{"files":[{"patch":"@@ -23,1 +23,3 @@\n-6. Configure libxml.\n+6. Prerequisites to compile libxml: libtool, autoconf, automake\n+\n+7. Configure libxml.\n@@ -27,1 +29,1 @@\n-6.1 Copy `libxml\\src\\include\\libxml\\xmlversion.h` to `libxml\\mac\\include\\libxml\\xmlversion.h` and follow same guidelines as Windows to retain changes from our repo.\n+7.1 Copy `libxml\\src\\include\\libxml\\xmlversion.h` to `libxml\\mac\\include\\libxml\\xmlversion.h` and follow same guidelines as Windows to retain changes from our repo.\n@@ -29,1 +31,1 @@\n-6.2 Copy libxml\\src\\config.h to libxml\\mac\\config.h\n+7.2 Copy libxml\\src\\config.h to libxml\\mac\\config.h\n@@ -32,1 +34,3 @@\n-7. Configure libxml.\n+8. Prerequisites to compile libxml: libtool, autoconf, automake\n+\n+9. Configure libxml.\n@@ -36,1 +40,1 @@\n-7.1 Copy `libxml\\src\\include\\libxml\\xmlversion.h` to `libxml\\linux\\include\\libxml\\xmlversion.h` and follow same guidelines as Windows to retain changes from our repo.\n+9.1 Copy `libxml\\src\\include\\libxml\\xmlversion.h` to `libxml\\linux\\include\\libxml\\xmlversion.h` and follow same guidelines as Windows to retain changes from our repo.\n@@ -38,1 +42,1 @@\n-7.2 Copy libxml\\src\\config.h to libxml\\linux\\config.h\n+9.2 Copy libxml\\src\\config.h to libxml\\linux\\config.h\n@@ -40,1 +44,1 @@\n-8. Helper commands for removing tabs and trailing whitespaces from source files(.h and .c).\n+10. Helper commands for removing tabs and trailing whitespaces from source files(.h and .c).\n@@ -42,1 +46,1 @@\n-8.1 > cd modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\n+10.1 > cd modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\n@@ -44,1 +48,1 @@\n-8.2 Remove tabs from source files:\n+10.2 Remove tabs from source files:\n@@ -46,2 +50,2 @@\n-    > find src\/ -name \"*.c\" -type f -exec bash -c 'expand -t 4 \"$0\" | sponge \"$0\"' {} \\;\n-    > find src\/ -name \"*.h\" -type f -exec bash -c 'expand -t 4 \"$0\" | sponge \"$0\"' {} \\;\n+    > find src\/ -name \"*.c\" -type f -exec bash -c 'expand -t 8 \"$0\" | sponge \"$0\"' {} \\;\n+    > find src\/ -name \"*.h\" -type f -exec bash -c 'expand -t 8 \"$0\" | sponge \"$0\"' {} \\;\n@@ -49,1 +53,1 @@\n-8.3 Remove trailing whitespaces from source files:\n+10.3 Remove trailing whitespaces from source files:\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/UPDATING.txt","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n-\/* Define to 1 if you have the <dirent.h> header file. *\/\n+\/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.\n+   *\/\n@@ -32,1 +33,1 @@\n-\/* #undef HAVE_DLOPEN *\/\n+#define HAVE_DLOPEN \/**\/\n@@ -64,6 +65,0 @@\n-\/* Define if isinf is there *\/\n-#define HAVE_ISINF \/**\/\n-\n-\/* Define if isnan is there *\/\n-#define HAVE_ISNAN \/**\/\n-\n@@ -73,3 +68,0 @@\n-\/* Define if pthread library is there (-lpthread) *\/\n-#define HAVE_LIBPTHREAD \/**\/\n-\n@@ -133,1 +125,1 @@\n-\/* #undef HAVE_RAND_R 1 *\/\n+#define HAVE_RAND_R 1\n@@ -237,1 +229,1 @@\n-\/* #undef ICONV_CONST *\/\n+#define ICONV_CONST\n@@ -249,1 +241,1 @@\n-#define PACKAGE_NAME \"\"\n+#define PACKAGE_NAME \"libxml2\"\n@@ -252,1 +244,1 @@\n-#define PACKAGE_STRING \"\"\n+#define PACKAGE_STRING \"libxml2 2.9.13\"\n@@ -255,1 +247,1 @@\n-#define PACKAGE_TARNAME \"\"\n+#define PACKAGE_TARNAME \"libxml2\"\n@@ -261,1 +253,1 @@\n-#define PACKAGE_VERSION \"\"\n+#define PACKAGE_VERSION \"2.9.13\"\n@@ -276,1 +268,1 @@\n-#define VERSION \"2.9.12\"\n+#define VERSION \"2.9.13\"\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/linux\/config.h","additions":10,"deletions":18,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#define LIBXML_DOTTED_VERSION \"2.9.12\"\n+#define LIBXML_DOTTED_VERSION \"2.9.13\"\n@@ -39,1 +39,1 @@\n-#define LIBXML_VERSION 20912\n+#define LIBXML_VERSION 20913\n@@ -46,1 +46,1 @@\n-#define LIBXML_VERSION_STRING \"20912\"\n+#define LIBXML_VERSION_STRING \"20913\"\n@@ -51,1 +51,1 @@\n- * extra version information, used to show a CVS compilation\n+ * extra version information, used to show a git commit description\n@@ -61,1 +61,1 @@\n-#define LIBXML_TEST_VERSION xmlCheckVersion(20912);\n+#define LIBXML_TEST_VERSION xmlCheckVersion(20913);\n@@ -390,1 +390,1 @@\n-#define LIBXML_MODULE_EXTENSION \"\"\n+#define LIBXML_MODULE_EXTENSION \".so\"\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/linux\/include\/libxml\/xmlversion.h","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#define LIBXML_DOTTED_VERSION \"2.9.12\"\n+#define LIBXML_DOTTED_VERSION \"2.9.13\"\n@@ -39,1 +39,1 @@\n-#define LIBXML_VERSION 20912\n+#define LIBXML_VERSION 20913\n@@ -46,1 +46,1 @@\n-#define LIBXML_VERSION_STRING \"20912\"\n+#define LIBXML_VERSION_STRING \"20913\"\n@@ -61,1 +61,1 @@\n-#define LIBXML_TEST_VERSION xmlCheckVersion(20912);\n+#define LIBXML_TEST_VERSION xmlCheckVersion(20913);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/mac\/include\/libxml\/xmlversion.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,5 +0,0 @@\n-Daniel Veillard <daniel@veillard.com>\n-Bjorn Reese <breese@users.sourceforge.net>\n-William Brack <wbrack@mmm.com.hk>\n-Igor Zlatkovic <igor@zlatkovic.com> for the Windows port\n-Aleksey Sanin <aleksey@aleksey.com>\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/AUTHORS","additions":0,"deletions":5,"binary":false,"changes":5,"status":"deleted"},{"patch":"@@ -1,19678 +0,0 @@\n-Fri Jul 10 16:11:34 CEST 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fix a regression in entity parsing when using the reader\n-\t  introduced because we were not reusing _private on entities parsing\n-\t  context\n-\n-Thu Jul  9 10:21:00 CEST 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\tAleksey Sanin support for c14n 1.1\n-\t* c14n.c include\/libxml\/c14n.h: adds support for C14N 1.1,\n-\t  new flags at the API level\n-\t* runtest.c Makefile.am testC14N.c xmllint.c: add support in CLI\n-\t  tools and test binaries\n-\t* result\/c14n\/1-1-without-comments\/* test\/c14n\/1-1-without-comments\/*:\n-\t  add a new batch of tests\n-\n-Thu Jul  9 08:52:35 CEST 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* config.h.in: update of libtool seems to have modified it\n-\t* python\/libxml2class.txt: python update modified the order\n-\t  of classes apparently\n-\n-Thu Jul  9 08:43:06 CEST 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: avoid calling xmlAddID with NULL values\n-\t* parser.c: add a few xmlInitParser in some entry points\n-\n-Fri Jun 19 19:51:08 CEST 2009 Rob Richards <rrichards@cdatazone.org>\n-\n-\t* parser.c: use options from current parser context when creating \n-\t  a parser context within xmlParseCtxtExternalEntity\n-\t* xmlwriter.c: fix error message when unable to create output file\n-\n-Thu Jun  4 11:17:23 CEST 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* c14n.c debugXML.c doc\/examples\/io2.c parser.c schematron.c\n-\t  valid.c xmlschemas.c xmlwriter.c xpath.c: use %s to printf string\n-\t  patch by Christian Persch, fixes #581612\n-\n-Thu Jun  4 11:06:07 CEST 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c threads.c: change the threading initialization sequence\n-\t  as suggested by Igor Novoseltsev to avoid crash if xmlInitParser()\n-\t  is called from a thread which is not the main one, should fix\n-\t  #584605\n-\n-Fri May 15 17:54:48 CEST 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: make sure we keep line numbers fixes #580705\n-\t  based Aaron Patterson patch\n-\n-Tue May 12 09:13:58 CEST 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: a broken HTML table attributes initialization,\n-\t  fixes #581803, by Roland Steiner <rolandsteiner@google.com>\n-\n-Tue May 12 08:54:20 CEST 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml2.doap: adding RDF dope file.\n-\n-Tue May 12 08:42:52 CEST 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: adapt the extra version detection code to git\n-\n-Wed Apr 29 16:09:38 CEST 2009 Rob Richards <rrichards@cdatazone.org>\n-\n-\t* parser.c: do not set error code in xmlNsWarn\n-\n-Wed Apr 15 11:18:24 CEST 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/parser.h include\/libxml\/xmlwriter.h\n-\t  include\/libxml\/relaxng.h include\/libxml\/xmlversion.h.in\n-\t  include\/libxml\/xmlwin32version.h.in include\/libxml\/valid.h\n-\t  include\/libxml\/xmlschemas.h include\/libxml\/xmlerror.h: change\n-\t  ATTRIBUTE_PRINTF into LIBXML_ATTR_FORMAT to avoid macro name\n-\t  collisions with other packages and headers as reported by\n-\t  Belgabor and Mike Hommey\n-\n-Thu Apr  2 13:57:15 CEST 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c: fix structured error handling problems #564217\n-\n-Thu Mar 26 19:08:08 CET 2009 Rob Richards <rrichards@cdatazone.org>\n-\n-\t* parser.c: use options from current parser context when creating \n-\t  an entity parser context\n-\n-Wed Mar 25 11:40:34 CET 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/*: updated SVN URL for GNOME as pointed by Vincent Lefevre\n-\t  and regenerated docs\n-\n-Wed Mar 25 11:21:26 CET 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: hide the nbParse* variables used for debugging\n-\t  as pointed by Mike Hommey\n-\n-Wed Mar 25 10:50:05 CET 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/wsockcompat.h win32\/Makefile.bcb xpath.c: fixes for\n-\t  Borland\/CodeGear\/Embarcadero compilers by Eric Zurcher\n-\n-Wed Mar 25 10:43:07 CET 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: xmlXPathRegisterNs should not allow enpty prefixes\n-\n-Mon Mar 23 20:27:15 CET 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: add a missing check in xmlAddSibling, patch by Kris Breuker\n-\t* xmlIO.c: avoid xmlAllocOutputBuffer using XML_BUFFER_EXACT which\n-\t  leads to performances problems especially on Windows.\n-\n-Tue Mar  3 14:30.28 HKT 2009 William Brack <wbrack@mmm.com.hk>\n-\n-\t* trio.h: changed include of config.h to be surrounded by\n-\t  quotation marks #570806\n-\n-Sat Feb 21 10:20:34 CET 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* threads.c parser.c: more warnings about xmlCleanupThreads and\n-\t  xmlCleanupParser to avoid troubles like #571409\n-\n-Fri Feb 20 09:40:04 CET 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlwriter.c: cleanups and error reports when xmlTextWriterVSprintf\n-\t  fails, by Jinmei Tatuya\n-\n-Fri Feb 20 09:18:56 CET 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlwriter.c: remove a couple of leaks on errors reported by\n-\t  Jinmei Tatuya\n-\n-Sun Jan 18 22:37:59 CET 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in doc\/xml.html doc\/*: preparing 0.7.3 release\n-\t* include\/libxml\/parserInternals.h SAX2.c: fix a typo in a name\n-\n-Sun Jan 18 21:48:28 CET 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/parser.h include\/libxml\/xmlwriter.h\n-\t  include\/libxml\/relaxng.h include\/libxml\/xmlversion.h.in\n-\t  include\/libxml\/xmlwin32version.h.in include\/libxml\/valid.h\n-\t  include\/libxml\/xmlschemas.h include\/libxml\/xmlerror.h:\n-\t  port patch from Marcus Meissner to add gcc checking for\n-\t  printf like functions parameters, should fix #65068\n-\t* doc\/apibuild.py doc\/*: modified the script accordingly\n-\t  and regenerated\n-\t* xpath.c xmlmemory.c threads.c: fix a few warnings\n-\n-Sun Jan 18 20:40:42 CET 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlwin32version.h.in: windows header should\n-\t  get the same define\n-\n-Sun Jan 18 18:22:33 CET 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlversion.h.in include\/libxml\/xmlmemory.h:\n-\t  apply patch from Marcus Meissner to add gcc attribute alloc_size\n-\t  should fix #552505\n-\t* doc\/apibuild.py doc\/* testapi.c: regenerate the API\n-\t* include\/libxml\/parserInternals.h: fix a comment problem raised\n-\t  by apibuild.py\n-\n-Sun Jan 18 16:39:01 CET 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* threads.c: also remove pthread key when stopping thread\n-\t  support, patch based on Alex Ott one should fix #564723\n-\n-Sun Jan 18 15:55:18 CET 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* threads.c: patch from Daniel Zimmermann fixing a memory leak\n-\t  in an edge case, solves #562230\n-\n-Sun Jan 18 15:06:05 CET 2009 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/parserInternals.h SAX2.c: add a new define\n-\t  XML_MAX_TEXT_LENGTH limiting the maximum size of a single text\n-\t  node, the defaultis 10MB and can be removed with the HUGE\n-\t  parsing option\n-\n-Mon Jan 05 18:28:41 CET 2009 Rob Richards <rrichards@cdatazone.org>\n-\n-\t* include\/libxml\/parser.h parser.c: add XML_PARSE_OLDSAX parser \n-\t  option to enable pre 2.7 SAX behavior.\n-\n-Wed Dec 31 23:11:37 CET 2008 Rob Richards <rrichards@cdatazone.org>\n-\n-\t* tree.c: set doc on last child tree in xmlAddChildList for \n-\t  bug #546772. Fix problem adding an attribute via with xmlAddChild \n-\t  reported by Kris Breuker.\n-\n-Sun Dec 27 14:16:13 CET 2008 Rob Richards <rrichards@cdatazone.org>\n-\n-\t* xmlwriter.c: fix indenting in xmlTextWriterFullEndElement for \n-\t  bug# 554353.\n-\n-Thu Nov 27 16:24:52 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/tree.h tree.c python\/generator.py: adds\n-\t  element traversal support\n-\t* valid.c: avoid a warning\n-\t* doc\/*: regenerated\n-\n-Mon Nov 17 16:56:18 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c parser.c: fix for CVE-2008-4226, a memory overflow\n-\t  when building gigantic text nodes, and a bit of cleanup\n-\t  to better handled out of memory problem in that code.\n-\t* tree.c: fix for CVE-2008-4225, lack of testing leads to\n-\t  a busy loop test assuming one have enough core memory.\n-\n-Thu Nov  6 14:34:35 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: Matthias Kaehlcke reported a build problem when\n-\t  not compiling HTML support in.\n-\n-Fri Oct 17 15:24:08 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in doc\/Makefile.am: patch from Adrian Bunk which\n-\t  adds --disable-rebuild-docs to avoid rebuilding them\n-\n-Fri Oct  3 09:43:45 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in doc\/* NEWS: preparing the release of 2.7.2\n-\t* dict.c: fix the Solaris portability issue\n-\t* parser.c: additional cleanup on #554660 fix\n-\t* test\/ent13 result\/ent13* result\/noent\/ent13*: added the\n-\t  example in the regression test suite.\n-\t* HTMLparser.c: handle leading BOM in htmlParseElement()\n-\n-Thu Oct  2 22:53:39 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fix a nasty bug introduced when cleaning up\n-\t  entities processing in 2.7.x , fixes #554660\n-\n-Thu Sep 25 18:04:20 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fix an HTML parsing error on large data sections\n-\t  reported by Mike Day\n-\t* test\/HTML\/utf8bug.html result\/HTML\/utf8bug.html.err\n-\t  result\/HTML\/utf8bug.html.sax result\/HTML\/utf8bug.html: add the\n-\t  reproducer to the test suite\n-\n-Thu Sep 25 17:35:57 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runxmlconf.c: fix compilation if XPath is not included\n-\n-Thu Sep 25 16:54:04 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: patch from Riccardo Scussat fixing custom error\n-\t  handlers problems.\n-\n-Thu Sep 25 16:30:11 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlsave.h xmlsave.c: new options to serialize\n-\t  as XML\/HTML\/XHTML and restore old entry point behaviours\n-\n-Mon Sep  1 16:49:05 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xml.html doc\/news.html configure.in python\/setup.py NEWS:\n-\t  prepare release of 2.7.1\n-\n-Mon Sep  1 15:35:13 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* schematron.c xpath.c: applied a couple of patches from Martin\n-\t  avoiding some leaks, fixinq QName checks in XPath, XPath debugging\n-\t  and schematron code cleanups.\n-\t* python\/tests\/Makefile.am python\/tests\/xpathleak.py: add the\n-\t  specific regression tests, just tweak it to avoid output by default\n-\n-Mon Sep  1 15:02:05 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* trionan.c: Borland C fix from Moritz Both\n-\t* testapi.c: regenerate, workaround a problem for buffer testing\n-\t* xmlIO.c HTMLtree.c: new internal entry point to hide even better\n-\t  xmlAllocOutputBufferInternal\n-\t* tree.c: harden the code around buffer allocation schemes\n-\t* parser.c: restore the warning when namespace names are not absolute\n-\t  URIs\n-\t* runxmlconf.c: continue regression tests if we get the expected\n-\t  number of errors\n-\t* Makefile.am: run the python tests on make check\n-\t* xmlsave.c: handle the HTML documents and trees\n-\t* python\/libxml.c: convert python serialization to the xmlSave APIs\n-\t  and avoid some horrible hacks\n-\n-Sat Aug 30 16:58:40 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in, doc\/*: preparing 2.7.0 release\n-\t* tree.c: remove some testing traces\n-\t* parser.c xmlIO.c xmlschemas.c: remove some warnings\n-\n-Sat Aug 30 14:50:16 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/tree.h tree.c: make a new kind of buffer where\n-\t  shrinking and adding in head can avoid reallocation or full\n-\t  buffer memmoves\n-\t* encoding.c xmlIO.c: use the new kind of buffers for output\n-\t  buffers\n-\n-Sat Aug 30 10:18:13 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/* testapi.c: regenerated\n-\n-Fri Aug 29 21:53:12 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/examples\/reader3.c: patch from  Robert Schwebel , allows to\n-\t  compile the example if configured without output support fixes\n-\t  #545582\n-\t* Makefile.am: add testrecurse to the make check tests\n-\t* HTMLparser.c: if the parser got a encoding argument it should be\n-\t  used over what the meta specifies, patch fixing #536346\n-\n-Fri Aug 29 14:41:38 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: a couple more fixes\n-\t* nanohttp.c nanoftp.c: patch from Andreas Färber to compile on Haiku\n-\t  fixes #527880\n-\t* doc\/examples\/*: regenerated\n-\n-Thu Aug 28 17:31:46 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c include\/libxml\/parser.h: completely different fix for\n-\t  the recursion detection based on entity density, big cleanups\n-\t  in the entity parsing code too\n-\t* result\/*.sax*: the parser should not ask for used defined versions\n-\t  of the predefined entities\n-\t* testrecurse.c: automatic test for entity recursion checks\n-\t* Makefile.am: added testrecurse\n-\t* test\/recurse\/lol* test\/recurse\/good*: a first set of tests for\n-\t  the recursion\n-\n-Wed Aug 27 21:55:34 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlerror.h parser.c: a bit of cleanup and\n-\t  added checks based on the regression tests of the xmlconf suite\n-\n-Wed Aug 27 19:22:35 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: bug in parsing RFC 3986 uris with port numbers\n-\n-Wed Aug 27 17:30:48 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in Makefile.am: add an --with-coverage configure option\n-\t  and a 'make cov' target based on gcc profiling and the lcov\n-\t  tool. Currently at 68.9% coverage out of 'make check' and \n-\t  runsuite executions.\n-\t* xmlreader.c: remove warnings due to C++ comments\n-\n-Wed Aug 27 15:00:54 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/parserInternals.h parser.c: cleanup entity\n-\t  pushing error handling based on a patch from Ashwin\n-\n-Wed Aug 27 13:41:26 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* threads.c: fix a small initialization problem raised by Ashwin\n-\t* testapi.c gentest.py: increase testing especially for document\n-\t  with an internal subset, and entities\n-\t* tree.c: fix a deallocation issue when unlinking entities from\n-\t  a document.\n-\t* valid.c: fix a missing entry point test not found previously.\n-\t* doc\/*: regenerated the APIs, docs etc.\n-\n-Tue Aug 26 15:02:58 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/parser.h parser.c xmllint.c: strengthen some\n-\t  of the internal parser limits, add an XML_PARSE_HUGE option\n-\t  to bypass them all. More internal parser limits will still need\n-\t  to be added.\n-\n-Tue Aug 26 09:42:08 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: add the testchar to 'make check'\n-\t* xmlschemas.c: Volker Grabsch pointed out a typo\n-\t* xmlregexp.c: production [19] from XML Schemas regexps were a\n-\t  mistake removed in version REC-xmlschema-2-20041028, Volker Grabsch\n-\t  provided a patch to remove it\n-\t* test\/schemas\/regexp-char-ref_0.xml test\/schemas\/regexp-char-ref_0.xsd\n-\t  test\/schemas\/regexp-char-ref_1.xsd result\/schemas\/regexp-char-ref_0_0\n-\t  result\/schemas\/regexp-char-ref_1_0: Volker Grabsch also provided\n-\t  regression tests for this\n-\n-Tue Aug 26 09:25:39 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/parser.h xinclude.c xmllint.c: patch based on\n-\t  Wieant Nielander contribution to add the option of not doing\n-\t  URI base fixup in XInclude\n-\n-Mon Aug 25 16:52:53 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: applied patch from Aswin to fix tree skipping\n-\t* include\/libxml\/entities.h entities.c: fixed a comment and\n-\t  added a new xmlNewEntity() entry point\n-\t* runtest.c: be less verbose\n-\t* tree.c: space and tabs cleanups\n-\n-Mon Aug 25 10:56:30 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/entities.h entities.c SAX2.c parser.c: rework\n-\t  the patch to avoid some ABI issue with people allocating\n-\t  entities structure directly\n-\n-Wed Aug 20 19:02:01 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/parser.h include\/libxml\/entities.h entities.c\n-\t  parserInternals.c parser.c: fix for CVE-2008-3281\n-\n-Sun Aug 10 17:06:13 CEST 2008 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* dict.c: fix non GNUC builds.\n-\n-Fri Aug  8 14:13:06 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* makefile.am: adding a check-valgrind target\n-\n-Fri Aug  8 14:01:59 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am testdict.c: add the new test in 'make check' and\n-\t  update it to check subdictionaries processing.\n-\n-Fri Aug  8 12:07:20 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testdict.c: added a program to regression test the dictionary code\n-\t* dict.c: improve the lookup efficiency by caching the key.\n-\n-Thu Aug  7 18:30:55 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* dict.c: chased and found a couple of nasty issues\n-\n-Thu Aug  7 15:51:31 CEST 2008 Sven Herzberg <sven@imendio.com>\n-\n-\tBug 546629 – runtests doesn't pass on my mac\n-\tReviewed by William M. Brack.\n-\n-\t* runtest.c: use libpthread on Mac OS X as well\n-\n-Wed Aug  6 12:24:33 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: allow [ and ] in fragment identifiers, 3986 disallow them\n-\t  but it's widely used for XPointer, and would break DocBook\n-\t  processing among others\n-\n-Wed Aug  6 11:32:21 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* dict.c: change the big key algorithm to work properly with QName\n-\t  too, fix a bug with dict size and sub dictionaries\n-\n-Mon Aug  4 17:27:27 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c include\/libxml\/uri.h: rewrite the URI parser to update to\n-\t  rfc3986 (from 2396)\n-\t* test\/errors\/webdav.xml result\/errors\/webdav.xml*: removed the\n-\t  error test, 'DAV:' is a correct URI under 3986\n-\t* Makefile.am: small cleanup in make check\n-\n-Thu Jul 31 21:49:45 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runxmlconf.c: more progresses against the official regression tests\n-\t* runsuite.c: small cleanup for non-leak reports\n-\t* include\/libxml\/tree.h: parsing flags and other properties are\n-\t  now added to the document node, this is generally useful and\n-\t  allow to make Name and NmToken validations based on the parser\n-\t  flags, more specifically the 5th edition of XML or not\n-\t* HTMLparser.c tree.c: small side effects for the previous changes\n-\t* parser.c SAX2.c valid.c: the bulk of the changes are here,\n-\t  the parser and validation behaviour can be affected, parsing\n-\t  flags need to be copied, lot of changes. Also fixing various\n-\t  validation problems in the regression tests.\n-\n-Thu Jul 31 10:15:53 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runxmlconf.c: added a skipped list, insert rmt-ns10-035\n-\t* Makefile.am: improve 'make check'\n-\t* include\/libxml\/xmlerror.h parser.c: clean up namespace errors\n-\t  checking and reporting, errors when a document is labelled\n-\t  as UTF-16 while it is parsed as UTF-8 and no encoding was given\n-\t  explicitly.\n-\t* result\/errors\/webdav.xml.*: some warnings are no recategorized\n-\t  as Namespace errors\n-\n-Wed Jul 30 14:55:54 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlmemory.h xmlmemory.c: add xmlMemDisplayLast to\n-\t  help debug incremental memory leaks, and some cleanups\n-\t* runxmlconf.c: use that new call and avoid ever touching the\n-\t  system catalog in the regression tests\n-\n-Wed Jul 30 14:33:33 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c include\/libxml\/xmlerror.h: an XML-1.0 document can't load\n-\t  an 1.1 entity\n-\t* runxmlconf.c: when using entities make sure we load them\n-\n-Tue Jul 29 18:43:07 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fix a bug not detecting cross entity comments probably\n-\t  when comment parsing got optimized.\n-\t* Makefile.am: add make check\n-\t* runxmlconf.c: fix the log file name\n-\n-Tue Jul 29 18:09:26 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runxmlconf.c Makefile.am: add a C program to run the W3C test\n-\t  suite, work in progress\n-\t* xmllint.c: add a new option --oldxml10 to use the old parser\n-\t* parser.c: fix the XML_PARSE_OLD10 processing of the new option\n-\t  and a bug in version parsing\n-\n-Tue Jul 29 11:12:40 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: space and tabs cleanup\n-\n-Tue Jul 29 10:59:36 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/parser.h include\/libxml\/xmlerror.h parser.c:\n-\t  implement XML-1.0 5th edition, add parser option XML_PARSE_OLD10\n-\t  to stick to old behaviour\n-\t* testapi.c gentest.py: modified slightly and regenerated\n-\t* Makefile.am: add testchar\n-\n-Thu Jul 24 16:57:20 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am testchar.c Makefile.tests README.tests: add a\n-\t  new regression test program for testing character ranges and\n-\t  UTF8 encoding\/decoding\n-\n-Wed Jul 23 15:32:39 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in: fix the build root\n-\n-Wed Jul 16 22:28:48 PDT 2008 William Brack <wbrack@mmm.com.hk>\n-\n-\t* pattern.c: fix problem with xmlStreamPop when pattern includes\n-\t  a \".\" element (see discussion on libxslt list)\n-\n-Mon Jul  7 15:49:59 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c: fix line number on text nodes, problem raised by Ralf Junker\n-\n-Sun Jun 29 17:04:28 CEST 2008 Rob Richards <rrichards@ctindustries.net>\n-\t* xmlschemas.c: fix crash with invalid whitespace facet\n-\n-Wed Jun 11 10:13:02 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xml.html doc\/FAQ.html: add a section in the FAQ about\n-\t  multithread and xmlCleanupParser\n-\n-Tue Jun 10 16:52:17 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: apply a couple of fixes based on a Coverity report\n-\t  forwarded by Derrick Price.\n-\t* VxWorks\/README VxWorks\/Makefile VxWorks\/build.sh: instructions\n-\t  Makefile, and shell script to build on VxWorks 6.4+ provided by\n-\t  Jim Wert.\n-\n-Tue Jun  3 18:07:13 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/setup.py: apply patch from Martin fixing\n-\t  python whitespaces\n-\t* NEWS: following previous commit rebuilt now in UTF-8\n-\n-Mon Jun  2 17:39:42 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* ChangeLog: patch from Hans de Goede to switch the file to UTF-8\n-\t* doc\/news.xsl: switch to generate the NEWS file in UTF-8 instead of\n-\t  ISO-8859-1\n-\n-Mon May 12 15:12:44 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: avoid a regexp crash, should fix #523738\n-\n-Mon May 12 14:56:06 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c runtest.c testapi.c include\/libxml\/xmlreader.h\n-\t  python\/types.c python\/libxml_wrap.h python\/libxml.c: fx compilation\n-\t  when configured without the reader should fix #513110\n-\t* doc\/*: regenerated\n-\n-Sat May  3 14:33:29 CEST 2008 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* dict.c: check for stdint.h and define types when using MSVC\n-\n-Mon Apr 28 20:06:12 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c: applied patch from Ashwin to avoid a potential\n-\t  double-free\n-\n-Thu Apr 24 13:56:53 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: applied patch from Ashwin fixing a number of realloc problems\n-\t* HTMLparser.c: improve handling for misplaced html\/head\/body\n-\n-Tue Apr 22 10:27:17 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* dict.c: improvement on the hashing of the dictionary, with visible\n-\t  speed up as the number of strings in the hash increases, work from\n-\t  Stefan Behnel\n-\n-Fri Apr 11 14:44:00 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlschemas.h xmlschemas.c: added new function\n-\t  xmlSchemaValidCtxtGetParserCtxt based on Holger Kaelberer patch\n-\t* doc\/apibuild.py doc\/*: regenerated the doc, chased why the new\n-\t  function didn't got any documentation, added more checking in the\n-\t  generator\n-\t* include\/libxml\/relaxng.h include\/libxml\/schematron.h\n-\t  include\/libxml\/xmlschemas.h include\/libxml\/c14n.h\n-\t  include\/libxml\/xmlregexp.h include\/libxml\/globals.h\n-\t  include\/libxml\/xmlreader.h threads.c xmlschemas.c: various changes\n-\t  and cleanups following the new reports\n-\n-\n-Thu Apr 10 10:07:00 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: extend the cleanup rule\n-\t* xmlschemas.c: space cleanup\n-\n-Wed Apr  9 19:43:25 CEST 2008 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* include\/wsockcompat.h: support older win32 platforms when building\n-\t  with newer versions of VS\n-\n-Tue Apr  8 16:56:07 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in NEWS doc\/*: preparing release of 2.6.32\n-\n-Tue Apr  8 10:19:01 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fix a bug introduced when fixing #438208 and reported by\n-\t  Ashwin\n-\t* python\/generator.py: fix an infinite loop bug\n-\n-Mon Apr  7 14:44:51 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: fix a link to XmlNodeType doc reported by Martijn Arts\n-\t* docs\/*: rebuilt\n-\n-Fri Apr  4 18:09:50 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: improve the *Recover* functions documentation\n-\n-Thu Apr  3 14:57:15 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: patch from Mark Rowe fixing BOM or encoding detection\n-\t  in external parsed entities, should fix #440415\n-\n-Thu Apr  3 13:16:01 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fix some problems with the *EatName functions when\n-\t  running out of memory raised by Eric Schrock , should fix #438208\n-\n-Thu Apr  3 12:41:29 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: horror around the definition of the lexical\n-\t  values for decimal and derived types, fixing to reject empty \n-\t  values, should fix #503268\n-\n-Thu Apr  3 11:44:57 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: buffer may not be  large enough to convert to\n-\t  UCS4, patch from Christian Fruth , fixes #504015\n-\n-Thu Apr  3 11:02:02 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: apparently it's okay to forget the semicolon after\n-\t  entity refs in HTML, fixing char refs parsing accordingly based on\n-\t  T. Manske patch, this should fix #517653\n-\n-Thu Apr  3 09:30:29 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c: avoid a scary realloc() loop should fix #520383\n-\n-Thu Apr  3 08:22:52 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: more realloc problems pointed out by Ashwin\n-\n-Thu Apr  3 07:40:13 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xstc\/Makefile.am: applied patch from Mike Hommey fixing distclean,\n-\t  fixes #520387\n-\n-Thu Apr  3 06:52:32 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xpath.h: small doc improvement for xmlXPathContext\n-\t  from Jack Jansen, fixes #524759\n-\t* doc\/newapi.xsl doc\/*: fixed a problem and regenerated the docs\n-\n-Tue Apr  1 09:59:22 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: two patches from Alvaro Herrera to avoid problem when\n-\t  running out of memory in XPath evaluations.\n-\n-Mon Mar 31 11:23:19 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: lot of out of memory handling fixes from Ashwin\n-\t* elfgcchack.h doc\/elfgcchack.xsl: work around a problem with xmlDllMain\n-\t* include\/libxml\/threads.h: indenting cleanups\n-\n-Mon Mar 31 10:25:37 CEST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c docs\/*: trying to clarify even more the xmlCleanupParser()\n-\t  use and the memory documentation\n-\n-Wed Mar 26 18:39:58 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: changes based on  Alex Khesin patch where xmlParseCharRef\n-\t  seems to not be checked correctly, fixes #520198\n-\n-Wed Mar 26 15:03:49 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: patch from Ashwin to avoid a problem of attribute\n-\t  redefinition in the DTD. Remove a warning too.\n-\n-Wed Mar 26 14:38:31 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: fix a problem in externalSubsetSplit with a patch\n-\t  from Ashwin\n-\n-Tue Mar 25 17:48:02 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fix various attribute normalisation problems reported\n-\t  by Ashwin\n-\t* result\/c14n\/without-comments\/example-4\n-\t  result\/c14n\/with-comments\/example-4: this impacted the result of\n-\t  two c14n tests :-\\\n-\t* test\/att9 test\/att10 test\/att11 result\/\/att9* result\/\/att10*\n-\t  result\/\/att11*: added 3 specific regression tests coming from the\n-\t  XML spec revision and from Ashwin\n-\n-Tue Mar 25 14:20:49 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: fix saving for file:\/\/\/X:\/ URI embedding Windows file paths\n-\t  should fix #524253 \n-\n-Mon Mar 24 21:42:33 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fix a problem reported by Ashwin for system parameter\n-\t  entities referenced from entities in external subset, add a\n-\t  specific loading routine.\n-\t* test\/valid\/dtds\/external.ent test\/valid\/dtds\/external2.ent\n-\t  test\/valid\/t11.xml result\/valid\/t11.xml*: added the test to\n-\t  the regression suite\n-\n-Mon Mar 24 15:04:54 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: fix an XML Schemas crash raised by Stefan Behnel\n-\t  when testing with W3C test suite\n-\n-Mon Mar 24 12:12:00 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* threads.c: check some allocation with Ashwin patch\n-\n-Wed Mar 19 16:41:52 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* vms\/build_libxml.com: update from Tycho Hilhorst, should fix #523378\n-\n-Tue Mar 18 09:23:05 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* threads.c: check some malloc returns with Ashwin patch, add\n-\t  error messages and reindent the module.\n-\n-Fri Mar 14 15:28:43 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: patch from Ashwin removing duplicate tests\n-\n-Fri Mar 14 13:44:29 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/schematron.h include\/libxml\/xmlerror.h schematron.c:\n-\t  applied patch from Tobias Minich to allow plugin schematron error\n-\t  reporting in the normal error system, should fix #513998\n-\n-Fri Mar 14 11:52:09 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c xinclude.c: patch from Vasily Chekalkin fixes memory\n-\t  leaks, should fix 512647\n-\n-Thu Mar 13 08:17:58 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: found a nasty bug in regexp automata build,\n-\t  reported by Ashwin and Bjorn Reese\n-\n-Wed Mar 12 18:56:22 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: patch from Arnold Hendriks improving parsing of\n-\t  html within html bogus data, still not a complete fix though\n-\n-Wed Mar 12 10:22:01 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/types.c: fix a memory error when using namespace nodes\n-\t  returned from XPath queries, should fix #521699\n-\t* python\/tests\/Makefile.am python\/tests\/xpathns.py: add a specific\n-\t  regression test for it\n-\n-Mon Mar 10 16:25:32 CET 2008 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* include\/win32config.h: add ICONV_CONST define for win32 build\n-\t  to satisfy encoding.c change in rev 3693\n-\n-Fri Mar  7 17:45:27 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlsave.c parser.c: fix handling of empty CDATA nodes as \n-\t  reported and discussed around #514181 and associated patches\n-\t* test\/emptycdata.xml result\/emptycdata.xml* \n-\t  result\/noent\/emptycdata.xml: added a specific test in the\n-\t  regression suite.\n-\n-Thu Mar  6 15:23:10 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: poblem with encoding detection for UTF-16 reported by\n-\t  Ashwin and found by Bill\n-\t* test\/valid\/dtds\/utf16b.ent test\/valid\/dtds\/utf16l.ent\n-\t  test\/valid\/UTF16Entity.xml result\/valid\/UTF16Entity.xml*: added\n-\t  the example to the regression tests\n-\n-Tue Mar  4 14:16:38 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlwriter.c: patch from Alex Khesin fixing CDATA output after\n-\t  a text node.\n-\t* parser.c: fixed the comment for xmlParserCleanup\n-\t* globals.c: fixed indentation\n-\n-Mon Feb 25 16:42:19 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testModule.c: patch from Florent Guiliani to fix build on\n-\t  SCO OpenServer\n-\n-Thu Feb 21 22:46:08 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c: made one of the changes suggested by Brian Krahmer\n-\t* testRegexp.c: allow to pass '--' on the command line to allow\n-\t  regexps starting with the character '-'\n-\n-Tue Feb 19 08:49:32 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/Makefile.am python\/tests\/Makefile.am: applied cleanup\n-\t  patches for cross compilation and MinGW from Roumen Petrov\n-\n-Sat Feb 16 11:06:54 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: fix output bug reported by Petr Pajas and analyzed by\n-\t  Bill\n-\n-Fri Feb 15 09:32:11 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlerror.h tree.c: patch from Julien Charbon\n-\t  to simplify the processing of xmlSetProp()\n-\n-Fri Feb 15 08:45:32 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* config.h.in configure.in encoding.c: patch from Roumen Petrov\n-\t  to detect if iconv() needs a const for the second parameter\n-\n-Fri Feb 15 08:41:31 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* macos\/src\/XMLTestPrefix2.h win32\/Makefile.msvc: EOL cleanups\n-\t  from Florent Guiliani\n-\n-Wed Feb 13 10:56:38 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlwriter.c: applied patch from Alfred Mickautsch to flush the\n-\t  output at the end of document.\n-\n-Fri Feb  8 11:57:03 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/examples\/examples.xml: regenerated, it was truncated.\n-\n-Fri Feb  8 11:47:18 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlmodule.c: apply simple patch from Carlo Bramini to avoid\n-\t  compilation problems with Mingw32\n-\n-Fri Feb  8 11:33:15 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: apply patch from Andrew Tosh to fix behaviour\n-\t  when '.' is used in a posCharGroup\n-\t* test\/schemas\/poschargrp0_0.* result\/schemas\/poschargrp0_0_0*:\n-\t  added the test to the regression suite\n-\n-Fri Feb  8 10:54:09 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* dict.c: applied patch from Florent Guilian to remove an\n-\t  useless mutex in the xmlDict structure.\n-\n-Wed Feb  6 17:00:20 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c: another leak reported by Ashwin\n-\t* xinclude.c: fixed the behaviour when XIncluding a fragment\n-\t  of the current document, patch from Chris Ryan\n-\n-Wed Feb  6 12:10:08 HKT 2008 William Brack <wbrack@mmm.com.hk>\n-\n-\t* nanohttp.c: added space for port number (when not 80) in\n-\t  xmlNanoHTTPMethodRedir, plus a few more comments. Should\n-\t  fix #514521.\n-\n-Tue Feb  5 09:41:46 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* schemas.c: apply fix suggested by Ashwin correcting a cut-n-paste\n-\t  error about the SAX callback in cdataBlockSplit when streaming\n-\t  XSD validation \n-\n-Tue Feb  5 09:36:46 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: applied a patch based on Petr Sumbera one to avoid a \n-\t  problem with paths starting with \/\/\n-\n-Mon Feb  4 17:48:30 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xml.html doc\/xmlmem.html: added a small section on returning\n-\t  memory to the kernel by compacting the heap provided by Wolfram Sang\n-\n-Fri Jan 25 20:01:42 CET 2007 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* include\/win32config.h win32\/Makefile.msvc: fix build under VS 2008.\n-\t  patch by David Wimsey\n-\n-Thu Jan 24 15:37:04 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fix a memory leak in internal subset parsing with\n-\t  a fix from Ashwin\n-\t* test\/errors\/content1.xml result\/errors\/content1.xml*:\n-\t  add test to regressions\n-\n-Fri Jan 11 09:00:09 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in doc\/*: preparing release of 2.6.31\n-\n-Fri Jan 11 08:58:49 CET 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: avoid a warning on 64bits introduced earlier\n-\t* parserInternals.c: make more checking on the UTF-8 input\n-\n-Fri Jan 11 15:37:05 CST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: avoid stopping parsing when encountering\n-\t  out of range characters in an HTML file, report and \n-\t  continue processing instead, should fix #472696\n-\n-Fri Jan 11 15:13:35 CST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* check-relaxng-test-suite2.py check-relaxng-test-suite.py\n-\t  Makefile.am python\/tests\/Makefile.am python\/Makefile.am\n-\t  check-xsddata-test-suite.py: patches from John Carr to\n-\t  start cleaning up 'make diskcheck' problems c.f. #506228\n-\n-Fri Jan 11 14:48:40 CST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: apply fix from Stefan Kost to avoid a crash\n-\t  in xmllint, fixes 504284\n-\n-Fri Jan 11 14:39:03 CST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xml2-config.in: apply patch from Fred Crozat to avoid\n-\t  outputting -L\/usr\/lib from xml2-config, fixes #497012\n-\n-Fri Jan 11 14:18:09 CST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fix definition for <embed> to avoid error\n-\t  when saving back, patch from Stefan Behnel fixing 495213\n-\n-Fri Jan 11 14:06:09 CST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: applied patch from Christian Schmidt fixing a \n-\t  column counter update problem, fixes #472696\n-\n-Fri Jan 11 13:22:14 CST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: handle a erroneous parsing of attributes in \n-\t  case said attribute has been redeclared in the DTD with a\n-\t  different type\n-\t* hash.c: fix the hash scanner to not crash if a first element\n-\t  from the hash list is been removed in the callback\n-\n-Wed Jan  9 10:15:50 CST 2008 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlwriter.c: fix indentation in xmlTextWriterFullEndElement,\n-\t  as raised by Felipe Pena, should fix #508156\n-\n-Tue Dec  6 11:07:42 CET 2007 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* pattern.c: fix crash from double free of name for bug #501760\n-\n-Fri Nov 23 11:47:48 CET 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* threads.c: remove unused variable in __xmlGlobalInitMutexLock\n-\t  reported by Hannes Eder\n-\n-Mon Nov 19 18:39:26 CET 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: remove a cut-and-paste copy error\n-\n-Fri Nov 16 11:55:36 CET 2007 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* globals.c threads.c include\/libxml\/threads.h: \n-\t  __xmlGlobalInitMutexDestroy() will free global_init_lock on Win32.\n-\t  Patch from Marc-Antoine Ruel.\n-\n-Tue Nov 13 21:26:27 CET 2007 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* schematron.c: fix crash\/leaks from xmlSchematronParse due to improper\n-\t  schema document ownership for bug #495215\n-\n-Tue Oct 30 21:24:55 CET 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlmemory.c: xmlFree(NULL) should not crash in debug mode\n-\t  should fix #491651\n-\n-Tue Oct 16 13:58:41 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testURI.c: add a debug option printing all the fields within\n-\t  the parsed URI structure\n-\n-Wed Oct 10 10:25:52 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlsave.c: fix to avoid a crash when dumping an attribute from\n-\t  an XHTML document, patch contributed to fix #485298\n-\n-Tue Aug 28 19:32:28 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: another nasty regexp case fixed.\n-\t* test\/regexp\/ranges2 result\/regexp\/ranges2: added to regression\n-\t  suite\n-\n-Fri Aug 24 10:58:58 HKT 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* nanohttp.c: Enhanced to include port number (if not == 80) on the\n-\t  \"Header:\" URL (bug #469681).\n-\t* xmlregexp.c: Fixed a typo causing a warning message.\n-\n-Thu Aug 23 22:48:20 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanohttp.c: fix an open() call with creation without 3rd argument\n-\t  hopefully that interface is never used.\n-\n-Thu Aug 23 17:00:49 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in doc\/*: preparing release of 2.6.30\n-\n-Thu Aug 23 20:58:28 HKT 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: fixed xmlXPathCompOpEvalPositionalPredicate problem\n-\t  with object caching (bug #469410)\n-\n-Thu Aug 23 11:28:38 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c test\/schemas\/*455953* result\/schemas\/bug455953*:\n-\t  applied patch from Frank Gross fixing Schemas IDC import bug\n-\t  #455953 and also add the test to the regression suite\n-\n-Wed Aug 22 18:29:42 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: try to fix for the nth time the automata generation\n-\t  in case of complex ranges. I suppose that time it is actually okay\n-\n-Tue Aug 14 15:51:05 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: aligned xmlSAXUserParseMemory() to match \n-\t  xmlSAXUserParseFile() logic based on Ashwin post, and ifdef\n-\t  cleanup\n-\n-Tue Aug 14 11:42:27 CEST 2007 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* xmlIO.c: fixed windows path determination (patch from\n-\t  Roland Schwarz, bug #462877)\n-\t* win32\/Makefile.mingw win32\/configure.js: fixed mingw build\n-\t  (patch from Roland Schwarz, bug #462877)\n-\n-Wed Aug  1 09:50:12 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed a parser bug where invalid char in comment may\n-\t  not be detected, reported by Ashwin Sinha\n-\t* test\/errors\/comment1.xml result\/errors\/comment1.xml*: added\n-\t  the example to the regression suite\n-\n-Thu Jul 26 13:42:26 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlsave.c: fixed problem reported on bug #460415\n-\n-Thu Jul 19 18:10:58 PDT 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* uri.c: applied patch from from Patrik Fimml.  Fixes bug #458268.\n-\n-Wed Jul 18 11:05:08 PDT 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xinclude.c: applied patch from bug #454608 from Patrik Fimml.\n-\t  Fixes bug #454608.\n-\n-Wed Jul 11 19:57:59 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: applied patch for xsi:nil from Frank Gross, this\n-\t  should fix bug #358125\n-\n-Wed Jul  4 17:44:20 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlwriter.c: patch from Dodji Seketeli to avoid a leak on repeated\n-\t  uses of xmlTextWriterStartDocument()\n-\n-Tue Jun 26 13:30:50 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: fix a crash on solaris when a printf %s with a NULL\n-\t  argument occurs, should fix #450936\n-\n-Wed Jun 13 13:33:38 PDT 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: fixed problem in previous fix to xmlXPathNodeSetSort\n-\n-Tue Jun 12 18:17:28 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/* configure.in NEWS: release of libxml2 2.6.29\n-\t* valid.c: patch from Dagfinn I. Mannsåker for idness of name\n-\t  in HTML, c.f. bug #305885.\n-\n-Tue Jun 12 17:14:08 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c: fixing bug #319964, parsing of HTML attribute really\n-\t  should not have namespace processing.\n-\n-Tue Jun 12 16:42:14 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed the push mode when a big comment occurs before\n-\t  an internal subset, should close bug #438835\n-\t* test\/comment6.xml result\/\/comment6.xml*: added a special\n-\t  test in the regression suite\n-\n-Tue Jun 12 15:41:09 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fix bug #414846 where invalid characters in attributes\n-\t  would sometimes not be detected.\n-\t* test\/errors\/attr4.xml result\/errors\/attr4.xml*: added a specific\n-\t  test case to the regression tests\n-\n-Tue Jun 12 14:23:24 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xstc\/Makefile.am: apply patch from Ryan Hill to cope with changes\n-\t  in GNU tar, should fix #396751\n-\n-Tue Jun 12 12:03:36 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/types.c: try to allow compilation on old python version\n-\t  should fix #398125\n-\n-Tue Jun 12 11:48:15 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c: htmlNodeDumpFormatOutput didn't handle XML_ATTRIBUTE_NODe\n-\t  fixes bug #438390\n-\n-Tue Jun 12 11:37:55 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: workaround misgenerated file: URIs c.f. #437385\n-\n-Tue Jun 12 11:22:47 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: fixed bug #407436 a crash in a specific case of\n-\t  Relax-NG validation\n-\n-Tue Jun 12 11:12:50 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: fixed bug #383687, some case of recursion on next\n-\t  were not caught in the catalog code.\n-\n-Tue Jun 12 10:37:42 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fixed bug #381877, avoid reading over the end\n-\t  of stream when generating an UTF-8 encoding error.\n-\n-Tue Jun 12 10:16:48 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed bug #366161, trivially added the check in\n-\t  xmlCtxtReset()\n-\n-Fri Jun  8 21:48:21 CEST 2007 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* win32\/configure.js win32\/Makefile.msvc: add --vcmanifest flag (yes\/no) \n-\t  for VC8 build support to embed manifest within files. Under MS VC, build \n-\t  libxml2_a_dll.lib by default (LIBXML_STATIC_FOR_DLL flag).\n-\n-Fri Jun  8 21:37:46 CEST 2007 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* threads.c include\/libxml\/threads.h: use specified calling convention \n-\t  for xmlDllMain. Old SDKs (VC6) only support InterlockedCompareExchange.\n-\t  add xmlDllMain to header for win32 when building for static dll\n-\n-Fri Jun  8 10:51:28 CEST 2007 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* xmlwriter.c: fixed problem with namespace declaration being \n-\t  written more than once per element start tag\n-\n-Wed Jun  6 10:18:28 PDT 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: fixed problem with xmlXPathNodeSetSort;\n-\t  fixed problem with xmlXPathNodeTrailingSorted (both bug#413451)\n-\n-Wed May 30 22:05:08 PDT 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: fixed problem with string value for PI node\n-\t  (bug #442275)\n-\n-Mon May 28 16:14:50 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: fix bug reported by François Delyon\n-\n-Tue May 22 08:59:48 PDT 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* encoding.c: Fixed typo in xmlCharEncFirstLine pointed out\n-\t  by Mark Rowe (bug #440159)\n-\t* include\/libxml\/xmlversion.h.in: Added check for definition of\n-\t  _POSIX_C_SOURCE to avoid warnings on Apple OS\/X (patch from\n-\t  Wendy Doyle and Mark Rowe, bug #346675)\n-\t* schematron.c, testapi.c, tree.c, xmlIO.c, xmlsave.c: minor\n-\t  changes to fix compilation warnings - no change to logic.\n-\n-Tue May 15 22:18:08 PDT 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* nanohttp.c: small enhancement to last fix, pointed out\n-\t  by Alex Cornejo\n-\n-Tue May 15 12:38:38 PDT 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* nanohttp.c: fixed problem on gzip streams (bug #438045)\n-\t* xpath.c: fixed minor spot of redundant code - no logic change.\n-\n-Fri May 11 22:45:18 HKT 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: enhanced the coding for xmlXPathCastNumberToString\n-\t  in order to produce the required number of significant digits\n-\t  (bug #437179)\n-\n-Thu May 10 01:52:42 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* list.c: applied patch to fix xmlListAppend() from \n-\t  Georges-André SILBER\n-\t* valid.c: also fix the place where it was called.\n-\n-Wed May  2 18:47:33 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: tried to fix an error problem on entity content failure\n-\t  reported by Michael Day\n-\n-Wed May  2 18:23:35 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: typo patch from Bjorn Reese\n-\n-Wed May  2 18:12:58 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: applied patch from Michael Day to add support for\n-\t  <embed>\n-\n-Thu Apr 26 10:58:50 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: Jean-Daniel Dupas pointed a couple of problems\n-\t  in htmlCreateDocParserCtxt.\n-\n-Thu Apr 26 10:36:26 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c include\/libxml\/uri.h: patch from Richard Jones to save\n-\t  the query part in raw form.\n-\t* libxml2-python-api.xml: also added accessor for the python bindings\n-\n-Wed Apr 25 15:57:32 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xstc\/Makefile.am doc\/examples\/Makefile.am Makefile.am: applied\n-\t  patch from Richard Jones to for the silent flag on valgrind\n-\t  when doing \"make valgrind\"\n-\t* xmlregexp.c: raise a regexp error when '\\' is misused to escape\n-\t  a standard character.\n-\n-Tue Apr 24 20:15:14 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: Richard Jones reported xmlBufferAdd (buf, \"\", -1), fixing it\n-\n-Tue Apr 24 10:59:28 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: fix xmlURIUnescapeString comments which was confusing\n-\n-Wed Apr 18 09:52:25 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/win32config.h libxml.h: new patch from Andreas Stricke to\n-\t  better integrate support for Windows CE\n-\n-Tue Apr 17 16:50:12 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/* configure.in NEWS: release of libxml2 2.6.28\n-\n-Tue Apr 17 14:47:42 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c libxml.h win32\/wince\/wincecompat.h win32\/wince\/wincecompat.c\n-\t  xmlIO.c nanohttp.c nanoftp.c trio.c triostr.c triostr.h: applied \n-\t  patch from Andreas Stricke to ease the compilation on Windows CE\n-\n-Tue Apr 17 14:34:45 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c catalog.c: \"xmllint unusable on win32\" so applied\n-\t  a libxml2 patch from Christian Ehrlicher\n-\n-Mon Apr 16 09:05:01 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: change the way script\/style are parsed to\n-\t  not try to detect comments, reported by Mike Day\n-\t* result\/HTML\/doc3.*: affects the result of that test\n-\n-Wed Apr 11 22:38:18 HKT 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlregexp.c: small enhancement for quantifier range with\n-\t  min occurs of 0; fixes bug 425542.\n-\t\n-Fri Mar 30 14:41:57 CEST 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: applied change from Michael Day to avoid a problem when\n-\t  compiled without zlib support.\n-\n-Wed Mar 21 17:58:13 CET 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xpath.h: applied documentation patch from James Dennett\n-\n-Wed Mar 21 21:20:48 HKT 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlregexp.c: fixed problem with 0x2d in Char Range (bug #420596)\n-\t* test\/regexp\/bug420596, result\/regexp\/bug420596: added regression\n-\t  test for this\n-\n-Wed Mar 21 14:23:08 HKT 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* HTMLparser.c: fixed memory access error on parsing of meta data\n-\t  which had errors (bug #382206).  Also cleaned up a few warnings\n-\t  by adding some additional DECL macros.\n-\n-Tue Mar 20 09:58:13 CET 2007  Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanoftp.c: applied patch from Björn Wiberg to try to fix again\n-\t  the silly __ss_family problem on various AIXes, should fix #420184\n-\n-Wed Mar 14 20:30:38 HKT 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* configure.in: corrected small error in last commit\n-\t* xmlreader.c: corrected small typo in last commit\n-\n-Wed Mar 14 19:35:28 HKT 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlschemas.c: fixed problem with referenced attribute groups\n-\t  (bug #417621)\n-\t* configure.in: re-ordered some includes for types.h \/ socket.h\n-\t  (bug #416001)\n-\n-Fri Mar  9 17:54:40 CET 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: applied patch from Julien Reichel cleaning up mode\n-\t  and state internal flags mixups\n-\n-Wed Mar  7 16:18:18 HKT 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: fixed xmlXPathCmpNodes for incorrect result on certain\n-\t  cases when comparing identical nodes (bug #415567) with patch\n-\t  from Oleg Paraschenko\n-\n-Fri Feb 16 09:13:38 PST 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* python\/libxml.py: fixed tab problem with patch from\n-\t  Andreas Hanke (bug #408626)\n-\n-Thu Feb 15 12:43:28 PST 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/xml.html: Changed all references to libxml2 CVS over to\n-\t  the corresponding SVN.  A few other spelling\/grammar\/links\n-\t  also changed.\n-\t* doc\/libxml2-api.xml, doc\/*.html: Regenerated all docs.\n-\n-Tue Feb 13 18:15:58 PST 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: Fixed memory bug with invalid function reported by\n-\t  Francois Delyon on mailing list\n-\n-Mon Feb 12 16:40:48 PST 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xinclude.c: fixed problem with invalid char encountered\n-\t  during text include (reported on xslt mailing list)\n-\n-Mon Feb 12 18:30:01 CET 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: small cleanup to avoid packaging .svn\n-\t* libxml.h threads.c parser.c: applied patch to avoid a problem\n-\t  in concurrent threaded initialization fix from Ted Phelps\n-\n-Thu Feb 08 15:35:18 PST 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* parser.c: added a GROW when parsing complex comments (bug #405666)\n-\t* gentest.py, testapi.c: added a hack to prevent destruction of any\n-\t  param with 'destroy' in it's description (i.e. param destroyed by\n-\t  the routine under test, so shouldn't be destroyed by testapi)\n-\t* xmlreader.c: added freeing of 'input' param even on error\n-\t  (fixes leak detected by testapi)\n-\n-Wed Jan 31 10:25:38 PST 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* testAutomata.c, testRegexp.c, testThreads.c, testThreadsWin32.c,\n-\t  xmlwriter.c: repositioned #include for libxml.h to avoid\n-\t  compilation error on some architectures (bug #398277)\n-\t* fixed screwed-up ChangeLog (deleted some duplicate entries)\n-\n-Fri Jan 26 00:05:18 PST 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* implemented patch from Stéphane Bidoul for uri.c (bug #389767)\n-\n-Thu Jan 25 11:15:08 PST 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: added checks for alloc fail on calls to\n-\t  xmlXPathNewContext (libxslt bug #400242)\n-\n-Thu Jan 11 15:38:08 PST 2007 William Brack <wbrack@mmm.com.hk>\n-\n-\t* Re-generated the documentation (API chunks 27-29 were missing)\n-\t  (also causes changes to testapi.c, elfgcchack.h and\n-\t  win32\/libxml2.def.src)\n-\n-Tue Jan  9 22:24:26 CET 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c: fix a memory leak in the python string handling\n-\t  when SAX event are passed back to the python handlers\n-\n-Thu Jan  4 18:27:49 CET 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: fix xmlTextReaderSetup() description\n-\t* test\/relaxng\/empty1.rng test\/relaxng\/comps_0.xml\n-\t  test\/relaxng\/empty1_0.xml test\/relaxng\/comps.rng\n-\t  test\/relaxng\/empty0.rng test\/relaxng\/empty0_0.xml\n-\t  test\/relaxng\/empty1_1.xml: tests which were apparently \n-\t  never committed to CVS\n-\n-Wed Jan  3 16:05:21 PST 2007 Aleksey Sanin <aleksey@aleksey.com>\n-\n-\t* xmlreader.c include\/libxml\/xmlreader.h win32\/libxml2.def.src:\n-\texpose xmlTextReaderSetup() function\n-\n-Wed Jan  3 16:14:13 CET 2007 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: adapt the extra versioning code to SVN\n-\n-Thu Dec 14 16:52:34 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/libxml.py: apparently id() sometimes\n-\t  generate negative values and %X outputs -XXXX :-(\n-\n-Mon Dec  4 10:30:25 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c include\/libxml\/tree.h: patch from Michael Day on standalone\n-\t  and XML declaration detection, and associated documentation change\n-\n-Mon Dec  4 10:27:01 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: another XInclude user data propagation patch from\n-\t  Michael Day\n-\n-Thu Nov 23 17:22:03 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: applied patch from Steven Rainwater to fix \n-\t  UTF8ToHtml behaviour on code points which are not mappable to\n-\t  predefined HTML entities, fixes #377544\n-\n-Thu Nov 23 17:11:23 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fixed a bug where the principal node type of an axis\n-\t  wasn't tested on name check, fixes bug #377432\n-\n-Wed Nov  8 10:19:27 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: change htmlCtxtReset() following Michael Day bug\n-\t  report and suggestion.\n-\n-Mon Nov  6 09:56:41 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: applied patch from Igor for path conversion on Windows\n-\n-Thu Nov  2 11:29:17 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: another small change on the algorithm for the\n-\t  elimination of epsilon transitions, should help on #362989 too\n-\n-Wed Nov  1 16:33:10 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: applied documentation patches from Markus Keim\n-\t* xmlregexp.c: fixed one bug and added a couple of optimisations\n-\t  while working on bug #362989\n-\n-Fri Oct 27 14:54:07 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: applied a reworked version of Usamah Malik patch\n-\t  to avoid growing the parser stack in some autoclose cases, should\n-\t  fix #361221\n-\n-Thu Oct 26 10:54:40 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: William spotted an obvious bug\n-\n-Wed Oct 25 18:04:50 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* NEWS configure.in testapi.c doc\/\/*: preparing release of\n-\t  libxml2-2.6.27\n-\t* include\/libxml\/tree.h: fix a small problem with preproc flags\n-\n-Fri Oct 20 14:55:47 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fix comment for xmlDocSetRootElement c.f. #351981\n-\t* xmllint.c: order XPath elements when using --shell\n-\n-Tue Oct 17 23:23:26 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: applied fix from Christopher Boumenot for bug\n-\t  #362714 on regexps missing ']'\n-\n-Tue Oct 17 22:32:42 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c: applied patch from Marius Konitzer to avoid\n-\t  leaking in xmlNewInputFromFile() in case of HTTP redirection\n-\n-Tue Oct 17 22:19:02 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fix one problem found in htmlCtxtUseOptions()\n-\t  and pointed in #340591\n-\n-Tue Oct 17 22:04:31 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fixed the 2 stupid bugs affecting htmlReadDoc() and\n-\t  htmlReadIO() this should fix #340322\n-\n-Tue Oct 17 21:39:23 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: applied patch from Olaf Walkowiak which should fix #334104\n-\n-Tue Oct 17 18:12:34 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fixing HTML minimized attribute values to be generated\n-\t  internally if not present, fixes bug #332124\n-\t* result\/HTML\/doc2.htm.sax result\/HTML\/doc3.htm.sax \n-\t  result\/HTML\/wired.html.sax: this affects the SAX event stream for\n-\t  a few test cases\n-\n-Tue Oct 17 17:56:31 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fixing HTML entities in attributes parsing bug #362552\n-\t* result\/HTML\/entities2.html* test\/HTML\/entities2.html: added to\n-\t  the regression suite\n-\n-Tue Oct 17 01:21:37 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: started to switch xmllint to use xmlSaveDoc to test\n-\t  #342556\n-\t* xmlsave.c: fixed #342556 easy and a whole set of problems with\n-\t  encodings, BOM and xmlSaveDoc()\n-\n-Mon Oct 16 15:14:53 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fix #348252 if the document clains to be in a\n-\t  different encoding in the meta tag and it's obviously wrong,\n-\t  don't screw up the end of the content.\n-\n-Mon Oct 16 11:32:09 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fix a chunking and script bug #347708\n-\n-Mon Oct 16 09:51:05 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: remove a warning\n-\t* encoding.c: check with uppercase for AIX iconv() should fix #352644\n-\t* doc\/examples\/Makefile.am: partially handle one bug report\n-\n-Sun Oct 15 22:31:42 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fix the patch for unreproductable #343000 but\n-\t  also fix a line\/column keeping error\n-\t* result\/errors\/attr1.xml.err result\/errors\/attr2.xml.err\n-\t  result\/errors\/name.xml.err result\/errors\/name2.xml.err \n-\t  result\/schemas\/anyAttr-processContents-err1_0_0.err \n-\t  result\/schemas\/bug312957_1_0.err: affected lines in error output\n-\t  of the regression tests\n-\n-Sat Oct 14 10:46:46 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fixing bug #344390 with xmlReconciliateNs\n-\n-Sat Oct 14 00:31:49 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: added --html --memory to test htmlReadMemory to \n-\t  test #321632\n-\t* HTMLparser.c: added various initialization calls which may help \n-\t  #321632 but not conclusive\n-\t* testapi.c tree.c include\/libxml\/tree.h: fixed compilation with\n-\t  --with-minimum --with-sax1 and --with-minimum --with-schemas\n-\t  fixing #326442\n-\n-Fri Oct 13 18:30:55 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: fix a Relax-NG bug related to element content processing,\n-\t  fixes bug #302836\n-\t* test\/relaxng\/302836.rng test\/relaxng\/302836_0.xml\n-\t  result\/relaxng\/302836*: added to regression tests\n-\n-Fri Oct 13 14:42:44 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fix a problem in xmlSplitQName resulting in bug #334669\n-\n-Fri Oct 13 12:27:22 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed xmlIOParseDTD handling of @input in error case,\n-\t  Should fix #335085\n-\t* testapi.c: reset the http_proxy env variable to not waste time\n-\t  on regression tests\n-\n-Thu Oct 12 23:07:43 CEST 2006 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* xmlIO.c: fix Windows compile - missing xmlWrapOpen.\n-\n-Thu Oct 12 18:21:18 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed the heuristic used when trying to detect mixed-content\n-\t  elememts if the parser wants to treat ignorable whitespaces \n-\t  in a non-standard way, should fix bug #300263\n-\n-Thu Oct 12 14:52:38 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fix a first arg error in SAX callback pointed out by\n-\t  Mike Hommey, and another one still hanging around. Should fix #342737\n-\n-Wed Oct 11 23:11:58 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlversion.h.in: fix comment on versions\n-\t* xmlmemory.c: do not spend too much time digging in dumped memory\n-\n-Wed Oct 11 18:40:00 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: fixed a weird error where validity context would not\n-\t  show up if warnings were disabled pointed out by Bob Stayton\n-\t* xmlIO.c doc\/generator.py: cleanup and fix to regenerate the docs\n-\t* doc\/\/* testapi.c: rebuilt the docs\n-\n-Wed Oct 11 14:32:00 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml-2.0.pc.in: applied patch from Mikhail Zabaluev to separate\n-\t  library flags for shared and static builds, fixes #344594. If this\n-\t  bites you, use xml2-config.\n-\n-Wed Oct 11 11:27:37 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/Makefile.am: remove the build path recorded in the python\n-\t  shared module as Peter Breitenlohner pointed out, should fix #346022\n-\n-Wed Oct 11 11:14:51 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: applied patch from Mikhail Zabaluev fixing the conditions\n-\t  of unescaping from URL to filepath, should fix #344588.\n-\n-Wed Oct 11 10:24:58 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in xstc\/Makefile.am: applied patch from Peter Breitenlohner\n-\t  for wget detection and fix of a Python path problem, should fix\n-\t  #340993\n-\n-Tue Oct 10 22:02:29 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/entities.h entities.c SAX2.c parser.c: trying to\n-\t  fix entities behaviour when using SAX, had to extend entities \n-\t  content and hack on the entities processing code, but that should\n-\t  fix the long standing bug #159219\n-\n-Tue Oct 10 14:36:18 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c include\/libxml\/uri.h: add a new function xmlPathToUri()\n-\t  to provide a clean conversion when setting up a base\n-\t* SAX2.c tree.c: use said function when setting up doc->URL\n-\t  or using the xmlSetBase function. Should fix #346261\n-\n-Tue Oct 10 11:05:59 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: applied a portability patch from Emelyanov Alexey\n-\n-Tue Oct 10 10:52:01 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: applied and slightly modified a patch from Michael Day to \n-\t  keep _private in the parser context when parsing external entities\n-\n-Tue Oct 10 10:33:43 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.py python\/types.c: applied patch from Ross Reedstrom,\n-\t  Brian West and Stefan Anca to add XPointer support to the Python bindings\n-\n-Fri Sep 29 11:13:59 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlsave.c: fixed a comment\n-\t* xinclude.c include\/libxml\/xinclude.h: applied a patch from Michael Day\n-\t  to add a new function providing the _private field for the generated\n-\t  parser contexts xmlXIncludeProcessFlagsData()\n-\n-Thu Sep 21 10:36:11 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: applied patch from Michael Day doing some refactoring\n-\t  for the catalog entity loaders.\n-\n-Thu Sep 21 08:53:06 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c include\/libxml\/HTMLparser.h: exports htmlNewParserCtxt()\n-\t  as Michael Day pointed out this is needed to use htmlCtxtRead*()\n-\n-Tue Sep 19 14:42:59 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: applied patch from Ben Darnell on #321545, I could not\n-\t  reproduce the problem but 1\/ this is safe 2\/ it's better to be safe.\n-\n-Sat Sep 16 16:02:23 CEST 2006 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* tree.c: xmlTextConcat works with comments and PI nodes (bug #355962).\n-\t* parser.c: fix resulting tree corruption when using XML namespace \n-\t  with existing doc in xmlParseBalancedChunkMemoryRecover.\n-\n-Fri Sep  1 11:52:55 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: another patch from Emelyanov Alexey to clean up a few things\n-\t  in the previous patch.\n-\n-Wed Aug 30 15:10:09 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: applied patch from Roland Schwingel to fix the problem\n-\t  with file names in UTF-8 on Windows, and compat on older win9x \n-\t  versions.\n-\n-Tue Aug 22 16:51:22 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: fixed a bug #203125 in Red hat bugzilla, crashing PHP4\n-\t  on validation errors, the heuristic to guess is a vctxt user\n-\t  pointer is the parsing context was insufficient.\n-\n-Mon Aug 21 10:40:10 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xmlcatalog.1 doc\/xmlcatalog_man.xml doc\/xmllint.1 doc\/xmllint.xml:\n-\t  applied patch to man pages from Daniel Leidert and regenerated\n-\n-Thu Aug 17 00:48:31 CEST 2006 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* xmlwriter.c: Add a document to the xmlwriter structure and \n-\t  pass document when writing attribute content for encoding support.\n-\n-Wed Aug 16 01:15:12 CEST 2006 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* HTMLtree.c xmlsave.c: Add linefeeds to error messages allowing \n-\t  for consistent handling.\n-\n-Tue Aug 15 15:02:18 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Applied the proposed fix for the documentation\n-\t  of xmlXPathCastToString(); see bug #346202.\n-\n-Tue Aug 15 14:49:18 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: While investigating bug #350247, I noticed\n-\t  that xmlSchemaIDCMatcher structs are massively recreated\n-\t  although only a maximum of 3 structs is used at the same\n-\t  time; added a cache for those structures to the\n-\t  validation context.\n-\n-Sat Aug 12 16:12:53 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: applied patch from Marton Illes to fix an allocation\n-\t  bug in xmlSchemaXPathEvaluate should close #351032\n-\n-Mon Aug  7 13:08:46 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: applied patch from Bertrand Fritsch to fix a bug in\n-\t  xmlSchemaClearValidCtxt\n-\n-Fri Aug  4 14:50:41 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py: fixed the conversion of long parameters\n-\n-Thu Jul 13 15:03:11 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlsave.c: Removed the automatic generation of CDATA sections\n-\t  for the content of the \"script\" and \"style\" elements when\n-\t  serializing XHTML. The issue was reported by Vincent Lefevre,\n-\t  bug #345147.\n-\t* result\/xhtml1 result\/noent\/xhtml1: Adjusted regression test\n-\t  results due to the serialization change described above.\n-\n-Thu Jul 13 08:32:21 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in parser.c xmllint.c include\/libxml\/parser.h\n-\t  include\/libxml\/xmlversion.h.in: applied patch from Andrew W. Nosenko\n-\t  to expose if zlib support was compiled in, in the header, in the\n-\t  feature API and in the xmllint --version output.\n-\n-Thu Jul 13 08:24:14 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c: refactor to use normal warnings for entities problem\n-\t  and not straight SAX callbacks.\n-\n-Wed Jul 12 17:13:03 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed bug #347316, reported by David Belius:\n-\t  The simple type, which was the content type definition\n-\t  of a complex type, which in turn was the base type of a\n-\t  extending complex type, was missed to be set on this\n-\t  extending complex type in the derivation machinery.\n-\n-Mon Jul  3 13:36:43 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Changed xmlXPathCollectAndTest() to use\n-\t  xmlXPathNodeSetAddNs() when adding a ns-node in case of\n-\t  NODE_TEST_TYPE (the ns-node was previously added plainly\n-\t  to the list). Since for NODE_TEST_ALL and NODE_TEST_NAME\n-\t  this specialized ns-addition function was already used,\n-\t  I assume it was missed to be used with NODE_TEST_TYPE.\n-\n-Mon Jul  3 10:57:33 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: applied const'ification of strings patch from\n-\t  Matthias Clasen\n-\n-Thu Jun 29 13:51:12 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* threads.c: patch from Andrew W. Nosenko, xmlFreeRMutex forgot to\n-\t  destroy the condition associated to the mutex.\n-\n-Thu Jun 29 12:48:00 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Fixed a double-free in xmlXPathCompOpEvalToBoolean(),\n-\t  revealed by a Libxslt regression test.\n-\n-Thu Jun 29 12:28:07 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Enhanced xmlXPathCompOpEvalToBoolean() to be also\n-\t  usable outside predicate evaluation; the intention is to\n-\t  use it via xmlXPathCompiledEvalToBoolean() for XSLT tests,\n-\t  like in <xsl:if test=\"\/foo\">.\n-\t  \n-Wed Jun 28 19:11:16 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Fix a memory leak which occurred when using\n-\t  xmlXPathCompiledEvalToBoolean().\n-\n-Mon Jun 26 17:24:28 UTC 2006 William Brack <wbrack@mmm.com.hk>\n-\n-\t* python\/libxml.c, python\/libxml.py, python\/tests\/compareNodes.py,\n-\t  python\/tests\/Makefile.am:\n-\t  Added code submitted by Andreas Pakulat to provide node\n-\t  equality, inequality and hash functions, plus a single\n-\t  test program to check the functions (bugs 345779 + 345961).\n-\n-Mon Jun 26 18:38:51 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Added xmlXPathCompiledEvalToBoolean() to the API and\n-\t  adjusted\/added xmlXPathRunEval(), xmlXPathRunStreamEval(),\n-\t  xmlXPathCompOpEvalToBoolean(), xmlXPathNodeCollectAndTest()\n-\t  to be aware of a boolean result request. The new function\n-\t  is now used to evaluate predicates.\n-\n-Mon Jun 26 16:22:50 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Fixed an bug in xmlXPathCompExprAdd(): the newly\n-\t  introduced field @rewriteType on xmlXPathStepOp was not\n-\t  initialized to zero here; this could lead to the activation\n-\t  of the axis rewrite code in xmlXPathNodeCollectAndTest() when\n-\t  @rewriteType is randomly set to the value 1. A test\n-\t  (hardcoding the initial value to 1) revealed that the\n-\t  resulting incorrect behaviour is similar to the behaviour\n-\t  as described by Arnold Hendriks on the mailing list; so I\n-\t  hope that will fix the issue.\t  \n-\n-Fri Jun 23 18:26:08 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Fixed an error in xmlXPathEvalExpr(), which\n-\t  was introduced with the addition of the d-o-s rewrite\n-\t  and made xpath.c unable to compile if XPATH_STREAMING\n-\t  was not defined (reported by Kupriyanov Anatolij -\n-\t  #345752). Fixed the check for d-o-s rewrite\n-\t  to work on the correct XPath string, which is ctxt->base\n-\t  and not comp->expr in this case.\n-\n-Mon Jun 19 12:23:41 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Added optimization for positional predicates\n-\t  (only short-hand form \"[n]\"), which have a preceding\n-\t  predicate: \"\/foo[descendant::bar][3]\".\n-\n-Sun Jun 18 20:59:02 EDT 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: try to fix the crash raised by the parser in\n-\t  recover mode as pointed by Ryan Phillips\n-\n-Sun Jun 18 18:44:56 EDT 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/types.c: patch from Nic Ferrier to provide a better type\n-\t  mapping from XPath to python\n-\n-Sun Jun 18 18:35:50 EDT 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runtest.c: applied patch from Boz for VMS and reporting\n-\t  Schemas errors.\n-\n-Sun Jun 18 18:22:25 EDT 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testapi.c: applied patch from Felipe Contreras when compiling\n-\t  with --with-minimum\n-\n-Fri Jun 16 21:37:44 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* tree.c include\/libxml\/tree.h: Fixed a bug in\n-\t  xmlDOMWrapAdoptNode(); the tree traversal stopped if the\n-\t  very first given node had an attribute node :-( This was due\n-\t  to a missed check in the traversal mechanism.\n-\t  Expanded the xmlDOMWrapCtxt: it now holds the namespace map\n-\t  used in xmlDOMWrapAdoptNode() and xmlDOMWrapCloneNode() for\n-\t  reusal; so the map-items don't need to be created for every\n-\t  cloning\/adoption. Added a callback function to it for\n-\t  retrieval of xmlNsPtr to be set on node->ns; this is needed\n-\t  for my custom handling of ns-references in my DOM wrapper.\n-\t  Substituted code which created the XML namespace decl on\n-\t  the doc for a call to xmlTreeEnsureXMLDecl(). Removed\n-\t  those nasty \"warnings\" from the docs of the clone\/adopt\n-\t  functions; they work fine on my side.\n-\t  \n-Mon Jun 12 13:23:11 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* result\/pattern\/namespaces: Adjusted the result of a\n-\t  regression test, since the fix of xmlGetNodePath() revealed a\n-\t  bug in this test result.\n-\n-Mon Jun 12 13:06:03 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* tree.c: Got rid of a compiler warning in xmlGetNodePath().\n-\n-Mon Jun 12 12:54:25 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* tree.c: Fixed xmlGetNodePath() to generate the node test \"*\"\n-\t  for elements in the default namespace, rather than generating\n-\t  an unprefixed named node test and losing the namespace\n-\t  information.\n-\n-Fri Jun  9 21:45:02 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* include\/libxml\/parser.h: Clarified in the docs that the tree\n-\t  must not  be tried to be modified if using the parser flag\n-\t  XML_PARSE_COMPACT as suggested by Stefan Behnel\n-\t  (#344390).\n-\n-Tue Jun  6 17:50:43 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.ini NEWS doc\/\/* libxml.spec.in : preparing release of 2.6.26\n-\n-Tue Jun  6 17:25:23 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Fixed self-invented a segfault in xmlXPathCtxtCompile(),\n-\t  when the expression was not valid and @comp was NULL and I\n-\t  tried to do the d-o-s rewrite.\n-\n-Tue Jun  6 15:19:57 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.ini NEWS doc\/\/* libxml.spec.in : preparing release of 2.6.25\n-\n-Tue Jun  6 11:28:15 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Enabled the compound traversal again; I added a\n-\t  check to use this only if the have an expression starting\n-\t  with the document node; so in the case of \"\/\/foo\", we\n-\t  already know at compilation-time, that there will be only\n-\t  1 initial context node. Added the rewrite also to\n-\t  xmlXPathEvalExpr().\n-\n-Tue Jun  6 10:23:10 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: fix bug #343968, include='text' can't lead to a \n-\t  recursion.\n-\n-Fri Jun  2 22:47:08 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Disabled the compound traversal for the release;\n-\t  I need first to assure that this is done only if we have\n-\t  1 initial node.\n-\n-Wed May 31 13:53:41 PST 2006 Aleksey Sanin <aleksey@aleksey.com>\n-      \n-\t* xpath.c: fixed memory leak in xpath error reporting\n-\n-Wed May 31 15:30:16 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.h triodef.h: applied patch from Olli Savia for LynxOS\n-\n-Wed May 31 14:33:00 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c include\/libxml\/xpath.h runsuite.c:\n-\t  Changed the name of the recently added public function\n-\t  xmlXPathContextSetObjectCache() to\n-\t  xmlXPathContextSetCache(); so a more generic one, in\n-\t  case we decide to cache more things than only XPath\n-\t  objects.\n-\n-Tue May 30 21:36:16 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Optimized xmlXPathNodeCollectAndTest() and\n-\t  xmlXPathNodeCollectAndTestNth() to evaluate a compound\n-\t  traversal of 2 axes when we have a \"\/\/foo\" expression.\n-\t  This is done with a rewrite of the XPath AST in\n-\t  xmlXPathRewriteDOSExpression(); I added an additional field\n-\t  to xmlXPathStepOp for this (but the field's name should be\n-\t  changed). The mechanism: the embracing descendant-or-self\n-\t  axis traversal (also optimized to return only nodes which\n-\t  can hold elements), will produce context nodes for the\n-\t  inner traversal of the child axis. This way we avoid a full\n-\t  node-collecting traversal of the descendant-or-self axis.\n-\t  Some tests indicate that this can reduce execution time of\n-\t  \"\/\/foo\" to 50%. Together with the XPath object cache this\n-\t  all significantly speeds up libxslt.\n-\n-Tue May 30 11:38:47 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: A warning will now be reported in the value of\n-\t  the XSD attribute 'schemaLocation' does not consist of tuples\n-\t  (namespace-name, document-URI). A warning will be reported\n-\t  if a schema document could not be found at the specified\n-\t  location (via 'schemaLocation' or\n-\t  'noNamespaceSchemaLocation').\n-\t* include\/libxml\/xmlerror.h: Added XML_SCHEMAV_MISC to\n-\t  xmlParserErrors.\n-\n-Tue May 30 11:21:34 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Enhanced xmlXPathNodeCollectAndTest() to avoid\n-\t  recreation (if possible) of the node-set which is used to\n-\t  collect the nodes in the current axis for the current context\n-\t  node. Especially for \"\/\/foo\" this will decrease dramatically\n-\t  the number of created node-sets, since for each node in the\n-\t  result node-set of the evaluation of descendant-or-self::node()\n-\t  a new temporary node-set was created. Added node iterator\n-\t  xmlXPathNextChildElement() as a tiny optimization for\n-\t  child::foo.\n-\n-Mon May 29 18:06:17 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c include\/libxml\/xpath.h: Added an XPath object cache.\n-\t  It sits on an xmlXPathContext and need to be explicitly\n-\t  activated (or deactivated again) with\n-\t  xmlXPathContextSetObjectCache(). The cache consists of 5\n-\t  lists for node-set, string, number, boolean and misc XPath\n-\t  objects. Internally the xpath.c module will use object-\n-\t  deposition and -acquisition functions which will try to reuse\n-\t  as many XPath objects as possible, and fallback to normal\n-\t  free\/create behaviour if no cache is available or if the cache\n-\t  is full.\n-\t* runsuite.c: Adjusted to deactivate the cache for XML Schema\n-\t  tests if a cache-creation is turned on by default for the whole\n-\t  library, e.g. for testing purposes of the cache. It is\n-\t  deactivated here in order to avoid confusion of the memory leak\n-\t  detection in runsuite.c.\n-\n-Wed May 24 10:54:25 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Removed a memcpy if xmlXPathNodeSetMerge(); it\n-\t  seems we really need to walk the whole list, since those\n-\t  nasty namespace nodes need to be added with\n-\t  xmlXPathNodeSetDupNs(); thus a pure memcpy is not possible.\n-\t  A flag on the node-set indicating if namespace nodes are in\n-\t  the set would help here; this is the 3rd flag which would\n-\t  be useful with node-sets. The current flags I have in mind:\n-\t  1) Is a node-set already sorted?\n-\t     This would allow for rebust and optimizable sorting\n-\t     behaviour.\n-\t  2) Of what type are the nodes in the set (or of mixed type)?\n-\t     This would allow for faster merging of node-sets.\n-\t  3) Are namespace nodes in the set?\n-\t     This would allow to skip all the namespace node specific\n-\t     special handling. Faster node-set merging if the first\n-\t     set is empty; just memcpy the set.\n-\n-Mon May 22 17:14:00 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Optimization of count(): eliminated sorting\n-\t  (see bug #165547). Optimization of XPATH_OP_FILTER if the\n-\t  predicate is a [1] (disable with XP_OPTIMIZED_FILTER_FIRST if\n-\t  it produces trouble). Tiny opt in xmlXPathNodeSetMerge().\n-\t  \n-Mon May 22 13:33:12 CEST 2006 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* tree.c: Revert behavior change in xmlSetProp to handle attributes\n-\t  with colons in name and no namespace.\n-\n-Fri May 19 21:56:43 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Substituted all remaining calls to xmlXPathCmpNodes()\n-\t  for xmlXPathCmpNodesExt(). Tiny further enhancement of\n-\t  xmlXPathCmpNodesExt(). Added additional checks in various code\n-\t  parts to avoid calling sorting or merging functions if the\n-\t  node-set(s) don't need them; i.e., if they are empty or contain\n-\t  just one node.\n-\n-Fri May 19 13:16:58 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Optimized the comparison for non-element nodes\n-\t  in xmlXPathCmpNodesExt(); the comparison is used for sorting\n-\t  of node-sets. This enhancement is related to bug #165547.\n-\t  There are other places where the old comparison function\n-\t  xmlXPathCmpNodes() is still called, but I currently don't\n-\t  know exactly what those calls are for; thus if they can be\n-\t  substituted (if it makes sense) for the new function.\n-\n-Tue May 16 16:55:13 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xpath.c: Applied patch from Rob Richards, fixing a potential\n-\t  memory leak in xmlXPathTryStreamCompile(), when a list of\n-\t  namespaces was assigned to the XPath compilation context;\n-\t  here a new namespace list was created and passed to\n-\t  xmlPatterncompile(); but this list was not freed afterwards.\n-\t  Additionally we avoid now in xmlXPathTryStreamCompile() to\n-\t  compile the expression, if it has a colon - indicating\n-\t  prefixed name tests - and no namespace list was given. The\n-\t  streaming XPath mechanism needs a namespace list at\n-\t  compilation time (unlike normal XPath, where we can bind\n-\t  namespace names to prefixes at execution time).\n-\t* pattern.c: Enhanced to use a string dict for local-names,\n-\t  ns-prefixes and namespace-names.\n-\t  Fixed xmlStreamPushInternal() not to use string-pointer\n-\t  comparison if a dict is available; this won't work, since\n-\t  one does not know it the given strings originate from the\n-\t  same dict - and they normally don't do, since e.g.\n-\t  namespaces are hold on xmlNs->href. I think this would be\n-\t  worth an investigation: if we can add a @doc field to xmlNs\n-\t  and put the @href in to a additionan namespace dict hold\n-\t  in xmlDoc. Daniel will surely not like this idea :-) But\n-\t  evaluation of tons of elements\/attributes in namespaces\n-\t  with xmlStrEqual() isn't the way we should go forever.\n-\t  \n-Thu May 11 18:03:49 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed bug #341337, reported by David Grohmann.\n-\t  The code expected a node (xmlNodePtr) on the info for a\n-\t  non-existent default attribute, which clearly cannot be\n-\t  expected, since the attribute does not exist. I can only\n-\t  guess that this sneaked trying to eliminate the query\n-\t  for the owner-element, which is unavoidable actually.\n-\t  Note that creation of default attributes won't have an\n-\t  effect if validating via SAX\/XMLReader; i.e., the processor\n-\t  won't fire additional start-attribute events (I'm not even\n-\t  sure if Libxml2 has such a SAX-event; I think it hands them\n-\t  all over in the start-element event).\n-\n-Tue May  9 21:47:58 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed bug #341150, reported by Michael Romer.\n-\t  In xmlSchemaBuildContentModelForSubstGroup(),\n-\t  xmlAutomataNewOnceTrans2() was incorrectly used instead of\n-\t  xmlAutomataNewTransition2() to mimic a xs:choice for\n-\t  substitution-groups.\n-\t* test\/schemas\/subst-group-1_1.xsd\n-\t  test\/schemas\/subst-group-1_0.xml\n-\t  result\/schemas\/subst-group-1_0_1\n-\t  result\/schemas\/subst-group-1_0_1.err: Added regression test\n-\t  supplied by Michael Romer for bug #341150.\n-\n-Sat May  6 11:05:24 HKT 2006 William M. Brack <wbrack@mmm.com.hk>\n-\n-\t* relaxng.c: Fixed compilation error with patch supplied by\n-\t  Graham Bennett.\n-\n-Thu May  4 19:14:03 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: We'll raise an internal error and stop\n-\t  validation now when an entity is found in the instance\n-\t  document, since we don't support automatic entity\n-\t  substitution by the schema processor (yet?) -\n-\t  see bug #340316, reported by Nick Wellnhofer.\n-\n-Wed May  3 15:16:00 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: applied another Python detection patch from Joseph Sacco\n-\t* libxml.spec.in: cleanup the changelog section, asciifies the spec file\n-\t  too\n-\n-Tue May  2 22:34:54 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: fix a mix of code and declarations showing up on Windows\n-\t  patch from Kjartan Maraas, fixing #340404\n-\n-Tue May  2 14:24:40 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: fixing bug #340398 xmlCharEncOutFunc writing to\n-\t  input buffer\n-\n-Fri Apr 28 18:29:22 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* NEWS configure.in doc\/\/*: preparing 2.6.24 release, fixed Python\n-\t  paths at the last moment\n-\t* relaxng.c testapi.c tree.c: fix some comments\n-\n-Thu Apr 27 10:15:45 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: applied patch from Roland Schwingel to allow UTF-8\n-\t  file paths on Windows\n-\n-Thu Apr 27 10:10:58 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlwriter.c: patch from Jason Viers for line breaks after EndPI\n-\n-Tue Apr 25 22:22:58 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fix compilation without tree\n-\n-Tue Apr 25 18:17:37 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: applied patch from Gary Coady to really make sure\n-\t  xmllint --nonet would not reach the network, should fix #337483.\n-\n-Tue Apr 25 14:52:15 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: applied patch from Joseph Sacco changing slightly\n-\t  the python detection scheme should fix bug #338526\n-\n-Mon Apr 24 10:50:19 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fix the error message for invalid code point in content\n-\t  c.f. bug #339311\n-\n-Wed Apr 19 13:16:23 CEST 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c test\/schemas\/restriction-enum-1*\n-\t  result\/schemas\/restriction-enum-1*: Fixed incorrect\n-\t  validation of restricted enumerations. Added related\n-\t  regression tests.\n-\n-Thu Apr 13 09:47:25 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: fixing a deallocation problem in xmlSchemaAddSchemaDoc()\n-\t  in case of errors, should fix bug #338303\n-\n-Thu Apr 13 09:31:45 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: fixing a deallocation problem in xmlRelaxNGParse() \n-\t  in case of errors, should fix bug #338306\n-\n-Thu Apr  6 10:22:17 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xmlcatalog.1 doc\/xmlcatalog_man.xml doc\/xmllint.1 doc\/xmllint.xml:\n-\t  applied man page improvements from Daniel Leidert\n-\n-Mon Mar 27 11:44:07 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: removed unused code or variables, from Stefan Kost\n-\t  fixing #336163 and #336164\n-\n-Mon Mar 27 11:38:21 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: applied patch from Stefan Kost fixing #336160\n-\n-Mon Mar 27 11:23:39 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* chvalid.c genChRanges.py genUnicode.py xmlunicode.c\n-\t  include\/libxml\/chvalid.h include\/libxml\/xmlunicode.h: applied\n-\t  patches from Aivars Kalvans to make unicode tables const, fixes\n-\t  bug #336096, this also updates to Unicode 4.01 final with a couple\n-\t  of character ranges fixes.\n-\n-Mon Mar 27 00:51:40 CEST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* chvalid.c genChRanges.py include\/libxml\/chvalid.h: fixed bug\n-\t  #335603 and resync'ed genChRanges.py to the expected output.\n-\n-Wed Mar 22 00:14:34 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: applied patch from Youri Golovanov fixing bug\n-\t  #316338 and adding a couple of optimizations in the regexp\n-\t  compilation engine.\n-\t* test\/regexp\/bug316338 result\/regexp\/bug316338: added regression\n-\t  tests based on the examples provided in the bug report.\n-\n-Fri Mar 10 08:40:55 EST 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* c14n.c encoding.c xmlschemas.c xpath.c xpointer.c: fix a few\n-\t  warning raised by gcc-4.1 and latest changes\n-\n-Fri Mar 10 01:34:42 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runtest.c schematron.c testAutomata.c tree.c valid.c xinclude.c\n-\t  xmlcatalog.c xmlreader.c xmlregexp.c xpath.c: end of first\n-\t  pass on coverity reports.\n-\n-Thu Mar  9 19:36:14 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c xmlschemas.c xmlschemastypes.c: more cleanups based\n-\t  on coverity reports.\n-\t\n-Thu Mar  9 17:47:40 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c catalog.c encoding.c entities.c example\/gjobread.c\n-\t  python\/libxml.c: more cleanups based on coverity reports.\n-\n-Thu Mar  9 15:12:19 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c parser.c parserInternals.c pattern.c uri.c: a bunch\n-\t  of small cleanups based on coverity reports.\n-\n-Thu Mar  9 09:42:10 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/Makefile.bcb: added schematron as pointed out by Eric Zurcher\n-\n-Tue Mar  7 09:50:09 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xml2-config.in: fix Red Hat bug #184170\n-\n-Mon Mar  6 14:21:08 CET 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* tree.c: Simplified usage of the internal xmlNsMap. Added a\n-\t  \"strict\" lookup for namespaces based on a prefix. Fixed a\n-\t  namespace processing issue in the clone-node function, which\n-\t  occurred if a @ctxt argument was given.\n-\t  \n-Fri Mar  3 17:44:10 CET 2006 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* valid.c: fix HTML attribute ID checking for input element.\n-\t  Maintain current attribute \"name\" behavior for now.\n-\n-Thu Mar  2 18:59:50 CET 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* tree.c: Bundled lookup of attr-nodes and retrieving their\n-\t  values into the functions xmlGetPropNodeInternal() and\n-\t  xmlGetPropNodeValueInternal(). Changed relevant code\n-\t  to use those functions.\n-\n-Mon Feb 27 20:42:04 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: workaround HP-UX compiler bug by Rick Jones\n-\n-Mon Feb 27 10:57:05 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml2.py: remove a tab, as pointed out on IRC\n-\n-Sat Feb 25 18:12:10 CET 2006 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* tree.c: Fix the add sibling functions when passing attributes.\n-\t  Modify testing for ID in xmlSetProp.\n-\t  No longer remove IDness when unlinking or replacing an attribute.\n-\n-Fri Feb 24 21:20:33 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: Martin Cole pointed out a bug in xmlCatalogAdd()\n-\t  if \/etc\/xml\/catalog doesn't exist.\n-\n-Thu Feb 23 23:06:18 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/\/*: updated the Ruby bindings links, and regenerated the\n-\t  docs.\n-\n-Thu Feb 23 09:12:27 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: improve catalog debugging message patch from Rick Jones\n-\n-Wed Feb 22 16:09:10 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/types.c: Nic Ferrier found debug statement left in the\n-\t  XPath conversion code\n-\n-Tue Feb 21 20:23:14 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xmllint.1 doc\/xmllint.xml: small man page improvements from\n-\t  Daniel Leidert\n-\n-Mon Feb 20 15:45:19 CET 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed a side-effect of the previous XSI bugfix:\n-\t  The constructor needs a bucket to be assigned during component\n-\t  fixup.\n-\n-Mon Feb 20 14:32:36 CET 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c xmlschemastypes.c: Fixed xs:boolean to reject\n-\t  the empty string (reported by Bas Driessen on the mailing-list).\n-\t  Fixed schema XSI-acquisition and construction: the schemata\n-\t  (xmlSchema) didn't get the targetNamespace in some cases, thus\t  \n-\t  the component resolution mechanism failed to work. The XSI\n-\t  stuff needs to be tested more intensively; think about how\n-\t  to test this for regression.\n-\n-Mon Feb 20 09:57:41 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xmllint.1 doc\/xmllint.xml: more man page improvements from\n-\t  Daniel Leidert\n-\n-Sun Feb 19 22:31:33 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xmllint.1 doc\/xmllint.xml: man page improvements from Daniel\n-\t  Leidert, c.f. #331290\n-\n-Sun Feb 19 17:54:04 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: fix an error report when using --path and --valid\n-\t  closes bug #331290\n-\n-Sun Feb 19 16:20:43 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: trying to fix #331062, this is again a problem\n-\t  around interleave, there is no good fix unless reimplementing\n-\t  but this works around some cases and allow to validate in that\n-\t  case.\n-\n-Wed Feb 15 11:55:22 CET 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* tree.c: Fixed bug #328896 reported by Liron. The path\n-\t  for text- and CDATA-section-nodes was computed incorrectly\n-\t  in xmlGetNodePath().\n-\n-Sun Feb 12 20:12:22 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: bug fixes for #327167 as well as some cleanups\n-\t  and more thorough tests on atoms comparisons.\n-\n-Thu Feb  9 10:07:20 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/wsockcompat.h: patch from Eric Zurcher to compile with\n-\t  Borland C++ 6\n-\n-Sun Feb  5 04:03:59 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: bill pointed out a missing block in xmlParseComment\n-\t  trying to fill with a normal processing of the given character.\n-\n-Sun Feb  5 03:41:39 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed the comment streaming bug raised by Graham Bennett\n-\t* test\/badcomment.xml result\/\/badcomment.xml*: added to the regression\n-\t  suite.\n-\n-Fri Feb  3 17:36:41 CET 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* include\/libxml\/tree.h: Added the xmlDOMWrapCloneNode() to\n-\t  the header file.\n-\n-Fri Feb  3 17:29:22 CET 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* tree.c: Added an initial version of xmlDOMWrapCloneNode() to\n-\t  the API. It will be used to reflect DOM's Node.cloneNode and\n-\t  Document.importNode methods.\n-\t  The pros: 1) non-recursive, 2) optimized ns-lookup\n-\t  (mostly pointer comparison), 3) user defined ns-lookup,\n-\t  4) save ns-processing. The function is in an unfinished\n-\t  and experimental state and should be only used to test it.\n-\n-Fri Feb  3 10:42:48 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: applied patch from Rob Richards fixing the URI regressions\n-\t  tests on Windows which seems to indicate bad escaping.\n-\n-Thu Feb  2 13:11:26 CET 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* tree.c: Fixed some bugs xmlDOMWrapReconcileNamespaces() wrt\n-\t  the previous addition of the removal of redundant ns-decls.\n-\n-Wed Feb  1 17:32:25 CET 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* tree.c: Enhanced xmlDOMWrapReconcileNamespaces() to remove\n-\t  redundant ns-decls if the option XML_DOM_RECONNS_REMOVEREDUND\n-\t  was given. Note that I haven't moved this option to the\n-\t  header file yet; so just call this function with an @option\n-\t  of 1 to test the behaviour.\t  \n-\n-Wed Feb  1 12:21:08 CET 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* tapi.c win32\/Makefile.*: Added changed as proposed on\n-\t  the mailing list by venkat naidu in order to compile\n-\t  testapi.c on windows.\n-\n-Thu Jan 19 09:57:28 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in xml2-config.in: trying to fix windows\/configure\n-\t  issues reported by Tim Van Holder\n-\n-Wed Jan 18 18:21:15 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c libxml.h parser.c: try to fix xmlParseInNodeContext\n-\t  when operating on an HTML document.\n-\n-Mon Jan  9 17:27:15 CET 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* relaxng.c include\/libxml\/relaxng.h: Added\n-\t  xmlRelaxNGSetParserStructuredErrors() to the API.\n-\n-Mon Jan  9 15:33:16 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: reverted first patches for #319279 which led to #326295\n-\t  and fixed the problem in xmlParseChunk() instead\n-\t* test\/ent11 result\/\/ent11*: added test for #326295 to the regression\n-\t  suite\n-\n-Thu Jan  5 16:25:06 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* NEWS configure.in libxml.spec.in testapi.c doc\/*: updated the news\n-\t  regenerated the docs, preparing for release of 2.6.23\n-\t* pattern.c xmlschemas.c: fixed some comments\n-\t\n-Thu Jan  5 15:48:27 CET 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* test\/XPath\/docs\/nodes test\/XPath\/tests\/nodespat\n-\t  result\/XPath\/tests\/nodespat: Added regression tests for\n-\t  the latest XPath\/pattern fixes.\n-\n-Thu Jan  5 15:43:38 CET 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* pattern.c: Another fix to handle \"foo\/\/.\": \"foo\" was not\n-\t  included in the resulting node-set.\n-\n-Thu Jan  5 13:22:29 CET 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* pattern.c xpath.c include\/libxml\/pattern.h:\n-\t  Fixed bug #322928, reported by Erich Schubert: The bug was\n-\t  in pattern.c, which is used for a tiny subset of xpath\n-\t  expression which can be evaluated in an optimized way.\n-\t  The doc-node was never considered when evaluating \"\/\/\"\n-\t  expressions. Additionally, we fixed resolution\n-\t  to nodes of any type in pattern.c; i.e. a \"\/\/.\" didn't work\n-\t  yet, as it did select only element-nodes. Due to this\n-\t  issue the pushing of nodes in xpath.c needed to be adjusted\n-\t  as well.\n-\n-Wed Jan  4 18:07:47 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: tiny refactoring patch from Bjorn Reese\n-\n-Wed Jan  4 15:00:51 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c: fix bug #324432 with <xml:foo\/>\n-\t* test\/ns7 result\/ns7*: added to the regression tests\n-\n-Wed Jan  4 10:53:56 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/wsockcompat.h: applied patch from Mark Junker, fixing a \n-\t  MinGW compilation problem, should close bug #324943\n-\n-Tue Jan  3 11:49:54 CET 2006 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Removed last dependency on the obsolete enum\n-\t  xmlSchemaValidError.\n-\n-Mon Jan  2 11:20:00 CET 2006 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c include\/libxml\/xmlreader.h xmlschemas.c: compilation\n-\t  and doc build fixes from Michael Day\n-\n-Wed Dec 28 22:12:34 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: bug in xmlRegExecPushString2() pointed out by \n-\t  Sreeni Nair.\n-\n-Tue Dec 20 16:55:31 CET 2005 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* tree.c: fix bug #322136 in xmlNodeBufGetContent when entity ref is \n-\t  a child of an element (fix by Oleksandr Kononenko).\n-\t* HTMLtree.c include\/libxml\/HTMLtree.h: Add htmlDocDumpMemoryFormat.\n-\n-Tue Dec 20 11:43:06 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c xmlstring.c: Fixed a segfault during\n-\t  text concatenation when validating a node tree:\n-\t  xmlStrncat was called with a @len of -1; but unlike\n-\t  xmlStrncatNew, it does not calculate the length\n-\t  automatically in such a case (reported by Judy Hay\n-\t  on the mailing list).\n-\t  Updated the descriptions of the involved string\n-\t  functions to note this.\n-\n-Thu Dec 15 12:11:07 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanohttp.c: applied patch from Gary Coady to accept gzipped\n-\t  http resources.\n-\n-Wed Dec 14 18:41:26 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* win32\/configure.js: Added enable\/disable of runtime\n-\t  debugging (LIBXML_DEBUG_RUNTIME).\n-\n-Wed Dec 14 18:11:50 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* include\/libxml\/xmlversion.h.in: Fixed to define\n-\t  LIBXML_DEBUG_RUNTIME on the basis of @WITH_RUN_DEBUG@.\n-\n-Tue Dec 13 12:49:23 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* test\/schemas\/bug321475* result\/schemas\/bug321475*:\n-\t  Added regression test for bug #321475 (reported by\n-\t  Gabor Nagy). Fixing of bug #323510 seemed to have\n-\t  fixed this bug as well.\n-\n-Mon Dec 12 16:19:16 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* test\/schemas\/bug323510* result\/schemas\/bug323510*:\n-\t  Added regression test for bug #323510.\n-\n-Mon Dec 12 16:11:13 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Workaround for bug #323510 (reported by\n-\t  Jonathan Filiatrault): substituted the epsilon transition\n-\t  for a labelled transition, in order to avoid a bug in\n-\t  xmlregexp.c which eliminated the epsilon transition and\n-\t  marked the initial state as final.\n-\n-Mon Dec 12 14:25:46 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: Gary Coady pointed a memory leak in\n-\t  xmlTextReaderReadInnerXml() applied patch fixing #323864\n-\n-Sat Dec 10 12:08:28 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c configure.in parserInternals.c runsuite.c runtest.c\n-\t  testapi.c xmlschemas.c xmlschemastypes.c xmlstring.c: fixed a number\n-\t  of warnings shown by HP-UX compiler and reported by Rick Jones\n-\n-Fri Dec  9 18:57:31 CET 2005 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* xmlwriter.c: Insert space between pubid and sysid when both \n-\t  passed to xmlTextWriterStartDTD and indenting not being used.\n-\t  Remove no longer used Mem callbacks.\n-\n-Fri Dec  9 11:01:16 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* runsuite.c: Changed to instantly mark instance-tests as\n-\t  failed if the corresponding schema was invalid. This\n-\t  reflects the side of the Python code for the XML Schema test\n-\t  suite. We now get the same number of failed tests on both\n-\t  sides.\n-\n-Wed Dec  7 14:59:01 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlreader.c include\/libxml\/xmlreader.h: Added\n-\t  xmlTextReaderSchemaValidateCtxt() to the API.\n-\n-Wed Dec  7 12:59:56 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed a segfault: the instance document was\n-\t  still tried to be validated, if the schema, dynamically\n-\t  acquired using XSI was invalid, thus mangled. The\n-\t  validation will stop (or rather won't validate) now in\n-\t  such a case. The schema parser error code will be set\n-\t  on the validion context now; this is somehow not nice,\n-\t  but it assures that the validation context indicates an\n-\t  error in there was a parser error.\n-\n-Tue Dec  6 18:57:23 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: small doc patch from Aron Stansvik\n-\t* legacy.c: another doc patch for a deprecated API\n-\n-Mon Dec  5 16:23:49 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* Makefile.am: Tiny change for 'make tests': raised\n-\t  the number of expected failures for James Clark's\n-\t  XML Schema datatype tests from 10 to 11. The additional\n-\t  reported error was agreed to be correct long time ago,\n-\t  but we missed to adjust the message reported by\n-\t  the testing script.\n-\n-Fri Dec  2 13:51:14 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* result\/schemas\/decimal* result\/schemas\/bug322411*:\n-\t  Added missing regression test results for the latest IDC\n-\t  and xs:decimal bugs.\n-\n-Wed Nov 30 12:22:23 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* test\/schemas\/decimal* test\/schemas\/bug322411*: Added\n-\t  regression tests for the latest IDC and xs:decimal bugs.\n-\n-Wed Nov 30 11:57:35 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed bubbling of duplicate IDC nodes: the\n-\t  parent's list of duplicates was filled with NULLs instead\n-\t  of the nodes under certain conditions. This lead to a\n-\t  segfault when the list's entries were accessed.\n-\n-Mon Nov 28 17:28:53 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemastypes.c: Fixed parsing of xs:decimal to\n-\t  allow\/deny special lexical forms. Fixed the totalDigits\n-\t  for values in the range (x < 1) &&  (x > -1) && (x != 0);\n-\t  E.g \"0.123\" has now a totalDigits of 3 (was 4 previously).\n-\t  Adjusted the comparison function for decimals due to this\n-\t  change. As a side effect comparison against zeroes was\n-\t  optimized.\n-\n-Mon Nov 28 13:25:11 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: An assignment to a local variable, which was\n-\t  used to access the IDC node list, was missing after the\n-\t  reallocation of the list (reported by Fabrice GUY\n-\t  bug #322411). Renamed the define ENABLE_IDC_NODE_TABLES\n-\t  to ENABLE_IDC_NODE_TABLES_TEST and *disabled* it, since\n-\t  it is used to force bubbling of IDC node tables even\n-\t  if not necessary; this was intended to be used for test\n-\t  purposes, but I obviously missed to disable it (although\n-\t  it apparently helped finding the bug).\n-\n-Wed Nov 23 17:34:52 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: In xmlSchemaAssembleByXSI() the return value\n-\t  of xmlSchemaGetMetaAttrInfo() was not assigned to anything;\n-\t  this caused XSI-driven-dynamic schema acquisition to fail\n-\t  with @noNamespaceSchemaLocation (reported by Julien Lamy\n-\t  on the mailing list).\n-\n-Tue Nov 22 18:31:34 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed a bug in xmlSchemaFindRedefCompInGraph()\n-\t  which caused the search for components to stop at the\n-\t  first encountered attribute group component.\n-\t  Fixed error report in xmlSchemaCheckSRCRedefineFirst(): the\n-\t  designation of a not-found component was not reported.\n-\n-Mon Nov 21 12:23:28 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: Albert Chin found another signed\/unsigned problem\n-\t  in the date and time code raised on IRIX 6.5\n-\n-Fri Nov 18 18:13:38 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c include\/libxml\/xmlschemas.h:\n-\t  Added xmlSchemaSetParserStructuredErrors() to the API.\n-\t  Fixed channeling of error relevant information to\n-\t  subsequent parser\/validation contexts.\n-\n-Thu Nov 17 14:11:43 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c: removed unreachable code pointed out by \n-\t  Oleksandr Kononenko, fixes bug #321695\n-\n-Thu Nov 17 08:24:31 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: use ctxt->standalone = -2 to indicate that the\n-\t  XMLDecl was parsed but no standalone attribute was found,\n-\t  suggested by Michael Day to detect if an XMLDecl was found.\n-\n-Tue Nov 15 09:49:24 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runtest.c: Hisashi Fujinaka pointed that errors in Schemas tests\n-\t  were not properly reported.\n-\n-Sun Nov 13 13:42:41 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: applied patch from Geert Jansen to remove xmlBufferClose()\n-\t  which is not needed.\n-\n-Fri Nov 11 13:48:52 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Changed xmlSchemaFormatIDCKeySequence()\n-\t  to use xmlSchemaGetCanonValueWhtspExt() in order to\n-\t  correctly report values for xs:anySimpleType.\n-\t* test\/schemas\/idc-keyref-err1*\n-\t  result\/schemas\/idc-keyref-err1*: Added a test for this change.\n-\n-Wed Nov  9 13:07:24 EST 2005 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* xmlIO.c xmlwriter.c: function consolidation when writing to xmlBuffer.\n-\t  Return error condition not len if xmlwriter fails writing to buffer.\n-\n-Wed Nov  9 09:54:54 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlsave.c xmlIO.c include\/libxml\/xmlIO.h include\/libxml\/xmlsave.h:\n-\t  applied patch from Geert Jansen to implement the save function to \n-\t  a xmlBuffer, and a bit of cleanup.\n-\n-Mon Nov  7 14:58:39 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c xmlschemastypes.c: Fixed the type of the\n-\t  totalDigits value to be positiveInteger.\n-\t  Fixed crash in an error report function when we gave it\n-\t  the document node; only element and attribute nodes are\n-\t  processed now (reported by Rob Richards).\n-\n-Tue Nov  1 16:22:29 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: fix bug #319897, problem with counted atoms\n-\t  when the transition itself is counted too\n-\t* result\/regexp\/hard test\/regexp\/hard: augmented the regression\n-\t  tests with the problem exposed.\n-\n-Tue Nov  1 11:54:39 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/Makefile.mingw include\/win32config.h: applied patch from\n-\t  Mark Junker to fix compilation with MinGW\n-\n-Fri Oct 28 18:36:08 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.3: tiny fix from Albert Chin\n-\t* runsuite.c runtest.c testapi.c: portability cleanup for arch\n-\t  needing trio for *printf\n-\n-Fri Oct 28 12:21:39 EDT 2005 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* tree.c: add additional checks to prevent tree corruption. fix problem \n-\t  copying attribute using xmlDocCopyNode from one document to another.\n-\n-Fri Oct 28 17:58:13 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* config.h.in configure.in vms\/config.vms macos\/src\/config-mac.h:\n-\t  cleanup from Albert Chin\n-\t* doc\/Makefile.am: html\/index.sgml doesn't exist anymore\n-\n-Fri Oct 28 16:53:51 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c xmlmodule.c: more portability patches from Albert Chin for\n-\t  HP-UX and AIX\n-\n-Fri Oct 28 10:36:10 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlmodule.c configure.in: applied 2 patches from Albert Chin for\n-\t  module portability\n-\n-Fri Oct 28 10:24:39 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c: fixing a portability problem on some old Unices with\n-\t  patch from Albert Chin\n-\n-2005-10-27  Aleksey Sanin <aleksey@aleksey.com>\n-\n-\t* c14n.c  result\/c14n\/exc-without-comments\/test-2\n-\t  test\/c14n\/exc-without-comments\/test-2.xml\n-\t  test\/c14n\/exc-without-comments\/test-2.xpath: fixing\n-\t  bug in exc-c14n namespace visibility + test case (bug #319367)\n-\n-Thu Oct 27 16:10:31 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.py: remove warnings to stdout patch from Nic Ferrier\n-\n-Thu Oct 27 13:54:52 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c xmlregexp.c include\/libxml\/valid.h\n-\t  include\/libxml\/xmlregexp.h: avoid function parameters names 'list'\n-\t  as this seems to give troubles with VC6 and stl as reported by\n-\t  Samuel Diaz Garcia.\n-\n-Wed Oct 26 10:59:21 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c: fix a problem in some error case on Solaris\n-\t  when passed a NULL filename, pointed by Albert Chin.\n-\n-Tue Oct 25 14:34:58 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: script HTML parser error fix, corrects bug #319715\n-\t* result\/HTML\/53867* test\/HTML\/53867.html: added test from Michael Day\n-\t  to the regression suite \n-\n-Tue Oct 25 14:21:11 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: typo fix from Michael Day\n-\n-Mon Oct 24 20:16:23 EDT 2005 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* tree.c: fix issue adding non-namespaced attributes in xmlAddChild(), \n-\t  xmlAddNextSibling() and xmlAddPrevSibling() (bug #319108) - part 1.\n-\n-Sat Oct 22 10:00:41 HKT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* parser.c: fixed second spot where CRLF split between chunks\n-\t  could cause trouble (bug #319279)\n-\t* gentest.py, testapi.c: fixed two problems involved with\n-\t  --with-minimum compilation (compilation errors with schematron\n-\t  and formal expressions tests)\n-\n-Fri Oct 21 10:50:14 EDT 2005 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* xmlsave.c: prevent output of fragment tags when serializing XHTML.\n-\n-Wed Oct 19 16:53:47 BST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: committing a some fixes and debug done yesterday in\n-\t  the London airport.\n-\n-Thu Oct 20 12:54:23 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Removed creation of a temporary parser context\n-\t  during validation when processing xsi:type; this previously\n-\t  added a string to the dict of the schema - to assure thread\n-\t  safety, we don't want to modify a given schema during\n-\t  validation.\n-\n-Thu Oct 20 17:05:29 HKT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlwriter.c: fixed problem in xmlTextWriterVSprintf caused by\n-\t  misuse of vsnprintf\n-\t* configure.in, config.h.in: added a configuration check for\n-\t  va_copy and added a define for VA_COPY for xmlwriter.c fix\n-\t* parser.c: fixed problem with CRLF split between chunks (bug\n-\t  #319279) (fix provided by Brion Vibber)\n-\n-Wed Oct 19 18:49:52 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed a potential memory leak in\n-\t  xmlSchemaCheckCSelectorXPath() when an internal error occurs.\n-\t  Fixed setting of ctxt->err to the given error code in\n-\t  the parsing error functions.\n-\t* pattern.c: Added internal xmlCompileIDCXPathPath() as a\n-\t  starting point for IDC XPath compilation; this and some other\n-\t  tiny changes fixes issues regarding whitespace in the\n-\t  expressions and IDC selector\/field relevant restrictions of\n-\t  the subset of XPath. Fixed a missing blocking of attributes\n-\t  in xmlStreamPushInternal().\n-\n-Mon Oct 17 15:06:05 EDT 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runtest.c: removed the error message\n-\t* relaxng.c xmlschemas.c: removed 2 instability warnings from function\n-\t  documentation\n-\t* include\/libxml\/schemasInternals.h: changed warning about API stability\n-\t* xmlregexp.c: trying to improve runtime execution of non-deterministic\n-\t  regexps and automata. Not fully finished but should be way better.\n-\n-Mon Oct 17 16:12:02 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed a memory leak in\n-\t  xmlSchemaContentModelDump(). Added output of local types\n-\t  in xmlSchemaElementDump(). Tiny cosmetical changes to the\n-\t  dump output.\n-\n-Mon Oct 17 14:29:08 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* tree.c pattern.c: Silenced intel compiler warnings (reported\n-\t  by Kjartan Maraas, bug #318517).\n-\t* xmlschemas.c: The above changes in pattern.c revealed an\n-\t  inconsistency wrt IDCs: we now _only_ pop XPath states, if\n-\t  we really pushed them beforehand; this was previously not\n-\t  checked for the case when we discover an element node to be\n-\t  invalid wrt the content model.\n-\t  Fixed segfault in xmlSchemaGetEffectiveValueConstraint().\n-\n-Fri Oct 14 16:40:18 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* result\/schemas\/*.err: Adapted regression test results.\n-\n-Fri Oct 14 16:21:22 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\t\n-\t* xmlschemas.c: Fixed some identity-constraint issues:\n-\t  Restructured IDC node-tables\n-\t  Allowed IDCs to resolve also to nodes of complex type with\n-\t  simple content.\n-\t  Added check for keyrefs with references to keyrefs.\n-\t  IDC target-nodes were interfering with IDC node-tables,\n-\t  since they used one list of entries only. I separated this\n-\t  one big list into 3 lists: 1 for IDC node-table entries,\n-\t  1 for _duplicates_ of IDC node-table entries and 1 for\n-\t  IDC target-nodes. More code, but cleaner and it works at last.\n-\t  Keyrefs will fail to resolve to duplicate key\/unique entries.\n-\t  I thought this was already working this way, but it didn't.\n-\t  The wording of the definition for [node table] in the spec\n-\t  can lead to a scenario, where keyrefs resolve perfectly, even\n-\t  if the relevant key-sequences of the referenced key\/unique have\n-\t  duplicates in the subtree. Currently only Saxon 8.5.1 is\n-\t  dissallowing resolution to duplicate entries correctly - we\n-\t  will follow Saxon here.\n-\t  Removed some intel compiler warnings (reported by\n-\t  Kjartan Maraas, bug #318517).\n-\t* pattern.c: Fixed an IDC-XPath problem when resolving to\n-\t  attributes.\t  \n-\n-Mon Oct 14 01:15:14 CEST 2005 Rob Richards <rrichards@ctindustries.net>\n-\t* nanohttp.c include\/wsockcompat.h: applied patch from Kolja Nowak \n-\t  to use getaddrinfo() if supported in Windows build (bug# 317431).\n-\n-Mon Oct 10 15:33:48 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* result\/schemas\/*: Adapted regression test results.\n-\n-Mon Oct 10 15:12:43 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c include\/libxml\/schemasInternals.h\n-\t  include\/libxml\/xmlerror.h: Initial implementation for\n-\t  redefinitions; this still misses checks for restrictions\n-\t  of the content model of complex types.\n-\t  Fixed default\/fixed values for attributes (looks like they\n-\t  did not work in the last  releases).\n-\t  Completed constraints for attribute uses.\n-\t  Separated attribute derivation from attribute constraints.\n-\t  Completed constraints for attribute group definitions.\n-\t  Disallowing <import>s of schemas in no target namespace if the\n-\t  importing schema is a chameleon schema. This contradicts\n-\t  the way Saxon, Xerces-J, XSV and IBM's SQC works, but the\n-\t  W3C XML Schema WG, thinks it is correct to disallow such\n-\t  imports.\n-\t  Added cos-all-limited constraints.\n-\t  Restructured reference resolution to model groups and element\n-\t  declarations.\n-\t  Misc cleanup.\n-\n-Fri Oct  7 04:34:12 CEST 2005 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* schematron.c xmlregexp.c: remove warnings under Windows.\n-\n-Wed Sep 28 23:42:14 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: applied patch from Massimo Morara fixing bug #317447\n-\t  about risk of invalid write in xmlStringLenDecodeEntities\n-\n-Tue Sep 27 11:20:57 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c: Adrian Mouat pointed out redundancies in xmlReportError()\n-\n-Mon Sep 26 19:18:24 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: seems a test to avoid duplicate transition is \n-\t  really needed at all times. Luka Por gave an example hitting\n-\t  this. Changed back the internal API.\n-\n-Thu Sep 22 13:14:07 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: fixing leak in xmlTextReaderReadString() #316924\n-\n-Thu Sep 15 16:12:44 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: more fixes to the behaviour of xmlBuildRelativeURI\n-\n-Thu Sep 15 15:08:21 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: detect combinatory explosion and return with\n-\t  a runtime error in those case, c.f. #316338 though maybe we\n-\t  should not see such an explosion with that specific regexp,\n-\t  more checking needs to be done.\n-\n-Wed Sep 14 19:52:18 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* include\/libxml\/schemasInternals.h: Added some comments for the\n-\t  struct fields.\n-\n-Wed Sep 14 13:24:27 HKT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* uri.c: fixed problem when xmlBuildRelativeURI was given a\n-\t  blank path (bug 316224)\n-\n-Mon Sep 12 23:41:40 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* NEWS configure.in doc\/\/*: release of 2.6.22 updated doc and\n-\t  rebuild.\n-\t* xmlsave.c include\/libxml\/xmlsave.h: added XML_SAVE_NO_XHTML\n-\t  xmlSaveOption\n-\t* xmlschemas.c: minor cleanups\n-\n-Mon Sep 12 21:42:47 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\t\n-\t* test\/schemas\/import1_0.xsd: And adapting another one.\n-\n-Mon Sep 12 21:29:35 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* result\/schemas\/derivation-ok-extension_0_0: Adapted result.\n-\n-Mon Sep 12 21:20:41 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* result\/schemas\/allsg_0_3.err result\/schemas\/allsg_0_4.err\n-\t  result\/schemas\/changelog093_1_0.err\n-\t  result\/schemas\/derivation-ok-extension_0_0.err\n-\t  result\/schemas\/import1_0_0.err\n-\t  result\/schemas\/derivation-ok-restriction-2-1-1_0_0.err:\n-\t  Adapted regression results.\n-\n-Mon Sep 12 21:00:53 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c include\/libxml\/schemasInternals.h\n-\t  include\/libxml\/xmlerror.h: Completion of the schema graph.\n-\t  Centralisation, more robustness of the schema document\n-\t  acquisition story. Centralised and restructured component fixup.\n-\t  Fixed attribute derivation when 'prohibiting' attribute uses.\n-\t  Added warnings: when schema documents cannot be localized\n-\t  during imports; when we get duplicate and pointless attribute\n-\t  prohibitions. Changed error reports for IDCs to report\n-\t  the relevant IDC designation as well (requested by GUY Fabrice).\n-\t  Misc code-cleanup.\n-\n-Mon Sep 12 16:02:12 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlsave.c: applied second patch from David Madore to be less intrusive\n-\t  when handling scripts and style elements in XHTML1 should fix #316041\n-\t* test\/xhtml1 result\/\/xhtml1\\*: updated the test accordingly\n-\n-Mon Sep 12 15:09:09 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in doc\/devhelp\/*: finished the integration with\n-\t  devhelp, completing the index and inserted into the gtk-doc\n-\t  database at \"make install\" stage\n-\n-Mon Sep 12 14:14:12 CEST 2005 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* include\/libxml\/xmlsave.h xmlsave.c: add XML_SAVE_NO_EMPTY save option\n-\t  and use option from xmlSaveCtxtPtr rather than global during output.\n-\t* xmlsave.c: fix some output formatting for meta element under XHTML.\n-\n-Mon Sep 12 11:12:03 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/parser.h parser.c xmllint.c: damn XML_FEATURE_UNICODE\n-\t  clashes with Expat headers rename to XML_WITH_ to fix bug #316053. \n-\t* doc\/Makefile.am: build devhelp before the examples.\n-\t* doc\/*: regenerated the API\n-\n-Mon Sep 12 02:03:12 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlsave.c: fix bug #316034, where xmlElemDump() can crash if \n-\t  given a document pointer instead of an element\n-\n-Mon Sep 12 01:26:16 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/devhelp\/devhelp.xsl: improvements on the html generation,\n-\t  should be complete with navigation, what is left done is glueing\n-\n-Mon Sep 12 00:03:27 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in doc\/Makefile.am doc\/apibuild.py doc\/libxml2-api.xml\n-\t  doc\/devhelp\/*: started work needed to generate devhelp content,\n-\t  not too hard based on the existing format and extractor.\n-\n-Fri Sep  9 12:56:19 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixes bug #315617 when using push CDATA in some cases.\n-\n-Thu Sep  8 23:39:41 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: patch from Stéphane Bidoul to compile without schematron\n-\n-Wed Sep  7 00:16:27 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c: patch from Oleg Paraschenko to fix xmlDebugDumpNode()\n-\t  when handled a namespace node.\n-\n-Sun Sep  4 23:36:45 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* NEWS elfgcchack.h testapi.c doc\/*: updated the docs and rebuild\n-\t  releasing 2.6.21\n-\t* include\/libxml\/threads.h threads.c: removed xmlIsThreadsEnabled()\n-\t* threads.c include\/libxml\/threads.h xmllint.c: added the more\n-\t  generic xmlHasFeature() as suggested by Bjorn Reese, xmllint uses it.\n-\n-Sun Sep  4 22:45:49 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in doc\/* configure.in: prepare for release\n-\t* xpath.c: work for #303289, fix a formatting bug for MIN_INT\n-\n-Sun Sep  4 15:48:57 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: real fix for #314881 and #314759 is was a bit more complex\n-\t  than initially expected as ctxt->error == NULL had behaviour side\n-\t  effects at the compilation level itself.\n-\n-Sun Sep  4 14:01:00 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* pattern.c xpath.c include\/libxml\/pattern.h: fixing yet another\n-\t  pattern induced XPath bug #314282\n-\t* relaxng.c: reverted back last change it was seriously broken\n-\n-Sat Sep  3 16:51:55 CEST 2005 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* xmlsave.c: check for NULL to prevent crash with meta elements\n-\n-Sat Sep  3 16:26:55 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: structured error reporting problem with Relax-NG\n-\t  should fix #314881 and #314759\n-\n-Sat Sep  3 15:42:29 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* pattern.c: fixes a portability problem raised by C370 on Z\/OS\n-\n-Sat Sep  3 15:26:31 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c tree.c valid.c: fixing a number of issues raised by xml:id\n-\t  but more generally related to attributes and ID handling, fixes\n-\t  #314358 among other things\n-\n-Fri Sep  2 14:26:43 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c parserInternals.c: avoid passing a char[] as snprintf\n-\t  first argument.\n-\t* threads.c include\/libxml\/threads.h: implemented xmlIsThreadsEnabled()\n-\t  based on Andrew W. Nosenko idea.\n-\t* doc\/* elfgcchack.h: regenerated the API\n-\n-Thu Sep  1 14:44:42 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: the use of AM_PATH_PYTHON is not portable enough\n-\t  reverting back to AM_PATH_PROG\n-\n-Thu Sep  1 11:42:39 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: Applied the last patch from Gary Coady for #304637\n-\t  changing the behaviour when text nodes are found in body\n-\t* result\/HTML\/*: this changes the output of some tests\n-\n-Thu Sep  1 11:22:37 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/downloads.html doc\/xml.html: adding reference to Bull AIX rpms\n-\t  c.f. #160598\n-\n-Wed Aug 31 11:39:02 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xml2-config.in: removed the obsolete --libtool-libs option, c.f.\n-\t  bug #314853\n-\n-Fri Aug 26 17:33:26 CEST 2005 Rob Richards <rrichards@ctindustries.net>\n-\n-\t* xmlsave.c: move handling of meta element for http-equiv in XHTML docs \n-\t  to serialization and no longer modify internal tree.\n-\n-Fri Aug 26 00:51:58 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in: the profiling usually don't work, disabled\n-\t* doc\/*: rebuilt\n-\n-Thu Aug 25 23:47:55 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: trying to fix the first part of #310033 by\n-\t  detecting gcc <= 3.2\n-\n-Thu Aug 25 22:13:37 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c: fixed bug #310033, the URI extraction code given a\n-\t  node is a bit twisted and broke in the last months.\n-\n-Thu Aug 25 16:18:15 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c result\/XPath\/xptr\/strrange2: uninitialized field and\n-\t  fix on test.\n-\n-Thu Aug 25 16:03:05 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c: change verbosity depending on API\n-\t* result\/XPath\/tests\/* result\/XPath\/xptr\/* result\/xmlid\/*: get back\n-\t  to previous outputs\n-\n-Thu Aug 25 15:14:56 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c parser.c SAX2.c debugXML.c tree.c valid.c xmlreader.c\n-\t  xmllint.c include\/libxml\/HTMLparser.h include\/libxml\/parser.h:\n-\t  added a parser XML_PARSE_COMPACT option to allocate small \n-\t  text nodes (less than 8 bytes on 32bits, less than 16bytes on 64bits)\n-\t  directly within the node, various changes to cope with this.\n-\t* result\/XPath\/tests\/* result\/XPath\/xptr\/* result\/xmlid\/*: this \n-\t  slightly change the output\n-\n-Thu Aug 25 12:16:26 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: patch from Andrew W. Nosenko, use se $GCC = 'yes'\n-\t  instead of $CC = 'gcc' because GCC may have a different name\n-\n-Thu Aug 25 00:18:20 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: changes the way the python binary is found, should\n-\t  also fix bug #308004\n-\n-Wed Aug 24 16:44:41 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: found another bug while looking at #309616 on missing\n-\t  entities.\n-\t* result\/ent2.sax* result\/ent7.sax* result\/xml2.sax*: this changed the\n-\t  SAX stream in missing conditions for a few tests\n-\n-Wed Aug 24 16:19:00 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: applied the patch suggested #309565 which can avoid\n-\t  looping in error conditions.\n-\n-Wed Aug 24 16:04:17 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c tree.c: line numbers are now carried by most nodes, fixing\n-\t  xmlGetLineNo() c.f. bug #309205\n-\n-Wed Aug 24 14:43:34 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c error.c include\/libxml\/xmlerror.h: finally converted\n-\t  the encoding module to the common error reporting mechanism\n-\t* doc\/* doc\/html\/libxml-xmlerror.html: rebuilt\n-\n-Wed Aug 24 11:35:26 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: removed a potentially uninitialized variable error\n-\t* python\/generator.py: fixed a deprecation warning\n-\t* python\/tests\/tstLastError.py: silent the damn test when Okay !\n-\n-Wed Aug 24 00:11:16 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c globals.c runtest.c testC14N.c testapi.c tree.c\n-\t  include\/libxml\/SAX2.h include\/libxml\/xmlregexp.h: fixed compilation\n-\t  when configured --without-sax1 and other cleanups fixes bug #172683\n-\t* doc\/* elfgcchack.h: regenerated\n-\n-Tue Aug 23 20:05:05 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed bug #170489 reported by Jirka Kosek\n-\t* test\/valid\/objednavka.xml test\/valid\/dtds\/objednavka.dtd\n-\t  result\/valid\/objednavka*: added the test to the regression suite.\n-\n-Tue Aug 23 18:04:08 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c include\/libxml\/HTMLparser.h: added a recovery mode\n-\t  for the HTML parser based on the suggestions of bug #169834 by\n-\t  Paul Loberg\n-\n-Tue Aug 23 15:38:46 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* elfgcchack.h testapi.c doc\/*: regenerated\n-\t* schematron.c: fixed a compilation problem\n-\t* xmlregexp.c include\/libxml\/xmlregexp.h: some cleanups and one bug fix\n-\t* result\/expr\/base: slightly changes the number of Cons.\n-\n-Mon Aug 22 23:19:50 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* elfgcchack.h testapi.c doc\/*: rescanned code and rebuilt\n-\t* xmlregexp.c: small cleanup\n-\t* include\/libxml\/schematron.h include\/libxml\/xmlexports.h\n-\t  include\/libxml\/xmlversion.h.in: cleanup problems from code scanner\n-\n-Mon Aug 22 18:00:18 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: applied patch from Kuba Nowakowski fixing bug\n-\t  #313982\n-\t* result\/schemas\/bug313982* test\/schemas\/bug313982*: also added\n-\t  the test case to the regression suite.\n-\n-Mon Aug 22 17:50:20 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testRegexp.c: printed the wrong string\n-\n-Mon Aug 22 16:42:07 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testRegexp.c xmlregexp.c include\/libxml\/xmlregexp.h: exported\n-\t  xmlExpExpDerive(), added it to the testRegexp command line \n-\t  tool when providing multiple expressions.\n-\n-Mon Aug 22 14:57:13 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am result\/expr\/base test\/expr\/base: added the first\n-\t  regression test suite set for the new expression support\n-\n-Mon Aug 22 13:49:18 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: fixed an uninitialized variable\n-\t* xmlregexp.c include\/libxml\/xmlregexp.h: extended the API to\n-\t  add the parser, serializer and some debugging\n-\t* include\/libxml\/xmlversion.h.in: made the new support compiled\n-\t  by default if Schemas is included\n-\t* testRegexp.c: cleanup and integration of the first part of the\n-\t  new code with a special switch\n-\t* xmllint.c: show up Expr in --version if compiled in\n-\t* include\/libxml\/tree.h: moved the xmlBuffer definition up\n-\n-Mon Aug 22 12:11:10 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Some preparation for the creation of a graph\n-\t  of imported\/included\/redefined schemas; this is needed for\n-\t  at least the redefinitions.\n-\t  Centralized the creation of the parser context in one function.\n-\n-Mon Aug 22 02:19:33 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c include\/libxml\/xmlregexp.h: pushing the formal expression\n-\t  handling code to have it in CVs from now. Not plugged, and misses \n-\t  APIs it's not compiled in yet.\n-\n-Sat Aug 20 23:13:27 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: applied another patch from Rob Richards to fix\n-\t  xmlTextReaderGetAttributeNs and xmlTextReaderMoveToAttributeNs\n-\n-Wed Aug 17 09:06:33 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: applied patch from Rob Richards to fix \n-\t  xmlTextReaderGetAttribute behaviour with namespace declarations\n-\n-Fri Aug 12 14:12:56 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c include\/libxml\/xmlerror.h:\n-\t  Changed output for keyref-match errors; the target-node will\n-\t  be now reported rather than the scope-node of the keyref\n-\t  definition - allowing easier chasing of instance errors.\n-\t  This was reported by Guy Fabrice to the mailing list.\n-\t  Some initial parsing code for schema redefinitions.\n-\t* result\/schemas\/bug303566_1_1.err\n-\t  result\/schemas\/bug312957_1_0.err: Adapted test results due\n-\t  to the keyref changes.\n-\n-Fri Aug 12 12:17:52 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: applied patch from Derek Poon fixing bug #310692\n-\n-Wed Aug 10 23:39:02 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: fix for bug #312945 as pointed by Dean Hill, the\n-\t  context type was not always properly initialized. \n-\n-Wed Aug 10 18:21:41 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: fixed bug #307377 about validation of choices in\n-\t  list values.\n-\t* test\/relaxng\/307377* result\/relaxng\/307377* Makefile.am runtest.c:\n-\t  added examples to the regression tests, problem is that streaming\n-\t  version gives slightly more information.\n-\n-Wed Aug 10 15:25:53 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: fixed bug #302302, nasty but the fix is rather simple.\n-\n-Wed Aug 10 11:59:46 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* result\/schemas\/any6_1_0*: Added missing test results.\n-\n-Tue Aug  9 23:37:22 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: fixed a determinism detection problem exposed by\n-\t  ##other tests committed by Kasimier, also added a small speedup\n-\t  of determinism detection.\n-\t* test\/results\/any6_2_0* any8_1_0* any7_1_2* any7_2_2*: added \n-\t  the results to the regression tests now\n-\n-Tue Aug  9 15:54:09 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* test\/schemas\/any7_2.xml test\/schemas\/any6_2.xsd\n-\t  test\/schemas\/any8_1.xsd test\/schemas\/any8_0.xml:\n-\t  Added some more tests for element wildcards.\n-\n-Tue Aug  9 14:22:47 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed #312957 reported by Carol Hunter:\n-\t  streaming XPath states were not popped in every case,\n-\t  thus failed to resolve correctly for subsequent input.\n-\t* test\/schemas\/bug312957* result\/schemas\/bug312957*:\n-\t  Added the test submitted by Carol Hunter.\n-\n-Tue Aug  9 13:07:27 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c xmlschemas.c: trying to nail down the remaining\n-\t  ##other issues\n-\t* result\/schemas\/any7* test\/schemas\/any7: completed the tests\n-\t  and added the results\n-\t* result\/schemas\/any3_0_0.err result\/schemas\/any5_0_0.err\n-\t  result\/schemas\/any5_1_0.err: this slightly changes the output\n-\t  from 3 existing tests\n-\n-Mon Aug  8 22:33:08 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanoftp.c nanohttp.c xmlschemastypes.c: applied patch from \n-\t  Marcus Boerger to remove warnings on Windows.\n-\n-Mon Aug  8 16:43:04 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlsave.c include\/libxml\/xmlsave.h: fixed #145092 by adding \n-\t  an xmlSaveOption to omit XML declaration\n-\n-Mon Aug  8 15:44:54 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c: fixed bug #310333 with a patch close to the provided\n-\t  patch for HTML UTF-8 serialization\n-\t* result\/HTML\/script2.html: this changed the output of that test\n-\n-Mon Aug  8 15:01:51 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: fixed bug #310264, basically it's about reentrancy\n-\t  of count based transition, when going though the counter must\n-\t  be reset to 0\n-\t* test\/schemas\/bug310264* result\/schemas\/bug310264*: added the\n-\t  regression test.\n-\n-Mon Aug  8 14:40:52 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed a memory leak: xmlSchemaFreeAnnot() was\n-\t  only freeing the first annotation in the list.\n-\n-Mon Aug  8 09:44:34 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: applied patch from Rob Richards fixing\n-\t  xmlTextReaderGetAttribute\n-\n-Mon Aug  8 01:41:53 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fixed an uninitialized memory access spotted by\n-\t  valgrind\n-\n-Sun Aug  7 12:39:35 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* test\/relaxng\/docbook_0.xml: get rid of the dependency on a locally\n-\t  installed DTD\n-\t* uri.c include\/libxml\/uri.h xmlIO.c nanoftp.c nanohttp.c: try to\n-\t  cleanup the Path\/URI conversion mess, needed fixing in various \n-\t  layers and a new API to the uri module which also fixes #306861\n-\t* runtest.c: integrated a regression test specific to check the\n-\t  URI conversions done before calling the I\/O handlers.\n-\n-Sat Aug  6 11:06:24 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/XSLT.html doc\/xml.html: small doc fix for #312647\n-\n-Tue Aug  2 13:26:42 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/configure.js: applied patch from Rob Richards to allow\n-\t  disabling modules in win32, fixes #304071\n-\n-Mon Aug  1 07:18:53 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c: applied fix from Jakub Piotr Clapa for\n-\t  xmlAttr.parent(), closing #312181\n-\n-Sun Jul 31 18:48:55 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* schematron.c: report improvement\n-\t* test\/schematron\/zvon* result\/schematron\/zvon*: more tests\n-\n-Sun Jul 31 16:02:59 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/Makefile.msvc win32\/configure.js: applied patch from Rob\n-\t  Richards to add schematron to the build on Windows\n-\t* test\/schematron\/zvon3* result\/schematron\/zvon3*: second test\n-\t* test\/schematron\/zvon10* result\/schematron\/zvon10*: this is the\n-\t  real second test 10 and 2 are swapped.\n-\n-Sun Jul 31 15:42:31 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* schematron.c: more bug fixes, improve the error reporting.\n-\t* test\/schematron\/zvon2* result\/schematron\/zvon2*: second test\n-\n-Sun Jul 31 14:15:31 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* schematron.c xmllint.c: fixing the loop bug, fixing schematron\n-\t  text error rendering\n-\t* Makefile.am result\/schematron\/* test\/schematron\/zvon1*.sct:\n-\t  started integrating within \"make tests\"\n-\n-Sat Jul 30 17:26:58 EDT 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* test\/schematron\/*: a few first tests from Zvon unfortunately\n-\t  with the old syntax\n-\n-Sat Jul 30 17:08:07 EDT 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* schematron.c xmllint.c include\/libxml\/schematron.h: committing\n-\t  work done on the plane last week-end\n-\n-Sat Jul 30 15:16:29 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runtest.c: allows an extra argument to subset the tests\n-\t* xmlregexp.c: big speedup for validation, basically avoided\n-\t  transition creation explosion when removing epsilon transition\n-\t  \n-Sat Jul 30 00:00:46 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am globals.c parserInternals.c xmlreader.c xmlunicode.c\n-\t  xmlwriter.c: more cleanups based on sparse reports, added \n-\t  \"make sparse\"\n-\n-Fri Jul 29 12:11:25 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c: don't output any message on failed resolver lookups,\n-\t  better done by the python user provided resolver layer.\n-\n-Fri Jul 29 01:48:02 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c SAX2.c encoding.c globals.c parser.c relaxng.c\n-\t  runsuite.c runtest.c schematron.c testHTML.c testReader.c\n-\t  testRegexp.c testSAX.c testThreads.c valid.c xinclude.c xmlIO.c\n-\t  xmllint.c xmlmodule.c xmlschemas.c xpath.c xpointer.c: a lot of \n-\t  small cleanups based on Linus' sparse check output.\n-\n-Thu Jul 28 21:28:33 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/Makefile.am: added schematron.h, oops ...\n-\n-Thu Jul 28 02:38:21 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemastypes.c: Added creation of the content type of\n-\t  xs:anyType. This is needed when trying to extend xs:anyType\n-\t  (although it makes no sense to extend it; IMHO the schema\n-\t  people should have ruled this out). This was reported\n-\t  by Yong Chen to the mailing list.\n-\t* xmlschemas.c: Fixed handling of xs:anyType in\n-\t  xmlSchemaCheckCOSCTExtends() (reported by Young Chen). Tiny\n-\t  adjustment to an error report output.\n-\t* test\/schemas\/extension2* result\/schemas\/extension2*:\n-\t  Added a test case provided by Young Chen.\n-\n-Mon Jul 25 11:41:18 PDT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* uri.c: enhanced xmlBuildRelativeURI to allow the URI and the\n-\t  base to be in \"relative\" form\n-\n-Sun Jul 24 10:25:41 EDT 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* schematron.c xmllint.c: started adding schematron to the xmllint\n-\t  tool, the report infrastructure is gonna be fun.\n-\n-Sat Jul 23 23:23:51 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* test\/schemas\/any6* test\/schemas\/any7*: Added regression tests\n-\t  (they fail currently), but did not added results yet.\n-\n-Sat Jul 23 23:07:05 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Removed the workaround code in\n-\t  xmlSchemaValidateElemWildcard() for the <any> wildcard\n-\t  with namespace == ##other. Support for such wildcards was\n-\t  implemented by Daniel at the automaton level recently, and\n-\t  the workaround code iterfered with it.\n-\n-Sat Jul 23 10:55:50 EDT 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* pattern.c include\/libxml\/pattern.h: changed xmlPatterncompile\n-\t  signature to pass an int and not an enum since it can generate\n-\t  ABI compat troubles.\n-\t* include\/libxml\/schematron.h schematron.c: adding the new \n-\t  schematron code, work in progress lots to be left and needing\n-\t  testing\n-\t* include\/libxml\/xmlversion.h.in include\/libxml\/xmlwin32version.h.in\n-\t  Makefile.am configure.in: integration of schematron into the\n-\t  build\n-\t* xpath.c include\/libxml\/xpath.h: adding flags to control compilation\n-\t  options right now just XML_XPATH_CHECKNS.\n-\n-Sat Jul 23 16:39:35 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Removed an \"internal error\" message from\n-\t  xmlSchemaBuildAContentModel() when an empty model group\n-\t  definition is hit.\n-\n-Sat Jul 23 00:34:07 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* pattern.c: Changed xmlCompileStepPattern() and\n-\t  xmlCompileAttributeTest() to handle the \"xml\" prefix without\n-\t  caring if the XML namespace was supplied by the user.\n-\n-Fri Jul 22 00:08:43 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed xmlSchemaPSimpleTypeErr(), which did not\n-\t  output the given string arguments correctly.\n-\n-Thu Jul 21 09:21:00 EDT 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c globals.c parser.c runtest.c testHTML.c testSAX.c\n-\t  threads.c valid.c xmllint.c xmlreader.c xmlschemas.c xmlstring.c\n-\t  xmlwriter.c include\/libxml\/parser.h include\/libxml\/relaxng.h\n-\t  include\/libxml\/valid.h include\/libxml\/xmlIO.h\n-\t  include\/libxml\/xmlerror.h include\/libxml\/xmlexports.h\n-\t  include\/libxml\/xmlschemas.h: applied a patch from Marcus Boerger\n-\t  to fix problems with calling conventions on Windows this should\n-\t  fix #309757\n-\n-Wed Jul 20 14:45:39 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: an optimization of the char data inner loop,\n-\t  can gain up to 10% in pure SAX2 parsing speed\n-\t* xmlschemas.c: applied patch from Kupriyanov Anatolij fixing\n-\t  a bug in XML Schemas facet comparison #310893\n-\n-Tue Jul 19 17:27:26 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c xmlschemas.c: fixed the error reporting for\n-\t  not transitions\n-\t* result\/schemas\/any5_0_0* result\/schemas\/any5_0_2*\n-\t  result\/schemas\/any5_1_0*: fixed output\n-\n-Tue Jul 19 15:34:12 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c xmlschemas.c include\/libxml\/xmlautomata.h: fixing\n-\t  bug #172215 about foreign namespaces by adding support for\n-\t  negated string transitions. Error messages still need to be\n-\t  improved.\n-\t* test\/schemas\/any5* result\/schemas\/any5*: adding regression\n-\t  tests for this.\n-\n-Tue Jul 19 12:33:31 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: applied patch from Alexander Pohoyda fixing xmlGetNodePath\n-\t  on namespaced attributes #310417.\n-\n-Mon Jul 18 23:01:15 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xmllint.1 doc\/xmllint.html doc\/xmllint.xml: --nonet was\n-\t  ducplicated\n-\n-Mon Jul 18 20:49:28 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: fixed xsd:all when used in conjunction with\n-\t  substitution groups\n-\t* test\/schemas\/allsg_* result\/schemas\/allsg_*: adding specific\n-\t  regression tests, strangely missing from NIST\/Sun\/Microsoft\n-\t  testsuites\n-\n-Sun Jul 17 07:11:27 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: fixed bug #307508, a bad automata was built but\n-\t  this showed as an indeterminist result\n-\n-Thu Jul 14 17:53:02 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: found the last bug raised by NIST tests in\n-\t  comparing base64 strings, result from runsuite:\n-\t  ## NIST test suite for Schemas version NIST2004-01-14\n-\t  Ran 23170 tests (3953 schemata), no errors\n-\n-Thu Jul 14 14:57:36 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testRegexp.c: fixed where xmlMemoryDump() should be called.\n-\t* xmlregexp.c: fixed handling of {0}, \\n, \\r and \\t, two bugs\n-\t  affecting NIST regression tests\n-\n-Thu Jul 14 11:30:24 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: applied a patch from Gerrit P. Haase to add\n-\t  module support on cygwin\n-\n-Thu Jul 14 10:56:42 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fixed a potential buffer overrun error introduced\n-\t  on last commit to htmlParseScript() c.f. #310229\n-\n-Thu Jul 14 23:48:17 PDT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: Changed the behaviour of xmlXPathEqualNodeSetFloat to\n-\t  return TRUE if a nodeset with a numeric value of NaN is compared\n-\t  for inequality with any numeric value (bug 309914).\n-\t  \n-Thu Jul 14 01:03:03 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c relaxng.c xmlreader.c xmlschemas.c include\/libxml\/relaxng.h\n-\t  include\/libxml\/xmlschemas.h: applied patch from Marcus Boerger\n-\t  to route relaxng and schemas error messages when using the reader\n-\t  through the structured interface if activated.\n-\t* elfgcchack.h doc\/* testapi.c: rebuilt since this add  new APIs\n-\t  to test.\n-\n-Wed Jul 13 18:35:47 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: applied UTF-8 script parsing bug #310229 fix from\n-\t  Jiri Netolicky \n-\t* result\/HTML\/script2.html* test\/HTML\/script2.html: added the test\n-\t  case from the regression suite\n-\n-Tue Jul 12 17:08:11 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanohttp.c: fixed bug #310105 with http_proxy environments with\n-\t  patch provided by Peter Breitenlohner\n-\n-Mon Jul 11 00:28:10 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am NEWS configure.in doc\/*: preparing release 2.6.20 \n-\t* xmllint.c: removed a compilation problem\n-\n-Sun Jul 10 23:33:41 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xstc\/Makefile.am README README.tests Makefile.tests Makefile.am:\n-\t  preparing to make testsuite releases along with code source releases\n-\t* gentest.py testapi.c: fixed a couple of problem introduced by\n-\t  the new Schemas support for Readers\n-\t* xpath.c: fixed the XPath attribute:: bug #309580, #309864 in a crude\n-\t  but simple way.\n-\t* xmlschemas.c include\/libxml\/tree.h: fixed a couple of problems\n-\t  raised by the doc builder.\n-\t* doc\/*: made rebuild\n-\n-Sun Jul 10 21:51:16 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: fixed a bug introduced on last commit\n-\n-Sun Jul 10 21:00:54 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xmllint.1 doc\/xmllint.html doc\/xmllint.xml: fixed a typo\n-\t  pointed by Jeroen Ruigrok\n-\t* include\/libxml\/xmlreader.h include\/libxml\/xmlschemas.h: increased\n-\t  the APIs for xmlReader schemas validation support\n-\t* xmllint.c xmlreader.c xmlschemas.c: xmlReader schemas validation\n-\t  implementation and testing as xmllint --stream --schema ...\n-\n-Sun Jul 10 16:11:26 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlwin32version.h.in: try to avoid conflicts.\n-\n-Sat Jul  9 19:29:10 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fix for #309761 from Dylan Shell  \n-\t* xmlschemas.c include\/libxml\/xmlschemas.h: added xmlSchemaSAXPlug\n-\t  and xmlSchemaSAXUnplug generic APIs for SAX Schemas validation.\n-\t* xmllint.c: couple of fixes plus added descriptions for --sax and\n-\t  --sax1\n-\n-Fri Jul  8 23:35:00 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Added c-props-correct constraint to check\n-\t  for equal cardinality of keyref\/key.\n-\t* include\/libxml\/xmlerror.h: Added an error code.\n-\n-Fri Jul  8 21:56:04 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* pattern.c: Fixed evaluation of attributes. Actually only\n-\t  attribute at the first level were evaluated (e.g. \"@attr\");\n-\t  expression like \"foo\/@attr\" always failed.\n-\n-Fri Jul  8 20:04:29 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: tiny fix in xmlSchemaValidateStream() if a\n-\t  user-provided SAX handler is given.\n-\n-Fri Jul  8 19:25:26 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fix some potential leaks in error cases.\n-\t* xmllint.c: added --sax, to allow testing of --schemas --sax and\n-\t  various other combinations.\n-\t* xmlschemas.c: fix a couple of tiny problems in\n-\t  xmlSchemaValidateStream()\n-\n-Fri Jul  8 18:34:22 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\t\n-\t* xmlschemas.c: Changed xmlSchemaValidateFile() to use\n-\t  xmlSchemaValidateStream() internally.\n-\n-Fri Jul  8 17:02:14 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* test\/relaxng\/docbook_0.xml: added the missing entity to the\n-\t  document internal subset to avoid errors if the DocBook catalogs\n-\t  are not there\n-\t* xmlschemas.c: first cut at implementing xmlSchemaValidateStream()\n-\t  untested yet\n-\n-Wed Jul  6 15:45:48 PDT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* parser.c: fixed problem with free on dupl attribute in\n-\t  dtd (bug309637).\n-\t* test\/errors\/attr3.xml, result\/errors\/attr3.*: added\n-\t  regression test for this\n-\n-Wed Jul  6 13:11:35 PDT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* win32\/Makefile.msvc: try again to fix file format for Windows\n-\n-Wed Jul  6 12:20:13 PDT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* win32\/Makefile.msvc: removed spurious ^M\n-\t* runtest.c: added check for option O_BINARY\n-\t* test\/schemas\/bug309338*, result\/schemas\/bug309338*: changed\n-\t  sticky tag to 'binary'\n-\n-Wed Jul  6 10:38:02 PDT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* debugXML.c: excluded content string check for XML_ELEMENT_DECL\n-\t  in xmlCtxtGenericNodeCheck\n-\t* runtest.c: changed \"open\" calls to include O_BINARY for Windows\n-\n-Wed Jul  6 17:14:03 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixing bug #166777 (and #169838), it was an heuristic\n-\t  in areBlanks which failed.\n-\t* result\/winblanks.xml* result\/noent\/winblanks.xml test\/winblanks.xml:\n-\t  added the input file to the regression tests\n-\n-Wed Jul  6 13:40:22 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemastypes.c: Fixed bug #309338, reported by Kupriyanov\n-\t  Anotolij.\n-\t* test\/schemas\/bug309338* result\/schemas\/bug309338*:\n-\t  Added a regression test for the above bug.\n-\n-Tue Jul  5 16:03:05 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: first steps toward a testsuite dist\n-\t* SAX2.c include\/libxml\/xmlerror.h: fixed bug #307870\n-\n-Tue Jul  5 12:38:36 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* runsuite.c runtest.c: Tiny portability adjustment for win.\n-\t* win32\/Makefile.*: Added runtest.exe and runsuite.exe to\n-\t  be created.\n-\n-Mon Jul  4 17:44:26 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runsuite.c: first stb at unimplemnted detection\n-\t* runtest.c: fixing Windows code\n-\n-Mon Jul  4 17:19:31 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runsuite.c: fix on schemas error\n-\t* runtest.c: portability glob() on Windows\n-\n-Mon Jul  4 16:23:54 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runsuite.c runtest.c: cleanups, logfile and portability\n-\t* xmllint.c: fixed a memory leak\n-\n-Mon Jul  4 13:11:12 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed a bug failing to detect UTF-8 violations in\n-\t  CData in push mode.\n-\t* result\/errors\/cdata.xml* test\/errors\/cdata.xml: added the test\n-\t  to the regressions\n-\n-Mon Jul  4 11:26:57 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c: added enhancement for #309057 in xmllint shell\n-\n-Mon Jul  4 00:58:44 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: applied patch from James Bursa fixing an html parsing\n-\t  bug in push mode\n-\t* result\/HTML\/repeat.html* test\/HTML\/repeat.html: added the test to the\n-\t  regression suite\n-\n-Sun Jul  3 23:42:31 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testapi.c tree.c: fixing a leak detected by testapi in \n-\t  xmlDOMWrapAdoptNode, and fixing another side effect in testapi\n-\t  seems to pass tests fine now.\n-\t* include\/libxml\/parser.h parser.c: xmlStopParser() is no more limited\n-\t  to push mode\n-\t* error.c: remove a warning\n-\t* runtest.c xmllint.c: avoid compilation errors if only some parts\n-\t  of the library are compiled in.\n-\n-Mon Jul  4 00:39:35 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: fix a problem with previous patch to\n-\t  testapi.c\n-\n-Sun Jul  3 22:59:28 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runsuite.c runtest.c tree.c: fixing compilations when\n-\t  disabling parts of the library at configure time.\n-\n-Sun Jul  3 18:17:58 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c: fix bug raised by zamez on IRC\n-\t* testapi.c: regenerated, seems to pop-up leaks in new tree functions\n-\t* tree.c: added comments missing.\n-\t* doc\/*: regenerated\n-\n-Sun Jul  3 18:06:55 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testapi.c runsuite.c runtest.c: fixing #307823 and a couple of\n-\t  assorted bugs\n-\t* python\/generator.py python\/libxml2-python-api.xml: fixed \n-\t  conditionals in generator too\n-\t* doc\/apibuild.py doc\/libxml2-api.xml doc\/* elfgcchack.h: some\n-\t  cleanups too and rebuilt\n-\n-Sun Jul  3 16:42:00 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: fixed bug #307503 misplaced #ifdef\n-\n-Sun Jul  3 16:34:47 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runsuite.c: expanded test\n-\t* xmlregexp.c: found and fixed the leak exposed by Microsoft regtests\n-\n-Sat Jul  2 23:38:24 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runsuite.c: a bit of progresses on xstc\n-\n-Sat Jul  2 09:30:13 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runsuite.c: completed the simple checks for Relax-NG suites\n-\t  back to the same 11 errors as in the Python runs.\n-\n-Thu Jun 30 15:01:52 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runtest.c: complete, checking on other platforms is needed\n-\t* README: updated \n-\t* debugXML.c: fix a bug raised by bill on IRC\n-\t* relaxng.c: fix a leak in weird circumstances\n-\t* runsuite.c Makefile.am: standalone test tool against\n-\t  the regression suites, work in progress\n-\n-Tue Jun 28 08:30:26 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runtest.c: adding URI tests\n-\n-Mon Jun 27 23:55:56 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runtest.c: adding xml:id\n-\n-Mon Jun 27 23:29:36 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runtest.c: finishing XPath, adding XPointer\n-\n-Mon Jun 27 17:39:27 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runtest.c: adding more coverage, XInclude and starting XPath\n-\n-Mon Jun 27 17:02:14 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* tree.c include\/libxml\/tree.h: Added allocation\/deallocation\n-\t  functions for the DOM-wrapper context.\n-\n-Mon Jun 27 15:41:30 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* tree.c: Commented the new functions to be experimental.\n-\n-Mon Jun 27 14:41:14 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c valid.c: working some weird error reporting problem for\n-\t  DTD validation.\n-\t* runtest.c: augmented with DTD validation tests\n-\t* result\/VC\/OneID*: slight change in validation output.\n-\n-Mon Jun 27 13:44:41 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runtest.c: added most HTML tests\n-\n-Mon Jun 27 14:06:10 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* test\/namespaces\/reconcile\/tests.xml\n-\t  test\/namespaces\/reconcile\/tests-to-c.xsl: Added initial tests\n-\t  for some new DOM-wrapper helping functions.\n-\n-Mon Jun 27 14:01:06 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xstc\/xstc-to-python.xsl: Cleanup.\n-\t* xstc\/sun-test-def.xml xstc\/nist-test-def.xml xstc\/ms-test-def.xml:\n-\t  Removed, those are not needed anymore due to the new test suite.\n-\n-Mon Jun 27 11:39:50 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* result\/*.sax2 MAkefile.am: added SAXv2 regression tests apparently\n-\t  missing.\n-\t* runtest.c: added SAX1\/SAX2 checks.\n-\n-Mon Jun 27 12:24:54 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* tree.c include\/libxml\/tree.h: Added\n-\t  xmlDOMWrapReconcileNamespaces(), xmlDOMWrapAdoptNode() and\n-\t  xmlDOMWrapRemoveNode() to the API. These are functions intended\n-\t  to be used with DOM-wrappers.\n-\n-Mon Jun 27 10:14:57 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runtest.c: continue to increase the tests\n-\n-Mon Jun 27 09:21:49 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runtest.c: continue to increase the tests\n-\n-Mon Jun 27 01:01:32 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* runtest.c: continue to increase the tests\n-\n-Sun Jun 26 20:08:24 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/valid.h valid.c: avoid name glob in arguments as\n-\t  it matches the glob() routine.\n-\t* runtest.c Makefile.am: first steps toward a C regression test\n-\t  framework.\n-\n-Sat Jun 25 01:37:22 PDT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* configure.in: fixed a problem with the detection of\n-\t  ss_family for ipV6, as reported on the mailing list by\n-\t  Doug Orleans.\n-\n-Tue Jun 21 10:44:34 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* test\/schemas\/empty-value* result\/schemas\/empty-value*:\n-\t  Added regression tests (from Dhyanesh).\n-\n-Tue Jun 21 10:35:43 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed NULL values to be validated as empty\n-\t  string values (reported by Dhyanesh to the mailing list).\n-\t  Adjusted text concatenation of mixed content.\n-\n-Mon Jun 20 18:11:32 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c valid.c: applied patch from Rob Richards for removal\n-\t  of ID (and xml:id)\n-\t* xmlreader.c: applied patch from James Wert implementing \n-\t  xmlTextReaderReadInnerXml and xmlTextReaderReadOuterXml\n-\n-Thu Jun 16 14:38:22 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed SAX2 validation: grow of internal\n-\t  namespace list, appending of element character content.\n-\t* xstc\/xstc.py: Added \"--sax\" option for SAX2 validation.\n-\n-Wed Jun 15 15:34:52 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemastypes.c: Added missing function descriptions.\n-\n-Wed Jun 15 15:26:14 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: if sax1 is used and input is a file use the old\n-\t  API xmlParseFile()\n-\t* xmlschemas.c: cleanups\n-\t* doc\/* testapi.c elfgcchack.h: rebuilt to add python bindings\n-\t  for the new functions in Schemas.\n-\n-Wed Jun 15 14:50:48 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c include\/libxml\/xmlschemas.h: Added\n-\t  xmlSchemaValidateFile() to the public API. This will use\n-\t  SAX2-driven validation.\n-\n-Wed Jun 15 11:11:38 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* result\/schemas\/bug306806_1_0 result\/schemas\/bug306806_1_0.err:\n-\t  Added schema test results (Tom Browder, bug #306806).\n-\n-Wed Jun 15 11:08:34 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* test\/schemas\/bug306806_1.xsd test\/schemas\/bug306806_0.xml:\n-\t  Added schema tests submitted by Tom Browder (bug #306806).\n-\n-Tue Jun 14 15:03:22 PDT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* pattern.c: adjusted last change to xmlCompilePathPattern,\n-\t  fixed one compilation warning\n-\n-Tue Jun 14 21:19:16 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* pattern.c: Some changes\/fixes to the streaming evaluation.\n-\t* xmlschemas.c: A bit of support for parsing the schema for\n-\t  schema. Fixed attribute derivation when the use is\n-\t  \"prohibited\" and was \"optional\". Fixed an attribute construction\n-\t  bug, a left-over from the time, where <complexContent>,\n-\t  <extension>, etc. where created as structs.\n-\n-Tue Jun 14 12:35:12 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml-2.0.pc.in: removed a redundant include path\n-\n-Mon Jun 13 14:58:33 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xstc\/Makefile.am: Some more adjustments.\n-\n-Mon Jun 13 14:35:59 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xstc\/Makefile.am: Changed test extraction process, since some\n-\t  boxes don't know about \"tar --strip-path\".\n-\n-Mon Jun 13 13:39:43 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: fixed a bug exposed by Rob Richards in the mailing-list\n-\t* result\/\/compare0* test\/\/compare0*: added the regression test in\n-\t  the suite as this went unnoticed !\n-\n-Wed Jun  9 11:07:42 PDT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* pattern.c, xpath.c, include\/libxml\/pattern.h: Further\n-\t  enhancement for XPath streaming, consolidated with\n-\t  schemas usage of pattern.c.  Added a new enum\n-\t  xmlPatternFlags.\n-\t* doc\/*, testapi.c, elfgcchack.h: updated to reflect new\n-\t  enum.\n-\t* test\/XPath\/tests\/mixedpat, test\/XPath\/docs\/mixed,\n-\t  result\/XPath\/mixedpat: added regression test for problems\n-\t  reported in bug306348\n-\n-Thu Jun  9 16:51:31 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemastypes.c: Changed non-prefixed QNames to be bound to a\n-\t  default namespace if existent.\n-\n-Thu Jun  9 15:11:38 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemastypes.c: Fixed a bug which I invented: hexBinary's string\n-\t  values were not duplicated corrently when creating a computed value\n-\t  in xmlSchemaValAtomicType.\n-\n-Thu Jun  9 13:20:57 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c result\/schemas\/include1_0_0.err:\n-\t  Fixed an attribute fixed\/default value constraint error.\n-\n-Thu Jun  9 12:51:23 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* result\/schemas\/*: Adapted regression test results.\n-\n-Thu Jun  9 12:22:45 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c xmlschemastypes.c include\/libxml\/schemasInternals.h\n-\t  include\/libxml\/xmlschemastypes.h: Changed the validation process\n-\t  to be able to work in streaming mode. Some datatype fixes,\n-\t  especially for list and union types. Due to the changes the\n-\t  error report output has changed in most cases. Initial migration to\n-\t  functions usable by both, the parser and the validator. This should\n-\t  ease a yet-to-come XS construction API in the long term as well.\n-\n-Thu Jun  9 10:16:11 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: applied patch from Malcolm Rowe to avoid namespace\n-\t  troubles on rollback parsing of elements start #304761\n-\t* test\/nsclean.xml result\/noent\/nsclean.xml result\/nsclean.xml*:\n-\t  added it to the regression tests.\n-\n-Thu Jun  9 00:33:50 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c include\/libxml\/xmlerror.h: applied patch from Rob Richards\n-\t  for xml:space and xml:lang handling with SAX2 api.\n-\n-Wed Jun  8 19:41:38 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* globals.c: applied patch from Morten Welinder, closing bug #306901\n-\t  on compiling subsets of the library\n-\n-Wed Jun  8 19:11:42 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xstc\/Makefile.am xstc.py xstc-to-python.xsl: Adapted the\n-\t  XS tests to use the new release of tests and test-definitions.\n-\n-2005-06-07  Aleksey Sanin <aleksey@aleksey.com>\n-\n-\t* c14n.c: fix rendering of attributes when parent node\n-\tis not in the node set\n-\n-2005-06-06  Aleksey Sanin <aleksey@aleksey.com>\n-\n-\t* c14n.c: fixed xml attributes processing bug in exc c14n\n-\t* xmllint.c: added --exc-c14n command line option\n-\n-Mon Jun  6 06:43:33 PDT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c, pattern.c: Enhanced xmlXPathRunStreamEval, fixed\n-\t  handling of depth\/level for cases like union operator\n-\t  (bug #306348 reported by Bob Stayton).  Also enhanced\n-\t  several comments throughout pattern.c.\n-\t* doc\/apibuild.py: fixed problem in handling of\n-\t  'signed' declaration.  Rebuilt the docs.\n-\t  \n-Tue May 31 20:35:27 PDT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xinclude.c: Enhanced handling of xml:base for included\n-\t  elements, fixing bugs 169209 and 302353.\n-\n-Wed May 25 18:59:53 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed facet errors to be channelled back for\n-\t  union type members; facet-validation will stop now on the\n-\t  first error. Reported by GUY Fabrice to the mailing-list.\n-\t* xmlschemastypes.c: Changed to ignore lengh-related facet\n-\t  validation for QNames and NOTATIONs as proposed by the\n-\t  schema people.\n-\t* test\/schemas\/union2* result\/schemas\/union2*: Added\n-\t  regression tests for union types (by GUY Fabrice).\n-\n-Fri May 20 20:48:08 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlsave.c: applied patch from Mark Vakoc fixing saving of\n-\t  CDATA with NULL content.\n-\n-Thu May 12 15:14:26 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemastypes.c: Changed the VALID_TZO macro to restrict\n-\t  the timezone to -840 to 840.\n-\n-Thu May 12 15:05:11 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemastypes.c: Applied patch from Steve Nairn (bug #303670)\n-\t  for \"signed int\" of the date-time timezone field. Silenced\n-\t  a warning.\n-\n-Wed May 11 20:04:09 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: applied patch for replaceNode from Brent Hendricks\n-\n-Tue May 10 17:27:52 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fixed bug #303682 of a leak reported by Malcolm Rowe\n-\n-Tue May 10 11:50:16 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testapi.c: applied patch from Steve Nairn tof fix the compilation\n-\t  problem exposed in bug #303640\n-\n-Tue May 10 11:11:26 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* test\/schemas\/bug303566_1* result\/schemas\/bug303566_1_1*:\n-\t  Added regression a test provided by Heiko Oberdiek (bug #303566).\n-\n-Mon May  9 17:56:58 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* pattern.c: Changed the XPath \".\" to resolve only on the first\n-\t  level for XML Schema IDCs (bug #303566 reported by Heiko Oberdiek).\n-\t  This should not affect pattern-like resolution on every level.\n-\n-Sun May  8 13:35:39 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlmemory.c: fixed #169630 segfault in xmlMemDisplay\n-\n-Fri May  6 13:40:03 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanoftp.c: fixing bug #303068 increasing the nanoftp buffer.\n-\t* doc\/apibuild.py: fixed __attribute() parsing problem\n-\t* doc\/* testapi.c: regenerated the descriptions and docs.\n-\n-Wed May  4 11:16:00 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am configure.in threads.c: on linux\/gcc use weak definitions\n-\t  to avoid linking with pthread library on non-threaded environments.\n-\t* xpath.c: applied patch from Mark Vakoc w.r.t. a buggy namespace\n-\t  list allocation.\n-\n-Fri Apr 29 11:27:37 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* parser.c: Fixed a test for duplicate attributes: Non-prefixed\n-\t  attributes were treated as being bound to the default namespace.\n-\n-Tue Apr 19 17:51:32 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemastypes.c: Fixed date-time related validation\n-\t  (reported by David Crossley, bug #300576).\n-\n-Tue Apr 19 16:55:40 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c xmlregexp.c: Removed 5 unnecessary\n-\t  dereferences (reported by Andriy, bug #301074).\n-\n-Tue Apr 19 22:33:18 HKT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: Added some code to avoid integer overflow for\n-\t  ceil, floor and round functions (bug 301162)\n-\n-Tue Apr 19 13:21:54 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Removed workaround for bug #172215, since it\n-\t  does more harm in some scenarios. Added some of the\n-\t  \"Particle Restriction OK\" constraints - not yet enabled.\t  \n-\n-Mon Apr 18 13:02:55 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* result\/schemas\/changelog093*: Added test results.\n-\n-Mon Apr 18 12:42:14 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Added output of canonical values in\n-\t  identity-constraint error messages.\n-\t* xmlschemastypes.c include\/libxml\/xmlschemastypes.h:\n-\t  Added xmlSchemaGetCanonValueWhtsp() to the API.\n-\t  Further enhancement of the canonical value\n-\t  conversion.\n-\t* test\/schemas\/changelog093_0.*: Added test with an XSD\n-\t  submitted by Randy J. Ray.\n-\n-Fri Apr 15 09:33:21 HKT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* valid.c: Applied Daniel's fix for memory leak in dtd\n-\t  prefix (bug 300550).\n-\t* xpath.c: minor change to comment only\n-\n-Thu Apr 14 20:52:41 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlmemory.c: added the call to the breakpoint routine\n-\t  when a monitored block is reallocated or freed\n-\n-Wed Apr 13 05:55:51 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanohttp.c: applied patch from Aron Stansvik for bug #172525\n-\t  about HTTP query string parameter being lost\n-\n-Tue Apr 12 04:03:32 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c python\/libxml.py: applied patch from Brent Hendricks\n-\t  adding namespace removal at the python level #300209\n-\t* python\/tests\/Makefile.am python\/tests\/nsdel.py: added the regression\n-\t  test\n-\n-Sun Apr 10 09:03:22 HKT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: fixed several places where memory cleanup was not\n-\t  properly done after an error was detected (problem was\n-\t  reported on the mailing list by Pawel Palucha)\n-\n-Fri Apr  8 21:58:04 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Added substitution group constraints; changed\n-\t  the build of the pre-computed substitution groups. Channeled\n-\t  errors during xsi assembling of schemas to the validation\n-\t  context. Fixed a big memory leak, which occurred when using\n-\t  IDCs: the precomputed value of attributes was not freed if\n-\t  the attribute did not resolve to an IDC field (discovered\n-\t  with the help of Randy J. Ray's schema, posted to the\n-\t  xmlschema-dev maling list).\n-\n-Fri Apr  8 13:22:01 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Added \"Particle correct 2\" to parsing of model groups.\n-\t  Added handling substitution groups inside <choice> and <sequence>;\n-\t  for <all> this is not supported yet. Changed circular checks for\n-\t  model groups definitions. \"memberTypes\" are processed at different\n-\t  levels now: component resolution first, construction later; this\n-\t  goes hand in hand with a global change to handle component\n-\t  resolution in a distinct phase. Fixed invalid default values for\n-\t  elements to mark the schema as invalid; this just resulted in an\n-\t  error report previously, but the schema was handled as valid.\n-\t  Separated the assignment of the model groups to referencing\n-\t  model group definition references (i.e. particles); this was\n-\t  needed to perform the circularity check for model group definitions.\n-\t  Added \"Element Declaration Properties Correct (e-props-correct)\"\n-\t  constraints. Separated component resolution for simple\/complex\n-\t  types.\n-\t* include\/libxml\/schemasInternals.h: Added a flag for substitution\n-\t  group heads.\t  \n-\n-Wed Apr  6 23:14:03 CEST 2005 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/Makefile.*: make install cleanup\n-\n-Wed Apr  6 22:42:23 CEST 2005 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/Makefile.mingw: fixed mingw compilation\n-\t* testModule.c: removed mingw warnings\n-\n-Wed Apr  6 21:59:11 CEST 2005 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* .cvsignore: added Eclipse project files to ignore list\n-\n-Wed Apr  6 16:08:10 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fixed the bug in lang() as raised by Elliotte Rusty Harold\n-\t* result\/XPath\/tests\/langsimple test\/XPath\/tests\/langsimple\n-\t  test\/XPath\/docs\/lang: added a regression test\n-\n-Tue Apr  5 23:48:35 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanoftp.c: applied fix from Rob Richards to compile on Windows.\n-\n-Tue Apr  5 17:02:58 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Added \"Type Derivation OK (Complex)\" constraints\n-\t  and anchored them in the \"Element Locally Valid (Element)\"\n-\t  constraints. This restricts the type substitution via \"xsi:type\".\n-\n-Tue Apr  5 13:10:06 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: patch from Matthew Burgess to improve some schemas\n-\t  facets validation messages.\n-\n-Sat Apr  2 12:48:41 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/* configure.in NEWS: preparing release 2.6.19, updated docs and\n-\t  rebuilding.\n-\n-Sat Apr  2 13:27:32 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xstc\/Makefile.am: integrated fixup-tests.py\n-\n-Fri Apr  1 19:14:18 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: fixed a lack of comment and missing test for\n-\t  a pointer in the API.\n-\n-Fri Apr  1 17:54:22 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xstc\/fixup-tests.py: A tiny script to fixup some of the schema\n-\t  files used for the tests.\n-\n-Fri Apr  1 17:33:50 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c include\/libxml\/schemasInternals.h\n-\t  result\/schemas\/src-element2-*.err result\/schemas\/element-*.err:\n-\t  Committing again, since the CVS server aborted.\n-\n-Fri Apr  1 15:29:27 CEST 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemastypes.c: Corrected 'length' facet validation for\n-\t  QNames and notations. Corrected xmlSchemaGetCanonValue: some\n-\t  data types did not return a value if already in normalized\n-\t  form.\n-\t* xmlschemas.c include\/libxml\/schemasInternals.h:\n-\t  Eliminated creation of structs for <restriction>, <extension>,\n-\t  <simpleContent>, <complexContent>, <list> and <union>: the\n-\t  information is now set directly on the corresponding simple\/\n-\t  complex type. Added some more complex type constraints.\n-\t  Added facet derivation constraints. Introduced \"particle\"\n-\t  components, which seem to be really needed if applying\n-\t  constraints. Corrected\/change some of the parsing functions.\n-\t  This is all a bit scary, since a significant change to the code.\n-\t* result\/schemas\/src-element2-*.err result\/schemas\/element-*.err:\n-\t  Adapted regression test results.\n-\n-Fri Apr  1 16:07:59 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/apibuild.py doc\/elfgcchack.xsl: revamped the elfgcchack.h \n-\t  format to cope with gcc4 change of aliasing allowed scopes, had\n-\t  to add extra information to doc\/libxml2-api.xml to separate\n-\t  the header from the c module source.\n-\t* *.c: updated all c library files to add a #define bottom_xxx\n-\t  and reimport elfgcchack.h thereafter, and a bit of cleanups.\n-\t* doc\/\/* testapi.c: regenerated when rebuilding the API\n-\n-Thu Mar 31 17:20:32 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlsave.c: fixed bug reported by Petr Pajas, in the absence of\n-\t  encoding UTF-8 should really be assumed. This may break if \n-\t  the HTTP headers indicates for example ISO-8859-1 since this\n-\t  then becomes a well formedness error.\n-\n-Thu Mar 31 16:57:18 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: fixed #172260 redundant assignment.\n-\t* parser.c include\/libxml\/parser.h: fixed xmlSAXParseDoc() and \n-\t  xmlParseDoc() signatures #172257.\n-\n-Thu Mar 31 16:11:10 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fix potential crash if ctxt->sax->ignorableWhitespace\n-\t  is NULL as reported by bug #172255\n-\n-Thu Mar 31 15:36:52 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: fixed a problem in Relax-NG validation #159968\n-\t* test\/relaxng\/list.* result\/relaxng\/list_*: added the test\n-\t  to the regression suite\n-\n-Thu Mar 31 13:06:02 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c: fixed bug #168504\n-\n-Thu Mar 31 12:22:54 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* config.h.in configure.in nanoftp.c nanohttp.c xmllint.c\n-\t  macos\/src\/config-mac.h: use XML_SOCKLEN_T instead of SOCKLEN_T\n-\t  since apparently IBM can't avoid breaking common defines #166922\n-\n-Thu Mar 31 10:41:45 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: fix unitinialized variable in not frequently used\n-\t  code bug #172182\n-\n-Thu Mar 31 00:45:18 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/libxml.py: another patch from Brent\n-\t  Hendricks to add new handlers with the various validity contexts\n-\t* python\/tests\/Makefile.am python\/tests\/validDTD.py\n-\t  python\/tests\/validRNG.py python\/tests\/validSchemas.py: also \n-\t  added the regression tests he provided\n-\n-Wed Mar 30 09:39:27 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/libxml.c: applied patch from Brent\n-\t  Hendricks to avoid leak in python bindings when using schemas\n-\t  error handlers.\n-\n-Tue Mar 29 22:29:28 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c: fixing bug 168196, <a name=\"\"> must be URI escaped too\n-\n-Sun Mar 27 13:24:24 CEST 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: cleanup of the Prop related functions and xmlNewNodeEatName\n-\t  by Rob Richards\n-\n-Thu Mar 24 19:01:22 PST 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* gentest.py, testapi.c: fixed problem with 'minimal library'\n-\t  compilation (LIBXML_PATTERN_ENABLED not properly checked) reported\n-\t  by Greg Morgan\n-\n-Thu Mar 24 12:01:30 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed call to a facet error report: the type of\n-\t  the error was wrong, resulting in a segfault (bug #171220, reported\n-\t  by GUY Fabrice).\n-\n-Mon Mar 21 22:58:37 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Removed a stupid bug in xmlSchemaValidateAttributes,\n-\t  failing to build a linked list correctly (bug #169898, reported\n-\t  by bing song, hmm...).\n-\n-Mon Mar 21 21:09:07 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed a segfault, which occurred during bubbling\n-\t  of IDC nodes (bug #170779 and #170778, reported by GUY Fabrice):\n-\t  a variable was missed to be reset in a loop. Deactivated bubbling,\n-\t  if not referenced by a keyref.\n-\n-Sun Mar 20 11:13:02 PST 2005 Aleksey Sanin <aleksey@aleksey.com>\n-\t\n-\t* c14n.c include\/libxml\/xmlerror.h: special case \"DAV:\" namespace\n-\tin c14n relative namespaces check and add structured error messages\n-\tto c14n code\n-\n-Thu Mar 17 12:55:23 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Removed inheritance of \"mixed\" content type for\n-\t  short-hand restrictions of \"anyType\" (reported by Guy Fabrice\n-\t  to the mailing list). Added the namespace conversion (chameleon\n-\t  includes) for the base type reference of <restriction> and\n-\t  <extension>.\n-\t* test\/schemas\/bug152470_1.xsd: Adapted due to the above change\n-\t  of \"mixed\" inheritance.\n-\n-Thu Mar 17 11:03:59 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: fixed a = -> == error pointed by GUY Fabrice\n-\n-Wed Mar 16 22:53:53 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: more debug messages from Matthew Burgess\n-\t* xmlschemastypes.c: xmlSchemaValidateLengthFacet API missing check.\n-\n-Wed Mar 16 17:37:04 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemastypes.c: Aaaannnd putting back the previous changes done\n-\t  by Daniel, which I overwrote with the previous commit.\n-\n-Wed Mar 16 17:20:25 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c xmlschemastypes.c include\/libxml\/xmlschemastypes.h:\n-\t  Hopefully finished validation against facets to use the normalized\n-\t  value of both, the facets and instance values. Added \n-\t  xmlSchemaValidateLengthFacetWhtsp(), xmlSchemaValidateFacetWhtsp()\n-\t  and xmlSchemaGetValType() to the schema API.\n-\n-Wed Mar 16 13:55:31 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in: do not package .la files\n-\t* xmllint.c: applied patch from Gerry Murphy for xmllint return code\n-\t* xmlschemastypes.c: fixed a couple of missing tests of parameters\n-\t  at public API entry points.\n-\n-Tue Mar 15 23:31:14 HKT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlschemastypes.c: a couple of more changes to various\n-\t  decimal-handling routines.  Fixes python some problems\n-\t  turned up by the python tests.\n-\t* Makefile.am: change SchemasPythonTests message to warn\n-\t  that there are 10 'expected' errors (rather than 6) since\n-\t  we now reject a '+' sign on an unsigned.\n-\n-Tue Mar 15 15:43:27 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemastypes.c xmlschemastypes.h: In preparation to use\n-\t  normalized values of facets during validation: changed the\n-\t  arguments of some string comparison functions; added a static\n-\t  xmlSchemaValidateFacetInternal() with more arguments to be\n-\t  more flexible. Prepared XML_SCHEMA_FACET_ENUMERATION validation\n-\t  to use the comparison functions. Fixed some assignments in\n-\t  xmlSchemaValAtomicType(): total digit count, lo, mi, hi.\n-\n-Sun Mar 13 19:32:03 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* NEWS configure.in testapi.c doc\/*: preparing release of 2.6.18\n-\t  updated docs and rebuilt\n-\t* libxml.spec.in: reactivated gcc profiling for gcc >= 4.0.0\n-\n-Sat Mar 12 19:50:22 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: removed a static buffer in xmlByteConsumed(),\n-\t  as pointed by Ben Maurer, fixes #170086\n-\t* xmlschemas.c: remove a potentially uninitialized pointer warning\n-\n-Fri Mar 11 23:53:13 HKT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlschemastypes.c: enhanced the parsing of XML_SCHEMAS_DECIMAL\n-\t  and much of the routine xmlSchemaCompareDecimals.  The\n-\t  changes were necessary to fix a problem reported on the\n-\t  mailing list by John Hockaday.\n-\n-Fri Mar 11 13:22:52 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: The schema parser will stop if components could\n-\t  not be resolved. This is not conforming to the spec but for now\n-\t  will avoid internal errors during type fixup and content model\n-\t  creation. Restructured inclusion\/import of schemata: this avoids\n-\t  duplicate, self and circular inclusion. Chameleon includes are\n-\t  still workarounded. Added restriction to disallow references to\n-\t  non-imported namespaces. Corrected parsing of <group>.\n-\t* result\/schemas\/bug167754_0_0*: Added a missing test result.\n-\n-Thu Mar 10 16:02:17 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xml.html doc\/encoding.html: Enriched encoding.html with more\n-\t  link and foreword warning to avoid problem with ignorant\n-\t  programmers, c.f #169721\n-\n-Thu Mar 10 15:01:34 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/tests\/Makefile.am python\/tests\/readernext.py: added\n-\t  a regression test from Rob Richards for the previous bug\n-\n-Thu Mar 10 13:22:36 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: applied fix for xmlTextReaderNext() bug from\n-\t  Rob Richards\n-\n-Thu Mar 10 11:35:57 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlmodule.c: second patch from Rick Jones, portability fix for\n-\t  HP-UX\n-\t* doc\/examples\/xpath1.c doc\/examples\/xpath2.c: first fix from Rick Jones\n-\t  to avoid warnings.\n-\n-Thu Mar 10 10:20:23 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/hash.h libxml.h libxml.spec.in: some gcc4 portability\n-\t  patches, including a serious aliasing bug exposed in s390 \n-\t  when trying to convert data pointer to code pointer.\n-\n-Mon Mar  7 18:34:00 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Tiny restructuring of the validation start-up\n-\t  functions. Added cleanup of the validation context at the\n-\t  end of validation. This takes care of the validation context\n-\t  being reused.\n-\n-Mon Mar  7 12:12:01 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemastypes.c: Tiny changes in the comparison functions\n-\t  I forgot to commit last time.\n-\n-Fri Mar  4 22:51:42 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Added IDC validation of anySimpleType attribute\n-\t  values; anyway the IDC key comparison is restricted to\n-\t  anySimpleType <--> string based types. For other types we\n-\t  would possibly need the canonical lexical representation of\n-\t  them; this sounds not performant, since we would need to\n-\t  build such a representation each time we want to compare against\n-\t  anySimpleType. TODO: think about buffering the canonical values\n-\t  somewhere. Fixed error reports for default attributes to work\n-\t  without a node being specified. This all and the enabling of IDC\n-\t  validation fixes bug #165346 (reported by Benoit Gr?goire - could\n-\t  not read his last name correctly from bugzilla).\n-\n-Fri Mar  4 18:57:44 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Enabled IDC parsing and validation.\n-\t* xmlschemastypes.c include\/libxml\/xmlschemastypes.h: \n-\t  Added xmlSchemaCopyValue to the API; this was done due to\n-\t  validation of default attributes against IDCs: since IDC keys\n-\t  consume the precomputed value, one needs a copy.\n-\t* pattern.c: Enabled IDC support; this is currently done\n-\t  via calling xmlPatterncompile with a flag arg of 1.\n-\n-Wed Mar  2 11:45:18 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am doc\/examples\/Makefile.am python\/tests\/Makefile.am\n-\t  xstc\/Makefile.am: try to fix a problem with valgrind.\n-\t* python\/generator.py python\/libxml.c python\/tests\/Makefile.am\n-\t  python\/tests\/tstmem.py: applied memory leak fix from Brent Hendricks\n-\t  c.f. bug #165349\n-\n-Mon Feb 28 11:18:24 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* tree.c: Changed xmlSearchNsByHref to call xmlNsInScope with\n-\t  the prefix instead of the namespace name.\n-\t* test\/schemas\/annot-err_0.xsd test\/schemas\/element-err_0.xsd:\n-\t  Adapted invalid values of the \"id\" attribute, since they are\n-\t  validated now.\n-\n-Fri Feb 25 08:31:16 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* threads.c: new version with fixes from Rob Richards\n-\n-Thu Feb 24 16:37:51 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* threads.c: applied patch from Rich Salz for multithreading on\n-\t  Windows.\n-\n-Wed Feb 23 15:04:46 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlwriter.c: applied a patch from Rob Richards fixing a couple\n-\t  of bugs in the writer\n-\n-Mon Feb 21 21:51:03 HKT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlsave.c: fixed problem when XMLLINT_INDENT was empty (bug 168033).\n-\t* xpath.c: fixed compilation warning, no change to logic.\n-\t* xmlschemastypes.c: fixed compilation warning, no change to logic.\n-\n-Mon Feb 21 14:48:27 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlwriter.c: applied patch from Rob Richards to fix a problem with\n-\t  xmlTextWriterStartAttributeNS\n-\n-Mon Feb 21 11:41:41 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* pattern.c xpath.c: fixed remaining known bugs in the XPath streaming,\n-\t  and switched XPath to use it by default when possible\n-\n-Sat Feb 19 19:25:14 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: a bit of cleanup\n-\t* elfgcchack.h testapi.c doc\/*: rebuilt the API the tests and\n-\t  the documentation as a result.\n-\n-Fri Feb 18 20:34:03 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c include\/libxml\/xmlreader.h: applied patch from\n-\t  Aron Stansvik to add xmlTextReaderByteConsumed()\n-\t* testReader.c: added a test option\n-\t* xmlschemastypes.c: fix a lack of pointer checking in APIs\n-\n-Fri Feb 18 12:41:10 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* test\/schemas\/bug167754_0*: Added the regression test of Frans\n-\t  Englich for bug #167754.\n-\n-Fri Feb 18 12:31:49 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Started support for IDC resolution to default\n-\t  attributes. If building the content model for <all>: ensured\n-\t  to put element declarations and not the particles into the\n-\t  content model automaton (this was bug #167754, reported by\n-\t  Frans Englich).\n-\n-Thu Feb 17 22:31:58 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* pattern.c pattern.h: Some experimental addition for parsing\n-\t  of expressions and streamable validation.\n-\t  Added xmlStreamPushAttr to the API.\n-\n-Thu Feb 17 19:57:35 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Added validation for the attribute \"id\" in the\n-\t  schemata; doing this needed error report fixes for notations,\n-\t  facets and group. Changed NOTATION validation to work with the\n-\t  declared NOTATIONs in the schema; this does have no impact on\n-\t  the validation via the relaxng module.\n-\t* xmlschemastypes.c include\/libxml\/xmlschemastypes.h:\n-\t  Added xmlSchemaNewNOTATIONValue to the API to be able to do\n-\t  the NOTATION validation described above.\n-\t* test\/schemas\/element-err_0.xsd test\/schemas\/annot-err_0.xsd:\n-\t  Fixed the values of the \"id\" attributes, which were not validated\n-\t  previously.  \n-\n-Thu Feb 17 12:03:46 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed comparison for default\/fixed attribute\n-\t  values, if the type was 'xsd:string'. Changed the comparison\n-\t  for IDCs to use the whitespace aware comparison function.\n-\t* xmlschemastypes.c include\/libxml\/xmlschemastypes.h:\n-\t  Added xmlSchemaGetCanonValue, xmlSchemaNewStringValue and\n-\t  xmlSchemaCompareValuesWhtsp to the API. Added functions\n-\t  to compare strings with whitespace combinations of \"preserve\",\n-\t  \"replace\" and \"collapse\".\n-\n-Wed Feb 16 13:24:35 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Further work on IDCs, especially evaluation for\n-\t  attribute nodes.\n-\n-Wed Feb 16 01:19:27 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: fix the comment to describe the real return values\n-\t* pattern.c xpath.c include\/libxml\/pattern.h: lot of work on\n-\t  the patterns, pluggin in the XPath default evaluation, but\n-\t  disabled right now because it's not yet good enough for XSLT.\n-\t  pattern.h streaming API are likely to be changed to handle\n-\t  relative and absolute paths in the same expression.\n-\n-Tue Feb 15 15:33:32 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Added IDC evaluation for attribute nodes.\n-\t  Made 'nil'ed elements work. Added a specific error message\n-\t  for 'strict' attribute wildcards.\n-\t* include\/libxml\/xmlerror.h: Added an error code for\n-\t  wildcards.\n-\t* result\/schemas\/anyAttr-processContents-err1_0_0.err: Adapted.  \n-\n-Sun Feb 13 16:15:03 HKT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\tThis change started out as a simple desire to speed up the\n-\texecution time of testapi.c, which was being delayed by\n-\tnameserver requests for non-existent URL's.  From there it\n-\tjust sort of grew, and grew....\n-\t* nanohttp.c, nanoftp.c: changed the processing of URL's\n-\t  to use the uri.c routines instead of custom code.\n-\t* include\/libxml\/xmlerror.h: added code XML_FTP_URL_SYNTAX\n-\t* uri.c: added accepting ipV6 addresses, in accordance with\n-\t  RFC's 2732 and 2373 (TODO: allow ipV4 within ipV6)\n-\t* gentest.py, testapi.c: fixed a few problems with the\n-\t  testing of the nanoftp and nanohttp routines.\n-\t* include\/libxml\/xmlversion.h: minor change to fix a\n-\t  warning on the docs generation\n-\t* regenerated the docs\n-\n-Sat Feb 12 09:07:11 HKT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xinclude.c: fixed xmlXIncludeParseFile to prevent\n-\t  overwriting XML_COMPLETE_ATTRS when setting pctxt->loadsubset\n-\t  (bug 166199)\n-\t* Makefile.am, python\/tests\/Makefile.am, xstc\/Makefile.am: added\n-\t  code to add $(top_builddir)\/.libs to LD_LIBRARY_PATH whenever\n-\t  PYTHONPATH is set, to assure new libxml2 routines are used.\n-\n-Fri Feb 11 22:20:41 HKT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* parser.c: fixed problem when no initial \"chunk\" was\n-\t  given to xmlCreatePushParser (bug 162613)\n-\n-Fri Feb 11 18:37:22 HKT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* dict.c: fixed compilation warning\n-\t* parser.c: changed xmlWarningMsg so ctxt->errNo is not set\n-\t* xmllint.c: changed to return non-zero status if error\n-\t  on xinclude processing\n-\t* xmlsave.c: minor deletion of a redundant condition statement\n-\t\n-Wed Feb  9 17:47:40 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: applied patch to xmlSetNsProp from Mike Hommey\n-\n-Sun Feb  6 00:17:57 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* pattern.c xmllint.c: fixed implementation for |\n-\t* test\/pattern\/conj.* result\/pattern\/conj: added a specific regression\n-\t  test\n-\n-Sat Feb  5 18:36:56 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* pattern.c: first implementation for | support\n-\n-Sat Feb  5 14:58:46 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* pattern.c: fixed the namespaces support\n-\t* tree.c: fixed xmlGetNodePath when namespaces are used\n-\t* result\/pattern\/multiple result\/pattern\/namespaces\n-\t  test\/pattern\/multiple.* test\/pattern\/namespaces.*: added\n-\t  more regression tests\n-\n-Fri Feb  4 18:26:43 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: fixed one internal function\n-\t* doc\/Makefile.am doc\/wiki.xsl: applied patch from Joel Reed\n-\t* testapi.c doc\/libxml2-api.xml doc\/libxml2-refs.xml: regenerated\n-\n-Fri Feb  4 00:25:43 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: use the walker to test the patterns instead of\n-\t  the normal reader\n-\t* pattern.c xmllint.c: bug fixes in the train including fixing the\n-\t  stupid build break.\n-\n-Tue Feb  1 18:15:52 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* pattern.c: more bug fixes for the XPath streaming code.\n-\n-Mon Jan 31 17:59:24 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Integrated the streaming pattern from the\n-\t  pattern module. Fixed some IDC code bugs. Changed\n-\t  fallback for attribute declaration addition to work like for\n-\t  element declarations.\t\n-\n-Mon Jan 31 01:27:22 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* pattern.c xmllint.c: bugfixes around the streaming patterns\n-\n-Sun Jan 30 23:35:19 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am configure.in result\/pattern\/simple \n-\t  test\/pattern\/simple.*: added first test for the patterns\n-\t* pattern.c xmllint.c: a few fixes\n-\n-Sun Jan 30 19:27:23 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* pattern.c include\/libxml\/pattern.h xmllint.c: added a \n-\t  streaming pattern detector for a subset of XPath, should\n-\t  help Kasimier for identity constraints\n-\t* python\/generator.py: applied Stéphane Bidoul patch to find\n-\t  paths without breaking.\n-\n-Fri Jan 28 18:53:40 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: fixed an untested pointer dereference and a & vs &&\n-\n-Fri Jan 28 18:37:18 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: implementation of xmlTextReaderReadString by\n-\t  Bjorn Reese\n-\n-Fri Jan 28 16:51:47 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Corrected an ambiguous symbol-space for\n-\t  local attribute declarations. IFDEFed more IDC code to\n-\t  suppress compiler warnings.\n-\n-Fri Jan 28 00:57:04 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* bakefile\/Readme.txt bakefile\/Bakefiles.bkgen bakefile\/libxml2.bkl:\n-\t  files for the Bakefile generator for Makefiles from Francesco\n-\t  Montorsi\n-\t* win32\/configure.js: fixes for Windows compilation with non-default\n-\t  flags by Joel Reed\n-\n-Thu Jan 27 18:23:50 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fixed xmlCopyDoc to also copy the doc->URL as pointed\n-\t  by Martijn Faassen\n-\n-Thu Jan 27 13:39:04 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c include\/libxml\/schemasInternals.h:\n-\t  Added an initial skeleton for indentity-constraints. This is all\n-\t  defined out, since not complete, plus it needs support from other\n-\t  modules.\n-\t  Added mechanism to store element information for the\n-\t  ancestor-or-self axis; this is needed for identity-constraints\n-\t  and should be helpful for a future streamable validation.\n-\t* include\/libxml\/xmlerror.h: Added an error code for\n-\t  identity-constraints.\n-\n-Wed Jan 26 01:03:37 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: had to fix generation and rebuild.\n-\t* valid.c: the testapi found a bug in the last code of course !\n-\n-Wed Jan 26 00:43:05 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am testapi.c doc\/Makefile.am: fixing the way testapi.c\n-\t  is generated, fixes bug #161386\n-\t* dict.c: fix a comment typo\n-\t* elfgcchack.h doc\/*: regenerated\n-\n-Tue Jan 25 22:39:33 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: found and fixed 2 problems in the internal subset scanning\n-\t  code affecting the push parser (and the reader), fixes #165126\n-\t* test\/intsubset2.xml result\/\/intsubset2.xml*: added the test case\n-\t  to the regression tests.\n-\n-Tue Jan 25 01:20:11 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testdso.c xmlregexp.c: warning patches from Peter Breitenlohner\n-\t* include\/libxml\/valid.h valid.c parser.c: serious DTD parsing\n-\t  speedups, start to deprecate 3 ElementDef related entry point\n-\t  and replace them with better ones.\n-\n-Mon Jan 24 00:47:41 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: more hash dictionary interning changes\n-\n-Sun Jan 23 23:54:39 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* hash.c include\/libxml\/hash.h: added xmlHashCreateDict where\n-\t  the hash reuses the dictionary for internal strings\n-\t* entities.c valid.c parser.c: reuse that new API, leads to a decent\n-\t  speedup when parsing for example DocBook documents.\n-\n-Sun Jan 23 21:14:20 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: small speedup in skipping blanks characters\n-\t* entities.c: interning the entities strings \n-\n-Sun Jan 23 18:35:00 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: boosting common comment parsing code, it was really\n-\t  slow.\n-\t* test\/comment[3-5].xml result\/\/comment[3-5].xml*: added sprecific\n-\t  regression tests\n-\n-Sun Jan 23 01:00:09 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: small optimization back.\n-\n-Sat Jan 22 00:40:31 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* dict.c parser.c include\/libxml\/dict.h: a single lock version\n-\t  mostly avoid the cost penalty of the lock in case of low \n-\t  parallelism, so applying that version instead.\n-\n-Fri Jan 21 17:54:06 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* dict.c: patch from Gary Coady to fix a race in dict reference\n-\t  counting in multithreaded apps.\n-\n-Fri Jan 21 16:08:21 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed bug #164556 where non-fatal errors stopped\n-\t  push parsing and xmlreader.\n-\t* Makefile.am: fixup\n-\t* test\/errors\/webdav.xml result\/errors\/webdav*: adding regression\n-\t  test for this problem.\n-\n-Wed Jan 19 17:24:34 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Corrected targetNamespace in\n-\t  xmlSchemaElementDump. Cosmetic changes to the dump output.\t\n-\n-Sun Jan 16 21:00:53 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in NEWS doc\/*: preparing release of 2.6.17,\n-\t  updated and rebuilt the docs\n-\n-Sun Jan 16 19:58:36 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: better fix for #151694 not killing c14n regression tests\n-\t* xmlschemastypes.c: fixing bug #157653\n-\n-Sun Jan 16 19:01:06 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixing bug #151694, line should always be set in the\n-\t  elements.\n-\n-Sun Jan 16 01:04:18 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: trying to fix at least the message from\n-\t  bug #158628\n-\t* include\/libxml\/xmlsave.h xmlsave.c: added first xmlsave option\n-\t  for format, c.f. bug #159997\n-\n-Sat Jan 15 18:44:30 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.py: make __str__ call serialize() on nodes, c.f. \n-\t  bug #157872\n-\n-Sat Jan 15 18:18:07 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanoftp.c: applied patch from Dan McNichol for compilation on AIX\n-\n-Sat Jan 15 13:35:19 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: fixed bug #157633 in relaxng choice optimization\n-\t* result\/relaxng\/choice0* test\/relaxng\/choice0*: added regression\n-\t  tests about it.\n-\t* doc\/*: rebuilt\n-\t* testdso.c: removed a warning due to a missing void in signature.\n-\n-Thu Jan 13 17:42:55 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* include\/libxml\/schemasInternals.h xmlschemas.c: \n-\t  Exposed targetNamespace for simple\/complex types, model groups,\n-\t  attribute groups and notations (reported by Michael Hewarth \n-\t  to the mailing list). Added targetNamespace to xmlSchemaType, \n-\t  xmlSchemaAttributeGroup and xmlSchemaNotation.\n-\t  Tiny cosmetic change to the content model error report output.\n-\t* result\/\/all_*.err result\/\/any3_0_0.err result\/\/choice_*.err \n-\t  result\/\/list0_0_1.err result\/\/list0_1_1.err: Adapted output \n-\t  of regression tests.\n-\n-Thu Jan 13 13:20:51 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Put the fix of Daniel (from Tue Jan 11 14:41:47 CET)\n-\t  back in, since I missed to update xmlschemas.c before doing\n-\t  the previous commit.\n-\t\n-Thu Jan 13 12:59:25 CET 2005 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Integrated xmlRegExecErrInfo and xmlRegExecNextValues\n-\t  from xmlregexp.c to report expected elements on content model errors.\n-\t* all_*.err any3_0_0.err choice_*.err list0_0_1.err list0_1_1.err:\n-\t  Adapted output of regression tests.\n-\n-Thu Jan 13 12:24:09 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* config.h.in configure.in xmlmodule.c: trying to work around\n-\t  the compilation problem on HP-UX\n-\n-Wed Jan 12 22:03:33 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* pattern.c: fixed the fixed size array structure problem reported by\n-\t  Patrick Streule\n-\n-Wed Jan 12 15:15:02 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* elfgcchack.h testapi.c doc\/libxml2-api.xml doc\/*: regenerated\n-\t  the API description, rebuilt, improved navigation in documentation\n-\t  a bit.\n-\n-Wed Jan 12 14:17:14 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlregexp.h xmlregexp.c: extended xmlRegExecErrInfo()\n-\t  and xmlRegExecNextValues() to return error transition strings too,\n-\t  and sink state detection and handling.\n-\n-Tue Jan 11 14:41:47 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: fixed bug #163641 when the value passed for\n-\t  an atomic list type is NULL.\n-\n-Tue Jan 11 10:14:33 HKT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* Makefile.am configure.in: fixed dependency on python 2.3,\n-\t  also small improvement for cygwin (bug 163273)\n-\n-Sun Jan  9 18:46:32 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: William noticed I forgot to add special\n-\t  support for xmlmodules.c define\n-\t* xmlregexp.c include\/libxml\/xmlregexp.h: added terminal to\n-\t  xmlRegExecErrInfo() API, adding new xmlRegExecNextValues()\n-\t  entry point and refactored to use both code.\n-\n-Mon Jan 10 01:02:41 HKT 2006 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/xml.html, doc\/FAQ.html: added an FAQ under Developer for\n-\t  setting up a \"private\" library (after some list posts about\n-\t  people having trouble doing it)\n-\n-Sat Jan  8 23:04:10 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: fixing behaviour for xmlRegExecErrInfo in case of\n-\t  rollback\n-\n-Fri Jan  7 14:54:51 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* TODO: small update\n-\t* xmlregexp.c: trying to add an API to get useful error information\n-\t  back from a failing regexp context.\n-\n-Thu Jan  6 17:35:41 HKT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: fixed problem with xmlXPathErr when error number\n-\t  subscript was out of range (bug 163055)\n-\n-Thu Jan  6 09:57:03 HKT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\t* uri.c: fixed problem with xmlURIEscape when query part was\n-\t  empty (actually fixed xmlURIEscapeStr to return an empty\n-\t  string rather than NULL for empty string input) (bug 163079)\n-\t  \n-Tue Jan  4 17:08:45 PST 2005 Aleksey Sanin <aleksey@aleksey.com>\n-\n-\t* parser.c, parserInternal.c: fixed \"col\" calculation for \n-          struct _xmlParserInput (based on patch from Rob Richards) \n-\t* include\/libxml\/xmlerror.h, error.c: propagated error column\n-          number in the xmlError structure\n-\n-Tue Jan  4 22:47:22 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed namespace bug in push mode reported by \n-\t  Rob Richards\n-\t* test\/ns6 result\/\/ns6*: added it to the regression tests\n-\t* xmlmodule.c testModule.c include\/libxml\/xmlmodule.h:\n-\t  added an extra option argument to module opening and defined\n-\t  a couple of flags to the API.\n-\n-Tue Jan  4 21:16:05 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlmodule.c include\/libxml\/xmlmodule.h: applied patch from\n-\t  Bjorn Reese, plus some cleanups\n-\t* elfgcchack.h doc\/elfgcchack.xsl: fixed the stylesheet to \n-\t  add the new header\n-\t* doc\/* testapi.c: regenerated the API\n-\n-Tue Jan  4 18:47:19 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: making DSO support an option\n-\t* xmlmodule.c xmlreader.c include\/libxml\/xmlmodule.h: code\n-\t  and documentation cleanups\n-\t* elfgcchack.h testapi.c doc\/*: regenerated the docs and\n-\t  checks for new module\n-\t* test\/valid\/REC-xml-19980210.xml: fix a small change introduced\n-\t  previously\n-\n-Tue Jan  4 16:07:52 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am config.h.in configure.in error.c libxml-2.0.pc.in\n-\t  testModule.c testdso.c xml2-config.in xmllint.c xmlmodule.c\n-\t  include\/libxml\/Makefile.am include\/libxml\/xmlerror.h\n-\t  include\/libxml\/xmlmodule.h include\/libxml\/xmlversion.h.in \n-\t  include\/libxml\/xmlwin32version.h.in: applied DSO support\n-\t  patch 2 from Joel Reed\n-\n-Tue Jan  4 15:30:15 CET 2005 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: applied patch from Marcin Konicki for BeOS\n-\n-Mon Jan  3 13:57:21 PST 2005 Aleksey Sanin <aleksey@aleksey.com>\n-\n-\t* parser.c: added GetLineNumber and GetColumnNumber functions for xmlReader\n-\n-Sun Jan  2 17:51:18 HKT 2005 William Brack <wbrack@mmm.com.hk>\n-\n-\tRe-examined the problems of configuring a \"minimal\" library.\n-\tSynchronized the header files with the library code in order\n-\tto assure that all the various conditionals (LIBXML_xxxx_ENABLED)\n-\twere the same in both.  Modified the API database content to more\n-\taccurately reflect the conditionals.  Enhanced the generation\n-\tof that database.  Although there was no substantial change to\n-\tany of the library code's logic, a large number of files were\n-\tmodified to achieve the above, and the configuration script\n-\twas enhanced to do some automatic enabling of features (e.g.\n-\t--with-xinclude forces --with-xpath).  Additionally, all the format\n-\terrors discovered by apibuild.py were corrected.\n-\t* configure.in: enhanced cross-checking of options\n-\t* doc\/apibuild.py, doc\/elfgcchack.xsl, doc\/libxml2-refs.xml,\n-\t  doc\/libxml2-api.xml, gentest.py: changed the usage of the\n-\t  <cond> element in module descriptions\n-\t* elfgcchack.h, testapi.c: regenerated with proper conditionals\n-\t* HTMLparser.c, SAX.c, globals.c, tree.c, xmlschemas.c, xpath.c,\n-\t  testSAX.c: cleaned up conditionals\n-\t* include\/libxml\/[SAX.h, SAX2.h, debugXML.h, encoding.h, entities.h,\n-\t  hash.h, parser.h, parserInternals.h, schemasInternals.h, tree.h,\n-\t  valid.h, xlink.h, xmlIO.h, xmlautomata.h, xmlreader.h, xpath.h]:\n-\t  synchronized the conditionals with the corresponding module code\n-\t* doc\/examples\/tree2.c, doc\/examples\/xpath1.c, doc\/examples\/xpath2.c:\n-\t  added additional conditions required for compilation\n-\t* doc\/*.html, doc\/html\/*.html: rebuilt the docs\n-\t\n-Sat Dec 25 18:10:02 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* parserInternals.c: fixed to skip (if necessary) the BOM for\n-\t  encoding 'utf-16'.  Completes the fix for bug #152286.\n-\t* tree.c, parser.c: minor warning cleanup, no change to logic\n-\t\n-Fri Dec 24 16:31:22 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* python\/generator.py: added most required entries to\n-\t  foreign encoding table, plus some additional logic to\n-\t  assure only the 1st param uses the 't#' format.  Fixes\n-\t  bug #152286, but may still have some other UTF-16 problems.\n-\n-Thu Dec 23 23:44:08 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* Makefile.am, gentest.py: enhanced for enabling build in\n-\t  a different directory.  Added (optional) param to gentest.py\n-\t  to specify the source directory (bug #155468)\n-\t* doc\/Makefile.am: changed destination of NEWS from (top_srcdir)\n-\t  to (top_builddir) (bug #155468)\n-\t* python\/Makefile.am, python\/generator.py: enhanced for enabling\n-\t  build in a different directory(bug #155468).  Added (optional)\n-\t  param to generator.py to specify the source directory.  Added\n-\t  a new table of functions which have possible \"foreign\" encodings\n-\t  (e.g. UTF16), and code to use python 't' format instead of\n-\t  'z' format (mostly solving bug #152286, but still need to\n-\t  populate the table).\n-\t  \n-Tue Dec 21 08:10:44 MST 2004 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/site.xsl, doc\/xml.html, plus rebuilt all the html pages\n-\tChange reference to new site for Solaris binaries, fixing bug\n-\t160598\n-\n-\n-Mon Dec 20 08:02:57 PST 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* parser.c: reset input->base within xmlStopParser\n-\t* xmlstring.c: removed call to xmlUTF8Strlen from within\n-\t  xmlUTF8Strpos (Bill Moseley pointed out it was not\n-\t  useful)\n-\n-Fri Dec 17 16:03:41 PST 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* valid.c: changed xmlErrValidWarning to use ctxt->warning\n-\t  instead of ctxt->error for its reports (bug #160662)\n-\n-Fri Dec 17 14:52:17 PST 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* python\/generator.py: modified to allow the ns and nsDefs\n-\t  accessors to return None instead of error when no namespace\n-\t  is present (bug #)\n-\n-Fri Dec 17 11:40:21 PST 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/Makefile.am: changed maintainer-clean dependency with\n-\t  suggestion from Crispin Flowerday (bug #157634)\n-\t* debugXML.c: fixed crash when ATTRIBUTE or DOCUMENT nodes\n-\t  were specified with debugDumpNode (bug #160621)\n-\n-Fri Dec 10 11:24:41 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: fixed ID deallocation problem based on patch from\n-\t  Steve Shepard fixes bug #160893\n-\t* xmlmemory.c: improving comment.\n-\t* testapi.c: new test for xmlDictExists() is generated.\n-\n-Wed Dec  1 22:35:37 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* dict.c, xpath.c, include\/libxml\/hash.h: fixed up some gcc warnings,\n-\t  no change to logic.  New macro XML_CAST_FPTR to circumvent gcc\n-\t  warnings on function pointer <-> object pointer (a hack).\n-\n-Mon Nov 29 14:07:18 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fixed a memory leak on errors in some circumstances #159812\n-\n-Fri Nov 26 23:20:48 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlIO.c: added a check within xmlOutputBufferWriteEscape to prevent\n-\t  a dead loop on bad data (bug 159550)\n-\n-Fri Nov 26 13:09:04 CET 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed strict\/lax element wildcards: the children\n-\t  of elements for which a declaration existed were still processed\n-\t  by the wildcard mechanism (reported by philippe ventrillon to the\n-\t  mailing list).\n-\t  Changed the import and include mechanism to share dictionaries.\n-\n-Fri Nov 26 11:44:36 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c parser.c: make sure xmlCtxtReadFile and htmlCtxtReadFile\n-\t  go through the catalog resolution.\n-\t* gentest.py testapi.c: fix a side effect wrning of the change\n-\n-Wed Nov 24 13:41:52 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* dict.c include\/libxml\/dict.h: added xmlDictExists() to the \n-\t  dictionary interface.\n-\t* xmlreader.c: applying xmlTextReaderHasAttributes fix for namespaces\n-\t  from Rob Richards\n-\n-Wed Nov 17 13:54:37 CET 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: tiny enhancement for content model error reports\n-\t  (#157190, #143948). Removed abbreviations: CT, ST and WC \n-\t  (#157190, reported by Frans  Englich).\n-\t  Initial: no report of local components.\n-\t* result\/schemas\/all* result\/schemas\/any3_0_0.err\n-\t  result\/schemas\/choice*\n-\t  result\/schemas\/cos-st-restricts-1-2-err_0_0.err\n-\t  result\/schemas\/derivation-ok-extension-err_0_0.err\n-\t  result\/schemas\/derivation-ok-extension_0_0.err\n-\t  result\/schemas\/derivation-ok-restriction-2-1-1_0_0.err\n-\t  result\/schemas\/derivation-ok-restriction-4-1-err_0_0.err \n-\t  result\/schemas\/deter0_0_0.err result\/schemas\/extension1_0_2.err\n-\t  result\/schemas\/facet-unionST-err1_0_0.err\n-\t  result\/schemas\/hexbinary_0_1.err\n-\t  result\/schemas\/list* result\/schemas\/restriction-attr1_0_0.err\n-\t  result\/schemas\/vdv-first4_0_1.err result\/schemas\/vdv-first4_0_2.err:\n-\t  Adapted output.\n-\n-Mon Nov 15 13:04:28 CET 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Moved execution of xmlSchemaCheckDefaults to\n-\t  xmlSchemaTypeFixup; this ensures facets of inherited types to be\n-\t  checked prior to facets of derived types - which caused a seg\n-\t  fault otherwise (bug #158216, reported by Frans Englich).\n-\n-Sun Nov 14 22:23:18 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* gentest.py, testapi.c: further enhancement, now all\n-\t  compilation warnings have been fixed.\n-\t* xmlschemastypes.c: added NULL check for one function\n-\n-Fri Nov 12 23:58:14 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: trivial change (changed CHECK_CONTEXT to CHECK_CTXT\n-\t  on a couple of lines)\n-\t* gentest.py, testapi.c: enhanced to reduce compilation warnings\n-\n-Fri Nov 12 16:12:48 CET 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Un-commented a TODO in xmlSchemaParseElement.\n-\n-Fri Nov 12 14:55:36 CET 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Correct symbol space for 'all' and 'choice'.\n-\t* xmlschemastypes.c include\/xmlschemastypes.h: Added 'replace' \n-\t  normalization for 'normalizedString'.  \n-\t  Added xmlSchemaWhiteSpaceReplace to the API.\n-\n-Thu Nov 11 21:43:02 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: forgot a $(srcdir)\n-\t* encoding.c: stupid error wrong name #157976\n-\n-Wed Nov 10 15:35:25 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* NEWS configure.in doc\/*: preparing release of libxml2-2.6.16\n-\n-Wed Nov 10 12:55:18 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/libxml.c python\/libxml2class.txt\n-\t  python\/libxml_wrap.h python\/types.c: Applied patch from Brent\n-\t  Hendricks adding support for late DTD validation.\n-\t* python\/tests\/Makefile.am python\/tests\/dtdvalid.py\n-\t  python\/tests\/test.dtd: integrated the provided regression test\n-\n-Tue nov  9 19:24:31 CET 2004 Dodji Seketeli <dodji@seketeli.org>\n-\n-\t* configure.in: detect when struct sockaddr_storage\n-\t  has the __ss_family member instead of ss_family and\n-\t  behave accordingly. We now can use ipv6 on aix.\n-\n-Tue Nov  9 17:15:46 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am gentest.py testapi.c: integrated in \"make tests\"\n-\t  added -q option, and more conditional features fixes\n-\t* catalog.c debugXML.c parser.c testThreads.c xmllint.c\n-\t  xmlschemastypes.c xmlwriter.cinclude\/libxml\/catalog.h\n-\t  include\/libxml\/debugXML.h: various compilation and conditional\n-\t  cleanups.\n-\t* doc\/*: regenerated\n-\n-Tue Nov  9 15:59:50 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: better handling of conditional features\n-\t* HTMLparser.c SAX2.c parserInternals.c xmlwriter.c: more testing\n-\t  on parser contexts closed leaks, error messages\n-\n-Tue Nov  9 10:21:37 GMT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: fixed problem concerning XPath context corruption\n-\t  during function argument evaluation (bug 157652)\n-\t  \n-Mon Nov  8 18:54:52 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testapi.c: more types.\n-\t* parserInternals.c xpath.c: more fixes\n-\n-Mon Nov  8 18:16:43 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: better parser options coverage\n-\t* SAX2.c xpath.c: more cleanups.\n-\n-Tue Nov  9 01:50:08 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testapi.c: trying to fix some optional support brokenness\n-\n-Mon Nov  8 17:25:27 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: more coverage\n-\t* debugXML.c parser.c xmlregexp.c xpath.c: more fixes\n-\n-Mon Nov  8 15:02:39 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: more coverage\n-\t* SAX2.c parser.c parserInternals.c: more fixes\n-\n-Mon Nov  8 12:55:16 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c testapi.c xmlIO.c xmlstring.c: more fixes.\n-\n-Mon Nov  8 11:24:57 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: more types, more coverage\n-\t* parser.c parserInternals.c relaxng.c valid.c xmlIO.c\n-\t  xmlschemastypes.c: more problems fixed\n-\t  \n-Mon Nov  8 10:24:28 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* gentest.py: fixed test file corruption problem\n-\n-Sun Nov  7 13:18:05 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: fixed typos and avoid Catalogs verbosity\n-\n-Sat Nov  6 23:25:16 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testapi.c: augmented the number of types\n-\n-Sat Nov  6 20:24:07 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c tree.c xmlreader.c xmlwriter.c: a number of new\n-\t  bug fixes and documentation updates.\n-\n-Sat Nov  6 15:50:11 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: augmented type autogeneration for enums\n-\t* xpath.c include\/libxml\/xpath.h: removed direct error reporting.\n-\n-Sat Nov  6 14:27:18 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: fixed a regression in iconv support.\n-\n-Fri Nov  5 18:19:23 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: autogenerate a minimal NULL value sequence\n-\t  for unknown pointer types\n-\t* HTMLparser.c SAX2.c chvalid.c encoding.c entities.c parser.c\n-\t  parserInternals.c relaxng.c valid.c xmlIO.c xmlreader.c \n-\t  xmlsave.c xmlschemas.c xmlschemastypes.c xmlstring.c xpath.c\n-\t  xpointer.c: This uncovered an impressive amount of entry points\n-\t  not checking for NULL pointers when they ought to, closing all\n-\t  the open gaps.\n-\n-Fri Nov  5 16:26:28 UTC 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* catalog.c: fixed problem with NULL entry (bug 157407)\n-\t* xpath.c: fixed a couple of warnings (no change to logic)\n-\n-Fri Nov  5 15:30:43 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: more coverage\n-\t* xmlunicode.c: one fix\n-\n-Fri Nov  5 23:15:51 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* entities.c: fixed a compilation problem on a recent change\n-\n-Fri Nov  5 12:50:09 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: more coverage\n-\t* nanoftp.c tree.c: more fixes\n-\n-Fri Nov  5 11:02:28 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: fixed the way the generator works,\n-\t  extended the testing, especially with more real trees and nodes.\n-\t* HTMLtree.c tree.c valid.c xinclude.c xmlIO.c xmlsave.c: a bunch\n-\t  of real problems found and fixed.\n-\t* entities.c: fix error reporting to go through the new handlers\n-\n-Thu Nov  4 18:44:56 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: dohh ... stupid change killing xmlParseDoc()\n-\n-Thu Nov  4 18:32:22 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: changing the way the .c is generated,\n-\t  extending the tests coverage\n-\t* include\/libxml\/nanoftp.h nanoftp.c elfgcchack.h doc\/*: fixing some\n-\t  function signatures, regenerating stuff\n-\t* SAX2.c parser.c xmlIO.c: another set of bug fixes and API hardening\n-\n-Thu Nov  4 13:32:19 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: extending the tests coverage\n-\n-Thu Nov  4 11:52:28 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: gentest.py was missing from the EXTRA_DIST\n-\n-Thu Nov  4 11:48:47 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: extending the tests coverage\n-\t* HTMLtree.c tree.c xmlsave.c xpointer.c: more fixes and cleanups\n-\n-Thu Nov  4 00:25:36 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: more fixes and extending the tests coverage\n-\t* nanoftp.c xmlIO.c: more fixes and hardening\n-\t\n-Wed Nov  3 20:16:24 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: more fixes and extending the tests coverage\n-\t* valid.c: bunch of cleanups and 2 leaks removed \n-\n-Wed Nov  3 18:06:44 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: more fixes and extending the tests coverage\n-\t* list.c tree.c: more fixes and hardening\n-\n-Wed Nov  3 15:19:22 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: more fixes and extending the tests coverage\n-\t* relaxng.c include\/libxml\/relaxng.h: adding a type init interface\n-\t* include\/libxml\/xmlerror.h parser.c xmlreader.c xmlwriter.c: more\n-\t  cleanups and bug fixes raised by the regression tests\n-\n-Wed Nov  3 12:49:30 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: more fixes and extending the tests coverage\n-\t* xmlwriter.c list.c: more hardeing of APIs\n-\t* doc\/apibuild.py: skip testapi.c when scanning the C files.\n-\n-Tue Nov  2 23:09:06 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: more testing and coverage\n-\t* elfgcchack.h xmlstring.c include\/libxml\/xmlstring.h: more cleanups\n-\t* doc\/*: rebuilt\n-\n-Tue Nov  2 19:44:32 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* gentest.py testapi.c: more developments on the API testing\n-\t* HTMLparser.c tree.c: more cleanups\n-\t* doc\/*: rebuilt\n-\n-Tue Nov  2 15:49:34 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlmemory.c include\/libxml\/xmlmemory.h: adding xmlMemBlocks()\n-\t* Makefile.am gentest.py testapi.c: work on generator of an\n-\t  automatic API regression test tool.\n-\t* SAX2.c nanoftp.c parser.c parserInternals.c tree.c xmlIO.c\n-\t  xmlstring.c: various API hardeing changes as a result of running\n-\t  the first set of automatic API regression tests.\n-\t* test\/slashdot16.xml: apparently missing from CVS, committed it\n-\n-Mon Nov  1 15:54:18 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fixed an UTF-8 parsing bug reported by Markus Bertheau\n-\t  on #fedora-devel\n-\n-Sun Oct 31 22:03:38 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed a bug reported by Petr Pajas on the list and\n-\t  affecting XML::Libxml\n-\n-Sun Oct 31 16:33:54 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c doc\/examples\/testWriter.c: Fixed bug #153937, making\n-\t  sure the conversion functions return the number of byte written.\n-\t  Had to fix one of the examples.\n-\n-Fri Oct 29 14:16:56 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xmllint.1 doc\/xmllint.xml: indicate - means stdin closing #156626\n-\n-Fri Oct 29 14:03:36 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c: register xmlSchemaSetValidErrors, patch from\n-\t  Brent Hendricks in the mailing-list\n-\t* include\/libxml\/valid.h HTMLparser.c SAX2.c valid.c\n-\t  parserInternals.c: fix #156626 and more generally how to find out\n-\t  if a validation contect is part of a parsing context or not. This\n-\t  can probably be improved to make 100% sure that vctxt->userData\n-\t  is the parser context too. It's a bit hairy because we can't \n-\t  change the xmlValidCtxt structure without breaking the ABI since\n-\t  this change xmlParserCtxt information indexes.\n-\n-Wed Oct 27 19:26:20 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* ChangeLog NEWS configure.in doc\/*: preparing release 2.6.15\n-\t* debugXML.c nanoftp.c xmlschemas.c xmlschemastypes.c: cleanups\n-\n-Wed Oct 27 09:31:24 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* uri.c: fixed a stupid mistake in xmlBuildRelativeURI\n-\t  (bug 156527)\n-\n-Wed Oct 27 11:44:35 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanoftp.c nanohttp.c: second part of the security fix for\n-\t  xmlNanoFTPConnect() and xmlNanoHTTPConnectHost().\n-\n-Tue Oct 26 23:57:02 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanoftp.c: applied fixes for a couple of potential security problems\n-\t* tree.c valid.c xmllint.c: more fixes on the string interning checks\n-\n-Tue Oct 26 18:09:59 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c include\/libxml\/xmlerror.h: added checking for names\n-\t  values and dictionaries generates a tons of errors\n-\t* SAX2.ccatalog.c parser.c relaxng.c tree.c xinclude.c xmlwriter.c\n-\t  include\/libxml\/tree.h: fixing the errors in the regression tests\n-\n-Mon Oct 25 16:04:22 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* parser.c: modified the handling of _private for entity\n-\t  expansion (bug 155816)\n-\n-Mon Oct 25 17:11:37 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed the leak reported by Volker Roth on the list\n-\t* test\/ent10 result\/\/ent10*: added a specific test for the problem\n-\n-Sat Oct 23 11:07:41 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* valid.c: unlinked the internal subset within xmlValidateDtd\n-\t  (bug 141827)\n-\t* configure.in: added -Wall to developer's flags\n-\t* doc\/examples\/reader4.res: added to CVS\n-\n-Fri Oct 22 16:36:50 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: added support for HTML PIs #156087\n-\t* test\/HTML\/python.html result\/HTML\/python.html*: added specific tests\n-\n-Fri Oct 22 15:20:23 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* threads.c: fixed nasty bug #156087\n-\n-Fri Oct 22 21:04:20 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c: fixed a problem occurring only in x86_64 when\n-\t  very large error messages are raised to the Python handlers.\n-\n-Thu Oct 21 18:03:21 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: fixed a memory bug\n-\t* doc\/examples\/reader4.c doc\/examples\/*: added test from Graham Bennett\n-\t  and regenerated the directory\n-\n-Tue Oct 19 11:06:39 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlreader.h xmlreader.c: applied patch from\n-\t  Graham Bennett adding 4 convenience functions to the reader API.\n-\n-Fri Oct 15 11:22:48 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* debugXML.c: excluded a few nodes (with no content) from the\n-\t  string check routine.\n-\n-Fri Oct 15 10:48:30 EDT 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c include\/libxml\/xmlerror.h: added UTF-8 string checking,\n-\t  raise a problem, need debug\n-\n-Wed Oct 13 02:17:36 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/Makefile.am: applied patch from Thomas Fitzsimmons fixing\n-\t  #155240 building outside the source tree. but make tests fails.\n-\n-Mon Oct 11 16:26:51 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c include\/libxml\/xmlerror.h: added namespace checking\n-\n-Sat Oct  9 22:36:21 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c: some framework preparation to add namespace checkings\n-\n-Thu Oct  7 15:12:58 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c include\/libxml\/debugXML.h include\/libxml\/xmlerror.h:\n-\t  adding the tree debug mode\n-\t* parser.c relaxng.c tree.c xpath.c: fixing various problems reported\n-\t  by the debug mode.\n-\t* SAX2.c: another tree fix from Rob Richards\n-\n-Wed Oct  6 10:50:03 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* catalog.c: small change to last fix, to get xml:base right\n-\n-Wed Oct  6 09:33:51 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* catalog.c: added code to handle <group>, including dumping\n-\t  to output (bug 151924).\n-\t* xmlcatalog.c, xmlstring.c, parser.c: minor compiler warning \n-\t  cleanup (no change to logic)\n-\t  \n-Mon Oct  4 16:09:07 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in debugXML.c include\/libxml\/xmlversion.h.in\n-\t  include\/libxml\/xmlwin32version.h.in: revamped the XML debugging\n-\t  module and prepare for a new checking mode\n-\n-Mon Oct  4 13:53:24 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: applied patch from Malcolm Tredinnick fixing bug #152426\n-\n-Mon Oct  4 12:26:28 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/libxml.c python\/tests\/outbuf.py: \n-\t  applied patch from Malcolm Tredinnick fixing bug #154294\n-\t  related to saving to python file objects.\n-\n-Sat Oct  2 21:08:51 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* tree.c: changed xmlHasNsProp to properly handle a request for\n-\t  the default namespace (bug 153557)\n-\n-Sat Oct  2 18:18:27 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* parser.c: fixed problem with dictionary handling within\n-\t  xmlParseInNodeContext (bug 153175)\n-\n-Sat Oct  2 15:46:37 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* check-relaxng-test-suite.py, check-relaxng-test-suite2.py,\n-\t  check-xinclude-test-suite.py, check-xml-test-suite.py,\n-\t  check-xsddata-test-suite.py, doc\/examples\/index.py: changed\n-\t  changed sys.path setting from 'append' to 'insert' (patch\n-\t  supplied by Malcolm Tredinnick) (bug 153716)\n-\n-Sat Oct  2 15:03:14 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* include\/libxml\/parserInternals.h: added two new macros\n-\t  IS_ASCII_LETTER and IS_ASCII_DIGIT used with (html)\n-\t  parsing and xpath for testing data not necessarily\n-\t  unicode.\n-\t* HTMLparser.c, xpath.c: changed use of IS_LETTER_CH and\n-\t  IS_DIGIT_CH macros to ascii versions (bug 153936).\n-\t  \n-Fri Oct  1 20:37:25 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* error.c: added some coding to attempt to display which file\n-\t  contains an error when using XInclude (bug 152623)\n-\n-Thu Sep 30 11:19:17 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: stupid cut'n paste bug in xmllint detection\n-\n-Wed Sep 29 17:47:56 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in doc\/*: releasing 2.6.14, rebuilding the docs\n-\t  \n-Wed Sep 29 15:00:11 CEST 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c include\/libxml\/xmlerror.h include\/libxml\/xmlschemas.h\n-\t  include\/libxml\/schemasInternals.h: Parsing of <complexContent>\n-\t  - handle attribute 'mixed', catch illegal attributes.\n-\t  Parsing of <complexType> - handle attributes 'abstract',\n-\t  'final' and 'block', catch illegal attributes.\n-\t  Validation of complex types - handle abstract types.\n-\t  Added handling of default\/fixed attributes and element values.\n-\t  Per validation option attribute nodes\/text nodes are created\n-\t  on the instance.\n-\t  Added the corresponding constraints for fixed\/default.\n-\t  Added xmlSchemaSetValidOptions, xmlSchemaGetValidOptions\n-\t  to the external API.\n-\t  Extended element declaration constraints.  \n-\t  Got rid of perseverative creation of temporery validation\/parser \n-\t  contexts.\n-\t  Added handling of xsi:schemaLocation and\n-\t  xsi:noNamespaceSchemaLocation.\n-\t  Fixed xsi:type component resolution if using non-prefixed\n-\t  QNames.\n-\t* xmlregexp.c xmlschemas.c include\/libxml\/xmlautomata.h:\n-\t  Enabled namespace awareness of the content model if using the\n-\t  model group \"all\".\n-\t* test\/schemas\/bug152470_1.xsd: Removed an \"abstract\" attribute,\n-\t  which broke the test.\n-\t* xstc\/xstc.py:  Workaround to accommodate case insensitive\n-\t  test definitions in ms-test.def.xml (was missing in a previous\n-\t  commit).\n-\n-Wed Sep 29 11:03:10 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/drv_libxml2.py: another patch from Malcolm Tredinnick\n-\t  adding option not to load dtd from the drv_libxml2.py module\n-\t  #134633\n-\n-Tue Sep 28 14:30:22 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* acconfig.h config.h.in configure.in xmlIO.c xmlregexp.c xmlschemas.c\n-\t  xmlschemastypes.c: another patch from Malcolm Tredinnick fixing\n-\t  warning generated by the Nonstop Kernel Open System Services \n-\t  compiler #151710\n-\n-Tue Sep 28 13:07:37 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.py: applied patch from Malcolm Tredinnick fixing\n-\t  python exception hierarchy #139824\n-\n-Sun Sep 26 16:40:24 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c TODO: applied patch from Malcolm Tredinnick fixing errata\n-\t  E20 concerning NMTOKENS and co. validation #153722\n-\t* result\/VC\/AttributeNmtokens test\/VC\/AttributeNmtokens\n-\t  test\/VCM\/AttributeNmtokens.xml: also added tests from Malcolm\n-\n-Sun Sep 26 16:24:44 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xstc\/xstc.py: applied patch from Malcolm Tredinnick fixing space\/tabs\n-\t  #153713\n-\t* xpath.c: fixed a realloc potential problem\n-\n-Fri Sep 24 16:14:12 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: fixed make valgrind xstc \n-\n-Thu Sep 23 18:23:46 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: fixing an out of bound addressing issue\n-\n-Thu Sep 23 15:14:12 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c parser.c relaxng.c xmlschemas.c: more memory related\n-\t  code cleanups.\n-\n-Thu Sep 23 01:04:30 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed a bunch of errors when realloc failed.\n-\n-Wed Sep 22 23:56:05 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* threads.c uri.c: couple of memory fixes from Mark Vakoc reported\n-\t  by Purify on Windows.\n-\n-Mon Sep 20 22:01:47 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: added --timing --copy timing for the copy\n-\t* vms\/build_libxml.com: applied patch from Craig Berry\n-\t  to build with recent releases\n-\n-Fri Sep 17 21:25:33 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* nanohttp.c, include\/libxml\/nanohttp.h: added the routine\n-\t  xmlNanoHTTPContentLength to the external API (bug151968).\n-\t* parser.c: fixed unnecessary internal error message (bug152060);\n-\t  also changed call to strncmp over to xmlStrncmp.\n-\t* encoding.c: fixed compilation warning (bug152307).\n-\t* tree.c: fixed segfault in xmlCopyPropList (bug152368); fixed\n-\t  a couple of compilation warnings.\n-\t* HTMLtree.c, debugXML.c, xmlmemory.c: fixed a few compilation\n-\t  warnings; no change to logic.\n-\n-Fri Sep 17 10:40:23 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: removed some extern before function code reported by\n-\t  Kjartan Maraas on IRC\n-\t* legacy.c: fixed compiling when configuring out the HTML parser\n-\t* Makefile.am: added a declaration for CVS_EXTRA_DIST\n-\t* HTMLparser.c: beginning of an attempt at cleaning up the construction\n-\t  of the HTML parser data structures, current data generate a huge\n-\t  amount of ELF relocations at loading time.\n-\n-Fri Sep 17 10:36:23 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* ChangeLog: applied fix from Stepan Kasal to fix duplication\n-\t  in the change log and cleanup of space\/tabs issues.\n-\n-Thu Sep 16 13:24:27 CEST 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c include\/libxml\/schemasInternals.h \n-\t  test\/schemas\/bug152470_1.* result\/schemas\/bug152470_1_1*: \n-\t  Simplified attribute wildcard creation and assignment to get rid \n-\t  of memory leaks.\n-\t  Restructured the validation process.\n-\t  Restructured and expanded parsing of <attributeGroup>.\n-\t  Added initial handing of xsi:type.\n-\t  Advanced handling of xsi:nil (should work now for simple types).\n-\t  Added construction of schemata using xsi:schemaLocation and \n-\t  xsi:noNamespaceSchemaLocation; this is not enabled, since \n-\t  no corresponding API exists yet.\n-\t  Moved the content model to complex type components.\n-\t  Resolution of types for attributes will look for simple types\n-\t  only (incl. all the built-in simple types).\n-\t  Extended parsing of 'anyAttribute'.\n-\t  Fixed content-type type for complex types if derived from \n-\t  'anyType' using the short-hand form (see bug # 152470,\n-\t  submitted by Thilo Jeremias).\n-\t* include\/libxml\/xmlschematypes.h: Cleaned up some comments.\n-\t* xstc\/xstc.py: Workaround to accommodate case insensitive\n-\t  test definitions in ms-test.def.xml.\n-\t* result\/schemas\/deter0_0_0.err result\/schemas\/ns0_0_2.err\n-\t  result\/schemas\/ns0_1_2.err: Adapted.\n-\n-Sat Sep 11 09:04:22 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlwriter.c: changed char array initialisation to avoid a\n-\t  complaint from some compiler(s) (bug 152308)\n-\n-Thu Sep  9 07:22:11 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* encoding.c: applied fixes for the UTF8ToISO8859x transcoding\n-\t  routine suggested by Mark Itzcovitz\n-\n-Wed Sep  8 22:50:27 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c xmlsave.c: fixed 2 problems raised by #152140, one\n-\t  which is that notation not in the internal subset should\n-\t  not be saved, and the second more nasty on an error saving\n-\t  NOTATIONs, if there is a proof that nobody uses notations !\n-\n-Wed Sep  8 11:04:27 CEST 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c include\/libxml\/xmlschemas.h: Added the function\n-\t  xmlSchemaValidateOneElement to the XML Schema validation API, \n-\t  as proposed by Jeffrey Fink - see bug # 152073.\n-\n-Tue Sep  7 11:10:36 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in doc\/Makefile.am xstc\/Makefile.am: some cleanup\n-\t  checking for xmllint and xsltproc in configure.in, fixed\n-\t  make dist w.r.t. the new xstc subdir.\n-\t* doc\/*: rebuilt\n-\n-Mon Sep  6 16:42:59 CEST 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xstc\/xstc.py: Changed to finally validate instance documents.\n-\n-Mon Sep  6 16:04:01 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xstc\/Makefile.am Makefile.am: integrated to \"make valgrind\",\n-\t  heavy ... weight 250MB of VM !\n-\n-Mon Sep  6 14:54:39 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xstc\/Makefile.am xstc\/xstc-to-python.xsl xstc\/xstc.py Makefile.am:\n-\t  more cleanup in integrating the xstc testsuite\n-\n-Mon Sep  6 13:56:28 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am configure.in xstc\/.cvsignore xstc\/Makefile.am:\n-\t  starting to integrate the xstc suite in the normal regression\n-\t  tests\n-\n-Mon Sep  6 13:14:11 CEST 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xstc\/sun-test-def.xml: The \"tsDir\" attribute was not\n-\t  set correctly.\n-\n-Mon Sep  6 11:52:50 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* check-xinclude-test-suite.py: when output and expected do not match\n-\t  exactly run diff to put the differences in the log c.f. #148691\n-\n-Mon Sep  6 11:17:35 CEST 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xstc\/xstc-to-python.xslt xstc\/ms-test-def.xml xstc\/nist-test-def.xml\n-\t  xstc\/sun-test-def.xml: Initial release of generation files to \n-\t  create python test scripts, which will run the W3C XML Schema Test\n-\t  Collection. The ms-test-def.xml and sun-test-def.xml files\n-\t  were extracted from the online HTML XSTC results [1], since they did\n-\t  not exist for the SUN tests, and only partially did exist for the \n-\t  MS tests. The NIST definition file was created by concatenation\n-\t  of the existing definition files for each single datatype.\n-\t  The stylesheet \"xstc-to-python.xslt\" should be run against the\n-\t  definition files to produce the python scripts.\n-\t  [1] \"http:\/\/www.w3.org\/XML\/2001\/05\/xmlschema-test-collection\/\n-\t  results-master.html\"\n-\n-Fri Sep  3 20:29:59 CEST 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c include\/libxml\/schemasInternals.h\n-\t  include\/libxml\/xmlerror.h: Fixed a seg fault in xmlGetQNameProp:\n-\t  a format argument was missing.\n-\t  Fixed wrong assignment of the owner of a wildcard in\n-\t  xmlSchemaBuildAttributeValidation (in the shorthandform of\n-\t  <complexType>; this caused a seg fault, due to a double-free\n-\t  of the wildcard.\n-\t  Added a check for circular attribute group references.\n-\t  Added a check for circular model group definition references.\n-\t  Fixed a duplicate xmlParserErrors enum value - see bug #151738.\n-\n-Fri Sep  3 10:08:13 PDT 2004 William Brack <wbrack@mmmm.com.hk>\n-\n-\t* xmlstring.c: modified comments on xmlGetUTF8Char in\n-\t  response to bug 151760 (no change to logic)\n-\n-Tue Aug 31 09:46:18 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlstring.c: fixed error reported on the list caused by\n-\t  my last change\n-\n-Tue Aug 31 15:41:52 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* NEWS configure.in doc\/*: release of libxml2-2.6.13\n-\n-Tue Aug 31 14:14:30 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: fixing #151456, an encoding error could generate\n-\t  a serialization loop.\n-\n-Tue Aug 31 11:34:04 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: also produce a tar ball with just the sources\n-\t* xmllint.c: added --path option and --load-trace options to\n-\t  xmllint, RFE #147740 based on xsltproc versions\n-\t* doc\/xmllint.* doc\/*: updated the man page and rebuilt\n-\n-Tue Aug 31 10:37:23 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: \"\" is a valid hexbinary string dixit xmlschema-dev\n-\t* result\/schemas\/hexbinary_0_1.err test\/schemas\/hexbinary_1.xml: \n-\t  update the test.\n-\t* test\/ns5 result\/\/ns5*: added a test for the namespace bug fixed\n-\t  in previous commit.\n-\t* Makefile.am: added a message in the regression tests\n-\n-Mon Aug 30 23:36:21 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* SAX2.c: fixed bug introduced during OOM fixup causing problems\n-\t  with default namespace when a named prefix with the same href\n-\t  was present (reported on the mailing list by Karl Eichwalder.\n-\t* xmlstring.c: modified xmlCheckUTF8 with suggested code from\n-\t  Julius Mittenzwei.\n-\t* dict.c: added a typecast to try to avoid problem reported by\n-\t  Pascal Rodes.\n-\n-Mon Aug 30 12:45:46 CEST 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: Fixed a bug in xmlSchemasCheckFacet, which did\n-\t  not create a computed value on a facet and thus crashed during\n-\t  validation of instances.\n-\t  Expanded validity checks for min\/maxOccurs attributes.\n-\t  Expanded validity checks for the value of the attribute \"form\".\n-\n-Fri Aug 27 18:32:24 PST 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlstring.c: fixed a problem with xmlCheckUTF8 reported on the\n-\t  mailing list by Julius Mittenzwei\n-\n-Fri Aug 27 00:13:39 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in: added BuildRequires:  zlib-devel, fixes\n-\t  Red Hat bug #124942\n-\n-Thu Aug 26 12:27:23 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: remove a warning on Solaris\n-\t* xmlschemastype.c: fix a crashing bug #151111\n-\n-Wed Aug 25 22:20:18 CEST 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* test\/schemas\/import-bad-1_0.imp: Added missing test file.\n-\t* xmlschemas.c include\/libxml\/xmlerror.h include\/libxml\/xmlschemas.h:\n-\t  Substituted the obsolete xmlSchemaValidError(s) for xmlParserErrors\n-\t  - see #150840. \n-\t  Changed the import of schemas to allow failure of location\n-\t  of a resource to be imported.\n-\t* result\/schemas\/all_* result\/schemas\/any3_0_0.err \n-\t  result\/schemas\/choice_* result\/schemas\/import1_0_0.err\n-\t  result\/schemas\/list0_0_1.err result\/schemas\/list0_1_0.err\n-\t  result\/schemas\/list0_1_1.err result\/schemas\/ns0_0_2.err\n-\t  result\/schemas\/ns0_1_2.err: Adapted regression test results.\n-\n-Tue Aug 24 20:49:15 MDT 2004 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/tutorial\/xmltutorial.xml, xmltutorial.pdf, *.html\n-\tfix Xpath memory leak (thanks to sKaBoy and William Brack)\n-\n-Tue Aug 24 21:10:59 CEST 2004 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* parser.c: fixed path problem in DTD loading reported by \n-\t  Sameer Abhinkar\n-\n-Tue Aug 24 16:40:51 CEST 2004 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/configure.js: added support for version extra\n-\t* win32\/Makefile.*: upgraded to zlib 1.2.1\n-\n-Mon Aug 23 14:33:54 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: removing -O -g from default gcc flags #150828\n-\n-Sun Aug 22 16:26:46 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in doc\/* NEWS: preparing 2.6.12 release, updated and\n-\t  and rebuilt the docs.\n-\n-Sun Aug 22 16:07:20 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c: fix a problem on last commit\n-\n-Sun Aug 22 15:16:53 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c xpath.c include\/libxml\/xpath.h \n-\t  include\/libxml\/xpathInternals.h python\/libxml.c \n-\t  python\/libxml_wrap.h: trying to remove some warning when compiling\n-\t  on Fedora Core 3 and 64bits\n-\n-Sat Aug 21 0:035:10 CET 2004 Kasimier Buchcik <libxml2-cvs@cazic.net>\n-\n-\t* xmlschemas.c: modified parsing of <list>, <union>, <restriction>,\n-\t  <sequence>, <choice>, <include>, <import>.\n-\t  Fixed schema defaults (elementFormDefault, etc.) for included\n-\t  schemas.\n-\t  Fixed a bug which reported attributes as invalid on\n-\t  elements declarations with the built-in type 'anyType'.\n-\t  Added \"lax\" validation of the content of elements of type\n-\t  'anyType'.\n-\t  Fixed: element declarations with the same name were treated\n-\t  as duplicate if located in the subtree of <choice> -> <sequence>.\n-\t  (This was bug 150623, submitted by Roland Lezuo)\n-\t  Fixed cleanup of error codes in xmlSchemaValidateDoc as proposed\n-\t  by Igor Kapitanker. (This was bug 150647, submitted by Igor\n-\t  Kapitanker)\n-\t* xmlschemastypes.c: Changed the type of anyType to\n-\t  XML_SCHEMAS_ANYTYPE.\n-\t* include\/libxml\/xmlerror.h: Added schema parser errors.\n-\t* result\/schemas\/bug145246_0_0*\n-\t  result\/schemas\/extension1_0_2.err: Changed test results.\n-\t* result\/schemas\/ct-sc-nobase_0_0*\n-\t  result\/schemas\/facet-whiteSpace_0_0*\n-\t  result\/schemas\/import1_0_0* result\/schemas\/import2_0_0*\n-\t  result\/schemas\/include2_0_0* result\/schemas\/include3_0_0*\n-\t  result\/schemas\/restriction-attr1_0_0*\n-\t  result\/schemas\/seq-dubl-elem1_0_0*\n-\t  result\/schemas\/xsd-list-itemType_0_0*: Added new rest results.\n-\t  test\/schemas\/bug145246.xsd.imp test\/schemas\/ct-sc-nobase_0*\n-\t  test\/schemas\/facet-whiteSpace_0* test\/schemas\/import1_0*\n-\t  test\/schemas\/import2_0* test\/schemas\/include2_0*\n-\t  test\/schemas\/include3_0* test\/schemas\/restriction-attr1_0*\n-\t  test\/schemas\/seq-dubl-elem1_0* test\/schemas\/xml.xsd\n-\t  test\/schemas\/xsd-list-itemType_0*: Added new tests and missing\n-\t  files.  \t      \n-\n-Fri Aug 20 18:51:36 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am configure.in: a bit of cleanup and a extra variable for\n-\t  CVS dist\n-\n-Thu Aug 19 07:44:07 MDT 2004 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmllint.xml, xmllint.1, xmllint.html:\n-\tEdit and rebuild the man pages with Daniel's C14 update\n-\n-Wed Aug 18 19:15:27 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* parser.c: fixed missing line numbers on entity as reported\n-\t  on the list by Steve Cheng\n-\n-Wed Aug 18 14:04:31 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* configure.in globals.c include\/libxml\/xmlversion.h.in\n-\t  include\/libxml\/xmlwin32version.h.in: added some code to\n-\t  include the CVS ChangeLog version in the xmlParserVersion\n-\t  string (printed by xmllint with --version)\n-\n-Wed Aug 18 11:14:06 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c include\/libxml\/xmlschemas.h python\/generator.py\n-\t  python\/libxml.c python\/libxml_wrap.h python\/types.c\n-\t  python\/tests\/schema.py python\/tests\/Makefile.am: Applied patch\n-\t  from Torkel Lyng to add Schemas support to the Python bindings\n-\t  and extend the schemas error API, registered a new test.\n-\t* doc\/* elfgcchack.h: rebuilt to regenerate the bindings\n-\n-Mon Aug 16 14:36:25 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c: added help for new set shell command\n-\t* xinclude.c xmllint.c xmlreader.c include\/libxml\/parser.h:\n-\t  added parser option to not generate XInclude start\/end nodes,\n-\t  added a specific option to xmllint to test it fixes #130769\n-\t* Makefile.am: regression test the new feature\n-\t* doc\/xmllint.1 doc\/xmllint.xml: updated man page to document option.\n-\n-Mon Aug 16 02:42:30 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: small typo pointed out by Mike Hommey\n-\t* doc\/xmllint.xml, xmllint.html, xmllint.1: slightly improved\n-\t  the --c14n description, c.f. #144675 .\n-\t* nanohttp.c nanoftp.c: applied a first simple patch from \n-\t  Mike Hommey for $no_proxy, c.f. #133470\n-\t* parserInternals.c include\/libxml\/parserInternals.h\n-\t  include\/libxml\/xmlerror.h: cleanup to avoid 'error' identifier \n-\t  in includes #137414\n-\t* parser.c SAX2.c debugXML.c include\/libxml\/parser.h:\n-\t  first version of the implementation of parsing within\n-\t  the context of a node in the tree #142359, new function\n-\t  xmlParseInNodeContext(), added support at the xmllint --shell\n-\t  level as the \"set\" function\n-\t* test\/scripts\/set* result\/scripts\/* Makefile.am: extended\n-\t  the script based regression tests to instrument the new function.\n-\n-Sat Aug 14 18:53:08 MDT 2004 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmllint.xml, xmllint.html, xmllint.1:\n-\tadd c14n to man page (man, it's hard to keep up with\n-\tDaniel!)\n-\n-Sat Aug 14 18:45:38 MDT 2004 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmllint.xml, xmllint.html, xmllint.1:\n-\tadd pattern, walker, maxmem, output and xmlout to man page\n-\tfixes #144675\n-\n-Sun Aug 15 00:41:12 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: added a --c14n option to canonicalize the output\n-\t  should close the RFE #143226\n-\n-Sat Aug 14 23:50:10 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: Dodji pointed out a bug in xmlGetNodePath()\n-\t* xmlcatalog.c: applied patch from Albert Chin to add a\n-\t  --no-super-update option to xmlcatalog see #145461\n-\t  and another patch also from Albert Chin to not crash \n-\t  on -sgml --del without args see #145462\n-\t* Makefile.am: applied another patch from Albert Chin to\n-\t  fix a problem with diff on Solaris #145511\n-\t* xmlstring.c: fix xmlCheckUTF8() according to the suggestion\n-\t  in bug #148115\n-\t* python\/libxml.py: apply fix from Marc-Antoine Parent about\n-\t  the errors in libxml(2).py on the node wrapper #135547\n-\n-Sat Aug 14 13:18:57 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: added a dumb rule to able to compile tst.c\n-\t  when people submit a sample test program\n-\t* xmlschemas.c: applied small patch from Eric Haszlakiewicz\n-\t  to document xmlSchemasSetValidErrors() limitations, #141827\n-\t* error.c: Add information in generic and structured error\n-\t  setter functions that this need to be done per thread #144308\n-\t* xmlsave.c: fixed bug with missing NOTATION(s) serialization\n-\t  bug #144162\n-\t* doc\/xmllint.xml: typo fix #144840\n-\n-Tue Aug 10 07:19:31 PDT 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in xmlregexp.c xmlschemas.c xmlschemastypes.c\n-\t  include\/libxml\/schemasInternals.h include\/libxml\/xmlerror.h\n-\t  include\/libxml\/xmlschemastypes.h: applied Schemas patches\n-\t  from Kasimier Buchcik\n-\t* test\/ result\/ bug141333* annot-err* any[1-4]* bug145246*\n-\t  element-err* element-minmax-err* include1* restrict-CT-attr-ref*:\n-\t  lot of new tests for things fixed by the patch\n-\n-Fri Aug  6 09:22:34 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* valid.c: fixed my mis-handling of External ID on last\n-\t  change.\n-\n-Wed Aug  4 23:40:21 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* valid.c: changed the parsing of a document's DTD to use\n-\t  the proper base path (bug 144366)\n-\n-Wed Aug  4 16:58:08 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am config.h.in configure.in python\/Makefile.am:\n-\t  applied a patch from Gerrit P. Haase to get python bindings\n-\t  on Cygwin\n-\n-Tue Aug  3 15:08:22 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* include\/libxml\/valid.h: elaborated on description of\n-\t  xmlValidityWarningFunc and xmlValidityErrorFunc (bug\n-\t  144760)\n-\t* xmlIO.c, xmlschemastypes.c, include\/libxml\/schemasinternals.h:\n-\t  minor fixes to comments for doc rebuilding errors.\n-\t* doc\/*.html: rebuilt the docs\n-\n-Tue Aug  3 23:59:23 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/ChangeLog.xsl doc\/downloads.html doc\/xml.html doc\/*:\n-\t  fixes documentation glitches raised by Oliver Stoeneberg\n-\n-Tue Aug  3 09:42:31 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* tree.c: fixed problem with memory leak on text nodes in DTD\n-\t  (bug 148965) with patch provided by Darrell Kindred\n-\n-Tue Aug  3 08:14:44 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* HTMLparser.c: fixed initialisation problem for htmlReadMemory\n-\t  (bug 149041)\n-\n-Sat Jul 31 11:01:33 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/buildDocBookCatalog: enhanced per bug 119876.  Further\n-\t  info posted to the mailing list.\n-\n-Sat Jul 31 09:12:44 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* SAX2.c, encoding.c, error.c, parser.c, tree.c, uri.c, xmlIO.c,\n-\t  xmlreader.c, include\/libxml\/tree.h: many further little changes\n-\t  for OOM problems.  Now seems to be getting closer to \"ok\".\n-\t* testOOM.c: added code to intercept more errors, found more\n-\t  problems with library. Changed method of flagging \/ counting\n-\t  errors intercepted.\n-\n-Fri Jul 30 13:57:55 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: applied a couple of patch one from Oliver Stoeneberg\n-\t  and another one from Rob Richards fixing #148448\n-\n-Thu Jul 29 13:20:28 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: 1 line patch, apparently htmlNewDoc() was not\n-\t  setting doc->charset.\n-\n-Thu Jul 29 00:05:58 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* SAX2.c, tree.c, uri.c, xmlIO.c, xmlreader.c: further\n-\t  fixes for out of memory condition, mostly from Olivier\n-\t  Andrieu.\n-\t* testOOM.c: some further improvement by Olivier, with\n-\t  a further small enhancement for easier debugging.\n-\n-Tue Jul 27 00:34:07 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* SAX2.c, error.c, parser.c, tree.c, xmlreader.c:\n-\t  implemented patches supplied by Olivier Andrieu \n-\t  (bug 148588), plus made some further enhancements, to\n-\t  correct some problems with out of memory conditions.\n-\t* testOOM.c: improved with patches from Olivier Andrieu\n-\n-Mon Jul 26 11:03:18 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* tree.c: put in patch for Windows buffer re-allocation\n-\t  submitted by Steve Hay (bug 146697)\n-\n-Sun Jul 25 17:18:39 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xinclude.c: added some code to check, when an include is\n-\t  done, whether the requested URL gets mapped to some other\n-\t  location (e.g. with a catalog entry) and, if so, take care\n-\t  of the xml:base properly (bug 146988)\n-\n-Sun Jul 25 14:02:24 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* error.c: fixed to assure user data param is set correctly\n-\t  when user structured error handler is called (bug 144823)\n-\n-Thu Jul 22 10:14:48 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlreader.c: fixed problem with reader state after\n-\t  processing attributes (bug 147993)\n-\n-Wed Jul 21 17:04:27 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* configure.in, Makefile.am: put in an auto* check for the\n-\t  path to perl (if it exists), and modified make Timingtests\n-\t  to use that path instead of just executing the dbgenattr.pl\n-\t  script (bug 148056)\n-\n-Fri Jul 16 18:36:33 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* python\/generator.py: added a check on the argument for some\n-\t  classes (e.g. xmlDoc and xmlNode) to prevent a segfault (as\n-\t  reported on the list).  Further enhancement should be done\n-\t  to auto-create the appropriate object.\n-\t* python\/libxml.c: minor fix for a warning message; added a\n-\t  routine, currently not used, to report the description of a\n-\t  PyCObject.\n-\t* python\/libxml2class.txt: regenerated\n-\n-Fri Jul 16 11:01:40 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c test\/catalogs\/white* result\/catalogs\/white*:\n-\t  applied patches from Peter Breitenlohner to fix handling\n-\t  of white space normalization in public ids and add tests\n-\n-Tue Jul 13 17:24:13 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlmemory.c: applied a small fix from Steve Hay\n-\n-Tue Jul 13 23:02:19 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: Added code to in PREDICATE\/FILTER handling to reset\n-\t  the xpath context document pointer (part of fix to libxslt\n-\t  bug 147445)\n-\n-Tue Jul 13 00:14:08 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* python\/libxml.py: ran 'expand' on the file to get rid of mixture\n-\t  of tabs and spaces (bug 147424)\n-\n-Sun Jul 11 22:38:29 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* python\/drv_libxml.py: added an encoding \"special comment\" to avoid\n-\t  warning message in python2.3 (bug 146889)\n-\t* Makefile.am, python\/Makefile.am, python\/tests\/Makefile.am: small\n-\t  change to make \"make tests\" a little quieter (MAKEFLAGS+=--silent)\n-\t* xpath.c: enhanced to take advantage of current libxslt handling\n-\t  of tmpRVT.  Fixes bug 145547.\n-\n-Fri Jul  9 14:02:54 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.h uri.c: fixed a couple of problems in the new\n-\t  elfgcchack.h trick pointed by Peter Breitenlohner\n-\n-Wed Jul  7 00:45:48 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* elfgcchack.h doc\/apibuild.py doc\/libxml2-api.xml: fixed a bug\n-\t  which prevented building with --with-minimum\n-\n-Mon Jul  5 19:43:51 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in doc\/*: releasing 2.6.11, updated and regenerated the\n-\t  docs\n-\n-Mon Jul  5 18:43:47 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: make the push interfaces synchronous\n-\t* python\/tests\/sync.py: added a specific test\n-\t* python\/tests\/Makefile.am doc\/examples\/Makefile.am\n-\t  doc\/examples\/index.py: added the new test, cleaning up \n-\t  \"make tests\" output\n-\n-Mon Jul  5 15:09:17 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: applied patch from Kasimier to fix some Relax-NG\n-\t  datatype facet problem with recent changes.\n-\n-Sat Jul  3 11:31:02 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* python\/libxml.c: Changed the number of XPath extension functions\n-\t  allowed to be variable-length (patch supplied by Marc-Antoine\n-\t  Parent, bug 143805).  Added code to \"unregister\" the functions\n-\t  when the parser cleanup takes place.\n-\n-Fri Jul  2 14:22:14 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlmemory.c python\/libxml.c python\/libxml2-python-api.xml:\n-\t  some updates with memory debugging facilities while messing\n-\t  with libxslt python bindings\n-\n-Thu Jul  1 14:53:36 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c python\/generator.py python\/libxml.py\n-\t  python\/libxml2-python-api.xml python\/libxml2class.txt:\n-\t  applied patch from Stéphane Bidoul to fix some Python bindings\n-\t  initialization, then had to change the parserCleanup() \n-\t  to handle memory released there.\n-\t* xmlmemory.c: added more debugging comments.\n-\n-Thu Jul  1 13:18:02 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: seems the reader buffer could be used while not\n-\t  allocated, fixes bug #145218\n-\n-Thu Jul  1 11:34:10 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py: do not provide functions used as destructor\n-\t  of classes as public methods to avoid double-free problem like\n-\t  in bug #145185\n-\n-Wed Jun 30 19:45:23 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlschemas.c, xmlschemastypes.c: warning message cleanup.\n-\t  Now compiles warning-free, all tests passed.\n-\t* SAX2.c: small change to comments for documentation.\n-\t  No change to logic.\n-\n-Tue Jun 29 15:00:13 PDT 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: more fixes with Kasimier, looks far cleaner :-)\n-\n-Tue Jun 29 23:00:05 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: Kasimier Buchcik fixed the memory access and\n-\t  allocation problem\n-\n-Tue Jun 29 19:00:32 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c xmlschemastypes.c include\/libxml\/xmlerror.h\n-\t  include\/libxml\/schemasInternals.h include\/libxml\/xmlschemastypes.h:\n-\t  applied Schemas patches from Kasimier Buchcik, there is still\n-\t  one open issue about referencing freed memory.\n-\t* test\/schemas\/* result\/schemas\/*: updated with new tests from \n-\t  Kasimier\n-\n-Tue Jun 29 14:52:18 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/globals.h include\/libxml\/xmlIO.h\n-\t  doc\/libxml2-api.xml doc\/libxml2-refs.xml: moved some definitions\n-\t  to globals.h to avoid some troubles pointed out by Rob Richards\n-\n-Mon Jun 28 11:25:31 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.m4: applied changes suggested by Mike Hommey, remove\n-\t  libxml1 support and use CPPFLAGS instead of CFLAGS\n-\n-Sun Jun 27 14:17:15 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in: another, more 'experimental' feature to \n-\t  get compiler optimization based on gcc runtime profiling\n-\n-Sun Jun 27 14:02:36 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* elfgcchack.h doc\/elfgcchack.xsl libxml.h: hack based on Arjan van de\n-\t  Ven suggestion to reduce ELF footprint and generated code. Based on\n-\t  aliasing of libraries function to generate direct call instead of\n-\t  indirect ones\n-\t* doc\/libxml2-api.xml doc\/Makefile.am doc\/apibuild.py: added automatic\n-\t  generation of elfgcchack.h based on the API description, extended\n-\t  the API description to show the conditionals configuration flags\n-\t  required for symbols.\n-\t* nanohttp.c parser.c xmlsave.c include\/libxml\/*.h: lot of cleanup\n-\t* doc\/*: regenerated the docs.\n-\n-Sun Jun 27 10:02:28 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* regressions.py, regressions.xml: new files for running\n-\t  regression tests under Python.  Not yet complete, but\n-\t  should provide good testing under both Linux and Windows.\n-\t* testHTML.c, testSAX.c, xmllint.c: changed the 'fopen' used\n-\t  for --push testing to include the 'rb' param when compiled\n-\t  under Windows.\n-\n-Fri Jun 25 13:38:57 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* uri.c: fixed a problem when base path was \".\/xxx\"\n-\t* result\/XInclude\/*: 5 test results changed by above.\n-\t* Makefile.am: fixed a couple of spots where a new\n-\t  result file used different flags that the testing one.\n-\n-Thu Jun 24 16:27:44 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* valid.c: suppressed warnings from within xmlValidGetValidElements\n-\t  (bug 144644)\n-\t* doc\/examples\/testWriter.c: corrected typo in comment for ISO-8859-1\n-\t  (bug 144245)\n-\n-Thu Jun 24 10:17:31 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* valid.c: implemented bugfix from Massimo Morara for DTD\n-\t  dumping problem.\n-\t* test\/valid\/t10.xml, result\/valid\/t10.*: added regression\n-\t  for above\n-\t* configure.in: small change for my profile settings\n-\n-Wed Jun 23 20:18:19 MDT 2004 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmlcatalog_man.xml, xmlcatalog.1\n-\tDocs patch from Ville Skytta, bugzilla #144841\n-\n-Sat Jun 19 18:34:11 MDT 2004 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmllint.xml, xmllint.html, xmllint.1\n-\tupdate man page to reflect William's newly disciplined return\n-\tcode mojo\n-\n-Thu Jun 17 00:51:55 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/examples\/io2.c doc\/examples\/parse4.c: fixing a couple of\n-\t  compilation errors when configured with --with-minimum\n-\n-Wed Jun 16 16:07:10 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c: applied patch from Stefano Debenedetti to register\n-\t  namespaces in the debug shell\n-\n-Mon Jun 14 21:56:31 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: fix from Steve Ball and update of the comment.\n-\t* Makefile.am result\/errors\/*.str: William pointed out that \n-\t  the streaming error checking part wasn't streaming, fixing\n-\n-Mon Jun 14 14:11:52 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: patch from Igor for the default catalog path on Windows\n-\n-Sat Jun 12 09:03:57 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* configure.in: apparently wasn't updated last time\n-\n-Thu Jun 10 20:57:48 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* configure.in, xmlmemory.c, globals.c: fixed problem when\n-\t  configuring using --with-thread-alloc\n-\n-Wed Jun  9 16:31:24 CEST 2004 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/configure.js win32\/Makefile.* minor changes for the new\n-\t  layout of the Windows binary package\n-\n-Tue Jun  8 19:50:25 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c include\/libxml\/xmlerror.h: applied another patch\n-\t  from Kasimier Buchcik for Schema Component Constraints\n-\t* test\/schemas\/* result\/schemas\/*: added the regression tests\n-\n-Tue Jun  8 21:27:03 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmllint.c: fixed missing error return code for schema\n-\t  validation (bug 143880), also changed over to an enum for\n-\t  defining the error return codes for all conditions.\n-\n-Tue Jun  8 14:01:14 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c xmlreader.c include\/libxml\/parser.h: fixed a serious\n-\t  problem when substituting entities using the Reader, the entities\n-\t  content might be freed and if rereferenced would crash\n-\t* Makefile.am test\/* result\/*: added a new test case and a new\n-\t  test operation for the reader with substitution of entities.\n-\n-Tue Jun  8 12:14:16 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* globals.c xmlIO.c include\/libxml\/globals.h include\/libxml\/xmlIO.h:\n-\t  applied patch from Rob Richards for the per thread I\/O mappings\n-\n-Tue Jun  8 09:58:31 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xinclude.c: some further enhancement to take care of\n-\t  xml:base for XPointer elements (bug 143886).  Also fixed\n-\t  a problem when xml:base was already specified on an\n-\t  XInclude'd element.\n-\n-Mon Jun  7 22:14:58 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* relaxng.c: fixed a problem with internal cleanup of <DIV> element\n-\t  (bug 143738).\n-\n-Mon Jun  7 16:57:43 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* uri.c, include\/libxml\/uri.h: added a new routine\n-\t  xmlBuildRelativeURI needed for enhancement of xinclude.c\n-\t* xinclude.c: changed handling of xml:base (bug 135864)\n-\t* result\/XInclude\/*: results of 5 tests changed as a result\n-\t  of the above change\n-\n-Fri Jun  4 11:27:37 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* test\/schemas\/* result\/schemas\/*: added a bunch of tests from\n-\t  Kasimier Buchcik posted on May 11\n-\n-Thu Jun  3 17:58:25 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: new patch from  Kasimier Buchcik for processContents\n-\t  of wildcards attribute handling\n-\t* test\/schemas\/anyAttr-* result\/schemas\/anyAttr-*: added specific\n-\t  regression tests\n-\n-Thu Jun  3 13:20:36 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed a bug where invalid charrefs may not be detected\n-\t  sometimes as pointed by Morus Walter.\n-\t* test\/errors\/charref1.xm result\/errors\/charref1.xml*: added the\n-\t  test in the regression suite.\n-\n-Thu Jun  3 18:38:27 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlschemas.c: small change to xmlSchemaValidateAttributes,\n-\t  also corrected typo on error code enum.\n-\t* include\/libxml\/xmlerror.h: corrected typo on schema error\n-\t  code enum\n-\n-Thu Jun  3 10:12:38 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlschemas.c: minor cosmetic changes, no change to logic.\n-\t* result\/schemas\/attruse_0_[12].err: regenerated\n-\t* globals.c: added a newline at end to make gcc happy\n-\n-Wed Jun  2 21:16:26 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c include\/libxml\/schemasInternals.h \n-\t  include\/libxml\/xmlerror.h: applied a patch from Kasimier Buchcik\n-\t  implementing attribute uses and wildcards.\n-\t* test\/schemas\/* result\/schemas\/*: added\/fixed a bunch of tests\n-\n-Wed Jun  2 18:15:51 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* globals.c xmlIO.c include\/libxml\/globals.h: applied patch from \n-\t  Rob Richards for custom I\/O BufferCreateFilenane fixes bug\n-\t  #143366\n-\n-Wed Jun 02 16:25:32 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: fixed problem with predicate evaluation on an\n-\t  empty nodeset (bug 143409)\n-\n-Wed Jun 02 11:26:41 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* testSAX.c: fixed problem with attribute listing (bug 142674)\n-\t  and added macro LIBXML_TEST_VERSION to assure xmlInitParser\n-\t  gets called (bug 142686)\n-\n-Sat May 29 21:35:52 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* test\/schemas\/date_0.xml xmlschemastypes.c: applied a patch from\n-\t  Charles Bozeman fixing a side effect in date handling\n-\n-Thu May 27 19:47:48 MDT 2004 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/tutorial\/xmltutorial.xml fix lack of cast in Xpath example\n-\t* doc\/tutorial\/*.html, xmltutorial.pdf rebuild html, pdf\n-\n-2004-05-25  Aleksey Sanin <aleksey@aleksey.com>\n-\n-\t* c14n.c: fixed c14n bug with serializing attribute namespaces\n-\n-Mon May 24 08:22:48 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: fixed to allow '+' in exponent of number\n-\t  (bug 143005)\n-\t* SAX2.c: fixed typo in last commit\n-\n-Sat May 22 09:08:24 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* SAX2.c: skipped call to xmlValidateNCName when compiling\n-\t  --with-minimum (bug 142917)\n-\n-Tue May 18 06:48:00 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: reverted the broken change.\n-\n-Mon May 17 23:07:15 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* NEWS doc\/*: updated the docs for 2.6.10\n-\n-Mon May 17 05:52:03 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in : releasing 2.6.10\n-\n-Sun May 16 23:12:35 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: avoid returning default namespace when searching\n-\t  from an attribute\n-\t* entities.c xmlwriter.c: reverse xmlEncodeSpecialChars() behaviour\n-\t  back to escaping \" since the normal serialization routines do not\n-\t  use it anymore, should close bug #134477 . Tried to make \n-\t  the writer avoid it too but it didn't work.\n-\n-Sun May 16 01:07:16 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/ChangeLog.awk doc\/ChangeLog.xsl: fixed escaping\n-\t  handling and added direct links to bugzilla report for\n-\t  bug numbers.\n-\n-Sun May 16 11:11:13 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* error.c: modified to assure proper user data is sent to\n-\t  structured error routine (bug 142598)\n-\n-Sun May 16 03:18:52 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: a couple of large static variable which should really\n-\t  not be declared as such cluttered the .bss section.\n-\n-Sun May 16 03:06:31 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/ChangeLog.awk: fixed a couple of problems when parsing\n-\t  libxslt ChangeLog\n-\n-Sat May 15 20:14:21 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/ChangeLog.awk doc\/ChangeLog.xsl: first steps of a good\n-\t  ChangeLog page generation. The awk should escape characters\n-\t  not okay in XML and the xslt should make links to functions\n-\t  or variables or bug reported in the entries.\n-\n-Sat May 15 14:57:40 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlsave.c include\/libxml\/xmlsave.h: start adding API for \n-\t  escaping customization.\n-\n-Sat May 15 12:38:17 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlsave.c: more xmlSave cleanup, optimization and refactoring\n-\n-Fri May 14 17:51:48 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c xmlsave.c: third pass at the escaping refactoring.\n-\n-Fri May 14 12:37:24 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* parser.c: enhanced the enhancement, fixed another couple of\n-\t  special cases.\n-\n-Fri May 14 11:48:33 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* parser.c: small enhancement to dtd handling of (a?)+ (bug 142487)\n-\n-Thu May 13 23:19:00 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c xmlsave.c include\/libxml\/xmlIO.h: second pass on escaping\n-\t  handling, start to looks better, need to be completed and added\n-\t  directly at the saving context level.\n-\n-Thu May 13 10:31:28 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c xmlsave.c include\/libxml\/xmlIO.h: first pass at refactoring\n-\t  the escape on save routines for better performances (less malloc)\n-\t  and more flexibility using the new saving context. Preliminary\n-\t  work, interface will change.\n-\n-Wed May 12 22:34:03 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlschemas.c: added code in xmlSchemaBuildAContentModel to handle\n-\t  element reference within the xs:all construct (bug 139897)\n-\n-Wed May 12 17:27:18 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xinclude.c: a little further fixing of fallback processing, this\n-\t  time for fallback with children (bug 139520).\n-\n-Wed May 12 08:21:33 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlschemas.c: added code in xmlSchemaBuildContentModel to\n-\t  allow ref in group definition (bug 134411).  Also fixed\n-\t  misc compilation warning messages.\n-\t* result\/schema\/group0_0_0, result\/schema\/group0_0_0.err:\n-\t  regenerated (now no error reported).\n-\n-Tue May 11 11:55:59 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: fix to the fix for #141864 from Paul Elseth  \n-\t* HTMLparser.c result\/HTML\/doc3.htm: apply fix from David Gatwood for\n-\t  #141195 about text between comments.\n-\n-Tue May 11 23:04:47 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlschemas.c, include\/libxml\/schemasInternals.h,\n-\t  include\/libxml\/xmlerror.h: Applied patches supplied by\n-\t  Kasimier Buchcik.\n-\t* test\/schemas\/po1_0.xml, test\/schemas\/po1_0.xsd:\n-\t  changed test to account for above patch.\n-\n-Tue May 11 09:06:53 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/tests\/tstLastError.py: better portability fix for f(*args),\n-\t  use apply(f, args) as Stéphane Bidoul suggested\n-\n-Mon May 10 15:49:22 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlregexp.c: enhanced xmlRegStateAddTrans to check if transition\n-\t  is already present and, if so, to ignore the request to add it.\n-\t  This has a very dramatic effect on memory requirements as well\n-\t  as efficiency.  It also fixes bug 141762.\n-\n-Sun May  9 20:40:59 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am python\/tests\/Makefile.am python\/tests\/tstLastError.py:\n-\t  applied patch from Ed Davis to allow \"make tests\" to work\n-\t  with Python 1.5\n-\n-Sun May  9 19:46:13 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlsave.c: apply fix for XHTML1 formatting from Nick Wellnhofer\n-\t  fixes bug #141266\n-\t* test\/xhtmlcomp result\/\/xhtmlcomp*: added the specific regression\n-\t  test\n-\n-Sun May  9 14:07:21 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: fix for a pedantic make check without make all request\n-\n-Sat May  8 22:56:22 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c xmlIO.c: fixing some problems in URI unescaping\n-\t  and output buffer opening, this should fix #141864\n-\n-Fri May  7 22:31:54 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c include\/libxml\/valid.h: fixes the use of 'list' as a parameter\n-\t* xmlIO.c include\/libxml\/xmlIO.h: added xmlPopInputCallback for\n-\t  Matt Sergeant\n-\n-Thu May  6 21:14:38 PDT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlregexp.c: enhanced the handling of subexpression ranges\n-\t  which have a minOccurs of 0 (bug 140478 again); cleaned up\n-\t  comments throughout the module.\n-\n-Tue May  4 00:52:16 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: adding a --maxmem option to check memory used.\n-\n-Sat May  1 01:08:44 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c xmlsave.c python\/generator.py python\/libxml.c: Fixed\n-\t  bug #141529 i.e. various problems when building with --without-html\n-\n-Fri Apr 30 18:12:31 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c xmlreader.c: fixing bug #141384 where the reader didn't\n-\t  call the deregistering functions. Also added the check to\n-\t  xmllint --stream --chkregister .\n-\n-Fri Apr 30 08:57:47 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/Makefile.msvc: applied a second patch from Mark Vakoc for\n-\t  regression tests on Windows\n-\n-Thu Apr 29 21:47:23 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: never commit without running make tests first !\n-\n-Thu Apr 29 20:15:20 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: fix a nasty problem with reading over the end\n-\t* xmlsave.c: fix a reported memory leak apparently\n-\n-Thu Apr 29 17:05:00 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/Makefile.msvc: patch from Mark Vakoc for regression tests\n-\t  on Windows.\n-\t* xpath.c: the NaN problem also shows up on Borland\n-\n-Mon Apr 26 23:37:12 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlregexp.c: enhanced xmlFARegExec range evaluation for min\n-\t  occurs 0 problems - fixes bug 140478.\n-\n-Thu Apr 22 09:12:47 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* rngparser.c: tiny path fixes the \"xmlConvertCRNGFile\" function name\n-\t  from Kasimier Buchcik\n-\t* xmlschemas.c: recursive xs:extension fix from taihei goi\n-\n-Wed Apr 21 00:19:29 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: small buffer resizing improvement from Morten Welinder\n-\t  closes #140629\n-\n-Tue Apr 20 23:40:14 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: last version of the fix for MSC version 1200\n-\n-Tue Apr 20 19:40:37 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: killing the strncmp vs. memcmp controversy and #140593\n-\n-Tue Apr 20 13:27:06 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/SAX2.h: Kasimier Buchcik pointed out some \n-\t  inexistent functions, cleaned them out.\n-\n-Tue Apr 20 11:42:50 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c: Johnson Cameron pointed out that\n-\t  initGenericErrorDefaultFunc() was really wrong.\n-\t* xmlreader.c include\/libxml\/xmlreader.h: xmlTextReaderMode enum\n-\t  must be made public, added some missing comments on the XMLReader\n-\t  header.\n-\t* c14n.c: Alexsey fixed C14N bug with processing namespaces\n-\t  from attributes\n-\n-Mon Apr 19 23:27:46 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fixed a stupid () error + Mark name.\n-\n-Sun Apr 18 23:45:46 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: preparing 2.6.9 release\n-\t* doc\/* News: updated and rebuilt the docs\n-\n-Sun Apr 18 22:51:43 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: relaxed id() to not check that the name(s) passed\n-\t  are actually NCName, decided this in agreement with Aleksey Sanin\n-\t  since existing specs like Visa3D broke that conformance checking\n-\t  and other tools seems to not implement it sigh...\n-\t* SAX2.c: check attribute decls for xml:id and the value is an\n-\t  NCName.\n-\t* test\/xmlid\/id_err* result\/xmlid\/id_err*: added error testing\n-\n-Sun Apr 18 21:46:17 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: work around Microsoft compiler NaN bug raise reported\n-\t  by Mark Vakoc\n-\t* xmlschemas.c include\/libxml\/schemasInternals.h \n-\t  include\/libxml\/xmlerror.h: fixed a recursive extension schemas\n-\t  compilation error raised by taihei goi\n-\n-Sun Apr 18 16:57:02 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in: keep the ChangeLog compressed \n-\t* xmlreader.c: fix a segfault when using Close()\n-\t* python\/tests\/Makefile.am python\/tests\/reader8.py: test for\n-\t  the Close() reader API.\n-\n-Sat Apr 17 22:42:13 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlschemas.c, xmlwriter.c, doc\/examples\/parse4.c,\n-\t  doc\/examples\/io2.c: minor warning cleanup (no change to logic)\n-\t* xinclude: fixed return value for internal function\n-\t  xmlXIncludeLoadFallback (now always 0 or -1)\n-\n-Sat Apr 17 21:32:32 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* valid.c: small enhancement to fix bug 139791\n-\n-Fri Apr 16 18:44:47 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c include\/libxml\/schemasInternals.h\n-\t  include\/libxml\/xmlerror.h: applied patches from Kasimier Buchcik\n-\t  for the attribute use support\n-\t* test\/schemas\/attruse* result\/schemas\/attruse*: added the\n-\t  tests to the regression suite.\n-\n-Fri Apr 16 18:22:25 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlsave.c: move the TODO as comments as the function while not\n-\t  finished are usable as-is\n-\t* xmlschemas.c include\/libxml\/xmlerror.h: patch from Kasimier Buchcik\n-\t  implementing union\n-\t* test\/schemas\/union_0_0.x* result\/schemas\/union_0_0*: added example\n-\t* python\/Makefile.am: applied fix from Mike Hommey\n-\n-Fri Apr 16 23:58:42 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* parser.c: fixed problem with detecting external dtd\n-\t  encoding (bug 135229).\n-\t* Makefile.am: minor change to test label\n-\n-Fri Apr 16 16:09:31 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xinclude.c: fixed problem causing duplicate fallback\n-\t  execution (bug 139520)\n-\t* test\/XInclude\/docs\/fallback2.xml result\/XInclude\/fallback2.*:\n-\t  added testcase\n-\n-Fri Apr  9 23:49:37 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c include\/libxml\/tree.h: adding xml:id draft support\n-\t* Makefile.am test\/xmlid\/id_tst* result\/xmlid\/id_tst*: adding\n-\t  4 first regression tests\n-\n-Fri Apr  9 11:56:08 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in: fixing Red Hat bug #120482 , libxml2-python\n-\t  should depend on the version of python used to compile it.\n-\n-Mon Apr  5 09:07:24 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: applied patch from James Bursa, frameset should\n-\t  close head.\n-\n-Fri Apr  2 22:02:24 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* relaxng.c: fixed problem in xmlRelaxNGCompareNameClasses\n-\t  which was causing check-relaxng-test-suite.py test 351 to fail.\n-\n-Fri Apr  2 17:03:48 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* nanohttp.c: implemented fix for M$ IIS redirect provided\n-\t  by Ian Hummel\n-\t* relaxng.c: fixed problem with notAllowed compilation\n-\t  (bug 138793)\n-\n-Thu Apr  1 22:07:52 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: fix for xmlUriEscape on \"http:\/\/user@somewhere.com\"\n-\t  from Mark Vakoc.\n-\n-2004-04-01  Johan Dahlin  <johan@gnome.org>\n-\n-\t* python\/.cvsignore: Add generated files, to make cvs silent.\n-\n-Thu Apr  1 12:41:36 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: small signed-ness patch from Steve Little\n-\n-Wed Mar 31 17:47:28 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: patched a bug in parsing production 1 and 2 of\n-\t  xmlschemas regexp that William pointed out while working on\n-\t  #134120\n-\t* test\/regexp\/branch result\/regexp\/branch: added a specific\n-\t  regression test\n-\n-Wed Mar 31 09:50:32 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* Makefile.am: added PYTHONPATH to python tests for Schemas\n-\t  and RelaxNG\n-\t* test\/xsdtest\/xsdtestsuite.xml: added testfile for\n-\t  SchemasPythonTests\n-\n-Mon Mar 29 16:56:49 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/examples\/examples.xsl doc\/examples\/index.html: added\n-\t  information about compiling on Unix\n-\n-Mon Mar 29 14:18:12 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: fixes the comments for xmlCatalogDump and xmlDumpACatalog\n-\t* doc\/*: rebuilt to update\n-\n-Sun Mar 28 18:11:41 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlsave.c: optimize indentation based on the new context\n-\n-Sun Mar 28 14:17:10 CEST 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/examples\/xpath2.c doc\/examples\/xpath2.res: handle and explain\n-\t  a very tricky problem when modifying the tree based on an XPath\n-\t  result query.\n-\n-Sat Mar 27 09:56:14 PST 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* relaxng.c: fixed problem with IS_COMPILABLE flag\n-\t  (bug 130216)\n-\n-Fri Mar 26 18:28:32 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: applied patch from Dave Beckett to correct line number\n-\t  errors when using push with CDATA\n-\n-Fri Mar 26 14:53:58 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/examples\/xpath1.c: added a test template\n-\t* doc\/examples\/xpath2.c doc\/examples\/xpath2.res doc\/examples\/*:\n-\t  added a new example, and make valgrind target \n-\n-Fri Mar 26 11:47:29 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: apply fix for #136693\n-\n-Thu Mar 25 20:21:01 MST 2004 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/examples\/io2.c\n-\t* doc\/examples\/io2.res\n-\tadd xmlDocDumpMemory example in response to mailing list FAQ\n-\t(rebuilt xml and html also)\n-\n-Thu Mar 25 10:33:05 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c testXPath.c xmllint.c xmlschemastypes.c: applied\n-\t  patch from Mark Vakoc avoiding using xmlParse* option and use\n-\t  xmlRead* instead\n-\t* win32\/Makefile.bcb: patch to Borland C++ builder from Eric Zurcher\n-\t  to avoid problems with some pathnames.\n-\n-Tue Mar 23 12:35:08 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in doc\/* News: preparing 2.6.8 release, updated and rebuilt\n-\t  the docs.\n-\t* Makefile.am: use valgring for the new Python based regression tests\n-\n-Mon Mar 22 20:07:27 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: remove a memory leak on schemas type facets.\n-\t* check-relaxng-test-suite.py check-relaxng-test-suite2.py\n-\t  check-xsddata-test-suite.py: reduce verbosity\n-\t* configure.in Makefile.am: incorporated the Python regressions\n-\t  tests for Relax-NG and Schemas Datatype to \"make tests\"\n-\n-Mon Mar 22 16:16:18 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlwriter.c include\/libxml\/xmlwriter.h doc\/* : applied patch from\n-\t  Alfred Mickautsch for better DTD support.\n-\t* SAX2.c HTMLparser.c parser.c xinclude.c xmllint.c xmlreader.c\n-\t  xmlschemas.c: fixed bug #137867 i.e. fixed properly the way\n-\t  reference counting is handled in the XML parser which had the\n-\t  side effect of removing a lot of hazardous cruft added to try\n-\t  to fix the problems associated as they popped up.\n-\t* xmlIO.c: FILE * close fixup for stderr\/stdout\n-\n-Sun Mar 21 19:19:41 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* relaxng.c: added an error message when an element is not\n-\t  found within a <choice> (bug 126093)\n-\n-Sat Mar 20 22:25:18 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlregexp.c: enhanced the logic of parsing char groups to\n-\t  better handle initial or ending '-' (bug 135972)\n-\n-Sat Mar 20 19:26:03 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* relaxng.c: added check for external reference in \n-\t  xmlRelaxNGGetElements (bug 137718)\n-\t* test\/relaxng\/rngbug-001.*, result\/relaxng\/rngbug-001*: added\n-\t  regression test for above\n-\n-Wed Mar 17 16:37:22 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* nanohttp.c: added a close for the local file descriptor\n-\t  (bug 137474)\n-\n-Mon Mar 15 15:46:59 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlsave.c: switched the output routines to use the new context.\n-\n-Mon Mar 15 10:37:18 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* relaxng.c: enhanced to ignore XML_XINCLUDE_START and XML_XINCLUDE_END\n-\t  nodes (bug 137153)\n-\n-Sun Mar 14 13:19:20 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: applied patch from John Belmonte for anyURI.\n-\n-Wed Mar 10 17:22:48 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fix bug reported by Holger Rauch\n-\t* test\/att8 result\/noent\/att8 result\/att8 result\/att8.rdr\n-\t  result\/att8.sax: added the test to th regression suite\n-\n-Wed Mar 10 19:42:22 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/search.php: Minor change for later version of php requiring\n-\t  $HTTP_GET_VARS.\n-\n-Wed Mar 10 00:12:31 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* tree.c: Changed the flag to xmlDocCopyNode (and similar routines),\n-\t  previously used only for recursion, to use a value of '2' to\n-\t  indicate copy properties & namespaces, but not children.\n-\t* xinclude.c: changed the handling of ranges to use the above new\n-\t  facility.  Fixes Bug 134268.\n-\n-Tue Mar  9 18:48:51 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* win32\/Makefile.bcb, win32\/Makefile.mingw, win32\/Makefile.msvc:\n-\t  added new module xmlsave with patch supplied by Eric Zurcher\n-\t  (second attempt - don't know what happened to the first one!)\n-\n-Tue Mar  9 09:59:25 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c python\/libxml.py: applied patch from Anthony Carrico\n-\t  providing Python bindings for the Canonicalization C14N support.\n-\n-Mon Mar  8 11:12:23 CET 2004 Hagen Moebius <hagen.moebius@starschiffchen.de>\n-\n-\t* .cvsignore and python\/.cvsignore patched\n-\n-Mon Mar  8 22:33:14 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xinclude.c: enhanced to assure that if xpointer is called\n-\t  for a document, the XML_PARSE_NOENT flag is set before parsing\n-\t  the included document so that entities will automatically get\n-\t  taken care of.\n-\t* xpointer.c: corrected code so that, if an XML_ENTITY_REF node\n-\t  is encountered, it will log it and not crash (bug 135713)\n-\n-Sun Mar  7 19:03:48 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xinclude.c: modified to make sub-includes inherit the\n-\t  parse flags from the parent document (bug 132597)\n-\n-Fri Mar  5 01:13:22 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: QName handling fixes for the XML Schemas\n-\t  support from Adam Dickmeiss\n-\t* test\/schemas\/po1_0.xsd: also fix the schemas\n-\t* test\/schemas\/ns[12]* result\/schemas\/ns[12]*: added the specific\n-\t  regression tests\n-\n-Thu Mar  4 23:03:02 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in doc\/Makefile.am include\/libxml\/Makefile.am:\n-\t  paalied patch from Julio M. Merino Vidal fixing bug #134751\n-\t  to fix --with-html-dir option.\n-\t* doc\/*: rebuilt fully the docs \n-\t* doc\/html\/libxml-xmlsave.html: new file from new header.\n-\n-Thu Mar  4 16:57:50 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c testHTML.c tree.c doc\/examples\/*.c\n-\t  include\/libxml\/xmlsave.h: fixing compilation bug with some options\n-\t  disabled as well as --with-minimum should fix #134695\n-\n-Thu Mar  4 15:00:45 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlcatalog.c: allow fallback to URI lookup when SYSTEM fails,\n-\t  should close #134092\n-\n-Thu Mar  4 14:39:38 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am tree.c xmlsave.c include\/libxml\/xmlsave.h: committing\n-\t  the new xmlsave module before the actual big code change.\n-\n-Thu Mar  4 12:38:53 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: applied patch from Adam Dickmeiss for mixed content\n-\t* test\/schemas\/mixed* result\/schemas\/mixed*: added his regression\n-\t  tests too.\n-\n-Mon Mar  1 15:22:06 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testSAX.c: fix a compilation problem about a missing timb include\n-\n-Sat Feb 28 22:35:32 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* testSAX.c: small enhancement to prevent trying to print\n-\t  strings with null pointers (caused \"make tests\" errors on\n-\t  HP-UX)\n-\n-Thu Feb 26 20:19:40 MST 2004 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmllint.xml\n-\t* doc\/xmllint.1\n-\t* doc\/xmllint.html\n-\t* doc\/xmlcatalog_man.xml\n-\t* doc\/xmlcatalog.1\n-\t* doc\/xmlcatalog_man.html\n-\tapplying patch from Mike Hommey to clarify XML_CATALOG_FILES\n-\tuse\n-\n-Thu Feb 26 23:47:43 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: patch for cross-compilation to Windows from\n-\t  Christophe de VIENNE.\n-\n-Thu Feb 26 18:52:11 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/*.html, doc\/html\/*.html: regenerated docs using older\n-\t  version of xsltproc pending resolution of AVT problem\n-\n-Thu Feb 26 10:56:29 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: applied patch from Charles Bozeman to not use\n-\t  the system xmllint.\n-\n-Wed Feb 25 18:07:05 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlexports.h: applied patch from Roland Schwingel\n-\t  for MingW\n-\n-Wed Feb 25 13:57:25 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am catalog.c configure.in: applied a cleanup patch\n-\t  from Peter Breitenlohner\n-\t* tree.c: removed a doc build warning by fixing a param comment\n-\t* doc\/* : rebuilt the docs\n-\n-Wed Feb 25 13:33:07 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c HTMLparser.c: avoid ID error message if using\n-\t  HTML_PARSE_NOERROR should fix #130762\n-\n-Wed Feb 25 12:50:53 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c relaxng.c valid.c xinclude.c xmllint.c xmlreader.c:\n-\t  fixing compilation and link option when configuring with\n-\t  --without-valid should fix #135309\n-\n-Wed Feb 25 11:36:06 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: fixed the main issues reported by Peter Breitenlohner\n-\t* parser.c: cleanup\n-\t* valid.c: speedup patch from Petr Pajas\n-\n-Wed Feb 25 16:07:14 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: fixed a memory leak (xmlXPathLangFunction) reported\n-\t  on the list by Mike Hommey\n-\n-Mon Feb 23 17:28:34 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/* NEWS configure.in: preparing 2.6.7 release, updated and\n-\t  rebuilt the documentation.\n-\n-Mon Feb 23 11:52:12 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/tests\/*.py: applied patch from Malcolm Tredinnick\n-\t  to avoid tabs in python sources, should fix #135095\n-\n-Sun Feb 22 23:16:23 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testSAX.c: add --timing option\n-\t* relaxng.c: use the psvi field of the nodes instead of _private\n-\t  which may be used for other purposes.\n-\n-Sat Feb 21 16:57:48 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: small patch to try to fix a warning with Sun One compiler\n-\n-Sat Feb 21 16:22:35 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: small patch removing a warning with MS compiler.\n-\n-Sat Feb 21 13:52:30 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c: added \"relaxng\" option to the debugging shell\n-\t* Makefile.am test\/errors\/* result\/errors\/*: some regression tests\n-\t  for some error tests cases.\n-\n-Fri Feb 20 09:56:47 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: xmlAttrSerializeTxtContent don't segfault if NULL\n-\t  is passed.\n-\t* test\/att7 result\/\/att7*: adding an old regression test\n-\t  laying around on my laptop\n-\n-Thu Feb 19 17:33:36 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: fixed xmllint --memory --stream memory consumption\n-\t  on large file by using xmlParserInputBufferCreateStatic() with\n-\t  the mmap'ed file \n-\n-Thu Feb 19 13:56:53 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: some clarification in xmlDocDumpMemory() documentation\n-\t* xmllint.c: fixed xmllint --stream --timing to get timings back\n-\n-Wed Feb 18 15:20:42 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed a problem in push mode when attribute contains\n-\t  unescaped '>' characters, fixes bug #134566\n-\t* test\/att6 result\/\/att6*: added the test to the regression suite\n-\n-Tue Feb 17 17:26:31 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: removing a non-linear behaviour from ID\/IDREF raised\n-\t  by Petr Pajas. Call xmlListAppend instead of xmlListInsert in\n-\t  xmlAddRef\n-\n-Tue Feb 17 13:27:27 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/tests\/indexes.py python\/tests\/reader.py: indicated\n-\t  encoding of the test file, needed for python 2.3\n-\n-Tue Feb 17 21:08:11 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: fixed problem with numbers having > 19\n-\t  fractional places (bug 133921)\n-\n-Tue Feb 17 12:47:20 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: applied optimization patch from Petr Pajas\n-\n-Tue Feb 17 12:39:08 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlwriter.c include\/libxml\/xmlwriter.h: applied update\n-\t  from Alfred Mickautsch and the added patch from Lucas Brasilino\n-\n-Sun Feb 15 12:01:30 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* benchmark.png index.html xml.html: updating the benchmark\n-\t  graph and using a PNG instead of a GIF\n-\t* xmlreader.c: updated the TODO\n-\n-Sat Feb 14 18:55:40 MST 2004 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/tutorial\/xmltutorial.xml\n-\t* doc\/tutorial\/xmltutorial.pdf\n-\t* doc\/tutorial\/*.html\n-\tFix bug in XPath example in the tutorial, thanks to Carlos, whose\n-\tlast name I don't know, for pointing this out\n-\n-Thu Feb 12 16:28:12 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* NEWS configure.in: preparing release of 2.6.6\n-\t* doc\/*: updated the docs and rebuilt them\n-\n-Thu Feb 12 13:41:16 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: fixing bug #132930 with the provided patch, a bit\n-\t  suspicious about it but this is fairly contained and regression\n-\t  tests still passes.\n-\t* test\/schemas\/all1* result\/schemas\/all1*: added the test to\n-\t  the regression suite.\n-\n-Thu Feb 12 12:54:26 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed bug #132575 about finding the end of the\n-\t  internal subset in push mode.\n-\t* test\/intsubset.xml result\/intsubset.xml* result\/noent\/intsubset.xml:\n-\t  added the test to the regression suite\n-\n-Wed Feb 11 14:19:31 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c xmlIO.c encoding.c include\/libxml\/parser.h\n-\t  include\/libxml\/xmlIO.h: added xmlByteConsumed() interface\n-\t* doc\/*: updated the benchmark rebuilt the docs\n-\t* python\/tests\/Makefile.am python\/tests\/indexes.py: added a\n-\t  specific regression test for xmlByteConsumed()\n-\t* include\/libxml\/encoding.h rngparser.c tree.c: small cleanups\n-\n-Wed Feb 11 08:13:58 HKT 2004 William Brack <wbrack@mmm.com.hk\n-\n-\t* tree.c: fixed missing output of internal DTD param entities when\n-\t  nothing else present in DTD (bug 134052)\n-\n-Tue Feb 10 19:24:38 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* encoding.c: applied patch supplied by Christophe Dubach\n-\t  to fix problem with --with-minimum configuration\n-\t  (bug 133773)\n-\t* nanoftp.c: fixed potential buffer overflow problem,\n-\t  similar to fix just applied to nanohttp.c.\n-\n-Mon Feb  9 18:40:21 CET 2004 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* nanohttp.c: fixed the fix for the buffer overflow, thanx\n-\t  William :-)\n-\n-Mon Feb  9 22:37:14 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* acinclude.m4, configure.in: fixed problem concerning\n-\t  determining SOCKLEN_T as pointed out by Daniel Richard G.\n-\t  on the mailing list\n-\n-Mon Feb  9 15:31:24 CET 2004 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* nanohttp.c: fixed buffer overflow reported by Yuuichi Teranishi\n-\n-Mon Feb  9 13:45:59 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: small patch from Philip Ludlam to avoid warnings.\n-\n-Mon Feb  9 13:41:47 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: applied a small patch from Alfred Mickautsch\n-\t  to avoid an out of bound error in isolat1ToUTF8()\n-\n-Mon Feb  9 13:35:50 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: remove the warning on the 2001 namespace\n-\t* parser.c parserInternals.c xpath.c: remove some warnings\n-\t  when compiling with MSVC6\n-\t* nanohttp.c: applied a patch when using _WINSOCKAPI_\n-\n-Sun Feb  8 12:09:55 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xinclude.c: added a small hack to fix interference between\n-\t  my fixes for bugs 132585 and 132588.\n-\t* python\/libxml.c: fixed problem with serialization of namespace\n-\t  reported on the mailing list by Anthony Carrico\n-\n-Sat Feb  7 16:53:11 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xinclude.c: fixed problem with function xmlXIncludeCopyRange\n-\t  (bug 133686).\n-\n-Fri Feb  6 21:03:41 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlwriter.c: fixed problem with return value of\n-\t  xmlTextWriterWriteIndent() (bug 133297)\n-\n-Fri Feb  6 19:07:04 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xinclude.c: changed coding to output good XIncludes when\n-\t  one or more bad ones are present (bug 132588)\n-\n-Fri Feb  6 17:34:21 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xinclude.c: corrected handling of empty fallback condition\n-\t  (bug 132585)\n-\n-Fri Feb  6 15:28:36 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* HTMLparser.c: added initialisation for ctxt->vctxt\n-\t  in HTMLInitParser (bug 133127)\n-\t* valid.c: minor cosmetic change (removed ATTRIBUTE_UNUSED\n-\t  from several function params)\n-\n-Tue Feb  3 16:48:57 PST 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xinclude.c: fixed problem regarding freeing of dictionary\n-\t  when there are errors within an XInclude file (bug 133106).\n-\t  Thanks to Oleg Paraschenko for the assistance.\n-\n-Tue Feb  3 09:53:18 PST 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlschemastypes.c: fixed validation of maxLength with no\n-\t  content using patch submitted by Eric Haszlakiewicz\n-\t  (bug 133259)\n-\n-Tue Feb  3 09:21:09 CET 2004 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* include\/libxml\/xmlreader.h include\/libxml\/xmlmemory.h: added\n-\t  calling convention to the public function prototypes (rep by\n-\t  Cameron Johnson)\n-\t* include\/libxml\/xmlexports.h: fixed mingw+msys compilation\n-\t  (rep by Mikhail Grushinskiy)\n-\n-Mon Feb  2 20:22:18 PST 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlwriter.c: enhanced output indenting (bug 133264)\n-\n-Mon Feb  2 16:13:33 PST 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlreader.c, include\/libxml\/xmlreader.h: applied patch from\n-\t  Steve Ball to provide structured error reports.\n-\n-Sun Feb  1 01:48:14 PST 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* tree.c, include\/libxml\/tree.h: moved serialization of\n-\t  attribute text data (xmlSerializeContent) into a separate\n-\t  routine (xmlSerializeTxtContent) so it can be used by xmlwriter.c\n-\t* xmlwriter.c: changed handling of attribute string to use the\n-\t  routine above (fixed bug 131548)\n-\n-Sat Jan 31 08:22:02 MST 2004 John Fleck <jfleck@inkstain.net\n-\n-\t* doc\/examples\/reader1.c, reader2.c, reader3.c\n-\t* doc\/examples\/examples.xml\n-\t* doc\/examples\/*.html\n-\tadd note that reader examples need libmxl2 > 2.6, rebuild\n-\thtml - this time doing it correctly :-)\n-\n-Fri Jan 30 20:45:36 MST 2004 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/examples\/examples.xml\n-\t* doc\/examples\/*.html\n-\tadd note that reader examples need libmxl2 > 2.6, rebuild\n-\thtml\n-\n-Thu Jan 29 23:51:48 PST 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: added (void *) type override to prevent\n-\t  warning on Solaris (Bug 132671)\n-\n-Wed Jan 28 07:20:37 MST 2004 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/examples\/Makefile.am\n-\tper Jan. 15 email to the list from oliverst, the index.html\n-\tfile from this directory wasn't making it into the tarball\n-\n-Mon Jan 26 18:01:00 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* acinclude.m4: applied fix from Alexander Winston for a problem\n-\t  related to automake-1.8 , c.f. #132513 and #129861\n-\n-Mon Jan 26 12:53:11 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/examples\/index.py: don't rely on . being on the path for\n-\t  make tests, should keep Mr. Crozat quiet until next time...\n-\n-Sun Jan 25 21:45:03 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in NEWS doc\/*: preparing release 2.6.5, rebuilt the\n-\t  docs, checked rngparser stuff does not end up in the tarball\n-\n-Sun Jan 25 20:59:20 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c: applied patch from Frederic Peters\n-\t  fixing the wrong arg order in xpath callback in bug #130980\n-\n-Sun Jan 25 20:52:09 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: fixing #130453 XInclude element with no href attribute\n-\t* relaxng.c rngparser.c include\/libxml2\/relaxng.h: fully integrating \n-\t  the compact syntax will require more work, postponed for the\n-\t  2.6.5 release.\n-\n-Sat Jan 24 09:30:22 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/schemasInternals.h xmlschemas.c: applied patch from\n-\t  Steve Ball to avoid a double-free.\n-\n-Fri Jan 23 14:03:21 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/examples\/*: added io1.c an example ox xmlIO usage and io1.res\n-\t  test result, fixed a awful lot of memory leaks showing up in\n-\t  testWriter.c, changed the examples and the Makefiles to test\n-\t  memory leaks.\n-\t* xmlwriter.c: fixed a memory leak\n-\t* Makefile.am: run the doc\/examples regression tests as part of\n-\t  make tests\n-\t* xpath.c include\/libxml\/xpath.h: added xmlXPathCtxtCompile() to\n-\t  compile an XPath expression within a context, currently the goal\n-\t  is to be able to reuse the XSLT stylesheet dictionary, but this\n-\t  opens the door to others possible optimizations.\n-\t* dict.c include\/libxml\/dict.h: added xmlDictCreateSub() which allows\n-\t  to build a new dictionary based on another read-only dictionary.\n-\t  This is needed for XSLT to keep the stylesheet dictionary read-only\n-\t  while being able to reuse the strings for the transformation\n-\t  dictionary.\n-\t* xinclude.c: fixed a dictionary reference counting problem occurring\n-\t  when document parsing failed.\n-\t* testSAX.c: adding option --repeat for timing 100times the parsing\n-\t* doc\/* : rebuilt all the docs\n-\n-Thu Jan 22 14:17:05 2004  Aleksey Sanin  <aleksey@aleksey.com>\n-\n-\t* xmlmemory.c: make xmlReallocLoc() accept NULL pointer\n-\n-Thu Jan 22 08:26:20 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: applied patch from John Belmonte for\n-\t  normalizedString datatype support.\n-\n-Thu Jan 22 10:43:22 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: fixed problem with union when last() is used\n-\t  in predicate (bug #131971)\n-\t* xpointer.c: minor change to comment for doc generation\n-\n-Wed Jan 21 17:03:17 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed bug #131745 raised by Shaun McCance with the\n-\t  suggested patch\n-\n-Wed Jan 21 10:59:55 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlwriter.c: applied patch from Alfred Mickautsch fixing a memory\n-\t  leak reported on the list.\n-\n-Thu Jan 15 00:48:46 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/tests\/tstLastError.py: applied\n-\t  patch from Stéphane Bidoul to add enums to the Python bindings.\n-\n-Tue Jan 13 21:50:05 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testHTML.c: another small patch from Mark Vakoc\n-\n-Tue Jan 13 21:39:58 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c relaxng.c testRelax.c testSchemas.c: applied\n-\t  patch from Mark Vakoc to not use SAX1 unless necessary.\n-\n-Mon Jan 12 17:22:57 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* dict.c parser.c xmlstring.c: some parser optimizations,\n-\t  xmllint --memory --timing --repeat --stream .\/db10000.xml\n-\t  went down from 16.5 secs to 15.5 secs.\n-\n-Thu Jan  8 17:57:50 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: removed a memory leak remaining from the switch\n-\t  to a dictionary for string allocations c.f. #130891\n-\n-Thu Jan  8 17:48:46 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: fixing some problem if configured --without-xinclude\n-\t  c.f. #130902\n-\n-Thu Jan  8 17:42:48 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: changed AC_OUTPUT() macro to avoid a cygwin problem\n-\t  c.f. #130896\n-\n-Thu Jan  8 00:36:00 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/Makefile.bcb win32\/Makefile.mingw win32\/Makefile.msvc:\n-\t  applying patch from Mark Vakoc for Windows\n-\t* doc\/catalog.html doc\/encoding.html doc\/xml.html: applied doc\n-\t  fixes from Sven Zimmerman\n-\n-Tue Jan  6 23:51:46 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml2-python-api.xml python\/libxml_wrap.h python\/types.c\n-\t  python\/tests\/Makefile.am python\/tests\/tstLastError.py: applied \n-\t  patch from Stéphane Bidoul for structured error handling from\n-\t  python, and the associated test\n-\n-Tue Jan  6 23:18:11 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* configure.in: fixed Bug130593\n-\t* xmlwriter.c: fixed compilation warning\n-\n-Tue Jan  6 15:15:23 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlstring.h: fixed the comment in the header\n-\t* doc\/*: rebuilt the docs\n-\n-Tue Jan  6 19:40:04 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* encoding.c, parser.c, xmlstring.c, Makefile.am,\n-\t  include\/libxml\/Makefile.am, include\/libxml\/catalog.c,\n-\t  include\/libxml\/chvalid.h, include\/libxml\/encoding.h,\n-\t  include\/libxml\/parser.h, include\/libxml\/relaxng.h,\n-\t  include\/libxml\/tree.h, include\/libxml\/xmlwriter.h,\n-\t  include\/libxml\/xmlstring.h:\n-\t  moved string and UTF8 routines out of parser.c and encoding.c\n-\t  into a new module xmlstring.c with include file\n-\t  include\/libxml\/xmlstring.h mostly using patches from Reid\n-\t  Spencer.  Since xmlChar now defined in xmlstring.h, several\n-\t  include files needed to have a #include added for safety.\n-\t* doc\/apibuild.py: added some additional sorting for various\n-\t  references displayed in the APIxxx.html files.  Rebuilt the\n-\t  docs, and also added new file for xmlstring module.\n-\t* configure.in: small addition to help my testing; no effect on\n-\t  normal usage.\n-\t* doc\/search.php: added $_GET[query] so that persistent globals\n-\t  can be disabled (for recent versions of PHP)\n-\n-Mon Jan  5 20:47:07 MST 2004 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/tutorial\/customfo.xsl\n-\t* doc\/tutorial\/customhtml.xsl\n-\tupdate custom tutorial-building stylesheets in preparation\n-\tfor tutorial update\n-\n-Tue Jan  6 00:10:33 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* rngparser.c: committing the compact relax ng parser. It's not\n-\t  completely finished, it's not integrated but I want to save the\n-\t  current state\n-\n-Mon Jan  5 22:22:48 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/apibuild.py, doc\/APIconstructors.html, doc\/libxml2-refs.xml,\n-\t  win32\/libxml2.def.src: fixed apibuild.py's generation of\n-\t  \"constructors\" to be in alphabetical order (instead of previous\n-\t  random sequence); regenerated resulting files.\n-\n-Mon Jan  5 14:03:59 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlwriter.c: applied patch from Lucas Brasilino fixing an indent\n-\t  problem.\n-\n-Sun Jan  4 18:54:29 MST 2004 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/newapi.xsl: change background color of function\n-\tdeclaration to improve readability\n-\t* doc\/*: rebuild docs with new stylesheet\n-\n-Sun Jan  4 22:45:14 HKT 2004 William Brack <wbarck@mmm.com.hk>\n-\n-\t* parser.c, include\/libxml\/parser.h: added a routine\n-\t  xmlStrncatNew to create a new string from 2 frags.\n-\t* tree.c: added code to check if node content is from\n-\t  dictionary before trying to change or concatenate.\n-\n-Sun Jan  4 08:57:51 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlmemory.c: applied suggestion from Miloslav Trmac (see\n-\t  Bug 130419) and eliminated xmlInitMemoryDone.  More\n-\t  improvement needed.\n-\t* xml2-config.in: added an additional flag (--exec-prefix) to\n-\t  allow library directory to be different from include directory\n-\t  (Bug 129558).\n-\n-Fri Jan  2 21:22:18 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c: applied patch from Stéphane Bidoul for structured error\n-\t  reporting.\n-\n-Fri Jan  2 21:03:17 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlwriter.h xmlwriter.c: applied the patch from\n-\t  Lucas Brasilino to add indentation support to xmlWriter\n-\n-Fri Jan  2 22:58:29 HKT 2004 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xinclude.c: fixed problem with \"recursive\" include (fallback\n-\t  contains another include - Bug 129969)\n-\n-Fri Jan  2 11:40:06 CET 2004 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c: found and fixed a bug misallocating some non\n-\t  blank text node strings from the dictionary.\n-\t* xmlmemory.c: fixed a problem with the memory debug mutex\n-\t  release.\n-\n-Wed Dec 31 22:02:37 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xinclude.c: fixed problem caused by wrong dictionary\n-\t  reference count, reported on the list by Christopher\n-\t  Grayce.\n-\n-Wed Dec 31 15:55:55 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* python\/generator.py, python\/libxml2class.txt: fixed problem\n-\t  pointed out by Stéphane Bidoul on the list.\n-\t* xinclude.c, xpointer.c, xpath.c, include\/libxml\/xpointer.h:\n-\t  completed modifications required to fix Bug 129967 (at last!).\n-\t  Now wait to see how long before further trouble...\n-\n-Tue Dec 30 16:26:13 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* parser.c, xmlmemory.c, include\/libxml\/xmlmemory.h: Fixed\n-\t  memory leak reported by Dave Beckett\n-\t* xmlschemas.c: Removed spurious comment reported on the mailing\n-\t  list\n-\t* xinclude.c, xpath.c, xpointer.c, libxml\/include\/xpointer.h:\n-\t  Further work on Bug 129967 concerning xpointer range handling\n-\t  and range-to function; much better, but still not complete\n-\n-Mon Dec 29 18:08:05 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: xmlValidateElement could crash for element holding a \n-\t  namespace declaration but not in a namespace. Oliver Fischer \n-\t  provided the example.\n-\n-Mon Dec 29 11:29:31 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: issue validation status on stderr, not stdout as suggested\n-\t  by Pawel Palucha\n-\t* result\/relaxng\/*: this change slightly all the output from RNG \n-\t  regressions.\n-\n-Mon Dec 28 10:47:32 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlschemas.c: edited a couple of comments in accordance with\n-\t  posting on the mailing list (no logic change)\n-\t* xpointer.c: working on Bug 129967, added check for NULL\n-\t  nodeset to prevent crash.  Further work required.\n-\t* xpath.c: working on Bug 129967, added code to handle\n-\t  XPATH_LOCATIONSET in RANGETO code, also added code to\n-\t  handle it in xmlXPathEvaluatePredicateResult.  Further\n-\t  work required.\n-\n-Sat Dec 27 12:32:58 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlschemas.c: added tests for xs:all to assure minOccurs\n-\t  and maxOccurs <= 1 (Bug 130020)\n-\n-Sat Dec 27 09:53:06 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlregexp.c: fixed xmlFAParseCharRange for Unicode ranges\n-\t  with patch from Charles Bozeman.\n-\n-Fri Dec 26 14:03:41 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlregexp.c: fixed problem causing segfault on validation error\n-\t  condition (reported on mailing list)\n-\n-Thu Dec 25 21:16:22 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlschemas.c: fixed missing dictionaries for Memory and Doc\n-\t  parser contexts (problem reported on mailing list)\n-\t* doc\/apibuild.py: small change to prevent duplicate lines\n-\t  on API functions list.  It will take effect the next time\n-\t  the docs are rebuilt.\n-\n-Wed Dec 24 12:54:25 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in NEWS doc\/*: updated the docs and prepared a new\n-\t  release 2.6.4\n-\n-Wed Dec 24 12:07:52 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* legacy.c: remove deprecated warning on startElement()\n-\n-Wed Dec 24 12:04:35 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c result\/XInclude\/nodes2.*: XInclude xpointer support\n-\t  was broken with the new namespace. Fixes #129932\n-\n-Wed Dec 24 00:29:30 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c include\/libxml\/schemasInternals.h: types might be\n-\t  redefined in includes, quick fix to allow this but lacks the \n-\t  equality of the redefinition test.\n-\n-Tue Dec 23 15:14:37 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* valid.c: fixed bug concerning validation using external\n-\t  dtd of element with multiple namespace declarations\n-\t  (Bug 129821)\n-\n-Tue Dec 23 11:41:42 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* tree.c: inhibited production of \"(null):\" in xmlGetNodePath\n-\t  when node has default namespace (Bug 129710)\n-\n-Tue Dec 23 09:29:14 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: small enhancement to xmlXPathCmpNodes to assure\n-\t  document order for attributes is retained (Bug 129331)\n-\n-Mon Dec 22 19:06:16 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c xmlreader.c: change xmlReadFd() xmlCtxtReadFd()\n-\t  xmlReaderNewFd() xmlReaderForFd(), change those to not close\n-\t  the file descriptor. Updated the comment, should close #129683\n-\n-Mon Dec 22 00:34:09 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: fixed a serious problem in XInclude #129021\n-\n-Sun Dec 21 13:59:54 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed bug #129489, propagation of parsing flags \n-\t  in entities.\n-\t* parser.c xmlreader.c: improved the comments of parsing options\n-\n-Sun Dec 21 18:14:04 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* python\/Makefile.am, python\/tests\/Makefile.am,\n-\t  doc\/Makefile.am: applied fixes to allow build from\n-\t  'outside' directory (Bug 129172)\n-\n-Sat Dec 20 16:42:07 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* tree.c - add explanation of namespace inheritance when\n-\tns is NULL to xmlNewChild and xmlNewTextChild API doc\n-\n-Sat Dec 20 18:17:28 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* include\/libxml\/xpathInternals.h: undid last change (my\n-\t  bad).  Put necessary fix in libxslt\/libexslt instead.\n-\t* include\/libxml\/DOCBparser.h: put test for __GCC__ on\n-\t  warning directive (Bug 129105)\n-\n-Sat Dec 20 10:48:37 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* include\/libxml\/xpathInternals.h: fixed xmlXPathReturnString\n-\t  to cater for NULL pointer (bug 129561)\n-\t* globals.c: added comment to suppress documentation warning\n-\t* doc\/apibuild.py: fixed problem which caused last APIchunkxx.html\n-\t  to be lost.  Rebuilt doc\/* (including adding APIchunk26.html)\n-\n-Fri Dec 19 18:24:02 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: trying to fix #129692 xmlTextReaderExpand() when\n-\t  using an xmlReaderWalker()\n-\n-Thu Dec 18 20:10:34 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* tree.c: fix misc. typos in doc comments\n-\t* include\/libxml\/tree.h: elaborate on macro define doc comments\n-\t* doc\/*: rebuild docs\n-\n-Wed Dec 17 16:07:33 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/examples\/*: don't call the result files .out but .res as\n-\t  the Makefiles tend to try generating binaries for .out targets...\n-\n-Tue Dec 16 20:53:54 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/html\/libxml-pattern.html: - cvs add API docs for new\n-\tpattern stuff\n-\n-Tue Dec 16 20:40:40 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* tree.c\n-\t* doc\/*:\n-\tElaborate in documentation discussion of xmlNewChild\n-\tand xmlNewTextChild. Thanks to Steve Lenti for pointing\n-\tout the usefulness of a more explicit explanation of the\n-\treserved character escaping issue.\n-\n-Fri Dec 12 15:55:15 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlcatalog.c: applied patch from Stefan Kost\n-\n-Thu Dec 11 15:15:31 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/examples\/testWriter.c: applied small fix from Lucas Brasilino\n-\n-Thu Dec 11 14:55:22 CET 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/Makefile.* win32\/configure.js: Added pattern support\n-\n-Wed Dec 10 14:11:20 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in doc\/* libxml.spec.in: preparing release of\n-\t  libxml2-2.6.3, updated and regenerated the docs.\n-\n-Wed Dec 10 11:43:33 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c pattern.c: removed some compilation warnings\n-\n-Wed Dec 10 11:16:29 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: fixing bug #119264 xmllint failing to report\n-\t  serialization errors in some cases.\n-\n-Tue Dec  9 23:50:23 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* entities.c: fixed an XML entities content serialization\n-\t  potentially triggered by XInclude, see #126817\n-\n-Tue Dec  9 16:12:50 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlwriter.c: applied the patch to xmlTextWriterStartPI()\n-\t  suggested by Daniel Schulman in #128313\n-\n-Tue Dec  9 15:18:32 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in Makefile.am: another patch from Kenneth Haley\n-\t  for Mingw, c.f. #128787\n-\n-Tue Dec  9 15:07:09 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlexports.h: applied patch from Kenneth Haley\n-\t  for compiling on Mingw see #128786\n-\n-Tue Dec  9 14:52:59 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: some flags were not passed down correctly as\n-\t  parsing options. Fixes #126806\n-\n-Tue Dec  9 12:29:26 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c xmllint.c xmlreader.c include\/libxml\/xinclude.h\n-\t  include\/libxml\/xmlerror.h: augmented the XInclude API\n-\t  to be able to pass XML parser flags down to the Inclusion\n-\t  process. Also resynchronized with the Last Call W3C Working\n-\t  Draft 10 November 2003 for the xpointer attribute.\n-\t* Makefile.am test\/XInclude\/docs\/nodes[23].xml \n-\t  result\/XInclude\/*: augmented the tests for the new namespace and\n-\t  testing the xpointer attribute, changed the way error messages\n-\t  are tested\n-\t* doc\/*: regenerated the documentation\n-\n-Mon Dec  8 18:38:26 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c: filter warning messages if the global setting blocks them\n-\t* xinclude.c xmlreader.c include\/libxml\/xinclude.h\n-\t  include\/libxml\/xmlerror.h: updated the change of namespace at\n-\t  the XInclude level, raise a warning if the old one is found,\n-\t  and some cleanup\n-\n-Mon Dec  8 13:09:39 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: tentative fix for #126117 character reference in\n-\t  attributes output problem in some cornercase.\n-\n-Mon Dec  8 11:08:45 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.py: tried to fix the problems reported in \n-\t  bug #126735\n-\t* xpath.c SAX2.c error.c parser.c valid.c include\/libxml\/xmlerror.h:\n-\t  fixed again some problem trying to use the structured error\n-\t  handlers, c.f. bug #126735\n-\t* result\/VC\/ElementValid: tiny change due to the fix\n-\n-Sun Dec  7 22:27:31 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c: fixed __xmlRaiseError to use structured error handlers\n-\t  defined by xmlSetStructuredErrorFunc(), fixes bug #126211\n-\n-Sun Dec  7 20:30:53 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: attempt to fix #126211 ... \n-\n-Fri Dec  5 17:07:29 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* pattern.c xmlreader.c xmllint.c include\/libxml\/pattern.h\n-\t  include\/libxml\/xmlreader.h: fixed the pattern interfaces\n-\t  but not yet the parser to handle the namespaces.\n-\t* doc\/examples\/reader3.c doc\/*: fixed the example, rebuilt the docs.\n-\n-Fri Dec  5 15:49:44 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* globals.c xmlwriter.c doc\/apibuild.py include\/libxml\/globals.h \n-\t  include\/libxml\/pattern.h include\/libxml\/schemasInternals.h\n-\t  include\/libxml\/xmlexports.h include\/libxml\/xmlwriter.h: cleanup\n-\t  the make rebuild in doc, this include new directive to stop\n-\t  documentation warnings\n-\t* doc\/* doc\/html\/*: rebuilt the docs\n-\t* pattern.c xmlreader.c include\/libxml\/pattern.h\n-\t  include\/libxml\/xmlreader.h: adding xmlTextReaderPreservePattern()\n-\t  to save nodes while scanning the tree with the reader, cleanup\n-\t  the way element were freed, and xmlTextReaderPreserve()\n-\t  implementation, the API might change for namespace binding support\n-\t  when compiling patterns.\n-\t* doc\/examples\/*: added reader3.c exposing the xmlTextReaderPreserve()\n-\n-Thu Dec  4 15:10:57 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.py: oops forgot to modify\/commit the new code.\n-\n-Thu Dec  4 13:29:19 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/libxml.c python\/libxml_wrap.h:\n-\t  cleanup the output buffer support to at least get the basic\n-\t  to work\n-\t* python\/tests\/outbuf.py python\/tests\/serialize.py: fixes and\n-\t  cleanup.\n-\t* include\/libxml\/xmlwriter.h: cleanup\n-\n-Wed Dec  3 21:38:56 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* include\/libxml\/xmlversion.h.in\n-\t* doc\/*: add WITH_TRIO comment so it shows up in the docs, rebuild\n-\t  docs\n-\n-Wed Dec  3 13:10:08 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* config.h.in configure.in xmlregexp.c: fix bug #128401 affecting\n-\t  regexp quantifiers\n-\n-Tue Dec  2 23:29:56 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* pattern.c include\/libxml\/pattern.h: adding the pattern node\n-\t  selection code. Inheried in part from libxslt but smaller.\n-\t* Makefile.am configure.in include\/libxml\/xmlversion.h.in:\n-\t  integrated the pattern module, made it a configure time option\n-\t* xmllint.c: added --pattern to test when doing --stream\n-\n-Tue Dec  2 11:25:25 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: fixed a problem in xmlreader validation when\n-\t  streaming exposed by reader2 example.\n-\n-Mon Dec  1 20:40:51 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xml.html\n-\t* doc\/docs.html:\n-\tadd reference to the Code Examples page to docs.html list\n-\tof resources\n-\n-Mon Dec  1 12:30:28 CET 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/Makefile.bcb win32\/configure.js: Applied the BCB patch\n-\t  from Eric\n-\n-Sun Nov 30 21:33:37 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* include\/libxml\/xinclude.h\n-\t* doc\/*: Add comments for macro definitions in xinclude.h and\n-\trebuild the docs\n-\n-Sun Nov 30 21:06:29 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/docdescr.doc\n-\tUpdating William's explanation of how to build docs, \n-\treflecting Daniel's new docs build system\n-\n-Sat Nov 29 18:38:22 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlmemory.c: enhanced by adding mutex to protect global\n-\t  structures in a multi-threading environment.  This fixed\n-\t  some random errors on the Threads regression tests.\n-\n-Fri Nov 28 21:39:49 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xml.html doc\/python.html: fix tst.py text, which didn't\n-\t  import sys\n-\n-Fri Nov 28 17:28:47 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* encoding.c, include\/libxml\/encoding.h: Enhanced the handling of\n-\t  UTF-16, UTF-16LE and UTF-16BE encodings.  Now UTF-16 output is\n-\t  handled internally by default, with proper BOM and UTF-16LE\n-\t  encoding.  Native UTF-16LE and UTF-16BE encoding will not generate\n-\t  BOM on output, and will be automatically recognized on input.\n-\t* test\/utf16lebom.xml, test\/utf16bebom.xml, result\/utf16?ebom*:\n-\t  added regression tests for above.\n-\n-Thu Nov 27 19:25:10 CET 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/Makefile.* win32\/configure.js: Modified to allow coexistent \n-\t  build with all compilers. Added C-Runtime option for MSVC. Included\n-\t  xmlWriter.\n-\t* xmlwriter.c: Added IN_LIBXML macro\n-\n-Wed Nov 26 21:54:01 CET 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/Makefile.bcb: applied patch from Eric\n-\n-Wed Nov 26 21:33:14 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/tree.h: stefan on IRC pointed out that XML_GET_LINE\n-\t  is broken on 2.6.x\n-\n-Tue Nov 25 18:39:44 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* entities.c: fixed #127877, never output &quot; in element content\n-\t* result\/isolat3 result\/slashdot16.xml result\/noent\/isolat3\n-\t  result\/noent\/slashdot16.xml result\/valid\/REC-xml-19980210.xml\n-\t  result\/valid\/index.xml result\/valid\/xlink.xml: this changes the\n-\t  output of a few tests\n-\n-Tue Nov 25 16:36:21 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/schemasInternals.h include\/libxml\/xmlerror.h\n-\t  testSchemas.c xmlschemas.c: added xsd:include support, fixed\n-\t  testSchemas behaviour when a schemas failed to parse.\n-\t* test\/schemas\/vdv-* result\/schemas\/vdv-first5_0_0*: added one\n-\t  test for xsd:include from Eric Van der Vlist\n-\n-Tue Nov 25 08:18:12 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: swapped the attribute defaulting and attribute checking\n-\t  parts of parsing a new element start, fixes bug #127772\n-\t* result\/valid\/127772.* test\/valid\/127772.xml\n-\t  test\/valid\/dtds\/127772.dtd: added the example in the regression tests\n-\n-Tue Nov 25 08:00:15 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: moved xmlCleanupThreads() to the end of xmlCleanupParser()\n-\t  to avoid bug #127851\n-\n-Mon Nov 24 15:26:21 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: fixing some Negative Character Group and\n-\t  Character Class Subtraction handling.\n-\n-Mon Nov 24 14:01:57 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c xmlschemas.c: more XML Schemas fixes based\n-\t  on Eric van der Vlist examples\n-\t* result\/schemas\/vdv-first4* test\/schemas\/vdv-first4*:\n-\t  added regression tests\n-\t* doc\/examples\/Makefile.am doc\/examples\/index.py: do not\n-\t  regenerate the index on make all target, but only on\n-\t  make rebuild to avoid troubles.\n-\n-Sat Nov 22 21:35:42 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c xmlschemastypes.c include\/libxml\/xmlerror.h\n-\t  include\/libxml\/schemasInternals.h: lot of bug fixes, cleanup,\n-\t  starting to add proper namespace support too.\n-\t* test\/schemas\/* result\/schemas\/*: added a number of tests\n-\t  fixed the result from some regression tests too.\n-\n-Fri Nov 21 20:50:59 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xml.html, docs.html: remove reference to gtk-doc now that\n-\tDaniel has removed it, fix link to George's IBM article, other\n-\tminor edits\n-\n-Fri Nov 21 01:26:00 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: applied patch from Robert Stepanek to start \n-\t  import os schemas support, cleaned up stuff and the patch.\n-\t* test\/schemas\/import0_0.* result\/schemas\/import0_0_0*: added test\n-\t  to regression, fixed a few regressions too.\n-\n-Thu Nov 20 22:58:00 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: applied two parsing fixes from James Bursa\n-\n-Thu Nov 20 19:20:46 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/examples\/*: added two xmlReader examples\n-\t* xmlreader.c: cleaned up some bugs in the process\n-\n-Thu Nov 20 12:54:30 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlwriter.c include\/libxml\/xmlwriter.h: applied patch from\n-\t  Alfred Mickautsch, bugfixes and comments\n-\t* doc\/examples\/*: added his test as the xmlWriter example\n-\t* doc\/html\/ doc\/*.html: this resulted in some improvements\n-\t* include\/libxml\/hash.h: fixed an inclusion problem when\n-\t  <libxml\/hash.h> wasn't preceded by <xml\/parser.h>\n-\n-Wed Nov 19 17:19:35 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: fix an error message\n-\t* doc\/examples\/*: added tree2 example from Lucas Brasilino\n-\n-Wed Nov 19 17:50:47 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/newapi.xsl: improve the sort sequence for page content\n-\t* doc\/html\/*.html: regenerate the web pages\n-\n-Wed Nov 19 00:48:56 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: do not package cvs versioning temp files.\n-\t* doc\/apibuild.py doc\/libxml2-api.xml doc\/newapi.xsl: more cleanup,\n-\t  slightly improved the API xml format, fixed a lot of small\n-\t  rendering problems\n-\t* doc\/html\/libxml*.html: rebuilt\n-\n-Tue Nov 18 21:51:15 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/*.h include\/libxml\/*.h.in: modified the file\n-\t  header to add more information, painful...\n-\t* genChRanges.py genUnicode.py: updated to generate said changes\n-\t  in headers\n-\t* doc\/apibuild.py: extract headers, add them to libxml2-api.xml\n-\t* *.html *.xsl *.xml: updated the stylesheets to flag geprecated\n-\t  APIs modules. Updated the stylesheets, some cleanups, regenerated\n-\t* doc\/html\/*.html: regenerated added back book1 and libxml-lib.html\n-\n-Tue Nov 18 14:43:16 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/Makefile.am doc\/*.xsl doc\/*.html doc\/apibuild.py: cleaned up\n-\t  the build process to remove all remains from the old gtk-doc\n-\t  inherited, libxml2-refs.xml is now generated by apibuild.py, the\n-\t  stylesheets have been improved, and the API*html now generated\n-\t  are XHTML1 valid too\n-\n-Tue Nov 18 14:28:32 HKT 2003 William Brack <mmm.com.hk>\n-\n-\t* genChRanges.py, chvalid.c, include\/libxml\/chvalid.h: minor\n-\t  enhancement to prevent comment with unreferenced variable.\n-\t* threads.c xmlreader.c xmlwriter.c: edited some comments to\n-\t  improve auto-generation of documentation\n-\t* apibuild.py: minor change to an error message\n-\n-Mon Nov 17 17:55:51 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/apibuild.py doc\/libxml2-api.xml doc\/newapi.xsl: more cleanup,\n-\t  improving navigation\n-\t* doc\/html\/*.html: updated the result\n-\n-Mon Nov 17 14:54:38 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/Makefile.am doc\/apibuild.py doc\/libxml2-api.xml doc\/newapi.xsl:\n-\t  improvement of the stylesheets, fixed a API generation problem,\n-\t  switched the stylesheet and Makefile to build the HTML output.\n-\t* doc\/html\/*.html: complete update, ditched some old files, might\n-\t  introduce some breakage...\n-\n-Mon Nov 17 12:50:28 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/newapi.xsl: lot of improvements, this starts looking good\n-\t  enough to be usable.\n-\n-Mon Nov 17 00:58:09 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/newapi.xsl: stylesheet to build HTML pages from the\n-\t  API XML description, Work in Progress\n-\n-Sun Nov 16 16:03:24 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: fixed bug 126976 (string != empty nodeset\n-\t  should be false)\n-\n-Sun Nov 16 14:00:08 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/html\/*.html: Finally - found the problem with the\n-\t  page generation (XMLPUBFUN not recognized by gtkdoc).\n-\t  Re-created the pages using a temporary version of\n-\t  include\/libxml\/*.h.\n-\t* testOOMlib.c,include\/libxml\/encoding.h,\n-\t  include\/libxml\/schemasInternals.h,include\/libxml\/valid.h,\n-\t  include\/libxml\/xlink.h,include\/libxml\/xmlwin32version.h,\n-\t  include\/libxml\/xmlwin32version.h.in,\n-\t  include\/libxml\/xpathInternals.h: minor edit of comments\n-\t  to help automatic documentation generation\n-\t* doc\/docdescr.doc: small elaboration\n-\t* doc\/examples\/test1.c,doc\/examples\/Makefile.am: re-commit\n-\t  (messed up on last try)\n-\t* xmlreader.c: minor change to clear warning.\n-\n-Sat Nov 15 19:20:32 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Copyright: fixed some wording\n-\t* libxml.spec.in: make sure doc\/examples is packaged\n-\t* include\/libxml\/tree.h valid.c xmlreader.c: fixed the really\n-\t  annoying problem about xmlRemoveID and xmlReader streaming.\n-\t  Thing looks fixed now, had to add a doc reference to the\n-\t  xmlID structure though...\n-\n-Sat Nov 15 09:53:36 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/docdescr.doc: added description of man page building\n-\n-Sat Nov 15 19:08:22 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/html\/libxml-chvalid.html, doc\/html\/libxml-dict.html,\n-\t  doc\/html\/libxml-list.html, doc\/html\/libxml-testOOMlib.html,\n-\t  doc\/html\/libxml-wincecompat, doc\/html\/winsockcompat.html,\n-\t  doc\/html\/libxml-xmlexports.html, doc\/html\/libxml-xmlversion.html,\n-\t  doc\/html\/libxml-xmlwin32version.html, doc\/html\/libxml-xmlwriter.html:\n-\t  added missing pages for the website.\n-\n-Sat Nov 15 18:23:48 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/Makefile.am doc\/*.html doc\/html\/*.html: rebuilt the\n-\t  generated pages (again), manually restored doc\/html\/index.html\n-\t  and manually edited generated file doc\/gnome-xml.xml to put\n-\t  in appropriate headings.\n-\t* doc\/docdescr.doc: new file to describe details of the\n-\t  document generation (helps my memory for the next time)\n-\t* genChRanges.py,chvalid.c,include\/libxml\/chvalid.h: minor\n-\t  enhancement to please the automatic documentation generation.\n-\n-Fri Nov 14 23:47:31 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* catalog.c,relaxng.c,testAutomata.c,xpointer.c,genChRanges.py,\n-\t  chvalid.c,include\/libxml\/chvalid.h,doc\/examples\/test1.c:\n-\t  minor error cleanup for gcc-3.3.[12] compilation warnings.\n-\n-Fri Nov 14 15:08:13 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* tree.c: minor changes to some comments\n-\t* doc\/*.html: rebuilt the generated HTML pages for changes\n-\t  from jfleck (bug 126945)\n-\n-Thu Nov 13 12:44:14 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/examples\/*: added Dodji's example, added output handling\n-\n-Thu Nov 13 11:35:35 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/examples\/*: added Aleksey XPath example, fixed bugs\n-\t  in the indexer\n-\n-Wed Nov 12 23:48:26 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/*: integrating the examples in the navigation menus\n-\t* doc\/examples\/*: added make tests, updated the navigation,\n-\t  added a new test, cleanups, updates.\n-\n-Wed Nov 12 17:50:36 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/*.html: rebuilt the generated HTML pages\n-\t* doc\/examples\/*: updated the stylesheets, added a synopsis,\n-\t  Makefile.am is now generated by index.py\n-\n-Wed Nov 12 01:38:16 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/site.xsl doc\/examples\/Makefile.am doc\/examples\/index.html:\n-\t  added autogeneration of a web page for the examples\n-\t* doc\/examples\/example1.c doc\/examples\/.cvsignore\n-\t  doc\/examples\/examples.xml doc\/examples\/index.py: updated the\n-\t  information extracted, improved the format and indexing.\n-\n-Tue Nov 11 22:08:59 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* check-xinclude-test-suite.py: less verbose on difference\n-\t* libxml.spec.in: cleanup\n-\t* parser.c: fixed xmlCleanupParser() doc\n-\t* doc\/Makefile.am doc\/apibuild.py doc\/libxml2-api.xml\n-\t  doc\/examples\/Makefile.am doc\/examples\/example1.c \n-\t  doc\/examples\/examples.xml doc\/examples\/index.py\n-\t  doc\/examples\/test1.xml: work on adding C examples and\n-\t  generating automated information about those. examples.xml\n-\t  is autogenerated describing the examples.\n-\t* example\/Makefile.am: cleanup\n-\n-Mon Nov 10 23:47:03 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* genUnicode.py, xmlunicode.c, include\/libxml\/xmlunicode.h:\n-\t  fixed missing '-' in block names, enhanced the hack for\n-\t  ABI aliasing.\n-\n-Sun Nov  9 20:28:21 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* genUnicode.py, xmlunicode.c, include\/libxml\/xmlunicode.h,\n-\t  python\/libxml2class.txt: enhanced for range checking,\n-\t  updated to Unicode version 4.0.1 (API docs also updated)\n-\t* python\/generator.py: minor change to fix a warning\n-\n-Wed Nov  5 23:46:36 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: apply fix from Karl Eichwalder for script path\n-\n-Wed Nov  5 10:49:20 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/configure.js: applied patch from Mark Vakoc to simplify\n-\t  his work from CVS checkouts.\n-\n-Tue Nov  4 21:16:47 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmlreader.html: minor cleanups\n-\n-Tue Nov  4 15:52:28 PST 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* include\/libxml\/xmlversion.h.in: changed macro ATTRIBUTE_UNUSED\n-\t  for gcc so that, if undefined, it's defined as\n-\t  __attribute__((unused))\n-\n-Tue Nov  4 15:28:07 PST 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* python\/generator.py: small enhancement to assure ATTRIBUTE_UNUSED\n-\t  appears after the variable declaration.\n-\t* valid.c: trivial change to eliminate a warning message\n-\n-Tue Nov  4 11:24:04 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in NEWS doc\/*: preparing release 2.6.2, updated and\n-\t  rebuilt the docs\n-\n-Tue Nov  4 09:38:46 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: change --html to make sure we use the HTML serialization\n-\t  rule by default when HTML parser is used, add --xmlout to allow to\n-\t  force the XML serializer on HTML.\n-\t* HTMLtree.c: ugly tweak to fix the output on <p> element and \n-\t  solve #125093\n-\t* result\/HTML\/*: this changes the output of some tests\n-\n-Mon Nov  3 17:51:28 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: fixed bug #125812, about XPointer in XInclude \n-\t  failing but not returning an error.\n-\n-Mon Nov  3 17:18:22 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: fixed bug #125811 related to DTD post validation\n-\t  where the DTD doesn't pertain to a document.\n-\n-Mon Nov  3 15:25:58 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c xmlIO.c include\/libxml\/parserInternals.h: implemented\n-\t  the XML_PARSE_NONET parser option.\n-\t* xmllint.c: converted xmllint.c to use the option instead of \n-\t  relying on the global resolver variable.\n-\n-Mon Nov  3 13:26:32 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c xmlreader.c include\/libxml\/xinclude.h: adding XInclude\n-\t  support to the reader interface. Lot of testing of the walker,\n-\t  various bug fixes.\n-\t* xmllint.c: added --walker and made sure --xinclude --stream --debug\n-\t  works as expected\n-\t* Makefile.am result\/dtd11.rdr result\/ent6.rdr test\/dtd11 test\/ent6\n-\t  result\/XInclude\/*.rdr: added regression tests for the walker and\n-\t  XInclude xmlReader support, had to slightly change a couple of tests\n-\t  because the walker can't distinguish <foo\/> from <foo><\/foo>\n-\n-Sat Nov  1 17:42:27 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c nanohttp.c threads.c: second BeOS patch from \n-\t  Marcin 'Shard' Konicki\n-\n-Fri Oct 31 15:35:20 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: always generate line numbers\n-\n-Fri Oct 31 11:53:46 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed another regression introduced in fixing #125823\n-\n-Fri Oct 31 11:33:18 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c: previous fix for #124044 was broken, correct\n-\t  fix provided.\n-\t* HTMLparser.c parser.c parserInternals.c xmlIO.c: fix xmlStopParser()\n-\t  and the error handlers to address #125877\n-\n-Thu Oct 30 23:10:46 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: side effect of #123105 patch, namespace resolution\n-\t  would fail when defined in internal entities, fixes #125823\n-\n-Thu Oct 30 14:10:42 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c: be more defensive in the xmlReader python bindings\n-\t  fixing bug #124044\n-\n-Thu Oct 30 11:14:31 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: the a-posteriori DTD validation code was not validating\n-\t  the namespace declarations, this fixes #124110\n-\n-Wed Oct 29 14:13:03 PDT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlIO.c: enhanced to bypass compression detection code\n-\t  when input file is stdin (bug 125801)\n-\n-Wed Oct 29 18:21:00 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: fix needed when HTTP is not compiled in by Mark Vakoc\n-\n-Wed Oct 29 18:05:53 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: more fixes about unregistering objects\n-\t* include\/libxml\/relaxng.h: applied patch from Mark Vakoc\n-\t  missing _cplusplus processing clause\n-\n-Wed Oct 29 07:49:52 2003  Aleksey Sanin  <aleksey@aleksey.com>\n-\n-\t* include\/libxml\/parser.h parser.c: added xmlStrVPrintf function\n-\n-Wed Oct 29 14:37:40 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanoftp.c nanohttp.c testThreads.c threads.c: applied patch from\n-\t  Marcin 'Shard' Konicki to provide BeOS thread support.\n-\n-Wed Oct 29 14:20:14 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c include\/libxml\/xmlschemas.h: applied patch\n-\t  from Steve Ball to make a schema parser from a preparsed document.\n-\n-Wed Oct 29 13:52:25 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: applied a couple of patches from Mark Lilback about text\n-\t  nodes coalescing\n-\n-Wed Oct 29 12:16:52 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: change suggested by Anthony Carrico when unregistering\n-\t  a namespace prefix to a context\n-\t* hash.c: be more careful about calling callbacks with NULL payloads.\n-\n-Wed Oct 29 00:04:26 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in NEWS doc\/*: preparing release 2.6.1, updated and\n-\t  regenerated docs and APIs\n-\t* parser.c: cleanup and last change to fix #123105\n-\n-Tue Oct 28 23:02:29 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: Fix #124907 by simply backporting the same\n-\t  fix as for the XML parser\n-\t* result\/HTML\/doc3.htm.err: change to ID detecting modified one\n-\t  test result.\n-\n-Tue Oct 28 22:28:50 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c include\/libxml\/parser.h: included a new function\n-\t  to reuse a Push parser context, based on Graham Bennett original\n-\t  code\n-\t* valid.c: in HTML, a name in an input is not an ID\n-\t* TODO: bug list update\n-\n-Tue Oct 28 19:54:37 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: applied patch from nico@xtradyne.com for #125030\n-\n-Tue Oct 28 16:42:16 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: cleanup\n-\t* error.c valid.c include\/libxml\/xmlerror.h: fixing bug #125653\n-\t  sometimes the error handlers can get a parser context on DTD\n-\t  errors, and sometime they don't. So be very careful when trying\n-\t  to grab those information.\n-\n-Tue Oct 28 15:26:18 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: applied patch from Kasimier Buchcik which fixes a \n-\t  problem in xmlSearchNs introduced in 2.6.0\n-\n-Tue Oct 28 14:57:03 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed #123263, the encoding is mandatory in a textdecl.\n-\n-Tue Oct 28 13:48:52 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fix bug #125047 about serializing when finding a \n-\t  document fragment node.\n-\n-Mon Oct 27 11:11:29 EST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testSAX.c: fix bug #125592 need a NULL check\n-\t* include\/libxml\/chvalid.h: rename a parameter\n-\n-Mon Oct 27 09:43:48 EST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: applied patch from #123105 about defaulted attributes\n-\t  from element coming from an entity\n-\n-Mon Oct 27 21:12:27 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmllint.c: fixed warning message from IRIX (bug 125182)\n-\t* python\/libxml.py: removed tabs, replaced with spaces\n-\t  (bug 125572)\n-\n-Mon Oct 27 06:17:30 EST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.h parserInternals.c xmlIO.c: make sure we report errors\n-\t  if xmlNewInputFromFile() fails.\n-\t* xmlreader.c: avoid using _private for the node or document\n-\t  elements.\n-\n-Sat Oct 25 17:33:59 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/configure.js: added declaration for verMicroSuffix\n-\n-Fri Oct 24 23:08:17 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.m4: applied patch from Patrick Welche provided in\n-\t  bug #125432 , future proofing the .m4 file.\n-\t* parser.c: resetting the context should also reset the error\n-\t* TODO: problem of conformance w.r.t. E20 was raised in the\n-\t  XML Core telconf and libxml2 isn't conformant there.\n-\n-Wed Oct 22 14:33:05 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlwriter.c: applied patch from Alfred Mickautsch fixing #125180\n-\n-Wed Oct 22 10:50:31 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* chvalid.c genChRanges.py: Stéphane Bidoul pointed out another\n-\t  small glitch missing a const\n-\n-Wed Oct 22 10:43:21 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* chvalid.c genChRanges.py: Stéphane Bidoul pointed out that\n-\t  it doesn't define IN_LIBXML\n-\n-Tue Oct 21 21:14:55 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/Makefile.mingw: typo pointed out by Stéphane Bidoul\n-\n-Tue Oct 21 11:26:36 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/Makefile.bcb win32\/Makefile.mingw win32\/Makefile.msvc\n-\t  win32\/configure.js: set of Win32 patches for 2.6.0 by Joachim Bauch\n-\n-Tue Oct 21 02:07:22 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: last minute patch from Eric Zurcher making it into 2.6.0\n-\n-Tue Oct 21 02:03:03 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in NEWS doc\/libxml2.xsa: preparing libxml2-2.6.0\n-\t* doc\/*: updated and regenerated the docs and API\n-\n-Tue Oct 21 01:01:55 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c error.c tree.c: moved the line number to their proper\n-\t  field in elements now.\n-\n-Tue Oct 21 00:28:20 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in xmlwriter.c Makefile.am include\/libxml\/xmlwriter.h\n-\t  include\/libxml\/Makefile.am include\/libxml\/xmlversion.h.in:\n-\t  added the xmlWriter module contributed by Alfred Mickautsch\n-\t* include\/libxml\/tree.h: added room for line and extra information\n-\t* xmlreader.c python\/tests\/reader6.py: bugfixing some problem some\n-\t  of them introduced in September\n-\t* win32\/libxml2.def.src doc\/libxml2-api.xml: regenerated the API\n-\n-Mon Oct 20 19:02:53 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am configure.in xmldwalk.c xmlreader.c\n-\t  include\/libxml\/Makefile.am include\/libxml\/xmldwalk.h\n-\t  include\/libxml\/xmlversion.h.in: removing xmldwalk module\n-\t  since it got merged with the xmlreader.\n-\t* parser.c: cleanup\n-\t* win32\/libxml2.def.src python\/libxml2class.txt doc\/libxml2-api.xml:\n-\t  rebuilt the API\n-\t* python\/tests\/Makefile.am python\/tests\/reader7.py\n-\t  python\/tests\/walker.py: adding regression testing for the\n-\t  new xmlreader APIs, new APIs for reader creation, including\n-\t  making reader \"walker\" operating on preparsed document trees.\n-\n-Sun Oct 20 22:37:03 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* entities.c, valid.c: fixed problem reported on the mailing\n-\t  list by Melvyn Sopacua - wrong argument order on functions\n-\t  called through xmlHashScan.\n-\n-Sun Oct 19 23:57:45 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c xmlIO.c: fixes for compiling using --with-minimum\n-\n-Sun Oct 19 23:46:04 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: cleanup xmlNodeGetContent() reusing xmlNodeBufGetContent(),\n-\t  tested it through the xslt regression suite.\n-\n-Sun Oct 19 22:42:16 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c include\/libxml\/tree.h: adding xmlNodeBufGetContent()\n-\t  allowing to grab the content without forcing allocations.\n-\t* python\/libxml2class.txt doc\/libxml2-api.xml: rebuilt the API\n-\t* xpath.c xmldwalk.c: removed a couple of comment errors.\n-\n-Sun Oct 19 16:39:36 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: applied patch from Chris Anderson to change back\n-\t  memcmp with CMPx()\n-\n-Sun Oct 19 16:24:19 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fixed to not send NULL to %s printing\n-\t* python\/tests\/error.py result\/HTML\/doc3.htm.err\n-\t  result\/HTML\/test3.html.err result\/HTML\/wired.html.err\n-\t  result\/valid\/t8.xml.err result\/valid\/t8a.xml.err: cleaning\n-\t  up some of the regression tests error\n-\n-Sun Oct 19 15:31:43 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/nanohttp.h include\/libxml\/parserInternals.h \n-\t  include\/libxml\/xmlIO.h nanohttp.c parserInternals.c xmlIO.c:\n-\t  Fixed the HTTP<->parser interraction, which should fix 2 long\n-\t  standing bugs #104790 and #124054 , this also fix the fact that\n-\t  HTTP error code (> 400) should not generate data, we usually\n-\t  don't want to parse the HTML error information instead of the\n-\t  resource looked at.\n-\n-Sun Oct 19 19:20:48 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/Makefile.am: enhanced the installation of tutorial files\n-\t  to avoid installing CVS subdirectories (bug 122943)\n-\n-Sun Oct 19 17:33:27 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlIO.c: fixed segfault when input file not present\n-\t* tree.c: changed output formatting of XML_CDATA_SECTION\n-\t  (bug 120917)\n-\n-Sun Oct 19 00:15:38 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* include\/libxml\/parserInternals.h HTMLparser.c HTMLtree.c\n-\t  SAX2.c catalog.c debugXML.c entities.c parser.c relaxng.c\n-\t  testSAX.c tree.c valid.c xmlschemas.c xmlschemastypes.c\n-\t  xpath.c: Changed all (?) occurrences where validation macros\n-\t  (IS_xxx) had single-byte arguments to use IS_xxx_CH instead\n-\t  (e.g. IS_BLANK changed to IS_BLANK_CH).  This gets rid of\n-\t  many warning messages on certain platforms, and also high-\n-\t  lights places in the library which may need to be enhanced\n-\t  for proper UTF8 handling.\n-\n-Sat Oct 18 20:34:18 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* genChRanges.py, chvalid.c, include\/libxml\/chvalid.h,\n-\t  doc\/apibuild.py: enhanced to include enough comments to\n-\t  make the api doc generation happy.\n-\n-Sat Oct 18 07:28:25 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanohttp.c xmlIO.c include\/libxml\/nanohttp.h: starting work\n-\t  to fix the HTTP\/XML parser integration.\n-\n-Sat Oct 18 11:04:32 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c include\/libxml\/xmlreader.h: added new APIs\n-\t  for creating reader from sources or reusing a reader with\n-\t  a new source, like the xmlReadxx and xmlCtxtReadxxx\n-\t* win32\/libxml2.def.src doc\/libxml2-api.xml doc\/apibuild.py\n-\t  doc\/Makefile.am: regenerated the APIs\n-\t* doc\/xml.html: applied a patch from Stefan Kost for namespace docs\n-\n-Sat Oct 18 12:46:02 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* genChRanges.py, chvalid.c, include\/libxml\/chvalid.h,\n-\t  include\/libxml\/parserInternals.h: enhanced macros to avoid\n-\t  breaking ABI from previous versions.\n-\t* catalog.c, parser.c, tree.c: modified to use IS_* macros\n-\t  defined in parserInternals.h.  Makes maintenance much easier.\n-\t* testHTML.c, testSAX.c, python\/libxml.c: minor fixes to avoid\n-\t  compilation warnings\n-\t* configuration.in: fixed pushHTML test error; enhanced for\n-\t  better devel (me) testing\n-\n-Fri Oct 17 14:38:54 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* legacy.c: remove the warning for startDocument(), as it is used by\n-\t  glade (or glade-python)\n-\t* parser.c relaxng.c xmlschemastypes.c: fixed an assorted set of\n-\t  invalid accesses found by running some Python based regression\n-\t  tests under valgrind. There is still a few leaks reported by the\n-\t  relaxng regressions which need some attention.\n-\t* doc\/Makefile.am: fixed a make install problem c.f. #124539\n-\t* include\/libxml\/parserInternals.h: addition of xmlParserMaxDepth\n-\t  patch from crutcher\n-\n-Wed Oct 15 12:47:33 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: Marc Liyanage pointed out that xmlCleanupParser()\n-\t  was missing xmlCleanupInputCallbacks and xmlCleanupOutputCallbacks\n-\t  calls.\n-\n-Wed Oct 15 10:16:47 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* vms\/build_libxml.com trionan.c: VMS patch from Craig A. Berry\n-\n-Mon Oct 13 21:46:25 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: small fix from Bjorn Reese\n-\n-Mon Oct 13 15:59:25 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: fix a call missing arguments\n-\n-Sun Oct 12 18:42:18 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* genChRanges.py, chvalid.c, include\/libxml\/chvalid.h: fixed\n-\t  a bug in the range search; enhanced range generation (inline code\n-\t  if a small number of intervals); enhanced the readability of the\n-\t  output files.\n-\n-Sun Oct 12 00:52:14 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* chvalid.def chvalid.c include\/libxml\/chvalid.h: rebuilt \n-\t  chvalid.def from scratch based on XML 2nd edition REC\n-\t  and regenerated the code.\n-\n-Sat Oct 11 22:54:13 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* check-xml-test-suite.py: removed some annoying warnings\n-\t* chvalid.def chvalid.c include\/libxml\/chvalid.h: fixed a bug\n-\t  in the PubidChars definition, regenerated, there is still\n-\t  a bug left somewhere\n-\t* genChRanges.py: save the header directly in include\/libxml\/\n-\t* configure.in: I generated a 2.6.0beta6 earlier today\n-\n-Sat Oct 11 23:32:47 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* fixed small error on previous commit (chvalid.h in\n-\t  base dir instead of include directory)\n-\n-Sat Oct 11 23:11:22 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* genChRange.py, chvalid.def, chvalid.c, include\/libxml\/chvalid.h:\n-\t  new files for a different method for doing range validation\n-\t  of character data.\n-\t* Makefile.am, parserInternals.c, include\/libxml\/Makefile.am,\n-\t  include\/libxml\/parserInternals.h: modified for new range method.\n-\t* catalog.c: small enhance for warning message (using one\n-\t  of the new range routines)\n-\n-Sat Oct 11 13:24:57 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c include\/libxml\/valid.h: adding an serror field to\n-\t  the validation context breaks the ABI for the xmlParserCtxt\n-\t  structure since it's embedded by content and not by reference\n-\n-Sat Oct 11 12:46:49 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: patch from Mike Hommey\n-\t* threads.c: applied Windows patch from Jesse Pelton and Stephane\n-\t  Bidoul\n-\t* parser.c: fix the potentially nasty access to ctxt->serror\n-\t  without checking first that the SAX block is version 2\n-\n-Fri Oct 10 21:34:01 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c: fixed a nasty bug with interning some text strings\n-\t* configure.in: prepare for beta5 of 2.6.0\n-\t* libxml.h nanoftp.c nanohttp.c xmlIO.c include\/libxml\/xmlerror.h:\n-\t  better error handling for I\/O and converted FTP and HTTP\n-\t* parser.c: fixed another bug\n-\n-Fri Oct 10 16:45:20 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c: fixed uninitialized new field.\n-\t* result\/VC\/OneID2 result\/relaxng\/*.err: fixed a typo updating\n-\t  all messages\n-\n-Fri Oct 10 16:19:17 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/tree.h: make room in Doc, Element, Attributes\n-\t  for PSVI type information.\n-\n-Fri Oct 10 16:08:02 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c c14n.c catalog.c error.c globals.c parser.c\n-\t  parserInternals.c relaxng.c valid.c xinclude.c xmlIO.c xmlregexp.c\n-\t  xmlschemas.c xpath.c xpointer.c include\/libxml\/globals.h\n-\t  include\/libxml\/parser.h include\/libxml\/valid.h \n-\t  include\/libxml\/xmlerror.h: Setting up the framework for structured\n-\t  error reporting, touches a lot of modules, but little code now\n-\t  the error handling trail has been cleaned up.\n-\n-Fri Oct 10 14:29:42 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* c14n.c include\/libxml\/xmlerror.h: converted the C14N module too\n-\n-Fri Oct 10 13:40:51 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: cleanup\n-\t* xpointer.c include\/libxml\/xmlerror.h: migrated XPointer module\n-\t  to the new error mechanism\n-\n-Fri Oct 10 12:49:53 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c xmlschemas.c: a bit of cleanup\n-\t* result\/schemas\/*.err: updated with the new result strings\n-\n-Fri Oct 10 03:58:39 PDT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: fixed bug 124061\n-\n-Fri Oct 10 02:47:22 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: cleanup\n-\t* encoding.c: fix a funny typo\n-\t* error.c xmlschemas.c xmlschemastypes.c include\/libxml\/xmlerror.h:\n-\t  converted the Schemas code to the new error handling. PITA,\n-\t  still need to check output from regression tests.\n-\n-Thu Oct  9 15:13:53 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c include\/libxml\/xmlerror.h: converted too\n-\t* tree.c: small cleanup\n-\n-Thu Oct  9 13:44:57 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: comment fix\n-\t* catalog.c include\/libxml\/xmlerror.h: migrating the catalog code\n-\t  to the new infrastructure\n-\n-Thu Oct  9 00:36:03 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: final error handling cleanup\n-\t* xinclude.c error.c: converted XInclude to the new error handling\n-\t* include\/libxml\/xmlerror.h: added XInclude errors\n-\n-Wed Oct  8 23:31:23 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: bug in compression saving was crashing galeon\n-\t  reported by teuf\n-\n-Wed Oct  8 21:18:12 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c tree.c xmlIO.c xmllint.c: more cleanup through the\n-\t  I\/O error path\n-\n-Wed Oct  8 20:57:27 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: better handling of error cases\n-\n-Wed Oct  8 13:51:14 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c xmllint.c include\/libxml\/xmlerror.h: first pass at\n-\t  cleaning up error handling in the I\/O module.\n-\n-Wed Oct  8 10:52:05 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c include\/libxml\/xmlerror.h: error handling\n-\t  cleanup of the Regexp module.\n-\n-Wed Oct  8 01:09:05 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: converting the tree module too\n-\t* error.c include\/libxml\/xmlerror.h: created a simpler internal\n-\t  error reporting function.\n-\n-Tue Oct  7 23:19:39 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c include\/libxml\/xmlerror.h include\/libxml\/xpath.h\n-\t  include\/libxml\/xpathInternals.h xpath.c: cleaning up XPath\n-\t  error reporting that time. \n-\t* threads.c: applied the two patches for TLS threads\n-\t  on Windows from Jesse Pelton\n-\t* parser.c: tiny safety patch for xmlStrPrintf() make sure the\n-\t  return is always zero terminated. Should also help detecting\n-\t  passing wrong buffer size easily.\n-\t* result\/VC\/* result\/valid\/rss.xml.err result\/valid\/xlink.xml.err:\n-\t  updated the results to follow the errors string generated by\n-\t  last commit.\n-\n-Tue Oct  7 14:16:45 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c include\/libxml\/xmlerror.h: last cleanup of error\n-\t  handling in the Relax-NG module.\n-\n-Tue Oct  7 13:30:39 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c relaxng.c include\/libxml\/xmlerror.h: switched Relax-NG\n-\t  module to the new error reporting. Better default report, adds\n-\t  the element associated if found, context and node are included\n-\t  in the xmlError\n-\t* python\/tests\/reader2.py: the error messages changed.\n-\t* result\/relaxng\/*: error message changed too.\n-\n-Mon Oct  6 10:46:35 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/Makefile.bcb win32\/Makefile.mingw win32\/Makefile.msvc\n-\t  win32\/configure.js: applied patch from Stéphane Bidoul to\n-\t  fix the compilation of 2.6.0 code on Win32\n-\n-Mon Oct  6 10:16:30 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* check-xml-test-suite.py: fixing the script\n-\t* parser.c: replace sequences of RAW && NXT(.) == '.' with\n-\t  memcmp calls, seems to not break conformance, slightly inflate\n-\t  the size of the gcc generated code though.\n-\n-Sun Oct  5 23:30:48 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c parser.c valid.c include\/libxml\/parserInternals.h:\n-\t  more cleanup of error handling in parserInternals, sharing the\n-\t  routine for memory errors.\n-\n-Sun Oct  5 15:49:14 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c Makefile.am legacy.c parser.c parserInternals.c\n-\t  include\/libxml\/xmlerror.h: more code cleanup, especially around\n-\t  error messages, the HTML parser has now been upgraded to the new\n-\t  handling.\n-\t* result\/HTML\/*: a few changes in the resulting error messages\n-\n-Sat Oct  4 23:06:41 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c include\/libxml\/xmlerror.h: more error\/warning\n-\t  handling cleanups, the XML parser module should be okay now.\n-\n-Sat Oct  4 01:58:27 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am configure.in xmldwalk.c include\/libxml\/Makefile.am\n-\t  include\/libxml\/xmldwalk.h include\/libxml\/xmlversion.h.in:\n-\t  integrated the xmlDocWalker API given by Alfred Mickautsch,\n-\t  and providing an xmlReader like API but working on a xmlDocPtr.\n-\n-Sat Oct  4 00:18:29 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: more cleanup in make tests\n-\t* error.c valid.c parser.c include\/libxml\/xmlerror.h: more work\n-\t  in the transition to the new error reporting strategy.\n-\t* python\/tests\/reader2.py  result\/VC\/* result\/valid\/*:\n-\t  few changes in the strings generated by the validation output\n-\n-Fri Oct  3 00:19:02 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: changed 'make tests' to use a concise output,\n-\t  scrolling to see where thing broke wasn't pleasant\n-\t* configure.in: some beta4 preparation, but not ready yet\n-\t* error.c globals.c include\/libxml\/globals.h include\/libxml\/xmlerror.h:\n-\t  new error handling code, last error information are stored\n-\t  in the parsing context or a global variable, new APIs to\n-\t  handle the xmlErrorPtr type.\n-\t* parser.c parserInternals.c valid.c : started migrating to the\n-\t  new error handling code, it's a royal pain.\n-\t* include\/libxml\/parser.h include\/libxml\/parserInternals.h:\n-\t  moved the definition of xmlNewParserCtxt()\n-\t* parser.c: small potential buffer access problem in push code\n-\t  provided by Justin Fletcher\n-\t* result\/*.sax result\/VC\/PENesting* result\/namespaces\/*\n-\t  result\/valid\/*.err: some error messages were slightly changed.\n-\n-Thu Oct  2 13:01:13 2003  Aleksey Sanin  <aleksey@aleksey.com>\n-\n-\t* include\/libxml\/parser.h parser.c: introduced xmlStrPrintf\n-\tfunction (wrapper around snprintf)\n-\n-Wed Oct  1 21:12:06 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* entities.c: Fix error on output of high codepoint charref like\n-\t  &#x10FFFF; , reported by Eric Hanchrow\n-\n-Wed Oct  1 14:20:10 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* DOCBparser.c include\/libxml\/DOCBparser.h: let's see how much\n-\t  of a pain murrayc is really gonna be.\n-\n-Wed Oct  1 11:03:40 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: Applied fix for bug #123481 reported by Peter Derr\n-\n-Tue Sep 30 15:34:31 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* entities.c legacy.c parser.c: made the predefined entities\n-\t  static predefined structures to avoid the work, memory and\n-\t  hazards associated to initialization\/cleanup.\n-\n-Tue Sep 30 14:30:47 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c Makefile.am configure.in legacy.c parser.c\n-\t  parserInternals.c testHTML.c xmllint.c include\/libxml\/HTMLparser.h\n-\t  include\/libxml\/parser.h include\/libxml\/parserInternals.h\n-\t  include\/libxml\/xmlversion.h.in: added a new configure\n-\t  option --with-push, some cleanups, chased code size anomalies.\n-\t  Now a library configured --with-minimum is around 150KB,\n-\t  sounds good enough.\n-\n-Tue Sep 30 12:31:00 AEST 2003 Malcolm Tredinnick <malcolm@commsecure.com.au>\n-\n-\t* libxml-2.0-uninstalled.pc.in: New file for building against\n-\tuninstalled libxml2 builds.\n-\t* configure.in, Makefile.am: Support the *-uninstalled.pc file.\n-\t* .cvsignore: Ignore the new generated *.pc file.\n-\n-Tue Sep 30 02:38:16 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am SAX.c SAX2.c configure.in globals.c parser.c\n-\t  parserInternals.c testReader.c testSAX.c xmlIO.c xmllint.c\n-\t  xmlreader.c example\/gjobread.c include\/libxml\/xmlversion.h.in:\n-\t  added 2 new configure option: --with-reader --with-sax1\n-\t  to allow removing the reader or non-xmlReadxxx() interfaces.\n-\n-Mon Sep 29 19:58:26 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in entities.c tree.c valid.c xmllint.c\n-\t  include\/libxml\/tree.h include\/libxml\/xmlversion.h.in:\n-\t  Adding a configure option to remove tree manipulation\n-\t  code which is not strictly needed by the parser.\n-\n-Mon Sep 29 15:23:41 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanoftp.c nanohttp.c: last finishing touch to the BeOS\n-\t  patch from Marcin 'Shard' Konicki\n-\n-Mon Sep 29 15:15:08 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c SAX2.c c14n.c catalog.c configure.in debugXML.c\n-\t  encoding.c entities.c nanoftp.c nanohttp.c parser.c relaxng.c\n-\t  testAutomata.c testC14N.c testHTML.c testRegexp.c testRelax.c\n-\t  testSchemas.c testXPath.c threads.c tree.c valid.c xmlIO.c\n-\t  xmlcatalog.c xmllint.c xmlmemory.c xmlreader.c xmlschemas.c\n-\t  example\/gjobread.c include\/libxml\/HTMLtree.h include\/libxml\/c14n.h\n-\t  include\/libxml\/catalog.h include\/libxml\/debugXML.h\n-\t  include\/libxml\/entities.h include\/libxml\/nanohttp.h\n-\t  include\/libxml\/relaxng.h include\/libxml\/tree.h\n-\t  include\/libxml\/valid.h include\/libxml\/xmlIO.h\n-\t  include\/libxml\/xmlschemas.h include\/libxml\/xmlversion.h.in\n-\t  include\/libxml\/xpathInternals.h python\/libxml.c:\n-\t  Okay this is scary but it is just adding a configure option\n-\t  to disable output, this touches most of the files.\n-\n-Mon Sep 29 12:53:56 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlmemory.c: better fix, avoids breaking the python bindings\n-\n-Mon Sep 29 11:21:33 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlmemory.c: fix a compilation problem when configuring\n-\t  with debug but without mem-debug\n-\n-Sun Sep 28 20:53:17 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: cleanup, creating a new legacy.c module,\n-\t  made sure make tests ran in reduced conditions\n-\t* SAX.c SAX2.c configure.in entities.c globals.c parser.c\n-\t  parserInternals.c tree.c valid.c xlink.c xmlIO.c xmlcatalog.c\n-\t  xmlmemory.c xpath.c xmlmemory.c include\/libxml\/xmlversion.h.in:\n-\t  increased the modularization, allow to configure out \n-\t  validation code and legacy code, added a configuration\n-\t  option --with-minimum compiling only the mandatory code\n-\t  which then shrink to 200KB.\n-\n-Sun Sep 28 02:15:07 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fix a bug raised by the Mips compiler.\n-\t* include\/libxml\/SAX.h include\/libxml\/parser.h: move the \n-\t  SAXv1 block definitions to parser.h fixes bug #123380\n-\t* xmlreader.c include\/libxml\/xmlreader.h: reinstanciate\n-\t  the attribute and element pool broken 2 commits ago.\n-\t  Start playing with an entry point to preserve a subtree.\n-\t* entities.c: remove a warning.\n-\n-Sat Sep 27 12:19:38 PDT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* encoding.c, parser.c, relaxng.c: further (final?) minor\n-\t  changes for compilation warnings. No change to logic.\n-\n-Fri Sep 26 18:03:42 PDT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* parser.c: fixed small problem with missing entities (test\/ent2)\n-\n-Sat Sep 27 01:25:39 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: William's change allowed to spot a nasty bug in xmlDoRead\n-\t  if the result is not well formed that ctxt->myDoc is not NULL\n-\t  and uses the context dictionary.\n-\n-Fri Sep 26 21:09:34 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: other patches from William Brack to avoid\n-\t  compilation warnings on AIX.\n-\n-Fri Sep 26 11:03:08 PDT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* HTMLparser.c, entities.c, xmlreader.c: minor change to\n-\t  avoid compilation warnings on some (e.g. AIX) systems\n-\n-Fri Sep 26 16:49:25 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c: fixed a backward compatibility problem\n-\t  when formatting \"deprecated SAXv1 function ignorableWhitespace\"\n-\t  could be reproduced by xmllint --format\n-\n-Fri Sep 26 15:50:44 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/libxml2-api.xml: rebuilt the API\n-\t* xmllint.c doc\/xmllint.1 doc\/xmllint.xml: added the new options\n-\t  --nocdata and --nsclean to remove CDATA section and surperfluous\n-\t  namespace declarations\n-\t* parser.c SAX2.c: implementation of the 2 new options\n-\n-Fri Sep 26 14:41:53 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c testHTML.c xmllint.c include\/libxml\/HTMLparser.h:\n-\t  added the same htmlRead APIs than their XML counterparts\n-\t* include\/libxml\/parser.h: new parser options, not yet implemented,\n-\t  added an options field to the context.\n-\t* tree.c: patch from Shaun McCance to fix bug #123238 when ]]>\n-\t  is found within a cdata section.\n-\t* result\/noent\/cdata2 result\/cdata2 result\/cdata2.rdr\n-\t  result\/cdata2.sax test\/cdata2: add one more cdata test\n-\n-Thu Sep 25 23:03:23 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c xmllint.c doc\/libxml2-api.xml include\/libxml\/parser.h:\n-\t  Changed the new xmlRead\/xmlCtxtRead APIs to have an extra\n-\t  base URL parameter when not loading from a file or URL.\n-\n-Thu Sep 25 16:23:58 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: preparing a beta3 solving the ABI problems\n-\t* globals.c parser.c parserInternals.c testHTML.c HTMLparser.c SAX.c\n-\t  include\/libxml\/globals.h include\/libxml\/SAX.h: make sure the\n-\t  global variables for the default SAX handler are V1 ones to\n-\t  avoid ABI compat problems.\n-\t* xmlreader.c: cleanup of unneeded code\n-\t* hash.c: fix a comment\n-\n-Thu Sep 25 14:16:51 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c hash.c parser.c include\/libxml\/xmlexports.h \n-\t  include\/libxml\/xmlmemory.h include\/libxml\/xmlversion.h.in:\n-\t  fixing some comments to avoid warnings from apibuild.py\n-\n-Wed Sep 24 23:42:08 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/configure.js: patch from Stéphane Bidoul for configuring\n-\t  the beta2 version #123104\n-\n-Wed Sep 24 23:17:59 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: adding repeated parsing and validating tests\n-\t* SAX2.c parser.c tree.c include\/libxml\/parser.h: make the new\n-\t  DOM tree building interfaces use the dictionary from the \n-\t  parsing context to build the element and attributes names\n-\t  as well as formatting spaces and short text nodes\n-\t* include\/libxml\/dict.h dict.c: added some reference counting\n-\t  for xmlDictPtr because they can be shared by documents and\n-\t  a parser context.\n-\t* xmlreader.c: a bit of cleanup, remove the specific tree freeing\n-\t  functions and use the standard ones now.\n-\t* xmllint.c: add --nodict\n-\t* python\/libxml.c: fix a stupid bug so that ns() works on \n-\t  attribute nodes.\n-\n-Tue Sep 23 23:07:45 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c include\/libxml\/parser.h: adding a new set of\n-\t  API for parsing xmlReadDoc() xmlReadFile() ... xmlReadIO()\n-\t  and xmlCtxtReadDoc() ... xmlCtxtReadIO(). That with\n-\t  a clear define of xmlParserOption, xmlCtxtUseOptions()\n-\t  should simplify custom parsing without being tempted to\n-\t  use global variables, and xmlCtxtReset() should allow reuse\n-\t  of a context for multiple parsing.\n-\t* xmllint.c: switched to use xmlReadXXX, allow options to\n-\t  be used simultaneously with less troubles.\n-\t* tree.c: simple warning removal\n-\t* doc\/apibuild.py: small fix\n-\t* doc\/libxml2-api.xml win32\/libxml2.def.src: updated\n-\n-Tue Sep 23 11:15:23 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: revert xmlCreateDocParserCtxt() since this break\n-\t  the parseDoc() python bindings\n-\n-Tue Sep 23 11:00:18 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: make sure xmlDetectSAX2() is called only at \n-\t  parsing time to avoid breaking apps changing the SAX\n-\t  callbacks after context allocation, change xmlCreateDocParserCtxt()\n-\t  to use an immutable buffer instead of a copy\n-\n-Tue Sep 23 09:40:33 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: applied patch from Markus Keim fixing a problem\n-\t  with I\/O callback registration.\n-\t* include\/libxml\/xmlerror.h: fixed #122994 comment numbering\n-\t  for xmlParserErrors\n-\n-Mon Sep 22 12:21:11 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c include\/libxml\/tree.h: the uri arg to xmlNodeSetBase is\n-\t  really a const xmlChar*\n-\t* xmlreader.c include\/libxml\/xmlreader.h: addin the\n-\t  xmlTextReaderConstString() to get an interned string from\n-\t  the reader\n-\n-Sun Sep 20 17:22:20 PDT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* error.c: fixed a warning message (trivial)\n-\t* doc\/search.php: removed incorrect warning message when word\n-\t  search not found in last of multiple tables (bug 119535)\n-\n-Fri Sep 19 14:26:28 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: preparing a 2.6.0-beta2 release\n-\t* xmlIO.c: avoid a warning\n-\t* tree.c: avoid duplicate code in xmlReplaceNode as pointed out\n-\t  by Chris Ryland\n-\t* include\/libxml\/dict.h: add a QName access lookup to the\n-\t  dictionary.\n-\t* xmlreader.c include\/libxml\/xmlreader.h: adding const access\n-\t  based on the dictionary interface for string read from the\n-\t  reader, the node content access is still TODO, it's too different\n-\n-Fri Sep 19 00:01:08 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c: fixing namespace DTD validations\n-\t* result\/valid\/ns2.xml result\/valid\/ns.xml: the output of defaulted\n-\t  namespaces is slightly different now.\n-\t* Makefile.am: report the memory used in Timingtests (as well as time)\n-\n-Thu Sep 18 15:29:46 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: add streaming on memory regression tests, found\n-\t  bad bugs in the reader interface\n-\t* xmlreader.c: fixing bugs w.r.t. very large names, and special\n-\t  condition in end of file.\n-\t* xmlIO.c tree.c include\/libxml\/tree.h include\/libxml\/xmlIO.h:\n-\t  adding immutable buffers, and parser input based on those,\n-\t  but this should not be used (yet) for general parsing\n-\t* parser.c: added a comment about using immutable buffers for\n-\t  general parsing.\n-\t* result\/bigname.xml.rdr result\/bigname2.xml.rdr: fixing the\n-\t  output of the regression tests\n-\t* xmllint.c: using the immutable buffers when streaming on\n-\t  mmaped file (--stream --memory)\n-\n-Thu Sep 18 12:04:50 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* dict.c: the last patch broke unicity of returned strings, removed\n-\n-Thu Sep 18 00:31:02 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: add a Timingtests target to check bad behaviour\n-\t  from the streaming engine\n-\t* dbgen.pl dbgenattr.pl: perl script to generate big instances\n-\t* xmlreader.c: fix a bad behaviour on large buffer inputs\n-\n-Wed Sep 17 23:25:47 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* dict.c xmlreader.c: two small improvements\n-\n-Wed Sep 17 22:53:32 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c: avoid a leak with previous patch\n-\n-Wed Sep 17 22:06:11 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c: use stderr and not stdout for default errors\n-\t  in python environment bug #122552\n-\n-Wed Sep 17 21:33:57 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c: small fix from Rob Richards for input filename\n-\t* xmllint.c: fixes for --repeat and --memory\/--stream for speed tests\n-\t* xmlIO: adding a guard in one function\n-\n-Wed Sep 17 15:57:44 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c xmlreader.c include\/libxml\/parser.h: more performance hunting\n-\t  reducing memory allocation and free and avoiding expensive routines\n-\n-Wed Sep 17 12:23:41 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c parser.c parserInternals.c xmlreader.c: started messing\n-\t  seriously with per-document dict and element and attribute nodes\n-\t  reuse in the xmlReader. This seems to lead to an interesting\n-\t  speedup of the xmlReader already.\n-\n-Wed Sep 17 01:07:56 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* dict.c include\/libxml\/dict.h: do string allocations in large\n-\t  pools, allowing to find if a string pertain to a dict quickly\n-\t* xmllint.c: fix --stream --repeat --timing\n-\t* Makefile.am: the testThreads run output should be seen.\n-\n-Mon Sep 15 16:46:28 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c include\/libxml\/parser.h: starting work on reusing the\n-\t  parser dictionary for the element and attribute tag names.\n-\t  Add pools for Element and Attributes in the parser context,\n-\t  which should help speeding up the reader.\n-\t* Makefile.am result\/*.rdr : adding non-python reader regression\n-\t  tests.\n-\n-Mon Sep 15 14:54:42 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c parser.c valid.c: starting to cleanup some of the\n-\t  problems exposed by the W3C\/NIST regression suite.\n-\t* result\/ent7.sax result\/xml2.sax: small fixes.\n-\n-Mon Sep 15 11:46:47 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: more parser error factoring\n-\n-Sun Sep 14 21:53:39 PDT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* HTMLtree.c: Fixed bug 121394 - missing ns on attributes\n-\n-Sun Sep 14 21:43:32 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c include\/libxml\/xmlerror.h: factoring of more \n-\t  error handling code, serious size reduction and more lisibility\n-\t  of the resulting code.\n-\t* parserInternals.c parser.c include\/libxml\/parserInternals.h\n-\t  include\/libxml\/parser.h: changing the way VC:Proper Group\/PE Nesting\n-\t  checks are done, use a counter for entities. Entities where freed and\n-\t  reallocated at the same address failing the check.\n-\t* tree.c: avoid a warning\n-\t* result\/valid\/* result\/VC\/*: this slightly changes some validation\n-\t  error messages.\n-\n-Sun Sep 14 11:03:27 PDT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* valid.c: fixed bug 121759 - early declaration of\n-\t  attribute-list in external DTD\n-\n-Sat Sep 13 14:42:11 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c include\/libxml\/xmlerror.h: starting cleaning up\n-\t  error handling, factorize error processing\n-\t* doc\/xmllint.html: update of the page, remove --sgml\n-\n-Sat Sep 13 02:13:50 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am DOCBparser.c parserInternals.c testDocbook.c\n-\t  xmllint.c doc\/xmllint.xml doc\/xmllint.1: removing the \n-\t  broken pseudo SGML DocBook parser code.\n-\n-Fri Sep 12 17:24:11 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fix a problem with strcpy() in xmlXPathFormatNumber()\n-\t  valgrind pointed out the strings overlapped. cleanup .\n-\n-Fri Sep 12 11:43:12 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: applied speedup to xmlSearchNs() as suggested by\n-\t  Luca Padovani. Cleaned up xmlSearchNsByHref() in the process\n-\t  applying the same trick.\n-\n-Fri Sep 12 01:36:20 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c parserInternals.c tree.c include\/libxml\/parser.h\n-\t  include\/libxml\/xmlerror.h: adding namespace checkings\n-\t  while making sure they still parse as wellformed documents.\n-\t  Add an nsWellFormed status report to the context, and \n-\t  provide new appropriate error codes.\n-\t* Makefile.am result\/namespaces\/* test\/namespaces\/*: add \n-\t  specific regression testing for the new namespace support\n-\t* test\/att5 result\/noent\/att5 result\/att5 result\/att5.sax:\n-\t  add more coverage for the attribute parsing and normalization\n-\t  code.\n-\n-Fri Sep 12 01:34:19 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* threads.c: backport of a thread bugfix from 2_5_X branch\n-\n-Thu Sep 11 18:29:18 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed a bug in one corner case of attribute parsing.\n-\n-Thu Sep 11 16:21:53 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in doc\/* : 2.6.0beta1 changes\n-\t* SAX2.c hash.c parser.c parserInternals.c: Fixing attribute\n-\t  normalization, might not be totally fixed but this should \n-\t  make sure SAX event provide the right strings for attributes\n-\t  except entities for which libxml2 is different by default\n-\t  This should fix #109564\n-\t* result\/attrib.xml.sax result\/ent3.sax result\/p3p.sax: minor changes\n-\t  in attribute callback values\n-\t* result\/c14n\/with-comments\/example-4\n-\t  result\/c14n\/without-comments\/example-4: this also fixes a subtle\n-\t  bug in the canonicalization tests.\n-\n-Wed Sep 10 12:38:44 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\tTime to commit 3 days of work rewriting the parser internal,\n-\tfixing bugs and migrating to SAX2 interface by default. There\n-\tis some work letf TODO, like namespace validation and attributes\n-\tnormalization (this break C14N right now)\n-\t* Makefile.am: fixed the test rules\n-\t* include\/libxml\/SAX2.h include\/libxml\/parser.h\n-\t  include\/libxml\/parserInternals.h SAX2.c parser.c\n-\t  parserInternals.c: changing the parser, migrating to SAX2,\n-\t  adding new interface to switch back to SAX1 or initialize a\n-\t  SAX block for v1 or v2. Most of the namespace work is done\n-\t  below SAX, as well as attribute defaulting\n-\t* globals.c: changed initialization of the default SAX handlers\n-\t* hash.c tree.c include\/libxml\/hash.h: added QName specific handling\n-\t* xmlIO.c: small fix\n-\t* xmllint.c testSAX.c: provide a --sax1 switch to test the old\n-\t  version code path\n-\t* result\/p3p result\/p3p.sax result\/noent\/p3p test\/p3p: the new code\n-\t  pointed out a typo in a very old test namespace\n-\n-Sun Sep  7 19:58:33 PTD 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xmlIO.c include\/libxml\/xmlIO.h parser.c: Implemented detection\n-\t  of compressed files, setting doc->compressed appropriately\n-\t  (bug #120503).\n-\n-Sun Sep  7 22:53:06 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: try to cope with the fact that apps may still\n-\t  have allocated smaller SAX callbak block\n-\n-Sun Sep  7 11:11:45 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* dict.c: allow to give -1 for undefined length in lookups\n-\t* include\/libxml\/parser.h parser.c parserInternals.c testSAX.c:\n-\t  first round of work on the new SAX2 interfaces, the API\n-\t  will change but committing before changing for historical\n-\t  reference.\n-\n-Sat Sep  6 10:55:01 PTD 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* SAX2.c, xmlIO.c: fixed bug #121210 (callback to sax->error,\n-\t  sax->warning with wrong params).\n-\n-Fri Sep  5 10:33:42 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/globals.h: patch from Stéphane Bidoul to export\n-\t  globals entry points to the python bindings\n-\n-Wed Sep  3 15:24:41 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: when creating a DOCTYPE use \"html\" lowercase\n-\t  by default instead of \"HTML\"\n-\t* parser.c xmlreader.c: optimization, gain a few % parsing speed by\n-\t  avoiding calls to \"areBlanks\" when not needed.\n-\t* include\/libxml\/parser.h include\/libxml\/tree.h: some structure\n-\t  extensions for future work on using per-document dictionaries.\n-\n-Wed Sep  3 15:08:06 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am results\/*.sax SAXResult\/*: removing the SAXresults\n-\t  tree, keeping result in the same tree, added SAXtests to the\n-\t  default \"make tests\"\n-\n-Tue Sep  2 15:59:04 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* include\/libxml\/xmlexports.h: defined additional macros which\n-\t  affect exports and added mingw section\n-\n-Mon Sep  1 15:15:18 PDT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/index.py: fixed problem parsing xhtml docs\n-\t* doc\/xmlreader.html,doc\/guidelines.html: small modification\n-\t  to avoid problem in python parsing.\n-\t* doc\/search.php: fixed upper case filename problem for XSLT docs\n-\n-Mon Sep  1 22:55:09 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: patch from Mark Vakoc that allows compiling \n-\t  with XInclude but without XPointer support.\n-\n-Mon Sep  1 22:31:38 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in xml2-config.in: Applied a patch from Kevin P. Fleming\n-\t  to add --libtool-libs option to xml2-config script.\n-\n-Sun Aug 31 21:52:12 PDT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/README.docs, doc\/Makefile.am: new file added,\n-\t  giving some description of the documentation generation process\n-\t* doc\/search.php: fixed problem with upper case on filenames\n-\n-Fri Aug 29 12:25:01 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/Makefile.bcb: updates by Eric Zurcher\n-\n-Thu Aug 28 22:58:38 PDT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/apibuild.py, doc\/libxml2-api.xml: enhanced code\n-\t  to compensate for pollution from Igor's header taint\n-\t  (quick before Daniel notices)\n-\n-Thu Aug 28 23:01:36 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX2.c: fixed a namespace error on attribute reporting bug\n-\t  pointed out by Tobias Reif\n-\t* test\/p3p result\/p3p result\/noent\/p3p: this test case was wrong\n-\t  using xmlsn instead of xmlns...\n-\n-Thu Aug 28 18:25:07 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* include\/libxml\/globals.h include\/libxml\/xmlexports.h: fixed\n-\t  typos reported by Mark Vakoc\n-\n-Thu Aug 28 08:59:51 MDT 2003 John Fleck <jfleck@inkstain.net>\n-\n-\tadd:\n-\t* doc\/tutorial\/api.html\n-\t* doc\/tutorial\/ar01s09.html\n-\t* doc\/tutorial\/includexpath.c\n-\tupdated\n-\t* doc\/tutorial\/*.html\n-\tfix my bad - forgot to check in new files when I last\n-\tupdated\n-\n-Thu Aug 28 14:31:13 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/Makefile.bcb: new file, support for Borland C++\n-\t* xmllint.c: fixed time inclusion for various compilers\n-\n-Thu Aug 28 12:32:59 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* parser.c parserInternals.c DOCBparser.c HTMLparser.c: added\n-\t  few casts to shut the compiler warnings\n-\n-Thu Aug 28 12:23:51 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/Makefile.* win32\/configure.js: fixed for mingw\n-\n-Thu Aug 28 10:01:44 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* globals.c threads.c: fixing bug #120870 try to avoid problem\n-\t  with uninitialized mutexes\n-\n-Wed Aug 27 16:12:41 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: fixed an error reporting bug in Relax-NG when we end\n-\t  up with multiple states, select the \"best\" one. Fix #120682\n-\t* result\/relaxng\/tutor11_2_3.err: small change resulting \n-\n-Wed Aug 27 11:25:25 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: applied base64 support patch from Anthony Carrico\n-\n-Wed Aug 27 10:58:51 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* include\/libxml\/[threads-xpointer].h: realigned parameters\n-\t  after taint\n-\n-Wed Aug 27 09:59:54 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* include\/libxml\/xmlexports.h: fixed defs for Borland compiler,\n-\t  as reported by Eric Zurcher\n-\n-Tue Aug 26 15:54:04 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: fixed bug #120386 again a problem introduced when\n-\t  trying to reuse automata for content validation. Fix a bug report\n-\t  problem on zeroOrMore\n-\t* result\/relaxng\/tutor3_7_err: change slightly error reporting.\n-\n-Mon Aug 25 13:24:57 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/Makefile.am: make sure the new header will\n-\t  be included when generating a new distribution.\n-\n-Mon Aug 25 12:37:05 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: fixed a couple of stupid bugs in the state allocation\n-\t  routines which led to bug #120040 and the ones reported by\n-\t  Martijn Faassen\n-\n-Mon Aug 25 12:37:23 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* include\/libxml\/parserInternals.h include\/libxml\/relaxng.h\n-\t  include\/libxml\/SAX.h include\/libxml\/SAX2.h: realigned the\n-\t  parameters after taint.\n-\n-Mon Aug 25 11:16:01 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* include\/libxml\/xmlversion.h.in: moved export defs to a separate\n-\t  file for consistency.\n-\t* include\/libxml\/xmlexports.h: new file, contains export defs.\n-\n-Mon Aug 25 11:01:49 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* include\/libxml\/*.h genUnicode.py: exportability taint\n-\t  of the headers.\n-\n-Thu Aug 21 12:37:46 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: make the deprecated interfaces log an error message\n-\t  to be sure it won't get used.\n-\n-Thu Aug 21 00:50:32 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am SAX2.c include\/libxml\/Makefile.am include\/libxml\/SAX2.h:\n-\t  Adding new version of the SAX interface, it's not there yet,\n-\t  currently just preparing the work\n-\t* globals.c parser.c SAX.c include\/libxml\/SAX.h \n-\t  include\/libxml\/globals.h include\/libxml\/parser.h: doing some\n-\t  refactoring of the SAXv1 interfaces, obsoleting a bunch of them\n-\t  while keeping functionalities, preparing SAX2 integration.\n-\t* dict.c: small cleanup.\n-\n-Wed Aug 20 00:20:01 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fixes a small bug introduced in last commit and detected\n-\t  by valgrind.\n-\n-Tue Aug 19 16:54:18 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* dict.c hash.c: optimization when freeing hash tables.\n-\t* parser.c xmlIO.c include\/libxml\/tree.h: some tuning of buffer\n-\t  allocations\n-\t* parser.c parserInternals.c include\/libxml\/parser.h: keep a\n-\t  single allocated block for all the attributes callbacks,\n-\t  avoid useless malloc()\/free()\n-\t* tree.c: do not realloc() when growing a buffer if the buffer\n-\t  ain't full, malloc\/memcpy\/free avoid copying memory.\n-\n-Mon Aug 18 18:37:01 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c doc\/xmllint.xml doc\/xmllint.1: added option\n-\t  --dtdvalidfpi for Tobias Reif\n-\n-Mon Aug 18 14:03:03 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* dict.c include\/libxml\/dict.h Makefile.am include\/libxml\/Makefile.am:\n-\t  new dictionary module to keep a single instance of the names used\n-\t  by the parser\n-\t* DOCBparser.c HTMLparser.c parser.c parserInternals.c valid.c:\n-\t  switched all parsers to use the dictionary internally\n-\t* include\/libxml\/HTMLparser.h include\/libxml\/parser.h\n-\t  include\/libxml\/parserInternals.h include\/libxml\/valid.h:\n-\t  Some of the interfaces changed as a result to receive or return\n-\t  \"const xmlChar *\" instead of \"xmlChar *\", this is either\n-\t  insignificant from an user point of view or when the returning\n-\t  value changed, those function are really parser internal methods\n-\t  that no user code should really change\n-\t* doc\/libxml2-api.xml doc\/html\/*: the API interface changed and\n-\t  the docs were regenerated\n-\n-Sun Aug 17 23:05:38 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: applied patch to xmlCleanupParser from Dave Beckett\n-\n-Sat Aug 16 22:53:42 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/parsedecl.py, doc\/libxml2-refs.xml, doc\/API*.html:\n-\t  fixed part (2) of bug 119535 (wrong alpha case on filenames)\n-\n-Sat Aug 16 20:35:28 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/API*.html, doc\/html\/*: regenerated API documentation\n-\t  for xmlsoft.org (part of Bug 119535)\n-\n-Fri Aug 15 14:58:37 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* encoding.c, threads.c, include\/libxml\/HTMLparser.h,\n-\t  doc\/libxml2-api.xml: Minor changes to comments, etc. for\n-\t  improving documentation generation\n-\t* doc\/Makefile.am: further adjustment to auto-generation of\n-\t  win32\/libxml2.def.src\n-\n-Fri Aug 15 02:24:20 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* News configure.in: preparing libxml2-2.5.10 release\n-\t* doc\/* : updated the doc and rebuilt\n-\n-Fri Aug 15 01:55:53 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixing the xmlSAXParseDTD bug #119536 raised by\n-\t  Malcolm Tredinnick with the patch he suggested.\n-\n-Fri Aug 15 01:37:10 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: allocation error #119784 raised by Oliver Stoeneberg\n-\n-Fri Aug 15 00:41:58 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: fixing an use of strcpy() where both strings overlap\n-\t  pointed out by valgrind.\n-\n-Thu Aug 14 17:10:39 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* DOCBparser.c globals.c include\/libxml\/xmlmemory.h: get rid of\n-\t  some compilation warnings.\n-\t* xinclude.c: fix the performance problem reported by Kevin Ruscoe\n-\t  plus some cleanup and better error reporting.\n-\n-Thu Aug 14 14:13:43 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: applied UTF-16 encoding handling patch provided by\n-\t  Mark Itzcovitz\n-\t* encoding.c parser.c: more cleanup and fixes for UTF-16 when \n-\t  not having iconv support.\n-\n-Thu Aug 14 03:19:08 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am configure.in example\/Makefile.am libxml.h nanoftp.c\n-\t  nanohttp.c xmllint.c: Applied patch from Mikhail Grushinskiy for\n-\t  mingw compiler on Windows.\n-\n-Thu Aug 14 02:28:36 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed the serious CPU usage problem reported by\n-\t  Grant Goodale\n-\t* HTMLparser.c: applied patch from Oliver Stoeneberg about a free\n-\t  missing in htmlSAXParseDoc\n-\n-Tue Aug 12 22:48:10 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* doc\/Makefile.am: Removed dependency from libxml2.def.src\n-\n-Tue Aug 12 18:55:08 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* autogen.sh: took away the requirement for automake-1.4,\n-\t  changed the messages for getting auto* tools to current\n-\t  gnu pages.\n-\t* configure.in: added check for Linux Dec alpha requiring\n-\t  -ieee flag, fixed test for ipv6\n-\t* trionan.c: fixed problem for compiling on Linux Dec alpha\n-\t  using native compiler\n-\t* doc\/Makefile.am: implemented regeneration of win32\/libxml2.def.src\n-\t  whenever libxml2-api.xml is changed.\n-\n-Mon Aug 11 17:02:23 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: cleaning up a problem when parsing UTF-16 and libiconv\n-\t  is not used.\n-\n-Sun Aug 10 08:13:22 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* win32\/libxml2.def.src: renerated with fixed libxml2-api.xml\n-\n-Sun Aug 10 00:22:55 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* News configure.in: preparing libxml2-2.5.9 release\n-\t* doc\/* : updated the doc and rebuilt\n-\n-Sat Aug  9 20:00:13 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlreader.h doc\/libxml2-api.xml: changing an enum\n-\t  definition to get a correct API XML description. This was apparently\n-\t  breaking Windows build.\n-\n-Sat Aug  9 13:41:21 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fixed a nasty bug #119387, bad heuristic from\n-\t  the progressive HTML parser front-end on large character data\n-\t  island leading to an erroneous end of data detection by the\n-\t  parser. Some cleanup too to get closer from the XML progressive\n-\t  parser.\n-\n-Sat Aug  9 00:42:47 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* win32\/configure.js: Added in support for the ISO8859X\n-\t  module (patch provided by Jesse Pelton)\n-\n-Fri Aug  8 15:56:32 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c tree.c threads.c: hum try to avoid some troubles\n-\t  when the library is not initialized and one try to save, the \n-\t  locks in threaded env might not been initialized, playing safe\n-\t* xmlschemastypes.c: apply patch for hexBinary from Charles Bozeman\n-\t* test\/schemas\/hexbinary_* result\/schemas\/hexbinary_*: also added\n-\t  his tests to the regression suite.\n-\n-Fri Aug  8 18:47:38 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* win32\/defgen.xsl, win32\/libxml2.def.src: Bug 119343\n-\t  (with apologies to Igor) - Enhanced handling of docb and\n-\t  nanohttp.\n-\n-Thu Aug  7 21:13:22 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* encoding.c: further small changes for warnings when\n-\t  configured with --with-iconv=no\n-\n-Wed Aug  6 12:32:11 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* error.c trionan.[ch] testThreads.c python\/generator.py:\n-\t  further small changes to eliminate most of the remaining\n-\t  warnings.\n-\n-Tue Aug  5 23:51:21 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* error.c HTMLparser.c testC14N.c testHTML.c testURI.c\n-\t  xmlcatalog.c xmlmemory.c xmlreader.c xmlschemastypes.c\n-\t  python\/libxml.c include\/libxml\/xmlmemory.h: small changes\n-\t  to syntax to get rid of compiler warnings.  No changes\n-\t  to logic.\n-\n-Mon Aug  4 22:40:54 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/libxml2-api.xml doc\/html\/*: rebuilt the API and docs.\n-\n-Mon Aug  4 21:40:34 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fixed a small problem in the patch for #118763\n-\t* result\/HTML\/doc3.htm*: this reverts back to the previous result\n-\n-Sun Aug  3 21:41:49 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/FAQ.html doc\/xml.html: applied doc patch to xml.html\n-\t  and rebuilt, apparently some C++ wrappers are not available,\n-\t  c.f. bug #118943\n-\n-Sun Aug  3 21:30:31 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fixing HTML attribute serialization bug #118763\n-\t  applying a modified version of the patch from Bacek\n-\t* result\/HTML\/doc3.htm*: this modifies the output from one test\n-\n-Sun Aug  3 21:02:30 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c include\/libxml\/tree.h: added a new API to split a\n-\t  QName without generating any memory allocation\n-\t* valid.c: fixed another problem with namespaces on element\n-\t  in mixed content case\n-\t* python\/tests\/reader2.py: updated the testcase with \n-\t  Bjorn Reese fix to reader for insignificant white space\n-\t* parser.c HTMLparser.c: cleanup.\n-\n-Sun Aug  3 20:55:40 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: trying to fix #118754 of possible recursion in the\n-\t  catalogs. Not fantastically happy about the current fix since\n-\t  it's likely to break under very thread intensive concurrent\n-\t  access to the catalog. Better solution might to keep the depth\n-\t  an extra argument to the resolution functions.\n-\n-Sun Aug  3 18:56:54 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: fixed bug #118712 about mixed content, and namespaced\n-\t  element names.\n-\t* test\/valid\/mixed_ns.xml result\/valid\/mixed_ns*: added a check\n-\t  in the regression tests\n-\n-Fri Aug 1 23:55:23 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\tConinuing work on bug 118559\n-\t* DOCBparser.c: removed 2 unused vars\n-\t* xmlregexp.c: changed some numeric const to their enum symbols\n-\t* xmlreader.c: changed one var define from int to enum\n-\t  (a little more to be done, awaiting co-ordination)\n-\t* relaxng.c: deleted one unused var\n-\t* xmllint.c: deleted some unused vars, changed one arg\n-\t  val from int to enum\n-\t* testHTML.c, testDocbook.c: changed some arg vals to enum const\n-\t* xmlIO.c: fixed typo from last night (small warning msg)\n-\n-Thu Jul 31 22:44:33 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\tWorking on bug 118559\n-\t* error.c: deleted unused variable\n-\t* parserInternals.c: deleted unneeded 'const' qualifier\n-\t* parser.c: changed variable type for enum temp storage\n-\t* xmlIO.c: changed debugging var to be inside #ifdef\n-\t* valid.c: removed unused variable\n-\t* HTMLparser.c: removed some unneeded 'const' qualifiers\n-\t* xpath.c: added some type casts, removed some unused vars\n-\t* xinclude.c: added one type cast\n-\t* nanohttp.c: repositioned some #ifdef to avoid unused var\n-\t* nanoftp.c: removed unused var\n-\n-Wed Jul 30 14:57:55 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: applied a patch from William Brack about\n-\t  the problem of parsing very large HTML instance with comments\n-\t  as raised by Nick Kew\n-\n-Wed Jul 30 12:29:38 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c include\/libxml\/xmlreader.h: applying cleanup\n-\t  patch from Bjorn Reese for xmlTextReaderNodeType() and \n-\t  significant whitespace. There is an enum for node type\n-\t  values now.\n-\n-Wed Jul 30 11:08:21 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: applying patch from Peter Jacobi to added \n-\t  ISO-8859-x encoding support when iconv is not available\n-\t* configure.in include\/libxml\/xmlversion.h.in\n-\t  include\/libxml\/xmlwin32version.h.in: added the glue needed\n-\t  at the configure level and made it the default for Windows\n-\n-Tue Jul 29 16:43:48 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/libxml.c python\/libxml2class.txt:\n-\t  patch from Joachim Bauch + cleanup for Relax NG error callbacks\n-\t  in python\n-\n-Tue Jul 29 12:46:08 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c parserInternals.c tree.c: applied Peter Jacobi encoding\n-\t  cleanup patch, and also avoided a possible memory leak\n-\n-Tue Jul 29 09:28:09 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: fix the previous commit\n-\n-Tue Jul 29 12:28:17 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* HTMLparser.c: fixed problem with comments reported by Nick Kew\n-\t* encoding.c: added routines xmlUTF8Size and xmlUTF8Charcmp for\n-\t  some future cleanup of UTF8 handling\n-\n-Mon Jul 28 16:39:14 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: applied a change suggested by Sean Griffin in bug\n-\t  #118494 about a memory leak in EXSLT\n-\n-Sun Jul 27 14:30:56 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: fixed a Relax-NG compilation\/streaming bug introduced\n-\t  when fixing the previous Relax-NG bugs\n-\t* result\/relaxng\/*: This slightly changes the output messages of\n-\t  some regression tests.\n-\t* configure.in: added support of -with-fexceptions for nested C++\n-\t  support.\n-\n-Thu Jul 24 15:46:02 MDT 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/tutorial\/apa.html\n-\t* doc\/tutorial\/apb.html\n-\t* doc\/tutorial\/apc.html\n-\t* doc\/tutorial\/apd.html\n-\t* doc\/tutorial\/ape.html\n-\t* doc\/tutorial\/apf.html\n-\t* doc\/tutorial\/apg.html\n-\t* doc\/tutorial\/aph.html\n-\t* doc\/tutorial\/ar01s02.html\n-\t* doc\/tutorial\/ar01s03.html\n-\t* doc\/tutorial\/ar01s04.html\n-\t* doc\/tutorial\/ar01s05.html\n-\t* doc\/tutorial\/ar01s06.html\n-\t* doc\/tutorial\/ar01s07.html\n-\t* doc\/tutorial\/ar01s08.html\n-\t* doc\/tutorial\/index.html\n-\t* doc\/tutorial\/ix01.html\n-\t* doc\/tutorial\/xmltutorial.pdf\n-\t* doc\/tutorial\/xmltutorial.xml\n-\tupdate tutorial with XPath example\n-\n-Thu Jul 24 17:07:06 IST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c parser.c: fixing a bug about a special case of namespace\n-\t  handling, this closes bug #116841\n-\n-Wed Jul 23 20:52:36 IST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c result\/relaxng\/*: checked and fixed the compilation\n-\t  of RNG schemas, fixes a couple of bugs #117097 and #117001 .\n-\t  This slightly changes the output messages of some regression tests.\n-\n-Wed Jul 23 15:15:08 IST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: fixed an out of bound error #118052 , the good\n-\t  part if that base64 code was not in use yet ...\n-\n-Tue Jul 22 19:42:15 MDT 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmllint.html\n-\tinclude html version of the xmllint man page, so an\n-\tup-to-date version is visible on the Web\n-\n-Mon Jul 21 21:53:43 IST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c include\/libxml\/xinclude.h: added a new API\n-\t  xmlXIncludeProcessTree() to process XInclude only on a subtree\n-\t  this should fix bug #115385\n-\n-Fri Jul 18 17:11:42 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c include\/libxml\/relaxng.h: adding Get interface for\n-\t  the error callback and parameters of parsing and validation\n-\t  contexts\n-\t* xmlreader.c: patch to fix bug #117702 about incomplete Read()\n-\t  on text nodes.\n-\n-Wed Jul 16 23:15:53 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c: patch from Dodji Seketeli about UTF16 BOM\n-\t  when using the push XML parser.\n-\t* result\/utf16bom.xml result\/noent\/utf16bom.xml test\/utf16bom.xml:\n-\t  added the test to the regression suite.\n-\n-Tue Jul 15 22:03:13 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* globals.c: add xmlThrDefMutex = NULL in xmlCleanupGlobals() \n-\t  as suggested by Rob Richards\n-\n-Tue Jul 15 15:30:55 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* DOCBparser.c HTMLparser.c entities.c parser.c relaxng.c \n-\t  xmlschemas.c xpath.c: removed some warnings by casting xmlChar\n-\t  to unsigned int and a couple of others.\n-\n-Fri Jul 11 16:44:22 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: fixes a segfault on empty hexBinary strings\n-\n-Thu Jul 10 16:02:47 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanoftp.c nanohttp.c: cleanup patches from Peter Breitenlohner\n-\n-Tue Jul  8 16:02:19 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* globals.c threads.c: fixes some problem when freeing uninitialized\n-\t  mutexes\n-\n-Tue Jul  8 14:15:07 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanoftp.c nanohttp.c: the modules should not import <config.h>\n-\t  directly, some cleanups\n-\t* xmlschemas.c: Peter Sobisch found a nasty bug in the Schemas\n-\t  validation code.\n-\n-Mon Jul  7 18:00:51 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/configure.js: Jesse Pelton pointed out a problem in the\n-\t  javascript code.\n-\n-Mon Jul  7 16:39:31 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* NEWS doc\/*: regenerated\n-\t* nanoftp.c nanohttp.c: might fix includes problems with the\n-\t  Ipv6 support on solaris\n-\t* tree.c: patch from Markus Keim about xmlHasNsProp() on attributes\n-\t  defined as #IMPLIED\n-\n-Sun Jul  6 23:09:13 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in doc\/*: preparing release 2.5.8\n-\t* nanohttp.c: changed some preprocessor block\n-\t* xmlschemastypes.c: applied patch from Charles Bozeman adding\n-\t  hexBinary schema datatype and adding support for totalDigits and\n-\t  fractionDigits facets.\n-\n-Sun Jul  6 19:56:18 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c xpath.c: fixed 2 bugs pointed in #116448\n-\n-Sun Jul  6 19:34:17 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: fixed bug #116095 removing the error message when\n-\t  reapplying XInclude to a document.\n-\n-Sat Jul  5 22:40:23 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: applied small changes to portability layer for \n-\t  compilation on DJGPP Ms-DOS compiler.\n-\n-Sat Jul  5 22:30:25 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c HTMLparser.c: use the character() SAX callback\n-\t  if the cdataBlock ain't defined.\n-\t* xpath.c: fix bug #115349 allowing compilation when configured\n-\t  with --without-xpath since the Schemas code needs NAN and co.\n-\n-Sat Jul 5 00:51:30 HKT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\tFixed problem with multi-threading, shown by the test program\n-\ttestThreads.  After fix, ran multiple tests on various speed\n-\tmachines (single and dual processor X86), which all seem okay.\n-\n-\t* catalog.c: added missing xmlRMutexUnlock in xmlLoadCatalog\n-\n-\t* threads.c: added missing initialisation for condition variable\n-\t  in xmlNewRMutex.\n-\n-Sat Jun 21 16:10:24 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\tApplying IPv6 patch from Archana Shah <archana.shah@wipro.com>\n-\tclosing bug #114837\n-\n-\t* configure.in: Added checks for IPv6 support and getaddrinfo().\n-\n-\t* acconfig.h: Defined HAVE_GETADDRINFO and SUPPORT_IP6.\n-\n-\t* config.h.in: Defined HAVE_GETADDRINFO and SUPPORT_IP6.\n-\n-\t* nanoftp.c: Structure xmlNanoFTPCtxt contains either sockaddr_storage\n-\t  field or sockaddr_in field, depending upon the availability of IPv6\n-\t  support.\n-\t  have_ipv6(): Added to check for run-time IPv6 support.\n-\t  (xmlNanoFTPScanURL), (xmlNanoFTPUpdateURL), (xmlNanoFTPScanProxy):\n-\t  Modified to parse a URI with IPv6 address given in [].\n-\t  (xmlNanoFTPConnect): Changed to use getaddrinfo for address\n-\t  resolution, if it is available on the system, as gethostbyname\n-\t  does not return IPv6 addresses on some platforms.\n-\t  (xmlNanoFTPGetConnection): Modified type of dataAddr variable to\n-\t  sockaddr_storage or sockaddr_in depending upon the IPv6 support.\n-\t  Sending EPSV, EPRT or PASV, PORT depending upon the type of address\n-\t  we are dealing with.\n-\n-\t* nanohttp.c: (have_ipv6): Added to check for run-time IPv6 support.\n-\t  (xmlNanoHTTPScanURL), (xmlNanoHTTPScanProxy): Modified to parse\n-\t  a URI with IPv6 address given in [].\n-\t  (xmlNanoHTTPConnectHost): Modified to use getaddrinfo if it is\n-\t  available on the system. Also IPv6 addresses will be resolved by\n-\t  gethostbyname only if IPv6 run-time support is available.\n-\t  (xmlNanoHTTPConnectAttempt): Modified to deal with IPv6 address.\n-\n-Sat Jun 14 18:46:51 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/configure.js include\/win32config.h \n-\t  include\/libxml\/xmlversion.h.in: Applied the patch for BCB\n-\t  by Eric Zurcher.\n-\n-Fri Jun 13 14:27:19 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/Makefile.am doc\/html\/*: reverted back patch for #113521,\n-\t  due to #115104 and while fixing #115101 . HTML URLs must not\n-\t  be version dependent.\n-\n-Fri Jun 13 12:03:30 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* entities.c: do not generate &quot; for \" outside of attributes\n-\t* result\/\/*: this changes the output of some tests\n-\n-Mon Jun  9 12:28:58 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c xmlIO.c: trying to fix #114277 about when file\n-\t  remapping and escaping should really be attempted.\n-\n-Mon Jun  9 11:06:09 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/*: applied a patch from Gman for building docs\n-\t* valid.c xmllint.c include\/libxml\/valid.h: applied a patch from\n-\t  Gary Pennington to provide an allocator for xmlValidCtxt\n-\t* xmlreader.c: applied patch from Jacek Konieczny fixing bug\n-\t  #113580 about data not being passed immediately.\n-\n-Thu Jun  5 11:31:02 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: applied a couple of patches from Mark Itzcovitz\n-\t  to handle saving back \"UTF-16\" documents.\n-\n-Mon Jun  2 21:56:15 MVT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c xmlschemas.c include\/libxml\/schemasInternals.h: committing\n-\t  some work done while in the Maldives (hence the timezone on the\n-\t  laptop !)\n-\t* result\/schemas\/length3* test\/schemas\/deter0_*\n-\t  test\/schemas\/group0_*: some tests added too\n-\n-Mon Jun  2 15:34:17 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: small fix\n-\t* xmlIO.c: fixed an error message\n-\n-Tue May 20 14:21:23 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c: fixing Red Hat bug #91013 where xmllint was\n-\t  accepting an improper UTF8 sequence\n-\n-Sat May 17 12:53:11 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* threads.c: applied the patch from Stéphane Bidoul for getting\n-\t  rid of extra threads in a dynamic library.\n-\t* win32\/configure.js: threads default to 'native' now.\n-\n-Fri May 16 13:17:52 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c: fixing  bug #112904: html output method escaped\n-\t  plus sign character in URI attribute.\n-\n-Thu May 15 18:06:18 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* build_glob.py global.data globals.c parser.c\n-\t  include\/libxml\/globals.h: patch from Stéphane Bidoul for setting\n-\t  up threads global defaults.\n-\t* doc\/libxml2-api.xml: this extends the API with new functions\n-\t* python\/tests\/Makefile.am python\/tests\/reader2.py\n-\t  python\/tests\/thread2.py: integrated the associated testcase and\n-\t  fixed the error string used in reader2\n-\n-Wed May 14 14:56:46 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in libxml.spec.in python\/Makefile.am: trying\n-\t  to conciliate --with-python= requirements and RPM builds,\n-\t  a PITA really...\n-\n-Tue May 13 18:30:34 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: oops last commit introduced a memory leak.\n-\n-Tue May 13 18:10:38 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c doc\/xmllint.xml: added --nonet option\n-\t* doc\/Makefile.am: fixing #112803 by adding --nonet when calling\n-\t  xsltproc or xmllint\n-\t* doc\/xmllint.xml doc\/xmllint.1: also added --schema doc and\n-\t  rebuilt\n-\t* HTMLparser.c: cleaned up the HTML parser context build when \n-\t  using an URL\n-\n-Tue May 13 16:35:04 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in: added a comment about bug #112902 \n-\n-Mon May 12 21:58:00 EDT 2003 William Brack <wbrack@mmm.com.hk>\n-\n-\t* minor cleanup of configure '--help' display\n-\t* error.c: enhanced xmlParserPrintFileContext to fix bug #109942\n-\n-Mon May 12 17:53:30 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: PI nodes in external subset were not freed :-\\\n-\t  fixes bug #112842\n-\n-Mon May 12 11:23:27 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: added --schema option to run WXS schema validation\n-\t* xmlschemas.c xmlschemastypes.c include\/libxml\/schemasInternals.h:\n-\t  tried to improve error reporting in the Schema code, some cleanup\n-\t  too.\n-\n-Sun May 11 16:13:20 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: fixed some problems in the handling of errors,\n-\t  and attributes addressed by references.\n-\t* test\/schemas\/* result\/schemas\/*: dropped the verbosity level\n-\t  and added a couple of new tests\n-\n-Sat May 10 16:01:21 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: Stéphane Bidoul found an off by one addressing\n-\t  error on the error handling.\n-\n-Fri May  9 19:08:20 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: trying to fix #112673\n-\n-Fri May  9 18:14:16 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* DOCBparser.c catalog.c parser.c relaxng.c: removed multiple\n-\t  warning, this fixed a bug and should close #111574\n-\n-Fri May  9 15:34:32 EDT 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: fixing bug #104081 with xs:all with an element\n-\t  holding minOccurs=\"0\"\n-\t* test\/schemas\/all_* result\/schemas\/all_*: added some regression\n-\t  tests for that bug\n-\t* xmllint.c xmlreader.c: patches from Joerg Schmitz-Linneweber and\n-\t  Garry Pennington to compile without schemas support.\n-\n-Thu May  1 10:02:35 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fixed a problem with xmlUnlinkNode() for DTDs.\n-\n-Wed Apr 30 14:16:08 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xml2-config.in: try to fix Red hat bug #89957, do not\n-\t  output -L\/usr\/lib64\n-\t* xmlreader.c: fixed a typo in a comment\n-\n-Tue Apr 29 07:32:02 MDT 2003 John Fleck <jfleck@inkstain.ent>\n-\n-\t* doc\/tutorial\/aph.html, ix01.html\n-\tforgot to cvs add the new files. Thanks to Roland van Laar\n-\tfor pointing this out\n-\n-Tue Apr 29 14:36:49 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c doc\/libxml2-api.xml: fixing a function comment\n-\t* doc\/Makefile.am doc\/apibuild.py doc\/gnome-xml.sgml: switching\n-\t  to the XML\/XSLT doc generation closing #111799\n-\t* doc\/html\/*: complete update of the HTML results\n-\n-Mon Apr 28 14:51:41 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/defgen.xsl: fixed the conditional for unicode map,\n-\t  removed hardcoded schema entries\n-\n-Mon Apr 28 02:19:00 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/defgen.xsl: new file, stylesheet for generating \n-\t  win32\/libxml2.def.src from doc\/libxml2-api.xml\n-\t* win32\/libxml2.def.src: is autogenerated from now on, changes\n-\t  to this file will not appear here anymore\n-\n-Mon Apr 28 00:12:11 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/configure.js python\/setup.py.in: applied patch\n-\t  from Stéphane Bidoul for the Python bindings on the new\n-\t  release.\n-\n-Sun Apr 27 17:56:21 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* debugXML.c: included libxml\/uri.h for xmlCanonicPath\n-\t  declaration\n-\t* win32\/configure.js: thread-enabled build is now default\n-\t* win32\/libxml2.def.src: added more exports\n-\n-Sun Apr 27 00:23:05 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* NEWS doc\/*.xsl doc\/*.html: updated the web site separated\n-\t  developers from common pages, made the transition to XHTML1,\n-\t  added validity checking to the makefile rules.\n-\n-Sat Apr 26 23:17:51 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fix for xmlIOParseDTD same as previous and reported\n-\t  by Petr Pajas\n-\n-Sat Apr 26 15:26:04 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: applied fix to xmlSAXParseDTD from Malcolm Tredinnick\n-\t  closing #111638\n-\n-Sat Apr 26 14:00:58 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py: fixed a problem in the generator where\n-\t  the way functions are remapped as methods on classes was\n-\t  not symmetric and dependent on python internal hash order,\n-\t  as reported by Stéphane Bidoul\n-\n-Fri Apr 25 21:52:33 MDT 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/tutorial:\n-\txmltutorial.xml\n-\txmltutorial.pdf\n-\t*.html\n-\tadd appendix on generating compiler flags, more indexing\n-\n-Sat Apr 26 01:10:48 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* triodef.h vms\/build_libxml.com: applied patch from Craig A. Berry\n-\t  to get libxml-2.5.7 to compile on OpenVMS\n-\n-Fri Apr 25 18:42:35 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixing an xmlParseDTD bug raised by Petr Pajas\n-\n-Fri Apr 25 15:20:29 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/Makefile.am doc\/xmlcatalog.1 doc\/xmlcatalog_man.xml\n-\t  doc\/xmllint.1 doc\/xmllint.xml: automated the generation of the\n-\t  man page based on xsltproc and a stylesheet PI in the XML.\n-\n-Fri Apr 25 12:37:33 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xmllint.*: trying to fix #110541 where &nbsp; generated\n-\t  character preventing rendering by the man command.\n-\n-Fri Apr 25 01:09:23 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* NEWS configure.in: preparing release 2.5.7\n-\t* doc\/*: updated and rebuilt the docs\n-\t* doc\/apibuild.py: fixed the script\n-\n-Thu Apr 24 19:11:12 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am doc\/apibuild.py: make sure the OOM code don't\n-\t  get in the way of the builds\n-\t* doc\/libxml2-api.xml python\/libxml2class.txt: automatic update\n-\n-Thu Apr 24 18:01:46 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am testOOM.c testOOMlib.[ch] : integrated the Out Of\n-\t  Memory test from Havoc Pennington #109368\n-\t* SAX.c parser.c parserInternals.c tree.c uri.c valid.c\n-\t  xmlmemory.c xmlreader.c xmlregexp.c include\/libxml\/tree.h\n-\t  include\/libxml\/parser.h: a lot of memory allocation cleanups\n-\t  based on the results of the OOM testing\n-\t* check-relaxng-test-suite2.py: seems I forgot to commit the\n-\t  script.\n-\n-Wed Apr 23 17:16:41 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: trivial fix for 109774 removing a warning\n-\n-Wed Apr 23 15:49:32 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* DOCBparser.c SAX.c catalog.c debugXML.c parser.c: try to find\n-\t  more places where xmlCanonicPath() must be used to convert\n-\t  filenames to URLs, trying to fix #111088\n-\n-Wed Apr 23 09:35:12 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c python\/libxml.py: applied patch from \n-\t  Brent M Hendricks adding binding for xmlCatalogAddLocal\n-\n-Tue Apr 22 15:18:01 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: tried to fix #98879 again in a more solid\n-\t  way.\n-\n-Tue Apr 22 13:58:43 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/libxml2.def.src: added more exports from the relaxng and\n-\t  xmlreader clan\n-\n-Tue Apr 22 10:35:13 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c test\/valid\/ns* test\/result\/ns*: applied the patch\n-\t  provided by Brent Hendricks fixing #105992 and integrated the\n-\t  examples in the testsuite.\n-\n-Tue Apr 22 01:06:09 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* TODO: updated a bit\n-\t* configure.in: fixed the comment, threads now default to on\n-\t* parserInternals.c: fixed an erroneous xmlMallocAtomic() call\n-\n-Mon Apr 21 23:33:38 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* globals.c libxml.h parser.c parserInternals.c tree.c xmllint.c\n-\t  xmlreader.c include\/libxml\/parser.h: a lot of performance work\n-\t  especially the speed of streaming through the reader and push\n-\t  interface. Some thread related optimizations. Nearly doubled the\n-\t  speed of parsing through the reader.\n-\n-Sun Apr 20 10:36:05 MDT 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmllint.xml\n-\t* doc\/xmllint.1\n-\tupdate man page to explain use of --stream\n-\n-Sat Apr 19 02:03:24 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* DOCBparser.c HTMLparser.c c14n.c catalog.c encoding.c globals.c\n-\t  nanohttp.c parser.c parserInternals.c relaxng.c tree.c uri.c\n-\t  xmlmemory.c xmlreader.c xmlregexp.c xpath.c xpointer.c\n-\t  include\/libxml\/globals.h include\/libxml\/xmlmemory.h: added\n-\t  xmlMallocAtomic() to be used when allocating blocks which\n-\t  do not contains pointers, add xmlGcMemSetup() and xmlGcMemGet()\n-\t  to allow registering the full set of functions needed by\n-\t  a garbage collecting allocator like libgc, ref #109944\n-\n-Fri Apr 18 16:37:41 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: switched to have thread support enabled by default,\n-\t  didn't got troubles with ABI compatibility on Linux, hope it\n-\t  won't break on strange OSes, if yes, report the system ID\n-\t* doc\/libxml2-api.xml: just rebuilt the API\n-\n-Fri Apr 18 14:31:15 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.h include\/libxml\/parser.h parser.c xmlIO.c DOCBparser.c: \n-\t  added support for large file, tested with a 3+GB instance,\n-\t  and some cleanup.\n-\t* catalog.c: added a TODO\n-\t* Makefile.am: added some \"make tests\" comments\n-\n-Thu Apr 17 14:51:57 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: some cleanups\n-\t* doc\/xmlreader.html: extended the document to cover RelaxNG and\n-\t  tree operations\n-\t* python\/tests\/Makefile.am python\/tests\/reader[46].py: added some\n-\t  xmlReader example\/regression tests\n-\t* result\/relaxng\/tutor*.err: updated the output of a number of tests\n-\n-Thu Apr 17 11:35:37 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: valgrind pointed out an uninitialized variable error.\n-\n-Thu Apr 17 11:06:28 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/relaxng.h relaxng.c include\/libxml\/xmlreader.h\n-\t  xmlreader.c: augnemting the APIs, cleanups.\n-\t* parser.c: cleanup bug #111005\n-\t* xmlIO.c: added some missing comments\n-\n-Wed Apr 16 17:46:50 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c xmllint.c: more work on RelaxNG streaming validation\n-\t  trying to improve the subset compiled, and more testing.\n-\t* doc\/downloads.html doc\/xml.html doc\/xmlmem.html: some updates on the\n-\t  documentation\n-\t* test\/relaxng\/tutor11_1_3.xml: fixes the DTD path\n-\t* result\/relaxng\/*.err: fix some of the outputs\n-\n-Wed Apr 16 01:28:15 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c xmlreader.c xmllint.c include\/libxml\/relaxng.h\n-\t  include\/libxml\/xmlreader.h: implemented streaming of\n-\t  RelaxNG (when possible) on top of the xmlReader interface,\n-\t  provided it as xmllint --stream --relaxng .rng .xml\n-\t  This seems to mostly work.\n-\t* Makefile.am: updated to test RelaxNG streaming\n-\n-Mon Apr 14 18:08:33 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c include\/libxml\/relaxng.h: integrated the regexp\n-\t  based validity checking of fragments of the document for\n-\t  which the RNG can be compiled to regexps. Works on all regression\n-\t  tests, only fix needed is related to error messages.\n-\n-Sun Apr 13 21:51:00 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c xmlregexp.c include\/libxml\/xmlautomata.h\n-\t  include\/libxml\/xmlregexp.h: Starting work precompiling\n-\t  parts of RelaxNG schemas. Not plugged onto validity checking\n-\t  yet, just the regexp building part. Needed to extend some\n-\t  of the automata and regexp APIs.\n-\n-Fri Apr 11 21:36:21 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c xmlreader.c include\/libxml\/xmlreader.h: make sure\n-\t  xmllint --stream and xmllint --stream --valid returns errors\n-\t  code appropriately\n-\n-Fri Apr 11 10:59:24 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c include\/libxml\/xmlreader.h: Added the Expand()\n-\t  and Next() operation to work on subtrees within the reader\n-\t  framework.\n-\t* doc\/libxml2-api.xml python\/libxml2class.txt: resulting updates\n-\t* python\/tests\/reader5.py: added an example for those new\n-\t  functions of the reader.\n-\n-Thu Apr 10 23:38:13 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c: patch from Vasily Tchekalkin to fix #109865\n-\n-Thu Apr 10 15:32:44 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: fixing HasValue for namespace as raised by \n-\t  Denys Duchier\n-\n-Wed Apr  9 14:07:18 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c include\/libxml\/HTMLparser.h:  exported\n-\t  htmlCreateMemoryParserCtxt() it was static\n-\n-Wed Apr  9 13:21:48 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c xmlschemastypes.c include\/libxml\/xmlschemas.h:\n-\t  update from Charles Bozeman for date and duration types\n-\t* test\/schemas\/date_0.* test\/schemas\/dur_0.*\n-\t  result\/schemas\/date_0.* result\/schemas\/dur_0.*: updated too\n-\n-Mon Apr  7 12:19:26 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c valid.c xpath.c include\/libxml\/tree.h include\/libxml\/valid.h:\n-\t  fixing bug #107129, removing excessive allocation and calls\n-\t  to *printf in the code to build QName strings.\n-\n-Sat Apr  5 11:41:36 CEST 2003 Igoe Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/libxml2.def.src: fixed conditional exports, reported by\n-\t  Luke Murray.\n-\n-Fri Apr  4 18:08:00 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed a possible problem with xmlRecoverMemory()\n-\n-Thu Apr  3 17:24:44 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* trio.c trio.h triodef.h trionan.c trionan.h triop.h triostr.c\n-\t  triostr.h: Bjorn sent an update for the TRIO portability layer.\n-\n-Tue Apr  1 21:57:26 CEST 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/libxml2.def.src: exported new functions\n-\n-Tue Apr  1 13:09:46 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in NEWS: preparing release 2.5.6\n-\t* doc\/*: updated and rebuilt the docs\n-\n-Tue Apr  1 11:52:15 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: fixed an uninitialized memory access pointed by valgrind\n-\t  on C14Ntests\n-\n-Tue Apr  1 00:12:28 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: one more fixup of error message reporting\n-\n-Mon Mar 31 18:36:32 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: more work on bug #109225, and fixed an uninitialized\n-\t  variable pointed out by valgrind\n-\n-Mon Mar 31 18:05:22 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: try to work on bug #109225 and provide better\n-\t  error reports.\n-\t* result\/relaxng\/* : this change the output of a number of tests\n-\t* xinclude.c: fixing the parsed entity redefinition problem\n-\t  raised on the list.\n-\t* test\/schemas\/date_0.xsd: updated the date test c.f. E2-12\n-\n-Mon Mar 31 13:19:04 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: fixed date comparison to handle the tzo\n-\t  The only failures left are disagreements on Notations and\n-\t  '+1' not being allowed for ulong, uint, ushort and ubyte.\n-\n-Mon Mar 31 12:11:47 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: fixed gMonth parsing routine accordingly\n-\t  to the XML Schemas errata\n-\t  http:\/\/www.w3.org\/2001\/05\/xmlschema-errata#e2-12\n-\n-Sun Mar 30 23:04:18 CEST 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c xmlschemastypes.c: more work on XML Schemas datatypes\n-\t  and facets support. Currently only schemas with binHex or\n-\t  base64 don't compile. A few error left in the test suite:\n-\t  found 1035 test instances: 919 success 23 failures\n-\t  most are gdate or gdateyear failing check, and a few cases where\n-\t  James clark tests results are strange.\n-\t* valid.c: allow to reuse the Notation checking routine without\n-\t  having a validation context.\n-\t* SAX.c: removed a #if 0\n-\n-Sat Mar 29 17:35:05 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: forgot to apply one check from #106931 patch\n-\t* xmlschemastypes.c: more work on XML Schemas datatypes\n-\n-Sat Mar 29 11:49:25 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c include\/libxml\/relaxng.h xmlschemastypes.c: more work\n-\t  on cleaning up XML Schemas datatypes based on James Clark tests\n-\t  test\/xsdtest\/xsdtest.xml\n-\n-Fri Mar 28 14:24:08 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: implemented comparisons for Schemas values.\n-\t* xmlschemastypes.c include\/libxml\/xmlschemastypes.h: fixed\n-\t  some bugs in duration handling, comparisons for durations\n-\t  and decimals, removed all memory leaks pointed out by James\n-\t  testsuite. Current status is now\n-\t  found 238 test schemas: 197 success 41 failures\n-\t  found 1035 test instances: 803 success 130 failures\n-\n-Fri Mar 28 00:41:55 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c include\/libxml\/xmlschemas.h: fixed bugs and memory\n-\t  leaks in the W3C XML Schemas code\n-\t* xmlschemastypes.c: implemented nonPositiveInteger\n-\t* test\/schemas\/length2_0.xsd result\/schemas\/length2_0_0.err:\n-\t  fixed the test and result.\n-\n-Thu Mar 27 22:23:07 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c tree.c: two patches from James Bursa on the HTML\n-\t  parser and a typo\n-\t* xmlschemastypes.c: reindenting, fixing a memory access\n-\t  problem with dates.\n-\n-Thu Mar 27 15:53:35 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixing #109227 providing more context in case of \n-\t  start\/end tag mismatch\n-\t* python\/tests\/ctxterror.py python\/tests\/readererr.py: update the\n-\t  tests accordingly\n-\n-Thu Mar 27 15:22:41 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: should fix #109327 errors on memory accesses\n-\n-Thu Mar 27 15:06:13 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c: Fixed reopening of #78662 <form action=\"...\">\n-\t  is an URI reference\n-\n-Wed Mar 26 22:38:39 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fixed bug #109160 on non-ASCII IDs\n-\n-Wed Mar 26 17:30:37 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: Norm suggested a nicer error message for xml:space values\n-\t  errors\n-\n-Wed Mar 26 01:34:19 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c include\/libxml\/xpath.h: first part of the fix to\n-\t  performance bug #108905, adds xmlXPathOrderDocElems() providing\n-\t  document order for nodes.\n-\t* python\/libxml.c: Python may require TRIO as Albert Chin pointed out\n-\n-Tue Mar 25 16:07:00 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: removing a warning with Sun compiler\n-\t  bug #109154\n-\n-Tue Mar 25 07:02:56 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmllint.xml\n-\t* doc\/xmllint.1\n-\tupdate xmllint man page with --relaxng option\n-\n-Tue Mar 25 12:07:03 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/setup.py.in : was missing \"drv_libxml2.py\"\n-\n-Mon Mar 24 19:38:05 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c xpath.c: some changes related to the new way of \n-\t  handling Result Value Tree, before 2.5.5\n-\n-Mon Mar 24 16:36:23 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in NEWS: preparing release 2.5.5\n-\t* doc\/* : updated the documentation and regenerated it.\n-\n-Mon Mar 24 14:56:01 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fixed some problems related to #75813 about handling\n-\t  of Result Value Trees\n-\n-Sun Mar 23 22:57:20 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: applied a set of patches from Lorenzo Viali correcting\n-\t  URI parsing errors.\n-\n-Sun Mar 23 22:00:14 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: validity status was not passed back when validating in\n-\t  entities, but raised by Oliver Fischer\n-\n-Sun Mar 23 21:30:50 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c: avoid escaping ',' in URIs\n-\n-Sun Mar 23 12:57:00 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixing bug #108976 get the ID\/REFs to reference \n-\t  the ID in the document content and not in the entity copy\n-\t* SAX.c include\/libxml\/parser.h: more checking of the ID\/REF\n-\t  stuff, better solution for #107208\n-\t* xmlregexp.c: removed a direct printf, dohhh\n-\t* xmlreader.c: fixed a bug on streaming validation of empty \n-\t  elements in entities\n-\t* result\/VC\/ElementValid8 test\/VCM\/v20.xml result\/valid\/xhtml1.xhtml:\n-\t  cleanup of the validation tests\n-\t* test\/valid\/id* test\/valid\/dtds\/destfoo.ent result\/valid\/id*:\n-\t  added more ID\/IDREF tests to the suite\n-\n-Sat Mar 22 23:38:08 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: fixed #107043 removing 2 warnings with Sun One\n-\t  compiler.\n-\n-Sat Mar 22 18:50:45 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: valgrind'ed and cleaned up a couple of memory issues.\n-\n-Sat Mar 22 16:15:50 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: fix bug #107208 avoid false duplicates when ID\/REFs are\n-\t  defined in entities content\n-\n-Sat Mar 22 15:53:27 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: Fixed validation bug #108858 on namespace names using\n-\t  entities and reported by Brent Hendricks\n-\t* xmllint.c: report xmlTextReaderHasValue() result in --stream\n-\t  --debug output.\n-\n-Sat Mar 22 13:32:39 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: fixed bug #108801 reported by Malcolm Tredinnick\n-\t  about the DocType node not being reported sometimes.\n-\t* python\/tests\/reader.py: added to test to the regression checks\n-\n-Sat Mar 22 01:57:40 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: fixed bug #108546 on long CDATA (or text nodes)\n-\t  reported by Edd Dumbill\n-\n-Sat Mar 23 01:00:24 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c parser.c parserInternals.c: patch from\n-\t  johan@evenhuis.nl for #107937 fixing some line counting\n-\t  problems, and some other cleanups.\n-\t* result\/HTML\/: this result in some line number changes\n-\n-Fri Mar 21 22:19:14 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in Makefile.am: fixed Red Hat bug #86118 use libxml2.spec\n-\t  instead of libxml.spec\n-\t* relaxng.c: fixed some of the error reporting excessive\n-\t  verbosity\n-\t* catalog.c debugXML.c valid.c xmlreader.c xmlschemas.c xpath.c\n-\t  xmlschemastypes.c: removed some warnings from gcc\n-\t* doc\/libxml2-api.xml: rebuilt\n-\n-Fri Mar 21 17:25:23 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: another optimization, for choice this time\n-\t* result\/relaxng\/spec1* result\/relaxng\/tutor12_1* \n-\t  result\/relaxng\/tutor3_7: cleanups.\n-\n-Fri Mar 21 13:41:23 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: fixed xmlRelaxNGNodeMatchesList\n-\t* test\/relaxng\/testsuite.xml: augmented the test suite\n-\t* result\/relaxng\/spec1* result\/relaxng\/tutor12_1*: this fixes\n-\t  some schemas validation tests in the presence of foreign \n-\t  namespaces.\n-\n-Fri Mar 21 02:23:34 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: added another interleave speedup.\n-\n-Thu Mar 20 17:22:00 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: added integer and fixed one of the\n-\t  IDREFS regression tests pbm\n-\t* result\/relaxng\/docbook_0.err: updated\n-\n-Wed Mar 19 21:58:47 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c xmlschemastypes.c: attempt to cope with ID\/IDREF(S)\n-\t  declared both in the DTD and in the Schemas <grin\/>\n-\t* relaxng.c: more debug, added a big optimization for <mixed>\n-\t* test\/relaxng\/testsuite.xml: augmented the testsuite\n-\t* test\/relaxng\/ result\/relaxng: added the RelaxNG spec and a \n-\t  DocBook example to the regression tests\n-\n-Wed Mar 19 11:34:10 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* check-xsddata-test-suite.py: cosmetic change for output\n-\t* relaxng.c: try to minimize calls to malloc\/free for states.\n-\n-Tue Mar 18 17:50:31 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: removed a warning\n-\t* xmlschemastypes.c: more cleanup, added ENTITY and ENTITIES\n-\t  support\n-\t* check-relaxng-test-suite.py check-xsddata-test-suite.py:\n-\t  cleanup\/improvements of the regression tests batch\n-\t* test\/relaxng\/testsuite.xml: augmented libxml2 own testsuite\n-\n-Tue Mar 18 12:36:22 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: fixed error msg cleanup deallocation\n-\t* xmlschemastypes.c: added a function to handle lists of\n-\t  atomic types, added support for IDREFS\n-\n-Tue Mar 18 01:28:15 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c valid.c xmlschemastypes.c: added Datatype ID\n-\t  and IDREF, usable from RelaxNG now\n-\t* include\/libxml\/xmlschemastypes.h: need to add a new interface\n-\t  because the validation modifies the infoset\n-\t* test\/relaxng\/testsuite.xml: extended the testsuite\n-\n-Mon Mar 17 16:34:07 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: fixed the last core RelaxNG bug known #107083,\n-\t  schemas datatype ID\/IDREF support still missing though.\n-\t* xmlreader.c: fix a crashing bug with prefix raised by\n-\t  Merijn Broeren\n-\t* test\/relaxng\/testsuite.xml: augmented the testsuite with\n-\t  complex inheritance tests\n-\n-Sun Mar 16 18:45:50 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: switched back to the previous Relax-NG code base,\n-\t  the derivation algorithm need severe constraining code to avoid\n-\t  combinatorial explosion. Fixed the problem with Sebastian Rahtz\n-\t  TEI based example and other bugs\n-\t* result\/relaxng\/*err: updated the results\n-\t* test\/relaxng\/testsuite.xml: started a new test suite \n-\n-Sat Mar 15 22:26:46 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c include\/libxml\/relaxng.h: After coming to the conclusion\n-\t  that the original RelaxNG validation code was un-fixeable, it got\n-\t  rewritten to use the derivation algorithm from James Clark and\n-\t  redebugged it (nearly) from scratch:\n-\t  found 373 test schemas: 372 success 1 failures\n-\t  found 529 test instances: 529 success 0 failures\n-\n-Tue Mar 11 12:08:23 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c parser.c: fix some recursion problems introduced in the\n-\t  last release.\n-\t* relaxng.c: more debugging of the RNG validation engine, still\n-\t  problems though.\n-\n-Mon Mar 10 14:10:47 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: stop generating wrong result file with * in name\n-\t* relaxng.c: fixing the include bug raised by Sebastian Rahtz\n-\t* result\/relaxng\/demo* test\/relaxng\/demo: added the tests from\n-\t  Sebastian reproducing the problem.\n-\n-Sun Mar  9 18:02:31 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmllint.1: regenerating man page from xmllint.xml to pick\n-\t  up Aleksey's change\n-\n-Sun Mar  9 13:53:16 2003  Aleksey Sanin  <aleksey@aleksey.com>\n-\n-\t* xmllint.c doc\/xmllint.xml: use $XMLLINT_INDENT environment\n-\tvariable to control the indentation for the xmllint \"--format\" \n-\toption\n-\n-Sat Mar  8 14:27:43 CET 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* encoding.c: applied Gennady's patch against buffer overrun\n-\n-Fri Mar  7 19:29:40 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* test\/xsdtest\/xsdtest.xml uri.c: after and exchange with James\n-\t  Clark it appeared I had bug in URI parsing code ...\n-\t* relaxng.c include\/libxml\/relaxng.h: completely revamped error\n-\t  reporting to not lose message from optional parts.\n-\t* xmllint.c: added timing for RNG validation steps\n-\t* result\/relaxng\/*: updated the result, all error messages changed\n-\n-Fri Mar  7 15:18:32 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fix bug #107804, the algorithm used for document order\n-\t  computation was failing on attributes.\n-\n-Thu Mar  6 22:35:50 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: fix bug #107764 , possibility of buffer overflow\n-\t  in xmlValidDebug()\n-\n-Wed Mar  5 17:41:37 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanoftp.c include\/libxml\/nanoftp.h: adding xmlNanoFTPDele()\n-\t  from Philipp Dunkel\n-\n-Wed Mar  5 10:57:09 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastype.c: made powten array static it should not be exported\n-\t* HTMLparser.c: fix bug #107361 by reusing the code from the XML \n-\t  parser function.\n-\t* testHTML.c: get rid of valgrind messages on the HTML SAX tests\n-\n-Fri Feb 28 00:23:00 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fixed a node dump crash on attributes\n-\t* test\/xsdtest\/xsdtest.xml test\/xsdtest\/xsdtest.xsl: fixed\n-\t  an URI test bug and get better output.\n-\n-Thu Feb 27 22:28:40 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* check-xsddata-test-suite.py: give more infos\n-\t* relaxng.c: fix a bug reported by Sebastian Rahtz and\n-\t  REF->DEF in attribute values.\n-\n-Thu Feb 27 21:09:32 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* check-xsddata-test-suite.py test\/xsdtest\/xsdtest.xml\n-\t  test\/xsdtest\/xsdtest.xsl: import of the XSD Datatype\n-\t  regression tests from James Clark.\n-\n-Thu Feb 27 18:40:04 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c xmlschemas.c xmlschemastypes.c\n-\t  include\/libxml\/xmlschemastypes.h: added param support for relaxng\n-\t  type checking, started to increment the pool of simple types\n-\t  registered, still much work to be done on simple types and\n-\t  facets checkings.\n-\n-Wed Feb 26 16:45:39 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* entities.c: fixes again one of the problem raised by\n-\t  James Clark in #106788\n-\n-Wed Feb 26 15:46:48 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: Fixed a couple of problem raised by James Clark\n-\t  in bug #107083, the support for ID\/IDREF\/IDREFS at the WXS\n-\t  datatype level still not fixed though.\n-\n-Mon Feb 24 21:09:19 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: preparing release 2.5.4\n-\t* doc\/*: updated and rebuilt the docs\n-\t* relaxng.c: removed warnings\n-\t* result\/relaxng\/*: updated the results\n-\n-Mon Feb 24 20:53:17 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: fixes a DTD regexp generation problem.\n-\n-Mon Feb 24 20:12:57 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixes bug #105998 about false detection of\n-\t  attribute consumption loop.\n-\n-Mon Feb 24 19:14:57 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: Fixes bug #106931 in XInclude entities merging.\n-\n-Mon Feb 24 18:50:35 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: fixed bug #105992\n-\n-Mon Feb 24 18:14:16 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fixed xmlSetProp and al. when the node passed is not an\n-\t  element.\n-\t* relaxng.c: fixed bugs 7.3 (though not complete) and memory leaks\n-\t  found 373 test schemas: 369 success 4 failures\n-\t  found 529 test instances: 525 success 4 failures\n-\t* check-relaxng-test-suite.py: added memory debug reporting\n-\n-Mon Feb 24 12:41:54 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c parser.c: some warning removal on Igor's patch\n-\t* tree.c: seems I messed up with #106788 fix\n-\t* python\/libxml.c: fixed some base problems when Python provides\n-\t  the resolver.\n-\t* relaxng.c: fixed the interleave algorithm \n-\t  found 373 test schemas: 364 success 9 failures\n-\t  found 529 test instances: 525 success 4 failures\n-\t  the resulting failures are bug in the algorithm from 7.3 and\n-\t  lack of support for params\n-\n-Sun Feb 23 14:49:39 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: another fix for nodeinfo in entities problem\n-\t* tree.c entities.c: fixed bug #106788 from James Clark\n-\t  some spaces need to be serialized as character references.\n-\n-Sat Feb 22 18:28:16 CET 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* parser.c uri.c: fixed the bug I introduced in the path\n-\t  handling, reported by Sebastian Bergmann\n-\n-Sat Feb 22 00:19:48 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixing some nodeinfo in entities problem raised\n-\t  by Glenn W. Bach\n-\t* relaxng.c: implemented the first section 7.3 check\n-\t* result\/relaxng\/*: updated the results\n-\n-Fri Feb 21 18:12:19 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: fixed some problems in the previous commit\n-\t  and finished implementing 4.16 rules checking\n-\t  found 373 test schemas: 353 success 20 failures\n-\t  found 529 test instances: 519 success 6 failures\n-\t* result\/relaxng\/*: updated the results\n-\n-Fri Feb 21 16:37:39 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: implemented checks from section 7.2\n-\n-Thu Feb 20 16:00:31 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: implemented the checks from section 7.1, fixed\n-\t  some of the 4.20 and 4.21 problems.\n-\t  found 373 test schemas: 338 success 35 failures\n-\t  found 529 test instances: 519 success 6 failures\n-\t* result\/relaxng\/*: updated the results\n-\n-Thu Feb 20 01:09:24 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: implemented the 4.20 and 4.21 simplification rules.\n-\t* result\/relaxng\/*: updated the results\n-\n-Wed Feb 19 18:30:30 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: more bugfixes\n-\t* result\/relaxng\/*: updated the results\n-\n-Wed Feb 19 15:39:56 CET 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* DOCBparser.c: obsoleted xmlNormalizeWindowsPath\n-\t* HTMLparser.c: obsoleted xmlNormalizeWindowsPath\n-\t* SAX.c: ensured xmlDoc.URL is always canonic\n-\t* parser.c: obsoleted xmlNormalizeWindowsPath\n-\t* uri.c include\/libxml\/uri.h: introduced xmlCanonicPath\n-\t* xmlIO.c include\/libxml\/xmlIO.h: obsoleted xmlNormalizeWindowsPath\n-\t* win32\/libxml2.def.src: added few exports\n-\n-Wed Feb 19 14:26:51 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am configure.in: patched to have shared libraries\n-\t  for Python regression tests and static binaries for gdb debug\n-\t  in my development environment\n-\t* relaxng.c: more bugfixes \n-\t  found 373 test schemas: 296 success 77 failures\n-\t  found 529 test instances: 516 success 8 failures\n-\t* result\/relaxng\/*: updated the results\n-\n-Wed Feb 19 01:17:48 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: guess what ! Relax-NG bugfixing, what a surprise...\n-\n-Tue Feb 18 22:09:50 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: float\/double check bugfix\n-\t* tree.c include\/libxml\/tree.h: exported a function for NMTOKEN\n-\t  validation\n-\t* xmlreader.c: add a TODO for Jody\n-\t* relaxng.c: bugfix bugfix bugfix\n-\t  found 373 test schemas: 300 success 73 failures\n-\t  found 529 test instances: 507 success 10 failures\n-\t* result\/relaxng\/*: updated the results\n-\n-Tue Feb 18 00:33:17 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c check-relaxng-test-suite.py: more RelaxNG bug hunting\n-\n-Mon Feb 17 18:23:32 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c check-relaxng-test-suite.py: more work on the\n-\t  RelaxNG implementation conformance testing.\n-\t  found 373 test schemas: 284 success 89 failures\n-\t  found 529 test instances: 448 success 47 failures\n-\t* result\/relaxng\/*: updated the results\n-\n-Sun Feb 16 16:48:38 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* ChangeLog tree.c doc\/libxml-doc.el doc\/libxml2-api.xml: applied\n-\t  a patch from Kjartan Maraas to fix some typos\n-\n-Sun Feb 16 16:40:52 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: more bug-hunting\n-\t* testRelax.c include\/libxml\/relaxng.h: added --tree to dump the\n-\t  intermediate rng tree\n-\t* python\/generator.py: patch from Stéphane Bidoul to fix the generator\n-\t  on python < 2.2\n-\n-Fri Feb 14 17:49:26 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* check-relaxng-test-suite.py relaxng.c: more testing on the\n-\t  Relax-NG front, cleaning up the regression tests failures\n-\t  current state and I forgot support for \"mixed\":\n-\t  found 373 test schemas: 280 success 93 failures\n-\t  found 529 test instances: 401 success 68 failures\n-\t* tree.c include\/libxml\/tree.h xmlschemastypes.c: finished and\n-\t  moved the Name, NCName and QName validation routine in tree.c\n-\t* uri.c: fixed handling of URI ending up with #, i.e. having\n-\t  an empty fragment ID.\n-\t* result\/relaxng\/*: updated the results\n-\n-Thu Feb 13 16:49:24 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* check-xinclude-test-suite.py: improved the script accordingly\n-\t  to the XInclude regression tests updates\n-\t* xpointer.c: Implemented XPointer element() Scheme W3C PR of 13\n-\t  November 2002\n-\t* result\/XPath\/xptr\/chapterschildseq result\/XPath\/xptr\/vidchildseq\n-\t  test\/XPath\/xptr\/chapterschildseq test\/XPath\/xptr\/vidchildseq:\n-\t  augmented the Xpointer testsuite for the element() scheme\n-\n-Thu Feb 13 12:00:30 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: added TODO for the DTD compatibility spec\n-\t* xinclude.c: more bug fixes driven by the testsuite \n-\n-Tue Feb 11 19:01:02 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* check-xinclude-test-suite.py xinclude.c: Work on the W3C\/NIST\n-\t  regression tests for XInclude, improved the script, improving\n-\t  XInclude error reporting mechanism\n-\n-Mon Feb 10 17:19:14 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* NEWS doc\/* configure.in: preparing release 2.5.3\n-\n-Mon Feb 10 17:11:22 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: trying to fix #104934 about some XHTML1 serialization\n-\t  issues.\n-\n-Mon Feb 10 16:41:13 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c xmlIO.c: fixing bug #104646 about iconv based\n-\t  encoding conversion when the input buffer stops in the\n-\t  middle of a multibyte char\n-\n-Mon Feb 10 15:24:47 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* test\/relaxng\/OASIS\/spectest.xml: OASIS RelaxNG testsuite\n-\t* check-relaxng-test-suite.py: python script to run regression\n-\t  against OASIS RelaxNG testsuite\n-\t* relaxng.c: some cleanup tweaks\n-\t* HTMLparser.c globals.c: cleanups in comments\n-\t* doc\/libxml2-api.xml: updated the API\n-\t* result\/relaxng\/*: errors moved files, so large diffs but\n-\t  no changes at the semantic level.\n-\n-Mon Feb 10 01:00:31 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fixing #105678 problem when dumping a namespace node.\n-\n-Mon Feb 10 00:30:01 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fixed doc comment problems\n-\t* python\/generator.py python\/libxml_wrap.h python\/types.c: adding\n-\t  RelaxNG wrappers\n-\t* python\/tests\/Makefile.am python\/tests\/relaxng.py: added a specific\n-\t  test of those early Python RelaxNG bindings\n-\n-Sun Feb  9 15:18:43 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in: fixes a libtool problem on AMD 64bits builds\n-\t* relaxng.c: found the validation problem I had with interleave\n-\t  when not covering all remaining siblings\n-\t* Makefile.am test.relaxng\/* result\/relaxng\/*: augmented the\n-\t  testsuite and check the RNG schemas against the RNG schemas\n-\t  given in appendix A\n-\n-Sat Feb  8 18:55:43 CET 2003 Igor Zlatkovic <igor@zlatkovic.com>\n-\n-\t* win32\/Makefile.msvc: updates for RelaxNG\n-\t* win32\/Makefile.mingw: updates for RelaxNG\n-\t* win32\/libxml2.def.src: added RelaxNG exports\n-\n-Fri Feb  7 14:00:53 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: applied another bug fix from Sean Chittenden\n-\n-Fri Feb  7 13:34:08 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in xmllint.c: I f...ed up the default configuration\n-\t  of schemas and --relaxng option display in xmllint, pointed by\n-\t  Morus Walter.\n-\t* xlink.c: Sean Chittenden pointed a couple of errors in the XLink\n-\t  detection module, fixes bug #105374.\n-\n-Fri Feb  7 01:43:38 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: added the boolean base type.\n-\n-Thu Feb  6 10:23:52 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: started implementing some of the missing\n-\t  default simple types\n-\t* result\/relaxng\/*: updated the results\n-\n-Wed Feb  5 15:28:04 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* NEWS doc\/*: updated the docs, ready for 2.5.2 release\n-\n-Wed Feb  5 14:15:59 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c tree.c xmlIO.c: comments cleanups\n-\t* Makefile.am: use xmllint for doing the RelaxNG tests\n-\t* configure.in: preparing 2.5.2 made schemas support default to\n-\t  on instead of off\n-\t* relaxng.c: removed the verbosity\n-\t* xmllint.c: added --relaxng option\n-\t* python\/generator.py python\/libxml_wrap.h: prepared the integration\n-\t  of the new RelaxNG module and schemas\n-\t* result\/relaxng\/*: less verbose output\n-\n-Wed Feb  5 12:00:36 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: do not run content model validation if the\n-\t  content is not determinist\n-\n-Wed Feb  5 11:43:58 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: added the redefinition of namespaced attribute\n-\t  check that was missing as Fabrice Desré pointed out.\n-\n-Wed Feb  5 11:09:29 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c include\/libxml\/HTMLparser.h: applied HTML\n-\t  improvements from Nick Kew, allowing to do more checking\n-\t  to HTML elements and attributes.\n-\n-Tue Feb  4 23:47:06 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: fixing bug #105137 about entities declaration\n-\t  needing to be copied to the including document.\n-\n-Tue Feb  4 20:26:22 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: fixed bug #104817 with delegateURI\n-\t* xpath.c: fixing bugs #104123 and #104125\n-\n-Tue Feb  4 17:12:56 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in valid.c xmlreader.c python\/libxml_wrap.h \n-\t  python\/types.c: fixing #104096 to compile without regexps\n-\n-Tue Feb  4 16:31:55 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: fixing bug #103969 forgot to add an epsilon transition\n-\t  when building the automata for elem*\n-\n-Tue Feb  4 16:21:07 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: applied patch from Arne de Bruijn fixing \n-\t  bug #103827\n-\n-Tue Feb  4 16:17:09 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: updating a comment, fixing #103776\n-\n-Tue Feb  4 16:05:53 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixing bug 105049 for validity checking of content\n-\t  within recursive entities.\n-\n-Tue Feb  4 15:40:54 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: try to fix # 105049\n-\t* relaxng.c xmlschemastypes.c: a couple of changes and extensions\n-\t* tree.c: updated a function comment\n-\n-Tue Feb  4 00:20:58 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng: more work on grammars and refs\/defs\n-\t* test\/relaxng\/* result\/relaxng\/*: augmented\/updated the\n-\t  regression tests\n-\n-Mon Feb  3 14:16:59 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng: more work on name classes, except support\n-\t* test\/relaxng\/* result\/relaxng\/*: augmented\/updated the\n-\t  regression tests\n-\n-Mon Feb  3 11:56:05 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng: more work on name classes, the \"validate all\" schemas\n-\t  seems to work now.\n-\t* test\/relaxng\/* result\/relaxng\/*: augmented\/updated the\n-\t  regression tests\n-\n-Mon Feb  3 09:50:26 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c: removed an unprotedted debug message Aleksi Suhonen\n-\t* parser.c: put a guard against infinite document depth, basically\n-\t  trying to avoid another kind of DoS attack.\n-\t* relaxng.c: some code w.r.t. nameClasses\n-\n-Sun Feb  2 17:01:43 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* test\/relaxng\/* result\/relaxng\/*: check all the namespace support\n-\t  was actually correct based on tutorial section 10.\n-\n-Sun Feb  2 15:33:38 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng: include seems to work okay now\n-\t* test\/relaxng\/* result\/relaxng\/*: augmented\/updated the\n-\t  regression tests\n-\n-Sat Feb  1 19:44:58 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: a bit of work done in the train back.\n-\t* test\/relaxng\/*: added one of the include tests\n-\n-Thu Jan 30 14:06:55 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng: more work done in the train\n-\t* test\/relaxng\/* result\/relaxng\/*: augmented\/updated the\n-\t  regression tests\n-\n-Wed Jan 29 23:44:58 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: debugging of externalRef\n-\t* test\/relaxng\/* result\/relaxng\/*: augmented\/updated the\n-\t  regression tests\n-\n-Wed Jan 29 22:06:04 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: more work on Relax-NG, implementing externalRef\n-\t* test\/relaxng\/* result\/relaxng\/*: augmented\/updated the \n-\t  regression tests\n-\t* Makefile.am: cleanup to Relaxtests target\n-\n-Wed Jan 29 00:08:38 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: more work on Relax-NG, implementing interleave\n-\t* test\/relaxng\/* result\/relaxng\/*: augmented\/updated the \n-\t  regression tests\n-\n-Tue Jan 28 21:56:49 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: more work on Relax-NG, implementing interleave\n-\t* test\/relaxng\/* result\/relaxng\/*: augmented\/updated the \n-\t  regression tests\n-\n-Mon Jan 27 07:35:29 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/tutorial\/customfo.xsl\n-\t* doc\/tutorial\/customhtml.xsl\n-\tadding stylesheet customizations used to generate fo\n-\tfor pdf and html\n-\n-Mon Jan 27 13:29:43 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: more work on Relax-NG\n-\t* test\/relaxng\/* result\/relaxng\/*: augmented\/updated the \n-\t  regression tests\n-\t* xmlschemastypes.c: added a number of base type definition but not\n-\t  the associated checks, those are still TODOs\n-\n-Sun Jan 26 17:37:06 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\tin docs\/tutorial:\n-\t* apa.html\n-\t* apb.html\n-\t* apc.html\n-\t* apd.html\n-\t* ape.html\n-\t* apf.html\n-\t* apg.html\n-\t* ar01s02.html\n-\t* ar01s03.html\n-\t* ar01s04.html\n-\t* ar01s05.html\n-\t* ar01s06.html\n-\t* ar01s07.html\n-\t* ar01s08.html\n-\t* index.html\n-\t* xmltutorial.pdf\n-\t* xmltutorial.xml\n-\tadd index to tutorial\n-\n-Sun Jan 26 17:02:29 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmlcatalog.1\n-\t* doc\/xmlcatalog_man.html\n-\t* doc\/xmlcatalog_man.xml\n-\tbelatedly fixing bug #93622 (adds rewriteURI type to\n-\t\"--add\" option in xmlcatalog man page\n-\n-Sun Jan 26 20:47:26 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlcatalog.c xmllint.c: applied patch for NetBSD by\n-\t  Julio Merino, closing #104475\n-\n-Sun Jan 26 20:38:43 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: more work on Relax-NG\n-\t* test\/relaxng\/* result\/relaxng\/*: augmented\/updated the \n-\t  regression tests\n-\n-Sun Jan 26 01:49:58 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: more work on Relax-NG\n-\t* test\/relaxng\/* result\/relaxng\/*: augmented\/updated the \n-\t  regression tests\n-\n-Sat Jan 25 18:59:54 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* README: updated the policy on private mail answers\n-\t* relaxng.c: more work on Relax-NG\n-\t* test\/relaxng\/* result\/relaxng\/*: augmented\/updated the \n-\t  regression tests\n-\n-Fri Jan 24 15:12:44 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c parser.c tree.c: applied a documentation patch from\n-\t  Stefan Kost\n-\n-Fri Jan 24 02:00:50 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* relaxng.c: more work on Relax-NG\n-\t* doc\/*: regenerated the docs\n-\t* test\/relaxng\/* result\/relaxng\/*: updated and augmented the\n-\t  Relax-NG regression tests and results\n-\n-Thu Jan 23 19:26:20 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am configure.in relaxng.c include\/libxml\/relaxng.h:\n-\t  First commit of the new Relax-NG validation code, not generally\n-\t  useful yet.\n-\t* test\/relaxng\/* result\/relaxng\/*: current state of the regression\n-\t  tests\n-\n-Thu Jan 23 19:22:54 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: minimized the memory allocated for GetContent\n-\t  and a bit of cleanup.\n-\n-Thu Jan 23 17:41:37 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py: seems there is no good reasons to\n-\t  not generate bindings for XPointer\n-\n-Tue Jan 21 13:19:35 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c doc\/apibuild.py: applied a new patch from\n-\t  Stéphane Bidoul for cleanups\n-\t* doc\/libxml2-api.xml: rebuilt the API description with\n-\t  new entry points\n-\n-Mon Jan 20 23:25:00 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c python\/drv_libxml2.py python\/generator.py\n-\t  python\/libxml.c python\/libxml.py python\/libxml_wrap.h\n-\t  python\/types.c: patch from Stéphane Bidoul for better per\n-\t  context error message APIs\n-\t* python\/tests\/ctxterror.py python\/tests\/readererr.py:\n-\t  update of the tests\n-\n-Sun Jan 19 17:09:28 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/guidelines.html\n-\tgrammar and spelling cleanup\n-\n-Fri Jan 17 00:31:30 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c include\/libxml\/xmlreader.h python\/generator.py\n-\t  python\/libxml.c python\/libxml.py win32\/libxml2.def.src: applied\n-\t  a patch from Stéphane Bidoul to allow per XMLtextReader error\n-\t  and warning handling\n-\t* python\/tests\/Makefile.am python\/tests\/readererr.py: adding the\n-\t  specific regression test\n-\n-Tue Jan 14 17:00:08 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: Alexey Efimov pointed out that concat('a', 'b', )\n-\t  should raise a syntax error\n-\n-Tue Jan 14 15:39:14 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c: cleanup patch from Stéphane Bidoul\n-\n-Tue Jan 14 14:41:18 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: fixing bug #103100 with a dummy UTF8ToUTF8 copy\n-\n-Tue Jan 14 12:40:29 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/libxml.c python\/libxml.py\n-\t  python\/libxml_wrap.h python\/types.c: applied and fixed a patch\n-\t  from Stéphane Bidoul to provide per parser error handlers at the\n-\t  Python level.\n-\t* python\/tests\/Makefile.am python\/tests\/ctxterror.py: added a\n-\t  regression test for it.\n-\n-Tue Jan 14 01:15:04 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: fixed the streaming property of the reader,\n-\t  it was generating tree faster than consuming it. Pointed out\n-\t  by Nate Myers\n-\t* tree.c: fixed a bug in xmlSaveFormatFileEnc if passed a NULL doc\n-\n-Sun Jan 12 22:18:02 CET 2003 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* win32\/libxml2.def.src: added more xmlreader and other exports\n-\n-Fri Jan 10 18:04:32 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fix to the XPath implementation for parent and\n-\t  ancestors axis when operating on a Result Value Tree.\n-\t  Fixes bug #100271\n-\n-Fri Jan 10 17:07:01 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanoftp.c nanohttp.c xmlIO.c: patch from Stefano Zacchiroli\n-\t  to fix some URI\/file escaping problems\n-\n-Fri Jan 10 16:20:34 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py: fixed a bug raised by Raymond Wiker, \n-\t  docSetRootElement() should not raise an exception if the\n-\t  return is None\n-\n-Fri Jan 10 14:13:03 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.py python\/libxml.c python\/libxml2-python-api.xml:\n-\t  fixed bug #102181 by applying the suggested change and fixing\n-\t  the generation\/registration problem.\n-\n-Fri Jan 10 13:47:55 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fixed bug #102960 by reusing the XML name parsing\n-\t  routines.\n-\n-Fri Jan 10 00:16:49 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: one more IsEmptyElement craziness, that time in\n-\t  external parsed entities if substitution is asked.\n-\t* python\/tests\/reader3.py: added a specific test.\n-\n-Thu Jan  9 22:35:31 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/drv_libxml2.py: update from Stéphane Bidoul: python 2.1\n-\t  support and improved error handler registration\n-\n-Thu Jan  9 14:16:38 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c tree.c: fixes #102920 about namespace handling in\n-\t  HTML output and section 16.2 \"HTML Output Method\" of XSLT-1.0\n-\t* README: fixed a link\n-\n-Wed Jan  8 18:32:25 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in doc\/* NEWS: preparing 2.5.1 release\n-\t* SAX.c parser.c: fixing XmlTextReader bug\n-\n-Wed Jan  8 00:13:01 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: fuck, I introduced a memory leak on external parsed\n-\t  entities in 2.5.0 :-(\n-\n-Tue Jan  7 12:12:45 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: another fix needed as pointed by Christophe Merlet\n-\t  for --stream --debug if compiled without debug support.\n-\n-Mon Jan  6 20:53:08 MST 2003 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmllint.xml\n-\t* doc\/xmllint.1:\n-\tupdate man page with --stream and --chkregister\n-\n-Tue Jan  7 01:17:26 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* globals.c: fixed --with-threads compile\n-\t* xmllint.c: fixed --without-debug compile\n-\t* include\/libxml\/globals.h: cleanup\n-\t* include\/libxml\/schemasInternals.h: add a missing include\n-\n-Mon Jan  6 14:06:07 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in NEWS: preparing 2.5.0 release\n-\t* SAX.c: only warn in pedantic mode about namespace name \n-\t  brokenness\n-\t* globals.c: fix a doc generation problem\n-\t* uri.c: fix #101520\n-\t* doc\/*: updated and rebuilt the doc for the release, including\n-\t  stylesheet update\n-\t* python\/Makefile.am: fix a filename bug\n-\n-Mon Jan  6 12:05:12 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/tutorial\/* : fixed #101894 if doc == NULL xmlFreeDoc \n-\t  should not be called.\n-\n-Mon Jan  6 11:59:09 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml-2.0.pc.in: applied the patch to fix #101894\n-\n-Sun Jan  5 23:35:47 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c : applied patch from Lukas Schroeder for register callbacks\n-\t* valid.c: modified patch from Lukas Schroeder to test\n-\t  register callbacks with --chkregister\n-\n-Sun Jan  5 02:23:20 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: seriously changed the way data are pushed to\n-\t  the underlying parser, go by block of 512 bytes instead of\n-\t  tryng to detect tag boundaries at that level. Changed the\n-\t  way empty element are detected and tagged.\n-\t* python\/tests\/reader.py python\/tests\/reader2.py\n-\t  python\/tests\/reader3.py: small changes mostly due to context\n-\t  reporting being different and DTD node being reported. Some\n-\t  errors previously undetected are now caught and fixed.\n-\t* doc\/xmlreader.html: flagged last section as TODO\n-\n-Sat Jan  4 20:40:28 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.py: integrated the Python 2.2 optimizations\n-\t  from Hannu Krosing, while maintaining compatibility with \n-\t  1.5 and 2.1\n-\n-Sat Jan  4 17:33:17 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: a bit of cleanup\n-\t* xmlreader.c: small fix\n-\t* doc\/xmlreader.html: more work on the XmlTextReader tutorial\n-\t* python\/libxml.py: a few fixes pointed out by Hannu Krosing\n-\n-Sat Jan  4 13:46:14 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/setup.py.in: patch from Stéphane Bidoul to include\n-\t  drv_libxml2.py in setup.py\n-\n-Sat Jan  4 01:43:06 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xmlreader.html: starting documenting the new XmlTextReader\n-\t  interface.\n-\n-Fri Jan  3 17:18:32 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: added the --stream flag to use the TextReader API\n-\t* xmlreader.c: small performance tweak\n-\n-Fri Jan  3 13:50:55 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c python\/tests\/reader2py: okay the DTD validation\n-\t  code on top of the XMLTextParser API should be solid now.\n-\n-Fri Jan  3 02:17:18 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c python\/tests\/reader2py: Fixing some more mess\n-\t  with validation and recursive entities while using the\n-\t  reader interface, it's getting a bit messy...\n-\n-Thu Jan  2 15:15:26 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c python\/tests\/reader.py: another couple of problem\n-\t  related to IsEmptyElement reported by Stéphane Bidoul needed \n-\t  some fixes.\n-\n-Thu Jan  2 13:57:07 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in python\/Makefile.am python\/drv_libxml2.py:\n-\t  integrated drv_libxml2.py Python xml.sax driver from Stéphane Bidoul\n-\t  based on the python XmlTextReader interface.\n-\n-Wed Jan  1 22:05:40 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: backing out one change in the last patch which broke the\n-\t  regression tests\n-\n-Wed Jan  1 21:57:28 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* global.data globals.c tree.c include\/libxml\/globals.h: applied\n-\t  an old patch from Lukas Schroeder to track node creation and\n-\t  destruction. Probably missing a lot of references at the moment\n-\t  and not usable reliably.\n-\n-Wed Jan  1 20:12:07 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* NEWS doc\/Makefile.am doc\/news.xsl: generate the NEWS file\n-\t  from doc\/news.html and a stylesheet\n-\n-Wed Jan  1 16:09:57 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c python\/tests\/reader.py: fixed another couple of\n-\t  xmlreader bugs reported by Stéphane Bidoul and added tests.\n-\n-Wed Jan  1 15:42:54 CET 2003 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c python\/tests\/reader2.py: fixed another validity\n-\t  checking in external parsed entities raised by Stéphane Bidoul\n-\t  and added a specific regression test.\n-\t* python\/tests\/reader3.py: cleanup\n-\n-Tue Dec 31 15:44:02 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c python\/tests\/reader2.py: fixed a problem with\n-\t  validation within entities pointed by Stéphane Bidoul, augmented\n-\t  the tests to catch those.\n-\n-Tue Dec 31 12:15:37 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py: modified the generator to allow keeping\n-\t  class references when creating new classes, needed to fix a bug\n-\t  pointed by Stéphane Bidoul where the input buffer of the\n-\t  xmlTextReader instance gets destroyed if the python wrapper for\n-\t  the input is not referenced anymore.\n-\n-Mon Dec 30 19:39:36 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c python\/tests\/reader.py: fixed another pair of problem\n-\t  pointed by Stéphane Bidoul: depth start at 0 and a parse problem.\n-\n-Mon Dec 30 13:36:50 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c python\/tests\/reader.py: fixed another problem\n-\t  pointed by Stéphane Bidoul\n-\n-Mon Dec 30 12:39:55 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c python\/tests\/reader.py: fixed a limit case problem\n-\t  with \"<a\/>\"\n-\n-Mon Dec 30 11:53:44 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: warn on xmlns:prefix=\"foo\"\n-\t* xmlreader.c python\/tests\/reader.py: fixed a couple of problem\n-\t  for namespace attributes handling.\n-\n-Mon Dec 30 00:59:07 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* entities.c parser.c tree.c include\/libxml\/entities.h: Fixed\n-\t  a really nasty problem raised by a DocBook XSLT transform\n-\t  provided by Sebastian Bergmann\n-\n-Sun Dec 29 12:13:18 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c python\/tests\/reader.py: fixed a bug pointed out\n-\t  by Stéphane Bidoul and integrated it into the tests\n-\n-Sat Dec 28 23:49:12 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c include\/libxml\/xmlreader.h doc\/libxml2-api.xml:\n-\t  extended the XmlTextReader API a bit, adding accessors for\n-\t  the current doc and node, and an entity substitution mode for\n-\t  the parser.\n-\t* python\/libxml.py python\/libxml2class.txt: related updates\n-\t* python\/tests\/Makefile.am python\/tests\/reader.py \n-\t  python\/tests\/reader2.py python\/tests\/reader3.py: updated a bit\n-\t  the old tests and added a new one to test the entities handling\n-\n-Sat Dec 28 22:11:57 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/libxml2class.txt \n-\t  python\/tests\/reader.py python\/tests\/reader2.py: changed the\n-\t  generator to provide casing for the XmlTextReader similar to\n-\t  C# so that examples and documentation are more directly transposable.\n-\t  Fixed the couple of tests in the suite.\n-\n-Sat Dec 28 15:55:32 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/guidelines.html: added a document on guildeline for\n-\t  publishing and deploying XML\n-\n-Fri Dec 27 20:35:15 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c xmlreader.c: final touch running DTD validation\n-\t  on the XmlTextReader\n-\t* python\/tests\/Makefile.am python\/tests\/reader2.py: added a\n-\t  specific run based on the examples from test\/valid\/*.xml\n-\n-Fri Dec 27 15:17:20 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.py: added a few predefined xmlTextReader parser\n-\t  configuration values.\n-\n-Fri Dec 27 12:57:22 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml_wrap.h: trying to fix #102037\n-\n-Fri Dec 27 12:18:14 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: fixing bug #95296, when the predefined entities\n-\t  are redefined in the DTD the default one must be used\n-\t  instead anyway.\n-\n-Wed Dec 25 19:22:06 MST 2002 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmllint.xml\n-\t* doc\/xmllint.1\n-\tAdd discussion of XML_DEBUG_CATALOG to xmllint man\n-\tpage - bug #100907\n-\n-Mon Dec 23 16:54:22 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c: Fixed the empty node detection to avoid reporting\n-\t  an nonexistent close tag.\n-\n-Mon Dec 23 15:42:24 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c python\/setup.py.in: patch from Stéphane Bidoul\n-\t  for Python 2.1\n-\n-Sun Dec 22 11:24:06 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testC14N.c vms\/config.vms: applied Craig A. Berry patches for VMS\n-\n-Fri Dec 20 11:27:49 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/libxml2-api.xml python\/tests\/reader.py: one really need\n-\t  to provide the base URI information when creating a reader parser\n-\t  from an input stream. Updated the API and the example using it.\n-\n-Fri Dec 20 01:11:30 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testReader.c xmlreader.c valid.c include\/libxml\/tree.h\n-\t  include\/libxml\/valid.h include\/libxml\/xmlreader.h: working on\n-\t  DTD validation on top of xml reader interfaces. Allows to\n-\t  validate arbitrary large instances. This required some extensions\n-\t  to the valid module interface and augmenting the size of xmlID\n-\t  and xmlRef structs a bit.\n-\t* uri.c xmlregexp.c: simple cleanup.\n-\n-Wed Dec 18 15:51:22 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c include\/libxml\/xmlreader.h doc\/libxml2-api.xml: more\n-\t  work on the xml reader interfaces.\n-\t* AUTHORS MAINTAINERS doc\/* win32\/*: updated Igor's mail and the\n-\t  Web page for the Windows binaries.\n-\n-Tue Dec 17 19:31:07 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: applied a patch for VMS following the report by\n-\t  Nigel Hall\n-\n-Tue Dec 17 11:29:41 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: the parseStartTag bug fix wasn't complete.\n-\n-Mon Dec 16 23:00:05 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: Vyacheslav Pindyura managed to trigger a bug in\n-\t  parseStartTag, fixing it.\n-\t* test\/att4 result\/att4 result\/noent\/att4: adding the test\n-\t* xmlreader.c include\/libxml\/xmlreader.h doc\/libxml2-api.xml: added\n-\t  more methods to XmlTextReader.\n-\n-Mon Dec 16 19:31:16 CET 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* win32\/libxml2.def.src: added more xml reader exports\n-\t* win32\/Makefile.msvc win32\/Makefile.mingw: added xml reader interface\n-\t  to the build\n-\n-Mon Dec 16 06:36:54 MST 2002 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/tutorial\/xmltutorial.xml\n-\tplus generated html and pdf\n-\tUpdating tutorial again based on further comments from Niraj\n-\tTolia on the last iteration\n-\n-Sun Dec 15 21:27:30 MST 2002 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/tutorial\/xmltutorial.xml\n-\t* doc\/tutorial\/includekeyword.c\n-\t* doc\/tutorial\/includegetattribute.c\n-\tplus generated html and pdf\n-\tAdding fix from Niraj Tolia to tutorial to properly free memory.\n-\n-Mon Dec 16 00:34:25 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c include\/libxml\/xmlreader.h doc\/libxml2-api.xml: added\n-\t  more methods of XmlTextReader.\n-\t* python\/libxml2class.txt python\/tests\/reader.py: this increased the\n-\t  methods in the bndings, augmented the test to check those new\n-\t  functions.\n-\n-Sat Dec 14 23:57:39 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlreader.c doc\/libxml2-api.xml: added the close and getattribute\n-\t  methods of XmlTextReader.\n-\t* python\/generator.py python\/libxml_wrap.h python\/types.c \n-\t  python\/libxml2class.txt: added the reader to the Python bindings\n-\t* python\/tests\/Makefile.am python\/tests\/reader.py: added a specific\n-\t  test for the Python bindings of the Reader APIs\n-\t* parser.c: small cleanup.\n-\n-Fri Dec 13 11:39:44 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: fallback was only copying the first child not the\n-\t  full child list of the fallback element, closes #89684 as reopened\n-\t  by Bernd Kuemmerlen\n-\n-Thu Dec 12 13:34:59 CET 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* win32\/libxml2.def.src: exported htmlNodeDumpOutput\n-\n-Thu Dec 12 10:59:11 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: preparing release of 2.4.30\n-\t* doc\/apibuild.py doc\/libxml2-api.xml: fixups to the api builder,\n-\t  gives enum values, fix functype return type, put back fields in\n-\t  structs \n-\t* doc\/*: updated the docs rebuilt\n-\n-Thu Dec 12 01:09:34 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c include\/libxml\/HTMLtree.h: patch from Mark Vakoc\n-\t  about htmlNodeDumpOutput location.\n-\t* xpath.c: removed an undefined function signature\n-\t* doc\/apibuild.py doc\/libxml2-api.xml: the script was exporting\n-\t  too many symbols in the API breaking the python bindings.\n-\t  Updated with the libxslt\/libexslt changes.\n-\n-Wed Dec 11 20:26:15 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: preparing release of 2.4.29\n-\t* doc\/*: rebuilt the docs and API\n-\t* xmlreader.c: a few more fixes for the XmlTextReader API\n-\n-Wed Dec 11 18:01:15 CET 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* include\/win32config.h: applied mingw patch from Magnus Henoch\n-\n-Wed Dec 11 16:58:48 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c doc\/libxml2-api.xml: a bit more cleanup\n-\n-Wed Dec 11 14:54:47 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/apibuild.py doc\/libxml2-api.xml doc\/Makefile.am: new API\n-\t  building Python script, does the C parsing directly, generates\n-\t  a better API description including structure fieds defs and\n-\t  enums. Still a couple of bugs, but good enough for the python\n-\t  wrappers now.\n-\t* DOCBparser.c SAX.c nanohttp.c parser.c parserInternals.c tree.c\n-\t  valid.c xmlIO.c xmlmemory.c xmlreader.c xmlregexp.c xmlschemas.c\n-\t  include\/libxml\/schemasInternals.h include\/libxml\/tree.h: more\n-\t  cleanup based on the python analysis script reports.\n-\t* libxml.spec.in: make sure the API XML description is part of the\n-\t  devel package.\n-\n-Tue Dec 10 16:16:34 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* DOCBparser.c HTMLparser.c c14n.c debugXML.c encoding.c hash.c\n-\t  nanoftp.c nanohttp.c parser.c parserInternals.c testC14N.c\n-\t  testDocbook.c threads.c tree.c valid.c xmlIO.c xmllint.c xmlmemory.c\n-\t  xmlreader.c xmlregexp.c xmlschemas.c xmlschemastypes.c xpath.c:\n-\t  code cleanup, especially the function comments.\n-\t* tree.c: fixed a small bug when freeing nodes which are XInclude ones.\n-\n-Mon Dec  9 15:08:17 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am xmlreader.c include\/libxml\/Makefile.am\n-\t  include\/libxml\/xmlreader.h:  Adding a new set of APIs based on\n-\t  the C# TextXmlReader API but converted to C. Allow to parse\n-\t  in constant memory usage, far simpler to program and explain\n-\t  than the SAX like APIs, unfinished but working.\n-\t* testReader.c: test program\n-\n-Sun Dec  8 18:36:01 CET 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* win32\/libxml2.def.src: applied YALDSP from Mark Vakoc\n-\n-Wed Dec  4 16:08:49 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: Chip turner indicated that XHTML1 serialization\n-\t  rule for style actually break on both IE and Mozilla, \n-\t  try to avoid the rule if escaping ain't necessary\n-\n-Wed Dec  4 12:43:28 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanhttp.c: handle HTTP URL escaping, problem reported by\n-\t  Glen Nakamura and Stefano Zacchiroli\n-\n-Sat Nov 30 12:19:17 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* DOCBparser.c HTMLparser.c parser.c valid.c xpath.c: code cleanup\n-\n-Thu Nov 28 12:53:22 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: Johann Richard pointed out some XPointer problems for\n-\t  URN based URI references in XInclude. Modified the URI parsing\n-\t  and saving routines to allow correct parsing and saving of \n-\t  XPointers, especially when attached to \"opaque\" scheme accordingly\n-\t  to RFC 2396\n-\n-Wed Nov 27 20:36:08 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c include\/libxml\/HTMLtree.h: applied the same kind\n-\t  of refactoring to the HTML saving code.\n-\t* doc\/libxml2-*.xml doc\/API*.html: slight API changes got reflected\n-\t  in the doc.\n-\n-Wed Nov 27 12:40:16 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c include\/libxml\/tree.h: refactored the XML dump of a node\n-\t  to a buffer API to reuse the generic dump to an OutputIO layer,\n-\t  this reduces code, fixes xmlNodeDump() for XHTML, also made\n-\t  xmlNodeDump() now return the number of byte written.\n-\n-Wed Nov 27 09:00:00 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/setup.py.in: another patch from Stéphane Bidoul for \n-\t  Python bindings on Windows\n-\t* doc\/parsedecl.py: small cleanup\n-\n-Mon Nov 25 17:28:53 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in configure.in: add a line in %changelog for releases\n-\n-Mon Nov 25 14:18:27 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: patch from Marcus Clarke fixing a problem in entities\n-\t  parsing that was detected in KDe documentations environment.\n-\n-Mon Nov 24 14:13:21 CET 2002 ERDI Gergo <cactus@cactus.rulez.org>\n-\n-\t* python\/libxml.c (libxml_prev): Return the previous as opposed to\n-\tthe next node (I guess this is the result of some cut & paste programming:)\n-\n-Sat Nov 23 17:22:22 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/Makefile.am: Jan Rafaj pointed a bug in the Makefile.\n-\n-Sat Nov 23 12:21:24 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/libxml.c python\/setup.py.in: trying\n-\t  to fix the Python bindings build on Windows (Stéphane Bidoul)\n-\n-Fri Nov 22 22:41:34 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* win32\/configure.js: added option for python bindings\n-\t* win32\/libxml2.def.src: added more exports\n-\n-Fri Nov 22 18:50:34 CET 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* win32\/Makefile.mingw: fixed unresolved symbols when linking with\n-\t  pthreads\n-\t* win32\/wince\/*: applied updates to Windows CE port from Javier\n-\n-Fri Nov 22 15:51:22 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: preparing 2.4.28\n-\t* libxml.spec.in doc\/Makefile.am: some cleanup\n-\t* doc\/*: updated the news and regenerated.\n-\n-Fri Nov 22 14:15:14 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: final touch at closing #87235 <\/p> end tags\n-\t  need to be generated.\n-\t* result\/HTML\/cf_128.html result\/HTML\/test2.html result\/HTML\/test3.html:\n-\t  this change slightly the output of a few tests\n-\t* doc\/*: regenerated\n-\n-Fri Nov 22 13:26:19 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c: fixing bug #99190 when UTF8 document are\n-\t  parsed using the progressive parser and the end of the chunk\n-\t  is in the middle of an UTF8 multibyte character.\n-\n-Fri Nov 22 13:13:00 HKT 2002 William Brack <wbrack@mmm.com.hk>\n-\n-\t* threads.c: fixed initialization problem in xmlNewGlobalState\n-\t  which was causing crash.\n-\t* globals.c: removed duplicate call to initxmlDefaultSAXHandler\n-\t  in xmlInitializeGlobalState.\n-\t* parserInternals.c: cleaned up ctxt->sax initialisation.\n-\n-Thu Nov 21 15:05:45 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c include\/libxml\/tree.h: modified the existing APIs\n-\t  to handle XHTML1 serialization rules automatically, also add\n-\t  xmlIsXHTML() to libxml2 API. Some tweaking to make sure\n-\t  libxslt serialization uses it when needed without changing\n-\t  the library API.\n-\t* test\/xhtml1 result\/noent\/xhtml1 result\/valid\/xhtml1.xhtml\n-\t  result\/xhtml1: added a new test specifically for xhtml1 output\n-\t  and updated the result of one XHTML1 test\n-\n-Wed Nov 20 14:24:56 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c parserInternals.c encoding.c: fixed #99082\n-\t  for xi:include encoding=\"...\" support on text includes.\n-\t* result\/XInclude\/tstencoding.xml test\/XInclude\/docs\/tstencoding.xml\n-\t  test\/XInclude\/ents\/isolatin.txt : added a specific regression test\n-\t* python\/generator.py python\/libxml2class.txt: fixed the generator\n-\t  the new set of comments generated for doc\/libxml2-api.xml were\n-\t  breaking the python generation.\n-\n-Tue Nov 19 23:25:47 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/Makefile.am: repair some problem if gtk-doc fail or such\n-\t* configure.in: patch for Solaris on new autoconf closes #98880 \n-\t* doc\/parsedecl.py: repair the frigging API building script,\n-\t  did I say that python xmllib sucks ?\n-\t* doc\/libxml2-api.xml doc\/libxml2-refs.xml: regenerated, reordering\n-\t  and some comment are no more truncated.\n-\n-Tue Nov 19 09:09:04 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: Martin Stoilov pointed out a potential leak in\n-\t  xmlCreateMemoryParserCtxt\n-\n-Mon Nov 18 16:05:51 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fixed bug #98879 a corner case when 0 is\n-\t  included in HTML documents and using the push parser.\n-\n-Mon Nov 18 00:11:24 CET 2002 ERDI Gergo <cactus@cactus.rulez.org>\n-\n-\t* configure.in (PYTHON_SITE_PACKAGES): If --with-python is\n-\t  specified, look for the Python interpreter not just in the\n-\t  specified root but also in the specified location. Fixes #98825\n-\n-Sun Nov 17 23:36:06 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c: fixing bug #98792 , node may have no doc\n-\t  and dereferencing without checking ain't good ...\n-\n-Sun Nov 17 10:25:43 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: preparing release 2.4.27\n-\t* doc\/* : updated and rebuilt the docs\n-\t* doc\/Makefile.am libxml.spec.in: try to make sure the tutorial\n-\t  and all the docs are actually packaged and in the final RPMs\n-\t* parser.c parserInternals.c include\/libxml\/parser.h: restore\n-\t  xmllint --recover feature.\n-\n-Sat Nov 16 16:30:25 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c xpath.c: fixing #96925 which was also dependent on the\n-\t  processing of parsed entities, and XPath computation on sustitued\n-\t  entities.\n-\t* testXPath.c: make sure entities are substituted.\n-\n-Fri Nov 15 16:22:54 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed #96594, which was totally dependent on the \n-\t  processing of internal parsed entities, which had to be changed.\n-\n-Fri Nov 15 12:16:07 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am python\/Makefile.am python\/tests\/Makefile.am:\n-\t  trying to fix bug #98517 about building outside the source tree\n-\t* doc\/xml.html doc\/FAQ.html: fixed the link to libiconv #94585\n-\n-Thu Nov 14 18:41:55 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* include\/win32config.h: cleanup\n-\t* win32\/Makefile.mingw: integrated mingw in JScript configure\n-\t* win32\/Makefile.msvc: modified to allow mingw coexistence\n-\t* win32\/configure.js: integrated mingw\n-\t* win32\/Readme.txt: cleanup\n-\n-Tue Nov 12 22:06:45 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: strengthen the guard in the Pop macros,\n-\t  like in the XML parser, closes bug #97315\n-\n-Tue Nov 12 21:56:39 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/parser.h: fixed bug #98338 , fatalError SAX\n-\t  callback is never used.\n-\n-Tue Nov 12 13:32:50 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c: fixed the initialization of the SAX structure\n-\t  which was breaking xsltproc\n-\t* xpath.c: patch from Petr Pajas for CDATA nodes\n-\t* tree.c: patch from Petr Pajas improving xmlGetNodePath()\n-\t* parser.c include\/libxml\/parser.h: patch from Peter Jones\n-\t  removing a leak in xmlSAXParseMemory() and adding the\n-\t  function xmlSAXParseMemoryWithData()\n-\n-Mon Nov 11 20:47:03 MST 2002 John Fleck <jfleck@inkstain.net>\n-\n-\tadding pdf of tutorial, changing web page to link to it\n-\t* doc\/tutorial\/xmltutorial.pdf\n-\t* doc\/xml.html\n-\t* doc\/docs.html\n-\n-Sun Nov 10 20:48:57 MST 2002 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/tutorial\/ar01s08.html\n-\tadding file what I forgot for tutorial\n-\n-Sun Nov 10 20:33:13 MST 2002 John Fleck  <jfleck@inkstain.net>\n-\n-\tAdding encoding discussion to tutorial\n-\tAdded:\n-\t* doc\/tutorial\/images\/*.png: DocBook admonition image files\n-\t* doc\/tutorial\/apf.html, apg.html: new generated html\n-\t* doc\/tutorial\/includeconvert.c: conversion code entity file\n-\tchanged:\n-\t* doc\/tutorial\/xmltutorial.xml: DocBook original\n-\t* doc\/tutorial\/*.html: generated html\n-\n-Fri Nov  8 17:59:32 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* include\/libxml\/*.h: retired xmlwin32version.h\n-\t* doc\/Makefile.am: retired xmlwin32version.h\n-\t* win32\/configure.js: retired xmlwin32version.h\n-\n-Fri Nov  8 16:55:47 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* win32\/libxml2.def.src: exported additional symbols\n-\t* include\/libxml\/xmlmemory.h: exported the rest of the xmlMem* \n-\t  sisterhood\n-\n-Fri Nov  8 16:08:13 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* globals.c: fixed a typo pointed out by Igor\n-\t* xpath.c: try to speed up node compare using line numbers\n-\t  if available.\n-\n-Thu Nov  7 15:16:02 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: make xmlFreeNode() handle attributes correctly.\n-\n-Wed Nov  6 23:51:11 CET 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* catalog.c: completed the #96963 fix, as reported by Karl\n-\t  Eichwalder\n-\n-Wed Nov  6 16:48:44 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpointer.c: tried to fix bug #97852 reported by Nicolas Noffke\n-\n-Sun Nov  3 10:43:44 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: switched the order of a couple of includes\n-\t  to fix bugs #97100\n-\n-Thu Oct 31 17:11:46 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* catalog.c: fixed bug #96963, reverted to the old behaviour of\n-\t  xmlLoadCatalogs that used to separate directories with a ':'.\n-\n-Thu Oct 31 16:55:21 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* threads.c: improvements to the Windows-side of thread handling\n-\t* testThreads.c: conditionally excluded unistd.h\n-\t* testThradsWin32.c: broke overlong lines\n-\t* include\/win32config.h: adapted thread-related macros to the new\n-\t  scheme and for pthreads on Windows\n-\t* win32\/Makefile.msvc: introduced a more flexible thread build, \n-\t  added testThreads[Win32].c to the build\n-\t* win32\/configure.js: introduced a more flexible thread config\n-\n-2002-10-31  John Fleck  <jfleck@inkstain.net>\n-\n-\t* doc\/xml.html (and, by implication, FAQ.html)\n-\tadded UTF-8 conversaion FAQ from Marcus Labib Iskander\n-\n-Tue Oct 29 18:32:33 CET 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* configure.in: removed xmlwin32version.h\n-\t* include\/libxml\/Makefile.am: removed xmlwin32version.h\n-\n-Mon Oct 28 14:01:29 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: applied patch from Brian Stafford to fix a bug\n-\t  in xmlReconciliateNs()\n-\n-Mon Oct 28 13:51:55 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: applied patch from Christian Glahn to allow\n-\t  xmlNewChild() on document fragment nodes\n-\n-Sat Oct 26 15:27:00 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: Christian Glahn found a problem with a recent\n-\t  patch to xmlParseBalancedChunkMemoryRecover()\n-\t* xmlschemas.c: Charles Bozeman fixed some Schemas validation\n-\t  problems\n-\t* result\/schemas\/elem* result\/schemas\/seq* test\/schemas.elem*\n-\t  test\/schemas\/seq*: added the test cases from Charles\n-\n-Wed Oct 23 16:42:29 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am config.h.in libxml.spec.in doc\/Makefile.am:\n-\t  serious cleanup of the spec file and associated changes\n-\t  in the Makefiles.\n-\t* valid.c: try to remove some warnings on x86_64\n-\n-Wed Oct 23 10:53:42 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/Makefile.am: added winsockcompat.h to EXTRA_DIST to\n-\t  fix bug #96586\n-\n-Tue Oct 22 21:13:06 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: Mikhail Sogrine pointed out a bug in HTML\n-\t  parsing, applied his patch\n-\t* result\/HTML\/attrents.html result\/HTML\/attrents.html.err\n-\t  result\/HTML\/attrents.html.sax test\/HTML\/attrents.html:\n-\t  added the test and result case provided by Mikhail Sogrine\n-\n-Tue Oct 22 19:33:20 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* vms\/build_libxml.com vms\/config.vms vms\/readme.vms\n-\t  include\/libxml\/parser.h include\/libxml\/parserInternals.h\n-\t  include\/libxml\/tree.h include\/libxml\/xmlIO.h\n-\t  HTMLparser.c catalog.c debugXML.c parser.c parserInternals.c\n-\t  tree.c triodef.h trionan.c uri.c xmlIO.c xpath.c:\n-\t  Applied the VMS update patch from Craig A. Berry\n-\t* doc\/*.html: update\n-\n-Tue Oct 22 16:27:31 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/encoding.h encoding.c: made xmlGetUTF8Char public\n-\n-Tue Oct 22 16:25:18 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c: adding a grep command to --shell in xmllint\n-\t  for T.V. Raman\n-\n-Tue Oct 22 16:23:57 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlcatalog.c: tried to fix some of the problem with --sgml\n-\n-Mon Oct 21 09:57:10 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: tried to fix bug #91500 where doc->children may\n-\t  be overridden by a call to xmlParseBalancedChunkMemory()\n-\n-Mon Oct 21 09:04:32 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: tried to fix bug #90945 w.r.t. parsing of system\n-\t  identifiers in SGML catalogs containing '&'\n-\n-Sun Oct 20 23:31:47 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/types.c: fixed bugs when passing result value tree\n-\t  to Python functions.\n-\n-Fri Oct 18 13:18:53 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: preparing the release of 2.4.26\n-\t* doc\/*: updated and rebuilt the documentation\n-\n-Wed Oct 16 20:01:46 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed a XML Namespace compliance bug reported by\n-\t  Alexander Grimalovsky\n-\n-Wed Oct 16 17:18:42 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c: fixed serialization of script and style when\n-\t  they are not lowercase (i.e. added using the API to the tree).\n-\n-Wed Oct 16 16:31:05 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: make xmlValidateDocument emit a warning msg if there\n-\t  is no DTD, pointed by Christian Glahn\n-\n-Wed Oct 16 16:05:38 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c xmlschemas.c: fixed the validation of sequences\n-\t  content model when some of the blocks have min or max, and a couple\n-\t  of bugs found in the process.\n-\t* result\/schemas\/list0* test\/schemas\/list0*: added some specific\n-\t  regression tests\n-\n-Tue Oct 15 12:41:01 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* README: updated the contact information\n-\n-Tue Oct 15 10:35:57 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: use test -f instead of test -e since Solaris \/bin\/sh\n-\t  misses it, reported by Peter Bray.\n-\n-Mon Oct 14 17:37:32 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: investigating xmlNodeGetContent() on namespace nodes\n-\t  and removed a few warnings\n-\n-Mon Oct 14 13:12:55 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: Christian Glahn found a small bug in the push parser.\n-\t* xmlIO.c include\/libxml\/xmlIO.h: cleaned up and made xmlCheckFilename\n-\t  public\n-\n-Wed Oct  9 23:11:02 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c include\/libxml\/xmlschemas.h: added\n-\t  xmlSchemaNewMemParserCtxt to parse a schemas from a memory area\n-\t* testSchemas.c: added --memory to test the new interface\n-\n-Wed Oct  9 16:22:54 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/index.py doc\/search.php: integrated the XSLT indexing,\n-\t  a few fixed in the indexer, added a scope selection at the\n-\t  search level.\n-\n-Wed Oct  9 12:18:37 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: Joe Marcus Clarke reported a segfault on FBsd \n-\t  this was due to uninitialized parts of the validation context\n-\n-Tue Oct  8 23:24:20 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c: applied patch from Mark Vakoc except the API\n-\t  change, preserved it.\n-\t* doc\/*: updated the docs to point to the search engine for\n-\t  information lookup or before bug\/help reports.\n-\n-Tue Oct  8 18:53:31 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/index.py doc\/search.php: added mailing-list archives\n-\t  indexing and lookup\n-\n-Tue Oct  8 10:25:07 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: patch from Mark Vakoc to fix xmlNodeGetPath()\n-\n-Mon Oct  7 13:12:03 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/index.py: improved HTML indexing\n-\t* doc\/search.php: make the queries also lookup the HTML based indexes\n-\n-Sun Oct  6 23:50:29 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/index.py: added HTML page indexing \n-\n-Fri Oct  4 15:33:55 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* xmlIO.c: extended Windows path normalisation to fix the base\n-\t  problem in libxslt.\n-\t* catalog.c: fixed list handling in XML_CATALOG_FILES\n-\n-Fri Oct  4 13:43:02 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: typo\/bug found by Christian Glahn\n-\n-Sun Sep 29 19:44:10 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* xmlIO.c: applied Windows CE patch from Javier.\n-\t* win32\/wince: new directory, contains support for the PocketPC\n-\t  with Windows CE from Javier.\n-\t* include\/win32config.h: reorganised, removed duplicate \n-\t  definitions and applied WinCE patch from Javier.\n-\t* include\/wsockcompat.h: new file, now contains WinSock\n-\t  compatibility macros.\n-\t* win32\/Makefile.msvc: introduced double-run compilation.\n-\n-Thu Sep 26 19:48:06 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in include\/libxml\/xmlwin32version.h: preparing release\n-\t  of 2.4.25\n-\t* doc\/*: updated and regenerated the docs and web pages.\n-\n-Thu Sep 26 17:33:46 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c valid.c include\/libxml\/valid.h: fixed bug #92518 validation\n-\t  error were not covering namespace declarations.\n-\t* result\/valid\/dia.xml test\/valid\/dia.xml: the test wasn't valid,\n-\t  it was missing the attribute declaration for the namespace\n-\t* result\/VC\/NS3: the fix now report breakages in that test\n-\n-Thu Sep 26 14:39:07 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c: fixing bug #94241 on HTML boolean attributes\n-\n-Thu Sep 26 14:25:33 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/*: added the 3 new modules xmlregexp xmlautomata and xmlunicode\n-\t  and regenerated the docs and web site\n-\n-Thu Sep 26 11:45:42 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c xmlschemas.c xmlschemastypes.c xpath.c: make sure\n-\t  ATTRIBUTE_UNUSED is always put after the attribute declaration,\n-\t  not before\n-\n-Thu Sep 26 11:33:28 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/libxml2class.txt: fixed a stupid error\n-\t  breaking the python API\n-\n-Thu Sep 26 00:31:46 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* trio.c trio.h triodef.h trionan.c trionan.h triop.h\n-\t  triostr.c triostr.h: applied a trio update patch from \n-\t  Bjorn Reese which should work with MinGW\n-\n-Thu Sep 26 00:21:18 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: improving some documentation comments\n-\t* xmlregexp.c: found and fixed a mem leak with python regression tests\n-\t* doc\/*: rebuilt the doc and the API XML file including the \n-\t  xmlregexp.h xmlautomata.h and xmlunicode.h headers\n-\t* python\/generator.py python\/libxml2class.txt python\/libxml_wrap.h\n-\t  python\/types.c: added access to the XML Schemas regexps from\n-\t  python\n-\t* python\/tests\/Makefile.am python\/tests\/regexp.py: added a \n-\t  simple regexp bindings test\n-\n-Tue Sep 24 08:10:48 MDT 2002 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xml.html:\n-\t  fixing ftp links - thanks to Vitaly Ostanin\n-\n-Tue Sep 24 16:08:17 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: fixed the data callback on transition functionality\n-\t  which was broken when using the compact form\n-\t* result\/schemas\/*: updated the results, less verbose, all tests\n-\t  pass like before\n-\t* DOCBparser.c testAutomata.c testC14N.c testSchemas.c testThreads.c\n-\t  testXPath.c valid.c xinclude.c xmllint.c xmlregexp.c xmlschemas.c\n-\t  xmlschemastypes.c xpath.c python\/libxml.c: removed a bunch of\n-\t  annoying warnings\n-\t* xpath.c: try to provide better error report when possible\n-\n-Sat Sep 21 14:56:37 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: fixed a breakage raised by Jacob\n-\n-Fri Sep 20 20:08:18 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* include\/win32config.h: added HAVE_ERRNO_H definition for parts\n-\t  which don't use sockets\n-\n-Fri Sep 20 18:40:50 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* win32\/Makefile.msvc: applied zlib patch from Daniel Gehriger\n-\t* win32\/configure.js: applied zlib patch from Daniel Gehriger\n-\n-Fri Sep 20 15:40:14 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* win32\/configure.js: applied the patch from Mark Vakoc for \n-\t  regexp support\n-\t* win32\/libxml2.def.src: applied the patch from Mark Vakoc\n-\t  for regexp support\n-\n-Fri Sep 20 15:35:33 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: as pointed by Igor Float and Double\n-\t  parsing ain't finished yet\n-\n-Fri Sep 20 14:00:16 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am configure.in: trying to fix #88412 by bypassing\n-\t  all the python subdir if python ain't detected\n-\n-Thu Sep 19 21:46:53 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am configure.in include\/libxml\/xmlversion.h.in:\n-\t  made configuring with regexps\/automata\/unicode the default\n-\t  but without schemas ATM\n-\t* testRegexp.c valid.c xmlregexp.c include\/libxml\/xmlregexp.h:\n-\t  fixed the regexp based DTD validation performance and memory\n-\t  problem by switching to a compact form for determinist regexps\n-\t  and detecting the determinism property in the process. Seems\n-\t  as fast as the old DTD validation specific engine :-) despite\n-\t  the regexp built and compaction process.\n-\n-Wed Sep 18 18:27:26 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: determinism is debugged, new DTD checking code now works\n-\t  but xmlFAComputesDeterminism takes far too much CPU and the whole\n-\t  set usues too much memory to be really usable as-is\n-\n-Wed Sep 18 00:54:30 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fixed another stupid bug in xmlGetNodePath()\n-\t* xmllint.c: --version now report the options compiled in\n-\n-Tue Sep 17 23:48:07 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: small cleanup\n-\t* valid.c xmlregexp.c: switched DTD validation to use only regexp\n-\t  when configured with them. A bit of debugging around the determinism\n-\t  checks is still needed\n-\n-Tue Sep 17 21:22:25 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml_wrap.h: stupid bug found by mattam@netcourrier.com\n-\n-Tue Sep 17 19:58:26 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: small portability glitch fixed.\n-\n-Mon Sep 17 12:38:08 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: incomplete steps for real\/double support\n-\t* testAutomata.c include\/libxml\/xmlautomata.h\n-\t  include\/libxml\/xmlregexp.h: avoiding a compilation problem\n-\t* valid.c include\/libxml\/valid.h: starting the work toward using\n-\t  the regexps for actual DTD validation\n-\n-Fri Sep 13 16:46:14 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* hash.c: cosmetic cleanup\n-\t* valid.c include\/libxml\/tree.h include\/libxml\/valid.h: started \n-\t  integrating a DTD validation layer based on the regexps\n-\n-Thu Sep 12 18:01:29 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c xmlschemas.c: fixed a bug reported by Jeff Goff,\n-\t  the determinism was tested before eliminating the epsilon\n-\t  transitions :-(\n-\n-Thu Sep 12 16:57:45 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/libxml.c python\/libxml.py\n-\t  python\/libxml2-python-api.xml python\/libxml2class.txt\n-\t  python\/libxml_wrap.h python\/types.c: updated the python\n-\t  bindings, added code for easier File I\/O, and the ability to\n-\t  define a resolver from Python fixing bug #91635\n-\t* python\/tests\/Makefile.am python\/tests\/inbuf.py\n-\t  python\/tests\/outbuf.py python\/tests\/pushSAXhtml.py\n-\t  python\/tests\/resolver.py python\/tests\/serialize.py: updated\n-\t  and augmented the set of Python tests.\n-\n-Tue Sep 10 21:05:28 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* win32\/configure.js: added more readme info for the binary\n-\t  package.\n-\n-Tue Sep 10 14:15:18 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: fixed a stupid out of bound array error\n-\n-Tue Sep 10 13:09:14 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlIO.h xmlIO.c parser.c HTMLparser.c DOCBparser.c:\n-\t  messing around with support for Windows path, cleanups,\n-\t  trying to identify and fix the various code path to the\n-\t  filename access. Added xmlNormalizeWindowsPath()\n-\n-Thu Sep  5 16:19:18 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* error.c valid.c: working on better error reporting of validity\n-\t  errors, especially providing an accurate context.\n-\t* result\/valid\/xlink.xml.err result\/valid\/rss.xml.err: better\n-\t  error reports in those cases.\n-\n-Thu Sep  5 13:29:47 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* DOCBparser.c HTMLparser.c c14n.c entities.c list.c\n-\t  parser.c parserInternals.c xmlIO.c: get rid of all the \n-\t  perror() calls made in the library execution paths. This\n-\t  should fix both #92059 and #92385\n-\n-Thu Sep  5 13:13:17 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: memory leak reporting was broken after a change\n-\t  of the preprocessor symbol used to activate it.\n-\n-Thu Sep  5 13:10:57 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: try to make the copy function work for node of\n-\t  type XML_DOCUMENT_FRAG_NODE, they are only created by the\n-\t  DOM layers though, not libxml2 itself.\n-\n-Thu Sep  5 12:57:38 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: try to provide file and line information, not all\n-\t  messages are covered, but it's a (good) start\n-\n-Thu Sep  5 12:49:35 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: reimplemented a large part of the XInclude\n-\t  processor, trying to minimize resources used, James Henstridge\n-\t  provided a huge test case which was exhibiting severe memory\n-\t  consumption problems.\n-\n-Thu Sep  5 10:07:13 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/Makefile.am: applied patch from Christophe Merlet to\n-\t  reestablish DESTDIR\n-\n-Wed Sep  4 14:13:34 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in: fixes library path for x86_64 AMD\n-\n-Tue Sep  3 21:14:19 MDT 2002 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/tutorial\/includekeyword.c\n-\t* doc\/tutorial\/xmltutorial.xml:\n-\t(plus resulting generated html files)\n-\tfixing one spot I missed in the tutorial where I hadn't freed\n-\tmemory properly\n-\n-Sat Aug 31 19:31:17 MDT 2002 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/tutorial\/includeaddattribute.c\n-\t* doc\/tutorial\/includeaddkeyword.c\n-\t* doc\/tutorial\/includegetattribute.c\n-\t* doc\/tutorial\/includekeyword.c\n-\t* doc\/tutorial\/xmltutorial.xml\n-\t* doc\/tutorial\/*.html:\n-\tupdate tutorial to properly free memory (thanks to Christopher\n-\tR. Harris for pointing out that this needs to be done)\n-\t* doc\/tutorial\/images\/callouts\/*.png:\n-\tadded image files so the callouts are graphical, making it\n-\teasier to read ( use \"--param callout.graphics 1\" to generate\n-\thtml with graphical callouts)\n-\n-Wed Aug 28 13:44:54 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/Libxml2-Logo-180x168.gif doc\/Libxml2-Logo-90x34.gif:\n-\t  nice logos generated by Marc Liyanage\n-\t* doc\/site.xsl *.html: changed the stylesheet to show the new\n-\t  logo and regenerated the pages\n-\n-Sun Aug 25 16:38:05 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: handle Windows specific file:\/\/localhost\/ semantic ...\n-\n-Thu Aug 22 22:03:19 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: possible mem leak patch from Jason Adams\n-\n-Thu Aug 22 17:27:30 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: integrated xf:escape-uri() from Wesley Terpstra\n-\t  in the XQuery namespace\n-\t* configure.in: preparing 2.4.24\n-\t* doc\/*.html: updated the web pages\n-\n-Thu Aug 22 16:19:42 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py: closing bug #85258 by generating conditional\n-\t  compile check to avoid linking to routines not configured in.\n-\n-2002-08-22  Havoc Pennington  <hp@pobox.com>\n-\n-\t* autogen.sh: update error message for missing automake\n-\n-Thu Aug 22 11:45:50 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/Makefile.am: typo in target name resulted in libxml2.py\n-\t  to not be rebuilt. fixed DESTDIR similarly to the libxslt one.\n-\n-Thu Aug 22 09:15:00 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/win32\/Makefile.mingw: updated with version from \n-\t  Elizabeth Barham at http:\/\/soggytrousers.net\/repository\/\n-\n-Tue Aug 20 16:40:48 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* win32\/Makefile.msvc: added the prefix location to the include\n-\tand lib search path.\n-\n-2002-08-18  Havoc Pennington  <hp@pobox.com>\n-\n-\t* autogen.sh: hardcode aclocal-1.4\/automake-1.4 so that users with\n-\tboth automake 1.6 and 1.4 installed get the right automake. Means\n-\tcompilation from CVS will now require the latest automake 1.4\n-\trelease, or manually creating symlinks called \"automake-1.4\" and\n-\t\"aclocal-1.4\"\n-\n-Wed Aug 14 18:54:19 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in python\/Makefile.am: more AMD 64 induced changes from\n-\t  Frederic Crozat\n-\n-Wed Aug 14 16:43:53 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: oops I was missing the xml:base fixup too\n-\t* result\/XInclude\/*.xml: this adds xml:base attributes to most\n-\t  results of the tests\n-\n-Wed Aug 14 16:05:37 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xinclude.c: quick but apparently working implementation of\n-\t  xi:fallback, should close bug #89684\n-\t* Makefile.am test\/XInclude\/docs\/fallback.xml \n-\t  result\/XInclude\/fallback.xml: added a basic test for fallback,\n-\t  and run with --nowarning to avoid a spurious warning\n-\t* configure.in: applied patch from Frederic Crozat for python\n-\t  bindings on AMD 64bits machines.\n-\n-Wed Aug 14 10:47:46 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: xmlSAXUserParseMemory() really ought to fail if\n-\t  the caller don't pass a SAX callback block.\n-\n-Wed Aug 14 10:29:02 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: applied the same fix for the XML-1.0 namespace to\n-\t  xmlSearchNsByHref() as was done for xmlSearchNs()\n-\n-Mon Aug 12 16:52:08 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.3: small cleanup of the man page\n-\t* HTMLtree.c: fixed a potential problem raised by Petr Vandrovec\n-\t  when serializing HREF attributes generated by XSLT.\n-\n-Mon Aug 12 15:24:05 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c include\/libxml\/HTMLtree.h: integrated a cleaned up\n-\t  version of Marc Liyanage' patch for boolean attributes in HTML\n-\t  output\n-\n-Mon Aug 12 14:11:59 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/tests\/serialize.py: fixed the test results, indenting\n-\t  behaviour changed slightly\n-\n-Thu Aug  8 11:00:26 2002  Aleksey Sanin  <aleksey@aleksey.com>\n-\n-\t* win32\/dsp\/libxml2.def.src win32\/libxml2.def.src: added\n-\tnew c14n function to Windows def files\n-\n-Fri Aug  2 16:46:46 2002  Aleksey Sanin  <aleksey@aleksey.com>\n-\n-\t* c14n.c: fixed a memory leak in c14n code\n-\n-Sat Aug  3 00:15:06 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c include\/libxml\/parser.h: adding a new API for Christian\n-\t  Glahn: xmlParseBalancedChunkMemoryRecover\n-\t* valid.c: patch from Rick Jones for some grammar cleanup in\n-\t  validation messages\n-\t* result\/VC\/* result\/valid\/*: this slightly change some of the\n-\t  regression tests outputs\n-\n-Thu Aug  1 14:50:28 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: trying to fix a problem in namespaced attribute handling\n-\t  raised by Christian Glahn\n-\n-Thu Aug  1 12:17:30 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c include\/libxml\/encoding.h: Opening the interface\n-\t  xmlNewCharEncodingHandler as requested in #89415\n-\t* python\/generator.py python\/setup.py.in: applied cleanup\n-\t  patches from Marc-Andre Lemburg\n-\t* tree.c: fixing bug #89332 on a specific case of losing \n-\t  the XML-1.0 namespace on xml:xxx attributes\n-\n-Wed Jul 31 23:27:42 2002  Aleksey Sanin  <aleksey@aleksey.com>\n-\n-\t* c14n.c include\/libxml\/c14n.h: fixed one more c14n + namespaces\n-\tcorner case from new Merlin's test suite and added a callback\n-\tthat will be used to improve xmlsec performance\n-\n-Mon Jul 29 18:22:00 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c: trying to fix the <style> escaping problem in\n-\t  HTML serialization bug #89342\n-\n-Thu Jul 25 01:33:47 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xml.html doc\/*.html: applied syntax patch from Rick Jones\n-\t  and rebuilt the web site.\n-\n-Mon Jul 22 11:04:48 PDT 2002  Aleksey Sanin <aleksey@aleksey.com>\n-\n-\t* include\/libxml\/tree.h: added _private member to xmlNs struct\n-\n-Sun Jul 21 17:48:47 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fixing bug #84876 based on the xml working\n-\t  code.\n-\n-Sun Jul 21 19:15:00 HKT 2002 William Brack <wbrack@mmm.com.hk>\n-\n-\t* python\/Makefile.am: enhanced to fix bug 72012 (errors\n-\t  when using '-jX' make parameter)\n-\n-Fri Jul 19 16:35:00 HKT 2002 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: small additional enhancement for booleans\n-\t  compared to nodesets\n-\n-Wed Jul 17 19:48:14 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c: changed the order of the encoding declaration\n-\t  attributes in the meta tags due to a bug in IE\/Mac\n-\n-Fri Jul 12 08:45:00 HKT 2002 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: enhanced handling of booleans (especially '='\n-\t  and '!=' for nodesets) - fixes bug 85256.  Added new\n-\t  routine xmlXPathNotEqualValues for more proper handling\n-\t  of '!=' when nodesets are involved.\n-\n-Thu Jul 11 21:45:52 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/Makefile.am: fixing Red Hat bug #68614 by adding the\n-\t  doc\/xmlcatalog_man.xml to the source distribution\n-\n-Wed Jul 10 21:26:13 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* win32\/Makefile.msvc: Added a copy *.pdb to install, few have\n-\t  asked for this.\n-\n-Sat Jul  6 21:55:59 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: preparing 2.4.23\n-\t* doc\/*: rebuilt the docs\n-\n-Sat Jul  6 21:11:20 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixing bug #84169 by fixing the\n-\t  comment of xmlCreatePushParserCtxt to describe the \n-\t  encoding detection parameters better.\n-\n-Sat Jul  6 19:44:56 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: fixing bug #79331 in one path the lookup for\n-\t  ID attributes on a namespaced node wasn't handled correctly :-\\\n-\n-Fri Jul  5 20:07:43 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: trying to fix 87235 about discarded white\n-\t  spaces in the HTML parser.\n-\t* result\/HTML\/*: this changes the output of a number of HTML\n-\t  regression tests\n-\n-Mon Jul  1 23:23:41 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: applied patch from Richard Jinks for the namespace\n-\t  axis + fixed a memory error.\n-\t* parser.c parserInternals.c: applied patches from Peter Jacobi\n-\t  removing ctxt->token for good.\n-\t* xmlschemas.c xmlschemastypes.c: fixed a few memory leaks\n-\t  popped out by the regression tests.\n-\t* Makefile.am: patch for threads makefile from Gary Pennington\n-\n-Fri Jun 28 19:38:00 HKT 2002 William Brack <wbrack@mmm.com.hk>\n-\n-\t* xpath.c: enhanced behaviour of position() after usage of\n-\t  expressions involving preceding-sibling (et al).\n-\n-Tue Jun 18 09:58:48 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* hash.c: applied a patch from Peter Jacobi to solve a problem\n-\t  when compiling with the Watcom C on Win32 \n-\t* result\/schemas\/*.err: the change of hashing algo generated\n-\t  permutations in the output\n-\n-Mon Jun 17 19:02:49 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* hash.c: applied patch from Sander Vesik improving the quality of\n-\t  the hash function.\n-\n-2002-06-14  Aleksey Sanin  <aleksey@aleksey.com>\n-\n-\t* DOCBparser.c HTMLparser.c debugXML.c encoding.c\n-\tnanoftp.c nanohttp.c parser.c tree.c uri.c xmlIO.c\n-\txmllint.c xpath.c: replaced sprintf() with snprintf()\n-\tto prevent possible buffer overflow (the bug was pointed\n-\tout by Anju Premachandran) \n-\n-Thu Jun 13 17:30:25 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: removed an uninitialized data error popped by valgrind\n-\t  on PE references\n-\n-Wed Jun 12 21:38:46 MDT 2002 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xml.html\n-\tadding tutorial reference to the web page\n-\n-Wed Jun 12 21:26:08 MDT 2002 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/tutorial\/xmltutorial.xml\n-\t* doc\/tutorial\/ar01s07.html\n-\t* doc\/tutorial\/ape.html\n-\t* doc\/tutorial\/includegetattribute.c\n-\tadding section to tutorial about retrieving an attribute\n-\tvalue\n-\n-Tue Jun 11 12:07:04 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: applied a couple of patches from Peter Jacobi to start\n-\t  to get rid of ctxt->token, with a possible significant speed\n-\t  improvement to be gained once done. Better compliance with PE\n-\t  references constructs in DTDs too.\n-\t* test\/valid\/t[0-9]* result\/valid\/t[0-9]*: added a set of tests\n-\t  from Peter too\n-\n-Tue Jun 11 09:25:12 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: Babak Vahedipour-Kunze reported that openTag in \n-\t  xmlParseElement was likely to have been deallocated at the\n-\t  time of the report, possibly leading to segfault. Just report\n-\t  the tag name now.\n-\n-Mon Jun 10 18:00:02 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: patch from Richard Jinks for XPath substring() function\n-\t* result\/XPath\/expr\/strings test\/XPath\/expr\/strings: new set of tests\n-\n-2002-06-06  Aleksey Sanin  <aleksey@aleksey.com>\n-\n-\t* xmlIO.c: patch from Rachel Hestilow to fix bug #84340\n-\n-Wed Jun  5 19:14:49 MDT 2002 John Fleck <jfleck@inkstain.net>\n-\n-\t*doc\/FAQ.html\n-\tfixing typos in FAQ, thanks to Robert Funnell for the\n-\tediting help\n-\n-Wed Jun  5 14:50:24 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* NEWS: got complaints from rpmlint that it was empty\n-\n-Tue Jun  4 09:09:18 MDT 2002 John Fleck <jfleck@inkstain.net>\n-\n-\t* added doc\/tutorial, including:\n-\tapa.html\n-\tapb.html\n-\tapc.html\n-\tapd.html\n-\tar01s02.html\n-\tar01s03.html\n-\tar01s04.html\n-\tar01s05.html\n-\tar01s06.html\n-\tincludeaddattribute.c\n-\tincludeaddkeyword.c\n-\tincludekeyword.c\n-\tincludestory.xml\n-\tindex.html\n-\txmltutorial.xml\n-\tlibxml tutorial, including generated html\n-\n-Mon Jun  3 21:21:26 2002  Aleksey Sanin  <aleksey@aleksey.com>\n-\n-\t* result\/c14n\/exc-without-comments\/merlin-c14n-two-*\n-\t  result\/c14n\/without-comments\/merlin-c14n-two-*\n-\t  test\/c14n\/exc-without-comments\/merlin-c14n-two-*\n-\t  test\/c14n\/without-comments\/merlin-c14n-two-*\n-\t  testC14N.c Makefile.am: added merlin-c14n-two.tar.gz tests for \n-\tc14n\/exc-c14n and slightly modified test script to handle\n-\tthese test cases\n-\t* c14n.c: fixed bugs for complicated nodes set (namespace\n-\twithout node and others from merlin-c14n-two.tar.gz)\n-\t* include\/libxml\/xpathInternals.h win32\/dsp\/libxml2.def.src\n-\twin32\/libxml2.def.src: \"opened\" xmlXPathNodeSetFreeNs() function\n-\tfor xmlsec performance patch\n-\t* xpath.c: fixed self::node() for namespaces and attributes\n-\n-Mon Jun 03 00:04:21 2002 Chema Celorio <chema@ximian.com>\n-\n-\t* tree.h: added xmlDocFormatDump which is just as xmlDocDump\n-\t  but with the format parameter\n-\t* tree.c: made xmlDocDump a wrapper around xmlDocFormatDump\n-\n-Fri May 31 12:16:48 2002  Aleksey Sanin  <aleksey@aleksey.com>\n-\n-\t* Makefile.am: updated c14n tests suite\n-\t* c14n.c: performance improvement for previous c14n patch\n-\n-Fri May 31 11:47:12 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: another peroformance patch from Peter Jacobi, that\n-\t  time on parsing attribute values.\n-\n-Thu May 30 23:34:27 2002  Aleksey Sanin  <aleksey@aleksey.com>\n-\n-\t* Makefile.am result\/c14n\/* test\/c14n\/*: C14N tests integrated\n-\tinto LibXML2 test suite\n-\n-Thu May 30 21:23:06 2002  Aleksey Sanin  <aleksey@aleksey.com>\n-\n-\t* c14n.c: propagating xpath ancesstors node fix to c14n\n-\tplus small performance improvement to reduce number of\n-\tmallocs\n-\t* xpath.c: fixed ancestors axis processing for namespace nodes\n-\n-Wed May 29 10:21:39 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c parser.c tree.c include\/libxml\/tree.h: performance patch from\n-\t  Peter Jacobi\n-\n-Mon May 27 23:18:33 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: preparing 2.4.22\n-\n-Mon May 27 16:44:04 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c win32\/libxml2.def.src win32\/dsp\/libxml2.def.src\n-\t  include\/libxml\/HTMLparser.h: fixing #79334 making htmlParseDocument\n-\t  a public entry point.\n-\t* doc\/*: rebuilt the API and docs\n-\n-Mon May 27 14:16:28 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: patch from Richard Jinks to fix a problem introduced\n-\t  in the previous patch and pointed by Norm\n-\n-Fri May 24 13:10:22 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in: fixing bug #81112\n-\n-Fri May 24 13:03:24 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: fixing bug #82848\n-\n-Fri May 24 09:54:49 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* result\/catalogs\/mycatalog.full: Aleksey's commit changed the\n-\t  output of one catalog test\n-\n-Fri 24 May 2002 12:17:45 AM PDT Aleksey Sanin <aleksey@aleksey.com>\n-\n-\t* global.data globals.c tree.c include\/libxml\/globals.h \n-\twin32\/libxml2.def.src win32\/dsp\/libxml2.def.src: changed\n-\tdefault value for global parameter xmlIndentTreeOutput to 1 and\n-\tintroduced new global parameter xmlTreeIndentString (the string\n-\tused to do one-level indent) with default value \"  \" (as it was\n-\tin tree.c)\n-\n-Thu May 23 13:55:57 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: Merijn Broeren pointed out a problem when compiling\n-\t  with trio and schemas.\n-\n-Wed May 22 11:57:49 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: patch from Richard Jinks to fix the problem raised in\n-\t  http:\/\/mail.gnome.org\/archives\/xml\/2002-April\/msg00246.htm\n-\n-Wed May 22 08:38:19 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: a bit of work on import.\n-\t* xmlschemastypes.c: Charles Bozeman provided a compare function\n-\t  for date\/time types so min\/max facet restrictions should work,\n-\t  indeterminate comparisons return an error instead of equal.\n-\t* test\/schemas\/date_0* result\/schemas\/date_0_0: specific test\n-\t  from Charles Bozeman too\n-\n-Sat May 18 09:54:12 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.3 doc\/buildDocBookCatalog: apply a couple of patches\n-\t  from Christian Cornelssen fixing the man pages and the Catalog\n-\t  building script.\n-\t* xmlschemas.c include\/libxml\/schemasInternals.h: nothing new yet\n-\t  next step is <xs:import> I now have a reasonable understanding\n-\t  of how it works.\n-\n-Thu May 16 10:43:26 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: applied a small buffer performance patch from Gary Pennington\n-\n-Wed May 15 00:25:34 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* win32\/libxml2.def.src: exported xmlXPathNodeSetAddNs()\n-\n-Tue May 14 13:00:48 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fixing an XPath function evaluation bug pointed out\n-\t  by Alexey Efimov where the context was lost when evaluating\n-\t  the function arguments\n-\n-Mon 13 May 2002 11:37:39 PM PDT Aleksey Sanin <aleksey@aleksey.com>\n-\n-\t* xpath.c include\/libxml\/xpathInternals.h: made xmlXPathNodeSetAddNs() \n-\t  function public for XMLSec performance optimizations\n-\n-Mon May 13 12:32:22 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/libxml2class.txt : fixed a problem\n-\t  with the HTML parser pointed by Gary Benson\n-\t* python\/tests\/Makefile.am python\/tests\/pushSAXhtml.py: sdding the\n-\t  example\n-\n-Thu 09 May 2002 11:19:00 AM PDT Aleksey Sanin <aleksey@aleksey.com>\n-\t* parser.c: fixed bug #81159 (memory growth in SAX)\n-\n-Tue 07 May 2002 09:20:21 AM PDT Aleksey Sanin <aleksey@aleksey.com>\n-\t* xpath.c: fixed bug #78858 (the real fix)\n-\n-Sat 04 May 2002 11:56:31 PM PDT Aleksey Sanin <aleksey@aleksey.com>\n-\t* xpath.c: fixed bug #78858 (quick and durty fix to hide the problem)\n-\n-Sun May  5 08:57:08 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: modified xmlNodeSetBase to allow changing the\n-\t  base of a document.\n-\n-Fri May  3 09:20:41 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemastypes.c: patch Charles Bozeman for validation of\n-\t  all the date, time, and duration types\n-\t* test\/schemas\/dur_0* result\/schemas\/dur_0*: associated tests\n-\t* configure.in: fixed an error pointed by an user\n-\t* xml2-config.in: fixed an error pointed by an user\n-\n-Wed 01 May 2002 11:29:27 AM PDT Aleksey Sanin <aleksey@aleksey.com>\n-\n-\t* include\/libxml\/xmlIO.h win32\/dsp\/libxml2.def.src\n-\twin32\/libxml2.def.src xmlIO.c: exported default\n-\t'file:', 'http:' and 'ftp:' protocols input handlers \n-\tand made protocols comparison case insensitive\n-\n-Tue Apr 30 16:29:05 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: Neven Has detected a typo\n-\n-Tue Apr 30 08:48:11 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* AUTHORS HACKING: added Aleksey Sanin <aleksey@aleksey.com>\n-\t  as one of the persons allowed to commit directly to the\n-\t  module.\n-\n-Mon Apr 29 17:48:26 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in include\/libxml\/xmlwin32version.h: preparing 2.4.21\n-\t* valid.c: raised a too low limit\n-\t* doc\/*: rebuilt the docs \n-\n-Wed Apr 24 13:41:03 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* test\/XPath\/expr\/floats test\/XPath\/expr\/functions\n-\t  result\/XPath\/expr\/floats result\/XPath\/expr\/functions\n-\t  xpath.c: another XPath conformance patch from Richard Jinks\n-\n-Tue Apr 23 19:50:40 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: fixed validation of attribute groups.\n-\t* test\/schemas result\/schemas: added an example from the primer\n-\n-Tue Apr 23 09:11:37 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am xmlschemas.c xmlschemastypes.c: more work on Schemas\n-\t* test\/schemas result\/schemas: updated the test list\n-\n-Mon Apr 22 17:59:14 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* TODO: updated a bit\n-\t* parser.c: made a comment more specific\n-\t* xmlregexp.c xmlschemas.c xmlschemastypes.c: more work on the\n-\t  Schemas conformance.\n-\t* test\/schemas result\/schemas: updated the test list\n-\n-Sat Apr 20 19:36:39 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c xmlschemas.c include\/libxml\/xmlautomata.h:\n-\t  implementing xs:all with minOccurs = 0\n-\t* tes\/schemas\/* result\/schemas\/*: added more tests covering\n-\t  xs:all\n-\n-Sat Apr 20 09:22:50 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c: first implementation of the all particle, this\n-\t  may need to be revisited for case where not all transitions\n-\t  must be crossed.\n-\n-Fri Apr 19 18:26:04 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: another entity processing update from Markus Henke\n-\n-Fri Apr 19 17:14:24 CEST 2002 Bjorn Reese <breese@users.sourceforge.net>\n-\n-\t* trionan.c: fixed crash on OSF\/1\n-\n-Fri Apr 19 09:00:56 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c: more Schemas work\n-\t* test\/schemas\/* result\/schemas\/*: added more tests coming\n-\t  from the spec.\n-\n-Thu Apr 18 23:00:02 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* c14n.c: patch from Aleksey Sanin reflecting a change in the\n-\t  ExcC14N specification\n-\n-Thu Apr 18 18:38:30 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: patch from Markus Henke, fix for recursive entities.\n-\n-Thu Apr 18 17:49:24 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fix a problem with string() on a document node.\n-\n-Thu Apr 18 16:40:42 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am xmlschemas.c: more Schemas work\n-\t* test\/schemas\/* result\/schemas\/*: added more tests coming\n-\t  from the spec.\n-\n-Thu Apr 18 13:52:52 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c: fixed & serialization bug introduced in 2.4.20\n-\t* result\/HTML\/*: this changes a few things in the results\n-\n-Wed Apr 17 20:34:37 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* include\/libxml\/tree.h: eliminated 'declaration different than\n-\t prototype' warning\n-\t* include\/win32config.h: \"resolved\" conflicts with errno.h\n-\n-Wed Apr 17 18:26:07 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlregexp.c xmlschemas.c include\/libxml\/xmlautomata.h: more work\n-\t  on the automata interfaces and debug of counted choices\n-\t* test\/schemas\/* result\/schemas\/*: added a number of tests\n-\n-Wed Apr 17 11:03:03 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlschemas.c xmlschemastypes.c include\/libxml\/xmlschemas.h:\n-\t  a bit of work on Schemas\n-\t* testSchemas.c: try to make it more useful\n-\t* test\/schemas\/* result\/schemas\/* Makefile.am: changed the\n-\t  Schemas regression test procedure, started adding a few samples\n-\n-Tue Apr 16 19:52:01 CEST 2002 Igor Zlatkovic <izlatkovic@stud.fh-frankfurt.de>\n-\n-\t* include\/libxml\/encoding.h: Patch for the Borland C++ builder\n-\t* include\/libxml\/tree.h: Patch for the Borland C++ builder\n-\t* threads.c: Patch for the Borland C++ builder\n-\t* win32\/bcb5: New directory for the Borland C++ builder\n-\t project files       \n-\n-Tue Apr 16 19:46:55 CEST 2002 Igor Zlatkovic <izlatkovic@stud.fh-frankfurt.de>\n-\n-\t* win32\/Makefile.msvc: Update for XML Schema support\n-\t* win32\/configure.js: Update for XML Schema support\n-\t* win32\/libxml2.def.src: Update for XML Schema support\n-\n-Tue Apr 16 17:46:43 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am TODO_SCHEMAS configure.in genUnicode.py testAutomata.c\n-\t testRegexp.c testSchemas.c xmlregexp.c xmlschemas.c xmlschemastypes.c\n-\t xmlunicode.c include\/libxml\/Makefile.am\n-\t include\/libxml\/schemasInternals.h include\/libxml\/xmlautomata.h\n-\t include\/libxml\/xmlregexp.h include\/libxml\/xmlschemas.h\n-\t include\/libxml\/xmlschemastypes.h include\/libxml\/xmlunicode.h\n-\t include\/libxml\/xmlversion.h.in : merged the current state of\n-\t XML Schemas implementation, it is not configured in by default,\n-\t a specific --schemas configure option has been added.\n-\t* test\/automata test\/regexp test\/schemas Makefile.am\n-\t  result\/automata result\/regexp result\/schemas:\n-\t  merged automata\/regexp\/schemas regression tests\n-\n-Tue Apr 16 09:48:44 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: Gary found a compile time problem, fixes #78823\n-\n-Mon Apr 15 19:11:36 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: release of 2.4.20\n-\t* doc\/*: updated and rebuilt the docs\n-\n-Mon Apr 15 14:55:53 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/Makefile.am: patch from Cristian Gafton to build on\n-\t  Red Hat 6.2, should also fix #75779\n-\n-Mon Apr 15 12:14:49 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: first part of fixing #78729\n-\n-Sun Apr 14 23:44:58 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c uri.c: fixing bug #78662 i.e. add proper\n-\t  escaping of URI when saving HTML files.\n-\t* result\/HTML\/*: this impacted some tests\n-\n-Sun Apr 14 14:55:15 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: trying to fix #77441\n-\n-Fri Apr 12 23:02:16 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlIO.h: Hallski complained it could not be\n-\t  included by itself.\n-\n-Thu Apr 11 10:23:36 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: applied an IEEE flag patch for OSF\/1 #77825\n-\n-Wed Apr 10 23:31:34 CEST 2002 Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-\t* win32\/configure.js: patch from Nilo for the c14n option\n-\t* win32\/Makefile.msvc: fixed libxml2.def generation with threads\n-\n-Wed Apr 10 21:24:16 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c include\/libxml\/xmlwin32version.h.in: Silvan Minghetti\n-\t  pointed erroneous use of LIBXML_THREADS_ENABLED instead of\n-\t   LIBXML_THREAD_ENABLED\n-\n-Wed Apr 10 18:12:52 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: another patch from Richard Jinks for substring conformance\n-\t* test\/XPath\/expr\/floats test\/XPath\/expr\/strings\n-\t  result\/XPath\/expr\/floats result\/XPath\/expr\/strings: update of the\n-\t  test suite to check those.\n-\n-Wed Apr 10 13:29:49 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: patch from Richard Jinks for .x float parsing.\n-\n-Tue Apr  9 18:09:31 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: patch from Markus Henke when an encoding ain't recognized\n-\n-Tue Apr  9 15:47:14 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.m4: got a report that #include <string.h> was needed\n-\n-Tue Apr  9 11:51:25 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: applied a fix from Anthony Jones for -o \/--output\n-\n-Tue Apr  2 20:27:11 MST 2002 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/example.html: fixing typo\n-\n-Mon Apr  1 10:02:57 CEST 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fixed a bug in the nodeset to boolean comparison code\n-\t  pointed out by Melvyn Sopacua.\n-\n-Fri Mar 29 23:41:53 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.m4: Frédéric Crozat gave a patch related to the change\n-\t  of Include paths breaking the libxml.m4\n-\n-Fri Mar 29 18:25:54 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: Fix bug #76927 forgot to save some context\n-\t  when evaluating binary expressions\n-\n-Thu Mar 28 19:22:48 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: fixed configure for MPE\/iX from Markus Henke\n-\t* xmlmemory.c: fixed initialization problems\n-\t* xpath.c: another set of patches from Richard Jinks this\n-\t  fixes \"make XPathtests\" on linux\n-\n-Wed Mar 27 17:09:43 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* trionan.c trionan.h xpath.c: more patches from Richard Jinks\n-\t* test\/XPath\/expr\/compare test\/XPath\/expr\/equality\n-\t  test\/XPath\/expr\/floats test\/XPath\/expr\/functions\n-\t  test\/XPath\/expr\/strings result\/XPath\/expr\/compare\n-\t  result\/XPath\/expr\/equality result\/XPath\/expr\/floats\n-\t  result\/XPath\/expr\/functions result\/XPath\/expr\/strings: Updated\n-\t  tests though they show a divergence on Linux\n-\n-Wed Mar 27 10:06:53 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c trionan.c: previous commit also included patches\n-\t  from Richard Jinks on some IEEE support corner case\n-\n-Wed Mar 27 10:03:11 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* AUTHORS HACKING: Added Igor Zlatkovic as official maintainer\n-\t* python\/Makefile.am python\/tests\/Makefile.am: Albert Chin pointed\n-\t  that $(datadir) should be used for docs\n-\n-Tue Mar 26 13:43:16 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: Thomas Steinborn pointed out #76404 that libxml2\n-\t  could leak filedescriptors\n-\n-Tue Mar 26 08:55:53 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in nanohttp.c: applied patch from Allan Clark for\n-\t  UnixWare\/OpenServer\n-\n-Mon Mar 25 17:45:44 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: preparing 2.4.19\n-\t* doc\/*: rebuilt the docs\n-\n-Mon Mar 25 17:34:06 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanohttp.c: fixing #76043, got fed up with non-portability\n-\t  of that piece of code.\n-\n-Mon Mar 25 13:08:21 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c SAX.c: Never commit without running \"make tests\" :-(\n-\t  fix a couple of stupidities in the previous commit\n-\t* result\/*: a few changes in some attribute order result of previous\n-\t  commit.\n-\n-Mon Mar 25 11:46:05 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c SAX.c: fixed bug #76168, attribute redeclared in\n-\t  the internal subset should not raise duplicate ID errors,\n-\t  also there was a small bug in conjunction to namespace\n-\t  declarations defaulted and xml:xxx attributes DTD definitions.\n-\n-Fri Mar 22 15:13:49 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: Richard Jinks also raised some rounding problems\n-\t  this tries to fix them\n-\n-Fri Mar 22 13:22:09 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: Richard Jinks spotted an incoherent memory allocation\n-\t  behaviour in xmlXPathCastToString()\n-\n-Thu Mar 21 14:25:29 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: fixed a bug in the ISO-Latin 1 to UTF8 encoder\n-\t  raised by Morus Walter\n-\n-Thu Mar 21 14:07:13 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlcatalog.c include\/libxml\/xmlversion.h.in: applied 2 fixups\n-\t  from Igor\n-\n-Thu Mar 21 13:30:06 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fixing #75619, related to a problem when trying\n-\t  to evaluate condition when the current node set resulting\n-\t  from that sub-step evaluation is empty. Also fixes 2 potential\n-\t  problem with previous-sibling and next-siblings axis.\n-\n-Thu Mar 21 09:03:59 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* c14n.c: patch from Mark Vakoc to build C14N if DocBook and\n-\t  HTML support is not configured in.\n-\n-Wed Mar 20 22:42:42 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c error.c parser.c parserInternals.c tree.c xmlIO.c\n-\t  include\/libxml\/tree.h: dohh I really didn't intended to commit\n-\t  this test version :-(\n-\n-Wed Mar 20 20:20:57 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testSAX.c: I wanted to see the real speed at the SAX interface\n-\t  after a little too many Ximianer started complaining about the\n-\t  parser speed.\n-\t  added a --quiet option:\n-\t  paphio:~\/XML -> ls -l db100000.xml \n-\t  -rw-rw-r--    1 veillard www      20182040 Mar 20 10:30 db100000.xml\n-\t  paphio:~\/XML -> time .\/testSAX --quiet db100000.xml \n-\t  3200006 callbacks generated\n-\t  real\t0m1.270s\n-\t  Which means 16MBytes\/s and 3Mcallback\/s\n-\n-Tue Mar 19 19:33:57 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: valgrind spotted another error that time when running\n-\t  on libxslt regression tests\n-\n-Tue Mar 19 15:24:49 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: adding \"make valgrind\" running the full regression\n-\t  tests (except python ones) under Valgrind (using valgrind -q\n-\t  which was kindly added by the author).\n-\t* valid.c: stupid bug pinpointed by Valgrind, the regression tests\n-\t  passes cleanly now except an obcure floating point initialization\n-\t  raised in log10() in one XPath regression test ???\n-\t* tree.c: edited some comments to close #75244\n-\n-Tue Mar 19 12:15:20 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: pretty insane thing, the xmlXPathFormatNumber()\n-\t  was not serializing 1 as \"1\" if LC_ALL=sv_SE :-( and in the\n-\t  context of ScrollKeeper, made sure that if the number is\n-\t  an integer, the serialization follows the description at\n-\t  http:\/\/www.w3.org\/TR\/xpath#section-String-Functions\n-\n-Mon Mar 18 19:18:13 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: preparing 2.4.18\n-\t* doc\/*: updated and rebuilt the web site\n-\t* *.c libxml.h: implement the new IN_LIBXML scheme discussed with\n-\t  the Windows and Cygwin maintainers.\n-\t* parser.c: humm, changed the way the SAX parser work when\n-\t  xmlSubstituteEntitiesDefault(1) is set, it will then \n-\t  do the entity registration and loading by itself in case the\n-\t  user provided SAX getEntity() returns NULL.\n-\t* testSAX.c: added --noent to test the behaviour.\n-\n-Mon Mar 18 12:44:23 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: Wilfried Teiken provided a hackish but working\n-\t  way to get context reported back on entities when parsing\n-\t  with SAX and without breaking the DOM build.\n-\n-Sun Mar 17 11:31:55 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* c14n.c: applied a new patch from Aleksey Sanin\n-\t* doc\/site.xsl doc\/xml.html doc\/*.html: updated the documentation\n-\t  to reference Aleksey implementation of XML digital Signatures\n-\n-Sat Mar 16 23:01:42 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: small fix to avoid potential problem due to\n-\t  ordering of freeing data\n-\t* python\/Makefile.am: people were complaining about \n-\t  the generated file in python dir not being built\n-\n-Fri Mar 15 23:21:40 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in python\/Makefile.am python\/tests\/Makefile.am\n-\t  python\/generator.py python\/libxml.c python\/types.c: Cleanup\n-\t  of the python Makefiles based on Jacob and James feedback,\n-\t  fixed the spec file accordingly, fixed the number of warning\n-\t  that passing my pedantic CFLAGS was generating. Conclusion\n-\t  is that Python includes are real crap.\n-\n-Fri Mar 15 19:41:25 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure,in: it was reported quite a few times that\n-\t  xml2-config --cflags should not output\n-\t  -I$includeprefix\/libxml2\/libxml because libxml2 header names\n-\t  clashes with existing names like list.h from C++ stl.\n-\t  Includes should be #include<libxml\/xxx.h> so ...\n-\n-Fri Mar 15 10:41:50 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* c14n.c: another patch from Aleksey Sanin\n-\n-Fri Mar 15 08:55:55 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* c14n.c: applied patch from Aleksey Sanin fixing a problem in the\n-\t  canonicalization algorithm\n-\t* doc\/xml.html doc\/index.html: added the C14N references on the \n-\t  index page.\n-\n-2002-03-13  jacob berkman  <jacob@ximian.com>\n-\n-\t* python\/Makefile.am: remove LDADD and CFLAGS as this is broken\n-\tusage, redundant, and gcc specific\n-\n-Wed Mar 13 11:00:59 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: speedup some node selection operations, this can\n-\t  have a significant impact on DocBook Norm's stylesheets\n-\t* nanohttp.c: someone reported that SOCKLEN_T may not be defined\n-\t  make sure it's always the case\n-\t* debugXML.c: distinguish CDATA and comments in ls operations\n-\n-Tue Mar 12 19:45:24 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/*.h: Heiko W. Rupp fixed a lot of comments\n-\t  to generate better API descriptions etc...\n-\n-Mon Mar 11 10:10:30 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* c14n.c: Fixing #74186, made sure all boolean expressions\n-\t  get fully parenthesized, ran indent on the output\n-\t* configure.in HTMLtree.c SAX.c c14n.c debugXML.c tree.c xpointer.c\n-\t  include\/libxml\/tree.h: also #74186 related, removed the\n-\t  --with-buffers option, and all the preprocessor conditional\n-\t  sections that were resulting from it.\n-\n-Sun Mar 10 17:47:58 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: applied patch from Dodji Seketeli fixing an\n-\t  uninitialized variable in xmlValidGetValidElements()\n-\n-Sat Mar  9 15:10:49 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* c14n.c: fixed a few comments\n-\t* doc\/*.html doc\/*\/*.html: regenerated the docs and added\n-\t  the C14N API\n-\t* doc\/api.xsl doc\/gnome-xml.sgml: fixups and added IDs\n-\n-Sat Mar  9 11:16:11 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* check-xml-test-suite.py: fix to adapt varaiations in the\n-\t  bindings\n-\t* configure.in python\/setup.py python\/setup.py.in: fixed to\n-\t  have the version of the python scripts automatically updated\n-\n-Fri Mar  8 16:45:55 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fixed a bug newly introduced and pointed by Uwe Fechner\n-\t  in xmlCopyProp()\n-\n-Fri Mar  8 15:49:10 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: preparing 2.4.17 release\n-\t* doc\/*: updated and rebuilt the docs\n-\t* xpath.c: fixed a comment\n-\t* python\/libxml.c: fixed a possible reentrancy problem\n-\n-Thu Mar  7 23:19:28 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c python\/tests\/Makefile.am python\/tests\/attribs.py:\n-\t  fixed xmlHasNsProp() bugs for defaulted from DTD attribs,\n-\t  added a specific regression test\n-\t* python\/generator.py: xmlHasNsProp() and xmlHasProp() shall\n-\t  not raise exceptions when failing to find the attribute.\n-\n-Thu Mar  7 16:11:35 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in xmllint.c: owen pointed out a problem with the\n-\t  ftme fix, gettimeofday() was not detected by configure and\n-\t  the ftime header wasn't included, dohhh\n-\n-Thu Mar  7 12:19:36 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in xmllint.c: trying to fix #71457 for timing\n-\t  precision when gettimeofday() is not available but ftime() is\n-\n-Thu Mar  7 11:24:02 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in doc\/Makefile.am: Fixed #73408 missing images\n-\t  are now copied on install and part of the -devel RPM\n-\n-Thu Mar  7 09:34:16 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: trying to avoid bug #72150 which was apparently\n-\t  caused by a gcc bug (or a processor problem) as detailed\n-\t  at http:\/\/veillard.com\/gcc.bug\n-\n-Thu Mar  7 01:02:37 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c python\/tests\/Makefile.am python\/tests\/cutnpaste.py:\n-\t  fixed xmlReconciliateNs(), added a Python test\/example for\n-\t  inter-document cut'n paste\n-\t* python\/libxml.py: fixed node.doc on document nodes and added\n-\t  xpathEval() onto node objects\n-\n-Wed Mar  6 22:38:03 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c: fixed some htmlSetMetaEncoding() problems\n-\t* python\/libxml.c python\/tests\/Makefile.am python\/tests\/serialize.py:\n-\t  fixup and integrated tests for the serialization stuff\n-\n-Wed Mar  6 19:40:57 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am libxml.3 libxml.4 libxml.spec.in: Fixed bug #72570\n-\t  moved the libxml man page to section 3\n-\n-Wed Mar  6 18:34:07 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fix bug #72490\n-\t* python\/libxml.c python\/libxml.py: added methods serialize()\n-\t  and saveTo() to all node elements.\n-\n-Tue Mar  5 21:27:03 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: closed #73430, don't read from an input source\n-\t  which indicated an end-of-file or an error.\n-\n-Tue Mar  5 16:33:42 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: make sure SAX endDocument is always called as\n-\t  this could result in a Python memory leak otherwise (it's\n-\t  used to decrement ref-counting)\n-\t* python\/generator.py python\/libxml.c python\/libxml.py\n-\t  python\/libxml2-python-api.xml python\/libxml2class.txt\n-\t  python\/tests\/error.py python\/tests\/xpath.py: implemented\n-\t  the suggestions made by Gary Benson and extended the tests\n-\t  to match it.\n-\n-Tue Mar  5 10:35:24 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py: applied patch fixing #73450\n-\n-Mon Mar  4 17:59:29 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fixing #61290 \"namespace nodes have no parent\"\n-\t  long standing divergence from the XPath REC. NodeSets\n-\t  simply hold a copy of namespace nodes and those node ->next\n-\t  points to the parent (which may not be the node carrying the\n-\t  definition).\n-\t* include\/libxml\/xpath.h: flagged but didn't added a possible\n-\t  speedup\n-\t* DOCBparser.c HTMLparser.c: removed some warnings from push\n-\t  parser due to new state being added.\n-\t* tree.c: new fix from Boris Erdmann\n-\t* configure.in c14n.c include\/libxml\/c14n.h testC14N.c: added\n-\t  the XML Canonalization support from Aleksey Sanin\n-\n-Sun Mar  3 15:12:42 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: patch from Boris Erdmann fixing some namespace odities\n-\t  with xmlCopyNode()\n-\n-Sat Mar  2 10:33:04 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: fix bug #72706 when loading a NULL entity\n-\n-Fri Mar  1 17:14:42 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: Fixed #72346, about handling of xmlns:foo=\"\", this could\n-\t  actually change in a future XML Namespace revision.\n-\n-Fri Mar  1 17:12:15 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/types.c python\/tests\/Makefile.am python\/tests\/xpathret.py:\n-\t  added the possibility of returning nodesets from XPath extension\n-\t  functions written in Python\n-\n-Fri Mar  1 13:56:12 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/*: committing some Python bindings work done while travelling\n-\n-Fri Mar  1 10:11:15 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: close #72663 and #72658, don't memdump unless compiled\n-\t  explicitly with memory debugging switched on\n-\n-Sat Feb 23 11:08:09 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/libxml.c python\/libxml2-python-api.xml\n-\t  python\/libxml2class.txt python\/libxml_wrap.h python\/types.c:\n-\t  Added wrapper for the xmlURIPtr type, provided accessors, fixed\n-\t  the accessor generator for strings\n-\t* python\/tests\/Makefile.am python\/tests\/tstURI.py: added a specific\n-\t  regression test.\n-\n-Fri Feb 22 23:44:57 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/README python\/generator.py python\/libxml.c python\/setup.py:\n-\t  added the 'usual' setup.py to allow building a libxml2-python\n-\t  module based on the same code. The initialization is however\n-\t  different the 2 .so files fo libxml2 and libxslt are identical and\n-\t  they entry point initialize both libraries. this is done to avoid\n-\t  some possible nasty problem since the Python don't merge the maps\n-\t  of all shared modules.\n-\n-Wed Feb 20 23:16:08 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed a push\/encoding bug reported by Michael\n-\t  on librsvg\n-\n-Wed Feb 20 19:54:05 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/parserInternals.h: fixes a misplaced #endif\n-\n-Wed Feb 20 17:47:55 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c valid.c: found and fixed a couple of allocation bugs\n-\n-Wed Feb 20 15:36:03 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xml.html doc\/python.html doc\/*: added a Python and binding\n-\t  page describing the current state of the Python bindings and \n-\t  giving pointers to the other languages wrappers.\n-\n-Wed Feb 20 11:16:15 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in include\/libxml\/xmlwin32version.h: preparing 2.4.16\n-\t* doc\/* python\/libxml2class.txt: updated and rebuilt the docs,\n-\t  rebuilt the API and web site\n-\t* xpath.c: fixed #71978 portability bugs\n-\n-Tue Feb 19 22:49:36 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: oops broke automatic defaulting of namespaces attributes.\n-\n-Tue Feb 19 22:01:35 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/parserInternals.h parser.c: had to change\n-\t  2 internal parsing API when processing document content\n-\t  to check the start and end of element content are defined\n-\t  in the same entity\n-\t* valid.c include\/libxml\/valid.h: attribute normalization can\n-\t  generate a validity error added xmlValidCtxtNormalizeAttributeValue()\n-\t  with the context to report it.\n-\t* SAX.c: fixed the last known bugs, crazy validation constraints\n-\t  when a document is standalone seems correctly handled. There\n-\t  is a couple of open issues left which need consideration especially\n-\t  PE93 on external unparsed entities and standalone status. \n-\t  Ran 1819 tests: 1817 succeeded, 2 failed and 0 generated an error in 8.26 s.\n-\t  The 2 tests left failing are actually in error. Cleanup done.\n-\n-Tue Feb 19 15:17:02 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: implemented E59 spaces in CDATA does not match the\n-\t  nonterminal S\n-\n-Tue Feb 19 14:44:53 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c parser.c valid.c: more validation test fixups\n-\t* check-xml-test-suite.py: added duration info for the tests\n-\n-Mon Feb 18 23:25:08 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c valid.c: a couple of errors were reported but not\n-\t  saved back as such in the parsing context. Down to 1% failure rate\n-\t  Ran 1819 tests: 1801 succeeded, 18 failed and 0 generated an error\n-\n-Mon Feb 18 20:16:15 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlInternald.c: isExtender was missing a char \n-\t* parser.c include\/libxml\/parser.h: % are acceptable in the\n-\t  internal subset if within a PUBLIC ID\n-\n-Mon Feb 18 19:27:32 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c parserInternals.c valid.c: more work on the conformance\n-\t  suite. Took the step to finally block documents with encoding\n-\t  errors. It's a fatal error per the spec, people should have fixed\n-\t  their documents by now.\n-\n-Mon Feb 18 15:30:14 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* check-xml-test-suite.py: fixed the test script after some discussion\n-\t  on the semantic of TYPE=\"error\"\n-\t* Makefile.am: added the script to the distrib\n-\n-Mon Feb 18 12:17:41 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c entities.c: fixed a couple of conformances issues deep\n-\t  into the validation code (standalone and undeclared Notations)\n-\n-Mon Feb 18 00:17:24 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed #71741 supid typo an a bug about encoding parsing\n-\t  stayed there for years !\n-\n-Mon Feb 18 00:06:42 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c SAX.c: fixed #71740 NotationDecl with a required field\n-\t  missing\n-\n-Sun Feb 17 23:45:40 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* check-xml-test-suite.py: improved the behaviour a bit as\n-\t  well as the logs\n-\t* parser.c valid.c SAX.c: fixed a few more bugs \n-\t  \"Ran 1819 tests: 1778 succeeded, 41 failed, and 0 generated an error\"\n-\n-Sun Feb 17 20:41:37 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* check-xml-test-suite.py: python script to run regression tests\n-\t  against the XML Test suite of W3C\/OASis\n-\t* SAX.c: fixed a validation bug\n-\t* parser.c: fixed 3 errors pointed by the test suite\n-\t* doc\/buildDocBookCatalog: fixed a typo pointed by drake\n-\t* python\/Makefile.am: fixed a dependendy\n-\n-Fri Feb 15 21:47:13 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlmemory.c: avoid a warning bug #71594\n-\n-Wed Feb 13 22:13:33 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlmemory.c: Jesse Perry provided a patch to remove a few\n-\t  warning on alpha\/Tru64\n-\n-Wed Feb 13 14:30:49 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/entities.h: fixing a comment\n-\t* valid.c: fixing some troubles with validity check on namespaces\n-\t* result\/VC\/NS3 test\/VC\/NS3: added a specific regression test\n-\n-Wed Feb 13 14:05:24 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: Fixing #71342 serializing '\\n' in attribute values\n-\t* result\/noent\/att3 result\/att3 test\/att3: added a specific\n-\t  test.\n-\n-Tue Feb 12 14:45:32 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c: couple of bug fixes\n-\n-Mon Feb 11 19:41:29 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/*.py: removed tabs and used spaces.\n-\n-Mon Feb 11 19:25:44 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in include\/libxml\/xmlwin32version.h: preparing 2.4.15\n-\t* doc\/news.html doc\/xml.html doc\/xmlio.html: rebuilt some docs\n-\n-Mon Feb 11 14:53:24 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xmlcatalog_man.xml: trying to close Red Hat bug #58707\n-\t  https:\/\/bugzilla.redhat.com\/bugzilla\/show_bug.cgi?id=58707\n-\n-Mon Feb 11 09:53:02 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/encoding.h include\/libxml\/entities.h\n-\t  include\/libxml\/globals.h include\/libxml\/parser.h\n-\t  include\/libxml\/threads.h include\/libxml\/tree.h\n-\t  include\/libxml\/xmlmemory.h: trying to fix the include mess\n-\n-Mon Feb 11 08:53:33 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlmemory.h: reverted part of the previous\n-\t  attempt to provide #69655, this was breaking the build.\n-\n-Sun Feb 10 14:13:34 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c Makefile.am build_glob.py configure.in debugXML.c\n-\t  globals.c parser.c threads.c tree.c valid.c xmlmemory.c\n-\t  xpath.c xpointer.c include\/libxml\/globals.h include\/libxml\/parser.h\n-\t  include\/libxml\/parserInternals.h include\/libxml\/tree.h\n-\t  include\/libxml\/xmlmemory.h include\/libxml\/xpathInternals.h:\n-\t  Tentatively fixed #69655 , make compiling with -Wredundant-decls\n-\t  clean.\n-\t* python\/libxml.c: fixed a warning.\n-\n-Sun Feb 10 12:02:59 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c valid.c xinclude.c: fix #68882, cleanup the XInclude\n-\t  copying of node, merge back IDs in the target document.\n-\t* result\/XInclude\/docids.xml test\/XInclude\/docs\/docids.xml\n-\t  test\/XInclude\/ents\/ids.xml: test case\n-\t* result\/VC\/ElementValid4: output changed due to a typo fix\n-\n-Sat Feb  9 23:15:04 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/Makefile.am: seems some version of automake didn't\n-\t  generate the dependencies right as Jacob found out. Add\n-\t  an extra dependency rule.\n-\n-Sat Feb  9 18:59:23 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c valid.c: Justin Fletcher found some parts\n-\t  of the code needing cleanup\n-\t* libxml.spec.in python\/Makefile.am python\/generator.py\n-\t  python\/libxml.c python\/libxml.py: Fixed the python Makefiles\n-\t  corrected a bug showing up on ia64, changed the name of the\n-\t  python internal module too\n-\n-Fri Feb  8 15:19:28 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: applied patch from Andris Pavenis for binary\n-\t  name suffixes\n-\n-Fri Feb  8 14:43:17 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c win32\/win32config.h: fixing #68748\n-\n-Fri Feb  8 14:37:05 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: fixing #70166\n-\n-Fri Feb  8 14:31:24 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: fixing #70077\n-\n-Fri Feb  8 14:24:02 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Copyright Makefile.am README configure.in libxml.spec.in:\n-\t  Changed to the MIT Licence\n-\t* doc\/FAQ.html doc\/catalog.html doc\/intro.html doc\/xml.html\n-\t  doc\/xmlio.html: updated the doc accordingly\n-\t* include\/libxml\/xmlwin32version.h configure.in: preparing\n-\t  2.4.14 release\n-\t* python\/generator.py python\/libxml.c python\/libxml2-python-api.xml\n-\t  python\/libxml2class.txt python\/libxml_wrap.h python\/types.c:\n-\t  fixed the const xmlChar * wrapper and generator, XPath extension\n-\t  functions now use the context as first argument\n-\t* python\/tests\/tstxpath.py python\/tests\/xpath.py\n-\t  python\/tests\/xpathext.py: Updated the tests accordingly\n-\t* tree.c: fixed bug #70067\n-\n-Thu Feb  7 17:33:58 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: cleanup\n-\t* debugXML.c: always use stdout if output is NULL\n-\t* xmlIO.c: don't close filedescriptors passed to outputBuffers\n-\t* python\/Makefile.am python\/generator.py python\/libxml2class.txt\n-\t  python\/libxml_wrap.h python\/types.c: augmented the number of bindings\n-\t  handling FILE * and XPath contexts\n-\t* python\/tests\/Makefile.am: avoid a stupid problem due to the\n-\t  use of TEST.\n-\n-Wed Feb  6 23:37:07 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: fixed stupid bug #70738 found by alfons hoogervorst\n-\n-Wed Feb  6 17:04:51 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/TODO python\/libxml.c: cleanup the extension function lookup\n-\t* xmlmemory.c include\/libxml\/xmlmemory.h: always compile the list\n-\n-Tue Feb  5 17:33:30 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in python\/Makefile.am: do not install outside\n-\t  of prefix\n-\n-Mon Feb  4 15:05:55 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/TODO python\/libxml.c: started adding SAX interfaces\n-\t* python\/tests\/Makefile.am python\/tests\/pushSAX.py: added a basic\n-\t  SAX test\n-\n-Mon Feb  4 01:12:42 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: hardened the addChild function\n-\t* python\/generator.py python\/libxml.c python\/libxml2-python-api.xml\n-\t  python\/libxml2class.txt python\/libxml_wrap.h python\/TODO:\n-\t  added accessors needed for xmlNode, a bit more testing and\n-\t  extension of interfaces\n-\t* python\/tests\/Makefile.am python\/tests\/build.py: added a test\n-\t  build from scratch\/save\/load\/check\n-\n-Sun Feb  3 21:10:39 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c: change a small bit in the way valididy\n-\t  error messages get initialized\n-\t* python\/TODO python\/libxml.c python\/libxml2-python-api.xml\n-\t  python\/libxml2class.txt python\/libxml_wrap.h python\/types.c:\n-\t  added some memory debugging to track leaks at the libxml2 level\n-\t* python\/tests\/*.py: changed all tests to check for leaks,\n-\t  there is just one left in XPath extension registrations.\n-\n-Sun Feb  3 17:50:46 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/TODO python\/generator.py python\/libxml2-python-api.xml\n-\t  python\/libxml2class.txt: more accessor classes for the parser\n-\t  context, allow to switch on and check validity\n-\t* python\/tests\/Makefile.am python\/tests\/error.py\n-\t  python\/tests\/invalid.xml python\/tests\/valid.xml\n-\t  python\/tests\/validate.py: added more test and added error.py\n-\t  which I forgot to commit in the last step\n-\n-Sun Feb  3 16:03:55 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/Makefile.am python\/types.c: cleanup\n-\t* python\/libxml.c python\/libxml.py python\/libxml_wrap.h\n-\t  python\/generator.py python\/libxml2-python-api.xml \n-\t  python\/libxml2class.txt: added class for parser context, added\n-\t  first cut for push mode support. Added a framework to generate\n-\t  accessors functions.\n-\t* python\/tests\/Makefile.am python\/tests\/push.py: added a push\n-\t  test\n-\n-Sun Feb  3 00:17:26 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/Makefile.am python\/TODO python\/libxml.py: fixed a small\n-\t  bug a bit of cleanup.\n-\n-Sat Feb  2 22:47:10 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/Makefile.am python\/libxml.c python\/libxml2-python-api.xml\n-\t  python\/libxml2class.txt: adding error redirections and preformat\n-\t  to a python handler\n-\t* python\/tests\/Makefile.am python\/tests\/*.py: cleanup made all\n-\t  tests self checking\n-\n-Sat Feb  2 13:18:54 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/libxml.c python\/libxml.py: fixed a stupid bug when renaming\n-\t  a function\n-\n-Sat Feb  2 11:25:51 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in python\/Makefile.am python\/TODO python\/generator.py\n-\t  python\/libxml.c python\/libxml2-python-api.xml\n-\t  python\/libxml2class.txt: Progressing through the TODOs, class\n-\t  description output, extra XML API, RPM now builds the wrappers\n-\t  for all python installed versions\n-\n-Sat Feb  2 10:13:52 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in libxml.spec.in python\/Makefile.am python\/TODO\n-\t  python\/generator.py python\/libxml2class.txt: added more information\n-\t  in the libxml2-python package including docs. Slightly changed\n-\t  the class hierarchy\n-\t* python\/tests\/*: added basic regression tests infrastructure too\n-\n-Fri Feb  1 23:11:58 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in libxml.spec.in example\/Makefile.am python\/Makefile.am:\n-\t  added libxml2-python as part of the packages installed\n-\n-Fri Feb  1 18:48:19 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/Makefile.am python\/generator.py python\/libxml.c\n-\t  python\/libxml.py: more work, now able to extend the\n-\t  XPath interpreter with functions written in python.\n-\n-Fri Feb  1 10:28:51 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/Makefile.am: Jacob sent a patch to allow building from\n-\t  tarfile.\n-\n-Fri Feb  1 00:40:48 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/Makefile.am python\/libxml.c configure.in Makefile.am:\n-\t  inserted the python wrappers build, I hope this won't be too\n-\t  unportable\n-\n-Thu Jan 31 21:27:37 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: minor optimization\n-\t* python\/generator.py python\/libxml.c python\/libxml.py\n-\t  python\/libxml_wrap.h: more work on the python bindings,\n-\t  they now support XPath and there is no evident leak\n-\n-Thu Jan 31 00:48:06 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/libxml.c python\/libxml.py:\n-\t  more work on the python bindings generator.\n-\n-Wed Jan 30 21:51:26 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/libxml.c python\/libxml_wrap.h:\n-\t  more work on the python bindings.\n-\n-Wed Jan 30 17:35:33 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* python\/generator.py python\/libxml.c python\/libxml.py\n-\t  python\/libxml_wrap.h: committed early version of a python binding\n-\t  for private use only ATM\n-\n-Sat Jan 26 22:41:13 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* entities.c tree.c include\/libxml\/entities.h: applied patch\n-\t  from Anthony Jones to implement copy of DTD subtree too. Had\n-\t  just to keep 2 function private which really ought to become\n-\t  public ones.\n-\n-Fri Jan 25 15:14:55 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: added pointers to the web pages in the usage()\n-\n-Thu Jan 24 17:04:04 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: more fixes from Petr Kozelka for attribute handling\n-\t  in the tree API to align the semantic with DOM.\n-\n-Thu Jan 24 16:00:53 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c tree.c entities.c: another set of patches from\n-\t  Anthony Jones for copy operations cleanup and robustness\n-\n-Wed Jan 23 18:53:55 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/APIchunk*.html doc\/parsedecl.py doc\/api.xsl: generated\n-\t  an alphabetic index based on comments content\n-\t* doc\/*: rebuilt the web site with the new references\n-\n-Wed Jan 23 15:14:22 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.h: Greg Sjaardema suggested to use an\n-\t  exponential buffer growth policy in xmlParserAddNodeInfo()\n-\n-Wed Jan 23 13:32:40 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/api.xsl doc\/APIconstructors.html doc\/APIfiles.html\n-\t  doc\/APIfunctions.html doc\/APIsymbols.html doc\/libxml2-refs.xml\n-\t  doc\/parsedecl.py doc\/Makefile.am: updated the python extractor\n-\t  to generate cross-references, and added\/updated the stylesheets\n-\t  to generate and link API indexes. The generic keyword index\n-\t  is not done yet.\n-\t* doc\/*.html: regenerated all the usual docs too\n-\n-Tue Jan 22 23:11:26 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c: added an xpath function to the shell for T. V. Raman\n-\n-Tue Jan 22 22:42:23 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c: patch from Anthony Jones to catch NULL nodes in\n-\t  debug routines.\n-\n-Tue Jan 22 22:38:42 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: apply an patch from Petr Kozelka for unlink and replace \n-\t  support of attribute nodes\n-\n-Tue Jan 22 19:12:06 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/libxml2-api.xml doc\/parsedecl.py: Build a new version\n-\t  hopefully near complete and fully documented of the API in XML\n-\t* HTMLtree.c SAX.c debugXML.c error.c globals.c parser.c tree.c\n-\t xmlIO.c xmlmemory.c include\/libxml\/catalog.h include\/libxml\/hash.h\n-\t include\/libxml\/list.h include\/libxml\/parser.h include\/libxml\/tree.h\n-\t include\/libxml\/parserInternals.h include\/libxml\/valid.hi\n-\t include\/libxml\/xmlIO.h include\/libxml\/xmlerror.hi\n-\t include\/libxml\/xmlmemory.h include\/libxml\/xmlversion.h.ini\n-\t include\/libxml\/xpath.h include\/libxml\/xpathInternals.h:\n-\t  Cleaned up the doc comments a lot in the process, the interface\n-\t  coverage is now 100%\n-\n-Tue Jan 22 00:12:58 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/libxml2-api.xml doc\/parsedecl.py: improved the script to\n-\t  extracts comments from the gtk-doc DocBook output (a bit\n-\t  convoluted but seems to work).\n-\n-Mon Jan 21 18:29:19 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am doc\/Makefile.am doc\/libxml2-api.xml doc\/parsedecl.py:\n-\t  added an XML description of the API, moved the script generating\n-\t  it here. Added a \"make api\" target\n-\n-Mon Jan 21 14:34:37 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: Adam Lounds pointed out a bug in xmlSearchNs()\n-\n-Mon Jan 21 09:55:21 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c include\/libxml\/xpathInternals.h: the change made to\n-\t  xmlXPathFuncLookupFunc was incompatible roll it back\n-\n-Sun Jan 20 23:03:41 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: cleanup patch from Anthony Jones\n-\t* doc\/Makefile.am: fix the headers to avoid in make scan\n-\t* parserInternals.c xpath.c include\/libxml\/*.h: cleanup of the\n-\t  includes, * vs Ptr and general cleanup\n-\t* parsedecl.py: first version of a script to extract the\n-\t  module interfaces, the goal will be to provide .decl or XML\n-\t  specification of the interfaces to build wrappers.\n-\n-Sun Jan 20 13:38:22 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/xmlcatalog_man.xml xmlcatalog.c: Fixed bug #68830, xmlcatalog\n-\t  now provides return codes in case of errors\n-\n-Sat Jan 19 16:36:21 CET 2002 Bjorn Reese <breese@users.sourceforge.net>\n-\n-\t* trio.h trio.c triodef.h triop.h trionan.h trionan.c Makefile.am:\n-\t  Upgraded to trio baseline 1.6\n-\t* strio.h strio.c: Replaced by triostr.h and triostr.c\n-\n-Fri Jan 18 17:22:50 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* globals.c xmlIO.c xmlcatalog.c: removed the last occurrences\n-\t  of strdup usage in the code\n-\n-Fri Jan 18 12:47:15 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c error.c: Keith Isdale complained rightly that \n-\t  xmlInitParser() did not preserve value set by xmlSetGenericErrorFunc\n-\n-Thu Jan 17 09:44:44 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fixed the funxtion to set the xml: attributes\n-\t* debugXML.c: added \"setbase\" to test it.\n-\n-Wed Jan 16 16:36:08 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: update xmlNodeSetContent() and xmlNodeSetContentLen()\n-\t  to allow updating an attribute content\n-\n-Tue Jan 15 18:09:23 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.h: try to avoid problems when compiling on Windows\n-\n-Mon Jan 14 18:56:25 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* hash.c: patch from Anthony Jones for hash.c allocation size\n-\t* Makefile.am: trying to work around Yet Another Libtool Madness\n-\t  and build the 2.4.13 release finally ...\n-\n-Mon Jan 14 18:27:19 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in include\/libxml\/xmlwin32version.h: updated to 2.4.13\n-\t* doc\/* : update of the documentation\n-\n-Mon Jan 14 17:53:41 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c tree.c: some cleanup after an unsuccessful attempt\n-\t  at fixing #61290 :-(\n-\n-Sun Jan 13 21:30:54 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fixed xmlSaveFormatFileEnc() when encoding == NULL\n-\t  Fixes bug #67229\n-\n-Sun Jan 13 17:14:06 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: trying to avoid troubles when a subtree is copied\n-\t  and coalesced in part with the target tree. Should fix \n-\t  bug #67407\n-\n-Sun Jan 13 16:37:15 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: fixed validation of attributes content of type\n-\t  NAME NAMES NMTOKEN and NMTOKENS to accept internationalized\n-\t  values, very old bug. Fixes #67671\n-\n-Sun Jan 13 15:07:49 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c include\/libxml\/parserInternals.h tree.c: integrated\n-\t  a couple of fixes and a new API function xmlSetEntityReferenceFunc()\n-\t  from Keith Isdale and dedicated to xsldbg the XSLT debugger.\n-\n-Sun Jan 13 14:23:21 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* threads.c: applied Serguei Narojnyi's patch to add native\n-\t  thread support on the Win32 platform\n-\t* testThreadsWin32.c Makefile.am: added the test program also\n-\t  from Serguei, Win32 specific\n-\t* include\/win32config.h include\/libxml\/xmlwin32version.h.in:\n-\t  added patch from Igor for the Windows thread specific defines.\n-\n-Wed Jan  9 12:50:39 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* entities.c: Anthony Jones pointed a bug in xmlCopyEntity()\n-\n-Tue Jan  8 14:23:22 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/*.html doc\/site.xsl doc\/Makefile: renamed XML.html\n-\t  output page into XMLinfo.html. Close bug #66951 and\n-\t  raised by Robert Collins too.\n-\n-Tue Jan  8 14:13:18 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c: Paul Keogh pointed out a possibility of segfault\n-\t  on repeted xmlAddEncodingAlias() \/ xmlCleanupEncodingAlias().\n-\t  Closes bug # 68238\n-\n-Tue Jan  8 12:48:27 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/*.html: updated the Gdome2 links\n-\n-Tue Jan  8 11:32:30 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.h: Applied following patches from Robert Collins\n-\t  and make sure IN_LIBXML is defined when compiling it\n-\t-------\n-\t* include\/libxml\/xmlversion.h.in (LIBXML_DLL_IMPORT): Use on Cygwin\n-\t  as well as Visual C.\n-\t* parser.c (XML_DIR_SEP): Don't use '\\\\' for Cygwin.\n-\t* parserInternals.c (XML_DIR_SEP): Don't use '\\\\' for Cygwin.\n-\t* strio.c (PLATFORM_UNIX): Define for Cygwin.\n-\t* triodef.h (TRIO_PLATFORM_UNIX): Define for Cygwin.\n-\t* xmlIO.c (xmlFileOpen): Use unix behaviour for Cygwin.\n-\t  Use binary mode opens for Cygwin (xmlFileOpenW xmlParserGetDirectory\n-\t  xmlSysIDExists xmlNoNetExists).\n-\t* xmllint.c: Don't include winsock2.h for Cygwin.\n-\n-Mon Jan  7 17:52:48 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: Jirka Kosek pointer out a bug in xmlParseTextDecl()\n-\t  when the version info is not present.\n-\n-Mon Jan  7 00:03:58 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: Anthony Jones  pointed out a problem in\n-\t  xmlStringGetNodeList() and provided a fix for it\n-\n-Sun Jan  6 13:45:49 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: patch from Frank J Franklin to remove a bug in\n-\t  xmlCreatePushParserCtxt() when the initial buffer passed\n-\t  is large.\n-\n-Sat Jan  5 19:24:23 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/*: big cleanup of the Windows\/MSVC project files\n-\t  from Igor Zlatkovic\n-\n-Wed Jan  2 14:11:35 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/Makefile.am: should fix #67674 and avoid troubles if \n-\t  xsltproc is not available or fails in the prefix provided\n-\n-Tue Jan  1 17:48:56 CET 2002 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlmemory.c: one more doc patch from Charlie Bozeman.\n-\n-Mon Dec 31 17:35:40 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* DOCBparser.c parser.c valid.c include\/libxml\/parserInternals.h\n-\t  include\/libxml\/xmlerror.h include\/libxml\/xpathInternals.h:\n-\t  Fixed a few other problems raised by Charlie Bozeman.\n-\t* result\/VC\/ElementValid[5-7]: fixed the output\n-\n-Mon Dec 31 17:13:34 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* *.c include\/libxml\/*.h doc\/html\/*: applied 42 documentation\n-\t  patches from Charlie Bozeman. Regenerated the HTML docs.\n-\n-Thu Dec 20 14:59:52 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/debugXML.h win32\/dsp\/libxml2.def.src: fixes\n-\t  for Windows from Igor\n-\n-Tue Dec 18 12:13:33 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: applied Justin Fletcher patch for --output or -o\n-\n-Tue Dec 18 08:52:32 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/libxml2\/libxml2.def.src: close #67019\n-\n-Tue Dec 18 08:08:51 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: applied Justin Fletcher generic timing patch\n-\t  similar to the one already applied to xsltproc.\n-\n-Mon Dec 17 16:29:08 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/tree.h tree.c: applied documentation patches\n-\t  from Charlie Bozeman\n-\n-Thu Dec 13 21:24:16 MST 2001 John Fleck <jfleck@inkstain.net>\n-\n-\t*doc\/xmllint.xml, xmllint.1 - document --dropdtd\n-\n-Thu Dec 13 23:19:50 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: fix the xmlStrdup() used in the previous patch.\n-\t* valid.c: added --dropdtd\n-\t* tree.c: fixed xmlUnlinkNode so it also removes the references\n-\t  from the document if the node is a DTD\n-\n-Thu Dec 13 15:54:35 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c valid.c: cleanup some static declarations\n-\n-Thu Dec 13 15:23:04 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: removed another strdup()\n-\t* doc\/FAQ: removed the HP\/UX entry\n-\n-Thu Dec 13 09:44:58 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: fix bug #66816 when validating.\n-\t* xmllint.c: don't use sys\/time.h if configure did not found it\n-\n-Mon Dec 10 21:39:55 MST 2001 John Fleck <jfleck@inkstain.net>\n-\n-\t* docs\/xmllint.1, xmllint.xml, xmlcatalog.1, xmlcatalog_man.html,\n-\txmlcatalog_man.xml\n-\n-Mon Dec 10 22:06:16 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlmemory.h: Hietaniemi Jarkko pointed out that\n-\t  xmlInitMemory() was declared twice\n-\n-Sun Dec  9 14:59:23 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* globals.c: do not reference strdup() !\n-\t* configure.in libxml-2.0.pc.in: trying to fix the libs\n-\t  of the various config extraction modules\n-\n-Fri Dec  7 15:21:33 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in : preparing 2.4.12\n-\t* doc\/* : updated and rebuilt the docs\n-\n-Fri Dec  7 12:32:00 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: closed bug #66159\n-\t* testURI.c: added --escape option\n-\t* configure.in: some cleanup for xml2-config --cflags\n-\n-Thu Dec  6 15:31:30 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* globals.c testThreads.c: removed some misplaced includes\n-\t  of xmlversion.h\n-\n-Thu Dec  6 09:06:08 EST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* threads.c: patch from Gary Pennington fixing a possible\n-\t  problem at initialization time.\n-\n-Wed Dec  5 13:01:37 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in libxml.h parser.c testThreads.c macos\/: integrated\n-\t  Eric Lavigne contribution to build libxml2 on MacOS using\n-\t  CodeWarrior.\n-\n-Tue Dec  4 14:13:44 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: applied Geert Kloosterman's patch to fix\n-\t  --repeat --timing output\n-\n-Thu Nov 29 17:10:22 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: Robin Berjon <robin@knowscape.com> found a case\n-\t  where non-wellformed XML declaractions were not detected.\n-\n-Wed Nov 28 15:41:40 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpointer.c: fixed a compilation bug pointed by Danny Jamshy\n-\n-Wed Nov 28 10:09:51 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: as robert pointed again, xmlInputCallbackInitialized\n-\t  gets reset by xmlCleanupInputCallbacks() and this makes the\n-\t  function useless. Same for output.\n-\n-Tue Nov 27 17:22:36 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: robert pointed out a loop error in callback cleanups\n-\n-Mon Nov 26 16:56:00 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c debugXML.c include\/libxml\/tree.h include\/libxml\/debugXML.h:\n-\t  moved xmlGetLineNo() and xmlGetNodePath() into the main tree module,\n-\t  they are not really tied to debugging\n-\n-Mon Nov 26 11:31:36 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in include\/libxml\/xmlwin32version.h: preparing 2.4.11\n-\t* xmllint.c: better --catalogs description\n-\n-Sun Nov 25 11:34:24 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: fixed a couple of problems in xmlSetProp()\n-\n-Thu Nov 22 19:19:10 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c tree.c xmlIO.c xmlmemory.c: some cleanups when chasing\n-\t  unappropriate stdout output.\n-\n-Thu Nov 22 13:58:14 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/tree.h: Fixed a couple of macro errors pointed out\n-\t  by Denis Beurive, closes #65111\n-\n-Tue Nov 20 10:34:01 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: in case of content model validity error, don't\n-\t  print it if validity warnings were not requested.\n-\n-Tue Nov 20 09:30:02 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanoftp.c: applied a couple of patches from Brian D Ripley.\n-\t* parserInternals.c: removed the last exit() call. Print an\n-\t  unmaskable error on stderr instead (library mismatch detection)\n-\n-Sat Nov 17 17:16:51 MST 2001 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmllint.xml, doc\/xmllint.1 - update xmllint man page with\n-\tshell instructions from Heiko Rupp\n-\n-Thu Nov 15 14:53:42 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: use the URL notation file:\/\/ for default catalog paths\n-\n-Wed Nov 14 16:03:02 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/tree.h: better comments for _private fields\n-\t* tree.c: removed a problem when copying an entity reference.\n-\n-Tue Nov 13 16:23:04 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* vms\/*: updated instructions and diffs from John A Fotheringham\n-\n-Mon Nov 12 23:43:22 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlerror.h: avoid an include problem if\n-\t  #include <libxml\/xmlerror.h> happens first in code\n-\t  seems to be the case in KDE libs\n-\n-Mon Nov 12 22:32:41 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/dsp\/* include\/libxml\/xmlwin32version.h.in: update\n-\t  from Igor for Windows\n-\n-Mon Nov 12 10:19:41 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: Gary Pennington pointed out a missing prefix\n-\n-Sat Nov 10 12:55:42 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in include\/libxml\/xmlwin32version.h: preparing 2.4.10\n-\t* doc\/*: upgraded and rebuilt the docs\n-\n-Sat Nov 10 12:33:38 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fix comment in scripts element parsing.\n-\t* result\/HTML\/doc3*: updated the results.\n-\n-Sat Nov 10 11:18:18 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: another URI bug fix #63336, using Joel Young patch.\n-\n-Sat Nov 10 11:07:26 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c include\/libxml\/debugXML.h: add xmlGetNodePath()\n-\t  a cleaned up version of the Pwd shell string generation.\n-\n-Fri Nov  9 00:34:13 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c include\/libxml\/tree.h: trying to fix namespaces +\n-\t  validation problems for good, closing #63619 in the process\n-\t* result\/valid\/dia.xml test\/valid\/dia.xml: the Dia test was\n-\t  wrong in this respect, fixed it.\n-\n-Thu Nov  8 18:31:40 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: Morus Walter patch to allow --format and --encode\n-\n-Thu Nov  8 14:52:18 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c: Stefan Kost provided an help command for the shell\n-\n-Wed Nov  7 14:32:55 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c: Heiko Rupp pointed that the shell would crash\n-\t  on empty nodesets returns.\n-\n-Wed Nov  7 13:52:36 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: Weiqi Gao pointed out that xmlcatalog\n-\t  migh need the history libraries\n-\n-Tue Nov  6 23:49:09 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c test\/HTML\/lt.html result\/HTML\/lt.html*:\n-\t  handle the case of < in quoted attributes, Bastian Kleineidam\n-\n-Tue Nov  6 16:21:33 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in include\/libxml\/xmlwin32version.h: releasing 2.4.9\n-\t  fixing catalog breakages\n-\t* Makefile.am catalog.c result\/catalogs\/catal \n-\t  result\/catalogs\/mycatalog.* test\/catalogs\/catal*:\n-\t  fixed more problems in catalog support, added more regression tests\n-\t  for both XML and SGML catalog handling\n-\n-Mon Nov  5 20:26:41 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c: applied an improvement to xmlGetLineNo() from\n-\t  Keith Isdale\n-\n-Mon Nov  5 15:20:16 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: dohhhh XML catalog add and remove ops were broken too.\n-\t  Side effect of the progressive catalog loading\n-\n-Mon Nov  5 12:40:54 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: confexecdir and confexec_DATA were defined twice\n-\t  pointed out by Karl Eichwalder\n-\n-Sun Nov  4 23:18:34 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlcatalog.c: avoid unlink() and use remove() instead.\n-\n-Sun Nov  4 23:12:38 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.spec.in: cleanup\n-\t* include\/libxml\/xmlwin32version.h: updated with 2.4.8\n-\n-Sun Nov  4 21:17:24 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c global.data globals.c testThreads.c: fix bug #63752\n-\t  of compiling libxml with a non standard set of options\n-\n-Sun Nov  4 13:11:41 MST 2001 John Fleck <jfleck@inkstain.net\n-\n-\t* doc\/xmllint.xml, xmllint.1 - updating xmllint man page to\n-\tdocument --sgml option, fixing gnome bugzilla #63382\n-\n-Sun Nov  4 20:56:53 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/catalog.h catalog.c: Fixed SGML catalogs\n-\t  breakage of 2.4.7, added a couple of really needed APIs\n-\t  like xmlCatalogIsEmpty() and xmlNewCatalog()\n-\t* xmlcatalog.c: updated --sgml --noout to be a suitable replacement\n-\t  for install-catalog\n-\t* configure.in: preparing 2.4.8\n-\n-Thu Nov  1 15:29:31 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c tree.c include\/libxml\/HTMLtree.h\n-\t  include\/libxml\/tree.h include\/libxml\/xmlIO.h: more include\n-\t  cleanups, export cleanly one html output + format function.\n-\n-Thu Nov  1 14:12:12 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: removed initGenericErrorDefaultFunc call from\n-\t  xmlInitParser() since it could destroy previous calls to\n-\t  xsltSetGenericErrorFunc() effects\n-\n-Thu Nov  1 09:37:13 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* debugXML.c include\/libxml\/debugXML.h: bool can be a reserved\n-\t  keyword.\n-\n-Wed Oct 31 18:50:08 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: cleanup\n-\t* threads.c: cleanup too\n-\t* xmlIO.c include\/libxml\/xmlIO.h: added xmlNoNetExternalEntityLoader()\n-\t  from xsltproc\n-\t* include\/libxml\/tree.h include\/libxml\/parser.h: trying to break a\n-\t  dependency loop.\n-\n-Tue Oct 30 18:38:53 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: Justin Fletcher pointed out that xmlParseXMLCatalog\n-\t  was not used anymore !\n-\n-Tue Oct 30 13:33:13 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: preparing 2.4.7\n-\t* Makefile.am doc\/Makefile.am: switched to the latest xmllint\n-\t  manual page from John\n-\t* doc\/*: updated the doc and rebuilt the generated pages\n-\n-Tue Oct 30 11:31:19 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: closing bug #62711, the library should never\n-\t  close stdin or stdout.\n-\n-Tue Oct 30 10:46:12 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: second pass at fixing #63336, using Joel Young\n-\t  final patch. looks okay.\n-\n-Tue Oct 30 00:56:05 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c include\/libxml\/uri.h: trying to clear #63336\n-\t  allowing the escaping routine to parse unconformant\n-\t  URI-References.\n-\n-Mon Oct 29 19:09:46 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* vms\/readme.vms vms\/build_libxml.com nanoftp.c \n-\t  include\/libxml\/xmlversion.h.in: a few VMS updates from\n-\t  John A Fotheringham\n-\t* include\/libxml\/xmlIO.h xmlIO.c: added xmlCleanupInputCallbacks()\n-\t  and xmlCleanupOutputCallbacks() for the Perl binding people.\n-\n-Mon Oct 29 12:44:17 CET 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c globals.c DOCBparser.c HTMLparser.c error.c:\n-\t  apply fixes to close #63271 and avoid segfaults when\n-\t  the error routine gets callbed before xmlInitParser()\n-\t  get called.\n-\t* nanoftp.c error.c: Applied patches from Justin Fletcher\n-\t  correcting some xmlGenericError misuses.\n-\n-Sat Oct 27 14:04:45 MDT 2001 John Fleck <jfleck@inkstain.net>\n-\n-\t*doc\/xmllint.xml, doc\/xmllint.1\n-\tNew and improved man page for xmllint - .xml is the original, .1\n-\tis the generated man page\n-\n-Wed Oct 24 14:34:25 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/site.xsl doc\/*.html doc\/Makefile.am: now autogenerate\n-\t  the web site from the main HTML document.\n-\n-Tue Oct 23 14:32:04 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: fixed an erroneous validation bug when PE refs\n-\t  occurs in external parsed entities referenced from the\n-\t  internals subset\n-\t* test\/valid\/index.xml test\/valid\/dtds\/nitf-2-5.dtd\n-\t  test\/valid\/dtds\/NewsMLv1.0.dtd result\/valid\/index.xml*:\n-\t  added the associated testcase, it's a nice one.\n-\t* HTMLparser.c: generate the DTD node as HTML still ...\n-\t* HTMLtree.c: fixed errors in Set\/GetMetaEncoding \n-\n-Mon Oct 22 14:20:17 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: fixed a bug in htmlNewDoc()\n-\n-Mon Oct 22 11:32:36 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* test\/threads\/*: added entities testing to the Thread test\n-\t* testThreads.c: make the test reasonable\n-\t* DOCBparser.c: fix the DTD public and system ID\n-\t* xmllint.c: added --sgml for SGML DocBook importing\n-\t* Makefile.am: added Docbtests target\n-\n-Fri Oct 19 11:47:13 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* nanoftp.c: use only \"anonymous@\" string for anonymous passwds\n-\t* testThreads.c: removed bogus include\n-\n-Thu Oct 18 16:56:23 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c valid.c result\/valid\/rss.xml result\/valid\/rss.xml.err:\n-\t  fixed a very serious (looping) validation bug\n-\n-Wed Oct 17 11:56:25 EDT 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/globals.h include\/libxml\/threads.h threads.c\n-\t  testThreads.c: far more testing, cleaning up bugs\n-\t* *.c : make sure globals.h is always included.\n-\n-Wed Oct 17 17:41:41 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c: try to get rid of parser loops for good.\n-\n-Wed Oct 17 13:29:02 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: fixed some bugs in CFLAGS passing.\n-\t* test\/threads Makefile.am testThreads.c: added a specific\n-\t  threaded test case (really nasty, guaranteed).\n-\n-Tue Oct 16 23:01:49 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: serious cleanup on the management of the\n-\t  XML catalog tree, more tests done, especially with\n-\t  the catalog PI.\n-\n-Tue Oct 16 08:43:43 EDT 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: avoid a problem in catalog cleanup on SMP if\n-\t  catalogs were not initialized.\n-\n-Tue Oct 16 14:33:19 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c xpath.c: trying to cleanup the not thread safe\n-\t  parts of the library.\n-\n-Mon Oct 15 14:30:11 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/globals.h configure.in global.data: make\n-\t  the allocation be per-thread a configure option\n-\t* encoding.c include\/libxml\/parser.h: fixed compilation\n-\t  errors\n-\n-Mon Oct 15 12:45:03 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/parser.h: Norm reported that a few lines\n-\t  added were breaking libxslt compile, removed them for now\n-\n-Sun Oct 14 05:55:01 EDT 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c parserInternals.c threads.c: debugged and fixed\n-\t  initialization problems which were giving troubles on SMP\n-\t  boxes.\n-\n-Sat Oct 13 16:17:13 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/Makefile.am: missing globals.h\n-\n-Sat Oct 13 14:15:00 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* globals.c: added a couple of standard includes.\n-\n-Sat Oct 13 11:08:20 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/SAX.h include\/libxml\/globals.h include\/libxml\/parser.h\n-\t  include\/libxml\/parserInternals.h include\/libxml\/tree.h\n-\t  include\/libxml\/xmlerror.h HTMLparser.c SAX.c error.c globals.c\n-\t  nanoftp.c nanohttp.c parser.c parserInternals.c testDocbook.c\n-\t  testHTML.c testSAX.c tree.c uri.c xlink.c xmlmemory.c:\n-\t  Applied the last patches from Gary, cleanup, activated threading\n-\t  all user accessible global variables are now handled in globals.[ch]\n-\t  Still a bit rought but make tests passes with either \n-\t  --with-threads defined at configure time or not.\n-\t* Makefile.am example\/Makefile.am: added globals.[ch] and threads\n-\t  linking options\n-\n-Fri Oct 12 19:25:55 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am include\/libxml\/Makefile.am\n-\t  include\/libxml\/globals.h globals.c  include\/libxml\/threads.h\n-\t  threads.c build_glob.py global.data xmlcatalog.c acconfig.h\n-\t  configure.in: started integrating the core of the thread support\n-\t  not activated yet but half integrated. The code should still\n-\t  compile and work anyway.\n-\n-Fri Oct 12 00:53:03 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLtree.c catalog.c debugXML.c entities.c nanoftp.c\n-\t  parser.c valid.c xmlmemory.c xpath.c xpointer.c: started\n-\t  integrating the non-controversial parts of Gary Pennington\n-\t  multithread patches\n-\t* catalog.c: corrected a small bug introduced\n-\n-Thu Oct 11 20:58:15 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c include\/libxml\/catalog.h: very serious cleanup,\n-\t  isolating unportable code and as much as possible the accesses\n-\t  to the global shared catalog. May need more testing !\n-\n-Thu Oct 11 11:10:31 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/debugXML.h debugXML.c tree.c: integrating\n-\t  Keith Isdale patches for the XSLT debugger interfaces. Some\n-\t  cleanup\n-\n-Thu Oct 11 08:44:01 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/Makefile.mingw: update from Tobias Peters for 2.4.5\n-\t* DOCBparser.c: generate line nubers in elements\n-\n-Wed Oct 10 11:35:45 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: preparing 2.4.6 release\n-\t* doc\/xml.html doc\/html\/*: updated and rebuilt the docs\n-\t* include\/libxml\/*.h *.c: fixed a number of teh\/the widht\/width typos\n-\n-Mon Oct  8 20:38:27 MDT 2001 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmlcatalog_man.xml, xmlcatalog.1, xmlcatalog_man.html\n-\tadding documentation for DV's supercatalog support\n-\n-Mon Oct  8 17:00:16 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/catalog.h catalog.c xmlcatalog.c: adding SGML\n-\t  super catalog support adding one API and one flag --sgml to\n-\t  xmlcatalog\n-\n-Sun Oct  7 16:43:57 MDT 2001 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmlcatalog_man.xml, xmlcatalog.1\n-\tOne more crack at\n-\thttps:\/\/bugzilla.redhat.com\/bugzilla\/show_bug.cgi?id=54392 \n-\n-Sun Oct  7 18:47:02 CEST 2001 Thomas Broyer <tbroyer@ltgt.net>\n-\n-\t* xpath.c: implemented xmlXPathObjectCopy for external objects\n-\t* include\/libxml\/xpathInternals.h: added xmlXPathStackIsExternal\n-\n-Sat Oct  6 16:25:52 MDT 2001 John Fleck <jfleck@inkstain.net>\n-\n-\t*doc\/xmlcatalog_man.xml, xmlcatalog_man.html, xmlcatalog.1\n-\tfinishing up fix to\n-\thttps:\/\/bugzilla.redhat.com\/bugzilla\/show_bug.cgi?id=54392, making\n-\tthe xmlcatalog man page display more elegantly\n-\n-Sat Oct  6 15:27:12 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: closing bug #61832\n-\t* HTMLparser.c: removed a warning\n-\n-Sat Oct  6 15:07:14 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fixing #61673 part I, do not lose doc information\n-\t  when copying result value trees.\n-\n-Sat Oct  6 11:58:58 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: trying to harden the XPath interpreter\n-\n-Fri Oct  5 20:37:51 MDT 2001 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmlcatalog.1 updated using a new stylesheet to address, in\n-\tpart, https:\/\/bugzilla.redhat.com\/bugzilla\/show_bug.cgi?id=54392\n-\n-Fri Oct  5 23:35:00 HKT 2001 William Brack <wbrack@mmm.com.hk>\n-\n-\t* HTMLparser: repaired another loop problem\n-\n-Fri Oct  5 11:16:21 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* uri.c: applied fix from Mathias Hasselmann about a bug in URI\n-\t  parsing.\n-\t* xpath.c: fix bug #61291 the default XML namespace node is\n-\t  missing from the namespace axis.\n-\t* tree.c: refuse to create namespaces nodes with prefix \"xml\"\n-\n-Thu Oct  4 16:47:44 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: ouch a non-defined namespace could lead to a crash,\n-\t  fixed #61215\n-\n-Thu Oct  4 16:24:26 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c: closed bug #61054\n-\n-Wed Oct  3 15:19:04 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/Makefile.am: closing #60708\n-\n-Tue Oct  2 15:52:05 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/dsp\/libxml2.def.src include\/libxml\/parser.h parser.c:\n-\t  adding xmlSAXParseFileWithData following Marco Stipek suggestion\n-\n-Tue Oct  2 11:27:58 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: close bug #61550 when xml: wasn't considered a namespace\n-\n-Tue Oct  2 11:18:32 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/dsp\/libxml2.def.src: Igor Zlatkovic patches\n-\t* DOCBparser.c HTMLparser.c parser.c: fixed typos\n-\n-Mon Oct  1 09:34:51 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: Justin Fletcher provided cleaup code in case\n-\t  HAVE_STAT is not defined\n-\t* include\/win32config.h: Igor Zlatkovic suggested to have\n-\t  HAVE_STAT defined there\n-\n-Sat Sep 29 00:15:00 HKT 2001 William Brack <wbrack@mmm.com.hk>\n-\n-\t* catalog.c - fixed typing error reported by M. Barros\n-\n-Sun Sep 23 21:02:39 MDT 2001 John Fleck <jfleck@inkstain.net>\n-\n-\t* xmllint.c - fixing typo\n-\n-Sat Sep 22 10:00:00 HKT 2001 William Brack <wbrack@mmm.com.hk>\n-\n-\t* HTMLparser.c: small enhancement to prevent loop on\n-\t  unrecognizable data\n-\n-Fri Sep 21 11:45:53 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parserInternals.c: applying patch from bug #60757 this\n-\t  should close it\n-\n-Thu Sep 20 15:54:29 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c xmlcatalog.c: removed a couple of warning\n-\t* xpath.c: try to solve the linking problem on platforms\n-\t  needing trio to compile\n-\n-Wed Sep 19 10:01:37 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am libxml.spec.in: backing up non-documented changes\n-\t  committed without review or approval by Jens Finke <jens@gnome.org>\n-\t* HACKING: made 100% clear that no commit should be done directly\n-\n-Mon Sep 17 18:52:37 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: Joe Orton provided a patch fixing a problem\n-\t  when iconv is specified to be in a non-standard directory\n-\t  but wasn't exported in xml2-config --cflags\n-\n-Fri Sep 14 19:32:43 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: let's ship 2.4.5 before getting too much\n-\t  troubles with 2.4.4 errors.\n-\n-Fri Sep 14 12:26:58 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* encoding.c entities.c: do not output hexadecimal charrefs\n-\t  when serializing HTML since some version of Netscape can't\n-\t  grok it, generate decimal ones.\n-\t* result\/HTML\/doc3.htm: output changed due to previous test\n-\t* parserInternals.c: repair xmlKeepBlanksDefault() broken in 2.4.4\n-\n-Thu Sep 13 13:34:27 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml-2.0.pc.in: dohh generated the wrong include path :-(\n-\t* doc\/Makefile.am libxml.spec.in: re-dohh forgot the new manpage :-(\n-\n-Wed Sep 12 22:14:55 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\tReleased 2.4.4\n-\n-\t* config.h.in configure.in libxml.spec.in include\/libxml\/Makefile.am\n-\t  libxml-2.0.pc.in: moved includes to includedir\/libxml2\/libxml,\n-\t  updated the configuration scripts systems accordingly\n-\n-Wed Sep 12 20:49:32 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* configure.in: preparing for 2.4.4\n-\t* doc\/xml.html doc\/html\/*: updated and rebuilt the docs\n-\n-Wed Sep 12 16:58:16 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/dsp\/libxml2.def.src: tried to incorporate comments\n-\t  from bug #59220\n-\n-Tue Sep 11 11:25:36 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c result\/noent\/wml.xml: fixed bug #59981 related\n-\t  to handling of '&' in attributes when entities are substituted\n-\n-Mon Sep 10 22:14:42 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.h include\/libxml\/xmlversion.h.in\n-\t  include\/libxml\/xmlwin32version.h include\/libxml\/xmlwin32version.h.in:\n-\t  Tried to close bug #60131\n-\n-Mon Sep 10 20:46:03 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: fixed a bug in the HTML parser introduced Sep  9\n-\n-Mon Sep 10 20:13:09 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: fixing bug #59946 on xmlns=\"\"\n-\n-Mon Sep 10 16:39:42 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/xmlerror.h SAX.c: fixing bug 59732, simple\n-\t  but allocates a new error code.\n-\n-Sun Sep  9 10:33:15 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: John Fleck fixed typos in the options output\n-\t* parser.c SAX.c: fix ignorable white space SAX selection\n-\n-Sat Sep  8 11:43:53 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* entities.c: Steve Underwood found the possibility of an\n-\t  ininite loop in case of error.\n-\n-Fri Sep  7 11:35:00 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am: Need $(ICONV_LIBS) in libxml2_la_LIBADD\n-\n-Wed Sep  5 17:47:43 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* parser.c: warn if version is not 1.0 but it's not\n-\t  strictly speaking an error after analyzing the spec\n-\n-Mon Sep  3 10:07:03 MDT 2001 John Fleck <jfleck@inkstain.net>\n-\n-\t*doc\/catalog.html - add link to the html version of the\n-\tman page, other linguistic cleanups\n-\n-Mon Sep  3 09:10:08 MDT 2001 John Fleck <jfleck@inkstain.net>\n-\n-\t* doc\/xmlcatalog_man.xml, xmlcatalog_man.html, xmlcatalog.1\n-\tadding documentation for xmlcatalog. Note: xmlcatalog.1, the man\n-\tfile, has not yet been included in the build.\n-\n-Sat Sep  1 18:17:47 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: removed a duplicate affectation Justin Fletcher\n-\n-Fri Aug 31 22:02:10 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: Armin Sander pointed a possible text coalescing \n-\t  problem, completed his patch.\n-\n-Fri Aug 31 18:30:28 CEST 2001 Bjorn Reese <breese@users.sourceforge.net>\n-\n-\t* trionan.c: Fixed const and volatile re-definition problem\n-\n-Fri Aug 31 16:51:28 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.4 parser.c: doc updates from Heiko Rupp\n-\t* parserInternals.c: 2 sanity checks from Heiko Rupp\n-\n-Tue Aug 28 22:38:45 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* tree.c: applied patch from Armin Sander to make some pointers\n-\t  const in xmlCopyNode()\n-\t* include\/libxml\/tree.h: added fix to the header\n-\n-Mon Aug 27 16:24:47 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: hum, restrict the integer usage gcc bug workaround\n-\t  to only gcc compilers so that other architecture don't get\n-\t  penalized by this limitation.\n-\t* include\/libxml\/xpath.h: small typo fix from Heiko W. Rupp\n-\n-Sun Aug 26 20:45:04 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* valid.c: fixed a Windows compiler warning (Chris Poblete)\n-\t* xpath.c: fix for mod when dividend is 0 (Chris Poblete)\n-\n-Sat Aug 25 15:30:17 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/catalog.h catalog.c xmlcatalog.c: added a \n-\t  --convert option to xmlcatalog to convert SGML ones to\n-\t  the XML syntax.\n-\t* xmllint.c: small cleanup for $SGML_CATALOG_FILES support.\n-\n-\t2.4.3 got released at that point\n-Thu Aug 23 23:16:32 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c xmlIO.c: started some serious testing and fixed\n-\t  a few bug and optimization needs.\n-\n-Thu Aug 23 17:26:58 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am configure.in include\/libxml\/xmlwin32version.h:\n-\t  preparing for a 2.4.3 release even if it may not be ready yet\n-\t* catalog.c parser.c xmlIO.c include\/libxml\/catalog.h: redirected\n-\t  all file parsing lookup to go through the entity resolver, add\n-\t  to add an API to bypass it (needed to load catalogs themselves),\n-\t  some cleanup on the catalog code too.\n-\t* nanoftp.c: small cleanup\n-\t* doc\/catalog.html: small update\n-\n-Thu Aug 23 12:22:26 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: fixed bugi #59406 in SGML catalog parsing reported by\n-\t  Jun Kuriyama\n-\n-Thu Aug 23 02:51:29 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/catalog.html: finished the catalog documentation\n-\n-Thu Aug 23 01:38:42 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* doc\/catalog.html doc\/xml.html: added documentation about\n-\t  Catalog support, misses an API description \n-\t* doc\/html\/*: reextracted the API pages\n-\n-Wed Aug 22 18:27:47 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/catalog.h catalog.c xmlIO.c HTMLparser.c:\n-\t  Added the part about section 7.2 on URI resolution,\n-\t  fixed a side effect in the HTML parser, look complete\n-\t  and ready to rock except the URI\/SystemID part!\n-\n-Wed Aug 22 16:27:03 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/catalog.h include\/libxml\/parser.h\n-\t  include\/libxml\/xmlerror.h catalog.c parser.c parserInternals.c\n-\t  xmlIO.c: added support and APIs needed for the catalog PI\n-\t* include\/libxml\/xmlIO.h: cleanup\n-\n-Wed Aug 22 02:03:31 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c parser.c xmlIO.c xmlcatalog.c xmllint.c \n-\t  include\/libxml\/catalog.h: starts to look okay, really\n-\t  plugged the new framework, cleaned a lot of stuff,\n-\t  added some APIs, except the PI's support missing this\n-\t  should be mostly complete\n-\t* result\/catalogs\/* test\/catalogs\/*: added new test, enriched\n-\t  the existing one with URN ID tests\n-\n-Tue Aug 21 14:56:18 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* catalog.c: fixed nextCatalog\n-\t* result\/catalogs\/docbook test\/catalogs\/*: started adding\n-\t  a small regression test\n-\n-Tue Aug 21 12:52:38 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am catalog.c xmlcatalog.c include\/libxml\/catalog.h:\n-\t  more work on the XML catalog support.\n-\t* parser.c include\/libxml\/parser.h: small cleanup seems using\n-\t  list as a public parameter name can give portability troubles\n-\t* trionan.c trionan.h xpath.c include\/libxml\/trionan.h\n-\t  include\/libxml\/xpath.h include\/libxml\/Makefile.am: removed\n-\t  trionan from the libxml API, added xmlXPathIsInf and xmlXPathIsNaN\n-\t  wrappers\n-\n-Tue Aug 21 11:18:45 CEST 2001 Bjorn Reese <breese@users.sourceforge.net>\n-\n-\t* Makefile.am trio.c triodef.h trionan.c xpath.c\n-\t  include\/libxml\/Makefile.am include\/libxml\/trionan.h:\n-\t  Re-worked Not-A-Number and Infinity support.\n-\t* xmlcatalog.c: added readline include files\n-\n-Mon Aug 20 02:04:13 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* Makefile.am xmlcatalog.c libxml.spec.in: renaming \n-\t  testCatalog as xmlcatalog, making it an installed app\n-\t  adding a shell, and preparing it to be a \/etc\/xml\/catalog\n-\t  management tool, though not ready yet\n-\t* catalog.c include\/libxml\/catalog.h: adding support for\n-\t  XML Catalogs http:\/\/www.oasis-open.org\/committees\/entity\/\n-\t  not finished, there is some interesting tradeoffs and a\n-\t  few open questions left.\n-\n-Sun Aug 19 14:59:56 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: fixed a line formatting problem\n-\n-Fri Aug 17 11:35:31 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: removed a couple of unused variable (Albert Chin)\n-\n-Fri Aug 17 01:25:21 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HTMLparser.c HTMLtree.c include\/libxml\/HTMLparser.h:\n-\t  trying to fix some troubles w.r.t. function returning\n-\t  const xxxPtr.\n-\n-Thu Aug 16 21:33:20 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/dsp\/libxml2.def.src: another set of symbols conditionally\n-\t  defined\n-\n-Thu Aug 16 21:31:14 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpointer.c: removed unused var\n-\n-Thu Aug 16 18:26:40 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* testXPath.c: another small cleanup closing bug #59110\n-\n-Thu Aug 16 17:59:18 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* win32\/dsp\/libxml2.def.src: small cleanup closing bug\n-\t  #59108\n-\n-Wed Aug 15 22:46:01 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* example\/gjobread.c: add xmlCleanupParser() before leaving\n-\n-Wed Aug 15 14:57:08 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* config.h.in configure.in include\/libxml\/xmlwin32version.h:\n-\t  released 2.4.2\n-\n-Wed Aug 15 13:56:22 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* include\/libxml\/valid.h debugXML.c valid.c: deprecate\n-\t  the non-boundchecking Sprintf functions, add Snprintf\n-\t  this should close bug #57984\n-\n-Wed Aug 15 10:46:07 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmlIO.c: xmlOutputBufferCreateFilename() didn't unescaped\n-\t  URIs before doing the lookups (pointed by Mark Vakoc)\n-\n-Tue Aug 14 18:37:23 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: serious changes on Result Value Trees and NodeSets\n-\t  w.r.t. deallocation and collect operations. Probably not\n-\t  100% clean (merge of allocated trees smells like a problem).\n-\t  Seems sufficient to close #58943\n-\n-Tue Aug 14 16:12:00 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xmllint.c: adding a --format option\n-\n-Tue Aug 14 14:16:24 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: count() was broken on Result Value Tree\n-\t* xmlIO.c: fixed file:\/\/\/ accesses on _WIN32\n-\n-Mon Aug 13 13:22:53 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* libxml.m4: s\/LIBXML_VERSION_NUMBER\/LIBXML_VERSION\/ seems the\n-\t  macro was renamed, this should close bug #58683\n-\n-Mon Aug 13 12:33:40 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: small fix fixing bug #58539 reported by coolo, in\n-\t  entity substitution mode text at the end of the entity might\n-\t  be added due to text coalescing.\n-\t* nanoftp.c parser.c: small cleanup\n-\n-Wed Aug  8 22:57:05 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* HACKING: added John Fleck right to commit in the doc subdir\n-\n-Tue Aug  7 03:05:58 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c testXPath.c valid.c xmllint.c include\/libxml\/valid.h:\n-\t  allow to inherit attributes from the DTD directly in the\n-\t  tree, this is needed for XPath and can be a useful feature.\n-\t  Inherited namespaces are always provided at the tree level now\n-\t* test\/defattr* result\/defattr* result\/noent\/defattr*: added a couple\n-\t  of tests for this feature (XSLT being the prime user).\n-\n-Fri Aug  3 14:02:20 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* DOCBparser.c Makefile.am nanohttp.c parser.c testHTML.c\n-\t  testSAX.c xmlIO.c xmllint.c include\/win32config.h\n-\t  include\/libxml\/xmlversion.h.in include\/libxml\/xmlwin32version.h\n-\t  include\/libxml\/xmlwin32version.h.in win32\/README.MSDev\n-\t  win32\/dsp\/*: applied Win32 Facelift No.2 patches from \n-\t  Igor Zlatkovic for Windows\/MSC\n-\n-Wed Aug  1 23:21:06 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* SAX.c: unparsedEntityDecl() the URI computation of the\n-\t  entity wasn't done breaking XSLT unparsed-entity-uri()\n-\n-Wed Aug  1 17:44:57 CEST 2001 Daniel Veillard <daniel@veillard.com>\n-\n-\t* xpath.c: fixed a bug when walking the descendants and\n-\t  the current node has no children\n-\t* debugXML.c: show up when a text node is supposed to not be escaped\n-\n-Wed Aug  1 01:33:35 CEST 2001 Thomas Broyer <tbroyer@ltgt.net>\n-\n-\t* xpath.c: fixed a bug in xmlXPathNodeTrailingSorted (for now it\n-\t  worked like the set:leading() function)\n-\t* include\/libxml\/xpathInternals.h: added xmlXPathNodeSetContains\n-\n-Tue Jul 31 18:24:34 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* nanohttp.c: protected an use of EAGAIN, Brian Stafford\n-\n-Tue Jul 31 17:48:44 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* include\/libxml\/xmlIO.h: apply change to close #58141 \n-\t* win32\/libxml2\/*: update of the MSC projects from Igor  Zlatkovic\n-\n-Tue Jul 31 17:09:31 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: when the internal subset uses a PE, then the\n-\t  included entity can use conditional sections.\n-\n-Mon Jul 30 12:58:39 EDT 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c include\/libxml\/xpath.h: fixed a serious memory problen\n-\t  when walking the namespace axis showing up in\n-\t  libxst\/tests\/general\/bug-12\n-\t* xmlmemory.c: added the possibility to trace a given block\n-\t  defined by its address\n-\n-Sun Jul 29 07:18:53 EDT 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: don't override existing encoding specified before\n-\t  starting xmlParseDocument()\n-\n-Sat Jul 28 13:33:10 EDT 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* include\/libxml\/xmlwin32version.h: reinserted, needed for\n-\t  Windows users of CVS\n-\n-2001-07-27  Darin Adler  <darin@bentspoon.com>\n-\n-\t* encoding.c: (xmlIconvWrapper): Add cast to fix warning.\n-\t* testCatalog.c: Add include of <libxml\/parser.h>.\n-\n-2001-07-27  Darin Adler  <darin@bentspoon.com>\n-\n-\t* include\/libxml\/.cvsignore:\n-\t* include\/libxml\/xmlwin32version.h:\n-\tRemove this file from CVS because it's generated.\n-\n-Fri Jul 27 10:03:56 EDT 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c include\/libxml\/parser.h: applied const patches from\n-\t  Tom Moog #58002\n-\n-Thu Jul 26 18:55:52 CEST 2001 Thomas Broyer <tbroyer@ltgt.net>\n-\n-\t* xpath.c include\/libxml\/xpath{,Internals}.h: added a function\n-\t  lookup framework\n-\n-Fri Jul 27 01:50:20 EDT 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c: fixed xmlCopyNode() for documents\n-\n-Thu Jul 26 12:40:35 EDT 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: fixed bugs #58073 reported by Greg Shtilman\n-\n-Thu Jul 26 11:38:37 EDT 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: fixes bug #57652 reported by Morus Walter\n-\n-Thu Jul 26 10:24:34 EDT 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* nanohttp.c: John Kroll provided a small fix to xmlNanoHTTPSave\n-\n-Thu Jul 26 07:16:04 EDT 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c parserInternals.c: fixed the xmlLineNumbersDefault()\n-\t  errors, lesson don't add new functions at 1am before a release\n-\t* xpath.c: integrated fix from Bjorn to avoid divide by zero\n-\t  from XPath initialization when possible.\n-\n-Tue Jul 24 15:39:11 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* result\/scripts\/base*: removing history\/readline changed\n-\t  this slightly\n-\t* include\/libxml\/parser.h SAX.c parser.c parserInternals.c\n-\t  xmllint.c: make element content line number generation\n-\t  optional to avoid breaking old apps added interface to switch\n-\n-Tue Jul 24 15:06:58 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: get rid of the readline and libhistory\n-\t  dependencies by default, release 2.4.1 with IA64 fix\n-\t* nanohttp.c tree.c xmlIO.c include\/libxml\/nanohttp.h\n-\t  include\/libxml\/tree.h include\/libxml\/xmlIO.h: incorporated\n-\t  John Kroll fixes to allow saving to HTTP via PUT (or\n-\t  POST of needed).\n-\t* doc\/html\/*.html: regenerated the docs\n-\n-Sun Jul 22 05:56:16 CEST 2001 Thomas Broyer <tbroyer@ltgt.net>\n-\n-\t* hash.c include\/libxml\/hash.h: added xmlHashScannerFull,\n-\t  xmlHashScanFull and xmlHashScannFull3 to get passed the\n-\t  three keys as arguments to the callback function\n-\n-Thu Jul 19 15:29:26 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in Makefile.am: removed libxml softlink for good\n-\t* include\/libxml\/*.h *.c doc\/Makefile.am: cleanup to get\n-\t  100% coverage by gtk-doc\n-\n-Tue Jul 17 17:36:46 EDT 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xmlmemory.c include\/libxml\/xmlmemory.h: debugging on IA64,\n-\t  fixed serious troubles due to size_t vs. int mismatch\n-\n-Tue Jul 17 16:04:36 EDT 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* SAX.c xmlIO.c: cleaned up some warning on the Alpha\n-\n-Mon Jul 16 06:32:44 CEST 2001 Thomas Broyer <tbroyer@ltgt.net>\n-\n-\t* include\/libxml\/xpath{,Internals}.h xpath.c: added a more\n-\t  convenient extension API for value and context managing\n-\t  Now handles external objects through xmlXPathPopExternal,\n-\t  xmlXPathWrapExternal and xmlXPathReturnExternal.\n-\t  Added functions for sets operations (intersection, etc.)\n-\n-Mon Jul 16 20:05:27 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* include\/libxml\/parserInternals.h include\/libxml\/HTMLparser.h\n-\t  xmlIO.c tree.c parserInternals.c entities.c encoding.c\n-\t  HTMLparser.c: cleanup of global variables, marking some\n-\t  const or private.\n-\n-Mon Jul 16 00:17:15 CEST 2001 Thomas Broyer <tbroyer@ltgt.net>\n-\n-\t* include\/libxml\/xpath.h: exported xmlXPath{NAN,PINF,NINF}\n-\t  fixed xmlXPathNodeSetItem when passing index=0\n-\n-Sun Jul 15 17:58:44 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* include\/libxml\/xmlwin32version.h.in: added xmlCheckVersion()\n-\n-Sat Jul 14 19:31:21 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xmllint.c: fixed compilation under Cygwin #57503\n-\t* TODO: update\n-\n-2001-07-13  Peter Williams  <peterw@ximian.com>\n-\n-\t* config.h.in: add #undef HAVE_DLFCN_H\n-\n-\t* example\/Makefile.am (INCLUDES): Compile fix when srcdir !=\n-\tbuilddir.\n-\n-Fri Jul 13 11:09:56 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* win32\/libxml2\/libxml2.def.src: added a couple of exported entries\n-\t  raised by #57348 and #57381\n-\n-Thu Jul 12 21:20:17 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* DOCBparser.c HTMLparser.c HTMLtree.c SAX.c debugXML.c parser.c\n-\t  tree.c xpointer.c: store the line numbder in element->content,\n-\t  may break some software, need a configuration mechanism\n-\n-2001-07-10  Darin Adler  <darin@bentspoon.com>\n-\n-\t* .cvsignore:\n-\t* example\/.cvsignore:\n-\t* include\/.cvsignore:\n-\t* include\/libxml\/.cvsignore:\n-\tVarious things that are generated and should be ignored.\n-\n-Tue Jul 10 17:47:09 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in include\/libxml\/xmlwin32version.h: release of 2.4.0\n-\t* doc\/xml.html doc\/html\/*:  updated the docs\n-\n-Mon Jul  9 22:06:53 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* valid.c: fixed \"Internal: MIXED struct bad\" when #CDATA elements\n-\t  validation occurred on content with element child\n-\n-Mon Jul  9 17:59:08 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c: fixed XML Base computation which was broken\n-\t* debugXML.c: added a base function to the shell\n-\t* Makefile.am result\/scripts\/* test\/scripts\/*: added scripts\n-\t  based regression tests, and adding 2 XML Base tests\n-\n-Mon Jul  9 12:31:05 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c: set properties doc and call xmlSetListDoc for properties\n-\t  content when grafting them in a different tree.\n-\t* aclocal.m4: remove from CVS\n-\n-Sun Jul  8 23:09:07 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* win32\/libxml2\/libxml2.def.src: added some missing entry point\n-\t  for XPath (Mark Vakoc)\n-\n-Sun Jul  8 20:34:35 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xmlIO.c: fixed an old bug raised by Bernhard Zwisch, the I\/O\n-\t  layer should URI-Unescape before trying to open resources.\n-\n-Sun Jul  8 16:26:00 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: fix the name() bug for elements in the default \n-\t  namespace reported by Charlie Bozeman\n-\n-Sun Jul  8 15:11:05 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* SAX.c parser.c testXPath.c xpath.c: trying to fix #56948, this\n-\t  led to an XPath fix, improvements of SAX initialization, and\n-\t  an added option --nocdata to testXPath\n-\n-Sat Jul  7 21:09:55 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* doc\/libxml-doc.el: Felix Natter provided anew version working\n-\t  with XEmacs too\n-\n-Sat Jul  7 02:16:00 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* include\/libxml\/xpath.h: small cleanup\n-\t* doc\/xml.html: update\n-\n-Fri Jul  6 01:40:23 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* Makefile.am configure.in include\/libxml\/xmlwin32version.h:\n-\t  released 2.3.14\n-\n-Fri Jul  6 00:47:41 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* doc\/html\/*: rebuilt the docs for the release\n-\t* doc\/xml.html: added 2.3.14 release.\n-\n-Thu Jul  5 22:01:31 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: a bug reported by Stephan Kulow empty nodesets\n-\t  were not equal to empty strings\n-\n-Thu Jul  5 00:52:25 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* SAX.c: fixed a URI-Reference computation problem when validating\n-\t* xmlIO.c: small cleanup\n-\n-Thu Jul  5 00:04:58 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: improved the description of a couple of interfaces\n-\t  upon Larry Stamper suggestion\n-\n-Wed Jul  4 21:42:24 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* SAX.c entities.c parser.c: changed completely the way entities\n-\t  are handled when running the parser in entity substitution mode.\n-\t  This fixes a bug reported by Stephan Kulow and nearly divides\n-\t  by 3 the amount of memory required by libxslt to load and process\n-\t  DocBook TDG.\n-\n-Wed Jul  4 18:02:58 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLparser.c: fixing a too early root closing problem raised\n-\t  byt Prashanth Naidu\n-\n-Wed Jul  4 01:42:01 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: fixed a missing copy in xmlXPathVariableLookupNS() \n-\t  raised by Mark Vakoc.\n-\n-Tue Jul  3 18:35:48 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* example\/Makefile.am: fixed the include path to add srcdir\/include\n-\t* Makefile.am configure.in: fix from Albert Chin for iconv detection\n-\t  and some cleanup\n-\n-Tue Jul  3 10:12:03 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c include\/libxml\/xpath.h include\/libxml\/xpathInternals.h:\n-\t  lot of optimization work, results in significant improvements\n-\t  when handling really complex XPath queries. Add a small optimizer\n-\t  for unions, improve [n] and [last()], avoid some costly ops.\n-\n-Fri Jun 29 23:26:54 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* include\/libxml\/parser.h parser.c: xmlStrstr args are both const\n-\t* xpath.c: small cleanup\n-\t* xmlGetNsList: reformated, fixed problems if used on Entities\n-\n-Thu Jun 28 18:19:44 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* doc\/xml.html: added 1.8.14 and 2.3.13 releases\n-\n-Thu Jun 28 18:16:28 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in include\/libxml\/xmlwin32version.h: released 2.3.13\n-\t* Makefile.am example\/Makefile.am: workaround automake generating\n-\t  erroneous deps\n-\n-Thu Jun 28 15:08:22 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* include\/win32config.h: bug #56801 Yon Derek provided a patch\n-\t  to the windows config file.\n-\n-Thu Jun 28 14:51:44 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpointer.c include\/win32config.h win32\/libxml2\/libxml2.def.src\n-\t  libxml.h : Yon Derek provided a set of changes to compile from\n-\t  CVS on Windows\/MSC\n-\n-Thu Jun 28 14:11:28 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: fixed UTF8 BOM support in push mode\n-\t* test\/utf8bom.xml result\/utf8bom.xml result\/noent\/utf8bom.xml:\n-\t  added a specific testcase\n-\n-Wed Jun 27 18:33:13 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* Makefile.am: added --push regression tests\n-\t* parserInternals.c: the XML parser segfaulted in --push mode\n-\n-Wed Jun 27 13:09:51 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: moved the symlinks detection within a CVS\n-\t  check, this is not portable and will be removed soon.\n-\t* xpath.c: small cleanup\/speedup\n-\n-Tue Jun 26 18:05:26 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in doc\/xml.html include\/libxml\/xmlwin32version.h:\n-\t  release of 2.3.12\n-\t* parser.c: make an error message if unknown entities in all cases\n-\n-Tue Jun 26 09:46:29 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* uri.c: fixed 2 uri normalization bugs on '\/\/' reduction\n-\n-Mon Jun 25 18:06:23 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* include\/libxml\/Makefile.am: Laszlo Peter pointed out that\n-\t  includes were installed in the wrong dir\n-\n-Mon Jun 25 17:07:37 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* doc\/html.xml: warn against sending code to exhibit bugs.\n-\n-Sun Jun 24 23:31:56 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: patch to xmlXPathFormatNumber for the optimizer on\n-\t  Tru64 from Thomas Leitner\n-\n-Sun Jun 24 14:05:54 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* AUTHORS: added William and Bjorn\n-\t* include\/libxml\/*.h *.c README doc\/*.html etc.: changed old email to\n-\t  daniel@veillard.com hopefully I won't have to do this again\n-\t* doc\/Makefile.am doc\/html\/*.html: cleanup makefile, checked that\n-\t  docs can be rebuilt cleanly now\n-\t* include\/libxml\/xml*version.h*: removed include\/libxml\/xmlversion.h\n-\t  from CVs it's generated, added include\/libxml\/xmlwin32version.h\n-\t  also generated but which should change far less frequently.\n-\t* catalog.c nanoftp.c: made sure to include libxml.h not\n-\t  libxml\/xmlversion.h directly\n-\t* include\/libxml\/*.h: include xmlwin32version.h instead of xmlversion.h\n-\t  when compiling on WIN32 and MSC\n-\n-Sat Jun 23 23:54:12 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* include\/Makefile.am include\/libxml\/Makefile.am configure.in:\n-\t  fixed make distcheck and rebuilding the rpms\n-\n-Sat Jun 23 20:50:53 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: should finish the migration of exported includes\n-\t  into a real include\/libxml in CVS, at least for CVS users.\n-\t* removed the exported headers, added in include\/libxml (as well\n-\t  as xmlversion.h.in).\n-\n-Sat Jun 23 20:37:19 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: fixed the way to detect symlink\n-\n-Sat Jun 23 20:30:11 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: updated, include\/libxml is now a real CVS dir\n-\n-Sat Jun 23 19:36:31 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* doc\/libxml-doc.el: a new version of libxml-doc.el. This new\n-\t  version works with both libxml1 and libxml2 (it autodetects\n-\t  the prefix of the html-files) from Felix Natter.\n-\t* doc\/xml.html: updated doc accordingly\n-\n-Sat Jun 23 18:30:28 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: fixed the bug generating a template loop in libxslt\n-\t  when using docbook-xsl-1.4, * should filter out document nodes\n-\t* HACKING: added William\n-\t* TODO: updated\n-\n-Fri Jun 22 18:02:37 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* doc\/FAQ.html: added a warning about gcc-3.0\n-\t* doc\/xml.html: added reference to gdome2 and removed a confusing\n-\t  sentence\n-\n-Fri Jun 22 17:02:16 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xmlversion.h: okay this is a generated file, but Windows\n-\t  users need it and they can't generate it, and I want CVS\n-\t  Windows users ...\n-\t* win32\/libxml2\/libxml2_so.dsp: Windows project file for \n-\t  the shared lib version of libxml2\n-\t* win32\/libxml2\/libxml2.def.src: bug #56527 set of exported\n-\t  resources needed for libxslt\/xsltproc by Yon Derek\n-\n-Fri Jun 22 16:39:36 CEST 2001 Bjorn Reese <breese@users.sourceforge.net>\n-\n-\t* trio.c: MSVC fix (provided by Igor Zlatkovic)\n-\n-Fri Jun 22 12:42:16 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* include\/win32config.h: another small fix for ATTRIBUTE_UNUSED\n-\n-Fri Jun 22 12:42:16 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* include\/win32config.h: Yon Derek provided a first fix\n-\t  to be able to compile libxslt\/xsltproc on Windows\n-\n-Fri Jun 22 00:04:36 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: attempt to work around what seemed a gcc optimizer\n-\t  bug when handling floats on i386 http:\/\/veillard.com\/gcc.bug\n-\t* tree.c entities.c encoding.c: doing some cleanups while\n-\t  chasing it\n-\n-Thu Jun 21 13:13:36 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* Makefile.am: cleanup when --without-debug is specified\n-\t* xinclude.c xpath.c xpathInternals.h xpointer.c: cleanup\n-\t  w.r.t. --without-debug and other include points\n-\t* catalog.h testCatalog.c: a bit of cleanup and prepare for XML\n-\t  Catalogs\n-\t* configure.in entities.h tree.h HTMLparser.c: removed\n-\t  --without-corba, made the _private field mandatory\n-\n-Wed Jun 20 19:37:25 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c parserInternals.c encoding.c: Since Notepad on Win2k\n-\t  outputs a BOM in UTF8, an errata has been issued to avoid the\n-\t  problem, that was the most reasonable solution... Add support\n-\t  for a leading UTF8 BOM in entities.\n-\n-Wed Jun 20 15:38:59 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* valid.c: fixed a bug found when post validating an entity ref\n-\t* xmllint.c: added --loaddtd and sligly changed --postvalid to\n-\t  activate it too\n-\n-Tue Jun 19 20:03:40 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c xinclude.c xpointer.c: bug #56402 exposed a number of\n-\t  weakness in the node copy the XPointer and the XInclude\n-\t  implementations. Serious cleanup.\n-\n-Tue Jun 19 14:50:18 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* Makefile.am: Kjartan Maraas provided a small patch to\n-\t  add xml2-config.in to EXTRA_DIST\n-\n-Tue Jun 19 13:04:10 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* valid.c tree.c parserInternals.c parser.c: Stephan Kulow\n-\t  provided another failing case found in KDE, the way the\n-\t  ctxt->vctxt.nodeTab was allocated and freed changed over\n-\t  time but it wasn't completely cleaned up. This should fix it.\n-\n-Sun Jun 17 19:56:33 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: Stephan Kulow also raised the fact that line number\n-\t  could get miscounted making debug harder, fixed the problem\n-\t  in xmlParseCharData()\n-\n-Sun Jun 17 19:17:26 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* valid.c: Stephan Kulow pointed out a problem when validating\n-\t  and using an empty entity, forgot a 'break' in a case.\n-\n-Sun Jun 17 16:47:40 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c: fixed xmlHasNsProp() accordingly to bug #55683\n-\t* doc\/xml.html: updated with 2.3.11\n-\n-Sun Jun 17 12:24:11 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* TODO: updated adding cleanup of generated doc\n-\t* configure.in: prepared to release 2.3.11\n-\t* xmllint.c: added --version for bug reporting\n-\t* doc\/html\/*.html: rebuilt the doc\n-\n-Sat Jun 16 23:23:33 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: first part of the work on selecting namespace to\n-\t  fix bug #56115 \n-\n-Sat Jun 16 00:20:46 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* Makefile.am example\/Makefile.am: Laszlo PETER provided a fix\n-\t  when using -liconv\n-\t* TODO: updated\n-\n-Fri Jun 15 07:08:57 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLtree.[ch]: more work on the HTML serialization routnes,\n-\t  cleanup, encoding support.\n-\n-Thu Jun 14 10:31:17 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: Thomas Broyer suggested a better patch for the \/ arg\n-\n-Thu Jun 14 01:01:30 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: bug detected by Ankh when \/ is used as a function arg\n-\n-Wed Jun 13 23:08:46 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLparser.[ch] HTMLtree.c: stored the inline\/block property\n-\t  of element and use it to avoid outputting formatting spaces at\n-\t  the wrong place. Implemented the format parameter for HTML save.\n-\t* result\/HTML\/doc2.htm result\/HTML\/doc3.htm result\/HTML\/fp40.htm\n-\t  result\/HTML\/script.html result\/HTML\/test2.html result\/HTML\/test3.html\n-\t  result\/HTML\/wired.html: of course this impact the result of a\n-\t  number of HTML tests\n-\n-Thu Jun 14 09:49:09 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLtree.[ch]: started augmenting the HTML save API with\n-\t  encoding and formatting parameters\n-\n-Wed Jun 13 09:44:15 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLtree.h: cleanup and started evaluating the work needed on\n-\t  revamping the HTML output code\n-\n-Mon Jun 11 19:29:40 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* DOCBparser.c: handling of PIs and <?sgml-declaration in entities.\n-\n-Tue Jun 12 08:46:28 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* valid.c: fixed bug #56049, forgot one check in the\n-\t  validation routine\n-\n-Tue Jun 12 08:09:46 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.[ch]: grrr ... namespace is a C++ reserved keyword\n-\n-Tue Jun 12 06:29:39 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* libxml.h: fixed an error in last commit\n-\t* doc\/FAQ.html: added an entry for compilation from CVS\n-\n-Mon Jun 11 10:07:29 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xmlversion.h.in libxml.h: Cygwin patches\n-\t* tree.c: xmlFreeNodeList patch similar to xmlFreeNode one\n-\t* tree.h: cleanup\n-\n-Sat Jun  9 19:16:00 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c: patched xmlFreeNode() to avoid freeing() a static\n-\t  memory block in a strange case where libxml is linked twice\n-\t  in the binary.\n-\n-Sat Jun  9 18:39:03 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* valid.c: (a? , b? , c? , ... , z?) was storing\/restauring\n-\t  state far too often, simple fix used to avoid it.\n-\n-Sat Jun  9 16:10:36 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xinclude.c: Raphael Hertzog had a trouble with DTD nodes\n-\t  being processed, applied his patch\n-\t* tree.c: fixed a bug raised in xmlStaticCopyNodeList()\n-\n-Sat Jun  9 15:50:11 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* nanoftp.c nanohttp.c uri.c include\/win32config.h: Igor  Zlatkovic\n-\t  provided fixes to compile on MSCC again\n-\t* win32\/libxml2\/libxml2.def.src win32\/libxml2\/libxml2*.dsp: he\n-\t  also provided an update for the project files.\n-\n-Thu Jun  7 21:52:10 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c: applied Steve Tinney patch to xmlNewNsProp to fix\n-\t  bug #55810\n-\n-Thu Jun  7 21:29:39 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c: fixed xmlGetNsProp() to close bug #55683\n-\t  Note this requires libxslt to use it's own function instead.\n-\n-Thu Jun  7 18:06:34 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLtree.c: when in a pre element no formatting space should\n-\t  be added.\n-\t* test\/HTML\/pre.html result\/HTML\/pre.html*: added a regression test\n-\n-Thu Jun  7 17:29:38 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: added tests for signal() and signal.h\n-\n-Fri Jun  8 10:17:15 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: robert pointed out xmlXPathNINF was not initialized\n-\n-Fri Jun  8 10:01:45 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* doc\/libxml-doc.el: Felix Natter provided a new version for\n-\t  libxml2\n-\n-Fri Jun  8 07:20:46 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLtree.c: when in a pre element no formatting space should\n-\t  be added.\n-\n-Wed Jun  6 18:07:36 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: add -mieee to CFLAGS when compiling on Linux\/alpha\n-\n-Thu Jun  7 06:44:01 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* DOCBparser.c: implemented the <?sgml-declaration encoding=\"xxx\"?>\n-\t  hack\n-\t* tree.[ch]: added xmlHasNsProp as suggested in bug report #55653 \n-\t* uri.c: fixed a warning\n-\n-Tue Jun  5 22:54:21 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLtree.c: trying to close bug #55772 escaping in script\n-\t  elements\n-\t* doc\/xml.html: suggest to send mail to the list\n-\n-Tue Jun  5 19:11:02 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* error.c: attempt to fix the xmlGetVarStr breakage once and for\n-\t  good. Use a macro and based on the solution provided in \n-\t  vsnprintf manual page from GNU.\n-\n-Tue Jun  5 14:46:10 CEST 2001 Bjorn Reese <breese@users.sourceforge.net>\n-\n-\t* error.c: Workaround for non-preserving variadic list.\n-\t* trio.c trio.h triop.h strio.c strio.h: Upgraded to trio baseline 1.4\n-\n-Sat Jun  2 06:12:33 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* doc\/xml.html: added 2.3.10 release\n-\n-Fri Jun  1 11:27:11 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: releasing 2.3.10\n-\n-Thu May 31 20:42:39 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xmlIO.c: Gary Pennington spotted a few troubles with file:\/\/\/\n-\n-Thu May 31 20:18:59 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* encoding.c: Robert Collins provided a patch to add the\n-\t  \"US-ASCII\" encoding alias\n-\n-Wed May 30 21:12:45 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c encoding.[ch]: William M. Brack provided a set of UTF8\n-\t  string oriented functions and started cleaning the related areas\n-\t  in xpath.c which needed fixing in this respect\n-\n-Wed May 30 20:30:47 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLtree.c: applied patch from Jaroslaw Kolakowski to close bug\n-\t  #55380\n-\t* tree.c: patch to xmlNodeGetContent() to get CDATA section content\n-\n-Mon May 28 12:56:29 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* TODO: updated\n-\t* nanohttp.[ch] : started adding APIs to get the redirected URL\n-\t  when this occurs (needed for further base computation\n-\t* tree.h: cleanup\n-\t* encoding.c: cleanup\n-\t* SAX.c: minor change around ctxt->loadsubset\n-\n-Fri May 25 09:36:26 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* Makefile.am include\/Makefile.am: small change to have\n-\t  include\/libxml rebuilt if working from CVS.\n-\t* uri.c: applied another patch from Carl Douglas for URI escaping,\n-\t  this should close bug #51876\n-\n-Wed May 23 15:40:27 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xinclude.c: fixed XInclude recursive behaviour bug #54678\n-\t* result\/XInclude\/recursive.xml test\/XInclude\/docs\/recursive.xml\n-\t  test\/XInclude\/ents\/inc.txt test\/XInclude\/ents\/sub-inc.ent:\n-\t  added specific regression test\n-\t* parser.h: preparing for the XSLT mode where DTD inherited\n-\t  attributes are added to the tree.\n-\n-Wed May 23 13:59:19 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xinclude.[ch]: Updated the namespace for the Last Call version\n-\t* result\/XInclude\/include test\/XInclude\/include: updated the\n-\t  testsuite accordingly\n-\n-Wed May 23 12:27:44 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* uri.[ch]: applied a patch from Carl Douglas for URI escaping,\n-\t  related to bug #51876\n-\n-Tue May 22 18:46:56 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c: fixed a gross mistake in base computation, xml:base is\n-\t  not completely correct yet (need cascade).\n-\t* xpath.[ch]: added the few things needed to find a function name\n-\t  and URI from the XPath context when it is called.\n-\n-Tue May 22 17:00:36 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* catalog.[ch]: fixes and add xmlLoadCatalogs()\n-\t* DOCBparser.c: small cleanup\n-\t* xmllint.c: added a --catalogs option to load catalogs from\n-\t  $SGML_CATALOG_FILES\n-\t* tree.c: cleanup\n-\t* configure.in: iconv library fixup, ICONV_LIBS \n-\n-Mon May 21 16:05:22 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* catalog.c: handling of CATALOG entries. detection of recursion,\n-\t  and a few bugfixes\n-\t* xpath.c: fixing bug #54951 QNAME with no prefix should not match\n-\t  against the default namespace\n-\n-Mon May 21 10:14:07 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: Joe Orton reported a bug found with IRIx compiler.\n-\n-Sun May 20 15:15:46 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: fixed propagation context info when parsing an\n-\t  external entity.\n-\t* doc\/html\/*.html: regenerated a couple of docs\n-\n-Sat May 19 17:11:15 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* doc\/xml.html: update with 2.3.9 information\n-\n-Sat May 19 16:50:47 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLtree.h debugXML.h parserInternals.h tree.h valid.c\n-\t  xmlversion.h.in xpathInternals.h xpath.h: some cleanup for gtk-doc\n-\t* doc\/html\/* : rebuilt the docs\n-\t* valid.c: small patch which may improve some case when\n-\t  validating.\n-\n-Sat May 19 15:20:03 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLparser.c: Closed bug #54891\n-\t* result\/HTML\/cf_128.html* test\/HTML\/cf_128.html: added the test\n-\t  to the suite\n-\n-Thu May 17 14:15:07 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* encoding.h hash.c nanoftp.h parser.h tree.h uri.h xlink.h xpointer.c:\n-\t  applied a documentation patch from LotR and filled in a few missing\n-\t  descriptions\n-\n-Wed May 16 23:02:41 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c tree.c parser.c: speed optimizations at the parser level\n-\t  document tree freeing and xpath evaluation\n-\n-Wed May 16 12:55:48 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c parser.h parserInternals.h: fixed a couple of\n-\t  interfaces for handling memory buffer input to const char *\n-\t  upon suggestion of JamesH.\n-\n-Tue May 15 17:22:27 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: LoTR sent a patch fixing the previous commit \n-\n-Tue May 15 14:40:04 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: trying to deal again with the stoopid -R linking\n-\t  flag of Solaris\n-\n-Tue May 15 12:49:50 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.h: two nodeset access macros from Thomas Broyer\n-\n-Tue May 15 11:42:39 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c xpath.h xpathInternals.h: apply an XPath API cleanup\n-\t  patch from Thomas Broyer\n-\n-Tue May 15 10:52:19 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* valid.c test\/VCM\/v2[34].xml: Fixed bug #54631 added specific test\n-\t  case\n-\t* INSTALL: was empty added stuff from the FAQ\n-\n-Fri May 11 19:37:30 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.[ch]: fixing bug #54446, by cleaning some bugs in the\n-\t  attributes handling and #54433 by adding xmlUnsetProp()\n-\t  and xmlUnsetNsProp()\n-\n-Fri May 11 16:07:13 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLparser.c: Patch from Jonas Borgström\n-\t(htmlGetEndPriority): New function, returns \n-\tthe priority of a certain element.\n-\t(htmlAutoCloseOnClose): Only close inline elements if they \n-\tall have lower or equal priority.\n-\t* result\/HTML: this of course changed a number of tests results.\n-\n-Thu May 10 17:30:22 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xmlIO.c catalog.c: plugged in the default catalog resolution\n-\t* doc\/gnome-xml.sgml: linked in the Docbook parser and catalog\n-\t  documentations\n-\t* doc\/html\/libxml-*.html: rebuild added the missing ones to CVS\n-\n-Thu May 10 16:14:36 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* Makefile.am xmlversion.h.in configure.in include\/Makefile.am:\n-\t  integrating catalogs\n-\t* catalog.[ch] testCatalog.c: adding a small catalo API\n-\t  (only SGML catalog support).\n-\t* parser.c: restaured xmlKeepBlanksDefault(0) API\n-\n-Wed May  9 12:50:15 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c: zb@bisp.com reported an error in xmlNodeGetLang()\n-\n-Tue May  8 12:31:40 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: added xmlParseExternalEntityPrivate() to allow\n-\t  propagation of ctxt->_private when parsing external entities\n-\n-Tue May  8 10:26:22 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLtree.c: fixed the bug reported by Bjorn in htmlNodeDump\n-\n-Tue May  8 09:30:12 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: fixed a small portability problem with AM_CONDITIONAL\n-\n-Mon May  7 22:44:45 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* valid.c: warn when indeterminist content model is detected\n-\t* result\/VC\/ElementValid8: this adds a message\n-\t* Makefile.am: add --novalid for VCM tests\n-\t* parserInternals.c: added a call to Init memory \n-\n-Fri May  4 19:51:15 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLparser.c: fixed htmlNewDoc SYSTEM and PUBLIC ID inversion\n-\t  when both parameters are NULL.\n-\n-Fri May  4 17:19:39 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* valid.c: applied small patch from Gary Pennington, reindented\n-\t  some part of the code.\n-\n-Thu May  3 13:10:43 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in doc\/xml.html doc\/html\/*: preparing for 2.3.8\n-\t  release, updated and regenerated the docs\n-\n-Thu May  3 12:47:46 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c result\/XPath\/expr\/floats : clarified and cleanup\n-\t  printing of abnormal floats in tests.\n-\n-Thu May  3 10:25:19 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLparser.c: trying to fix the problem reported by Jonas Borgström\n-\t* results\/HTML\/ : a few changes in the output of the HTML tests as\n-\t  a result.\n-\t* configure.in: tying to fix -liconv where needed\n-\n-Wed May  2 19:10:26 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* Makefile.am: fixed a stupid error\n-\n-Wed May  2 18:39:39 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in Makefile.am: make the inclusion of the trio\n-\t  modules in the library conditional\n-\n-Wed May  2 14:39:57 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* DOCBparser.c: patche from  László Kovács, fixed entities refs\n-\t  in attributes handling\n-\n-Wed May  2 12:56:04 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xmlIO.c: Bjorn Reese provided a fix for a problem on buffer\n-\t flushing\n-\n-Mon Apr 30 22:29:34 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: fix of an XSLT namespace bug reported on the list\n-\t  general\/bug-8-\n-\n-Mon Apr 30 19:42:58 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* strio.h trio.c: Dan McNichol suggested a couple of small\n-\t  fixes for AIX 4.3.3 using Visual Age 5.0.2 compiler\n-\n-Mon Apr 30 13:44:48 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c parser.c encoding.c: spent a bit more time looking\n-\t  at the parsing speed and DOM handling. Added a few more\n-\t  speedups.\n-\n-Sun Apr 29 21:53:47 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: small but effective parsing speed improvement\n-\n-Sun Apr 29 19:02:13 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: default on the DocBook parser inclusion (for Gnome)\n-\t* DOCBparser.h: fixed a header reference\n-\n-Sat Apr 28 19:00:39 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in xpath.c: applied Bjorn patches for FPE on the\n-\t  alpha\n-\n-Sat Apr 28 18:54:28 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.[ch] xmlIO.h: applied patch from Joe McAlerney to add\n-\t  xmlSaveFormatFileTo()\n-\n-Sat Apr 28 16:33:05 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: simple and efficient optimization, XPath functions\n-\t  always bind to the same code, cache this\n-\t* TODO: updated (by saying some is obsolete)\n-\n-Sat Apr 28 14:23:30 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: more cleanup work on XPath name parsing routines\n-\n-Fri Apr 27 19:06:13 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parserInternals.c xpath.[ch]: some UTF8 cleanup on\n-\t  xmlXPathParseName\n-\t* xpath.c: Igor Zlatkovic suggested a change for NAN and MSC\n-\t* debugXML.c: avoid compilation problems if compiling without\n-\t  HTML support, Igor Zlatkovic\n-\t* win32\/libxml2\/libxml2.def.src: being able to compile without\n-\t  XPath on Windows\n-\n-Thu Apr 26 22:53:03 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* libxml.m4: yet another patch from Toshio Kuratomi\n-\n-Thu Apr 26 21:27:43 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* libxml.m4 libxml2-spec.in: new patches from Toshio Kuratomi\n-\n-Thu Apr 26 20:53:48 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.[ch]: added xmlSaveFormatFile interface for saving\n-\t  and indenting a file.\n-\n-Thu Apr 26 16:35:53 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: fixed bug #53689 related to processing-instruction()\n-\n-Thu Apr 26 12:57:58 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* DOCBparser.c: patche from  László Kovács\n-\n-Thu Apr 26 11:31:54 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: applied fixes from Christian Glahn bug report #53391\n-\n-Thu Apr 26 11:14:56 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* error.c: Jean François Lecomte provided a complete description\n-\t  and a fix to bug #53537\n-\n-Thu Apr 26 09:42:58 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* libxml.m4: added AM_PATH_XML2 provided by Toshio Kuratomi\n-\n-Wed Apr 25 21:05:31 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* DOCBparser.c SAX.c: a bit more work on entities processing.\n-\t  Still Need to cleanup XML output and references in attributes\n-\n-Wed Apr 25 17:52:27 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* DOCBparser.c include\/Makefile.am: two patches from László Kovács\n-\n-Wed Apr 25 14:56:26 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c: trying to fix #53574, not completely complete,\n-\t  I would like xmllint --copy --debug test\/ent1 and\n-\t  xmllint --debug test\/ent1 to show the same result.\n-\t* xpath.c: fix a bug when trying to sort namespace nodes\n-\n-Wed Apr 25 12:28:57 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLtree.c: real fix for  #53402\n-\n-Tue Apr 24 17:36:35 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLtree.c HTMLtree.h : closing #53402 i.e. output of\n-\t  PIs when using xsl:output\n-\t* valid.c: closing #53537 some case generate segfaults if there\n-\t  is validity errors\n-\n-Tue Apr 24 15:19:53 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* SAX.c testDocbook.c DOCBparser.c: more work on the support\n-\t  of external parsed entities, added --noent to testDocbook\n-\t* valid.c: Garry Pennington found an uninitialized variable\n-\t  access in xmlValidateElementContent()\n-\n-Tue Apr 24 14:41:25 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLparser.c : HTML parsing still sucks ... trying to deal\n-\t  with madness\n-\t* result\/HTML\/ : this modified the result of the regression tests\n-\t  a lot.\n-\n-Tue Apr 24 14:10:38 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* entities.c: xmlEncodeEntitiesReentrant fixed a few accesses\n-\t  to doc where it wasn't checked against NULL reported by\n-\t  Jens Laas\n-\n-Tue Apr 24 13:21:36 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLparser.c: Jonas Borgström patch, the <td>, and <th> elements\n-\t  now means the end of any open <span>,<font>,<a>,<b>,<i>,<u>.\n-\n-Mon Apr 23 15:40:04 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* DOCBparser.c DOCBparser.h testDocbook.c configure.in Makefile.am\n-\t  xmlversion.h.in: started (re)integrating the DocBook SGML parser.\n-\t* SAX.[ch]: cleanup and updates for DocBook\n-\t* debugXML.c parser.h tree.[ch] valid.c xpath.c: small macro or\n-\t  ex SGML identifier changes\n-\t* valid.c: removed a static unused function.\n-\n-Mon Apr 23 11:05:56 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLtree.c: applied change for Paul Sponagl on script saving\n-\t* Makefile.am: the warning about entity title.xml are normal.\n-\n-Sun Apr 22 22:09:35 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: release of 2.3.7\n-\t* Makefile.am: fixing make distcheck\n-\n-Sun Apr 22 21:29:52 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* doc\/html\/* doc\/xml.html: updated and regenerated the docs\n-\n-Sun Apr 22 21:11:45 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: fixed the XPointer problem introduced in 2.3.6\n-\n-Sun Apr 22 14:11:58 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c: fixed #53388 with the provided patch\n-\n-Sun Apr 22 12:34:41 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* valid.c: Bjorn detected an invalid memory access. Fixed\n-\t  vstateVPush()\n-\n-Sun Apr 22 10:49:23 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: fixed xmlXPathCompile to detected unproperly ended expr\n-\n-Sat Apr 21 18:27:51 CEST 2001 Bjorn Reese <breese@users.sourceforge.net>\n-\n-\t* libxml.h: new header used only for the compilation of libxml\n-\t* HTMLparser.c HTMLtree.c SAX.c debugXML.c encoding.c entities.c\n-\t  error.c hash.c list.c nanoftp.c nanohttp.c parser.c\n-\t  parserInternals.c testHTML.c testSAX.c testURI.c testXPath.c\n-\t  tree.c uri.c valid.c xinclude.c xlink.c xmlIO.c xmllint.c\n-\t  xmlmemory.c xpath.c xpointer.c: libxml.h integration\n-\t* trio.[ch] triop.h strio.[ch]: upgraded to the latest trio\n-\t  baseline (version 1.2 plus a single patch).\n-\t* xpath.c result\/XPath\/expr\/floats test\/XPath\/expr\/floats: parses\n-\t  scientific notation for numbers. Tests added.\n-\t* xpath.c: formatting of numbers changed to use sprintf\n-\t  (contribution from William Brack)\n-\n-Sat Apr 21 16:12:59 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* valid.c: cleanup, more useful debugging\n-\t* parserInternals.c: cleanup vctxt.nodeTab (de)allocation\n-\t* xmlIO.c: entity loading is printed as an error when validating\n-\n-Sat Apr 21 12:25:49 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* valid.c: fixed to validate within entities\n-\t* test\/VCM\/v22.xml: added a specific testcase\n-\n-Fri Apr 20 17:45:47 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* valid.c: forgot an epsilon transition in for ()+\n-\t* test\/VCM\/v21.xml : added a specific test case\n-\n-Fri Apr 20 15:46:04 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* valid.c: removed a state explosion exhibited by RSS\n-\t* test\/valid\/rss.xml result\/valid\/rss.xml*: added the testcase\n-\t  from bug #51872\n-\n-Fri Apr 20 14:52:44 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* valid.[ch] tree.h: worked *hard* to get non-determinist content\n-\t  validation without using an ugly NFA -> DFA algo in the source.\n-\t  Made a specific algorithm easier to maintain, using a single\n-\t  stack and without recursion.\n-\t* Makefile.am test\/VCM\/*.xml: added more tests to \"make Validtests\"\n-\t* hash.c: made the growing routine static\n-\t* tree.h parser.c: added the parent information to an\n-\t  xmlElementContent node.\n-\n-Wed Apr 18 23:33:11 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* SAX.c parser.c xpath.c: generating IDs when not validating\n-\t  from an external parsed entity was poisoning the ID has table\n-\t  with removed values. This was killing XSLT on the KDE help\n-\t  browser.\n-\n-Wed Apr 18 17:09:15 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* entities.h: andrew@ugh.net.au detected a double declaration\n-\n-Wed Apr 18 15:06:30 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* debugXML.c hash.c tree.h valid.c : some changes related to\n-\t  the validation support to improve speed with DocBook\n-\t* result\/VC\/OneID2 result\/VC\/OneID3 : this slightly changes\n-\t  the way validation errors get reported\n-\n-Wed Apr 18 11:42:47 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLparser.c HTMLtree.c: applied part of the patches provided\n-\t  by P C Chow and William M. Brack for XSLT HTML output\n-\n-Mon Apr 16 19:44:36 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xmlversion.h.in win32config.h win32\/libxml2\/*: applied \n-\t  Igor Zlatkovic patches for MSC compilation and added his\n-\t  updates\n-\n-Tue Apr 17 10:08:19 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: fixed xmlXPathNodeCollectAndTest() to do proper\n-\t  prefix lookup.\n-\t* parserInternals.c: fixed the bug reported by Morus Walter\n-\t  due to an off by one typo in xmlStringCurrentChar()\n-\n-Thu Apr 12 17:41:09 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLparser.c result\/HTML\/*: revamped the way the HTML\n-\t  parser handles end of tags or end of input\n-\n-Thu Apr 12 10:50:34 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.[ch] : added xmlDocCopyNode for gdome2 support\n-\n-Wed Apr 11 16:37:50 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.h: include xmlmemory.h this seems to havoid a nasty glibc\n-\t  bug where the linktime versions of free() won't work ...\n-\n-Wed Apr 11 14:21:31 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* config.h.in configure.in xmlversion.h.in: added ansidecl.h test\n-\n-Wed Apr 11 13:50:42 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* doc\/xml.html: added 2.3.6 release\n-\n-Wed Apr 11 13:26:34 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c: fixed xmlStringGetNodeList() to handle charrefs\n-\t* result\/wml.xml: resulted in a small output change\n-\n-Wed Apr 11 09:47:55 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c: xmlNewDoc was missing the charset initialization\n-\t* xmllint.c: added --auto to autogenerate a doc, allow to\n-\t  reproduce the problem fixed on xmlNewDoc\n-\n-Tue Apr 10 18:13:10 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: trying to get 52979 solved\n-\t* tree.c result\/ result\/noent\/: trying to get 52712 solved, this\n-\t  also made me clean up the fact that XML output in general should\n-\t  not add formatting blanks by default, this changed the output of\n-\t  a few tests\n-\n-Tue Apr 10 16:30:20 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: Bill Brack pointer an error in detecting a null nodeset\n-\n-Sun Apr  8 15:07:16 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: finally released 2.3.6\n-\n-Sun Apr  8 11:39:21 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: checking for null pointer generated by new code\n-\n-Fri Apr  6 12:53:05 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: fixed a [] evaluation problem reported\n-\t* test\/XPath\/tests\/simpleaddr: extended test\n-\t* result\/XPath\/simpleaddr: updated result\n-\n-Wed Apr  4 02:07:53 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xmllint.c: Dan Timis reported a portability problem\n-\t  on Macs without mmap, fixed it.\n-\n-Tue Apr  3 20:20:51 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* testXPath.c : added a --tree option allowing to display the\n-\t  tree dump of the XPath expression\n-\n-Mon Apr  2 17:13:51 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: fixed a memleak when comparing nodesets\n-\t* HTMLtree.c: don't invent the HTML doctype if not available (XSLT)\n-\t* tree.c: added a TODO\n-\n-Tue Mar 27 14:32:06 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in Makefile.am config.h.in xmlversion.h.in: detect if\n-\t  we need string functions\n-\t* trio.[ch] strio.[ch]: embedded the Trio-0.23 string functions\n-\t  to be able to use them where needed. Applied some changes\n-\t  to reduce name linking pollution and compile in only what's\n-\t  needed.\n-\t* HTMLtree.c debugXML.c entities.c error.c nanoftp.c valid.c\n-\t  xlink.c xmlversion.h.in xpath.c: got rid of the #ifdef \n-\t  for the string manipulation functions\n-\t* xmlmemory.[ch]: removed DEBUG_MEMORY_FREED and added it automatically\n-\t  to the free() function of xmlmemory.c\n-\t* entities.c HTMLtree.c parserInternals.c tree.c uri.c valid.c\n-\t  xinclude.c xmlIO.c xpath.c xpointer.c: removed the MEM_CLEANUP\n-\t  usage.\n-\n-Tue Mar 27 02:30:23 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* error.c: applied the context output patch of the error\n-\t  handling submitted by Chuck Griffith\n-\t* error\/VC\/*: this slightly change some error logs\n-\n-Tue Mar 27 00:51:27 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: fixed line number reporting on error\n-\n-Mon Mar 26 23:21:41 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: Sullivan and Darin found a parser bug,\n-\t  applied the patch.\n-\n-Mon Mar 26 18:24:52 CEST 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLparser.c HTMLtree.c SAX.c debugXML.c error.c parserInternals.c\n-\t  testHTML.c testSAX.c tree.c valid.c xmlIO.c xmlmemory.c\n-\t  xmlversion.h.in xpointer.c: of course the way I defined\n-\t  UNUSED breaks on old gcc version. Try to be smart and\n-\t  also define it directly in xmlversion.h\n-\t* configure.in: removed -ansi flag from the pedantic set\n-\n-Sat Mar 24 17:45:36 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\tHuge cleanup, I switched to compile with\n-\t-Wall -g -O -ansi -pedantic -W -Wunused -Wimplicit\n-\t-Wreturn-type -Wswitch -Wcomment -Wtrigraphs -Wformat\n-\t-Wchar-subscripts -Wuninitialized -Wparentheses -Wshadow\n-\t-Wpointer-arith -Wcast-align -Wwrite-strings -Waggregate-return\n-\t-Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -Winline\n-\t* HTMLparser.[ch] HTMLtree.c SAX.c debugXML.c encoding.[ch]\n-\t  encoding.h entities.c error.c list.[ch] nanoftp.c\n-\t  nanohttp.c parser.[ch] parserInternals.[ch] testHTML.c\n-\t  testSAX.c testURI.c testXPath.c tree.[ch] uri.c\n-\t  valid.[ch] xinclude.c xmlIO.[ch] xmllint.c xmlmemory.c\n-\t  xpath.c xpathInternals.h xpointer.[ch] example\/gjobread.c:\n-\t  Cleanup, staticfied a number of non-exported functions,\n-\t  detected and cleaned up a dozen of problem found this way,\n-\t  avoided a lot of public function name\/typedef\/system names clashes\n-\t* doc\/xml.html: updated\n-\t* configure.in: switched private flags to the really pedantic ones.\n-\n-Thu Mar 22 22:44:15 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: 2.3.5\n-\t* doc\/html\/*: rebuilt the docs\n-\n-Thu Mar 22 15:36:45 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: fixed a reported bug in NOTATION parsing\n-\t* uri.c: accepted but not fixed bug 51876, added TODO \n-\t* Makefile.am: fixed bug 51876\n-\n-Thu Mar 22 13:41:22 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* config.h.in configure.in error.c: fix a compilation problem\n-\t  on platforms without vsnprintf (xml@thewrittenword.com)\n-\n-Wed Mar 21 19:04:34 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: fixed a function name header typo\n-\t* SAX.c: notations can also occur in external subset.\n-\n-Tue Mar 20 14:21:28 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* error.c: removed a C++ like comment\n-\n-Tue Mar 20 12:22:36 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: fixing bug 52299 strange condition leading\n-\t  to a parser crash due to a buffer overflow\n-\t* result\/noent\/attrib.xml result\/attrib.xml test\/attrib.xml:\n-\t  added the specific test case\n-\n-Mon Mar 19 16:50:52 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.[ch]: still a lot of cleanup based on XSLT, added\n-\t  xmlXPathConvert{String,Number,Boolean} to be able to make\n-\t  type casts without a context stack, fixed some implementation\n-\t  problems related to the absence of context at parse-time,\n-\t  added xmlXPathEvalPredicate() and xmlXPathFreeCompExpr()\n-\t  in the public API too\n-\t* xpointer.c xpathInternals.h: we need to know at parse time\n-\t  whether we are compiling an XPointer\n-\n-Mon Mar 19 11:54:31 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.[ch] xpointer.c: restaured the Binary and API compatibility\n-\t  cleaned up the parser internals, refactored XPath code, added\n-\t  new compilation based APIs and cleanly separated public and\n-\t  private APIs.\n-\n-Mon Mar 19 00:59:25 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.h: the comp field must be added at the end to avoid\n-\t  killing binary compat.\n-\n-Mon Mar 19 00:11:18 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* Makefile.am: detect XPath memleaks in regreson tests\n-\t* error.c: fixed and error w.r.t. error reporting still using\n-\t  stderr\n-\t* hash.c: added new line at end of file\n-\t* tree.h: minor cleanup\n-\t* xpath.[ch] xpointer.[ch]: Major changes ! Separated XPath\n-\t  expression parsing from evaluation, resulted in a number of\n-\t  changes internally, and in XPointer. Likely to break stuff\n-\t  using xpathInternals.h but should remain binary compatible,\n-\t  new interfaces will be added.\n-\n-Wed Mar 14 20:34:02 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: fixed a couple of problems reported by \n-\t  okiddle@yahoo.co.uk and allanc@chickenandporn.com when compiling\n-\t  without gcc on non linux platforms.\n-\n-Wed Mar 14 20:13:54 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* doc\/Makefile.am configure.in: yearke@eng.buffalo.edu suggested\n-\t  a fix for --with-html-dir= configure support. I hope it won't\n-\t  break rpm generation\n-\n-Wed Mar 14 17:28:49 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xmlIO.c: one function comment cleanup.\n-\n-Wed Mar 14 14:55:46 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* SAX.c: external subset notations were improperly registered\n-\t  in the internal subset.\n-\n-Tue Mar 13 10:28:49 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* README.cvs-commits: added, pointing to HACKING\n-\t* HACKING: updated\n-\n-Mon Mar 12 22:09:40 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: and Matt Sergeant found one in the XML push\n-\t  parser (erroneous check I forgot to remove when I fixed the\n-\t  main parser).\n-\n-Mon Mar 12 19:19:04 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: ptittom found a small bug in UnaryExpr\n-\n-Sat Mar 10 13:09:53 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: bumped to 2.3.4\n-\t* error.c: fixed bug #51860\n-\t* tree.c: fixed bug #51861\n-\t* valid.c: cleanup, more debug, failed to fix one bug crap ...\n-\t* tree.[ch] : added xmlDefaultBufferSize\n-\t* nanoftp.c: typo in function name header block\n-\t* doc\/xml.html : updated, added link to XML::LibXSLT\n-\t* doc\/html\/* : rebuilt the docs\n-\n-Wed Mar  7 20:43:47 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c SAX.c: the new content parsing code raised an\n-\t  ugly bug in the characters() SAX callback. Found it\n-\t  just because of strangeness in XSLT XML Rec output :-(\n-\n-Wed Mar  7 16:50:22 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* Makefile.am: Martin Baulig suggested to add -lm\n-\t* tree.c: found another bug in xmlNodeGetContent()\n-\n-Tue Mar  6 09:21:30 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: Bjorn found the error related to strictness of comparison.\n-\n-Mon Mar  5 21:47:31 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: trying to fix the Dtd parsing problem reported\n-\t  by Gary, side effect of last week speed optimizations.\n-\n-Sat Mar  3 19:45:59 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xml2Conf.sh.in: fixes pointed out by Fredrik Hallenberg\n-\t* parserInternals.c: removed unneeded test raised by Stric\n-\n-Sat Mar  3 13:04:37 CET 2001 Bjorn Reese <breese@users.sourceforge.net>\n-\n-\t* xpath.c: Fixed xmlXPathNodeCollectAndTest (problem reported\n-\t  and fixed by William Brack). Added xmlXPathFormatNumber.\n-\t  Changed the sorting slightly.\n-\t* configure.in Makefile.am example\/Makefile.am: Added -lm.\n-\t  Please note that applications linking with libxml2, must\n-\t  also like with the math library from now on.\n-\n-Sat Mar  3 07:38:58 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLparser.c: fixed loop reported by Marc Sanfacon\n-\n-Sat Mar  3 02:10:24 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: one must report spaces even if the Dtd element\n-\t  content proves that this is not part of the element content.\n-\t* result\/valid\/*.xml: this changed the ouptu slightly\n-\n-Thu Mar  1 17:53:39 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: bumped to 2.3.3\n-\t* doc\/xml.html: updated\n-\n-Wed Feb 28 00:43:58 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c: minor doc fix\n-\t* xpath.c: deallocation issues when a result tree has been\n-\t  converted to a node-set\n-\n-Mon Feb 26 22:09:45 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* doc\/xml.html: oops corrected dates s\/2000\/2001\n-\n-Mon Feb 26 12:48:35 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* valid.c: new patch from Gary Pennington\n-\n-Mon Feb 26 09:30:23 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* doc\/xml.html: applied patch from Ankh\n-\n-Mon Feb 26 03:34:43 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xinclude.c: fixed a problem building on Mac\n-\n-Sun Feb 25 21:52:30 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: more work on increasing parsing ferformances\n-\n-Sun Feb 25 18:03:42 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xmlmemory.h HTMLparser.c HTMLtree.c entities.c parser.c\n-\t  xpath.c xpointer.c tree.c uri.c valid.c xinclude.c xmlIO.c:\n-\t  avoiding memcpy in production builds MEM_CLEANUP macro use\n-\t* parser.[ch] parserInternals.c: optimizations of the tightest\n-\t  internal loops inside the parser. Better checking of I\/O\n-\t  flushing\/loading conditions\n-\t* xmllint.c : added --timing\n-\n-Sun Feb 25 05:48:51 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: bumped to 2.3.2\n-\t* doc\/xml.html: updated for release\n-\n-Sat Feb 24 14:07:52 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: found a memleak and fixed a nasty bug\n-\n-Sat Feb 24 03:35:48 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xmllint.[c1] : added return code errors for xmllint\n-\t* xpath.c: specific debug dump function for result value trees\n-\n-Thu Feb 22 07:52:27 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: finally implemented xmlXPathCompareNodeSets\n-\t* test\/XPath\/expr\/floats results\/XPath\/expr\/floats: added \n-\t  a test for float expressions\n-\n-Tue Feb 20 18:57:54 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c: fixed xmlNodeGetContent, it was not recursing on child\n-\t* parserInternals.[ch]: trying to speed up parsing\n-\t* xpath.c : speeded up node set equality op\n-\n-Mon Feb 19 19:01:57 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* Makefile.am valid.c list.[ch]: Gary Pennington provided a\n-\t  better handling of ID\/IDREF and the list modules associated\n-\t* configure.in: small CFLAGS cleanup\n-\n-Mon Feb 19 16:13:22 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: fixed iconv detection on AIX (stric)\n-\n-Mon Feb 19 10:59:41 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: fixed \"*\" (unbelievable !) and a couple of warnings\n-\n-Sun Feb 18 17:52:37 MET 2001 Bjorn Reese <breese@users.sourceforge.net>\n-\n-\t* xpath.c: fixed whitespace handling in xmlXPathStringEvalNumber,\n-\t  and optimized xmlXPathNodeSetSort\n-\n-Sat Feb 17 14:18:42 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: bug fix when context size is 0\n-\t* parser.c: I like Norm's Dtd because they still manage to break\n-\t  the parser occasionally\n-\n-Fri Feb 16 14:20:35 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: xmlXPathEqualNodeSetFloat the arg is really a double now\n-\n-Fri Feb 16 01:10:06 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.[ch] parser.c xpath.c: fixed the problem of addressing\n-\t  attributes within the XML-1.0 namespace\n-\n-Thu Feb 15 16:53:20 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpathInternals.h: exported a few axis functions\n-\t* doc\/xml.html: updated the doc\n-\n-Thu Feb 15 15:57:14 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: applied patch from Daniel van Balen for OpenBSD\n-\t  and bumped version to 2.3.1\n-\t* HTMLtree.c result\/HTML\/doc3.htm result\/HTML\/wired.html: the\n-\t  attempt to find autoclosing was simply broken, removed it,\n-\t  updated the examples, this is better\n-\n-Wed Feb 14 11:35:39 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* hash.[ch]: added Paolo Casarini patch to provide Delete from\n-\t  hash functionalities.\n-\t* doc\/html\/* : rebuild the doc\n-\n-Tue Feb 13 18:01:48 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c result\/XPath\/tests\/chaptersprefol: bugfixes on order and\n-\t  on predicate\n-\t* HTMLparser.[ch] HTMLtree.c result\/HTML\/doc3.htm.err\n-\t  result\/HTML\/doc3.htm.sax result\/HTML\/wired.html: sometimes one\n-\t  really want to have tags closed on output even if we accept\n-\t  unclosed ones on input\n-\n-Mon Feb 12 18:33:20 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: ouch don't free NULL, rare case fixed\n-\t* tree.c: don't coalesce text nodes if they don't have the\n-\t  same behaviour wrt escaping on output\n-\n-Sun Feb 11 21:15:41 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: small fixup\n-\t* SAX.c: don't warn on empty namespaces.\n-\n-Thu Feb  8 11:28:58 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* README: a bit of cleanup\n-\t* configure.in: preparing for 2.3.0 release\n-\n-Thu Feb  8 10:37:00 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* hash.[ch]: added a first version of xmlHashSize()\n-\t* valid.c: another bug fix from Gary Pennington\n-\n-Wed Feb  7 19:22:37 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* valid.c: couple of bug fixes pointed by Gary Pennington\n-\t* HTMLtree.c: #if 0 cleanup\n-\n-Tue Feb  6 14:02:56 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: started profiling XSLT, added xmlXPathNodeSetAddUnique()\n-\t  which removes a time consuming check of xmlXPathNodeSetAdd()\n-\t  and use it in places where we are sure to not break unicity\n-\n-Mon Feb  5 18:51:36 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: bug fixes found from XSLT\n-\t* tree.c: preserve node->name special values when copying nodes.\n-\t* parserInternals.[ch] parser.[ch] SAX.c : added a mode where\n-\t  external subset are fetched when available but without full\n-\t  validation. Added xmlLoadExtDtdDefaultValue, need a function.\n-\t* HTMLtree.c: add support for xmlStringTextNoenc for XSLt HTML\n-\t  output with encoding disabled.\n-\n-Sat Feb  3 09:50:29 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xmliO.c: Harry Blundell pointed out that xmlCheckFilename\n-\t  xmlCheckFilename should not be called from xmlFileOpenW\n-\t  and xmlGzfileOpenW\n-\n-Fri Feb  2 18:04:35 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* uri.c: rewrite of xmlNormalizeURIPath from Paul D. Smith\n-\t* test\/URI\/smith.uri result\/URI\/smith.uri Makefile.am:\n-\t  added the new tests for URI normalization\n-\t* testURI.c: fixed stoopid bugs\n-\t* result\/VC\/OneID3 result\/VC\/UniqueElementTypeDeclaration:\n-\t  the URI in the error messages are now properly normalized\n-\n-Fri Feb  2 09:18:53 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* uri.c: applied Marc Sanfacon's patch for xmlNormalizeURIPath\n-\n-Thu Feb  1 05:28:55 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: fixed a number of problems in XPATH_XSLT_TREE processing\n-\n-Wed Jan 31 21:45:37 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: fixed mod operator\n-\n-Wed Jan 31 16:50:42 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c: fixed xmlStrcat doc\n-\t* tree.c: 2 fixes form Anders Carlson for copying nodes and\n-\t  trees.\n-\n-Wed Jan 31 14:19:16 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c result\/XPath\/tests\/chaptersbase\n-\t  result\/XPath\/tests\/simplebase: fixed XPath node() \n-\t* tree.c: small fix in xmlNewNs()\n-\t* Makefile.am: removed extraneous xml2Conf.sh rule\n-\n-Sun Jan 28 08:37:03 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* Makefile.am configure.in libxml.spec.in example\/Makefile.am:\n-\t  Changed the library name, in order to get libxml-devel and\n-\t  libxml2-devel to coexist on a single system\n-\t* xml-config.1 xml-config.in xmlConf.sh.in: renamed\n-\t* xml2-config.1 xml2-config.in xml2Conf.sh.in: new files\n-\n-Sat Jan 27 19:58:22 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* Makefile.am configure.in libxml-2.0.pc.in: started working on getting\n-\t  libxml2-devel installable in \/\/ as libxml-devel.\n-\n-Sat Jan 27 18:49:02 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* doc\/Makefile.am: fixed make rebuild in doc\n-\t* doc\/html\/*.html: rebuilt the docs\n-\n-Fri Jan 26 10:30:58 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c: patch from Bjorn Reese on xmlBufferCCat\n-\n-Thu Jan 25 19:22:25 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* Makefile.am doc\/Makefile.am libxml.spec.in: painful work to get\n-\t  the HTML doc to go into the -devel RPM ...\n-\t* aclocal.m4 config.h.in: some updates due to auto* magic\n-\n-Thu Jan 25 19:11:49 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.h: added a hook in the context structure allowing to\n-\t  link to extra support, needed for XSLT\n-\n-Thu Jan 25 13:34:11 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.[ch] xpointer.c: added xmlXPathCmpNodes, changed\n-\t  xmlXPtrCmpPoints to use it.\n-\t* propagated the following patch from Alejandro Forero\n-\t* include\/win32config.h xmlIO.c: applied further suggestions\n-\t  from Igor Zlatkovic <igorz@dialup.nacamar.de> and cleanup\n-\t* example\/gjobread.c: fixed warnings, now that it builds\n-\n-Wed Jan 24 20:27:28 COT 2001 Alejandro Forero <bachue@bachue.com>\n-\n-\t* xmlIO.c (xmlFileOpen, xmlFileOpenW): Removed unnecessary checks.\n-\n-\t* xmlIO.c (xmlCheckFilename): Function added to know whether a given\n-\t  filename points to a valid file (not a directory).\n-\t* xmlIO.c (xmlFileOpen, xmlFileOpenW, xmlGzfileOpen, xmlGzfileOpenW):\n-\t  Added calls to xmlCheckFilenameDir.\n-\n-\t* xmlIO.c (xmlGzfileOpen, xmlGzfileOpenW, xmlFdOpen, xmlFdOpenW): Pass\n-\t  `path' (rather than `filename') as the parameter to gzopen and open.\n-\n-Tue Jan 23 16:26:30 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* Makefile.am: fixed a problem with EXTRA_DIST\n-\n-Mon Jan 22 23:42:17 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* Makefile.am example\/Makefile.am: finally found the trick\n-\t  to build the example, i.e. add \".\" in SUBDIRS before example\n-\t  in the list <grin\/>\n-\n-Mon Jan 22 16:30:37 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* doc\/xml.html: updated with an XSLT section, removed pointer to\n-\t  W3C CVS base.\n-\n-Mon Jan 22 11:43:21 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: when copying a XSLT tree object the tree need to be copied\n-\t  too, and deallocation need to occur the same way.\n-\n-Mon Jan 22 10:35:40 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpathInternals.h xpath.[ch] debugXML.c: added the XPATH_XSLT_TREE\n-\t  type corresponding to an XSLT result tree fragment. Share most\n-\t  of the data format with node set, as well as operators.\n-\t* HTMLtree.c: added a newline at the end of the doctype output\n-\t  whe this one is not present initially.\n-\t* tree.c: make sure that the parent and doc pointers are properly\n-\t  set when copying attributes (lists).\n-\n-Sun Jan 21 10:47:38 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* htmlTree.[ch] xmlIO.h: exported htmlDocContentDumpOutput\n-\n-Fri Jan 19 18:15:50 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: seems I finally killed that ugly path evaluation\n-\t  context bug (tagged 9999 in case is is wrong)\n-\n-Fri Jan 19 06:30:38 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.[ch] xpathInternals.h: added xmlXPathRegisterVariableLookup()\n-\t  for XSLT\n-\n-Thu Jan 18 16:19:47 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xmlIO.c: Gary Pennington <Gary.Pennington@uk.sun.com> fix\n-\t  for xmlGzfileOpen() bug\n-\n-Thu Jan 18 13:11:50 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: removed an error found by XSLT usage\n-\t* tree.c parserInternals.h: use a predefined static string\n-\t  for text and comment nodes, avoid freeing them in xmlFreeNode,\n-\t  exported the string name in parserInternals.h and added\n-\t  another value to disable encoding at output (for XSLT),\n-\t  gain memory, time.\n-\n-Wed Jan 17 09:15:16 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* win32\/README.MSDev win32\/libxml2\/libxml2_a.dsp\n-\t  win32\/libxml2\/libxml2_so.dsp: new makefiles and update\n-\t  provided by Igor Zlatkovic <igor@stud.fh-frankfurt.de>\n-\n-Tue Jan 16 18:24:46 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c : xmlSaveFile, xmlSaveFileEnc, applied patch from \n-\t  Gary Pennington\n-\n-Mon Jan 15 20:24:18 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xpath.c: fixed the comaprision of values and nodelists,\n-\t  need to compare nodelist still ...\n-\t* debugXML.c: avoided a possible core dump\n-\t* HTMLparser.c: cleanup\n-\t* nanohttp.c: contributed fix.\n-\t* tree.c: fixes in properties handling added xmlSetNsProp\n-\t  needed by libxslt\n-\t* xpathInternals.h: exported xmlXPathBooleanFunction, added a \n-\t  comment\n-\t* TODO: updated\n-\n-Sat Jan  6 22:05:09 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* parser.c parserInternals.c: applied Bjorn Reese optimization\n-\t  patch\n-\n-Sat Jan  6 19:13:27 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* Makefile.am: applied patch for make check from Martin Vidner\n-\n-Thu Jan  4 19:07:49 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* configure.in: preparing 2.2.11\n-\t* doc\/html\/*: rebuild the HTML files\n-\t* doc\/xml.html : updated\n-\n-Thu Jan  4 14:09:58 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* tree.c: fixed a stupid bug\n-\t* valid.c: applied \"Paul D. Smith\" <pausmith@nortelnetworks.com>\n-\t  patches related to validation of an XInclude processing result\n-\t* TODO: updated\n-\n-Thu Jan  4 11:46:40 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* encoding.c xmlIO.c: Fixing the problem reported by Marc Sanfacon\n-\t  on large files\n-\n-Wed Jan  3 21:51:13 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xmlIO.c: fixed xmlParserInputBufferCreateMem doc\n-\n-Wed Jan  3 18:56:00 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* HTMLparser.c: htmlCheckParagraph to check htmlOmittedDefaultValue,\n-\t  reported by Jonas Borgström\n-\t* nanohttp.c: Applied Bjorn Reese' IPV6 first patch\n-\n-Wed Jan  3 16:19:39 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* testXPath.c xpath.c: fixing the XPath union expressions problem\n-\t  reported by  Martin Vidner <martin@artax.karlin.mff.cuni.cz>\n-\n-Wed Jan  3 14:22:33 CET 2001 Daniel Veillard <Daniel.Veillard@imag.fr>\n-\n-\t* xmllint.c: Made is so if the file name is \"-\" is will read form\n-\t  standard input. Sven Heinicke  <sven@zen.org>\n-\t* tree.c: fixed a problem when growing buffer\n-\t* tree.h: fixed the comment of the node types following andersca\n-\t  comment\n-\t* TODO: updated\n-\n-Wed Dec 27 12:35:49 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.[ch]: added a way to avoid adding automatically\n-\t  omitted tags. htmlHandleOmittedElem() allows to change the\n-\t  default handling.\n-\t* tree.[ch] xmllint.c: added xmlDocDumpFormatMemory() and \n-\t  xmlDocDumpFormatMemoryEnc(), uses memory functions for output\n-\t  of xmllint too when using --memory flag, added a memory test\n-\t  suite at the Makefile level.\n-\t* xpathInternals.h xpath.[ch] xpointer.c: fixed problems\n-\t  with namespace use when encountering QNames in XPath evaluation,\n-\t  added xmlns() scheme in XPointer.\n-\t* nanoftp.c : incorporated a fix\n-\t* parser.c xmlIO.c: fixed problems raised with encoding when using\n-\t  the memory I\/O\n-\t* parserInternals.c: closed bug 25934 reported by \n-\t  torsten.landschoff@innominate.de\n-\t* TODO: updated\n-\n-Sat Nov 25 11:46:27 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in doc\/html\/* doc\/xml.html: made a 2.2.9 release\n-\t  on a non-updated tree :-(, made a 2.2.10 release to correct the\n-\t  situation\n-\n-Sat Nov 25 10:41:37 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanohttp.c parser.[ch] tree.[ch] xmlIO.[ch] xmllint.c xpath.c\n-\t  parserInternals.h vms\/build_libxml.com vms\/config.vms Makefile.am:\n-\t  integrated a set of OpenVMS changes from Howard Taylor\n-\t  <Howard.Taylor@pacoast.com>\n-\n-Sat Nov 25 01:21:01 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.[ch] xmlIO.c: added xmlDocDumpMemoryEnc() from John Kroll\n-\t* error.c: applied fix suggested by \"Leo Davidson\" <leo@ox.compsoc.net>\n-\n-Sat Nov 25 00:24:49 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c: some fixes on auto-open of html\/head\/body\n-\t* encoding.c: fixed a compilation error on some gcc env\n-\t* xpath.c xpointer.[ch] xpathInternals.h: improved the\n-\t  XPointer implementation\n-\t* test\/XPath\/xptr\/strpoint test\/XPath\/xptr\/strrange3: added\n-\t  related XPointer tests and associated results\n-\n-Fri Nov 24 14:01:44 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/xmldtd.html doc\/xml.html: following a short step by step\n-\t  guidance on IRC to help maciej with DTDs I started a small\n-\t  page on the subject.\n-\n-Fri Nov 17 17:28:06 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c: fixed handling of broken charrefs\n-\t* xmlmemory.h libxml2.dsp include\/win32config.h: reporting Windows\n-\t  patches\n-\n-Mon Nov 13 19:17:20 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/xml.html doc\/html\/* : rebuilt the docs after adding\n-\t  xinclude and updated page for 2.2.7 and 2.2.8\n-\t* configure.in: releasing 2.2.8\n-\n-Mon Nov 13 12:39:38 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.[ch] parserInternals.c: applied the conditional\n-\t  section processing fix from Jonathan P Springer\n-\t  <jonathan.springer2@gte.net>\n-\t* xmlversion.h.in win32\/libxml2\/libxml2.dsp : Updated MS\n-\t  project file, fixed iconv default non support\n-\t* xpath.c: fixed the problem of evaluating relative expressions\n-\t  when a node context is provided.\n-\n-Sun Nov 12 16:31:19 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanoftp.c: fixed gcc 2.95 new warnings\n-\t* SAX.c: fixed a stupid bug\n-\t* tree.c: fixed a formatting problem when round-tripping\n-\t  from\/to memory\n-\t* xinclude.c: chased memleak, fixed a base problem\n-\t* xpointer.c: added xmlXPtrBuildRangeNodeList(), finished ? \n-\t  xmlXPtrBuildNodeList()\n-\t* TODO: updated\n-\t* Makefile.am test\/XInclude\/docs test\/XInclude\/ents result\/XInclude:\n-\t  adding a first small set of regression tests for XInclude\n-\n-Tue Nov  7 15:11:34 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanohttp.[ch]: applied Wayne Davison patches to access\n-\t  the WWW-Authorization header.\n-\t* parser.c: Closed Bug#30847: Problems when switching encoding\n-\t  in short files by applying Simon Berg's patch.\n-\t* valid.c: fixed a validation problem\n-\t* hash.c parser.h parserInternals.h testHTML.c testSAX.c tree.h\n-\t  xmlerror.h xmlmemory.h xmlversion.h.in: applied a DLL patch from\n-\t  Wayne Davison\n-\t* xpointer.[ch]: added first version of xmlXPtrBuildNodeList()\n-\t  need to be extended to non full nodes selections.\n-\t* xinclude.c: starts to work decently\n-\n-Mon Nov  6 17:22:46 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.[ch] xinclude.[ch] xmllint.c configure.in valid.c\n-\t  debugXML.c xmlversion.h.in: Started adding XInclude support,\n-\t  this is a new xmllint option\n-\t* tree.c xpath.c: applied TOM patches for XPath\n-\t* xpointer.c: fixed a couple of errors.\n-\t* uri.c: added an escaping function needed for xinclude\n-\t* testXPath.c hash.c HTMLtree.c: minor cleanups raised by\n-\t  new warning from RH70 gcc's version\n-\n-Tue Oct 31 14:14:13 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c: fixed loop on invalid char in scripts\n-\t* parser.c: update to description of xmlIOParseDTD()\n-\t* libxml.m4 xmlversion.h.in: changes contributed by\n-\t  Michael Schmeing <m.schmeing@internet-factory.de>\n-\t* configure.in: preparing for 2.2.7\n-\t* Makefile.am: trying to avoid  config.h and acconfig.h\n-\t  being included in the distrib\n-\t* configure.in: released 2.2.7\n-\n-Mon Oct 30 17:08:10 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.[ch] debugXML.c parserInternals.c xpath.c: Deprecated Pi's\n-\t  like namespaces for good. Unified xmlNs and xmlNode somewhat.\n-\n-Mon Oct 30 16:26:49 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.[ch]: added xmlIOParseDTD()\n-\t* xpointer.c: added support for the 2 extra parameters of\n-\t  string-range, fixed a stoopid error when '0' was present\n-\t  in XPointer expressions\n-\t* test\/XPath\/xptr\/strrange2 result\/XPath\/xptr\/strrange2: added\n-\t  testsuite for the above\n-\n-Mon Oct 30 10:26:43 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* libxml.spec.in: improved package descriptions\n-\n-Sun Oct 29 19:03:11 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xpath.c xpathInternals.h: applied a large cleaning patch\n-\t  from TOM <ptittom@free.fr>, it also add namespace support\n-\t  for function and variables registration.\n-\n-Sun Oct 29 18:51:46 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* uri.c: Wayne Davison's patch fixing xmlBuildURI()\n-\t* Makefile.mingw: Wayne Davison's update adding hash.c\n-\n-Sun Oct 29 18:38:12 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xpath.c: fixed the root evaluation problems\n-\t* HTMLparser.c result\/HTML\/doc3.htm: fixed the problem of non\n-\t  ignorable spaces with <b> <bold> <em>\n-\t* tree.c: fixed a loop in xmlSearchNsByHref()\n-\n-Fri Oct 27 18:57:32 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xpath.c: applied another XPath patch from TOM \n-\t* xpath.c include\/makefile.am: applied another patch from \n-\t  china@thewrittenword.com (cleanup on IRIX).\n-\n-Fri Oct 27 13:45:28 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xml-config.1: received a fixed version from Fredrik Hallenberg\n-\t  <hallon@lysator.liu.se>\n-\n-Thu Oct 26 16:05:25 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xpath.c textXPath.c xpathInternals.h: applied TOM <ptittom@free.fr>\n-\t  cleanup patch for XPath\n-\n-Wed Oct 25 21:31:10 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* patched to redirrect all \"out of context\" error messages to\n-\t  a reconfigurable routine. The changes are:\n-\t* xmlerror.h : added the export of an error context type (void *)\n-\t  an error handler type xmlGenericErrorFunc there is an interface\n-\t  xmlSetGenericErrorFunc(void *ctx, xmlGenericErrorFunc handler);\n-\t  to reset the error handling routine and its argument\n-\t  (by default it's equivalent to respectively fprintf and stderr.\n-\t* all the c files: all wild accesses to stderr or stdout within\n-\t  the library have been replaced to calls to the handler.\n-\n-Wed Oct 25 15:27:19 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in: release 2.2.6\n-\t* xpath.[ch] xpointer.c xpathInternals.h: added xpathInternals.h\n-\t  exporting the inner functions of xpath for extension modules\n-\t* doc\/*: updated and rebuilt the doc\n-\n-Wed Oct 25 12:48:55 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanohttp.c : applied Wayne HTTP cleanup patch\n-\t* tree.[ch]: applied TOM <ptittom@free.fr> for xmlNodeSetBase()\n-\t  and xmlNodeSetSpacePreserve()\n-\n-Wed Oct 25 12:11:03 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xpath.c: closing bug #29260\n-\n-Tue Oct 24 18:49:34 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* hash.[ch] debugXML.c: expanded\/enhanced the API, added\n-\t  multikey tuples, made hash structure opaque\n-\t* valid.[ch]: moved elements, attributes, notations decalarations\n-\t  as well as ID and refs to hash tables.\n-\t* entities.c: hash cleanup\n-\t* xmlmemory.c: fixed a dump problem in debug mode\n-\t* include\/Makefile.am: problem passing in DESTDIR= values patch\n-\t  from Marc Christensen <marc@calderasystems.com>\n-\t* nanohttp.c: removed debugging remains\n-\t* HTMLparser.c: the bogus tag should be ignored (Wayne)\n-\t* HTMLparser.c parser.c: fixing a number of problems with the\n-\t  macros in the *parser.c files (Wayne).\n-\t* HTMLparser.c: close the previous option when opening a new one\n-\t  (Marc Sanfacon).\n-\t* result\/HTML\/*: updated the HTML results accordingly\n-\n-Sun Oct 22 18:39:19 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* entities.[ch] xpath.[ch] hash.[ch] debugXML.c tree.h: added\/hacked\n-\t  hash tables from Bjorn Reese <breese@mail1.stofanet.dk>. Switched\n-\t  XPath functions and XML entities table to them. More to come...\n-\t* xmlIO.c: fixed libxml closing FILEs it didn't open.\n-\n-Sun Oct 22 13:59:50 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.c: coalesce adjacent text nodes\n-\t* valid.c: handling of blank nodes in DTd validation (raised\n-\t  by problems with a posteriori validation).\n-\t* nanohttp.c: changing behaviour on HTTP write stuff.\n-\t* HTMLtree.c: forced body and html to be explicitly closed.\n-\t* xpath.h: exported more XPath functions.\n-\n-Sun Oct 15 22:28:32 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* Release of 2.2.5\n-\t* xpointer.c: range() range-inside and other helper functions\n-\t* parserInternals.c: fixed perf problem raised by rolf@pointsman.de\n-\n-Sun Oct 15 16:21:27 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* SAX.c: HTML attributes need normalization too (Bjorn Reese)\n-\t* HTMLparser.[ch]: added htmlIsScriptAttribute()\n-\n-Sun Oct 15 13:18:36 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/*: rebuilt docs preparing for 2.2.5 release, added URI\n-\t  and XPointer modules\n-\n-Sun Oct 15 12:13:30 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* SAX.h: closed #25107\n-\n-Sun Oct 15 12:06:16 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* testSAX.c: fixed problem with cdata reporting\n-\t* SAXresult\/* : updated\n-\n-Sun Oct 15 12:00:24 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c test\/wap.xml result\/noent\/wap.xml result\/wap.xml:\n-\t  Closed bug #27499, added to regression tests\n-\t* TODO: updated\n-\n-Sun Oct 15 01:34:37 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c HTMLtree.[ch] SAX.c testHTML.c tree.c: fixed HTML\n-\t  support for SCRIPT and STYLE with help from Bjorn Reese\n-\t* test\/HTML\/* result\/HTML\/*: added simple testcase and updated\n-\t  the existing ones.\n-\n-Fri Oct 13 18:24:31 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xpath.c xpointer.c: XPointer reorder of ranges start\/end and\n-\t  string-range for empty strings\n-\t* test\/XPath\/docs\/str test\/XPath\/xptr\/chaptersrange\n-\t  test\/XPath\/xptr\/strrange: augmented the XPointer testsuite\n-\n-Fri Oct 13 12:21:48 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/xml.html doc\/xmlmem.html: added a module describing memory\n-\t  interfaces and use, updated the main page.\n-\n-Fri Oct 13 01:23:48 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanoftp.c nanohttp.c xmlIO.c: Wayne Davison Win32 patch\n-\t  nanoftp code work on Windows too now\n-\n-Fri Oct 13 00:54:37 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* testXPath.c xpath.[ch]: moved some debug functions to xpath core\n-\t* xpointer.c: implemented string-range() at least a good first version\n-\t* test\/XPath\/docs\/str test\/XPath\/xptr\/strrange\n-\t  result\/XPath\/xptr\/strrange: the string-range() tests\n-\n-Thu Oct 12 10:02:59 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* Makefile.am include\/Makefile.am include\/win32config.h\n-\t  win32\/Makefile.mingw: fixed problems reported by Wayne Davison\n-\t  and make distcheck\n-\n-Thu Oct 12 01:44:08 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanohttp.c: added xmlNanoHTTPTimeout(int delay), removed a bug\n-\t  xmlNanoHTTPMethod on input MimeType Tony Lam <Tony.Lam@eng.sun.com>\n-\t* xpointer.c: slight extension of xmlXPtrLocationSetMerge\n-\n-Thu Oct 12 01:37:53 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* config.h.in configure.in nanoftp.c nanohttp.c xmlversion.h.in :\n-\t  patch for socklen_t detection by\n-\t  Albert Chin-A-Young <china@thewrittenword.com>\n-\n-Wed Oct 11 17:53:57 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.c valid.c xmllint.c: Fixed a few postvalidation bugs\n-\t  and added a --dtdvalid option to xmllint used to test it\n-\n-Wed Oct 11 15:01:29 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xml-config.1 Makefile.am libxml.spec.in: adding a man page for\n-\t  xml-config by Fredrik Hallenberg <hallon@lysator.liu.se>\n-\n-Wed Oct 11 12:41:30 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xpath.[ch] xpointer.[ch]: worked on XPath functions and variable\n-\t  handlings (registration, lookup, cleanup)\n-\n-Wed Oct 11 01:46:44 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in Makefile.am include\/makefile.am: adding XPointer\n-\t  and XPtrtests target\n-\t* xpointer.[ch] : new files for XPointer support\n-\t* test\/XPath\/xptr result\/XPath\/xptr: added XPointer testsuite and\n-\t  more XPath tests\n-\n-Wed Oct 11 01:23:25 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in: fixed, very broken, make distcheck works again\n-\n-Wed Oct 11 02:53:10 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* More work toward 2.2.5, integrated a number of patches\n-\t* configure.in Makefile.am win32config.h.in: trying to cleanup\n-\t  make distcheck .... huh ...\n-\t* include\/Makefile.am include\/win32config.h: new directory\n-\t  for includes\n-\t* win32\/Makefile.mingw win32\/README.MSDev win32\/libxml2\/libxml2.dsp\n-\t  updated the makefiles and instructions for WIN32\n-\t* xpath.c: small fixes\n-\t* test\/XPath\/ results\/XPath: updated the testcases and results\n-\t* HTMLparser.c nanohttp.c testXPath.c: incorporated provided or\n-\t  suggested patches\n-\t* valid.c: fixed an ID bug\n-\n-Mon Oct  9 14:28:56 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* moved xml-error.h to xmlerror.h: seems this allowed to bypass\n-\t  the automake bug where wrong dependencies were generated.\n-\t* xpath.[ch]: worked on XPointer\n-\n-Fri Oct  6 12:58:04 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in Makefile.am: 2.2.5, ship the include in an\n-\t  include\/libxml subdirectory, use symlinks when using CVS\n-\t* testSAX.c: fixed small bug\n-\t* testXPath.c: changed the way testfiles are parsed\n-\t* debugXML.c: same kind of cleanup when parsing an argument expression\n-\t  XPath\/XPointers can have blanks embedded\n-\t* xpath.[ch]: more cleanup, reorgs for XPointer work\n-\t* parserInternals.c parser.c HTMLparser.c: fixed wrong include\n-\t* win32\/README.MSDev win32\/libxml2\/libxml2.dsp: Windows stuff\n-\n-Thu Oct  5 18:13:15 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* debugXML.c testXPath.c xpath.[ch]: got pissed by some nastiness\n-\t  in the XPath engine, rewrote large parts of it, now it's far\n-\t  cleaner and in sync with the REC not an old WD. Fixed a parsing\n-\t  problem in the interactive XML shell found when testing XPath.\n-\n-Wed Oct  4 15:25:53 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* debugXML.c testXPath.c xpath.[ch]: More work on XPath\/Xpointer,\n-\t  incorporated \"(TOM)\" <ptittom@free.fr> patches rebuilt the XPath\n-\t  examples with the extra test\n-\n-Wed Oct  4 14:39:01 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c xmlIO.c xmlIO.h: fixed bug 26650, and improved\n-\t  the global init function.\n-\n-Tue Oct  3 11:28:52 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c: Doohhh, attribute name parsing was still case\n-\t  sensitive ! Fixed this ...\n-\t* result\/HTML\/* : updated the tests results accordingly\n-\n-Mon Oct  2 23:47:32 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xpath.[ch] debugXML.c testXPath.c: fixed the XPath evaluation\n-\t  engine, should be far more stable, incorporated a new version of\n-\t  preceding\/following axis, need testing\n-\t* uri.c: fixed file:\/\/\/c:\/a\/b\/c problem\n-\t* test\/XPath\/tests\/idsimple: augmented the XPath tests\n-\n-Sun Oct  1 22:33:00 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/* rebuilding docs for 2.2.4 release\n-\n-Sun Oct  1 22:16:33 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in: releasing 2.2.4\n-\t* parser.[ch]: added xmlStrEqual()\n-\t* HTMLparser.c HTMLtree.c SAX.c debugXML.c entities.c parser.c\n-\t  tree.c valid.c xlink.c xpath.c: converted all !xmlStrcmp to\n-\t  use xmlStrEqual instead\n-\t* TODO: updated\n-\t* added an XPath test\n-\n-Sun Oct  1 20:19:39 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c: fixed htmlStartCloseIndexinitialized init\n-\t* entities.h: exported xmlInitializePredefinedEntities\n-\t* parser.[ch] : added xmlInitParser()\n-\t* parserInternals.h : had to export htmlInitAutoClose()\n-\n-Sun Oct  1 16:28:22 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xpath.[ch] : fixed some serious XPath Predicate evaluation\n-\t  problems\n-\t* Makefile.am : added XPath regression tests to normal tests\n-\t* uri.c: fixed a problem with local paths, cleanup\n-\t* parser.c: fixed a problem with large CData sections\n-\n-Sat Sep 30 16:35:54 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in xml-config.in: patch from \"Ben Taylor\"\n-\t  <sol7x86@hotmail.com> for solaris shared libs lookup\n-\n-2000-09-30  Martin Baulig  <baulig@suse.de>\n-\n-\t* libxml-2.0.pc.in: Provide pkg-config script.\n-\n-\t* configure.in: Create the libxml-2.0.pc script from the\n-\tlibxml-2.0.pc.in templates.\n-\t* Makefile.am (pkgconfig_DATA): Install the libxml-2.0.pc\n-\tscript in `$(libdir)\/pkgconfig'.\n-\n-Mon Sep 25 16:23:41 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c parser.c tree.c tree.h: Avoiding a few warning\n-\t  when compiling with MSC\n-\n-Sun Sep 24 20:32:52 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xpath.c: patch for normalize-string() substring-before(),\n-\t  substring-after() and translate() functions from Bjorn Reese\n-\t  <breese@mail1.stofanet.dk>\n-\t* libxml.m4 Makefile.am: added libxml.m4 from Debian ?\n-\t  Fredrik Hallenberg <hallon@lysator.liu.se>\n-\t* TODO: updated\n-\n-Sun Sep 24 10:00:49 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xmlversion.h.in nanoftp.c nanohttp.c: traying to work out the\n-\t  problem of socklen_t being undefined on a number of platforms\n-\t* debugXML.c: fixed a compilation problem when without snprintf\n-\n-Sat Sep 23 12:19:45 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c uri.c: Another patch from Wayne Davison, correcting\n-\t  an URI bug and a fix for the control-character-induced infinite loop\n-\t* nanohttp.c: preventive fix for compiling on WIN32\n-\n-Fri Sep 22 18:06:08 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xmlint.c: closing bug #25000\n-\n-Fri Sep 22 14:17:53 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xmlIO.h tree.h: made xmlNodeDump() and xmlNodeDumpOutput() public\n-\t* parser.[ch] nanohttp.c HTMLtree.c HTMLparser.c tree.c: applied and\n-\t  modified slightly Wayne Davison patch adding xmlStrcasecmp and\n-\t  related function, fixing xmlStrncmp(), and associated cleanup\n-\t* result\/HTML\/entities.html.sax: updating result\n-\n-Tue Sep 19 14:20:10 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* uri.c: applied patch for URI escaping from Wayne Davison\n-\t  <wayned@blorf.net>\n-\t* tree.c parserInternals.c HTMLparser.c: memset checks patches\n-\t  from Denis Barbier <barbier@imacs.polytechnique.fr>\n-\t* HTMLparser.c: UTF8 characters in HTML tag-attribute values\n-\t  patch from Wayne Davison\n-\n-Sun Sep 17 18:37:03 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/xml.html : updated with new releases, adding \"how to help\"\n-\n-Sun Sep 17 17:58:37 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* SAX.c debugXML.c parser.c parserInternals.c tree.c valid.c xpath.c:\n-\t  removed a few warnings in pedantic mode ...\n-\t* parserInternals.c parser.c: moved encoding switching function\n-\t  to parserInternals.c\n-\t* configure.in, doc\/Makefile.am libxml.spec.in: released 2.2.3\n-\n-Sat Sep 16 20:12:41 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c parser.c: set ctxt->errNo before calling the\n-\t  error or warning handlers\n-\n-Wed Sep 13 22:03:18 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parserInternals.c parserInternals.h parser.c Makefile.am:\n-\t  created a new module parserInternals.c, moved most of the\n-\t  code shared by the various parsers there, as well as\n-\t  deprecated  code from parser.c. More cleanup of parser.c\n-\t* uri.c: fixed a problem when URI is NULL\n-\t* valid.c: speedup when looking for an attribute declaration\n-\n-Sun Sep 10 17:53:48 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* uri.c tree.c SAX.c parser.c entities.c debugXML.c: finished\n-\t  the cleanup of the computation of URI references when seeking\n-\t  external entities. The URI reference string and the resulting\n-\t  URI are both stored now.\n-\t* parser.c HTMLparser.c valid.c nanoftp.c nanohttp.c xpath.c:\n-\t  large s(n)printf checks and cleanup from Denis Barbier\n-\t  <barbier@imacs.polytechnique.fr>\n-\t* xmlversion.h.in tree.h: couple of SGML declarations for a\n-\t  possible docbook module.\n-\t* result\/VC\/ : a couple of test output changed due to the change\n-\t  of the entities URI\n-\n-Sun Sep 10 15:59:58 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.h: added a _private field for linking user's data\n-\n-Sun Sep 10 15:14:43 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c parserInternals.h: demacroified most of the IS_XXX\n-\t  the gain in size is significant so ...\n-\n-Fri Sep  8 20:48:29 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* entities.c: cases where looking up entities with doc==NULL\n-\t  covered\n-\n-Tue Sep  5 12:41:15 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* uri.c: applied Wayne Davison patch\n-\t* Makefile.in test\/URI\/uri.data result\/URI\/uri.data: updated URI tests\n-\n-Mon Sep  4 13:01:45 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* uri.c testUri.c: applied Wayne Davison patches\n-\t* test\/URI\/uri.data result\/URI\/uri.data: first set of tests\/results\n-\t* Makefile.in: added URItest and included thenin \"make tests\"\n-\n-Sun Sep  3 19:19:29 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xmlversion.h.in: closed bug 22941\n-\n-Thu Aug 31 16:55:55 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/xmlio.html: added doc and example for entity loader\n-\t  redefinition.\n-\n-Thu Aug 31 14:59:28 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/xmlio.html doc\/xml.html: added a doc on the I\/O mechanism\n-\t  used by libxml\n-\n-Tue Aug 29 20:22:53 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c: Fixed bug on invalid ontent characters and when using\n-\t  push.\n-\t* xmllint.c: fixed xmllint endling of errors in push mode\n-\n-Tue Aug 29 11:24:48 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c testHTML.c: applied two new patches from\n-\t  Wayne Davison <wayned@users.sourceforge.net>\n-\t* result\/HTML\/*.sax: regenerated HTML SAX output\n-\t* parser.c: more cleanup.\n-\n-Mon Aug 28 11:58:12 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.[ch] testHTML.c: applied the second set of\n-\t  patches from Wayne Davison <wayned@users.sourceforge.net>,\n-\t  adding htmlEncodeEntities()\n-\t* HTMLparser.c: fixed an ignorable white space detection bug\n-\t  occurring when parsing with SAX only\n-\t* result\/HTML\/*.sax: updated since the output is now HTML\n-\t  encoded...\n-\n-Mon Aug 28 00:38:31 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.[ch]: applied some of Wayne Davison\n-\t  <wayned@users.sourceforge.net> patches\n-\n-Sun Aug 27 22:14:01 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* SAX.c tree.c debugXML.c: fixed bogus behaviour when an\n-\t  undeclared namespace prefix was used, added a warning.\n-\t  Cleaned up support w.r.t. entities, spilling out a warning\n-\t  and being pedantic on lookups.\n-\t* test\/warning\/ent9 : added testcase for previous example.\n-\t* TODO: updated\n-\t* parserInternals.h parser.c: changed the way names are parsed\n-\t  now allow infinite size and decrease penalty for normal use\n-\t* parser.c: Started a big cleanup\/check of the parser code,\n-\t  fixed some of the most tortuous entity code, spotted code\n-\t  unused anymore\n-\t* test\/*: added tests for very long names and related nasty\n-\t  things.\n-\n-Sat Aug 26 23:31:04 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/encoding.html: added encoding aliases doc\n-\t* doc\/xml.html: updates\n-\t* encoding.[ch]: added EncodingAliases functions\n-\t* entities.[ch] valid.[ch] debugXML.c: removed two serious\n-\t  bottleneck affecting large DTDs like Docbook\n-\t* parser.[ch] xmllint.c: added a pedantic option, will be\n-\t  useful\n-\t* SAX.c: redefinition of entities is reported in pedantic mode\n-\t* testHTML.c: uninitialized warning from gcc\n-\t* uri.c: fixed a couple of bugs\n-\t* TODO: added issue raised by Michael\n-\n-Wed Aug 23 01:50:51 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/encoding.html: propagated Martin Duerst suggestions\n-\n-Wed Aug 23 00:23:41 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c: Fixed Bug#21552: libxml fails to decode &amp;\n-\t* uri.c testUri.c patches, by Marc Sanfacon (1 left)\n-\t* parser.c HTMLparser.c: HTML\/encoding push problems reportedi\n-\t  by Wayne Davison\n-\n-Sun Aug 20 17:03:38 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanoftp.c nanohttp.c: small cleanup\n-\t* TODO: updated\n-\n-Sat Aug 19 22:57:02 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* added an old VC testcase and updated title.xml entity\n-\n-Sat Aug 19 21:02:08 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c SAX.c tree.c HTMLtree.h result\/HTML\/*: work\n-\t  done on auto-opening of <p> tags and cleanup of SAX output\n-\n-Sat Aug 19 18:45:40 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* libxml.4  xmllint.1 Makefile.am libxml.spec.in: added man pages\n-\n-Sat Aug 19 18:38:53 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/xml.html libxml.* structure.*: updated the doc a bit\n-\n-Thu Aug 17 15:50:00 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* testSAX.c testHTML.c result\/HTML\/: cleanup of the output\n-\t  of SAX tests\n-\n-Mon Aug 14 13:56:33 EDT 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* Patch from Albert Chin-A-Young <china@thewrittenword.com>:\n-\t* xmllint.c: workaround a MAP_FAILEd definition bug in DU-4.0\n-\n-Mon Aug 14 11:10:20 EDT 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* Patch from Dave Yearke <yearke@eng.buffalo.edu>:\n-\t* testHTML.c: fix core dump on Solaris 2.x systems\n-\t* HTMLparser.c: fix segfault if ctxt->sax->characters() is NULL\n-\t* result\/HTML\/*.sax: previous bug fix lead to new results\n-\n-Mon Aug 14 10:26:09 EDT 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* Patch from Albert Chin-A-Young <china@thewrittenword.com>:\n-\t* configure.in: added --with-readline=DIR to accept alternate\n-\t  path for readline include\/library\n-\t* configure.in: added AM_C_PROTOTYPES to add -Aa -D_HPUX_SOURCE\n-\t  for ANSI under HP-UX\n-\t* config.in: Removed @LIBS@ from xml-config because @XML_LIBS@\n-\t  includes @LIBS@\n-\n-Sat Aug 12 23:19:42 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/* : rebuilt the docs\n-\t* getting ready for 2.2.2 release\n-\n-Sat Aug 12 16:42:37 EDT 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.[ch]: added xmlGetFeaturesList() xmlGetFeature()\n-\t  and xmlAddFeature()\n-\t* tree.[ch]: added xmlAddChildList()\n-\t* xmllint.c: MAP_FAILED macro test\n-\t* parser.h: added xmlParseCtxtExternalEntity()\n-\t* valid.c: applied bug fixes removed warning\n-\t* tree.c: added CDATA block to elements content\n-\t* testSAX.c: cleanup of output\n-\t* testHTML.c: added SAX testing\n-\t* encoding.c: better error recovery\n-\t* SAX.c, parser.c: fixed one of the external entity processing\n-\t  of the OASis testsuite\n-\t* Makefile.am: added HTML SAX regression tests\n-\t* configure.in: bumped to 2.2.2\n-\t* test\/HTML\/ result\/HTML: added a few of HTML tests, and added the\n-\t  SAX results\n-\n-Fri Aug  4 11:21:50 PDT 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in: patch for HP compiler\n-\n-2000-08-04  Sven Heinicke  <sven@zen.org>\n-\n-\t* xmllint.c: Was coredumping sometimes when the file given didn't\n-\texist.\n-\n-Sat Jul 22 05:59:05 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c xmlIO.[ch]: fixed the problem of encoding support\n-\n-\t  when using in memory parsing. Need some cleanup.\n-\t* xmllint.c configure.in: added a --memory flag to test memory\n-\t  parsing\n-\n-Fri Jul 21 17:09:57 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanohttp.c: fixed socklen_t replacement to unsigned int\n-\t* parser.c: fixed a space handdling missing at the end of\n-\t  production 28 DOCTYPE.\n-\t* xmlmemory.c: fixed a stupid bug on the routine to override\n-\t  allocation functions\n-\t* TODO: updated\n-\n-Fri Jul 14 17:01:14 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/ regenerated the docs\n-\n-Fri Jul 14 16:12:20 MEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/encoding.html doc\/xml.html: added I18N doc\n-\t* encoding.[ch] HTMLtree.[ch] parser.c HTMLparser.c: I18N encoding\n-\t  improvements, both parser and filters, added ASCII & HTML,\n-\t  fixed the ISO-Latin-1 one\n-\t* xmllint.c testHTML.c: added\/made visible --encode\n-\t* debugXML.c : cleanup\n-\t* most .c files: applied patches due to warning on Windows and\n-\t  when using Sun Pro cc compiler\n-\t* xpath.c : cleanup memleaks\n-\t* nanoftp.c : added a TESTING preprocessor flag for standalong\n-\t  compile so that people can report bugs more easily\n-\t* nanohttp.c : ditched socklen_t which was a portability mess\n-\t  and replaced it with unsigned int.\n-\t* tree.[ch]: added xmlHasProp()\n-\t* TODO: updated\n-\t* test\/ : added more test for entities, NS, encoding, HTML, wap\n-\t* configure.in: preparing for 2.2.0 release\n-\n-Mon Jul 10 16:17:18 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanoftp.c: fixed the way the control connection is handled\n-\t* libxml.spec.in: fixed the dependencies and cleanup\n-\n-Mon Jul  3 14:37:07 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/xml.html: changed the xmlsoft.org structure, updated the\n-\t  examples w.r.t. root and childs\n-\n-Sun Jul  2 20:51:43 MEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* libxml.spec.in: fixed bug #7419, dependencies fouled for libxml-devel\n-\n-Sun Jul  2 09:52:45 MEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c: Work on character encoding support for the HTML parser\n-\t* HTMLparser.c: Fixed some autoopen\/autoclose probs for the HTML parser\n-\t* encoding.c: Fixed a potential memleak in the encoding stuff\n-\n-Sat Jul  1 13:44:22 MEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/FAQ.html doc\/Makefile.am : added a FAQ\n-\n-Fri Jun 30 20:29:08 MEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c HTMLtree.c SAX.c valid.c tree.h : more cleanup\n-\t  of the HTML parser to force it to not bypass SAX\n-\n-Fri Jun 30 11:19:59 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* win32config.h.in: updated\n-\t* xmlversion.h.in: crap forgot to update this, this mean 2.1.0\n-\t  lacks iconv support :-( need to release 2.1.1\n-\t* configure.in: release 2.1.1\n-\t* HTMLparser: fixed bug #14784\n-\t* xpath.c HTMLparser.c encoding.c parser.c: fix warning raised\n-\t  by Windows compiler\n-\t* HTMLparser.c SAX.c HTMLtree.h tree.h: create HTML document in\n-\t  the SAX startDocument() callback.\n-\t* TODO: updated\n-\n-Thu Jun 29 12:06:48 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* added xmlStopParser()\n-\n-Wed Jun 28 23:10:26 MEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in: 2.1.0 prerelease\n-\t* Large resync between W3C and Gnome tree\n-\t* nanoftp, nanohttp.c: fixed stalled connections probs\n-\t* HTMLtree.c SAX.c : support for attribute without values in\n-\t  HTML for andersca\n-\t* valid.c: Fixed most validation + namespace problems\n-\t* HTMLparser.c: start document callback for andersca\n-\t* debugXML.c xpath.c: lots of XPath fixups from Picdar Technology\n-\t* parser.h, SAX.c: serious speed improvement for large\n-\t  CDATA blocks\n-\t* encoding.[ch] xmlIO.[ch]: Improved seriously saving to\n-\t  different encoding\n-\t* example\/Makefile.am example\/gjobread.c tree.h: work on \n-\t  libxml1 libxml2 convergence.\n-\t* config.h.in parser.c xmllint.c: added xmlCheckVersion()\n-\t  and the LIBXML_TEST_VERSION macro\n-\n-Fri Jun 23 22:26:07 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/xml.html: various patches and improvements typo fixed by\n-\t  Felix Natter\n-\t* doc\/libxml-doc.el: Emacs module to lookup the libxml documentation\n-\t  from Felix Natter <fnatter@gmx.net>\n-\n-Sat May  6 10:09:45 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/upgrade.html: updated with instructions for support of both\n-\t  libxml-1.x and libxml-2.x\n-\t* doc\/gjobread.c : applied Todd Dukes <tdukes@ibmoto.com> patch\n-\t  for 2.x support and also fixed includes\n-\n-Wed May  3 14:21:25 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* encoding.[ch], xmlIO.[ch], parser.c, configure.in : revamped\n-\t  the encoding support, added iconv support, so now libxml if\n-\t  compiled with iconv automatically support japanese encodings\n-\t  among others. Work based on initial patch from Yuan-Chen Cheng\n-\t  I may have broken binary compat in the encoding handler\n-\t  registration scheme, but that was so utterly broken I don't\n-\t  expect anybody to have used this feature until now.\n-\t* parserInternals.h: fixup on the CHAR range macro\n-\t* xml-error.h, parser.c: catch URL\/URI errors using the uri.c\n-\t  code.\n-\t* tree.[ch]: added xmlBufferGrow(), was needed for iconv\n-\t* uri.c: added xmlParseURI() I can't believe I forgot to\n-\t  implement this one in 2.0 !!!\n-\t* SAX.c: moved doc->encoding update in the endDocument() call.\n-\t* TODO: updated.\n-\n-Mon Apr 24 13:30:13 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.h: removed extraneous xmlRemoveProp definition\n-\t* TODO: added item about --disable-corba configure switch\n-\t* tree.c parser.c: fixed problems for xmlCopyDoc and postvalidation\n-\t* nanoftp.c: fixed include problems giving troubles on AIX and \n-\t  slowlaris\n-\t* xmlIO.[ch] valid.h tree.[ch] xlink.c xmlmemory.c uri.c \n-\t  parser.c nanoftp.c nanohttp.c SAX.c testSAX.c :\n-\t  comment and headers changes to lower gtk-doc number of warnings\n-\t* doc\/html\/*: rebuilt docs\n-\n-Sun Apr 16 11:23:29 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HACKING: documented the tag for 1.x and instructions\n-\n-Wed Apr 12 15:47:22 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xmlIO.[ch] parser.[ch]: More interfaces for new I\/O functions\n-\t  xmlNewIOInputStream, xmlParserInputBufferCreateIO,\n-\t  xmlCreateIOParserCtxt\n-\t* parser.c parserInternals.h: speedup of IS_CHAR like macros,\n-\t  significant overall improvement\n-\t* xmllint.c: added I\/O test to xmllint\n-\t* testSAX.c: added a speed test\n-\t* doc\/* : updated\/regenerated\n-\n-Sat Apr  8 14:54:54 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xpath.c uri.h parserInternals.h: cosmetic changes from\n-\t  \"Timur I. Bakeyev\" <timur@bat.ru>, including making \n-\t  xmlCreateURI() public\n-\n-Fri Apr  7 18:35:02 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xmlIO.[ch] parser.c: cleane up the xmlParserInputBuffer mess\n-\t  and the code at the same time. Added a clean mechanism for\n-\t  overload or added input methods: xmlRegisterInputCallbacks()\n-\t* tree.c: fixed xmlPrevSibling and xmlNextSibling per \n-\t  Christophe Le Gal (Christophe.Le-Gal@imag.fr) input\n-\t* TODO: updated\n-\t* doc\/* : updated\/regenerated\n-\t* doc\/Makefile.am: tweaks to avoid problem with libxml link in the\n-\t  source dir\n-\n-Wed Apr  5 21:11:35 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* testURI.c: yet another forgotten commit, I should get some sleep !\n-\n-Wed Apr  5 20:36:46 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xmllint.c: forgot to commit this too ?\n-\n-Wed Apr  5 16:22:44 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xmlversion.h.in : forgot to commit this previously\n-\n-Mon Apr  3 21:47:10 CEST 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in: preparing libxml-2.0.0 version looks Ok so far\n-\t* README TODO: updated for release\n-\t* uri.c uri.h: added authority parsing\/saving\n-\t* uri.c testURI.c Makefile.am: moved the testing code to testURI.c\n-\t* xmlversion.h.in configure.in nanoftp.[ch] nanohttp.[ch] encoding.h\n-\t  debugXML.[ch] xpath.[ch] xmlIO.c tester.c testXPath.c testHTML.c\n-\t  tree.c HTMLtree.c HTMLparser.c tree.c tree.h parser.c\n-\t  Makefile.am : added compile-time customization of libxml\n-\t  --with-ftp --with-http --with-html --with-xpath --with-debug\n-\t  --with-mem-debug\n-\t* *.[ch] autoconf.sh : moved to an absolute addressing of includes : \n-\t  #include <libxml\/xxx.h> I hope it won't break too much stuff\n-\t  and will be manageable in the future...\n-\t* xmllint.c Makefile.am libxml.spec.in : renamed tester.c to xmllint.c\n-\t  and added xmllint to the installed programs\n-\t* uri.h: added xmlFreeURI()\n-\n-Fri Mar 24 14:35:21 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* uri.c uri.h: finished the escaping handling, the base support\n-\t  and the URI path normalization. Looks good just lacks the\n-\t  authority content parsing code.\n-\t* Makefile.am: added instructions to generate testURI\n-\t* TODO: updated\n-\t* doc\/xml.html, doc\/smallfootonly.gif doc\/w3c.png: updated,\n-\t  added links and icons for W3C and Gnome\n-\n-Mon Mar 20 14:05:26 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xmlmemory.[ch] : seems I forgot to actually update the files in\n-\t  the last commit :-)\n-\t* doc\/xml.html doc\/html\/* : updated and uploaded the docs\n-\n-Mon Mar 20 12:33:51 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* test\/valid\/dtds\/xhtml*: removed RCS infos (pain with CVS)\n-\t* TODO: updated\n-\t* xmlmemory.[ch] : added xmlMemSetup() and xmlMemGet() to override\n-\t  libxml default allocation function with another set (like gmalloc\/\n-\t  gfree).\n-\t* Makefile.am, uri.c, uri.h: added a set of functions to do\n-\t  exact (literally copied from the RFC 2396 productions) parsing\n-\t  and handling of URI. Will be needed for XLink, one XML WFC, \n-\t  XML Base and reused in the nano[ftp\/http] modules. Still work\n-\t  to be done.\n-\n-Tue Mar 14 20:52:35 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in, libxml.spec.in : libxml2\n-\t* doc\/* : updated the doc page, rebuilt the docs\n-\n-Tue Mar 14 19:11:29 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* all: tagged LIB_XML_1_X\n-\t* *.c *.h : updated from W3C CVS tree\n-\t* configure.in : 2.0.0-beta\n-\t* libxml.spec.in : libxml2 package nam\n-\t* result\/* : new version of the tests output\n-\n-Mon Mar  6 09:34:52 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/xml.html, doc\/update.html: updated docs, 1.8.7\n-\n-Sat Mar  4 16:14:42 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/* : rebuilt the docs\n-\t* parser.c: final patch on #6766\n-\t* valid.c: small patch on validity checks.\n-\n-Sat Mar  4 12:38:41 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/upgrade.html: instruction on how to upgrade from 1.x to 2.x\n-\t  added\n-\t* parser.c: adding xmlKeepBlanksDefault() as a way to manage\n-\t  compatibility w.r.t. XML spec and existing code.\n-\n-Thu Mar  2 04:45:15 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c: seems a better solution to <a>   <\/a> exists,\n-\t  will try it for a while\n-\n-Thu Mar  2 02:26:13 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c: tried to remove the <a>   <\/a> generating <a\/>\n-\t  this is hard. Left a flag for that purpose. Fixed bug #6766\n-\t* configure.in: prepared 1.8.7 not released, due to previous\n-\t  problem\n-\n-Thu Mar  2 03:03:50 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/xml.html : applied second patch from Paul DuBois\n-\n-Tue Feb 29 23:55:13 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/xml.html : applied patch from Paul DuBois\n-\n-Thu Feb  3 16:36:39 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c HTMLparser.c: do a bit of bufferization in push mode.\n-\n-Thu Feb  3 15:59:37 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanoftp.c nanohttp.c tree.c HTMLtree.[ch] debugXML.c xpath.c: Fixed\n-\t  compilation warnings on various platforms.\n-\t* parser.c: Fixed #5281 validity error callbacks are now deactivated\n-\t  by default if not validating.\n-\n-Thu Feb  3 13:46:14 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanoftp.c, win32config.h.in: patches to compile on WIN32\n-\n-Wed Feb  2 22:51:16 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanoftp.c: snprintf\/sprintf patch courtesy George Katsirelos\n-\t  <gkatsi@cs.toronto.edu>\n-\n-Mon Jan 31 18:58:21 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanoftp.c nanohttp.c: Fixed '#' and '?' stripping when\n-\t  processing URLs\n-\n-Mon Jan 31 14:25:57 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanoftp.[ch]: cleanup, bug fixes, integration in rpmfind, added\n-\t  xmlNanoFTPUpdateURL for persistent control connections.\n-\t* configure.in: 1.8.6\n-\n-Thu Jan 27 17:52:29 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanohttp.[ch], nanoftp.[ch]: cleanup, added proxy support\n-\t* tree.[ch] : added xmlSaveNoEmptyTags\n-\n-2000-01-29  James Henstridge <james@daa.com.au>\n-\n-\t* nanoftp.c: include <netinet\/in.h> for IPPROTO_TCP.\n-\n-\t* Makefile.am: added nanoftp.[ch] to the build.\n-\n-Wed Jan 26 18:14:55 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanoftp.[ch]: cleanup, comments, API\n-\t* debugXML.c : fixed a bug in the cat command\n-\t* doc\/*: regenerated the docs\n-\n-Wed Jan 26 16:52:50 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanoftp.[ch] parser.c xmlIO.[ch]: added a Nano FTP implementation\n-\t* debugXML.c : fixed a bug in the cat command\n-\t* valid.c: fixing some small probs\n-\t* libxml.spec.in: get rid of the SNAP suffix\n-\t* doc\/xml.html: updated the status\n-\n-Mon Jan 24 14:31:09 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xml-config.in: xml-config --version to just return the\n-\t  version number\n-\t* xpath.c: some cleanup w.r.t. axis when the current node is\n-\t  an attribute.\n-\t* TODO: updated\n-\n-Tue Jan 18 18:46:06 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in: prepared for libxml-1.8.5\n-\t* doc\/* recompiled the documentation\n-\n-2000-01-17  Jody Goldberg <jgoldberg@home.com>\n-\n-\t* configure.in : WARNING autoconf subtlety alert :\n-\t  Use AC_CHECK_HEADERS rather than AC_CHECK_HEADER\n-\t  when looking for zlib.h so that HAVE_ZLIB_H is defined.\n-\t* config.h.in : Have a #undef for HAVE_ZLIB_H so that it will\n-\t  get defined by AC_CHECK_HEADERS.\n-\n-Mon Jan 17 17:04:12 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.c: fixed a hideous bug in xmlGetProp() thanks to\n-\t  Rune.Djurhuus@fast.no\n-\n-Sat Jan 15 15:09:06 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* TODO: updated\n-\t* tree.c, parser.c: made sure that only memory alloc problems\n-\t  and internal parser errors are allowed to write to stdout or\n-\t  stderr.\n-\n-Thu Jan 13 11:49:11 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.c : restored xmlNewGlobalNs since this seems used by\n-\t  a lot of existing code :-(, fixed a bug in xmlNewNs\n-\t* nanohttp.c: fixed a problem with INCLUDE_WINSOCK\n-\t* HTMLparser.c, parser.c, entities.c, valid.c : removed all calls\n-\t  to exit() from the library code.\n-\t* xpath.c, parser.c: removed bugs or unused code detected by \n-\t  Windows compilers\n-\t* parser.c: started adding interfaces for parsing well balanced\n-\t  XML fragments\n-\t* configure.in: releasing 1.8.4\n-\t* doc\/* : rebuilt the docs\n-\n-Sun Jan  9 23:03:20 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.[ch] : added xmlNewDocFragment() for DOM\n-\t* testHTML.c: uninitialized variable.\n-\n-Wed Jan  5 17:29:17 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/* : rebuild the docs\n-\n-Wed Jan  5 17:08:43 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* acconfig.h: readline and history patch\n-\t* valid.[ch]: added xmlRemoveID() and xmlRemoveRef()\n-\t* tree.c: added check and handling when possibly removing an ID\n-\t* tree.c, HTMLparser.h, HTMLtree.h: fixed entities parsing\n-\t     and saving.\n-\t* test\/HTML\/entities.html result\/HTML\/entities.html* : test for\n-\t     various entities reference cases\n-\t* result\/HTML\/* : as a result output of some testcase have\n-\t     changed\n-\t* HTMLparser.c, parser.c: fixed a bug in the push mode triggered\n-\t     by previous example. added xmlParseTryOrFinish().\n-\t* xpath.h tree.h parser.h valid.h xmlIO.h xlink.h encoding.h\n-\t  entities.h debugXML.h HTMLparser.h: changed the way struct are \n-\t  declared to allow gtk-doc to expose those\n-\t* parser.c: closed bug #4960  \n-\t* Makefile.am configure.in: Applied patch from \n-\t  Albert Chin-A-Young <china@thewrittenword.com> for better zlib\n-\t  and math\/socket libs detection\n-\n-Mon Jan  3 18:29:43 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in, Makefile.am: link tester against readline\n-\t* doc\/xml.html doc\/*\/*: updated and rebuilt the documentation pages\n-\n-Mon Jan  3 11:58:05 CET 2000 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.[ch]: added xmlRemoveProp\n-\t* win32config.h.in nanohttp.c: avoid including the Windows\n-\t    socket stuff in every C files\n-\t* parser.c: removed an indetermination xmLDecl\/PI(xml...) in\n-\t    the XmL parser(s)\n-\t* test\/ns4 result\/ns4 etc...: added test case for previous prob    \n-\t* tree.c: xmlNewNs wasn't checking for double definition\n-\t* Makefile.in: fixed a problem with dist-hook duplicates\n-\t* parser.[hc], xmlIO.c: fixed the loading of external entities\n-\t    APIs, now xmlLoadExternalEntity() is used everywhere and\n-\t    setting up an app specific front-end using the \n-\t* SAX.c parser.c: some fixes, now the xhtml spec validates\n-\t    with the xhtml DTD.\n-\t* error.c: fixed crashes in case of no input stream    \n-\t* test\/valid\/[dtds\/]\/xhtml* : added the xhtml spec and dtds\n-\t    to the validation tests and results\n-\n-Wed Dec 29 15:29:52 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.[ch] testHTML.c: added push mode for the HTML parser\n-\t  too htmlCreatePushParserCtxt() and htmlParseChunk()\n-\t* parser.c: a bit of cleanup.\n-\t* SAX.c, HTMLparser.c: some attributes may not have values (contrary\n-\t  to XML) removed the last mem leak known\n-\t* HTMLtree.c: output message cleanup\n-\t* xmlmemory.c: display content info about memory blocks\n-\t* result\/HTML\/wired.* : missing att value warning change\n-\n-Tue Dec 28 17:42:41 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/* : rebuilt the documentation\n-\n-Tue Dec 28 18:44:22 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.[ch] parserInternals.h: Push parser for XML,\n-\t     seems to work fine now\n-\t* tester.c debugXML.[ch]: Added an XML shell debug facility and\n-\t     --push for push testing\n-\t* xpath.[ch] : cleaned up for Shell usage, added missing APIs\n-\t* testSAX.c: added --push\n-\t* HTMLtree.[ch] tree.[ch]: new functions for dumping parts of the\n-\t     subtree\n-\t* xmlIO.[ch] : enriched API + fixes for push mode     \n-\t* entities.[ch]: added the entity content length to the struct.\n-\t* xmlmemory.[ch]: new API to show the last entries for the shell\n-\t* valid.c: added required attribute testing\n-\t* SAX.c: the cdata callback now merge contiguous fragments\n-\t* HTMLparser.c: cleanup of some macros\n-\n-Wed Dec 22 12:20:53 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c: fix for PIs name starting with xml\n-\t* tree.c: fixed a potential problem with || and && ops\n-\t* *.c, configure.in win32config.h.in : generate win32config.h for\n-\t  those on the Other Side !\n-\n-Tue Dec 21 17:22:17 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c: fixed a stupid = vs. == bug :-(\n-\t* doc\/gnome-xml.sgml: s\/glade\/xml\/\n-\n-Tue Dec 21 14:29:34 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in, doc\/xml.html : bug fix release 1.8.2\n-\t* debugXML.h nanohttp.h xml-error.h xmlmemory.h xpath.h : \n-\t  Hopefully the end of that silly C++ include problem\n-\t* tree.[ch]: Added a few functions: xmlReplaceNode, xmlAddPrevSibling,\n-\t      xmlAddNextSibling, xmlNodeSetName and xmlDocSetRootElement\n-\t* HTMLparser.c HTMLparser.h HTMLtree.c: When saving HTML try to avoid \n-\t      troubles with autoclosed elements when the stree shape doesn't\n-\t      follow the DtD specs. Added htmlIsAutoClosed() and\n-\t      htmlAutoCloseTag()\n-\t* result\/HTML\/*.htm*: Updated the HTML examples regression tests output\n-\t* SAX.c tree.c: fixed bug on defaulting namespaces on attributes\n-\t* debugXML.c: fixed a bug on printing default namespaces.\n-\t* HTMLtree.c: fixed a problem when outputting XML parsed docs as HTML\n-\n-Mon Dec 20 16:20:55 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* result\/HTML\/*.htm[l] : updated the HTML regression tests according\n-\t  to the new output\n-\t* xpath.h xml-error.h valid.h tree.h parser.h entities.h SAX.h\n-\t  HTMLtree.h tree.c entities.c: headers tweakings to avoid a nasty\n-\t  problem due to intermix of extern \"C\" { ... } declarations for C++\n-\t  and recursive includes in the headers\n-\n-1999-12-20  Chris Lahey  <clahey@umich.edu>\n-\n-\t* HTMLtree.c: Made it so that html nodes with a single child do\n-\tnot insert a carriage return before or after the child node.\n-\n-Sat Dec 18 16:07:03 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in, doc\/xml.html : bug fix release 1.8.1\n-\t* parser.c: fixed bug #4344\n-\t* xpath.h xml-error.h xlink.h nanohttp.h debugXML.h SAX.h HTMLparser.h\n-\t  added the glue to avoid C++ problems\n-\t* doc\/* : regenerated the documentation\n-\n-Thu Dec 16 16:19:29 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.c: fixed a bug introduced in 1.8.0 and breaking default\n-\t  namespace recognition, and Dia as a result :-(\n-\t* encoding.c: closed bug #3950\n-\n-Wed Dec 15 19:22:23 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* valid.c: debugging a posteriori validation, except URI expansion\n-\t  stuff this should be fixed now\n-\t* parserInternals.h: fixed a bug in IS_BASECHAR reported by\n-\t  Carl Nygard <cnygard@bellatlantic.net>\n-\t* tester.c: added --postvalid, cleaning of the code\n-\t* tree.[ch]: added xmlDocGetRootElement()\n-\n-Tue Dec 14 20:30:34 PST 1999 Ramiro Estrugo <ramiro@eazel.com>\n-\n-\t* SAX.h, tree.h : changed 'namespace' to 'nameSpace' to workaround\n-\tc++ losage.\n-\n-Sun Dec 12 13:08:15 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in, doc\/xml.html : bumped to 1.8.0\n-\t* xlink.[ch], Makefile.am : added framework for link detection\n-\t* parser.h: added nbChars to parser context, needed for cleanup.\n-\t* xmlmemory.c: removed a nasty bug when out of mem\n-\t* valid.[ch]: adding namespace support for attribute decl\n-\t* tester.c: added --debugent option\n-\t* debugXML.[ch]: added xmlDebugDumpEntities()\n-\t* parser.c: cleanup, avoiding use of CUR_PTR like plague, using\n-\t  buffers instead, this was really needed, validation was breaking\n-\t  in strange ways due to that. Added xmlParseStringPEReference()\n-\t  and other parsing from strings functions. Entities processing\n-\t  modified again, but PERef are still not handled correctly but\n-\t  unless you're Eve Maller you won't notice :-)\n-\t* HTMLparser.c: large changes toward reliability, and switched to\n-\t  lowercase internal tags, XHTML is lowercase, so it will help\n-\t  that output is closer to next version.\n-\t* doc\/* : regenerated the documentation, it is now hosted at\n-\t  http:\/\/xmlsoft.org\/ (same bits I just bought the domain :-)\n-\n-Fri Dec  3 13:46:32 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* SAX.h, SAX.c, makefile.am: added SAX.h mostly useful for the\n-\t         doc generation\n-\t* parser.c: fixed bugs #3908 and #3937 and a memory leak\n-\t         in the SAX API\n-\t* doc\/*: rebuilt the doc making sure everything appears in the\n-\t         HTML files\n-\n-Wed Dec  1 10:27:47 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.[ch] HTMLtree.c, debugXML.c, configure.in, xml-config.in:\n-\t     added the patch from Carl Nygard <cnygard@bellatlantic.net>\n-\t     which allow impressive speed improvement on dataset with\n-\t     large text pieces, but at the cost of broken binary\n-\t     compatibility and slightly bigger memory usage.\n-\t     Configure with --with-buffers to activate them, they\n-\t     are protected with XML_USE_BUFFER_CONTENT define.\n-\t* entities.[ch], parser.c: added xmlCleanupPredefinedEntities(),\n-\t     goal is 0 memory left allocated once parser is no more used\n-\t* testDAV.c, testHTML.c, testSAX.c, testXPath.c: make sure we\n-\t     call xmlCleanupParser() and xmlMemoryDump()\n-\n-Wed Nov 24 19:00:06 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.[ch] xmlIO.[ch] parser.c valid.c: code cleanup with -pedantic\n-\t* parser.[ch] encoding.[ch]: added memory cleanup routines\n-\t* parser.c: closing bug #3788\n-\t* doc\/*: rebuilt the doc\n-\n-Tue Nov 23 11:23:55 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.[ch]: closing bug 3748, added xmlNewDocRawNode(), \n-\t             xmlNewTextChild() and xmlSetCompressMode() behaviour.\n-\t* tester.c: added --compress option\n-\t* doc\/*: rebuilt the documentation\n-\n-Fri Nov 19 18:41:28 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c: bugfixing, the damn thing MUST not crash even\n-\t                if given \/proc\/kcore as input !\n-\t* doc\/xml.html doc\/*: updated and rebuilt the documentation\n-\n-Thu Nov 18 14:57:18 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c: Fixed some wrongly space collapsing code due to\n-\t            a misreading of the spec.\n-\t* result\/*: fixed the output accordingly\t    \n-\n-Wed Nov 17 18:28:06 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* encoding.c: bug fix and typos\n-\t* xmlIO.[ch] parser.c: first bits toward real progressive parsing\n-\t* parser.c: added attribute normalization closing bug #3597\n-\t* test\/att* result\/att* SAXresult\/att*: testcase for attribute\n-\t    normalization\n-\n-Mon Nov 15 18:50:56 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in: closing bug #3163 by adding extra flags for the\n-\t                cc compiler on HP-UX\n-\n-Fri Nov 12 17:41:20 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* valid.[ch] : removed a typo and an enumerated type bug in the\n-\t               xmlAddElementDecl() function\n-\t* tree.c : I changed xmlSetProp() and xmlNewProp() to do the\n-\t    call to xmlEncodeEntitiesReentrant() so that the functions \n-\t    New, Set and Get are at the same level.\n-\t* parser.c HTMLparser.c: extra memory allocation bug for\n-\t    attributes detected by someone using libxml in embedded systems :-)\n-\n-Thu Oct 28 17:49:26 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xmlmemory.h: turned off mem debug :-\\\n-\n-Mon Oct 25 12:13:25 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c: closed bug #2784 a one line fix, but worth pushing\n-\t            a new release out\n-\t* HTMLparser.c: fixed auto-close bugs on list items, zeroing\n-\t            some structures, comments before and after the\n-\t\t    main element, and other nastiness\n-\t* HTMLtree.c tree.c: accommodate the extended HTML supported\t    \n-\t* configure.in: pushing 1.7.4\n-\t* test\/ent8 and related outputs : added a new test for bug #2784\n-\t* test\/HTML\/wired.html and related output: a nasty HTML example\n-\t* Makefile.am: improved the test scripts\n-\t* docs\/* : reran the documentation extractor, updated xml.html\n-\n-Thu Oct 14 10:29:56 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c, HTMLtree.c, tree.h: completely revamped the\n-\t     HTMLparser and debugged the HTML related code. HTML documents\n-\t     now have their own type\n-\t* entities.c: do not dump &apos; for HTML output\n-\t* xmlmemory.c: improvement, breakpoint mechanism\n-\t* testHTML.c: added --sax --repeat ...\n-\t* Makefile.am: improved the HTML tests\n-\t* valid.[ch]: added xmlValidGetValidElements and\n-\t              xmlValidGetPotentialChildren\n-\t* tester.c: added --insert to test the 2 new functions\n-\t* test\/\/* result\/\/* SAXresult\/\/* : regression test cleanup\n-\t               and extension.\n-\t* doc\/html : added doc for new modules gnome-xml-xmlmemory.html and\n-\t             gnome-xml-nanohttp.html\n-\n-Mon Oct 11 14:31:58 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c: fixed problems with some autoclose tags\n-\t* tree.c: fixed XML output problems. \n-\t* result\/* SAXresult\/*: update of the tests output\n-\n-Sat Oct  9 11:02:57 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* Makefile.am: Arturo patch for xmlConf.sh version info\n-\t* parser.c: Tim Josling patch for single quoted items\n-\t* tester.c: Tim Josling patch for tester options usage\n-\t* tree.h: indent cleanup\n-\n-Fri Oct  8 16:35:37 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c parser.h : Fixed problems with HTML parsing\n-\t    reported by Kristian Hogsberg Kristensen <hogsberg@daimi.au.dk>\n-\n-Fri Oct  8 11:37:11 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.c : Raph patch for initialization of CORBA fields\n-\t* parser.c, xpath.c, ...: modification of doc comments\n-\t* xpath.c : allow spaces in xpath expressions\n-\n-Mon Sep 27 10:16:43 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xmlmemory.h: turning off memory debug :-(\n-\n-Sun Sep 26 13:16:54 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.[ch] : added xmlSAXUserParseFile() and xmlSAXUserParseMemory()\n-\t                better SAX interfaces.\n-\t* testSAX.c: uses the new SAX routine, avoid fetching any remote\n-\t             entity.\n-\t* configure.in: 1.7.2\n-\n-Fri Sep 24 16:01:01 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* libxml.spec.in: fixed the URL\n-\t* doc\/xml.html: improved the documentation front-end\n-\n-Fri Sep 24 01:06:36 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* nanohttp.c: conditionned references to snprintf with HAVE_SNPRINTF\n-\n-Fri Sep 24 00:15:58 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* libxml.spec.in: fixed the alpha compile problem\n-\t* parser.[ch]: changed errno to errNo in the parser context :-(\n-\t* *.[ch]: changed CHAR to xmlChar to avoid problem on WIN32\n-\t* doc\/xml.html: changed CHAR to xmlChar\n-\t* doc\/html\/*: recompiled the documentation\n-\t* configure.in: 1.7.1\n-\n-Wed Sep 22 11:40:31 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.h: modified the parser context struct to regain 1.4.0\n-\t            binary compatibility\n-\t* parser.c, xml-error.h: added errno to the context and defined\n-\t            a set of errors values with update of errno\n-\t* nanohttp.[ch]: minimalist HTTP front-end for fetching remote\n-\t            DTDs and entities\n-\t* *.h, *.c: complete cleanup of the use of config.h and include\n-\t            protection depending on the current setup.\n-\t* overalll debugging, maintenance and bug-fixing on all modules\n-\t* updated the documentation\n-\t* ready for 1.7.0\n-\n-Wed Sep  8 22:46:14 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c : cleanup\n-\t* SAX.c valid.c valid.h: added ID\/IDREF checking\n-\t* tree.c tree.h: extended doc structure for refs\n-\t* configure.in: 1.6.2\n-\t* parser.c: patched bug in SAX user arg call\n-\t* parserInternals.h: patched missing close in C++ wrapping\n-\t* testXPath.c xpath.c xpath.h: prepared for extensibility,\n-\t  especially upcoming XPointer implementation.\n-\t* doc\/xml.html: augmented, typo\n-\n-Sat Sep  4 22:48:05 CEST 1999 Timur Bakeyev <mc@bat.ru>\n-\n-\t* doc\/Makefile.am: replaced \"install -d \" with \"mkinstalldirs\" -\n-\tnot all invocations of install understand -d.\n-\n-Sat Sep  4 22:20:07 CEST 1999 Timur Bakeyev <mc@bat.ru>\n-\n-\t* Makefile.am: prepend all the test* calls with $(top_builddir) -\n-\tto make 'check' works, when builddir != srcdir.\n-\n-Sat Sep  4 20:25:46 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* doc\/xml.html : updated the documentation\n-\n-Fri Sep  3 00:01:08 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xmlmemory.[ch] Makefile.am  :added a memory wrapper to chase\n-\t      not deallocated memory blocks\n-\t* *.c : replaces all calls to malloc() free() and realloc() to\n-\t      the wrapper functions\/macros\n-\t* tree.c : removed memory leaks dues to calling xmlFreeNode()\n-\t      instead of xmlFreeNodeList()\n-\n-Wed Sep  1 14:15:09 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c: corrected a stupid bug leading to core dump at\n-\t                tree deallocation. Removed warnings indicated by\n-\t\t\tStephane.Conversy@lri.fr\n-\t* entities.c: Fixes Yet Another Stupid Bug, entities were not\n-\t              looked for in the external subset\n-\n-Mon Aug 30 13:22:26 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c valid.[ch] xpath.c: patched compilation warnings reported\n-\t  on SGI by Stephane.Conversy@lri.fr\n-\n-Sun Aug 29 22:27:29 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* all .h : changed the prototype declaration indent as in gtk\n-\t* most .c : working on reducing the TODOs in the code\n-\t* most .c : cleanup though -pedantic and Insure++\n-\t* improvements on validation ID checkings.\n-\t* tree.[ch] SAX.c: added support for namespace on attributes #2022\n-\t* xml-config.in: closed #1810\n-\n-Mon Aug 16 03:27:38 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.h, valid.c, valid.h: more work on validity, IDs\n-\t* xpath.c: added\/fixed comparidon and equlity, added a new isinf\n-\t  definition for AIX\n-\n-Sun Aug 15 21:15:17 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* Makefile.am libxml.spec.in: corrected missing xmlConf.sh in\n-\t  the distribution due to a cut'n paste error at last commit\n-\n-Tue Aug 10 20:28:09 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in: upgraded to version 1.4.0\n-\t* valid.[ch], SAX.c, parser.[ch] parserInternals.h ...\n-\t  Big update, added a large part of the validation process,\n-\t  it should be usable, but some parts are missing\n-\t* xpath.c: improved the implementation w.r.t. root.\n-\t* Makefile.am: added more tests\n-\t* test and result trees: added a lot of tests\n-\t* libxml.spec.in: export libxml.so.0 and libxml.so.1\n-\n-Tue Aug 10 11:33:41 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* Added an HACKING file\n-\n-Tue Jul 27 21:43:00 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xpath.[ch] : improvements and debug of the XPath implementation\n-\t* parser.c, HTMLparser.c : modified the parsers to be progressive\n-\t* tree.[ch] : extended the Buffer promitives\n-\t* xmlIO.[ch] : added basic I\/O routines providing progressive\n-\t  parsing and ready for I18N conversion plugins\n-\t* SAXresult\/* : the SAX callback sequence maybe slightly different\n-\t  now\n-\t* test*.c : improved\/updated the tests programs\n-\t* doc\/* : recompiled the docs.\n-\n-1999-07-26  Michael Meeks  <michael@edenproject.org>\n-\n-\t* tree.h: Add const to 'content' in xmlNewDocNode, xmlNewChild\n-\n-\t* tree.c: Ditto.\n-\n-Thu Jul 15 16:17:16 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in: upgraded to version 1.4.0\n-\t* xpath.c, xpath.h, testXPath.c, makefile.am: added code for the XPath\n-\t  draft from W3C. Will be used by XPointer, Xlink, XSL, and possibly\n-\t  XML query language, see http:\/\/www.w3.org\/TR\/xpath for more details.\n-\t* parser.c, parser.h: added CHAR* related string functions for XPath\n-\t* HTMLparser.[ch], HTMLtree.c: a bit of cleanup on entities.\n-\t* doc\/gnome-xml.sgml, doc\/html\/* : added XPath and HTML documentation,\n-\t  rebuild the docs.\n-\t* Makefile.am, test\/XPath\/*, result\/XPath\/*: added an XPathtests target\n-\t  and regression testing capabilities for XPath.\n-\n-Mon Jul 12 12:36:39 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c, HTMLparser.c: applied patch from John Ellson <ellson@lucent.com>\n-\t  closing bug #1646\n-\n-Mon Jul 12 11:04:44 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* Makefile.am, example\/Makefile.am: closed bug #1683\n-\n-Sun Jul 11 18:16:34 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* example\/Makefile.am, configure.in: added the makefile for the\n-\t  gjobread example\n-\n-Sat Jul 10 14:19:11 CEST 1999 Tomasz Kłoczko  <kloczek@pld.org.pl>\n-\n-\t* doc\/Makefile.am:\n-\t- fix which allow \"make install DESTDIR=<\/install\/prefix>\".\n-\n-Fri Jul  9 12:10:24 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.c parser.c: applied patch from John Ellson <ellson@lucent.com>\n-\t  which fixed a problem on the file reading-code.\n-\n-Wed Jul  7 09:28:43 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* HTMLparser.[ch], HTMLtree.[ch]: more work for HTML parsing and\n-\t  output.\n-\t* Makefile.am, test\/HTML\/*, result\/HTML\/*: added HTMLtests targetestHTMLt\n-\n-Wed Jul  7 00:25:42 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.h : Oops removed the binary compatibility problem\n-\t* HTMLparser.[ch], HTMLtree.h : More work on the HTML parse\/dump\n-\t* parser.c, HTMLparser.c: applied patches for reading from stdin\n-\n-Mon Jul  5 18:45:31 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c, entities.c, valid.c: cleanup bug #1591\n-\t* configure.in: cleanup bug #1592\n-\t* HTMLparser.[ch], testHTML.c: started adding an HTML parser using\n-\t  the same tree back-end. Hence gdome will be available for it.\n-\t* doc\/Makefile.am: close bug #617\n-\n-Sat Jun 26 23:36:38 EDT 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c: alloctate a per parser context SAX interface block\n-\n-Tue Jun 22 23:46:32 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* released 1.3.0 with xmlEncodeEntities restoring old behaviour\n-\t  and xmlEncodeEntitiesReentrant with the correct one :-\\\n-\n-Mon Jun 21 14:07:53 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* commit of my internal XML base changes, quite a lot of\n-\t  changes, cleanups, better entities support, framework for\n-\t  new I\/O and charset detection and handling\n-\t* Fixed the configure\/Makefile stuff to generate shared libs\n-\t  with the proper version info, so we jumped on rev from\n-\t  0.0.0 to 1.2.0 ! The binary interfaces have been broken,\n-\t  xmlEncodeEntities() result need to be freed now, and a string\n-\t  xmlParserVersion provide the current library version.\n-\n-Tue Jun 15 14:24:19 1999  Raph Levien  <raph@acm.org>\n-\n-\t* parser.c: fixed a buffer overrun for when you have a very long\n-\tattribute with no entities in it.\n-\n-Mon Jun 14 00:17:50 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* added example directory\n-\t* added example\/gjobs.xml gjobread.c, still need a Makefile.in\n-\n-Wed Jun  2 19:40:58 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* Release of libxml-1.1, nearly everything has been touched for\n-\t  this.\n-\t* Added more regression tests\n-\t* Updated the documentation\n-\n-Sat May 29 13:34:42 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.[ch]: unified the XML_NO_CORBA defines.\n-\t* parser.c encoding.[ch]: started plugging in char encoding detection\n-\n-Fri May 28 22:58:42 EDT 1999 Manish Vachharajani <mvachhar@vger.rutgers.edu>\n-\n-\t* tree.c: (xmlSaveFile) - removed double call of xmlContentDump.  \n-\t  Also freed allocated buffer.\n-\n-Wed Apr 21 22:07:35 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\t* parser.[ch] tree.[ch] entities.[ch] valid.[ch] : removed the main\n-\t  reentrancy problem at printing. One is left in entities.c, to\n-\t  remove ASAP\n-\t* testSAX.c : added a test example showing the use of the SAX \n-\t  interface if one doesn't want to build the DOM tree.\n-\t* html\/gnome-xml-*.html html\/index.sgml: regenerated the documentation\n-\n-Mon Apr  5 14:14:40 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.[ch] tree.[ch] SAX.c, parserInternals.h valid.[ch]:\n-\t  large revamping of the parser to use SAX callbacks\n-\t  http:\/\/www.megginson.com\/SAX\/ (or at least a C like interface\n-\t  a la Expat). It's now possible to set up your own callbacks\n-\t  and the parser will not build a DOM tree.\n-\t* test\/* result\/*: updated the test suite, I finally removed\n-\t  the old Namespace draft support (PI based).\n-\n-Fri Apr  2 17:57:32 CEST 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* Makefile.am: added test result to EXTRA_DIST for make tests\n-\n-Wed Mar 24 21:37:02 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c, parserInternals.h: moved the chars macro definitions\n-\t  to parserInternals.h\n-\t* parser.c, error.c: applied patches from \"Knut Åkesson\"\n-\t  <ka@s2.chalmers.se> for clean compilation under MSVC 6 :-o\n-\n-Tue Mar 23 11:10:15 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xml-config.in : applied patch to make --version work\n-\n-1999-03-05  Raja R Harinath  <harinath@cs.umn.edu>\n-\n-\t* Makefile.am (check-local): Alias for `tests' target.  This will\n-\tcause `make check' to do the right thing.\n-\t(tests): Don't run tests in srcdir.  Also, replaced calls to\n-\tbasename with a `sed' \"equivalent\".\n-\n-Fri Mar  5 07:23:53 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* Renamed error.h to xml-error.h, corrected Makefile.am to list\n-\t  it in the header and not the sources, updated the doc.\n-\t  Thanks to Tim Mooney <mooney@dogbert.cc.ndsu.nodak.edu> for\n-\t  pointing this out.\n-\n-Mon Mar  1 13:27:17 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c, parser.h, parserInternals.h: memory leak hunting,\n-\t  exported the inputStream routines.\n-\t* doc\/html\/* : updated accordingly\n-\n-Sun Feb 28 22:51:33 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c, parser.h, parserInternals.h: added a few extra\n-\t  internal calls to allocate and free parser contexts ...\n-\t* doc\/html\/* : updated accordingly\n-\n-Thu Feb 25 11:52:24 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in, Makefile.am, doc\/makefile.am : General changes for\n-\t  1.0.0 release and including the generated HTML documentation.\n-\n-Thu Feb 25 09:44:52 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* makefile.am : added parserInternals.h, oops.\n-\n-Mon Feb 22 11:24:56 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parserInternals.h: added this header giving access to the parser\n-\t  internal functions.\n-\t* doc\/Makefile.am : added a rebuild target which rebuilds the full\n-\t  set of documentations\n-\t* parser.[ch] tree.[ch] valid.[ch]: serious updates w.r.t. parsing\n-\t  the internal subset. \n-\t* *.c *.h: modifications needed to generate the documentation using\n-\t  gtk-doc, cleanup of functions blocks, reorganisation of struct\n-\t  declarations.\n-\n-Tue Feb 16 17:27:29 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* Makefile.am, spec, doc\/Makefile.am : upgrading to 0.99.8, fixing\n-\t  the tar and spec file to include the beginning of the doc.\n-\n-1999-02-13  Nuno Ferreira  <nmrf@rnl.ist.utl.pt>\n-\n-\t* doc\/.cvsignore: Added this file.\n-\n-Mon Feb  8 19:27:56 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.c: fixed xmlGetProp to return \"\" when the attribute\n-\t  exists, even if the node-list is NULL.\n-\n-Mon Feb  8 16:10:15 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.c: patched an error outputting empty attribute values.\n-\t* Makefile.am and doc\/makefile.am: have been updated during the\n-\t  week-end. Sorry for an empty CVS log, I got a shell problem.\n-\n-Mon Feb  1 12:10:13 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.h: cleaned up using enums instead of defines\n-\t* parser.c, valid.[ch]: more work on parsing\/output of element\n-\t  declarations\n-\n-Sun Jan 31 22:06:48 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* valid.[ch], tree.c, parser.c : more work toward full parsing\n-\t  of XML DTDs.\n-\t* README: added information about mailing-list and on-line\n-\t  documentation\n-\n-1999-01-27  Raja R Harinath  <harinath@cs.umn.edu>\n-\n-\t* configure.in (XML_INCLUDEDIR): Use -I not -L for includes.\n-\n-Sun Jan 17 20:06:36 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c, tree.[ch] : more work toward conformance testing,\n-\t  added a last element to accelerate parsing of very flat structures\n-\t  started working on internal subset Element content declaration.\n-\t* valid.[ch] : first cut at adding code toward validation.\n-\t* previous changes had also small impact on most files, especially\n-\t  the conformance testing using James Clark test suite.\n-\n-Sun Jan 17 14:45:06 CET 1999 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* test\/* : updated the examples, most of them were not well\n-\t           formed (humm), and added rdf2.\n-\t* result\/* : resulting changes in the output.\n-\n-Sun Dec  6 13:06:58 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.c: changed the behaviour of xmlGetProp on NULL values.\n-\n-Sat Dec  5 12:25:09 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.c: patched a bug in the generation of empty attributes\n-\n-Fri Nov 27 01:36:54 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* entities.[ch], tree.[ch], tester.c: added copy interfaces\n-\t  for node\/trees\/documents\/... Biggest problem is namespace\n-\t  support when copying subtrees.\n-\n-Sun Nov 15 19:59:47 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c, entities.c: improve entities and char ref encoding,\n-\t  and cleanups of error messages.\n-\n-Fri Nov 13 13:03:10 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c, entities.c: simple bug hunting done during rpm2html and\n-\t  rpmfind integration.\n-\n-Sun Nov  8 13:11:07 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.[ch]: Added interfaces allowing to specify a SAX\n-\t  handler before parsing.\n-\n-Sun Nov  8 09:39:17 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c: redirrect all errors reporting through the SAX\n-\t  error function\n-\n-Wed Nov  4 14:21:54 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* entities.c: rather use HAVE_SNPRINTF and not depend on glib\n-\t* libtool, tlmain ...: update of the libtool files\n-\n-1998-11-04  Miguel de Icaza  <miguel@nuclecu.unam.mx>\n-\n-\t* entities.c: Use g_snprintf insteda of snprintf.\n-\n-Sun Nov  1 14:31:06 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* entities.c, parser.c: debug and cleanup of CharRef handling\/saving.\n-\t  added ent5 test for this purpose.\n-\t* parser.c, parser.h: formatting, comments and UTF-8 planning.\n-\n-Fri Oct 30 01:36:52 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c: fixed? a strange error due to compression on a GWP\n-\t  document.\n-\n-Thu Oct 29 00:48:45 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.[ch]: bug fixing\n-\t* entities.[ch]: defined a specific type for predefined entities\n-\t* doc\/xml.html: more documentation on the library, how to use it,\n-\t  overview of the interfaces.\n-\n-Wed Oct 28 17:56:35 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.[ch]: more cleanup on the API, made the tree more conformant.\n-\n-Tue Oct 27 17:54:00 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.c: corrected a small bug\n-\t* doc\/xml.html: continuing writing documentation.\n-\n-Tue Oct 27 17:54:00 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* debugXML.h debugXML.c: added debugging utilities.\n-\t* tester.c: added --debug switch.\n-\t* tree.c: patched an incorrect node->type assignment.\n-\t* parser.c: formatting, ensure that node->doc != NULL in attributes\n-\n-Tue Oct 27 01:15:39 EST 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.[ch] SAX.c tree.[ch]: large amount of changes to improve\n-\t  entity support and provide an internal representation close to\n-\t  DOM one (entity ref nodes, and attribute value as tree). I tried\n-\t  to preserve the interface but this will surely break some apps\n-\t  (I have to change rpm2html\/rpmfind for example). I had to change\n-\t  two interfaces, and the generated tree is somewhat different.\n-\t* doc\/* : started documenting the XML library, the tree and\n-\t  DOM\/Corba. This is a first step.\n-\n-Sat Oct 24 14:23:51 EDT 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c: Set up the functions comment block, boring but useful.\n-\t* parser.h, SAX.c, parser.c: now attributes are processed through\n-\t  the SAX interface. The problem is that my SAX interface diverged\n-\t  quite a bit from the original one, well this is not an official\n-\t  spec, and translating it from Java to C is hairy anyway...\n-\n-Tue Oct 20 02:11:21 EDT 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* SAX.c, entities.c, tree.c, encoding.c, error.c: Set up the\n-\t  functions comment block, boring but useful.\n-\n-Sun Oct 18 20:40:58 EDT 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* encoding.[ch], Makefile.am: Added the UTF-8, UTF-16 and ISO Latin 1\n-\t  conversion routines. However they are not yet used to convert the\n-\t  inputs. The core will run with UTF-8.\n-\n-Sun Oct 18 15:08:19 EDT 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.c : make sure that the type id is properly set-up when\n-\t  a new object is allocated, needed for DOM.\n-\n-Sat Oct 17 02:43:21 EDT 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.h, tree.c: Ok, the main objects in the tree will be native\n-\t  corba objects, it costs 8 bytes per Node, Attribute and Document\n-\t  but it simplifies the Corba integration a lot (no extra interface\n-\t  objects to allocate\/free).\n-\n-Tue Oct 13 21:46:57 EDT 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.h, tree.c, parser.c: added prev and doc pointers to Node,\n-\t  and changed NODEs constants for conformity with DOM Level 1\n-\n-Wed Oct  7 23:42:46 EDT 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* added hooks to keep track of servants when creating objects\n-\t  xmlDoc and xmlNode (for Corba export).\n-\n-Sun Oct  4 03:18:09 EDT 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* added xml-config script.\n-\n-Thu Oct  1 16:22:37 EDT 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* autogen.sh : applied patch from Frederic Devernay <devernay@istar.fr>\n-\t  to autoupdate libtool and automake conf files.\n-\n-1998-09-30  Miguel de Icaza  <miguel@nuclecu.unam.mx>\n-\n-\t* Makefile.am: Use '?' to separate the sed\n-\tcommands as ',' is used when people pass -Wl,something.\n-\n-Thu Sep 24 15:13:29 EDT 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* tree.c, tree.h: added a per-document compression interface.\n-\n-Tue Sep 22 20:47:38 EDT 1998\n-\n-\t* tree.c, tree.h: added saving with compression and added interfaces\n-\t  to control the compression level (xmlGetCompressMode,\n-\t  xmlSetCompressMode) and a new save to filename function (xmlSaveFile).\n-\n-Mon Sep 21 20:11:13 EDT 1998 Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* parser.c: corrected a loop for files of size 0\n-\n-1998-08-20  Raja R Harinath  <harinath@cs.umn.edu>\n-\n-\t* error.h: New file.  Contains prototypes from `error.c'.\n-\n-Thu Aug 13 19:02:34 1998  Tom Tromey  <tromey@cygnus.com>\n-\n-\t* Makefile.am (xmlincdir): New macro.\n-\t(xmlinc_HEADERS): Renamed from include_HEADERS.\n-\n-Thu Aug 13 00:40:14 EDT 1998  Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* applied small patch on numeric entities from\n-\t  Christopher Blizzard <blizzard@appliedtheory.com>\n-\n-Wed Aug 12 23:12:58 EDT 1998  Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* New release 0.2, removed the old xml_* files so that it's\n-\t    coherent with the other CVS base (W3C), far better conformance\n-\t    to standard, new namespaces, decent entities support, beginning\n-\t    of a SAX-like interface. Nearly nothing left intact, even the\n-\t    test examples ...\n-\n-1998-07-30  Christopher Blizzard  <blizzard@appliedtheory.com>\n-\n-\t* .cvsignore: Add .deps dir\n-\n-Sun Jul 26 17:29:52 EDT 1998  Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* xml_tree: changed the memory allocation scheme for name in xmlNewNode\n-\n-Sun Jul 26 00:17:51 EDT 1998  Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* configure.in: added test for CPP\n-\t* AUTHORS, Changelog: the original ones didn't get committed but the\n-\t    glib ones instead, fixed.\n-\t* Makefile.am: corrected an error in library naming\n-\n-Fri Jul 24 16:47:14 1998  Daniel Veillard <Daniel.Veillard@w3.org>\n-\n-\t* integrated code developed at W3C\n-\t* changed the original Copyright\n-\t* migrated to automake\n-\t* prefixed the filenames by xml_ to avoid filename clashes\n-\n-#\n-# vim: set enc=utf-8\n-#\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/ChangeLog","additions":0,"deletions":19678,"binary":false,"changes":19678,"status":"deleted"},{"patch":"@@ -60,1 +60,1 @@\n-                 xmlChar end, xmlChar  end2, xmlChar end3);\n+                             xmlChar end, xmlChar  end2, xmlChar end3);\n@@ -64,3 +64,3 @@\n- *                                  *\n- *      Some factorized error routines              *\n- *                                  *\n+ *                                                                      *\n+ *              Some factorized error routines                          *\n+ *                                                                      *\n@@ -81,1 +81,1 @@\n-    return;\n+        return;\n@@ -114,1 +114,1 @@\n-    return;\n+        return;\n@@ -116,1 +116,1 @@\n-    ctxt->errNo = error;\n+        ctxt->errNo = error;\n@@ -119,3 +119,3 @@\n-            (const char *) str1, (const char *) str2,\n-            NULL, 0, 0,\n-            msg, str1, str2);\n+                    (const char *) str1, (const char *) str2,\n+                    NULL, 0, 0,\n+                    msg, str1, str2);\n@@ -123,1 +123,1 @@\n-    ctxt->wellFormed = 0;\n+        ctxt->wellFormed = 0;\n@@ -141,1 +141,1 @@\n-    return;\n+        return;\n@@ -143,1 +143,1 @@\n-    ctxt->errNo = error;\n+        ctxt->errNo = error;\n@@ -146,1 +146,1 @@\n-            NULL, val, 0, msg, val);\n+                    NULL, val, 0, msg, val);\n@@ -148,1 +148,1 @@\n-    ctxt->wellFormed = 0;\n+        ctxt->wellFormed = 0;\n@@ -152,3 +152,3 @@\n- *                                  *\n- *  Parser stacks related functions and macros      *\n- *                                  *\n+ *                                                                      *\n+ *      Parser stacks related functions and macros              *\n+ *                                                                      *\n@@ -309,2 +309,2 @@\n-           (ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \\\n-    xmlParserInputShrink(ctxt->input)\n+                   (ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \\\n+        xmlParserInputShrink(ctxt->input)\n@@ -312,3 +312,3 @@\n-#define GROW if ((ctxt->progressive == 0) &&                \\\n-         (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK))   \\\n-    xmlParserInputGrow(ctxt->input, INPUT_CHUNK)\n+#define GROW if ((ctxt->progressive == 0) &&                            \\\n+                 (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK))   \\\n+        xmlParserInputGrow(ctxt->input, INPUT_CHUNK)\n@@ -329,5 +329,5 @@\n-#define NEXTL(l) do {                           \\\n-    if (*(ctxt->input->cur) == '\\n') {                  \\\n-    ctxt->input->line++; ctxt->input->col = 1;          \\\n-    } else ctxt->input->col++;                      \\\n-    ctxt->token = 0; ctxt->input->cur += l;             \\\n+#define NEXTL(l) do {                                                   \\\n+    if (*(ctxt->input->cur) == '\\n') {                                  \\\n+        ctxt->input->line++; ctxt->input->col = 1;                      \\\n+    } else ctxt->input->col++;                                          \\\n+    ctxt->token = 0; ctxt->input->cur += l;                             \\\n@@ -338,1 +338,1 @@\n-    if (*ctxt->input->cur == '%') xmlParserHandlePEReference(ctxt); \\\n+    if (*ctxt->input->cur == '%') xmlParserHandlePEReference(ctxt);     \\\n@@ -345,2 +345,2 @@\n-#define COPY_BUF(l,b,i,v)                       \\\n-    if (l == 1) b[i++] = (xmlChar) v;                   \\\n+#define COPY_BUF(l,b,i,v)                                               \\\n+    if (l == 1) b[i++] = (xmlChar) v;                                   \\\n@@ -422,1 +422,1 @@\n-    return(0);\n+        return(0);\n@@ -425,2 +425,2 @@\n-    *len = 0;\n-    return(ctxt->token);\n+        *len = 0;\n+        return(ctxt->token);\n@@ -566,10 +566,10 @@\n-    if (ctxt->input->end - ctxt->input->cur >= 4) {\n-        snprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n-                ctxt->input->cur[0], ctxt->input->cur[1],\n-                ctxt->input->cur[2], ctxt->input->cur[3]);\n-    } else {\n-        snprintf(buffer, 149, \"Bytes: 0x%02X\\n\", ctxt->input->cur[0]);\n-    }\n-    htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-             \"Input is not proper UTF-8, indicate encoding !\\n\",\n-             BAD_CAST buffer, NULL);\n+        if (ctxt->input->end - ctxt->input->cur >= 4) {\n+            snprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n+                            ctxt->input->cur[0], ctxt->input->cur[1],\n+                            ctxt->input->cur[2], ctxt->input->cur[3]);\n+        } else {\n+            snprintf(buffer, 149, \"Bytes: 0x%02X\\n\", ctxt->input->cur[0]);\n+        }\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     \"Input is not proper UTF-8, indicate encoding !\\n\",\n+                     BAD_CAST buffer, NULL);\n@@ -606,12 +606,12 @@\n-    if ((*ctxt->input->cur == 0) &&\n-        (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0)) {\n-        xmlPopInput(ctxt);\n-    } else {\n-        if (*(ctxt->input->cur) == '\\n') {\n-        ctxt->input->line++; ctxt->input->col = 1;\n-        } else ctxt->input->col++;\n-        ctxt->input->cur++;\n-        if (*ctxt->input->cur == 0)\n-        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-    }\n-    res++;\n+        if ((*ctxt->input->cur == 0) &&\n+            (xmlParserInputGrow(ctxt->input, INPUT_CHUNK) <= 0)) {\n+                xmlPopInput(ctxt);\n+        } else {\n+            if (*(ctxt->input->cur) == '\\n') {\n+                ctxt->input->line++; ctxt->input->col = 1;\n+            } else ctxt->input->col++;\n+            ctxt->input->cur++;\n+            if (*ctxt->input->cur == 0)\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        }\n+        res++;\n@@ -625,3 +625,3 @@\n- *                                  *\n- *  The list of HTML elements and their properties      *\n- *                                  *\n+ *                                                                      *\n+ *      The list of HTML elements and their properties          *\n+ *                                                                      *\n@@ -640,1 +640,1 @@\n-    , subElements , impliedsubelt , Attributes, userdata\n+        , subElements , impliedsubelt , Attributes, userdata\n@@ -701,2 +701,2 @@\n-    \"href\", \"hreflang\", \"rel\", \"rev\", \"accesskey\", \"shape\", \"coords\",\n-    \"tabindex\", \"onfocus\", \"onblur\", NULL } ;\n+        \"href\", \"hreflang\", \"rel\", \"rev\", \"accesskey\", \"shape\", \"coords\",\n+        \"tabindex\", \"onfocus\", \"onblur\", NULL } ;\n@@ -713,2 +713,2 @@\n-        \"archive\", \"alt\", \"name\", \"height\", \"width\", \"align\",\n-        \"hspace\", \"vspace\", NULL } ;\n+                \"archive\", \"alt\", \"name\", \"height\", \"width\", \"align\",\n+                \"hspace\", \"vspace\", NULL } ;\n@@ -716,1 +716,1 @@\n-    \"tabindex\", \"accesskey\", \"onfocus\", \"onblur\", NULL } ;\n+        \"tabindex\", \"accesskey\", \"onfocus\", \"onblur\", NULL } ;\n@@ -718,1 +718,1 @@\n-    { \"id\", \"size\", \"color\", \"face\", NULL } ;\n+        { \"id\", \"size\", \"color\", \"face\", NULL } ;\n@@ -723,1 +723,1 @@\n-    \"link\", \"vlink\", \"alink\", NULL } ;\n+        \"link\", \"vlink\", \"alink\", NULL } ;\n@@ -725,1 +725,1 @@\n-    \"disabled\", \"tabindex\", \"accesskey\", \"onfocus\", \"onblur\", NULL } ;\n+        \"disabled\", \"tabindex\", \"accesskey\", \"onfocus\", \"onblur\", NULL } ;\n@@ -797,2 +797,2 @@\n-{ \"a\",      0, 0, 0, 0, 0, 0, 1, \"anchor \",\n-    DECL html_inline , NULL , DECL a_attrs , DECL target_attr, NULL\n+{ \"a\",          0, 0, 0, 0, 0, 0, 1, \"anchor \",\n+        DECL html_inline , NULL , DECL a_attrs , DECL target_attr, NULL\n@@ -800,2 +800,2 @@\n-{ \"abbr\",   0, 0, 0, 0, 0, 0, 1, \"abbreviated form\",\n-    DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n+{ \"abbr\",       0, 0, 0, 0, 0, 0, 1, \"abbreviated form\",\n+        DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n@@ -804,1 +804,1 @@\n-    DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n+        DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n@@ -807,1 +807,1 @@\n-    DECL inline_p  , NULL , DECL html_attrs, NULL, NULL\n+        DECL inline_p  , NULL , DECL html_attrs, NULL, NULL\n@@ -809,2 +809,2 @@\n-{ \"applet\", 0, 0, 0, 0, 1, 1, 2, \"java applet \",\n-    DECL flow_param , NULL , NULL , DECL applet_attrs, NULL\n+{ \"applet\",     0, 0, 0, 0, 1, 1, 2, \"java applet \",\n+        DECL flow_param , NULL , NULL , DECL applet_attrs, NULL\n@@ -812,2 +812,2 @@\n-{ \"area\",   0, 2, 2, 1, 0, 0, 0, \"client-side image map area \",\n-    EMPTY ,  NULL , DECL area_attrs , DECL target_attr, DECL alt_attr\n+{ \"area\",       0, 2, 2, 1, 0, 0, 0, \"client-side image map area \",\n+        EMPTY ,  NULL , DECL area_attrs , DECL target_attr, DECL alt_attr\n@@ -815,2 +815,2 @@\n-{ \"b\",      0, 3, 0, 0, 0, 0, 1, \"bold text style\",\n-    DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n+{ \"b\",          0, 3, 0, 0, 0, 0, 1, \"bold text style\",\n+        DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n@@ -818,2 +818,2 @@\n-{ \"base\",   0, 2, 2, 1, 0, 0, 0, \"document base uri \",\n-    EMPTY , NULL , NULL , DECL target_attr, DECL href_attrs\n+{ \"base\",       0, 2, 2, 1, 0, 0, 0, \"document base uri \",\n+        EMPTY , NULL , NULL , DECL target_attr, DECL href_attrs\n@@ -822,1 +822,1 @@\n-    EMPTY , NULL , NULL, DECL basefont_attrs, NULL\n+        EMPTY , NULL , NULL, DECL basefont_attrs, NULL\n@@ -824,2 +824,2 @@\n-{ \"bdo\",    0, 0, 0, 0, 0, 0, 1, \"i18n bidi over-ride \",\n-    DECL html_inline , NULL , DECL core_i18n_attrs, NULL, DECL dir_attr\n+{ \"bdo\",        0, 0, 0, 0, 0, 0, 1, \"i18n bidi over-ride \",\n+        DECL html_inline , NULL , DECL core_i18n_attrs, NULL, DECL dir_attr\n@@ -827,2 +827,2 @@\n-{ \"big\",    0, 3, 0, 0, 0, 0, 1, \"large text style\",\n-    DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n+{ \"big\",        0, 3, 0, 0, 0, 0, 1, \"large text style\",\n+        DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n@@ -831,1 +831,1 @@\n-    DECL html_flow , NULL , DECL quote_attrs , NULL, NULL\n+        DECL html_flow , NULL , DECL quote_attrs , NULL, NULL\n@@ -833,2 +833,2 @@\n-{ \"body\",   1, 1, 0, 0, 0, 0, 0, \"document body \",\n-    DECL body_contents , \"div\" , DECL body_attrs, DECL body_depr, NULL\n+{ \"body\",       1, 1, 0, 0, 0, 0, 0, \"document body \",\n+        DECL body_contents , \"div\" , DECL body_attrs, DECL body_depr, NULL\n@@ -836,2 +836,2 @@\n-{ \"br\",     0, 2, 2, 1, 0, 0, 1, \"forced line break \",\n-    EMPTY , NULL , DECL core_attrs, DECL clear_attrs , NULL\n+{ \"br\",         0, 2, 2, 1, 0, 0, 1, \"forced line break \",\n+        EMPTY , NULL , DECL core_attrs, DECL clear_attrs , NULL\n@@ -839,2 +839,2 @@\n-{ \"button\", 0, 0, 0, 0, 0, 0, 2, \"push button \",\n-    DECL html_flow MODIFIER , NULL , DECL button_attrs, NULL, NULL\n+{ \"button\",     0, 0, 0, 0, 0, 0, 2, \"push button \",\n+        DECL html_flow MODIFIER , NULL , DECL button_attrs, NULL, NULL\n@@ -843,1 +843,1 @@\n-    DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n+        DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n@@ -845,2 +845,2 @@\n-{ \"center\", 0, 3, 0, 0, 1, 1, 0, \"shorthand for div align=center \",\n-    DECL html_flow , NULL , NULL, DECL html_attrs, NULL\n+{ \"center\",     0, 3, 0, 0, 1, 1, 0, \"shorthand for div align=center \",\n+        DECL html_flow , NULL , NULL, DECL html_attrs, NULL\n@@ -848,2 +848,2 @@\n-{ \"cite\",   0, 0, 0, 0, 0, 0, 1, \"citation\",\n-    DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n+{ \"cite\",       0, 0, 0, 0, 0, 0, 1, \"citation\",\n+        DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n@@ -851,2 +851,2 @@\n-{ \"code\",   0, 0, 0, 0, 0, 0, 1, \"computer code fragment\",\n-    DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n+{ \"code\",       0, 0, 0, 0, 0, 0, 1, \"computer code fragment\",\n+        DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n@@ -854,2 +854,2 @@\n-{ \"col\",    0, 2, 2, 1, 0, 0, 0, \"table column \",\n-    EMPTY , NULL , DECL col_attrs , NULL, NULL\n+{ \"col\",        0, 2, 2, 1, 0, 0, 0, \"table column \",\n+        EMPTY , NULL , DECL col_attrs , NULL, NULL\n@@ -858,1 +858,1 @@\n-    DECL col_elt , \"col\" , DECL col_attrs , NULL, NULL\n+        DECL col_elt , \"col\" , DECL col_attrs , NULL, NULL\n@@ -860,2 +860,2 @@\n-{ \"dd\",     0, 1, 0, 0, 0, 0, 0, \"definition description \",\n-    DECL html_flow , NULL , DECL html_attrs, NULL, NULL\n+{ \"dd\",         0, 1, 0, 0, 0, 0, 0, \"definition description \",\n+        DECL html_flow , NULL , DECL html_attrs, NULL, NULL\n@@ -863,2 +863,2 @@\n-{ \"del\",    0, 0, 0, 0, 0, 0, 2, \"deleted text \",\n-    DECL html_flow , NULL , DECL edit_attrs , NULL, NULL\n+{ \"del\",        0, 0, 0, 0, 0, 0, 2, \"deleted text \",\n+        DECL html_flow , NULL , DECL edit_attrs , NULL, NULL\n@@ -866,2 +866,2 @@\n-{ \"dfn\",    0, 0, 0, 0, 0, 0, 1, \"instance definition\",\n-    DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n+{ \"dfn\",        0, 0, 0, 0, 0, 0, 1, \"instance definition\",\n+        DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n@@ -869,2 +869,2 @@\n-{ \"dir\",    0, 0, 0, 0, 1, 1, 0, \"directory list\",\n-    DECL blockli_elt, \"li\" , NULL, DECL compact_attrs, NULL\n+{ \"dir\",        0, 0, 0, 0, 1, 1, 0, \"directory list\",\n+        DECL blockli_elt, \"li\" , NULL, DECL compact_attrs, NULL\n@@ -872,2 +872,2 @@\n-{ \"div\",    0, 0, 0, 0, 0, 0, 0, \"generic language\/style container\",\n-    DECL html_flow, NULL, DECL html_attrs, DECL align_attr, NULL\n+{ \"div\",        0, 0, 0, 0, 0, 0, 0, \"generic language\/style container\",\n+        DECL html_flow, NULL, DECL html_attrs, DECL align_attr, NULL\n@@ -875,2 +875,2 @@\n-{ \"dl\",     0, 0, 0, 0, 0, 0, 0, \"definition list \",\n-    DECL dl_contents , \"dd\" , DECL html_attrs, DECL compact_attr, NULL\n+{ \"dl\",         0, 0, 0, 0, 0, 0, 0, \"definition list \",\n+        DECL dl_contents , \"dd\" , DECL html_attrs, DECL compact_attr, NULL\n@@ -878,2 +878,2 @@\n-{ \"dt\",     0, 1, 0, 0, 0, 0, 0, \"definition term \",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"dt\",         0, 1, 0, 0, 0, 0, 0, \"definition term \",\n+        DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n@@ -881,2 +881,2 @@\n-{ \"em\",     0, 3, 0, 0, 0, 0, 1, \"emphasis\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"em\",         0, 3, 0, 0, 0, 0, 1, \"emphasis\",\n+        DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n@@ -884,2 +884,2 @@\n-{ \"embed\",  0, 1, 0, 0, 1, 1, 1, \"generic embedded object \",\n-    EMPTY, NULL, DECL embed_attrs, NULL, NULL\n+{ \"embed\",      0, 1, 0, 0, 1, 1, 1, \"generic embedded object \",\n+        EMPTY, NULL, DECL embed_attrs, NULL, NULL\n@@ -888,1 +888,1 @@\n-    DECL fieldset_contents , NULL, DECL html_attrs, NULL, NULL\n+        DECL fieldset_contents , NULL, DECL html_attrs, NULL, NULL\n@@ -890,2 +890,2 @@\n-{ \"font\",   0, 3, 0, 0, 1, 1, 1, \"local change to font \",\n-    DECL html_inline, NULL, NULL, DECL font_attrs, NULL\n+{ \"font\",       0, 3, 0, 0, 1, 1, 1, \"local change to font \",\n+        DECL html_inline, NULL, NULL, DECL font_attrs, NULL\n@@ -893,2 +893,2 @@\n-{ \"form\",   0, 0, 0, 0, 0, 0, 0, \"interactive form \",\n-    DECL form_contents, \"fieldset\", DECL form_attrs , DECL target_attr, DECL action_attr\n+{ \"form\",       0, 0, 0, 0, 0, 0, 0, \"interactive form \",\n+        DECL form_contents, \"fieldset\", DECL form_attrs , DECL target_attr, DECL action_attr\n@@ -896,2 +896,2 @@\n-{ \"frame\",  0, 2, 2, 1, 0, 2, 0, \"subwindow \" ,\n-    EMPTY, NULL, NULL, DECL frame_attrs, NULL\n+{ \"frame\",      0, 2, 2, 1, 0, 2, 0, \"subwindow \" ,\n+        EMPTY, NULL, NULL, DECL frame_attrs, NULL\n@@ -900,1 +900,1 @@\n-    DECL frameset_contents, \"noframes\" , NULL , DECL frameset_attrs, NULL\n+        DECL frameset_contents, \"noframes\" , NULL , DECL frameset_attrs, NULL\n@@ -902,2 +902,2 @@\n-{ \"h1\",     0, 0, 0, 0, 0, 0, 0, \"heading \",\n-    DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n+{ \"h1\",         0, 0, 0, 0, 0, 0, 0, \"heading \",\n+        DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n@@ -905,2 +905,2 @@\n-{ \"h2\",     0, 0, 0, 0, 0, 0, 0, \"heading \",\n-    DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n+{ \"h2\",         0, 0, 0, 0, 0, 0, 0, \"heading \",\n+        DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n@@ -908,2 +908,2 @@\n-{ \"h3\",     0, 0, 0, 0, 0, 0, 0, \"heading \",\n-    DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n+{ \"h3\",         0, 0, 0, 0, 0, 0, 0, \"heading \",\n+        DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n@@ -911,2 +911,2 @@\n-{ \"h4\",     0, 0, 0, 0, 0, 0, 0, \"heading \",\n-    DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n+{ \"h4\",         0, 0, 0, 0, 0, 0, 0, \"heading \",\n+        DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n@@ -914,2 +914,2 @@\n-{ \"h5\",     0, 0, 0, 0, 0, 0, 0, \"heading \",\n-    DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n+{ \"h5\",         0, 0, 0, 0, 0, 0, 0, \"heading \",\n+        DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n@@ -917,2 +917,2 @@\n-{ \"h6\",     0, 0, 0, 0, 0, 0, 0, \"heading \",\n-    DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n+{ \"h6\",         0, 0, 0, 0, 0, 0, 0, \"heading \",\n+        DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n@@ -920,2 +920,2 @@\n-{ \"head\",   1, 1, 0, 0, 0, 0, 0, \"document head \",\n-    DECL head_contents, NULL, DECL head_attrs, NULL, NULL\n+{ \"head\",       1, 1, 0, 0, 0, 0, 0, \"document head \",\n+        DECL head_contents, NULL, DECL head_attrs, NULL, NULL\n@@ -923,2 +923,2 @@\n-{ \"hr\",     0, 2, 2, 1, 0, 0, 0, \"horizontal rule \" ,\n-    EMPTY, NULL, DECL html_attrs, DECL hr_depr, NULL\n+{ \"hr\",         0, 2, 2, 1, 0, 0, 0, \"horizontal rule \" ,\n+        EMPTY, NULL, DECL html_attrs, DECL hr_depr, NULL\n@@ -926,2 +926,2 @@\n-{ \"html\",   1, 1, 0, 0, 0, 0, 0, \"document root element \",\n-    DECL html_content , NULL , DECL i18n_attrs, DECL version_attr, NULL\n+{ \"html\",       1, 1, 0, 0, 0, 0, 0, \"document root element \",\n+        DECL html_content , NULL , DECL i18n_attrs, DECL version_attr, NULL\n@@ -929,2 +929,2 @@\n-{ \"i\",      0, 3, 0, 0, 0, 0, 1, \"italic text style\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"i\",          0, 3, 0, 0, 0, 0, 1, \"italic text style\",\n+        DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n@@ -932,2 +932,2 @@\n-{ \"iframe\", 0, 0, 0, 0, 0, 1, 2, \"inline subwindow \",\n-    DECL html_flow, NULL, NULL, DECL iframe_attrs, NULL\n+{ \"iframe\",     0, 0, 0, 0, 0, 1, 2, \"inline subwindow \",\n+        DECL html_flow, NULL, NULL, DECL iframe_attrs, NULL\n@@ -935,2 +935,2 @@\n-{ \"img\",    0, 2, 2, 1, 0, 0, 1, \"embedded image \",\n-    EMPTY, NULL, DECL img_attrs, DECL align_attr, DECL src_alt_attrs\n+{ \"img\",        0, 2, 2, 1, 0, 0, 1, \"embedded image \",\n+        EMPTY, NULL, DECL img_attrs, DECL align_attr, DECL src_alt_attrs\n@@ -938,2 +938,2 @@\n-{ \"input\",  0, 2, 2, 1, 0, 0, 1, \"form control \",\n-    EMPTY, NULL, DECL input_attrs , DECL align_attr, NULL\n+{ \"input\",      0, 2, 2, 1, 0, 0, 1, \"form control \",\n+        EMPTY, NULL, DECL input_attrs , DECL align_attr, NULL\n@@ -941,2 +941,2 @@\n-{ \"ins\",    0, 0, 0, 0, 0, 0, 2, \"inserted text\",\n-    DECL html_flow, NULL, DECL edit_attrs, NULL, NULL\n+{ \"ins\",        0, 0, 0, 0, 0, 0, 2, \"inserted text\",\n+        DECL html_flow, NULL, DECL edit_attrs, NULL, NULL\n@@ -945,1 +945,1 @@\n-    EMPTY, NULL, NULL, DECL prompt_attrs, NULL\n+        EMPTY, NULL, NULL, DECL prompt_attrs, NULL\n@@ -947,2 +947,2 @@\n-{ \"kbd\",    0, 0, 0, 0, 0, 0, 1, \"text to be entered by the user\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"kbd\",        0, 0, 0, 0, 0, 0, 1, \"text to be entered by the user\",\n+        DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n@@ -950,2 +950,2 @@\n-{ \"label\",  0, 0, 0, 0, 0, 0, 1, \"form field label text \",\n-    DECL html_inline MODIFIER, NULL, DECL label_attrs , NULL, NULL\n+{ \"label\",      0, 0, 0, 0, 0, 0, 1, \"form field label text \",\n+        DECL html_inline MODIFIER, NULL, DECL label_attrs , NULL, NULL\n@@ -953,2 +953,2 @@\n-{ \"legend\", 0, 0, 0, 0, 0, 0, 0, \"fieldset legend \",\n-    DECL html_inline, NULL, DECL legend_attrs , DECL align_attr, NULL\n+{ \"legend\",     0, 0, 0, 0, 0, 0, 0, \"fieldset legend \",\n+        DECL html_inline, NULL, DECL legend_attrs , DECL align_attr, NULL\n@@ -956,2 +956,2 @@\n-{ \"li\",     0, 1, 1, 0, 0, 0, 0, \"list item \",\n-    DECL html_flow, NULL, DECL html_attrs, NULL, NULL\n+{ \"li\",         0, 1, 1, 0, 0, 0, 0, \"list item \",\n+        DECL html_flow, NULL, DECL html_attrs, NULL, NULL\n@@ -959,2 +959,2 @@\n-{ \"link\",   0, 2, 2, 1, 0, 0, 0, \"a media-independent link \",\n-    EMPTY, NULL, DECL link_attrs, DECL target_attr, NULL\n+{ \"link\",       0, 2, 2, 1, 0, 0, 0, \"a media-independent link \",\n+        EMPTY, NULL, DECL link_attrs, DECL target_attr, NULL\n@@ -962,2 +962,2 @@\n-{ \"map\",    0, 0, 0, 0, 0, 0, 2, \"client-side image map \",\n-    DECL map_contents , NULL, DECL html_attrs , NULL, DECL name_attr\n+{ \"map\",        0, 0, 0, 0, 0, 0, 2, \"client-side image map \",\n+        DECL map_contents , NULL, DECL html_attrs , NULL, DECL name_attr\n@@ -965,2 +965,2 @@\n-{ \"menu\",   0, 0, 0, 0, 1, 1, 0, \"menu list \",\n-    DECL blockli_elt , NULL, NULL, DECL compact_attrs, NULL\n+{ \"menu\",       0, 0, 0, 0, 1, 1, 0, \"menu list \",\n+        DECL blockli_elt , NULL, NULL, DECL compact_attrs, NULL\n@@ -968,2 +968,2 @@\n-{ \"meta\",   0, 2, 2, 1, 0, 0, 0, \"generic metainformation \",\n-    EMPTY, NULL, DECL meta_attrs , NULL , DECL content_attr\n+{ \"meta\",       0, 2, 2, 1, 0, 0, 0, \"generic metainformation \",\n+        EMPTY, NULL, DECL meta_attrs , NULL , DECL content_attr\n@@ -972,1 +972,1 @@\n-    DECL noframes_content, \"body\" , DECL html_attrs, NULL, NULL\n+        DECL noframes_content, \"body\" , DECL html_attrs, NULL, NULL\n@@ -975,1 +975,1 @@\n-    DECL html_flow, \"div\", DECL html_attrs, NULL, NULL\n+        DECL html_flow, \"div\", DECL html_attrs, NULL, NULL\n@@ -977,2 +977,2 @@\n-{ \"object\", 0, 0, 0, 0, 0, 0, 2, \"generic embedded object \",\n-    DECL object_contents , \"div\" , DECL object_attrs, DECL object_depr, NULL\n+{ \"object\",     0, 0, 0, 0, 0, 0, 2, \"generic embedded object \",\n+        DECL object_contents , \"div\" , DECL object_attrs, DECL object_depr, NULL\n@@ -980,2 +980,2 @@\n-{ \"ol\",     0, 0, 0, 0, 0, 0, 0, \"ordered list \",\n-    DECL li_elt , \"li\" , DECL html_attrs, DECL ol_attrs, NULL\n+{ \"ol\",         0, 0, 0, 0, 0, 0, 0, \"ordered list \",\n+        DECL li_elt , \"li\" , DECL html_attrs, DECL ol_attrs, NULL\n@@ -984,1 +984,1 @@\n-    DECL option_elt , \"option\", DECL optgroup_attrs, NULL, DECL label_attr\n+        DECL option_elt , \"option\", DECL optgroup_attrs, NULL, DECL label_attr\n@@ -986,2 +986,2 @@\n-{ \"option\", 0, 1, 0, 0, 0, 0, 0, \"selectable choice \" ,\n-    DECL html_pcdata, NULL, DECL option_attrs, NULL, NULL\n+{ \"option\",     0, 1, 0, 0, 0, 0, 0, \"selectable choice \" ,\n+        DECL html_pcdata, NULL, DECL option_attrs, NULL, NULL\n@@ -989,2 +989,2 @@\n-{ \"p\",      0, 1, 0, 0, 0, 0, 0, \"paragraph \",\n-    DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n+{ \"p\",          0, 1, 0, 0, 0, 0, 0, \"paragraph \",\n+        DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n@@ -992,2 +992,2 @@\n-{ \"param\",  0, 2, 2, 1, 0, 0, 0, \"named property value \",\n-    EMPTY, NULL, DECL param_attrs, NULL, DECL name_attr\n+{ \"param\",      0, 2, 2, 1, 0, 0, 0, \"named property value \",\n+        EMPTY, NULL, DECL param_attrs, NULL, DECL name_attr\n@@ -995,2 +995,2 @@\n-{ \"pre\",    0, 0, 0, 0, 0, 0, 0, \"preformatted text \",\n-    DECL pre_content, NULL, DECL html_attrs, DECL width_attr, NULL\n+{ \"pre\",        0, 0, 0, 0, 0, 0, 0, \"preformatted text \",\n+        DECL pre_content, NULL, DECL html_attrs, DECL width_attr, NULL\n@@ -998,2 +998,2 @@\n-{ \"q\",      0, 0, 0, 0, 0, 0, 1, \"short inline quotation \",\n-    DECL html_inline, NULL, DECL quote_attrs, NULL, NULL\n+{ \"q\",          0, 0, 0, 0, 0, 0, 1, \"short inline quotation \",\n+        DECL html_inline, NULL, DECL quote_attrs, NULL, NULL\n@@ -1001,2 +1001,2 @@\n-{ \"s\",      0, 3, 0, 0, 1, 1, 1, \"strike-through text style\",\n-    DECL html_inline, NULL, NULL, DECL html_attrs, NULL\n+{ \"s\",          0, 3, 0, 0, 1, 1, 1, \"strike-through text style\",\n+        DECL html_inline, NULL, NULL, DECL html_attrs, NULL\n@@ -1004,2 +1004,2 @@\n-{ \"samp\",   0, 0, 0, 0, 0, 0, 1, \"sample program output, scripts, etc.\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"samp\",       0, 0, 0, 0, 0, 0, 1, \"sample program output, scripts, etc.\",\n+        DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n@@ -1007,2 +1007,2 @@\n-{ \"script\", 0, 0, 0, 0, 0, 0, 2, \"script statements \",\n-    DECL html_cdata, NULL, DECL script_attrs, DECL language_attr, DECL type_attr\n+{ \"script\",     0, 0, 0, 0, 0, 0, 2, \"script statements \",\n+        DECL html_cdata, NULL, DECL script_attrs, DECL language_attr, DECL type_attr\n@@ -1010,2 +1010,2 @@\n-{ \"select\", 0, 0, 0, 0, 0, 0, 1, \"option selector \",\n-    DECL select_content, NULL, DECL select_attrs, NULL, NULL\n+{ \"select\",     0, 0, 0, 0, 0, 0, 1, \"option selector \",\n+        DECL select_content, NULL, DECL select_attrs, NULL, NULL\n@@ -1013,2 +1013,2 @@\n-{ \"small\",  0, 3, 0, 0, 0, 0, 1, \"small text style\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"small\",      0, 3, 0, 0, 0, 0, 1, \"small text style\",\n+        DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n@@ -1016,2 +1016,2 @@\n-{ \"span\",   0, 0, 0, 0, 0, 0, 1, \"generic language\/style container \",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"span\",       0, 0, 0, 0, 0, 0, 1, \"generic language\/style container \",\n+        DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n@@ -1019,2 +1019,2 @@\n-{ \"strike\", 0, 3, 0, 0, 1, 1, 1, \"strike-through text\",\n-    DECL html_inline, NULL, NULL, DECL html_attrs, NULL\n+{ \"strike\",     0, 3, 0, 0, 1, 1, 1, \"strike-through text\",\n+        DECL html_inline, NULL, NULL, DECL html_attrs, NULL\n@@ -1022,2 +1022,2 @@\n-{ \"strong\", 0, 3, 0, 0, 0, 0, 1, \"strong emphasis\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"strong\",     0, 3, 0, 0, 0, 0, 1, \"strong emphasis\",\n+        DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n@@ -1025,2 +1025,2 @@\n-{ \"style\",  0, 0, 0, 0, 0, 0, 0, \"style info \",\n-    DECL html_cdata, NULL, DECL style_attrs, NULL, DECL type_attr\n+{ \"style\",      0, 0, 0, 0, 0, 0, 0, \"style info \",\n+        DECL html_cdata, NULL, DECL style_attrs, NULL, DECL type_attr\n@@ -1028,2 +1028,2 @@\n-{ \"sub\",    0, 3, 0, 0, 0, 0, 1, \"subscript\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"sub\",        0, 3, 0, 0, 0, 0, 1, \"subscript\",\n+        DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n@@ -1031,2 +1031,2 @@\n-{ \"sup\",    0, 3, 0, 0, 0, 0, 1, \"superscript \",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"sup\",        0, 3, 0, 0, 0, 0, 1, \"superscript \",\n+        DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n@@ -1034,2 +1034,2 @@\n-{ \"table\",  0, 0, 0, 0, 0, 0, 0, \"\",\n-    DECL table_contents , \"tr\" , DECL table_attrs , DECL table_depr, NULL\n+{ \"table\",      0, 0, 0, 0, 0, 0, 0, \"\",\n+        DECL table_contents , \"tr\" , DECL table_attrs , DECL table_depr, NULL\n@@ -1037,2 +1037,2 @@\n-{ \"tbody\",  1, 0, 0, 0, 0, 0, 0, \"table body \",\n-    DECL tr_elt , \"tr\" , DECL talign_attrs, NULL, NULL\n+{ \"tbody\",      1, 0, 0, 0, 0, 0, 0, \"table body \",\n+        DECL tr_elt , \"tr\" , DECL talign_attrs, NULL, NULL\n@@ -1040,2 +1040,2 @@\n-{ \"td\",     0, 0, 0, 0, 0, 0, 0, \"table data cell\",\n-    DECL html_flow, NULL, DECL th_td_attr, DECL th_td_depr, NULL\n+{ \"td\",         0, 0, 0, 0, 0, 0, 0, \"table data cell\",\n+        DECL html_flow, NULL, DECL th_td_attr, DECL th_td_depr, NULL\n@@ -1044,1 +1044,1 @@\n-    DECL html_pcdata, NULL, DECL textarea_attrs, NULL, DECL rows_cols_attr\n+        DECL html_pcdata, NULL, DECL textarea_attrs, NULL, DECL rows_cols_attr\n@@ -1046,2 +1046,2 @@\n-{ \"tfoot\",  0, 1, 0, 0, 0, 0, 0, \"table footer \",\n-    DECL tr_elt , \"tr\" , DECL talign_attrs, NULL, NULL\n+{ \"tfoot\",      0, 1, 0, 0, 0, 0, 0, \"table footer \",\n+        DECL tr_elt , \"tr\" , DECL talign_attrs, NULL, NULL\n@@ -1049,2 +1049,2 @@\n-{ \"th\",     0, 1, 0, 0, 0, 0, 0, \"table header cell\",\n-    DECL html_flow, NULL, DECL th_td_attr, DECL th_td_depr, NULL\n+{ \"th\",         0, 1, 0, 0, 0, 0, 0, \"table header cell\",\n+        DECL html_flow, NULL, DECL th_td_attr, DECL th_td_depr, NULL\n@@ -1052,2 +1052,2 @@\n-{ \"thead\",  0, 1, 0, 0, 0, 0, 0, \"table header \",\n-    DECL tr_elt , \"tr\" , DECL talign_attrs, NULL, NULL\n+{ \"thead\",      0, 1, 0, 0, 0, 0, 0, \"table header \",\n+        DECL tr_elt , \"tr\" , DECL talign_attrs, NULL, NULL\n@@ -1055,2 +1055,2 @@\n-{ \"title\",  0, 0, 0, 0, 0, 0, 0, \"document title \",\n-    DECL html_pcdata, NULL, DECL i18n_attrs, NULL, NULL\n+{ \"title\",      0, 0, 0, 0, 0, 0, 0, \"document title \",\n+        DECL html_pcdata, NULL, DECL i18n_attrs, NULL, NULL\n@@ -1058,2 +1058,2 @@\n-{ \"tr\",     0, 0, 0, 0, 0, 0, 0, \"table row \",\n-    DECL tr_contents , \"td\" , DECL talign_attrs, DECL bgcolor_attr, NULL\n+{ \"tr\",         0, 0, 0, 0, 0, 0, 0, \"table row \",\n+        DECL tr_contents , \"td\" , DECL talign_attrs, DECL bgcolor_attr, NULL\n@@ -1061,2 +1061,2 @@\n-{ \"tt\",     0, 3, 0, 0, 0, 0, 1, \"teletype or monospaced text style\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"tt\",         0, 3, 0, 0, 0, 0, 1, \"teletype or monospaced text style\",\n+        DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n@@ -1064,2 +1064,2 @@\n-{ \"u\",      0, 3, 0, 0, 1, 1, 1, \"underlined text style\",\n-    DECL html_inline, NULL, NULL, DECL html_attrs, NULL\n+{ \"u\",          0, 3, 0, 0, 1, 1, 1, \"underlined text style\",\n+        DECL html_inline, NULL, NULL, DECL html_attrs, NULL\n@@ -1067,2 +1067,2 @@\n-{ \"ul\",     0, 0, 0, 0, 0, 0, 0, \"unordered list \",\n-    DECL li_elt , \"li\" , DECL html_attrs, DECL ul_depr, NULL\n+{ \"ul\",         0, 0, 0, 0, 0, 0, 0, \"unordered list \",\n+        DECL li_elt , \"li\" , DECL html_attrs, DECL ul_depr, NULL\n@@ -1070,2 +1070,2 @@\n-{ \"var\",    0, 0, 0, 0, 0, 0, 1, \"instance of a variable or program argument\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"var\",        0, 0, 0, 0, 0, 0, 1, \"instance of a variable or program argument\",\n+        DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n@@ -1405,3 +1405,3 @@\n- *                                  *\n- *  functions to handle HTML specific data          *\n- *                                  *\n+ *                                                                      *\n+ *      functions to handle HTML specific data                  *\n+ *                                                                      *\n@@ -1456,2 +1456,2 @@\n-       (!xmlStrEqual((const xmlChar *)htmlEndPriority[i].name, name)))\n-    i++;\n+           (!xmlStrEqual((const xmlChar *)htmlEndPriority[i].name, name)))\n+        i++;\n@@ -1536,2 +1536,2 @@\n-                     \"Opening and ending tag mismatch: %s and %s\\n\",\n-             newtag, ctxt->name);\n+                         \"Opening and ending tag mismatch: %s and %s\\n\",\n+                         newtag, ctxt->name);\n@@ -1541,1 +1541,1 @@\n-    htmlnamePop(ctxt);\n+        htmlnamePop(ctxt);\n@@ -1561,1 +1561,1 @@\n-    htmlnamePop(ctxt);\n+        htmlnamePop(ctxt);\n@@ -1584,1 +1584,1 @@\n-    htmlnamePop(ctxt);\n+        htmlnamePop(ctxt);\n@@ -1596,1 +1596,1 @@\n-    htmlnamePop(ctxt);\n+        htmlnamePop(ctxt);\n@@ -1623,1 +1623,1 @@\n-    child = child->next;\n+        child = child->next;\n@@ -1646,2 +1646,2 @@\n-    if (htmlAutoCloseTag(doc, elem->name, child)) return(1);\n-    child = child->next;\n+        if (htmlAutoCloseTag(doc, elem->name, child)) return(1);\n+        child = child->next;\n@@ -1668,1 +1668,1 @@\n-    return;\n+        return;\n@@ -1670,1 +1670,1 @@\n-    return;\n+        return;\n@@ -1672,3 +1672,3 @@\n-    htmlnamePush(ctxt, BAD_CAST\"html\");\n-    if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL))\n-        ctxt->sax->startElement(ctxt->userData, BAD_CAST\"html\", NULL);\n+        htmlnamePush(ctxt, BAD_CAST\"html\");\n+        if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL))\n+            ctxt->sax->startElement(ctxt->userData, BAD_CAST\"html\", NULL);\n@@ -1680,5 +1680,5 @@\n-     (xmlStrEqual(newtag, BAD_CAST\"style\")) ||\n-     (xmlStrEqual(newtag, BAD_CAST\"meta\")) ||\n-     (xmlStrEqual(newtag, BAD_CAST\"link\")) ||\n-     (xmlStrEqual(newtag, BAD_CAST\"title\")) ||\n-     (xmlStrEqual(newtag, BAD_CAST\"base\")))) {\n+         (xmlStrEqual(newtag, BAD_CAST\"style\")) ||\n+         (xmlStrEqual(newtag, BAD_CAST\"meta\")) ||\n+         (xmlStrEqual(newtag, BAD_CAST\"link\")) ||\n+         (xmlStrEqual(newtag, BAD_CAST\"title\")) ||\n+         (xmlStrEqual(newtag, BAD_CAST\"base\")))) {\n@@ -1697,2 +1697,2 @@\n-           (!xmlStrEqual(newtag, BAD_CAST\"frame\")) &&\n-           (!xmlStrEqual(newtag, BAD_CAST\"frameset\"))) {\n+               (!xmlStrEqual(newtag, BAD_CAST\"frame\")) &&\n+               (!xmlStrEqual(newtag, BAD_CAST\"frameset\"))) {\n@@ -1703,6 +1703,7 @@\n-    for (i = 0;i < ctxt->nameNr;i++) {\n-        if (xmlStrEqual(ctxt->nameTab[i], BAD_CAST\"body\")) {\n-        return;\n-        }\n-        if (xmlStrEqual(ctxt->nameTab[i], BAD_CAST\"head\")) {\n-        return;\n+        for (i = 0;i < ctxt->nameNr;i++) {\n+            if (xmlStrEqual(ctxt->nameTab[i], BAD_CAST\"body\")) {\n+                return;\n+            }\n+            if (xmlStrEqual(ctxt->nameTab[i], BAD_CAST\"head\")) {\n+                return;\n+            }\n@@ -1710,1 +1711,0 @@\n-    }\n@@ -1712,3 +1712,3 @@\n-    htmlnamePush(ctxt, BAD_CAST\"body\");\n-    if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL))\n-        ctxt->sax->startElement(ctxt->userData, BAD_CAST\"body\", NULL);\n+        htmlnamePush(ctxt, BAD_CAST\"body\");\n+        if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL))\n+            ctxt->sax->startElement(ctxt->userData, BAD_CAST\"body\", NULL);\n@@ -1735,1 +1735,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1738,11 +1738,0 @@\n-    htmlAutoClose(ctxt, BAD_CAST\"p\");\n-    htmlCheckImplied(ctxt, BAD_CAST\"p\");\n-    htmlnamePush(ctxt, BAD_CAST\"p\");\n-    if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL))\n-        ctxt->sax->startElement(ctxt->userData, BAD_CAST\"p\", NULL);\n-    return(1);\n-    }\n-    if (!htmlOmittedDefaultValue)\n-    return(0);\n-    for (i = 0; htmlNoContentElements[i] != NULL; i++) {\n-    if (xmlStrEqual(tag, BAD_CAST htmlNoContentElements[i])) {\n@@ -1753,1 +1742,1 @@\n-        ctxt->sax->startElement(ctxt->userData, BAD_CAST\"p\", NULL);\n+            ctxt->sax->startElement(ctxt->userData, BAD_CAST\"p\", NULL);\n@@ -1756,0 +1745,11 @@\n+    if (!htmlOmittedDefaultValue)\n+        return(0);\n+    for (i = 0; htmlNoContentElements[i] != NULL; i++) {\n+        if (xmlStrEqual(tag, BAD_CAST htmlNoContentElements[i])) {\n+            htmlAutoClose(ctxt, BAD_CAST\"p\");\n+            htmlCheckImplied(ctxt, BAD_CAST\"p\");\n+            htmlnamePush(ctxt, BAD_CAST\"p\");\n+            if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL))\n+                ctxt->sax->startElement(ctxt->userData, BAD_CAST\"p\", NULL);\n+            return(1);\n+        }\n@@ -1780,4 +1780,4 @@\n-     i < sizeof(htmlScriptAttributes)\/sizeof(htmlScriptAttributes[0]);\n-     i++) {\n-    if (xmlStrEqual(name, (const xmlChar *) htmlScriptAttributes[i]))\n-        return(1);\n+         i < sizeof(htmlScriptAttributes)\/sizeof(htmlScriptAttributes[0]);\n+         i++) {\n+        if (xmlStrEqual(name, (const xmlChar *) htmlScriptAttributes[i]))\n+            return(1);\n@@ -1789,3 +1789,3 @@\n- *                                  *\n- *  The list of HTML predefined entities            *\n- *                                  *\n+ *                                                                      *\n+ *      The list of HTML predefined entities                    *\n+ *                                                                      *\n@@ -2079,3 +2079,3 @@\n- *                                  *\n- *      Commodity functions to handle entities          *\n- *                                  *\n+ *                                                                      *\n+ *              Commodity functions to handle entities                  *\n+ *                                                                      *\n@@ -2087,3 +2087,3 @@\n-#define growBuffer(buffer) {                        \\\n-    xmlChar *tmp;                           \\\n-    buffer##_size *= 2;                         \\\n+#define growBuffer(buffer) {                                            \\\n+    xmlChar *tmp;                                                       \\\n+    buffer##_size *= 2;                                                 \\\n@@ -2091,6 +2091,6 @@\n-    if (tmp == NULL) {                      \\\n-    htmlErrMemory(ctxt, \"growing buffer\\n\");            \\\n-    xmlFree(buffer);                        \\\n-    return(NULL);                           \\\n-    }                                   \\\n-    buffer = tmp;                           \\\n+    if (tmp == NULL) {                                          \\\n+        htmlErrMemory(ctxt, \"growing buffer\\n\");                        \\\n+        xmlFree(buffer);                                                \\\n+        return(NULL);                                                   \\\n+    }                                                                   \\\n+    buffer = tmp;                                                       \\\n@@ -2117,1 +2117,1 @@\n-    }\n+        }\n@@ -2139,2 +2139,2 @@\n-        if (html40EntitiesTable[i].value > value)\n-        break;\n+            if (html40EntitiesTable[i].value > value)\n+                break;\n@@ -2142,1 +2142,1 @@\n-    }\n+        }\n@@ -2176,5 +2176,5 @@\n-     * initialization nothing to do\n-     *\/\n-    *outlen = 0;\n-    *inlen = 0;\n-    return(0);\n+         * initialization nothing to do\n+         *\/\n+        *outlen = 0;\n+        *inlen = 0;\n+        return(0);\n@@ -2185,7 +2185,7 @@\n-    d = *in++;\n-    if      (d < 0x80)  { c= d; trailing= 0; }\n-    else if (d < 0xC0) {\n-        \/* trailing byte in leading position *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(-2);\n+        d = *in++;\n+        if      (d < 0x80)  { c= d; trailing= 0; }\n+        else if (d < 0xC0) {\n+            \/* trailing byte in leading position *\/\n+            *outlen = out - outstart;\n+            *inlen = processed - instart;\n+            return(-2);\n@@ -2195,6 +2195,6 @@\n-    else {\n-        \/* no chance for this in Ascii *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(-2);\n-    }\n+        else {\n+            \/* no chance for this in Ascii *\/\n+            *outlen = out - outstart;\n+            *inlen = processed - instart;\n+            return(-2);\n+        }\n@@ -2202,3 +2202,3 @@\n-    if (inend - in < trailing) {\n-        break;\n-    }\n+        if (inend - in < trailing) {\n+            break;\n+        }\n@@ -2206,6 +2206,6 @@\n-    for ( ; trailing; trailing--) {\n-        if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))\n-        break;\n-        c <<= 6;\n-        c |= d & 0x3F;\n-    }\n+        for ( ; trailing; trailing--) {\n+            if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))\n+                break;\n+            c <<= 6;\n+            c |= d & 0x3F;\n+        }\n@@ -2213,10 +2213,10 @@\n-    \/* assertion: c is a single UTF-4 value *\/\n-    if (c < 0x80) {\n-        if (out + 1 >= outend)\n-        break;\n-        *out++ = c;\n-    } else {\n-        int len;\n-        const htmlEntityDesc * ent;\n-        const char *cp;\n-        char nbuf[16];\n+        \/* assertion: c is a single UTF-4 value *\/\n+        if (c < 0x80) {\n+            if (out + 1 >= outend)\n+                break;\n+            *out++ = c;\n+        } else {\n+            int len;\n+            const htmlEntityDesc * ent;\n+            const char *cp;\n+            char nbuf[16];\n@@ -2224,3 +2224,3 @@\n-        \/*\n-         * Try to lookup a predefined HTML entity for it\n-         *\/\n+            \/*\n+             * Try to lookup a predefined HTML entity for it\n+             *\/\n@@ -2228,4 +2228,14 @@\n-        ent = htmlEntityValueLookup(c);\n-        if (ent == NULL) {\n-          snprintf(nbuf, sizeof(nbuf), \"#%u\", c);\n-          cp = nbuf;\n+            ent = htmlEntityValueLookup(c);\n+            if (ent == NULL) {\n+              snprintf(nbuf, sizeof(nbuf), \"#%u\", c);\n+              cp = nbuf;\n+            }\n+            else\n+              cp = ent->name;\n+            len = strlen(cp);\n+            if (out + 2 + len >= outend)\n+                break;\n+            *out++ = '&';\n+            memcpy(out, cp, len);\n+            out += len;\n+            *out++ = ';';\n@@ -2233,11 +2243,1 @@\n-        else\n-          cp = ent->name;\n-        len = strlen(cp);\n-        if (out + 2 + len >= outend)\n-        break;\n-        *out++ = '&';\n-        memcpy(out, cp, len);\n-        out += len;\n-        *out++ = ';';\n-    }\n-    processed = in;\n+        processed = in;\n@@ -2268,1 +2268,1 @@\n-           const unsigned char* in, int *inlen, int quoteChar) {\n+                   const unsigned char* in, int *inlen, int quoteChar) {\n@@ -2282,7 +2282,7 @@\n-    d = *in++;\n-    if      (d < 0x80)  { c= d; trailing= 0; }\n-    else if (d < 0xC0) {\n-        \/* trailing byte in leading position *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(-2);\n+        d = *in++;\n+        if      (d < 0x80)  { c= d; trailing= 0; }\n+        else if (d < 0xC0) {\n+            \/* trailing byte in leading position *\/\n+            *outlen = out - outstart;\n+            *inlen = processed - instart;\n+            return(-2);\n@@ -2292,6 +2292,6 @@\n-    else {\n-        \/* no chance for this in Ascii *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(-2);\n-    }\n+        else {\n+            \/* no chance for this in Ascii *\/\n+            *outlen = out - outstart;\n+            *inlen = processed - instart;\n+            return(-2);\n+        }\n@@ -2299,2 +2299,2 @@\n-    if (inend - in < trailing)\n-        break;\n+        if (inend - in < trailing)\n+            break;\n@@ -2302,5 +2302,8 @@\n-    while (trailing--) {\n-        if (((d= *in++) & 0xC0) != 0x80) {\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(-2);\n+        while (trailing--) {\n+            if (((d= *in++) & 0xC0) != 0x80) {\n+                *outlen = out - outstart;\n+                *inlen = processed - instart;\n+                return(-2);\n+            }\n+            c <<= 6;\n+            c |= d & 0x3F;\n@@ -2308,3 +2311,0 @@\n-        c <<= 6;\n-        c |= d & 0x3F;\n-    }\n@@ -2312,11 +2312,11 @@\n-    \/* assertion: c is a single UTF-4 value *\/\n-    if ((c < 0x80) && (c != (unsigned int) quoteChar) &&\n-        (c != '&') && (c != '<') && (c != '>')) {\n-        if (out >= outend)\n-        break;\n-        *out++ = c;\n-    } else {\n-        const htmlEntityDesc * ent;\n-        const char *cp;\n-        char nbuf[16];\n-        int len;\n+        \/* assertion: c is a single UTF-4 value *\/\n+        if ((c < 0x80) && (c != (unsigned int) quoteChar) &&\n+            (c != '&') && (c != '<') && (c != '>')) {\n+            if (out >= outend)\n+                break;\n+            *out++ = c;\n+        } else {\n+            const htmlEntityDesc * ent;\n+            const char *cp;\n+            char nbuf[16];\n+            int len;\n@@ -2324,7 +2324,17 @@\n-        \/*\n-         * Try to lookup a predefined HTML entity for it\n-         *\/\n-        ent = htmlEntityValueLookup(c);\n-        if (ent == NULL) {\n-        snprintf(nbuf, sizeof(nbuf), \"#%u\", c);\n-        cp = nbuf;\n+            \/*\n+             * Try to lookup a predefined HTML entity for it\n+             *\/\n+            ent = htmlEntityValueLookup(c);\n+            if (ent == NULL) {\n+                snprintf(nbuf, sizeof(nbuf), \"#%u\", c);\n+                cp = nbuf;\n+            }\n+            else\n+                cp = ent->name;\n+            len = strlen(cp);\n+            if (out + 2 + len > outend)\n+                break;\n+            *out++ = '&';\n+            memcpy(out, cp, len);\n+            out += len;\n+            *out++ = ';';\n@@ -2332,11 +2342,1 @@\n-        else\n-        cp = ent->name;\n-        len = strlen(cp);\n-        if (out + 2 + len > outend)\n-        break;\n-        *out++ = '&';\n-        memcpy(out, cp, len);\n-        out += len;\n-        *out++ = ';';\n-    }\n-    processed = in;\n+        processed = in;\n@@ -2350,3 +2350,3 @@\n- *                                  *\n- *      Commodity functions to handle streams           *\n- *                                  *\n+ *                                                                      *\n+ *              Commodity functions to handle streams                   *\n+ *                                                                      *\n@@ -2370,1 +2370,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2391,3 +2391,3 @@\n- *                                  *\n- *      Commodity functions, cleanup needed ?           *\n- *                                  *\n+ *                                                                      *\n+ *              Commodity functions, cleanup needed ?                   *\n+ *                                                                      *\n@@ -2433,1 +2433,1 @@\n-    return(1);\n+        return(1);\n@@ -2435,1 +2435,1 @@\n-    return(1);\n+        return(1);\n@@ -2437,1 +2437,1 @@\n-    return(1);\n+        return(1);\n@@ -2452,1 +2452,1 @@\n-    lastChild = lastChild->prev;\n+        lastChild = lastChild->prev;\n@@ -2456,5 +2456,6 @@\n-    \/* keep ws in constructs like ...<b> <\/b>...\n-       for all tags \"b\" allowing PCDATA *\/\n-    for ( i = 0; i < sizeof(allowPCData)\/sizeof(allowPCData[0]); i++ ) {\n-        if ( xmlStrEqual(ctxt->name, BAD_CAST allowPCData[i]) ) {\n-        return(0);\n+        \/* keep ws in constructs like ...<b> <\/b>...\n+           for all tags \"b\" allowing PCDATA *\/\n+        for ( i = 0; i < sizeof(allowPCData)\/sizeof(allowPCData[0]); i++ ) {\n+            if ( xmlStrEqual(ctxt->name, BAD_CAST allowPCData[i]) ) {\n+                return(0);\n+            }\n@@ -2462,1 +2463,0 @@\n-    }\n@@ -2466,5 +2466,6 @@\n-    \/* keep ws in constructs like <p><b>xy<\/b> <i>z<\/i><p>\n-       for all tags \"p\" allowing PCDATA *\/\n-    for ( i = 0; i < sizeof(allowPCData)\/sizeof(allowPCData[0]); i++ ) {\n-        if ( xmlStrEqual(lastChild->name, BAD_CAST allowPCData[i]) ) {\n-        return(0);\n+        \/* keep ws in constructs like <p><b>xy<\/b> <i>z<\/i><p>\n+           for all tags \"p\" allowing PCDATA *\/\n+        for ( i = 0; i < sizeof(allowPCData)\/sizeof(allowPCData[0]); i++ ) {\n+            if ( xmlStrEqual(lastChild->name, BAD_CAST allowPCData[i]) ) {\n+                return(0);\n+            }\n@@ -2473,1 +2474,0 @@\n-    }\n@@ -2496,2 +2496,2 @@\n-    htmlErrMemory(NULL, \"HTML document creation failed\\n\");\n-    return(NULL);\n+        htmlErrMemory(NULL, \"HTML document creation failed\\n\");\n+        return(NULL);\n@@ -2518,2 +2518,4 @@\n-    (URI != NULL))\n-    xmlCreateIntSubset(cur, BAD_CAST \"html\", ExternalID, URI);\n+        (URI != NULL))\n+        xmlCreateIntSubset(cur, BAD_CAST \"html\", ExternalID, URI);\n+    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -2535,3 +2537,3 @@\n-    return(htmlNewDocNoDtD(\n-            BAD_CAST \"http:\/\/www.w3.org\/TR\/REC-html40\/loose.dtd\",\n-            BAD_CAST \"-\/\/W3C\/\/DTD HTML 4.0 Transitional\/\/EN\"));\n+        return(htmlNewDocNoDtD(\n+                    BAD_CAST \"http:\/\/www.w3.org\/TR\/REC-html40\/loose.dtd\",\n+                    BAD_CAST \"-\/\/W3C\/\/DTD HTML 4.0 Transitional\/\/EN\"));\n@@ -2544,4 +2546,4 @@\n- *                                  *\n- *          The parser itself               *\n- *  Relates to http:\/\/www.w3.org\/TR\/html40              *\n- *                                  *\n+ *                                                                      *\n+ *                      The parser itself                               *\n+ *      Relates to http:\/\/www.w3.org\/TR\/html40                          *\n+ *                                                                      *\n@@ -2551,3 +2553,3 @@\n- *                                  *\n- *          The parser itself               *\n- *                                  *\n+ *                                                                      *\n+ *                      The parser itself                               *\n+ *                                                                      *\n@@ -2578,1 +2580,1 @@\n-       (CUR == ':') || (CUR == '-') || (CUR == '_') ||\n+           (CUR == ':') || (CUR == '-') || (CUR == '_') ||\n@@ -2580,1 +2582,1 @@\n-    if ((CUR >= 'A') && (CUR <= 'Z')) loc[i] = CUR + 0x20;\n+        if ((CUR >= 'A') && (CUR <= 'Z')) loc[i] = CUR + 0x20;\n@@ -2582,1 +2584,1 @@\n-    i++;\n+        i++;\n@@ -2584,1 +2586,1 @@\n-    NEXT;\n+        NEXT;\n@@ -2612,2 +2614,2 @@\n-       (NXT(1+i) == ':') || (NXT(1+i) == '-') || (NXT(1+i) == '_'))) {\n-    if ((NXT(1+i) >= 'A') && (NXT(1+i) <= 'Z')) loc[i] = NXT(1+i) + 0x20;\n+           (NXT(1+i) == ':') || (NXT(1+i) == '-') || (NXT(1+i) == '_'))) {\n+        if ((NXT(1+i) >= 'A') && (NXT(1+i) <= 'Z')) loc[i] = NXT(1+i) + 0x20;\n@@ -2615,1 +2617,1 @@\n-    i++;\n+        i++;\n@@ -2644,8 +2646,2 @@\n-    ((*in >= 0x41) && (*in <= 0x5A)) ||\n-    (*in == '_') || (*in == ':')) {\n-    in++;\n-    while (((*in >= 0x61) && (*in <= 0x7A)) ||\n-           ((*in >= 0x41) && (*in <= 0x5A)) ||\n-           ((*in >= 0x30) && (*in <= 0x39)) ||\n-           (*in == '_') || (*in == '-') ||\n-           (*in == ':') || (*in == '.'))\n+        ((*in >= 0x41) && (*in <= 0x5A)) ||\n+        (*in == '_') || (*in == ':')) {\n@@ -2653,11 +2649,17 @@\n-\n-    if (in == ctxt->input->end)\n-        return(NULL);\n-\n-    if ((*in > 0) && (*in < 0x80)) {\n-        count = in - ctxt->input->cur;\n-        ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);\n-        ctxt->input->cur = in;\n-        ctxt->input->col += count;\n-        return(ret);\n-    }\n+        while (((*in >= 0x61) && (*in <= 0x7A)) ||\n+               ((*in >= 0x41) && (*in <= 0x5A)) ||\n+               ((*in >= 0x30) && (*in <= 0x39)) ||\n+               (*in == '_') || (*in == '-') ||\n+               (*in == ':') || (*in == '.'))\n+            in++;\n+\n+        if (in == ctxt->input->end)\n+            return(NULL);\n+\n+        if ((*in > 0) && (*in < 0x80)) {\n+            count = in - ctxt->input->cur;\n+            ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);\n+            ctxt->input->cur = in;\n+            ctxt->input->col += count;\n+            return(ret);\n+        }\n@@ -2681,1 +2683,1 @@\n-    (!IS_LETTER(c) && (c != '_') &&\n+        (!IS_LETTER(c) && (c != '_') &&\n@@ -2683,1 +2685,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2687,1 +2689,1 @@\n-       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n+           ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n@@ -2689,17 +2691,17 @@\n-        (c == '_') || (c == ':') ||\n-        (IS_COMBINING(c)) ||\n-        (IS_EXTENDER(c)))) {\n-    if (count++ > 100) {\n-        count = 0;\n-        GROW;\n-    }\n-    len += l;\n-    NEXTL(l);\n-    c = CUR_CHAR(l);\n-    if (ctxt->input->base != base) {\n-        \/*\n-         * We changed encoding from an unknown encoding\n-         * Input buffer changed location, so we better start again\n-         *\/\n-        return(htmlParseNameComplex(ctxt));\n-    }\n+            (c == '_') || (c == ':') ||\n+            (IS_COMBINING(c)) ||\n+            (IS_EXTENDER(c)))) {\n+        if (count++ > 100) {\n+            count = 0;\n+            GROW;\n+        }\n+        len += l;\n+        NEXTL(l);\n+        c = CUR_CHAR(l);\n+        if (ctxt->input->base != base) {\n+            \/*\n+             * We changed encoding from an unknown encoding\n+             * Input buffer changed location, so we better start again\n+             *\/\n+            return(htmlParseNameComplex(ctxt));\n+        }\n@@ -2710,1 +2712,1 @@\n-    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n@@ -2745,2 +2747,2 @@\n-    htmlErrMemory(ctxt, \"buffer allocation failed\\n\");\n-    return(NULL);\n+        htmlErrMemory(ctxt, \"buffer allocation failed\\n\");\n+        return(NULL);\n@@ -2754,2 +2756,2 @@\n-    if ((stop == 0) && (CUR == '>')) break;\n-    if ((stop == 0) && (IS_BLANK_CH(CUR))) break;\n+        if ((stop == 0) && (CUR == '>')) break;\n+        if ((stop == 0) && (IS_BLANK_CH(CUR))) break;\n@@ -2757,3 +2759,17 @@\n-        if (NXT(1) == '#') {\n-        unsigned int c;\n-        int bits;\n+            if (NXT(1) == '#') {\n+                unsigned int c;\n+                int bits;\n+\n+                c = htmlParseCharRef(ctxt);\n+                if      (c <    0x80)\n+                        { *out++  = c;                bits= -6; }\n+                else if (c <   0x800)\n+                        { *out++  =((c >>  6) & 0x1F) | 0xC0;  bits=  0; }\n+                else if (c < 0x10000)\n+                        { *out++  =((c >> 12) & 0x0F) | 0xE0;  bits=  6; }\n+                else\n+                        { *out++  =((c >> 18) & 0x07) | 0xF0;  bits= 12; }\n+\n+                for ( ; bits >= 0; bits-= 6) {\n+                    *out++  = ((c >> bits) & 0x3F) | 0x80;\n+                }\n@@ -2761,9 +2777,2 @@\n-        c = htmlParseCharRef(ctxt);\n-        if      (c <    0x80)\n-                { *out++  = c;                bits= -6; }\n-        else if (c <   0x800)\n-                { *out++  =((c >>  6) & 0x1F) | 0xC0;  bits=  0; }\n-        else if (c < 0x10000)\n-                { *out++  =((c >> 12) & 0x0F) | 0xE0;  bits=  6; }\n-        else\n-                { *out++  =((c >> 18) & 0x07) | 0xF0;  bits= 12; }\n+                if (out - buffer > buffer_size - 100) {\n+                        int indx = out - buffer;\n@@ -2771,3 +2780,28 @@\n-        for ( ; bits >= 0; bits-= 6) {\n-            *out++  = ((c >> bits) & 0x3F) | 0x80;\n-        }\n+                        growBuffer(buffer);\n+                        out = &buffer[indx];\n+                }\n+            } else {\n+                ent = htmlParseEntityRef(ctxt, &name);\n+                if (name == NULL) {\n+                    *out++ = '&';\n+                    if (out - buffer > buffer_size - 100) {\n+                        int indx = out - buffer;\n+\n+                        growBuffer(buffer);\n+                        out = &buffer[indx];\n+                    }\n+                } else if (ent == NULL) {\n+                    *out++ = '&';\n+                    cur = name;\n+                    while (*cur != 0) {\n+                        if (out - buffer > buffer_size - 100) {\n+                            int indx = out - buffer;\n+\n+                            growBuffer(buffer);\n+                            out = &buffer[indx];\n+                        }\n+                        *out++ = *cur++;\n+                    }\n+                } else {\n+                    unsigned int c;\n+                    int bits;\n@@ -2775,2 +2809,2 @@\n-        if (out - buffer > buffer_size - 100) {\n-            int indx = out - buffer;\n+                    if (out - buffer > buffer_size - 100) {\n+                        int indx = out - buffer;\n@@ -2778,3 +2812,18 @@\n-            growBuffer(buffer);\n-            out = &buffer[indx];\n-        }\n+                        growBuffer(buffer);\n+                        out = &buffer[indx];\n+                    }\n+                    c = ent->value;\n+                    if      (c <    0x80)\n+                        { *out++  = c;                bits= -6; }\n+                    else if (c <   0x800)\n+                        { *out++  =((c >>  6) & 0x1F) | 0xC0;  bits=  0; }\n+                    else if (c < 0x10000)\n+                        { *out++  =((c >> 12) & 0x0F) | 0xE0;  bits=  6; }\n+                    else\n+                        { *out++  =((c >> 18) & 0x07) | 0xF0;  bits= 12; }\n+\n+                    for ( ; bits >= 0; bits-= 6) {\n+                        *out++  = ((c >> bits) & 0x3F) | 0x80;\n+                    }\n+                }\n+            }\n@@ -2782,5 +2831,2 @@\n-        ent = htmlParseEntityRef(ctxt, &name);\n-        if (name == NULL) {\n-            *out++ = '&';\n-            if (out - buffer > buffer_size - 100) {\n-            int indx = out - buffer;\n+            unsigned int c;\n+            int bits, l;\n@@ -2788,7 +2834,0 @@\n-            growBuffer(buffer);\n-            out = &buffer[indx];\n-            }\n-        } else if (ent == NULL) {\n-            *out++ = '&';\n-            cur = name;\n-            while (*cur != 0) {\n@@ -2801,13 +2840,1 @@\n-            *out++ = *cur++;\n-            }\n-        } else {\n-            unsigned int c;\n-            int bits;\n-\n-            if (out - buffer > buffer_size - 100) {\n-            int indx = out - buffer;\n-\n-            growBuffer(buffer);\n-            out = &buffer[indx];\n-            }\n-            c = ent->value;\n+            c = CUR_CHAR(l);\n@@ -2815,1 +2842,1 @@\n-            { *out++  = c;                bits= -6; }\n+                    { *out++  = c;                bits= -6; }\n@@ -2817,1 +2844,1 @@\n-            { *out++  =((c >>  6) & 0x1F) | 0xC0;  bits=  0; }\n+                    { *out++  =((c >>  6) & 0x1F) | 0xC0;  bits=  0; }\n@@ -2819,1 +2846,1 @@\n-            { *out++  =((c >> 12) & 0x0F) | 0xE0;  bits=  6; }\n+                    { *out++  =((c >> 12) & 0x0F) | 0xE0;  bits=  6; }\n@@ -2821,1 +2848,1 @@\n-            { *out++  =((c >> 18) & 0x07) | 0xF0;  bits= 12; }\n+                    { *out++  =((c >> 18) & 0x07) | 0xF0;  bits= 12; }\n@@ -2824,1 +2851,1 @@\n-            *out++  = ((c >> bits) & 0x3F) | 0x80;\n+                *out++  = ((c >> bits) & 0x3F) | 0x80;\n@@ -2826,0 +2853,1 @@\n+            NEXT;\n@@ -2827,26 +2855,0 @@\n-        }\n-    } else {\n-        unsigned int c;\n-        int bits, l;\n-\n-        if (out - buffer > buffer_size - 100) {\n-        int indx = out - buffer;\n-\n-        growBuffer(buffer);\n-        out = &buffer[indx];\n-        }\n-        c = CUR_CHAR(l);\n-        if      (c <    0x80)\n-            { *out++  = c;                bits= -6; }\n-        else if (c <   0x800)\n-            { *out++  =((c >>  6) & 0x1F) | 0xC0;  bits=  0; }\n-        else if (c < 0x10000)\n-            { *out++  =((c >> 12) & 0x0F) | 0xE0;  bits=  6; }\n-        else\n-            { *out++  =((c >> 18) & 0x07) | 0xF0;  bits= 12; }\n-\n-        for ( ; bits >= 0; bits-= 6) {\n-        *out++  = ((c >> bits) & 0x3F) | 0x80;\n-        }\n-        NEXT;\n-    }\n@@ -2881,15 +2883,3 @@\n-    if (name == NULL) {\n-        htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n-                     \"htmlParseEntityRef: no name\\n\", NULL, NULL);\n-    } else {\n-        GROW;\n-        if (CUR == ';') {\n-            if (str != NULL)\n-            *str = name;\n-\n-        \/*\n-         * Lookup the entity in the table.\n-         *\/\n-        ent = htmlEntityLookup(name);\n-        if (ent != NULL) \/* OK that's ugly !!! *\/\n-            NEXT;\n+        if (name == NULL) {\n+            htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n+                         \"htmlParseEntityRef: no name\\n\", NULL, NULL);\n@@ -2897,5 +2887,18 @@\n-        htmlParseErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING,\n-                     \"htmlParseEntityRef: expecting ';'\\n\",\n-                 NULL, NULL);\n-            if (str != NULL)\n-            *str = name;\n+            GROW;\n+            if (CUR == ';') {\n+                if (str != NULL)\n+                    *str = name;\n+\n+                \/*\n+                 * Lookup the entity in the table.\n+                 *\/\n+                ent = htmlEntityLookup(name);\n+                if (ent != NULL) \/* OK that's ugly !!! *\/\n+                    NEXT;\n+            } else {\n+                htmlParseErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING,\n+                             \"htmlParseEntityRef: expecting ';'\\n\",\n+                             NULL, NULL);\n+                if (str != NULL)\n+                    *str = name;\n+            }\n@@ -2904,1 +2907,0 @@\n-    }\n@@ -2926,1 +2928,1 @@\n-    ret = htmlParseHTMLAttribute(ctxt, '\"');\n+        ret = htmlParseHTMLAttribute(ctxt, '\"');\n@@ -2928,4 +2930,4 @@\n-        htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                     \"AttValue: \\\" expected\\n\", NULL, NULL);\n-    } else\n-        NEXT;\n+            htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                         \"AttValue: \\\" expected\\n\", NULL, NULL);\n+        } else\n+            NEXT;\n@@ -2934,1 +2936,1 @@\n-    ret = htmlParseHTMLAttribute(ctxt, '\\'');\n+        ret = htmlParseHTMLAttribute(ctxt, '\\'');\n@@ -2936,4 +2938,4 @@\n-        htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                     \"AttValue: ' expected\\n\", NULL, NULL);\n-    } else\n-        NEXT;\n+            htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                         \"AttValue: ' expected\\n\", NULL, NULL);\n+        } else\n+            NEXT;\n@@ -2942,7 +2944,7 @@\n-     * That's an HTMLism, the attribute value may not be quoted\n-     *\/\n-    ret = htmlParseHTMLAttribute(ctxt, 0);\n-    if (ret == NULL) {\n-        htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,\n-                     \"AttValue: no value found\\n\", NULL, NULL);\n-    }\n+         * That's an HTMLism, the attribute value may not be quoted\n+         *\/\n+        ret = htmlParseHTMLAttribute(ctxt, 0);\n+        if (ret == NULL) {\n+            htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,\n+                         \"AttValue: no value found\\n\", NULL, NULL);\n+        }\n@@ -2972,2 +2974,2 @@\n-    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,\n-                 \"SystemLiteral \\\" or ' expected\\n\", NULL, NULL);\n+        htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,\n+                     \"SystemLiteral \\\" or ' expected\\n\", NULL, NULL);\n@@ -3024,2 +3026,2 @@\n-    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,\n-                 \"PubidLiteral \\\" or ' expected\\n\", NULL, NULL);\n+        htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,\n+                     \"PubidLiteral \\\" or ' expected\\n\", NULL, NULL);\n@@ -3048,1 +3050,1 @@\n-    if (CUR != '\"') {\n+    if (CUR != quote) {\n@@ -3090,1 +3092,1 @@\n-    if ((cur == '<') && (NXT(1) == '\/')) {\n+        if ((cur == '<') && (NXT(1) == '\/')) {\n@@ -3104,1 +3106,1 @@\n-                   xmlStrlen(ctxt->name)) == 0)\n+                                   xmlStrlen(ctxt->name)) == 0)\n@@ -3108,4 +3110,4 @@\n-            htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,\n-                 \"Element %s embeds close tag\\n\",\n-                         ctxt->name, NULL);\n-        }\n+                    htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,\n+                                 \"Element %s embeds close tag\\n\",\n+                                 ctxt->name, NULL);\n+                }\n@@ -3119,1 +3121,1 @@\n-    }\n+        }\n@@ -3121,1 +3123,1 @@\n-        COPY_BUF(l,buf,nbchar,cur);\n+            COPY_BUF(l,buf,nbchar,cur);\n@@ -3126,1 +3128,1 @@\n-    if (nbchar >= HTML_PARSER_BIG_BUFFER_SIZE) {\n+        if (nbchar >= HTML_PARSER_BIG_BUFFER_SIZE) {\n@@ -3128,7 +3130,9 @@\n-        if (ctxt->sax->cdataBlock!= NULL) {\n-        \/*\n-         * Insert as CDATA, which is the same as HTML_PRESERVE_NODE\n-         *\/\n-        ctxt->sax->cdataBlock(ctxt->userData, buf, nbchar);\n-        } else if (ctxt->sax->characters != NULL) {\n-        ctxt->sax->characters(ctxt->userData, buf, nbchar);\n+            if (ctxt->sax->cdataBlock!= NULL) {\n+                \/*\n+                 * Insert as CDATA, which is the same as HTML_PRESERVE_NODE\n+                 *\/\n+                ctxt->sax->cdataBlock(ctxt->userData, buf, nbchar);\n+            } else if (ctxt->sax->characters != NULL) {\n+                ctxt->sax->characters(ctxt->userData, buf, nbchar);\n+            }\n+            nbchar = 0;\n@@ -3136,5 +3140,3 @@\n-        nbchar = 0;\n-    }\n-    GROW;\n-    NEXTL(l);\n-    cur = CUR_CHAR(l);\n+        GROW;\n+        NEXTL(l);\n+        cur = CUR_CHAR(l);\n@@ -3145,8 +3147,8 @@\n-    if (ctxt->sax->cdataBlock!= NULL) {\n-        \/*\n-         * Insert as CDATA, which is the same as HTML_PRESERVE_NODE\n-         *\/\n-        ctxt->sax->cdataBlock(ctxt->userData, buf, nbchar);\n-    } else if (ctxt->sax->characters != NULL) {\n-        ctxt->sax->characters(ctxt->userData, buf, nbchar);\n-    }\n+        if (ctxt->sax->cdataBlock!= NULL) {\n+            \/*\n+             * Insert as CDATA, which is the same as HTML_PRESERVE_NODE\n+             *\/\n+            ctxt->sax->cdataBlock(ctxt->userData, buf, nbchar);\n+        } else if (ctxt->sax->characters != NULL) {\n+            ctxt->sax->characters(ctxt->userData, buf, nbchar);\n+        }\n@@ -3182,8 +3184,8 @@\n-       (cur != 0)) {\n-    if (!(IS_CHAR(cur))) {\n-        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-                    \"Invalid char in CDATA 0x%X\\n\", cur);\n-    } else {\n-        COPY_BUF(l,buf,nbchar,cur);\n-    }\n-    if (nbchar >= HTML_PARSER_BIG_BUFFER_SIZE) {\n+           (cur != 0)) {\n+        if (!(IS_CHAR(cur))) {\n+            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                        \"Invalid char in CDATA 0x%X\\n\", cur);\n+        } else {\n+            COPY_BUF(l,buf,nbchar,cur);\n+        }\n+        if (nbchar >= HTML_PARSER_BIG_BUFFER_SIZE) {\n@@ -3192,18 +3194,20 @@\n-        \/*\n-         * Ok the segment is to be consumed as chars.\n-         *\/\n-        if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n-        if (areBlanks(ctxt, buf, nbchar)) {\n-            if (ctxt->keepBlanks) {\n-            if (ctxt->sax->characters != NULL)\n-                ctxt->sax->characters(ctxt->userData, buf, nbchar);\n-            } else {\n-            if (ctxt->sax->ignorableWhitespace != NULL)\n-                ctxt->sax->ignorableWhitespace(ctxt->userData,\n-                                               buf, nbchar);\n-            }\n-        } else {\n-            htmlCheckParagraph(ctxt);\n-            if (ctxt->sax->characters != NULL)\n-            ctxt->sax->characters(ctxt->userData, buf, nbchar);\n-        }\n+            \/*\n+             * Ok the segment is to be consumed as chars.\n+             *\/\n+            if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n+                if (areBlanks(ctxt, buf, nbchar)) {\n+                    if (ctxt->keepBlanks) {\n+                        if (ctxt->sax->characters != NULL)\n+                            ctxt->sax->characters(ctxt->userData, buf, nbchar);\n+                    } else {\n+                        if (ctxt->sax->ignorableWhitespace != NULL)\n+                            ctxt->sax->ignorableWhitespace(ctxt->userData,\n+                                                           buf, nbchar);\n+                    }\n+                } else {\n+                    htmlCheckParagraph(ctxt);\n+                    if (ctxt->sax->characters != NULL)\n+                        ctxt->sax->characters(ctxt->userData, buf, nbchar);\n+                }\n+            }\n+            nbchar = 0;\n@@ -3211,3 +3215,1 @@\n-        nbchar = 0;\n-    }\n-    NEXTL(l);\n+        NEXTL(l);\n@@ -3220,4 +3222,0 @@\n-    cur = CUR_CHAR(l);\n-    if (cur == 0) {\n-        SHRINK;\n-        GROW;\n@@ -3225,1 +3223,5 @@\n-    }\n+        if (cur == 0) {\n+            SHRINK;\n+            GROW;\n+            cur = CUR_CHAR(l);\n+        }\n@@ -3230,17 +3232,18 @@\n-    \/*\n-     * Ok the segment is to be consumed as chars.\n-     *\/\n-    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n-        if (areBlanks(ctxt, buf, nbchar)) {\n-        if (ctxt->keepBlanks) {\n-            if (ctxt->sax->characters != NULL)\n-            ctxt->sax->characters(ctxt->userData, buf, nbchar);\n-        } else {\n-            if (ctxt->sax->ignorableWhitespace != NULL)\n-            ctxt->sax->ignorableWhitespace(ctxt->userData,\n-                                           buf, nbchar);\n-        }\n-        } else {\n-        htmlCheckParagraph(ctxt);\n-        if (ctxt->sax->characters != NULL)\n-            ctxt->sax->characters(ctxt->userData, buf, nbchar);\n+        \/*\n+         * Ok the segment is to be consumed as chars.\n+         *\/\n+        if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n+            if (areBlanks(ctxt, buf, nbchar)) {\n+                if (ctxt->keepBlanks) {\n+                    if (ctxt->sax->characters != NULL)\n+                        ctxt->sax->characters(ctxt->userData, buf, nbchar);\n+                } else {\n+                    if (ctxt->sax->ignorableWhitespace != NULL)\n+                        ctxt->sax->ignorableWhitespace(ctxt->userData,\n+                                                       buf, nbchar);\n+                }\n+            } else {\n+                htmlCheckParagraph(ctxt);\n+                if (ctxt->sax->characters != NULL)\n+                    ctxt->sax->characters(ctxt->userData, buf, nbchar);\n+            }\n@@ -3248,1 +3251,0 @@\n-    }\n@@ -3250,5 +3252,5 @@\n-    \/*\n-     * Loop detection\n-     *\/\n-    if (cur == 0)\n-        ctxt->instate = XML_PARSER_EOF;\n+        \/*\n+         * Loop detection\n+         *\/\n+        if (cur == 0)\n+            ctxt->instate = XML_PARSER_EOF;\n@@ -3296,1 +3298,1 @@\n-     (UPP(4) == 'E') && (UPP(5) == 'M')) {\n+         (UPP(4) == 'E') && (UPP(5) == 'M')) {\n@@ -3298,4 +3300,4 @@\n-    if (!IS_BLANK_CH(CUR)) {\n-        htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,\n-                     \"Space required after 'SYSTEM'\\n\", NULL, NULL);\n-    }\n+        if (!IS_BLANK_CH(CUR)) {\n+            htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,\n+                         \"Space required after 'SYSTEM'\\n\", NULL, NULL);\n+        }\n@@ -3303,4 +3305,4 @@\n-    URI = htmlParseSystemLiteral(ctxt);\n-    if (URI == NULL) {\n-        htmlParseErr(ctxt, XML_ERR_URI_REQUIRED,\n-                     \"htmlParseExternalID: SYSTEM, no URI\\n\", NULL, NULL);\n+        URI = htmlParseSystemLiteral(ctxt);\n+        if (URI == NULL) {\n+            htmlParseErr(ctxt, XML_ERR_URI_REQUIRED,\n+                         \"htmlParseExternalID: SYSTEM, no URI\\n\", NULL, NULL);\n@@ -3309,2 +3311,2 @@\n-           (UPP(2) == 'B') && (UPP(3) == 'L') &&\n-           (UPP(4) == 'I') && (UPP(5) == 'C')) {\n+               (UPP(2) == 'B') && (UPP(3) == 'L') &&\n+               (UPP(4) == 'I') && (UPP(5) == 'C')) {\n@@ -3312,4 +3314,4 @@\n-    if (!IS_BLANK_CH(CUR)) {\n-        htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,\n-                     \"Space required after 'PUBLIC'\\n\", NULL, NULL);\n-    }\n+        if (!IS_BLANK_CH(CUR)) {\n+            htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,\n+                         \"Space required after 'PUBLIC'\\n\", NULL, NULL);\n+        }\n@@ -3317,6 +3319,6 @@\n-    *publicID = htmlParsePubidLiteral(ctxt);\n-    if (*publicID == NULL) {\n-        htmlParseErr(ctxt, XML_ERR_PUBID_REQUIRED,\n-                     \"htmlParseExternalID: PUBLIC, no Public Identifier\\n\",\n-             NULL, NULL);\n-    }\n+        *publicID = htmlParsePubidLiteral(ctxt);\n+        if (*publicID == NULL) {\n+            htmlParseErr(ctxt, XML_ERR_PUBID_REQUIRED,\n+                         \"htmlParseExternalID: PUBLIC, no Public Identifier\\n\",\n+                         NULL, NULL);\n+        }\n@@ -3325,2 +3327,2 @@\n-        URI = htmlParseSystemLiteral(ctxt);\n-    }\n+            URI = htmlParseSystemLiteral(ctxt);\n+        }\n@@ -3350,1 +3352,1 @@\n-    state = ctxt->instate;\n+        state = ctxt->instate;\n@@ -3352,14 +3354,5 @@\n-    \/*\n-     * this is a Processing Instruction.\n-     *\/\n-    SKIP(2);\n-    SHRINK;\n-\n-    \/*\n-     * Parse the target name and check for special support like\n-     * namespace.\n-     *\/\n-        target = htmlParseName(ctxt);\n-    if (target != NULL) {\n-        if (RAW == '>') {\n-        SKIP(1);\n+        \/*\n+         * this is a Processing Instruction.\n+         *\/\n+        SKIP(2);\n+        SHRINK;\n@@ -3368,1 +3361,2 @@\n-         * SAX: PI detected.\n+         * Parse the target name and check for special support like\n+         * namespace.\n@@ -3370,23 +3364,4 @@\n-        if ((ctxt->sax) && (!ctxt->disableSAX) &&\n-            (ctxt->sax->processingInstruction != NULL))\n-            ctxt->sax->processingInstruction(ctxt->userData,\n-                                             target, NULL);\n-        ctxt->instate = state;\n-        return;\n-        }\n-        buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n-        if (buf == NULL) {\n-        htmlErrMemory(ctxt, NULL);\n-        ctxt->instate = state;\n-        return;\n-        }\n-        cur = CUR;\n-        if (!IS_BLANK(cur)) {\n-        htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,\n-              \"ParsePI: PI %s space expected\\n\", target, NULL);\n-        }\n-            SKIP_BLANKS;\n-        cur = CUR_CHAR(l);\n-        while ((cur != 0) && (cur != '>')) {\n-        if (len + 5 >= size) {\n-            xmlChar *tmp;\n+        target = htmlParseName(ctxt);\n+        if (target != NULL) {\n+            if (RAW == '>') {\n+                SKIP(1);\n@@ -3394,7 +3369,9 @@\n-            size *= 2;\n-            tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n-            if (tmp == NULL) {\n-            htmlErrMemory(ctxt, NULL);\n-            xmlFree(buf);\n-            ctxt->instate = state;\n-            return;\n+                \/*\n+                 * SAX: PI detected.\n+                 *\/\n+                if ((ctxt->sax) && (!ctxt->disableSAX) &&\n+                    (ctxt->sax->processingInstruction != NULL))\n+                    ctxt->sax->processingInstruction(ctxt->userData,\n+                                                     target, NULL);\n+                ctxt->instate = state;\n+                return;\n@@ -3402,7 +3379,32 @@\n-            buf = tmp;\n-        }\n-        count++;\n-        if (count > 50) {\n-            GROW;\n-            count = 0;\n-        }\n+            buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n+            if (buf == NULL) {\n+                htmlErrMemory(ctxt, NULL);\n+                ctxt->instate = state;\n+                return;\n+            }\n+            cur = CUR;\n+            if (!IS_BLANK(cur)) {\n+                htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,\n+                          \"ParsePI: PI %s space expected\\n\", target, NULL);\n+            }\n+            SKIP_BLANKS;\n+            cur = CUR_CHAR(l);\n+            while ((cur != 0) && (cur != '>')) {\n+                if (len + 5 >= size) {\n+                    xmlChar *tmp;\n+\n+                    size *= 2;\n+                    tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n+                    if (tmp == NULL) {\n+                        htmlErrMemory(ctxt, NULL);\n+                        xmlFree(buf);\n+                        ctxt->instate = state;\n+                        return;\n+                    }\n+                    buf = tmp;\n+                }\n+                count++;\n+                if (count > 50) {\n+                    GROW;\n+                    count = 0;\n+                }\n@@ -3410,1 +3412,1 @@\n-            COPY_BUF(l,buf,len,cur);\n+                    COPY_BUF(l,buf,len,cur);\n@@ -3416,14 +3418,14 @@\n-        NEXTL(l);\n-        cur = CUR_CHAR(l);\n-        if (cur == 0) {\n-            SHRINK;\n-            GROW;\n-            cur = CUR_CHAR(l);\n-        }\n-        }\n-        buf[len] = 0;\n-        if (cur != '>') {\n-        htmlParseErr(ctxt, XML_ERR_PI_NOT_FINISHED,\n-              \"ParsePI: PI %s never end ...\\n\", target, NULL);\n-        } else {\n-        SKIP(1);\n+                NEXTL(l);\n+                cur = CUR_CHAR(l);\n+                if (cur == 0) {\n+                    SHRINK;\n+                    GROW;\n+                    cur = CUR_CHAR(l);\n+                }\n+            }\n+            buf[len] = 0;\n+            if (cur != '>') {\n+                htmlParseErr(ctxt, XML_ERR_PI_NOT_FINISHED,\n+                      \"ParsePI: PI %s never end ...\\n\", target, NULL);\n+            } else {\n+                SKIP(1);\n@@ -3431,11 +3433,11 @@\n-        \/*\n-         * SAX: PI detected.\n-         *\/\n-        if ((ctxt->sax) && (!ctxt->disableSAX) &&\n-            (ctxt->sax->processingInstruction != NULL))\n-            ctxt->sax->processingInstruction(ctxt->userData,\n-                                             target, buf);\n-        }\n-        xmlFree(buf);\n-    } else {\n-        htmlParseErr(ctxt, XML_ERR_PI_NOT_STARTED,\n+                \/*\n+                 * SAX: PI detected.\n+                 *\/\n+                if ((ctxt->sax) && (!ctxt->disableSAX) &&\n+                    (ctxt->sax->processingInstruction != NULL))\n+                    ctxt->sax->processingInstruction(ctxt->userData,\n+                                                     target, buf);\n+            }\n+            xmlFree(buf);\n+        } else {\n+            htmlParseErr(ctxt, XML_ERR_PI_NOT_STARTED,\n@@ -3443,2 +3445,2 @@\n-    }\n-    ctxt->instate = state;\n+        }\n+        ctxt->instate = state;\n@@ -3480,2 +3482,2 @@\n-    ctxt->instate = state;\n-    return;\n+        ctxt->instate = state;\n+        return;\n@@ -3496,6 +3498,2 @@\n-        (r != '-') || (q != '-'))) {\n-    NEXTL(l);\n-    next = CUR_CHAR(nl);\n-    if (next == 0) {\n-        SHRINK;\n-        GROW;\n+            (r != '-') || (q != '-'))) {\n+        NEXTL(l);\n@@ -3503,1 +3501,5 @@\n-    }\n+        if (next == 0) {\n+            SHRINK;\n+            GROW;\n+            next = CUR_CHAR(nl);\n+        }\n@@ -3505,6 +3507,6 @@\n-    if ((q == '-') && (r == '-') && (cur == '!') && (next == '>')) {\n-      htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n-               \"Comment incorrectly closed by '--!>'\", NULL, NULL);\n-      cur = '>';\n-      break;\n-    }\n+        if ((q == '-') && (r == '-') && (cur == '!') && (next == '>')) {\n+          htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n+                       \"Comment incorrectly closed by '--!>'\", NULL, NULL);\n+          cur = '>';\n+          break;\n+        }\n@@ -3512,2 +3514,2 @@\n-    if (len + 5 >= size) {\n-        xmlChar *tmp;\n+        if (len + 5 >= size) {\n+            xmlChar *tmp;\n@@ -3515,7 +3517,9 @@\n-        size *= 2;\n-        tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n-        if (tmp == NULL) {\n-            xmlFree(buf);\n-            htmlErrMemory(ctxt, \"growing buffer failed\\n\");\n-        ctxt->instate = state;\n-        return;\n+            size *= 2;\n+            tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n+            if (tmp == NULL) {\n+                xmlFree(buf);\n+                htmlErrMemory(ctxt, \"growing buffer failed\\n\");\n+                ctxt->instate = state;\n+                return;\n+            }\n+            buf = tmp;\n@@ -3523,2 +3527,0 @@\n-        buf = tmp;\n-    }\n@@ -3526,1 +3528,1 @@\n-        COPY_BUF(ql,buf,len,q);\n+            COPY_BUF(ql,buf,len,q);\n@@ -3532,6 +3534,6 @@\n-    q = r;\n-    ql = rl;\n-    r = cur;\n-    rl = l;\n-    cur = next;\n-    l = nl;\n+        q = r;\n+        ql = rl;\n+        r = cur;\n+        rl = l;\n+        cur = next;\n+        l = nl;\n@@ -3542,6 +3544,6 @@\n-    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n-        (!ctxt->disableSAX))\n-        ctxt->sax->comment(ctxt->userData, buf);\n-    xmlFree(buf);\n-    ctxt->instate = state;\n-    return;\n+        if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n+            (!ctxt->disableSAX))\n+            ctxt->sax->comment(ctxt->userData, buf);\n+        xmlFree(buf);\n+        ctxt->instate = state;\n+        return;\n@@ -3552,1 +3554,1 @@\n-         \"Comment not terminated \\n<!--%.50s\\n\", buf, NULL);\n+                 \"Comment not terminated \\n<!--%.50s\\n\", buf, NULL);\n@@ -3572,3 +3574,3 @@\n-    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-             \"htmlParseCharRef: context error\\n\",\n-             NULL, NULL);\n+        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                     \"htmlParseCharRef: context error\\n\",\n+                     NULL, NULL);\n@@ -3579,3 +3581,3 @@\n-    SKIP(3);\n-    while (CUR != ';') {\n-        if ((CUR >= '0') && (CUR <= '9')) {\n+        SKIP(3);\n+        while (CUR != ';') {\n+            if ((CUR >= '0') && (CUR <= '9')) {\n@@ -3583,1 +3585,1 @@\n-                val = val * 16 + (CUR - '0');\n+                    val = val * 16 + (CUR - '0');\n@@ -3586,1 +3588,1 @@\n-                val = val * 16 + (CUR - 'a') + 10;\n+                    val = val * 16 + (CUR - 'a') + 10;\n@@ -3589,1 +3591,1 @@\n-                val = val * 16 + (CUR - 'A') + 10;\n+                    val = val * 16 + (CUR - 'A') + 10;\n@@ -3591,4 +3593,6 @@\n-            htmlParseErr(ctxt, XML_ERR_INVALID_HEX_CHARREF,\n-                     \"htmlParseCharRef: missing semicolon\\n\",\n-                 NULL, NULL);\n-        break;\n+                htmlParseErr(ctxt, XML_ERR_INVALID_HEX_CHARREF,\n+                             \"htmlParseCharRef: missing semicolon\\n\",\n+                             NULL, NULL);\n+                break;\n+            }\n+            NEXT;\n@@ -3596,4 +3600,2 @@\n-        NEXT;\n-    }\n-    if (CUR == ';')\n-        NEXT;\n+        if (CUR == ';')\n+            NEXT;\n@@ -3601,3 +3603,3 @@\n-    SKIP(2);\n-    while (CUR != ';') {\n-        if ((CUR >= '0') && (CUR <= '9')) {\n+        SKIP(2);\n+        while (CUR != ';') {\n+            if ((CUR >= '0') && (CUR <= '9')) {\n@@ -3605,1 +3607,1 @@\n-                val = val * 10 + (CUR - '0');\n+                    val = val * 10 + (CUR - '0');\n@@ -3607,4 +3609,6 @@\n-            htmlParseErr(ctxt, XML_ERR_INVALID_DEC_CHARREF,\n-                     \"htmlParseCharRef: missing semicolon\\n\",\n-                 NULL, NULL);\n-        break;\n+                htmlParseErr(ctxt, XML_ERR_INVALID_DEC_CHARREF,\n+                             \"htmlParseCharRef: missing semicolon\\n\",\n+                             NULL, NULL);\n+                break;\n+            }\n+            NEXT;\n@@ -3612,4 +3616,2 @@\n-        NEXT;\n-    }\n-    if (CUR == ';')\n-        NEXT;\n+        if (CUR == ';')\n+            NEXT;\n@@ -3617,2 +3619,2 @@\n-    htmlParseErr(ctxt, XML_ERR_INVALID_CHARREF,\n-                 \"htmlParseCharRef: invalid value\\n\", NULL, NULL);\n+        htmlParseErr(ctxt, XML_ERR_INVALID_CHARREF,\n+                     \"htmlParseCharRef: invalid value\\n\", NULL, NULL);\n@@ -3626,2 +3628,2 @@\n-    htmlParseErr(ctxt, XML_ERR_INVALID_CHAR,\n-             \"htmlParseCharRef: value too large\\n\", NULL, NULL);\n+        htmlParseErr(ctxt, XML_ERR_INVALID_CHAR,\n+                     \"htmlParseCharRef: value too large\\n\", NULL, NULL);\n@@ -3629,3 +3631,3 @@\n-    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-            \"htmlParseCharRef: invalid xmlChar value %d\\n\",\n-            val);\n+        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n+                        \"htmlParseCharRef: invalid xmlChar value %d\\n\",\n+                        val);\n@@ -3665,3 +3667,3 @@\n-    htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n-                 \"htmlParseDocTypeDecl : no DOCTYPE name !\\n\",\n-             NULL, NULL);\n+        htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n+                     \"htmlParseDocTypeDecl : no DOCTYPE name !\\n\",\n+                     NULL, NULL);\n@@ -3685,2 +3687,2 @@\n-    htmlParseErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED,\n-                 \"DOCTYPE improperly terminated\\n\", NULL, NULL);\n+        htmlParseErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED,\n+                     \"DOCTYPE improperly terminated\\n\", NULL, NULL);\n@@ -3698,2 +3700,2 @@\n-    (!ctxt->disableSAX))\n-    ctxt->sax->internalSubset(ctxt->userData, name, ExternalID, URI);\n+        (!ctxt->disableSAX))\n+        ctxt->sax->internalSubset(ctxt->userData, name, ExternalID, URI);\n@@ -3737,2 +3739,2 @@\n-    htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n-                 \"error parsing attribute name\\n\", NULL, NULL);\n+        htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n+                     \"error parsing attribute name\\n\", NULL, NULL);\n@@ -3748,2 +3750,2 @@\n-    SKIP_BLANKS;\n-    val = htmlParseAttValue(ctxt);\n+        SKIP_BLANKS;\n+        val = htmlParseAttValue(ctxt);\n@@ -3771,1 +3773,1 @@\n-    return;\n+        return;\n@@ -3778,2 +3780,2 @@\n-    xmlCharEncoding enc;\n-    xmlCharEncodingHandlerPtr handler;\n+        xmlCharEncoding enc;\n+        xmlCharEncodingHandlerPtr handler;\n@@ -3781,1 +3783,1 @@\n-    while ((*encoding == ' ') || (*encoding == '\\t')) encoding++;\n+        while ((*encoding == ' ') || (*encoding == '\\t')) encoding++;\n@@ -3783,3 +3785,3 @@\n-    if (ctxt->input->encoding != NULL)\n-        xmlFree((xmlChar *) ctxt->input->encoding);\n-    ctxt->input->encoding = xmlStrdup(encoding);\n+        if (ctxt->input->encoding != NULL)\n+            xmlFree((xmlChar *) ctxt->input->encoding);\n+        ctxt->input->encoding = xmlStrdup(encoding);\n@@ -3787,19 +3789,1 @@\n-    enc = xmlParseCharEncoding((const char *) encoding);\n-    \/*\n-     * registered set of known encodings\n-     *\/\n-    if (enc != XML_CHAR_ENCODING_ERROR) {\n-        if (((enc == XML_CHAR_ENCODING_UTF16LE) ||\n-             (enc == XML_CHAR_ENCODING_UTF16BE) ||\n-         (enc == XML_CHAR_ENCODING_UCS4LE) ||\n-         (enc == XML_CHAR_ENCODING_UCS4BE)) &&\n-        (ctxt->input->buf != NULL) &&\n-        (ctxt->input->buf->encoder == NULL)) {\n-        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-                     \"htmlCheckEncoding: wrong encoding meta\\n\",\n-                 NULL, NULL);\n-        } else {\n-        xmlSwitchEncoding(ctxt, enc);\n-        }\n-        ctxt->charset = XML_CHAR_ENCODING_UTF8;\n-    } else {\n+        enc = xmlParseCharEncoding((const char *) encoding);\n@@ -3807,1 +3791,1 @@\n-         * fallback for unknown encodings\n+         * registered set of known encodings\n@@ -3809,4 +3793,14 @@\n-        handler = xmlFindCharEncodingHandler((const char *) encoding);\n-        if (handler != NULL) {\n-        xmlSwitchToEncoding(ctxt, handler);\n-        ctxt->charset = XML_CHAR_ENCODING_UTF8;\n+        if (enc != XML_CHAR_ENCODING_ERROR) {\n+            if (((enc == XML_CHAR_ENCODING_UTF16LE) ||\n+                 (enc == XML_CHAR_ENCODING_UTF16BE) ||\n+                 (enc == XML_CHAR_ENCODING_UCS4LE) ||\n+                 (enc == XML_CHAR_ENCODING_UCS4BE)) &&\n+                (ctxt->input->buf != NULL) &&\n+                (ctxt->input->buf->encoder == NULL)) {\n+                htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                             \"htmlCheckEncoding: wrong encoding meta\\n\",\n+                             NULL, NULL);\n+            } else {\n+                xmlSwitchEncoding(ctxt, enc);\n+            }\n+            ctxt->charset = XML_CHAR_ENCODING_UTF8;\n@@ -3814,3 +3808,12 @@\n-        htmlParseErr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n-                     \"htmlCheckEncoding: unknown encoding %s\\n\",\n-                 encoding, NULL);\n+            \/*\n+             * fallback for unknown encodings\n+             *\/\n+            handler = xmlFindCharEncodingHandler((const char *) encoding);\n+            if (handler != NULL) {\n+                xmlSwitchToEncoding(ctxt, handler);\n+                ctxt->charset = XML_CHAR_ENCODING_UTF8;\n+            } else {\n+                htmlParseErr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n+                             \"htmlCheckEncoding: unknown encoding %s\\n\",\n+                             encoding, NULL);\n+            }\n@@ -3818,1 +3821,0 @@\n-    }\n@@ -3820,6 +3822,6 @@\n-    if ((ctxt->input->buf != NULL) &&\n-        (ctxt->input->buf->encoder != NULL) &&\n-        (ctxt->input->buf->raw != NULL) &&\n-        (ctxt->input->buf->buffer != NULL)) {\n-        int nbchars;\n-        int processed;\n+        if ((ctxt->input->buf != NULL) &&\n+            (ctxt->input->buf->encoder != NULL) &&\n+            (ctxt->input->buf->raw != NULL) &&\n+            (ctxt->input->buf->buffer != NULL)) {\n+            int nbchars;\n+            int processed;\n@@ -3827,6 +3829,6 @@\n-        \/*\n-         * convert as much as possible to the parser reading buffer.\n-         *\/\n-        processed = ctxt->input->cur - ctxt->input->base;\n-        xmlBufShrink(ctxt->input->buf->buffer, processed);\n-        nbchars = xmlCharEncInput(ctxt->input->buf, 1);\n+            \/*\n+             * convert as much as possible to the parser reading buffer.\n+             *\/\n+            processed = ctxt->input->cur - ctxt->input->base;\n+            xmlBufShrink(ctxt->input->buf->buffer, processed);\n+            nbchars = xmlCharEncInput(ctxt->input->buf, 1);\n@@ -3834,4 +3836,5 @@\n-        if (nbchars < 0) {\n-        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-                     \"htmlCheckEncoding: encoder error\\n\",\n-                 NULL, NULL);\n+            if (nbchars < 0) {\n+                htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                             \"htmlCheckEncoding: encoder error\\n\",\n+                             NULL, NULL);\n+            }\n@@ -3840,1 +3843,0 @@\n-    }\n@@ -3858,1 +3860,1 @@\n-    return;\n+        return;\n@@ -3862,1 +3864,1 @@\n-    encoding += 7;\n+        encoding += 7;\n@@ -3868,1 +3870,1 @@\n-    encoding = xmlStrcasestr(attvalue, BAD_CAST\"=\");\n+        encoding = xmlStrcasestr(attvalue, BAD_CAST\"=\");\n@@ -3870,2 +3872,2 @@\n-    encoding ++;\n-    htmlCheckEncodingDirect(ctxt, encoding);\n+        encoding ++;\n+        htmlCheckEncodingDirect(ctxt, encoding);\n@@ -3890,1 +3892,1 @@\n-    return;\n+        return;\n@@ -3895,9 +3897,9 @@\n-    value = atts[i++];\n-    if ((value != NULL) && (!xmlStrcasecmp(att, BAD_CAST\"http-equiv\"))\n-     && (!xmlStrcasecmp(value, BAD_CAST\"Content-Type\")))\n-        http = 1;\n-    else if ((value != NULL) && (!xmlStrcasecmp(att, BAD_CAST\"charset\")))\n-        htmlCheckEncodingDirect(ctxt, value);\n-    else if ((value != NULL) && (!xmlStrcasecmp(att, BAD_CAST\"content\")))\n-        content = value;\n-    att = atts[i++];\n+        value = atts[i++];\n+        if ((value != NULL) && (!xmlStrcasecmp(att, BAD_CAST\"http-equiv\"))\n+         && (!xmlStrcasecmp(value, BAD_CAST\"Content-Type\")))\n+            http = 1;\n+        else if ((value != NULL) && (!xmlStrcasecmp(att, BAD_CAST\"charset\")))\n+            htmlCheckEncodingDirect(ctxt, value);\n+        else if ((value != NULL) && (!xmlStrcasecmp(att, BAD_CAST\"content\")))\n+            content = value;\n+        att = atts[i++];\n@@ -3906,1 +3908,1 @@\n-    htmlCheckEncoding(ctxt, content);\n+        htmlCheckEncoding(ctxt, content);\n@@ -3943,3 +3945,3 @@\n-    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-             \"htmlParseStartTag: context error\\n\", NULL, NULL);\n-    return -1;\n+        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                     \"htmlParseStartTag: context error\\n\", NULL, NULL);\n+        return -1;\n@@ -3958,10 +3960,22 @@\n-    htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n-                 \"htmlParseStartTag: invalid element name\\n\",\n-             NULL, NULL);\n-    \/* if recover preserve text on classic misconstructs *\/\n-    if ((ctxt->recovery) && ((IS_BLANK_CH(CUR)) || (CUR == '<') ||\n-        (CUR == '=') || (CUR == '>') || (((CUR >= '0') && (CUR <= '9'))))) {\n-        htmlParseCharDataInternal(ctxt, '<');\n-        return(-1);\n-    }\n-\n+        htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n+                     \"htmlParseStartTag: invalid element name\\n\",\n+                     NULL, NULL);\n+        \/*\n+         * The recovery code is disabled for now as it can result in\n+         * quadratic behavior with the push parser. htmlParseStartTag\n+         * must consume all content up to the final '>' in order to avoid\n+         * rescanning for this terminator.\n+         *\n+         * For a proper fix in line with HTML5, htmlParseStartTag and\n+         * htmlParseElement should only be called when there's an ASCII\n+         * alpha character following the initial '<'. Otherwise, the '<'\n+         * should be emitted as text (unless followed by '!', '\/' or '?').\n+         *\/\n+#if 0\n+        \/* if recover preserve text on classic misconstructs *\/\n+        if ((ctxt->recovery) && ((IS_BLANK_CH(CUR)) || (CUR == '<') ||\n+            (CUR == '=') || (CUR == '>') || (((CUR >= '0') && (CUR <= '9'))))) {\n+            htmlParseCharDataInternal(ctxt, '<');\n+            return(-1);\n+        }\n+#endif\n@@ -3969,2 +3983,2 @@\n-    \/* Dump the bogus tag like browsers do *\/\n-    while ((CUR != 0) && (CUR != '>') &&\n+        \/* Dump the bogus tag like browsers do *\/\n+        while ((CUR != 0) && (CUR != '>') &&\n@@ -3972,1 +3986,1 @@\n-        NEXT;\n+            NEXT;\n@@ -3976,1 +3990,1 @@\n-    meta = 1;\n+        meta = 1;\n@@ -3993,5 +4007,5 @@\n-    htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n-                 \"htmlParseStartTag: misplaced <html> tag\\n\",\n-             name, NULL);\n-    discardtag = 1;\n-    ctxt->depth++;\n+        htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n+                     \"htmlParseStartTag: misplaced <html> tag\\n\",\n+                     name, NULL);\n+        discardtag = 1;\n+        ctxt->depth++;\n@@ -4000,11 +4014,1 @@\n-    (xmlStrEqual(name, BAD_CAST\"head\"))) {\n-    htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n-                 \"htmlParseStartTag: misplaced <head> tag\\n\",\n-             name, NULL);\n-    discardtag = 1;\n-    ctxt->depth++;\n-    }\n-    if (xmlStrEqual(name, BAD_CAST\"body\")) {\n-    int indx;\n-    for (indx = 0;indx < ctxt->nameNr;indx++) {\n-        if (xmlStrEqual(ctxt->nameTab[indx], BAD_CAST\"body\")) {\n+        (xmlStrEqual(name, BAD_CAST\"head\"))) {\n@@ -4012,2 +4016,2 @@\n-                     \"htmlParseStartTag: misplaced <body> tag\\n\",\n-                 name, NULL);\n+                     \"htmlParseStartTag: misplaced <head> tag\\n\",\n+                     name, NULL);\n@@ -4016,1 +4020,0 @@\n-        }\n@@ -4018,0 +4021,11 @@\n+    if (xmlStrEqual(name, BAD_CAST\"body\")) {\n+        int indx;\n+        for (indx = 0;indx < ctxt->nameNr;indx++) {\n+            if (xmlStrEqual(ctxt->nameTab[indx], BAD_CAST\"body\")) {\n+                htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n+                             \"htmlParseStartTag: misplaced <body> tag\\n\",\n+                             name, NULL);\n+                discardtag = 1;\n+                ctxt->depth++;\n+            }\n+        }\n@@ -4028,3 +4042,3 @@\n-       ((CUR != '\/') || (NXT(1) != '>'))) {\n-    GROW;\n-    attname = htmlParseAttribute(ctxt, &attvalue);\n+           ((CUR != '\/') || (NXT(1) != '>'))) {\n+        GROW;\n+        attname = htmlParseAttribute(ctxt, &attvalue);\n@@ -4033,10 +4047,48 @@\n-        \/*\n-         * Well formedness requires at most one declaration of an attribute\n-         *\/\n-        for (i = 0; i < nbatts;i += 2) {\n-            if (xmlStrEqual(atts[i], attname)) {\n-            htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_REDEFINED,\n-                         \"Attribute %s redefined\\n\", attname, NULL);\n-            if (attvalue != NULL)\n-            xmlFree(attvalue);\n-            goto failed;\n+            \/*\n+             * Well formedness requires at most one declaration of an attribute\n+             *\/\n+            for (i = 0; i < nbatts;i += 2) {\n+                if (xmlStrEqual(atts[i], attname)) {\n+                    htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_REDEFINED,\n+                                 \"Attribute %s redefined\\n\", attname, NULL);\n+                    if (attvalue != NULL)\n+                        xmlFree(attvalue);\n+                    goto failed;\n+                }\n+            }\n+\n+            \/*\n+             * Add the pair to atts\n+             *\/\n+            if (atts == NULL) {\n+                maxatts = 22; \/* allow for 10 attrs by default *\/\n+                atts = (const xmlChar **)\n+                       xmlMalloc(maxatts * sizeof(xmlChar *));\n+                if (atts == NULL) {\n+                    htmlErrMemory(ctxt, NULL);\n+                    if (attvalue != NULL)\n+                        xmlFree(attvalue);\n+                    goto failed;\n+                }\n+                ctxt->atts = atts;\n+                ctxt->maxatts = maxatts;\n+            } else if (nbatts + 4 > maxatts) {\n+                const xmlChar **n;\n+\n+                maxatts *= 2;\n+                n = (const xmlChar **) xmlRealloc((void *) atts,\n+                                             maxatts * sizeof(const xmlChar *));\n+                if (n == NULL) {\n+                    htmlErrMemory(ctxt, NULL);\n+                    if (attvalue != NULL)\n+                        xmlFree(attvalue);\n+                    goto failed;\n+                }\n+                atts = n;\n+                ctxt->atts = atts;\n+                ctxt->maxatts = maxatts;\n+            }\n+            atts[nbatts++] = attname;\n+            atts[nbatts++] = attvalue;\n+            atts[nbatts] = NULL;\n+            atts[nbatts + 1] = NULL;\n@@ -4044,0 +4096,9 @@\n+        else {\n+            if (attvalue != NULL)\n+                xmlFree(attvalue);\n+            \/* Dump the bogus attribute string up to the next blank or\n+             * the end of the tag. *\/\n+            while ((CUR != 0) &&\n+                   !(IS_BLANK_CH(CUR)) && (CUR != '>') &&\n+                   ((CUR != '\/') || (NXT(1) != '>')))\n+                NEXT;\n@@ -4046,47 +4107,0 @@\n-        \/*\n-         * Add the pair to atts\n-         *\/\n-        if (atts == NULL) {\n-            maxatts = 22; \/* allow for 10 attrs by default *\/\n-            atts = (const xmlChar **)\n-               xmlMalloc(maxatts * sizeof(xmlChar *));\n-        if (atts == NULL) {\n-            htmlErrMemory(ctxt, NULL);\n-            if (attvalue != NULL)\n-            xmlFree(attvalue);\n-            goto failed;\n-        }\n-        ctxt->atts = atts;\n-        ctxt->maxatts = maxatts;\n-        } else if (nbatts + 4 > maxatts) {\n-            const xmlChar **n;\n-\n-            maxatts *= 2;\n-            n = (const xmlChar **) xmlRealloc((void *) atts,\n-                         maxatts * sizeof(const xmlChar *));\n-        if (n == NULL) {\n-            htmlErrMemory(ctxt, NULL);\n-            if (attvalue != NULL)\n-            xmlFree(attvalue);\n-            goto failed;\n-        }\n-        atts = n;\n-        ctxt->atts = atts;\n-        ctxt->maxatts = maxatts;\n-        }\n-        atts[nbatts++] = attname;\n-        atts[nbatts++] = attvalue;\n-        atts[nbatts] = NULL;\n-        atts[nbatts + 1] = NULL;\n-    }\n-    else {\n-        if (attvalue != NULL)\n-            xmlFree(attvalue);\n-        \/* Dump the bogus attribute string up to the next blank or\n-         * the end of the tag. *\/\n-        while ((CUR != 0) &&\n-               !(IS_BLANK_CH(CUR)) && (CUR != '>') &&\n-           ((CUR != '\/') || (NXT(1) != '>')))\n-        NEXT;\n-    }\n-\n@@ -4094,1 +4108,1 @@\n-    SKIP_BLANKS;\n+        SKIP_BLANKS;\n@@ -4101,1 +4115,1 @@\n-    htmlCheckMeta(ctxt, atts);\n+        htmlCheckMeta(ctxt, atts);\n@@ -4107,7 +4121,7 @@\n-    htmlnamePush(ctxt, name);\n-    if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL)) {\n-        if (nbatts != 0)\n-        ctxt->sax->startElement(ctxt->userData, name, atts);\n-        else\n-        ctxt->sax->startElement(ctxt->userData, name, NULL);\n-    }\n+        htmlnamePush(ctxt, name);\n+        if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL)) {\n+            if (nbatts != 0)\n+                ctxt->sax->startElement(ctxt->userData, name, atts);\n+            else\n+                ctxt->sax->startElement(ctxt->userData, name, NULL);\n+        }\n@@ -4118,3 +4132,3 @@\n-        if (atts[i] != NULL)\n-        xmlFree((xmlChar *) atts[i]);\n-    }\n+            if (atts[i] != NULL)\n+                xmlFree((xmlChar *) atts[i]);\n+        }\n@@ -4150,1 +4164,1 @@\n-                 \"htmlParseEndTag: '<\/' not found\\n\", NULL, NULL);\n+                     \"htmlParseEndTag: '<\/' not found\\n\", NULL, NULL);\n@@ -4164,1 +4178,1 @@\n-                 \"End tag : expected '>'\\n\", NULL, NULL);\n+                     \"End tag : expected '>'\\n\", NULL, NULL);\n@@ -4179,3 +4193,3 @@\n-     xmlStrEqual(name, BAD_CAST \"head\"))) {\n-    ctxt->depth--;\n-    return (0);\n+         xmlStrEqual(name, BAD_CAST \"head\"))) {\n+        ctxt->depth--;\n+        return (0);\n@@ -4194,1 +4208,1 @@\n-                 \"Unexpected end tag : %s\\n\", name, NULL);\n+                     \"Unexpected end tag : %s\\n\", name, NULL);\n@@ -4223,1 +4237,1 @@\n-    htmlNodeInfoPop(ctxt);\n+        htmlNodeInfoPop(ctxt);\n@@ -4250,2 +4264,2 @@\n-    unsigned int c;\n-    int bits, i = 0;\n+        unsigned int c;\n+        int bits, i = 0;\n@@ -4253,3 +4267,3 @@\n-    c = htmlParseCharRef(ctxt);\n-    if (c == 0)\n-        return;\n+        c = htmlParseCharRef(ctxt);\n+        if (c == 0)\n+            return;\n@@ -4265,1 +4279,1 @@\n-    out[i] = 0;\n+        out[i] = 0;\n@@ -4267,6 +4281,0 @@\n-    htmlCheckParagraph(ctxt);\n-    if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL))\n-        ctxt->sax->characters(ctxt->userData, out, i);\n-    } else {\n-    ent = htmlParseEntityRef(ctxt, &name);\n-    if (name == NULL) {\n@@ -4275,10 +4283,1 @@\n-            ctxt->sax->characters(ctxt->userData, BAD_CAST \"&\", 1);\n-        return;\n-    }\n-    if ((ent == NULL) || !(ent->value > 0)) {\n-        htmlCheckParagraph(ctxt);\n-        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL)) {\n-        ctxt->sax->characters(ctxt->userData, BAD_CAST \"&\", 1);\n-        ctxt->sax->characters(ctxt->userData, name, xmlStrlen(name));\n-        \/* ctxt->sax->characters(ctxt->userData, BAD_CAST \";\", 1); *\/\n-        }\n+            ctxt->sax->characters(ctxt->userData, out, i);\n@@ -4286,2 +4285,17 @@\n-        unsigned int c;\n-        int bits, i = 0;\n+        ent = htmlParseEntityRef(ctxt, &name);\n+        if (name == NULL) {\n+            htmlCheckParagraph(ctxt);\n+            if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL))\n+                ctxt->sax->characters(ctxt->userData, BAD_CAST \"&\", 1);\n+            return;\n+        }\n+        if ((ent == NULL) || !(ent->value > 0)) {\n+            htmlCheckParagraph(ctxt);\n+            if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL)) {\n+                ctxt->sax->characters(ctxt->userData, BAD_CAST \"&\", 1);\n+                ctxt->sax->characters(ctxt->userData, name, xmlStrlen(name));\n+                \/* ctxt->sax->characters(ctxt->userData, BAD_CAST \";\", 1); *\/\n+            }\n+        } else {\n+            unsigned int c;\n+            int bits, i = 0;\n@@ -4289,9 +4303,9 @@\n-        c = ent->value;\n-        if      (c <    0x80)\n-                { out[i++]= c;                bits= -6; }\n-        else if (c <   0x800)\n-                { out[i++]=((c >>  6) & 0x1F) | 0xC0;  bits=  0; }\n-        else if (c < 0x10000)\n-                { out[i++]=((c >> 12) & 0x0F) | 0xE0;  bits=  6; }\n-        else\n-                { out[i++]=((c >> 18) & 0x07) | 0xF0;  bits= 12; }\n+            c = ent->value;\n+            if      (c <    0x80)\n+                    { out[i++]= c;                bits= -6; }\n+            else if (c <   0x800)\n+                    { out[i++]=((c >>  6) & 0x1F) | 0xC0;  bits=  0; }\n+            else if (c < 0x10000)\n+                    { out[i++]=((c >> 12) & 0x0F) | 0xE0;  bits=  6; }\n+            else\n+                    { out[i++]=((c >> 18) & 0x07) | 0xF0;  bits= 12; }\n@@ -4299,4 +4313,4 @@\n-        for ( ; bits >= 0; bits-= 6) {\n-        out[i++]= ((c >> bits) & 0x3F) | 0x80;\n-        }\n-        out[i] = 0;\n+            for ( ; bits >= 0; bits-= 6) {\n+                out[i++]= ((c >> bits) & 0x3F) | 0x80;\n+            }\n+            out[i] = 0;\n@@ -4304,4 +4318,4 @@\n-        htmlCheckParagraph(ctxt);\n-        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL))\n-        ctxt->sax->characters(ctxt->userData, out, i);\n-    }\n+            htmlCheckParagraph(ctxt);\n+            if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL))\n+                ctxt->sax->characters(ctxt->userData, out, i);\n+        }\n@@ -4333,3 +4347,3 @@\n-    \/*\n-     * Our tag or one of it's parent or children is ending.\n-     *\/\n+        \/*\n+         * Our tag or one of it's parent or children is ending.\n+         *\/\n@@ -4337,7 +4351,7 @@\n-        if (htmlParseEndTag(ctxt) &&\n-        ((currentNode != NULL) || (ctxt->nameNr == 0))) {\n-        if (currentNode != NULL)\n-            xmlFree(currentNode);\n-        return;\n-        }\n-        continue; \/* while *\/\n+            if (htmlParseEndTag(ctxt) &&\n+                ((currentNode != NULL) || (ctxt->nameNr == 0))) {\n+                if (currentNode != NULL)\n+                    xmlFree(currentNode);\n+                return;\n+            }\n+            continue; \/* while *\/\n@@ -4346,9 +4360,9 @@\n-    else if ((CUR == '<') &&\n-             ((IS_ASCII_LETTER(NXT(1))) ||\n-          (NXT(1) == '_') || (NXT(1) == ':'))) {\n-        name = htmlParseHTMLName_nonInvasive(ctxt);\n-        if (name == NULL) {\n-            htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n-             \"htmlParseStartTag: invalid element name\\n\",\n-             NULL, NULL);\n-            \/* Dump the bogus tag like browsers do *\/\n+        else if ((CUR == '<') &&\n+                 ((IS_ASCII_LETTER(NXT(1))) ||\n+                  (NXT(1) == '_') || (NXT(1) == ':'))) {\n+            name = htmlParseHTMLName_nonInvasive(ctxt);\n+            if (name == NULL) {\n+                htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n+                         \"htmlParseStartTag: invalid element name\\n\",\n+                         NULL, NULL);\n+                \/* Dump the bogus tag like browsers do *\/\n@@ -4356,1 +4370,1 @@\n-                NEXT;\n+                    NEXT;\n@@ -4358,4 +4372,4 @@\n-            if (currentNode != NULL)\n-                xmlFree(currentNode);\n-            return;\n-        }\n+                if (currentNode != NULL)\n+                    xmlFree(currentNode);\n+                return;\n+            }\n@@ -4363,4 +4377,5 @@\n-        if (ctxt->name != NULL) {\n-            if (htmlCheckAutoClose(name, ctxt->name) == 1) {\n-                htmlAutoClose(ctxt, name);\n-                continue;\n+            if (ctxt->name != NULL) {\n+                if (htmlCheckAutoClose(name, ctxt->name) == 1) {\n+                    htmlAutoClose(ctxt, name);\n+                    continue;\n+                }\n@@ -4369,12 +4384,0 @@\n-    }\n-\n-    \/*\n-     * Has this node been popped out during parsing of\n-     * the next element\n-     *\/\n-        if ((ctxt->nameNr > 0) && (depth >= ctxt->nameNr) &&\n-        (!xmlStrEqual(currentNode, ctxt->name)))\n-         {\n-        if (currentNode != NULL) xmlFree(currentNode);\n-        return;\n-    }\n@@ -4382,7 +4385,0 @@\n-    if ((CUR != 0) && ((xmlStrEqual(currentNode, BAD_CAST\"script\")) ||\n-        (xmlStrEqual(currentNode, BAD_CAST\"style\")))) {\n-        \/*\n-         * Handle SCRIPT\/STYLE separately\n-         *\/\n-        htmlParseScript(ctxt);\n-    } else {\n@@ -4390,1 +4386,2 @@\n-         * Sometimes DOCTYPE arrives in the middle of the document\n+         * Has this node been popped out during parsing of\n+         * the next element\n@@ -4392,9 +4389,5 @@\n-        if ((CUR == '<') && (NXT(1) == '!') &&\n-        (UPP(2) == 'D') && (UPP(3) == 'O') &&\n-        (UPP(4) == 'C') && (UPP(5) == 'T') &&\n-        (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n-        (UPP(8) == 'E')) {\n-        htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n-                     \"Misplaced DOCTYPE declaration\\n\",\n-                 BAD_CAST \"DOCTYPE\" , NULL);\n-        htmlParseDocTypeDecl(ctxt);\n+        if ((ctxt->nameNr > 0) && (depth >= ctxt->nameNr) &&\n+            (!xmlStrEqual(currentNode, ctxt->name)))\n+             {\n+            if (currentNode != NULL) xmlFree(currentNode);\n+            return;\n@@ -4403,7 +4396,20 @@\n-        \/*\n-         * First case :  a comment\n-         *\/\n-        if ((CUR == '<') && (NXT(1) == '!') &&\n-        (NXT(2) == '-') && (NXT(3) == '-')) {\n-        htmlParseComment(ctxt);\n-        }\n+        if ((CUR != 0) && ((xmlStrEqual(currentNode, BAD_CAST\"script\")) ||\n+            (xmlStrEqual(currentNode, BAD_CAST\"style\")))) {\n+            \/*\n+             * Handle SCRIPT\/STYLE separately\n+             *\/\n+            htmlParseScript(ctxt);\n+        } else {\n+            \/*\n+             * Sometimes DOCTYPE arrives in the middle of the document\n+             *\/\n+            if ((CUR == '<') && (NXT(1) == '!') &&\n+                (UPP(2) == 'D') && (UPP(3) == 'O') &&\n+                (UPP(4) == 'C') && (UPP(5) == 'T') &&\n+                (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n+                (UPP(8) == 'E')) {\n+                htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n+                             \"Misplaced DOCTYPE declaration\\n\",\n+                             BAD_CAST \"DOCTYPE\" , NULL);\n+                htmlParseDocTypeDecl(ctxt);\n+            }\n@@ -4411,6 +4417,7 @@\n-        \/*\n-         * Second case : a Processing Instruction.\n-         *\/\n-        else if ((CUR == '<') && (NXT(1) == '?')) {\n-        htmlParsePI(ctxt);\n-        }\n+            \/*\n+             * First case :  a comment\n+             *\/\n+            if ((CUR == '<') && (NXT(1) == '!') &&\n+                (NXT(2) == '-') && (NXT(3) == '-')) {\n+                htmlParseComment(ctxt);\n+            }\n@@ -4418,6 +4425,6 @@\n-        \/*\n-         * Third case :  a sub-element.\n-         *\/\n-        else if (CUR == '<') {\n-        htmlParseElement(ctxt);\n-        }\n+            \/*\n+             * Second case : a Processing Instruction.\n+             *\/\n+            else if ((CUR == '<') && (NXT(1) == '?')) {\n+                htmlParsePI(ctxt);\n+            }\n@@ -4425,7 +4432,6 @@\n-        \/*\n-         * Fourth case : a reference. If if has not been resolved,\n-         *    parsing returns it's Name, create the node\n-         *\/\n-        else if (CUR == '&') {\n-        htmlParseReference(ctxt);\n-        }\n+            \/*\n+             * Third case :  a sub-element.\n+             *\/\n+            else if (CUR == '<') {\n+                htmlParseElement(ctxt);\n+            }\n@@ -4433,7 +4439,7 @@\n-        \/*\n-         * Fifth case : end of the resource\n-         *\/\n-        else if (CUR == 0) {\n-        htmlAutoCloseOnEnd(ctxt);\n-        break;\n-        }\n+            \/*\n+             * Fourth case : a reference. If if has not been resolved,\n+             *    parsing returns it's Name, create the node\n+             *\/\n+            else if (CUR == '&') {\n+                htmlParseReference(ctxt);\n+            }\n@@ -4441,5 +4447,14 @@\n-        \/*\n-         * Last case, text. Note that References are handled directly.\n-         *\/\n-        else {\n-        htmlParseCharData(ctxt);\n+            \/*\n+             * Fifth case : end of the resource\n+             *\/\n+            else if (CUR == 0) {\n+                htmlAutoCloseOnEnd(ctxt);\n+                break;\n+            }\n+\n+            \/*\n+             * Last case, text. Note that References are handled directly.\n+             *\/\n+            else {\n+                htmlParseCharData(ctxt);\n+            }\n@@ -4447,1 +4462,0 @@\n-    }\n@@ -4476,3 +4490,3 @@\n-    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-             \"htmlParseElement: context error\\n\", NULL, NULL);\n-    return;\n+        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                     \"htmlParseElement: context error\\n\", NULL, NULL);\n+        return;\n@@ -4488,1 +4502,1 @@\n-    node_info.begin_line = ctxt->input->line;\n+        node_info.begin_line = ctxt->input->line;\n@@ -4494,2 +4508,2 @@\n-    if (CUR == '>')\n-        NEXT;\n+        if (CUR == '>')\n+            NEXT;\n@@ -4504,2 +4518,2 @@\n-    htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,\n-                 \"Tag %s invalid\\n\", name, NULL);\n+        htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,\n+                     \"Tag %s invalid\\n\", name, NULL);\n@@ -4513,4 +4527,4 @@\n-    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n-        ctxt->sax->endElement(ctxt->userData, name);\n-    htmlnamePop(ctxt);\n-    return;\n+        if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n+            ctxt->sax->endElement(ctxt->userData, name);\n+        htmlnamePop(ctxt);\n+        return;\n@@ -4522,2 +4536,2 @@\n-    htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,\n-                 \"Couldn't find end of Start Tag %s\\n\", name, NULL);\n+        htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,\n+                     \"Couldn't find end of Start Tag %s\\n\", name, NULL);\n@@ -4525,7 +4539,7 @@\n-    \/*\n-     * end of parsing of this node.\n-     *\/\n-    if (xmlStrEqual(name, ctxt->name)) {\n-        nodePop(ctxt);\n-        htmlnamePop(ctxt);\n-    }\n+        \/*\n+         * end of parsing of this node.\n+         *\/\n+        if (xmlStrEqual(name, ctxt->name)) {\n+            nodePop(ctxt);\n+            htmlnamePop(ctxt);\n+        }\n@@ -4533,11 +4547,11 @@\n-    \/*\n-     * Capture end position and add node\n-     *\/\n-    if (ctxt->record_info) {\n-       node_info.end_pos = ctxt->input->consumed +\n-                  (CUR_PTR - ctxt->input->base);\n-       node_info.end_line = ctxt->input->line;\n-       node_info.node = ctxt->node;\n-       xmlParserAddNodeInfo(ctxt, &node_info);\n-    }\n-    return;\n+        \/*\n+         * Capture end position and add node\n+         *\/\n+        if (ctxt->record_info) {\n+           node_info.end_pos = ctxt->input->consumed +\n+                              (CUR_PTR - ctxt->input->base);\n+           node_info.end_line = ctxt->input->line;\n+           node_info.node = ctxt->node;\n+           xmlParserAddNodeInfo(ctxt, &node_info);\n+        }\n+        return;\n@@ -4550,4 +4564,4 @@\n-    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n-        ctxt->sax->endElement(ctxt->userData, name);\n-    htmlnamePop(ctxt);\n-    return;\n+        if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n+            ctxt->sax->endElement(ctxt->userData, name);\n+        htmlnamePop(ctxt);\n+        return;\n@@ -4562,4 +4576,4 @@\n-    oldptr = ctxt->input->cur;\n-    htmlParseContent(ctxt);\n-    if (oldptr==ctxt->input->cur) break;\n-    if (ctxt->nameNr < depth) break;\n+        oldptr = ctxt->input->cur;\n+        htmlParseContent(ctxt);\n+        if (oldptr==ctxt->input->cur) break;\n+        if (ctxt->nameNr < depth) break;\n@@ -4579,1 +4593,1 @@\n-    htmlAutoCloseOnEnd(ctxt);\n+        htmlAutoCloseOnEnd(ctxt);\n@@ -4583,1 +4597,1 @@\n-    xmlFree(currentNode);\n+        xmlFree(currentNode);\n@@ -4623,3 +4637,3 @@\n-    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-             \"htmlParseElementInternal: context error\\n\", NULL, NULL);\n-    return;\n+        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                     \"htmlParseElementInternal: context error\\n\", NULL, NULL);\n+        return;\n@@ -4635,1 +4649,1 @@\n-    node_info.begin_line = ctxt->input->line;\n+        node_info.begin_line = ctxt->input->line;\n@@ -4641,2 +4655,2 @@\n-    if (CUR == '>')\n-        NEXT;\n+        if (CUR == '>')\n+            NEXT;\n@@ -4651,2 +4665,2 @@\n-    htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,\n-                 \"Tag %s invalid\\n\", name, NULL);\n+        htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,\n+                     \"Tag %s invalid\\n\", name, NULL);\n@@ -4660,4 +4674,4 @@\n-    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n-        ctxt->sax->endElement(ctxt->userData, name);\n-    htmlnamePop(ctxt);\n-    return;\n+        if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n+            ctxt->sax->endElement(ctxt->userData, name);\n+        htmlnamePop(ctxt);\n+        return;\n@@ -4669,2 +4683,2 @@\n-    htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,\n-                 \"Couldn't find end of Start Tag %s\\n\", name, NULL);\n+        htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,\n+                     \"Couldn't find end of Start Tag %s\\n\", name, NULL);\n@@ -4672,7 +4686,7 @@\n-    \/*\n-     * end of parsing of this node.\n-     *\/\n-    if (xmlStrEqual(name, ctxt->name)) {\n-        nodePop(ctxt);\n-        htmlnamePop(ctxt);\n-    }\n+        \/*\n+         * end of parsing of this node.\n+         *\/\n+        if (xmlStrEqual(name, ctxt->name)) {\n+            nodePop(ctxt);\n+            htmlnamePop(ctxt);\n+        }\n@@ -4683,1 +4697,1 @@\n-    return;\n+        return;\n@@ -4690,4 +4704,4 @@\n-    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n-        ctxt->sax->endElement(ctxt->userData, name);\n-    htmlnamePop(ctxt);\n-    return;\n+        if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n+            ctxt->sax->endElement(ctxt->userData, name);\n+        htmlnamePop(ctxt);\n+        return;\n@@ -4722,3 +4736,3 @@\n-    \/*\n-     * Our tag or one of it's parent or children is ending.\n-     *\/\n+        \/*\n+         * Our tag or one of it's parent or children is ending.\n+         *\/\n@@ -4726,4 +4740,4 @@\n-        if (htmlParseEndTag(ctxt) &&\n-        ((currentNode != NULL) || (ctxt->nameNr == 0))) {\n-        if (currentNode != NULL)\n-            xmlFree(currentNode);\n+            if (htmlParseEndTag(ctxt) &&\n+                ((currentNode != NULL) || (ctxt->nameNr == 0))) {\n+                if (currentNode != NULL)\n+                    xmlFree(currentNode);\n@@ -4731,4 +4745,4 @@\n-            currentNode = xmlStrdup(ctxt->name);\n-            depth = ctxt->nameNr;\n-        }\n-        continue; \/* while *\/\n+                currentNode = xmlStrdup(ctxt->name);\n+                depth = ctxt->nameNr;\n+            }\n+            continue; \/* while *\/\n@@ -4737,11 +4751,20 @@\n-    else if ((CUR == '<') &&\n-             ((IS_ASCII_LETTER(NXT(1))) ||\n-          (NXT(1) == '_') || (NXT(1) == ':'))) {\n-        name = htmlParseHTMLName_nonInvasive(ctxt);\n-        if (name == NULL) {\n-            htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n-             \"htmlParseStartTag: invalid element name\\n\",\n-             NULL, NULL);\n-            \/* Dump the bogus tag like browsers do *\/\n-            while ((CUR == 0) && (CUR != '>'))\n-                NEXT;\n+        else if ((CUR == '<') &&\n+                 ((IS_ASCII_LETTER(NXT(1))) ||\n+                  (NXT(1) == '_') || (NXT(1) == ':'))) {\n+            name = htmlParseHTMLName_nonInvasive(ctxt);\n+            if (name == NULL) {\n+                htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n+                         \"htmlParseStartTag: invalid element name\\n\",\n+                         NULL, NULL);\n+                \/* Dump the bogus tag like browsers do *\/\n+                while ((CUR == 0) && (CUR != '>'))\n+                    NEXT;\n+\n+                htmlParserFinishElementParsing(ctxt);\n+                if (currentNode != NULL)\n+                    xmlFree(currentNode);\n+\n+                currentNode = xmlStrdup(ctxt->name);\n+                depth = ctxt->nameNr;\n+                continue;\n+            }\n@@ -4749,0 +4772,15 @@\n+            if (ctxt->name != NULL) {\n+                if (htmlCheckAutoClose(name, ctxt->name) == 1) {\n+                    htmlAutoClose(ctxt, name);\n+                    continue;\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Has this node been popped out during parsing of\n+         * the next element\n+         *\/\n+        if ((ctxt->nameNr > 0) && (depth >= ctxt->nameNr) &&\n+            (!xmlStrEqual(currentNode, ctxt->name)))\n+             {\n@@ -4750,2 +4788,1 @@\n-            if (currentNode != NULL)\n-                xmlFree(currentNode);\n+            if (currentNode != NULL) xmlFree(currentNode);\n@@ -4758,4 +4795,19 @@\n-        if (ctxt->name != NULL) {\n-            if (htmlCheckAutoClose(name, ctxt->name) == 1) {\n-                htmlAutoClose(ctxt, name);\n-                continue;\n+        if ((CUR != 0) && ((xmlStrEqual(currentNode, BAD_CAST\"script\")) ||\n+            (xmlStrEqual(currentNode, BAD_CAST\"style\")))) {\n+            \/*\n+             * Handle SCRIPT\/STYLE separately\n+             *\/\n+            htmlParseScript(ctxt);\n+        } else {\n+            \/*\n+             * Sometimes DOCTYPE arrives in the middle of the document\n+             *\/\n+            if ((CUR == '<') && (NXT(1) == '!') &&\n+                (UPP(2) == 'D') && (UPP(3) == 'O') &&\n+                (UPP(4) == 'C') && (UPP(5) == 'T') &&\n+                (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n+                (UPP(8) == 'E')) {\n+                htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n+                             \"Misplaced DOCTYPE declaration\\n\",\n+                             BAD_CAST \"DOCTYPE\" , NULL);\n+                htmlParseDocTypeDecl(ctxt);\n@@ -4763,38 +4815,0 @@\n-        }\n-    }\n-\n-    \/*\n-     * Has this node been popped out during parsing of\n-     * the next element\n-     *\/\n-        if ((ctxt->nameNr > 0) && (depth >= ctxt->nameNr) &&\n-        (!xmlStrEqual(currentNode, ctxt->name)))\n-         {\n-        htmlParserFinishElementParsing(ctxt);\n-        if (currentNode != NULL) xmlFree(currentNode);\n-\n-        currentNode = xmlStrdup(ctxt->name);\n-        depth = ctxt->nameNr;\n-        continue;\n-    }\n-\n-    if ((CUR != 0) && ((xmlStrEqual(currentNode, BAD_CAST\"script\")) ||\n-        (xmlStrEqual(currentNode, BAD_CAST\"style\")))) {\n-        \/*\n-         * Handle SCRIPT\/STYLE separately\n-         *\/\n-        htmlParseScript(ctxt);\n-    } else {\n-        \/*\n-         * Sometimes DOCTYPE arrives in the middle of the document\n-         *\/\n-        if ((CUR == '<') && (NXT(1) == '!') &&\n-        (UPP(2) == 'D') && (UPP(3) == 'O') &&\n-        (UPP(4) == 'C') && (UPP(5) == 'T') &&\n-        (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n-        (UPP(8) == 'E')) {\n-        htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n-                     \"Misplaced DOCTYPE declaration\\n\",\n-                 BAD_CAST \"DOCTYPE\" , NULL);\n-        htmlParseDocTypeDecl(ctxt);\n-        }\n@@ -4802,7 +4816,7 @@\n-        \/*\n-         * First case :  a comment\n-         *\/\n-        if ((CUR == '<') && (NXT(1) == '!') &&\n-        (NXT(2) == '-') && (NXT(3) == '-')) {\n-        htmlParseComment(ctxt);\n-        }\n+            \/*\n+             * First case :  a comment\n+             *\/\n+            if ((CUR == '<') && (NXT(1) == '!') &&\n+                (NXT(2) == '-') && (NXT(3) == '-')) {\n+                htmlParseComment(ctxt);\n+            }\n@@ -4810,6 +4824,6 @@\n-        \/*\n-         * Second case : a Processing Instruction.\n-         *\/\n-        else if ((CUR == '<') && (NXT(1) == '?')) {\n-        htmlParsePI(ctxt);\n-        }\n+            \/*\n+             * Second case : a Processing Instruction.\n+             *\/\n+            else if ((CUR == '<') && (NXT(1) == '?')) {\n+                htmlParsePI(ctxt);\n+            }\n@@ -4817,6 +4831,6 @@\n-        \/*\n-         * Third case :  a sub-element.\n-         *\/\n-        else if (CUR == '<') {\n-        htmlParseElementInternal(ctxt);\n-        if (currentNode != NULL) xmlFree(currentNode);\n+            \/*\n+             * Third case :  a sub-element.\n+             *\/\n+            else if (CUR == '<') {\n+                htmlParseElementInternal(ctxt);\n+                if (currentNode != NULL) xmlFree(currentNode);\n@@ -4824,3 +4838,3 @@\n-        currentNode = xmlStrdup(ctxt->name);\n-        depth = ctxt->nameNr;\n-        }\n+                currentNode = xmlStrdup(ctxt->name);\n+                depth = ctxt->nameNr;\n+            }\n@@ -4828,7 +4842,7 @@\n-        \/*\n-         * Fourth case : a reference. If if has not been resolved,\n-         *    parsing returns it's Name, create the node\n-         *\/\n-        else if (CUR == '&') {\n-        htmlParseReference(ctxt);\n-        }\n+            \/*\n+             * Fourth case : a reference. If if has not been resolved,\n+             *    parsing returns it's Name, create the node\n+             *\/\n+            else if (CUR == '&') {\n+                htmlParseReference(ctxt);\n+            }\n@@ -4836,7 +4850,7 @@\n-        \/*\n-         * Fifth case : end of the resource\n-         *\/\n-        else if (CUR == 0) {\n-        htmlAutoCloseOnEnd(ctxt);\n-        break;\n-        }\n+            \/*\n+             * Fifth case : end of the resource\n+             *\/\n+            else if (CUR == 0) {\n+                htmlAutoCloseOnEnd(ctxt);\n+                break;\n+            }\n@@ -4844,5 +4858,6 @@\n-        \/*\n-         * Last case, text. Note that References are handled directly.\n-         *\/\n-        else {\n-        htmlParseCharData(ctxt);\n+            \/*\n+             * Last case, text. Note that References are handled directly.\n+             *\/\n+            else {\n+                htmlParseCharData(ctxt);\n+            }\n@@ -4850,1 +4865,0 @@\n-    }\n@@ -4867,1 +4881,1 @@\n-    htmlParseContentInternal((htmlParserCtxtPtr) ctxt);\n+        htmlParseContentInternal((htmlParserCtxtPtr) ctxt);\n@@ -4892,3 +4906,3 @@\n-    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-             \"htmlParseDocument: context error\\n\", NULL, NULL);\n-    return(XML_ERR_INTERNAL_ERROR);\n+        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                     \"htmlParseDocument: context error\\n\", NULL, NULL);\n+        return(XML_ERR_INTERNAL_ERROR);\n@@ -4907,13 +4921,13 @@\n-    \/*\n-     * Get the 4 first bytes and decode the charset\n-     * if enc != XML_CHAR_ENCODING_NONE\n-     * plug some encoding conversion routines.\n-     *\/\n-    start[0] = RAW;\n-    start[1] = NXT(1);\n-    start[2] = NXT(2);\n-    start[3] = NXT(3);\n-    enc = xmlDetectCharEncoding(&start[0], 4);\n-    if (enc != XML_CHAR_ENCODING_NONE) {\n-        xmlSwitchEncoding(ctxt, enc);\n-    }\n+        \/*\n+         * Get the 4 first bytes and decode the charset\n+         * if enc != XML_CHAR_ENCODING_NONE\n+         * plug some encoding conversion routines.\n+         *\/\n+        start[0] = RAW;\n+        start[1] = NXT(1);\n+        start[2] = NXT(2);\n+        start[3] = NXT(3);\n+        enc = xmlDetectCharEncoding(&start[0], 4);\n+        if (enc != XML_CHAR_ENCODING_NONE) {\n+            xmlSwitchEncoding(ctxt, enc);\n+        }\n@@ -4927,2 +4941,2 @@\n-    htmlParseErr(ctxt, XML_ERR_DOCUMENT_EMPTY,\n-                 \"Document is empty\\n\", NULL, NULL);\n+        htmlParseErr(ctxt, XML_ERR_DOCUMENT_EMPTY,\n+                     \"Document is empty\\n\", NULL, NULL);\n@@ -4932,1 +4946,1 @@\n-    ctxt->sax->startDocument(ctxt->userData);\n+        ctxt->sax->startDocument(ctxt->userData);\n@@ -4940,1 +4954,1 @@\n-       ((CUR == '<') && (NXT(1) == '?'))) {\n+           ((CUR == '<') && (NXT(1) == '?'))) {\n@@ -4943,1 +4957,1 @@\n-    SKIP_BLANKS;\n+        SKIP_BLANKS;\n@@ -4952,5 +4966,5 @@\n-    (UPP(2) == 'D') && (UPP(3) == 'O') &&\n-    (UPP(4) == 'C') && (UPP(5) == 'T') &&\n-    (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n-    (UPP(8) == 'E')) {\n-    htmlParseDocTypeDecl(ctxt);\n+        (UPP(2) == 'D') && (UPP(3) == 'O') &&\n+        (UPP(4) == 'C') && (UPP(5) == 'T') &&\n+        (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n+        (UPP(8) == 'E')) {\n+        htmlParseDocTypeDecl(ctxt);\n@@ -4965,1 +4979,1 @@\n-       ((CUR == '<') && (NXT(1) == '?'))) {\n+           ((CUR == '<') && (NXT(1) == '?'))) {\n@@ -4968,1 +4982,1 @@\n-    SKIP_BLANKS;\n+        SKIP_BLANKS;\n@@ -4980,1 +4994,1 @@\n-    htmlAutoCloseOnEnd(ctxt);\n+        htmlAutoCloseOnEnd(ctxt);\n@@ -4990,6 +5004,6 @@\n-    dtd = xmlGetIntSubset(ctxt->myDoc);\n-    if (dtd == NULL)\n-        ctxt->myDoc->intSubset =\n-        xmlCreateIntSubset(ctxt->myDoc, BAD_CAST \"html\",\n-            BAD_CAST \"-\/\/W3C\/\/DTD HTML 4.0 Transitional\/\/EN\",\n-            BAD_CAST \"http:\/\/www.w3.org\/TR\/REC-html40\/loose.dtd\");\n+        dtd = xmlGetIntSubset(ctxt->myDoc);\n+        if (dtd == NULL)\n+            ctxt->myDoc->intSubset =\n+                xmlCreateIntSubset(ctxt->myDoc, BAD_CAST \"html\",\n+                    BAD_CAST \"-\/\/W3C\/\/DTD HTML 4.0 Transitional\/\/EN\",\n+                    BAD_CAST \"http:\/\/www.w3.org\/TR\/REC-html40\/loose.dtd\");\n@@ -5003,3 +5017,3 @@\n- *                                  *\n- *          Parser contexts handling            *\n- *                                  *\n+ *                                                                      *\n+ *                      Parser contexts handling                        *\n+ *                                                                      *\n@@ -5028,1 +5042,1 @@\n-    return(-1);\n+        return(-1);\n@@ -5033,1 +5047,1 @@\n-    return(-1);\n+        return(-1);\n@@ -5043,4 +5057,4 @@\n-    ctxt->inputNr = 0;\n-    ctxt->inputMax = 0;\n-    ctxt->input = NULL;\n-    return(-1);\n+        ctxt->inputNr = 0;\n+        ctxt->inputMax = 0;\n+        ctxt->input = NULL;\n+        return(-1);\n@@ -5060,7 +5074,7 @@\n-    ctxt->nodeNr = 0;\n-    ctxt->nodeMax = 0;\n-    ctxt->node = NULL;\n-    ctxt->inputNr = 0;\n-    ctxt->inputMax = 0;\n-    ctxt->input = NULL;\n-    return(-1);\n+        ctxt->nodeNr = 0;\n+        ctxt->nodeMax = 0;\n+        ctxt->node = NULL;\n+        ctxt->inputNr = 0;\n+        ctxt->inputMax = 0;\n+        ctxt->input = NULL;\n+        return(-1);\n@@ -5076,10 +5090,10 @@\n-    ctxt->nameNr = 0;\n-    ctxt->nameMax = 0;\n-    ctxt->name = NULL;\n-    ctxt->nodeNr = 0;\n-    ctxt->nodeMax = 0;\n-    ctxt->node = NULL;\n-    ctxt->inputNr = 0;\n-    ctxt->inputMax = 0;\n-    ctxt->input = NULL;\n-    return(-1);\n+        ctxt->nameNr = 0;\n+        ctxt->nameMax = 0;\n+        ctxt->name = NULL;\n+        ctxt->nodeNr = 0;\n+        ctxt->nodeMax = 0;\n+        ctxt->node = NULL;\n+        ctxt->inputNr = 0;\n+        ctxt->inputMax = 0;\n+        ctxt->input = NULL;\n+        return(-1);\n@@ -5098,1 +5112,1 @@\n-    memcpy(sax, &htmlDefaultSAXHandler, sizeof(xmlSAXHandlerV1));\n+        memcpy(sax, &htmlDefaultSAXHandler, sizeof(xmlSAXHandlerV1));\n@@ -5149,1 +5163,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5154,1 +5168,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5175,1 +5189,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5177,1 +5191,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5181,1 +5195,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5188,2 +5202,3 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserInputBuffer(buf);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -5217,1 +5232,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5221,1 +5236,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5224,2 +5239,2 @@\n-    xmlCharEncoding enc;\n-    xmlCharEncodingHandlerPtr handler;\n+        xmlCharEncoding enc;\n+        xmlCharEncodingHandlerPtr handler;\n@@ -5227,3 +5242,3 @@\n-    if (ctxt->input->encoding != NULL)\n-        xmlFree((xmlChar *) ctxt->input->encoding);\n-    ctxt->input->encoding = xmlStrdup((const xmlChar *) encoding);\n+        if (ctxt->input->encoding != NULL)\n+            xmlFree((xmlChar *) ctxt->input->encoding);\n+        ctxt->input->encoding = xmlStrdup((const xmlChar *) encoding);\n@@ -5231,12 +5246,1 @@\n-    enc = xmlParseCharEncoding(encoding);\n-    \/*\n-     * registered set of known encodings\n-     *\/\n-    if (enc != XML_CHAR_ENCODING_ERROR) {\n-        xmlSwitchEncoding(ctxt, enc);\n-        if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n-        htmlParseErr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n-                     \"Unsupported encoding %s\\n\",\n-                 (const xmlChar *) encoding, NULL);\n-        }\n-    } else {\n+        enc = xmlParseCharEncoding(encoding);\n@@ -5244,1 +5248,1 @@\n-         * fallback for unknown encodings\n+         * registered set of known encodings\n@@ -5246,3 +5250,7 @@\n-        handler = xmlFindCharEncodingHandler((const char *) encoding);\n-        if (handler != NULL) {\n-        xmlSwitchToEncoding(ctxt, handler);\n+        if (enc != XML_CHAR_ENCODING_ERROR) {\n+            xmlSwitchEncoding(ctxt, enc);\n+            if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n+                htmlParseErr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n+                             \"Unsupported encoding %s\\n\",\n+                             (const xmlChar *) encoding, NULL);\n+            }\n@@ -5250,3 +5258,11 @@\n-        htmlParseErr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n-                     \"Unsupported encoding %s\\n\",\n-                 (const xmlChar *) encoding, NULL);\n+            \/*\n+             * fallback for unknown encodings\n+             *\/\n+            handler = xmlFindCharEncodingHandler((const char *) encoding);\n+            if (handler != NULL) {\n+                xmlSwitchToEncoding(ctxt, handler);\n+            } else {\n+                htmlParseErr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n+                             \"Unsupported encoding %s\\n\",\n+                             (const xmlChar *) encoding, NULL);\n+            }\n@@ -5255,1 +5271,0 @@\n-    }\n@@ -5261,3 +5276,3 @@\n- *                                  *\n- *  Progressive parsing interfaces              *\n- *                                  *\n+ *                                                                      *\n+ *      Progressive parsing interfaces                          *\n+ *                                                                      *\n@@ -5406,7 +5421,7 @@\n-    mark = htmlParseLookupSequence(ctxt, '-', '-', 0, 0);\n-    if ((mark < 0) ||\n-        (NXT(mark+2) == '>') ||\n-        ((NXT(mark+2) == '!') && (NXT(mark+3) == '>'))) {\n-        return mark;\n-    }\n-    ctxt->checkIndex = cur + mark + 1;\n+        mark = htmlParseLookupSequence(ctxt, '-', '-', 0, 0);\n+        if ((mark < 0) ||\n+            (NXT(mark+2) == '>') ||\n+            ((NXT(mark+2) == '!') && (NXT(mark+3) == '>'))) {\n+            return mark;\n+        }\n+        ctxt->checkIndex = cur + mark + 1;\n@@ -5438,48 +5453,48 @@\n-    case XML_PARSER_EOF:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: try EOF\\n\"); break;\n-    case XML_PARSER_START:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: try START\\n\"); break;\n-    case XML_PARSER_MISC:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: try MISC\\n\");break;\n-    case XML_PARSER_COMMENT:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: try COMMENT\\n\");break;\n-    case XML_PARSER_PROLOG:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: try PROLOG\\n\");break;\n-    case XML_PARSER_START_TAG:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: try START_TAG\\n\");break;\n-    case XML_PARSER_CONTENT:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: try CONTENT\\n\");break;\n-    case XML_PARSER_CDATA_SECTION:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: try CDATA_SECTION\\n\");break;\n-    case XML_PARSER_END_TAG:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: try END_TAG\\n\");break;\n-    case XML_PARSER_ENTITY_DECL:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: try ENTITY_DECL\\n\");break;\n-    case XML_PARSER_ENTITY_VALUE:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: try ENTITY_VALUE\\n\");break;\n-    case XML_PARSER_ATTRIBUTE_VALUE:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: try ATTRIBUTE_VALUE\\n\");break;\n-    case XML_PARSER_DTD:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: try DTD\\n\");break;\n-    case XML_PARSER_EPILOG:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: try EPILOG\\n\");break;\n-    case XML_PARSER_PI:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: try PI\\n\");break;\n-    case XML_PARSER_SYSTEM_LITERAL:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: try SYSTEM_LITERAL\\n\");break;\n+        case XML_PARSER_EOF:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"HPP: try EOF\\n\"); break;\n+        case XML_PARSER_START:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"HPP: try START\\n\"); break;\n+        case XML_PARSER_MISC:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"HPP: try MISC\\n\");break;\n+        case XML_PARSER_COMMENT:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"HPP: try COMMENT\\n\");break;\n+        case XML_PARSER_PROLOG:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"HPP: try PROLOG\\n\");break;\n+        case XML_PARSER_START_TAG:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"HPP: try START_TAG\\n\");break;\n+        case XML_PARSER_CONTENT:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"HPP: try CONTENT\\n\");break;\n+        case XML_PARSER_CDATA_SECTION:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"HPP: try CDATA_SECTION\\n\");break;\n+        case XML_PARSER_END_TAG:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"HPP: try END_TAG\\n\");break;\n+        case XML_PARSER_ENTITY_DECL:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"HPP: try ENTITY_DECL\\n\");break;\n+        case XML_PARSER_ENTITY_VALUE:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"HPP: try ENTITY_VALUE\\n\");break;\n+        case XML_PARSER_ATTRIBUTE_VALUE:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"HPP: try ATTRIBUTE_VALUE\\n\");break;\n+        case XML_PARSER_DTD:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"HPP: try DTD\\n\");break;\n+        case XML_PARSER_EPILOG:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"HPP: try EPILOG\\n\");break;\n+        case XML_PARSER_PI:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"HPP: try PI\\n\");break;\n+        case XML_PARSER_SYSTEM_LITERAL:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"HPP: try SYSTEM_LITERAL\\n\");break;\n@@ -5491,6 +5506,6 @@\n-    in = ctxt->input;\n-    if (in == NULL) break;\n-    if (in->buf == NULL)\n-        avail = in->length - (in->cur - in->base);\n-    else\n-        avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -\n+        in = ctxt->input;\n+        if (in == NULL) break;\n+        if (in->buf == NULL)\n+            avail = in->length - (in->cur - in->base);\n+        else\n+            avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -\n@@ -5498,9 +5513,10 @@\n-    if ((avail == 0) && (terminate)) {\n-        htmlAutoCloseOnEnd(ctxt);\n-        if ((ctxt->nameNr == 0) && (ctxt->instate != XML_PARSER_EOF)) {\n-        \/*\n-         * SAX: end of the document processing.\n-         *\/\n-        ctxt->instate = XML_PARSER_EOF;\n-        if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n-            ctxt->sax->endDocument(ctxt->userData);\n+        if ((avail == 0) && (terminate)) {\n+            htmlAutoCloseOnEnd(ctxt);\n+            if ((ctxt->nameNr == 0) && (ctxt->instate != XML_PARSER_EOF)) {\n+                \/*\n+                 * SAX: end of the document processing.\n+                 *\/\n+                ctxt->instate = XML_PARSER_EOF;\n+                if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n+                    ctxt->sax->endDocument(ctxt->userData);\n+            }\n@@ -5508,1 +5524,0 @@\n-    }\n@@ -5510,1 +5525,1 @@\n-        goto done;\n+            goto done;\n@@ -5517,5 +5532,5 @@\n-    cur = in->cur[0];\n-    if (cur == 0) {\n-        SKIP(1);\n-        continue;\n-    }\n+        cur = in->cur[0];\n+        if (cur == 0) {\n+            SKIP(1);\n+            continue;\n+        }\n@@ -5525,4 +5540,4 @@\n-            \/*\n-         * Document parsing is done !\n-         *\/\n-            goto done;\n+                \/*\n+                 * Document parsing is done !\n+                 *\/\n+                goto done;\n@@ -5530,10 +5545,10 @@\n-            \/*\n-         * Very first chars read from the document flow.\n-         *\/\n-        cur = in->cur[0];\n-        if (IS_BLANK_CH(cur)) {\n-            SKIP_BLANKS;\n-            if (in->buf == NULL)\n-            avail = in->length - (in->cur - in->base);\n-            else\n-            avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -\n+                \/*\n+                 * Very first chars read from the document flow.\n+                 *\/\n+                cur = in->cur[0];\n+                if (IS_BLANK_CH(cur)) {\n+                    SKIP_BLANKS;\n+                    if (in->buf == NULL)\n+                        avail = in->length - (in->cur - in->base);\n+                    else\n+                        avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -\n@@ -5541,18 +5556,18 @@\n-        }\n-        if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n-            ctxt->sax->setDocumentLocator(ctxt->userData,\n-                          &xmlDefaultSAXLocator);\n-        if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n-                (!ctxt->disableSAX))\n-            ctxt->sax->startDocument(ctxt->userData);\n-\n-        cur = in->cur[0];\n-        next = in->cur[1];\n-        if ((cur == '<') && (next == '!') &&\n-            (UPP(2) == 'D') && (UPP(3) == 'O') &&\n-            (UPP(4) == 'C') && (UPP(5) == 'T') &&\n-            (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n-            (UPP(8) == 'E')) {\n-            if ((!terminate) &&\n-                (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))\n-            goto done;\n+                }\n+                if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n+                    ctxt->sax->setDocumentLocator(ctxt->userData,\n+                                                  &xmlDefaultSAXLocator);\n+                if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n+                    (!ctxt->disableSAX))\n+                    ctxt->sax->startDocument(ctxt->userData);\n+\n+                cur = in->cur[0];\n+                next = in->cur[1];\n+                if ((cur == '<') && (next == '!') &&\n+                    (UPP(2) == 'D') && (UPP(3) == 'O') &&\n+                    (UPP(4) == 'C') && (UPP(5) == 'T') &&\n+                    (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n+                    (UPP(8) == 'E')) {\n+                    if ((!terminate) &&\n+                        (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))\n+                        goto done;\n@@ -5560,2 +5575,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: Parsing internal subset\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: Parsing internal subset\\n\");\n@@ -5563,2 +5578,2 @@\n-            htmlParseDocTypeDecl(ctxt);\n-            ctxt->instate = XML_PARSER_PROLOG;\n+                    htmlParseDocTypeDecl(ctxt);\n+                    ctxt->instate = XML_PARSER_PROLOG;\n@@ -5566,2 +5581,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: entering PROLOG\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: entering PROLOG\\n\");\n@@ -5570,1 +5585,1 @@\n-            ctxt->instate = XML_PARSER_MISC;\n+                    ctxt->instate = XML_PARSER_MISC;\n@@ -5572,2 +5587,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: entering MISC\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: entering MISC\\n\");\n@@ -5575,2 +5590,2 @@\n-        }\n-        break;\n+                }\n+                break;\n@@ -5578,5 +5593,5 @@\n-        SKIP_BLANKS;\n-        if (in->buf == NULL)\n-            avail = in->length - (in->cur - in->base);\n-        else\n-            avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -\n+                SKIP_BLANKS;\n+                if (in->buf == NULL)\n+                    avail = in->length - (in->cur - in->base);\n+                else\n+                    avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -\n@@ -5584,21 +5599,21 @@\n-        \/*\n-         * no chars in buffer\n-         *\/\n-        if (avail < 1)\n-            goto done;\n-        \/*\n-         * not enough chars in buffer\n-         *\/\n-        if (avail < 2) {\n-            if (!terminate)\n-            goto done;\n-            else\n-            next = ' ';\n-        } else {\n-            next = in->cur[1];\n-        }\n-        cur = in->cur[0];\n-            if ((cur == '<') && (next == '!') &&\n-            (in->cur[2] == '-') && (in->cur[3] == '-')) {\n-            if ((!terminate) && (htmlParseLookupCommentEnd(ctxt) < 0))\n-            goto done;\n+                \/*\n+                 * no chars in buffer\n+                 *\/\n+                if (avail < 1)\n+                    goto done;\n+                \/*\n+                 * not enough chars in buffer\n+                 *\/\n+                if (avail < 2) {\n+                    if (!terminate)\n+                        goto done;\n+                    else\n+                        next = ' ';\n+                } else {\n+                    next = in->cur[1];\n+                }\n+                cur = in->cur[0];\n+                if ((cur == '<') && (next == '!') &&\n+                    (in->cur[2] == '-') && (in->cur[3] == '-')) {\n+                    if ((!terminate) && (htmlParseLookupCommentEnd(ctxt) < 0))\n+                        goto done;\n@@ -5606,2 +5621,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: Parsing Comment\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: Parsing Comment\\n\");\n@@ -5609,6 +5624,6 @@\n-            htmlParseComment(ctxt);\n-            ctxt->instate = XML_PARSER_MISC;\n-            } else if ((cur == '<') && (next == '?')) {\n-            if ((!terminate) &&\n-                (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))\n-            goto done;\n+                    htmlParseComment(ctxt);\n+                    ctxt->instate = XML_PARSER_MISC;\n+                } else if ((cur == '<') && (next == '?')) {\n+                    if ((!terminate) &&\n+                        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))\n+                        goto done;\n@@ -5616,2 +5631,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: Parsing PI\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: Parsing PI\\n\");\n@@ -5619,10 +5634,10 @@\n-            htmlParsePI(ctxt);\n-            ctxt->instate = XML_PARSER_MISC;\n-        } else if ((cur == '<') && (next == '!') &&\n-            (UPP(2) == 'D') && (UPP(3) == 'O') &&\n-            (UPP(4) == 'C') && (UPP(5) == 'T') &&\n-            (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n-            (UPP(8) == 'E')) {\n-            if ((!terminate) &&\n-                (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))\n-            goto done;\n+                    htmlParsePI(ctxt);\n+                    ctxt->instate = XML_PARSER_MISC;\n+                } else if ((cur == '<') && (next == '!') &&\n+                    (UPP(2) == 'D') && (UPP(3) == 'O') &&\n+                    (UPP(4) == 'C') && (UPP(5) == 'T') &&\n+                    (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n+                    (UPP(8) == 'E')) {\n+                    if ((!terminate) &&\n+                        (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))\n+                        goto done;\n@@ -5630,2 +5645,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: Parsing internal subset\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: Parsing internal subset\\n\");\n@@ -5633,2 +5648,2 @@\n-            htmlParseDocTypeDecl(ctxt);\n-            ctxt->instate = XML_PARSER_PROLOG;\n+                    htmlParseDocTypeDecl(ctxt);\n+                    ctxt->instate = XML_PARSER_PROLOG;\n@@ -5636,2 +5651,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: entering PROLOG\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: entering PROLOG\\n\");\n@@ -5639,5 +5654,5 @@\n-        } else if ((cur == '<') && (next == '!') &&\n-                   (avail < 9)) {\n-            goto done;\n-        } else {\n-            ctxt->instate = XML_PARSER_CONTENT;\n+                } else if ((cur == '<') && (next == '!') &&\n+                           (avail < 9)) {\n+                    goto done;\n+                } else {\n+                    ctxt->instate = XML_PARSER_CONTENT;\n@@ -5645,2 +5660,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: entering START_TAG\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: entering START_TAG\\n\");\n@@ -5648,2 +5663,2 @@\n-        }\n-        break;\n+                }\n+                break;\n@@ -5651,5 +5666,5 @@\n-        SKIP_BLANKS;\n-        if (in->buf == NULL)\n-            avail = in->length - (in->cur - in->base);\n-        else\n-            avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -\n+                SKIP_BLANKS;\n+                if (in->buf == NULL)\n+                    avail = in->length - (in->cur - in->base);\n+                else\n+                    avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -\n@@ -5657,8 +5672,8 @@\n-        if (avail < 2)\n-            goto done;\n-        cur = in->cur[0];\n-        next = in->cur[1];\n-        if ((cur == '<') && (next == '!') &&\n-            (in->cur[2] == '-') && (in->cur[3] == '-')) {\n-            if ((!terminate) && (htmlParseLookupCommentEnd(ctxt) < 0))\n-            goto done;\n+                if (avail < 2)\n+                    goto done;\n+                cur = in->cur[0];\n+                next = in->cur[1];\n+                if ((cur == '<') && (next == '!') &&\n+                    (in->cur[2] == '-') && (in->cur[3] == '-')) {\n+                    if ((!terminate) && (htmlParseLookupCommentEnd(ctxt) < 0))\n+                        goto done;\n@@ -5666,2 +5681,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: Parsing Comment\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: Parsing Comment\\n\");\n@@ -5669,6 +5684,6 @@\n-            htmlParseComment(ctxt);\n-            ctxt->instate = XML_PARSER_PROLOG;\n-            } else if ((cur == '<') && (next == '?')) {\n-            if ((!terminate) &&\n-                (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))\n-            goto done;\n+                    htmlParseComment(ctxt);\n+                    ctxt->instate = XML_PARSER_PROLOG;\n+                } else if ((cur == '<') && (next == '?')) {\n+                    if ((!terminate) &&\n+                        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))\n+                        goto done;\n@@ -5676,2 +5691,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: Parsing PI\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: Parsing PI\\n\");\n@@ -5679,7 +5694,7 @@\n-            htmlParsePI(ctxt);\n-            ctxt->instate = XML_PARSER_PROLOG;\n-        } else if ((cur == '<') && (next == '!') &&\n-                   (avail < 4)) {\n-            goto done;\n-        } else {\n-            ctxt->instate = XML_PARSER_CONTENT;\n+                    htmlParsePI(ctxt);\n+                    ctxt->instate = XML_PARSER_PROLOG;\n+                } else if ((cur == '<') && (next == '!') &&\n+                           (avail < 4)) {\n+                    goto done;\n+                } else {\n+                    ctxt->instate = XML_PARSER_CONTENT;\n@@ -5687,2 +5702,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: entering START_TAG\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: entering START_TAG\\n\");\n@@ -5690,2 +5705,2 @@\n-        }\n-        break;\n+                }\n+                break;\n@@ -5693,4 +5708,4 @@\n-        if (in->buf == NULL)\n-            avail = in->length - (in->cur - in->base);\n-        else\n-            avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -\n+                if (in->buf == NULL)\n+                    avail = in->length - (in->cur - in->base);\n+                else\n+                    avail = (ptrdiff_t)xmlBufUse(in->buf->buffer) -\n@@ -5698,14 +5713,14 @@\n-        if (avail < 1)\n-            goto done;\n-        cur = in->cur[0];\n-        if (IS_BLANK_CH(cur)) {\n-            htmlParseCharData(ctxt);\n-            goto done;\n-        }\n-        if (avail < 2)\n-            goto done;\n-        next = in->cur[1];\n-            if ((cur == '<') && (next == '!') &&\n-            (in->cur[2] == '-') && (in->cur[3] == '-')) {\n-            if ((!terminate) && (htmlParseLookupCommentEnd(ctxt) < 0))\n-            goto done;\n+                if (avail < 1)\n+                    goto done;\n+                cur = in->cur[0];\n+                if (IS_BLANK_CH(cur)) {\n+                    htmlParseCharData(ctxt);\n+                    goto done;\n+                }\n+                if (avail < 2)\n+                    goto done;\n+                next = in->cur[1];\n+                if ((cur == '<') && (next == '!') &&\n+                    (in->cur[2] == '-') && (in->cur[3] == '-')) {\n+                    if ((!terminate) && (htmlParseLookupCommentEnd(ctxt) < 0))\n+                        goto done;\n@@ -5713,2 +5728,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: Parsing Comment\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: Parsing Comment\\n\");\n@@ -5716,6 +5731,6 @@\n-            htmlParseComment(ctxt);\n-            ctxt->instate = XML_PARSER_EPILOG;\n-            } else if ((cur == '<') && (next == '?')) {\n-            if ((!terminate) &&\n-                (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))\n-            goto done;\n+                    htmlParseComment(ctxt);\n+                    ctxt->instate = XML_PARSER_EPILOG;\n+                } else if ((cur == '<') && (next == '?')) {\n+                    if ((!terminate) &&\n+                        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))\n+                        goto done;\n@@ -5723,2 +5738,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: Parsing PI\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: Parsing PI\\n\");\n@@ -5726,9 +5741,9 @@\n-            htmlParsePI(ctxt);\n-            ctxt->instate = XML_PARSER_EPILOG;\n-        } else if ((cur == '<') && (next == '!') &&\n-                   (avail < 4)) {\n-            goto done;\n-        } else {\n-            ctxt->errNo = XML_ERR_DOCUMENT_END;\n-            ctxt->wellFormed = 0;\n-            ctxt->instate = XML_PARSER_EOF;\n+                    htmlParsePI(ctxt);\n+                    ctxt->instate = XML_PARSER_EPILOG;\n+                } else if ((cur == '<') && (next == '!') &&\n+                           (avail < 4)) {\n+                    goto done;\n+                } else {\n+                    ctxt->errNo = XML_ERR_DOCUMENT_END;\n+                    ctxt->wellFormed = 0;\n+                    ctxt->instate = XML_PARSER_EOF;\n@@ -5736,2 +5751,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: entering EOF\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: entering EOF\\n\");\n@@ -5739,5 +5754,5 @@\n-            if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n-            ctxt->sax->endDocument(ctxt->userData);\n-            goto done;\n-        }\n-        break;\n+                    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n+                        ctxt->sax->endDocument(ctxt->userData);\n+                    goto done;\n+                }\n+                break;\n@@ -5745,3 +5760,3 @@\n-            const xmlChar *name;\n-        int failed;\n-        const htmlElemDesc * info;\n+                const xmlChar *name;\n+                int failed;\n+                const htmlElemDesc * info;\n@@ -5749,19 +5764,19 @@\n-        \/*\n-         * no chars in buffer\n-         *\/\n-        if (avail < 1)\n-            goto done;\n-        \/*\n-         * not enough chars in buffer\n-         *\/\n-        if (avail < 2) {\n-            if (!terminate)\n-            goto done;\n-            else\n-            next = ' ';\n-        } else {\n-            next = in->cur[1];\n-        }\n-        cur = in->cur[0];\n-            if (cur != '<') {\n-            ctxt->instate = XML_PARSER_CONTENT;\n+                \/*\n+                 * no chars in buffer\n+                 *\/\n+                if (avail < 1)\n+                    goto done;\n+                \/*\n+                 * not enough chars in buffer\n+                 *\/\n+                if (avail < 2) {\n+                    if (!terminate)\n+                        goto done;\n+                    else\n+                        next = ' ';\n+                } else {\n+                    next = in->cur[1];\n+                }\n+                cur = in->cur[0];\n+                if (cur != '<') {\n+                    ctxt->instate = XML_PARSER_CONTENT;\n@@ -5769,2 +5784,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: entering CONTENT\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: entering CONTENT\\n\");\n@@ -5772,5 +5787,5 @@\n-            break;\n-        }\n-        if (next == '\/') {\n-            ctxt->instate = XML_PARSER_END_TAG;\n-            ctxt->checkIndex = 0;\n+                    break;\n+                }\n+                if (next == '\/') {\n+                    ctxt->instate = XML_PARSER_END_TAG;\n+                    ctxt->checkIndex = 0;\n@@ -5778,2 +5793,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: entering END_TAG\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: entering END_TAG\\n\");\n@@ -5781,5 +5796,5 @@\n-            break;\n-        }\n-        if ((!terminate) &&\n-            (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))\n-            goto done;\n+                    break;\n+                }\n+                if ((!terminate) &&\n+                    (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))\n+                    goto done;\n@@ -5788,5 +5803,5 @@\n-            if (ctxt->record_info) {\n-                 node_info.begin_pos = ctxt->input->consumed +\n-                                    (CUR_PTR - ctxt->input->base);\n-                 node_info.begin_line = ctxt->input->line;\n-            }\n+                if (ctxt->record_info) {\n+                     node_info.begin_pos = ctxt->input->consumed +\n+                                        (CUR_PTR - ctxt->input->base);\n+                     node_info.begin_line = ctxt->input->line;\n+                }\n@@ -5795,8 +5810,8 @@\n-        failed = htmlParseStartTag(ctxt);\n-        name = ctxt->name;\n-        if ((failed == -1) ||\n-            (name == NULL)) {\n-            if (CUR == '>')\n-            NEXT;\n-            break;\n-        }\n+                failed = htmlParseStartTag(ctxt);\n+                name = ctxt->name;\n+                if ((failed == -1) ||\n+                    (name == NULL)) {\n+                    if (CUR == '>')\n+                        NEXT;\n+                    break;\n+                }\n@@ -5804,8 +5819,8 @@\n-        \/*\n-         * Lookup the info for that element.\n-         *\/\n-        info = htmlTagLookup(name);\n-        if (info == NULL) {\n-            htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,\n-                         \"Tag %s invalid\\n\", name, NULL);\n-        }\n+                \/*\n+                 * Lookup the info for that element.\n+                 *\/\n+                info = htmlTagLookup(name);\n+                if (info == NULL) {\n+                    htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,\n+                                 \"Tag %s invalid\\n\", name, NULL);\n+                }\n@@ -5813,9 +5828,9 @@\n-        \/*\n-         * Check for an Empty Element labeled the XML\/SGML way\n-         *\/\n-        if ((CUR == '\/') && (NXT(1) == '>')) {\n-            SKIP(2);\n-            if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n-            ctxt->sax->endElement(ctxt->userData, name);\n-            htmlnamePop(ctxt);\n-            ctxt->instate = XML_PARSER_CONTENT;\n+                \/*\n+                 * Check for an Empty Element labeled the XML\/SGML way\n+                 *\/\n+                if ((CUR == '\/') && (NXT(1) == '>')) {\n+                    SKIP(2);\n+                    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n+                        ctxt->sax->endElement(ctxt->userData, name);\n+                    htmlnamePop(ctxt);\n+                    ctxt->instate = XML_PARSER_CONTENT;\n@@ -5823,2 +5838,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: entering CONTENT\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: entering CONTENT\\n\");\n@@ -5826,9 +5841,2 @@\n-            break;\n-        }\n-\n-        if (CUR == '>') {\n-            NEXT;\n-        } else {\n-            htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,\n-                         \"Couldn't find end of Start Tag %s\\n\",\n-                 name, NULL);\n+                    break;\n+                }\n@@ -5836,7 +5844,14 @@\n-            \/*\n-             * end of parsing of this node.\n-             *\/\n-            if (xmlStrEqual(name, ctxt->name)) {\n-            nodePop(ctxt);\n-            htmlnamePop(ctxt);\n-            }\n+                if (CUR == '>') {\n+                    NEXT;\n+                } else {\n+                    htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,\n+                                 \"Couldn't find end of Start Tag %s\\n\",\n+                                 name, NULL);\n+\n+                    \/*\n+                     * end of parsing of this node.\n+                     *\/\n+                    if (xmlStrEqual(name, ctxt->name)) {\n+                        nodePop(ctxt);\n+                        htmlnamePop(ctxt);\n+                    }\n@@ -5844,2 +5859,2 @@\n-            if (ctxt->record_info)\n-                htmlNodeInfoPush(ctxt, &node_info);\n+                    if (ctxt->record_info)\n+                        htmlNodeInfoPush(ctxt, &node_info);\n@@ -5847,1 +5862,1 @@\n-            ctxt->instate = XML_PARSER_CONTENT;\n+                    ctxt->instate = XML_PARSER_CONTENT;\n@@ -5849,2 +5864,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: entering CONTENT\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"HPP: entering CONTENT\\n\");\n@@ -5852,2 +5867,2 @@\n-            break;\n-        }\n+                    break;\n+                }\n@@ -5855,8 +5870,8 @@\n-        \/*\n-         * Check for an Empty Element from DTD definition\n-         *\/\n-        if ((info != NULL) && (info->empty)) {\n-            if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n-            ctxt->sax->endElement(ctxt->userData, name);\n-            htmlnamePop(ctxt);\n-        }\n+                \/*\n+                 * Check for an Empty Element from DTD definition\n+                 *\/\n+                if ((info != NULL) && (info->empty)) {\n+                    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n+                        ctxt->sax->endElement(ctxt->userData, name);\n+                    htmlnamePop(ctxt);\n+                }\n@@ -5865,1 +5880,1 @@\n-                htmlNodeInfoPush(ctxt, &node_info);\n+                    htmlNodeInfoPush(ctxt, &node_info);\n@@ -5867,1 +5882,1 @@\n-        ctxt->instate = XML_PARSER_CONTENT;\n+                ctxt->instate = XML_PARSER_CONTENT;\n@@ -5869,2 +5884,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: entering CONTENT\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"HPP: entering CONTENT\\n\");\n@@ -5873,1 +5888,1 @@\n-        }\n+            }\n@@ -5875,1 +5890,1 @@\n-        xmlChar chr[2] = { 0, 0 };\n+                xmlChar chr[2] = { 0, 0 };\n@@ -5878,24 +5893,9 @@\n-         * Handle preparsed entities and charRef\n-         *\/\n-        if (ctxt->token != 0) {\n-            chr[0] = (xmlChar) ctxt->token;\n-            htmlCheckParagraph(ctxt);\n-            if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL))\n-            ctxt->sax->characters(ctxt->userData, chr, 1);\n-            ctxt->token = 0;\n-            ctxt->checkIndex = 0;\n-        }\n-        if ((avail == 1) && (terminate)) {\n-            cur = in->cur[0];\n-            if ((cur != '<') && (cur != '&')) {\n-            if (ctxt->sax != NULL) {\n-                            chr[0] = cur;\n-                if (IS_BLANK_CH(cur)) {\n-                if (ctxt->keepBlanks) {\n-                    if (ctxt->sax->characters != NULL)\n-                    ctxt->sax->characters(\n-                        ctxt->userData, chr, 1);\n-                } else {\n-                    if (ctxt->sax->ignorableWhitespace != NULL)\n-                    ctxt->sax->ignorableWhitespace(\n-                        ctxt->userData, chr, 1);\n+                 * Handle preparsed entities and charRef\n+                 *\/\n+                if (ctxt->token != 0) {\n+                    chr[0] = (xmlChar) ctxt->token;\n+                    htmlCheckParagraph(ctxt);\n+                    if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL))\n+                        ctxt->sax->characters(ctxt->userData, chr, 1);\n+                    ctxt->token = 0;\n+                    ctxt->checkIndex = 0;\n@@ -5903,5 +5903,27 @@\n-                } else {\n-                htmlCheckParagraph(ctxt);\n-                if (ctxt->sax->characters != NULL)\n-                    ctxt->sax->characters(\n-                        ctxt->userData, chr, 1);\n+                if ((avail == 1) && (terminate)) {\n+                    cur = in->cur[0];\n+                    if ((cur != '<') && (cur != '&')) {\n+                        if (ctxt->sax != NULL) {\n+                            chr[0] = cur;\n+                            if (IS_BLANK_CH(cur)) {\n+                                if (ctxt->keepBlanks) {\n+                                    if (ctxt->sax->characters != NULL)\n+                                        ctxt->sax->characters(\n+                                                ctxt->userData, chr, 1);\n+                                } else {\n+                                    if (ctxt->sax->ignorableWhitespace != NULL)\n+                                        ctxt->sax->ignorableWhitespace(\n+                                                ctxt->userData, chr, 1);\n+                                }\n+                            } else {\n+                                htmlCheckParagraph(ctxt);\n+                                if (ctxt->sax->characters != NULL)\n+                                    ctxt->sax->characters(\n+                                            ctxt->userData, chr, 1);\n+                            }\n+                        }\n+                        ctxt->token = 0;\n+                        ctxt->checkIndex = 0;\n+                        in->cur++;\n+                        break;\n+                    }\n@@ -5909,31 +5931,24 @@\n-            }\n-            ctxt->token = 0;\n-            ctxt->checkIndex = 0;\n-            in->cur++;\n-            break;\n-            }\n-        }\n-        if (avail < 2)\n-            goto done;\n-        cur = in->cur[0];\n-        next = in->cur[1];\n-        if ((xmlStrEqual(ctxt->name, BAD_CAST\"script\")) ||\n-            (xmlStrEqual(ctxt->name, BAD_CAST\"style\"))) {\n-            \/*\n-             * Handle SCRIPT\/STYLE separately\n-             *\/\n-            if (!terminate) {\n-                int idx;\n-            xmlChar val;\n-\n-            idx = htmlParseLookupSequence(ctxt, '<', '\/', 0, 0);\n-            if (idx < 0)\n-                goto done;\n-                val = in->cur[idx + 2];\n-            if (val == 0) \/* bad cut of input *\/\n-                goto done;\n-            }\n-            htmlParseScript(ctxt);\n-            if ((cur == '<') && (next == '\/')) {\n-            ctxt->instate = XML_PARSER_END_TAG;\n-            ctxt->checkIndex = 0;\n+                if (avail < 2)\n+                    goto done;\n+                cur = in->cur[0];\n+                next = in->cur[1];\n+                if ((xmlStrEqual(ctxt->name, BAD_CAST\"script\")) ||\n+                    (xmlStrEqual(ctxt->name, BAD_CAST\"style\"))) {\n+                    \/*\n+                     * Handle SCRIPT\/STYLE separately\n+                     *\/\n+                    if (!terminate) {\n+                        int idx;\n+                        xmlChar val;\n+\n+                        idx = htmlParseLookupSequence(ctxt, '<', '\/', 0, 0);\n+                        if (idx < 0)\n+                            goto done;\n+                        val = in->cur[idx + 2];\n+                        if (val == 0) \/* bad cut of input *\/\n+                            goto done;\n+                    }\n+                    htmlParseScript(ctxt);\n+                    if ((cur == '<') && (next == '\/')) {\n+                        ctxt->instate = XML_PARSER_END_TAG;\n+                        ctxt->checkIndex = 0;\n@@ -5941,2 +5956,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: entering END_TAG\\n\");\n+                        xmlGenericError(xmlGenericErrorContext,\n+                                \"HPP: entering END_TAG\\n\");\n@@ -5944,22 +5959,22 @@\n-            break;\n-            }\n-        } else {\n-            \/*\n-             * Sometimes DOCTYPE arrives in the middle of the document\n-             *\/\n-            if ((cur == '<') && (next == '!') &&\n-            (UPP(2) == 'D') && (UPP(3) == 'O') &&\n-            (UPP(4) == 'C') && (UPP(5) == 'T') &&\n-            (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n-            (UPP(8) == 'E')) {\n-            if ((!terminate) &&\n-                (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))\n-                goto done;\n-            htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n-                         \"Misplaced DOCTYPE declaration\\n\",\n-                     BAD_CAST \"DOCTYPE\" , NULL);\n-            htmlParseDocTypeDecl(ctxt);\n-            } else if ((cur == '<') && (next == '!') &&\n-            (in->cur[2] == '-') && (in->cur[3] == '-')) {\n-            if ((!terminate) && (htmlParseLookupCommentEnd(ctxt) < 0))\n-                goto done;\n+                        break;\n+                    }\n+                } else {\n+                    \/*\n+                     * Sometimes DOCTYPE arrives in the middle of the document\n+                     *\/\n+                    if ((cur == '<') && (next == '!') &&\n+                        (UPP(2) == 'D') && (UPP(3) == 'O') &&\n+                        (UPP(4) == 'C') && (UPP(5) == 'T') &&\n+                        (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n+                        (UPP(8) == 'E')) {\n+                        if ((!terminate) &&\n+                            (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))\n+                            goto done;\n+                        htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n+                                     \"Misplaced DOCTYPE declaration\\n\",\n+                                     BAD_CAST \"DOCTYPE\" , NULL);\n+                        htmlParseDocTypeDecl(ctxt);\n+                    } else if ((cur == '<') && (next == '!') &&\n+                        (in->cur[2] == '-') && (in->cur[3] == '-')) {\n+                        if ((!terminate) && (htmlParseLookupCommentEnd(ctxt) < 0))\n+                            goto done;\n@@ -5967,2 +5982,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: Parsing Comment\\n\");\n+                        xmlGenericError(xmlGenericErrorContext,\n+                                \"HPP: Parsing Comment\\n\");\n@@ -5970,6 +5985,6 @@\n-            htmlParseComment(ctxt);\n-            ctxt->instate = XML_PARSER_CONTENT;\n-            } else if ((cur == '<') && (next == '?')) {\n-            if ((!terminate) &&\n-                (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))\n-                goto done;\n+                        htmlParseComment(ctxt);\n+                        ctxt->instate = XML_PARSER_CONTENT;\n+                    } else if ((cur == '<') && (next == '?')) {\n+                        if ((!terminate) &&\n+                            (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))\n+                            goto done;\n@@ -5977,2 +5992,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: Parsing PI\\n\");\n+                        xmlGenericError(xmlGenericErrorContext,\n+                                \"HPP: Parsing PI\\n\");\n@@ -5980,7 +5995,7 @@\n-            htmlParsePI(ctxt);\n-            ctxt->instate = XML_PARSER_CONTENT;\n-            } else if ((cur == '<') && (next == '!') && (avail < 4)) {\n-            goto done;\n-            } else if ((cur == '<') && (next == '\/')) {\n-            ctxt->instate = XML_PARSER_END_TAG;\n-            ctxt->checkIndex = 0;\n+                        htmlParsePI(ctxt);\n+                        ctxt->instate = XML_PARSER_CONTENT;\n+                    } else if ((cur == '<') && (next == '!') && (avail < 4)) {\n+                        goto done;\n+                    } else if ((cur == '<') && (next == '\/')) {\n+                        ctxt->instate = XML_PARSER_END_TAG;\n+                        ctxt->checkIndex = 0;\n@@ -5988,2 +6003,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: entering END_TAG\\n\");\n+                        xmlGenericError(xmlGenericErrorContext,\n+                                \"HPP: entering END_TAG\\n\");\n@@ -5991,2 +6006,2 @@\n-            break;\n-            } else if (cur == '<') {\n+                        break;\n+                    } else if (cur == '<') {\n@@ -5995,10 +6010,2 @@\n-                        \/*\n-                         * Only switch to START_TAG if the next character\n-                         * starts a valid name. Otherwise, htmlParseStartTag\n-                         * might return without consuming all characters\n-                         * up to the final '>'.\n-                         *\/\n-                        if ((IS_ASCII_LETTER(next)) ||\n-                            (next == '_') || (next == ':') || (next == '.')) {\n-                            ctxt->instate = XML_PARSER_START_TAG;\n-                            ctxt->checkIndex = 0;\n+                        ctxt->instate = XML_PARSER_START_TAG;\n+                        ctxt->checkIndex = 0;\n@@ -6006,2 +6013,2 @@\n-                            xmlGenericError(xmlGenericErrorContext,\n-                                    \"HPP: entering START_TAG\\n\");\n+                        xmlGenericError(xmlGenericErrorContext,\n+                                \"HPP: entering START_TAG\\n\");\n@@ -6009,21 +6016,9 @@\n-                        } else {\n-                            htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n-                                         \"htmlParseTryOrFinish: \"\n-                                         \"invalid element name\\n\",\n-                                         NULL, NULL);\n-                            htmlCheckParagraph(ctxt);\n-                            if ((ctxt->sax != NULL) &&\n-                                (ctxt->sax->characters != NULL))\n-                                ctxt->sax->characters(ctxt->userData,\n-                                                      in->cur, 1);\n-                            NEXT;\n-                        }\n-            break;\n-            } else {\n-                \/*\n-             * check that the text sequence is complete\n-             * before handing out the data to the parser\n-             * to avoid problems with erroneous end of\n-             * data detection.\n-             *\/\n-            if ((!terminate) &&\n+                        break;\n+                    } else {\n+                        \/*\n+                         * check that the text sequence is complete\n+                         * before handing out the data to the parser\n+                         * to avoid problems with erroneous end of\n+                         * data detection.\n+                         *\/\n+                        if ((!terminate) &&\n@@ -6031,2 +6026,2 @@\n-                goto done;\n-            ctxt->checkIndex = 0;\n+                            goto done;\n+                        ctxt->checkIndex = 0;\n@@ -6034,2 +6029,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"HPP: Parsing char data\\n\");\n+                        xmlGenericError(xmlGenericErrorContext,\n+                                \"HPP: Parsing char data\\n\");\n@@ -6040,1 +6035,1 @@\n-                    htmlParseReference(ctxt);\n+                                htmlParseReference(ctxt);\n@@ -6042,1 +6037,1 @@\n-                    htmlParseCharData(ctxt);\n+                                htmlParseCharData(ctxt);\n@@ -6046,2 +6041,2 @@\n-            }\n-        }\n+                    }\n+                }\n@@ -6049,2 +6044,2 @@\n-        break;\n-        }\n+                break;\n+            }\n@@ -6052,12 +6047,12 @@\n-        if (avail < 2)\n-            goto done;\n-        if ((!terminate) &&\n-            (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))\n-            goto done;\n-        htmlParseEndTag(ctxt);\n-        if (ctxt->nameNr == 0) {\n-            ctxt->instate = XML_PARSER_EPILOG;\n-        } else {\n-            ctxt->instate = XML_PARSER_CONTENT;\n-        }\n-        ctxt->checkIndex = 0;\n+                if (avail < 2)\n+                    goto done;\n+                if ((!terminate) &&\n+                    (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))\n+                    goto done;\n+                htmlParseEndTag(ctxt);\n+                if (ctxt->nameNr == 0) {\n+                    ctxt->instate = XML_PARSER_EPILOG;\n+                } else {\n+                    ctxt->instate = XML_PARSER_CONTENT;\n+                }\n+                ctxt->checkIndex = 0;\n@@ -6065,2 +6060,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: entering CONTENT\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"HPP: entering CONTENT\\n\");\n@@ -6068,1 +6063,1 @@\n-            break;\n+                break;\n@@ -6070,5 +6065,5 @@\n-        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-            \"HPP: internal error, state == CDATA\\n\",\n-                 NULL, NULL);\n-        ctxt->instate = XML_PARSER_CONTENT;\n-        ctxt->checkIndex = 0;\n+                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                        \"HPP: internal error, state == CDATA\\n\",\n+                             NULL, NULL);\n+                ctxt->instate = XML_PARSER_CONTENT;\n+                ctxt->checkIndex = 0;\n@@ -6076,2 +6071,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: entering CONTENT\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"HPP: entering CONTENT\\n\");\n@@ -6079,1 +6074,1 @@\n-        break;\n+                break;\n@@ -6081,5 +6076,5 @@\n-        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-            \"HPP: internal error, state == DTD\\n\",\n-                 NULL, NULL);\n-        ctxt->instate = XML_PARSER_CONTENT;\n-        ctxt->checkIndex = 0;\n+                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                        \"HPP: internal error, state == DTD\\n\",\n+                             NULL, NULL);\n+                ctxt->instate = XML_PARSER_CONTENT;\n+                ctxt->checkIndex = 0;\n@@ -6087,2 +6082,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: entering CONTENT\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"HPP: entering CONTENT\\n\");\n@@ -6090,1 +6085,1 @@\n-        break;\n+                break;\n@@ -6092,5 +6087,5 @@\n-        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-            \"HPP: internal error, state == COMMENT\\n\",\n-                 NULL, NULL);\n-        ctxt->instate = XML_PARSER_CONTENT;\n-        ctxt->checkIndex = 0;\n+                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                        \"HPP: internal error, state == COMMENT\\n\",\n+                             NULL, NULL);\n+                ctxt->instate = XML_PARSER_CONTENT;\n+                ctxt->checkIndex = 0;\n@@ -6098,2 +6093,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: entering CONTENT\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"HPP: entering CONTENT\\n\");\n@@ -6101,1 +6096,1 @@\n-        break;\n+                break;\n@@ -6103,5 +6098,5 @@\n-        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-            \"HPP: internal error, state == PI\\n\",\n-                 NULL, NULL);\n-        ctxt->instate = XML_PARSER_CONTENT;\n-        ctxt->checkIndex = 0;\n+                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                        \"HPP: internal error, state == PI\\n\",\n+                             NULL, NULL);\n+                ctxt->instate = XML_PARSER_CONTENT;\n+                ctxt->checkIndex = 0;\n@@ -6109,2 +6104,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: entering CONTENT\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"HPP: entering CONTENT\\n\");\n@@ -6112,1 +6107,1 @@\n-        break;\n+                break;\n@@ -6114,5 +6109,5 @@\n-        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-            \"HPP: internal error, state == ENTITY_DECL\\n\",\n-                 NULL, NULL);\n-        ctxt->instate = XML_PARSER_CONTENT;\n-        ctxt->checkIndex = 0;\n+                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                        \"HPP: internal error, state == ENTITY_DECL\\n\",\n+                             NULL, NULL);\n+                ctxt->instate = XML_PARSER_CONTENT;\n+                ctxt->checkIndex = 0;\n@@ -6120,2 +6115,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: entering CONTENT\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"HPP: entering CONTENT\\n\");\n@@ -6123,1 +6118,1 @@\n-        break;\n+                break;\n@@ -6125,5 +6120,5 @@\n-        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-            \"HPP: internal error, state == ENTITY_VALUE\\n\",\n-                 NULL, NULL);\n-        ctxt->instate = XML_PARSER_CONTENT;\n-        ctxt->checkIndex = 0;\n+                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                        \"HPP: internal error, state == ENTITY_VALUE\\n\",\n+                             NULL, NULL);\n+                ctxt->instate = XML_PARSER_CONTENT;\n+                ctxt->checkIndex = 0;\n@@ -6131,2 +6126,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: entering DTD\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"HPP: entering DTD\\n\");\n@@ -6134,1 +6129,1 @@\n-        break;\n+                break;\n@@ -6136,5 +6131,5 @@\n-        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-            \"HPP: internal error, state == ATTRIBUTE_VALUE\\n\",\n-                 NULL, NULL);\n-        ctxt->instate = XML_PARSER_START_TAG;\n-        ctxt->checkIndex = 0;\n+                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                        \"HPP: internal error, state == ATTRIBUTE_VALUE\\n\",\n+                             NULL, NULL);\n+                ctxt->instate = XML_PARSER_START_TAG;\n+                ctxt->checkIndex = 0;\n@@ -6142,2 +6137,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: entering START_TAG\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"HPP: entering START_TAG\\n\");\n@@ -6145,7 +6140,7 @@\n-        break;\n-        case XML_PARSER_SYSTEM_LITERAL:\n-        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-            \"HPP: internal error, state == XML_PARSER_SYSTEM_LITERAL\\n\",\n-                 NULL, NULL);\n-        ctxt->instate = XML_PARSER_CONTENT;\n-        ctxt->checkIndex = 0;\n+                break;\n+            case XML_PARSER_SYSTEM_LITERAL:\n+                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                    \"HPP: internal error, state == XML_PARSER_SYSTEM_LITERAL\\n\",\n+                             NULL, NULL);\n+                ctxt->instate = XML_PARSER_CONTENT;\n+                ctxt->checkIndex = 0;\n@@ -6153,2 +6148,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: entering CONTENT\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"HPP: entering CONTENT\\n\");\n@@ -6156,7 +6151,7 @@\n-        break;\n-        case XML_PARSER_IGNORE:\n-        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-            \"HPP: internal error, state == XML_PARSER_IGNORE\\n\",\n-                 NULL, NULL);\n-        ctxt->instate = XML_PARSER_CONTENT;\n-        ctxt->checkIndex = 0;\n+                break;\n+            case XML_PARSER_IGNORE:\n+                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                        \"HPP: internal error, state == XML_PARSER_IGNORE\\n\",\n+                             NULL, NULL);\n+                ctxt->instate = XML_PARSER_CONTENT;\n+                ctxt->checkIndex = 0;\n@@ -6164,2 +6159,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: entering CONTENT\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"HPP: entering CONTENT\\n\");\n@@ -6167,7 +6162,7 @@\n-        break;\n-        case XML_PARSER_PUBLIC_LITERAL:\n-        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-            \"HPP: internal error, state == XML_PARSER_LITERAL\\n\",\n-                 NULL, NULL);\n-        ctxt->instate = XML_PARSER_CONTENT;\n-        ctxt->checkIndex = 0;\n+                break;\n+            case XML_PARSER_PUBLIC_LITERAL:\n+                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                        \"HPP: internal error, state == XML_PARSER_LITERAL\\n\",\n+                             NULL, NULL);\n+                ctxt->instate = XML_PARSER_CONTENT;\n+                ctxt->checkIndex = 0;\n@@ -6175,2 +6170,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"HPP: entering CONTENT\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"HPP: entering CONTENT\\n\");\n@@ -6178,1 +6173,1 @@\n-        break;\n+                break;\n@@ -6180,1 +6175,1 @@\n-    }\n+        }\n@@ -6184,9 +6179,9 @@\n-    htmlAutoCloseOnEnd(ctxt);\n-    if ((ctxt->nameNr == 0) && (ctxt->instate != XML_PARSER_EOF)) {\n-        \/*\n-         * SAX: end of the document processing.\n-         *\/\n-        ctxt->instate = XML_PARSER_EOF;\n-        if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n-        ctxt->sax->endDocument(ctxt->userData);\n-    }\n+        htmlAutoCloseOnEnd(ctxt);\n+        if ((ctxt->nameNr == 0) && (ctxt->instate != XML_PARSER_EOF)) {\n+            \/*\n+             * SAX: end of the document processing.\n+             *\/\n+            ctxt->instate = XML_PARSER_EOF;\n+            if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n+                ctxt->sax->endDocument(ctxt->userData);\n+        }\n@@ -6195,9 +6190,9 @@\n-    ((terminate) || (ctxt->instate == XML_PARSER_EOF) ||\n-     (ctxt->instate == XML_PARSER_EPILOG))) {\n-    xmlDtdPtr dtd;\n-    dtd = xmlGetIntSubset(ctxt->myDoc);\n-    if (dtd == NULL)\n-        ctxt->myDoc->intSubset =\n-        xmlCreateIntSubset(ctxt->myDoc, BAD_CAST \"html\",\n-            BAD_CAST \"-\/\/W3C\/\/DTD HTML 4.0 Transitional\/\/EN\",\n-            BAD_CAST \"http:\/\/www.w3.org\/TR\/REC-html40\/loose.dtd\");\n+        ((terminate) || (ctxt->instate == XML_PARSER_EOF) ||\n+         (ctxt->instate == XML_PARSER_EPILOG))) {\n+        xmlDtdPtr dtd;\n+        dtd = xmlGetIntSubset(ctxt->myDoc);\n+        if (dtd == NULL)\n+            ctxt->myDoc->intSubset =\n+                xmlCreateIntSubset(ctxt->myDoc, BAD_CAST \"html\",\n+                    BAD_CAST \"-\/\/W3C\/\/DTD HTML 4.0 Transitional\/\/EN\",\n+                    BAD_CAST \"http:\/\/www.w3.org\/TR\/REC-html40\/loose.dtd\");\n@@ -6226,3 +6221,3 @@\n-    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-             \"htmlParseChunk: context error\\n\", NULL, NULL);\n-    return(XML_ERR_INTERNAL_ERROR);\n+        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                     \"htmlParseChunk: context error\\n\", NULL, NULL);\n+        return(XML_ERR_INTERNAL_ERROR);\n@@ -6232,3 +6227,3 @@\n-    size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n-    size_t cur = ctxt->input->cur - ctxt->input->base;\n-    int res;\n+        size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n+        size_t cur = ctxt->input->cur - ctxt->input->base;\n+        int res;\n@@ -6236,1 +6231,1 @@\n-    res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n+        res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n@@ -6238,5 +6233,5 @@\n-    if (res < 0) {\n-        ctxt->errNo = XML_PARSER_EOF;\n-        ctxt->disableSAX = 1;\n-        return (XML_PARSER_EOF);\n-    }\n+        if (res < 0) {\n+            ctxt->errNo = XML_PARSER_EOF;\n+            ctxt->disableSAX = 1;\n+            return (XML_PARSER_EOF);\n+        }\n@@ -6244,1 +6239,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"HPP: pushed %d\\n\", size);\n+        xmlGenericError(xmlGenericErrorContext, \"HPP: pushed %d\\n\", size);\n@@ -6248,2 +6243,2 @@\n-    if ((terminate) || (ctxt->input->buf->buffer->use > 80))\n-        htmlParseTryOrFinish(ctxt, terminate);\n+        if ((terminate) || (ctxt->input->buf->buffer->use > 80))\n+            htmlParseTryOrFinish(ctxt, terminate);\n@@ -6252,15 +6247,16 @@\n-    if ((ctxt->input != NULL) && ctxt->input->buf != NULL) {\n-        xmlParserInputBufferPtr in = ctxt->input->buf;\n-        if ((in->encoder != NULL) && (in->buffer != NULL) &&\n-            (in->raw != NULL)) {\n-        int nbchars;\n-        size_t base = xmlBufGetInputBase(in->buffer, ctxt->input);\n-        size_t current = ctxt->input->cur - ctxt->input->base;\n-\n-        nbchars = xmlCharEncInput(in, terminate);\n-        xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);\n-        if (nbchars < 0) {\n-            htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n-                     \"encoder error\\n\", NULL, NULL);\n-            return(XML_ERR_INVALID_ENCODING);\n-        }\n+        if ((ctxt->input != NULL) && ctxt->input->buf != NULL) {\n+            xmlParserInputBufferPtr in = ctxt->input->buf;\n+            if ((in->encoder != NULL) && (in->buffer != NULL) &&\n+                    (in->raw != NULL)) {\n+                int nbchars;\n+                size_t base = xmlBufGetInputBase(in->buffer, ctxt->input);\n+                size_t current = ctxt->input->cur - ctxt->input->base;\n+\n+                nbchars = xmlCharEncInput(in, terminate);\n+                xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);\n+                if (nbchars < 0) {\n+                    htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                                 \"encoder error\\n\", NULL, NULL);\n+                    return(XML_ERR_INVALID_ENCODING);\n+                }\n+            }\n@@ -6269,1 +6265,0 @@\n-    }\n@@ -6272,11 +6267,11 @@\n-    if ((ctxt->instate != XML_PARSER_EOF) &&\n-        (ctxt->instate != XML_PARSER_EPILOG) &&\n-        (ctxt->instate != XML_PARSER_MISC)) {\n-        ctxt->errNo = XML_ERR_DOCUMENT_END;\n-        ctxt->wellFormed = 0;\n-    }\n-    if (ctxt->instate != XML_PARSER_EOF) {\n-        if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n-        ctxt->sax->endDocument(ctxt->userData);\n-    }\n-    ctxt->instate = XML_PARSER_EOF;\n+        if ((ctxt->instate != XML_PARSER_EOF) &&\n+            (ctxt->instate != XML_PARSER_EPILOG) &&\n+            (ctxt->instate != XML_PARSER_MISC)) {\n+            ctxt->errNo = XML_ERR_DOCUMENT_END;\n+            ctxt->wellFormed = 0;\n+        }\n+        if (ctxt->instate != XML_PARSER_EOF) {\n+            if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n+                ctxt->sax->endDocument(ctxt->userData);\n+        }\n+        ctxt->instate = XML_PARSER_EOF;\n@@ -6288,3 +6283,3 @@\n- *                                  *\n- *          User entry points               *\n- *                                  *\n+ *                                                                      *\n+ *                      User entry points                               *\n+ *                                                                      *\n@@ -6311,1 +6306,1 @@\n-             xmlCharEncoding enc) {\n+                         xmlCharEncoding enc) {\n@@ -6323,2 +6318,2 @@\n-    xmlFreeParserInputBuffer(buf);\n-    return(NULL);\n+        xmlFreeParserInputBuffer(buf);\n+        return(NULL);\n@@ -6327,1 +6322,1 @@\n-    ctxt->charset=XML_CHAR_ENCODING_UTF8;\n+        ctxt->charset=XML_CHAR_ENCODING_UTF8;\n@@ -6329,11 +6324,11 @@\n-    if (ctxt->sax != (xmlSAXHandlerPtr) &htmlDefaultSAXHandler)\n-        xmlFree(ctxt->sax);\n-    ctxt->sax = (htmlSAXHandlerPtr) xmlMalloc(sizeof(htmlSAXHandler));\n-    if (ctxt->sax == NULL) {\n-        xmlFree(buf);\n-        xmlFree(ctxt);\n-        return(NULL);\n-    }\n-    memcpy(ctxt->sax, sax, sizeof(htmlSAXHandler));\n-    if (user_data != NULL)\n-        ctxt->userData = user_data;\n+        if (ctxt->sax != (xmlSAXHandlerPtr) &htmlDefaultSAXHandler)\n+            xmlFree(ctxt->sax);\n+        ctxt->sax = (htmlSAXHandlerPtr) xmlMalloc(sizeof(htmlSAXHandler));\n+        if (ctxt->sax == NULL) {\n+            xmlFree(buf);\n+            xmlFree(ctxt);\n+            return(NULL);\n+        }\n+        memcpy(ctxt->sax, sax, sizeof(htmlSAXHandler));\n+        if (user_data != NULL)\n+            ctxt->userData = user_data;\n@@ -6342,1 +6337,1 @@\n-    ctxt->directory = NULL;\n+        ctxt->directory = NULL;\n@@ -6349,3 +6344,3 @@\n-    xmlFreeParserCtxt(ctxt);\n-    xmlFree(buf);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        xmlFree(buf);\n+        return(NULL);\n@@ -6355,1 +6350,1 @@\n-    inputStream->filename = NULL;\n+        inputStream->filename = NULL;\n@@ -6357,2 +6352,2 @@\n-    inputStream->filename = (char *)\n-        xmlCanonicPath((const xmlChar *) filename);\n+        inputStream->filename = (char *)\n+            xmlCanonicPath((const xmlChar *) filename);\n@@ -6366,2 +6361,2 @@\n-    size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n-    size_t cur = ctxt->input->cur - ctxt->input->base;\n+        size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n+        size_t cur = ctxt->input->cur - ctxt->input->base;\n@@ -6369,1 +6364,1 @@\n-    xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n+        xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n@@ -6373,1 +6368,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"HPP: pushed %d\\n\", size);\n+        xmlGenericError(xmlGenericErrorContext, \"HPP: pushed %d\\n\", size);\n@@ -6419,2 +6414,2 @@\n-    ctxt->sax = NULL;\n-    ctxt->userData = NULL;\n+        ctxt->sax = NULL;\n+        ctxt->userData = NULL;\n@@ -6468,1 +6463,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6473,3 +6468,3 @@\n-    if (xmlDefaultSAXHandler.error != NULL) {\n-        xmlDefaultSAXHandler.error(NULL, \"out of memory\\n\");\n-    }\n+        if (xmlDefaultSAXHandler.error != NULL) {\n+            xmlDefaultSAXHandler.error(NULL, \"out of memory\\n\");\n+        }\n@@ -6477,2 +6472,2 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -6484,2 +6479,2 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -6494,7 +6489,8 @@\n-    if (l < 1000) {\n-        content = xmlMallocAtomic (xmlStrlen(content_line) + l + 1);\n-        if (content) {\n-        strcpy ((char *)content, (char *)content_line);\n-        strcat ((char *)content, (char *)encoding);\n-        htmlCheckEncoding (ctxt, content);\n-        xmlFree (content);\n+        if (l < 1000) {\n+            content = xmlMallocAtomic (xmlStrlen(content_line) + l + 1);\n+            if (content) {\n+                strcpy ((char *)content, (char *)content_line);\n+                strcat ((char *)content, (char *)encoding);\n+                htmlCheckEncoding (ctxt, content);\n+                xmlFree (content);\n+            }\n@@ -6503,1 +6499,0 @@\n-    }\n@@ -6536,1 +6531,1 @@\n-    oldsax = ctxt->sax;\n+        oldsax = ctxt->sax;\n@@ -6601,1 +6596,1 @@\n-    return 0 ;\n+        return 0 ;\n@@ -6644,1 +6639,1 @@\n-    return HTML_INVALID ;\n+        return HTML_INVALID ;\n@@ -6667,1 +6662,1 @@\n- *  for Element nodes)\n+ *      for Element nodes)\n@@ -6673,3 +6668,3 @@\n- *  legacy allowed) or htmlElementStatusHere (otherwise).\n- *  for Attribute nodes, a return from htmlAttrAllowed\n- *  for other nodes, HTML_NA (no checks performed)\n+ *      legacy allowed) or htmlElementStatusHere (otherwise).\n+ *      for Attribute nodes, a return from htmlAttrAllowed\n+ *      for other nodes, HTML_NA (no checks performed)\n@@ -6685,7 +6680,7 @@\n-    ? ( htmlElementAllowedHere (\n-        htmlTagLookup(node->parent->name) , node->name\n-        ) ? HTML_VALID : HTML_INVALID )\n-    : htmlElementStatusHere(\n-        htmlTagLookup(node->parent->name) ,\n-        htmlTagLookup(node->name) )\n-    ;\n+        ? ( htmlElementAllowedHere (\n+                htmlTagLookup(node->parent->name) , node->name\n+                ) ? HTML_VALID : HTML_INVALID )\n+        : htmlElementStatusHere(\n+                htmlTagLookup(node->parent->name) ,\n+                htmlTagLookup(node->name) )\n+        ;\n@@ -6694,1 +6689,1 @@\n-    htmlTagLookup(node->parent->name) , node->name, legacy) ;\n+        htmlTagLookup(node->parent->name) , node->name, legacy) ;\n@@ -6699,3 +6694,3 @@\n- *                                  *\n- *  New set (2.6.0) of simpler and more flexible APIs       *\n- *                                  *\n+ *                                                                      *\n+ *      New set (2.6.0) of simpler and more flexible APIs               *\n+ *                                                                      *\n@@ -6710,4 +6705,4 @@\n-#define DICT_FREE(str)                      \\\n-    if ((str) && ((!dict) ||                \\\n-        (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \\\n-        xmlFree((char *)(str));\n+#define DICT_FREE(str)                                          \\\n+        if ((str) && ((!dict) ||                                \\\n+            (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \\\n+            xmlFree((char *)(str));\n@@ -6741,2 +6736,2 @@\n-    ctxt->spaceTab[0] = -1;\n-    ctxt->space = &ctxt->spaceTab[0];\n+        ctxt->spaceTab[0] = -1;\n+        ctxt->space = &ctxt->spaceTab[0];\n@@ -6744,1 +6739,1 @@\n-    ctxt->space = NULL;\n+        ctxt->space = NULL;\n@@ -6822,1 +6817,1 @@\n-    ctxt->options |= XML_PARSE_NOWARNING;\n+        ctxt->options |= XML_PARSE_NOWARNING;\n@@ -6829,1 +6824,1 @@\n-    ctxt->options |= XML_PARSE_NOERROR;\n+        ctxt->options |= XML_PARSE_NOERROR;\n@@ -6834,1 +6829,1 @@\n-    ctxt->options |= XML_PARSE_PEDANTIC;\n+        ctxt->options |= XML_PARSE_PEDANTIC;\n@@ -6841,1 +6836,1 @@\n-    ctxt->options |= XML_PARSE_NOBLANKS;\n+        ctxt->options |= XML_PARSE_NOBLANKS;\n@@ -6846,1 +6841,1 @@\n-    options -= HTML_PARSE_RECOVER;\n+        options -= HTML_PARSE_RECOVER;\n@@ -6850,1 +6845,1 @@\n-    ctxt->options |= HTML_PARSE_COMPACT;\n+        ctxt->options |= HTML_PARSE_COMPACT;\n@@ -6854,1 +6849,1 @@\n-    ctxt->options |= XML_PARSE_HUGE;\n+        ctxt->options |= XML_PARSE_HUGE;\n@@ -6858,1 +6853,1 @@\n-    ctxt->options |= HTML_PARSE_NODEFDTD;\n+        ctxt->options |= HTML_PARSE_NODEFDTD;\n@@ -6862,1 +6857,1 @@\n-    ctxt->options |= HTML_PARSE_IGNORE_ENC;\n+        ctxt->options |= HTML_PARSE_IGNORE_ENC;\n@@ -6896,5 +6891,5 @@\n-    hdlr = xmlFindCharEncodingHandler(encoding);\n-    if (hdlr != NULL) {\n-        xmlSwitchToEncoding(ctxt, hdlr);\n-        if (ctxt->input->encoding != NULL)\n-          xmlFree((xmlChar *) ctxt->input->encoding);\n+        hdlr = xmlFindCharEncodingHandler(encoding);\n+        if (hdlr != NULL) {\n+            xmlSwitchToEncoding(ctxt, hdlr);\n+            if (ctxt->input->encoding != NULL)\n+              xmlFree((xmlChar *) ctxt->input->encoding);\n@@ -6912,4 +6907,4 @@\n-        (ret != NULL) &&\n-        (ret->dict == ctxt->dict))\n-        ctxt->dict = NULL;\n-    xmlFreeParserCtxt(ctxt);\n+            (ret != NULL) &&\n+            (ret->dict == ctxt->dict))\n+            ctxt->dict = NULL;\n+        xmlFreeParserCtxt(ctxt);\n@@ -7002,1 +6997,3 @@\n- * parse an XML from a file descriptor and build a tree.\n+ * parse an HTML from a file descriptor and build a tree.\n+ * NOTE that the file descriptor will not be closed when the\n+ *      reader is closed or reset.\n@@ -7011,1 +7008,1 @@\n-    xmlParserInputPtr stream;\n+    htmlParserInputPtr stream;\n@@ -7015,1 +7012,0 @@\n-    xmlInitParser();\n@@ -7021,1 +7017,2 @@\n-    ctxt = xmlNewParserCtxt();\n+    input->closecallback = NULL;\n+    ctxt = htmlNewParserCtxt();\n@@ -7029,1 +7026,1 @@\n-    xmlFreeParserCtxt(ctxt);\n+        htmlFreeParserCtxt(ctxt);\n@@ -7076,1 +7073,1 @@\n-    xmlFreeParserCtxt(ctxt);\n+        xmlFreeParserCtxt(ctxt);\n@@ -7183,1 +7180,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -7188,2 +7185,2 @@\n-    xmlFreeParserInputBuffer(input);\n-    return(NULL);\n+        xmlFreeParserInputBuffer(input);\n+        return(NULL);\n@@ -7255,1 +7252,1 @@\n-          const char *URL,\n+              const char *URL,\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/HTMLparser.c","additions":2267,"deletions":2270,"binary":false,"changes":4537,"status":"modified"},{"patch":"@@ -36,3 +36,3 @@\n- *                                  *\n- *      Getting\/Setting encoding meta tags          *\n- *                                  *\n+ *                                                                      *\n+ *              Getting\/Setting encoding meta tags                      *\n+ *                                                                      *\n@@ -56,1 +56,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -63,9 +63,9 @@\n-    if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n-        if (xmlStrEqual(cur->name, BAD_CAST\"html\"))\n-        break;\n-        if (xmlStrEqual(cur->name, BAD_CAST\"head\"))\n-        goto found_head;\n-        if (xmlStrEqual(cur->name, BAD_CAST\"meta\"))\n-        goto found_meta;\n-    }\n-    cur = cur->next;\n+        if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n+            if (xmlStrEqual(cur->name, BAD_CAST\"html\"))\n+                break;\n+            if (xmlStrEqual(cur->name, BAD_CAST\"head\"))\n+                goto found_head;\n+            if (xmlStrEqual(cur->name, BAD_CAST\"meta\"))\n+                goto found_meta;\n+        }\n+        cur = cur->next;\n@@ -74,1 +74,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -81,7 +81,7 @@\n-    if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n-        if (xmlStrEqual(cur->name, BAD_CAST\"head\"))\n-        break;\n-        if (xmlStrEqual(cur->name, BAD_CAST\"meta\"))\n-        goto found_meta;\n-    }\n-    cur = cur->next;\n+        if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n+            if (xmlStrEqual(cur->name, BAD_CAST\"head\"))\n+                break;\n+            if (xmlStrEqual(cur->name, BAD_CAST\"meta\"))\n+                goto found_meta;\n+        }\n+        cur = cur->next;\n@@ -90,1 +90,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -99,21 +99,24 @@\n-    if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n-        if (xmlStrEqual(cur->name, BAD_CAST\"meta\")) {\n-        xmlAttrPtr attr = cur->properties;\n-        int http;\n-        const xmlChar *value;\n-\n-        content = NULL;\n-        http = 0;\n-        while (attr != NULL) {\n-            if ((attr->children != NULL) &&\n-                (attr->children->type == XML_TEXT_NODE) &&\n-                (attr->children->next == NULL)) {\n-            value = attr->children->content;\n-            if ((!xmlStrcasecmp(attr->name, BAD_CAST\"http-equiv\"))\n-             && (!xmlStrcasecmp(value, BAD_CAST\"Content-Type\")))\n-                http = 1;\n-            else if ((value != NULL)\n-             && (!xmlStrcasecmp(attr->name, BAD_CAST\"content\")))\n-                content = value;\n-            if ((http != 0) && (content != NULL))\n-                goto found_content;\n+        if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n+            if (xmlStrEqual(cur->name, BAD_CAST\"meta\")) {\n+                xmlAttrPtr attr = cur->properties;\n+                int http;\n+                const xmlChar *value;\n+\n+                content = NULL;\n+                http = 0;\n+                while (attr != NULL) {\n+                    if ((attr->children != NULL) &&\n+                        (attr->children->type == XML_TEXT_NODE) &&\n+                        (attr->children->next == NULL)) {\n+                        value = attr->children->content;\n+                        if ((!xmlStrcasecmp(attr->name, BAD_CAST\"http-equiv\"))\n+                         && (!xmlStrcasecmp(value, BAD_CAST\"Content-Type\")))\n+                            http = 1;\n+                        else if ((value != NULL)\n+                         && (!xmlStrcasecmp(attr->name, BAD_CAST\"content\")))\n+                            content = value;\n+                        if ((http != 0) && (content != NULL))\n+                            goto found_content;\n+                    }\n+                    attr = attr->next;\n+                }\n@@ -121,2 +124,0 @@\n-            attr = attr->next;\n-        }\n@@ -124,2 +125,1 @@\n-    }\n-    cur = cur->next;\n+        cur = cur->next;\n@@ -132,1 +132,1 @@\n-    encoding = xmlStrstr(content, BAD_CAST\"Charset=\");\n+        encoding = xmlStrstr(content, BAD_CAST\"Charset=\");\n@@ -134,1 +134,1 @@\n-    encoding = xmlStrstr(content, BAD_CAST\"CHARSET=\");\n+        encoding = xmlStrstr(content, BAD_CAST\"CHARSET=\");\n@@ -136,1 +136,1 @@\n-    encoding += 8;\n+        encoding += 8;\n@@ -138,7 +138,7 @@\n-    encoding = xmlStrstr(content, BAD_CAST\"charset =\");\n-    if (encoding == NULL)\n-        encoding = xmlStrstr(content, BAD_CAST\"Charset =\");\n-    if (encoding == NULL)\n-        encoding = xmlStrstr(content, BAD_CAST\"CHARSET =\");\n-    if (encoding != NULL)\n-        encoding += 9;\n+        encoding = xmlStrstr(content, BAD_CAST\"charset =\");\n+        if (encoding == NULL)\n+            encoding = xmlStrstr(content, BAD_CAST\"Charset =\");\n+        if (encoding == NULL)\n+            encoding = xmlStrstr(content, BAD_CAST\"CHARSET =\");\n+        if (encoding != NULL)\n+            encoding += 9;\n@@ -147,1 +147,1 @@\n-    while ((*encoding == ' ') || (*encoding == '\\t')) encoding++;\n+        while ((*encoding == ' ') || (*encoding == '\\t')) encoding++;\n@@ -172,1 +172,1 @@\n-    return(-1);\n+        return(-1);\n@@ -179,1 +179,1 @@\n-    snprintf(newcontent, sizeof(newcontent), \"text\/html; charset=%s\",\n+        snprintf(newcontent, sizeof(newcontent), \"text\/html; charset=%s\",\n@@ -181,1 +181,1 @@\n-    newcontent[sizeof(newcontent) - 1] = 0;\n+        newcontent[sizeof(newcontent) - 1] = 0;\n@@ -190,9 +190,9 @@\n-    if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n-        if (xmlStrcasecmp(cur->name, BAD_CAST\"html\") == 0)\n-        break;\n-        if (xmlStrcasecmp(cur->name, BAD_CAST\"head\") == 0)\n-        goto found_head;\n-        if (xmlStrcasecmp(cur->name, BAD_CAST\"meta\") == 0)\n-        goto found_meta;\n-    }\n-    cur = cur->next;\n+        if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n+            if (xmlStrcasecmp(cur->name, BAD_CAST\"html\") == 0)\n+                break;\n+            if (xmlStrcasecmp(cur->name, BAD_CAST\"head\") == 0)\n+                goto found_head;\n+            if (xmlStrcasecmp(cur->name, BAD_CAST\"meta\") == 0)\n+                goto found_meta;\n+        }\n+        cur = cur->next;\n@@ -201,1 +201,1 @@\n-    return(-1);\n+        return(-1);\n@@ -208,4 +208,4 @@\n-    if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n-        if (xmlStrcasecmp(cur->name, BAD_CAST\"head\") == 0)\n-        break;\n-        if (xmlStrcasecmp(cur->name, BAD_CAST\"meta\") == 0) {\n+        if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n+            if (xmlStrcasecmp(cur->name, BAD_CAST\"head\") == 0)\n+                break;\n+            if (xmlStrcasecmp(cur->name, BAD_CAST\"meta\") == 0) {\n@@ -213,1 +213,1 @@\n-        goto found_meta;\n+                goto found_meta;\n@@ -215,2 +215,2 @@\n-    }\n-    cur = cur->next;\n+        }\n+        cur = cur->next;\n@@ -219,1 +219,1 @@\n-    return(-1);\n+        return(-1);\n@@ -232,17 +232,17 @@\n-    if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n-        if (xmlStrcasecmp(cur->name, BAD_CAST\"meta\") == 0) {\n-        xmlAttrPtr attr = cur->properties;\n-        int http;\n-        const xmlChar *value;\n-\n-        content = NULL;\n-        http = 0;\n-        while (attr != NULL) {\n-            if ((attr->children != NULL) &&\n-                (attr->children->type == XML_TEXT_NODE) &&\n-                (attr->children->next == NULL)) {\n-            value = attr->children->content;\n-            if ((!xmlStrcasecmp(attr->name, BAD_CAST\"http-equiv\"))\n-             && (!xmlStrcasecmp(value, BAD_CAST\"Content-Type\")))\n-                http = 1;\n-            else\n+        if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n+            if (xmlStrcasecmp(cur->name, BAD_CAST\"meta\") == 0) {\n+                xmlAttrPtr attr = cur->properties;\n+                int http;\n+                const xmlChar *value;\n+\n+                content = NULL;\n+                http = 0;\n+                while (attr != NULL) {\n+                    if ((attr->children != NULL) &&\n+                        (attr->children->type == XML_TEXT_NODE) &&\n+                        (attr->children->next == NULL)) {\n+                        value = attr->children->content;\n+                        if ((!xmlStrcasecmp(attr->name, BAD_CAST\"http-equiv\"))\n+                         && (!xmlStrcasecmp(value, BAD_CAST\"Content-Type\")))\n+                            http = 1;\n+                        else\n@@ -252,1 +252,1 @@\n-                   content = value;\n+                               content = value;\n@@ -254,9 +254,9 @@\n-                if ((http != 0) && (content != NULL))\n-                break;\n-            }\n-            attr = attr->next;\n-        }\n-        if ((http != 0) && (content != NULL)) {\n-            meta = cur;\n-            break;\n-        }\n+                        if ((http != 0) && (content != NULL))\n+                            break;\n+                    }\n+                    attr = attr->next;\n+                }\n+                if ((http != 0) && (content != NULL)) {\n+                    meta = cur;\n+                    break;\n+                }\n@@ -264,0 +264,1 @@\n+            }\n@@ -265,2 +266,1 @@\n-    }\n-    cur = cur->next;\n+        cur = cur->next;\n@@ -342,3 +342,3 @@\n- *                                  *\n- *          Output error handlers               *\n- *                                  *\n+ *                                                                      *\n+ *                      Output error handlers                           *\n+ *                                                                      *\n@@ -373,13 +373,13 @@\n-        msg = \"string is not in UTF-8\\n\";\n-        break;\n-    case XML_SAVE_CHAR_INVALID:\n-        msg = \"invalid character value\\n\";\n-        break;\n-    case XML_SAVE_UNKNOWN_ENCODING:\n-        msg = \"unknown encoding %s\\n\";\n-        break;\n-    case XML_SAVE_NO_DOCTYPE:\n-        msg = \"HTML has no DOCTYPE\\n\";\n-        break;\n-    default:\n-        msg = \"unexpected error number\\n\";\n+            msg = \"string is not in UTF-8\\n\";\n+            break;\n+        case XML_SAVE_CHAR_INVALID:\n+            msg = \"invalid character value\\n\";\n+            break;\n+        case XML_SAVE_UNKNOWN_ENCODING:\n+            msg = \"unknown encoding %s\\n\";\n+            break;\n+        case XML_SAVE_NO_DOCTYPE:\n+            msg = \"HTML has no DOCTYPE\\n\";\n+            break;\n+        default:\n+            msg = \"unexpected error number\\n\";\n@@ -391,3 +391,3 @@\n- *                                  *\n- *      Dumping HTML tree content to a simple buffer        *\n- *                                  *\n+ *                                                                      *\n+ *              Dumping HTML tree content to a simple buffer            *\n+ *                                                                      *\n@@ -409,1 +409,1 @@\n-               int format) {\n+                   int format) {\n@@ -415,1 +415,1 @@\n-    return (-1);\n+        return (-1);\n@@ -418,1 +418,1 @@\n-    return (-1);\n+        return (-1);\n@@ -423,1 +423,1 @@\n-    return (-1);\n+        return (-1);\n@@ -489,1 +489,1 @@\n-                   xmlNodePtr cur, const char *encoding, int format) {\n+                       xmlNodePtr cur, const char *encoding, int format) {\n@@ -497,1 +497,1 @@\n-    xmlCharEncoding enc;\n+        xmlCharEncoding enc;\n@@ -499,6 +499,6 @@\n-    enc = xmlParseCharEncoding(encoding);\n-    if (enc != XML_CHAR_ENCODING_UTF8) {\n-        handler = xmlFindCharEncodingHandler(encoding);\n-        if (handler == NULL)\n-        htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);\n-    }\n+        enc = xmlParseCharEncoding(encoding);\n+        if (enc != XML_CHAR_ENCODING_UTF8) {\n+            handler = xmlFindCharEncodingHandler(encoding);\n+            if (handler == NULL)\n+                htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);\n+        }\n@@ -562,3 +562,3 @@\n-    *mem = NULL;\n-    *size = 0;\n-    return;\n+        *mem = NULL;\n+        *size = 0;\n+        return;\n@@ -570,1 +570,1 @@\n-    xmlCharEncoding enc;\n+        xmlCharEncoding enc;\n@@ -572,4 +572,4 @@\n-    enc = xmlParseCharEncoding(encoding);\n-    if (enc != XML_CHAR_ENCODING_UTF8) {\n-        handler = xmlFindCharEncodingHandler(encoding);\n-        if (handler == NULL)\n+        enc = xmlParseCharEncoding(encoding);\n+        if (enc != XML_CHAR_ENCODING_UTF8) {\n+            handler = xmlFindCharEncodingHandler(encoding);\n+            if (handler == NULL)\n@@ -578,1 +578,1 @@\n-    }\n+        }\n@@ -591,3 +591,3 @@\n-    *mem = NULL;\n-    *size = 0;\n-    return;\n+        *mem = NULL;\n+        *size = 0;\n+        return;\n@@ -600,2 +600,2 @@\n-    *size = xmlBufUse(buf->conv);\n-    *mem = xmlStrndup(xmlBufContent(buf->conv), *size);\n+        *size = xmlBufUse(buf->conv);\n+        *mem = xmlStrndup(xmlBufContent(buf->conv), *size);\n@@ -603,2 +603,2 @@\n-    *size = xmlBufUse(buf->buffer);\n-    *mem = xmlStrndup(xmlBufContent(buf->buffer), *size);\n+        *size = xmlBufUse(buf->buffer);\n+        *mem = xmlStrndup(xmlBufContent(buf->buffer), *size);\n@@ -620,1 +620,1 @@\n-    htmlDocDumpMemoryFormat(cur, mem, size, 1);\n+        htmlDocDumpMemoryFormat(cur, mem, size, 1);\n@@ -625,3 +625,3 @@\n- *                                  *\n- *      Dumping HTML tree content to an I\/O output buffer   *\n- *                                  *\n+ *                                                                      *\n+ *              Dumping HTML tree content to an I\/O output buffer       *\n+ *                                                                      *\n@@ -644,1 +644,1 @@\n-              const char *encoding ATTRIBUTE_UNUSED) {\n+                  const char *encoding ATTRIBUTE_UNUSED) {\n@@ -648,2 +648,2 @@\n-    htmlSaveErr(XML_SAVE_NO_DOCTYPE, (xmlNodePtr) doc, NULL);\n-    return;\n+        htmlSaveErr(XML_SAVE_NO_DOCTYPE, (xmlNodePtr) doc, NULL);\n+        return;\n@@ -654,6 +654,6 @@\n-    xmlOutputBufferWriteString(buf, \" PUBLIC \");\n-    xmlBufWriteQuotedString(buf->buffer, cur->ExternalID);\n-    if (cur->SystemID != NULL) {\n-        xmlOutputBufferWriteString(buf, \" \");\n-        xmlBufWriteQuotedString(buf->buffer, cur->SystemID);\n-    }\n+        xmlOutputBufferWriteString(buf, \" PUBLIC \");\n+        xmlBufWriteQuotedString(buf->buffer, cur->ExternalID);\n+        if (cur->SystemID != NULL) {\n+            xmlOutputBufferWriteString(buf, \" \");\n+            xmlBufWriteQuotedString(buf->buffer, cur->SystemID);\n+        }\n@@ -661,3 +661,3 @@\n-           xmlStrcmp(cur->SystemID, BAD_CAST \"about:legacy-compat\")) {\n-    xmlOutputBufferWriteString(buf, \" SYSTEM \");\n-    xmlBufWriteQuotedString(buf->buffer, cur->SystemID);\n+               xmlStrcmp(cur->SystemID, BAD_CAST \"about:legacy-compat\")) {\n+        xmlOutputBufferWriteString(buf, \" SYSTEM \");\n+        xmlBufWriteQuotedString(buf->buffer, cur->SystemID);\n@@ -688,1 +688,1 @@\n-    return;\n+        return;\n@@ -693,1 +693,1 @@\n-    xmlOutputBufferWriteString(buf, \":\");\n+        xmlOutputBufferWriteString(buf, \":\");\n@@ -697,28 +697,32 @@\n-    value = xmlNodeListGetString(doc, cur->children, 0);\n-    if (value) {\n-        xmlOutputBufferWriteString(buf, \"=\");\n-        if ((cur->ns == NULL) && (cur->parent != NULL) &&\n-        (cur->parent->ns == NULL) &&\n-        ((!xmlStrcasecmp(cur->name, BAD_CAST \"href\")) ||\n-             (!xmlStrcasecmp(cur->name, BAD_CAST \"action\")) ||\n-         (!xmlStrcasecmp(cur->name, BAD_CAST \"src\")) ||\n-         ((!xmlStrcasecmp(cur->name, BAD_CAST \"name\")) &&\n-          (!xmlStrcasecmp(cur->parent->name, BAD_CAST \"a\"))))) {\n-        xmlChar *escaped;\n-        xmlChar *tmp = value;\n-\n-        while (IS_BLANK_CH(*tmp)) tmp++;\n-\n-        \/*\n-         * the < and > have already been escaped at the entity level\n-         * And doing so here breaks server side includes\n-         *\/\n-        escaped = xmlURIEscapeStr(tmp, BAD_CAST\"@\/:=?;#%&,+<>\");\n-        if (escaped != NULL) {\n-            xmlBufWriteQuotedString(buf->buffer, escaped);\n-            xmlFree(escaped);\n-        } else {\n-            xmlBufWriteQuotedString(buf->buffer, value);\n-        }\n-        } else {\n-        xmlBufWriteQuotedString(buf->buffer, value);\n+        value = xmlNodeListGetString(doc, cur->children, 0);\n+        if (value) {\n+            xmlOutputBufferWriteString(buf, \"=\");\n+            if ((cur->ns == NULL) && (cur->parent != NULL) &&\n+                (cur->parent->ns == NULL) &&\n+                ((!xmlStrcasecmp(cur->name, BAD_CAST \"href\")) ||\n+                 (!xmlStrcasecmp(cur->name, BAD_CAST \"action\")) ||\n+                 (!xmlStrcasecmp(cur->name, BAD_CAST \"src\")) ||\n+                 ((!xmlStrcasecmp(cur->name, BAD_CAST \"name\")) &&\n+                  (!xmlStrcasecmp(cur->parent->name, BAD_CAST \"a\"))))) {\n+                xmlChar *escaped;\n+                xmlChar *tmp = value;\n+\n+                while (IS_BLANK_CH(*tmp)) tmp++;\n+\n+                \/*\n+                 * the < and > have already been escaped at the entity level\n+                 * And doing so here breaks server side includes\n+                 *\/\n+                escaped = xmlURIEscapeStr(tmp, BAD_CAST\"@\/:=?;#%&,+<>\");\n+                if (escaped != NULL) {\n+                    xmlBufWriteQuotedString(buf->buffer, escaped);\n+                    xmlFree(escaped);\n+                } else {\n+                    xmlBufWriteQuotedString(buf->buffer, value);\n+                }\n+            } else {\n+                xmlBufWriteQuotedString(buf->buffer, value);\n+            }\n+            xmlFree(value);\n+        } else  {\n+            xmlOutputBufferWriteString(buf, \"=\\\"\\\"\");\n@@ -726,4 +730,0 @@\n-        xmlFree(value);\n-    } else  {\n-        xmlOutputBufferWriteString(buf, \"=\\\"\\\"\");\n-    }\n@@ -745,1 +745,1 @@\n-                     xmlNodePtr cur, const char *encoding ATTRIBUTE_UNUSED,\n+                         xmlNodePtr cur, const char *encoding ATTRIBUTE_UNUSED,\n@@ -747,1 +747,1 @@\n-    xmlNodePtr root;\n+    xmlNodePtr root, parent;\n@@ -754,1 +754,1 @@\n-    return;\n+        return;\n@@ -758,0 +758,1 @@\n+    parent = cur->parent;\n@@ -766,2 +767,8 @@\n-                cur = cur->children;\n-                continue;\n+                \/* Always validate cur->parent when descending. *\/\n+                if (cur->parent == parent) {\n+                    parent = cur;\n+                    cur = cur->children;\n+                    continue;\n+                }\n+            } else {\n+                xmlOutputBufferWriteString(buf, \"\\n\");\n@@ -772,0 +779,10 @@\n+            \/*\n+             * Some users like lxml are known to pass nodes with a corrupted\n+             * tree structure. Fall back to a recursive call to handle this\n+             * case.\n+             *\/\n+            if ((cur->parent != parent) && (cur->children != NULL)) {\n+                htmlNodeDumpFormatOutput(buf, doc, cur, encoding, format);\n+                break;\n+            }\n+\n@@ -820,0 +837,1 @@\n+                parent = cur;\n@@ -828,3 +846,3 @@\n-                    (cur->parent != NULL) &&\n-                    (cur->parent->name != NULL) &&\n-                    (cur->parent->name[0] != 'p')) \/* p, pre, param *\/\n+                    (parent != NULL) &&\n+                    (parent->name != NULL) &&\n+                    (parent->name[0] != 'p')) \/* p, pre, param *\/\n@@ -845,3 +863,3 @@\n-                ((cur->parent == NULL) ||\n-                 ((xmlStrcasecmp(cur->parent->name, BAD_CAST \"script\")) &&\n-                  (xmlStrcasecmp(cur->parent->name, BAD_CAST \"style\"))))) {\n+                ((parent == NULL) ||\n+                 ((xmlStrcasecmp(parent->name, BAD_CAST \"script\")) &&\n+                  (xmlStrcasecmp(parent->name, BAD_CAST \"style\"))))) {\n@@ -905,7 +923,3 @@\n-            \/*\n-             * The parent should never be NULL here but we want to handle\n-             * corrupted documents gracefully.\n-             *\/\n-            if (cur->parent == NULL)\n-                return;\n-            cur = cur->parent;\n+            cur = parent;\n+            \/* cur->parent was validated when descending. *\/\n+            parent = cur->parent;\n@@ -942,3 +956,3 @@\n-                        (cur->parent != NULL) &&\n-                        (cur->parent->name != NULL) &&\n-                        (cur->parent->name[0] != 'p')) \/* p, pre, param *\/\n+                        (parent != NULL) &&\n+                        (parent->name != NULL) &&\n+                        (parent->name[0] != 'p')) \/* p, pre, param *\/\n@@ -964,1 +978,1 @@\n-               xmlNodePtr cur, const char *encoding ATTRIBUTE_UNUSED) {\n+                   xmlNodePtr cur, const char *encoding ATTRIBUTE_UNUSED) {\n@@ -979,1 +993,1 @@\n-                           const char *encoding ATTRIBUTE_UNUSED,\n+                               const char *encoding ATTRIBUTE_UNUSED,\n@@ -994,1 +1008,1 @@\n-                     const char *encoding ATTRIBUTE_UNUSED) {\n+                         const char *encoding ATTRIBUTE_UNUSED) {\n@@ -999,3 +1013,3 @@\n- *                                  *\n- *      Saving functions front-ends             *\n- *                                  *\n+ *                                                                      *\n+ *              Saving functions front-ends                             *\n+ *                                                                      *\n@@ -1023,1 +1037,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1029,1 +1043,1 @@\n-    xmlCharEncoding enc;\n+        xmlCharEncoding enc;\n@@ -1031,6 +1045,6 @@\n-    enc = xmlParseCharEncoding(encoding);\n-    if (enc != XML_CHAR_ENCODING_UTF8) {\n-        handler = xmlFindCharEncodingHandler(encoding);\n-        if (handler == NULL)\n-        htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);\n-    }\n+        enc = xmlParseCharEncoding(encoding);\n+        if (enc != XML_CHAR_ENCODING_UTF8) {\n+            handler = xmlFindCharEncodingHandler(encoding);\n+            if (handler == NULL)\n+                htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);\n+        }\n@@ -1079,1 +1093,1 @@\n-    xmlCharEncoding enc;\n+        xmlCharEncoding enc;\n@@ -1081,6 +1095,6 @@\n-    enc = xmlParseCharEncoding(encoding);\n-    if (enc != XML_CHAR_ENCODING_UTF8) {\n-        handler = xmlFindCharEncodingHandler(encoding);\n-        if (handler == NULL)\n-        htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);\n-    }\n+        enc = xmlParseCharEncoding(encoding);\n+        if (enc != XML_CHAR_ENCODING_UTF8) {\n+            handler = xmlFindCharEncodingHandler(encoding);\n+            if (handler == NULL)\n+                htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);\n+        }\n@@ -1122,1 +1136,1 @@\n-               const char *encoding, int format) {\n+                   const char *encoding, int format) {\n@@ -1133,1 +1147,1 @@\n-    xmlCharEncoding enc;\n+        xmlCharEncoding enc;\n@@ -1135,6 +1149,6 @@\n-    enc = xmlParseCharEncoding(encoding);\n-    if (enc != XML_CHAR_ENCODING_UTF8) {\n-        handler = xmlFindCharEncodingHandler(encoding);\n-        if (handler == NULL)\n-        htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);\n-    }\n+        enc = xmlParseCharEncoding(encoding);\n+        if (enc != XML_CHAR_ENCODING_UTF8) {\n+            handler = xmlFindCharEncodingHandler(encoding);\n+            if (handler == NULL)\n+                htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);\n+        }\n@@ -1143,1 +1157,1 @@\n-    htmlSetMetaEncoding(cur, (const xmlChar *) \"UTF-8\");\n+        htmlSetMetaEncoding(cur, (const xmlChar *) \"UTF-8\");\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/HTMLtree.c","additions":270,"deletions":256,"binary":false,"changes":526,"status":"modified"},{"patch":"@@ -1212,1 +1212,1 @@\n-\t(cd $(srcdir) ; tar -cf - --exclude CVS --exclude .svn --exclude .git win32 macos os400 vms VxWorks bakefile test result) | (cd $(distdir); tar xf -)\n+\t(cd $(srcdir) ; tar -cf - --exclude .git win32 macos os400 vms VxWorks bakefile test result) | (cd $(distdir); tar xf -)\n@@ -1219,2 +1219,2 @@\n-\t(cd $(srcdir) ; tar -cf - --exclude CVS --exclude .svn --exclude .git xstc\/Tests) | (cd $(distdir); tar xf -)\n-\ttar -cf - $(distdir)\/test $(distdir)\/result $(distdir)\/xstc\/Tests  $(distdir)\/Makefile.tests $(distdir)\/README $(distdir)\/README.tests $(distdir)\/AUTHORS $(distdir)\/testapi.c $(distdir)\/runtest.c $(distdir)\/runsuite.c | GZIP=$(GZIP_ENV) gzip -c >`echo \"$(distdir)\" | sed \"s+libxml2+libxml2-tests+\"`.tar.gz\n+\t(cd $(srcdir) ; tar -cf - --exclude .git xstc\/Tests) | (cd $(distdir); tar xf -)\n+\ttar -cf - $(distdir)\/test $(distdir)\/result $(distdir)\/xstc\/Tests  $(distdir)\/Makefile.tests $(distdir)\/README.md $(distdir)\/README.tests $(distdir)\/testapi.c $(distdir)\/runtest.c $(distdir)\/runsuite.c | GZIP=$(GZIP_ENV) gzip -c >`echo \"$(distdir)\" | sed \"s+libxml2+libxml2-tests+\"`.tar.gz\n@@ -1249,1 +1249,0 @@\n-CVS_EXTRA_DIST=\n@@ -1262,3 +1261,2 @@\n-\t     README.zOS \\\n-\t     CMakeLists.txt config.h.cmake.in libxml2-config.cmake.cmake.in \\\n-\t     $(CVS_EXTRA_DIST)\n+\t     README.zOS README.md \\\n+\t     CMakeLists.txt config.h.cmake.in libxml2-config.cmake.cmake.in\n@@ -1276,3 +1274,1 @@\n-BASE_DIR=$(datadir)\/doc\n-DOC_MODULE=libxml2-$(VERSION)\n-EXAMPLES_DIR=$(BASE_DIR)\/$(DOC_MODULE)\/examples\n+EXAMPLES_DIR=$(docdir)\/examples\n@@ -1281,2 +1277,2 @@\n-\t$(MKDIR_P) $(DESTDIR)$(BASE_DIR)\/$(DOC_MODULE)\n-\t-$(INSTALL) -m 0644 $(srcdir)\/Copyright $(DESTDIR)$(BASE_DIR)\/$(DOC_MODULE)\n+\t$(MKDIR_P) $(DESTDIR)$(docdir)\n+\t-$(INSTALL) -m 0644 $(srcdir)\/Copyright $(DESTDIR)$(docdir)\n@@ -1288,0 +1284,1 @@\n+\t@echo \"If the documentation is installed, please also look at html\/examples for more.\" > $(DESTDIR)$(EXAMPLES_DIR)\/README\n@@ -1290,0 +1287,1 @@\n+\trm -f $(DESTDIR)$(EXAMPLES_DIR)\/README\n@@ -1295,2 +1293,2 @@\n-\trm -f $(DESTDIR)$(BASE_DIR)\/$(DOC_MODULE)\/Copyright\n-\trm -rf $(DESTDIR)$(BASE_DIR)\/$(DOC_MODULE)\n+\trm -f $(DESTDIR)$(docdir)\/Copyright\n+\trm -rf $(DESTDIR)$(docdir)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/Makefile.am","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -4,3 +4,0 @@\n-  Note that this is automatically generated from the news webpage at:\n-       http:\/\/xmlsoft.org\/news.html\n-\n@@ -13,0 +10,486 @@\n+v2.9.13: Feb 19 2022:\n+   - Security:\n+  [CVE-2022-23308] Use-after-free of ID and IDREF attributes\n+  (Thanks to Shinji Sato for the report)\n+  Use-after-free in xmlXIncludeCopyRange (David Kilzer)\n+  Fix Null-deref-in-xmlSchemaGetComponentTargetNs (huangduirong)\n+  Fix memory leak in xmlXPathCompNodeTest\n+  Fix null pointer deref in xmlStringGetNodeList\n+  Fix several memory leaks found by Coverity (David King)\n+  \n+   - Fixed regressions:\n+  Fix regression in RelaxNG pattern matching\n+  Properly handle nested documents in xmlFreeNode\n+  Fix regression with PEs in external DTD\n+  Fix random dropping of characters on dumping ASCII encoded XML (Mohammad Razavi)\n+  Revert \"Make schema validation fail with multiple top-level elements\"\n+  Fix regression when parsing invalid HTML tags in push mode\n+  Fix regression parsing public IDs literals in HTML\n+  Fix buffering in xmlOutputBufferWrite\n+  Fix whitespace when serializing empty HTML documents\n+  Fix XPath recursion limit\n+  Fix regression in xmlNodeDumpOutputInternal\n+  Work around lxml API abuse\n+  \n+   - Bug fixes:\n+  Fix xmlSetTreeDoc with entity references\n+  Fix double counting of CRLF in comments\n+  Make sure to grow input buffer in xmlParseMisc\n+  Don't ignore xmllint options after \"-\"\n+  Don't normalize namespace URIs in XPointer xmlns() scheme\n+  Fix handling of XSD with empty namespace\n+  Also register HTML document nodes\n+  Make xmllint return an error if arguments are missing\n+  Fix handling of ctxt->base in xmlXPtrEvalXPtrPart\n+  Fix xmllint --maxmem\n+  Fix htmlReadFd, which was using a mix of xml and html context functions (Finn Barber)\n+  Move current position before possible calling of ctxt->sax->characters (Yulin Li)\n+  Fix parse failure when 4-byte character in UTF-16 BE is split across a chunk (David Kilzer)\n+  Patch to forbid epsilon-reduction of final states (Arne Becker)\n+  Avoid segfault at exit when using custom memory functions (Mike Dalessio)\n+  \n+   - Tests, code quality, fuzzing:\n+  Remove .travis.yml\n+  Make xmlFuzzReadString return a zero size in error case\n+  Fix unused function warning in testapi.c\n+  Update NewsML DTD in test suite\n+  Add more checks for malloc failures in xmllint.c\n+  Avoid potential integer overflow in xmlstring.c\n+  Run CI tests with UBSan implicit-conversion checks\n+  Fix casting of line numbers in SAX2.c\n+  Fix integer conversion warnings in hash.c\n+  Add explicit casts in runtest.c \n+  Fix integer conversion warning in xmlIconvWrapper\n+  Add suffix to unsigned constant in xmlmemory.c\n+  Add explicit casts in testchar.c\n+  Fix integer conversion warnings in xmlstring.c\n+  Add explicit cast in xmlURIUnescapeString\n+  Remove unused variable in xmlCharEncOutFunc (David King)\n+  \n+   - Build system, portability:\n+  Remove xmlwin32version.h\n+  Fix fuzzer test with VPATH build\n+  Support custom prefix when installing Python module\n+  Remove Makefile.win\n+  Remove CVS and SVN-related code\n+  Port python 3.x module to Windows and improve distutils (Chun-wei Fan)\n+  Correctly install the HTML examples into their subdirectory (Mattia Rizzolo)\n+  Refactor the settings of $docdir (Mattia Rizzolo)\n+  Remove unused configure checks (Ben Boeckel)\n+  python\/Makefile.am: use *_LIBADD, not *_LDFLAGS for LIBS (Sam James)\n+  Fix check for libtool in autogen.sh\n+  Use version in configure.ac for CMake (Timothy Lyanguzov)\n+  Add CMake alias targets for embedded projects (Markus Rickert)\n+  \n+   - Documentation:\n+  Remove SVN keyword anchors\n+  Rework README\n+  Remove README.cvs-commits\n+  Remove old ChangeLog\n+  Update hyperlinks\n+  Remove README.docs\n+  Remove MAINTAINERS \n+  Remove xmltutorial.pdf\n+  Upload documentation to GitLab pages\n+  Document how to escape XML_CATALOG_FILES\n+  Fix libxml2.doap\n+  Update URL for libxml++ C++ binding (Kjell Ahlstedt)\n+  Generate devhelp2 index file (Emmanuele Bassi)\n+  Mention XML_CATALOG_FILES is space-separated (Jan Tojnar)\n+  Add documentaiton for xmllint exit code 10 (Rainer Canavan)\n+  Fix some validation errors in the FAQ (David King)\n+  Add instructions on how to use CMake to compile libxml (Markus Rickert)\n+  \n+\n+\n+v2.9.12: May 13 2021:\n+   - Build system:\n+  Add fuzz.h and seed\/regexp to EXTRA_DIST\n+  \n+\n+\n+v2.9.11: May 13 2021:\n+   - Security:\n+  Patch for security issue CVE-2021-3541 (Daniel Veillard)\n+  \n+   - Documentation:\n+  Clarify xmlNewDocProp documentation (Nick Wellnhofer)\n+  \n+   - Portability:\n+  CMake: Only add postfixes if MSVC (Christopher Degawa),\n+  Fix XPath NaN\/Inf for older GCC versions (Nick Wellnhofer),\n+  Use CMake PROJECT_VERSION (Markus Rickert),\n+  Fix warnings in libxml.m4 with autoconf 2.70+. (Simon Josefsson),\n+  Add CI for CMake on MSVC (Markus Rickert),\n+  Update minimum required CMake version (Markus Rickert),\n+  Add variables for configured options to CMake config files (Markus Rickert),\n+  Check if variables exist when defining targets (Markus Rickert),\n+  Check if target exists when reading target properties (Markus Rickert),\n+  Add xmlcatalog target and definition to config files (Markus Rickert),\n+  Remove include directories for link-only dependencies (Markus Rickert),\n+  Fix ICU build in CMake (Markus Rickert),\n+  Configure pkgconfig, xml2-config, and xml2Conf.sh file (Markus Rickert),\n+  Update CMake config files (Markus Rickert),\n+  Add xmlcatalog and xmllint to CMake export (Markus Rickert),\n+  Simplify xmlexports.h (Nick Wellnhofer),\n+  Require dependencies based on enabled CMake options (Markus Rickert),\n+  Use NAMELINK_COMPONENT in CMake install (Markus Rickert),\n+  Add CMake files to EXTRA_DIST (Markus Rickert),\n+  Add missing compile definition for static builds to CMake (Markus Rickert),\n+  Add CI for CMake on Linux and MinGW (Markus Rickert),\n+  Fix variable name in win32\/configure.js (Nick Wellnhofer),\n+  Fix version parsing in win32\/configure.js (Nick Wellnhofer),\n+  Fix autotools warnings (Nick Wellnhofer),\n+  Update config.h.cmake.in (Markus Rickert),\n+  win32: allow passing *FLAGS on command line (Michael Stahl),\n+  Configure file xmlwin32version.h.in on MSVC (Markus Rickert),\n+  List headers individually (Markus Rickert),\n+  Add CMake build files (Markus Rickert),\n+  Parenthesize Py<type>_Check() in ifs (Miro Hrončok),\n+  Minor fixes to configure.js (Nick Wellnhofer)\n+  \n+   - Bug Fixes:\n+  Fix null deref in legacy SAX1 parser (Nick Wellnhofer),\n+  Fix handling of unexpected EOF in xmlParseContent (Nick Wellnhofer),\n+  Fix line numbers in error messages for mismatched tags (Nick Wellnhofer),\n+  Fix htmlTagLookup (Nick Wellnhofer),\n+  Propagate error in xmlParseElementChildrenContentDeclPriv (Nick Wellnhofer),\n+  Fix user-after-free with `xmllint --xinclude --dropdtd` (Nick Wellnhofer),\n+  Fix dangling pointer with `xmllint --dropdtd` (Nick Wellnhofer),\n+  Validate UTF8 in xmlEncodeEntities (Joel Hockey),\n+  Fix use-after-free with `xmllint --html --push` (Nick Wellnhofer),\n+  Allow FP division by zero in xmlXPathInit (Nick Wellnhofer),\n+  Fix xmlGetNodePath with invalid node types (Nick Wellnhofer),\n+  Fix exponential behavior with recursive entities (Nick Wellnhofer),\n+  Fix quadratic behavior when looking up xml:* attributes (Nick Wellnhofer),\n+  Fix slow parsing of HTML with encoding errors (Nick Wellnhofer),\n+  Fix null deref introduced with previous commit (Nick Wellnhofer),\n+  Check for invalid redeclarations of predefined entities (Nick Wellnhofer),\n+  Add the copy of type from original xmlDoc in xmlCopyDoc() (SVGAnimate),\n+  parser.c: shrink the input buffer when appropriate (Mike Dalessio),\n+  Fix infinite loop in HTML parser introduced with recent commits (Nick Wellnhofer),\n+  Fix quadratic runtime when parsing CDATA sections (Nick Wellnhofer),\n+  Fix timeout when handling recursive entities (Nick Wellnhofer),\n+  Fix memory leak in xmlParseElementMixedContentDecl (Nick Wellnhofer),\n+  Fix null deref in xmlStringGetNodeList (Nick Wellnhofer),\n+  use new htmlParseLookupCommentEnd to find comment ends (Mike Dalessio),\n+  htmlParseComment: treat `--!>` as if it closed the comment (Mike Dalessio),\n+  Fix integer overflow in xmlSchemaGetParticleTotalRangeMin (Nick Wellnhofer),\n+  encoding: fix memleak in xmlRegisterCharEncodingHandler() (Xiaoming Ni),\n+  xmlschemastypes.c: xmlSchemaGetFacetValueAsULong add, check \"facet->val\" (Xiaoming Ni),\n+  Fix null pointer deref in xmlXPtrRangeInsideFunction (Nick Wellnhofer),\n+  Fix quadratic runtime in HTML push parser with null bytes (Nick Wellnhofer),\n+  Avoid quadratic checking of identity-constraints (Michael Matz),\n+  Fix building with ICU 68. (Frederik Seiffert),\n+  Convert python\/libxml.c to PY_SSIZE_T_CLEAN (Victor Stinner),\n+  Fix xmlURIEscape memory leaks. (Elliott Hughes),\n+  Avoid call stack overflow with XML reader and recursive XIncludes (Nick Wellnhofer),\n+  Fix caret in regexp character group (Nick Wellnhofer),\n+  parser.c: xmlParseCharData peek behavior fixed wrt newlines (Mike Dalessio),\n+  Fix memory leaks in XPointer string-range function (Nick Wellnhofer),\n+  Fix use-after-free when XIncluding text from Reader (Nick Wellnhofer),\n+  Fix SEGV in xmlSAXParseFileWithData (yanjinjq),\n+  Fix null deref in XPointer expression error path (Nick Wellnhofer),\n+  Don't call xmlXPathInit directly (Nick Wellnhofer),\n+  Fix cleanup of attributes in XML reader (Nick Wellnhofer),\n+  Fix double free in XML reader with XIncludes (Nick Wellnhofer),\n+  Fix memory leak in xmlXIncludeAddNode error paths (Nick Wellnhofer),\n+  Revert \"Fix quadratic runtime in xi:fallback processing\" (Nick Wellnhofer),\n+  Fix error reporting with xi:fallback (Nick Wellnhofer),\n+  Fix quadratic runtime in xi:fallback processing (Nick Wellnhofer),\n+  Fix corner case with empty xi:fallback (Nick Wellnhofer),\n+  Fix XInclude regression introduced with recent commit (Nick Wellnhofer),\n+  Fix memory leak in runtest.c (Nick Wellnhofer),\n+  Make \"xmllint --push --recovery\" work (Nick Wellnhofer),\n+  Revert \"Do not URI escape in server side includes\" (Nick Wellnhofer),\n+  Fix column number accounting in xmlParse*NameAndCompare (Nick Wellnhofer),\n+  Stop counting nbChars in parser context (Nick Wellnhofer),\n+  Fix out-of-bounds read with 'xmllint --htmlout' (Nick Wellnhofer),\n+  Fix exponential runtime and memory in xi:fallback processing (Nick Wellnhofer),\n+  Don't process siblings of root in xmlXIncludeProcess (Nick Wellnhofer),\n+  Don't recurse into xi:include children in xmlXIncludeDoProcess (Nick Wellnhofer),\n+  Fix memory leak in xmlXIncludeIncludeNode error paths (Nick Wellnhofer),\n+  Check for custom free function in global destructor (Nick Wellnhofer),\n+  Fix integer overflow when comparing schema dates (Nick Wellnhofer),\n+  Fix exponential runtime in xmlFARecurseDeterminism (Nick Wellnhofer),\n+  Don't try to handle namespaces when building HTML documents (Nick Wellnhofer),\n+  Fix several quadratic runtime issues in HTML push parser (Nick Wellnhofer),\n+  Fix quadratic runtime when push parsing HTML start tags (Nick Wellnhofer),\n+  Reset XML parser input before reporting errors (David Kilzer),\n+  Fix quadratic runtime when push parsing HTML entity refs (Nick Wellnhofer),\n+  Fix HTML push parser lookahead (Nick Wellnhofer),\n+  Make htmlCurrentChar always translate U+0000 (Nick Wellnhofer),\n+  Fix UTF-8 decoder in HTML parser (Nick Wellnhofer),\n+  Fix quadratic runtime when parsing HTML script content (Nick Wellnhofer),\n+  Reset HTML parser input before reporting error (Nick Wellnhofer),\n+  Fix more quadratic runtime issues in HTML push parser (Nick Wellnhofer),\n+  Fix regression introduced with 477c7f6a (Nick Wellnhofer),\n+  Fix quadratic runtime in HTML parser (Nick Wellnhofer),\n+  Reset HTML parser input before reporting encoding error (Nick Wellnhofer),\n+  Fix integer overflow in xmlFAParseQuantExact (Nick Wellnhofer),\n+  Fix return value of xmlC14NDocDumpMemory (Nick Wellnhofer),\n+  Don't follow next pointer on documents in xmlXPathRunStreamEval (Nick Wellnhofer),\n+  Fix integer overflow in _xmlSchemaParseGYear (Nick Wellnhofer),\n+  Fix integer overflow when parsing {min,max}Occurs (Nick Wellnhofer),\n+  Fix another memory leak in xmlSchemaValAtomicType (Nick Wellnhofer),\n+  Fix unsigned integer overflow in htmlParseTryOrFinish (Nick Wellnhofer),\n+  Fix integer overflow in htmlParseCharRef (Nick Wellnhofer),\n+  Fix undefined behavior in UTF16LEToUTF8 (Nick Wellnhofer),\n+  Fix return value of xmlCharEncOutput (Nick Wellnhofer),\n+  Never expand parameter entities in text declaration (Nick Wellnhofer),\n+  Fix undefined behavior in xmlXPathTryStreamCompile (Nick Wellnhofer),\n+  Fix use-after-free with validating reader (Nick Wellnhofer),\n+  xmlParseBalancedChunkMemory must not be called with NULL doc (Nick Wellnhofer),\n+  Revert \"Fix memory leak in xmlParseBalancedChunkMemoryRecover\" (Nick Wellnhofer),\n+  Fix memory leak in xmlXIncludeLoadDoc error path (Nick Wellnhofer),\n+  Make schema validation fail with multiple top-level elements (Nick Wellnhofer),\n+  Call xmlCleanupParser on ELF destruction (Samuel Thibault),\n+  Fix copying of entities in xmlParseReference (Nick Wellnhofer),\n+  Fix memory leak in xmlSchemaValidateStream (Zhipeng Xie),\n+  Fix xmlSchemaGetCanonValue formatting for date and dateTime (Kevin Puetz),\n+  Fix memory leak when shared libxml.dll is unloaded (Kevin Puetz),\n+  Fix potentially-uninitialized critical section in Win32 DLL builds (Kevin Puetz),\n+  Fix integer overflow in xmlBufferResize (Nick Wellnhofer),\n+  Check for overflow when allocating two-dimensional arrays (Nick Wellnhofer),\n+  Remove useless comparisons (Nick Wellnhofer),\n+  Fix overflow check in xmlNodeDump (Nick Wellnhofer),\n+  Fix infinite loop in xmlStringLenDecodeEntities (Zhipeng Xie),\n+  Fix freeing of nested documents (Nick Wellnhofer),\n+  Fix more memory leaks in error paths of XPath parser (Nick Wellnhofer),\n+  Fix memory leaks of encoding handlers in xmlsave.c (Nick Wellnhofer),\n+  Fix xml2-config error code (Nick Wellnhofer),\n+  Fix memory leak in error path of XPath expr parser (Nick Wellnhofer),\n+  Fix overflow handling in xmlBufBackToBuffer (Nick Wellnhofer),\n+  Null pointer handling in catalog.c (raniervf),\n+  xml2-config.in: fix regressions introduced by commit 2f2bf4b2c (Dmitry V. Levin)\n+  \n+   - Improvements:\n+  Store per-element parser state in a struct (Nick Wellnhofer),\n+  update for xsd:language type check (PaulHiggs),\n+  Update INSTALL.libxml2 (Nick Wellnhofer),\n+  Fix include order in c14n.h (Nick Wellnhofer),\n+  Fix duplicate xmlStrEqual calls in htmlParseEndTag (Nick Wellnhofer),\n+  Speed up htmlCheckAutoClose (Nick Wellnhofer),\n+  Speed up htmlTagLookup (Nick Wellnhofer),\n+  Stop checking attributes for UTF-8 validity (Nick Wellnhofer),\n+  Reduce some fuzzer timeouts (Nick Wellnhofer),\n+  Only run a few CI tests unless scheduled (Nick Wellnhofer),\n+  Improve fuzzer stability (Nick Wellnhofer),\n+  Check for feature flags in fuzzer tests (Nick Wellnhofer),\n+  Another attempt at improving fuzzer stability (Nick Wellnhofer),\n+  Revert \"Improve HTML fuzzer stability\" (Nick Wellnhofer),\n+  Add charset names to fuzzing dictionaries (Nick Wellnhofer),\n+  Improve HTML fuzzer stability (Nick Wellnhofer),\n+  Add CI for MSVC x86 (Markus Rickert),\n+  Add a flag to not output anything when xmllint succeeded (hhb),\n+  Speed up HTML fuzzer (Nick Wellnhofer),\n+  Remove unused encoding parameter of HTML output functions (Nick Wellnhofer),\n+  Handle malloc failures in fuzzing code (Nick Wellnhofer),\n+  add test coverage for incorrectly-closed comments (Mike Dalessio),\n+  Enforce maximum length of fuzz input (Nick Wellnhofer),\n+  Remove temporary members from struct _xmlXPathContext (Nick Wellnhofer),\n+  Build the Python extension with PY_SSIZE_T_CLEAN (Victor Stinner),\n+  Add CI test for Python 3 (Nick Wellnhofer),\n+  Add fuzzing dictionaries to EXTRA_DIST (Nick Wellnhofer),\n+  Add 'fuzz' subdirectory to DIST_SUBDIRS (Nick Wellnhofer),\n+  Allow port numbers up to INT_MAX (Nick Wellnhofer),\n+  Handle dumps of corrupted documents more gracefully (Nick Wellnhofer),\n+  Limit size of free lists in XML reader when fuzzing (Nick Wellnhofer),\n+  Hardcode maximum XPath recursion depth (Nick Wellnhofer),\n+  Pass URL of main entity in XML fuzzer (Nick Wellnhofer),\n+  Consolidate seed corpus generation (Nick Wellnhofer),\n+  Test fuzz targets with dummy driver (Nick Wellnhofer),\n+  Fix regression introduced with commit d88df4b (Nick Wellnhofer),\n+  Fix regression introduced with commit 74dcc10b (Nick Wellnhofer),\n+  Add TODO comment in xinclude.c (Nick Wellnhofer),\n+  Stop using maxParserDepth in xpath.c (Nick Wellnhofer),\n+  Remove dead code in xinclude.c (Nick Wellnhofer),\n+  Don't add formatting newlines to XInclude nodes (Nick Wellnhofer),\n+  Don't use SAX1 if all element handlers are NULL (Nick Wellnhofer),\n+  Remove unneeded progress checks in HTML parser (Nick Wellnhofer),\n+  Use strcmp when fuzzing (Nick Wellnhofer),\n+  Fix XPath fuzzer (Nick Wellnhofer),\n+  Fuzz XInclude engine (Nick Wellnhofer),\n+  Add XPath and XPointer fuzzer (Nick Wellnhofer),\n+  Update fuzzing code (Nick Wellnhofer),\n+  More *NodeDumpOutput fixes (Nick Wellnhofer),\n+  Fix *NodeDumpOutput functions (Nick Wellnhofer),\n+  Make xmlNodeDumpOutputInternal non-recursive (Nick Wellnhofer),\n+  Make xhtmlNodeDumpOutput non-recursive (Nick Wellnhofer),\n+  Make htmlNodeDumpFormatOutput non-recursive (Nick Wellnhofer),\n+  Fix .gitattributes (Nick Wellnhofer),\n+  Rework control flow in htmlCurrentChar (Nick Wellnhofer),\n+  Make 'xmllint --html --push -' read from stdin (Nick Wellnhofer),\n+  Remove misleading comments in xpath.c (Nick Wellnhofer),\n+  Update to Devhelp index file format version 2 (Andre Klapper),\n+  Set project language to C (Markus Rickert),\n+  Add variable for working directory of XML Conformance Test Suite (Markus Rickert),\n+  Add additional tests and XML Conformance Test Suite (Markus Rickert),\n+  Add command line option for temp directory in runtest (Markus Rickert),\n+  Ensure LF line endings for test files (Markus Rickert),\n+  Enable runtests and testThreads (Markus Rickert),\n+  Limit regexp nesting depth (Nick Wellnhofer),\n+  Fix return values and documentation in encoding.c (Nick Wellnhofer),\n+  Add regexp regression tests (David Kilzer),\n+  Report error for invalid regexp quantifiers (Nick Wellnhofer),\n+  Fix rebuilding docs, by hiding __attribute__((...)) behind a macro. (Martin Vidner),\n+  Copy xs:duration parser from libexslt (Nick Wellnhofer),\n+  Fuzz target for XML Schemas (Nick Wellnhofer),\n+  Move entity recorder to fuzz.c (Nick Wellnhofer),\n+  Fuzz target for HTML parser (Nick Wellnhofer),\n+  Update GitLab CI container (Nick Wellnhofer),\n+  Add options file for xml fuzzer (Nick Wellnhofer),\n+  Add a couple of libFuzzer targets (Nick Wellnhofer),\n+  Guard new calls to xmlValidatePopElement in xml_reader.c (Daniel Cheng),\n+  Add LIBXML_VALID_ENABLED to xmlreader (Łukasz Wojniłowicz),\n+  Fix typos (Nick Wellnhofer),\n+  Disable LeakSanitizer (Nick Wellnhofer),\n+  Stop calling SAX getEntity handler from XMLReader (Nick Wellnhofer),\n+  Add test case for recursive external parsed entities (Nick Wellnhofer),\n+  Enable error tests with entity substitution (Nick Wellnhofer),\n+  Don't load external entity from xmlSAX2GetEntity (Nick Wellnhofer),\n+  Merge code paths loading external entities (Nick Wellnhofer),\n+  Copy some XMLReader option flags to parser context (Nick Wellnhofer),\n+  Add xmlPopOutputCallbacks (Nick Wellnhofer),\n+  Updated Python test reader2.py (Pieter van Oostrum),\n+  Updated python\/tests\/tstLastError.py (Pieter van Oostrum),\n+  Use random seed in xmlDictComputeFastKey (Ranier Vilela),\n+  Enable more undefined behavior sanitizers (Nick Wellnhofer)\n+  \n+\n+\n+v2.9.10: Oct 30 2019:\n+   - Documentation:\n+  Fix a few more typos (\"fonction\") (Nick Wellnhofer),\n+  Large batch of typo fixes (Jared Yanovich),\n+  Fix typos: tree: move{ -> s}, reconcil{i -> }ed, h{o -> e}ld by... (Jan Pokorný),\n+  Fix typo: xpath: simpli{ -> fi}ed (Jan Pokorný),\n+  Doc: do not mislead towards \"infeasible\" scenario wrt. xmlBufNodeDump (Jan Pokorný),\n+  Fix comments in test code (zhouzhongyuan),\n+  fix comment in testReader.c (zhouzhongyuan)\n+  \n+   - Portability:\n+  Fix some release issues on Fedora 30 (Daniel Veillard),\n+  Fix exponent digits when running tests under old MSVC (Daniel Richard G),\n+  Work around buggy ceil() function on AIX (Daniel Richard G),\n+  Don't call printf with NULL string in runtest.c (Daniel Richard G),\n+  Switched from unsigned long to ptrdiff_t in parser.c (Stephen Chenney),\n+  timsort.h: support older GCCs (Jérôme Duval),\n+  Make configure.ac work with older pkg-config (Nick Wellnhofer),\n+  Stop defining _REENTRANT on some Win32 platforms (Nick Wellnhofer),\n+  Fix nanohttp.c on MinGW (Nick Wellnhofer),\n+  Fix Windows compiler warning in testC14N.c (Nick Wellnhofer),\n+  Merge testThreadsWin32.c into testThreads.c (Nick Wellnhofer),\n+  Fix Python bindings under Windows (Nick Wellnhofer)\n+  \n+   - Bug Fixes:\n+  Another fix for conditional sections at end of document (Nick Wellnhofer),\n+  Fix for conditional sections at end of document (Nick Wellnhofer),\n+  Make sure that Python tests exit with error code (Nick Wellnhofer),\n+  Audit memory error handling in xpath.c (Nick Wellnhofer),\n+  Fix error code in xmlTextWriterStartDocument (Nick Wellnhofer),\n+  Fix integer overflow when counting written bytes (Nick Wellnhofer),\n+  Fix uninitialized memory access in HTML parser (Nick Wellnhofer),\n+  Fix memory leak in xmlSchemaValAtomicType (Nick Wellnhofer),\n+  Disallow conditional sections in internal subset (Nick Wellnhofer),\n+  Fix use-after-free in xmlTextReaderFreeNodeList (Nick Wellnhofer),\n+  Fix Regextests (Nick Wellnhofer),\n+  Fix empty branch in regex (Nick Wellnhofer),\n+  Fix integer overflow in entity recursion check (Nick Wellnhofer),\n+  Don't read external entities or XIncludes from stdin (Nick Wellnhofer),\n+  Fix Schema determinism check of ##other namespaces (Nick Wellnhofer),\n+  Fix potential null deref in xmlSchemaIDCFillNodeTables (zhouzhongyuan),\n+  Fix potential memory leak in xmlBufBackToBuffer (Nick Wellnhofer),\n+  Fix error message when processing XIncludes with fallbacks (Nick Wellnhofer),\n+  Fix memory leak in xmlRegEpxFromParse (zhouzhongyuan),\n+  14:00 is a valid timezone for xs:dateTime (Nick Wellnhofer),\n+  Fix memory leak in xmlParseBalancedChunkMemoryRecover (Zhipeng Xie),\n+  Fix potential null deref in xmlRelaxNGParsePatterns (Nick Wellnhofer),\n+  Misleading error message with xs:{min|max}Inclusive (bettermanzzy),\n+  Fix memory leak in xmlXIncludeLoadTxt (Wang Kirin),\n+  Partial fix for comparison of xs:durations (Nick Wellnhofer),\n+  Fix null deref in xmlreader buffer (zhouzhongyuan),\n+  Fix unability to RelaxNG-validate grammar with choice-based name class (Jan Pokorný),\n+  Fix unability to validate ambiguously constructed interleave for RelaxNG (Jan Pokorný),\n+  Fix possible null dereference in xmlXPathIdFunction (zhouzhongyuan),\n+  fix memory leak in xmlAllocOutputBuffer (zhouzhongyuan),\n+  Fix unsigned int overflow (Jens Eggerstedt),\n+  dict.h: gcc 2.95 doesn't allow multiple storage classes (Nick Wellnhofer),\n+  Fix another code path in xmlParseQName (Nick Wellnhofer),\n+  Make sure that xmlParseQName returns NULL in error case (Nick Wellnhofer),\n+  Fix build without reader but with pattern (Nick Wellnhofer),\n+  Fix memory leak in xmlAllocOutputBufferInternal error path (Nick Wellnhofer),\n+  Fix unsigned integer overflow (Nick Wellnhofer),\n+  Fix return value of xmlOutputBufferWrite (Nick Wellnhofer),\n+  Fix parser termination from \"Double hyphen within comment\" error (David Warring),\n+  Fix call stack overflow in xmlFreePattern (Nick Wellnhofer),\n+  Fix null deref in previous commit (Nick Wellnhofer),\n+  Fix memory leaks in xmlXPathParseNameComplex error paths (Nick Wellnhofer),\n+  Check for integer overflow in xmlXPtrEvalChildSeq (Nick Wellnhofer),\n+  Fix xmllint dump of XPath namespace nodes (Nick Wellnhofer),\n+  Fix float casts in xmlXPathSubstringFunction (Nick Wellnhofer),\n+  Fix null deref in xmlregexp error path (Nick Wellnhofer),\n+  Fix null pointer dereference in xmlTextReaderReadOuterXml (Nick Wellnhofer),\n+  Fix memory leaks in xmlParseStartTag2 error paths (Nick Wellnhofer),\n+  Fix memory leak in xmlSAX2StartElement (Nick Wellnhofer),\n+  Fix commit \"Memory leak in xmlFreeID (xmlreader.c)\" (Nick Wellnhofer),\n+  Fix NULL pointer deref in xmlTextReaderValidateEntity (Nick Wellnhofer),\n+  Memory leak in xmlFreeTextReader (Nick Wellnhofer),\n+  Memory leak in xmlFreeID (xmlreader.c) (Nick Wellnhofer)\n+  \n+   - Improvements:\n+  Run XML conformance tests under CI (Nick Wellnhofer),\n+  Update GitLab CI config (Nick Wellnhofer),\n+  Propagate memory errors in valuePush (Nick Wellnhofer),\n+  Propagate memory errors in xmlXPathCompExprAdd (Nick Wellnhofer),\n+  Make xmlFreeDocElementContent non-recursive (Nick Wellnhofer),\n+  Enable continuous integration via GitLab CI (Nick Wellnhofer),\n+  Avoid ignored attribute warnings under GCC (Nick Wellnhofer),\n+  Make xmlDumpElementContent non-recursive (Nick Wellnhofer),\n+  Make apibuild.py ignore ATTRIBUTE_NO_SANITIZE (Nick Wellnhofer),\n+  Mark xmlExp* symbols as removed (Nick Wellnhofer),\n+  Make xmlParseConditionalSections non-recursive (Nick Wellnhofer),\n+  Adjust expected error in Python tests (Nick Wellnhofer),\n+  Make xmlTextReaderFreeNodeList non-recursive (Nick Wellnhofer),\n+  Make xmlFreeNodeList non-recursive (Nick Wellnhofer),\n+  Make xmlParseContent and xmlParseElement non-recursive (Nick Wellnhofer),\n+  Remove executable bit from non-executable files (Nick Wellnhofer),\n+  Fix expected output of test\/schemas\/any4 (Nick Wellnhofer),\n+  Optimize build instructions in README (zhouzhongyuan),\n+  xml2-config.in: Output CFLAGS and LIBS on the same line (Hugh McMaster),\n+  xml2-config: Add a --dynamic switch to print only shared libraries (Hugh McMaster),\n+  Annotate functions with __attribute__((no_sanitize)) (Nick Wellnhofer),\n+  Fix warnings when compiling without reader or push parser (Nick Wellnhofer),\n+  Remove unused member `doc` in xmlSaveCtxt (Nick Wellnhofer),\n+  Limit recursion depth in xmlXPathCompOpEvalPredicate (Nick Wellnhofer),\n+  Remove -Wno-array-bounds (Nick Wellnhofer),\n+  Remove unreachable code in xmlXPathCountFunction (Nick Wellnhofer),\n+  Improve XPath predicate and filter evaluation (Nick Wellnhofer),\n+  Limit recursion depth in xmlXPathOptimizeExpression (Nick Wellnhofer),\n+  Disable hash randomization when fuzzing (Nick Wellnhofer),\n+  Optional recursion limit when parsing XPath expressions (Nick Wellnhofer),\n+  Optional recursion limit when evaluating XPath expressions (Nick Wellnhofer),\n+  Use break statements in xmlXPathCompOpEval (Nick Wellnhofer),\n+  Optional XPath operation limit (Nick Wellnhofer),\n+  Fix compilation with --with-minimum (Nick Wellnhofer),\n+  Check XPath stack after calling functions (Nick Wellnhofer),\n+  Remove debug printf in xmlreader.c (Nick Wellnhofer),\n+  Always define LIBXML_THREAD_ENABLED when enabled (Michael Haubenwallner),\n+  Regenerate NEWS (Nick Wellnhofer),\n+  Change git repo URL (Nick Wellnhofer),\n+  Change bug tracker URL (Nick Wellnhofer),\n+  Remove outdated HTML file (Nick Wellnhofer),\n+  Fix unused function warning in testapi.c (Nick Wellnhofer),\n+  Add some generated test files to .gitignore (Nick Wellnhofer),\n+  Remove unneeded function pointer casts (Nick Wellnhofer),\n+  Fix -Wcast-function-type warnings (GCC 8) (Nick Wellnhofer),\n+  Fix -Wformat-truncation warnings (GCC 8) (Nick Wellnhofer)\n+  \n+   - Cleanups:\n+  Rebuild docs (Nick Wellnhofer),\n+  Disable xmlExp regex code (Nick Wellnhofer),\n+  Remove redundant code in xmlRelaxNGValidateState (Nick Wellnhofer),\n+  Remove redundant code in xmlXPathCompRelationalExpr (Nick Wellnhofer)\n+  \n+\n+\n@@ -17,1 +500,1 @@\n-\n+  \n@@ -20,1 +503,1 @@\n-\n+  \n@@ -29,1 +512,1 @@\n-\n+  \n@@ -51,1 +534,1 @@\n-\n+  \n@@ -70,1 +553,1 @@\n-\n+  \n@@ -72,1 +555,1 @@\n-\n+  \n@@ -82,1 +565,1 @@\n-\n+  \n@@ -101,1 +584,1 @@\n-\n+  \n@@ -118,1 +601,1 @@\n-\n+  \n@@ -123,2 +606,2 @@\n-  xmlcatalog: refresh man page wrt. quering system catalog easily (Jan Pokorný)\n-\n+  xmlcatalog: refresh man page wrt. querying system catalog easily (Jan Pokorný)\n+  \n@@ -138,1 +621,1 @@\n-\n+  \n@@ -142,1 +625,1 @@\n-\n+  \n@@ -158,1 +641,1 @@\n-\n+  \n@@ -164,1 +647,1 @@\n-\n+  \n@@ -177,1 +660,1 @@\n-\n+  \n@@ -186,1 +669,1 @@\n-\n+  \n@@ -190,1 +673,1 @@\n-\n+  \n@@ -197,1 +680,1 @@\n-\n+  \n@@ -249,1 +732,1 @@\n-\n+  \n@@ -293,1 +776,1 @@\n-\n+  \n@@ -297,1 +780,1 @@\n-\n+  \n@@ -316,1 +799,1 @@\n-\n+  \n@@ -322,1 +805,1 @@\n-\n+  \n@@ -349,1 +832,1 @@\n-\n+  \n@@ -380,1 +863,1 @@\n-\n+  \n@@ -385,1 +868,1 @@\n-\n+  \n@@ -403,1 +886,1 @@\n-\n+  \n@@ -408,1 +891,1 @@\n-\n+  \n@@ -412,1 +895,1 @@\n-\n+  \n@@ -439,1 +922,1 @@\n-\n+  \n@@ -443,1 +926,1 @@\n-  Reenable xz support by default (Daniel Veillard),\n+  Re-enable xz support by default (Daniel Veillard),\n@@ -451,1 +934,1 @@\n-\n+  \n@@ -453,1 +936,1 @@\n-\n+  \n@@ -817,1 +1300,1 @@\n-    Swicth the test program for characters to new input buffers (Daniel Veillard),\n+    Switch the test program for characters to new input buffers (Daniel Veillard),\n@@ -912,1 +1395,1 @@\n-    HTML element position is not detected propperly (Pavel Andrejs),\n+    HTML element position is not detected properly (Pavel Andrejs),\n@@ -940,1 +1423,1 @@\n-    Reactivate the shared library versionning script (Daniel Veillard)\n+    Reactivate the shared library versioning script (Daniel Veillard)\n@@ -1127,1 +1610,1 @@\n-    Small patch to accomodate the Haiku OS (Scott McCreary),\n+    Small patch to accommodate the Haiku OS (Scott McCreary),\n@@ -1157,1 +1640,1 @@\n-    566012 part 2 fix regresion tests and push mode (Daniel Veillard),\n+    566012 part 2 fix regression tests and push mode (Daniel Veillard),\n@@ -1284,1 +1767,1 @@\n-      when encoder cant serialize characters on output\n+      when encoder can't serialize characters on output\n@@ -1291,1 +1774,1 @@\n-      new hashing functions for dictionnaries (based on Stefan Behnel work),\n+      new hashing functions for dictionaries (based on Stefan Behnel work),\n@@ -1349,1 +1832,1 @@\n-      some make distcheck realted fixes (John Carr)\n+      some make distcheck related fixes (John Carr)\n@@ -1444,1 +1927,1 @@\n-      missing destry in xmlFreeRMutex (Andrew Nosenko), XML Schemas fixes\n+      missing destroy in xmlFreeRMutex (Andrew Nosenko), XML Schemas fixes\n@@ -1450,1 +1933,1 @@\n-      crasher, parser safety patch (Ben Darnell), _private context propagation\n+      crash, parser safety patch (Ben Darnell), _private context propagation\n@@ -1591,1 +2074,1 @@\n-    xs:anyType in Schemas (Kasimier), Python resolver emmitting error\n+    xs:anyType in Schemas (Kasimier), Python resolver emitting error\n@@ -1617,1 +2100,1 @@\n-    pthread dependancy on Linux, compilation problem (Steve Nairn), compiling\n+    pthread dependency on Linux, compilation problem (Steve Nairn), compiling\n@@ -1658,1 +2141,1 @@\n-    Fabrice), workaround \"DAV:\" namespace brokeness in c14n (Aleksey Sanin),\n+    Fabrice), workaround \"DAV:\" namespace brokenness in c14n (Aleksey Sanin),\n@@ -1677,1 +2160,1 @@\n-    xmlreader stopping on non-fatal errors, thread support for dictionnaries\n+    xmlreader stopping on non-fatal errors, thread support for dictionaries\n@@ -1732,1 +2215,1 @@\n-   - documentation: fix to xmllint man page, some API function descritpion\n+   - documentation: fix to xmllint man page, some API function description\n@@ -1872,1 +2355,1 @@\n-    validation bug (William), xmlReader Close() fix, recusive extention\n+    validation bug (William), xmlReader Close() fix, recursive extension\n@@ -1877,1 +2360,1 @@\n-    dependancy, XML Schemas union support (Kasimier Buchcik), warning removal\n+    dependency, XML Schemas union support (Kasimier Buchcik), warning removal\n@@ -1928,1 +2411,1 @@\n-    (Eric Haszlakiewicz), XInclude dictionnaries issues (William and Oleg\n+    (Eric Haszlakiewicz), XInclude dictionaries issues (William and Oleg\n@@ -1944,1 +2427,1 @@\n-   - Parsers: added xmlByteConsumed(ctxt) API to get the byte offest in\n+   - Parsers: added xmlByteConsumed(ctxt) API to get the byte offset in\n@@ -1949,1 +2432,1 @@\n-   - Bugfixes: dictionnaries for schemas (William Brack), regexp segfault\n+   - Bugfixes: dictionaries for schemas (William Brack), regexp segfault\n@@ -2889,1 +3372,1 @@\n-      improved a lot parsing speed when there is large CDATA blocs\n+      improved a lot parsing speed when there is large CDATA blocks\n@@ -2898,1 +3381,1 @@\n-   - improved a lot parsing speed when there is large CDATA blocs\n+   - improved a lot parsing speed when there is large CDATA blocks\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/NEWS","additions":542,"deletions":59,"binary":false,"changes":601,"status":"modified"},{"patch":"@@ -1,40 +0,0 @@\n-\n-                  XML toolkit from the GNOME project\n-\n-Full documentation is available on-line at\n-    http:\/\/xmlsoft.org\/\n-\n-This code is released under the MIT Licence see the Copyright file.\n-\n-To build on an Unixised setup:\n-   .\/configure ; make ; make install\n-   if the .\/configure file does not exist, run .\/autogen.sh instead.\n-To build on Windows:\n-   see instructions on win32\/Readme.txt\n-\n-To assert build quality:\n-   on an Unixised setup:\n-      run make tests\n-   otherwise:\n-       There is 3 standalone tools runtest.c runsuite.c testapi.c, which\n-       should compile as part of the build or as any application would.\n-       Launch them from this directory to get results, runtest checks \n-       the proper functioning of libxml2 main APIs while testapi does\n-       a full coverage check. Report failures to the list.\n-\n-To report bugs, follow the instructions at: \n-  http:\/\/xmlsoft.org\/bugs.html\n-\n-A mailing-list xml@gnome.org is available, to subscribe:\n-    http:\/\/mail.gnome.org\/mailman\/listinfo\/xml\n-\n-The list archive is at:\n-    http:\/\/mail.gnome.org\/archives\/xml\/\n-\n-All technical answers asked privately will be automatically answered on\n-the list and archived for public access unless privacy is explicitly\n-required and justified.\n-\n-Daniel Veillard\n-\n-$Id$\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/README","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -49,3 +49,3 @@\n-#define TODO                                \\\n-    xmlGenericError(xmlGenericErrorContext,             \\\n-        \"Unimplemented block at %s:%d\\n\",               \\\n+#define TODO                                                            \\\n+    xmlGenericError(xmlGenericErrorContext,                             \\\n+            \"Unimplemented block at %s:%d\\n\",                           \\\n@@ -65,12 +65,12 @@\n-    ctxt->errNo = XML_ERR_NO_MEMORY;\n-    if ((ctxt->sax != NULL) && (ctxt->sax->initialized == XML_SAX2_MAGIC))\n-        schannel = ctxt->sax->serror;\n-    __xmlRaiseError(schannel,\n-            ctxt->vctxt.error, ctxt->vctxt.userData,\n-            ctxt, NULL, XML_FROM_PARSER, XML_ERR_NO_MEMORY,\n-            XML_ERR_ERROR, NULL, 0, (const char *) str1,\n-            NULL, NULL, 0, 0,\n-            msg, (const char *) str1, NULL);\n-    ctxt->errNo = XML_ERR_NO_MEMORY;\n-    ctxt->instate = XML_PARSER_EOF;\n-    ctxt->disableSAX = 1;\n+        ctxt->errNo = XML_ERR_NO_MEMORY;\n+        if ((ctxt->sax != NULL) && (ctxt->sax->initialized == XML_SAX2_MAGIC))\n+            schannel = ctxt->sax->serror;\n+        __xmlRaiseError(schannel,\n+                        ctxt->vctxt.error, ctxt->vctxt.userData,\n+                        ctxt, NULL, XML_FROM_PARSER, XML_ERR_NO_MEMORY,\n+                        XML_ERR_ERROR, NULL, 0, (const char *) str1,\n+                        NULL, NULL, 0, 0,\n+                        msg, (const char *) str1, NULL);\n+        ctxt->errNo = XML_ERR_NO_MEMORY;\n+        ctxt->instate = XML_PARSER_EOF;\n+        ctxt->disableSAX = 1;\n@@ -78,6 +78,6 @@\n-    __xmlRaiseError(schannel,\n-            NULL, NULL,\n-            ctxt, NULL, XML_FROM_PARSER, XML_ERR_NO_MEMORY,\n-            XML_ERR_ERROR, NULL, 0, (const char *) str1,\n-            NULL, NULL, 0, 0,\n-            msg, (const char *) str1, NULL);\n+        __xmlRaiseError(schannel,\n+                        NULL, NULL,\n+                        ctxt, NULL, XML_FROM_PARSER, XML_ERR_NO_MEMORY,\n+                        XML_ERR_ERROR, NULL, 0, (const char *) str1,\n+                        NULL, NULL, 0, 0,\n+                        msg, (const char *) str1, NULL);\n@@ -105,1 +105,1 @@\n-    return;\n+        return;\n@@ -107,10 +107,10 @@\n-    ctxt->errNo = error;\n-    if ((ctxt->sax != NULL) && (ctxt->sax->initialized == XML_SAX2_MAGIC))\n-        schannel = ctxt->sax->serror;\n-    __xmlRaiseError(schannel,\n-            ctxt->vctxt.error, ctxt->vctxt.userData,\n-            ctxt, NULL, XML_FROM_DTD, error,\n-            XML_ERR_ERROR, NULL, 0, (const char *) str1,\n-            (const char *) str2, NULL, 0, 0,\n-            msg, (const char *) str1, (const char *) str2);\n-    ctxt->valid = 0;\n+        ctxt->errNo = error;\n+        if ((ctxt->sax != NULL) && (ctxt->sax->initialized == XML_SAX2_MAGIC))\n+            schannel = ctxt->sax->serror;\n+        __xmlRaiseError(schannel,\n+                        ctxt->vctxt.error, ctxt->vctxt.userData,\n+                        ctxt, NULL, XML_FROM_DTD, error,\n+                        XML_ERR_ERROR, NULL, 0, (const char *) str1,\n+                        (const char *) str2, NULL, 0, 0,\n+                        msg, (const char *) str1, (const char *) str2);\n+        ctxt->valid = 0;\n@@ -118,6 +118,6 @@\n-    __xmlRaiseError(schannel,\n-            NULL, NULL,\n-            ctxt, NULL, XML_FROM_DTD, error,\n-            XML_ERR_ERROR, NULL, 0, (const char *) str1,\n-            (const char *) str2, NULL, 0, 0,\n-            msg, (const char *) str1, (const char *) str2);\n+        __xmlRaiseError(schannel,\n+                        NULL, NULL,\n+                        ctxt, NULL, XML_FROM_DTD, error,\n+                        XML_ERR_ERROR, NULL, 0, (const char *) str1,\n+                        (const char *) str2, NULL, 0, 0,\n+                        msg, (const char *) str1, (const char *) str2);\n@@ -143,1 +143,1 @@\n-    return;\n+        return;\n@@ -145,1 +145,1 @@\n-    ctxt->errNo = error;\n+        ctxt->errNo = error;\n@@ -148,2 +148,2 @@\n-            (const char *) str1, (const char *) str2,\n-            NULL, 0, 0, msg, str1, str2);\n+                    (const char *) str1, (const char *) str2,\n+                    NULL, 0, 0, msg, str1, str2);\n@@ -151,4 +151,4 @@\n-    ctxt->wellFormed = 0;\n-    ctxt->valid = 0;\n-    if (ctxt->recovery == 0)\n-        ctxt->disableSAX = 1;\n+        ctxt->wellFormed = 0;\n+        ctxt->valid = 0;\n+        if (ctxt->recovery == 0)\n+            ctxt->disableSAX = 1;\n@@ -174,1 +174,1 @@\n-    return;\n+        return;\n@@ -176,1 +176,1 @@\n-    ctxt->errNo = error;\n+        ctxt->errNo = error;\n@@ -179,2 +179,2 @@\n-            (const char *) str1, NULL,\n-            NULL, 0, 0, msg, str1);\n+                    (const char *) str1, NULL,\n+                    NULL, 0, 0, msg, str1);\n@@ -199,1 +199,1 @@\n-    return;\n+        return;\n@@ -201,1 +201,1 @@\n-    ctxt->errNo = error;\n+        ctxt->errNo = error;\n@@ -204,2 +204,2 @@\n-            (const char *) str1, (const char *) str2,\n-            NULL, 0, 0, msg, str1, str2);\n+                    (const char *) str1, (const char *) str2,\n+                    NULL, 0, 0, msg, str1, str2);\n@@ -223,1 +223,1 @@\n-    return;\n+        return;\n@@ -225,1 +225,1 @@\n-    ctxt->errNo = error;\n+        ctxt->errNo = error;\n@@ -228,2 +228,2 @@\n-            (const char *) str1, (const char *) str2,\n-            NULL, 0, 0, msg, str1, str2);\n+                    (const char *) str1, (const char *) str2,\n+                    NULL, 0, 0, msg, str1, str2);\n@@ -355,1 +355,1 @@\n-           const xmlChar *ExternalID, const xmlChar *SystemID)\n+               const xmlChar *ExternalID, const xmlChar *SystemID)\n@@ -362,1 +362,1 @@\n-        \"SAX.xmlSAX2InternalSubset(%s, %s, %s)\\n\",\n+            \"SAX.xmlSAX2InternalSubset(%s, %s, %s)\\n\",\n@@ -367,1 +367,1 @@\n-    return;\n+        return;\n@@ -370,5 +370,5 @@\n-    if (ctxt->html)\n-        return;\n-    xmlUnlinkNode((xmlNodePtr) dtd);\n-    xmlFreeDtd(dtd);\n-    ctxt->myDoc->intSubset = NULL;\n+        if (ctxt->html)\n+            return;\n+        xmlUnlinkNode((xmlNodePtr) dtd);\n+        xmlFreeDtd(dtd);\n+        ctxt->myDoc->intSubset = NULL;\n@@ -377,1 +377,1 @@\n-    xmlCreateIntSubset(ctxt->myDoc, name, ExternalID, SystemID);\n+        xmlCreateIntSubset(ctxt->myDoc, name, ExternalID, SystemID);\n@@ -393,1 +393,1 @@\n-           const xmlChar *ExternalID, const xmlChar *SystemID)\n+               const xmlChar *ExternalID, const xmlChar *SystemID)\n@@ -399,1 +399,1 @@\n-        \"SAX.xmlSAX2ExternalSubset(%s, %s, %s)\\n\",\n+            \"SAX.xmlSAX2ExternalSubset(%s, %s, %s)\\n\",\n@@ -404,12 +404,12 @@\n-     (ctxt->wellFormed && ctxt->myDoc))) {\n-    \/*\n-     * Try to fetch and parse the external subset.\n-     *\/\n-    xmlParserInputPtr oldinput;\n-    int oldinputNr;\n-    int oldinputMax;\n-    xmlParserInputPtr *oldinputTab;\n-    xmlParserInputPtr input = NULL;\n-    xmlCharEncoding enc;\n-    int oldcharset;\n-    const xmlChar *oldencoding;\n+         (ctxt->wellFormed && ctxt->myDoc))) {\n+        \/*\n+         * Try to fetch and parse the external subset.\n+         *\/\n+        xmlParserInputPtr oldinput;\n+        int oldinputNr;\n+        int oldinputMax;\n+        xmlParserInputPtr *oldinputTab;\n+        xmlParserInputPtr input = NULL;\n+        xmlCharEncoding enc;\n+        int oldcharset;\n+        const xmlChar *oldencoding;\n@@ -417,9 +417,9 @@\n-    \/*\n-     * Ask the Entity resolver to load the damn thing\n-     *\/\n-    if ((ctxt->sax != NULL) && (ctxt->sax->resolveEntity != NULL))\n-        input = ctxt->sax->resolveEntity(ctxt->userData, ExternalID,\n-                                            SystemID);\n-    if (input == NULL) {\n-        return;\n-    }\n+        \/*\n+         * Ask the Entity resolver to load the damn thing\n+         *\/\n+        if ((ctxt->sax != NULL) && (ctxt->sax->resolveEntity != NULL))\n+            input = ctxt->sax->resolveEntity(ctxt->userData, ExternalID,\n+                                                SystemID);\n+        if (input == NULL) {\n+            return;\n+        }\n@@ -427,1 +427,1 @@\n-    xmlNewDtd(ctxt->myDoc, name, ExternalID, SystemID);\n+        xmlNewDtd(ctxt->myDoc, name, ExternalID, SystemID);\n@@ -429,27 +429,27 @@\n-    \/*\n-     * make sure we won't destroy the main document context\n-     *\/\n-    oldinput = ctxt->input;\n-    oldinputNr = ctxt->inputNr;\n-    oldinputMax = ctxt->inputMax;\n-    oldinputTab = ctxt->inputTab;\n-    oldcharset = ctxt->charset;\n-    oldencoding = ctxt->encoding;\n-    ctxt->encoding = NULL;\n-\n-    ctxt->inputTab = (xmlParserInputPtr *)\n-                     xmlMalloc(5 * sizeof(xmlParserInputPtr));\n-    if (ctxt->inputTab == NULL) {\n-        xmlSAX2ErrMemory(ctxt, \"xmlSAX2ExternalSubset\");\n-        ctxt->input = oldinput;\n-        ctxt->inputNr = oldinputNr;\n-        ctxt->inputMax = oldinputMax;\n-        ctxt->inputTab = oldinputTab;\n-        ctxt->charset = oldcharset;\n-        ctxt->encoding = oldencoding;\n-        return;\n-    }\n-    ctxt->inputNr = 0;\n-    ctxt->inputMax = 5;\n-    ctxt->input = NULL;\n-    xmlPushInput(ctxt, input);\n+        \/*\n+         * make sure we won't destroy the main document context\n+         *\/\n+        oldinput = ctxt->input;\n+        oldinputNr = ctxt->inputNr;\n+        oldinputMax = ctxt->inputMax;\n+        oldinputTab = ctxt->inputTab;\n+        oldcharset = ctxt->charset;\n+        oldencoding = ctxt->encoding;\n+        ctxt->encoding = NULL;\n+\n+        ctxt->inputTab = (xmlParserInputPtr *)\n+                         xmlMalloc(5 * sizeof(xmlParserInputPtr));\n+        if (ctxt->inputTab == NULL) {\n+            xmlSAX2ErrMemory(ctxt, \"xmlSAX2ExternalSubset\");\n+            ctxt->input = oldinput;\n+            ctxt->inputNr = oldinputNr;\n+            ctxt->inputMax = oldinputMax;\n+            ctxt->inputTab = oldinputTab;\n+            ctxt->charset = oldcharset;\n+            ctxt->encoding = oldencoding;\n+            return;\n+        }\n+        ctxt->inputNr = 0;\n+        ctxt->inputMax = 5;\n+        ctxt->input = NULL;\n+        xmlPushInput(ctxt, input);\n@@ -457,7 +457,7 @@\n-    \/*\n-     * On the fly encoding conversion if needed\n-     *\/\n-    if (ctxt->input->length >= 4) {\n-        enc = xmlDetectCharEncoding(ctxt->input->cur, 4);\n-        xmlSwitchEncoding(ctxt, enc);\n-    }\n+        \/*\n+         * On the fly encoding conversion if needed\n+         *\/\n+        if (ctxt->input->length >= 4) {\n+            enc = xmlDetectCharEncoding(ctxt->input->cur, 4);\n+            xmlSwitchEncoding(ctxt, enc);\n+        }\n@@ -465,7 +465,7 @@\n-    if (input->filename == NULL)\n-        input->filename = (char *) xmlCanonicPath(SystemID);\n-    input->line = 1;\n-    input->col = 1;\n-    input->base = ctxt->input->cur;\n-    input->cur = ctxt->input->cur;\n-    input->free = NULL;\n+        if (input->filename == NULL)\n+            input->filename = (char *) xmlCanonicPath(SystemID);\n+        input->line = 1;\n+        input->col = 1;\n+        input->base = ctxt->input->cur;\n+        input->cur = ctxt->input->cur;\n+        input->free = NULL;\n@@ -473,4 +473,4 @@\n-    \/*\n-     * let's parse that entity knowing it's an external subset.\n-     *\/\n-    xmlParseExternalSubset(ctxt, ExternalID, SystemID);\n+        \/*\n+         * let's parse that entity knowing it's an external subset.\n+         *\/\n+        xmlParseExternalSubset(ctxt, ExternalID, SystemID);\n@@ -479,2 +479,2 @@\n-     * Free up the external entities\n-     *\/\n+         * Free up the external entities\n+         *\/\n@@ -482,3 +482,3 @@\n-    while (ctxt->inputNr > 1)\n-        xmlPopInput(ctxt);\n-    xmlFreeInputStream(ctxt->input);\n+        while (ctxt->inputNr > 1)\n+            xmlPopInput(ctxt);\n+        xmlFreeInputStream(ctxt->input);\n@@ -487,14 +487,14 @@\n-    \/*\n-     * Restore the parsing context of the main entity\n-     *\/\n-    ctxt->input = oldinput;\n-    ctxt->inputNr = oldinputNr;\n-    ctxt->inputMax = oldinputMax;\n-    ctxt->inputTab = oldinputTab;\n-    ctxt->charset = oldcharset;\n-    if ((ctxt->encoding != NULL) &&\n-        ((ctxt->dict == NULL) ||\n-         (!xmlDictOwns(ctxt->dict, ctxt->encoding))))\n-        xmlFree((xmlChar *) ctxt->encoding);\n-    ctxt->encoding = oldencoding;\n-    \/* ctxt->wellFormed = oldwellFormed; *\/\n+        \/*\n+         * Restore the parsing context of the main entity\n+         *\/\n+        ctxt->input = oldinput;\n+        ctxt->inputNr = oldinputNr;\n+        ctxt->inputMax = oldinputMax;\n+        ctxt->inputTab = oldinputTab;\n+        ctxt->charset = oldcharset;\n+        if ((ctxt->encoding != NULL) &&\n+            ((ctxt->dict == NULL) ||\n+             (!xmlDictOwns(ctxt->dict, ctxt->encoding))))\n+            xmlFree((xmlChar *) ctxt->encoding);\n+        ctxt->encoding = oldencoding;\n+        \/* ctxt->wellFormed = oldwellFormed; *\/\n@@ -528,1 +528,1 @@\n-    base = ctxt->input->filename;\n+        base = ctxt->input->filename;\n@@ -530,1 +530,1 @@\n-    base = ctxt->directory;\n+        base = ctxt->directory;\n@@ -536,1 +536,1 @@\n-        \"SAX.xmlSAX2ResolveEntity(%s, %s)\\n\", publicId, systemId);\n+            \"SAX.xmlSAX2ResolveEntity(%s, %s)\\n\", publicId, systemId);\n@@ -540,1 +540,1 @@\n-                (const char *) publicId, ctxt);\n+                                (const char *) publicId, ctxt);\n@@ -542,1 +542,1 @@\n-    xmlFree(URI);\n+        xmlFree(URI);\n@@ -564,1 +564,1 @@\n-        \"SAX.xmlSAX2GetEntity(%s)\\n\", name);\n+            \"SAX.xmlSAX2GetEntity(%s)\\n\", name);\n@@ -568,3 +568,3 @@\n-    ret = xmlGetPredefinedEntity(name);\n-    if (ret != NULL)\n-        return(ret);\n+        ret = xmlGetPredefinedEntity(name);\n+        if (ret != NULL)\n+            return(ret);\n@@ -573,15 +573,16 @@\n-    if (ctxt->inSubset == 2) {\n-        ctxt->myDoc->standalone = 0;\n-        ret = xmlGetDocEntity(ctxt->myDoc, name);\n-        ctxt->myDoc->standalone = 1;\n-    } else {\n-        ret = xmlGetDocEntity(ctxt->myDoc, name);\n-        if (ret == NULL) {\n-        ctxt->myDoc->standalone = 0;\n-        ret = xmlGetDocEntity(ctxt->myDoc, name);\n-        if (ret != NULL) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_NOT_STANDALONE,\n-     \"Entity(%s) document marked standalone but requires external subset\\n\",\n-                   name, NULL);\n-        }\n-        ctxt->myDoc->standalone = 1;\n+        if (ctxt->inSubset == 2) {\n+            ctxt->myDoc->standalone = 0;\n+            ret = xmlGetDocEntity(ctxt->myDoc, name);\n+            ctxt->myDoc->standalone = 1;\n+        } else {\n+            ret = xmlGetDocEntity(ctxt->myDoc, name);\n+            if (ret == NULL) {\n+                ctxt->myDoc->standalone = 0;\n+                ret = xmlGetDocEntity(ctxt->myDoc, name);\n+                if (ret != NULL) {\n+                    xmlFatalErrMsg(ctxt, XML_ERR_NOT_STANDALONE,\n+         \"Entity(%s) document marked standalone but requires external subset\\n\",\n+                                   name, NULL);\n+                }\n+                ctxt->myDoc->standalone = 1;\n+            }\n@@ -589,1 +590,0 @@\n-    }\n@@ -591,1 +591,1 @@\n-    ret = xmlGetDocEntity(ctxt->myDoc, name);\n+        ret = xmlGetDocEntity(ctxt->myDoc, name);\n@@ -614,1 +614,1 @@\n-        \"SAX.xmlSAX2GetParameterEntity(%s)\\n\", name);\n+            \"SAX.xmlSAX2GetParameterEntity(%s)\\n\", name);\n@@ -643,1 +643,1 @@\n-        \"SAX.xmlSAX2EntityDecl(%s, %d, %s, %s, %s)\\n\",\n+            \"SAX.xmlSAX2EntityDecl(%s, %d, %s, %s, %s)\\n\",\n@@ -647,18 +647,18 @@\n-    ent = xmlAddDocEntity(ctxt->myDoc, name, type, publicId,\n-                      systemId, content);\n-    if ((ent == NULL) && (ctxt->pedantic))\n-        xmlWarnMsg(ctxt, XML_WAR_ENTITY_REDEFINED,\n-         \"Entity(%s) already defined in the internal subset\\n\",\n-                   name);\n-    if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {\n-        xmlChar *URI;\n-        const char *base = NULL;\n-\n-        if (ctxt->input != NULL)\n-        base = ctxt->input->filename;\n-        if (base == NULL)\n-        base = ctxt->directory;\n-\n-        URI = xmlBuildURI(systemId, (const xmlChar *) base);\n-        ent->URI = URI;\n-    }\n+        ent = xmlAddDocEntity(ctxt->myDoc, name, type, publicId,\n+                              systemId, content);\n+        if ((ent == NULL) && (ctxt->pedantic))\n+            xmlWarnMsg(ctxt, XML_WAR_ENTITY_REDEFINED,\n+             \"Entity(%s) already defined in the internal subset\\n\",\n+                       name);\n+        if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {\n+            xmlChar *URI;\n+            const char *base = NULL;\n+\n+            if (ctxt->input != NULL)\n+                base = ctxt->input->filename;\n+            if (base == NULL)\n+                base = ctxt->directory;\n+\n+            URI = xmlBuildURI(systemId, (const xmlChar *) base);\n+            ent->URI = URI;\n+        }\n@@ -666,18 +666,18 @@\n-    ent = xmlAddDtdEntity(ctxt->myDoc, name, type, publicId,\n-                      systemId, content);\n-    if ((ent == NULL) && (ctxt->pedantic) &&\n-        (ctxt->sax != NULL) && (ctxt->sax->warning != NULL))\n-        ctxt->sax->warning(ctxt->userData,\n-         \"Entity(%s) already defined in the external subset\\n\", name);\n-    if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {\n-        xmlChar *URI;\n-        const char *base = NULL;\n-\n-        if (ctxt->input != NULL)\n-        base = ctxt->input->filename;\n-        if (base == NULL)\n-        base = ctxt->directory;\n-\n-        URI = xmlBuildURI(systemId, (const xmlChar *) base);\n-        ent->URI = URI;\n-    }\n+        ent = xmlAddDtdEntity(ctxt->myDoc, name, type, publicId,\n+                              systemId, content);\n+        if ((ent == NULL) && (ctxt->pedantic) &&\n+            (ctxt->sax != NULL) && (ctxt->sax->warning != NULL))\n+            ctxt->sax->warning(ctxt->userData,\n+             \"Entity(%s) already defined in the external subset\\n\", name);\n+        if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {\n+            xmlChar *URI;\n+            const char *base = NULL;\n+\n+            if (ctxt->input != NULL)\n+                base = ctxt->input->filename;\n+            if (base == NULL)\n+                base = ctxt->directory;\n+\n+            URI = xmlBuildURI(systemId, (const xmlChar *) base);\n+            ent->URI = URI;\n+        }\n@@ -685,3 +685,3 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_PROCESSING,\n-                   \"SAX.xmlSAX2EntityDecl(%s) called while not in subset\\n\",\n-               name, NULL);\n+        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_PROCESSING,\n+                       \"SAX.xmlSAX2EntityDecl(%s) called while not in subset\\n\",\n+                       name, NULL);\n@@ -706,1 +706,1 @@\n-          xmlEnumerationPtr tree)\n+              xmlEnumerationPtr tree)\n@@ -717,1 +717,1 @@\n-        \"SAX.xmlSAX2AttributeDecl(%s, %s, %d, %d, %s, ...)\\n\",\n+            \"SAX.xmlSAX2AttributeDecl(%s, %s, %d, %d, %s, ...)\\n\",\n@@ -722,7 +722,7 @@\n-    \/*\n-     * Raise the error but keep the validity flag\n-     *\/\n-    int tmp = ctxt->valid;\n-    xmlErrValid(ctxt, XML_DTD_XMLID_TYPE,\n-          \"xml:id : attribute type should be ID\\n\", NULL, NULL);\n-    ctxt->valid = tmp;\n+        \/*\n+         * Raise the error but keep the validity flag\n+         *\/\n+        int tmp = ctxt->valid;\n+        xmlErrValid(ctxt, XML_DTD_XMLID_TYPE,\n+              \"xml:id : attribute type should be ID\\n\", NULL, NULL);\n+        ctxt->valid = tmp;\n@@ -734,1 +734,5 @@\n-    attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->intSubset, elem,\n+        attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->intSubset, elem,\n+               name, prefix, (xmlAttributeType) type,\n+               (xmlAttributeDefault) def, defaultValue, tree);\n+    else if (ctxt->inSubset == 2)\n+        attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->extSubset, elem,\n@@ -737,4 +741,0 @@\n-    else if (ctxt->inSubset == 2)\n-    attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->extSubset, elem,\n-       name, prefix, (xmlAttributeType) type,\n-       (xmlAttributeDefault) def, defaultValue, tree);\n@@ -743,4 +743,5 @@\n-         \"SAX.xmlSAX2AttributeDecl(%s) called while not in subset\\n\",\n-                   name, NULL);\n-    xmlFreeEnumeration(tree);\n-    return;\n+             \"SAX.xmlSAX2AttributeDecl(%s) called while not in subset\\n\",\n+                       name, NULL);\n+        xmlFree(name);\n+        xmlFreeEnumeration(tree);\n+        return;\n@@ -750,1 +751,1 @@\n-    ctxt->valid = 0;\n+        ctxt->valid = 0;\n@@ -753,2 +754,2 @@\n-    ctxt->valid &= xmlValidateAttributeDecl(&ctxt->vctxt, ctxt->myDoc,\n-                                            attr);\n+        ctxt->valid &= xmlValidateAttributeDecl(&ctxt->vctxt, ctxt->myDoc,\n+                                                attr);\n@@ -757,1 +758,1 @@\n-    xmlFree(prefix);\n+        xmlFree(prefix);\n@@ -759,1 +760,1 @@\n-    xmlFree(name);\n+        xmlFree(name);\n@@ -794,2 +795,2 @@\n-         \"SAX.xmlSAX2ElementDecl(%s) called while not in subset\\n\",\n-                   name, NULL);\n+             \"SAX.xmlSAX2ElementDecl(%s) called while not in subset\\n\",\n+                       name, NULL);\n@@ -819,1 +820,1 @@\n-         const xmlChar *publicId, const xmlChar *systemId)\n+             const xmlChar *publicId, const xmlChar *systemId)\n@@ -829,1 +830,1 @@\n-        \"SAX.xmlSAX2NotationDecl(%s, %s, %s)\\n\", name, publicId, systemId);\n+            \"SAX.xmlSAX2NotationDecl(%s, %s, %s)\\n\", name, publicId, systemId);\n@@ -833,4 +834,4 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NOTATION_PROCESSING,\n-         \"SAX.xmlSAX2NotationDecl(%s) externalID or PublicID missing\\n\",\n-                   name, NULL);\n-    return;\n+        xmlFatalErrMsg(ctxt, XML_ERR_NOTATION_PROCESSING,\n+             \"SAX.xmlSAX2NotationDecl(%s) externalID or PublicID missing\\n\",\n+                       name, NULL);\n+        return;\n@@ -838,1 +839,1 @@\n-    nota = xmlAddNotationDecl(&ctxt->vctxt, ctxt->myDoc->intSubset, name,\n+        nota = xmlAddNotationDecl(&ctxt->vctxt, ctxt->myDoc->intSubset, name,\n@@ -841,1 +842,1 @@\n-    nota = xmlAddNotationDecl(&ctxt->vctxt, ctxt->myDoc->extSubset, name,\n+        nota = xmlAddNotationDecl(&ctxt->vctxt, ctxt->myDoc->extSubset, name,\n@@ -844,4 +845,4 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NOTATION_PROCESSING,\n-         \"SAX.xmlSAX2NotationDecl(%s) called while not in subset\\n\",\n-                   name, NULL);\n-    return;\n+        xmlFatalErrMsg(ctxt, XML_ERR_NOTATION_PROCESSING,\n+             \"SAX.xmlSAX2NotationDecl(%s) called while not in subset\\n\",\n+                       name, NULL);\n+        return;\n@@ -853,2 +854,2 @@\n-    ctxt->valid &= xmlValidateNotationDecl(&ctxt->vctxt, ctxt->myDoc,\n-                                           nota);\n+        ctxt->valid &= xmlValidateNotationDecl(&ctxt->vctxt, ctxt->myDoc,\n+                                               nota);\n@@ -870,2 +871,2 @@\n-           const xmlChar *publicId, const xmlChar *systemId,\n-           const xmlChar *notationName)\n+                   const xmlChar *publicId, const xmlChar *systemId,\n+                   const xmlChar *notationName)\n@@ -878,1 +879,1 @@\n-        \"SAX.xmlSAX2UnparsedEntityDecl(%s, %s, %s, %s)\\n\",\n+            \"SAX.xmlSAX2UnparsedEntityDecl(%s, %s, %s, %s)\\n\",\n@@ -882,19 +883,19 @@\n-    ent = xmlAddDocEntity(ctxt->myDoc, name,\n-            XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,\n-            publicId, systemId, notationName);\n-    if ((ent == NULL) && (ctxt->pedantic) &&\n-        (ctxt->sax != NULL) && (ctxt->sax->warning != NULL))\n-        ctxt->sax->warning(ctxt->userData,\n-         \"Entity(%s) already defined in the internal subset\\n\", name);\n-    if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {\n-        xmlChar *URI;\n-        const char *base = NULL;\n-\n-        if (ctxt->input != NULL)\n-        base = ctxt->input->filename;\n-        if (base == NULL)\n-        base = ctxt->directory;\n-\n-        URI = xmlBuildURI(systemId, (const xmlChar *) base);\n-        ent->URI = URI;\n-    }\n+        ent = xmlAddDocEntity(ctxt->myDoc, name,\n+                        XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,\n+                        publicId, systemId, notationName);\n+        if ((ent == NULL) && (ctxt->pedantic) &&\n+            (ctxt->sax != NULL) && (ctxt->sax->warning != NULL))\n+            ctxt->sax->warning(ctxt->userData,\n+             \"Entity(%s) already defined in the internal subset\\n\", name);\n+        if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {\n+            xmlChar *URI;\n+            const char *base = NULL;\n+\n+            if (ctxt->input != NULL)\n+                base = ctxt->input->filename;\n+            if (base == NULL)\n+                base = ctxt->directory;\n+\n+            URI = xmlBuildURI(systemId, (const xmlChar *) base);\n+            ent->URI = URI;\n+        }\n@@ -902,19 +903,19 @@\n-    ent = xmlAddDtdEntity(ctxt->myDoc, name,\n-            XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,\n-            publicId, systemId, notationName);\n-    if ((ent == NULL) && (ctxt->pedantic) &&\n-        (ctxt->sax != NULL) && (ctxt->sax->warning != NULL))\n-        ctxt->sax->warning(ctxt->userData,\n-         \"Entity(%s) already defined in the external subset\\n\", name);\n-    if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {\n-        xmlChar *URI;\n-        const char *base = NULL;\n-\n-        if (ctxt->input != NULL)\n-        base = ctxt->input->filename;\n-        if (base == NULL)\n-        base = ctxt->directory;\n-\n-        URI = xmlBuildURI(systemId, (const xmlChar *) base);\n-        ent->URI = URI;\n-    }\n+        ent = xmlAddDtdEntity(ctxt->myDoc, name,\n+                        XML_EXTERNAL_GENERAL_UNPARSED_ENTITY,\n+                        publicId, systemId, notationName);\n+        if ((ent == NULL) && (ctxt->pedantic) &&\n+            (ctxt->sax != NULL) && (ctxt->sax->warning != NULL))\n+            ctxt->sax->warning(ctxt->userData,\n+             \"Entity(%s) already defined in the external subset\\n\", name);\n+        if ((ent != NULL) && (ent->URI == NULL) && (systemId != NULL)) {\n+            xmlChar *URI;\n+            const char *base = NULL;\n+\n+            if (ctxt->input != NULL)\n+                base = ctxt->input->filename;\n+            if (base == NULL)\n+                base = ctxt->directory;\n+\n+            URI = xmlBuildURI(systemId, (const xmlChar *) base);\n+            ent->URI = URI;\n+        }\n@@ -923,2 +924,2 @@\n-         \"SAX.xmlSAX2UnparsedEntityDecl(%s) called while not in subset\\n\",\n-                   name, NULL);\n+             \"SAX.xmlSAX2UnparsedEntityDecl(%s) called while not in subset\\n\",\n+                       name, NULL);\n@@ -942,1 +943,1 @@\n-        \"SAX.xmlSAX2SetDocumentLocator()\\n\");\n+            \"SAX.xmlSAX2SetDocumentLocator()\\n\");\n@@ -962,1 +963,1 @@\n-        \"SAX.xmlSAX2StartDocument()\\n\");\n+            \"SAX.xmlSAX2StartDocument()\\n\");\n@@ -966,8 +967,8 @@\n-    if (ctxt->myDoc == NULL)\n-        ctxt->myDoc = htmlNewDocNoDtD(NULL, NULL);\n-    if (ctxt->myDoc == NULL) {\n-        xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartDocument\");\n-        return;\n-    }\n-    ctxt->myDoc->properties = XML_DOC_HTML;\n-    ctxt->myDoc->parseFlags = ctxt->options;\n+        if (ctxt->myDoc == NULL)\n+            ctxt->myDoc = htmlNewDocNoDtD(NULL, NULL);\n+        if (ctxt->myDoc == NULL) {\n+            xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartDocument\");\n+            return;\n+        }\n+        ctxt->myDoc->properties = XML_DOC_HTML;\n+        ctxt->myDoc->parseFlags = ctxt->options;\n@@ -976,5 +977,5 @@\n-        \"libxml2 built without HTML support\\n\");\n-    ctxt->errNo = XML_ERR_INTERNAL_ERROR;\n-    ctxt->instate = XML_PARSER_EOF;\n-    ctxt->disableSAX = 1;\n-    return;\n+                \"libxml2 built without HTML support\\n\");\n+        ctxt->errNo = XML_ERR_INTERNAL_ERROR;\n+        ctxt->instate = XML_PARSER_EOF;\n+        ctxt->disableSAX = 1;\n+        return;\n@@ -983,19 +984,19 @@\n-    doc = ctxt->myDoc = xmlNewDoc(ctxt->version);\n-    if (doc != NULL) {\n-        doc->properties = 0;\n-        if (ctxt->options & XML_PARSE_OLD10)\n-            doc->properties |= XML_DOC_OLD10;\n-        doc->parseFlags = ctxt->options;\n-        if (ctxt->encoding != NULL)\n-        doc->encoding = xmlStrdup(ctxt->encoding);\n-        else\n-        doc->encoding = NULL;\n-        doc->standalone = ctxt->standalone;\n-    } else {\n-        xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartDocument\");\n-        return;\n-    }\n-    if ((ctxt->dictNames) && (doc != NULL)) {\n-        doc->dict = ctxt->dict;\n-        xmlDictReference(doc->dict);\n-    }\n+        doc = ctxt->myDoc = xmlNewDoc(ctxt->version);\n+        if (doc != NULL) {\n+            doc->properties = 0;\n+            if (ctxt->options & XML_PARSE_OLD10)\n+                doc->properties |= XML_DOC_OLD10;\n+            doc->parseFlags = ctxt->options;\n+            if (ctxt->encoding != NULL)\n+                doc->encoding = xmlStrdup(ctxt->encoding);\n+            else\n+                doc->encoding = NULL;\n+            doc->standalone = ctxt->standalone;\n+        } else {\n+            xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartDocument\");\n+            return;\n+        }\n+        if ((ctxt->dictNames) && (doc != NULL)) {\n+            doc->dict = ctxt->dict;\n+            xmlDictReference(doc->dict);\n+        }\n@@ -1004,4 +1005,4 @@\n-    (ctxt->input != NULL) && (ctxt->input->filename != NULL)) {\n-    ctxt->myDoc->URL = xmlPathToURI((const xmlChar *)ctxt->input->filename);\n-    if (ctxt->myDoc->URL == NULL)\n-        xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartDocument\");\n+        (ctxt->input != NULL) && (ctxt->input->filename != NULL)) {\n+        ctxt->myDoc->URL = xmlPathToURI((const xmlChar *)ctxt->input->filename);\n+        if (ctxt->myDoc->URL == NULL)\n+            xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartDocument\");\n@@ -1023,1 +1024,1 @@\n-        \"SAX.xmlSAX2EndDocument()\\n\");\n+            \"SAX.xmlSAX2EndDocument()\\n\");\n@@ -1029,1 +1030,1 @@\n-    ctxt->valid &= xmlValidateDocumentFinal(&ctxt->vctxt, ctxt->myDoc);\n+        ctxt->valid &= xmlValidateDocumentFinal(&ctxt->vctxt, ctxt->myDoc);\n@@ -1036,3 +1037,3 @@\n-    (ctxt->myDoc->encoding == NULL)) {\n-    ctxt->myDoc->encoding = ctxt->encoding;\n-    ctxt->encoding = NULL;\n+        (ctxt->myDoc->encoding == NULL)) {\n+        ctxt->myDoc->encoding = ctxt->encoding;\n+        ctxt->encoding = NULL;\n@@ -1043,2 +1044,2 @@\n-    (ctxt->myDoc->encoding == NULL)) {\n-    ctxt->myDoc->encoding = xmlStrdup(ctxt->inputTab[0]->encoding);\n+        (ctxt->myDoc->encoding == NULL)) {\n+        ctxt->myDoc->encoding = xmlStrdup(ctxt->inputTab[0]->encoding);\n@@ -1047,2 +1048,2 @@\n-    (ctxt->myDoc->charset == XML_CHAR_ENCODING_NONE)) {\n-    ctxt->myDoc->charset = ctxt->charset;\n+        (ctxt->myDoc->charset == XML_CHAR_ENCODING_NONE)) {\n+        ctxt->myDoc->charset = ctxt->charset;\n@@ -1077,3 +1078,3 @@\n-    name = xmlStrdup(fullname);\n-    ns = NULL;\n-    namespace = NULL;\n+        name = xmlStrdup(fullname);\n+        ns = NULL;\n+        namespace = NULL;\n@@ -1081,13 +1082,19 @@\n-    \/*\n-     * Split the full name into a namespace prefix and the tag name\n-     *\/\n-    name = xmlSplitQName(ctxt, fullname, &ns);\n-    if ((name != NULL) && (name[0] == 0)) {\n-        if (xmlStrEqual(ns, BAD_CAST \"xmlns\")) {\n-        xmlNsErrMsg(ctxt, XML_ERR_NS_DECL_ERROR,\n-                \"invalid namespace declaration '%s'\\n\",\n-                fullname, NULL);\n-        } else {\n-        xmlNsWarnMsg(ctxt, XML_WAR_NS_COLUMN,\n-                 \"Avoid attribute ending with ':' like '%s'\\n\",\n-                 fullname, NULL);\n+        \/*\n+         * Split the full name into a namespace prefix and the tag name\n+         *\/\n+        name = xmlSplitQName(ctxt, fullname, &ns);\n+        if ((name != NULL) && (name[0] == 0)) {\n+            if (xmlStrEqual(ns, BAD_CAST \"xmlns\")) {\n+                xmlNsErrMsg(ctxt, XML_ERR_NS_DECL_ERROR,\n+                            \"invalid namespace declaration '%s'\\n\",\n+                            fullname, NULL);\n+            } else {\n+                xmlNsWarnMsg(ctxt, XML_WAR_NS_COLUMN,\n+                             \"Avoid attribute ending with ':' like '%s'\\n\",\n+                             fullname, NULL);\n+            }\n+            if (ns != NULL)\n+                xmlFree(ns);\n+            ns = NULL;\n+            xmlFree(name);\n+            name = xmlStrdup(fullname);\n@@ -1095,6 +1102,0 @@\n-        if (ns != NULL)\n-        xmlFree(ns);\n-        ns = NULL;\n-        xmlFree(name);\n-        name = xmlStrdup(fullname);\n-    }\n@@ -1104,3 +1105,3 @@\n-    if (ns != NULL)\n-        xmlFree(ns);\n-    return;\n+        if (ns != NULL)\n+            xmlFree(ns);\n+        return;\n@@ -1143,2 +1144,2 @@\n-    xmlNsPtr nsret;\n-    xmlChar *val;\n+        xmlNsPtr nsret;\n+        xmlChar *val;\n@@ -1147,8 +1148,8 @@\n-        ctxt->depth++;\n-        val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,\n-                                  0,0,0);\n-        ctxt->depth--;\n-        if (val == NULL) {\n-            xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartElement\");\n-        if (name != NULL)\n-            xmlFree(name);\n+            ctxt->depth++;\n+            val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,\n+                                          0,0,0);\n+            ctxt->depth--;\n+            if (val == NULL) {\n+                xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartElement\");\n+                if (name != NULL)\n+                    xmlFree(name);\n@@ -1157,1 +1158,4 @@\n-        return;\n+                return;\n+            }\n+        } else {\n+            val = (xmlChar *) value;\n@@ -1159,3 +1163,0 @@\n-    } else {\n-        val = (xmlChar *) value;\n-    }\n@@ -1163,2 +1164,2 @@\n-    if (val[0] != 0) {\n-        xmlURIPtr uri;\n+        if (val[0] != 0) {\n+            xmlURIPtr uri;\n@@ -1166,12 +1167,13 @@\n-        uri = xmlParseURI((const char *)val);\n-        if (uri == NULL) {\n-        if ((ctxt->sax != NULL) && (ctxt->sax->warning != NULL))\n-            ctxt->sax->warning(ctxt->userData,\n-             \"xmlns: %s not a valid URI\\n\", val);\n-        } else {\n-        if (uri->scheme == NULL) {\n-            if ((ctxt->sax != NULL) && (ctxt->sax->warning != NULL))\n-            ctxt->sax->warning(ctxt->userData,\n-                 \"xmlns: URI %s is not absolute\\n\", val);\n-        }\n-        xmlFreeURI(uri);\n+            uri = xmlParseURI((const char *)val);\n+            if (uri == NULL) {\n+                if ((ctxt->sax != NULL) && (ctxt->sax->warning != NULL))\n+                    ctxt->sax->warning(ctxt->userData,\n+                         \"xmlns: %s not a valid URI\\n\", val);\n+            } else {\n+                if (uri->scheme == NULL) {\n+                    if ((ctxt->sax != NULL) && (ctxt->sax->warning != NULL))\n+                        ctxt->sax->warning(ctxt->userData,\n+                             \"xmlns: URI %s is not absolute\\n\", val);\n+                }\n+                xmlFreeURI(uri);\n+            }\n@@ -1179,1 +1181,0 @@\n-    }\n@@ -1181,2 +1182,2 @@\n-    \/* a default namespace definition *\/\n-    nsret = xmlNewNs(ctxt->node, val, NULL);\n+        \/* a default namespace definition *\/\n+        nsret = xmlNewNs(ctxt->node, val, NULL);\n@@ -1185,4 +1186,4 @@\n-    \/*\n-     * Validate also for namespace decls, they are attributes from\n-     * an XML-1.0 perspective\n-     *\/\n+        \/*\n+         * Validate also for namespace decls, they are attributes from\n+         * an XML-1.0 perspective\n+         *\/\n@@ -1190,3 +1191,3 @@\n-        ctxt->myDoc && ctxt->myDoc->intSubset)\n-        ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,\n-                       ctxt->node, prefix, nsret, val);\n+            ctxt->myDoc && ctxt->myDoc->intSubset)\n+            ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,\n+                                           ctxt->node, prefix, nsret, val);\n@@ -1194,7 +1195,7 @@\n-    if (name != NULL)\n-        xmlFree(name);\n-    if (nval != NULL)\n-        xmlFree(nval);\n-    if (val != value)\n-        xmlFree(val);\n-    return;\n+        if (name != NULL)\n+            xmlFree(name);\n+        if (nval != NULL)\n+            xmlFree(nval);\n+        if (val != value)\n+            xmlFree(val);\n+        return;\n@@ -1203,1 +1204,1 @@\n-    (ns != NULL) && (ns[0] == 'x') && (ns[1] == 'm') && (ns[2] == 'l') &&\n+        (ns != NULL) && (ns[0] == 'x') && (ns[1] == 'm') && (ns[2] == 'l') &&\n@@ -1205,2 +1206,2 @@\n-    xmlNsPtr nsret;\n-    xmlChar *val;\n+        xmlNsPtr nsret;\n+        xmlChar *val;\n@@ -1209,9 +1210,9 @@\n-        ctxt->depth++;\n-        val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,\n-                                  0,0,0);\n-        ctxt->depth--;\n-        if (val == NULL) {\n-            xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartElement\");\n-            xmlFree(ns);\n-        if (name != NULL)\n-            xmlFree(name);\n+            ctxt->depth++;\n+            val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,\n+                                          0,0,0);\n+            ctxt->depth--;\n+            if (val == NULL) {\n+                xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartElement\");\n+                xmlFree(ns);\n+                if (name != NULL)\n+                    xmlFree(name);\n@@ -1220,1 +1221,4 @@\n-        return;\n+                return;\n+            }\n+        } else {\n+            val = (xmlChar *) value;\n@@ -1222,3 +1226,0 @@\n-    } else {\n-        val = (xmlChar *) value;\n-    }\n@@ -1226,15 +1227,3 @@\n-    if (val[0] == 0) {\n-        xmlNsErrMsg(ctxt, XML_NS_ERR_EMPTY,\n-                \"Empty namespace name for prefix %s\\n\", name, NULL);\n-    }\n-    if ((ctxt->pedantic != 0) && (val[0] != 0)) {\n-        xmlURIPtr uri;\n-\n-        uri = xmlParseURI((const char *)val);\n-        if (uri == NULL) {\n-            xmlNsWarnMsg(ctxt, XML_WAR_NS_URI,\n-             \"xmlns:%s: %s not a valid URI\\n\", name, value);\n-        } else {\n-        if (uri->scheme == NULL) {\n-            xmlNsWarnMsg(ctxt, XML_WAR_NS_URI_RELATIVE,\n-               \"xmlns:%s: URI %s is not absolute\\n\", name, value);\n+        if (val[0] == 0) {\n+            xmlNsErrMsg(ctxt, XML_NS_ERR_EMPTY,\n+                        \"Empty namespace name for prefix %s\\n\", name, NULL);\n@@ -1242,1 +1231,14 @@\n-        xmlFreeURI(uri);\n+        if ((ctxt->pedantic != 0) && (val[0] != 0)) {\n+            xmlURIPtr uri;\n+\n+            uri = xmlParseURI((const char *)val);\n+            if (uri == NULL) {\n+                xmlNsWarnMsg(ctxt, XML_WAR_NS_URI,\n+                         \"xmlns:%s: %s not a valid URI\\n\", name, value);\n+            } else {\n+                if (uri->scheme == NULL) {\n+                    xmlNsWarnMsg(ctxt, XML_WAR_NS_URI_RELATIVE,\n+                           \"xmlns:%s: URI %s is not absolute\\n\", name, value);\n+                }\n+                xmlFreeURI(uri);\n+            }\n@@ -1244,1 +1246,0 @@\n-    }\n@@ -1246,3 +1247,3 @@\n-    \/* a standard namespace definition *\/\n-    nsret = xmlNewNs(ctxt->node, val, name);\n-    xmlFree(ns);\n+        \/* a standard namespace definition *\/\n+        nsret = xmlNewNs(ctxt->node, val, name);\n+        xmlFree(ns);\n@@ -1250,4 +1251,4 @@\n-    \/*\n-     * Validate also for namespace decls, they are attributes from\n-     * an XML-1.0 perspective\n-     *\/\n+        \/*\n+         * Validate also for namespace decls, they are attributes from\n+         * an XML-1.0 perspective\n+         *\/\n@@ -1255,3 +1256,3 @@\n-        ctxt->myDoc && ctxt->myDoc->intSubset)\n-        ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,\n-                       ctxt->node, prefix, nsret, value);\n+            ctxt->myDoc && ctxt->myDoc->intSubset)\n+            ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,\n+                                           ctxt->node, prefix, nsret, value);\n@@ -1259,7 +1260,7 @@\n-    if (name != NULL)\n-        xmlFree(name);\n-    if (nval != NULL)\n-        xmlFree(nval);\n-    if (val != value)\n-        xmlFree(val);\n-    return;\n+        if (name != NULL)\n+            xmlFree(name);\n+        if (nval != NULL)\n+            xmlFree(nval);\n+        if (val != value)\n+            xmlFree(val);\n+        return;\n@@ -1269,1 +1270,1 @@\n-    namespace = xmlSearchNs(ctxt->myDoc, ctxt->node, ns);\n+        namespace = xmlSearchNs(ctxt->myDoc, ctxt->node, ns);\n@@ -1271,5 +1272,5 @@\n-    if (namespace == NULL) {\n-        xmlNsErrMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,\n-            \"Namespace prefix %s of attribute %s is not defined\\n\",\n-                     ns, name);\n-    } else {\n+        if (namespace == NULL) {\n+            xmlNsErrMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,\n+                    \"Namespace prefix %s of attribute %s is not defined\\n\",\n+                             ns, name);\n+        } else {\n@@ -1298,1 +1299,1 @@\n-    namespace = NULL;\n+        namespace = NULL;\n@@ -1306,9 +1307,15 @@\n-        xmlNodePtr tmp;\n-\n-        ret->children = xmlStringGetNodeList(ctxt->myDoc, value);\n-        tmp = ret->children;\n-        while (tmp != NULL) {\n-        tmp->parent = (xmlNodePtr) ret;\n-        if (tmp->next == NULL)\n-            ret->last = tmp;\n-        tmp = tmp->next;\n+            xmlNodePtr tmp;\n+\n+            ret->children = xmlStringGetNodeList(ctxt->myDoc, value);\n+            tmp = ret->children;\n+            while (tmp != NULL) {\n+                tmp->parent = (xmlNodePtr) ret;\n+                if (tmp->next == NULL)\n+                    ret->last = tmp;\n+                tmp = tmp->next;\n+            }\n+        } else if (value != NULL) {\n+            ret->children = xmlNewDocText(ctxt->myDoc, value);\n+            ret->last = ret->children;\n+            if (ret->children != NULL)\n+                ret->children->parent = (xmlNodePtr) ret;\n@@ -1316,6 +1323,0 @@\n-    } else if (value != NULL) {\n-        ret->children = xmlNewDocText(ctxt->myDoc, value);\n-        ret->last = ret->children;\n-        if (ret->children != NULL)\n-        ret->children->parent = (xmlNodePtr) ret;\n-    }\n@@ -1328,18 +1329,0 @@\n-    \/*\n-     * If we don't substitute entities, the validation should be\n-     * done on a value with replaced entities anyway.\n-     *\/\n-        if (!ctxt->replaceEntities) {\n-        xmlChar *val;\n-\n-        ctxt->depth++;\n-        val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,\n-                                  0,0,0);\n-        ctxt->depth--;\n-\n-        if (val == NULL)\n-        ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n-                ctxt->myDoc, ctxt->node, ret, value);\n-        else {\n-        xmlChar *nvalnorm;\n-\n@@ -1347,3 +1330,2 @@\n-         * Do the last stage of the attribute normalization\n-         * It need to be done twice ... it's an extra burden related\n-         * to the ability to keep xmlSAX2References in attributes\n+         * If we don't substitute entities, the validation should be\n+         * done on a value with replaced entities anyway.\n@@ -1351,6 +1333,25 @@\n-        nvalnorm = xmlValidNormalizeAttributeValue(ctxt->myDoc,\n-                        ctxt->node, fullname, val);\n-        if (nvalnorm != NULL) {\n-            xmlFree(val);\n-            val = nvalnorm;\n-        }\n+        if (!ctxt->replaceEntities) {\n+            xmlChar *val;\n+\n+            ctxt->depth++;\n+            val = xmlStringDecodeEntities(ctxt, value, XML_SUBSTITUTE_REF,\n+                                          0,0,0);\n+            ctxt->depth--;\n+\n+            if (val == NULL)\n+                ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n+                                ctxt->myDoc, ctxt->node, ret, value);\n+            else {\n+                xmlChar *nvalnorm;\n+\n+                \/*\n+                 * Do the last stage of the attribute normalization\n+                 * It need to be done twice ... it's an extra burden related\n+                 * to the ability to keep xmlSAX2References in attributes\n+                 *\/\n+                nvalnorm = xmlValidNormalizeAttributeValue(ctxt->myDoc,\n+                                            ctxt->node, fullname, val);\n+                if (nvalnorm != NULL) {\n+                    xmlFree(val);\n+                    val = nvalnorm;\n+                }\n@@ -1358,2 +1359,2 @@\n-        ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n-                    ctxt->myDoc, ctxt->node, ret, val);\n+                ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n+                                ctxt->myDoc, ctxt->node, ret, val);\n@@ -1361,0 +1362,4 @@\n+            }\n+        } else {\n+            ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt, ctxt->myDoc,\n+                                               ctxt->node, ret, value);\n@@ -1362,4 +1367,0 @@\n-    } else {\n-        ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt, ctxt->myDoc,\n-                           ctxt->node, ret, value);\n-    }\n@@ -1369,7 +1370,2 @@\n-           (((ctxt->replaceEntities == 0) && (ctxt->external != 2)) ||\n-            ((ctxt->replaceEntities != 0) && (ctxt->inSubset == 0)))) {\n-        \/*\n-     * when validating, the ID registration is done at the attribute\n-     * validation level. Otherwise we have to do specific handling here.\n-     *\/\n-    if (xmlStrEqual(fullname, BAD_CAST \"xml:id\")) {\n+               (((ctxt->replaceEntities == 0) && (ctxt->external != 2)) ||\n+                ((ctxt->replaceEntities != 0) && (ctxt->inSubset == 0)))) {\n@@ -1377,3 +1373,2 @@\n-         * Add the xml:id value\n-         *\n-         * Open issue: normalization of the value.\n+         * when validating, the ID registration is done at the attribute\n+         * validation level. Otherwise we have to do specific handling here.\n@@ -1381,10 +1376,16 @@\n-        if (xmlValidateNCName(value, 1) != 0) {\n-            xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,\n-              \"xml:id : attribute value %s is not an NCName\\n\",\n-                (const char *) value, NULL);\n-        }\n-        xmlAddID(&ctxt->vctxt, ctxt->myDoc, value, ret);\n-    } else if (xmlIsID(ctxt->myDoc, ctxt->node, ret))\n-        xmlAddID(&ctxt->vctxt, ctxt->myDoc, value, ret);\n-    else if (xmlIsRef(ctxt->myDoc, ctxt->node, ret))\n-        xmlAddRef(&ctxt->vctxt, ctxt->myDoc, value, ret);\n+        if (xmlStrEqual(fullname, BAD_CAST \"xml:id\")) {\n+            \/*\n+             * Add the xml:id value\n+             *\n+             * Open issue: normalization of the value.\n+             *\/\n+            if (xmlValidateNCName(value, 1) != 0) {\n+                xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,\n+                      \"xml:id : attribute value %s is not an NCName\\n\",\n+                            (const char *) value, NULL);\n+            }\n+            xmlAddID(&ctxt->vctxt, ctxt->myDoc, value, ret);\n+        } else if (xmlIsID(ctxt->myDoc, ctxt->node, ret))\n+            xmlAddID(&ctxt->vctxt, ctxt->myDoc, value, ret);\n+        else if (xmlIsRef(ctxt->myDoc, ctxt->node, ret))\n+            xmlAddRef(&ctxt->vctxt, ctxt->myDoc, value, ret);\n@@ -1395,1 +1396,1 @@\n-    xmlFree(nval);\n+        xmlFree(nval);\n@@ -1397,1 +1398,1 @@\n-    xmlFree(ns);\n+        xmlFree(ns);\n@@ -1407,1 +1408,1 @@\n-    const xmlChar *prefix, const xmlChar **atts) {\n+        const xmlChar *prefix, const xmlChar **atts) {\n@@ -1415,2 +1416,2 @@\n-    elemDecl = xmlGetDtdQElementDesc(ctxt->myDoc->extSubset, name, prefix);\n-    internal = 0;\n+        elemDecl = xmlGetDtdQElementDesc(ctxt->myDoc->extSubset, name, prefix);\n+        internal = 0;\n@@ -1422,25 +1423,25 @@\n-    xmlAttributePtr attr = elemDecl->attributes;\n-    \/*\n-     * Check against defaulted attributes from the external subset\n-     * if the document is stamped as standalone\n-     *\/\n-    if ((ctxt->myDoc->standalone == 1) &&\n-        (ctxt->myDoc->extSubset != NULL) &&\n-        (ctxt->validate)) {\n-        while (attr != NULL) {\n-        if ((attr->defaultValue != NULL) &&\n-            (xmlGetDtdQAttrDesc(ctxt->myDoc->extSubset,\n-                    attr->elem, attr->name,\n-                    attr->prefix) == attr) &&\n-            (xmlGetDtdQAttrDesc(ctxt->myDoc->intSubset,\n-                    attr->elem, attr->name,\n-                    attr->prefix) == NULL)) {\n-            xmlChar *fulln;\n-\n-            if (attr->prefix != NULL) {\n-            fulln = xmlStrdup(attr->prefix);\n-            fulln = xmlStrcat(fulln, BAD_CAST \":\");\n-            fulln = xmlStrcat(fulln, attr->name);\n-            } else {\n-            fulln = xmlStrdup(attr->name);\n-            }\n+        xmlAttributePtr attr = elemDecl->attributes;\n+        \/*\n+         * Check against defaulted attributes from the external subset\n+         * if the document is stamped as standalone\n+         *\/\n+        if ((ctxt->myDoc->standalone == 1) &&\n+            (ctxt->myDoc->extSubset != NULL) &&\n+            (ctxt->validate)) {\n+            while (attr != NULL) {\n+                if ((attr->defaultValue != NULL) &&\n+                    (xmlGetDtdQAttrDesc(ctxt->myDoc->extSubset,\n+                                        attr->elem, attr->name,\n+                                        attr->prefix) == attr) &&\n+                    (xmlGetDtdQAttrDesc(ctxt->myDoc->intSubset,\n+                                        attr->elem, attr->name,\n+                                        attr->prefix) == NULL)) {\n+                    xmlChar *fulln;\n+\n+                    if (attr->prefix != NULL) {\n+                        fulln = xmlStrdup(attr->prefix);\n+                        fulln = xmlStrcat(fulln, BAD_CAST \":\");\n+                        fulln = xmlStrcat(fulln, attr->name);\n+                    } else {\n+                        fulln = xmlStrdup(attr->name);\n+                    }\n@@ -1452,17 +1453,17 @@\n-            \/*\n-             * Check that the attribute is not declared in the\n-             * serialization\n-             *\/\n-            att = NULL;\n-            if (atts != NULL) {\n-            i = 0;\n-            att = atts[i];\n-            while (att != NULL) {\n-                if (xmlStrEqual(att, fulln))\n-                break;\n-                i += 2;\n-                att = atts[i];\n-            }\n-            }\n-            if (att == NULL) {\n-                xmlErrValid(ctxt, XML_DTD_STANDALONE_DEFAULTED,\n+                    \/*\n+                     * Check that the attribute is not declared in the\n+                     * serialization\n+                     *\/\n+                    att = NULL;\n+                    if (atts != NULL) {\n+                        i = 0;\n+                        att = atts[i];\n+                        while (att != NULL) {\n+                            if (xmlStrEqual(att, fulln))\n+                                break;\n+                            i += 2;\n+                            att = atts[i];\n+                        }\n+                    }\n+                    if (att == NULL) {\n+                        xmlErrValid(ctxt, XML_DTD_STANDALONE_DEFAULTED,\n@@ -1470,3 +1471,3 @@\n-                    (const char *)fulln,\n-                    (const char *)attr->elem);\n-            }\n+                                    (const char *)fulln,\n+                                    (const char *)attr->elem);\n+                    }\n@@ -1474,0 +1475,3 @@\n+                }\n+                attr = attr->nexth;\n+            }\n@@ -1475,3 +1479,0 @@\n-        attr = attr->nexth;\n-        }\n-    }\n@@ -1479,5 +1480,0 @@\n-    \/*\n-     * Actually insert defaulted values when needed\n-     *\/\n-    attr = elemDecl->attributes;\n-    while (attr != NULL) {\n@@ -1485,3 +1481,1 @@\n-         * Make sure that attributes redefinition occurring in the\n-         * internal subset are not overridden by definitions in the\n-         * external subset.\n+         * Actually insert defaulted values when needed\n@@ -1489,29 +1483,2 @@\n-        if (attr->defaultValue != NULL) {\n-        \/*\n-         * the element should be instantiated in the tree if:\n-         *  - this is a namespace prefix\n-         *  - the user required for completion in the tree\n-         *    like XSLT\n-         *  - there isn't already an attribute definition\n-         *    in the internal subset overriding it.\n-         *\/\n-        if (((attr->prefix != NULL) &&\n-             (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\"))) ||\n-            ((attr->prefix == NULL) &&\n-             (xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) ||\n-            (ctxt->loadsubset & XML_COMPLETE_ATTRS)) {\n-            xmlAttributePtr tst;\n-\n-            tst = xmlGetDtdQAttrDesc(ctxt->myDoc->intSubset,\n-                         attr->elem, attr->name,\n-                         attr->prefix);\n-            if ((tst == attr) || (tst == NULL)) {\n-                xmlChar fn[50];\n-            xmlChar *fulln;\n-\n-                        fulln = xmlBuildQName(attr->name, attr->prefix, fn, 50);\n-            if (fulln == NULL) {\n-                xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartElement\");\n-                return;\n-            }\n-\n+        attr = elemDecl->attributes;\n+        while (attr != NULL) {\n@@ -1519,2 +1486,3 @@\n-             * Check that the attribute is not declared in the\n-             * serialization\n+             * Make sure that attributes redefinition occurring in the\n+             * internal subset are not overridden by definitions in the\n+             * external subset.\n@@ -1522,9 +1490,51 @@\n-            att = NULL;\n-            if (atts != NULL) {\n-                i = 0;\n-                att = atts[i];\n-                while (att != NULL) {\n-                if (xmlStrEqual(att, fulln))\n-                    break;\n-                i += 2;\n-                att = atts[i];\n+            if (attr->defaultValue != NULL) {\n+                \/*\n+                 * the element should be instantiated in the tree if:\n+                 *  - this is a namespace prefix\n+                 *  - the user required for completion in the tree\n+                 *    like XSLT\n+                 *  - there isn't already an attribute definition\n+                 *    in the internal subset overriding it.\n+                 *\/\n+                if (((attr->prefix != NULL) &&\n+                     (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\"))) ||\n+                    ((attr->prefix == NULL) &&\n+                     (xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) ||\n+                    (ctxt->loadsubset & XML_COMPLETE_ATTRS)) {\n+                    xmlAttributePtr tst;\n+\n+                    tst = xmlGetDtdQAttrDesc(ctxt->myDoc->intSubset,\n+                                             attr->elem, attr->name,\n+                                             attr->prefix);\n+                    if ((tst == attr) || (tst == NULL)) {\n+                        xmlChar fn[50];\n+                        xmlChar *fulln;\n+\n+                        fulln = xmlBuildQName(attr->name, attr->prefix, fn, 50);\n+                        if (fulln == NULL) {\n+                            xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartElement\");\n+                            return;\n+                        }\n+\n+                        \/*\n+                         * Check that the attribute is not declared in the\n+                         * serialization\n+                         *\/\n+                        att = NULL;\n+                        if (atts != NULL) {\n+                            i = 0;\n+                            att = atts[i];\n+                            while (att != NULL) {\n+                                if (xmlStrEqual(att, fulln))\n+                                    break;\n+                                i += 2;\n+                                att = atts[i];\n+                            }\n+                        }\n+                        if (att == NULL) {\n+                            xmlSAX2AttributeInternal(ctxt, fulln,\n+                                                 attr->defaultValue, prefix);\n+                        }\n+                        if ((fulln != fn) && (fulln != attr->name))\n+                            xmlFree(fulln);\n+                    }\n@@ -1533,7 +1543,1 @@\n-            if (att == NULL) {\n-                xmlSAX2AttributeInternal(ctxt, fulln,\n-                         attr->defaultValue, prefix);\n-            }\n-            if ((fulln != fn) && (fulln != attr->name))\n-                xmlFree(fulln);\n-            }\n+            attr = attr->nexth;\n@@ -1541,0 +1545,5 @@\n+        if (internal == 1) {\n+            elemDecl = xmlGetDtdQElementDesc(ctxt->myDoc->extSubset,\n+                                             name, prefix);\n+            internal = 0;\n+            goto process_external_subset;\n@@ -1542,8 +1551,0 @@\n-        attr = attr->nexth;\n-    }\n-    if (internal == 1) {\n-        elemDecl = xmlGetDtdQElementDesc(ctxt->myDoc->extSubset,\n-                                     name, prefix);\n-        internal = 0;\n-        goto process_external_subset;\n-    }\n@@ -1578,1 +1579,1 @@\n-        \"SAX.xmlSAX2StartElement(%s)\\n\", fullname);\n+            \"SAX.xmlSAX2StartElement(%s)\\n\", fullname);\n@@ -1586,7 +1587,7 @@\n-     ((ctxt->myDoc->intSubset->notations == NULL) &&\n-      (ctxt->myDoc->intSubset->elements == NULL) &&\n-      (ctxt->myDoc->intSubset->attributes == NULL) &&\n-      (ctxt->myDoc->intSubset->entities == NULL)))) {\n-    xmlErrValid(ctxt, XML_ERR_NO_DTD,\n-      \"Validation failed: no DTD found !\", NULL, NULL);\n-    ctxt->validate = 0;\n+         ((ctxt->myDoc->intSubset->notations == NULL) &&\n+          (ctxt->myDoc->intSubset->elements == NULL) &&\n+          (ctxt->myDoc->intSubset->attributes == NULL) &&\n+          (ctxt->myDoc->intSubset->entities == NULL)))) {\n+        xmlErrValid(ctxt, XML_ERR_NO_DTD,\n+          \"Validation failed: no DTD found !\", NULL, NULL);\n+        ctxt->validate = 0;\n@@ -1610,2 +1611,2 @@\n-        xmlFree(prefix);\n-    xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartElement\");\n+            xmlFree(prefix);\n+        xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartElement\");\n@@ -1616,1 +1617,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"Setting %s as root\\n\", name);\n+        xmlGenericError(xmlGenericErrorContext, \"Setting %s as root\\n\", name);\n@@ -1624,6 +1625,6 @@\n-    if (ctxt->input != NULL) {\n-        if (ctxt->input->line < 65535)\n-        ret->line = (short) ctxt->input->line;\n-        else\n-            ret->line = 65535;\n-    }\n+        if (ctxt->input != NULL) {\n+            if (ctxt->input->line < USHRT_MAX)\n+                ret->line = (unsigned short) ctxt->input->line;\n+            else\n+                ret->line = USHRT_MAX;\n+        }\n@@ -1652,2 +1653,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"adding child %s to %s\\n\", name, parent->name);\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"adding child %s to %s\\n\", name, parent->name);\n@@ -1655,2 +1656,2 @@\n-        xmlAddChild(parent, ret);\n-    } else {\n+            xmlAddChild(parent, ret);\n+        } else {\n@@ -1658,3 +1659,3 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"adding sibling %s to \", name);\n-        xmlDebugDumpOneNode(stderr, parent, 0);\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"adding sibling %s to \", name);\n+            xmlDebugDumpOneNode(stderr, parent, 0);\n@@ -1662,2 +1663,2 @@\n-        xmlAddSibling(parent, ret);\n-    }\n+            xmlAddSibling(parent, ret);\n+        }\n@@ -1683,4 +1684,4 @@\n-        while ((att != NULL) && (value != NULL)) {\n-        if ((att[0] == 'x') && (att[1] == 'm') && (att[2] == 'l') &&\n-            (att[3] == 'n') && (att[4] == 's'))\n-            xmlSAX2AttributeInternal(ctxt, att, value, prefix);\n+            while ((att != NULL) && (value != NULL)) {\n+                if ((att[0] == 'x') && (att[1] == 'm') && (att[2] == 'l') &&\n+                    (att[3] == 'n') && (att[4] == 's'))\n+                    xmlSAX2AttributeInternal(ctxt, att, value, prefix);\n@@ -1688,3 +1689,3 @@\n-        att = atts[i++];\n-        value = atts[i++];\n-        }\n+                att = atts[i++];\n+                value = atts[i++];\n+            }\n@@ -1721,17 +1722,0 @@\n-    att = atts[i++];\n-    value = atts[i++];\n-    if (ctxt->html) {\n-        while (att != NULL) {\n-        xmlSAX2AttributeInternal(ctxt, att, value, NULL);\n-        att = atts[i++];\n-        value = atts[i++];\n-        }\n-    } else {\n-        while ((att != NULL) && (value != NULL)) {\n-        if ((att[0] != 'x') || (att[1] != 'm') || (att[2] != 'l') ||\n-            (att[3] != 'n') || (att[4] != 's'))\n-            xmlSAX2AttributeInternal(ctxt, att, value, NULL);\n-\n-        \/*\n-         * Next ones\n-         *\/\n@@ -1740,0 +1724,18 @@\n+        if (ctxt->html) {\n+            while (att != NULL) {\n+                xmlSAX2AttributeInternal(ctxt, att, value, NULL);\n+                att = atts[i++];\n+                value = atts[i++];\n+            }\n+        } else {\n+            while ((att != NULL) && (value != NULL)) {\n+                if ((att[0] != 'x') || (att[1] != 'm') || (att[2] != 'l') ||\n+                    (att[3] != 'n') || (att[4] != 's'))\n+                    xmlSAX2AttributeInternal(ctxt, att, value, NULL);\n+\n+                \/*\n+                 * Next ones\n+                 *\/\n+                att = atts[i++];\n+                value = atts[i++];\n+            }\n@@ -1742,1 +1744,0 @@\n-    }\n@@ -1750,1 +1751,1 @@\n-    int chk;\n+        int chk;\n@@ -1752,7 +1753,7 @@\n-    chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc);\n-    if (chk <= 0)\n-        ctxt->valid = 0;\n-    if (chk < 0)\n-        ctxt->wellFormed = 0;\n-    ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n-    ctxt->vctxt.finishDtd = XML_CTXT_FINISH_DTD_1;\n+        chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc);\n+        if (chk <= 0)\n+            ctxt->valid = 0;\n+        if (chk < 0)\n+            ctxt->wellFormed = 0;\n+        ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n+        ctxt->vctxt.finishDtd = XML_CTXT_FINISH_DTD_1;\n@@ -1763,1 +1764,1 @@\n-    xmlFree(prefix);\n+        xmlFree(prefix);\n@@ -1786,1 +1787,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"SAX.xmlSAX2EndElement(%s)\\n\", name);\n+        xmlGenericError(xmlGenericErrorContext, \"SAX.xmlSAX2EndElement(%s)\\n\", name);\n@@ -1802,1 +1803,1 @@\n-                         cur);\n+                                             cur);\n@@ -1835,3 +1836,3 @@\n-    ret = ctxt->freeElems;\n-    ctxt->freeElems = ret->next;\n-    ctxt->freeElemsNr--;\n+        ret = ctxt->freeElems;\n+        ctxt->freeElems = ret->next;\n+        ctxt->freeElemsNr--;\n@@ -1839,1 +1840,1 @@\n-    ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n+        ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n@@ -1843,1 +1844,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1853,16 +1854,18 @@\n-    if ((len < (int) (2 * sizeof(void *))) &&\n-        (ctxt->options & XML_PARSE_COMPACT)) {\n-        \/* store the string in the node overriding properties and nsDef *\/\n-        xmlChar *tmp = (xmlChar *) &(ret->properties);\n-        memcpy(tmp, str, len);\n-        tmp[len] = 0;\n-        intern = tmp;\n-    } else if ((len <= 3) && ((cur == '\"') || (cur == '\\'') ||\n-        ((cur == '<') && (str[len + 1] != '!')))) {\n-        intern = xmlDictLookup(ctxt->dict, str, len);\n-    } else if (IS_BLANK_CH(*str) && (len < 60) && (cur == '<') &&\n-               (str[len + 1] != '!')) {\n-        int i;\n-\n-        for (i = 1;i < len;i++) {\n-        if (!IS_BLANK_CH(str[i])) goto skip;\n+        if ((len < (int) (2 * sizeof(void *))) &&\n+            (ctxt->options & XML_PARSE_COMPACT)) {\n+            \/* store the string in the node overriding properties and nsDef *\/\n+            xmlChar *tmp = (xmlChar *) &(ret->properties);\n+            memcpy(tmp, str, len);\n+            tmp[len] = 0;\n+            intern = tmp;\n+        } else if ((len <= 3) && ((cur == '\"') || (cur == '\\'') ||\n+            ((cur == '<') && (str[len + 1] != '!')))) {\n+            intern = xmlDictLookup(ctxt->dict, str, len);\n+        } else if (IS_BLANK_CH(*str) && (len < 60) && (cur == '<') &&\n+                   (str[len + 1] != '!')) {\n+            int i;\n+\n+            for (i = 1;i < len;i++) {\n+                if (!IS_BLANK_CH(str[i])) goto skip;\n+            }\n+            intern = xmlDictLookup(ctxt->dict, str, len);\n@@ -1870,2 +1873,0 @@\n-        intern = xmlDictLookup(ctxt->dict, str, len);\n-    }\n@@ -1878,6 +1879,6 @@\n-    ret->content = xmlStrndup(str, len);\n-    if (ret->content == NULL) {\n-        xmlSAX2ErrMemory(ctxt, \"xmlSAX2TextNode\");\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n+        ret->content = xmlStrndup(str, len);\n+        if (ret->content == NULL) {\n+            xmlSAX2ErrMemory(ctxt, \"xmlSAX2TextNode\");\n+            xmlFree(ret);\n+            return(NULL);\n+        }\n@@ -1885,1 +1886,1 @@\n-    ret->content = (xmlChar *) intern;\n+        ret->content = (xmlChar *) intern;\n@@ -1888,7 +1889,8 @@\n-    if (ctxt->input != NULL) {\n-        if (ctxt->input->line < 65535)\n-        ret->line = (short) ctxt->input->line;\n-        else {\n-            ret->line = 65535;\n-        if (ctxt->options & XML_PARSE_BIG_LINES)\n-            ret->psvi = (void *) (ptrdiff_t) ctxt->input->line;\n+        if (ctxt->input != NULL) {\n+            if (ctxt->input->line < USHRT_MAX)\n+                ret->line = (unsigned short) ctxt->input->line;\n+            else {\n+                ret->line = USHRT_MAX;\n+                if (ctxt->options & XML_PARSE_BIG_LINES)\n+                    ret->psvi = (void *) (ptrdiff_t) ctxt->input->line;\n+            }\n@@ -1897,1 +1899,0 @@\n-    }\n@@ -1900,1 +1901,1 @@\n-    xmlRegisterNodeDefaultValue(ret);\n+        xmlRegisterNodeDefaultValue(ret);\n@@ -1924,1 +1925,1 @@\n-        goto decode;\n+            goto decode;\n@@ -1929,1 +1930,1 @@\n-                     XML_SUBSTITUTE_REF, 0,0,0);\n+                                     XML_SUBSTITUTE_REF, 0,0,0);\n@@ -1953,2 +1954,2 @@\n-           const xmlChar * value,\n-           const xmlChar * valueend)\n+                   const xmlChar * value,\n+                   const xmlChar * valueend)\n@@ -1964,1 +1965,1 @@\n-    namespace = xmlSearchNs(ctxt->myDoc, ctxt->node, prefix);\n+        namespace = xmlSearchNs(ctxt->myDoc, ctxt->node, prefix);\n@@ -1971,4 +1972,4 @@\n-    ctxt->freeAttrs = ret->next;\n-    ctxt->freeAttrsNr--;\n-    memset(ret, 0, sizeof(xmlAttr));\n-    ret->type = XML_ATTRIBUTE_NODE;\n+        ctxt->freeAttrs = ret->next;\n+        ctxt->freeAttrsNr--;\n+        memset(ret, 0, sizeof(xmlAttr));\n+        ret->type = XML_ATTRIBUTE_NODE;\n@@ -1976,3 +1977,3 @@\n-    ret->parent = ctxt->node;\n-    ret->doc = ctxt->myDoc;\n-    ret->ns = namespace;\n+        ret->parent = ctxt->node;\n+        ret->doc = ctxt->myDoc;\n+        ret->ns = namespace;\n@@ -1980,4 +1981,4 @@\n-    if (ctxt->dictNames)\n-        ret->name = localname;\n-    else\n-        ret->name = xmlStrdup(localname);\n+        if (ctxt->dictNames)\n+            ret->name = localname;\n+        else\n+            ret->name = xmlStrdup(localname);\n@@ -1986,4 +1987,4 @@\n-    if (ctxt->node->properties == NULL) {\n-        ctxt->node->properties = ret;\n-    } else {\n-        xmlAttrPtr prev = ctxt->node->properties;\n+        if (ctxt->node->properties == NULL) {\n+            ctxt->node->properties = ret;\n+        } else {\n+            xmlAttrPtr prev = ctxt->node->properties;\n@@ -1991,4 +1992,4 @@\n-        while (prev->next != NULL) prev = prev->next;\n-        prev->next = ret;\n-        ret->prev = prev;\n-    }\n+            while (prev->next != NULL) prev = prev->next;\n+            prev->next = ret;\n+            ret->prev = prev;\n+        }\n@@ -1996,2 +1997,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-        xmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n+        if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+            xmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n@@ -1999,9 +2000,9 @@\n-    if (ctxt->dictNames)\n-        ret = xmlNewNsPropEatName(ctxt->node, namespace,\n-                                  (xmlChar *) localname, NULL);\n-    else\n-        ret = xmlNewNsProp(ctxt->node, namespace, localname, NULL);\n-    if (ret == NULL) {\n-        xmlErrMemory(ctxt, \"xmlSAX2AttributeNs\");\n-        return;\n-    }\n+        if (ctxt->dictNames)\n+            ret = xmlNewNsPropEatName(ctxt->node, namespace,\n+                                      (xmlChar *) localname, NULL);\n+        else\n+            ret = xmlNewNsProp(ctxt->node, namespace, localname, NULL);\n+        if (ret == NULL) {\n+            xmlErrMemory(ctxt, \"xmlSAX2AttributeNs\");\n+            return;\n+        }\n@@ -2011,1 +2012,29 @@\n-    xmlNodePtr tmp;\n+        xmlNodePtr tmp;\n+\n+        \/*\n+         * We know that if there is an entity reference, then\n+         * the string has been dup'ed and terminates with 0\n+         * otherwise with ' or \"\n+         *\/\n+        if (*valueend != 0) {\n+            tmp = xmlSAX2TextNode(ctxt, value, valueend - value);\n+            ret->children = tmp;\n+            ret->last = tmp;\n+            if (tmp != NULL) {\n+                tmp->doc = ret->doc;\n+                tmp->parent = (xmlNodePtr) ret;\n+            }\n+        } else {\n+            ret->children = xmlStringLenGetNodeList(ctxt->myDoc, value,\n+                                                    valueend - value);\n+            tmp = ret->children;\n+            while (tmp != NULL) {\n+                tmp->doc = ret->doc;\n+                tmp->parent = (xmlNodePtr) ret;\n+                if (tmp->next == NULL)\n+                    ret->last = tmp;\n+                tmp = tmp->next;\n+            }\n+        }\n+    } else if (value != NULL) {\n+        xmlNodePtr tmp;\n@@ -2013,6 +2042,0 @@\n-    \/*\n-     * We know that if there is an entity reference, then\n-     * the string has been dup'ed and terminates with 0\n-     * otherwise with ' or \"\n-     *\/\n-    if (*valueend != 0) {\n@@ -2023,8 +2046,0 @@\n-        tmp->doc = ret->doc;\n-        tmp->parent = (xmlNodePtr) ret;\n-        }\n-    } else {\n-        ret->children = xmlStringLenGetNodeList(ctxt->myDoc, value,\n-                            valueend - value);\n-        tmp = ret->children;\n-        while (tmp != NULL) {\n@@ -2032,4 +2047,1 @@\n-        tmp->parent = (xmlNodePtr) ret;\n-        if (tmp->next == NULL)\n-            ret->last = tmp;\n-        tmp = tmp->next;\n+            tmp->parent = (xmlNodePtr) ret;\n@@ -2038,11 +2050,0 @@\n-    } else if (value != NULL) {\n-    xmlNodePtr tmp;\n-\n-    tmp = xmlSAX2TextNode(ctxt, value, valueend - value);\n-    ret->children = tmp;\n-    ret->last = tmp;\n-    if (tmp != NULL) {\n-        tmp->doc = ret->doc;\n-        tmp->parent = (xmlNodePtr) ret;\n-    }\n-    }\n@@ -2053,4 +2054,4 @@\n-    \/*\n-     * If we don't substitute entities, the validation should be\n-     * done on a value with replaced entities anyway.\n-     *\/\n+        \/*\n+         * If we don't substitute entities, the validation should be\n+         * done on a value with replaced entities anyway.\n+         *\/\n@@ -2058,5 +2059,50 @@\n-        dup = xmlSAX2DecodeAttrEntities(ctxt, value, valueend);\n-        if (dup == NULL) {\n-            if (*valueend == 0) {\n-            ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n-                    ctxt->myDoc, ctxt->node, ret, value);\n+            dup = xmlSAX2DecodeAttrEntities(ctxt, value, valueend);\n+            if (dup == NULL) {\n+                if (*valueend == 0) {\n+                    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n+                                    ctxt->myDoc, ctxt->node, ret, value);\n+                } else {\n+                    \/*\n+                     * That should already be normalized.\n+                     * cheaper to finally allocate here than duplicate\n+                     * entry points in the full validation code\n+                     *\/\n+                    dup = xmlStrndup(value, valueend - value);\n+\n+                    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n+                                    ctxt->myDoc, ctxt->node, ret, dup);\n+                }\n+            } else {\n+                \/*\n+                 * dup now contains a string of the flattened attribute\n+                 * content with entities substituted. Check if we need to\n+                 * apply an extra layer of normalization.\n+                 * It need to be done twice ... it's an extra burden related\n+                 * to the ability to keep references in attributes\n+                 *\/\n+                if (ctxt->attsSpecial != NULL) {\n+                    xmlChar *nvalnorm;\n+                    xmlChar fn[50];\n+                    xmlChar *fullname;\n+\n+                    fullname = xmlBuildQName(localname, prefix, fn, 50);\n+                    if (fullname != NULL) {\n+                        ctxt->vctxt.valid = 1;\n+                        nvalnorm = xmlValidCtxtNormalizeAttributeValue(\n+                                         &ctxt->vctxt, ctxt->myDoc,\n+                                         ctxt->node, fullname, dup);\n+                        if (ctxt->vctxt.valid != 1)\n+                            ctxt->valid = 0;\n+\n+                        if ((fullname != fn) && (fullname != localname))\n+                            xmlFree(fullname);\n+                        if (nvalnorm != NULL) {\n+                            xmlFree(dup);\n+                            dup = nvalnorm;\n+                        }\n+                    }\n+                }\n+\n+                ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n+                                ctxt->myDoc, ctxt->node, ret, dup);\n+            }\n@@ -2065,3 +2111,2 @@\n-             * That should already be normalized.\n-             * cheaper to finally allocate here than duplicate\n-             * entry points in the full validation code\n+             * if entities already have been substituted, then\n+             * the attribute as passed is already normalized\n@@ -2072,35 +2117,1 @@\n-                    ctxt->myDoc, ctxt->node, ret, dup);\n-        }\n-        } else {\n-            \/*\n-         * dup now contains a string of the flattened attribute\n-         * content with entities substituted. Check if we need to\n-         * apply an extra layer of normalization.\n-         * It need to be done twice ... it's an extra burden related\n-         * to the ability to keep references in attributes\n-         *\/\n-        if (ctxt->attsSpecial != NULL) {\n-            xmlChar *nvalnorm;\n-            xmlChar fn[50];\n-            xmlChar *fullname;\n-\n-            fullname = xmlBuildQName(localname, prefix, fn, 50);\n-            if (fullname != NULL) {\n-            ctxt->vctxt.valid = 1;\n-                nvalnorm = xmlValidCtxtNormalizeAttributeValue(\n-                             &ctxt->vctxt, ctxt->myDoc,\n-                     ctxt->node, fullname, dup);\n-            if (ctxt->vctxt.valid != 1)\n-                ctxt->valid = 0;\n-\n-            if ((fullname != fn) && (fullname != localname))\n-                xmlFree(fullname);\n-            if (nvalnorm != NULL) {\n-                xmlFree(dup);\n-                dup = nvalnorm;\n-            }\n-            }\n-        }\n-\n-        ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n-                    ctxt->myDoc, ctxt->node, ret, dup);\n+                                     ctxt->myDoc, ctxt->node, ret, dup);\n@@ -2108,10 +2119,0 @@\n-    } else {\n-        \/*\n-         * if entities already have been substituted, then\n-         * the attribute as passed is already normalized\n-         *\/\n-        dup = xmlStrndup(value, valueend - value);\n-\n-        ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n-                                 ctxt->myDoc, ctxt->node, ret, dup);\n-    }\n@@ -2121,9 +2122,2 @@\n-           (((ctxt->replaceEntities == 0) && (ctxt->external != 2)) ||\n-            ((ctxt->replaceEntities != 0) && (ctxt->inSubset == 0)))) {\n-        \/*\n-     * when validating, the ID registration is done at the attribute\n-     * validation level. Otherwise we have to do specific handling here.\n-     *\/\n-        if ((prefix == ctxt->str_xml) &&\n-               (localname[0] == 'i') && (localname[1] == 'd') &&\n-           (localname[2] == 0)) {\n+               (((ctxt->replaceEntities == 0) && (ctxt->external != 2)) ||\n+                ((ctxt->replaceEntities != 0) && (ctxt->inSubset == 0)))) {\n@@ -2131,3 +2125,2 @@\n-         * Add the xml:id value\n-         *\n-         * Open issue: normalization of the value.\n+         * when validating, the ID registration is done at the attribute\n+         * validation level. Otherwise we have to do specific handling here.\n@@ -2135,2 +2128,10 @@\n-        if (dup == NULL)\n-            dup = xmlStrndup(value, valueend - value);\n+        if ((prefix == ctxt->str_xml) &&\n+                   (localname[0] == 'i') && (localname[1] == 'd') &&\n+                   (localname[2] == 0)) {\n+            \/*\n+             * Add the xml:id value\n+             *\n+             * Open issue: normalization of the value.\n+             *\/\n+            if (dup == NULL)\n+                dup = xmlStrndup(value, valueend - value);\n@@ -2139,5 +2140,5 @@\n-        if (xmlValidateNCName(dup, 1) != 0) {\n-            xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,\n-              \"xml:id : attribute value %s is not an NCName\\n\",\n-                (const char *) dup, NULL);\n-        }\n+            if (xmlValidateNCName(dup, 1) != 0) {\n+                xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,\n+                      \"xml:id : attribute value %s is not an NCName\\n\",\n+                            (const char *) dup, NULL);\n+            }\n@@ -2146,11 +2147,11 @@\n-        xmlAddID(&ctxt->vctxt, ctxt->myDoc, dup, ret);\n-    } else if (xmlIsID(ctxt->myDoc, ctxt->node, ret)) {\n-        \/* might be worth duplicate entry points and not copy *\/\n-        if (dup == NULL)\n-            dup = xmlStrndup(value, valueend - value);\n-        xmlAddID(&ctxt->vctxt, ctxt->myDoc, dup, ret);\n-    } else if (xmlIsRef(ctxt->myDoc, ctxt->node, ret)) {\n-        if (dup == NULL)\n-            dup = xmlStrndup(value, valueend - value);\n-        xmlAddRef(&ctxt->vctxt, ctxt->myDoc, dup, ret);\n-    }\n+            xmlAddID(&ctxt->vctxt, ctxt->myDoc, dup, ret);\n+        } else if (xmlIsID(ctxt->myDoc, ctxt->node, ret)) {\n+            \/* might be worth duplicate entry points and not copy *\/\n+            if (dup == NULL)\n+                dup = xmlStrndup(value, valueend - value);\n+            xmlAddID(&ctxt->vctxt, ctxt->myDoc, dup, ret);\n+        } else if (xmlIsRef(ctxt->myDoc, ctxt->node, ret)) {\n+            if (dup == NULL)\n+                dup = xmlStrndup(value, valueend - value);\n+            xmlAddRef(&ctxt->vctxt, ctxt->myDoc, dup, ret);\n+        }\n@@ -2159,1 +2160,1 @@\n-    xmlFree(dup);\n+        xmlFree(dup);\n@@ -2182,7 +2183,7 @@\n-              const xmlChar *prefix,\n-              const xmlChar *URI,\n-              int nb_namespaces,\n-              const xmlChar **namespaces,\n-              int nb_attributes,\n-              int nb_defaulted,\n-              const xmlChar **attributes)\n+                      const xmlChar *prefix,\n+                      const xmlChar *URI,\n+                      int nb_namespaces,\n+                      const xmlChar **namespaces,\n+                      int nb_attributes,\n+                      int nb_defaulted,\n+                      const xmlChar **attributes)\n@@ -2205,7 +2206,7 @@\n-     ((ctxt->myDoc->intSubset->notations == NULL) &&\n-      (ctxt->myDoc->intSubset->elements == NULL) &&\n-      (ctxt->myDoc->intSubset->attributes == NULL) &&\n-      (ctxt->myDoc->intSubset->entities == NULL)))) {\n-    xmlErrValid(ctxt, XML_DTD_NO_DTD,\n-      \"Validation failed: no DTD found !\", NULL, NULL);\n-    ctxt->validate = 0;\n+         ((ctxt->myDoc->intSubset->notations == NULL) &&\n+          (ctxt->myDoc->intSubset->elements == NULL) &&\n+          (ctxt->myDoc->intSubset->attributes == NULL) &&\n+          (ctxt->myDoc->intSubset->entities == NULL)))) {\n+        xmlErrValid(ctxt, XML_DTD_NO_DTD,\n+          \"Validation failed: no DTD found !\", NULL, NULL);\n+        ctxt->validate = 0;\n@@ -2219,1 +2220,1 @@\n-        const xmlChar *fullname;\n+            const xmlChar *fullname;\n@@ -2221,6 +2222,6 @@\n-        fullname = xmlDictQLookup(ctxt->dict, prefix, localname);\n-        if (fullname != NULL)\n-            localname = fullname;\n-    } else {\n-        lname = xmlBuildQName(localname, prefix, NULL, 0);\n-    }\n+            fullname = xmlDictQLookup(ctxt->dict, prefix, localname);\n+            if (fullname != NULL)\n+                localname = fullname;\n+        } else {\n+            lname = xmlBuildQName(localname, prefix, NULL, 0);\n+        }\n@@ -2233,3 +2234,3 @@\n-    ctxt->freeElems = ret->next;\n-    ctxt->freeElemsNr--;\n-    memset(ret, 0, sizeof(xmlNode));\n+        ctxt->freeElems = ret->next;\n+        ctxt->freeElemsNr--;\n+        memset(ret, 0, sizeof(xmlNode));\n@@ -2237,1 +2238,1 @@\n-    ret->type = XML_ELEMENT_NODE;\n+        ret->type = XML_ELEMENT_NODE;\n@@ -2239,5 +2240,20 @@\n-    if (ctxt->dictNames)\n-        ret->name = localname;\n-    else {\n-        if (lname == NULL)\n-        ret->name = xmlStrdup(localname);\n+        if (ctxt->dictNames)\n+            ret->name = localname;\n+        else {\n+            if (lname == NULL)\n+                ret->name = xmlStrdup(localname);\n+            else\n+                ret->name = lname;\n+            if (ret->name == NULL) {\n+                xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartElementNs\");\n+                return;\n+            }\n+        }\n+        if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+            xmlRegisterNodeDefaultValue(ret);\n+    } else {\n+        if (ctxt->dictNames)\n+            ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,\n+                                       (xmlChar *) localname, NULL);\n+        else if (lname == NULL)\n+            ret = xmlNewDocNode(ctxt->myDoc, NULL, localname, NULL);\n@@ -2245,2 +2261,3 @@\n-            ret->name = lname;\n-        if (ret->name == NULL) {\n+            ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,\n+                                       (xmlChar *) lname, NULL);\n+        if (ret == NULL) {\n@@ -2248,1 +2265,1 @@\n-        return;\n+            return;\n@@ -2251,16 +2268,0 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-        xmlRegisterNodeDefaultValue(ret);\n-    } else {\n-    if (ctxt->dictNames)\n-        ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,\n-                                   (xmlChar *) localname, NULL);\n-    else if (lname == NULL)\n-        ret = xmlNewDocNode(ctxt->myDoc, NULL, localname, NULL);\n-    else\n-        ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,\n-                                   (xmlChar *) lname, NULL);\n-    if (ret == NULL) {\n-        xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartElementNs\");\n-        return;\n-    }\n-    }\n@@ -2268,6 +2269,6 @@\n-    if (ctxt->input != NULL) {\n-        if (ctxt->input->line < 65535)\n-        ret->line = (short) ctxt->input->line;\n-        else\n-            ret->line = 65535;\n-    }\n+        if (ctxt->input != NULL) {\n+            if (ctxt->input->line < USHRT_MAX)\n+                ret->line = (unsigned short) ctxt->input->line;\n+            else\n+                ret->line = USHRT_MAX;\n+        }\n@@ -2284,5 +2285,11 @@\n-    uri = namespaces[i++];\n-    ns = xmlNewNs(NULL, uri, pref);\n-    if (ns != NULL) {\n-        if (last == NULL) {\n-            ret->nsDef = last = ns;\n+        uri = namespaces[i++];\n+        ns = xmlNewNs(NULL, uri, pref);\n+        if (ns != NULL) {\n+            if (last == NULL) {\n+                ret->nsDef = last = ns;\n+            } else {\n+                last->next = ns;\n+                last = ns;\n+            }\n+            if ((URI != NULL) && (prefix == pref))\n+                ret->ns = ns;\n@@ -2290,6 +2297,0 @@\n-            last->next = ns;\n-        last = ns;\n-        }\n-        if ((URI != NULL) && (prefix == pref))\n-        ret->ns = ns;\n-    } else {\n@@ -2301,2 +2302,2 @@\n-        continue;\n-    }\n+            continue;\n+        }\n@@ -2304,5 +2305,5 @@\n-    if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&\n-        ctxt->myDoc && ctxt->myDoc->intSubset) {\n-        ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,\n-                                               ret, prefix, ns, uri);\n-    }\n+        if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&\n+            ctxt->myDoc && ctxt->myDoc->intSubset) {\n+            ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,\n+                                                   ret, prefix, ns, uri);\n+        }\n@@ -2327,4 +2328,4 @@\n-        xmlAddChild(parent, ret);\n-    } else {\n-        xmlAddSibling(parent, ret);\n-    }\n+            xmlAddChild(parent, ret);\n+        } else {\n+            xmlAddSibling(parent, ret);\n+        }\n@@ -2338,1 +2339,1 @@\n-    nb_attributes -= nb_defaulted;\n+        nb_attributes -= nb_defaulted;\n@@ -2346,9 +2347,2 @@\n-    if ((ret->ns == NULL) && (xmlStrEqual(prefix, BAD_CAST \"xml\"))) {\n-        ret->ns = xmlSearchNs(ctxt->myDoc, ret, prefix);\n-    }\n-    if (ret->ns == NULL) {\n-        ns = xmlNewNs(ret, NULL, prefix);\n-        if (ns == NULL) {\n-\n-            xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartElementNs\");\n-        return;\n+        if ((ret->ns == NULL) && (xmlStrEqual(prefix, BAD_CAST \"xml\"))) {\n+            ret->ns = xmlSearchNs(ctxt->myDoc, ret, prefix);\n@@ -2356,0 +2350,7 @@\n+        if (ret->ns == NULL) {\n+            ns = xmlNewNs(ret, NULL, prefix);\n+            if (ns == NULL) {\n+\n+                xmlSAX2ErrMemory(ctxt, \"xmlSAX2StartElementNs\");\n+                return;\n+            }\n@@ -2364,1 +2365,1 @@\n-    }\n+        }\n@@ -2372,13 +2373,24 @@\n-        \/*\n-         * Handle the rare case of an undefined attribute prefix\n-         *\/\n-        if ((attributes[j+1] != NULL) && (attributes[j+2] == NULL)) {\n-        if (ctxt->dictNames) {\n-            const xmlChar *fullname;\n-\n-            fullname = xmlDictQLookup(ctxt->dict, attributes[j+1],\n-                                      attributes[j]);\n-            if (fullname != NULL) {\n-            xmlSAX2AttributeNs(ctxt, fullname, NULL,\n-                               attributes[j+3], attributes[j+4]);\n-                continue;\n+            \/*\n+             * Handle the rare case of an undefined attribute prefix\n+             *\/\n+            if ((attributes[j+1] != NULL) && (attributes[j+2] == NULL)) {\n+                if (ctxt->dictNames) {\n+                    const xmlChar *fullname;\n+\n+                    fullname = xmlDictQLookup(ctxt->dict, attributes[j+1],\n+                                              attributes[j]);\n+                    if (fullname != NULL) {\n+                        xmlSAX2AttributeNs(ctxt, fullname, NULL,\n+                                           attributes[j+3], attributes[j+4]);\n+                        continue;\n+                    }\n+                } else {\n+                    lname = xmlBuildQName(attributes[j], attributes[j+1],\n+                                          NULL, 0);\n+                    if (lname != NULL) {\n+                        xmlSAX2AttributeNs(ctxt, lname, NULL,\n+                                           attributes[j+3], attributes[j+4]);\n+                        xmlFree(lname);\n+                        continue;\n+                    }\n+                }\n@@ -2386,5 +2398,1 @@\n-        } else {\n-            lname = xmlBuildQName(attributes[j], attributes[j+1],\n-                                  NULL, 0);\n-            if (lname != NULL) {\n-            xmlSAX2AttributeNs(ctxt, lname, NULL,\n+            xmlSAX2AttributeNs(ctxt, attributes[j], attributes[j+1],\n@@ -2392,4 +2400,0 @@\n-            xmlFree(lname);\n-                continue;\n-            }\n-        }\n@@ -2397,3 +2401,0 @@\n-        xmlSAX2AttributeNs(ctxt, attributes[j], attributes[j+1],\n-                   attributes[j+3], attributes[j+4]);\n-    }\n@@ -2408,1 +2409,1 @@\n-    int chk;\n+        int chk;\n@@ -2410,7 +2411,7 @@\n-    chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc);\n-    if (chk <= 0)\n-        ctxt->valid = 0;\n-    if (chk < 0)\n-        ctxt->wellFormed = 0;\n-    ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n-    ctxt->vctxt.finishDtd = XML_CTXT_FINISH_DTD_1;\n+        chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc);\n+        if (chk <= 0)\n+            ctxt->valid = 0;\n+        if (chk < 0)\n+            ctxt->wellFormed = 0;\n+        ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n+        ctxt->vctxt.finishDtd = XML_CTXT_FINISH_DTD_1;\n@@ -2435,1 +2436,1 @@\n-            const xmlChar * URI ATTRIBUTE_UNUSED)\n+                    const xmlChar * URI ATTRIBUTE_UNUSED)\n@@ -2480,1 +2481,1 @@\n-        \"SAX.xmlSAX2Reference(%s)\\n\", name);\n+            \"SAX.xmlSAX2Reference(%s)\\n\", name);\n@@ -2483,1 +2484,1 @@\n-    ret = xmlNewCharRef(ctxt->myDoc, name);\n+        ret = xmlNewCharRef(ctxt->myDoc, name);\n@@ -2485,1 +2486,1 @@\n-    ret = xmlNewReference(ctxt->myDoc, name);\n+        ret = xmlNewReference(ctxt->myDoc, name);\n@@ -2488,1 +2489,1 @@\n-        \"add xmlSAX2Reference %s to %s \\n\", name, ctxt->node->name);\n+            \"add xmlSAX2Reference %s to %s \\n\", name, ctxt->node->name);\n@@ -2513,1 +2514,1 @@\n-        \"SAX.xmlSAX2Characters(%.30s, %d)\\n\", ch, len);\n+            \"SAX.xmlSAX2Characters(%.30s, %d)\\n\", ch, len);\n@@ -2523,2 +2524,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"add chars: ctxt->node == NULL !\\n\");\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"add chars: ctxt->node == NULL !\\n\");\n@@ -2531,1 +2532,1 @@\n-        \"add chars to %s \\n\", ctxt->node->name);\n+            \"add chars to %s \\n\", ctxt->node->name);\n@@ -2543,11 +2544,11 @@\n-    if (lastChild != NULL) {\n-        ctxt->node->children = lastChild;\n-        ctxt->node->last = lastChild;\n-        lastChild->parent = ctxt->node;\n-        lastChild->doc = ctxt->node->doc;\n-        ctxt->nodelen = len;\n-        ctxt->nodemem = len + 1;\n-    } else {\n-        xmlSAX2ErrMemory(ctxt, \"xmlSAX2Characters\");\n-        return;\n-    }\n+        if (lastChild != NULL) {\n+            ctxt->node->children = lastChild;\n+            ctxt->node->last = lastChild;\n+            lastChild->parent = ctxt->node;\n+            lastChild->doc = ctxt->node->doc;\n+            ctxt->nodelen = len;\n+            ctxt->nodemem = len + 1;\n+        } else {\n+            xmlSAX2ErrMemory(ctxt, \"xmlSAX2Characters\");\n+            return;\n+        }\n@@ -2555,3 +2556,3 @@\n-    int coalesceText = (lastChild != NULL) &&\n-        (lastChild->type == type) &&\n-        ((type != XML_TEXT_NODE) ||\n+        int coalesceText = (lastChild != NULL) &&\n+            (lastChild->type == type) &&\n+            ((type != XML_TEXT_NODE) ||\n@@ -2559,19 +2560,19 @@\n-    if ((coalesceText) && (ctxt->nodemem != 0)) {\n-        \/*\n-         * The whole point of maintaining nodelen and nodemem,\n-         * xmlTextConcat is too costly, i.e. compute length,\n-         * reallocate a new buffer, move data, append ch. Here\n-         * We try to minimize realloc() uses and avoid copying\n-         * and recomputing length over and over.\n-         *\/\n-        if (lastChild->content == (xmlChar *)&(lastChild->properties)) {\n-        lastChild->content = xmlStrdup(lastChild->content);\n-        lastChild->properties = NULL;\n-        } else if ((ctxt->nodemem == ctxt->nodelen + 1) &&\n-                   (xmlDictOwns(ctxt->dict, lastChild->content))) {\n-        lastChild->content = xmlStrdup(lastChild->content);\n-        }\n-        if (lastChild->content == NULL) {\n-        xmlSAX2ErrMemory(ctxt, \"xmlSAX2Characters: xmlStrdup returned NULL\");\n-        return;\n-        }\n+        if ((coalesceText) && (ctxt->nodemem != 0)) {\n+            \/*\n+             * The whole point of maintaining nodelen and nodemem,\n+             * xmlTextConcat is too costly, i.e. compute length,\n+             * reallocate a new buffer, move data, append ch. Here\n+             * We try to minimize realloc() uses and avoid copying\n+             * and recomputing length over and over.\n+             *\/\n+            if (lastChild->content == (xmlChar *)&(lastChild->properties)) {\n+                lastChild->content = xmlStrdup(lastChild->content);\n+                lastChild->properties = NULL;\n+            } else if ((ctxt->nodemem == ctxt->nodelen + 1) &&\n+                       (xmlDictOwns(ctxt->dict, lastChild->content))) {\n+                lastChild->content = xmlStrdup(lastChild->content);\n+            }\n+            if (lastChild->content == NULL) {\n+                xmlSAX2ErrMemory(ctxt, \"xmlSAX2Characters: xmlStrdup returned NULL\");\n+                return;\n+            }\n@@ -2583,2 +2584,2 @@\n-        if ((size_t)ctxt->nodelen > SIZE_T_MAX - (size_t)len ||\n-            (size_t)ctxt->nodemem + (size_t)len > SIZE_T_MAX \/ 2) {\n+            if ((size_t)ctxt->nodelen > SIZE_T_MAX - (size_t)len ||\n+                (size_t)ctxt->nodemem + (size_t)len > SIZE_T_MAX \/ 2) {\n@@ -2587,4 +2588,4 @@\n-        }\n-        if (ctxt->nodelen + len >= ctxt->nodemem) {\n-        xmlChar *newbuf;\n-        size_t size;\n+            }\n+            if (ctxt->nodelen + len >= ctxt->nodemem) {\n+                xmlChar *newbuf;\n+                size_t size;\n@@ -2592,2 +2593,2 @@\n-        size = ctxt->nodemem + len;\n-        size *= 2;\n+                size = ctxt->nodemem + len;\n+                size *= 2;\n@@ -2595,20 +2596,20 @@\n-        if (newbuf == NULL) {\n-            xmlSAX2ErrMemory(ctxt, \"xmlSAX2Characters\");\n-            return;\n-        }\n-        ctxt->nodemem = size;\n-        lastChild->content = newbuf;\n-        }\n-        memcpy(&lastChild->content[ctxt->nodelen], ch, len);\n-        ctxt->nodelen += len;\n-        lastChild->content[ctxt->nodelen] = 0;\n-    } else if (coalesceText) {\n-        if (xmlTextConcat(lastChild, ch, len)) {\n-        xmlSAX2ErrMemory(ctxt, \"xmlSAX2Characters\");\n-        }\n-        if (ctxt->node->children != NULL) {\n-        ctxt->nodelen = xmlStrlen(lastChild->content);\n-        ctxt->nodemem = ctxt->nodelen + 1;\n-        }\n-    } else {\n-        \/* Mixed content, first time *\/\n+                if (newbuf == NULL) {\n+                    xmlSAX2ErrMemory(ctxt, \"xmlSAX2Characters\");\n+                    return;\n+                }\n+                ctxt->nodemem = size;\n+                lastChild->content = newbuf;\n+            }\n+            memcpy(&lastChild->content[ctxt->nodelen], ch, len);\n+            ctxt->nodelen += len;\n+            lastChild->content[ctxt->nodelen] = 0;\n+        } else if (coalesceText) {\n+            if (xmlTextConcat(lastChild, ch, len)) {\n+                xmlSAX2ErrMemory(ctxt, \"xmlSAX2Characters\");\n+            }\n+            if (ctxt->node->children != NULL) {\n+                ctxt->nodelen = xmlStrlen(lastChild->content);\n+                ctxt->nodemem = ctxt->nodelen + 1;\n+            }\n+        } else {\n+            \/* Mixed content, first time *\/\n@@ -2619,6 +2620,7 @@\n-        if (lastChild != NULL) {\n-        xmlAddChild(ctxt->node, lastChild);\n-        if (ctxt->node->children != NULL) {\n-            ctxt->nodelen = len;\n-            ctxt->nodemem = len + 1;\n-        }\n+            if (lastChild != NULL) {\n+                xmlAddChild(ctxt->node, lastChild);\n+                if (ctxt->node->children != NULL) {\n+                    ctxt->nodelen = len;\n+                    ctxt->nodemem = len + 1;\n+                }\n+            }\n@@ -2627,1 +2629,0 @@\n-    }\n@@ -2659,1 +2660,1 @@\n-        \"SAX.xmlSAX2IgnorableWhitespace(%.30s, %d)\\n\", ch, len);\n+            \"SAX.xmlSAX2IgnorableWhitespace(%.30s, %d)\\n\", ch, len);\n@@ -2683,1 +2684,1 @@\n-        \"SAX.xmlSAX2ProcessingInstruction(%s, %s)\\n\", target, data);\n+            \"SAX.xmlSAX2ProcessingInstruction(%s, %s)\\n\", target, data);\n@@ -2690,6 +2691,6 @@\n-    if (ctxt->input != NULL) {\n-        if (ctxt->input->line < 65535)\n-        ret->line = (short) ctxt->input->line;\n-        else\n-            ret->line = 65535;\n-    }\n+        if (ctxt->input != NULL) {\n+            if (ctxt->input->line < USHRT_MAX)\n+                ret->line = (unsigned short) ctxt->input->line;\n+            else\n+                ret->line = USHRT_MAX;\n+        }\n@@ -2698,2 +2699,2 @@\n-    xmlAddChild((xmlNodePtr) ctxt->myDoc->intSubset, ret);\n-    return;\n+        xmlAddChild((xmlNodePtr) ctxt->myDoc->intSubset, ret);\n+        return;\n@@ -2701,2 +2702,2 @@\n-    xmlAddChild((xmlNodePtr) ctxt->myDoc->extSubset, ret);\n-    return;\n+        xmlAddChild((xmlNodePtr) ctxt->myDoc->extSubset, ret);\n+        return;\n@@ -2706,2 +2707,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"Setting PI %s as root\\n\", target);\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"Setting PI %s as root\\n\", target);\n@@ -2710,1 +2711,1 @@\n-    return;\n+        return;\n@@ -2714,2 +2715,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"adding PI %s child to %s\\n\", target, parent->name);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"adding PI %s child to %s\\n\", target, parent->name);\n@@ -2717,1 +2718,1 @@\n-    xmlAddChild(parent, ret);\n+        xmlAddChild(parent, ret);\n@@ -2720,3 +2721,3 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"adding PI %s sibling to \", target);\n-    xmlDebugDumpOneNode(stderr, parent, 0);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"adding PI %s sibling to \", target);\n+        xmlDebugDumpOneNode(stderr, parent, 0);\n@@ -2724,1 +2725,1 @@\n-    xmlAddSibling(parent, ret);\n+        xmlAddSibling(parent, ret);\n@@ -2750,6 +2751,6 @@\n-    if (ctxt->input != NULL) {\n-        if (ctxt->input->line < 65535)\n-        ret->line = (short) ctxt->input->line;\n-        else\n-            ret->line = 65535;\n-    }\n+        if (ctxt->input != NULL) {\n+            if (ctxt->input->line < USHRT_MAX)\n+                ret->line = (unsigned short) ctxt->input->line;\n+            else\n+                ret->line = USHRT_MAX;\n+        }\n@@ -2759,2 +2760,2 @@\n-    xmlAddChild((xmlNodePtr) ctxt->myDoc->intSubset, ret);\n-    return;\n+        xmlAddChild((xmlNodePtr) ctxt->myDoc->intSubset, ret);\n+        return;\n@@ -2762,2 +2763,2 @@\n-    xmlAddChild((xmlNodePtr) ctxt->myDoc->extSubset, ret);\n-    return;\n+        xmlAddChild((xmlNodePtr) ctxt->myDoc->extSubset, ret);\n+        return;\n@@ -2767,2 +2768,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"Setting xmlSAX2Comment as root\\n\");\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"Setting xmlSAX2Comment as root\\n\");\n@@ -2771,1 +2772,1 @@\n-    return;\n+        return;\n@@ -2775,2 +2776,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"adding xmlSAX2Comment child to %s\\n\", parent->name);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"adding xmlSAX2Comment child to %s\\n\", parent->name);\n@@ -2778,1 +2779,1 @@\n-    xmlAddChild(parent, ret);\n+        xmlAddChild(parent, ret);\n@@ -2781,3 +2782,3 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"adding xmlSAX2Comment sibling to \");\n-    xmlDebugDumpOneNode(stderr, parent, 0);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"adding xmlSAX2Comment sibling to \");\n+        xmlDebugDumpOneNode(stderr, parent, 0);\n@@ -2785,1 +2786,1 @@\n-    xmlAddSibling(parent, ret);\n+        xmlAddSibling(parent, ret);\n@@ -2844,6 +2845,6 @@\n-    hdlr->startElement = NULL;\n-    hdlr->endElement = NULL;\n-    hdlr->startElementNs = xmlSAX2StartElementNs;\n-    hdlr->endElementNs = xmlSAX2EndElementNs;\n-    hdlr->serror = NULL;\n-    hdlr->initialized = XML_SAX2_MAGIC;\n+        hdlr->startElement = NULL;\n+        hdlr->endElement = NULL;\n+        hdlr->startElementNs = xmlSAX2StartElementNs;\n+        hdlr->endElementNs = xmlSAX2EndElementNs;\n+        hdlr->serror = NULL;\n+        hdlr->initialized = XML_SAX2_MAGIC;\n@@ -2852,3 +2853,3 @@\n-    hdlr->startElement = xmlSAX2StartElement;\n-    hdlr->endElement = xmlSAX2EndElement;\n-    hdlr->initialized = 1;\n+        hdlr->startElement = xmlSAX2StartElement;\n+        hdlr->endElement = xmlSAX2EndElement;\n+        hdlr->initialized = 1;\n@@ -2898,1 +2899,1 @@\n-    return;\n+        return;\n@@ -2902,1 +2903,1 @@\n-    hdlr->warning = NULL;\n+        hdlr->warning = NULL;\n@@ -2904,1 +2905,1 @@\n-    hdlr->warning = xmlParserWarning;\n+        hdlr->warning = xmlParserWarning;\n@@ -2932,1 +2933,1 @@\n-    return;\n+        return;\n@@ -2990,1 +2991,1 @@\n-    return;\n+        return;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/SAX2.c","additions":1171,"deletions":1170,"binary":false,"changes":2341,"status":"modified"},{"patch":"@@ -8,2 +8,0 @@\n-      $Id$\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/TODO","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-# generated automatically by aclocal 1.16.1 -*- Autoconf -*-\n+# generated automatically by aclocal 1.16.5 -*- Autoconf -*-\n@@ -3,1 +3,1 @@\n-# Copyright (C) 1996-2018 Free Software Foundation, Inc.\n+# Copyright (C) 1996-2021 Free Software Foundation, Inc.\n@@ -17,2 +17,2 @@\n-m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.69],,\n-[m4_warning([this file was generated for autoconf 2.69.\n+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.71],,\n+[m4_warning([this file was generated for autoconf 2.71.\n@@ -24,1 +24,1 @@\n-# serial 11 (pkg-config-0.29.1)\n+# serial 12 (pkg-config-0.29.2)\n@@ -66,1 +66,1 @@\n-[m4_define([PKG_MACROS_VERSION], [0.29.1])\n+[m4_define([PKG_MACROS_VERSION], [0.29.2])\n@@ -167,1 +167,1 @@\n-AC_MSG_CHECKING([for $1])\n+AC_MSG_CHECKING([for $2])\n@@ -299,69 +299,1 @@\n-dnl PKG_WITH_MODULES(VARIABLE-PREFIX, MODULES,\n-dnl   [ACTION-IF-FOUND],[ACTION-IF-NOT-FOUND],\n-dnl   [DESCRIPTION], [DEFAULT])\n-dnl ------------------------------------------\n-dnl\n-dnl Prepare a \"--with-\" configure option using the lowercase\n-dnl [VARIABLE-PREFIX] name, merging the behaviour of AC_ARG_WITH and\n-dnl PKG_CHECK_MODULES in a single macro.\n-AC_DEFUN([PKG_WITH_MODULES],\n-[\n-m4_pushdef([with_arg], m4_tolower([$1]))\n-\n-m4_pushdef([description],\n-           [m4_default([$5], [build with ]with_arg[ support])])\n-\n-m4_pushdef([def_arg], [m4_default([$6], [auto])])\n-m4_pushdef([def_action_if_found], [AS_TR_SH([with_]with_arg)=yes])\n-m4_pushdef([def_action_if_not_found], [AS_TR_SH([with_]with_arg)=no])\n-\n-m4_case(def_arg,\n-            [yes],[m4_pushdef([with_without], [--without-]with_arg)],\n-            [m4_pushdef([with_without],[--with-]with_arg)])\n-\n-AC_ARG_WITH(with_arg,\n-     AS_HELP_STRING(with_without, description[ @<:@default=]def_arg[@:>@]),,\n-    [AS_TR_SH([with_]with_arg)=def_arg])\n-\n-AS_CASE([$AS_TR_SH([with_]with_arg)],\n-            [yes],[PKG_CHECK_MODULES([$1],[$2],$3,$4)],\n-            [auto],[PKG_CHECK_MODULES([$1],[$2],\n-                                        [m4_n([def_action_if_found]) $3],\n-                                        [m4_n([def_action_if_not_found]) $4])])\n-\n-m4_popdef([with_arg])\n-m4_popdef([description])\n-m4_popdef([def_arg])\n-\n-])dnl PKG_WITH_MODULES\n-\n-dnl PKG_HAVE_WITH_MODULES(VARIABLE-PREFIX, MODULES,\n-dnl   [DESCRIPTION], [DEFAULT])\n-dnl -----------------------------------------------\n-dnl\n-dnl Convenience macro to trigger AM_CONDITIONAL after PKG_WITH_MODULES\n-dnl check._[VARIABLE-PREFIX] is exported as make variable.\n-AC_DEFUN([PKG_HAVE_WITH_MODULES],\n-[\n-PKG_WITH_MODULES([$1],[$2],,,[$3],[$4])\n-\n-AM_CONDITIONAL([HAVE_][$1],\n-               [test \"$AS_TR_SH([with_]m4_tolower([$1]))\" = \"yes\"])\n-])dnl PKG_HAVE_WITH_MODULES\n-\n-dnl PKG_HAVE_DEFINE_WITH_MODULES(VARIABLE-PREFIX, MODULES,\n-dnl   [DESCRIPTION], [DEFAULT])\n-dnl ------------------------------------------------------\n-dnl\n-dnl Convenience macro to run AM_CONDITIONAL and AC_DEFINE after\n-dnl PKG_WITH_MODULES check. HAVE_[VARIABLE-PREFIX] is exported as make\n-dnl and preprocessor variable.\n-AC_DEFUN([PKG_HAVE_DEFINE_WITH_MODULES],\n-[\n-PKG_HAVE_WITH_MODULES([$1],[$2],[$3],[$4])\n-\n-AS_IF([test \"$AS_TR_SH([with_]m4_tolower([$1]))\" = \"yes\"],\n-        [AC_DEFINE([HAVE_][$1], 1, [Enable ]m4_tolower([$1])[ support])])\n-])dnl PKG_HAVE_DEFINE_WITH_MODULES\n-\n-# Copyright (C) 2002-2018 Free Software Foundation, Inc.\n+# Copyright (C) 2002-2021 Free Software Foundation, Inc.\n@@ -382,1 +314,1 @@\n-m4_if([$1], [1.16.1], [],\n+m4_if([$1], [1.16.5], [],\n@@ -398,1 +330,1 @@\n-[AM_AUTOMAKE_VERSION([1.16.1])dnl\n+[AM_AUTOMAKE_VERSION([1.16.5])dnl\n@@ -405,1 +337,1 @@\n-# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2021 Free Software Foundation, Inc.\n@@ -457,1 +389,1 @@\n-# Copyright (C) 1997-2018 Free Software Foundation, Inc.\n+# Copyright (C) 1997-2021 Free Software Foundation, Inc.\n@@ -488,1 +420,1 @@\n-# Copyright (C) 1999-2018 Free Software Foundation, Inc.\n+# Copyright (C) 1999-2021 Free Software Foundation, Inc.\n@@ -679,1 +611,1 @@\n-# Copyright (C) 1999-2018 Free Software Foundation, Inc.\n+# Copyright (C) 1999-2021 Free Software Foundation, Inc.\n@@ -718,1 +650,3 @@\n-    for automatic dependency tracking.  Try re-running configure with the\n+    for automatic dependency tracking.  If GNU make was not used, consider\n+    re-running the configure script with MAKE=\"gmake\" (or whatever is\n+    necessary).  You can also try re-running configure with the\n@@ -745,1 +679,1 @@\n-# Copyright (C) 1996-2018 Free Software Foundation, Inc.\n+# Copyright (C) 1996-2021 Free Software Foundation, Inc.\n@@ -773,0 +707,4 @@\n+m4_ifdef([_$0_ALREADY_INIT],\n+  [m4_fatal([$0 expanded multiple times\n+]m4_defn([_$0_ALREADY_INIT]))],\n+  [m4_define([_$0_ALREADY_INIT], m4_expansion_stack)])dnl\n@@ -809,1 +747,1 @@\n-  m4_ifdef([AC_PACKAGE_NAME], [ok]):m4_ifdef([AC_PACKAGE_VERSION], [ok]),\n+  m4_ifset([AC_PACKAGE_NAME], [ok]):m4_ifset([AC_PACKAGE_VERSION], [ok]),\n@@ -861,0 +799,14 @@\n+# Variables for tags utilities; see am\/tags.am\n+if test -z \"$CTAGS\"; then\n+  CTAGS=ctags\n+fi\n+AC_SUBST([CTAGS])\n+if test -z \"$ETAGS\"; then\n+  ETAGS=etags\n+fi\n+AC_SUBST([ETAGS])\n+if test -z \"$CSCOPE\"; then\n+  CSCOPE=cscope\n+fi\n+AC_SUBST([CSCOPE])\n+\n@@ -942,1 +894,1 @@\n-# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2021 Free Software Foundation, Inc.\n@@ -963,1 +915,1 @@\n-# Copyright (C) 2003-2018 Free Software Foundation, Inc.\n+# Copyright (C) 2003-2021 Free Software Foundation, Inc.\n@@ -985,1 +937,1 @@\n-# Copyright (C) 1996-2018 Free Software Foundation, Inc.\n+# Copyright (C) 1996-2021 Free Software Foundation, Inc.\n@@ -1020,1 +972,1 @@\n-# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2021 Free Software Foundation, Inc.\n@@ -1063,1 +1015,1 @@\n-# Copyright (C) 1997-2018 Free Software Foundation, Inc.\n+# Copyright (C) 1997-2021 Free Software Foundation, Inc.\n@@ -1084,6 +1036,1 @@\n-  case $am_aux_dir in\n-  *\\ * | *\\\t*)\n-    MISSING=\"\\${SHELL} \\\"$am_aux_dir\/missing\\\"\" ;;\n-  *)\n-    MISSING=\"\\${SHELL} $am_aux_dir\/missing\" ;;\n-  esac\n+  MISSING=\"\\${SHELL} '$am_aux_dir\/missing'\"\n@@ -1102,1 +1049,1 @@\n-# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2021 Free Software Foundation, Inc.\n@@ -1131,1 +1078,1 @@\n-# Copyright (C) 1999-2018 Free Software Foundation, Inc.\n+# Copyright (C) 1999-2021 Free Software Foundation, Inc.\n@@ -1178,1 +1125,1 @@\n-# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2021 Free Software Foundation, Inc.\n@@ -1197,1 +1144,1 @@\n-# Copyright (C) 1996-2018 Free Software Foundation, Inc.\n+# Copyright (C) 1996-2021 Free Software Foundation, Inc.\n@@ -1278,1 +1225,1 @@\n-# Copyright (C) 2009-2018 Free Software Foundation, Inc.\n+# Copyright (C) 2009-2021 Free Software Foundation, Inc.\n@@ -1338,1 +1285,1 @@\n-# Copyright (C) 2001-2018 Free Software Foundation, Inc.\n+# Copyright (C) 2001-2021 Free Software Foundation, Inc.\n@@ -1366,1 +1313,1 @@\n-# Copyright (C) 2006-2018 Free Software Foundation, Inc.\n+# Copyright (C) 2006-2021 Free Software Foundation, Inc.\n@@ -1385,1 +1332,1 @@\n-# Copyright (C) 2004-2018 Free Software Foundation, Inc.\n+# Copyright (C) 2004-2021 Free Software Foundation, Inc.\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/aclocal.m4","additions":51,"deletions":104,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    xmlChar *content;       \/* The buffer content UTF8 *\/\n+    xmlChar *content;           \/* The buffer content UTF8 *\/\n@@ -48,3 +48,3 @@\n-    xmlChar *contentIO;     \/* in IO mode we may have a different base *\/\n-    size_t use;             \/* The buffer size used *\/\n-    size_t size;        \/* The buffer size *\/\n+    xmlChar *contentIO;         \/* in IO mode we may have a different base *\/\n+    size_t use;                 \/* The buffer size used *\/\n+    size_t size;                \/* The buffer size *\/\n@@ -60,1 +60,1 @@\n-#define UPDATE_COMPAT(buf)                  \\\n+#define UPDATE_COMPAT(buf)                                  \\\n@@ -62,1 +62,1 @@\n-     else buf->compat_size = INT_MAX;               \\\n+     else buf->compat_size = INT_MAX;                       \\\n@@ -71,7 +71,7 @@\n-#define CHECK_COMPAT(buf)                   \\\n-     if (buf->size != (size_t) buf->compat_size)        \\\n-         if (buf->compat_size < INT_MAX)            \\\n-         buf->size = buf->compat_size;          \\\n-     if (buf->use != (size_t) buf->compat_use)          \\\n-         if (buf->compat_use < INT_MAX)             \\\n-         buf->use = buf->compat_use;\n+#define CHECK_COMPAT(buf)                                   \\\n+     if (buf->size != (size_t) buf->compat_size)            \\\n+         if (buf->compat_size < INT_MAX)                    \\\n+             buf->size = buf->compat_size;                  \\\n+     if (buf->use != (size_t) buf->compat_use)              \\\n+         if (buf->compat_use < INT_MAX)                     \\\n+             buf->use = buf->compat_use;\n@@ -127,1 +127,1 @@\n-    xmlBufMemoryError(NULL, \"creating buffer\");\n+        xmlBufMemoryError(NULL, \"creating buffer\");\n@@ -139,2 +139,2 @@\n-    xmlBufMemoryError(ret, \"creating buffer\");\n-    xmlFree(ret);\n+        xmlBufMemoryError(ret, \"creating buffer\");\n+        xmlFree(ret);\n@@ -161,1 +161,1 @@\n-    xmlBufMemoryError(NULL, \"creating buffer\");\n+        xmlBufMemoryError(NULL, \"creating buffer\");\n@@ -174,1 +174,1 @@\n-        xmlBufMemoryError(ret, \"creating buffer\");\n+            xmlBufMemoryError(ret, \"creating buffer\");\n@@ -180,1 +180,1 @@\n-    ret->content = NULL;\n+        ret->content = NULL;\n@@ -239,1 +239,1 @@\n-    xmlBufMemoryError(NULL, \"creating buffer\");\n+        xmlBufMemoryError(NULL, \"creating buffer\");\n@@ -271,1 +271,1 @@\n-        \"xmlBufGetAllocationScheme: buf == NULL\\n\");\n+                \"xmlBufGetAllocationScheme: buf == NULL\\n\");\n@@ -293,1 +293,1 @@\n-        \"xmlBufSetAllocationScheme: buf == NULL or in error\\n\");\n+                \"xmlBufSetAllocationScheme: buf == NULL or in error\\n\");\n@@ -304,2 +304,2 @@\n-    (scheme == XML_BUFFER_ALLOC_BOUNDED)) {\n-    buf->alloc = scheme;\n+        (scheme == XML_BUFFER_ALLOC_BOUNDED)) {\n+        buf->alloc = scheme;\n@@ -333,1 +333,1 @@\n-        \"xmlBufFree: buf == NULL\\n\");\n+                \"xmlBufFree: buf == NULL\\n\");\n@@ -335,1 +335,1 @@\n-    return;\n+        return;\n@@ -366,1 +366,1 @@\n-    buf->size += start_buf;\n+        buf->size += start_buf;\n@@ -397,4 +397,4 @@\n-    \/*\n-     * we just move the content pointer, but also make sure\n-     * the perceived buffer size has shrunk accordingly\n-     *\/\n+        \/*\n+         * we just move the content pointer, but also make sure\n+         * the perceived buffer size has shrunk accordingly\n+         *\/\n@@ -402,1 +402,1 @@\n-    buf->size -= len;\n+        buf->size -= len;\n@@ -405,10 +405,11 @@\n-     * sometimes though it maybe be better to really shrink\n-     * on IO buffers\n-     *\/\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n-        size_t start_buf = buf->content - buf->contentIO;\n-        if (start_buf >= buf->size) {\n-        memmove(buf->contentIO, &buf->content[0], buf->use);\n-        buf->content = buf->contentIO;\n-        buf->content[buf->use] = 0;\n-        buf->size += start_buf;\n+         * sometimes though it maybe be better to really shrink\n+         * on IO buffers\n+         *\/\n+        if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n+            size_t start_buf = buf->content - buf->contentIO;\n+            if (start_buf >= buf->size) {\n+                memmove(buf->contentIO, &buf->content[0], buf->use);\n+                buf->content = buf->contentIO;\n+                buf->content[buf->use] = 0;\n+                buf->size += start_buf;\n+            }\n@@ -416,1 +417,0 @@\n-    }\n@@ -418,2 +418,2 @@\n-    memmove(buf->content, &buf->content[len], buf->use);\n-    buf->content[buf->use] = 0;\n+        memmove(buf->content, &buf->content[len], buf->use);\n+        buf->content[buf->use] = 0;\n@@ -465,2 +465,2 @@\n-     * Used to provide parsing limits\n-     *\/\n+         * Used to provide parsing limits\n+         *\/\n@@ -468,6 +468,6 @@\n-        (buf->size >= XML_MAX_TEXT_LENGTH)) {\n-        xmlBufMemoryError(buf, \"buffer error: text too long\\n\");\n-        return(0);\n-    }\n-    if (size >= XML_MAX_TEXT_LENGTH)\n-        size = XML_MAX_TEXT_LENGTH;\n+            (buf->size >= XML_MAX_TEXT_LENGTH)) {\n+            xmlBufMemoryError(buf, \"buffer error: text too long\\n\");\n+            return(0);\n+        }\n+        if (size >= XML_MAX_TEXT_LENGTH)\n+            size = XML_MAX_TEXT_LENGTH;\n@@ -478,7 +478,7 @@\n-    newbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);\n-    if (newbuf == NULL) {\n-        xmlBufMemoryError(buf, \"growing buffer\");\n-        return(0);\n-    }\n-    buf->contentIO = newbuf;\n-    buf->content = newbuf + start_buf;\n+        newbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);\n+        if (newbuf == NULL) {\n+            xmlBufMemoryError(buf, \"growing buffer\");\n+            return(0);\n+        }\n+        buf->contentIO = newbuf;\n+        buf->content = newbuf + start_buf;\n@@ -486,6 +486,6 @@\n-    newbuf = (xmlChar *) xmlRealloc(buf->content, size);\n-    if (newbuf == NULL) {\n-        xmlBufMemoryError(buf, \"growing buffer\");\n-        return(0);\n-    }\n-    buf->content = newbuf;\n+        newbuf = (xmlChar *) xmlRealloc(buf->content, size);\n+        if (newbuf == NULL) {\n+            xmlBufMemoryError(buf, \"growing buffer\");\n+            return(0);\n+        }\n+        buf->content = newbuf;\n@@ -554,1 +554,1 @@\n-        \"xmlBufDump: buf == NULL or in error\\n\");\n+                \"xmlBufDump: buf == NULL or in error\\n\");\n@@ -556,1 +556,1 @@\n-    return(0);\n+        return(0);\n@@ -561,1 +561,1 @@\n-        \"xmlBufDump: buf->content == NULL\\n\");\n+                \"xmlBufDump: buf->content == NULL\\n\");\n@@ -563,1 +563,1 @@\n-    return(0);\n+        return(0);\n@@ -567,1 +567,1 @@\n-    file = stdout;\n+        file = stdout;\n@@ -758,2 +758,2 @@\n-     * Used to provide parsing limits\n-     *\/\n+         * Used to provide parsing limits\n+         *\/\n@@ -761,3 +761,3 @@\n-        xmlBufMemoryError(buf, \"buffer error: text too long\\n\");\n-        return(0);\n-    }\n+            xmlBufMemoryError(buf, \"buffer error: text too long\\n\");\n+            return(0);\n+        }\n@@ -772,8 +772,10 @@\n-    case XML_BUFFER_ALLOC_IO:\n-    case XML_BUFFER_ALLOC_DOUBLEIT:\n-        \/*take care of empty case*\/\n-        newSize = (buf->size ? buf->size*2 : size + 10);\n-        while (size > newSize) {\n-            if (newSize > UINT_MAX \/ 2) {\n-                xmlBufMemoryError(buf, \"growing buffer\");\n-                return 0;\n+        case XML_BUFFER_ALLOC_IO:\n+        case XML_BUFFER_ALLOC_DOUBLEIT:\n+            \/*take care of empty case*\/\n+            newSize = (buf->size ? buf->size*2 : size + 10);\n+            while (size > newSize) {\n+                if (newSize > UINT_MAX \/ 2) {\n+                    xmlBufMemoryError(buf, \"growing buffer\");\n+                    return 0;\n+                }\n+                newSize *= 2;\n@@ -781,6 +783,4 @@\n-            newSize *= 2;\n-        }\n-        break;\n-    case XML_BUFFER_ALLOC_EXACT:\n-        newSize = size+10;\n-        break;\n+            break;\n+        case XML_BUFFER_ALLOC_EXACT:\n+            newSize = size+10;\n+            break;\n@@ -802,3 +802,3 @@\n-    default:\n-        newSize = size+10;\n-        break;\n+        default:\n+            newSize = size+10;\n+            break;\n@@ -811,10 +811,13 @@\n-        \/* move data back to start *\/\n-        memmove(buf->contentIO, buf->content, buf->use);\n-        buf->content = buf->contentIO;\n-        buf->content[buf->use] = 0;\n-        buf->size += start_buf;\n-    } else {\n-        rebuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + newSize);\n-        if (rebuf == NULL) {\n-        xmlBufMemoryError(buf, \"growing buffer\");\n-        return 0;\n+            \/* move data back to start *\/\n+            memmove(buf->contentIO, buf->content, buf->use);\n+            buf->content = buf->contentIO;\n+            buf->content[buf->use] = 0;\n+            buf->size += start_buf;\n+        } else {\n+            rebuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + newSize);\n+            if (rebuf == NULL) {\n+                xmlBufMemoryError(buf, \"growing buffer\");\n+                return 0;\n+            }\n+            buf->contentIO = rebuf;\n+            buf->content = rebuf + start_buf;\n@@ -822,3 +825,0 @@\n-        buf->contentIO = rebuf;\n-        buf->content = rebuf + start_buf;\n-    }\n@@ -826,4 +826,4 @@\n-    if (buf->content == NULL) {\n-        rebuf = (xmlChar *) xmlMallocAtomic(newSize);\n-    } else if (buf->size - buf->use < 100) {\n-        rebuf = (xmlChar *) xmlRealloc(buf->content, newSize);\n+        if (buf->content == NULL) {\n+            rebuf = (xmlChar *) xmlMallocAtomic(newSize);\n+        } else if (buf->size - buf->use < 100) {\n+            rebuf = (xmlChar *) xmlRealloc(buf->content, newSize);\n@@ -831,10 +831,11 @@\n-        \/*\n-         * if we are reallocating a buffer far from being full, it's\n-         * better to make a new allocation and copy only the used range\n-         * and free the old one.\n-         *\/\n-        rebuf = (xmlChar *) xmlMallocAtomic(newSize);\n-        if (rebuf != NULL) {\n-        memcpy(rebuf, buf->content, buf->use);\n-        xmlFree(buf->content);\n-        rebuf[buf->use] = 0;\n+            \/*\n+             * if we are reallocating a buffer far from being full, it's\n+             * better to make a new allocation and copy only the used range\n+             * and free the old one.\n+             *\/\n+            rebuf = (xmlChar *) xmlMallocAtomic(newSize);\n+            if (rebuf != NULL) {\n+                memcpy(rebuf, buf->content, buf->use);\n+                xmlFree(buf->content);\n+                rebuf[buf->use] = 0;\n+            }\n@@ -842,6 +843,5 @@\n-    }\n-    if (rebuf == NULL) {\n-        xmlBufMemoryError(buf, \"growing buffer\");\n-        return 0;\n-    }\n-    buf->content = rebuf;\n+        if (rebuf == NULL) {\n+            xmlBufMemoryError(buf, \"growing buffer\");\n+            return 0;\n+        }\n+        buf->content = rebuf;\n@@ -872,1 +872,1 @@\n-    return -1;\n+        return -1;\n@@ -879,1 +879,1 @@\n-        \"xmlBufAdd: len < 0\\n\");\n+                \"xmlBufAdd: len < 0\\n\");\n@@ -881,1 +881,1 @@\n-    return -1;\n+        return -1;\n@@ -893,7 +893,8 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {\n-        \/*\n-         * Used to provide parsing limits\n-         *\/\n-        if (needSize >= XML_MAX_TEXT_LENGTH) {\n-        xmlBufMemoryError(buf, \"buffer error: text too long\\n\");\n-        return(-1);\n+        if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {\n+            \/*\n+             * Used to provide parsing limits\n+             *\/\n+            if (needSize >= XML_MAX_TEXT_LENGTH) {\n+                xmlBufMemoryError(buf, \"buffer error: text too long\\n\");\n+                return(-1);\n+            }\n@@ -901,1 +902,0 @@\n-    }\n@@ -903,1 +903,1 @@\n-        xmlBufMemoryError(buf, \"growing buffer\");\n+            xmlBufMemoryError(buf, \"growing buffer\");\n@@ -938,1 +938,1 @@\n-        \"xmlBufAddHead: str == NULL\\n\");\n+                \"xmlBufAddHead: str == NULL\\n\");\n@@ -940,1 +940,1 @@\n-    return -1;\n+        return -1;\n@@ -945,1 +945,1 @@\n-        \"xmlBufAddHead: len < 0\\n\");\n+                \"xmlBufAddHead: len < 0\\n\");\n@@ -947,1 +947,1 @@\n-    return -1;\n+        return -1;\n@@ -959,5 +959,5 @@\n-    if (start_buf > (unsigned int) len) {\n-        \/*\n-         * We can add it in the space previously shrunk\n-         *\/\n-        buf->content -= len;\n+        if (start_buf > (unsigned int) len) {\n+            \/*\n+             * We can add it in the space previously shrunk\n+             *\/\n+            buf->content -= len;\n@@ -965,5 +965,5 @@\n-        buf->use += len;\n-        buf->size += len;\n-        UPDATE_COMPAT(buf)\n-        return(0);\n-    }\n+            buf->use += len;\n+            buf->size += len;\n+            UPDATE_COMPAT(buf)\n+            return(0);\n+        }\n@@ -973,7 +973,8 @@\n-    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {\n-        \/*\n-         * Used to provide parsing limits\n-         *\/\n-        if (needSize >= XML_MAX_TEXT_LENGTH) {\n-        xmlBufMemoryError(buf, \"buffer error: text too long\\n\");\n-        return(-1);\n+        if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {\n+            \/*\n+             * Used to provide parsing limits\n+             *\/\n+            if (needSize >= XML_MAX_TEXT_LENGTH) {\n+                xmlBufMemoryError(buf, \"buffer error: text too long\\n\");\n+                return(-1);\n+            }\n@@ -981,1 +982,0 @@\n-    }\n@@ -983,1 +983,1 @@\n-        xmlBufMemoryError(buf, \"growing buffer\");\n+            xmlBufMemoryError(buf, \"growing buffer\");\n@@ -1037,1 +1037,1 @@\n-        \"xmlBufCCat: str == NULL\\n\");\n+                \"xmlBufCCat: str == NULL\\n\");\n@@ -1039,1 +1039,1 @@\n-    return -1;\n+        return -1;\n@@ -1044,1 +1044,1 @@\n-        xmlBufMemoryError(buf, \"growing buffer\");\n+                xmlBufMemoryError(buf, \"growing buffer\");\n@@ -1121,1 +1121,1 @@\n-        xmlGenericError(xmlGenericErrorContext,\n+            xmlGenericError(xmlGenericErrorContext,\n@@ -1124,1 +1124,1 @@\n-        xmlBufCCat(buf, \"\\\"\");\n+            xmlBufCCat(buf, \"\\\"\");\n@@ -1140,2 +1140,2 @@\n-        xmlBufCCat(buf, \"\\\"\");\n-    }\n+            xmlBufCCat(buf, \"\\\"\");\n+        }\n@@ -1143,1 +1143,1 @@\n-        xmlBufCCat(buf, \"\\'\");\n+            xmlBufCCat(buf, \"\\'\");\n@@ -1145,1 +1145,1 @@\n-        xmlBufCCat(buf, \"\\'\");\n+            xmlBufCCat(buf, \"\\'\");\n@@ -1175,1 +1175,1 @@\n-    xmlBufMemoryError(NULL, \"creating buffer\");\n+        xmlBufMemoryError(NULL, \"creating buffer\");\n@@ -1263,1 +1263,1 @@\n-    xmlBufferFree(buffer);\n+        xmlBufferFree(buffer);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/buf.c","additions":172,"deletions":172,"binary":false,"changes":344,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- *      validation APIs\n+ *              validation APIs\n@@ -100,1 +100,1 @@\n-    {197, 0, xmlIsBaseChar_srng, (xmlChLRangePtr)0};\n+        {197, 0, xmlIsBaseChar_srng, (xmlChLRangePtr)0};\n@@ -106,1 +106,1 @@\n-    {2, 1, xmlIsChar_srng, xmlIsChar_lrng};\n+        {2, 1, xmlIsChar_srng, xmlIsChar_lrng};\n@@ -134,1 +134,1 @@\n-    {95, 0, xmlIsCombining_srng, (xmlChLRangePtr)0};\n+        {95, 0, xmlIsCombining_srng, (xmlChLRangePtr)0};\n@@ -142,1 +142,1 @@\n-    {14, 0, xmlIsDigit_srng, (xmlChLRangePtr)0};\n+        {14, 0, xmlIsDigit_srng, (xmlChLRangePtr)0};\n@@ -149,1 +149,1 @@\n-    {10, 0, xmlIsExtender_srng, (xmlChLRangePtr)0};\n+        {10, 0, xmlIsExtender_srng, (xmlChLRangePtr)0};\n@@ -154,1 +154,1 @@\n-    {3, 0, xmlIsIdeographic_srng, (xmlChLRangePtr)0};\n+        {3, 0, xmlIsIdeographic_srng, (xmlChLRangePtr)0};\n@@ -174,15 +174,17 @@\n-    if (val < 0x10000) {    \/* is val in 'short' or 'long'  array? *\/\n-    if (rptr->nbShortRange == 0)\n-        return 0;\n-    low = 0;\n-    high = rptr->nbShortRange - 1;\n-    sptr = rptr->shortRange;\n-    while (low <= high) {\n-        mid = (low + high) \/ 2;\n-        if ((unsigned short) val < sptr[mid].low) {\n-        high = mid - 1;\n-        } else {\n-            if ((unsigned short) val > sptr[mid].high) {\n-            low = mid + 1;\n-        } else {\n-            return 1;\n+    if (val < 0x10000) {        \/* is val in 'short' or 'long'  array? *\/\n+        if (rptr->nbShortRange == 0)\n+            return 0;\n+        low = 0;\n+        high = rptr->nbShortRange - 1;\n+        sptr = rptr->shortRange;\n+        while (low <= high) {\n+            mid = (low + high) \/ 2;\n+            if ((unsigned short) val < sptr[mid].low) {\n+                high = mid - 1;\n+            } else {\n+                if ((unsigned short) val > sptr[mid].high) {\n+                    low = mid + 1;\n+                } else {\n+                    return 1;\n+                }\n+            }\n@@ -190,2 +192,0 @@\n-        }\n-    }\n@@ -193,15 +193,2 @@\n-    if (rptr->nbLongRange == 0) {\n-        return 0;\n-    }\n-    low = 0;\n-    high = rptr->nbLongRange - 1;\n-    lptr = rptr->longRange;\n-    while (low <= high) {\n-        mid = (low + high) \/ 2;\n-        if (val < lptr[mid].low) {\n-        high = mid - 1;\n-        } else {\n-            if (val > lptr[mid].high) {\n-            low = mid + 1;\n-        } else {\n-            return 1;\n+        if (rptr->nbLongRange == 0) {\n+            return 0;\n@@ -209,0 +196,14 @@\n+        low = 0;\n+        high = rptr->nbLongRange - 1;\n+        lptr = rptr->longRange;\n+        while (low <= high) {\n+            mid = (low + high) \/ 2;\n+            if (val < lptr[mid].low) {\n+                high = mid - 1;\n+            } else {\n+                if (val > lptr[mid].high) {\n+                    low = mid + 1;\n+                } else {\n+                    return 1;\n+                }\n+            }\n@@ -211,1 +212,0 @@\n-    }\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/chvalid.c","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -24,1 +24,2 @@\n-\/* Define to 1 if you have the <dirent.h> header file. *\/\n+\/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.\n+   *\/\n@@ -63,6 +64,0 @@\n-\/* Define if isinf is there *\/\n-#undef HAVE_ISINF\n-\n-\/* Define if isnan is there *\/\n-#undef HAVE_ISNAN\n-\n@@ -72,3 +67,0 @@\n-\/* Define if pthread library is there (-lpthread) *\/\n-#undef HAVE_LIBPTHREAD\n-\n@@ -93,3 +85,0 @@\n-\/* Define to 1 if you have the <memory.h> header file. *\/\n-#undef HAVE_MEMORY_H\n-\n@@ -167,0 +156,3 @@\n+\/* Define to 1 if you have the <stdio.h> header file. *\/\n+#undef HAVE_STDIO_H\n+\n@@ -265,1 +257,3 @@\n-\/* Define to 1 if you have the ANSI C header files. *\/\n+\/* Define to 1 if all of the C90 standard headers exist (not just the ones\n+   required in a freestanding environment). This macro is provided for\n+   backward compatibility; new code need not use it. *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/config.h.in","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-m4_define([MICRO_VERSION], 12)\n+m4_define([MICRO_VERSION], 13)\n@@ -24,15 +24,1 @@\n-if test -f CVS\/Entries ; then\n-  extra=`grep ChangeLog CVS\/Entries | grep -v LIBXML | sed -e s\\%\/ChangeLog\/1\\.%% -e s\\%\/.*$%%`\n-  echo extra=$extra\n-  if test \"$extra\" != \"\"\n-  then\n-      LIBXML_VERSION_EXTRA=\"-CVS$extra\"\n-  fi\n-else if test -d .svn ; then\n-  extra=`svn info | grep Revision | sed 's+Revision: ++'`\n-  echo extra=$extra\n-  if test \"$extra\" != \"\"\n-  then\n-      LIBXML_VERSION_EXTRA=\"-SVN$extra\"\n-  fi\n-else if test -d .git ; then\n+if test -d .git ; then\n@@ -46,2 +32,1 @@\n-fi\n-fi\n+\n@@ -127,2 +112,2 @@\n-            [path to base html directory, default $datadir\/doc\/html]),\n-            [HTML_DIR=$withval], [HTML_DIR='$(datadir)\/doc'])\n+            [path to base html directory, default $docdir\/html]),\n+            [HTML_DIR=$withval], [HTML_DIR='$(docdir)\/html'])\n@@ -131,3 +116,2 @@\n-            [directory used under html-dir, default $PACKAGE-$VERSION\/html]),\n-            [test \"x$withval\" != \"x\" && HTML_DIR=\"$HTML_DIR\/$withval\"],\n-            [HTML_DIR=\"$HTML_DIR\/\\$(PACKAGE)-\\$(VERSION)\/html\"])\n+            [directory used under html-dir, default '']),\n+            [test \"x$withval\" != \"x\" && HTML_DIR=\"$HTML_DIR\/$withval\"])\n@@ -478,1 +462,0 @@\n-AC_CHECK_HEADERS([dirent.h])\n@@ -744,7 +727,0 @@\n-dnl Checks for isnan in libm if not in libc\n-AC_CHECK_FUNC(isnan, AC_DEFINE([HAVE_ISNAN],[], [Define if isnan is there]) , AC_CHECK_LIB(m, isnan,\n-  [AC_DEFINE([HAVE_ISNAN],[], [Define if isnan is there])]))\n-\n-AC_CHECK_FUNC(isinf, AC_DEFINE([HAVE_ISINF], [], [Define if isinf is there]) , AC_CHECK_LIB(m, isinf,\n-  [AC_DEFINE([HAVE_ISINF], [], [Define if isinf is there])]))\n-\n@@ -903,1 +879,1 @@\n-\t\tPYTHON_SITE_PACKAGES=`$PYTHON -c \"from distutils import sysconfig; print(sysconfig.get_python_lib())\"`\n+\t\tPYTHON_SITE_PACKAGES=$($PYTHON -c 'from distutils import sysconfig; print(sysconfig.get_python_lib(True,False,\"${exec_prefix}\"))')\n@@ -1066,1 +1042,0 @@\n-                AC_DEFINE([HAVE_LIBPTHREAD], [], [Define if pthread library is there (-lpthread)])\n@@ -1704,2 +1679,0 @@\n-AC_SUBST(HAVE_ISNAN)\n-AC_SUBST(HAVE_ISINF)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/configure.ac","additions":8,"deletions":35,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -253,3 +253,3 @@\n-    if ((size_t)(pool->end - pool->free) > namelen)\n-        goto found_pool;\n-    if (pool->size > size) size = pool->size;\n+        if ((size_t)(pool->end - pool->free) > namelen)\n+            goto found_pool;\n+        if (pool->size > size) size = pool->size;\n@@ -257,1 +257,1 @@\n-    pool = pool->next;\n+        pool = pool->next;\n@@ -268,1 +268,1 @@\n-    else size *= 4; \/* exponential growth *\/\n+        else size *= 4; \/* exponential growth *\/\n@@ -270,10 +270,10 @@\n-        size = 4 * namelen; \/* just in case ! *\/\n-    pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);\n-    if (pool == NULL)\n-        return(NULL);\n-    pool->size = size;\n-    pool->nbStrings = 0;\n-    pool->free = &pool->array[0];\n-    pool->end = &pool->array[size];\n-    pool->next = dict->strings;\n-    dict->strings = pool;\n+            size = 4 * namelen; \/* just in case ! *\/\n+        pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);\n+        if (pool == NULL)\n+            return(NULL);\n+        pool->size = size;\n+        pool->nbStrings = 0;\n+        pool->free = &pool->array[0];\n+        pool->end = &pool->array[size];\n+        pool->next = dict->strings;\n+        dict->strings = pool;\n@@ -321,3 +321,3 @@\n-    if ((size_t)(pool->end - pool->free) > namelen + plen + 1)\n-        goto found_pool;\n-    if (pool->size > size) size = pool->size;\n+        if ((size_t)(pool->end - pool->free) > namelen + plen + 1)\n+            goto found_pool;\n+        if (pool->size > size) size = pool->size;\n@@ -325,1 +325,1 @@\n-    pool = pool->next;\n+        pool = pool->next;\n@@ -336,1 +336,1 @@\n-    else size *= 4; \/* exponential growth *\/\n+        else size *= 4; \/* exponential growth *\/\n@@ -338,10 +338,10 @@\n-        size = 4 * (namelen + plen + 1); \/* just in case ! *\/\n-    pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);\n-    if (pool == NULL)\n-        return(NULL);\n-    pool->size = size;\n-    pool->nbStrings = 0;\n-    pool->free = &pool->array[0];\n-    pool->end = &pool->array[size];\n-    pool->next = dict->strings;\n-    dict->strings = pool;\n+            size = 4 * (namelen + plen + 1); \/* just in case ! *\/\n+        pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);\n+        if (pool == NULL)\n+            return(NULL);\n+        pool->size = size;\n+        pool->nbStrings = 0;\n+        pool->free = &pool->array[0];\n+        pool->end = &pool->array[size];\n+        pool->next = dict->strings;\n+        dict->strings = pool;\n@@ -389,2 +389,2 @@\n-    hash += (hash << 10);\n-    hash ^= (hash >> 6);\n+        hash += (hash << 10);\n+        hash ^= (hash >> 6);\n@@ -424,2 +424,2 @@\n-    hash += (hash << 10);\n-    hash ^= (hash >> 6);\n+        hash += (hash << 10);\n+        hash ^= (hash >> 6);\n@@ -433,2 +433,2 @@\n-    hash += (hash << 10);\n-    hash ^= (hash >> 6);\n+        hash += (hash << 10);\n+        hash ^= (hash >> 6);\n@@ -500,1 +500,1 @@\n-    value += 30 * (unsigned long) ':';\n+        value += 30 * (unsigned long) ':';\n@@ -502,1 +502,1 @@\n-    value += 30 * (*prefix);\n+        value += 30 * (*prefix);\n@@ -506,3 +506,3 @@\n-    if (offset < 0)\n-        offset = len - (10 + 1);\n-    value += name[offset];\n+        if (offset < 0)\n+            offset = len - (10 + 1);\n+        value += name[offset];\n@@ -510,2 +510,2 @@\n-    if (plen > 10)\n-        plen = 10;\n+        if (plen > 10)\n+            plen = 10;\n@@ -539,1 +539,1 @@\n-    len--;\n+        len--;\n@@ -592,1 +592,1 @@\n-    dict->nbElems = 0;\n+        dict->nbElems = 0;\n@@ -594,2 +594,2 @@\n-    dict->strings = NULL;\n-    dict->subdict = NULL;\n+        dict->strings = NULL;\n+        dict->subdict = NULL;\n@@ -597,1 +597,1 @@\n-        memset(dict->dict, 0, MIN_DICT_SIZE * sizeof(xmlDictEntry));\n+            memset(dict->dict, 0, MIN_DICT_SIZE * sizeof(xmlDictEntry));\n@@ -603,1 +603,1 @@\n-        return(dict);\n+            return(dict);\n@@ -631,1 +631,1 @@\n-    xmlDictReference(dict->subdict);\n+        xmlDictReference(dict->subdict);\n@@ -679,1 +679,1 @@\n-    return(-1);\n+        return(-1);\n@@ -683,1 +683,1 @@\n-    return(-1);\n+        return(-1);\n@@ -698,2 +698,2 @@\n-    dict->dict = olddict;\n-    return(-1);\n+        dict->dict = olddict;\n+        return(-1);\n@@ -705,4 +705,4 @@\n-    a new entry needs to allocated and data copied into it from\n-    the main dict. It is nicer to run through the array twice, first\n-    copying all the elements in the main array (less probability of\n-    allocate) and then the rest, so we only free in the second loop.\n+        a new entry needs to allocated and data copied into it from\n+        the main dict. It is nicer to run through the array twice, first\n+        copying all the elements in the main array (less probability of\n+        allocate) and then the rest, so we only free in the second loop.\n@@ -711,2 +711,2 @@\n-    if (olddict[i].valid == 0)\n-        continue;\n+        if (olddict[i].valid == 0)\n+            continue;\n@@ -714,12 +714,5 @@\n-    if (keep_keys)\n-        okey = olddict[i].okey;\n-    else\n-        okey = xmlDictComputeKey(dict, olddict[i].name, olddict[i].len);\n-    key = okey % dict->size;\n-\n-    if (dict->dict[key].valid == 0) {\n-        memcpy(&(dict->dict[key]), &(olddict[i]), sizeof(xmlDictEntry));\n-        dict->dict[key].next = NULL;\n-        dict->dict[key].okey = okey;\n-    } else {\n-        xmlDictEntryPtr entry;\n+        if (keep_keys)\n+            okey = olddict[i].okey;\n+        else\n+            okey = xmlDictComputeKey(dict, olddict[i].name, olddict[i].len);\n+        key = okey % dict->size;\n@@ -727,8 +720,4 @@\n-        entry = xmlMalloc(sizeof(xmlDictEntry));\n-        if (entry != NULL) {\n-        entry->name = olddict[i].name;\n-        entry->len = olddict[i].len;\n-        entry->okey = okey;\n-        entry->next = dict->dict[key].next;\n-        entry->valid = 1;\n-        dict->dict[key].next = entry;\n+        if (dict->dict[key].valid == 0) {\n+            memcpy(&(dict->dict[key]), &(olddict[i]), sizeof(xmlDictEntry));\n+            dict->dict[key].next = NULL;\n+            dict->dict[key].okey = okey;\n@@ -736,5 +725,17 @@\n-            \/*\n-         * we don't have much ways to alert from here\n-         * result is losing an entry and unicity guarantee\n-         *\/\n-            ret = -1;\n+            xmlDictEntryPtr entry;\n+\n+            entry = xmlMalloc(sizeof(xmlDictEntry));\n+            if (entry != NULL) {\n+                entry->name = olddict[i].name;\n+                entry->len = olddict[i].len;\n+                entry->okey = okey;\n+                entry->next = dict->dict[key].next;\n+                entry->valid = 1;\n+                dict->dict[key].next = entry;\n+            } else {\n+                \/*\n+                 * we don't have much ways to alert from here\n+                 * result is losing an entry and unicity guarantee\n+                 *\/\n+                ret = -1;\n+            }\n@@ -742,1 +743,0 @@\n-    }\n@@ -744,1 +744,1 @@\n-    nbElem++;\n+        nbElem++;\n@@ -749,7 +749,3 @@\n-    iter = olddict[i].next;\n-    while (iter) {\n-        next = iter->next;\n-\n-        \/*\n-         * put back the entry in the new dict\n-         *\/\n+        iter = olddict[i].next;\n+        while (iter) {\n+            next = iter->next;\n@@ -757,16 +753,20 @@\n-        if (keep_keys)\n-        okey = iter->okey;\n-        else\n-        okey = xmlDictComputeKey(dict, iter->name, iter->len);\n-        key = okey % dict->size;\n-        if (dict->dict[key].valid == 0) {\n-        memcpy(&(dict->dict[key]), iter, sizeof(xmlDictEntry));\n-        dict->dict[key].next = NULL;\n-        dict->dict[key].valid = 1;\n-        dict->dict[key].okey = okey;\n-        xmlFree(iter);\n-        } else {\n-        iter->next = dict->dict[key].next;\n-        iter->okey = okey;\n-        dict->dict[key].next = iter;\n-        }\n+            \/*\n+             * put back the entry in the new dict\n+             *\/\n+\n+            if (keep_keys)\n+                okey = iter->okey;\n+            else\n+                okey = xmlDictComputeKey(dict, iter->name, iter->len);\n+            key = okey % dict->size;\n+            if (dict->dict[key].valid == 0) {\n+                memcpy(&(dict->dict[key]), iter, sizeof(xmlDictEntry));\n+                dict->dict[key].next = NULL;\n+                dict->dict[key].valid = 1;\n+                dict->dict[key].okey = okey;\n+                xmlFree(iter);\n+            } else {\n+                iter->next = dict->dict[key].next;\n+                iter->okey = okey;\n+                dict->dict[key].next = iter;\n+            }\n@@ -775,1 +775,1 @@\n-        nbElem++;\n+            nbElem++;\n@@ -778,2 +778,2 @@\n-        iter = next;\n-    }\n+            iter = next;\n+        }\n@@ -786,1 +786,1 @@\n-        \"xmlDictGrow : from %lu to %lu, %u elems\\n\", oldsize, size, nbElem);\n+            \"xmlDictGrow : from %lu to %lu, %u elems\\n\", oldsize, size, nbElem);\n@@ -808,1 +808,1 @@\n-    return;\n+        return;\n@@ -829,12 +829,13 @@\n-    for(i = 0; ((i < dict->size) && (dict->nbElems > 0)); i++) {\n-        iter = &(dict->dict[i]);\n-        if (iter->valid == 0)\n-        continue;\n-        inside_dict = 1;\n-        while (iter) {\n-        next = iter->next;\n-        if (!inside_dict)\n-            xmlFree(iter);\n-        dict->nbElems--;\n-        inside_dict = 0;\n-        iter = next;\n+        for(i = 0; ((i < dict->size) && (dict->nbElems > 0)); i++) {\n+            iter = &(dict->dict[i]);\n+            if (iter->valid == 0)\n+                continue;\n+            inside_dict = 1;\n+            while (iter) {\n+                next = iter->next;\n+                if (!inside_dict)\n+                    xmlFree(iter);\n+                dict->nbElems--;\n+                inside_dict = 0;\n+                iter = next;\n+            }\n@@ -842,2 +843,1 @@\n-    }\n-    xmlFree(dict->dict);\n+        xmlFree(dict->dict);\n@@ -848,2 +848,2 @@\n-    xmlFree(pool);\n-    pool = nextp;\n+        xmlFree(pool);\n+        pool = nextp;\n@@ -873,1 +873,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -890,1 +890,1 @@\n-    insert = NULL;\n+        insert = NULL;\n@@ -892,2 +892,14 @@\n-    for (insert = &(dict->dict[key]); insert->next != NULL;\n-         insert = insert->next) {\n+        for (insert = &(dict->dict[key]); insert->next != NULL;\n+             insert = insert->next) {\n+#ifdef __GNUC__\n+            if ((insert->okey == okey) && (insert->len == l)) {\n+                if (!memcmp(insert->name, name, l))\n+                    return(insert->name);\n+            }\n+#else\n+            if ((insert->okey == okey) && (insert->len == l) &&\n+                (!xmlStrncmp(insert->name, name, l)))\n+                return(insert->name);\n+#endif\n+            nbi++;\n+        }\n@@ -896,2 +908,2 @@\n-        if (!memcmp(insert->name, name, l))\n-            return(insert->name);\n+            if (!memcmp(insert->name, name, l))\n+                return(insert->name);\n@@ -902,13 +914,1 @@\n-        return(insert->name);\n-#endif\n-        nbi++;\n-    }\n-#ifdef __GNUC__\n-    if ((insert->okey == okey) && (insert->len == l)) {\n-        if (!memcmp(insert->name, name, l))\n-        return(insert->name);\n-    }\n-#else\n-    if ((insert->okey == okey) && (insert->len == l) &&\n-        (!xmlStrncmp(insert->name, name, l)))\n-        return(insert->name);\n+            return(insert->name);\n@@ -923,1 +923,1 @@\n-         (dict->subdict->size != MIN_DICT_SIZE)) ||\n+             (dict->subdict->size != MIN_DICT_SIZE)) ||\n@@ -925,4 +925,4 @@\n-         (dict->subdict->size == MIN_DICT_SIZE)))\n-        skey = xmlDictComputeKey(dict->subdict, name, l);\n-    else\n-        skey = okey;\n+             (dict->subdict->size == MIN_DICT_SIZE)))\n+            skey = xmlDictComputeKey(dict->subdict, name, l);\n+        else\n+            skey = okey;\n@@ -930,3 +930,3 @@\n-    key = skey % dict->subdict->size;\n-    if (dict->subdict->dict[key].valid != 0) {\n-        xmlDictEntryPtr tmp;\n+        key = skey % dict->subdict->size;\n+        if (dict->subdict->dict[key].valid != 0) {\n+            xmlDictEntryPtr tmp;\n@@ -934,2 +934,2 @@\n-        for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;\n-         tmp = tmp->next) {\n+            for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;\n+                 tmp = tmp->next) {\n@@ -937,4 +937,4 @@\n-        if ((tmp->okey == skey) && (tmp->len == l)) {\n-            if (!memcmp(tmp->name, name, l))\n-            return(tmp->name);\n-        }\n+                if ((tmp->okey == skey) && (tmp->len == l)) {\n+                    if (!memcmp(tmp->name, name, l))\n+                        return(tmp->name);\n+                }\n@@ -942,3 +942,3 @@\n-        if ((tmp->okey == skey) && (tmp->len == l) &&\n-            (!xmlStrncmp(tmp->name, name, l)))\n-            return(tmp->name);\n+                if ((tmp->okey == skey) && (tmp->len == l) &&\n+                    (!xmlStrncmp(tmp->name, name, l)))\n+                    return(tmp->name);\n@@ -946,2 +946,2 @@\n-        nbi++;\n-        }\n+                nbi++;\n+            }\n@@ -949,4 +949,4 @@\n-        if ((tmp->okey == skey) && (tmp->len == l)) {\n-        if (!memcmp(tmp->name, name, l))\n-            return(tmp->name);\n-        }\n+            if ((tmp->okey == skey) && (tmp->len == l)) {\n+                if (!memcmp(tmp->name, name, l))\n+                    return(tmp->name);\n+            }\n@@ -954,3 +954,3 @@\n-        if ((tmp->okey == skey) && (tmp->len == l) &&\n-        (!xmlStrncmp(tmp->name, name, l)))\n-        return(tmp->name);\n+            if ((tmp->okey == skey) && (tmp->len == l) &&\n+                (!xmlStrncmp(tmp->name, name, l)))\n+                return(tmp->name);\n@@ -958,2 +958,2 @@\n-    }\n-    key = okey % dict->size;\n+        }\n+        key = okey % dict->size;\n@@ -966,1 +966,1 @@\n-    entry = &(dict->dict[key]);\n+        entry = &(dict->dict[key]);\n@@ -968,3 +968,3 @@\n-    entry = xmlMalloc(sizeof(xmlDictEntry));\n-    if (entry == NULL)\n-         return(NULL);\n+        entry = xmlMalloc(sizeof(xmlDictEntry));\n+        if (entry == NULL)\n+             return(NULL);\n@@ -980,1 +980,1 @@\n-    insert->next = entry;\n+        insert->next = entry;\n@@ -986,2 +986,2 @@\n-    if (xmlDictGrow(dict, MAX_HASH_LEN * 2 * dict->size) != 0)\n-        return(NULL);\n+        if (xmlDictGrow(dict, MAX_HASH_LEN * 2 * dict->size) != 0)\n+            return(NULL);\n@@ -1011,1 +1011,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1027,1 +1027,1 @@\n-    insert = NULL;\n+        insert = NULL;\n@@ -1029,2 +1029,14 @@\n-    for (insert = &(dict->dict[key]); insert->next != NULL;\n-         insert = insert->next) {\n+        for (insert = &(dict->dict[key]); insert->next != NULL;\n+             insert = insert->next) {\n+#ifdef __GNUC__\n+            if ((insert->okey == okey) && (insert->len == l)) {\n+                if (!memcmp(insert->name, name, l))\n+                    return(insert->name);\n+            }\n+#else\n+            if ((insert->okey == okey) && (insert->len == l) &&\n+                (!xmlStrncmp(insert->name, name, l)))\n+                return(insert->name);\n+#endif\n+            nbi++;\n+        }\n@@ -1033,2 +1045,2 @@\n-        if (!memcmp(insert->name, name, l))\n-            return(insert->name);\n+            if (!memcmp(insert->name, name, l))\n+                return(insert->name);\n@@ -1039,13 +1051,1 @@\n-        return(insert->name);\n-#endif\n-        nbi++;\n-    }\n-#ifdef __GNUC__\n-    if ((insert->okey == okey) && (insert->len == l)) {\n-        if (!memcmp(insert->name, name, l))\n-        return(insert->name);\n-    }\n-#else\n-    if ((insert->okey == okey) && (insert->len == l) &&\n-        (!xmlStrncmp(insert->name, name, l)))\n-        return(insert->name);\n+            return(insert->name);\n@@ -1060,1 +1060,1 @@\n-         (dict->subdict->size != MIN_DICT_SIZE)) ||\n+             (dict->subdict->size != MIN_DICT_SIZE)) ||\n@@ -1062,4 +1062,4 @@\n-         (dict->subdict->size == MIN_DICT_SIZE)))\n-        skey = xmlDictComputeKey(dict->subdict, name, l);\n-    else\n-        skey = okey;\n+             (dict->subdict->size == MIN_DICT_SIZE)))\n+            skey = xmlDictComputeKey(dict->subdict, name, l);\n+        else\n+            skey = okey;\n@@ -1067,3 +1067,3 @@\n-    key = skey % dict->subdict->size;\n-    if (dict->subdict->dict[key].valid != 0) {\n-        xmlDictEntryPtr tmp;\n+        key = skey % dict->subdict->size;\n+        if (dict->subdict->dict[key].valid != 0) {\n+            xmlDictEntryPtr tmp;\n@@ -1071,2 +1071,2 @@\n-        for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;\n-         tmp = tmp->next) {\n+            for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;\n+                 tmp = tmp->next) {\n@@ -1074,4 +1074,4 @@\n-        if ((tmp->okey == skey) && (tmp->len == l)) {\n-            if (!memcmp(tmp->name, name, l))\n-            return(tmp->name);\n-        }\n+                if ((tmp->okey == skey) && (tmp->len == l)) {\n+                    if (!memcmp(tmp->name, name, l))\n+                        return(tmp->name);\n+                }\n@@ -1079,3 +1079,3 @@\n-        if ((tmp->okey == skey) && (tmp->len == l) &&\n-            (!xmlStrncmp(tmp->name, name, l)))\n-            return(tmp->name);\n+                if ((tmp->okey == skey) && (tmp->len == l) &&\n+                    (!xmlStrncmp(tmp->name, name, l)))\n+                    return(tmp->name);\n@@ -1083,2 +1083,2 @@\n-        nbi++;\n-        }\n+                nbi++;\n+            }\n@@ -1086,4 +1086,4 @@\n-        if ((tmp->okey == skey) && (tmp->len == l)) {\n-        if (!memcmp(tmp->name, name, l))\n-            return(tmp->name);\n-        }\n+            if ((tmp->okey == skey) && (tmp->len == l)) {\n+                if (!memcmp(tmp->name, name, l))\n+                    return(tmp->name);\n+            }\n@@ -1091,3 +1091,3 @@\n-        if ((tmp->okey == skey) && (tmp->len == l) &&\n-        (!xmlStrncmp(tmp->name, name, l)))\n-        return(tmp->name);\n+            if ((tmp->okey == skey) && (tmp->len == l) &&\n+                (!xmlStrncmp(tmp->name, name, l)))\n+                return(tmp->name);\n@@ -1095,1 +1095,1 @@\n-    }\n+        }\n@@ -1121,1 +1121,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1135,1 +1135,1 @@\n-    insert = NULL;\n+        insert = NULL;\n@@ -1137,2 +1137,7 @@\n-    for (insert = &(dict->dict[key]); insert->next != NULL;\n-         insert = insert->next) {\n+        for (insert = &(dict->dict[key]); insert->next != NULL;\n+             insert = insert->next) {\n+            if ((insert->okey == okey) && (insert->len == len) &&\n+                (xmlStrQEqual(prefix, name, insert->name)))\n+                return(insert->name);\n+            nbi++;\n+        }\n@@ -1141,6 +1146,1 @@\n-        return(insert->name);\n-        nbi++;\n-    }\n-    if ((insert->okey == okey) && (insert->len == len) &&\n-        (xmlStrQEqual(prefix, name, insert->name)))\n-        return(insert->name);\n+            return(insert->name);\n@@ -1154,1 +1154,1 @@\n-         (dict->subdict->size != MIN_DICT_SIZE)) ||\n+             (dict->subdict->size != MIN_DICT_SIZE)) ||\n@@ -1156,14 +1156,18 @@\n-         (dict->subdict->size == MIN_DICT_SIZE)))\n-        skey = xmlDictComputeQKey(dict->subdict, prefix, plen, name, l);\n-    else\n-        skey = okey;\n-\n-    key = skey % dict->subdict->size;\n-    if (dict->subdict->dict[key].valid != 0) {\n-        xmlDictEntryPtr tmp;\n-        for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;\n-         tmp = tmp->next) {\n-        if ((tmp->okey == skey) && (tmp->len == len) &&\n-            (xmlStrQEqual(prefix, name, tmp->name)))\n-            return(tmp->name);\n-        nbi++;\n+             (dict->subdict->size == MIN_DICT_SIZE)))\n+            skey = xmlDictComputeQKey(dict->subdict, prefix, plen, name, l);\n+        else\n+            skey = okey;\n+\n+        key = skey % dict->subdict->size;\n+        if (dict->subdict->dict[key].valid != 0) {\n+            xmlDictEntryPtr tmp;\n+            for (tmp = &(dict->subdict->dict[key]); tmp->next != NULL;\n+                 tmp = tmp->next) {\n+                if ((tmp->okey == skey) && (tmp->len == len) &&\n+                    (xmlStrQEqual(prefix, name, tmp->name)))\n+                    return(tmp->name);\n+                nbi++;\n+            }\n+            if ((tmp->okey == skey) && (tmp->len == len) &&\n+                (xmlStrQEqual(prefix, name, tmp->name)))\n+                return(tmp->name);\n@@ -1171,5 +1175,1 @@\n-        if ((tmp->okey == skey) && (tmp->len == len) &&\n-        (xmlStrQEqual(prefix, name, tmp->name)))\n-        return(tmp->name);\n-    }\n-    key = okey % dict->size;\n+        key = okey % dict->size;\n@@ -1182,1 +1182,1 @@\n-    entry = &(dict->dict[key]);\n+        entry = &(dict->dict[key]);\n@@ -1184,3 +1184,3 @@\n-    entry = xmlMalloc(sizeof(xmlDictEntry));\n-    if (entry == NULL)\n-         return(NULL);\n+        entry = xmlMalloc(sizeof(xmlDictEntry));\n+        if (entry == NULL)\n+             return(NULL);\n@@ -1195,1 +1195,1 @@\n-    insert->next = entry;\n+        insert->next = entry;\n@@ -1201,1 +1201,1 @@\n-    xmlDictGrow(dict, MAX_HASH_LEN * 2 * dict->size);\n+        xmlDictGrow(dict, MAX_HASH_LEN * 2 * dict->size);\n@@ -1222,1 +1222,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1226,2 +1226,2 @@\n-        return(1);\n-    pool = pool->next;\n+            return(1);\n+        pool = pool->next;\n@@ -1246,1 +1246,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1267,1 +1267,1 @@\n-    return(0);\n+        return(0);\n@@ -1288,1 +1288,1 @@\n-    return(0);\n+        return(0);\n@@ -1292,1 +1292,1 @@\n-    pool = pool->next;\n+        pool = pool->next;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/dict.c","additions":274,"deletions":274,"binary":false,"changes":548,"status":"modified"},{"patch":"@@ -7976,0 +7976,12 @@\n+#if defined(LIBXML_OUTPUT_ENABLED)\n+#ifdef bottom_xmlIO\n+#undef xmlPopOutputCallbacks\n+extern __typeof (xmlPopOutputCallbacks) xmlPopOutputCallbacks __attribute((alias(\"xmlPopOutputCallbacks__internal_alias\")));\n+#else\n+#ifndef xmlPopOutputCallbacks\n+extern __typeof (xmlPopOutputCallbacks) xmlPopOutputCallbacks__internal_alias __attribute((visibility(\"hidden\")));\n+#define xmlPopOutputCallbacks xmlPopOutputCallbacks__internal_alias\n+#endif\n+#endif\n+#endif\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/elfgcchack.h","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -156,3 +156,3 @@\n- *                                  *\n- *      Conversions To\/From UTF8 encoding           *\n- *                                  *\n+ *                                                                      *\n+ *              Conversions To\/From UTF8 encoding                       *\n+ *                                                                      *\n@@ -187,1 +187,1 @@\n-    c= *in++;\n+        c= *in++;\n@@ -190,1 +190,1 @@\n-        break;\n+            break;\n@@ -192,6 +192,6 @@\n-        *out++ = c;\n-    } else {\n-        *outlen = out - outstart;\n-        *inlen = processed - base;\n-        return(-1);\n-    }\n+            *out++ = c;\n+        } else {\n+            *outlen = out - outstart;\n+            *inlen = processed - base;\n+            return(-1);\n+        }\n@@ -199,1 +199,1 @@\n-    processed = (const unsigned char*) in;\n+        processed = (const unsigned char*) in;\n@@ -236,5 +236,5 @@\n-     * initialization nothing to do\n-     *\/\n-    *outlen = 0;\n-    *inlen = 0;\n-    return(0);\n+         * initialization nothing to do\n+         *\/\n+        *outlen = 0;\n+        *inlen = 0;\n+        return(0);\n@@ -245,7 +245,7 @@\n-    d = *in++;\n-    if      (d < 0x80)  { c= d; trailing= 0; }\n-    else if (d < 0xC0) {\n-        \/* trailing byte in leading position *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(-2);\n+        d = *in++;\n+        if      (d < 0x80)  { c= d; trailing= 0; }\n+        else if (d < 0xC0) {\n+            \/* trailing byte in leading position *\/\n+            *outlen = out - outstart;\n+            *inlen = processed - instart;\n+            return(-2);\n@@ -255,6 +255,6 @@\n-    else {\n-        \/* no chance for this in Ascii *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(-2);\n-    }\n+        else {\n+            \/* no chance for this in Ascii *\/\n+            *outlen = out - outstart;\n+            *inlen = processed - instart;\n+            return(-2);\n+        }\n@@ -262,3 +262,3 @@\n-    if (inend - in < trailing) {\n-        break;\n-    }\n+        if (inend - in < trailing) {\n+            break;\n+        }\n@@ -266,6 +266,6 @@\n-    for ( ; trailing; trailing--) {\n-        if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))\n-        break;\n-        c <<= 6;\n-        c |= d & 0x3F;\n-    }\n+        for ( ; trailing; trailing--) {\n+            if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))\n+                break;\n+            c <<= 6;\n+            c |= d & 0x3F;\n+        }\n@@ -273,12 +273,12 @@\n-    \/* assertion: c is a single UTF-4 value *\/\n-    if (c < 0x80) {\n-        if (out >= outend)\n-        break;\n-        *out++ = c;\n-    } else {\n-        \/* no chance for this in Ascii *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(-2);\n-    }\n-    processed = in;\n+        \/* assertion: c is a single UTF-4 value *\/\n+        if (c < 0x80) {\n+            if (out >= outend)\n+                break;\n+            *out++ = c;\n+        } else {\n+            \/* no chance for this in Ascii *\/\n+            *outlen = out - outstart;\n+            *inlen = processed - instart;\n+            return(-2);\n+        }\n+        processed = in;\n@@ -316,1 +316,1 @@\n-    return(-1);\n+        return(-1);\n@@ -323,2 +323,2 @@\n-    if (*in >= 0x80) {\n-        *out++ = (((*in) >>  6) & 0x1F) | 0xC0;\n+        if (*in >= 0x80) {\n+            *out++ = (((*in) >>  6) & 0x1F) | 0xC0;\n@@ -326,6 +326,6 @@\n-        ++in;\n-    }\n-    if ((instop - in) > (outend - out)) instop = in + (outend - out);\n-    while ((in < instop) && (*in < 0x80)) {\n-        *out++ = *in++;\n-    }\n+            ++in;\n+        }\n+        if ((instop - in) > (outend - out)) instop = in + (outend - out);\n+        while ((in < instop) && (*in < 0x80)) {\n+            *out++ = *in++;\n+        }\n@@ -361,1 +361,1 @@\n-    return(-1);\n+        return(-1);\n@@ -369,1 +369,1 @@\n-    len = *inlenb;\n+        len = *inlenb;\n@@ -371,1 +371,1 @@\n-    len = *outlen;\n+        len = *outlen;\n@@ -374,1 +374,1 @@\n-    return(-1);\n+        return(-1);\n@@ -420,5 +420,5 @@\n-     * initialization nothing to do\n-     *\/\n-    *outlen = 0;\n-    *inlen = 0;\n-    return(0);\n+         * initialization nothing to do\n+         *\/\n+        *outlen = 0;\n+        *inlen = 0;\n+        return(0);\n@@ -429,7 +429,7 @@\n-    d = *in++;\n-    if      (d < 0x80)  { c= d; trailing= 0; }\n-    else if (d < 0xC0) {\n-        \/* trailing byte in leading position *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(-2);\n+        d = *in++;\n+        if      (d < 0x80)  { c= d; trailing= 0; }\n+        else if (d < 0xC0) {\n+            \/* trailing byte in leading position *\/\n+            *outlen = out - outstart;\n+            *inlen = processed - instart;\n+            return(-2);\n@@ -439,6 +439,6 @@\n-    else {\n-        \/* no chance for this in IsoLat1 *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(-2);\n-    }\n+        else {\n+            \/* no chance for this in IsoLat1 *\/\n+            *outlen = out - outstart;\n+            *inlen = processed - instart;\n+            return(-2);\n+        }\n@@ -446,3 +446,3 @@\n-    if (inend - in < trailing) {\n-        break;\n-    }\n+        if (inend - in < trailing) {\n+            break;\n+        }\n@@ -450,7 +450,10 @@\n-    for ( ; trailing; trailing--) {\n-        if (in >= inend)\n-        break;\n-        if (((d= *in++) & 0xC0) != 0x80) {\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(-2);\n+        for ( ; trailing; trailing--) {\n+            if (in >= inend)\n+                break;\n+            if (((d= *in++) & 0xC0) != 0x80) {\n+                *outlen = out - outstart;\n+                *inlen = processed - instart;\n+                return(-2);\n+            }\n+            c <<= 6;\n+            c |= d & 0x3F;\n@@ -458,3 +461,0 @@\n-        c <<= 6;\n-        c |= d & 0x3F;\n-    }\n@@ -462,12 +462,12 @@\n-    \/* assertion: c is a single UTF-4 value *\/\n-    if (c <= 0xFF) {\n-        if (out >= outend)\n-        break;\n-        *out++ = c;\n-    } else {\n-        \/* no chance for this in IsoLat1 *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(-2);\n-    }\n-    processed = in;\n+        \/* assertion: c is a single UTF-4 value *\/\n+        if (c <= 0xFF) {\n+            if (out >= outend)\n+                break;\n+            *out++ = c;\n+        } else {\n+            \/* no chance for this in IsoLat1 *\/\n+            *outlen = out - outstart;\n+            *inlen = processed - instart;\n+            return(-2);\n+        }\n+        processed = in;\n@@ -522,13 +522,1 @@\n-        c= *in++;\n-    } else {\n-        tmp = (unsigned char *) in;\n-        c = *tmp++;\n-        c = c | (((unsigned int)*tmp) << 8);\n-        in++;\n-    }\n-        if ((c & 0xFC00) == 0xD800) {    \/* surrogates *\/\n-        if (in >= inend) {           \/* (in > inend) shouldn't happens *\/\n-        break;\n-        }\n-        if (xmlLittleEndian) {\n-        d = *in++;\n+            c= *in++;\n@@ -536,4 +524,4 @@\n-        tmp = (unsigned char *) in;\n-        d = *tmp++;\n-        d = d | (((unsigned int)*tmp) << 8);\n-        in++;\n+            tmp = (unsigned char *) in;\n+            c = *tmp++;\n+            c = c | (((unsigned int)*tmp) << 8);\n+            in++;\n@@ -541,0 +529,12 @@\n+        if ((c & 0xFC00) == 0xD800) {    \/* surrogates *\/\n+            if (in >= inend) {           \/* handle split mutli-byte characters *\/\n+                break;\n+            }\n+            if (xmlLittleEndian) {\n+                d = *in++;\n+            } else {\n+                tmp = (unsigned char *) in;\n+                d = *tmp++;\n+                d = d | (((unsigned int)*tmp) << 8);\n+                in++;\n+            }\n@@ -548,4 +548,4 @@\n-        *outlen = out - outstart;\n-        *inlenb = processed - inb;\n-            return(-2);\n-        }\n+                *outlen = out - outstart;\n+                *inlenb = processed - inb;\n+                return(-2);\n+            }\n@@ -554,1 +554,1 @@\n-    \/* assertion: c is a single UTF-4 value *\/\n+        \/* assertion: c is a single UTF-4 value *\/\n@@ -556,1 +556,1 @@\n-        break;\n+            break;\n@@ -564,1 +564,1 @@\n-            break;\n+                break;\n@@ -567,1 +567,1 @@\n-    processed = (const unsigned char*) in;\n+        processed = (const unsigned char*) in;\n@@ -606,3 +606,3 @@\n-    *outlen = 0;\n-    *inlen = 0;\n-    return(0);\n+        *outlen = 0;\n+        *inlen = 0;\n+        return(0);\n@@ -617,3 +617,3 @@\n-      *outlen = (out - outstart) * 2;\n-      *inlen = processed - instart;\n-      return(-2);\n+          *outlen = (out - outstart) * 2;\n+          *inlen = processed - instart;\n+          return(-2);\n@@ -624,4 +624,4 @@\n-    \/* no chance for this in UTF-16 *\/\n-    *outlen = (out - outstart) * 2;\n-    *inlen = processed - instart;\n-    return(-2);\n+        \/* no chance for this in UTF-16 *\/\n+        *outlen = (out - outstart) * 2;\n+        *inlen = processed - instart;\n+        return(-2);\n@@ -636,1 +636,1 @@\n-          break;\n+              break;\n@@ -644,9 +644,9 @@\n-            break;\n-        if (xmlLittleEndian) {\n-        *out++ = c;\n-        } else {\n-        tmp = (unsigned char *) out;\n-        *tmp = c ;\n-        *(tmp + 1) = c >> 8 ;\n-        out++;\n-        }\n+                break;\n+            if (xmlLittleEndian) {\n+                *out++ = c;\n+            } else {\n+                tmp = (unsigned char *) out;\n+                *tmp = c ;\n+                *(tmp + 1) = c >> 8 ;\n+                out++;\n+            }\n@@ -656,1 +656,1 @@\n-            break;\n+                break;\n@@ -658,16 +658,16 @@\n-        if (xmlLittleEndian) {\n-        *out++ = 0xD800 | (c >> 10);\n-        *out++ = 0xDC00 | (c & 0x03FF);\n-        } else {\n-        tmp1 = 0xD800 | (c >> 10);\n-        tmp = (unsigned char *) out;\n-        *tmp = (unsigned char) tmp1;\n-        *(tmp + 1) = tmp1 >> 8;\n-        out++;\n-\n-        tmp2 = 0xDC00 | (c & 0x03FF);\n-        tmp = (unsigned char *) out;\n-        *tmp  = (unsigned char) tmp2;\n-        *(tmp + 1) = tmp2 >> 8;\n-        out++;\n-        }\n+            if (xmlLittleEndian) {\n+                *out++ = 0xD800 | (c >> 10);\n+                *out++ = 0xDC00 | (c & 0x03FF);\n+            } else {\n+                tmp1 = 0xD800 | (c >> 10);\n+                tmp = (unsigned char *) out;\n+                *tmp = (unsigned char) tmp1;\n+                *(tmp + 1) = tmp1 >> 8;\n+                out++;\n+\n+                tmp2 = 0xDC00 | (c & 0x03FF);\n+                tmp = (unsigned char *) out;\n+                *tmp  = (unsigned char) tmp2;\n+                *(tmp + 1) = tmp2 >> 8;\n+                out++;\n+            }\n@@ -676,2 +676,2 @@\n-        break;\n-    processed = in;\n+            break;\n+        processed = in;\n@@ -702,3 +702,3 @@\n-    \/*\n-     * initialization, add the Byte Order Mark for UTF-16LE\n-     *\/\n+        \/*\n+         * initialization, add the Byte Order Mark for UTF-16LE\n+         *\/\n@@ -706,4 +706,4 @@\n-        outb[0] = 0xFF;\n-        outb[1] = 0xFE;\n-        *outlen = 2;\n-        *inlen = 0;\n+            outb[0] = 0xFF;\n+            outb[1] = 0xFE;\n+            *outlen = 2;\n+            *inlen = 0;\n@@ -712,1 +712,1 @@\n-            \"Added FFFE Byte Order Mark\\n\");\n+                    \"Added FFFE Byte Order Mark\\n\");\n@@ -714,5 +714,5 @@\n-        return(2);\n-    }\n-    *outlen = 0;\n-    *inlen = 0;\n-    return(0);\n+            return(2);\n+        }\n+        *outlen = 0;\n+        *inlen = 0;\n+        return(0);\n@@ -747,1 +747,1 @@\n-    unsigned char* outend = out + *outlen;\n+    unsigned char* outend;\n@@ -754,0 +754,5 @@\n+    if (*outlen == 0) {\n+        *inlenb = 0;\n+        return(0);\n+    }\n+    outend = out + *outlen;\n@@ -758,16 +763,1 @@\n-    while (in < inend) {\n-    if (xmlLittleEndian) {\n-        tmp = (unsigned char *) in;\n-        c = *tmp++;\n-        c = c << 8;\n-        c = c | (unsigned int) *tmp;\n-        in++;\n-    } else {\n-        c= *in++;\n-    }\n-        if ((c & 0xFC00) == 0xD800) {    \/* surrogates *\/\n-        if (in >= inend) {           \/* (in > inend) shouldn't happens *\/\n-        *outlen = out - outstart;\n-        *inlenb = processed - inb;\n-            return(-2);\n-        }\n+    while ((in < inend) && (out - outstart + 5 < *outlen)) {\n@@ -775,5 +765,4 @@\n-        tmp = (unsigned char *) in;\n-        d = *tmp++;\n-        d = d << 8;\n-        d = d | (unsigned int) *tmp;\n-        in++;\n+            tmp = (unsigned char *) in;\n+            c = *tmp++;\n+            c = (c << 8) | (unsigned int) *tmp;\n+            in++;\n@@ -781,1 +770,1 @@\n-        d= *in++;\n+            c= *in++;\n@@ -783,0 +772,12 @@\n+        if ((c & 0xFC00) == 0xD800) {    \/* surrogates *\/\n+            if (in >= inend) {           \/* handle split mutli-byte characters *\/\n+                break;\n+            }\n+            if (xmlLittleEndian) {\n+                tmp = (unsigned char *) in;\n+                d = *tmp++;\n+                d = (d << 8) | (unsigned int) *tmp;\n+                in++;\n+            } else {\n+                d= *in++;\n+            }\n@@ -790,4 +791,4 @@\n-        *outlen = out - outstart;\n-        *inlenb = processed - inb;\n-            return(-2);\n-        }\n+                *outlen = out - outstart;\n+                *inlenb = processed - inb;\n+                return(-2);\n+            }\n@@ -796,1 +797,1 @@\n-    \/* assertion: c is a single UTF-4 value *\/\n+        \/* assertion: c is a single UTF-4 value *\/\n@@ -798,1 +799,1 @@\n-        break;\n+            break;\n@@ -806,1 +807,1 @@\n-            break;\n+                break;\n@@ -809,1 +810,1 @@\n-    processed = (const unsigned char*) in;\n+        processed = (const unsigned char*) in;\n@@ -848,3 +849,3 @@\n-    *outlen = 0;\n-    *inlen = 0;\n-    return(0);\n+        *outlen = 0;\n+        *inlen = 0;\n+        return(0);\n@@ -859,3 +860,3 @@\n-      *outlen = out - outstart;\n-      *inlen = processed - instart;\n-      return(-2);\n+          *outlen = out - outstart;\n+          *inlen = processed - instart;\n+          return(-2);\n@@ -867,3 +868,3 @@\n-      *outlen = out - outstart;\n-      *inlen = processed - instart;\n-      return(-2);\n+          *outlen = out - outstart;\n+          *inlen = processed - instart;\n+          return(-2);\n@@ -885,8 +886,8 @@\n-        if (xmlLittleEndian) {\n-        tmp = (unsigned char *) out;\n-        *tmp = c >> 8;\n-        *(tmp + 1) = c;\n-        out++;\n-        } else {\n-        *out++ = c;\n-        }\n+            if (xmlLittleEndian) {\n+                tmp = (unsigned char *) out;\n+                *tmp = c >> 8;\n+                *(tmp + 1) = c;\n+                out++;\n+            } else {\n+                *out++ = c;\n+            }\n@@ -897,16 +898,16 @@\n-        if (xmlLittleEndian) {\n-        tmp1 = 0xD800 | (c >> 10);\n-        tmp = (unsigned char *) out;\n-        *tmp = tmp1 >> 8;\n-        *(tmp + 1) = (unsigned char) tmp1;\n-        out++;\n-\n-        tmp2 = 0xDC00 | (c & 0x03FF);\n-        tmp = (unsigned char *) out;\n-        *tmp = tmp2 >> 8;\n-        *(tmp + 1) = (unsigned char) tmp2;\n-        out++;\n-        } else {\n-        *out++ = 0xD800 | (c >> 10);\n-        *out++ = 0xDC00 | (c & 0x03FF);\n-        }\n+            if (xmlLittleEndian) {\n+                tmp1 = 0xD800 | (c >> 10);\n+                tmp = (unsigned char *) out;\n+                *tmp = tmp1 >> 8;\n+                *(tmp + 1) = (unsigned char) tmp1;\n+                out++;\n+\n+                tmp2 = 0xDC00 | (c & 0x03FF);\n+                tmp = (unsigned char *) out;\n+                *tmp = tmp2 >> 8;\n+                *(tmp + 1) = (unsigned char) tmp2;\n+                out++;\n+            } else {\n+                *out++ = 0xD800 | (c >> 10);\n+                *out++ = 0xDC00 | (c & 0x03FF);\n+            }\n@@ -915,2 +916,2 @@\n-        break;\n-    processed = in;\n+            break;\n+        processed = in;\n@@ -925,3 +926,3 @@\n- *                                  *\n- *      Generic encoding handling routines          *\n- *                                  *\n+ *                                                                      *\n+ *              Generic encoding handling routines                      *\n+ *                                                                      *\n@@ -947,29 +948,29 @@\n-    if ((in[0] == 0x00) && (in[1] == 0x00) &&\n-        (in[2] == 0x00) && (in[3] == 0x3C))\n-        return(XML_CHAR_ENCODING_UCS4BE);\n-    if ((in[0] == 0x3C) && (in[1] == 0x00) &&\n-        (in[2] == 0x00) && (in[3] == 0x00))\n-        return(XML_CHAR_ENCODING_UCS4LE);\n-    if ((in[0] == 0x00) && (in[1] == 0x00) &&\n-        (in[2] == 0x3C) && (in[3] == 0x00))\n-        return(XML_CHAR_ENCODING_UCS4_2143);\n-    if ((in[0] == 0x00) && (in[1] == 0x3C) &&\n-        (in[2] == 0x00) && (in[3] == 0x00))\n-        return(XML_CHAR_ENCODING_UCS4_3412);\n-    if ((in[0] == 0x4C) && (in[1] == 0x6F) &&\n-        (in[2] == 0xA7) && (in[3] == 0x94))\n-        return(XML_CHAR_ENCODING_EBCDIC);\n-    if ((in[0] == 0x3C) && (in[1] == 0x3F) &&\n-        (in[2] == 0x78) && (in[3] == 0x6D))\n-        return(XML_CHAR_ENCODING_UTF8);\n-    \/*\n-     * Although not part of the recommendation, we also\n-     * attempt an \"auto-recognition\" of UTF-16LE and\n-     * UTF-16BE encodings.\n-     *\/\n-    if ((in[0] == 0x3C) && (in[1] == 0x00) &&\n-        (in[2] == 0x3F) && (in[3] == 0x00))\n-        return(XML_CHAR_ENCODING_UTF16LE);\n-    if ((in[0] == 0x00) && (in[1] == 0x3C) &&\n-        (in[2] == 0x00) && (in[3] == 0x3F))\n-        return(XML_CHAR_ENCODING_UTF16BE);\n+        if ((in[0] == 0x00) && (in[1] == 0x00) &&\n+            (in[2] == 0x00) && (in[3] == 0x3C))\n+            return(XML_CHAR_ENCODING_UCS4BE);\n+        if ((in[0] == 0x3C) && (in[1] == 0x00) &&\n+            (in[2] == 0x00) && (in[3] == 0x00))\n+            return(XML_CHAR_ENCODING_UCS4LE);\n+        if ((in[0] == 0x00) && (in[1] == 0x00) &&\n+            (in[2] == 0x3C) && (in[3] == 0x00))\n+            return(XML_CHAR_ENCODING_UCS4_2143);\n+        if ((in[0] == 0x00) && (in[1] == 0x3C) &&\n+            (in[2] == 0x00) && (in[3] == 0x00))\n+            return(XML_CHAR_ENCODING_UCS4_3412);\n+        if ((in[0] == 0x4C) && (in[1] == 0x6F) &&\n+            (in[2] == 0xA7) && (in[3] == 0x94))\n+            return(XML_CHAR_ENCODING_EBCDIC);\n+        if ((in[0] == 0x3C) && (in[1] == 0x3F) &&\n+            (in[2] == 0x78) && (in[3] == 0x6D))\n+            return(XML_CHAR_ENCODING_UTF8);\n+        \/*\n+         * Although not part of the recommendation, we also\n+         * attempt an \"auto-recognition\" of UTF-16LE and\n+         * UTF-16BE encodings.\n+         *\/\n+        if ((in[0] == 0x3C) && (in[1] == 0x00) &&\n+            (in[2] == 0x3F) && (in[3] == 0x00))\n+            return(XML_CHAR_ENCODING_UTF16LE);\n+        if ((in[0] == 0x00) && (in[1] == 0x3C) &&\n+            (in[2] == 0x00) && (in[3] == 0x3F))\n+            return(XML_CHAR_ENCODING_UTF16BE);\n@@ -978,7 +979,7 @@\n-    \/*\n-     * Errata on XML-1.0 June 20 2001\n-     * We now allow an UTF8 encoded BOM\n-     *\/\n-    if ((in[0] == 0xEF) && (in[1] == 0xBB) &&\n-        (in[2] == 0xBF))\n-        return(XML_CHAR_ENCODING_UTF8);\n+        \/*\n+         * Errata on XML-1.0 June 20 2001\n+         * We now allow an UTF8 encoded BOM\n+         *\/\n+        if ((in[0] == 0xEF) && (in[1] == 0xBB) &&\n+            (in[2] == 0xBF))\n+            return(XML_CHAR_ENCODING_UTF8);\n@@ -988,4 +989,4 @@\n-    if ((in[0] == 0xFE) && (in[1] == 0xFF))\n-        return(XML_CHAR_ENCODING_UTF16BE);\n-    if ((in[0] == 0xFF) && (in[1] == 0xFE))\n-        return(XML_CHAR_ENCODING_UTF16LE);\n+        if ((in[0] == 0xFE) && (in[1] == 0xFF))\n+            return(XML_CHAR_ENCODING_UTF16BE);\n+        if ((in[0] == 0xFF) && (in[1] == 0xFE))\n+            return(XML_CHAR_ENCODING_UTF16LE);\n@@ -1006,1 +1007,1 @@\n-    return;\n+        return;\n@@ -1009,4 +1010,4 @@\n-    if (xmlCharEncodingAliases[i].name != NULL)\n-        xmlFree((char *) xmlCharEncodingAliases[i].name);\n-    if (xmlCharEncodingAliases[i].alias != NULL)\n-        xmlFree((char *) xmlCharEncodingAliases[i].alias);\n+        if (xmlCharEncodingAliases[i].name != NULL)\n+            xmlFree((char *) xmlCharEncodingAliases[i].name);\n+        if (xmlCharEncodingAliases[i].alias != NULL)\n+            xmlFree((char *) xmlCharEncodingAliases[i].alias);\n@@ -1034,1 +1035,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1037,1 +1038,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1041,1 +1042,1 @@\n-    if (upper[i] == 0) break;\n+        if (upper[i] == 0) break;\n@@ -1049,3 +1050,3 @@\n-    if (!strcmp(xmlCharEncodingAliases[i].alias, upper)) {\n-        return(xmlCharEncodingAliases[i].name);\n-    }\n+        if (!strcmp(xmlCharEncodingAliases[i].alias, upper)) {\n+            return(xmlCharEncodingAliases[i].name);\n+        }\n@@ -1072,1 +1073,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1076,1 +1077,1 @@\n-    if (upper[i] == 0) break;\n+        if (upper[i] == 0) break;\n@@ -1081,6 +1082,6 @@\n-    xmlCharEncodingAliasesNb = 0;\n-    xmlCharEncodingAliasesMax = 20;\n-    xmlCharEncodingAliases = (xmlCharEncodingAliasPtr)\n-          xmlMalloc(xmlCharEncodingAliasesMax * sizeof(xmlCharEncodingAlias));\n-    if (xmlCharEncodingAliases == NULL)\n-        return(-1);\n+        xmlCharEncodingAliasesNb = 0;\n+        xmlCharEncodingAliasesMax = 20;\n+        xmlCharEncodingAliases = (xmlCharEncodingAliasPtr)\n+              xmlMalloc(xmlCharEncodingAliasesMax * sizeof(xmlCharEncodingAlias));\n+        if (xmlCharEncodingAliases == NULL)\n+            return(-1);\n@@ -1088,4 +1089,4 @@\n-    xmlCharEncodingAliasesMax *= 2;\n-    xmlCharEncodingAliases = (xmlCharEncodingAliasPtr)\n-          xmlRealloc(xmlCharEncodingAliases,\n-                 xmlCharEncodingAliasesMax * sizeof(xmlCharEncodingAlias));\n+        xmlCharEncodingAliasesMax *= 2;\n+        xmlCharEncodingAliases = (xmlCharEncodingAliasPtr)\n+              xmlRealloc(xmlCharEncodingAliases,\n+                         xmlCharEncodingAliasesMax * sizeof(xmlCharEncodingAlias));\n@@ -1097,8 +1098,8 @@\n-    if (!strcmp(xmlCharEncodingAliases[i].alias, upper)) {\n-        \/*\n-         * Replace the definition.\n-         *\/\n-        xmlFree((char *) xmlCharEncodingAliases[i].name);\n-        xmlCharEncodingAliases[i].name = xmlMemStrdup(name);\n-        return(0);\n-    }\n+        if (!strcmp(xmlCharEncodingAliases[i].alias, upper)) {\n+            \/*\n+             * Replace the definition.\n+             *\/\n+            xmlFree((char *) xmlCharEncodingAliases[i].name);\n+            xmlCharEncodingAliases[i].name = xmlMemStrdup(name);\n+            return(0);\n+        }\n@@ -1128,1 +1129,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1131,1 +1132,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1136,8 +1137,8 @@\n-    if (!strcmp(xmlCharEncodingAliases[i].alias, alias)) {\n-        xmlFree((char *) xmlCharEncodingAliases[i].name);\n-        xmlFree((char *) xmlCharEncodingAliases[i].alias);\n-        xmlCharEncodingAliasesNb--;\n-        memmove(&xmlCharEncodingAliases[i], &xmlCharEncodingAliases[i + 1],\n-            sizeof(xmlCharEncodingAlias) * (xmlCharEncodingAliasesNb - i));\n-        return(0);\n-    }\n+        if (!strcmp(xmlCharEncodingAliases[i].alias, alias)) {\n+            xmlFree((char *) xmlCharEncodingAliases[i].name);\n+            xmlFree((char *) xmlCharEncodingAliases[i].alias);\n+            xmlCharEncodingAliasesNb--;\n+            memmove(&xmlCharEncodingAliases[i], &xmlCharEncodingAliases[i + 1],\n+                    sizeof(xmlCharEncodingAlias) * (xmlCharEncodingAliasesNb - i));\n+            return(0);\n+        }\n@@ -1167,1 +1168,1 @@\n-    return(XML_CHAR_ENCODING_NONE);\n+        return(XML_CHAR_ENCODING_NONE);\n@@ -1174,1 +1175,1 @@\n-    name = alias;\n+        name = alias;\n@@ -1178,1 +1179,1 @@\n-    if (upper[i] == 0) break;\n+        if (upper[i] == 0) break;\n@@ -1247,1 +1248,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -1249,1 +1250,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -1251,1 +1252,1 @@\n-        return(\"UTF-8\");\n+            return(\"UTF-8\");\n@@ -1253,1 +1254,1 @@\n-        return(\"UTF-16\");\n+            return(\"UTF-16\");\n@@ -1255,1 +1256,1 @@\n-        return(\"UTF-16\");\n+            return(\"UTF-16\");\n@@ -1269,1 +1270,1 @@\n-        return(\"ISO-8859-1\");\n+            return(\"ISO-8859-1\");\n@@ -1271,1 +1272,1 @@\n-        return(\"ISO-8859-2\");\n+            return(\"ISO-8859-2\");\n@@ -1273,1 +1274,1 @@\n-        return(\"ISO-8859-3\");\n+            return(\"ISO-8859-3\");\n@@ -1275,1 +1276,1 @@\n-        return(\"ISO-8859-4\");\n+            return(\"ISO-8859-4\");\n@@ -1277,1 +1278,1 @@\n-        return(\"ISO-8859-5\");\n+            return(\"ISO-8859-5\");\n@@ -1279,1 +1280,1 @@\n-        return(\"ISO-8859-6\");\n+            return(\"ISO-8859-6\");\n@@ -1281,1 +1282,1 @@\n-        return(\"ISO-8859-7\");\n+            return(\"ISO-8859-7\");\n@@ -1283,1 +1284,1 @@\n-        return(\"ISO-8859-8\");\n+            return(\"ISO-8859-8\");\n@@ -1285,1 +1286,1 @@\n-        return(\"ISO-8859-9\");\n+            return(\"ISO-8859-9\");\n@@ -1292,2 +1293,2 @@\n-    case XML_CHAR_ENCODING_ASCII:\n-        return(NULL);\n+        case XML_CHAR_ENCODING_ASCII:\n+            return(NULL);\n@@ -1299,3 +1300,3 @@\n- *                                  *\n- *          Char encoding handlers              *\n- *                                  *\n+ *                                                                      *\n+ *                      Char encoding handlers                          *\n+ *                                                                      *\n@@ -1342,1 +1343,1 @@\n-    name = alias;\n+        name = alias;\n@@ -1349,2 +1350,2 @@\n-               \"xmlNewCharEncodingHandler : no name !\\n\", NULL);\n-    return(NULL);\n+                       \"xmlNewCharEncodingHandler : no name !\\n\", NULL);\n+        return(NULL);\n@@ -1354,1 +1355,1 @@\n-    if (upper[i] == 0) break;\n+        if (upper[i] == 0) break;\n@@ -1360,1 +1361,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1371,1 +1372,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1393,1 +1394,1 @@\n-        \"Registered encoding handler for %s\\n\", name);\n+            \"Registered encoding handler for %s\\n\", name);\n@@ -1420,1 +1421,1 @@\n-                   \"Odd problem at endianness detection\\n\", NULL);\n+                       \"Odd problem at endianness detection\\n\", NULL);\n@@ -1425,1 +1426,1 @@\n-    return;\n+        return;\n@@ -1472,5 +1473,5 @@\n-    if (handlers[nbCharEncodingHandler] != NULL) {\n-        if (handlers[nbCharEncodingHandler]->name != NULL)\n-        xmlFree(handlers[nbCharEncodingHandler]->name);\n-        xmlFree(handlers[nbCharEncodingHandler]);\n-    }\n+        if (handlers[nbCharEncodingHandler] != NULL) {\n+            if (handlers[nbCharEncodingHandler]->name != NULL)\n+                xmlFree(handlers[nbCharEncodingHandler]->name);\n+            xmlFree(handlers[nbCharEncodingHandler]);\n+        }\n@@ -1495,1 +1496,1 @@\n-        \"xmlRegisterCharEncodingHandler: NULL handler !\\n\", NULL);\n+                \"xmlRegisterCharEncodingHandler: NULL handler !\\n\", NULL);\n@@ -1501,2 +1502,2 @@\n-    \"xmlRegisterCharEncodingHandler: Too many handler registered, see %s\\n\",\n-                   \"MAX_ENCODING_HANDLERS\");\n+        \"xmlRegisterCharEncodingHandler: Too many handler registered, see %s\\n\",\n+                       \"MAX_ENCODING_HANDLERS\");\n@@ -1532,1 +1533,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -1534,1 +1535,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -1536,1 +1537,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -1538,1 +1539,1 @@\n-        return(xmlUTF16LEHandler);\n+            return(xmlUTF16LEHandler);\n@@ -1540,1 +1541,1 @@\n-        return(xmlUTF16BEHandler);\n+            return(xmlUTF16BEHandler);\n@@ -1550,1 +1551,1 @@\n-        break;\n+            break;\n@@ -1558,1 +1559,1 @@\n-        break;\n+            break;\n@@ -1566,1 +1567,1 @@\n-        break;\n+            break;\n@@ -1568,1 +1569,1 @@\n-        break;\n+            break;\n@@ -1570,1 +1571,1 @@\n-        break;\n+            break;\n@@ -1578,1 +1579,1 @@\n-        break;\n+            break;\n@@ -1580,6 +1581,6 @@\n-        \/*\n-         * We used to keep ISO Latin encodings native in the\n-         * generated data. This led to so many problems that\n-         * this has been removed. One can still change this\n-         * back by registering no-ops encoders for those\n-         *\/\n+            \/*\n+             * We used to keep ISO Latin encodings native in the\n+             * generated data. This led to so many problems that\n+             * this has been removed. One can still change this\n+             * back by registering no-ops encoders for those\n+             *\/\n@@ -1587,3 +1588,3 @@\n-        handler = xmlFindCharEncodingHandler(\"ISO-8859-1\");\n-        if (handler != NULL) return(handler);\n-        break;\n+            handler = xmlFindCharEncodingHandler(\"ISO-8859-1\");\n+            if (handler != NULL) return(handler);\n+            break;\n@@ -1591,3 +1592,3 @@\n-        handler = xmlFindCharEncodingHandler(\"ISO-8859-2\");\n-        if (handler != NULL) return(handler);\n-        break;\n+            handler = xmlFindCharEncodingHandler(\"ISO-8859-2\");\n+            if (handler != NULL) return(handler);\n+            break;\n@@ -1595,3 +1596,3 @@\n-        handler = xmlFindCharEncodingHandler(\"ISO-8859-3\");\n-        if (handler != NULL) return(handler);\n-        break;\n+            handler = xmlFindCharEncodingHandler(\"ISO-8859-3\");\n+            if (handler != NULL) return(handler);\n+            break;\n@@ -1599,3 +1600,3 @@\n-        handler = xmlFindCharEncodingHandler(\"ISO-8859-4\");\n-        if (handler != NULL) return(handler);\n-        break;\n+            handler = xmlFindCharEncodingHandler(\"ISO-8859-4\");\n+            if (handler != NULL) return(handler);\n+            break;\n@@ -1603,3 +1604,3 @@\n-        handler = xmlFindCharEncodingHandler(\"ISO-8859-5\");\n-        if (handler != NULL) return(handler);\n-        break;\n+            handler = xmlFindCharEncodingHandler(\"ISO-8859-5\");\n+            if (handler != NULL) return(handler);\n+            break;\n@@ -1607,3 +1608,3 @@\n-        handler = xmlFindCharEncodingHandler(\"ISO-8859-6\");\n-        if (handler != NULL) return(handler);\n-        break;\n+            handler = xmlFindCharEncodingHandler(\"ISO-8859-6\");\n+            if (handler != NULL) return(handler);\n+            break;\n@@ -1611,3 +1612,3 @@\n-        handler = xmlFindCharEncodingHandler(\"ISO-8859-7\");\n-        if (handler != NULL) return(handler);\n-        break;\n+            handler = xmlFindCharEncodingHandler(\"ISO-8859-7\");\n+            if (handler != NULL) return(handler);\n+            break;\n@@ -1615,3 +1616,3 @@\n-        handler = xmlFindCharEncodingHandler(\"ISO-8859-8\");\n-        if (handler != NULL) return(handler);\n-        break;\n+            handler = xmlFindCharEncodingHandler(\"ISO-8859-8\");\n+            if (handler != NULL) return(handler);\n+            break;\n@@ -1619,3 +1620,3 @@\n-        handler = xmlFindCharEncodingHandler(\"ISO-8859-9\");\n-        if (handler != NULL) return(handler);\n-        break;\n+            handler = xmlFindCharEncodingHandler(\"ISO-8859-9\");\n+            if (handler != NULL) return(handler);\n+            break;\n@@ -1627,1 +1628,1 @@\n-        break;\n+            break;\n@@ -1635,1 +1636,1 @@\n-        break;\n+            break;\n@@ -1639,3 +1640,3 @@\n-        break;\n-    default:\n-        break;\n+            break;\n+        default:\n+            break;\n@@ -1646,1 +1647,1 @@\n-        \"No handler found for encoding %d\\n\", enc);\n+            \"No handler found for encoding %d\\n\", enc);\n@@ -1685,1 +1686,1 @@\n-    name = nalias;\n+        name = nalias;\n@@ -1692,1 +1693,1 @@\n-    if (upper[i] == 0) break;\n+        if (upper[i] == 0) break;\n@@ -1716,1 +1717,1 @@\n-    icv_out = iconv_open(upper, \"UTF-8\");\n+        icv_out = iconv_open(upper, \"UTF-8\");\n@@ -1719,7 +1720,7 @@\n-        enc = (xmlCharEncodingHandlerPtr)\n-              xmlMalloc(sizeof(xmlCharEncodingHandler));\n-        if (enc == NULL) {\n-            iconv_close(icv_in);\n-            iconv_close(icv_out);\n-        return(NULL);\n-        }\n+            enc = (xmlCharEncodingHandlerPtr)\n+                  xmlMalloc(sizeof(xmlCharEncodingHandler));\n+            if (enc == NULL) {\n+                iconv_close(icv_in);\n+                iconv_close(icv_out);\n+                return(NULL);\n+            }\n@@ -1727,5 +1728,5 @@\n-        enc->name = xmlMemStrdup(name);\n-        enc->input = NULL;\n-        enc->output = NULL;\n-        enc->iconv_in = icv_in;\n-        enc->iconv_out = icv_out;\n+            enc->name = xmlMemStrdup(name);\n+            enc->input = NULL;\n+            enc->output = NULL;\n+            enc->iconv_in = icv_in;\n+            enc->iconv_out = icv_out;\n@@ -1734,1 +1735,1 @@\n-            \"Found iconv handler for encoding %s\\n\", name);\n+                    \"Found iconv handler for encoding %s\\n\", name);\n@@ -1736,1 +1737,1 @@\n-        return enc;\n+            return enc;\n@@ -1738,2 +1739,2 @@\n-        xmlEncodingErr(XML_ERR_INTERNAL_ERROR,\n-            \"iconv : problems with filters for '%s'\\n\", name);\n+            xmlEncodingErr(XML_ERR_INTERNAL_ERROR,\n+                    \"iconv : problems with filters for '%s'\\n\", name);\n@@ -1747,3 +1748,3 @@\n-        encu = (xmlCharEncodingHandlerPtr)\n-               xmlMalloc(sizeof(xmlCharEncodingHandler));\n-        if (encu == NULL) {\n+            encu = (xmlCharEncodingHandlerPtr)\n+                   xmlMalloc(sizeof(xmlCharEncodingHandler));\n+            if (encu == NULL) {\n@@ -1752,2 +1753,2 @@\n-        return(NULL);\n-        }\n+                return(NULL);\n+            }\n@@ -1755,5 +1756,5 @@\n-        encu->name = xmlMemStrdup(name);\n-        encu->input = NULL;\n-        encu->output = NULL;\n-        encu->uconv_in = ucv_in;\n-        encu->uconv_out = ucv_out;\n+            encu->name = xmlMemStrdup(name);\n+            encu->input = NULL;\n+            encu->output = NULL;\n+            encu->uconv_in = ucv_in;\n+            encu->uconv_out = ucv_out;\n@@ -1762,1 +1763,1 @@\n-            \"Found ICU converter handler for encoding %s\\n\", name);\n+                    \"Found ICU converter handler for encoding %s\\n\", name);\n@@ -1764,1 +1765,1 @@\n-        return encu;\n+            return encu;\n@@ -1768,2 +1769,2 @@\n-        xmlEncodingErr(XML_ERR_INTERNAL_ERROR,\n-            \"ICU converter : problems with filters for '%s'\\n\", name);\n+            xmlEncodingErr(XML_ERR_INTERNAL_ERROR,\n+                    \"ICU converter : problems with filters for '%s'\\n\", name);\n@@ -1775,1 +1776,1 @@\n-        \"No handler found for encoding %s\\n\", name);\n+            \"No handler found for encoding %s\\n\", name);\n@@ -1786,1 +1787,1 @@\n-        return(xmlFindCharEncodingHandler(canon));\n+            return(xmlFindCharEncodingHandler(canon));\n@@ -1795,3 +1796,3 @@\n- *                                  *\n- *      ICONV based generic conversion functions        *\n- *                                  *\n+ *                                                                      *\n+ *              ICONV based generic conversion functions                *\n+ *                                                                      *\n@@ -1803,1 +1804,1 @@\n- * @cd:     iconv converter data structure\n+ * @cd:         iconv converter data structure\n@@ -1825,1 +1826,1 @@\n-    int ret;\n+    size_t ret;\n@@ -1836,1 +1837,1 @@\n-    if ((icv_inlen != 0) || (ret == -1)) {\n+    if ((icv_inlen != 0) || (ret == (size_t) -1)) {\n@@ -1861,3 +1862,3 @@\n- *                                  *\n- *      ICU based generic conversion functions      *\n- *                                  *\n+ *                                                                      *\n+ *              ICU based generic conversion functions          *\n+ *                                                                      *\n@@ -1929,3 +1930,3 @@\n- *                                  *\n- *      The real API used by libxml for on-the-fly conversion   *\n- *                                  *\n+ *                                                                      *\n+ *              The real API used by libxml for on-the-fly conversion   *\n+ *                                                                      *\n@@ -2079,1 +2080,1 @@\n-    written = out->size - out->use - 1;\n+        written = out->size - out->use - 1;\n@@ -2092,4 +2093,4 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"converted %d bytes to %d bytes of input\\n\",\n-                toconv, written);\n-        break;\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"converted %d bytes to %d bytes of input\\n\",\n+                    toconv, written);\n+            break;\n@@ -2097,3 +2098,3 @@\n-        xmlGenericError(xmlGenericErrorContext,\"converted %d bytes to %d bytes of input, %d left\\n\",\n-                toconv, written, in->use);\n-        break;\n+            xmlGenericError(xmlGenericErrorContext,\"converted %d bytes to %d bytes of input, %d left\\n\",\n+                    toconv, written, in->use);\n+            break;\n@@ -2101,3 +2102,3 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"input conversion failed due to input error\\n\");\n-        break;\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"input conversion failed due to input error\\n\");\n+            break;\n@@ -2105,5 +2106,5 @@\n-        xmlGenericError(xmlGenericErrorContext,\"converted %d bytes to %d bytes of input, %d left\\n\",\n-                toconv, written, in->use);\n-        break;\n-    default:\n-        xmlGenericError(xmlGenericErrorContext,\"Unknown input conversion failed %d\\n\", ret);\n+            xmlGenericError(xmlGenericErrorContext,\"converted %d bytes to %d bytes of input, %d left\\n\",\n+                    toconv, written, in->use);\n+            break;\n+        default:\n+            xmlGenericError(xmlGenericErrorContext,\"Unknown input conversion failed %d\\n\", ret);\n@@ -2233,7 +2234,7 @@\n-        snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\",\n-             content[0], content[1],\n-             content[2], content[3]);\n-        buf[49] = 0;\n-        xmlEncodingErr(XML_I18N_CONV_FAILED,\n-            \"input conversion failed due to input error, bytes %s\\n\",\n-                   buf);\n+            snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\",\n+                     content[0], content[1],\n+                     content[2], content[3]);\n+            buf[49] = 0;\n+            xmlEncodingErr(XML_I18N_CONV_FAILED,\n+                    \"input conversion failed due to input error, bytes %s\\n\",\n+                           buf);\n@@ -2331,7 +2332,7 @@\n-        snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\",\n-             content[0], content[1],\n-             content[2], content[3]);\n-        buf[49] = 0;\n-        xmlEncodingErr(XML_I18N_CONV_FAILED,\n-            \"input conversion failed due to input error, bytes %s\\n\",\n-                   buf);\n+            snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\",\n+                     content[0], content[1],\n+                     content[2], content[3]);\n+            buf[49] = 0;\n+            xmlEncodingErr(XML_I18N_CONV_FAILED,\n+                    \"input conversion failed due to input error, bytes %s\\n\",\n+                           buf);\n@@ -2417,7 +2418,7 @@\n-        snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\",\n-             in->content[0], in->content[1],\n-             in->content[2], in->content[3]);\n-        buf[49] = 0;\n-        xmlEncodingErr(XML_I18N_CONV_FAILED,\n-            \"input conversion failed due to input error, bytes %s\\n\",\n-                   buf);\n+            snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\",\n+                     in->content[0], in->content[1],\n+                     in->content[2], in->content[3]);\n+            buf[49] = 0;\n+            xmlEncodingErr(XML_I18N_CONV_FAILED,\n+                    \"input conversion failed due to input error, bytes %s\\n\",\n+                           buf);\n@@ -2487,2 +2488,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"initialized encoder\\n\");\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"initialized encoder\\n\");\n@@ -2498,1 +2499,1 @@\n-        return (0);\n+        return (writtentot);\n@@ -2529,3 +2530,3 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"converted %d bytes to %d bytes of output\\n\",\n-                c_in, c_out);\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"converted %d bytes to %d bytes of output\\n\",\n+                    c_in, c_out);\n@@ -2533,1 +2534,1 @@\n-        break;\n+            break;\n@@ -2536,2 +2537,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"output conversion failed by lack of space\\n\");\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"output conversion failed by lack of space\\n\");\n@@ -2539,1 +2540,1 @@\n-        break;\n+            break;\n@@ -2542,2 +2543,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\"converted %d bytes to %d bytes of output %d left\\n\",\n-                c_in, c_out, (int) xmlBufUse(in));\n+            xmlGenericError(xmlGenericErrorContext,\"converted %d bytes to %d bytes of output %d left\\n\",\n+                    c_in, c_out, (int) xmlBufUse(in));\n@@ -2545,1 +2546,1 @@\n-        break;\n+            break;\n@@ -2552,2 +2553,2 @@\n-        xmlChar charref[20];\n-        int len = (int) xmlBufUse(in);\n+            xmlChar charref[20];\n+            int len = (int) xmlBufUse(in);\n@@ -2555,1 +2556,1 @@\n-        int cur, charrefLen;\n+            int cur, charrefLen;\n@@ -2557,2 +2558,2 @@\n-        cur = xmlGetUTF8Char(content, &len);\n-        if (cur <= 0)\n+            cur = xmlGetUTF8Char(content, &len);\n+            if (cur <= 0)\n@@ -2583,12 +2584,12 @@\n-        if ((ret < 0) || (c_in != charrefLen)) {\n-        char buf[50];\n-\n-        snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\",\n-             content[0], content[1],\n-             content[2], content[3]);\n-        buf[49] = 0;\n-        xmlEncodingErr(XML_I18N_CONV_FAILED,\n-            \"output conversion failed due to conv error, bytes %s\\n\",\n-                   buf);\n-        if (xmlBufGetAllocationScheme(in) != XML_BUFFER_ALLOC_IMMUTABLE)\n-            content[0] = ' ';\n+            if ((ret < 0) || (c_in != charrefLen)) {\n+                char buf[50];\n+\n+                snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\",\n+                         content[0], content[1],\n+                         content[2], content[3]);\n+                buf[49] = 0;\n+                xmlEncodingErr(XML_I18N_CONV_FAILED,\n+                    \"output conversion failed due to conv error, bytes %s\\n\",\n+                               buf);\n+                if (xmlBufGetAllocationScheme(in) != XML_BUFFER_ALLOC_IMMUTABLE)\n+                    content[0] = ' ';\n@@ -2596,1 +2597,1 @@\n-        }\n+            }\n@@ -2601,1 +2602,1 @@\n-    }\n+        }\n@@ -2632,1 +2633,0 @@\n-    int output = 0;\n@@ -2642,1 +2642,1 @@\n-    written--; \/* Gennady: count '\/0' *\/\n+        written--; \/* Gennady: count '\/0' *\/\n@@ -2655,2 +2655,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"initialized encoder\\n\");\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"initialized encoder\\n\");\n@@ -2666,1 +2666,1 @@\n-    return(0);\n+        return(0);\n@@ -2669,1 +2669,1 @@\n-    written = out->size - out->use - 1;\n+        written = out->size - out->use - 1;\n@@ -2685,2 +2685,0 @@\n-    if (ret >= 0) output += ret;\n-\n@@ -2693,3 +2691,3 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"converted %d bytes to %d bytes of output\\n\",\n-                toconv, written);\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"converted %d bytes to %d bytes of output\\n\",\n+                    toconv, written);\n@@ -2697,1 +2695,1 @@\n-        break;\n+            break;\n@@ -2700,2 +2698,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"output conversion failed by lack of space\\n\");\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"output conversion failed by lack of space\\n\");\n@@ -2703,1 +2701,1 @@\n-        break;\n+            break;\n@@ -2706,2 +2704,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\"converted %d bytes to %d bytes of output %d left\\n\",\n-                toconv, written, in->use);\n+            xmlGenericError(xmlGenericErrorContext,\"converted %d bytes to %d bytes of output %d left\\n\",\n+                    toconv, written, in->use);\n@@ -2709,1 +2707,1 @@\n-        break;\n+            break;\n@@ -2711,3 +2709,3 @@\n-        xmlEncodingErr(XML_I18N_NO_OUTPUT,\n-                   \"xmlCharEncOutFunc: no output function !\\n\", NULL);\n-        ret = -1;\n+            xmlEncodingErr(XML_I18N_NO_OUTPUT,\n+                           \"xmlCharEncOutFunc: no output function !\\n\", NULL);\n+            ret = -1;\n@@ -2716,4 +2714,4 @@\n-        xmlChar charref[20];\n-        int len = in->use;\n-        const xmlChar *utf = (const xmlChar *) in->content;\n-        int cur, charrefLen;\n+            xmlChar charref[20];\n+            int len = in->use;\n+            const xmlChar *utf = (const xmlChar *) in->content;\n+            int cur, charrefLen;\n@@ -2721,2 +2719,2 @@\n-        cur = xmlGetUTF8Char(utf, &len);\n-        if (cur <= 0)\n+            cur = xmlGetUTF8Char(utf, &len);\n+            if (cur <= 0)\n@@ -2742,1 +2740,1 @@\n-        written = out->size - out->use - 1;\n+            written = out->size - out->use - 1;\n@@ -2747,14 +2745,14 @@\n-        if ((ret < 0) || (toconv != charrefLen)) {\n-        char buf[50];\n-\n-        snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\",\n-             in->content[0], in->content[1],\n-             in->content[2], in->content[3]);\n-        buf[49] = 0;\n-        xmlEncodingErr(XML_I18N_CONV_FAILED,\n-            \"output conversion failed due to conv error, bytes %s\\n\",\n-                   buf);\n-        if (in->alloc != XML_BUFFER_ALLOC_IMMUTABLE)\n-            in->content[0] = ' ';\n-            break;\n-        }\n+            if ((ret < 0) || (toconv != charrefLen)) {\n+                char buf[50];\n+\n+                snprintf(&buf[0], 49, \"0x%02X 0x%02X 0x%02X 0x%02X\",\n+                         in->content[0], in->content[1],\n+                         in->content[2], in->content[3]);\n+                buf[49] = 0;\n+                xmlEncodingErr(XML_I18N_CONV_FAILED,\n+                    \"output conversion failed due to conv error, bytes %s\\n\",\n+                               buf);\n+                if (in->alloc != XML_BUFFER_ALLOC_IMMUTABLE)\n+                    in->content[0] = ' ';\n+                break;\n+            }\n@@ -2766,1 +2764,1 @@\n-    }\n+        }\n@@ -2790,2 +2788,3 @@\n-            handler_in_list = 1;\n-        break;\n+                handler_in_list = 1;\n+                break;\n+            }\n@@ -2794,1 +2793,0 @@\n-    }\n@@ -2803,10 +2801,10 @@\n-    if (handler->iconv_out != NULL) {\n-        if (iconv_close(handler->iconv_out))\n-        ret = -1;\n-        handler->iconv_out = NULL;\n-    }\n-    if (handler->iconv_in != NULL) {\n-        if (iconv_close(handler->iconv_in))\n-        ret = -1;\n-        handler->iconv_in = NULL;\n-    }\n+        if (handler->iconv_out != NULL) {\n+            if (iconv_close(handler->iconv_out))\n+                ret = -1;\n+            handler->iconv_out = NULL;\n+        }\n+        if (handler->iconv_in != NULL) {\n+            if (iconv_close(handler->iconv_in))\n+                ret = -1;\n+            handler->iconv_in = NULL;\n+        }\n@@ -2819,8 +2817,8 @@\n-    if (handler->uconv_out != NULL) {\n-        closeIcuConverter(handler->uconv_out);\n-        handler->uconv_out = NULL;\n-    }\n-    if (handler->uconv_in != NULL) {\n-        closeIcuConverter(handler->uconv_in);\n-        handler->uconv_in = NULL;\n-    }\n+        if (handler->uconv_out != NULL) {\n+            closeIcuConverter(handler->uconv_out);\n+            handler->uconv_out = NULL;\n+        }\n+        if (handler->uconv_in != NULL) {\n+            closeIcuConverter(handler->uconv_in);\n+            handler->uconv_in = NULL;\n+        }\n@@ -2839,1 +2837,1 @@\n-        \"failed to close the encoding handler\\n\");\n+                \"failed to close the encoding handler\\n\");\n@@ -2842,1 +2840,1 @@\n-        \"closed the encoding handler\\n\");\n+                \"closed the encoding handler\\n\");\n@@ -2871,1 +2869,1 @@\n-    xmlCharEncodingHandler * handler = in->buf->encoder;\n+        xmlCharEncodingHandler * handler = in->buf->encoder;\n@@ -2873,4 +2871,4 @@\n-     * Encoding conversion, compute the number of unused original\n-     * bytes from the input not consumed and subtract that from\n-     * the raw consumed value, this is not a cheap operation\n-     *\/\n+         * Encoding conversion, compute the number of unused original\n+         * bytes from the input not consumed and subtract that from\n+         * the raw consumed value, this is not a cheap operation\n+         *\/\n@@ -2878,3 +2876,3 @@\n-        unsigned char convbuf[32000];\n-        const unsigned char *cur = (const unsigned char *)in->cur;\n-        int toconv = in->end - in->cur, written = 32000;\n+            unsigned char convbuf[32000];\n+            const unsigned char *cur = (const unsigned char *)in->cur;\n+            int toconv = in->end - in->cur, written = 32000;\n@@ -2882,1 +2880,1 @@\n-        int ret;\n+            int ret;\n@@ -2898,4 +2896,4 @@\n-    }\n-    if (in->buf->rawconsumed < unused)\n-        return(-1);\n-    return(in->buf->rawconsumed - unused);\n+        }\n+        if (in->buf->rawconsumed < unused)\n+            return(-1);\n+        return(in->buf->rawconsumed - unused);\n@@ -2936,1 +2934,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3005,3 +3003,3 @@\n-        d = d & 0x0F;\n-        d = xlattable [48 + c2 + xlattable [48 + c1 +\n-            xlattable [32 + d] * 64] * 64];\n+            d = d & 0x0F;\n+            d = xlattable [48 + c2 + xlattable [48 + c1 +\n+                        xlattable [32 + d] * 64] * 64];\n@@ -3054,1 +3052,1 @@\n-    return(-1);\n+        return(-1);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/encoding.c","additions":621,"deletions":623,"binary":false,"changes":1244,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-        (!xmlDictOwns(dict, entity->ExternalID)))\n+            (!xmlDictOwns(dict, entity->ExternalID)))\n@@ -122,1 +122,1 @@\n-        (!xmlDictOwns(dict, entity->SystemID)))\n+            (!xmlDictOwns(dict, entity->SystemID)))\n@@ -155,2 +155,2 @@\n-            const xmlChar *ExternalID, const xmlChar *SystemID,\n-            const xmlChar *content) {\n+                const xmlChar *ExternalID, const xmlChar *SystemID,\n+                const xmlChar *content) {\n@@ -162,1 +162,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -173,5 +173,5 @@\n-    ret->name = xmlStrdup(name);\n-    if (ExternalID != NULL)\n-        ret->ExternalID = xmlStrdup(ExternalID);\n-    if (SystemID != NULL)\n-        ret->SystemID = xmlStrdup(SystemID);\n+        ret->name = xmlStrdup(name);\n+        if (ExternalID != NULL)\n+            ret->ExternalID = xmlStrdup(ExternalID);\n+        if (SystemID != NULL)\n+            ret->SystemID = xmlStrdup(SystemID);\n@@ -180,4 +180,4 @@\n-    if (ExternalID != NULL)\n-        ret->ExternalID = xmlDictLookup(dict, ExternalID, -1);\n-    if (SystemID != NULL)\n-        ret->SystemID = xmlDictLookup(dict, SystemID, -1);\n+        if (ExternalID != NULL)\n+            ret->ExternalID = xmlDictLookup(dict, ExternalID, -1);\n+        if (SystemID != NULL)\n+            ret->SystemID = xmlDictLookup(dict, SystemID, -1);\n@@ -187,5 +187,5 @@\n-    if ((dict != NULL) && (ret->length < 5))\n-        ret->content = (xmlChar *)\n-                       xmlDictLookup(dict, content, ret->length);\n-    else\n-        ret->content = xmlStrndup(content, ret->length);\n+        if ((dict != NULL) && (ret->length < 5))\n+            ret->content = (xmlChar *)\n+                           xmlDictLookup(dict, content, ret->length);\n+        else\n+            ret->content = xmlStrndup(content, ret->length);\n@@ -197,1 +197,1 @@\n-            the defining entity *\/\n+                        the defining entity *\/\n@@ -209,2 +209,2 @@\n-      const xmlChar *ExternalID, const xmlChar *SystemID,\n-      const xmlChar *content) {\n+          const xmlChar *ExternalID, const xmlChar *SystemID,\n+          const xmlChar *content) {\n@@ -216,1 +216,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -218,1 +218,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -264,4 +264,4 @@\n-        if (dtd->entities == NULL)\n-        dtd->entities = xmlHashCreateDict(0, dict);\n-        table = dtd->entities;\n-        break;\n+            if (dtd->entities == NULL)\n+                dtd->entities = xmlHashCreateDict(0, dict);\n+            table = dtd->entities;\n+            break;\n@@ -270,4 +270,4 @@\n-        if (dtd->pentities == NULL)\n-        dtd->pentities = xmlHashCreateDict(0, dict);\n-        table = dtd->pentities;\n-        break;\n+            if (dtd->pentities == NULL)\n+                dtd->pentities = xmlHashCreateDict(0, dict);\n+            table = dtd->pentities;\n+            break;\n@@ -275,1 +275,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -278,1 +278,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -285,3 +285,3 @@\n-    \/*\n-     * entity was already defined at another level.\n-     *\/\n+        \/*\n+         * entity was already defined at another level.\n+         *\/\n@@ -289,1 +289,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -307,3 +307,3 @@\n-        if (xmlStrEqual(name, BAD_CAST \"lt\"))\n-            return(&xmlEntityLt);\n-        break;\n+            if (xmlStrEqual(name, BAD_CAST \"lt\"))\n+                return(&xmlEntityLt);\n+            break;\n@@ -311,3 +311,3 @@\n-        if (xmlStrEqual(name, BAD_CAST \"gt\"))\n-            return(&xmlEntityGt);\n-        break;\n+            if (xmlStrEqual(name, BAD_CAST \"gt\"))\n+                return(&xmlEntityGt);\n+            break;\n@@ -315,5 +315,5 @@\n-        if (xmlStrEqual(name, BAD_CAST \"amp\"))\n-            return(&xmlEntityAmp);\n-        if (xmlStrEqual(name, BAD_CAST \"apos\"))\n-            return(&xmlEntityApos);\n-        break;\n+            if (xmlStrEqual(name, BAD_CAST \"amp\"))\n+                return(&xmlEntityAmp);\n+            if (xmlStrEqual(name, BAD_CAST \"apos\"))\n+                return(&xmlEntityApos);\n+            break;\n@@ -321,5 +321,5 @@\n-        if (xmlStrEqual(name, BAD_CAST \"quot\"))\n-            return(&xmlEntityQuot);\n-        break;\n-    default:\n-        break;\n+            if (xmlStrEqual(name, BAD_CAST \"quot\"))\n+                return(&xmlEntityQuot);\n+            break;\n+        default:\n+            break;\n@@ -345,2 +345,2 @@\n-            const xmlChar *ExternalID, const xmlChar *SystemID,\n-        const xmlChar *content) {\n+                const xmlChar *ExternalID, const xmlChar *SystemID,\n+                const xmlChar *content) {\n@@ -351,3 +351,3 @@\n-    xmlEntitiesErr(XML_DTD_NO_DOC,\n-            \"xmlAddDtdEntity: document is NULL\");\n-    return(NULL);\n+        xmlEntitiesErr(XML_DTD_NO_DOC,\n+                \"xmlAddDtdEntity: document is NULL\");\n+        return(NULL);\n@@ -356,3 +356,3 @@\n-    xmlEntitiesErr(XML_DTD_NO_DTD,\n-            \"xmlAddDtdEntity: document without external subset\");\n-    return(NULL);\n+        xmlEntitiesErr(XML_DTD_NO_DTD,\n+                \"xmlAddDtdEntity: document without external subset\");\n+        return(NULL);\n@@ -370,1 +370,1 @@\n-    dtd->children = dtd->last = (xmlNodePtr) ret;\n+        dtd->children = dtd->last = (xmlNodePtr) ret;\n@@ -373,2 +373,2 @@\n-    ret->prev = dtd->last;\n-    dtd->last = (xmlNodePtr) ret;\n+        ret->prev = dtd->last;\n+        dtd->last = (xmlNodePtr) ret;\n@@ -394,2 +394,2 @@\n-            const xmlChar *ExternalID, const xmlChar *SystemID,\n-            const xmlChar *content) {\n+                const xmlChar *ExternalID, const xmlChar *SystemID,\n+                const xmlChar *content) {\n@@ -400,3 +400,3 @@\n-    xmlEntitiesErr(XML_DTD_NO_DOC,\n-            \"xmlAddDocEntity: document is NULL\");\n-    return(NULL);\n+        xmlEntitiesErr(XML_DTD_NO_DOC,\n+                \"xmlAddDocEntity: document is NULL\");\n+        return(NULL);\n@@ -405,3 +405,3 @@\n-    xmlEntitiesErr(XML_DTD_NO_DTD,\n-            \"xmlAddDocEntity: document without internal subset\");\n-    return(NULL);\n+        xmlEntitiesErr(XML_DTD_NO_DTD,\n+                \"xmlAddDocEntity: document without internal subset\");\n+        return(NULL);\n@@ -419,1 +419,1 @@\n-    dtd->children = dtd->last = (xmlNodePtr) ret;\n+        dtd->children = dtd->last = (xmlNodePtr) ret;\n@@ -421,3 +421,3 @@\n-    dtd->last->next = (xmlNodePtr) ret;\n-    ret->prev = dtd->last;\n-    dtd->last = (xmlNodePtr) ret;\n+        dtd->last->next = (xmlNodePtr) ret;\n+        ret->prev = dtd->last;\n+        dtd->last = (xmlNodePtr) ret;\n@@ -447,2 +447,2 @@\n-         const xmlChar *ExternalID, const xmlChar *SystemID,\n-         const xmlChar *content) {\n+             const xmlChar *ExternalID, const xmlChar *SystemID,\n+             const xmlChar *content) {\n@@ -453,1 +453,1 @@\n-    return(xmlAddDocEntity(doc, name, type, ExternalID, SystemID, content));\n+        return(xmlAddDocEntity(doc, name, type, ExternalID, SystemID, content));\n@@ -498,1 +498,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -500,4 +500,4 @@\n-    table = (xmlEntitiesTablePtr) doc->intSubset->pentities;\n-    ret = xmlGetEntityFromTable(table, name);\n-    if (ret != NULL)\n-        return(ret);\n+        table = (xmlEntitiesTablePtr) doc->intSubset->pentities;\n+        ret = xmlGetEntityFromTable(table, name);\n+        if (ret != NULL)\n+            return(ret);\n@@ -506,2 +506,2 @@\n-    table = (xmlEntitiesTablePtr) doc->extSubset->pentities;\n-    return(xmlGetEntityFromTable(table, name));\n+        table = (xmlEntitiesTablePtr) doc->extSubset->pentities;\n+        return(xmlGetEntityFromTable(table, name));\n@@ -528,1 +528,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -530,2 +530,2 @@\n-    table = (xmlEntitiesTablePtr) doc->extSubset->entities;\n-    return(xmlGetEntityFromTable(table, name));\n+        table = (xmlEntitiesTablePtr) doc->extSubset->entities;\n+        return(xmlGetEntityFromTable(table, name));\n@@ -553,13 +553,14 @@\n-    if ((doc->intSubset != NULL) && (doc->intSubset->entities != NULL)) {\n-        table = (xmlEntitiesTablePtr) doc->intSubset->entities;\n-        cur = xmlGetEntityFromTable(table, name);\n-        if (cur != NULL)\n-        return(cur);\n-    }\n-    if (doc->standalone != 1) {\n-        if ((doc->extSubset != NULL) &&\n-        (doc->extSubset->entities != NULL)) {\n-        table = (xmlEntitiesTablePtr) doc->extSubset->entities;\n-        cur = xmlGetEntityFromTable(table, name);\n-        if (cur != NULL)\n-            return(cur);\n+        if ((doc->intSubset != NULL) && (doc->intSubset->entities != NULL)) {\n+            table = (xmlEntitiesTablePtr) doc->intSubset->entities;\n+            cur = xmlGetEntityFromTable(table, name);\n+            if (cur != NULL)\n+                return(cur);\n+        }\n+        if (doc->standalone != 1) {\n+            if ((doc->extSubset != NULL) &&\n+                (doc->extSubset->entities != NULL)) {\n+                table = (xmlEntitiesTablePtr) doc->extSubset->entities;\n+                cur = xmlGetEntityFromTable(table, name);\n+                if (cur != NULL)\n+                    return(cur);\n+            }\n@@ -567,1 +568,0 @@\n-    }\n@@ -575,1 +575,1 @@\n-#define growBufferReentrant() {                     \\\n+#define growBufferReentrant() {                                         \\\n@@ -579,1 +579,1 @@\n-    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                 \\\n+    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                     \\\n@@ -581,2 +581,2 @@\n-    buffer = tmp;                           \\\n-    buffer_size = new_size;                     \\\n+    buffer = tmp;                                                       \\\n+    buffer_size = new_size;                                             \\\n@@ -617,1 +617,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -625,20 +625,0 @@\n-        growBufferReentrant();\n-        out = &buffer[indx];\n-    }\n-\n-    \/*\n-     * By default one have to encode at least '<', '>', '\"' and '&' !\n-     *\/\n-    if (*cur == '<') {\n-        const xmlChar *end;\n-\n-        \/*\n-         * Special handling of server side include in HTML attributes\n-         *\/\n-        if (html && attr &&\n-            (cur[1] == '!') && (cur[2] == '-') && (cur[3] == '-') &&\n-            ((end = xmlStrstr(cur, BAD_CAST \"-->\")) != NULL)) {\n-            while (cur != end) {\n-            *out++ = *cur++;\n-            indx = out - buffer;\n-            if (indx + 100 > buffer_size) {\n@@ -647,6 +627,0 @@\n-            }\n-        }\n-        *out++ = *cur++;\n-        *out++ = *cur++;\n-        *out++ = *cur++;\n-        continue;\n@@ -654,10 +628,1 @@\n-        *out++ = '&';\n-        *out++ = 'l';\n-        *out++ = 't';\n-        *out++ = ';';\n-    } else if (*cur == '>') {\n-        *out++ = '&';\n-        *out++ = 'g';\n-        *out++ = 't';\n-        *out++ = ';';\n-    } else if (*cur == '&') {\n+\n@@ -665,2 +630,1 @@\n-         * Special handling of &{...} construct from HTML 4, see\n-         * http:\/\/www.w3.org\/TR\/html401\/appendix\/notes.html#h-B.7.1\n+         * By default one have to encode at least '<', '>', '\"' and '&' !\n@@ -668,8 +632,21 @@\n-        if (html && attr && (cur[1] == '{') &&\n-            (strchr((const char *) cur, '}'))) {\n-            while (*cur != '}') {\n-            *out++ = *cur++;\n-            indx = out - buffer;\n-            if (indx + 100 > buffer_size) {\n-            growBufferReentrant();\n-            out = &buffer[indx];\n+        if (*cur == '<') {\n+            const xmlChar *end;\n+\n+            \/*\n+             * Special handling of server side include in HTML attributes\n+             *\/\n+            if (html && attr &&\n+                (cur[1] == '!') && (cur[2] == '-') && (cur[3] == '-') &&\n+                ((end = xmlStrstr(cur, BAD_CAST \"-->\")) != NULL)) {\n+                while (cur != end) {\n+                    *out++ = *cur++;\n+                    indx = out - buffer;\n+                    if (indx + 100 > buffer_size) {\n+                        growBufferReentrant();\n+                        out = &buffer[indx];\n+                    }\n+                }\n+                *out++ = *cur++;\n+                *out++ = *cur++;\n+                *out++ = *cur++;\n+                continue;\n@@ -677,60 +654,83 @@\n-        }\n-        *out++ = *cur++;\n-        continue;\n-        }\n-        *out++ = '&';\n-        *out++ = 'a';\n-        *out++ = 'm';\n-        *out++ = 'p';\n-        *out++ = ';';\n-    } else if (((*cur >= 0x20) && (*cur < 0x80)) ||\n-        (*cur == '\\n') || (*cur == '\\t') || ((html) && (*cur == '\\r'))) {\n-        \/*\n-         * default case, just copy !\n-         *\/\n-        *out++ = *cur;\n-    } else if (*cur >= 0x80) {\n-        if (((doc != NULL) && (doc->encoding != NULL)) || (html)) {\n-        \/*\n-         * Bjørn Reese <br@sseusa.com> provided the patch\n-            xmlChar xc;\n-            xc = (*cur & 0x3F) << 6;\n-            if (cur[1] != 0) {\n-            xc += *(++cur) & 0x3F;\n-            *out++ = xc;\n-            } else\n-         *\/\n-        *out++ = *cur;\n-        } else {\n-        \/*\n-         * We assume we have UTF-8 input.\n-         * It must match either:\n-         *   110xxxxx 10xxxxxx\n-         *   1110xxxx 10xxxxxx 10xxxxxx\n-         *   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n-         * That is:\n-         *   cur[0] is 11xxxxxx\n-         *   cur[1] is 10xxxxxx\n-         *   cur[2] is 10xxxxxx if cur[0] is 111xxxxx\n-         *   cur[3] is 10xxxxxx if cur[0] is 1111xxxx\n-         *   cur[0] is not 11111xxx\n-         *\/\n-        char buf[11], *ptr;\n-        int val = 0, l = 1;\n-\n-        if (((cur[0] & 0xC0) != 0xC0) ||\n-            ((cur[1] & 0xC0) != 0x80) ||\n-            (((cur[0] & 0xE0) == 0xE0) && ((cur[2] & 0xC0) != 0x80)) ||\n-            (((cur[0] & 0xF0) == 0xF0) && ((cur[3] & 0xC0) != 0x80)) ||\n-            (((cur[0] & 0xF8) == 0xF8))) {\n-            xmlEntitiesErr(XML_CHECK_NOT_UTF8,\n-                \"xmlEncodeEntities: input not UTF-8\");\n-            if (doc != NULL)\n-            doc->encoding = xmlStrdup(BAD_CAST \"ISO-8859-1\");\n-            snprintf(buf, sizeof(buf), \"&#%d;\", *cur);\n-            buf[sizeof(buf) - 1] = 0;\n-            ptr = buf;\n-            while (*ptr != 0) *out++ = *ptr++;\n-            cur++;\n-            continue;\n-        } else if (*cur < 0xE0) {\n+            *out++ = '&';\n+            *out++ = 'l';\n+            *out++ = 't';\n+            *out++ = ';';\n+        } else if (*cur == '>') {\n+            *out++ = '&';\n+            *out++ = 'g';\n+            *out++ = 't';\n+            *out++ = ';';\n+        } else if (*cur == '&') {\n+            \/*\n+             * Special handling of &{...} construct from HTML 4, see\n+             * http:\/\/www.w3.org\/TR\/html401\/appendix\/notes.html#h-B.7.1\n+             *\/\n+            if (html && attr && (cur[1] == '{') &&\n+                (strchr((const char *) cur, '}'))) {\n+                while (*cur != '}') {\n+                    *out++ = *cur++;\n+                    indx = out - buffer;\n+                    if (indx + 100 > buffer_size) {\n+                        growBufferReentrant();\n+                        out = &buffer[indx];\n+                    }\n+                }\n+                *out++ = *cur++;\n+                continue;\n+            }\n+            *out++ = '&';\n+            *out++ = 'a';\n+            *out++ = 'm';\n+            *out++ = 'p';\n+            *out++ = ';';\n+        } else if (((*cur >= 0x20) && (*cur < 0x80)) ||\n+            (*cur == '\\n') || (*cur == '\\t') || ((html) && (*cur == '\\r'))) {\n+            \/*\n+             * default case, just copy !\n+             *\/\n+            *out++ = *cur;\n+        } else if (*cur >= 0x80) {\n+            if (((doc != NULL) && (doc->encoding != NULL)) || (html)) {\n+                \/*\n+                 * Bjørn Reese <br@sseusa.com> provided the patch\n+                xmlChar xc;\n+                xc = (*cur & 0x3F) << 6;\n+                if (cur[1] != 0) {\n+                    xc += *(++cur) & 0x3F;\n+                    *out++ = xc;\n+                } else\n+                 *\/\n+                *out++ = *cur;\n+            } else {\n+                \/*\n+                 * We assume we have UTF-8 input.\n+                 * It must match either:\n+                 *   110xxxxx 10xxxxxx\n+                 *   1110xxxx 10xxxxxx 10xxxxxx\n+                 *   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n+                 * That is:\n+                 *   cur[0] is 11xxxxxx\n+                 *   cur[1] is 10xxxxxx\n+                 *   cur[2] is 10xxxxxx if cur[0] is 111xxxxx\n+                 *   cur[3] is 10xxxxxx if cur[0] is 1111xxxx\n+                 *   cur[0] is not 11111xxx\n+                 *\/\n+                char buf[11], *ptr;\n+                int val = 0, l = 1;\n+\n+                if (((cur[0] & 0xC0) != 0xC0) ||\n+                    ((cur[1] & 0xC0) != 0x80) ||\n+                    (((cur[0] & 0xE0) == 0xE0) && ((cur[2] & 0xC0) != 0x80)) ||\n+                    (((cur[0] & 0xF0) == 0xF0) && ((cur[3] & 0xC0) != 0x80)) ||\n+                    (((cur[0] & 0xF8) == 0xF8))) {\n+                    xmlEntitiesErr(XML_CHECK_NOT_UTF8,\n+                            \"xmlEncodeEntities: input not UTF-8\");\n+                    if (doc != NULL)\n+                        doc->encoding = xmlStrdup(BAD_CAST \"ISO-8859-1\");\n+                    snprintf(buf, sizeof(buf), \"&#%d;\", *cur);\n+                    buf[sizeof(buf) - 1] = 0;\n+                    ptr = buf;\n+                    while (*ptr != 0) *out++ = *ptr++;\n+                    cur++;\n+                    continue;\n+                } else if (*cur < 0xE0) {\n@@ -738,4 +738,4 @@\n-            val <<= 6;\n-            val |= (cur[1]) & 0x3F;\n-            l = 2;\n-        } else if (*cur < 0xF0) {\n+                    val <<= 6;\n+                    val |= (cur[1]) & 0x3F;\n+                    l = 2;\n+                } else if (*cur < 0xF0) {\n@@ -743,6 +743,6 @@\n-            val <<= 6;\n-            val |= (cur[1]) & 0x3F;\n-            val <<= 6;\n-            val |= (cur[2]) & 0x3F;\n-            l = 3;\n-        } else if (*cur < 0xF8) {\n+                    val <<= 6;\n+                    val |= (cur[1]) & 0x3F;\n+                    val <<= 6;\n+                    val |= (cur[2]) & 0x3F;\n+                    l = 3;\n+                } else if (*cur < 0xF8) {\n@@ -750,13 +750,33 @@\n-            val <<= 6;\n-            val |= (cur[1]) & 0x3F;\n-            val <<= 6;\n-            val |= (cur[2]) & 0x3F;\n-            val <<= 6;\n-            val |= (cur[3]) & 0x3F;\n-            l = 4;\n-        }\n-        if ((l == 1) || (!IS_CHAR(val))) {\n-            xmlEntitiesErr(XML_ERR_INVALID_CHAR,\n-            \"xmlEncodeEntities: char out of range\\n\");\n-            if (doc != NULL)\n-            doc->encoding = xmlStrdup(BAD_CAST \"ISO-8859-1\");\n+                    val <<= 6;\n+                    val |= (cur[1]) & 0x3F;\n+                    val <<= 6;\n+                    val |= (cur[2]) & 0x3F;\n+                    val <<= 6;\n+                    val |= (cur[3]) & 0x3F;\n+                    l = 4;\n+                }\n+                if ((l == 1) || (!IS_CHAR(val))) {\n+                    xmlEntitiesErr(XML_ERR_INVALID_CHAR,\n+                        \"xmlEncodeEntities: char out of range\\n\");\n+                    if (doc != NULL)\n+                        doc->encoding = xmlStrdup(BAD_CAST \"ISO-8859-1\");\n+                    snprintf(buf, sizeof(buf), \"&#%d;\", *cur);\n+                    buf[sizeof(buf) - 1] = 0;\n+                    ptr = buf;\n+                    while (*ptr != 0) *out++ = *ptr++;\n+                    cur++;\n+                    continue;\n+                }\n+                \/*\n+                 * We could do multiple things here. Just save as a char ref\n+                 *\/\n+                snprintf(buf, sizeof(buf), \"&#x%X;\", val);\n+                buf[sizeof(buf) - 1] = 0;\n+                ptr = buf;\n+                while (*ptr != 0) *out++ = *ptr++;\n+                cur += l;\n+                continue;\n+            }\n+        } else if (IS_BYTE_CHAR(*cur)) {\n+            char buf[11], *ptr;\n+\n@@ -767,12 +787,0 @@\n-            cur++;\n-            continue;\n-        }\n-        \/*\n-         * We could do multiple things here. Just save as a char ref\n-         *\/\n-        snprintf(buf, sizeof(buf), \"&#x%X;\", val);\n-        buf[sizeof(buf) - 1] = 0;\n-        ptr = buf;\n-        while (*ptr != 0) *out++ = *ptr++;\n-        cur += l;\n-        continue;\n@@ -780,9 +788,1 @@\n-    } else if (IS_BYTE_CHAR(*cur)) {\n-        char buf[11], *ptr;\n-\n-        snprintf(buf, sizeof(buf), \"&#%d;\", *cur);\n-        buf[sizeof(buf) - 1] = 0;\n-            ptr = buf;\n-        while (*ptr != 0) *out++ = *ptr++;\n-    }\n-    cur++;\n+        cur++;\n@@ -857,1 +857,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -865,3 +865,3 @@\n-        growBufferReentrant();\n-        out = &buffer[indx];\n-    }\n+            growBufferReentrant();\n+            out = &buffer[indx];\n+        }\n@@ -869,33 +869,0 @@\n-    \/*\n-     * By default one have to encode at least '<', '>', '\"' and '&' !\n-     *\/\n-    if (*cur == '<') {\n-        *out++ = '&';\n-        *out++ = 'l';\n-        *out++ = 't';\n-        *out++ = ';';\n-    } else if (*cur == '>') {\n-        *out++ = '&';\n-        *out++ = 'g';\n-        *out++ = 't';\n-        *out++ = ';';\n-    } else if (*cur == '&') {\n-        *out++ = '&';\n-        *out++ = 'a';\n-        *out++ = 'm';\n-        *out++ = 'p';\n-        *out++ = ';';\n-    } else if (*cur == '\"') {\n-        *out++ = '&';\n-        *out++ = 'q';\n-        *out++ = 'u';\n-        *out++ = 'o';\n-        *out++ = 't';\n-        *out++ = ';';\n-    } else if (*cur == '\\r') {\n-        *out++ = '&';\n-        *out++ = '#';\n-        *out++ = '1';\n-        *out++ = '3';\n-        *out++ = ';';\n-    } else {\n@@ -903,2 +870,1 @@\n-         * Works because on UTF-8, all extended sequences cannot\n-         * result in bytes in the ASCII range.\n+         * By default one have to encode at least '<', '>', '\"' and '&' !\n@@ -906,3 +872,37 @@\n-        *out++ = *cur;\n-    }\n-    cur++;\n+        if (*cur == '<') {\n+            *out++ = '&';\n+            *out++ = 'l';\n+            *out++ = 't';\n+            *out++ = ';';\n+        } else if (*cur == '>') {\n+            *out++ = '&';\n+            *out++ = 'g';\n+            *out++ = 't';\n+            *out++ = ';';\n+        } else if (*cur == '&') {\n+            *out++ = '&';\n+            *out++ = 'a';\n+            *out++ = 'm';\n+            *out++ = 'p';\n+            *out++ = ';';\n+        } else if (*cur == '\"') {\n+            *out++ = '&';\n+            *out++ = 'q';\n+            *out++ = 'u';\n+            *out++ = 'o';\n+            *out++ = 't';\n+            *out++ = ';';\n+        } else if (*cur == '\\r') {\n+            *out++ = '&';\n+            *out++ = '#';\n+            *out++ = '1';\n+            *out++ = '3';\n+            *out++ = ';';\n+        } else {\n+            \/*\n+             * Works because on UTF-8, all extended sequences cannot\n+             * result in bytes in the ASCII range.\n+             *\/\n+            *out++ = *cur;\n+        }\n+        cur++;\n@@ -942,1 +942,1 @@\n-    xmlFreeEntity((xmlEntityPtr) entity);\n+        xmlFreeEntity((xmlEntityPtr) entity);\n@@ -973,1 +973,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -980,1 +980,1 @@\n-    cur->name = xmlStrdup(ent->name);\n+        cur->name = xmlStrdup(ent->name);\n@@ -982,1 +982,1 @@\n-    cur->ExternalID = xmlStrdup(ent->ExternalID);\n+        cur->ExternalID = xmlStrdup(ent->ExternalID);\n@@ -984,1 +984,1 @@\n-    cur->SystemID = xmlStrdup(ent->SystemID);\n+        cur->SystemID = xmlStrdup(ent->SystemID);\n@@ -986,1 +986,1 @@\n-    cur->content = xmlStrdup(ent->content);\n+        cur->content = xmlStrdup(ent->content);\n@@ -988,1 +988,1 @@\n-    cur->orig = xmlStrdup(ent->orig);\n+        cur->orig = xmlStrdup(ent->orig);\n@@ -990,1 +990,1 @@\n-    cur->URI = xmlStrdup(ent->URI);\n+        cur->URI = xmlStrdup(ent->URI);\n@@ -1024,10 +1024,19 @@\n-    xmlBufferCCat(buf, \"\\\"\");\n-    base = cur = content;\n-    while (*cur != 0) {\n-        if (*cur == '\"') {\n-        if (base != cur)\n-            xmlBufferAdd(buf, base, cur - base);\n-        xmlBufferAdd(buf, BAD_CAST \"&quot;\", 6);\n-        cur++;\n-        base = cur;\n-        } else if (*cur == '%') {\n+        xmlBufferCCat(buf, \"\\\"\");\n+        base = cur = content;\n+        while (*cur != 0) {\n+            if (*cur == '\"') {\n+                if (base != cur)\n+                    xmlBufferAdd(buf, base, cur - base);\n+                xmlBufferAdd(buf, BAD_CAST \"&quot;\", 6);\n+                cur++;\n+                base = cur;\n+            } else if (*cur == '%') {\n+                if (base != cur)\n+                    xmlBufferAdd(buf, base, cur - base);\n+                xmlBufferAdd(buf, BAD_CAST \"&#x25;\", 6);\n+                cur++;\n+                base = cur;\n+            } else {\n+                cur++;\n+            }\n+        }\n@@ -1036,10 +1045,1 @@\n-        xmlBufferAdd(buf, BAD_CAST \"&#x25;\", 6);\n-        cur++;\n-        base = cur;\n-        } else {\n-        cur++;\n-        }\n-    }\n-    if (base != cur)\n-        xmlBufferAdd(buf, base, cur - base);\n-    xmlBufferCCat(buf, \"\\\"\");\n+        xmlBufferCCat(buf, \"\\\"\");\n@@ -1062,72 +1062,72 @@\n-    case XML_INTERNAL_GENERAL_ENTITY:\n-        xmlBufferWriteChar(buf, \"<!ENTITY \");\n-        xmlBufferWriteCHAR(buf, ent->name);\n-        xmlBufferWriteChar(buf, \" \");\n-        if (ent->orig != NULL)\n-        xmlBufferWriteQuotedString(buf, ent->orig);\n-        else\n-        xmlDumpEntityContent(buf, ent->content);\n-        xmlBufferWriteChar(buf, \">\\n\");\n-        break;\n-    case XML_EXTERNAL_GENERAL_PARSED_ENTITY:\n-        xmlBufferWriteChar(buf, \"<!ENTITY \");\n-        xmlBufferWriteCHAR(buf, ent->name);\n-        if (ent->ExternalID != NULL) {\n-         xmlBufferWriteChar(buf, \" PUBLIC \");\n-         xmlBufferWriteQuotedString(buf, ent->ExternalID);\n-         xmlBufferWriteChar(buf, \" \");\n-         xmlBufferWriteQuotedString(buf, ent->SystemID);\n-        } else {\n-         xmlBufferWriteChar(buf, \" SYSTEM \");\n-         xmlBufferWriteQuotedString(buf, ent->SystemID);\n-        }\n-        xmlBufferWriteChar(buf, \">\\n\");\n-        break;\n-    case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:\n-        xmlBufferWriteChar(buf, \"<!ENTITY \");\n-        xmlBufferWriteCHAR(buf, ent->name);\n-        if (ent->ExternalID != NULL) {\n-         xmlBufferWriteChar(buf, \" PUBLIC \");\n-         xmlBufferWriteQuotedString(buf, ent->ExternalID);\n-         xmlBufferWriteChar(buf, \" \");\n-         xmlBufferWriteQuotedString(buf, ent->SystemID);\n-        } else {\n-         xmlBufferWriteChar(buf, \" SYSTEM \");\n-         xmlBufferWriteQuotedString(buf, ent->SystemID);\n-        }\n-        if (ent->content != NULL) { \/* Should be true ! *\/\n-        xmlBufferWriteChar(buf, \" NDATA \");\n-        if (ent->orig != NULL)\n-            xmlBufferWriteCHAR(buf, ent->orig);\n-        else\n-            xmlBufferWriteCHAR(buf, ent->content);\n-        }\n-        xmlBufferWriteChar(buf, \">\\n\");\n-        break;\n-    case XML_INTERNAL_PARAMETER_ENTITY:\n-        xmlBufferWriteChar(buf, \"<!ENTITY % \");\n-        xmlBufferWriteCHAR(buf, ent->name);\n-        xmlBufferWriteChar(buf, \" \");\n-        if (ent->orig == NULL)\n-        xmlDumpEntityContent(buf, ent->content);\n-        else\n-        xmlBufferWriteQuotedString(buf, ent->orig);\n-        xmlBufferWriteChar(buf, \">\\n\");\n-        break;\n-    case XML_EXTERNAL_PARAMETER_ENTITY:\n-        xmlBufferWriteChar(buf, \"<!ENTITY % \");\n-        xmlBufferWriteCHAR(buf, ent->name);\n-        if (ent->ExternalID != NULL) {\n-         xmlBufferWriteChar(buf, \" PUBLIC \");\n-         xmlBufferWriteQuotedString(buf, ent->ExternalID);\n-         xmlBufferWriteChar(buf, \" \");\n-         xmlBufferWriteQuotedString(buf, ent->SystemID);\n-        } else {\n-         xmlBufferWriteChar(buf, \" SYSTEM \");\n-         xmlBufferWriteQuotedString(buf, ent->SystemID);\n-        }\n-        xmlBufferWriteChar(buf, \">\\n\");\n-        break;\n-    default:\n-        xmlEntitiesErr(XML_DTD_UNKNOWN_ENTITY,\n-        \"xmlDumpEntitiesDecl: internal: unknown type entity type\");\n+        case XML_INTERNAL_GENERAL_ENTITY:\n+            xmlBufferWriteChar(buf, \"<!ENTITY \");\n+            xmlBufferWriteCHAR(buf, ent->name);\n+            xmlBufferWriteChar(buf, \" \");\n+            if (ent->orig != NULL)\n+                xmlBufferWriteQuotedString(buf, ent->orig);\n+            else\n+                xmlDumpEntityContent(buf, ent->content);\n+            xmlBufferWriteChar(buf, \">\\n\");\n+            break;\n+        case XML_EXTERNAL_GENERAL_PARSED_ENTITY:\n+            xmlBufferWriteChar(buf, \"<!ENTITY \");\n+            xmlBufferWriteCHAR(buf, ent->name);\n+            if (ent->ExternalID != NULL) {\n+                 xmlBufferWriteChar(buf, \" PUBLIC \");\n+                 xmlBufferWriteQuotedString(buf, ent->ExternalID);\n+                 xmlBufferWriteChar(buf, \" \");\n+                 xmlBufferWriteQuotedString(buf, ent->SystemID);\n+            } else {\n+                 xmlBufferWriteChar(buf, \" SYSTEM \");\n+                 xmlBufferWriteQuotedString(buf, ent->SystemID);\n+            }\n+            xmlBufferWriteChar(buf, \">\\n\");\n+            break;\n+        case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:\n+            xmlBufferWriteChar(buf, \"<!ENTITY \");\n+            xmlBufferWriteCHAR(buf, ent->name);\n+            if (ent->ExternalID != NULL) {\n+                 xmlBufferWriteChar(buf, \" PUBLIC \");\n+                 xmlBufferWriteQuotedString(buf, ent->ExternalID);\n+                 xmlBufferWriteChar(buf, \" \");\n+                 xmlBufferWriteQuotedString(buf, ent->SystemID);\n+            } else {\n+                 xmlBufferWriteChar(buf, \" SYSTEM \");\n+                 xmlBufferWriteQuotedString(buf, ent->SystemID);\n+            }\n+            if (ent->content != NULL) { \/* Should be true ! *\/\n+                xmlBufferWriteChar(buf, \" NDATA \");\n+                if (ent->orig != NULL)\n+                    xmlBufferWriteCHAR(buf, ent->orig);\n+                else\n+                    xmlBufferWriteCHAR(buf, ent->content);\n+            }\n+            xmlBufferWriteChar(buf, \">\\n\");\n+            break;\n+        case XML_INTERNAL_PARAMETER_ENTITY:\n+            xmlBufferWriteChar(buf, \"<!ENTITY % \");\n+            xmlBufferWriteCHAR(buf, ent->name);\n+            xmlBufferWriteChar(buf, \" \");\n+            if (ent->orig == NULL)\n+                xmlDumpEntityContent(buf, ent->content);\n+            else\n+                xmlBufferWriteQuotedString(buf, ent->orig);\n+            xmlBufferWriteChar(buf, \">\\n\");\n+            break;\n+        case XML_EXTERNAL_PARAMETER_ENTITY:\n+            xmlBufferWriteChar(buf, \"<!ENTITY % \");\n+            xmlBufferWriteCHAR(buf, ent->name);\n+            if (ent->ExternalID != NULL) {\n+                 xmlBufferWriteChar(buf, \" PUBLIC \");\n+                 xmlBufferWriteQuotedString(buf, ent->ExternalID);\n+                 xmlBufferWriteChar(buf, \" \");\n+                 xmlBufferWriteQuotedString(buf, ent->SystemID);\n+            } else {\n+                 xmlBufferWriteChar(buf, \" SYSTEM \");\n+                 xmlBufferWriteQuotedString(buf, ent->SystemID);\n+            }\n+            xmlBufferWriteChar(buf, \">\\n\");\n+            break;\n+        default:\n+            xmlEntitiesErr(XML_DTD_UNKNOWN_ENTITY,\n+                \"xmlDumpEntitiesDecl: internal: unknown type entity type\");\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/entities.c","additions":401,"deletions":401,"binary":false,"changes":802,"status":"modified"},{"patch":"@@ -19,35 +19,35 @@\n-void XMLCDECL xmlGenericErrorDefaultFunc    (void *ctx ATTRIBUTE_UNUSED,\n-                 const char *msg,\n-                 ...) LIBXML_ATTR_FORMAT(2,3);\n-\n-#define XML_GET_VAR_STR(msg, str) {             \\\n-    int       size, prev_size = -1;             \\\n-    int       chars;                        \\\n-    char      *larger;                      \\\n-    va_list   ap;                       \\\n-                                \\\n-    str = (char *) xmlMalloc(150);              \\\n-    if (str != NULL) {                      \\\n-                                \\\n-    size = 150;                         \\\n-                                \\\n-    while (size < 64000) {                  \\\n-    va_start(ap, msg);                  \\\n-    chars = vsnprintf(str, size, msg, ap);          \\\n-    va_end(ap);                     \\\n-    if ((chars > -1) && (chars < size)) {           \\\n-        if (prev_size == chars) {               \\\n-        break;                      \\\n-        } else {                        \\\n-        prev_size = chars;              \\\n-        }                           \\\n-    }                           \\\n-    if (chars > -1)                     \\\n-        size += chars + 1;                  \\\n-    else                            \\\n-        size += 100;                    \\\n-    if ((larger = (char *) xmlRealloc(str, size)) == NULL) {\\\n-        break;                      \\\n-    }                           \\\n-    str = larger;                       \\\n-    }}                              \\\n+void XMLCDECL xmlGenericErrorDefaultFunc        (void *ctx ATTRIBUTE_UNUSED,\n+                                 const char *msg,\n+                                 ...) LIBXML_ATTR_FORMAT(2,3);\n+\n+#define XML_GET_VAR_STR(msg, str) {                             \\\n+    int       size, prev_size = -1;                             \\\n+    int       chars;                                            \\\n+    char      *larger;                                          \\\n+    va_list   ap;                                               \\\n+                                                                \\\n+    str = (char *) xmlMalloc(150);                              \\\n+    if (str != NULL) {                                          \\\n+                                                                \\\n+    size = 150;                                                 \\\n+                                                                \\\n+    while (size < 64000) {                                      \\\n+        va_start(ap, msg);                                      \\\n+        chars = vsnprintf(str, size, msg, ap);                  \\\n+        va_end(ap);                                             \\\n+        if ((chars > -1) && (chars < size)) {                   \\\n+            if (prev_size == chars) {                           \\\n+                break;                                          \\\n+            } else {                                            \\\n+                prev_size = chars;                              \\\n+            }                                                   \\\n+        }                                                       \\\n+        if (chars > -1)                                         \\\n+            size += chars + 1;                                  \\\n+        else                                                    \\\n+            size += 100;                                        \\\n+        if ((larger = (char *) xmlRealloc(str, size)) == NULL) {\\\n+            break;                                              \\\n+        }                                                       \\\n+        str = larger;                                           \\\n+    }}                                                          \\\n@@ -57,3 +57,3 @@\n- *                                  *\n- *          Handling of out of context errors       *\n- *                                  *\n+ *                                                                      *\n+ *                      Handling of out of context errors               *\n+ *                                                                      *\n@@ -75,1 +75,1 @@\n-    xmlGenericErrorContext = (void *) stderr;\n+        xmlGenericErrorContext = (void *) stderr;\n@@ -116,1 +116,1 @@\n-    xmlGenericError = handler;\n+        xmlGenericError = handler;\n@@ -118,1 +118,1 @@\n-    xmlGenericError = xmlGenericErrorDefaultFunc;\n+        xmlGenericError = xmlGenericErrorDefaultFunc;\n@@ -140,3 +140,3 @@\n- *                                  *\n- *          Handling of parsing errors          *\n- *                                  *\n+ *                                                                      *\n+ *                      Handling of parsing errors                      *\n+ *                                                                      *\n@@ -155,7 +155,7 @@\n-    if (input->filename)\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"%s:%d: \", input->filename,\n-            input->line);\n-    else\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"Entity: line %d: \", input->line);\n+        if (input->filename)\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"%s:%d: \", input->filename,\n+                    input->line);\n+        else\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"Entity: line %d: \", input->line);\n@@ -174,1 +174,1 @@\n-        xmlGenericErrorFunc channel, void *data ) {\n+                xmlGenericErrorFunc channel, void *data ) {\n@@ -176,1 +176,1 @@\n-    unsigned int n, col;    \/* GCC warns if signed, because compared with sizeof() *\/\n+    unsigned int n, col;        \/* GCC warns if signed, because compared with sizeof() *\/\n@@ -187,1 +187,1 @@\n-    cur--;\n+        cur--;\n@@ -192,1 +192,1 @@\n-       (*(cur) != '\\n') && (*(cur) != '\\r'))\n+           (*(cur) != '\\n') && (*(cur) != '\\r'))\n@@ -202,3 +202,3 @@\n-       (*(cur) != '\\r') && (n < sizeof(content)-1)) {\n-        *ctnt++ = *cur++;\n-    n++;\n+           (*(cur) != '\\r') && (n < sizeof(content)-1)) {\n+                *ctnt++ = *cur++;\n+        n++;\n@@ -214,3 +214,3 @@\n-    if (*(ctnt) != '\\t')\n-        *(ctnt) = ' ';\n-    ctnt++;\n+        if (*(ctnt) != '\\t')\n+            *(ctnt) = ' ';\n+        ctnt++;\n@@ -262,2 +262,2 @@\n-    channel = xmlGenericError;\n-    data = xmlGenericErrorContext;\n+        channel = xmlGenericError;\n+        data = xmlGenericErrorContext;\n@@ -298,3 +298,3 @@\n-             ((domain == XML_FROM_PARSER) || (domain == XML_FROM_SCHEMASV)||\n-          (domain == XML_FROM_SCHEMASP)||(domain == XML_FROM_DTD) ||\n-          (domain == XML_FROM_RELAXNGP)||(domain == XML_FROM_RELAXNGV)))\n+                 ((domain == XML_FROM_PARSER) || (domain == XML_FROM_SCHEMASV)||\n+                  (domain == XML_FROM_SCHEMASP)||(domain == XML_FROM_DTD) ||\n+                  (domain == XML_FROM_RELAXNGP)||(domain == XML_FROM_RELAXNGV)))\n@@ -396,5 +396,5 @@\n-    len = xmlStrlen((const xmlChar *)str);\n-    if ((len > 0) && (str[len - 1] != '\\n'))\n-        channel(data, \"%s\\n\", str);\n-    else\n-        channel(data, \"%s\", str);\n+        len = xmlStrlen((const xmlChar *)str);\n+        if ((len > 0) && (str[len - 1] != '\\n'))\n+            channel(data, \"%s\\n\", str);\n+        else\n+            channel(data, \"%s\", str);\n@@ -417,10 +417,10 @@\n-    (err->int1 < xmlStrlen((const xmlChar *)err->str1))) {\n-    xmlChar buf[150];\n-    int i;\n-\n-    channel(data, \"%s\\n\", err->str1);\n-    for (i=0;i < err->int1;i++)\n-         buf[i] = ' ';\n-    buf[i++] = '^';\n-    buf[i] = 0;\n-    channel(data, \"%s\\n\", buf);\n+        (err->int1 < xmlStrlen((const xmlChar *)err->str1))) {\n+        xmlChar buf[150];\n+        int i;\n+\n+        channel(data, \"%s\\n\", err->str1);\n+        for (i=0;i < err->int1;i++)\n+             buf[i] = ' ';\n+        buf[i++] = '^';\n+        buf[i] = 0;\n+        channel(data, \"%s\\n\", buf);\n@@ -460,1 +460,1 @@\n-          const char *msg, ...)\n+              const char *msg, ...)\n@@ -475,8 +475,8 @@\n-    (domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {\n-    ctxt = (xmlParserCtxtPtr) ctx;\n-    if ((schannel == NULL) && (ctxt != NULL) && (ctxt->sax != NULL) &&\n-        (ctxt->sax->initialized == XML_SAX2_MAGIC) &&\n-        (ctxt->sax->serror != NULL)) {\n-        schannel = ctxt->sax->serror;\n-        data = ctxt->userData;\n-    }\n+        (domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {\n+        ctxt = (xmlParserCtxtPtr) ctx;\n+        if ((schannel == NULL) && (ctxt != NULL) && (ctxt->sax != NULL) &&\n+            (ctxt->sax->initialized == XML_SAX2_MAGIC) &&\n+            (ctxt->sax->serror != NULL)) {\n+            schannel = ctxt->sax->serror;\n+            data = ctxt->userData;\n+        }\n@@ -488,6 +488,6 @@\n-    schannel = xmlStructuredError;\n-    \/*\n-     * if user has defined handler, change data ptr to user's choice\n-     *\/\n-    if (schannel != NULL)\n-        data = xmlStructuredErrorContext;\n+        schannel = xmlStructuredError;\n+        \/*\n+         * if user has defined handler, change data ptr to user's choice\n+         *\/\n+        if (schannel != NULL)\n+            data = xmlStructuredErrorContext;\n@@ -522,1 +522,1 @@\n-    int i;\n+        int i;\n@@ -524,8 +524,8 @@\n-    if ((node->doc != NULL) && (node->doc->URL != NULL)) {\n-        baseptr = node;\n-\/*      file = (const char *) node->doc->URL; *\/\n-    }\n-    for (i = 0;\n-         ((i < 10) && (node != NULL) && (node->type != XML_ELEMENT_NODE));\n-         i++)\n-         node = node->parent;\n+        if ((node->doc != NULL) && (node->doc->URL != NULL)) {\n+            baseptr = node;\n+\/*          file = (const char *) node->doc->URL; *\/\n+        }\n+        for (i = 0;\n+             ((i < 10) && (node != NULL) && (node->type != XML_ELEMENT_NODE));\n+             i++)\n+             node = node->parent;\n@@ -533,2 +533,2 @@\n-        (node->doc != NULL) && (node->doc->URL != NULL))\n-        baseptr = node;\n+            (node->doc != NULL) && (node->doc->URL != NULL))\n+            baseptr = node;\n@@ -536,4 +536,4 @@\n-    if ((node != NULL) && (node->type == XML_ELEMENT_NODE))\n-        line = node->line;\n-    if ((line == 0) || (line == 65535))\n-        line = xmlGetLineNo(node);\n+        if ((node != NULL) && (node->type == XML_ELEMENT_NODE))\n+            line = node->line;\n+        if ((line == 0) || (line == 65535))\n+            line = xmlGetLineNo(node);\n@@ -554,5 +554,5 @@\n-    \/*\n-     * We check if the error is within an XInclude section and,\n-     * if so, attempt to print out the href of the XInclude instead\n-     * of the usual \"base\" (doc->URL) for the node (bug 152623).\n-     *\/\n+        \/*\n+         * We check if the error is within an XInclude section and,\n+         * if so, attempt to print out the href of the XInclude instead\n+         * of the usual \"base\" (doc->URL) for the node (bug 152623).\n+         *\/\n@@ -561,8 +561,8 @@\n-    int inclcount = 0;\n-    while (prev != NULL) {\n-        if (prev->prev == NULL)\n-            prev = prev->parent;\n-        else {\n-            prev = prev->prev;\n-        if (prev->type == XML_XINCLUDE_START) {\n-            if (inclcount > 0) {\n+        int inclcount = 0;\n+        while (prev != NULL) {\n+            if (prev->prev == NULL)\n+                prev = prev->parent;\n+            else {\n+                prev = prev->prev;\n+                if (prev->type == XML_XINCLUDE_START) {\n+                    if (inclcount > 0) {\n@@ -573,1 +573,1 @@\n-                    break;\n+                            break;\n@@ -575,2 +575,3 @@\n-        } else if (prev->type == XML_XINCLUDE_END)\n-            inclcount++;\n+                } else if (prev->type == XML_XINCLUDE_END)\n+                    inclcount++;\n+            }\n@@ -578,1 +579,0 @@\n-    }\n@@ -581,1 +581,1 @@\n-    else\n+        else\n@@ -583,4 +583,4 @@\n-        to->file = (char *) xmlStrdup(baseptr->doc->URL);\n-    if ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) {\n-        to->file = (char *) xmlStrdup(node->doc->URL);\n-    }\n+            to->file = (char *) xmlStrdup(baseptr->doc->URL);\n+        if ((to->file == NULL) && (node != NULL) && (node->doc != NULL)) {\n+            to->file = (char *) xmlStrdup(node->doc->URL);\n+        }\n@@ -604,2 +604,2 @@\n-    schannel(data, to);\n-    return;\n+        schannel(data, to);\n+        return;\n@@ -614,1 +614,1 @@\n-        channel = ctxt->sax->warning;\n+            channel = ctxt->sax->warning;\n@@ -616,2 +616,2 @@\n-        channel = ctxt->sax->error;\n-    data = ctxt->userData;\n+            channel = ctxt->sax->error;\n+        data = ctxt->userData;\n@@ -619,6 +619,6 @@\n-    channel = xmlGenericError;\n-    if (ctxt != NULL) {\n-        data = ctxt;\n-    } else {\n-        data = xmlGenericErrorContext;\n-    }\n+        channel = xmlGenericError;\n+        if (ctxt != NULL) {\n+            data = ctxt;\n+        } else {\n+            data = xmlGenericErrorContext;\n+        }\n@@ -631,3 +631,3 @@\n-    (channel == xmlParserValidityError) ||\n-    (channel == xmlParserValidityWarning))\n-    xmlReportError(to, ctxt, str, NULL, NULL);\n+        (channel == xmlParserValidityError) ||\n+        (channel == xmlParserValidityWarning))\n+        xmlReportError(to, ctxt, str, NULL, NULL);\n@@ -636,1 +636,1 @@\n-    xmlReportError(to, ctxt, str, channel, data);\n+        xmlReportError(to, ctxt, str, channel, data);\n@@ -638,1 +638,1 @@\n-    channel(data, \"%s\", str);\n+        channel(data, \"%s\", str);\n@@ -656,9 +656,9 @@\n-    if (extra)\n-        __xmlRaiseError(NULL, NULL, NULL, NULL, node, domain,\n-                XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,\n-                NULL, NULL, 0, 0,\n-                \"Memory allocation failed : %s\\n\", extra);\n-    else\n-        __xmlRaiseError(NULL, NULL, NULL, NULL, node, domain,\n-                XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, NULL,\n-                NULL, NULL, 0, 0, \"Memory allocation failed\\n\");\n+        if (extra)\n+            __xmlRaiseError(NULL, NULL, NULL, NULL, node, domain,\n+                            XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, extra,\n+                            NULL, NULL, 0, 0,\n+                            \"Memory allocation failed : %s\\n\", extra);\n+        else\n+            __xmlRaiseError(NULL, NULL, NULL, NULL, node, domain,\n+                            XML_ERR_NO_MEMORY, XML_ERR_FATAL, NULL, 0, NULL,\n+                            NULL, NULL, 0, 0, \"Memory allocation failed\\n\");\n@@ -666,3 +666,3 @@\n-    __xmlRaiseError(NULL, NULL, NULL, NULL, node, domain,\n-            code, XML_ERR_ERROR, NULL, 0, extra,\n-            NULL, NULL, 0, 0, msg, extra);\n+        __xmlRaiseError(NULL, NULL, NULL, NULL, node, domain,\n+                        code, XML_ERR_ERROR, NULL, 0, extra,\n+                        NULL, NULL, 0, 0, msg, extra);\n@@ -689,7 +689,7 @@\n-    input = ctxt->input;\n-    if ((input != NULL) && (input->filename == NULL) &&\n-        (ctxt->inputNr > 1)) {\n-        cur = input;\n-        input = ctxt->inputTab[ctxt->inputNr - 2];\n-    }\n-    xmlParserPrintFileInfo(input);\n+        input = ctxt->input;\n+        if ((input != NULL) && (input->filename == NULL) &&\n+            (ctxt->inputNr > 1)) {\n+            cur = input;\n+            input = ctxt->inputTab[ctxt->inputNr - 2];\n+        }\n+        xmlParserPrintFileInfo(input);\n@@ -702,1 +702,1 @@\n-    xmlFree(str);\n+        xmlFree(str);\n@@ -705,6 +705,6 @@\n-    xmlParserPrintFileContext(input);\n-    if (cur != NULL) {\n-        xmlParserPrintFileInfo(cur);\n-        xmlGenericError(xmlGenericErrorContext, \"\\n\");\n-        xmlParserPrintFileContext(cur);\n-    }\n+        xmlParserPrintFileContext(input);\n+        if (cur != NULL) {\n+            xmlParserPrintFileInfo(cur);\n+            xmlGenericError(xmlGenericErrorContext, \"\\n\");\n+            xmlParserPrintFileContext(cur);\n+        }\n@@ -732,7 +732,7 @@\n-    input = ctxt->input;\n-    if ((input != NULL) && (input->filename == NULL) &&\n-        (ctxt->inputNr > 1)) {\n-        cur = input;\n-        input = ctxt->inputTab[ctxt->inputNr - 2];\n-    }\n-    xmlParserPrintFileInfo(input);\n+        input = ctxt->input;\n+        if ((input != NULL) && (input->filename == NULL) &&\n+            (ctxt->inputNr > 1)) {\n+            cur = input;\n+            input = ctxt->inputTab[ctxt->inputNr - 2];\n+        }\n+        xmlParserPrintFileInfo(input);\n@@ -745,1 +745,1 @@\n-    xmlFree(str);\n+        xmlFree(str);\n@@ -748,6 +748,6 @@\n-    xmlParserPrintFileContext(input);\n-    if (cur != NULL) {\n-        xmlParserPrintFileInfo(cur);\n-        xmlGenericError(xmlGenericErrorContext, \"\\n\");\n-        xmlParserPrintFileContext(cur);\n-    }\n+        xmlParserPrintFileContext(input);\n+        if (cur != NULL) {\n+            xmlParserPrintFileInfo(cur);\n+            xmlGenericError(xmlGenericErrorContext, \"\\n\");\n+            xmlParserPrintFileContext(cur);\n+        }\n@@ -758,3 +758,3 @@\n- *                                  *\n- *          Handling of validation errors           *\n- *                                  *\n+ *                                                                      *\n+ *                      Handling of validation errors                   *\n+ *                                                                      *\n@@ -782,4 +782,4 @@\n-    if (ctxt != NULL) {\n-        input = ctxt->input;\n-        if ((input->filename == NULL) && (ctxt->inputNr > 1))\n-        input = ctxt->inputTab[ctxt->inputNr - 2];\n+        if (ctxt != NULL) {\n+            input = ctxt->input;\n+            if ((input->filename == NULL) && (ctxt->inputNr > 1))\n+                input = ctxt->inputTab[ctxt->inputNr - 2];\n@@ -787,2 +787,3 @@\n-        if (had_info == 0) {\n-        xmlParserPrintFileInfo(input);\n+            if (had_info == 0) {\n+                xmlParserPrintFileInfo(input);\n+            }\n@@ -790,3 +791,2 @@\n-    }\n-    xmlGenericError(xmlGenericErrorContext, \"validity error: \");\n-    had_info = 0;\n+        xmlGenericError(xmlGenericErrorContext, \"validity error: \");\n+        had_info = 0;\n@@ -794,1 +794,1 @@\n-    had_info = 1;\n+        had_info = 1;\n@@ -800,1 +800,1 @@\n-    xmlFree(str);\n+        xmlFree(str);\n@@ -803,1 +803,1 @@\n-    xmlParserPrintFileContext(input);\n+        xmlParserPrintFileContext(input);\n@@ -825,3 +825,3 @@\n-    input = ctxt->input;\n-    if ((input->filename == NULL) && (ctxt->inputNr > 1))\n-        input = ctxt->inputTab[ctxt->inputNr - 2];\n+        input = ctxt->input;\n+        if ((input->filename == NULL) && (ctxt->inputNr > 1))\n+            input = ctxt->inputTab[ctxt->inputNr - 2];\n@@ -829,1 +829,1 @@\n-    xmlParserPrintFileInfo(input);\n+        xmlParserPrintFileInfo(input);\n@@ -836,1 +836,1 @@\n-    xmlFree(str);\n+        xmlFree(str);\n@@ -839,1 +839,1 @@\n-    xmlParserPrintFileContext(input);\n+        xmlParserPrintFileContext(input);\n@@ -845,3 +845,3 @@\n- *                                  *\n- *          Extended Error Handling             *\n- *                                  *\n+ *                                                                      *\n+ *                      Extended Error Handling                         *\n+ *                                                                      *\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/error.c","additions":213,"deletions":213,"binary":false,"changes":426,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-    xmlFreeMutex(xmlThrDefMutex);\n-    xmlThrDefMutex = NULL;\n+        xmlFreeMutex(xmlThrDefMutex);\n+        xmlThrDefMutex = NULL;\n@@ -68,3 +68,3 @@\n- *                                  *\n- *  All the user accessible global variables of the library     *\n- *                                  *\n+ *                                                                      *\n+ *      All the user accessible global variables of the library         *\n+ *                                                                      *\n@@ -307,3 +307,3 @@\n-void XMLCDECL xmlGenericErrorDefaultFunc    (void *ctx ATTRIBUTE_UNUSED,\n-                 const char *msg,\n-                 ...);\n+void XMLCDECL xmlGenericErrorDefaultFunc        (void *ctx ATTRIBUTE_UNUSED,\n+                                 const char *msg,\n+                                 ...);\n@@ -510,1 +510,1 @@\n-        (unsigned long) gs, xmlGetThreadId());\n+            (unsigned long) gs, xmlGetThreadId());\n@@ -573,2 +573,2 @@\n-    gs->xmlParserInputBufferCreateFilenameValue = xmlParserInputBufferCreateFilenameValueThrDef;\n-    gs->xmlOutputBufferCreateFilenameValue = xmlOutputBufferCreateFilenameValueThrDef;\n+        gs->xmlParserInputBufferCreateFilenameValue = xmlParserInputBufferCreateFilenameValueThrDef;\n+        gs->xmlOutputBufferCreateFilenameValue = xmlOutputBufferCreateFilenameValueThrDef;\n@@ -589,1 +589,1 @@\n-    xmlGenericErrorThrDef = handler;\n+        xmlGenericErrorThrDef = handler;\n@@ -591,1 +591,1 @@\n-    xmlGenericErrorThrDef = xmlGenericErrorDefaultFunc;\n+        xmlGenericErrorThrDef = xmlGenericErrorDefaultFunc;\n@@ -677,2 +677,2 @@\n-        old = __xmlParserInputBufferCreateFilename;\n-    }\n+                old = __xmlParserInputBufferCreateFilename;\n+        }\n@@ -695,2 +695,2 @@\n-        old = __xmlOutputBufferCreateFilename;\n-    }\n+                old = __xmlOutputBufferCreateFilename;\n+        }\n@@ -709,1 +709,1 @@\n-    return (&docbDefaultSAXHandler);\n+        return (&docbDefaultSAXHandler);\n@@ -711,1 +711,1 @@\n-    return (&xmlGetGlobalState()->docbDefaultSAXHandler);\n+        return (&xmlGetGlobalState()->docbDefaultSAXHandler);\n@@ -720,1 +720,1 @@\n-    return (&htmlDefaultSAXHandler);\n+        return (&htmlDefaultSAXHandler);\n@@ -722,1 +722,1 @@\n-    return (&xmlGetGlobalState()->htmlDefaultSAXHandler);\n+        return (&xmlGetGlobalState()->htmlDefaultSAXHandler);\n@@ -730,1 +730,1 @@\n-    return (&xmlLastError);\n+        return (&xmlLastError);\n@@ -732,1 +732,1 @@\n-    return (&xmlGetGlobalState()->xmlLastError);\n+        return (&xmlGetGlobalState()->xmlLastError);\n@@ -747,1 +747,1 @@\n-    return (&xmlGetGlobalState()->xmlMalloc);\n+        return (&xmlGetGlobalState()->xmlMalloc);\n@@ -798,1 +798,1 @@\n-    return (&oldXMLWDcompatibility);\n+        return (&oldXMLWDcompatibility);\n@@ -800,1 +800,1 @@\n-    return (&xmlGetGlobalState()->oldXMLWDcompatibility);\n+        return (&xmlGetGlobalState()->oldXMLWDcompatibility);\n@@ -807,1 +807,1 @@\n-    return (&xmlBufferAllocScheme);\n+        return (&xmlBufferAllocScheme);\n@@ -809,1 +809,1 @@\n-    return (&xmlGetGlobalState()->xmlBufferAllocScheme);\n+        return (&xmlGetGlobalState()->xmlBufferAllocScheme);\n@@ -824,1 +824,1 @@\n-    return (&xmlDefaultBufferSize);\n+        return (&xmlDefaultBufferSize);\n@@ -826,1 +826,1 @@\n-    return (&xmlGetGlobalState()->xmlDefaultBufferSize);\n+        return (&xmlGetGlobalState()->xmlDefaultBufferSize);\n@@ -842,1 +842,1 @@\n-    return (&xmlDefaultSAXHandler);\n+        return (&xmlDefaultSAXHandler);\n@@ -844,1 +844,1 @@\n-    return (&xmlGetGlobalState()->xmlDefaultSAXHandler);\n+        return (&xmlGetGlobalState()->xmlDefaultSAXHandler);\n@@ -852,1 +852,1 @@\n-    return (&xmlDefaultSAXLocator);\n+        return (&xmlDefaultSAXLocator);\n@@ -854,1 +854,1 @@\n-    return (&xmlGetGlobalState()->xmlDefaultSAXLocator);\n+        return (&xmlGetGlobalState()->xmlDefaultSAXLocator);\n@@ -861,1 +861,1 @@\n-    return (&xmlDoValidityCheckingDefaultValue);\n+        return (&xmlDoValidityCheckingDefaultValue);\n@@ -863,1 +863,1 @@\n-    return (&xmlGetGlobalState()->xmlDoValidityCheckingDefaultValue);\n+        return (&xmlGetGlobalState()->xmlDoValidityCheckingDefaultValue);\n@@ -878,1 +878,1 @@\n-    return (&xmlGenericError);\n+        return (&xmlGenericError);\n@@ -880,1 +880,1 @@\n-    return (&xmlGetGlobalState()->xmlGenericError);\n+        return (&xmlGetGlobalState()->xmlGenericError);\n@@ -887,1 +887,1 @@\n-    return (&xmlStructuredError);\n+        return (&xmlStructuredError);\n@@ -889,1 +889,1 @@\n-    return (&xmlGetGlobalState()->xmlStructuredError);\n+        return (&xmlGetGlobalState()->xmlStructuredError);\n@@ -896,1 +896,1 @@\n-    return (&xmlGenericErrorContext);\n+        return (&xmlGenericErrorContext);\n@@ -898,1 +898,1 @@\n-    return (&xmlGetGlobalState()->xmlGenericErrorContext);\n+        return (&xmlGetGlobalState()->xmlGenericErrorContext);\n@@ -905,1 +905,1 @@\n-    return (&xmlStructuredErrorContext);\n+        return (&xmlStructuredErrorContext);\n@@ -907,1 +907,1 @@\n-    return (&xmlGetGlobalState()->xmlStructuredErrorContext);\n+        return (&xmlGetGlobalState()->xmlStructuredErrorContext);\n@@ -914,1 +914,1 @@\n-    return (&xmlGetWarningsDefaultValue);\n+        return (&xmlGetWarningsDefaultValue);\n@@ -916,1 +916,1 @@\n-    return (&xmlGetGlobalState()->xmlGetWarningsDefaultValue);\n+        return (&xmlGetGlobalState()->xmlGetWarningsDefaultValue);\n@@ -931,1 +931,1 @@\n-    return (&xmlIndentTreeOutput);\n+        return (&xmlIndentTreeOutput);\n@@ -933,1 +933,1 @@\n-    return (&xmlGetGlobalState()->xmlIndentTreeOutput);\n+        return (&xmlGetGlobalState()->xmlIndentTreeOutput);\n@@ -948,1 +948,1 @@\n-    return (&xmlTreeIndentString);\n+        return (&xmlTreeIndentString);\n@@ -950,1 +950,1 @@\n-    return (&xmlGetGlobalState()->xmlTreeIndentString);\n+        return (&xmlGetGlobalState()->xmlTreeIndentString);\n@@ -965,1 +965,1 @@\n-    return (&xmlKeepBlanksDefaultValue);\n+        return (&xmlKeepBlanksDefaultValue);\n@@ -967,1 +967,1 @@\n-    return (&xmlGetGlobalState()->xmlKeepBlanksDefaultValue);\n+        return (&xmlGetGlobalState()->xmlKeepBlanksDefaultValue);\n@@ -982,1 +982,1 @@\n-    return (&xmlLineNumbersDefaultValue);\n+        return (&xmlLineNumbersDefaultValue);\n@@ -984,1 +984,1 @@\n-    return (&xmlGetGlobalState()->xmlLineNumbersDefaultValue);\n+        return (&xmlGetGlobalState()->xmlLineNumbersDefaultValue);\n@@ -999,1 +999,1 @@\n-    return (&xmlLoadExtDtdDefaultValue);\n+        return (&xmlLoadExtDtdDefaultValue);\n@@ -1001,1 +1001,1 @@\n-    return (&xmlGetGlobalState()->xmlLoadExtDtdDefaultValue);\n+        return (&xmlGetGlobalState()->xmlLoadExtDtdDefaultValue);\n@@ -1016,1 +1016,1 @@\n-    return (&xmlParserDebugEntities);\n+        return (&xmlParserDebugEntities);\n@@ -1018,1 +1018,1 @@\n-    return (&xmlGetGlobalState()->xmlParserDebugEntities);\n+        return (&xmlGetGlobalState()->xmlParserDebugEntities);\n@@ -1033,1 +1033,1 @@\n-    return (&xmlParserVersion);\n+        return (&xmlParserVersion);\n@@ -1035,1 +1035,1 @@\n-    return (&xmlGetGlobalState()->xmlParserVersion);\n+        return (&xmlGetGlobalState()->xmlParserVersion);\n@@ -1042,1 +1042,1 @@\n-    return (&xmlPedanticParserDefaultValue);\n+        return (&xmlPedanticParserDefaultValue);\n@@ -1044,1 +1044,1 @@\n-    return (&xmlGetGlobalState()->xmlPedanticParserDefaultValue);\n+        return (&xmlGetGlobalState()->xmlPedanticParserDefaultValue);\n@@ -1059,1 +1059,1 @@\n-    return (&xmlSaveNoEmptyTags);\n+        return (&xmlSaveNoEmptyTags);\n@@ -1061,1 +1061,1 @@\n-    return (&xmlGetGlobalState()->xmlSaveNoEmptyTags);\n+        return (&xmlGetGlobalState()->xmlSaveNoEmptyTags);\n@@ -1076,1 +1076,1 @@\n-    return (&xmlSubstituteEntitiesDefaultValue);\n+        return (&xmlSubstituteEntitiesDefaultValue);\n@@ -1078,1 +1078,1 @@\n-    return (&xmlGetGlobalState()->xmlSubstituteEntitiesDefaultValue);\n+        return (&xmlGetGlobalState()->xmlSubstituteEntitiesDefaultValue);\n@@ -1093,1 +1093,1 @@\n-    return (&xmlRegisterNodeDefaultValue);\n+        return (&xmlRegisterNodeDefaultValue);\n@@ -1095,1 +1095,1 @@\n-    return (&xmlGetGlobalState()->xmlRegisterNodeDefaultValue);\n+        return (&xmlGetGlobalState()->xmlRegisterNodeDefaultValue);\n@@ -1102,1 +1102,1 @@\n-    return (&xmlDeregisterNodeDefaultValue);\n+        return (&xmlDeregisterNodeDefaultValue);\n@@ -1104,1 +1104,1 @@\n-    return (&xmlGetGlobalState()->xmlDeregisterNodeDefaultValue);\n+        return (&xmlGetGlobalState()->xmlDeregisterNodeDefaultValue);\n@@ -1111,1 +1111,1 @@\n-    return (&xmlParserInputBufferCreateFilenameValue);\n+        return (&xmlParserInputBufferCreateFilenameValue);\n@@ -1113,1 +1113,1 @@\n-    return (&xmlGetGlobalState()->xmlParserInputBufferCreateFilenameValue);\n+        return (&xmlGetGlobalState()->xmlParserInputBufferCreateFilenameValue);\n@@ -1120,1 +1120,1 @@\n-    return (&xmlOutputBufferCreateFilenameValue);\n+        return (&xmlOutputBufferCreateFilenameValue);\n@@ -1122,1 +1122,1 @@\n-    return (&xmlGetGlobalState()->xmlOutputBufferCreateFilenameValue);\n+        return (&xmlGetGlobalState()->xmlOutputBufferCreateFilenameValue);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/globals.c","additions":74,"deletions":74,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-              const xmlChar *name2, const xmlChar *name3) {\n+                  const xmlChar *name2, const xmlChar *name3) {\n@@ -89,1 +89,1 @@\n-    char ch;\n+    unsigned long ch;\n@@ -95,4 +95,4 @@\n-    value += 30 * (*name);\n-    while ((ch = *name++) != 0) {\n-        value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n-    }\n+        value += 30 * (*name);\n+        while ((ch = *name++) != 0) {\n+            value = value ^ ((value << 5) + (value >> 3) + ch);\n+        }\n@@ -102,3 +102,3 @@\n-    while ((ch = *name2++) != 0) {\n-        value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n-    }\n+        while ((ch = *name2++) != 0) {\n+            value = value ^ ((value << 5) + (value >> 3) + ch);\n+        }\n@@ -108,3 +108,3 @@\n-    while ((ch = *name3++) != 0) {\n-        value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n-    }\n+        while ((ch = *name3++) != 0) {\n+            value = value ^ ((value << 5) + (value >> 3) + ch);\n+        }\n@@ -120,3 +120,3 @@\n-           const xmlChar *prefix, const xmlChar *name,\n-           const xmlChar *prefix2, const xmlChar *name2,\n-           const xmlChar *prefix3, const xmlChar *name3) {\n+                   const xmlChar *prefix, const xmlChar *name,\n+                   const xmlChar *prefix2, const xmlChar *name2,\n+                   const xmlChar *prefix3, const xmlChar *name3) {\n@@ -124,1 +124,1 @@\n-    char ch;\n+    unsigned long ch;\n@@ -130,1 +130,1 @@\n-    value += 30 * (*prefix);\n+        value += 30 * (*prefix);\n@@ -132,1 +132,1 @@\n-    value += 30 * (*name);\n+        value += 30 * (*name);\n@@ -135,4 +135,4 @@\n-    while ((ch = *prefix++) != 0) {\n-        value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n-    }\n-    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');\n+        while ((ch = *prefix++) != 0) {\n+            value = value ^ ((value << 5) + (value >> 3) + ch);\n+        }\n+        value = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');\n@@ -141,3 +141,3 @@\n-    while ((ch = *name++) != 0) {\n-        value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n-    }\n+        while ((ch = *name++) != 0) {\n+            value = value ^ ((value << 5) + (value >> 3) + ch);\n+        }\n@@ -147,4 +147,4 @@\n-    while ((ch = *prefix2++) != 0) {\n-        value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n-    }\n-    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');\n+        while ((ch = *prefix2++) != 0) {\n+            value = value ^ ((value << 5) + (value >> 3) + ch);\n+        }\n+        value = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');\n@@ -153,3 +153,3 @@\n-    while ((ch = *name2++) != 0) {\n-        value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n-    }\n+        while ((ch = *name2++) != 0) {\n+            value = value ^ ((value << 5) + (value >> 3) + ch);\n+        }\n@@ -159,4 +159,4 @@\n-    while ((ch = *prefix3++) != 0) {\n-        value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n-    }\n-    value = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');\n+        while ((ch = *prefix3++) != 0) {\n+            value = value ^ ((value << 5) + (value >> 3) + ch);\n+        }\n+        value = value ^ ((value << 5) + (value >> 3) + (unsigned long)':');\n@@ -165,3 +165,3 @@\n-    while ((ch = *name3++) != 0) {\n-        value = value ^ ((value << 5) + (value >> 3) + (unsigned long)ch);\n-    }\n+        while ((ch = *name3++) != 0) {\n+            value = value ^ ((value << 5) + (value >> 3) + ch);\n+        }\n@@ -191,1 +191,1 @@\n-    table->nbElems = 0;\n+        table->nbElems = 0;\n@@ -194,1 +194,1 @@\n-        memset(table->table, 0, size * sizeof(xmlHashEntry));\n+            memset(table->table, 0, size * sizeof(xmlHashEntry));\n@@ -198,1 +198,1 @@\n-        return(table);\n+            return(table);\n@@ -221,1 +221,1 @@\n-    xmlDictReference(dict);\n+        xmlDictReference(dict);\n@@ -246,1 +246,1 @@\n-    return(-1);\n+        return(-1);\n@@ -250,1 +250,1 @@\n-    return(-1);\n+        return(-1);\n@@ -259,2 +259,2 @@\n-    table->table = oldtable;\n-    return(-1);\n+        table->table = oldtable;\n+        return(-1);\n@@ -266,4 +266,4 @@\n-    a new entry needs to allocated and data copied into it from\n-    the main table. So instead, we run through the array twice, first\n-    copying all the elements in the main array (where we can't get\n-    conflicts) and then the rest, so we only free (and don't allocate)\n+        a new entry needs to allocated and data copied into it from\n+        the main table. So instead, we run through the array twice, first\n+        copying all the elements in the main array (where we can't get\n+        conflicts) and then the rest, so we only free (and don't allocate)\n@@ -272,6 +272,6 @@\n-    if (oldtable[i].valid == 0)\n-        continue;\n-    key = xmlHashComputeKey(table, oldtable[i].name, oldtable[i].name2,\n-                oldtable[i].name3);\n-    memcpy(&(table->table[key]), &(oldtable[i]), sizeof(xmlHashEntry));\n-    table->table[key].next = NULL;\n+        if (oldtable[i].valid == 0)\n+            continue;\n+        key = xmlHashComputeKey(table, oldtable[i].name, oldtable[i].name2,\n+                                oldtable[i].name3);\n+        memcpy(&(table->table[key]), &(oldtable[i]), sizeof(xmlHashEntry));\n+        table->table[key].next = NULL;\n@@ -281,18 +281,18 @@\n-    iter = oldtable[i].next;\n-    while (iter) {\n-        next = iter->next;\n-\n-        \/*\n-         * put back the entry in the new table\n-         *\/\n-\n-        key = xmlHashComputeKey(table, iter->name, iter->name2,\n-                            iter->name3);\n-        if (table->table[key].valid == 0) {\n-        memcpy(&(table->table[key]), iter, sizeof(xmlHashEntry));\n-        table->table[key].next = NULL;\n-        xmlFree(iter);\n-        } else {\n-        iter->next = table->table[key].next;\n-        table->table[key].next = iter;\n-        }\n+        iter = oldtable[i].next;\n+        while (iter) {\n+            next = iter->next;\n+\n+            \/*\n+             * put back the entry in the new table\n+             *\/\n+\n+            key = xmlHashComputeKey(table, iter->name, iter->name2,\n+                                    iter->name3);\n+            if (table->table[key].valid == 0) {\n+                memcpy(&(table->table[key]), iter, sizeof(xmlHashEntry));\n+                table->table[key].next = NULL;\n+                xmlFree(iter);\n+            } else {\n+                iter->next = table->table[key].next;\n+                table->table[key].next = iter;\n+            }\n@@ -301,1 +301,1 @@\n-        nbElem++;\n+            nbElem++;\n@@ -304,2 +304,2 @@\n-        iter = next;\n-    }\n+            iter = next;\n+        }\n@@ -312,1 +312,1 @@\n-        \"xmlHashGrow : from %d to %d, %d elems\\n\", oldsize, size, nbElem);\n+            \"xmlHashGrow : from %d to %d, %d elems\\n\", oldsize, size, nbElem);\n@@ -335,1 +335,1 @@\n-    return;\n+        return;\n@@ -337,24 +337,25 @@\n-    nbElems = table->nbElems;\n-    for(i = 0; (i < table->size) && (nbElems > 0); i++) {\n-        iter = &(table->table[i]);\n-        if (iter->valid == 0)\n-        continue;\n-        inside_table = 1;\n-        while (iter) {\n-        next = iter->next;\n-        if ((f != NULL) && (iter->payload != NULL))\n-            f(iter->payload, iter->name);\n-        if (table->dict == NULL) {\n-            if (iter->name)\n-            xmlFree(iter->name);\n-            if (iter->name2)\n-            xmlFree(iter->name2);\n-            if (iter->name3)\n-            xmlFree(iter->name3);\n-        }\n-        iter->payload = NULL;\n-        if (!inside_table)\n-            xmlFree(iter);\n-        nbElems--;\n-        inside_table = 0;\n-        iter = next;\n+        nbElems = table->nbElems;\n+        for(i = 0; (i < table->size) && (nbElems > 0); i++) {\n+            iter = &(table->table[i]);\n+            if (iter->valid == 0)\n+                continue;\n+            inside_table = 1;\n+            while (iter) {\n+                next = iter->next;\n+                if ((f != NULL) && (iter->payload != NULL))\n+                    f(iter->payload, iter->name);\n+                if (table->dict == NULL) {\n+                    if (iter->name)\n+                        xmlFree(iter->name);\n+                    if (iter->name2)\n+                        xmlFree(iter->name2);\n+                    if (iter->name3)\n+                        xmlFree(iter->name3);\n+                }\n+                iter->payload = NULL;\n+                if (!inside_table)\n+                    xmlFree(iter);\n+                nbElems--;\n+                inside_table = 0;\n+                iter = next;\n+            }\n@@ -362,2 +363,1 @@\n-    }\n-    xmlFree(table->table);\n+        xmlFree(table->table);\n@@ -412,1 +412,1 @@\n-            const xmlChar *name2, void *userdata) {\n+                const xmlChar *name2, void *userdata) {\n@@ -431,1 +431,1 @@\n-               void *userdata, xmlHashDeallocator f) {\n+                   void *userdata, xmlHashDeallocator f) {\n@@ -451,2 +451,2 @@\n-               const xmlChar *name2, void *userdata,\n-           xmlHashDeallocator f) {\n+                   const xmlChar *name2, void *userdata,\n+                   xmlHashDeallocator f) {\n@@ -482,1 +482,1 @@\n-          const xmlChar *name2) {\n+              const xmlChar *name2) {\n@@ -517,1 +517,1 @@\n-            const xmlChar *name2) {\n+                const xmlChar *name2) {\n@@ -537,2 +537,2 @@\n-             const xmlChar *name2, const xmlChar *name3,\n-         void *userdata) {\n+                 const xmlChar *name2, const xmlChar *name3,\n+                 void *userdata) {\n@@ -544,1 +544,1 @@\n-    return(-1);\n+        return(-1);\n@@ -551,4 +551,4 @@\n-        name = xmlDictLookup(table->dict, name, -1);\n-        if (name == NULL)\n-            return(-1);\n-    }\n+            name = xmlDictLookup(table->dict, name, -1);\n+            if (name == NULL)\n+                return(-1);\n+        }\n@@ -556,4 +556,4 @@\n-        name2 = xmlDictLookup(table->dict, name2, -1);\n-        if (name2 == NULL)\n-            return(-1);\n-    }\n+            name2 = xmlDictLookup(table->dict, name2, -1);\n+            if (name2 == NULL)\n+                return(-1);\n+        }\n@@ -561,4 +561,4 @@\n-        name3 = xmlDictLookup(table->dict, name3, -1);\n-        if (name3 == NULL)\n-            return(-1);\n-    }\n+            name3 = xmlDictLookup(table->dict, name3, -1);\n+            if (name3 == NULL)\n+                return(-1);\n+        }\n@@ -572,1 +572,1 @@\n-    insert = NULL;\n+        insert = NULL;\n@@ -575,20 +575,25 @@\n-        for (insert = &(table->table[key]); insert->next != NULL;\n-         insert = insert->next) {\n-        if ((insert->name == name) &&\n-            (insert->name2 == name2) &&\n-            (insert->name3 == name3))\n-            return(-1);\n-        len++;\n-        }\n-        if ((insert->name == name) &&\n-        (insert->name2 == name2) &&\n-        (insert->name3 == name3))\n-        return(-1);\n-    } else {\n-        for (insert = &(table->table[key]); insert->next != NULL;\n-         insert = insert->next) {\n-        if ((xmlStrEqual(insert->name, name)) &&\n-            (xmlStrEqual(insert->name2, name2)) &&\n-            (xmlStrEqual(insert->name3, name3)))\n-            return(-1);\n-        len++;\n+            for (insert = &(table->table[key]); insert->next != NULL;\n+                 insert = insert->next) {\n+                if ((insert->name == name) &&\n+                    (insert->name2 == name2) &&\n+                    (insert->name3 == name3))\n+                    return(-1);\n+                len++;\n+            }\n+            if ((insert->name == name) &&\n+                (insert->name2 == name2) &&\n+                (insert->name3 == name3))\n+                return(-1);\n+        } else {\n+            for (insert = &(table->table[key]); insert->next != NULL;\n+                 insert = insert->next) {\n+                if ((xmlStrEqual(insert->name, name)) &&\n+                    (xmlStrEqual(insert->name2, name2)) &&\n+                    (xmlStrEqual(insert->name3, name3)))\n+                    return(-1);\n+                len++;\n+            }\n+            if ((xmlStrEqual(insert->name, name)) &&\n+                (xmlStrEqual(insert->name2, name2)) &&\n+                (xmlStrEqual(insert->name3, name3)))\n+                return(-1);\n@@ -596,5 +601,0 @@\n-        if ((xmlStrEqual(insert->name, name)) &&\n-        (xmlStrEqual(insert->name2, name2)) &&\n-        (xmlStrEqual(insert->name3, name3)))\n-        return(-1);\n-    }\n@@ -604,1 +604,1 @@\n-    entry = &(table->table[key]);\n+        entry = &(table->table[key]);\n@@ -606,3 +606,3 @@\n-    entry = xmlMalloc(sizeof(xmlHashEntry));\n-    if (entry == NULL)\n-         return(-1);\n+        entry = xmlMalloc(sizeof(xmlHashEntry));\n+        if (entry == NULL)\n+             return(-1);\n@@ -616,3 +616,3 @@\n-    entry->name = xmlStrdup(name);\n-    entry->name2 = xmlStrdup(name2);\n-    entry->name3 = xmlStrdup(name3);\n+        entry->name = xmlStrdup(name);\n+        entry->name2 = xmlStrdup(name2);\n+        entry->name3 = xmlStrdup(name3);\n@@ -626,1 +626,1 @@\n-    insert->next = entry;\n+        insert->next = entry;\n@@ -631,1 +631,1 @@\n-    xmlHashGrow(table, MAX_HASH_LEN * table->size);\n+        xmlHashGrow(table, MAX_HASH_LEN * table->size);\n@@ -653,2 +653,2 @@\n-               const xmlChar *name2, const xmlChar *name3,\n-           void *userdata, xmlHashDeallocator f) {\n+                   const xmlChar *name2, const xmlChar *name3,\n+                   void *userdata, xmlHashDeallocator f) {\n@@ -660,1 +660,1 @@\n-    return(-1);\n+        return(-1);\n@@ -667,4 +667,4 @@\n-        name = xmlDictLookup(table->dict, name, -1);\n-        if (name == NULL)\n-            return(-1);\n-    }\n+            name = xmlDictLookup(table->dict, name, -1);\n+            if (name == NULL)\n+                return(-1);\n+        }\n@@ -672,4 +672,4 @@\n-        name2 = xmlDictLookup(table->dict, name2, -1);\n-        if (name2 == NULL)\n-            return(-1);\n-    }\n+            name2 = xmlDictLookup(table->dict, name2, -1);\n+            if (name2 == NULL)\n+                return(-1);\n+        }\n@@ -677,4 +677,4 @@\n-        name3 = xmlDictLookup(table->dict, name3, -1);\n-        if (name3 == NULL)\n-            return(-1);\n-    }\n+            name3 = xmlDictLookup(table->dict, name3, -1);\n+            if (name3 == NULL)\n+                return(-1);\n+        }\n@@ -688,1 +688,1 @@\n-    insert = NULL;\n+        insert = NULL;\n@@ -691,38 +691,39 @@\n-        for (insert = &(table->table[key]); insert->next != NULL;\n-         insert = insert->next) {\n-        if ((insert->name == name) &&\n-            (insert->name2 == name2) &&\n-            (insert->name3 == name3)) {\n-            if (f)\n-            f(insert->payload, insert->name);\n-            insert->payload = userdata;\n-            return(0);\n-        }\n-        }\n-        if ((insert->name == name) &&\n-        (insert->name2 == name2) &&\n-        (insert->name3 == name3)) {\n-        if (f)\n-            f(insert->payload, insert->name);\n-        insert->payload = userdata;\n-        return(0);\n-        }\n-    } else {\n-        for (insert = &(table->table[key]); insert->next != NULL;\n-         insert = insert->next) {\n-        if ((xmlStrEqual(insert->name, name)) &&\n-            (xmlStrEqual(insert->name2, name2)) &&\n-            (xmlStrEqual(insert->name3, name3))) {\n-            if (f)\n-            f(insert->payload, insert->name);\n-            insert->payload = userdata;\n-            return(0);\n-        }\n-        }\n-        if ((xmlStrEqual(insert->name, name)) &&\n-        (xmlStrEqual(insert->name2, name2)) &&\n-        (xmlStrEqual(insert->name3, name3))) {\n-        if (f)\n-            f(insert->payload, insert->name);\n-        insert->payload = userdata;\n-        return(0);\n+            for (insert = &(table->table[key]); insert->next != NULL;\n+                 insert = insert->next) {\n+                if ((insert->name == name) &&\n+                    (insert->name2 == name2) &&\n+                    (insert->name3 == name3)) {\n+                    if (f)\n+                        f(insert->payload, insert->name);\n+                    insert->payload = userdata;\n+                    return(0);\n+                }\n+            }\n+            if ((insert->name == name) &&\n+                (insert->name2 == name2) &&\n+                (insert->name3 == name3)) {\n+                if (f)\n+                    f(insert->payload, insert->name);\n+                insert->payload = userdata;\n+                return(0);\n+            }\n+        } else {\n+            for (insert = &(table->table[key]); insert->next != NULL;\n+                 insert = insert->next) {\n+                if ((xmlStrEqual(insert->name, name)) &&\n+                    (xmlStrEqual(insert->name2, name2)) &&\n+                    (xmlStrEqual(insert->name3, name3))) {\n+                    if (f)\n+                        f(insert->payload, insert->name);\n+                    insert->payload = userdata;\n+                    return(0);\n+                }\n+            }\n+            if ((xmlStrEqual(insert->name, name)) &&\n+                (xmlStrEqual(insert->name2, name2)) &&\n+                (xmlStrEqual(insert->name3, name3))) {\n+                if (f)\n+                    f(insert->payload, insert->name);\n+                insert->payload = userdata;\n+                return(0);\n+            }\n@@ -731,1 +732,0 @@\n-    }\n@@ -734,1 +734,1 @@\n-    entry =  &(table->table[key]);\n+        entry =  &(table->table[key]);\n@@ -736,3 +736,3 @@\n-    entry = xmlMalloc(sizeof(xmlHashEntry));\n-    if (entry == NULL)\n-         return(-1);\n+        entry = xmlMalloc(sizeof(xmlHashEntry));\n+        if (entry == NULL)\n+             return(-1);\n@@ -746,3 +746,3 @@\n-    entry->name = xmlStrdup(name);\n-    entry->name2 = xmlStrdup(name2);\n-    entry->name3 = xmlStrdup(name3);\n+        entry->name = xmlStrdup(name);\n+        entry->name2 = xmlStrdup(name2);\n+        entry->name3 = xmlStrdup(name3);\n@@ -757,1 +757,1 @@\n-    insert->next = entry;\n+        insert->next = entry;\n@@ -775,1 +775,1 @@\n-           const xmlChar *name2, const xmlChar *name3) {\n+               const xmlChar *name2, const xmlChar *name3) {\n@@ -780,1 +780,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -782,1 +782,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -785,1 +785,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -787,6 +787,6 @@\n-    for (entry = &(table->table[key]); entry != NULL; entry = entry->next) {\n-        if ((entry->name == name) &&\n-        (entry->name2 == name2) &&\n-        (entry->name3 == name3))\n-        return(entry->payload);\n-    }\n+        for (entry = &(table->table[key]); entry != NULL; entry = entry->next) {\n+            if ((entry->name == name) &&\n+                (entry->name2 == name2) &&\n+                (entry->name3 == name3))\n+                return(entry->payload);\n+        }\n@@ -795,4 +795,4 @@\n-    if ((xmlStrEqual(entry->name, name)) &&\n-        (xmlStrEqual(entry->name2, name2)) &&\n-        (xmlStrEqual(entry->name3, name3)))\n-        return(entry->payload);\n+        if ((xmlStrEqual(entry->name, name)) &&\n+            (xmlStrEqual(entry->name2, name2)) &&\n+            (xmlStrEqual(entry->name3, name3)))\n+            return(entry->payload);\n@@ -820,2 +820,2 @@\n-        const xmlChar *prefix2, const xmlChar *name2,\n-        const xmlChar *prefix3, const xmlChar *name3) {\n+                const xmlChar *prefix2, const xmlChar *name2,\n+                const xmlChar *prefix3, const xmlChar *name3) {\n@@ -826,1 +826,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -828,1 +828,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -832,1 +832,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -834,4 +834,4 @@\n-    if ((xmlStrQEqual(prefix, name, entry->name)) &&\n-        (xmlStrQEqual(prefix2, name2, entry->name2)) &&\n-        (xmlStrQEqual(prefix3, name3, entry->name3)))\n-        return(entry->payload);\n+        if ((xmlStrQEqual(prefix, name, entry->name)) &&\n+            (xmlStrQEqual(prefix2, name2, entry->name2)) &&\n+            (xmlStrQEqual(prefix3, name3, entry->name3)))\n+            return(entry->payload);\n@@ -850,1 +850,1 @@\n-             const xmlChar *name3 ATTRIBUTE_UNUSED) {\n+                     const xmlChar *name3 ATTRIBUTE_UNUSED) {\n@@ -886,1 +886,1 @@\n-    return;\n+        return;\n@@ -888,1 +888,1 @@\n-    return;\n+        return;\n@@ -891,6 +891,6 @@\n-    for(i = 0; i < table->size; i++) {\n-        if (table->table[i].valid == 0)\n-        continue;\n-        iter = &(table->table[i]);\n-        while (iter) {\n-        next = iter->next;\n+        for(i = 0; i < table->size; i++) {\n+            if (table->table[i].valid == 0)\n+                continue;\n+            iter = &(table->table[i]);\n+            while (iter) {\n+                next = iter->next;\n@@ -898,3 +898,3 @@\n-        if ((f != NULL) && (iter->payload != NULL))\n-            f(iter->payload, data, iter->name,\n-              iter->name2, iter->name3);\n+                if ((f != NULL) && (iter->payload != NULL))\n+                    f(iter->payload, data, iter->name,\n+                      iter->name2, iter->name3);\n@@ -907,1 +907,1 @@\n-                iter = &(table->table[i]);\n+                            iter = &(table->table[i]);\n@@ -909,1 +909,1 @@\n-                iter = next;\n+                        iter = next;\n@@ -911,1 +911,2 @@\n-            iter = next;\n+                    iter = next;\n+            }\n@@ -914,1 +915,0 @@\n-    }\n@@ -932,2 +932,2 @@\n-         const xmlChar *name2, const xmlChar *name3,\n-         xmlHashScanner f, void *data) {\n+             const xmlChar *name2, const xmlChar *name3,\n+             xmlHashScanner f, void *data) {\n@@ -956,2 +956,2 @@\n-         const xmlChar *name2, const xmlChar *name3,\n-         xmlHashScannerFull f, void *data) {\n+                 const xmlChar *name2, const xmlChar *name3,\n+                 xmlHashScannerFull f, void *data) {\n@@ -963,1 +963,1 @@\n-    return;\n+        return;\n@@ -965,1 +965,1 @@\n-    return;\n+        return;\n@@ -968,14 +968,15 @@\n-    for(i = 0; i < table->size; i++) {\n-        if (table->table[i].valid == 0)\n-        continue;\n-        iter = &(table->table[i]);\n-        while (iter) {\n-        next = iter->next;\n-        if (((name == NULL) || (xmlStrEqual(name, iter->name))) &&\n-            ((name2 == NULL) || (xmlStrEqual(name2, iter->name2))) &&\n-            ((name3 == NULL) || (xmlStrEqual(name3, iter->name3))) &&\n-            (iter->payload != NULL)) {\n-            f(iter->payload, data, iter->name,\n-              iter->name2, iter->name3);\n-        }\n-        iter = next;\n+        for(i = 0; i < table->size; i++) {\n+            if (table->table[i].valid == 0)\n+                continue;\n+            iter = &(table->table[i]);\n+            while (iter) {\n+                next = iter->next;\n+                if (((name == NULL) || (xmlStrEqual(name, iter->name))) &&\n+                    ((name2 == NULL) || (xmlStrEqual(name2, iter->name2))) &&\n+                    ((name3 == NULL) || (xmlStrEqual(name3, iter->name3))) &&\n+                    (iter->payload != NULL)) {\n+                    f(iter->payload, data, iter->name,\n+                      iter->name2, iter->name3);\n+                }\n+                iter = next;\n+            }\n@@ -984,1 +985,0 @@\n-    }\n@@ -1004,1 +1004,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1006,1 +1006,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1013,9 +1013,10 @@\n-    for(i = 0; i < table->size; i++) {\n-        if (table->table[i].valid == 0)\n-        continue;\n-        iter = &(table->table[i]);\n-        while (iter) {\n-        next = iter->next;\n-        xmlHashAddEntry3(ret, iter->name, iter->name2,\n-                     iter->name3, f(iter->payload, iter->name));\n-        iter = next;\n+        for(i = 0; i < table->size; i++) {\n+            if (table->table[i].valid == 0)\n+                continue;\n+            iter = &(table->table[i]);\n+            while (iter) {\n+                next = iter->next;\n+                xmlHashAddEntry3(ret, iter->name, iter->name2,\n+                                 iter->name3, f(iter->payload, iter->name));\n+                iter = next;\n+            }\n@@ -1024,1 +1025,0 @@\n-    }\n@@ -1041,1 +1041,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1058,1 +1058,1 @@\n-               xmlHashDeallocator f) {\n+                       xmlHashDeallocator f) {\n@@ -1077,1 +1077,1 @@\n-            const xmlChar *name2, xmlHashDeallocator f) {\n+                        const xmlChar *name2, xmlHashDeallocator f) {\n@@ -1116,8 +1116,8 @@\n-        if (table->dict == NULL) {\n-            if(entry->name)\n-            xmlFree(entry->name);\n-            if(entry->name2)\n-            xmlFree(entry->name2);\n-            if(entry->name3)\n-            xmlFree(entry->name3);\n-        }\n+                if (table->dict == NULL) {\n+                    if(entry->name)\n+                        xmlFree(entry->name);\n+                    if(entry->name2)\n+                        xmlFree(entry->name2);\n+                    if(entry->name3)\n+                        xmlFree(entry->name3);\n+                }\n@@ -1126,10 +1126,10 @@\n-            xmlFree(entry);\n-        } else {\n-            if (entry->next == NULL) {\n-            entry->valid = 0;\n-            } else {\n-            entry = entry->next;\n-            memcpy(&(table->table[key]), entry, sizeof(xmlHashEntry));\n-            xmlFree(entry);\n-            }\n-        }\n+                    xmlFree(entry);\n+                } else {\n+                    if (entry->next == NULL) {\n+                        entry->valid = 0;\n+                    } else {\n+                        entry = entry->next;\n+                        memcpy(&(table->table[key]), entry, sizeof(xmlHashEntry));\n+                        xmlFree(entry);\n+                    }\n+                }\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/hash.c","additions":318,"deletions":318,"binary":false,"changes":636,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-             docbEncodeEntities(unsigned char *out,\n+                     docbEncodeEntities(unsigned char *out,\n@@ -51,1 +51,1 @@\n-             docbSAXParseDoc   (xmlChar *cur,\n+                     docbSAXParseDoc   (xmlChar *cur,\n@@ -56,1 +56,1 @@\n-             docbParseDoc      (xmlChar *cur,\n+                     docbParseDoc      (xmlChar *cur,\n@@ -59,1 +59,1 @@\n-             docbSAXParseFile  (const char *filename,\n+                     docbSAXParseFile  (const char *filename,\n@@ -64,1 +64,1 @@\n-             docbParseFile     (const char *filename,\n+                     docbParseFile     (const char *filename,\n@@ -71,1 +71,1 @@\n-             docbFreeParserCtxt      (docbParserCtxtPtr ctxt);\n+                     docbFreeParserCtxt      (docbParserCtxtPtr ctxt);\n@@ -73,1 +73,1 @@\n-             docbCreatePushParserCtxt(docbSAXHandlerPtr sax,\n+                     docbCreatePushParserCtxt(docbSAXHandlerPtr sax,\n@@ -80,1 +80,1 @@\n-             docbParseChunk          (docbParserCtxtPtr ctxt,\n+                     docbParseChunk          (docbParserCtxtPtr ctxt,\n@@ -85,1 +85,1 @@\n-             docbCreateFileParserCtxt(const char *filename,\n+                     docbCreateFileParserCtxt(const char *filename,\n@@ -88,1 +88,1 @@\n-             docbParseDocument       (docbParserCtxtPtr ctxt);\n+                     docbParseDocument       (docbParserCtxtPtr ctxt);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/DOCBparser.h","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -58,5 +58,5 @@\n- *  This is a very limited representation.  It fails to tell us when\n- *  an element *requires* subelements (we only have whether they're\n- *  allowed or not), and it doesn't tell us where CDATA and PCDATA\n- *  are allowed.  Some element relationships are not fully represented:\n- *  these are flagged with the word MODIFIER\n+ *      This is a very limited representation.  It fails to tell us when\n+ *      an element *requires* subelements (we only have whether they're\n+ *      allowed or not), and it doesn't tell us where CDATA and PCDATA\n+ *      are allowed.  Some element relationships are not fully represented:\n+ *      these are flagged with the word MODIFIER\n@@ -64,1 +64,1 @@\n-    const char** subelts;       \/* allowed sub-elements of this element *\/\n+    const char** subelts;               \/* allowed sub-elements of this element *\/\n@@ -66,4 +66,4 @@\n-                       if necessary or NULL *\/\n-    const char** attrs_opt;     \/* Optional Attributes *\/\n-    const char** attrs_depr;        \/* Additional deprecated attributes *\/\n-    const char** attrs_req;     \/* Required attributes *\/\n+                                           if necessary or NULL *\/\n+    const char** attrs_opt;             \/* Optional Attributes *\/\n+    const char** attrs_depr;            \/* Additional deprecated attributes *\/\n+    const char** attrs_req;             \/* Required attributes *\/\n@@ -87,1 +87,1 @@\n-            htmlTagLookup   (const xmlChar *tag);\n+                        htmlTagLookup   (const xmlChar *tag);\n@@ -89,1 +89,1 @@\n-            htmlEntityLookup(const xmlChar *name);\n+                        htmlEntityLookup(const xmlChar *name);\n@@ -91,1 +91,1 @@\n-            htmlEntityValueLookup(unsigned int value);\n+                        htmlEntityValueLookup(unsigned int value);\n@@ -94,2 +94,2 @@\n-            htmlIsAutoClosed(htmlDocPtr doc,\n-                     htmlNodePtr elem);\n+                        htmlIsAutoClosed(htmlDocPtr doc,\n+                                         htmlNodePtr elem);\n@@ -97,3 +97,3 @@\n-            htmlAutoCloseTag(htmlDocPtr doc,\n-                     const xmlChar *name,\n-                     htmlNodePtr elem);\n+                        htmlAutoCloseTag(htmlDocPtr doc,\n+                                         const xmlChar *name,\n+                                         htmlNodePtr elem);\n@@ -101,2 +101,2 @@\n-            htmlParseEntityRef(htmlParserCtxtPtr ctxt,\n-                     const xmlChar **str);\n+                        htmlParseEntityRef(htmlParserCtxtPtr ctxt,\n+                                         const xmlChar **str);\n@@ -104,1 +104,1 @@\n-            htmlParseCharRef(htmlParserCtxtPtr ctxt);\n+                        htmlParseCharRef(htmlParserCtxtPtr ctxt);\n@@ -106,1 +106,1 @@\n-            htmlParseElement(htmlParserCtxtPtr ctxt);\n+                        htmlParseElement(htmlParserCtxtPtr ctxt);\n@@ -109,1 +109,1 @@\n-            htmlNewParserCtxt(void);\n+                        htmlNewParserCtxt(void);\n@@ -112,2 +112,2 @@\n-            htmlCreateMemoryParserCtxt(const char *buffer,\n-                           int size);\n+                        htmlCreateMemoryParserCtxt(const char *buffer,\n+                                                   int size);\n@@ -116,1 +116,1 @@\n-            htmlParseDocument(htmlParserCtxtPtr ctxt);\n+                        htmlParseDocument(htmlParserCtxtPtr ctxt);\n@@ -118,4 +118,4 @@\n-            htmlSAXParseDoc (const xmlChar *cur,\n-                     const char *encoding,\n-                     htmlSAXHandlerPtr sax,\n-                     void *userData);\n+                        htmlSAXParseDoc (const xmlChar *cur,\n+                                         const char *encoding,\n+                                         htmlSAXHandlerPtr sax,\n+                                         void *userData);\n@@ -123,2 +123,2 @@\n-            htmlParseDoc    (const xmlChar *cur,\n-                     const char *encoding);\n+                        htmlParseDoc    (const xmlChar *cur,\n+                                         const char *encoding);\n@@ -126,4 +126,4 @@\n-            htmlSAXParseFile(const char *filename,\n-                     const char *encoding,\n-                     htmlSAXHandlerPtr sax,\n-                     void *userData);\n+                        htmlSAXParseFile(const char *filename,\n+                                         const char *encoding,\n+                                         htmlSAXHandlerPtr sax,\n+                                         void *userData);\n@@ -131,2 +131,2 @@\n-            htmlParseFile   (const char *filename,\n-                     const char *encoding);\n+                        htmlParseFile   (const char *filename,\n+                                         const char *encoding);\n@@ -134,4 +134,4 @@\n-            UTF8ToHtml  (unsigned char *out,\n-                     int *outlen,\n-                     const unsigned char *in,\n-                     int *inlen);\n+                        UTF8ToHtml      (unsigned char *out,\n+                                         int *outlen,\n+                                         const unsigned char *in,\n+                                         int *inlen);\n@@ -139,4 +139,4 @@\n-            htmlEncodeEntities(unsigned char *out,\n-                     int *outlen,\n-                     const unsigned char *in,\n-                     int *inlen, int quoteChar);\n+                        htmlEncodeEntities(unsigned char *out,\n+                                         int *outlen,\n+                                         const unsigned char *in,\n+                                         int *inlen, int quoteChar);\n@@ -144,1 +144,1 @@\n-            htmlIsScriptAttribute(const xmlChar *name);\n+                        htmlIsScriptAttribute(const xmlChar *name);\n@@ -146,1 +146,1 @@\n-            htmlHandleOmittedElem(int val);\n+                        htmlHandleOmittedElem(int val);\n@@ -153,6 +153,6 @@\n-            htmlCreatePushParserCtxt(htmlSAXHandlerPtr sax,\n-                         void *user_data,\n-                         const char *chunk,\n-                         int size,\n-                         const char *filename,\n-                         xmlCharEncoding enc);\n+                        htmlCreatePushParserCtxt(htmlSAXHandlerPtr sax,\n+                                                 void *user_data,\n+                                                 const char *chunk,\n+                                                 int size,\n+                                                 const char *filename,\n+                                                 xmlCharEncoding enc);\n@@ -160,4 +160,4 @@\n-            htmlParseChunk      (htmlParserCtxtPtr ctxt,\n-                         const char *chunk,\n-                         int size,\n-                         int terminate);\n+                        htmlParseChunk          (htmlParserCtxtPtr ctxt,\n+                                                 const char *chunk,\n+                                                 int size,\n+                                                 int terminate);\n@@ -167,1 +167,1 @@\n-            htmlFreeParserCtxt  (htmlParserCtxtPtr ctxt);\n+                        htmlFreeParserCtxt      (htmlParserCtxtPtr ctxt);\n@@ -192,1 +192,1 @@\n-        htmlCtxtReset       (htmlParserCtxtPtr ctxt);\n+                htmlCtxtReset           (htmlParserCtxtPtr ctxt);\n@@ -194,2 +194,2 @@\n-        htmlCtxtUseOptions  (htmlParserCtxtPtr ctxt,\n-                     int options);\n+                htmlCtxtUseOptions      (htmlParserCtxtPtr ctxt,\n+                                         int options);\n@@ -197,4 +197,4 @@\n-        htmlReadDoc     (const xmlChar *cur,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlReadDoc             (const xmlChar *cur,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -202,3 +202,3 @@\n-        htmlReadFile        (const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlReadFile            (const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -206,5 +206,5 @@\n-        htmlReadMemory      (const char *buffer,\n-                     int size,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlReadMemory          (const char *buffer,\n+                                         int size,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -212,4 +212,4 @@\n-        htmlReadFd      (int fd,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlReadFd              (int fd,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -217,6 +217,6 @@\n-        htmlReadIO      (xmlInputReadCallback ioread,\n-                     xmlInputCloseCallback ioclose,\n-                     void *ioctx,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlReadIO              (xmlInputReadCallback ioread,\n+                                         xmlInputCloseCallback ioclose,\n+                                         void *ioctx,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -224,5 +224,5 @@\n-        htmlCtxtReadDoc     (xmlParserCtxtPtr ctxt,\n-                     const xmlChar *cur,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlCtxtReadDoc         (xmlParserCtxtPtr ctxt,\n+                                         const xmlChar *cur,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -230,4 +230,4 @@\n-        htmlCtxtReadFile        (xmlParserCtxtPtr ctxt,\n-                     const char *filename,\n-                     const char *encoding,\n-                     int options);\n+                htmlCtxtReadFile                (xmlParserCtxtPtr ctxt,\n+                                         const char *filename,\n+                                         const char *encoding,\n+                                         int options);\n@@ -235,6 +235,6 @@\n-        htmlCtxtReadMemory      (xmlParserCtxtPtr ctxt,\n-                     const char *buffer,\n-                     int size,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlCtxtReadMemory              (xmlParserCtxtPtr ctxt,\n+                                         const char *buffer,\n+                                         int size,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -242,5 +242,5 @@\n-        htmlCtxtReadFd      (xmlParserCtxtPtr ctxt,\n-                     int fd,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlCtxtReadFd          (xmlParserCtxtPtr ctxt,\n+                                         int fd,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -248,7 +248,7 @@\n-        htmlCtxtReadIO      (xmlParserCtxtPtr ctxt,\n-                     xmlInputReadCallback ioread,\n-                     xmlInputCloseCallback ioclose,\n-                     void *ioctx,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlCtxtReadIO          (xmlParserCtxtPtr ctxt,\n+                                         xmlInputReadCallback ioread,\n+                                         xmlInputCloseCallback ioclose,\n+                                         void *ioctx,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -259,1 +259,1 @@\n-  HTML_NA = 0 ,     \/* something we don't check at all *\/\n+  HTML_NA = 0 ,         \/* something we don't check at all *\/\n@@ -291,1 +291,1 @@\n-    htmlElementAllowedHere((parent), (elt)->name)\n+        htmlElementAllowedHere((parent), (elt)->name)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/HTMLparser.h","additions":113,"deletions":113,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#define HTML_TEXT_NODE      XML_TEXT_NODE\n+#define HTML_TEXT_NODE          XML_TEXT_NODE\n@@ -46,1 +46,1 @@\n-#define HTML_COMMENT_NODE   XML_COMMENT_NODE\n+#define HTML_COMMENT_NODE       XML_COMMENT_NODE\n@@ -53,1 +53,1 @@\n-#define HTML_PRESERVE_NODE  XML_CDATA_SECTION_NODE\n+#define HTML_PRESERVE_NODE      XML_CDATA_SECTION_NODE\n@@ -60,1 +60,1 @@\n-#define HTML_PI_NODE        XML_PI_NODE\n+#define HTML_PI_NODE            XML_PI_NODE\n@@ -63,2 +63,2 @@\n-        htmlNewDoc      (const xmlChar *URI,\n-                     const xmlChar *ExternalID);\n+                htmlNewDoc              (const xmlChar *URI,\n+                                         const xmlChar *ExternalID);\n@@ -66,2 +66,2 @@\n-        htmlNewDocNoDtD     (const xmlChar *URI,\n-                     const xmlChar *ExternalID);\n+                htmlNewDocNoDtD         (const xmlChar *URI,\n+                                         const xmlChar *ExternalID);\n@@ -69,1 +69,1 @@\n-        htmlGetMetaEncoding (htmlDocPtr doc);\n+                htmlGetMetaEncoding     (htmlDocPtr doc);\n@@ -71,2 +71,2 @@\n-        htmlSetMetaEncoding (htmlDocPtr doc,\n-                     const xmlChar *encoding);\n+                htmlSetMetaEncoding     (htmlDocPtr doc,\n+                                         const xmlChar *encoding);\n@@ -75,3 +75,3 @@\n-        htmlDocDumpMemory   (xmlDocPtr cur,\n-                     xmlChar **mem,\n-                     int *size);\n+                htmlDocDumpMemory       (xmlDocPtr cur,\n+                                         xmlChar **mem,\n+                                         int *size);\n@@ -79,4 +79,4 @@\n-        htmlDocDumpMemoryFormat (xmlDocPtr cur,\n-                     xmlChar **mem,\n-                     int *size,\n-                     int format);\n+                htmlDocDumpMemoryFormat (xmlDocPtr cur,\n+                                         xmlChar **mem,\n+                                         int *size,\n+                                         int format);\n@@ -84,2 +84,2 @@\n-        htmlDocDump     (FILE *f,\n-                     xmlDocPtr cur);\n+                htmlDocDump             (FILE *f,\n+                                         xmlDocPtr cur);\n@@ -87,2 +87,2 @@\n-        htmlSaveFile        (const char *filename,\n-                     xmlDocPtr cur);\n+                htmlSaveFile            (const char *filename,\n+                                         xmlDocPtr cur);\n@@ -90,3 +90,3 @@\n-        htmlNodeDump        (xmlBufferPtr buf,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur);\n+                htmlNodeDump            (xmlBufferPtr buf,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur);\n@@ -94,3 +94,3 @@\n-        htmlNodeDumpFile    (FILE *out,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur);\n+                htmlNodeDumpFile        (FILE *out,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur);\n@@ -98,5 +98,5 @@\n-        htmlNodeDumpFileFormat  (FILE *out,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur,\n-                     const char *encoding,\n-                     int format);\n+                htmlNodeDumpFileFormat  (FILE *out,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur,\n+                                         const char *encoding,\n+                                         int format);\n@@ -104,3 +104,3 @@\n-        htmlSaveFileEnc     (const char *filename,\n-                     xmlDocPtr cur,\n-                     const char *encoding);\n+                htmlSaveFileEnc         (const char *filename,\n+                                         xmlDocPtr cur,\n+                                         const char *encoding);\n@@ -108,4 +108,4 @@\n-        htmlSaveFileFormat  (const char *filename,\n-                     xmlDocPtr cur,\n-                     const char *encoding,\n-                     int format);\n+                htmlSaveFileFormat      (const char *filename,\n+                                         xmlDocPtr cur,\n+                                         const char *encoding,\n+                                         int format);\n@@ -114,5 +114,5 @@\n-        htmlNodeDumpFormatOutput(xmlOutputBufferPtr buf,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur,\n-                     const char *encoding,\n-                     int format);\n+                htmlNodeDumpFormatOutput(xmlOutputBufferPtr buf,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur,\n+                                         const char *encoding,\n+                                         int format);\n@@ -120,3 +120,3 @@\n-        htmlDocContentDumpOutput(xmlOutputBufferPtr buf,\n-                     xmlDocPtr cur,\n-                     const char *encoding);\n+                htmlDocContentDumpOutput(xmlOutputBufferPtr buf,\n+                                         xmlDocPtr cur,\n+                                         const char *encoding);\n@@ -124,4 +124,4 @@\n-        htmlDocContentDumpFormatOutput(xmlOutputBufferPtr buf,\n-                     xmlDocPtr cur,\n-                     const char *encoding,\n-                     int format);\n+                htmlDocContentDumpFormatOutput(xmlOutputBufferPtr buf,\n+                                         xmlDocPtr cur,\n+                                         const char *encoding,\n+                                         int format);\n@@ -129,4 +129,4 @@\n-        htmlNodeDumpOutput  (xmlOutputBufferPtr buf,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur,\n-                     const char *encoding);\n+                htmlNodeDumpOutput      (xmlOutputBufferPtr buf,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur,\n+                                         const char *encoding);\n@@ -137,1 +137,1 @@\n-        htmlIsBooleanAttr   (const xmlChar *name);\n+                htmlIsBooleanAttr       (const xmlChar *name);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/HTMLtree.h","additions":57,"deletions":57,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-        getPublicId         (void *ctx);\n+                getPublicId                     (void *ctx);\n@@ -29,1 +29,1 @@\n-        getSystemId         (void *ctx);\n+                getSystemId                     (void *ctx);\n@@ -31,2 +31,2 @@\n-        setDocumentLocator      (void *ctx,\n-                         xmlSAXLocatorPtr loc);\n+                setDocumentLocator              (void *ctx,\n+                                                 xmlSAXLocatorPtr loc);\n@@ -35,1 +35,1 @@\n-        getLineNumber           (void *ctx);\n+                getLineNumber                   (void *ctx);\n@@ -37,1 +37,1 @@\n-        getColumnNumber         (void *ctx);\n+                getColumnNumber                 (void *ctx);\n@@ -40,1 +40,1 @@\n-        isStandalone            (void *ctx);\n+                isStandalone                    (void *ctx);\n@@ -42,1 +42,1 @@\n-        hasInternalSubset       (void *ctx);\n+                hasInternalSubset               (void *ctx);\n@@ -44,1 +44,1 @@\n-        hasExternalSubset       (void *ctx);\n+                hasExternalSubset               (void *ctx);\n@@ -47,4 +47,4 @@\n-        internalSubset          (void *ctx,\n-                         const xmlChar *name,\n-                         const xmlChar *ExternalID,\n-                         const xmlChar *SystemID);\n+                internalSubset                  (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ExternalID,\n+                                                 const xmlChar *SystemID);\n@@ -52,4 +52,4 @@\n-        externalSubset          (void *ctx,\n-                         const xmlChar *name,\n-                         const xmlChar *ExternalID,\n-                         const xmlChar *SystemID);\n+                externalSubset                  (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ExternalID,\n+                                                 const xmlChar *SystemID);\n@@ -57,2 +57,2 @@\n-        getEntity           (void *ctx,\n-                         const xmlChar *name);\n+                getEntity                       (void *ctx,\n+                                                 const xmlChar *name);\n@@ -60,2 +60,2 @@\n-        getParameterEntity      (void *ctx,\n-                         const xmlChar *name);\n+                getParameterEntity              (void *ctx,\n+                                                 const xmlChar *name);\n@@ -63,3 +63,3 @@\n-        resolveEntity           (void *ctx,\n-                         const xmlChar *publicId,\n-                         const xmlChar *systemId);\n+                resolveEntity                   (void *ctx,\n+                                                 const xmlChar *publicId,\n+                                                 const xmlChar *systemId);\n@@ -68,30 +68,30 @@\n-        entityDecl          (void *ctx,\n-                         const xmlChar *name,\n-                         int type,\n-                         const xmlChar *publicId,\n-                         const xmlChar *systemId,\n-                         xmlChar *content);\n-XMLPUBFUN void XMLCALL\n-        attributeDecl           (void *ctx,\n-                         const xmlChar *elem,\n-                         const xmlChar *fullname,\n-                         int type,\n-                         int def,\n-                         const xmlChar *defaultValue,\n-                         xmlEnumerationPtr tree);\n-XMLPUBFUN void XMLCALL\n-        elementDecl         (void *ctx,\n-                         const xmlChar *name,\n-                         int type,\n-                         xmlElementContentPtr content);\n-XMLPUBFUN void XMLCALL\n-        notationDecl            (void *ctx,\n-                         const xmlChar *name,\n-                         const xmlChar *publicId,\n-                         const xmlChar *systemId);\n-XMLPUBFUN void XMLCALL\n-        unparsedEntityDecl      (void *ctx,\n-                         const xmlChar *name,\n-                         const xmlChar *publicId,\n-                         const xmlChar *systemId,\n-                         const xmlChar *notationName);\n+                entityDecl                      (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 int type,\n+                                                 const xmlChar *publicId,\n+                                                 const xmlChar *systemId,\n+                                                 xmlChar *content);\n+XMLPUBFUN void XMLCALL\n+                attributeDecl                   (void *ctx,\n+                                                 const xmlChar *elem,\n+                                                 const xmlChar *fullname,\n+                                                 int type,\n+                                                 int def,\n+                                                 const xmlChar *defaultValue,\n+                                                 xmlEnumerationPtr tree);\n+XMLPUBFUN void XMLCALL\n+                elementDecl                     (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 int type,\n+                                                 xmlElementContentPtr content);\n+XMLPUBFUN void XMLCALL\n+                notationDecl                    (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *publicId,\n+                                                 const xmlChar *systemId);\n+XMLPUBFUN void XMLCALL\n+                unparsedEntityDecl              (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *publicId,\n+                                                 const xmlChar *systemId,\n+                                                 const xmlChar *notationName);\n@@ -100,1 +100,1 @@\n-        startDocument           (void *ctx);\n+                startDocument                   (void *ctx);\n@@ -102,1 +102,1 @@\n-        endDocument         (void *ctx);\n+                endDocument                     (void *ctx);\n@@ -104,3 +104,3 @@\n-        attribute           (void *ctx,\n-                         const xmlChar *fullname,\n-                         const xmlChar *value);\n+                attribute                       (void *ctx,\n+                                                 const xmlChar *fullname,\n+                                                 const xmlChar *value);\n@@ -108,3 +108,3 @@\n-        startElement            (void *ctx,\n-                         const xmlChar *fullname,\n-                         const xmlChar **atts);\n+                startElement                    (void *ctx,\n+                                                 const xmlChar *fullname,\n+                                                 const xmlChar **atts);\n@@ -112,2 +112,2 @@\n-        endElement          (void *ctx,\n-                         const xmlChar *name);\n+                endElement                      (void *ctx,\n+                                                 const xmlChar *name);\n@@ -115,2 +115,2 @@\n-        reference           (void *ctx,\n-                         const xmlChar *name);\n+                reference                       (void *ctx,\n+                                                 const xmlChar *name);\n@@ -118,3 +118,3 @@\n-        characters          (void *ctx,\n-                         const xmlChar *ch,\n-                         int len);\n+                characters                      (void *ctx,\n+                                                 const xmlChar *ch,\n+                                                 int len);\n@@ -122,3 +122,3 @@\n-        ignorableWhitespace     (void *ctx,\n-                         const xmlChar *ch,\n-                         int len);\n+                ignorableWhitespace             (void *ctx,\n+                                                 const xmlChar *ch,\n+                                                 int len);\n@@ -126,3 +126,3 @@\n-        processingInstruction       (void *ctx,\n-                         const xmlChar *target,\n-                         const xmlChar *data);\n+                processingInstruction           (void *ctx,\n+                                                 const xmlChar *target,\n+                                                 const xmlChar *data);\n@@ -130,3 +130,3 @@\n-        globalNamespace         (void *ctx,\n-                         const xmlChar *href,\n-                         const xmlChar *prefix);\n+                globalNamespace                 (void *ctx,\n+                                                 const xmlChar *href,\n+                                                 const xmlChar *prefix);\n@@ -134,2 +134,2 @@\n-        setNamespace            (void *ctx,\n-                         const xmlChar *name);\n+                setNamespace                    (void *ctx,\n+                                                 const xmlChar *name);\n@@ -137,1 +137,1 @@\n-        getNamespace            (void *ctx);\n+                getNamespace                    (void *ctx);\n@@ -139,2 +139,2 @@\n-        checkNamespace          (void *ctx,\n-                         xmlChar *nameSpace);\n+                checkNamespace                  (void *ctx,\n+                                                 xmlChar *nameSpace);\n@@ -142,3 +142,3 @@\n-        namespaceDecl           (void *ctx,\n-                         const xmlChar *href,\n-                         const xmlChar *prefix);\n+                namespaceDecl                   (void *ctx,\n+                                                 const xmlChar *href,\n+                                                 const xmlChar *prefix);\n@@ -146,2 +146,2 @@\n-        comment             (void *ctx,\n-                         const xmlChar *value);\n+                comment                         (void *ctx,\n+                                                 const xmlChar *value);\n@@ -149,3 +149,3 @@\n-        cdataBlock          (void *ctx,\n-                         const xmlChar *value,\n-                         int len);\n+                cdataBlock                      (void *ctx,\n+                                                 const xmlChar *value,\n+                                                 int len);\n@@ -155,2 +155,2 @@\n-        initxmlDefaultSAXHandler    (xmlSAXHandlerV1 *hdlr,\n-                         int warning);\n+                initxmlDefaultSAXHandler        (xmlSAXHandlerV1 *hdlr,\n+                                                 int warning);\n@@ -159,1 +159,1 @@\n-        inithtmlDefaultSAXHandler   (xmlSAXHandlerV1 *hdlr);\n+                inithtmlDefaultSAXHandler       (xmlSAXHandlerV1 *hdlr);\n@@ -163,1 +163,1 @@\n-        initdocbDefaultSAXHandler   (xmlSAXHandlerV1 *hdlr);\n+                initdocbDefaultSAXHandler       (xmlSAXHandlerV1 *hdlr);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/SAX.h","additions":95,"deletions":95,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-        xmlSAX2GetPublicId      (void *ctx);\n+                xmlSAX2GetPublicId              (void *ctx);\n@@ -27,1 +27,1 @@\n-        xmlSAX2GetSystemId      (void *ctx);\n+                xmlSAX2GetSystemId              (void *ctx);\n@@ -29,2 +29,2 @@\n-        xmlSAX2SetDocumentLocator   (void *ctx,\n-                         xmlSAXLocatorPtr loc);\n+                xmlSAX2SetDocumentLocator       (void *ctx,\n+                                                 xmlSAXLocatorPtr loc);\n@@ -33,1 +33,1 @@\n-        xmlSAX2GetLineNumber        (void *ctx);\n+                xmlSAX2GetLineNumber            (void *ctx);\n@@ -35,1 +35,1 @@\n-        xmlSAX2GetColumnNumber      (void *ctx);\n+                xmlSAX2GetColumnNumber          (void *ctx);\n@@ -38,1 +38,1 @@\n-        xmlSAX2IsStandalone     (void *ctx);\n+                xmlSAX2IsStandalone             (void *ctx);\n@@ -40,1 +40,1 @@\n-        xmlSAX2HasInternalSubset    (void *ctx);\n+                xmlSAX2HasInternalSubset        (void *ctx);\n@@ -42,1 +42,1 @@\n-        xmlSAX2HasExternalSubset    (void *ctx);\n+                xmlSAX2HasExternalSubset        (void *ctx);\n@@ -45,4 +45,4 @@\n-        xmlSAX2InternalSubset       (void *ctx,\n-                         const xmlChar *name,\n-                         const xmlChar *ExternalID,\n-                         const xmlChar *SystemID);\n+                xmlSAX2InternalSubset           (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ExternalID,\n+                                                 const xmlChar *SystemID);\n@@ -50,4 +50,4 @@\n-        xmlSAX2ExternalSubset       (void *ctx,\n-                         const xmlChar *name,\n-                         const xmlChar *ExternalID,\n-                         const xmlChar *SystemID);\n+                xmlSAX2ExternalSubset           (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ExternalID,\n+                                                 const xmlChar *SystemID);\n@@ -55,2 +55,2 @@\n-        xmlSAX2GetEntity        (void *ctx,\n-                         const xmlChar *name);\n+                xmlSAX2GetEntity                (void *ctx,\n+                                                 const xmlChar *name);\n@@ -58,2 +58,2 @@\n-        xmlSAX2GetParameterEntity   (void *ctx,\n-                         const xmlChar *name);\n+                xmlSAX2GetParameterEntity       (void *ctx,\n+                                                 const xmlChar *name);\n@@ -61,3 +61,3 @@\n-        xmlSAX2ResolveEntity        (void *ctx,\n-                         const xmlChar *publicId,\n-                         const xmlChar *systemId);\n+                xmlSAX2ResolveEntity            (void *ctx,\n+                                                 const xmlChar *publicId,\n+                                                 const xmlChar *systemId);\n@@ -66,30 +66,30 @@\n-        xmlSAX2EntityDecl       (void *ctx,\n-                         const xmlChar *name,\n-                         int type,\n-                         const xmlChar *publicId,\n-                         const xmlChar *systemId,\n-                         xmlChar *content);\n-XMLPUBFUN void XMLCALL\n-        xmlSAX2AttributeDecl        (void *ctx,\n-                         const xmlChar *elem,\n-                         const xmlChar *fullname,\n-                         int type,\n-                         int def,\n-                         const xmlChar *defaultValue,\n-                         xmlEnumerationPtr tree);\n-XMLPUBFUN void XMLCALL\n-        xmlSAX2ElementDecl      (void *ctx,\n-                         const xmlChar *name,\n-                         int type,\n-                         xmlElementContentPtr content);\n-XMLPUBFUN void XMLCALL\n-        xmlSAX2NotationDecl     (void *ctx,\n-                         const xmlChar *name,\n-                         const xmlChar *publicId,\n-                         const xmlChar *systemId);\n-XMLPUBFUN void XMLCALL\n-        xmlSAX2UnparsedEntityDecl   (void *ctx,\n-                         const xmlChar *name,\n-                         const xmlChar *publicId,\n-                         const xmlChar *systemId,\n-                         const xmlChar *notationName);\n+                xmlSAX2EntityDecl               (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 int type,\n+                                                 const xmlChar *publicId,\n+                                                 const xmlChar *systemId,\n+                                                 xmlChar *content);\n+XMLPUBFUN void XMLCALL\n+                xmlSAX2AttributeDecl            (void *ctx,\n+                                                 const xmlChar *elem,\n+                                                 const xmlChar *fullname,\n+                                                 int type,\n+                                                 int def,\n+                                                 const xmlChar *defaultValue,\n+                                                 xmlEnumerationPtr tree);\n+XMLPUBFUN void XMLCALL\n+                xmlSAX2ElementDecl              (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 int type,\n+                                                 xmlElementContentPtr content);\n+XMLPUBFUN void XMLCALL\n+                xmlSAX2NotationDecl             (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *publicId,\n+                                                 const xmlChar *systemId);\n+XMLPUBFUN void XMLCALL\n+                xmlSAX2UnparsedEntityDecl       (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *publicId,\n+                                                 const xmlChar *systemId,\n+                                                 const xmlChar *notationName);\n@@ -98,1 +98,1 @@\n-        xmlSAX2StartDocument        (void *ctx);\n+                xmlSAX2StartDocument            (void *ctx);\n@@ -100,1 +100,1 @@\n-        xmlSAX2EndDocument      (void *ctx);\n+                xmlSAX2EndDocument              (void *ctx);\n@@ -105,3 +105,3 @@\n-        xmlSAX2StartElement     (void *ctx,\n-                         const xmlChar *fullname,\n-                         const xmlChar **atts);\n+                xmlSAX2StartElement             (void *ctx,\n+                                                 const xmlChar *fullname,\n+                                                 const xmlChar **atts);\n@@ -109,2 +109,2 @@\n-        xmlSAX2EndElement       (void *ctx,\n-                         const xmlChar *name);\n+                xmlSAX2EndElement               (void *ctx,\n+                                                 const xmlChar *name);\n@@ -113,36 +113,36 @@\n-        xmlSAX2StartElementNs       (void *ctx,\n-                         const xmlChar *localname,\n-                         const xmlChar *prefix,\n-                         const xmlChar *URI,\n-                         int nb_namespaces,\n-                         const xmlChar **namespaces,\n-                         int nb_attributes,\n-                         int nb_defaulted,\n-                         const xmlChar **attributes);\n-XMLPUBFUN void XMLCALL\n-        xmlSAX2EndElementNs     (void *ctx,\n-                         const xmlChar *localname,\n-                         const xmlChar *prefix,\n-                         const xmlChar *URI);\n-XMLPUBFUN void XMLCALL\n-        xmlSAX2Reference        (void *ctx,\n-                         const xmlChar *name);\n-XMLPUBFUN void XMLCALL\n-        xmlSAX2Characters       (void *ctx,\n-                         const xmlChar *ch,\n-                         int len);\n-XMLPUBFUN void XMLCALL\n-        xmlSAX2IgnorableWhitespace  (void *ctx,\n-                         const xmlChar *ch,\n-                         int len);\n-XMLPUBFUN void XMLCALL\n-        xmlSAX2ProcessingInstruction    (void *ctx,\n-                         const xmlChar *target,\n-                         const xmlChar *data);\n-XMLPUBFUN void XMLCALL\n-        xmlSAX2Comment          (void *ctx,\n-                         const xmlChar *value);\n-XMLPUBFUN void XMLCALL\n-        xmlSAX2CDataBlock       (void *ctx,\n-                         const xmlChar *value,\n-                         int len);\n+                xmlSAX2StartElementNs           (void *ctx,\n+                                                 const xmlChar *localname,\n+                                                 const xmlChar *prefix,\n+                                                 const xmlChar *URI,\n+                                                 int nb_namespaces,\n+                                                 const xmlChar **namespaces,\n+                                                 int nb_attributes,\n+                                                 int nb_defaulted,\n+                                                 const xmlChar **attributes);\n+XMLPUBFUN void XMLCALL\n+                xmlSAX2EndElementNs             (void *ctx,\n+                                                 const xmlChar *localname,\n+                                                 const xmlChar *prefix,\n+                                                 const xmlChar *URI);\n+XMLPUBFUN void XMLCALL\n+                xmlSAX2Reference                (void *ctx,\n+                                                 const xmlChar *name);\n+XMLPUBFUN void XMLCALL\n+                xmlSAX2Characters               (void *ctx,\n+                                                 const xmlChar *ch,\n+                                                 int len);\n+XMLPUBFUN void XMLCALL\n+                xmlSAX2IgnorableWhitespace      (void *ctx,\n+                                                 const xmlChar *ch,\n+                                                 int len);\n+XMLPUBFUN void XMLCALL\n+                xmlSAX2ProcessingInstruction    (void *ctx,\n+                                                 const xmlChar *target,\n+                                                 const xmlChar *data);\n+XMLPUBFUN void XMLCALL\n+                xmlSAX2Comment                  (void *ctx,\n+                                                 const xmlChar *value);\n+XMLPUBFUN void XMLCALL\n+                xmlSAX2CDataBlock               (void *ctx,\n+                                                 const xmlChar *value,\n+                                                 int len);\n@@ -152,1 +152,1 @@\n-        xmlSAXDefaultVersion        (int version);\n+                xmlSAXDefaultVersion            (int version);\n@@ -156,2 +156,2 @@\n-        xmlSAXVersion           (xmlSAXHandler *hdlr,\n-                         int version);\n+                xmlSAXVersion                   (xmlSAXHandler *hdlr,\n+                                                 int version);\n@@ -159,2 +159,2 @@\n-        xmlSAX2InitDefaultSAXHandler    (xmlSAXHandler *hdlr,\n-                         int warning);\n+                xmlSAX2InitDefaultSAXHandler    (xmlSAXHandler *hdlr,\n+                                                 int warning);\n@@ -163,1 +163,1 @@\n-        xmlSAX2InitHtmlDefaultSAXHandler(xmlSAXHandler *hdlr);\n+                xmlSAX2InitHtmlDefaultSAXHandler(xmlSAXHandler *hdlr);\n@@ -165,1 +165,1 @@\n-        htmlDefaultSAXHandlerInit   (void);\n+                htmlDefaultSAXHandlerInit       (void);\n@@ -169,1 +169,1 @@\n-        xmlSAX2InitDocbDefaultSAXHandler(xmlSAXHandler *hdlr);\n+                xmlSAX2InitDocbDefaultSAXHandler(xmlSAXHandler *hdlr);\n@@ -171,1 +171,1 @@\n-        docbDefaultSAXHandlerInit   (void);\n+                docbDefaultSAXHandlerInit       (void);\n@@ -174,1 +174,1 @@\n-        xmlDefaultSAXHandlerInit    (void);\n+                xmlDefaultSAXHandlerInit        (void);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/SAX2.h","additions":107,"deletions":107,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -70,6 +70,6 @@\n-        xmlC14NDocSaveTo    (xmlDocPtr doc,\n-                     xmlNodeSetPtr nodes,\n-                     int mode, \/* a xmlC14NMode *\/\n-                     xmlChar **inclusive_ns_prefixes,\n-                     int with_comments,\n-                     xmlOutputBufferPtr buf);\n+                xmlC14NDocSaveTo        (xmlDocPtr doc,\n+                                         xmlNodeSetPtr nodes,\n+                                         int mode, \/* a xmlC14NMode *\/\n+                                         xmlChar **inclusive_ns_prefixes,\n+                                         int with_comments,\n+                                         xmlOutputBufferPtr buf);\n@@ -78,6 +78,6 @@\n-        xmlC14NDocDumpMemory    (xmlDocPtr doc,\n-                     xmlNodeSetPtr nodes,\n-                     int mode, \/* a xmlC14NMode *\/\n-                     xmlChar **inclusive_ns_prefixes,\n-                     int with_comments,\n-                     xmlChar **doc_txt_ptr);\n+                xmlC14NDocDumpMemory    (xmlDocPtr doc,\n+                                         xmlNodeSetPtr nodes,\n+                                         int mode, \/* a xmlC14NMode *\/\n+                                         xmlChar **inclusive_ns_prefixes,\n+                                         int with_comments,\n+                                         xmlChar **doc_txt_ptr);\n@@ -86,7 +86,7 @@\n-        xmlC14NDocSave      (xmlDocPtr doc,\n-                     xmlNodeSetPtr nodes,\n-                     int mode, \/* a xmlC14NMode *\/\n-                     xmlChar **inclusive_ns_prefixes,\n-                     int with_comments,\n-                     const char* filename,\n-                     int compression);\n+                xmlC14NDocSave          (xmlDocPtr doc,\n+                                         xmlNodeSetPtr nodes,\n+                                         int mode, \/* a xmlC14NMode *\/\n+                                         xmlChar **inclusive_ns_prefixes,\n+                                         int with_comments,\n+                                         const char* filename,\n+                                         int compression);\n@@ -109,2 +109,2 @@\n-                     xmlNodePtr node,\n-                     xmlNodePtr parent);\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr parent);\n@@ -113,7 +113,7 @@\n-        xmlC14NExecute      (xmlDocPtr doc,\n-                     xmlC14NIsVisibleCallback is_visible_callback,\n-                     void* user_data,\n-                     int mode, \/* a xmlC14NMode *\/\n-                     xmlChar **inclusive_ns_prefixes,\n-                     int with_comments,\n-                     xmlOutputBufferPtr buf);\n+                xmlC14NExecute          (xmlDocPtr doc,\n+                                         xmlC14NIsVisibleCallback is_visible_callback,\n+                                         void* user_data,\n+                                         int mode, \/* a xmlC14NMode *\/\n+                                         xmlChar **inclusive_ns_prefixes,\n+                                         int with_comments,\n+                                         xmlOutputBufferPtr buf);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/c14n.h","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#define XML_CATALOGS_NAMESPACE                  \\\n+#define XML_CATALOGS_NAMESPACE                                  \\\n@@ -44,1 +44,1 @@\n-#define XML_CATALOG_PI                      \\\n+#define XML_CATALOG_PI                                          \\\n@@ -70,1 +70,1 @@\n-        xmlNewCatalog       (int sgml);\n+                xmlNewCatalog           (int sgml);\n@@ -72,1 +72,1 @@\n-        xmlLoadACatalog     (const char *filename);\n+                xmlLoadACatalog         (const char *filename);\n@@ -74,1 +74,1 @@\n-        xmlLoadSGMLSuperCatalog (const char *filename);\n+                xmlLoadSGMLSuperCatalog (const char *filename);\n@@ -76,1 +76,1 @@\n-        xmlConvertSGMLCatalog   (xmlCatalogPtr catal);\n+                xmlConvertSGMLCatalog   (xmlCatalogPtr catal);\n@@ -78,4 +78,4 @@\n-        xmlACatalogAdd      (xmlCatalogPtr catal,\n-                     const xmlChar *type,\n-                     const xmlChar *orig,\n-                     const xmlChar *replace);\n+                xmlACatalogAdd          (xmlCatalogPtr catal,\n+                                         const xmlChar *type,\n+                                         const xmlChar *orig,\n+                                         const xmlChar *replace);\n@@ -83,2 +83,2 @@\n-        xmlACatalogRemove   (xmlCatalogPtr catal,\n-                     const xmlChar *value);\n+                xmlACatalogRemove       (xmlCatalogPtr catal,\n+                                         const xmlChar *value);\n@@ -86,3 +86,3 @@\n-        xmlACatalogResolve  (xmlCatalogPtr catal,\n-                     const xmlChar *pubID,\n-                                     const xmlChar *sysID);\n+                xmlACatalogResolve      (xmlCatalogPtr catal,\n+                                         const xmlChar *pubID,\n+                                         const xmlChar *sysID);\n@@ -90,2 +90,2 @@\n-        xmlACatalogResolveSystem(xmlCatalogPtr catal,\n-                     const xmlChar *sysID);\n+                xmlACatalogResolveSystem(xmlCatalogPtr catal,\n+                                         const xmlChar *sysID);\n@@ -93,2 +93,2 @@\n-        xmlACatalogResolvePublic(xmlCatalogPtr catal,\n-                     const xmlChar *pubID);\n+                xmlACatalogResolvePublic(xmlCatalogPtr catal,\n+                                         const xmlChar *pubID);\n@@ -96,2 +96,2 @@\n-        xmlACatalogResolveURI   (xmlCatalogPtr catal,\n-                     const xmlChar *URI);\n+                xmlACatalogResolveURI   (xmlCatalogPtr catal,\n+                                         const xmlChar *URI);\n@@ -100,2 +100,2 @@\n-        xmlACatalogDump     (xmlCatalogPtr catal,\n-                     FILE *out);\n+                xmlACatalogDump         (xmlCatalogPtr catal,\n+                                         FILE *out);\n@@ -104,1 +104,1 @@\n-        xmlFreeCatalog      (xmlCatalogPtr catal);\n+                xmlFreeCatalog          (xmlCatalogPtr catal);\n@@ -106,1 +106,1 @@\n-        xmlCatalogIsEmpty   (xmlCatalogPtr catal);\n+                xmlCatalogIsEmpty       (xmlCatalogPtr catal);\n@@ -112,1 +112,1 @@\n-        xmlInitializeCatalog    (void);\n+                xmlInitializeCatalog    (void);\n@@ -114,1 +114,1 @@\n-        xmlLoadCatalog      (const char *filename);\n+                xmlLoadCatalog          (const char *filename);\n@@ -116,1 +116,1 @@\n-        xmlLoadCatalogs     (const char *paths);\n+                xmlLoadCatalogs         (const char *paths);\n@@ -118,1 +118,1 @@\n-        xmlCatalogCleanup   (void);\n+                xmlCatalogCleanup       (void);\n@@ -121,1 +121,1 @@\n-        xmlCatalogDump      (FILE *out);\n+                xmlCatalogDump          (FILE *out);\n@@ -124,2 +124,2 @@\n-        xmlCatalogResolve   (const xmlChar *pubID,\n-                                     const xmlChar *sysID);\n+                xmlCatalogResolve       (const xmlChar *pubID,\n+                                         const xmlChar *sysID);\n@@ -127,1 +127,1 @@\n-        xmlCatalogResolveSystem (const xmlChar *sysID);\n+                xmlCatalogResolveSystem (const xmlChar *sysID);\n@@ -129,1 +129,1 @@\n-        xmlCatalogResolvePublic (const xmlChar *pubID);\n+                xmlCatalogResolvePublic (const xmlChar *pubID);\n@@ -131,1 +131,1 @@\n-        xmlCatalogResolveURI    (const xmlChar *URI);\n+                xmlCatalogResolveURI    (const xmlChar *URI);\n@@ -133,3 +133,3 @@\n-        xmlCatalogAdd       (const xmlChar *type,\n-                     const xmlChar *orig,\n-                     const xmlChar *replace);\n+                xmlCatalogAdd           (const xmlChar *type,\n+                                         const xmlChar *orig,\n+                                         const xmlChar *replace);\n@@ -137,1 +137,1 @@\n-        xmlCatalogRemove    (const xmlChar *value);\n+                xmlCatalogRemove        (const xmlChar *value);\n@@ -139,1 +139,1 @@\n-        xmlParseCatalogFile (const char *filename);\n+                xmlParseCatalogFile     (const char *filename);\n@@ -141,1 +141,1 @@\n-        xmlCatalogConvert   (void);\n+                xmlCatalogConvert       (void);\n@@ -148,1 +148,1 @@\n-        xmlCatalogFreeLocal (void *catalogs);\n+                xmlCatalogFreeLocal     (void *catalogs);\n@@ -150,2 +150,2 @@\n-        xmlCatalogAddLocal  (void *catalogs,\n-                     const xmlChar *URL);\n+                xmlCatalogAddLocal      (void *catalogs,\n+                                         const xmlChar *URL);\n@@ -153,3 +153,3 @@\n-        xmlCatalogLocalResolve  (void *catalogs,\n-                     const xmlChar *pubID,\n-                                     const xmlChar *sysID);\n+                xmlCatalogLocalResolve  (void *catalogs,\n+                                         const xmlChar *pubID,\n+                                         const xmlChar *sysID);\n@@ -157,2 +157,2 @@\n-        xmlCatalogLocalResolveURI(void *catalogs,\n-                     const xmlChar *URI);\n+                xmlCatalogLocalResolveURI(void *catalogs,\n+                                         const xmlChar *URI);\n@@ -163,1 +163,1 @@\n-        xmlCatalogSetDebug  (int level);\n+                xmlCatalogSetDebug      (int level);\n@@ -165,1 +165,1 @@\n-        xmlCatalogSetDefaultPrefer(xmlCatalogPrefer prefer);\n+                xmlCatalogSetDefaultPrefer(xmlCatalogPrefer prefer);\n@@ -167,1 +167,1 @@\n-        xmlCatalogSetDefaults   (xmlCatalogAllow allow);\n+                xmlCatalogSetDefaults   (xmlCatalogAllow allow);\n@@ -169,1 +169,1 @@\n-        xmlCatalogGetDefaults   (void);\n+                xmlCatalogGetDefaults   (void);\n@@ -174,1 +174,1 @@\n-        xmlCatalogGetSystem (const xmlChar *sysID);\n+                xmlCatalogGetSystem     (const xmlChar *sysID);\n@@ -176,1 +176,1 @@\n-        xmlCatalogGetPublic (const xmlChar *pubID);\n+                xmlCatalogGetPublic     (const xmlChar *pubID);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/catalog.h","additions":55,"deletions":55,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-    unsigned short  low;\n-    unsigned short  high;\n+    unsigned short      low;\n+    unsigned short      high;\n@@ -38,2 +38,2 @@\n-    unsigned int    low;\n-    unsigned int    high;\n+    unsigned int        low;\n+    unsigned int        high;\n@@ -45,2 +45,2 @@\n-    int         nbShortRange;\n-    int         nbLongRange;\n+    int                 nbShortRange;\n+    int                 nbLongRange;\n@@ -55,1 +55,1 @@\n-        xmlCharInRange(unsigned int val, const xmlChRangeGroup *group);\n+                xmlCharInRange(unsigned int val, const xmlChRangeGroup *group);\n@@ -64,5 +64,5 @@\n-#define xmlIsBaseChar_ch(c) (((0x41 <= (c)) && ((c) <= 0x5a)) || \\\n-                 ((0x61 <= (c)) && ((c) <= 0x7a)) || \\\n-                 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \\\n-                 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \\\n-                  (0xf8 <= (c)))\n+#define xmlIsBaseChar_ch(c)     (((0x41 <= (c)) && ((c) <= 0x5a)) || \\\n+                                 ((0x61 <= (c)) && ((c) <= 0x7a)) || \\\n+                                 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \\\n+                                 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \\\n+                                  (0xf8 <= (c)))\n@@ -76,3 +76,3 @@\n-#define xmlIsBaseCharQ(c)   (((c) < 0x100) ? \\\n-                 xmlIsBaseChar_ch((c)) : \\\n-                 xmlCharInRange((c), &xmlIsBaseCharGroup))\n+#define xmlIsBaseCharQ(c)       (((c) < 0x100) ? \\\n+                                 xmlIsBaseChar_ch((c)) : \\\n+                                 xmlCharInRange((c), &xmlIsBaseCharGroup))\n@@ -88,3 +88,3 @@\n-#define xmlIsBlank_ch(c)    (((c) == 0x20) || \\\n-                 ((0x9 <= (c)) && ((c) <= 0xa)) || \\\n-                 ((c) == 0xd))\n+#define xmlIsBlank_ch(c)        (((c) == 0x20) || \\\n+                                 ((0x9 <= (c)) && ((c) <= 0xa)) || \\\n+                                 ((c) == 0xd))\n@@ -98,2 +98,2 @@\n-#define xmlIsBlankQ(c)      (((c) < 0x100) ? \\\n-                 xmlIsBlank_ch((c)) : 0)\n+#define xmlIsBlankQ(c)          (((c) < 0x100) ? \\\n+                                 xmlIsBlank_ch((c)) : 0)\n@@ -108,3 +108,3 @@\n-#define xmlIsChar_ch(c)     (((0x9 <= (c)) && ((c) <= 0xa)) || \\\n-                 ((c) == 0xd) || \\\n-                  (0x20 <= (c)))\n+#define xmlIsChar_ch(c)         (((0x9 <= (c)) && ((c) <= 0xa)) || \\\n+                                 ((c) == 0xd) || \\\n+                                  (0x20 <= (c)))\n@@ -118,5 +118,5 @@\n-#define xmlIsCharQ(c)       (((c) < 0x100) ? \\\n-                 xmlIsChar_ch((c)) :\\\n-                (((0x100 <= (c)) && ((c) <= 0xd7ff)) || \\\n-                 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \\\n-                 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))\n+#define xmlIsCharQ(c)           (((c) < 0x100) ? \\\n+                                 xmlIsChar_ch((c)) :\\\n+                                (((0x100 <= (c)) && ((c) <= 0xd7ff)) || \\\n+                                 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \\\n+                                 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))\n@@ -132,3 +132,3 @@\n-#define xmlIsCombiningQ(c)  (((c) < 0x100) ? \\\n-                 0 : \\\n-                 xmlCharInRange((c), &xmlIsCombiningGroup))\n+#define xmlIsCombiningQ(c)      (((c) < 0x100) ? \\\n+                                 0 : \\\n+                                 xmlCharInRange((c), &xmlIsCombiningGroup))\n@@ -144,1 +144,1 @@\n-#define xmlIsDigit_ch(c)    (((0x30 <= (c)) && ((c) <= 0x39)))\n+#define xmlIsDigit_ch(c)        (((0x30 <= (c)) && ((c) <= 0x39)))\n@@ -152,3 +152,3 @@\n-#define xmlIsDigitQ(c)      (((c) < 0x100) ? \\\n-                 xmlIsDigit_ch((c)) : \\\n-                 xmlCharInRange((c), &xmlIsDigitGroup))\n+#define xmlIsDigitQ(c)          (((c) < 0x100) ? \\\n+                                 xmlIsDigit_ch((c)) : \\\n+                                 xmlCharInRange((c), &xmlIsDigitGroup))\n@@ -164,1 +164,1 @@\n-#define xmlIsExtender_ch(c) (((c) == 0xb7))\n+#define xmlIsExtender_ch(c)     (((c) == 0xb7))\n@@ -172,3 +172,3 @@\n-#define xmlIsExtenderQ(c)   (((c) < 0x100) ? \\\n-                 xmlIsExtender_ch((c)) : \\\n-                 xmlCharInRange((c), &xmlIsExtenderGroup))\n+#define xmlIsExtenderQ(c)       (((c) < 0x100) ? \\\n+                                 xmlIsExtender_ch((c)) : \\\n+                                 xmlCharInRange((c), &xmlIsExtenderGroup))\n@@ -185,4 +185,4 @@\n-                 0 :\\\n-                (((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \\\n-                 ((c) == 0x3007) || \\\n-                 ((0x3021 <= (c)) && ((c) <= 0x3029))))\n+                                 0 :\\\n+                                (((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \\\n+                                 ((c) == 0x3007) || \\\n+                                 ((0x3021 <= (c)) && ((c) <= 0x3029))))\n@@ -207,2 +207,2 @@\n-#define xmlIsPubidCharQ(c)  (((c) < 0x100) ? \\\n-                 xmlIsPubidChar_ch((c)) : 0)\n+#define xmlIsPubidCharQ(c)      (((c) < 0x100) ? \\\n+                                 xmlIsPubidChar_ch((c)) : 0)\n@@ -211,1 +211,1 @@\n-        xmlIsBaseChar(unsigned int ch);\n+                xmlIsBaseChar(unsigned int ch);\n@@ -213,1 +213,1 @@\n-        xmlIsBlank(unsigned int ch);\n+                xmlIsBlank(unsigned int ch);\n@@ -215,1 +215,1 @@\n-        xmlIsChar(unsigned int ch);\n+                xmlIsChar(unsigned int ch);\n@@ -217,1 +217,1 @@\n-        xmlIsCombining(unsigned int ch);\n+                xmlIsCombining(unsigned int ch);\n@@ -219,1 +219,1 @@\n-        xmlIsDigit(unsigned int ch);\n+                xmlIsDigit(unsigned int ch);\n@@ -221,1 +221,1 @@\n-        xmlIsExtender(unsigned int ch);\n+                xmlIsExtender(unsigned int ch);\n@@ -223,1 +223,1 @@\n-        xmlIsIdeographic(unsigned int ch);\n+                xmlIsIdeographic(unsigned int ch);\n@@ -225,1 +225,1 @@\n-        xmlIsPubidChar(unsigned int ch);\n+                xmlIsPubidChar(unsigned int ch);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/chvalid.h","additions":53,"deletions":53,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-    xmlDebugDumpString  (FILE *output,\n-                 const xmlChar *str);\n+        xmlDebugDumpString      (FILE *output,\n+                                 const xmlChar *str);\n@@ -32,3 +32,3 @@\n-    xmlDebugDumpAttr    (FILE *output,\n-                 xmlAttrPtr attr,\n-                 int depth);\n+        xmlDebugDumpAttr        (FILE *output,\n+                                 xmlAttrPtr attr,\n+                                 int depth);\n@@ -36,3 +36,3 @@\n-    xmlDebugDumpAttrList    (FILE *output,\n-                 xmlAttrPtr attr,\n-                 int depth);\n+        xmlDebugDumpAttrList    (FILE *output,\n+                                 xmlAttrPtr attr,\n+                                 int depth);\n@@ -40,3 +40,3 @@\n-    xmlDebugDumpOneNode (FILE *output,\n-                 xmlNodePtr node,\n-                 int depth);\n+        xmlDebugDumpOneNode     (FILE *output,\n+                                 xmlNodePtr node,\n+                                 int depth);\n@@ -44,3 +44,3 @@\n-    xmlDebugDumpNode    (FILE *output,\n-                 xmlNodePtr node,\n-                 int depth);\n+        xmlDebugDumpNode        (FILE *output,\n+                                 xmlNodePtr node,\n+                                 int depth);\n@@ -48,3 +48,3 @@\n-    xmlDebugDumpNodeList    (FILE *output,\n-                 xmlNodePtr node,\n-                 int depth);\n+        xmlDebugDumpNodeList    (FILE *output,\n+                                 xmlNodePtr node,\n+                                 int depth);\n@@ -52,2 +52,2 @@\n-    xmlDebugDumpDocumentHead(FILE *output,\n-                 xmlDocPtr doc);\n+        xmlDebugDumpDocumentHead(FILE *output,\n+                                 xmlDocPtr doc);\n@@ -55,2 +55,2 @@\n-    xmlDebugDumpDocument    (FILE *output,\n-                 xmlDocPtr doc);\n+        xmlDebugDumpDocument    (FILE *output,\n+                                 xmlDocPtr doc);\n@@ -58,2 +58,2 @@\n-    xmlDebugDumpDTD     (FILE *output,\n-                 xmlDtdPtr dtd);\n+        xmlDebugDumpDTD         (FILE *output,\n+                                 xmlDtdPtr dtd);\n@@ -61,2 +61,2 @@\n-    xmlDebugDumpEntities    (FILE *output,\n-                 xmlDocPtr doc);\n+        xmlDebugDumpEntities    (FILE *output,\n+                                 xmlDocPtr doc);\n@@ -65,3 +65,3 @@\n- *                              *\n- *          Checking routines           *\n- *                              *\n+ *                                                              *\n+ *                      Checking routines                       *\n+ *                                                              *\n@@ -71,2 +71,2 @@\n-    xmlDebugCheckDocument   (FILE * output,\n-                 xmlDocPtr doc);\n+        xmlDebugCheckDocument   (FILE * output,\n+                                 xmlDocPtr doc);\n@@ -75,3 +75,3 @@\n- *                              *\n- *          XML shell helpers           *\n- *                              *\n+ *                                                              *\n+ *                      XML shell helpers                       *\n+ *                                                              *\n@@ -81,1 +81,1 @@\n-    xmlLsOneNode        (FILE *output, xmlNodePtr node);\n+        xmlLsOneNode            (FILE *output, xmlNodePtr node);\n@@ -83,1 +83,1 @@\n-    xmlLsCountNode      (xmlNodePtr node);\n+        xmlLsCountNode          (xmlNodePtr node);\n@@ -86,1 +86,1 @@\n-    xmlBoolToText       (int boolval);\n+        xmlBoolToText           (int boolval);\n@@ -89,3 +89,3 @@\n- *                              *\n- *   The XML shell related structures and functions     *\n- *                              *\n+ *                                                              *\n+ *       The XML shell related structures and functions         *\n+ *                                                              *\n@@ -136,2 +136,2 @@\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n+                             xmlNodePtr node,\n+                             xmlNodePtr node2);\n@@ -140,2 +140,2 @@\n-    xmlShellPrintXPathError (int errorType,\n-                 const char *arg);\n+        xmlShellPrintXPathError (int errorType,\n+                                 const char *arg);\n@@ -143,1 +143,1 @@\n-    xmlShellPrintXPathResult(xmlXPathObjectPtr list);\n+        xmlShellPrintXPathResult(xmlXPathObjectPtr list);\n@@ -145,4 +145,4 @@\n-    xmlShellList        (xmlShellCtxtPtr ctxt,\n-                 char *arg,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n+        xmlShellList            (xmlShellCtxtPtr ctxt,\n+                                 char *arg,\n+                                 xmlNodePtr node,\n+                                 xmlNodePtr node2);\n@@ -150,4 +150,4 @@\n-    xmlShellBase        (xmlShellCtxtPtr ctxt,\n-                 char *arg,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n+        xmlShellBase            (xmlShellCtxtPtr ctxt,\n+                                 char *arg,\n+                                 xmlNodePtr node,\n+                                 xmlNodePtr node2);\n@@ -155,4 +155,4 @@\n-    xmlShellDir     (xmlShellCtxtPtr ctxt,\n-                 char *arg,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n+        xmlShellDir             (xmlShellCtxtPtr ctxt,\n+                                 char *arg,\n+                                 xmlNodePtr node,\n+                                 xmlNodePtr node2);\n@@ -160,4 +160,4 @@\n-    xmlShellLoad        (xmlShellCtxtPtr ctxt,\n-                 char *filename,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n+        xmlShellLoad            (xmlShellCtxtPtr ctxt,\n+                                 char *filename,\n+                                 xmlNodePtr node,\n+                                 xmlNodePtr node2);\n@@ -166,1 +166,1 @@\n-    xmlShellPrintNode   (xmlNodePtr node);\n+        xmlShellPrintNode       (xmlNodePtr node);\n@@ -168,4 +168,4 @@\n-    xmlShellCat     (xmlShellCtxtPtr ctxt,\n-                 char *arg,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n+        xmlShellCat             (xmlShellCtxtPtr ctxt,\n+                                 char *arg,\n+                                 xmlNodePtr node,\n+                                 xmlNodePtr node2);\n@@ -173,4 +173,4 @@\n-    xmlShellWrite       (xmlShellCtxtPtr ctxt,\n-                 char *filename,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n+        xmlShellWrite           (xmlShellCtxtPtr ctxt,\n+                                 char *filename,\n+                                 xmlNodePtr node,\n+                                 xmlNodePtr node2);\n@@ -178,4 +178,4 @@\n-    xmlShellSave        (xmlShellCtxtPtr ctxt,\n-                 char *filename,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n+        xmlShellSave            (xmlShellCtxtPtr ctxt,\n+                                 char *filename,\n+                                 xmlNodePtr node,\n+                                 xmlNodePtr node2);\n@@ -185,4 +185,4 @@\n-    xmlShellValidate    (xmlShellCtxtPtr ctxt,\n-                 char *dtd,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n+        xmlShellValidate        (xmlShellCtxtPtr ctxt,\n+                                 char *dtd,\n+                                 xmlNodePtr node,\n+                                 xmlNodePtr node2);\n@@ -191,4 +191,4 @@\n-    xmlShellDu      (xmlShellCtxtPtr ctxt,\n-                 char *arg,\n-                 xmlNodePtr tree,\n-                 xmlNodePtr node2);\n+        xmlShellDu              (xmlShellCtxtPtr ctxt,\n+                                 char *arg,\n+                                 xmlNodePtr tree,\n+                                 xmlNodePtr node2);\n@@ -196,4 +196,4 @@\n-    xmlShellPwd     (xmlShellCtxtPtr ctxt,\n-                 char *buffer,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n+        xmlShellPwd             (xmlShellCtxtPtr ctxt,\n+                                 char *buffer,\n+                                 xmlNodePtr node,\n+                                 xmlNodePtr node2);\n@@ -205,4 +205,4 @@\n-    xmlShell        (xmlDocPtr doc,\n-                 char *filename,\n-                 xmlShellReadlineFunc input,\n-                 FILE *output);\n+        xmlShell                (xmlDocPtr doc,\n+                                 char *filename,\n+                                 xmlShellReadlineFunc input,\n+                                 FILE *output);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/debugXML.h","additions":89,"deletions":89,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-            xmlDictCreate   (void);\n+                        xmlDictCreate   (void);\n@@ -38,1 +38,1 @@\n-            xmlDictSetLimit (xmlDictPtr dict,\n+                        xmlDictSetLimit (xmlDictPtr dict,\n@@ -41,1 +41,1 @@\n-            xmlDictGetUsage (xmlDictPtr dict);\n+                        xmlDictGetUsage (xmlDictPtr dict);\n@@ -43,1 +43,1 @@\n-            xmlDictCreateSub(xmlDictPtr sub);\n+                        xmlDictCreateSub(xmlDictPtr sub);\n@@ -45,1 +45,1 @@\n-            xmlDictReference(xmlDictPtr dict);\n+                        xmlDictReference(xmlDictPtr dict);\n@@ -47,1 +47,1 @@\n-            xmlDictFree (xmlDictPtr dict);\n+                        xmlDictFree     (xmlDictPtr dict);\n@@ -53,3 +53,3 @@\n-            xmlDictLookup   (xmlDictPtr dict,\n-                                 const xmlChar *name,\n-                                 int len);\n+                        xmlDictLookup   (xmlDictPtr dict,\n+                                         const xmlChar *name,\n+                                         int len);\n@@ -57,3 +57,3 @@\n-            xmlDictExists   (xmlDictPtr dict,\n-                                 const xmlChar *name,\n-                                 int len);\n+                        xmlDictExists   (xmlDictPtr dict,\n+                                         const xmlChar *name,\n+                                         int len);\n@@ -61,3 +61,3 @@\n-            xmlDictQLookup  (xmlDictPtr dict,\n-                                 const xmlChar *prefix,\n-                                 const xmlChar *name);\n+                        xmlDictQLookup  (xmlDictPtr dict,\n+                                         const xmlChar *prefix,\n+                                         const xmlChar *name);\n@@ -65,2 +65,2 @@\n-            xmlDictOwns (xmlDictPtr dict,\n-                     const xmlChar *str);\n+                        xmlDictOwns     (xmlDictPtr dict,\n+                                         const xmlChar *str);\n@@ -68,1 +68,1 @@\n-            xmlDictSize (xmlDictPtr dict);\n+                        xmlDictSize     (xmlDictPtr dict);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/dict.h","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-    XML_CHAR_ENCODING_NONE= 0, \/* No char encoding detected *\/\n-    XML_CHAR_ENCODING_UTF8= 1, \/* UTF-8 *\/\n+    XML_CHAR_ENCODING_NONE=     0, \/* No char encoding detected *\/\n+    XML_CHAR_ENCODING_UTF8=     1, \/* UTF-8 *\/\n@@ -69,1 +69,1 @@\n-    XML_CHAR_ENCODING_UCS2= 9, \/* UCS-2 *\/\n+    XML_CHAR_ENCODING_UCS2=     9, \/* UCS-2 *\/\n@@ -172,1 +172,1 @@\n-    xmlInitCharEncodingHandlers (void);\n+        xmlInitCharEncodingHandlers     (void);\n@@ -174,1 +174,1 @@\n-    xmlCleanupCharEncodingHandlers  (void);\n+        xmlCleanupCharEncodingHandlers  (void);\n@@ -176,1 +176,1 @@\n-    xmlRegisterCharEncodingHandler  (xmlCharEncodingHandlerPtr handler);\n+        xmlRegisterCharEncodingHandler  (xmlCharEncodingHandlerPtr handler);\n@@ -178,1 +178,1 @@\n-    xmlGetCharEncodingHandler   (xmlCharEncoding enc);\n+        xmlGetCharEncodingHandler       (xmlCharEncoding enc);\n@@ -180,1 +180,1 @@\n-    xmlFindCharEncodingHandler  (const char *name);\n+        xmlFindCharEncodingHandler      (const char *name);\n@@ -182,3 +182,3 @@\n-    xmlNewCharEncodingHandler   (const char *name,\n-                     xmlCharEncodingInputFunc input,\n-                     xmlCharEncodingOutputFunc output);\n+        xmlNewCharEncodingHandler       (const char *name,\n+                                         xmlCharEncodingInputFunc input,\n+                                         xmlCharEncodingOutputFunc output);\n@@ -190,2 +190,2 @@\n-    xmlAddEncodingAlias     (const char *name,\n-                     const char *alias);\n+        xmlAddEncodingAlias             (const char *name,\n+                                         const char *alias);\n@@ -193,1 +193,1 @@\n-    xmlDelEncodingAlias     (const char *alias);\n+        xmlDelEncodingAlias             (const char *alias);\n@@ -195,1 +195,1 @@\n-    xmlGetEncodingAlias     (const char *alias);\n+        xmlGetEncodingAlias             (const char *alias);\n@@ -197,1 +197,1 @@\n-    xmlCleanupEncodingAliases   (void);\n+        xmlCleanupEncodingAliases       (void);\n@@ -199,1 +199,1 @@\n-    xmlParseCharEncoding        (const char *name);\n+        xmlParseCharEncoding            (const char *name);\n@@ -201,1 +201,1 @@\n-    xmlGetCharEncodingName      (xmlCharEncoding enc);\n+        xmlGetCharEncodingName          (xmlCharEncoding enc);\n@@ -207,2 +207,2 @@\n-    xmlDetectCharEncoding       (const unsigned char *in,\n-                     int len);\n+        xmlDetectCharEncoding           (const unsigned char *in,\n+                                         int len);\n@@ -211,3 +211,3 @@\n-    xmlCharEncOutFunc       (xmlCharEncodingHandler *handler,\n-                     xmlBufferPtr out,\n-                     xmlBufferPtr in);\n+        xmlCharEncOutFunc               (xmlCharEncodingHandler *handler,\n+                                         xmlBufferPtr out,\n+                                         xmlBufferPtr in);\n@@ -216,3 +216,3 @@\n-    xmlCharEncInFunc        (xmlCharEncodingHandler *handler,\n-                     xmlBufferPtr out,\n-                     xmlBufferPtr in);\n+        xmlCharEncInFunc                (xmlCharEncodingHandler *handler,\n+                                         xmlBufferPtr out,\n+                                         xmlBufferPtr in);\n@@ -220,3 +220,3 @@\n-    xmlCharEncFirstLine     (xmlCharEncodingHandler *handler,\n-                     xmlBufferPtr out,\n-                     xmlBufferPtr in);\n+        xmlCharEncFirstLine             (xmlCharEncodingHandler *handler,\n+                                         xmlBufferPtr out,\n+                                         xmlBufferPtr in);\n@@ -224,1 +224,1 @@\n-    xmlCharEncCloseFunc     (xmlCharEncodingHandler *handler);\n+        xmlCharEncCloseFunc             (xmlCharEncodingHandler *handler);\n@@ -231,4 +231,4 @@\n-    UTF8Toisolat1           (unsigned char *out,\n-                     int *outlen,\n-                     const unsigned char *in,\n-                     int *inlen);\n+        UTF8Toisolat1                   (unsigned char *out,\n+                                         int *outlen,\n+                                         const unsigned char *in,\n+                                         int *inlen);\n@@ -237,4 +237,4 @@\n-    isolat1ToUTF8           (unsigned char *out,\n-                     int *outlen,\n-                     const unsigned char *in,\n-                     int *inlen);\n+        isolat1ToUTF8                   (unsigned char *out,\n+                                         int *outlen,\n+                                         const unsigned char *in,\n+                                         int *inlen);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/encoding.h","additions":38,"deletions":38,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -41,6 +41,6 @@\n-    const xmlChar          *name;   \/* Entity name *\/\n-    struct _xmlNode    *children;   \/* First child link *\/\n-    struct _xmlNode        *last;   \/* Last child link *\/\n-    struct _xmlDtd       *parent;   \/* -> DTD *\/\n-    struct _xmlNode        *next;   \/* next sibling link  *\/\n-    struct _xmlNode        *prev;   \/* previous sibling link  *\/\n+    const xmlChar          *name;       \/* Entity name *\/\n+    struct _xmlNode    *children;       \/* First child link *\/\n+    struct _xmlNode        *last;       \/* Last child link *\/\n+    struct _xmlDtd       *parent;       \/* -> DTD *\/\n+    struct _xmlNode        *next;       \/* next sibling link  *\/\n+    struct _xmlNode        *prev;       \/* previous sibling link  *\/\n@@ -49,14 +49,14 @@\n-    xmlChar                *orig;   \/* content without ref substitution *\/\n-    xmlChar             *content;   \/* content or ndata if unparsed *\/\n-    int                   length;   \/* the content length *\/\n-    xmlEntityType          etype;   \/* The entity type *\/\n-    const xmlChar    *ExternalID;   \/* External identifier for PUBLIC *\/\n-    const xmlChar      *SystemID;   \/* URI for a SYSTEM or PUBLIC Entity *\/\n-\n-    struct _xmlEntity     *nexte;   \/* unused *\/\n-    const xmlChar           *URI;   \/* the full URI as computed *\/\n-    int                    owner;   \/* does the entity own the childrens *\/\n-    int          checked;   \/* was the entity content checked *\/\n-                    \/* this is also used to count entities\n-                     * references done from that entity\n-                     * and if it contains '<' *\/\n+    xmlChar                *orig;       \/* content without ref substitution *\/\n+    xmlChar             *content;       \/* content or ndata if unparsed *\/\n+    int                   length;       \/* the content length *\/\n+    xmlEntityType          etype;       \/* The entity type *\/\n+    const xmlChar    *ExternalID;       \/* External identifier for PUBLIC *\/\n+    const xmlChar      *SystemID;       \/* URI for a SYSTEM or PUBLIC Entity *\/\n+\n+    struct _xmlEntity     *nexte;       \/* unused *\/\n+    const xmlChar           *URI;       \/* the full URI as computed *\/\n+    int                    owner;       \/* does the entity own the childrens *\/\n+    int                  checked;       \/* was the entity content checked *\/\n+                                        \/* this is also used to count entities\n+                                         * references done from that entity\n+                                         * and if it contains '<' *\/\n@@ -79,1 +79,1 @@\n-        xmlInitializePredefinedEntities (void);\n+                xmlInitializePredefinedEntities (void);\n@@ -83,6 +83,6 @@\n-            xmlNewEntity        (xmlDocPtr doc,\n-                         const xmlChar *name,\n-                         int type,\n-                         const xmlChar *ExternalID,\n-                         const xmlChar *SystemID,\n-                         const xmlChar *content);\n+                        xmlNewEntity            (xmlDocPtr doc,\n+                                                 const xmlChar *name,\n+                                                 int type,\n+                                                 const xmlChar *ExternalID,\n+                                                 const xmlChar *SystemID,\n+                                                 const xmlChar *content);\n@@ -90,6 +90,6 @@\n-            xmlAddDocEntity     (xmlDocPtr doc,\n-                         const xmlChar *name,\n-                         int type,\n-                         const xmlChar *ExternalID,\n-                         const xmlChar *SystemID,\n-                         const xmlChar *content);\n+                        xmlAddDocEntity         (xmlDocPtr doc,\n+                                                 const xmlChar *name,\n+                                                 int type,\n+                                                 const xmlChar *ExternalID,\n+                                                 const xmlChar *SystemID,\n+                                                 const xmlChar *content);\n@@ -97,6 +97,6 @@\n-            xmlAddDtdEntity     (xmlDocPtr doc,\n-                         const xmlChar *name,\n-                         int type,\n-                         const xmlChar *ExternalID,\n-                         const xmlChar *SystemID,\n-                         const xmlChar *content);\n+                        xmlAddDtdEntity         (xmlDocPtr doc,\n+                                                 const xmlChar *name,\n+                                                 int type,\n+                                                 const xmlChar *ExternalID,\n+                                                 const xmlChar *SystemID,\n+                                                 const xmlChar *content);\n@@ -104,1 +104,1 @@\n-            xmlGetPredefinedEntity  (const xmlChar *name);\n+                        xmlGetPredefinedEntity  (const xmlChar *name);\n@@ -106,2 +106,2 @@\n-            xmlGetDocEntity     (const xmlDoc *doc,\n-                         const xmlChar *name);\n+                        xmlGetDocEntity         (const xmlDoc *doc,\n+                                                 const xmlChar *name);\n@@ -109,2 +109,2 @@\n-            xmlGetDtdEntity     (xmlDocPtr doc,\n-                         const xmlChar *name);\n+                        xmlGetDtdEntity         (xmlDocPtr doc,\n+                                                 const xmlChar *name);\n@@ -112,2 +112,2 @@\n-            xmlGetParameterEntity   (xmlDocPtr doc,\n-                         const xmlChar *name);\n+                        xmlGetParameterEntity   (xmlDocPtr doc,\n+                                                 const xmlChar *name);\n@@ -116,2 +116,2 @@\n-            xmlEncodeEntities   (xmlDocPtr doc,\n-                         const xmlChar *input);\n+                        xmlEncodeEntities       (xmlDocPtr doc,\n+                                                 const xmlChar *input);\n@@ -120,2 +120,2 @@\n-            xmlEncodeEntitiesReentrant(xmlDocPtr doc,\n-                         const xmlChar *input);\n+                        xmlEncodeEntitiesReentrant(xmlDocPtr doc,\n+                                                 const xmlChar *input);\n@@ -123,2 +123,2 @@\n-            xmlEncodeSpecialChars   (const xmlDoc *doc,\n-                         const xmlChar *input);\n+                        xmlEncodeSpecialChars   (const xmlDoc *doc,\n+                                                 const xmlChar *input);\n@@ -126,1 +126,1 @@\n-            xmlCreateEntitiesTable  (void);\n+                        xmlCreateEntitiesTable  (void);\n@@ -129,1 +129,1 @@\n-            xmlCopyEntitiesTable    (xmlEntitiesTablePtr table);\n+                        xmlCopyEntitiesTable    (xmlEntitiesTablePtr table);\n@@ -132,1 +132,1 @@\n-            xmlFreeEntitiesTable    (xmlEntitiesTablePtr table);\n+                        xmlFreeEntitiesTable    (xmlEntitiesTablePtr table);\n@@ -135,2 +135,2 @@\n-            xmlDumpEntitiesTable    (xmlBufferPtr buf,\n-                         xmlEntitiesTablePtr table);\n+                        xmlDumpEntitiesTable    (xmlBufferPtr buf,\n+                                                 xmlEntitiesTablePtr table);\n@@ -138,2 +138,2 @@\n-            xmlDumpEntityDecl   (xmlBufferPtr buf,\n-                         xmlEntityPtr ent);\n+                        xmlDumpEntityDecl       (xmlBufferPtr buf,\n+                                                 xmlEntityPtr ent);\n@@ -143,1 +143,1 @@\n-            xmlCleanupPredefinedEntities(void);\n+                        xmlCleanupPredefinedEntities(void);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/entities.h","additions":60,"deletions":60,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-                                       xmlCharEncoding enc);\n+                                                                           xmlCharEncoding enc);\n@@ -57,2 +57,2 @@\n-                                 xmlCharEncodingHandlerPtr encoder,\n-                                 int compression);\n+                                                                 xmlCharEncodingHandlerPtr encoder,\n+                                                                 int compression);\n@@ -123,1 +123,1 @@\n-    const char *xmlParserVersion;\n+        const char *xmlParserVersion;\n@@ -125,4 +125,4 @@\n-    xmlSAXLocator xmlDefaultSAXLocator;\n-    xmlSAXHandlerV1 xmlDefaultSAXHandler;\n-    xmlSAXHandlerV1 docbDefaultSAXHandler;\n-    xmlSAXHandlerV1 htmlDefaultSAXHandler;\n+        xmlSAXLocator xmlDefaultSAXLocator;\n+        xmlSAXHandlerV1 xmlDefaultSAXHandler;\n+        xmlSAXHandlerV1 docbDefaultSAXHandler;\n+        xmlSAXHandlerV1 htmlDefaultSAXHandler;\n@@ -130,4 +130,4 @@\n-    xmlFreeFunc xmlFree;\n-    xmlMallocFunc xmlMalloc;\n-    xmlStrdupFunc xmlMemStrdup;\n-    xmlReallocFunc xmlRealloc;\n+        xmlFreeFunc xmlFree;\n+        xmlMallocFunc xmlMalloc;\n+        xmlStrdupFunc xmlMemStrdup;\n+        xmlReallocFunc xmlRealloc;\n@@ -135,3 +135,3 @@\n-    xmlGenericErrorFunc xmlGenericError;\n-    xmlStructuredErrorFunc xmlStructuredError;\n-    void *xmlGenericErrorContext;\n+        xmlGenericErrorFunc xmlGenericError;\n+        xmlStructuredErrorFunc xmlStructuredError;\n+        void *xmlGenericErrorContext;\n@@ -139,1 +139,1 @@\n-    int oldXMLWDcompatibility;\n+        int oldXMLWDcompatibility;\n@@ -141,2 +141,2 @@\n-    xmlBufferAllocationScheme xmlBufferAllocScheme;\n-    int xmlDefaultBufferSize;\n+        xmlBufferAllocationScheme xmlBufferAllocScheme;\n+        int xmlDefaultBufferSize;\n@@ -144,8 +144,8 @@\n-    int xmlSubstituteEntitiesDefaultValue;\n-    int xmlDoValidityCheckingDefaultValue;\n-    int xmlGetWarningsDefaultValue;\n-    int xmlKeepBlanksDefaultValue;\n-    int xmlLineNumbersDefaultValue;\n-    int xmlLoadExtDtdDefaultValue;\n-    int xmlParserDebugEntities;\n-    int xmlPedanticParserDefaultValue;\n+        int xmlSubstituteEntitiesDefaultValue;\n+        int xmlDoValidityCheckingDefaultValue;\n+        int xmlGetWarningsDefaultValue;\n+        int xmlKeepBlanksDefaultValue;\n+        int xmlLineNumbersDefaultValue;\n+        int xmlLoadExtDtdDefaultValue;\n+        int xmlParserDebugEntities;\n+        int xmlPedanticParserDefaultValue;\n@@ -153,3 +153,3 @@\n-    int xmlSaveNoEmptyTags;\n-    int xmlIndentTreeOutput;\n-    const char *xmlTreeIndentString;\n+        int xmlSaveNoEmptyTags;\n+        int xmlIndentTreeOutput;\n+        const char *xmlTreeIndentString;\n@@ -157,2 +157,2 @@\n-    xmlRegisterNodeFunc xmlRegisterNodeDefaultValue;\n-    xmlDeregisterNodeFunc xmlDeregisterNodeDefaultValue;\n+        xmlRegisterNodeFunc xmlRegisterNodeDefaultValue;\n+        xmlDeregisterNodeFunc xmlDeregisterNodeDefaultValue;\n@@ -160,2 +160,2 @@\n-    xmlMallocFunc xmlMallocAtomic;\n-    xmlError xmlLastError;\n+        xmlMallocFunc xmlMallocAtomic;\n+        xmlError xmlLastError;\n@@ -163,2 +163,2 @@\n-    xmlParserInputBufferCreateFilenameFunc xmlParserInputBufferCreateFilenameValue;\n-    xmlOutputBufferCreateFilenameFunc xmlOutputBufferCreateFilenameValue;\n+        xmlParserInputBufferCreateFilenameFunc xmlParserInputBufferCreateFilenameValue;\n+        xmlOutputBufferCreateFilenameFunc xmlOutputBufferCreateFilenameValue;\n@@ -166,1 +166,1 @@\n-    void *xmlStructuredErrorContext;\n+        void *xmlStructuredErrorContext;\n@@ -189,1 +189,1 @@\n-    xmlThrDefOutputBufferCreateFilenameDefault(xmlOutputBufferCreateFilenameFunc func);\n+        xmlThrDefOutputBufferCreateFilenameDefault(xmlOutputBufferCreateFilenameFunc func);\n@@ -191,2 +191,2 @@\n-    xmlThrDefParserInputBufferCreateFilenameDefault(\n-                xmlParserInputBufferCreateFilenameFunc func);\n+        xmlThrDefParserInputBufferCreateFilenameDefault(\n+                                xmlParserInputBufferCreateFilenameFunc func);\n@@ -305,1 +305,1 @@\n-    xmlThrDefBufferAllocScheme(xmlBufferAllocationScheme v);\n+        xmlThrDefBufferAllocScheme(xmlBufferAllocationScheme v);\n@@ -488,1 +488,1 @@\n-                __xmlParserInputBufferCreateFilenameValue(void);\n+                                __xmlParserInputBufferCreateFilenameValue(void);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/globals.h","additions":41,"deletions":41,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- *      various places in the library.\n+ *              various places in the library.\n@@ -100,2 +100,2 @@\n-                   const xmlChar *name, const xmlChar *name2,\n-                   const xmlChar *name3);\n+                                   const xmlChar *name, const xmlChar *name2,\n+                                   const xmlChar *name3);\n@@ -107,1 +107,1 @@\n-            xmlHashCreate   (int size);\n+                        xmlHashCreate   (int size);\n@@ -109,2 +109,2 @@\n-            xmlHashCreateDict(int size,\n-                     xmlDictPtr dict);\n+                        xmlHashCreateDict(int size,\n+                                         xmlDictPtr dict);\n@@ -112,2 +112,2 @@\n-            xmlHashFree (xmlHashTablePtr table,\n-                     xmlHashDeallocator f);\n+                        xmlHashFree     (xmlHashTablePtr table,\n+                                         xmlHashDeallocator f);\n@@ -115,2 +115,2 @@\n-            xmlHashDefaultDeallocator(void *entry,\n-                     const xmlChar *name);\n+                        xmlHashDefaultDeallocator(void *entry,\n+                                         const xmlChar *name);\n@@ -122,3 +122,3 @@\n-            xmlHashAddEntry (xmlHashTablePtr table,\n-                                 const xmlChar *name,\n-                                 void *userdata);\n+                        xmlHashAddEntry (xmlHashTablePtr table,\n+                                         const xmlChar *name,\n+                                         void *userdata);\n@@ -126,4 +126,4 @@\n-            xmlHashUpdateEntry(xmlHashTablePtr table,\n-                                 const xmlChar *name,\n-                                 void *userdata,\n-                     xmlHashDeallocator f);\n+                        xmlHashUpdateEntry(xmlHashTablePtr table,\n+                                         const xmlChar *name,\n+                                         void *userdata,\n+                                         xmlHashDeallocator f);\n@@ -131,4 +131,4 @@\n-            xmlHashAddEntry2(xmlHashTablePtr table,\n-                                 const xmlChar *name,\n-                                 const xmlChar *name2,\n-                                 void *userdata);\n+                        xmlHashAddEntry2(xmlHashTablePtr table,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         void *userdata);\n@@ -136,5 +136,5 @@\n-            xmlHashUpdateEntry2(xmlHashTablePtr table,\n-                                 const xmlChar *name,\n-                                 const xmlChar *name2,\n-                                 void *userdata,\n-                     xmlHashDeallocator f);\n+                        xmlHashUpdateEntry2(xmlHashTablePtr table,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         void *userdata,\n+                                         xmlHashDeallocator f);\n@@ -142,5 +142,5 @@\n-            xmlHashAddEntry3(xmlHashTablePtr table,\n-                                 const xmlChar *name,\n-                                 const xmlChar *name2,\n-                                 const xmlChar *name3,\n-                                 void *userdata);\n+                        xmlHashAddEntry3(xmlHashTablePtr table,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         const xmlChar *name3,\n+                                         void *userdata);\n@@ -148,6 +148,6 @@\n-            xmlHashUpdateEntry3(xmlHashTablePtr table,\n-                                 const xmlChar *name,\n-                                 const xmlChar *name2,\n-                                 const xmlChar *name3,\n-                                 void *userdata,\n-                     xmlHashDeallocator f);\n+                        xmlHashUpdateEntry3(xmlHashTablePtr table,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         const xmlChar *name3,\n+                                         void *userdata,\n+                                         xmlHashDeallocator f);\n@@ -159,1 +159,1 @@\n-            xmlHashRemoveEntry(xmlHashTablePtr table, const xmlChar *name,\n+                        xmlHashRemoveEntry(xmlHashTablePtr table, const xmlChar *name,\n@@ -162,1 +162,1 @@\n-            xmlHashRemoveEntry2(xmlHashTablePtr table, const xmlChar *name,\n+                        xmlHashRemoveEntry2(xmlHashTablePtr table, const xmlChar *name,\n@@ -165,1 +165,1 @@\n-            xmlHashRemoveEntry3(xmlHashTablePtr table, const xmlChar *name,\n+                        xmlHashRemoveEntry3(xmlHashTablePtr table, const xmlChar *name,\n@@ -173,2 +173,2 @@\n-            xmlHashLookup   (xmlHashTablePtr table,\n-                     const xmlChar *name);\n+                        xmlHashLookup   (xmlHashTablePtr table,\n+                                         const xmlChar *name);\n@@ -176,3 +176,3 @@\n-            xmlHashLookup2  (xmlHashTablePtr table,\n-                     const xmlChar *name,\n-                     const xmlChar *name2);\n+                        xmlHashLookup2  (xmlHashTablePtr table,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2);\n@@ -180,4 +180,4 @@\n-            xmlHashLookup3  (xmlHashTablePtr table,\n-                     const xmlChar *name,\n-                     const xmlChar *name2,\n-                     const xmlChar *name3);\n+                        xmlHashLookup3  (xmlHashTablePtr table,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         const xmlChar *name3);\n@@ -185,3 +185,3 @@\n-            xmlHashQLookup  (xmlHashTablePtr table,\n-                     const xmlChar *name,\n-                     const xmlChar *prefix);\n+                        xmlHashQLookup  (xmlHashTablePtr table,\n+                                         const xmlChar *name,\n+                                         const xmlChar *prefix);\n@@ -189,5 +189,5 @@\n-            xmlHashQLookup2 (xmlHashTablePtr table,\n-                     const xmlChar *name,\n-                     const xmlChar *prefix,\n-                     const xmlChar *name2,\n-                     const xmlChar *prefix2);\n+                        xmlHashQLookup2 (xmlHashTablePtr table,\n+                                         const xmlChar *name,\n+                                         const xmlChar *prefix,\n+                                         const xmlChar *name2,\n+                                         const xmlChar *prefix2);\n@@ -195,7 +195,7 @@\n-            xmlHashQLookup3 (xmlHashTablePtr table,\n-                     const xmlChar *name,\n-                     const xmlChar *prefix,\n-                     const xmlChar *name2,\n-                     const xmlChar *prefix2,\n-                     const xmlChar *name3,\n-                     const xmlChar *prefix3);\n+                        xmlHashQLookup3 (xmlHashTablePtr table,\n+                                         const xmlChar *name,\n+                                         const xmlChar *prefix,\n+                                         const xmlChar *name2,\n+                                         const xmlChar *prefix2,\n+                                         const xmlChar *name3,\n+                                         const xmlChar *prefix3);\n@@ -207,2 +207,2 @@\n-            xmlHashCopy (xmlHashTablePtr table,\n-                     xmlHashCopier f);\n+                        xmlHashCopy     (xmlHashTablePtr table,\n+                                         xmlHashCopier f);\n@@ -210,1 +210,1 @@\n-            xmlHashSize (xmlHashTablePtr table);\n+                        xmlHashSize     (xmlHashTablePtr table);\n@@ -212,3 +212,3 @@\n-            xmlHashScan (xmlHashTablePtr table,\n-                     xmlHashScanner f,\n-                     void *data);\n+                        xmlHashScan     (xmlHashTablePtr table,\n+                                         xmlHashScanner f,\n+                                         void *data);\n@@ -216,6 +216,6 @@\n-            xmlHashScan3    (xmlHashTablePtr table,\n-                     const xmlChar *name,\n-                     const xmlChar *name2,\n-                     const xmlChar *name3,\n-                     xmlHashScanner f,\n-                     void *data);\n+                        xmlHashScan3    (xmlHashTablePtr table,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         const xmlChar *name3,\n+                                         xmlHashScanner f,\n+                                         void *data);\n@@ -223,3 +223,3 @@\n-            xmlHashScanFull (xmlHashTablePtr table,\n-                     xmlHashScannerFull f,\n-                     void *data);\n+                        xmlHashScanFull (xmlHashTablePtr table,\n+                                         xmlHashScannerFull f,\n+                                         void *data);\n@@ -227,6 +227,6 @@\n-            xmlHashScanFull3(xmlHashTablePtr table,\n-                     const xmlChar *name,\n-                     const xmlChar *name2,\n-                     const xmlChar *name3,\n-                     xmlHashScannerFull f,\n-                     void *data);\n+                        xmlHashScanFull3(xmlHashTablePtr table,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         const xmlChar *name3,\n+                                         xmlHashScannerFull f,\n+                                         void *data);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/hash.h","additions":85,"deletions":85,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-        xmlListCreate       (xmlListDeallocator deallocator,\n-                                     xmlListDataCompare compare);\n+                xmlListCreate           (xmlListDeallocator deallocator,\n+                                         xmlListDataCompare compare);\n@@ -59,1 +59,1 @@\n-        xmlListDelete       (xmlListPtr l);\n+                xmlListDelete           (xmlListPtr l);\n@@ -63,2 +63,2 @@\n-        xmlListSearch       (xmlListPtr l,\n-                     void *data);\n+                xmlListSearch           (xmlListPtr l,\n+                                         void *data);\n@@ -66,2 +66,2 @@\n-        xmlListReverseSearch    (xmlListPtr l,\n-                     void *data);\n+                xmlListReverseSearch    (xmlListPtr l,\n+                                         void *data);\n@@ -69,2 +69,2 @@\n-        xmlListInsert       (xmlListPtr l,\n-                     void *data) ;\n+                xmlListInsert           (xmlListPtr l,\n+                                         void *data) ;\n@@ -72,2 +72,2 @@\n-        xmlListAppend       (xmlListPtr l,\n-                     void *data) ;\n+                xmlListAppend           (xmlListPtr l,\n+                                         void *data) ;\n@@ -75,2 +75,2 @@\n-        xmlListRemoveFirst  (xmlListPtr l,\n-                     void *data);\n+                xmlListRemoveFirst      (xmlListPtr l,\n+                                         void *data);\n@@ -78,2 +78,2 @@\n-        xmlListRemoveLast   (xmlListPtr l,\n-                     void *data);\n+                xmlListRemoveLast       (xmlListPtr l,\n+                                         void *data);\n@@ -81,2 +81,2 @@\n-        xmlListRemoveAll    (xmlListPtr l,\n-                     void *data);\n+                xmlListRemoveAll        (xmlListPtr l,\n+                                         void *data);\n@@ -84,1 +84,1 @@\n-        xmlListClear        (xmlListPtr l);\n+                xmlListClear            (xmlListPtr l);\n@@ -86,1 +86,1 @@\n-        xmlListEmpty        (xmlListPtr l);\n+                xmlListEmpty            (xmlListPtr l);\n@@ -88,1 +88,1 @@\n-        xmlListFront        (xmlListPtr l);\n+                xmlListFront            (xmlListPtr l);\n@@ -90,1 +90,1 @@\n-        xmlListEnd      (xmlListPtr l);\n+                xmlListEnd              (xmlListPtr l);\n@@ -92,1 +92,1 @@\n-        xmlListSize     (xmlListPtr l);\n+                xmlListSize             (xmlListPtr l);\n@@ -95,1 +95,1 @@\n-        xmlListPopFront     (xmlListPtr l);\n+                xmlListPopFront         (xmlListPtr l);\n@@ -97,1 +97,1 @@\n-        xmlListPopBack      (xmlListPtr l);\n+                xmlListPopBack          (xmlListPtr l);\n@@ -99,2 +99,2 @@\n-        xmlListPushFront    (xmlListPtr l,\n-                     void *data);\n+                xmlListPushFront        (xmlListPtr l,\n+                                         void *data);\n@@ -102,2 +102,2 @@\n-        xmlListPushBack     (xmlListPtr l,\n-                     void *data);\n+                xmlListPushBack         (xmlListPtr l,\n+                                         void *data);\n@@ -107,1 +107,1 @@\n-        xmlListReverse      (xmlListPtr l);\n+                xmlListReverse          (xmlListPtr l);\n@@ -109,1 +109,1 @@\n-        xmlListSort     (xmlListPtr l);\n+                xmlListSort             (xmlListPtr l);\n@@ -111,3 +111,3 @@\n-        xmlListWalk     (xmlListPtr l,\n-                     xmlListWalker walker,\n-                     void *user);\n+                xmlListWalk             (xmlListPtr l,\n+                                         xmlListWalker walker,\n+                                         void *user);\n@@ -115,3 +115,3 @@\n-        xmlListReverseWalk  (xmlListPtr l,\n-                     xmlListWalker walker,\n-                     void *user);\n+                xmlListReverseWalk      (xmlListPtr l,\n+                                         xmlListWalker walker,\n+                                         void *user);\n@@ -119,2 +119,2 @@\n-        xmlListMerge        (xmlListPtr l1,\n-                     xmlListPtr l2);\n+                xmlListMerge            (xmlListPtr l1,\n+                                         xmlListPtr l2);\n@@ -122,1 +122,1 @@\n-        xmlListDup      (const xmlListPtr old);\n+                xmlListDup              (const xmlListPtr old);\n@@ -124,2 +124,2 @@\n-        xmlListCopy     (xmlListPtr cur,\n-                     const xmlListPtr old);\n+                xmlListCopy             (xmlListPtr cur,\n+                                         const xmlListPtr old);\n@@ -128,1 +128,1 @@\n-        xmlLinkGetData          (xmlLinkPtr lk);\n+                xmlLinkGetData          (xmlLinkPtr lk);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/list.h","additions":42,"deletions":42,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -61,5 +61,5 @@\n-                             const char *filename, const char *attrib,\n-                             const char *owner, const char *group,\n-                 unsigned long size, int links, int year,\n-                 const char *month, int day, int hour,\n-                 int minute);\n+                                 const char *filename, const char *attrib,\n+                                 const char *owner, const char *group,\n+                                 unsigned long size, int links, int year,\n+                                 const char *month, int day, int hour,\n+                                 int minute);\n@@ -75,2 +75,2 @@\n-                 const char *data,\n-                 int len);\n+                                 const char *data,\n+                                 int len);\n@@ -82,1 +82,1 @@\n-    xmlNanoFTPInit      (void);\n+        xmlNanoFTPInit          (void);\n@@ -84,1 +84,1 @@\n-    xmlNanoFTPCleanup   (void);\n+        xmlNanoFTPCleanup       (void);\n@@ -90,1 +90,1 @@\n-    xmlNanoFTPNewCtxt   (const char *URL);\n+        xmlNanoFTPNewCtxt       (const char *URL);\n@@ -92,1 +92,1 @@\n-    xmlNanoFTPFreeCtxt  (void * ctx);\n+        xmlNanoFTPFreeCtxt      (void * ctx);\n@@ -94,2 +94,2 @@\n-    xmlNanoFTPConnectTo (const char *server,\n-                 int port);\n+        xmlNanoFTPConnectTo     (const char *server,\n+                                 int port);\n@@ -100,1 +100,1 @@\n-    xmlNanoFTPOpen      (const char *URL);\n+        xmlNanoFTPOpen          (const char *URL);\n@@ -102,1 +102,1 @@\n-    xmlNanoFTPConnect   (void *ctx);\n+        xmlNanoFTPConnect       (void *ctx);\n@@ -104,1 +104,1 @@\n-    xmlNanoFTPClose     (void *ctx);\n+        xmlNanoFTPClose         (void *ctx);\n@@ -106,1 +106,1 @@\n-    xmlNanoFTPQuit      (void *ctx);\n+        xmlNanoFTPQuit          (void *ctx);\n@@ -108,1 +108,1 @@\n-    xmlNanoFTPScanProxy (const char *URL);\n+        xmlNanoFTPScanProxy     (const char *URL);\n@@ -110,5 +110,5 @@\n-    xmlNanoFTPProxy     (const char *host,\n-                 int port,\n-                 const char *user,\n-                 const char *passwd,\n-                 int type);\n+        xmlNanoFTPProxy         (const char *host,\n+                                 int port,\n+                                 const char *user,\n+                                 const char *passwd,\n+                                 int type);\n@@ -116,2 +116,2 @@\n-    xmlNanoFTPUpdateURL (void *ctx,\n-                 const char *URL);\n+        xmlNanoFTPUpdateURL     (void *ctx,\n+                                 const char *URL);\n@@ -123,1 +123,1 @@\n-    xmlNanoFTPGetResponse   (void *ctx);\n+        xmlNanoFTPGetResponse   (void *ctx);\n@@ -125,1 +125,1 @@\n-    xmlNanoFTPCheckResponse (void *ctx);\n+        xmlNanoFTPCheckResponse (void *ctx);\n@@ -131,2 +131,2 @@\n-    xmlNanoFTPCwd       (void *ctx,\n-                 const char *directory);\n+        xmlNanoFTPCwd           (void *ctx,\n+                                 const char *directory);\n@@ -134,2 +134,2 @@\n-    xmlNanoFTPDele      (void *ctx,\n-                 const char *file);\n+        xmlNanoFTPDele          (void *ctx,\n+                                 const char *file);\n@@ -138,1 +138,1 @@\n-    xmlNanoFTPGetConnection (void *ctx);\n+        xmlNanoFTPGetConnection (void *ctx);\n@@ -140,1 +140,1 @@\n-    xmlNanoFTPCloseConnection(void *ctx);\n+        xmlNanoFTPCloseConnection(void *ctx);\n@@ -142,4 +142,4 @@\n-    xmlNanoFTPList      (void *ctx,\n-                 ftpListCallback callback,\n-                 void *userData,\n-                 const char *filename);\n+        xmlNanoFTPList          (void *ctx,\n+                                 ftpListCallback callback,\n+                                 void *userData,\n+                                 const char *filename);\n@@ -147,2 +147,2 @@\n-    xmlNanoFTPGetSocket (void *ctx,\n-                 const char *filename);\n+        xmlNanoFTPGetSocket     (void *ctx,\n+                                 const char *filename);\n@@ -150,4 +150,4 @@\n-    xmlNanoFTPGet       (void *ctx,\n-                 ftpDataCallback callback,\n-                 void *userData,\n-                 const char *filename);\n+        xmlNanoFTPGet           (void *ctx,\n+                                 ftpDataCallback callback,\n+                                 void *userData,\n+                                 const char *filename);\n@@ -155,3 +155,3 @@\n-    xmlNanoFTPRead      (void *ctx,\n-                 void *dest,\n-                 int len);\n+        xmlNanoFTPRead          (void *ctx,\n+                                 void *dest,\n+                                 int len);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/nanoftp.h","additions":46,"deletions":46,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -22,1 +22,1 @@\n-    xmlNanoHTTPInit     (void);\n+        xmlNanoHTTPInit         (void);\n@@ -24,1 +24,1 @@\n-    xmlNanoHTTPCleanup  (void);\n+        xmlNanoHTTPCleanup      (void);\n@@ -26,1 +26,1 @@\n-    xmlNanoHTTPScanProxy    (const char *URL);\n+        xmlNanoHTTPScanProxy    (const char *URL);\n@@ -28,3 +28,3 @@\n-    xmlNanoHTTPFetch    (const char *URL,\n-                 const char *filename,\n-                 char **contentType);\n+        xmlNanoHTTPFetch        (const char *URL,\n+                                 const char *filename,\n+                                 char **contentType);\n@@ -32,6 +32,6 @@\n-    xmlNanoHTTPMethod   (const char *URL,\n-                 const char *method,\n-                 const char *input,\n-                 char **contentType,\n-                 const char *headers,\n-                 int   ilen);\n+        xmlNanoHTTPMethod       (const char *URL,\n+                                 const char *method,\n+                                 const char *input,\n+                                 char **contentType,\n+                                 const char *headers,\n+                                 int   ilen);\n@@ -39,7 +39,7 @@\n-    xmlNanoHTTPMethodRedir  (const char *URL,\n-                 const char *method,\n-                 const char *input,\n-                 char **contentType,\n-                 char **redir,\n-                 const char *headers,\n-                 int   ilen);\n+        xmlNanoHTTPMethodRedir  (const char *URL,\n+                                 const char *method,\n+                                 const char *input,\n+                                 char **contentType,\n+                                 char **redir,\n+                                 const char *headers,\n+                                 int   ilen);\n@@ -47,2 +47,2 @@\n-    xmlNanoHTTPOpen     (const char *URL,\n-                 char **contentType);\n+        xmlNanoHTTPOpen         (const char *URL,\n+                                 char **contentType);\n@@ -50,3 +50,3 @@\n-    xmlNanoHTTPOpenRedir    (const char *URL,\n-                 char **contentType,\n-                 char **redir);\n+        xmlNanoHTTPOpenRedir    (const char *URL,\n+                                 char **contentType,\n+                                 char **redir);\n@@ -54,1 +54,1 @@\n-    xmlNanoHTTPReturnCode   (void *ctx);\n+        xmlNanoHTTPReturnCode   (void *ctx);\n@@ -56,1 +56,1 @@\n-    xmlNanoHTTPAuthHeader   (void *ctx);\n+        xmlNanoHTTPAuthHeader   (void *ctx);\n@@ -58,1 +58,1 @@\n-    xmlNanoHTTPRedir    (void *ctx);\n+        xmlNanoHTTPRedir        (void *ctx);\n@@ -60,1 +60,1 @@\n-    xmlNanoHTTPContentLength( void * ctx );\n+        xmlNanoHTTPContentLength( void * ctx );\n@@ -62,1 +62,1 @@\n-    xmlNanoHTTPEncoding (void *ctx);\n+        xmlNanoHTTPEncoding     (void *ctx);\n@@ -64,1 +64,1 @@\n-    xmlNanoHTTPMimeType (void *ctx);\n+        xmlNanoHTTPMimeType     (void *ctx);\n@@ -66,3 +66,3 @@\n-    xmlNanoHTTPRead     (void *ctx,\n-                 void *dest,\n-                 int len);\n+        xmlNanoHTTPRead         (void *ctx,\n+                                 void *dest,\n+                                 int len);\n@@ -71,2 +71,2 @@\n-    xmlNanoHTTPSave     (void *ctxt,\n-                 const char *filename);\n+        xmlNanoHTTPSave         (void *ctxt,\n+                                 const char *filename);\n@@ -75,1 +75,1 @@\n-    xmlNanoHTTPClose    (void *ctx);\n+        xmlNanoHTTPClose        (void *ctx);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/nanohttp.h","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#define XML_DEFAULT_VERSION \"1.0\"\n+#define XML_DEFAULT_VERSION     \"1.0\"\n@@ -113,9 +113,9 @@\n-    XML_PARSER_EOF = -1,    \/* nothing is to be parsed *\/\n-    XML_PARSER_START = 0,   \/* nothing has been parsed *\/\n-    XML_PARSER_MISC,        \/* Misc* before int subset *\/\n-    XML_PARSER_PI,      \/* Within a processing instruction *\/\n-    XML_PARSER_DTD,     \/* within some DTD content *\/\n-    XML_PARSER_PROLOG,      \/* Misc* after internal subset *\/\n-    XML_PARSER_COMMENT,     \/* within a comment *\/\n-    XML_PARSER_START_TAG,   \/* within a start tag *\/\n-    XML_PARSER_CONTENT,     \/* within the content *\/\n+    XML_PARSER_EOF = -1,        \/* nothing is to be parsed *\/\n+    XML_PARSER_START = 0,       \/* nothing has been parsed *\/\n+    XML_PARSER_MISC,            \/* Misc* before int subset *\/\n+    XML_PARSER_PI,              \/* Within a processing instruction *\/\n+    XML_PARSER_DTD,             \/* within some DTD content *\/\n+    XML_PARSER_PROLOG,          \/* Misc* after internal subset *\/\n+    XML_PARSER_COMMENT,         \/* within a comment *\/\n+    XML_PARSER_START_TAG,       \/* within a start tag *\/\n+    XML_PARSER_CONTENT,         \/* within the content *\/\n@@ -123,2 +123,2 @@\n-    XML_PARSER_END_TAG,     \/* within a closing tag *\/\n-    XML_PARSER_ENTITY_DECL, \/* within an entity declaration *\/\n+    XML_PARSER_END_TAG,         \/* within a closing tag *\/\n+    XML_PARSER_ENTITY_DECL,     \/* within an entity declaration *\/\n@@ -128,2 +128,2 @@\n-    XML_PARSER_EPILOG,      \/* the Misc* after the last end tag *\/\n-    XML_PARSER_IGNORE,      \/* within an IGNORED section *\/\n+    XML_PARSER_EPILOG,          \/* the Misc* after the last end tag *\/\n+    XML_PARSER_IGNORE,          \/* within an IGNORED section *\/\n@@ -139,1 +139,1 @@\n-#define XML_DETECT_IDS      2\n+#define XML_DETECT_IDS          2\n@@ -148,1 +148,1 @@\n-#define XML_COMPLETE_ATTRS  4\n+#define XML_COMPLETE_ATTRS      4\n@@ -156,1 +156,1 @@\n-#define XML_SKIP_IDS        8\n+#define XML_SKIP_IDS            8\n@@ -254,1 +254,1 @@\n-                         actually an xmlCharEncoding *\/\n+                                         actually an xmlCharEncoding *\/\n@@ -353,2 +353,2 @@\n-                const xmlChar *publicId,\n-                const xmlChar *systemId);\n+                                const xmlChar *publicId,\n+                                const xmlChar *systemId);\n@@ -365,3 +365,3 @@\n-                const xmlChar *name,\n-                const xmlChar *ExternalID,\n-                const xmlChar *SystemID);\n+                                const xmlChar *name,\n+                                const xmlChar *ExternalID,\n+                                const xmlChar *SystemID);\n@@ -378,3 +378,3 @@\n-                const xmlChar *name,\n-                const xmlChar *ExternalID,\n-                const xmlChar *SystemID);\n+                                const xmlChar *name,\n+                                const xmlChar *ExternalID,\n+                                const xmlChar *SystemID);\n@@ -391,1 +391,1 @@\n-                const xmlChar *name);\n+                                const xmlChar *name);\n@@ -402,1 +402,1 @@\n-                const xmlChar *name);\n+                                const xmlChar *name);\n@@ -415,5 +415,5 @@\n-                const xmlChar *name,\n-                int type,\n-                const xmlChar *publicId,\n-                const xmlChar *systemId,\n-                xmlChar *content);\n+                                const xmlChar *name,\n+                                int type,\n+                                const xmlChar *publicId,\n+                                const xmlChar *systemId,\n+                                xmlChar *content);\n@@ -430,3 +430,3 @@\n-                const xmlChar *name,\n-                const xmlChar *publicId,\n-                const xmlChar *systemId);\n+                                const xmlChar *name,\n+                                const xmlChar *publicId,\n+                                const xmlChar *systemId);\n@@ -446,6 +446,6 @@\n-                const xmlChar *elem,\n-                const xmlChar *fullname,\n-                int type,\n-                int def,\n-                const xmlChar *defaultValue,\n-                xmlEnumerationPtr tree);\n+                                const xmlChar *elem,\n+                                const xmlChar *fullname,\n+                                int type,\n+                                int def,\n+                                const xmlChar *defaultValue,\n+                                xmlEnumerationPtr tree);\n@@ -462,3 +462,3 @@\n-                const xmlChar *name,\n-                int type,\n-                xmlElementContentPtr content);\n+                                const xmlChar *name,\n+                                int type,\n+                                xmlElementContentPtr content);\n@@ -476,4 +476,4 @@\n-                const xmlChar *name,\n-                const xmlChar *publicId,\n-                const xmlChar *systemId,\n-                const xmlChar *notationName);\n+                                const xmlChar *name,\n+                                const xmlChar *publicId,\n+                                const xmlChar *systemId,\n+                                const xmlChar *notationName);\n@@ -489,1 +489,1 @@\n-                xmlSAXLocatorPtr loc);\n+                                xmlSAXLocatorPtr loc);\n@@ -513,2 +513,2 @@\n-                const xmlChar *name,\n-                const xmlChar **atts);\n+                                const xmlChar *name,\n+                                const xmlChar **atts);\n@@ -523,1 +523,1 @@\n-                const xmlChar *name);\n+                                const xmlChar *name);\n@@ -536,2 +536,2 @@\n-                const xmlChar *name,\n-                const xmlChar *value);\n+                                const xmlChar *name,\n+                                const xmlChar *value);\n@@ -546,1 +546,1 @@\n-                const xmlChar *name);\n+                                const xmlChar *name);\n@@ -556,2 +556,2 @@\n-                const xmlChar *ch,\n-                int len);\n+                                const xmlChar *ch,\n+                                int len);\n@@ -568,2 +568,2 @@\n-                const xmlChar *ch,\n-                int len);\n+                                const xmlChar *ch,\n+                                int len);\n@@ -579,2 +579,2 @@\n-                const xmlChar *target,\n-                const xmlChar *data);\n+                                const xmlChar *target,\n+                                const xmlChar *data);\n@@ -589,1 +589,1 @@\n-                const xmlChar *value);\n+                                const xmlChar *value);\n@@ -599,3 +599,3 @@\n-                            void *ctx,\n-                const xmlChar *value,\n-                int len);\n+                                void *ctx,\n+                                const xmlChar *value,\n+                                int len);\n@@ -611,1 +611,1 @@\n-                const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);\n+                                const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -621,1 +621,1 @@\n-                const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);\n+                                const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -633,1 +633,1 @@\n-                const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);\n+                                const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -664,3 +664,3 @@\n- *                                  *\n- *          The SAX version 2 API extensions        *\n- *                                  *\n+ *                                                                      *\n+ *                      The SAX version 2 API extensions                *\n+ *                                                                      *\n@@ -695,8 +695,8 @@\n-                    const xmlChar *localname,\n-                    const xmlChar *prefix,\n-                    const xmlChar *URI,\n-                    int nb_namespaces,\n-                    const xmlChar **namespaces,\n-                    int nb_attributes,\n-                    int nb_defaulted,\n-                    const xmlChar **attributes);\n+                                        const xmlChar *localname,\n+                                        const xmlChar *prefix,\n+                                        const xmlChar *URI,\n+                                        int nb_namespaces,\n+                                        const xmlChar **namespaces,\n+                                        int nb_attributes,\n+                                        int nb_defaulted,\n+                                        const xmlChar **attributes);\n@@ -716,3 +716,3 @@\n-                    const xmlChar *localname,\n-                    const xmlChar *prefix,\n-                    const xmlChar *URI);\n+                                        const xmlChar *localname,\n+                                        const xmlChar *prefix,\n+                                        const xmlChar *URI);\n@@ -805,2 +805,2 @@\n-                     const char *ID,\n-                     xmlParserCtxtPtr context);\n+                                         const char *ID,\n+                                         xmlParserCtxtPtr context);\n@@ -825,1 +825,1 @@\n-        xmlInitParser       (void);\n+                xmlInitParser           (void);\n@@ -827,1 +827,1 @@\n-        xmlCleanupParser    (void);\n+                xmlCleanupParser        (void);\n@@ -833,2 +833,2 @@\n-        xmlParserInputRead  (xmlParserInputPtr in,\n-                     int len);\n+                xmlParserInputRead      (xmlParserInputPtr in,\n+                                         int len);\n@@ -836,2 +836,2 @@\n-        xmlParserInputGrow  (xmlParserInputPtr in,\n-                     int len);\n+                xmlParserInputGrow      (xmlParserInputPtr in,\n+                                         int len);\n@@ -844,1 +844,1 @@\n-        xmlParseDoc     (const xmlChar *cur);\n+                xmlParseDoc             (const xmlChar *cur);\n@@ -846,1 +846,1 @@\n-        xmlParseFile        (const char *filename);\n+                xmlParseFile            (const char *filename);\n@@ -848,2 +848,2 @@\n-        xmlParseMemory      (const char *buffer,\n-                     int size);\n+                xmlParseMemory          (const char *buffer,\n+                                         int size);\n@@ -852,1 +852,1 @@\n-        xmlSubstituteEntitiesDefault(int val);\n+                xmlSubstituteEntitiesDefault(int val);\n@@ -854,1 +854,1 @@\n-        xmlKeepBlanksDefault    (int val);\n+                xmlKeepBlanksDefault    (int val);\n@@ -856,1 +856,1 @@\n-        xmlStopParser       (xmlParserCtxtPtr ctxt);\n+                xmlStopParser           (xmlParserCtxtPtr ctxt);\n@@ -858,1 +858,1 @@\n-        xmlPedanticParserDefault(int val);\n+                xmlPedanticParserDefault(int val);\n@@ -860,1 +860,1 @@\n-        xmlLineNumbersDefault   (int val);\n+                xmlLineNumbersDefault   (int val);\n@@ -867,1 +867,1 @@\n-        xmlRecoverDoc       (const xmlChar *cur);\n+                xmlRecoverDoc           (const xmlChar *cur);\n@@ -869,2 +869,2 @@\n-        xmlRecoverMemory    (const char *buffer,\n-                     int size);\n+                xmlRecoverMemory        (const char *buffer,\n+                                         int size);\n@@ -872,1 +872,1 @@\n-        xmlRecoverFile      (const char *filename);\n+                xmlRecoverFile          (const char *filename);\n@@ -879,1 +879,1 @@\n-        xmlParseDocument    (xmlParserCtxtPtr ctxt);\n+                xmlParseDocument        (xmlParserCtxtPtr ctxt);\n@@ -881,1 +881,1 @@\n-        xmlParseExtParsedEnt    (xmlParserCtxtPtr ctxt);\n+                xmlParseExtParsedEnt    (xmlParserCtxtPtr ctxt);\n@@ -884,3 +884,3 @@\n-        xmlSAXUserParseFile (xmlSAXHandlerPtr sax,\n-                     void *user_data,\n-                     const char *filename);\n+                xmlSAXUserParseFile     (xmlSAXHandlerPtr sax,\n+                                         void *user_data,\n+                                         const char *filename);\n@@ -888,4 +888,4 @@\n-        xmlSAXUserParseMemory   (xmlSAXHandlerPtr sax,\n-                     void *user_data,\n-                     const char *buffer,\n-                     int size);\n+                xmlSAXUserParseMemory   (xmlSAXHandlerPtr sax,\n+                                         void *user_data,\n+                                         const char *buffer,\n+                                         int size);\n@@ -893,3 +893,3 @@\n-        xmlSAXParseDoc      (xmlSAXHandlerPtr sax,\n-                     const xmlChar *cur,\n-                     int recovery);\n+                xmlSAXParseDoc          (xmlSAXHandlerPtr sax,\n+                                         const xmlChar *cur,\n+                                         int recovery);\n@@ -897,4 +897,4 @@\n-        xmlSAXParseMemory   (xmlSAXHandlerPtr sax,\n-                     const char *buffer,\n-                     int size,\n-                     int recovery);\n+                xmlSAXParseMemory       (xmlSAXHandlerPtr sax,\n+                                         const char *buffer,\n+                                         int size,\n+                                         int recovery);\n@@ -902,5 +902,5 @@\n-        xmlSAXParseMemoryWithData (xmlSAXHandlerPtr sax,\n-                     const char *buffer,\n-                     int size,\n-                     int recovery,\n-                     void *data);\n+                xmlSAXParseMemoryWithData (xmlSAXHandlerPtr sax,\n+                                         const char *buffer,\n+                                         int size,\n+                                         int recovery,\n+                                         void *data);\n@@ -908,3 +908,3 @@\n-        xmlSAXParseFile     (xmlSAXHandlerPtr sax,\n-                     const char *filename,\n-                     int recovery);\n+                xmlSAXParseFile         (xmlSAXHandlerPtr sax,\n+                                         const char *filename,\n+                                         int recovery);\n@@ -912,4 +912,4 @@\n-        xmlSAXParseFileWithData (xmlSAXHandlerPtr sax,\n-                     const char *filename,\n-                     int recovery,\n-                     void *data);\n+                xmlSAXParseFileWithData (xmlSAXHandlerPtr sax,\n+                                         const char *filename,\n+                                         int recovery,\n+                                         void *data);\n@@ -917,2 +917,2 @@\n-        xmlSAXParseEntity   (xmlSAXHandlerPtr sax,\n-                     const char *filename);\n+                xmlSAXParseEntity       (xmlSAXHandlerPtr sax,\n+                                         const char *filename);\n@@ -920,1 +920,1 @@\n-        xmlParseEntity      (const char *filename);\n+                xmlParseEntity          (const char *filename);\n@@ -925,3 +925,3 @@\n-        xmlSAXParseDTD      (xmlSAXHandlerPtr sax,\n-                     const xmlChar *ExternalID,\n-                     const xmlChar *SystemID);\n+                xmlSAXParseDTD          (xmlSAXHandlerPtr sax,\n+                                         const xmlChar *ExternalID,\n+                                         const xmlChar *SystemID);\n@@ -929,2 +929,2 @@\n-        xmlParseDTD     (const xmlChar *ExternalID,\n-                     const xmlChar *SystemID);\n+                xmlParseDTD             (const xmlChar *ExternalID,\n+                                         const xmlChar *SystemID);\n@@ -932,3 +932,3 @@\n-        xmlIOParseDTD       (xmlSAXHandlerPtr sax,\n-                     xmlParserInputBufferPtr input,\n-                     xmlCharEncoding enc);\n+                xmlIOParseDTD           (xmlSAXHandlerPtr sax,\n+                                         xmlParserInputBufferPtr input,\n+                                         xmlCharEncoding enc);\n@@ -938,6 +938,6 @@\n-        xmlParseBalancedChunkMemory(xmlDocPtr doc,\n-                     xmlSAXHandlerPtr sax,\n-                     void *user_data,\n-                     int depth,\n-                     const xmlChar *string,\n-                     xmlNodePtr *lst);\n+                xmlParseBalancedChunkMemory(xmlDocPtr doc,\n+                                         xmlSAXHandlerPtr sax,\n+                                         void *user_data,\n+                                         int depth,\n+                                         const xmlChar *string,\n+                                         xmlNodePtr *lst);\n@@ -946,5 +946,5 @@\n-        xmlParseInNodeContext   (xmlNodePtr node,\n-                     const char *data,\n-                     int datalen,\n-                     int options,\n-                     xmlNodePtr *lst);\n+                xmlParseInNodeContext   (xmlNodePtr node,\n+                                         const char *data,\n+                                         int datalen,\n+                                         int options,\n+                                         xmlNodePtr *lst);\n@@ -953,1 +953,1 @@\n-        xmlParseBalancedChunkMemoryRecover(xmlDocPtr doc,\n+                xmlParseBalancedChunkMemoryRecover(xmlDocPtr doc,\n@@ -961,7 +961,7 @@\n-        xmlParseExternalEntity  (xmlDocPtr doc,\n-                     xmlSAXHandlerPtr sax,\n-                     void *user_data,\n-                     int depth,\n-                     const xmlChar *URL,\n-                     const xmlChar *ID,\n-                     xmlNodePtr *lst);\n+                xmlParseExternalEntity  (xmlDocPtr doc,\n+                                         xmlSAXHandlerPtr sax,\n+                                         void *user_data,\n+                                         int depth,\n+                                         const xmlChar *URL,\n+                                         const xmlChar *ID,\n+                                         xmlNodePtr *lst);\n@@ -970,4 +970,4 @@\n-        xmlParseCtxtExternalEntity(xmlParserCtxtPtr ctx,\n-                     const xmlChar *URL,\n-                     const xmlChar *ID,\n-                     xmlNodePtr *lst);\n+                xmlParseCtxtExternalEntity(xmlParserCtxtPtr ctx,\n+                                         const xmlChar *URL,\n+                                         const xmlChar *ID,\n+                                         xmlNodePtr *lst);\n@@ -979,1 +979,1 @@\n-        xmlNewParserCtxt    (void);\n+                xmlNewParserCtxt        (void);\n@@ -981,1 +981,1 @@\n-        xmlInitParserCtxt   (xmlParserCtxtPtr ctxt);\n+                xmlInitParserCtxt       (xmlParserCtxtPtr ctxt);\n@@ -983,1 +983,1 @@\n-        xmlClearParserCtxt  (xmlParserCtxtPtr ctxt);\n+                xmlClearParserCtxt      (xmlParserCtxtPtr ctxt);\n@@ -985,1 +985,1 @@\n-        xmlFreeParserCtxt   (xmlParserCtxtPtr ctxt);\n+                xmlFreeParserCtxt       (xmlParserCtxtPtr ctxt);\n@@ -988,3 +988,3 @@\n-        xmlSetupParserForBuffer (xmlParserCtxtPtr ctxt,\n-                     const xmlChar* buffer,\n-                     const char *filename);\n+                xmlSetupParserForBuffer (xmlParserCtxtPtr ctxt,\n+                                         const xmlChar* buffer,\n+                                         const char *filename);\n@@ -993,1 +993,1 @@\n-        xmlCreateDocParserCtxt  (const xmlChar *cur);\n+                xmlCreateDocParserCtxt  (const xmlChar *cur);\n@@ -1000,2 +1000,2 @@\n-        xmlGetFeaturesList  (int *len,\n-                     const char **result);\n+                xmlGetFeaturesList      (int *len,\n+                                         const char **result);\n@@ -1003,3 +1003,3 @@\n-        xmlGetFeature       (xmlParserCtxtPtr ctxt,\n-                     const char *name,\n-                     void *result);\n+                xmlGetFeature           (xmlParserCtxtPtr ctxt,\n+                                         const char *name,\n+                                         void *result);\n@@ -1007,3 +1007,3 @@\n-        xmlSetFeature       (xmlParserCtxtPtr ctxt,\n-                     const char *name,\n-                     void *value);\n+                xmlSetFeature           (xmlParserCtxtPtr ctxt,\n+                                         const char *name,\n+                                         void *value);\n@@ -1017,5 +1017,5 @@\n-        xmlCreatePushParserCtxt(xmlSAXHandlerPtr sax,\n-                     void *user_data,\n-                     const char *chunk,\n-                     int size,\n-                     const char *filename);\n+                xmlCreatePushParserCtxt(xmlSAXHandlerPtr sax,\n+                                         void *user_data,\n+                                         const char *chunk,\n+                                         int size,\n+                                         const char *filename);\n@@ -1023,4 +1023,4 @@\n-        xmlParseChunk       (xmlParserCtxtPtr ctxt,\n-                     const char *chunk,\n-                     int size,\n-                     int terminate);\n+                xmlParseChunk           (xmlParserCtxtPtr ctxt,\n+                                         const char *chunk,\n+                                         int size,\n+                                         int terminate);\n@@ -1034,6 +1034,6 @@\n-        xmlCreateIOParserCtxt   (xmlSAXHandlerPtr sax,\n-                     void *user_data,\n-                     xmlInputReadCallback   ioread,\n-                     xmlInputCloseCallback  ioclose,\n-                     void *ioctx,\n-                     xmlCharEncoding enc);\n+                xmlCreateIOParserCtxt   (xmlSAXHandlerPtr sax,\n+                                         void *user_data,\n+                                         xmlInputReadCallback   ioread,\n+                                         xmlInputCloseCallback  ioclose,\n+                                         void *ioctx,\n+                                         xmlCharEncoding enc);\n@@ -1042,3 +1042,3 @@\n-        xmlNewIOInputStream (xmlParserCtxtPtr ctxt,\n-                     xmlParserInputBufferPtr input,\n-                     xmlCharEncoding enc);\n+                xmlNewIOInputStream     (xmlParserCtxtPtr ctxt,\n+                                         xmlParserInputBufferPtr input,\n+                                         xmlCharEncoding enc);\n@@ -1050,2 +1050,2 @@\n-        xmlParserFindNodeInfo   (const xmlParserCtxtPtr ctxt,\n-                         const xmlNodePtr node);\n+                xmlParserFindNodeInfo   (const xmlParserCtxtPtr ctxt,\n+                                         const xmlNodePtr node);\n@@ -1053,1 +1053,1 @@\n-        xmlInitNodeInfoSeq  (xmlParserNodeInfoSeqPtr seq);\n+                xmlInitNodeInfoSeq      (xmlParserNodeInfoSeqPtr seq);\n@@ -1055,1 +1055,1 @@\n-        xmlClearNodeInfoSeq (xmlParserNodeInfoSeqPtr seq);\n+                xmlClearNodeInfoSeq     (xmlParserNodeInfoSeqPtr seq);\n@@ -1057,1 +1057,1 @@\n-        xmlParserFindNodeInfoIndex(const xmlParserNodeInfoSeqPtr seq,\n+                xmlParserFindNodeInfoIndex(const xmlParserNodeInfoSeqPtr seq,\n@@ -1060,2 +1060,2 @@\n-        xmlParserAddNodeInfo    (xmlParserCtxtPtr ctxt,\n-                     const xmlParserNodeInfoPtr info);\n+                xmlParserAddNodeInfo    (xmlParserCtxtPtr ctxt,\n+                                         const xmlParserNodeInfoPtr info);\n@@ -1068,1 +1068,1 @@\n-        xmlSetExternalEntityLoader(xmlExternalEntityLoader f);\n+                xmlSetExternalEntityLoader(xmlExternalEntityLoader f);\n@@ -1070,1 +1070,1 @@\n-        xmlGetExternalEntityLoader(void);\n+                xmlGetExternalEntityLoader(void);\n@@ -1072,3 +1072,3 @@\n-        xmlLoadExternalEntity   (const char *URL,\n-                     const char *ID,\n-                     xmlParserCtxtPtr ctxt);\n+                xmlLoadExternalEntity   (const char *URL,\n+                                         const char *ID,\n+                                         xmlParserCtxtPtr ctxt);\n@@ -1080,1 +1080,1 @@\n-        xmlByteConsumed     (xmlParserCtxtPtr ctxt);\n+                xmlByteConsumed         (xmlParserCtxtPtr ctxt);\n@@ -1093,1 +1093,1 @@\n-    XML_PARSE_NOENT = 1<<1, \/* substitute entities *\/\n+    XML_PARSE_NOENT     = 1<<1, \/* substitute entities *\/\n@@ -1101,1 +1101,1 @@\n-    XML_PARSE_SAX1  = 1<<9, \/* use the SAX1 interface internally *\/\n+    XML_PARSE_SAX1      = 1<<9, \/* use the SAX1 interface internally *\/\n@@ -1103,1 +1103,1 @@\n-    XML_PARSE_NONET = 1<<11,\/* Forbid network access *\/\n+    XML_PARSE_NONET     = 1<<11,\/* Forbid network access *\/\n@@ -1110,2 +1110,2 @@\n-                   crash if you try to modify the tree) *\/\n-    XML_PARSE_OLD10 = 1<<17,\/* parse using XML-1.0 before update 5 *\/\n+                                   crash if you try to modify the tree) *\/\n+    XML_PARSE_OLD10     = 1<<17,\/* parse using XML-1.0 before update 5 *\/\n@@ -1120,1 +1120,1 @@\n-        xmlCtxtReset        (xmlParserCtxtPtr ctxt);\n+                xmlCtxtReset            (xmlParserCtxtPtr ctxt);\n@@ -1122,5 +1122,5 @@\n-        xmlCtxtResetPush    (xmlParserCtxtPtr ctxt,\n-                     const char *chunk,\n-                     int size,\n-                     const char *filename,\n-                     const char *encoding);\n+                xmlCtxtResetPush        (xmlParserCtxtPtr ctxt,\n+                                         const char *chunk,\n+                                         int size,\n+                                         const char *filename,\n+                                         const char *encoding);\n@@ -1128,2 +1128,2 @@\n-        xmlCtxtUseOptions   (xmlParserCtxtPtr ctxt,\n-                     int options);\n+                xmlCtxtUseOptions       (xmlParserCtxtPtr ctxt,\n+                                         int options);\n@@ -1131,4 +1131,4 @@\n-        xmlReadDoc      (const xmlChar *cur,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlReadDoc              (const xmlChar *cur,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1136,3 +1136,3 @@\n-        xmlReadFile     (const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlReadFile             (const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1140,5 +1140,5 @@\n-        xmlReadMemory       (const char *buffer,\n-                     int size,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlReadMemory           (const char *buffer,\n+                                         int size,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1146,4 +1146,4 @@\n-        xmlReadFd       (int fd,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlReadFd               (int fd,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1151,6 +1151,6 @@\n-        xmlReadIO       (xmlInputReadCallback ioread,\n-                     xmlInputCloseCallback ioclose,\n-                     void *ioctx,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlReadIO               (xmlInputReadCallback ioread,\n+                                         xmlInputCloseCallback ioclose,\n+                                         void *ioctx,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1158,5 +1158,5 @@\n-        xmlCtxtReadDoc      (xmlParserCtxtPtr ctxt,\n-                     const xmlChar *cur,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlCtxtReadDoc          (xmlParserCtxtPtr ctxt,\n+                                         const xmlChar *cur,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1164,4 +1164,4 @@\n-        xmlCtxtReadFile     (xmlParserCtxtPtr ctxt,\n-                     const char *filename,\n-                     const char *encoding,\n-                     int options);\n+                xmlCtxtReadFile         (xmlParserCtxtPtr ctxt,\n+                                         const char *filename,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1169,6 +1169,6 @@\n-        xmlCtxtReadMemory       (xmlParserCtxtPtr ctxt,\n-                     const char *buffer,\n-                     int size,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlCtxtReadMemory               (xmlParserCtxtPtr ctxt,\n+                                         const char *buffer,\n+                                         int size,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1176,5 +1176,5 @@\n-        xmlCtxtReadFd       (xmlParserCtxtPtr ctxt,\n-                     int fd,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlCtxtReadFd           (xmlParserCtxtPtr ctxt,\n+                                         int fd,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1182,7 +1182,7 @@\n-        xmlCtxtReadIO       (xmlParserCtxtPtr ctxt,\n-                     xmlInputReadCallback ioread,\n-                     xmlInputCloseCallback ioclose,\n-                     void *ioctx,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlCtxtReadIO           (xmlParserCtxtPtr ctxt,\n+                                         xmlInputReadCallback ioread,\n+                                         xmlInputCloseCallback ioclose,\n+                                         void *ioctx,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1238,1 +1238,1 @@\n-        xmlHasFeature       (xmlFeature feature);\n+                xmlHasFeature           (xmlFeature feature);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/parser.h","additions":276,"deletions":276,"binary":false,"changes":552,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-#define INPUT_CHUNK 250\n+#define INPUT_CHUNK     250\n@@ -92,3 +92,3 @@\n- *                                  *\n- * UNICODE version of the macros.                   *\n- *                                  *\n+ *                                                                      *\n+ * UNICODE version of the macros.                                       *\n+ *                                                                      *\n@@ -250,2 +250,2 @@\n-#define IS_ASCII_LETTER(c)  (((0x41 <= (c)) && ((c) <= 0x5a)) || \\\n-                 ((0x61 <= (c)) && ((c) <= 0x7a)))\n+#define IS_ASCII_LETTER(c)      (((0x41 <= (c)) && ((c) <= 0x5a)) || \\\n+                                 ((0x61 <= (c)) && ((c) <= 0x7a)))\n@@ -260,1 +260,1 @@\n-#define IS_ASCII_DIGIT(c)   ((0x30 <= (c)) && ((c) <= 0x39))\n+#define IS_ASCII_DIGIT(c)       ((0x30 <= (c)) && ((c) <= 0x39))\n@@ -287,2 +287,2 @@\n-#define SKIP_EOL(p)                         \\\n-    if (*(p) == 0x13) { p++ ; if (*(p) == 0x10) p++; }          \\\n+#define SKIP_EOL(p)                                                     \\\n+    if (*(p) == 0x13) { p++ ; if (*(p) == 0x10) p++; }                  \\\n@@ -297,1 +297,1 @@\n-#define MOVETO_ENDTAG(p)                        \\\n+#define MOVETO_ENDTAG(p)                                                \\\n@@ -306,1 +306,1 @@\n-#define MOVETO_STARTTAG(p)                      \\\n+#define MOVETO_STARTTAG(p)                                              \\\n@@ -325,1 +325,1 @@\n-            xmlCreateFileParserCtxt (const char *filename);\n+                        xmlCreateFileParserCtxt (const char *filename);\n@@ -327,2 +327,2 @@\n-            xmlCreateURLParserCtxt  (const char *filename,\n-                         int options);\n+                        xmlCreateURLParserCtxt  (const char *filename,\n+                                                 int options);\n@@ -330,2 +330,2 @@\n-            xmlCreateMemoryParserCtxt(const char *buffer,\n-                         int size);\n+                        xmlCreateMemoryParserCtxt(const char *buffer,\n+                                                 int size);\n@@ -333,3 +333,3 @@\n-            xmlCreateEntityParserCtxt(const xmlChar *URL,\n-                         const xmlChar *ID,\n-                         const xmlChar *base);\n+                        xmlCreateEntityParserCtxt(const xmlChar *URL,\n+                                                 const xmlChar *ID,\n+                                                 const xmlChar *base);\n@@ -337,2 +337,2 @@\n-            xmlSwitchEncoding   (xmlParserCtxtPtr ctxt,\n-                         xmlCharEncoding enc);\n+                        xmlSwitchEncoding       (xmlParserCtxtPtr ctxt,\n+                                                 xmlCharEncoding enc);\n@@ -340,2 +340,2 @@\n-            xmlSwitchToEncoding (xmlParserCtxtPtr ctxt,\n-                     xmlCharEncodingHandlerPtr handler);\n+                        xmlSwitchToEncoding     (xmlParserCtxtPtr ctxt,\n+                                         xmlCharEncodingHandlerPtr handler);\n@@ -343,3 +343,3 @@\n-            xmlSwitchInputEncoding  (xmlParserCtxtPtr ctxt,\n-                         xmlParserInputPtr input,\n-                     xmlCharEncodingHandlerPtr handler);\n+                        xmlSwitchInputEncoding  (xmlParserCtxtPtr ctxt,\n+                                                 xmlParserInputPtr input,\n+                                         xmlCharEncodingHandlerPtr handler);\n@@ -350,5 +350,5 @@\n-            __xmlErrEncoding    (xmlParserCtxtPtr ctxt,\n-                         xmlParserErrors xmlerr,\n-                         const char *msg,\n-                         const xmlChar * str1,\n-                         const xmlChar * str2) LIBXML_ATTR_FORMAT(3,0);\n+                        __xmlErrEncoding        (xmlParserCtxtPtr ctxt,\n+                                                 xmlParserErrors xmlerr,\n+                                                 const char *msg,\n+                                                 const xmlChar * str1,\n+                                                 const xmlChar * str2) LIBXML_ATTR_FORMAT(3,0);\n@@ -361,2 +361,2 @@\n-            xmlNewStringInputStream (xmlParserCtxtPtr ctxt,\n-                         const xmlChar *buffer);\n+                        xmlNewStringInputStream (xmlParserCtxtPtr ctxt,\n+                                                 const xmlChar *buffer);\n@@ -364,2 +364,2 @@\n-            xmlNewEntityInputStream (xmlParserCtxtPtr ctxt,\n-                         xmlEntityPtr entity);\n+                        xmlNewEntityInputStream (xmlParserCtxtPtr ctxt,\n+                                                 xmlEntityPtr entity);\n@@ -367,2 +367,2 @@\n-            xmlPushInput        (xmlParserCtxtPtr ctxt,\n-                         xmlParserInputPtr input);\n+                        xmlPushInput            (xmlParserCtxtPtr ctxt,\n+                                                 xmlParserInputPtr input);\n@@ -370,1 +370,1 @@\n-            xmlPopInput     (xmlParserCtxtPtr ctxt);\n+                        xmlPopInput             (xmlParserCtxtPtr ctxt);\n@@ -372,1 +372,1 @@\n-            xmlFreeInputStream  (xmlParserInputPtr input);\n+                        xmlFreeInputStream      (xmlParserInputPtr input);\n@@ -374,2 +374,2 @@\n-            xmlNewInputFromFile (xmlParserCtxtPtr ctxt,\n-                         const char *filename);\n+                        xmlNewInputFromFile     (xmlParserCtxtPtr ctxt,\n+                                                 const char *filename);\n@@ -377,1 +377,1 @@\n-            xmlNewInputStream   (xmlParserCtxtPtr ctxt);\n+                        xmlNewInputStream       (xmlParserCtxtPtr ctxt);\n@@ -383,3 +383,3 @@\n-            xmlSplitQName       (xmlParserCtxtPtr ctxt,\n-                         const xmlChar *name,\n-                         xmlChar **prefix);\n+                        xmlSplitQName           (xmlParserCtxtPtr ctxt,\n+                                                 const xmlChar *name,\n+                                                 xmlChar **prefix);\n@@ -391,1 +391,1 @@\n-            xmlParseName        (xmlParserCtxtPtr ctxt);\n+                        xmlParseName            (xmlParserCtxtPtr ctxt);\n@@ -393,1 +393,1 @@\n-            xmlParseNmtoken     (xmlParserCtxtPtr ctxt);\n+                        xmlParseNmtoken         (xmlParserCtxtPtr ctxt);\n@@ -395,2 +395,2 @@\n-            xmlParseEntityValue (xmlParserCtxtPtr ctxt,\n-                         xmlChar **orig);\n+                        xmlParseEntityValue     (xmlParserCtxtPtr ctxt,\n+                                                 xmlChar **orig);\n@@ -398,1 +398,1 @@\n-            xmlParseAttValue    (xmlParserCtxtPtr ctxt);\n+                        xmlParseAttValue        (xmlParserCtxtPtr ctxt);\n@@ -400,1 +400,1 @@\n-            xmlParseSystemLiteral   (xmlParserCtxtPtr ctxt);\n+                        xmlParseSystemLiteral   (xmlParserCtxtPtr ctxt);\n@@ -402,1 +402,1 @@\n-            xmlParsePubidLiteral    (xmlParserCtxtPtr ctxt);\n+                        xmlParsePubidLiteral    (xmlParserCtxtPtr ctxt);\n@@ -404,2 +404,2 @@\n-            xmlParseCharData    (xmlParserCtxtPtr ctxt,\n-                         int cdata);\n+                        xmlParseCharData        (xmlParserCtxtPtr ctxt,\n+                                                 int cdata);\n@@ -407,3 +407,3 @@\n-            xmlParseExternalID  (xmlParserCtxtPtr ctxt,\n-                         xmlChar **publicID,\n-                         int strict);\n+                        xmlParseExternalID      (xmlParserCtxtPtr ctxt,\n+                                                 xmlChar **publicID,\n+                                                 int strict);\n@@ -411,1 +411,1 @@\n-            xmlParseComment     (xmlParserCtxtPtr ctxt);\n+                        xmlParseComment         (xmlParserCtxtPtr ctxt);\n@@ -413,1 +413,1 @@\n-            xmlParsePITarget    (xmlParserCtxtPtr ctxt);\n+                        xmlParsePITarget        (xmlParserCtxtPtr ctxt);\n@@ -415,1 +415,1 @@\n-            xmlParsePI      (xmlParserCtxtPtr ctxt);\n+                        xmlParsePI              (xmlParserCtxtPtr ctxt);\n@@ -417,1 +417,1 @@\n-            xmlParseNotationDecl    (xmlParserCtxtPtr ctxt);\n+                        xmlParseNotationDecl    (xmlParserCtxtPtr ctxt);\n@@ -419,1 +419,1 @@\n-            xmlParseEntityDecl  (xmlParserCtxtPtr ctxt);\n+                        xmlParseEntityDecl      (xmlParserCtxtPtr ctxt);\n@@ -421,2 +421,2 @@\n-            xmlParseDefaultDecl (xmlParserCtxtPtr ctxt,\n-                         xmlChar **value);\n+                        xmlParseDefaultDecl     (xmlParserCtxtPtr ctxt,\n+                                                 xmlChar **value);\n@@ -424,1 +424,1 @@\n-            xmlParseNotationType    (xmlParserCtxtPtr ctxt);\n+                        xmlParseNotationType    (xmlParserCtxtPtr ctxt);\n@@ -426,1 +426,1 @@\n-            xmlParseEnumerationType (xmlParserCtxtPtr ctxt);\n+                        xmlParseEnumerationType (xmlParserCtxtPtr ctxt);\n@@ -428,2 +428,2 @@\n-            xmlParseEnumeratedType  (xmlParserCtxtPtr ctxt,\n-                         xmlEnumerationPtr *tree);\n+                        xmlParseEnumeratedType  (xmlParserCtxtPtr ctxt,\n+                                                 xmlEnumerationPtr *tree);\n@@ -431,2 +431,2 @@\n-            xmlParseAttributeType   (xmlParserCtxtPtr ctxt,\n-                         xmlEnumerationPtr *tree);\n+                        xmlParseAttributeType   (xmlParserCtxtPtr ctxt,\n+                                                 xmlEnumerationPtr *tree);\n@@ -434,1 +434,1 @@\n-            xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt);\n+                        xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt);\n@@ -436,3 +436,3 @@\n-            xmlParseElementMixedContentDecl\n-                        (xmlParserCtxtPtr ctxt,\n-                         int inputchk);\n+                        xmlParseElementMixedContentDecl\n+                                                (xmlParserCtxtPtr ctxt,\n+                                                 int inputchk);\n@@ -440,3 +440,3 @@\n-            xmlParseElementChildrenContentDecl\n-                        (xmlParserCtxtPtr ctxt,\n-                         int inputchk);\n+                        xmlParseElementChildrenContentDecl\n+                                                (xmlParserCtxtPtr ctxt,\n+                                                 int inputchk);\n@@ -444,3 +444,3 @@\n-            xmlParseElementContentDecl(xmlParserCtxtPtr ctxt,\n-                         const xmlChar *name,\n-                         xmlElementContentPtr *result);\n+                        xmlParseElementContentDecl(xmlParserCtxtPtr ctxt,\n+                                                 const xmlChar *name,\n+                                                 xmlElementContentPtr *result);\n@@ -448,1 +448,1 @@\n-            xmlParseElementDecl (xmlParserCtxtPtr ctxt);\n+                        xmlParseElementDecl     (xmlParserCtxtPtr ctxt);\n@@ -450,1 +450,1 @@\n-            xmlParseMarkupDecl  (xmlParserCtxtPtr ctxt);\n+                        xmlParseMarkupDecl      (xmlParserCtxtPtr ctxt);\n@@ -452,1 +452,1 @@\n-            xmlParseCharRef     (xmlParserCtxtPtr ctxt);\n+                        xmlParseCharRef         (xmlParserCtxtPtr ctxt);\n@@ -454,1 +454,1 @@\n-            xmlParseEntityRef   (xmlParserCtxtPtr ctxt);\n+                        xmlParseEntityRef       (xmlParserCtxtPtr ctxt);\n@@ -456,1 +456,1 @@\n-            xmlParseReference   (xmlParserCtxtPtr ctxt);\n+                        xmlParseReference       (xmlParserCtxtPtr ctxt);\n@@ -458,1 +458,1 @@\n-            xmlParsePEReference (xmlParserCtxtPtr ctxt);\n+                        xmlParsePEReference     (xmlParserCtxtPtr ctxt);\n@@ -460,1 +460,1 @@\n-            xmlParseDocTypeDecl (xmlParserCtxtPtr ctxt);\n+                        xmlParseDocTypeDecl     (xmlParserCtxtPtr ctxt);\n@@ -463,2 +463,2 @@\n-            xmlParseAttribute   (xmlParserCtxtPtr ctxt,\n-                         xmlChar **value);\n+                        xmlParseAttribute       (xmlParserCtxtPtr ctxt,\n+                                                 xmlChar **value);\n@@ -466,1 +466,1 @@\n-            xmlParseStartTag    (xmlParserCtxtPtr ctxt);\n+                        xmlParseStartTag        (xmlParserCtxtPtr ctxt);\n@@ -468,1 +468,1 @@\n-            xmlParseEndTag      (xmlParserCtxtPtr ctxt);\n+                        xmlParseEndTag          (xmlParserCtxtPtr ctxt);\n@@ -471,1 +471,1 @@\n-            xmlParseCDSect      (xmlParserCtxtPtr ctxt);\n+                        xmlParseCDSect          (xmlParserCtxtPtr ctxt);\n@@ -473,1 +473,1 @@\n-            xmlParseContent     (xmlParserCtxtPtr ctxt);\n+                        xmlParseContent         (xmlParserCtxtPtr ctxt);\n@@ -475,1 +475,1 @@\n-            xmlParseElement     (xmlParserCtxtPtr ctxt);\n+                        xmlParseElement         (xmlParserCtxtPtr ctxt);\n@@ -477,1 +477,1 @@\n-            xmlParseVersionNum  (xmlParserCtxtPtr ctxt);\n+                        xmlParseVersionNum      (xmlParserCtxtPtr ctxt);\n@@ -479,1 +479,1 @@\n-            xmlParseVersionInfo (xmlParserCtxtPtr ctxt);\n+                        xmlParseVersionInfo     (xmlParserCtxtPtr ctxt);\n@@ -481,1 +481,1 @@\n-            xmlParseEncName     (xmlParserCtxtPtr ctxt);\n+                        xmlParseEncName         (xmlParserCtxtPtr ctxt);\n@@ -483,1 +483,1 @@\n-            xmlParseEncodingDecl    (xmlParserCtxtPtr ctxt);\n+                        xmlParseEncodingDecl    (xmlParserCtxtPtr ctxt);\n@@ -485,1 +485,1 @@\n-            xmlParseSDDecl      (xmlParserCtxtPtr ctxt);\n+                        xmlParseSDDecl          (xmlParserCtxtPtr ctxt);\n@@ -487,1 +487,1 @@\n-            xmlParseXMLDecl     (xmlParserCtxtPtr ctxt);\n+                        xmlParseXMLDecl         (xmlParserCtxtPtr ctxt);\n@@ -489,1 +489,1 @@\n-            xmlParseTextDecl    (xmlParserCtxtPtr ctxt);\n+                        xmlParseTextDecl        (xmlParserCtxtPtr ctxt);\n@@ -491,1 +491,1 @@\n-            xmlParseMisc        (xmlParserCtxtPtr ctxt);\n+                        xmlParseMisc            (xmlParserCtxtPtr ctxt);\n@@ -493,3 +493,3 @@\n-            xmlParseExternalSubset  (xmlParserCtxtPtr ctxt,\n-                         const xmlChar *ExternalID,\n-                         const xmlChar *SystemID);\n+                        xmlParseExternalSubset  (xmlParserCtxtPtr ctxt,\n+                                                 const xmlChar *ExternalID,\n+                                                 const xmlChar *SystemID);\n@@ -501,1 +501,1 @@\n-#define XML_SUBSTITUTE_NONE 0\n+#define XML_SUBSTITUTE_NONE     0\n@@ -507,1 +507,1 @@\n-#define XML_SUBSTITUTE_REF  1\n+#define XML_SUBSTITUTE_REF      1\n@@ -519,1 +519,1 @@\n-#define XML_SUBSTITUTE_BOTH 3\n+#define XML_SUBSTITUTE_BOTH     3\n@@ -522,6 +522,6 @@\n-        xmlStringDecodeEntities     (xmlParserCtxtPtr ctxt,\n-                         const xmlChar *str,\n-                         int what,\n-                         xmlChar end,\n-                         xmlChar  end2,\n-                         xmlChar end3);\n+                xmlStringDecodeEntities         (xmlParserCtxtPtr ctxt,\n+                                                 const xmlChar *str,\n+                                                 int what,\n+                                                 xmlChar end,\n+                                                 xmlChar  end2,\n+                                                 xmlChar end3);\n@@ -529,7 +529,7 @@\n-        xmlStringLenDecodeEntities  (xmlParserCtxtPtr ctxt,\n-                         const xmlChar *str,\n-                         int len,\n-                         int what,\n-                         xmlChar end,\n-                         xmlChar  end2,\n-                         xmlChar end3);\n+                xmlStringLenDecodeEntities      (xmlParserCtxtPtr ctxt,\n+                                                 const xmlChar *str,\n+                                                 int len,\n+                                                 int what,\n+                                                 xmlChar end,\n+                                                 xmlChar  end2,\n+                                                 xmlChar end3);\n@@ -540,9 +540,9 @@\n-XMLPUBFUN int XMLCALL           nodePush        (xmlParserCtxtPtr ctxt,\n-                         xmlNodePtr value);\n-XMLPUBFUN xmlNodePtr XMLCALL        nodePop         (xmlParserCtxtPtr ctxt);\n-XMLPUBFUN int XMLCALL           inputPush       (xmlParserCtxtPtr ctxt,\n-                         xmlParserInputPtr value);\n-XMLPUBFUN xmlParserInputPtr XMLCALL inputPop        (xmlParserCtxtPtr ctxt);\n-XMLPUBFUN const xmlChar * XMLCALL   namePop         (xmlParserCtxtPtr ctxt);\n-XMLPUBFUN int XMLCALL           namePush        (xmlParserCtxtPtr ctxt,\n-                         const xmlChar *value);\n+XMLPUBFUN int XMLCALL                   nodePush                (xmlParserCtxtPtr ctxt,\n+                                                 xmlNodePtr value);\n+XMLPUBFUN xmlNodePtr XMLCALL            nodePop                 (xmlParserCtxtPtr ctxt);\n+XMLPUBFUN int XMLCALL                   inputPush               (xmlParserCtxtPtr ctxt,\n+                                                 xmlParserInputPtr value);\n+XMLPUBFUN xmlParserInputPtr XMLCALL     inputPop                (xmlParserCtxtPtr ctxt);\n+XMLPUBFUN const xmlChar * XMLCALL       namePop                 (xmlParserCtxtPtr ctxt);\n+XMLPUBFUN int XMLCALL                   namePush                (xmlParserCtxtPtr ctxt,\n+                                                 const xmlChar *value);\n@@ -553,6 +553,6 @@\n-XMLPUBFUN int XMLCALL           xmlSkipBlankChars   (xmlParserCtxtPtr ctxt);\n-XMLPUBFUN int XMLCALL           xmlStringCurrentChar    (xmlParserCtxtPtr ctxt,\n-                         const xmlChar *cur,\n-                         int *len);\n-XMLPUBFUN void XMLCALL          xmlParserHandlePEReference(xmlParserCtxtPtr ctxt);\n-XMLPUBFUN int XMLCALL           xmlCheckLanguageID  (const xmlChar *lang);\n+XMLPUBFUN int XMLCALL                   xmlSkipBlankChars       (xmlParserCtxtPtr ctxt);\n+XMLPUBFUN int XMLCALL                   xmlStringCurrentChar    (xmlParserCtxtPtr ctxt,\n+                                                 const xmlChar *cur,\n+                                                 int *len);\n+XMLPUBFUN void XMLCALL                  xmlParserHandlePEReference(xmlParserCtxtPtr ctxt);\n+XMLPUBFUN int XMLCALL                   xmlCheckLanguageID      (const xmlChar *lang);\n@@ -563,9 +563,9 @@\n-XMLPUBFUN int XMLCALL           xmlCurrentChar      (xmlParserCtxtPtr ctxt,\n-                         int *len);\n-XMLPUBFUN int XMLCALL       xmlCopyCharMultiByte    (xmlChar *out,\n-                         int val);\n-XMLPUBFUN int XMLCALL           xmlCopyChar     (int len,\n-                         xmlChar *out,\n-                         int val);\n-XMLPUBFUN void XMLCALL          xmlNextChar     (xmlParserCtxtPtr ctxt);\n-XMLPUBFUN void XMLCALL          xmlParserInputShrink    (xmlParserInputPtr in);\n+XMLPUBFUN int XMLCALL                   xmlCurrentChar          (xmlParserCtxtPtr ctxt,\n+                                                 int *len);\n+XMLPUBFUN int XMLCALL           xmlCopyCharMultiByte    (xmlChar *out,\n+                                                 int val);\n+XMLPUBFUN int XMLCALL                   xmlCopyChar             (int len,\n+                                                 xmlChar *out,\n+                                                 int val);\n+XMLPUBFUN void XMLCALL                  xmlNextChar             (xmlParserCtxtPtr ctxt);\n+XMLPUBFUN void XMLCALL                  xmlParserInputShrink    (xmlParserInputPtr in);\n@@ -577,3 +577,3 @@\n-XMLPUBFUN void XMLCALL          htmlInitAutoClose   (void);\n-XMLPUBFUN htmlParserCtxtPtr XMLCALL htmlCreateFileParserCtxt(const char *filename,\n-                                             const char *encoding);\n+XMLPUBFUN void XMLCALL                  htmlInitAutoClose       (void);\n+XMLPUBFUN htmlParserCtxtPtr XMLCALL     htmlCreateFileParserCtxt(const char *filename,\n+                                                 const char *encoding);\n@@ -596,3 +596,3 @@\n-typedef void    (*xmlEntityReferenceFunc)   (xmlEntityPtr ent,\n-                         xmlNodePtr firstNode,\n-                         xmlNodePtr lastNode);\n+typedef void    (*xmlEntityReferenceFunc)       (xmlEntityPtr ent,\n+                                                 xmlNodePtr firstNode,\n+                                                 xmlNodePtr lastNode);\n@@ -600,1 +600,1 @@\n-XMLPUBFUN void XMLCALL      xmlSetEntityReferenceFunc   (xmlEntityReferenceFunc func);\n+XMLPUBFUN void XMLCALL          xmlSetEntityReferenceFunc       (xmlEntityReferenceFunc func);\n@@ -603,1 +603,1 @@\n-            xmlParseQuotedString    (xmlParserCtxtPtr ctxt);\n+                        xmlParseQuotedString    (xmlParserCtxtPtr ctxt);\n@@ -607,1 +607,1 @@\n-            xmlNamespaceParseNSDef  (xmlParserCtxtPtr ctxt);\n+                        xmlNamespaceParseNSDef  (xmlParserCtxtPtr ctxt);\n@@ -609,1 +609,1 @@\n-            xmlScanName     (xmlParserCtxtPtr ctxt);\n+                        xmlScanName             (xmlParserCtxtPtr ctxt);\n@@ -611,1 +611,1 @@\n-            xmlNamespaceParseNCName (xmlParserCtxtPtr ctxt);\n+                        xmlNamespaceParseNCName (xmlParserCtxtPtr ctxt);\n@@ -614,2 +614,2 @@\n-            xmlNamespaceParseQName  (xmlParserCtxtPtr ctxt,\n-                         xmlChar **prefix);\n+                        xmlNamespaceParseQName  (xmlParserCtxtPtr ctxt,\n+                                                 xmlChar **prefix);\n@@ -620,6 +620,6 @@\n-        xmlDecodeEntities       (xmlParserCtxtPtr ctxt,\n-                         int len,\n-                         int what,\n-                         xmlChar end,\n-                         xmlChar  end2,\n-                         xmlChar end3);\n+                xmlDecodeEntities               (xmlParserCtxtPtr ctxt,\n+                                                 int len,\n+                                                 int what,\n+                                                 xmlChar end,\n+                                                 xmlChar  end2,\n+                                                 xmlChar end3);\n@@ -627,2 +627,2 @@\n-            xmlHandleEntity     (xmlParserCtxtPtr ctxt,\n-                         xmlEntityPtr entity);\n+                        xmlHandleEntity         (xmlParserCtxtPtr ctxt,\n+                                                 xmlEntityPtr entity);\n@@ -637,2 +637,2 @@\n-    xmlErrMemory        (xmlParserCtxtPtr ctxt,\n-                 const char *extra);\n+        xmlErrMemory            (xmlParserCtxtPtr ctxt,\n+                                 const char *extra);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/parserInternals.h","additions":168,"deletions":168,"binary":false,"changes":336,"status":"modified"},{"patch":"@@ -40,4 +40,4 @@\n-    XML_PATTERN_DEFAULT     = 0,    \/* simple pattern match *\/\n-    XML_PATTERN_XPATH       = 1<<0, \/* standard XPath pattern *\/\n-    XML_PATTERN_XSSEL       = 1<<1, \/* XPath subset for schema selector *\/\n-    XML_PATTERN_XSFIELD     = 1<<2  \/* XPath subset for schema field *\/\n+    XML_PATTERN_DEFAULT         = 0,    \/* simple pattern match *\/\n+    XML_PATTERN_XPATH           = 1<<0, \/* standard XPath pattern *\/\n+    XML_PATTERN_XSSEL           = 1<<1, \/* XPath subset for schema selector *\/\n+    XML_PATTERN_XSFIELD         = 1<<2  \/* XPath subset for schema field *\/\n@@ -47,1 +47,1 @@\n-            xmlFreePattern      (xmlPatternPtr comp);\n+                        xmlFreePattern          (xmlPatternPtr comp);\n@@ -50,1 +50,1 @@\n-            xmlFreePatternList  (xmlPatternPtr comp);\n+                        xmlFreePatternList      (xmlPatternPtr comp);\n@@ -53,4 +53,4 @@\n-            xmlPatterncompile   (const xmlChar *pattern,\n-                         xmlDict *dict,\n-                         int flags,\n-                         const xmlChar **namespaces);\n+                        xmlPatterncompile       (const xmlChar *pattern,\n+                                                 xmlDict *dict,\n+                                                 int flags,\n+                                                 const xmlChar **namespaces);\n@@ -58,2 +58,2 @@\n-            xmlPatternMatch     (xmlPatternPtr comp,\n-                         xmlNodePtr node);\n+                        xmlPatternMatch         (xmlPatternPtr comp,\n+                                                 xmlNodePtr node);\n@@ -66,1 +66,1 @@\n-            xmlPatternStreamable    (xmlPatternPtr comp);\n+                        xmlPatternStreamable    (xmlPatternPtr comp);\n@@ -68,1 +68,1 @@\n-            xmlPatternMaxDepth  (xmlPatternPtr comp);\n+                        xmlPatternMaxDepth      (xmlPatternPtr comp);\n@@ -70,1 +70,1 @@\n-            xmlPatternMinDepth  (xmlPatternPtr comp);\n+                        xmlPatternMinDepth      (xmlPatternPtr comp);\n@@ -72,1 +72,1 @@\n-            xmlPatternFromRoot  (xmlPatternPtr comp);\n+                        xmlPatternFromRoot      (xmlPatternPtr comp);\n@@ -74,1 +74,1 @@\n-            xmlPatternGetStreamCtxt (xmlPatternPtr comp);\n+                        xmlPatternGetStreamCtxt (xmlPatternPtr comp);\n@@ -76,1 +76,1 @@\n-            xmlFreeStreamCtxt   (xmlStreamCtxtPtr stream);\n+                        xmlFreeStreamCtxt       (xmlStreamCtxtPtr stream);\n@@ -78,4 +78,4 @@\n-            xmlStreamPushNode   (xmlStreamCtxtPtr stream,\n-                         const xmlChar *name,\n-                         const xmlChar *ns,\n-                         int nodeType);\n+                        xmlStreamPushNode       (xmlStreamCtxtPtr stream,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns,\n+                                                 int nodeType);\n@@ -83,3 +83,3 @@\n-            xmlStreamPush       (xmlStreamCtxtPtr stream,\n-                         const xmlChar *name,\n-                         const xmlChar *ns);\n+                        xmlStreamPush           (xmlStreamCtxtPtr stream,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns);\n@@ -87,3 +87,3 @@\n-            xmlStreamPushAttr   (xmlStreamCtxtPtr stream,\n-                         const xmlChar *name,\n-                         const xmlChar *ns);\n+                        xmlStreamPushAttr       (xmlStreamCtxtPtr stream,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns);\n@@ -91,1 +91,1 @@\n-            xmlStreamPop        (xmlStreamCtxtPtr stream);\n+                        xmlStreamPop            (xmlStreamCtxtPtr stream);\n@@ -93,1 +93,1 @@\n-            xmlStreamWantsAnyNode   (xmlStreamCtxtPtr stream);\n+                        xmlStreamWantsAnyNode   (xmlStreamCtxtPtr stream);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/pattern.h","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n-                              const char *msg,\n-                              ...) LIBXML_ATTR_FORMAT(2,3);\n+                                                      const char *msg,\n+                                                      ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -48,2 +48,2 @@\n-                            const char *msg,\n-                            ...) LIBXML_ATTR_FORMAT(2,3);\n+                                                        const char *msg,\n+                                                        ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -120,1 +120,1 @@\n-            xmlRelaxNGInitTypes     (void);\n+                    xmlRelaxNGInitTypes         (void);\n@@ -122,1 +122,1 @@\n-            xmlRelaxNGCleanupTypes  (void);\n+                    xmlRelaxNGCleanupTypes      (void);\n@@ -128,1 +128,1 @@\n-            xmlRelaxNGNewParserCtxt (const char *URL);\n+                    xmlRelaxNGNewParserCtxt     (const char *URL);\n@@ -130,2 +130,2 @@\n-            xmlRelaxNGNewMemParserCtxt  (const char *buffer,\n-                         int size);\n+                    xmlRelaxNGNewMemParserCtxt  (const char *buffer,\n+                                                 int size);\n@@ -133,1 +133,1 @@\n-            xmlRelaxNGNewDocParserCtxt  (xmlDocPtr doc);\n+                    xmlRelaxNGNewDocParserCtxt  (xmlDocPtr doc);\n@@ -136,2 +136,2 @@\n-            xmlRelaxParserSetFlag   (xmlRelaxNGParserCtxtPtr ctxt,\n-                         int flag);\n+                    xmlRelaxParserSetFlag       (xmlRelaxNGParserCtxtPtr ctxt,\n+                                                 int flag);\n@@ -140,1 +140,1 @@\n-            xmlRelaxNGFreeParserCtxt    (xmlRelaxNGParserCtxtPtr ctxt);\n+                    xmlRelaxNGFreeParserCtxt    (xmlRelaxNGParserCtxtPtr ctxt);\n@@ -142,4 +142,4 @@\n-            xmlRelaxNGSetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,\n-                     xmlRelaxNGValidityErrorFunc err,\n-                     xmlRelaxNGValidityWarningFunc warn,\n-                     void *ctx);\n+                    xmlRelaxNGSetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,\n+                                         xmlRelaxNGValidityErrorFunc err,\n+                                         xmlRelaxNGValidityWarningFunc warn,\n+                                         void *ctx);\n@@ -147,4 +147,4 @@\n-            xmlRelaxNGGetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,\n-                     xmlRelaxNGValidityErrorFunc *err,\n-                     xmlRelaxNGValidityWarningFunc *warn,\n-                     void **ctx);\n+                    xmlRelaxNGGetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,\n+                                         xmlRelaxNGValidityErrorFunc *err,\n+                                         xmlRelaxNGValidityWarningFunc *warn,\n+                                         void **ctx);\n@@ -152,4 +152,4 @@\n-            xmlRelaxNGSetParserStructuredErrors(\n-                     xmlRelaxNGParserCtxtPtr ctxt,\n-                     xmlStructuredErrorFunc serror,\n-                     void *ctx);\n+                    xmlRelaxNGSetParserStructuredErrors(\n+                                         xmlRelaxNGParserCtxtPtr ctxt,\n+                                         xmlStructuredErrorFunc serror,\n+                                         void *ctx);\n@@ -157,1 +157,1 @@\n-            xmlRelaxNGParse     (xmlRelaxNGParserCtxtPtr ctxt);\n+                    xmlRelaxNGParse             (xmlRelaxNGParserCtxtPtr ctxt);\n@@ -159,1 +159,1 @@\n-            xmlRelaxNGFree      (xmlRelaxNGPtr schema);\n+                    xmlRelaxNGFree              (xmlRelaxNGPtr schema);\n@@ -162,2 +162,2 @@\n-            xmlRelaxNGDump      (FILE *output,\n-                     xmlRelaxNGPtr schema);\n+                    xmlRelaxNGDump              (FILE *output,\n+                                         xmlRelaxNGPtr schema);\n@@ -165,2 +165,2 @@\n-            xmlRelaxNGDumpTree  (FILE * output,\n-                     xmlRelaxNGPtr schema);\n+                    xmlRelaxNGDumpTree  (FILE * output,\n+                                         xmlRelaxNGPtr schema);\n@@ -172,4 +172,4 @@\n-            xmlRelaxNGSetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,\n-                     xmlRelaxNGValidityErrorFunc err,\n-                     xmlRelaxNGValidityWarningFunc warn,\n-                     void *ctx);\n+                    xmlRelaxNGSetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,\n+                                         xmlRelaxNGValidityErrorFunc err,\n+                                         xmlRelaxNGValidityWarningFunc warn,\n+                                         void *ctx);\n@@ -177,4 +177,4 @@\n-            xmlRelaxNGGetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,\n-                     xmlRelaxNGValidityErrorFunc *err,\n-                     xmlRelaxNGValidityWarningFunc *warn,\n-                     void **ctx);\n+                    xmlRelaxNGGetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,\n+                                         xmlRelaxNGValidityErrorFunc *err,\n+                                         xmlRelaxNGValidityWarningFunc *warn,\n+                                         void **ctx);\n@@ -182,2 +182,2 @@\n-            xmlRelaxNGSetValidStructuredErrors(xmlRelaxNGValidCtxtPtr ctxt,\n-                      xmlStructuredErrorFunc serror, void *ctx);\n+                        xmlRelaxNGSetValidStructuredErrors(xmlRelaxNGValidCtxtPtr ctxt,\n+                                          xmlStructuredErrorFunc serror, void *ctx);\n@@ -185,1 +185,1 @@\n-            xmlRelaxNGNewValidCtxt  (xmlRelaxNGPtr schema);\n+                    xmlRelaxNGNewValidCtxt      (xmlRelaxNGPtr schema);\n@@ -187,1 +187,1 @@\n-            xmlRelaxNGFreeValidCtxt (xmlRelaxNGValidCtxtPtr ctxt);\n+                    xmlRelaxNGFreeValidCtxt     (xmlRelaxNGValidCtxtPtr ctxt);\n@@ -189,2 +189,2 @@\n-            xmlRelaxNGValidateDoc   (xmlRelaxNGValidCtxtPtr ctxt,\n-                         xmlDocPtr doc);\n+                    xmlRelaxNGValidateDoc       (xmlRelaxNGValidCtxtPtr ctxt,\n+                                                 xmlDocPtr doc);\n@@ -195,3 +195,3 @@\n-            xmlRelaxNGValidatePushElement   (xmlRelaxNGValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr elem);\n+                    xmlRelaxNGValidatePushElement       (xmlRelaxNGValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem);\n@@ -199,3 +199,3 @@\n-            xmlRelaxNGValidatePushCData (xmlRelaxNGValidCtxtPtr ctxt,\n-                     const xmlChar *data,\n-                     int len);\n+                    xmlRelaxNGValidatePushCData (xmlRelaxNGValidCtxtPtr ctxt,\n+                                         const xmlChar *data,\n+                                         int len);\n@@ -203,3 +203,3 @@\n-            xmlRelaxNGValidatePopElement    (xmlRelaxNGValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr elem);\n+                    xmlRelaxNGValidatePopElement        (xmlRelaxNGValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem);\n@@ -207,3 +207,3 @@\n-            xmlRelaxNGValidateFullElement   (xmlRelaxNGValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr elem);\n+                    xmlRelaxNGValidateFullElement       (xmlRelaxNGValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/relaxng.h","additions":57,"deletions":57,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- *      The Schemas development is a Work In Progress.\n+ *              The Schemas development is a Work In Progress.\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/schemasInternals.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-    XML_SCHEMATRON_OUT_IO = 1 << 10 \/* output to I\/O mechanism *\/\n+    XML_SCHEMATRON_OUT_IO = 1 << 10     \/* output to I\/O mechanism *\/\n@@ -73,1 +73,1 @@\n-        xmlSchematronNewParserCtxt  (const char *URL);\n+            xmlSchematronNewParserCtxt  (const char *URL);\n@@ -75,2 +75,2 @@\n-        xmlSchematronNewMemParserCtxt(const char *buffer,\n-                     int size);\n+            xmlSchematronNewMemParserCtxt(const char *buffer,\n+                                         int size);\n@@ -78,1 +78,1 @@\n-        xmlSchematronNewDocParserCtxt(xmlDocPtr doc);\n+            xmlSchematronNewDocParserCtxt(xmlDocPtr doc);\n@@ -80,1 +80,1 @@\n-        xmlSchematronFreeParserCtxt (xmlSchematronParserCtxtPtr ctxt);\n+            xmlSchematronFreeParserCtxt (xmlSchematronParserCtxtPtr ctxt);\n@@ -83,4 +83,4 @@\n-        xmlSchematronSetParserErrors(xmlSchematronParserCtxtPtr ctxt,\n-                     xmlSchematronValidityErrorFunc err,\n-                     xmlSchematronValidityWarningFunc warn,\n-                     void *ctx);\n+            xmlSchematronSetParserErrors(xmlSchematronParserCtxtPtr ctxt,\n+                                         xmlSchematronValidityErrorFunc err,\n+                                         xmlSchematronValidityWarningFunc warn,\n+                                         void *ctx);\n@@ -88,4 +88,4 @@\n-        xmlSchematronGetParserErrors(xmlSchematronParserCtxtPtr ctxt,\n-                    xmlSchematronValidityErrorFunc * err,\n-                    xmlSchematronValidityWarningFunc * warn,\n-                    void **ctx);\n+                xmlSchematronGetParserErrors(xmlSchematronParserCtxtPtr ctxt,\n+                                        xmlSchematronValidityErrorFunc * err,\n+                                        xmlSchematronValidityWarningFunc * warn,\n+                                        void **ctx);\n@@ -93,1 +93,1 @@\n-        xmlSchematronIsValid    (xmlSchematronValidCtxtPtr ctxt);\n+                xmlSchematronIsValid    (xmlSchematronValidCtxtPtr ctxt);\n@@ -96,1 +96,1 @@\n-        xmlSchematronParse      (xmlSchematronParserCtxtPtr ctxt);\n+            xmlSchematronParse          (xmlSchematronParserCtxtPtr ctxt);\n@@ -98,1 +98,1 @@\n-        xmlSchematronFree       (xmlSchematronPtr schema);\n+            xmlSchematronFree           (xmlSchematronPtr schema);\n@@ -103,4 +103,4 @@\n-        xmlSchematronSetValidStructuredErrors(\n-                                      xmlSchematronValidCtxtPtr ctxt,\n-                      xmlStructuredErrorFunc serror,\n-                      void *ctx);\n+            xmlSchematronSetValidStructuredErrors(\n+                                          xmlSchematronValidCtxtPtr ctxt,\n+                                          xmlStructuredErrorFunc serror,\n+                                          void *ctx);\n@@ -109,4 +109,4 @@\n-        xmlSchematronSetValidErrors (xmlSchematronValidCtxtPtr ctxt,\n-                     xmlSchematronValidityErrorFunc err,\n-                     xmlSchematronValidityWarningFunc warn,\n-                     void *ctx);\n+            xmlSchematronSetValidErrors (xmlSchematronValidCtxtPtr ctxt,\n+                                         xmlSchematronValidityErrorFunc err,\n+                                         xmlSchematronValidityWarningFunc warn,\n+                                         void *ctx);\n@@ -114,4 +114,4 @@\n-        xmlSchematronGetValidErrors (xmlSchematronValidCtxtPtr ctxt,\n-                     xmlSchematronValidityErrorFunc *err,\n-                     xmlSchematronValidityWarningFunc *warn,\n-                     void **ctx);\n+            xmlSchematronGetValidErrors (xmlSchematronValidCtxtPtr ctxt,\n+                                         xmlSchematronValidityErrorFunc *err,\n+                                         xmlSchematronValidityWarningFunc *warn,\n+                                         void **ctx);\n@@ -119,2 +119,2 @@\n-        xmlSchematronSetValidOptions(xmlSchematronValidCtxtPtr ctxt,\n-                     int options);\n+            xmlSchematronSetValidOptions(xmlSchematronValidCtxtPtr ctxt,\n+                                         int options);\n@@ -122,1 +122,1 @@\n-        xmlSchematronValidCtxtGetOptions(xmlSchematronValidCtxtPtr ctxt);\n+            xmlSchematronValidCtxtGetOptions(xmlSchematronValidCtxtPtr ctxt);\n@@ -125,1 +125,1 @@\n-                             xmlNodePtr elem);\n+                                         xmlNodePtr elem);\n@@ -129,2 +129,2 @@\n-        xmlSchematronNewValidCtxt   (xmlSchematronPtr schema,\n-                     int options);\n+            xmlSchematronNewValidCtxt   (xmlSchematronPtr schema,\n+                                         int options);\n@@ -132,1 +132,1 @@\n-        xmlSchematronFreeValidCtxt  (xmlSchematronValidCtxtPtr ctxt);\n+            xmlSchematronFreeValidCtxt  (xmlSchematronValidCtxtPtr ctxt);\n@@ -134,2 +134,2 @@\n-        xmlSchematronValidateDoc    (xmlSchematronValidCtxtPtr ctxt,\n-                     xmlDocPtr instance);\n+            xmlSchematronValidateDoc    (xmlSchematronValidCtxtPtr ctxt,\n+                                         xmlDocPtr instance);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/schematron.h","additions":38,"deletions":38,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-            xmlNewMutex (void);\n+                        xmlNewMutex     (void);\n@@ -42,1 +42,1 @@\n-            xmlMutexLock    (xmlMutexPtr tok);\n+                        xmlMutexLock    (xmlMutexPtr tok);\n@@ -44,1 +44,1 @@\n-            xmlMutexUnlock  (xmlMutexPtr tok);\n+                        xmlMutexUnlock  (xmlMutexPtr tok);\n@@ -46,1 +46,1 @@\n-            xmlFreeMutex    (xmlMutexPtr tok);\n+                        xmlFreeMutex    (xmlMutexPtr tok);\n@@ -49,1 +49,1 @@\n-            xmlNewRMutex    (void);\n+                        xmlNewRMutex    (void);\n@@ -51,1 +51,1 @@\n-            xmlRMutexLock   (xmlRMutexPtr tok);\n+                        xmlRMutexLock   (xmlRMutexPtr tok);\n@@ -53,1 +53,1 @@\n-            xmlRMutexUnlock (xmlRMutexPtr tok);\n+                        xmlRMutexUnlock (xmlRMutexPtr tok);\n@@ -55,1 +55,1 @@\n-            xmlFreeRMutex   (xmlRMutexPtr tok);\n+                        xmlFreeRMutex   (xmlRMutexPtr tok);\n@@ -61,1 +61,1 @@\n-            xmlInitThreads  (void);\n+                        xmlInitThreads  (void);\n@@ -63,1 +63,1 @@\n-            xmlLockLibrary  (void);\n+                        xmlLockLibrary  (void);\n@@ -65,1 +65,1 @@\n-            xmlUnlockLibrary(void);\n+                        xmlUnlockLibrary(void);\n@@ -67,1 +67,1 @@\n-            xmlGetThreadId  (void);\n+                        xmlGetThreadId  (void);\n@@ -69,1 +69,1 @@\n-            xmlIsMainThread (void);\n+                        xmlIsMainThread (void);\n@@ -71,1 +71,1 @@\n-            xmlCleanupThreads(void);\n+                        xmlCleanupThreads(void);\n@@ -73,1 +73,1 @@\n-            xmlGetGlobalState(void);\n+                        xmlGetGlobalState(void);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/threads.h","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-    XML_BUFFER_ALLOC_EXACT, \/* grow only to the minimal size *\/\n+    XML_BUFFER_ALLOC_EXACT,     \/* grow only to the minimal size *\/\n@@ -78,1 +78,1 @@\n-    XML_BUFFER_ALLOC_IO,    \/* special allocation scheme used for I\/O *\/\n+    XML_BUFFER_ALLOC_IO,        \/* special allocation scheme used for I\/O *\/\n@@ -92,3 +92,3 @@\n-    xmlChar *content;       \/* The buffer content UTF8 *\/\n-    unsigned int use;       \/* The buffer size used *\/\n-    unsigned int size;      \/* The buffer size *\/\n+    xmlChar *content;           \/* The buffer content UTF8 *\/\n+    unsigned int use;           \/* The buffer size used *\/\n+    unsigned int size;          \/* The buffer size *\/\n@@ -96,1 +96,1 @@\n-    xmlChar *contentIO;     \/* in IO mode we may have a different base *\/\n+    xmlChar *contentIO;         \/* in IO mode we may have a different base *\/\n@@ -160,20 +160,20 @@\n-    XML_ELEMENT_NODE=       1,\n-    XML_ATTRIBUTE_NODE=     2,\n-    XML_TEXT_NODE=      3,\n-    XML_CDATA_SECTION_NODE= 4,\n-    XML_ENTITY_REF_NODE=    5,\n-    XML_ENTITY_NODE=        6,\n-    XML_PI_NODE=        7,\n-    XML_COMMENT_NODE=       8,\n-    XML_DOCUMENT_NODE=      9,\n-    XML_DOCUMENT_TYPE_NODE= 10,\n-    XML_DOCUMENT_FRAG_NODE= 11,\n-    XML_NOTATION_NODE=      12,\n-    XML_HTML_DOCUMENT_NODE= 13,\n-    XML_DTD_NODE=       14,\n-    XML_ELEMENT_DECL=       15,\n-    XML_ATTRIBUTE_DECL=     16,\n-    XML_ENTITY_DECL=        17,\n-    XML_NAMESPACE_DECL=     18,\n-    XML_XINCLUDE_START=     19,\n-    XML_XINCLUDE_END=       20\n+    XML_ELEMENT_NODE=           1,\n+    XML_ATTRIBUTE_NODE=         2,\n+    XML_TEXT_NODE=              3,\n+    XML_CDATA_SECTION_NODE=     4,\n+    XML_ENTITY_REF_NODE=        5,\n+    XML_ENTITY_NODE=            6,\n+    XML_PI_NODE=                7,\n+    XML_COMMENT_NODE=           8,\n+    XML_DOCUMENT_NODE=          9,\n+    XML_DOCUMENT_TYPE_NODE=     10,\n+    XML_DOCUMENT_FRAG_NODE=     11,\n+    XML_NOTATION_NODE=          12,\n+    XML_HTML_DOCUMENT_NODE=     13,\n+    XML_DTD_NODE=               14,\n+    XML_ELEMENT_DECL=           15,\n+    XML_ATTRIBUTE_DECL=         16,\n+    XML_ENTITY_DECL=            17,\n+    XML_NAMESPACE_DECL=         18,\n+    XML_XINCLUDE_START=         19,\n+    XML_XINCLUDE_END=           20\n@@ -181,1 +181,1 @@\n-   ,XML_DOCB_DOCUMENT_NODE= 21\n+   ,XML_DOCB_DOCUMENT_NODE=     21\n@@ -196,2 +196,2 @@\n-    const xmlChar               *PublicID;  \/* Public identifier, if any *\/\n-    const xmlChar               *SystemID;  \/* System identifier, if any *\/\n+    const xmlChar               *PublicID;      \/* Public identifier, if any *\/\n+    const xmlChar               *SystemID;      \/* System identifier, if any *\/\n@@ -242,1 +242,1 @@\n-    const xmlChar            *name; \/* Enumeration name *\/\n+    const xmlChar            *name;     \/* Enumeration name *\/\n@@ -256,6 +256,6 @@\n-    const xmlChar          *name;   \/* Attribute name *\/\n-    struct _xmlNode    *children;   \/* NULL *\/\n-    struct _xmlNode        *last;   \/* NULL *\/\n-    struct _xmlDtd       *parent;   \/* -> DTD *\/\n-    struct _xmlNode        *next;   \/* next sibling link  *\/\n-    struct _xmlNode        *prev;   \/* previous sibling link  *\/\n+    const xmlChar          *name;       \/* Attribute name *\/\n+    struct _xmlNode    *children;       \/* NULL *\/\n+    struct _xmlNode        *last;       \/* NULL *\/\n+    struct _xmlDtd       *parent;       \/* -> DTD *\/\n+    struct _xmlNode        *next;       \/* next sibling link  *\/\n+    struct _xmlNode        *prev;       \/* previous sibling link  *\/\n@@ -264,4 +264,4 @@\n-    struct _xmlAttribute  *nexth;   \/* next in hash table *\/\n-    xmlAttributeType       atype;   \/* The attribute type *\/\n-    xmlAttributeDefault      def;   \/* the default *\/\n-    const xmlChar  *defaultValue;   \/* or the default value *\/\n+    struct _xmlAttribute  *nexth;       \/* next in hash table *\/\n+    xmlAttributeType       atype;       \/* The attribute type *\/\n+    xmlAttributeDefault      def;       \/* the default *\/\n+    const xmlChar  *defaultValue;       \/* or the default value *\/\n@@ -269,2 +269,2 @@\n-    const xmlChar        *prefix;   \/* the namespace prefix if any *\/\n-    const xmlChar          *elem;   \/* Element holding the attribute *\/\n+    const xmlChar        *prefix;       \/* the namespace prefix if any *\/\n+    const xmlChar          *elem;       \/* Element holding the attribute *\/\n@@ -307,2 +307,2 @@\n-    xmlElementContentType     type; \/* PCDATA, ELEMENT, SEQ or OR *\/\n-    xmlElementContentOccur    ocur; \/* ONCE, OPT, MULT or PLUS *\/\n+    xmlElementContentType     type;     \/* PCDATA, ELEMENT, SEQ or OR *\/\n+    xmlElementContentOccur    ocur;     \/* ONCE, OPT, MULT or PLUS *\/\n@@ -310,2 +310,2 @@\n-    struct _xmlElementContent *c1;  \/* first child *\/\n-    struct _xmlElementContent *c2;  \/* second child *\/\n+    struct _xmlElementContent *c1;      \/* first child *\/\n+    struct _xmlElementContent *c2;      \/* second child *\/\n@@ -349,6 +349,6 @@\n-    const xmlChar          *name;   \/* Element name *\/\n-    struct _xmlNode    *children;   \/* NULL *\/\n-    struct _xmlNode        *last;   \/* NULL *\/\n-    struct _xmlDtd       *parent;   \/* -> DTD *\/\n-    struct _xmlNode        *next;   \/* next sibling link  *\/\n-    struct _xmlNode        *prev;   \/* previous sibling link  *\/\n+    const xmlChar          *name;       \/* Element name *\/\n+    struct _xmlNode    *children;       \/* NULL *\/\n+    struct _xmlNode        *last;       \/* NULL *\/\n+    struct _xmlDtd       *parent;       \/* -> DTD *\/\n+    struct _xmlNode        *next;       \/* next sibling link  *\/\n+    struct _xmlNode        *prev;       \/* previous sibling link  *\/\n@@ -357,4 +357,4 @@\n-    xmlElementTypeVal      etype;   \/* The type *\/\n-    xmlElementContentPtr content;   \/* the allowed element content *\/\n-    xmlAttributePtr   attributes;   \/* List of the declared attributes *\/\n-    const xmlChar        *prefix;   \/* the namespace prefix if any *\/\n+    xmlElementTypeVal      etype;       \/* The type *\/\n+    xmlElementContentPtr content;       \/* the allowed element content *\/\n+    xmlAttributePtr   attributes;       \/* List of the declared attributes *\/\n+    const xmlChar        *prefix;       \/* the namespace prefix if any *\/\n@@ -362,1 +362,1 @@\n-    xmlRegexpPtr       contModel;   \/* the validating regexp *\/\n+    xmlRegexpPtr       contModel;       \/* the validating regexp *\/\n@@ -364,1 +364,1 @@\n-    void          *contModel;\n+    void              *contModel;\n@@ -390,4 +390,4 @@\n-    struct _xmlNs  *next;   \/* next Ns link for this node  *\/\n-    xmlNsType      type;    \/* global or local *\/\n-    const xmlChar *href;    \/* URL for the namespace *\/\n-    const xmlChar *prefix;  \/* prefix for the namespace *\/\n+    struct _xmlNs  *next;       \/* next Ns link for this node  *\/\n+    xmlNsType      type;        \/* global or local *\/\n+    const xmlChar *href;        \/* URL for the namespace *\/\n+    const xmlChar *prefix;      \/* prefix for the namespace *\/\n@@ -395,1 +395,1 @@\n-    struct _xmlDoc *context;        \/* normally an xmlDoc *\/\n+    struct _xmlDoc *context;            \/* normally an xmlDoc *\/\n@@ -409,1 +409,1 @@\n-    const xmlChar *name;    \/* Name of the DTD *\/\n+    const xmlChar *name;        \/* Name of the DTD *\/\n@@ -411,1 +411,1 @@\n-    struct _xmlNode *last;  \/* last child link *\/\n+    struct _xmlNode *last;      \/* last child link *\/\n@@ -413,3 +413,3 @@\n-    struct _xmlNode *next;  \/* next sibling link  *\/\n-    struct _xmlNode *prev;  \/* previous sibling link  *\/\n-    struct _xmlDoc  *doc;   \/* the containing document *\/\n+    struct _xmlNode *next;      \/* next sibling link  *\/\n+    struct _xmlNode *prev;      \/* previous sibling link  *\/\n+    struct _xmlDoc  *doc;       \/* the containing document *\/\n@@ -439,1 +439,1 @@\n-    struct _xmlNode *last;  \/* NULL *\/\n+    struct _xmlNode *last;      \/* NULL *\/\n@@ -441,3 +441,3 @@\n-    struct _xmlAttr *next;  \/* next sibling link  *\/\n-    struct _xmlAttr *prev;  \/* previous sibling link  *\/\n-    struct _xmlDoc  *doc;   \/* the containing document *\/\n+    struct _xmlAttr *next;      \/* next sibling link  *\/\n+    struct _xmlAttr *prev;      \/* previous sibling link  *\/\n+    struct _xmlDoc  *doc;       \/* the containing document *\/\n@@ -446,1 +446,1 @@\n-    void            *psvi;  \/* for type\/PSVI information *\/\n+    void            *psvi;      \/* for type\/PSVI information *\/\n@@ -458,1 +458,1 @@\n-    struct _xmlID    *next; \/* next ID *\/\n+    struct _xmlID    *next;     \/* next ID *\/\n@@ -460,2 +460,2 @@\n-    xmlAttrPtr        attr; \/* The attribute holding it *\/\n-    const xmlChar    *name; \/* The attribute if attr is not available *\/\n+    xmlAttrPtr        attr;     \/* The attribute holding it *\/\n+    const xmlChar    *name;     \/* The attribute if attr is not available *\/\n@@ -463,1 +463,1 @@\n-    struct _xmlDoc   *doc;  \/* The document holding the ID *\/\n+    struct _xmlDoc   *doc;      \/* The document holding the ID *\/\n@@ -477,2 +477,2 @@\n-    xmlAttrPtr        attr; \/* The attribute holding it *\/\n-    const xmlChar    *name; \/* The attribute if attr is not available *\/\n+    xmlAttrPtr        attr;     \/* The attribute holding it *\/\n+    const xmlChar    *name;     \/* The attribute if attr is not available *\/\n@@ -491,1 +491,1 @@\n-    xmlElementType   type;  \/* type number, must be second ! *\/\n+    xmlElementType   type;      \/* type number, must be second ! *\/\n@@ -494,1 +494,1 @@\n-    struct _xmlNode *last;  \/* last child link *\/\n+    struct _xmlNode *last;      \/* last child link *\/\n@@ -496,3 +496,3 @@\n-    struct _xmlNode *next;  \/* next sibling link  *\/\n-    struct _xmlNode *prev;  \/* previous sibling link  *\/\n-    struct _xmlDoc  *doc;   \/* the containing document *\/\n+    struct _xmlNode *next;      \/* next sibling link  *\/\n+    struct _xmlNode *prev;      \/* previous sibling link  *\/\n+    struct _xmlDoc  *doc;       \/* the containing document *\/\n@@ -505,3 +505,3 @@\n-    void            *psvi;  \/* for type\/PSVI information *\/\n-    unsigned short   line;  \/* line number *\/\n-    unsigned short   extra; \/* extra data for XPath\/XSLT *\/\n+    void            *psvi;      \/* for type\/PSVI information *\/\n+    unsigned short   line;      \/* line number *\/\n+    unsigned short   extra;     \/* extra data for XPath\/XSLT *\/\n@@ -515,1 +515,1 @@\n-#define XML_GET_CONTENT(n)                  \\\n+#define XML_GET_CONTENT(n)                                      \\\n@@ -523,1 +523,1 @@\n-#define XML_GET_LINE(n)                     \\\n+#define XML_GET_LINE(n)                                         \\\n@@ -533,6 +533,6 @@\n-    XML_DOC_WELLFORMED      = 1<<0, \/* document is XML well formed *\/\n-    XML_DOC_NSVALID     = 1<<1, \/* document is Namespace valid *\/\n-    XML_DOC_OLD10       = 1<<2, \/* parsed with old XML-1.0 parser *\/\n-    XML_DOC_DTDVALID        = 1<<3, \/* DTD validation was successful *\/\n-    XML_DOC_XINCLUDE        = 1<<4, \/* XInclude substitution was done *\/\n-    XML_DOC_USERBUILT       = 1<<5, \/* Document was built using the API\n+    XML_DOC_WELLFORMED          = 1<<0, \/* document is XML well formed *\/\n+    XML_DOC_NSVALID             = 1<<1, \/* document is Namespace valid *\/\n+    XML_DOC_OLD10               = 1<<2, \/* parsed with old XML-1.0 parser *\/\n+    XML_DOC_DTDVALID            = 1<<3, \/* DTD validation was successful *\/\n+    XML_DOC_XINCLUDE            = 1<<4, \/* XInclude substitution was done *\/\n+    XML_DOC_USERBUILT           = 1<<5, \/* Document was built using the API\n@@ -540,2 +540,2 @@\n-    XML_DOC_INTERNAL        = 1<<6, \/* built for internal processing *\/\n-    XML_DOC_HTML        = 1<<7  \/* parsed or built HTML document *\/\n+    XML_DOC_INTERNAL            = 1<<6, \/* built for internal processing *\/\n+    XML_DOC_HTML                = 1<<7  \/* parsed or built HTML document *\/\n@@ -554,1 +554,1 @@\n-    char           *name;   \/* name\/filename\/URI of the document *\/\n+    char           *name;       \/* name\/filename\/URI of the document *\/\n@@ -556,1 +556,1 @@\n-    struct _xmlNode *last;  \/* last child link *\/\n+    struct _xmlNode *last;      \/* last child link *\/\n@@ -558,3 +558,3 @@\n-    struct _xmlNode *next;  \/* next sibling link  *\/\n-    struct _xmlNode *prev;  \/* previous sibling link  *\/\n-    struct _xmlDoc  *doc;   \/* autoreference to itself *\/\n+    struct _xmlNode *next;      \/* next sibling link  *\/\n+    struct _xmlNode *prev;      \/* previous sibling link  *\/\n+    struct _xmlDoc  *doc;       \/* autoreference to itself *\/\n@@ -565,5 +565,5 @@\n-                     1 if standalone=\"yes\"\n-                     0 if standalone=\"no\"\n-                    -1 if there is no XML declaration\n-                    -2 if there is an XML declaration, but no\n-                    standalone attribute was specified *\/\n+                                     1 if standalone=\"yes\"\n+                                     0 if standalone=\"no\"\n+                                    -1 if there is no XML declaration\n+                                    -2 if there is an XML declaration, but no\n+                                        standalone attribute was specified *\/\n@@ -572,1 +572,1 @@\n-    struct _xmlNs   *oldNs; \/* Global namespace, the old way *\/\n+    struct _xmlNs   *oldNs;     \/* Global namespace, the old way *\/\n@@ -577,1 +577,1 @@\n-    const xmlChar  *URL;    \/* The URI for that document *\/\n+    const xmlChar  *URL;        \/* The URI for that document *\/\n@@ -579,1 +579,1 @@\n-                   actually an xmlCharEncoding *\/\n+                                   actually an xmlCharEncoding *\/\n@@ -581,1 +581,1 @@\n-    void           *psvi;   \/* for type\/PSVI information *\/\n+    void           *psvi;       \/* for type\/PSVI information *\/\n@@ -583,1 +583,1 @@\n-                   document *\/\n+                                   document *\/\n@@ -585,1 +585,1 @@\n-                   set at the end of parsing *\/\n+                                   set at the end of parsing *\/\n@@ -604,3 +604,3 @@\n-                         xmlNodePtr node,\n-                         const xmlChar *nsName,\n-                         const xmlChar *nsPrefix);\n+                                                 xmlNodePtr node,\n+                                                 const xmlChar *nsName,\n+                                                 const xmlChar *nsPrefix);\n@@ -664,2 +664,2 @@\n-        xmlValidateNCName   (const xmlChar *value,\n-                     int space);\n+                xmlValidateNCName       (const xmlChar *value,\n+                                         int space);\n@@ -670,2 +670,2 @@\n-        xmlValidateQName    (const xmlChar *value,\n-                     int space);\n+                xmlValidateQName        (const xmlChar *value,\n+                                         int space);\n@@ -673,2 +673,2 @@\n-        xmlValidateName     (const xmlChar *value,\n-                     int space);\n+                xmlValidateName         (const xmlChar *value,\n+                                         int space);\n@@ -676,2 +676,2 @@\n-        xmlValidateNMToken  (const xmlChar *value,\n-                     int space);\n+                xmlValidateNMToken      (const xmlChar *value,\n+                                         int space);\n@@ -681,4 +681,4 @@\n-        xmlBuildQName       (const xmlChar *ncname,\n-                     const xmlChar *prefix,\n-                     xmlChar *memory,\n-                     int len);\n+                xmlBuildQName           (const xmlChar *ncname,\n+                                         const xmlChar *prefix,\n+                                         xmlChar *memory,\n+                                         int len);\n@@ -686,2 +686,2 @@\n-        xmlSplitQName2      (const xmlChar *name,\n-                     xmlChar **prefix);\n+                xmlSplitQName2          (const xmlChar *name,\n+                                         xmlChar **prefix);\n@@ -689,2 +689,2 @@\n-        xmlSplitQName3      (const xmlChar *name,\n-                     int *len);\n+                xmlSplitQName3          (const xmlChar *name,\n+                                         int *len);\n@@ -697,1 +697,1 @@\n-        xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme);\n+                xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme);\n@@ -699,1 +699,1 @@\n-        xmlGetBufferAllocationScheme(void);\n+                xmlGetBufferAllocationScheme(void);\n@@ -702,1 +702,1 @@\n-        xmlBufferCreate     (void);\n+                xmlBufferCreate         (void);\n@@ -704,1 +704,1 @@\n-        xmlBufferCreateSize (size_t size);\n+                xmlBufferCreateSize     (size_t size);\n@@ -706,2 +706,2 @@\n-        xmlBufferCreateStatic   (void *mem,\n-                     size_t size);\n+                xmlBufferCreateStatic   (void *mem,\n+                                         size_t size);\n@@ -709,2 +709,2 @@\n-        xmlBufferResize     (xmlBufferPtr buf,\n-                     unsigned int size);\n+                xmlBufferResize         (xmlBufferPtr buf,\n+                                         unsigned int size);\n@@ -712,1 +712,1 @@\n-        xmlBufferFree       (xmlBufferPtr buf);\n+                xmlBufferFree           (xmlBufferPtr buf);\n@@ -714,2 +714,2 @@\n-        xmlBufferDump       (FILE *file,\n-                     xmlBufferPtr buf);\n+                xmlBufferDump           (FILE *file,\n+                                         xmlBufferPtr buf);\n@@ -717,3 +717,3 @@\n-        xmlBufferAdd        (xmlBufferPtr buf,\n-                     const xmlChar *str,\n-                     int len);\n+                xmlBufferAdd            (xmlBufferPtr buf,\n+                                         const xmlChar *str,\n+                                         int len);\n@@ -721,3 +721,3 @@\n-        xmlBufferAddHead    (xmlBufferPtr buf,\n-                     const xmlChar *str,\n-                     int len);\n+                xmlBufferAddHead        (xmlBufferPtr buf,\n+                                         const xmlChar *str,\n+                                         int len);\n@@ -725,2 +725,2 @@\n-        xmlBufferCat        (xmlBufferPtr buf,\n-                     const xmlChar *str);\n+                xmlBufferCat            (xmlBufferPtr buf,\n+                                         const xmlChar *str);\n@@ -728,2 +728,2 @@\n-        xmlBufferCCat       (xmlBufferPtr buf,\n-                     const char *str);\n+                xmlBufferCCat           (xmlBufferPtr buf,\n+                                         const char *str);\n@@ -731,2 +731,2 @@\n-        xmlBufferShrink     (xmlBufferPtr buf,\n-                     unsigned int len);\n+                xmlBufferShrink         (xmlBufferPtr buf,\n+                                         unsigned int len);\n@@ -734,2 +734,2 @@\n-        xmlBufferGrow       (xmlBufferPtr buf,\n-                     unsigned int len);\n+                xmlBufferGrow           (xmlBufferPtr buf,\n+                                         unsigned int len);\n@@ -737,1 +737,1 @@\n-        xmlBufferEmpty      (xmlBufferPtr buf);\n+                xmlBufferEmpty          (xmlBufferPtr buf);\n@@ -739,1 +739,1 @@\n-        xmlBufferContent    (const xmlBuffer *buf);\n+                xmlBufferContent        (const xmlBuffer *buf);\n@@ -741,1 +741,1 @@\n-        xmlBufferDetach         (xmlBufferPtr buf);\n+                xmlBufferDetach         (xmlBufferPtr buf);\n@@ -743,2 +743,2 @@\n-        xmlBufferSetAllocationScheme(xmlBufferPtr buf,\n-                     xmlBufferAllocationScheme scheme);\n+                xmlBufferSetAllocationScheme(xmlBufferPtr buf,\n+                                         xmlBufferAllocationScheme scheme);\n@@ -746,1 +746,1 @@\n-        xmlBufferLength     (const xmlBuffer *buf);\n+                xmlBufferLength         (const xmlBuffer *buf);\n@@ -752,4 +752,4 @@\n-        xmlCreateIntSubset  (xmlDocPtr doc,\n-                     const xmlChar *name,\n-                     const xmlChar *ExternalID,\n-                     const xmlChar *SystemID);\n+                xmlCreateIntSubset      (xmlDocPtr doc,\n+                                         const xmlChar *name,\n+                                         const xmlChar *ExternalID,\n+                                         const xmlChar *SystemID);\n@@ -757,4 +757,4 @@\n-        xmlNewDtd       (xmlDocPtr doc,\n-                     const xmlChar *name,\n-                     const xmlChar *ExternalID,\n-                     const xmlChar *SystemID);\n+                xmlNewDtd               (xmlDocPtr doc,\n+                                         const xmlChar *name,\n+                                         const xmlChar *ExternalID,\n+                                         const xmlChar *SystemID);\n@@ -762,1 +762,1 @@\n-        xmlGetIntSubset     (const xmlDoc *doc);\n+                xmlGetIntSubset         (const xmlDoc *doc);\n@@ -764,1 +764,1 @@\n-        xmlFreeDtd      (xmlDtdPtr cur);\n+                xmlFreeDtd              (xmlDtdPtr cur);\n@@ -767,3 +767,3 @@\n-        xmlNewGlobalNs      (xmlDocPtr doc,\n-                     const xmlChar *href,\n-                     const xmlChar *prefix);\n+                xmlNewGlobalNs          (xmlDocPtr doc,\n+                                         const xmlChar *href,\n+                                         const xmlChar *prefix);\n@@ -772,3 +772,3 @@\n-        xmlNewNs        (xmlNodePtr node,\n-                     const xmlChar *href,\n-                     const xmlChar *prefix);\n+                xmlNewNs                (xmlNodePtr node,\n+                                         const xmlChar *href,\n+                                         const xmlChar *prefix);\n@@ -776,1 +776,1 @@\n-        xmlFreeNs       (xmlNsPtr cur);\n+                xmlFreeNs               (xmlNsPtr cur);\n@@ -778,1 +778,1 @@\n-        xmlFreeNsList       (xmlNsPtr cur);\n+                xmlFreeNsList           (xmlNsPtr cur);\n@@ -780,1 +780,1 @@\n-        xmlNewDoc       (const xmlChar *version);\n+                xmlNewDoc               (const xmlChar *version);\n@@ -782,1 +782,1 @@\n-        xmlFreeDoc      (xmlDocPtr cur);\n+                xmlFreeDoc              (xmlDocPtr cur);\n@@ -784,3 +784,3 @@\n-        xmlNewDocProp       (xmlDocPtr doc,\n-                     const xmlChar *name,\n-                     const xmlChar *value);\n+                xmlNewDocProp           (xmlDocPtr doc,\n+                                         const xmlChar *name,\n+                                         const xmlChar *value);\n@@ -790,3 +790,3 @@\n-        xmlNewProp      (xmlNodePtr node,\n-                     const xmlChar *name,\n-                     const xmlChar *value);\n+                xmlNewProp              (xmlNodePtr node,\n+                                         const xmlChar *name,\n+                                         const xmlChar *value);\n@@ -795,4 +795,4 @@\n-        xmlNewNsProp        (xmlNodePtr node,\n-                     xmlNsPtr ns,\n-                     const xmlChar *name,\n-                     const xmlChar *value);\n+                xmlNewNsProp            (xmlNodePtr node,\n+                                         xmlNsPtr ns,\n+                                         const xmlChar *name,\n+                                         const xmlChar *value);\n@@ -800,4 +800,4 @@\n-        xmlNewNsPropEatName (xmlNodePtr node,\n-                     xmlNsPtr ns,\n-                     xmlChar *name,\n-                     const xmlChar *value);\n+                xmlNewNsPropEatName     (xmlNodePtr node,\n+                                         xmlNsPtr ns,\n+                                         xmlChar *name,\n+                                         const xmlChar *value);\n@@ -805,1 +805,1 @@\n-        xmlFreePropList     (xmlAttrPtr cur);\n+                xmlFreePropList         (xmlAttrPtr cur);\n@@ -807,1 +807,1 @@\n-        xmlFreeProp     (xmlAttrPtr cur);\n+                xmlFreeProp             (xmlAttrPtr cur);\n@@ -809,2 +809,2 @@\n-        xmlCopyProp     (xmlNodePtr target,\n-                     xmlAttrPtr cur);\n+                xmlCopyProp             (xmlNodePtr target,\n+                                         xmlAttrPtr cur);\n@@ -812,2 +812,2 @@\n-        xmlCopyPropList     (xmlNodePtr target,\n-                     xmlAttrPtr cur);\n+                xmlCopyPropList         (xmlNodePtr target,\n+                                         xmlAttrPtr cur);\n@@ -816,1 +816,1 @@\n-        xmlCopyDtd      (xmlDtdPtr dtd);\n+                xmlCopyDtd              (xmlDtdPtr dtd);\n@@ -820,2 +820,2 @@\n-        xmlCopyDoc      (xmlDocPtr doc,\n-                     int recursive);\n+                xmlCopyDoc              (xmlDocPtr doc,\n+                                         int recursive);\n@@ -827,4 +827,4 @@\n-        xmlNewDocNode       (xmlDocPtr doc,\n-                     xmlNsPtr ns,\n-                     const xmlChar *name,\n-                     const xmlChar *content);\n+                xmlNewDocNode           (xmlDocPtr doc,\n+                                         xmlNsPtr ns,\n+                                         const xmlChar *name,\n+                                         const xmlChar *content);\n@@ -832,4 +832,4 @@\n-        xmlNewDocNodeEatName    (xmlDocPtr doc,\n-                     xmlNsPtr ns,\n-                     xmlChar *name,\n-                     const xmlChar *content);\n+                xmlNewDocNodeEatName    (xmlDocPtr doc,\n+                                         xmlNsPtr ns,\n+                                         xmlChar *name,\n+                                         const xmlChar *content);\n@@ -837,2 +837,2 @@\n-        xmlNewNode      (xmlNsPtr ns,\n-                     const xmlChar *name);\n+                xmlNewNode              (xmlNsPtr ns,\n+                                         const xmlChar *name);\n@@ -840,2 +840,2 @@\n-        xmlNewNodeEatName   (xmlNsPtr ns,\n-                     xmlChar *name);\n+                xmlNewNodeEatName       (xmlNsPtr ns,\n+                                         xmlChar *name);\n@@ -844,4 +844,4 @@\n-        xmlNewChild     (xmlNodePtr parent,\n-                     xmlNsPtr ns,\n-                     const xmlChar *name,\n-                     const xmlChar *content);\n+                xmlNewChild             (xmlNodePtr parent,\n+                                         xmlNsPtr ns,\n+                                         const xmlChar *name,\n+                                         const xmlChar *content);\n@@ -850,2 +850,2 @@\n-        xmlNewDocText       (const xmlDoc *doc,\n-                     const xmlChar *content);\n+                xmlNewDocText           (const xmlDoc *doc,\n+                                         const xmlChar *content);\n@@ -853,1 +853,1 @@\n-        xmlNewText      (const xmlChar *content);\n+                xmlNewText              (const xmlChar *content);\n@@ -855,3 +855,3 @@\n-        xmlNewDocPI     (xmlDocPtr doc,\n-                     const xmlChar *name,\n-                     const xmlChar *content);\n+                xmlNewDocPI             (xmlDocPtr doc,\n+                                         const xmlChar *name,\n+                                         const xmlChar *content);\n@@ -859,2 +859,2 @@\n-        xmlNewPI        (const xmlChar *name,\n-                     const xmlChar *content);\n+                xmlNewPI                (const xmlChar *name,\n+                                         const xmlChar *content);\n@@ -862,3 +862,3 @@\n-        xmlNewDocTextLen    (xmlDocPtr doc,\n-                     const xmlChar *content,\n-                     int len);\n+                xmlNewDocTextLen        (xmlDocPtr doc,\n+                                         const xmlChar *content,\n+                                         int len);\n@@ -866,2 +866,2 @@\n-        xmlNewTextLen       (const xmlChar *content,\n-                     int len);\n+                xmlNewTextLen           (const xmlChar *content,\n+                                         int len);\n@@ -869,2 +869,2 @@\n-        xmlNewDocComment    (xmlDocPtr doc,\n-                     const xmlChar *content);\n+                xmlNewDocComment        (xmlDocPtr doc,\n+                                         const xmlChar *content);\n@@ -872,1 +872,1 @@\n-        xmlNewComment       (const xmlChar *content);\n+                xmlNewComment           (const xmlChar *content);\n@@ -874,3 +874,3 @@\n-        xmlNewCDataBlock    (xmlDocPtr doc,\n-                     const xmlChar *content,\n-                     int len);\n+                xmlNewCDataBlock        (xmlDocPtr doc,\n+                                         const xmlChar *content,\n+                                         int len);\n@@ -878,2 +878,2 @@\n-        xmlNewCharRef       (xmlDocPtr doc,\n-                     const xmlChar *name);\n+                xmlNewCharRef           (xmlDocPtr doc,\n+                                         const xmlChar *name);\n@@ -881,2 +881,2 @@\n-        xmlNewReference     (const xmlDoc *doc,\n-                     const xmlChar *name);\n+                xmlNewReference         (const xmlDoc *doc,\n+                                         const xmlChar *name);\n@@ -884,2 +884,2 @@\n-        xmlCopyNode     (xmlNodePtr node,\n-                     int recursive);\n+                xmlCopyNode             (xmlNodePtr node,\n+                                         int recursive);\n@@ -887,3 +887,3 @@\n-        xmlDocCopyNode      (xmlNodePtr node,\n-                     xmlDocPtr doc,\n-                     int recursive);\n+                xmlDocCopyNode          (xmlNodePtr node,\n+                                         xmlDocPtr doc,\n+                                         int recursive);\n@@ -891,2 +891,2 @@\n-        xmlDocCopyNodeList  (xmlDocPtr doc,\n-                     xmlNodePtr node);\n+                xmlDocCopyNodeList      (xmlDocPtr doc,\n+                                         xmlNodePtr node);\n@@ -894,1 +894,1 @@\n-        xmlCopyNodeList     (xmlNodePtr node);\n+                xmlCopyNodeList         (xmlNodePtr node);\n@@ -897,4 +897,4 @@\n-        xmlNewTextChild     (xmlNodePtr parent,\n-                     xmlNsPtr ns,\n-                     const xmlChar *name,\n-                     const xmlChar *content);\n+                xmlNewTextChild         (xmlNodePtr parent,\n+                                         xmlNsPtr ns,\n+                                         const xmlChar *name,\n+                                         const xmlChar *content);\n@@ -902,4 +902,4 @@\n-        xmlNewDocRawNode    (xmlDocPtr doc,\n-                     xmlNsPtr ns,\n-                     const xmlChar *name,\n-                     const xmlChar *content);\n+                xmlNewDocRawNode        (xmlDocPtr doc,\n+                                         xmlNsPtr ns,\n+                                         const xmlChar *name,\n+                                         const xmlChar *content);\n@@ -907,1 +907,1 @@\n-        xmlNewDocFragment   (xmlDocPtr doc);\n+                xmlNewDocFragment       (xmlDocPtr doc);\n@@ -914,1 +914,1 @@\n-        xmlGetLineNo        (const xmlNode *node);\n+                xmlGetLineNo            (const xmlNode *node);\n@@ -917,1 +917,1 @@\n-        xmlGetNodePath      (const xmlNode *node);\n+                xmlGetNodePath          (const xmlNode *node);\n@@ -920,1 +920,1 @@\n-        xmlDocGetRootElement    (const xmlDoc *doc);\n+                xmlDocGetRootElement    (const xmlDoc *doc);\n@@ -922,1 +922,1 @@\n-        xmlGetLastChild     (const xmlNode *parent);\n+                xmlGetLastChild         (const xmlNode *parent);\n@@ -924,1 +924,1 @@\n-        xmlNodeIsText       (const xmlNode *node);\n+                xmlNodeIsText           (const xmlNode *node);\n@@ -926,1 +926,1 @@\n-        xmlIsBlankNode      (const xmlNode *node);\n+                xmlIsBlankNode          (const xmlNode *node);\n@@ -933,2 +933,2 @@\n-        xmlDocSetRootElement    (xmlDocPtr doc,\n-                     xmlNodePtr root);\n+                xmlDocSetRootElement    (xmlDocPtr doc,\n+                                         xmlNodePtr root);\n@@ -938,2 +938,2 @@\n-        xmlNodeSetName      (xmlNodePtr cur,\n-                     const xmlChar *name);\n+                xmlNodeSetName          (xmlNodePtr cur,\n+                                         const xmlChar *name);\n@@ -942,2 +942,2 @@\n-        xmlAddChild     (xmlNodePtr parent,\n-                     xmlNodePtr cur);\n+                xmlAddChild             (xmlNodePtr parent,\n+                                         xmlNodePtr cur);\n@@ -945,2 +945,2 @@\n-        xmlAddChildList     (xmlNodePtr parent,\n-                     xmlNodePtr cur);\n+                xmlAddChildList         (xmlNodePtr parent,\n+                                         xmlNodePtr cur);\n@@ -949,2 +949,2 @@\n-        xmlReplaceNode      (xmlNodePtr old,\n-                     xmlNodePtr cur);\n+                xmlReplaceNode          (xmlNodePtr old,\n+                                         xmlNodePtr cur);\n@@ -955,2 +955,2 @@\n-        xmlAddPrevSibling   (xmlNodePtr cur,\n-                     xmlNodePtr elem);\n+                xmlAddPrevSibling       (xmlNodePtr cur,\n+                                         xmlNodePtr elem);\n@@ -959,2 +959,2 @@\n-        xmlAddSibling       (xmlNodePtr cur,\n-                     xmlNodePtr elem);\n+                xmlAddSibling           (xmlNodePtr cur,\n+                                         xmlNodePtr elem);\n@@ -962,2 +962,2 @@\n-        xmlAddNextSibling   (xmlNodePtr cur,\n-                     xmlNodePtr elem);\n+                xmlAddNextSibling       (xmlNodePtr cur,\n+                                         xmlNodePtr elem);\n@@ -965,1 +965,1 @@\n-        xmlUnlinkNode       (xmlNodePtr cur);\n+                xmlUnlinkNode           (xmlNodePtr cur);\n@@ -967,2 +967,2 @@\n-        xmlTextMerge        (xmlNodePtr first,\n-                     xmlNodePtr second);\n+                xmlTextMerge            (xmlNodePtr first,\n+                                         xmlNodePtr second);\n@@ -970,3 +970,3 @@\n-        xmlTextConcat       (xmlNodePtr node,\n-                     const xmlChar *content,\n-                     int len);\n+                xmlTextConcat           (xmlNodePtr node,\n+                                         const xmlChar *content,\n+                                         int len);\n@@ -974,1 +974,1 @@\n-        xmlFreeNodeList     (xmlNodePtr cur);\n+                xmlFreeNodeList         (xmlNodePtr cur);\n@@ -976,1 +976,1 @@\n-        xmlFreeNode     (xmlNodePtr cur);\n+                xmlFreeNode             (xmlNodePtr cur);\n@@ -978,2 +978,2 @@\n-        xmlSetTreeDoc       (xmlNodePtr tree,\n-                     xmlDocPtr doc);\n+                xmlSetTreeDoc           (xmlNodePtr tree,\n+                                         xmlDocPtr doc);\n@@ -981,2 +981,2 @@\n-        xmlSetListDoc       (xmlNodePtr list,\n-                     xmlDocPtr doc);\n+                xmlSetListDoc           (xmlNodePtr list,\n+                                         xmlDocPtr doc);\n@@ -987,3 +987,3 @@\n-        xmlSearchNs     (xmlDocPtr doc,\n-                     xmlNodePtr node,\n-                     const xmlChar *nameSpace);\n+                xmlSearchNs             (xmlDocPtr doc,\n+                                         xmlNodePtr node,\n+                                         const xmlChar *nameSpace);\n@@ -991,3 +991,3 @@\n-        xmlSearchNsByHref   (xmlDocPtr doc,\n-                     xmlNodePtr node,\n-                     const xmlChar *href);\n+                xmlSearchNsByHref       (xmlDocPtr doc,\n+                                         xmlNodePtr node,\n+                                         const xmlChar *href);\n@@ -997,2 +997,2 @@\n-        xmlGetNsList        (const xmlDoc *doc,\n-                     const xmlNode *node);\n+                xmlGetNsList            (const xmlDoc *doc,\n+                                         const xmlNode *node);\n@@ -1002,2 +1002,2 @@\n-        xmlSetNs        (xmlNodePtr node,\n-                     xmlNsPtr ns);\n+                xmlSetNs                (xmlNodePtr node,\n+                                         xmlNsPtr ns);\n@@ -1005,1 +1005,1 @@\n-        xmlCopyNamespace    (xmlNsPtr cur);\n+                xmlCopyNamespace        (xmlNsPtr cur);\n@@ -1007,1 +1007,1 @@\n-        xmlCopyNamespaceList    (xmlNsPtr cur);\n+                xmlCopyNamespaceList    (xmlNsPtr cur);\n@@ -1015,3 +1015,3 @@\n-        xmlSetProp      (xmlNodePtr node,\n-                     const xmlChar *name,\n-                     const xmlChar *value);\n+                xmlSetProp              (xmlNodePtr node,\n+                                         const xmlChar *name,\n+                                         const xmlChar *value);\n@@ -1019,4 +1019,4 @@\n-        xmlSetNsProp        (xmlNodePtr node,\n-                     xmlNsPtr ns,\n-                     const xmlChar *name,\n-                     const xmlChar *value);\n+                xmlSetNsProp            (xmlNodePtr node,\n+                                         xmlNsPtr ns,\n+                                         const xmlChar *name,\n+                                         const xmlChar *value);\n@@ -1024,1 +1024,1 @@\n-      defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED) *\/\n+          defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED) *\/\n@@ -1026,2 +1026,2 @@\n-        xmlGetNoNsProp      (const xmlNode *node,\n-                     const xmlChar *name);\n+                xmlGetNoNsProp          (const xmlNode *node,\n+                                         const xmlChar *name);\n@@ -1029,2 +1029,2 @@\n-        xmlGetProp      (const xmlNode *node,\n-                     const xmlChar *name);\n+                xmlGetProp              (const xmlNode *node,\n+                                         const xmlChar *name);\n@@ -1032,2 +1032,2 @@\n-        xmlHasProp      (const xmlNode *node,\n-                     const xmlChar *name);\n+                xmlHasProp              (const xmlNode *node,\n+                                         const xmlChar *name);\n@@ -1035,3 +1035,3 @@\n-        xmlHasNsProp        (const xmlNode *node,\n-                     const xmlChar *name,\n-                     const xmlChar *nameSpace);\n+                xmlHasNsProp            (const xmlNode *node,\n+                                         const xmlChar *name,\n+                                         const xmlChar *nameSpace);\n@@ -1039,3 +1039,3 @@\n-        xmlGetNsProp        (const xmlNode *node,\n-                     const xmlChar *name,\n-                     const xmlChar *nameSpace);\n+                xmlGetNsProp            (const xmlNode *node,\n+                                         const xmlChar *name,\n+                                         const xmlChar *nameSpace);\n@@ -1043,2 +1043,2 @@\n-        xmlStringGetNodeList    (const xmlDoc *doc,\n-                     const xmlChar *value);\n+                xmlStringGetNodeList    (const xmlDoc *doc,\n+                                         const xmlChar *value);\n@@ -1046,3 +1046,3 @@\n-        xmlStringLenGetNodeList (const xmlDoc *doc,\n-                     const xmlChar *value,\n-                     int len);\n+                xmlStringLenGetNodeList (const xmlDoc *doc,\n+                                         const xmlChar *value,\n+                                         int len);\n@@ -1050,3 +1050,3 @@\n-        xmlNodeListGetString    (xmlDocPtr doc,\n-                     const xmlNode *list,\n-                     int inLine);\n+                xmlNodeListGetString    (xmlDocPtr doc,\n+                                         const xmlNode *list,\n+                                         int inLine);\n@@ -1055,3 +1055,3 @@\n-        xmlNodeListGetRawString (const xmlDoc *doc,\n-                     const xmlNode *list,\n-                     int inLine);\n+                xmlNodeListGetRawString (const xmlDoc *doc,\n+                                         const xmlNode *list,\n+                                         int inLine);\n@@ -1060,2 +1060,2 @@\n-        xmlNodeSetContent   (xmlNodePtr cur,\n-                     const xmlChar *content);\n+                xmlNodeSetContent       (xmlNodePtr cur,\n+                                         const xmlChar *content);\n@@ -1064,3 +1064,3 @@\n-        xmlNodeSetContentLen    (xmlNodePtr cur,\n-                     const xmlChar *content,\n-                     int len);\n+                xmlNodeSetContentLen    (xmlNodePtr cur,\n+                                         const xmlChar *content,\n+                                         int len);\n@@ -1069,2 +1069,2 @@\n-        xmlNodeAddContent   (xmlNodePtr cur,\n-                     const xmlChar *content);\n+                xmlNodeAddContent       (xmlNodePtr cur,\n+                                         const xmlChar *content);\n@@ -1072,3 +1072,3 @@\n-        xmlNodeAddContentLen    (xmlNodePtr cur,\n-                     const xmlChar *content,\n-                     int len);\n+                xmlNodeAddContentLen    (xmlNodePtr cur,\n+                                         const xmlChar *content,\n+                                         int len);\n@@ -1076,1 +1076,1 @@\n-        xmlNodeGetContent   (const xmlNode *cur);\n+                xmlNodeGetContent       (const xmlNode *cur);\n@@ -1079,2 +1079,2 @@\n-        xmlNodeBufGetContent    (xmlBufferPtr buffer,\n-                     const xmlNode *cur);\n+                xmlNodeBufGetContent    (xmlBufferPtr buffer,\n+                                         const xmlNode *cur);\n@@ -1082,2 +1082,2 @@\n-        xmlBufGetNodeContent    (xmlBufPtr buf,\n-                     const xmlNode *cur);\n+                xmlBufGetNodeContent    (xmlBufPtr buf,\n+                                         const xmlNode *cur);\n@@ -1086,1 +1086,1 @@\n-        xmlNodeGetLang      (const xmlNode *cur);\n+                xmlNodeGetLang          (const xmlNode *cur);\n@@ -1088,1 +1088,1 @@\n-        xmlNodeGetSpacePreserve (const xmlNode *cur);\n+                xmlNodeGetSpacePreserve (const xmlNode *cur);\n@@ -1091,2 +1091,2 @@\n-        xmlNodeSetLang      (xmlNodePtr cur,\n-                     const xmlChar *lang);\n+                xmlNodeSetLang          (xmlNodePtr cur,\n+                                         const xmlChar *lang);\n@@ -1094,2 +1094,2 @@\n-        xmlNodeSetSpacePreserve (xmlNodePtr cur,\n-                     int val);\n+                xmlNodeSetSpacePreserve (xmlNodePtr cur,\n+                                         int val);\n@@ -1098,2 +1098,2 @@\n-        xmlNodeGetBase      (const xmlDoc *doc,\n-                     const xmlNode *cur);\n+                xmlNodeGetBase          (const xmlDoc *doc,\n+                                         const xmlNode *cur);\n@@ -1102,2 +1102,2 @@\n-        xmlNodeSetBase      (xmlNodePtr cur,\n-                     const xmlChar *uri);\n+                xmlNodeSetBase          (xmlNodePtr cur,\n+                                         const xmlChar *uri);\n@@ -1110,1 +1110,1 @@\n-        xmlRemoveProp       (xmlAttrPtr cur);\n+                xmlRemoveProp           (xmlAttrPtr cur);\n@@ -1113,3 +1113,3 @@\n-        xmlUnsetNsProp      (xmlNodePtr node,\n-                     xmlNsPtr ns,\n-                     const xmlChar *name);\n+                xmlUnsetNsProp          (xmlNodePtr node,\n+                                         xmlNsPtr ns,\n+                                         const xmlChar *name);\n@@ -1117,2 +1117,2 @@\n-        xmlUnsetProp        (xmlNodePtr node,\n-                     const xmlChar *name);\n+                xmlUnsetProp            (xmlNodePtr node,\n+                                         const xmlChar *name);\n@@ -1125,2 +1125,2 @@\n-        xmlBufferWriteCHAR  (xmlBufferPtr buf,\n-                     const xmlChar *string);\n+                xmlBufferWriteCHAR      (xmlBufferPtr buf,\n+                                         const xmlChar *string);\n@@ -1128,2 +1128,2 @@\n-        xmlBufferWriteChar  (xmlBufferPtr buf,\n-                     const char *string);\n+                xmlBufferWriteChar      (xmlBufferPtr buf,\n+                                         const char *string);\n@@ -1131,2 +1131,2 @@\n-        xmlBufferWriteQuotedString(xmlBufferPtr buf,\n-                     const xmlChar *string);\n+                xmlBufferWriteQuotedString(xmlBufferPtr buf,\n+                                         const xmlChar *string);\n@@ -1136,3 +1136,3 @@\n-                     xmlDocPtr doc,\n-                     xmlAttrPtr attr,\n-                     const xmlChar *string);\n+                                         xmlDocPtr doc,\n+                                         xmlAttrPtr attr,\n+                                         const xmlChar *string);\n@@ -1146,2 +1146,2 @@\n-        xmlReconciliateNs   (xmlDocPtr doc,\n-                     xmlNodePtr tree);\n+                xmlReconciliateNs       (xmlDocPtr doc,\n+                                         xmlNodePtr tree);\n@@ -1155,4 +1155,4 @@\n-        xmlDocDumpFormatMemory  (xmlDocPtr cur,\n-                     xmlChar **mem,\n-                     int *size,\n-                     int format);\n+                xmlDocDumpFormatMemory  (xmlDocPtr cur,\n+                                         xmlChar **mem,\n+                                         int *size,\n+                                         int format);\n@@ -1160,3 +1160,3 @@\n-        xmlDocDumpMemory    (xmlDocPtr cur,\n-                     xmlChar **mem,\n-                     int *size);\n+                xmlDocDumpMemory        (xmlDocPtr cur,\n+                                         xmlChar **mem,\n+                                         int *size);\n@@ -1164,4 +1164,4 @@\n-        xmlDocDumpMemoryEnc (xmlDocPtr out_doc,\n-                     xmlChar **doc_txt_ptr,\n-                     int * doc_txt_len,\n-                     const char *txt_encoding);\n+                xmlDocDumpMemoryEnc     (xmlDocPtr out_doc,\n+                                         xmlChar **doc_txt_ptr,\n+                                         int * doc_txt_len,\n+                                         const char *txt_encoding);\n@@ -1169,5 +1169,5 @@\n-        xmlDocDumpFormatMemoryEnc(xmlDocPtr out_doc,\n-                     xmlChar **doc_txt_ptr,\n-                     int * doc_txt_len,\n-                     const char *txt_encoding,\n-                     int format);\n+                xmlDocDumpFormatMemoryEnc(xmlDocPtr out_doc,\n+                                         xmlChar **doc_txt_ptr,\n+                                         int * doc_txt_len,\n+                                         const char *txt_encoding,\n+                                         int format);\n@@ -1175,3 +1175,3 @@\n-        xmlDocFormatDump    (FILE *f,\n-                     xmlDocPtr cur,\n-                     int format);\n+                xmlDocFormatDump        (FILE *f,\n+                                         xmlDocPtr cur,\n+                                         int format);\n@@ -1179,2 +1179,2 @@\n-        xmlDocDump      (FILE *f,\n-                     xmlDocPtr cur);\n+                xmlDocDump              (FILE *f,\n+                                         xmlDocPtr cur);\n@@ -1182,3 +1182,3 @@\n-        xmlElemDump     (FILE *f,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur);\n+                xmlElemDump             (FILE *f,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur);\n@@ -1186,2 +1186,2 @@\n-        xmlSaveFile     (const char *filename,\n-                     xmlDocPtr cur);\n+                xmlSaveFile             (const char *filename,\n+                                         xmlDocPtr cur);\n@@ -1189,3 +1189,3 @@\n-        xmlSaveFormatFile   (const char *filename,\n-                     xmlDocPtr cur,\n-                     int format);\n+                xmlSaveFormatFile       (const char *filename,\n+                                         xmlDocPtr cur,\n+                                         int format);\n@@ -1193,5 +1193,5 @@\n-        xmlBufNodeDump      (xmlBufPtr buf,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur,\n-                     int level,\n-                     int format);\n+                xmlBufNodeDump          (xmlBufPtr buf,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur,\n+                                         int level,\n+                                         int format);\n@@ -1199,5 +1199,5 @@\n-        xmlNodeDump     (xmlBufferPtr buf,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur,\n-                     int level,\n-                     int format);\n+                xmlNodeDump             (xmlBufferPtr buf,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur,\n+                                         int level,\n+                                         int format);\n@@ -1206,3 +1206,3 @@\n-        xmlSaveFileTo       (xmlOutputBufferPtr buf,\n-                     xmlDocPtr cur,\n-                     const char *encoding);\n+                xmlSaveFileTo           (xmlOutputBufferPtr buf,\n+                                         xmlDocPtr cur,\n+                                         const char *encoding);\n@@ -1210,4 +1210,4 @@\n-        xmlSaveFormatFileTo     (xmlOutputBufferPtr buf,\n-                     xmlDocPtr cur,\n-                         const char *encoding,\n-                         int format);\n+                xmlSaveFormatFileTo     (xmlOutputBufferPtr buf,\n+                                         xmlDocPtr cur,\n+                                         const char *encoding,\n+                                         int format);\n@@ -1215,6 +1215,6 @@\n-        xmlNodeDumpOutput   (xmlOutputBufferPtr buf,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur,\n-                     int level,\n-                     int format,\n-                     const char *encoding);\n+                xmlNodeDumpOutput       (xmlOutputBufferPtr buf,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur,\n+                                         int level,\n+                                         int format,\n+                                         const char *encoding);\n@@ -1223,4 +1223,4 @@\n-        xmlSaveFormatFileEnc    (const char *filename,\n-                     xmlDocPtr cur,\n-                     const char *encoding,\n-                     int format);\n+                xmlSaveFormatFileEnc    (const char *filename,\n+                                         xmlDocPtr cur,\n+                                         const char *encoding,\n+                                         int format);\n@@ -1229,3 +1229,3 @@\n-        xmlSaveFileEnc      (const char *filename,\n-                     xmlDocPtr cur,\n-                     const char *encoding);\n+                xmlSaveFileEnc          (const char *filename,\n+                                         xmlDocPtr cur,\n+                                         const char *encoding);\n@@ -1238,2 +1238,2 @@\n-        xmlIsXHTML      (const xmlChar *systemID,\n-                     const xmlChar *publicID);\n+                xmlIsXHTML              (const xmlChar *systemID,\n+                                         const xmlChar *publicID);\n@@ -1245,1 +1245,1 @@\n-        xmlGetDocCompressMode   (const xmlDoc *doc);\n+                xmlGetDocCompressMode   (const xmlDoc *doc);\n@@ -1247,2 +1247,2 @@\n-        xmlSetDocCompressMode   (xmlDocPtr doc,\n-                     int mode);\n+                xmlSetDocCompressMode   (xmlDocPtr doc,\n+                                         int mode);\n@@ -1250,1 +1250,1 @@\n-        xmlGetCompressMode  (void);\n+                xmlGetCompressMode      (void);\n@@ -1252,1 +1252,1 @@\n-        xmlSetCompressMode  (int mode);\n+                xmlSetCompressMode      (int mode);\n@@ -1258,1 +1258,1 @@\n-        xmlDOMWrapNewCtxt   (void);\n+                xmlDOMWrapNewCtxt       (void);\n@@ -1260,1 +1260,1 @@\n-        xmlDOMWrapFreeCtxt  (xmlDOMWrapCtxtPtr ctxt);\n+                xmlDOMWrapFreeCtxt      (xmlDOMWrapCtxtPtr ctxt);\n@@ -1262,3 +1262,3 @@\n-        xmlDOMWrapReconcileNamespaces(xmlDOMWrapCtxtPtr ctxt,\n-                     xmlNodePtr elem,\n-                     int options);\n+            xmlDOMWrapReconcileNamespaces(xmlDOMWrapCtxtPtr ctxt,\n+                                         xmlNodePtr elem,\n+                                         int options);\n@@ -1266,6 +1266,6 @@\n-        xmlDOMWrapAdoptNode     (xmlDOMWrapCtxtPtr ctxt,\n-                     xmlDocPtr sourceDoc,\n-                     xmlNodePtr node,\n-                     xmlDocPtr destDoc,\n-                     xmlNodePtr destParent,\n-                     int options);\n+            xmlDOMWrapAdoptNode         (xmlDOMWrapCtxtPtr ctxt,\n+                                         xmlDocPtr sourceDoc,\n+                                         xmlNodePtr node,\n+                                         xmlDocPtr destDoc,\n+                                         xmlNodePtr destParent,\n+                                         int options);\n@@ -1273,4 +1273,4 @@\n-        xmlDOMWrapRemoveNode    (xmlDOMWrapCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr node,\n-                     int options);\n+            xmlDOMWrapRemoveNode        (xmlDOMWrapCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr node,\n+                                         int options);\n@@ -1278,8 +1278,8 @@\n-        xmlDOMWrapCloneNode     (xmlDOMWrapCtxtPtr ctxt,\n-                     xmlDocPtr sourceDoc,\n-                     xmlNodePtr node,\n-                     xmlNodePtr *clonedNode,\n-                     xmlDocPtr destDoc,\n-                     xmlNodePtr destParent,\n-                     int deep,\n-                     int options);\n+            xmlDOMWrapCloneNode         (xmlDOMWrapCtxtPtr ctxt,\n+                                         xmlDocPtr sourceDoc,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr *clonedNode,\n+                                         xmlDocPtr destDoc,\n+                                         xmlNodePtr destParent,\n+                                         int deep,\n+                                         int options);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/tree.h","additions":470,"deletions":470,"binary":false,"changes":940,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-    char *scheme;   \/* the URI scheme *\/\n-    char *opaque;   \/* opaque part *\/\n+    char *scheme;       \/* the URI scheme *\/\n+    char *opaque;       \/* opaque part *\/\n@@ -37,7 +37,7 @@\n-    char *server;   \/* the server part *\/\n-    char *user;     \/* the user part *\/\n-    int port;       \/* the port number *\/\n-    char *path;     \/* the path string *\/\n-    char *query;    \/* the query string (deprecated - use with caution) *\/\n-    char *fragment; \/* the fragment identifier *\/\n-    int  cleanup;   \/* parsing potentially unclean URI *\/\n+    char *server;       \/* the server part *\/\n+    char *user;         \/* the user part *\/\n+    int port;           \/* the port number *\/\n+    char *path;         \/* the path string *\/\n+    char *query;        \/* the query string (deprecated - use with caution) *\/\n+    char *fragment;     \/* the fragment identifier *\/\n+    int  cleanup;       \/* parsing potentially unclean URI *\/\n@@ -53,1 +53,1 @@\n-        xmlCreateURI        (void);\n+                xmlCreateURI            (void);\n@@ -55,2 +55,2 @@\n-        xmlBuildURI     (const xmlChar *URI,\n-                     const xmlChar *base);\n+                xmlBuildURI             (const xmlChar *URI,\n+                                         const xmlChar *base);\n@@ -58,2 +58,2 @@\n-        xmlBuildRelativeURI (const xmlChar *URI,\n-                     const xmlChar *base);\n+                xmlBuildRelativeURI     (const xmlChar *URI,\n+                                         const xmlChar *base);\n@@ -61,1 +61,1 @@\n-        xmlParseURI     (const char *str);\n+                xmlParseURI             (const char *str);\n@@ -63,2 +63,2 @@\n-        xmlParseURIRaw      (const char *str,\n-                     int raw);\n+                xmlParseURIRaw          (const char *str,\n+                                         int raw);\n@@ -66,2 +66,2 @@\n-        xmlParseURIReference    (xmlURIPtr uri,\n-                     const char *str);\n+                xmlParseURIReference    (xmlURIPtr uri,\n+                                         const char *str);\n@@ -69,1 +69,1 @@\n-        xmlSaveUri      (xmlURIPtr uri);\n+                xmlSaveUri              (xmlURIPtr uri);\n@@ -71,2 +71,2 @@\n-        xmlPrintURI     (FILE *stream,\n-                     xmlURIPtr uri);\n+                xmlPrintURI             (FILE *stream,\n+                                         xmlURIPtr uri);\n@@ -74,2 +74,2 @@\n-        xmlURIEscapeStr         (const xmlChar *str,\n-                     const xmlChar *list);\n+                xmlURIEscapeStr         (const xmlChar *str,\n+                                         const xmlChar *list);\n@@ -77,3 +77,3 @@\n-        xmlURIUnescapeString    (const char *str,\n-                     int len,\n-                     char *target);\n+                xmlURIUnescapeString    (const char *str,\n+                                         int len,\n+                                         char *target);\n@@ -81,1 +81,1 @@\n-        xmlNormalizeURIPath (char *path);\n+                xmlNormalizeURIPath     (char *path);\n@@ -83,1 +83,1 @@\n-        xmlURIEscape        (const xmlChar *str);\n+                xmlURIEscape            (const xmlChar *str);\n@@ -85,1 +85,1 @@\n-        xmlFreeURI      (xmlURIPtr uri);\n+                xmlFreeURI              (xmlURIPtr uri);\n@@ -87,1 +87,1 @@\n-        xmlCanonicPath      (const xmlChar *path);\n+                xmlCanonicPath          (const xmlChar *path);\n@@ -89,1 +89,1 @@\n-        xmlPathToURI        (const xmlChar *path);\n+                xmlPathToURI            (const xmlChar *path);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/uri.h","additions":32,"deletions":32,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -43,2 +43,2 @@\n-                 const char *msg,\n-                 ...) LIBXML_ATTR_FORMAT(2,3);\n+                             const char *msg,\n+                             ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -58,2 +58,2 @@\n-                   const char *msg,\n-                   ...) LIBXML_ATTR_FORMAT(2,3);\n+                               const char *msg,\n+                               ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -83,3 +83,3 @@\n-    void *userData;         \/* user specific data block *\/\n-    xmlValidityErrorFunc error;     \/* the callback in case of errors *\/\n-    xmlValidityWarningFunc warning; \/* the callback in case of warning *\/\n+    void *userData;                     \/* user specific data block *\/\n+    xmlValidityErrorFunc error;         \/* the callback in case of errors *\/\n+    xmlValidityWarningFunc warning;     \/* the callback in case of warning *\/\n@@ -154,5 +154,5 @@\n-        xmlAddNotationDecl  (xmlValidCtxtPtr ctxt,\n-                     xmlDtdPtr dtd,\n-                     const xmlChar *name,\n-                     const xmlChar *PublicID,\n-                     const xmlChar *SystemID);\n+                xmlAddNotationDecl      (xmlValidCtxtPtr ctxt,\n+                                         xmlDtdPtr dtd,\n+                                         const xmlChar *name,\n+                                         const xmlChar *PublicID,\n+                                         const xmlChar *SystemID);\n@@ -161,1 +161,1 @@\n-        xmlCopyNotationTable    (xmlNotationTablePtr table);\n+                xmlCopyNotationTable    (xmlNotationTablePtr table);\n@@ -164,1 +164,1 @@\n-        xmlFreeNotationTable    (xmlNotationTablePtr table);\n+                xmlFreeNotationTable    (xmlNotationTablePtr table);\n@@ -167,2 +167,2 @@\n-        xmlDumpNotationDecl (xmlBufferPtr buf,\n-                     xmlNotationPtr nota);\n+                xmlDumpNotationDecl     (xmlBufferPtr buf,\n+                                         xmlNotationPtr nota);\n@@ -170,2 +170,2 @@\n-        xmlDumpNotationTable    (xmlBufferPtr buf,\n-                     xmlNotationTablePtr table);\n+                xmlDumpNotationTable    (xmlBufferPtr buf,\n+                                         xmlNotationTablePtr table);\n@@ -177,2 +177,2 @@\n-        xmlNewElementContent    (const xmlChar *name,\n-                     xmlElementContentType type);\n+                xmlNewElementContent    (const xmlChar *name,\n+                                         xmlElementContentType type);\n@@ -180,1 +180,1 @@\n-        xmlCopyElementContent   (xmlElementContentPtr content);\n+                xmlCopyElementContent   (xmlElementContentPtr content);\n@@ -182,1 +182,1 @@\n-        xmlFreeElementContent   (xmlElementContentPtr cur);\n+                xmlFreeElementContent   (xmlElementContentPtr cur);\n@@ -185,3 +185,3 @@\n-        xmlNewDocElementContent (xmlDocPtr doc,\n-                     const xmlChar *name,\n-                     xmlElementContentType type);\n+                xmlNewDocElementContent (xmlDocPtr doc,\n+                                         const xmlChar *name,\n+                                         xmlElementContentType type);\n@@ -189,2 +189,2 @@\n-        xmlCopyDocElementContent(xmlDocPtr doc,\n-                     xmlElementContentPtr content);\n+                xmlCopyDocElementContent(xmlDocPtr doc,\n+                                         xmlElementContentPtr content);\n@@ -192,2 +192,2 @@\n-        xmlFreeDocElementContent(xmlDocPtr doc,\n-                     xmlElementContentPtr cur);\n+                xmlFreeDocElementContent(xmlDocPtr doc,\n+                                         xmlElementContentPtr cur);\n@@ -195,4 +195,4 @@\n-        xmlSnprintfElementContent(char *buf,\n-                     int size,\n-                                     xmlElementContentPtr content,\n-                     int englob);\n+                xmlSnprintfElementContent(char *buf,\n+                                         int size,\n+                                         xmlElementContentPtr content,\n+                                         int englob);\n@@ -202,3 +202,3 @@\n-        xmlSprintfElementContent(char *buf,\n-                                     xmlElementContentPtr content,\n-                     int englob);\n+                xmlSprintfElementContent(char *buf,\n+                                         xmlElementContentPtr content,\n+                                         int englob);\n@@ -210,5 +210,5 @@\n-        xmlAddElementDecl   (xmlValidCtxtPtr ctxt,\n-                     xmlDtdPtr dtd,\n-                     const xmlChar *name,\n-                     xmlElementTypeVal type,\n-                     xmlElementContentPtr content);\n+                xmlAddElementDecl       (xmlValidCtxtPtr ctxt,\n+                                         xmlDtdPtr dtd,\n+                                         const xmlChar *name,\n+                                         xmlElementTypeVal type,\n+                                         xmlElementContentPtr content);\n@@ -217,1 +217,1 @@\n-        xmlCopyElementTable (xmlElementTablePtr table);\n+                xmlCopyElementTable     (xmlElementTablePtr table);\n@@ -220,1 +220,1 @@\n-        xmlFreeElementTable (xmlElementTablePtr table);\n+                xmlFreeElementTable     (xmlElementTablePtr table);\n@@ -223,2 +223,2 @@\n-        xmlDumpElementTable (xmlBufferPtr buf,\n-                     xmlElementTablePtr table);\n+                xmlDumpElementTable     (xmlBufferPtr buf,\n+                                         xmlElementTablePtr table);\n@@ -226,2 +226,2 @@\n-        xmlDumpElementDecl  (xmlBufferPtr buf,\n-                     xmlElementPtr elem);\n+                xmlDumpElementDecl      (xmlBufferPtr buf,\n+                                         xmlElementPtr elem);\n@@ -232,1 +232,1 @@\n-        xmlCreateEnumeration    (const xmlChar *name);\n+                xmlCreateEnumeration    (const xmlChar *name);\n@@ -234,1 +234,1 @@\n-        xmlFreeEnumeration  (xmlEnumerationPtr cur);\n+                xmlFreeEnumeration      (xmlEnumerationPtr cur);\n@@ -237,1 +237,1 @@\n-        xmlCopyEnumeration  (xmlEnumerationPtr cur);\n+                xmlCopyEnumeration      (xmlEnumerationPtr cur);\n@@ -242,9 +242,9 @@\n-        xmlAddAttributeDecl (xmlValidCtxtPtr ctxt,\n-                     xmlDtdPtr dtd,\n-                     const xmlChar *elem,\n-                     const xmlChar *name,\n-                     const xmlChar *ns,\n-                     xmlAttributeType type,\n-                     xmlAttributeDefault def,\n-                     const xmlChar *defaultValue,\n-                     xmlEnumerationPtr tree);\n+                xmlAddAttributeDecl     (xmlValidCtxtPtr ctxt,\n+                                         xmlDtdPtr dtd,\n+                                         const xmlChar *elem,\n+                                         const xmlChar *name,\n+                                         const xmlChar *ns,\n+                                         xmlAttributeType type,\n+                                         xmlAttributeDefault def,\n+                                         const xmlChar *defaultValue,\n+                                         xmlEnumerationPtr tree);\n@@ -253,1 +253,1 @@\n-        xmlCopyAttributeTable  (xmlAttributeTablePtr table);\n+                xmlCopyAttributeTable  (xmlAttributeTablePtr table);\n@@ -256,1 +256,1 @@\n-        xmlFreeAttributeTable  (xmlAttributeTablePtr table);\n+                xmlFreeAttributeTable  (xmlAttributeTablePtr table);\n@@ -259,2 +259,2 @@\n-        xmlDumpAttributeTable  (xmlBufferPtr buf,\n-                    xmlAttributeTablePtr table);\n+                xmlDumpAttributeTable  (xmlBufferPtr buf,\n+                                        xmlAttributeTablePtr table);\n@@ -262,2 +262,2 @@\n-        xmlDumpAttributeDecl   (xmlBufferPtr buf,\n-                    xmlAttributePtr attr);\n+                xmlDumpAttributeDecl   (xmlBufferPtr buf,\n+                                        xmlAttributePtr attr);\n@@ -268,4 +268,4 @@\n-        xmlAddID           (xmlValidCtxtPtr ctxt,\n-                    xmlDocPtr doc,\n-                    const xmlChar *value,\n-                    xmlAttrPtr attr);\n+                xmlAddID               (xmlValidCtxtPtr ctxt,\n+                                        xmlDocPtr doc,\n+                                        const xmlChar *value,\n+                                        xmlAttrPtr attr);\n@@ -273,1 +273,1 @@\n-        xmlFreeIDTable         (xmlIDTablePtr table);\n+                xmlFreeIDTable         (xmlIDTablePtr table);\n@@ -275,2 +275,2 @@\n-        xmlGetID           (xmlDocPtr doc,\n-                    const xmlChar *ID);\n+                xmlGetID               (xmlDocPtr doc,\n+                                        const xmlChar *ID);\n@@ -278,3 +278,3 @@\n-        xmlIsID            (xmlDocPtr doc,\n-                    xmlNodePtr elem,\n-                    xmlAttrPtr attr);\n+                xmlIsID                (xmlDocPtr doc,\n+                                        xmlNodePtr elem,\n+                                        xmlAttrPtr attr);\n@@ -282,2 +282,2 @@\n-        xmlRemoveID        (xmlDocPtr doc,\n-                    xmlAttrPtr attr);\n+                xmlRemoveID            (xmlDocPtr doc,\n+                                        xmlAttrPtr attr);\n@@ -287,4 +287,4 @@\n-        xmlAddRef          (xmlValidCtxtPtr ctxt,\n-                    xmlDocPtr doc,\n-                    const xmlChar *value,\n-                    xmlAttrPtr attr);\n+                xmlAddRef              (xmlValidCtxtPtr ctxt,\n+                                        xmlDocPtr doc,\n+                                        const xmlChar *value,\n+                                        xmlAttrPtr attr);\n@@ -292,1 +292,1 @@\n-        xmlFreeRefTable        (xmlRefTablePtr table);\n+                xmlFreeRefTable        (xmlRefTablePtr table);\n@@ -294,3 +294,3 @@\n-        xmlIsRef           (xmlDocPtr doc,\n-                    xmlNodePtr elem,\n-                    xmlAttrPtr attr);\n+                xmlIsRef               (xmlDocPtr doc,\n+                                        xmlNodePtr elem,\n+                                        xmlAttrPtr attr);\n@@ -298,2 +298,2 @@\n-        xmlRemoveRef           (xmlDocPtr doc,\n-                    xmlAttrPtr attr);\n+                xmlRemoveRef           (xmlDocPtr doc,\n+                                        xmlAttrPtr attr);\n@@ -301,2 +301,2 @@\n-        xmlGetRefs         (xmlDocPtr doc,\n-                    const xmlChar *ID);\n+                xmlGetRefs             (xmlDocPtr doc,\n+                                        const xmlChar *ID);\n@@ -310,1 +310,1 @@\n-        xmlNewValidCtxt(void);\n+                xmlNewValidCtxt(void);\n@@ -312,1 +312,1 @@\n-        xmlFreeValidCtxt(xmlValidCtxtPtr);\n+                xmlFreeValidCtxt(xmlValidCtxtPtr);\n@@ -315,2 +315,2 @@\n-        xmlValidateRoot     (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc);\n+                xmlValidateRoot         (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc);\n@@ -318,3 +318,3 @@\n-        xmlValidateElementDecl  (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                                 xmlElementPtr elem);\n+                xmlValidateElementDecl  (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlElementPtr elem);\n@@ -322,4 +322,4 @@\n-        xmlValidNormalizeAttributeValue(xmlDocPtr doc,\n-                     xmlNodePtr elem,\n-                     const xmlChar *name,\n-                     const xmlChar *value);\n+                xmlValidNormalizeAttributeValue(xmlDocPtr doc,\n+                                         xmlNodePtr elem,\n+                                         const xmlChar *name,\n+                                         const xmlChar *value);\n@@ -327,5 +327,5 @@\n-        xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr elem,\n-                     const xmlChar *name,\n-                     const xmlChar *value);\n+                xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem,\n+                                         const xmlChar *name,\n+                                         const xmlChar *value);\n@@ -333,3 +333,3 @@\n-        xmlValidateAttributeDecl(xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                                 xmlAttributePtr attr);\n+                xmlValidateAttributeDecl(xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlAttributePtr attr);\n@@ -337,2 +337,2 @@\n-        xmlValidateAttributeValue(xmlAttributeType type,\n-                     const xmlChar *value);\n+                xmlValidateAttributeValue(xmlAttributeType type,\n+                                         const xmlChar *value);\n@@ -340,3 +340,3 @@\n-        xmlValidateNotationDecl (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                                 xmlNotationPtr nota);\n+                xmlValidateNotationDecl (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNotationPtr nota);\n@@ -344,3 +344,3 @@\n-        xmlValidateDtd      (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlDtdPtr dtd);\n+                xmlValidateDtd          (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlDtdPtr dtd);\n@@ -348,2 +348,2 @@\n-        xmlValidateDtdFinal (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc);\n+                xmlValidateDtdFinal     (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc);\n@@ -351,2 +351,2 @@\n-        xmlValidateDocument (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc);\n+                xmlValidateDocument     (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc);\n@@ -354,3 +354,3 @@\n-        xmlValidateElement  (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr elem);\n+                xmlValidateElement      (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem);\n@@ -358,3 +358,3 @@\n-        xmlValidateOneElement   (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                                 xmlNodePtr elem);\n+                xmlValidateOneElement   (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem);\n@@ -362,5 +362,5 @@\n-        xmlValidateOneAttribute (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr elem,\n-                     xmlAttrPtr attr,\n-                     const xmlChar *value);\n+                xmlValidateOneAttribute (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr     elem,\n+                                         xmlAttrPtr attr,\n+                                         const xmlChar *value);\n@@ -368,6 +368,6 @@\n-        xmlValidateOneNamespace (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr elem,\n-                     const xmlChar *prefix,\n-                     xmlNsPtr ns,\n-                     const xmlChar *value);\n+                xmlValidateOneNamespace (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem,\n+                                         const xmlChar *prefix,\n+                                         xmlNsPtr ns,\n+                                         const xmlChar *value);\n@@ -375,2 +375,2 @@\n-        xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc);\n+                xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc);\n@@ -381,3 +381,3 @@\n-        xmlValidateNotationUse  (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     const xmlChar *notationName);\n+                xmlValidateNotationUse  (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         const xmlChar *notationName);\n@@ -387,2 +387,2 @@\n-        xmlIsMixedElement   (xmlDocPtr doc,\n-                     const xmlChar *name);\n+                xmlIsMixedElement       (xmlDocPtr doc,\n+                                         const xmlChar *name);\n@@ -390,3 +390,3 @@\n-        xmlGetDtdAttrDesc   (xmlDtdPtr dtd,\n-                     const xmlChar *elem,\n-                     const xmlChar *name);\n+                xmlGetDtdAttrDesc       (xmlDtdPtr dtd,\n+                                         const xmlChar *elem,\n+                                         const xmlChar *name);\n@@ -394,4 +394,4 @@\n-        xmlGetDtdQAttrDesc  (xmlDtdPtr dtd,\n-                     const xmlChar *elem,\n-                     const xmlChar *name,\n-                     const xmlChar *prefix);\n+                xmlGetDtdQAttrDesc      (xmlDtdPtr dtd,\n+                                         const xmlChar *elem,\n+                                         const xmlChar *name,\n+                                         const xmlChar *prefix);\n@@ -399,2 +399,2 @@\n-        xmlGetDtdNotationDesc   (xmlDtdPtr dtd,\n-                     const xmlChar *name);\n+                xmlGetDtdNotationDesc   (xmlDtdPtr dtd,\n+                                         const xmlChar *name);\n@@ -402,3 +402,3 @@\n-        xmlGetDtdQElementDesc   (xmlDtdPtr dtd,\n-                     const xmlChar *name,\n-                     const xmlChar *prefix);\n+                xmlGetDtdQElementDesc   (xmlDtdPtr dtd,\n+                                         const xmlChar *name,\n+                                         const xmlChar *prefix);\n@@ -406,2 +406,2 @@\n-        xmlGetDtdElementDesc    (xmlDtdPtr dtd,\n-                     const xmlChar *name);\n+                xmlGetDtdElementDesc    (xmlDtdPtr dtd,\n+                                         const xmlChar *name);\n@@ -412,4 +412,4 @@\n-        xmlValidGetPotentialChildren(xmlElementContent *ctree,\n-                     const xmlChar **names,\n-                     int *len,\n-                     int max);\n+                xmlValidGetPotentialChildren(xmlElementContent *ctree,\n+                                         const xmlChar **names,\n+                                         int *len,\n+                                         int max);\n@@ -418,4 +418,4 @@\n-        xmlValidGetValidElements(xmlNode *prev,\n-                     xmlNode *next,\n-                     const xmlChar **names,\n-                     int max);\n+                xmlValidGetValidElements(xmlNode *prev,\n+                                         xmlNode *next,\n+                                         const xmlChar **names,\n+                                         int max);\n@@ -423,1 +423,1 @@\n-        xmlValidateNameValue    (const xmlChar *value);\n+                xmlValidateNameValue    (const xmlChar *value);\n@@ -425,1 +425,1 @@\n-        xmlValidateNamesValue   (const xmlChar *value);\n+                xmlValidateNamesValue   (const xmlChar *value);\n@@ -427,1 +427,1 @@\n-        xmlValidateNmtokenValue (const xmlChar *value);\n+                xmlValidateNmtokenValue (const xmlChar *value);\n@@ -429,1 +429,1 @@\n-        xmlValidateNmtokensValue(const xmlChar *value);\n+                xmlValidateNmtokensValue(const xmlChar *value);\n@@ -436,2 +436,2 @@\n-        xmlValidBuildContentModel(xmlValidCtxtPtr ctxt,\n-                     xmlElementPtr elem);\n+                xmlValidBuildContentModel(xmlValidCtxtPtr ctxt,\n+                                         xmlElementPtr elem);\n@@ -440,4 +440,4 @@\n-        xmlValidatePushElement  (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr elem,\n-                     const xmlChar *qname);\n+                xmlValidatePushElement  (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem,\n+                                         const xmlChar *qname);\n@@ -445,3 +445,3 @@\n-        xmlValidatePushCData    (xmlValidCtxtPtr ctxt,\n-                     const xmlChar *data,\n-                     int len);\n+                xmlValidatePushCData    (xmlValidCtxtPtr ctxt,\n+                                         const xmlChar *data,\n+                                         int len);\n@@ -449,4 +449,4 @@\n-        xmlValidatePopElement   (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr elem,\n-                     const xmlChar *qname);\n+                xmlValidatePopElement   (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem,\n+                                         const xmlChar *qname);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/valid.h","additions":183,"deletions":183,"binary":false,"changes":366,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-        xmlXIncludeProcess  (xmlDocPtr doc);\n+                xmlXIncludeProcess      (xmlDocPtr doc);\n@@ -95,2 +95,2 @@\n-        xmlXIncludeProcessFlags (xmlDocPtr doc,\n-                     int flags);\n+                xmlXIncludeProcessFlags (xmlDocPtr doc,\n+                                         int flags);\n@@ -98,3 +98,3 @@\n-        xmlXIncludeProcessFlagsData(xmlDocPtr doc,\n-                     int flags,\n-                     void *data);\n+                xmlXIncludeProcessFlagsData(xmlDocPtr doc,\n+                                         int flags,\n+                                         void *data);\n@@ -106,1 +106,1 @@\n-        xmlXIncludeProcessTree  (xmlNodePtr tree);\n+                xmlXIncludeProcessTree  (xmlNodePtr tree);\n@@ -108,2 +108,2 @@\n-        xmlXIncludeProcessTreeFlags(xmlNodePtr tree,\n-                     int flags);\n+                xmlXIncludeProcessTreeFlags(xmlNodePtr tree,\n+                                         int flags);\n@@ -114,1 +114,1 @@\n-        xmlXIncludeNewContext   (xmlDocPtr doc);\n+                xmlXIncludeNewContext   (xmlDocPtr doc);\n@@ -116,2 +116,2 @@\n-        xmlXIncludeSetFlags (xmlXIncludeCtxtPtr ctxt,\n-                     int flags);\n+                xmlXIncludeSetFlags     (xmlXIncludeCtxtPtr ctxt,\n+                                         int flags);\n@@ -119,1 +119,1 @@\n-        xmlXIncludeFreeContext  (xmlXIncludeCtxtPtr ctxt);\n+                xmlXIncludeFreeContext  (xmlXIncludeCtxtPtr ctxt);\n@@ -121,2 +121,2 @@\n-        xmlXIncludeProcessNode  (xmlXIncludeCtxtPtr ctxt,\n-                     xmlNodePtr tree);\n+                xmlXIncludeProcessNode  (xmlXIncludeCtxtPtr ctxt,\n+                                         xmlNodePtr tree);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xinclude.h","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -83,4 +83,4 @@\n-             xmlNodePtr node,\n-             const xlinkHRef href,\n-             const xlinkRole role,\n-             const xlinkTitle title);\n+                         xmlNodePtr node,\n+                         const xlinkHRef href,\n+                         const xlinkRole role,\n+                         const xlinkTitle title);\n@@ -108,12 +108,12 @@\n-             xmlNodePtr node,\n-             int nbLocators,\n-             const xlinkHRef *hrefs,\n-             const xlinkRole *roles,\n-             int nbArcs,\n-             const xlinkRole *from,\n-             const xlinkRole *to,\n-             xlinkShow *show,\n-             xlinkActuate *actuate,\n-             int nbTitles,\n-             const xlinkTitle *titles,\n-             const xmlChar **langs);\n+                         xmlNodePtr node,\n+                         int nbLocators,\n+                         const xlinkHRef *hrefs,\n+                         const xlinkRole *roles,\n+                         int nbArcs,\n+                         const xlinkRole *from,\n+                         const xlinkRole *to,\n+                         xlinkShow *show,\n+                         xlinkActuate *actuate,\n+                         int nbTitles,\n+                         const xlinkTitle *titles,\n+                         const xmlChar **langs);\n@@ -135,8 +135,8 @@\n-(*xlinkExtendedLinkSetFunk) (void *ctx,\n-                 xmlNodePtr node,\n-                 int nbLocators,\n-                 const xlinkHRef *hrefs,\n-                 const xlinkRole *roles,\n-                 int nbTitles,\n-                 const xlinkTitle *titles,\n-                 const xmlChar **langs);\n+(*xlinkExtendedLinkSetFunk)     (void *ctx,\n+                                 xmlNodePtr node,\n+                                 int nbLocators,\n+                                 const xlinkHRef *hrefs,\n+                                 const xlinkRole *roles,\n+                                 int nbTitles,\n+                                 const xlinkTitle *titles,\n+                                 const xmlChar **langs);\n@@ -164,1 +164,1 @@\n-        xlinkGetDefaultDetect   (void);\n+                xlinkGetDefaultDetect   (void);\n@@ -166,1 +166,1 @@\n-        xlinkSetDefaultDetect   (xlinkNodeDetectFunc func);\n+                xlinkSetDefaultDetect   (xlinkNodeDetectFunc func);\n@@ -172,1 +172,1 @@\n-        xlinkGetDefaultHandler  (void);\n+                xlinkGetDefaultHandler  (void);\n@@ -174,1 +174,1 @@\n-        xlinkSetDefaultHandler  (xlinkHandlerPtr handler);\n+                xlinkSetDefaultHandler  (xlinkHandlerPtr handler);\n@@ -180,2 +180,2 @@\n-        xlinkIsLink     (xmlDocPtr doc,\n-                     xmlNodePtr node);\n+                xlinkIsLink             (xmlDocPtr doc,\n+                                         xmlNodePtr node);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xlink.h","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-    int compressed;     \/* -1=unknown, 0=not compressed, 1=compressed *\/\n+    int compressed;         \/* -1=unknown, 0=not compressed, 1=compressed *\/\n@@ -159,1 +159,1 @@\n-    xmlCleanupInputCallbacks        (void);\n+        xmlCleanupInputCallbacks                (void);\n@@ -162,1 +162,1 @@\n-    xmlPopInputCallbacks            (void);\n+        xmlPopInputCallbacks                    (void);\n@@ -165,1 +165,1 @@\n-    xmlRegisterDefaultInputCallbacks    (void);\n+        xmlRegisterDefaultInputCallbacks        (void);\n@@ -167,1 +167,1 @@\n-    xmlAllocParserInputBuffer       (xmlCharEncoding enc);\n+        xmlAllocParserInputBuffer               (xmlCharEncoding enc);\n@@ -170,1 +170,1 @@\n-    xmlParserInputBufferCreateFilename  (const char *URI,\n+        xmlParserInputBufferCreateFilename      (const char *URI,\n@@ -173,1 +173,1 @@\n-    xmlParserInputBufferCreateFile      (FILE *file,\n+        xmlParserInputBufferCreateFile          (FILE *file,\n@@ -176,2 +176,2 @@\n-    xmlParserInputBufferCreateFd        (int fd,\n-                                             xmlCharEncoding enc);\n+        xmlParserInputBufferCreateFd            (int fd,\n+                                                 xmlCharEncoding enc);\n@@ -179,2 +179,2 @@\n-    xmlParserInputBufferCreateMem       (const char *mem, int size,\n-                                             xmlCharEncoding enc);\n+        xmlParserInputBufferCreateMem           (const char *mem, int size,\n+                                                 xmlCharEncoding enc);\n@@ -182,2 +182,2 @@\n-    xmlParserInputBufferCreateStatic    (const char *mem, int size,\n-                                             xmlCharEncoding enc);\n+        xmlParserInputBufferCreateStatic        (const char *mem, int size,\n+                                                 xmlCharEncoding enc);\n@@ -185,4 +185,4 @@\n-    xmlParserInputBufferCreateIO        (xmlInputReadCallback   ioread,\n-                         xmlInputCloseCallback  ioclose,\n-                         void *ioctx,\n-                                             xmlCharEncoding enc);\n+        xmlParserInputBufferCreateIO            (xmlInputReadCallback   ioread,\n+                                                 xmlInputCloseCallback  ioclose,\n+                                                 void *ioctx,\n+                                                 xmlCharEncoding enc);\n@@ -190,2 +190,2 @@\n-    xmlParserInputBufferRead        (xmlParserInputBufferPtr in,\n-                         int len);\n+        xmlParserInputBufferRead                (xmlParserInputBufferPtr in,\n+                                                 int len);\n@@ -193,2 +193,2 @@\n-    xmlParserInputBufferGrow        (xmlParserInputBufferPtr in,\n-                         int len);\n+        xmlParserInputBufferGrow                (xmlParserInputBufferPtr in,\n+                                                 int len);\n@@ -196,3 +196,3 @@\n-    xmlParserInputBufferPush        (xmlParserInputBufferPtr in,\n-                         int len,\n-                         const char *buf);\n+        xmlParserInputBufferPush                (xmlParserInputBufferPtr in,\n+                                                 int len,\n+                                                 const char *buf);\n@@ -200,1 +200,1 @@\n-    xmlFreeParserInputBuffer        (xmlParserInputBufferPtr in);\n+        xmlFreeParserInputBuffer                (xmlParserInputBufferPtr in);\n@@ -202,1 +202,1 @@\n-    xmlParserGetDirectory           (const char *filename);\n+        xmlParserGetDirectory                   (const char *filename);\n@@ -205,4 +205,4 @@\n-    xmlRegisterInputCallbacks       (xmlInputMatchCallback matchFunc,\n-                         xmlInputOpenCallback openFunc,\n-                         xmlInputReadCallback readFunc,\n-                         xmlInputCloseCallback closeFunc);\n+        xmlRegisterInputCallbacks               (xmlInputMatchCallback matchFunc,\n+                                                 xmlInputOpenCallback openFunc,\n+                                                 xmlInputReadCallback readFunc,\n+                                                 xmlInputCloseCallback closeFunc);\n@@ -211,2 +211,2 @@\n-    __xmlParserInputBufferCreateFilename(const char *URI,\n-                        xmlCharEncoding enc);\n+        __xmlParserInputBufferCreateFilename(const char *URI,\n+                                                xmlCharEncoding enc);\n@@ -219,1 +219,1 @@\n-    xmlCleanupOutputCallbacks       (void);\n+        xmlCleanupOutputCallbacks               (void);\n@@ -221,1 +221,1 @@\n-    xmlPopOutputCallbacks           (void);\n+        xmlPopOutputCallbacks                   (void);\n@@ -223,1 +223,1 @@\n-    xmlRegisterDefaultOutputCallbacks(void);\n+        xmlRegisterDefaultOutputCallbacks(void);\n@@ -225,1 +225,1 @@\n-    xmlAllocOutputBuffer        (xmlCharEncodingHandlerPtr encoder);\n+        xmlAllocOutputBuffer            (xmlCharEncodingHandlerPtr encoder);\n@@ -228,3 +228,3 @@\n-    xmlOutputBufferCreateFilename   (const char *URI,\n-                     xmlCharEncodingHandlerPtr encoder,\n-                     int compression);\n+        xmlOutputBufferCreateFilename   (const char *URI,\n+                                         xmlCharEncodingHandlerPtr encoder,\n+                                         int compression);\n@@ -233,2 +233,2 @@\n-    xmlOutputBufferCreateFile   (FILE *file,\n-                     xmlCharEncodingHandlerPtr encoder);\n+        xmlOutputBufferCreateFile       (FILE *file,\n+                                         xmlCharEncodingHandlerPtr encoder);\n@@ -237,2 +237,2 @@\n-    xmlOutputBufferCreateBuffer (xmlBufferPtr buffer,\n-                     xmlCharEncodingHandlerPtr encoder);\n+        xmlOutputBufferCreateBuffer     (xmlBufferPtr buffer,\n+                                         xmlCharEncodingHandlerPtr encoder);\n@@ -241,2 +241,2 @@\n-    xmlOutputBufferCreateFd     (int fd,\n-                     xmlCharEncodingHandlerPtr encoder);\n+        xmlOutputBufferCreateFd         (int fd,\n+                                         xmlCharEncodingHandlerPtr encoder);\n@@ -245,4 +245,4 @@\n-    xmlOutputBufferCreateIO     (xmlOutputWriteCallback   iowrite,\n-                     xmlOutputCloseCallback  ioclose,\n-                     void *ioctx,\n-                     xmlCharEncodingHandlerPtr encoder);\n+        xmlOutputBufferCreateIO         (xmlOutputWriteCallback   iowrite,\n+                                         xmlOutputCloseCallback  ioclose,\n+                                         void *ioctx,\n+                                         xmlCharEncodingHandlerPtr encoder);\n@@ -257,3 +257,3 @@\n-    xmlOutputBufferWrite        (xmlOutputBufferPtr out,\n-                     int len,\n-                     const char *buf);\n+        xmlOutputBufferWrite            (xmlOutputBufferPtr out,\n+                                         int len,\n+                                         const char *buf);\n@@ -261,2 +261,2 @@\n-    xmlOutputBufferWriteString  (xmlOutputBufferPtr out,\n-                     const char *str);\n+        xmlOutputBufferWriteString      (xmlOutputBufferPtr out,\n+                                         const char *str);\n@@ -264,3 +264,3 @@\n-    xmlOutputBufferWriteEscape  (xmlOutputBufferPtr out,\n-                     const xmlChar *str,\n-                     xmlCharEncodingOutputFunc escaping);\n+        xmlOutputBufferWriteEscape      (xmlOutputBufferPtr out,\n+                                         const xmlChar *str,\n+                                         xmlCharEncodingOutputFunc escaping);\n@@ -269,1 +269,1 @@\n-    xmlOutputBufferFlush        (xmlOutputBufferPtr out);\n+        xmlOutputBufferFlush            (xmlOutputBufferPtr out);\n@@ -271,1 +271,1 @@\n-    xmlOutputBufferClose        (xmlOutputBufferPtr out);\n+        xmlOutputBufferClose            (xmlOutputBufferPtr out);\n@@ -274,4 +274,4 @@\n-    xmlRegisterOutputCallbacks  (xmlOutputMatchCallback matchFunc,\n-                     xmlOutputOpenCallback openFunc,\n-                     xmlOutputWriteCallback writeFunc,\n-                     xmlOutputCloseCallback closeFunc);\n+        xmlRegisterOutputCallbacks      (xmlOutputMatchCallback matchFunc,\n+                                         xmlOutputOpenCallback openFunc,\n+                                         xmlOutputWriteCallback writeFunc,\n+                                         xmlOutputCloseCallback closeFunc);\n@@ -280,1 +280,1 @@\n-    __xmlOutputBufferCreateFilename(const char *URI,\n+        __xmlOutputBufferCreateFilename(const char *URI,\n@@ -287,1 +287,1 @@\n-    xmlRegisterHTTPPostCallbacks    (void );\n+        xmlRegisterHTTPPostCallbacks    (void );\n@@ -293,2 +293,2 @@\n-    xmlCheckHTTPInput       (xmlParserCtxtPtr ctxt,\n-                     xmlParserInputPtr ret);\n+        xmlCheckHTTPInput               (xmlParserCtxtPtr ctxt,\n+                                         xmlParserInputPtr ret);\n@@ -300,3 +300,3 @@\n-    xmlNoNetExternalEntityLoader    (const char *URL,\n-                     const char *ID,\n-                     xmlParserCtxtPtr ctxt);\n+        xmlNoNetExternalEntityLoader    (const char *URL,\n+                                         const char *ID,\n+                                         xmlParserCtxtPtr ctxt);\n@@ -309,1 +309,1 @@\n-    xmlNormalizeWindowsPath     (const xmlChar *path);\n+        xmlNormalizeWindowsPath         (const xmlChar *path);\n@@ -312,1 +312,1 @@\n-    xmlCheckFilename        (const char *path);\n+        xmlCheckFilename                (const char *path);\n@@ -317,1 +317,1 @@\n-    xmlFileMatch            (const char *filename);\n+        xmlFileMatch                    (const char *filename);\n@@ -319,1 +319,1 @@\n-    xmlFileOpen         (const char *filename);\n+        xmlFileOpen                     (const char *filename);\n@@ -321,3 +321,3 @@\n-    xmlFileRead         (void * context,\n-                     char * buffer,\n-                     int len);\n+        xmlFileRead                     (void * context,\n+                                         char * buffer,\n+                                         int len);\n@@ -325,1 +325,1 @@\n-    xmlFileClose            (void * context);\n+        xmlFileClose                    (void * context);\n@@ -332,1 +332,1 @@\n-    xmlIOHTTPMatch          (const char *filename);\n+        xmlIOHTTPMatch                  (const char *filename);\n@@ -334,1 +334,1 @@\n-    xmlIOHTTPOpen           (const char *filename);\n+        xmlIOHTTPOpen                   (const char *filename);\n@@ -337,2 +337,2 @@\n-    xmlIOHTTPOpenW          (const char * post_uri,\n-                     int   compression );\n+        xmlIOHTTPOpenW                  (const char * post_uri,\n+                                         int   compression );\n@@ -341,3 +341,3 @@\n-    xmlIOHTTPRead           (void * context,\n-                     char * buffer,\n-                     int len);\n+        xmlIOHTTPRead                   (void * context,\n+                                         char * buffer,\n+                                         int len);\n@@ -345,1 +345,1 @@\n-    xmlIOHTTPClose          (void * context);\n+        xmlIOHTTPClose                  (void * context);\n@@ -353,1 +353,1 @@\n-    xmlIOFTPMatch           (const char *filename);\n+        xmlIOFTPMatch                   (const char *filename);\n@@ -355,1 +355,1 @@\n-    xmlIOFTPOpen            (const char *filename);\n+        xmlIOFTPOpen                    (const char *filename);\n@@ -357,3 +357,3 @@\n-    xmlIOFTPRead            (void * context,\n-                     char * buffer,\n-                     int len);\n+        xmlIOFTPRead                    (void * context,\n+                                         char * buffer,\n+                                         int len);\n@@ -361,1 +361,1 @@\n-    xmlIOFTPClose           (void * context);\n+        xmlIOFTPClose                   (void * context);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlIO.h","additions":92,"deletions":92,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-            xmlNewAutomata      (void);\n+                    xmlNewAutomata              (void);\n@@ -46,1 +46,1 @@\n-            xmlFreeAutomata     (xmlAutomataPtr am);\n+                    xmlFreeAutomata             (xmlAutomataPtr am);\n@@ -49,1 +49,1 @@\n-            xmlAutomataGetInitState (xmlAutomataPtr am);\n+                    xmlAutomataGetInitState     (xmlAutomataPtr am);\n@@ -51,2 +51,2 @@\n-            xmlAutomataSetFinalState    (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr state);\n+                    xmlAutomataSetFinalState    (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr state);\n@@ -54,1 +54,1 @@\n-            xmlAutomataNewState     (xmlAutomataPtr am);\n+                    xmlAutomataNewState         (xmlAutomataPtr am);\n@@ -56,5 +56,5 @@\n-            xmlAutomataNewTransition    (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         const xmlChar *token,\n-                         void *data);\n+                    xmlAutomataNewTransition    (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 const xmlChar *token,\n+                                                 void *data);\n@@ -62,6 +62,6 @@\n-            xmlAutomataNewTransition2   (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         const xmlChar *token,\n-                         const xmlChar *token2,\n-                         void *data);\n+                    xmlAutomataNewTransition2   (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 const xmlChar *token,\n+                                                 const xmlChar *token2,\n+                                                 void *data);\n@@ -69,6 +69,6 @@\n-                    xmlAutomataNewNegTrans  (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         const xmlChar *token,\n-                         const xmlChar *token2,\n-                         void *data);\n+                    xmlAutomataNewNegTrans      (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 const xmlChar *token,\n+                                                 const xmlChar *token2,\n+                                                 void *data);\n@@ -77,7 +77,7 @@\n-            xmlAutomataNewCountTrans    (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         const xmlChar *token,\n-                         int min,\n-                         int max,\n-                         void *data);\n+                    xmlAutomataNewCountTrans    (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 const xmlChar *token,\n+                                                 int min,\n+                                                 int max,\n+                                                 void *data);\n@@ -85,8 +85,8 @@\n-            xmlAutomataNewCountTrans2   (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         const xmlChar *token,\n-                         const xmlChar *token2,\n-                         int min,\n-                         int max,\n-                         void *data);\n+                    xmlAutomataNewCountTrans2   (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 const xmlChar *token,\n+                                                 const xmlChar *token2,\n+                                                 int min,\n+                                                 int max,\n+                                                 void *data);\n@@ -94,7 +94,7 @@\n-            xmlAutomataNewOnceTrans (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         const xmlChar *token,\n-                         int min,\n-                         int max,\n-                         void *data);\n+                    xmlAutomataNewOnceTrans     (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 const xmlChar *token,\n+                                                 int min,\n+                                                 int max,\n+                                                 void *data);\n@@ -102,8 +102,8 @@\n-            xmlAutomataNewOnceTrans2    (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         const xmlChar *token,\n-                         const xmlChar *token2,\n-                         int min,\n-                         int max,\n-                         void *data);\n+                    xmlAutomataNewOnceTrans2    (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 const xmlChar *token,\n+                                                 const xmlChar *token2,\n+                                                 int min,\n+                                                 int max,\n+                                                 void *data);\n@@ -111,4 +111,4 @@\n-            xmlAutomataNewAllTrans  (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         int lax);\n+                    xmlAutomataNewAllTrans      (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 int lax);\n@@ -116,3 +116,3 @@\n-            xmlAutomataNewEpsilon   (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to);\n+                    xmlAutomataNewEpsilon       (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to);\n@@ -120,4 +120,4 @@\n-            xmlAutomataNewCountedTrans  (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         int counter);\n+                    xmlAutomataNewCountedTrans  (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 int counter);\n@@ -125,4 +125,4 @@\n-            xmlAutomataNewCounterTrans  (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         int counter);\n+                    xmlAutomataNewCounterTrans  (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 int counter);\n@@ -130,3 +130,3 @@\n-            xmlAutomataNewCounter   (xmlAutomataPtr am,\n-                         int min,\n-                         int max);\n+                    xmlAutomataNewCounter       (xmlAutomataPtr am,\n+                                                 int min,\n+                                                 int max);\n@@ -135,1 +135,1 @@\n-            xmlAutomataCompile      (xmlAutomataPtr am);\n+                    xmlAutomataCompile          (xmlAutomataPtr am);\n@@ -137,1 +137,1 @@\n-            xmlAutomataIsDeterminist    (xmlAutomataPtr am);\n+                    xmlAutomataIsDeterminist    (xmlAutomataPtr am);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlautomata.h","additions":73,"deletions":73,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -26,3 +26,3 @@\n-    XML_ERR_WARNING = 1,    \/* A simple warning *\/\n-    XML_ERR_ERROR = 2,      \/* A recoverable error *\/\n-    XML_ERR_FATAL = 3       \/* A fatal error *\/\n+    XML_ERR_WARNING = 1,        \/* A simple warning *\/\n+    XML_ERR_ERROR = 2,          \/* A recoverable error *\/\n+    XML_ERR_FATAL = 3           \/* A fatal error *\/\n@@ -39,1 +39,1 @@\n-    XML_FROM_TREE,  \/* The tree module *\/\n+    XML_FROM_TREE,      \/* The tree module *\/\n@@ -41,2 +41,2 @@\n-    XML_FROM_DTD,   \/* The XML DTD validation with parser context*\/\n-    XML_FROM_HTML,  \/* The HTML parser *\/\n+    XML_FROM_DTD,       \/* The XML DTD validation with parser context*\/\n+    XML_FROM_HTML,      \/* The HTML parser *\/\n@@ -45,3 +45,3 @@\n-    XML_FROM_IO,    \/* The Input\/Output stack *\/\n-    XML_FROM_FTP,   \/* The FTP module *\/\n-    XML_FROM_HTTP,  \/* The HTTP module *\/\n+    XML_FROM_IO,        \/* The Input\/Output stack *\/\n+    XML_FROM_FTP,       \/* The FTP module *\/\n+    XML_FROM_HTTP,      \/* The HTTP module *\/\n@@ -49,1 +49,1 @@\n-    XML_FROM_XPATH, \/* The XPath module *\/\n+    XML_FROM_XPATH,     \/* The XPath module *\/\n@@ -58,4 +58,4 @@\n-    XML_FROM_C14N,  \/* The Canonicalization module *\/\n-    XML_FROM_XSLT,  \/* The XSLT engine from libxslt *\/\n-    XML_FROM_VALID, \/* The XML DTD validation with valid context *\/\n-    XML_FROM_CHECK, \/* The error checking module *\/\n+    XML_FROM_C14N,      \/* The Canonicalization module *\/\n+    XML_FROM_XSLT,      \/* The XSLT engine from libxslt *\/\n+    XML_FROM_VALID,     \/* The XML DTD validation with valid context *\/\n+    XML_FROM_CHECK,     \/* The error checking module *\/\n@@ -64,1 +64,1 @@\n-    XML_FROM_I18N,  \/* The module handling character conversion *\/\n+    XML_FROM_I18N,      \/* The module handling character conversion *\/\n@@ -79,2 +79,2 @@\n-    int     domain; \/* What part of the library raised this error *\/\n-    int     code;   \/* The error code, e.g. an xmlParserError *\/\n+    int         domain; \/* What part of the library raised this error *\/\n+    int         code;   \/* The error code, e.g. an xmlParserError *\/\n@@ -84,1 +84,1 @@\n-    int     line;   \/* the line number if available *\/\n+    int         line;   \/* the line number if available *\/\n@@ -88,2 +88,2 @@\n-    int     int1;   \/* extra number information *\/\n-    int     int2;   \/* error column # or 0 if N\/A (todo: rename field when we would brk ABI) *\/\n+    int         int1;   \/* extra number information *\/\n+    int         int2;   \/* error column # or 0 if N\/A (todo: rename field when we would brk ABI) *\/\n@@ -846,2 +846,2 @@\n-                 const char *msg,\n-                 ...) LIBXML_ATTR_FORMAT(2,3);\n+                                 const char *msg,\n+                                 ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -863,2 +863,2 @@\n-    xmlSetGenericErrorFunc  (void *ctx,\n-                 xmlGenericErrorFunc handler);\n+    xmlSetGenericErrorFunc      (void *ctx,\n+                                 xmlGenericErrorFunc handler);\n@@ -870,1 +870,1 @@\n-                 xmlStructuredErrorFunc handler);\n+                                 xmlStructuredErrorFunc handler);\n@@ -876,3 +876,3 @@\n-    xmlParserError      (void *ctx,\n-                 const char *msg,\n-                 ...) LIBXML_ATTR_FORMAT(2,3);\n+    xmlParserError              (void *ctx,\n+                                 const char *msg,\n+                                 ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -880,3 +880,3 @@\n-    xmlParserWarning        (void *ctx,\n-                 const char *msg,\n-                 ...) LIBXML_ATTR_FORMAT(2,3);\n+    xmlParserWarning            (void *ctx,\n+                                 const char *msg,\n+                                 ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -884,3 +884,3 @@\n-    xmlParserValidityError  (void *ctx,\n-                 const char *msg,\n-                 ...) LIBXML_ATTR_FORMAT(2,3);\n+    xmlParserValidityError      (void *ctx,\n+                                 const char *msg,\n+                                 ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -889,2 +889,2 @@\n-                 const char *msg,\n-                 ...) LIBXML_ATTR_FORMAT(2,3);\n+                                 const char *msg,\n+                                 ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -892,1 +892,1 @@\n-    xmlParserPrintFileInfo  (xmlParserInputPtr input);\n+    xmlParserPrintFileInfo      (xmlParserInputPtr input);\n@@ -900,1 +900,1 @@\n-    xmlGetLastError     (void);\n+    xmlGetLastError             (void);\n@@ -902,1 +902,1 @@\n-    xmlResetLastError       (void);\n+    xmlResetLastError           (void);\n@@ -904,1 +904,1 @@\n-    xmlCtxtGetLastError     (void *ctx);\n+    xmlCtxtGetLastError         (void *ctx);\n@@ -906,1 +906,1 @@\n-    xmlCtxtResetLastError   (void *ctx);\n+    xmlCtxtResetLastError       (void *ctx);\n@@ -908,1 +908,1 @@\n-    xmlResetError       (xmlErrorPtr err);\n+    xmlResetError               (xmlErrorPtr err);\n@@ -910,2 +910,2 @@\n-    xmlCopyError        (xmlErrorPtr from,\n-                 xmlErrorPtr to);\n+    xmlCopyError                (xmlErrorPtr from,\n+                                 xmlErrorPtr to);\n@@ -918,3 +918,3 @@\n-    __xmlRaiseError     (xmlStructuredErrorFunc schannel,\n-                 xmlGenericErrorFunc channel,\n-                 void *data,\n+    __xmlRaiseError             (xmlStructuredErrorFunc schannel,\n+                                 xmlGenericErrorFunc channel,\n+                                 void *data,\n@@ -922,13 +922,13 @@\n-                 void *node,\n-                 int domain,\n-                 int code,\n-                 xmlErrorLevel level,\n-                 const char *file,\n-                 int line,\n-                 const char *str1,\n-                 const char *str2,\n-                 const char *str3,\n-                 int int1,\n-                 int col,\n-                 const char *msg,\n-                 ...) LIBXML_ATTR_FORMAT(16,17);\n+                                 void *node,\n+                                 int domain,\n+                                 int code,\n+                                 xmlErrorLevel level,\n+                                 const char *file,\n+                                 int line,\n+                                 const char *str1,\n+                                 const char *str2,\n+                                 const char *str3,\n+                                 int int1,\n+                                 int col,\n+                                 const char *msg,\n+                                 ...) LIBXML_ATTR_FORMAT(16,17);\n@@ -936,5 +936,5 @@\n-    __xmlSimpleError        (int domain,\n-                 int code,\n-                 xmlNodePtr node,\n-                 const char *msg,\n-                 const char *extra) LIBXML_ATTR_FORMAT(4,0);\n+    __xmlSimpleError            (int domain,\n+                                 int code,\n+                                 xmlNodePtr node,\n+                                 const char *msg,\n+                                 const char *extra) LIBXML_ATTR_FORMAT(4,0);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlerror.h","additions":65,"deletions":65,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -104,4 +104,4 @@\n-    xmlMemSetup (xmlFreeFunc freeFunc,\n-             xmlMallocFunc mallocFunc,\n-             xmlReallocFunc reallocFunc,\n-             xmlStrdupFunc strdupFunc);\n+        xmlMemSetup     (xmlFreeFunc freeFunc,\n+                         xmlMallocFunc mallocFunc,\n+                         xmlReallocFunc reallocFunc,\n+                         xmlStrdupFunc strdupFunc);\n@@ -109,4 +109,4 @@\n-    xmlMemGet   (xmlFreeFunc *freeFunc,\n-             xmlMallocFunc *mallocFunc,\n-             xmlReallocFunc *reallocFunc,\n-             xmlStrdupFunc *strdupFunc);\n+        xmlMemGet       (xmlFreeFunc *freeFunc,\n+                         xmlMallocFunc *mallocFunc,\n+                         xmlReallocFunc *reallocFunc,\n+                         xmlStrdupFunc *strdupFunc);\n@@ -114,5 +114,5 @@\n-    xmlGcMemSetup   (xmlFreeFunc freeFunc,\n-             xmlMallocFunc mallocFunc,\n-             xmlMallocFunc mallocAtomicFunc,\n-             xmlReallocFunc reallocFunc,\n-             xmlStrdupFunc strdupFunc);\n+        xmlGcMemSetup   (xmlFreeFunc freeFunc,\n+                         xmlMallocFunc mallocFunc,\n+                         xmlMallocFunc mallocAtomicFunc,\n+                         xmlReallocFunc reallocFunc,\n+                         xmlStrdupFunc strdupFunc);\n@@ -120,5 +120,5 @@\n-    xmlGcMemGet (xmlFreeFunc *freeFunc,\n-             xmlMallocFunc *mallocFunc,\n-             xmlMallocFunc *mallocAtomicFunc,\n-             xmlReallocFunc *reallocFunc,\n-             xmlStrdupFunc *strdupFunc);\n+        xmlGcMemGet     (xmlFreeFunc *freeFunc,\n+                         xmlMallocFunc *mallocFunc,\n+                         xmlMallocFunc *mallocAtomicFunc,\n+                         xmlReallocFunc *reallocFunc,\n+                         xmlStrdupFunc *strdupFunc);\n@@ -130,1 +130,1 @@\n-    xmlInitMemory   (void);\n+        xmlInitMemory   (void);\n@@ -141,1 +141,1 @@\n-    xmlMemUsed  (void);\n+        xmlMemUsed      (void);\n@@ -143,1 +143,1 @@\n-    xmlMemBlocks    (void);\n+        xmlMemBlocks    (void);\n@@ -145,1 +145,1 @@\n-    xmlMemDisplay   (FILE *fp);\n+        xmlMemDisplay   (FILE *fp);\n@@ -147,1 +147,1 @@\n-    xmlMemDisplayLast(FILE *fp, long nbBytes);\n+        xmlMemDisplayLast(FILE *fp, long nbBytes);\n@@ -149,1 +149,1 @@\n-    xmlMemShow  (FILE *fp, int nr);\n+        xmlMemShow      (FILE *fp, int nr);\n@@ -151,1 +151,1 @@\n-    xmlMemoryDump   (void);\n+        xmlMemoryDump   (void);\n@@ -153,1 +153,1 @@\n-    xmlMemMalloc    (size_t size) LIBXML_ATTR_ALLOC_SIZE(1);\n+        xmlMemMalloc    (size_t size) LIBXML_ATTR_ALLOC_SIZE(1);\n@@ -155,1 +155,1 @@\n-    xmlMemRealloc   (void *ptr,size_t size);\n+        xmlMemRealloc   (void *ptr,size_t size);\n@@ -157,1 +157,1 @@\n-    xmlMemFree  (void *ptr);\n+        xmlMemFree      (void *ptr);\n@@ -159,1 +159,1 @@\n-    xmlMemoryStrdup (const char *str);\n+        xmlMemoryStrdup (const char *str);\n@@ -161,1 +161,1 @@\n-    xmlMallocLoc    (size_t size, const char *file, int line) LIBXML_ATTR_ALLOC_SIZE(1);\n+        xmlMallocLoc    (size_t size, const char *file, int line) LIBXML_ATTR_ALLOC_SIZE(1);\n@@ -163,1 +163,1 @@\n-    xmlReallocLoc   (void *ptr, size_t size, const char *file, int line);\n+        xmlReallocLoc   (void *ptr, size_t size, const char *file, int line);\n@@ -165,1 +165,1 @@\n-    xmlMallocAtomicLoc (size_t size, const char *file, int line) LIBXML_ATTR_ALLOC_SIZE(1);\n+        xmlMallocAtomicLoc (size_t size, const char *file, int line) LIBXML_ATTR_ALLOC_SIZE(1);\n@@ -167,1 +167,1 @@\n-    xmlMemStrdupLoc (const char *str, const char *file, int line);\n+        xmlMemStrdupLoc (const char *str, const char *file, int line);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlmemory.h","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n-    XML_MODULE_LAZY = 1,    \/* lazy binding *\/\n-    XML_MODULE_LOCAL= 2     \/* local binding *\/\n+    XML_MODULE_LAZY = 1,        \/* lazy binding *\/\n+    XML_MODULE_LOCAL= 2         \/* local binding *\/\n@@ -41,1 +41,1 @@\n-                         int options);\n+                                                 int options);\n@@ -43,3 +43,3 @@\n-XMLPUBFUN int XMLCALL xmlModuleSymbol       (xmlModulePtr module,\n-                         const char* name,\n-                         void **result);\n+XMLPUBFUN int XMLCALL xmlModuleSymbol           (xmlModulePtr module,\n+                                                 const char* name,\n+                                                 void **result);\n@@ -47,1 +47,1 @@\n-XMLPUBFUN int XMLCALL xmlModuleClose        (xmlModulePtr module);\n+XMLPUBFUN int XMLCALL xmlModuleClose            (xmlModulePtr module);\n@@ -49,1 +49,1 @@\n-XMLPUBFUN int XMLCALL xmlModuleFree     (xmlModulePtr module);\n+XMLPUBFUN int XMLCALL xmlModuleFree             (xmlModulePtr module);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlmodule.h","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -112,2 +112,2 @@\n-            xmlNewTextReader    (xmlParserInputBufferPtr input,\n-                                             const char *URI);\n+                        xmlNewTextReader        (xmlParserInputBufferPtr input,\n+                                                 const char *URI);\n@@ -115,1 +115,1 @@\n-            xmlNewTextReaderFilename(const char *URI);\n+                        xmlNewTextReaderFilename(const char *URI);\n@@ -118,1 +118,1 @@\n-            xmlFreeTextReader   (xmlTextReaderPtr reader);\n+                        xmlFreeTextReader       (xmlTextReaderPtr reader);\n@@ -129,1 +129,1 @@\n-            xmlTextReaderRead   (xmlTextReaderPtr reader);\n+                        xmlTextReaderRead       (xmlTextReaderPtr reader);\n@@ -133,1 +133,1 @@\n-            xmlTextReaderReadInnerXml(xmlTextReaderPtr reader);\n+                        xmlTextReaderReadInnerXml(xmlTextReaderPtr reader);\n@@ -136,1 +136,1 @@\n-            xmlTextReaderReadOuterXml(xmlTextReaderPtr reader);\n+                        xmlTextReaderReadOuterXml(xmlTextReaderPtr reader);\n@@ -140,1 +140,1 @@\n-            xmlTextReaderReadString (xmlTextReaderPtr reader);\n+                        xmlTextReaderReadString (xmlTextReaderPtr reader);\n@@ -142,1 +142,1 @@\n-            xmlTextReaderReadAttributeValue(xmlTextReaderPtr reader);\n+                        xmlTextReaderReadAttributeValue(xmlTextReaderPtr reader);\n@@ -148,1 +148,1 @@\n-            xmlTextReaderAttributeCount(xmlTextReaderPtr reader);\n+                        xmlTextReaderAttributeCount(xmlTextReaderPtr reader);\n@@ -150,1 +150,1 @@\n-            xmlTextReaderDepth  (xmlTextReaderPtr reader);\n+                        xmlTextReaderDepth      (xmlTextReaderPtr reader);\n@@ -152,1 +152,1 @@\n-            xmlTextReaderHasAttributes(xmlTextReaderPtr reader);\n+                        xmlTextReaderHasAttributes(xmlTextReaderPtr reader);\n@@ -154,1 +154,1 @@\n-            xmlTextReaderHasValue(xmlTextReaderPtr reader);\n+                        xmlTextReaderHasValue(xmlTextReaderPtr reader);\n@@ -156,1 +156,1 @@\n-            xmlTextReaderIsDefault  (xmlTextReaderPtr reader);\n+                        xmlTextReaderIsDefault  (xmlTextReaderPtr reader);\n@@ -158,1 +158,1 @@\n-            xmlTextReaderIsEmptyElement(xmlTextReaderPtr reader);\n+                        xmlTextReaderIsEmptyElement(xmlTextReaderPtr reader);\n@@ -160,1 +160,1 @@\n-            xmlTextReaderNodeType   (xmlTextReaderPtr reader);\n+                        xmlTextReaderNodeType   (xmlTextReaderPtr reader);\n@@ -162,1 +162,1 @@\n-            xmlTextReaderQuoteChar  (xmlTextReaderPtr reader);\n+                        xmlTextReaderQuoteChar  (xmlTextReaderPtr reader);\n@@ -164,1 +164,1 @@\n-            xmlTextReaderReadState  (xmlTextReaderPtr reader);\n+                        xmlTextReaderReadState  (xmlTextReaderPtr reader);\n@@ -169,1 +169,1 @@\n-            xmlTextReaderConstBaseUri   (xmlTextReaderPtr reader);\n+                    xmlTextReaderConstBaseUri   (xmlTextReaderPtr reader);\n@@ -171,1 +171,1 @@\n-            xmlTextReaderConstLocalName (xmlTextReaderPtr reader);\n+                    xmlTextReaderConstLocalName (xmlTextReaderPtr reader);\n@@ -173,1 +173,1 @@\n-            xmlTextReaderConstName  (xmlTextReaderPtr reader);\n+                    xmlTextReaderConstName      (xmlTextReaderPtr reader);\n@@ -175,1 +175,1 @@\n-            xmlTextReaderConstNamespaceUri(xmlTextReaderPtr reader);\n+                    xmlTextReaderConstNamespaceUri(xmlTextReaderPtr reader);\n@@ -177,1 +177,1 @@\n-            xmlTextReaderConstPrefix    (xmlTextReaderPtr reader);\n+                    xmlTextReaderConstPrefix    (xmlTextReaderPtr reader);\n@@ -179,1 +179,1 @@\n-            xmlTextReaderConstXmlLang   (xmlTextReaderPtr reader);\n+                    xmlTextReaderConstXmlLang   (xmlTextReaderPtr reader);\n@@ -181,2 +181,2 @@\n-            xmlTextReaderConstString    (xmlTextReaderPtr reader,\n-                         const xmlChar *str);\n+                    xmlTextReaderConstString    (xmlTextReaderPtr reader,\n+                                                 const xmlChar *str);\n@@ -184,1 +184,1 @@\n-            xmlTextReaderConstValue (xmlTextReaderPtr reader);\n+                    xmlTextReaderConstValue     (xmlTextReaderPtr reader);\n@@ -191,1 +191,1 @@\n-            xmlTextReaderBaseUri    (xmlTextReaderPtr reader);\n+                        xmlTextReaderBaseUri    (xmlTextReaderPtr reader);\n@@ -193,1 +193,1 @@\n-            xmlTextReaderLocalName  (xmlTextReaderPtr reader);\n+                        xmlTextReaderLocalName  (xmlTextReaderPtr reader);\n@@ -195,1 +195,1 @@\n-            xmlTextReaderName   (xmlTextReaderPtr reader);\n+                        xmlTextReaderName       (xmlTextReaderPtr reader);\n@@ -197,1 +197,1 @@\n-            xmlTextReaderNamespaceUri(xmlTextReaderPtr reader);\n+                        xmlTextReaderNamespaceUri(xmlTextReaderPtr reader);\n@@ -199,1 +199,1 @@\n-            xmlTextReaderPrefix (xmlTextReaderPtr reader);\n+                        xmlTextReaderPrefix     (xmlTextReaderPtr reader);\n@@ -201,1 +201,1 @@\n-            xmlTextReaderXmlLang    (xmlTextReaderPtr reader);\n+                        xmlTextReaderXmlLang    (xmlTextReaderPtr reader);\n@@ -203,1 +203,1 @@\n-            xmlTextReaderValue  (xmlTextReaderPtr reader);\n+                        xmlTextReaderValue      (xmlTextReaderPtr reader);\n@@ -209,1 +209,1 @@\n-            xmlTextReaderClose      (xmlTextReaderPtr reader);\n+                    xmlTextReaderClose          (xmlTextReaderPtr reader);\n@@ -211,2 +211,2 @@\n-            xmlTextReaderGetAttributeNo (xmlTextReaderPtr reader,\n-                         int no);\n+                    xmlTextReaderGetAttributeNo (xmlTextReaderPtr reader,\n+                                                 int no);\n@@ -214,2 +214,2 @@\n-            xmlTextReaderGetAttribute   (xmlTextReaderPtr reader,\n-                         const xmlChar *name);\n+                    xmlTextReaderGetAttribute   (xmlTextReaderPtr reader,\n+                                                 const xmlChar *name);\n@@ -217,3 +217,3 @@\n-            xmlTextReaderGetAttributeNs (xmlTextReaderPtr reader,\n-                         const xmlChar *localName,\n-                         const xmlChar *namespaceURI);\n+                    xmlTextReaderGetAttributeNs (xmlTextReaderPtr reader,\n+                                                 const xmlChar *localName,\n+                                                 const xmlChar *namespaceURI);\n@@ -221,1 +221,1 @@\n-            xmlTextReaderGetRemainder   (xmlTextReaderPtr reader);\n+                    xmlTextReaderGetRemainder   (xmlTextReaderPtr reader);\n@@ -223,2 +223,2 @@\n-            xmlTextReaderLookupNamespace(xmlTextReaderPtr reader,\n-                         const xmlChar *prefix);\n+                    xmlTextReaderLookupNamespace(xmlTextReaderPtr reader,\n+                                                 const xmlChar *prefix);\n@@ -226,2 +226,2 @@\n-            xmlTextReaderMoveToAttributeNo(xmlTextReaderPtr reader,\n-                         int no);\n+                    xmlTextReaderMoveToAttributeNo(xmlTextReaderPtr reader,\n+                                                 int no);\n@@ -229,2 +229,2 @@\n-            xmlTextReaderMoveToAttribute(xmlTextReaderPtr reader,\n-                         const xmlChar *name);\n+                    xmlTextReaderMoveToAttribute(xmlTextReaderPtr reader,\n+                                                 const xmlChar *name);\n@@ -232,3 +232,3 @@\n-            xmlTextReaderMoveToAttributeNs(xmlTextReaderPtr reader,\n-                         const xmlChar *localName,\n-                         const xmlChar *namespaceURI);\n+                    xmlTextReaderMoveToAttributeNs(xmlTextReaderPtr reader,\n+                                                 const xmlChar *localName,\n+                                                 const xmlChar *namespaceURI);\n@@ -236,1 +236,1 @@\n-            xmlTextReaderMoveToFirstAttribute(xmlTextReaderPtr reader);\n+                    xmlTextReaderMoveToFirstAttribute(xmlTextReaderPtr reader);\n@@ -238,1 +238,1 @@\n-            xmlTextReaderMoveToNextAttribute(xmlTextReaderPtr reader);\n+                    xmlTextReaderMoveToNextAttribute(xmlTextReaderPtr reader);\n@@ -240,1 +240,1 @@\n-            xmlTextReaderMoveToElement  (xmlTextReaderPtr reader);\n+                    xmlTextReaderMoveToElement  (xmlTextReaderPtr reader);\n@@ -242,1 +242,1 @@\n-            xmlTextReaderNormalization  (xmlTextReaderPtr reader);\n+                    xmlTextReaderNormalization  (xmlTextReaderPtr reader);\n@@ -244,1 +244,1 @@\n-            xmlTextReaderConstEncoding  (xmlTextReaderPtr reader);\n+                    xmlTextReaderConstEncoding  (xmlTextReaderPtr reader);\n@@ -250,3 +250,3 @@\n-            xmlTextReaderSetParserProp  (xmlTextReaderPtr reader,\n-                         int prop,\n-                         int value);\n+                    xmlTextReaderSetParserProp  (xmlTextReaderPtr reader,\n+                                                 int prop,\n+                                                 int value);\n@@ -254,2 +254,2 @@\n-            xmlTextReaderGetParserProp  (xmlTextReaderPtr reader,\n-                         int prop);\n+                    xmlTextReaderGetParserProp  (xmlTextReaderPtr reader,\n+                                                 int prop);\n@@ -257,1 +257,1 @@\n-            xmlTextReaderCurrentNode    (xmlTextReaderPtr reader);\n+                    xmlTextReaderCurrentNode    (xmlTextReaderPtr reader);\n@@ -266,1 +266,1 @@\n-            xmlTextReaderPreserve   (xmlTextReaderPtr reader);\n+                    xmlTextReaderPreserve       (xmlTextReaderPtr reader);\n@@ -269,3 +269,3 @@\n-            xmlTextReaderPreservePattern(xmlTextReaderPtr reader,\n-                         const xmlChar *pattern,\n-                         const xmlChar **namespaces);\n+                    xmlTextReaderPreservePattern(xmlTextReaderPtr reader,\n+                                                 const xmlChar *pattern,\n+                                                 const xmlChar **namespaces);\n@@ -274,1 +274,1 @@\n-            xmlTextReaderCurrentDoc (xmlTextReaderPtr reader);\n+                    xmlTextReaderCurrentDoc     (xmlTextReaderPtr reader);\n@@ -276,1 +276,1 @@\n-            xmlTextReaderExpand     (xmlTextReaderPtr reader);\n+                    xmlTextReaderExpand         (xmlTextReaderPtr reader);\n@@ -278,1 +278,1 @@\n-            xmlTextReaderNext       (xmlTextReaderPtr reader);\n+                    xmlTextReaderNext           (xmlTextReaderPtr reader);\n@@ -280,1 +280,1 @@\n-            xmlTextReaderNextSibling    (xmlTextReaderPtr reader);\n+                    xmlTextReaderNextSibling    (xmlTextReaderPtr reader);\n@@ -282,1 +282,1 @@\n-            xmlTextReaderIsValid    (xmlTextReaderPtr reader);\n+                    xmlTextReaderIsValid        (xmlTextReaderPtr reader);\n@@ -285,2 +285,2 @@\n-            xmlTextReaderRelaxNGValidate(xmlTextReaderPtr reader,\n-                         const char *rng);\n+                    xmlTextReaderRelaxNGValidate(xmlTextReaderPtr reader,\n+                                                 const char *rng);\n@@ -288,3 +288,3 @@\n-            xmlTextReaderRelaxNGValidateCtxt(xmlTextReaderPtr reader,\n-                         xmlRelaxNGValidCtxtPtr ctxt,\n-                         int options);\n+                    xmlTextReaderRelaxNGValidateCtxt(xmlTextReaderPtr reader,\n+                                                 xmlRelaxNGValidCtxtPtr ctxt,\n+                                                 int options);\n@@ -293,2 +293,2 @@\n-            xmlTextReaderRelaxNGSetSchema(xmlTextReaderPtr reader,\n-                         xmlRelaxNGPtr schema);\n+                    xmlTextReaderRelaxNGSetSchema(xmlTextReaderPtr reader,\n+                                                 xmlRelaxNGPtr schema);\n@@ -296,2 +296,2 @@\n-            xmlTextReaderSchemaValidate (xmlTextReaderPtr reader,\n-                         const char *xsd);\n+                    xmlTextReaderSchemaValidate (xmlTextReaderPtr reader,\n+                                                 const char *xsd);\n@@ -299,3 +299,3 @@\n-            xmlTextReaderSchemaValidateCtxt(xmlTextReaderPtr reader,\n-                         xmlSchemaValidCtxtPtr ctxt,\n-                         int options);\n+                    xmlTextReaderSchemaValidateCtxt(xmlTextReaderPtr reader,\n+                                                 xmlSchemaValidCtxtPtr ctxt,\n+                                                 int options);\n@@ -303,2 +303,2 @@\n-            xmlTextReaderSetSchema  (xmlTextReaderPtr reader,\n-                         xmlSchemaPtr schema);\n+                    xmlTextReaderSetSchema      (xmlTextReaderPtr reader,\n+                                                 xmlSchemaPtr schema);\n@@ -307,1 +307,1 @@\n-            xmlTextReaderConstXmlVersion(xmlTextReaderPtr reader);\n+                    xmlTextReaderConstXmlVersion(xmlTextReaderPtr reader);\n@@ -309,1 +309,1 @@\n-            xmlTextReaderStandalone     (xmlTextReaderPtr reader);\n+                    xmlTextReaderStandalone     (xmlTextReaderPtr reader);\n@@ -316,1 +316,1 @@\n-        xmlTextReaderByteConsumed   (xmlTextReaderPtr reader);\n+                xmlTextReaderByteConsumed       (xmlTextReaderPtr reader);\n@@ -322,1 +322,1 @@\n-        xmlReaderWalker     (xmlDocPtr doc);\n+                xmlReaderWalker         (xmlDocPtr doc);\n@@ -324,4 +324,4 @@\n-        xmlReaderForDoc     (const xmlChar * cur,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlReaderForDoc         (const xmlChar * cur,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -329,3 +329,3 @@\n-        xmlReaderForFile    (const char *filename,\n-                     const char *encoding,\n-                     int options);\n+                xmlReaderForFile        (const char *filename,\n+                                         const char *encoding,\n+                                         int options);\n@@ -333,5 +333,5 @@\n-        xmlReaderForMemory  (const char *buffer,\n-                     int size,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlReaderForMemory      (const char *buffer,\n+                                         int size,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -339,4 +339,4 @@\n-        xmlReaderForFd      (int fd,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlReaderForFd          (int fd,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -344,42 +344,42 @@\n-        xmlReaderForIO      (xmlInputReadCallback ioread,\n-                     xmlInputCloseCallback ioclose,\n-                     void *ioctx,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n-\n-XMLPUBFUN int XMLCALL\n-        xmlReaderNewWalker  (xmlTextReaderPtr reader,\n-                     xmlDocPtr doc);\n-XMLPUBFUN int XMLCALL\n-        xmlReaderNewDoc     (xmlTextReaderPtr reader,\n-                     const xmlChar * cur,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n-XMLPUBFUN int XMLCALL\n-        xmlReaderNewFile    (xmlTextReaderPtr reader,\n-                     const char *filename,\n-                     const char *encoding,\n-                     int options);\n-XMLPUBFUN int XMLCALL\n-        xmlReaderNewMemory  (xmlTextReaderPtr reader,\n-                     const char *buffer,\n-                     int size,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n-XMLPUBFUN int XMLCALL\n-        xmlReaderNewFd      (xmlTextReaderPtr reader,\n-                     int fd,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n-XMLPUBFUN int XMLCALL\n-        xmlReaderNewIO      (xmlTextReaderPtr reader,\n-                     xmlInputReadCallback ioread,\n-                     xmlInputCloseCallback ioclose,\n-                     void *ioctx,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlReaderForIO          (xmlInputReadCallback ioread,\n+                                         xmlInputCloseCallback ioclose,\n+                                         void *ioctx,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n+\n+XMLPUBFUN int XMLCALL\n+                xmlReaderNewWalker      (xmlTextReaderPtr reader,\n+                                         xmlDocPtr doc);\n+XMLPUBFUN int XMLCALL\n+                xmlReaderNewDoc         (xmlTextReaderPtr reader,\n+                                         const xmlChar * cur,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n+XMLPUBFUN int XMLCALL\n+                xmlReaderNewFile        (xmlTextReaderPtr reader,\n+                                         const char *filename,\n+                                         const char *encoding,\n+                                         int options);\n+XMLPUBFUN int XMLCALL\n+                xmlReaderNewMemory      (xmlTextReaderPtr reader,\n+                                         const char *buffer,\n+                                         int size,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n+XMLPUBFUN int XMLCALL\n+                xmlReaderNewFd          (xmlTextReaderPtr reader,\n+                                         int fd,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n+XMLPUBFUN int XMLCALL\n+                xmlReaderNewIO          (xmlTextReaderPtr reader,\n+                                         xmlInputReadCallback ioread,\n+                                         xmlInputCloseCallback ioclose,\n+                                         void *ioctx,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -401,3 +401,3 @@\n-                           const char *msg,\n-                           xmlParserSeverities severity,\n-                           xmlTextReaderLocatorPtr locator);\n+                                               const char *msg,\n+                                               xmlParserSeverities severity,\n+                                               xmlTextReaderLocatorPtr locator);\n@@ -405,1 +405,1 @@\n-        xmlTextReaderLocatorLineNumber(xmlTextReaderLocatorPtr locator);\n+            xmlTextReaderLocatorLineNumber(xmlTextReaderLocatorPtr locator);\n@@ -407,1 +407,1 @@\n-        xmlTextReaderLocatorBaseURI (xmlTextReaderLocatorPtr locator);\n+            xmlTextReaderLocatorBaseURI (xmlTextReaderLocatorPtr locator);\n@@ -409,3 +409,3 @@\n-        xmlTextReaderSetErrorHandler(xmlTextReaderPtr reader,\n-                     xmlTextReaderErrorFunc f,\n-                     void *arg);\n+            xmlTextReaderSetErrorHandler(xmlTextReaderPtr reader,\n+                                         xmlTextReaderErrorFunc f,\n+                                         void *arg);\n@@ -413,3 +413,3 @@\n-        xmlTextReaderSetStructuredErrorHandler(xmlTextReaderPtr reader,\n-                           xmlStructuredErrorFunc f,\n-                           void *arg);\n+            xmlTextReaderSetStructuredErrorHandler(xmlTextReaderPtr reader,\n+                                                   xmlStructuredErrorFunc f,\n+                                                   void *arg);\n@@ -417,3 +417,3 @@\n-        xmlTextReaderGetErrorHandler(xmlTextReaderPtr reader,\n-                     xmlTextReaderErrorFunc *f,\n-                     void **arg);\n+            xmlTextReaderGetErrorHandler(xmlTextReaderPtr reader,\n+                                         xmlTextReaderErrorFunc *f,\n+                                         void **arg);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlreader.h","additions":162,"deletions":162,"binary":false,"changes":324,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-            xmlRegexpCompile    (const xmlChar *regexp);\n-XMLPUBFUN void XMLCALL           xmlRegFreeRegexp(xmlRegexpPtr regexp);\n+                    xmlRegexpCompile    (const xmlChar *regexp);\n+XMLPUBFUN void XMLCALL                   xmlRegFreeRegexp(xmlRegexpPtr regexp);\n@@ -55,2 +55,2 @@\n-            xmlRegexpExec   (xmlRegexpPtr comp,\n-                     const xmlChar *value);\n+                    xmlRegexpExec       (xmlRegexpPtr comp,\n+                                         const xmlChar *value);\n@@ -58,2 +58,2 @@\n-            xmlRegexpPrint  (FILE *output,\n-                     xmlRegexpPtr regexp);\n+                    xmlRegexpPrint      (FILE *output,\n+                                         xmlRegexpPtr regexp);\n@@ -61,1 +61,1 @@\n-            xmlRegexpIsDeterminist(xmlRegexpPtr comp);\n+                    xmlRegexpIsDeterminist(xmlRegexpPtr comp);\n@@ -73,3 +73,3 @@\n-                                 const xmlChar *token,\n-                     void *transdata,\n-                     void *inputdata);\n+                                     const xmlChar *token,\n+                                     void *transdata,\n+                                     void *inputdata);\n@@ -81,3 +81,3 @@\n-            xmlRegNewExecCtxt   (xmlRegexpPtr comp,\n-                     xmlRegExecCallbacks callback,\n-                     void *data);\n+                    xmlRegNewExecCtxt   (xmlRegexpPtr comp,\n+                                         xmlRegExecCallbacks callback,\n+                                         void *data);\n@@ -85,1 +85,1 @@\n-            xmlRegFreeExecCtxt  (xmlRegExecCtxtPtr exec);\n+                    xmlRegFreeExecCtxt  (xmlRegExecCtxtPtr exec);\n@@ -87,3 +87,3 @@\n-            xmlRegExecPushString(xmlRegExecCtxtPtr exec,\n-                     const xmlChar *value,\n-                     void *data);\n+                    xmlRegExecPushString(xmlRegExecCtxtPtr exec,\n+                                         const xmlChar *value,\n+                                         void *data);\n@@ -91,4 +91,4 @@\n-            xmlRegExecPushString2(xmlRegExecCtxtPtr exec,\n-                     const xmlChar *value,\n-                     const xmlChar *value2,\n-                     void *data);\n+                    xmlRegExecPushString2(xmlRegExecCtxtPtr exec,\n+                                         const xmlChar *value,\n+                                         const xmlChar *value2,\n+                                         void *data);\n@@ -97,5 +97,5 @@\n-            xmlRegExecNextValues(xmlRegExecCtxtPtr exec,\n-                     int *nbval,\n-                     int *nbneg,\n-                     xmlChar **values,\n-                     int *terminal);\n+                    xmlRegExecNextValues(xmlRegExecCtxtPtr exec,\n+                                         int *nbval,\n+                                         int *nbneg,\n+                                         xmlChar **values,\n+                                         int *terminal);\n@@ -103,6 +103,6 @@\n-            xmlRegExecErrInfo   (xmlRegExecCtxtPtr exec,\n-                     const xmlChar **string,\n-                     int *nbval,\n-                     int *nbneg,\n-                     xmlChar **values,\n-                     int *terminal);\n+                    xmlRegExecErrInfo   (xmlRegExecCtxtPtr exec,\n+                                         const xmlChar **string,\n+                                         int *nbval,\n+                                         int *nbneg,\n+                                         xmlChar **values,\n+                                         int *terminal);\n@@ -120,1 +120,1 @@\n-            xmlExpFreeCtxt  (xmlExpCtxtPtr ctxt);\n+                        xmlExpFreeCtxt  (xmlExpCtxtPtr ctxt);\n@@ -122,2 +122,2 @@\n-            xmlExpNewCtxt   (int maxNodes,\n-                     xmlDictPtr dict);\n+                        xmlExpNewCtxt   (int maxNodes,\n+                                         xmlDictPtr dict);\n@@ -126,1 +126,1 @@\n-            xmlExpCtxtNbNodes(xmlExpCtxtPtr ctxt);\n+                        xmlExpCtxtNbNodes(xmlExpCtxtPtr ctxt);\n@@ -128,1 +128,1 @@\n-            xmlExpCtxtNbCons(xmlExpCtxtPtr ctxt);\n+                        xmlExpCtxtNbCons(xmlExpCtxtPtr ctxt);\n@@ -154,2 +154,2 @@\n-            xmlExpFree  (xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr expr);\n+                        xmlExpFree      (xmlExpCtxtPtr ctxt,\n+                                         xmlExpNodePtr expr);\n@@ -157,1 +157,1 @@\n-            xmlExpRef   (xmlExpNodePtr expr);\n+                        xmlExpRef       (xmlExpNodePtr expr);\n@@ -163,2 +163,2 @@\n-            xmlExpParse (xmlExpCtxtPtr ctxt,\n-                     const char *expr);\n+                        xmlExpParse     (xmlExpCtxtPtr ctxt,\n+                                         const char *expr);\n@@ -166,3 +166,3 @@\n-            xmlExpNewAtom   (xmlExpCtxtPtr ctxt,\n-                     const xmlChar *name,\n-                     int len);\n+                        xmlExpNewAtom   (xmlExpCtxtPtr ctxt,\n+                                         const xmlChar *name,\n+                                         int len);\n@@ -170,3 +170,3 @@\n-            xmlExpNewOr (xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr left,\n-                     xmlExpNodePtr right);\n+                        xmlExpNewOr     (xmlExpCtxtPtr ctxt,\n+                                         xmlExpNodePtr left,\n+                                         xmlExpNodePtr right);\n@@ -174,3 +174,3 @@\n-            xmlExpNewSeq    (xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr left,\n-                     xmlExpNodePtr right);\n+                        xmlExpNewSeq    (xmlExpCtxtPtr ctxt,\n+                                         xmlExpNodePtr left,\n+                                         xmlExpNodePtr right);\n@@ -178,4 +178,4 @@\n-            xmlExpNewRange  (xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr subset,\n-                     int min,\n-                     int max);\n+                        xmlExpNewRange  (xmlExpCtxtPtr ctxt,\n+                                         xmlExpNodePtr subset,\n+                                         int min,\n+                                         int max);\n@@ -186,1 +186,1 @@\n-            xmlExpIsNillable(xmlExpNodePtr expr);\n+                        xmlExpIsNillable(xmlExpNodePtr expr);\n@@ -188,1 +188,1 @@\n-            xmlExpMaxToken  (xmlExpNodePtr expr);\n+                        xmlExpMaxToken  (xmlExpNodePtr expr);\n@@ -190,4 +190,4 @@\n-            xmlExpGetLanguage(xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr expr,\n-                     const xmlChar**langList,\n-                     int len);\n+                        xmlExpGetLanguage(xmlExpCtxtPtr ctxt,\n+                                         xmlExpNodePtr expr,\n+                                         const xmlChar**langList,\n+                                         int len);\n@@ -195,4 +195,4 @@\n-            xmlExpGetStart  (xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr expr,\n-                     const xmlChar**tokList,\n-                     int len);\n+                        xmlExpGetStart  (xmlExpCtxtPtr ctxt,\n+                                         xmlExpNodePtr expr,\n+                                         const xmlChar**tokList,\n+                                         int len);\n@@ -200,4 +200,4 @@\n-            xmlExpStringDerive(xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr expr,\n-                     const xmlChar *str,\n-                     int len);\n+                        xmlExpStringDerive(xmlExpCtxtPtr ctxt,\n+                                         xmlExpNodePtr expr,\n+                                         const xmlChar *str,\n+                                         int len);\n@@ -205,3 +205,3 @@\n-            xmlExpExpDerive (xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr expr,\n-                     xmlExpNodePtr sub);\n+                        xmlExpExpDerive (xmlExpCtxtPtr ctxt,\n+                                         xmlExpNodePtr expr,\n+                                         xmlExpNodePtr sub);\n@@ -209,3 +209,3 @@\n-            xmlExpSubsume   (xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr expr,\n-                     xmlExpNodePtr sub);\n+                        xmlExpSubsume   (xmlExpCtxtPtr ctxt,\n+                                         xmlExpNodePtr expr,\n+                                         xmlExpNodePtr sub);\n@@ -213,2 +213,2 @@\n-            xmlExpDump  (xmlBufferPtr buf,\n-                     xmlExpNodePtr expr);\n+                        xmlExpDump      (xmlBufferPtr buf,\n+                                         xmlExpNodePtr expr);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlregexp.h","additions":77,"deletions":77,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    XML_SAVE_XHTML  = 1<<4, \/* force XHTML1 specific rules *\/\n+    XML_SAVE_XHTML      = 1<<4, \/* force XHTML1 specific rules *\/\n@@ -45,3 +45,3 @@\n-        xmlSaveToFd     (int fd,\n-                     const char *encoding,\n-                     int options);\n+                xmlSaveToFd             (int fd,\n+                                         const char *encoding,\n+                                         int options);\n@@ -49,3 +49,3 @@\n-        xmlSaveToFilename   (const char *filename,\n-                     const char *encoding,\n-                     int options);\n+                xmlSaveToFilename       (const char *filename,\n+                                         const char *encoding,\n+                                         int options);\n@@ -54,3 +54,3 @@\n-        xmlSaveToBuffer     (xmlBufferPtr buffer,\n-                     const char *encoding,\n-                     int options);\n+                xmlSaveToBuffer         (xmlBufferPtr buffer,\n+                                         const char *encoding,\n+                                         int options);\n@@ -59,5 +59,5 @@\n-        xmlSaveToIO     (xmlOutputWriteCallback iowrite,\n-                     xmlOutputCloseCallback ioclose,\n-                     void *ioctx,\n-                     const char *encoding,\n-                     int options);\n+                xmlSaveToIO             (xmlOutputWriteCallback iowrite,\n+                                         xmlOutputCloseCallback ioclose,\n+                                         void *ioctx,\n+                                         const char *encoding,\n+                                         int options);\n@@ -66,2 +66,2 @@\n-        xmlSaveDoc      (xmlSaveCtxtPtr ctxt,\n-                     xmlDocPtr doc);\n+                xmlSaveDoc              (xmlSaveCtxtPtr ctxt,\n+                                         xmlDocPtr doc);\n@@ -69,2 +69,2 @@\n-        xmlSaveTree     (xmlSaveCtxtPtr ctxt,\n-                     xmlNodePtr node);\n+                xmlSaveTree             (xmlSaveCtxtPtr ctxt,\n+                                         xmlNodePtr node);\n@@ -73,1 +73,1 @@\n-        xmlSaveFlush        (xmlSaveCtxtPtr ctxt);\n+                xmlSaveFlush            (xmlSaveCtxtPtr ctxt);\n@@ -75,1 +75,1 @@\n-        xmlSaveClose        (xmlSaveCtxtPtr ctxt);\n+                xmlSaveClose            (xmlSaveCtxtPtr ctxt);\n@@ -77,2 +77,2 @@\n-        xmlSaveSetEscape    (xmlSaveCtxtPtr ctxt,\n-                     xmlCharEncodingOutputFunc escape);\n+                xmlSaveSetEscape        (xmlSaveCtxtPtr ctxt,\n+                                         xmlCharEncodingOutputFunc escape);\n@@ -80,2 +80,2 @@\n-        xmlSaveSetAttrEscape    (xmlSaveCtxtPtr ctxt,\n-                     xmlCharEncodingOutputFunc escape);\n+                xmlSaveSetAttrEscape    (xmlSaveCtxtPtr ctxt,\n+                                         xmlCharEncodingOutputFunc escape);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlsave.h","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-    XML_SCHEMAS_ERR_OK      = 0,\n-    XML_SCHEMAS_ERR_NOROOT  = 1,\n+    XML_SCHEMAS_ERR_OK          = 0,\n+    XML_SCHEMAS_ERR_NOROOT      = 1,\n@@ -68,4 +68,4 @@\n-    XML_SCHEMA_VAL_VC_I_CREATE          = 1<<0\n-    \/* Default\/fixed: create an attribute node\n-    * or an element's text node on the instance.\n-    *\/\n+    XML_SCHEMA_VAL_VC_I_CREATE                  = 1<<0\n+        \/* Default\/fixed: create an attribute node\n+        * or an element's text node on the instance.\n+        *\/\n@@ -75,4 +75,4 @@\n-    XML_SCHEMA_VAL_XSI_ASSEMBLE         = 1<<1,\n-    * assemble schemata using\n-    * xsi:schemaLocation and\n-    * xsi:noNamespaceSchemaLocation\n+    XML_SCHEMA_VAL_XSI_ASSEMBLE                 = 1<<1,\n+        * assemble schemata using\n+        * xsi:schemaLocation and\n+        * xsi:noNamespaceSchemaLocation\n@@ -138,1 +138,1 @@\n-        xmlSchemaNewParserCtxt  (const char *URL);\n+            xmlSchemaNewParserCtxt      (const char *URL);\n@@ -140,2 +140,2 @@\n-        xmlSchemaNewMemParserCtxt   (const char *buffer,\n-                     int size);\n+            xmlSchemaNewMemParserCtxt   (const char *buffer,\n+                                         int size);\n@@ -143,1 +143,1 @@\n-        xmlSchemaNewDocParserCtxt   (xmlDocPtr doc);\n+            xmlSchemaNewDocParserCtxt   (xmlDocPtr doc);\n@@ -145,1 +145,1 @@\n-        xmlSchemaFreeParserCtxt (xmlSchemaParserCtxtPtr ctxt);\n+            xmlSchemaFreeParserCtxt     (xmlSchemaParserCtxtPtr ctxt);\n@@ -147,4 +147,4 @@\n-        xmlSchemaSetParserErrors    (xmlSchemaParserCtxtPtr ctxt,\n-                     xmlSchemaValidityErrorFunc err,\n-                     xmlSchemaValidityWarningFunc warn,\n-                     void *ctx);\n+            xmlSchemaSetParserErrors    (xmlSchemaParserCtxtPtr ctxt,\n+                                         xmlSchemaValidityErrorFunc err,\n+                                         xmlSchemaValidityWarningFunc warn,\n+                                         void *ctx);\n@@ -152,3 +152,3 @@\n-        xmlSchemaSetParserStructuredErrors(xmlSchemaParserCtxtPtr ctxt,\n-                     xmlStructuredErrorFunc serror,\n-                     void *ctx);\n+            xmlSchemaSetParserStructuredErrors(xmlSchemaParserCtxtPtr ctxt,\n+                                         xmlStructuredErrorFunc serror,\n+                                         void *ctx);\n@@ -156,4 +156,4 @@\n-        xmlSchemaGetParserErrors(xmlSchemaParserCtxtPtr ctxt,\n-                    xmlSchemaValidityErrorFunc * err,\n-                    xmlSchemaValidityWarningFunc * warn,\n-                    void **ctx);\n+                xmlSchemaGetParserErrors(xmlSchemaParserCtxtPtr ctxt,\n+                                        xmlSchemaValidityErrorFunc * err,\n+                                        xmlSchemaValidityWarningFunc * warn,\n+                                        void **ctx);\n@@ -161,1 +161,1 @@\n-        xmlSchemaIsValid    (xmlSchemaValidCtxtPtr ctxt);\n+                xmlSchemaIsValid        (xmlSchemaValidCtxtPtr ctxt);\n@@ -164,1 +164,1 @@\n-        xmlSchemaParse      (xmlSchemaParserCtxtPtr ctxt);\n+            xmlSchemaParse              (xmlSchemaParserCtxtPtr ctxt);\n@@ -166,1 +166,1 @@\n-        xmlSchemaFree       (xmlSchemaPtr schema);\n+            xmlSchemaFree               (xmlSchemaPtr schema);\n@@ -169,2 +169,2 @@\n-        xmlSchemaDump       (FILE *output,\n-                     xmlSchemaPtr schema);\n+            xmlSchemaDump               (FILE *output,\n+                                         xmlSchemaPtr schema);\n@@ -176,4 +176,4 @@\n-        xmlSchemaSetValidErrors (xmlSchemaValidCtxtPtr ctxt,\n-                     xmlSchemaValidityErrorFunc err,\n-                     xmlSchemaValidityWarningFunc warn,\n-                     void *ctx);\n+            xmlSchemaSetValidErrors     (xmlSchemaValidCtxtPtr ctxt,\n+                                         xmlSchemaValidityErrorFunc err,\n+                                         xmlSchemaValidityWarningFunc warn,\n+                                         void *ctx);\n@@ -181,3 +181,3 @@\n-        xmlSchemaSetValidStructuredErrors(xmlSchemaValidCtxtPtr ctxt,\n-                     xmlStructuredErrorFunc serror,\n-                     void *ctx);\n+            xmlSchemaSetValidStructuredErrors(xmlSchemaValidCtxtPtr ctxt,\n+                                         xmlStructuredErrorFunc serror,\n+                                         void *ctx);\n@@ -185,4 +185,4 @@\n-        xmlSchemaGetValidErrors (xmlSchemaValidCtxtPtr ctxt,\n-                     xmlSchemaValidityErrorFunc *err,\n-                     xmlSchemaValidityWarningFunc *warn,\n-                     void **ctx);\n+            xmlSchemaGetValidErrors     (xmlSchemaValidCtxtPtr ctxt,\n+                                         xmlSchemaValidityErrorFunc *err,\n+                                         xmlSchemaValidityWarningFunc *warn,\n+                                         void **ctx);\n@@ -190,2 +190,2 @@\n-        xmlSchemaSetValidOptions    (xmlSchemaValidCtxtPtr ctxt,\n-                     int options);\n+            xmlSchemaSetValidOptions    (xmlSchemaValidCtxtPtr ctxt,\n+                                         int options);\n@@ -194,1 +194,1 @@\n-                                     const char *filename);\n+                                         const char *filename);\n@@ -196,1 +196,1 @@\n-        xmlSchemaValidCtxtGetOptions(xmlSchemaValidCtxtPtr ctxt);\n+            xmlSchemaValidCtxtGetOptions(xmlSchemaValidCtxtPtr ctxt);\n@@ -199,1 +199,1 @@\n-        xmlSchemaNewValidCtxt   (xmlSchemaPtr schema);\n+            xmlSchemaNewValidCtxt       (xmlSchemaPtr schema);\n@@ -201,1 +201,1 @@\n-        xmlSchemaFreeValidCtxt  (xmlSchemaValidCtxtPtr ctxt);\n+            xmlSchemaFreeValidCtxt      (xmlSchemaValidCtxtPtr ctxt);\n@@ -203,2 +203,2 @@\n-        xmlSchemaValidateDoc    (xmlSchemaValidCtxtPtr ctxt,\n-                     xmlDocPtr instance);\n+            xmlSchemaValidateDoc        (xmlSchemaValidCtxtPtr ctxt,\n+                                         xmlDocPtr instance);\n@@ -207,1 +207,1 @@\n-                             xmlNodePtr elem);\n+                                         xmlNodePtr elem);\n@@ -209,5 +209,5 @@\n-        xmlSchemaValidateStream (xmlSchemaValidCtxtPtr ctxt,\n-                     xmlParserInputBufferPtr input,\n-                     xmlCharEncoding enc,\n-                     xmlSAXHandlerPtr sax,\n-                     void *user_data);\n+            xmlSchemaValidateStream     (xmlSchemaValidCtxtPtr ctxt,\n+                                         xmlParserInputBufferPtr input,\n+                                         xmlCharEncoding enc,\n+                                         xmlSAXHandlerPtr sax,\n+                                         void *user_data);\n@@ -215,3 +215,3 @@\n-        xmlSchemaValidateFile   (xmlSchemaValidCtxtPtr ctxt,\n-                     const char * filename,\n-                     int options);\n+            xmlSchemaValidateFile       (xmlSchemaValidCtxtPtr ctxt,\n+                                         const char * filename,\n+                                         int options);\n@@ -220,1 +220,1 @@\n-        xmlSchemaValidCtxtGetParserCtxt(xmlSchemaValidCtxtPtr ctxt);\n+            xmlSchemaValidCtxtGetParserCtxt(xmlSchemaValidCtxtPtr ctxt);\n@@ -229,3 +229,3 @@\n-            xmlSchemaSAXPlug        (xmlSchemaValidCtxtPtr ctxt,\n-                     xmlSAXHandlerPtr *sax,\n-                     void **user_data);\n+            xmlSchemaSAXPlug            (xmlSchemaValidCtxtPtr ctxt,\n+                                         xmlSAXHandlerPtr *sax,\n+                                         void **user_data);\n@@ -233,1 +233,1 @@\n-            xmlSchemaSAXUnplug      (xmlSchemaSAXPlugPtr plug);\n+            xmlSchemaSAXUnplug          (xmlSchemaSAXPlugPtr plug);\n@@ -238,2 +238,2 @@\n-                     xmlSchemaValidityLocatorFunc f,\n-                     void *ctxt);\n+                                         xmlSchemaValidityLocatorFunc f,\n+                                         void *ctxt);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlschemas.h","additions":66,"deletions":66,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-        xmlSchemaInitTypes      (void);\n+                xmlSchemaInitTypes              (void);\n@@ -36,1 +36,1 @@\n-        xmlSchemaCleanupTypes       (void);\n+                xmlSchemaCleanupTypes           (void);\n@@ -38,23 +38,23 @@\n-        xmlSchemaGetPredefinedType  (const xmlChar *name,\n-                         const xmlChar *ns);\n-XMLPUBFUN int XMLCALL\n-        xmlSchemaValidatePredefinedType (xmlSchemaTypePtr type,\n-                         const xmlChar *value,\n-                         xmlSchemaValPtr *val);\n-XMLPUBFUN int XMLCALL\n-        xmlSchemaValPredefTypeNode  (xmlSchemaTypePtr type,\n-                         const xmlChar *value,\n-                         xmlSchemaValPtr *val,\n-                         xmlNodePtr node);\n-XMLPUBFUN int XMLCALL\n-        xmlSchemaValidateFacet      (xmlSchemaTypePtr base,\n-                         xmlSchemaFacetPtr facet,\n-                         const xmlChar *value,\n-                         xmlSchemaValPtr val);\n-XMLPUBFUN int XMLCALL\n-        xmlSchemaValidateFacetWhtsp (xmlSchemaFacetPtr facet,\n-                         xmlSchemaWhitespaceValueType fws,\n-                         xmlSchemaValType valType,\n-                         const xmlChar *value,\n-                         xmlSchemaValPtr val,\n-                         xmlSchemaWhitespaceValueType ws);\n+                xmlSchemaGetPredefinedType      (const xmlChar *name,\n+                                                 const xmlChar *ns);\n+XMLPUBFUN int XMLCALL\n+                xmlSchemaValidatePredefinedType (xmlSchemaTypePtr type,\n+                                                 const xmlChar *value,\n+                                                 xmlSchemaValPtr *val);\n+XMLPUBFUN int XMLCALL\n+                xmlSchemaValPredefTypeNode      (xmlSchemaTypePtr type,\n+                                                 const xmlChar *value,\n+                                                 xmlSchemaValPtr *val,\n+                                                 xmlNodePtr node);\n+XMLPUBFUN int XMLCALL\n+                xmlSchemaValidateFacet          (xmlSchemaTypePtr base,\n+                                                 xmlSchemaFacetPtr facet,\n+                                                 const xmlChar *value,\n+                                                 xmlSchemaValPtr val);\n+XMLPUBFUN int XMLCALL\n+                xmlSchemaValidateFacetWhtsp     (xmlSchemaFacetPtr facet,\n+                                                 xmlSchemaWhitespaceValueType fws,\n+                                                 xmlSchemaValType valType,\n+                                                 const xmlChar *value,\n+                                                 xmlSchemaValPtr val,\n+                                                 xmlSchemaWhitespaceValueType ws);\n@@ -62,1 +62,1 @@\n-        xmlSchemaFreeValue      (xmlSchemaValPtr val);\n+                xmlSchemaFreeValue              (xmlSchemaValPtr val);\n@@ -64,1 +64,1 @@\n-        xmlSchemaNewFacet       (void);\n+                xmlSchemaNewFacet               (void);\n@@ -66,4 +66,4 @@\n-        xmlSchemaCheckFacet     (xmlSchemaFacetPtr facet,\n-                         xmlSchemaTypePtr typeDecl,\n-                         xmlSchemaParserCtxtPtr ctxt,\n-                         const xmlChar *name);\n+                xmlSchemaCheckFacet             (xmlSchemaFacetPtr facet,\n+                                                 xmlSchemaTypePtr typeDecl,\n+                                                 xmlSchemaParserCtxtPtr ctxt,\n+                                                 const xmlChar *name);\n@@ -71,1 +71,1 @@\n-        xmlSchemaFreeFacet      (xmlSchemaFacetPtr facet);\n+                xmlSchemaFreeFacet              (xmlSchemaFacetPtr facet);\n@@ -73,2 +73,2 @@\n-        xmlSchemaCompareValues      (xmlSchemaValPtr x,\n-                         xmlSchemaValPtr y);\n+                xmlSchemaCompareValues          (xmlSchemaValPtr x,\n+                                                 xmlSchemaValPtr y);\n@@ -78,4 +78,4 @@\n-    xmlSchemaValidateListSimpleTypeFacet    (xmlSchemaFacetPtr facet,\n-                         const xmlChar *value,\n-                         unsigned long actualLen,\n-                         unsigned long *expectedLen);\n+    xmlSchemaValidateListSimpleTypeFacet        (xmlSchemaFacetPtr facet,\n+                                                 const xmlChar *value,\n+                                                 unsigned long actualLen,\n+                                                 unsigned long *expectedLen);\n@@ -83,1 +83,1 @@\n-        xmlSchemaGetBuiltInType     (xmlSchemaValType type);\n+                xmlSchemaGetBuiltInType         (xmlSchemaValType type);\n@@ -85,2 +85,2 @@\n-        xmlSchemaIsBuiltInTypeFacet (xmlSchemaTypePtr type,\n-                         int facetType);\n+                xmlSchemaIsBuiltInTypeFacet     (xmlSchemaTypePtr type,\n+                                                 int facetType);\n@@ -88,1 +88,1 @@\n-        xmlSchemaCollapseString     (const xmlChar *value);\n+                xmlSchemaCollapseString         (const xmlChar *value);\n@@ -90,1 +90,1 @@\n-        xmlSchemaWhiteSpaceReplace  (const xmlChar *value);\n+                xmlSchemaWhiteSpaceReplace      (const xmlChar *value);\n@@ -92,29 +92,29 @@\n-        xmlSchemaGetFacetValueAsULong   (xmlSchemaFacetPtr facet);\n-XMLPUBFUN int XMLCALL\n-        xmlSchemaValidateLengthFacet    (xmlSchemaTypePtr type,\n-                         xmlSchemaFacetPtr facet,\n-                         const xmlChar *value,\n-                         xmlSchemaValPtr val,\n-                         unsigned long *length);\n-XMLPUBFUN int XMLCALL\n-        xmlSchemaValidateLengthFacetWhtsp(xmlSchemaFacetPtr facet,\n-                          xmlSchemaValType valType,\n-                          const xmlChar *value,\n-                          xmlSchemaValPtr val,\n-                          unsigned long *length,\n-                          xmlSchemaWhitespaceValueType ws);\n-XMLPUBFUN int XMLCALL\n-        xmlSchemaValPredefTypeNodeNoNorm(xmlSchemaTypePtr type,\n-                         const xmlChar *value,\n-                         xmlSchemaValPtr *val,\n-                         xmlNodePtr node);\n-XMLPUBFUN int XMLCALL\n-        xmlSchemaGetCanonValue      (xmlSchemaValPtr val,\n-                         const xmlChar **retValue);\n-XMLPUBFUN int XMLCALL\n-        xmlSchemaGetCanonValueWhtsp (xmlSchemaValPtr val,\n-                         const xmlChar **retValue,\n-                         xmlSchemaWhitespaceValueType ws);\n-XMLPUBFUN int XMLCALL\n-        xmlSchemaValueAppend        (xmlSchemaValPtr prev,\n-                         xmlSchemaValPtr cur);\n+                xmlSchemaGetFacetValueAsULong   (xmlSchemaFacetPtr facet);\n+XMLPUBFUN int XMLCALL\n+                xmlSchemaValidateLengthFacet    (xmlSchemaTypePtr type,\n+                                                 xmlSchemaFacetPtr facet,\n+                                                 const xmlChar *value,\n+                                                 xmlSchemaValPtr val,\n+                                                 unsigned long *length);\n+XMLPUBFUN int XMLCALL\n+                xmlSchemaValidateLengthFacetWhtsp(xmlSchemaFacetPtr facet,\n+                                                  xmlSchemaValType valType,\n+                                                  const xmlChar *value,\n+                                                  xmlSchemaValPtr val,\n+                                                  unsigned long *length,\n+                                                  xmlSchemaWhitespaceValueType ws);\n+XMLPUBFUN int XMLCALL\n+                xmlSchemaValPredefTypeNodeNoNorm(xmlSchemaTypePtr type,\n+                                                 const xmlChar *value,\n+                                                 xmlSchemaValPtr *val,\n+                                                 xmlNodePtr node);\n+XMLPUBFUN int XMLCALL\n+                xmlSchemaGetCanonValue          (xmlSchemaValPtr val,\n+                                                 const xmlChar **retValue);\n+XMLPUBFUN int XMLCALL\n+                xmlSchemaGetCanonValueWhtsp     (xmlSchemaValPtr val,\n+                                                 const xmlChar **retValue,\n+                                                 xmlSchemaWhitespaceValueType ws);\n+XMLPUBFUN int XMLCALL\n+                xmlSchemaValueAppend            (xmlSchemaValPtr prev,\n+                                                 xmlSchemaValPtr cur);\n@@ -122,1 +122,1 @@\n-        xmlSchemaValueGetNext       (xmlSchemaValPtr cur);\n+                xmlSchemaValueGetNext           (xmlSchemaValPtr cur);\n@@ -124,1 +124,1 @@\n-        xmlSchemaValueGetAsString   (xmlSchemaValPtr val);\n+                xmlSchemaValueGetAsString       (xmlSchemaValPtr val);\n@@ -126,1 +126,1 @@\n-        xmlSchemaValueGetAsBoolean  (xmlSchemaValPtr val);\n+                xmlSchemaValueGetAsBoolean      (xmlSchemaValPtr val);\n@@ -128,2 +128,2 @@\n-        xmlSchemaNewStringValue     (xmlSchemaValType type,\n-                         const xmlChar *value);\n+                xmlSchemaNewStringValue         (xmlSchemaValType type,\n+                                                 const xmlChar *value);\n@@ -131,2 +131,2 @@\n-        xmlSchemaNewNOTATIONValue   (const xmlChar *name,\n-                         const xmlChar *ns);\n+                xmlSchemaNewNOTATIONValue       (const xmlChar *name,\n+                                                 const xmlChar *ns);\n@@ -134,2 +134,2 @@\n-        xmlSchemaNewQNameValue      (const xmlChar *namespaceName,\n-                         const xmlChar *localName);\n+                xmlSchemaNewQNameValue          (const xmlChar *namespaceName,\n+                                                 const xmlChar *localName);\n@@ -137,4 +137,4 @@\n-        xmlSchemaCompareValuesWhtsp (xmlSchemaValPtr x,\n-                         xmlSchemaWhitespaceValueType xws,\n-                         xmlSchemaValPtr y,\n-                         xmlSchemaWhitespaceValueType yws);\n+                xmlSchemaCompareValuesWhtsp     (xmlSchemaValPtr x,\n+                                                 xmlSchemaWhitespaceValueType xws,\n+                                                 xmlSchemaValPtr y,\n+                                                 xmlSchemaWhitespaceValueType yws);\n@@ -142,1 +142,1 @@\n-        xmlSchemaCopyValue      (xmlSchemaValPtr val);\n+                xmlSchemaCopyValue              (xmlSchemaValPtr val);\n@@ -144,1 +144,1 @@\n-        xmlSchemaGetValType     (xmlSchemaValPtr val);\n+                xmlSchemaGetValType             (xmlSchemaValPtr val);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlschemastypes.h","additions":87,"deletions":87,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsAegeanNumbers (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsAlphabeticPresentationForms   (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsAegeanNumbers     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsAlphabeticPresentationForms       (int code);\n@@ -33,1 +33,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsBasicLatin    (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsBasicLatin        (int code);\n@@ -35,1 +35,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsBlockElements (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsBlockElements     (int code);\n@@ -38,1 +38,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsBoxDrawing    (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsBoxDrawing        (int code);\n@@ -40,1 +40,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsBuhid (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsBuhid     (int code);\n@@ -43,4 +43,4 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityForms (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityIdeographs    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityIdeographsSupplement  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCJKRadicalsSupplement (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityForms     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityIdeographs        (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCJKCompatibilityIdeographsSupplement      (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCJKRadicalsSupplement     (int code);\n@@ -48,1 +48,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsCJKUnifiedIdeographs  (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCJKUnifiedIdeographs      (int code);\n@@ -53,2 +53,2 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsCombiningDiacriticalMarksforSymbols   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCombiningHalfMarks    (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCombiningDiacriticalMarksforSymbols       (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCombiningHalfMarks        (int code);\n@@ -60,1 +60,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsCyrillicSupplement    (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCyrillicSupplement        (int code);\n@@ -62,1 +62,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsDevanagari    (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsDevanagari        (int code);\n@@ -64,2 +64,2 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsEnclosedAlphanumerics (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsEnclosedCJKLettersandMonths   (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsEnclosedAlphanumerics     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsEnclosedCJKLettersandMonths       (int code);\n@@ -67,1 +67,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsGeneralPunctuation    (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsGeneralPunctuation        (int code);\n@@ -71,2 +71,2 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsGreek (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsGreekExtended (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsGreek     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsGreekExtended     (int code);\n@@ -76,1 +76,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsHalfwidthandFullwidthForms    (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsHalfwidthandFullwidthForms        (int code);\n@@ -78,1 +78,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsHangulJamo    (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsHangulJamo        (int code);\n@@ -85,1 +85,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsIPAExtensions (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsIPAExtensions     (int code);\n@@ -91,4 +91,4 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsKatakanaPhoneticExtensions    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsKhmer (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsKhmerSymbols  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsLao   (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsKatakanaPhoneticExtensions        (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsKhmer     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsKhmerSymbols      (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsLao       (int code);\n@@ -100,1 +100,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsLimbu (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsLimbu     (int code);\n@@ -103,1 +103,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsLowSurrogates (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsLowSurrogates     (int code);\n@@ -106,1 +106,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsMathematicalOperators (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsMathematicalOperators     (int code);\n@@ -109,2 +109,2 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousSymbols  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousSymbolsandArrows (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousSymbols      (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsMiscellaneousSymbolsandArrows     (int code);\n@@ -115,2 +115,2 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsNumberForms   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsOgham (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsNumberForms       (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsOgham     (int code);\n@@ -118,2 +118,2 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsOpticalCharacterRecognition   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsOriya (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsOpticalCharacterRecognition       (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsOriya     (int code);\n@@ -121,2 +121,2 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsPhoneticExtensions    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsPrivateUse    (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsPhoneticExtensions        (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsPrivateUse        (int code);\n@@ -124,1 +124,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsRunic (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsRunic     (int code);\n@@ -131,2 +131,2 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsSupplementalArrowsA   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsSupplementalArrowsB   (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsSupplementalArrowsA       (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsSupplementalArrowsB       (int code);\n@@ -134,2 +134,2 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsSupplementaryPrivateUseAreaA  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsSupplementaryPrivateUseAreaB  (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsSupplementaryPrivateUseAreaA      (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsSupplementaryPrivateUseAreaB      (int code);\n@@ -139,4 +139,4 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsTags  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsTaiLe (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsTaiXuanJingSymbols    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsTamil (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsTags      (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsTaiLe     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsTaiXuanJingSymbols        (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsTamil     (int code);\n@@ -145,1 +145,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsThai  (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsThai      (int code);\n@@ -148,6 +148,6 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsUnifiedCanadianAboriginalSyllabics    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsVariationSelectors    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsVariationSelectorsSupplement  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsYiRadicals    (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsYiSyllables   (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsYijingHexagramSymbols (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsUnifiedCanadianAboriginalSyllabics        (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsVariationSelectors        (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsVariationSelectorsSupplement      (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsYiRadicals        (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsYiSyllables       (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsYijingHexagramSymbols     (int code);\n@@ -155,1 +155,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsBlock (int code, const char *block);\n+XMLPUBFUN int XMLCALL xmlUCSIsBlock     (int code, const char *block);\n@@ -157,36 +157,36 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsCatC  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatCc (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatCf (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatCo (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatCs (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatL  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatLl (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatLm (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatLo (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatLt (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatLu (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatM  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatMc (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatMe (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatMn (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatN  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatNd (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatNl (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatNo (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatP  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatPc (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatPd (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatPe (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatPf (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatPi (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatPo (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatPs (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatS  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatSc (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatSk (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatSm (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatSo (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatZ  (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatZl (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatZp (int code);\n-XMLPUBFUN int XMLCALL xmlUCSIsCatZs (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatC      (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatCc     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatCf     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatCo     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatCs     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatL      (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatLl     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatLm     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatLo     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatLt     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatLu     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatM      (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatMc     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatMe     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatMn     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatN      (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatNd     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatNl     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatNo     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatP      (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatPc     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatPd     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatPe     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatPf     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatPi     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatPo     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatPs     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatS      (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatSc     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatSk     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatSm     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatSo     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatZ      (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatZl     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatZp     (int code);\n+XMLPUBFUN int XMLCALL xmlUCSIsCatZs     (int code);\n@@ -194,1 +194,1 @@\n-XMLPUBFUN int XMLCALL xmlUCSIsCat   (int code, const char *cat);\n+XMLPUBFUN int XMLCALL xmlUCSIsCat       (int code, const char *cat);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlunicode.h","additions":92,"deletions":92,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * extra version information, used to show a CVS compilation\n+ * extra version information, used to show a git commit description\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlversion.h.in","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-                    LIBXML_ATTR_FORMAT(2,3);\n+                                        LIBXML_ATTR_FORMAT(2,3);\n@@ -77,1 +77,1 @@\n-                     LIBXML_ATTR_FORMAT(2,0);\n+                                         LIBXML_ATTR_FORMAT(2,0);\n@@ -107,1 +107,1 @@\n-                    LIBXML_ATTR_FORMAT(3,4);\n+                                        LIBXML_ATTR_FORMAT(3,4);\n@@ -113,1 +113,1 @@\n-                     LIBXML_ATTR_FORMAT(3,0);\n+                                         LIBXML_ATTR_FORMAT(3,0);\n@@ -125,1 +125,1 @@\n-                      LIBXML_ATTR_FORMAT(5,6);\n+                                          LIBXML_ATTR_FORMAT(5,6);\n@@ -133,1 +133,1 @@\n-                       LIBXML_ATTR_FORMAT(5,0);\n+                                           LIBXML_ATTR_FORMAT(5,0);\n@@ -150,1 +150,1 @@\n-                    LIBXML_ATTR_FORMAT(2,3);\n+                                    LIBXML_ATTR_FORMAT(2,3);\n@@ -154,1 +154,1 @@\n-                     LIBXML_ATTR_FORMAT(2,0);\n+                                     LIBXML_ATTR_FORMAT(2,0);\n@@ -165,1 +165,1 @@\n-                             LIBXML_ATTR_FORMAT(2,3);\n+                                                         LIBXML_ATTR_FORMAT(2,3);\n@@ -171,1 +171,1 @@\n-                              LIBXML_ATTR_FORMAT(2,0);\n+                                                          LIBXML_ATTR_FORMAT(2,0);\n@@ -206,1 +206,1 @@\n-                      LIBXML_ATTR_FORMAT(3,4);\n+                                          LIBXML_ATTR_FORMAT(3,4);\n@@ -212,1 +212,1 @@\n-                       LIBXML_ATTR_FORMAT(3,0);\n+                                           LIBXML_ATTR_FORMAT(3,0);\n@@ -224,1 +224,1 @@\n-                        LIBXML_ATTR_FORMAT(5,6);\n+                                            LIBXML_ATTR_FORMAT(5,6);\n@@ -232,1 +232,1 @@\n-                         LIBXML_ATTR_FORMAT(5,0);\n+                                             LIBXML_ATTR_FORMAT(5,0);\n@@ -259,1 +259,1 @@\n-                   LIBXML_ATTR_FORMAT(3,4);\n+                                   LIBXML_ATTR_FORMAT(3,4);\n@@ -264,1 +264,1 @@\n-                    LIBXML_ATTR_FORMAT(3,0);\n+                                    LIBXML_ATTR_FORMAT(3,0);\n@@ -289,1 +289,1 @@\n-                      LIBXML_ATTR_FORMAT(2,3);\n+                                      LIBXML_ATTR_FORMAT(2,3);\n@@ -293,1 +293,1 @@\n-                       LIBXML_ATTR_FORMAT(2,0);\n+                                       LIBXML_ATTR_FORMAT(2,0);\n@@ -317,1 +317,1 @@\n-                    LIBXML_ATTR_FORMAT(5,6);\n+                                    LIBXML_ATTR_FORMAT(5,6);\n@@ -324,1 +324,1 @@\n-                     LIBXML_ATTR_FORMAT(5,0);\n+                                     LIBXML_ATTR_FORMAT(5,0);\n@@ -355,1 +355,1 @@\n-                       LIBXML_ATTR_FORMAT(3,4);\n+                                           LIBXML_ATTR_FORMAT(3,4);\n@@ -361,1 +361,1 @@\n-                        LIBXML_ATTR_FORMAT(3,0);\n+                                            LIBXML_ATTR_FORMAT(3,0);\n@@ -385,1 +385,1 @@\n-                       LIBXML_ATTR_FORMAT(3,4);\n+                                           LIBXML_ATTR_FORMAT(3,4);\n@@ -391,1 +391,1 @@\n-                        LIBXML_ATTR_FORMAT(3,0);\n+                                            LIBXML_ATTR_FORMAT(3,0);\n@@ -416,1 +416,1 @@\n-                          LIBXML_ATTR_FORMAT(4,5);\n+                                                  LIBXML_ATTR_FORMAT(4,5);\n@@ -423,1 +423,1 @@\n-                           LIBXML_ATTR_FORMAT(4,0);\n+                                                   LIBXML_ATTR_FORMAT(4,0);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlwriter.h","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -84,3 +84,3 @@\n-    int nodeNr;         \/* number of nodes in the set *\/\n-    int nodeMax;        \/* size of the array as allocated *\/\n-    xmlNodePtr *nodeTab;    \/* array of nodes in no particular order *\/\n+    int nodeNr;                 \/* number of nodes in the set *\/\n+    int nodeMax;                \/* size of the array as allocated *\/\n+    xmlNodePtr *nodeTab;        \/* array of nodes in no particular order *\/\n@@ -147,2 +147,2 @@\n-    const xmlChar         *name;        \/* the type name *\/\n-    xmlXPathConvertFunc func;       \/* the conversion function *\/\n+    const xmlChar         *name;                \/* the type name *\/\n+    xmlXPathConvertFunc func;           \/* the conversion function *\/\n@@ -158,2 +158,2 @@\n-    const xmlChar       *name;      \/* the variable name *\/\n-    xmlXPathObjectPtr value;        \/* the value *\/\n+    const xmlChar       *name;          \/* the variable name *\/\n+    xmlXPathObjectPtr value;            \/* the value *\/\n@@ -171,1 +171,1 @@\n-                             int nargs);\n+                                 int nargs);\n@@ -180,2 +180,2 @@\n-    const xmlChar      *name;       \/* the function name *\/\n-    xmlXPathEvalFunc func;      \/* the evaluation function *\/\n+    const xmlChar      *name;           \/* the function name *\/\n+    xmlXPathEvalFunc func;              \/* the evaluation function *\/\n@@ -197,1 +197,1 @@\n-                 xmlXPathObjectPtr cur);\n+                                 xmlXPathObjectPtr cur);\n@@ -206,2 +206,2 @@\n-    const xmlChar      *name;       \/* the axis name *\/\n-    xmlXPathAxisFunc func;      \/* the search function *\/\n+    const xmlChar      *name;           \/* the axis name *\/\n+    xmlXPathAxisFunc func;              \/* the search function *\/\n@@ -253,2 +253,2 @@\n-                     const xmlChar *name,\n-                     const xmlChar *ns_uri);\n+                                         const xmlChar *name,\n+                                         const xmlChar *ns_uri);\n@@ -291,2 +291,2 @@\n-    xmlDocPtr doc;          \/* The current document *\/\n-    xmlNodePtr node;            \/* The current node *\/\n+    xmlDocPtr doc;                      \/* The current document *\/\n+    xmlNodePtr node;                    \/* The current node *\/\n@@ -294,3 +294,3 @@\n-    int nb_variables_unused;        \/* unused (hash table) *\/\n-    int max_variables_unused;       \/* unused (hash table) *\/\n-    xmlHashTablePtr varHash;        \/* Hash table of defined variables *\/\n+    int nb_variables_unused;            \/* unused (hash table) *\/\n+    int max_variables_unused;           \/* unused (hash table) *\/\n+    xmlHashTablePtr varHash;            \/* Hash table of defined variables *\/\n@@ -298,3 +298,3 @@\n-    int nb_types;           \/* number of defined types *\/\n-    int max_types;          \/* max number of types *\/\n-    xmlXPathTypePtr types;      \/* Array of defined types *\/\n+    int nb_types;                       \/* number of defined types *\/\n+    int max_types;                      \/* max number of types *\/\n+    xmlXPathTypePtr types;              \/* Array of defined types *\/\n@@ -302,3 +302,3 @@\n-    int nb_funcs_unused;        \/* unused (hash table) *\/\n-    int max_funcs_unused;       \/* unused (hash table) *\/\n-    xmlHashTablePtr funcHash;       \/* Hash table of defined funcs *\/\n+    int nb_funcs_unused;                \/* unused (hash table) *\/\n+    int max_funcs_unused;               \/* unused (hash table) *\/\n+    xmlHashTablePtr funcHash;           \/* Hash table of defined funcs *\/\n@@ -306,3 +306,3 @@\n-    int nb_axis;            \/* number of defined axis *\/\n-    int max_axis;           \/* max number of axis *\/\n-    xmlXPathAxisPtr axis;       \/* Array of defined axis *\/\n+    int nb_axis;                        \/* number of defined axis *\/\n+    int max_axis;                       \/* max number of axis *\/\n+    xmlXPathAxisPtr axis;               \/* Array of defined axis *\/\n@@ -311,3 +311,3 @@\n-    xmlNsPtr *namespaces;       \/* Array of namespaces *\/\n-    int nsNr;               \/* number of namespace in scope *\/\n-    void *user;             \/* function to free *\/\n+    xmlNsPtr *namespaces;               \/* Array of namespaces *\/\n+    int nsNr;                           \/* number of namespace in scope *\/\n+    void *user;                         \/* function to free *\/\n@@ -316,2 +316,2 @@\n-    int contextSize;            \/* the context size *\/\n-    int proximityPosition;      \/* the proximity position *\/\n+    int contextSize;                    \/* the context size *\/\n+    int proximityPosition;              \/* the proximity position *\/\n@@ -320,3 +320,3 @@\n-    int xptr;               \/* is this an XPointer context? *\/\n-    xmlNodePtr here;            \/* for here() *\/\n-    xmlNodePtr origin;          \/* for origin() *\/\n+    int xptr;                           \/* is this an XPointer context? *\/\n+    xmlNodePtr here;                    \/* for here() *\/\n+    xmlNodePtr origin;                  \/* for origin() *\/\n@@ -325,1 +325,1 @@\n-    xmlHashTablePtr nsHash;     \/* The namespaces hash table *\/\n+    xmlHashTablePtr nsHash;             \/* The namespaces hash table *\/\n@@ -327,1 +327,1 @@\n-    void *varLookupData;        \/* variable lookup data *\/\n+    void *varLookupData;                \/* variable lookup data *\/\n@@ -338,1 +338,1 @@\n-    void *funcLookupData;       \/* function lookup data *\/\n+    void *funcLookupData;               \/* function lookup data *\/\n@@ -341,2 +341,2 @@\n-    xmlNsPtr *tmpNsList;        \/* Array of namespaces *\/\n-    int tmpNsNr;            \/* number of namespaces in scope *\/\n+    xmlNsPtr *tmpNsList;                \/* Array of namespaces *\/\n+    int tmpNsNr;                        \/* number of namespaces in scope *\/\n@@ -347,2 +347,2 @@\n-    xmlError lastError;         \/* the last error *\/\n-    xmlNodePtr debugNode;       \/* the source node XSLT *\/\n+    xmlError lastError;                 \/* the last error *\/\n+    xmlNodePtr debugNode;               \/* the source node XSLT *\/\n@@ -351,1 +351,1 @@\n-    xmlDictPtr dict;            \/* dictionary if any *\/\n+    xmlDictPtr dict;                    \/* dictionary if any *\/\n@@ -353,1 +353,1 @@\n-    int flags;              \/* flags to control compilation *\/\n+    int flags;                          \/* flags to control compilation *\/\n@@ -378,2 +378,2 @@\n-    const xmlChar *cur;         \/* the current char being parsed *\/\n-    const xmlChar *base;            \/* the full expression *\/\n+    const xmlChar *cur;                 \/* the current char being parsed *\/\n+    const xmlChar *base;                        \/* the full expression *\/\n@@ -381,1 +381,1 @@\n-    int error;              \/* error code *\/\n+    int error;                          \/* error code *\/\n@@ -383,5 +383,5 @@\n-    xmlXPathContextPtr  context;    \/* the evaluation context *\/\n-    xmlXPathObjectPtr     value;    \/* the current value *\/\n-    int                 valueNr;    \/* number of values stacked *\/\n-    int                valueMax;    \/* max number of values stacked *\/\n-    xmlXPathObjectPtr *valueTab;    \/* stack of values *\/\n+    xmlXPathContextPtr  context;        \/* the evaluation context *\/\n+    xmlXPathObjectPtr     value;        \/* the current value *\/\n+    int                 valueNr;        \/* number of values stacked *\/\n+    int                valueMax;        \/* max number of values stacked *\/\n+    xmlXPathObjectPtr *valueTab;        \/* stack of values *\/\n@@ -389,3 +389,3 @@\n-    xmlXPathCompExprPtr comp;       \/* the precompiled expression *\/\n-    int xptr;               \/* it this an XPointer expression *\/\n-    xmlNodePtr         ancestor;    \/* used for walking preceding axis *\/\n+    xmlXPathCompExprPtr comp;           \/* the precompiled expression *\/\n+    int xptr;                           \/* it this an XPointer expression *\/\n+    xmlNodePtr         ancestor;        \/* used for walking preceding axis *\/\n@@ -397,3 +397,3 @@\n- *                                  *\n- *          Public API                  *\n- *                                  *\n+ *                                                                      *\n+ *                      Public API                                      *\n+ *                                                                      *\n@@ -430,5 +430,5 @@\n-#define xmlXPathNodeSetItem(ns, index)              \\\n-        ((((ns) != NULL) &&             \\\n-          ((index) >= 0) && ((index) < (ns)->nodeNr)) ? \\\n-         (ns)->nodeTab[(index)]             \\\n-         : NULL)\n+#define xmlXPathNodeSetItem(ns, index)                          \\\n+                ((((ns) != NULL) &&                             \\\n+                  ((index) >= 0) && ((index) < (ns)->nodeNr)) ? \\\n+                 (ns)->nodeTab[(index)]                         \\\n+                 : NULL)\n@@ -448,1 +448,1 @@\n-            xmlXPathFreeObject      (xmlXPathObjectPtr obj);\n+                    xmlXPathFreeObject          (xmlXPathObjectPtr obj);\n@@ -450,1 +450,1 @@\n-            xmlXPathNodeSetCreate   (xmlNodePtr val);\n+                    xmlXPathNodeSetCreate       (xmlNodePtr val);\n@@ -452,1 +452,1 @@\n-            xmlXPathFreeNodeSetList (xmlXPathObjectPtr obj);\n+                    xmlXPathFreeNodeSetList     (xmlXPathObjectPtr obj);\n@@ -454,1 +454,1 @@\n-            xmlXPathFreeNodeSet     (xmlNodeSetPtr obj);\n+                    xmlXPathFreeNodeSet         (xmlNodeSetPtr obj);\n@@ -456,1 +456,1 @@\n-            xmlXPathObjectCopy      (xmlXPathObjectPtr val);\n+                    xmlXPathObjectCopy          (xmlXPathObjectPtr val);\n@@ -458,2 +458,2 @@\n-            xmlXPathCmpNodes        (xmlNodePtr node1,\n-                         xmlNodePtr node2);\n+                    xmlXPathCmpNodes            (xmlNodePtr node1,\n+                                                 xmlNodePtr node2);\n@@ -464,1 +464,1 @@\n-            xmlXPathCastNumberToBoolean (double val);\n+                    xmlXPathCastNumberToBoolean (double val);\n@@ -466,1 +466,1 @@\n-            xmlXPathCastStringToBoolean (const xmlChar * val);\n+                    xmlXPathCastStringToBoolean (const xmlChar * val);\n@@ -468,1 +468,1 @@\n-            xmlXPathCastNodeSetToBoolean(xmlNodeSetPtr ns);\n+                    xmlXPathCastNodeSetToBoolean(xmlNodeSetPtr ns);\n@@ -470,1 +470,1 @@\n-            xmlXPathCastToBoolean   (xmlXPathObjectPtr val);\n+                    xmlXPathCastToBoolean       (xmlXPathObjectPtr val);\n@@ -473,1 +473,1 @@\n-            xmlXPathCastBooleanToNumber (int val);\n+                    xmlXPathCastBooleanToNumber (int val);\n@@ -475,1 +475,1 @@\n-            xmlXPathCastStringToNumber  (const xmlChar * val);\n+                    xmlXPathCastStringToNumber  (const xmlChar * val);\n@@ -477,1 +477,1 @@\n-            xmlXPathCastNodeToNumber    (xmlNodePtr node);\n+                    xmlXPathCastNodeToNumber    (xmlNodePtr node);\n@@ -479,1 +479,1 @@\n-            xmlXPathCastNodeSetToNumber (xmlNodeSetPtr ns);\n+                    xmlXPathCastNodeSetToNumber (xmlNodeSetPtr ns);\n@@ -481,1 +481,1 @@\n-            xmlXPathCastToNumber    (xmlXPathObjectPtr val);\n+                    xmlXPathCastToNumber        (xmlXPathObjectPtr val);\n@@ -484,1 +484,1 @@\n-            xmlXPathCastBooleanToString (int val);\n+                    xmlXPathCastBooleanToString (int val);\n@@ -486,1 +486,1 @@\n-            xmlXPathCastNumberToString  (double val);\n+                    xmlXPathCastNumberToString  (double val);\n@@ -488,1 +488,1 @@\n-            xmlXPathCastNodeToString    (xmlNodePtr node);\n+                    xmlXPathCastNodeToString    (xmlNodePtr node);\n@@ -490,1 +490,1 @@\n-            xmlXPathCastNodeSetToString (xmlNodeSetPtr ns);\n+                    xmlXPathCastNodeSetToString (xmlNodeSetPtr ns);\n@@ -492,1 +492,1 @@\n-            xmlXPathCastToString    (xmlXPathObjectPtr val);\n+                    xmlXPathCastToString        (xmlXPathObjectPtr val);\n@@ -495,1 +495,1 @@\n-            xmlXPathConvertBoolean  (xmlXPathObjectPtr val);\n+                    xmlXPathConvertBoolean      (xmlXPathObjectPtr val);\n@@ -497,1 +497,1 @@\n-            xmlXPathConvertNumber   (xmlXPathObjectPtr val);\n+                    xmlXPathConvertNumber       (xmlXPathObjectPtr val);\n@@ -499,1 +499,1 @@\n-            xmlXPathConvertString   (xmlXPathObjectPtr val);\n+                    xmlXPathConvertString       (xmlXPathObjectPtr val);\n@@ -505,1 +505,1 @@\n-            xmlXPathNewContext      (xmlDocPtr doc);\n+                    xmlXPathNewContext          (xmlDocPtr doc);\n@@ -507,1 +507,1 @@\n-            xmlXPathFreeContext     (xmlXPathContextPtr ctxt);\n+                    xmlXPathFreeContext         (xmlXPathContextPtr ctxt);\n@@ -509,4 +509,4 @@\n-            xmlXPathContextSetCache(xmlXPathContextPtr ctxt,\n-                            int active,\n-                        int value,\n-                        int options);\n+                    xmlXPathContextSetCache(xmlXPathContextPtr ctxt,\n+                                            int active,\n+                                            int value,\n+                                            int options);\n@@ -517,1 +517,1 @@\n-            xmlXPathOrderDocElems   (xmlDocPtr doc);\n+                    xmlXPathOrderDocElems       (xmlDocPtr doc);\n@@ -519,2 +519,2 @@\n-            xmlXPathSetContextNode  (xmlNodePtr node,\n-                         xmlXPathContextPtr ctx);\n+                    xmlXPathSetContextNode      (xmlNodePtr node,\n+                                                 xmlXPathContextPtr ctx);\n@@ -522,3 +522,3 @@\n-            xmlXPathNodeEval        (xmlNodePtr node,\n-                         const xmlChar *str,\n-                         xmlXPathContextPtr ctx);\n+                    xmlXPathNodeEval            (xmlNodePtr node,\n+                                                 const xmlChar *str,\n+                                                 xmlXPathContextPtr ctx);\n@@ -526,2 +526,2 @@\n-            xmlXPathEval        (const xmlChar *str,\n-                         xmlXPathContextPtr ctx);\n+                    xmlXPathEval                (const xmlChar *str,\n+                                                 xmlXPathContextPtr ctx);\n@@ -529,2 +529,2 @@\n-            xmlXPathEvalExpression  (const xmlChar *str,\n-                         xmlXPathContextPtr ctxt);\n+                    xmlXPathEvalExpression      (const xmlChar *str,\n+                                                 xmlXPathContextPtr ctxt);\n@@ -532,2 +532,2 @@\n-            xmlXPathEvalPredicate   (xmlXPathContextPtr ctxt,\n-                         xmlXPathObjectPtr res);\n+                    xmlXPathEvalPredicate       (xmlXPathContextPtr ctxt,\n+                                                 xmlXPathObjectPtr res);\n@@ -538,1 +538,1 @@\n-            xmlXPathCompile     (const xmlChar *str);\n+                    xmlXPathCompile             (const xmlChar *str);\n@@ -540,2 +540,2 @@\n-            xmlXPathCtxtCompile     (xmlXPathContextPtr ctxt,\n-                         const xmlChar *str);\n+                    xmlXPathCtxtCompile         (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *str);\n@@ -543,2 +543,2 @@\n-            xmlXPathCompiledEval    (xmlXPathCompExprPtr comp,\n-                         xmlXPathContextPtr ctx);\n+                    xmlXPathCompiledEval        (xmlXPathCompExprPtr comp,\n+                                                 xmlXPathContextPtr ctx);\n@@ -546,2 +546,2 @@\n-            xmlXPathCompiledEvalToBoolean(xmlXPathCompExprPtr comp,\n-                         xmlXPathContextPtr ctxt);\n+                    xmlXPathCompiledEvalToBoolean(xmlXPathCompExprPtr comp,\n+                                                 xmlXPathContextPtr ctxt);\n@@ -549,1 +549,1 @@\n-            xmlXPathFreeCompExpr    (xmlXPathCompExprPtr comp);\n+                    xmlXPathFreeCompExpr        (xmlXPathCompExprPtr comp);\n@@ -553,1 +553,1 @@\n-            xmlXPathInit        (void);\n+                    xmlXPathInit                (void);\n@@ -555,1 +555,1 @@\n-        xmlXPathIsNaN   (double val);\n+                xmlXPathIsNaN   (double val);\n@@ -557,1 +557,1 @@\n-        xmlXPathIsInf   (double val);\n+                xmlXPathIsInf   (double val);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xpath.h","additions":118,"deletions":118,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -25,3 +25,3 @@\n- *                                  *\n- *          Helpers                     *\n- *                                  *\n+ *                                                                      *\n+ *                      Helpers                                         *\n+ *                                                                      *\n@@ -41,2 +41,2 @@\n-#define xmlXPathSetError(ctxt, err)                 \\\n-    { xmlXPatherror((ctxt), __FILE__, __LINE__, (err));         \\\n+#define xmlXPathSetError(ctxt, err)                                     \\\n+    { xmlXPatherror((ctxt), __FILE__, __LINE__, (err));                 \\\n@@ -51,1 +51,1 @@\n-#define xmlXPathSetArityError(ctxt)                 \\\n+#define xmlXPathSetArityError(ctxt)                                     \\\n@@ -60,1 +60,1 @@\n-#define xmlXPathSetTypeError(ctxt)                  \\\n+#define xmlXPathSetTypeError(ctxt)                                      \\\n@@ -91,1 +91,1 @@\n-#define xmlXPathGetDocument(ctxt)   ((ctxt)->context->doc)\n+#define xmlXPathGetDocument(ctxt)       ((ctxt)->context->doc)\n@@ -104,1 +104,1 @@\n-        xmlXPathPopBoolean  (xmlXPathParserContextPtr ctxt);\n+                xmlXPathPopBoolean      (xmlXPathParserContextPtr ctxt);\n@@ -106,1 +106,1 @@\n-        xmlXPathPopNumber   (xmlXPathParserContextPtr ctxt);\n+                xmlXPathPopNumber       (xmlXPathParserContextPtr ctxt);\n@@ -108,1 +108,1 @@\n-        xmlXPathPopString   (xmlXPathParserContextPtr ctxt);\n+                xmlXPathPopString       (xmlXPathParserContextPtr ctxt);\n@@ -110,1 +110,1 @@\n-        xmlXPathPopNodeSet  (xmlXPathParserContextPtr ctxt);\n+                xmlXPathPopNodeSet      (xmlXPathParserContextPtr ctxt);\n@@ -112,1 +112,1 @@\n-        xmlXPathPopExternal (xmlXPathParserContextPtr ctxt);\n+                xmlXPathPopExternal     (xmlXPathParserContextPtr ctxt);\n@@ -121,1 +121,1 @@\n-#define xmlXPathReturnBoolean(ctxt, val)                \\\n+#define xmlXPathReturnBoolean(ctxt, val)                                \\\n@@ -147,1 +147,1 @@\n-#define xmlXPathReturnNumber(ctxt, val)                 \\\n+#define xmlXPathReturnNumber(ctxt, val)                                 \\\n@@ -157,1 +157,1 @@\n-#define xmlXPathReturnString(ctxt, str)                 \\\n+#define xmlXPathReturnString(ctxt, str)                                 \\\n@@ -166,1 +166,1 @@\n-#define xmlXPathReturnEmptyString(ctxt)                 \\\n+#define xmlXPathReturnEmptyString(ctxt)                                 \\\n@@ -176,1 +176,1 @@\n-#define xmlXPathReturnNodeSet(ctxt, ns)                 \\\n+#define xmlXPathReturnNodeSet(ctxt, ns)                                 \\\n@@ -185,1 +185,1 @@\n-#define xmlXPathReturnEmptyNodeSet(ctxt)                \\\n+#define xmlXPathReturnEmptyNodeSet(ctxt)                                \\\n@@ -195,1 +195,1 @@\n-#define xmlXPathReturnExternal(ctxt, val)               \\\n+#define xmlXPathReturnExternal(ctxt, val)                               \\\n@@ -207,3 +207,3 @@\n-#define xmlXPathStackIsNodeSet(ctxt)                    \\\n-    (((ctxt)->value != NULL)                        \\\n-     && (((ctxt)->value->type == XPATH_NODESET)             \\\n+#define xmlXPathStackIsNodeSet(ctxt)                                    \\\n+    (((ctxt)->value != NULL)                                            \\\n+     && (((ctxt)->value->type == XPATH_NODESET)                         \\\n@@ -222,2 +222,2 @@\n-#define xmlXPathStackIsExternal(ctxt)                   \\\n-    ((ctxt->value != NULL) && (ctxt->value->type == XPATH_USERS))\n+#define xmlXPathStackIsExternal(ctxt)                                   \\\n+        ((ctxt->value != NULL) && (ctxt->value->type == XPATH_USERS))\n@@ -231,1 +231,1 @@\n-#define xmlXPathEmptyNodeSet(ns)                    \\\n+#define xmlXPathEmptyNodeSet(ns)                                        \\\n@@ -239,1 +239,1 @@\n-#define CHECK_ERROR                         \\\n+#define CHECK_ERROR                                                     \\\n@@ -247,1 +247,1 @@\n-#define CHECK_ERROR0                            \\\n+#define CHECK_ERROR0                                                    \\\n@@ -256,1 +256,1 @@\n-#define XP_ERROR(X)                         \\\n+#define XP_ERROR(X)                                                     \\\n@@ -265,1 +265,1 @@\n-#define XP_ERROR0(X)                            \\\n+#define XP_ERROR0(X)                                                    \\\n@@ -275,2 +275,2 @@\n-#define CHECK_TYPE(typeval)                     \\\n-    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))    \\\n+#define CHECK_TYPE(typeval)                                             \\\n+    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))        \\\n@@ -286,2 +286,2 @@\n-#define CHECK_TYPE0(typeval)                        \\\n-    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))    \\\n+#define CHECK_TYPE0(typeval)                                            \\\n+    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))        \\\n@@ -296,5 +296,5 @@\n-#define CHECK_ARITY(x)                          \\\n-    if (ctxt == NULL) return;                       \\\n-    if (nargs != (x))                           \\\n-        XP_ERROR(XPATH_INVALID_ARITY);                  \\\n-    if (ctxt->valueNr < ctxt->valueFrame + (x))             \\\n+#define CHECK_ARITY(x)                                                  \\\n+    if (ctxt == NULL) return;                                           \\\n+    if (nargs != (x))                                                   \\\n+        XP_ERROR(XPATH_INVALID_ARITY);                                  \\\n+    if (ctxt->valueNr < ctxt->valueFrame + (x))                         \\\n@@ -308,1 +308,1 @@\n-#define CAST_TO_STRING                          \\\n+#define CAST_TO_STRING                                                  \\\n@@ -317,1 +317,1 @@\n-#define CAST_TO_NUMBER                          \\\n+#define CAST_TO_NUMBER                                                  \\\n@@ -326,1 +326,1 @@\n-#define CAST_TO_BOOLEAN                         \\\n+#define CAST_TO_BOOLEAN                                                 \\\n@@ -335,3 +335,3 @@\n-    xmlXPathRegisterVariableLookup  (xmlXPathContextPtr ctxt,\n-                     xmlXPathVariableLookupFunc f,\n-                     void *data);\n+        xmlXPathRegisterVariableLookup  (xmlXPathContextPtr ctxt,\n+                                         xmlXPathVariableLookupFunc f,\n+                                         void *data);\n@@ -344,3 +344,3 @@\n-        xmlXPathRegisterFuncLookup  (xmlXPathContextPtr ctxt,\n-                     xmlXPathFuncLookupFunc f,\n-                     void *funcCtxt);\n+            xmlXPathRegisterFuncLookup  (xmlXPathContextPtr ctxt,\n+                                         xmlXPathFuncLookupFunc f,\n+                                         void *funcCtxt);\n@@ -352,4 +352,4 @@\n-        xmlXPatherror   (xmlXPathParserContextPtr ctxt,\n-                 const char *file,\n-                 int line,\n-                 int no);\n+                xmlXPatherror   (xmlXPathParserContextPtr ctxt,\n+                                 const char *file,\n+                                 int line,\n+                                 int no);\n@@ -358,2 +358,2 @@\n-        xmlXPathErr (xmlXPathParserContextPtr ctxt,\n-                 int error);\n+                xmlXPathErr     (xmlXPathParserContextPtr ctxt,\n+                                 int error);\n@@ -363,3 +363,3 @@\n-        xmlXPathDebugDumpObject (FILE *output,\n-                     xmlXPathObjectPtr cur,\n-                     int depth);\n+                xmlXPathDebugDumpObject (FILE *output,\n+                                         xmlXPathObjectPtr cur,\n+                                         int depth);\n@@ -367,3 +367,3 @@\n-        xmlXPathDebugDumpCompExpr(FILE *output,\n-                     xmlXPathCompExprPtr comp,\n-                     int depth);\n+            xmlXPathDebugDumpCompExpr(FILE *output,\n+                                         xmlXPathCompExprPtr comp,\n+                                         int depth);\n@@ -375,2 +375,2 @@\n-        xmlXPathNodeSetContains     (xmlNodeSetPtr cur,\n-                         xmlNodePtr val);\n+                xmlXPathNodeSetContains         (xmlNodeSetPtr cur,\n+                                                 xmlNodePtr val);\n@@ -378,2 +378,2 @@\n-        xmlXPathDifference      (xmlNodeSetPtr nodes1,\n-                         xmlNodeSetPtr nodes2);\n+                xmlXPathDifference              (xmlNodeSetPtr nodes1,\n+                                                 xmlNodeSetPtr nodes2);\n@@ -381,2 +381,2 @@\n-        xmlXPathIntersection        (xmlNodeSetPtr nodes1,\n-                         xmlNodeSetPtr nodes2);\n+                xmlXPathIntersection            (xmlNodeSetPtr nodes1,\n+                                                 xmlNodeSetPtr nodes2);\n@@ -385,1 +385,1 @@\n-        xmlXPathDistinctSorted      (xmlNodeSetPtr nodes);\n+                xmlXPathDistinctSorted          (xmlNodeSetPtr nodes);\n@@ -387,1 +387,1 @@\n-        xmlXPathDistinct        (xmlNodeSetPtr nodes);\n+                xmlXPathDistinct                (xmlNodeSetPtr nodes);\n@@ -390,2 +390,2 @@\n-        xmlXPathHasSameNodes        (xmlNodeSetPtr nodes1,\n-                         xmlNodeSetPtr nodes2);\n+                xmlXPathHasSameNodes            (xmlNodeSetPtr nodes1,\n+                                                 xmlNodeSetPtr nodes2);\n@@ -394,2 +394,2 @@\n-        xmlXPathNodeLeadingSorted   (xmlNodeSetPtr nodes,\n-                         xmlNodePtr node);\n+                xmlXPathNodeLeadingSorted       (xmlNodeSetPtr nodes,\n+                                                 xmlNodePtr node);\n@@ -397,2 +397,2 @@\n-        xmlXPathLeadingSorted       (xmlNodeSetPtr nodes1,\n-                         xmlNodeSetPtr nodes2);\n+                xmlXPathLeadingSorted           (xmlNodeSetPtr nodes1,\n+                                                 xmlNodeSetPtr nodes2);\n@@ -400,2 +400,2 @@\n-        xmlXPathNodeLeading     (xmlNodeSetPtr nodes,\n-                         xmlNodePtr node);\n+                xmlXPathNodeLeading             (xmlNodeSetPtr nodes,\n+                                                 xmlNodePtr node);\n@@ -403,2 +403,2 @@\n-        xmlXPathLeading         (xmlNodeSetPtr nodes1,\n-                         xmlNodeSetPtr nodes2);\n+                xmlXPathLeading                 (xmlNodeSetPtr nodes1,\n+                                                 xmlNodeSetPtr nodes2);\n@@ -407,2 +407,2 @@\n-        xmlXPathNodeTrailingSorted  (xmlNodeSetPtr nodes,\n-                         xmlNodePtr node);\n+                xmlXPathNodeTrailingSorted      (xmlNodeSetPtr nodes,\n+                                                 xmlNodePtr node);\n@@ -410,2 +410,2 @@\n-        xmlXPathTrailingSorted      (xmlNodeSetPtr nodes1,\n-                         xmlNodeSetPtr nodes2);\n+                xmlXPathTrailingSorted          (xmlNodeSetPtr nodes1,\n+                                                 xmlNodeSetPtr nodes2);\n@@ -413,2 +413,2 @@\n-        xmlXPathNodeTrailing        (xmlNodeSetPtr nodes,\n-                         xmlNodePtr node);\n+                xmlXPathNodeTrailing            (xmlNodeSetPtr nodes,\n+                                                 xmlNodePtr node);\n@@ -416,2 +416,2 @@\n-        xmlXPathTrailing        (xmlNodeSetPtr nodes1,\n-                         xmlNodeSetPtr nodes2);\n+                xmlXPathTrailing                (xmlNodeSetPtr nodes1,\n+                                                 xmlNodeSetPtr nodes2);\n@@ -425,3 +425,3 @@\n-        xmlXPathRegisterNs      (xmlXPathContextPtr ctxt,\n-                         const xmlChar *prefix,\n-                         const xmlChar *ns_uri);\n+                xmlXPathRegisterNs              (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *prefix,\n+                                                 const xmlChar *ns_uri);\n@@ -429,2 +429,2 @@\n-        xmlXPathNsLookup        (xmlXPathContextPtr ctxt,\n-                         const xmlChar *prefix);\n+                xmlXPathNsLookup                (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *prefix);\n@@ -432,1 +432,1 @@\n-        xmlXPathRegisteredNsCleanup (xmlXPathContextPtr ctxt);\n+                xmlXPathRegisteredNsCleanup     (xmlXPathContextPtr ctxt);\n@@ -435,3 +435,3 @@\n-        xmlXPathRegisterFunc        (xmlXPathContextPtr ctxt,\n-                         const xmlChar *name,\n-                         xmlXPathFunction f);\n+                xmlXPathRegisterFunc            (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *name,\n+                                                 xmlXPathFunction f);\n@@ -439,4 +439,4 @@\n-        xmlXPathRegisterFuncNS      (xmlXPathContextPtr ctxt,\n-                         const xmlChar *name,\n-                         const xmlChar *ns_uri,\n-                         xmlXPathFunction f);\n+                xmlXPathRegisterFuncNS          (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns_uri,\n+                                                 xmlXPathFunction f);\n@@ -444,3 +444,3 @@\n-        xmlXPathRegisterVariable    (xmlXPathContextPtr ctxt,\n-                         const xmlChar *name,\n-                         xmlXPathObjectPtr value);\n+                xmlXPathRegisterVariable        (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *name,\n+                                                 xmlXPathObjectPtr value);\n@@ -448,4 +448,4 @@\n-        xmlXPathRegisterVariableNS  (xmlXPathContextPtr ctxt,\n-                         const xmlChar *name,\n-                         const xmlChar *ns_uri,\n-                         xmlXPathObjectPtr value);\n+                xmlXPathRegisterVariableNS      (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns_uri,\n+                                                 xmlXPathObjectPtr value);\n@@ -453,2 +453,2 @@\n-        xmlXPathFunctionLookup      (xmlXPathContextPtr ctxt,\n-                         const xmlChar *name);\n+                xmlXPathFunctionLookup          (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *name);\n@@ -456,3 +456,3 @@\n-        xmlXPathFunctionLookupNS    (xmlXPathContextPtr ctxt,\n-                         const xmlChar *name,\n-                         const xmlChar *ns_uri);\n+                xmlXPathFunctionLookupNS        (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns_uri);\n@@ -460,1 +460,1 @@\n-        xmlXPathRegisteredFuncsCleanup  (xmlXPathContextPtr ctxt);\n+                xmlXPathRegisteredFuncsCleanup  (xmlXPathContextPtr ctxt);\n@@ -462,2 +462,2 @@\n-        xmlXPathVariableLookup      (xmlXPathContextPtr ctxt,\n-                         const xmlChar *name);\n+                xmlXPathVariableLookup          (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *name);\n@@ -465,3 +465,3 @@\n-        xmlXPathVariableLookupNS    (xmlXPathContextPtr ctxt,\n-                         const xmlChar *name,\n-                         const xmlChar *ns_uri);\n+                xmlXPathVariableLookupNS        (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns_uri);\n@@ -469,1 +469,1 @@\n-        xmlXPathRegisteredVariablesCleanup(xmlXPathContextPtr ctxt);\n+                xmlXPathRegisteredVariablesCleanup(xmlXPathContextPtr ctxt);\n@@ -475,2 +475,2 @@\n-          xmlXPathNewParserContext  (const xmlChar *str,\n-                         xmlXPathContextPtr ctxt);\n+                  xmlXPathNewParserContext      (const xmlChar *str,\n+                                                 xmlXPathContextPtr ctxt);\n@@ -478,1 +478,1 @@\n-        xmlXPathFreeParserContext   (xmlXPathParserContextPtr ctxt);\n+                xmlXPathFreeParserContext       (xmlXPathParserContextPtr ctxt);\n@@ -482,1 +482,1 @@\n-        valuePop            (xmlXPathParserContextPtr ctxt);\n+                valuePop                        (xmlXPathParserContextPtr ctxt);\n@@ -484,2 +484,2 @@\n-        valuePush           (xmlXPathParserContextPtr ctxt,\n-                         xmlXPathObjectPtr value);\n+                valuePush                       (xmlXPathParserContextPtr ctxt,\n+                                                 xmlXPathObjectPtr value);\n@@ -488,1 +488,1 @@\n-        xmlXPathNewString       (const xmlChar *val);\n+                xmlXPathNewString               (const xmlChar *val);\n@@ -490,1 +490,1 @@\n-        xmlXPathNewCString      (const char *val);\n+                xmlXPathNewCString              (const char *val);\n@@ -492,1 +492,1 @@\n-        xmlXPathWrapString      (xmlChar *val);\n+                xmlXPathWrapString              (xmlChar *val);\n@@ -494,1 +494,1 @@\n-        xmlXPathWrapCString     (char * val);\n+                xmlXPathWrapCString             (char * val);\n@@ -496,1 +496,1 @@\n-        xmlXPathNewFloat        (double val);\n+                xmlXPathNewFloat                (double val);\n@@ -498,1 +498,1 @@\n-        xmlXPathNewBoolean      (int val);\n+                xmlXPathNewBoolean              (int val);\n@@ -500,1 +500,1 @@\n-        xmlXPathNewNodeSet      (xmlNodePtr val);\n+                xmlXPathNewNodeSet              (xmlNodePtr val);\n@@ -502,1 +502,1 @@\n-        xmlXPathNewValueTree        (xmlNodePtr val);\n+                xmlXPathNewValueTree            (xmlNodePtr val);\n@@ -504,2 +504,2 @@\n-        xmlXPathNodeSetAdd      (xmlNodeSetPtr cur,\n-                         xmlNodePtr val);\n+                xmlXPathNodeSetAdd              (xmlNodeSetPtr cur,\n+                                                 xmlNodePtr val);\n@@ -507,2 +507,2 @@\n-        xmlXPathNodeSetAddUnique    (xmlNodeSetPtr cur,\n-                         xmlNodePtr val);\n+                xmlXPathNodeSetAddUnique        (xmlNodeSetPtr cur,\n+                                                 xmlNodePtr val);\n@@ -510,3 +510,3 @@\n-        xmlXPathNodeSetAddNs        (xmlNodeSetPtr cur,\n-                         xmlNodePtr node,\n-                         xmlNsPtr ns);\n+                xmlXPathNodeSetAddNs            (xmlNodeSetPtr cur,\n+                                                 xmlNodePtr node,\n+                                                 xmlNsPtr ns);\n@@ -514,1 +514,1 @@\n-        xmlXPathNodeSetSort     (xmlNodeSetPtr set);\n+                xmlXPathNodeSetSort             (xmlNodeSetPtr set);\n@@ -517,1 +517,1 @@\n-        xmlXPathRoot            (xmlXPathParserContextPtr ctxt);\n+                xmlXPathRoot                    (xmlXPathParserContextPtr ctxt);\n@@ -519,1 +519,1 @@\n-        xmlXPathEvalExpr        (xmlXPathParserContextPtr ctxt);\n+                xmlXPathEvalExpr                (xmlXPathParserContextPtr ctxt);\n@@ -521,1 +521,1 @@\n-        xmlXPathParseName       (xmlXPathParserContextPtr ctxt);\n+                xmlXPathParseName               (xmlXPathParserContextPtr ctxt);\n@@ -523,1 +523,1 @@\n-        xmlXPathParseNCName     (xmlXPathParserContextPtr ctxt);\n+                xmlXPathParseNCName             (xmlXPathParserContextPtr ctxt);\n@@ -529,1 +529,1 @@\n-        xmlXPathStringEvalNumber    (const xmlChar *str);\n+                xmlXPathStringEvalNumber        (const xmlChar *str);\n@@ -531,2 +531,2 @@\n-        xmlXPathEvaluatePredicateResult (xmlXPathParserContextPtr ctxt,\n-                         xmlXPathObjectPtr res);\n+                xmlXPathEvaluatePredicateResult (xmlXPathParserContextPtr ctxt,\n+                                                 xmlXPathObjectPtr res);\n@@ -534,1 +534,1 @@\n-        xmlXPathRegisterAllFunctions    (xmlXPathContextPtr ctxt);\n+                xmlXPathRegisterAllFunctions    (xmlXPathContextPtr ctxt);\n@@ -536,2 +536,2 @@\n-        xmlXPathNodeSetMerge        (xmlNodeSetPtr val1,\n-                         xmlNodeSetPtr val2);\n+                xmlXPathNodeSetMerge            (xmlNodeSetPtr val1,\n+                                                 xmlNodeSetPtr val2);\n@@ -539,2 +539,2 @@\n-        xmlXPathNodeSetDel      (xmlNodeSetPtr cur,\n-                         xmlNodePtr val);\n+                xmlXPathNodeSetDel              (xmlNodeSetPtr cur,\n+                                                 xmlNodePtr val);\n@@ -542,2 +542,2 @@\n-        xmlXPathNodeSetRemove       (xmlNodeSetPtr cur,\n-                         int val);\n+                xmlXPathNodeSetRemove           (xmlNodeSetPtr cur,\n+                                                 int val);\n@@ -545,1 +545,1 @@\n-        xmlXPathNewNodeSetList      (xmlNodeSetPtr val);\n+                xmlXPathNewNodeSetList          (xmlNodeSetPtr val);\n@@ -547,1 +547,1 @@\n-        xmlXPathWrapNodeSet     (xmlNodeSetPtr val);\n+                xmlXPathWrapNodeSet             (xmlNodeSetPtr val);\n@@ -549,1 +549,1 @@\n-        xmlXPathWrapExternal        (void *val);\n+                xmlXPathWrapExternal            (void *val);\n@@ -567,1 +567,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -569,1 +569,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -571,1 +571,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -573,1 +573,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -575,1 +575,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -577,1 +577,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -579,1 +579,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -581,1 +581,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -583,1 +583,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -585,1 +585,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -587,1 +587,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -589,1 +589,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -591,1 +591,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xpathInternals.h","additions":170,"deletions":170,"binary":false,"changes":340,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-    int locNr;            \/* number of locations in the set *\/\n-    int locMax;           \/* size of the array as allocated *\/\n+    int locNr;                \/* number of locations in the set *\/\n+    int locMax;               \/* size of the array as allocated *\/\n@@ -47,1 +47,1 @@\n-            xmlXPtrLocationSetCreate    (xmlXPathObjectPtr val);\n+                    xmlXPtrLocationSetCreate    (xmlXPathObjectPtr val);\n@@ -49,1 +49,1 @@\n-            xmlXPtrFreeLocationSet  (xmlLocationSetPtr obj);\n+                    xmlXPtrFreeLocationSet      (xmlLocationSetPtr obj);\n@@ -51,2 +51,2 @@\n-            xmlXPtrLocationSetMerge (xmlLocationSetPtr val1,\n-                         xmlLocationSetPtr val2);\n+                    xmlXPtrLocationSetMerge     (xmlLocationSetPtr val1,\n+                                                 xmlLocationSetPtr val2);\n@@ -54,4 +54,4 @@\n-            xmlXPtrNewRange     (xmlNodePtr start,\n-                         int startindex,\n-                         xmlNodePtr end,\n-                         int endindex);\n+                    xmlXPtrNewRange             (xmlNodePtr start,\n+                                                 int startindex,\n+                                                 xmlNodePtr end,\n+                                                 int endindex);\n@@ -59,2 +59,2 @@\n-            xmlXPtrNewRangePoints   (xmlXPathObjectPtr start,\n-                         xmlXPathObjectPtr end);\n+                    xmlXPtrNewRangePoints       (xmlXPathObjectPtr start,\n+                                                 xmlXPathObjectPtr end);\n@@ -62,2 +62,2 @@\n-            xmlXPtrNewRangeNodePoint    (xmlNodePtr start,\n-                         xmlXPathObjectPtr end);\n+                    xmlXPtrNewRangeNodePoint    (xmlNodePtr start,\n+                                                 xmlXPathObjectPtr end);\n@@ -65,2 +65,2 @@\n-            xmlXPtrNewRangePointNode    (xmlXPathObjectPtr start,\n-                         xmlNodePtr end);\n+                    xmlXPtrNewRangePointNode    (xmlXPathObjectPtr start,\n+                                                 xmlNodePtr end);\n@@ -68,2 +68,2 @@\n-            xmlXPtrNewRangeNodes    (xmlNodePtr start,\n-                         xmlNodePtr end);\n+                    xmlXPtrNewRangeNodes        (xmlNodePtr start,\n+                                                 xmlNodePtr end);\n@@ -71,2 +71,2 @@\n-            xmlXPtrNewLocationSetNodes  (xmlNodePtr start,\n-                         xmlNodePtr end);\n+                    xmlXPtrNewLocationSetNodes  (xmlNodePtr start,\n+                                                 xmlNodePtr end);\n@@ -74,1 +74,1 @@\n-            xmlXPtrNewLocationSetNodeSet(xmlNodeSetPtr set);\n+                    xmlXPtrNewLocationSetNodeSet(xmlNodeSetPtr set);\n@@ -76,2 +76,2 @@\n-            xmlXPtrNewRangeNodeObject   (xmlNodePtr start,\n-                         xmlXPathObjectPtr end);\n+                    xmlXPtrNewRangeNodeObject   (xmlNodePtr start,\n+                                                 xmlXPathObjectPtr end);\n@@ -79,1 +79,1 @@\n-            xmlXPtrNewCollapsedRange    (xmlNodePtr start);\n+                    xmlXPtrNewCollapsedRange    (xmlNodePtr start);\n@@ -81,2 +81,2 @@\n-            xmlXPtrLocationSetAdd   (xmlLocationSetPtr cur,\n-                         xmlXPathObjectPtr val);\n+                    xmlXPtrLocationSetAdd       (xmlLocationSetPtr cur,\n+                                                 xmlXPathObjectPtr val);\n@@ -84,1 +84,1 @@\n-            xmlXPtrWrapLocationSet  (xmlLocationSetPtr val);\n+                    xmlXPtrWrapLocationSet      (xmlLocationSetPtr val);\n@@ -86,2 +86,2 @@\n-            xmlXPtrLocationSetDel   (xmlLocationSetPtr cur,\n-                         xmlXPathObjectPtr val);\n+                    xmlXPtrLocationSetDel       (xmlLocationSetPtr cur,\n+                                                 xmlXPathObjectPtr val);\n@@ -89,2 +89,2 @@\n-            xmlXPtrLocationSetRemove    (xmlLocationSetPtr cur,\n-                         int val);\n+                    xmlXPtrLocationSetRemove    (xmlLocationSetPtr cur,\n+                                                 int val);\n@@ -96,3 +96,3 @@\n-            xmlXPtrNewContext       (xmlDocPtr doc,\n-                         xmlNodePtr here,\n-                         xmlNodePtr origin);\n+                    xmlXPtrNewContext           (xmlDocPtr doc,\n+                                                 xmlNodePtr here,\n+                                                 xmlNodePtr origin);\n@@ -100,2 +100,2 @@\n-            xmlXPtrEval         (const xmlChar *str,\n-                         xmlXPathContextPtr ctx);\n+                    xmlXPtrEval                 (const xmlChar *str,\n+                                                 xmlXPathContextPtr ctx);\n@@ -103,2 +103,2 @@\n-            xmlXPtrRangeToFunction  (xmlXPathParserContextPtr ctxt,\n-                         int nargs);\n+                    xmlXPtrRangeToFunction      (xmlXPathParserContextPtr ctxt,\n+                                                 int nargs);\n@@ -106,1 +106,1 @@\n-            xmlXPtrBuildNodeList    (xmlXPathObjectPtr obj);\n+                    xmlXPtrBuildNodeList        (xmlXPathObjectPtr obj);\n@@ -108,1 +108,1 @@\n-            xmlXPtrEvalRangePredicate   (xmlXPathParserContextPtr ctxt);\n+                    xmlXPtrEvalRangePredicate   (xmlXPathParserContextPtr ctxt);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xpointer.h","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    : ((_fpclass(d) == _FPCLASS_NINF) ? -1 : 0))\n+        : ((_fpclass(d) == _FPCLASS_NINF) ? -1 : 0))\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/win32config.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-        printf(\"*** You need a version of libxml newer than %d.%d.%d. The latest version of\\n\",\n+        printf(\"*** You need a version of libxml newer than %d.%d.%d.\\n\",\n@@ -127,1 +127,0 @@\n-        printf(\"*** libxml is always available from ftp:\/\/ftp.xmlsoft.org.\\n\");\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/libxml.m4","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n-Source: ftp:\/\/xmlsoft.org\/libxml2\/libxml2-%{version}.tar.gz\n+Source: https:\/\/download.gnome.org\/sources\/libxml2\/@LIBXML_MAJOR_VERSION@.@LIBXML_MINOR_VERSION@\/libxml2-%{version}.tar.xz\n@@ -18,1 +18,1 @@\n-URL: http:\/\/xmlsoft.org\/\n+URL: https:\/\/gitlab.gnome.org\/GNOME\/libxml2\n@@ -144,1 +144,1 @@\n-%doc AUTHORS NEWS README Copyright TODO\n+%doc NEWS README.md Copyright TODO\n@@ -157,1 +157,1 @@\n-%doc AUTHORS NEWS README Copyright\n+%doc NEWS README.md Copyright\n@@ -208,1 +208,1 @@\n-- upstream release @VERSION@ see http:\/\/xmlsoft.org\/news.html\n+- upstream release @VERSION@\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/libxml.spec.in","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-Version: 2.9.12\n+Version: 2.9.13\n@@ -9,1 +9,1 @@\n-Source: ftp:\/\/xmlsoft.org\/libxml2\/libxml2-%{version}.tar.gz\n+Source: https:\/\/download.gnome.org\/sources\/libxml2\/2.9\/libxml2-%{version}.tar.xz\n@@ -18,1 +18,1 @@\n-URL: http:\/\/xmlsoft.org\/\n+URL: https:\/\/gitlab.gnome.org\/GNOME\/libxml2\n@@ -144,1 +144,1 @@\n-%doc AUTHORS NEWS README Copyright TODO\n+%doc NEWS README.md Copyright TODO\n@@ -157,1 +157,1 @@\n-%doc AUTHORS NEWS README Copyright\n+%doc NEWS README.md Copyright\n@@ -207,2 +207,2 @@\n-* Wed Jun 30 2021 Daniel Veillard <veillard@redhat.com>\n-- upstream release 2.9.12 see http:\/\/xmlsoft.org\/news.html\n+* Tue Mar 22 2022 Daniel Veillard <veillard@redhat.com>\n+- upstream release 2.9.13\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/libxml2.spec","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-    return (0);\n+        return (0);\n@@ -193,1 +193,1 @@\n-                \"Cannot initialize memory for list\");\n+                        \"Cannot initialize memory for list\");\n@@ -202,2 +202,2 @@\n-                \"Cannot initialize memory for sentinel\");\n-    xmlFree(l);\n+                        \"Cannot initialize memory for sentinel\");\n+        xmlFree(l);\n@@ -284,1 +284,1 @@\n-                \"Cannot initialize memory for new link\");\n+                        \"Cannot initialize memory for new link\");\n@@ -316,1 +316,1 @@\n-                \"Cannot initialize memory for new link\");\n+                        \"Cannot initialize memory for new link\");\n@@ -387,1 +387,1 @@\n-    xmlLinkDeallocator(l, lk);\n+        xmlLinkDeallocator(l, lk);\n@@ -553,1 +553,1 @@\n-                \"Cannot initialize memory for new link\");\n+                        \"Cannot initialize memory for new link\");\n@@ -584,1 +584,1 @@\n-                \"Cannot initialize memory for new link\");\n+                        \"Cannot initialize memory for new link\");\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/list.c","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/macos\/src\/XMLTestPrefix.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/macos\/src\/XMLTestPrefix2.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -12,1 +12,0 @@\n-#undef HAVE_LIBZ\n@@ -14,2 +13,0 @@\n-#undef HAVE_ISINF\n-#undef HAVE_ISNAN\n@@ -20,1 +17,0 @@\n-#define HAVE_LIBPTHREAD\n@@ -33,3 +29,0 @@\n-\/* Define if you have the signal function.  *\/\n-#define HAVE_SIGNAL\n-\n@@ -66,3 +59,0 @@\n-\/* Define if you have the <dirent.h> header file.  *\/\n-#define HAVE_DIRENT_H\n-\n@@ -87,3 +77,0 @@\n-\/* Define if you have the <ndir.h> header file.  *\/\n-#define HAVE_NDIR_H\n-\n@@ -108,3 +95,0 @@\n-\/* Define if you have the <sys\/dir.h> header file.  *\/\n-#define HAVE_SYS_DIR_H\n-\n@@ -114,3 +98,0 @@\n-\/* Define if you have the <sys\/ndir.h> header file.  *\/\n-#undef HAVE_SYS_NDIR_H\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/macos\/src\/config-mac.h","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/**************** BEGIN GUSI CONFIGURATION ****************************\r *\r * GUSI Configuration section generated by GUSI Configurator\r * last modified: Wed Oct 31 17:07:45 2001\r *\r * This section will be overwritten by the next run of Configurator.\r *\/\r\r#define GUSI_SOURCE\r#include <GUSIConfig.h>\r#include <sys\/cdefs.h>\r\r\/* Declarations of Socket Factories *\/\r\r__BEGIN_DECLS\rvoid GUSIwithInetSockets();\rvoid GUSIwithLocalSockets();\rvoid GUSIwithMTInetSockets();\rvoid GUSIwithMTTcpSockets();\rvoid GUSIwithMTUdpSockets();\rvoid GUSIwithOTInetSockets();\rvoid GUSIwithOTTcpSockets();\rvoid GUSIwithOTUdpSockets();\rvoid GUSIwithPPCSockets();\rvoid GUSISetupFactories();\r__END_DECLS\r\r\/* Configure Socket Factories *\/\r\rvoid GUSISetupFactories()\r{\r#ifdef GUSISetupFactories_BeginHook\r    GUSISetupFactories_BeginHook\r#endif\r    GUSIwithInetSockets();\r#ifdef GUSISetupFactories_EndHook\r   GUSISetupFactories_EndHook\r#endif\r}\r\r\/* Declarations of File Devices *\/\r\r__BEGIN_DECLS\rvoid GUSIwithNullSockets();\rvoid GUSISetupDevices();\r__END_DECLS\r\r\/* Configure File Devices *\/\r\rvoid GUSISetupDevices()\r{\r#ifdef GUSISetupDevices_BeginHook\r GUSISetupDevices_BeginHook\r#endif\r  GUSIwithNullSockets();\r#ifdef GUSISetupDevices_EndHook\r GUSISetupDevices_EndHook\r#endif\r}\r\r#ifndef __cplusplus\r#error GUSISetupConfig() needs to be written in C++\r#endif\r\rGUSIConfiguration::FileSuffix    sSuffices[] = {\r    \"\", '????', '????'\r};\r\rextern \"C\" void GUSISetupConfig()\r{\r GUSIConfiguration * config =\r       GUSIConfiguration::CreateInstance(GUSIConfiguration::kNoResource);\r\r    config->ConfigureDefaultTypeCreator('TEXT', 'CWIE');\r   config->ConfigureSuffices(\r     sizeof(sSuffices)\/sizeof(GUSIConfiguration::FileSuffix)-1, sSuffices);\r}\r\r\/**************** END GUSI CONFIGURATION *************************\/\n+\/**************** BEGIN GUSI CONFIGURATION ****************************\r *\r * GUSI Configuration section generated by GUSI Configurator\r * last modified: Wed Oct 31 17:07:45 2001\r *\r * This section will be overwritten by the next run of Configurator.\r *\/\r\r#define GUSI_SOURCE\r#include <GUSIConfig.h>\r#include <sys\/cdefs.h>\r\r\/* Declarations of Socket Factories *\/\r\r__BEGIN_DECLS\rvoid GUSIwithInetSockets();\rvoid GUSIwithLocalSockets();\rvoid GUSIwithMTInetSockets();\rvoid GUSIwithMTTcpSockets();\rvoid GUSIwithMTUdpSockets();\rvoid GUSIwithOTInetSockets();\rvoid GUSIwithOTTcpSockets();\rvoid GUSIwithOTUdpSockets();\rvoid GUSIwithPPCSockets();\rvoid GUSISetupFactories();\r__END_DECLS\r\r\/* Configure Socket Factories *\/\r\rvoid GUSISetupFactories()\r{\r#ifdef GUSISetupFactories_BeginHook\r\tGUSISetupFactories_BeginHook\r#endif\r\tGUSIwithInetSockets();\r#ifdef GUSISetupFactories_EndHook\r\tGUSISetupFactories_EndHook\r#endif\r}\r\r\/* Declarations of File Devices *\/\r\r__BEGIN_DECLS\rvoid GUSIwithNullSockets();\rvoid GUSISetupDevices();\r__END_DECLS\r\r\/* Configure File Devices *\/\r\rvoid GUSISetupDevices()\r{\r#ifdef GUSISetupDevices_BeginHook\r\tGUSISetupDevices_BeginHook\r#endif\r\tGUSIwithNullSockets();\r#ifdef GUSISetupDevices_EndHook\r\tGUSISetupDevices_EndHook\r#endif\r}\r\r#ifndef __cplusplus\r#error GUSISetupConfig() needs to be written in C++\r#endif\r\rGUSIConfiguration::FileSuffix\tsSuffices[] = {\r\t\"\", '????', '????'\r};\r\rextern \"C\" void GUSISetupConfig()\r{\r\tGUSIConfiguration * config =\r\t\tGUSIConfiguration::CreateInstance(GUSIConfiguration::kNoResource);\r\r\tconfig->ConfigureDefaultTypeCreator('TEXT', 'CWIE');\r\tconfig->ConfigureSuffices(\r\t\tsizeof(sSuffices)\/sizeof(GUSIConfiguration::FileSuffix)-1, sSuffices);\r}\r\r\/**************** END GUSI CONFIGURATION *************************\/\r\n\\ No newline at end of file\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/macos\/src\/libxml2_GUSIConfig.cp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,4 +107,4 @@\n-#define FTP_COMMAND_OK      200\n-#define FTP_SYNTAX_ERROR    500\n-#define FTP_GET_PASSWD      331\n-#define FTP_BUF_SIZE        1024\n+#define FTP_COMMAND_OK          200\n+#define FTP_SYNTAX_ERROR        500\n+#define FTP_GET_PASSWD          331\n+#define FTP_BUF_SIZE            1024\n@@ -112,1 +112,1 @@\n-#define XML_NANO_MAX_URLBUF 4096\n+#define XML_NANO_MAX_URLBUF     4096\n@@ -115,6 +115,6 @@\n-    char *protocol; \/* the protocol name *\/\n-    char *hostname; \/* the host name *\/\n-    int port;       \/* the port *\/\n-    char *path;     \/* the path within the URL *\/\n-    char *user;     \/* user string *\/\n-    char *passwd;   \/* passwd string *\/\n+    char *protocol;     \/* the protocol name *\/\n+    char *hostname;     \/* the host name *\/\n+    int port;           \/* the port *\/\n+    char *path;         \/* the path within the URL *\/\n+    char *user;         \/* user string *\/\n+    char *passwd;       \/* passwd string *\/\n@@ -126,1 +126,1 @@\n-    int passive;    \/* currently we support only passive !!! *\/\n+    int passive;        \/* currently we support only passive !!! *\/\n@@ -128,2 +128,2 @@\n-    SOCKET dataFd;  \/* the file descriptor for the data socket *\/\n-    int state;      \/* WRITE \/ READ \/ CLOSED *\/\n+    SOCKET dataFd;      \/* the file descriptor for the data socket *\/\n+    int state;          \/* WRITE \/ READ \/ CLOSED *\/\n@@ -139,2 +139,2 @@\n-static char *proxy = NULL;  \/* the proxy name if any *\/\n-static int proxyPort = 0;   \/* the proxy port if any *\/\n+static char *proxy = NULL;      \/* the proxy name if any *\/\n+static int proxyPort = 0;       \/* the proxy port if any *\/\n@@ -143,1 +143,1 @@\n-static int proxyType = 0;   \/* uses TYPE or a@b ? *\/\n+static int proxyType = 0;       \/* uses TYPE or a@b ? *\/\n@@ -152,2 +152,2 @@\n-    close (s);\n-    return (1);\n+        close (s);\n+        return (1);\n@@ -187,1 +187,1 @@\n-    return;\n+        return;\n@@ -191,1 +191,1 @@\n-    return;\n+        return;\n@@ -197,1 +197,1 @@\n-    return;\n+        return;\n@@ -199,4 +199,0 @@\n-    if (env != NULL) {\n-    xmlNanoFTPScanProxy(env);\n-    } else {\n-    env = getenv(\"FTP_PROXY\");\n@@ -205,1 +201,5 @@\n-    }\n+    } else {\n+        env = getenv(\"FTP_PROXY\");\n+        if (env != NULL) {\n+            xmlNanoFTPScanProxy(env);\n+        }\n@@ -209,1 +209,1 @@\n-    proxyUser = xmlMemStrdup(env);\n+        proxyUser = xmlMemStrdup(env);\n@@ -213,1 +213,1 @@\n-    proxyPasswd = xmlMemStrdup(env);\n+        proxyPasswd = xmlMemStrdup(env);\n@@ -227,2 +227,2 @@\n-    xmlFree(proxy);\n-    proxy = NULL;\n+        xmlFree(proxy);\n+        proxy = NULL;\n@@ -231,2 +231,2 @@\n-    xmlFree(proxyUser);\n-    proxyUser = NULL;\n+        xmlFree(proxyUser);\n+        proxyUser = NULL;\n@@ -235,2 +235,2 @@\n-    xmlFree(proxyPasswd);\n-    proxyPasswd = NULL;\n+        xmlFree(proxyPasswd);\n+        proxyPasswd = NULL;\n@@ -240,1 +240,1 @@\n-    WSACleanup();\n+        WSACleanup();\n@@ -260,1 +260,1 @@\n-            const char *passwd, int type) {\n+                const char *passwd, int type) {\n@@ -262,2 +262,2 @@\n-    xmlFree(proxy);\n-    proxy = NULL;\n+        xmlFree(proxy);\n+        proxy = NULL;\n@@ -266,2 +266,2 @@\n-    xmlFree(proxyUser);\n-    proxyUser = NULL;\n+        xmlFree(proxyUser);\n+        proxyUser = NULL;\n@@ -270,2 +270,2 @@\n-    xmlFree(proxyPasswd);\n-    proxyPasswd = NULL;\n+        xmlFree(proxyPasswd);\n+        proxyPasswd = NULL;\n@@ -274,1 +274,1 @@\n-    proxy = xmlMemStrdup(host);\n+        proxy = xmlMemStrdup(host);\n@@ -276,1 +276,1 @@\n-    proxyUser = xmlMemStrdup(user);\n+        proxyUser = xmlMemStrdup(user);\n@@ -278,1 +278,1 @@\n-    proxyPasswd = xmlMemStrdup(passwd);\n+        proxyPasswd = xmlMemStrdup(passwd);\n@@ -302,1 +302,1 @@\n-    ctxt->protocol = NULL;\n+        ctxt->protocol = NULL;\n@@ -306,1 +306,1 @@\n-    ctxt->hostname = NULL;\n+        ctxt->hostname = NULL;\n@@ -310,1 +310,1 @@\n-    ctxt->path = NULL;\n+        ctxt->path = NULL;\n@@ -316,1 +316,1 @@\n-    return;\n+        return;\n@@ -319,2 +319,2 @@\n-    xmlFreeURI(uri);\n-    return;\n+        xmlFreeURI(uri);\n+        return;\n@@ -326,1 +326,1 @@\n-    ctxt->path = xmlMemStrdup(uri->path);\n+        ctxt->path = xmlMemStrdup(uri->path);\n@@ -328,1 +328,1 @@\n-    ctxt->path = xmlMemStrdup(\"\/\");\n+        ctxt->path = xmlMemStrdup(\"\/\");\n@@ -330,1 +330,1 @@\n-    ctxt->port = uri->port;\n+        ctxt->port = uri->port;\n@@ -333,8 +333,8 @@\n-    char *cptr;\n-    if ((cptr=strchr(uri->user, ':')) == NULL)\n-        ctxt->user = xmlMemStrdup(uri->user);\n-    else {\n-        ctxt->user = (char *)xmlStrndup((xmlChar *)uri->user,\n-                (cptr - uri->user));\n-        ctxt->passwd = xmlMemStrdup(cptr+1);\n-    }\n+        char *cptr;\n+        if ((cptr=strchr(uri->user, ':')) == NULL)\n+            ctxt->user = xmlMemStrdup(uri->user);\n+        else {\n+            ctxt->user = (char *)xmlStrndup((xmlChar *)uri->user,\n+                            (cptr - uri->user));\n+            ctxt->passwd = xmlMemStrdup(cptr+1);\n+        }\n@@ -367,1 +367,1 @@\n-    return(-1);\n+        return(-1);\n@@ -369,1 +369,1 @@\n-    return(-1);\n+        return(-1);\n@@ -371,1 +371,1 @@\n-    return(-1);\n+        return(-1);\n@@ -373,1 +373,1 @@\n-    return(-1);\n+        return(-1);\n@@ -377,1 +377,1 @@\n-    return(-1);\n+        return(-1);\n@@ -380,2 +380,2 @@\n-    xmlFreeURI(uri);\n-    return(-1);\n+        xmlFreeURI(uri);\n+        return(-1);\n@@ -384,4 +384,4 @@\n-    (strcmp(ctxt->hostname, uri->server)) ||\n-    ((uri->port != 0) && (ctxt->port != uri->port))) {\n-    xmlFreeURI(uri);\n-    return(-1);\n+        (strcmp(ctxt->hostname, uri->server)) ||\n+        ((uri->port != 0) && (ctxt->port != uri->port))) {\n+        xmlFreeURI(uri);\n+        return(-1);\n@@ -391,1 +391,1 @@\n-    ctxt->port = uri->port;\n+        ctxt->port = uri->port;\n@@ -394,2 +394,2 @@\n-    xmlFree(ctxt->path);\n-    ctxt->path = NULL;\n+        xmlFree(ctxt->path);\n+        ctxt->path = NULL;\n@@ -401,1 +401,1 @@\n-    ctxt->path = xmlMemStrdup(uri->path);\n+        ctxt->path = xmlMemStrdup(uri->path);\n@@ -424,1 +424,1 @@\n-    proxy = NULL;\n+        proxy = NULL;\n@@ -430,2 +430,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"Removing FTP proxy info\\n\");\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"Removing FTP proxy info\\n\");\n@@ -433,2 +433,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"Using FTP proxy %s\\n\", URL);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"Using FTP proxy %s\\n\", URL);\n@@ -440,5 +440,5 @@\n-    (strcmp(uri->scheme, \"ftp\")) || (uri->server == NULL)) {\n-    __xmlIOErr(XML_FROM_FTP, XML_FTP_URL_SYNTAX, \"Syntax Error\\n\");\n-    if (uri != NULL)\n-        xmlFreeURI(uri);\n-    return;\n+        (strcmp(uri->scheme, \"ftp\")) || (uri->server == NULL)) {\n+        __xmlIOErr(XML_FROM_FTP, XML_FTP_URL_SYNTAX, \"Syntax Error\\n\");\n+        if (uri != NULL)\n+            xmlFreeURI(uri);\n+        return;\n@@ -449,1 +449,1 @@\n-    proxyPort = uri->port;\n+        proxyPort = uri->port;\n@@ -484,2 +484,2 @@\n-    xmlNanoFTPScanURL(ret, unescaped);\n-    xmlFree(unescaped);\n+        xmlNanoFTPScanURL(ret, unescaped);\n+        xmlFree(unescaped);\n@@ -487,1 +487,1 @@\n-    xmlNanoFTPScanURL(ret, URL);\n+        xmlNanoFTPScanURL(ret, URL);\n@@ -570,2 +570,2 @@\n-        \"xmlNanoFTPGetMore : controlBufIndex = %d\\n\",\n-        ctxt->controlBufIndex);\n+                \"xmlNanoFTPGetMore : controlBufIndex = %d\\n\",\n+                ctxt->controlBufIndex);\n@@ -573,1 +573,1 @@\n-    return(-1);\n+        return(-1);\n@@ -579,2 +579,2 @@\n-        \"xmlNanoFTPGetMore : controlBufUsed = %d\\n\",\n-        ctxt->controlBufUsed);\n+                \"xmlNanoFTPGetMore : controlBufUsed = %d\\n\",\n+                ctxt->controlBufUsed);\n@@ -582,1 +582,1 @@\n-    return(-1);\n+        return(-1);\n@@ -587,2 +587,2 @@\n-        \"xmlNanoFTPGetMore : controlBufIndex > controlBufUsed %d > %d\\n\",\n-           ctxt->controlBufIndex, ctxt->controlBufUsed);\n+                \"xmlNanoFTPGetMore : controlBufIndex > controlBufUsed %d > %d\\n\",\n+               ctxt->controlBufIndex, ctxt->controlBufUsed);\n@@ -590,1 +590,1 @@\n-    return(-1);\n+        return(-1);\n@@ -597,4 +597,4 @@\n-    memmove(&ctxt->controlBuf[0], &ctxt->controlBuf[ctxt->controlBufIndex],\n-        ctxt->controlBufUsed - ctxt->controlBufIndex);\n-    ctxt->controlBufUsed -= ctxt->controlBufIndex;\n-    ctxt->controlBufIndex = 0;\n+        memmove(&ctxt->controlBuf[0], &ctxt->controlBuf[ctxt->controlBufIndex],\n+                ctxt->controlBufUsed - ctxt->controlBufIndex);\n+        ctxt->controlBufUsed -= ctxt->controlBufIndex;\n+        ctxt->controlBufIndex = 0;\n@@ -606,1 +606,1 @@\n-        \"xmlNanoFTPGetMore : buffer full %d \\n\", ctxt->controlBufUsed);\n+                \"xmlNanoFTPGetMore : buffer full %d \\n\", ctxt->controlBufUsed);\n@@ -608,1 +608,1 @@\n-    return(0);\n+        return(0);\n@@ -615,3 +615,3 @@\n-            size, 0)) < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"recv failed\");\n-    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n+                    size, 0)) < 0) {\n+        __xmlIOErr(XML_FROM_FTP, 0, \"recv failed\");\n+        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n@@ -623,2 +623,2 @@\n-        \"xmlNanoFTPGetMore : read %d [%d - %d]\\n\", len,\n-       ctxt->controlBufUsed, ctxt->controlBufUsed + len);\n+            \"xmlNanoFTPGetMore : read %d [%d - %d]\\n\", len,\n+           ctxt->controlBufUsed, ctxt->controlBufUsed + len);\n@@ -665,1 +665,1 @@\n-        \"\\n<<<\\n%s\\n--\\n\", ptr);\n+            \"\\n<<<\\n%s\\n--\\n\", ptr);\n@@ -669,9 +669,14 @@\n-    if (cur > 0) {\n-        \/*\n-         * Successfully scanned the control code, scratch\n-         * till the end of the line, but keep the index to be\n-         * able to analyze the result if needed.\n-         *\/\n-        res = cur;\n-        ptr += 3;\n-        ctxt->controlBufAnswer = ptr - ctxt->controlBuf;\n+        if (cur > 0) {\n+            \/*\n+             * Successfully scanned the control code, scratch\n+             * till the end of the line, but keep the index to be\n+             * able to analyze the result if needed.\n+             *\/\n+            res = cur;\n+            ptr += 3;\n+            ctxt->controlBufAnswer = ptr - ctxt->controlBuf;\n+            while ((ptr < end) && (*ptr != '\\n')) ptr++;\n+            if (*ptr == '\\n') ptr++;\n+            if (*ptr == '\\r') ptr++;\n+            break;\n+        }\n@@ -679,10 +684,5 @@\n-        if (*ptr == '\\n') ptr++;\n-        if (*ptr == '\\r') ptr++;\n-        break;\n-    }\n-    while ((ptr < end) && (*ptr != '\\n')) ptr++;\n-    if (ptr >= end) {\n-        ctxt->controlBufIndex = ctxt->controlBufUsed;\n-        goto get_more;\n-    }\n-    if (*ptr != '\\r') ptr++;\n+        if (ptr >= end) {\n+            ctxt->controlBufIndex = ctxt->controlBufUsed;\n+            goto get_more;\n+        }\n+        if (*ptr != '\\r') ptr++;\n@@ -741,5 +741,5 @@\n-    case 0:\n-        return(0);\n-    case -1:\n-        __xmlIOErr(XML_FROM_FTP, 0, \"select\");\n-        return(-1);\n+        case 0:\n+            return(0);\n+        case -1:\n+            __xmlIOErr(XML_FROM_FTP, 0, \"select\");\n+            return(-1);\n@@ -764,1 +764,1 @@\n-    snprintf(buf, sizeof(buf), \"USER anonymous\\r\\n\");\n+        snprintf(buf, sizeof(buf), \"USER anonymous\\r\\n\");\n@@ -766,1 +766,1 @@\n-    snprintf(buf, sizeof(buf), \"USER %s\\r\\n\", ctxt->user);\n+        snprintf(buf, sizeof(buf), \"USER %s\\r\\n\", ctxt->user);\n@@ -774,2 +774,2 @@\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    return(res);\n+        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n+        return(res);\n@@ -792,1 +792,1 @@\n-    snprintf(buf, sizeof(buf), \"PASS anonymous@\\r\\n\");\n+        snprintf(buf, sizeof(buf), \"PASS anonymous@\\r\\n\");\n@@ -794,1 +794,1 @@\n-    snprintf(buf, sizeof(buf), \"PASS %s\\r\\n\", ctxt->passwd);\n+        snprintf(buf, sizeof(buf), \"PASS %s\\r\\n\", ctxt->passwd);\n@@ -802,2 +802,2 @@\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    return(res);\n+        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n+        return(res);\n@@ -833,2 +833,2 @@\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    return(res);\n+        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n+        return(res);\n@@ -857,1 +857,1 @@\n-    return(-1);\n+        return(-1);\n@@ -859,1 +859,1 @@\n-    return(-1);\n+        return(-1);\n@@ -867,1 +867,1 @@\n-    port = ctxt->port;\n+        port = ctxt->port;\n@@ -870,1 +870,1 @@\n-    port = 21;\n+        port = 21;\n@@ -876,1 +876,1 @@\n-    struct addrinfo hints, *tmp, *result;\n+        struct addrinfo hints, *tmp, *result;\n@@ -878,3 +878,3 @@\n-    result = NULL;\n-    memset (&hints, 0, sizeof(hints));\n-    hints.ai_socktype = SOCK_STREAM;\n+        result = NULL;\n+        memset (&hints, 0, sizeof(hints));\n+        hints.ai_socktype = SOCK_STREAM;\n@@ -882,10 +882,5 @@\n-    if (proxy) {\n-        if (getaddrinfo (proxy, NULL, &hints, &result) != 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"getaddrinfo failed\");\n-        return (-1);\n-        }\n-    }\n-    else\n-        if (getaddrinfo (ctxt->hostname, NULL, &hints, &result) != 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"getaddrinfo failed\");\n-        return (-1);\n+        if (proxy) {\n+            if (getaddrinfo (proxy, NULL, &hints, &result) != 0) {\n+                __xmlIOErr(XML_FROM_FTP, 0, \"getaddrinfo failed\");\n+                return (-1);\n+            }\n@@ -893,0 +888,5 @@\n+        else\n+            if (getaddrinfo (ctxt->hostname, NULL, &hints, &result) != 0) {\n+                __xmlIOErr(XML_FROM_FTP, 0, \"getaddrinfo failed\");\n+                return (-1);\n+            }\n@@ -894,3 +894,3 @@\n-    for (tmp = result; tmp; tmp = tmp->ai_next)\n-        if (tmp->ai_family == AF_INET || tmp->ai_family == AF_INET6)\n-        break;\n+        for (tmp = result; tmp; tmp = tmp->ai_next)\n+            if (tmp->ai_family == AF_INET || tmp->ai_family == AF_INET6)\n+                break;\n@@ -898,8 +898,23 @@\n-    if (!tmp) {\n-        if (result)\n-        freeaddrinfo (result);\n-        __xmlIOErr(XML_FROM_FTP, 0, \"getaddrinfo failed\");\n-        return (-1);\n-    }\n-    if ((size_t)tmp->ai_addrlen > sizeof(ctxt->ftpAddr)) {\n-        if (result)\n+        if (!tmp) {\n+            if (result)\n+                freeaddrinfo (result);\n+            __xmlIOErr(XML_FROM_FTP, 0, \"getaddrinfo failed\");\n+            return (-1);\n+        }\n+        if ((size_t)tmp->ai_addrlen > sizeof(ctxt->ftpAddr)) {\n+            if (result)\n+                freeaddrinfo (result);\n+            __xmlIOErr(XML_FROM_FTP, 0, \"gethostbyname address mismatch\");\n+            return (-1);\n+        }\n+        if (tmp->ai_family == AF_INET6) {\n+            memcpy (&ctxt->ftpAddr, tmp->ai_addr, tmp->ai_addrlen);\n+            ((struct sockaddr_in6 *) &ctxt->ftpAddr)->sin6_port = htons (port);\n+            ctxt->controlFd = socket (AF_INET6, SOCK_STREAM, 0);\n+        }\n+        else {\n+            memcpy (&ctxt->ftpAddr, tmp->ai_addr, tmp->ai_addrlen);\n+            ((struct sockaddr_in *) &ctxt->ftpAddr)->sin_port = htons (port);\n+            ctxt->controlFd = socket (AF_INET, SOCK_STREAM, 0);\n+        }\n+        addrlen = tmp->ai_addrlen;\n@@ -907,15 +922,0 @@\n-        __xmlIOErr(XML_FROM_FTP, 0, \"gethostbyname address mismatch\");\n-        return (-1);\n-    }\n-    if (tmp->ai_family == AF_INET6) {\n-        memcpy (&ctxt->ftpAddr, tmp->ai_addr, tmp->ai_addrlen);\n-        ((struct sockaddr_in6 *) &ctxt->ftpAddr)->sin6_port = htons (port);\n-        ctxt->controlFd = socket (AF_INET6, SOCK_STREAM, 0);\n-    }\n-    else {\n-        memcpy (&ctxt->ftpAddr, tmp->ai_addr, tmp->ai_addrlen);\n-        ((struct sockaddr_in *) &ctxt->ftpAddr)->sin_port = htons (port);\n-        ctxt->controlFd = socket (AF_INET, SOCK_STREAM, 0);\n-    }\n-    addrlen = tmp->ai_addrlen;\n-    freeaddrinfo (result);\n@@ -926,13 +926,13 @@\n-    if (proxy)\n-        hp = gethostbyname (GETHOSTBYNAME_ARG_CAST proxy);\n-    else\n-        hp = gethostbyname (GETHOSTBYNAME_ARG_CAST ctxt->hostname);\n-    if (hp == NULL) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"gethostbyname failed\");\n-        return (-1);\n-    }\n-    if ((unsigned int) hp->h_length >\n-        sizeof(((struct sockaddr_in *)&ctxt->ftpAddr)->sin_addr)) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"gethostbyname address mismatch\");\n-        return (-1);\n-    }\n+        if (proxy)\n+            hp = gethostbyname (GETHOSTBYNAME_ARG_CAST proxy);\n+        else\n+            hp = gethostbyname (GETHOSTBYNAME_ARG_CAST ctxt->hostname);\n+        if (hp == NULL) {\n+            __xmlIOErr(XML_FROM_FTP, 0, \"gethostbyname failed\");\n+            return (-1);\n+        }\n+        if ((unsigned int) hp->h_length >\n+            sizeof(((struct sockaddr_in *)&ctxt->ftpAddr)->sin_addr)) {\n+            __xmlIOErr(XML_FROM_FTP, 0, \"gethostbyname address mismatch\");\n+            return (-1);\n+        }\n@@ -940,7 +940,7 @@\n-    \/*\n-     * Prepare the socket\n-     *\/\n-    ((struct sockaddr_in *)&ctxt->ftpAddr)->sin_family = AF_INET;\n-    memcpy (&((struct sockaddr_in *)&ctxt->ftpAddr)->sin_addr,\n-        hp->h_addr_list[0], hp->h_length);\n-    ((struct sockaddr_in *)&ctxt->ftpAddr)->sin_port =\n+        \/*\n+         * Prepare the socket\n+         *\/\n+        ((struct sockaddr_in *)&ctxt->ftpAddr)->sin_family = AF_INET;\n+        memcpy (&((struct sockaddr_in *)&ctxt->ftpAddr)->sin_addr,\n+                hp->h_addr_list[0], hp->h_length);\n+        ((struct sockaddr_in *)&ctxt->ftpAddr)->sin_port =\n@@ -948,2 +948,2 @@\n-    ctxt->controlFd = socket (AF_INET, SOCK_STREAM, 0);\n-    addrlen = sizeof (struct sockaddr_in);\n+        ctxt->controlFd = socket (AF_INET, SOCK_STREAM, 0);\n+        addrlen = sizeof (struct sockaddr_in);\n@@ -953,1 +953,1 @@\n-    __xmlIOErr(XML_FROM_FTP, 0, \"socket failed\");\n+        __xmlIOErr(XML_FROM_FTP, 0, \"socket failed\");\n@@ -961,2 +961,2 @@\n-        addrlen) < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"Failed to create a connection\");\n+            addrlen) < 0) {\n+        __xmlIOErr(XML_FROM_FTP, 0, \"Failed to create a connection\");\n@@ -965,1 +965,1 @@\n-    return(-1);\n+        return(-1);\n@@ -975,1 +975,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1015,1 +1015,1 @@\n-    char buf[400];\n+        char buf[400];\n@@ -1018,4 +1018,4 @@\n-        \/*\n-         * We need proxy auth\n-         *\/\n-        snprintf(buf, sizeof(buf), \"USER %s\\r\\n\", proxyUser);\n+            \/*\n+             * We need proxy auth\n+             *\/\n+            snprintf(buf, sizeof(buf), \"USER %s\\r\\n\", proxyUser);\n@@ -1024,23 +1024,0 @@\n-#ifdef DEBUG_FTP\n-        xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n-        res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-        if (res < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-        closesocket(ctxt->controlFd);\n-        ctxt->controlFd = INVALID_SOCKET;\n-            return(res);\n-        }\n-        res = xmlNanoFTPGetResponse(ctxt);\n-        switch (res) {\n-        case 2:\n-            if (proxyPasswd == NULL)\n-            break;\n-                    \/* Falls through. *\/\n-        case 3:\n-            if (proxyPasswd != NULL)\n-            snprintf(buf, sizeof(buf), \"PASS %s\\r\\n\", proxyPasswd);\n-            else\n-            snprintf(buf, sizeof(buf), \"PASS anonymous@\\r\\n\");\n-                    buf[sizeof(buf) - 1] = 0;\n-                    len = strlen(buf);\n@@ -1052,4 +1029,4 @@\n-            __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-            closesocket(ctxt->controlFd);\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(res);\n+                __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n+                closesocket(ctxt->controlFd);\n+                ctxt->controlFd = INVALID_SOCKET;\n+                return(res);\n@@ -1058,4 +1035,38 @@\n-            if (res > 3) {\n-            closesocket(ctxt->controlFd);\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(-1);\n+            switch (res) {\n+                case 2:\n+                    if (proxyPasswd == NULL)\n+                        break;\n+                    \/* Falls through. *\/\n+                case 3:\n+                    if (proxyPasswd != NULL)\n+                        snprintf(buf, sizeof(buf), \"PASS %s\\r\\n\", proxyPasswd);\n+                    else\n+                        snprintf(buf, sizeof(buf), \"PASS anonymous@\\r\\n\");\n+                    buf[sizeof(buf) - 1] = 0;\n+                    len = strlen(buf);\n+#ifdef DEBUG_FTP\n+                    xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n+#endif\n+                    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n+                    if (res < 0) {\n+                        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n+                        closesocket(ctxt->controlFd);\n+                        ctxt->controlFd = INVALID_SOCKET;\n+                        return(res);\n+                    }\n+                    res = xmlNanoFTPGetResponse(ctxt);\n+                    if (res > 3) {\n+                        closesocket(ctxt->controlFd);\n+                        ctxt->controlFd = INVALID_SOCKET;\n+                        return(-1);\n+                    }\n+                    break;\n+                case 1:\n+                    break;\n+                case 4:\n+                case 5:\n+                case -1:\n+                default:\n+                    closesocket(ctxt->controlFd);\n+                    ctxt->controlFd = INVALID_SOCKET;\n+                    return(-1);\n@@ -1063,10 +1074,0 @@\n-            break;\n-        case 1:\n-            break;\n-        case 4:\n-        case 5:\n-        case -1:\n-        default:\n-            closesocket(ctxt->controlFd);\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(-1);\n@@ -1074,1 +1075,0 @@\n-    }\n@@ -1076,10 +1076,10 @@\n-    \/*\n-     * We assume we don't need more authentication to the proxy\n-     * and that it succeeded :-\\\n-     *\/\n-    switch (proxyType) {\n-        case 0:\n-        \/* we will try in sequence *\/\n-        case 1:\n-        \/* Using SITE command *\/\n-        snprintf(buf, sizeof(buf), \"SITE %s\\r\\n\", ctxt->hostname);\n+        \/*\n+         * We assume we don't need more authentication to the proxy\n+         * and that it succeeded :-\\\n+         *\/\n+        switch (proxyType) {\n+            case 0:\n+                \/* we will try in sequence *\/\n+            case 1:\n+                \/* Using SITE command *\/\n+                snprintf(buf, sizeof(buf), \"SITE %s\\r\\n\", ctxt->hostname);\n@@ -1089,20 +1089,20 @@\n-        xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n-        res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-        if (res < 0) {\n-            __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(res);\n-        }\n-        res = xmlNanoFTPGetResponse(ctxt);\n-        if (res == 2) {\n-            \/* we assume it worked :-\\ 1 is error for SITE command *\/\n-            proxyType = 1;\n-            break;\n-        }\n-        if (proxyType == 1) {\n-            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(-1);\n-        }\n+                xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n+#endif\n+                res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n+                if (res < 0) {\n+                    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n+                    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n+                    ctxt->controlFd = INVALID_SOCKET;\n+                    return(res);\n+                }\n+                res = xmlNanoFTPGetResponse(ctxt);\n+                if (res == 2) {\n+                    \/* we assume it worked :-\\ 1 is error for SITE command *\/\n+                    proxyType = 1;\n+                    break;\n+                }\n+                if (proxyType == 1) {\n+                    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n+                    ctxt->controlFd = INVALID_SOCKET;\n+                    return(-1);\n+                }\n@@ -1110,8 +1110,8 @@\n-        case 2:\n-        \/* USER user@host command *\/\n-        if (ctxt->user == NULL)\n-            snprintf(buf, sizeof(buf), \"USER anonymous@%s\\r\\n\",\n-                       ctxt->hostname);\n-        else\n-            snprintf(buf, sizeof(buf), \"USER %s@%s\\r\\n\",\n-                       ctxt->user, ctxt->hostname);\n+            case 2:\n+                \/* USER user@host command *\/\n+                if (ctxt->user == NULL)\n+                    snprintf(buf, sizeof(buf), \"USER anonymous@%s\\r\\n\",\n+                                   ctxt->hostname);\n+                else\n+                    snprintf(buf, sizeof(buf), \"USER %s@%s\\r\\n\",\n+                                   ctxt->user, ctxt->hostname);\n@@ -1121,19 +1121,19 @@\n-        xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n-        res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-        if (res < 0) {\n-            __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(res);\n-        }\n-        res = xmlNanoFTPGetResponse(ctxt);\n-        if ((res == 1) || (res == 2)) {\n-            \/* we assume it worked :-\\ *\/\n-            proxyType = 2;\n-            return(0);\n-        }\n-        if (ctxt->passwd == NULL)\n-            snprintf(buf, sizeof(buf), \"PASS anonymous@\\r\\n\");\n-        else\n-            snprintf(buf, sizeof(buf), \"PASS %s\\r\\n\", ctxt->passwd);\n+                xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n+#endif\n+                res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n+                if (res < 0) {\n+                    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n+                    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n+                    ctxt->controlFd = INVALID_SOCKET;\n+                    return(res);\n+                }\n+                res = xmlNanoFTPGetResponse(ctxt);\n+                if ((res == 1) || (res == 2)) {\n+                    \/* we assume it worked :-\\ *\/\n+                    proxyType = 2;\n+                    return(0);\n+                }\n+                if (ctxt->passwd == NULL)\n+                    snprintf(buf, sizeof(buf), \"PASS anonymous@\\r\\n\");\n+                else\n+                    snprintf(buf, sizeof(buf), \"PASS %s\\r\\n\", ctxt->passwd);\n@@ -1143,20 +1143,20 @@\n-        xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n-#endif\n-        res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-        if (res < 0) {\n-            __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(res);\n-        }\n-        res = xmlNanoFTPGetResponse(ctxt);\n-        if ((res == 1) || (res == 2)) {\n-            \/* we assume it worked :-\\ *\/\n-            proxyType = 2;\n-            return(0);\n-        }\n-        if (proxyType == 2) {\n-            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(-1);\n-        }\n+                xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n+#endif\n+                res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n+                if (res < 0) {\n+                    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n+                    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n+                    ctxt->controlFd = INVALID_SOCKET;\n+                    return(res);\n+                }\n+                res = xmlNanoFTPGetResponse(ctxt);\n+                if ((res == 1) || (res == 2)) {\n+                    \/* we assume it worked :-\\ *\/\n+                    proxyType = 2;\n+                    return(0);\n+                }\n+                if (proxyType == 2) {\n+                    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n+                    ctxt->controlFd = INVALID_SOCKET;\n+                    return(-1);\n+                }\n@@ -1164,10 +1164,10 @@\n-        case 3:\n-        \/*\n-         * If you need support for other Proxy authentication scheme\n-         * send the code or at least the sequence in use.\n-         *\/\n-        default:\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n+            case 3:\n+                \/*\n+                 * If you need support for other Proxy authentication scheme\n+                 * send the code or at least the sequence in use.\n+                 *\/\n+            default:\n+                closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n+                ctxt->controlFd = INVALID_SOCKET;\n+                return(-1);\n+        }\n@@ -1182,1 +1182,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1186,7 +1186,7 @@\n-    case 2:\n-        return(0);\n-    case 3:\n-        break;\n-    case 1:\n-    case 4:\n-    case 5:\n+        case 2:\n+            return(0);\n+        case 3:\n+            break;\n+        case 1:\n+        case 4:\n+        case 5:\n@@ -1194,4 +1194,4 @@\n-    default:\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-        return(-1);\n+        default:\n+            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n+            ctxt->controlFd = INVALID_SOCKET;\n+            return(-1);\n@@ -1203,1 +1203,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1207,5 +1207,5 @@\n-    case 2:\n-        break;\n-    case 3:\n-        __xmlIOErr(XML_FROM_FTP, XML_FTP_ACCNT,\n-               \"FTP server asking for ACCNT on anonymous\\n\");\n+        case 2:\n+            break;\n+        case 3:\n+            __xmlIOErr(XML_FROM_FTP, XML_FTP_ACCNT,\n+                       \"FTP server asking for ACCNT on anonymous\\n\");\n@@ -1213,3 +1213,3 @@\n-    case 1:\n-    case 4:\n-    case 5:\n+        case 1:\n+        case 4:\n+        case 5:\n@@ -1217,4 +1217,4 @@\n-    default:\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-        return(-1);\n+        default:\n+            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n+            ctxt->controlFd = INVALID_SOCKET;\n+            return(-1);\n@@ -1243,1 +1243,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1245,1 +1245,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1251,2 +1251,2 @@\n-    xmlNanoFTPFreeCtxt(ctxt);\n-    return(NULL);\n+        xmlNanoFTPFreeCtxt(ctxt);\n+        return(NULL);\n@@ -1257,2 +1257,2 @@\n-    xmlNanoFTPFreeCtxt(ctxt);\n-    return(NULL);\n+        xmlNanoFTPFreeCtxt(ctxt);\n+        return(NULL);\n@@ -1298,2 +1298,2 @@\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    return(res);\n+        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n+        return(res);\n@@ -1303,1 +1303,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1307,1 +1307,1 @@\n-    return(0);\n+        return(0);\n@@ -1349,2 +1349,2 @@\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    return(res);\n+        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n+        return(res);\n@@ -1354,1 +1354,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1358,1 +1358,1 @@\n-    return(0);\n+        return(0);\n@@ -1392,3 +1392,3 @@\n-    ctxt->dataFd = socket (AF_INET6, SOCK_STREAM, IPPROTO_TCP);\n-    ((struct sockaddr_in6 *)&dataAddr)->sin6_family = AF_INET6;\n-    dataAddrLen = sizeof(struct sockaddr_in6);\n+        ctxt->dataFd = socket (AF_INET6, SOCK_STREAM, IPPROTO_TCP);\n+        ((struct sockaddr_in6 *)&dataAddr)->sin6_family = AF_INET6;\n+        dataAddrLen = sizeof(struct sockaddr_in6);\n@@ -1398,3 +1398,3 @@\n-    ctxt->dataFd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);\n-    ((struct sockaddr_in *)&dataAddr)->sin_family = AF_INET;\n-    dataAddrLen = sizeof (struct sockaddr_in);\n+        ctxt->dataFd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);\n+        ((struct sockaddr_in *)&dataAddr)->sin_family = AF_INET;\n+        dataAddrLen = sizeof (struct sockaddr_in);\n@@ -1404,2 +1404,2 @@\n-    __xmlIOErr(XML_FROM_FTP, 0, \"socket failed\");\n-    return INVALID_SOCKET;\n+        __xmlIOErr(XML_FROM_FTP, 0, \"socket failed\");\n+        return INVALID_SOCKET;\n@@ -1410,3 +1410,3 @@\n-    if ((ctxt->ftpAddr).ss_family == AF_INET6)\n-        snprintf (buf, sizeof(buf), \"EPSV\\r\\n\");\n-    else\n+        if ((ctxt->ftpAddr).ss_family == AF_INET6)\n+            snprintf (buf, sizeof(buf), \"EPSV\\r\\n\");\n+        else\n@@ -1414,1 +1414,1 @@\n-        snprintf (buf, sizeof(buf), \"PASV\\r\\n\");\n+            snprintf (buf, sizeof(buf), \"PASV\\r\\n\");\n@@ -1417,1 +1417,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n+        xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n@@ -1419,15 +1419,3 @@\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-    }\n-        res = xmlNanoFTPReadResponse(ctx);\n-    if (res != 2) {\n-        if (res == 5) {\n-            closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-        } else {\n-        \/*\n-         * retry with an active connection\n-         *\/\n+        res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n+        if (res < 0) {\n+            __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n@@ -1435,1 +1423,1 @@\n-            ctxt->passive = 0;\n+            return INVALID_SOCKET;\n@@ -1437,10 +1425,12 @@\n-    }\n-    cur = &ctxt->controlBuf[ctxt->controlBufAnswer];\n-    while (((*cur < '0') || (*cur > '9')) && *cur != '\\0') cur++;\n-#ifdef SUPPORT_IP6\n-    if ((ctxt->ftpAddr).ss_family == AF_INET6) {\n-        if (sscanf (cur, \"%u\", &temp[0]) != 1) {\n-        __xmlIOErr(XML_FROM_FTP, XML_FTP_EPSV_ANSWER,\n-            \"Invalid answer to EPSV\\n\");\n-        if (ctxt->dataFd != INVALID_SOCKET) {\n-            closesocket (ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+        res = xmlNanoFTPReadResponse(ctx);\n+        if (res != 2) {\n+            if (res == 5) {\n+                closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+                return INVALID_SOCKET;\n+            } else {\n+                \/*\n+                 * retry with an active connection\n+                 *\/\n+                closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+                ctxt->passive = 0;\n+            }\n@@ -1448,1 +1438,14 @@\n-        return INVALID_SOCKET;\n+        cur = &ctxt->controlBuf[ctxt->controlBufAnswer];\n+        while (((*cur < '0') || (*cur > '9')) && *cur != '\\0') cur++;\n+#ifdef SUPPORT_IP6\n+        if ((ctxt->ftpAddr).ss_family == AF_INET6) {\n+            if (sscanf (cur, \"%u\", &temp[0]) != 1) {\n+                __xmlIOErr(XML_FROM_FTP, XML_FTP_EPSV_ANSWER,\n+                        \"Invalid answer to EPSV\\n\");\n+                if (ctxt->dataFd != INVALID_SOCKET) {\n+                    closesocket (ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+                }\n+                return INVALID_SOCKET;\n+            }\n+            memcpy (&((struct sockaddr_in6 *)&dataAddr)->sin6_addr, &((struct sockaddr_in6 *)&ctxt->ftpAddr)->sin6_addr, sizeof(struct in6_addr));\n+            ((struct sockaddr_in6 *)&dataAddr)->sin6_port = htons (temp[0]);\n@@ -1450,4 +1453,1 @@\n-        memcpy (&((struct sockaddr_in6 *)&dataAddr)->sin6_addr, &((struct sockaddr_in6 *)&ctxt->ftpAddr)->sin6_addr, sizeof(struct in6_addr));\n-        ((struct sockaddr_in6 *)&dataAddr)->sin6_port = htons (temp[0]);\n-    }\n-    else\n+        else\n@@ -1455,9 +1455,13 @@\n-    {\n-        if (sscanf (cur, \"%u,%u,%u,%u,%u,%u\", &temp[0], &temp[1], &temp[2],\n-        &temp[3], &temp[4], &temp[5]) != 6) {\n-        __xmlIOErr(XML_FROM_FTP, XML_FTP_PASV_ANSWER,\n-            \"Invalid answer to PASV\\n\");\n-        if (ctxt->dataFd != INVALID_SOCKET) {\n-            closesocket (ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        }\n-        return INVALID_SOCKET;\n+        {\n+            if (sscanf (cur, \"%u,%u,%u,%u,%u,%u\", &temp[0], &temp[1], &temp[2],\n+                &temp[3], &temp[4], &temp[5]) != 6) {\n+                __xmlIOErr(XML_FROM_FTP, XML_FTP_PASV_ANSWER,\n+                        \"Invalid answer to PASV\\n\");\n+                if (ctxt->dataFd != INVALID_SOCKET) {\n+                    closesocket (ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+                }\n+                return INVALID_SOCKET;\n+            }\n+            for (i=0; i<6; i++) ad[i] = (unsigned char) (temp[i] & 0xff);\n+            memcpy (&((struct sockaddr_in *)&dataAddr)->sin_addr, &ad[0], 4);\n+            memcpy (&((struct sockaddr_in *)&dataAddr)->sin_port, &ad[4], 2);\n@@ -1465,4 +1469,0 @@\n-        for (i=0; i<6; i++) ad[i] = (unsigned char) (temp[i] & 0xff);\n-        memcpy (&((struct sockaddr_in *)&dataAddr)->sin_addr, &ad[0], 4);\n-        memcpy (&((struct sockaddr_in *)&dataAddr)->sin_port, &ad[4], 2);\n-    }\n@@ -1470,5 +1470,5 @@\n-    if (connect(ctxt->dataFd, (struct sockaddr *) &dataAddr, dataAddrLen) < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"Failed to create a data connection\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-    }\n+        if (connect(ctxt->dataFd, (struct sockaddr *) &dataAddr, dataAddrLen) < 0) {\n+            __xmlIOErr(XML_FROM_FTP, 0, \"Failed to create a data connection\");\n+            closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+            return INVALID_SOCKET;\n+        }\n@@ -1478,3 +1478,3 @@\n-    if ((ctxt->ftpAddr).ss_family == AF_INET6)\n-        ((struct sockaddr_in6 *)&dataAddr)->sin6_port = 0;\n-    else\n+        if ((ctxt->ftpAddr).ss_family == AF_INET6)\n+            ((struct sockaddr_in6 *)&dataAddr)->sin6_port = 0;\n+        else\n@@ -1482,1 +1482,1 @@\n-        ((struct sockaddr_in *)&dataAddr)->sin_port = 0;\n+            ((struct sockaddr_in *)&dataAddr)->sin_port = 0;\n@@ -1484,5 +1484,5 @@\n-    if (bind(ctxt->dataFd, (struct sockaddr *) &dataAddr, dataAddrLen) < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"bind failed\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-    }\n+        if (bind(ctxt->dataFd, (struct sockaddr *) &dataAddr, dataAddrLen) < 0) {\n+            __xmlIOErr(XML_FROM_FTP, 0, \"bind failed\");\n+            closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+            return INVALID_SOCKET;\n+        }\n@@ -1491,5 +1491,5 @@\n-    if (listen(ctxt->dataFd, 1) < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"listen failed\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-    }\n+        if (listen(ctxt->dataFd, 1) < 0) {\n+            __xmlIOErr(XML_FROM_FTP, 0, \"listen failed\");\n+            closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+            return INVALID_SOCKET;\n+        }\n@@ -1497,7 +1497,7 @@\n-    if ((ctxt->ftpAddr).ss_family == AF_INET6) {\n-        char buf6[INET6_ADDRSTRLEN];\n-        inet_ntop (AF_INET6, &((struct sockaddr_in6 *)&dataAddr)->sin6_addr,\n-            buf6, INET6_ADDRSTRLEN);\n-        adp = (unsigned char *) buf6;\n-        portp = (unsigned char *) &((struct sockaddr_in6 *)&dataAddr)->sin6_port;\n-        snprintf (buf, sizeof(buf), \"EPRT |2|%s|%s|\\r\\n\", adp, portp);\n+        if ((ctxt->ftpAddr).ss_family == AF_INET6) {\n+            char buf6[INET6_ADDRSTRLEN];\n+            inet_ntop (AF_INET6, &((struct sockaddr_in6 *)&dataAddr)->sin6_addr,\n+                    buf6, INET6_ADDRSTRLEN);\n+            adp = (unsigned char *) buf6;\n+            portp = (unsigned char *) &((struct sockaddr_in6 *)&dataAddr)->sin6_port;\n+            snprintf (buf, sizeof(buf), \"EPRT |2|%s|%s|\\r\\n\", adp, portp);\n@@ -1506,7 +1506,7 @@\n-    {\n-        adp = (unsigned char *) &((struct sockaddr_in *)&dataAddr)->sin_addr;\n-        portp = (unsigned char *) &((struct sockaddr_in *)&dataAddr)->sin_port;\n-        snprintf (buf, sizeof(buf), \"PORT %d,%d,%d,%d,%d,%d\\r\\n\",\n-        adp[0] & 0xff, adp[1] & 0xff, adp[2] & 0xff, adp[3] & 0xff,\n-        portp[0] & 0xff, portp[1] & 0xff);\n-    }\n+        {\n+            adp = (unsigned char *) &((struct sockaddr_in *)&dataAddr)->sin_addr;\n+            portp = (unsigned char *) &((struct sockaddr_in *)&dataAddr)->sin_port;\n+            snprintf (buf, sizeof(buf), \"PORT %d,%d,%d,%d,%d,%d\\r\\n\",\n+            adp[0] & 0xff, adp[1] & 0xff, adp[2] & 0xff, adp[3] & 0xff,\n+            portp[0] & 0xff, portp[1] & 0xff);\n+        }\n@@ -1517,1 +1517,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n+        xmlGenericError(xmlGenericErrorContext, \"%s\", buf);\n@@ -1520,6 +1520,6 @@\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-    }\n+        res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n+        if (res < 0) {\n+            __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n+            closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+            return INVALID_SOCKET;\n+        }\n@@ -1527,3 +1527,3 @@\n-    if (res != 2) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n+        if (res != 2) {\n+            closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+            return INVALID_SOCKET;\n@@ -1564,1 +1564,1 @@\n-    perror(\"select\");\n+        perror(\"select\");\n@@ -1566,2 +1566,2 @@\n-    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-    return(-1);\n+        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n+        return(-1);\n@@ -1571,2 +1571,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"xmlNanoFTPCloseConnection: timeout\\n\");\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"xmlNanoFTPCloseConnection: timeout\\n\");\n@@ -1574,4 +1574,0 @@\n-    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-    } else {\n-    res = xmlNanoFTPGetResponse(ctxt);\n-    if (res != 2) {\n@@ -1579,2 +1575,6 @@\n-        return(-1);\n-    }\n+    } else {\n+        res = xmlNanoFTPGetResponse(ctxt);\n+        if (res != 2) {\n+            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n+            return(-1);\n+        }\n@@ -1614,6 +1614,6 @@\n-    while (*cur == ' ') cur++;\n-    while ((*cur >= '0') && (*cur <= '9'))\n-        links = (links * 10) + (*cur++ - '0');\n-    while ((*cur == ' ') || (*cur == '\\n')  || (*cur == '\\r'))\n-        cur++;\n-    return(cur - list);\n+        while (*cur == ' ') cur++;\n+        while ((*cur >= '0') && (*cur <= '9'))\n+            links = (links * 10) + (*cur++ - '0');\n+        while ((*cur == ' ') || (*cur == '\\n')  || (*cur == '\\r'))\n+            cur++;\n+        return(cur - list);\n@@ -1621,1 +1621,1 @@\n-    return(0);\n+        return(0);\n@@ -1623,8 +1623,2 @@\n-    while ((*cur == ' ') || (*cur == '\\n')  || (*cur == '\\r'))\n-        cur++;\n-    if (*cur == 0) return(0);\n-    i = 0;\n-    while (*cur != ' ') {\n-        if (i < 10)\n-        attrib[i++] = *cur;\n-        cur++;\n+        while ((*cur == ' ') || (*cur == '\\n')  || (*cur == '\\r'))\n+            cur++;\n@@ -1632,13 +1626,9 @@\n-    }\n-    attrib[10] = 0;\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    while ((*cur >= '0') && (*cur <= '9'))\n-        links = (links * 10) + (*cur++ - '0');\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    i = 0;\n-    while (*cur != ' ') {\n-        if (i < 10)\n-        owner[i++] = *cur;\n-        cur++;\n+        i = 0;\n+        while (*cur != ' ') {\n+            if (i < 10)\n+                attrib[i++] = *cur;\n+            cur++;\n+            if (*cur == 0) return(0);\n+        }\n+        attrib[10] = 0;\n+        while (*cur == ' ') cur++;\n@@ -1646,9 +1636,3 @@\n-    }\n-    owner[i] = 0;\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    i = 0;\n-    while (*cur != ' ') {\n-        if (i < 10)\n-        group[i++] = *cur;\n-        cur++;\n+        while ((*cur >= '0') && (*cur <= '9'))\n+            links = (links * 10) + (*cur++ - '0');\n+        while (*cur == ' ') cur++;\n@@ -1656,13 +1640,19 @@\n-    }\n-    group[i] = 0;\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    while ((*cur >= '0') && (*cur <= '9'))\n-        size = (size * 10) + (*cur++ - '0');\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    i = 0;\n-    while (*cur != ' ') {\n-        if (i < 3)\n-        month[i++] = *cur;\n-        cur++;\n+        i = 0;\n+        while (*cur != ' ') {\n+            if (i < 10)\n+                owner[i++] = *cur;\n+            cur++;\n+            if (*cur == 0) return(0);\n+        }\n+        owner[i] = 0;\n+        while (*cur == ' ') cur++;\n+        if (*cur == 0) return(0);\n+        i = 0;\n+        while (*cur != ' ') {\n+            if (i < 10)\n+                group[i++] = *cur;\n+            cur++;\n+            if (*cur == 0) return(0);\n+        }\n+        group[i] = 0;\n+        while (*cur == ' ') cur++;\n@@ -1670,13 +1660,0 @@\n-    }\n-    month[i] = 0;\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-        while ((*cur >= '0') && (*cur <= '9'))\n-        day = (day * 10) + (*cur++ - '0');\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    if ((cur[1] == 0) || (cur[2] == 0)) return(0);\n-    if ((cur[1] == ':') || (cur[2] == ':')) {\n-        while ((*cur >= '0') && (*cur <= '9'))\n-        hour = (hour * 10) + (*cur++ - '0');\n-        if (*cur == ':') cur++;\n@@ -1684,2 +1661,13 @@\n-        minute = (minute * 10) + (*cur++ - '0');\n-    } else {\n+            size = (size * 10) + (*cur++ - '0');\n+        while (*cur == ' ') cur++;\n+        if (*cur == 0) return(0);\n+        i = 0;\n+        while (*cur != ' ') {\n+            if (i < 3)\n+                month[i++] = *cur;\n+            cur++;\n+            if (*cur == 0) return(0);\n+        }\n+        month[i] = 0;\n+        while (*cur == ' ') cur++;\n+        if (*cur == 0) return(0);\n@@ -1687,9 +1675,2 @@\n-        year = (year * 10) + (*cur++ - '0');\n-    }\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    i = 0;\n-    while ((*cur != '\\n')  && (*cur != '\\r')) {\n-        if (i < 150)\n-        filename[i++] = *cur;\n-        cur++;\n+            day = (day * 10) + (*cur++ - '0');\n+        while (*cur == ' ') cur++;\n@@ -1697,6 +1678,25 @@\n-    }\n-    filename[i] = 0;\n-    if ((*cur != '\\n') && (*cur != '\\r'))\n-        return(0);\n-    while ((*cur == '\\n')  || (*cur == '\\r'))\n-        cur++;\n+        if ((cur[1] == 0) || (cur[2] == 0)) return(0);\n+        if ((cur[1] == ':') || (cur[2] == ':')) {\n+            while ((*cur >= '0') && (*cur <= '9'))\n+                hour = (hour * 10) + (*cur++ - '0');\n+            if (*cur == ':') cur++;\n+            while ((*cur >= '0') && (*cur <= '9'))\n+                minute = (minute * 10) + (*cur++ - '0');\n+        } else {\n+            while ((*cur >= '0') && (*cur <= '9'))\n+                year = (year * 10) + (*cur++ - '0');\n+        }\n+        while (*cur == ' ') cur++;\n+        if (*cur == 0) return(0);\n+        i = 0;\n+        while ((*cur != '\\n')  && (*cur != '\\r')) {\n+            if (i < 150)\n+                filename[i++] = *cur;\n+            cur++;\n+            if (*cur == 0) return(0);\n+        }\n+        filename[i] = 0;\n+        if ((*cur != '\\n') && (*cur != '\\r'))\n+            return(0);\n+        while ((*cur == '\\n')  || (*cur == '\\r'))\n+            cur++;\n@@ -1706,1 +1706,1 @@\n-         year, month, day, hour, minute);\n+                 year, month, day, hour, minute);\n@@ -1726,1 +1726,1 @@\n-           const char *filename) {\n+               const char *filename) {\n@@ -1737,5 +1737,5 @@\n-        return(-1);\n-    ctxt->dataFd = xmlNanoFTPGetConnection(ctxt);\n-    if (ctxt->dataFd == INVALID_SOCKET)\n-        return(-1);\n-    snprintf(buf, sizeof(buf), \"LIST -L\\r\\n\");\n+            return(-1);\n+        ctxt->dataFd = xmlNanoFTPGetConnection(ctxt);\n+        if (ctxt->dataFd == INVALID_SOCKET)\n+            return(-1);\n+        snprintf(buf, sizeof(buf), \"LIST -L\\r\\n\");\n@@ -1743,8 +1743,8 @@\n-    if (filename[0] != '\/') {\n-        if (xmlNanoFTPCwd(ctxt, ctxt->path) < 1)\n-        return(-1);\n-    }\n-    ctxt->dataFd = xmlNanoFTPGetConnection(ctxt);\n-    if (ctxt->dataFd == INVALID_SOCKET)\n-        return(-1);\n-    snprintf(buf, sizeof(buf), \"LIST -L %s\\r\\n\", filename);\n+        if (filename[0] != '\/') {\n+            if (xmlNanoFTPCwd(ctxt, ctxt->path) < 1)\n+                return(-1);\n+        }\n+        ctxt->dataFd = xmlNanoFTPGetConnection(ctxt);\n+        if (ctxt->dataFd == INVALID_SOCKET)\n+            return(-1);\n+        snprintf(buf, sizeof(buf), \"LIST -L %s\\r\\n\", filename);\n@@ -1759,3 +1759,3 @@\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return(res);\n+        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n+        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+        return(res);\n@@ -1765,2 +1765,2 @@\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return(-res);\n+        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+        return(-res);\n@@ -1770,8 +1770,8 @@\n-    tv.tv_sec = 1;\n-    tv.tv_usec = 0;\n-    FD_ZERO(&rfd);\n-    FD_SET(ctxt->dataFd, &rfd);\n-    FD_ZERO(&efd);\n-    FD_SET(ctxt->dataFd, &efd);\n-    res = select(ctxt->dataFd + 1, &rfd, NULL, &efd, &tv);\n-    if (res < 0) {\n+        tv.tv_sec = 1;\n+        tv.tv_usec = 0;\n+        FD_ZERO(&rfd);\n+        FD_SET(ctxt->dataFd, &rfd);\n+        FD_ZERO(&efd);\n+        FD_SET(ctxt->dataFd, &efd);\n+        res = select(ctxt->dataFd + 1, &rfd, NULL, &efd, &tv);\n+        if (res < 0) {\n@@ -1779,1 +1779,1 @@\n-        perror(\"select\");\n+            perror(\"select\");\n@@ -1781,13 +1781,2 @@\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    if (res == 0) {\n-        res = xmlNanoFTPCheckResponse(ctxt);\n-        if (res < 0) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-        }\n-        if (res == 2) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return(0);\n+            closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+            return(-1);\n@@ -1795,0 +1784,11 @@\n+        if (res == 0) {\n+            res = xmlNanoFTPCheckResponse(ctxt);\n+            if (res < 0) {\n+                closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+                ctxt->dataFd = INVALID_SOCKET;\n+                return(-1);\n+            }\n+            if (res == 2) {\n+                closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+                return(0);\n+            }\n@@ -1796,2 +1796,2 @@\n-        continue;\n-    }\n+            continue;\n+        }\n@@ -1799,6 +1799,6 @@\n-    if ((len = recv(ctxt->dataFd, &buf[indx], sizeof(buf) - (indx + 1), 0)) < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"recv\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n+        if ((len = recv(ctxt->dataFd, &buf[indx], sizeof(buf) - (indx + 1), 0)) < 0) {\n+            __xmlIOErr(XML_FROM_FTP, 0, \"recv\");\n+            closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+            ctxt->dataFd = INVALID_SOCKET;\n+            return(-1);\n+        }\n@@ -1808,7 +1808,7 @@\n-    indx += len;\n-    buf[indx] = 0;\n-    base = 0;\n-    do {\n-        res = xmlNanoFTPParseList(&buf[base], callback, userData);\n-        base += res;\n-    } while (res > 0);\n+        indx += len;\n+        buf[indx] = 0;\n+        base = 0;\n+        do {\n+            res = xmlNanoFTPParseList(&buf[base], callback, userData);\n+            base += res;\n+        } while (res > 0);\n@@ -1816,2 +1816,2 @@\n-    memmove(&buf[0], &buf[base], indx - base);\n-    indx -= base;\n+        memmove(&buf[0], &buf[base], indx - base);\n+        indx -= base;\n@@ -1840,1 +1840,1 @@\n-    return INVALID_SOCKET;\n+        return INVALID_SOCKET;\n@@ -1842,1 +1842,1 @@\n-    return INVALID_SOCKET;\n+        return INVALID_SOCKET;\n@@ -1845,1 +1845,1 @@\n-    return INVALID_SOCKET;\n+        return INVALID_SOCKET;\n@@ -1854,3 +1854,3 @@\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return INVALID_SOCKET;\n+        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n+        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+        return INVALID_SOCKET;\n@@ -1860,2 +1860,2 @@\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return INVALID_SOCKET;\n+        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+        return INVALID_SOCKET;\n@@ -1864,1 +1864,1 @@\n-    snprintf(buf, sizeof(buf), \"RETR %s\\r\\n\", ctxt->path);\n+        snprintf(buf, sizeof(buf), \"RETR %s\\r\\n\", ctxt->path);\n@@ -1866,1 +1866,1 @@\n-    snprintf(buf, sizeof(buf), \"RETR %s\\r\\n\", filename);\n+        snprintf(buf, sizeof(buf), \"RETR %s\\r\\n\", filename);\n@@ -1874,3 +1874,3 @@\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return INVALID_SOCKET;\n+        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n+        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+        return INVALID_SOCKET;\n@@ -1880,2 +1880,2 @@\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return INVALID_SOCKET;\n+        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+        return INVALID_SOCKET;\n@@ -1901,1 +1901,1 @@\n-          const char *filename) {\n+              const char *filename) {\n@@ -1910,1 +1910,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1912,1 +1912,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1914,1 +1914,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1917,6 +1917,6 @@\n-    tv.tv_sec = 1;\n-    tv.tv_usec = 0;\n-    FD_ZERO(&rfd);\n-    FD_SET(ctxt->dataFd, &rfd);\n-    res = select(ctxt->dataFd + 1, &rfd, NULL, NULL, &tv);\n-    if (res < 0) {\n+        tv.tv_sec = 1;\n+        tv.tv_usec = 0;\n+        FD_ZERO(&rfd);\n+        FD_SET(ctxt->dataFd, &rfd);\n+        res = select(ctxt->dataFd + 1, &rfd, NULL, NULL, &tv);\n+        if (res < 0) {\n@@ -1924,1 +1924,1 @@\n-        perror(\"select\");\n+            perror(\"select\");\n@@ -1926,13 +1926,2 @@\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    if (res == 0) {\n-        res = xmlNanoFTPCheckResponse(ctxt);\n-        if (res < 0) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-        }\n-        if (res == 2) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return(0);\n+            closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+            return(-1);\n@@ -1940,0 +1929,11 @@\n+        if (res == 0) {\n+            res = xmlNanoFTPCheckResponse(ctxt);\n+            if (res < 0) {\n+                closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+                ctxt->dataFd = INVALID_SOCKET;\n+                return(-1);\n+            }\n+            if (res == 2) {\n+                closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+                return(0);\n+            }\n@@ -1941,4 +1941,8 @@\n-        continue;\n-    }\n-    if ((len = recv(ctxt->dataFd, buf, sizeof(buf), 0)) < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"recv failed\");\n+            continue;\n+        }\n+        if ((len = recv(ctxt->dataFd, buf, sizeof(buf), 0)) < 0) {\n+            __xmlIOErr(XML_FROM_FTP, 0, \"recv failed\");\n+            callback(userData, buf, len);\n+            closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n+            return(-1);\n+        }\n@@ -1946,4 +1950,0 @@\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    callback(userData, buf, len);\n@@ -1978,3 +1978,3 @@\n-    if (len < 0)\n-        __xmlIOErr(XML_FROM_FTP, 0, \"recv failed\");\n-    xmlNanoFTPCloseConnection(ctxt);\n+        if (len < 0)\n+            __xmlIOErr(XML_FROM_FTP, 0, \"recv failed\");\n+        xmlNanoFTPCloseConnection(ctxt);\n@@ -2009,2 +2009,2 @@\n-    xmlNanoFTPFreeCtxt(ctxt);\n-    return(NULL);\n+        xmlNanoFTPFreeCtxt(ctxt);\n+        return(NULL);\n@@ -2014,2 +2014,2 @@\n-    xmlNanoFTPFreeCtxt(ctxt);\n-    return(NULL);\n+        xmlNanoFTPFreeCtxt(ctxt);\n+        return(NULL);\n@@ -2034,1 +2034,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2037,2 +2037,2 @@\n-    closesocket(ctxt->dataFd);\n-    ctxt->dataFd = INVALID_SOCKET;\n+        closesocket(ctxt->dataFd);\n+        ctxt->dataFd = INVALID_SOCKET;\n@@ -2041,3 +2041,3 @@\n-    xmlNanoFTPQuit(ctxt);\n-    closesocket(ctxt->controlFd);\n-    ctxt->controlFd = INVALID_SOCKET;\n+        xmlNanoFTPQuit(ctxt);\n+        closesocket(ctxt->controlFd);\n+        ctxt->controlFd = INVALID_SOCKET;\n@@ -2051,3 +2051,3 @@\n- *                                  *\n- *          Basic test in Standalone mode           *\n- *                                  *\n+ *                                                                      *\n+ *                      Basic test in Standalone mode                   *\n+ *                                                                      *\n@@ -2057,2 +2057,2 @@\n-         const char *owner, const char *group, unsigned long size, int links,\n-         int year, const char *month, int day, int hour, int minute) {\n+             const char *owner, const char *group, unsigned long size, int links,\n+             int year, const char *month, int day, int hour, int minute) {\n@@ -2060,1 +2060,1 @@\n-        \"%s %s %s %ld %s\\n\", attrib, owner, group, size, filename);\n+            \"%s %s %s %ld %s\\n\", attrib, owner, group, size, filename);\n@@ -2066,2 +2066,2 @@\n-    fclose((FILE*)userData);\n-    return;\n+        fclose((FILE*)userData);\n+        return;\n@@ -2079,8 +2079,8 @@\n-    ctxt = xmlNanoFTPNewCtxt(argv[1]);\n-    if (xmlNanoFTPConnect(ctxt) < 0) {\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"Couldn't connect to %s\\n\", argv[1]);\n-        exit(1);\n-    }\n-    if (argc > 2)\n-        tstfile = argv[2];\n+        ctxt = xmlNanoFTPNewCtxt(argv[1]);\n+        if (xmlNanoFTPConnect(ctxt) < 0) {\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"Couldn't connect to %s\\n\", argv[1]);\n+            exit(1);\n+        }\n+        if (argc > 2)\n+            tstfile = argv[2];\n@@ -2088,1 +2088,1 @@\n-    ctxt = xmlNanoFTPConnectTo(\"localhost\", 0);\n+        ctxt = xmlNanoFTPConnectTo(\"localhost\", 0);\n@@ -2091,1 +2091,1 @@\n-        \"Couldn't connect to localhost\\n\");\n+                \"Couldn't connect to localhost\\n\");\n@@ -2097,3 +2097,3 @@\n-    if (xmlNanoFTPGet(ctxt, ftpData, (void *) output, tstfile) < 0)\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"Failed to get file\\n\");\n+        if (xmlNanoFTPGet(ctxt, ftpData, (void *) output, tstfile) < 0)\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"Failed to get file\\n\");\n@@ -2112,1 +2112,1 @@\n-        \"%s : FTP support not compiled in\\n\", argv[0]);\n+            \"%s : FTP support not compiled in\\n\", argv[0]);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/nanoftp.c","additions":723,"deletions":723,"binary":false,"changes":1446,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-#define XML_NANO_HTTP_CHUNK 4096\n+#define XML_NANO_HTTP_CHUNK     4096\n@@ -120,3 +120,3 @@\n-#define XML_NANO_HTTP_WRITE 1\n-#define XML_NANO_HTTP_READ  2\n-#define XML_NANO_HTTP_NONE  4\n+#define XML_NANO_HTTP_WRITE     1\n+#define XML_NANO_HTTP_READ      2\n+#define XML_NANO_HTTP_NONE      4\n@@ -125,15 +125,15 @@\n-    char *protocol; \/* the protocol name *\/\n-    char *hostname; \/* the host name *\/\n-    int port;       \/* the port *\/\n-    char *path;     \/* the path within the URL *\/\n-    char *query;    \/* the query string *\/\n-    SOCKET fd;      \/* the file descriptor for the socket *\/\n-    int state;      \/* WRITE \/ READ \/ CLOSED *\/\n-    char *out;      \/* buffer sent (zero terminated) *\/\n-    char *outptr;   \/* index within the buffer sent *\/\n-    char *in;       \/* the receiving buffer *\/\n-    char *content;  \/* the start of the content *\/\n-    char *inptr;    \/* the next byte to read from network *\/\n-    char *inrptr;   \/* the next byte to give back to the client *\/\n-    int inlen;      \/* len of the input buffer *\/\n-    int last;       \/* return code for last operation *\/\n+    char *protocol;     \/* the protocol name *\/\n+    char *hostname;     \/* the host name *\/\n+    int port;           \/* the port *\/\n+    char *path;         \/* the path within the URL *\/\n+    char *query;        \/* the query string *\/\n+    SOCKET fd;          \/* the file descriptor for the socket *\/\n+    int state;          \/* WRITE \/ READ \/ CLOSED *\/\n+    char *out;          \/* buffer sent (zero terminated) *\/\n+    char *outptr;       \/* index within the buffer sent *\/\n+    char *in;           \/* the receiving buffer *\/\n+    char *content;      \/* the start of the content *\/\n+    char *inptr;        \/* the next byte to read from network *\/\n+    char *inrptr;       \/* the next byte to give back to the client *\/\n+    int inlen;          \/* len of the input buffer *\/\n+    int last;           \/* return code for last operation *\/\n@@ -144,1 +144,1 @@\n-    char *location; \/* the new URL in case of redirect *\/\n+    char *location;     \/* the new URL in case of redirect *\/\n@@ -146,2 +146,2 @@\n-    char *encoding; \/* encoding extracted from the contentType *\/\n-    char *mimeType; \/* Mime-Type extracted from the contentType *\/\n+    char *encoding;     \/* encoding extracted from the contentType *\/\n+    char *mimeType;     \/* Mime-Type extracted from the contentType *\/\n@@ -149,2 +149,2 @@\n-    z_stream *strm; \/* Zlib stream object *\/\n-    int usesGzip;   \/* \"Content-Encoding: gzip\" was detected *\/\n+    z_stream *strm;     \/* Zlib stream object *\/\n+    int usesGzip;       \/* \"Content-Encoding: gzip\" was detected *\/\n@@ -155,1 +155,1 @@\n-static char *proxy = NULL;   \/* the proxy name if any *\/\n+static char *proxy = NULL;       \/* the proxy name if any *\/\n@@ -205,2 +205,2 @@\n-    close (s);\n-    return (1);\n+        close (s);\n+        return (1);\n@@ -227,1 +227,1 @@\n-    return;\n+        return;\n@@ -231,1 +231,1 @@\n-    return;\n+        return;\n@@ -235,14 +235,14 @@\n-    proxyPort = 80;\n-    env = getenv(\"no_proxy\");\n-    if (env && ((env[0] == '*') && (env[1] == 0)))\n-        goto done;\n-    env = getenv(\"http_proxy\");\n-    if (env != NULL) {\n-        xmlNanoHTTPScanProxy(env);\n-        goto done;\n-    }\n-    env = getenv(\"HTTP_PROXY\");\n-    if (env != NULL) {\n-        xmlNanoHTTPScanProxy(env);\n-        goto done;\n-    }\n+        proxyPort = 80;\n+        env = getenv(\"no_proxy\");\n+        if (env && ((env[0] == '*') && (env[1] == 0)))\n+            goto done;\n+        env = getenv(\"http_proxy\");\n+        if (env != NULL) {\n+            xmlNanoHTTPScanProxy(env);\n+            goto done;\n+        }\n+        env = getenv(\"HTTP_PROXY\");\n+        if (env != NULL) {\n+            xmlNanoHTTPScanProxy(env);\n+            goto done;\n+        }\n@@ -263,2 +263,2 @@\n-    xmlFree(proxy);\n-    proxy = NULL;\n+        xmlFree(proxy);\n+        proxy = NULL;\n@@ -268,1 +268,1 @@\n-    WSACleanup();\n+        WSACleanup();\n@@ -293,1 +293,1 @@\n-    ctxt->protocol = NULL;\n+        ctxt->protocol = NULL;\n@@ -297,1 +297,1 @@\n-    ctxt->hostname = NULL;\n+        ctxt->hostname = NULL;\n@@ -301,1 +301,1 @@\n-    ctxt->path = NULL;\n+        ctxt->path = NULL;\n@@ -305,1 +305,1 @@\n-    ctxt->query = NULL;\n+        ctxt->query = NULL;\n@@ -311,1 +311,1 @@\n-    return;\n+        return;\n@@ -314,2 +314,2 @@\n-    xmlFreeURI(uri);\n-    return;\n+        xmlFreeURI(uri);\n+        return;\n@@ -322,2 +322,4 @@\n-    if ((len > 2) && (uri->server[len - 1] == ']')) {\n-        ctxt->hostname = (char *) xmlCharStrndup(uri->server + 1, len -2);\n+        if ((len > 2) && (uri->server[len - 1] == ']')) {\n+            ctxt->hostname = (char *) xmlCharStrndup(uri->server + 1, len -2);\n+        } else\n+            ctxt->hostname = xmlMemStrdup(uri->server);\n@@ -326,2 +328,0 @@\n-    } else\n-    ctxt->hostname = xmlMemStrdup(uri->server);\n@@ -329,1 +329,1 @@\n-    ctxt->path = xmlMemStrdup(uri->path);\n+        ctxt->path = xmlMemStrdup(uri->path);\n@@ -331,1 +331,1 @@\n-    ctxt->path = xmlMemStrdup(\"\/\");\n+        ctxt->path = xmlMemStrdup(\"\/\");\n@@ -333,1 +333,1 @@\n-    ctxt->query = xmlMemStrdup(uri->query);\n+        ctxt->query = xmlMemStrdup(uri->query);\n@@ -335,1 +335,1 @@\n-    ctxt->port = uri->port;\n+        ctxt->port = uri->port;\n@@ -356,1 +356,1 @@\n-    proxy = NULL;\n+        proxy = NULL;\n@@ -362,2 +362,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"Removing HTTP proxy info\\n\");\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"Removing HTTP proxy info\\n\");\n@@ -365,2 +365,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"Using HTTP proxy %s\\n\", URL);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"Using HTTP proxy %s\\n\", URL);\n@@ -372,5 +372,5 @@\n-    (strcmp(uri->scheme, \"http\")) || (uri->server == NULL)) {\n-    __xmlIOErr(XML_FROM_HTTP, XML_HTTP_URL_SYNTAX, \"Syntax Error\\n\");\n-    if (uri != NULL)\n-        xmlFreeURI(uri);\n-    return;\n+        (strcmp(uri->scheme, \"http\")) || (uri->server == NULL)) {\n+        __xmlIOErr(XML_FROM_HTTP, XML_HTTP_URL_SYNTAX, \"Syntax Error\\n\");\n+        if (uri != NULL)\n+            xmlFreeURI(uri);\n+        return;\n@@ -381,1 +381,1 @@\n-    proxyPort = uri->port;\n+        proxyPort = uri->port;\n@@ -439,2 +439,2 @@\n-    inflateEnd(ctxt->strm);\n-    xmlFree(ctxt->strm);\n+        inflateEnd(ctxt->strm);\n+        xmlFree(ctxt->strm);\n@@ -666,7 +666,11 @@\n-    if (ctxt->inrptr == ctxt->inptr) {\n-        if ( (rc = xmlNanoHTTPRecv(ctxt)) == 0) {\n-        if (bp == buf)\n-            return(NULL);\n-        else\n-            *bp = 0;\n-        return(xmlMemStrdup(buf));\n+        if (ctxt->inrptr == ctxt->inptr) {\n+            if ( (rc = xmlNanoHTTPRecv(ctxt)) == 0) {\n+                if (bp == buf)\n+                    return(NULL);\n+                else\n+                    *bp = 0;\n+                return(xmlMemStrdup(buf));\n+            }\n+            else if ( rc == -1 ) {\n+                return ( NULL );\n+            }\n@@ -674,2 +678,4 @@\n-        else if ( rc == -1 ) {\n-            return ( NULL );\n+        *bp = *ctxt->inrptr++;\n+        if (*bp == '\\n') {\n+            *bp = 0;\n+            return(xmlMemStrdup(buf));\n@@ -677,8 +683,2 @@\n-    }\n-    *bp = *ctxt->inrptr++;\n-    if (*bp == '\\n') {\n-        *bp = 0;\n-        return(xmlMemStrdup(buf));\n-    }\n-    if (*bp != '\\r')\n-        bp++;\n+        if (*bp != '\\r')\n+            bp++;\n@@ -713,1 +713,1 @@\n-    int ret = 0;\n+        int ret = 0;\n@@ -715,12 +715,5 @@\n-    cur += 5;\n-    while ((*cur >= '0') && (*cur <= '9')) {\n-        version *= 10;\n-        version += *cur - '0';\n-        cur++;\n-    }\n-    if (*cur == '.') {\n-        cur++;\n-        if ((*cur >= '0') && (*cur <= '9')) {\n-        version *= 10;\n-        version += *cur - '0';\n-        cur++;\n+        cur += 5;\n+        while ((*cur >= '0') && (*cur <= '9')) {\n+            version *= 10;\n+            version += *cur - '0';\n+            cur++;\n@@ -728,14 +721,21 @@\n-        while ((*cur >= '0') && (*cur <= '9'))\n-        cur++;\n-    } else\n-        version *= 10;\n-    if ((*cur != ' ') && (*cur != '\\t')) return;\n-    while ((*cur == ' ') || (*cur == '\\t')) cur++;\n-    if ((*cur < '0') || (*cur > '9')) return;\n-    while ((*cur >= '0') && (*cur <= '9')) {\n-        ret *= 10;\n-        ret += *cur - '0';\n-        cur++;\n-    }\n-    if ((*cur != 0) && (*cur != ' ') && (*cur != '\\t')) return;\n-    ctxt->returnValue = ret;\n+        if (*cur == '.') {\n+            cur++;\n+            if ((*cur >= '0') && (*cur <= '9')) {\n+                version *= 10;\n+                version += *cur - '0';\n+                cur++;\n+            }\n+            while ((*cur >= '0') && (*cur <= '9'))\n+                cur++;\n+        } else\n+            version *= 10;\n+        if ((*cur != ' ') && (*cur != '\\t')) return;\n+        while ((*cur == ' ') || (*cur == '\\t')) cur++;\n+        if ((*cur < '0') || (*cur > '9')) return;\n+        while ((*cur >= '0') && (*cur <= '9')) {\n+            ret *= 10;\n+            ret += *cur - '0';\n+            cur++;\n+        }\n+        if ((*cur != 0) && (*cur != ' ') && (*cur != '\\t')) return;\n+        ctxt->returnValue = ret;\n@@ -746,16 +746,6 @@\n-    while ((*cur == ' ') || (*cur == '\\t')) cur++;\n-    if (ctxt->contentType != NULL)\n-        xmlFree(ctxt->contentType);\n-    ctxt->contentType = xmlMemStrdup(cur);\n-    mime = (const xmlChar *) cur;\n-    last = mime;\n-    while ((*last != 0) && (*last != ' ') && (*last != '\\t') &&\n-           (*last != ';') && (*last != ','))\n-        last++;\n-    if (ctxt->mimeType != NULL)\n-        xmlFree(ctxt->mimeType);\n-    ctxt->mimeType = (char *) xmlStrndup(mime, last - mime);\n-    charset = xmlStrstr(BAD_CAST ctxt->contentType, BAD_CAST \"charset=\");\n-    if (charset != NULL) {\n-        charset += 8;\n-        last = charset;\n+        while ((*cur == ' ') || (*cur == '\\t')) cur++;\n+        if (ctxt->contentType != NULL)\n+            xmlFree(ctxt->contentType);\n+        ctxt->contentType = xmlMemStrdup(cur);\n+        mime = (const xmlChar *) cur;\n+        last = mime;\n@@ -764,5 +754,15 @@\n-        last++;\n-        if (ctxt->encoding != NULL)\n-            xmlFree(ctxt->encoding);\n-        ctxt->encoding = (char *) xmlStrndup(charset, last - charset);\n-    }\n+            last++;\n+        if (ctxt->mimeType != NULL)\n+            xmlFree(ctxt->mimeType);\n+        ctxt->mimeType = (char *) xmlStrndup(mime, last - mime);\n+        charset = xmlStrstr(BAD_CAST ctxt->contentType, BAD_CAST \"charset=\");\n+        if (charset != NULL) {\n+            charset += 8;\n+            last = charset;\n+            while ((*last != 0) && (*last != ' ') && (*last != '\\t') &&\n+                   (*last != ';') && (*last != ','))\n+                last++;\n+            if (ctxt->encoding != NULL)\n+                xmlFree(ctxt->encoding);\n+            ctxt->encoding = (char *) xmlStrndup(charset, last - charset);\n+        }\n@@ -772,15 +772,5 @@\n-    if (ctxt->contentType != NULL) return;\n-    while ((*cur == ' ') || (*cur == '\\t')) cur++;\n-    ctxt->contentType = xmlMemStrdup(cur);\n-    mime = (const xmlChar *) cur;\n-    last = mime;\n-    while ((*last != 0) && (*last != ' ') && (*last != '\\t') &&\n-           (*last != ';') && (*last != ','))\n-        last++;\n-    if (ctxt->mimeType != NULL)\n-        xmlFree(ctxt->mimeType);\n-    ctxt->mimeType = (char *) xmlStrndup(mime, last - mime);\n-    charset = xmlStrstr(BAD_CAST ctxt->contentType, BAD_CAST \"charset=\");\n-    if (charset != NULL) {\n-        charset += 8;\n-        last = charset;\n+        if (ctxt->contentType != NULL) return;\n+        while ((*cur == ' ') || (*cur == '\\t')) cur++;\n+        ctxt->contentType = xmlMemStrdup(cur);\n+        mime = (const xmlChar *) cur;\n+        last = mime;\n@@ -789,5 +779,15 @@\n-        last++;\n-        if (ctxt->encoding != NULL)\n-            xmlFree(ctxt->encoding);\n-        ctxt->encoding = (char *) xmlStrndup(charset, last - charset);\n-    }\n+            last++;\n+        if (ctxt->mimeType != NULL)\n+            xmlFree(ctxt->mimeType);\n+        ctxt->mimeType = (char *) xmlStrndup(mime, last - mime);\n+        charset = xmlStrstr(BAD_CAST ctxt->contentType, BAD_CAST \"charset=\");\n+        if (charset != NULL) {\n+            charset += 8;\n+            last = charset;\n+            while ((*last != 0) && (*last != ' ') && (*last != '\\t') &&\n+                   (*last != ';') && (*last != ','))\n+                last++;\n+            if (ctxt->encoding != NULL)\n+                xmlFree(ctxt->encoding);\n+            ctxt->encoding = (char *) xmlStrndup(charset, last - charset);\n+        }\n@@ -796,12 +796,12 @@\n-    while ((*cur == ' ') || (*cur == '\\t')) cur++;\n-    if (ctxt->location != NULL)\n-        xmlFree(ctxt->location);\n-    if (*cur == '\/') {\n-        xmlChar *tmp_http = xmlStrdup(BAD_CAST \"http:\/\/\");\n-        xmlChar *tmp_loc =\n-            xmlStrcat(tmp_http, (const xmlChar *) ctxt->hostname);\n-        ctxt->location =\n-            (char *) xmlStrcat (tmp_loc, (const xmlChar *) cur);\n-    } else {\n-        ctxt->location = xmlMemStrdup(cur);\n-    }\n+        while ((*cur == ' ') || (*cur == '\\t')) cur++;\n+        if (ctxt->location != NULL)\n+            xmlFree(ctxt->location);\n+        if (*cur == '\/') {\n+            xmlChar *tmp_http = xmlStrdup(BAD_CAST \"http:\/\/\");\n+            xmlChar *tmp_loc =\n+                xmlStrcat(tmp_http, (const xmlChar *) ctxt->hostname);\n+            ctxt->location =\n+                (char *) xmlStrcat (tmp_loc, (const xmlChar *) cur);\n+        } else {\n+            ctxt->location = xmlMemStrdup(cur);\n+        }\n@@ -810,4 +810,4 @@\n-    while ((*cur == ' ') || (*cur == '\\t')) cur++;\n-    if (ctxt->authHeader != NULL)\n-        xmlFree(ctxt->authHeader);\n-    ctxt->authHeader = xmlMemStrdup(cur);\n+        while ((*cur == ' ') || (*cur == '\\t')) cur++;\n+        if (ctxt->authHeader != NULL)\n+            xmlFree(ctxt->authHeader);\n+        ctxt->authHeader = xmlMemStrdup(cur);\n@@ -816,4 +816,4 @@\n-    while ((*cur == ' ') || (*cur == '\\t')) cur++;\n-    if (ctxt->authHeader != NULL)\n-        xmlFree(ctxt->authHeader);\n-    ctxt->authHeader = xmlMemStrdup(cur);\n+        while ((*cur == ' ') || (*cur == '\\t')) cur++;\n+        if (ctxt->authHeader != NULL)\n+            xmlFree(ctxt->authHeader);\n+        ctxt->authHeader = xmlMemStrdup(cur);\n@@ -822,4 +822,4 @@\n-    cur += 17;\n-    while ((*cur == ' ') || (*cur == '\\t')) cur++;\n-    if ( !xmlStrncasecmp( BAD_CAST cur, BAD_CAST\"gzip\", 4) ) {\n-        ctxt->usesGzip = 1;\n+        cur += 17;\n+        while ((*cur == ' ') || (*cur == '\\t')) cur++;\n+        if ( !xmlStrncasecmp( BAD_CAST cur, BAD_CAST\"gzip\", 4) ) {\n+            ctxt->usesGzip = 1;\n@@ -827,1 +827,1 @@\n-        ctxt->strm = xmlMalloc(sizeof(z_stream));\n+            ctxt->strm = xmlMalloc(sizeof(z_stream));\n@@ -829,6 +829,6 @@\n-        if (ctxt->strm != NULL) {\n-        ctxt->strm->zalloc = Z_NULL;\n-        ctxt->strm->zfree = Z_NULL;\n-        ctxt->strm->opaque = Z_NULL;\n-        ctxt->strm->avail_in = 0;\n-        ctxt->strm->next_in = Z_NULL;\n+            if (ctxt->strm != NULL) {\n+                ctxt->strm->zalloc = Z_NULL;\n+                ctxt->strm->zfree = Z_NULL;\n+                ctxt->strm->opaque = Z_NULL;\n+                ctxt->strm->avail_in = 0;\n+                ctxt->strm->next_in = Z_NULL;\n@@ -836,1 +836,2 @@\n-        inflateInit2( ctxt->strm, 31 );\n+                inflateInit2( ctxt->strm, 31 );\n+            }\n@@ -838,1 +839,0 @@\n-    }\n@@ -841,2 +841,2 @@\n-    cur += 15;\n-    ctxt->ContentLength = strtol( cur, NULL, 10 );\n+        cur += 15;\n+        ctxt->ContentLength = strtol( cur, NULL, 10 );\n@@ -1065,3 +1065,3 @@\n-    if (!(_res.options & RES_INIT))\n-        res_init();\n-    _res.options |= RES_USE_INET6;\n+        if (!(_res.options & RES_INIT))\n+            res_init();\n+        _res.options |= RES_USE_INET6;\n@@ -1076,2 +1076,2 @@\n-    int status;\n-    struct addrinfo hints, *res, *result;\n+        int status;\n+        struct addrinfo hints, *res, *result;\n@@ -1079,3 +1079,3 @@\n-    result = NULL;\n-    memset (&hints, 0,sizeof(hints));\n-    hints.ai_socktype = SOCK_STREAM;\n+        result = NULL;\n+        memset (&hints, 0,sizeof(hints));\n+        hints.ai_socktype = SOCK_STREAM;\n@@ -1083,21 +1083,3 @@\n-    status = getaddrinfo (host, NULL, &hints, &result);\n-    if (status) {\n-        __xmlIOErr(XML_FROM_HTTP, 0, \"getaddrinfo failed\\n\");\n-        return INVALID_SOCKET;\n-    }\n-\n-    for (res = result; res; res = res->ai_next) {\n-        if (res->ai_family == AF_INET) {\n-        if ((size_t)res->ai_addrlen > sizeof(sockin)) {\n-            __xmlIOErr(XML_FROM_HTTP, 0, \"address size mismatch\\n\");\n-            freeaddrinfo (result);\n-            return INVALID_SOCKET;\n-        }\n-        memcpy (&sockin, res->ai_addr, res->ai_addrlen);\n-        sockin.sin_port = htons (port);\n-        addr = (struct sockaddr *)&sockin;\n-#ifdef SUPPORT_IP6\n-        } else if (have_ipv6 () && (res->ai_family == AF_INET6)) {\n-        if ((size_t)res->ai_addrlen > sizeof(sockin6)) {\n-            __xmlIOErr(XML_FROM_HTTP, 0, \"address size mismatch\\n\");\n-            freeaddrinfo (result);\n+        status = getaddrinfo (host, NULL, &hints, &result);\n+        if (status) {\n+            __xmlIOErr(XML_FROM_HTTP, 0, \"getaddrinfo failed\\n\");\n@@ -1106,6 +1088,0 @@\n-        memcpy (&sockin6, res->ai_addr, res->ai_addrlen);\n-        sockin6.sin6_port = htons (port);\n-        addr = (struct sockaddr *)&sockin6;\n-#endif\n-        } else\n-        continue;              \/* for *\/\n@@ -1113,4 +1089,29 @@\n-        s = xmlNanoHTTPConnectAttempt (addr);\n-        if (s != INVALID_SOCKET) {\n-        freeaddrinfo (result);\n-        return (s);\n+        for (res = result; res; res = res->ai_next) {\n+            if (res->ai_family == AF_INET) {\n+                if ((size_t)res->ai_addrlen > sizeof(sockin)) {\n+                    __xmlIOErr(XML_FROM_HTTP, 0, \"address size mismatch\\n\");\n+                    freeaddrinfo (result);\n+                    return INVALID_SOCKET;\n+                }\n+                memcpy (&sockin, res->ai_addr, res->ai_addrlen);\n+                sockin.sin_port = htons (port);\n+                addr = (struct sockaddr *)&sockin;\n+#ifdef SUPPORT_IP6\n+            } else if (have_ipv6 () && (res->ai_family == AF_INET6)) {\n+                if ((size_t)res->ai_addrlen > sizeof(sockin6)) {\n+                    __xmlIOErr(XML_FROM_HTTP, 0, \"address size mismatch\\n\");\n+                    freeaddrinfo (result);\n+                    return INVALID_SOCKET;\n+                }\n+                memcpy (&sockin6, res->ai_addr, res->ai_addrlen);\n+                sockin6.sin6_port = htons (port);\n+                addr = (struct sockaddr *)&sockin6;\n+#endif\n+            } else\n+                continue;              \/* for *\/\n+\n+            s = xmlNanoHTTPConnectAttempt (addr);\n+            if (s != INVALID_SOCKET) {\n+                freeaddrinfo (result);\n+                return (s);\n+            }\n@@ -1118,1 +1119,0 @@\n-    }\n@@ -1120,2 +1120,2 @@\n-    if (result)\n-        freeaddrinfo (result);\n+        if (result)\n+            freeaddrinfo (result);\n@@ -1133,2 +1133,2 @@\n-    h = gethostbyname (GETHOSTBYNAME_ARG_CAST host);\n-    if (h == NULL) {\n+        h = gethostbyname (GETHOSTBYNAME_ARG_CAST host);\n+        if (h == NULL) {\n@@ -1142,1 +1142,1 @@\n-        const char *h_err_txt = \"\";\n+            const char *h_err_txt = \"\";\n@@ -1144,4 +1144,4 @@\n-        switch (h_errno) {\n-        case HOST_NOT_FOUND:\n-            h_err_txt = \"Authoritative host not found\";\n-            break;\n+            switch (h_errno) {\n+                case HOST_NOT_FOUND:\n+                    h_err_txt = \"Authoritative host not found\";\n+                    break;\n@@ -1149,4 +1149,4 @@\n-        case TRY_AGAIN:\n-            h_err_txt =\n-            \"Non-authoritative host not found or server failure.\";\n-            break;\n+                case TRY_AGAIN:\n+                    h_err_txt =\n+                        \"Non-authoritative host not found or server failure.\";\n+                    break;\n@@ -1154,4 +1154,4 @@\n-        case NO_RECOVERY:\n-            h_err_txt =\n-            \"Non-recoverable errors:  FORMERR, REFUSED, or NOTIMP.\";\n-            break;\n+                case NO_RECOVERY:\n+                    h_err_txt =\n+                        \"Non-recoverable errors:  FORMERR, REFUSED, or NOTIMP.\";\n+                    break;\n@@ -1160,4 +1160,4 @@\n-        case NO_ADDRESS:\n-            h_err_txt =\n-            \"Valid name, no data record of requested type.\";\n-            break;\n+                case NO_ADDRESS:\n+                    h_err_txt =\n+                        \"Valid name, no data record of requested type.\";\n+                    break;\n@@ -1166,5 +1166,5 @@\n-        default:\n-            h_err_txt = \"No error text defined.\";\n-            break;\n-        }\n-        __xmlIOErr(XML_FROM_HTTP, 0, h_err_txt);\n+                default:\n+                    h_err_txt = \"No error text defined.\";\n+                    break;\n+            }\n+            __xmlIOErr(XML_FROM_HTTP, 0, h_err_txt);\n@@ -1172,1 +1172,1 @@\n-        __xmlIOErr(XML_FROM_HTTP, 0, \"Failed to resolve host\");\n+            __xmlIOErr(XML_FROM_HTTP, 0, \"Failed to resolve host\");\n@@ -1174,8 +1174,0 @@\n-        return INVALID_SOCKET;\n-    }\n-\n-    for (i = 0; h->h_addr_list[i]; i++) {\n-        if (h->h_addrtype == AF_INET) {\n-        \/* A records (IPv4) *\/\n-        if ((unsigned int) h->h_length > sizeof(ia)) {\n-            __xmlIOErr(XML_FROM_HTTP, 0, \"address size mismatch\\n\");\n@@ -1184,5 +1176,13 @@\n-        memcpy (&ia, h->h_addr_list[i], h->h_length);\n-        sockin.sin_family = h->h_addrtype;\n-        sockin.sin_addr = ia;\n-        sockin.sin_port = (unsigned short)htons ((unsigned short)port);\n-        addr = (struct sockaddr *) &sockin;\n+\n+        for (i = 0; h->h_addr_list[i]; i++) {\n+            if (h->h_addrtype == AF_INET) {\n+                \/* A records (IPv4) *\/\n+                if ((unsigned int) h->h_length > sizeof(ia)) {\n+                    __xmlIOErr(XML_FROM_HTTP, 0, \"address size mismatch\\n\");\n+                    return INVALID_SOCKET;\n+                }\n+                memcpy (&ia, h->h_addr_list[i], h->h_length);\n+                sockin.sin_family = h->h_addrtype;\n+                sockin.sin_addr = ia;\n+                sockin.sin_port = (unsigned short)htons ((unsigned short)port);\n+                addr = (struct sockaddr *) &sockin;\n@@ -1190,5 +1190,18 @@\n-        } else if (have_ipv6 () && (h->h_addrtype == AF_INET6)) {\n-        \/* AAAA records (IPv6) *\/\n-        if ((unsigned int) h->h_length > sizeof(ia6)) {\n-            __xmlIOErr(XML_FROM_HTTP, 0, \"address size mismatch\\n\");\n-            return INVALID_SOCKET;\n+            } else if (have_ipv6 () && (h->h_addrtype == AF_INET6)) {\n+                \/* AAAA records (IPv6) *\/\n+                if ((unsigned int) h->h_length > sizeof(ia6)) {\n+                    __xmlIOErr(XML_FROM_HTTP, 0, \"address size mismatch\\n\");\n+                    return INVALID_SOCKET;\n+                }\n+                memcpy (&ia6, h->h_addr_list[i], h->h_length);\n+                sockin6.sin6_family = h->h_addrtype;\n+                sockin6.sin6_addr = ia6;\n+                sockin6.sin6_port = htons (port);\n+                addr = (struct sockaddr *) &sockin6;\n+#endif\n+            } else\n+                break;              \/* for *\/\n+\n+            s = xmlNanoHTTPConnectAttempt (addr);\n+            if (s != INVALID_SOCKET)\n+                return (s);\n@@ -1196,13 +1209,0 @@\n-        memcpy (&ia6, h->h_addr_list[i], h->h_length);\n-        sockin6.sin6_family = h->h_addrtype;\n-        sockin6.sin6_addr = ia6;\n-        sockin6.sin6_port = htons (port);\n-        addr = (struct sockaddr *) &sockin6;\n-#endif\n-        } else\n-        break;              \/* for *\/\n-\n-        s = xmlNanoHTTPConnectAttempt (addr);\n-        if (s != INVALID_SOCKET)\n-        return (s);\n-    }\n@@ -1292,1 +1292,1 @@\n-    ctxt->strm->avail_in = ctxt->inptr - ctxt->inrptr;\n+        ctxt->strm->avail_in = ctxt->inptr - ctxt->inrptr;\n@@ -1295,1 +1295,1 @@\n-           (ctxt->strm->avail_in > 0 || xmlNanoHTTPRecv(ctxt) > 0)) {\n+               (ctxt->strm->avail_in > 0 || xmlNanoHTTPRecv(ctxt) > 0)) {\n@@ -1297,1 +1297,1 @@\n-                ctxt->inptr - ctxt->inrptr - bytes_read;\n+                            ctxt->inptr - ctxt->inrptr - bytes_read;\n@@ -1304,1 +1304,1 @@\n-    }\n+        }\n@@ -1358,1 +1358,1 @@\n-          const char *headers, int ilen ) {\n+                  const char *headers, int ilen ) {\n@@ -1375,3 +1375,3 @@\n-    ctxt = xmlNanoHTTPNewCtxt(URL);\n-    if (ctxt == NULL)\n-        return(NULL);\n+        ctxt = xmlNanoHTTPNewCtxt(URL);\n+        if (ctxt == NULL)\n+            return(NULL);\n@@ -1379,4 +1379,4 @@\n-    ctxt = xmlNanoHTTPNewCtxt(redirURL);\n-    if (ctxt == NULL)\n-        return(NULL);\n-    ctxt->location = xmlMemStrdup(redirURL);\n+        ctxt = xmlNanoHTTPNewCtxt(redirURL);\n+        if (ctxt == NULL)\n+            return(NULL);\n+        ctxt->location = xmlMemStrdup(redirURL);\n@@ -1386,1 +1386,1 @@\n-    __xmlIOErr(XML_FROM_HTTP, XML_HTTP_URL_SYNTAX, \"Not a valid HTTP URI\");\n+        __xmlIOErr(XML_FROM_HTTP, XML_HTTP_URL_SYNTAX, \"Not a valid HTTP URI\");\n@@ -1388,1 +1388,1 @@\n-    if (redirURL != NULL) xmlFree(redirURL);\n+        if (redirURL != NULL) xmlFree(redirURL);\n@@ -1392,2 +1392,2 @@\n-    __xmlIOErr(XML_FROM_HTTP, XML_HTTP_UNKNOWN_HOST,\n-               \"Failed to identify host in URI\");\n+        __xmlIOErr(XML_FROM_HTTP, XML_HTTP_UNKNOWN_HOST,\n+                   \"Failed to identify host in URI\");\n@@ -1395,1 +1395,1 @@\n-    if (redirURL != NULL) xmlFree(redirURL);\n+        if (redirURL != NULL) xmlFree(redirURL);\n@@ -1399,2 +1399,2 @@\n-    blen = strlen(ctxt->hostname) * 2 + 16;\n-    ret = xmlNanoHTTPConnectHost(proxy, proxyPort);\n+        blen = strlen(ctxt->hostname) * 2 + 16;\n+        ret = xmlNanoHTTPConnectHost(proxy, proxyPort);\n@@ -1403,2 +1403,2 @@\n-    blen = strlen(ctxt->hostname);\n-    ret = xmlNanoHTTPConnectHost(ctxt->hostname, ctxt->port);\n+        blen = strlen(ctxt->hostname);\n+        ret = xmlNanoHTTPConnectHost(ctxt->hostname, ctxt->port);\n@@ -1408,1 +1408,1 @@\n-    if (redirURL != NULL) xmlFree(redirURL);\n+        if (redirURL != NULL) xmlFree(redirURL);\n@@ -1414,1 +1414,1 @@\n-    ilen = 0;\n+        ilen = 0;\n@@ -1416,1 +1416,1 @@\n-    blen += 36;\n+        blen += 36;\n@@ -1419,1 +1419,1 @@\n-    blen += strlen(headers) + 2;\n+        blen += strlen(headers) + 2;\n@@ -1421,2 +1421,2 @@\n-    \/* reserve for string plus 'Content-Type: \\r\\n\" *\/\n-    blen += strlen(*contentType) + 16;\n+        \/* reserve for string plus 'Content-Type: \\r\\n\" *\/\n+        blen += strlen(*contentType) + 16;\n@@ -1424,2 +1424,2 @@\n-    \/* 1 for '?' *\/\n-    blen += strlen(ctxt->query) + 1;\n+        \/* 1 for '?' *\/\n+        blen += strlen(ctxt->query) + 1;\n@@ -1432,5 +1432,5 @@\n-    \/* reserve space for ':xxxxx', incl. potential proxy *\/\n-    if (proxy)\n-        blen += 17;\n-    else\n-        blen += 11;\n+        \/* reserve space for ':xxxxx', incl. potential proxy *\/\n+        if (proxy)\n+            blen += 17;\n+        else\n+            blen += 11;\n@@ -1441,2 +1441,2 @@\n-    xmlHTTPErrMemory(\"allocating header buffer\");\n-    return ( NULL );\n+        xmlHTTPErrMemory(\"allocating header buffer\");\n+        return ( NULL );\n@@ -1448,8 +1448,8 @@\n-    if (ctxt->port != 80) {\n-        p += snprintf( p, blen - (p - bp), \"%s http:\/\/%s:%d%s\",\n-            method, ctxt->hostname,\n-            ctxt->port, ctxt->path );\n-    }\n-    else\n-        p += snprintf( p, blen - (p - bp), \"%s http:\/\/%s%s\", method,\n-            ctxt->hostname, ctxt->path);\n+        if (ctxt->port != 80) {\n+            p += snprintf( p, blen - (p - bp), \"%s http:\/\/%s:%d%s\",\n+                        method, ctxt->hostname,\n+                        ctxt->port, ctxt->path );\n+        }\n+        else\n+            p += snprintf( p, blen - (p - bp), \"%s http:\/\/%s%s\", method,\n+                        ctxt->hostname, ctxt->path);\n@@ -1458,1 +1458,1 @@\n-    p += snprintf( p, blen - (p - bp), \"%s %s\", method, ctxt->path);\n+        p += snprintf( p, blen - (p - bp), \"%s %s\", method, ctxt->path);\n@@ -1461,1 +1461,1 @@\n-    p += snprintf( p, blen - (p - bp), \"?%s\", ctxt->query);\n+        p += snprintf( p, blen - (p - bp), \"?%s\", ctxt->query);\n@@ -1465,1 +1465,1 @@\n-            ctxt->hostname);\n+                    ctxt->hostname);\n@@ -1468,1 +1468,1 @@\n-            ctxt->hostname, ctxt->port);\n+                    ctxt->hostname, ctxt->port);\n@@ -1476,1 +1476,1 @@\n-    p += snprintf(p, blen - (p - bp), \"Content-Type: %s\\r\\n\", *contentType);\n+        p += snprintf(p, blen - (p - bp), \"Content-Type: %s\\r\\n\", *contentType);\n@@ -1479,1 +1479,1 @@\n-    p += snprintf( p, blen - (p - bp), \"%s\", headers );\n+        p += snprintf( p, blen - (p - bp), \"%s\", headers );\n@@ -1482,1 +1482,1 @@\n-    snprintf(p, blen - (p - bp), \"Content-Length: %d\\r\\n\\r\\n\", ilen );\n+        snprintf(p, blen - (p - bp), \"Content-Length: %d\\r\\n\\r\\n\", ilen );\n@@ -1484,1 +1484,1 @@\n-    snprintf(p, blen - (p - bp), \"\\r\\n\");\n+        snprintf(p, blen - (p - bp), \"\\r\\n\");\n@@ -1488,1 +1488,1 @@\n-        \"-> %s%s\", proxy? \"(Proxy) \" : \"\", bp);\n+            \"-> %s%s\", proxy? \"(Proxy) \" : \"\", bp);\n@@ -1490,2 +1490,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"ERROR: overflowed buffer by %d bytes\\n\", -blen);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"ERROR: overflowed buffer by %d bytes\\n\", -blen);\n@@ -1500,4 +1500,4 @@\n-            \"xmlNanoHTTPMethodRedir:  Only %d of %d %s %s\\n\",\n-            xmt_bytes, blen,\n-            \"bytes of HTTP headers sent to host\",\n-            ctxt->hostname );\n+                        \"xmlNanoHTTPMethodRedir:  Only %d of %d %s %s\\n\",\n+                        xmt_bytes, blen,\n+                        \"bytes of HTTP headers sent to host\",\n+                        ctxt->hostname );\n@@ -1512,6 +1512,6 @@\n-    if ( xmt_bytes != ilen )\n-        xmlGenericError( xmlGenericErrorContext,\n-            \"xmlNanoHTTPMethodRedir:  Only %d of %d %s %s\\n\",\n-            xmt_bytes, ilen,\n-            \"bytes of HTTP content sent to host\",\n-            ctxt->hostname );\n+        if ( xmt_bytes != ilen )\n+            xmlGenericError( xmlGenericErrorContext,\n+                        \"xmlNanoHTTPMethodRedir:  Only %d of %d %s %s\\n\",\n+                        xmt_bytes, ilen,\n+                        \"bytes of HTTP content sent to host\",\n+                        ctxt->hostname );\n@@ -1519,1 +1519,1 @@\n-    xmlNanoHTTPSend( ctxt, input, ilen );\n+        xmlNanoHTTPSend( ctxt, input, ilen );\n@@ -1527,5 +1527,5 @@\n-        ctxt->content = ctxt->inrptr;\n-        xmlFree(p);\n-        break;\n-    }\n-    xmlNanoHTTPScanAnswer(ctxt, p);\n+            ctxt->content = ctxt->inrptr;\n+            xmlFree(p);\n+            break;\n+        }\n+        xmlNanoHTTPScanAnswer(ctxt, p);\n@@ -1534,1 +1534,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"<- %s\\n\", p);\n+        xmlGenericError(xmlGenericErrorContext, \"<- %s\\n\", p);\n@@ -1542,2 +1542,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"\\nRedirect to: %s\\n\", ctxt->location);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"\\nRedirect to: %s\\n\", ctxt->location);\n@@ -1545,1 +1545,1 @@\n-    while ( xmlNanoHTTPRecv(ctxt) > 0 )\n+        while ( xmlNanoHTTPRecv(ctxt) > 0 )\n@@ -1548,4 +1548,7 @@\n-        nbRedirects++;\n-        if (redirURL != NULL)\n-        xmlFree(redirURL);\n-        redirURL = xmlMemStrdup(ctxt->location);\n+            nbRedirects++;\n+            if (redirURL != NULL)\n+                xmlFree(redirURL);\n+            redirURL = xmlMemStrdup(ctxt->location);\n+            xmlNanoHTTPFreeCtxt(ctxt);\n+            goto retry;\n+        }\n@@ -1553,4 +1556,1 @@\n-        goto retry;\n-    }\n-    xmlNanoHTTPFreeCtxt(ctxt);\n-    if (redirURL != NULL) xmlFree(redirURL);\n+        if (redirURL != NULL) xmlFree(redirURL);\n@@ -1558,2 +1558,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"xmlNanoHTTPMethodRedir: Too many redirects, aborting ...\\n\");\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"xmlNanoHTTPMethodRedir: Too many redirects, aborting ...\\n\");\n@@ -1561,1 +1561,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1565,4 +1565,4 @@\n-    if (ctxt->contentType != NULL)\n-        *contentType = xmlMemStrdup(ctxt->contentType);\n-    else\n-        *contentType = NULL;\n+        if (ctxt->contentType != NULL)\n+            *contentType = xmlMemStrdup(ctxt->contentType);\n+        else\n+            *contentType = NULL;\n@@ -1572,1 +1572,1 @@\n-    *redir = redirURL;\n+        *redir = redirURL;\n@@ -1574,4 +1574,4 @@\n-    if (redirURL != NULL)\n-        xmlFree(redirURL);\n-    if (redir != NULL)\n-        *redir = NULL;\n+        if (redirURL != NULL)\n+            xmlFree(redirURL);\n+        if (redir != NULL)\n+            *redir = NULL;\n@@ -1582,3 +1582,3 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"\\nCode %d, content-type '%s'\\n\\n\",\n-           ctxt->returnValue, ctxt->contentType);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"\\nCode %d, content-type '%s'\\n\\n\",\n+               ctxt->returnValue, ctxt->contentType);\n@@ -1586,3 +1586,3 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"\\nCode %d, no content-type\\n\\n\",\n-           ctxt->returnValue);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"\\nCode %d, no content-type\\n\\n\",\n+               ctxt->returnValue);\n@@ -1615,1 +1615,1 @@\n-                          NULL, headers, ilen));\n+                                  NULL, headers, ilen));\n@@ -1647,5 +1647,7 @@\n-    if (fd < 0) {\n-        xmlNanoHTTPClose(ctxt);\n-        if ((contentType != NULL) && (*contentType != NULL)) {\n-            xmlFree(*contentType);\n-        *contentType = NULL;\n+        if (fd < 0) {\n+            xmlNanoHTTPClose(ctxt);\n+            if ((contentType != NULL) && (*contentType != NULL)) {\n+                xmlFree(*contentType);\n+                *contentType = NULL;\n+            }\n+            return(-1);\n@@ -1653,2 +1655,0 @@\n-        return(-1);\n-    }\n@@ -1659,3 +1659,3 @@\n-    if (write(fd, buf, len) == -1) {\n-        ret = -1;\n-    }\n+        if (write(fd, buf, len) == -1) {\n+            ret = -1;\n+        }\n@@ -1693,4 +1693,4 @@\n-    if (fd < 0) {\n-        xmlNanoHTTPClose(ctxt);\n-        return(-1);\n-    }\n+        if (fd < 0) {\n+            xmlNanoHTTPClose(ctxt);\n+            return(-1);\n+        }\n@@ -1701,3 +1701,3 @@\n-    if (write(fd, buf, len) == -1) {\n-        ret = -1;\n-    }\n+        if (write(fd, buf, len) == -1) {\n+            ret = -1;\n+        }\n@@ -1825,5 +1825,5 @@\n-    int         rc = 0;\n-    int         cur_lgth;\n-    int         rcvd_lgth;\n-    int         dummy_int;\n-    char *      dummy_ptr = NULL;\n+    int                 rc = 0;\n+    int                 cur_lgth;\n+    int                 rcvd_lgth;\n+    int                 dummy_int;\n+    char *              dummy_ptr = NULL;\n@@ -1843,2 +1843,2 @@\n-    *ptr = NULL;\n-    return ( -1 );\n+        *ptr = NULL;\n+        return ( -1 );\n@@ -1851,3 +1851,3 @@\n-    rcvd_lgth += cur_lgth;\n-    if ( (ctxt->ContentLength > 0) && (rcvd_lgth >= ctxt->ContentLength) )\n-        break;\n+        rcvd_lgth += cur_lgth;\n+        if ( (ctxt->ContentLength > 0) && (rcvd_lgth >= ctxt->ContentLength) )\n+            break;\n@@ -1862,1 +1862,1 @@\n-    rc = -1;\n+        rc = -1;\n@@ -1872,2 +1872,2 @@\n-    if (argv[2] != NULL)\n-        xmlNanoHTTPFetch(argv[1], argv[2], &contentType);\n+        if (argv[2] != NULL)\n+            xmlNanoHTTPFetch(argv[1], argv[2], &contentType);\n@@ -1875,2 +1875,2 @@\n-        xmlNanoHTTPFetch(argv[1], \"-\", &contentType);\n-    if (contentType != NULL) xmlFree(contentType);\n+            xmlNanoHTTPFetch(argv[1], \"-\", &contentType);\n+        if (contentType != NULL) xmlFree(contentType);\n@@ -1879,1 +1879,1 @@\n-        \"%s: minimal HTTP GET implementation\\n\", argv[0]);\n+                \"%s: minimal HTTP GET implementation\\n\", argv[0]);\n@@ -1881,1 +1881,1 @@\n-        \"\\tusage %s [ URL [ filename ] ]\\n\", argv[0]);\n+                \"\\tusage %s [ URL [ filename ] ]\\n\", argv[0]);\n@@ -1893,1 +1893,1 @@\n-        \"%s : HTTP support not compiled in\\n\", argv[0]);\n+            \"%s : HTTP support not compiled in\\n\", argv[0]);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/nanohttp.c","additions":429,"deletions":429,"binary":false,"changes":858,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-                      const xmlChar *base, xmlParserCtxtPtr pctx);\n+                          const xmlChar *base, xmlParserCtxtPtr pctx);\n@@ -113,3 +113,3 @@\n- *                                  *\n- *  Arbitrary limits set in the parser. See XML_PARSE_HUGE      *\n- *                                  *\n+ *                                                                      *\n+ *      Arbitrary limits set in the parser. See XML_PARSE_HUGE          *\n+ *                                                                      *\n@@ -155,4 +155,4 @@\n-    (ent->content != NULL) && (ent->checked == 0) &&\n-    (ctxt->errNo != XML_ERR_ENTITY_LOOP)) {\n-    unsigned long oldnbent = ctxt->nbentities, diff;\n-    xmlChar *rep;\n+        (ent->content != NULL) && (ent->checked == 0) &&\n+        (ctxt->errNo != XML_ERR_ENTITY_LOOP)) {\n+        unsigned long oldnbent = ctxt->nbentities, diff;\n+        xmlChar *rep;\n@@ -160,1 +160,1 @@\n-    ent->checked = 1;\n+        ent->checked = 1;\n@@ -163,2 +163,2 @@\n-    rep = xmlStringDecodeEntities(ctxt, ent->content,\n-                  XML_SUBSTITUTE_REF, 0, 0, 0);\n+        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                  XML_SUBSTITUTE_REF, 0, 0, 0);\n@@ -166,3 +166,3 @@\n-    if ((rep == NULL) || (ctxt->errNo == XML_ERR_ENTITY_LOOP)) {\n-        ent->content[0] = 0;\n-    }\n+        if ((rep == NULL) || (ctxt->errNo == XML_ERR_ENTITY_LOOP)) {\n+            ent->content[0] = 0;\n+        }\n@@ -173,7 +173,7 @@\n-    ent->checked = diff * 2;\n-    if (rep != NULL) {\n-        if (xmlStrchr(rep, '<'))\n-        ent->checked |= 1;\n-        xmlFree(rep);\n-        rep = NULL;\n-    }\n+        ent->checked = diff * 2;\n+        if (rep != NULL) {\n+            if (xmlStrchr(rep, '<'))\n+                ent->checked |= 1;\n+            xmlFree(rep);\n+            rep = NULL;\n+        }\n@@ -189,10 +189,10 @@\n-    for (i = 0;i < ctxt->inputNr;i++) {\n-        consumed += ctxt->inputTab[i]->consumed +\n-                   (ctxt->inputTab[i]->cur - ctxt->inputTab[i]->base);\n-    }\n-    if (ctxt->nbentities > consumed * XML_PARSER_NON_LINEAR) {\n-        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n-        ctxt->instate = XML_PARSER_EOF;\n-        return (1);\n-    }\n-    consumed = 0;\n+        for (i = 0;i < ctxt->inputNr;i++) {\n+            consumed += ctxt->inputTab[i]->consumed +\n+                       (ctxt->inputTab[i]->cur - ctxt->inputTab[i]->base);\n+        }\n+        if (ctxt->nbentities > consumed * XML_PARSER_NON_LINEAR) {\n+            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n+            ctxt->instate = XML_PARSER_EOF;\n+            return (1);\n+        }\n+        consumed = 0;\n@@ -204,2 +204,2 @@\n-    if (replacement < XML_MAX_TEXT_LENGTH)\n-        return(0);\n+        if (replacement < XML_MAX_TEXT_LENGTH)\n+            return(0);\n@@ -208,4 +208,4 @@\n-     * If the volume of entity copy reaches 10 times the\n-     * amount of parsed data and over the large text threshold\n-     * then that's very likely to be an abuse.\n-     *\/\n+         * If the volume of entity copy reaches 10 times the\n+         * amount of parsed data and over the large text threshold\n+         * then that's very likely to be an abuse.\n+         *\/\n@@ -213,3 +213,3 @@\n-        consumed = ctxt->input->consumed +\n-                   (ctxt->input->cur - ctxt->input->base);\n-    }\n+            consumed = ctxt->input->consumed +\n+                       (ctxt->input->cur - ctxt->input->base);\n+        }\n@@ -219,1 +219,1 @@\n-        return(0);\n+            return(0);\n@@ -225,1 +225,1 @@\n-        return(0);\n+            return(0);\n@@ -237,1 +237,1 @@\n-        (ctxt->nbentities * 3 < XML_PARSER_NON_LINEAR * consumed))\n+            (ctxt->nbentities * 3 < XML_PARSER_NON_LINEAR * consumed))\n@@ -256,1 +256,1 @@\n-     * knowing an entity reference will take at least 3 bytes\n+         * knowing an entity reference will take at least 3 bytes\n@@ -264,4 +264,4 @@\n-    if (((ctxt->lastError.code != XML_ERR_UNDECLARED_ENTITY) &&\n-         (ctxt->lastError.code != XML_WAR_UNDECLARED_ENTITY)) ||\n-        (ctxt->nbentities <= 10000))\n-        return (0);\n+        if (((ctxt->lastError.code != XML_ERR_UNDECLARED_ENTITY) &&\n+             (ctxt->lastError.code != XML_WAR_UNDECLARED_ENTITY)) ||\n+            (ctxt->nbentities <= 10000))\n+            return (0);\n@@ -318,3 +318,3 @@\n-                  xmlSAXHandlerPtr sax,\n-              void *user_data, int depth, const xmlChar *URL,\n-              const xmlChar *ID, xmlNodePtr *list);\n+                      xmlSAXHandlerPtr sax,\n+                      void *user_data, int depth, const xmlChar *URL,\n+                      const xmlChar *ID, xmlNodePtr *list);\n@@ -333,1 +333,1 @@\n-              const xmlChar *string, void *user_data, xmlNodePtr *lst);\n+                      const xmlChar *string, void *user_data, xmlNodePtr *lst);\n@@ -339,3 +339,3 @@\n- *                                  *\n- *      Some factorized error routines              *\n- *                                  *\n+ *                                                                      *\n+ *              Some factorized error routines                          *\n+ *                                                                      *\n@@ -358,1 +358,1 @@\n-    return;\n+        return;\n@@ -360,1 +360,1 @@\n-    ctxt->errNo = XML_ERR_ATTRIBUTE_REDEFINED;\n+        ctxt->errNo = XML_ERR_ATTRIBUTE_REDEFINED;\n@@ -374,3 +374,3 @@\n-    ctxt->wellFormed = 0;\n-    if (ctxt->recovery == 0)\n-        ctxt->disableSAX = 1;\n+        ctxt->wellFormed = 0;\n+        if (ctxt->recovery == 0)\n+            ctxt->disableSAX = 1;\n@@ -395,1 +395,1 @@\n-    return;\n+        return;\n@@ -579,1 +579,1 @@\n-    ctxt->errNo = error;\n+        ctxt->errNo = error;\n@@ -590,3 +590,3 @@\n-    ctxt->wellFormed = 0;\n-    if (ctxt->recovery == 0)\n-        ctxt->disableSAX = 1;\n+        ctxt->wellFormed = 0;\n+        if (ctxt->recovery == 0)\n+            ctxt->disableSAX = 1;\n@@ -610,1 +610,1 @@\n-    return;\n+        return;\n@@ -612,1 +612,1 @@\n-    ctxt->errNo = error;\n+        ctxt->errNo = error;\n@@ -616,3 +616,3 @@\n-    ctxt->wellFormed = 0;\n-    if (ctxt->recovery == 0)\n-        ctxt->disableSAX = 1;\n+        ctxt->wellFormed = 0;\n+        if (ctxt->recovery == 0)\n+            ctxt->disableSAX = 1;\n@@ -640,1 +640,1 @@\n-    return;\n+        return;\n@@ -650,2 +650,2 @@\n-            (const char *) str1, (const char *) str2, NULL, 0, 0,\n-            msg, (const char *) str1, (const char *) str2);\n+                    (const char *) str1, (const char *) str2, NULL, 0, 0,\n+                    msg, (const char *) str1, (const char *) str2);\n@@ -656,2 +656,2 @@\n-            (const char *) str1, (const char *) str2, NULL, 0, 0,\n-            msg, (const char *) str1, (const char *) str2);\n+                    (const char *) str1, (const char *) str2, NULL, 0, 0,\n+                    msg, (const char *) str1, (const char *) str2);\n@@ -678,1 +678,1 @@\n-    return;\n+        return;\n@@ -680,3 +680,3 @@\n-    ctxt->errNo = error;\n-    if ((ctxt->sax != NULL) && (ctxt->sax->initialized == XML_SAX2_MAGIC))\n-        schannel = ctxt->sax->serror;\n+        ctxt->errNo = error;\n+        if ((ctxt->sax != NULL) && (ctxt->sax->initialized == XML_SAX2_MAGIC))\n+            schannel = ctxt->sax->serror;\n@@ -689,3 +689,3 @@\n-            (const char *) str2, NULL, 0, 0,\n-            msg, (const char *) str1, (const char *) str2);\n-    ctxt->valid = 0;\n+                    (const char *) str2, NULL, 0, 0,\n+                    msg, (const char *) str1, (const char *) str2);\n+        ctxt->valid = 0;\n@@ -696,2 +696,2 @@\n-            (const char *) str2, NULL, 0, 0,\n-            msg, (const char *) str1, (const char *) str2);\n+                    (const char *) str2, NULL, 0, 0,\n+                    msg, (const char *) str1, (const char *) str2);\n@@ -716,1 +716,1 @@\n-    return;\n+        return;\n@@ -718,1 +718,1 @@\n-    ctxt->errNo = error;\n+        ctxt->errNo = error;\n@@ -723,3 +723,3 @@\n-    ctxt->wellFormed = 0;\n-    if (ctxt->recovery == 0)\n-        ctxt->disableSAX = 1;\n+        ctxt->wellFormed = 0;\n+        if (ctxt->recovery == 0)\n+            ctxt->disableSAX = 1;\n@@ -743,1 +743,1 @@\n-          const xmlChar *str2)\n+                  const xmlChar *str2)\n@@ -747,1 +747,1 @@\n-    return;\n+        return;\n@@ -749,1 +749,1 @@\n-    ctxt->errNo = error;\n+        ctxt->errNo = error;\n@@ -753,1 +753,1 @@\n-            NULL, val, 0, msg, str1, val, str2);\n+                    NULL, val, 0, msg, str1, val, str2);\n@@ -755,3 +755,3 @@\n-    ctxt->wellFormed = 0;\n-    if (ctxt->recovery == 0)\n-        ctxt->disableSAX = 1;\n+        ctxt->wellFormed = 0;\n+        if (ctxt->recovery == 0)\n+            ctxt->disableSAX = 1;\n@@ -776,1 +776,1 @@\n-    return;\n+        return;\n@@ -778,1 +778,1 @@\n-    ctxt->errNo = error;\n+        ctxt->errNo = error;\n@@ -784,3 +784,3 @@\n-    ctxt->wellFormed = 0;\n-    if (ctxt->recovery == 0)\n-        ctxt->disableSAX = 1;\n+        ctxt->wellFormed = 0;\n+        if (ctxt->recovery == 0)\n+            ctxt->disableSAX = 1;\n@@ -805,1 +805,1 @@\n-    return;\n+        return;\n@@ -807,1 +807,1 @@\n-    ctxt->errNo = error;\n+        ctxt->errNo = error;\n@@ -832,1 +832,1 @@\n-    return;\n+        return;\n@@ -834,1 +834,1 @@\n-    ctxt->errNo = error;\n+        ctxt->errNo = error;\n@@ -840,1 +840,1 @@\n-    ctxt->nsWellFormed = 0;\n+        ctxt->nsWellFormed = 0;\n@@ -861,1 +861,1 @@\n-    return;\n+        return;\n@@ -869,3 +869,3 @@\n- *                                  *\n- *      Library wide options                    *\n- *                                  *\n+ *                                                                      *\n+ *              Library wide options                                    *\n+ *                                                                      *\n@@ -888,1 +888,1 @@\n-    case XML_WITH_THREAD:\n+        case XML_WITH_THREAD:\n@@ -890,1 +890,1 @@\n-        return(1);\n+            return(1);\n@@ -892,1 +892,1 @@\n-        return(0);\n+            return(0);\n@@ -1087,1 +1087,1 @@\n-        break;\n+            break;\n@@ -1093,3 +1093,3 @@\n- *                                  *\n- *      SAX2 defaulted attributes handling          *\n- *                                  *\n+ *                                                                      *\n+ *              SAX2 defaulted attributes handling                      *\n+ *                                                                      *\n@@ -1123,1 +1123,1 @@\n-        (ctxt->str_xml_ns == NULL)) {\n+                (ctxt->str_xml_ns == NULL)) {\n@@ -1131,1 +1131,1 @@\n-    int nbAttrs;    \/* number of defaulted attributes on that element *\/\n+    int nbAttrs;        \/* number of defaulted attributes on that element *\/\n@@ -1166,7 +1166,7 @@\n-    if (*src == 0x20) {\n-        while (*src == 0x20) src++;\n-        if (*src != 0)\n-        *dst++ = 0x20;\n-    } else {\n-        *dst++ = *src++;\n-    }\n+        if (*src == 0x20) {\n+            while (*src == 0x20) src++;\n+            if (*src != 0)\n+                *dst++ = 0x20;\n+        } else {\n+            *dst++ = *src++;\n+        }\n@@ -1208,1 +1208,1 @@\n-    remove_head++;\n+        remove_head++;\n@@ -1211,8 +1211,8 @@\n-    if (*cur == 0x20) {\n-        cur++;\n-        if ((*cur == 0x20) || (*cur == 0)) {\n-            need_realloc = 1;\n-        break;\n-        }\n-    } else\n-        cur++;\n+        if (*cur == 0x20) {\n+            cur++;\n+            if ((*cur == 0x20) || (*cur == 0)) {\n+                need_realloc = 1;\n+                break;\n+            }\n+        } else\n+            cur++;\n@@ -1223,7 +1223,7 @@\n-    ret = xmlStrndup(src + remove_head, i - remove_head + 1);\n-    if (ret == NULL) {\n-        xmlErrMemory(ctxt, NULL);\n-        return(NULL);\n-    }\n-    xmlAttrNormalizeSpace(ret, ret);\n-    *len = (int) strlen((const char *)ret);\n+        ret = xmlStrndup(src + remove_head, i - remove_head + 1);\n+        if (ret == NULL) {\n+            xmlErrMemory(ctxt, NULL);\n+            return(NULL);\n+        }\n+        xmlAttrNormalizeSpace(ret, ret);\n+        *len = (int) strlen((const char *)ret);\n@@ -1234,1 +1234,1 @@\n-    return(src);\n+        return(src);\n@@ -1263,1 +1263,1 @@\n-        return;\n+            return;\n@@ -1268,2 +1268,2 @@\n-    if (ctxt->attsDefault == NULL)\n-        goto mem_error;\n+        if (ctxt->attsDefault == NULL)\n+            goto mem_error;\n@@ -1279,1 +1279,1 @@\n-    prefix = NULL;\n+        prefix = NULL;\n@@ -1282,1 +1282,1 @@\n-    prefix = xmlDictLookup(ctxt->dict, fullname, len);\n+        prefix = xmlDictLookup(ctxt->dict, fullname, len);\n@@ -1291,10 +1291,10 @@\n-                       (4 * 5) * sizeof(const xmlChar *));\n-    if (defaults == NULL)\n-        goto mem_error;\n-    defaults->nbAttrs = 0;\n-    defaults->maxAttrs = 4;\n-    if (xmlHashUpdateEntry2(ctxt->attsDefault, name, prefix,\n-                            defaults, NULL) < 0) {\n-        xmlFree(defaults);\n-        goto mem_error;\n-    }\n+                           (4 * 5) * sizeof(const xmlChar *));\n+        if (defaults == NULL)\n+            goto mem_error;\n+        defaults->nbAttrs = 0;\n+        defaults->maxAttrs = 4;\n+        if (xmlHashUpdateEntry2(ctxt->attsDefault, name, prefix,\n+                                defaults, NULL) < 0) {\n+            xmlFree(defaults);\n+            goto mem_error;\n+        }\n@@ -1305,10 +1305,10 @@\n-               (2 * defaults->maxAttrs * 5) * sizeof(const xmlChar *));\n-    if (temp == NULL)\n-        goto mem_error;\n-    defaults = temp;\n-    defaults->maxAttrs *= 2;\n-    if (xmlHashUpdateEntry2(ctxt->attsDefault, name, prefix,\n-                            defaults, NULL) < 0) {\n-        xmlFree(defaults);\n-        goto mem_error;\n-    }\n+                       (2 * defaults->maxAttrs * 5) * sizeof(const xmlChar *));\n+        if (temp == NULL)\n+            goto mem_error;\n+        defaults = temp;\n+        defaults->maxAttrs *= 2;\n+        if (xmlHashUpdateEntry2(ctxt->attsDefault, name, prefix,\n+                                defaults, NULL) < 0) {\n+            xmlFree(defaults);\n+            goto mem_error;\n+        }\n@@ -1324,1 +1324,1 @@\n-    prefix = NULL;\n+        prefix = NULL;\n@@ -1327,1 +1327,1 @@\n-    prefix = xmlDictLookup(ctxt->dict, fullattr, len);\n+        prefix = xmlDictLookup(ctxt->dict, fullattr, len);\n@@ -1361,3 +1361,3 @@\n-          const xmlChar *fullname,\n-          const xmlChar *fullattr,\n-          int type)\n+                  const xmlChar *fullname,\n+                  const xmlChar *fullattr,\n+                  int type)\n@@ -1367,2 +1367,2 @@\n-    if (ctxt->attsSpecial == NULL)\n-        goto mem_error;\n+        if (ctxt->attsSpecial == NULL)\n+            goto mem_error;\n@@ -1617,3 +1617,3 @@\n- *                                  *\n- *      Parser stacks related functions and macros      *\n- *                                  *\n+ *                                                                      *\n+ *              Parser stacks related functions and macros              *\n+ *                                                                      *\n@@ -1635,1 +1635,1 @@\n- *     and the index in the stack otherwise.\n+ *         and the index in the stack otherwise.\n@@ -1642,7 +1642,8 @@\n-    for (i = ctxt->nsNr - 2;i >= 0;i -= 2) {\n-        if (ctxt->nsTab[i] == prefix) {\n-        \/* in scope *\/\n-            if (ctxt->nsTab[i + 1] == URL)\n-            return(-2);\n-        \/* out of scope keep it *\/\n-        break;\n+        for (i = ctxt->nsNr - 2;i >= 0;i -= 2) {\n+            if (ctxt->nsTab[i] == prefix) {\n+                \/* in scope *\/\n+                if (ctxt->nsTab[i + 1] == URL)\n+                    return(-2);\n+                \/* out of scope keep it *\/\n+                break;\n+            }\n@@ -1651,1 +1652,0 @@\n-    }\n@@ -1653,7 +1653,7 @@\n-    ctxt->nsMax = 10;\n-    ctxt->nsNr = 0;\n-    ctxt->nsTab = (const xmlChar **)\n-                  xmlMalloc(ctxt->nsMax * sizeof(xmlChar *));\n-    if (ctxt->nsTab == NULL) {\n-        xmlErrMemory(ctxt, NULL);\n-        ctxt->nsMax = 0;\n+        ctxt->nsMax = 10;\n+        ctxt->nsNr = 0;\n+        ctxt->nsTab = (const xmlChar **)\n+                      xmlMalloc(ctxt->nsMax * sizeof(xmlChar *));\n+        if (ctxt->nsTab == NULL) {\n+            xmlErrMemory(ctxt, NULL);\n+            ctxt->nsMax = 0;\n@@ -1661,1 +1661,1 @@\n-    }\n+        }\n@@ -1666,1 +1666,1 @@\n-                    ctxt->nsMax * sizeof(ctxt->nsTab[0]));\n+                                    ctxt->nsMax * sizeof(ctxt->nsTab[0]));\n@@ -1669,1 +1669,1 @@\n-        ctxt->nsMax \/= 2;\n+            ctxt->nsMax \/= 2;\n@@ -1672,1 +1672,1 @@\n-    ctxt->nsTab = tmp;\n+        ctxt->nsTab = tmp;\n@@ -1702,1 +1702,1 @@\n-     ctxt->nsTab[ctxt->nsNr] = NULL;\n+         ctxt->nsTab[ctxt->nsNr] = NULL;\n@@ -1715,9 +1715,9 @@\n-    maxatts = 55; \/* allow for 10 attrs by default *\/\n-    atts = (const xmlChar **)\n-           xmlMalloc(maxatts * sizeof(xmlChar *));\n-    if (atts == NULL) goto mem_error;\n-    ctxt->atts = atts;\n-    attallocs = (int *) xmlMalloc((maxatts \/ 5) * sizeof(int));\n-    if (attallocs == NULL) goto mem_error;\n-    ctxt->attallocs = attallocs;\n-    ctxt->maxatts = maxatts;\n+        maxatts = 55; \/* allow for 10 attrs by default *\/\n+        atts = (const xmlChar **)\n+               xmlMalloc(maxatts * sizeof(xmlChar *));\n+        if (atts == NULL) goto mem_error;\n+        ctxt->atts = atts;\n+        attallocs = (int *) xmlMalloc((maxatts \/ 5) * sizeof(int));\n+        if (attallocs == NULL) goto mem_error;\n+        ctxt->attallocs = attallocs;\n+        ctxt->maxatts = maxatts;\n@@ -1725,10 +1725,10 @@\n-    maxatts = (nr + 5) * 2;\n-    atts = (const xmlChar **) xmlRealloc((void *) ctxt->atts,\n-                     maxatts * sizeof(const xmlChar *));\n-    if (atts == NULL) goto mem_error;\n-    ctxt->atts = atts;\n-    attallocs = (int *) xmlRealloc((void *) ctxt->attallocs,\n-                                 (maxatts \/ 5) * sizeof(int));\n-    if (attallocs == NULL) goto mem_error;\n-    ctxt->attallocs = attallocs;\n-    ctxt->maxatts = maxatts;\n+        maxatts = (nr + 5) * 2;\n+        atts = (const xmlChar **) xmlRealloc((void *) ctxt->atts,\n+                                     maxatts * sizeof(const xmlChar *));\n+        if (atts == NULL) goto mem_error;\n+        ctxt->atts = atts;\n+        attallocs = (int *) xmlRealloc((void *) ctxt->attallocs,\n+                                     (maxatts \/ 5) * sizeof(int));\n+        if (attallocs == NULL) goto mem_error;\n+        ctxt->attallocs = attallocs;\n+        ctxt->maxatts = maxatts;\n@@ -1764,3 +1764,3 @@\n-        xmlFreeInputStream(value);\n-        ctxt->inputMax \/= 2;\n-        value = NULL;\n+            xmlFreeInputStream(value);\n+            ctxt->inputMax \/= 2;\n+            value = NULL;\n@@ -1816,1 +1816,1 @@\n-    tmp = (xmlNodePtr *) xmlRealloc(ctxt->nodeTab,\n+        tmp = (xmlNodePtr *) xmlRealloc(ctxt->nodeTab,\n@@ -1824,1 +1824,1 @@\n-    ctxt->nodeMax *= 2;\n+        ctxt->nodeMax *= 2;\n@@ -1828,5 +1828,5 @@\n-    xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,\n-         \"Excessive depth in document: %d use XML_PARSE_HUGE option\\n\",\n-              xmlParserMaxDepth);\n-    xmlHaltParser(ctxt);\n-    return(-1);\n+        xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,\n+                 \"Excessive depth in document: %d use XML_PARSE_HUGE option\\n\",\n+                          xmlParserMaxDepth);\n+        xmlHaltParser(ctxt);\n+        return(-1);\n@@ -1892,2 +1892,2 @@\n-        ctxt->nameMax \/= 2;\n-        goto mem_error;\n+            ctxt->nameMax \/= 2;\n+            goto mem_error;\n@@ -1895,1 +1895,1 @@\n-    ctxt->nameTab = tmp;\n+        ctxt->nameTab = tmp;\n@@ -1900,2 +1900,2 @@\n-        ctxt->nameMax \/= 2;\n-        goto mem_error;\n+            ctxt->nameMax \/= 2;\n+            goto mem_error;\n@@ -1903,1 +1903,1 @@\n-    ctxt->pushTab = tmp2;\n+        ctxt->pushTab = tmp2;\n@@ -1969,1 +1969,1 @@\n-        goto mem_error;\n+            goto mem_error;\n@@ -1971,1 +1971,1 @@\n-    ctxt->nameTab = tmp;\n+        ctxt->nameTab = tmp;\n@@ -2010,1 +2010,1 @@\n-    ctxt->spaceMax *= 2;\n+        ctxt->spaceMax *= 2;\n@@ -2012,1 +2012,1 @@\n-                             ctxt->spaceMax * sizeof(ctxt->spaceTab[0]));\n+                                 ctxt->spaceMax * sizeof(ctxt->spaceTab[0]));\n@@ -2014,5 +2014,5 @@\n-        xmlErrMemory(ctxt, NULL);\n-        ctxt->spaceMax \/=2;\n-        return(-1);\n-    }\n-    ctxt->spaceTab = tmp;\n+            xmlErrMemory(ctxt, NULL);\n+            ctxt->spaceMax \/=2;\n+            return(-1);\n+        }\n+        ctxt->spaceTab = tmp;\n@@ -2030,1 +2030,1 @@\n-    ctxt->space = &ctxt->spaceTab[ctxt->spaceNr - 1];\n+        ctxt->space = &ctxt->spaceTab[ctxt->spaceNr - 1];\n@@ -2097,4 +2097,4 @@\n-#define SKIP(val) do {                          \\\n-    ctxt->input->cur += (val),ctxt->input->col+=(val);          \\\n-    if (*ctxt->input->cur == 0)                     \\\n-        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);           \\\n+#define SKIP(val) do {                                                  \\\n+    ctxt->input->cur += (val),ctxt->input->col+=(val);                  \\\n+    if (*ctxt->input->cur == 0)                                         \\\n+        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);                   \\\n@@ -2103,10 +2103,10 @@\n-#define SKIPL(val) do {                         \\\n-    int skipl;                              \\\n-    for(skipl=0; skipl<val; skipl++) {                  \\\n-    if (*(ctxt->input->cur) == '\\n') {              \\\n-    ctxt->input->line++; ctxt->input->col = 1;          \\\n-    } else ctxt->input->col++;                  \\\n-    ctxt->input->cur++;                     \\\n-    }                                   \\\n-    if (*ctxt->input->cur == 0)                     \\\n-        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);           \\\n+#define SKIPL(val) do {                                                 \\\n+    int skipl;                                                          \\\n+    for(skipl=0; skipl<val; skipl++) {                                  \\\n+        if (*(ctxt->input->cur) == '\\n') {                              \\\n+        ctxt->input->line++; ctxt->input->col = 1;                      \\\n+        } else ctxt->input->col++;                                      \\\n+        ctxt->input->cur++;                                             \\\n+    }                                                                   \\\n+    if (*ctxt->input->cur == 0)                                         \\\n+        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);                   \\\n@@ -2115,4 +2115,4 @@\n-#define SHRINK if ((ctxt->progressive == 0) &&              \\\n-           (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \\\n-           (ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \\\n-    xmlSHRINK (ctxt);\n+#define SHRINK if ((ctxt->progressive == 0) &&                          \\\n+                   (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \\\n+                   (ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \\\n+        xmlSHRINK (ctxt);\n@@ -2126,3 +2126,3 @@\n-#define GROW if ((ctxt->progressive == 0) &&                \\\n-         (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK))   \\\n-    xmlGROW (ctxt);\n+#define GROW if ((ctxt->progressive == 0) &&                            \\\n+                 (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK))   \\\n+        xmlGROW (ctxt);\n@@ -2141,1 +2141,1 @@\n-    return;\n+        return;\n@@ -2148,1 +2148,1 @@\n-    return;\n+        return;\n@@ -2158,5 +2158,5 @@\n-#define NEXT1 {                             \\\n-    ctxt->input->col++;                     \\\n-    ctxt->input->cur++;                     \\\n-    if (*ctxt->input->cur == 0)                 \\\n-        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);       \\\n+#define NEXT1 {                                                         \\\n+        ctxt->input->col++;                                             \\\n+        ctxt->input->cur++;                                             \\\n+        if (*ctxt->input->cur == 0)                                     \\\n+            xmlParserInputGrow(ctxt->input, INPUT_CHUNK);               \\\n@@ -2165,5 +2165,5 @@\n-#define NEXTL(l) do {                           \\\n-    if (*(ctxt->input->cur) == '\\n') {                  \\\n-    ctxt->input->line++; ctxt->input->col = 1;          \\\n-    } else ctxt->input->col++;                      \\\n-    ctxt->input->cur += l;              \\\n+#define NEXTL(l) do {                                                   \\\n+    if (*(ctxt->input->cur) == '\\n') {                                  \\\n+        ctxt->input->line++; ctxt->input->col = 1;                      \\\n+    } else ctxt->input->col++;                                          \\\n+    ctxt->input->cur += l;                              \\\n@@ -2175,2 +2175,2 @@\n-#define COPY_BUF(l,b,i,v)                       \\\n-    if (l == 1) b[i++] = (xmlChar) v;                   \\\n+#define COPY_BUF(l,b,i,v)                                               \\\n+    if (l == 1) b[i++] = (xmlChar) v;                                   \\\n@@ -2197,17 +2197,6 @@\n-    if (ctxt->instate != XML_PARSER_DTD) {\n-    const xmlChar *cur;\n-    \/*\n-     * if we are in the document content, go really fast\n-     *\/\n-    cur = ctxt->input->cur;\n-    while (IS_BLANK_CH(*cur)) {\n-        if (*cur == '\\n') {\n-        ctxt->input->line++; ctxt->input->col = 1;\n-        } else {\n-        ctxt->input->col++;\n-        }\n-        cur++;\n-        res++;\n-        if (*cur == 0) {\n-        ctxt->input->cur = cur;\n-        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+    if (((ctxt->inputNr == 1) && (ctxt->instate != XML_PARSER_DTD)) ||\n+        (ctxt->instate == XML_PARSER_START)) {\n+        const xmlChar *cur;\n+        \/*\n+         * if we are in the document content, go really fast\n+         *\/\n@@ -2215,0 +2204,13 @@\n+        while (IS_BLANK_CH(*cur)) {\n+            if (*cur == '\\n') {\n+                ctxt->input->line++; ctxt->input->col = 1;\n+            } else {\n+                ctxt->input->col++;\n+            }\n+            cur++;\n+            res++;\n+            if (*cur == 0) {\n+                ctxt->input->cur = cur;\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                cur = ctxt->input->cur;\n+            }\n@@ -2216,2 +2218,1 @@\n-    }\n-    ctxt->input->cur = cur;\n+        ctxt->input->cur = cur;\n@@ -2221,1 +2222,1 @@\n-    while (1) {\n+        while (1) {\n@@ -2223,2 +2224,2 @@\n-        NEXT;\n-        } else if (CUR == '%') {\n+                NEXT;\n+            } else if (CUR == '%') {\n@@ -2228,1 +2229,1 @@\n-            if ((expandPE == 0) || (IS_BLANK_CH(NXT(1))) || (NXT(1) == 0))\n+                if ((expandPE == 0) || (IS_BLANK_CH(NXT(1))) || (NXT(1) == 0))\n@@ -2230,1 +2231,1 @@\n-            xmlParsePEReference(ctxt);\n+                xmlParsePEReference(ctxt);\n@@ -2246,1 +2247,1 @@\n-        res++;\n+            res++;\n@@ -2253,3 +2254,3 @@\n- *                                  *\n- *      Commodity functions to handle entities          *\n- *                                  *\n+ *                                                                      *\n+ *              Commodity functions to handle entities                  *\n+ *                                                                      *\n@@ -2271,2 +2272,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"Popping input %d\\n\", ctxt->inputNr);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"Popping input %d\\n\", ctxt->inputNr);\n@@ -2298,1 +2299,4 @@\n-    if ((ctxt->input != NULL) && (ctxt->input->filename))\n+        if ((ctxt->input != NULL) && (ctxt->input->filename))\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"%s(%d): \", ctxt->input->filename,\n+                    ctxt->input->line);\n@@ -2300,4 +2304,1 @@\n-            \"%s(%d): \", ctxt->input->filename,\n-            ctxt->input->line);\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);\n+                \"Pushing input %d : %.30s\\n\", ctxt->inputNr+1, input->cur);\n@@ -2310,1 +2311,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2344,5 +2345,1 @@\n-    SKIP(3);\n-    GROW;\n-    while (RAW != ';') { \/* loop blocked by count *\/\n-        if (count++ > 20) {\n-        count = 0;\n+        SKIP(3);\n@@ -2350,0 +2347,4 @@\n+        while (RAW != ';') { \/* loop blocked by count *\/\n+            if (count++ > 20) {\n+                count = 0;\n+                GROW;\n@@ -2352,0 +2353,17 @@\n+            }\n+            if ((RAW >= '0') && (RAW <= '9'))\n+                val = val * 16 + (CUR - '0');\n+            else if ((RAW >= 'a') && (RAW <= 'f') && (count < 20))\n+                val = val * 16 + (CUR - 'a') + 10;\n+            else if ((RAW >= 'A') && (RAW <= 'F') && (count < 20))\n+                val = val * 16 + (CUR - 'A') + 10;\n+            else {\n+                xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);\n+                val = 0;\n+                break;\n+            }\n+            if (val > 0x110000)\n+                val = 0x110000;\n+\n+            NEXT;\n+            count++;\n@@ -2353,10 +2371,4 @@\n-        if ((RAW >= '0') && (RAW <= '9'))\n-            val = val * 16 + (CUR - '0');\n-        else if ((RAW >= 'a') && (RAW <= 'f') && (count < 20))\n-            val = val * 16 + (CUR - 'a') + 10;\n-        else if ((RAW >= 'A') && (RAW <= 'F') && (count < 20))\n-            val = val * 16 + (CUR - 'A') + 10;\n-        else {\n-        xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);\n-        val = 0;\n-        break;\n+        if (RAW == ';') {\n+            \/* on purpose to avoid reentrancy problems with NEXT and SKIP *\/\n+            ctxt->input->col++;\n+            ctxt->input->cur++;\n@@ -2364,11 +2376,0 @@\n-        if (val > 0x110000)\n-            val = 0x110000;\n-\n-        NEXT;\n-        count++;\n-    }\n-    if (RAW == ';') {\n-        \/* on purpose to avoid reentrancy problems with NEXT and SKIP *\/\n-        ctxt->input->col++;\n-        ctxt->input->cur++;\n-    }\n@@ -2376,5 +2377,1 @@\n-    SKIP(2);\n-    GROW;\n-    while (RAW != ';') { \/* loop blocked by count *\/\n-        if (count++ > 20) {\n-        count = 0;\n+        SKIP(2);\n@@ -2382,0 +2379,4 @@\n+        while (RAW != ';') { \/* loop blocked by count *\/\n+            if (count++ > 20) {\n+                count = 0;\n+                GROW;\n@@ -2384,0 +2385,13 @@\n+            }\n+            if ((RAW >= '0') && (RAW <= '9'))\n+                val = val * 10 + (CUR - '0');\n+            else {\n+                xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);\n+                val = 0;\n+                break;\n+            }\n+            if (val > 0x110000)\n+                val = 0x110000;\n+\n+            NEXT;\n+            count++;\n@@ -2385,6 +2399,4 @@\n-        if ((RAW >= '0') && (RAW <= '9'))\n-            val = val * 10 + (CUR - '0');\n-        else {\n-        xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);\n-        val = 0;\n-        break;\n+        if (RAW == ';') {\n+            \/* on purpose to avoid reentrancy problems with NEXT and SKIP *\/\n+            ctxt->input->col++;\n+            ctxt->input->cur++;\n@@ -2392,11 +2404,0 @@\n-        if (val > 0x110000)\n-            val = 0x110000;\n-\n-        NEXT;\n-        count++;\n-    }\n-    if (RAW == ';') {\n-        \/* on purpose to avoid reentrancy problems with NEXT and SKIP *\/\n-        ctxt->input->col++;\n-        ctxt->input->cur++;\n-    }\n@@ -2415,1 +2416,1 @@\n-            val);\n+                val);\n@@ -2421,1 +2422,1 @@\n-                      val);\n+                          val);\n@@ -2454,18 +2455,1 @@\n-    ptr += 3;\n-    cur = *ptr;\n-    while (cur != ';') { \/* Non input consuming loop *\/\n-        if ((cur >= '0') && (cur <= '9'))\n-            val = val * 16 + (cur - '0');\n-        else if ((cur >= 'a') && (cur <= 'f'))\n-            val = val * 16 + (cur - 'a') + 10;\n-        else if ((cur >= 'A') && (cur <= 'F'))\n-            val = val * 16 + (cur - 'A') + 10;\n-        else {\n-        xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);\n-        val = 0;\n-        break;\n-        }\n-        if (val > 0x110000)\n-            val = 0x110000;\n-\n-        ptr++;\n+        ptr += 3;\n@@ -2473,16 +2457,14 @@\n-    }\n-    if (cur == ';')\n-        ptr++;\n-    } else if  ((cur == '&') && (ptr[1] == '#')){\n-    ptr += 2;\n-    cur = *ptr;\n-    while (cur != ';') { \/* Non input consuming loops *\/\n-        if ((cur >= '0') && (cur <= '9'))\n-            val = val * 10 + (cur - '0');\n-        else {\n-        xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);\n-        val = 0;\n-        break;\n-        }\n-        if (val > 0x110000)\n-            val = 0x110000;\n+        while (cur != ';') { \/* Non input consuming loop *\/\n+            if ((cur >= '0') && (cur <= '9'))\n+                val = val * 16 + (cur - '0');\n+            else if ((cur >= 'a') && (cur <= 'f'))\n+                val = val * 16 + (cur - 'a') + 10;\n+            else if ((cur >= 'A') && (cur <= 'F'))\n+                val = val * 16 + (cur - 'A') + 10;\n+            else {\n+                xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);\n+                val = 0;\n+                break;\n+            }\n+            if (val > 0x110000)\n+                val = 0x110000;\n@@ -2490,1 +2472,7 @@\n-        ptr++;\n+            ptr++;\n+            cur = *ptr;\n+        }\n+        if (cur == ';')\n+            ptr++;\n+    } else if  ((cur == '&') && (ptr[1] == '#')){\n+        ptr += 2;\n@@ -2492,3 +2480,16 @@\n-    }\n-    if (cur == ';')\n-        ptr++;\n+        while (cur != ';') { \/* Non input consuming loops *\/\n+            if ((cur >= '0') && (cur <= '9'))\n+                val = val * 10 + (cur - '0');\n+            else {\n+                xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);\n+                val = 0;\n+                break;\n+            }\n+            if (val > 0x110000)\n+                val = 0x110000;\n+\n+            ptr++;\n+            cur = *ptr;\n+        }\n+        if (cur == ';')\n+            ptr++;\n@@ -2496,2 +2497,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);\n-    return(0);\n+        xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);\n+        return(0);\n@@ -2514,2 +2515,2 @@\n-              \"xmlParseStringCharRef: invalid xmlChar value %d\\n\",\n-              val);\n+                          \"xmlParseStringCharRef: invalid xmlChar value %d\\n\",\n+                          val);\n@@ -2555,2 +2556,2 @@\n-    case XML_PARSER_CDATA_SECTION:\n-        return;\n+        case XML_PARSER_CDATA_SECTION:\n+            return;\n@@ -2558,5 +2559,5 @@\n-        return;\n-    case XML_PARSER_START_TAG:\n-        return;\n-    case XML_PARSER_END_TAG:\n-        return;\n+            return;\n+        case XML_PARSER_START_TAG:\n+            return;\n+        case XML_PARSER_END_TAG:\n+            return;\n@@ -2564,2 +2565,2 @@\n-        xmlFatalErr(ctxt, XML_ERR_PEREF_AT_EOF, NULL);\n-        return;\n+            xmlFatalErr(ctxt, XML_ERR_PEREF_AT_EOF, NULL);\n+            return;\n@@ -2567,5 +2568,5 @@\n-    case XML_PARSER_START:\n-    case XML_PARSER_MISC:\n-        xmlFatalErr(ctxt, XML_ERR_PEREF_IN_PROLOG, NULL);\n-        return;\n-    case XML_PARSER_ENTITY_DECL:\n+        case XML_PARSER_START:\n+        case XML_PARSER_MISC:\n+            xmlFatalErr(ctxt, XML_ERR_PEREF_IN_PROLOG, NULL);\n+            return;\n+        case XML_PARSER_ENTITY_DECL:\n@@ -2575,4 +2576,4 @@\n-    case XML_PARSER_SYSTEM_LITERAL:\n-    case XML_PARSER_PUBLIC_LITERAL:\n-        \/* we just ignore it there *\/\n-        return;\n+        case XML_PARSER_SYSTEM_LITERAL:\n+        case XML_PARSER_PUBLIC_LITERAL:\n+            \/* we just ignore it there *\/\n+            return;\n@@ -2580,11 +2581,11 @@\n-        xmlFatalErr(ctxt, XML_ERR_PEREF_IN_EPILOG, NULL);\n-        return;\n-    case XML_PARSER_ENTITY_VALUE:\n-        \/*\n-         * NOTE: in the case of entity values, we don't do the\n-         *       substitution here since we need the literal\n-         *       entity value to be able to save the internal\n-         *       subset of the document.\n-         *       This will be handled by xmlStringDecodeEntities\n-         *\/\n-        return;\n+            xmlFatalErr(ctxt, XML_ERR_PEREF_IN_EPILOG, NULL);\n+            return;\n+        case XML_PARSER_ENTITY_VALUE:\n+            \/*\n+             * NOTE: in the case of entity values, we don't do the\n+             *       substitution here since we need the literal\n+             *       entity value to be able to save the internal\n+             *       subset of the document.\n+             *       This will be handled by xmlStringDecodeEntities\n+             *\/\n+            return;\n@@ -2592,11 +2593,11 @@\n-        \/*\n-         * [WFC: Well-Formedness Constraint: PEs in Internal Subset]\n-         * In the internal DTD subset, parameter-entity references\n-         * can occur only where markup declarations can occur, not\n-         * within markup declarations.\n-         * In that case this is handled in xmlParseMarkupDecl\n-         *\/\n-        if ((ctxt->external == 0) && (ctxt->inputNr == 1))\n-        return;\n-        if (IS_BLANK_CH(NXT(1)) || NXT(1) == 0)\n-        return;\n+            \/*\n+             * [WFC: Well-Formedness Constraint: PEs in Internal Subset]\n+             * In the internal DTD subset, parameter-entity references\n+             * can occur only where markup declarations can occur, not\n+             * within markup declarations.\n+             * In that case this is handled in xmlParseMarkupDecl\n+             *\/\n+            if ((ctxt->external == 0) && (ctxt->inputNr == 1))\n+                return;\n+            if (IS_BLANK_CH(NXT(1)) || NXT(1) == 0)\n+                return;\n@@ -2616,2 +2617,2 @@\n-#define growBuffer(buffer, n) {                     \\\n-    xmlChar *tmp;                           \\\n+#define growBuffer(buffer, n) {                                         \\\n+    xmlChar *tmp;                                                       \\\n@@ -2621,2 +2622,2 @@\n-    if (tmp == NULL) goto mem_error;                    \\\n-    buffer = tmp;                           \\\n+    if (tmp == NULL) goto mem_error;                                    \\\n+    buffer = tmp;                                                       \\\n@@ -2647,1 +2648,1 @@\n-              int what, xmlChar end, xmlChar  end2, xmlChar end3) {\n+                      int what, xmlChar end, xmlChar  end2, xmlChar end3) {\n@@ -2659,1 +2660,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2664,3 +2665,3 @@\n-    (ctxt->depth > 1024)) {\n-    xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n-    return(NULL);\n+        (ctxt->depth > 1024)) {\n+        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n+        return(NULL);\n@@ -2681,1 +2682,1 @@\n-    c = CUR_SCHAR(str, l);\n+        c = CUR_SCHAR(str, l);\n@@ -2688,1 +2689,1 @@\n-    if (c == 0) break;\n+        if (c == 0) break;\n@@ -2690,2 +2691,2 @@\n-        int val = xmlParseStringCharRef(ctxt, &str);\n-        if (val == 0)\n+            int val = xmlParseStringCharRef(ctxt, &str);\n+            if (val == 0)\n@@ -2693,17 +2694,1 @@\n-        COPY_BUF(0,buffer,nbchars,val);\n-        if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n-            growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n-        }\n-    } else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) {\n-        if (xmlParserDebugEntities)\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"String decoding Entity Reference: %.30s\\n\",\n-            str);\n-        ent = xmlParseStringEntityRef(ctxt, &str);\n-        xmlParserEntityCheck(ctxt, 0, ent, 0);\n-        if (ent != NULL)\n-            ctxt->nbentities += ent->checked \/ 2;\n-        if ((ent != NULL) &&\n-        (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-        if (ent->content != NULL) {\n-            COPY_BUF(0,buffer,nbchars,ent->content[0]);\n+            COPY_BUF(0,buffer,nbchars,val);\n@@ -2711,1 +2696,1 @@\n-            growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n+                growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n@@ -2713,3 +2698,19 @@\n-        } else {\n-            xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n-                \"predefined entity has no content\\n\");\n+        } else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) {\n+            if (xmlParserDebugEntities)\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"String decoding Entity Reference: %.30s\\n\",\n+                        str);\n+            ent = xmlParseStringEntityRef(ctxt, &str);\n+            xmlParserEntityCheck(ctxt, 0, ent, 0);\n+            if (ent != NULL)\n+                ctxt->nbentities += ent->checked \/ 2;\n+            if ((ent != NULL) &&\n+                (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                if (ent->content != NULL) {\n+                    COPY_BUF(0,buffer,nbchars,ent->content[0]);\n+                    if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n+                        growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n+                    }\n+                } else {\n+                    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n+                            \"predefined entity has no content\\n\");\n@@ -2717,7 +2718,7 @@\n-        }\n-        } else if ((ent != NULL) && (ent->content != NULL)) {\n-        ctxt->depth++;\n-        rep = xmlStringDecodeEntities(ctxt, ent->content, what,\n-                                  0, 0, 0);\n-        ctxt->depth--;\n-        if (rep == NULL) {\n+                }\n+            } else if ((ent != NULL) && (ent->content != NULL)) {\n+                ctxt->depth++;\n+                rep = xmlStringDecodeEntities(ctxt, ent->content, what,\n+                                              0, 0, 0);\n+                ctxt->depth--;\n+                if (rep == NULL) {\n@@ -2739,3 +2740,3 @@\n-        } else if (ent != NULL) {\n-        int i = xmlStrlen(ent->name);\n-        const xmlChar *cur = ent->name;\n+            } else if (ent != NULL) {\n+                int i = xmlStrlen(ent->name);\n+                const xmlChar *cur = ent->name;\n@@ -2743,32 +2744,7 @@\n-        buffer[nbchars++] = '&';\n-        if (nbchars + i + XML_PARSER_BUFFER_SIZE > buffer_size) {\n-            growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);\n-        }\n-        for (;i > 0;i--)\n-            buffer[nbchars++] = *cur++;\n-        buffer[nbchars++] = ';';\n-        }\n-    } else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) {\n-        if (xmlParserDebugEntities)\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"String decoding PE Reference: %.30s\\n\", str);\n-        ent = xmlParseStringPEReference(ctxt, &str);\n-        xmlParserEntityCheck(ctxt, 0, ent, 0);\n-        if (ent != NULL)\n-            ctxt->nbentities += ent->checked \/ 2;\n-        if (ent != NULL) {\n-                if (ent->content == NULL) {\n-            \/*\n-             * Note: external parsed entities will not be loaded,\n-             * it is not required for a non-validating parser to\n-             * complete external PEReferences coming from the\n-             * internal subset\n-             *\/\n-            if (((ctxt->options & XML_PARSE_NOENT) != 0) ||\n-            ((ctxt->options & XML_PARSE_DTDVALID) != 0) ||\n-            (ctxt->validate != 0)) {\n-            xmlLoadEntityContent(ctxt, ent);\n-            } else {\n-            xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,\n-          \"not validating will not read content for PE entity %s\\n\",\n-                              ent->name, NULL);\n+                buffer[nbchars++] = '&';\n+                if (nbchars + i + XML_PARSER_BUFFER_SIZE > buffer_size) {\n+                    growBuffer(buffer, i + XML_PARSER_BUFFER_SIZE);\n+                }\n+                for (;i > 0;i--)\n+                    buffer[nbchars++] = *cur++;\n+                buffer[nbchars++] = ';';\n@@ -2776,6 +2752,31 @@\n-        }\n-        ctxt->depth++;\n-        rep = xmlStringDecodeEntities(ctxt, ent->content, what,\n-                                  0, 0, 0);\n-        ctxt->depth--;\n-        if (rep == NULL) {\n+        } else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) {\n+            if (xmlParserDebugEntities)\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"String decoding PE Reference: %.30s\\n\", str);\n+            ent = xmlParseStringPEReference(ctxt, &str);\n+            xmlParserEntityCheck(ctxt, 0, ent, 0);\n+            if (ent != NULL)\n+                ctxt->nbentities += ent->checked \/ 2;\n+            if (ent != NULL) {\n+                if (ent->content == NULL) {\n+                    \/*\n+                     * Note: external parsed entities will not be loaded,\n+                     * it is not required for a non-validating parser to\n+                     * complete external PEReferences coming from the\n+                     * internal subset\n+                     *\/\n+                    if (((ctxt->options & XML_PARSE_NOENT) != 0) ||\n+                        ((ctxt->options & XML_PARSE_DTDVALID) != 0) ||\n+                        (ctxt->validate != 0)) {\n+                        xmlLoadEntityContent(ctxt, ent);\n+                    } else {\n+                        xmlWarningMsg(ctxt, XML_ERR_ENTITY_PROCESSING,\n+                  \"not validating will not read content for PE entity %s\\n\",\n+                                      ent->name, NULL);\n+                    }\n+                }\n+                ctxt->depth++;\n+                rep = xmlStringDecodeEntities(ctxt, ent->content, what,\n+                                              0, 0, 0);\n+                ctxt->depth--;\n+                if (rep == NULL) {\n@@ -2797,0 +2798,7 @@\n+            }\n+        } else {\n+            COPY_BUF(l,buffer,nbchars,c);\n+            str += l;\n+            if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n+                growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n+            }\n@@ -2798,11 +2806,4 @@\n-    } else {\n-        COPY_BUF(l,buffer,nbchars,c);\n-        str += l;\n-        if (nbchars + XML_PARSER_BUFFER_SIZE > buffer_size) {\n-            growBuffer(buffer, XML_PARSER_BUFFER_SIZE);\n-        }\n-    }\n-    if (str < last)\n-        c = CUR_SCHAR(str, l);\n-    else\n-        c = 0;\n+        if (str < last)\n+            c = CUR_SCHAR(str, l);\n+        else\n+            c = 0;\n@@ -2843,1 +2844,1 @@\n-                xmlChar end, xmlChar  end2, xmlChar end3) {\n+                        xmlChar end, xmlChar  end2, xmlChar end3) {\n@@ -2850,3 +2851,3 @@\n- *                                  *\n- *      Commodity functions, cleanup needed ?           *\n- *                                  *\n+ *                                                                      *\n+ *              Commodity functions, cleanup needed ?                   *\n+ *                                                                      *\n@@ -2877,1 +2878,1 @@\n-    return(0);\n+        return(0);\n@@ -2884,1 +2885,1 @@\n-    return(0);\n+        return(0);\n@@ -2890,2 +2891,2 @@\n-    for (i = 0;i < len;i++)\n-        if (!(IS_BLANK_CH(str[i]))) return(0);\n+        for (i = 0;i < len;i++)\n+            if (!(IS_BLANK_CH(str[i]))) return(0);\n@@ -2899,1 +2900,1 @@\n-    ret = xmlIsMixedElement(ctxt->myDoc, ctxt->node->name);\n+        ret = xmlIsMixedElement(ctxt->myDoc, ctxt->node->name);\n@@ -2909,1 +2910,1 @@\n-    (RAW == '<') && (NXT(1) == '\/')) return(0);\n+        (RAW == '<') && (NXT(1) == '\/')) return(0);\n@@ -2924,4 +2925,4 @@\n- *                                  *\n- *      Extra stuff for namespace support           *\n- *  Relates to http:\/\/www.w3.org\/TR\/WD-xml-names            *\n- *                                  *\n+ *                                                                      *\n+ *              Extra stuff for namespace support                       *\n+ *      Relates to http:\/\/www.w3.org\/TR\/WD-xml-names                    *\n+ *                                                                      *\n@@ -2967,1 +2968,1 @@\n-    return(xmlStrdup(name));\n+        return(xmlStrdup(name));\n@@ -2972,1 +2973,1 @@\n-    return(xmlStrdup(name));\n+        return(xmlStrdup(name));\n@@ -2976,2 +2977,2 @@\n-    buf[len++] = c;\n-    c = *cur++;\n+        buf[len++] = c;\n+        c = *cur++;\n@@ -2980,15 +2981,5 @@\n-    \/*\n-     * Okay someone managed to make a huge name, so he's ready to pay\n-     * for the processing speed.\n-     *\/\n-    max = len * 2;\n-\n-    buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));\n-    if (buffer == NULL) {\n-        xmlErrMemory(ctxt, NULL);\n-        return(NULL);\n-    }\n-    memcpy(buffer, buf, len);\n-    while ((c != 0) && (c != ':')) { \/* tested bigname.xml *\/\n-        if (len + 10 > max) {\n-            xmlChar *tmp;\n+        \/*\n+         * Okay someone managed to make a huge name, so he's ready to pay\n+         * for the processing speed.\n+         *\/\n+        max = len * 2;\n@@ -2996,5 +2987,2 @@\n-        max *= 2;\n-        tmp = (xmlChar *) xmlRealloc(buffer,\n-                        max * sizeof(xmlChar));\n-        if (tmp == NULL) {\n-            xmlFree(buffer);\n+        buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));\n+        if (buffer == NULL) {\n@@ -3004,1 +2992,17 @@\n-        buffer = tmp;\n+        memcpy(buffer, buf, len);\n+        while ((c != 0) && (c != ':')) { \/* tested bigname.xml *\/\n+            if (len + 10 > max) {\n+                xmlChar *tmp;\n+\n+                max *= 2;\n+                tmp = (xmlChar *) xmlRealloc(buffer,\n+                                                max * sizeof(xmlChar));\n+                if (tmp == NULL) {\n+                    xmlFree(buffer);\n+                    xmlErrMemory(ctxt, NULL);\n+                    return(NULL);\n+                }\n+                buffer = tmp;\n+            }\n+            buffer[len++] = c;\n+            c = *cur++;\n@@ -3006,4 +3010,1 @@\n-        buffer[len++] = c;\n-        c = *cur++;\n-    }\n-    buffer[len] = 0;\n+        buffer[len] = 0;\n@@ -3014,3 +3015,3 @@\n-        xmlFree(buffer);\n-    *prefix = NULL;\n-    return(xmlStrdup(name));\n+            xmlFree(buffer);\n+        *prefix = NULL;\n+        return(xmlStrdup(name));\n@@ -3020,1 +3021,1 @@\n-    ret = xmlStrndup(buf, len);\n+        ret = xmlStrndup(buf, len);\n@@ -3022,3 +3023,3 @@\n-    ret = buffer;\n-    buffer = NULL;\n-    max = XML_MAX_NAMELEN;\n+        ret = buffer;\n+        buffer = NULL;\n+        max = XML_MAX_NAMELEN;\n@@ -3029,1 +3030,1 @@\n-    c = *cur;\n+        c = *cur;\n@@ -3031,19 +3032,2 @@\n-    if (c == 0) {\n-        return(xmlStrndup(BAD_CAST \"\", 0));\n-    }\n-    len = 0;\n-\n-    \/*\n-     * Check that the first character is proper to start\n-     * a new name\n-     *\/\n-    if (!(((c >= 0x61) && (c <= 0x7A)) ||\n-          ((c >= 0x41) && (c <= 0x5A)) ||\n-          (c == '_') || (c == ':'))) {\n-        int l;\n-        int first = CUR_SCHAR(cur, l);\n-\n-        if (!IS_LETTER(first) && (first != '_')) {\n-        xmlFatalErrMsgStr(ctxt, XML_NS_ERR_QNAME,\n-                \"Name %s is not XML Namespace compliant\\n\",\n-                  name);\n+        if (c == 0) {\n+            return(xmlStrndup(BAD_CAST \"\", 0));\n@@ -3051,2 +3035,1 @@\n-    }\n-    cur++;\n+        len = 0;\n@@ -3054,5 +3037,0 @@\n-    while ((c != 0) && (len < max)) { \/* tested bigname2.xml *\/\n-        buf[len++] = c;\n-        c = *cur++;\n-    }\n-    if (len >= max) {\n@@ -3060,2 +3038,2 @@\n-         * Okay someone managed to make a huge name, so he's ready to pay\n-         * for the processing speed.\n+         * Check that the first character is proper to start\n+         * a new name\n@@ -3063,1 +3041,13 @@\n-        max = len * 2;\n+        if (!(((c >= 0x61) && (c <= 0x7A)) ||\n+              ((c >= 0x41) && (c <= 0x5A)) ||\n+              (c == '_') || (c == ':'))) {\n+            int l;\n+            int first = CUR_SCHAR(cur, l);\n+\n+            if (!IS_LETTER(first) && (first != '_')) {\n+                xmlFatalErrMsgStr(ctxt, XML_NS_ERR_QNAME,\n+                            \"Name %s is not XML Namespace compliant\\n\",\n+                                  name);\n+            }\n+        }\n+        cur++;\n@@ -3065,4 +3055,3 @@\n-        buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));\n-        if (buffer == NULL) {\n-            xmlErrMemory(ctxt, NULL);\n-        return(NULL);\n+        while ((c != 0) && (len < max)) { \/* tested bigname2.xml *\/\n+            buf[len++] = c;\n+            c = *cur++;\n@@ -3070,4 +3059,6 @@\n-        memcpy(buffer, buf, len);\n-        while (c != 0) { \/* tested bigname2.xml *\/\n-        if (len + 10 > max) {\n-            xmlChar *tmp;\n+        if (len >= max) {\n+            \/*\n+             * Okay someone managed to make a huge name, so he's ready to pay\n+             * for the processing speed.\n+             *\/\n+            max = len * 2;\n@@ -3075,7 +3066,4 @@\n-            max *= 2;\n-            tmp = (xmlChar *) xmlRealloc(buffer,\n-                            max * sizeof(xmlChar));\n-            if (tmp == NULL) {\n-            xmlErrMemory(ctxt, NULL);\n-            xmlFree(buffer);\n-            return(NULL);\n+            buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));\n+            if (buffer == NULL) {\n+                xmlErrMemory(ctxt, NULL);\n+                return(NULL);\n@@ -3083,4 +3071,19 @@\n-            buffer = tmp;\n-        }\n-        buffer[len++] = c;\n-        c = *cur++;\n+            memcpy(buffer, buf, len);\n+            while (c != 0) { \/* tested bigname2.xml *\/\n+                if (len + 10 > max) {\n+                    xmlChar *tmp;\n+\n+                    max *= 2;\n+                    tmp = (xmlChar *) xmlRealloc(buffer,\n+                                                    max * sizeof(xmlChar));\n+                    if (tmp == NULL) {\n+                        xmlErrMemory(ctxt, NULL);\n+                        xmlFree(buffer);\n+                        return(NULL);\n+                    }\n+                    buffer = tmp;\n+                }\n+                buffer[len++] = c;\n+                c = *cur++;\n+            }\n+            buffer[len] = 0;\n@@ -3088,2 +3091,0 @@\n-        buffer[len] = 0;\n-    }\n@@ -3091,5 +3092,5 @@\n-    if (buffer == NULL)\n-        ret = xmlStrndup(buf, len);\n-    else {\n-        ret = buffer;\n-    }\n+        if (buffer == NULL)\n+            ret = xmlStrndup(buf, len);\n+        else {\n+            ret = buffer;\n+        }\n@@ -3102,4 +3103,4 @@\n- *                                  *\n- *          The parser itself               *\n- *  Relates to http:\/\/www.w3.org\/TR\/REC-xml             *\n- *                                  *\n+ *                                                                      *\n+ *                      The parser itself                               *\n+ *      Relates to http:\/\/www.w3.org\/TR\/REC-xml                         *\n+ *                                                                      *\n@@ -3109,3 +3110,3 @@\n- *                                  *\n- *  Routines to parse Name, NCName and NmToken          *\n- *                                  *\n+ *                                                                      *\n+ *      Routines to parse Name, NCName and NmToken                      *\n+ *                                                                      *\n@@ -3136,20 +3137,20 @@\n-     * Use the new checks of production [4] [4a] amd [5] of the\n-     * Update 5 of XML-1.0\n-     *\/\n-    if ((c != ' ') && (c != '>') && (c != '\/') && \/* accelerators *\/\n-        (((c >= 'a') && (c <= 'z')) ||\n-         ((c >= 'A') && (c <= 'Z')) ||\n-         (c == '_') || (c == ':') ||\n-         ((c >= 0xC0) && (c <= 0xD6)) ||\n-         ((c >= 0xD8) && (c <= 0xF6)) ||\n-         ((c >= 0xF8) && (c <= 0x2FF)) ||\n-         ((c >= 0x370) && (c <= 0x37D)) ||\n-         ((c >= 0x37F) && (c <= 0x1FFF)) ||\n-         ((c >= 0x200C) && (c <= 0x200D)) ||\n-         ((c >= 0x2070) && (c <= 0x218F)) ||\n-         ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n-         ((c >= 0x3001) && (c <= 0xD7FF)) ||\n-         ((c >= 0xF900) && (c <= 0xFDCF)) ||\n-         ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n-         ((c >= 0x10000) && (c <= 0xEFFFF))))\n-        return(1);\n+         * Use the new checks of production [4] [4a] amd [5] of the\n+         * Update 5 of XML-1.0\n+         *\/\n+        if ((c != ' ') && (c != '>') && (c != '\/') && \/* accelerators *\/\n+            (((c >= 'a') && (c <= 'z')) ||\n+             ((c >= 'A') && (c <= 'Z')) ||\n+             (c == '_') || (c == ':') ||\n+             ((c >= 0xC0) && (c <= 0xD6)) ||\n+             ((c >= 0xD8) && (c <= 0xF6)) ||\n+             ((c >= 0xF8) && (c <= 0x2FF)) ||\n+             ((c >= 0x370) && (c <= 0x37D)) ||\n+             ((c >= 0x37F) && (c <= 0x1FFF)) ||\n+             ((c >= 0x200C) && (c <= 0x200D)) ||\n+             ((c >= 0x2070) && (c <= 0x218F)) ||\n+             ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n+             ((c >= 0x3001) && (c <= 0xD7FF)) ||\n+             ((c >= 0xF900) && (c <= 0xFDCF)) ||\n+             ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n+             ((c >= 0x10000) && (c <= 0xEFFFF))))\n+            return(1);\n@@ -3158,1 +3159,1 @@\n-        return(1);\n+            return(1);\n@@ -3167,24 +3168,24 @@\n-     * Use the new checks of production [4] [4a] amd [5] of the\n-     * Update 5 of XML-1.0\n-     *\/\n-    if ((c != ' ') && (c != '>') && (c != '\/') && \/* accelerators *\/\n-        (((c >= 'a') && (c <= 'z')) ||\n-         ((c >= 'A') && (c <= 'Z')) ||\n-         ((c >= '0') && (c <= '9')) || \/* !start *\/\n-         (c == '_') || (c == ':') ||\n-         (c == '-') || (c == '.') || (c == 0xB7) || \/* !start *\/\n-         ((c >= 0xC0) && (c <= 0xD6)) ||\n-         ((c >= 0xD8) && (c <= 0xF6)) ||\n-         ((c >= 0xF8) && (c <= 0x2FF)) ||\n-         ((c >= 0x300) && (c <= 0x36F)) || \/* !start *\/\n-         ((c >= 0x370) && (c <= 0x37D)) ||\n-         ((c >= 0x37F) && (c <= 0x1FFF)) ||\n-         ((c >= 0x200C) && (c <= 0x200D)) ||\n-         ((c >= 0x203F) && (c <= 0x2040)) || \/* !start *\/\n-         ((c >= 0x2070) && (c <= 0x218F)) ||\n-         ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n-         ((c >= 0x3001) && (c <= 0xD7FF)) ||\n-         ((c >= 0xF900) && (c <= 0xFDCF)) ||\n-         ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n-         ((c >= 0x10000) && (c <= 0xEFFFF))))\n-         return(1);\n+         * Use the new checks of production [4] [4a] amd [5] of the\n+         * Update 5 of XML-1.0\n+         *\/\n+        if ((c != ' ') && (c != '>') && (c != '\/') && \/* accelerators *\/\n+            (((c >= 'a') && (c <= 'z')) ||\n+             ((c >= 'A') && (c <= 'Z')) ||\n+             ((c >= '0') && (c <= '9')) || \/* !start *\/\n+             (c == '_') || (c == ':') ||\n+             (c == '-') || (c == '.') || (c == 0xB7) || \/* !start *\/\n+             ((c >= 0xC0) && (c <= 0xD6)) ||\n+             ((c >= 0xD8) && (c <= 0xF6)) ||\n+             ((c >= 0xF8) && (c <= 0x2FF)) ||\n+             ((c >= 0x300) && (c <= 0x36F)) || \/* !start *\/\n+             ((c >= 0x370) && (c <= 0x37D)) ||\n+             ((c >= 0x37F) && (c <= 0x1FFF)) ||\n+             ((c >= 0x200C) && (c <= 0x200D)) ||\n+             ((c >= 0x203F) && (c <= 0x2040)) || \/* !start *\/\n+             ((c >= 0x2070) && (c <= 0x218F)) ||\n+             ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n+             ((c >= 0x3001) && (c <= 0xD7FF)) ||\n+             ((c >= 0xF900) && (c <= 0xFDCF)) ||\n+             ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n+             ((c >= 0x10000) && (c <= 0xEFFFF))))\n+             return(1);\n@@ -3194,4 +3195,4 @@\n-        (c == '_') || (c == ':') ||\n-        (IS_COMBINING(c)) ||\n-        (IS_EXTENDER(c)))\n-        return(1);\n+            (c == '_') || (c == ':') ||\n+            (IS_COMBINING(c)) ||\n+            (IS_EXTENDER(c)))\n+            return(1);\n@@ -3224,50 +3225,20 @@\n-     * Use the new checks of production [4] [4a] amd [5] of the\n-     * Update 5 of XML-1.0\n-     *\/\n-    if ((c == ' ') || (c == '>') || (c == '\/') || \/* accelerators *\/\n-        (!(((c >= 'a') && (c <= 'z')) ||\n-           ((c >= 'A') && (c <= 'Z')) ||\n-           (c == '_') || (c == ':') ||\n-           ((c >= 0xC0) && (c <= 0xD6)) ||\n-           ((c >= 0xD8) && (c <= 0xF6)) ||\n-           ((c >= 0xF8) && (c <= 0x2FF)) ||\n-           ((c >= 0x370) && (c <= 0x37D)) ||\n-           ((c >= 0x37F) && (c <= 0x1FFF)) ||\n-           ((c >= 0x200C) && (c <= 0x200D)) ||\n-           ((c >= 0x2070) && (c <= 0x218F)) ||\n-           ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n-           ((c >= 0x3001) && (c <= 0xD7FF)) ||\n-           ((c >= 0xF900) && (c <= 0xFDCF)) ||\n-           ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n-           ((c >= 0x10000) && (c <= 0xEFFFF))))) {\n-        return(NULL);\n-    }\n-    len += l;\n-    NEXTL(l);\n-    c = CUR_CHAR(l);\n-    while ((c != ' ') && (c != '>') && (c != '\/') && \/* accelerators *\/\n-           (((c >= 'a') && (c <= 'z')) ||\n-            ((c >= 'A') && (c <= 'Z')) ||\n-            ((c >= '0') && (c <= '9')) || \/* !start *\/\n-            (c == '_') || (c == ':') ||\n-            (c == '-') || (c == '.') || (c == 0xB7) || \/* !start *\/\n-            ((c >= 0xC0) && (c <= 0xD6)) ||\n-            ((c >= 0xD8) && (c <= 0xF6)) ||\n-            ((c >= 0xF8) && (c <= 0x2FF)) ||\n-            ((c >= 0x300) && (c <= 0x36F)) || \/* !start *\/\n-            ((c >= 0x370) && (c <= 0x37D)) ||\n-            ((c >= 0x37F) && (c <= 0x1FFF)) ||\n-            ((c >= 0x200C) && (c <= 0x200D)) ||\n-            ((c >= 0x203F) && (c <= 0x2040)) || \/* !start *\/\n-            ((c >= 0x2070) && (c <= 0x218F)) ||\n-            ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n-            ((c >= 0x3001) && (c <= 0xD7FF)) ||\n-            ((c >= 0xF900) && (c <= 0xFDCF)) ||\n-            ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n-            ((c >= 0x10000) && (c <= 0xEFFFF))\n-        )) {\n-        if (count++ > XML_PARSER_CHUNK_SIZE) {\n-        count = 0;\n-        GROW;\n-                if (ctxt->instate == XML_PARSER_EOF)\n-                    return(NULL);\n+         * Use the new checks of production [4] [4a] amd [5] of the\n+         * Update 5 of XML-1.0\n+         *\/\n+        if ((c == ' ') || (c == '>') || (c == '\/') || \/* accelerators *\/\n+            (!(((c >= 'a') && (c <= 'z')) ||\n+               ((c >= 'A') && (c <= 'Z')) ||\n+               (c == '_') || (c == ':') ||\n+               ((c >= 0xC0) && (c <= 0xD6)) ||\n+               ((c >= 0xD8) && (c <= 0xF6)) ||\n+               ((c >= 0xF8) && (c <= 0x2FF)) ||\n+               ((c >= 0x370) && (c <= 0x37D)) ||\n+               ((c >= 0x37F) && (c <= 0x1FFF)) ||\n+               ((c >= 0x200C) && (c <= 0x200D)) ||\n+               ((c >= 0x2070) && (c <= 0x218F)) ||\n+               ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n+               ((c >= 0x3001) && (c <= 0xD7FF)) ||\n+               ((c >= 0xF900) && (c <= 0xFDCF)) ||\n+               ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n+               ((c >= 0x10000) && (c <= 0xEFFFF))))) {\n+            return(NULL);\n@@ -3278,20 +3249,24 @@\n-    }\n-    } else {\n-    if ((c == ' ') || (c == '>') || (c == '\/') || \/* accelerators *\/\n-        (!IS_LETTER(c) && (c != '_') &&\n-         (c != ':'))) {\n-        return(NULL);\n-    }\n-    len += l;\n-    NEXTL(l);\n-    c = CUR_CHAR(l);\n-\n-    while ((c != ' ') && (c != '>') && (c != '\/') && \/* test bigname.xml *\/\n-           ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n-        (c == '.') || (c == '-') ||\n-        (c == '_') || (c == ':') ||\n-        (IS_COMBINING(c)) ||\n-        (IS_EXTENDER(c)))) {\n-        if (count++ > XML_PARSER_CHUNK_SIZE) {\n-        count = 0;\n-        GROW;\n+        while ((c != ' ') && (c != '>') && (c != '\/') && \/* accelerators *\/\n+               (((c >= 'a') && (c <= 'z')) ||\n+                ((c >= 'A') && (c <= 'Z')) ||\n+                ((c >= '0') && (c <= '9')) || \/* !start *\/\n+                (c == '_') || (c == ':') ||\n+                (c == '-') || (c == '.') || (c == 0xB7) || \/* !start *\/\n+                ((c >= 0xC0) && (c <= 0xD6)) ||\n+                ((c >= 0xD8) && (c <= 0xF6)) ||\n+                ((c >= 0xF8) && (c <= 0x2FF)) ||\n+                ((c >= 0x300) && (c <= 0x36F)) || \/* !start *\/\n+                ((c >= 0x370) && (c <= 0x37D)) ||\n+                ((c >= 0x37F) && (c <= 0x1FFF)) ||\n+                ((c >= 0x200C) && (c <= 0x200D)) ||\n+                ((c >= 0x203F) && (c <= 0x2040)) || \/* !start *\/\n+                ((c >= 0x2070) && (c <= 0x218F)) ||\n+                ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n+                ((c >= 0x3001) && (c <= 0xD7FF)) ||\n+                ((c >= 0xF900) && (c <= 0xFDCF)) ||\n+                ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n+                ((c >= 0x10000) && (c <= 0xEFFFF))\n+                )) {\n+            if (count++ > XML_PARSER_CHUNK_SIZE) {\n+                count = 0;\n+                GROW;\n@@ -3300,0 +3275,10 @@\n+            }\n+            len += l;\n+            NEXTL(l);\n+            c = CUR_CHAR(l);\n+        }\n+    } else {\n+        if ((c == ' ') || (c == '>') || (c == '\/') || \/* accelerators *\/\n+            (!IS_LETTER(c) && (c != '_') &&\n+             (c != ':'))) {\n+            return(NULL);\n@@ -3304,1 +3289,17 @@\n-    }\n+\n+        while ((c != ' ') && (c != '>') && (c != '\/') && \/* test bigname.xml *\/\n+               ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n+                (c == '.') || (c == '-') ||\n+                (c == '_') || (c == ':') ||\n+                (IS_COMBINING(c)) ||\n+                (IS_EXTENDER(c)))) {\n+            if (count++ > XML_PARSER_CHUNK_SIZE) {\n+                count = 0;\n+                GROW;\n+                if (ctxt->instate == XML_PARSER_EOF)\n+                    return(NULL);\n+            }\n+            len += l;\n+            NEXTL(l);\n+            c = CUR_CHAR(l);\n+        }\n@@ -3359,8 +3360,2 @@\n-    ((*in >= 0x41) && (*in <= 0x5A)) ||\n-    (*in == '_') || (*in == ':')) {\n-    in++;\n-    while (((*in >= 0x61) && (*in <= 0x7A)) ||\n-           ((*in >= 0x41) && (*in <= 0x5A)) ||\n-           ((*in >= 0x30) && (*in <= 0x39)) ||\n-           (*in == '_') || (*in == '-') ||\n-           (*in == ':') || (*in == '.'))\n+        ((*in >= 0x41) && (*in <= 0x5A)) ||\n+        (*in == '_') || (*in == ':')) {\n@@ -3368,2 +3363,8 @@\n-    if ((*in > 0) && (*in < 0x80)) {\n-        count = in - ctxt->input->cur;\n+        while (((*in >= 0x61) && (*in <= 0x7A)) ||\n+               ((*in >= 0x41) && (*in <= 0x5A)) ||\n+               ((*in >= 0x30) && (*in <= 0x39)) ||\n+               (*in == '_') || (*in == '-') ||\n+               (*in == ':') || (*in == '.'))\n+            in++;\n+        if ((*in > 0) && (*in < 0x80)) {\n+            count = in - ctxt->input->cur;\n@@ -3375,7 +3376,7 @@\n-        ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);\n-        ctxt->input->cur = in;\n-        ctxt->input->col += count;\n-        if (ret == NULL)\n-            xmlErrMemory(ctxt, NULL);\n-        return(ret);\n-    }\n+            ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);\n+            ctxt->input->cur = in;\n+            ctxt->input->col += count;\n+            if (ret == NULL)\n+                xmlErrMemory(ctxt, NULL);\n+            return(ret);\n+        }\n@@ -3405,2 +3406,2 @@\n-    (!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {\n-    return(NULL);\n+        (!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {\n+        return(NULL);\n@@ -3410,2 +3411,2 @@\n-       (xmlIsNameChar(ctxt, c) && (c != ':'))) {\n-    if (count++ > XML_PARSER_CHUNK_SIZE) {\n+           (xmlIsNameChar(ctxt, c) && (c != ':'))) {\n+        if (count++ > XML_PARSER_CHUNK_SIZE) {\n@@ -3417,2 +3418,2 @@\n-        count = 0;\n-        GROW;\n+            count = 0;\n+            GROW;\n@@ -3421,13 +3422,13 @@\n-    }\n-    len += l;\n-    NEXTL(l);\n-    c = CUR_CHAR(l);\n-    if (c == 0) {\n-        count = 0;\n-        \/*\n-         * when shrinking to extend the buffer we really need to preserve\n-         * the part of the name we already parsed. Hence rolling back\n-         * by current length.\n-         *\/\n-        ctxt->input->cur -= l;\n-        GROW;\n+        }\n+        len += l;\n+        NEXTL(l);\n+        c = CUR_CHAR(l);\n+        if (c == 0) {\n+            count = 0;\n+            \/*\n+             * when shrinking to extend the buffer we really need to preserve\n+             * the part of the name we already parsed. Hence rolling back\n+             * by current length.\n+             *\/\n+            ctxt->input->cur -= l;\n+            GROW;\n@@ -3436,3 +3437,3 @@\n-        ctxt->input->cur += l;\n-        c = CUR_CHAR(l);\n-    }\n+            ctxt->input->cur += l;\n+            c = CUR_CHAR(l);\n+        }\n@@ -3479,8 +3480,2 @@\n-     ((*in >= 0x41) && (*in <= 0x5A)) ||\n-     (*in == '_')) && (in < e)) {\n-    in++;\n-    while ((((*in >= 0x61) && (*in <= 0x7A)) ||\n-            ((*in >= 0x41) && (*in <= 0x5A)) ||\n-            ((*in >= 0x30) && (*in <= 0x39)) ||\n-            (*in == '_') || (*in == '-') ||\n-            (*in == '.')) && (in < e))\n+         ((*in >= 0x41) && (*in <= 0x5A)) ||\n+         (*in == '_')) && (in < e)) {\n@@ -3488,4 +3483,10 @@\n-    if (in >= e)\n-        goto complex;\n-    if ((*in > 0) && (*in < 0x80)) {\n-        count = in - ctxt->input->cur;\n+        while ((((*in >= 0x61) && (*in <= 0x7A)) ||\n+                ((*in >= 0x41) && (*in <= 0x5A)) ||\n+                ((*in >= 0x30) && (*in <= 0x39)) ||\n+                (*in == '_') || (*in == '-') ||\n+                (*in == '.')) && (in < e))\n+            in++;\n+        if (in >= e)\n+            goto complex;\n+        if ((*in > 0) && (*in < 0x80)) {\n+            count = in - ctxt->input->cur;\n@@ -3497,5 +3498,7 @@\n-        ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);\n-        ctxt->input->cur = in;\n-        ctxt->input->col += count;\n-        if (ret == NULL) {\n-            xmlErrMemory(ctxt, NULL);\n+            ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);\n+            ctxt->input->cur = in;\n+            ctxt->input->col += count;\n+            if (ret == NULL) {\n+                xmlErrMemory(ctxt, NULL);\n+            }\n+            return(ret);\n@@ -3503,2 +3506,0 @@\n-        return(ret);\n-    }\n@@ -3533,2 +3534,2 @@\n-    ++in;\n-    ++cmp;\n+        ++in;\n+        ++cmp;\n@@ -3537,4 +3538,4 @@\n-    \/* success *\/\n-    ctxt->input->col += in - ctxt->input->cur;\n-    ctxt->input->cur = in;\n-    return (const xmlChar*) 1;\n+        \/* success *\/\n+        ctxt->input->col += in - ctxt->input->cur;\n+        ctxt->input->cur = in;\n+        return (const xmlChar*) 1;\n@@ -3546,1 +3547,1 @@\n-    return (const xmlChar*) 1;\n+        return (const xmlChar*) 1;\n@@ -3582,1 +3583,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3589,10 +3590,10 @@\n-    COPY_BUF(l,buf,len,c);\n-    cur += l;\n-    c = CUR_SCHAR(cur, l);\n-    if (len >= XML_MAX_NAMELEN) { \/* test bigentname.xml *\/\n-        \/*\n-         * Okay someone managed to make a huge name, so he's ready to pay\n-         * for the processing speed.\n-         *\/\n-        xmlChar *buffer;\n-        int max = len * 2;\n+        COPY_BUF(l,buf,len,c);\n+        cur += l;\n+        c = CUR_SCHAR(cur, l);\n+        if (len >= XML_MAX_NAMELEN) { \/* test bigentname.xml *\/\n+            \/*\n+             * Okay someone managed to make a huge name, so he's ready to pay\n+             * for the processing speed.\n+             *\/\n+            xmlChar *buffer;\n+            int max = len * 2;\n@@ -3600,9 +3601,9 @@\n-        buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));\n-        if (buffer == NULL) {\n-            xmlErrMemory(ctxt, NULL);\n-        return(NULL);\n-        }\n-        memcpy(buffer, buf, len);\n-        while (xmlIsNameChar(ctxt, c)) {\n-        if (len + 10 > max) {\n-            xmlChar *tmp;\n+            buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));\n+            if (buffer == NULL) {\n+                xmlErrMemory(ctxt, NULL);\n+                return(NULL);\n+            }\n+            memcpy(buffer, buf, len);\n+            while (xmlIsNameChar(ctxt, c)) {\n+                if (len + 10 > max) {\n+                    xmlChar *tmp;\n@@ -3613,1 +3614,1 @@\n-            xmlFree(buffer);\n+                        xmlFree(buffer);\n@@ -3616,7 +3617,13 @@\n-            max *= 2;\n-            tmp = (xmlChar *) xmlRealloc(buffer,\n-                                        max * sizeof(xmlChar));\n-            if (tmp == NULL) {\n-            xmlErrMemory(ctxt, NULL);\n-            xmlFree(buffer);\n-            return(NULL);\n+                    max *= 2;\n+                    tmp = (xmlChar *) xmlRealloc(buffer,\n+                                                    max * sizeof(xmlChar));\n+                    if (tmp == NULL) {\n+                        xmlErrMemory(ctxt, NULL);\n+                        xmlFree(buffer);\n+                        return(NULL);\n+                    }\n+                    buffer = tmp;\n+                }\n+                COPY_BUF(l,buffer,len,c);\n+                cur += l;\n+                c = CUR_SCHAR(cur, l);\n@@ -3624,5 +3631,3 @@\n-            buffer = tmp;\n-        }\n-        COPY_BUF(l,buffer,len,c);\n-        cur += l;\n-        c = CUR_SCHAR(cur, l);\n+            buffer[len] = 0;\n+            *str = cur;\n+            return(buffer);\n@@ -3630,4 +3635,0 @@\n-        buffer[len] = 0;\n-        *str = cur;\n-        return(buffer);\n-    }\n@@ -3674,29 +3675,0 @@\n-    if (count++ > XML_PARSER_CHUNK_SIZE) {\n-        count = 0;\n-        GROW;\n-    }\n-    COPY_BUF(l,buf,len,c);\n-    NEXTL(l);\n-    c = CUR_CHAR(l);\n-    if (c == 0) {\n-        count = 0;\n-        GROW;\n-        if (ctxt->instate == XML_PARSER_EOF)\n-        return(NULL);\n-            c = CUR_CHAR(l);\n-    }\n-    if (len >= XML_MAX_NAMELEN) {\n-        \/*\n-         * Okay someone managed to make a huge token, so he's ready to pay\n-         * for the processing speed.\n-         *\/\n-        xmlChar *buffer;\n-        int max = len * 2;\n-\n-        buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));\n-        if (buffer == NULL) {\n-            xmlErrMemory(ctxt, NULL);\n-        return(NULL);\n-        }\n-        memcpy(buffer, buf, len);\n-        while (xmlIsNameChar(ctxt, c)) {\n@@ -3706,0 +3678,29 @@\n+        }\n+        COPY_BUF(l,buf,len,c);\n+        NEXTL(l);\n+        c = CUR_CHAR(l);\n+        if (c == 0) {\n+            count = 0;\n+            GROW;\n+            if (ctxt->instate == XML_PARSER_EOF)\n+                return(NULL);\n+            c = CUR_CHAR(l);\n+        }\n+        if (len >= XML_MAX_NAMELEN) {\n+            \/*\n+             * Okay someone managed to make a huge token, so he's ready to pay\n+             * for the processing speed.\n+             *\/\n+            xmlChar *buffer;\n+            int max = len * 2;\n+\n+            buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));\n+            if (buffer == NULL) {\n+                xmlErrMemory(ctxt, NULL);\n+                return(NULL);\n+            }\n+            memcpy(buffer, buf, len);\n+            while (xmlIsNameChar(ctxt, c)) {\n+                if (count++ > XML_PARSER_CHUNK_SIZE) {\n+                    count = 0;\n+                    GROW;\n@@ -3710,3 +3711,3 @@\n-        }\n-        if (len + 10 > max) {\n-            xmlChar *tmp;\n+                }\n+                if (len + 10 > max) {\n+                    xmlChar *tmp;\n@@ -3720,7 +3721,13 @@\n-            max *= 2;\n-            tmp = (xmlChar *) xmlRealloc(buffer,\n-                                        max * sizeof(xmlChar));\n-            if (tmp == NULL) {\n-            xmlErrMemory(ctxt, NULL);\n-            xmlFree(buffer);\n-            return(NULL);\n+                    max *= 2;\n+                    tmp = (xmlChar *) xmlRealloc(buffer,\n+                                                    max * sizeof(xmlChar));\n+                    if (tmp == NULL) {\n+                        xmlErrMemory(ctxt, NULL);\n+                        xmlFree(buffer);\n+                        return(NULL);\n+                    }\n+                    buffer = tmp;\n+                }\n+                COPY_BUF(l,buffer,len,c);\n+                NEXTL(l);\n+                c = CUR_CHAR(l);\n@@ -3728,1 +3735,2 @@\n-            buffer = tmp;\n+            buffer[len] = 0;\n+            return(buffer);\n@@ -3730,7 +3738,0 @@\n-        COPY_BUF(l,buffer,len,c);\n-        NEXTL(l);\n-        c = CUR_CHAR(l);\n-        }\n-        buffer[len] = 0;\n-        return(buffer);\n-    }\n@@ -3756,1 +3757,1 @@\n- *                 \"'\" ([^%&'] | PEReference | Reference)* \"'\"\n+ *                     \"'\" ([^%&'] | PEReference | Reference)* \"'\"\n@@ -3775,2 +3776,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_ENTITY_NOT_STARTED, NULL);\n-    return(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ENTITY_NOT_STARTED, NULL);\n+        return(NULL);\n@@ -3780,2 +3781,2 @@\n-    xmlErrMemory(ctxt, NULL);\n-    return(NULL);\n+        xmlErrMemory(ctxt, NULL);\n+        return(NULL);\n@@ -3805,3 +3806,3 @@\n-        (ctxt->input != input))) && (ctxt->instate != XML_PARSER_EOF)) {\n-    if (len + 5 >= size) {\n-        xmlChar *tmp;\n+            (ctxt->input != input))) && (ctxt->instate != XML_PARSER_EOF)) {\n+        if (len + 5 >= size) {\n+            xmlChar *tmp;\n@@ -3809,4 +3810,4 @@\n-        size *= 2;\n-        tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n-        if (tmp == NULL) {\n-        xmlErrMemory(ctxt, NULL);\n+            size *= 2;\n+            tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n+            if (tmp == NULL) {\n+                xmlErrMemory(ctxt, NULL);\n@@ -3814,0 +3815,2 @@\n+            }\n+            buf = tmp;\n@@ -3815,4 +3818,2 @@\n-        buf = tmp;\n-    }\n-    COPY_BUF(l,buf,len,c);\n-    NEXTL(l);\n+        COPY_BUF(l,buf,len,c);\n+        NEXTL(l);\n@@ -3820,3 +3821,0 @@\n-    GROW;\n-    c = CUR_CHAR(l);\n-    if (c == 0) {\n@@ -3825,1 +3823,4 @@\n-    }\n+        if (c == 0) {\n+            GROW;\n+            c = CUR_CHAR(l);\n+        }\n@@ -3843,3 +3844,3 @@\n-    if ((*cur == '%') || ((*cur == '&') && (cur[1] != '#'))) {\n-        xmlChar *name;\n-        xmlChar tmp = *cur;\n+        if ((*cur == '%') || ((*cur == '&') && (cur[1] != '#'))) {\n+            xmlChar *name;\n+            xmlChar tmp = *cur;\n@@ -3848,2 +3849,2 @@\n-        cur++;\n-        name = xmlParseStringName(ctxt, &cur);\n+            cur++;\n+            name = xmlParseStringName(ctxt, &cur);\n@@ -3855,3 +3856,3 @@\n-        xmlFatalErrMsgInt(ctxt, XML_ERR_ENTITY_CHAR_ERROR,\n-        \"EntityValue: '%c' forbidden except for entities references\\n\",\n-                              tmp);\n+                xmlFatalErrMsgInt(ctxt, XML_ERR_ENTITY_CHAR_ERROR,\n+            \"EntityValue: '%c' forbidden except for entities references\\n\",\n+                                  tmp);\n@@ -3859,4 +3860,4 @@\n-        }\n-        if ((tmp == '%') && (ctxt->inSubset == 1) &&\n-        (ctxt->inputNr == 1)) {\n-        xmlFatalErr(ctxt, XML_ERR_ENTITY_PE_INTERNAL, NULL);\n+            }\n+            if ((tmp == '%') && (ctxt->inSubset == 1) &&\n+                (ctxt->inputNr == 1)) {\n+                xmlFatalErr(ctxt, XML_ERR_ENTITY_PE_INTERNAL, NULL);\n@@ -3864,0 +3865,3 @@\n+            }\n+            if (*cur == 0)\n+                break;\n@@ -3865,4 +3869,1 @@\n-        if (*cur == 0)\n-            break;\n-    }\n-    cur++;\n+        cur++;\n@@ -3918,2 +3919,2 @@\n-    ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n-    limit = '\"';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = '\"';\n@@ -3922,2 +3923,2 @@\n-    limit = '\\'';\n-    ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n+        limit = '\\'';\n+        ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;\n@@ -3926,2 +3927,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-    return(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n@@ -3954,4 +3955,4 @@\n-    if (c == '&') {\n-        in_space = 0;\n-        if (NXT(1) == '#') {\n-        int val = xmlParseCharRef(ctxt);\n+        if (c == '&') {\n+            in_space = 0;\n+            if (NXT(1) == '#') {\n+                int val = xmlParseCharRef(ctxt);\n@@ -3959,43 +3960,26 @@\n-        if (val == '&') {\n-            if (ctxt->replaceEntities) {\n-            if (len + 10 > buf_size) {\n-                growBuffer(buf, 10);\n-            }\n-            buf[len++] = '&';\n-            } else {\n-            \/*\n-             * The reparsing will be done in xmlStringGetNodeList()\n-             * called by the attribute() function in SAX.c\n-             *\/\n-            if (len + 10 > buf_size) {\n-                growBuffer(buf, 10);\n-            }\n-            buf[len++] = '&';\n-            buf[len++] = '#';\n-            buf[len++] = '3';\n-            buf[len++] = '8';\n-            buf[len++] = ';';\n-            }\n-        } else if (val != 0) {\n-            if (len + 10 > buf_size) {\n-            growBuffer(buf, 10);\n-            }\n-            len += xmlCopyChar(0, &buf[len], val);\n-        }\n-        } else {\n-        ent = xmlParseEntityRef(ctxt);\n-        ctxt->nbentities++;\n-        if (ent != NULL)\n-            ctxt->nbentities += ent->owner;\n-        if ((ent != NULL) &&\n-            (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-            if (len + 10 > buf_size) {\n-            growBuffer(buf, 10);\n-            }\n-            if ((ctxt->replaceEntities == 0) &&\n-                (ent->content[0] == '&')) {\n-            buf[len++] = '&';\n-            buf[len++] = '#';\n-            buf[len++] = '3';\n-            buf[len++] = '8';\n-            buf[len++] = ';';\n+                if (val == '&') {\n+                    if (ctxt->replaceEntities) {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = '&';\n+                    } else {\n+                        \/*\n+                         * The reparsing will be done in xmlStringGetNodeList()\n+                         * called by the attribute() function in SAX.c\n+                         *\/\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        buf[len++] = '&';\n+                        buf[len++] = '#';\n+                        buf[len++] = '3';\n+                        buf[len++] = '8';\n+                        buf[len++] = ';';\n+                    }\n+                } else if (val != 0) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    len += xmlCopyChar(0, &buf[len], val);\n+                }\n@@ -4003,13 +3987,30 @@\n-            buf[len++] = ent->content[0];\n-            }\n-        } else if ((ent != NULL) &&\n-                   (ctxt->replaceEntities != 0)) {\n-            if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n-            ++ctxt->depth;\n-            rep = xmlStringDecodeEntities(ctxt, ent->content,\n-                              XML_SUBSTITUTE_REF,\n-                              0, 0, 0);\n-            --ctxt->depth;\n-            if (rep != NULL) {\n-                current = rep;\n-                while (*current != 0) { \/* non input consuming *\/\n+                ent = xmlParseEntityRef(ctxt);\n+                ctxt->nbentities++;\n+                if (ent != NULL)\n+                    ctxt->nbentities += ent->owner;\n+                if ((ent != NULL) &&\n+                    (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    if (len + 10 > buf_size) {\n+                        growBuffer(buf, 10);\n+                    }\n+                    if ((ctxt->replaceEntities == 0) &&\n+                        (ent->content[0] == '&')) {\n+                        buf[len++] = '&';\n+                        buf[len++] = '#';\n+                        buf[len++] = '3';\n+                        buf[len++] = '8';\n+                        buf[len++] = ';';\n+                    } else {\n+                        buf[len++] = ent->content[0];\n+                    }\n+                } else if ((ent != NULL) &&\n+                           (ctxt->replaceEntities != 0)) {\n+                    if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {\n+                        ++ctxt->depth;\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                      XML_SUBSTITUTE_REF,\n+                                                      0, 0, 0);\n+                        --ctxt->depth;\n+                        if (rep != NULL) {\n+                            current = rep;\n+                            while (*current != 0) { \/* non input consuming *\/\n@@ -4022,30 +4023,30 @@\n-                if (len + 10 > buf_size) {\n-                    growBuffer(buf, 10);\n-                }\n-                }\n-                xmlFree(rep);\n-                rep = NULL;\n-            }\n-            } else {\n-            if (len + 10 > buf_size) {\n-                growBuffer(buf, 10);\n-            }\n-            if (ent->content != NULL)\n-                buf[len++] = ent->content[0];\n-            }\n-        } else if (ent != NULL) {\n-            int i = xmlStrlen(ent->name);\n-            const xmlChar *cur = ent->name;\n-\n-            \/*\n-             * This may look absurd but is needed to detect\n-             * entities problems\n-             *\/\n-            if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-            (ent->content != NULL) && (ent->checked == 0)) {\n-            unsigned long oldnbent = ctxt->nbentities, diff;\n-\n-            ++ctxt->depth;\n-            rep = xmlStringDecodeEntities(ctxt, ent->content,\n-                          XML_SUBSTITUTE_REF, 0, 0, 0);\n-            --ctxt->depth;\n+                                if (len + 10 > buf_size) {\n+                                    growBuffer(buf, 10);\n+                                }\n+                            }\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        }\n+                    } else {\n+                        if (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                        if (ent->content != NULL)\n+                            buf[len++] = ent->content[0];\n+                    }\n+                } else if (ent != NULL) {\n+                    int i = xmlStrlen(ent->name);\n+                    const xmlChar *cur = ent->name;\n+\n+                    \/*\n+                     * This may look absurd but is needed to detect\n+                     * entities problems\n+                     *\/\n+                    if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+                        (ent->content != NULL) && (ent->checked == 0)) {\n+                        unsigned long oldnbent = ctxt->nbentities, diff;\n+\n+                        ++ctxt->depth;\n+                        rep = xmlStringDecodeEntities(ctxt, ent->content,\n+                                                  XML_SUBSTITUTE_REF, 0, 0, 0);\n+                        --ctxt->depth;\n@@ -4057,6 +4058,6 @@\n-            if (rep != NULL) {\n-                if (xmlStrchr(rep, '<'))\n-                    ent->checked |= 1;\n-                xmlFree(rep);\n-                rep = NULL;\n-            } else {\n+                        if (rep != NULL) {\n+                            if (xmlStrchr(rep, '<'))\n+                                ent->checked |= 1;\n+                            xmlFree(rep);\n+                            rep = NULL;\n+                        } else {\n@@ -4065,1 +4066,1 @@\n-            }\n+                    }\n@@ -4067,20 +4068,11 @@\n-            \/*\n-             * Just output the reference\n-             *\/\n-            buf[len++] = '&';\n-            while (len + i + 10 > buf_size) {\n-            growBuffer(buf, i + 10);\n-            }\n-            for (;i > 0;i--)\n-            buf[len++] = *cur++;\n-            buf[len++] = ';';\n-        }\n-        }\n-    } else {\n-        if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n-            if ((len != 0) || (!normalize)) {\n-            if ((!normalize) || (!in_space)) {\n-            COPY_BUF(l,buf,len,0x20);\n-            while (len + 10 > buf_size) {\n-                growBuffer(buf, 10);\n-            }\n+                    \/*\n+                     * Just output the reference\n+                     *\/\n+                    buf[len++] = '&';\n+                    while (len + i + 10 > buf_size) {\n+                        growBuffer(buf, i + 10);\n+                    }\n+                    for (;i > 0;i--)\n+                        buf[len++] = *cur++;\n+                    buf[len++] = ';';\n+                }\n@@ -4088,2 +4080,0 @@\n-            in_space = 1;\n-        }\n@@ -4091,5 +4081,18 @@\n-            in_space = 0;\n-        COPY_BUF(l,buf,len,c);\n-        if (len + 10 > buf_size) {\n-            growBuffer(buf, 10);\n-        }\n+            if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {\n+                if ((len != 0) || (!normalize)) {\n+                    if ((!normalize) || (!in_space)) {\n+                        COPY_BUF(l,buf,len,0x20);\n+                        while (len + 10 > buf_size) {\n+                            growBuffer(buf, 10);\n+                        }\n+                    }\n+                    in_space = 1;\n+                }\n+            } else {\n+                in_space = 0;\n+                COPY_BUF(l,buf,len,c);\n+                if (len + 10 > buf_size) {\n+                    growBuffer(buf, 10);\n+                }\n+            }\n+            NEXTL(l);\n@@ -4097,4 +4100,2 @@\n-        NEXTL(l);\n-    }\n-    GROW;\n-    c = CUR_CHAR(l);\n+        GROW;\n+        c = CUR_CHAR(l);\n@@ -4110,1 +4111,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);\n@@ -4112,6 +4113,6 @@\n-    if ((c != 0) && (!IS_CHAR(c))) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-               \"invalid character in attribute value\\n\");\n-    } else {\n-        xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-               \"AttValue: ' expected\\n\");\n+        if ((c != 0) && (!IS_CHAR(c))) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n+                           \"invalid character in attribute value\\n\");\n+        } else {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n+                           \"AttValue: ' expected\\n\");\n@@ -4120,1 +4121,1 @@\n-    NEXT;\n+        NEXT;\n@@ -4209,1 +4210,1 @@\n-    stop = '\"';\n+        stop = '\"';\n@@ -4212,1 +4213,1 @@\n-    stop = '\\'';\n+        stop = '\\'';\n@@ -4214,2 +4215,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);\n-    return(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);\n+        return(NULL);\n@@ -4221,1 +4222,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4226,2 +4227,2 @@\n-    if (len + 5 >= size) {\n-        xmlChar *tmp;\n+        if (len + 5 >= size) {\n+            xmlChar *tmp;\n@@ -4233,1 +4234,1 @@\n-        ctxt->instate = (xmlParserInputState) state;\n+                ctxt->instate = (xmlParserInputState) state;\n@@ -4236,7 +4237,9 @@\n-        size *= 2;\n-        tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n-        if (tmp == NULL) {\n-            xmlFree(buf);\n-        xmlErrMemory(ctxt, NULL);\n-        ctxt->instate = (xmlParserInputState) state;\n-        return(NULL);\n+            size *= 2;\n+            tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n+            if (tmp == NULL) {\n+                xmlFree(buf);\n+                xmlErrMemory(ctxt, NULL);\n+                ctxt->instate = (xmlParserInputState) state;\n+                return(NULL);\n+            }\n+            buf = tmp;\n@@ -4244,7 +4247,5 @@\n-        buf = tmp;\n-    }\n-    count++;\n-    if (count > 50) {\n-        SHRINK;\n-        GROW;\n-        count = 0;\n+        count++;\n+        if (count > 50) {\n+            SHRINK;\n+            GROW;\n+            count = 0;\n@@ -4252,2 +4253,2 @@\n-            xmlFree(buf);\n-        return(NULL);\n+                xmlFree(buf);\n+                return(NULL);\n@@ -4255,7 +4256,3 @@\n-    }\n-    COPY_BUF(l,buf,len,cur);\n-    NEXTL(l);\n-    cur = CUR_CHAR(l);\n-    if (cur == 0) {\n-        GROW;\n-        SHRINK;\n+        }\n+        COPY_BUF(l,buf,len,cur);\n+        NEXTL(l);\n@@ -4263,1 +4260,5 @@\n-    }\n+        if (cur == 0) {\n+            GROW;\n+            SHRINK;\n+            cur = CUR_CHAR(l);\n+        }\n@@ -4268,1 +4269,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);\n@@ -4270,1 +4271,1 @@\n-    NEXT;\n+        NEXT;\n@@ -4299,1 +4300,1 @@\n-    stop = '\"';\n+        stop = '\"';\n@@ -4302,1 +4303,1 @@\n-    stop = '\\'';\n+        stop = '\\'';\n@@ -4304,2 +4305,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);\n-    return(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);\n+        return(NULL);\n@@ -4309,2 +4310,2 @@\n-    xmlErrMemory(ctxt, NULL);\n-    return(NULL);\n+        xmlErrMemory(ctxt, NULL);\n+        return(NULL);\n@@ -4315,2 +4316,2 @@\n-    if (len + 1 >= size) {\n-        xmlChar *tmp;\n+        if (len + 1 >= size) {\n+            xmlChar *tmp;\n@@ -4324,6 +4325,8 @@\n-        size *= 2;\n-        tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n-        if (tmp == NULL) {\n-        xmlErrMemory(ctxt, NULL);\n-        xmlFree(buf);\n-        return(NULL);\n+            size *= 2;\n+            tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n+            if (tmp == NULL) {\n+                xmlErrMemory(ctxt, NULL);\n+                xmlFree(buf);\n+                return(NULL);\n+            }\n+            buf = tmp;\n@@ -4331,8 +4334,6 @@\n-        buf = tmp;\n-    }\n-    buf[len++] = cur;\n-    count++;\n-    if (count > 50) {\n-        SHRINK;\n-        GROW;\n-        count = 0;\n+        buf[len++] = cur;\n+        count++;\n+        if (count > 50) {\n+            SHRINK;\n+            GROW;\n+            count = 0;\n@@ -4340,2 +4341,2 @@\n-        xmlFree(buf);\n-        return(NULL);\n+                xmlFree(buf);\n+                return(NULL);\n@@ -4343,6 +4344,2 @@\n-    }\n-    NEXT;\n-    cur = CUR;\n-    if (cur == 0) {\n-        GROW;\n-        SHRINK;\n+        }\n+        NEXT;\n@@ -4350,1 +4347,5 @@\n-    }\n+        if (cur == 0) {\n+            GROW;\n+            SHRINK;\n+            cur = CUR;\n+        }\n@@ -4354,1 +4355,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);\n@@ -4356,1 +4357,1 @@\n-    NEXT;\n+        NEXT;\n@@ -4433,5 +4434,1 @@\n-    in = ctxt->input->cur;\n-    do {\n-get_more_space:\n-        while (*in == 0x20) { in++; ctxt->input->col++; }\n-        if (*in == 0xA) {\n+        in = ctxt->input->cur;\n@@ -4439,24 +4436,8 @@\n-            ctxt->input->line++; ctxt->input->col = 1;\n-            in++;\n-        } while (*in == 0xA);\n-        goto get_more_space;\n-        }\n-        if (*in == '<') {\n-        nbchar = in - ctxt->input->cur;\n-        if (nbchar > 0) {\n-            const xmlChar *tmp = ctxt->input->cur;\n-            ctxt->input->cur = in;\n-\n-            if ((ctxt->sax != NULL) &&\n-                (ctxt->sax->ignorableWhitespace !=\n-                 ctxt->sax->characters)) {\n-            if (areBlanks(ctxt, tmp, nbchar, 1)) {\n-                if (ctxt->sax->ignorableWhitespace != NULL)\n-                ctxt->sax->ignorableWhitespace(ctxt->userData,\n-                               tmp, nbchar);\n-            } else {\n-                if (ctxt->sax->characters != NULL)\n-                ctxt->sax->characters(ctxt->userData,\n-                              tmp, nbchar);\n-                if (*ctxt->space == -1)\n-                    *ctxt->space = -2;\n+get_more_space:\n+            while (*in == 0x20) { in++; ctxt->input->col++; }\n+            if (*in == 0xA) {\n+                do {\n+                    ctxt->input->line++; ctxt->input->col = 1;\n+                    in++;\n+                } while (*in == 0xA);\n+                goto get_more_space;\n@@ -4464,4 +4445,27 @@\n-            } else if ((ctxt->sax != NULL) &&\n-                       (ctxt->sax->characters != NULL)) {\n-            ctxt->sax->characters(ctxt->userData,\n-                          tmp, nbchar);\n+            if (*in == '<') {\n+                nbchar = in - ctxt->input->cur;\n+                if (nbchar > 0) {\n+                    const xmlChar *tmp = ctxt->input->cur;\n+                    ctxt->input->cur = in;\n+\n+                    if ((ctxt->sax != NULL) &&\n+                        (ctxt->sax->ignorableWhitespace !=\n+                         ctxt->sax->characters)) {\n+                        if (areBlanks(ctxt, tmp, nbchar, 1)) {\n+                            if (ctxt->sax->ignorableWhitespace != NULL)\n+                                ctxt->sax->ignorableWhitespace(ctxt->userData,\n+                                                       tmp, nbchar);\n+                        } else {\n+                            if (ctxt->sax->characters != NULL)\n+                                ctxt->sax->characters(ctxt->userData,\n+                                                      tmp, nbchar);\n+                            if (*ctxt->space == -1)\n+                                *ctxt->space = -2;\n+                        }\n+                    } else if ((ctxt->sax != NULL) &&\n+                               (ctxt->sax->characters != NULL)) {\n+                        ctxt->sax->characters(ctxt->userData,\n+                                              tmp, nbchar);\n+                    }\n+                }\n+                return;\n@@ -4469,3 +4473,0 @@\n-        }\n-        return;\n-        }\n@@ -4475,41 +4476,21 @@\n-        while (test_char_data[*in]) {\n-        in++;\n-        ccol++;\n-        }\n-        ctxt->input->col = ccol;\n-        if (*in == 0xA) {\n-        do {\n-            ctxt->input->line++; ctxt->input->col = 1;\n-            in++;\n-        } while (*in == 0xA);\n-        goto get_more;\n-        }\n-        if (*in == ']') {\n-        if ((in[1] == ']') && (in[2] == '>')) {\n-            xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);\n-            ctxt->input->cur = in + 1;\n-            return;\n-        }\n-        in++;\n-        ctxt->input->col++;\n-        goto get_more;\n-        }\n-        nbchar = in - ctxt->input->cur;\n-        if (nbchar > 0) {\n-        if ((ctxt->sax != NULL) &&\n-            (ctxt->sax->ignorableWhitespace !=\n-             ctxt->sax->characters) &&\n-            (IS_BLANK_CH(*ctxt->input->cur))) {\n-            const xmlChar *tmp = ctxt->input->cur;\n-            ctxt->input->cur = in;\n-\n-            if (areBlanks(ctxt, tmp, nbchar, 0)) {\n-                if (ctxt->sax->ignorableWhitespace != NULL)\n-                ctxt->sax->ignorableWhitespace(ctxt->userData,\n-                               tmp, nbchar);\n-            } else {\n-                if (ctxt->sax->characters != NULL)\n-                ctxt->sax->characters(ctxt->userData,\n-                          tmp, nbchar);\n-            if (*ctxt->space == -1)\n-                *ctxt->space = -2;\n+            while (test_char_data[*in]) {\n+                in++;\n+                ccol++;\n+            }\n+            ctxt->input->col = ccol;\n+            if (*in == 0xA) {\n+                do {\n+                    ctxt->input->line++; ctxt->input->col = 1;\n+                    in++;\n+                } while (*in == 0xA);\n+                goto get_more;\n+            }\n+            if (*in == ']') {\n+                if ((in[1] == ']') && (in[2] == '>')) {\n+                    xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);\n+                    ctxt->input->cur = in + 1;\n+                    return;\n+                }\n+                in++;\n+                ctxt->input->col++;\n+                goto get_more;\n@@ -4517,0 +4498,20 @@\n+            nbchar = in - ctxt->input->cur;\n+            if (nbchar > 0) {\n+                if ((ctxt->sax != NULL) &&\n+                    (ctxt->sax->ignorableWhitespace !=\n+                     ctxt->sax->characters) &&\n+                    (IS_BLANK_CH(*ctxt->input->cur))) {\n+                    const xmlChar *tmp = ctxt->input->cur;\n+                    ctxt->input->cur = in;\n+\n+                    if (areBlanks(ctxt, tmp, nbchar, 0)) {\n+                        if (ctxt->sax->ignorableWhitespace != NULL)\n+                            ctxt->sax->ignorableWhitespace(ctxt->userData,\n+                                                           tmp, nbchar);\n+                    } else {\n+                        if (ctxt->sax->characters != NULL)\n+                            ctxt->sax->characters(ctxt->userData,\n+                                                  tmp, nbchar);\n+                        if (*ctxt->space == -1)\n+                            *ctxt->space = -2;\n+                    }\n@@ -4519,4 +4520,4 @@\n-        } else if (ctxt->sax != NULL) {\n-            if (ctxt->sax->characters != NULL)\n-            ctxt->sax->characters(ctxt->userData,\n-                          ctxt->input->cur, nbchar);\n+                } else if (ctxt->sax != NULL) {\n+                    if (ctxt->sax->characters != NULL)\n+                        ctxt->sax->characters(ctxt->userData,\n+                                              ctxt->input->cur, nbchar);\n@@ -4525,1 +4526,1 @@\n-        }\n+                }\n@@ -4529,5 +4530,1 @@\n-        }\n-        ctxt->input->cur = in;\n-        if (*in == 0xD) {\n-        in++;\n-        if (*in == 0xA) {\n+            }\n@@ -4535,14 +4532,18 @@\n-            in++;\n-            ctxt->input->line++; ctxt->input->col = 1;\n-            continue; \/* while *\/\n-        }\n-        in--;\n-        }\n-        if (*in == '<') {\n-        return;\n-        }\n-        if (*in == '&') {\n-        return;\n-        }\n-        SHRINK;\n-        GROW;\n+            if (*in == 0xD) {\n+                in++;\n+                if (*in == 0xA) {\n+                    ctxt->input->cur = in;\n+                    in++;\n+                    ctxt->input->line++; ctxt->input->col = 1;\n+                    continue; \/* while *\/\n+                }\n+                in--;\n+            }\n+            if (*in == '<') {\n+                return;\n+            }\n+            if (*in == '&') {\n+                return;\n+            }\n+            SHRINK;\n+            GROW;\n@@ -4550,4 +4551,4 @@\n-        return;\n-        in = ctxt->input->cur;\n-    } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));\n-    nbchar = 0;\n+                return;\n+            in = ctxt->input->cur;\n+        } while (((*in >= 0x20) && (*in <= 0x7F)) || (*in == 0x09) || (*in == 0x0a));\n+        nbchar = 0;\n@@ -4581,6 +4582,7 @@\n-       (IS_CHAR(cur))) \/* test also done in xmlCurrentChar() *\/ {\n-    if ((cur == ']') && (NXT(1) == ']') &&\n-        (NXT(2) == '>')) {\n-        if (cdata) break;\n-        else {\n-        xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);\n+           (IS_CHAR(cur))) \/* test also done in xmlCurrentChar() *\/ {\n+        if ((cur == ']') && (NXT(1) == ']') &&\n+            (NXT(2) == '>')) {\n+            if (cdata) break;\n+            else {\n+                xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);\n+            }\n@@ -4588,4 +4590,6 @@\n-    }\n-    COPY_BUF(l,buf,nbchar,cur);\n-    if (nbchar >= XML_PARSER_BIG_BUFFER_SIZE) {\n-        buf[nbchar] = 0;\n+        COPY_BUF(l,buf,nbchar,cur);\n+        \/* move current position before possible calling of ctxt->sax->characters *\/\n+        NEXTL(l);\n+        cur = CUR_CHAR(l);\n+        if (nbchar >= XML_PARSER_BIG_BUFFER_SIZE) {\n+            buf[nbchar] = 0;\n@@ -4593,18 +4597,18 @@\n-        \/*\n-         * OK the segment is to be consumed as chars.\n-         *\/\n-        if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n-        if (areBlanks(ctxt, buf, nbchar, 0)) {\n-            if (ctxt->sax->ignorableWhitespace != NULL)\n-            ctxt->sax->ignorableWhitespace(ctxt->userData,\n-                                           buf, nbchar);\n-        } else {\n-            if (ctxt->sax->characters != NULL)\n-            ctxt->sax->characters(ctxt->userData, buf, nbchar);\n-            if ((ctxt->sax->characters !=\n-                 ctxt->sax->ignorableWhitespace) &&\n-            (*ctxt->space == -1))\n-            *ctxt->space = -2;\n-        }\n-        }\n-        nbchar = 0;\n+            \/*\n+             * OK the segment is to be consumed as chars.\n+             *\/\n+            if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n+                if (areBlanks(ctxt, buf, nbchar, 0)) {\n+                    if (ctxt->sax->ignorableWhitespace != NULL)\n+                        ctxt->sax->ignorableWhitespace(ctxt->userData,\n+                                                       buf, nbchar);\n+                } else {\n+                    if (ctxt->sax->characters != NULL)\n+                        ctxt->sax->characters(ctxt->userData, buf, nbchar);\n+                    if ((ctxt->sax->characters !=\n+                         ctxt->sax->ignorableWhitespace) &&\n+                        (*ctxt->space == -1))\n+                        *ctxt->space = -2;\n+                }\n+            }\n+            nbchar = 0;\n@@ -4614,6 +4618,6 @@\n-    }\n-    count++;\n-    if (count > 50) {\n-        SHRINK;\n-        GROW;\n-        count = 0;\n+        }\n+        count++;\n+        if (count > 50) {\n+            SHRINK;\n+            GROW;\n+            count = 0;\n@@ -4621,4 +4625,2 @@\n-        return;\n-    }\n-    NEXTL(l);\n-    cur = CUR_CHAR(l);\n+                return;\n+        }\n@@ -4628,13 +4630,14 @@\n-    \/*\n-     * OK the segment is to be consumed as chars.\n-     *\/\n-    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n-        if (areBlanks(ctxt, buf, nbchar, 0)) {\n-        if (ctxt->sax->ignorableWhitespace != NULL)\n-            ctxt->sax->ignorableWhitespace(ctxt->userData, buf, nbchar);\n-        } else {\n-        if (ctxt->sax->characters != NULL)\n-            ctxt->sax->characters(ctxt->userData, buf, nbchar);\n-        if ((ctxt->sax->characters != ctxt->sax->ignorableWhitespace) &&\n-            (*ctxt->space == -1))\n-            *ctxt->space = -2;\n+        \/*\n+         * OK the segment is to be consumed as chars.\n+         *\/\n+        if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n+            if (areBlanks(ctxt, buf, nbchar, 0)) {\n+                if (ctxt->sax->ignorableWhitespace != NULL)\n+                    ctxt->sax->ignorableWhitespace(ctxt->userData, buf, nbchar);\n+            } else {\n+                if (ctxt->sax->characters != NULL)\n+                    ctxt->sax->characters(ctxt->userData, buf, nbchar);\n+                if ((ctxt->sax->characters != ctxt->sax->ignorableWhitespace) &&\n+                    (*ctxt->space == -1))\n+                    *ctxt->space = -2;\n+            }\n@@ -4643,1 +4646,0 @@\n-    }\n@@ -4645,1 +4647,1 @@\n-    \/* Generate the error and skip the offending character *\/\n+        \/* Generate the error and skip the offending character *\/\n@@ -4648,2 +4650,2 @@\n-                      cur);\n-    NEXTL(l);\n+                          cur);\n+        NEXTL(l);\n@@ -4684,7 +4686,7 @@\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                       \"Space required after 'SYSTEM'\\n\");\n-    }\n-    URI = xmlParseSystemLiteral(ctxt);\n-    if (URI == NULL) {\n-        xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);\n+        if (SKIP_BLANKS == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space required after 'SYSTEM'\\n\");\n+        }\n+        URI = xmlParseSystemLiteral(ctxt);\n+        if (URI == NULL) {\n+            xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);\n@@ -4694,12 +4696,0 @@\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-            \"Space required after 'PUBLIC'\\n\");\n-    }\n-    *publicID = xmlParsePubidLiteral(ctxt);\n-    if (*publicID == NULL) {\n-        xmlFatalErr(ctxt, XML_ERR_PUBID_REQUIRED, NULL);\n-    }\n-    if (strict) {\n-        \/*\n-         * We don't handle [83] so \"S SystemLiteral\" is required.\n-         *\/\n@@ -4707,2 +4697,2 @@\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-            \"Space required after the Public Identifier\\n\");\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                    \"Space required after 'PUBLIC'\\n\");\n@@ -4710,4 +4700,16 @@\n-    } else {\n-        \/*\n-         * We handle [83] so we return immediately, if\n-         * \"S SystemLiteral\" is not detected. We skip blanks if no\n+        *publicID = xmlParsePubidLiteral(ctxt);\n+        if (*publicID == NULL) {\n+            xmlFatalErr(ctxt, XML_ERR_PUBID_REQUIRED, NULL);\n+        }\n+        if (strict) {\n+            \/*\n+             * We don't handle [83] so \"S SystemLiteral\" is required.\n+             *\/\n+            if (SKIP_BLANKS == 0) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                        \"Space required after the Public Identifier\\n\");\n+            }\n+        } else {\n+            \/*\n+             * We handle [83] so we return immediately, if\n+             * \"S SystemLiteral\" is not detected. We skip blanks if no\n@@ -4716,7 +4718,7 @@\n-         *\/\n-        if (SKIP_BLANKS == 0) return(NULL);\n-        if ((CUR != '\\'') && (CUR != '\"')) return(NULL);\n-    }\n-    URI = xmlParseSystemLiteral(ctxt);\n-    if (URI == NULL) {\n-        xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);\n+             *\/\n+            if (SKIP_BLANKS == 0) return(NULL);\n+            if ((CUR != '\\'') && (CUR != '\"')) return(NULL);\n+        }\n+        URI = xmlParseSystemLiteral(ctxt);\n+        if (URI == NULL) {\n+            xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);\n@@ -4755,6 +4757,6 @@\n-    size = XML_PARSER_BUFFER_SIZE;\n-    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n-    if (buf == NULL) {\n-        xmlErrMemory(ctxt, NULL);\n-        return;\n-    }\n+        size = XML_PARSER_BUFFER_SIZE;\n+        buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n+        if (buf == NULL) {\n+            xmlErrMemory(ctxt, NULL);\n+            return;\n+        }\n@@ -4762,1 +4764,1 @@\n-    GROW;   \/* Assure there's enough input data *\/\n+    GROW;       \/* Assure there's enough input data *\/\n@@ -4769,3 +4771,3 @@\n-                      q);\n-    xmlFree (buf);\n-    return;\n+                          q);\n+        xmlFree (buf);\n+        return;\n@@ -4780,3 +4782,3 @@\n-                      q);\n-    xmlFree (buf);\n-    return;\n+                          q);\n+        xmlFree (buf);\n+        return;\n@@ -4790,4 +4792,4 @@\n-        (r != '-') || (q != '-'))) {\n-    if ((r == '-') && (q == '-')) {\n-        xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL);\n-    }\n+            (r != '-') || (q != '-'))) {\n+        if ((r == '-') && (q == '-')) {\n+            xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL);\n+        }\n@@ -4801,2 +4803,2 @@\n-    if (len + 5 >= size) {\n-        xmlChar *new_buf;\n+        if (len + 5 >= size) {\n+            xmlChar *new_buf;\n@@ -4805,8 +4807,8 @@\n-        new_size = size * 2;\n-        new_buf = (xmlChar *) xmlRealloc(buf, new_size);\n-        if (new_buf == NULL) {\n-        xmlFree (buf);\n-        xmlErrMemory(ctxt, NULL);\n-        return;\n-        }\n-        buf = new_buf;\n+            new_size = size * 2;\n+            new_buf = (xmlChar *) xmlRealloc(buf, new_size);\n+            if (new_buf == NULL) {\n+                xmlFree (buf);\n+                xmlErrMemory(ctxt, NULL);\n+                return;\n+            }\n+            buf = new_buf;\n@@ -4814,6 +4816,6 @@\n-    }\n-    COPY_BUF(ql,buf,len,q);\n-    q = r;\n-    ql = rl;\n-    r = cur;\n-    rl = l;\n+        }\n+        COPY_BUF(ql,buf,len,q);\n+        q = r;\n+        ql = rl;\n+        r = cur;\n+        rl = l;\n@@ -4821,5 +4823,5 @@\n-    count++;\n-    if (count > 50) {\n-        SHRINK;\n-        GROW;\n-        count = 0;\n+        count++;\n+        if (count > 50) {\n+            SHRINK;\n+            GROW;\n+            count = 0;\n@@ -4827,2 +4829,2 @@\n-        xmlFree(buf);\n-        return;\n+                xmlFree(buf);\n+                return;\n@@ -4830,6 +4832,2 @@\n-    }\n-    NEXTL(l);\n-    cur = CUR_CHAR(l);\n-    if (cur == 0) {\n-        SHRINK;\n-        GROW;\n+        }\n+        NEXTL(l);\n@@ -4837,1 +4835,5 @@\n-    }\n+        if (cur == 0) {\n+            SHRINK;\n+            GROW;\n+            cur = CUR_CHAR(l);\n+        }\n@@ -4841,2 +4843,2 @@\n-    xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n-                         \"Comment not terminated \\n<!--%.50s\\n\", buf);\n+        xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n+                             \"Comment not terminated \\n<!--%.50s\\n\", buf);\n@@ -4846,1 +4848,1 @@\n-                      cur);\n+                          cur);\n@@ -4848,3 +4850,3 @@\n-    if (inputid != ctxt->input->id) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n-                   \"Comment doesn't start and stop in the same\"\n+        if (inputid != ctxt->input->id) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+                           \"Comment doesn't start and stop in the same\"\n@@ -4852,1 +4854,1 @@\n-    }\n+        }\n@@ -4854,3 +4856,3 @@\n-    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n-        (!ctxt->disableSAX))\n-        ctxt->sax->comment(ctxt->userData, buf);\n+        if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n+            (!ctxt->disableSAX))\n+            ctxt->sax->comment(ctxt->userData, buf);\n@@ -4862,1 +4864,1 @@\n-             \"Comment not terminated\\n\", NULL);\n+                         \"Comment not terminated\\n\", NULL);\n@@ -4906,6 +4908,6 @@\n-    if (*in == 0xA) {\n-        do {\n-        ctxt->input->line++; ctxt->input->col = 1;\n-        in++;\n-        } while (*in == 0xA);\n-    }\n+        if (*in == 0xA) {\n+            do {\n+                ctxt->input->line++; ctxt->input->col = 1;\n+                in++;\n+            } while (*in == 0xA);\n+        }\n@@ -4914,45 +4916,5 @@\n-    while (((*in > '-') && (*in <= 0x7F)) ||\n-           ((*in >= 0x20) && (*in < '-')) ||\n-           (*in == 0x09)) {\n-            in++;\n-            ccol++;\n-    }\n-    ctxt->input->col = ccol;\n-    if (*in == 0xA) {\n-        do {\n-        ctxt->input->line++; ctxt->input->col = 1;\n-        in++;\n-        } while (*in == 0xA);\n-        goto get_more;\n-    }\n-    nbchar = in - ctxt->input->cur;\n-    \/*\n-     * save current set of data\n-     *\/\n-    if (nbchar > 0) {\n-        if ((ctxt->sax != NULL) &&\n-        (ctxt->sax->comment != NULL)) {\n-        if (buf == NULL) {\n-            if ((*in == '-') && (in[1] == '-'))\n-                size = nbchar + 1;\n-            else\n-                size = XML_PARSER_BUFFER_SIZE + nbchar;\n-            buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n-            if (buf == NULL) {\n-                xmlErrMemory(ctxt, NULL);\n-            ctxt->instate = state;\n-            return;\n-            }\n-            len = 0;\n-        } else if (len + nbchar + 1 >= size) {\n-            xmlChar *new_buf;\n-            size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n-            new_buf = (xmlChar *) xmlRealloc(buf,\n-                                             size * sizeof(xmlChar));\n-            if (new_buf == NULL) {\n-                xmlFree (buf);\n-            xmlErrMemory(ctxt, NULL);\n-            ctxt->instate = state;\n-            return;\n-            }\n-            buf = new_buf;\n+        while (((*in > '-') && (*in <= 0x7F)) ||\n+               ((*in >= 0x20) && (*in < '-')) ||\n+               (*in == 0x09)) {\n+                    in++;\n+                    ccol++;\n@@ -4960,3 +4922,44 @@\n-        memcpy(&buf[len], ctxt->input->cur, nbchar);\n-        len += nbchar;\n-        buf[len] = 0;\n+        ctxt->input->col = ccol;\n+        if (*in == 0xA) {\n+            do {\n+                ctxt->input->line++; ctxt->input->col = 1;\n+                in++;\n+            } while (*in == 0xA);\n+            goto get_more;\n+        }\n+        nbchar = in - ctxt->input->cur;\n+        \/*\n+         * save current set of data\n+         *\/\n+        if (nbchar > 0) {\n+            if ((ctxt->sax != NULL) &&\n+                (ctxt->sax->comment != NULL)) {\n+                if (buf == NULL) {\n+                    if ((*in == '-') && (in[1] == '-'))\n+                        size = nbchar + 1;\n+                    else\n+                        size = XML_PARSER_BUFFER_SIZE + nbchar;\n+                    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n+                    if (buf == NULL) {\n+                        xmlErrMemory(ctxt, NULL);\n+                        ctxt->instate = state;\n+                        return;\n+                    }\n+                    len = 0;\n+                } else if (len + nbchar + 1 >= size) {\n+                    xmlChar *new_buf;\n+                    size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n+                    new_buf = (xmlChar *) xmlRealloc(buf,\n+                                                     size * sizeof(xmlChar));\n+                    if (new_buf == NULL) {\n+                        xmlFree (buf);\n+                        xmlErrMemory(ctxt, NULL);\n+                        ctxt->instate = state;\n+                        return;\n+                    }\n+                    buf = new_buf;\n+                }\n+                memcpy(&buf[len], ctxt->input->cur, nbchar);\n+                len += nbchar;\n+                buf[len] = 0;\n+            }\n@@ -4964,1 +4967,0 @@\n-    }\n@@ -4972,8 +4974,0 @@\n-    ctxt->input->cur = in;\n-    if (*in == 0xA) {\n-        in++;\n-        ctxt->input->line++; ctxt->input->col = 1;\n-    }\n-    if (*in == 0xD) {\n-        in++;\n-        if (*in == 0xA) {\n@@ -4981,3 +4975,3 @@\n-        in++;\n-        ctxt->input->line++; ctxt->input->col = 1;\n-        continue; \/* while *\/\n+        if (*in == 0xA) {\n+            in++;\n+            ctxt->input->line++; ctxt->input->col = 1;\n@@ -4985,4 +4979,12 @@\n-        in--;\n-    }\n-    SHRINK;\n-    GROW;\n+        if (*in == 0xD) {\n+            in++;\n+            if (*in == 0xA) {\n+                ctxt->input->cur = in;\n+                in++;\n+                ctxt->input->line++; ctxt->input->col = 1;\n+                goto get_more;\n+            }\n+            in--;\n+        }\n+        SHRINK;\n+        GROW;\n@@ -4993,7 +4995,7 @@\n-    in = ctxt->input->cur;\n-    if (*in == '-') {\n-        if (in[1] == '-') {\n-            if (in[2] == '>') {\n-            if (ctxt->input->id != inputid) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n-                           \"comment doesn't start and stop in the\"\n+        in = ctxt->input->cur;\n+        if (*in == '-') {\n+            if (in[1] == '-') {\n+                if (in[2] == '>') {\n+                    if (ctxt->input->id != inputid) {\n+                        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+                                       \"comment doesn't start and stop in the\"\n@@ -5001,18 +5003,18 @@\n-            }\n-            SKIP(3);\n-            if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n-                (!ctxt->disableSAX)) {\n-            if (buf != NULL)\n-                ctxt->sax->comment(ctxt->userData, buf);\n-            else\n-                ctxt->sax->comment(ctxt->userData, BAD_CAST \"\");\n-            }\n-            if (buf != NULL)\n-                xmlFree(buf);\n-            if (ctxt->instate != XML_PARSER_EOF)\n-            ctxt->instate = state;\n-            return;\n-        }\n-        if (buf != NULL) {\n-            xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n-                              \"Double hyphen within comment: \"\n+                    }\n+                    SKIP(3);\n+                    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n+                        (!ctxt->disableSAX)) {\n+                        if (buf != NULL)\n+                            ctxt->sax->comment(ctxt->userData, buf);\n+                        else\n+                            ctxt->sax->comment(ctxt->userData, BAD_CAST \"\");\n+                    }\n+                    if (buf != NULL)\n+                        xmlFree(buf);\n+                    if (ctxt->instate != XML_PARSER_EOF)\n+                        ctxt->instate = state;\n+                    return;\n+                }\n+                if (buf != NULL) {\n+                    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n+                                      \"Double hyphen within comment: \"\n@@ -5020,4 +5022,4 @@\n-                      buf);\n-        } else\n-            xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n-                              \"Double hyphen within comment\\n\", NULL);\n+                                      buf);\n+                } else\n+                    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n+                                      \"Double hyphen within comment\\n\", NULL);\n@@ -5028,2 +5030,6 @@\n-        in++;\n-        ctxt->input->col++;\n+                in++;\n+                ctxt->input->col++;\n+            }\n+            in++;\n+            ctxt->input->col++;\n+            goto get_more;\n@@ -5031,4 +5037,0 @@\n-        in++;\n-        ctxt->input->col++;\n-        goto get_more;\n-    }\n@@ -5062,13 +5064,5 @@\n-    int i;\n-    if ((name[0] == 'x') && (name[1] == 'm') &&\n-        (name[2] == 'l') && (name[3] == 0)) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_RESERVED_XML_NAME,\n-         \"XML declaration allowed only at the start of the document\\n\");\n-        return(name);\n-    } else if (name[3] == 0) {\n-        xmlFatalErr(ctxt, XML_ERR_RESERVED_XML_NAME, NULL);\n-        return(name);\n-    }\n-    for (i = 0;;i++) {\n-        if (xmlW3CPIs[i] == NULL) break;\n-        if (xmlStrEqual(name, (const xmlChar *)xmlW3CPIs[i]))\n+        int i;\n+        if ((name[0] == 'x') && (name[1] == 'm') &&\n+            (name[2] == 'l') && (name[3] == 0)) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_RESERVED_XML_NAME,\n+                 \"XML declaration allowed only at the start of the document\\n\");\n@@ -5076,4 +5070,12 @@\n-    }\n-    xmlWarningMsg(ctxt, XML_ERR_RESERVED_XML_NAME,\n-              \"xmlParsePITarget: invalid name prefix 'xml'\\n\",\n-              NULL, NULL);\n+        } else if (name[3] == 0) {\n+            xmlFatalErr(ctxt, XML_ERR_RESERVED_XML_NAME, NULL);\n+            return(name);\n+        }\n+        for (i = 0;;i++) {\n+            if (xmlW3CPIs[i] == NULL) break;\n+            if (xmlStrEqual(name, (const xmlChar *)xmlW3CPIs[i]))\n+                return(name);\n+        }\n+        xmlWarningMsg(ctxt, XML_ERR_RESERVED_XML_NAME,\n+                      \"xmlParsePITarget: invalid name prefix 'xml'\\n\",\n+                      NULL, NULL);\n@@ -5082,2 +5084,2 @@\n-    xmlNsErr(ctxt, XML_NS_ERR_COLON,\n-         \"colons are forbidden from PI names '%s'\\n\", name, NULL, NULL);\n+        xmlNsErr(ctxt, XML_NS_ERR_COLON,\n+                 \"colons are forbidden from PI names '%s'\\n\", name, NULL, NULL);\n@@ -5113,1 +5115,1 @@\n-    goto error;\n+        goto error;\n@@ -5117,1 +5119,1 @@\n-    return;\n+        return;\n@@ -5123,1 +5125,1 @@\n-    goto error;\n+        goto error;\n@@ -5128,1 +5130,1 @@\n-    goto error;\n+        goto error;\n@@ -5133,1 +5135,1 @@\n-    goto error;\n+        goto error;\n@@ -5136,2 +5138,2 @@\n-    ctxt->catalogs = xmlCatalogAddLocal(ctxt->catalogs, URL);\n-    xmlFree(URL);\n+        ctxt->catalogs = xmlCatalogAddLocal(ctxt->catalogs, URL);\n+        xmlFree(URL);\n@@ -5143,2 +5145,2 @@\n-              \"Catalog PI syntax error: %s\\n\",\n-          catalog, NULL);\n+                  \"Catalog PI syntax error: %s\\n\",\n+                  catalog, NULL);\n@@ -5146,1 +5148,1 @@\n-    xmlFree(URL);\n+        xmlFree(URL);\n@@ -5172,2 +5174,2 @@\n-    int inputid = ctxt->input->id;\n-    state = ctxt->instate;\n+        int inputid = ctxt->input->id;\n+        state = ctxt->instate;\n@@ -5175,18 +5177,3 @@\n-    \/*\n-     * this is a Processing Instruction.\n-     *\/\n-    SKIP(2);\n-    SHRINK;\n-\n-    \/*\n-     * Parse the target name and check for special support like\n-     * namespace.\n-     *\/\n-        target = xmlParsePITarget(ctxt);\n-    if (target != NULL) {\n-        if ((RAW == '?') && (NXT(1) == '>')) {\n-        if (inputid != ctxt->input->id) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n-                               \"PI declaration doesn't start and stop in\"\n-                                   \" the same entity\\n\");\n-        }\n+        \/*\n+         * this is a Processing Instruction.\n+         *\/\n@@ -5194,0 +5181,1 @@\n+        SHRINK;\n@@ -5196,1 +5184,2 @@\n-         * SAX: PI detected.\n+         * Parse the target name and check for special support like\n+         * namespace.\n@@ -5198,30 +5187,20 @@\n-        if ((ctxt->sax) && (!ctxt->disableSAX) &&\n-            (ctxt->sax->processingInstruction != NULL))\n-            ctxt->sax->processingInstruction(ctxt->userData,\n-                                             target, NULL);\n-        if (ctxt->instate != XML_PARSER_EOF)\n-            ctxt->instate = state;\n-        return;\n-        }\n-        buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n-        if (buf == NULL) {\n-        xmlErrMemory(ctxt, NULL);\n-        ctxt->instate = state;\n-        return;\n-        }\n-        if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,\n-              \"ParsePI: PI %s space expected\\n\", target);\n-        }\n-        cur = CUR_CHAR(l);\n-        while (IS_CHAR(cur) && \/* checked *\/\n-           ((cur != '?') || (NXT(1) != '>'))) {\n-        if (len + 5 >= size) {\n-            xmlChar *tmp;\n-                    size_t new_size = size * 2;\n-            tmp = (xmlChar *) xmlRealloc(buf, new_size);\n-            if (tmp == NULL) {\n-            xmlErrMemory(ctxt, NULL);\n-            xmlFree(buf);\n-            ctxt->instate = state;\n-            return;\n+        target = xmlParsePITarget(ctxt);\n+        if (target != NULL) {\n+            if ((RAW == '?') && (NXT(1) == '>')) {\n+                if (inputid != ctxt->input->id) {\n+                    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+                                   \"PI declaration doesn't start and stop in\"\n+                                   \" the same entity\\n\");\n+                }\n+                SKIP(2);\n+\n+                \/*\n+                 * SAX: PI detected.\n+                 *\/\n+                if ((ctxt->sax) && (!ctxt->disableSAX) &&\n+                    (ctxt->sax->processingInstruction != NULL))\n+                    ctxt->sax->processingInstruction(ctxt->userData,\n+                                                     target, NULL);\n+                if (ctxt->instate != XML_PARSER_EOF)\n+                    ctxt->instate = state;\n+                return;\n@@ -5229,1 +5208,24 @@\n-            buf = tmp;\n+            buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n+            if (buf == NULL) {\n+                xmlErrMemory(ctxt, NULL);\n+                ctxt->instate = state;\n+                return;\n+            }\n+            if (SKIP_BLANKS == 0) {\n+                xmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,\n+                          \"ParsePI: PI %s space expected\\n\", target);\n+            }\n+            cur = CUR_CHAR(l);\n+            while (IS_CHAR(cur) && \/* checked *\/\n+                   ((cur != '?') || (NXT(1) != '>'))) {\n+                if (len + 5 >= size) {\n+                    xmlChar *tmp;\n+                    size_t new_size = size * 2;\n+                    tmp = (xmlChar *) xmlRealloc(buf, new_size);\n+                    if (tmp == NULL) {\n+                        xmlErrMemory(ctxt, NULL);\n+                        xmlFree(buf);\n+                        ctxt->instate = state;\n+                        return;\n+                    }\n+                    buf = tmp;\n@@ -5231,5 +5233,5 @@\n-        }\n-        count++;\n-        if (count > 50) {\n-            SHRINK;\n-            GROW;\n+                }\n+                count++;\n+                if (count > 50) {\n+                    SHRINK;\n+                    GROW;\n@@ -5240,1 +5242,1 @@\n-            count = 0;\n+                    count = 0;\n@@ -5249,10 +5251,10 @@\n-        }\n-        COPY_BUF(l,buf,len,cur);\n-        NEXTL(l);\n-        cur = CUR_CHAR(l);\n-        if (cur == 0) {\n-            SHRINK;\n-            GROW;\n-            cur = CUR_CHAR(l);\n-        }\n-        }\n+                }\n+                COPY_BUF(l,buf,len,cur);\n+                NEXTL(l);\n+                cur = CUR_CHAR(l);\n+                if (cur == 0) {\n+                    SHRINK;\n+                    GROW;\n+                    cur = CUR_CHAR(l);\n+                }\n+            }\n@@ -5267,8 +5269,8 @@\n-        buf[len] = 0;\n-        if (cur != '?') {\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,\n-              \"ParsePI: PI %s never end ...\\n\", target);\n-        } else {\n-        if (inputid != ctxt->input->id) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n-                               \"PI declaration doesn't start and stop in\"\n+            buf[len] = 0;\n+            if (cur != '?') {\n+                xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,\n+                      \"ParsePI: PI %s never end ...\\n\", target);\n+            } else {\n+                if (inputid != ctxt->input->id) {\n+                    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+                                   \"PI declaration doesn't start and stop in\"\n@@ -5276,2 +5278,2 @@\n-        }\n-        SKIP(2);\n+                }\n+                SKIP(2);\n@@ -5280,8 +5282,8 @@\n-        if (((state == XML_PARSER_MISC) ||\n-                 (state == XML_PARSER_START)) &&\n-            (xmlStrEqual(target, XML_CATALOG_PI))) {\n-            xmlCatalogAllow allow = xmlCatalogGetDefaults();\n-            if ((allow == XML_CATA_ALLOW_DOCUMENT) ||\n-            (allow == XML_CATA_ALLOW_ALL))\n-            xmlParseCatalogPI(ctxt, buf);\n-        }\n+                if (((state == XML_PARSER_MISC) ||\n+                     (state == XML_PARSER_START)) &&\n+                    (xmlStrEqual(target, XML_CATALOG_PI))) {\n+                    xmlCatalogAllow allow = xmlCatalogGetDefaults();\n+                    if ((allow == XML_CATA_ALLOW_DOCUMENT) ||\n+                        (allow == XML_CATA_ALLOW_ALL))\n+                        xmlParseCatalogPI(ctxt, buf);\n+                }\n@@ -5291,7 +5293,11 @@\n-        \/*\n-         * SAX: PI detected.\n-         *\/\n-        if ((ctxt->sax) && (!ctxt->disableSAX) &&\n-            (ctxt->sax->processingInstruction != NULL))\n-            ctxt->sax->processingInstruction(ctxt->userData,\n-                                             target, buf);\n+                \/*\n+                 * SAX: PI detected.\n+                 *\/\n+                if ((ctxt->sax) && (!ctxt->disableSAX) &&\n+                    (ctxt->sax->processingInstruction != NULL))\n+                    ctxt->sax->processingInstruction(ctxt->userData,\n+                                                     target, buf);\n+            }\n+            xmlFree(buf);\n+        } else {\n+            xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);\n@@ -5299,6 +5305,2 @@\n-        xmlFree(buf);\n-    } else {\n-        xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);\n-    }\n-    if (ctxt->instate != XML_PARSER_EOF)\n-        ctxt->instate = state;\n+        if (ctxt->instate != XML_PARSER_EOF)\n+            ctxt->instate = state;\n@@ -5331,8 +5333,8 @@\n-    int inputid = ctxt->input->id;\n-    SHRINK;\n-    SKIP(10);\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"Space required after '<!NOTATION'\\n\");\n-        return;\n-    }\n+        int inputid = ctxt->input->id;\n+        SHRINK;\n+        SKIP(10);\n+        if (SKIP_BLANKS == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space required after '<!NOTATION'\\n\");\n+            return;\n+        }\n@@ -5341,14 +5343,14 @@\n-    if (name == NULL) {\n-        xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);\n-        return;\n-    }\n-    if (xmlStrchr(name, ':') != NULL) {\n-        xmlNsErr(ctxt, XML_NS_ERR_COLON,\n-             \"colons are forbidden from notation names '%s'\\n\",\n-             name, NULL, NULL);\n-    }\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-             \"Space required after the NOTATION name'\\n\");\n-        return;\n-    }\n+        if (name == NULL) {\n+            xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);\n+            return;\n+        }\n+        if (xmlStrchr(name, ':') != NULL) {\n+            xmlNsErr(ctxt, XML_NS_ERR_COLON,\n+                     \"colons are forbidden from notation names '%s'\\n\",\n+                     name, NULL, NULL);\n+        }\n+        if (SKIP_BLANKS == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                     \"Space required after the NOTATION name'\\n\");\n+            return;\n+        }\n@@ -5356,5 +5358,5 @@\n-    \/*\n-     * Parse the IDs.\n-     *\/\n-    Systemid = xmlParseExternalID(ctxt, &Pubid, 0);\n-    SKIP_BLANKS;\n+        \/*\n+         * Parse the IDs.\n+         *\/\n+        Systemid = xmlParseExternalID(ctxt, &Pubid, 0);\n+        SKIP_BLANKS;\n@@ -5362,4 +5364,4 @@\n-    if (RAW == '>') {\n-        if (inputid != ctxt->input->id) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n-                           \"Notation declaration doesn't start and stop\"\n+        if (RAW == '>') {\n+            if (inputid != ctxt->input->id) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+                               \"Notation declaration doesn't start and stop\"\n@@ -5367,0 +5369,7 @@\n+            }\n+            NEXT;\n+            if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n+                (ctxt->sax->notationDecl != NULL))\n+                ctxt->sax->notationDecl(ctxt->userData, name, Pubid, Systemid);\n+        } else {\n+            xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);\n@@ -5368,9 +5377,2 @@\n-        NEXT;\n-        if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n-        (ctxt->sax->notationDecl != NULL))\n-        ctxt->sax->notationDecl(ctxt->userData, name, Pubid, Systemid);\n-    } else {\n-        xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);\n-    }\n-    if (Systemid != NULL) xmlFree(Systemid);\n-    if (Pubid != NULL) xmlFree(Pubid);\n+        if (Systemid != NULL) xmlFree(Systemid);\n+        if (Pubid != NULL) xmlFree(Pubid);\n@@ -5413,10 +5415,3 @@\n-    int inputid = ctxt->input->id;\n-    SHRINK;\n-    SKIP(8);\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"Space required after '<!ENTITY'\\n\");\n-    }\n-\n-    if (RAW == '%') {\n-        NEXT;\n+        int inputid = ctxt->input->id;\n+        SHRINK;\n+        SKIP(8);\n@@ -5424,2 +5419,11 @@\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                   \"Space required after '%%'\\n\");\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space required after '<!ENTITY'\\n\");\n+        }\n+\n+        if (RAW == '%') {\n+            NEXT;\n+            if (SKIP_BLANKS == 0) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                               \"Space required after '%%'\\n\");\n+            }\n+            isParameter = 1;\n@@ -5427,2 +5431,0 @@\n-        isParameter = 1;\n-    }\n@@ -5431,3 +5433,3 @@\n-    if (name == NULL) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-                       \"xmlParseEntityDecl: no name\\n\");\n+        if (name == NULL) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                           \"xmlParseEntityDecl: no name\\n\");\n@@ -5435,29 +5437,0 @@\n-    }\n-    if (xmlStrchr(name, ':') != NULL) {\n-        xmlNsErr(ctxt, XML_NS_ERR_COLON,\n-             \"colons are forbidden from entities names '%s'\\n\",\n-             name, NULL, NULL);\n-    }\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"Space required after the entity name\\n\");\n-    }\n-\n-    ctxt->instate = XML_PARSER_ENTITY_DECL;\n-    \/*\n-     * handle the various case of definitions...\n-     *\/\n-    if (isParameter) {\n-        if ((RAW == '\"') || (RAW == '\\'')) {\n-            value = xmlParseEntityValue(ctxt, &orig);\n-        if (value) {\n-            if ((ctxt->sax != NULL) &&\n-            (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))\n-            ctxt->sax->entityDecl(ctxt->userData, name,\n-                            XML_INTERNAL_PARAMETER_ENTITY,\n-                    NULL, NULL, value);\n-        }\n-        } else {\n-            URI = xmlParseExternalID(ctxt, &literal, 1);\n-        if ((URI == NULL) && (literal == NULL)) {\n-            xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);\n@@ -5465,29 +5438,4 @@\n-        if (URI) {\n-            xmlURIPtr uri;\n-\n-            uri = xmlParseURI((const char *) URI);\n-            if (uri == NULL) {\n-                xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,\n-                     \"Invalid URI: %s\\n\", URI);\n-            \/*\n-             * This really ought to be a well formedness error\n-             * but the XML Core WG decided otherwise c.f. issue\n-             * E26 of the XML erratas.\n-             *\/\n-            } else {\n-            if (uri->fragment != NULL) {\n-                \/*\n-                 * Okay this is foolish to block those but not\n-                 * invalid URIs.\n-                 *\/\n-                xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);\n-            } else {\n-                if ((ctxt->sax != NULL) &&\n-                (!ctxt->disableSAX) &&\n-                (ctxt->sax->entityDecl != NULL))\n-                ctxt->sax->entityDecl(ctxt->userData, name,\n-                        XML_EXTERNAL_PARAMETER_ENTITY,\n-                        literal, URI, NULL);\n-            }\n-            xmlFreeURI(uri);\n-            }\n+        if (xmlStrchr(name, ':') != NULL) {\n+            xmlNsErr(ctxt, XML_NS_ERR_COLON,\n+                     \"colons are forbidden from entities names '%s'\\n\",\n+                     name, NULL, NULL);\n@@ -5495,0 +5443,3 @@\n+        if (SKIP_BLANKS == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space required after the entity name\\n\");\n@@ -5496,8 +5447,2 @@\n-    } else {\n-        if ((RAW == '\"') || (RAW == '\\'')) {\n-            value = xmlParseEntityValue(ctxt, &orig);\n-        if ((ctxt->sax != NULL) &&\n-            (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))\n-            ctxt->sax->entityDecl(ctxt->userData, name,\n-                XML_INTERNAL_GENERAL_ENTITY,\n-                NULL, NULL, value);\n+\n+        ctxt->instate = XML_PARSER_ENTITY_DECL;\n@@ -5505,1 +5450,1 @@\n-         * For expat compatibility in SAX mode.\n+         * handle the various case of definitions...\n@@ -5507,9 +5452,45 @@\n-        if ((ctxt->myDoc == NULL) ||\n-            (xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {\n-            if (ctxt->myDoc == NULL) {\n-            ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);\n-            if (ctxt->myDoc == NULL) {\n-                xmlErrMemory(ctxt, \"New Doc failed\");\n-                return;\n-            }\n-            ctxt->myDoc->properties = XML_DOC_INTERNAL;\n+        if (isParameter) {\n+            if ((RAW == '\"') || (RAW == '\\'')) {\n+                value = xmlParseEntityValue(ctxt, &orig);\n+                if (value) {\n+                    if ((ctxt->sax != NULL) &&\n+                        (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))\n+                        ctxt->sax->entityDecl(ctxt->userData, name,\n+                                    XML_INTERNAL_PARAMETER_ENTITY,\n+                                    NULL, NULL, value);\n+                }\n+            } else {\n+                URI = xmlParseExternalID(ctxt, &literal, 1);\n+                if ((URI == NULL) && (literal == NULL)) {\n+                    xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);\n+                }\n+                if (URI) {\n+                    xmlURIPtr uri;\n+\n+                    uri = xmlParseURI((const char *) URI);\n+                    if (uri == NULL) {\n+                        xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,\n+                                     \"Invalid URI: %s\\n\", URI);\n+                        \/*\n+                         * This really ought to be a well formedness error\n+                         * but the XML Core WG decided otherwise c.f. issue\n+                         * E26 of the XML erratas.\n+                         *\/\n+                    } else {\n+                        if (uri->fragment != NULL) {\n+                            \/*\n+                             * Okay this is foolish to block those but not\n+                             * invalid URIs.\n+                             *\/\n+                            xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);\n+                        } else {\n+                            if ((ctxt->sax != NULL) &&\n+                                (!ctxt->disableSAX) &&\n+                                (ctxt->sax->entityDecl != NULL))\n+                                ctxt->sax->entityDecl(ctxt->userData, name,\n+                                            XML_EXTERNAL_PARAMETER_ENTITY,\n+                                            literal, URI, NULL);\n+                        }\n+                        xmlFreeURI(uri);\n+                    }\n+                }\n@@ -5517,7 +5498,0 @@\n-            if (ctxt->myDoc->intSubset == NULL)\n-            ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,\n-                        BAD_CAST \"fake\", NULL, NULL);\n-\n-            xmlSAX2EntityDecl(ctxt, name, XML_INTERNAL_GENERAL_ENTITY,\n-                          NULL, NULL, value);\n-        }\n@@ -5525,18 +5499,7 @@\n-            URI = xmlParseExternalID(ctxt, &literal, 1);\n-        if ((URI == NULL) && (literal == NULL)) {\n-            xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);\n-        }\n-        if (URI) {\n-            xmlURIPtr uri;\n-\n-            uri = xmlParseURI((const char *)URI);\n-            if (uri == NULL) {\n-                xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,\n-                     \"Invalid URI: %s\\n\", URI);\n-            \/*\n-             * This really ought to be a well formedness error\n-             * but the XML Core WG decided otherwise c.f. issue\n-             * E26 of the XML erratas.\n-             *\/\n-            } else {\n-            if (uri->fragment != NULL) {\n+            if ((RAW == '\"') || (RAW == '\\'')) {\n+                value = xmlParseEntityValue(ctxt, &orig);\n+                if ((ctxt->sax != NULL) &&\n+                    (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))\n+                    ctxt->sax->entityDecl(ctxt->userData, name,\n+                                XML_INTERNAL_GENERAL_ENTITY,\n+                                NULL, NULL, value);\n@@ -5544,2 +5507,1 @@\n-                 * Okay this is foolish to block those but not\n-                 * invalid URIs.\n+                 * For expat compatibility in SAX mode.\n@@ -5547,38 +5509,16 @@\n-                xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);\n-            }\n-            xmlFreeURI(uri);\n-            }\n-        }\n-        if ((RAW != '>') && (SKIP_BLANKS == 0)) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                   \"Space required before 'NDATA'\\n\");\n-        }\n-        if (CMP5(CUR_PTR, 'N', 'D', 'A', 'T', 'A')) {\n-            SKIP(5);\n-            if (SKIP_BLANKS == 0) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                       \"Space required after 'NDATA'\\n\");\n-            }\n-            ndata = xmlParseName(ctxt);\n-            if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n-                (ctxt->sax->unparsedEntityDecl != NULL))\n-            ctxt->sax->unparsedEntityDecl(ctxt->userData, name,\n-                    literal, URI, ndata);\n-        } else {\n-            if ((ctxt->sax != NULL) &&\n-                (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))\n-            ctxt->sax->entityDecl(ctxt->userData, name,\n-                    XML_EXTERNAL_GENERAL_PARSED_ENTITY,\n-                    literal, URI, NULL);\n-            \/*\n-             * For expat compatibility in SAX mode.\n-             * assuming the entity replacement was asked for\n-             *\/\n-            if ((ctxt->replaceEntities != 0) &&\n-            ((ctxt->myDoc == NULL) ||\n-            (xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE)))) {\n-            if (ctxt->myDoc == NULL) {\n-                ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);\n-                if (ctxt->myDoc == NULL) {\n-                    xmlErrMemory(ctxt, \"New Doc failed\");\n-                return;\n+                if ((ctxt->myDoc == NULL) ||\n+                    (xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {\n+                    if (ctxt->myDoc == NULL) {\n+                        ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);\n+                        if (ctxt->myDoc == NULL) {\n+                            xmlErrMemory(ctxt, \"New Doc failed\");\n+                            return;\n+                        }\n+                        ctxt->myDoc->properties = XML_DOC_INTERNAL;\n+                    }\n+                    if (ctxt->myDoc->intSubset == NULL)\n+                        ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,\n+                                            BAD_CAST \"fake\", NULL, NULL);\n+\n+                    xmlSAX2EntityDecl(ctxt, name, XML_INTERNAL_GENERAL_ENTITY,\n+                                      NULL, NULL, value);\n@@ -5586,2 +5526,64 @@\n-                ctxt->myDoc->properties = XML_DOC_INTERNAL;\n-            }\n+            } else {\n+                URI = xmlParseExternalID(ctxt, &literal, 1);\n+                if ((URI == NULL) && (literal == NULL)) {\n+                    xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);\n+                }\n+                if (URI) {\n+                    xmlURIPtr uri;\n+\n+                    uri = xmlParseURI((const char *)URI);\n+                    if (uri == NULL) {\n+                        xmlErrMsgStr(ctxt, XML_ERR_INVALID_URI,\n+                                     \"Invalid URI: %s\\n\", URI);\n+                        \/*\n+                         * This really ought to be a well formedness error\n+                         * but the XML Core WG decided otherwise c.f. issue\n+                         * E26 of the XML erratas.\n+                         *\/\n+                    } else {\n+                        if (uri->fragment != NULL) {\n+                            \/*\n+                             * Okay this is foolish to block those but not\n+                             * invalid URIs.\n+                             *\/\n+                            xmlFatalErr(ctxt, XML_ERR_URI_FRAGMENT, NULL);\n+                        }\n+                        xmlFreeURI(uri);\n+                    }\n+                }\n+                if ((RAW != '>') && (SKIP_BLANKS == 0)) {\n+                    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                                   \"Space required before 'NDATA'\\n\");\n+                }\n+                if (CMP5(CUR_PTR, 'N', 'D', 'A', 'T', 'A')) {\n+                    SKIP(5);\n+                    if (SKIP_BLANKS == 0) {\n+                        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                                       \"Space required after 'NDATA'\\n\");\n+                    }\n+                    ndata = xmlParseName(ctxt);\n+                    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n+                        (ctxt->sax->unparsedEntityDecl != NULL))\n+                        ctxt->sax->unparsedEntityDecl(ctxt->userData, name,\n+                                    literal, URI, ndata);\n+                } else {\n+                    if ((ctxt->sax != NULL) &&\n+                        (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))\n+                        ctxt->sax->entityDecl(ctxt->userData, name,\n+                                    XML_EXTERNAL_GENERAL_PARSED_ENTITY,\n+                                    literal, URI, NULL);\n+                    \/*\n+                     * For expat compatibility in SAX mode.\n+                     * assuming the entity replacement was asked for\n+                     *\/\n+                    if ((ctxt->replaceEntities != 0) &&\n+                        ((ctxt->myDoc == NULL) ||\n+                        (xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE)))) {\n+                        if (ctxt->myDoc == NULL) {\n+                            ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);\n+                            if (ctxt->myDoc == NULL) {\n+                                xmlErrMemory(ctxt, \"New Doc failed\");\n+                                return;\n+                            }\n+                            ctxt->myDoc->properties = XML_DOC_INTERNAL;\n+                        }\n@@ -5589,6 +5591,8 @@\n-            if (ctxt->myDoc->intSubset == NULL)\n-                ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,\n-                        BAD_CAST \"fake\", NULL, NULL);\n-            xmlSAX2EntityDecl(ctxt, name,\n-                          XML_EXTERNAL_GENERAL_PARSED_ENTITY,\n-                          literal, URI, NULL);\n+                        if (ctxt->myDoc->intSubset == NULL)\n+                            ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,\n+                                                BAD_CAST \"fake\", NULL, NULL);\n+                        xmlSAX2EntityDecl(ctxt, name,\n+                                          XML_EXTERNAL_GENERAL_PARSED_ENTITY,\n+                                          literal, URI, NULL);\n+                    }\n+                }\n@@ -5597,13 +5601,11 @@\n-        }\n-    }\n-    if (ctxt->instate == XML_PARSER_EOF)\n-        goto done;\n-    SKIP_BLANKS;\n-    if (RAW != '>') {\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,\n-                \"xmlParseEntityDecl: entity %s not terminated\\n\", name);\n-        xmlHaltParser(ctxt);\n-    } else {\n-        if (inputid != ctxt->input->id) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n-                           \"Entity declaration doesn't start and stop in\"\n+        if (ctxt->instate == XML_PARSER_EOF)\n+            goto done;\n+        SKIP_BLANKS;\n+        if (RAW != '>') {\n+            xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,\n+                    \"xmlParseEntityDecl: entity %s not terminated\\n\", name);\n+            xmlHaltParser(ctxt);\n+        } else {\n+            if (inputid != ctxt->input->id) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+                               \"Entity declaration doesn't start and stop in\"\n@@ -5611,0 +5613,2 @@\n+            }\n+            NEXT;\n@@ -5612,7 +5616,5 @@\n-        NEXT;\n-    }\n-    if (orig != NULL) {\n-        \/*\n-         * Ugly mechanism to save the raw entity value.\n-         *\/\n-        xmlEntityPtr cur = NULL;\n+        if (orig != NULL) {\n+            \/*\n+             * Ugly mechanism to save the raw entity value.\n+             *\/\n+            xmlEntityPtr cur = NULL;\n@@ -5620,12 +5622,12 @@\n-        if (isParameter) {\n-            if ((ctxt->sax != NULL) &&\n-            (ctxt->sax->getParameterEntity != NULL))\n-            cur = ctxt->sax->getParameterEntity(ctxt->userData, name);\n-        } else {\n-            if ((ctxt->sax != NULL) &&\n-            (ctxt->sax->getEntity != NULL))\n-            cur = ctxt->sax->getEntity(ctxt->userData, name);\n-        if ((cur == NULL) && (ctxt->userData==ctxt)) {\n-            cur = xmlSAX2GetEntity(ctxt, name);\n-        }\n-        }\n+            if (isParameter) {\n+                if ((ctxt->sax != NULL) &&\n+                    (ctxt->sax->getParameterEntity != NULL))\n+                    cur = ctxt->sax->getParameterEntity(ctxt->userData, name);\n+            } else {\n+                if ((ctxt->sax != NULL) &&\n+                    (ctxt->sax->getEntity != NULL))\n+                    cur = ctxt->sax->getEntity(ctxt->userData, name);\n+                if ((cur == NULL) && (ctxt->userData==ctxt)) {\n+                    cur = xmlSAX2GetEntity(ctxt, name);\n+                }\n+            }\n@@ -5633,1 +5635,1 @@\n-        cur->orig = orig;\n+                cur->orig = orig;\n@@ -5635,0 +5637,1 @@\n+            }\n@@ -5636,1 +5639,0 @@\n-    }\n@@ -5639,3 +5641,3 @@\n-    if (value != NULL) xmlFree(value);\n-    if (URI != NULL) xmlFree(URI);\n-    if (literal != NULL) xmlFree(literal);\n+        if (value != NULL) xmlFree(value);\n+        if (URI != NULL) xmlFree(URI);\n+        if (literal != NULL) xmlFree(literal);\n@@ -5682,2 +5684,2 @@\n-    SKIP(9);\n-    return(XML_ATTRIBUTE_REQUIRED);\n+        SKIP(9);\n+        return(XML_ATTRIBUTE_REQUIRED);\n@@ -5686,2 +5688,2 @@\n-    SKIP(8);\n-    return(XML_ATTRIBUTE_IMPLIED);\n+        SKIP(8);\n+        return(XML_ATTRIBUTE_IMPLIED);\n@@ -5691,6 +5693,6 @@\n-    SKIP(6);\n-    val = XML_ATTRIBUTE_FIXED;\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"Space required after '#FIXED'\\n\");\n-    }\n+        SKIP(6);\n+        val = XML_ATTRIBUTE_FIXED;\n+        if (SKIP_BLANKS == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space required after '#FIXED'\\n\");\n+        }\n@@ -5701,2 +5703,2 @@\n-    xmlFatalErrMsg(ctxt, (xmlParserErrors)ctxt->errNo,\n-               \"Attribute default value declaration error\\n\");\n+        xmlFatalErrMsg(ctxt, (xmlParserErrors)ctxt->errNo,\n+                       \"Attribute default value declaration error\\n\");\n@@ -5731,2 +5733,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);\n-    return(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);\n+        return(NULL);\n@@ -5737,1 +5739,1 @@\n-    SKIP_BLANKS;\n+        SKIP_BLANKS;\n@@ -5739,3 +5741,3 @@\n-    if (name == NULL) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-               \"Name expected in NOTATION declaration\\n\");\n+        if (name == NULL) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                           \"Name expected in NOTATION declaration\\n\");\n@@ -5743,11 +5745,1 @@\n-        return(NULL);\n-    }\n-    tmp = ret;\n-    while (tmp != NULL) {\n-        if (xmlStrEqual(name, tmp->name)) {\n-        xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,\n-      \"standalone: attribute notation value token %s duplicated\\n\",\n-                 name, NULL);\n-        if (!xmlDictOwns(ctxt->dict, name))\n-            xmlFree((xmlChar *) name);\n-        break;\n+            return(NULL);\n@@ -5755,5 +5747,15 @@\n-        tmp = tmp->next;\n-    }\n-    if (tmp == NULL) {\n-        cur = xmlCreateEnumeration(name);\n-        if (cur == NULL) {\n+        tmp = ret;\n+        while (tmp != NULL) {\n+            if (xmlStrEqual(name, tmp->name)) {\n+                xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,\n+          \"standalone: attribute notation value token %s duplicated\\n\",\n+                                 name, NULL);\n+                if (!xmlDictOwns(ctxt->dict, name))\n+                    xmlFree((xmlChar *) name);\n+                break;\n+            }\n+            tmp = tmp->next;\n+        }\n+        if (tmp == NULL) {\n+            cur = xmlCreateEnumeration(name);\n+            if (cur == NULL) {\n@@ -5763,4 +5765,5 @@\n-        if (last == NULL) ret = last = cur;\n-        else {\n-        last->next = cur;\n-        last = cur;\n+            if (last == NULL) ret = last = cur;\n+            else {\n+                last->next = cur;\n+                last = cur;\n+            }\n@@ -5768,2 +5771,1 @@\n-    }\n-    SKIP_BLANKS;\n+        SKIP_BLANKS;\n@@ -5772,1 +5774,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);\n@@ -5774,1 +5776,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5801,2 +5803,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_STARTED, NULL);\n-    return(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_STARTED, NULL);\n+        return(NULL);\n@@ -5807,1 +5809,1 @@\n-    SKIP_BLANKS;\n+        SKIP_BLANKS;\n@@ -5809,13 +5811,3 @@\n-    if (name == NULL) {\n-        xmlFatalErr(ctxt, XML_ERR_NMTOKEN_REQUIRED, NULL);\n-        return(ret);\n-    }\n-    tmp = ret;\n-    while (tmp != NULL) {\n-        if (xmlStrEqual(name, tmp->name)) {\n-        xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,\n-      \"standalone: attribute enumeration value token %s duplicated\\n\",\n-                 name, NULL);\n-        if (!xmlDictOwns(ctxt->dict, name))\n-            xmlFree(name);\n-        break;\n+        if (name == NULL) {\n+            xmlFatalErr(ctxt, XML_ERR_NMTOKEN_REQUIRED, NULL);\n+            return(ret);\n@@ -5823,7 +5815,17 @@\n-        tmp = tmp->next;\n-    }\n-    if (tmp == NULL) {\n-        cur = xmlCreateEnumeration(name);\n-        if (!xmlDictOwns(ctxt->dict, name))\n-        xmlFree(name);\n-        if (cur == NULL) {\n+        tmp = ret;\n+        while (tmp != NULL) {\n+            if (xmlStrEqual(name, tmp->name)) {\n+                xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,\n+          \"standalone: attribute enumeration value token %s duplicated\\n\",\n+                                 name, NULL);\n+                if (!xmlDictOwns(ctxt->dict, name))\n+                    xmlFree(name);\n+                break;\n+            }\n+            tmp = tmp->next;\n+        }\n+        if (tmp == NULL) {\n+            cur = xmlCreateEnumeration(name);\n+            if (!xmlDictOwns(ctxt->dict, name))\n+                xmlFree(name);\n+            if (cur == NULL) {\n@@ -5833,4 +5835,5 @@\n-        if (last == NULL) ret = last = cur;\n-        else {\n-        last->next = cur;\n-        last = cur;\n+            if (last == NULL) ret = last = cur;\n+            else {\n+                last->next = cur;\n+                last = cur;\n+            }\n@@ -5838,2 +5841,1 @@\n-    }\n-    SKIP_BLANKS;\n+        SKIP_BLANKS;\n@@ -5842,2 +5844,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_FINISHED, NULL);\n-    return(ret);\n+        xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_FINISHED, NULL);\n+        return(ret);\n@@ -5867,9 +5869,9 @@\n-    SKIP(8);\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"Space required after 'NOTATION'\\n\");\n-        return(0);\n-    }\n-    *tree = xmlParseNotationType(ctxt);\n-    if (*tree == NULL) return(0);\n-    return(XML_ATTRIBUTE_NOTATION);\n+        SKIP(8);\n+        if (SKIP_BLANKS == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space required after 'NOTATION'\\n\");\n+            return(0);\n+        }\n+        *tree = xmlParseNotationType(ctxt);\n+        if (*tree == NULL) return(0);\n+        return(XML_ATTRIBUTE_NOTATION);\n@@ -5931,2 +5933,2 @@\n-    SKIP(5);\n-    return(XML_ATTRIBUTE_CDATA);\n+        SKIP(5);\n+        return(XML_ATTRIBUTE_CDATA);\n@@ -5934,2 +5936,2 @@\n-    SKIP(6);\n-    return(XML_ATTRIBUTE_IDREFS);\n+        SKIP(6);\n+        return(XML_ATTRIBUTE_IDREFS);\n@@ -5937,2 +5939,2 @@\n-    SKIP(5);\n-    return(XML_ATTRIBUTE_IDREF);\n+        SKIP(5);\n+        return(XML_ATTRIBUTE_IDREF);\n@@ -5941,1 +5943,1 @@\n-    return(XML_ATTRIBUTE_ID);\n+        return(XML_ATTRIBUTE_ID);\n@@ -5943,2 +5945,2 @@\n-    SKIP(6);\n-    return(XML_ATTRIBUTE_ENTITY);\n+        SKIP(6);\n+        return(XML_ATTRIBUTE_ENTITY);\n@@ -5946,2 +5948,2 @@\n-    SKIP(8);\n-    return(XML_ATTRIBUTE_ENTITIES);\n+        SKIP(8);\n+        return(XML_ATTRIBUTE_ENTITIES);\n@@ -5949,2 +5951,2 @@\n-    SKIP(8);\n-    return(XML_ATTRIBUTE_NMTOKENS);\n+        SKIP(8);\n+        return(XML_ATTRIBUTE_NMTOKENS);\n@@ -5952,2 +5954,2 @@\n-    SKIP(7);\n-    return(XML_ATTRIBUTE_NMTOKEN);\n+        SKIP(7);\n+        return(XML_ATTRIBUTE_NMTOKEN);\n@@ -5976,1 +5978,1 @@\n-    int inputid = ctxt->input->id;\n+        int inputid = ctxt->input->id;\n@@ -5978,5 +5980,5 @@\n-    SKIP(9);\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                         \"Space required after '<!ATTLIST'\\n\");\n-    }\n+        SKIP(9);\n+        if (SKIP_BLANKS == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                                 \"Space required after '<!ATTLIST'\\n\");\n+        }\n@@ -5984,19 +5986,4 @@\n-    if (elemName == NULL) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-               \"ATTLIST: no name for Element\\n\");\n-        return;\n-    }\n-    SKIP_BLANKS;\n-    GROW;\n-    while ((RAW != '>') && (ctxt->instate != XML_PARSER_EOF)) {\n-        int type;\n-        int def;\n-        xmlChar *defaultValue = NULL;\n-\n-        GROW;\n-            tree = NULL;\n-        attrName = xmlParseName(ctxt);\n-        if (attrName == NULL) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-                   \"ATTLIST: no name for Attribute\\n\");\n-        break;\n+        if (elemName == NULL) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                           \"ATTLIST: no name for Element\\n\");\n+            return;\n@@ -6004,0 +5991,1 @@\n+        SKIP_BLANKS;\n@@ -6005,5 +5993,4 @@\n-        if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                \"Space required after the attribute name\\n\");\n-        break;\n-        }\n+        while ((RAW != '>') && (ctxt->instate != XML_PARSER_EOF)) {\n+            int type;\n+            int def;\n+            xmlChar *defaultValue = NULL;\n@@ -6011,4 +5998,14 @@\n-        type = xmlParseAttributeType(ctxt, &tree);\n-        if (type <= 0) {\n-            break;\n-        }\n+            GROW;\n+            tree = NULL;\n+            attrName = xmlParseName(ctxt);\n+            if (attrName == NULL) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                               \"ATTLIST: no name for Attribute\\n\");\n+                break;\n+            }\n+            GROW;\n+            if (SKIP_BLANKS == 0) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                        \"Space required after the attribute name\\n\");\n+                break;\n+            }\n@@ -6016,8 +6013,13 @@\n-        GROW;\n-        if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                   \"Space required after the attribute type\\n\");\n-            if (tree != NULL)\n-            xmlFreeEnumeration(tree);\n-        break;\n-        }\n+            type = xmlParseAttributeType(ctxt, &tree);\n+            if (type <= 0) {\n+                break;\n+            }\n+\n+            GROW;\n+            if (SKIP_BLANKS == 0) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                               \"Space required after the attribute type\\n\");\n+                if (tree != NULL)\n+                    xmlFreeEnumeration(tree);\n+                break;\n+            }\n@@ -6025,2 +6027,2 @@\n-        def = xmlParseDefaultDecl(ctxt, &defaultValue);\n-        if (def <= 0) {\n+            def = xmlParseDefaultDecl(ctxt, &defaultValue);\n+            if (def <= 0) {\n@@ -6028,7 +6030,7 @@\n-            xmlFree(defaultValue);\n-            if (tree != NULL)\n-            xmlFreeEnumeration(tree);\n-            break;\n-        }\n-        if ((type != XML_ATTRIBUTE_CDATA) && (defaultValue != NULL))\n-            xmlAttrNormalizeSpace(defaultValue, defaultValue);\n+                    xmlFree(defaultValue);\n+                if (tree != NULL)\n+                    xmlFreeEnumeration(tree);\n+                break;\n+            }\n+            if ((type != XML_ATTRIBUTE_CDATA) && (defaultValue != NULL))\n+                xmlAttrNormalizeSpace(defaultValue, defaultValue);\n@@ -6036,1 +6038,1 @@\n-        GROW;\n+            GROW;\n@@ -6038,3 +6040,25 @@\n-        if (SKIP_BLANKS == 0) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-            \"Space required after the attribute default value\\n\");\n+                if (SKIP_BLANKS == 0) {\n+                    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                        \"Space required after the attribute default value\\n\");\n+                    if (defaultValue != NULL)\n+                        xmlFree(defaultValue);\n+                    if (tree != NULL)\n+                        xmlFreeEnumeration(tree);\n+                    break;\n+                }\n+            }\n+            if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n+                (ctxt->sax->attributeDecl != NULL))\n+                ctxt->sax->attributeDecl(ctxt->userData, elemName, attrName,\n+                                type, def, defaultValue, tree);\n+            else if (tree != NULL)\n+                xmlFreeEnumeration(tree);\n+\n+            if ((ctxt->sax2) && (defaultValue != NULL) &&\n+                (def != XML_ATTRIBUTE_IMPLIED) &&\n+                (def != XML_ATTRIBUTE_REQUIRED)) {\n+                xmlAddDefAttrs(ctxt, elemName, attrName, defaultValue);\n+            }\n+            if (ctxt->sax2) {\n+                xmlAddSpecialAttr(ctxt, elemName, attrName, type);\n+            }\n@@ -6042,4 +6066,2 @@\n-            xmlFree(defaultValue);\n-            if (tree != NULL)\n-            xmlFreeEnumeration(tree);\n-            break;\n+                xmlFree(defaultValue);\n+            GROW;\n@@ -6047,0 +6069,7 @@\n+        if (RAW == '>') {\n+            if (inputid != ctxt->input->id) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+                               \"Attribute list declaration doesn't start and\"\n+                               \" stop in the same entity\\n\");\n+            }\n+            NEXT;\n@@ -6048,27 +6077,0 @@\n-        if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n-        (ctxt->sax->attributeDecl != NULL))\n-        ctxt->sax->attributeDecl(ctxt->userData, elemName, attrName,\n-                            type, def, defaultValue, tree);\n-        else if (tree != NULL)\n-        xmlFreeEnumeration(tree);\n-\n-        if ((ctxt->sax2) && (defaultValue != NULL) &&\n-            (def != XML_ATTRIBUTE_IMPLIED) &&\n-        (def != XML_ATTRIBUTE_REQUIRED)) {\n-        xmlAddDefAttrs(ctxt, elemName, attrName, defaultValue);\n-        }\n-        if (ctxt->sax2) {\n-        xmlAddSpecialAttr(ctxt, elemName, attrName, type);\n-        }\n-        if (defaultValue != NULL)\n-            xmlFree(defaultValue);\n-        GROW;\n-    }\n-    if (RAW == '>') {\n-        if (inputid != ctxt->input->id) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n-                               \"Attribute list declaration doesn't start and\"\n-                               \" stop in the same entity\\n\");\n-        }\n-        NEXT;\n-    }\n@@ -6104,6 +6106,6 @@\n-    SKIP(7);\n-    SKIP_BLANKS;\n-    SHRINK;\n-    if (RAW == ')') {\n-        if (ctxt->input->id != inputchk) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+        SKIP(7);\n+        SKIP_BLANKS;\n+        SHRINK;\n+        if (RAW == ')') {\n+            if (ctxt->input->id != inputchk) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n@@ -6112,0 +6114,10 @@\n+            }\n+            NEXT;\n+            ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);\n+            if (ret == NULL)\n+                return(NULL);\n+            if (RAW == '*') {\n+                ret->ocur = XML_ELEMENT_CONTENT_MULT;\n+                NEXT;\n+            }\n+            return(ret);\n@@ -6113,7 +6125,3 @@\n-        NEXT;\n-        ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);\n-        if (ret == NULL)\n-            return(NULL);\n-        if (RAW == '*') {\n-        ret->ocur = XML_ELEMENT_CONTENT_MULT;\n-        NEXT;\n+        if ((RAW == '(') || (RAW == '|')) {\n+            ret = cur = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);\n+            if (ret == NULL) return(NULL);\n@@ -6121,12 +6129,6 @@\n-        return(ret);\n-    }\n-    if ((RAW == '(') || (RAW == '|')) {\n-        ret = cur = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);\n-        if (ret == NULL) return(NULL);\n-    }\n-    while ((RAW == '|') && (ctxt->instate != XML_PARSER_EOF)) {\n-        NEXT;\n-        if (elem == NULL) {\n-            ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);\n-        if (ret == NULL) {\n-            xmlFreeDocElementContent(ctxt->myDoc, cur);\n+        while ((RAW == '|') && (ctxt->instate != XML_PARSER_EOF)) {\n+            NEXT;\n+            if (elem == NULL) {\n+                ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);\n+                if (ret == NULL) {\n+                    xmlFreeDocElementContent(ctxt->myDoc, cur);\n@@ -6135,8 +6137,8 @@\n-        ret->c1 = cur;\n-        if (cur != NULL)\n-            cur->parent = ret;\n-        cur = ret;\n-        } else {\n-            n = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);\n-        if (n == NULL) {\n-            xmlFreeDocElementContent(ctxt->myDoc, ret);\n+                ret->c1 = cur;\n+                if (cur != NULL)\n+                    cur->parent = ret;\n+                cur = ret;\n+            } else {\n+                n = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);\n+                if (n == NULL) {\n+                    xmlFreeDocElementContent(ctxt->myDoc, ret);\n@@ -6145,15 +6147,18 @@\n-        n->c1 = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);\n-        if (n->c1 != NULL)\n-            n->c1->parent = n;\n-            cur->c2 = n;\n-        if (n != NULL)\n-            n->parent = cur;\n-        cur = n;\n-        }\n-        SKIP_BLANKS;\n-        elem = xmlParseName(ctxt);\n-        if (elem == NULL) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-            \"xmlParseElementMixedContentDecl : Name expected\\n\");\n-        xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n+                n->c1 = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);\n+                if (n->c1 != NULL)\n+                    n->c1->parent = n;\n+                cur->c2 = n;\n+                if (n != NULL)\n+                    n->parent = cur;\n+                cur = n;\n+            }\n+            SKIP_BLANKS;\n+            elem = xmlParseName(ctxt);\n+            if (elem == NULL) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                        \"xmlParseElementMixedContentDecl : Name expected\\n\");\n+                xmlFreeDocElementContent(ctxt->myDoc, ret);\n+                return(NULL);\n+            }\n+            SKIP_BLANKS;\n+            GROW;\n@@ -6161,9 +6166,6 @@\n-        SKIP_BLANKS;\n-        GROW;\n-    }\n-    if ((RAW == ')') && (NXT(1) == '*')) {\n-        if (elem != NULL) {\n-        cur->c2 = xmlNewDocElementContent(ctxt->myDoc, elem,\n-                                       XML_ELEMENT_CONTENT_ELEMENT);\n-        if (cur->c2 != NULL)\n-            cur->c2->parent = cur;\n+        if ((RAW == ')') && (NXT(1) == '*')) {\n+            if (elem != NULL) {\n+                cur->c2 = xmlNewDocElementContent(ctxt->myDoc, elem,\n+                                               XML_ELEMENT_CONTENT_ELEMENT);\n+                if (cur->c2 != NULL)\n+                    cur->c2->parent = cur;\n@@ -6173,2 +6175,2 @@\n-        if (ctxt->input->id != inputchk) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+            if (ctxt->input->id != inputchk) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n@@ -6177,0 +6179,6 @@\n+            }\n+            SKIP(2);\n+        } else {\n+            xmlFreeDocElementContent(ctxt->myDoc, ret);\n+            xmlFatalErr(ctxt, XML_ERR_MIXED_NOT_STARTED, NULL);\n+            return(NULL);\n@@ -6178,6 +6186,0 @@\n-        SKIP(2);\n-    } else {\n-        xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        xmlFatalErr(ctxt, XML_ERR_MIXED_NOT_STARTED, NULL);\n-        return(NULL);\n-    }\n@@ -6186,1 +6188,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_PCDATA_REQUIRED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_PCDATA_REQUIRED, NULL);\n@@ -6211,8 +6213,8 @@\n- *  with parenthesized groups. That is to say, if either of the\n- *  opening or closing parentheses in a choice, seq, or Mixed\n- *  construct is contained in the replacement text for a parameter\n- *  entity, both must be contained in the same replacement text. For\n- *  interoperability, if a parameter-entity reference appears in a\n- *  choice, seq, or Mixed construct, its replacement text should not\n- *  be empty, and neither the first nor last non-blank character of\n- *  the replacement text should be a connector (| or ,).\n+ *      with parenthesized groups. That is to say, if either of the\n+ *      opening or closing parentheses in a choice, seq, or Mixed\n+ *      construct is contained in the replacement text for a parameter\n+ *      entity, both must be contained in the same replacement text. For\n+ *      interoperability, if a parameter-entity reference appears in a\n+ *      choice, seq, or Mixed construct, its replacement text should not\n+ *      be empty, and neither the first nor last non-blank character of\n+ *      the replacement text should be a connector (| or ,).\n@@ -6235,1 +6237,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6240,1 +6242,1 @@\n-    int inputid = ctxt->input->id;\n+        int inputid = ctxt->input->id;\n@@ -6243,2 +6245,2 @@\n-    NEXT;\n-    SKIP_BLANKS;\n+        NEXT;\n+        SKIP_BLANKS;\n@@ -6249,2 +6251,2 @@\n-    SKIP_BLANKS;\n-    GROW;\n+        SKIP_BLANKS;\n+        GROW;\n@@ -6252,5 +6254,5 @@\n-    elem = xmlParseName(ctxt);\n-    if (elem == NULL) {\n-        xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);\n-        return(NULL);\n-    }\n+        elem = xmlParseName(ctxt);\n+        if (elem == NULL) {\n+            xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);\n+            return(NULL);\n+        }\n@@ -6258,18 +6260,18 @@\n-    if (cur == NULL) {\n-        xmlErrMemory(ctxt, NULL);\n-        return(NULL);\n-    }\n-    GROW;\n-    if (RAW == '?') {\n-        cur->ocur = XML_ELEMENT_CONTENT_OPT;\n-        NEXT;\n-    } else if (RAW == '*') {\n-        cur->ocur = XML_ELEMENT_CONTENT_MULT;\n-        NEXT;\n-    } else if (RAW == '+') {\n-        cur->ocur = XML_ELEMENT_CONTENT_PLUS;\n-        NEXT;\n-    } else {\n-        cur->ocur = XML_ELEMENT_CONTENT_ONCE;\n-    }\n-    GROW;\n+        if (cur == NULL) {\n+            xmlErrMemory(ctxt, NULL);\n+            return(NULL);\n+        }\n+        GROW;\n+        if (RAW == '?') {\n+            cur->ocur = XML_ELEMENT_CONTENT_OPT;\n+            NEXT;\n+        } else if (RAW == '*') {\n+            cur->ocur = XML_ELEMENT_CONTENT_MULT;\n+            NEXT;\n+        } else if (RAW == '+') {\n+            cur->ocur = XML_ELEMENT_CONTENT_PLUS;\n+            NEXT;\n+        } else {\n+            cur->ocur = XML_ELEMENT_CONTENT_ONCE;\n+        }\n+        GROW;\n@@ -6281,2 +6283,2 @@\n-     * Each loop we parse one separator and one element.\n-     *\/\n+         * Each loop we parse one separator and one element.\n+         *\/\n@@ -6284,1 +6286,1 @@\n-        if (type == 0) type = CUR;\n+            if (type == 0) type = CUR;\n@@ -6286,14 +6288,14 @@\n-        \/*\n-         * Detect \"Name | Name , Name\" error\n-         *\/\n-        else if (type != CUR) {\n-        xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,\n-            \"xmlParseElementChildrenContentDecl : '%c' expected\\n\",\n-                          type);\n-        if ((last != NULL) && (last != ret))\n-            xmlFreeDocElementContent(ctxt->myDoc, last);\n-        if (ret != NULL)\n-            xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n-        }\n-        NEXT;\n+            \/*\n+             * Detect \"Name | Name , Name\" error\n+             *\/\n+            else if (type != CUR) {\n+                xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,\n+                    \"xmlParseElementChildrenContentDecl : '%c' expected\\n\",\n+                                  type);\n+                if ((last != NULL) && (last != ret))\n+                    xmlFreeDocElementContent(ctxt->myDoc, last);\n+                if (ret != NULL)\n+                    xmlFreeDocElementContent(ctxt->myDoc, ret);\n+                return(NULL);\n+            }\n+            NEXT;\n@@ -6301,24 +6303,24 @@\n-        op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_SEQ);\n-        if (op == NULL) {\n-        if ((last != NULL) && (last != ret))\n-            xmlFreeDocElementContent(ctxt->myDoc, last);\n-            xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n-        }\n-        if (last == NULL) {\n-        op->c1 = ret;\n-        if (ret != NULL)\n-            ret->parent = op;\n-        ret = cur = op;\n-        } else {\n-            cur->c2 = op;\n-        if (op != NULL)\n-            op->parent = cur;\n-        op->c1 = last;\n-        if (last != NULL)\n-            last->parent = op;\n-        cur =op;\n-        last = NULL;\n-        }\n-    } else if (RAW == '|') {\n-        if (type == 0) type = CUR;\n+            op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_SEQ);\n+            if (op == NULL) {\n+                if ((last != NULL) && (last != ret))\n+                    xmlFreeDocElementContent(ctxt->myDoc, last);\n+                xmlFreeDocElementContent(ctxt->myDoc, ret);\n+                return(NULL);\n+            }\n+            if (last == NULL) {\n+                op->c1 = ret;\n+                if (ret != NULL)\n+                    ret->parent = op;\n+                ret = cur = op;\n+            } else {\n+                cur->c2 = op;\n+                if (op != NULL)\n+                    op->parent = cur;\n+                op->c1 = last;\n+                if (last != NULL)\n+                    last->parent = op;\n+                cur =op;\n+                last = NULL;\n+            }\n+        } else if (RAW == '|') {\n+            if (type == 0) type = CUR;\n@@ -6326,14 +6328,14 @@\n-        \/*\n-         * Detect \"Name , Name | Name\" error\n-         *\/\n-        else if (type != CUR) {\n-        xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,\n-            \"xmlParseElementChildrenContentDecl : '%c' expected\\n\",\n-                  type);\n-        if ((last != NULL) && (last != ret))\n-            xmlFreeDocElementContent(ctxt->myDoc, last);\n-        if (ret != NULL)\n-            xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n-        }\n-        NEXT;\n+            \/*\n+             * Detect \"Name , Name | Name\" error\n+             *\/\n+            else if (type != CUR) {\n+                xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,\n+                    \"xmlParseElementChildrenContentDecl : '%c' expected\\n\",\n+                                  type);\n+                if ((last != NULL) && (last != ret))\n+                    xmlFreeDocElementContent(ctxt->myDoc, last);\n+                if (ret != NULL)\n+                    xmlFreeDocElementContent(ctxt->myDoc, ret);\n+                return(NULL);\n+            }\n+            NEXT;\n@@ -6341,13 +6343,23 @@\n-        op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);\n-        if (op == NULL) {\n-        if ((last != NULL) && (last != ret))\n-            xmlFreeDocElementContent(ctxt->myDoc, last);\n-        if (ret != NULL)\n-            xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n-        }\n-        if (last == NULL) {\n-        op->c1 = ret;\n-        if (ret != NULL)\n-            ret->parent = op;\n-        ret = cur = op;\n+            op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);\n+            if (op == NULL) {\n+                if ((last != NULL) && (last != ret))\n+                    xmlFreeDocElementContent(ctxt->myDoc, last);\n+                if (ret != NULL)\n+                    xmlFreeDocElementContent(ctxt->myDoc, ret);\n+                return(NULL);\n+            }\n+            if (last == NULL) {\n+                op->c1 = ret;\n+                if (ret != NULL)\n+                    ret->parent = op;\n+                ret = cur = op;\n+            } else {\n+                cur->c2 = op;\n+                if (op != NULL)\n+                    op->parent = cur;\n+                op->c1 = last;\n+                if (last != NULL)\n+                    last->parent = op;\n+                cur =op;\n+                last = NULL;\n+            }\n@@ -6355,8 +6367,6 @@\n-            cur->c2 = op;\n-        if (op != NULL)\n-            op->parent = cur;\n-        op->c1 = last;\n-        if (last != NULL)\n-            last->parent = op;\n-        cur =op;\n-        last = NULL;\n+            xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED, NULL);\n+            if ((last != NULL) && (last != ret))\n+                xmlFreeDocElementContent(ctxt->myDoc, last);\n+            if (ret != NULL)\n+                xmlFreeDocElementContent(ctxt->myDoc, ret);\n+            return(NULL);\n@@ -6364,15 +6374,1 @@\n-    } else {\n-        xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED, NULL);\n-        if ((last != NULL) && (last != ret))\n-            xmlFreeDocElementContent(ctxt->myDoc, last);\n-        if (ret != NULL)\n-        xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n-    }\n-    GROW;\n-    SKIP_BLANKS;\n-    GROW;\n-    if (RAW == '(') {\n-        int inputid = ctxt->input->id;\n-        \/* Recurse on second child *\/\n-        NEXT;\n+        GROW;\n@@ -6380,1 +6376,7 @@\n-        last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,\n+        GROW;\n+        if (RAW == '(') {\n+            int inputid = ctxt->input->id;\n+            \/* Recurse on second child *\/\n+            NEXT;\n+            SKIP_BLANKS;\n+            last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,\n@@ -6383,3 +6385,3 @@\n-        if (ret != NULL)\n-            xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n+                if (ret != NULL)\n+                    xmlFreeDocElementContent(ctxt->myDoc, ret);\n+                return(NULL);\n@@ -6387,24 +6389,1 @@\n-        SKIP_BLANKS;\n-    } else {\n-        elem = xmlParseName(ctxt);\n-        if (elem == NULL) {\n-        xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);\n-        if (ret != NULL)\n-            xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n-        }\n-        last = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);\n-        if (last == NULL) {\n-        if (ret != NULL)\n-            xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n-        }\n-        if (RAW == '?') {\n-        last->ocur = XML_ELEMENT_CONTENT_OPT;\n-        NEXT;\n-        } else if (RAW == '*') {\n-        last->ocur = XML_ELEMENT_CONTENT_MULT;\n-        NEXT;\n-        } else if (RAW == '+') {\n-        last->ocur = XML_ELEMENT_CONTENT_PLUS;\n-        NEXT;\n+            SKIP_BLANKS;\n@@ -6412,1 +6391,25 @@\n-        last->ocur = XML_ELEMENT_CONTENT_ONCE;\n+            elem = xmlParseName(ctxt);\n+            if (elem == NULL) {\n+                xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);\n+                if (ret != NULL)\n+                    xmlFreeDocElementContent(ctxt->myDoc, ret);\n+                return(NULL);\n+            }\n+            last = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);\n+            if (last == NULL) {\n+                if (ret != NULL)\n+                    xmlFreeDocElementContent(ctxt->myDoc, ret);\n+                return(NULL);\n+            }\n+            if (RAW == '?') {\n+                last->ocur = XML_ELEMENT_CONTENT_OPT;\n+                NEXT;\n+            } else if (RAW == '*') {\n+                last->ocur = XML_ELEMENT_CONTENT_MULT;\n+                NEXT;\n+            } else if (RAW == '+') {\n+                last->ocur = XML_ELEMENT_CONTENT_PLUS;\n+                NEXT;\n+            } else {\n+                last->ocur = XML_ELEMENT_CONTENT_ONCE;\n+            }\n@@ -6414,3 +6417,2 @@\n-    }\n-    SKIP_BLANKS;\n-    GROW;\n+        SKIP_BLANKS;\n+        GROW;\n@@ -6420,2 +6422,2 @@\n-    if (last != NULL)\n-        last->parent = cur;\n+        if (last != NULL)\n+            last->parent = cur;\n@@ -6424,1 +6426,1 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n@@ -6430,8 +6432,8 @@\n-    if (ret != NULL) {\n-        if ((ret->ocur == XML_ELEMENT_CONTENT_PLUS) ||\n-            (ret->ocur == XML_ELEMENT_CONTENT_MULT))\n-            ret->ocur = XML_ELEMENT_CONTENT_MULT;\n-        else\n-            ret->ocur = XML_ELEMENT_CONTENT_OPT;\n-    }\n-    NEXT;\n+        if (ret != NULL) {\n+            if ((ret->ocur == XML_ELEMENT_CONTENT_PLUS) ||\n+                (ret->ocur == XML_ELEMENT_CONTENT_MULT))\n+                ret->ocur = XML_ELEMENT_CONTENT_MULT;\n+            else\n+                ret->ocur = XML_ELEMENT_CONTENT_OPT;\n+        }\n+        NEXT;\n@@ -6439,17 +6441,18 @@\n-    if (ret != NULL) {\n-        ret->ocur = XML_ELEMENT_CONTENT_MULT;\n-        cur = ret;\n-        \/*\n-         * Some normalization:\n-         * (a | b* | c?)* == (a | b | c)*\n-         *\/\n-        while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {\n-        if ((cur->c1 != NULL) &&\n-                ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n-             (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT)))\n-            cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;\n-        if ((cur->c2 != NULL) &&\n-                ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||\n-             (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT)))\n-            cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;\n-        cur = cur->c2;\n+        if (ret != NULL) {\n+            ret->ocur = XML_ELEMENT_CONTENT_MULT;\n+            cur = ret;\n+            \/*\n+             * Some normalization:\n+             * (a | b* | c?)* == (a | b | c)*\n+             *\/\n+            while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {\n+                if ((cur->c1 != NULL) &&\n+                    ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n+                     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT)))\n+                    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;\n+                if ((cur->c2 != NULL) &&\n+                    ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||\n+                     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT)))\n+                    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;\n+                cur = cur->c2;\n+            }\n@@ -6457,2 +6460,1 @@\n-    }\n-    NEXT;\n+        NEXT;\n@@ -6460,2 +6462,2 @@\n-    if (ret != NULL) {\n-        int found = 0;\n+        if (ret != NULL) {\n+            int found = 0;\n@@ -6463,24 +6465,27 @@\n-        if ((ret->ocur == XML_ELEMENT_CONTENT_OPT) ||\n-            (ret->ocur == XML_ELEMENT_CONTENT_MULT))\n-            ret->ocur = XML_ELEMENT_CONTENT_MULT;\n-        else\n-            ret->ocur = XML_ELEMENT_CONTENT_PLUS;\n-        \/*\n-         * Some normalization:\n-         * (a | b*)+ == (a | b)*\n-         * (a | b?)+ == (a | b)*\n-         *\/\n-        while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {\n-        if ((cur->c1 != NULL) &&\n-                ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n-             (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {\n-            cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;\n-            found = 1;\n-        }\n-        if ((cur->c2 != NULL) &&\n-                ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||\n-             (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT))) {\n-            cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;\n-            found = 1;\n-        }\n-        cur = cur->c2;\n+            if ((ret->ocur == XML_ELEMENT_CONTENT_OPT) ||\n+                (ret->ocur == XML_ELEMENT_CONTENT_MULT))\n+                ret->ocur = XML_ELEMENT_CONTENT_MULT;\n+            else\n+                ret->ocur = XML_ELEMENT_CONTENT_PLUS;\n+            \/*\n+             * Some normalization:\n+             * (a | b*)+ == (a | b)*\n+             * (a | b?)+ == (a | b)*\n+             *\/\n+            while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {\n+                if ((cur->c1 != NULL) &&\n+                    ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n+                     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {\n+                    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;\n+                    found = 1;\n+                }\n+                if ((cur->c2 != NULL) &&\n+                    ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||\n+                     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT))) {\n+                    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;\n+                    found = 1;\n+                }\n+                cur = cur->c2;\n+            }\n+            if (found)\n+                ret->ocur = XML_ELEMENT_CONTENT_MULT;\n@@ -6488,4 +6493,1 @@\n-        if (found)\n-        ret->ocur = XML_ELEMENT_CONTENT_MULT;\n-    }\n-    NEXT;\n+        NEXT;\n@@ -6514,8 +6516,8 @@\n- *  with parenthesized groups. That is to say, if either of the\n- *  opening or closing parentheses in a choice, seq, or Mixed\n- *  construct is contained in the replacement text for a parameter\n- *  entity, both must be contained in the same replacement text. For\n- *  interoperability, if a parameter-entity reference appears in a\n- *  choice, seq, or Mixed construct, its replacement text should not\n- *  be empty, and neither the first nor last non-blank character of\n- *  the replacement text should be a connector (| or ,).\n+ *      with parenthesized groups. That is to say, if either of the\n+ *      opening or closing parentheses in a choice, seq, or Mixed\n+ *      construct is contained in the replacement text for a parameter\n+ *      entity, both must be contained in the same replacement text. For\n+ *      interoperability, if a parameter-entity reference appears in a\n+ *      choice, seq, or Mixed construct, its replacement text should not\n+ *      be empty, and neither the first nor last non-blank character of\n+ *      the replacement text should be a connector (| or ,).\n@@ -6557,3 +6559,3 @@\n-    xmlFatalErrMsgStr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,\n-        \"xmlParseElementContentDecl : %s '(' expected\\n\", name);\n-    return(-1);\n+        xmlFatalErrMsgStr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,\n+                \"xmlParseElementContentDecl : %s '(' expected\\n\", name);\n+        return(-1);\n@@ -6568,1 +6570,1 @@\n-    res = XML_ELEMENT_TYPE_MIXED;\n+        res = XML_ELEMENT_TYPE_MIXED;\n@@ -6571,1 +6573,1 @@\n-    res = XML_ELEMENT_TYPE_ELEMENT;\n+        res = XML_ELEMENT_TYPE_ELEMENT;\n@@ -6599,1 +6601,1 @@\n-    int inputid = ctxt->input->id;\n+        int inputid = ctxt->input->id;\n@@ -6601,39 +6603,31 @@\n-    SKIP(9);\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                   \"Space required after 'ELEMENT'\\n\");\n-        return(-1);\n-    }\n-        name = xmlParseName(ctxt);\n-    if (name == NULL) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-               \"xmlParseElementDecl: no name for Element\\n\");\n-        return(-1);\n-    }\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"Space required after the element name\\n\");\n-    }\n-    if (CMP5(CUR_PTR, 'E', 'M', 'P', 'T', 'Y')) {\n-        SKIP(5);\n-        \/*\n-         * Element must always be empty.\n-         *\/\n-        ret = XML_ELEMENT_TYPE_EMPTY;\n-    } else if ((RAW == 'A') && (NXT(1) == 'N') &&\n-               (NXT(2) == 'Y')) {\n-        SKIP(3);\n-        \/*\n-         * Element is a generic container.\n-         *\/\n-        ret = XML_ELEMENT_TYPE_ANY;\n-    } else if (RAW == '(') {\n-        ret = xmlParseElementContentDecl(ctxt, name, &content);\n-    } else {\n-        \/*\n-         * [ WFC: PEs in Internal Subset ] error handling.\n-         *\/\n-        if ((RAW == '%') && (ctxt->external == 0) &&\n-            (ctxt->inputNr == 1)) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_PEREF_IN_INT_SUBSET,\n-      \"PEReference: forbidden within markup decl in internal subset\\n\");\n+        SKIP(9);\n+        if (SKIP_BLANKS == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space required after 'ELEMENT'\\n\");\n+            return(-1);\n+        }\n+        name = xmlParseName(ctxt);\n+        if (name == NULL) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                           \"xmlParseElementDecl: no name for Element\\n\");\n+            return(-1);\n+        }\n+        if (SKIP_BLANKS == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space required after the element name\\n\");\n+        }\n+        if (CMP5(CUR_PTR, 'E', 'M', 'P', 'T', 'Y')) {\n+            SKIP(5);\n+            \/*\n+             * Element must always be empty.\n+             *\/\n+            ret = XML_ELEMENT_TYPE_EMPTY;\n+        } else if ((RAW == 'A') && (NXT(1) == 'N') &&\n+                   (NXT(2) == 'Y')) {\n+            SKIP(3);\n+            \/*\n+             * Element is a generic container.\n+             *\/\n+            ret = XML_ELEMENT_TYPE_ANY;\n+        } else if (RAW == '(') {\n+            ret = xmlParseElementContentDecl(ctxt, name, &content);\n@@ -6641,2 +6635,10 @@\n-        xmlFatalErrMsg(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,\n-              \"xmlParseElementDecl: 'EMPTY', 'ANY' or '(' expected\\n\");\n+            \/*\n+             * [ WFC: PEs in Internal Subset ] error handling.\n+             *\/\n+            if ((RAW == '%') && (ctxt->external == 0) &&\n+                (ctxt->inputNr == 1)) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_PEREF_IN_INT_SUBSET,\n+          \"PEReference: forbidden within markup decl in internal subset\\n\");\n+            } else {\n+                xmlFatalErrMsg(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,\n+                      \"xmlParseElementDecl: 'EMPTY', 'ANY' or '(' expected\\n\");\n@@ -6644,2 +6646,2 @@\n-        return(-1);\n-    }\n+            return(-1);\n+        }\n@@ -6647,1 +6649,1 @@\n-    SKIP_BLANKS;\n+        SKIP_BLANKS;\n@@ -6649,8 +6651,8 @@\n-    if (RAW != '>') {\n-        xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);\n-        if (content != NULL) {\n-        xmlFreeDocElementContent(ctxt->myDoc, content);\n-        }\n-    } else {\n-        if (inputid != ctxt->input->id) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+        if (RAW != '>') {\n+            xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);\n+            if (content != NULL) {\n+                xmlFreeDocElementContent(ctxt->myDoc, content);\n+            }\n+        } else {\n+            if (inputid != ctxt->input->id) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n@@ -6659,1 +6661,1 @@\n-        }\n+            }\n@@ -6661,18 +6663,19 @@\n-        NEXT;\n-        if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n-        (ctxt->sax->elementDecl != NULL)) {\n-        if (content != NULL)\n-            content->parent = NULL;\n-            ctxt->sax->elementDecl(ctxt->userData, name, ret,\n-                               content);\n-        if ((content != NULL) && (content->parent == NULL)) {\n-            \/*\n-             * this is a trick: if xmlAddElementDecl is called,\n-             * instead of copying the full tree it is plugged directly\n-             * if called from the parser. Avoid duplicating the\n-             * interfaces or change the API\/ABI\n-             *\/\n-            xmlFreeDocElementContent(ctxt->myDoc, content);\n-        }\n-        } else if (content != NULL) {\n-        xmlFreeDocElementContent(ctxt->myDoc, content);\n+            NEXT;\n+            if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n+                (ctxt->sax->elementDecl != NULL)) {\n+                if (content != NULL)\n+                    content->parent = NULL;\n+                ctxt->sax->elementDecl(ctxt->userData, name, ret,\n+                                       content);\n+                if ((content != NULL) && (content->parent == NULL)) {\n+                    \/*\n+                     * this is a trick: if xmlAddElementDecl is called,\n+                     * instead of copying the full tree it is plugged directly\n+                     * if called from the parser. Avoid duplicating the\n+                     * interfaces or change the API\/ABI\n+                     *\/\n+                    xmlFreeDocElementContent(ctxt->myDoc, content);\n+                }\n+            } else if (content != NULL) {\n+                xmlFreeDocElementContent(ctxt->myDoc, content);\n+            }\n@@ -6681,1 +6684,0 @@\n-    }\n@@ -6789,2 +6791,2 @@\n-        if (RAW == 0) {\n-            xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);\n+                if (RAW == 0) {\n+                    xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);\n@@ -6792,1 +6794,1 @@\n-        }\n+                }\n@@ -6864,19 +6866,22 @@\n-        switch (NXT(2)) {\n-            case 'E':\n-            if (NXT(3) == 'L')\n-            xmlParseElementDecl(ctxt);\n-            else if (NXT(3) == 'N')\n-            xmlParseEntityDecl(ctxt);\n-            break;\n-            case 'A':\n-            xmlParseAttributeListDecl(ctxt);\n-            break;\n-            case 'N':\n-            xmlParseNotationDecl(ctxt);\n-            break;\n-            case '-':\n-            xmlParseComment(ctxt);\n-            break;\n-        default:\n-            \/* there is an error but it will be detected later *\/\n-            break;\n+            switch (NXT(2)) {\n+                case 'E':\n+                    if (NXT(3) == 'L')\n+                        xmlParseElementDecl(ctxt);\n+                    else if (NXT(3) == 'N')\n+                        xmlParseEntityDecl(ctxt);\n+                    break;\n+                case 'A':\n+                    xmlParseAttributeListDecl(ctxt);\n+                    break;\n+                case 'N':\n+                    xmlParseNotationDecl(ctxt);\n+                    break;\n+                case '-':\n+                    xmlParseComment(ctxt);\n+                    break;\n+                default:\n+                    \/* there is an error but it will be detected later *\/\n+                    break;\n+            }\n+        } else if (NXT(1) == '?') {\n+            xmlParsePI(ctxt);\n@@ -6884,3 +6889,0 @@\n-    } else if (NXT(1) == '?') {\n-        xmlParsePI(ctxt);\n-    }\n@@ -6918,1 +6920,1 @@\n-    SKIP(5);\n+        SKIP(5);\n@@ -6920,2 +6922,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_STARTED, NULL);\n-    return;\n+        xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_STARTED, NULL);\n+        return;\n@@ -6929,2 +6931,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"Space needed after '<?xml'\\n\");\n+        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                       \"Space needed after '<?xml'\\n\");\n@@ -6938,1 +6940,1 @@\n-    version = xmlCharStrdup(XML_DEFAULT_VERSION);\n+        version = xmlCharStrdup(XML_DEFAULT_VERSION);\n@@ -6940,4 +6942,4 @@\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                   \"Space needed here\\n\");\n-    }\n+        if (SKIP_BLANKS == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space needed here\\n\");\n+        }\n@@ -6952,3 +6954,3 @@\n-    \/*\n-     * The XML REC instructs us to stop parsing right here\n-     *\/\n+        \/*\n+         * The XML REC instructs us to stop parsing right here\n+         *\/\n@@ -6959,2 +6961,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_MISSING_ENCODING,\n-               \"Missing encoding in text declaration\\n\");\n+        xmlFatalErrMsg(ctxt, XML_ERR_MISSING_ENCODING,\n+                       \"Missing encoding in text declaration\\n\");\n@@ -6968,2 +6970,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);\n-    NEXT;\n+        xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);\n+        NEXT;\n@@ -6971,3 +6973,3 @@\n-    xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);\n-    MOVETO_ENDTAG(CUR_PTR);\n-    NEXT;\n+        xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);\n+        MOVETO_ENDTAG(CUR_PTR);\n+        NEXT;\n@@ -7000,9 +7002,9 @@\n-    xmlCharEncoding enc;\n-\n-    start[0] = RAW;\n-    start[1] = NXT(1);\n-    start[2] = NXT(2);\n-    start[3] = NXT(3);\n-    enc = xmlDetectCharEncoding(start, 4);\n-    if (enc != XML_CHAR_ENCODING_NONE)\n-        xmlSwitchEncoding(ctxt, enc);\n+        xmlCharEncoding enc;\n+\n+        start[0] = RAW;\n+        start[1] = NXT(1);\n+        start[2] = NXT(2);\n+        start[3] = NXT(3);\n+        enc = xmlDetectCharEncoding(start, 4);\n+        if (enc != XML_CHAR_ENCODING_NONE)\n+            xmlSwitchEncoding(ctxt, enc);\n@@ -7012,8 +7014,8 @@\n-    xmlParseTextDecl(ctxt);\n-    if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n-        \/*\n-         * The XML REC instructs us to stop parsing right here\n-         *\/\n-        xmlHaltParser(ctxt);\n-        return;\n-    }\n+        xmlParseTextDecl(ctxt);\n+        if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n+            \/*\n+             * The XML REC instructs us to stop parsing right here\n+             *\/\n+            xmlHaltParser(ctxt);\n+            return;\n+        }\n@@ -7023,5 +7025,5 @@\n-    if (ctxt->myDoc == NULL) {\n-        xmlErrMemory(ctxt, \"New Doc failed\");\n-        return;\n-    }\n-    ctxt->myDoc->properties = XML_DOC_INTERNAL;\n+        if (ctxt->myDoc == NULL) {\n+            xmlErrMemory(ctxt, \"New Doc failed\");\n+            return;\n+        }\n+        ctxt->myDoc->properties = XML_DOC_INTERNAL;\n@@ -7037,3 +7039,3 @@\n-       (RAW == '%')) {\n-    const xmlChar *check = CUR_PTR;\n-    unsigned int cons = ctxt->input->consumed;\n+           (RAW == '%')) {\n+        const xmlChar *check = CUR_PTR;\n+        unsigned int cons = ctxt->input->consumed;\n@@ -7041,1 +7043,1 @@\n-    GROW;\n+        GROW;\n@@ -7043,3 +7045,3 @@\n-        xmlParseConditionalSections(ctxt);\n-    } else\n-        xmlParseMarkupDecl(ctxt);\n+            xmlParseConditionalSections(ctxt);\n+        } else\n+            xmlParseMarkupDecl(ctxt);\n@@ -7048,4 +7050,4 @@\n-    if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {\n-        xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);\n-        break;\n-    }\n+        if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {\n+            xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);\n+            break;\n+        }\n@@ -7055,1 +7057,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);\n@@ -7087,4 +7089,4 @@\n-    int i = 0;\n-    xmlChar out[16];\n-    int hex = NXT(2);\n-    int value = xmlParseCharRef(ctxt);\n+        int i = 0;\n+        xmlChar out[16];\n+        int hex = NXT(2);\n+        int value = xmlParseCharRef(ctxt);\n@@ -7092,14 +7094,23 @@\n-    if (value == 0)\n-        return;\n-    if (ctxt->charset != XML_CHAR_ENCODING_UTF8) {\n-        \/*\n-         * So we are using non-UTF-8 buffers\n-         * Check that the char fit on 8bits, if not\n-         * generate a CharRef.\n-         *\/\n-        if (value <= 0xFF) {\n-        out[0] = value;\n-        out[1] = 0;\n-        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n-            (!ctxt->disableSAX))\n-            ctxt->sax->characters(ctxt->userData, out, 1);\n+        if (value == 0)\n+            return;\n+        if (ctxt->charset != XML_CHAR_ENCODING_UTF8) {\n+            \/*\n+             * So we are using non-UTF-8 buffers\n+             * Check that the char fit on 8bits, if not\n+             * generate a CharRef.\n+             *\/\n+            if (value <= 0xFF) {\n+                out[0] = value;\n+                out[1] = 0;\n+                if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n+                    (!ctxt->disableSAX))\n+                    ctxt->sax->characters(ctxt->userData, out, 1);\n+            } else {\n+                if ((hex == 'x') || (hex == 'X'))\n+                    snprintf((char *)out, sizeof(out), \"#x%X\", value);\n+                else\n+                    snprintf((char *)out, sizeof(out), \"#%d\", value);\n+                if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&\n+                    (!ctxt->disableSAX))\n+                    ctxt->sax->reference(ctxt->userData, out);\n+            }\n@@ -7107,7 +7118,8 @@\n-        if ((hex == 'x') || (hex == 'X'))\n-            snprintf((char *)out, sizeof(out), \"#x%X\", value);\n-        else\n-            snprintf((char *)out, sizeof(out), \"#%d\", value);\n-        if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&\n-            (!ctxt->disableSAX))\n-            ctxt->sax->reference(ctxt->userData, out);\n+            \/*\n+             * Just encode the value in UTF-8\n+             *\/\n+            COPY_BUF(0 ,out, i, value);\n+            out[i] = 0;\n+            if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n+                (!ctxt->disableSAX))\n+                ctxt->sax->characters(ctxt->userData, out, i);\n@@ -7115,11 +7127,1 @@\n-    } else {\n-        \/*\n-         * Just encode the value in UTF-8\n-         *\/\n-        COPY_BUF(0 ,out, i, value);\n-        out[i] = 0;\n-        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n-        (!ctxt->disableSAX))\n-        ctxt->sax->characters(ctxt->userData, out, i);\n-    }\n-    return;\n+        return;\n@@ -7134,1 +7136,1 @@\n-    return;\n+        return;\n@@ -7140,9 +7142,9 @@\n-    val = ent->content;\n-    if (val == NULL) return;\n-    \/*\n-     * inline the entity.\n-     *\/\n-    if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n-        (!ctxt->disableSAX))\n-        ctxt->sax->characters(ctxt->userData, val, xmlStrlen(val));\n-    return;\n+        val = ent->content;\n+        if (val == NULL) return;\n+        \/*\n+         * inline the entity.\n+         *\/\n+        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n+            (!ctxt->disableSAX))\n+            ctxt->sax->characters(ctxt->userData, val, xmlStrlen(val));\n+        return;\n@@ -7165,1 +7167,1 @@\n-    unsigned long oldnbent = ctxt->nbentities, diff;\n+        unsigned long oldnbent = ctxt->nbentities, diff;\n@@ -7167,34 +7169,10 @@\n-    \/*\n-     * This is a bit hackish but this seems the best\n-     * way to make sure both SAX and DOM entity support\n-     * behaves okay.\n-     *\/\n-    void *user_data;\n-    if (ctxt->userData == ctxt)\n-        user_data = NULL;\n-    else\n-        user_data = ctxt->userData;\n-\n-    \/*\n-     * Check that this entity is well formed\n-     * 4.3.2: An internal general parsed entity is well-formed\n-     * if its replacement text matches the production labeled\n-     * content.\n-     *\/\n-    if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {\n-        ctxt->depth++;\n-        ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent->content,\n-                                                  user_data, &list);\n-        ctxt->depth--;\n-\n-    } else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {\n-        ctxt->depth++;\n-        ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt, ctxt->sax,\n-                                       user_data, ctxt->depth, ent->URI,\n-                       ent->ExternalID, &list);\n-        ctxt->depth--;\n-    } else {\n-        ret = XML_ERR_ENTITY_PE_INTERNAL;\n-        xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,\n-             \"invalid entity type found\\n\", NULL);\n-    }\n+        \/*\n+         * This is a bit hackish but this seems the best\n+         * way to make sure both SAX and DOM entity support\n+         * behaves okay.\n+         *\/\n+        void *user_data;\n+        if (ctxt->userData == ctxt)\n+            user_data = NULL;\n+        else\n+            user_data = ctxt->userData;\n@@ -7202,4 +7180,28 @@\n-    \/*\n-     * Store the number of entities needing parsing for this entity\n-     * content and do checkings\n-     *\/\n+        \/*\n+         * Check that this entity is well formed\n+         * 4.3.2: An internal general parsed entity is well-formed\n+         * if its replacement text matches the production labeled\n+         * content.\n+         *\/\n+        if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {\n+            ctxt->depth++;\n+            ret = xmlParseBalancedChunkMemoryInternal(ctxt, ent->content,\n+                                                      user_data, &list);\n+            ctxt->depth--;\n+\n+        } else if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY) {\n+            ctxt->depth++;\n+            ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt, ctxt->sax,\n+                                           user_data, ctxt->depth, ent->URI,\n+                                           ent->ExternalID, &list);\n+            ctxt->depth--;\n+        } else {\n+            ret = XML_ERR_ENTITY_PE_INTERNAL;\n+            xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                         \"invalid entity type found\\n\", NULL);\n+        }\n+\n+        \/*\n+         * Store the number of entities needing parsing for this entity\n+         * content and do checkings\n+         *\/\n@@ -7210,4 +7212,4 @@\n-    if ((ent->content != NULL) && (xmlStrchr(ent->content, '<')))\n-        ent->checked |= 1;\n-    if (ret == XML_ERR_ENTITY_LOOP) {\n-        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n+        if ((ent->content != NULL) && (xmlStrchr(ent->content, '<')))\n+            ent->checked |= 1;\n+        if (ret == XML_ERR_ENTITY_LOOP) {\n+            xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n@@ -7215,7 +7217,7 @@\n-        xmlFreeNodeList(list);\n-        return;\n-    }\n-    if (xmlParserEntityCheck(ctxt, 0, ent, 0)) {\n-        xmlFreeNodeList(list);\n-        return;\n-    }\n+            xmlFreeNodeList(list);\n+            return;\n+        }\n+        if (xmlParserEntityCheck(ctxt, 0, ent, 0)) {\n+            xmlFreeNodeList(list);\n+            return;\n+        }\n@@ -7223,5 +7225,5 @@\n-    if ((ret == XML_ERR_OK) && (list != NULL)) {\n-        if (((ent->etype == XML_INTERNAL_GENERAL_ENTITY) ||\n-         (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY))&&\n-        (ent->children == NULL)) {\n-        ent->children = list;\n+        if ((ret == XML_ERR_OK) && (list != NULL)) {\n+            if (((ent->etype == XML_INTERNAL_GENERAL_ENTITY) ||\n+             (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY))&&\n+                (ent->children == NULL)) {\n+                ent->children = list;\n@@ -7260,8 +7262,8 @@\n-        } else {\n-        xmlFreeNodeList(list);\n-        list = NULL;\n-        }\n-    } else if ((ret != XML_ERR_OK) &&\n-           (ret != XML_WAR_UNDECLARED_ENTITY)) {\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n-             \"Entity '%s' failed to parse\\n\", ent->name);\n+            } else {\n+                xmlFreeNodeList(list);\n+                list = NULL;\n+            }\n+        } else if ((ret != XML_ERR_OK) &&\n+                   (ret != XML_WAR_UNDECLARED_ENTITY)) {\n+            xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n+                     \"Entity '%s' failed to parse\\n\", ent->name);\n@@ -7270,7 +7272,7 @@\n-        xmlParserEntityCheck(ctxt, 0, ent, 0);\n-    } else if (list != NULL) {\n-        xmlFreeNodeList(list);\n-        list = NULL;\n-    }\n-    if (ent->checked == 0)\n-        ent->checked = 2;\n+            xmlParserEntityCheck(ctxt, 0, ent, 0);\n+        } else if (list != NULL) {\n+            xmlFreeNodeList(list);\n+            list = NULL;\n+        }\n+        if (ent->checked == 0)\n+            ent->checked = 2;\n@@ -7281,1 +7283,1 @@\n-    ctxt->nbentities += ent->checked \/ 2;\n+        ctxt->nbentities += ent->checked \/ 2;\n@@ -7290,8 +7292,0 @@\n-    \/*\n-     * Probably running in SAX mode and the callbacks don't\n-     * build the entity content. So unless we already went\n-     * though parsing for first checking go though the entity\n-     * content to generate callbacks associated to the entity\n-     *\/\n-    if (was_checked != 0) {\n-        void *user_data;\n@@ -7299,3 +7293,4 @@\n-         * This is a bit hackish but this seems the best\n-         * way to make sure both SAX and DOM entity support\n-         * behaves okay.\n+         * Probably running in SAX mode and the callbacks don't\n+         * build the entity content. So unless we already went\n+         * though parsing for first checking go though the entity\n+         * content to generate callbacks associated to the entity\n@@ -7303,21 +7298,33 @@\n-        if (ctxt->userData == ctxt)\n-        user_data = NULL;\n-        else\n-        user_data = ctxt->userData;\n-\n-        if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {\n-        ctxt->depth++;\n-        ret = xmlParseBalancedChunkMemoryInternal(ctxt,\n-                   ent->content, user_data, NULL);\n-        ctxt->depth--;\n-        } else if (ent->etype ==\n-               XML_EXTERNAL_GENERAL_PARSED_ENTITY) {\n-        ctxt->depth++;\n-        ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt,\n-               ctxt->sax, user_data, ctxt->depth,\n-               ent->URI, ent->ExternalID, NULL);\n-        ctxt->depth--;\n-        } else {\n-        ret = XML_ERR_ENTITY_PE_INTERNAL;\n-        xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                 \"invalid entity type found\\n\", NULL);\n+        if (was_checked != 0) {\n+            void *user_data;\n+            \/*\n+             * This is a bit hackish but this seems the best\n+             * way to make sure both SAX and DOM entity support\n+             * behaves okay.\n+             *\/\n+            if (ctxt->userData == ctxt)\n+                user_data = NULL;\n+            else\n+                user_data = ctxt->userData;\n+\n+            if (ent->etype == XML_INTERNAL_GENERAL_ENTITY) {\n+                ctxt->depth++;\n+                ret = xmlParseBalancedChunkMemoryInternal(ctxt,\n+                                   ent->content, user_data, NULL);\n+                ctxt->depth--;\n+            } else if (ent->etype ==\n+                       XML_EXTERNAL_GENERAL_PARSED_ENTITY) {\n+                ctxt->depth++;\n+                ret = xmlParseExternalEntityPrivate(ctxt->myDoc, ctxt,\n+                           ctxt->sax, user_data, ctxt->depth,\n+                           ent->URI, ent->ExternalID, NULL);\n+                ctxt->depth--;\n+            } else {\n+                ret = XML_ERR_ENTITY_PE_INTERNAL;\n+                xmlErrMsgStr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                             \"invalid entity type found\\n\", NULL);\n+            }\n+            if (ret == XML_ERR_ENTITY_LOOP) {\n+                xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n+                return;\n+            }\n@@ -7325,3 +7332,7 @@\n-        if (ret == XML_ERR_ENTITY_LOOP) {\n-        xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);\n-        return;\n+        if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&\n+            (ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {\n+            \/*\n+             * Entity reference callback comes second, it's somewhat\n+             * superfluous but a compatibility to historical behaviour\n+             *\/\n+            ctxt->sax->reference(ctxt->userData, ent->name);\n@@ -7329,10 +7340,1 @@\n-    }\n-    if ((ctxt->sax != NULL) && (ctxt->sax->reference != NULL) &&\n-        (ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {\n-        \/*\n-         * Entity reference callback comes second, it's somewhat\n-         * superfluous but a compatibility to historical behaviour\n-         *\/\n-        ctxt->sax->reference(ctxt->userData, ent->name);\n-    }\n-    return;\n+        return;\n@@ -7345,23 +7347,1 @@\n-    (ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {\n-    \/*\n-     * Create a node.\n-     *\/\n-    ctxt->sax->reference(ctxt->userData, ent->name);\n-    return;\n-    }\n-\n-    if ((ctxt->replaceEntities) || (ent->children == NULL))  {\n-    \/*\n-     * There is a problem on the handling of _private for entities\n-     * (bug 155816): Should we copy the content of the field from\n-     * the entity (possibly overwriting some value set by the user\n-     * when a copy is created), should we leave it alone, or should\n-     * we try to take care of different situations?  The problem\n-     * is exacerbated by the usage of this field by the xmlReader.\n-     * To fix this bug, we look at _private on the created node\n-     * and, if it's NULL, we copy in whatever was in the entity.\n-     * If it's not NULL we leave it alone.  This is somewhat of a\n-     * hack - maybe we should have further tests to determine\n-     * what to do.\n-     *\/\n-    if ((ctxt->node != NULL) && (ent->children != NULL)) {\n+        (ctxt->replaceEntities == 0) && (!ctxt->disableSAX)) {\n@@ -7369,3 +7349,1 @@\n-         * Seems we are generating the DOM content, do\n-         * a simple tree copy for all references except the first\n-         * In the first occurrence list contains the replacement.\n+         * Create a node.\n@@ -7373,3 +7351,3 @@\n-        if (((list == NULL) && (ent->owner == 0)) ||\n-        (ctxt->parseMode == XML_PARSE_READER)) {\n-        xmlNodePtr nw = NULL, cur, firstChild = NULL;\n+        ctxt->sax->reference(ctxt->userData, ent->name);\n+        return;\n+    }\n@@ -7377,0 +7355,1 @@\n+    if ((ctxt->replaceEntities) || (ent->children == NULL))  {\n@@ -7378,1 +7357,11 @@\n-         * We are copying here, make sure there is no abuse\n+         * There is a problem on the handling of _private for entities\n+         * (bug 155816): Should we copy the content of the field from\n+         * the entity (possibly overwriting some value set by the user\n+         * when a copy is created), should we leave it alone, or should\n+         * we try to take care of different situations?  The problem\n+         * is exacerbated by the usage of this field by the xmlReader.\n+         * To fix this bug, we look at _private on the created node\n+         * and, if it's NULL, we copy in whatever was in the entity.\n+         * If it's not NULL we leave it alone.  This is somewhat of a\n+         * hack - maybe we should have further tests to determine\n+         * what to do.\n@@ -7380,3 +7369,9 @@\n-        ctxt->sizeentcopy += ent->length + 5;\n-        if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))\n-            return;\n+        if ((ctxt->node != NULL) && (ent->children != NULL)) {\n+            \/*\n+             * Seems we are generating the DOM content, do\n+             * a simple tree copy for all references except the first\n+             * In the first occurrence list contains the replacement.\n+             *\/\n+            if (((list == NULL) && (ent->owner == 0)) ||\n+                (ctxt->parseMode == XML_PARSE_READER)) {\n+                xmlNodePtr nw = NULL, cur, firstChild = NULL;\n@@ -7384,6 +7379,6 @@\n-        \/*\n-         * when operating on a reader, the entities definitions\n-         * are always owning the entities subtree.\n-        if (ctxt->parseMode == XML_PARSE_READER)\n-            ent->owner = 1;\n-         *\/\n+                \/*\n+                 * We are copying here, make sure there is no abuse\n+                 *\/\n+                ctxt->sizeentcopy += ent->length + 5;\n+                if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))\n+                    return;\n@@ -7391,21 +7386,6 @@\n-        cur = ent->children;\n-        while (cur != NULL) {\n-            nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);\n-            if (nw != NULL) {\n-            if (nw->_private == NULL)\n-                nw->_private = cur->_private;\n-            if (firstChild == NULL){\n-                firstChild = nw;\n-            }\n-            nw = xmlAddChild(ctxt->node, nw);\n-            }\n-            if (cur == ent->last) {\n-            \/*\n-             * needed to detect some strange empty\n-             * node cases in the reader tests\n-             *\/\n-            if ((ctxt->parseMode == XML_PARSE_READER) &&\n-                (nw != NULL) &&\n-                (nw->type == XML_ELEMENT_NODE) &&\n-                (nw->children == NULL))\n-                nw->extra = 1;\n+                \/*\n+                 * when operating on a reader, the entities definitions\n+                 * are always owning the entities subtree.\n+                if (ctxt->parseMode == XML_PARSE_READER)\n+                    ent->owner = 1;\n+                 *\/\n@@ -7413,4 +7393,26 @@\n-            break;\n-            }\n-            cur = cur->next;\n-        }\n+                cur = ent->children;\n+                while (cur != NULL) {\n+                    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);\n+                    if (nw != NULL) {\n+                        if (nw->_private == NULL)\n+                            nw->_private = cur->_private;\n+                        if (firstChild == NULL){\n+                            firstChild = nw;\n+                        }\n+                        nw = xmlAddChild(ctxt->node, nw);\n+                    }\n+                    if (cur == ent->last) {\n+                        \/*\n+                         * needed to detect some strange empty\n+                         * node cases in the reader tests\n+                         *\/\n+                        if ((ctxt->parseMode == XML_PARSE_READER) &&\n+                            (nw != NULL) &&\n+                            (nw->type == XML_ELEMENT_NODE) &&\n+                            (nw->children == NULL))\n+                            nw->extra = 1;\n+\n+                        break;\n+                    }\n+                    cur = cur->next;\n+                }\n@@ -7418,2 +7420,2 @@\n-        if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)\n-          xmlAddEntityReference(ent, firstChild, nw);\n+                if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)\n+                  xmlAddEntityReference(ent, firstChild, nw);\n@@ -7421,3 +7423,3 @@\n-        } else if ((list == NULL) || (ctxt->inputNr > 0)) {\n-        xmlNodePtr nw = NULL, cur, next, last,\n-               firstChild = NULL;\n+            } else if ((list == NULL) || (ctxt->inputNr > 0)) {\n+                xmlNodePtr nw = NULL, cur, next, last,\n+                           firstChild = NULL;\n@@ -7425,6 +7427,6 @@\n-        \/*\n-         * We are copying here, make sure there is no abuse\n-         *\/\n-        ctxt->sizeentcopy += ent->length + 5;\n-        if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))\n-            return;\n+                \/*\n+                 * We are copying here, make sure there is no abuse\n+                 *\/\n+                ctxt->sizeentcopy += ent->length + 5;\n+                if (xmlParserEntityCheck(ctxt, 0, ent, ctxt->sizeentcopy))\n+                    return;\n@@ -7432,30 +7434,30 @@\n-        \/*\n-         * Copy the entity child list and make it the new\n-         * entity child list. The goal is to make sure any\n-         * ID or REF referenced will be the one from the\n-         * document content and not the entity copy.\n-         *\/\n-        cur = ent->children;\n-        ent->children = NULL;\n-        last = ent->last;\n-        ent->last = NULL;\n-        while (cur != NULL) {\n-            next = cur->next;\n-            cur->next = NULL;\n-            cur->parent = NULL;\n-            nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);\n-            if (nw != NULL) {\n-            if (nw->_private == NULL)\n-                nw->_private = cur->_private;\n-            if (firstChild == NULL){\n-                firstChild = cur;\n-            }\n-            xmlAddChild((xmlNodePtr) ent, nw);\n-            xmlAddChild(ctxt->node, cur);\n-            }\n-            if (cur == last)\n-            break;\n-            cur = next;\n-        }\n-        if (ent->owner == 0)\n-            ent->owner = 1;\n+                \/*\n+                 * Copy the entity child list and make it the new\n+                 * entity child list. The goal is to make sure any\n+                 * ID or REF referenced will be the one from the\n+                 * document content and not the entity copy.\n+                 *\/\n+                cur = ent->children;\n+                ent->children = NULL;\n+                last = ent->last;\n+                ent->last = NULL;\n+                while (cur != NULL) {\n+                    next = cur->next;\n+                    cur->next = NULL;\n+                    cur->parent = NULL;\n+                    nw = xmlDocCopyNode(cur, ctxt->myDoc, 1);\n+                    if (nw != NULL) {\n+                        if (nw->_private == NULL)\n+                            nw->_private = cur->_private;\n+                        if (firstChild == NULL){\n+                            firstChild = cur;\n+                        }\n+                        xmlAddChild((xmlNodePtr) ent, nw);\n+                        xmlAddChild(ctxt->node, cur);\n+                    }\n+                    if (cur == last)\n+                        break;\n+                    cur = next;\n+                }\n+                if (ent->owner == 0)\n+                    ent->owner = 1;\n@@ -7463,2 +7465,2 @@\n-        if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)\n-          xmlAddEntityReference(ent, firstChild, nw);\n+                if (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)\n+                  xmlAddEntityReference(ent, firstChild, nw);\n@@ -7466,2 +7468,2 @@\n-        } else {\n-        const xmlChar *nbktext;\n+            } else {\n+                const xmlChar *nbktext;\n@@ -7469,14 +7471,14 @@\n-        \/*\n-         * the name change is to avoid coalescing of the\n-         * node with a possible previous text one which\n-         * would make ent->children a dangling pointer\n-         *\/\n-        nbktext = xmlDictLookup(ctxt->dict, BAD_CAST \"nbktext\",\n-                    -1);\n-        if (ent->children->type == XML_TEXT_NODE)\n-            ent->children->name = nbktext;\n-        if ((ent->last != ent->children) &&\n-            (ent->last->type == XML_TEXT_NODE))\n-            ent->last->name = nbktext;\n-        xmlAddChildList(ctxt->node, ent->children);\n-        }\n+                \/*\n+                 * the name change is to avoid coalescing of the\n+                 * node with a possible previous text one which\n+                 * would make ent->children a dangling pointer\n+                 *\/\n+                nbktext = xmlDictLookup(ctxt->dict, BAD_CAST \"nbktext\",\n+                                        -1);\n+                if (ent->children->type == XML_TEXT_NODE)\n+                    ent->children->name = nbktext;\n+                if ((ent->last != ent->children) &&\n+                    (ent->last->type == XML_TEXT_NODE))\n+                    ent->last->name = nbktext;\n+                xmlAddChildList(ctxt->node, ent->children);\n+            }\n@@ -7484,8 +7486,8 @@\n-        \/*\n-         * This is to avoid a nasty side effect, see\n-         * characters() in SAX.c\n-         *\/\n-        ctxt->nodemem = 0;\n-        ctxt->nodelen = 0;\n-        return;\n-    }\n+            \/*\n+             * This is to avoid a nasty side effect, see\n+             * characters() in SAX.c\n+             *\/\n+            ctxt->nodemem = 0;\n+            ctxt->nodelen = 0;\n+            return;\n+        }\n@@ -7537,2 +7539,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-               \"xmlParseEntityRef: no name\\n\");\n+        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                       \"xmlParseEntityRef: no name\\n\");\n@@ -7542,2 +7544,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n-    return(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n+        return(NULL);\n@@ -7566,9 +7568,9 @@\n-    if (ctxt->sax->getEntity != NULL)\n-        ent = ctxt->sax->getEntity(ctxt->userData, name);\n-    if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&\n-        (ctxt->options & XML_PARSE_OLDSAX))\n-        ent = xmlGetPredefinedEntity(name);\n-    if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&\n-        (ctxt->userData==ctxt)) {\n-        ent = xmlSAX2GetEntity(ctxt, name);\n-    }\n+        if (ctxt->sax->getEntity != NULL)\n+            ent = ctxt->sax->getEntity(ctxt->userData, name);\n+        if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&\n+            (ctxt->options & XML_PARSE_OLDSAX))\n+            ent = xmlGetPredefinedEntity(name);\n+        if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&\n+            (ctxt->userData==ctxt)) {\n+            ent = xmlSAX2GetEntity(ctxt, name);\n+        }\n@@ -7577,1 +7579,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -7600,12 +7602,13 @@\n-    if ((ctxt->standalone == 1) ||\n-        ((ctxt->hasExternalSubset == 0) &&\n-         (ctxt->hasPErefs == 0))) {\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n-             \"Entity '%s' not defined\\n\", name);\n-    } else {\n-        xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,\n-             \"Entity '%s' not defined\\n\", name);\n-        if ((ctxt->inSubset == 0) &&\n-        (ctxt->sax != NULL) &&\n-        (ctxt->sax->reference != NULL)) {\n-        ctxt->sax->reference(ctxt->userData, name);\n+        if ((ctxt->standalone == 1) ||\n+            ((ctxt->hasExternalSubset == 0) &&\n+             (ctxt->hasPErefs == 0))) {\n+            xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n+                     \"Entity '%s' not defined\\n\", name);\n+        } else {\n+            xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,\n+                     \"Entity '%s' not defined\\n\", name);\n+            if ((ctxt->inSubset == 0) &&\n+                (ctxt->sax != NULL) &&\n+                (ctxt->sax->reference != NULL)) {\n+                ctxt->sax->reference(ctxt->userData, name);\n+            }\n@@ -7613,3 +7616,2 @@\n-    }\n-    xmlParserEntityCheck(ctxt, 0, ent, 0);\n-    ctxt->valid = 0;\n+        xmlParserEntityCheck(ctxt, 0, ent, 0);\n+        ctxt->valid = 0;\n@@ -7624,2 +7626,2 @@\n-    xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,\n-         \"Entity reference to unparsed entity %s\\n\", name);\n+        xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,\n+                 \"Entity reference to unparsed entity %s\\n\", name);\n@@ -7634,3 +7636,3 @@\n-         (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {\n-    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,\n-         \"Attribute references external entity '%s'\\n\", name);\n+             (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {\n+        xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,\n+             \"Attribute references external entity '%s'\\n\", name);\n@@ -7645,6 +7647,6 @@\n-         (ent != NULL) &&\n-         (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY)) {\n-    if (((ent->checked & 1) || (ent->checked == 0)) &&\n-         (ent->content != NULL) && (xmlStrchr(ent->content, '<'))) {\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,\n-    \"'<' in entity '%s' is not allowed in attributes values\\n\", name);\n+             (ent != NULL) &&\n+             (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY)) {\n+        if (((ent->checked & 1) || (ent->checked == 0)) &&\n+             (ent->content != NULL) && (xmlStrchr(ent->content, '<'))) {\n+            xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,\n+        \"'<' in entity '%s' is not allowed in attributes values\\n\", name);\n@@ -7658,10 +7660,10 @@\n-    switch (ent->etype) {\n-        case XML_INTERNAL_PARAMETER_ENTITY:\n-        case XML_EXTERNAL_PARAMETER_ENTITY:\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,\n-         \"Attempt to reference the parameter entity '%s'\\n\",\n-                  name);\n-        break;\n-        default:\n-        break;\n-    }\n+        switch (ent->etype) {\n+            case XML_INTERNAL_PARAMETER_ENTITY:\n+            case XML_EXTERNAL_PARAMETER_ENTITY:\n+            xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,\n+             \"Attempt to reference the parameter entity '%s'\\n\",\n+                              name);\n+            break;\n+            default:\n+            break;\n+        }\n@@ -7722,1 +7724,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -7727,4 +7729,4 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-               \"xmlParseStringEntityRef: no name\\n\");\n-    *str = ptr;\n-    return(NULL);\n+        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                       \"xmlParseStringEntityRef: no name\\n\");\n+        *str = ptr;\n+        return(NULL);\n@@ -7733,1 +7735,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n@@ -7735,2 +7737,2 @@\n-    *str = ptr;\n-    return(NULL);\n+        *str = ptr;\n+        return(NULL);\n@@ -7763,7 +7765,7 @@\n-    if (ctxt->sax->getEntity != NULL)\n-        ent = ctxt->sax->getEntity(ctxt->userData, name);\n-    if ((ent == NULL) && (ctxt->options & XML_PARSE_OLDSAX))\n-        ent = xmlGetPredefinedEntity(name);\n-    if ((ent == NULL) && (ctxt->userData==ctxt)) {\n-        ent = xmlSAX2GetEntity(ctxt, name);\n-    }\n+        if (ctxt->sax->getEntity != NULL)\n+            ent = ctxt->sax->getEntity(ctxt->userData, name);\n+        if ((ent == NULL) && (ctxt->options & XML_PARSE_OLDSAX))\n+            ent = xmlGetPredefinedEntity(name);\n+        if ((ent == NULL) && (ctxt->userData==ctxt)) {\n+            ent = xmlSAX2GetEntity(ctxt, name);\n+        }\n@@ -7772,2 +7774,2 @@\n-    xmlFree(name);\n-    return(NULL);\n+        xmlFree(name);\n+        return(NULL);\n@@ -7798,12 +7800,12 @@\n-    if ((ctxt->standalone == 1) ||\n-        ((ctxt->hasExternalSubset == 0) &&\n-         (ctxt->hasPErefs == 0))) {\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n-             \"Entity '%s' not defined\\n\", name);\n-    } else {\n-        xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,\n-              \"Entity '%s' not defined\\n\",\n-              name);\n-    }\n-    xmlParserEntityCheck(ctxt, 0, ent, 0);\n-    \/* TODO ? check regressions ctxt->valid = 0; *\/\n+        if ((ctxt->standalone == 1) ||\n+            ((ctxt->hasExternalSubset == 0) &&\n+             (ctxt->hasPErefs == 0))) {\n+            xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n+                     \"Entity '%s' not defined\\n\", name);\n+        } else {\n+            xmlErrMsgStr(ctxt, XML_WAR_UNDECLARED_ENTITY,\n+                          \"Entity '%s' not defined\\n\",\n+                          name);\n+        }\n+        xmlParserEntityCheck(ctxt, 0, ent, 0);\n+        \/* TODO ? check regressions ctxt->valid = 0; *\/\n@@ -7818,2 +7820,2 @@\n-    xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,\n-         \"Entity reference to unparsed entity %s\\n\", name);\n+        xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,\n+                 \"Entity reference to unparsed entity %s\\n\", name);\n@@ -7828,3 +7830,3 @@\n-         (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {\n-    xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,\n-     \"Attribute references external entity '%s'\\n\", name);\n+             (ent->etype == XML_EXTERNAL_GENERAL_PARSED_ENTITY)) {\n+        xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_EXTERNAL,\n+         \"Attribute references external entity '%s'\\n\", name);\n@@ -7839,4 +7841,4 @@\n-         (ent != NULL) && (ent->content != NULL) &&\n-         (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n-         (xmlStrchr(ent->content, '<'))) {\n-    xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,\n+             (ent != NULL) && (ent->content != NULL) &&\n+             (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&\n+             (xmlStrchr(ent->content, '<'))) {\n+        xmlFatalErrMsgStr(ctxt, XML_ERR_LT_IN_ATTRIBUTE,\n@@ -7844,1 +7846,1 @@\n-              name);\n+                          name);\n@@ -7851,10 +7853,10 @@\n-    switch (ent->etype) {\n-        case XML_INTERNAL_PARAMETER_ENTITY:\n-        case XML_EXTERNAL_PARAMETER_ENTITY:\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,\n-         \"Attempt to reference the parameter entity '%s'\\n\",\n-                  name);\n-        break;\n-        default:\n-        break;\n-    }\n+        switch (ent->etype) {\n+            case XML_INTERNAL_PARAMETER_ENTITY:\n+            case XML_EXTERNAL_PARAMETER_ENTITY:\n+                xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_IS_PARAMETER,\n+             \"Attempt to reference the parameter entity '%s'\\n\",\n+                                  name);\n+            break;\n+            default:\n+            break;\n+        }\n@@ -7916,2 +7918,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, \"PEReference: no name\\n\");\n-    return;\n+        xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, \"PEReference: no name\\n\");\n+        return;\n@@ -7920,2 +7922,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"PEReference: %s\\n\", name);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"PEReference: %s\\n\", name);\n@@ -7923,1 +7925,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);\n@@ -7938,2 +7940,2 @@\n-    (ctxt->sax->getParameterEntity != NULL))\n-    entity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n+        (ctxt->sax->getParameterEntity != NULL))\n+        entity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n@@ -7941,1 +7943,1 @@\n-    return;\n+        return;\n@@ -7943,15 +7945,0 @@\n-    \/*\n-     * [ WFC: Entity Declared ]\n-     * In a document without any DTD, a document with only an\n-     * internal DTD subset which contains no parameter entity\n-     * references, or a document with \"standalone='yes'\", ...\n-     * ... The declaration of a parameter entity must precede\n-     * any reference to it...\n-     *\/\n-    if ((ctxt->standalone == 1) ||\n-        ((ctxt->hasExternalSubset == 0) &&\n-         (ctxt->hasPErefs == 0))) {\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n-                  \"PEReference: %%%s; not found\\n\",\n-                  name);\n-    } else {\n@@ -7959,5 +7946,6 @@\n-         * [ VC: Entity Declared ]\n-         * In a document with an external subset or external\n-         * parameter entities with \"standalone='no'\", ...\n-         * ... The declaration of a parameter entity must\n-         * precede any reference to it...\n+         * [ WFC: Entity Declared ]\n+         * In a document without any DTD, a document with only an\n+         * internal DTD subset which contains no parameter entity\n+         * references, or a document with \"standalone='yes'\", ...\n+         * ... The declaration of a parameter entity must precede\n+         * any reference to it...\n@@ -7965,0 +7953,14 @@\n+        if ((ctxt->standalone == 1) ||\n+            ((ctxt->hasExternalSubset == 0) &&\n+             (ctxt->hasPErefs == 0))) {\n+            xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n+                              \"PEReference: %%%s; not found\\n\",\n+                              name);\n+        } else {\n+            \/*\n+             * [ VC: Entity Declared ]\n+             * In a document with an external subset or external\n+             * parameter entities with \"standalone='no'\", ...\n+             * ... The declaration of a parameter entity must\n+             * precede any reference to it...\n+             *\/\n@@ -7974,11 +7976,2 @@\n-    }\n-    xmlParserEntityCheck(ctxt, 0, NULL, 0);\n-    } else {\n-    \/*\n-     * Internal checking in case the entity quest barfed\n-     *\/\n-    if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n-        (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n-        xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n-          \"Internal: %%%s; is not a parameter entity\\n\",\n-              name, NULL);\n+        }\n+        xmlParserEntityCheck(ctxt, 0, NULL, 0);\n@@ -7986,0 +7979,9 @@\n+        \/*\n+         * Internal checking in case the entity quest barfed\n+         *\/\n+        if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n+            (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n+            xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n+                  \"Internal: %%%s; is not a parameter entity\\n\",\n+                          name, NULL);\n+        } else {\n@@ -7989,2 +7991,2 @@\n-        if (xmlParserEntityCheck(ctxt, 0, entity, 0))\n-            return;\n+            if (xmlParserEntityCheck(ctxt, 0, entity, 0))\n+                return;\n@@ -7992,8 +7994,8 @@\n-        if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n-            ((ctxt->options & XML_PARSE_NOENT) == 0) &&\n-        ((ctxt->options & XML_PARSE_DTDVALID) == 0) &&\n-        ((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&\n-        ((ctxt->options & XML_PARSE_DTDATTR) == 0) &&\n-        (ctxt->replaceEntities == 0) &&\n-        (ctxt->validate == 0))\n-        return;\n+            if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n+                ((ctxt->options & XML_PARSE_NOENT) == 0) &&\n+                ((ctxt->options & XML_PARSE_DTDVALID) == 0) &&\n+                ((ctxt->options & XML_PARSE_DTDLOAD) == 0) &&\n+                ((ctxt->options & XML_PARSE_DTDATTR) == 0) &&\n+                (ctxt->replaceEntities == 0) &&\n+                (ctxt->validate == 0))\n+                return;\n@@ -8001,2 +8003,2 @@\n-        input = xmlNewEntityInputStream(ctxt, entity);\n-        if (xmlPushInput(ctxt, input) < 0) {\n+            input = xmlNewEntityInputStream(ctxt, entity);\n+            if (xmlPushInput(ctxt, input) < 0) {\n@@ -8004,1 +8006,1 @@\n-        return;\n+                return;\n@@ -8007,1 +8009,1 @@\n-        if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {\n+            if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {\n@@ -8036,1 +8038,1 @@\n-    }\n+        }\n@@ -8061,4 +8063,4 @@\n-     (entity->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)) ||\n-    (entity->content != NULL)) {\n-    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                \"xmlLoadEntityContent parameter error\");\n+         (entity->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)) ||\n+        (entity->content != NULL)) {\n+        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                    \"xmlLoadEntityContent parameter error\");\n@@ -8069,2 +8071,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"Reading %s entity content input\\n\", entity->name);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"Reading %s entity content input\\n\", entity->name);\n@@ -8074,2 +8076,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                \"xmlLoadEntityContent parameter error\");\n+        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                    \"xmlLoadEntityContent parameter error\");\n@@ -8081,3 +8083,3 @@\n-    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                \"xmlLoadEntityContent input error\");\n-    xmlBufferFree(buf);\n+        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                    \"xmlLoadEntityContent input error\");\n+        xmlBufferFree(buf);\n@@ -8093,1 +8095,1 @@\n-    return(-1);\n+        return(-1);\n@@ -8101,3 +8103,3 @@\n-    if (count++ > XML_PARSER_CHUNK_SIZE) {\n-        count = 0;\n-        GROW;\n+        if (count++ > XML_PARSER_CHUNK_SIZE) {\n+            count = 0;\n+            GROW;\n@@ -8108,6 +8110,6 @@\n-    }\n-    NEXTL(l);\n-    c = CUR_CHAR(l);\n-    if (c == 0) {\n-        count = 0;\n-        GROW;\n+        }\n+        NEXTL(l);\n+        c = CUR_CHAR(l);\n+        if (c == 0) {\n+            count = 0;\n+            GROW;\n@@ -8118,2 +8120,2 @@\n-        c = CUR_CHAR(l);\n-    }\n+            c = CUR_CHAR(l);\n+        }\n@@ -8127,3 +8129,3 @@\n-                      c);\n-    xmlBufferFree(buf);\n-    return(-1);\n+                          c);\n+        xmlBufferFree(buf);\n+        return(-1);\n@@ -8184,4 +8186,4 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-               \"xmlParseStringPEReference: no name\\n\");\n-    *str = ptr;\n-    return(NULL);\n+        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                       \"xmlParseStringPEReference: no name\\n\");\n+        *str = ptr;\n+        return(NULL);\n@@ -8191,4 +8193,4 @@\n-    xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n-    xmlFree(name);\n-    *str = ptr;\n-    return(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n+        xmlFree(name);\n+        *str = ptr;\n+        return(NULL);\n@@ -8207,2 +8209,2 @@\n-    (ctxt->sax->getParameterEntity != NULL))\n-    entity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n+        (ctxt->sax->getParameterEntity != NULL))\n+        entity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n@@ -8210,3 +8212,3 @@\n-    xmlFree(name);\n-    *str = ptr;\n-    return(NULL);\n+        xmlFree(name);\n+        *str = ptr;\n+        return(NULL);\n@@ -8215,13 +8217,0 @@\n-    \/*\n-     * [ WFC: Entity Declared ]\n-     * In a document without any DTD, a document with only an\n-     * internal DTD subset which contains no parameter entity\n-     * references, or a document with \"standalone='yes'\", ...\n-     * ... The declaration of a parameter entity must precede\n-     * any reference to it...\n-     *\/\n-    if ((ctxt->standalone == 1) ||\n-        ((ctxt->hasExternalSubset == 0) && (ctxt->hasPErefs == 0))) {\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n-         \"PEReference: %%%s; not found\\n\", name);\n-    } else {\n@@ -8229,5 +8218,6 @@\n-         * [ VC: Entity Declared ]\n-         * In a document with an external subset or external\n-         * parameter entities with \"standalone='no'\", ...\n-         * ... The declaration of a parameter entity must\n-         * precede any reference to it...\n+         * [ WFC: Entity Declared ]\n+         * In a document without any DTD, a document with only an\n+         * internal DTD subset which contains no parameter entity\n+         * references, or a document with \"standalone='yes'\", ...\n+         * ... The declaration of a parameter entity must precede\n+         * any reference to it...\n@@ -8235,6 +8225,18 @@\n-        xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n-              \"PEReference: %%%s; not found\\n\",\n-              name, NULL);\n-        ctxt->valid = 0;\n-    }\n-    xmlParserEntityCheck(ctxt, 0, NULL, 0);\n+        if ((ctxt->standalone == 1) ||\n+            ((ctxt->hasExternalSubset == 0) && (ctxt->hasPErefs == 0))) {\n+            xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,\n+                 \"PEReference: %%%s; not found\\n\", name);\n+        } else {\n+            \/*\n+             * [ VC: Entity Declared ]\n+             * In a document with an external subset or external\n+             * parameter entities with \"standalone='no'\", ...\n+             * ... The declaration of a parameter entity must\n+             * precede any reference to it...\n+             *\/\n+            xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n+                          \"PEReference: %%%s; not found\\n\",\n+                          name, NULL);\n+            ctxt->valid = 0;\n+        }\n+        xmlParserEntityCheck(ctxt, 0, NULL, 0);\n@@ -8242,9 +8244,9 @@\n-    \/*\n-     * Internal checking in case the entity quest barfed\n-     *\/\n-    if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n-        (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n-        xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n-              \"%%%s; is not a parameter entity\\n\",\n-              name, NULL);\n-    }\n+        \/*\n+         * Internal checking in case the entity quest barfed\n+         *\/\n+        if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n+            (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n+            xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n+                          \"%%%s; is not a parameter entity\\n\",\n+                          name, NULL);\n+        }\n@@ -8290,2 +8292,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-               \"xmlParseDocTypeDecl : no DOCTYPE name !\\n\");\n+        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                       \"xmlParseDocTypeDecl : no DOCTYPE name !\\n\");\n@@ -8314,2 +8316,2 @@\n-    (!ctxt->disableSAX))\n-    ctxt->sax->internalSubset(ctxt->userData, name, ExternalID, URI);\n+        (!ctxt->disableSAX))\n+        ctxt->sax->internalSubset(ctxt->userData, name, ExternalID, URI);\n@@ -8317,1 +8319,1 @@\n-    return;\n+        return;\n@@ -8324,1 +8326,1 @@\n-    return;\n+        return;\n@@ -8330,1 +8332,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);\n@@ -8353,6 +8355,6 @@\n-    \/*\n-     * Parse the succession of Markup declarations and\n-     * PEReferences.\n-     * Subsequence (markupdecl | PEReference | S)*\n-     *\/\n-    while (((RAW != ']') || (ctxt->inputNr > baseInputNr)) &&\n+        \/*\n+         * Parse the succession of Markup declarations and\n+         * PEReferences.\n+         * Subsequence (markupdecl | PEReference | S)*\n+         *\/\n+        while (((RAW != ']') || (ctxt->inputNr > baseInputNr)) &&\n@@ -8360,2 +8362,2 @@\n-        const xmlChar *check = CUR_PTR;\n-        unsigned int cons = ctxt->input->consumed;\n+            const xmlChar *check = CUR_PTR;\n+            unsigned int cons = ctxt->input->consumed;\n@@ -8363,3 +8365,3 @@\n-        SKIP_BLANKS;\n-        xmlParseMarkupDecl(ctxt);\n-        xmlParsePEReference(ctxt);\n+            SKIP_BLANKS;\n+            xmlParseMarkupDecl(ctxt);\n+            xmlParsePEReference(ctxt);\n@@ -8376,3 +8378,3 @@\n-        if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {\n-        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-         \"xmlParseInternalSubset: error detected in Markup declaration\\n\");\n+            if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {\n+                xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+             \"xmlParseInternalSubset: error detected in Markup declaration\\n\");\n@@ -8382,1 +8384,6 @@\n-            break;\n+                    break;\n+            }\n+        }\n+        if (RAW == ']') {\n+            NEXT;\n+            SKIP_BLANKS;\n@@ -8384,5 +8391,0 @@\n-    }\n-    if (RAW == ']') {\n-        NEXT;\n-        SKIP_BLANKS;\n-    }\n@@ -8395,2 +8397,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);\n-    return;\n+        xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);\n+        return;\n@@ -8444,2 +8446,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-                   \"error parsing attribute name\\n\");\n+        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                       \"error parsing attribute name\\n\");\n@@ -8455,3 +8457,3 @@\n-    SKIP_BLANKS;\n-    val = xmlParseAttValue(ctxt);\n-    ctxt->instate = XML_PARSER_CONTENT;\n+        SKIP_BLANKS;\n+        val = xmlParseAttValue(ctxt);\n+        ctxt->instate = XML_PARSER_CONTENT;\n@@ -8459,3 +8461,3 @@\n-    xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,\n-           \"Specification mandates value for attribute %s\\n\", name);\n-    return(NULL);\n+        xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,\n+               \"Specification mandates value for attribute %s\\n\", name);\n+        return(NULL);\n@@ -8470,5 +8472,5 @@\n-    if (!xmlCheckLanguageID(val)) {\n-        xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,\n-                  \"Malformed value for xml:lang : %s\\n\",\n-              val, NULL);\n-    }\n+        if (!xmlCheckLanguageID(val)) {\n+            xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,\n+                          \"Malformed value for xml:lang : %s\\n\",\n+                          val, NULL);\n+        }\n@@ -8481,6 +8483,6 @@\n-    if (xmlStrEqual(val, BAD_CAST \"default\"))\n-        *(ctxt->space) = 0;\n-    else if (xmlStrEqual(val, BAD_CAST \"preserve\"))\n-        *(ctxt->space) = 1;\n-    else {\n-        xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,\n+        if (xmlStrEqual(val, BAD_CAST \"default\"))\n+            *(ctxt->space) = 0;\n+        else if (xmlStrEqual(val, BAD_CAST \"preserve\"))\n+            *(ctxt->space) = 1;\n+        else {\n+                xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,\n@@ -8489,1 +8491,1 @@\n-    }\n+        }\n@@ -8539,2 +8541,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-         \"xmlParseStartTag: invalid element name\\n\");\n+        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+             \"xmlParseStartTag: invalid element name\\n\");\n@@ -8553,4 +8555,4 @@\n-       ((RAW != '\/') || (NXT(1) != '>')) &&\n-       (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {\n-    const xmlChar *q = CUR_PTR;\n-    unsigned int cons = ctxt->input->consumed;\n+           ((RAW != '\/') || (NXT(1) != '>')) &&\n+           (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {\n+        const xmlChar *q = CUR_PTR;\n+        unsigned int cons = ctxt->input->consumed;\n@@ -8558,1 +8560,1 @@\n-    attname = xmlParseAttribute(ctxt, &attvalue);\n+        attname = xmlParseAttribute(ctxt, &attvalue);\n@@ -8560,35 +8562,48 @@\n-        \/*\n-         * [ WFC: Unique Att Spec ]\n-         * No attribute name may appear more than once in the same\n-         * start-tag or empty-element tag.\n-         *\/\n-        for (i = 0; i < nbatts;i += 2) {\n-            if (xmlStrEqual(atts[i], attname)) {\n-            xmlErrAttributeDup(ctxt, NULL, attname);\n-            xmlFree(attvalue);\n-            goto failed;\n-        }\n-        }\n-        \/*\n-         * Add the pair to atts\n-         *\/\n-        if (atts == NULL) {\n-            maxatts = 22; \/* allow for 10 attrs by default *\/\n-            atts = (const xmlChar **)\n-               xmlMalloc(maxatts * sizeof(xmlChar *));\n-        if (atts == NULL) {\n-            xmlErrMemory(ctxt, NULL);\n-            if (attvalue != NULL)\n-            xmlFree(attvalue);\n-            goto failed;\n-        }\n-        ctxt->atts = atts;\n-        ctxt->maxatts = maxatts;\n-        } else if (nbatts + 4 > maxatts) {\n-            const xmlChar **n;\n-\n-            maxatts *= 2;\n-            n = (const xmlChar **) xmlRealloc((void *) atts,\n-                         maxatts * sizeof(const xmlChar *));\n-        if (n == NULL) {\n-            xmlErrMemory(ctxt, NULL);\n+            \/*\n+             * [ WFC: Unique Att Spec ]\n+             * No attribute name may appear more than once in the same\n+             * start-tag or empty-element tag.\n+             *\/\n+            for (i = 0; i < nbatts;i += 2) {\n+                if (xmlStrEqual(atts[i], attname)) {\n+                    xmlErrAttributeDup(ctxt, NULL, attname);\n+                    xmlFree(attvalue);\n+                    goto failed;\n+                }\n+            }\n+            \/*\n+             * Add the pair to atts\n+             *\/\n+            if (atts == NULL) {\n+                maxatts = 22; \/* allow for 10 attrs by default *\/\n+                atts = (const xmlChar **)\n+                       xmlMalloc(maxatts * sizeof(xmlChar *));\n+                if (atts == NULL) {\n+                    xmlErrMemory(ctxt, NULL);\n+                    if (attvalue != NULL)\n+                        xmlFree(attvalue);\n+                    goto failed;\n+                }\n+                ctxt->atts = atts;\n+                ctxt->maxatts = maxatts;\n+            } else if (nbatts + 4 > maxatts) {\n+                const xmlChar **n;\n+\n+                maxatts *= 2;\n+                n = (const xmlChar **) xmlRealloc((void *) atts,\n+                                             maxatts * sizeof(const xmlChar *));\n+                if (n == NULL) {\n+                    xmlErrMemory(ctxt, NULL);\n+                    if (attvalue != NULL)\n+                        xmlFree(attvalue);\n+                    goto failed;\n+                }\n+                atts = n;\n+                ctxt->atts = atts;\n+                ctxt->maxatts = maxatts;\n+            }\n+            atts[nbatts++] = attname;\n+            atts[nbatts++] = attvalue;\n+            atts[nbatts] = NULL;\n+            atts[nbatts + 1] = NULL;\n+        } else {\n@@ -8596,2 +8611,1 @@\n-            xmlFree(attvalue);\n-            goto failed;\n+                xmlFree(attvalue);\n@@ -8599,12 +8613,0 @@\n-        atts = n;\n-        ctxt->atts = atts;\n-        ctxt->maxatts = maxatts;\n-        }\n-        atts[nbatts++] = attname;\n-        atts[nbatts++] = attvalue;\n-        atts[nbatts] = NULL;\n-        atts[nbatts + 1] = NULL;\n-    } else {\n-        if (attvalue != NULL)\n-        xmlFree(attvalue);\n-    }\n@@ -8614,7 +8616,7 @@\n-    GROW\n-    if ((RAW == '>') || (((RAW == '\/') && (NXT(1) == '>'))))\n-        break;\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"attributes construct error\\n\");\n-    }\n+        GROW\n+        if ((RAW == '>') || (((RAW == '\/') && (NXT(1) == '>'))))\n+            break;\n+        if (SKIP_BLANKS == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"attributes construct error\\n\");\n+        }\n@@ -8623,5 +8625,5 @@\n-        xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n-               \"xmlParseStartTag: problem parsing attributes\\n\");\n-        break;\n-    }\n-    SHRINK;\n+            xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n+                           \"xmlParseStartTag: problem parsing attributes\\n\");\n+            break;\n+        }\n+        SHRINK;\n@@ -8635,5 +8637,5 @@\n-    (!ctxt->disableSAX)) {\n-    if (nbatts > 0)\n-        ctxt->sax->startElement(ctxt->userData, name, atts);\n-    else\n-        ctxt->sax->startElement(ctxt->userData, name, NULL);\n+        (!ctxt->disableSAX)) {\n+        if (nbatts > 0)\n+            ctxt->sax->startElement(ctxt->userData, name, atts);\n+        else\n+            ctxt->sax->startElement(ctxt->userData, name, NULL);\n@@ -8645,2 +8647,2 @@\n-        if (atts[i] != NULL)\n-           xmlFree((xmlChar *) atts[i]);\n+            if (atts[i] != NULL)\n+               xmlFree((xmlChar *) atts[i]);\n@@ -8672,3 +8674,3 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_LTSLASH_REQUIRED,\n-               \"xmlParseEndTag: '<\/' not found\\n\");\n-    return;\n+        xmlFatalErrMsg(ctxt, XML_ERR_LTSLASH_REQUIRED,\n+                       \"xmlParseEndTag: '<\/' not found\\n\");\n+        return;\n@@ -8686,1 +8688,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);\n@@ -8688,1 +8690,1 @@\n-    NEXT1;\n+        NEXT1;\n@@ -8699,2 +8701,2 @@\n-             \"Opening and ending tag mismatch: %s line %d and %s\\n\",\n-                        ctxt->name, line, name);\n+                     \"Opening and ending tag mismatch: %s line %d and %s\\n\",\n+                                ctxt->name, line, name);\n@@ -8707,1 +8709,1 @@\n-    (!ctxt->disableSAX))\n+        (!ctxt->disableSAX))\n@@ -8735,3 +8737,3 @@\n- *                                  *\n- *            SAX 2 specific operations             *\n- *                                  *\n+ *                                                                      *\n+ *                    SAX 2 specific operations                         *\n+ *                                                                      *\n@@ -8757,4 +8759,4 @@\n-        if ((prefix == NULL) && (*ctxt->nsTab[i + 1] == 0))\n-            return(NULL);\n-        return(ctxt->nsTab[i + 1]);\n-    }\n+            if ((prefix == NULL) && (*ctxt->nsTab[i + 1] == 0))\n+                return(NULL);\n+            return(ctxt->nsTab[i + 1]);\n+        }\n@@ -8787,6 +8789,7 @@\n-        l = xmlParseName(ctxt);\n-        if (l != NULL) {\n-            xmlNsErr(ctxt, XML_NS_ERR_QNAME,\n-                 \"Failed to parse QName '%s'\\n\", l, NULL, NULL);\n-        *prefix = NULL;\n-        return(l);\n+            l = xmlParseName(ctxt);\n+            if (l != NULL) {\n+                xmlNsErr(ctxt, XML_NS_ERR_QNAME,\n+                         \"Failed to parse QName '%s'\\n\", l, NULL, NULL);\n+                *prefix = NULL;\n+                return(l);\n+            }\n@@ -8794,1 +8797,0 @@\n-    }\n@@ -8799,4 +8801,4 @@\n-    p = l;\n-    l = xmlParseNCName(ctxt);\n-    if (l == NULL) {\n-        xmlChar *tmp;\n+        p = l;\n+        l = xmlParseNCName(ctxt);\n+        if (l == NULL) {\n+            xmlChar *tmp;\n@@ -8807,3 +8809,3 @@\n-                 \"Failed to parse QName '%s:'\\n\", p, NULL, NULL);\n-        l = xmlParseNmtoken(ctxt);\n-        if (l == NULL) {\n+                     \"Failed to parse QName '%s:'\\n\", p, NULL, NULL);\n+            l = xmlParseNmtoken(ctxt);\n+            if (l == NULL) {\n@@ -8812,1 +8814,1 @@\n-        tmp = xmlBuildQName(BAD_CAST \"\", p, NULL, 0);\n+                tmp = xmlBuildQName(BAD_CAST \"\", p, NULL, 0);\n@@ -8814,2 +8816,7 @@\n-        tmp = xmlBuildQName(l, p, NULL, 0);\n-        xmlFree((char *)l);\n+                tmp = xmlBuildQName(l, p, NULL, 0);\n+                xmlFree((char *)l);\n+            }\n+            p = xmlDictLookup(ctxt->dict, tmp, -1);\n+            if (tmp != NULL) xmlFree(tmp);\n+            *prefix = NULL;\n+            return(p);\n@@ -8817,7 +8824,2 @@\n-        p = xmlDictLookup(ctxt->dict, tmp, -1);\n-        if (tmp != NULL) xmlFree(tmp);\n-        *prefix = NULL;\n-        return(p);\n-    }\n-    if (CUR == ':') {\n-        xmlChar *tmp;\n+        if (CUR == ':') {\n+            xmlChar *tmp;\n@@ -8826,10 +8828,10 @@\n-                 \"Failed to parse QName '%s:%s:'\\n\", p, l, NULL);\n-        NEXT;\n-        tmp = (xmlChar *) xmlParseName(ctxt);\n-        if (tmp != NULL) {\n-            tmp = xmlBuildQName(tmp, l, NULL, 0);\n-        l = xmlDictLookup(ctxt->dict, tmp, -1);\n-        if (tmp != NULL) xmlFree(tmp);\n-        *prefix = p;\n-        return(l);\n-        }\n+                     \"Failed to parse QName '%s:%s:'\\n\", p, l, NULL);\n+            NEXT;\n+            tmp = (xmlChar *) xmlParseName(ctxt);\n+            if (tmp != NULL) {\n+                tmp = xmlBuildQName(tmp, l, NULL, 0);\n+                l = xmlDictLookup(ctxt->dict, tmp, -1);\n+                if (tmp != NULL) xmlFree(tmp);\n+                *prefix = p;\n+                return(l);\n+            }\n@@ -8838,3 +8840,6 @@\n-        tmp = xmlBuildQName(BAD_CAST \"\", l, NULL, 0);\n-        l = xmlDictLookup(ctxt->dict, tmp, -1);\n-        if (tmp != NULL) xmlFree(tmp);\n+            tmp = xmlBuildQName(BAD_CAST \"\", l, NULL, 0);\n+            l = xmlDictLookup(ctxt->dict, tmp, -1);\n+            if (tmp != NULL) xmlFree(tmp);\n+            *prefix = p;\n+            return(l);\n+        }\n@@ -8842,3 +8847,0 @@\n-        return(l);\n-    }\n-    *prefix = p;\n@@ -8877,7 +8879,0 @@\n-    while (*in != 0 && *in == *cmp) {\n-    ++in;\n-    ++cmp;\n-    }\n-    if ((*cmp == 0) && (*in == ':')) {\n-        in++;\n-    cmp = name;\n@@ -8888,2 +8883,9 @@\n-    if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {\n-        \/* success *\/\n+    if ((*cmp == 0) && (*in == ':')) {\n+        in++;\n+        cmp = name;\n+        while (*in != 0 && *in == *cmp) {\n+            ++in;\n+            ++cmp;\n+        }\n+        if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {\n+            \/* success *\/\n@@ -8891,3 +8893,3 @@\n-        ctxt->input->cur = in;\n-        return((const xmlChar*) 1);\n-    }\n+            ctxt->input->cur = in;\n+            return((const xmlChar*) 1);\n+        }\n@@ -8900,1 +8902,1 @@\n-    return((const xmlChar*) 1);\n+        return((const xmlChar*) 1);\n@@ -8983,13 +8985,13 @@\n-     * Skip any leading spaces\n-     *\/\n-    while ((in < end) && (*in != limit) &&\n-           ((*in == 0x20) || (*in == 0x9) ||\n-            (*in == 0xA) || (*in == 0xD))) {\n-        if (*in == 0xA) {\n-            line++; col = 1;\n-        } else {\n-            col++;\n-        }\n-        in++;\n-        start = in;\n-        if (in >= end) {\n+         * Skip any leading spaces\n+         *\/\n+        while ((in < end) && (*in != limit) &&\n+               ((*in == 0x20) || (*in == 0x9) ||\n+                (*in == 0xA) || (*in == 0xD))) {\n+            if (*in == 0xA) {\n+                line++; col = 1;\n+            } else {\n+                col++;\n+            }\n+            in++;\n+            start = in;\n+            if (in >= end) {\n@@ -9003,0 +9005,1 @@\n+            }\n@@ -9004,6 +9007,5 @@\n-    }\n-    while ((in < end) && (*in != limit) && (*in >= 0x20) &&\n-           (*in <= 0x7f) && (*in != '&') && (*in != '<')) {\n-        col++;\n-        if ((*in++ == 0x20) && (*in == 0x20)) break;\n-        if (in >= end) {\n+        while ((in < end) && (*in != limit) && (*in >= 0x20) &&\n+               (*in <= 0x7f) && (*in != '&') && (*in != '<')) {\n+            col++;\n+            if ((*in++ == 0x20) && (*in == 0x20)) break;\n+            if (in >= end) {\n@@ -9017,0 +9019,1 @@\n+            }\n@@ -9018,18 +9021,17 @@\n-    }\n-    last = in;\n-    \/*\n-     * skip the trailing blanks\n-     *\/\n-    while ((last[-1] == 0x20) && (last > start)) last--;\n-    while ((in < end) && (*in != limit) &&\n-           ((*in == 0x20) || (*in == 0x9) ||\n-            (*in == 0xA) || (*in == 0xD))) {\n-        if (*in == 0xA) {\n-            line++, col = 1;\n-        } else {\n-            col++;\n-        }\n-        in++;\n-        if (in >= end) {\n-        const xmlChar *oldbase = ctxt->input->base;\n-        GROW;\n+        last = in;\n+        \/*\n+         * skip the trailing blanks\n+         *\/\n+        while ((last[-1] == 0x20) && (last > start)) last--;\n+        while ((in < end) && (*in != limit) &&\n+               ((*in == 0x20) || (*in == 0x9) ||\n+                (*in == 0xA) || (*in == 0xD))) {\n+            if (*in == 0xA) {\n+                line++, col = 1;\n+            } else {\n+                col++;\n+            }\n+            in++;\n+            if (in >= end) {\n+                const xmlChar *oldbase = ctxt->input->base;\n+                GROW;\n@@ -9038,7 +9040,7 @@\n-        if (oldbase != ctxt->input->base) {\n-            ptrdiff_t delta = ctxt->input->base - oldbase;\n-            start = start + delta;\n-            in = in + delta;\n-            last = last + delta;\n-        }\n-        end = ctxt->input->end;\n+                if (oldbase != ctxt->input->base) {\n+                    ptrdiff_t delta = ctxt->input->base - oldbase;\n+                    start = start + delta;\n+                    in = in + delta;\n+                    last = last + delta;\n+                }\n+                end = ctxt->input->end;\n@@ -9051,0 +9053,1 @@\n+            }\n@@ -9052,1 +9055,0 @@\n-    }\n@@ -9059,1 +9061,1 @@\n-    if (*in != limit) goto need_complex;\n+        if (*in != limit) goto need_complex;\n@@ -9061,5 +9063,5 @@\n-    while ((in < end) && (*in != limit) && (*in >= 0x20) &&\n-           (*in <= 0x7f) && (*in != '&') && (*in != '<')) {\n-        in++;\n-        col++;\n-        if (in >= end) {\n+        while ((in < end) && (*in != limit) && (*in >= 0x20) &&\n+               (*in <= 0x7f) && (*in != '&') && (*in != '<')) {\n+            in++;\n+            col++;\n+            if (in >= end) {\n@@ -9073,0 +9075,1 @@\n+            }\n@@ -9074,2 +9077,1 @@\n-    }\n-    last = in;\n+        last = in;\n@@ -9082,1 +9084,1 @@\n-    if (*in != limit) goto need_complex;\n+        if (*in != limit) goto need_complex;\n@@ -9157,9 +9159,9 @@\n-    if (normalize) {\n-        \/*\n-         * Sometimes a second normalisation pass for spaces is needed\n-         * but that only happens if charrefs or entities references\n-         * have been used in the attribute value, i.e. the attribute\n-         * value have been extracted in an allocated string already.\n-         *\/\n-        if (*alloc) {\n-            const xmlChar *val2;\n+        if (normalize) {\n+            \/*\n+             * Sometimes a second normalisation pass for spaces is needed\n+             * but that only happens if charrefs or entities references\n+             * have been used in the attribute value, i.e. the attribute\n+             * value have been extracted in an allocated string already.\n+             *\/\n+            if (*alloc) {\n+                const xmlChar *val2;\n@@ -9167,5 +9169,6 @@\n-            val2 = xmlAttrNormalizeSpace2(ctxt, val, len);\n-        if ((val2 != NULL) && (val2 != val)) {\n-            xmlFree(val);\n-            val = (xmlChar *) val2;\n-        }\n+                val2 = xmlAttrNormalizeSpace2(ctxt, val, len);\n+                if ((val2 != NULL) && (val2 != val)) {\n+                    xmlFree(val);\n+                    val = (xmlChar *) val2;\n+                }\n+            }\n@@ -9173,1 +9176,0 @@\n-    }\n@@ -9288,2 +9290,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-               \"StartTag: invalid element name\\n\");\n+        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                       \"StartTag: invalid element name\\n\");\n@@ -9303,8 +9305,8 @@\n-       ((RAW != '\/') || (NXT(1) != '>')) &&\n-       (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {\n-    const xmlChar *q = CUR_PTR;\n-    unsigned int cons = ctxt->input->consumed;\n-    int len = -1, alloc = 0;\n-\n-    attname = xmlParseAttribute2(ctxt, prefix, localname,\n-                                 &aprefix, &attvalue, &len, &alloc);\n+           ((RAW != '\/') || (NXT(1) != '>')) &&\n+           (IS_BYTE_CHAR(RAW))) && (ctxt->instate != XML_PARSER_EOF)) {\n+        const xmlChar *q = CUR_PTR;\n+        unsigned int cons = ctxt->input->consumed;\n+        int len = -1, alloc = 0;\n+\n+        attname = xmlParseAttribute2(ctxt, prefix, localname,\n+                                     &aprefix, &attvalue, &len, &alloc);\n@@ -9313,1 +9315,1 @@\n-    if (len < 0) len = xmlStrlen(attvalue);\n+        if (len < 0) len = xmlStrlen(attvalue);\n@@ -9477,1 +9479,1 @@\n-    GROW\n+        GROW\n@@ -9480,7 +9482,7 @@\n-    if ((RAW == '>') || (((RAW == '\/') && (NXT(1) == '>'))))\n-        break;\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"attributes construct error\\n\");\n-        break;\n-    }\n+        if ((RAW == '>') || (((RAW == '\/') && (NXT(1) == '>'))))\n+            break;\n+        if (SKIP_BLANKS == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"attributes construct error\\n\");\n+            break;\n+        }\n@@ -9489,4 +9491,4 @@\n-        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-             \"xmlParseStartTag: problem parsing attributes\\n\");\n-        break;\n-    }\n+            xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                 \"xmlParseStartTag: problem parsing attributes\\n\");\n+            break;\n+        }\n@@ -9523,5 +9525,5 @@\n-    defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);\n-    if (defaults != NULL) {\n-        for (i = 0;i < defaults->nbAttrs;i++) {\n-            attname = defaults->values[5 * i];\n-        aprefix = defaults->values[5 * i + 1];\n+        defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);\n+        if (defaults != NULL) {\n+            for (i = 0;i < defaults->nbAttrs;i++) {\n+                attname = defaults->values[5 * i];\n+                aprefix = defaults->values[5 * i + 1];\n@@ -9530,10 +9532,10 @@\n-         * special work for namespaces defaulted defs\n-         *\/\n-        if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {\n-            \/*\n-             * check that it's not a defined namespace\n-             *\/\n-            for (j = 1;j <= nbNs;j++)\n-                if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL)\n-                break;\n-                if (j <= nbNs) continue;\n+                 * special work for namespaces defaulted defs\n+                 *\/\n+                if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {\n+                    \/*\n+                     * check that it's not a defined namespace\n+                     *\/\n+                    for (j = 1;j <= nbNs;j++)\n+                        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == NULL)\n+                            break;\n+                    if (j <= nbNs) continue;\n@@ -9541,14 +9543,14 @@\n-            nsname = xmlGetNamespace(ctxt, NULL);\n-            if (nsname != defaults->values[5 * i + 2]) {\n-            if (nsPush(ctxt, NULL,\n-                       defaults->values[5 * i + 2]) > 0)\n-                nbNs++;\n-            }\n-        } else if (aprefix == ctxt->str_xmlns) {\n-            \/*\n-             * check that it's not a defined namespace\n-             *\/\n-            for (j = 1;j <= nbNs;j++)\n-                if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname)\n-                break;\n-                if (j <= nbNs) continue;\n+                    nsname = xmlGetNamespace(ctxt, NULL);\n+                    if (nsname != defaults->values[5 * i + 2]) {\n+                        if (nsPush(ctxt, NULL,\n+                                   defaults->values[5 * i + 2]) > 0)\n+                            nbNs++;\n+                    }\n+                } else if (aprefix == ctxt->str_xmlns) {\n+                    \/*\n+                     * check that it's not a defined namespace\n+                     *\/\n+                    for (j = 1;j <= nbNs;j++)\n+                        if (ctxt->nsTab[ctxt->nsNr - 2 * j] == attname)\n+                            break;\n+                    if (j <= nbNs) continue;\n@@ -9556,15 +9558,15 @@\n-            nsname = xmlGetNamespace(ctxt, attname);\n-            if (nsname != defaults->values[2]) {\n-            if (nsPush(ctxt, attname,\n-                       defaults->values[5 * i + 2]) > 0)\n-                nbNs++;\n-            }\n-        } else {\n-            \/*\n-             * check that it's not a defined attribute\n-             *\/\n-            for (j = 0;j < nbatts;j+=5) {\n-            if ((attname == atts[j]) && (aprefix == atts[j+1]))\n-                break;\n-            }\n-            if (j < nbatts) continue;\n+                    nsname = xmlGetNamespace(ctxt, attname);\n+                    if (nsname != defaults->values[2]) {\n+                        if (nsPush(ctxt, attname,\n+                                   defaults->values[5 * i + 2]) > 0)\n+                            nbNs++;\n+                    }\n+                } else {\n+                    \/*\n+                     * check that it's not a defined attribute\n+                     *\/\n+                    for (j = 0;j < nbatts;j+=5) {\n+                        if ((attname == atts[j]) && (aprefix == atts[j+1]))\n+                            break;\n+                    }\n+                    if (j < nbatts) continue;\n@@ -9572,2 +9574,2 @@\n-            if ((atts == NULL) || (nbatts + 5 > maxatts)) {\n-            if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {\n+                    if ((atts == NULL) || (nbatts + 5 > maxatts)) {\n+                        if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {\n@@ -9576,0 +9578,20 @@\n+                        }\n+                        maxatts = ctxt->maxatts;\n+                        atts = ctxt->atts;\n+                    }\n+                    atts[nbatts++] = attname;\n+                    atts[nbatts++] = aprefix;\n+                    if (aprefix == NULL)\n+                        atts[nbatts++] = NULL;\n+                    else\n+                        atts[nbatts++] = xmlGetNamespace(ctxt, aprefix);\n+                    atts[nbatts++] = defaults->values[5 * i + 2];\n+                    atts[nbatts++] = defaults->values[5 * i + 3];\n+                    if ((ctxt->standalone == 1) &&\n+                        (defaults->values[5 * i + 4] != NULL)) {\n+                        xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,\n+          \"standalone: attribute %s on %s defaulted from external subset\\n\",\n+                                         attname, localname);\n+                    }\n+                    nbdef++;\n+                }\n@@ -9577,19 +9599,0 @@\n-            maxatts = ctxt->maxatts;\n-            atts = ctxt->atts;\n-            }\n-            atts[nbatts++] = attname;\n-            atts[nbatts++] = aprefix;\n-            if (aprefix == NULL)\n-            atts[nbatts++] = NULL;\n-            else\n-                atts[nbatts++] = xmlGetNamespace(ctxt, aprefix);\n-            atts[nbatts++] = defaults->values[5 * i + 2];\n-            atts[nbatts++] = defaults->values[5 * i + 3];\n-            if ((ctxt->standalone == 1) &&\n-                (defaults->values[5 * i + 4] != NULL)) {\n-            xmlValidityError(ctxt, XML_DTD_STANDALONE_DEFAULTED,\n-      \"standalone: attribute %s on %s defaulted from external subset\\n\",\n-                                     attname, localname);\n-            }\n-            nbdef++;\n-        }\n@@ -9598,1 +9601,0 @@\n-    }\n@@ -9605,18 +9607,18 @@\n-    * The default namespace does not apply to attribute names.\n-    *\/\n-    if (atts[i + 1] != NULL) {\n-        nsname = xmlGetNamespace(ctxt, atts[i + 1]);\n-        if (nsname == NULL) {\n-        xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,\n-            \"Namespace prefix %s for %s on %s is not defined\\n\",\n-            atts[i + 1], atts[i], localname);\n-        }\n-        atts[i + 2] = nsname;\n-    } else\n-        nsname = NULL;\n-    \/*\n-     * [ WFC: Unique Att Spec ]\n-     * No attribute name may appear more than once in the same\n-     * start-tag or empty-element tag.\n-     * As extended by the Namespace in XML REC.\n-     *\/\n+        * The default namespace does not apply to attribute names.\n+        *\/\n+        if (atts[i + 1] != NULL) {\n+            nsname = xmlGetNamespace(ctxt, atts[i + 1]);\n+            if (nsname == NULL) {\n+                xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,\n+                    \"Namespace prefix %s for %s on %s is not defined\\n\",\n+                    atts[i + 1], atts[i], localname);\n+            }\n+            atts[i + 2] = nsname;\n+        } else\n+            nsname = NULL;\n+        \/*\n+         * [ WFC: Unique Att Spec ]\n+         * No attribute name may appear more than once in the same\n+         * start-tag or empty-element tag.\n+         * As extended by the Namespace in XML REC.\n+         *\/\n@@ -9624,11 +9626,12 @@\n-        if (atts[i] == atts[j]) {\n-            if (atts[i+1] == atts[j+1]) {\n-            xmlErrAttributeDup(ctxt, atts[i+1], atts[i]);\n-            break;\n-        }\n-        if ((nsname != NULL) && (atts[j + 2] == nsname)) {\n-            xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,\n-                 \"Namespaced Attribute %s in '%s' redefined\\n\",\n-                 atts[i], nsname, NULL);\n-            break;\n-        }\n+            if (atts[i] == atts[j]) {\n+                if (atts[i+1] == atts[j+1]) {\n+                    xmlErrAttributeDup(ctxt, atts[i+1], atts[i]);\n+                    break;\n+                }\n+                if ((nsname != NULL) && (atts[j + 2] == nsname)) {\n+                    xmlNsErr(ctxt, XML_NS_ERR_ATTRIBUTE_REDEFINED,\n+                             \"Namespaced Attribute %s in '%s' redefined\\n\",\n+                             atts[i], nsname, NULL);\n+                    break;\n+                }\n+            }\n@@ -9637,1 +9640,0 @@\n-    }\n@@ -9641,3 +9643,3 @@\n-    xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,\n-             \"Namespace prefix %s on %s is not defined\\n\",\n-         prefix, localname, NULL);\n+        xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,\n+                 \"Namespace prefix %s on %s is not defined\\n\",\n+                 prefix, localname, NULL);\n@@ -9652,8 +9654,8 @@\n-    (!ctxt->disableSAX)) {\n-    if (nbNs > 0)\n-        ctxt->sax->startElementNs(ctxt->userData, localname, prefix,\n-              nsname, nbNs, &ctxt->nsTab[ctxt->nsNr - 2 * nbNs],\n-              nbatts \/ 5, nbdef, atts);\n-    else\n-        ctxt->sax->startElementNs(ctxt->userData, localname, prefix,\n-                      nsname, 0, NULL, nbatts \/ 5, nbdef, atts);\n+        (!ctxt->disableSAX)) {\n+        if (nbNs > 0)\n+            ctxt->sax->startElementNs(ctxt->userData, localname, prefix,\n+                          nsname, nbNs, &ctxt->nsTab[ctxt->nsNr - 2 * nbNs],\n+                          nbatts \/ 5, nbdef, atts);\n+        else\n+            ctxt->sax->startElementNs(ctxt->userData, localname, prefix,\n+                          nsname, 0, NULL, nbatts \/ 5, nbdef, atts);\n@@ -9667,3 +9669,3 @@\n-    for (i = 3,j = 0; j < nratts;i += 5,j++)\n-        if ((ctxt->attallocs[j] != 0) && (atts[i] != NULL))\n-            xmlFree((xmlChar *) atts[i]);\n+        for (i = 3,j = 0; j < nratts;i += 5,j++)\n+            if ((ctxt->attallocs[j] != 0) && (atts[i] != NULL))\n+                xmlFree((xmlChar *) atts[i]);\n@@ -9696,2 +9698,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);\n-    return;\n+        xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);\n+        return;\n@@ -9714,1 +9716,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);\n@@ -9716,1 +9718,1 @@\n-    NEXT1;\n+        NEXT1;\n@@ -9727,2 +9729,2 @@\n-             \"Opening and ending tag mismatch: %s line %d and %s\\n\",\n-                        ctxt->name, tag->line, name);\n+                     \"Opening and ending tag mismatch: %s line %d and %s\\n\",\n+                                ctxt->name, tag->line, name);\n@@ -9735,2 +9737,2 @@\n-    (!ctxt->disableSAX))\n-    ctxt->sax->endElementNs(ctxt->userData, ctxt->name, tag->prefix,\n+        (!ctxt->disableSAX))\n+        ctxt->sax->endElementNs(ctxt->userData, ctxt->name, tag->prefix,\n@@ -9741,1 +9743,1 @@\n-    nsPop(ctxt, tag->nsNr);\n+        nsPop(ctxt, tag->nsNr);\n@@ -9770,1 +9772,1 @@\n-    SKIP(9);\n+        SKIP(9);\n@@ -9777,2 +9779,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);\n-    ctxt->instate = XML_PARSER_CONTENT;\n+        xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);\n+        ctxt->instate = XML_PARSER_CONTENT;\n@@ -9784,2 +9786,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);\n-    ctxt->instate = XML_PARSER_CONTENT;\n+        xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);\n+        ctxt->instate = XML_PARSER_CONTENT;\n@@ -9792,2 +9794,2 @@\n-    xmlErrMemory(ctxt, NULL);\n-    return;\n+        xmlErrMemory(ctxt, NULL);\n+        return;\n@@ -9797,2 +9799,2 @@\n-    if (len + 5 >= size) {\n-        xmlChar *tmp;\n+        if (len + 5 >= size) {\n+            xmlChar *tmp;\n@@ -9807,21 +9809,5 @@\n-        tmp = (xmlChar *) xmlRealloc(buf, size * 2 * sizeof(xmlChar));\n-        if (tmp == NULL) {\n-            xmlFree(buf);\n-        xmlErrMemory(ctxt, NULL);\n-        return;\n-        }\n-        buf = tmp;\n-        size *= 2;\n-    }\n-    COPY_BUF(rl,buf,len,r);\n-    r = s;\n-    rl = sl;\n-    s = cur;\n-    sl = l;\n-    count++;\n-    if (count > 50) {\n-        SHRINK;\n-        GROW;\n-            if (ctxt->instate == XML_PARSER_EOF) {\n-        xmlFree(buf);\n-        return;\n+            tmp = (xmlChar *) xmlRealloc(buf, size * 2 * sizeof(xmlChar));\n+            if (tmp == NULL) {\n+                xmlFree(buf);\n+                xmlErrMemory(ctxt, NULL);\n+                return;\n@@ -9829,4 +9815,20 @@\n-        count = 0;\n-    }\n-    NEXTL(l);\n-    cur = CUR_CHAR(l);\n+            buf = tmp;\n+            size *= 2;\n+        }\n+        COPY_BUF(rl,buf,len,r);\n+        r = s;\n+        rl = sl;\n+        s = cur;\n+        sl = l;\n+        count++;\n+        if (count > 50) {\n+            SHRINK;\n+            GROW;\n+            if (ctxt->instate == XML_PARSER_EOF) {\n+                xmlFree(buf);\n+                return;\n+            }\n+            count = 0;\n+        }\n+        NEXTL(l);\n+        cur = CUR_CHAR(l);\n@@ -9837,3 +9839,3 @@\n-    xmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,\n-                         \"CData section not finished\\n%.50s\\n\", buf);\n-    xmlFree(buf);\n+        xmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,\n+                             \"CData section not finished\\n%.50s\\n\", buf);\n+        xmlFree(buf);\n@@ -9848,4 +9850,4 @@\n-    if (ctxt->sax->cdataBlock != NULL)\n-        ctxt->sax->cdataBlock(ctxt->userData, buf, len);\n-    else if (ctxt->sax->characters != NULL)\n-        ctxt->sax->characters(ctxt->userData, buf, len);\n+        if (ctxt->sax->cdataBlock != NULL)\n+            ctxt->sax->cdataBlock(ctxt->userData, buf, len);\n+        else if (ctxt->sax->characters != NULL)\n+            ctxt->sax->characters(ctxt->userData, buf, len);\n@@ -9870,4 +9872,4 @@\n-       (ctxt->instate != XML_PARSER_EOF)) {\n-    const xmlChar *test = CUR_PTR;\n-    unsigned int cons = ctxt->input->consumed;\n-    const xmlChar *cur = ctxt->input->cur;\n+           (ctxt->instate != XML_PARSER_EOF)) {\n+        const xmlChar *test = CUR_PTR;\n+        unsigned int cons = ctxt->input->consumed;\n+        const xmlChar *cur = ctxt->input->cur;\n@@ -9875,6 +9877,6 @@\n-    \/*\n-     * First case : a Processing Instruction.\n-     *\/\n-    if ((*cur == '<') && (cur[1] == '?')) {\n-        xmlParsePI(ctxt);\n-    }\n+        \/*\n+         * First case : a Processing Instruction.\n+         *\/\n+        if ((*cur == '<') && (cur[1] == '?')) {\n+            xmlParsePI(ctxt);\n+        }\n@@ -9882,7 +9884,7 @@\n-    \/*\n-     * Second case : a CDSection\n-     *\/\n-    \/* 2.6.0 test was *cur not RAW *\/\n-    else if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {\n-        xmlParseCDSect(ctxt);\n-    }\n+        \/*\n+         * Second case : a CDSection\n+         *\/\n+        \/* 2.6.0 test was *cur not RAW *\/\n+        else if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {\n+            xmlParseCDSect(ctxt);\n+        }\n@@ -9890,8 +9892,8 @@\n-    \/*\n-     * Third case :  a comment\n-     *\/\n-    else if ((*cur == '<') && (NXT(1) == '!') &&\n-         (NXT(2) == '-') && (NXT(3) == '-')) {\n-        xmlParseComment(ctxt);\n-        ctxt->instate = XML_PARSER_CONTENT;\n-    }\n+        \/*\n+         * Third case :  a comment\n+         *\/\n+        else if ((*cur == '<') && (NXT(1) == '!') &&\n+                 (NXT(2) == '-') && (NXT(3) == '-')) {\n+            xmlParseComment(ctxt);\n+            ctxt->instate = XML_PARSER_CONTENT;\n+        }\n@@ -9899,4 +9901,4 @@\n-    \/*\n-     * Fourth case :  a sub-element.\n-     *\/\n-    else if (*cur == '<') {\n+        \/*\n+         * Fourth case :  a sub-element.\n+         *\/\n+        else if (*cur == '<') {\n@@ -9906,1 +9908,1 @@\n-            xmlParseElementEnd(ctxt);\n+                xmlParseElementEnd(ctxt);\n@@ -9908,1 +9910,1 @@\n-            xmlParseElementStart(ctxt);\n+                xmlParseElementStart(ctxt);\n@@ -9910,1 +9912,1 @@\n-    }\n+        }\n@@ -9912,4 +9914,4 @@\n-    \/*\n-     * Fifth case : a reference. If if has not been resolved,\n-     *    parsing returns it's Name, create the node\n-     *\/\n+        \/*\n+         * Fifth case : a reference. If if has not been resolved,\n+         *    parsing returns it's Name, create the node\n+         *\/\n@@ -9917,3 +9919,3 @@\n-    else if (*cur == '&') {\n-        xmlParseReference(ctxt);\n-    }\n+        else if (*cur == '&') {\n+            xmlParseReference(ctxt);\n+        }\n@@ -9921,6 +9923,6 @@\n-    \/*\n-     * Last case, text. Note that References are handled directly.\n-     *\/\n-    else {\n-        xmlParseCharData(ctxt, 0);\n-    }\n+        \/*\n+         * Last case, text. Note that References are handled directly.\n+         *\/\n+        else {\n+            xmlParseCharData(ctxt, 0);\n+        }\n@@ -9928,2 +9930,2 @@\n-    GROW;\n-    SHRINK;\n+        GROW;\n+        SHRINK;\n@@ -9931,4 +9933,4 @@\n-    if ((cons == ctxt->input->consumed) && (test == CUR_PTR)) {\n-        xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                    \"detected an error in element content\\n\");\n-        xmlHaltParser(ctxt);\n+        if ((cons == ctxt->input->consumed) && (test == CUR_PTR)) {\n+            xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                        \"detected an error in element content\\n\");\n+            xmlHaltParser(ctxt);\n@@ -9936,1 +9938,1 @@\n-    }\n+        }\n@@ -9960,1 +9962,1 @@\n-        name, line, NULL);\n+                name, line, NULL);\n@@ -9985,1 +9987,1 @@\n-    return;\n+        return;\n@@ -9992,1 +9994,1 @@\n-        name, line, NULL);\n+                name, line, NULL);\n@@ -10018,5 +10020,5 @@\n-    xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,\n-         \"Excessive depth in document: %d use XML_PARSE_HUGE option\\n\",\n-              xmlParserMaxDepth);\n-    xmlHaltParser(ctxt);\n-    return(-1);\n+        xmlFatalErrMsgInt(ctxt, XML_ERR_INTERNAL_ERROR,\n+                 \"Excessive depth in document: %d use XML_PARSE_HUGE option\\n\",\n+                          xmlParserMaxDepth);\n+        xmlHaltParser(ctxt);\n+        return(-1);\n@@ -10029,1 +10031,1 @@\n-    node_info.begin_line = ctxt->input->line;\n+        node_info.begin_line = ctxt->input->line;\n@@ -10033,1 +10035,1 @@\n-    spacePush(ctxt, -1);\n+        spacePush(ctxt, -1);\n@@ -10035,1 +10037,1 @@\n-    spacePush(ctxt, -1);\n+        spacePush(ctxt, -1);\n@@ -10037,1 +10039,1 @@\n-    spacePush(ctxt, *ctxt->space);\n+        spacePush(ctxt, *ctxt->space);\n@@ -10046,1 +10048,1 @@\n-    name = xmlParseStartTag(ctxt);\n+        name = xmlParseStartTag(ctxt);\n@@ -10049,1 +10051,1 @@\n-    return(-1);\n+        return(-1);\n@@ -10051,1 +10053,1 @@\n-    spacePop(ctxt);\n+        spacePop(ctxt);\n@@ -10073,4 +10075,4 @@\n-    if (ctxt->sax2) {\n-        if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&\n-        (!ctxt->disableSAX))\n-        ctxt->sax->endElementNs(ctxt->userData, name, prefix, URI);\n+        if (ctxt->sax2) {\n+            if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&\n+                (!ctxt->disableSAX))\n+                ctxt->sax->endElementNs(ctxt->userData, name, prefix, URI);\n@@ -10078,4 +10080,4 @@\n-    } else {\n-        if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL) &&\n-        (!ctxt->disableSAX))\n-        ctxt->sax->endElement(ctxt->userData, name);\n+        } else {\n+            if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL) &&\n+                (!ctxt->disableSAX))\n+                ctxt->sax->endElement(ctxt->userData, name);\n@@ -10083,13 +10085,13 @@\n-    }\n-    namePop(ctxt);\n-    spacePop(ctxt);\n-    if (nsNr != ctxt->nsNr)\n-        nsPop(ctxt, ctxt->nsNr - nsNr);\n-    if ( ret != NULL && ctxt->record_info ) {\n-       node_info.end_pos = ctxt->input->consumed +\n-                  (CUR_PTR - ctxt->input->base);\n-       node_info.end_line = ctxt->input->line;\n-       node_info.node = ret;\n-       xmlParserAddNodeInfo(ctxt, &node_info);\n-    }\n-    return(1);\n+        }\n+        namePop(ctxt);\n+        spacePop(ctxt);\n+        if (nsNr != ctxt->nsNr)\n+            nsPop(ctxt, ctxt->nsNr - nsNr);\n+        if ( ret != NULL && ctxt->record_info ) {\n+           node_info.end_pos = ctxt->input->consumed +\n+                              (CUR_PTR - ctxt->input->base);\n+           node_info.end_line = ctxt->input->line;\n+           node_info.node = ret;\n+           xmlParserAddNodeInfo(ctxt, &node_info);\n+        }\n+        return(1);\n@@ -10101,2 +10103,2 @@\n-             \"Couldn't find end of Start Tag %s line %d\\n\",\n-                        name, line, NULL);\n+                     \"Couldn't find end of Start Tag %s line %d\\n\",\n+                                name, line, NULL);\n@@ -10104,8 +10106,8 @@\n-    \/*\n-     * end of parsing of this node.\n-     *\/\n-    nodePop(ctxt);\n-    namePop(ctxt);\n-    spacePop(ctxt);\n-    if (nsNr != ctxt->nsNr)\n-        nsPop(ctxt, ctxt->nsNr - nsNr);\n+        \/*\n+         * end of parsing of this node.\n+         *\/\n+        nodePop(ctxt);\n+        namePop(ctxt);\n+        spacePop(ctxt);\n+        if (nsNr != ctxt->nsNr)\n+            nsPop(ctxt, ctxt->nsNr - nsNr);\n@@ -10113,11 +10115,11 @@\n-    \/*\n-     * Capture end position and add node\n-     *\/\n-    if ( ret != NULL && ctxt->record_info ) {\n-       node_info.end_pos = ctxt->input->consumed +\n-                  (CUR_PTR - ctxt->input->base);\n-       node_info.end_line = ctxt->input->line;\n-       node_info.node = ret;\n-       xmlParserAddNodeInfo(ctxt, &node_info);\n-    }\n-    return(-1);\n+        \/*\n+         * Capture end position and add node\n+         *\/\n+        if ( ret != NULL && ctxt->record_info ) {\n+           node_info.end_pos = ctxt->input->consumed +\n+                              (CUR_PTR - ctxt->input->base);\n+           node_info.end_line = ctxt->input->line;\n+           node_info.node = ret;\n+           xmlParserAddNodeInfo(ctxt, &node_info);\n+        }\n+        return(-1);\n@@ -10147,2 +10149,2 @@\n-    xmlParseEndTag2(ctxt, &ctxt->pushTab[ctxt->nameNr - 1]);\n-    namePop(ctxt);\n+        xmlParseEndTag2(ctxt, &ctxt->pushTab[ctxt->nameNr - 1]);\n+        namePop(ctxt);\n@@ -10152,1 +10154,1 @@\n-    xmlParseEndTag1(ctxt, 0);\n+        xmlParseEndTag1(ctxt, 0);\n@@ -10188,2 +10190,2 @@\n-    xmlErrMemory(ctxt, NULL);\n-    return(NULL);\n+        xmlErrMemory(ctxt, NULL);\n+        return(NULL);\n@@ -10193,2 +10195,2 @@\n-    xmlFree(buf);\n-    return(NULL);\n+        xmlFree(buf);\n+        return(NULL);\n@@ -10200,2 +10202,2 @@\n-    xmlFree(buf);\n-    return(NULL);\n+        xmlFree(buf);\n+        return(NULL);\n@@ -10207,2 +10209,2 @@\n-    if (len + 1 >= size) {\n-        xmlChar *tmp;\n+        if (len + 1 >= size) {\n+            xmlChar *tmp;\n@@ -10210,6 +10212,8 @@\n-        size *= 2;\n-        tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n-        if (tmp == NULL) {\n-            xmlFree(buf);\n-        xmlErrMemory(ctxt, NULL);\n-        return(NULL);\n+            size *= 2;\n+            tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n+            if (tmp == NULL) {\n+                xmlFree(buf);\n+                xmlErrMemory(ctxt, NULL);\n+                return(NULL);\n+            }\n+            buf = tmp;\n@@ -10217,5 +10221,3 @@\n-        buf = tmp;\n-    }\n-    buf[len++] = cur;\n-    NEXT;\n-    cur=CUR;\n+        buf[len++] = cur;\n+        NEXT;\n+        cur=CUR;\n@@ -10245,5 +10247,5 @@\n-    SKIP(7);\n-    SKIP_BLANKS;\n-    if (RAW != '=') {\n-        xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);\n-        return(NULL);\n+        SKIP(7);\n+        SKIP_BLANKS;\n+        if (RAW != '=') {\n+            xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);\n+            return(NULL);\n@@ -10251,3 +10253,0 @@\n-    NEXT;\n-    SKIP_BLANKS;\n-    if (RAW == '\"') {\n@@ -10255,4 +10254,2 @@\n-        version = xmlParseVersionNum(ctxt);\n-        if (RAW != '\"') {\n-        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n-        } else\n+        SKIP_BLANKS;\n+        if (RAW == '\"') {\n@@ -10260,6 +10257,6 @@\n-    } else if (RAW == '\\''){\n-        NEXT;\n-        version = xmlParseVersionNum(ctxt);\n-        if (RAW != '\\'') {\n-        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n-        } else\n+            version = xmlParseVersionNum(ctxt);\n+            if (RAW != '\"') {\n+                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n+            } else\n+                NEXT;\n+        } else if (RAW == '\\''){\n@@ -10267,3 +10264,8 @@\n-    } else {\n-        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);\n-    }\n+            version = xmlParseVersionNum(ctxt);\n+            if (RAW != '\\'') {\n+                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n+            } else\n+                NEXT;\n+        } else {\n+            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);\n+        }\n@@ -10294,20 +10296,2 @@\n-    buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n-    if (buf == NULL) {\n-        xmlErrMemory(ctxt, NULL);\n-        return(NULL);\n-    }\n-\n-    buf[len++] = cur;\n-    NEXT;\n-    cur = CUR;\n-    while (((cur >= 'a') && (cur <= 'z')) ||\n-           ((cur >= 'A') && (cur <= 'Z')) ||\n-           ((cur >= '0') && (cur <= '9')) ||\n-           (cur == '.') || (cur == '_') ||\n-           (cur == '-')) {\n-        if (len + 1 >= size) {\n-            xmlChar *tmp;\n-\n-        size *= 2;\n-        tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n-        if (tmp == NULL) {\n+        buf = (xmlChar *) xmlMallocAtomic(size * sizeof(xmlChar));\n+        if (buf == NULL) {\n@@ -10315,1 +10299,0 @@\n-            xmlFree(buf);\n@@ -10318,2 +10301,1 @@\n-        buf = tmp;\n-        }\n+\n@@ -10323,5 +10305,25 @@\n-        if (cur == 0) {\n-            SHRINK;\n-        GROW;\n-        cur = CUR;\n-        }\n+        while (((cur >= 'a') && (cur <= 'z')) ||\n+               ((cur >= 'A') && (cur <= 'Z')) ||\n+               ((cur >= '0') && (cur <= '9')) ||\n+               (cur == '.') || (cur == '_') ||\n+               (cur == '-')) {\n+            if (len + 1 >= size) {\n+                xmlChar *tmp;\n+\n+                size *= 2;\n+                tmp = (xmlChar *) xmlRealloc(buf, size * sizeof(xmlChar));\n+                if (tmp == NULL) {\n+                    xmlErrMemory(ctxt, NULL);\n+                    xmlFree(buf);\n+                    return(NULL);\n+                }\n+                buf = tmp;\n+            }\n+            buf[len++] = cur;\n+            NEXT;\n+            cur = CUR;\n+            if (cur == 0) {\n+                SHRINK;\n+                GROW;\n+                cur = CUR;\n+            }\n@@ -10329,1 +10331,1 @@\n-    buf[len] = 0;\n+        buf[len] = 0;\n@@ -10331,1 +10333,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_ENCODING_NAME, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ENCODING_NAME, NULL);\n@@ -10355,5 +10357,5 @@\n-    SKIP(8);\n-    SKIP_BLANKS;\n-    if (RAW != '=') {\n-        xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);\n-        return(NULL);\n+        SKIP(8);\n+        SKIP_BLANKS;\n+        if (RAW != '=') {\n+            xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);\n+            return(NULL);\n@@ -10361,3 +10363,0 @@\n-    NEXT;\n-    SKIP_BLANKS;\n-    if (RAW == '\"') {\n@@ -10365,6 +10364,2 @@\n-        encoding = xmlParseEncName(ctxt);\n-        if (RAW != '\"') {\n-        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n-        xmlFree((xmlChar *) encoding);\n-        return(NULL);\n-        } else\n+        SKIP_BLANKS;\n+        if (RAW == '\"') {\n@@ -10372,8 +10367,8 @@\n-    } else if (RAW == '\\''){\n-        NEXT;\n-        encoding = xmlParseEncName(ctxt);\n-        if (RAW != '\\'') {\n-        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n-        xmlFree((xmlChar *) encoding);\n-        return(NULL);\n-        } else\n+            encoding = xmlParseEncName(ctxt);\n+            if (RAW != '\"') {\n+                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n+                xmlFree((xmlChar *) encoding);\n+                return(NULL);\n+            } else\n+                NEXT;\n+        } else if (RAW == '\\''){\n@@ -10381,3 +10376,10 @@\n-    } else {\n-        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);\n-    }\n+            encoding = xmlParseEncName(ctxt);\n+            if (RAW != '\\'') {\n+                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n+                xmlFree((xmlChar *) encoding);\n+                return(NULL);\n+            } else\n+                NEXT;\n+        } else {\n+            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);\n+        }\n@@ -10389,1 +10391,1 @@\n-        xmlFree((xmlChar *) encoding);\n+            xmlFree((xmlChar *) encoding);\n@@ -10391,1 +10393,1 @@\n-    }\n+        }\n@@ -10393,7 +10395,0 @@\n-    \/*\n-     * UTF-16 encoding switch has already taken place at this stage,\n-     * more over the little-endian\/big-endian selection is already done\n-     *\/\n-        if ((encoding != NULL) &&\n-        ((!xmlStrcasecmp(encoding, BAD_CAST \"UTF-16\")) ||\n-         (!xmlStrcasecmp(encoding, BAD_CAST \"UTF16\")))) {\n@@ -10401,4 +10396,2 @@\n-         * If no encoding was passed to the parser, that we are\n-         * using UTF-16 and no decoder is present i.e. the\n-         * document is apparently UTF-8 compatible, then raise an\n-         * encoding mismatch fatal error\n+         * UTF-16 encoding switch has already taken place at this stage,\n+         * more over the little-endian\/big-endian selection is already done\n@@ -10406,5 +10399,18 @@\n-        if ((ctxt->encoding == NULL) &&\n-            (ctxt->input->buf != NULL) &&\n-            (ctxt->input->buf->encoder == NULL)) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_INVALID_ENCODING,\n-          \"Document labelled UTF-16 but has UTF-8 content\\n\");\n+        if ((encoding != NULL) &&\n+            ((!xmlStrcasecmp(encoding, BAD_CAST \"UTF-16\")) ||\n+             (!xmlStrcasecmp(encoding, BAD_CAST \"UTF16\")))) {\n+            \/*\n+             * If no encoding was passed to the parser, that we are\n+             * using UTF-16 and no decoder is present i.e. the\n+             * document is apparently UTF-8 compatible, then raise an\n+             * encoding mismatch fatal error\n+             *\/\n+            if ((ctxt->encoding == NULL) &&\n+                (ctxt->input->buf != NULL) &&\n+                (ctxt->input->buf->encoder == NULL)) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_INVALID_ENCODING,\n+                  \"Document labelled UTF-16 but has UTF-8 content\\n\");\n+            }\n+            if (ctxt->encoding != NULL)\n+                xmlFree((xmlChar *) ctxt->encoding);\n+            ctxt->encoding = encoding;\n@@ -10412,7 +10418,3 @@\n-        if (ctxt->encoding != NULL)\n-        xmlFree((xmlChar *) ctxt->encoding);\n-        ctxt->encoding = encoding;\n-    }\n-    \/*\n-     * UTF-8 encoding is handled natively\n-     *\/\n+        \/*\n+         * UTF-8 encoding is handled natively\n+         *\/\n@@ -10420,8 +10422,8 @@\n-        ((!xmlStrcasecmp(encoding, BAD_CAST \"UTF-8\")) ||\n-         (!xmlStrcasecmp(encoding, BAD_CAST \"UTF8\")))) {\n-        if (ctxt->encoding != NULL)\n-        xmlFree((xmlChar *) ctxt->encoding);\n-        ctxt->encoding = encoding;\n-    }\n-    else if (encoding != NULL) {\n-        xmlCharEncodingHandlerPtr handler;\n+            ((!xmlStrcasecmp(encoding, BAD_CAST \"UTF-8\")) ||\n+             (!xmlStrcasecmp(encoding, BAD_CAST \"UTF8\")))) {\n+            if (ctxt->encoding != NULL)\n+                xmlFree((xmlChar *) ctxt->encoding);\n+            ctxt->encoding = encoding;\n+        }\n+        else if (encoding != NULL) {\n+            xmlCharEncodingHandlerPtr handler;\n@@ -10429,3 +10431,3 @@\n-        if (ctxt->input->encoding != NULL)\n-        xmlFree((xmlChar *) ctxt->input->encoding);\n-        ctxt->input->encoding = encoding;\n+            if (ctxt->input->encoding != NULL)\n+                xmlFree((xmlChar *) ctxt->input->encoding);\n+            ctxt->input->encoding = encoding;\n@@ -10434,10 +10436,11 @@\n-        if (handler != NULL) {\n-        if (xmlSwitchToEncoding(ctxt, handler) < 0) {\n-            \/* failed to convert *\/\n-            ctxt->errNo = XML_ERR_UNSUPPORTED_ENCODING;\n-            return(NULL);\n-        }\n-        } else {\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n-            \"Unsupported encoding %s\\n\", encoding);\n-        return(NULL);\n+            if (handler != NULL) {\n+                if (xmlSwitchToEncoding(ctxt, handler) < 0) {\n+                    \/* failed to convert *\/\n+                    ctxt->errNo = XML_ERR_UNSUPPORTED_ENCODING;\n+                    return(NULL);\n+                }\n+            } else {\n+                xmlFatalErrMsgStr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n+                        \"Unsupported encoding %s\\n\", encoding);\n+                return(NULL);\n+            }\n@@ -10446,1 +10449,0 @@\n-    }\n@@ -10477,2 +10479,2 @@\n- *    (A standalone value of -2 means that the XML declaration was found,\n- *     but no value was specified for the standalone attribute).\n+ *        (A standalone value of -2 means that the XML declaration was found,\n+ *         but no value was specified for the standalone attribute).\n@@ -10487,1 +10489,1 @@\n-    SKIP(10);\n+        SKIP(10);\n@@ -10489,3 +10491,3 @@\n-    if (RAW != '=') {\n-        xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);\n-        return(standalone);\n+        if (RAW != '=') {\n+            xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);\n+            return(standalone);\n@@ -10493,3 +10495,0 @@\n-    NEXT;\n-    SKIP_BLANKS;\n-        if (RAW == '\\''){\n@@ -10497,2 +10496,5 @@\n-        if ((RAW == 'n') && (NXT(1) == 'o')) {\n-            standalone = 0;\n+        SKIP_BLANKS;\n+        if (RAW == '\\''){\n+            NEXT;\n+            if ((RAW == 'n') && (NXT(1) == 'o')) {\n+                standalone = 0;\n@@ -10500,4 +10502,4 @@\n-        } else if ((RAW == 'y') && (NXT(1) == 'e') &&\n-                   (NXT(2) == 's')) {\n-            standalone = 1;\n-        SKIP(3);\n+            } else if ((RAW == 'y') && (NXT(1) == 'e') &&\n+                       (NXT(2) == 's')) {\n+                standalone = 1;\n+                SKIP(3);\n@@ -10505,5 +10507,7 @@\n-        xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);\n-        }\n-        if (RAW != '\\'') {\n-        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n-        } else\n+                xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);\n+            }\n+            if (RAW != '\\'') {\n+                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n+            } else\n+                NEXT;\n+        } else if (RAW == '\"'){\n@@ -10511,8 +10515,6 @@\n-    } else if (RAW == '\"'){\n-        NEXT;\n-        if ((RAW == 'n') && (NXT(1) == 'o')) {\n-            standalone = 0;\n-        SKIP(2);\n-        } else if ((RAW == 'y') && (NXT(1) == 'e') &&\n-                   (NXT(2) == 's')) {\n-            standalone = 1;\n+            if ((RAW == 'n') && (NXT(1) == 'o')) {\n+                standalone = 0;\n+                SKIP(2);\n+            } else if ((RAW == 'y') && (NXT(1) == 'e') &&\n+                       (NXT(2) == 's')) {\n+                standalone = 1;\n@@ -10521,8 +10523,8 @@\n-        xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);\n-        }\n-        if (RAW != '\"') {\n-        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n-        } else\n-            NEXT;\n-    } else {\n-        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);\n+                xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);\n+            }\n+            if (RAW != '\"') {\n+                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n+            } else\n+                NEXT;\n+        } else {\n+            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);\n@@ -10560,2 +10562,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                   \"Blank needed after '<?xml'\\n\");\n+        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                       \"Blank needed after '<?xml'\\n\");\n@@ -10570,1 +10572,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_VERSION_MISSING, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_VERSION_MISSING, NULL);\n@@ -10572,18 +10574,19 @@\n-    if (!xmlStrEqual(version, (const xmlChar *) XML_DEFAULT_VERSION)) {\n-        \/*\n-         * Changed here for XML-1.0 5th edition\n-         *\/\n-        if (ctxt->options & XML_PARSE_OLD10) {\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,\n-                      \"Unsupported version '%s'\\n\",\n-                      version);\n-        } else {\n-            if ((version[0] == '1') && ((version[1] == '.'))) {\n-            xmlWarningMsg(ctxt, XML_WAR_UNKNOWN_VERSION,\n-                          \"Unsupported version '%s'\\n\",\n-                  version, NULL);\n-        } else {\n-            xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,\n-                      \"Unsupported version '%s'\\n\",\n-                      version);\n-        }\n+        if (!xmlStrEqual(version, (const xmlChar *) XML_DEFAULT_VERSION)) {\n+            \/*\n+             * Changed here for XML-1.0 5th edition\n+             *\/\n+            if (ctxt->options & XML_PARSE_OLD10) {\n+                xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,\n+                                  \"Unsupported version '%s'\\n\",\n+                                  version);\n+            } else {\n+                if ((version[0] == '1') && ((version[1] == '.'))) {\n+                    xmlWarningMsg(ctxt, XML_WAR_UNKNOWN_VERSION,\n+                                  \"Unsupported version '%s'\\n\",\n+                                  version, NULL);\n+                } else {\n+                    xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,\n+                                      \"Unsupported version '%s'\\n\",\n+                                      version);\n+                }\n+            }\n@@ -10591,4 +10594,3 @@\n-    }\n-    if (ctxt->version != NULL)\n-        xmlFree((void *) ctxt->version);\n-    ctxt->version = version;\n+        if (ctxt->version != NULL)\n+            xmlFree((void *) ctxt->version);\n+        ctxt->version = version;\n@@ -10602,4 +10604,4 @@\n-        SKIP(2);\n-        return;\n-    }\n-    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, \"Blank needed here\\n\");\n+            SKIP(2);\n+            return;\n+        }\n+        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, \"Blank needed here\\n\");\n@@ -10610,3 +10612,3 @@\n-    \/*\n-     * The XML REC instructs us to stop parsing right here\n-     *\/\n+        \/*\n+         * The XML REC instructs us to stop parsing right here\n+         *\/\n@@ -10621,4 +10623,4 @@\n-        SKIP(2);\n-        return;\n-    }\n-    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, \"Blank needed here\\n\");\n+            SKIP(2);\n+            return;\n+        }\n+        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, \"Blank needed here\\n\");\n@@ -10640,2 +10642,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);\n-    NEXT;\n+        xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);\n+        NEXT;\n@@ -10643,3 +10645,3 @@\n-    xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);\n-    MOVETO_ENDTAG(CUR_PTR);\n-    NEXT;\n+        xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);\n+        MOVETO_ENDTAG(CUR_PTR);\n+        NEXT;\n@@ -10660,4 +10662,3 @@\n-    while ((ctxt->instate != XML_PARSER_EOF) &&\n-           (((RAW == '<') && (NXT(1) == '?')) ||\n-            (CMP4(CUR_PTR, '<', '!', '-', '-')) ||\n-            IS_BLANK_CH(CUR))) {\n+    while (ctxt->instate != XML_PARSER_EOF) {\n+        SKIP_BLANKS;\n+        GROW;\n@@ -10665,5 +10666,6 @@\n-        xmlParsePI(ctxt);\n-    } else if (IS_BLANK_CH(CUR)) {\n-        NEXT;\n-    } else\n-        xmlParseComment(ctxt);\n+            xmlParsePI(ctxt);\n+        } else if (CMP4(CUR_PTR, '<', '!', '-', '-')) {\n+            xmlParseComment(ctxt);\n+        } else {\n+            break;\n+        }\n@@ -10711,1 +10713,1 @@\n-    return(-1);\n+        return(-1);\n@@ -10715,13 +10717,13 @@\n-    \/*\n-     * Get the 4 first bytes and decode the charset\n-     * if enc != XML_CHAR_ENCODING_NONE\n-     * plug some encoding conversion routines.\n-     *\/\n-    start[0] = RAW;\n-    start[1] = NXT(1);\n-    start[2] = NXT(2);\n-    start[3] = NXT(3);\n-    enc = xmlDetectCharEncoding(&start[0], 4);\n-    if (enc != XML_CHAR_ENCODING_NONE) {\n-        xmlSwitchEncoding(ctxt, enc);\n-    }\n+        \/*\n+         * Get the 4 first bytes and decode the charset\n+         * if enc != XML_CHAR_ENCODING_NONE\n+         * plug some encoding conversion routines.\n+         *\/\n+        start[0] = RAW;\n+        start[1] = NXT(1);\n+        start[2] = NXT(2);\n+        start[3] = NXT(3);\n+        enc = xmlDetectCharEncoding(&start[0], 4);\n+        if (enc != XML_CHAR_ENCODING_NONE) {\n+            xmlSwitchEncoding(ctxt, enc);\n+        }\n@@ -10732,2 +10734,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n-    return(-1);\n+        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n+        return(-1);\n@@ -10747,6 +10749,0 @@\n-    \/*\n-     * Note that we will switch encoding on the fly.\n-     *\/\n-    xmlParseXMLDecl(ctxt);\n-    if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||\n-        (ctxt->instate == XML_PARSER_EOF)) {\n@@ -10754,1 +10750,1 @@\n-         * The XML REC instructs us to stop parsing right here\n+         * Note that we will switch encoding on the fly.\n@@ -10756,4 +10752,10 @@\n-        return(-1);\n-    }\n-    ctxt->standalone = ctxt->input->standalone;\n-    SKIP_BLANKS;\n+        xmlParseXMLDecl(ctxt);\n+        if ((ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) ||\n+            (ctxt->instate == XML_PARSER_EOF)) {\n+            \/*\n+             * The XML REC instructs us to stop parsing right here\n+             *\/\n+            return(-1);\n+        }\n+        ctxt->standalone = ctxt->input->standalone;\n+        SKIP_BLANKS;\n@@ -10761,1 +10763,1 @@\n-    ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n+        ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n@@ -10766,1 +10768,1 @@\n-    return(-1);\n+        return(-1);\n@@ -10769,1 +10771,1 @@\n-    ctxt->myDoc->compression = ctxt->input->buf->compressed;\n+        ctxt->myDoc->compression = ctxt->input->buf->compressed;\n@@ -10775,1 +10777,0 @@\n-    GROW;\n@@ -10785,8 +10786,8 @@\n-    ctxt->inSubset = 1;\n-    xmlParseDocTypeDecl(ctxt);\n-    if (RAW == '[') {\n-        ctxt->instate = XML_PARSER_DTD;\n-        xmlParseInternalSubset(ctxt);\n-        if (ctxt->instate == XML_PARSER_EOF)\n-        return(-1);\n-    }\n+        ctxt->inSubset = 1;\n+        xmlParseDocTypeDecl(ctxt);\n+        if (RAW == '[') {\n+            ctxt->instate = XML_PARSER_DTD;\n+            xmlParseInternalSubset(ctxt);\n+            if (ctxt->instate == XML_PARSER_EOF)\n+                return(-1);\n+        }\n@@ -10794,11 +10795,11 @@\n-    \/*\n-     * Create and update the external subset.\n-     *\/\n-    ctxt->inSubset = 2;\n-    if ((ctxt->sax != NULL) && (ctxt->sax->externalSubset != NULL) &&\n-        (!ctxt->disableSAX))\n-        ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\n-                                  ctxt->extSubSystem, ctxt->extSubURI);\n-    if (ctxt->instate == XML_PARSER_EOF)\n-        return(-1);\n-    ctxt->inSubset = 0;\n+        \/*\n+         * Create and update the external subset.\n+         *\/\n+        ctxt->inSubset = 2;\n+        if ((ctxt->sax != NULL) && (ctxt->sax->externalSubset != NULL) &&\n+            (!ctxt->disableSAX))\n+            ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\n+                                      ctxt->extSubSystem, ctxt->extSubURI);\n+        if (ctxt->instate == XML_PARSER_EOF)\n+            return(-1);\n+        ctxt->inSubset = 0;\n@@ -10808,2 +10809,2 @@\n-    ctxt->instate = XML_PARSER_PROLOG;\n-    xmlParseMisc(ctxt);\n+        ctxt->instate = XML_PARSER_PROLOG;\n+        xmlParseMisc(ctxt);\n@@ -10817,2 +10818,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n-               \"Start tag expected, '<' not found\\n\");\n+        xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n+                       \"Start tag expected, '<' not found\\n\");\n@@ -10820,3 +10821,3 @@\n-    ctxt->instate = XML_PARSER_CONTENT;\n-    xmlParseElement(ctxt);\n-    ctxt->instate = XML_PARSER_EPILOG;\n+        ctxt->instate = XML_PARSER_CONTENT;\n+        xmlParseElement(ctxt);\n+        ctxt->instate = XML_PARSER_EPILOG;\n@@ -10825,4 +10826,4 @@\n-    \/*\n-     * The Misc part at the end\n-     *\/\n-    xmlParseMisc(ctxt);\n+        \/*\n+         * The Misc part at the end\n+         *\/\n+        xmlParseMisc(ctxt);\n@@ -10830,4 +10831,4 @@\n-    if (RAW != 0) {\n-        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n-    }\n-    ctxt->instate = XML_PARSER_EOF;\n+        if (RAW != 0) {\n+            xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n+        }\n+        ctxt->instate = XML_PARSER_EOF;\n@@ -10846,3 +10847,3 @@\n-    (xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {\n-    xmlFreeDoc(ctxt->myDoc);\n-    ctxt->myDoc = NULL;\n+        (xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {\n+        xmlFreeDoc(ctxt->myDoc);\n+        ctxt->myDoc = NULL;\n@@ -10853,6 +10854,6 @@\n-    if (ctxt->valid)\n-        ctxt->myDoc->properties |= XML_DOC_DTDVALID;\n-    if (ctxt->nsWellFormed)\n-        ctxt->myDoc->properties |= XML_DOC_NSVALID;\n-    if (ctxt->options & XML_PARSE_OLD10)\n-        ctxt->myDoc->properties |= XML_DOC_OLD10;\n+        if (ctxt->valid)\n+            ctxt->myDoc->properties |= XML_DOC_DTDVALID;\n+        if (ctxt->nsWellFormed)\n+            ctxt->myDoc->properties |= XML_DOC_NSVALID;\n+        if (ctxt->options & XML_PARSE_OLD10)\n+            ctxt->myDoc->properties |= XML_DOC_OLD10;\n@@ -10861,2 +10862,2 @@\n-    ctxt->valid = 0;\n-    return(-1);\n+        ctxt->valid = 0;\n+        return(-1);\n@@ -10907,8 +10908,8 @@\n-    start[0] = RAW;\n-    start[1] = NXT(1);\n-    start[2] = NXT(2);\n-    start[3] = NXT(3);\n-    enc = xmlDetectCharEncoding(start, 4);\n-    if (enc != XML_CHAR_ENCODING_NONE) {\n-        xmlSwitchEncoding(ctxt, enc);\n-    }\n+        start[0] = RAW;\n+        start[1] = NXT(1);\n+        start[2] = NXT(2);\n+        start[3] = NXT(3);\n+        enc = xmlDetectCharEncoding(start, 4);\n+        if (enc != XML_CHAR_ENCODING_NONE) {\n+            xmlSwitchEncoding(ctxt, enc);\n+        }\n@@ -10919,1 +10920,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n@@ -10928,5 +10929,0 @@\n-    \/*\n-     * Note that we will switch encoding on the fly.\n-     *\/\n-    xmlParseXMLDecl(ctxt);\n-    if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n@@ -10934,1 +10930,1 @@\n-         * The XML REC instructs us to stop parsing right here\n+         * Note that we will switch encoding on the fly.\n@@ -10936,3 +10932,8 @@\n-        return(-1);\n-    }\n-    SKIP_BLANKS;\n+        xmlParseXMLDecl(ctxt);\n+        if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n+            \/*\n+             * The XML REC instructs us to stop parsing right here\n+             *\/\n+            return(-1);\n+        }\n+        SKIP_BLANKS;\n@@ -10940,1 +10941,1 @@\n-    ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n+        ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n@@ -10945,1 +10946,1 @@\n-    return(-1);\n+        return(-1);\n@@ -10957,1 +10958,1 @@\n-    return(-1);\n+        return(-1);\n@@ -10960,1 +10961,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n@@ -10962,1 +10963,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n@@ -10977,3 +10978,3 @@\n- *                                  *\n- *      Progressive parsing interfaces              *\n- *                                  *\n+ *                                                                      *\n+ *              Progressive parsing interfaces                          *\n+ *                                                                      *\n@@ -11012,2 +11013,2 @@\n-    buf = in->base;\n-    len = in->length;\n+        buf = in->base;\n+        len = in->length;\n@@ -11015,2 +11016,2 @@\n-    buf = xmlBufContent(in->buf->buffer);\n-    len = xmlBufUse(in->buf->buffer);\n+        buf = xmlBufContent(in->buf->buffer);\n+        len = xmlBufUse(in->buf->buffer);\n@@ -11023,7 +11024,7 @@\n-        if (third != 0) {\n-        if ((buf[base + 1] != next) ||\n-            (buf[base + 2] != third)) continue;\n-        } else if (next != 0) {\n-        if (buf[base + 1] != next) continue;\n-        }\n-        ctxt->checkIndex = 0;\n+            if (third != 0) {\n+                if ((buf[base + 1] != next) ||\n+                    (buf[base + 2] != third)) continue;\n+            } else if (next != 0) {\n+                if (buf[base + 1] != next) continue;\n+            }\n+            ctxt->checkIndex = 0;\n@@ -11031,12 +11032,12 @@\n-        if (next == 0)\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: lookup '%c' found at %d\\n\",\n-            first, base);\n-        else if (third == 0)\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: lookup '%c%c' found at %d\\n\",\n-            first, next, base);\n-        else\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: lookup '%c%c%c' found at %d\\n\",\n-            first, next, third, base);\n+            if (next == 0)\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: lookup '%c' found at %d\\n\",\n+                        first, base);\n+            else if (third == 0)\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: lookup '%c%c' found at %d\\n\",\n+                        first, next, base);\n+            else\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: lookup '%c%c%c' found at %d\\n\",\n+                        first, next, third, base);\n@@ -11044,2 +11045,2 @@\n-        return(base - (in->cur - in->base));\n-    }\n+            return(base - (in->cur - in->base));\n+        }\n@@ -11050,2 +11051,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"PP: lookup '%c' failed\\n\", first);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"PP: lookup '%c' failed\\n\", first);\n@@ -11053,2 +11054,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"PP: lookup '%c%c' failed\\n\", first, next);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"PP: lookup '%c%c' failed\\n\", first, next);\n@@ -11056,2 +11057,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"PP: lookup '%c%c%c' failed\\n\", first, next, third);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"PP: lookup '%c%c%c' failed\\n\", first, next, third);\n@@ -11076,3 +11077,3 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"Internal error: xmlParseGetLasts\\n\");\n-    return;\n+        xmlGenericError(xmlGenericErrorContext,\n+                    \"Internal error: xmlParseGetLasts\\n\");\n+        return;\n@@ -11082,24 +11083,0 @@\n-    tmp--;\n-    while ((tmp >= ctxt->input->base) && (*tmp != '<')) tmp--;\n-    if (tmp < ctxt->input->base) {\n-        *lastlt = NULL;\n-        *lastgt = NULL;\n-    } else {\n-        *lastlt = tmp;\n-        tmp++;\n-        while ((tmp < ctxt->input->end) && (*tmp != '>')) {\n-            if (*tmp == '\\'') {\n-            tmp++;\n-            while ((tmp < ctxt->input->end) && (*tmp != '\\'')) tmp++;\n-            if (tmp < ctxt->input->end) tmp++;\n-        } else if (*tmp == '\"') {\n-            tmp++;\n-            while ((tmp < ctxt->input->end) && (*tmp != '\"')) tmp++;\n-            if (tmp < ctxt->input->end) tmp++;\n-        } else\n-            tmp++;\n-        }\n-        if (tmp < ctxt->input->end)\n-            *lastgt = tmp;\n-        else {\n-            tmp = *lastlt;\n@@ -11107,4 +11084,3 @@\n-        while ((tmp >= ctxt->input->base) && (*tmp != '>')) tmp--;\n-        if (tmp >= ctxt->input->base)\n-            *lastgt = tmp;\n-        else\n+        while ((tmp >= ctxt->input->base) && (*tmp != '<')) tmp--;\n+        if (tmp < ctxt->input->base) {\n+            *lastlt = NULL;\n@@ -11112,0 +11088,26 @@\n+        } else {\n+            *lastlt = tmp;\n+            tmp++;\n+            while ((tmp < ctxt->input->end) && (*tmp != '>')) {\n+                if (*tmp == '\\'') {\n+                    tmp++;\n+                    while ((tmp < ctxt->input->end) && (*tmp != '\\'')) tmp++;\n+                    if (tmp < ctxt->input->end) tmp++;\n+                } else if (*tmp == '\"') {\n+                    tmp++;\n+                    while ((tmp < ctxt->input->end) && (*tmp != '\"')) tmp++;\n+                    if (tmp < ctxt->input->end) tmp++;\n+                } else\n+                    tmp++;\n+            }\n+            if (tmp < ctxt->input->end)\n+                *lastgt = tmp;\n+            else {\n+                tmp = *lastlt;\n+                tmp--;\n+                while ((tmp >= ctxt->input->base) && (*tmp != '>')) tmp--;\n+                if (tmp >= ctxt->input->base)\n+                    *lastgt = tmp;\n+                else\n+                    *lastgt = NULL;\n+            }\n@@ -11113,1 +11115,0 @@\n-    }\n@@ -11116,1 +11117,1 @@\n-    *lastgt = NULL;\n+        *lastgt = NULL;\n@@ -11141,38 +11142,41 @@\n-        if ((c & 0x80) == 0x00) {   \/* 1-byte code, starts with 10 *\/\n-        if (c >= 0x20)\n-        ix++;\n-        else if ((c == 0xA) || (c == 0xD) || (c == 0x9))\n-            ix++;\n-        else\n-            return(-ix);\n-    } else if ((c & 0xe0) == 0xc0) {\/* 2-byte code, starts with 110 *\/\n-        if (ix + 2 > len) return(complete ? -ix : ix);\n-        if ((utf[ix+1] & 0xc0 ) != 0x80)\n-            return(-ix);\n-        codepoint = (utf[ix] & 0x1f) << 6;\n-        codepoint |= utf[ix+1] & 0x3f;\n-        if (!xmlIsCharQ(codepoint))\n-            return(-ix);\n-        ix += 2;\n-    } else if ((c & 0xf0) == 0xe0) {\/* 3-byte code, starts with 1110 *\/\n-        if (ix + 3 > len) return(complete ? -ix : ix);\n-        if (((utf[ix+1] & 0xc0) != 0x80) ||\n-            ((utf[ix+2] & 0xc0) != 0x80))\n-            return(-ix);\n-        codepoint = (utf[ix] & 0xf) << 12;\n-        codepoint |= (utf[ix+1] & 0x3f) << 6;\n-        codepoint |= utf[ix+2] & 0x3f;\n-        if (!xmlIsCharQ(codepoint))\n-            return(-ix);\n-        ix += 3;\n-    } else if ((c & 0xf8) == 0xf0) {\/* 4-byte code, starts with 11110 *\/\n-        if (ix + 4 > len) return(complete ? -ix : ix);\n-        if (((utf[ix+1] & 0xc0) != 0x80) ||\n-            ((utf[ix+2] & 0xc0) != 0x80) ||\n-        ((utf[ix+3] & 0xc0) != 0x80))\n-            return(-ix);\n-        codepoint = (utf[ix] & 0x7) << 18;\n-        codepoint |= (utf[ix+1] & 0x3f) << 12;\n-        codepoint |= (utf[ix+2] & 0x3f) << 6;\n-        codepoint |= utf[ix+3] & 0x3f;\n-        if (!xmlIsCharQ(codepoint))\n+        if ((c & 0x80) == 0x00) {       \/* 1-byte code, starts with 10 *\/\n+            if (c >= 0x20)\n+                ix++;\n+            else if ((c == 0xA) || (c == 0xD) || (c == 0x9))\n+                ix++;\n+            else\n+                return(-ix);\n+        } else if ((c & 0xe0) == 0xc0) {\/* 2-byte code, starts with 110 *\/\n+            if (ix + 2 > len) return(complete ? -ix : ix);\n+            if ((utf[ix+1] & 0xc0 ) != 0x80)\n+                return(-ix);\n+            codepoint = (utf[ix] & 0x1f) << 6;\n+            codepoint |= utf[ix+1] & 0x3f;\n+            if (!xmlIsCharQ(codepoint))\n+                return(-ix);\n+            ix += 2;\n+        } else if ((c & 0xf0) == 0xe0) {\/* 3-byte code, starts with 1110 *\/\n+            if (ix + 3 > len) return(complete ? -ix : ix);\n+            if (((utf[ix+1] & 0xc0) != 0x80) ||\n+                ((utf[ix+2] & 0xc0) != 0x80))\n+                    return(-ix);\n+            codepoint = (utf[ix] & 0xf) << 12;\n+            codepoint |= (utf[ix+1] & 0x3f) << 6;\n+            codepoint |= utf[ix+2] & 0x3f;\n+            if (!xmlIsCharQ(codepoint))\n+                return(-ix);\n+            ix += 3;\n+        } else if ((c & 0xf8) == 0xf0) {\/* 4-byte code, starts with 11110 *\/\n+            if (ix + 4 > len) return(complete ? -ix : ix);\n+            if (((utf[ix+1] & 0xc0) != 0x80) ||\n+                ((utf[ix+2] & 0xc0) != 0x80) ||\n+                ((utf[ix+3] & 0xc0) != 0x80))\n+                    return(-ix);\n+            codepoint = (utf[ix] & 0x7) << 18;\n+            codepoint |= (utf[ix+1] & 0x3f) << 12;\n+            codepoint |= (utf[ix+2] & 0x3f) << 6;\n+            codepoint |= utf[ix+3] & 0x3f;\n+            if (!xmlIsCharQ(codepoint))\n+                return(-ix);\n+            ix += 4;\n+        } else                          \/* unknown encoding *\/\n@@ -11180,3 +11184,0 @@\n-        ix += 4;\n-    } else              \/* unknown encoding *\/\n-        return(-ix);\n@@ -11208,45 +11209,45 @@\n-    case XML_PARSER_EOF:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: try EOF\\n\"); break;\n-    case XML_PARSER_START:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: try START\\n\"); break;\n-    case XML_PARSER_MISC:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: try MISC\\n\");break;\n-    case XML_PARSER_COMMENT:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: try COMMENT\\n\");break;\n-    case XML_PARSER_PROLOG:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: try PROLOG\\n\");break;\n-    case XML_PARSER_START_TAG:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: try START_TAG\\n\");break;\n-    case XML_PARSER_CONTENT:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: try CONTENT\\n\");break;\n-    case XML_PARSER_CDATA_SECTION:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: try CDATA_SECTION\\n\");break;\n-    case XML_PARSER_END_TAG:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: try END_TAG\\n\");break;\n-    case XML_PARSER_ENTITY_DECL:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: try ENTITY_DECL\\n\");break;\n-    case XML_PARSER_ENTITY_VALUE:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: try ENTITY_VALUE\\n\");break;\n-    case XML_PARSER_ATTRIBUTE_VALUE:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: try ATTRIBUTE_VALUE\\n\");break;\n-    case XML_PARSER_DTD:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: try DTD\\n\");break;\n-    case XML_PARSER_EPILOG:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: try EPILOG\\n\");break;\n-    case XML_PARSER_PI:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: try PI\\n\");break;\n+        case XML_PARSER_EOF:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"PP: try EOF\\n\"); break;\n+        case XML_PARSER_START:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"PP: try START\\n\"); break;\n+        case XML_PARSER_MISC:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"PP: try MISC\\n\");break;\n+        case XML_PARSER_COMMENT:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"PP: try COMMENT\\n\");break;\n+        case XML_PARSER_PROLOG:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"PP: try PROLOG\\n\");break;\n+        case XML_PARSER_START_TAG:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"PP: try START_TAG\\n\");break;\n+        case XML_PARSER_CONTENT:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"PP: try CONTENT\\n\");break;\n+        case XML_PARSER_CDATA_SECTION:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"PP: try CDATA_SECTION\\n\");break;\n+        case XML_PARSER_END_TAG:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"PP: try END_TAG\\n\");break;\n+        case XML_PARSER_ENTITY_DECL:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"PP: try ENTITY_DECL\\n\");break;\n+        case XML_PARSER_ENTITY_VALUE:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"PP: try ENTITY_VALUE\\n\");break;\n+        case XML_PARSER_ATTRIBUTE_VALUE:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"PP: try ATTRIBUTE_VALUE\\n\");break;\n+        case XML_PARSER_DTD:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"PP: try DTD\\n\");break;\n+        case XML_PARSER_EPILOG:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"PP: try EPILOG\\n\");break;\n+        case XML_PARSER_PI:\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"PP: try PI\\n\");break;\n@@ -11255,1 +11256,1 @@\n-            \"PP: try IGNORE\\n\");break;\n+                    \"PP: try IGNORE\\n\");break;\n@@ -11261,2 +11262,2 @@\n-    xmlSHRINK(ctxt);\n-    ctxt->checkIndex = 0;\n+        xmlSHRINK(ctxt);\n+        ctxt->checkIndex = 0;\n@@ -11267,2 +11268,2 @@\n-    if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n-        return(0);\n+        if ((ctxt->errNo != XML_ERR_OK) && (ctxt->disableSAX == 1))\n+            return(0);\n@@ -11270,15 +11271,15 @@\n-    if (ctxt->input == NULL) break;\n-    if (ctxt->input->buf == NULL)\n-        avail = ctxt->input->length -\n-                (ctxt->input->cur - ctxt->input->base);\n-    else {\n-        \/*\n-         * If we are operating on converted input, try to flush\n-         * remaining chars to avoid them stalling in the non-converted\n-         * buffer. But do not do this in document start where\n-         * encoding=\"...\" may not have been read and we work on a\n-         * guessed encoding.\n-         *\/\n-        if ((ctxt->instate != XML_PARSER_START) &&\n-            (ctxt->input->buf->raw != NULL) &&\n-        (xmlBufIsEmpty(ctxt->input->buf->raw) == 0)) {\n+        if (ctxt->input == NULL) break;\n+        if (ctxt->input->buf == NULL)\n+            avail = ctxt->input->length -\n+                    (ctxt->input->cur - ctxt->input->base);\n+        else {\n+            \/*\n+             * If we are operating on converted input, try to flush\n+             * remaining chars to avoid them stalling in the non-converted\n+             * buffer. But do not do this in document start where\n+             * encoding=\"...\" may not have been read and we work on a\n+             * guessed encoding.\n+             *\/\n+            if ((ctxt->instate != XML_PARSER_START) &&\n+                (ctxt->input->buf->raw != NULL) &&\n+                (xmlBufIsEmpty(ctxt->input->buf->raw) == 0)) {\n@@ -11287,1 +11288,1 @@\n-        size_t current = ctxt->input->cur - ctxt->input->base;\n+                size_t current = ctxt->input->cur - ctxt->input->base;\n@@ -11289,1 +11290,1 @@\n-        xmlParserInputBufferPush(ctxt->input->buf, 0, \"\");\n+                xmlParserInputBufferPush(ctxt->input->buf, 0, \"\");\n@@ -11292,0 +11293,3 @@\n+            }\n+            avail = xmlBufUse(ctxt->input->buf->buffer) -\n+                    (ctxt->input->cur - ctxt->input->base);\n@@ -11293,3 +11297,0 @@\n-        avail = xmlBufUse(ctxt->input->buf->buffer) -\n-            (ctxt->input->cur - ctxt->input->base);\n-    }\n@@ -11297,1 +11298,1 @@\n-        goto done;\n+            goto done;\n@@ -11300,4 +11301,4 @@\n-            \/*\n-         * Document parsing is done !\n-         *\/\n-            goto done;\n+                \/*\n+                 * Document parsing is done !\n+                 *\/\n+                goto done;\n@@ -11305,25 +11306,25 @@\n-        if (ctxt->charset == XML_CHAR_ENCODING_NONE) {\n-            xmlChar start[4];\n-            xmlCharEncoding enc;\n-\n-            \/*\n-             * Very first chars read from the document flow.\n-             *\/\n-            if (avail < 4)\n-            goto done;\n-\n-            \/*\n-             * Get the 4 first bytes and decode the charset\n-             * if enc != XML_CHAR_ENCODING_NONE\n-             * plug some encoding conversion routines,\n-             * else xmlSwitchEncoding will set to (default)\n-             * UTF8.\n-             *\/\n-            start[0] = RAW;\n-            start[1] = NXT(1);\n-            start[2] = NXT(2);\n-            start[3] = NXT(3);\n-            enc = xmlDetectCharEncoding(start, 4);\n-            xmlSwitchEncoding(ctxt, enc);\n-            break;\n-        }\n+                if (ctxt->charset == XML_CHAR_ENCODING_NONE) {\n+                    xmlChar start[4];\n+                    xmlCharEncoding enc;\n+\n+                    \/*\n+                     * Very first chars read from the document flow.\n+                     *\/\n+                    if (avail < 4)\n+                        goto done;\n+\n+                    \/*\n+                     * Get the 4 first bytes and decode the charset\n+                     * if enc != XML_CHAR_ENCODING_NONE\n+                     * plug some encoding conversion routines,\n+                     * else xmlSwitchEncoding will set to (default)\n+                     * UTF8.\n+                     *\/\n+                    start[0] = RAW;\n+                    start[1] = NXT(1);\n+                    start[2] = NXT(2);\n+                    start[3] = NXT(3);\n+                    enc = xmlDetectCharEncoding(start, 4);\n+                    xmlSwitchEncoding(ctxt, enc);\n+                    break;\n+                }\n@@ -11331,10 +11332,10 @@\n-        if (avail < 2)\n-            goto done;\n-        cur = ctxt->input->cur[0];\n-        next = ctxt->input->cur[1];\n-        if (cur == 0) {\n-            if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n-            ctxt->sax->setDocumentLocator(ctxt->userData,\n-                              &xmlDefaultSAXLocator);\n-            xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n-            xmlHaltParser(ctxt);\n+                if (avail < 2)\n+                    goto done;\n+                cur = ctxt->input->cur[0];\n+                next = ctxt->input->cur[1];\n+                if (cur == 0) {\n+                    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n+                        ctxt->sax->setDocumentLocator(ctxt->userData,\n+                                                      &xmlDefaultSAXLocator);\n+                    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n+                    xmlHaltParser(ctxt);\n@@ -11342,2 +11343,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: entering EOF\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"PP: entering EOF\\n\");\n@@ -11345,18 +11346,18 @@\n-            if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n-            ctxt->sax->endDocument(ctxt->userData);\n-            goto done;\n-        }\n-            if ((cur == '<') && (next == '?')) {\n-            \/* PI or XML decl *\/\n-            if (avail < 5) return(ret);\n-            if ((!terminate) &&\n-                (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n-            return(ret);\n-            if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n-            ctxt->sax->setDocumentLocator(ctxt->userData,\n-                              &xmlDefaultSAXLocator);\n-            if ((ctxt->input->cur[2] == 'x') &&\n-            (ctxt->input->cur[3] == 'm') &&\n-            (ctxt->input->cur[4] == 'l') &&\n-            (IS_BLANK_CH(ctxt->input->cur[5]))) {\n-            ret += 5;\n+                    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n+                        ctxt->sax->endDocument(ctxt->userData);\n+                    goto done;\n+                }\n+                if ((cur == '<') && (next == '?')) {\n+                    \/* PI or XML decl *\/\n+                    if (avail < 5) return(ret);\n+                    if ((!terminate) &&\n+                        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0))\n+                        return(ret);\n+                    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n+                        ctxt->sax->setDocumentLocator(ctxt->userData,\n+                                                      &xmlDefaultSAXLocator);\n+                    if ((ctxt->input->cur[2] == 'x') &&\n+                        (ctxt->input->cur[3] == 'm') &&\n+                        (ctxt->input->cur[4] == 'l') &&\n+                        (IS_BLANK_CH(ctxt->input->cur[5]))) {\n+                        ret += 5;\n@@ -11364,2 +11365,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: Parsing XML Decl\\n\");\n+                        xmlGenericError(xmlGenericErrorContext,\n+                                \"PP: Parsing XML Decl\\n\");\n@@ -11367,17 +11368,17 @@\n-            xmlParseXMLDecl(ctxt);\n-            if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n-                \/*\n-                 * The XML REC instructs us to stop parsing right\n-                 * here\n-                 *\/\n-                xmlHaltParser(ctxt);\n-                return(0);\n-            }\n-            ctxt->standalone = ctxt->input->standalone;\n-            if ((ctxt->encoding == NULL) &&\n-                (ctxt->input->encoding != NULL))\n-                ctxt->encoding = xmlStrdup(ctxt->input->encoding);\n-            if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n-                (!ctxt->disableSAX))\n-                ctxt->sax->startDocument(ctxt->userData);\n-            ctxt->instate = XML_PARSER_MISC;\n+                        xmlParseXMLDecl(ctxt);\n+                        if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n+                            \/*\n+                             * The XML REC instructs us to stop parsing right\n+                             * here\n+                             *\/\n+                            xmlHaltParser(ctxt);\n+                            return(0);\n+                        }\n+                        ctxt->standalone = ctxt->input->standalone;\n+                        if ((ctxt->encoding == NULL) &&\n+                            (ctxt->input->encoding != NULL))\n+                            ctxt->encoding = xmlStrdup(ctxt->input->encoding);\n+                        if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n+                            (!ctxt->disableSAX))\n+                            ctxt->sax->startDocument(ctxt->userData);\n+                        ctxt->instate = XML_PARSER_MISC;\n@@ -11385,2 +11386,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: entering MISC\\n\");\n+                        xmlGenericError(xmlGenericErrorContext,\n+                                \"PP: entering MISC\\n\");\n@@ -11388,6 +11389,6 @@\n-            } else {\n-            ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n-            if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n-                (!ctxt->disableSAX))\n-                ctxt->sax->startDocument(ctxt->userData);\n-            ctxt->instate = XML_PARSER_MISC;\n+                    } else {\n+                        ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n+                        if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n+                            (!ctxt->disableSAX))\n+                            ctxt->sax->startDocument(ctxt->userData);\n+                        ctxt->instate = XML_PARSER_MISC;\n@@ -11395,2 +11396,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: entering MISC\\n\");\n+                        xmlGenericError(xmlGenericErrorContext,\n+                                \"PP: entering MISC\\n\");\n@@ -11398,14 +11399,14 @@\n-            }\n-        } else {\n-            if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n-            ctxt->sax->setDocumentLocator(ctxt->userData,\n-                              &xmlDefaultSAXLocator);\n-            ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n-            if (ctxt->version == NULL) {\n-                xmlErrMemory(ctxt, NULL);\n-            break;\n-            }\n-            if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n-                (!ctxt->disableSAX))\n-            ctxt->sax->startDocument(ctxt->userData);\n-            ctxt->instate = XML_PARSER_MISC;\n+                    }\n+                } else {\n+                    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n+                        ctxt->sax->setDocumentLocator(ctxt->userData,\n+                                                      &xmlDefaultSAXLocator);\n+                    ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n+                    if (ctxt->version == NULL) {\n+                        xmlErrMemory(ctxt, NULL);\n+                        break;\n+                    }\n+                    if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n+                        (!ctxt->disableSAX))\n+                        ctxt->sax->startDocument(ctxt->userData);\n+                    ctxt->instate = XML_PARSER_MISC;\n@@ -11413,2 +11414,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: entering MISC\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"PP: entering MISC\\n\");\n@@ -11416,2 +11417,2 @@\n-        }\n-        break;\n+                }\n+                break;\n@@ -11419,3 +11420,3 @@\n-            const xmlChar *name;\n-        const xmlChar *prefix = NULL;\n-        const xmlChar *URI = NULL;\n+                const xmlChar *name;\n+                const xmlChar *prefix = NULL;\n+                const xmlChar *URI = NULL;\n@@ -11423,1 +11424,1 @@\n-        int nsNr = ctxt->nsNr;\n+                int nsNr = ctxt->nsNr;\n@@ -11425,25 +11426,25 @@\n-        if ((avail < 2) && (ctxt->inputNr == 1))\n-            goto done;\n-        cur = ctxt->input->cur[0];\n-            if (cur != '<') {\n-            xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n-            xmlHaltParser(ctxt);\n-            if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n-            ctxt->sax->endDocument(ctxt->userData);\n-            goto done;\n-        }\n-        if (!terminate) {\n-            if (ctxt->progressive) {\n-                \/* > can be found unescaped in attribute values *\/\n-                if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))\n-                goto done;\n-            } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {\n-            goto done;\n-            }\n-        }\n-        if (ctxt->spaceNr == 0)\n-            spacePush(ctxt, -1);\n-        else if (*ctxt->space == -2)\n-            spacePush(ctxt, -1);\n-        else\n-            spacePush(ctxt, *ctxt->space);\n+                if ((avail < 2) && (ctxt->inputNr == 1))\n+                    goto done;\n+                cur = ctxt->input->cur[0];\n+                if (cur != '<') {\n+                    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n+                    xmlHaltParser(ctxt);\n+                    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n+                        ctxt->sax->endDocument(ctxt->userData);\n+                    goto done;\n+                }\n+                if (!terminate) {\n+                    if (ctxt->progressive) {\n+                        \/* > can be found unescaped in attribute values *\/\n+                        if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))\n+                            goto done;\n+                    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {\n+                        goto done;\n+                    }\n+                }\n+                if (ctxt->spaceNr == 0)\n+                    spacePush(ctxt, -1);\n+                else if (*ctxt->space == -2)\n+                    spacePush(ctxt, -1);\n+                else\n+                    spacePush(ctxt, *ctxt->space);\n@@ -11451,1 +11452,1 @@\n-        if (ctxt->sax2)\n+                if (ctxt->sax2)\n@@ -11453,1 +11454,1 @@\n-            name = xmlParseStartTag2(ctxt, &prefix, &URI, &tlen);\n+                    name = xmlParseStartTag2(ctxt, &prefix, &URI, &tlen);\n@@ -11455,2 +11456,2 @@\n-        else\n-            name = xmlParseStartTag(ctxt);\n+                else\n+                    name = xmlParseStartTag(ctxt);\n@@ -11458,9 +11459,9 @@\n-        if (ctxt->instate == XML_PARSER_EOF)\n-            goto done;\n-        if (name == NULL) {\n-            spacePop(ctxt);\n-            xmlHaltParser(ctxt);\n-            if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n-            ctxt->sax->endDocument(ctxt->userData);\n-            goto done;\n-        }\n+                if (ctxt->instate == XML_PARSER_EOF)\n+                    goto done;\n+                if (name == NULL) {\n+                    spacePop(ctxt);\n+                    xmlHaltParser(ctxt);\n+                    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n+                        ctxt->sax->endDocument(ctxt->userData);\n+                    goto done;\n+                }\n@@ -11468,8 +11469,8 @@\n-        \/*\n-         * [ VC: Root Element Type ]\n-         * The Name in the document type declaration must match\n-         * the element type of the root element.\n-         *\/\n-        if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&\n-            ctxt->node && (ctxt->node == ctxt->myDoc->children))\n-            ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n+                \/*\n+                 * [ VC: Root Element Type ]\n+                 * The Name in the document type declaration must match\n+                 * the element type of the root element.\n+                 *\/\n+                if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&\n+                    ctxt->node && (ctxt->node == ctxt->myDoc->children))\n+                    ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n@@ -11478,14 +11479,14 @@\n-        \/*\n-         * Check for an Empty Element.\n-         *\/\n-        if ((RAW == '\/') && (NXT(1) == '>')) {\n-            SKIP(2);\n-\n-            if (ctxt->sax2) {\n-            if ((ctxt->sax != NULL) &&\n-                (ctxt->sax->endElementNs != NULL) &&\n-                (!ctxt->disableSAX))\n-                ctxt->sax->endElementNs(ctxt->userData, name,\n-                                        prefix, URI);\n-            if (ctxt->nsNr - nsNr > 0)\n-                nsPop(ctxt, ctxt->nsNr - nsNr);\n+                \/*\n+                 * Check for an Empty Element.\n+                 *\/\n+                if ((RAW == '\/') && (NXT(1) == '>')) {\n+                    SKIP(2);\n+\n+                    if (ctxt->sax2) {\n+                        if ((ctxt->sax != NULL) &&\n+                            (ctxt->sax->endElementNs != NULL) &&\n+                            (!ctxt->disableSAX))\n+                            ctxt->sax->endElementNs(ctxt->userData, name,\n+                                                    prefix, URI);\n+                        if (ctxt->nsNr - nsNr > 0)\n+                            nsPop(ctxt, ctxt->nsNr - nsNr);\n@@ -11493,5 +11494,5 @@\n-            } else {\n-            if ((ctxt->sax != NULL) &&\n-                (ctxt->sax->endElement != NULL) &&\n-                (!ctxt->disableSAX))\n-                ctxt->sax->endElement(ctxt->userData, name);\n+                    } else {\n+                        if ((ctxt->sax != NULL) &&\n+                            (ctxt->sax->endElement != NULL) &&\n+                            (!ctxt->disableSAX))\n+                            ctxt->sax->endElement(ctxt->userData, name);\n@@ -11499,9 +11500,9 @@\n-            }\n-            if (ctxt->instate == XML_PARSER_EOF)\n-            goto done;\n-            spacePop(ctxt);\n-            if (ctxt->nameNr == 0) {\n-            ctxt->instate = XML_PARSER_EPILOG;\n-            } else {\n-            ctxt->instate = XML_PARSER_CONTENT;\n-            }\n+                    }\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n+                    spacePop(ctxt);\n+                    if (ctxt->nameNr == 0) {\n+                        ctxt->instate = XML_PARSER_EPILOG;\n+                    } else {\n+                        ctxt->instate = XML_PARSER_CONTENT;\n+                    }\n@@ -11509,11 +11510,11 @@\n-            break;\n-        }\n-        if (RAW == '>') {\n-            NEXT;\n-        } else {\n-            xmlFatalErrMsgStr(ctxt, XML_ERR_GT_REQUIRED,\n-                     \"Couldn't find end of Start Tag %s\\n\",\n-                     name);\n-            nodePop(ctxt);\n-            spacePop(ctxt);\n-        }\n+                    break;\n+                }\n+                if (RAW == '>') {\n+                    NEXT;\n+                } else {\n+                    xmlFatalErrMsgStr(ctxt, XML_ERR_GT_REQUIRED,\n+                                         \"Couldn't find end of Start Tag %s\\n\",\n+                                         name);\n+                    nodePop(ctxt);\n+                    spacePop(ctxt);\n+                }\n@@ -11522,1 +11523,1 @@\n-        ctxt->instate = XML_PARSER_CONTENT;\n+                ctxt->instate = XML_PARSER_CONTENT;\n@@ -11525,1 +11526,1 @@\n-        }\n+            }\n@@ -11527,6 +11528,6 @@\n-        const xmlChar *test;\n-        unsigned int cons;\n-        if ((avail < 2) && (ctxt->inputNr == 1))\n-            goto done;\n-        cur = ctxt->input->cur[0];\n-        next = ctxt->input->cur[1];\n+                const xmlChar *test;\n+                unsigned int cons;\n+                if ((avail < 2) && (ctxt->inputNr == 1))\n+                    goto done;\n+                cur = ctxt->input->cur[0];\n+                next = ctxt->input->cur[1];\n@@ -11534,8 +11535,8 @@\n-        test = CUR_PTR;\n-            cons = ctxt->input->consumed;\n-        if ((cur == '<') && (next == '\/')) {\n-            ctxt->instate = XML_PARSER_END_TAG;\n-            break;\n-            } else if ((cur == '<') && (next == '?')) {\n-            if ((!terminate) &&\n-                (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {\n+                test = CUR_PTR;\n+                cons = ctxt->input->consumed;\n+                if ((cur == '<') && (next == '\/')) {\n+                    ctxt->instate = XML_PARSER_END_TAG;\n+                    break;\n+                } else if ((cur == '<') && (next == '?')) {\n+                    if ((!terminate) &&\n+                        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {\n@@ -11543,1 +11544,1 @@\n-            goto done;\n+                        goto done;\n@@ -11545,2 +11546,2 @@\n-            xmlParsePI(ctxt);\n-            ctxt->instate = XML_PARSER_CONTENT;\n+                    xmlParsePI(ctxt);\n+                    ctxt->instate = XML_PARSER_CONTENT;\n@@ -11548,14 +11549,14 @@\n-        } else if ((cur == '<') && (next != '!')) {\n-            ctxt->instate = XML_PARSER_START_TAG;\n-            break;\n-        } else if ((cur == '<') && (next == '!') &&\n-                   (ctxt->input->cur[2] == '-') &&\n-               (ctxt->input->cur[3] == '-')) {\n-            int term;\n-\n-                if (avail < 4)\n-                goto done;\n-            ctxt->input->cur += 4;\n-            term = xmlParseLookupSequence(ctxt, '-', '-', '>');\n-            ctxt->input->cur -= 4;\n-            if ((!terminate) && (term < 0)) {\n+                } else if ((cur == '<') && (next != '!')) {\n+                    ctxt->instate = XML_PARSER_START_TAG;\n+                    break;\n+                } else if ((cur == '<') && (next == '!') &&\n+                           (ctxt->input->cur[2] == '-') &&\n+                           (ctxt->input->cur[3] == '-')) {\n+                    int term;\n+\n+                    if (avail < 4)\n+                        goto done;\n+                    ctxt->input->cur += 4;\n+                    term = xmlParseLookupSequence(ctxt, '-', '-', '>');\n+                    ctxt->input->cur -= 4;\n+                    if ((!terminate) && (term < 0)) {\n@@ -11563,1 +11564,1 @@\n-            goto done;\n+                        goto done;\n@@ -11565,2 +11566,2 @@\n-            xmlParseComment(ctxt);\n-            ctxt->instate = XML_PARSER_CONTENT;\n+                    xmlParseComment(ctxt);\n+                    ctxt->instate = XML_PARSER_CONTENT;\n@@ -11568,38 +11569,13 @@\n-        } else if ((cur == '<') && (ctxt->input->cur[1] == '!') &&\n-            (ctxt->input->cur[2] == '[') &&\n-            (ctxt->input->cur[3] == 'C') &&\n-            (ctxt->input->cur[4] == 'D') &&\n-            (ctxt->input->cur[5] == 'A') &&\n-            (ctxt->input->cur[6] == 'T') &&\n-            (ctxt->input->cur[7] == 'A') &&\n-            (ctxt->input->cur[8] == '[')) {\n-            SKIP(9);\n-            ctxt->instate = XML_PARSER_CDATA_SECTION;\n-            break;\n-        } else if ((cur == '<') && (next == '!') &&\n-                   (avail < 9)) {\n-            goto done;\n-        } else if (cur == '&') {\n-            if ((!terminate) &&\n-                (xmlParseLookupSequence(ctxt, ';', 0, 0) < 0))\n-            goto done;\n-            xmlParseReference(ctxt);\n-        } else {\n-            \/* TODO Avoid the extra copy, handle directly !!! *\/\n-            \/*\n-             * Goal of the following test is:\n-             *  - minimize calls to the SAX 'character' callback\n-             *    when they are mergeable\n-             *  - handle an problem for isBlank when we only parse\n-             *    a sequence of blank chars and the next one is\n-             *    not available to check against '<' presence.\n-             *  - tries to homogenize the differences in SAX\n-             *    callbacks between the push and pull versions\n-             *    of the parser.\n-             *\/\n-            if ((ctxt->inputNr == 1) &&\n-                (avail < XML_PARSER_BIG_BUFFER_SIZE)) {\n-            if (!terminate) {\n-                if (ctxt->progressive) {\n-                if ((lastlt == NULL) ||\n-                    (ctxt->input->cur > lastlt))\n+                } else if ((cur == '<') && (ctxt->input->cur[1] == '!') &&\n+                    (ctxt->input->cur[2] == '[') &&\n+                    (ctxt->input->cur[3] == 'C') &&\n+                    (ctxt->input->cur[4] == 'D') &&\n+                    (ctxt->input->cur[5] == 'A') &&\n+                    (ctxt->input->cur[6] == 'T') &&\n+                    (ctxt->input->cur[7] == 'A') &&\n+                    (ctxt->input->cur[8] == '[')) {\n+                    SKIP(9);\n+                    ctxt->instate = XML_PARSER_CDATA_SECTION;\n+                    break;\n+                } else if ((cur == '<') && (next == '!') &&\n+                           (avail < 9)) {\n@@ -11607,3 +11583,33 @@\n-                } else if (xmlParseLookupSequence(ctxt,\n-                                                  '<', 0, 0) < 0) {\n-                goto done;\n+                } else if (cur == '&') {\n+                    if ((!terminate) &&\n+                        (xmlParseLookupSequence(ctxt, ';', 0, 0) < 0))\n+                        goto done;\n+                    xmlParseReference(ctxt);\n+                } else {\n+                    \/* TODO Avoid the extra copy, handle directly !!! *\/\n+                    \/*\n+                     * Goal of the following test is:\n+                     *  - minimize calls to the SAX 'character' callback\n+                     *    when they are mergeable\n+                     *  - handle an problem for isBlank when we only parse\n+                     *    a sequence of blank chars and the next one is\n+                     *    not available to check against '<' presence.\n+                     *  - tries to homogenize the differences in SAX\n+                     *    callbacks between the push and pull versions\n+                     *    of the parser.\n+                     *\/\n+                    if ((ctxt->inputNr == 1) &&\n+                        (avail < XML_PARSER_BIG_BUFFER_SIZE)) {\n+                        if (!terminate) {\n+                            if (ctxt->progressive) {\n+                                if ((lastlt == NULL) ||\n+                                    (ctxt->input->cur > lastlt))\n+                                    goto done;\n+                            } else if (xmlParseLookupSequence(ctxt,\n+                                                              '<', 0, 0) < 0) {\n+                                goto done;\n+                            }\n+                        }\n+                    }\n+                    ctxt->checkIndex = 0;\n+                    xmlParseCharData(ctxt, 0);\n@@ -11611,0 +11617,7 @@\n+                if ((cons == ctxt->input->consumed) && (test == CUR_PTR)) {\n+                    xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                                \"detected an error in element content\\n\");\n+                    xmlHaltParser(ctxt);\n+                    break;\n+                }\n+                break;\n@@ -11612,12 +11625,0 @@\n-                    }\n-            ctxt->checkIndex = 0;\n-            xmlParseCharData(ctxt, 0);\n-        }\n-        if ((cons == ctxt->input->consumed) && (test == CUR_PTR)) {\n-            xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                        \"detected an error in element content\\n\");\n-            xmlHaltParser(ctxt);\n-            break;\n-        }\n-        break;\n-        }\n@@ -11625,15 +11626,15 @@\n-        if (avail < 2)\n-            goto done;\n-        if (!terminate) {\n-            if (ctxt->progressive) {\n-                \/* > can be found unescaped in attribute values *\/\n-                if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))\n-                goto done;\n-            } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {\n-            goto done;\n-            }\n-        }\n-        if (ctxt->sax2) {\n-                xmlParseEndTag2(ctxt, &ctxt->pushTab[ctxt->nameNr - 1]);\n-            nameNsPop(ctxt);\n-        }\n+                if (avail < 2)\n+                    goto done;\n+                if (!terminate) {\n+                    if (ctxt->progressive) {\n+                        \/* > can be found unescaped in attribute values *\/\n+                        if ((lastgt == NULL) || (ctxt->input->cur >= lastgt))\n+                            goto done;\n+                    } else if (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0) {\n+                        goto done;\n+                    }\n+                }\n+                if (ctxt->sax2) {\n+                    xmlParseEndTag2(ctxt, &ctxt->pushTab[ctxt->nameNr - 1]);\n+                    nameNsPop(ctxt);\n+                }\n@@ -11641,2 +11642,2 @@\n-          else\n-            xmlParseEndTag1(ctxt, 0);\n+                  else\n+                    xmlParseEndTag1(ctxt, 0);\n@@ -11644,8 +11645,8 @@\n-        if (ctxt->instate == XML_PARSER_EOF) {\n-            \/* Nothing *\/\n-        } else if (ctxt->nameNr == 0) {\n-            ctxt->instate = XML_PARSER_EPILOG;\n-        } else {\n-            ctxt->instate = XML_PARSER_CONTENT;\n-        }\n-        break;\n+                if (ctxt->instate == XML_PARSER_EOF) {\n+                    \/* Nothing *\/\n+                } else if (ctxt->nameNr == 0) {\n+                    ctxt->instate = XML_PARSER_EPILOG;\n+                } else {\n+                    ctxt->instate = XML_PARSER_CONTENT;\n+                }\n+                break;\n@@ -11653,34 +11654,34 @@\n-            \/*\n-         * The Push mode need to have the SAX callback for\n-         * cdataBlock merge back contiguous callbacks.\n-         *\/\n-        int base;\n-\n-        base = xmlParseLookupSequence(ctxt, ']', ']', '>');\n-        if (base < 0) {\n-            if (avail >= XML_PARSER_BIG_BUFFER_SIZE + 2) {\n-                int tmp;\n-\n-            tmp = xmlCheckCdataPush(ctxt->input->cur,\n-                                    XML_PARSER_BIG_BUFFER_SIZE, 0);\n-            if (tmp < 0) {\n-                tmp = -tmp;\n-                ctxt->input->cur += tmp;\n-                goto encoding_error;\n-            }\n-            if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n-                if (ctxt->sax->cdataBlock != NULL)\n-                ctxt->sax->cdataBlock(ctxt->userData,\n-                                      ctxt->input->cur, tmp);\n-                else if (ctxt->sax->characters != NULL)\n-                ctxt->sax->characters(ctxt->userData,\n-                                      ctxt->input->cur, tmp);\n-            }\n-            if (ctxt->instate == XML_PARSER_EOF)\n-                goto done;\n-            SKIPL(tmp);\n-            ctxt->checkIndex = 0;\n-            }\n-            goto done;\n-        } else {\n-            int tmp;\n+                \/*\n+                 * The Push mode need to have the SAX callback for\n+                 * cdataBlock merge back contiguous callbacks.\n+                 *\/\n+                int base;\n+\n+                base = xmlParseLookupSequence(ctxt, ']', ']', '>');\n+                if (base < 0) {\n+                    if (avail >= XML_PARSER_BIG_BUFFER_SIZE + 2) {\n+                        int tmp;\n+\n+                        tmp = xmlCheckCdataPush(ctxt->input->cur,\n+                                                XML_PARSER_BIG_BUFFER_SIZE, 0);\n+                        if (tmp < 0) {\n+                            tmp = -tmp;\n+                            ctxt->input->cur += tmp;\n+                            goto encoding_error;\n+                        }\n+                        if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n+                            if (ctxt->sax->cdataBlock != NULL)\n+                                ctxt->sax->cdataBlock(ctxt->userData,\n+                                                      ctxt->input->cur, tmp);\n+                            else if (ctxt->sax->characters != NULL)\n+                                ctxt->sax->characters(ctxt->userData,\n+                                                      ctxt->input->cur, tmp);\n+                        }\n+                        if (ctxt->instate == XML_PARSER_EOF)\n+                            goto done;\n+                        SKIPL(tmp);\n+                        ctxt->checkIndex = 0;\n+                    }\n+                    goto done;\n+                } else {\n+                    int tmp;\n@@ -11688,33 +11689,33 @@\n-            tmp = xmlCheckCdataPush(ctxt->input->cur, base, 1);\n-            if ((tmp < 0) || (tmp != base)) {\n-            tmp = -tmp;\n-            ctxt->input->cur += tmp;\n-            goto encoding_error;\n-            }\n-            if ((ctxt->sax != NULL) && (base == 0) &&\n-                (ctxt->sax->cdataBlock != NULL) &&\n-                (!ctxt->disableSAX)) {\n-            \/*\n-             * Special case to provide identical behaviour\n-             * between pull and push parsers on enpty CDATA\n-             * sections\n-             *\/\n-             if ((ctxt->input->cur - ctxt->input->base >= 9) &&\n-                 (!strncmp((const char *)&ctxt->input->cur[-9],\n-                           \"<![CDATA[\", 9)))\n-                 ctxt->sax->cdataBlock(ctxt->userData,\n-                                       BAD_CAST \"\", 0);\n-            } else if ((ctxt->sax != NULL) && (base > 0) &&\n-            (!ctxt->disableSAX)) {\n-            if (ctxt->sax->cdataBlock != NULL)\n-                ctxt->sax->cdataBlock(ctxt->userData,\n-                          ctxt->input->cur, base);\n-            else if (ctxt->sax->characters != NULL)\n-                ctxt->sax->characters(ctxt->userData,\n-                          ctxt->input->cur, base);\n-            }\n-            if (ctxt->instate == XML_PARSER_EOF)\n-            goto done;\n-            SKIPL(base + 3);\n-            ctxt->checkIndex = 0;\n-            ctxt->instate = XML_PARSER_CONTENT;\n+                    tmp = xmlCheckCdataPush(ctxt->input->cur, base, 1);\n+                    if ((tmp < 0) || (tmp != base)) {\n+                        tmp = -tmp;\n+                        ctxt->input->cur += tmp;\n+                        goto encoding_error;\n+                    }\n+                    if ((ctxt->sax != NULL) && (base == 0) &&\n+                        (ctxt->sax->cdataBlock != NULL) &&\n+                        (!ctxt->disableSAX)) {\n+                        \/*\n+                         * Special case to provide identical behaviour\n+                         * between pull and push parsers on enpty CDATA\n+                         * sections\n+                         *\/\n+                         if ((ctxt->input->cur - ctxt->input->base >= 9) &&\n+                             (!strncmp((const char *)&ctxt->input->cur[-9],\n+                                       \"<![CDATA[\", 9)))\n+                             ctxt->sax->cdataBlock(ctxt->userData,\n+                                                   BAD_CAST \"\", 0);\n+                    } else if ((ctxt->sax != NULL) && (base > 0) &&\n+                        (!ctxt->disableSAX)) {\n+                        if (ctxt->sax->cdataBlock != NULL)\n+                            ctxt->sax->cdataBlock(ctxt->userData,\n+                                                  ctxt->input->cur, base);\n+                        else if (ctxt->sax->characters != NULL)\n+                            ctxt->sax->characters(ctxt->userData,\n+                                                  ctxt->input->cur, base);\n+                    }\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n+                    SKIPL(base + 3);\n+                    ctxt->checkIndex = 0;\n+                    ctxt->instate = XML_PARSER_CONTENT;\n@@ -11722,2 +11723,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: entering CONTENT\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"PP: entering CONTENT\\n\");\n@@ -11725,3 +11726,3 @@\n-        }\n-        break;\n-        }\n+                }\n+                break;\n+            }\n@@ -11729,14 +11730,14 @@\n-        SKIP_BLANKS;\n-        if (ctxt->input->buf == NULL)\n-            avail = ctxt->input->length -\n-                    (ctxt->input->cur - ctxt->input->base);\n-        else\n-            avail = xmlBufUse(ctxt->input->buf->buffer) -\n-                    (ctxt->input->cur - ctxt->input->base);\n-        if (avail < 2)\n-            goto done;\n-        cur = ctxt->input->cur[0];\n-        next = ctxt->input->cur[1];\n-            if ((cur == '<') && (next == '?')) {\n-            if ((!terminate) &&\n-                (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {\n+                SKIP_BLANKS;\n+                if (ctxt->input->buf == NULL)\n+                    avail = ctxt->input->length -\n+                            (ctxt->input->cur - ctxt->input->base);\n+                else\n+                    avail = xmlBufUse(ctxt->input->buf->buffer) -\n+                            (ctxt->input->cur - ctxt->input->base);\n+                if (avail < 2)\n+                    goto done;\n+                cur = ctxt->input->cur[0];\n+                next = ctxt->input->cur[1];\n+                if ((cur == '<') && (next == '?')) {\n+                    if ((!terminate) &&\n+                        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {\n@@ -11744,1 +11745,1 @@\n-            goto done;\n+                        goto done;\n@@ -11747,2 +11748,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: Parsing PI\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"PP: Parsing PI\\n\");\n@@ -11750,4 +11751,4 @@\n-            xmlParsePI(ctxt);\n-            if (ctxt->instate == XML_PARSER_EOF)\n-            goto done;\n-            ctxt->instate = XML_PARSER_MISC;\n+                    xmlParsePI(ctxt);\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n+                    ctxt->instate = XML_PARSER_MISC;\n@@ -11755,6 +11756,6 @@\n-            ctxt->checkIndex = 0;\n-        } else if ((cur == '<') && (next == '!') &&\n-            (ctxt->input->cur[2] == '-') &&\n-            (ctxt->input->cur[3] == '-')) {\n-            if ((!terminate) &&\n-                (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {\n+                    ctxt->checkIndex = 0;\n+                } else if ((cur == '<') && (next == '!') &&\n+                    (ctxt->input->cur[2] == '-') &&\n+                    (ctxt->input->cur[3] == '-')) {\n+                    if ((!terminate) &&\n+                        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {\n@@ -11762,1 +11763,1 @@\n-            goto done;\n+                        goto done;\n@@ -11765,2 +11766,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: Parsing Comment\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"PP: Parsing Comment\\n\");\n@@ -11768,4 +11769,4 @@\n-            xmlParseComment(ctxt);\n-            if (ctxt->instate == XML_PARSER_EOF)\n-            goto done;\n-            ctxt->instate = XML_PARSER_MISC;\n+                    xmlParseComment(ctxt);\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n+                    ctxt->instate = XML_PARSER_MISC;\n@@ -11773,11 +11774,11 @@\n-            ctxt->checkIndex = 0;\n-        } else if ((cur == '<') && (next == '!') &&\n-            (ctxt->input->cur[2] == 'D') &&\n-            (ctxt->input->cur[3] == 'O') &&\n-            (ctxt->input->cur[4] == 'C') &&\n-            (ctxt->input->cur[5] == 'T') &&\n-            (ctxt->input->cur[6] == 'Y') &&\n-            (ctxt->input->cur[7] == 'P') &&\n-            (ctxt->input->cur[8] == 'E')) {\n-            if ((!terminate) &&\n-                (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0)) {\n+                    ctxt->checkIndex = 0;\n+                } else if ((cur == '<') && (next == '!') &&\n+                    (ctxt->input->cur[2] == 'D') &&\n+                    (ctxt->input->cur[3] == 'O') &&\n+                    (ctxt->input->cur[4] == 'C') &&\n+                    (ctxt->input->cur[5] == 'T') &&\n+                    (ctxt->input->cur[6] == 'Y') &&\n+                    (ctxt->input->cur[7] == 'P') &&\n+                    (ctxt->input->cur[8] == 'E')) {\n+                    if ((!terminate) &&\n+                        (xmlParseLookupSequence(ctxt, '>', 0, 0) < 0)) {\n@@ -11785,1 +11786,1 @@\n-            goto done;\n+                        goto done;\n@@ -11788,2 +11789,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: Parsing internal subset\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"PP: Parsing internal subset\\n\");\n@@ -11791,1 +11792,1 @@\n-            ctxt->inSubset = 1;\n+                    ctxt->inSubset = 1;\n@@ -11793,6 +11794,6 @@\n-            ctxt->checkIndex = 0;\n-            xmlParseDocTypeDecl(ctxt);\n-            if (ctxt->instate == XML_PARSER_EOF)\n-            goto done;\n-            if (RAW == '[') {\n-            ctxt->instate = XML_PARSER_DTD;\n+                    ctxt->checkIndex = 0;\n+                    xmlParseDocTypeDecl(ctxt);\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n+                    if (RAW == '[') {\n+                        ctxt->instate = XML_PARSER_DTD;\n@@ -11800,2 +11801,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: entering DTD\\n\");\n+                        xmlGenericError(xmlGenericErrorContext,\n+                                \"PP: entering DTD\\n\");\n@@ -11803,13 +11804,13 @@\n-            } else {\n-            \/*\n-             * Create and update the external subset.\n-             *\/\n-            ctxt->inSubset = 2;\n-            if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n-                (ctxt->sax->externalSubset != NULL))\n-                ctxt->sax->externalSubset(ctxt->userData,\n-                    ctxt->intSubName, ctxt->extSubSystem,\n-                    ctxt->extSubURI);\n-            ctxt->inSubset = 0;\n-            xmlCleanSpecialAttr(ctxt);\n-            ctxt->instate = XML_PARSER_PROLOG;\n+                    } else {\n+                        \/*\n+                         * Create and update the external subset.\n+                         *\/\n+                        ctxt->inSubset = 2;\n+                        if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n+                            (ctxt->sax->externalSubset != NULL))\n+                            ctxt->sax->externalSubset(ctxt->userData,\n+                                    ctxt->intSubName, ctxt->extSubSystem,\n+                                    ctxt->extSubURI);\n+                        ctxt->inSubset = 0;\n+                        xmlCleanSpecialAttr(ctxt);\n+                        ctxt->instate = XML_PARSER_PROLOG;\n@@ -11817,2 +11818,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: entering PROLOG\\n\");\n+                        xmlGenericError(xmlGenericErrorContext,\n+                                \"PP: entering PROLOG\\n\");\n@@ -11820,8 +11821,8 @@\n-            }\n-        } else if ((cur == '<') && (next == '!') &&\n-                   (avail < 9)) {\n-            goto done;\n-        } else {\n-            ctxt->instate = XML_PARSER_START_TAG;\n-            ctxt->progressive = XML_PARSER_START_TAG;\n-            xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n+                    }\n+                } else if ((cur == '<') && (next == '!') &&\n+                           (avail < 9)) {\n+                    goto done;\n+                } else {\n+                    ctxt->instate = XML_PARSER_START_TAG;\n+                    ctxt->progressive = XML_PARSER_START_TAG;\n+                    xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n@@ -11829,2 +11830,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: entering START_TAG\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"PP: entering START_TAG\\n\");\n@@ -11832,2 +11833,2 @@\n-        }\n-        break;\n+                }\n+                break;\n@@ -11835,5 +11836,5 @@\n-        SKIP_BLANKS;\n-        if (ctxt->input->buf == NULL)\n-            avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);\n-        else\n-            avail = xmlBufUse(ctxt->input->buf->buffer) -\n+                SKIP_BLANKS;\n+                if (ctxt->input->buf == NULL)\n+                    avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);\n+                else\n+                    avail = xmlBufUse(ctxt->input->buf->buffer) -\n@@ -11841,7 +11842,7 @@\n-        if (avail < 2)\n-            goto done;\n-        cur = ctxt->input->cur[0];\n-        next = ctxt->input->cur[1];\n-            if ((cur == '<') && (next == '?')) {\n-            if ((!terminate) &&\n-                (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {\n+                if (avail < 2)\n+                    goto done;\n+                cur = ctxt->input->cur[0];\n+                next = ctxt->input->cur[1];\n+                if ((cur == '<') && (next == '?')) {\n+                    if ((!terminate) &&\n+                        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {\n@@ -11849,1 +11850,1 @@\n-            goto done;\n+                        goto done;\n@@ -11852,2 +11853,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: Parsing PI\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"PP: Parsing PI\\n\");\n@@ -11855,4 +11856,4 @@\n-            xmlParsePI(ctxt);\n-            if (ctxt->instate == XML_PARSER_EOF)\n-            goto done;\n-            ctxt->instate = XML_PARSER_PROLOG;\n+                    xmlParsePI(ctxt);\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n+                    ctxt->instate = XML_PARSER_PROLOG;\n@@ -11860,4 +11861,4 @@\n-        } else if ((cur == '<') && (next == '!') &&\n-            (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {\n-            if ((!terminate) &&\n-                (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {\n+                } else if ((cur == '<') && (next == '!') &&\n+                    (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {\n+                    if ((!terminate) &&\n+                        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {\n@@ -11865,1 +11866,1 @@\n-            goto done;\n+                        goto done;\n@@ -11868,2 +11869,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: Parsing Comment\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"PP: Parsing Comment\\n\");\n@@ -11871,4 +11872,4 @@\n-            xmlParseComment(ctxt);\n-            if (ctxt->instate == XML_PARSER_EOF)\n-            goto done;\n-            ctxt->instate = XML_PARSER_PROLOG;\n+                    xmlParseComment(ctxt);\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n+                    ctxt->instate = XML_PARSER_PROLOG;\n@@ -11876,8 +11877,8 @@\n-        } else if ((cur == '<') && (next == '!') &&\n-                   (avail < 4)) {\n-            goto done;\n-        } else {\n-            ctxt->instate = XML_PARSER_START_TAG;\n-            if (ctxt->progressive == 0)\n-            ctxt->progressive = XML_PARSER_START_TAG;\n-            xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n+                } else if ((cur == '<') && (next == '!') &&\n+                           (avail < 4)) {\n+                    goto done;\n+                } else {\n+                    ctxt->instate = XML_PARSER_START_TAG;\n+                    if (ctxt->progressive == 0)\n+                        ctxt->progressive = XML_PARSER_START_TAG;\n+                    xmlParseGetLasts(ctxt, &lastlt, &lastgt);\n@@ -11885,2 +11886,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: entering START_TAG\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"PP: entering START_TAG\\n\");\n@@ -11888,2 +11889,2 @@\n-        }\n-        break;\n+                }\n+                break;\n@@ -11891,5 +11892,5 @@\n-        SKIP_BLANKS;\n-        if (ctxt->input->buf == NULL)\n-            avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);\n-        else\n-            avail = xmlBufUse(ctxt->input->buf->buffer) -\n+                SKIP_BLANKS;\n+                if (ctxt->input->buf == NULL)\n+                    avail = ctxt->input->length - (ctxt->input->cur - ctxt->input->base);\n+                else\n+                    avail = xmlBufUse(ctxt->input->buf->buffer) -\n@@ -11897,7 +11898,7 @@\n-        if (avail < 2)\n-            goto done;\n-        cur = ctxt->input->cur[0];\n-        next = ctxt->input->cur[1];\n-            if ((cur == '<') && (next == '?')) {\n-            if ((!terminate) &&\n-                (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {\n+                if (avail < 2)\n+                    goto done;\n+                cur = ctxt->input->cur[0];\n+                next = ctxt->input->cur[1];\n+                if ((cur == '<') && (next == '?')) {\n+                    if ((!terminate) &&\n+                        (xmlParseLookupSequence(ctxt, '?', '>', 0) < 0)) {\n@@ -11905,1 +11906,1 @@\n-            goto done;\n+                        goto done;\n@@ -11908,2 +11909,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: Parsing PI\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"PP: Parsing PI\\n\");\n@@ -11911,4 +11912,4 @@\n-            xmlParsePI(ctxt);\n-            if (ctxt->instate == XML_PARSER_EOF)\n-            goto done;\n-            ctxt->instate = XML_PARSER_EPILOG;\n+                    xmlParsePI(ctxt);\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n+                    ctxt->instate = XML_PARSER_EPILOG;\n@@ -11916,4 +11917,4 @@\n-        } else if ((cur == '<') && (next == '!') &&\n-            (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {\n-            if ((!terminate) &&\n-                (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {\n+                } else if ((cur == '<') && (next == '!') &&\n+                    (ctxt->input->cur[2] == '-') && (ctxt->input->cur[3] == '-')) {\n+                    if ((!terminate) &&\n+                        (xmlParseLookupSequence(ctxt, '-', '-', '>') < 0)) {\n@@ -11921,1 +11922,1 @@\n-            goto done;\n+                        goto done;\n@@ -11924,2 +11925,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: Parsing Comment\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"PP: Parsing Comment\\n\");\n@@ -11927,4 +11928,4 @@\n-            xmlParseComment(ctxt);\n-            if (ctxt->instate == XML_PARSER_EOF)\n-            goto done;\n-            ctxt->instate = XML_PARSER_EPILOG;\n+                    xmlParseComment(ctxt);\n+                    if (ctxt->instate == XML_PARSER_EOF)\n+                        goto done;\n+                    ctxt->instate = XML_PARSER_EPILOG;\n@@ -11932,6 +11933,6 @@\n-        } else if ((cur == '<') && (next == '!') &&\n-                   (avail < 4)) {\n-            goto done;\n-        } else {\n-            xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n-            xmlHaltParser(ctxt);\n+                } else if ((cur == '<') && (next == '!') &&\n+                           (avail < 4)) {\n+                    goto done;\n+                } else {\n+                    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n+                    xmlHaltParser(ctxt);\n@@ -11939,2 +11940,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: entering EOF\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"PP: entering EOF\\n\");\n@@ -11942,5 +11943,5 @@\n-            if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n-            ctxt->sax->endDocument(ctxt->userData);\n-            goto done;\n-        }\n-        break;\n+                    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n+                        ctxt->sax->endDocument(ctxt->userData);\n+                    goto done;\n+                }\n+                break;\n@@ -11948,13 +11949,13 @@\n-            \/*\n-         * Sorry but progressive parsing of the internal subset\n-         * is not expected to be supported. We first check that\n-         * the full content of the internal subset is available and\n-         * the parsing is launched only at that point.\n-         * Internal subset ends up with \"']' S? '>'\" in an unescaped\n-         * section and not in a ']]>' sequence which are conditional\n-         * sections (whoever argued to keep that crap in XML deserve\n-         * a place in hell !).\n-         *\/\n-        int base, i;\n-        xmlChar *buf;\n-            xmlChar quote = 0;\n+                \/*\n+                 * Sorry but progressive parsing of the internal subset\n+                 * is not expected to be supported. We first check that\n+                 * the full content of the internal subset is available and\n+                 * the parsing is launched only at that point.\n+                 * Internal subset ends up with \"']' S? '>'\" in an unescaped\n+                 * section and not in a ']]>' sequence which are conditional\n+                 * sections (whoever argued to keep that crap in XML deserve\n+                 * a place in hell !).\n+                 *\/\n+                int base, i;\n+                xmlChar *buf;\n+                xmlChar quote = 0;\n@@ -11963,5 +11964,5 @@\n-        base = ctxt->input->cur - ctxt->input->base;\n-        if (base < 0) return(0);\n-        if (ctxt->checkIndex > base)\n-            base = ctxt->checkIndex;\n-        buf = xmlBufContent(ctxt->input->buf->buffer);\n+                base = ctxt->input->cur - ctxt->input->base;\n+                if (base < 0) return(0);\n+                if (ctxt->checkIndex > base)\n+                    base = ctxt->checkIndex;\n+                buf = xmlBufContent(ctxt->input->buf->buffer);\n@@ -11969,21 +11970,5 @@\n-        for (;(unsigned int) base < use; base++) {\n-            if (quote != 0) {\n-                if (buf[base] == quote)\n-                quote = 0;\n-            continue;\n-            }\n-            if ((quote == 0) && (buf[base] == '<')) {\n-                int found  = 0;\n-            \/* special handling of comments *\/\n-                if (((unsigned int) base + 4 < use) &&\n-                (buf[base + 1] == '!') &&\n-                (buf[base + 2] == '-') &&\n-                (buf[base + 3] == '-')) {\n-                for (;(unsigned int) base + 3 < use; base++) {\n-                if ((buf[base] == '-') &&\n-                    (buf[base + 1] == '-') &&\n-                    (buf[base + 2] == '>')) {\n-                    found = 1;\n-                    base += 2;\n-                    break;\n-                }\n+                for (;(unsigned int) base < use; base++) {\n+                    if (quote != 0) {\n+                        if (buf[base] == quote)\n+                            quote = 0;\n+                        continue;\n@@ -11991,1 +11976,17 @@\n-                if (!found) {\n+                    if ((quote == 0) && (buf[base] == '<')) {\n+                        int found  = 0;\n+                        \/* special handling of comments *\/\n+                        if (((unsigned int) base + 4 < use) &&\n+                            (buf[base + 1] == '!') &&\n+                            (buf[base + 2] == '-') &&\n+                            (buf[base + 3] == '-')) {\n+                            for (;(unsigned int) base + 3 < use; base++) {\n+                                if ((buf[base] == '-') &&\n+                                    (buf[base + 1] == '-') &&\n+                                    (buf[base + 2] == '>')) {\n+                                    found = 1;\n+                                    base += 2;\n+                                    break;\n+                                }\n+                            }\n+                            if (!found) {\n@@ -11993,1 +11994,1 @@\n-                    fprintf(stderr, \"unfinished comment\\n\");\n+                                fprintf(stderr, \"unfinished comment\\n\");\n@@ -11995,1 +11996,4 @@\n-                    break; \/* for *\/\n+                                break; \/* for *\/\n+                            }\n+                            continue;\n+                        }\n@@ -11997,12 +12001,9 @@\n-                    continue;\n-            }\n-            }\n-            if (buf[base] == '\"') {\n-                quote = '\"';\n-            continue;\n-            }\n-            if (buf[base] == '\\'') {\n-                quote = '\\'';\n-            continue;\n-            }\n-            if (buf[base] == ']') {\n+                    if (buf[base] == '\"') {\n+                        quote = '\"';\n+                        continue;\n+                    }\n+                    if (buf[base] == '\\'') {\n+                        quote = '\\'';\n+                        continue;\n+                    }\n+                    if (buf[base] == ']') {\n@@ -12010,2 +12011,2 @@\n-                fprintf(stderr, \"%c%c%c%c: \", buf[base],\n-                    buf[base + 1], buf[base + 2], buf[base + 3]);\n+                        fprintf(stderr, \"%c%c%c%c: \", buf[base],\n+                                buf[base + 1], buf[base + 2], buf[base + 3]);\n@@ -12013,9 +12014,9 @@\n-                if ((unsigned int) base +1 >= use)\n-                break;\n-            if (buf[base + 1] == ']') {\n-                \/* conditional crap, skip both ']' ! *\/\n-                base++;\n-                continue;\n-            }\n-                for (i = 1; (unsigned int) base + i < use; i++) {\n-                if (buf[base + i] == '>') {\n+                        if ((unsigned int) base +1 >= use)\n+                            break;\n+                        if (buf[base + 1] == ']') {\n+                            \/* conditional crap, skip both ']' ! *\/\n+                            base++;\n+                            continue;\n+                        }\n+                        for (i = 1; (unsigned int) base + i < use; i++) {\n+                            if (buf[base + i] == '>') {\n@@ -12023,1 +12024,1 @@\n-                    fprintf(stderr, \"found\\n\");\n+                                fprintf(stderr, \"found\\n\");\n@@ -12025,3 +12026,3 @@\n-                    goto found_end_int_subset;\n-                }\n-                if (!IS_BLANK_CH(buf[base + i])) {\n+                                goto found_end_int_subset;\n+                            }\n+                            if (!IS_BLANK_CH(buf[base + i])) {\n@@ -12029,1 +12030,1 @@\n-                    fprintf(stderr, \"not found\\n\");\n+                                fprintf(stderr, \"not found\\n\");\n@@ -12031,3 +12032,3 @@\n-                    goto not_end_of_int_subset;\n-                }\n-            }\n+                                goto not_end_of_int_subset;\n+                            }\n+                        }\n@@ -12035,1 +12036,1 @@\n-            fprintf(stderr, \"end of stream\\n\");\n+                        fprintf(stderr, \"end of stream\\n\");\n@@ -12037,1 +12038,1 @@\n-                break;\n+                        break;\n@@ -12039,1 +12040,1 @@\n-            }\n+                    }\n@@ -12042,4 +12043,4 @@\n-        }\n-        \/*\n-         * We didn't found the end of the Internal subset\n-         *\/\n+                }\n+                \/*\n+                 * We didn't found the end of the Internal subset\n+                 *\/\n@@ -12051,3 +12052,3 @@\n-        if (next == 0)\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PP: lookup of int subset end filed\\n\");\n+                if (next == 0)\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"PP: lookup of int subset end filed\\n\");\n@@ -12055,1 +12056,1 @@\n-            goto done;\n+                goto done;\n@@ -12059,14 +12060,14 @@\n-        xmlParseInternalSubset(ctxt);\n-        if (ctxt->instate == XML_PARSER_EOF)\n-            goto done;\n-        ctxt->inSubset = 2;\n-        if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n-            (ctxt->sax->externalSubset != NULL))\n-            ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\n-                ctxt->extSubSystem, ctxt->extSubURI);\n-        ctxt->inSubset = 0;\n-        xmlCleanSpecialAttr(ctxt);\n-        if (ctxt->instate == XML_PARSER_EOF)\n-            goto done;\n-        ctxt->instate = XML_PARSER_PROLOG;\n-        ctxt->checkIndex = 0;\n+                xmlParseInternalSubset(ctxt);\n+                if (ctxt->instate == XML_PARSER_EOF)\n+                    goto done;\n+                ctxt->inSubset = 2;\n+                if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n+                    (ctxt->sax->externalSubset != NULL))\n+                    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\n+                            ctxt->extSubSystem, ctxt->extSubURI);\n+                ctxt->inSubset = 0;\n+                xmlCleanSpecialAttr(ctxt);\n+                if (ctxt->instate == XML_PARSER_EOF)\n+                    goto done;\n+                ctxt->instate = XML_PARSER_PROLOG;\n+                ctxt->checkIndex = 0;\n@@ -12074,2 +12075,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: entering PROLOG\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: entering PROLOG\\n\");\n@@ -12078,1 +12079,1 @@\n-        }\n+            }\n@@ -12080,3 +12081,3 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: internal error, state == COMMENT\\n\");\n-        ctxt->instate = XML_PARSER_CONTENT;\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: internal error, state == COMMENT\\n\");\n+                ctxt->instate = XML_PARSER_CONTENT;\n@@ -12084,2 +12085,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: entering CONTENT\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: entering CONTENT\\n\");\n@@ -12087,5 +12088,5 @@\n-        break;\n-            case XML_PARSER_IGNORE:\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: internal error, state == IGNORE\");\n-            ctxt->instate = XML_PARSER_DTD;\n+                break;\n+            case XML_PARSER_IGNORE:\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: internal error, state == IGNORE\");\n+                ctxt->instate = XML_PARSER_DTD;\n@@ -12093,2 +12094,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: entering DTD\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: entering DTD\\n\");\n@@ -12096,1 +12097,1 @@\n-            break;\n+                break;\n@@ -12098,3 +12099,3 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: internal error, state == PI\\n\");\n-        ctxt->instate = XML_PARSER_CONTENT;\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: internal error, state == PI\\n\");\n+                ctxt->instate = XML_PARSER_CONTENT;\n@@ -12102,2 +12103,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: entering CONTENT\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: entering CONTENT\\n\");\n@@ -12105,1 +12106,1 @@\n-        break;\n+                break;\n@@ -12107,3 +12108,3 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: internal error, state == ENTITY_DECL\\n\");\n-        ctxt->instate = XML_PARSER_DTD;\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: internal error, state == ENTITY_DECL\\n\");\n+                ctxt->instate = XML_PARSER_DTD;\n@@ -12111,2 +12112,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: entering DTD\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: entering DTD\\n\");\n@@ -12114,1 +12115,1 @@\n-        break;\n+                break;\n@@ -12116,3 +12117,3 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: internal error, state == ENTITY_VALUE\\n\");\n-        ctxt->instate = XML_PARSER_CONTENT;\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: internal error, state == ENTITY_VALUE\\n\");\n+                ctxt->instate = XML_PARSER_CONTENT;\n@@ -12120,2 +12121,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: entering DTD\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: entering DTD\\n\");\n@@ -12123,1 +12124,1 @@\n-        break;\n+                break;\n@@ -12125,3 +12126,3 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: internal error, state == ATTRIBUTE_VALUE\\n\");\n-        ctxt->instate = XML_PARSER_START_TAG;\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: internal error, state == ATTRIBUTE_VALUE\\n\");\n+                ctxt->instate = XML_PARSER_START_TAG;\n@@ -12129,2 +12130,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: entering START_TAG\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: entering START_TAG\\n\");\n@@ -12132,1 +12133,1 @@\n-        break;\n+                break;\n@@ -12134,3 +12135,3 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: internal error, state == SYSTEM_LITERAL\\n\");\n-        ctxt->instate = XML_PARSER_START_TAG;\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: internal error, state == SYSTEM_LITERAL\\n\");\n+                ctxt->instate = XML_PARSER_START_TAG;\n@@ -12138,2 +12139,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: entering START_TAG\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: entering START_TAG\\n\");\n@@ -12141,1 +12142,1 @@\n-        break;\n+                break;\n@@ -12143,3 +12144,3 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: internal error, state == PUBLIC_LITERAL\\n\");\n-        ctxt->instate = XML_PARSER_START_TAG;\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: internal error, state == PUBLIC_LITERAL\\n\");\n+                ctxt->instate = XML_PARSER_START_TAG;\n@@ -12147,2 +12148,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PP: entering START_TAG\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PP: entering START_TAG\\n\");\n@@ -12150,2 +12151,2 @@\n-        break;\n-    }\n+                break;\n+        }\n@@ -12162,6 +12163,6 @@\n-    snprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n-            ctxt->input->cur[0], ctxt->input->cur[1],\n-            ctxt->input->cur[2], ctxt->input->cur[3]);\n-    __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n-             \"Input is not proper UTF-8, indicate encoding !\\n%s\",\n-             BAD_CAST buffer, NULL);\n+        snprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n+                        ctxt->input->cur[0], ctxt->input->cur[1],\n+                        ctxt->input->cur[2], ctxt->input->cur[3]);\n+        __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n+                     \"Input is not proper UTF-8, indicate encoding !\\n%s\",\n+                     BAD_CAST buffer, NULL);\n@@ -12250,2 +12251,2 @@\n-    end_in_lf = 1;\n-    size--;\n+        end_in_lf = 1;\n+        size--;\n@@ -12258,3 +12259,3 @@\n-    size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n-    size_t cur = ctxt->input->cur - ctxt->input->base;\n-    int res;\n+        size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n+        size_t cur = ctxt->input->cur - ctxt->input->base;\n+        int res;\n@@ -12298,1 +12299,1 @@\n-    res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n+        res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n@@ -12300,5 +12301,5 @@\n-    if (res < 0) {\n-        ctxt->errNo = XML_PARSER_EOF;\n-        xmlHaltParser(ctxt);\n-        return (XML_PARSER_EOF);\n-    }\n+        if (res < 0) {\n+            ctxt->errNo = XML_PARSER_EOF;\n+            xmlHaltParser(ctxt);\n+            return (XML_PARSER_EOF);\n+        }\n@@ -12306,1 +12307,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"PP: pushed %d\\n\", size);\n+        xmlGenericError(xmlGenericErrorContext, \"PP: pushed %d\\n\", size);\n@@ -12310,14 +12311,14 @@\n-    if ((ctxt->input != NULL) && ctxt->input->buf != NULL) {\n-        xmlParserInputBufferPtr in = ctxt->input->buf;\n-        if ((in->encoder != NULL) && (in->buffer != NULL) &&\n-            (in->raw != NULL)) {\n-        int nbchars;\n-        size_t base = xmlBufGetInputBase(in->buffer, ctxt->input);\n-        size_t current = ctxt->input->cur - ctxt->input->base;\n-\n-        nbchars = xmlCharEncInput(in, terminate);\n-        xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);\n-        if (nbchars < 0) {\n-            \/* TODO 2.6.0 *\/\n-            xmlGenericError(xmlGenericErrorContext,\n-                    \"xmlParseChunk: encoder error\\n\");\n+        if ((ctxt->input != NULL) && ctxt->input->buf != NULL) {\n+            xmlParserInputBufferPtr in = ctxt->input->buf;\n+            if ((in->encoder != NULL) && (in->buffer != NULL) &&\n+                    (in->raw != NULL)) {\n+                int nbchars;\n+                size_t base = xmlBufGetInputBase(in->buffer, ctxt->input);\n+                size_t current = ctxt->input->cur - ctxt->input->base;\n+\n+                nbchars = xmlCharEncInput(in, terminate);\n+                xmlBufSetInputBaseCur(in->buffer, ctxt->input, base, current);\n+                if (nbchars < 0) {\n+                    \/* TODO 2.6.0 *\/\n+                    xmlGenericError(xmlGenericErrorContext,\n+                                    \"xmlParseChunk: encoder error\\n\");\n@@ -12325,2 +12326,3 @@\n-            return(XML_ERR_INVALID_ENCODING);\n-        }\n+                    return(XML_ERR_INVALID_ENCODING);\n+                }\n+            }\n@@ -12329,1 +12331,0 @@\n-    }\n@@ -12369,3 +12370,3 @@\n-    size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer,\n-                     ctxt->input);\n-    size_t current = ctxt->input->cur - ctxt->input->base;\n+        size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer,\n+                                         ctxt->input);\n+        size_t current = ctxt->input->cur - ctxt->input->base;\n@@ -12373,1 +12374,1 @@\n-    xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n+        xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n@@ -12375,2 +12376,2 @@\n-    xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input,\n-                  base, current);\n+        xmlBufSetInputBaseCur(ctxt->input->buf->buffer, ctxt->input,\n+                              base, current);\n@@ -12379,4 +12380,4 @@\n-    \/*\n-     * Check for termination\n-     *\/\n-    int cur_avail = 0;\n+        \/*\n+         * Check for termination\n+         *\/\n+        int cur_avail = 0;\n@@ -12384,8 +12385,8 @@\n-    if (ctxt->input != NULL) {\n-        if (ctxt->input->buf == NULL)\n-        cur_avail = ctxt->input->length -\n-                (ctxt->input->cur - ctxt->input->base);\n-        else\n-        cur_avail = xmlBufUse(ctxt->input->buf->buffer) -\n-                          (ctxt->input->cur - ctxt->input->base);\n-    }\n+        if (ctxt->input != NULL) {\n+            if (ctxt->input->buf == NULL)\n+                cur_avail = ctxt->input->length -\n+                            (ctxt->input->cur - ctxt->input->base);\n+            else\n+                cur_avail = xmlBufUse(ctxt->input->buf->buffer) -\n+                                      (ctxt->input->cur - ctxt->input->base);\n+        }\n@@ -12393,12 +12394,12 @@\n-    if ((ctxt->instate != XML_PARSER_EOF) &&\n-        (ctxt->instate != XML_PARSER_EPILOG)) {\n-        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n-    }\n-    if ((ctxt->instate == XML_PARSER_EPILOG) && (cur_avail > 0)) {\n-        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n-    }\n-    if (ctxt->instate != XML_PARSER_EOF) {\n-        if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n-        ctxt->sax->endDocument(ctxt->userData);\n-    }\n-    ctxt->instate = XML_PARSER_EOF;\n+        if ((ctxt->instate != XML_PARSER_EOF) &&\n+            (ctxt->instate != XML_PARSER_EPILOG)) {\n+            xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n+        }\n+        if ((ctxt->instate == XML_PARSER_EPILOG) && (cur_avail > 0)) {\n+            xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n+        }\n+        if (ctxt->instate != XML_PARSER_EOF) {\n+            if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n+                ctxt->sax->endDocument(ctxt->userData);\n+        }\n+        ctxt->instate = XML_PARSER_EOF;\n@@ -12407,1 +12408,1 @@\n-    return((xmlParserErrors) ctxt->errNo);\n+        return((xmlParserErrors) ctxt->errNo);\n@@ -12413,3 +12414,3 @@\n- *                                  *\n- *      I\/O front end functions to the parser           *\n- *                                  *\n+ *                                                                      *\n+ *              I\/O front end functions to the parser                   *\n+ *                                                                      *\n@@ -12449,1 +12450,1 @@\n-    enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);\n+        enc = xmlDetectCharEncoding((const xmlChar *) chunk, size);\n@@ -12457,2 +12458,2 @@\n-    xmlFreeParserInputBuffer(buf);\n-    return(NULL);\n+        xmlFreeParserInputBuffer(buf);\n+        return(NULL);\n@@ -12463,1 +12464,1 @@\n-    if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)\n+        if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)\n@@ -12465,15 +12466,15 @@\n-        xmlFree(ctxt->sax);\n-    ctxt->sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));\n-    if (ctxt->sax == NULL) {\n-        xmlErrMemory(ctxt, NULL);\n-        xmlFreeParserInputBuffer(buf);\n-        xmlFreeParserCtxt(ctxt);\n-        return(NULL);\n-    }\n-    memset(ctxt->sax, 0, sizeof(xmlSAXHandler));\n-    if (sax->initialized == XML_SAX2_MAGIC)\n-        memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));\n-    else\n-        memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));\n-    if (user_data != NULL)\n-        ctxt->userData = user_data;\n+            xmlFree(ctxt->sax);\n+        ctxt->sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));\n+        if (ctxt->sax == NULL) {\n+            xmlErrMemory(ctxt, NULL);\n+            xmlFreeParserInputBuffer(buf);\n+            xmlFreeParserCtxt(ctxt);\n+            return(NULL);\n+        }\n+        memset(ctxt->sax, 0, sizeof(xmlSAXHandler));\n+        if (sax->initialized == XML_SAX2_MAGIC)\n+            memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));\n+        else\n+            memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));\n+        if (user_data != NULL)\n+            ctxt->userData = user_data;\n@@ -12482,1 +12483,1 @@\n-    ctxt->directory = NULL;\n+        ctxt->directory = NULL;\n@@ -12489,11 +12490,0 @@\n-    xmlFreeParserCtxt(ctxt);\n-    xmlFreeParserInputBuffer(buf);\n-    return(NULL);\n-    }\n-\n-    if (filename == NULL)\n-    inputStream->filename = NULL;\n-    else {\n-    inputStream->filename = (char *)\n-        xmlCanonicPath((const xmlChar *) filename);\n-    if (inputStream->filename == NULL) {\n@@ -12504,0 +12494,11 @@\n+\n+    if (filename == NULL)\n+        inputStream->filename = NULL;\n+    else {\n+        inputStream->filename = (char *)\n+            xmlCanonicPath((const xmlChar *) filename);\n+        if (inputStream->filename == NULL) {\n+            xmlFreeParserCtxt(ctxt);\n+            xmlFreeParserInputBuffer(buf);\n+            return(NULL);\n+        }\n@@ -12515,1 +12516,1 @@\n-    ctxt->charset = XML_CHAR_ENCODING_NONE;\n+        ctxt->charset = XML_CHAR_ENCODING_NONE;\n@@ -12517,2 +12518,2 @@\n-    size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n-    size_t cur = ctxt->input->cur - ctxt->input->base;\n+        size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n+        size_t cur = ctxt->input->cur - ctxt->input->base;\n@@ -12520,1 +12521,1 @@\n-    xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n+        xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n@@ -12524,1 +12525,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"PP: pushed %d\\n\", size);\n+        xmlGenericError(xmlGenericErrorContext, \"PP: pushed %d\\n\", size);\n@@ -12553,3 +12554,3 @@\n-     * in case there was a specific allocation deallocate before\n-     * overriding base\n-     *\/\n+         * in case there was a specific allocation deallocate before\n+         * overriding base\n+         *\/\n@@ -12557,3 +12558,3 @@\n-        ctxt->input->free((xmlChar *) ctxt->input->base);\n-        ctxt->input->free = NULL;\n-    }\n+            ctxt->input->free((xmlChar *) ctxt->input->base);\n+            ctxt->input->free = NULL;\n+        }\n@@ -12564,1 +12565,1 @@\n-    ctxt->input->cur = BAD_CAST\"\";\n+        ctxt->input->cur = BAD_CAST\"\";\n@@ -12566,1 +12567,1 @@\n-    ctxt->input->base = ctxt->input->cur;\n+        ctxt->input->base = ctxt->input->cur;\n@@ -12601,2 +12602,2 @@\n-    xmlInputReadCallback   ioread, xmlInputCloseCallback  ioclose,\n-    void *ioctx, xmlCharEncoding enc) {\n+        xmlInputReadCallback   ioread, xmlInputCloseCallback  ioclose,\n+        void *ioctx, xmlCharEncoding enc) {\n@@ -12618,2 +12619,2 @@\n-    xmlFreeParserInputBuffer(buf);\n-    return(NULL);\n+        xmlFreeParserInputBuffer(buf);\n+        return(NULL);\n@@ -12623,1 +12624,1 @@\n-    if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)\n+        if (ctxt->sax != (xmlSAXHandlerPtr) &xmlDefaultSAXHandler)\n@@ -12625,14 +12626,15 @@\n-        xmlFree(ctxt->sax);\n-    ctxt->sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));\n-    if (ctxt->sax == NULL) {\n-        xmlErrMemory(ctxt, NULL);\n-        xmlFreeParserCtxt(ctxt);\n-        return(NULL);\n-    }\n-    memset(ctxt->sax, 0, sizeof(xmlSAXHandler));\n-    if (sax->initialized == XML_SAX2_MAGIC)\n-        memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));\n-    else\n-        memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));\n-    if (user_data != NULL)\n-        ctxt->userData = user_data;\n+            xmlFree(ctxt->sax);\n+        ctxt->sax = (xmlSAXHandlerPtr) xmlMalloc(sizeof(xmlSAXHandler));\n+        if (ctxt->sax == NULL) {\n+            xmlFreeParserInputBuffer(buf);\n+            xmlErrMemory(ctxt, NULL);\n+            xmlFreeParserCtxt(ctxt);\n+            return(NULL);\n+        }\n+        memset(ctxt->sax, 0, sizeof(xmlSAXHandler));\n+        if (sax->initialized == XML_SAX2_MAGIC)\n+            memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));\n+        else\n+            memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));\n+        if (user_data != NULL)\n+            ctxt->userData = user_data;\n@@ -12643,2 +12645,2 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -12653,3 +12655,3 @@\n- *                                  *\n- *      Front ends when parsing a DTD               *\n- *                                  *\n+ *                                                                      *\n+ *              Front ends when parsing a DTD                           *\n+ *                                                                      *\n@@ -12672,1 +12674,1 @@\n-          xmlCharEncoding enc) {\n+              xmlCharEncoding enc) {\n@@ -12679,1 +12681,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -12684,1 +12686,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -12694,2 +12696,2 @@\n-    if (ctxt->sax != NULL)\n-        xmlFree(ctxt->sax);\n+        if (ctxt->sax != NULL)\n+            xmlFree(ctxt->sax);\n@@ -12709,2 +12711,2 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -12718,2 +12720,2 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -12738,2 +12740,2 @@\n-    xmlErrMemory(ctxt, \"New Doc failed\");\n-    return(NULL);\n+        xmlErrMemory(ctxt, \"New Doc failed\");\n+        return(NULL);\n@@ -12743,1 +12745,1 @@\n-                                   BAD_CAST \"none\", BAD_CAST \"none\");\n+                                       BAD_CAST \"none\", BAD_CAST \"none\");\n@@ -12747,13 +12749,13 @@\n-    \/*\n-     * Get the 4 first bytes and decode the charset\n-     * if enc != XML_CHAR_ENCODING_NONE\n-     * plug some encoding conversion routines.\n-     *\/\n-    start[0] = RAW;\n-    start[1] = NXT(1);\n-    start[2] = NXT(2);\n-    start[3] = NXT(3);\n-    enc = xmlDetectCharEncoding(start, 4);\n-    if (enc != XML_CHAR_ENCODING_NONE) {\n-        xmlSwitchEncoding(ctxt, enc);\n-    }\n+        \/*\n+         * Get the 4 first bytes and decode the charset\n+         * if enc != XML_CHAR_ENCODING_NONE\n+         * plug some encoding conversion routines.\n+         *\/\n+        start[0] = RAW;\n+        start[1] = NXT(1);\n+        start[2] = NXT(2);\n+        start[3] = NXT(3);\n+        enc = xmlDetectCharEncoding(start, 4);\n+        if (enc != XML_CHAR_ENCODING_NONE) {\n+            xmlSwitchEncoding(ctxt, enc);\n+        }\n@@ -12765,12 +12767,15 @@\n-    if (ctxt->wellFormed) {\n-        ret = ctxt->myDoc->extSubset;\n-        ctxt->myDoc->extSubset = NULL;\n-        if (ret != NULL) {\n-        xmlNodePtr tmp;\n-\n-        ret->doc = NULL;\n-        tmp = ret->children;\n-        while (tmp != NULL) {\n-            tmp->doc = NULL;\n-            tmp = tmp->next;\n-        }\n+        if (ctxt->wellFormed) {\n+            ret = ctxt->myDoc->extSubset;\n+            ctxt->myDoc->extSubset = NULL;\n+            if (ret != NULL) {\n+                xmlNodePtr tmp;\n+\n+                ret->doc = NULL;\n+                tmp = ret->children;\n+                while (tmp != NULL) {\n+                    tmp->doc = NULL;\n+                    tmp = tmp->next;\n+                }\n+            }\n+        } else {\n+            ret = NULL;\n@@ -12778,3 +12783,0 @@\n-    } else {\n-        ret = NULL;\n-    }\n@@ -12814,1 +12816,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -12824,2 +12826,2 @@\n-    if (ctxt->sax != NULL)\n-        xmlFree(ctxt->sax);\n+        if (ctxt->sax != NULL)\n+            xmlFree(ctxt->sax);\n@@ -12835,2 +12837,2 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -12844,2 +12846,2 @@\n-    input = ctxt->sax->resolveEntity(ctxt->userData, ExternalID,\n-                                     systemIdCanonic);\n+        input = ctxt->sax->resolveEntity(ctxt->userData, ExternalID,\n+                                         systemIdCanonic);\n@@ -12848,4 +12850,4 @@\n-    xmlFreeParserCtxt(ctxt);\n-    if (systemIdCanonic != NULL)\n-        xmlFree(systemIdCanonic);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        if (systemIdCanonic != NULL)\n+            xmlFree(systemIdCanonic);\n+        return(NULL);\n@@ -12859,4 +12861,4 @@\n-    xmlFreeParserCtxt(ctxt);\n-    if (systemIdCanonic != NULL)\n-        xmlFree(systemIdCanonic);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        if (systemIdCanonic != NULL)\n+            xmlFree(systemIdCanonic);\n+        return(NULL);\n@@ -12865,2 +12867,2 @@\n-    enc = xmlDetectCharEncoding(ctxt->input->cur, 4);\n-    xmlSwitchEncoding(ctxt, enc);\n+        enc = xmlDetectCharEncoding(ctxt->input->cur, 4);\n+        xmlSwitchEncoding(ctxt, enc);\n@@ -12870,1 +12872,1 @@\n-    input->filename = (char *) systemIdCanonic;\n+        input->filename = (char *) systemIdCanonic;\n@@ -12872,1 +12874,1 @@\n-    xmlFree(systemIdCanonic);\n+        xmlFree(systemIdCanonic);\n@@ -12885,1 +12887,1 @@\n-    xmlErrMemory(ctxt, \"New Doc failed\");\n+        xmlErrMemory(ctxt, \"New Doc failed\");\n@@ -12887,2 +12889,2 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -12892,1 +12894,1 @@\n-                                   ExternalID, SystemID);\n+                                       ExternalID, SystemID);\n@@ -12896,12 +12898,15 @@\n-    if (ctxt->wellFormed) {\n-        ret = ctxt->myDoc->extSubset;\n-        ctxt->myDoc->extSubset = NULL;\n-        if (ret != NULL) {\n-        xmlNodePtr tmp;\n-\n-        ret->doc = NULL;\n-        tmp = ret->children;\n-        while (tmp != NULL) {\n-            tmp->doc = NULL;\n-            tmp = tmp->next;\n-        }\n+        if (ctxt->wellFormed) {\n+            ret = ctxt->myDoc->extSubset;\n+            ctxt->myDoc->extSubset = NULL;\n+            if (ret != NULL) {\n+                xmlNodePtr tmp;\n+\n+                ret->doc = NULL;\n+                tmp = ret->children;\n+                while (tmp != NULL) {\n+                    tmp->doc = NULL;\n+                    tmp = tmp->next;\n+                }\n+            }\n+        } else {\n+            ret = NULL;\n@@ -12909,3 +12914,0 @@\n-    } else {\n-        ret = NULL;\n-    }\n@@ -12939,3 +12941,3 @@\n- *                                  *\n- *      Front ends when parsing an Entity           *\n- *                                  *\n+ *                                                                      *\n+ *              Front ends when parsing an Entity                       *\n+ *                                                                      *\n@@ -12963,1 +12965,1 @@\n-                   const xmlChar *ID, xmlNodePtr *lst) {\n+                       const xmlChar *ID, xmlNodePtr *lst) {\n@@ -13000,3 +13002,3 @@\n-                  xmlSAXHandlerPtr sax,\n-              void *user_data, int depth, const xmlChar *URL,\n-              const xmlChar *ID, xmlNodePtr *list) {\n+                      xmlSAXHandlerPtr sax,\n+                      void *user_data, int depth, const xmlChar *URL,\n+                      const xmlChar *ID, xmlNodePtr *list) {\n@@ -13012,3 +13014,3 @@\n-    ((oldctxt == NULL) || (oldctxt->options & XML_PARSE_HUGE) == 0)) ||\n-    (depth > 1024)) {\n-    return(XML_ERR_ENTITY_LOOP);\n+        ((oldctxt == NULL) || (oldctxt->options & XML_PARSE_HUGE) == 0)) ||\n+        (depth > 1024)) {\n+        return(XML_ERR_ENTITY_LOOP);\n@@ -13020,1 +13022,1 @@\n-    return(XML_ERR_INTERNAL_ERROR);\n+        return(XML_ERR_INTERNAL_ERROR);\n@@ -13022,1 +13024,1 @@\n-    return(XML_ERR_INTERNAL_ERROR);\n+        return(XML_ERR_INTERNAL_ERROR);\n@@ -13029,1 +13031,1 @@\n-    oldsax = ctxt->sax;\n+        oldsax = ctxt->sax;\n@@ -13031,2 +13033,2 @@\n-    if (user_data != NULL)\n-        ctxt->userData = user_data;\n+        if (user_data != NULL)\n+            ctxt->userData = user_data;\n@@ -13037,2 +13039,2 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(XML_ERR_INTERNAL_ERROR);\n+        xmlFreeParserCtxt(ctxt);\n+        return(XML_ERR_INTERNAL_ERROR);\n@@ -13054,5 +13056,5 @@\n-    if (sax != NULL)\n-        ctxt->sax = oldsax;\n-    xmlFreeParserCtxt(ctxt);\n-    newDoc->intSubset = NULL;\n-    newDoc->extSubset = NULL;\n+        if (sax != NULL)\n+            ctxt->sax = oldsax;\n+        xmlFreeParserCtxt(ctxt);\n+        newDoc->intSubset = NULL;\n+        newDoc->extSubset = NULL;\n@@ -13060,1 +13062,1 @@\n-    return(XML_ERR_INTERNAL_ERROR);\n+        return(XML_ERR_INTERNAL_ERROR);\n@@ -13078,8 +13080,8 @@\n-    start[0] = RAW;\n-    start[1] = NXT(1);\n-    start[2] = NXT(2);\n-    start[3] = NXT(3);\n-    enc = xmlDetectCharEncoding(start, 4);\n-    if (enc != XML_CHAR_ENCODING_NONE) {\n-        xmlSwitchEncoding(ctxt, enc);\n-    }\n+        start[0] = RAW;\n+        start[1] = NXT(1);\n+        start[2] = NXT(2);\n+        start[3] = NXT(3);\n+        enc = xmlDetectCharEncoding(start, 4);\n+        if (enc != XML_CHAR_ENCODING_NONE) {\n+            xmlSwitchEncoding(ctxt, enc);\n+        }\n@@ -13092,1 +13094,1 @@\n-    xmlParseTextDecl(ctxt);\n+        xmlParseTextDecl(ctxt);\n@@ -13106,5 +13108,5 @@\n-    ctxt->_private = oldctxt->_private;\n-    ctxt->loadsubset = oldctxt->loadsubset;\n-    ctxt->validate = oldctxt->validate;\n-    ctxt->valid = oldctxt->valid;\n-    ctxt->replaceEntities = oldctxt->replaceEntities;\n+        ctxt->_private = oldctxt->_private;\n+        ctxt->loadsubset = oldctxt->loadsubset;\n+        ctxt->validate = oldctxt->validate;\n+        ctxt->valid = oldctxt->valid;\n+        ctxt->replaceEntities = oldctxt->replaceEntities;\n@@ -13116,1 +13118,1 @@\n-    ctxt->external = oldctxt->external;\n+        ctxt->external = oldctxt->external;\n@@ -13126,4 +13128,4 @@\n-    ctxt->record_info = oldctxt->record_info;\n-    ctxt->node_seq.maximum = oldctxt->node_seq.maximum;\n-    ctxt->node_seq.length = oldctxt->node_seq.length;\n-    ctxt->node_seq.buffer = oldctxt->node_seq.buffer;\n+        ctxt->record_info = oldctxt->record_info;\n+        ctxt->node_seq.maximum = oldctxt->node_seq.maximum;\n+        ctxt->node_seq.length = oldctxt->node_seq.length;\n+        ctxt->node_seq.buffer = oldctxt->node_seq.buffer;\n@@ -13131,8 +13133,8 @@\n-    \/*\n-     * Doing validity checking on chunk without context\n-     * doesn't make sense\n-     *\/\n-    ctxt->_private = NULL;\n-    ctxt->validate = 0;\n-    ctxt->external = 2;\n-    ctxt->loadsubset = 0;\n+        \/*\n+         * Doing validity checking on chunk without context\n+         * doesn't make sense\n+         *\/\n+        ctxt->_private = NULL;\n+        ctxt->validate = 0;\n+        ctxt->external = 2;\n+        ctxt->loadsubset = 0;\n@@ -13144,1 +13146,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n@@ -13146,1 +13148,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n@@ -13149,23 +13151,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n-    }\n-\n-    if (!ctxt->wellFormed) {\n-        if (ctxt->errNo == 0)\n-        ret = XML_ERR_INTERNAL_ERROR;\n-    else\n-        ret = (xmlParserErrors)ctxt->errNo;\n-    } else {\n-    if (list != NULL) {\n-        xmlNodePtr cur;\n-\n-        \/*\n-         * Return the newly created nodeset after unlinking it from\n-         * they pseudo parent.\n-         *\/\n-        cur = newDoc->children->children;\n-        *list = cur;\n-        while (cur != NULL) {\n-        cur->parent = NULL;\n-        cur = cur->next;\n-        }\n-            newDoc->children->children = NULL;\n+        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n@@ -13173,1 +13153,23 @@\n-    ret = XML_ERR_OK;\n+\n+    if (!ctxt->wellFormed) {\n+        if (ctxt->errNo == 0)\n+            ret = XML_ERR_INTERNAL_ERROR;\n+        else\n+            ret = (xmlParserErrors)ctxt->errNo;\n+    } else {\n+        if (list != NULL) {\n+            xmlNodePtr cur;\n+\n+            \/*\n+             * Return the newly created nodeset after unlinking it from\n+             * they pseudo parent.\n+             *\/\n+            cur = newDoc->children->children;\n+            *list = cur;\n+            while (cur != NULL) {\n+                cur->parent = NULL;\n+                cur = cur->next;\n+            }\n+            newDoc->children->children = NULL;\n+        }\n+        ret = XML_ERR_OK;\n@@ -13187,2 +13189,2 @@\n-    oldctxt->sizeentities += ctxt->input->consumed;\n-    oldctxt->sizeentities += (ctxt->input->cur - ctxt->input->base);\n+        oldctxt->sizeentities += ctxt->input->consumed;\n+        oldctxt->sizeentities += (ctxt->input->cur - ctxt->input->base);\n@@ -13197,1 +13199,1 @@\n-    ctxt->sax = oldsax;\n+        ctxt->sax = oldsax;\n@@ -13242,1 +13244,1 @@\n-      int depth, const xmlChar *URL, const xmlChar *ID, xmlNodePtr *lst) {\n+          int depth, const xmlChar *URL, const xmlChar *ID, xmlNodePtr *lst) {\n@@ -13244,1 +13246,1 @@\n-                               ID, lst));\n+                                       ID, lst));\n@@ -13298,1 +13300,1 @@\n-    const xmlChar *string, void *user_data, xmlNodePtr *lst) {\n+        const xmlChar *string, void *user_data, xmlNodePtr *lst) {\n@@ -13313,1 +13315,1 @@\n-    return(XML_ERR_ENTITY_LOOP);\n+        return(XML_ERR_ENTITY_LOOP);\n@@ -13327,1 +13329,1 @@\n-    ctxt->userData = user_data;\n+        ctxt->userData = user_data;\n@@ -13329,1 +13331,1 @@\n-    ctxt->userData = ctxt;\n+        ctxt->userData = ctxt;\n@@ -13352,11 +13354,11 @@\n-    newDoc = xmlNewDoc(BAD_CAST \"1.0\");\n-    if (newDoc == NULL) {\n-        ctxt->sax = oldsax;\n-        ctxt->dict = NULL;\n-        xmlFreeParserCtxt(ctxt);\n-        return(XML_ERR_INTERNAL_ERROR);\n-    }\n-    newDoc->properties = XML_DOC_INTERNAL;\n-    newDoc->dict = ctxt->dict;\n-    xmlDictReference(newDoc->dict);\n-    ctxt->myDoc = newDoc;\n+        newDoc = xmlNewDoc(BAD_CAST \"1.0\");\n+        if (newDoc == NULL) {\n+            ctxt->sax = oldsax;\n+            ctxt->dict = NULL;\n+            xmlFreeParserCtxt(ctxt);\n+            return(XML_ERR_INTERNAL_ERROR);\n+        }\n+        newDoc->properties = XML_DOC_INTERNAL;\n+        newDoc->dict = ctxt->dict;\n+        xmlDictReference(newDoc->dict);\n+        ctxt->myDoc = newDoc;\n@@ -13364,1 +13366,1 @@\n-    ctxt->myDoc = oldctxt->myDoc;\n+        ctxt->myDoc = oldctxt->myDoc;\n@@ -13366,1 +13368,1 @@\n-    last = ctxt->myDoc->last;\n+        last = ctxt->myDoc->last;\n@@ -13370,7 +13372,7 @@\n-    ctxt->sax = oldsax;\n-    ctxt->dict = NULL;\n-    xmlFreeParserCtxt(ctxt);\n-    if (newDoc != NULL) {\n-        xmlFreeDoc(newDoc);\n-    }\n-    return(XML_ERR_INTERNAL_ERROR);\n+        ctxt->sax = oldsax;\n+        ctxt->dict = NULL;\n+        xmlFreeParserCtxt(ctxt);\n+        if (newDoc != NULL) {\n+            xmlFreeDoc(newDoc);\n+        }\n+        return(XML_ERR_INTERNAL_ERROR);\n@@ -13388,4 +13390,4 @@\n-    \/*\n-     * ID\/IDREF registration will be done in xmlValidateElement below\n-     *\/\n-    ctxt->loadsubset |= XML_SKIP_IDS;\n+        \/*\n+         * ID\/IDREF registration will be done in xmlValidateElement below\n+         *\/\n+        ctxt->loadsubset |= XML_SKIP_IDS;\n@@ -13399,1 +13401,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n@@ -13401,1 +13403,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n@@ -13404,1 +13406,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n@@ -13409,3 +13411,3 @@\n-        ret = XML_ERR_INTERNAL_ERROR;\n-    else\n-        ret = (xmlParserErrors)ctxt->errNo;\n+            ret = XML_ERR_INTERNAL_ERROR;\n+        else\n+            ret = (xmlParserErrors)ctxt->errNo;\n@@ -13417,1 +13419,1 @@\n-    xmlNodePtr cur;\n+        xmlNodePtr cur;\n@@ -13419,7 +13421,7 @@\n-    \/*\n-     * Return the newly created nodeset after unlinking it from\n-     * they pseudo parent.\n-     *\/\n-    cur = ctxt->myDoc->children->children;\n-    *lst = cur;\n-    while (cur != NULL) {\n+        \/*\n+         * Return the newly created nodeset after unlinking it from\n+         * they pseudo parent.\n+         *\/\n+        cur = ctxt->myDoc->children->children;\n+        *lst = cur;\n+        while (cur != NULL) {\n@@ -13427,6 +13429,6 @@\n-        if ((oldctxt->validate) && (oldctxt->wellFormed) &&\n-        (oldctxt->myDoc) && (oldctxt->myDoc->intSubset) &&\n-        (cur->type == XML_ELEMENT_NODE)) {\n-        oldctxt->valid &= xmlValidateElement(&oldctxt->vctxt,\n-            oldctxt->myDoc, cur);\n-        }\n+            if ((oldctxt->validate) && (oldctxt->wellFormed) &&\n+                (oldctxt->myDoc) && (oldctxt->myDoc->intSubset) &&\n+                (cur->type == XML_ELEMENT_NODE)) {\n+                oldctxt->valid &= xmlValidateElement(&oldctxt->vctxt,\n+                        oldctxt->myDoc, cur);\n+            }\n@@ -13434,4 +13436,4 @@\n-        cur->parent = NULL;\n-        cur = cur->next;\n-    }\n-    ctxt->myDoc->children->children = NULL;\n+            cur->parent = NULL;\n+            cur = cur->next;\n+        }\n+        ctxt->myDoc->children->children = NULL;\n@@ -13440,1 +13442,1 @@\n-    xmlFreeNode(ctxt->myDoc->children);\n+        xmlFreeNode(ctxt->myDoc->children);\n@@ -13464,1 +13466,1 @@\n-    xmlFreeDoc(newDoc);\n+        xmlFreeDoc(newDoc);\n@@ -13515,3 +13517,3 @@\n-        break;\n-    default:\n-        return(XML_ERR_INTERNAL_ERROR);\n+            break;\n+        default:\n+            return(XML_ERR_INTERNAL_ERROR);\n@@ -13522,2 +13524,2 @@\n-       (node->type != XML_HTML_DOCUMENT_NODE))\n-    node = node->parent;\n+           (node->type != XML_HTML_DOCUMENT_NODE))\n+        node = node->parent;\n@@ -13525,1 +13527,1 @@\n-    return(XML_ERR_INTERNAL_ERROR);\n+        return(XML_ERR_INTERNAL_ERROR);\n@@ -13527,1 +13529,1 @@\n-    doc = node->doc;\n+        doc = node->doc;\n@@ -13531,1 +13533,1 @@\n-    return(XML_ERR_INTERNAL_ERROR);\n+        return(XML_ERR_INTERNAL_ERROR);\n@@ -13538,1 +13540,1 @@\n-    ctxt = xmlCreateMemoryParserCtxt((char *) data, datalen);\n+        ctxt = xmlCreateMemoryParserCtxt((char *) data, datalen);\n@@ -13541,1 +13543,1 @@\n-    ctxt = htmlCreateMemoryParserCtxt((char *) data, datalen);\n+        ctxt = htmlCreateMemoryParserCtxt((char *) data, datalen);\n@@ -13562,2 +13564,2 @@\n-        xmlDictFree(ctxt->dict);\n-    ctxt->dict = doc->dict;\n+            xmlDictFree(ctxt->dict);\n+        ctxt->dict = doc->dict;\n@@ -13571,1 +13573,1 @@\n-        xmlFree((xmlChar *) ctxt->encoding);\n+            xmlFree((xmlChar *) ctxt->encoding);\n@@ -13577,1 +13579,1 @@\n-    } else {\n+        } else {\n@@ -13592,1 +13594,1 @@\n-    return(XML_ERR_NO_MEMORY);\n+        return(XML_ERR_NO_MEMORY);\n@@ -13597,17 +13599,17 @@\n-    nodePush(ctxt, node);\n-    \/*\n-     * initialize the SAX2 namespaces stack\n-     *\/\n-    cur = node;\n-    while ((cur != NULL) && (cur->type == XML_ELEMENT_NODE)) {\n-        xmlNsPtr ns = cur->nsDef;\n-        const xmlChar *iprefix, *ihref;\n-\n-        while (ns != NULL) {\n-        if (ctxt->dict) {\n-            iprefix = xmlDictLookup(ctxt->dict, ns->prefix, -1);\n-            ihref = xmlDictLookup(ctxt->dict, ns->href, -1);\n-        } else {\n-            iprefix = ns->prefix;\n-            ihref = ns->href;\n-        }\n+        nodePush(ctxt, node);\n+        \/*\n+         * initialize the SAX2 namespaces stack\n+         *\/\n+        cur = node;\n+        while ((cur != NULL) && (cur->type == XML_ELEMENT_NODE)) {\n+            xmlNsPtr ns = cur->nsDef;\n+            const xmlChar *iprefix, *ihref;\n+\n+            while (ns != NULL) {\n+                if (ctxt->dict) {\n+                    iprefix = xmlDictLookup(ctxt->dict, ns->prefix, -1);\n+                    ihref = xmlDictLookup(ctxt->dict, ns->href, -1);\n+                } else {\n+                    iprefix = ns->prefix;\n+                    ihref = ns->href;\n+                }\n@@ -13615,5 +13617,7 @@\n-            if (xmlGetNamespace(ctxt, iprefix) == NULL) {\n-            nsPush(ctxt, iprefix, ihref);\n-            nsnr++;\n-        }\n-        ns = ns->next;\n+                if (xmlGetNamespace(ctxt, iprefix) == NULL) {\n+                    nsPush(ctxt, iprefix, ihref);\n+                    nsnr++;\n+                }\n+                ns = ns->next;\n+            }\n+            cur = cur->parent;\n@@ -13621,2 +13625,0 @@\n-        cur = cur->parent;\n-    }\n@@ -13626,4 +13628,4 @@\n-    \/*\n-     * ID\/IDREF registration will be done in xmlValidateElement below\n-     *\/\n-    ctxt->loadsubset |= XML_SKIP_IDS;\n+        \/*\n+         * ID\/IDREF registration will be done in xmlValidateElement below\n+         *\/\n+        ctxt->loadsubset |= XML_SKIP_IDS;\n@@ -13637,1 +13639,1 @@\n-    xmlParseContent(ctxt);\n+        xmlParseContent(ctxt);\n@@ -13641,1 +13643,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n@@ -13643,1 +13645,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n@@ -13646,2 +13648,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n-    ctxt->wellFormed = 0;\n+        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n+        ctxt->wellFormed = 0;\n@@ -13652,3 +13654,3 @@\n-        ret = XML_ERR_INTERNAL_ERROR;\n-    else\n-        ret = (xmlParserErrors)ctxt->errNo;\n+            ret = XML_ERR_INTERNAL_ERROR;\n+        else\n+            ret = (xmlParserErrors)ctxt->errNo;\n@@ -13669,1 +13671,1 @@\n-    cur->prev = NULL;\n+        cur->prev = NULL;\n@@ -13675,2 +13677,2 @@\n-    cur->parent = NULL;\n-    cur = cur->next;\n+        cur->parent = NULL;\n+        cur = cur->next;\n@@ -13685,1 +13687,1 @@\n-    *lst = NULL;\n+        *lst = NULL;\n@@ -13736,1 +13738,1 @@\n-    return(XML_ERR_ENTITY_LOOP);\n+        return(XML_ERR_ENTITY_LOOP);\n@@ -13751,1 +13753,1 @@\n-    oldsax = ctxt->sax;\n+        oldsax = ctxt->sax;\n@@ -13753,2 +13755,2 @@\n-    if (user_data != NULL)\n-        ctxt->userData = user_data;\n+        if (user_data != NULL)\n+            ctxt->userData = user_data;\n@@ -13758,2 +13760,2 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(-1);\n+        xmlFreeParserCtxt(ctxt);\n+        return(-1);\n@@ -13764,6 +13766,6 @@\n-    ctxt->dict = doc->dict;\n-    xmlDictReference(ctxt->dict);\n-    ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST \"xml\", 3);\n-    ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST \"xmlns\", 5);\n-    ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);\n-    ctxt->dictNames = 1;\n+        ctxt->dict = doc->dict;\n+        xmlDictReference(ctxt->dict);\n+        ctxt->str_xml = xmlDictLookup(ctxt->dict, BAD_CAST \"xml\", 3);\n+        ctxt->str_xmlns = xmlDictLookup(ctxt->dict, BAD_CAST \"xmlns\", 5);\n+        ctxt->str_xml_ns = xmlDictLookup(ctxt->dict, XML_XML_NAMESPACE, 36);\n+        ctxt->dictNames = 1;\n@@ -13771,1 +13773,1 @@\n-    xmlCtxtUseOptionsInternal(ctxt, XML_PARSE_NODICT, NULL);\n+        xmlCtxtUseOptionsInternal(ctxt, XML_PARSE_NODICT, NULL);\n@@ -13775,2 +13777,2 @@\n-    newDoc->intSubset = doc->intSubset;\n-    newDoc->extSubset = doc->extSubset;\n+        newDoc->intSubset = doc->intSubset;\n+        newDoc->extSubset = doc->extSubset;\n@@ -13780,5 +13782,5 @@\n-    if (sax != NULL)\n-        ctxt->sax = oldsax;\n-    xmlFreeParserCtxt(ctxt);\n-    newDoc->intSubset = NULL;\n-    newDoc->extSubset = NULL;\n+        if (sax != NULL)\n+            ctxt->sax = oldsax;\n+        xmlFreeParserCtxt(ctxt);\n+        newDoc->intSubset = NULL;\n+        newDoc->extSubset = NULL;\n@@ -13786,1 +13788,1 @@\n-    return(-1);\n+        return(-1);\n@@ -13792,1 +13794,1 @@\n-    ctxt->myDoc = newDoc;\n+        ctxt->myDoc = newDoc;\n@@ -13794,5 +13796,5 @@\n-    ctxt->myDoc = newDoc;\n-    newDoc->children->doc = doc;\n-    \/* Ensure that doc has XML spec namespace *\/\n-    xmlSearchNsByHref(doc, (xmlNodePtr)doc, XML_XML_NAMESPACE);\n-    newDoc->oldNs = doc->oldNs;\n+        ctxt->myDoc = newDoc;\n+        newDoc->children->doc = doc;\n+        \/* Ensure that doc has XML spec namespace *\/\n+        xmlSearchNsByHref(doc, (xmlNodePtr)doc, XML_XML_NAMESPACE);\n+        newDoc->oldNs = doc->oldNs;\n@@ -13821,1 +13823,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n@@ -13823,1 +13825,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n@@ -13826,1 +13828,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n@@ -13831,3 +13833,3 @@\n-        ret = 1;\n-    else\n-        ret = ctxt->errNo;\n+            ret = 1;\n+        else\n+            ret = ctxt->errNo;\n@@ -13839,1 +13841,1 @@\n-    xmlNodePtr cur;\n+        xmlNodePtr cur;\n@@ -13841,12 +13843,12 @@\n-    \/*\n-     * Return the newly created nodeset after unlinking it from\n-     * they pseudo parent.\n-     *\/\n-    cur = newDoc->children->children;\n-    *lst = cur;\n-    while (cur != NULL) {\n-        xmlSetTreeDoc(cur, doc);\n-        cur->parent = NULL;\n-        cur = cur->next;\n-    }\n-    newDoc->children->children = NULL;\n+        \/*\n+         * Return the newly created nodeset after unlinking it from\n+         * they pseudo parent.\n+         *\/\n+        cur = newDoc->children->children;\n+        *lst = cur;\n+        while (cur != NULL) {\n+            xmlSetTreeDoc(cur, doc);\n+            cur->parent = NULL;\n+            cur = cur->next;\n+        }\n+        newDoc->children->children = NULL;\n@@ -13856,1 +13858,1 @@\n-    ctxt->sax = oldsax;\n+        ctxt->sax = oldsax;\n@@ -13890,1 +13892,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -13893,2 +13895,2 @@\n-    if (ctxt->sax != NULL)\n-        xmlFree(ctxt->sax);\n+        if (ctxt->sax != NULL)\n+            xmlFree(ctxt->sax);\n@@ -13902,1 +13904,1 @@\n-    ret = ctxt->myDoc;\n+        ret = ctxt->myDoc;\n@@ -13949,1 +13951,1 @@\n-                      const xmlChar *base, xmlParserCtxtPtr pctx) {\n+                          const xmlChar *base, xmlParserCtxtPtr pctx) {\n@@ -13957,1 +13959,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -13963,5 +13965,5 @@\n-    \/*\n-     * this is a subparser of pctx, so the input_id should be\n-     * incremented to distinguish from main entity\n-     *\/\n-    ctxt->input_id = pctx->input_id + 1;\n+        \/*\n+         * this is a subparser of pctx, so the input_id should be\n+         * incremented to distinguish from main entity\n+         *\/\n+        ctxt->input_id = pctx->input_id + 1;\n@@ -13977,5 +13979,5 @@\n-    inputStream = xmlLoadExternalEntity((char *)URL, (char *)ID, ctxt);\n-    if (inputStream == NULL) {\n-        xmlFreeParserCtxt(ctxt);\n-        return(NULL);\n-    }\n+        inputStream = xmlLoadExternalEntity((char *)URL, (char *)ID, ctxt);\n+        if (inputStream == NULL) {\n+            xmlFreeParserCtxt(ctxt);\n+            return(NULL);\n+        }\n@@ -13983,1 +13985,1 @@\n-    inputPush(ctxt, inputStream);\n+        inputPush(ctxt, inputStream);\n@@ -13985,4 +13987,4 @@\n-    if ((ctxt->directory == NULL) && (directory == NULL))\n-        directory = xmlParserGetDirectory((char *)URL);\n-    if ((ctxt->directory == NULL) && (directory != NULL))\n-        ctxt->directory = directory;\n+        if ((ctxt->directory == NULL) && (directory == NULL))\n+            directory = xmlParserGetDirectory((char *)URL);\n+        if ((ctxt->directory == NULL) && (directory != NULL))\n+            ctxt->directory = directory;\n@@ -13990,6 +13992,6 @@\n-    inputStream = xmlLoadExternalEntity((char *)uri, (char *)ID, ctxt);\n-    if (inputStream == NULL) {\n-        xmlFree(uri);\n-        xmlFreeParserCtxt(ctxt);\n-        return(NULL);\n-    }\n+        inputStream = xmlLoadExternalEntity((char *)uri, (char *)ID, ctxt);\n+        if (inputStream == NULL) {\n+            xmlFree(uri);\n+            xmlFreeParserCtxt(ctxt);\n+            return(NULL);\n+        }\n@@ -13997,1 +13999,1 @@\n-    inputPush(ctxt, inputStream);\n+        inputPush(ctxt, inputStream);\n@@ -13999,5 +14001,5 @@\n-    if ((ctxt->directory == NULL) && (directory == NULL))\n-        directory = xmlParserGetDirectory((char *)uri);\n-    if ((ctxt->directory == NULL) && (directory != NULL))\n-        ctxt->directory = directory;\n-    xmlFree(uri);\n+        if ((ctxt->directory == NULL) && (directory == NULL))\n+            directory = xmlParserGetDirectory((char *)uri);\n+        if ((ctxt->directory == NULL) && (directory != NULL))\n+            ctxt->directory = directory;\n+        xmlFree(uri);\n@@ -14022,1 +14024,1 @@\n-                      const xmlChar *base) {\n+                          const xmlChar *base) {\n@@ -14028,3 +14030,3 @@\n- *                                  *\n- *      Front ends when parsing from a file         *\n- *                                  *\n+ *                                                                      *\n+ *              Front ends when parsing from a file                     *\n+ *                                                                      *\n@@ -14053,2 +14055,2 @@\n-    xmlErrMemory(NULL, \"cannot allocate parser context\");\n-    return(NULL);\n+        xmlErrMemory(NULL, \"cannot allocate parser context\");\n+        return(NULL);\n@@ -14058,1 +14060,1 @@\n-    xmlCtxtUseOptionsInternal(ctxt, options, NULL);\n+        xmlCtxtUseOptionsInternal(ctxt, options, NULL);\n@@ -14063,2 +14065,2 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -14122,1 +14124,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -14125,2 +14127,2 @@\n-    if (ctxt->sax != NULL)\n-        xmlFree(ctxt->sax);\n+        if (ctxt->sax != NULL)\n+            xmlFree(ctxt->sax);\n@@ -14131,1 +14133,1 @@\n-    ctxt->_private = data;\n+        ctxt->_private = data;\n@@ -14143,6 +14145,6 @@\n-    if ((ret != NULL) && (ctxt->input->buf != NULL)) {\n-        if (ctxt->input->buf->compressed > 0)\n-        ret->compression = 9;\n-        else\n-        ret->compression = ctxt->input->buf->compressed;\n-    }\n+        if ((ret != NULL) && (ctxt->input->buf != NULL)) {\n+            if (ctxt->input->buf->compressed > 0)\n+                ret->compression = 9;\n+            else\n+                ret->compression = ctxt->input->buf->compressed;\n+        }\n@@ -14288,1 +14290,1 @@\n-    xmlFree(ctxt->sax);\n+        xmlFree(ctxt->sax);\n@@ -14293,1 +14295,1 @@\n-    ctxt->userData = user_data;\n+        ctxt->userData = user_data;\n@@ -14298,1 +14300,1 @@\n-    ret = 0;\n+        ret = 0;\n@@ -14301,3 +14303,3 @@\n-        ret = ctxt->errNo;\n-    else\n-        ret = -1;\n+            ret = ctxt->errNo;\n+        else\n+            ret = -1;\n@@ -14306,1 +14308,1 @@\n-    ctxt->sax = NULL;\n+        ctxt->sax = NULL;\n@@ -14309,1 +14311,1 @@\n-    ctxt->myDoc = NULL;\n+        ctxt->myDoc = NULL;\n@@ -14318,3 +14320,3 @@\n- *                                  *\n- *      Front ends when parsing from memory         *\n- *                                  *\n+ *                                                                      *\n+ *              Front ends when parsing from memory                     *\n+ *                                                                      *\n@@ -14339,1 +14341,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -14341,1 +14343,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -14345,1 +14347,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -14350,2 +14352,2 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -14356,3 +14358,3 @@\n-    xmlFreeParserInputBuffer(buf);\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserInputBuffer(buf);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -14391,1 +14393,1 @@\n-              int size, int recovery, void *data) {\n+                  int size, int recovery, void *data) {\n@@ -14400,2 +14402,2 @@\n-    if (ctxt->sax != NULL)\n-        xmlFree(ctxt->sax);\n+        if (ctxt->sax != NULL)\n+            xmlFree(ctxt->sax);\n@@ -14406,1 +14408,1 @@\n-    ctxt->_private=data;\n+        ctxt->_private=data;\n@@ -14420,1 +14422,1 @@\n-    ctxt->sax = NULL;\n+        ctxt->sax = NULL;\n@@ -14442,1 +14444,1 @@\n-              int size, int recovery) {\n+                  int size, int recovery) {\n@@ -14489,1 +14491,1 @@\n-              const char *buffer, int size) {\n+                          const char *buffer, int size) {\n@@ -14503,1 +14505,1 @@\n-    ctxt->userData = user_data;\n+        ctxt->userData = user_data;\n@@ -14508,1 +14510,1 @@\n-    ret = 0;\n+        ret = 0;\n@@ -14511,3 +14513,3 @@\n-        ret = ctxt->errNo;\n-    else\n-        ret = -1;\n+            ret = ctxt->errNo;\n+        else\n+            ret = -1;\n@@ -14519,1 +14521,1 @@\n-    ctxt->myDoc = NULL;\n+        ctxt->myDoc = NULL;\n@@ -14540,1 +14542,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -14586,1 +14588,1 @@\n-    ctxt->sax = oldsax;\n+        ctxt->sax = oldsax;\n@@ -14609,4 +14611,4 @@\n- *                                  *\n- *  Specific function to keep track of entities references      *\n- *  and used by the XSLT debugger                   *\n- *                                  *\n+ *                                                                      *\n+ *      Specific function to keep track of entities references          *\n+ *      and used by the XSLT debugger                                   *\n+ *                                                                      *\n@@ -14649,3 +14651,3 @@\n- *                                  *\n- *              Miscellaneous               *\n- *                                  *\n+ *                                                                      *\n+ *                              Miscellaneous                           *\n+ *                                                                      *\n@@ -14672,1 +14674,1 @@\n-    return;\n+        return;\n@@ -14675,1 +14677,2 @@\n-    atexit(xmlCleanupParser);\n+    if (xmlFree == free)\n+        atexit(xmlCleanupParser);\n@@ -14682,6 +14685,6 @@\n-    xmlInitThreads();\n-    xmlInitGlobals();\n-    if ((xmlGenericError == xmlGenericErrorDefaultFunc) ||\n-        (xmlGenericError == NULL))\n-        initGenericErrorDefaultFunc(NULL);\n-    xmlInitMemory();\n+        xmlInitThreads();\n+        xmlInitGlobals();\n+        if ((xmlGenericError == xmlGenericErrorDefaultFunc) ||\n+            (xmlGenericError == NULL))\n+            initGenericErrorDefaultFunc(NULL);\n+        xmlInitMemory();\n@@ -14689,3 +14692,3 @@\n-    xmlInitCharEncodingHandlers();\n-    xmlDefaultSAXHandlerInit();\n-    xmlRegisterDefaultInputCallbacks();\n+        xmlInitCharEncodingHandlers();\n+        xmlDefaultSAXHandlerInit();\n+        xmlRegisterDefaultInputCallbacks();\n@@ -14693,1 +14696,1 @@\n-    xmlRegisterDefaultOutputCallbacks();\n+        xmlRegisterDefaultOutputCallbacks();\n@@ -14696,2 +14699,2 @@\n-    htmlInitAutoClose();\n-    htmlDefaultSAXHandlerInit();\n+        htmlInitAutoClose();\n+        htmlDefaultSAXHandlerInit();\n@@ -14700,1 +14703,1 @@\n-    xmlXPathInit();\n+        xmlXPathInit();\n@@ -14702,1 +14705,1 @@\n-    xmlParserInitialized = 1;\n+        xmlParserInitialized = 1;\n@@ -14734,1 +14737,1 @@\n-    return;\n+        return;\n@@ -14771,3 +14774,3 @@\n- *                                  *\n- *  New set (2.6.0) of simpler and more flexible APIs       *\n- *                                  *\n+ *                                                                      *\n+ *      New set (2.6.0) of simpler and more flexible APIs               *\n+ *                                                                      *\n@@ -14783,4 +14786,4 @@\n-#define DICT_FREE(str)                      \\\n-    if ((str) && ((!dict) ||                \\\n-        (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \\\n-        xmlFree((char *)(str));\n+#define DICT_FREE(str)                                          \\\n+        if ((str) && ((!dict) ||                                \\\n+            (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \\\n+            xmlFree((char *)(str));\n@@ -14813,2 +14816,2 @@\n-    ctxt->spaceTab[0] = -1;\n-    ctxt->space = &ctxt->spaceTab[0];\n+        ctxt->spaceTab[0] = -1;\n+        ctxt->space = &ctxt->spaceTab[0];\n@@ -14880,1 +14883,1 @@\n-    xmlCatalogFreeLocal(ctxt->catalogs);\n+        xmlCatalogFreeLocal(ctxt->catalogs);\n@@ -14947,1 +14950,1 @@\n-    size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n+        size_t base = xmlBufGetInputBase(ctxt->input->buf->buffer, ctxt->input);\n@@ -14962,1 +14965,1 @@\n-        xmlFree((xmlChar *) ctxt->encoding);\n+            xmlFree((xmlChar *) ctxt->encoding);\n@@ -14968,3 +14971,3 @@\n-    } else {\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n-                  \"Unsupported encoding %s\\n\", BAD_CAST encoding);\n+        } else {\n+            xmlFatalErrMsgStr(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n+                              \"Unsupported encoding %s\\n\", BAD_CAST encoding);\n@@ -14998,1 +15001,1 @@\n-        xmlFree((xmlChar *) ctxt->encoding);\n+            xmlFree((xmlChar *) ctxt->encoding);\n@@ -15004,1 +15007,1 @@\n-    ctxt->options |= XML_PARSE_RECOVER;\n+        ctxt->options |= XML_PARSE_RECOVER;\n@@ -15010,1 +15013,1 @@\n-    ctxt->options |= XML_PARSE_DTDLOAD;\n+        ctxt->options |= XML_PARSE_DTDLOAD;\n@@ -15016,1 +15019,1 @@\n-    ctxt->options |= XML_PARSE_DTDATTR;\n+        ctxt->options |= XML_PARSE_DTDATTR;\n@@ -15022,1 +15025,1 @@\n-    ctxt->options |= XML_PARSE_NOENT;\n+        ctxt->options |= XML_PARSE_NOENT;\n@@ -15028,1 +15031,1 @@\n-    ctxt->options |= XML_PARSE_PEDANTIC;\n+        ctxt->options |= XML_PARSE_PEDANTIC;\n@@ -15035,1 +15038,1 @@\n-    ctxt->options |= XML_PARSE_NOBLANKS;\n+        ctxt->options |= XML_PARSE_NOBLANKS;\n@@ -15045,1 +15048,1 @@\n-    ctxt->options |= XML_PARSE_DTDVALID;\n+        ctxt->options |= XML_PARSE_DTDVALID;\n@@ -15065,1 +15068,1 @@\n-    ctxt->options |= XML_PARSE_SAX1;\n+        ctxt->options |= XML_PARSE_SAX1;\n@@ -15071,1 +15074,1 @@\n-    ctxt->options |= XML_PARSE_NODICT;\n+        ctxt->options |= XML_PARSE_NODICT;\n@@ -15078,1 +15081,1 @@\n-    ctxt->options |= XML_PARSE_NOCDATA;\n+        ctxt->options |= XML_PARSE_NOCDATA;\n@@ -15081,1 +15084,1 @@\n-    ctxt->options |= XML_PARSE_NSCLEAN;\n+        ctxt->options |= XML_PARSE_NSCLEAN;\n@@ -15085,1 +15088,1 @@\n-    ctxt->options |= XML_PARSE_NONET;\n+        ctxt->options |= XML_PARSE_NONET;\n@@ -15089,1 +15092,1 @@\n-    ctxt->options |= XML_PARSE_COMPACT;\n+        ctxt->options |= XML_PARSE_COMPACT;\n@@ -15093,1 +15096,1 @@\n-    ctxt->options |= XML_PARSE_OLD10;\n+        ctxt->options |= XML_PARSE_OLD10;\n@@ -15097,1 +15100,1 @@\n-    ctxt->options |= XML_PARSE_NOBASEFIX;\n+        ctxt->options |= XML_PARSE_NOBASEFIX;\n@@ -15101,1 +15104,1 @@\n-    ctxt->options |= XML_PARSE_HUGE;\n+        ctxt->options |= XML_PARSE_HUGE;\n@@ -15107,1 +15110,1 @@\n-    ctxt->options |= XML_PARSE_OLDSAX;\n+        ctxt->options |= XML_PARSE_OLDSAX;\n@@ -15111,1 +15114,1 @@\n-    ctxt->options |= XML_PARSE_IGNORE_ENC;\n+        ctxt->options |= XML_PARSE_IGNORE_ENC;\n@@ -15115,1 +15118,1 @@\n-    ctxt->options |= XML_PARSE_BIG_LINES;\n+        ctxt->options |= XML_PARSE_BIG_LINES;\n@@ -15160,3 +15163,3 @@\n-    hdlr = xmlFindCharEncodingHandler(encoding);\n-    if (hdlr != NULL)\n-        xmlSwitchToEncoding(ctxt, hdlr);\n+        hdlr = xmlFindCharEncodingHandler(encoding);\n+        if (hdlr != NULL)\n+            xmlSwitchToEncoding(ctxt, hdlr);\n@@ -15172,3 +15175,3 @@\n-    if (ctxt->myDoc != NULL) {\n-        xmlFreeDoc(ctxt->myDoc);\n-    }\n+        if (ctxt->myDoc != NULL) {\n+            xmlFreeDoc(ctxt->myDoc);\n+        }\n@@ -15178,1 +15181,1 @@\n-    xmlFreeParserCtxt(ctxt);\n+        xmlFreeParserCtxt(ctxt);\n@@ -15292,1 +15295,1 @@\n-    xmlFreeParserCtxt(ctxt);\n+        xmlFreeParserCtxt(ctxt);\n@@ -15339,1 +15342,1 @@\n-    xmlFreeParserCtxt(ctxt);\n+        xmlFreeParserCtxt(ctxt);\n@@ -15446,1 +15449,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -15451,2 +15454,2 @@\n-    xmlFreeParserInputBuffer(input);\n-    return(NULL);\n+        xmlFreeParserInputBuffer(input);\n+        return(NULL);\n@@ -15521,1 +15524,1 @@\n-          const char *URL,\n+              const char *URL,\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/parser.c","additions":5421,"deletions":5418,"binary":false,"changes":10839,"status":"modified"},{"patch":"@@ -83,6 +83,6 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"Fatal: program compiled against libxml %d using libxml %d\\n\",\n-        (version \/ 10000), (myversion \/ 10000));\n-    fprintf(stderr,\n-        \"Fatal: program compiled against libxml %d using libxml %d\\n\",\n-        (version \/ 10000), (myversion \/ 10000));\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"Fatal: program compiled against libxml %d using libxml %d\\n\",\n+                (version \/ 10000), (myversion \/ 10000));\n+        fprintf(stderr,\n+                \"Fatal: program compiled against libxml %d using libxml %d\\n\",\n+                (version \/ 10000), (myversion \/ 10000));\n@@ -91,3 +91,3 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"Warning: program compiled against libxml %d using older %d\\n\",\n-        (version \/ 100), (myversion \/ 100));\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"Warning: program compiled against libxml %d using older %d\\n\",\n+                (version \/ 100), (myversion \/ 100));\n@@ -99,3 +99,3 @@\n- *                                  *\n- *      Some factorized error routines              *\n- *                                  *\n+ *                                                                      *\n+ *              Some factorized error routines                          *\n+ *                                                                      *\n@@ -117,1 +117,1 @@\n-    return;\n+        return;\n@@ -150,1 +150,1 @@\n-    return;\n+        return;\n@@ -177,1 +177,1 @@\n-    return;\n+        return;\n@@ -206,1 +206,1 @@\n-    return;\n+        return;\n@@ -234,3 +234,3 @@\n- *                                  *\n- *      Input handling functions for progressive parsing    *\n- *                                  *\n+ *                                                                      *\n+ *              Input handling functions for progressive parsing        *\n+ *                                                                      *\n@@ -254,1 +254,1 @@\n-        \"xmlParserInput: base mismatch problem\\n\");\n+                \"xmlParserInput: base mismatch problem\\n\");\n@@ -258,1 +258,1 @@\n-        \"xmlParserInput: cur < base problem\\n\");\n+                \"xmlParserInput: cur < base problem\\n\");\n@@ -262,1 +262,1 @@\n-        \"xmlParserInput: cur > base + use problem\\n\");\n+                \"xmlParserInput: cur > base + use problem\\n\");\n@@ -266,1 +266,1 @@\n-        xmlBufUse(in->buf->buffer));\n+            xmlBufUse(in->buf->buffer));\n@@ -319,1 +319,1 @@\n-    CHECK_BUFFER(in);\n+        CHECK_BUFFER(in);\n@@ -324,1 +324,1 @@\n-    ret = xmlParserInputBufferGrow(in->buf, len);\n+        ret = xmlParserInputBufferGrow(in->buf, len);\n@@ -338,5 +338,5 @@\n-     * the buffer has been reallocated\n-     *\/\n-    indx = in->cur - in->base;\n-    in->base = content;\n-    in->cur = &content[indx];\n+         * the buffer has been reallocated\n+         *\/\n+        indx = in->cur - in->base;\n+        in->base = content;\n+        in->cur = &content[indx];\n@@ -381,6 +381,6 @@\n-    ret = xmlBufShrink(in->buf->buffer, used - LINE_LEN);\n-    if (ret > 0) {\n-        in->cur -= ret;\n-        in->consumed += ret;\n-    }\n-    in->end = xmlBufEnd(in->buf->buffer);\n+        ret = xmlBufShrink(in->buf->buffer, used - LINE_LEN);\n+        if (ret > 0) {\n+            in->cur -= ret;\n+            in->consumed += ret;\n+        }\n+        in->end = xmlBufEnd(in->buf->buffer);\n@@ -398,5 +398,5 @@\n-     * the buffer has been reallocated\n-     *\/\n-    indx = in->cur - in->base;\n-    in->base = content;\n-    in->cur = &content[indx];\n+         * the buffer has been reallocated\n+         *\/\n+        indx = in->cur - in->base;\n+        in->base = content;\n+        in->cur = &content[indx];\n@@ -410,3 +410,3 @@\n- *                                  *\n- *      UTF8 character input and related functions      *\n- *                                  *\n+ *                                                                      *\n+ *              UTF8 character input and related functions              *\n+ *                                                                      *\n@@ -431,1 +431,1 @@\n-    ctxt->errNo = XML_ERR_INTERNAL_ERROR;\n+        ctxt->errNo = XML_ERR_INTERNAL_ERROR;\n@@ -433,1 +433,1 @@\n-    return;\n+        return;\n@@ -472,1 +472,1 @@\n-            goto encoding_error;\n+                goto encoding_error;\n@@ -512,3 +512,3 @@\n-        xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,\n-                  \"Char 0x%X out of allowed range\\n\",\n-                  val);\n+                xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                  \"Char 0x%X out of allowed range\\n\",\n+                                  val);\n@@ -548,3 +548,3 @@\n-    __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n-             \"Input is not proper UTF-8, indicate encoding !\\n\",\n-             NULL, NULL);\n+        __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n+                     \"Input is not proper UTF-8, indicate encoding !\\n\",\n+                     NULL, NULL);\n@@ -554,6 +554,6 @@\n-    snprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n-            ctxt->input->cur[0], ctxt->input->cur[1],\n-            ctxt->input->cur[2], ctxt->input->cur[3]);\n-    __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n-             \"Input is not proper UTF-8, indicate encoding !\\n%s\",\n-             BAD_CAST buffer, NULL);\n+        snprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n+                        ctxt->input->cur[0], ctxt->input->cur[1],\n+                        ctxt->input->cur[2], ctxt->input->cur[3]);\n+        __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n+                     \"Input is not proper UTF-8, indicate encoding !\\n%s\",\n+                     BAD_CAST buffer, NULL);\n@@ -588,1 +588,1 @@\n-    return(0);\n+        return(0);\n@@ -591,2 +591,2 @@\n-        *len = 1;\n-        return((int) *ctxt->input->cur);\n+            *len = 1;\n+            return((int) *ctxt->input->cur);\n@@ -595,21 +595,21 @@\n-    \/*\n-     * We are supposed to handle UTF8, check it's valid\n-     * From rfc2044: encoding of the Unicode values on UTF-8:\n-     *\n-     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-     * 0000 0000-0000 007F   0xxxxxxx\n-     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-     *\n-     * Check for the 0x110000 limit too\n-     *\/\n-    const unsigned char *cur = ctxt->input->cur;\n-    unsigned char c;\n-    unsigned int val;\n-\n-    c = *cur;\n-    if (c & 0x80) {\n-        if (((c & 0x40) == 0) || (c == 0xC0))\n-        goto encoding_error;\n-        if (cur[1] == 0) {\n-        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+        \/*\n+         * We are supposed to handle UTF8, check it's valid\n+         * From rfc2044: encoding of the Unicode values on UTF-8:\n+         *\n+         * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n+         * 0000 0000-0000 007F   0xxxxxxx\n+         * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n+         * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n+         *\n+         * Check for the 0x110000 limit too\n+         *\/\n+        const unsigned char *cur = ctxt->input->cur;\n+        unsigned char c;\n+        unsigned int val;\n+\n+        c = *cur;\n+        if (c & 0x80) {\n+            if (((c & 0x40) == 0) || (c == 0xC0))\n+                goto encoding_error;\n+            if (cur[1] == 0) {\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n@@ -618,5 +618,5 @@\n-        if ((cur[1] & 0xc0) != 0x80)\n-        goto encoding_error;\n-        if ((c & 0xe0) == 0xe0) {\n-        if (cur[2] == 0) {\n-            xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((cur[1] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xe0) == 0xe0) {\n+                if (cur[2] == 0) {\n+                    xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n@@ -625,5 +625,5 @@\n-        if ((cur[2] & 0xc0) != 0x80)\n-            goto encoding_error;\n-        if ((c & 0xf0) == 0xf0) {\n-            if (cur[3] == 0) {\n-            xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+                if ((cur[2] & 0xc0) != 0x80)\n+                    goto encoding_error;\n+                if ((c & 0xf0) == 0xf0) {\n+                    if (cur[3] == 0) {\n+                        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n@@ -632,20 +632,33 @@\n-            if (((c & 0xf8) != 0xf0) ||\n-            ((cur[3] & 0xc0) != 0x80))\n-            goto encoding_error;\n-            \/* 4-byte code *\/\n-            *len = 4;\n-            val = (cur[0] & 0x7) << 18;\n-            val |= (cur[1] & 0x3f) << 12;\n-            val |= (cur[2] & 0x3f) << 6;\n-            val |= cur[3] & 0x3f;\n-            if (val < 0x10000)\n-            goto encoding_error;\n-        } else {\n-          \/* 3-byte code *\/\n-            *len = 3;\n-            val = (cur[0] & 0xf) << 12;\n-            val |= (cur[1] & 0x3f) << 6;\n-            val |= cur[2] & 0x3f;\n-            if (val < 0x800)\n-            goto encoding_error;\n-        }\n+                    if (((c & 0xf8) != 0xf0) ||\n+                        ((cur[3] & 0xc0) != 0x80))\n+                        goto encoding_error;\n+                    \/* 4-byte code *\/\n+                    *len = 4;\n+                    val = (cur[0] & 0x7) << 18;\n+                    val |= (cur[1] & 0x3f) << 12;\n+                    val |= (cur[2] & 0x3f) << 6;\n+                    val |= cur[3] & 0x3f;\n+                    if (val < 0x10000)\n+                        goto encoding_error;\n+                } else {\n+                  \/* 3-byte code *\/\n+                    *len = 3;\n+                    val = (cur[0] & 0xf) << 12;\n+                    val |= (cur[1] & 0x3f) << 6;\n+                    val |= cur[2] & 0x3f;\n+                    if (val < 0x800)\n+                        goto encoding_error;\n+                }\n+            } else {\n+              \/* 2-byte code *\/\n+                *len = 2;\n+                val = (cur[0] & 0x1f) << 6;\n+                val |= cur[1] & 0x3f;\n+                if (val < 0x80)\n+                    goto encoding_error;\n+            }\n+            if (!IS_CHAR(val)) {\n+                xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                  \"Char 0x%X out of allowed range\\n\", val);\n+            }\n+            return(val);\n@@ -653,27 +666,16 @@\n-          \/* 2-byte code *\/\n-        *len = 2;\n-        val = (cur[0] & 0x1f) << 6;\n-        val |= cur[1] & 0x3f;\n-        if (val < 0x80)\n-            goto encoding_error;\n-        }\n-        if (!IS_CHAR(val)) {\n-            xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,\n-                  \"Char 0x%X out of allowed range\\n\", val);\n-        }\n-        return(val);\n-    } else {\n-        \/* 1-byte code *\/\n-        *len = 1;\n-        if (*ctxt->input->cur == 0)\n-        xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n-        if ((*ctxt->input->cur == 0) &&\n-            (ctxt->input->end > ctxt->input->cur)) {\n-            xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,\n-                  \"Char 0x0 out of allowed range\\n\", 0);\n-        }\n-        if (*ctxt->input->cur == 0xD) {\n-        if (ctxt->input->cur[1] == 0xA) {\n-            ctxt->input->cur++;\n-        }\n-        return(0xA);\n+            \/* 1-byte code *\/\n+            *len = 1;\n+            if (*ctxt->input->cur == 0)\n+                xmlParserInputGrow(ctxt->input, INPUT_CHUNK);\n+            if ((*ctxt->input->cur == 0) &&\n+                (ctxt->input->end > ctxt->input->cur)) {\n+                xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                  \"Char 0x0 out of allowed range\\n\", 0);\n+            }\n+            if (*ctxt->input->cur == 0xD) {\n+                if (ctxt->input->cur[1] == 0xA) {\n+                    ctxt->input->cur++;\n+                }\n+                return(0xA);\n+            }\n+            return((int) *ctxt->input->cur);\n@@ -681,2 +683,0 @@\n-        return((int) *ctxt->input->cur);\n-    }\n@@ -691,4 +691,4 @@\n-    if (ctxt->input->cur[1] == 0xA) {\n-        ctxt->input->cur++;\n-    }\n-    return(0xA);\n+        if (ctxt->input->cur[1] == 0xA) {\n+            ctxt->input->cur++;\n+        }\n+        return(0xA);\n@@ -704,2 +704,2 @@\n-    *len = 0;\n-    return(0);\n+        *len = 0;\n+        return(0);\n@@ -718,6 +718,6 @@\n-    snprintf(&buffer[0], 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n-            ctxt->input->cur[0], ctxt->input->cur[1],\n-            ctxt->input->cur[2], ctxt->input->cur[3]);\n-    __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n-             \"Input is not proper UTF-8, indicate encoding !\\n%s\",\n-             BAD_CAST buffer, NULL);\n+        snprintf(&buffer[0], 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n+                        ctxt->input->cur[0], ctxt->input->cur[1],\n+                        ctxt->input->cur[2], ctxt->input->cur[3]);\n+        __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n+                     \"Input is not proper UTF-8, indicate encoding !\\n%s\",\n+                     BAD_CAST buffer, NULL);\n@@ -792,2 +792,2 @@\n-            xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,\n-                  \"Char 0x%X out of allowed range\\n\", val);\n+                xmlErrEncodingInt(ctxt, XML_ERR_INVALID_CHAR,\n+                                  \"Char 0x%X out of allowed range\\n\", val);\n@@ -818,2 +818,2 @@\n-    *len = 0;\n-    return(0);\n+        *len = 0;\n+        return(0);\n@@ -831,6 +831,6 @@\n-    snprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n-            ctxt->input->cur[0], ctxt->input->cur[1],\n-            ctxt->input->cur[2], ctxt->input->cur[3]);\n-    __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n-             \"Input is not proper UTF-8, indicate encoding !\\n%s\",\n-             BAD_CAST buffer, NULL);\n+        snprintf(buffer, 149, \"Bytes: 0x%02X 0x%02X 0x%02X 0x%02X\\n\",\n+                        ctxt->input->cur[0], ctxt->input->cur[1],\n+                        ctxt->input->cur[2], ctxt->input->cur[3]);\n+        __xmlErrEncoding(ctxt, XML_ERR_INVALID_CHAR,\n+                     \"Input is not proper UTF-8, indicate encoding !\\n%s\",\n+                     BAD_CAST buffer, NULL);\n@@ -864,14 +864,14 @@\n-    xmlChar *savedout = out;\n-    int bits;\n-    if (val <   0x800) { *out++= (val >>  6) | 0xC0;  bits=  0; }\n-    else if (val < 0x10000) { *out++= (val >> 12) | 0xE0;  bits=  6;}\n-    else if (val < 0x110000)  { *out++= (val >> 18) | 0xF0;  bits=  12; }\n-    else {\n-        xmlErrEncodingInt(NULL, XML_ERR_INVALID_CHAR,\n-            \"Internal error, xmlCopyCharMultiByte 0x%X out of bound\\n\",\n-                  val);\n-        return(0);\n-    }\n-    for ( ; bits >= 0; bits-= 6)\n-        *out++= ((val >> bits) & 0x3F) | 0x80 ;\n-    return (out - savedout);\n+        xmlChar *savedout = out;\n+        int bits;\n+        if (val <   0x800) { *out++= (val >>  6) | 0xC0;  bits=  0; }\n+        else if (val < 0x10000) { *out++= (val >> 12) | 0xE0;  bits=  6;}\n+        else if (val < 0x110000)  { *out++= (val >> 18) | 0xF0;  bits=  12; }\n+        else {\n+            xmlErrEncodingInt(NULL, XML_ERR_INVALID_CHAR,\n+                    \"Internal error, xmlCopyCharMultiByte 0x%X out of bound\\n\",\n+                              val);\n+            return(0);\n+        }\n+        for ( ; bits >= 0; bits-= 6)\n+            *out++= ((val >> bits) & 0x3F) | 0x80 ;\n+        return (out - savedout);\n@@ -899,1 +899,1 @@\n-    return(xmlCopyCharMultiByte (out, val));\n+        return(xmlCopyCharMultiByte (out, val));\n@@ -906,3 +906,3 @@\n- *                                  *\n- *      Commodity functions to switch encodings         *\n- *                                  *\n+ *                                                                      *\n+ *              Commodity functions to switch encodings                 *\n+ *                                                                      *\n@@ -936,11 +936,11 @@\n-    case XML_CHAR_ENCODING_ERROR:\n-        __xmlErrEncoding(ctxt, XML_ERR_UNKNOWN_ENCODING,\n-                       \"encoding unknown\\n\", NULL, NULL);\n-        return(-1);\n-    case XML_CHAR_ENCODING_NONE:\n-        \/* let's assume it's UTF-8 without the XML decl *\/\n-        ctxt->charset = XML_CHAR_ENCODING_UTF8;\n-        return(0);\n-    case XML_CHAR_ENCODING_UTF8:\n-        \/* default encoding, no conversion should be needed *\/\n-        ctxt->charset = XML_CHAR_ENCODING_UTF8;\n+        case XML_CHAR_ENCODING_ERROR:\n+            __xmlErrEncoding(ctxt, XML_ERR_UNKNOWN_ENCODING,\n+                           \"encoding unknown\\n\", NULL, NULL);\n+            return(-1);\n+        case XML_CHAR_ENCODING_NONE:\n+            \/* let's assume it's UTF-8 without the XML decl *\/\n+            ctxt->charset = XML_CHAR_ENCODING_UTF8;\n+            return(0);\n+        case XML_CHAR_ENCODING_UTF8:\n+            \/* default encoding, no conversion should be needed *\/\n+            ctxt->charset = XML_CHAR_ENCODING_UTF8;\n@@ -948,12 +948,12 @@\n-        \/*\n-         * Errata on XML-1.0 June 20 2001\n-         * Specific handling of the Byte Order Mark for\n-         * UTF-8\n-         *\/\n-        if ((ctxt->input != NULL) &&\n-        (ctxt->input->cur[0] == 0xEF) &&\n-        (ctxt->input->cur[1] == 0xBB) &&\n-        (ctxt->input->cur[2] == 0xBF)) {\n-        ctxt->input->cur += 3;\n-        }\n-        return(0);\n+            \/*\n+             * Errata on XML-1.0 June 20 2001\n+             * Specific handling of the Byte Order Mark for\n+             * UTF-8\n+             *\/\n+            if ((ctxt->input != NULL) &&\n+                (ctxt->input->cur[0] == 0xEF) &&\n+                (ctxt->input->cur[1] == 0xBB) &&\n+                (ctxt->input->cur[2] == 0xBF)) {\n+                ctxt->input->cur += 3;\n+            }\n+            return(0);\n@@ -977,1 +977,1 @@\n-    break;\n+        break;\n@@ -980,1 +980,1 @@\n-    break;\n+        break;\n@@ -986,1 +986,1 @@\n-    break;\n+        break;\n@@ -1002,1 +1002,1 @@\n-    break;\n+        break;\n@@ -1006,51 +1006,0 @@\n-    \/*\n-     * Default handlers.\n-     *\/\n-    switch (enc) {\n-        case XML_CHAR_ENCODING_ASCII:\n-        \/* default encoding, no conversion should be needed *\/\n-        ctxt->charset = XML_CHAR_ENCODING_UTF8;\n-        return(0);\n-        case XML_CHAR_ENCODING_UTF16LE:\n-        break;\n-        case XML_CHAR_ENCODING_UTF16BE:\n-        break;\n-        case XML_CHAR_ENCODING_UCS4LE:\n-        __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n-                   \"encoding not supported %s\\n\",\n-                   BAD_CAST \"USC4 little endian\", NULL);\n-        break;\n-        case XML_CHAR_ENCODING_UCS4BE:\n-        __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n-                   \"encoding not supported %s\\n\",\n-                   BAD_CAST \"USC4 big endian\", NULL);\n-        break;\n-        case XML_CHAR_ENCODING_EBCDIC:\n-        __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n-                   \"encoding not supported %s\\n\",\n-                   BAD_CAST \"EBCDIC\", NULL);\n-        break;\n-        case XML_CHAR_ENCODING_UCS4_2143:\n-        __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n-                   \"encoding not supported %s\\n\",\n-                   BAD_CAST \"UCS4 2143\", NULL);\n-        break;\n-        case XML_CHAR_ENCODING_UCS4_3412:\n-        __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n-                   \"encoding not supported %s\\n\",\n-                   BAD_CAST \"UCS4 3412\", NULL);\n-        break;\n-        case XML_CHAR_ENCODING_UCS2:\n-        __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n-                   \"encoding not supported %s\\n\",\n-                   BAD_CAST \"UCS2\", NULL);\n-        break;\n-        case XML_CHAR_ENCODING_8859_1:\n-        case XML_CHAR_ENCODING_8859_2:\n-        case XML_CHAR_ENCODING_8859_3:\n-        case XML_CHAR_ENCODING_8859_4:\n-        case XML_CHAR_ENCODING_8859_5:\n-        case XML_CHAR_ENCODING_8859_6:\n-        case XML_CHAR_ENCODING_8859_7:\n-        case XML_CHAR_ENCODING_8859_8:\n-        case XML_CHAR_ENCODING_8859_9:\n@@ -1058,4 +1007,1 @@\n-         * We used to keep the internal content in the\n-         * document encoding however this turns being unmaintainable\n-         * So xmlGetCharEncodingHandler() will return non-null\n-         * values for this now.\n+         * Default handlers.\n@@ -1063,5 +1009,79 @@\n-        if ((ctxt->inputNr == 1) &&\n-            (ctxt->encoding == NULL) &&\n-            (ctxt->input != NULL) &&\n-            (ctxt->input->encoding != NULL)) {\n-            ctxt->encoding = xmlStrdup(ctxt->input->encoding);\n+        switch (enc) {\n+            case XML_CHAR_ENCODING_ASCII:\n+                \/* default encoding, no conversion should be needed *\/\n+                ctxt->charset = XML_CHAR_ENCODING_UTF8;\n+                return(0);\n+            case XML_CHAR_ENCODING_UTF16LE:\n+                break;\n+            case XML_CHAR_ENCODING_UTF16BE:\n+                break;\n+            case XML_CHAR_ENCODING_UCS4LE:\n+                __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n+                               \"encoding not supported %s\\n\",\n+                               BAD_CAST \"USC4 little endian\", NULL);\n+                break;\n+            case XML_CHAR_ENCODING_UCS4BE:\n+                __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n+                               \"encoding not supported %s\\n\",\n+                               BAD_CAST \"USC4 big endian\", NULL);\n+                break;\n+            case XML_CHAR_ENCODING_EBCDIC:\n+                __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n+                               \"encoding not supported %s\\n\",\n+                               BAD_CAST \"EBCDIC\", NULL);\n+                break;\n+            case XML_CHAR_ENCODING_UCS4_2143:\n+                __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n+                               \"encoding not supported %s\\n\",\n+                               BAD_CAST \"UCS4 2143\", NULL);\n+                break;\n+            case XML_CHAR_ENCODING_UCS4_3412:\n+                __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n+                               \"encoding not supported %s\\n\",\n+                               BAD_CAST \"UCS4 3412\", NULL);\n+                break;\n+            case XML_CHAR_ENCODING_UCS2:\n+                __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n+                               \"encoding not supported %s\\n\",\n+                               BAD_CAST \"UCS2\", NULL);\n+                break;\n+            case XML_CHAR_ENCODING_8859_1:\n+            case XML_CHAR_ENCODING_8859_2:\n+            case XML_CHAR_ENCODING_8859_3:\n+            case XML_CHAR_ENCODING_8859_4:\n+            case XML_CHAR_ENCODING_8859_5:\n+            case XML_CHAR_ENCODING_8859_6:\n+            case XML_CHAR_ENCODING_8859_7:\n+            case XML_CHAR_ENCODING_8859_8:\n+            case XML_CHAR_ENCODING_8859_9:\n+                \/*\n+                 * We used to keep the internal content in the\n+                 * document encoding however this turns being unmaintainable\n+                 * So xmlGetCharEncodingHandler() will return non-null\n+                 * values for this now.\n+                 *\/\n+                if ((ctxt->inputNr == 1) &&\n+                    (ctxt->encoding == NULL) &&\n+                    (ctxt->input != NULL) &&\n+                    (ctxt->input->encoding != NULL)) {\n+                    ctxt->encoding = xmlStrdup(ctxt->input->encoding);\n+                }\n+                ctxt->charset = enc;\n+                return(0);\n+            case XML_CHAR_ENCODING_2022_JP:\n+                __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n+                               \"encoding not supported %s\\n\",\n+                               BAD_CAST \"ISO-2022-JP\", NULL);\n+                break;\n+            case XML_CHAR_ENCODING_SHIFT_JIS:\n+                __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n+                               \"encoding not supported %s\\n\",\n+                               BAD_CAST \"Shift_JIS\", NULL);\n+                break;\n+            case XML_CHAR_ENCODING_EUC_JP:\n+                __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n+                               \"encoding not supported %s\\n\",\n+                               BAD_CAST \"EUC-JP\", NULL);\n+                break;\n+            default:\n+                break;\n@@ -1069,20 +1089,0 @@\n-        ctxt->charset = enc;\n-        return(0);\n-        case XML_CHAR_ENCODING_2022_JP:\n-        __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n-                   \"encoding not supported %s\\n\",\n-                   BAD_CAST \"ISO-2022-JP\", NULL);\n-        break;\n-        case XML_CHAR_ENCODING_SHIFT_JIS:\n-        __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n-                   \"encoding not supported %s\\n\",\n-                   BAD_CAST \"Shift_JIS\", NULL);\n-        break;\n-        case XML_CHAR_ENCODING_EUC_JP:\n-        __xmlErrEncoding(ctxt, XML_ERR_UNSUPPORTED_ENCODING,\n-                   \"encoding not supported %s\\n\",\n-                   BAD_CAST \"EUC-JP\", NULL);\n-        break;\n-        default:\n-            break;\n-    }\n@@ -1097,1 +1097,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1103,2 +1103,2 @@\n-     * on encoding conversion errors, stop the parser\n-     *\/\n+         * on encoding conversion errors, stop the parser\n+         *\/\n@@ -1106,1 +1106,1 @@\n-    ctxt->errNo = XML_I18N_CONV_FAILED;\n+        ctxt->errNo = XML_I18N_CONV_FAILED;\n@@ -1173,1 +1173,1 @@\n-        unsigned int use;\n+            unsigned int use;\n@@ -1210,2 +1210,2 @@\n-        input->buf->rawconsumed = processed;\n-        use = xmlBufUse(input->buf->raw);\n+            input->buf->rawconsumed = processed;\n+            use = xmlBufUse(input->buf->raw);\n@@ -1234,1 +1234,1 @@\n-        input->buf->rawconsumed += use - xmlBufUse(input->buf->raw);\n+            input->buf->rawconsumed += use - xmlBufUse(input->buf->raw);\n@@ -1238,5 +1238,5 @@\n-    \/*\n-     * When parsing a static memory array one must know the\n-     * size to be able to convert the buffer.\n-     *\/\n-    xmlErrInternal(ctxt, \"switching encoding : no input\\n\", NULL);\n+        \/*\n+         * When parsing a static memory array one must know the\n+         * size to be able to convert the buffer.\n+         *\/\n+        xmlErrInternal(ctxt, \"switching encoding : no input\\n\", NULL);\n@@ -1249,1 +1249,1 @@\n-    return (-1);\n+        return (-1);\n@@ -1295,10 +1295,10 @@\n-        ret = xmlSwitchInputEncodingInt(ctxt, ctxt->input, handler, len);\n-    } else {\n-        xmlErrInternal(ctxt, \"xmlSwitchToEncoding : no input\\n\",\n-                       NULL);\n-        return(-1);\n-    }\n-    \/*\n-     * The parsing is now done in UTF8 natively\n-     *\/\n-    ctxt->charset = XML_CHAR_ENCODING_UTF8;\n+            ret = xmlSwitchInputEncodingInt(ctxt, ctxt->input, handler, len);\n+        } else {\n+            xmlErrInternal(ctxt, \"xmlSwitchToEncoding : no input\\n\",\n+                           NULL);\n+            return(-1);\n+        }\n+        \/*\n+         * The parsing is now done in UTF8 natively\n+         *\/\n+        ctxt->charset = XML_CHAR_ENCODING_UTF8;\n@@ -1306,1 +1306,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1327,3 +1327,3 @@\n- *                                  *\n- *  Commodity functions to handle entities processing       *\n- *                                  *\n+ *                                                                      *\n+ *      Commodity functions to handle entities processing               *\n+ *                                                                      *\n@@ -1368,1 +1368,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1399,1 +1399,1 @@\n-                xmlCharEncoding enc) {\n+                    xmlCharEncoding enc) {\n@@ -1404,1 +1404,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"new input from I\/O\\n\");\n+        xmlGenericError(xmlGenericErrorContext, \"new input from I\/O\\n\");\n@@ -1407,1 +1407,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1435,2 +1435,2 @@\n-                   NULL);\n-    return(NULL);\n+                       NULL);\n+        return(NULL);\n@@ -1439,2 +1439,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"new input from entity: %s\\n\", entity->name);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"new input from entity: %s\\n\", entity->name);\n@@ -1442,1 +1442,1 @@\n-    switch (entity->etype) {\n+        switch (entity->etype) {\n@@ -1444,2 +1444,2 @@\n-            xmlErrInternal(ctxt, \"Cannot parse entity %s\\n\",\n-                       entity->name);\n+                xmlErrInternal(ctxt, \"Cannot parse entity %s\\n\",\n+                               entity->name);\n@@ -1449,2 +1449,2 @@\n-        return(xmlLoadExternalEntity((char *) entity->URI,\n-               (char *) entity->ExternalID, ctxt));\n+                return(xmlLoadExternalEntity((char *) entity->URI,\n+                       (char *) entity->ExternalID, ctxt));\n@@ -1452,3 +1452,3 @@\n-            xmlErrInternal(ctxt,\n-              \"Internal entity %s without content !\\n\",\n-                       entity->name);\n+                xmlErrInternal(ctxt,\n+                      \"Internal entity %s without content !\\n\",\n+                               entity->name);\n@@ -1457,3 +1457,3 @@\n-            xmlErrInternal(ctxt,\n-              \"Internal parameter entity %s without content !\\n\",\n-                       entity->name);\n+                xmlErrInternal(ctxt,\n+                      \"Internal parameter entity %s without content !\\n\",\n+                               entity->name);\n@@ -1462,3 +1462,3 @@\n-            xmlErrInternal(ctxt,\n-              \"Predefined entity %s without content !\\n\",\n-                       entity->name);\n+                xmlErrInternal(ctxt,\n+                      \"Predefined entity %s without content !\\n\",\n+                               entity->name);\n@@ -1466,2 +1466,2 @@\n-    }\n-    return(NULL);\n+        }\n+        return(NULL);\n@@ -1471,1 +1471,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1474,1 +1474,1 @@\n-    input->filename = (char *) xmlStrdup((xmlChar *) entity->URI);\n+        input->filename = (char *) xmlStrdup((xmlChar *) entity->URI);\n@@ -1498,2 +1498,2 @@\n-                   NULL);\n-    return(NULL);\n+                       NULL);\n+        return(NULL);\n@@ -1502,2 +1502,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"new fixed input: %.30s\\n\", buffer);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"new fixed input: %.30s\\n\", buffer);\n@@ -1507,1 +1507,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1533,2 +1533,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"new input from file: %s\\n\", filename);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"new input from file: %s\\n\", filename);\n@@ -1538,8 +1538,8 @@\n-    if (filename == NULL)\n-        __xmlLoaderErr(ctxt,\n-                       \"failed to load external entity: NULL filename \\n\",\n-               NULL);\n-    else\n-        __xmlLoaderErr(ctxt, \"failed to load external entity \\\"%s\\\"\\n\",\n-               (const char *) filename);\n-    return(NULL);\n+        if (filename == NULL)\n+            __xmlLoaderErr(ctxt,\n+                           \"failed to load external entity: NULL filename \\n\",\n+                           NULL);\n+        else\n+            __xmlLoaderErr(ctxt, \"failed to load external entity \\\"%s\\\"\\n\",\n+                           (const char *) filename);\n+        return(NULL);\n@@ -1549,2 +1549,4 @@\n-    if (inputStream == NULL)\n-    return(NULL);\n+    if (inputStream == NULL) {\n+        xmlFreeParserInputBuffer(buf);\n+        return(NULL);\n+    }\n@@ -1558,1 +1560,1 @@\n-    URI = xmlStrdup((xmlChar *) filename);\n+        URI = xmlStrdup((xmlChar *) filename);\n@@ -1560,1 +1562,1 @@\n-    URI = xmlStrdup((xmlChar *) inputStream->filename);\n+        URI = xmlStrdup((xmlChar *) inputStream->filename);\n@@ -1574,3 +1576,3 @@\n- *                                  *\n- *      Commodity functions to handle parser contexts       *\n- *                                  *\n+ *                                                                      *\n+ *              Commodity functions to handle parser contexts           *\n+ *                                                                      *\n@@ -1601,1 +1603,1 @@\n-    ctxt->dict = xmlDictCreate();\n+        ctxt->dict = xmlDictCreate();\n@@ -1604,1 +1606,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1609,1 +1611,1 @@\n-    ctxt->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));\n+        ctxt->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));\n@@ -1612,1 +1614,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1621,3 +1623,3 @@\n-    ctxt->inputTab = (xmlParserInputPtr *)\n-            xmlMalloc(5 * sizeof(xmlParserInputPtr));\n-    ctxt->inputMax = 5;\n+        ctxt->inputTab = (xmlParserInputPtr *)\n+                    xmlMalloc(5 * sizeof(xmlParserInputPtr));\n+        ctxt->inputMax = 5;\n@@ -1627,4 +1629,4 @@\n-    ctxt->inputNr = 0;\n-    ctxt->inputMax = 0;\n-    ctxt->input = NULL;\n-    return(-1);\n+        ctxt->inputNr = 0;\n+        ctxt->inputMax = 0;\n+        ctxt->input = NULL;\n+        return(-1);\n@@ -1651,2 +1653,2 @@\n-    ctxt->nodeTab = (xmlNodePtr *) xmlMalloc(10 * sizeof(xmlNodePtr));\n-    ctxt->nodeMax = 10;\n+        ctxt->nodeTab = (xmlNodePtr *) xmlMalloc(10 * sizeof(xmlNodePtr));\n+        ctxt->nodeMax = 10;\n@@ -1656,7 +1658,7 @@\n-    ctxt->nodeNr = 0;\n-    ctxt->nodeMax = 0;\n-    ctxt->node = NULL;\n-    ctxt->inputNr = 0;\n-    ctxt->inputMax = 0;\n-    ctxt->input = NULL;\n-    return(-1);\n+        ctxt->nodeNr = 0;\n+        ctxt->nodeMax = 0;\n+        ctxt->node = NULL;\n+        ctxt->inputNr = 0;\n+        ctxt->inputMax = 0;\n+        ctxt->input = NULL;\n+        return(-1);\n@@ -1669,2 +1671,2 @@\n-    ctxt->nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));\n-    ctxt->nameMax = 10;\n+        ctxt->nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));\n+        ctxt->nameMax = 10;\n@@ -1674,10 +1676,10 @@\n-    ctxt->nodeNr = 0;\n-    ctxt->nodeMax = 0;\n-    ctxt->node = NULL;\n-    ctxt->inputNr = 0;\n-    ctxt->inputMax = 0;\n-    ctxt->input = NULL;\n-    ctxt->nameNr = 0;\n-    ctxt->nameMax = 0;\n-    ctxt->name = NULL;\n-    return(-1);\n+        ctxt->nodeNr = 0;\n+        ctxt->nodeMax = 0;\n+        ctxt->node = NULL;\n+        ctxt->inputNr = 0;\n+        ctxt->inputMax = 0;\n+        ctxt->input = NULL;\n+        ctxt->nameNr = 0;\n+        ctxt->nameMax = 0;\n+        ctxt->name = NULL;\n+        return(-1);\n@@ -1690,2 +1692,2 @@\n-    ctxt->spaceTab = (int *) xmlMalloc(10 * sizeof(int));\n-    ctxt->spaceMax = 10;\n+        ctxt->spaceTab = (int *) xmlMalloc(10 * sizeof(int));\n+        ctxt->spaceMax = 10;\n@@ -1695,13 +1697,13 @@\n-    ctxt->nodeNr = 0;\n-    ctxt->nodeMax = 0;\n-    ctxt->node = NULL;\n-    ctxt->inputNr = 0;\n-    ctxt->inputMax = 0;\n-    ctxt->input = NULL;\n-    ctxt->nameNr = 0;\n-    ctxt->nameMax = 0;\n-    ctxt->name = NULL;\n-    ctxt->spaceNr = 0;\n-    ctxt->spaceMax = 0;\n-    ctxt->space = NULL;\n-    return(-1);\n+        ctxt->nodeNr = 0;\n+        ctxt->nodeMax = 0;\n+        ctxt->node = NULL;\n+        ctxt->inputNr = 0;\n+        ctxt->inputMax = 0;\n+        ctxt->input = NULL;\n+        ctxt->nameNr = 0;\n+        ctxt->nameMax = 0;\n+        ctxt->name = NULL;\n+        ctxt->spaceNr = 0;\n+        ctxt->spaceMax = 0;\n+        ctxt->space = NULL;\n+        return(-1);\n@@ -1730,2 +1732,2 @@\n-    ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;\n-    ctxt->options |= XML_PARSE_NOBLANKS;\n+        ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;\n+        ctxt->options |= XML_PARSE_NOBLANKS;\n@@ -1739,5 +1741,5 @@\n-    if (xmlGetWarningsDefaultValue == 0)\n-        ctxt->vctxt.warning = NULL;\n-    else\n-        ctxt->vctxt.warning = xmlParserValidityWarning;\n-    ctxt->vctxt.nodeMax = 0;\n+        if (xmlGetWarningsDefaultValue == 0)\n+            ctxt->vctxt.warning = NULL;\n+        else\n+            ctxt->vctxt.warning = xmlParserValidityWarning;\n+        ctxt->vctxt.nodeMax = 0;\n@@ -1813,6 +1815,6 @@\n-    cur = ctxt->freeElems;\n-    while (cur != NULL) {\n-        next = cur->next;\n-        xmlFree(cur);\n-        cur = next;\n-    }\n+        cur = ctxt->freeElems;\n+        while (cur != NULL) {\n+            next = cur->next;\n+            xmlFree(cur);\n+            cur = next;\n+        }\n@@ -1823,6 +1825,6 @@\n-    cur = ctxt->freeAttrs;\n-    while (cur != NULL) {\n-        next = cur->next;\n-        xmlFree(cur);\n-        cur = next;\n-    }\n+        cur = ctxt->freeAttrs;\n+        while (cur != NULL) {\n+            next = cur->next;\n+            xmlFree(cur);\n+            cur = next;\n+        }\n@@ -1846,1 +1848,1 @@\n-    xmlCatalogFreeLocal(ctxt->catalogs);\n+        xmlCatalogFreeLocal(ctxt->catalogs);\n@@ -1866,2 +1868,2 @@\n-    xmlErrMemory(NULL, \"cannot allocate parser context\\n\");\n-    return(NULL);\n+        xmlErrMemory(NULL, \"cannot allocate parser context\\n\");\n+        return(NULL);\n@@ -1872,1 +1874,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1878,3 +1880,3 @@\n- *                                  *\n- *      Handling of node information                *\n- *                                  *\n+ *                                                                      *\n+ *              Handling of node information                            *\n+ *                                                                      *\n@@ -2030,1 +2032,1 @@\n-        (ctxt->node_seq.buffer == NULL)) {\n+            (ctxt->node_seq.buffer == NULL)) {\n@@ -2037,1 +2039,1 @@\n-            (2 * ctxt->node_seq.maximum));\n+                        (2 * ctxt->node_seq.maximum));\n@@ -2047,1 +2049,1 @@\n-        xmlErrMemory(ctxt, \"failed to allocate buffer\\n\");\n+                xmlErrMemory(ctxt, \"failed to allocate buffer\\n\");\n@@ -2069,3 +2071,3 @@\n- *                                  *\n- *      Defaults settings                   *\n- *                                  *\n+ *                                                                      *\n+ *              Defaults settings                                       *\n+ *                                                                      *\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/parserInternals.c","additions":446,"deletions":444,"binary":false,"changes":890,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-                 XML_PATTERN_XSSEL | \\\n-                 XML_PATTERN_XSFIELD)\n+                                 XML_PATTERN_XSSEL | \\\n+                                 XML_PATTERN_XSFIELD)\n@@ -84,1 +84,1 @@\n-    r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \\\n+        r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \\\n@@ -92,4 +92,4 @@\n-    int flags;          \/* properties of that step *\/\n-    const xmlChar *name;    \/* first string value if NULL accept all *\/\n-    const xmlChar *ns;      \/* second string value *\/\n-    int nodeType;       \/* type of node *\/\n+    int flags;                  \/* properties of that step *\/\n+    const xmlChar *name;        \/* first string value if NULL accept all *\/\n+    const xmlChar *ns;          \/* second string value *\/\n+    int nodeType;               \/* type of node *\/\n@@ -101,4 +101,4 @@\n-    xmlDict *dict;      \/* the dictionary if any *\/\n-    int nbStep;         \/* number of steps in the automata *\/\n-    int maxStep;        \/* allocated number of steps *\/\n-    xmlStreamStepPtr steps; \/* the array of steps *\/\n+    xmlDict *dict;              \/* the dictionary if any *\/\n+    int nbStep;                 \/* number of steps in the automata *\/\n+    int maxStep;                \/* allocated number of steps *\/\n+    xmlStreamStepPtr steps;     \/* the array of steps *\/\n@@ -110,6 +110,6 @@\n-    xmlStreamCompPtr comp;  \/* the compiled stream *\/\n-    int nbState;        \/* number of states in the automata *\/\n-    int maxState;       \/* allocated number of states *\/\n-    int level;          \/* how deep are we ? *\/\n-    int *states;        \/* the array of step indexes *\/\n-    int flags;          \/* validation options *\/\n+    xmlStreamCompPtr comp;      \/* the compiled stream *\/\n+    int nbState;                \/* number of states in the automata *\/\n+    int maxState;               \/* allocated number of states *\/\n+    int level;                  \/* how deep are we ? *\/\n+    int *states;                \/* the array of step indexes *\/\n+    int flags;                  \/* validation options *\/\n@@ -165,2 +165,2 @@\n-    void *data;     \/* the associated template *\/\n-    xmlDictPtr dict;        \/* the optional dictionary *\/\n+    void *data;         \/* the associated template *\/\n+    xmlDictPtr dict;            \/* the optional dictionary *\/\n@@ -168,2 +168,2 @@\n-    const xmlChar *pattern; \/* the pattern *\/\n-    int flags;          \/* flags *\/\n+    const xmlChar *pattern;     \/* the pattern *\/\n+    int flags;                  \/* flags *\/\n@@ -179,8 +179,8 @@\n-    const xmlChar *cur;         \/* the current char being parsed *\/\n-    const xmlChar *base;        \/* the full expression *\/\n-    int            error;       \/* error code *\/\n-    xmlDictPtr     dict;        \/* the dictionary if any *\/\n-    xmlPatternPtr  comp;        \/* the result *\/\n-    xmlNodePtr     elem;        \/* the current node if any *\/\n-    const xmlChar **namespaces;     \/* the namespaces definitions *\/\n-    int   nb_namespaces;        \/* the number of namespaces *\/\n+    const xmlChar *cur;                 \/* the current char being parsed *\/\n+    const xmlChar *base;                \/* the full expression *\/\n+    int            error;               \/* error code *\/\n+    xmlDictPtr     dict;                \/* the dictionary if any *\/\n+    xmlPatternPtr  comp;                \/* the result *\/\n+    xmlNodePtr     elem;                \/* the current node if any *\/\n+    const xmlChar **namespaces;         \/* the namespaces definitions *\/\n+    int   nb_namespaces;                \/* the number of namespaces *\/\n@@ -190,3 +190,3 @@\n- *                                  *\n- *          Type functions                  *\n- *                                  *\n+ *                                                                      *\n+ *                      Type functions                                  *\n+ *                                                                      *\n@@ -208,3 +208,3 @@\n-    ERROR(NULL, NULL, NULL,\n-        \"xmlNewPattern : malloc failed\\n\");\n-    return(NULL);\n+        ERROR(NULL, NULL, NULL,\n+                \"xmlNewPattern : malloc failed\\n\");\n+        return(NULL);\n@@ -217,3 +217,3 @@\n-    ERROR(NULL, NULL, NULL,\n-        \"xmlNewPattern : malloc failed\\n\");\n-    return(NULL);\n+        ERROR(NULL, NULL, NULL,\n+                \"xmlNewPattern : malloc failed\\n\");\n+        return(NULL);\n@@ -241,1 +241,1 @@\n-    return;\n+        return;\n@@ -245,1 +245,1 @@\n-    xmlFree((xmlChar *)comp->pattern);\n+        xmlFree((xmlChar *)comp->pattern);\n@@ -248,6 +248,7 @@\n-        for (i = 0;i < comp->nbStep;i++) {\n-        op = &comp->steps[i];\n-        if (op->value != NULL)\n-            xmlFree((xmlChar *) op->value);\n-        if (op->value2 != NULL)\n-            xmlFree((xmlChar *) op->value2);\n+            for (i = 0;i < comp->nbStep;i++) {\n+                op = &comp->steps[i];\n+                if (op->value != NULL)\n+                    xmlFree((xmlChar *) op->value);\n+                if (op->value2 != NULL)\n+                    xmlFree((xmlChar *) op->value2);\n+            }\n@@ -255,2 +256,1 @@\n-    }\n-    xmlFree(comp->steps);\n+        xmlFree(comp->steps);\n@@ -276,4 +276,4 @@\n-    cur = comp;\n-    comp = comp->next;\n-    cur->next = NULL;\n-    xmlFreePatternInternal(cur);\n+        cur = comp;\n+        comp = comp->next;\n+        cur->next = NULL;\n+        xmlFreePatternInternal(cur);\n@@ -304,3 +304,3 @@\n-    ERROR(NULL, NULL, NULL,\n-        \"xmlNewPatParserContext : malloc failed\\n\");\n-    return(NULL);\n+        ERROR(NULL, NULL, NULL,\n+                \"xmlNewPatParserContext : malloc failed\\n\");\n+        return(NULL);\n@@ -333,1 +333,1 @@\n-    return;\n+        return;\n@@ -356,2 +356,2 @@\n-    temp = (xmlStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *\n-                                     sizeof(xmlStepOp));\n+        temp = (xmlStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *\n+                                         sizeof(xmlStepOp));\n@@ -359,6 +359,6 @@\n-        ERROR(ctxt, NULL, NULL,\n-                 \"xmlPatternAdd: realloc failed\\n\");\n-        return (-1);\n-    }\n-    comp->steps = temp;\n-    comp->maxStep *= 2;\n+            ERROR(ctxt, NULL, NULL,\n+                             \"xmlPatternAdd: realloc failed\\n\");\n+            return (-1);\n+        }\n+        comp->steps = temp;\n+        comp->maxStep *= 2;\n@@ -386,12 +386,12 @@\n-    register const xmlChar *tmp;\n-    register xmlPatOp op;\n-    i = j - 1;\n-    tmp = comp->steps[i].value;\n-    comp->steps[i].value = comp->steps[j].value;\n-    comp->steps[j].value = tmp;\n-    tmp = comp->steps[i].value2;\n-    comp->steps[i].value2 = comp->steps[j].value2;\n-    comp->steps[j].value2 = tmp;\n-    op = comp->steps[i].op;\n-    comp->steps[i].op = comp->steps[j].op;\n-    comp->steps[j].op = op;\n+        register const xmlChar *tmp;\n+        register xmlPatOp op;\n+        i = j - 1;\n+        tmp = comp->steps[i].value;\n+        comp->steps[i].value = comp->steps[j].value;\n+        comp->steps[j].value = tmp;\n+        tmp = comp->steps[i].value2;\n+        comp->steps[i].value2 = comp->steps[j].value2;\n+        comp->steps[j].value2 = tmp;\n+        op = comp->steps[i].op;\n+        comp->steps[i].op = comp->steps[j].op;\n+        comp->steps[j].op = op;\n@@ -419,5 +419,5 @@\n-        comp->steps[i].value = comp->steps[j].value;\n-        comp->steps[i].value2 = comp->steps[j].value2;\n-        comp->steps[i].op = comp->steps[j].op;\n-    }\n-    comp->nbStep--;\n+            comp->steps[i].value = comp->steps[j].value;\n+            comp->steps[i].value2 = comp->steps[j].value2;\n+            comp->steps[i].op = comp->steps[j].op;\n+        }\n+        comp->nbStep--;\n@@ -427,2 +427,2 @@\n-    temp = (xmlStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *\n-                                     sizeof(xmlStepOp));\n+        temp = (xmlStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *\n+                                         sizeof(xmlStepOp));\n@@ -430,6 +430,6 @@\n-        ERROR(ctxt, NULL, NULL,\n-                 \"xmlReversePattern: realloc failed\\n\");\n-        return (-1);\n-    }\n-    comp->steps = temp;\n-    comp->maxStep *= 2;\n+            ERROR(ctxt, NULL, NULL,\n+                             \"xmlReversePattern: realloc failed\\n\");\n+            return (-1);\n+        }\n+        comp->steps = temp;\n+        comp->maxStep *= 2;\n@@ -440,13 +440,13 @@\n-    register const xmlChar *tmp;\n-    register xmlPatOp op;\n-    tmp = comp->steps[i].value;\n-    comp->steps[i].value = comp->steps[j].value;\n-    comp->steps[j].value = tmp;\n-    tmp = comp->steps[i].value2;\n-    comp->steps[i].value2 = comp->steps[j].value2;\n-    comp->steps[j].value2 = tmp;\n-    op = comp->steps[i].op;\n-    comp->steps[i].op = comp->steps[j].op;\n-    comp->steps[j].op = op;\n-    j--;\n-    i++;\n+        register const xmlChar *tmp;\n+        register xmlPatOp op;\n+        tmp = comp->steps[i].value;\n+        comp->steps[i].value = comp->steps[j].value;\n+        comp->steps[j].value = tmp;\n+        tmp = comp->steps[i].value2;\n+        comp->steps[i].value2 = comp->steps[j].value2;\n+        comp->steps[j].value2 = tmp;\n+        op = comp->steps[i].op;\n+        comp->steps[i].op = comp->steps[j].op;\n+        comp->steps[j].op = op;\n+        j--;\n+        i++;\n@@ -461,3 +461,3 @@\n- *                                  *\n- *      The interpreter for the precompiled patterns        *\n- *                                  *\n+ *                                                                      *\n+ *              The interpreter for the precompiled patterns            *\n+ *                                                                      *\n@@ -470,2 +470,2 @@\n-    states->nbstates = 0;\n-    states->states = xmlMalloc(4 * sizeof(xmlStepState));\n+        states->nbstates = 0;\n+        states->states = xmlMalloc(4 * sizeof(xmlStepState));\n@@ -476,6 +476,6 @@\n-    tmp = (xmlStepStatePtr) xmlRealloc(states->states,\n-                   2 * states->maxstates * sizeof(xmlStepState));\n-    if (tmp == NULL)\n-        return(-1);\n-    states->states = tmp;\n-    states->maxstates *= 2;\n+        tmp = (xmlStepStatePtr) xmlRealloc(states->states,\n+                               2 * states->maxstates * sizeof(xmlStepState));\n+        if (tmp == NULL)\n+            return(-1);\n+        states->states = tmp;\n+        states->maxstates *= 2;\n@@ -510,2 +510,2 @@\n-    step = &comp->steps[i];\n-    switch (step->op) {\n+        step = &comp->steps[i];\n+        switch (step->op) {\n@@ -513,1 +513,1 @@\n-        goto found;\n+                goto found;\n@@ -515,4 +515,4 @@\n-        if (node->type == XML_NAMESPACE_DECL)\n-            goto rollback;\n-        node = node->parent;\n-        if ((node->type == XML_DOCUMENT_NODE) ||\n+                if (node->type == XML_NAMESPACE_DECL)\n+                    goto rollback;\n+                node = node->parent;\n+                if ((node->type == XML_DOCUMENT_NODE) ||\n@@ -520,1 +520,1 @@\n-            (node->type == XML_DOCB_DOCUMENT_NODE) ||\n+                    (node->type == XML_DOCB_DOCUMENT_NODE) ||\n@@ -522,3 +522,3 @@\n-            (node->type == XML_HTML_DOCUMENT_NODE))\n-            continue;\n-        goto rollback;\n+                    (node->type == XML_HTML_DOCUMENT_NODE))\n+                    continue;\n+                goto rollback;\n@@ -526,20 +526,20 @@\n-        if (node->type != XML_ELEMENT_NODE)\n-            goto rollback;\n-        if (step->value == NULL)\n-            continue;\n-        if (step->value[0] != node->name[0])\n-            goto rollback;\n-        if (!xmlStrEqual(step->value, node->name))\n-            goto rollback;\n-\n-        \/* Namespace test *\/\n-        if (node->ns == NULL) {\n-            if (step->value2 != NULL)\n-            goto rollback;\n-        } else if (node->ns->href != NULL) {\n-            if (step->value2 == NULL)\n-            goto rollback;\n-            if (!xmlStrEqual(step->value2, node->ns->href))\n-            goto rollback;\n-        }\n-        continue;\n+                if (node->type != XML_ELEMENT_NODE)\n+                    goto rollback;\n+                if (step->value == NULL)\n+                    continue;\n+                if (step->value[0] != node->name[0])\n+                    goto rollback;\n+                if (!xmlStrEqual(step->value, node->name))\n+                    goto rollback;\n+\n+                \/* Namespace test *\/\n+                if (node->ns == NULL) {\n+                    if (step->value2 != NULL)\n+                        goto rollback;\n+                } else if (node->ns->href != NULL) {\n+                    if (step->value2 == NULL)\n+                        goto rollback;\n+                    if (!xmlStrEqual(step->value2, node->ns->href))\n+                        goto rollback;\n+                }\n+                continue;\n@@ -547,1 +547,1 @@\n-        xmlNodePtr lst;\n+                xmlNodePtr lst;\n@@ -549,2 +549,2 @@\n-        if ((node->type != XML_ELEMENT_NODE) &&\n-            (node->type != XML_DOCUMENT_NODE) &&\n+                if ((node->type != XML_ELEMENT_NODE) &&\n+                    (node->type != XML_DOCUMENT_NODE) &&\n@@ -552,1 +552,1 @@\n-            (node->type != XML_DOCB_DOCUMENT_NODE) &&\n+                    (node->type != XML_DOCB_DOCUMENT_NODE) &&\n@@ -554,12 +554,17 @@\n-            (node->type != XML_HTML_DOCUMENT_NODE))\n-            goto rollback;\n-\n-        lst = node->children;\n-\n-        if (step->value != NULL) {\n-            while (lst != NULL) {\n-            if ((lst->type == XML_ELEMENT_NODE) &&\n-                (step->value[0] == lst->name[0]) &&\n-                (xmlStrEqual(step->value, lst->name)))\n-                break;\n-            lst = lst->next;\n+                    (node->type != XML_HTML_DOCUMENT_NODE))\n+                    goto rollback;\n+\n+                lst = node->children;\n+\n+                if (step->value != NULL) {\n+                    while (lst != NULL) {\n+                        if ((lst->type == XML_ELEMENT_NODE) &&\n+                            (step->value[0] == lst->name[0]) &&\n+                            (xmlStrEqual(step->value, lst->name)))\n+                            break;\n+                        lst = lst->next;\n+                    }\n+                    if (lst != NULL)\n+                        continue;\n+                }\n+                goto rollback;\n@@ -567,5 +572,0 @@\n-            if (lst != NULL)\n-            continue;\n-        }\n-        goto rollback;\n-        }\n@@ -573,17 +573,17 @@\n-        if (node->type != XML_ATTRIBUTE_NODE)\n-            goto rollback;\n-        if (step->value != NULL) {\n-            if (step->value[0] != node->name[0])\n-            goto rollback;\n-            if (!xmlStrEqual(step->value, node->name))\n-            goto rollback;\n-        }\n-        \/* Namespace test *\/\n-        if (node->ns == NULL) {\n-            if (step->value2 != NULL)\n-            goto rollback;\n-        } else if (step->value2 != NULL) {\n-            if (!xmlStrEqual(step->value2, node->ns->href))\n-            goto rollback;\n-        }\n-        continue;\n+                if (node->type != XML_ATTRIBUTE_NODE)\n+                    goto rollback;\n+                if (step->value != NULL) {\n+                    if (step->value[0] != node->name[0])\n+                        goto rollback;\n+                    if (!xmlStrEqual(step->value, node->name))\n+                        goto rollback;\n+                }\n+                \/* Namespace test *\/\n+                if (node->ns == NULL) {\n+                    if (step->value2 != NULL)\n+                        goto rollback;\n+                } else if (step->value2 != NULL) {\n+                    if (!xmlStrEqual(step->value2, node->ns->href))\n+                        goto rollback;\n+                }\n+                continue;\n@@ -591,2 +591,2 @@\n-        if ((node->type == XML_DOCUMENT_NODE) ||\n-            (node->type == XML_HTML_DOCUMENT_NODE) ||\n+                if ((node->type == XML_DOCUMENT_NODE) ||\n+                    (node->type == XML_HTML_DOCUMENT_NODE) ||\n@@ -594,1 +594,1 @@\n-            (node->type == XML_DOCB_DOCUMENT_NODE) ||\n+                    (node->type == XML_DOCB_DOCUMENT_NODE) ||\n@@ -596,22 +596,22 @@\n-            (node->type == XML_NAMESPACE_DECL))\n-            goto rollback;\n-        node = node->parent;\n-        if (node == NULL)\n-            goto rollback;\n-        if (step->value == NULL)\n-            continue;\n-        if (step->value[0] != node->name[0])\n-            goto rollback;\n-        if (!xmlStrEqual(step->value, node->name))\n-            goto rollback;\n-        \/* Namespace test *\/\n-        if (node->ns == NULL) {\n-            if (step->value2 != NULL)\n-            goto rollback;\n-        } else if (node->ns->href != NULL) {\n-            if (step->value2 == NULL)\n-            goto rollback;\n-            if (!xmlStrEqual(step->value2, node->ns->href))\n-            goto rollback;\n-        }\n-        continue;\n+                    (node->type == XML_NAMESPACE_DECL))\n+                    goto rollback;\n+                node = node->parent;\n+                if (node == NULL)\n+                    goto rollback;\n+                if (step->value == NULL)\n+                    continue;\n+                if (step->value[0] != node->name[0])\n+                    goto rollback;\n+                if (!xmlStrEqual(step->value, node->name))\n+                    goto rollback;\n+                \/* Namespace test *\/\n+                if (node->ns == NULL) {\n+                    if (step->value2 != NULL)\n+                        goto rollback;\n+                } else if (node->ns->href != NULL) {\n+                    if (step->value2 == NULL)\n+                        goto rollback;\n+                    if (!xmlStrEqual(step->value2, node->ns->href))\n+                        goto rollback;\n+                }\n+                continue;\n@@ -619,15 +619,15 @@\n-        \/* TODO: implement coalescing of ANCESTOR\/NODE ops *\/\n-        if (step->value == NULL) {\n-            i++;\n-            step = &comp->steps[i];\n-            if (step->op == XML_OP_ROOT)\n-            goto found;\n-            if (step->op != XML_OP_ELEM)\n-            goto rollback;\n-            if (step->value == NULL)\n-            return(-1);\n-        }\n-        if (node == NULL)\n-            goto rollback;\n-        if ((node->type == XML_DOCUMENT_NODE) ||\n-            (node->type == XML_HTML_DOCUMENT_NODE) ||\n+                \/* TODO: implement coalescing of ANCESTOR\/NODE ops *\/\n+                if (step->value == NULL) {\n+                    i++;\n+                    step = &comp->steps[i];\n+                    if (step->op == XML_OP_ROOT)\n+                        goto found;\n+                    if (step->op != XML_OP_ELEM)\n+                        goto rollback;\n+                    if (step->value == NULL)\n+                        return(-1);\n+                }\n+                if (node == NULL)\n+                    goto rollback;\n+                if ((node->type == XML_DOCUMENT_NODE) ||\n+                    (node->type == XML_HTML_DOCUMENT_NODE) ||\n@@ -635,1 +635,1 @@\n-            (node->type == XML_DOCB_DOCUMENT_NODE) ||\n+                    (node->type == XML_DOCB_DOCUMENT_NODE) ||\n@@ -637,10 +637,42 @@\n-            (node->type == XML_NAMESPACE_DECL))\n-            goto rollback;\n-        node = node->parent;\n-        while (node != NULL) {\n-            if ((node->type == XML_ELEMENT_NODE) &&\n-            (step->value[0] == node->name[0]) &&\n-            (xmlStrEqual(step->value, node->name))) {\n-            \/* Namespace test *\/\n-            if (node->ns == NULL) {\n-                if (step->value2 == NULL)\n+                    (node->type == XML_NAMESPACE_DECL))\n+                    goto rollback;\n+                node = node->parent;\n+                while (node != NULL) {\n+                    if ((node->type == XML_ELEMENT_NODE) &&\n+                        (step->value[0] == node->name[0]) &&\n+                        (xmlStrEqual(step->value, node->name))) {\n+                        \/* Namespace test *\/\n+                        if (node->ns == NULL) {\n+                            if (step->value2 == NULL)\n+                                break;\n+                        } else if (node->ns->href != NULL) {\n+                            if ((step->value2 != NULL) &&\n+                                (xmlStrEqual(step->value2, node->ns->href)))\n+                                break;\n+                        }\n+                    }\n+                    node = node->parent;\n+                }\n+                if (node == NULL)\n+                    goto rollback;\n+                \/*\n+                 * prepare a potential rollback from here\n+                 * for ancestors of that node.\n+                 *\/\n+                if (step->op == XML_OP_ANCESTOR)\n+                    xmlPatPushState(&states, i, node);\n+                else\n+                    xmlPatPushState(&states, i - 1, node);\n+                continue;\n+            case XML_OP_NS:\n+                if (node->type != XML_ELEMENT_NODE)\n+                    goto rollback;\n+                if (node->ns == NULL) {\n+                    if (step->value != NULL)\n+                        goto rollback;\n+                } else if (node->ns->href != NULL) {\n+                    if (step->value == NULL)\n+                        goto rollback;\n+                    if (!xmlStrEqual(step->value, node->ns->href))\n+                        goto rollback;\n+                }\n@@ -648,3 +680,3 @@\n-            } else if (node->ns->href != NULL) {\n-                if ((step->value2 != NULL) &&\n-                    (xmlStrEqual(step->value2, node->ns->href)))\n+            case XML_OP_ALL:\n+                if (node->type != XML_ELEMENT_NODE)\n+                    goto rollback;\n@@ -652,26 +684,0 @@\n-            }\n-            }\n-            node = node->parent;\n-        }\n-        if (node == NULL)\n-            goto rollback;\n-        \/*\n-         * prepare a potential rollback from here\n-         * for ancestors of that node.\n-         *\/\n-        if (step->op == XML_OP_ANCESTOR)\n-            xmlPatPushState(&states, i, node);\n-        else\n-            xmlPatPushState(&states, i - 1, node);\n-        continue;\n-            case XML_OP_NS:\n-        if (node->type != XML_ELEMENT_NODE)\n-            goto rollback;\n-        if (node->ns == NULL) {\n-            if (step->value != NULL)\n-            goto rollback;\n-        } else if (node->ns->href != NULL) {\n-            if (step->value == NULL)\n-            goto rollback;\n-            if (!xmlStrEqual(step->value, node->ns->href))\n-            goto rollback;\n@@ -679,6 +685,0 @@\n-        break;\n-            case XML_OP_ALL:\n-        if (node->type != XML_ELEMENT_NODE)\n-            goto rollback;\n-        break;\n-    }\n@@ -689,1 +689,1 @@\n-    xmlFree(states.states);\n+        xmlFree(states.states);\n@@ -695,1 +695,1 @@\n-    return(0);\n+        return(0);\n@@ -697,2 +697,2 @@\n-    xmlFree(states.states);\n-    return(0);\n+        xmlFree(states.states);\n+        return(0);\n@@ -710,3 +710,3 @@\n- *                                  *\n- *          Dedicated parser for templates          *\n- *                                  *\n+ *                                                                      *\n+ *                      Dedicated parser for templates                  *\n+ *                                                                      *\n@@ -715,3 +715,3 @@\n-#define TODO                                \\\n-    xmlGenericError(xmlGenericErrorContext,             \\\n-        \"Unimplemented block at %s:%d\\n\",               \\\n+#define TODO                                                            \\\n+    xmlGenericError(xmlGenericErrorContext,                             \\\n+            \"Unimplemented block at %s:%d\\n\",                           \\\n@@ -725,1 +725,1 @@\n-#define SKIP_BLANKS                         \\\n+#define SKIP_BLANKS                                                     \\\n@@ -732,1 +732,1 @@\n-#define PUSH(op, val, val2)                     \\\n+#define PUSH(op, val, val2)                                             \\\n@@ -735,2 +735,2 @@\n-#define XSLT_ERROR(X)                           \\\n-    { xsltError(ctxt, __FILE__, __LINE__, X);               \\\n+#define XSLT_ERROR(X)                                                   \\\n+    { xsltError(ctxt, __FILE__, __LINE__, X);                           \\\n@@ -739,2 +739,2 @@\n-#define XSLT_ERROR0(X)                          \\\n-    { xsltError(ctxt, __FILE__, __LINE__, X);               \\\n+#define XSLT_ERROR0(X)                                                  \\\n+    { xsltError(ctxt, __FILE__, __LINE__, X);                           \\\n@@ -765,4 +765,1 @@\n-    cur = q = CUR_PTR;\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    while ((IS_CHAR(val)) && (val != '\"')) {\n-        cur += len;\n+        cur = q = CUR_PTR;\n@@ -770,9 +767,3 @@\n-    }\n-    if (!IS_CHAR(val)) {\n-        ctxt->error = 1;\n-        return(NULL);\n-    } else {\n-        if (ctxt->dict)\n-        ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);\n-        else\n-        ret = xmlStrndup(q, cur - q);\n+        while ((IS_CHAR(val)) && (val != '\"')) {\n+            cur += len;\n+            val = xmlStringCurrentChar(NULL, cur, &len);\n@@ -780,2 +771,11 @@\n-    cur += len;\n-    CUR_PTR = cur;\n+        if (!IS_CHAR(val)) {\n+            ctxt->error = 1;\n+            return(NULL);\n+        } else {\n+            if (ctxt->dict)\n+                ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);\n+            else\n+                ret = xmlStrndup(q, cur - q);\n+        }\n+        cur += len;\n+        CUR_PTR = cur;\n@@ -784,4 +784,1 @@\n-    cur = q = CUR_PTR;\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    while ((IS_CHAR(val)) && (val != '\\'')) {\n-        cur += len;\n+        cur = q = CUR_PTR;\n@@ -789,9 +786,3 @@\n-    }\n-    if (!IS_CHAR(val)) {\n-        ctxt->error = 1;\n-        return(NULL);\n-    } else {\n-        if (ctxt->dict)\n-        ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);\n-        else\n-        ret = xmlStrndup(q, cur - q);\n+        while ((IS_CHAR(val)) && (val != '\\'')) {\n+            cur += len;\n+            val = xmlStringCurrentChar(NULL, cur, &len);\n@@ -799,2 +790,11 @@\n-    cur += len;\n-    CUR_PTR = cur;\n+        if (!IS_CHAR(val)) {\n+            ctxt->error = 1;\n+            return(NULL);\n+        } else {\n+            if (ctxt->dict)\n+                ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);\n+            else\n+                ret = xmlStrndup(q, cur - q);\n+        }\n+        cur += len;\n+        CUR_PTR = cur;\n@@ -802,3 +802,3 @@\n-    \/* XP_ERROR(XPATH_START_LITERAL_ERROR); *\/\n-    ctxt->error = 1;\n-    return(NULL);\n+        \/* XP_ERROR(XPATH_START_LITERAL_ERROR); *\/\n+        ctxt->error = 1;\n+        return(NULL);\n@@ -835,1 +835,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -839,5 +839,5 @@\n-       (val == '_') ||\n-       (IS_COMBINING(val)) ||\n-       (IS_EXTENDER(val))) {\n-    cur += len;\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n+           (val == '_') ||\n+           (IS_COMBINING(val)) ||\n+           (IS_EXTENDER(val))) {\n+        cur += len;\n+        val = xmlStringCurrentChar(NULL, cur, &len);\n@@ -846,1 +846,1 @@\n-    ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);\n+        ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);\n@@ -848,1 +848,1 @@\n-    ret = xmlStrndup(q, cur - q);\n+        ret = xmlStrndup(q, cur - q);\n@@ -873,1 +873,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -877,5 +877,5 @@\n-       (val == '_') ||\n-       (IS_COMBINING(val)) ||\n-       (IS_EXTENDER(val))) {\n-    cur += len;\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n+           (val == '_') ||\n+           (IS_COMBINING(val)) ||\n+           (IS_EXTENDER(val))) {\n+        cur += len;\n+        val = xmlStringCurrentChar(NULL, cur, &len);\n@@ -884,1 +884,1 @@\n-    ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);\n+        ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);\n@@ -886,1 +886,1 @@\n-    ret = xmlStrndup(q, cur - q);\n+        ret = xmlStrndup(q, cur - q);\n@@ -910,2 +910,2 @@\n-    NEXT;\n-    ret = xmlPatScanNCName(ctxt);\n+        NEXT;\n+        ret = xmlPatScanNCName(ctxt);\n@@ -932,9 +932,9 @@\n-    if (CUR == '*') {\n-        PUSH(XML_OP_ATTR, NULL, NULL);\n-        NEXT;\n-    } else {\n-        ERROR(NULL, NULL, NULL,\n-        \"xmlCompileAttributeTest : Name expected\\n\");\n-        ctxt->error = 1;\n-    }\n-    return;\n+        if (CUR == '*') {\n+            PUSH(XML_OP_ATTR, NULL, NULL);\n+            NEXT;\n+        } else {\n+            ERROR(NULL, NULL, NULL,\n+                \"xmlCompileAttributeTest : Name expected\\n\");\n+            ctxt->error = 1;\n+        }\n+        return;\n@@ -943,2 +943,2 @@\n-    int i;\n-    xmlChar *prefix = name;\n+        int i;\n+        xmlChar *prefix = name;\n@@ -946,1 +946,1 @@\n-    NEXT;\n+        NEXT;\n@@ -948,27 +948,2 @@\n-    if (IS_BLANK_CH(CUR)) {\n-        ERROR5(NULL, NULL, NULL, \"Invalid QName.\\n\", NULL);\n-        XML_PAT_FREE_STRING(ctxt, prefix);\n-        ctxt->error = 1;\n-        goto error;\n-    }\n-    \/*\n-    * This is a namespace match\n-    *\/\n-    token = xmlPatScanName(ctxt);\n-    if ((prefix[0] == 'x') &&\n-        (prefix[1] == 'm') &&\n-        (prefix[2] == 'l') &&\n-        (prefix[3] == 0))\n-    {\n-        XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE);\n-    } else {\n-        for (i = 0;i < ctxt->nb_namespaces;i++) {\n-        if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {\n-            XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])\n-            break;\n-        }\n-        }\n-        if (i >= ctxt->nb_namespaces) {\n-        ERROR5(NULL, NULL, NULL,\n-            \"xmlCompileAttributeTest : no namespace bound to prefix %s\\n\",\n-            prefix);\n+        if (IS_BLANK_CH(CUR)) {\n+            ERROR5(NULL, NULL, NULL, \"Invalid QName.\\n\", NULL);\n@@ -976,2 +951,2 @@\n-        ctxt->error = 1;\n-        goto error;\n+            ctxt->error = 1;\n+            goto error;\n@@ -979,6 +954,10 @@\n-    }\n-    XML_PAT_FREE_STRING(ctxt, prefix);\n-    if (token == NULL) {\n-        if (CUR == '*') {\n-        NEXT;\n-        PUSH(XML_OP_ATTR, NULL, URL);\n+        \/*\n+        * This is a namespace match\n+        *\/\n+        token = xmlPatScanName(ctxt);\n+        if ((prefix[0] == 'x') &&\n+            (prefix[1] == 'm') &&\n+            (prefix[2] == 'l') &&\n+            (prefix[3] == 0))\n+        {\n+            XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE);\n@@ -986,4 +965,28 @@\n-        ERROR(NULL, NULL, NULL,\n-            \"xmlCompileAttributeTest : Name expected\\n\");\n-        ctxt->error = 1;\n-        goto error;\n+            for (i = 0;i < ctxt->nb_namespaces;i++) {\n+                if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {\n+                    XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])\n+                    break;\n+                }\n+            }\n+            if (i >= ctxt->nb_namespaces) {\n+                ERROR5(NULL, NULL, NULL,\n+                    \"xmlCompileAttributeTest : no namespace bound to prefix %s\\n\",\n+                    prefix);\n+                XML_PAT_FREE_STRING(ctxt, prefix);\n+                ctxt->error = 1;\n+                goto error;\n+            }\n+        }\n+        XML_PAT_FREE_STRING(ctxt, prefix);\n+        if (token == NULL) {\n+            if (CUR == '*') {\n+                NEXT;\n+                PUSH(XML_OP_ATTR, NULL, URL);\n+            } else {\n+                ERROR(NULL, NULL, NULL,\n+                    \"xmlCompileAttributeTest : Name expected\\n\");\n+                ctxt->error = 1;\n+                goto error;\n+            }\n+        } else {\n+            PUSH(XML_OP_ATTR, token, URL);\n@@ -992,4 +995,1 @@\n-        PUSH(XML_OP_ATTR, token, URL);\n-    }\n-    } else {\n-    PUSH(XML_OP_ATTR, name, NULL);\n+        PUSH(XML_OP_ATTR, name, NULL);\n@@ -1000,1 +1000,1 @@\n-    XML_PAT_FREE_STRING(ctxt, URL)\n+        XML_PAT_FREE_STRING(ctxt, URL)\n@@ -1002,1 +1002,1 @@\n-    XML_PAT_FREE_STRING(ctxt, token);\n+        XML_PAT_FREE_STRING(ctxt, token);\n@@ -1025,26 +1025,3 @@\n-    \/*\n-    * Context node.\n-    *\/\n-    NEXT;\n-    PUSH(XML_OP_ELEM, NULL, NULL);\n-    return;\n-    }\n-    if (CUR == '@') {\n-    \/*\n-    * Attribute test.\n-    *\/\n-    if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {\n-        ERROR5(NULL, NULL, NULL,\n-        \"Unexpected attribute axis in '%s'.\\n\", ctxt->base);\n-        ctxt->error = 1;\n-        return;\n-    }\n-    NEXT;\n-    xmlCompileAttributeTest(ctxt);\n-    if (ctxt->error != 0)\n-        goto error;\n-    return;\n-    }\n-    name = xmlPatScanNCName(ctxt);\n-    if (name == NULL) {\n-    if (CUR == '*') {\n+        \/*\n+        * Context node.\n+        *\/\n@@ -1052,6 +1029,1 @@\n-        PUSH(XML_OP_ALL, NULL, NULL);\n-        return;\n-    } else {\n-        ERROR(NULL, NULL, NULL,\n-            \"xmlCompileStepPattern : Name expected\\n\");\n-        ctxt->error = 1;\n+        PUSH(XML_OP_ELEM, NULL, NULL);\n@@ -1060,16 +1032,1 @@\n-    }\n-    if (IS_BLANK_CH(CUR)) {\n-    hasBlanks = 1;\n-    SKIP_BLANKS;\n-    }\n-    if (CUR == ':') {\n-    NEXT;\n-    if (CUR != ':') {\n-        xmlChar *prefix = name;\n-        int i;\n-\n-        if (hasBlanks || IS_BLANK_CH(CUR)) {\n-        ERROR5(NULL, NULL, NULL, \"Invalid QName.\\n\", NULL);\n-        ctxt->error = 1;\n-        goto error;\n-        }\n+    if (CUR == '@') {\n@@ -1077,17 +1034,3 @@\n-         * This is a namespace match\n-         *\/\n-        token = xmlPatScanName(ctxt);\n-        if ((prefix[0] == 'x') &&\n-        (prefix[1] == 'm') &&\n-        (prefix[2] == 'l') &&\n-        (prefix[3] == 0))\n-        {\n-        XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)\n-        } else {\n-        for (i = 0;i < ctxt->nb_namespaces;i++) {\n-            if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {\n-            XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])\n-            break;\n-            }\n-        }\n-        if (i >= ctxt->nb_namespaces) {\n+        * Attribute test.\n+        *\/\n+        if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {\n@@ -1095,2 +1038,1 @@\n-            \"xmlCompileStepPattern : no namespace bound to prefix %s\\n\",\n-            prefix);\n+                \"Unexpected attribute axis in '%s'.\\n\", ctxt->base);\n@@ -1098,2 +1040,1 @@\n-            goto error;\n-        }\n+            return;\n@@ -1101,3 +1042,8 @@\n-        XML_PAT_FREE_STRING(ctxt, prefix);\n-        name = NULL;\n-        if (token == NULL) {\n+        NEXT;\n+        xmlCompileAttributeTest(ctxt);\n+        if (ctxt->error != 0)\n+            goto error;\n+        return;\n+    }\n+    name = xmlPatScanNCName(ctxt);\n+    if (name == NULL) {\n@@ -1106,1 +1052,2 @@\n-            PUSH(XML_OP_NS, URL, NULL);\n+            PUSH(XML_OP_ALL, NULL, NULL);\n+            return;\n@@ -1109,1 +1056,1 @@\n-                \"xmlCompileStepPattern : Name expected\\n\");\n+                    \"xmlCompileStepPattern : Name expected\\n\");\n@@ -1111,14 +1058,0 @@\n-            goto error;\n-        }\n-        } else {\n-        PUSH(XML_OP_ELEM, token, URL);\n-        }\n-    } else {\n-        NEXT;\n-        if (xmlStrEqual(name, (const xmlChar *) \"child\")) {\n-        XML_PAT_FREE_STRING(ctxt, name);\n-        name = xmlPatScanName(ctxt);\n-        if (name == NULL) {\n-            if (CUR == '*') {\n-            NEXT;\n-            PUSH(XML_OP_ALL, NULL, NULL);\n@@ -1126,6 +1059,0 @@\n-            } else {\n-            ERROR(NULL, NULL, NULL,\n-                \"xmlCompileStepPattern : QName expected\\n\");\n-            ctxt->error = 1;\n-            goto error;\n-            }\n@@ -1133,1 +1060,8 @@\n-        if (CUR == ':') {\n+    }\n+    if (IS_BLANK_CH(CUR)) {\n+        hasBlanks = 1;\n+        SKIP_BLANKS;\n+    }\n+    if (CUR == ':') {\n+        NEXT;\n+        if (CUR != ':') {\n@@ -1137,5 +1071,4 @@\n-            NEXT;\n-            if (IS_BLANK_CH(CUR)) {\n-            ERROR5(NULL, NULL, NULL, \"Invalid QName.\\n\", NULL);\n-            ctxt->error = 1;\n-            goto error;\n+            if (hasBlanks || IS_BLANK_CH(CUR)) {\n+                ERROR5(NULL, NULL, NULL, \"Invalid QName.\\n\", NULL);\n+                ctxt->error = 1;\n+                goto error;\n@@ -1144,2 +1077,2 @@\n-            * This is a namespace match\n-            *\/\n+             * This is a namespace match\n+             *\/\n@@ -1148,3 +1081,3 @@\n-            (prefix[1] == 'm') &&\n-            (prefix[2] == 'l') &&\n-            (prefix[3] == 0))\n+                (prefix[1] == 'm') &&\n+                (prefix[2] == 'l') &&\n+                (prefix[3] == 0))\n@@ -1152,1 +1085,1 @@\n-            XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)\n+                XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)\n@@ -1154,4 +1087,12 @@\n-            for (i = 0;i < ctxt->nb_namespaces;i++) {\n-                if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {\n-                XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])\n-                break;\n+                for (i = 0;i < ctxt->nb_namespaces;i++) {\n+                    if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {\n+                        XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])\n+                        break;\n+                    }\n+                }\n+                if (i >= ctxt->nb_namespaces) {\n+                    ERROR5(NULL, NULL, NULL,\n+                        \"xmlCompileStepPattern : no namespace bound to prefix %s\\n\",\n+                        prefix);\n+                    ctxt->error = 1;\n+                    goto error;\n@@ -1159,8 +1100,0 @@\n-            }\n-            if (i >= ctxt->nb_namespaces) {\n-                ERROR5(NULL, NULL, NULL,\n-                \"xmlCompileStepPattern : no namespace bound \"\n-                \"to prefix %s\\n\", prefix);\n-                ctxt->error = 1;\n-                goto error;\n-            }\n@@ -1171,3 +1104,9 @@\n-            if (CUR == '*') {\n-                NEXT;\n-                PUSH(XML_OP_NS, URL, NULL);\n+                if (CUR == '*') {\n+                    NEXT;\n+                    PUSH(XML_OP_NS, URL, NULL);\n+                } else {\n+                    ERROR(NULL, NULL, NULL,\n+                            \"xmlCompileStepPattern : Name expected\\n\");\n+                    ctxt->error = 1;\n+                    goto error;\n+                }\n@@ -1175,4 +1114,1 @@\n-                ERROR(NULL, NULL, NULL,\n-                \"xmlCompileStepPattern : Name expected\\n\");\n-                ctxt->error = 1;\n-                goto error;\n+                PUSH(XML_OP_ELEM, token, URL);\n@@ -1180,0 +1116,83 @@\n+        } else {\n+            NEXT;\n+            if (xmlStrEqual(name, (const xmlChar *) \"child\")) {\n+                XML_PAT_FREE_STRING(ctxt, name);\n+                name = xmlPatScanName(ctxt);\n+                if (name == NULL) {\n+                    if (CUR == '*') {\n+                        NEXT;\n+                        PUSH(XML_OP_ALL, NULL, NULL);\n+                        return;\n+                    } else {\n+                        ERROR(NULL, NULL, NULL,\n+                            \"xmlCompileStepPattern : QName expected\\n\");\n+                        ctxt->error = 1;\n+                        goto error;\n+                    }\n+                }\n+                if (CUR == ':') {\n+                    xmlChar *prefix = name;\n+                    int i;\n+\n+                    NEXT;\n+                    if (IS_BLANK_CH(CUR)) {\n+                        ERROR5(NULL, NULL, NULL, \"Invalid QName.\\n\", NULL);\n+                        ctxt->error = 1;\n+                        goto error;\n+                    }\n+                    \/*\n+                    * This is a namespace match\n+                    *\/\n+                    token = xmlPatScanName(ctxt);\n+                    if ((prefix[0] == 'x') &&\n+                        (prefix[1] == 'm') &&\n+                        (prefix[2] == 'l') &&\n+                        (prefix[3] == 0))\n+                    {\n+                        XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)\n+                    } else {\n+                        for (i = 0;i < ctxt->nb_namespaces;i++) {\n+                            if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {\n+                                XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])\n+                                break;\n+                            }\n+                        }\n+                        if (i >= ctxt->nb_namespaces) {\n+                            ERROR5(NULL, NULL, NULL,\n+                                \"xmlCompileStepPattern : no namespace bound \"\n+                                \"to prefix %s\\n\", prefix);\n+                            ctxt->error = 1;\n+                            goto error;\n+                        }\n+                    }\n+                    XML_PAT_FREE_STRING(ctxt, prefix);\n+                    name = NULL;\n+                    if (token == NULL) {\n+                        if (CUR == '*') {\n+                            NEXT;\n+                            PUSH(XML_OP_NS, URL, NULL);\n+                        } else {\n+                            ERROR(NULL, NULL, NULL,\n+                                \"xmlCompileStepPattern : Name expected\\n\");\n+                            ctxt->error = 1;\n+                            goto error;\n+                        }\n+                    } else {\n+                        PUSH(XML_OP_CHILD, token, URL);\n+                    }\n+                } else\n+                    PUSH(XML_OP_CHILD, name, NULL);\n+                return;\n+            } else if (xmlStrEqual(name, (const xmlChar *) \"attribute\")) {\n+                XML_PAT_FREE_STRING(ctxt, name)\n+                name = NULL;\n+                if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {\n+                    ERROR5(NULL, NULL, NULL,\n+                        \"Unexpected attribute axis in '%s'.\\n\", ctxt->base);\n+                    ctxt->error = 1;\n+                    goto error;\n+                }\n+                xmlCompileAttributeTest(ctxt);\n+                if (ctxt->error != 0)\n+                    goto error;\n+                return;\n@@ -1181,1 +1200,4 @@\n-            PUSH(XML_OP_CHILD, token, URL);\n+                ERROR5(NULL, NULL, NULL,\n+                    \"The 'element' or 'attribute' axis is expected.\\n\", NULL);\n+                ctxt->error = 1;\n+                goto error;\n@@ -1183,21 +1205,0 @@\n-        } else\n-            PUSH(XML_OP_CHILD, name, NULL);\n-        return;\n-        } else if (xmlStrEqual(name, (const xmlChar *) \"attribute\")) {\n-        XML_PAT_FREE_STRING(ctxt, name)\n-        name = NULL;\n-        if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {\n-            ERROR5(NULL, NULL, NULL,\n-            \"Unexpected attribute axis in '%s'.\\n\", ctxt->base);\n-            ctxt->error = 1;\n-            goto error;\n-        }\n-        xmlCompileAttributeTest(ctxt);\n-        if (ctxt->error != 0)\n-            goto error;\n-        return;\n-        } else {\n-        ERROR5(NULL, NULL, NULL,\n-            \"The 'element' or 'attribute' axis is expected.\\n\", NULL);\n-        ctxt->error = 1;\n-        goto error;\n@@ -1205,1 +1206,0 @@\n-    }\n@@ -1208,5 +1208,5 @@\n-        ctxt->error = 1;\n-        goto error;\n-    }\n-    NEXT;\n-    PUSH(XML_OP_ALL, token, NULL);\n+            ctxt->error = 1;\n+            goto error;\n+        }\n+        NEXT;\n+        PUSH(XML_OP_ALL, token, NULL);\n@@ -1214,1 +1214,1 @@\n-    PUSH(XML_OP_ELEM, name, NULL);\n+        PUSH(XML_OP_ELEM, name, NULL);\n@@ -1219,1 +1219,1 @@\n-    XML_PAT_FREE_STRING(ctxt, URL)\n+        XML_PAT_FREE_STRING(ctxt, URL)\n@@ -1221,1 +1221,1 @@\n-    XML_PAT_FREE_STRING(ctxt, token)\n+        XML_PAT_FREE_STRING(ctxt, token)\n@@ -1223,1 +1223,1 @@\n-    XML_PAT_FREE_STRING(ctxt, name)\n+        XML_PAT_FREE_STRING(ctxt, name)\n@@ -1245,30 +1245,1 @@\n-    PUSH(XML_OP_ANCESTOR, NULL, NULL);\n-    NEXT;\n-    NEXT;\n-    } else if ((CUR == '.') && (NXT(1) == '\/') && (NXT(2) == '\/')) {\n-    PUSH(XML_OP_ANCESTOR, NULL, NULL);\n-    NEXT;\n-    NEXT;\n-    NEXT;\n-    \/* Check for incompleteness. *\/\n-    SKIP_BLANKS;\n-    if (CUR == 0) {\n-        ERROR5(NULL, NULL, NULL,\n-           \"Incomplete expression '%s'.\\n\", ctxt->base);\n-        ctxt->error = 1;\n-        goto error;\n-    }\n-    }\n-    if (CUR == '@') {\n-    NEXT;\n-    xmlCompileAttributeTest(ctxt);\n-    SKIP_BLANKS;\n-    \/* TODO: check for incompleteness *\/\n-    if (CUR != 0) {\n-        xmlCompileStepPattern(ctxt);\n-        if (ctxt->error != 0)\n-        goto error;\n-    }\n-    } else {\n-        if (CUR == '\/') {\n-        PUSH(XML_OP_ROOT, NULL, NULL);\n+        PUSH(XML_OP_ANCESTOR, NULL, NULL);\n@@ -1276,16 +1247,3 @@\n-        \/* Check for incompleteness. *\/\n-        SKIP_BLANKS;\n-        if (CUR == 0) {\n-        ERROR5(NULL, NULL, NULL,\n-            \"Incomplete expression '%s'.\\n\", ctxt->base);\n-        ctxt->error = 1;\n-        goto error;\n-        }\n-    }\n-    xmlCompileStepPattern(ctxt);\n-    if (ctxt->error != 0)\n-        goto error;\n-    SKIP_BLANKS;\n-    while (CUR == '\/') {\n-        if (NXT(1) == '\/') {\n-            PUSH(XML_OP_ANCESTOR, NULL, NULL);\n+        NEXT;\n+    } else if ((CUR == '.') && (NXT(1) == '\/') && (NXT(2) == '\/')) {\n+        PUSH(XML_OP_ANCESTOR, NULL, NULL);\n@@ -1294,6 +1252,0 @@\n-        SKIP_BLANKS;\n-        xmlCompileStepPattern(ctxt);\n-        if (ctxt->error != 0)\n-            goto error;\n-        } else {\n-            PUSH(XML_OP_PARENT, NULL, NULL);\n@@ -1301,0 +1253,1 @@\n+        \/* Check for incompleteness. *\/\n@@ -1304,1 +1257,1 @@\n-            \"Incomplete expression '%s'.\\n\", ctxt->base);\n+               \"Incomplete expression '%s'.\\n\", ctxt->base);\n@@ -1308,0 +1261,24 @@\n+    }\n+    if (CUR == '@') {\n+        NEXT;\n+        xmlCompileAttributeTest(ctxt);\n+        SKIP_BLANKS;\n+        \/* TODO: check for incompleteness *\/\n+        if (CUR != 0) {\n+            xmlCompileStepPattern(ctxt);\n+            if (ctxt->error != 0)\n+                goto error;\n+        }\n+    } else {\n+        if (CUR == '\/') {\n+            PUSH(XML_OP_ROOT, NULL, NULL);\n+            NEXT;\n+            \/* Check for incompleteness. *\/\n+            SKIP_BLANKS;\n+            if (CUR == 0) {\n+                ERROR5(NULL, NULL, NULL,\n+                    \"Incomplete expression '%s'.\\n\", ctxt->base);\n+                ctxt->error = 1;\n+                goto error;\n+            }\n+        }\n@@ -1311,0 +1288,24 @@\n+        SKIP_BLANKS;\n+        while (CUR == '\/') {\n+            if (NXT(1) == '\/') {\n+                PUSH(XML_OP_ANCESTOR, NULL, NULL);\n+                NEXT;\n+                NEXT;\n+                SKIP_BLANKS;\n+                xmlCompileStepPattern(ctxt);\n+                if (ctxt->error != 0)\n+                    goto error;\n+            } else {\n+                PUSH(XML_OP_PARENT, NULL, NULL);\n+                NEXT;\n+                SKIP_BLANKS;\n+                if (CUR == 0) {\n+                    ERROR5(NULL, NULL, NULL,\n+                    \"Incomplete expression '%s'.\\n\", ctxt->base);\n+                    ctxt->error = 1;\n+                    goto error;\n+                }\n+                xmlCompileStepPattern(ctxt);\n+                if (ctxt->error != 0)\n+                    goto error;\n+            }\n@@ -1313,1 +1314,0 @@\n-    }\n@@ -1315,3 +1315,3 @@\n-    ERROR5(NULL, NULL, NULL,\n-           \"Failed to compile pattern %s\\n\", ctxt->base);\n-    ctxt->error = 1;\n+        ERROR5(NULL, NULL, NULL,\n+               \"Failed to compile pattern %s\\n\", ctxt->base);\n+        ctxt->error = 1;\n@@ -1336,4 +1336,4 @@\n-    ERROR5(NULL, NULL, NULL,\n-        \"Unexpected selection of the document root in '%s'.\\n\",\n-        ctxt->base);\n-    goto error;\n+        ERROR5(NULL, NULL, NULL,\n+            \"Unexpected selection of the document root in '%s'.\\n\",\n+            ctxt->base);\n+        goto error;\n@@ -1344,27 +1344,9 @@\n-    \/* \".\" - \"self::node()\" *\/\n-    NEXT;\n-    SKIP_BLANKS;\n-    if (CUR == 0) {\n-        \/*\n-        * Selection of the context node.\n-        *\/\n-        PUSH(XML_OP_ELEM, NULL, NULL);\n-        return;\n-    }\n-    if (CUR != '\/') {\n-        \/* TODO: A more meaningful error message. *\/\n-        ERROR5(NULL, NULL, NULL,\n-        \"Unexpected token after '.' in '%s'.\\n\", ctxt->base);\n-        goto error;\n-    }\n-    \/* \".\/\" - \"self::node()\/\" *\/\n-    NEXT;\n-    SKIP_BLANKS;\n-    if (CUR == '\/') {\n-        if (IS_BLANK_CH(PEEKPREV(1))) {\n-        \/*\n-        * Disallow \".\/ \/\"\n-        *\/\n-        ERROR5(NULL, NULL, NULL,\n-            \"Unexpected '\/' token in '%s'.\\n\", ctxt->base);\n-        goto error;\n+        \/* \".\" - \"self::node()\" *\/\n+        NEXT;\n+        SKIP_BLANKS;\n+        if (CUR == 0) {\n+            \/*\n+            * Selection of the context node.\n+            *\/\n+            PUSH(XML_OP_ELEM, NULL, NULL);\n+            return;\n@@ -1372,2 +1354,7 @@\n-        \/* \".\/\/\" - \"self:node()\/descendant-or-self::node()\/\" *\/\n-        PUSH(XML_OP_ANCESTOR, NULL, NULL);\n+        if (CUR != '\/') {\n+            \/* TODO: A more meaningful error message. *\/\n+            ERROR5(NULL, NULL, NULL,\n+            \"Unexpected token after '.' in '%s'.\\n\", ctxt->base);\n+            goto error;\n+        }\n+        \/* \".\/\" - \"self::node()\/\" *\/\n@@ -1376,3 +1363,16 @@\n-    }\n-    if (CUR == 0)\n-        goto error_unfinished;\n+        if (CUR == '\/') {\n+            if (IS_BLANK_CH(PEEKPREV(1))) {\n+                \/*\n+                * Disallow \".\/ \/\"\n+                *\/\n+                ERROR5(NULL, NULL, NULL,\n+                    \"Unexpected '\/' token in '%s'.\\n\", ctxt->base);\n+                goto error;\n+            }\n+            \/* \".\/\/\" - \"self:node()\/descendant-or-self::node()\/\" *\/\n+            PUSH(XML_OP_ANCESTOR, NULL, NULL);\n+            NEXT;\n+            SKIP_BLANKS;\n+        }\n+        if (CUR == 0)\n+            goto error_unfinished;\n@@ -1384,20 +1384,20 @@\n-    xmlCompileStepPattern(ctxt);\n-    if (ctxt->error != 0)\n-        goto error;\n-    SKIP_BLANKS;\n-    if (CUR != '\/')\n-        break;\n-    PUSH(XML_OP_PARENT, NULL, NULL);\n-    NEXT;\n-    SKIP_BLANKS;\n-    if (CUR == '\/') {\n-        \/*\n-        * Disallow subsequent '\/\/'.\n-        *\/\n-        ERROR5(NULL, NULL, NULL,\n-        \"Unexpected subsequent '\/\/' in '%s'.\\n\",\n-        ctxt->base);\n-        goto error;\n-    }\n-    if (CUR == 0)\n-        goto error_unfinished;\n+        xmlCompileStepPattern(ctxt);\n+        if (ctxt->error != 0)\n+            goto error;\n+        SKIP_BLANKS;\n+        if (CUR != '\/')\n+            break;\n+        PUSH(XML_OP_PARENT, NULL, NULL);\n+        NEXT;\n+        SKIP_BLANKS;\n+        if (CUR == '\/') {\n+            \/*\n+            * Disallow subsequent '\/\/'.\n+            *\/\n+            ERROR5(NULL, NULL, NULL,\n+                \"Unexpected subsequent '\/\/' in '%s'.\\n\",\n+                ctxt->base);\n+            goto error;\n+        }\n+        if (CUR == 0)\n+            goto error_unfinished;\n@@ -1408,3 +1408,3 @@\n-    ERROR5(NULL, NULL, NULL,\n-        \"Failed to compile expression '%s'.\\n\", ctxt->base);\n-    ctxt->error = 1;\n+        ERROR5(NULL, NULL, NULL,\n+            \"Failed to compile expression '%s'.\\n\", ctxt->base);\n+        ctxt->error = 1;\n@@ -1420,1 +1420,1 @@\n-    \"Unfinished expression '%s'.\\n\", ctxt->base);\n+        \"Unfinished expression '%s'.\\n\", ctxt->base);\n@@ -1425,3 +1425,3 @@\n- *                                  *\n- *          The streaming code              *\n- *                                  *\n+ *                                                                      *\n+ *                      The streaming code                              *\n+ *                                                                      *\n@@ -1437,1 +1437,1 @@\n-    return;\n+        return;\n@@ -1441,3 +1441,3 @@\n-    if (stream->steps[i].ns != NULL) {\n-        printf(\"{%s}\", stream->steps[i].ns);\n-    }\n+        if (stream->steps[i].ns != NULL) {\n+            printf(\"{%s}\", stream->steps[i].ns);\n+        }\n@@ -1445,11 +1445,11 @@\n-        printf(\"* \");\n-    } else {\n-        printf(\"%s \", stream->steps[i].name);\n-    }\n-    if (stream->steps[i].flags & XML_STREAM_STEP_ROOT)\n-        printf(\"root \");\n-    if (stream->steps[i].flags & XML_STREAM_STEP_DESC)\n-        printf(\"\/\/ \");\n-    if (stream->steps[i].flags & XML_STREAM_STEP_FINAL)\n-        printf(\"final \");\n-    printf(\"\\n\");\n+            printf(\"* \");\n+        } else {\n+            printf(\"%s \", stream->steps[i].name);\n+        }\n+        if (stream->steps[i].flags & XML_STREAM_STEP_ROOT)\n+            printf(\"root \");\n+        if (stream->steps[i].flags & XML_STREAM_STEP_DESC)\n+            printf(\"\/\/ \");\n+        if (stream->steps[i].flags & XML_STREAM_STEP_FINAL)\n+            printf(\"final \");\n+        printf(\"\\n\");\n@@ -1464,1 +1464,1 @@\n-    return;\n+        return;\n@@ -1473,4 +1473,4 @@\n-        printf(\" %d: free\\n\", i);\n-    else {\n-        printf(\" %d: step %d, level %d\", i, ctxt->states[2 * i],\n-               ctxt->states[(2 * i) + 1]);\n+            printf(\" %d: free\\n\", i);\n+        else {\n+            printf(\" %d: step %d, level %d\", i, ctxt->states[2 * i],\n+                   ctxt->states[(2 * i) + 1]);\n@@ -1478,5 +1478,5 @@\n-            XML_STREAM_STEP_DESC)\n-            printf(\" \/\/\\n\");\n-        else\n-            printf(\"\\n\");\n-    }\n+                XML_STREAM_STEP_DESC)\n+                printf(\" \/\/\\n\");\n+            else\n+                printf(\"\\n\");\n+        }\n@@ -1503,3 +1503,3 @@\n-    ERROR(NULL, NULL, NULL,\n-        \"xmlNewStreamComp: malloc failed\\n\");\n-    return(NULL);\n+        ERROR(NULL, NULL, NULL,\n+                \"xmlNewStreamComp: malloc failed\\n\");\n+        return(NULL);\n@@ -1510,4 +1510,4 @@\n-    xmlFree(cur);\n-    ERROR(NULL, NULL, NULL,\n-          \"xmlNewStreamComp: malloc failed\\n\");\n-    return(NULL);\n+        xmlFree(cur);\n+        ERROR(NULL, NULL, NULL,\n+              \"xmlNewStreamComp: malloc failed\\n\");\n+        return(NULL);\n@@ -1530,3 +1530,3 @@\n-        xmlFree(comp->steps);\n-    if (comp->dict != NULL)\n-        xmlDictFree(comp->dict);\n+            xmlFree(comp->steps);\n+        if (comp->dict != NULL)\n+            xmlDictFree(comp->dict);\n@@ -1554,8 +1554,8 @@\n-    cur = (xmlStreamStepPtr) xmlRealloc(comp->steps,\n-                 comp->maxStep * 2 * sizeof(xmlStreamStep));\n-    if (cur == NULL) {\n-        ERROR(NULL, NULL, NULL,\n-          \"xmlNewStreamComp: malloc failed\\n\");\n-        return(-1);\n-    }\n-    comp->steps = cur;\n+        cur = (xmlStreamStepPtr) xmlRealloc(comp->steps,\n+                                 comp->maxStep * 2 * sizeof(xmlStreamStep));\n+        if (cur == NULL) {\n+            ERROR(NULL, NULL, NULL,\n+                  \"xmlNewStreamComp: malloc failed\\n\");\n+            return(-1);\n+        }\n+        comp->steps = cur;\n@@ -1593,9 +1593,9 @@\n-    (comp->steps[0].value == NULL) &&\n-    (comp->steps[0].value2 == NULL)) {\n-    stream = xmlNewStreamComp(0);\n-    if (stream == NULL)\n-        return(-1);\n-    \/* Note that the stream will have no steps in this case. *\/\n-    stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;\n-    comp->stream = stream;\n-    return(0);\n+        (comp->steps[0].value == NULL) &&\n+        (comp->steps[0].value2 == NULL)) {\n+        stream = xmlNewStreamComp(0);\n+        if (stream == NULL)\n+            return(-1);\n+        \/* Note that the stream will have no steps in this case. *\/\n+        stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;\n+        comp->stream = stream;\n+        return(0);\n@@ -1609,1 +1609,1 @@\n-    xmlDictReference(stream->dict);\n+        xmlDictReference(stream->dict);\n@@ -1614,1 +1614,1 @@\n-    stream->flags |= XML_STREAM_FROM_ROOT;\n+        stream->flags |= XML_STREAM_FROM_ROOT;\n@@ -1617,1 +1617,1 @@\n-    step = comp->steps[i];\n+        step = comp->steps[i];\n@@ -1619,57 +1619,17 @@\n-        case XML_OP_END:\n-            break;\n-        case XML_OP_ROOT:\n-            if (i != 0)\n-            goto error;\n-        root = 1;\n-        break;\n-        case XML_OP_NS:\n-        s = xmlStreamCompAddStep(stream, NULL, step.value,\n-            XML_ELEMENT_NODE, flags);\n-        if (s < 0)\n-            goto error;\n-        prevs = s;\n-        flags = 0;\n-        break;\n-        case XML_OP_ATTR:\n-        flags |= XML_STREAM_STEP_ATTR;\n-        prevs = -1;\n-        s = xmlStreamCompAddStep(stream,\n-            step.value, step.value2, XML_ATTRIBUTE_NODE, flags);\n-        flags = 0;\n-        if (s < 0)\n-            goto error;\n-        break;\n-        case XML_OP_ELEM:\n-            if ((step.value == NULL) && (step.value2 == NULL)) {\n-            \/*\n-            * We have a \".\" or \"self::node()\" here.\n-            * Eliminate redundant self::node() tests like in \"\/.\/.\"\n-            * or \"\/\/.\/\"\n-            * The only case we won't eliminate is \"\/\/.\", i.e. if\n-            * self::node() is the last node test and we had\n-            * continuation somewhere beforehand.\n-            *\/\n-            if ((comp->nbStep == i + 1) &&\n-            (flags & XML_STREAM_STEP_DESC)) {\n-            \/*\n-            * Mark the special case where the expression resolves\n-            * to any type of node.\n-            *\/\n-            if (comp->nbStep == i + 1) {\n-                stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;\n-            }\n-            flags |= XML_STREAM_STEP_NODE;\n-            s = xmlStreamCompAddStep(stream, NULL, NULL,\n-                XML_STREAM_ANY_NODE, flags);\n-            if (s < 0)\n-                goto error;\n-            flags = 0;\n-            \/*\n-            * If there was a previous step, mark it to be added to\n-            * the result node-set; this is needed since only\n-            * the last step will be marked as \"final\" and only\n-            * \"final\" nodes are added to the resulting set.\n-            *\/\n-            if (prevs != -1) {\n-                stream->steps[prevs].flags |= XML_STREAM_STEP_IN_SET;\n+            case XML_OP_END:\n+                break;\n+            case XML_OP_ROOT:\n+                if (i != 0)\n+                    goto error;\n+                root = 1;\n+                break;\n+            case XML_OP_NS:\n+                s = xmlStreamCompAddStep(stream, NULL, step.value,\n+                    XML_ELEMENT_NODE, flags);\n+                if (s < 0)\n+                    goto error;\n+                prevs = s;\n+                flags = 0;\n+                break;\n+            case XML_OP_ATTR:\n+                flags |= XML_STREAM_STEP_ATTR;\n@@ -1677,7 +1637,86 @@\n-            }\n-            break;\n-\n-            } else {\n-            \/* Just skip this one. *\/\n-            continue;\n-            }\n+                s = xmlStreamCompAddStep(stream,\n+                    step.value, step.value2, XML_ATTRIBUTE_NODE, flags);\n+                flags = 0;\n+                if (s < 0)\n+                    goto error;\n+                break;\n+            case XML_OP_ELEM:\n+                if ((step.value == NULL) && (step.value2 == NULL)) {\n+                    \/*\n+                    * We have a \".\" or \"self::node()\" here.\n+                    * Eliminate redundant self::node() tests like in \"\/.\/.\"\n+                    * or \"\/\/.\/\"\n+                    * The only case we won't eliminate is \"\/\/.\", i.e. if\n+                    * self::node() is the last node test and we had\n+                    * continuation somewhere beforehand.\n+                    *\/\n+                    if ((comp->nbStep == i + 1) &&\n+                        (flags & XML_STREAM_STEP_DESC)) {\n+                        \/*\n+                        * Mark the special case where the expression resolves\n+                        * to any type of node.\n+                        *\/\n+                        if (comp->nbStep == i + 1) {\n+                            stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;\n+                        }\n+                        flags |= XML_STREAM_STEP_NODE;\n+                        s = xmlStreamCompAddStep(stream, NULL, NULL,\n+                            XML_STREAM_ANY_NODE, flags);\n+                        if (s < 0)\n+                            goto error;\n+                        flags = 0;\n+                        \/*\n+                        * If there was a previous step, mark it to be added to\n+                        * the result node-set; this is needed since only\n+                        * the last step will be marked as \"final\" and only\n+                        * \"final\" nodes are added to the resulting set.\n+                        *\/\n+                        if (prevs != -1) {\n+                            stream->steps[prevs].flags |= XML_STREAM_STEP_IN_SET;\n+                            prevs = -1;\n+                        }\n+                        break;\n+\n+                    } else {\n+                        \/* Just skip this one. *\/\n+                        continue;\n+                    }\n+                }\n+                \/* An element node. *\/\n+                s = xmlStreamCompAddStep(stream, step.value, step.value2,\n+                    XML_ELEMENT_NODE, flags);\n+                if (s < 0)\n+                    goto error;\n+                prevs = s;\n+                flags = 0;\n+                break;\n+            case XML_OP_CHILD:\n+                \/* An element node child. *\/\n+                s = xmlStreamCompAddStep(stream, step.value, step.value2,\n+                    XML_ELEMENT_NODE, flags);\n+                if (s < 0)\n+                    goto error;\n+                prevs = s;\n+                flags = 0;\n+                break;\n+            case XML_OP_ALL:\n+                s = xmlStreamCompAddStep(stream, NULL, NULL,\n+                    XML_ELEMENT_NODE, flags);\n+                if (s < 0)\n+                    goto error;\n+                prevs = s;\n+                flags = 0;\n+                break;\n+            case XML_OP_PARENT:\n+                break;\n+            case XML_OP_ANCESTOR:\n+                \/* Skip redundant continuations. *\/\n+                if (flags & XML_STREAM_STEP_DESC)\n+                    break;\n+                flags |= XML_STREAM_STEP_DESC;\n+                \/*\n+                * Mark the expression as having \"\/\/\".\n+                *\/\n+                if ((stream->flags & XML_STREAM_DESC) == 0)\n+                    stream->flags |= XML_STREAM_DESC;\n+                break;\n@@ -1685,32 +1724,2 @@\n-        \/* An element node. *\/\n-            s = xmlStreamCompAddStep(stream, step.value, step.value2,\n-            XML_ELEMENT_NODE, flags);\n-        if (s < 0)\n-            goto error;\n-        prevs = s;\n-        flags = 0;\n-        break;\n-        case XML_OP_CHILD:\n-        \/* An element node child. *\/\n-            s = xmlStreamCompAddStep(stream, step.value, step.value2,\n-            XML_ELEMENT_NODE, flags);\n-        if (s < 0)\n-            goto error;\n-        prevs = s;\n-        flags = 0;\n-        break;\n-        case XML_OP_ALL:\n-            s = xmlStreamCompAddStep(stream, NULL, NULL,\n-            XML_ELEMENT_NODE, flags);\n-        if (s < 0)\n-            goto error;\n-        prevs = s;\n-        flags = 0;\n-        break;\n-        case XML_OP_PARENT:\n-            break;\n-        case XML_OP_ANCESTOR:\n-        \/* Skip redundant continuations. *\/\n-        if (flags & XML_STREAM_STEP_DESC)\n-            break;\n-            flags |= XML_STREAM_STEP_DESC;\n+    }\n+    if ((! root) && (comp->flags & XML_PATTERN_NOTPATTERN) == 0) {\n@@ -1718,1 +1727,3 @@\n-        * Mark the expression as having \"\/\/\".\n+        * If this should behave like a real pattern, we will mark\n+        * the first step as having \"\/\/\", to be reentrant on every\n+        * tree level.\n@@ -1722,11 +1733,0 @@\n-        break;\n-    }\n-    }\n-    if ((! root) && (comp->flags & XML_PATTERN_NOTPATTERN) == 0) {\n-    \/*\n-    * If this should behave like a real pattern, we will mark\n-    * the first step as having \"\/\/\", to be reentrant on every\n-    * tree level.\n-    *\/\n-    if ((stream->flags & XML_STREAM_DESC) == 0)\n-        stream->flags |= XML_STREAM_DESC;\n@@ -1734,4 +1734,4 @@\n-    if (stream->nbStep > 0) {\n-        if ((stream->steps[0].flags & XML_STREAM_STEP_DESC) == 0)\n-        stream->steps[0].flags |= XML_STREAM_STEP_DESC;\n-    }\n+        if (stream->nbStep > 0) {\n+            if ((stream->steps[0].flags & XML_STREAM_STEP_DESC) == 0)\n+                stream->steps[0].flags |= XML_STREAM_STEP_DESC;\n+        }\n@@ -1740,1 +1740,1 @@\n-    goto error;\n+        goto error;\n@@ -1743,1 +1743,1 @@\n-    stream->steps[0].flags |= XML_STREAM_STEP_ROOT;\n+        stream->steps[0].flags |= XML_STREAM_STEP_ROOT;\n@@ -1768,3 +1768,3 @@\n-    ERROR(NULL, NULL, NULL,\n-        \"xmlNewStreamCtxt: malloc failed\\n\");\n-    return(NULL);\n+        ERROR(NULL, NULL, NULL,\n+                \"xmlNewStreamCtxt: malloc failed\\n\");\n+        return(NULL);\n@@ -1775,4 +1775,4 @@\n-    xmlFree(cur);\n-    ERROR(NULL, NULL, NULL,\n-          \"xmlNewStreamCtxt: malloc failed\\n\");\n-    return(NULL);\n+        xmlFree(cur);\n+        ERROR(NULL, NULL, NULL,\n+              \"xmlNewStreamCtxt: malloc failed\\n\");\n+        return(NULL);\n@@ -1801,1 +1801,1 @@\n-        xmlFree(stream->states);\n+            xmlFree(stream->states);\n@@ -1803,1 +1803,1 @@\n-    stream = next;\n+        stream = next;\n@@ -1821,4 +1821,4 @@\n-        comp->states[2 * i] = idx;\n-        comp->states[2 * i + 1] = level;\n-        return(i);\n-    }\n+            comp->states[2 * i] = idx;\n+            comp->states[2 * i + 1] = level;\n+            return(i);\n+        }\n@@ -1829,8 +1829,8 @@\n-    cur = (int *) xmlRealloc(comp->states,\n-                 comp->maxState * 4 * sizeof(int));\n-    if (cur == NULL) {\n-        ERROR(NULL, NULL, NULL,\n-          \"xmlNewStreamCtxt: malloc failed\\n\");\n-        return(-1);\n-    }\n-    comp->states = cur;\n+        cur = (int *) xmlRealloc(comp->states,\n+                                 comp->maxState * 4 * sizeof(int));\n+        if (cur == NULL) {\n+            ERROR(NULL, NULL, NULL,\n+                  \"xmlNewStreamCtxt: malloc failed\\n\");\n+            return(-1);\n+        }\n+        comp->states = cur;\n@@ -1862,2 +1862,2 @@\n-              const xmlChar *name, const xmlChar *ns,\n-              int nodeType) {\n+                      const xmlChar *name, const xmlChar *ns,\n+                      int nodeType) {\n@@ -1875,9 +1875,37 @@\n-    comp = stream->comp;\n-\n-    if ((nodeType == XML_ELEMENT_NODE) &&\n-        (name == NULL) && (ns == NULL)) {\n-        \/* We have a document node here (or a reset). *\/\n-        stream->nbState = 0;\n-        stream->level = 0;\n-        stream->blockLevel = -1;\n-        if (comp->flags & XML_STREAM_FROM_ROOT) {\n+        comp = stream->comp;\n+\n+        if ((nodeType == XML_ELEMENT_NODE) &&\n+            (name == NULL) && (ns == NULL)) {\n+            \/* We have a document node here (or a reset). *\/\n+            stream->nbState = 0;\n+            stream->level = 0;\n+            stream->blockLevel = -1;\n+            if (comp->flags & XML_STREAM_FROM_ROOT) {\n+                if (comp->nbStep == 0) {\n+                    \/* TODO: We have a \"\/.\" here? *\/\n+                    ret = 1;\n+                } else {\n+                    if ((comp->nbStep == 1) &&\n+                        (comp->steps[0].nodeType == XML_STREAM_ANY_NODE) &&\n+                        (comp->steps[0].flags & XML_STREAM_STEP_DESC))\n+                    {\n+                        \/*\n+                        * In the case of \"\/\/.\" the document node will match\n+                        * as well.\n+                        *\/\n+                        ret = 1;\n+                    } else if (comp->steps[0].flags & XML_STREAM_STEP_ROOT) {\n+                        \/* TODO: Do we need this ? *\/\n+                        tmp = xmlStreamCtxtAddState(stream, 0, 0);\n+                        if (tmp < 0)\n+                            err++;\n+                    }\n+                }\n+            }\n+            stream = stream->next;\n+            continue; \/* while *\/\n+        }\n+\n+        \/*\n+        * Fast check for \".\".\n+        *\/\n@@ -1885,7 +1913,0 @@\n-            \/* TODO: We have a \"\/.\" here? *\/\n-            ret = 1;\n-        } else {\n-            if ((comp->nbStep == 1) &&\n-            (comp->steps[0].nodeType == XML_STREAM_ANY_NODE) &&\n-            (comp->steps[0].flags & XML_STREAM_STEP_DESC))\n-            {\n@@ -1893,2 +1914,11 @@\n-            * In the case of \"\/\/.\" the document node will match\n-            * as well.\n+             * \/ and . are handled at the XPath node set creation\n+             * level by checking min depth\n+             *\/\n+            if (stream->flags & XML_PATTERN_XPATH) {\n+                stream = stream->next;\n+                continue; \/* while *\/\n+            }\n+            \/*\n+            * For non-pattern like evaluation like XML Schema IDCs\n+            * or traditional XPath expressions, this will match if\n+            * we are at the first level only, otherwise on every level.\n@@ -1896,6 +1926,4 @@\n-            ret = 1;\n-            } else if (comp->steps[0].flags & XML_STREAM_STEP_ROOT) {\n-            \/* TODO: Do we need this ? *\/\n-            tmp = xmlStreamCtxtAddState(stream, 0, 0);\n-            if (tmp < 0)\n-                err++;\n+            if ((nodeType != XML_ATTRIBUTE_NODE) &&\n+                (((stream->flags & XML_PATTERN_NOTPATTERN) == 0) ||\n+                (stream->level == 0))) {\n+                    ret = 1;\n@@ -1903,0 +1931,9 @@\n+            stream->level++;\n+            goto stream_next;\n+        }\n+        if (stream->blockLevel != -1) {\n+            \/*\n+            * Skip blocked expressions.\n+            *\/\n+            stream->level++;\n+            goto stream_next;\n@@ -1904,0 +1941,11 @@\n+\n+        if ((nodeType != XML_ELEMENT_NODE) &&\n+            (nodeType != XML_ATTRIBUTE_NODE) &&\n+            ((comp->flags & XML_STREAM_FINAL_IS_ANY_NODE) == 0)) {\n+            \/*\n+            * No need to process nodes of other types if we don't\n+            * resolve to those types.\n+            * TODO: Do we need to block the context here?\n+            *\/\n+            stream->level++;\n+            goto stream_next;\n@@ -1905,3 +1953,0 @@\n-        stream = stream->next;\n-        continue; \/* while *\/\n-    }\n@@ -1909,4 +1954,0 @@\n-    \/*\n-    * Fast check for \".\".\n-    *\/\n-    if (comp->nbStep == 0) {\n@@ -1914,2 +1955,1 @@\n-         * \/ and . are handled at the XPath node set creation\n-         * level by checking min depth\n+         * Check evolution of existing states\n@@ -1917,13 +1957,132 @@\n-        if (stream->flags & XML_PATTERN_XPATH) {\n-        stream = stream->next;\n-        continue; \/* while *\/\n-        }\n-        \/*\n-        * For non-pattern like evaluation like XML Schema IDCs\n-        * or traditional XPath expressions, this will match if\n-        * we are at the first level only, otherwise on every level.\n-        *\/\n-        if ((nodeType != XML_ATTRIBUTE_NODE) &&\n-        (((stream->flags & XML_PATTERN_NOTPATTERN) == 0) ||\n-        (stream->level == 0))) {\n-            ret = 1;\n+        i = 0;\n+        m = stream->nbState;\n+        while (i < m) {\n+            if ((comp->flags & XML_STREAM_DESC) == 0) {\n+                \/*\n+                * If there is no \"\/\/\", then only the last\n+                * added state is of interest.\n+                *\/\n+                stepNr = stream->states[2 * (stream->nbState -1)];\n+                \/*\n+                * TODO: Security check, should not happen, remove it.\n+                *\/\n+                if (stream->states[(2 * (stream->nbState -1)) + 1] <\n+                    stream->level) {\n+                    return (-1);\n+                }\n+                desc = 0;\n+                \/* loop-stopper *\/\n+                i = m;\n+            } else {\n+                \/*\n+                * If there are \"\/\/\", then we need to process every \"\/\/\"\n+                * occurring in the states, plus any other state for this\n+                * level.\n+                *\/\n+                stepNr = stream->states[2 * i];\n+\n+                \/* TODO: should not happen anymore: dead states *\/\n+                if (stepNr < 0)\n+                    goto next_state;\n+\n+                tmp = stream->states[(2 * i) + 1];\n+\n+                \/* skip new states just added *\/\n+                if (tmp > stream->level)\n+                    goto next_state;\n+\n+                \/* skip states at ancestor levels, except if \"\/\/\" *\/\n+                desc = comp->steps[stepNr].flags & XML_STREAM_STEP_DESC;\n+                if ((tmp < stream->level) && (!desc))\n+                    goto next_state;\n+            }\n+            \/*\n+            * Check for correct node-type.\n+            *\/\n+            step = comp->steps[stepNr];\n+            if (step.nodeType != nodeType) {\n+                if (step.nodeType == XML_ATTRIBUTE_NODE) {\n+                    \/*\n+                    * Block this expression for deeper evaluation.\n+                    *\/\n+                    if ((comp->flags & XML_STREAM_DESC) == 0)\n+                        stream->blockLevel = stream->level +1;\n+                    goto next_state;\n+                } else if (step.nodeType != XML_STREAM_ANY_NODE)\n+                    goto next_state;\n+            }\n+            \/*\n+            * Compare local\/namespace-name.\n+            *\/\n+            match = 0;\n+            if (step.nodeType == XML_STREAM_ANY_NODE) {\n+                match = 1;\n+            } else if (step.name == NULL) {\n+                if (step.ns == NULL) {\n+                    \/*\n+                    * This lets through all elements\/attributes.\n+                    *\/\n+                    match = 1;\n+                } else if (ns != NULL)\n+                    match = xmlStrEqual(step.ns, ns);\n+            } else if (((step.ns != NULL) == (ns != NULL)) &&\n+                (name != NULL) &&\n+                (step.name[0] == name[0]) &&\n+                xmlStrEqual(step.name, name) &&\n+                ((step.ns == ns) || xmlStrEqual(step.ns, ns)))\n+            {\n+                match = 1;\n+            }\n+#if 0\n+\/*\n+* TODO: Pointer comparison won't work, since not guaranteed that the given\n+*  values are in the same dict; especially if it's the namespace name,\n+*  normally coming from ns->href. We need a namespace dict mechanism !\n+*\/\n+            } else if (comp->dict) {\n+                if (step.name == NULL) {\n+                    if (step.ns == NULL)\n+                        match = 1;\n+                    else\n+                        match = (step.ns == ns);\n+                } else {\n+                    match = ((step.name == name) && (step.ns == ns));\n+                }\n+#endif \/* if 0 ------------------------------------------------------- *\/\n+            if (match) {\n+                final = step.flags & XML_STREAM_STEP_FINAL;\n+                if (desc) {\n+                    if (final) {\n+                        ret = 1;\n+                    } else {\n+                        \/* descending match create a new state *\/\n+                        xmlStreamCtxtAddState(stream, stepNr + 1,\n+                                              stream->level + 1);\n+                    }\n+                } else {\n+                    if (final) {\n+                        ret = 1;\n+                    } else {\n+                        xmlStreamCtxtAddState(stream, stepNr + 1,\n+                                              stream->level + 1);\n+                    }\n+                }\n+                if ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {\n+                    \/*\n+                    * Check if we have a special case like \"foo\/bar\/\/.\", where\n+                    * \"foo\" is selected as well.\n+                    *\/\n+                    ret = 1;\n+                }\n+            }\n+            if (((comp->flags & XML_STREAM_DESC) == 0) &&\n+                ((! match) || final))  {\n+                \/*\n+                * Mark this expression as blocked for any evaluation at\n+                * deeper levels. Note that this includes \"\/foo\"\n+                * expressions if the *pattern* behaviour is used.\n+                *\/\n+                stream->blockLevel = stream->level +1;\n+            }\n+next_state:\n+            i++;\n@@ -1931,10 +2090,0 @@\n-        stream->level++;\n-        goto stream_next;\n-    }\n-    if (stream->blockLevel != -1) {\n-        \/*\n-        * Skip blocked expressions.\n-        *\/\n-        stream->level++;\n-        goto stream_next;\n-    }\n@@ -1942,8 +2091,0 @@\n-    if ((nodeType != XML_ELEMENT_NODE) &&\n-        (nodeType != XML_ATTRIBUTE_NODE) &&\n-        ((comp->flags & XML_STREAM_FINAL_IS_ANY_NODE) == 0)) {\n-        \/*\n-        * No need to process nodes of other types if we don't\n-        * resolve to those types.\n-        * TODO: Do we need to block the context here?\n-        *\/\n@@ -1951,2 +2092,0 @@\n-        goto stream_next;\n-    }\n@@ -1954,23 +2093,0 @@\n-    \/*\n-     * Check evolution of existing states\n-     *\/\n-    i = 0;\n-    m = stream->nbState;\n-    while (i < m) {\n-        if ((comp->flags & XML_STREAM_DESC) == 0) {\n-        \/*\n-        * If there is no \"\/\/\", then only the last\n-        * added state is of interest.\n-        *\/\n-        stepNr = stream->states[2 * (stream->nbState -1)];\n-        \/*\n-        * TODO: Security check, should not happen, remove it.\n-        *\/\n-        if (stream->states[(2 * (stream->nbState -1)) + 1] <\n-            stream->level) {\n-            return (-1);\n-        }\n-        desc = 0;\n-        \/* loop-stopper *\/\n-        i = m;\n-        } else {\n@@ -1978,3 +2094,3 @@\n-        * If there are \"\/\/\", then we need to process every \"\/\/\"\n-        * occurring in the states, plus any other state for this\n-        * level.\n+        * Re\/enter the expression.\n+        * Don't reenter if it's an absolute expression like \"\/foo\",\n+        *   except \"\/\/foo\".\n@@ -1982,1 +2098,3 @@\n-        stepNr = stream->states[2 * i];\n+        step = comp->steps[0];\n+        if (step.flags & XML_STREAM_STEP_ROOT)\n+            goto stream_next;\n@@ -1984,3 +2102,6 @@\n-        \/* TODO: should not happen anymore: dead states *\/\n-        if (stepNr < 0)\n-            goto next_state;\n+        desc = step.flags & XML_STREAM_STEP_DESC;\n+        if (stream->flags & XML_PATTERN_NOTPATTERN) {\n+            \/*\n+            * Re\/enter the expression if it is a \"descendant\" one,\n+            * or if we are at the 1st level of evaluation.\n+            *\/\n@@ -1988,1 +2109,15 @@\n-        tmp = stream->states[(2 * i) + 1];\n+            if (stream->level == 1) {\n+                if (XML_STREAM_XS_IDC(stream)) {\n+                    \/*\n+                    * XS-IDC: The missing \"self::node()\" will always\n+                    * match the first given node.\n+                    *\/\n+                    goto stream_next;\n+                } else\n+                    goto compare;\n+            }\n+            \/*\n+            * A \"\/\/\" is always reentrant.\n+            *\/\n+            if (desc)\n+                goto compare;\n@@ -1990,3 +2125,7 @@\n-        \/* skip new states just added *\/\n-        if (tmp > stream->level)\n-            goto next_state;\n+            \/*\n+            * XS-IDC: Process the 2nd level, since the missing\n+            * \"self::node()\" is responsible for the 2nd level being\n+            * the real start level.\n+            *\/\n+            if ((stream->level == 2) && XML_STREAM_XS_IDC(stream))\n+                goto compare;\n@@ -1994,4 +2133,1 @@\n-        \/* skip states at ancestor levels, except if \"\/\/\" *\/\n-        desc = comp->steps[stepNr].flags & XML_STREAM_STEP_DESC;\n-        if ((tmp < stream->level) && (!desc))\n-            goto next_state;\n+            goto stream_next;\n@@ -1999,0 +2135,2 @@\n+\n+compare:\n@@ -2000,1 +2138,1 @@\n-        * Check for correct node-type.\n+        * Check expected node-type.\n@@ -2002,1 +2140,0 @@\n-        step = comp->steps[stepNr];\n@@ -2004,9 +2141,4 @@\n-        if (step.nodeType == XML_ATTRIBUTE_NODE) {\n-            \/*\n-            * Block this expression for deeper evaluation.\n-            *\/\n-            if ((comp->flags & XML_STREAM_DESC) == 0)\n-            stream->blockLevel = stream->level +1;\n-            goto next_state;\n-        } else if (step.nodeType != XML_STREAM_ANY_NODE)\n-            goto next_state;\n+            if (nodeType == XML_ATTRIBUTE_NODE)\n+                goto stream_next;\n+            else if (step.nodeType != XML_STREAM_ANY_NODE)\n+                goto stream_next;\n@@ -2019,6 +2151,0 @@\n-        match = 1;\n-        } else if (step.name == NULL) {\n-        if (step.ns == NULL) {\n-            \/*\n-            * This lets through all elements\/attributes.\n-            *\/\n@@ -2026,2 +2152,8 @@\n-        } else if (ns != NULL)\n-            match = xmlStrEqual(step.ns, ns);\n+        } else if (step.name == NULL) {\n+            if (step.ns == NULL) {\n+                \/*\n+                * This lets through all elements\/attributes.\n+                *\/\n+                match = 1;\n+            } else if (ns != NULL)\n+                match = xmlStrEqual(step.ns, ns);\n@@ -2029,4 +2161,4 @@\n-        (name != NULL) &&\n-        (step.name[0] == name[0]) &&\n-        xmlStrEqual(step.name, name) &&\n-        ((step.ns == ns) || xmlStrEqual(step.ns, ns)))\n+            (name != NULL) &&\n+            (step.name[0] == name[0]) &&\n+            xmlStrEqual(step.name, name) &&\n+            ((step.ns == ns) || xmlStrEqual(step.ns, ns)))\n@@ -2034,11 +2166,0 @@\n-        match = 1;\n-        }\n-#if 0\n-\/*\n-* TODO: Pointer comparison won't work, since not guaranteed that the given\n-*  values are in the same dict; especially if it's the namespace name,\n-*  normally coming from ns->href. We need a namespace dict mechanism !\n-*\/\n-        } else if (comp->dict) {\n-        if (step.name == NULL) {\n-            if (step.ns == NULL)\n@@ -2046,4 +2167,0 @@\n-            else\n-            match = (step.ns == ns);\n-        } else {\n-            match = ((step.name == name) && (step.ns == ns));\n@@ -2051,2 +2168,0 @@\n-#endif \/* if 0 ------------------------------------------------------- *\/\n-        if (match) {\n@@ -2054,14 +2169,11 @@\n-        if (desc) {\n-            if (final) {\n-            ret = 1;\n-            } else {\n-            \/* descending match create a new state *\/\n-            xmlStreamCtxtAddState(stream, stepNr + 1,\n-                                  stream->level + 1);\n-            }\n-        } else {\n-            if (final) {\n-            ret = 1;\n-            } else {\n-            xmlStreamCtxtAddState(stream, stepNr + 1,\n-                                  stream->level + 1);\n+        if (match) {\n+            if (final)\n+                ret = 1;\n+            else\n+                xmlStreamCtxtAddState(stream, 1, stream->level);\n+            if ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {\n+                \/*\n+                * Check if we have a special case like \"foo\/\/.\", where\n+                * \"foo\" is selected as well.\n+                *\/\n+                ret = 1;\n@@ -2070,8 +2182,0 @@\n-        if ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {\n-            \/*\n-            * Check if we have a special case like \"foo\/bar\/\/.\", where\n-            * \"foo\" is selected as well.\n-            *\/\n-            ret = 1;\n-        }\n-        }\n@@ -2079,32 +2183,1 @@\n-        ((! match) || final))  {\n-        \/*\n-        * Mark this expression as blocked for any evaluation at\n-        * deeper levels. Note that this includes \"\/foo\"\n-        * expressions if the *pattern* behaviour is used.\n-        *\/\n-        stream->blockLevel = stream->level +1;\n-        }\n-next_state:\n-        i++;\n-    }\n-\n-    stream->level++;\n-\n-    \/*\n-    * Re\/enter the expression.\n-    * Don't reenter if it's an absolute expression like \"\/foo\",\n-    *   except \"\/\/foo\".\n-    *\/\n-    step = comp->steps[0];\n-    if (step.flags & XML_STREAM_STEP_ROOT)\n-        goto stream_next;\n-\n-    desc = step.flags & XML_STREAM_STEP_DESC;\n-    if (stream->flags & XML_PATTERN_NOTPATTERN) {\n-        \/*\n-        * Re\/enter the expression if it is a \"descendant\" one,\n-        * or if we are at the 1st level of evaluation.\n-        *\/\n-\n-        if (stream->level == 1) {\n-        if (XML_STREAM_XS_IDC(stream)) {\n+            ((! match) || final))  {\n@@ -2112,2 +2185,2 @@\n-            * XS-IDC: The missing \"self::node()\" will always\n-            * match the first given node.\n+            * Mark this expression as blocked for any evaluation at\n+            * deeper levels.\n@@ -2115,3 +2188,1 @@\n-            goto stream_next;\n-        } else\n-            goto compare;\n+            stream->blockLevel = stream->level;\n@@ -2119,71 +2190,0 @@\n-        \/*\n-        * A \"\/\/\" is always reentrant.\n-        *\/\n-        if (desc)\n-        goto compare;\n-\n-        \/*\n-        * XS-IDC: Process the 2nd level, since the missing\n-        * \"self::node()\" is responsible for the 2nd level being\n-        * the real start level.\n-        *\/\n-        if ((stream->level == 2) && XML_STREAM_XS_IDC(stream))\n-        goto compare;\n-\n-        goto stream_next;\n-    }\n-\n-compare:\n-    \/*\n-    * Check expected node-type.\n-    *\/\n-    if (step.nodeType != nodeType) {\n-        if (nodeType == XML_ATTRIBUTE_NODE)\n-        goto stream_next;\n-        else if (step.nodeType != XML_STREAM_ANY_NODE)\n-        goto stream_next;\n-    }\n-    \/*\n-    * Compare local\/namespace-name.\n-    *\/\n-    match = 0;\n-    if (step.nodeType == XML_STREAM_ANY_NODE) {\n-        match = 1;\n-    } else if (step.name == NULL) {\n-        if (step.ns == NULL) {\n-        \/*\n-        * This lets through all elements\/attributes.\n-        *\/\n-        match = 1;\n-        } else if (ns != NULL)\n-        match = xmlStrEqual(step.ns, ns);\n-    } else if (((step.ns != NULL) == (ns != NULL)) &&\n-        (name != NULL) &&\n-        (step.name[0] == name[0]) &&\n-        xmlStrEqual(step.name, name) &&\n-        ((step.ns == ns) || xmlStrEqual(step.ns, ns)))\n-    {\n-        match = 1;\n-    }\n-    final = step.flags & XML_STREAM_STEP_FINAL;\n-    if (match) {\n-        if (final)\n-        ret = 1;\n-        else\n-        xmlStreamCtxtAddState(stream, 1, stream->level);\n-        if ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {\n-        \/*\n-        * Check if we have a special case like \"foo\/\/.\", where\n-        * \"foo\" is selected as well.\n-        *\/\n-        ret = 1;\n-        }\n-    }\n-    if (((comp->flags & XML_STREAM_DESC) == 0) &&\n-        ((! match) || final))  {\n-        \/*\n-        * Mark this expression as blocked for any evaluation at\n-        * deeper levels.\n-        *\/\n-        stream->blockLevel = stream->level;\n-    }\n@@ -2246,2 +2246,2 @@\n-          const xmlChar *name, const xmlChar *ns,\n-          int nodeType)\n+                  const xmlChar *name, const xmlChar *ns,\n+                  int nodeType)\n@@ -2250,1 +2250,1 @@\n-    nodeType));\n+        nodeType));\n@@ -2271,1 +2271,1 @@\n-          const xmlChar *name, const xmlChar *ns) {\n+                  const xmlChar *name, const xmlChar *ns) {\n@@ -2290,5 +2290,5 @@\n-    \/*\n-    * Reset block-level.\n-    *\/\n-    if (stream->blockLevel == stream->level)\n-        stream->blockLevel = -1;\n+        \/*\n+        * Reset block-level.\n+        *\/\n+        if (stream->blockLevel == stream->level)\n+            stream->blockLevel = -1;\n@@ -2296,19 +2296,19 @@\n-    \/*\n-     *  stream->level can be zero when XML_FINAL_IS_ANY_NODE is set\n-     *  (see the thread at\n-     *  http:\/\/mail.gnome.org\/archives\/xslt\/2008-July\/msg00027.html)\n-     *\/\n-    if (stream->level)\n-        stream->level--;\n-    \/*\n-     * Check evolution of existing states\n-     *\/\n-    for (i = stream->nbState -1; i >= 0; i--) {\n-        \/* discard obsoleted states *\/\n-        lev = stream->states[(2 * i) + 1];\n-        if (lev > stream->level)\n-        stream->nbState--;\n-        if (lev <= stream->level)\n-        break;\n-    }\n-    stream = stream->next;\n+        \/*\n+         *  stream->level can be zero when XML_FINAL_IS_ANY_NODE is set\n+         *  (see the thread at\n+         *  http:\/\/mail.gnome.org\/archives\/xslt\/2008-July\/msg00027.html)\n+         *\/\n+        if (stream->level)\n+            stream->level--;\n+        \/*\n+         * Check evolution of existing states\n+         *\/\n+        for (i = stream->nbState -1; i >= 0; i--) {\n+            \/* discard obsoleted states *\/\n+            lev = stream->states[(2 * i) + 1];\n+            if (lev > stream->level)\n+                stream->nbState--;\n+            if (lev <= stream->level)\n+                break;\n+        }\n+        stream = stream->next;\n@@ -2335,1 +2335,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2337,3 +2337,3 @@\n-    if (streamCtxt->comp->flags & XML_STREAM_FINAL_IS_ANY_NODE)\n-        return(1);\n-    streamCtxt = streamCtxt->next;\n+        if (streamCtxt->comp->flags & XML_STREAM_FINAL_IS_ANY_NODE)\n+            return(1);\n+        streamCtxt = streamCtxt->next;\n@@ -2345,3 +2345,3 @@\n- *                                  *\n- *          The public interfaces               *\n- *                                  *\n+ *                                                                      *\n+ *                      The public interfaces                           *\n+ *                                                                      *\n@@ -2377,2 +2377,2 @@\n-    tmp = NULL;\n-    while ((*or != 0) && (*or != '|')) or++;\n+        tmp = NULL;\n+        while ((*or != 0) && (*or != '|')) or++;\n@@ -2380,5 +2380,7 @@\n-        ctxt = xmlNewPatParserContext(start, dict, namespaces);\n-    else {\n-        tmp = xmlStrndup(start, or - start);\n-        if (tmp != NULL) {\n-        ctxt = xmlNewPatParserContext(tmp, dict, namespaces);\n+            ctxt = xmlNewPatParserContext(start, dict, namespaces);\n+        else {\n+            tmp = xmlStrndup(start, or - start);\n+            if (tmp != NULL) {\n+                ctxt = xmlNewPatParserContext(tmp, dict, namespaces);\n+            }\n+            or++;\n@@ -2386,20 +2388,18 @@\n-        or++;\n-    }\n-    if (ctxt == NULL) goto error;\n-    cur = xmlNewPattern();\n-    if (cur == NULL) goto error;\n-    \/*\n-    * Assign string dict.\n-    *\/\n-    if (dict) {\n-        cur->dict = dict;\n-        xmlDictReference(dict);\n-    }\n-    if (ret == NULL)\n-        ret = cur;\n-    else {\n-        cur->next = ret->next;\n-        ret->next = cur;\n-    }\n-    cur->flags = flags;\n-    ctxt->comp = cur;\n+        if (ctxt == NULL) goto error;\n+        cur = xmlNewPattern();\n+        if (cur == NULL) goto error;\n+        \/*\n+        * Assign string dict.\n+        *\/\n+        if (dict) {\n+            cur->dict = dict;\n+            xmlDictReference(dict);\n+        }\n+        if (ret == NULL)\n+            ret = cur;\n+        else {\n+            cur->next = ret->next;\n+            ret->next = cur;\n+        }\n+        cur->flags = flags;\n+        ctxt->comp = cur;\n@@ -2407,8 +2407,8 @@\n-    if (XML_STREAM_XS_IDC(cur))\n-        xmlCompileIDCXPathPath(ctxt);\n-    else\n-        xmlCompilePathPattern(ctxt);\n-    if (ctxt->error != 0)\n-        goto error;\n-    xmlFreePatParserContext(ctxt);\n-    ctxt = NULL;\n+        if (XML_STREAM_XS_IDC(cur))\n+            xmlCompileIDCXPathPath(ctxt);\n+        else\n+            xmlCompilePathPattern(ctxt);\n+        if (ctxt->error != 0)\n+            goto error;\n+        xmlFreePatParserContext(ctxt);\n+        ctxt = NULL;\n@@ -2418,8 +2418,9 @@\n-        if (type == 0) {\n-            type = cur->flags & (PAT_FROM_ROOT | PAT_FROM_CUR);\n-        } else if (type == PAT_FROM_ROOT) {\n-            if (cur->flags & PAT_FROM_CUR)\n-            streamable = 0;\n-        } else if (type == PAT_FROM_CUR) {\n-            if (cur->flags & PAT_FROM_ROOT)\n-            streamable = 0;\n+            if (type == 0) {\n+                type = cur->flags & (PAT_FROM_ROOT | PAT_FROM_CUR);\n+            } else if (type == PAT_FROM_ROOT) {\n+                if (cur->flags & PAT_FROM_CUR)\n+                    streamable = 0;\n+            } else if (type == PAT_FROM_CUR) {\n+                if (cur->flags & PAT_FROM_ROOT)\n+                    streamable = 0;\n+            }\n@@ -2427,10 +2428,9 @@\n-    }\n-    if (streamable)\n-        xmlStreamCompile(cur);\n-    if (xmlReversePattern(cur) < 0)\n-        goto error;\n-    if (tmp != NULL) {\n-        xmlFree(tmp);\n-        tmp = NULL;\n-    }\n-    start = or;\n+        if (streamable)\n+            xmlStreamCompile(cur);\n+        if (xmlReversePattern(cur) < 0)\n+            goto error;\n+        if (tmp != NULL) {\n+            xmlFree(tmp);\n+            tmp = NULL;\n+        }\n+        start = or;\n@@ -2440,4 +2440,6 @@\n-    while (cur != NULL) {\n-        if (cur->stream != NULL) {\n-        xmlFreeStreamComp(cur->stream);\n-        cur->stream = NULL;\n+        while (cur != NULL) {\n+            if (cur->stream != NULL) {\n+                xmlFreeStreamComp(cur->stream);\n+                cur->stream = NULL;\n+            }\n+            cur = cur->next;\n@@ -2445,2 +2447,0 @@\n-        cur = cur->next;\n-    }\n@@ -2476,3 +2476,3 @@\n-    if (ret != 0)\n-        return(ret);\n-    comp = comp->next;\n+        if (ret != 0)\n+            return(ret);\n+        comp = comp->next;\n@@ -2502,12 +2502,12 @@\n-        goto failed;\n-    cur = xmlNewStreamCtxt(comp->stream);\n-    if (cur == NULL)\n-        goto failed;\n-    if (ret == NULL)\n-        ret = cur;\n-    else {\n-        cur->next = ret->next;\n-        ret->next = cur;\n-    }\n-    cur->flags = comp->flags;\n-    comp = comp->next;\n+            goto failed;\n+        cur = xmlNewStreamCtxt(comp->stream);\n+        if (cur == NULL)\n+            goto failed;\n+        if (ret == NULL)\n+            ret = cur;\n+        else {\n+            cur->next = ret->next;\n+            ret->next = cur;\n+        }\n+        cur->flags = comp->flags;\n+        comp = comp->next;\n@@ -2536,2 +2536,2 @@\n-        return(0);\n-    comp = comp->next;\n+            return(0);\n+        comp = comp->next;\n@@ -2558,7 +2558,7 @@\n-        return(-1);\n-    for (i = 0;i < comp->stream->nbStep;i++)\n-        if (comp->stream->steps[i].flags & XML_STREAM_STEP_DESC)\n-            return(-2);\n-    if (comp->stream->nbStep > ret)\n-        ret = comp->stream->nbStep;\n-    comp = comp->next;\n+            return(-1);\n+        for (i = 0;i < comp->stream->nbStep;i++)\n+            if (comp->stream->steps[i].flags & XML_STREAM_STEP_DESC)\n+                return(-2);\n+        if (comp->stream->nbStep > ret)\n+            ret = comp->stream->nbStep;\n+        comp = comp->next;\n@@ -2586,6 +2586,6 @@\n-        return(-1);\n-    if (comp->stream->nbStep < ret)\n-        ret = comp->stream->nbStep;\n-    if (ret == 0)\n-        return(0);\n-    comp = comp->next;\n+            return(-1);\n+        if (comp->stream->nbStep < ret)\n+            ret = comp->stream->nbStep;\n+        if (ret == 0)\n+            return(0);\n+        comp = comp->next;\n@@ -2610,4 +2610,4 @@\n-        return(-1);\n-    if (comp->flags & PAT_FROM_ROOT)\n-        return(1);\n-    comp = comp->next;\n+            return(-1);\n+        if (comp->flags & PAT_FROM_ROOT)\n+            return(1);\n+        comp = comp->next;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/pattern.c","additions":1263,"deletions":1263,"binary":false,"changes":2526,"status":"modified"},{"patch":"@@ -406,1 +406,1 @@\n-    tok->count--;\n+        tok->count--;\n@@ -512,1 +512,1 @@\n-    LeaveCriticalSection(global_init_lock);\n+        LeaveCriticalSection(global_init_lock);\n@@ -539,3 +539,3 @@\n- *                                  *\n- *          Per thread global state handling        *\n- *                                  *\n+ *                                                                      *\n+ *                      Per thread global state handling                *\n+ *                                                                      *\n@@ -582,2 +582,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"xmlGetGlobalState: out of memory\\n\");\n+        xmlGenericError(xmlGenericErrorContext,\n+                        \"xmlGetGlobalState: out of memory\\n\");\n@@ -667,2 +667,2 @@\n-    if (tsd == NULL)\n-        return(NULL);\n+        if (tsd == NULL)\n+            return(NULL);\n@@ -696,1 +696,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -699,1 +699,1 @@\n-    if (p == NULL) {\n+        if (p == NULL) {\n@@ -703,2 +703,2 @@\n-        return(NULL);\n-    }\n+            return(NULL);\n+        }\n@@ -735,2 +735,2 @@\n-    if (tsd == NULL)\n-        return (NULL);\n+        if (tsd == NULL)\n+            return (NULL);\n@@ -749,3 +749,3 @@\n- *                                  *\n- *          Library wide thread interfaces          *\n- *                                  *\n+ *                                                                      *\n+ *                      Library wide thread interfaces                  *\n+ *                                                                      *\n@@ -965,1 +965,1 @@\n-        __xmlInitializeDict();\n+            __xmlInitializeDict();\n@@ -979,1 +979,1 @@\n-    __xmlInitializeDict();\n+        __xmlInitializeDict();\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/threads.c","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -56,3 +56,3 @@\n- *                                  *\n- *      Forward declarations                    *\n- *                                  *\n+ *                                                                      *\n+ *              Forward declarations                                    *\n+ *                                                                      *\n@@ -67,3 +67,3 @@\n- *                                  *\n- *      Tree memory error handler               *\n- *                                  *\n+ *                                                                      *\n+ *              Tree memory error handler                               *\n+ *                                                                      *\n@@ -97,13 +97,13 @@\n-        msg = \"invalid hexadecimal character value\\n\";\n-        break;\n-    case XML_TREE_INVALID_DEC:\n-        msg = \"invalid decimal character value\\n\";\n-        break;\n-    case XML_TREE_UNTERMINATED_ENTITY:\n-        msg = \"unterminated entity reference %15s\\n\";\n-        break;\n-    case XML_TREE_NOT_UTF8:\n-        msg = \"string is not in UTF-8\\n\";\n-        break;\n-    default:\n-        msg = \"unexpected error number\\n\";\n+            msg = \"invalid hexadecimal character value\\n\";\n+            break;\n+        case XML_TREE_INVALID_DEC:\n+            msg = \"invalid decimal character value\\n\";\n+            break;\n+        case XML_TREE_UNTERMINATED_ENTITY:\n+            msg = \"unterminated entity reference %15s\\n\";\n+            break;\n+        case XML_TREE_NOT_UTF8:\n+            msg = \"string is not in UTF-8\\n\";\n+            break;\n+        default:\n+            msg = \"unexpected error number\\n\";\n@@ -115,3 +115,3 @@\n- *                                  *\n- *      A few static variables and macros           *\n- *                                  *\n+ *                                                                      *\n+ *              A few static variables and macros                       *\n+ *                                                                      *\n@@ -130,11 +130,11 @@\n-#define UPDATE_LAST_CHILD_AND_PARENT(n) if ((n) != NULL) {      \\\n-    xmlNodePtr ulccur = (n)->children;                  \\\n-    if (ulccur == NULL) {                       \\\n-        (n)->last = NULL;                       \\\n-    } else {                                \\\n-        while (ulccur->next != NULL) {                  \\\n-        ulccur->parent = (n);                   \\\n-        ulccur = ulccur->next;                  \\\n-    }                               \\\n-    ulccur->parent = (n);                       \\\n-    (n)->last = ulccur;                     \\\n+#define UPDATE_LAST_CHILD_AND_PARENT(n) if ((n) != NULL) {              \\\n+    xmlNodePtr ulccur = (n)->children;                                  \\\n+    if (ulccur == NULL) {                                               \\\n+        (n)->last = NULL;                                               \\\n+    } else {                                                            \\\n+        while (ulccur->next != NULL) {                                  \\\n+                ulccur->parent = (n);                                   \\\n+                ulccur = ulccur->next;                                  \\\n+        }                                                               \\\n+        ulccur->parent = (n);                                           \\\n+        (n)->last = ulccur;                                             \\\n@@ -150,4 +150,4 @@\n- *                                  *\n- *      Functions to move to entities.c once the        *\n- *      API freeze is smoothen and they can be made public. *\n- *                                  *\n+ *                                                                      *\n+ *              Functions to move to entities.c once the                *\n+ *              API freeze is smoothen and they can be made public.     *\n+ *                                                                      *\n@@ -173,3 +173,3 @@\n-    table = (xmlEntitiesTablePtr) dtd->entities;\n-    return((xmlEntityPtr) xmlHashLookup(table, name));\n-    \/* return(xmlGetEntityFromTable(table, name)); *\/\n+        table = (xmlEntitiesTablePtr) dtd->entities;\n+        return((xmlEntityPtr) xmlHashLookup(table, name));\n+        \/* return(xmlGetEntityFromTable(table, name)); *\/\n@@ -194,3 +194,3 @@\n-    table = (xmlEntitiesTablePtr) dtd->pentities;\n-    return((xmlEntityPtr) xmlHashLookup(table, name));\n-    \/* return(xmlGetEntityFromTable(table, name)); *\/\n+        table = (xmlEntitiesTablePtr) dtd->pentities;\n+        return((xmlEntityPtr) xmlHashLookup(table, name));\n+        \/* return(xmlGetEntityFromTable(table, name)); *\/\n@@ -203,3 +203,3 @@\n- *                                  *\n- *          QName handling helper               *\n- *                                  *\n+ *                                                                      *\n+ *                      QName handling helper                           *\n+ *                                                                      *\n@@ -224,1 +224,1 @@\n-          xmlChar *memory, int len) {\n+              xmlChar *memory, int len) {\n@@ -235,5 +235,5 @@\n-    ret = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);\n-    if (ret == NULL) {\n-        xmlTreeErrMemory(\"building QName\");\n-        return(NULL);\n-    }\n+        ret = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);\n+        if (ret == NULL) {\n+            xmlTreeErrMemory(\"building QName\");\n+            return(NULL);\n+        }\n@@ -241,1 +241,1 @@\n-    ret = memory;\n+        ret = memory;\n@@ -280,1 +280,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -285,1 +285,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -292,1 +292,1 @@\n-    len++;\n+        len++;\n@@ -295,1 +295,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -299,2 +299,2 @@\n-    xmlTreeErrMemory(\"QName split\");\n-    return(NULL);\n+        xmlTreeErrMemory(\"QName split\");\n+        return(NULL);\n@@ -304,6 +304,6 @@\n-    xmlTreeErrMemory(\"QName split\");\n-    if (*prefix != NULL) {\n-        xmlFree(*prefix);\n-        *prefix = NULL;\n-    }\n-    return(NULL);\n+        xmlTreeErrMemory(\"QName split\");\n+        if (*prefix != NULL) {\n+            xmlFree(*prefix);\n+            *prefix = NULL;\n+        }\n+        return(NULL);\n@@ -336,1 +336,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -343,1 +343,1 @@\n-    l++;\n+        l++;\n@@ -346,1 +346,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -354,3 +354,3 @@\n- *                                  *\n- *      Check Name, NCName and QName strings            *\n- *                                  *\n+ *                                                                      *\n+ *              Check Name, NCName and QName strings                    *\n+ *                                                                      *\n@@ -384,1 +384,1 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n+        while (IS_BLANK_CH(*cur)) cur++;\n@@ -386,2 +386,2 @@\n-    (*cur == '_'))\n-    cur++;\n+        (*cur == '_'))\n+        cur++;\n@@ -389,1 +389,1 @@\n-    goto try_complex;\n+        goto try_complex;\n@@ -391,4 +391,4 @@\n-       ((*cur >= 'A') && (*cur <= 'Z')) ||\n-       ((*cur >= '0') && (*cur <= '9')) ||\n-       (*cur == '_') || (*cur == '-') || (*cur == '.'))\n-    cur++;\n+           ((*cur >= 'A') && (*cur <= 'Z')) ||\n+           ((*cur >= '0') && (*cur <= '9')) ||\n+           (*cur == '_') || (*cur == '-') || (*cur == '.'))\n+        cur++;\n@@ -396,1 +396,1 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n+        while (IS_BLANK_CH(*cur)) cur++;\n@@ -398,1 +398,1 @@\n-    return(0);\n+        return(0);\n@@ -407,4 +407,4 @@\n-    while (IS_BLANK(c)) {\n-        cur += l;\n-        c = CUR_SCHAR(cur, l);\n-    }\n+        while (IS_BLANK(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -413,1 +413,1 @@\n-    return(1);\n+        return(1);\n@@ -417,7 +417,2 @@\n-       (c == '-') || (c == '_') || IS_COMBINING(c) ||\n-       IS_EXTENDER(c)) {\n-    cur += l;\n-    c = CUR_SCHAR(cur, l);\n-    }\n-    if (space) {\n-    while (IS_BLANK(c)) {\n+           (c == '-') || (c == '_') || IS_COMBINING(c) ||\n+           IS_EXTENDER(c)) {\n@@ -427,0 +422,5 @@\n+    if (space) {\n+        while (IS_BLANK(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -429,1 +429,1 @@\n-    return(1);\n+        return(1);\n@@ -457,1 +457,1 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n+        while (IS_BLANK_CH(*cur)) cur++;\n@@ -459,13 +459,0 @@\n-    (*cur == '_'))\n-    cur++;\n-    else\n-    goto try_complex;\n-    while (((*cur >= 'a') && (*cur <= 'z')) ||\n-       ((*cur >= 'A') && (*cur <= 'Z')) ||\n-       ((*cur >= '0') && (*cur <= '9')) ||\n-       (*cur == '_') || (*cur == '-') || (*cur == '.'))\n-    cur++;\n-    if (*cur == ':') {\n-    cur++;\n-    if (((*cur >= 'a') && (*cur <= 'z')) ||\n-        ((*cur >= 'A') && (*cur <= 'Z')) ||\n@@ -481,0 +468,13 @@\n+    if (*cur == ':') {\n+        cur++;\n+        if (((*cur >= 'a') && (*cur <= 'z')) ||\n+            ((*cur >= 'A') && (*cur <= 'Z')) ||\n+            (*cur == '_'))\n+            cur++;\n+        else\n+            goto try_complex;\n+        while (((*cur >= 'a') && (*cur <= 'z')) ||\n+               ((*cur >= 'A') && (*cur <= 'Z')) ||\n+               ((*cur >= '0') && (*cur <= '9')) ||\n+               (*cur == '_') || (*cur == '-') || (*cur == '.'))\n+            cur++;\n@@ -483,1 +483,1 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n+        while (IS_BLANK_CH(*cur)) cur++;\n@@ -485,1 +485,1 @@\n-    return(0);\n+        return(0);\n@@ -494,14 +494,4 @@\n-    while (IS_BLANK(c)) {\n-        cur += l;\n-        c = CUR_SCHAR(cur, l);\n-    }\n-    }\n-    if ((!IS_LETTER(c)) && (c != '_'))\n-    return(1);\n-    cur += l;\n-    c = CUR_SCHAR(cur, l);\n-    while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||\n-       (c == '-') || (c == '_') || IS_COMBINING(c) ||\n-       IS_EXTENDER(c)) {\n-    cur += l;\n-    c = CUR_SCHAR(cur, l);\n+        while (IS_BLANK(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -509,3 +499,0 @@\n-    if (c == ':') {\n-    cur += l;\n-    c = CUR_SCHAR(cur, l);\n@@ -522,3 +509,5 @@\n-    }\n-    if (space) {\n-    while (IS_BLANK(c)) {\n+    if (c == ':') {\n+        cur += l;\n+        c = CUR_SCHAR(cur, l);\n+        if ((!IS_LETTER(c)) && (c != '_'))\n+            return(1);\n@@ -527,0 +516,6 @@\n+        while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||\n+               (c == '-') || (c == '_') || IS_COMBINING(c) ||\n+               IS_EXTENDER(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -528,0 +523,5 @@\n+    if (space) {\n+        while (IS_BLANK(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -530,1 +530,1 @@\n-    return(1);\n+        return(1);\n@@ -555,1 +555,1 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n+        while (IS_BLANK_CH(*cur)) cur++;\n@@ -557,2 +557,2 @@\n-    (*cur == '_') || (*cur == ':'))\n-    cur++;\n+        (*cur == '_') || (*cur == ':'))\n+        cur++;\n@@ -560,1 +560,1 @@\n-    goto try_complex;\n+        goto try_complex;\n@@ -562,4 +562,4 @@\n-       ((*cur >= 'A') && (*cur <= 'Z')) ||\n-       ((*cur >= '0') && (*cur <= '9')) ||\n-       (*cur == '_') || (*cur == '-') || (*cur == '.') || (*cur == ':'))\n-    cur++;\n+           ((*cur >= 'A') && (*cur <= 'Z')) ||\n+           ((*cur >= '0') && (*cur <= '9')) ||\n+           (*cur == '_') || (*cur == '-') || (*cur == '.') || (*cur == ':'))\n+        cur++;\n@@ -567,1 +567,1 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n+        while (IS_BLANK_CH(*cur)) cur++;\n@@ -569,1 +569,1 @@\n-    return(0);\n+        return(0);\n@@ -578,4 +578,4 @@\n-    while (IS_BLANK(c)) {\n-        cur += l;\n-        c = CUR_SCHAR(cur, l);\n-    }\n+        while (IS_BLANK(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -584,1 +584,1 @@\n-    return(1);\n+        return(1);\n@@ -588,6 +588,1 @@\n-       (c == '-') || (c == '_') || IS_COMBINING(c) || IS_EXTENDER(c)) {\n-    cur += l;\n-    c = CUR_SCHAR(cur, l);\n-    }\n-    if (space) {\n-    while (IS_BLANK(c)) {\n+           (c == '-') || (c == '_') || IS_COMBINING(c) || IS_EXTENDER(c)) {\n@@ -597,0 +592,5 @@\n+    if (space) {\n+        while (IS_BLANK(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -599,1 +599,1 @@\n-    return(1);\n+        return(1);\n@@ -624,1 +624,1 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n+        while (IS_BLANK_CH(*cur)) cur++;\n@@ -629,1 +629,1 @@\n-    cur++;\n+        cur++;\n@@ -631,1 +631,1 @@\n-    goto try_complex;\n+        goto try_complex;\n@@ -633,4 +633,4 @@\n-       ((*cur >= 'A') && (*cur <= 'Z')) ||\n-       ((*cur >= '0') && (*cur <= '9')) ||\n-       (*cur == '_') || (*cur == '-') || (*cur == '.') || (*cur == ':'))\n-    cur++;\n+           ((*cur >= 'A') && (*cur <= 'Z')) ||\n+           ((*cur >= '0') && (*cur <= '9')) ||\n+           (*cur == '_') || (*cur == '-') || (*cur == '.') || (*cur == ':'))\n+        cur++;\n@@ -638,1 +638,1 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n+        while (IS_BLANK_CH(*cur)) cur++;\n@@ -640,1 +640,1 @@\n-    return(0);\n+        return(0);\n@@ -649,4 +649,4 @@\n-    while (IS_BLANK(c)) {\n-        cur += l;\n-        c = CUR_SCHAR(cur, l);\n-    }\n+        while (IS_BLANK(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -656,1 +656,1 @@\n-    return(1);\n+        return(1);\n@@ -660,6 +660,1 @@\n-       (c == '-') || (c == '_') || IS_COMBINING(c) || IS_EXTENDER(c)) {\n-    cur += l;\n-    c = CUR_SCHAR(cur, l);\n-    }\n-    if (space) {\n-    while (IS_BLANK(c)) {\n+           (c == '-') || (c == '_') || IS_COMBINING(c) || IS_EXTENDER(c)) {\n@@ -669,0 +664,5 @@\n+    if (space) {\n+        while (IS_BLANK(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -671,1 +671,1 @@\n-    return(1);\n+        return(1);\n@@ -677,3 +677,3 @@\n- *                                  *\n- *      Allocation and deallocation of basic structures     *\n- *                                  *\n+ *                                                                      *\n+ *              Allocation and deallocation of basic structures         *\n+ *                                                                      *\n@@ -696,1 +696,1 @@\n-    xmlBufferAllocScheme = scheme;\n+        xmlBufferAllocScheme = scheme;\n@@ -738,1 +738,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -759,2 +759,2 @@\n-    xmlTreeErrMemory(\"building namespace\");\n-    return(NULL);\n+        xmlTreeErrMemory(\"building namespace\");\n+        return(NULL);\n@@ -766,1 +766,1 @@\n-    cur->href = xmlStrdup(href);\n+        cur->href = xmlStrdup(href);\n@@ -768,1 +768,1 @@\n-    cur->prefix = xmlStrdup(prefix);\n+        cur->prefix = xmlStrdup(prefix);\n@@ -775,4 +775,4 @@\n-    if (node->nsDef == NULL) {\n-        node->nsDef = cur;\n-    } else {\n-        xmlNsPtr prev = node->nsDef;\n+        if (node->nsDef == NULL) {\n+            node->nsDef = cur;\n+        } else {\n+            xmlNsPtr prev = node->nsDef;\n@@ -780,12 +780,14 @@\n-        if (((prev->prefix == NULL) && (cur->prefix == NULL)) ||\n-        (xmlStrEqual(prev->prefix, cur->prefix))) {\n-        xmlFreeNs(cur);\n-        return(NULL);\n-        }\n-        while (prev->next != NULL) {\n-            prev = prev->next;\n-        if (((prev->prefix == NULL) && (cur->prefix == NULL)) ||\n-            (xmlStrEqual(prev->prefix, cur->prefix))) {\n-            xmlFreeNs(cur);\n-            return(NULL);\n-        }\n+            if (((prev->prefix == NULL) && (cur->prefix == NULL)) ||\n+                (xmlStrEqual(prev->prefix, cur->prefix))) {\n+                xmlFreeNs(cur);\n+                return(NULL);\n+            }\n+            while (prev->next != NULL) {\n+                prev = prev->next;\n+                if (((prev->prefix == NULL) && (cur->prefix == NULL)) ||\n+                    (xmlStrEqual(prev->prefix, cur->prefix))) {\n+                    xmlFreeNs(cur);\n+                    return(NULL);\n+                }\n+            }\n+            prev->next = cur;\n@@ -793,2 +795,0 @@\n-        prev->next = cur;\n-    }\n@@ -811,1 +811,1 @@\n-        \"xmlSetNs: node == NULL\\n\");\n+                \"xmlSetNs: node == NULL\\n\");\n@@ -813,1 +813,1 @@\n-    return;\n+        return;\n@@ -817,1 +817,1 @@\n-    node->ns = ns;\n+        node->ns = ns;\n@@ -831,1 +831,1 @@\n-        \"xmlFreeNs : ns == NULL\\n\");\n+                \"xmlFreeNs : ns == NULL\\n\");\n@@ -833,1 +833,1 @@\n-    return;\n+        return;\n@@ -852,1 +852,1 @@\n-        \"xmlFreeNsList : ns == NULL\\n\");\n+                \"xmlFreeNsList : ns == NULL\\n\");\n@@ -854,1 +854,1 @@\n-    return;\n+        return;\n@@ -859,1 +859,1 @@\n-    cur = next;\n+        cur = next;\n@@ -883,3 +883,3 @@\n-        \"xmlNewDtd(%s): document %s already have a DTD %s\\n\",\n-        \/* !!! *\/ (char *) name, doc->name,\n-        \/* !!! *\/ (char *)doc->extSubset->name);\n+                \"xmlNewDtd(%s): document %s already have a DTD %s\\n\",\n+            \/* !!! *\/ (char *) name, doc->name,\n+            \/* !!! *\/ (char *)doc->extSubset->name);\n@@ -887,1 +887,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -895,2 +895,2 @@\n-    xmlTreeErrMemory(\"building DTD\");\n-    return(NULL);\n+        xmlTreeErrMemory(\"building DTD\");\n+        return(NULL);\n@@ -902,1 +902,1 @@\n-    cur->name = xmlStrdup(name);\n+        cur->name = xmlStrdup(name);\n@@ -904,1 +904,1 @@\n-    cur->ExternalID = xmlStrdup(ExternalID);\n+        cur->ExternalID = xmlStrdup(ExternalID);\n@@ -906,1 +906,1 @@\n-    cur->SystemID = xmlStrdup(SystemID);\n+        cur->SystemID = xmlStrdup(SystemID);\n@@ -908,1 +908,1 @@\n-    doc->extSubset = cur;\n+        doc->extSubset = cur;\n@@ -912,1 +912,1 @@\n-    xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n+        xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -929,1 +929,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -932,3 +932,3 @@\n-    if (cur->type == XML_DTD_NODE)\n-        return((xmlDtdPtr) cur);\n-    cur = cur->next;\n+        if (cur->type == XML_DTD_NODE)\n+            return((xmlDtdPtr) cur);\n+        cur = cur->next;\n@@ -959,1 +959,1 @@\n-        doc->name);\n+            doc->name);\n@@ -961,1 +961,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -969,2 +969,2 @@\n-    xmlTreeErrMemory(\"building internal subset\");\n-    return(NULL);\n+        xmlTreeErrMemory(\"building internal subset\");\n+        return(NULL);\n@@ -976,6 +976,6 @@\n-    cur->name = xmlStrdup(name);\n-    if (cur->name == NULL) {\n-        xmlTreeErrMemory(\"building internal subset\");\n-        xmlFree(cur);\n-        return(NULL);\n-    }\n+        cur->name = xmlStrdup(name);\n+        if (cur->name == NULL) {\n+            xmlTreeErrMemory(\"building internal subset\");\n+            xmlFree(cur);\n+            return(NULL);\n+        }\n@@ -984,8 +984,8 @@\n-    cur->ExternalID = xmlStrdup(ExternalID);\n-    if (cur->ExternalID  == NULL) {\n-        xmlTreeErrMemory(\"building internal subset\");\n-        if (cur->name != NULL)\n-            xmlFree((char *)cur->name);\n-        xmlFree(cur);\n-        return(NULL);\n-    }\n+        cur->ExternalID = xmlStrdup(ExternalID);\n+        if (cur->ExternalID  == NULL) {\n+            xmlTreeErrMemory(\"building internal subset\");\n+            if (cur->name != NULL)\n+                xmlFree((char *)cur->name);\n+            xmlFree(cur);\n+            return(NULL);\n+        }\n@@ -994,10 +994,10 @@\n-    cur->SystemID = xmlStrdup(SystemID);\n-    if (cur->SystemID == NULL) {\n-        xmlTreeErrMemory(\"building internal subset\");\n-        if (cur->name != NULL)\n-            xmlFree((char *)cur->name);\n-        if (cur->ExternalID != NULL)\n-            xmlFree((char *)cur->ExternalID);\n-        xmlFree(cur);\n-        return(NULL);\n-    }\n+        cur->SystemID = xmlStrdup(SystemID);\n+        if (cur->SystemID == NULL) {\n+            xmlTreeErrMemory(\"building internal subset\");\n+            if (cur->name != NULL)\n+                xmlFree((char *)cur->name);\n+            if (cur->ExternalID != NULL)\n+                xmlFree((char *)cur->ExternalID);\n+            xmlFree(cur);\n+            return(NULL);\n+        }\n@@ -1006,24 +1006,5 @@\n-    doc->intSubset = cur;\n-    cur->parent = doc;\n-    cur->doc = doc;\n-    if (doc->children == NULL) {\n-        doc->children = (xmlNodePtr) cur;\n-        doc->last = (xmlNodePtr) cur;\n-    } else {\n-        if (doc->type == XML_HTML_DOCUMENT_NODE) {\n-        xmlNodePtr prev;\n-\n-        prev = doc->children;\n-        prev->prev = (xmlNodePtr) cur;\n-        cur->next = prev;\n-        doc->children = (xmlNodePtr) cur;\n-        } else {\n-        xmlNodePtr next;\n-\n-        next = doc->children;\n-        while ((next != NULL) && (next->type != XML_ELEMENT_NODE))\n-            next = next->next;\n-        if (next == NULL) {\n-            cur->prev = doc->last;\n-            cur->prev->next = (xmlNodePtr) cur;\n-            cur->next = NULL;\n+        doc->intSubset = cur;\n+        cur->parent = doc;\n+        cur->doc = doc;\n+        if (doc->children == NULL) {\n+            doc->children = (xmlNodePtr) cur;\n@@ -1032,8 +1013,28 @@\n-            cur->next = next;\n-            cur->prev = next->prev;\n-            if (cur->prev == NULL)\n-            doc->children = (xmlNodePtr) cur;\n-            else\n-            cur->prev->next = (xmlNodePtr) cur;\n-            next->prev = (xmlNodePtr) cur;\n-        }\n+            if (doc->type == XML_HTML_DOCUMENT_NODE) {\n+                xmlNodePtr prev;\n+\n+                prev = doc->children;\n+                prev->prev = (xmlNodePtr) cur;\n+                cur->next = prev;\n+                doc->children = (xmlNodePtr) cur;\n+            } else {\n+                xmlNodePtr next;\n+\n+                next = doc->children;\n+                while ((next != NULL) && (next->type != XML_ELEMENT_NODE))\n+                    next = next->next;\n+                if (next == NULL) {\n+                    cur->prev = doc->last;\n+                    cur->prev->next = (xmlNodePtr) cur;\n+                    cur->next = NULL;\n+                    doc->last = (xmlNodePtr) cur;\n+                } else {\n+                    cur->next = next;\n+                    cur->prev = next->prev;\n+                    if (cur->prev == NULL)\n+                        doc->children = (xmlNodePtr) cur;\n+                    else\n+                        cur->prev->next = (xmlNodePtr) cur;\n+                    next->prev = (xmlNodePtr) cur;\n+                }\n+            }\n@@ -1042,1 +1043,0 @@\n-    }\n@@ -1045,1 +1045,1 @@\n-    xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n+        xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -1056,4 +1056,4 @@\n-#define DICT_FREE(str)                      \\\n-    if ((str) && ((!dict) ||                \\\n-        (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \\\n-        xmlFree((char *)(str));\n+#define DICT_FREE(str)                                          \\\n+        if ((str) && ((!dict) ||                                \\\n+            (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \\\n+            xmlFree((char *)(str));\n@@ -1071,7 +1071,7 @@\n-    if (dict) { \\\n-        if (xmlDictOwns(dict, (const xmlChar *)(str))) \\\n-        cpy = (xmlChar *) (str); \\\n-        else \\\n-        cpy = (xmlChar *) xmlDictLookup((dict), (const xmlChar *)(str), -1); \\\n-    } else \\\n-        cpy = xmlStrdup((const xmlChar *)(str)); }\n+        if (dict) { \\\n+            if (xmlDictOwns(dict, (const xmlChar *)(str))) \\\n+                cpy = (xmlChar *) (str); \\\n+            else \\\n+                cpy = (xmlChar *) xmlDictLookup((dict), (const xmlChar *)(str), -1); \\\n+        } else \\\n+            cpy = xmlStrdup((const xmlChar *)(str)); }\n@@ -1088,7 +1088,7 @@\n-    if (dict) { \\\n-        if (xmlDictOwns(dict, (const xmlChar *)(str))) \\\n-        cpy = (const xmlChar *) (str); \\\n-        else \\\n-        cpy = xmlDictLookup((dict), (const xmlChar *)(str), -1); \\\n-    } else \\\n-        cpy = (const xmlChar *) xmlStrdup((const xmlChar *)(str)); }\n+        if (dict) { \\\n+            if (xmlDictOwns(dict, (const xmlChar *)(str))) \\\n+                cpy = (const xmlChar *) (str); \\\n+            else \\\n+                cpy = xmlDictLookup((dict), (const xmlChar *)(str), -1); \\\n+        } else \\\n+            cpy = (const xmlChar *) xmlStrdup((const xmlChar *)(str)); }\n@@ -1108,1 +1108,1 @@\n-    return;\n+        return;\n@@ -1113,1 +1113,1 @@\n-    xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n+        xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -1116,1 +1116,1 @@\n-    xmlNodePtr next, c = cur->children;\n+        xmlNodePtr next, c = cur->children;\n@@ -1118,4 +1118,4 @@\n-    \/*\n-     * Cleanup all nodes which are not part of the specific lists\n-     * of notations, elements, attributes and entities.\n-     *\/\n+        \/*\n+         * Cleanup all nodes which are not part of the specific lists\n+         * of notations, elements, attributes and entities.\n+         *\/\n@@ -1123,7 +1123,9 @@\n-        next = c->next;\n-        if ((c->type != XML_NOTATION_NODE) &&\n-            (c->type != XML_ELEMENT_DECL) &&\n-        (c->type != XML_ATTRIBUTE_DECL) &&\n-        (c->type != XML_ENTITY_DECL)) {\n-        xmlUnlinkNode(c);\n-        xmlFreeNode(c);\n+            next = c->next;\n+            if ((c->type != XML_NOTATION_NODE) &&\n+                (c->type != XML_ELEMENT_DECL) &&\n+                (c->type != XML_ATTRIBUTE_DECL) &&\n+                (c->type != XML_ENTITY_DECL)) {\n+                xmlUnlinkNode(c);\n+                xmlFreeNode(c);\n+            }\n+            c = next;\n@@ -1131,2 +1133,0 @@\n-        c = next;\n-    }\n@@ -1166,1 +1166,1 @@\n-    version = (const xmlChar *) \"1.0\";\n+        version = (const xmlChar *) \"1.0\";\n@@ -1173,2 +1173,2 @@\n-    xmlTreeErrMemory(\"building doc\");\n-    return(NULL);\n+        xmlTreeErrMemory(\"building doc\");\n+        return(NULL);\n@@ -1181,3 +1181,3 @@\n-    xmlTreeErrMemory(\"building doc\");\n-    xmlFree(cur);\n-    return(NULL);\n+        xmlTreeErrMemory(\"building doc\");\n+        xmlFree(cur);\n+        return(NULL);\n@@ -1198,1 +1198,1 @@\n-    xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n+        xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -1216,1 +1216,1 @@\n-        \"xmlFreeDoc : document == NULL\\n\");\n+                \"xmlFreeDoc : document == NULL\\n\");\n@@ -1218,1 +1218,1 @@\n-    return;\n+        return;\n@@ -1229,1 +1229,1 @@\n-    xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n+        xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -1241,1 +1241,1 @@\n-    extSubset = NULL;\n+        extSubset = NULL;\n@@ -1243,3 +1243,3 @@\n-    xmlUnlinkNode((xmlNodePtr) cur->extSubset);\n-    cur->extSubset = NULL;\n-    xmlFreeDtd(extSubset);\n+        xmlUnlinkNode((xmlNodePtr) cur->extSubset);\n+        cur->extSubset = NULL;\n+        xmlFreeDtd(extSubset);\n@@ -1248,3 +1248,3 @@\n-    xmlUnlinkNode((xmlNodePtr) cur->intSubset);\n-    cur->intSubset = NULL;\n-    xmlFreeDtd(intSubset);\n+        xmlUnlinkNode((xmlNodePtr) cur->intSubset);\n+        cur->intSubset = NULL;\n+        xmlFreeDtd(intSubset);\n@@ -1294,3 +1294,3 @@\n-    if (cur[0] == '&') {\n-        int charval = 0;\n-        xmlChar tmp;\n+        if (cur[0] == '&') {\n+            int charval = 0;\n+            xmlChar tmp;\n@@ -1298,3 +1298,3 @@\n-        \/*\n-         * Save the current text.\n-         *\/\n+            \/*\n+             * Save the current text.\n+             *\/\n@@ -1302,11 +1302,11 @@\n-        if (xmlBufAdd(buf, q, cur - q))\n-            goto out;\n-        }\n-        q = cur;\n-        if ((cur + 2 < end) && (cur[1] == '#') && (cur[2] == 'x')) {\n-        cur += 3;\n-        if (cur < end)\n-            tmp = *cur;\n-        else\n-            tmp = 0;\n-        while (tmp != ';') { \/* Non input consuming loop *\/\n+                if (xmlBufAdd(buf, q, cur - q))\n+                    goto out;\n+            }\n+            q = cur;\n+            if ((cur + 2 < end) && (cur[1] == '#') && (cur[2] == 'x')) {\n+                cur += 3;\n+                if (cur < end)\n+                    tmp = *cur;\n+                else\n+                    tmp = 0;\n+                while (tmp != ';') { \/* Non input consuming loop *\/\n@@ -1323,28 +1323,28 @@\n-            if ((tmp >= '0') && (tmp <= '9'))\n-            charval = charval * 16 + (tmp - '0');\n-            else if ((tmp >= 'a') && (tmp <= 'f'))\n-            charval = charval * 16 + (tmp - 'a') + 10;\n-            else if ((tmp >= 'A') && (tmp <= 'F'))\n-            charval = charval * 16 + (tmp - 'A') + 10;\n-            else {\n-            xmlTreeErr(XML_TREE_INVALID_HEX, (xmlNodePtr) doc,\n-                       NULL);\n-            charval = 0;\n-            break;\n-            }\n-            cur++;\n-            if (cur < end)\n-            tmp = *cur;\n-            else\n-            tmp = 0;\n-        }\n-        if (tmp == ';')\n-            cur++;\n-        q = cur;\n-        } else if ((cur + 1 < end) && (cur[1] == '#')) {\n-        cur += 2;\n-        if (cur < end)\n-            tmp = *cur;\n-        else\n-            tmp = 0;\n-        while (tmp != ';') { \/* Non input consuming loops *\/\n+                    if ((tmp >= '0') && (tmp <= '9'))\n+                        charval = charval * 16 + (tmp - '0');\n+                    else if ((tmp >= 'a') && (tmp <= 'f'))\n+                        charval = charval * 16 + (tmp - 'a') + 10;\n+                    else if ((tmp >= 'A') && (tmp <= 'F'))\n+                        charval = charval * 16 + (tmp - 'A') + 10;\n+                    else {\n+                        xmlTreeErr(XML_TREE_INVALID_HEX, (xmlNodePtr) doc,\n+                                   NULL);\n+                        charval = 0;\n+                        break;\n+                    }\n+                    cur++;\n+                    if (cur < end)\n+                        tmp = *cur;\n+                    else\n+                        tmp = 0;\n+                }\n+                if (tmp == ';')\n+                    cur++;\n+                q = cur;\n+            } else if ((cur + 1 < end) && (cur[1] == '#')) {\n+                cur += 2;\n+                if (cur < end)\n+                    tmp = *cur;\n+                else\n+                    tmp = 0;\n+                while (tmp != ';') { \/* Non input consuming loops *\/\n@@ -1352,50 +1352,13 @@\n-            if ((tmp >= '0') && (tmp <= '9'))\n-            charval = charval * 10 + (tmp - '0');\n-            else {\n-            xmlTreeErr(XML_TREE_INVALID_DEC, (xmlNodePtr) doc,\n-                       NULL);\n-            charval = 0;\n-            break;\n-            }\n-            cur++;\n-            if (cur < end)\n-            tmp = *cur;\n-            else\n-            tmp = 0;\n-        }\n-        if (tmp == ';')\n-            cur++;\n-        q = cur;\n-        } else {\n-        \/*\n-         * Read the entity string\n-         *\/\n-        cur++;\n-        q = cur;\n-        while ((cur < end) && (*cur != 0) && (*cur != ';')) cur++;\n-        if ((cur >= end) || (*cur == 0)) {\n-            xmlTreeErr(XML_TREE_UNTERMINATED_ENTITY, (xmlNodePtr) doc,\n-                       (const char *) q);\n-            goto out;\n-        }\n-        if (cur != q) {\n-            \/*\n-             * Predefined entities don't generate nodes\n-             *\/\n-            val = xmlStrndup(q, cur - q);\n-            ent = xmlGetDocEntity(doc, val);\n-            if ((ent != NULL) &&\n-            (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\n-            if (xmlBufCat(buf, ent->content))\n-                goto out;\n-\n-            } else {\n-            \/*\n-             * Flush buffer so far\n-             *\/\n-            if (!xmlBufIsEmpty(buf)) {\n-                node = xmlNewDocText(doc, NULL);\n-                if (node == NULL) {\n-                if (val != NULL) xmlFree(val);\n-                goto out;\n+                    if ((tmp >= '0') && (tmp <= '9'))\n+                        charval = charval * 10 + (tmp - '0');\n+                    else {\n+                        xmlTreeErr(XML_TREE_INVALID_DEC, (xmlNodePtr) doc,\n+                                   NULL);\n+                        charval = 0;\n+                        break;\n+                    }\n+                    cur++;\n+                    if (cur < end)\n+                        tmp = *cur;\n+                    else\n+                        tmp = 0;\n@@ -1403,6 +1366,14 @@\n-                node->content = xmlBufDetach(buf);\n-\n-                if (last == NULL) {\n-                last = ret = node;\n-                } else {\n-                last = xmlAddNextSibling(last, node);\n+                if (tmp == ';')\n+                    cur++;\n+                q = cur;\n+            } else {\n+                \/*\n+                 * Read the entity string\n+                 *\/\n+                cur++;\n+                q = cur;\n+                while ((cur < end) && (*cur != 0) && (*cur != ';')) cur++;\n+                if ((cur >= end) || (*cur == 0)) {\n+                    xmlTreeErr(XML_TREE_UNTERMINATED_ENTITY, (xmlNodePtr) doc,\n+                               (const char *) q);\n+                    goto out;\n@@ -1410,1 +1381,30 @@\n-            }\n+                if (cur != q) {\n+                    \/*\n+                     * Predefined entities don't generate nodes\n+                     *\/\n+                    val = xmlStrndup(q, cur - q);\n+                    ent = xmlGetDocEntity(doc, val);\n+                    if ((ent != NULL) &&\n+                        (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+\n+                        if (xmlBufCat(buf, ent->content))\n+                            goto out;\n+\n+                    } else {\n+                        \/*\n+                         * Flush buffer so far\n+                         *\/\n+                        if (!xmlBufIsEmpty(buf)) {\n+                            node = xmlNewDocText(doc, NULL);\n+                            if (node == NULL) {\n+                                if (val != NULL) xmlFree(val);\n+                                goto out;\n+                            }\n+                            node->content = xmlBufDetach(buf);\n+\n+                            if (last == NULL) {\n+                                last = ret = node;\n+                            } else {\n+                                last = xmlAddNextSibling(last, node);\n+                            }\n+                        }\n@@ -1412,10 +1412,10 @@\n-            \/*\n-             * Create a new REFERENCE_REF node\n-             *\/\n-            node = xmlNewReference(doc, val);\n-            if (node == NULL) {\n-                if (val != NULL) xmlFree(val);\n-                goto out;\n-            }\n-            else if ((ent != NULL) && (ent->children == NULL)) {\n-                xmlNodePtr temp;\n+                        \/*\n+                         * Create a new REFERENCE_REF node\n+                         *\/\n+                        node = xmlNewReference(doc, val);\n+                        if (node == NULL) {\n+                            if (val != NULL) xmlFree(val);\n+                            goto out;\n+                        }\n+                        else if ((ent != NULL) && (ent->children == NULL)) {\n+                            xmlNodePtr temp;\n@@ -1424,9 +1424,18 @@\n-                ent->children = (xmlNodePtr) -1;\n-                ent->children = xmlStringGetNodeList(doc,\n-                    (const xmlChar*)node->content);\n-                ent->owner = 1;\n-                temp = ent->children;\n-                while (temp) {\n-                temp->parent = (xmlNodePtr)ent;\n-                ent->last = temp;\n-                temp = temp->next;\n+                            ent->children = (xmlNodePtr) -1;\n+                            ent->children = xmlStringGetNodeList(doc,\n+                                    (const xmlChar*)node->content);\n+                            ent->owner = 1;\n+                            temp = ent->children;\n+                            while (temp) {\n+                                temp->parent = (xmlNodePtr)ent;\n+                                ent->last = temp;\n+                                temp = temp->next;\n+                            }\n+                        }\n+                        if (last == NULL) {\n+                            last = ret = node;\n+                        } else {\n+                            last = xmlAddNextSibling(last, node);\n+                        }\n+                    }\n+                    xmlFree(val);\n@@ -1434,0 +1443,2 @@\n+                cur++;\n+                q = cur;\n@@ -1435,14 +1446,3 @@\n-            if (last == NULL) {\n-                last = ret = node;\n-            } else {\n-                last = xmlAddNextSibling(last, node);\n-            }\n-            }\n-            xmlFree(val);\n-        }\n-        cur++;\n-        q = cur;\n-        }\n-        if (charval != 0) {\n-        xmlChar buffer[10];\n-        int l;\n+            if (charval != 0) {\n+                xmlChar buffer[10];\n+                int l;\n@@ -1450,2 +1450,2 @@\n-        l = xmlCopyCharMultiByte(buffer, charval);\n-        buffer[l] = 0;\n+                l = xmlCopyCharMultiByte(buffer, charval);\n+                buffer[l] = 0;\n@@ -1453,6 +1453,6 @@\n-        if (xmlBufCat(buf, buffer))\n-            goto out;\n-        charval = 0;\n-        }\n-    } else\n-        cur++;\n+                if (xmlBufCat(buf, buffer))\n+                    goto out;\n+                charval = 0;\n+            }\n+        } else\n+            cur++;\n@@ -1463,4 +1463,4 @@\n-     * Handle the last piece of text.\n-     *\/\n-    if (xmlBufAdd(buf, q, cur - q))\n-        goto out;\n+         * Handle the last piece of text.\n+         *\/\n+        if (xmlBufAdd(buf, q, cur - q))\n+            goto out;\n@@ -1470,3 +1470,3 @@\n-    node = xmlNewDocText(doc, NULL);\n-    if (node == NULL) goto out;\n-    node->content = xmlBufDetach(buf);\n+        node = xmlNewDocText(doc, NULL);\n+        if (node == NULL) goto out;\n+        node->content = xmlBufDetach(buf);\n@@ -1474,5 +1474,5 @@\n-    if (last == NULL) {\n-        ret = node;\n-    } else {\n-        xmlAddNextSibling(last, node);\n-    }\n+        if (last == NULL) {\n+            ret = node;\n+        } else {\n+            xmlAddNextSibling(last, node);\n+        }\n@@ -1515,3 +1515,3 @@\n-    if (cur[0] == '&') {\n-        int charval = 0;\n-        xmlChar tmp;\n+        if (cur[0] == '&') {\n+            int charval = 0;\n+            xmlChar tmp;\n@@ -1519,3 +1519,3 @@\n-        \/*\n-         * Save the current text.\n-         *\/\n+            \/*\n+             * Save the current text.\n+             *\/\n@@ -1523,20 +1523,2 @@\n-        if (xmlBufAdd(buf, q, cur - q))\n-            goto out;\n-        }\n-        q = cur;\n-        if ((cur[1] == '#') && (cur[2] == 'x')) {\n-        cur += 3;\n-        tmp = *cur;\n-        while (tmp != ';') { \/* Non input consuming loop *\/\n-                    \/* Don't check for integer overflow, see above. *\/\n-            if ((tmp >= '0') && (tmp <= '9'))\n-            charval = charval * 16 + (tmp - '0');\n-            else if ((tmp >= 'a') && (tmp <= 'f'))\n-            charval = charval * 16 + (tmp - 'a') + 10;\n-            else if ((tmp >= 'A') && (tmp <= 'F'))\n-            charval = charval * 16 + (tmp - 'A') + 10;\n-            else {\n-            xmlTreeErr(XML_TREE_INVALID_HEX, (xmlNodePtr) doc,\n-                       NULL);\n-            charval = 0;\n-            break;\n+                if (xmlBufAdd(buf, q, cur - q))\n+                    goto out;\n@@ -1544,10 +1526,5 @@\n-            cur++;\n-            tmp = *cur;\n-        }\n-        if (tmp == ';')\n-            cur++;\n-        q = cur;\n-        } else if  (cur[1] == '#') {\n-        cur += 2;\n-        tmp = *cur;\n-        while (tmp != ';') { \/* Non input consuming loops *\/\n+            q = cur;\n+            if ((cur[1] == '#') && (cur[2] == 'x')) {\n+                cur += 3;\n+                tmp = *cur;\n+                while (tmp != ';') { \/* Non input consuming loop *\/\n@@ -1555,38 +1532,37 @@\n-            if ((tmp >= '0') && (tmp <= '9'))\n-            charval = charval * 10 + (tmp - '0');\n-            else {\n-            xmlTreeErr(XML_TREE_INVALID_DEC, (xmlNodePtr) doc,\n-                       NULL);\n-            charval = 0;\n-            break;\n-            }\n-            cur++;\n-            tmp = *cur;\n-        }\n-        if (tmp == ';')\n-            cur++;\n-        q = cur;\n-        } else {\n-        \/*\n-         * Read the entity string\n-         *\/\n-        cur++;\n-        q = cur;\n-        while ((*cur != 0) && (*cur != ';')) cur++;\n-        if (*cur == 0) {\n-            xmlTreeErr(XML_TREE_UNTERMINATED_ENTITY,\n-                       (xmlNodePtr) doc, (const char *) q);\n-            goto out;\n-        }\n-        if (cur != q) {\n-            \/*\n-             * Predefined entities don't generate nodes\n-             *\/\n-            val = xmlStrndup(q, cur - q);\n-            ent = xmlGetDocEntity(doc, val);\n-            if ((ent != NULL) &&\n-            (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-\n-            if (xmlBufCat(buf, ent->content))\n-                goto out;\n-\n+                    if ((tmp >= '0') && (tmp <= '9'))\n+                        charval = charval * 16 + (tmp - '0');\n+                    else if ((tmp >= 'a') && (tmp <= 'f'))\n+                        charval = charval * 16 + (tmp - 'a') + 10;\n+                    else if ((tmp >= 'A') && (tmp <= 'F'))\n+                        charval = charval * 16 + (tmp - 'A') + 10;\n+                    else {\n+                        xmlTreeErr(XML_TREE_INVALID_HEX, (xmlNodePtr) doc,\n+                                   NULL);\n+                        charval = 0;\n+                        break;\n+                    }\n+                    cur++;\n+                    tmp = *cur;\n+                }\n+                if (tmp == ';')\n+                    cur++;\n+                q = cur;\n+            } else if  (cur[1] == '#') {\n+                cur += 2;\n+                tmp = *cur;\n+                while (tmp != ';') { \/* Non input consuming loops *\/\n+                    \/* Don't check for integer overflow, see above. *\/\n+                    if ((tmp >= '0') && (tmp <= '9'))\n+                        charval = charval * 10 + (tmp - '0');\n+                    else {\n+                        xmlTreeErr(XML_TREE_INVALID_DEC, (xmlNodePtr) doc,\n+                                   NULL);\n+                        charval = 0;\n+                        break;\n+                    }\n+                    cur++;\n+                    tmp = *cur;\n+                }\n+                if (tmp == ';')\n+                    cur++;\n+                q = cur;\n@@ -1594,11 +1570,10 @@\n-            \/*\n-             * Flush buffer so far\n-             *\/\n-            if (!xmlBufIsEmpty(buf)) {\n-                node = xmlNewDocText(doc, NULL);\n-                node->content = xmlBufDetach(buf);\n-\n-                if (last == NULL) {\n-                last = ret = node;\n-                } else {\n-                last = xmlAddNextSibling(last, node);\n+                \/*\n+                 * Read the entity string\n+                 *\/\n+                cur++;\n+                q = cur;\n+                while ((*cur != 0) && (*cur != ';')) cur++;\n+                if (*cur == 0) {\n+                    xmlTreeErr(XML_TREE_UNTERMINATED_ENTITY,\n+                               (xmlNodePtr) doc, (const char *) q);\n+                    goto out;\n@@ -1606,1 +1581,30 @@\n-            }\n+                if (cur != q) {\n+                    \/*\n+                     * Predefined entities don't generate nodes\n+                     *\/\n+                    val = xmlStrndup(q, cur - q);\n+                    ent = xmlGetDocEntity(doc, val);\n+                    if ((ent != NULL) &&\n+                        (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+\n+                        if (xmlBufCat(buf, ent->content))\n+                            goto out;\n+\n+                    } else {\n+                        \/*\n+                         * Flush buffer so far\n+                         *\/\n+                        if (!xmlBufIsEmpty(buf)) {\n+                            node = xmlNewDocText(doc, NULL);\n+                            if (node == NULL) {\n+                                if (val != NULL) xmlFree(val);\n+                                goto out;\n+                            }\n+                            node->content = xmlBufDetach(buf);\n+\n+                            if (last == NULL) {\n+                                last = ret = node;\n+                            } else {\n+                                last = xmlAddNextSibling(last, node);\n+                            }\n+                        }\n@@ -1608,10 +1612,10 @@\n-            \/*\n-             * Create a new REFERENCE_REF node\n-             *\/\n-            node = xmlNewReference(doc, val);\n-            if (node == NULL) {\n-                if (val != NULL) xmlFree(val);\n-                goto out;\n-            }\n-            else if ((ent != NULL) && (ent->children == NULL)) {\n-                xmlNodePtr temp;\n+                        \/*\n+                         * Create a new REFERENCE_REF node\n+                         *\/\n+                        node = xmlNewReference(doc, val);\n+                        if (node == NULL) {\n+                            if (val != NULL) xmlFree(val);\n+                            goto out;\n+                        }\n+                        else if ((ent != NULL) && (ent->children == NULL)) {\n+                            xmlNodePtr temp;\n@@ -1620,9 +1624,18 @@\n-                ent->children = (xmlNodePtr) -1;\n-                ent->children = xmlStringGetNodeList(doc,\n-                    (const xmlChar*)node->content);\n-                ent->owner = 1;\n-                temp = ent->children;\n-                while (temp) {\n-                temp->parent = (xmlNodePtr)ent;\n-                ent->last = temp;\n-                temp = temp->next;\n+                            ent->children = (xmlNodePtr) -1;\n+                            ent->children = xmlStringGetNodeList(doc,\n+                                    (const xmlChar*)node->content);\n+                            ent->owner = 1;\n+                            temp = ent->children;\n+                            while (temp) {\n+                                temp->parent = (xmlNodePtr)ent;\n+                                ent->last = temp;\n+                                temp = temp->next;\n+                            }\n+                        }\n+                        if (last == NULL) {\n+                            last = ret = node;\n+                        } else {\n+                            last = xmlAddNextSibling(last, node);\n+                        }\n+                    }\n+                    xmlFree(val);\n@@ -1630,0 +1643,2 @@\n+                cur++;\n+                q = cur;\n@@ -1631,14 +1646,3 @@\n-            if (last == NULL) {\n-                last = ret = node;\n-            } else {\n-                last = xmlAddNextSibling(last, node);\n-            }\n-            }\n-            xmlFree(val);\n-        }\n-        cur++;\n-        q = cur;\n-        }\n-        if (charval != 0) {\n-        xmlChar buffer[10];\n-        int len;\n+            if (charval != 0) {\n+                xmlChar buffer[10];\n+                int len;\n@@ -1646,2 +1650,2 @@\n-        len = xmlCopyCharMultiByte(buffer, charval);\n-        buffer[len] = 0;\n+                len = xmlCopyCharMultiByte(buffer, charval);\n+                buffer[len] = 0;\n@@ -1649,6 +1653,6 @@\n-        if (xmlBufCat(buf, buffer))\n-            goto out;\n-        charval = 0;\n-        }\n-    } else\n-        cur++;\n+                if (xmlBufCat(buf, buffer))\n+                    goto out;\n+                charval = 0;\n+            }\n+        } else\n+            cur++;\n@@ -1658,3 +1662,3 @@\n-     * Handle the last piece of text.\n-     *\/\n-    xmlBufAdd(buf, q, cur - q);\n+         * Handle the last piece of text.\n+         *\/\n+        xmlBufAdd(buf, q, cur - q);\n@@ -1664,1 +1668,1 @@\n-    node = xmlNewDocText(doc, NULL);\n+        node = xmlNewDocText(doc, NULL);\n@@ -1669,1 +1673,1 @@\n-    node->content = xmlBufDetach(buf);\n+        node->content = xmlBufDetach(buf);\n@@ -1671,5 +1675,5 @@\n-    if (last == NULL) {\n-        ret = node;\n-    } else {\n-        xmlAddNextSibling(last, node);\n-    }\n+        if (last == NULL) {\n+            ret = node;\n+        } else {\n+            xmlAddNextSibling(last, node);\n+        }\n@@ -1717,4 +1721,4 @@\n-        if (attr)\n-            buffer = xmlEncodeAttributeEntities(doc, node->content);\n-        else\n-            buffer = xmlEncodeEntitiesReentrant(doc, node->content);\n+                if (attr)\n+                    buffer = xmlEncodeAttributeEntities(doc, node->content);\n+                else\n+                    buffer = xmlEncodeEntitiesReentrant(doc, node->content);\n@@ -1865,2 +1869,2 @@\n-        ((node->doc == NULL) ||\n-         (!(xmlDictOwns(node->doc->dict, name)))))\n+            ((node->doc == NULL) ||\n+             (!(xmlDictOwns(node->doc->dict, name)))))\n@@ -1877,2 +1881,2 @@\n-        ((node == NULL) || (node->doc == NULL) ||\n-         (!(xmlDictOwns(node->doc->dict, name)))))\n+            ((node == NULL) || (node->doc == NULL) ||\n+             (!(xmlDictOwns(node->doc->dict, name)))))\n@@ -1957,1 +1961,1 @@\n-        \"xmlNewProp : name == NULL\\n\");\n+                \"xmlNewProp : name == NULL\\n\");\n@@ -1959,1 +1963,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1962,1 +1966,1 @@\n-    return xmlNewPropInternal(node, NULL, name, value, 0);\n+        return xmlNewPropInternal(node, NULL, name, value, 0);\n@@ -1983,1 +1987,1 @@\n-        \"xmlNewNsProp : name == NULL\\n\");\n+                \"xmlNewNsProp : name == NULL\\n\");\n@@ -1985,1 +1989,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2008,1 +2012,1 @@\n-        \"xmlNewNsPropEatName : name == NULL\\n\");\n+                \"xmlNewNsPropEatName : name == NULL\\n\");\n@@ -2010,1 +2014,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2037,1 +2041,1 @@\n-        \"xmlNewDocProp : name == NULL\\n\");\n+                \"xmlNewDocProp : name == NULL\\n\");\n@@ -2039,1 +2043,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2047,2 +2051,2 @@\n-    xmlTreeErrMemory(\"building attribute\");\n-    return(NULL);\n+        xmlTreeErrMemory(\"building attribute\");\n+        return(NULL);\n@@ -2054,1 +2058,1 @@\n-    cur->name = xmlDictLookup(doc->dict, name, -1);\n+        cur->name = xmlDictLookup(doc->dict, name, -1);\n@@ -2056,1 +2060,1 @@\n-    cur->name = xmlStrdup(name);\n+        cur->name = xmlStrdup(name);\n@@ -2059,1 +2063,1 @@\n-    xmlNodePtr tmp;\n+        xmlNodePtr tmp;\n@@ -2061,2 +2065,2 @@\n-    cur->children = xmlStringGetNodeList(doc, value);\n-    cur->last = NULL;\n+        cur->children = xmlStringGetNodeList(doc, value);\n+        cur->last = NULL;\n@@ -2064,7 +2068,7 @@\n-    tmp = cur->children;\n-    while (tmp != NULL) {\n-        tmp->parent = (xmlNodePtr) cur;\n-        if (tmp->next == NULL)\n-        cur->last = tmp;\n-        tmp = tmp->next;\n-    }\n+        tmp = cur->children;\n+        while (tmp != NULL) {\n+            tmp->parent = (xmlNodePtr) cur;\n+            if (tmp->next == NULL)\n+                cur->last = tmp;\n+            tmp = tmp->next;\n+        }\n@@ -2074,1 +2078,1 @@\n-    xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n+        xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -2091,1 +2095,1 @@\n-    cur = next;\n+        cur = next;\n@@ -2109,1 +2113,1 @@\n-    xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n+        xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -2113,1 +2117,1 @@\n-        xmlRemoveID(cur->doc, cur);\n+            xmlRemoveID(cur->doc, cur);\n@@ -2135,1 +2139,1 @@\n-        \"xmlRemoveProp : cur == NULL\\n\");\n+                \"xmlRemoveProp : cur == NULL\\n\");\n@@ -2137,1 +2141,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2142,1 +2146,1 @@\n-        \"xmlRemoveProp : cur->parent == NULL\\n\");\n+                \"xmlRemoveProp : cur->parent == NULL\\n\");\n@@ -2144,1 +2148,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2149,10 +2153,2 @@\n-        if (cur->next != NULL)\n-            cur->next->prev = NULL;\n-    xmlFreeProp(cur);\n-    return(0);\n-    }\n-    while (tmp != NULL) {\n-    if (tmp->next == cur) {\n-        tmp->next = cur->next;\n-        if (tmp->next != NULL)\n-        tmp->next->prev = tmp;\n+                if (cur->next != NULL)\n+                        cur->next->prev = NULL;\n@@ -2162,0 +2158,8 @@\n+    while (tmp != NULL) {\n+        if (tmp->next == cur) {\n+            tmp->next = cur->next;\n+            if (tmp->next != NULL)\n+                tmp->next->prev = tmp;\n+            xmlFreeProp(cur);\n+            return(0);\n+        }\n@@ -2166,1 +2170,1 @@\n-        \"xmlRemoveProp : attribute not owned by its node\\n\");\n+            \"xmlRemoveProp : attribute not owned by its node\\n\");\n@@ -2187,1 +2191,1 @@\n-        \"xmlNewPI : name == NULL\\n\");\n+                \"xmlNewPI : name == NULL\\n\");\n@@ -2189,1 +2193,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2197,2 +2201,2 @@\n-    xmlTreeErrMemory(\"building PI\");\n-    return(NULL);\n+        xmlTreeErrMemory(\"building PI\");\n+        return(NULL);\n@@ -2206,1 +2210,1 @@\n-    cur->name = xmlStrdup(name);\n+        cur->name = xmlStrdup(name);\n@@ -2208,1 +2212,1 @@\n-    cur->content = xmlStrdup(content);\n+        cur->content = xmlStrdup(content);\n@@ -2213,1 +2217,1 @@\n-    xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n+        xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -2249,1 +2253,1 @@\n-        \"xmlNewNode : name == NULL\\n\");\n+                \"xmlNewNode : name == NULL\\n\");\n@@ -2251,1 +2255,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2259,2 +2263,2 @@\n-    xmlTreeErrMemory(\"building node\");\n-    return(NULL);\n+        xmlTreeErrMemory(\"building node\");\n+        return(NULL);\n@@ -2269,1 +2273,1 @@\n-    xmlRegisterNodeDefaultValue(cur);\n+        xmlRegisterNodeDefaultValue(cur);\n@@ -2291,1 +2295,1 @@\n-        \"xmlNewNode : name == NULL\\n\");\n+                \"xmlNewNode : name == NULL\\n\");\n@@ -2293,1 +2297,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2301,3 +2305,3 @@\n-    xmlTreeErrMemory(\"building node\");\n-    \/* we can't check here that name comes from the doc dictionary *\/\n-    return(NULL);\n+        xmlTreeErrMemory(\"building node\");\n+        \/* we can't check here that name comes from the doc dictionary *\/\n+        return(NULL);\n@@ -2312,1 +2316,1 @@\n-    xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n+        xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -2339,1 +2343,1 @@\n-                            xmlDictLookup(doc->dict, name, -1));\n+                                xmlDictLookup(doc->dict, name, -1));\n@@ -2341,1 +2345,1 @@\n-    cur = xmlNewNode(ns, name);\n+        cur = xmlNewNode(ns, name);\n@@ -2344,4 +2348,4 @@\n-    if (content != NULL) {\n-        cur->children = xmlStringGetNodeList(doc, content);\n-        UPDATE_LAST_CHILD_AND_PARENT(cur)\n-    }\n+        if (content != NULL) {\n+            cur->children = xmlStringGetNodeList(doc, content);\n+            UPDATE_LAST_CHILD_AND_PARENT(cur)\n+        }\n@@ -2377,4 +2381,4 @@\n-    if (content != NULL) {\n-        cur->children = xmlStringGetNodeList(doc, content);\n-        UPDATE_LAST_CHILD_AND_PARENT(cur)\n-    }\n+        if (content != NULL) {\n+            cur->children = xmlStringGetNodeList(doc, content);\n+            UPDATE_LAST_CHILD_AND_PARENT(cur)\n+        }\n@@ -2384,2 +2388,2 @@\n-        (!(xmlDictOwns(doc->dict, name))))\n-        xmlFree(name);\n+            (!(xmlDictOwns(doc->dict, name))))\n+            xmlFree(name);\n@@ -2411,4 +2415,4 @@\n-    if (content != NULL) {\n-        cur->children = xmlNewDocText(doc, content);\n-        UPDATE_LAST_CHILD_AND_PARENT(cur)\n-    }\n+        if (content != NULL) {\n+            cur->children = xmlNewDocText(doc, content);\n+            UPDATE_LAST_CHILD_AND_PARENT(cur)\n+        }\n@@ -2435,2 +2439,2 @@\n-    xmlTreeErrMemory(\"building fragment\");\n-    return(NULL);\n+        xmlTreeErrMemory(\"building fragment\");\n+        return(NULL);\n@@ -2444,1 +2448,1 @@\n-    xmlRegisterNodeDefaultValue(cur);\n+        xmlRegisterNodeDefaultValue(cur);\n@@ -2465,2 +2469,2 @@\n-    xmlTreeErrMemory(\"building text\");\n-    return(NULL);\n+        xmlTreeErrMemory(\"building text\");\n+        return(NULL);\n@@ -2473,1 +2477,1 @@\n-    cur->content = xmlStrdup(content);\n+        cur->content = xmlStrdup(content);\n@@ -2477,1 +2481,1 @@\n-    xmlRegisterNodeDefaultValue(cur);\n+        xmlRegisterNodeDefaultValue(cur);\n@@ -2509,1 +2513,1 @@\n-        \"xmlNewTextChild : parent == NULL\\n\");\n+                \"xmlNewTextChild : parent == NULL\\n\");\n@@ -2511,1 +2515,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2517,1 +2521,1 @@\n-        \"xmlNewTextChild : name == NULL\\n\");\n+                \"xmlNewTextChild : name == NULL\\n\");\n@@ -2519,1 +2523,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2526,4 +2530,4 @@\n-    if (ns == NULL)\n-        cur = xmlNewDocRawNode(parent->doc, parent->ns, name, content);\n-    else\n-        cur = xmlNewDocRawNode(parent->doc, ns, name, content);\n+        if (ns == NULL)\n+            cur = xmlNewDocRawNode(parent->doc, parent->ns, name, content);\n+        else\n+            cur = xmlNewDocRawNode(parent->doc, ns, name, content);\n@@ -2531,5 +2535,5 @@\n-           (parent->type == XML_HTML_DOCUMENT_NODE)) {\n-    if (ns == NULL)\n-        cur = xmlNewDocRawNode((xmlDocPtr) parent, NULL, name, content);\n-    else\n-        cur = xmlNewDocRawNode((xmlDocPtr) parent, ns, name, content);\n+               (parent->type == XML_HTML_DOCUMENT_NODE)) {\n+        if (ns == NULL)\n+            cur = xmlNewDocRawNode((xmlDocPtr) parent, NULL, name, content);\n+        else\n+            cur = xmlNewDocRawNode((xmlDocPtr) parent, ns, name, content);\n@@ -2537,1 +2541,1 @@\n-        cur = xmlNewDocRawNode( parent->doc, ns, name, content);\n+            cur = xmlNewDocRawNode( parent->doc, ns, name, content);\n@@ -2539,1 +2543,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2551,1 +2555,1 @@\n-    parent->last = cur;\n+        parent->last = cur;\n@@ -2554,3 +2558,3 @@\n-    prev->next = cur;\n-    cur->prev = prev;\n-    parent->last = cur;\n+        prev->next = cur;\n+        cur->prev = prev;\n+        parent->last = cur;\n@@ -2583,2 +2587,2 @@\n-    xmlTreeErrMemory(\"building character reference\");\n-    return(NULL);\n+        xmlTreeErrMemory(\"building character reference\");\n+        return(NULL);\n@@ -2593,5 +2597,5 @@\n-    len = xmlStrlen(name);\n-    if (name[len - 1] == ';')\n-        cur->name = xmlStrndup(name, len - 1);\n-    else\n-        cur->name = xmlStrndup(name, len);\n+        len = xmlStrlen(name);\n+        if (name[len - 1] == ';')\n+            cur->name = xmlStrndup(name, len - 1);\n+        else\n+            cur->name = xmlStrndup(name, len);\n@@ -2599,1 +2603,1 @@\n-    cur->name = xmlStrdup(name);\n+        cur->name = xmlStrdup(name);\n@@ -2602,1 +2606,1 @@\n-    xmlRegisterNodeDefaultValue(cur);\n+        xmlRegisterNodeDefaultValue(cur);\n@@ -2627,2 +2631,2 @@\n-    xmlTreeErrMemory(\"building reference\");\n-    return(NULL);\n+        xmlTreeErrMemory(\"building reference\");\n+        return(NULL);\n@@ -2637,5 +2641,5 @@\n-    len = xmlStrlen(name);\n-    if (name[len - 1] == ';')\n-        cur->name = xmlStrndup(name, len - 1);\n-    else\n-        cur->name = xmlStrndup(name, len);\n+        len = xmlStrlen(name);\n+        if (name[len - 1] == ';')\n+            cur->name = xmlStrndup(name, len - 1);\n+        else\n+            cur->name = xmlStrndup(name, len);\n@@ -2643,1 +2647,1 @@\n-    cur->name = xmlStrdup(name);\n+        cur->name = xmlStrdup(name);\n@@ -2647,8 +2651,8 @@\n-    cur->content = ent->content;\n-    \/*\n-     * The parent pointer in entity is a DTD pointer and thus is NOT\n-     * updated.  Not sure if this is 100% correct.\n-     *  -George\n-     *\/\n-    cur->children = (xmlNodePtr) ent;\n-    cur->last = (xmlNodePtr) ent;\n+        cur->content = ent->content;\n+        \/*\n+         * The parent pointer in entity is a DTD pointer and thus is NOT\n+         * updated.  Not sure if this is 100% correct.\n+         *  -George\n+         *\/\n+        cur->children = (xmlNodePtr) ent;\n+        cur->last = (xmlNodePtr) ent;\n@@ -2658,1 +2662,1 @@\n-    xmlRegisterNodeDefaultValue(cur);\n+        xmlRegisterNodeDefaultValue(cur);\n@@ -2696,2 +2700,2 @@\n-    xmlTreeErrMemory(\"building text\");\n-    return(NULL);\n+        xmlTreeErrMemory(\"building text\");\n+        return(NULL);\n@@ -2704,1 +2708,1 @@\n-    cur->content = xmlStrndup(content, len);\n+        cur->content = xmlStrndup(content, len);\n@@ -2708,1 +2712,1 @@\n-    xmlRegisterNodeDefaultValue(cur);\n+        xmlRegisterNodeDefaultValue(cur);\n@@ -2747,2 +2751,2 @@\n-    xmlTreeErrMemory(\"building comment\");\n-    return(NULL);\n+        xmlTreeErrMemory(\"building comment\");\n+        return(NULL);\n@@ -2755,1 +2759,1 @@\n-    cur->content = xmlStrdup(content);\n+        cur->content = xmlStrdup(content);\n@@ -2759,1 +2763,1 @@\n-    xmlRegisterNodeDefaultValue(cur);\n+        xmlRegisterNodeDefaultValue(cur);\n@@ -2781,2 +2785,2 @@\n-    xmlTreeErrMemory(\"building CDATA\");\n-    return(NULL);\n+        xmlTreeErrMemory(\"building CDATA\");\n+        return(NULL);\n@@ -2789,1 +2793,1 @@\n-    cur->content = xmlStrndup(content, len);\n+        cur->content = xmlStrndup(content, len);\n@@ -2793,1 +2797,1 @@\n-    xmlRegisterNodeDefaultValue(cur);\n+        xmlRegisterNodeDefaultValue(cur);\n@@ -2826,1 +2830,1 @@\n-    return;\n+        return;\n@@ -2828,3 +2832,3 @@\n-    if(tree->type == XML_ELEMENT_NODE) {\n-        prop = tree->properties;\n-        while (prop != NULL) {\n+        if(tree->type == XML_ELEMENT_NODE) {\n+            prop = tree->properties;\n+            while (prop != NULL) {\n@@ -2835,2 +2839,2 @@\n-        prop->doc = doc;\n-        xmlSetListDoc(prop->children, doc);\n+                prop->doc = doc;\n+                xmlSetListDoc(prop->children, doc);\n@@ -2852,1 +2856,2 @@\n-        prop = prop->next;\n+                prop = prop->next;\n+            }\n@@ -2854,4 +2859,10 @@\n-    }\n-    if (tree->children != NULL)\n-        xmlSetListDoc(tree->children, doc);\n-    tree->doc = doc;\n+        if (tree->type == XML_ENTITY_REF_NODE) {\n+            \/*\n+             * Clear 'children' which points to the entity declaration\n+             * from the original document.\n+             *\/\n+            tree->children = NULL;\n+        } else if (tree->children != NULL) {\n+            xmlSetListDoc(tree->children, doc);\n+        }\n+        tree->doc = doc;\n@@ -2873,1 +2884,1 @@\n-    return;\n+        return;\n@@ -2876,3 +2887,3 @@\n-    if (cur->doc != doc)\n-        xmlSetTreeDoc(cur, doc);\n-    cur = cur->next;\n+        if (cur->doc != doc)\n+            xmlSetTreeDoc(cur, doc);\n+        cur = cur->next;\n@@ -2908,1 +2919,1 @@\n-        \"xmlNewChild : parent == NULL\\n\");\n+                \"xmlNewChild : parent == NULL\\n\");\n@@ -2910,1 +2921,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2916,1 +2927,1 @@\n-        \"xmlNewChild : name == NULL\\n\");\n+                \"xmlNewChild : name == NULL\\n\");\n@@ -2918,1 +2929,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2925,4 +2936,4 @@\n-    if (ns == NULL)\n-        cur = xmlNewDocNode(parent->doc, parent->ns, name, content);\n-    else\n-        cur = xmlNewDocNode(parent->doc, ns, name, content);\n+        if (ns == NULL)\n+            cur = xmlNewDocNode(parent->doc, parent->ns, name, content);\n+        else\n+            cur = xmlNewDocNode(parent->doc, ns, name, content);\n@@ -2930,5 +2941,5 @@\n-           (parent->type == XML_HTML_DOCUMENT_NODE)) {\n-    if (ns == NULL)\n-        cur = xmlNewDocNode((xmlDocPtr) parent, NULL, name, content);\n-    else\n-        cur = xmlNewDocNode((xmlDocPtr) parent, ns, name, content);\n+               (parent->type == XML_HTML_DOCUMENT_NODE)) {\n+        if (ns == NULL)\n+            cur = xmlNewDocNode((xmlDocPtr) parent, NULL, name, content);\n+        else\n+            cur = xmlNewDocNode((xmlDocPtr) parent, ns, name, content);\n@@ -2936,1 +2947,1 @@\n-        cur = xmlNewDocNode( parent->doc, ns, name, content);\n+            cur = xmlNewDocNode( parent->doc, ns, name, content);\n@@ -2938,1 +2949,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2950,1 +2961,1 @@\n-    parent->last = cur;\n+        parent->last = cur;\n@@ -2953,3 +2964,3 @@\n-    prev->next = cur;\n-    cur->prev = prev;\n-    parent->last = cur;\n+        prev->next = cur;\n+        cur->prev = prev;\n+        parent->last = cur;\n@@ -2977,1 +2988,1 @@\n-    xmlAttrPtr attr;\n+        xmlAttrPtr attr;\n@@ -2979,4 +2990,4 @@\n-    if ((cur == NULL) || (cur->type != XML_ATTRIBUTE_NODE) ||\n-        (prop == NULL) || (prop->type != XML_ATTRIBUTE_NODE) ||\n-        ((prev != NULL) && (prev->type != XML_ATTRIBUTE_NODE)))\n-        return(NULL);\n+        if ((cur == NULL) || (cur->type != XML_ATTRIBUTE_NODE) ||\n+            (prop == NULL) || (prop->type != XML_ATTRIBUTE_NODE) ||\n+            ((prev != NULL) && (prev->type != XML_ATTRIBUTE_NODE)))\n+                return(NULL);\n@@ -2984,27 +2995,27 @@\n-    \/* check if an attribute with the same name exists *\/\n-    if (prop->ns == NULL)\n-        attr = xmlHasNsProp(cur->parent, prop->name, NULL);\n-    else\n-        attr = xmlHasNsProp(cur->parent, prop->name, prop->ns->href);\n-\n-    if (prop->doc != cur->doc) {\n-        xmlSetTreeDoc(prop, cur->doc);\n-    }\n-    prop->parent = cur->parent;\n-    prop->prev = prev;\n-    if (prev != NULL) {\n-        prop->next = prev->next;\n-        prev->next = prop;\n-        if (prop->next)\n-            prop->next->prev = prop;\n-    } else {\n-        prop->next = cur;\n-        cur->prev = prop;\n-    }\n-    if (prop->prev == NULL && prop->parent != NULL)\n-        prop->parent->properties = (xmlAttrPtr) prop;\n-    if ((attr != NULL) && (attr->type != XML_ATTRIBUTE_DECL)) {\n-        \/* different instance, destroy it (attributes must be unique) *\/\n-        xmlRemoveProp((xmlAttrPtr) attr);\n-    }\n-    return prop;\n+        \/* check if an attribute with the same name exists *\/\n+        if (prop->ns == NULL)\n+                attr = xmlHasNsProp(cur->parent, prop->name, NULL);\n+        else\n+                attr = xmlHasNsProp(cur->parent, prop->name, prop->ns->href);\n+\n+        if (prop->doc != cur->doc) {\n+                xmlSetTreeDoc(prop, cur->doc);\n+        }\n+        prop->parent = cur->parent;\n+        prop->prev = prev;\n+        if (prev != NULL) {\n+                prop->next = prev->next;\n+                prev->next = prop;\n+                if (prop->next)\n+                        prop->next->prev = prop;\n+        } else {\n+                prop->next = cur;\n+                cur->prev = prop;\n+        }\n+        if (prop->prev == NULL && prop->parent != NULL)\n+                prop->parent->properties = (xmlAttrPtr) prop;\n+        if ((attr != NULL) && (attr->type != XML_ATTRIBUTE_DECL)) {\n+                \/* different instance, destroy it (attributes must be unique) *\/\n+                xmlRemoveProp((xmlAttrPtr) attr);\n+        }\n+        return prop;\n@@ -3032,1 +3043,1 @@\n-        \"xmlAddNextSibling : cur == NULL\\n\");\n+                \"xmlAddNextSibling : cur == NULL\\n\");\n@@ -3034,1 +3045,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3039,1 +3050,1 @@\n-        \"xmlAddNextSibling : elem == NULL\\n\");\n+                \"xmlAddNextSibling : elem == NULL\\n\");\n@@ -3041,1 +3052,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3047,1 +3058,1 @@\n-        \"xmlAddNextSibling : cur == elem\\n\");\n+                \"xmlAddNextSibling : cur == elem\\n\");\n@@ -3049,1 +3060,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3055,6 +3066,6 @@\n-    if (cur->type == XML_TEXT_NODE) {\n-        xmlNodeAddContent(cur, elem->content);\n-        xmlFreeNode(elem);\n-        return(cur);\n-    }\n-    if ((cur->next != NULL) && (cur->next->type == XML_TEXT_NODE) &&\n+        if (cur->type == XML_TEXT_NODE) {\n+            xmlNodeAddContent(cur, elem->content);\n+            xmlFreeNode(elem);\n+            return(cur);\n+        }\n+        if ((cur->next != NULL) && (cur->next->type == XML_TEXT_NODE) &&\n@@ -3062,1 +3073,1 @@\n-        xmlChar *tmp;\n+            xmlChar *tmp;\n@@ -3064,7 +3075,7 @@\n-        tmp = xmlStrdup(elem->content);\n-        tmp = xmlStrcat(tmp, cur->next->content);\n-        xmlNodeSetContent(cur->next, tmp);\n-        xmlFree(tmp);\n-        xmlFreeNode(elem);\n-        return(cur->next);\n-    }\n+            tmp = xmlStrdup(elem->content);\n+            tmp = xmlStrcat(tmp, cur->next->content);\n+            xmlNodeSetContent(cur->next, tmp);\n+            xmlFree(tmp);\n+            xmlFreeNode(elem);\n+            return(cur->next);\n+        }\n@@ -3072,1 +3083,1 @@\n-        return xmlAddPropSibling(cur, cur, elem);\n+                return xmlAddPropSibling(cur, cur, elem);\n@@ -3076,1 +3087,1 @@\n-    xmlSetTreeDoc(elem, cur->doc);\n+        xmlSetTreeDoc(elem, cur->doc);\n@@ -3083,1 +3094,1 @@\n-    elem->next->prev = elem;\n+        elem->next->prev = elem;\n@@ -3085,1 +3096,1 @@\n-    elem->parent->last = elem;\n+        elem->parent->last = elem;\n@@ -3110,1 +3121,1 @@\n-        \"xmlAddPrevSibling : cur == NULL\\n\");\n+                \"xmlAddPrevSibling : cur == NULL\\n\");\n@@ -3112,1 +3123,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3117,1 +3128,1 @@\n-        \"xmlAddPrevSibling : elem == NULL\\n\");\n+                \"xmlAddPrevSibling : elem == NULL\\n\");\n@@ -3119,1 +3130,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3125,1 +3136,1 @@\n-        \"xmlAddPrevSibling : cur == elem\\n\");\n+                \"xmlAddPrevSibling : cur == elem\\n\");\n@@ -3127,1 +3138,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3133,11 +3144,11 @@\n-    if (cur->type == XML_TEXT_NODE) {\n-        xmlChar *tmp;\n-\n-        tmp = xmlStrdup(elem->content);\n-        tmp = xmlStrcat(tmp, cur->content);\n-        xmlNodeSetContent(cur, tmp);\n-        xmlFree(tmp);\n-        xmlFreeNode(elem);\n-        return(cur);\n-    }\n-    if ((cur->prev != NULL) && (cur->prev->type == XML_TEXT_NODE) &&\n+        if (cur->type == XML_TEXT_NODE) {\n+            xmlChar *tmp;\n+\n+            tmp = xmlStrdup(elem->content);\n+            tmp = xmlStrcat(tmp, cur->content);\n+            xmlNodeSetContent(cur, tmp);\n+            xmlFree(tmp);\n+            xmlFreeNode(elem);\n+            return(cur);\n+        }\n+        if ((cur->prev != NULL) && (cur->prev->type == XML_TEXT_NODE) &&\n@@ -3145,4 +3156,4 @@\n-        xmlNodeAddContent(cur->prev, elem->content);\n-        xmlFreeNode(elem);\n-        return(cur->prev);\n-    }\n+            xmlNodeAddContent(cur->prev, elem->content);\n+            xmlFreeNode(elem);\n+            return(cur->prev);\n+        }\n@@ -3150,1 +3161,1 @@\n-        return xmlAddPropSibling(cur->prev, cur, elem);\n+                return xmlAddPropSibling(cur->prev, cur, elem);\n@@ -3154,1 +3165,1 @@\n-    xmlSetTreeDoc(elem, cur->doc);\n+        xmlSetTreeDoc(elem, cur->doc);\n@@ -3161,1 +3172,1 @@\n-    elem->prev->next = elem;\n+        elem->prev->next = elem;\n@@ -3163,1 +3174,1 @@\n-        elem->parent->children = elem;\n+                elem->parent->children = elem;\n@@ -3188,1 +3199,1 @@\n-        \"xmlAddSibling : cur == NULL\\n\");\n+                \"xmlAddSibling : cur == NULL\\n\");\n@@ -3190,1 +3201,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3196,1 +3207,1 @@\n-        \"xmlAddSibling : elem == NULL\\n\");\n+                \"xmlAddSibling : elem == NULL\\n\");\n@@ -3198,1 +3209,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3204,1 +3215,1 @@\n-        \"xmlAddSibling : cur == elem\\n\");\n+                \"xmlAddSibling : cur == elem\\n\");\n@@ -3206,1 +3217,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3214,4 +3225,4 @@\n-    (cur->parent->children != NULL) &&\n-    (cur->parent->last != NULL) &&\n-    (cur->parent->last->next == NULL)) {\n-    cur = cur->parent->last;\n+        (cur->parent->children != NULL) &&\n+        (cur->parent->last != NULL) &&\n+        (cur->parent->last->next == NULL)) {\n+        cur = cur->parent->last;\n@@ -3219,1 +3230,1 @@\n-    while (cur->next != NULL) cur = cur->next;\n+        while (cur->next != NULL) cur = cur->next;\n@@ -3226,3 +3237,3 @@\n-    xmlNodeAddContent(cur, elem->content);\n-    xmlFreeNode(elem);\n-    return(cur);\n+        xmlNodeAddContent(cur, elem->content);\n+        xmlFreeNode(elem);\n+        return(cur);\n@@ -3230,1 +3241,1 @@\n-        return xmlAddPropSibling(cur, cur, elem);\n+                return xmlAddPropSibling(cur, cur, elem);\n@@ -3234,1 +3245,1 @@\n-    xmlSetTreeDoc(elem, cur->doc);\n+        xmlSetTreeDoc(elem, cur->doc);\n@@ -3242,1 +3253,1 @@\n-    parent->last = elem;\n+        parent->last = elem;\n@@ -3264,1 +3275,1 @@\n-        \"xmlAddChildList : parent == NULL\\n\");\n+                \"xmlAddChildList : parent == NULL\\n\");\n@@ -3266,1 +3277,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3272,1 +3283,1 @@\n-        \"xmlAddChildList : child == NULL\\n\");\n+                \"xmlAddChildList : child == NULL\\n\");\n@@ -3274,1 +3285,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3280,2 +3291,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"Elements moved to a different document\\n\");\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"Elements moved to a different document\\n\");\n@@ -3292,7 +3303,0 @@\n-    \/*\n-     * If cur and parent->last both are TEXT nodes, then merge them.\n-     *\/\n-    if ((cur->type == XML_TEXT_NODE) &&\n-        (parent->last->type == XML_TEXT_NODE) &&\n-        (cur->name == parent->last->name)) {\n-        xmlNodeAddContent(parent->last, cur->content);\n@@ -3300,1 +3304,1 @@\n-         * if it's the only child, nothing more to be done.\n+         * If cur and parent->last both are TEXT nodes, then merge them.\n@@ -3302,3 +3306,14 @@\n-        if (cur->next == NULL) {\n-        xmlFreeNode(cur);\n-        return(parent->last);\n+        if ((cur->type == XML_TEXT_NODE) &&\n+            (parent->last->type == XML_TEXT_NODE) &&\n+            (cur->name == parent->last->name)) {\n+            xmlNodeAddContent(parent->last, cur->content);\n+            \/*\n+             * if it's the only child, nothing more to be done.\n+             *\/\n+            if (cur->next == NULL) {\n+                xmlFreeNode(cur);\n+                return(parent->last);\n+            }\n+            prev = cur;\n+            cur = cur->next;\n+            xmlFreeNode(prev);\n@@ -3306,4 +3321,0 @@\n-        prev = cur;\n-        cur = cur->next;\n-        xmlFreeNode(prev);\n-    }\n@@ -3311,2 +3322,2 @@\n-    prev->next = cur;\n-    cur->prev = prev;\n+        prev->next = cur;\n+        cur->prev = prev;\n@@ -3315,4 +3326,4 @@\n-    cur->parent = parent;\n-    if (cur->doc != parent->doc) {\n-        xmlSetTreeDoc(cur, parent->doc);\n-    }\n+        cur->parent = parent;\n+        if (cur->doc != parent->doc) {\n+            xmlSetTreeDoc(cur, parent->doc);\n+        }\n@@ -3350,1 +3361,1 @@\n-        \"xmlAddChild : parent == NULL\\n\");\n+                \"xmlAddChild : parent == NULL\\n\");\n@@ -3352,1 +3363,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3358,1 +3369,1 @@\n-        \"xmlAddChild : child == NULL\\n\");\n+                \"xmlAddChild : child == NULL\\n\");\n@@ -3360,1 +3371,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3366,1 +3377,1 @@\n-        \"xmlAddChild : parent == cur\\n\");\n+                \"xmlAddChild : parent == cur\\n\");\n@@ -3368,1 +3379,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3375,14 +3386,14 @@\n-    if ((parent->type == XML_TEXT_NODE) &&\n-        (parent->content != NULL) &&\n-        (parent->name == cur->name)) {\n-        xmlNodeAddContent(parent, cur->content);\n-        xmlFreeNode(cur);\n-        return(parent);\n-    }\n-    if ((parent->last != NULL) && (parent->last->type == XML_TEXT_NODE) &&\n-        (parent->last->name == cur->name) &&\n-        (parent->last != cur)) {\n-        xmlNodeAddContent(parent->last, cur->content);\n-        xmlFreeNode(cur);\n-        return(parent->last);\n-    }\n+        if ((parent->type == XML_TEXT_NODE) &&\n+            (parent->content != NULL) &&\n+            (parent->name == cur->name)) {\n+            xmlNodeAddContent(parent, cur->content);\n+            xmlFreeNode(cur);\n+            return(parent);\n+        }\n+        if ((parent->last != NULL) && (parent->last->type == XML_TEXT_NODE) &&\n+            (parent->last->name == cur->name) &&\n+            (parent->last != cur)) {\n+            xmlNodeAddContent(parent->last, cur->content);\n+            xmlFreeNode(cur);\n+            return(parent->last);\n+        }\n@@ -3397,1 +3408,1 @@\n-    xmlSetTreeDoc(cur, parent->doc);\n+        xmlSetTreeDoc(cur, parent->doc);\n@@ -3403,1 +3414,1 @@\n-    return(cur);\n+        return(cur);\n@@ -3409,5 +3420,5 @@\n-    (parent->content != NULL) &&\n-    (parent != cur)) {\n-    xmlNodeAddContent(parent, cur->content);\n-    xmlFreeNode(cur);\n-    return(parent);\n+        (parent->content != NULL) &&\n+        (parent != cur)) {\n+        xmlNodeAddContent(parent, cur->content);\n+        xmlFreeNode(cur);\n+        return(parent);\n@@ -3416,5 +3427,17 @@\n-        if (parent->type != XML_ELEMENT_NODE)\n-            return(NULL);\n-    if (parent->properties != NULL) {\n-        \/* check if an attribute with the same name exists *\/\n-        xmlAttrPtr lastattr;\n+                if (parent->type != XML_ELEMENT_NODE)\n+                        return(NULL);\n+        if (parent->properties != NULL) {\n+            \/* check if an attribute with the same name exists *\/\n+            xmlAttrPtr lastattr;\n+\n+            if (cur->ns == NULL)\n+                lastattr = xmlHasNsProp(parent, cur->name, NULL);\n+            else\n+                lastattr = xmlHasNsProp(parent, cur->name, cur->ns->href);\n+            if ((lastattr != NULL) && (lastattr != (xmlAttrPtr) cur) && (lastattr->type != XML_ATTRIBUTE_DECL)) {\n+                \/* different instance, destroy it (attributes must be unique) *\/\n+                        xmlUnlinkNode((xmlNodePtr) lastattr);\n+                xmlFreeProp(lastattr);\n+            }\n+                if (lastattr == (xmlAttrPtr) cur)\n+                        return(cur);\n@@ -3422,8 +3445,0 @@\n-        if (cur->ns == NULL)\n-        lastattr = xmlHasNsProp(parent, cur->name, NULL);\n-        else\n-        lastattr = xmlHasNsProp(parent, cur->name, cur->ns->href);\n-        if ((lastattr != NULL) && (lastattr != (xmlAttrPtr) cur) && (lastattr->type != XML_ATTRIBUTE_DECL)) {\n-        \/* different instance, destroy it (attributes must be unique) *\/\n-            xmlUnlinkNode((xmlNodePtr) lastattr);\n-        xmlFreeProp(lastattr);\n@@ -3431,11 +3446,10 @@\n-        if (lastattr == (xmlAttrPtr) cur)\n-            return(cur);\n-\n-    }\n-    if (parent->properties == NULL) {\n-        parent->properties = (xmlAttrPtr) cur;\n-    } else {\n-        \/* find the end *\/\n-        xmlAttrPtr lastattr = parent->properties;\n-        while (lastattr->next != NULL) {\n-        lastattr = lastattr->next;\n+        if (parent->properties == NULL) {\n+            parent->properties = (xmlAttrPtr) cur;\n+        } else {\n+            \/* find the end *\/\n+            xmlAttrPtr lastattr = parent->properties;\n+            while (lastattr->next != NULL) {\n+                lastattr = lastattr->next;\n+            }\n+            lastattr->next = (xmlAttrPtr) cur;\n+            ((xmlAttrPtr) cur)->prev = lastattr;\n@@ -3443,7 +3457,0 @@\n-        lastattr->next = (xmlAttrPtr) cur;\n-        ((xmlAttrPtr) cur)->prev = lastattr;\n-    }\n-    } else {\n-    if (parent->children == NULL) {\n-        parent->children = cur;\n-        parent->last = cur;\n@@ -3451,5 +3458,9 @@\n-        prev = parent->last;\n-        prev->next = cur;\n-        cur->prev = prev;\n-        parent->last = cur;\n-    }\n+        if (parent->children == NULL) {\n+            parent->children = cur;\n+            parent->last = cur;\n+        } else {\n+            prev = parent->last;\n+            prev->next = cur;\n+            cur->prev = prev;\n+            parent->last = cur;\n+        }\n@@ -3472,1 +3483,1 @@\n-        \"xmlGetLastChild : parent == NULL\\n\");\n+                \"xmlGetLastChild : parent == NULL\\n\");\n@@ -3474,1 +3485,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3691,10 +3702,2 @@\n-    xmlFreeNsList((xmlNsPtr) cur);\n-    return;\n-    }\n-    if ((cur->type == XML_DOCUMENT_NODE) ||\n-#ifdef LIBXML_DOCB_ENABLED\n-    (cur->type == XML_DOCB_DOCUMENT_NODE) ||\n-#endif\n-    (cur->type == XML_HTML_DOCUMENT_NODE)) {\n-    xmlFreeDoc((xmlDocPtr) cur);\n-    return;\n+        xmlFreeNsList((xmlNsPtr) cur);\n+        return;\n@@ -3705,0 +3708,5 @@\n+               (cur->type != XML_DOCUMENT_NODE) &&\n+#ifdef LIBXML_DOCB_ENABLED\n+               (cur->type != XML_DOCB_DOCUMENT_NODE) &&\n+#endif\n+               (cur->type != XML_HTML_DOCUMENT_NODE) &&\n@@ -3713,15 +3721,1 @@\n-    if (cur->type != XML_DTD_NODE) {\n-\n-        if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n-        xmlDeregisterNodeDefaultValue(cur);\n-\n-        if (((cur->type == XML_ELEMENT_NODE) ||\n-         (cur->type == XML_XINCLUDE_START) ||\n-         (cur->type == XML_XINCLUDE_END)) &&\n-        (cur->properties != NULL))\n-        xmlFreePropList(cur->properties);\n-        if ((cur->type != XML_ELEMENT_NODE) &&\n-        (cur->type != XML_XINCLUDE_START) &&\n-        (cur->type != XML_XINCLUDE_END) &&\n-        (cur->type != XML_ENTITY_REF_NODE) &&\n-        (cur->type != XML_DOCUMENT_NODE) &&\n+        if ((cur->type == XML_DOCUMENT_NODE) ||\n@@ -3729,1 +3723,1 @@\n-        (cur->type != XML_DOCB_DOCUMENT_NODE) &&\n+            (cur->type == XML_DOCB_DOCUMENT_NODE) ||\n@@ -3731,9 +3725,24 @@\n-        (cur->type != XML_HTML_DOCUMENT_NODE) &&\n-        (cur->content != (xmlChar *) &(cur->properties))) {\n-        DICT_FREE(cur->content)\n-        }\n-        if (((cur->type == XML_ELEMENT_NODE) ||\n-             (cur->type == XML_XINCLUDE_START) ||\n-         (cur->type == XML_XINCLUDE_END)) &&\n-        (cur->nsDef != NULL))\n-        xmlFreeNsList(cur->nsDef);\n+            (cur->type == XML_HTML_DOCUMENT_NODE)) {\n+            xmlFreeDoc((xmlDocPtr) cur);\n+        } else if (cur->type != XML_DTD_NODE) {\n+\n+            if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n+                xmlDeregisterNodeDefaultValue(cur);\n+\n+            if (((cur->type == XML_ELEMENT_NODE) ||\n+                 (cur->type == XML_XINCLUDE_START) ||\n+                 (cur->type == XML_XINCLUDE_END)) &&\n+                (cur->properties != NULL))\n+                xmlFreePropList(cur->properties);\n+            if ((cur->type != XML_ELEMENT_NODE) &&\n+                (cur->type != XML_XINCLUDE_START) &&\n+                (cur->type != XML_XINCLUDE_END) &&\n+                (cur->type != XML_ENTITY_REF_NODE) &&\n+                (cur->content != (xmlChar *) &(cur->properties))) {\n+                DICT_FREE(cur->content)\n+            }\n+            if (((cur->type == XML_ELEMENT_NODE) ||\n+                 (cur->type == XML_XINCLUDE_START) ||\n+                 (cur->type == XML_XINCLUDE_END)) &&\n+                (cur->nsDef != NULL))\n+                xmlFreeNsList(cur->nsDef);\n@@ -3741,12 +3750,12 @@\n-        \/*\n-         * When a node is a text node or a comment, it uses a global static\n-         * variable for the name of the node.\n-         * Otherwise the node name might come from the document's\n-         * dictionary\n-         *\/\n-        if ((cur->name != NULL) &&\n-        (cur->type != XML_TEXT_NODE) &&\n-        (cur->type != XML_COMMENT_NODE))\n-        DICT_FREE(cur->name)\n-        xmlFree(cur);\n-    }\n+            \/*\n+             * When a node is a text node or a comment, it uses a global static\n+             * variable for the name of the node.\n+             * Otherwise the node name might come from the document's\n+             * dictionary\n+             *\/\n+            if ((cur->name != NULL) &&\n+                (cur->type != XML_TEXT_NODE) &&\n+                (cur->type != XML_COMMENT_NODE))\n+                DICT_FREE(cur->name)\n+            xmlFree(cur);\n+        }\n@@ -3755,1 +3764,1 @@\n-        cur = next;\n+            cur = next;\n@@ -3781,2 +3790,2 @@\n-    xmlFreeDtd((xmlDtdPtr) cur);\n-    return;\n+        xmlFreeDtd((xmlDtdPtr) cur);\n+        return;\n@@ -3785,1 +3794,1 @@\n-    xmlFreeNs((xmlNsPtr) cur);\n+        xmlFreeNs((xmlNsPtr) cur);\n@@ -3789,2 +3798,2 @@\n-    xmlFreeProp((xmlAttrPtr) cur);\n-    return;\n+        xmlFreeProp((xmlAttrPtr) cur);\n+        return;\n@@ -3794,1 +3803,1 @@\n-    xmlDeregisterNodeDefaultValue(cur);\n+        xmlDeregisterNodeDefaultValue(cur);\n@@ -3800,2 +3809,2 @@\n-    DICT_FREE(ent->SystemID);\n-    DICT_FREE(ent->ExternalID);\n+        DICT_FREE(ent->SystemID);\n+        DICT_FREE(ent->ExternalID);\n@@ -3804,2 +3813,2 @@\n-    (cur->type != XML_ENTITY_REF_NODE))\n-    xmlFreeNodeList(cur->children);\n+        (cur->type != XML_ENTITY_REF_NODE))\n+        xmlFreeNodeList(cur->children);\n@@ -3807,4 +3816,4 @@\n-     (cur->type == XML_XINCLUDE_START) ||\n-     (cur->type == XML_XINCLUDE_END)) &&\n-    (cur->properties != NULL))\n-    xmlFreePropList(cur->properties);\n+         (cur->type == XML_XINCLUDE_START) ||\n+         (cur->type == XML_XINCLUDE_END)) &&\n+        (cur->properties != NULL))\n+        xmlFreePropList(cur->properties);\n@@ -3812,6 +3821,6 @@\n-    (cur->content != NULL) &&\n-    (cur->type != XML_ENTITY_REF_NODE) &&\n-    (cur->type != XML_XINCLUDE_END) &&\n-    (cur->type != XML_XINCLUDE_START) &&\n-    (cur->content != (xmlChar *) &(cur->properties))) {\n-    DICT_FREE(cur->content)\n+        (cur->content != NULL) &&\n+        (cur->type != XML_ENTITY_REF_NODE) &&\n+        (cur->type != XML_XINCLUDE_END) &&\n+        (cur->type != XML_XINCLUDE_START) &&\n+        (cur->content != (xmlChar *) &(cur->properties))) {\n+        DICT_FREE(cur->content)\n@@ -3828,1 +3837,1 @@\n-    DICT_FREE(cur->name)\n+        DICT_FREE(cur->name)\n@@ -3831,4 +3840,4 @@\n-     (cur->type == XML_XINCLUDE_START) ||\n-     (cur->type == XML_XINCLUDE_END)) &&\n-    (cur->nsDef != NULL))\n-    xmlFreeNsList(cur->nsDef);\n+         (cur->type == XML_XINCLUDE_START) ||\n+         (cur->type == XML_XINCLUDE_END)) &&\n+        (cur->nsDef != NULL))\n+        xmlFreeNsList(cur->nsDef);\n@@ -3853,1 +3862,1 @@\n-        \"xmlUnlinkNode : node == NULL\\n\");\n+                \"xmlUnlinkNode : node == NULL\\n\");\n@@ -3855,1 +3864,1 @@\n-    return;\n+        return;\n@@ -3860,8 +3869,8 @@\n-    xmlDocPtr doc;\n-    doc = cur->doc;\n-    if (doc != NULL) {\n-        if (doc->intSubset == (xmlDtdPtr) cur)\n-        doc->intSubset = NULL;\n-        if (doc->extSubset == (xmlDtdPtr) cur)\n-        doc->extSubset = NULL;\n-    }\n+        xmlDocPtr doc;\n+        doc = cur->doc;\n+        if (doc != NULL) {\n+            if (doc->intSubset == (xmlDtdPtr) cur)\n+                doc->intSubset = NULL;\n+            if (doc->extSubset == (xmlDtdPtr) cur)\n+                doc->extSubset = NULL;\n+        }\n@@ -3871,17 +3880,18 @@\n-    doc = cur->doc;\n-    if (doc != NULL) {\n-        if (doc->intSubset != NULL) {\n-            if (xmlHashLookup(doc->intSubset->entities, cur->name) == cur)\n-            xmlHashRemoveEntry(doc->intSubset->entities, cur->name,\n-                               NULL);\n-            if (xmlHashLookup(doc->intSubset->pentities, cur->name) == cur)\n-            xmlHashRemoveEntry(doc->intSubset->pentities, cur->name,\n-                               NULL);\n-        }\n-        if (doc->extSubset != NULL) {\n-            if (xmlHashLookup(doc->extSubset->entities, cur->name) == cur)\n-            xmlHashRemoveEntry(doc->extSubset->entities, cur->name,\n-                               NULL);\n-            if (xmlHashLookup(doc->extSubset->pentities, cur->name) == cur)\n-            xmlHashRemoveEntry(doc->extSubset->pentities, cur->name,\n-                               NULL);\n+        doc = cur->doc;\n+        if (doc != NULL) {\n+            if (doc->intSubset != NULL) {\n+                if (xmlHashLookup(doc->intSubset->entities, cur->name) == cur)\n+                    xmlHashRemoveEntry(doc->intSubset->entities, cur->name,\n+                                       NULL);\n+                if (xmlHashLookup(doc->intSubset->pentities, cur->name) == cur)\n+                    xmlHashRemoveEntry(doc->intSubset->pentities, cur->name,\n+                                       NULL);\n+            }\n+            if (doc->extSubset != NULL) {\n+                if (xmlHashLookup(doc->extSubset->entities, cur->name) == cur)\n+                    xmlHashRemoveEntry(doc->extSubset->entities, cur->name,\n+                                       NULL);\n+                if (xmlHashLookup(doc->extSubset->pentities, cur->name) == cur)\n+                    xmlHashRemoveEntry(doc->extSubset->pentities, cur->name,\n+                                       NULL);\n+            }\n@@ -3890,1 +3900,0 @@\n-    }\n@@ -3892,12 +3901,12 @@\n-    xmlNodePtr parent;\n-    parent = cur->parent;\n-    if (cur->type == XML_ATTRIBUTE_NODE) {\n-        if (parent->properties == (xmlAttrPtr) cur)\n-        parent->properties = ((xmlAttrPtr) cur)->next;\n-    } else {\n-        if (parent->children == cur)\n-        parent->children = cur->next;\n-        if (parent->last == cur)\n-        parent->last = cur->prev;\n-    }\n-    cur->parent = NULL;\n+        xmlNodePtr parent;\n+        parent = cur->parent;\n+        if (cur->type == XML_ATTRIBUTE_NODE) {\n+            if (parent->properties == (xmlAttrPtr) cur)\n+                parent->properties = ((xmlAttrPtr) cur)->next;\n+        } else {\n+            if (parent->children == cur)\n+                parent->children = cur->next;\n+            if (parent->last == cur)\n+                parent->last = cur->prev;\n+        }\n+        cur->parent = NULL;\n@@ -3931,1 +3940,1 @@\n-        \"xmlReplaceNode : old == NULL or without parent\\n\");\n+                \"xmlReplaceNode : old == NULL or without parent\\n\");\n@@ -3933,1 +3942,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3936,2 +3945,2 @@\n-    xmlUnlinkNode(old);\n-    return(old);\n+        xmlUnlinkNode(old);\n+        return(old);\n@@ -3940,1 +3949,1 @@\n-    return(old);\n+        return(old);\n@@ -3945,1 +3954,1 @@\n-        \"xmlReplaceNode : Trying to replace attribute node with other node type\\n\");\n+                \"xmlReplaceNode : Trying to replace attribute node with other node type\\n\");\n@@ -3947,1 +3956,1 @@\n-    return(old);\n+        return(old);\n@@ -3952,1 +3961,1 @@\n-        \"xmlReplaceNode : Trying to replace a non-attribute node with attribute node\\n\");\n+                \"xmlReplaceNode : Trying to replace a non-attribute node with attribute node\\n\");\n@@ -3954,1 +3963,1 @@\n-    return(old);\n+        return(old);\n@@ -3961,1 +3970,1 @@\n-    cur->next->prev = cur;\n+        cur->next->prev = cur;\n@@ -3964,1 +3973,1 @@\n-    cur->prev->next = cur;\n+        cur->prev->next = cur;\n@@ -3966,9 +3975,9 @@\n-    if (cur->type == XML_ATTRIBUTE_NODE) {\n-        if (cur->parent->properties == (xmlAttrPtr)old)\n-        cur->parent->properties = ((xmlAttrPtr) cur);\n-    } else {\n-        if (cur->parent->children == old)\n-        cur->parent->children = cur;\n-        if (cur->parent->last == old)\n-        cur->parent->last = cur;\n-    }\n+        if (cur->type == XML_ATTRIBUTE_NODE) {\n+            if (cur->parent->properties == (xmlAttrPtr)old)\n+                cur->parent->properties = ((xmlAttrPtr) cur);\n+        } else {\n+            if (cur->parent->children == old)\n+                cur->parent->children = cur;\n+            if (cur->parent->last == old)\n+                cur->parent->last = cur;\n+        }\n@@ -3983,3 +3992,3 @@\n- *                                  *\n- *      Copy operations                     *\n- *                                  *\n+ *                                                                      *\n+ *              Copy operations                                         *\n+ *                                                                      *\n@@ -4002,4 +4011,4 @@\n-    case XML_LOCAL_NAMESPACE:\n-        ret = xmlNewNs(NULL, cur->href, cur->prefix);\n-        break;\n-    default:\n+        case XML_LOCAL_NAMESPACE:\n+            ret = xmlNewNs(NULL, cur->href, cur->prefix);\n+            break;\n+        default:\n@@ -4007,2 +4016,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"xmlCopyNamespace: invalid type %d\\n\", cur->type);\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"xmlCopyNamespace: invalid type %d\\n\", cur->type);\n@@ -4010,1 +4019,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -4030,7 +4039,7 @@\n-    if (p == NULL) {\n-        ret = p = q;\n-    } else {\n-        p->next = q;\n-        p = q;\n-    }\n-    cur = cur->next;\n+        if (p == NULL) {\n+            ret = p = q;\n+        } else {\n+            p->next = q;\n+            p = q;\n+        }\n+        cur = cur->next;\n@@ -4052,1 +4061,1 @@\n-    ret = xmlNewDocProp(target->doc, cur->name, NULL);\n+        ret = xmlNewDocProp(target->doc, cur->name, NULL);\n@@ -4054,1 +4063,1 @@\n-    ret = xmlNewDocProp(doc, cur->name, NULL);\n+        ret = xmlNewDocProp(doc, cur->name, NULL);\n@@ -4056,1 +4065,1 @@\n-    ret = xmlNewDocProp(cur->parent->doc, cur->name, NULL);\n+        ret = xmlNewDocProp(cur->parent->doc, cur->name, NULL);\n@@ -4058,1 +4067,1 @@\n-    ret = xmlNewDocProp(cur->children->doc, cur->name, NULL);\n+        ret = xmlNewDocProp(cur->children->doc, cur->name, NULL);\n@@ -4060,1 +4069,1 @@\n-    ret = xmlNewDocProp(NULL, cur->name, NULL);\n+        ret = xmlNewDocProp(NULL, cur->name, NULL);\n@@ -4111,1 +4120,1 @@\n-    xmlNodePtr tmp;\n+        xmlNodePtr tmp;\n@@ -4113,9 +4122,9 @@\n-    ret->children = xmlStaticCopyNodeList(cur->children, ret->doc, (xmlNodePtr) ret);\n-    ret->last = NULL;\n-    tmp = ret->children;\n-    while (tmp != NULL) {\n-        \/* tmp->parent = (xmlNodePtr)ret; *\/\n-        if (tmp->next == NULL)\n-            ret->last = tmp;\n-        tmp = tmp->next;\n-    }\n+        ret->children = xmlStaticCopyNodeList(cur->children, ret->doc, (xmlNodePtr) ret);\n+        ret->last = NULL;\n+        tmp = ret->children;\n+        while (tmp != NULL) {\n+            \/* tmp->parent = (xmlNodePtr)ret; *\/\n+            if (tmp->next == NULL)\n+                ret->last = tmp;\n+            tmp = tmp->next;\n+        }\n@@ -4127,9 +4136,10 @@\n-    (target->doc != NULL) && (cur->doc != NULL) &&\n-    (cur->doc->ids != NULL) && (cur->parent != NULL)) {\n-    if (xmlIsID(cur->doc, cur->parent, cur)) {\n-        xmlChar *id;\n-\n-        id = xmlNodeListGetString(cur->doc, cur->children, 1);\n-        if (id != NULL) {\n-        xmlAddID(NULL, target->doc, id, ret);\n-        xmlFree(id);\n+        (target->doc != NULL) && (cur->doc != NULL) &&\n+        (cur->doc->ids != NULL) && (cur->parent != NULL)) {\n+        if (xmlIsID(cur->doc, cur->parent, cur)) {\n+            xmlChar *id;\n+\n+            id = xmlNodeListGetString(cur->doc, cur->children, 1);\n+            if (id != NULL) {\n+                xmlAddID(NULL, target->doc, id, ret);\n+                xmlFree(id);\n+            }\n@@ -4138,1 +4148,0 @@\n-    }\n@@ -4153,1 +4162,1 @@\n-    return xmlCopyPropInternal(NULL, target, cur);\n+        return xmlCopyPropInternal(NULL, target, cur);\n@@ -4174,10 +4183,10 @@\n-    if (q == NULL)\n-        return(NULL);\n-    if (p == NULL) {\n-        ret = p = q;\n-    } else {\n-        p->next = q;\n-        q->prev = p;\n-        p = q;\n-    }\n-    cur = cur->next;\n+        if (q == NULL)\n+            return(NULL);\n+        if (p == NULL) {\n+            ret = p = q;\n+        } else {\n+            p->next = q;\n+            q->prev = p;\n+            p = q;\n+        }\n+        cur = cur->next;\n@@ -4224,1 +4233,1 @@\n-        break;\n+            break;\n@@ -4226,1 +4235,1 @@\n-        return((xmlNodePtr) xmlCopyPropInternal(doc, parent, (xmlAttrPtr) node));\n+                return((xmlNodePtr) xmlCopyPropInternal(doc, parent, (xmlAttrPtr) node));\n@@ -4228,1 +4237,1 @@\n-        return((xmlNodePtr) xmlCopyNamespaceList((xmlNsPtr) node));\n+            return((xmlNodePtr) xmlCopyNamespaceList((xmlNsPtr) node));\n@@ -4236,1 +4245,1 @@\n-        return((xmlNodePtr) xmlCopyDoc((xmlDocPtr) node, extended));\n+            return((xmlNodePtr) xmlCopyDoc((xmlDocPtr) node, extended));\n@@ -4252,2 +4261,2 @@\n-    xmlTreeErrMemory(\"copying node\");\n-    return(NULL);\n+        xmlTreeErrMemory(\"copying node\");\n+        return(NULL);\n@@ -4261,1 +4270,1 @@\n-    ret->name = xmlStringText;\n+        ret->name = xmlStringText;\n@@ -4263,1 +4272,1 @@\n-    ret->name = xmlStringTextNoenc;\n+        ret->name = xmlStringTextNoenc;\n@@ -4265,1 +4274,1 @@\n-    ret->name = xmlStringComment;\n+        ret->name = xmlStringComment;\n@@ -4268,3 +4277,3 @@\n-        ret->name = xmlDictLookup(doc->dict, node->name, -1);\n-    else\n-        ret->name = xmlStrdup(node->name);\n+            ret->name = xmlDictLookup(doc->dict, node->name, -1);\n+        else\n+            ret->name = xmlStrdup(node->name);\n@@ -4273,5 +4282,5 @@\n-    (node->content != NULL) &&\n-    (node->type != XML_ENTITY_REF_NODE) &&\n-    (node->type != XML_XINCLUDE_END) &&\n-    (node->type != XML_XINCLUDE_START)) {\n-    ret->content = xmlStrdup(node->content);\n+        (node->content != NULL) &&\n+        (node->type != XML_ENTITY_REF_NODE) &&\n+        (node->type != XML_XINCLUDE_END) &&\n+        (node->type != XML_XINCLUDE_START)) {\n+        ret->content = xmlStrdup(node->content);\n@@ -4283,1 +4292,1 @@\n-    xmlNodePtr tmp;\n+        xmlNodePtr tmp;\n@@ -4285,7 +4294,7 @@\n-    \/*\n-     * this is a tricky part for the node register thing:\n-     * in case ret does get coalesced in xmlAddChild\n-     * the deregister-node callback is called; so we register ret now already\n-     *\/\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-        xmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n+        \/*\n+         * this is a tricky part for the node register thing:\n+         * in case ret does get coalesced in xmlAddChild\n+         * the deregister-node callback is called; so we register ret now already\n+         *\/\n+        if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+            xmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n@@ -4294,3 +4303,3 @@\n-    \/* node could have coalesced *\/\n-    if (tmp != ret)\n-        return(tmp);\n+        \/* node could have coalesced *\/\n+        if (tmp != ret)\n+            return(tmp);\n@@ -4300,1 +4309,1 @@\n-    goto out;\n+        goto out;\n@@ -4308,10 +4317,10 @@\n-    ns = xmlSearchNs(doc, ret, node->ns->prefix);\n-    if (ns == NULL) {\n-        \/*\n-         * Humm, we are copying an element whose namespace is defined\n-         * out of the new tree scope. Search it in the original tree\n-         * and add it at the top of the new tree\n-         *\/\n-        ns = xmlSearchNs(node->doc, node, node->ns->prefix);\n-        if (ns != NULL) {\n-            xmlNodePtr root = ret;\n+        ns = xmlSearchNs(doc, ret, node->ns->prefix);\n+        if (ns == NULL) {\n+            \/*\n+             * Humm, we are copying an element whose namespace is defined\n+             * out of the new tree scope. Search it in the original tree\n+             * and add it at the top of the new tree\n+             *\/\n+            ns = xmlSearchNs(node->doc, node, node->ns->prefix);\n+            if (ns != NULL) {\n+                xmlNodePtr root = ret;\n@@ -4319,2 +4328,5 @@\n-        while (root->parent != NULL) root = root->parent;\n-        ret->ns = xmlNewNs(root, ns->href, ns->prefix);\n+                while (root->parent != NULL) root = root->parent;\n+                ret->ns = xmlNewNs(root, ns->href, ns->prefix);\n+                } else {\n+                        ret->ns = xmlNewReconciledNs(doc, ret, node->ns);\n+            }\n@@ -4322,1 +4334,4 @@\n-            ret->ns = xmlNewReconciledNs(doc, ret, node->ns);\n+            \/*\n+             * reference the existing namespace definition in our own tree.\n+             *\/\n+            ret->ns = ns;\n@@ -4324,6 +4339,0 @@\n-    } else {\n-        \/*\n-         * reference the existing namespace definition in our own tree.\n-         *\/\n-        ret->ns = ns;\n-    }\n@@ -4335,9 +4344,9 @@\n-    if ((doc == NULL) || (node->doc != doc)) {\n-        \/*\n-         * The copied node will go into a separate document, so\n-         * to avoid dangling references to the ENTITY_DECL node\n-         * we cannot keep the reference. Try to find it in the\n-         * target document.\n-         *\/\n-        ret->children = (xmlNodePtr) xmlGetDocEntity(doc, ret->name);\n-    } else {\n+        if ((doc == NULL) || (node->doc != doc)) {\n+            \/*\n+             * The copied node will go into a separate document, so\n+             * to avoid dangling references to the ENTITY_DECL node\n+             * we cannot keep the reference. Try to find it in the\n+             * target document.\n+             *\/\n+            ret->children = (xmlNodePtr) xmlGetDocEntity(doc, ret->name);\n+        } else {\n@@ -4345,2 +4354,2 @@\n-    }\n-    ret->last = ret->children;\n+        }\n+        ret->last = ret->children;\n@@ -4349,1 +4358,1 @@\n-    UPDATE_LAST_CHILD_AND_PARENT(ret)\n+        UPDATE_LAST_CHILD_AND_PARENT(ret)\n@@ -4356,1 +4365,1 @@\n-    xmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n+        xmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n@@ -4367,7 +4376,19 @@\n-    if (node->type == XML_DTD_NODE ) {\n-        if (doc == NULL) {\n-        node = node->next;\n-        continue;\n-        }\n-        if (doc->intSubset == NULL) {\n-        q = (xmlNodePtr) xmlCopyDtd( (xmlDtdPtr) node );\n+        if (node->type == XML_DTD_NODE ) {\n+            if (doc == NULL) {\n+                node = node->next;\n+                continue;\n+            }\n+            if (doc->intSubset == NULL) {\n+                q = (xmlNodePtr) xmlCopyDtd( (xmlDtdPtr) node );\n+                if (q == NULL) return(NULL);\n+                q->doc = doc;\n+                q->parent = parent;\n+                doc->intSubset = (xmlDtdPtr) q;\n+                xmlAddChild(parent, q);\n+            } else {\n+                q = (xmlNodePtr) doc->intSubset;\n+                xmlAddChild(parent, q);\n+            }\n+        } else\n+#endif \/* LIBXML_TREE_ENABLED *\/\n+            q = xmlStaticCopyNode(node, doc, parent, 1);\n@@ -4375,7 +4396,8 @@\n-        q->doc = doc;\n-        q->parent = parent;\n-        doc->intSubset = (xmlDtdPtr) q;\n-        xmlAddChild(parent, q);\n-        } else {\n-        q = (xmlNodePtr) doc->intSubset;\n-        xmlAddChild(parent, q);\n+        if (ret == NULL) {\n+            q->prev = NULL;\n+            ret = p = q;\n+        } else if (p != q) {\n+        \/* the test is required if xmlStaticCopyNode coalesced 2 text nodes *\/\n+            p->next = q;\n+            q->prev = p;\n+            p = q;\n@@ -4383,14 +4405,1 @@\n-    } else\n-#endif \/* LIBXML_TREE_ENABLED *\/\n-        q = xmlStaticCopyNode(node, doc, parent, 1);\n-    if (q == NULL) return(NULL);\n-    if (ret == NULL) {\n-        q->prev = NULL;\n-        ret = p = q;\n-    } else if (p != q) {\n-    \/* the test is required if xmlStaticCopyNode coalesced 2 text nodes *\/\n-        p->next = q;\n-        q->prev = p;\n-        p = q;\n-    }\n-    node = node->next;\n+        node = node->next;\n@@ -4405,2 +4414,2 @@\n- *          when applicable)\n- *      if 2 copy properties and namespaces (when applicable)\n+ *                      when applicable)\n+ *              if 2 copy properties and namespaces (when applicable)\n@@ -4425,2 +4434,2 @@\n- *          when applicable)\n- *      if 2 copy properties and namespaces (when applicable)\n+ *                      when applicable)\n+ *              if 2 copy properties and namespaces (when applicable)\n@@ -4487,1 +4496,1 @@\n-                        (xmlEntitiesTablePtr) dtd->entities);\n+                            (xmlEntitiesTablePtr) dtd->entities);\n@@ -4490,1 +4499,1 @@\n-                        (xmlNotationTablePtr) dtd->notations);\n+                            (xmlNotationTablePtr) dtd->notations);\n@@ -4493,1 +4502,1 @@\n-                        (xmlElementTablePtr) dtd->elements);\n+                            (xmlElementTablePtr) dtd->elements);\n@@ -4496,1 +4505,1 @@\n-                        (xmlAttributeTablePtr) dtd->attributes);\n+                            (xmlAttributeTablePtr) dtd->attributes);\n@@ -4498,2 +4507,2 @@\n-    ret->pentities = (void *) xmlCopyEntitiesTable(\n-                (xmlEntitiesTablePtr) dtd->pentities);\n+        ret->pentities = (void *) xmlCopyEntitiesTable(\n+                            (xmlEntitiesTablePtr) dtd->pentities);\n@@ -4503,12 +4512,20 @@\n-    q = NULL;\n-\n-    if (cur->type == XML_ENTITY_DECL) {\n-        xmlEntityPtr tmp = (xmlEntityPtr) cur;\n-        switch (tmp->etype) {\n-        case XML_INTERNAL_GENERAL_ENTITY:\n-        case XML_EXTERNAL_GENERAL_PARSED_ENTITY:\n-        case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:\n-            q = (xmlNodePtr) xmlGetEntityFromDtd(ret, tmp->name);\n-            break;\n-        case XML_INTERNAL_PARAMETER_ENTITY:\n-        case XML_EXTERNAL_PARAMETER_ENTITY:\n+        q = NULL;\n+\n+        if (cur->type == XML_ENTITY_DECL) {\n+            xmlEntityPtr tmp = (xmlEntityPtr) cur;\n+            switch (tmp->etype) {\n+                case XML_INTERNAL_GENERAL_ENTITY:\n+                case XML_EXTERNAL_GENERAL_PARSED_ENTITY:\n+                case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:\n+                    q = (xmlNodePtr) xmlGetEntityFromDtd(ret, tmp->name);\n+                    break;\n+                case XML_INTERNAL_PARAMETER_ENTITY:\n+                case XML_EXTERNAL_PARAMETER_ENTITY:\n+                    q = (xmlNodePtr)\n+                        xmlGetParameterEntityFromDtd(ret, tmp->name);\n+                    break;\n+                case XML_INTERNAL_PREDEFINED_ENTITY:\n+                    break;\n+            }\n+        } else if (cur->type == XML_ELEMENT_DECL) {\n+            xmlElementPtr tmp = (xmlElementPtr) cur;\n@@ -4516,4 +4533,7 @@\n-            xmlGetParameterEntityFromDtd(ret, tmp->name);\n-            break;\n-        case XML_INTERNAL_PREDEFINED_ENTITY:\n-            break;\n+                xmlGetDtdQElementDesc(ret, tmp->name, tmp->prefix);\n+        } else if (cur->type == XML_ATTRIBUTE_DECL) {\n+            xmlAttributePtr tmp = (xmlAttributePtr) cur;\n+            q = (xmlNodePtr)\n+                xmlGetDtdQAttrDesc(ret, tmp->elem, tmp->name, tmp->prefix);\n+        } else if (cur->type == XML_COMMENT_NODE) {\n+            q = xmlCopyNode(cur, 0);\n@@ -4521,11 +4541,0 @@\n-    } else if (cur->type == XML_ELEMENT_DECL) {\n-        xmlElementPtr tmp = (xmlElementPtr) cur;\n-        q = (xmlNodePtr)\n-        xmlGetDtdQElementDesc(ret, tmp->name, tmp->prefix);\n-    } else if (cur->type == XML_ATTRIBUTE_DECL) {\n-        xmlAttributePtr tmp = (xmlAttributePtr) cur;\n-        q = (xmlNodePtr)\n-        xmlGetDtdQAttrDesc(ret, tmp->elem, tmp->name, tmp->prefix);\n-    } else if (cur->type == XML_COMMENT_NODE) {\n-        q = xmlCopyNode(cur, 0);\n-    }\n@@ -4533,4 +4542,4 @@\n-    if (q == NULL) {\n-        cur = cur->next;\n-        continue;\n-    }\n+        if (q == NULL) {\n+            cur = cur->next;\n+            continue;\n+        }\n@@ -4538,4 +4547,4 @@\n-    if (p == NULL)\n-        ret->children = q;\n-    else\n-        p->next = q;\n+        if (p == NULL)\n+            ret->children = q;\n+        else\n+            p->next = q;\n@@ -4543,6 +4552,6 @@\n-    q->prev = p;\n-    q->parent = (xmlNodePtr) ret;\n-    q->next = NULL;\n-    ret->last = q;\n-    p = q;\n-    cur = cur->next;\n+        q->prev = p;\n+        q->parent = (xmlNodePtr) ret;\n+        q->next = NULL;\n+        ret->last = q;\n+        p = q;\n+        cur = cur->next;\n@@ -4590,6 +4599,6 @@\n-    if (ret->intSubset == NULL) {\n-        xmlFreeDoc(ret);\n-        return(NULL);\n-    }\n-    xmlSetTreeDoc((xmlNodePtr)ret->intSubset, ret);\n-    ret->intSubset->parent = ret;\n+        if (ret->intSubset == NULL) {\n+            xmlFreeDoc(ret);\n+            return(NULL);\n+        }\n+        xmlSetTreeDoc((xmlNodePtr)ret->intSubset, ret);\n+        ret->intSubset->parent = ret;\n@@ -4601,1 +4610,1 @@\n-    xmlNodePtr tmp;\n+        xmlNodePtr tmp;\n@@ -4603,9 +4612,9 @@\n-    ret->children = xmlStaticCopyNodeList(doc->children, ret,\n-                                       (xmlNodePtr)ret);\n-    ret->last = NULL;\n-    tmp = ret->children;\n-    while (tmp != NULL) {\n-        if (tmp->next == NULL)\n-            ret->last = tmp;\n-        tmp = tmp->next;\n-    }\n+        ret->children = xmlStaticCopyNodeList(doc->children, ret,\n+                                               (xmlNodePtr)ret);\n+        ret->last = NULL;\n+        tmp = ret->children;\n+        while (tmp != NULL) {\n+            if (tmp->next == NULL)\n+                ret->last = tmp;\n+            tmp = tmp->next;\n+        }\n@@ -4618,3 +4627,3 @@\n- *                                  *\n- *      Content access functions                *\n- *                                  *\n+ *                                                                      *\n+ *              Content access functions                                *\n+ *                                                                      *\n@@ -4645,15 +4654,15 @@\n-    (node->type == XML_COMMENT_NODE) ||\n-    (node->type == XML_PI_NODE)) {\n-    if (node->line == 65535) {\n-        if ((node->type == XML_TEXT_NODE) && (node->psvi != NULL))\n-            result = (long) (ptrdiff_t) node->psvi;\n-        else if ((node->type == XML_ELEMENT_NODE) &&\n-                 (node->children != NULL))\n-            result = xmlGetLineNoInternal(node->children, depth + 1);\n-        else if (node->next != NULL)\n-            result = xmlGetLineNoInternal(node->next, depth + 1);\n-        else if (node->prev != NULL)\n-            result = xmlGetLineNoInternal(node->prev, depth + 1);\n-    }\n-    if ((result == -1) || (result == 65535))\n-        result = (long) node->line;\n+        (node->type == XML_COMMENT_NODE) ||\n+        (node->type == XML_PI_NODE)) {\n+        if (node->line == 65535) {\n+            if ((node->type == XML_TEXT_NODE) && (node->psvi != NULL))\n+                result = (long) (ptrdiff_t) node->psvi;\n+            else if ((node->type == XML_ELEMENT_NODE) &&\n+                     (node->children != NULL))\n+                result = xmlGetLineNoInternal(node->children, depth + 1);\n+            else if (node->next != NULL)\n+                result = xmlGetLineNoInternal(node->next, depth + 1);\n+            else if (node->prev != NULL)\n+                result = xmlGetLineNoInternal(node->prev, depth + 1);\n+        }\n+        if ((result == -1) || (result == 65535))\n+            result = (long) node->line;\n@@ -4662,3 +4671,3 @@\n-          (node->prev->type == XML_TEXT_NODE) ||\n-          (node->prev->type == XML_COMMENT_NODE) ||\n-          (node->prev->type == XML_PI_NODE)))\n+              (node->prev->type == XML_TEXT_NODE) ||\n+              (node->prev->type == XML_COMMENT_NODE) ||\n+              (node->prev->type == XML_PI_NODE)))\n@@ -4717,1 +4726,1 @@\n-    xmlTreeErrMemory(\"getting node path\");\n+        xmlTreeErrMemory(\"getting node path\");\n@@ -4722,1 +4731,1 @@\n-    xmlTreeErrMemory(\"getting node path\");\n+        xmlTreeErrMemory(\"getting node path\");\n@@ -4740,1 +4749,1 @@\n-        generic = 0;\n+            generic = 0;\n@@ -4744,1 +4753,1 @@\n-        if (cur->ns->prefix != NULL) {\n+                if (cur->ns->prefix != NULL) {\n@@ -4746,11 +4755,11 @@\n-            (char *)cur->ns->prefix, (char *)cur->name);\n-            nametemp[sizeof(nametemp) - 1] = 0;\n-            name = nametemp;\n-        } else {\n-            \/*\n-            * We cannot express named elements in the default\n-            * namespace, so use \"*\".\n-            *\/\n-            generic = 1;\n-            name = \"*\";\n-        }\n+                        (char *)cur->ns->prefix, (char *)cur->name);\n+                    nametemp[sizeof(nametemp) - 1] = 0;\n+                    name = nametemp;\n+                } else {\n+                    \/*\n+                    * We cannot express named elements in the default\n+                    * namespace, so use \"*\".\n+                    *\/\n+                    generic = 1;\n+                    name = \"*\";\n+                }\n@@ -4762,1 +4771,1 @@\n-         * TODO: the occurrence test seems bogus for namespaced names\n+             * TODO: the occurrence test seems bogus for namespaced names\n@@ -4767,5 +4776,5 @@\n-            (generic ||\n-             (xmlStrEqual(cur->name, tmp->name) &&\n-             ((tmp->ns == cur->ns) ||\n-              ((tmp->ns != NULL) && (cur->ns != NULL) &&\n-               (xmlStrEqual(cur->ns->prefix, tmp->ns->prefix)))))))\n+                    (generic ||\n+                     (xmlStrEqual(cur->name, tmp->name) &&\n+                     ((tmp->ns == cur->ns) ||\n+                      ((tmp->ns != NULL) && (cur->ns != NULL) &&\n+                       (xmlStrEqual(cur->ns->prefix, tmp->ns->prefix)))))))\n@@ -4779,5 +4788,5 @@\n-            (generic ||\n-             (xmlStrEqual(cur->name, tmp->name) &&\n-             ((tmp->ns == cur->ns) ||\n-              ((tmp->ns != NULL) && (cur->ns != NULL) &&\n-               (xmlStrEqual(cur->ns->prefix, tmp->ns->prefix)))))))\n+                        (generic ||\n+                         (xmlStrEqual(cur->name, tmp->name) &&\n+                         ((tmp->ns == cur->ns) ||\n+                          ((tmp->ns != NULL) && (cur->ns != NULL) &&\n+                           (xmlStrEqual(cur->ns->prefix, tmp->ns->prefix)))))))\n@@ -4793,1 +4802,1 @@\n-        name = \"comment()\";\n+            name = \"comment()\";\n@@ -4802,1 +4811,1 @@\n-            occur++;\n+                    occur++;\n@@ -4808,2 +4817,2 @@\n-            if (tmp->type == XML_COMMENT_NODE)\n-                occur++;\n+                    if (tmp->type == XML_COMMENT_NODE)\n+                        occur++;\n@@ -4819,1 +4828,1 @@\n-        name = \"text()\";\n+            name = \"text()\";\n@@ -4828,2 +4837,2 @@\n-            (tmp->type == XML_CDATA_SECTION_NODE))\n-            occur++;\n+                    (tmp->type == XML_CDATA_SECTION_NODE))\n+                    occur++;\n@@ -4832,4 +4841,4 @@\n-        \/*\n-        * Evaluate if this is the only text- or CDATA-section-node;\n-        * if yes, then we'll get \"text()\", otherwise \"text()[1]\".\n-        *\/\n+            \/*\n+            * Evaluate if this is the only text- or CDATA-section-node;\n+            * if yes, then we'll get \"text()\", otherwise \"text()[1]\".\n+            *\/\n@@ -4839,8 +4848,8 @@\n-            if ((tmp->type == XML_TEXT_NODE) ||\n-            (tmp->type == XML_CDATA_SECTION_NODE))\n-            {\n-            occur = 1;\n-            break;\n-            }\n-            tmp = tmp->next;\n-        }\n+                    if ((tmp->type == XML_TEXT_NODE) ||\n+                        (tmp->type == XML_CDATA_SECTION_NODE))\n+                    {\n+                        occur = 1;\n+                        break;\n+                    }\n+                    tmp = tmp->next;\n+                }\n@@ -4851,2 +4860,2 @@\n-        snprintf(nametemp, sizeof(nametemp) - 1,\n-             \"processing-instruction('%s')\", (char *)cur->name);\n+            snprintf(nametemp, sizeof(nametemp) - 1,\n+                     \"processing-instruction('%s')\", (char *)cur->name);\n@@ -4856,1 +4865,1 @@\n-        next = cur->parent;\n+            next = cur->parent;\n@@ -4864,1 +4873,1 @@\n-            (xmlStrEqual(cur->name, tmp->name)))\n+                    (xmlStrEqual(cur->name, tmp->name)))\n@@ -4872,1 +4881,1 @@\n-            (xmlStrEqual(cur->name, tmp->name)))\n+                        (xmlStrEqual(cur->name, tmp->name)))\n@@ -4885,1 +4894,1 @@\n-            if (cur->ns->prefix != NULL)\n+                if (cur->ns->prefix != NULL)\n@@ -4887,4 +4896,4 @@\n-            (char *)cur->ns->prefix, (char *)cur->name);\n-        else\n-            snprintf(nametemp, sizeof(nametemp) - 1, \"%s\",\n-            (char *)cur->name);\n+                        (char *)cur->ns->prefix, (char *)cur->name);\n+                else\n+                    snprintf(nametemp, sizeof(nametemp) - 1, \"%s\",\n+                        (char *)cur->name);\n@@ -4909,1 +4918,1 @@\n-        xmlTreeErrMemory(\"getting node path\");\n+                xmlTreeErrMemory(\"getting node path\");\n@@ -4917,1 +4926,1 @@\n-        xmlTreeErrMemory(\"getting node path\");\n+                xmlTreeErrMemory(\"getting node path\");\n@@ -4954,2 +4963,2 @@\n-    if (ret->type == XML_ELEMENT_NODE)\n-        return(ret);\n+        if (ret->type == XML_ELEMENT_NODE)\n+            return(ret);\n@@ -4979,1 +4988,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4985,2 +4994,2 @@\n-    if (old->type == XML_ELEMENT_NODE)\n-        break;\n+        if (old->type == XML_ELEMENT_NODE)\n+            break;\n@@ -4990,6 +4999,6 @@\n-    if (doc->children == NULL) {\n-        doc->children = root;\n-        doc->last = root;\n-    } else {\n-        xmlAddSibling(doc->children, root);\n-    }\n+        if (doc->children == NULL) {\n+            doc->children = root;\n+            doc->last = root;\n+        } else {\n+            xmlAddSibling(doc->children, root);\n+        }\n@@ -4997,1 +5006,1 @@\n-    xmlReplaceNode(old, root);\n+        xmlReplaceNode(old, root);\n@@ -5033,1 +5042,1 @@\n-    case XML_NAMESPACE_DECL:\n+        case XML_NAMESPACE_DECL:\n@@ -5035,1 +5044,1 @@\n-    case XML_DOCB_DOCUMENT_NODE:\n+        case XML_DOCB_DOCUMENT_NODE:\n@@ -5037,3 +5046,3 @@\n-    case XML_XINCLUDE_START:\n-    case XML_XINCLUDE_END:\n-        return;\n+        case XML_XINCLUDE_START:\n+        case XML_XINCLUDE_END:\n+            return;\n@@ -5042,1 +5051,1 @@\n-        break;\n+            break;\n@@ -5046,1 +5055,1 @@\n-    return;\n+        return;\n@@ -5069,3 +5078,3 @@\n-    if (lang != NULL)\n-        return(lang);\n-    cur = cur->parent;\n+        if (lang != NULL)\n+            return(lang);\n+        cur = cur->parent;\n@@ -5107,3 +5116,3 @@\n-    case XML_NAMESPACE_DECL:\n-    case XML_XINCLUDE_START:\n-    case XML_XINCLUDE_END:\n+        case XML_NAMESPACE_DECL:\n+        case XML_XINCLUDE_START:\n+        case XML_XINCLUDE_END:\n@@ -5111,1 +5120,1 @@\n-    case XML_DOCB_DOCUMENT_NODE:\n+        case XML_DOCB_DOCUMENT_NODE:\n@@ -5113,1 +5122,1 @@\n-        return;\n+            return;\n@@ -5116,1 +5125,1 @@\n-        break;\n+            break;\n@@ -5120,1 +5129,1 @@\n-    return;\n+        return;\n@@ -5123,2 +5132,2 @@\n-    xmlSetNsProp(cur, ns, BAD_CAST \"space\", BAD_CAST \"default\");\n-    break;\n+        xmlSetNsProp(cur, ns, BAD_CAST \"space\", BAD_CAST \"default\");\n+        break;\n@@ -5126,2 +5135,2 @@\n-    xmlSetNsProp(cur, ns, BAD_CAST \"space\", BAD_CAST \"preserve\");\n-    break;\n+        xmlSetNsProp(cur, ns, BAD_CAST \"space\", BAD_CAST \"preserve\");\n+        break;\n@@ -5149,9 +5158,11 @@\n-    space = xmlGetNsProp(cur, BAD_CAST \"space\", XML_XML_NAMESPACE);\n-    if (space != NULL) {\n-        if (xmlStrEqual(space, BAD_CAST \"preserve\")) {\n-        xmlFree(space);\n-        return(1);\n-        }\n-        if (xmlStrEqual(space, BAD_CAST \"default\")) {\n-        xmlFree(space);\n-        return(0);\n+        space = xmlGetNsProp(cur, BAD_CAST \"space\", XML_XML_NAMESPACE);\n+        if (space != NULL) {\n+            if (xmlStrEqual(space, BAD_CAST \"preserve\")) {\n+                xmlFree(space);\n+                return(1);\n+            }\n+            if (xmlStrEqual(space, BAD_CAST \"default\")) {\n+                xmlFree(space);\n+                return(0);\n+            }\n+            xmlFree(space);\n@@ -5159,3 +5170,1 @@\n-        xmlFree(space);\n-    }\n-    cur = cur->parent;\n+        cur = cur->parent;\n@@ -5190,3 +5199,3 @@\n-    case XML_NAMESPACE_DECL:\n-    case XML_XINCLUDE_START:\n-    case XML_XINCLUDE_END:\n+        case XML_NAMESPACE_DECL:\n+        case XML_XINCLUDE_START:\n+        case XML_XINCLUDE_END:\n@@ -5194,1 +5203,1 @@\n-    case XML_DOCB_DOCUMENT_NODE:\n+        case XML_DOCB_DOCUMENT_NODE:\n@@ -5196,1 +5205,1 @@\n-        return;\n+            return;\n@@ -5207,1 +5216,1 @@\n-        break;\n+            break;\n@@ -5211,1 +5220,1 @@\n-    dict = doc->dict;\n+        dict = doc->dict;\n@@ -5216,2 +5225,2 @@\n-        freeme = cur->name;\n-    cur->name = xmlDictLookup(dict, name, -1);\n+            freeme = cur->name;\n+        cur->name = xmlDictLookup(dict, name, -1);\n@@ -5219,3 +5228,3 @@\n-    if (cur->name != NULL)\n-        freeme = cur->name;\n-    cur->name = xmlStrdup(name);\n+        if (cur->name != NULL)\n+            freeme = cur->name;\n+        cur->name = xmlStrdup(name);\n@@ -5258,4 +5267,4 @@\n-    case XML_NAMESPACE_DECL:\n-    case XML_XINCLUDE_START:\n-    case XML_XINCLUDE_END:\n-        return;\n+        case XML_NAMESPACE_DECL:\n+        case XML_XINCLUDE_START:\n+        case XML_XINCLUDE_END:\n+            return;\n@@ -5264,1 +5273,1 @@\n-        break;\n+            break;\n@@ -5267,1 +5276,1 @@\n-    case XML_DOCB_DOCUMENT_NODE:\n+        case XML_DOCB_DOCUMENT_NODE:\n@@ -5270,1 +5279,1 @@\n-        xmlDocPtr doc = (xmlDocPtr) cur;\n+            xmlDocPtr doc = (xmlDocPtr) cur;\n@@ -5272,8 +5281,8 @@\n-        if (doc->URL != NULL)\n-        xmlFree((xmlChar *) doc->URL);\n-        if (uri == NULL)\n-        doc->URL = NULL;\n-        else\n-        doc->URL = xmlPathToURI(uri);\n-        return;\n-    }\n+            if (doc->URL != NULL)\n+                xmlFree((xmlChar *) doc->URL);\n+            if (uri == NULL)\n+                doc->URL = NULL;\n+            else\n+                doc->URL = xmlPathToURI(uri);\n+            return;\n+        }\n@@ -5284,1 +5293,1 @@\n-    return;\n+        return;\n@@ -5287,2 +5296,2 @@\n-    xmlSetNsProp(cur, ns, BAD_CAST \"base\", fixed);\n-    xmlFree(fixed);\n+        xmlSetNsProp(cur, ns, BAD_CAST \"base\", fixed);\n+        xmlFree(fixed);\n@@ -5290,1 +5299,1 @@\n-    xmlSetNsProp(cur, ns, BAD_CAST \"base\", uri);\n+        xmlSetNsProp(cur, ns, BAD_CAST \"base\", uri);\n@@ -5324,14 +5333,14 @@\n-    while ((cur != NULL) && (cur->name != NULL)) {\n-        if (cur->type != XML_ELEMENT_NODE) {\n-            cur = cur->next;\n-        continue;\n-        }\n-        if (!xmlStrcasecmp(cur->name, BAD_CAST \"html\")) {\n-            cur = cur->children;\n-        continue;\n-        }\n-        if (!xmlStrcasecmp(cur->name, BAD_CAST \"head\")) {\n-            cur = cur->children;\n-        continue;\n-        }\n-        if (!xmlStrcasecmp(cur->name, BAD_CAST \"base\")) {\n+        while ((cur != NULL) && (cur->name != NULL)) {\n+            if (cur->type != XML_ELEMENT_NODE) {\n+                cur = cur->next;\n+                continue;\n+            }\n+            if (!xmlStrcasecmp(cur->name, BAD_CAST \"html\")) {\n+                cur = cur->children;\n+                continue;\n+            }\n+            if (!xmlStrcasecmp(cur->name, BAD_CAST \"head\")) {\n+                cur = cur->children;\n+                continue;\n+            }\n+            if (!xmlStrcasecmp(cur->name, BAD_CAST \"base\")) {\n@@ -5339,0 +5348,2 @@\n+            }\n+            cur = cur->next;\n@@ -5340,3 +5351,1 @@\n-        cur = cur->next;\n-    }\n-    return(NULL);\n+        return(NULL);\n@@ -5345,20 +5354,3 @@\n-    if (cur->type == XML_ENTITY_DECL) {\n-        xmlEntityPtr ent = (xmlEntityPtr) cur;\n-        return(xmlStrdup(ent->URI));\n-    }\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        base = xmlGetNsProp(cur, BAD_CAST \"base\", XML_XML_NAMESPACE);\n-        if (base != NULL) {\n-        if (oldbase != NULL) {\n-            newbase = xmlBuildURI(oldbase, base);\n-            if (newbase != NULL) {\n-            xmlFree(oldbase);\n-            xmlFree(base);\n-            oldbase = newbase;\n-            } else {\n-            xmlFree(oldbase);\n-            xmlFree(base);\n-            return(NULL);\n-            }\n-        } else {\n-            oldbase = base;\n+        if (cur->type == XML_ENTITY_DECL) {\n+            xmlEntityPtr ent = (xmlEntityPtr) cur;\n+            return(xmlStrdup(ent->URI));\n@@ -5366,4 +5358,22 @@\n-        if ((!xmlStrncmp(oldbase, BAD_CAST \"http:\/\/\", 7)) ||\n-            (!xmlStrncmp(oldbase, BAD_CAST \"ftp:\/\/\", 6)) ||\n-            (!xmlStrncmp(oldbase, BAD_CAST \"urn:\", 4)))\n-            return(oldbase);\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            base = xmlGetNsProp(cur, BAD_CAST \"base\", XML_XML_NAMESPACE);\n+            if (base != NULL) {\n+                if (oldbase != NULL) {\n+                    newbase = xmlBuildURI(oldbase, base);\n+                    if (newbase != NULL) {\n+                        xmlFree(oldbase);\n+                        xmlFree(base);\n+                        oldbase = newbase;\n+                    } else {\n+                        xmlFree(oldbase);\n+                        xmlFree(base);\n+                        return(NULL);\n+                    }\n+                } else {\n+                    oldbase = base;\n+                }\n+                if ((!xmlStrncmp(oldbase, BAD_CAST \"http:\/\/\", 7)) ||\n+                    (!xmlStrncmp(oldbase, BAD_CAST \"ftp:\/\/\", 6)) ||\n+                    (!xmlStrncmp(oldbase, BAD_CAST \"urn:\", 4)))\n+                    return(oldbase);\n+            }\n@@ -5371,2 +5381,1 @@\n-    }\n-    cur = cur->parent;\n+        cur = cur->parent;\n@@ -5375,5 +5384,5 @@\n-    if (oldbase == NULL)\n-        return(xmlStrdup(doc->URL));\n-    newbase = xmlBuildURI(oldbase, doc->URL);\n-    xmlFree(oldbase);\n-    return(newbase);\n+        if (oldbase == NULL)\n+            return(xmlStrdup(doc->URL));\n+        newbase = xmlBuildURI(oldbase, doc->URL);\n+        xmlFree(oldbase);\n+        return(newbase);\n@@ -5432,1 +5441,1 @@\n-        xmlBufCat(buf, cur->content);\n+            xmlBufCat(buf, cur->content);\n@@ -5482,1 +5491,1 @@\n-        break;\n+                break;\n@@ -5486,1 +5495,1 @@\n-        xmlNodePtr tmp = attr->children;\n+                xmlNodePtr tmp = attr->children;\n@@ -5488,7 +5497,7 @@\n-        while (tmp != NULL) {\n-            if (tmp->type == XML_TEXT_NODE)\n-                xmlBufCat(buf, tmp->content);\n-            else\n-                xmlBufGetNodeContent(buf, tmp);\n-            tmp = tmp->next;\n-        }\n+                while (tmp != NULL) {\n+                    if (tmp->type == XML_TEXT_NODE)\n+                        xmlBufCat(buf, tmp->content);\n+                    else\n+                        xmlBufGetNodeContent(buf, tmp);\n+                    tmp = tmp->next;\n+                }\n@@ -5499,1 +5508,1 @@\n-        xmlBufCat(buf, cur->content);\n+            xmlBufCat(buf, cur->content);\n@@ -5517,1 +5526,1 @@\n-            xmlBufGetNodeContent(buf, tmp);\n+                    xmlBufGetNodeContent(buf, tmp);\n@@ -5520,1 +5529,1 @@\n-        break;\n+                break;\n@@ -5534,10 +5543,10 @@\n-        cur = cur->children;\n-        while (cur!= NULL) {\n-        if ((cur->type == XML_ELEMENT_NODE) ||\n-            (cur->type == XML_TEXT_NODE) ||\n-            (cur->type == XML_CDATA_SECTION_NODE)) {\n-            xmlBufGetNodeContent(buf, cur);\n-        }\n-        cur = cur->next;\n-        }\n-        break;\n+            cur = cur->children;\n+            while (cur!= NULL) {\n+                if ((cur->type == XML_ELEMENT_NODE) ||\n+                    (cur->type == XML_TEXT_NODE) ||\n+                    (cur->type == XML_CDATA_SECTION_NODE)) {\n+                    xmlBufGetNodeContent(buf, cur);\n+                }\n+                cur = cur->next;\n+            }\n+            break;\n@@ -5545,2 +5554,2 @@\n-        xmlBufCat(buf, ((xmlNsPtr) cur)->href);\n-        break;\n+            xmlBufCat(buf, ((xmlNsPtr) cur)->href);\n+            break;\n@@ -5580,1 +5589,1 @@\n-        xmlBufGetNodeContent(buf, cur);\n+                xmlBufGetNodeContent(buf, cur);\n@@ -5586,1 +5595,1 @@\n-        return(xmlGetPropNodeValueInternal((xmlAttrPtr) cur));\n+            return(xmlGetPropNodeValueInternal((xmlAttrPtr) cur));\n@@ -5624,2 +5633,2 @@\n-        xmlBufPtr buf;\n-        xmlChar *ret;\n+            xmlBufPtr buf;\n+            xmlChar *ret;\n@@ -5627,3 +5636,3 @@\n-        buf = xmlBufCreate();\n-        if (buf == NULL)\n-        return (NULL);\n+            buf = xmlBufCreate();\n+            if (buf == NULL)\n+                return (NULL);\n@@ -5631,1 +5640,1 @@\n-        xmlBufGetNodeContent(buf, (xmlNodePtr) cur);\n+            xmlBufGetNodeContent(buf, (xmlNodePtr) cur);\n@@ -5633,4 +5642,4 @@\n-        ret = xmlBufDetach(buf);\n-        xmlBufFree(buf);\n-        return (ret);\n-    }\n+            ret = xmlBufDetach(buf);\n+            xmlBufFree(buf);\n+            return (ret);\n+        }\n@@ -5638,1 +5647,1 @@\n-        xmlChar *tmp;\n+            xmlChar *tmp;\n@@ -5640,1 +5649,1 @@\n-        tmp = xmlStrdup(((xmlNsPtr) cur)->href);\n+            tmp = xmlStrdup(((xmlNsPtr) cur)->href);\n@@ -5642,1 +5651,1 @@\n-    }\n+        }\n@@ -5676,1 +5685,1 @@\n-        \"xmlNodeSetContent : node == NULL\\n\");\n+                \"xmlNodeSetContent : node == NULL\\n\");\n@@ -5678,1 +5687,1 @@\n-    return;\n+        return;\n@@ -5684,4 +5693,4 @@\n-        if (cur->children != NULL) xmlFreeNodeList(cur->children);\n-        cur->children = xmlStringGetNodeList(cur->doc, content);\n-        UPDATE_LAST_CHILD_AND_PARENT(cur)\n-        break;\n+            if (cur->children != NULL) xmlFreeNodeList(cur->children);\n+            cur->children = xmlStringGetNodeList(cur->doc, content);\n+            UPDATE_LAST_CHILD_AND_PARENT(cur)\n+            break;\n@@ -5694,15 +5703,15 @@\n-        if ((cur->content != NULL) &&\n-            (cur->content != (xmlChar *) &(cur->properties))) {\n-            if (!((cur->doc != NULL) && (cur->doc->dict != NULL) &&\n-            (xmlDictOwns(cur->doc->dict, cur->content))))\n-            xmlFree(cur->content);\n-        }\n-        if (cur->children != NULL) xmlFreeNodeList(cur->children);\n-        cur->last = cur->children = NULL;\n-        if (content != NULL) {\n-        cur->content = xmlStrdup(content);\n-        } else\n-        cur->content = NULL;\n-        cur->properties = NULL;\n-        cur->nsDef = NULL;\n-        break;\n+            if ((cur->content != NULL) &&\n+                (cur->content != (xmlChar *) &(cur->properties))) {\n+                if (!((cur->doc != NULL) && (cur->doc->dict != NULL) &&\n+                    (xmlDictOwns(cur->doc->dict, cur->content))))\n+                    xmlFree(cur->content);\n+            }\n+            if (cur->children != NULL) xmlFreeNodeList(cur->children);\n+            cur->last = cur->children = NULL;\n+            if (content != NULL) {\n+                cur->content = xmlStrdup(content);\n+            } else\n+                cur->content = NULL;\n+            cur->properties = NULL;\n+            cur->nsDef = NULL;\n+            break;\n@@ -5712,2 +5721,2 @@\n-    case XML_XINCLUDE_START:\n-    case XML_XINCLUDE_END:\n+        case XML_XINCLUDE_START:\n+        case XML_XINCLUDE_END:\n@@ -5715,1 +5724,1 @@\n-    case XML_DOCB_DOCUMENT_NODE:\n+        case XML_DOCB_DOCUMENT_NODE:\n@@ -5717,1 +5726,1 @@\n-        break;\n+            break;\n@@ -5719,1 +5728,1 @@\n-        break;\n+            break;\n@@ -5721,3 +5730,3 @@\n-        break;\n-    case XML_NAMESPACE_DECL:\n-        break;\n+            break;\n+        case XML_NAMESPACE_DECL:\n+            break;\n@@ -5725,2 +5734,2 @@\n-        \/* TODO !!! *\/\n-        break;\n+            \/* TODO !!! *\/\n+            break;\n@@ -5728,2 +5737,2 @@\n-        \/* TODO !!! *\/\n-        break;\n+            \/* TODO !!! *\/\n+            break;\n@@ -5731,2 +5740,2 @@\n-        \/* TODO !!! *\/\n-        break;\n+            \/* TODO !!! *\/\n+            break;\n@@ -5753,1 +5762,1 @@\n-        \"xmlNodeSetContentLen : node == NULL\\n\");\n+                \"xmlNodeSetContentLen : node == NULL\\n\");\n@@ -5755,1 +5764,1 @@\n-    return;\n+        return;\n@@ -5761,4 +5770,4 @@\n-        if (cur->children != NULL) xmlFreeNodeList(cur->children);\n-        cur->children = xmlStringLenGetNodeList(cur->doc, content, len);\n-        UPDATE_LAST_CHILD_AND_PARENT(cur)\n-        break;\n+            if (cur->children != NULL) xmlFreeNodeList(cur->children);\n+            cur->children = xmlStringLenGetNodeList(cur->doc, content, len);\n+            UPDATE_LAST_CHILD_AND_PARENT(cur)\n+            break;\n@@ -5772,15 +5781,15 @@\n-        if ((cur->content != NULL) &&\n-            (cur->content != (xmlChar *) &(cur->properties))) {\n-            if (!((cur->doc != NULL) && (cur->doc->dict != NULL) &&\n-            (xmlDictOwns(cur->doc->dict, cur->content))))\n-            xmlFree(cur->content);\n-        }\n-        if (cur->children != NULL) xmlFreeNodeList(cur->children);\n-        cur->children = cur->last = NULL;\n-        if (content != NULL) {\n-        cur->content = xmlStrndup(content, len);\n-        } else\n-        cur->content = NULL;\n-        cur->properties = NULL;\n-        cur->nsDef = NULL;\n-        break;\n+            if ((cur->content != NULL) &&\n+                (cur->content != (xmlChar *) &(cur->properties))) {\n+                if (!((cur->doc != NULL) && (cur->doc->dict != NULL) &&\n+                    (xmlDictOwns(cur->doc->dict, cur->content))))\n+                    xmlFree(cur->content);\n+            }\n+            if (cur->children != NULL) xmlFreeNodeList(cur->children);\n+            cur->children = cur->last = NULL;\n+            if (content != NULL) {\n+                cur->content = xmlStrndup(content, len);\n+            } else\n+                cur->content = NULL;\n+            cur->properties = NULL;\n+            cur->nsDef = NULL;\n+            break;\n@@ -5791,3 +5800,3 @@\n-    case XML_NAMESPACE_DECL:\n-    case XML_XINCLUDE_START:\n-    case XML_XINCLUDE_END:\n+        case XML_NAMESPACE_DECL:\n+        case XML_XINCLUDE_START:\n+        case XML_XINCLUDE_END:\n@@ -5795,1 +5804,1 @@\n-    case XML_DOCB_DOCUMENT_NODE:\n+        case XML_DOCB_DOCUMENT_NODE:\n@@ -5797,1 +5806,1 @@\n-        break;\n+            break;\n@@ -5799,2 +5808,2 @@\n-        \/* TODO !!! *\/\n-        break;\n+            \/* TODO !!! *\/\n+            break;\n@@ -5802,2 +5811,2 @@\n-        \/* TODO !!! *\/\n-        break;\n+            \/* TODO !!! *\/\n+            break;\n@@ -5805,2 +5814,2 @@\n-        \/* TODO !!! *\/\n-        break;\n+            \/* TODO !!! *\/\n+            break;\n@@ -5827,1 +5836,1 @@\n-        \"xmlNodeAddContentLen : node == NULL\\n\");\n+                \"xmlNodeAddContentLen : node == NULL\\n\");\n@@ -5829,1 +5838,1 @@\n-    return;\n+        return;\n@@ -5835,11 +5844,13 @@\n-        xmlNodePtr last, newNode, tmp;\n-\n-        last = cur->last;\n-        newNode = xmlNewTextLen(content, len);\n-        if (newNode != NULL) {\n-        tmp = xmlAddChild(cur, newNode);\n-        if (tmp != newNode)\n-            return;\n-            if ((last != NULL) && (last->next == newNode)) {\n-            xmlTextMerge(last, newNode);\n-        }\n+            xmlNodePtr last, newNode, tmp;\n+\n+            last = cur->last;\n+            newNode = xmlNewTextLen(content, len);\n+            if (newNode != NULL) {\n+                tmp = xmlAddChild(cur, newNode);\n+                if (tmp != newNode)\n+                    return;\n+                if ((last != NULL) && (last->next == newNode)) {\n+                    xmlTextMerge(last, newNode);\n+                }\n+            }\n+            break;\n@@ -5847,2 +5858,0 @@\n-        break;\n-    }\n@@ -5850,1 +5859,1 @@\n-        break;\n+            break;\n@@ -5858,10 +5867,10 @@\n-        if (content != NULL) {\n-            if ((cur->content == (xmlChar *) &(cur->properties)) ||\n-            ((cur->doc != NULL) && (cur->doc->dict != NULL) &&\n-                xmlDictOwns(cur->doc->dict, cur->content))) {\n-            cur->content = xmlStrncatNew(cur->content, content, len);\n-            cur->properties = NULL;\n-            cur->nsDef = NULL;\n-            break;\n-        }\n-        cur->content = xmlStrncat(cur->content, content, len);\n+            if (content != NULL) {\n+                if ((cur->content == (xmlChar *) &(cur->properties)) ||\n+                    ((cur->doc != NULL) && (cur->doc->dict != NULL) &&\n+                            xmlDictOwns(cur->doc->dict, cur->content))) {\n+                    cur->content = xmlStrncatNew(cur->content, content, len);\n+                    cur->properties = NULL;\n+                    cur->nsDef = NULL;\n+                    break;\n+                }\n+                cur->content = xmlStrncat(cur->content, content, len);\n@@ -5873,3 +5882,3 @@\n-    case XML_NAMESPACE_DECL:\n-    case XML_XINCLUDE_START:\n-    case XML_XINCLUDE_END:\n+        case XML_NAMESPACE_DECL:\n+        case XML_XINCLUDE_START:\n+        case XML_XINCLUDE_END:\n@@ -5877,1 +5886,1 @@\n-    case XML_DOCB_DOCUMENT_NODE:\n+        case XML_DOCB_DOCUMENT_NODE:\n@@ -5879,1 +5888,1 @@\n-        break;\n+            break;\n@@ -5883,1 +5892,1 @@\n-        break;\n+            break;\n@@ -5904,1 +5913,1 @@\n-        \"xmlNodeAddContent : node == NULL\\n\");\n+                \"xmlNodeAddContent : node == NULL\\n\");\n@@ -5906,1 +5915,1 @@\n-    return;\n+        return;\n@@ -5928,1 +5937,1 @@\n-    return(first);\n+        return(first);\n@@ -5967,1 +5976,1 @@\n-            xmlTreeErrMemory(\"getting namespace list\");\n+                        xmlTreeErrMemory(\"getting namespace list\");\n@@ -5985,1 +5994,1 @@\n-                xmlTreeErrMemory(\"getting namespace list\");\n+                            xmlTreeErrMemory(\"getting namespace list\");\n@@ -6014,1 +6023,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -6016,1 +6025,1 @@\n-    return (doc->oldNs);\n+        return (doc->oldNs);\n@@ -6018,13 +6027,13 @@\n-    xmlNsPtr ns;\n-    ns = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));\n-    if (ns == NULL) {\n-        xmlTreeErrMemory(\n-        \"allocating the XML namespace\");\n-        return (NULL);\n-    }\n-    memset(ns, 0, sizeof(xmlNs));\n-    ns->type = XML_LOCAL_NAMESPACE;\n-    ns->href = xmlStrdup(XML_XML_NAMESPACE);\n-    ns->prefix = xmlStrdup((const xmlChar *)\"xml\");\n-    doc->oldNs = ns;\n-    return (ns);\n+        xmlNsPtr ns;\n+        ns = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));\n+        if (ns == NULL) {\n+            xmlTreeErrMemory(\n+                \"allocating the XML namespace\");\n+            return (NULL);\n+        }\n+        memset(ns, 0, sizeof(xmlNs));\n+        ns->type = XML_LOCAL_NAMESPACE;\n+        ns->href = xmlStrdup(XML_XML_NAMESPACE);\n+        ns->prefix = xmlStrdup((const xmlChar *)\"xml\");\n+        doc->oldNs = ns;\n+        return (ns);\n@@ -6058,11 +6067,19 @@\n-    (xmlStrEqual(nameSpace, (const xmlChar *)\"xml\"))) {\n-    if ((doc == NULL) && (node->type == XML_ELEMENT_NODE)) {\n-        \/*\n-         * The XML-1.0 namespace is normally held on the root\n-         * element. In this case exceptionally create it on the\n-         * node element.\n-         *\/\n-        cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));\n-        if (cur == NULL) {\n-        xmlTreeErrMemory(\"searching namespace\");\n-        return(NULL);\n+        (xmlStrEqual(nameSpace, (const xmlChar *)\"xml\"))) {\n+        if ((doc == NULL) && (node->type == XML_ELEMENT_NODE)) {\n+            \/*\n+             * The XML-1.0 namespace is normally held on the root\n+             * element. In this case exceptionally create it on the\n+             * node element.\n+             *\/\n+            cur = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));\n+            if (cur == NULL) {\n+                xmlTreeErrMemory(\"searching namespace\");\n+                return(NULL);\n+            }\n+            memset(cur, 0, sizeof(xmlNs));\n+            cur->type = XML_LOCAL_NAMESPACE;\n+            cur->href = xmlStrdup(XML_XML_NAMESPACE);\n+            cur->prefix = xmlStrdup((const xmlChar *)\"xml\");\n+            cur->next = node->nsDef;\n+            node->nsDef = cur;\n+            return(cur);\n@@ -6070,20 +6087,12 @@\n-        memset(cur, 0, sizeof(xmlNs));\n-        cur->type = XML_LOCAL_NAMESPACE;\n-        cur->href = xmlStrdup(XML_XML_NAMESPACE);\n-        cur->prefix = xmlStrdup((const xmlChar *)\"xml\");\n-        cur->next = node->nsDef;\n-        node->nsDef = cur;\n-        return(cur);\n-    }\n-    if (doc == NULL) {\n-        doc = node->doc;\n-        if (doc == NULL)\n-        return(NULL);\n-    }\n-    \/*\n-    * Return the XML namespace declaration held by the doc.\n-    *\/\n-    if (doc->oldNs == NULL)\n-        return(xmlTreeEnsureXMLDecl(doc));\n-    else\n-        return(doc->oldNs);\n+        if (doc == NULL) {\n+            doc = node->doc;\n+            if (doc == NULL)\n+                return(NULL);\n+        }\n+        \/*\n+        * Return the XML namespace declaration held by the doc.\n+        *\/\n+        if (doc->oldNs == NULL)\n+            return(xmlTreeEnsureXMLDecl(doc));\n+        else\n+            return(doc->oldNs);\n@@ -6092,26 +6101,27 @@\n-    if ((node->type == XML_ENTITY_REF_NODE) ||\n-        (node->type == XML_ENTITY_NODE) ||\n-        (node->type == XML_ENTITY_DECL))\n-        return(NULL);\n-    if (node->type == XML_ELEMENT_NODE) {\n-        cur = node->nsDef;\n-        while (cur != NULL) {\n-        if ((cur->prefix == NULL) && (nameSpace == NULL) &&\n-            (cur->href != NULL))\n-            return(cur);\n-        if ((cur->prefix != NULL) && (nameSpace != NULL) &&\n-            (cur->href != NULL) &&\n-            (xmlStrEqual(cur->prefix, nameSpace)))\n-            return(cur);\n-        cur = cur->next;\n-        }\n-        if (orig != node) {\n-            cur = node->ns;\n-            if (cur != NULL) {\n-            if ((cur->prefix == NULL) && (nameSpace == NULL) &&\n-                (cur->href != NULL))\n-                return(cur);\n-            if ((cur->prefix != NULL) && (nameSpace != NULL) &&\n-                (cur->href != NULL) &&\n-                (xmlStrEqual(cur->prefix, nameSpace)))\n-                return(cur);\n+        if ((node->type == XML_ENTITY_REF_NODE) ||\n+            (node->type == XML_ENTITY_NODE) ||\n+            (node->type == XML_ENTITY_DECL))\n+            return(NULL);\n+        if (node->type == XML_ELEMENT_NODE) {\n+            cur = node->nsDef;\n+            while (cur != NULL) {\n+                if ((cur->prefix == NULL) && (nameSpace == NULL) &&\n+                    (cur->href != NULL))\n+                    return(cur);\n+                if ((cur->prefix != NULL) && (nameSpace != NULL) &&\n+                    (cur->href != NULL) &&\n+                    (xmlStrEqual(cur->prefix, nameSpace)))\n+                    return(cur);\n+                cur = cur->next;\n+            }\n+            if (orig != node) {\n+                cur = node->ns;\n+                if (cur != NULL) {\n+                    if ((cur->prefix == NULL) && (nameSpace == NULL) &&\n+                        (cur->href != NULL))\n+                        return(cur);\n+                    if ((cur->prefix != NULL) && (nameSpace != NULL) &&\n+                        (cur->href != NULL) &&\n+                        (xmlStrEqual(cur->prefix, nameSpace)))\n+                        return(cur);\n+                }\n@@ -6120,2 +6130,1 @@\n-    }\n-    node = node->parent;\n+        node = node->parent;\n@@ -6200,1 +6209,1 @@\n-        xmlTreeErrMemory(\"searching namespace\");\n+                xmlTreeErrMemory(\"searching namespace\");\n@@ -6211,12 +6220,12 @@\n-    if (doc == NULL) {\n-        doc = node->doc;\n-        if (doc == NULL)\n-        return(NULL);\n-    }\n-    \/*\n-    * Return the XML namespace declaration held by the doc.\n-    *\/\n-    if (doc->oldNs == NULL)\n-        return(xmlTreeEnsureXMLDecl(doc));\n-    else\n-        return(doc->oldNs);\n+        if (doc == NULL) {\n+            doc = node->doc;\n+            if (doc == NULL)\n+                return(NULL);\n+        }\n+        \/*\n+        * Return the XML namespace declaration held by the doc.\n+        *\/\n+        if (doc->oldNs == NULL)\n+            return(xmlTreeEnsureXMLDecl(doc));\n+        else\n+            return(doc->oldNs);\n@@ -6235,3 +6244,3 @@\n-            if (((!is_attr) || (cur->prefix != NULL)) &&\n-                (xmlNsInScope(doc, orig, node, cur->prefix) == 1))\n-            return (cur);\n+                    if (((!is_attr) || (cur->prefix != NULL)) &&\n+                        (xmlNsInScope(doc, orig, node, cur->prefix) == 1))\n+                        return (cur);\n@@ -6246,3 +6255,3 @@\n-            if (((!is_attr) || (cur->prefix != NULL)) &&\n-                    (xmlNsInScope(doc, orig, node, cur->prefix) == 1))\n-                return (cur);\n+                        if (((!is_attr) || (cur->prefix != NULL)) &&\n+                            (xmlNsInScope(doc, orig, node, cur->prefix) == 1))\n+                            return (cur);\n@@ -6280,1 +6289,1 @@\n-        \"xmlNewReconciledNs : tree == NULL\\n\");\n+                \"xmlNewReconciledNs : tree == NULL\\n\");\n@@ -6282,1 +6291,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6287,1 +6296,1 @@\n-        \"xmlNewReconciledNs : ns == NULL\\n\");\n+                \"xmlNewReconciledNs : ns == NULL\\n\");\n@@ -6289,1 +6298,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6303,1 +6312,1 @@\n-    snprintf((char *) prefix, sizeof(prefix), \"default\");\n+        snprintf((char *) prefix, sizeof(prefix), \"default\");\n@@ -6305,1 +6314,1 @@\n-    snprintf((char *) prefix, sizeof(prefix), \"%.20s\", (char *)ns->prefix);\n+        snprintf((char *) prefix, sizeof(prefix), \"%.20s\", (char *)ns->prefix);\n@@ -6310,6 +6319,6 @@\n-    if (ns->prefix == NULL)\n-        snprintf((char *) prefix, sizeof(prefix), \"default%d\", counter++);\n-    else\n-        snprintf((char *) prefix, sizeof(prefix), \"%.20s%d\",\n-        (char *)ns->prefix, counter++);\n-    def = xmlSearchNs(doc, tree, prefix);\n+        if (ns->prefix == NULL)\n+            snprintf((char *) prefix, sizeof(prefix), \"default%d\", counter++);\n+        else\n+            snprintf((char *) prefix, sizeof(prefix), \"%.20s%d\",\n+                (char *)ns->prefix, counter++);\n+        def = xmlSearchNs(doc, tree, prefix);\n@@ -6357,31 +6366,1 @@\n-     * Reconciliate the node namespace\n-     *\/\n-    if (node->ns != NULL) {\n-        \/*\n-         * initialize the cache if needed\n-         *\/\n-        if (sizeCache == 0) {\n-        sizeCache = 10;\n-        oldNs = (xmlNsPtr *) xmlMalloc(sizeCache *\n-                           sizeof(xmlNsPtr));\n-        if (oldNs == NULL) {\n-            xmlTreeErrMemory(\"fixing namespaces\");\n-            return(-1);\n-        }\n-        newNs = (xmlNsPtr *) xmlMalloc(sizeCache *\n-                           sizeof(xmlNsPtr));\n-        if (newNs == NULL) {\n-            xmlTreeErrMemory(\"fixing namespaces\");\n-            xmlFree(oldNs);\n-            return(-1);\n-        }\n-        }\n-        for (i = 0;i < nbCache;i++) {\n-            if (oldNs[i] == node->ns) {\n-            node->ns = newNs[i];\n-            break;\n-        }\n-        }\n-        if (i == nbCache) {\n-            \/*\n-         * OK we need to recreate a new namespace definition\n+         * Reconciliate the node namespace\n@@ -6389,35 +6368,1 @@\n-        n = xmlNewReconciledNs(doc, tree, node->ns);\n-        if (n != NULL) { \/* :-( what if else ??? *\/\n-            \/*\n-             * check if we need to grow the cache buffers.\n-             *\/\n-            if (sizeCache <= nbCache) {\n-                sizeCache *= 2;\n-            oldNs = (xmlNsPtr *) xmlRealloc(oldNs, sizeCache *\n-                                           sizeof(xmlNsPtr));\n-                if (oldNs == NULL) {\n-                xmlTreeErrMemory(\"fixing namespaces\");\n-                xmlFree(newNs);\n-                return(-1);\n-            }\n-            newNs = (xmlNsPtr *) xmlRealloc(newNs, sizeCache *\n-                                           sizeof(xmlNsPtr));\n-                if (newNs == NULL) {\n-                xmlTreeErrMemory(\"fixing namespaces\");\n-                xmlFree(oldNs);\n-                return(-1);\n-            }\n-            }\n-            newNs[nbCache] = n;\n-            oldNs[nbCache++] = node->ns;\n-            node->ns = n;\n-                }\n-        }\n-    }\n-    \/*\n-     * now check for namespace held by attributes on the node.\n-     *\/\n-    if (node->type == XML_ELEMENT_NODE) {\n-        attr = node->properties;\n-        while (attr != NULL) {\n-        if (attr->ns != NULL) {\n+        if (node->ns != NULL) {\n@@ -6428,34 +6373,3 @@\n-            sizeCache = 10;\n-            oldNs = (xmlNsPtr *) xmlMalloc(sizeCache *\n-                               sizeof(xmlNsPtr));\n-            if (oldNs == NULL) {\n-                xmlTreeErrMemory(\"fixing namespaces\");\n-                return(-1);\n-            }\n-            newNs = (xmlNsPtr *) xmlMalloc(sizeCache *\n-                               sizeof(xmlNsPtr));\n-            if (newNs == NULL) {\n-                xmlTreeErrMemory(\"fixing namespaces\");\n-                xmlFree(oldNs);\n-                return(-1);\n-            }\n-            }\n-            for (i = 0;i < nbCache;i++) {\n-            if (oldNs[i] == attr->ns) {\n-                attr->ns = newNs[i];\n-                break;\n-            }\n-            }\n-            if (i == nbCache) {\n-            \/*\n-             * OK we need to recreate a new namespace definition\n-             *\/\n-            n = xmlNewReconciledNs(doc, tree, attr->ns);\n-            if (n != NULL) { \/* :-( what if else ??? *\/\n-                \/*\n-                 * check if we need to grow the cache buffers.\n-                 *\/\n-                if (sizeCache <= nbCache) {\n-                sizeCache *= 2;\n-                oldNs = (xmlNsPtr *) xmlRealloc(oldNs,\n-                           sizeCache * sizeof(xmlNsPtr));\n+                sizeCache = 10;\n+                oldNs = (xmlNsPtr *) xmlMalloc(sizeCache *\n+                                               sizeof(xmlNsPtr));\n@@ -6464,1 +6378,0 @@\n-                    xmlFree(newNs);\n@@ -6467,2 +6380,2 @@\n-                newNs = (xmlNsPtr *) xmlRealloc(newNs,\n-                           sizeCache * sizeof(xmlNsPtr));\n+                newNs = (xmlNsPtr *) xmlMalloc(sizeCache *\n+                                               sizeof(xmlNsPtr));\n@@ -6474,0 +6387,5 @@\n+            }\n+            for (i = 0;i < nbCache;i++) {\n+                if (oldNs[i] == node->ns) {\n+                    node->ns = newNs[i];\n+                    break;\n@@ -6475,3 +6393,0 @@\n-                newNs[nbCache] = n;\n-                oldNs[nbCache++] = attr->ns;\n-                attr->ns = n;\n@@ -6479,0 +6394,30 @@\n+            if (i == nbCache) {\n+                \/*\n+                 * OK we need to recreate a new namespace definition\n+                 *\/\n+                n = xmlNewReconciledNs(doc, tree, node->ns);\n+                if (n != NULL) { \/* :-( what if else ??? *\/\n+                    \/*\n+                     * check if we need to grow the cache buffers.\n+                     *\/\n+                    if (sizeCache <= nbCache) {\n+                        sizeCache *= 2;\n+                        oldNs = (xmlNsPtr *) xmlRealloc(oldNs, sizeCache *\n+                                                       sizeof(xmlNsPtr));\n+                        if (oldNs == NULL) {\n+                            xmlTreeErrMemory(\"fixing namespaces\");\n+                            xmlFree(newNs);\n+                            return(-1);\n+                        }\n+                        newNs = (xmlNsPtr *) xmlRealloc(newNs, sizeCache *\n+                                                       sizeof(xmlNsPtr));\n+                        if (newNs == NULL) {\n+                            xmlTreeErrMemory(\"fixing namespaces\");\n+                            xmlFree(oldNs);\n+                            return(-1);\n+                        }\n+                    }\n+                    newNs[nbCache] = n;\n+                    oldNs[nbCache++] = node->ns;\n+                    node->ns = n;\n+                }\n@@ -6481,1 +6426,66 @@\n-        attr = attr->next;\n+        \/*\n+         * now check for namespace held by attributes on the node.\n+         *\/\n+        if (node->type == XML_ELEMENT_NODE) {\n+            attr = node->properties;\n+            while (attr != NULL) {\n+                if (attr->ns != NULL) {\n+                    \/*\n+                     * initialize the cache if needed\n+                     *\/\n+                    if (sizeCache == 0) {\n+                        sizeCache = 10;\n+                        oldNs = (xmlNsPtr *) xmlMalloc(sizeCache *\n+                                                       sizeof(xmlNsPtr));\n+                        if (oldNs == NULL) {\n+                            xmlTreeErrMemory(\"fixing namespaces\");\n+                            return(-1);\n+                        }\n+                        newNs = (xmlNsPtr *) xmlMalloc(sizeCache *\n+                                                       sizeof(xmlNsPtr));\n+                        if (newNs == NULL) {\n+                            xmlTreeErrMemory(\"fixing namespaces\");\n+                            xmlFree(oldNs);\n+                            return(-1);\n+                        }\n+                    }\n+                    for (i = 0;i < nbCache;i++) {\n+                        if (oldNs[i] == attr->ns) {\n+                            attr->ns = newNs[i];\n+                            break;\n+                        }\n+                    }\n+                    if (i == nbCache) {\n+                        \/*\n+                         * OK we need to recreate a new namespace definition\n+                         *\/\n+                        n = xmlNewReconciledNs(doc, tree, attr->ns);\n+                        if (n != NULL) { \/* :-( what if else ??? *\/\n+                            \/*\n+                             * check if we need to grow the cache buffers.\n+                             *\/\n+                            if (sizeCache <= nbCache) {\n+                                sizeCache *= 2;\n+                                oldNs = (xmlNsPtr *) xmlRealloc(oldNs,\n+                                           sizeCache * sizeof(xmlNsPtr));\n+                                if (oldNs == NULL) {\n+                                    xmlTreeErrMemory(\"fixing namespaces\");\n+                                    xmlFree(newNs);\n+                                    return(-1);\n+                                }\n+                                newNs = (xmlNsPtr *) xmlRealloc(newNs,\n+                                           sizeCache * sizeof(xmlNsPtr));\n+                                if (newNs == NULL) {\n+                                    xmlTreeErrMemory(\"fixing namespaces\");\n+                                    xmlFree(oldNs);\n+                                    return(-1);\n+                                }\n+                            }\n+                            newNs[nbCache] = n;\n+                            oldNs[nbCache++] = attr->ns;\n+                            attr->ns = n;\n+                        }\n+                    }\n+                }\n+                attr = attr->next;\n+            }\n@@ -6483,1 +6493,0 @@\n-    }\n@@ -6485,3 +6494,3 @@\n-    \/*\n-     * Browse the full subtree, deep first\n-     *\/\n+        \/*\n+         * Browse the full subtree, deep first\n+         *\/\n@@ -6489,11 +6498,4 @@\n-        \/* deep first *\/\n-        node = node->children;\n-    } else if ((node != tree) && (node->next != NULL)) {\n-        \/* then siblings *\/\n-        node = node->next;\n-    } else if (node != tree) {\n-        \/* go up to parents->next if needed *\/\n-        while (node != tree) {\n-            if (node->parent != NULL)\n-            node = node->parent;\n-        if ((node != tree) && (node->next != NULL)) {\n+            \/* deep first *\/\n+            node = node->children;\n+        } else if ((node != tree) && (node->next != NULL)) {\n+            \/* then siblings *\/\n@@ -6501,0 +6503,18 @@\n+        } else if (node != tree) {\n+            \/* go up to parents->next if needed *\/\n+            while (node != tree) {\n+                if (node->parent != NULL)\n+                    node = node->parent;\n+                if ((node != tree) && (node->next != NULL)) {\n+                    node = node->next;\n+                    break;\n+                }\n+                if (node->parent == NULL) {\n+                    node = NULL;\n+                    break;\n+                }\n+            }\n+            \/* exit condition *\/\n+            if (node == tree)\n+                node = NULL;\n+        } else\n@@ -6502,11 +6522,0 @@\n-        }\n-        if (node->parent == NULL) {\n-            node = NULL;\n-            break;\n-        }\n-        }\n-        \/* exit condition *\/\n-        if (node == tree)\n-            node = NULL;\n-    } else\n-        break;\n@@ -6515,1 +6524,1 @@\n-    xmlFree(oldNs);\n+        xmlFree(oldNs);\n@@ -6517,1 +6526,1 @@\n-    xmlFree(newNs);\n+        xmlFree(newNs);\n@@ -6524,1 +6533,1 @@\n-               const xmlChar *nsName, int useDTD)\n+                       const xmlChar *nsName, int useDTD)\n@@ -6529,1 +6538,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6532,21 +6541,24 @@\n-    prop = node->properties;\n-    if (nsName == NULL) {\n-        \/*\n-        * We want the attr to be in no namespace.\n-        *\/\n-        do {\n-        if ((prop->ns == NULL) && xmlStrEqual(prop->name, name)) {\n-            return(prop);\n-        }\n-        prop = prop->next;\n-        } while (prop != NULL);\n-    } else {\n-        \/*\n-        * We want the attr to be in the specified namespace.\n-        *\/\n-        do {\n-        if ((prop->ns != NULL) && xmlStrEqual(prop->name, name) &&\n-            ((prop->ns->href == nsName) ||\n-             xmlStrEqual(prop->ns->href, nsName)))\n-        {\n-            return(prop);\n+        prop = node->properties;\n+        if (nsName == NULL) {\n+            \/*\n+            * We want the attr to be in no namespace.\n+            *\/\n+            do {\n+                if ((prop->ns == NULL) && xmlStrEqual(prop->name, name)) {\n+                    return(prop);\n+                }\n+                prop = prop->next;\n+            } while (prop != NULL);\n+        } else {\n+            \/*\n+            * We want the attr to be in the specified namespace.\n+            *\/\n+            do {\n+                if ((prop->ns != NULL) && xmlStrEqual(prop->name, name) &&\n+                    ((prop->ns->href == nsName) ||\n+                     xmlStrEqual(prop->ns->href, nsName)))\n+                {\n+                    return(prop);\n+                }\n+                prop = prop->next;\n+            } while (prop != NULL);\n@@ -6554,3 +6566,0 @@\n-        prop = prop->next;\n-        } while (prop != NULL);\n-    }\n@@ -6561,1 +6570,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6567,3 +6576,3 @@\n-    xmlDocPtr doc = node->doc;\n-    xmlAttributePtr attrDecl = NULL;\n-    xmlChar *elemQName, *tmpstr = NULL;\n+        xmlDocPtr doc = node->doc;\n+        xmlAttributePtr attrDecl = NULL;\n+        xmlChar *elemQName, *tmpstr = NULL;\n@@ -6571,13 +6580,0 @@\n-    \/*\n-    * We need the QName of the element for the DTD-lookup.\n-    *\/\n-    if ((node->ns != NULL) && (node->ns->prefix != NULL)) {\n-        tmpstr = xmlStrdup(node->ns->prefix);\n-        tmpstr = xmlStrcat(tmpstr, BAD_CAST \":\");\n-        tmpstr = xmlStrcat(tmpstr, node->name);\n-        if (tmpstr == NULL)\n-        return(NULL);\n-        elemQName = tmpstr;\n-    } else\n-        elemQName = (xmlChar *) node->name;\n-    if (nsName == NULL) {\n@@ -6585,1 +6581,1 @@\n-        * The common and nice case: Attr in no namespace.\n+        * We need the QName of the element for the DTD-lookup.\n@@ -6587,6 +6583,19 @@\n-        attrDecl = xmlGetDtdQAttrDesc(doc->intSubset,\n-        elemQName, name, NULL);\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n-        attrDecl = xmlGetDtdQAttrDesc(doc->extSubset,\n-            elemQName, name, NULL);\n-        }\n+        if ((node->ns != NULL) && (node->ns->prefix != NULL)) {\n+            tmpstr = xmlStrdup(node->ns->prefix);\n+            tmpstr = xmlStrcat(tmpstr, BAD_CAST \":\");\n+            tmpstr = xmlStrcat(tmpstr, node->name);\n+            if (tmpstr == NULL)\n+                return(NULL);\n+            elemQName = tmpstr;\n+        } else\n+            elemQName = (xmlChar *) node->name;\n+        if (nsName == NULL) {\n+            \/*\n+            * The common and nice case: Attr in no namespace.\n+            *\/\n+            attrDecl = xmlGetDtdQAttrDesc(doc->intSubset,\n+                elemQName, name, NULL);\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n+                attrDecl = xmlGetDtdQAttrDesc(doc->extSubset,\n+                    elemQName, name, NULL);\n+            }\n@@ -6594,11 +6603,11 @@\n-        \/*\n-        * The XML namespace must be bound to prefix 'xml'.\n-        *\/\n-        attrDecl = xmlGetDtdQAttrDesc(doc->intSubset,\n-        elemQName, name, BAD_CAST \"xml\");\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n-        attrDecl = xmlGetDtdQAttrDesc(doc->extSubset,\n-            elemQName, name, BAD_CAST \"xml\");\n-        }\n-    } else {\n-        xmlNsPtr *nsList, *cur;\n+            \/*\n+            * The XML namespace must be bound to prefix 'xml'.\n+            *\/\n+            attrDecl = xmlGetDtdQAttrDesc(doc->intSubset,\n+                elemQName, name, BAD_CAST \"xml\");\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n+                attrDecl = xmlGetDtdQAttrDesc(doc->extSubset,\n+                    elemQName, name, BAD_CAST \"xml\");\n+            }\n+        } else {\n+            xmlNsPtr *nsList, *cur;\n@@ -6606,22 +6615,9 @@\n-        \/*\n-        * The ugly case: Search using the prefixes of in-scope\n-        * ns-decls corresponding to @nsName.\n-        *\/\n-        nsList = xmlGetNsList(node->doc, node);\n-        if (nsList == NULL) {\n-        if (tmpstr != NULL)\n-            xmlFree(tmpstr);\n-        return(NULL);\n-        }\n-        cur = nsList;\n-        while (*cur != NULL) {\n-        if (xmlStrEqual((*cur)->href, nsName)) {\n-            attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elemQName,\n-            name, (*cur)->prefix);\n-            if (attrDecl)\n-            break;\n-            if (doc->extSubset != NULL) {\n-            attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elemQName,\n-                name, (*cur)->prefix);\n-            if (attrDecl)\n-                break;\n+            \/*\n+            * The ugly case: Search using the prefixes of in-scope\n+            * ns-decls corresponding to @nsName.\n+            *\/\n+            nsList = xmlGetNsList(node->doc, node);\n+            if (nsList == NULL) {\n+                if (tmpstr != NULL)\n+                    xmlFree(tmpstr);\n+                return(NULL);\n@@ -6629,0 +6625,17 @@\n+            cur = nsList;\n+            while (*cur != NULL) {\n+                if (xmlStrEqual((*cur)->href, nsName)) {\n+                    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elemQName,\n+                        name, (*cur)->prefix);\n+                    if (attrDecl)\n+                        break;\n+                    if (doc->extSubset != NULL) {\n+                        attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elemQName,\n+                            name, (*cur)->prefix);\n+                        if (attrDecl)\n+                            break;\n+                    }\n+                }\n+                cur++;\n+            }\n+            xmlFree(nsList);\n@@ -6630,11 +6643,7 @@\n-        cur++;\n-        }\n-        xmlFree(nsList);\n-    }\n-    if (tmpstr != NULL)\n-        xmlFree(tmpstr);\n-    \/*\n-    * Only default\/fixed attrs are relevant.\n-    *\/\n-    if ((attrDecl != NULL) && (attrDecl->defaultValue != NULL))\n-        return((xmlAttrPtr) attrDecl);\n+        if (tmpstr != NULL)\n+            xmlFree(tmpstr);\n+        \/*\n+        * Only default\/fixed attrs are relevant.\n+        *\/\n+        if ((attrDecl != NULL) && (attrDecl->defaultValue != NULL))\n+            return((xmlAttrPtr) attrDecl);\n@@ -6650,1 +6659,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6652,9 +6661,0 @@\n-    \/*\n-    * Note that we return at least the empty string.\n-    *   TODO: Do we really always want that?\n-    *\/\n-    if (prop->children != NULL) {\n-        if ((prop->children->next == NULL) &&\n-        ((prop->children->type == XML_TEXT_NODE) ||\n-        (prop->children->type == XML_CDATA_SECTION_NODE)))\n-        {\n@@ -6662,1 +6662,2 @@\n-        * Optimization for the common case: only 1 text node.\n+        * Note that we return at least the empty string.\n+        *   TODO: Do we really always want that?\n@@ -6664,3 +6665,11 @@\n-        return(xmlStrdup(prop->children->content));\n-        } else {\n-        xmlChar *ret;\n+        if (prop->children != NULL) {\n+            if ((prop->children->next == NULL) &&\n+                ((prop->children->type == XML_TEXT_NODE) ||\n+                (prop->children->type == XML_CDATA_SECTION_NODE)))\n+            {\n+                \/*\n+                * Optimization for the common case: only 1 text node.\n+                *\/\n+                return(xmlStrdup(prop->children->content));\n+            } else {\n+                xmlChar *ret;\n@@ -6668,3 +6677,4 @@\n-        ret = xmlNodeListGetString(prop->doc, prop->children, 1);\n-        if (ret != NULL)\n-            return(ret);\n+                ret = xmlNodeListGetString(prop->doc, prop->children, 1);\n+                if (ret != NULL)\n+                    return(ret);\n+            }\n@@ -6672,2 +6682,1 @@\n-    }\n-    return(xmlStrdup((xmlChar *)\"\"));\n+        return(xmlStrdup((xmlChar *)\"\"));\n@@ -6675,1 +6684,1 @@\n-    return(xmlStrdup(((xmlAttributePtr)prop)->defaultValue));\n+        return(xmlStrdup(((xmlAttributePtr)prop)->defaultValue));\n@@ -6705,1 +6714,1 @@\n-        return(prop);\n+            return(prop);\n@@ -6707,1 +6716,1 @@\n-    prop = prop->next;\n+        prop = prop->next;\n@@ -6719,3 +6728,3 @@\n-        attrDecl = xmlGetDtdAttrDesc(doc->intSubset, node->name, name);\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdAttrDesc(doc->extSubset, node->name, name);\n+            attrDecl = xmlGetDtdAttrDesc(doc->intSubset, node->name, name);\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdAttrDesc(doc->extSubset, node->name, name);\n@@ -6725,2 +6734,2 @@\n-        return((xmlAttrPtr) attrDecl);\n-    }\n+                return((xmlAttrPtr) attrDecl);\n+        }\n@@ -6775,1 +6784,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6800,1 +6809,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6825,1 +6834,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6845,1 +6854,1 @@\n-    return(-1);\n+        return(-1);\n@@ -6866,1 +6875,1 @@\n-    return(-1);\n+        return(-1);\n@@ -6894,1 +6903,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6902,6 +6911,6 @@\n-    xmlChar *prefix = xmlStrndup(name, len);\n-    ns = xmlSearchNs(node->doc, node, prefix);\n-    if (prefix != NULL)\n-        xmlFree(prefix);\n-    if (ns != NULL)\n-        return(xmlSetNsProp(node, ns, nqname, value));\n+        xmlChar *prefix = xmlStrndup(name, len);\n+        ns = xmlSearchNs(node->doc, node, prefix);\n+        if (prefix != NULL)\n+            xmlFree(prefix);\n+        if (ns != NULL)\n+            return(xmlSetNsProp(node, ns, nqname, value));\n@@ -6926,1 +6935,1 @@\n-         const xmlChar *value)\n+             const xmlChar *value)\n@@ -6931,1 +6940,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6934,16 +6943,10 @@\n-    \/*\n-    * Modify the attribute's value.\n-    *\/\n-    if (prop->atype == XML_ATTRIBUTE_ID) {\n-        xmlRemoveID(node->doc, prop);\n-        prop->atype = XML_ATTRIBUTE_ID;\n-    }\n-    if (prop->children != NULL)\n-        xmlFreeNodeList(prop->children);\n-    prop->children = NULL;\n-    prop->last = NULL;\n-    prop->ns = ns;\n-    if (value != NULL) {\n-        xmlNodePtr tmp;\n-\n-        prop->children = xmlNewDocText(node->doc, value);\n+        \/*\n+        * Modify the attribute's value.\n+        *\/\n+        if (prop->atype == XML_ATTRIBUTE_ID) {\n+            xmlRemoveID(node->doc, prop);\n+            prop->atype = XML_ATTRIBUTE_ID;\n+        }\n+        if (prop->children != NULL)\n+            xmlFreeNodeList(prop->children);\n+        prop->children = NULL;\n@@ -6951,6 +6954,13 @@\n-        tmp = prop->children;\n-        while (tmp != NULL) {\n-        tmp->parent = (xmlNodePtr) prop;\n-        if (tmp->next == NULL)\n-            prop->last = tmp;\n-        tmp = tmp->next;\n+        prop->ns = ns;\n+        if (value != NULL) {\n+            xmlNodePtr tmp;\n+\n+            prop->children = xmlNewDocText(node->doc, value);\n+            prop->last = NULL;\n+            tmp = prop->children;\n+            while (tmp != NULL) {\n+                tmp->parent = (xmlNodePtr) prop;\n+                if (tmp->next == NULL)\n+                    prop->last = tmp;\n+                tmp = tmp->next;\n+            }\n@@ -6958,4 +6968,3 @@\n-    }\n-    if (prop->atype == XML_ATTRIBUTE_ID)\n-        xmlAddID(NULL, node->doc, value, prop);\n-    return(prop);\n+        if (prop->atype == XML_ATTRIBUTE_ID)\n+            xmlAddID(NULL, node->doc, value, prop);\n+        return(prop);\n@@ -7002,1 +7011,1 @@\n-    return(0);\n+        return(0);\n@@ -7006,2 +7015,2 @@\n-    if (!IS_BLANK_CH(*cur)) return(0);\n-    cur++;\n+        if (!IS_BLANK_CH(*cur)) return(0);\n+        cur++;\n@@ -7030,2 +7039,2 @@\n-    (node->type != XML_COMMENT_NODE) &&\n-    (node->type != XML_PI_NODE)) {\n+        (node->type != XML_COMMENT_NODE) &&\n+        (node->type != XML_PI_NODE)) {\n@@ -7033,2 +7042,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"xmlTextConcat: node is not text nor CDATA\\n\");\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"xmlTextConcat: node is not text nor CDATA\\n\");\n@@ -7041,2 +7050,2 @@\n-        xmlDictOwns(node->doc->dict, node->content))) {\n-    node->content = xmlStrncatNew(node->content, content, len);\n+                xmlDictOwns(node->doc->dict, node->content))) {\n+        node->content = xmlStrncatNew(node->content, content, len);\n@@ -7053,3 +7062,3 @@\n- *                                  *\n- *          Output : to a FILE or in memory         *\n- *                                  *\n+ *                                                                      *\n+ *                      Output : to a FILE or in memory                 *\n+ *                                                                      *\n@@ -7070,1 +7079,1 @@\n-    xmlTreeErrMemory(\"creating buffer\");\n+        xmlTreeErrMemory(\"creating buffer\");\n@@ -7078,2 +7087,2 @@\n-    xmlTreeErrMemory(\"creating buffer\");\n-    xmlFree(ret);\n+        xmlTreeErrMemory(\"creating buffer\");\n+        xmlFree(ret);\n@@ -7100,1 +7109,1 @@\n-    xmlTreeErrMemory(\"creating buffer\");\n+        xmlTreeErrMemory(\"creating buffer\");\n@@ -7109,1 +7118,1 @@\n-        xmlTreeErrMemory(\"creating buffer\");\n+            xmlTreeErrMemory(\"creating buffer\");\n@@ -7115,1 +7124,1 @@\n-    ret->content = NULL;\n+        ret->content = NULL;\n@@ -7168,1 +7177,1 @@\n-    xmlTreeErrMemory(\"creating buffer\");\n+        xmlTreeErrMemory(\"creating buffer\");\n@@ -7191,1 +7200,1 @@\n-        \"xmlBufferSetAllocationScheme: buf == NULL\\n\");\n+                \"xmlBufferSetAllocationScheme: buf == NULL\\n\");\n@@ -7201,1 +7210,1 @@\n-    buf->alloc = scheme;\n+        buf->alloc = scheme;\n@@ -7216,1 +7225,1 @@\n-        \"xmlBufferFree: buf == NULL\\n\");\n+                \"xmlBufferFree: buf == NULL\\n\");\n@@ -7218,1 +7227,1 @@\n-    return;\n+        return;\n@@ -7248,1 +7257,1 @@\n-    buf->size += start_buf;\n+        buf->size += start_buf;\n@@ -7274,4 +7283,4 @@\n-    \/*\n-     * we just move the content pointer, but also make sure\n-     * the perceived buffer size has shrunk accordingly\n-     *\/\n+        \/*\n+         * we just move the content pointer, but also make sure\n+         * the perceived buffer size has shrunk accordingly\n+         *\/\n@@ -7279,1 +7288,1 @@\n-    buf->size -= len;\n+        buf->size -= len;\n@@ -7282,10 +7291,11 @@\n-     * sometimes though it maybe be better to really shrink\n-     * on IO buffers\n-     *\/\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n-        size_t start_buf = buf->content - buf->contentIO;\n-        if (start_buf >= buf->size) {\n-        memmove(buf->contentIO, &buf->content[0], buf->use);\n-        buf->content = buf->contentIO;\n-        buf->content[buf->use] = 0;\n-        buf->size += start_buf;\n+         * sometimes though it maybe be better to really shrink\n+         * on IO buffers\n+         *\/\n+        if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n+            size_t start_buf = buf->content - buf->contentIO;\n+            if (start_buf >= buf->size) {\n+                memmove(buf->contentIO, &buf->content[0], buf->use);\n+                buf->content = buf->contentIO;\n+                buf->content[buf->use] = 0;\n+                buf->size += start_buf;\n+            }\n@@ -7293,1 +7303,0 @@\n-    }\n@@ -7295,2 +7304,2 @@\n-    memmove(buf->content, &buf->content[len], buf->use);\n-    buf->content[buf->use] = 0;\n+        memmove(buf->content, &buf->content[len], buf->use);\n+        buf->content[buf->use] = 0;\n@@ -7338,7 +7347,7 @@\n-    newbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);\n-    if (newbuf == NULL) {\n-        xmlTreeErrMemory(\"growing buffer\");\n-        return(-1);\n-    }\n-    buf->contentIO = newbuf;\n-    buf->content = newbuf + start_buf;\n+        newbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);\n+        if (newbuf == NULL) {\n+            xmlTreeErrMemory(\"growing buffer\");\n+            return(-1);\n+        }\n+        buf->contentIO = newbuf;\n+        buf->content = newbuf + start_buf;\n@@ -7346,6 +7355,6 @@\n-    newbuf = (xmlChar *) xmlRealloc(buf->content, size);\n-    if (newbuf == NULL) {\n-        xmlTreeErrMemory(\"growing buffer\");\n-        return(-1);\n-    }\n-    buf->content = newbuf;\n+        newbuf = (xmlChar *) xmlRealloc(buf->content, size);\n+        if (newbuf == NULL) {\n+            xmlTreeErrMemory(\"growing buffer\");\n+            return(-1);\n+        }\n+        buf->content = newbuf;\n@@ -7372,1 +7381,1 @@\n-        \"xmlBufferDump: buf == NULL\\n\");\n+                \"xmlBufferDump: buf == NULL\\n\");\n@@ -7374,1 +7383,1 @@\n-    return(0);\n+        return(0);\n@@ -7379,1 +7388,1 @@\n-        \"xmlBufferDump: buf->content == NULL\\n\");\n+                \"xmlBufferDump: buf->content == NULL\\n\");\n@@ -7381,1 +7390,1 @@\n-    return(0);\n+        return(0);\n@@ -7384,1 +7393,1 @@\n-    file = stdout;\n+        file = stdout;\n@@ -7457,8 +7466,10 @@\n-    case XML_BUFFER_ALLOC_IO:\n-    case XML_BUFFER_ALLOC_DOUBLEIT:\n-        \/*take care of empty case*\/\n-        newSize = (buf->size ? buf->size : size + 10);\n-        while (size > newSize) {\n-            if (newSize > UINT_MAX \/ 2) {\n-                xmlTreeErrMemory(\"growing buffer\");\n-                return 0;\n+        case XML_BUFFER_ALLOC_IO:\n+        case XML_BUFFER_ALLOC_DOUBLEIT:\n+            \/*take care of empty case*\/\n+            newSize = (buf->size ? buf->size : size + 10);\n+            while (size > newSize) {\n+                if (newSize > UINT_MAX \/ 2) {\n+                    xmlTreeErrMemory(\"growing buffer\");\n+                    return 0;\n+                }\n+                newSize *= 2;\n@@ -7466,6 +7477,4 @@\n-            newSize *= 2;\n-        }\n-        break;\n-    case XML_BUFFER_ALLOC_EXACT:\n-        newSize = size+10;\n-        break;\n+            break;\n+        case XML_BUFFER_ALLOC_EXACT:\n+            newSize = size+10;\n+            break;\n@@ -7487,3 +7496,3 @@\n-    default:\n-        newSize = size+10;\n-        break;\n+        default:\n+            newSize = size+10;\n+            break;\n@@ -7496,10 +7505,13 @@\n-        \/* move data back to start *\/\n-        memmove(buf->contentIO, buf->content, buf->use);\n-        buf->content = buf->contentIO;\n-        buf->content[buf->use] = 0;\n-        buf->size += start_buf;\n-    } else {\n-        rebuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + newSize);\n-        if (rebuf == NULL) {\n-        xmlTreeErrMemory(\"growing buffer\");\n-        return 0;\n+            \/* move data back to start *\/\n+            memmove(buf->contentIO, buf->content, buf->use);\n+            buf->content = buf->contentIO;\n+            buf->content[buf->use] = 0;\n+            buf->size += start_buf;\n+        } else {\n+            rebuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + newSize);\n+            if (rebuf == NULL) {\n+                xmlTreeErrMemory(\"growing buffer\");\n+                return 0;\n+            }\n+            buf->contentIO = rebuf;\n+            buf->content = rebuf + start_buf;\n@@ -7507,3 +7519,0 @@\n-        buf->contentIO = rebuf;\n-        buf->content = rebuf + start_buf;\n-    }\n@@ -7511,4 +7520,4 @@\n-    if (buf->content == NULL) {\n-        rebuf = (xmlChar *) xmlMallocAtomic(newSize);\n-    } else if (buf->size - buf->use < 100) {\n-        rebuf = (xmlChar *) xmlRealloc(buf->content, newSize);\n+        if (buf->content == NULL) {\n+            rebuf = (xmlChar *) xmlMallocAtomic(newSize);\n+        } else if (buf->size - buf->use < 100) {\n+            rebuf = (xmlChar *) xmlRealloc(buf->content, newSize);\n@@ -7516,10 +7525,11 @@\n-        \/*\n-         * if we are reallocating a buffer far from being full, it's\n-         * better to make a new allocation and copy only the used range\n-         * and free the old one.\n-         *\/\n-        rebuf = (xmlChar *) xmlMallocAtomic(newSize);\n-        if (rebuf != NULL) {\n-        memcpy(rebuf, buf->content, buf->use);\n-        xmlFree(buf->content);\n-        rebuf[buf->use] = 0;\n+            \/*\n+             * if we are reallocating a buffer far from being full, it's\n+             * better to make a new allocation and copy only the used range\n+             * and free the old one.\n+             *\/\n+            rebuf = (xmlChar *) xmlMallocAtomic(newSize);\n+            if (rebuf != NULL) {\n+                memcpy(rebuf, buf->content, buf->use);\n+                xmlFree(buf->content);\n+                rebuf[buf->use] = 0;\n+            }\n@@ -7527,6 +7537,5 @@\n-    }\n-    if (rebuf == NULL) {\n-        xmlTreeErrMemory(\"growing buffer\");\n-        return 0;\n-    }\n-    buf->content = rebuf;\n+        if (rebuf == NULL) {\n+            xmlTreeErrMemory(\"growing buffer\");\n+            return 0;\n+        }\n+        buf->content = rebuf;\n@@ -7556,1 +7565,1 @@\n-    return -1;\n+        return -1;\n@@ -7562,1 +7571,1 @@\n-        \"xmlBufferAdd: len < 0\\n\");\n+                \"xmlBufferAdd: len < 0\\n\");\n@@ -7564,1 +7573,1 @@\n-    return -1;\n+        return -1;\n@@ -7577,1 +7586,1 @@\n-        xmlTreeErrMemory(\"growing buffer\");\n+            xmlTreeErrMemory(\"growing buffer\");\n@@ -7610,1 +7619,1 @@\n-        \"xmlBufferAddHead: str == NULL\\n\");\n+                \"xmlBufferAddHead: str == NULL\\n\");\n@@ -7612,1 +7621,1 @@\n-    return -1;\n+        return -1;\n@@ -7617,1 +7626,1 @@\n-        \"xmlBufferAddHead: len < 0\\n\");\n+                \"xmlBufferAddHead: len < 0\\n\");\n@@ -7619,1 +7628,1 @@\n-    return -1;\n+        return -1;\n@@ -7631,5 +7640,5 @@\n-    if (start_buf > (unsigned int) len) {\n-        \/*\n-         * We can add it in the space previously shrunk\n-         *\/\n-        buf->content -= len;\n+        if (start_buf > (unsigned int) len) {\n+            \/*\n+             * We can add it in the space previously shrunk\n+             *\/\n+            buf->content -= len;\n@@ -7637,4 +7646,4 @@\n-        buf->use += len;\n-        buf->size += len;\n-        return(0);\n-    }\n+            buf->use += len;\n+            buf->size += len;\n+            return(0);\n+        }\n@@ -7645,1 +7654,1 @@\n-        xmlTreeErrMemory(\"growing buffer\");\n+            xmlTreeErrMemory(\"growing buffer\");\n@@ -7696,1 +7705,1 @@\n-        \"xmlBufferCCat: str == NULL\\n\");\n+                \"xmlBufferCCat: str == NULL\\n\");\n@@ -7698,1 +7707,1 @@\n-    return -1;\n+        return -1;\n@@ -7703,1 +7712,1 @@\n-        xmlTreeErrMemory(\"growing buffer\");\n+                xmlTreeErrMemory(\"growing buffer\");\n@@ -7764,1 +7773,1 @@\n-        xmlGenericError(xmlGenericErrorContext,\n+            xmlGenericError(xmlGenericErrorContext,\n@@ -7767,1 +7776,1 @@\n-        xmlBufferCCat(buf, \"\\\"\");\n+            xmlBufferCCat(buf, \"\\\"\");\n@@ -7783,2 +7792,2 @@\n-        xmlBufferCCat(buf, \"\\\"\");\n-    }\n+            xmlBufferCCat(buf, \"\\\"\");\n+        }\n@@ -7786,1 +7795,1 @@\n-        xmlBufferCCat(buf, \"\\'\");\n+            xmlBufferCCat(buf, \"\\'\");\n@@ -7788,1 +7797,1 @@\n-        xmlBufferCCat(buf, \"\\'\");\n+            xmlBufferCCat(buf, \"\\'\");\n@@ -7889,1 +7898,1 @@\n-    (m)->first = NULL; \\\n+        (m)->first = NULL; \\\n@@ -7891,1 +7900,1 @@\n-    (m)->last->next = NULL; \\\n+        (m)->last->next = NULL; \\\n@@ -7907,1 +7916,1 @@\n-    return;\n+        return;\n@@ -7910,3 +7919,3 @@\n-    tmp = cur;\n-    cur = cur->next;\n-    xmlFree(tmp);\n+        tmp = cur;\n+        cur = cur->next;\n+        xmlFree(tmp);\n@@ -7916,3 +7925,3 @@\n-    tmp = cur;\n-    cur = cur->next;\n-    xmlFree(tmp);\n+        tmp = cur;\n+        cur = cur->next;\n+        xmlFree(tmp);\n@@ -7934,1 +7943,1 @@\n-               xmlNsPtr oldNs, xmlNsPtr newNs, int depth)\n+                       xmlNsPtr oldNs, xmlNsPtr newNs, int depth)\n@@ -7940,1 +7949,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -7942,1 +7951,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -7946,10 +7955,10 @@\n-    \/*\n-    * Create the ns-map.\n-    *\/\n-    map = (xmlNsMapPtr) xmlMalloc(sizeof(struct xmlNsMap));\n-    if (map == NULL) {\n-        xmlTreeErrMemory(\"allocating namespace map\");\n-        return (NULL);\n-    }\n-    memset(map, 0, sizeof(struct xmlNsMap));\n-    *nsmap = map;\n+        \/*\n+        * Create the ns-map.\n+        *\/\n+        map = (xmlNsMapPtr) xmlMalloc(sizeof(struct xmlNsMap));\n+        if (map == NULL) {\n+            xmlTreeErrMemory(\"allocating namespace map\");\n+            return (NULL);\n+        }\n+        memset(map, 0, sizeof(struct xmlNsMap));\n+        *nsmap = map;\n@@ -7959,6 +7968,6 @@\n-    \/*\n-    * Reuse an item from the pool.\n-    *\/\n-    ret = map->pool;\n-    map->pool = ret->next;\n-    memset(ret, 0, sizeof(struct xmlNsMapItem));\n+        \/*\n+        * Reuse an item from the pool.\n+        *\/\n+        ret = map->pool;\n+        map->pool = ret->next;\n+        memset(ret, 0, sizeof(struct xmlNsMapItem));\n@@ -7966,9 +7975,9 @@\n-    \/*\n-    * Create a new item.\n-    *\/\n-    ret = (xmlNsMapItemPtr) xmlMalloc(sizeof(struct xmlNsMapItem));\n-    if (ret == NULL) {\n-        xmlTreeErrMemory(\"allocating namespace map item\");\n-        return (NULL);\n-    }\n-    memset(ret, 0, sizeof(struct xmlNsMapItem));\n+        \/*\n+        * Create a new item.\n+        *\/\n+        ret = (xmlNsMapItemPtr) xmlMalloc(sizeof(struct xmlNsMapItem));\n+        if (ret == NULL) {\n+            xmlTreeErrMemory(\"allocating namespace map item\");\n+            return (NULL);\n+        }\n+        memset(ret, 0, sizeof(struct xmlNsMapItem));\n@@ -7978,5 +7987,5 @@\n-    \/*\n-    * First ever.\n-    *\/\n-    map->first = ret;\n-    map->last = ret;\n+        \/*\n+        * First ever.\n+        *\/\n+        map->first = ret;\n+        map->last = ret;\n@@ -7984,6 +7993,6 @@\n-    \/*\n-    * Append.\n-    *\/\n-    ret->prev = map->last;\n-    map->last->next = ret;\n-    map->last = ret;\n+        \/*\n+        * Append.\n+        *\/\n+        ret->prev = map->last;\n+        map->last->next = ret;\n+        map->last = ret;\n@@ -7991,7 +8000,7 @@\n-    \/*\n-    * Set on first position.\n-    *\/\n-    map->first->prev = ret;\n-    ret->next = map->first;\n-    map->first = ret;\n-    }\n+        \/*\n+        * Set on first position.\n+        *\/\n+        map->first->prev = ret;\n+        ret->next = map->first;\n+        map->first = ret;\n+    }\n@@ -8020,2 +8029,2 @@\n-           const xmlChar *nsName,\n-           const xmlChar *prefix)\n+                   const xmlChar *nsName,\n+                   const xmlChar *prefix)\n@@ -8026,1 +8035,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -8029,1 +8038,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -8031,10 +8040,1 @@\n-    \/* Reuse. *\/\n-    ns = ns->next;\n-    while (ns != NULL) {\n-        if (((ns->prefix == prefix) ||\n-        xmlStrEqual(ns->prefix, prefix)) &&\n-        xmlStrEqual(ns->href, nsName)) {\n-        return (ns);\n-        }\n-        if (ns->next == NULL)\n-        break;\n+        \/* Reuse. *\/\n@@ -8042,1 +8042,10 @@\n-    }\n+        while (ns != NULL) {\n+            if (((ns->prefix == prefix) ||\n+                xmlStrEqual(ns->prefix, prefix)) &&\n+                xmlStrEqual(ns->href, nsName)) {\n+                return (ns);\n+            }\n+            if (ns->next == NULL)\n+                break;\n+            ns = ns->next;\n+        }\n@@ -8066,2 +8075,2 @@\n-    xmlTreeErrMemory(\"allocating DOM-wrapper context\");\n-    return (NULL);\n+        xmlTreeErrMemory(\"allocating DOM-wrapper context\");\n+        return (NULL);\n@@ -8083,1 +8092,1 @@\n-    return;\n+        return;\n@@ -8085,1 +8094,1 @@\n-    xmlDOMWrapNsMapFree((xmlNsMapPtr) ctxt->namespaceMap);\n+        xmlDOMWrapNsMapFree((xmlNsMapPtr) ctxt->namespaceMap);\n@@ -8106,1 +8115,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -8108,9 +8117,9 @@\n-    xmlNsPtr ns;\n-    ns = nsList;\n-    do {\n-        if ((prefix == ns->prefix) ||\n-        xmlStrEqual(prefix, ns->prefix)) {\n-        return (ns);\n-        }\n-        ns = ns->next;\n-    } while (ns != NULL);\n+        xmlNsPtr ns;\n+        ns = nsList;\n+        do {\n+            if ((prefix == ns->prefix) ||\n+                xmlStrEqual(prefix, ns->prefix)) {\n+                return (ns);\n+            }\n+            ns = ns->next;\n+        } while (ns != NULL);\n@@ -8133,1 +8142,1 @@\n-                xmlNodePtr node)\n+                                xmlNodePtr node)\n@@ -8141,1 +8150,1 @@\n-    return (-1);\n+        return (-1);\n@@ -8149,16 +8158,28 @@\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        if (cur->nsDef != NULL) {\n-        ns = cur->nsDef;\n-        do {\n-            shadowed = 0;\n-            if (XML_NSMAP_NOTEMPTY(*map)) {\n-            \/*\n-            * Skip shadowed prefixes.\n-            *\/\n-            XML_NSMAP_FOREACH(*map, mi) {\n-                if ((ns->prefix == mi->newNs->prefix) ||\n-                xmlStrEqual(ns->prefix, mi->newNs->prefix)) {\n-                shadowed = 1;\n-                break;\n-                }\n-            }\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            if (cur->nsDef != NULL) {\n+                ns = cur->nsDef;\n+                do {\n+                    shadowed = 0;\n+                    if (XML_NSMAP_NOTEMPTY(*map)) {\n+                        \/*\n+                        * Skip shadowed prefixes.\n+                        *\/\n+                        XML_NSMAP_FOREACH(*map, mi) {\n+                            if ((ns->prefix == mi->newNs->prefix) ||\n+                                xmlStrEqual(ns->prefix, mi->newNs->prefix)) {\n+                                shadowed = 1;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    \/*\n+                    * Insert mapping.\n+                    *\/\n+                    mi = xmlDOMWrapNsMapAddItem(map, 0, NULL,\n+                        ns, XML_TREE_NSMAP_PARENT);\n+                    if (mi == NULL)\n+                        return (-1);\n+                    if (shadowed)\n+                        mi->shadowDepth = 0;\n+                    ns = ns->next;\n+                } while (ns != NULL);\n@@ -8166,11 +8187,0 @@\n-            \/*\n-            * Insert mapping.\n-            *\/\n-            mi = xmlDOMWrapNsMapAddItem(map, 0, NULL,\n-            ns, XML_TREE_NSMAP_PARENT);\n-            if (mi == NULL)\n-            return (-1);\n-            if (shadowed)\n-            mi->shadowDepth = 0;\n-            ns = ns->next;\n-        } while (ns != NULL);\n@@ -8178,2 +8188,1 @@\n-    }\n-    cur = cur->parent;\n+        cur = cur->parent;\n@@ -8190,10 +8199,10 @@\n-    if (destDoc->dict) { \\\n-        const xmlChar *old = str;   \\\n-        str = xmlDictLookup(destDoc->dict, str, -1); \\\n-        if ((sourceDoc == NULL) || (sourceDoc->dict == NULL) || \\\n-            (!xmlDictOwns(sourceDoc->dict, old))) \\\n-        xmlFree((char *)old); \\\n-    } else if ((sourceDoc) && (sourceDoc->dict) && \\\n-        xmlDictOwns(sourceDoc->dict, str)) { \\\n-        str = BAD_CAST xmlStrdup(str); \\\n-    } \\\n+        if (destDoc->dict) { \\\n+            const xmlChar *old = str;   \\\n+            str = xmlDictLookup(destDoc->dict, str, -1); \\\n+            if ((sourceDoc == NULL) || (sourceDoc->dict == NULL) || \\\n+                (!xmlDictOwns(sourceDoc->dict, old))) \\\n+                xmlFree((char *)old); \\\n+        } else if ((sourceDoc) && (sourceDoc->dict) && \\\n+            xmlDictOwns(sourceDoc->dict, str)) { \\\n+            str = BAD_CAST xmlStrdup(str); \\\n+        } \\\n@@ -8208,7 +8217,7 @@\n-    (sourceDoc->dict != NULL) && \\\n-    xmlDictOwns(sourceDoc->dict, cur->content)) { \\\n-    if (destDoc->dict) \\\n-        cur->content = (xmlChar *) \\\n-        xmlDictLookup(destDoc->dict, cur->content, -1); \\\n-    else \\\n-        cur->content = xmlStrdup(BAD_CAST cur->content); \\\n+        (sourceDoc->dict != NULL) && \\\n+        xmlDictOwns(sourceDoc->dict, cur->content)) { \\\n+        if (destDoc->dict) \\\n+            cur->content = (xmlChar *) \\\n+                xmlDictLookup(destDoc->dict, cur->content, -1); \\\n+        else \\\n+            cur->content = xmlStrdup(BAD_CAST cur->content); \\\n@@ -8226,1 +8235,1 @@\n-            xmlNsPtr oldNs, xmlNsPtr newNs)\n+                        xmlNsPtr oldNs, xmlNsPtr newNs)\n@@ -8229,7 +8238,7 @@\n-    *list = (xmlNsPtr *) xmlMalloc(6 * sizeof(xmlNsPtr));\n-    if (*list == NULL) {\n-        xmlTreeErrMemory(\"alloc ns map item\");\n-        return(-1);\n-    }\n-    *size = 3;\n-    *number = 0;\n+        *list = (xmlNsPtr *) xmlMalloc(6 * sizeof(xmlNsPtr));\n+        if (*list == NULL) {\n+            xmlTreeErrMemory(\"alloc ns map item\");\n+            return(-1);\n+        }\n+        *size = 3;\n+        *number = 0;\n@@ -8237,7 +8246,7 @@\n-    *size *= 2;\n-    *list = (xmlNsPtr *) xmlRealloc(*list,\n-        (*size) * 2 * sizeof(xmlNsPtr));\n-    if (*list == NULL) {\n-        xmlTreeErrMemory(\"realloc ns map item\");\n-        return(-1);\n-    }\n+        *size *= 2;\n+        *list = (xmlNsPtr *) xmlRealloc(*list,\n+            (*size) * 2 * sizeof(xmlNsPtr));\n+        if (*list == NULL) {\n+            xmlTreeErrMemory(\"realloc ns map item\");\n+            return(-1);\n+        }\n@@ -8270,1 +8279,1 @@\n-             xmlNodePtr node, int options ATTRIBUTE_UNUSED)\n+                     xmlNodePtr node, int options ATTRIBUTE_UNUSED)\n@@ -8277,1 +8286,1 @@\n-    return (-1);\n+        return (-1);\n@@ -8281,1 +8290,1 @@\n-    return (0);\n+        return (0);\n@@ -8284,12 +8293,12 @@\n-    case XML_TEXT_NODE:\n-    case XML_CDATA_SECTION_NODE:\n-    case XML_ENTITY_REF_NODE:\n-    case XML_PI_NODE:\n-    case XML_COMMENT_NODE:\n-        xmlUnlinkNode(node);\n-        return (0);\n-    case XML_ELEMENT_NODE:\n-    case XML_ATTRIBUTE_NODE:\n-        break;\n-    default:\n-        return (1);\n+        case XML_TEXT_NODE:\n+        case XML_CDATA_SECTION_NODE:\n+        case XML_ENTITY_REF_NODE:\n+        case XML_PI_NODE:\n+        case XML_COMMENT_NODE:\n+            xmlUnlinkNode(node);\n+            return (0);\n+        case XML_ELEMENT_NODE:\n+        case XML_ATTRIBUTE_NODE:\n+            break;\n+        default:\n+            return (1);\n@@ -8302,11 +8311,11 @@\n-    switch (node->type) {\n-        case XML_ELEMENT_NODE:\n-        if ((ctxt == NULL) && (node->nsDef != NULL)) {\n-            ns = node->nsDef;\n-            do {\n-            if (xmlDOMWrapNSNormAddNsMapItem2(&list, &sizeList,\n-                &nbList, ns, ns) == -1)\n-                goto internal_error;\n-            ns = ns->next;\n-            } while (ns != NULL);\n-        }\n+        switch (node->type) {\n+            case XML_ELEMENT_NODE:\n+                if ((ctxt == NULL) && (node->nsDef != NULL)) {\n+                    ns = node->nsDef;\n+                    do {\n+                        if (xmlDOMWrapNSNormAddNsMapItem2(&list, &sizeList,\n+                            &nbList, ns, ns) == -1)\n+                            goto internal_error;\n+                        ns = ns->next;\n+                    } while (ns != NULL);\n+                }\n@@ -8314,10 +8323,36 @@\n-        case XML_ATTRIBUTE_NODE:\n-        if (node->ns != NULL) {\n-            \/*\n-            * Find a mapping.\n-            *\/\n-            if (list != NULL) {\n-            for (i = 0, j = 0; i < nbList; i++, j += 2) {\n-                if (node->ns == list[j]) {\n-                node->ns = list[++j];\n-                goto next_node;\n+            case XML_ATTRIBUTE_NODE:\n+                if (node->ns != NULL) {\n+                    \/*\n+                    * Find a mapping.\n+                    *\/\n+                    if (list != NULL) {\n+                        for (i = 0, j = 0; i < nbList; i++, j += 2) {\n+                            if (node->ns == list[j]) {\n+                                node->ns = list[++j];\n+                                goto next_node;\n+                            }\n+                        }\n+                    }\n+                    ns = NULL;\n+                    if (ctxt != NULL) {\n+                        \/*\n+                        * User defined.\n+                        *\/\n+                    } else {\n+                        \/*\n+                        * Add to doc's oldNs.\n+                        *\/\n+                        ns = xmlDOMWrapStoreNs(doc, node->ns->href,\n+                            node->ns->prefix);\n+                        if (ns == NULL)\n+                            goto internal_error;\n+                    }\n+                    if (ns != NULL) {\n+                        \/*\n+                        * Add mapping.\n+                        *\/\n+                        if (xmlDOMWrapNSNormAddNsMapItem2(&list, &sizeList,\n+                            &nbList, node->ns, ns) == -1)\n+                            goto internal_error;\n+                    }\n+                    node->ns = ns;\n@@ -8325,25 +8360,8 @@\n-            }\n-            }\n-            ns = NULL;\n-            if (ctxt != NULL) {\n-            \/*\n-            * User defined.\n-            *\/\n-            } else {\n-            \/*\n-            * Add to doc's oldNs.\n-            *\/\n-            ns = xmlDOMWrapStoreNs(doc, node->ns->href,\n-                node->ns->prefix);\n-            if (ns == NULL)\n-                goto internal_error;\n-            }\n-            if (ns != NULL) {\n-            \/*\n-            * Add mapping.\n-            *\/\n-            if (xmlDOMWrapNSNormAddNsMapItem2(&list, &sizeList,\n-                &nbList, node->ns, ns) == -1)\n-                goto internal_error;\n-            }\n-            node->ns = ns;\n+                if ((node->type == XML_ELEMENT_NODE) &&\n+                    (node->properties != NULL)) {\n+                    node = (xmlNodePtr) node->properties;\n+                    continue;\n+                }\n+                break;\n+            default:\n+                goto next_sibling;\n@@ -8351,0 +8369,1 @@\n+next_node:\n@@ -8352,2 +8371,2 @@\n-            (node->properties != NULL)) {\n-            node = (xmlNodePtr) node->properties;\n+            (node->children != NULL)) {\n+            node = node->children;\n@@ -8356,10 +8375,0 @@\n-        break;\n-        default:\n-        goto next_sibling;\n-    }\n-next_node:\n-    if ((node->type == XML_ELEMENT_NODE) &&\n-        (node->children != NULL)) {\n-        node = node->children;\n-        continue;\n-    }\n@@ -8367,8 +8376,8 @@\n-    if (node == NULL)\n-        break;\n-    if (node->next != NULL)\n-        node = node->next;\n-    else {\n-        node = node->parent;\n-        goto next_sibling;\n-    }\n+        if (node == NULL)\n+            break;\n+        if (node->next != NULL)\n+            node = node->next;\n+        else {\n+            node = node->parent;\n+            goto next_sibling;\n+        }\n@@ -8378,1 +8387,1 @@\n-    xmlFree(list);\n+        xmlFree(list);\n@@ -8383,1 +8392,1 @@\n-    xmlFree(list);\n+        xmlFree(list);\n@@ -8403,2 +8412,2 @@\n-                 const xmlChar* nsName,\n-                 xmlNsPtr *retNs, int prefixed)\n+                             const xmlChar* nsName,\n+                             xmlNsPtr *retNs, int prefixed)\n@@ -8410,1 +8419,1 @@\n-    return (-1);\n+        return (-1);\n@@ -8416,4 +8425,4 @@\n-    *retNs = xmlTreeEnsureXMLDecl(doc);\n-    if (*retNs == NULL)\n-        return (-1);\n-    return (1);\n+        *retNs = xmlTreeEnsureXMLDecl(doc);\n+        if (*retNs == NULL)\n+            return (-1);\n+        return (1);\n@@ -8423,20 +8432,55 @@\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        if (cur->nsDef != NULL) {\n-        for (ns = cur->nsDef; ns != NULL; ns = ns->next) {\n-            if (prefixed && (ns->prefix == NULL))\n-            continue;\n-            if (prev != NULL) {\n-            \/*\n-            * Check the last level of ns-decls for a\n-            * shadowing prefix.\n-            *\/\n-            prevns = prev->nsDef;\n-            do {\n-                if ((prevns->prefix == ns->prefix) ||\n-                ((prevns->prefix != NULL) &&\n-                (ns->prefix != NULL) &&\n-                xmlStrEqual(prevns->prefix, ns->prefix))) {\n-                \/*\n-                * Shadowed.\n-                *\/\n-                break;\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            if (cur->nsDef != NULL) {\n+                for (ns = cur->nsDef; ns != NULL; ns = ns->next) {\n+                    if (prefixed && (ns->prefix == NULL))\n+                        continue;\n+                    if (prev != NULL) {\n+                        \/*\n+                        * Check the last level of ns-decls for a\n+                        * shadowing prefix.\n+                        *\/\n+                        prevns = prev->nsDef;\n+                        do {\n+                            if ((prevns->prefix == ns->prefix) ||\n+                                ((prevns->prefix != NULL) &&\n+                                (ns->prefix != NULL) &&\n+                                xmlStrEqual(prevns->prefix, ns->prefix))) {\n+                                \/*\n+                                * Shadowed.\n+                                *\/\n+                                break;\n+                            }\n+                            prevns = prevns->next;\n+                        } while (prevns != NULL);\n+                        if (prevns != NULL)\n+                            continue;\n+                    }\n+                    \/*\n+                    * Ns-name comparison.\n+                    *\/\n+                    if ((nsName == ns->href) ||\n+                        xmlStrEqual(nsName, ns->href)) {\n+                        \/*\n+                        * At this point the prefix can only be shadowed,\n+                        * if we are the the (at least) 3rd level of\n+                        * ns-decls.\n+                        *\/\n+                        if (out) {\n+                            int ret;\n+\n+                            ret = xmlNsInScope(doc, node, prev, ns->prefix);\n+                            if (ret < 0)\n+                                return (-1);\n+                            \/*\n+                            * TODO: Should we try to find a matching ns-name\n+                            * only once? This here keeps on searching.\n+                            * I think we should try further since, there might\n+                            * be an other matching ns-decl with an unshadowed\n+                            * prefix.\n+                            *\/\n+                            if (! ret)\n+                                continue;\n+                        }\n+                        *retNs = ns;\n+                        return (1);\n+                    }\n@@ -8444,33 +8488,2 @@\n-                prevns = prevns->next;\n-            } while (prevns != NULL);\n-            if (prevns != NULL)\n-                continue;\n-            }\n-            \/*\n-            * Ns-name comparison.\n-            *\/\n-            if ((nsName == ns->href) ||\n-            xmlStrEqual(nsName, ns->href)) {\n-            \/*\n-            * At this point the prefix can only be shadowed,\n-            * if we are the the (at least) 3rd level of\n-            * ns-decls.\n-            *\/\n-            if (out) {\n-                int ret;\n-\n-                ret = xmlNsInScope(doc, node, prev, ns->prefix);\n-                if (ret < 0)\n-                return (-1);\n-                \/*\n-                * TODO: Should we try to find a matching ns-name\n-                * only once? This here keeps on searching.\n-                * I think we should try further since, there might\n-                * be an other matching ns-decl with an unshadowed\n-                * prefix.\n-                *\/\n-                if (! ret)\n-                continue;\n-            }\n-            *retNs = ns;\n-            return (1);\n+                out = prev;\n+                prev = cur;\n@@ -8478,5 +8491,1 @@\n-        }\n-        out = prev;\n-        prev = cur;\n-        }\n-    } else if ((cur->type == XML_ENTITY_NODE) ||\n+        } else if ((cur->type == XML_ENTITY_NODE) ||\n@@ -8484,2 +8493,2 @@\n-        return (0);\n-    cur = cur->parent;\n+            return (0);\n+        cur = cur->parent;\n@@ -8505,2 +8514,2 @@\n-              const xmlChar* prefix,\n-              xmlNsPtr *retNs)\n+                          const xmlChar* prefix,\n+                          xmlNsPtr *retNs)\n@@ -8515,1 +8524,1 @@\n-    *retNs = NULL;\n+        *retNs = NULL;\n@@ -8517,6 +8526,6 @@\n-    if (retNs) {\n-        *retNs = xmlTreeEnsureXMLDecl(doc);\n-        if (*retNs == NULL)\n-        return (-1);\n-    }\n-    return (1);\n+        if (retNs) {\n+            *retNs = xmlTreeEnsureXMLDecl(doc);\n+            if (*retNs == NULL)\n+                return (-1);\n+        }\n+        return (1);\n@@ -8526,15 +8535,18 @@\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        if (cur->nsDef != NULL) {\n-        ns = cur->nsDef;\n-        do {\n-            if ((prefix == ns->prefix) ||\n-            xmlStrEqual(prefix, ns->prefix))\n-            {\n-            \/*\n-            * Disabled namespaces, e.g. xmlns:abc=\"\".\n-            *\/\n-            if (ns->href == NULL)\n-                return(0);\n-            if (retNs)\n-                *retNs = ns;\n-            return (1);\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            if (cur->nsDef != NULL) {\n+                ns = cur->nsDef;\n+                do {\n+                    if ((prefix == ns->prefix) ||\n+                        xmlStrEqual(prefix, ns->prefix))\n+                    {\n+                        \/*\n+                        * Disabled namespaces, e.g. xmlns:abc=\"\".\n+                        *\/\n+                        if (ns->href == NULL)\n+                            return(0);\n+                        if (retNs)\n+                            *retNs = ns;\n+                        return (1);\n+                    }\n+                    ns = ns->next;\n+                } while (ns != NULL);\n@@ -8542,4 +8554,1 @@\n-            ns = ns->next;\n-        } while (ns != NULL);\n-        }\n-    } else if ((cur->type == XML_ENTITY_NODE) ||\n+        } else if ((cur->type == XML_ENTITY_NODE) ||\n@@ -8547,2 +8556,2 @@\n-        return (0);\n-    cur = cur->parent;\n+            return (0);\n+        cur = cur->parent;\n@@ -8570,4 +8579,4 @@\n-                xmlNodePtr elem,\n-                const xmlChar *nsName,\n-                const xmlChar *prefix,\n-                int checkShadow)\n+                                xmlNodePtr elem,\n+                                const xmlChar *nsName,\n+                                const xmlChar *prefix,\n+                                int checkShadow)\n@@ -8588,8 +8597,0 @@\n-    \/*\n-    * Lookup whether the prefix is unused in elem's ns-decls.\n-    *\/\n-    if ((elem->nsDef != NULL) &&\n-        (xmlTreeNSListLookupByPrefix(elem->nsDef, pref) != NULL))\n-        goto ns_next_prefix;\n-    if (checkShadow && elem->parent &&\n-        ((xmlNodePtr) elem->parent->doc != elem->parent)) {\n@@ -8597,1 +8598,1 @@\n-        * Does it shadow ancestor ns-decls?\n+        * Lookup whether the prefix is unused in elem's ns-decls.\n@@ -8599,15 +8600,23 @@\n-        if (xmlSearchNsByPrefixStrict(doc, elem->parent, pref, NULL) == 1)\n-        goto ns_next_prefix;\n-    }\n-    ret = xmlNewNs(NULL, nsName, pref);\n-    if (ret == NULL)\n-        return (NULL);\n-    if (elem->nsDef == NULL)\n-        elem->nsDef = ret;\n-    else {\n-        xmlNsPtr ns2 = elem->nsDef;\n-        while (ns2->next != NULL)\n-        ns2 = ns2->next;\n-        ns2->next = ret;\n-    }\n-    return (ret);\n+        if ((elem->nsDef != NULL) &&\n+            (xmlTreeNSListLookupByPrefix(elem->nsDef, pref) != NULL))\n+            goto ns_next_prefix;\n+        if (checkShadow && elem->parent &&\n+            ((xmlNodePtr) elem->parent->doc != elem->parent)) {\n+            \/*\n+            * Does it shadow ancestor ns-decls?\n+            *\/\n+            if (xmlSearchNsByPrefixStrict(doc, elem->parent, pref, NULL) == 1)\n+                goto ns_next_prefix;\n+        }\n+        ret = xmlNewNs(NULL, nsName, pref);\n+        if (ret == NULL)\n+            return (NULL);\n+        if (elem->nsDef == NULL)\n+            elem->nsDef = ret;\n+        else {\n+            xmlNsPtr ns2 = elem->nsDef;\n+            while (ns2->next != NULL)\n+                ns2 = ns2->next;\n+            ns2->next = ret;\n+        }\n+        return (ret);\n@@ -8615,10 +8624,10 @@\n-    counter++;\n-    if (counter > 1000)\n-        return (NULL);\n-    if (prefix == NULL) {\n-        snprintf((char *) buf, sizeof(buf),\n-        \"ns_%d\", counter);\n-    } else\n-        snprintf((char *) buf, sizeof(buf),\n-        \"%.30s_%d\", (char *)prefix, counter);\n-    pref = BAD_CAST buf;\n+        counter++;\n+        if (counter > 1000)\n+            return (NULL);\n+        if (prefix == NULL) {\n+            snprintf((char *) buf, sizeof(buf),\n+                \"ns_%d\", counter);\n+        } else\n+            snprintf((char *) buf, sizeof(buf),\n+            \"%.30s_%d\", (char *)prefix, counter);\n+        pref = BAD_CAST buf;\n@@ -8649,8 +8658,8 @@\n-                   xmlNodePtr elem,\n-                   xmlNsPtr ns,\n-                   xmlNsPtr *retNs,\n-                   xmlNsMapPtr *nsMap,\n-\n-                   int depth,\n-                   int ancestorsOnly,\n-                   int prefixed)\n+                                   xmlNodePtr elem,\n+                                   xmlNsPtr ns,\n+                                   xmlNsPtr *retNs,\n+                                   xmlNsMapPtr *nsMap,\n+\n+                                   int depth,\n+                                   int ancestorsOnly,\n+                                   int prefixed)\n@@ -8661,2 +8670,2 @@\n-    (nsMap == NULL))\n-    return (-1);\n+        (nsMap == NULL))\n+        return (-1);\n@@ -8669,7 +8678,7 @@\n-    \/*\n-    * Insert XML namespace mapping.\n-    *\/\n-    *retNs = xmlTreeEnsureXMLDecl(doc);\n-    if (*retNs == NULL)\n-        return (-1);\n-    return (0);\n+        \/*\n+        * Insert XML namespace mapping.\n+        *\/\n+        *retNs = xmlTreeEnsureXMLDecl(doc);\n+        if (*retNs == NULL)\n+            return (-1);\n+        return (0);\n@@ -8682,1 +8691,1 @@\n-    (! (ancestorsOnly && (elem == NULL))))\n+        (! (ancestorsOnly && (elem == NULL))))\n@@ -8684,5 +8693,0 @@\n-    \/*\n-    * Try to find an equal ns-name in in-scope ns-decls.\n-    *\/\n-    XML_NSMAP_FOREACH(*nsMap, mi) {\n-        if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n@@ -8690,4 +8694,1 @@\n-        * ancestorsOnly: This should be turned on to gain speed,\n-        * if one knows that the branch itself was already\n-        * ns-wellformed and no stale references existed.\n-        * I.e. it searches in the ancestor axis only.\n+        * Try to find an equal ns-name in in-scope ns-decls.\n@@ -8695,15 +8696,24 @@\n-        ((! ancestorsOnly) || (mi->depth == XML_TREE_NSMAP_PARENT)) &&\n-        \/* Skip shadowed prefixes. *\/\n-        (mi->shadowDepth == -1) &&\n-        \/* Skip xmlns=\"\" or xmlns:foo=\"\". *\/\n-        ((mi->newNs->href != NULL) &&\n-        (mi->newNs->href[0] != 0)) &&\n-        \/* Ensure a prefix if wanted. *\/\n-        ((! prefixed) || (mi->newNs->prefix != NULL)) &&\n-        \/* Equal ns name *\/\n-        ((mi->newNs->href == ns->href) ||\n-        xmlStrEqual(mi->newNs->href, ns->href))) {\n-        \/* Set the mapping. *\/\n-        mi->oldNs = ns;\n-        *retNs = mi->newNs;\n-        return (0);\n+        XML_NSMAP_FOREACH(*nsMap, mi) {\n+            if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n+                \/*\n+                * ancestorsOnly: This should be turned on to gain speed,\n+                * if one knows that the branch itself was already\n+                * ns-wellformed and no stale references existed.\n+                * I.e. it searches in the ancestor axis only.\n+                *\/\n+                ((! ancestorsOnly) || (mi->depth == XML_TREE_NSMAP_PARENT)) &&\n+                \/* Skip shadowed prefixes. *\/\n+                (mi->shadowDepth == -1) &&\n+                \/* Skip xmlns=\"\" or xmlns:foo=\"\". *\/\n+                ((mi->newNs->href != NULL) &&\n+                (mi->newNs->href[0] != 0)) &&\n+                \/* Ensure a prefix if wanted. *\/\n+                ((! prefixed) || (mi->newNs->prefix != NULL)) &&\n+                \/* Equal ns name *\/\n+                ((mi->newNs->href == ns->href) ||\n+                xmlStrEqual(mi->newNs->href, ns->href))) {\n+                \/* Set the mapping. *\/\n+                mi->oldNs = ns;\n+                *retNs = mi->newNs;\n+                return (0);\n+            }\n@@ -8712,1 +8722,0 @@\n-    }\n@@ -8717,1 +8726,1 @@\n-    xmlNsPtr tmpns;\n+        xmlNsPtr tmpns;\n@@ -8719,15 +8728,15 @@\n-    \/*\n-    * Store ns-decls in \"oldNs\" of the document-node.\n-    *\/\n-    tmpns = xmlDOMWrapStoreNs(doc, ns->href, ns->prefix);\n-    if (tmpns == NULL)\n-        return (-1);\n-    \/*\n-    * Insert mapping.\n-    *\/\n-    if (xmlDOMWrapNsMapAddItem(nsMap, -1, ns,\n-        tmpns, XML_TREE_NSMAP_DOC) == NULL) {\n-        xmlFreeNs(tmpns);\n-        return (-1);\n-    }\n-    *retNs = tmpns;\n+        \/*\n+        * Store ns-decls in \"oldNs\" of the document-node.\n+        *\/\n+        tmpns = xmlDOMWrapStoreNs(doc, ns->href, ns->prefix);\n+        if (tmpns == NULL)\n+            return (-1);\n+        \/*\n+        * Insert mapping.\n+        *\/\n+        if (xmlDOMWrapNsMapAddItem(nsMap, -1, ns,\n+                tmpns, XML_TREE_NSMAP_DOC) == NULL) {\n+            xmlFreeNs(tmpns);\n+            return (-1);\n+        }\n+        *retNs = tmpns;\n@@ -8735,1 +8744,1 @@\n-    xmlNsPtr tmpns;\n+        xmlNsPtr tmpns;\n@@ -8737,4 +8746,4 @@\n-    tmpns = xmlDOMWrapNSNormDeclareNsForced(doc, elem, ns->href,\n-        ns->prefix, 0);\n-    if (tmpns == NULL)\n-        return (-1);\n+        tmpns = xmlDOMWrapNSNormDeclareNsForced(doc, elem, ns->href,\n+            ns->prefix, 0);\n+        if (tmpns == NULL)\n+            return (-1);\n@@ -8742,9 +8751,1 @@\n-    if (*nsMap != NULL) {\n-        \/*\n-        * Does it shadow ancestor ns-decls?\n-        *\/\n-        XML_NSMAP_FOREACH(*nsMap, mi) {\n-        if ((mi->depth < depth) &&\n-            (mi->shadowDepth == -1) &&\n-            ((ns->prefix == mi->newNs->prefix) ||\n-            xmlStrEqual(ns->prefix, mi->newNs->prefix))) {\n+        if (*nsMap != NULL) {\n@@ -8752,1 +8753,1 @@\n-            * Shadows.\n+            * Does it shadow ancestor ns-decls?\n@@ -8754,10 +8755,18 @@\n-            mi->shadowDepth = depth;\n-            break;\n-        }\n-        }\n-    }\n-    if (xmlDOMWrapNsMapAddItem(nsMap, -1, ns, tmpns, depth) == NULL) {\n-        xmlFreeNs(tmpns);\n-        return (-1);\n-    }\n-    *retNs = tmpns;\n+            XML_NSMAP_FOREACH(*nsMap, mi) {\n+                if ((mi->depth < depth) &&\n+                    (mi->shadowDepth == -1) &&\n+                    ((ns->prefix == mi->newNs->prefix) ||\n+                    xmlStrEqual(ns->prefix, mi->newNs->prefix))) {\n+                    \/*\n+                    * Shadows.\n+                    *\/\n+                    mi->shadowDepth = depth;\n+                    break;\n+                }\n+            }\n+        }\n+        if (xmlDOMWrapNsMapAddItem(nsMap, -1, ns, tmpns, depth) == NULL) {\n+            xmlFreeNs(tmpns);\n+            return (-1);\n+        }\n+        *retNs = tmpns;\n@@ -8791,2 +8800,2 @@\n-                  xmlNodePtr elem,\n-                  int options)\n+                              xmlNodePtr elem,\n+                              int options)\n@@ -8803,1 +8812,1 @@\n-    ((xmlDOMReconcileNSOptions) options & XML_DOM_RECONNS_REMOVEREDUND) ? 1 : 0;\n+        ((xmlDOMReconcileNSOptions) options & XML_DOM_RECONNS_REMOVEREDUND) ? 1 : 0;\n@@ -8808,2 +8817,2 @@\n-    (elem->type != XML_ELEMENT_NODE))\n-    return (-1);\n+        (elem->type != XML_ELEMENT_NODE))\n+        return (-1);\n@@ -8814,15 +8823,5 @@\n-    switch (cur->type) {\n-        case XML_ELEMENT_NODE:\n-        adoptns = 1;\n-        curElem = cur;\n-        depth++;\n-        \/*\n-        * Namespace declarations.\n-        *\/\n-        if (cur->nsDef != NULL) {\n-            prevns = NULL;\n-            ns = cur->nsDef;\n-            while (ns != NULL) {\n-            if (! parnsdone) {\n-                if ((elem->parent) &&\n-                ((xmlNodePtr) elem->parent->doc != elem->parent)) {\n+        switch (cur->type) {\n+            case XML_ELEMENT_NODE:\n+                adoptns = 1;\n+                curElem = cur;\n+                depth++;\n@@ -8830,1 +8829,1 @@\n-                * Gather ancestor in-scope ns-decls.\n+                * Namespace declarations.\n@@ -8832,6 +8831,16 @@\n-                if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n-                    elem->parent) == -1)\n-                    goto internal_error;\n-                }\n-                parnsdone = 1;\n-            }\n+                if (cur->nsDef != NULL) {\n+                    prevns = NULL;\n+                    ns = cur->nsDef;\n+                    while (ns != NULL) {\n+                        if (! parnsdone) {\n+                            if ((elem->parent) &&\n+                                ((xmlNodePtr) elem->parent->doc != elem->parent)) {\n+                                \/*\n+                                * Gather ancestor in-scope ns-decls.\n+                                *\/\n+                                if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n+                                    elem->parent) == -1)\n+                                    goto internal_error;\n+                            }\n+                            parnsdone = 1;\n+                        }\n@@ -8839,12 +8848,95 @@\n-            \/*\n-            * Lookup the ns ancestor-axis for equal ns-decls in scope.\n-            *\/\n-            if (optRemoveRedundantNS && XML_NSMAP_NOTEMPTY(nsMap)) {\n-                XML_NSMAP_FOREACH(nsMap, mi) {\n-                if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n-                    (mi->shadowDepth == -1) &&\n-                    ((ns->prefix == mi->newNs->prefix) ||\n-                      xmlStrEqual(ns->prefix, mi->newNs->prefix)) &&\n-                    ((ns->href == mi->newNs->href) ||\n-                      xmlStrEqual(ns->href, mi->newNs->href)))\n-                {\n+                        \/*\n+                        * Lookup the ns ancestor-axis for equal ns-decls in scope.\n+                        *\/\n+                        if (optRemoveRedundantNS && XML_NSMAP_NOTEMPTY(nsMap)) {\n+                            XML_NSMAP_FOREACH(nsMap, mi) {\n+                                if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n+                                    (mi->shadowDepth == -1) &&\n+                                    ((ns->prefix == mi->newNs->prefix) ||\n+                                      xmlStrEqual(ns->prefix, mi->newNs->prefix)) &&\n+                                    ((ns->href == mi->newNs->href) ||\n+                                      xmlStrEqual(ns->href, mi->newNs->href)))\n+                                {\n+                                    \/*\n+                                    * A redundant ns-decl was found.\n+                                    * Add it to the list of redundant ns-decls.\n+                                    *\/\n+                                    if (xmlDOMWrapNSNormAddNsMapItem2(&listRedund,\n+                                        &sizeRedund, &nbRedund, ns, mi->newNs) == -1)\n+                                        goto internal_error;\n+                                    \/*\n+                                    * Remove the ns-decl from the element-node.\n+                                    *\/\n+                                    if (prevns)\n+                                        prevns->next = ns->next;\n+                                    else\n+                                        cur->nsDef = ns->next;\n+                                    goto next_ns_decl;\n+                                }\n+                            }\n+                        }\n+\n+                        \/*\n+                        * Skip ns-references handling if the referenced\n+                        * ns-decl is declared on the same element.\n+                        *\/\n+                        if ((cur->ns != NULL) && adoptns && (cur->ns == ns))\n+                            adoptns = 0;\n+                        \/*\n+                        * Does it shadow any ns-decl?\n+                        *\/\n+                        if (XML_NSMAP_NOTEMPTY(nsMap)) {\n+                            XML_NSMAP_FOREACH(nsMap, mi) {\n+                                if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n+                                    (mi->shadowDepth == -1) &&\n+                                    ((ns->prefix == mi->newNs->prefix) ||\n+                                    xmlStrEqual(ns->prefix, mi->newNs->prefix))) {\n+\n+                                    mi->shadowDepth = depth;\n+                                }\n+                            }\n+                        }\n+                        \/*\n+                        * Push mapping.\n+                        *\/\n+                        if (xmlDOMWrapNsMapAddItem(&nsMap, -1, ns, ns,\n+                            depth) == NULL)\n+                            goto internal_error;\n+\n+                        prevns = ns;\n+next_ns_decl:\n+                        ns = ns->next;\n+                    }\n+                }\n+                if (! adoptns)\n+                    goto ns_end;\n+                \/* Falls through. *\/\n+            case XML_ATTRIBUTE_NODE:\n+                \/* No ns, no fun. *\/\n+                if (cur->ns == NULL)\n+                    goto ns_end;\n+\n+                if (! parnsdone) {\n+                    if ((elem->parent) &&\n+                        ((xmlNodePtr) elem->parent->doc != elem->parent)) {\n+                        if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n+                                elem->parent) == -1)\n+                            goto internal_error;\n+                    }\n+                    parnsdone = 1;\n+                }\n+                \/*\n+                * Adjust the reference if this was a redundant ns-decl.\n+                *\/\n+                if (listRedund) {\n+                   for (i = 0, j = 0; i < nbRedund; i++, j += 2) {\n+                       if (cur->ns == listRedund[j]) {\n+                           cur->ns = listRedund[++j];\n+                           break;\n+                       }\n+                   }\n+                }\n+                \/*\n+                * Adopt ns-references.\n+                *\/\n+                if (XML_NSMAP_NOTEMPTY(nsMap)) {\n@@ -8852,2 +8944,1 @@\n-                    * A redundant ns-decl was found.\n-                    * Add it to the list of redundant ns-decls.\n+                    * Search for a mapping.\n@@ -8855,2 +8946,17 @@\n-                    if (xmlDOMWrapNSNormAddNsMapItem2(&listRedund,\n-                    &sizeRedund, &nbRedund, ns, mi->newNs) == -1)\n+                    XML_NSMAP_FOREACH(nsMap, mi) {\n+                        if ((mi->shadowDepth == -1) &&\n+                            (cur->ns == mi->oldNs)) {\n+\n+                            cur->ns = mi->newNs;\n+                            goto ns_end;\n+                        }\n+                    }\n+                }\n+                \/*\n+                * Acquire a normalized ns-decl and add it to the map.\n+                *\/\n+                if (xmlDOMWrapNSNormAcquireNormalizedNs(doc, curElem,\n+                        cur->ns, &ns,\n+                        &nsMap, depth,\n+                        ancestorsOnly,\n+                        (cur->type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)\n@@ -8858,0 +8964,5 @@\n+                cur->ns = ns;\n+\n+ns_end:\n+                if ((cur->type == XML_ELEMENT_NODE) &&\n+                    (cur->properties != NULL)) {\n@@ -8859,1 +8970,1 @@\n-                    * Remove the ns-decl from the element-node.\n+                    * Process attributes.\n@@ -8861,26 +8972,2 @@\n-                    if (prevns)\n-                    prevns->next = ns->next;\n-                    else\n-                    cur->nsDef = ns->next;\n-                    goto next_ns_decl;\n-                }\n-                }\n-            }\n-\n-            \/*\n-            * Skip ns-references handling if the referenced\n-            * ns-decl is declared on the same element.\n-            *\/\n-            if ((cur->ns != NULL) && adoptns && (cur->ns == ns))\n-                adoptns = 0;\n-            \/*\n-            * Does it shadow any ns-decl?\n-            *\/\n-            if (XML_NSMAP_NOTEMPTY(nsMap)) {\n-                XML_NSMAP_FOREACH(nsMap, mi) {\n-                if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n-                    (mi->shadowDepth == -1) &&\n-                    ((ns->prefix == mi->newNs->prefix) ||\n-                    xmlStrEqual(ns->prefix, mi->newNs->prefix))) {\n-\n-                    mi->shadowDepth = depth;\n+                    cur = (xmlNodePtr) cur->properties;\n+                    continue;\n@@ -8888,57 +8975,3 @@\n-                }\n-            }\n-            \/*\n-            * Push mapping.\n-            *\/\n-            if (xmlDOMWrapNsMapAddItem(&nsMap, -1, ns, ns,\n-                depth) == NULL)\n-                goto internal_error;\n-\n-            prevns = ns;\n-next_ns_decl:\n-            ns = ns->next;\n-            }\n-        }\n-        if (! adoptns)\n-            goto ns_end;\n-                \/* Falls through. *\/\n-        case XML_ATTRIBUTE_NODE:\n-        \/* No ns, no fun. *\/\n-        if (cur->ns == NULL)\n-            goto ns_end;\n-\n-        if (! parnsdone) {\n-            if ((elem->parent) &&\n-            ((xmlNodePtr) elem->parent->doc != elem->parent)) {\n-            if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n-                elem->parent) == -1)\n-                goto internal_error;\n-            }\n-            parnsdone = 1;\n-        }\n-        \/*\n-        * Adjust the reference if this was a redundant ns-decl.\n-        *\/\n-        if (listRedund) {\n-           for (i = 0, j = 0; i < nbRedund; i++, j += 2) {\n-               if (cur->ns == listRedund[j]) {\n-               cur->ns = listRedund[++j];\n-               break;\n-               }\n-           }\n-        }\n-        \/*\n-        * Adopt ns-references.\n-        *\/\n-        if (XML_NSMAP_NOTEMPTY(nsMap)) {\n-            \/*\n-            * Search for a mapping.\n-            *\/\n-            XML_NSMAP_FOREACH(nsMap, mi) {\n-            if ((mi->shadowDepth == -1) &&\n-                (cur->ns == mi->oldNs)) {\n-\n-                cur->ns = mi->newNs;\n-                goto ns_end;\n-            }\n-            }\n+                break;\n+            default:\n+                goto next_sibling;\n@@ -8946,12 +8979,1 @@\n-        \/*\n-        * Acquire a normalized ns-decl and add it to the map.\n-        *\/\n-        if (xmlDOMWrapNSNormAcquireNormalizedNs(doc, curElem,\n-            cur->ns, &ns,\n-            &nsMap, depth,\n-            ancestorsOnly,\n-            (cur->type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)\n-            goto internal_error;\n-        cur->ns = ns;\n-\n-ns_end:\n+into_content:\n@@ -8959,1 +8981,1 @@\n-            (cur->properties != NULL)) {\n+            (cur->children != NULL)) {\n@@ -8961,1 +8983,1 @@\n-            * Process attributes.\n+            * Process content of element-nodes only.\n@@ -8963,1 +8985,1 @@\n-            cur = (xmlNodePtr) cur->properties;\n+            cur = cur->children;\n@@ -8966,13 +8988,0 @@\n-        break;\n-        default:\n-        goto next_sibling;\n-    }\n-into_content:\n-    if ((cur->type == XML_ELEMENT_NODE) &&\n-        (cur->children != NULL)) {\n-        \/*\n-        * Process content of element-nodes only.\n-        *\/\n-        cur = cur->children;\n-        continue;\n-    }\n@@ -8980,19 +8989,21 @@\n-    if (cur == elem)\n-        break;\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        if (XML_NSMAP_NOTEMPTY(nsMap)) {\n-        \/*\n-        * Pop mappings.\n-        *\/\n-        while ((nsMap->last != NULL) &&\n-            (nsMap->last->depth >= depth))\n-        {\n-            XML_NSMAP_POP(nsMap, mi)\n-        }\n-        \/*\n-        * Unshadow.\n-        *\/\n-        XML_NSMAP_FOREACH(nsMap, mi) {\n-            if (mi->shadowDepth >= depth)\n-            mi->shadowDepth = -1;\n-        }\n+        if (cur == elem)\n+            break;\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            if (XML_NSMAP_NOTEMPTY(nsMap)) {\n+                \/*\n+                * Pop mappings.\n+                *\/\n+                while ((nsMap->last != NULL) &&\n+                    (nsMap->last->depth >= depth))\n+                {\n+                    XML_NSMAP_POP(nsMap, mi)\n+                }\n+                \/*\n+                * Unshadow.\n+                *\/\n+                XML_NSMAP_FOREACH(nsMap, mi) {\n+                    if (mi->shadowDepth >= depth)\n+                        mi->shadowDepth = -1;\n+                }\n+            }\n+            depth--;\n@@ -9000,8 +9011,9 @@\n-        depth--;\n-    }\n-    if (cur->next != NULL)\n-        cur = cur->next;\n-    else {\n-        if (cur->type == XML_ATTRIBUTE_NODE) {\n-        cur = cur->parent;\n-        goto into_content;\n+        if (cur->next != NULL)\n+            cur = cur->next;\n+        else {\n+            if (cur->type == XML_ATTRIBUTE_NODE) {\n+                cur = cur->parent;\n+                goto into_content;\n+            }\n+            cur = cur->parent;\n+            goto next_sibling;\n@@ -9009,3 +9021,0 @@\n-        cur = cur->parent;\n-        goto next_sibling;\n-    }\n@@ -9020,4 +9029,4 @@\n-    for (i = 0, j = 0; i < nbRedund; i++, j += 2) {\n-        xmlFreeNs(listRedund[j]);\n-    }\n-    xmlFree(listRedund);\n+        for (i = 0, j = 0; i < nbRedund; i++, j += 2) {\n+            xmlFreeNs(listRedund[j]);\n+        }\n+        xmlFree(listRedund);\n@@ -9026,1 +9035,1 @@\n-    xmlDOMWrapNsMapFree(nsMap);\n+        xmlDOMWrapNsMapFree(nsMap);\n@@ -9054,5 +9063,5 @@\n-              xmlDocPtr sourceDoc,\n-              xmlNodePtr node,\n-              xmlDocPtr destDoc,\n-              xmlNodePtr destParent,\n-              int options ATTRIBUTE_UNUSED)\n+                      xmlDocPtr sourceDoc,\n+                      xmlNodePtr node,\n+                      xmlDocPtr destDoc,\n+                      xmlNodePtr destParent,\n+                      int options ATTRIBUTE_UNUSED)\n@@ -9075,2 +9084,2 @@\n-    (sourceDoc->dict == destDoc->dict))\n-    adoptStr = 0;\n+        (sourceDoc->dict == destDoc->dict))\n+        adoptStr = 0;\n@@ -9078,1 +9087,1 @@\n-    adoptStr = 1;\n+        adoptStr = 1;\n@@ -9084,1 +9093,1 @@\n-    nsMap = (xmlNsMapPtr) ctxt->namespaceMap;\n+        nsMap = (xmlNsMapPtr) ctxt->namespaceMap;\n@@ -9092,1 +9101,1 @@\n-    (ctxt && ctxt->getNsForNodeFunc))\n+        (ctxt && ctxt->getNsForNodeFunc))\n@@ -9094,1 +9103,1 @@\n-    parnsdone = 1;\n+        parnsdone = 1;\n@@ -9096,1 +9105,1 @@\n-    parnsdone = 0;\n+        parnsdone = 0;\n@@ -9100,1 +9109,1 @@\n-    goto internal_error;\n+        goto internal_error;\n@@ -9103,4 +9112,0 @@\n-    \/*\n-    * Paranoid source-doc sanity check.\n-    *\/\n-    if (cur->doc != sourceDoc) {\n@@ -9108,4 +9113,1 @@\n-        * We'll assume XIncluded nodes if the doc differs.\n-        * TODO: Do we need to reconciliate XIncluded nodes?\n-        * This here skips XIncluded nodes and tries to handle\n-        * broken sequences.\n+        * Paranoid source-doc sanity check.\n@@ -9113,35 +9115,1 @@\n-        if (cur->next == NULL)\n-        goto leave_node;\n-        do {\n-        cur = cur->next;\n-        if ((cur->type == XML_XINCLUDE_END) ||\n-            (cur->doc == node->doc))\n-            break;\n-        } while (cur->next != NULL);\n-\n-        if (cur->doc != node->doc)\n-        goto leave_node;\n-    }\n-    cur->doc = destDoc;\n-    switch (cur->type) {\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-        \/*\n-        * TODO\n-        *\/\n-        return (-1);\n-        case XML_ELEMENT_NODE:\n-        curElem = cur;\n-        depth++;\n-        \/*\n-        * Namespace declarations.\n-        * - ns->href and ns->prefix are never in the dict, so\n-        *   we need not move the values over to the destination dict.\n-        * - Note that for custom handling of ns-references,\n-        *   the ns-decls need not be stored in the ns-map,\n-        *   since they won't be referenced by node->ns.\n-        *\/\n-        if ((cur->nsDef) &&\n-            ((ctxt == NULL) || (ctxt->getNsForNodeFunc == NULL)))\n-        {\n-            if (! parnsdone) {\n+        if (cur->doc != sourceDoc) {\n@@ -9149,1 +9117,4 @@\n-            * Gather @parent's in-scope ns-decls.\n+            * We'll assume XIncluded nodes if the doc differs.\n+            * TODO: Do we need to reconciliate XIncluded nodes?\n+            * This here skips XIncluded nodes and tries to handle\n+            * broken sequences.\n@@ -9151,21 +9122,94 @@\n-            if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n-                destParent) == -1)\n-                goto internal_error;\n-            parnsdone = 1;\n-            }\n-            for (ns = cur->nsDef; ns != NULL; ns = ns->next) {\n-            \/*\n-            * NOTE: ns->prefix and ns->href are never in the dict.\n-            * XML_TREE_ADOPT_STR(ns->prefix)\n-            * XML_TREE_ADOPT_STR(ns->href)\n-            *\/\n-            \/*\n-            * Does it shadow any ns-decl?\n-            *\/\n-            if (XML_NSMAP_NOTEMPTY(nsMap)) {\n-                XML_NSMAP_FOREACH(nsMap, mi) {\n-                if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n-                    (mi->shadowDepth == -1) &&\n-                    ((ns->prefix == mi->newNs->prefix) ||\n-                    xmlStrEqual(ns->prefix,\n-                    mi->newNs->prefix))) {\n+            if (cur->next == NULL)\n+                goto leave_node;\n+            do {\n+                cur = cur->next;\n+                if ((cur->type == XML_XINCLUDE_END) ||\n+                    (cur->doc == node->doc))\n+                    break;\n+            } while (cur->next != NULL);\n+\n+            if (cur->doc != node->doc)\n+                goto leave_node;\n+        }\n+        cur->doc = destDoc;\n+        switch (cur->type) {\n+            case XML_XINCLUDE_START:\n+            case XML_XINCLUDE_END:\n+                \/*\n+                * TODO\n+                *\/\n+                return (-1);\n+            case XML_ELEMENT_NODE:\n+                curElem = cur;\n+                depth++;\n+                \/*\n+                * Namespace declarations.\n+                * - ns->href and ns->prefix are never in the dict, so\n+                *   we need not move the values over to the destination dict.\n+                * - Note that for custom handling of ns-references,\n+                *   the ns-decls need not be stored in the ns-map,\n+                *   since they won't be referenced by node->ns.\n+                *\/\n+                if ((cur->nsDef) &&\n+                    ((ctxt == NULL) || (ctxt->getNsForNodeFunc == NULL)))\n+                {\n+                    if (! parnsdone) {\n+                        \/*\n+                        * Gather @parent's in-scope ns-decls.\n+                        *\/\n+                        if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n+                            destParent) == -1)\n+                            goto internal_error;\n+                        parnsdone = 1;\n+                    }\n+                    for (ns = cur->nsDef; ns != NULL; ns = ns->next) {\n+                        \/*\n+                        * NOTE: ns->prefix and ns->href are never in the dict.\n+                        * XML_TREE_ADOPT_STR(ns->prefix)\n+                        * XML_TREE_ADOPT_STR(ns->href)\n+                        *\/\n+                        \/*\n+                        * Does it shadow any ns-decl?\n+                        *\/\n+                        if (XML_NSMAP_NOTEMPTY(nsMap)) {\n+                            XML_NSMAP_FOREACH(nsMap, mi) {\n+                                if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n+                                    (mi->shadowDepth == -1) &&\n+                                    ((ns->prefix == mi->newNs->prefix) ||\n+                                    xmlStrEqual(ns->prefix,\n+                                    mi->newNs->prefix))) {\n+\n+                                    mi->shadowDepth = depth;\n+                                }\n+                            }\n+                        }\n+                        \/*\n+                        * Push mapping.\n+                        *\/\n+                        if (xmlDOMWrapNsMapAddItem(&nsMap, -1,\n+                            ns, ns, depth) == NULL)\n+                            goto internal_error;\n+                    }\n+                }\n+                \/* Falls through. *\/\n+            case XML_ATTRIBUTE_NODE:\n+                \/* No namespace, no fun. *\/\n+                if (cur->ns == NULL)\n+                    goto ns_end;\n+\n+                if (! parnsdone) {\n+                    if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n+                        destParent) == -1)\n+                        goto internal_error;\n+                    parnsdone = 1;\n+                }\n+                \/*\n+                * Adopt ns-references.\n+                *\/\n+                if (XML_NSMAP_NOTEMPTY(nsMap)) {\n+                    \/*\n+                    * Search for a mapping.\n+                    *\/\n+                    XML_NSMAP_FOREACH(nsMap, mi) {\n+                        if ((mi->shadowDepth == -1) &&\n+                            (cur->ns == mi->oldNs)) {\n@@ -9173,1 +9217,4 @@\n-                    mi->shadowDepth = depth;\n+                            cur->ns = mi->newNs;\n+                            goto ns_end;\n+                        }\n+                    }\n@@ -9175,0 +9222,31 @@\n+                \/*\n+                * No matching namespace in scope. We need a new one.\n+                *\/\n+                if ((ctxt) && (ctxt->getNsForNodeFunc)) {\n+                    \/*\n+                    * User-defined behaviour.\n+                    *\/\n+                    ns = ctxt->getNsForNodeFunc(ctxt, cur,\n+                        cur->ns->href, cur->ns->prefix);\n+                    \/*\n+                    * Insert mapping if ns is available; it's the users fault\n+                    * if not.\n+                    *\/\n+                    if (xmlDOMWrapNsMapAddItem(&nsMap, -1,\n+                            cur->ns, ns, XML_TREE_NSMAP_CUSTOM) == NULL)\n+                        goto internal_error;\n+                    cur->ns = ns;\n+                } else {\n+                    \/*\n+                    * Acquire a normalized ns-decl and add it to the map.\n+                    *\/\n+                    if (xmlDOMWrapNSNormAcquireNormalizedNs(destDoc,\n+                        \/* ns-decls on curElem or on destDoc->oldNs *\/\n+                        destParent ? curElem : NULL,\n+                        cur->ns, &ns,\n+                        &nsMap, depth,\n+                        ancestorsOnly,\n+                        \/* ns-decls must be prefixed for attributes. *\/\n+                        (cur->type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)\n+                        goto internal_error;\n+                    cur->ns = ns;\n@@ -9176,6 +9254,68 @@\n-            }\n-            \/*\n-            * Push mapping.\n-            *\/\n-            if (xmlDOMWrapNsMapAddItem(&nsMap, -1,\n-                ns, ns, depth) == NULL)\n+ns_end:\n+                \/*\n+                * Further node properties.\n+                * TODO: Is this all?\n+                *\/\n+                XML_TREE_ADOPT_STR(cur->name)\n+                if (cur->type == XML_ELEMENT_NODE) {\n+                    cur->psvi = NULL;\n+                    cur->line = 0;\n+                    cur->extra = 0;\n+                    \/*\n+                    * Walk attributes.\n+                    *\/\n+                    if (cur->properties != NULL) {\n+                        \/*\n+                        * Process first attribute node.\n+                        *\/\n+                        cur = (xmlNodePtr) cur->properties;\n+                        continue;\n+                    }\n+                } else {\n+                    \/*\n+                    * Attributes.\n+                    *\/\n+                    if ((sourceDoc != NULL) &&\n+                        (((xmlAttrPtr) cur)->atype == XML_ATTRIBUTE_ID))\n+                    {\n+                        xmlRemoveID(sourceDoc, (xmlAttrPtr) cur);\n+                    }\n+                    ((xmlAttrPtr) cur)->atype = 0;\n+                    ((xmlAttrPtr) cur)->psvi = NULL;\n+                }\n+                break;\n+            case XML_TEXT_NODE:\n+            case XML_CDATA_SECTION_NODE:\n+                \/*\n+                * This puts the content in the dest dict, only if\n+                * it was previously in the source dict.\n+                *\/\n+                XML_TREE_ADOPT_STR_2(cur->content)\n+                goto leave_node;\n+            case XML_ENTITY_REF_NODE:\n+                \/*\n+                * Remove reference to the entity-node.\n+                *\/\n+                cur->content = NULL;\n+                cur->children = NULL;\n+                cur->last = NULL;\n+                if ((destDoc->intSubset) || (destDoc->extSubset)) {\n+                    xmlEntityPtr ent;\n+                    \/*\n+                    * Assign new entity-node if available.\n+                    *\/\n+                    ent = xmlGetDocEntity(destDoc, cur->name);\n+                    if (ent != NULL) {\n+                        cur->content = ent->content;\n+                        cur->children = (xmlNodePtr) ent;\n+                        cur->last = (xmlNodePtr) ent;\n+                    }\n+                }\n+                goto leave_node;\n+            case XML_PI_NODE:\n+                XML_TREE_ADOPT_STR(cur->name)\n+                XML_TREE_ADOPT_STR_2(cur->content)\n+                break;\n+            case XML_COMMENT_NODE:\n+                break;\n+            default:\n@@ -9183,61 +9323,0 @@\n-            }\n-        }\n-                \/* Falls through. *\/\n-        case XML_ATTRIBUTE_NODE:\n-        \/* No namespace, no fun. *\/\n-        if (cur->ns == NULL)\n-            goto ns_end;\n-\n-        if (! parnsdone) {\n-            if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n-            destParent) == -1)\n-            goto internal_error;\n-            parnsdone = 1;\n-        }\n-        \/*\n-        * Adopt ns-references.\n-        *\/\n-        if (XML_NSMAP_NOTEMPTY(nsMap)) {\n-            \/*\n-            * Search for a mapping.\n-            *\/\n-            XML_NSMAP_FOREACH(nsMap, mi) {\n-            if ((mi->shadowDepth == -1) &&\n-                (cur->ns == mi->oldNs)) {\n-\n-                cur->ns = mi->newNs;\n-                goto ns_end;\n-            }\n-            }\n-        }\n-        \/*\n-        * No matching namespace in scope. We need a new one.\n-        *\/\n-        if ((ctxt) && (ctxt->getNsForNodeFunc)) {\n-            \/*\n-            * User-defined behaviour.\n-            *\/\n-            ns = ctxt->getNsForNodeFunc(ctxt, cur,\n-            cur->ns->href, cur->ns->prefix);\n-            \/*\n-            * Insert mapping if ns is available; it's the users fault\n-            * if not.\n-            *\/\n-            if (xmlDOMWrapNsMapAddItem(&nsMap, -1,\n-                cur->ns, ns, XML_TREE_NSMAP_CUSTOM) == NULL)\n-            goto internal_error;\n-            cur->ns = ns;\n-        } else {\n-            \/*\n-            * Acquire a normalized ns-decl and add it to the map.\n-            *\/\n-            if (xmlDOMWrapNSNormAcquireNormalizedNs(destDoc,\n-            \/* ns-decls on curElem or on destDoc->oldNs *\/\n-            destParent ? curElem : NULL,\n-            cur->ns, &ns,\n-            &nsMap, depth,\n-            ancestorsOnly,\n-            \/* ns-decls must be prefixed for attributes. *\/\n-            (cur->type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)\n-            goto internal_error;\n-            cur->ns = ns;\n@@ -9245,1 +9324,0 @@\n-ns_end:\n@@ -9247,2 +9325,1 @@\n-        * Further node properties.\n-        * TODO: Is this all?\n+        * Walk the tree.\n@@ -9250,13 +9327,2 @@\n-        XML_TREE_ADOPT_STR(cur->name)\n-        if (cur->type == XML_ELEMENT_NODE) {\n-            cur->psvi = NULL;\n-            cur->line = 0;\n-            cur->extra = 0;\n-            \/*\n-            * Walk attributes.\n-            *\/\n-            if (cur->properties != NULL) {\n-            \/*\n-            * Process first attribute node.\n-            *\/\n-            cur = (xmlNodePtr) cur->properties;\n+        if (cur->children != NULL) {\n+            cur = cur->children;\n@@ -9264,12 +9330,0 @@\n-            }\n-        } else {\n-            \/*\n-            * Attributes.\n-            *\/\n-            if ((sourceDoc != NULL) &&\n-            (((xmlAttrPtr) cur)->atype == XML_ATTRIBUTE_ID))\n-            {\n-            xmlRemoveID(sourceDoc, (xmlAttrPtr) cur);\n-            }\n-            ((xmlAttrPtr) cur)->atype = 0;\n-            ((xmlAttrPtr) cur)->psvi = NULL;\n@@ -9277,18 +9331,8 @@\n-        break;\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        \/*\n-        * This puts the content in the dest dict, only if\n-        * it was previously in the source dict.\n-        *\/\n-        XML_TREE_ADOPT_STR_2(cur->content)\n-        goto leave_node;\n-        case XML_ENTITY_REF_NODE:\n-        \/*\n-        * Remove reference to the entity-node.\n-        *\/\n-        cur->content = NULL;\n-        cur->children = NULL;\n-        cur->last = NULL;\n-        if ((destDoc->intSubset) || (destDoc->extSubset)) {\n-            xmlEntityPtr ent;\n+\n+leave_node:\n+        if (cur == node)\n+            break;\n+        if ((cur->type == XML_ELEMENT_NODE) ||\n+            (cur->type == XML_XINCLUDE_START) ||\n+            (cur->type == XML_XINCLUDE_END))\n+        {\n@@ -9296,1 +9340,1 @@\n-            * Assign new entity-node if available.\n+            * TODO: Do we expect nsDefs on XML_XINCLUDE_START?\n@@ -9298,5 +9342,16 @@\n-            ent = xmlGetDocEntity(destDoc, cur->name);\n-            if (ent != NULL) {\n-            cur->content = ent->content;\n-            cur->children = (xmlNodePtr) ent;\n-            cur->last = (xmlNodePtr) ent;\n+            if (XML_NSMAP_NOTEMPTY(nsMap)) {\n+                \/*\n+                * Pop mappings.\n+                *\/\n+                while ((nsMap->last != NULL) &&\n+                    (nsMap->last->depth >= depth))\n+                {\n+                    XML_NSMAP_POP(nsMap, mi)\n+                }\n+                \/*\n+                * Unshadow.\n+                *\/\n+                XML_NSMAP_FOREACH(nsMap, mi) {\n+                    if (mi->shadowDepth >= depth)\n+                        mi->shadowDepth = -1;\n+                }\n@@ -9304,0 +9359,1 @@\n+            depth--;\n@@ -9305,34 +9361,4 @@\n-        goto leave_node;\n-        case XML_PI_NODE:\n-        XML_TREE_ADOPT_STR(cur->name)\n-        XML_TREE_ADOPT_STR_2(cur->content)\n-        break;\n-        case XML_COMMENT_NODE:\n-        break;\n-        default:\n-        goto internal_error;\n-    }\n-    \/*\n-    * Walk the tree.\n-    *\/\n-    if (cur->children != NULL) {\n-        cur = cur->children;\n-        continue;\n-    }\n-\n-leave_node:\n-    if (cur == node)\n-        break;\n-    if ((cur->type == XML_ELEMENT_NODE) ||\n-        (cur->type == XML_XINCLUDE_START) ||\n-        (cur->type == XML_XINCLUDE_END))\n-    {\n-        \/*\n-        * TODO: Do we expect nsDefs on XML_XINCLUDE_START?\n-        *\/\n-        if (XML_NSMAP_NOTEMPTY(nsMap)) {\n-        \/*\n-        * Pop mappings.\n-        *\/\n-        while ((nsMap->last != NULL) &&\n-            (nsMap->last->depth >= depth))\n+        if (cur->next != NULL)\n+            cur = cur->next;\n+        else if ((cur->type == XML_ATTRIBUTE_NODE) &&\n+            (cur->parent->children != NULL))\n@@ -9340,9 +9366,4 @@\n-            XML_NSMAP_POP(nsMap, mi)\n-        }\n-        \/*\n-        * Unshadow.\n-        *\/\n-        XML_NSMAP_FOREACH(nsMap, mi) {\n-            if (mi->shadowDepth >= depth)\n-            mi->shadowDepth = -1;\n-        }\n+            cur = cur->parent->children;\n+        } else {\n+            cur = cur->parent;\n+            goto leave_node;\n@@ -9350,12 +9371,0 @@\n-        depth--;\n-    }\n-    if (cur->next != NULL)\n-        cur = cur->next;\n-    else if ((cur->type == XML_ATTRIBUTE_NODE) &&\n-        (cur->parent->children != NULL))\n-    {\n-        cur = cur->parent->children;\n-    } else {\n-        cur = cur->parent;\n-        goto leave_node;\n-    }\n@@ -9374,12 +9383,12 @@\n-    if ((ctxt) && (ctxt->namespaceMap == nsMap)) {\n-        \/*\n-        * Just cleanup the map but don't free.\n-        *\/\n-        if (nsMap->first) {\n-        if (nsMap->pool)\n-            nsMap->last->next = nsMap->pool;\n-        nsMap->pool = nsMap->first;\n-        nsMap->first = NULL;\n-        }\n-    } else\n-        xmlDOMWrapNsMapFree(nsMap);\n+        if ((ctxt) && (ctxt->namespaceMap == nsMap)) {\n+            \/*\n+            * Just cleanup the map but don't free.\n+            *\/\n+            if (nsMap->first) {\n+                if (nsMap->pool)\n+                    nsMap->last->next = nsMap->pool;\n+                nsMap->pool = nsMap->first;\n+                nsMap->first = NULL;\n+            }\n+        } else\n+            xmlDOMWrapNsMapFree(nsMap);\n@@ -9422,7 +9431,7 @@\n-              xmlDocPtr sourceDoc,\n-              xmlNodePtr node,\n-              xmlNodePtr *resNode,\n-              xmlDocPtr destDoc,\n-              xmlNodePtr destParent,\n-              int deep,\n-              int options ATTRIBUTE_UNUSED)\n+                      xmlDocPtr sourceDoc,\n+                      xmlNodePtr node,\n+                      xmlNodePtr *resNode,\n+                      xmlDocPtr destDoc,\n+                      xmlNodePtr destParent,\n+                      int deep,\n+                      int options ATTRIBUTE_UNUSED)\n@@ -9450,1 +9459,1 @@\n-    return(-1);\n+        return(-1);\n@@ -9455,1 +9464,1 @@\n-    return(1);\n+        return(1);\n@@ -9460,5 +9469,5 @@\n-    (node->doc != sourceDoc)) {\n-    \/*\n-    * Might be an XIncluded node.\n-    *\/\n-    return (-1);\n+        (node->doc != sourceDoc)) {\n+        \/*\n+        * Might be an XIncluded node.\n+        *\/\n+        return (-1);\n@@ -9467,1 +9476,1 @@\n-    sourceDoc = node->doc;\n+        sourceDoc = node->doc;\n@@ -9476,1 +9485,1 @@\n-    nsMap = (xmlNsMapPtr) ctxt->namespaceMap;\n+        nsMap = (xmlNsMapPtr) ctxt->namespaceMap;\n@@ -9485,33 +9494,6 @@\n-    if (cur->doc != sourceDoc) {\n-        \/*\n-        * We'll assume XIncluded nodes if the doc differs.\n-        * TODO: Do we need to reconciliate XIncluded nodes?\n-        * TODO: This here returns -1 in this case.\n-        *\/\n-        goto internal_error;\n-    }\n-    \/*\n-    * Create a new node.\n-    *\/\n-    switch (cur->type) {\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-        \/*\n-        * TODO: What to do with XInclude?\n-        *\/\n-        goto internal_error;\n-        break;\n-        case XML_ELEMENT_NODE:\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        case XML_COMMENT_NODE:\n-        case XML_PI_NODE:\n-        case XML_DOCUMENT_FRAG_NODE:\n-        case XML_ENTITY_REF_NODE:\n-        case XML_ENTITY_NODE:\n-        \/*\n-        * Nodes of xmlNode structure.\n-        *\/\n-        clone = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n-        if (clone == NULL) {\n-            xmlTreeErrMemory(\"xmlDOMWrapCloneNode(): allocating a node\");\n+        if (cur->doc != sourceDoc) {\n+            \/*\n+            * We'll assume XIncluded nodes if the doc differs.\n+            * TODO: Do we need to reconciliate XIncluded nodes?\n+            * TODO: This here returns -1 in this case.\n+            *\/\n@@ -9520,1 +9502,0 @@\n-        memset(clone, 0, sizeof(xmlNode));\n@@ -9522,1 +9503,1 @@\n-        * Set hierarchical links.\n+        * Create a new node.\n@@ -9524,9 +9505,37 @@\n-        if (resultClone != NULL) {\n-            clone->parent = parentClone;\n-            if (prevClone) {\n-            prevClone->next = clone;\n-            clone->prev = prevClone;\n-            } else\n-            parentClone->children = clone;\n-        } else\n-            resultClone = clone;\n+        switch (cur->type) {\n+            case XML_XINCLUDE_START:\n+            case XML_XINCLUDE_END:\n+                \/*\n+                * TODO: What to do with XInclude?\n+                *\/\n+                goto internal_error;\n+                break;\n+            case XML_ELEMENT_NODE:\n+            case XML_TEXT_NODE:\n+            case XML_CDATA_SECTION_NODE:\n+            case XML_COMMENT_NODE:\n+            case XML_PI_NODE:\n+            case XML_DOCUMENT_FRAG_NODE:\n+            case XML_ENTITY_REF_NODE:\n+            case XML_ENTITY_NODE:\n+                \/*\n+                * Nodes of xmlNode structure.\n+                *\/\n+                clone = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n+                if (clone == NULL) {\n+                    xmlTreeErrMemory(\"xmlDOMWrapCloneNode(): allocating a node\");\n+                    goto internal_error;\n+                }\n+                memset(clone, 0, sizeof(xmlNode));\n+                \/*\n+                * Set hierarchical links.\n+                *\/\n+                if (resultClone != NULL) {\n+                    clone->parent = parentClone;\n+                    if (prevClone) {\n+                        prevClone->next = clone;\n+                        clone->prev = prevClone;\n+                    } else\n+                        parentClone->children = clone;\n+                } else\n+                    resultClone = clone;\n@@ -9534,9 +9543,30 @@\n-        break;\n-        case XML_ATTRIBUTE_NODE:\n-        \/*\n-        * Attributes (xmlAttr).\n-        *\/\n-        clone = (xmlNodePtr) xmlMalloc(sizeof(xmlAttr));\n-        if (clone == NULL) {\n-            xmlTreeErrMemory(\"xmlDOMWrapCloneNode(): allocating an attr-node\");\n-            goto internal_error;\n+                break;\n+            case XML_ATTRIBUTE_NODE:\n+                \/*\n+                * Attributes (xmlAttr).\n+                *\/\n+                clone = (xmlNodePtr) xmlMalloc(sizeof(xmlAttr));\n+                if (clone == NULL) {\n+                    xmlTreeErrMemory(\"xmlDOMWrapCloneNode(): allocating an attr-node\");\n+                    goto internal_error;\n+                }\n+                memset(clone, 0, sizeof(xmlAttr));\n+                \/*\n+                * Set hierarchical links.\n+                * TODO: Change this to add to the end of attributes.\n+                *\/\n+                if (resultClone != NULL) {\n+                    clone->parent = parentClone;\n+                    if (prevClone) {\n+                        prevClone->next = clone;\n+                        clone->prev = prevClone;\n+                    } else\n+                        parentClone->properties = (xmlAttrPtr) clone;\n+                } else\n+                    resultClone = clone;\n+                break;\n+            default:\n+                \/*\n+                * TODO QUESTION: Any other nodes expected?\n+                *\/\n+                goto internal_error;\n@@ -9544,24 +9574,0 @@\n-        memset(clone, 0, sizeof(xmlAttr));\n-        \/*\n-        * Set hierarchical links.\n-        * TODO: Change this to add to the end of attributes.\n-        *\/\n-        if (resultClone != NULL) {\n-            clone->parent = parentClone;\n-            if (prevClone) {\n-            prevClone->next = clone;\n-            clone->prev = prevClone;\n-            } else\n-            parentClone->properties = (xmlAttrPtr) clone;\n-        } else\n-            resultClone = clone;\n-        break;\n-        default:\n-        \/*\n-        * TODO QUESTION: Any other nodes expected?\n-        *\/\n-        goto internal_error;\n-    }\n-\n-    clone->type = cur->type;\n-    clone->doc = destDoc;\n@@ -9569,17 +9575,2 @@\n-    \/*\n-    * Clone the name of the node if any.\n-    *\/\n-    if (cur->name == xmlStringText)\n-        clone->name = xmlStringText;\n-    else if (cur->name == xmlStringTextNoenc)\n-        \/*\n-        * NOTE: Although xmlStringTextNoenc is never assigned to a node\n-        *   in tree.c, it might be set in Libxslt via\n-        *   \"xsl:disable-output-escaping\".\n-        *\/\n-        clone->name = xmlStringTextNoenc;\n-    else if (cur->name == xmlStringComment)\n-        clone->name = xmlStringComment;\n-    else if (cur->name != NULL) {\n-        DICT_CONST_COPY(cur->name, clone->name);\n-    }\n+        clone->type = cur->type;\n+        clone->doc = destDoc;\n@@ -9587,10 +9578,0 @@\n-    switch (cur->type) {\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-        \/*\n-        * TODO\n-        *\/\n-        return (-1);\n-        case XML_ELEMENT_NODE:\n-        curElem = cur;\n-        depth++;\n@@ -9598,1 +9579,1 @@\n-        * Namespace declarations.\n+        * Clone the name of the node if any.\n@@ -9600,17 +9581,3 @@\n-        if (cur->nsDef != NULL) {\n-            if (! parnsdone) {\n-            if (destParent && (ctxt == NULL)) {\n-                \/*\n-                * Gather @parent's in-scope ns-decls.\n-                *\/\n-                if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n-                destParent) == -1)\n-                goto internal_error;\n-            }\n-            parnsdone = 1;\n-            }\n-            \/*\n-            * Clone namespace declarations.\n-            *\/\n-            cloneNsDefSlot = &(clone->nsDef);\n-            for (ns = cur->nsDef; ns != NULL; ns = ns->next) {\n+        if (cur->name == xmlStringText)\n+            clone->name = xmlStringText;\n+        else if (cur->name == xmlStringTextNoenc)\n@@ -9618,1 +9585,3 @@\n-            * Create a new xmlNs.\n+            * NOTE: Although xmlStringTextNoenc is never assigned to a node\n+            *   in tree.c, it might be set in Libxslt via\n+            *   \"xsl:disable-output-escaping\".\n@@ -9620,16 +9589,6 @@\n-            cloneNs = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));\n-            if (cloneNs == NULL) {\n-                xmlTreeErrMemory(\"xmlDOMWrapCloneNode(): \"\n-                \"allocating namespace\");\n-                return(-1);\n-            }\n-            memset(cloneNs, 0, sizeof(xmlNs));\n-            cloneNs->type = XML_LOCAL_NAMESPACE;\n-\n-            if (ns->href != NULL)\n-                cloneNs->href = xmlStrdup(ns->href);\n-            if (ns->prefix != NULL)\n-                cloneNs->prefix = xmlStrdup(ns->prefix);\n-\n-            *cloneNsDefSlot = cloneNs;\n-            cloneNsDefSlot = &(cloneNs->next);\n+            clone->name = xmlStringTextNoenc;\n+        else if (cur->name == xmlStringComment)\n+            clone->name = xmlStringComment;\n+        else if (cur->name != NULL) {\n+            DICT_CONST_COPY(cur->name, clone->name);\n+        }\n@@ -9637,8 +9596,3 @@\n-            \/*\n-            * Note that for custom handling of ns-references,\n-            * the ns-decls need not be stored in the ns-map,\n-            * since they won't be referenced by node->ns.\n-            *\/\n-            if ((ctxt == NULL) ||\n-                (ctxt->getNsForNodeFunc == NULL))\n-            {\n+        switch (cur->type) {\n+            case XML_XINCLUDE_START:\n+            case XML_XINCLUDE_END:\n@@ -9646,1 +9600,1 @@\n-                * Does it shadow any ns-decl?\n+                * TODO\n@@ -9648,7 +9602,19 @@\n-                if (XML_NSMAP_NOTEMPTY(nsMap)) {\n-                XML_NSMAP_FOREACH(nsMap, mi) {\n-                    if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n-                    (mi->shadowDepth == -1) &&\n-                    ((ns->prefix == mi->newNs->prefix) ||\n-                    xmlStrEqual(ns->prefix,\n-                    mi->newNs->prefix))) {\n+                return (-1);\n+            case XML_ELEMENT_NODE:\n+                curElem = cur;\n+                depth++;\n+                \/*\n+                * Namespace declarations.\n+                *\/\n+                if (cur->nsDef != NULL) {\n+                    if (! parnsdone) {\n+                        if (destParent && (ctxt == NULL)) {\n+                            \/*\n+                            * Gather @parent's in-scope ns-decls.\n+                            *\/\n+                            if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n+                                destParent) == -1)\n+                                goto internal_error;\n+                        }\n+                        parnsdone = 1;\n+                    }\n@@ -9656,2 +9622,1 @@\n-                    * Mark as shadowed at the current\n-                    * depth.\n+                    * Clone namespace declarations.\n@@ -9659,1 +9624,55 @@\n-                    mi->shadowDepth = depth;\n+                    cloneNsDefSlot = &(clone->nsDef);\n+                    for (ns = cur->nsDef; ns != NULL; ns = ns->next) {\n+                        \/*\n+                        * Create a new xmlNs.\n+                        *\/\n+                        cloneNs = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));\n+                        if (cloneNs == NULL) {\n+                            xmlTreeErrMemory(\"xmlDOMWrapCloneNode(): \"\n+                                \"allocating namespace\");\n+                            return(-1);\n+                        }\n+                        memset(cloneNs, 0, sizeof(xmlNs));\n+                        cloneNs->type = XML_LOCAL_NAMESPACE;\n+\n+                        if (ns->href != NULL)\n+                            cloneNs->href = xmlStrdup(ns->href);\n+                        if (ns->prefix != NULL)\n+                            cloneNs->prefix = xmlStrdup(ns->prefix);\n+\n+                        *cloneNsDefSlot = cloneNs;\n+                        cloneNsDefSlot = &(cloneNs->next);\n+\n+                        \/*\n+                        * Note that for custom handling of ns-references,\n+                        * the ns-decls need not be stored in the ns-map,\n+                        * since they won't be referenced by node->ns.\n+                        *\/\n+                        if ((ctxt == NULL) ||\n+                            (ctxt->getNsForNodeFunc == NULL))\n+                        {\n+                            \/*\n+                            * Does it shadow any ns-decl?\n+                            *\/\n+                            if (XML_NSMAP_NOTEMPTY(nsMap)) {\n+                                XML_NSMAP_FOREACH(nsMap, mi) {\n+                                    if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n+                                        (mi->shadowDepth == -1) &&\n+                                        ((ns->prefix == mi->newNs->prefix) ||\n+                                        xmlStrEqual(ns->prefix,\n+                                        mi->newNs->prefix))) {\n+                                        \/*\n+                                        * Mark as shadowed at the current\n+                                        * depth.\n+                                        *\/\n+                                        mi->shadowDepth = depth;\n+                                    }\n+                                }\n+                            }\n+                            \/*\n+                            * Push mapping.\n+                            *\/\n+                            if (xmlDOMWrapNsMapAddItem(&nsMap, -1,\n+                                ns, cloneNs, depth) == NULL)\n+                                goto internal_error;\n+                        }\n@@ -9662,1 +9681,8 @@\n-                }\n+                \/* cur->ns will be processed further down. *\/\n+                break;\n+            case XML_ATTRIBUTE_NODE:\n+                \/* IDs will be processed further down. *\/\n+                \/* cur->ns will be processed further down. *\/\n+                break;\n+            case XML_TEXT_NODE:\n+            case XML_CDATA_SECTION_NODE:\n@@ -9664,1 +9690,1 @@\n-                * Push mapping.\n+                * Note that this will also cover the values of attributes.\n@@ -9666,2 +9692,36 @@\n-                if (xmlDOMWrapNsMapAddItem(&nsMap, -1,\n-                ns, cloneNs, depth) == NULL)\n+                DICT_COPY(cur->content, clone->content);\n+                goto leave_node;\n+            case XML_ENTITY_NODE:\n+                \/* TODO: What to do here? *\/\n+                goto leave_node;\n+            case XML_ENTITY_REF_NODE:\n+                if (sourceDoc != destDoc) {\n+                    if ((destDoc->intSubset) || (destDoc->extSubset)) {\n+                        xmlEntityPtr ent;\n+                        \/*\n+                        * Different doc: Assign new entity-node if available.\n+                        *\/\n+                        ent = xmlGetDocEntity(destDoc, cur->name);\n+                        if (ent != NULL) {\n+                            clone->content = ent->content;\n+                            clone->children = (xmlNodePtr) ent;\n+                            clone->last = (xmlNodePtr) ent;\n+                        }\n+                    }\n+                } else {\n+                    \/*\n+                    * Same doc: Use the current node's entity declaration\n+                    * and value.\n+                    *\/\n+                    clone->content = cur->content;\n+                    clone->children = cur->children;\n+                    clone->last = cur->last;\n+                }\n+                goto leave_node;\n+            case XML_PI_NODE:\n+                DICT_COPY(cur->content, clone->content);\n+                goto leave_node;\n+            case XML_COMMENT_NODE:\n+                DICT_COPY(cur->content, clone->content);\n+                goto leave_node;\n+            default:\n@@ -9669,41 +9729,0 @@\n-            }\n-            }\n-        }\n-        \/* cur->ns will be processed further down. *\/\n-        break;\n-        case XML_ATTRIBUTE_NODE:\n-        \/* IDs will be processed further down. *\/\n-        \/* cur->ns will be processed further down. *\/\n-        break;\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        \/*\n-        * Note that this will also cover the values of attributes.\n-        *\/\n-        DICT_COPY(cur->content, clone->content);\n-        goto leave_node;\n-        case XML_ENTITY_NODE:\n-        \/* TODO: What to do here? *\/\n-        goto leave_node;\n-        case XML_ENTITY_REF_NODE:\n-        if (sourceDoc != destDoc) {\n-            if ((destDoc->intSubset) || (destDoc->extSubset)) {\n-            xmlEntityPtr ent;\n-            \/*\n-            * Different doc: Assign new entity-node if available.\n-            *\/\n-            ent = xmlGetDocEntity(destDoc, cur->name);\n-            if (ent != NULL) {\n-                clone->content = ent->content;\n-                clone->children = (xmlNodePtr) ent;\n-                clone->last = (xmlNodePtr) ent;\n-            }\n-            }\n-        } else {\n-            \/*\n-            * Same doc: Use the current node's entity declaration\n-            * and value.\n-            *\/\n-            clone->content = cur->content;\n-            clone->children = cur->children;\n-            clone->last = cur->last;\n@@ -9711,10 +9730,0 @@\n-        goto leave_node;\n-        case XML_PI_NODE:\n-        DICT_COPY(cur->content, clone->content);\n-        goto leave_node;\n-        case XML_COMMENT_NODE:\n-        DICT_COPY(cur->content, clone->content);\n-        goto leave_node;\n-        default:\n-        goto internal_error;\n-    }\n@@ -9722,2 +9731,2 @@\n-    if (cur->ns == NULL)\n-        goto end_ns_reference;\n+        if (cur->ns == NULL)\n+            goto end_ns_reference;\n@@ -9726,9 +9735,11 @@\n-    \/*\n-    ** The following will take care of references to ns-decls ********\n-    ** and is intended only for element- and attribute-nodes.\n-    **\n-    *\/\n-    if (! parnsdone) {\n-        if (destParent && (ctxt == NULL)) {\n-        if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap, destParent) == -1)\n-            goto internal_error;\n+        \/*\n+        ** The following will take care of references to ns-decls ********\n+        ** and is intended only for element- and attribute-nodes.\n+        **\n+        *\/\n+        if (! parnsdone) {\n+            if (destParent && (ctxt == NULL)) {\n+                if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap, destParent) == -1)\n+                    goto internal_error;\n+            }\n+            parnsdone = 1;\n@@ -9736,6 +9747,0 @@\n-        parnsdone = 1;\n-    }\n-    \/*\n-    * Adopt ns-references.\n-    *\/\n-    if (XML_NSMAP_NOTEMPTY(nsMap)) {\n@@ -9743,1 +9748,1 @@\n-        * Search for a mapping.\n+        * Adopt ns-references.\n@@ -9745,3 +9750,1 @@\n-        XML_NSMAP_FOREACH(nsMap, mi) {\n-        if ((mi->shadowDepth == -1) &&\n-            (cur->ns == mi->oldNs)) {\n+        if (XML_NSMAP_NOTEMPTY(nsMap)) {\n@@ -9749,1 +9752,1 @@\n-            * This is the nice case: a mapping was found.\n+            * Search for a mapping.\n@@ -9751,3 +9754,10 @@\n-            clone->ns = mi->newNs;\n-            goto end_ns_reference;\n-        }\n+            XML_NSMAP_FOREACH(nsMap, mi) {\n+                if ((mi->shadowDepth == -1) &&\n+                    (cur->ns == mi->oldNs)) {\n+                    \/*\n+                    * This is the nice case: a mapping was found.\n+                    *\/\n+                    clone->ns = mi->newNs;\n+                    goto end_ns_reference;\n+                }\n+            }\n@@ -9755,18 +9765,0 @@\n-    }\n-    \/*\n-    * No matching namespace in scope. We need a new one.\n-    *\/\n-    if ((ctxt != NULL) && (ctxt->getNsForNodeFunc != NULL)) {\n-        \/*\n-        * User-defined behaviour.\n-        *\/\n-        ns = ctxt->getNsForNodeFunc(ctxt, cur,\n-        cur->ns->href, cur->ns->prefix);\n-        \/*\n-        * Add user's mapping.\n-        *\/\n-        if (xmlDOMWrapNsMapAddItem(&nsMap, -1,\n-        cur->ns, ns, XML_TREE_NSMAP_CUSTOM) == NULL)\n-        goto internal_error;\n-        clone->ns = ns;\n-    } else {\n@@ -9774,1 +9766,1 @@\n-        * Acquire a normalized ns-decl and add it to the map.\n+        * No matching namespace in scope. We need a new one.\n@@ -9776,12 +9768,29 @@\n-        if (xmlDOMWrapNSNormAcquireNormalizedNs(destDoc,\n-        \/* ns-decls on curElem or on destDoc->oldNs *\/\n-        destParent ? curElem : NULL,\n-        cur->ns, &ns,\n-        &nsMap, depth,\n-        \/* if we need to search only in the ancestor-axis *\/\n-        ancestorsOnly,\n-        \/* ns-decls must be prefixed for attributes. *\/\n-        (cur->type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)\n-        goto internal_error;\n-        clone->ns = ns;\n-    }\n+        if ((ctxt != NULL) && (ctxt->getNsForNodeFunc != NULL)) {\n+            \/*\n+            * User-defined behaviour.\n+            *\/\n+            ns = ctxt->getNsForNodeFunc(ctxt, cur,\n+                cur->ns->href, cur->ns->prefix);\n+            \/*\n+            * Add user's mapping.\n+            *\/\n+            if (xmlDOMWrapNsMapAddItem(&nsMap, -1,\n+                cur->ns, ns, XML_TREE_NSMAP_CUSTOM) == NULL)\n+                goto internal_error;\n+            clone->ns = ns;\n+        } else {\n+            \/*\n+            * Acquire a normalized ns-decl and add it to the map.\n+            *\/\n+            if (xmlDOMWrapNSNormAcquireNormalizedNs(destDoc,\n+                \/* ns-decls on curElem or on destDoc->oldNs *\/\n+                destParent ? curElem : NULL,\n+                cur->ns, &ns,\n+                &nsMap, depth,\n+                \/* if we need to search only in the ancestor-axis *\/\n+                ancestorsOnly,\n+                \/* ns-decls must be prefixed for attributes. *\/\n+                (cur->type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)\n+                goto internal_error;\n+            clone->ns = ns;\n+        }\n@@ -9791,9 +9800,9 @@\n-    \/*\n-    * Some post-processing.\n-    *\n-    * Handle ID attributes.\n-    *\/\n-    if ((clone->type == XML_ATTRIBUTE_NODE) &&\n-        (clone->parent != NULL))\n-    {\n-        if (xmlIsID(destDoc, clone->parent, (xmlAttrPtr) clone)) {\n+        \/*\n+        * Some post-processing.\n+        *\n+        * Handle ID attributes.\n+        *\/\n+        if ((clone->type == XML_ATTRIBUTE_NODE) &&\n+            (clone->parent != NULL))\n+        {\n+            if (xmlIsID(destDoc, clone->parent, (xmlAttrPtr) clone)) {\n@@ -9801,1 +9810,1 @@\n-        xmlChar *idVal;\n+                xmlChar *idVal;\n@@ -9803,6 +9812,9 @@\n-        idVal = xmlNodeListGetString(cur->doc, cur->children, 1);\n-        if (idVal != NULL) {\n-            if (xmlAddID(NULL, destDoc, idVal, (xmlAttrPtr) cur) == NULL) {\n-            \/* TODO: error message. *\/\n-            xmlFree(idVal);\n-            goto internal_error;\n+                idVal = xmlNodeListGetString(cur->doc, cur->children, 1);\n+                if (idVal != NULL) {\n+                    if (xmlAddID(NULL, destDoc, idVal, (xmlAttrPtr) cur) == NULL) {\n+                        \/* TODO: error message. *\/\n+                        xmlFree(idVal);\n+                        goto internal_error;\n+                    }\n+                    xmlFree(idVal);\n+                }\n@@ -9810,27 +9822,0 @@\n-            xmlFree(idVal);\n-        }\n-        }\n-    }\n-    \/*\n-    **\n-    ** The following will traverse the tree **************************\n-    **\n-    *\n-    * Walk the element's attributes before descending into child-nodes.\n-    *\/\n-    if ((cur->type == XML_ELEMENT_NODE) && (cur->properties != NULL)) {\n-        prevClone = NULL;\n-        parentClone = clone;\n-        cur = (xmlNodePtr) cur->properties;\n-        continue;\n-    }\n-into_content:\n-    \/*\n-    * Descend into child-nodes.\n-    *\/\n-    if (cur->children != NULL) {\n-        if (deep || (cur->type == XML_ATTRIBUTE_NODE)) {\n-        prevClone = NULL;\n-        parentClone = clone;\n-        cur = cur->children;\n-        continue;\n@@ -9838,12 +9823,0 @@\n-    }\n-\n-leave_node:\n-    \/*\n-    * At this point we are done with the node, its content\n-    * and an element-nodes's attribute-nodes.\n-    *\/\n-    if (cur == node)\n-        break;\n-    if ((cur->type == XML_ELEMENT_NODE) ||\n-        (cur->type == XML_XINCLUDE_START) ||\n-        (cur->type == XML_XINCLUDE_END)) {\n@@ -9851,1 +9824,5 @@\n-        * TODO: Do we expect nsDefs on XML_XINCLUDE_START?\n+        **\n+        ** The following will traverse the tree **************************\n+        **\n+        *\n+        * Walk the element's attributes before descending into child-nodes.\n@@ -9853,1 +9830,7 @@\n-        if (XML_NSMAP_NOTEMPTY(nsMap)) {\n+        if ((cur->type == XML_ELEMENT_NODE) && (cur->properties != NULL)) {\n+            prevClone = NULL;\n+            parentClone = clone;\n+            cur = (xmlNodePtr) cur->properties;\n+            continue;\n+        }\n+into_content:\n@@ -9855,1 +9838,1 @@\n-        * Pop mappings.\n+        * Descend into child-nodes.\n@@ -9857,4 +9840,7 @@\n-        while ((nsMap->last != NULL) &&\n-            (nsMap->last->depth >= depth))\n-        {\n-            XML_NSMAP_POP(nsMap, mi)\n+        if (cur->children != NULL) {\n+            if (deep || (cur->type == XML_ATTRIBUTE_NODE)) {\n+                prevClone = NULL;\n+                parentClone = clone;\n+                cur = cur->children;\n+                continue;\n+            }\n@@ -9862,0 +9848,2 @@\n+\n+leave_node:\n@@ -9863,1 +9851,2 @@\n-        * Unshadow.\n+        * At this point we are done with the node, its content\n+        * and an element-nodes's attribute-nodes.\n@@ -9865,3 +9854,26 @@\n-        XML_NSMAP_FOREACH(nsMap, mi) {\n-            if (mi->shadowDepth >= depth)\n-            mi->shadowDepth = -1;\n+        if (cur == node)\n+            break;\n+        if ((cur->type == XML_ELEMENT_NODE) ||\n+            (cur->type == XML_XINCLUDE_START) ||\n+            (cur->type == XML_XINCLUDE_END)) {\n+            \/*\n+            * TODO: Do we expect nsDefs on XML_XINCLUDE_START?\n+            *\/\n+            if (XML_NSMAP_NOTEMPTY(nsMap)) {\n+                \/*\n+                * Pop mappings.\n+                *\/\n+                while ((nsMap->last != NULL) &&\n+                    (nsMap->last->depth >= depth))\n+                {\n+                    XML_NSMAP_POP(nsMap, mi)\n+                }\n+                \/*\n+                * Unshadow.\n+                *\/\n+                XML_NSMAP_FOREACH(nsMap, mi) {\n+                    if (mi->shadowDepth >= depth)\n+                        mi->shadowDepth = -1;\n+                }\n+            }\n+            depth--;\n@@ -9869,0 +9881,26 @@\n+        if (cur->next != NULL) {\n+            prevClone = clone;\n+            cur = cur->next;\n+        } else if (cur->type != XML_ATTRIBUTE_NODE) {\n+            \/*\n+            * Set clone->last.\n+            *\/\n+            if (clone->parent != NULL)\n+                clone->parent->last = clone;\n+            clone = clone->parent;\n+            if (clone != NULL)\n+                parentClone = clone->parent;\n+            \/*\n+            * Process parent --> next;\n+            *\/\n+            cur = cur->parent;\n+            goto leave_node;\n+        } else {\n+            \/* This is for attributes only. *\/\n+            clone = clone->parent;\n+            parentClone = clone->parent;\n+            \/*\n+            * Process parent-element --> children.\n+            *\/\n+            cur = cur->parent;\n+            goto into_content;\n@@ -9870,29 +9908,0 @@\n-        depth--;\n-    }\n-    if (cur->next != NULL) {\n-        prevClone = clone;\n-        cur = cur->next;\n-    } else if (cur->type != XML_ATTRIBUTE_NODE) {\n-        \/*\n-        * Set clone->last.\n-        *\/\n-        if (clone->parent != NULL)\n-        clone->parent->last = clone;\n-        clone = clone->parent;\n-        if (clone != NULL)\n-        parentClone = clone->parent;\n-        \/*\n-        * Process parent --> next;\n-        *\/\n-        cur = cur->parent;\n-        goto leave_node;\n-    } else {\n-        \/* This is for attributes only. *\/\n-        clone = clone->parent;\n-        parentClone = clone->parent;\n-        \/*\n-        * Process parent-element --> children.\n-        *\/\n-        cur = cur->parent;\n-        goto into_content;\n-    }\n@@ -9910,12 +9919,12 @@\n-    if ((ctxt) && (ctxt->namespaceMap == nsMap)) {\n-        \/*\n-        * Just cleanup the map but don't free.\n-        *\/\n-        if (nsMap->first) {\n-        if (nsMap->pool)\n-            nsMap->last->next = nsMap->pool;\n-        nsMap->pool = nsMap->first;\n-        nsMap->first = NULL;\n-        }\n-    } else\n-        xmlDOMWrapNsMapFree(nsMap);\n+        if ((ctxt) && (ctxt->namespaceMap == nsMap)) {\n+            \/*\n+            * Just cleanup the map but don't free.\n+            *\/\n+            if (nsMap->first) {\n+                if (nsMap->pool)\n+                    nsMap->last->next = nsMap->pool;\n+                nsMap->pool = nsMap->first;\n+                nsMap->first = NULL;\n+            }\n+        } else\n+            xmlDOMWrapNsMapFree(nsMap);\n@@ -9949,5 +9958,5 @@\n-            xmlDocPtr sourceDoc,\n-            xmlAttrPtr attr,\n-            xmlDocPtr destDoc,\n-            xmlNodePtr destParent,\n-            int options ATTRIBUTE_UNUSED)\n+                    xmlDocPtr sourceDoc,\n+                    xmlAttrPtr attr,\n+                    xmlDocPtr destDoc,\n+                    xmlNodePtr destParent,\n+                    int options ATTRIBUTE_UNUSED)\n@@ -9959,1 +9968,1 @@\n-    return (-1);\n+        return (-1);\n@@ -9963,1 +9972,1 @@\n-    xmlNsPtr ns = NULL;\n+        xmlNsPtr ns = NULL;\n@@ -9965,21 +9974,2 @@\n-    if (ctxt != NULL) {\n-        \/* TODO: User defined. *\/\n-    }\n-    \/* XML Namespace. *\/\n-    if (IS_STR_XML(attr->ns->prefix)) {\n-        ns = xmlTreeEnsureXMLDecl(destDoc);\n-    } else if (destParent == NULL) {\n-        \/*\n-        * Store in @destDoc->oldNs.\n-        *\/\n-        ns = xmlDOMWrapStoreNs(destDoc, attr->ns->href, attr->ns->prefix);\n-    } else {\n-        \/*\n-        * Declare on @destParent.\n-        *\/\n-        if (xmlSearchNsByNamespaceStrict(destDoc, destParent, attr->ns->href,\n-        &ns, 1) == -1)\n-        goto internal_error;\n-        if (ns == NULL) {\n-        ns = xmlDOMWrapNSNormDeclareNsForced(destDoc, destParent,\n-            attr->ns->href, attr->ns->prefix, 1);\n+        if (ctxt != NULL) {\n+            \/* TODO: User defined. *\/\n@@ -9987,4 +9977,23 @@\n-    }\n-    if (ns == NULL)\n-        goto internal_error;\n-    attr->ns = ns;\n+        \/* XML Namespace. *\/\n+        if (IS_STR_XML(attr->ns->prefix)) {\n+            ns = xmlTreeEnsureXMLDecl(destDoc);\n+        } else if (destParent == NULL) {\n+            \/*\n+            * Store in @destDoc->oldNs.\n+            *\/\n+            ns = xmlDOMWrapStoreNs(destDoc, attr->ns->href, attr->ns->prefix);\n+        } else {\n+            \/*\n+            * Declare on @destParent.\n+            *\/\n+            if (xmlSearchNsByNamespaceStrict(destDoc, destParent, attr->ns->href,\n+                &ns, 1) == -1)\n+                goto internal_error;\n+            if (ns == NULL) {\n+                ns = xmlDOMWrapNSNormDeclareNsForced(destDoc, destParent,\n+                    attr->ns->href, attr->ns->prefix, 1);\n+            }\n+        }\n+        if (ns == NULL)\n+            goto internal_error;\n+        attr->ns = ns;\n@@ -10000,1 +10009,1 @@\n-    return (0);\n+        return (0);\n@@ -10005,24 +10014,32 @@\n-    cur->doc = destDoc;\n-    switch (cur->type) {\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        XML_TREE_ADOPT_STR_2(cur->content)\n-        break;\n-        case XML_ENTITY_REF_NODE:\n-        \/*\n-        * Remove reference to the entity-node.\n-        *\/\n-        cur->content = NULL;\n-        cur->children = NULL;\n-        cur->last = NULL;\n-        if ((destDoc->intSubset) || (destDoc->extSubset)) {\n-            xmlEntityPtr ent;\n-            \/*\n-            * Assign new entity-node if available.\n-            *\/\n-            ent = xmlGetDocEntity(destDoc, cur->name);\n-            if (ent != NULL) {\n-            cur->content = ent->content;\n-            cur->children = (xmlNodePtr) ent;\n-            cur->last = (xmlNodePtr) ent;\n-            }\n+        cur->doc = destDoc;\n+        switch (cur->type) {\n+            case XML_TEXT_NODE:\n+            case XML_CDATA_SECTION_NODE:\n+                XML_TREE_ADOPT_STR_2(cur->content)\n+                break;\n+            case XML_ENTITY_REF_NODE:\n+                \/*\n+                * Remove reference to the entity-node.\n+                *\/\n+                cur->content = NULL;\n+                cur->children = NULL;\n+                cur->last = NULL;\n+                if ((destDoc->intSubset) || (destDoc->extSubset)) {\n+                    xmlEntityPtr ent;\n+                    \/*\n+                    * Assign new entity-node if available.\n+                    *\/\n+                    ent = xmlGetDocEntity(destDoc, cur->name);\n+                    if (ent != NULL) {\n+                        cur->content = ent->content;\n+                        cur->children = (xmlNodePtr) ent;\n+                        cur->last = (xmlNodePtr) ent;\n+                    }\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+        if (cur->children != NULL) {\n+            cur = cur->children;\n+            continue;\n@@ -10030,8 +10047,0 @@\n-        break;\n-        default:\n-        break;\n-    }\n-    if (cur->children != NULL) {\n-        cur = cur->children;\n-        continue;\n-    }\n@@ -10039,8 +10048,8 @@\n-    if (cur == (xmlNodePtr) attr)\n-        break;\n-    if (cur->next != NULL)\n-        cur = cur->next;\n-    else {\n-        cur = cur->parent;\n-        goto next_sibling;\n-    }\n+        if (cur == (xmlNodePtr) attr)\n+            break;\n+        if (cur->next != NULL)\n+            cur = cur->next;\n+        else {\n+            cur = cur->parent;\n+            goto next_sibling;\n+        }\n@@ -10082,5 +10091,5 @@\n-            xmlDocPtr sourceDoc,\n-            xmlNodePtr node,\n-            xmlDocPtr destDoc,\n-            xmlNodePtr destParent,\n-            int options)\n+                    xmlDocPtr sourceDoc,\n+                    xmlNodePtr node,\n+                    xmlDocPtr destDoc,\n+                    xmlNodePtr destParent,\n+                    int options)\n@@ -10090,2 +10099,2 @@\n-    ((destParent != NULL) && (destParent->doc != destDoc)))\n-    return(-1);\n+        ((destParent != NULL) && (destParent->doc != destDoc)))\n+        return(-1);\n@@ -10096,5 +10105,5 @@\n-    (node->doc != sourceDoc)) {\n-    \/*\n-    * Might be an XIncluded node.\n-    *\/\n-    return (-1);\n+        (node->doc != sourceDoc)) {\n+        \/*\n+        * Might be an XIncluded node.\n+        *\/\n+        return (-1);\n@@ -10103,1 +10112,1 @@\n-    sourceDoc = node->doc;\n+        sourceDoc = node->doc;\n@@ -10105,1 +10114,1 @@\n-    return (-1);\n+        return (-1);\n@@ -10107,13 +10116,13 @@\n-    case XML_ELEMENT_NODE:\n-    case XML_ATTRIBUTE_NODE:\n-    case XML_TEXT_NODE:\n-    case XML_CDATA_SECTION_NODE:\n-    case XML_ENTITY_REF_NODE:\n-    case XML_PI_NODE:\n-    case XML_COMMENT_NODE:\n-        break;\n-    case XML_DOCUMENT_FRAG_NODE:\n-        \/* TODO: Support document-fragment-nodes. *\/\n-        return (2);\n-    default:\n-        return (1);\n+        case XML_ELEMENT_NODE:\n+        case XML_ATTRIBUTE_NODE:\n+        case XML_TEXT_NODE:\n+        case XML_CDATA_SECTION_NODE:\n+        case XML_ENTITY_REF_NODE:\n+        case XML_PI_NODE:\n+        case XML_COMMENT_NODE:\n+            break;\n+        case XML_DOCUMENT_FRAG_NODE:\n+            \/* TODO: Support document-fragment-nodes. *\/\n+            return (2);\n+        default:\n+            return (1);\n@@ -10125,1 +10134,1 @@\n-    xmlUnlinkNode(node);\n+        xmlUnlinkNode(node);\n@@ -10128,2 +10137,2 @@\n-        return (xmlDOMWrapAdoptBranch(ctxt, sourceDoc, node,\n-            destDoc, destParent, options));\n+            return (xmlDOMWrapAdoptBranch(ctxt, sourceDoc, node,\n+                    destDoc, destParent, options));\n@@ -10131,2 +10140,2 @@\n-        return (xmlDOMWrapAdoptAttr(ctxt, sourceDoc,\n-        (xmlAttrPtr) node, destDoc, destParent, options));\n+            return (xmlDOMWrapAdoptAttr(ctxt, sourceDoc,\n+                (xmlAttrPtr) node, destDoc, destParent, options));\n@@ -10134,2 +10143,2 @@\n-    xmlNodePtr cur = node;\n-    int adoptStr = 1;\n+        xmlNodePtr cur = node;\n+        int adoptStr = 1;\n@@ -10137,13 +10146,1 @@\n-    cur->doc = destDoc;\n-    \/*\n-    * Optimize string adoption.\n-    *\/\n-    if ((sourceDoc != NULL) &&\n-        (sourceDoc->dict == destDoc->dict))\n-        adoptStr = 0;\n-    switch (node->type) {\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        XML_TREE_ADOPT_STR_2(node->content)\n-            break;\n-        case XML_ENTITY_REF_NODE:\n+        cur->doc = destDoc;\n@@ -10151,1 +10148,1 @@\n-        * Remove reference to the entity-node.\n+        * Optimize string adoption.\n@@ -10153,13 +10150,33 @@\n-        node->content = NULL;\n-        node->children = NULL;\n-        node->last = NULL;\n-        if ((destDoc->intSubset) || (destDoc->extSubset)) {\n-            xmlEntityPtr ent;\n-            \/*\n-            * Assign new entity-node if available.\n-            *\/\n-            ent = xmlGetDocEntity(destDoc, node->name);\n-            if (ent != NULL) {\n-            node->content = ent->content;\n-            node->children = (xmlNodePtr) ent;\n-            node->last = (xmlNodePtr) ent;\n+        if ((sourceDoc != NULL) &&\n+            (sourceDoc->dict == destDoc->dict))\n+                adoptStr = 0;\n+        switch (node->type) {\n+            case XML_TEXT_NODE:\n+            case XML_CDATA_SECTION_NODE:\n+                XML_TREE_ADOPT_STR_2(node->content)\n+                    break;\n+            case XML_ENTITY_REF_NODE:\n+                \/*\n+                * Remove reference to the entity-node.\n+                *\/\n+                node->content = NULL;\n+                node->children = NULL;\n+                node->last = NULL;\n+                if ((destDoc->intSubset) || (destDoc->extSubset)) {\n+                    xmlEntityPtr ent;\n+                    \/*\n+                    * Assign new entity-node if available.\n+                    *\/\n+                    ent = xmlGetDocEntity(destDoc, node->name);\n+                    if (ent != NULL) {\n+                        node->content = ent->content;\n+                        node->children = (xmlNodePtr) ent;\n+                        node->last = (xmlNodePtr) ent;\n+                    }\n+                }\n+                XML_TREE_ADOPT_STR(node->name)\n+                break;\n+            case XML_PI_NODE: {\n+                XML_TREE_ADOPT_STR(node->name)\n+                XML_TREE_ADOPT_STR_2(node->content)\n+                break;\n@@ -10167,0 +10184,2 @@\n+            default:\n+                break;\n@@ -10168,10 +10187,0 @@\n-        XML_TREE_ADOPT_STR(node->name)\n-        break;\n-        case XML_PI_NODE: {\n-        XML_TREE_ADOPT_STR(node->name)\n-        XML_TREE_ADOPT_STR_2(node->content)\n-        break;\n-        }\n-        default:\n-        break;\n-    }\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/tree.c","additions":3676,"deletions":3667,"binary":false,"changes":7343,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-       TRIO_CONST unsigned char *values)\n+           TRIO_CONST unsigned char *values)\n@@ -196,2 +196,2 @@\n-       double number,\n-       int *has_mantissa)\n+           double number,\n+           int *has_mantissa)\n@@ -220,1 +220,1 @@\n-       double number)\n+           double number)\n@@ -227,1 +227,1 @@\n-            & ieee_754_sign_mask[i]);\n+                    & ieee_754_sign_mask[i]);\n@@ -373,1 +373,1 @@\n-       double number)\n+           double number)\n@@ -416,9 +416,9 @@\n-         * NaN is the only number which does not compare to itself\n-         *\/\n-        ((TRIO_VOLATILE double)number != (TRIO_VOLATILE double)number) ||\n-        \/*\n-         * Fallback solution if NaN compares to NaN\n-         *\/\n-        ((number != 0.0) &&\n-         (fraction = modf(number, &integral),\n-          integral == fraction)));\n+             * NaN is the only number which does not compare to itself\n+             *\/\n+            ((TRIO_VOLATILE double)number != (TRIO_VOLATILE double)number) ||\n+            \/*\n+             * Fallback solution if NaN compares to NaN\n+             *\/\n+            ((number != 0.0) &&\n+             (fraction = modf(number, &integral),\n+              integral == fraction)));\n@@ -444,1 +444,1 @@\n-       double number)\n+           double number)\n@@ -452,2 +452,2 @@\n-      ? 1\n-      : ((fp_class(number) == FP_NEG_INF) ? -1 : 0));\n+          ? 1\n+          : ((fp_class(number) == FP_NEG_INF) ? -1 : 0));\n@@ -469,2 +469,2 @@\n-      ? 1\n-      : ((_fpclass(number) == _FPCLASS_NINF) ? -1 : 0));\n+          ? 1\n+          : ((_fpclass(number) == _FPCLASS_NINF) ? -1 : 0));\n@@ -499,2 +499,2 @@\n-        ? 1\n-        : ((number == -infinity) ? -1 : 0));\n+            ? 1\n+            : ((number == -infinity) ? -1 : 0));\n@@ -512,1 +512,1 @@\n-    \/* Temporary fix - this routine is not used anywhere *\/\n+        \/* Temporary fix - this routine is not used anywhere *\/\n@@ -522,1 +522,1 @@\n-       double number)\n+           double number)\n@@ -562,2 +562,2 @@\n-       double number,\n-       int *is_negative)\n+           double number,\n+           int *is_negative)\n@@ -734,1 +734,1 @@\n-       double number)\n+           double number)\n@@ -743,1 +743,1 @@\n-    \/* Temporary fix - this routine is not used in libxml *\/\n+        \/* Temporary fix - this routine is not used in libxml *\/\n@@ -753,1 +753,1 @@\n-       double number)\n+           double number)\n@@ -778,1 +778,1 @@\n-       int type)\n+           int type)\n@@ -799,2 +799,2 @@\n-       TRIO_CONST char *prefix,\n-       double number)\n+           TRIO_CONST char *prefix,\n+           double number)\n@@ -803,4 +803,4 @@\n-     prefix,\n-     trio_signbit(number) ? \"-\" : \"+\",\n-     getClassification(TRIO_FPCLASSIFY(number)),\n-     number);\n+         prefix,\n+         trio_signbit(number) ? \"-\" : \"+\",\n+         getClassification(TRIO_FPCLASSIFY(number)),\n+         number);\n@@ -833,10 +833,10 @@\n-     my_nan,\n-     ((unsigned char *)&my_nan)[0],\n-     ((unsigned char *)&my_nan)[1],\n-     ((unsigned char *)&my_nan)[2],\n-     ((unsigned char *)&my_nan)[3],\n-     ((unsigned char *)&my_nan)[4],\n-     ((unsigned char *)&my_nan)[5],\n-     ((unsigned char *)&my_nan)[6],\n-     ((unsigned char *)&my_nan)[7],\n-     trio_isnan(my_nan), trio_isinf(my_nan));\n+         my_nan,\n+         ((unsigned char *)&my_nan)[0],\n+         ((unsigned char *)&my_nan)[1],\n+         ((unsigned char *)&my_nan)[2],\n+         ((unsigned char *)&my_nan)[3],\n+         ((unsigned char *)&my_nan)[4],\n+         ((unsigned char *)&my_nan)[5],\n+         ((unsigned char *)&my_nan)[6],\n+         ((unsigned char *)&my_nan)[7],\n+         trio_isnan(my_nan), trio_isinf(my_nan));\n@@ -844,10 +844,10 @@\n-     my_pinf,\n-     ((unsigned char *)&my_pinf)[0],\n-     ((unsigned char *)&my_pinf)[1],\n-     ((unsigned char *)&my_pinf)[2],\n-     ((unsigned char *)&my_pinf)[3],\n-     ((unsigned char *)&my_pinf)[4],\n-     ((unsigned char *)&my_pinf)[5],\n-     ((unsigned char *)&my_pinf)[6],\n-     ((unsigned char *)&my_pinf)[7],\n-     trio_isnan(my_pinf), trio_isinf(my_pinf));\n+         my_pinf,\n+         ((unsigned char *)&my_pinf)[0],\n+         ((unsigned char *)&my_pinf)[1],\n+         ((unsigned char *)&my_pinf)[2],\n+         ((unsigned char *)&my_pinf)[3],\n+         ((unsigned char *)&my_pinf)[4],\n+         ((unsigned char *)&my_pinf)[5],\n+         ((unsigned char *)&my_pinf)[6],\n+         ((unsigned char *)&my_pinf)[7],\n+         trio_isnan(my_pinf), trio_isinf(my_pinf));\n@@ -855,10 +855,10 @@\n-     my_ninf,\n-     ((unsigned char *)&my_ninf)[0],\n-     ((unsigned char *)&my_ninf)[1],\n-     ((unsigned char *)&my_ninf)[2],\n-     ((unsigned char *)&my_ninf)[3],\n-     ((unsigned char *)&my_ninf)[4],\n-     ((unsigned char *)&my_ninf)[5],\n-     ((unsigned char *)&my_ninf)[6],\n-     ((unsigned char *)&my_ninf)[7],\n-     trio_isnan(my_ninf), trio_isinf(my_ninf));\n+         my_ninf,\n+         ((unsigned char *)&my_ninf)[0],\n+         ((unsigned char *)&my_ninf)[1],\n+         ((unsigned char *)&my_ninf)[2],\n+         ((unsigned char *)&my_ninf)[3],\n+         ((unsigned char *)&my_ninf)[4],\n+         ((unsigned char *)&my_ninf)[5],\n+         ((unsigned char *)&my_ninf)[6],\n+         ((unsigned char *)&my_ninf)[7],\n+         trio_isnan(my_ninf), trio_isinf(my_ninf));\n@@ -879,10 +879,10 @@\n-     my_nan,\n-     ((unsigned char *)&my_nan)[0],\n-     ((unsigned char *)&my_nan)[1],\n-     ((unsigned char *)&my_nan)[2],\n-     ((unsigned char *)&my_nan)[3],\n-     ((unsigned char *)&my_nan)[4],\n-     ((unsigned char *)&my_nan)[5],\n-     ((unsigned char *)&my_nan)[6],\n-     ((unsigned char *)&my_nan)[7],\n-     trio_isnan(my_nan), trio_isinf(my_nan));\n+         my_nan,\n+         ((unsigned char *)&my_nan)[0],\n+         ((unsigned char *)&my_nan)[1],\n+         ((unsigned char *)&my_nan)[2],\n+         ((unsigned char *)&my_nan)[3],\n+         ((unsigned char *)&my_nan)[4],\n+         ((unsigned char *)&my_nan)[5],\n+         ((unsigned char *)&my_nan)[6],\n+         ((unsigned char *)&my_nan)[7],\n+         trio_isnan(my_nan), trio_isinf(my_nan));\n@@ -890,10 +890,10 @@\n-     my_pinf,\n-     ((unsigned char *)&my_pinf)[0],\n-     ((unsigned char *)&my_pinf)[1],\n-     ((unsigned char *)&my_pinf)[2],\n-     ((unsigned char *)&my_pinf)[3],\n-     ((unsigned char *)&my_pinf)[4],\n-     ((unsigned char *)&my_pinf)[5],\n-     ((unsigned char *)&my_pinf)[6],\n-     ((unsigned char *)&my_pinf)[7],\n-     trio_isnan(my_pinf), trio_isinf(my_pinf));\n+         my_pinf,\n+         ((unsigned char *)&my_pinf)[0],\n+         ((unsigned char *)&my_pinf)[1],\n+         ((unsigned char *)&my_pinf)[2],\n+         ((unsigned char *)&my_pinf)[3],\n+         ((unsigned char *)&my_pinf)[4],\n+         ((unsigned char *)&my_pinf)[5],\n+         ((unsigned char *)&my_pinf)[6],\n+         ((unsigned char *)&my_pinf)[7],\n+         trio_isnan(my_pinf), trio_isinf(my_pinf));\n@@ -901,10 +901,10 @@\n-     my_ninf,\n-     ((unsigned char *)&my_ninf)[0],\n-     ((unsigned char *)&my_ninf)[1],\n-     ((unsigned char *)&my_ninf)[2],\n-     ((unsigned char *)&my_ninf)[3],\n-     ((unsigned char *)&my_ninf)[4],\n-     ((unsigned char *)&my_ninf)[5],\n-     ((unsigned char *)&my_ninf)[6],\n-     ((unsigned char *)&my_ninf)[7],\n-     trio_isnan(my_ninf), trio_isinf(my_ninf));\n+         my_ninf,\n+         ((unsigned char *)&my_ninf)[0],\n+         ((unsigned char *)&my_ninf)[1],\n+         ((unsigned char *)&my_ninf)[2],\n+         ((unsigned char *)&my_ninf)[3],\n+         ((unsigned char *)&my_ninf)[4],\n+         ((unsigned char *)&my_ninf)[5],\n+         ((unsigned char *)&my_ninf)[6],\n+         ((unsigned char *)&my_ninf)[7],\n+         trio_isnan(my_ninf), trio_isinf(my_ninf));\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/trionan.c","additions":96,"deletions":96,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    \/* Temporary fix - these 2 routines not used in libxml *\/\n+        \/* Temporary fix - these 2 routines not used in libxml *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/trionan.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,3 +142,3 @@\n- *                                  *\n- *                         RFC 3986 parser              *\n- *                                  *\n+ *                                                                      *\n+ *                         RFC 3986 parser                              *\n+ *                                                                      *\n@@ -148,1 +148,1 @@\n-#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||       \\\n+#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||               \\\n@@ -150,2 +150,2 @@\n-#define ISA_HEXDIG(p)                           \\\n-       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||     \\\n+#define ISA_HEXDIG(p)                                                   \\\n+       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||             \\\n@@ -158,4 +158,4 @@\n-#define ISA_SUB_DELIM(p)                        \\\n-      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||     \\\n-       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||     \\\n-       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||     \\\n+#define ISA_SUB_DELIM(p)                                                \\\n+      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||         \\\n+       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||         \\\n+       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||         \\\n@@ -167,1 +167,1 @@\n-#define ISA_GEN_DELIM(p)                        \\\n+#define ISA_GEN_DELIM(p)                                                \\\n@@ -180,2 +180,2 @@\n-#define ISA_UNRESERVED(p)                       \\\n-      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||       \\\n+#define ISA_UNRESERVED(p)                                               \\\n+      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||           \\\n@@ -187,1 +187,1 @@\n-#define ISA_PCT_ENCODED(p)                      \\\n+#define ISA_PCT_ENCODED(p)                                              \\\n@@ -193,1 +193,1 @@\n-#define ISA_PCHAR(p)                            \\\n+#define ISA_PCHAR(p)                                                    \\\n@@ -213,1 +213,1 @@\n-    return(-1);\n+        return(-1);\n@@ -217,1 +217,1 @@\n-    return(2);\n+        return(2);\n@@ -222,2 +222,2 @@\n-    if (uri->scheme != NULL) xmlFree(uri->scheme);\n-    uri->scheme = STRNDUP(*str, cur - *str);\n+        if (uri->scheme != NULL) xmlFree(uri->scheme);\n+        uri->scheme = STRNDUP(*str, cur - *str);\n@@ -261,4 +261,4 @@\n-    if (uri->cleanup & 2)\n-        uri->fragment = STRNDUP(*str, cur - *str);\n-    else\n-        uri->fragment = xmlURIUnescapeString(*str, cur - *str, NULL);\n+        if (uri->cleanup & 2)\n+            uri->fragment = STRNDUP(*str, cur - *str);\n+        else\n+            uri->fragment = xmlURIUnescapeString(*str, cur - *str, NULL);\n@@ -297,4 +297,4 @@\n-    if (uri->cleanup & 2)\n-        uri->query = STRNDUP(*str, cur - *str);\n-    else\n-        uri->query = xmlURIUnescapeString(*str, cur - *str, NULL);\n+        if (uri->cleanup & 2)\n+            uri->query = STRNDUP(*str, cur - *str);\n+        else\n+            uri->query = xmlURIUnescapeString(*str, cur - *str, NULL);\n@@ -302,6 +302,6 @@\n-    \/* Save the raw bytes of the query as well.\n-     * See: http:\/\/mail.gnome.org\/archives\/xml\/2007-April\/thread.html#00114\n-     *\/\n-    if (uri->query_raw != NULL)\n-        xmlFree (uri->query_raw);\n-    uri->query_raw = STRNDUP (*str, cur - *str);\n+        \/* Save the raw bytes of the query as well.\n+         * See: http:\/\/mail.gnome.org\/archives\/xml\/2007-April\/thread.html#00114\n+         *\/\n+        if (uri->query_raw != NULL)\n+            xmlFree (uri->query_raw);\n+        uri->query_raw = STRNDUP (*str, cur - *str);\n@@ -332,1 +332,1 @@\n-    while (ISA_DIGIT(cur)) {\n+        while (ISA_DIGIT(cur)) {\n@@ -340,1 +340,1 @@\n-        port += digit;\n+            port += digit;\n@@ -342,6 +342,6 @@\n-        cur++;\n-    }\n-    if (uri != NULL)\n-        uri->port = port;\n-    *str = cur;\n-    return(0);\n+            cur++;\n+        }\n+        if (uri != NULL)\n+            uri->port = port;\n+        *str = cur;\n+        return(0);\n@@ -372,1 +372,1 @@\n-    NEXT(cur);\n+        NEXT(cur);\n@@ -374,9 +374,9 @@\n-    if (uri != NULL) {\n-        if (uri->user != NULL) xmlFree(uri->user);\n-        if (uri->cleanup & 2)\n-        uri->user = STRNDUP(*str, cur - *str);\n-        else\n-        uri->user = xmlURIUnescapeString(*str, cur - *str, NULL);\n-    }\n-    *str = cur;\n-    return(0);\n+        if (uri != NULL) {\n+            if (uri->user != NULL) xmlFree(uri->user);\n+            if (uri->cleanup & 2)\n+                uri->user = STRNDUP(*str, cur - *str);\n+            else\n+                uri->user = xmlURIUnescapeString(*str, cur - *str, NULL);\n+        }\n+        *str = cur;\n+        return(0);\n@@ -408,1 +408,1 @@\n-    cur++;\n+        cur++;\n@@ -410,1 +410,1 @@\n-    cur += 2;\n+        cur += 2;\n@@ -412,1 +412,1 @@\n-    cur += 3;\n+        cur += 3;\n@@ -414,2 +414,2 @@\n-         (*(cur + 1) <= '4') && (ISA_DIGIT(cur + 2)))\n-    cur += 3;\n+             (*(cur + 1) <= '4') && (ISA_DIGIT(cur + 2)))\n+        cur += 3;\n@@ -417,2 +417,2 @@\n-         (*(cur + 2) >= '0') && (*(cur + 1) <= '5'))\n-    cur += 3;\n+             (*(cur + 2) >= '0') && (*(cur + 1) <= '5'))\n+        cur += 3;\n@@ -451,1 +451,4 @@\n-    while ((*cur != ']') && (*cur != 0))\n+        while ((*cur != ']') && (*cur != 0))\n+            cur++;\n+        if (*cur != ']')\n+            return(1);\n@@ -453,4 +456,1 @@\n-    if (*cur != ']')\n-        return(1);\n-    cur++;\n-    goto found;\n+        goto found;\n@@ -463,4 +463,4 @@\n-        goto not_ipv4;\n-    if (*cur != '.')\n-        goto not_ipv4;\n-    cur++;\n+            goto not_ipv4;\n+        if (*cur != '.')\n+            goto not_ipv4;\n+        cur++;\n@@ -468,3 +468,3 @@\n-        goto not_ipv4;\n-    if (*cur != '.')\n-        goto not_ipv4;\n+            goto not_ipv4;\n+        if (*cur != '.')\n+            goto not_ipv4;\n@@ -472,3 +472,3 @@\n-        goto not_ipv4;\n-    if (*cur != '.')\n-        goto not_ipv4;\n+            goto not_ipv4;\n+        if (*cur != '.')\n+            goto not_ipv4;\n@@ -476,2 +476,2 @@\n-        goto not_ipv4;\n-    goto found;\n+            goto not_ipv4;\n+        goto found;\n@@ -488,10 +488,10 @@\n-    if (uri->authority != NULL) xmlFree(uri->authority);\n-    uri->authority = NULL;\n-    if (uri->server != NULL) xmlFree(uri->server);\n-    if (cur != host) {\n-        if (uri->cleanup & 2)\n-        uri->server = STRNDUP(host, cur - host);\n-        else\n-        uri->server = xmlURIUnescapeString(host, cur - host, NULL);\n-    } else\n-        uri->server = NULL;\n+        if (uri->authority != NULL) xmlFree(uri->authority);\n+        uri->authority = NULL;\n+        if (uri->server != NULL) xmlFree(uri->server);\n+        if (cur != host) {\n+            if (uri->cleanup & 2)\n+                uri->server = STRNDUP(host, cur - host);\n+            else\n+                uri->server = xmlURIUnescapeString(host, cur - host, NULL);\n+        } else\n+            uri->server = NULL;\n@@ -535,1 +535,1 @@\n-    if (ret != 0) return(ret);\n+        if (ret != 0) return(ret);\n@@ -565,2 +565,2 @@\n-        return(0);\n-    return(1);\n+            return(0);\n+        return(1);\n@@ -596,2 +596,2 @@\n-    ret = xmlParse3986Segment(&cur, 0, 1);\n-    if (ret != 0) return(ret);\n+        ret = xmlParse3986Segment(&cur, 0, 1);\n+        if (ret != 0) return(ret);\n@@ -600,1 +600,1 @@\n-    if (uri->path != NULL) xmlFree(uri->path);\n+        if (uri->path != NULL) xmlFree(uri->path);\n@@ -639,5 +639,5 @@\n-    while (*cur == '\/') {\n-        cur++;\n-        ret = xmlParse3986Segment(&cur, 0, 1);\n-        if (ret != 0) return(ret);\n-    }\n+        while (*cur == '\/') {\n+            cur++;\n+            ret = xmlParse3986Segment(&cur, 0, 1);\n+            if (ret != 0) return(ret);\n+        }\n@@ -646,1 +646,1 @@\n-    if (uri->path != NULL) xmlFree(uri->path);\n+        if (uri->path != NULL) xmlFree(uri->path);\n@@ -684,2 +684,2 @@\n-    ret = xmlParse3986Segment(&cur, 0, 1);\n-    if (ret != 0) return(ret);\n+        ret = xmlParse3986Segment(&cur, 0, 1);\n+        if (ret != 0) return(ret);\n@@ -688,1 +688,1 @@\n-    if (uri->path != NULL) xmlFree(uri->path);\n+        if (uri->path != NULL) xmlFree(uri->path);\n@@ -726,2 +726,2 @@\n-    ret = xmlParse3986Segment(&cur, 0, 1);\n-    if (ret != 0) return(ret);\n+        ret = xmlParse3986Segment(&cur, 0, 1);\n+        if (ret != 0) return(ret);\n@@ -730,1 +730,1 @@\n-    if (uri->path != NULL) xmlFree(uri->path);\n+        if (uri->path != NULL) xmlFree(uri->path);\n@@ -769,8 +769,8 @@\n-    ret = xmlParse3986Authority(uri, &cur);\n-    if (ret != 0) return(ret);\n-    if (uri->server == NULL)\n-        uri->port = -1;\n-    ret = xmlParse3986PathAbEmpty(uri, &cur);\n-    if (ret != 0) return(ret);\n-    *str = cur;\n-    return(0);\n+        ret = xmlParse3986Authority(uri, &cur);\n+        if (ret != 0) return(ret);\n+        if (uri->server == NULL)\n+            uri->port = -1;\n+        ret = xmlParse3986PathAbEmpty(uri, &cur);\n+        if (ret != 0) return(ret);\n+        *str = cur;\n+        return(0);\n@@ -779,1 +779,1 @@\n-    if (ret != 0) return(ret);\n+        if (ret != 0) return(ret);\n@@ -782,1 +782,1 @@\n-    if (ret != 0) return(ret);\n+        if (ret != 0) return(ret);\n@@ -784,5 +784,5 @@\n-    \/* path-empty is effectively empty *\/\n-    if (uri != NULL) {\n-        if (uri->path != NULL) xmlFree(uri->path);\n-        uri->path = NULL;\n-    }\n+        \/* path-empty is effectively empty *\/\n+        if (uri != NULL) {\n+            if (uri->path != NULL) xmlFree(uri->path);\n+            uri->path = NULL;\n+        }\n@@ -816,4 +816,4 @@\n-    ret = xmlParse3986Authority(uri, &str);\n-    if (ret != 0) return(ret);\n-    ret = xmlParse3986PathAbEmpty(uri, &str);\n-    if (ret != 0) return(ret);\n+        ret = xmlParse3986Authority(uri, &str);\n+        if (ret != 0) return(ret);\n+        ret = xmlParse3986PathAbEmpty(uri, &str);\n+        if (ret != 0) return(ret);\n@@ -821,2 +821,2 @@\n-    ret = xmlParse3986PathAbsolute(uri, &str);\n-    if (ret != 0) return(ret);\n+        ret = xmlParse3986PathAbsolute(uri, &str);\n+        if (ret != 0) return(ret);\n@@ -825,1 +825,1 @@\n-    if (ret != 0) return(ret);\n+        if (ret != 0) return(ret);\n@@ -827,5 +827,5 @@\n-    \/* path-empty is effectively empty *\/\n-    if (uri != NULL) {\n-        if (uri->path != NULL) xmlFree(uri->path);\n-        uri->path = NULL;\n-    }\n+        \/* path-empty is effectively empty *\/\n+        if (uri != NULL) {\n+            if (uri->path != NULL) xmlFree(uri->path);\n+            uri->path = NULL;\n+        }\n@@ -835,3 +835,3 @@\n-    str++;\n-    ret = xmlParse3986Query(uri, &str);\n-    if (ret != 0) return(ret);\n+        str++;\n+        ret = xmlParse3986Query(uri, &str);\n+        if (ret != 0) return(ret);\n@@ -840,3 +840,3 @@\n-    str++;\n-    ret = xmlParse3986Fragment(uri, &str);\n-    if (ret != 0) return(ret);\n+        str++;\n+        ret = xmlParse3986Fragment(uri, &str);\n+        if (ret != 0) return(ret);\n@@ -845,2 +845,2 @@\n-    xmlCleanURI(uri);\n-    return(1);\n+        xmlCleanURI(uri);\n+        return(1);\n@@ -871,1 +871,1 @@\n-    return(1);\n+        return(1);\n@@ -877,3 +877,3 @@\n-    str++;\n-    ret = xmlParse3986Query(uri, &str);\n-    if (ret != 0) return(ret);\n+        str++;\n+        ret = xmlParse3986Query(uri, &str);\n+        if (ret != 0) return(ret);\n@@ -882,3 +882,3 @@\n-    str++;\n-    ret = xmlParse3986Fragment(uri, &str);\n-    if (ret != 0) return(ret);\n+        str++;\n+        ret = xmlParse3986Fragment(uri, &str);\n+        if (ret != 0) return(ret);\n@@ -887,2 +887,2 @@\n-    xmlCleanURI(uri);\n-    return(1);\n+        xmlCleanURI(uri);\n+        return(1);\n@@ -910,1 +910,1 @@\n-    return(-1);\n+        return(-1);\n@@ -918,3 +918,0 @@\n-    if (ret != 0) {\n-    xmlCleanURI(uri);\n-        ret = xmlParse3986RelativeRef(uri, str);\n@@ -923,2 +920,5 @@\n-        return(ret);\n-    }\n+        ret = xmlParse3986RelativeRef(uri, str);\n+        if (ret != 0) {\n+            xmlCleanURI(uri);\n+            return(ret);\n+        }\n@@ -945,1 +945,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -948,1 +948,1 @@\n-    ret = xmlParse3986URIReference(uri, str);\n+        ret = xmlParse3986URIReference(uri, str);\n@@ -950,3 +950,3 @@\n-        xmlFreeURI(uri);\n-        return(NULL);\n-    }\n+            xmlFreeURI(uri);\n+            return(NULL);\n+        }\n@@ -991,1 +991,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -995,3 +995,3 @@\n-        uri->cleanup |= 2;\n-    }\n-    ret = xmlParseURIReference(uri, str);\n+            uri->cleanup |= 2;\n+        }\n+        ret = xmlParseURIReference(uri, str);\n@@ -999,3 +999,3 @@\n-        xmlFreeURI(uri);\n-        return(NULL);\n-    }\n+            xmlFreeURI(uri);\n+            return(NULL);\n+        }\n@@ -1007,3 +1007,3 @@\n- *                                  *\n- *          Generic URI structure functions         *\n- *                                  *\n+ *                                                                      *\n+ *                      Generic URI structure functions                 *\n+ *                                                                      *\n@@ -1026,1 +1026,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1080,1 +1080,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1085,3 +1085,3 @@\n-    p = uri->scheme;\n-    while (*p != 0) {\n-        if (len >= max) {\n+        p = uri->scheme;\n+        while (*p != 0) {\n+            if (len >= max) {\n@@ -1090,1 +1090,3 @@\n-        ret = temp;\n+                ret = temp;\n+            }\n+            ret[len++] = *p++;\n@@ -1092,3 +1094,1 @@\n-        ret[len++] = *p++;\n-    }\n-    if (len >= max) {\n+        if (len >= max) {\n@@ -1098,2 +1098,2 @@\n-    }\n-    ret[len++] = ':';\n+        }\n+        ret[len++] = ':';\n@@ -1102,3 +1102,3 @@\n-    p = uri->opaque;\n-    while (*p != 0) {\n-        if (len + 3 >= max) {\n+        p = uri->opaque;\n+        while (*p != 0) {\n+            if (len + 3 >= max) {\n@@ -1108,0 +1108,10 @@\n+            }\n+            if (IS_RESERVED(*(p)) || IS_UNRESERVED(*(p)))\n+                ret[len++] = *p++;\n+            else {\n+                int val = *(unsigned char *)p++;\n+                int hi = val \/ 0x10, lo = val % 0x10;\n+                ret[len++] = '%';\n+                ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n+                ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n+            }\n@@ -1109,10 +1119,0 @@\n-        if (IS_RESERVED(*(p)) || IS_UNRESERVED(*(p)))\n-        ret[len++] = *p++;\n-        else {\n-        int val = *(unsigned char *)p++;\n-        int hi = val \/ 0x10, lo = val % 0x10;\n-        ret[len++] = '%';\n-        ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n-        ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n-        }\n-    }\n@@ -1120,2 +1120,2 @@\n-    if ((uri->server != NULL) || (uri->port == -1)) {\n-        if (len + 3 >= max) {\n+        if ((uri->server != NULL) || (uri->port == -1)) {\n+            if (len + 3 >= max) {\n@@ -1125,7 +1125,7 @@\n-        }\n-        ret[len++] = '\/';\n-        ret[len++] = '\/';\n-        if (uri->user != NULL) {\n-        p = uri->user;\n-        while (*p != 0) {\n-            if (len + 3 >= max) {\n+            }\n+            ret[len++] = '\/';\n+            ret[len++] = '\/';\n+            if (uri->user != NULL) {\n+                p = uri->user;\n+                while (*p != 0) {\n+                    if (len + 3 >= max) {\n@@ -1135,16 +1135,16 @@\n-            }\n-            if ((IS_UNRESERVED(*(p))) ||\n-            ((*(p) == ';')) || ((*(p) == ':')) ||\n-            ((*(p) == '&')) || ((*(p) == '=')) ||\n-            ((*(p) == '+')) || ((*(p) == '$')) ||\n-            ((*(p) == ',')))\n-            ret[len++] = *p++;\n-            else {\n-            int val = *(unsigned char *)p++;\n-            int hi = val \/ 0x10, lo = val % 0x10;\n-            ret[len++] = '%';\n-            ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n-            ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n-            }\n-        }\n-        if (len + 3 >= max) {\n+                    }\n+                    if ((IS_UNRESERVED(*(p))) ||\n+                        ((*(p) == ';')) || ((*(p) == ':')) ||\n+                        ((*(p) == '&')) || ((*(p) == '=')) ||\n+                        ((*(p) == '+')) || ((*(p) == '$')) ||\n+                        ((*(p) == ',')))\n+                        ret[len++] = *p++;\n+                    else {\n+                        int val = *(unsigned char *)p++;\n+                        int hi = val \/ 0x10, lo = val % 0x10;\n+                        ret[len++] = '%';\n+                        ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n+                        ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n+                    }\n+                }\n+                if (len + 3 >= max) {\n@@ -1154,10 +1154,2 @@\n-        }\n-        ret[len++] = '@';\n-        }\n-        if (uri->server != NULL) {\n-        p = uri->server;\n-        while (*p != 0) {\n-            if (len >= max) {\n-            temp = xmlSaveUriRealloc(ret, &max);\n-            if (temp == NULL) goto mem_error;\n-            ret = temp;\n+                }\n+                ret[len++] = '@';\n@@ -1165,7 +1157,18 @@\n-            ret[len++] = *p++;\n-        }\n-        if (uri->port > 0) {\n-            if (len + 10 >= max) {\n-            temp = xmlSaveUriRealloc(ret, &max);\n-            if (temp == NULL) goto mem_error;\n-            ret = temp;\n+            if (uri->server != NULL) {\n+                p = uri->server;\n+                while (*p != 0) {\n+                    if (len >= max) {\n+                        temp = xmlSaveUriRealloc(ret, &max);\n+                        if (temp == NULL) goto mem_error;\n+                        ret = temp;\n+                    }\n+                    ret[len++] = *p++;\n+                }\n+                if (uri->port > 0) {\n+                    if (len + 10 >= max) {\n+                        temp = xmlSaveUriRealloc(ret, &max);\n+                        if (temp == NULL) goto mem_error;\n+                        ret = temp;\n+                    }\n+                    len += snprintf((char *) &ret[len], max - len, \":%d\", uri->port);\n+                }\n@@ -1173,5 +1176,2 @@\n-            len += snprintf((char *) &ret[len], max - len, \":%d\", uri->port);\n-        }\n-        }\n-    } else if (uri->authority != NULL) {\n-        if (len + 3 >= max) {\n+        } else if (uri->authority != NULL) {\n+            if (len + 3 >= max) {\n@@ -1181,6 +1181,6 @@\n-        }\n-        ret[len++] = '\/';\n-        ret[len++] = '\/';\n-        p = uri->authority;\n-        while (*p != 0) {\n-        if (len + 3 >= max) {\n+            }\n+            ret[len++] = '\/';\n+            ret[len++] = '\/';\n+            p = uri->authority;\n+            while (*p != 0) {\n+                if (len + 3 >= max) {\n@@ -1190,2 +1190,2 @@\n-        }\n-        if ((IS_UNRESERVED(*(p))) ||\n+                }\n+                if ((IS_UNRESERVED(*(p))) ||\n@@ -1195,11 +1195,11 @@\n-            ret[len++] = *p++;\n-        else {\n-            int val = *(unsigned char *)p++;\n-            int hi = val \/ 0x10, lo = val % 0x10;\n-            ret[len++] = '%';\n-            ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n-            ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n-        }\n-        }\n-    } else if (uri->scheme != NULL) {\n-        if (len + 3 >= max) {\n+                    ret[len++] = *p++;\n+                else {\n+                    int val = *(unsigned char *)p++;\n+                    int hi = val \/ 0x10, lo = val % 0x10;\n+                    ret[len++] = '%';\n+                    ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n+                    ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n+                }\n+            }\n+        } else if (uri->scheme != NULL) {\n+            if (len + 3 >= max) {\n@@ -1209,0 +1209,1 @@\n+            }\n@@ -1210,14 +1211,13 @@\n-    }\n-    if (uri->path != NULL) {\n-        p = uri->path;\n-        \/*\n-         * the colon in file:\/\/\/d: should not be escaped or\n-         * Windows accesses fail later.\n-         *\/\n-        if ((uri->scheme != NULL) &&\n-        (p[0] == '\/') &&\n-        (((p[1] >= 'a') && (p[1] <= 'z')) ||\n-         ((p[1] >= 'A') && (p[1] <= 'Z'))) &&\n-        (p[2] == ':') &&\n-            (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST \"file\"))) {\n-        if (len + 3 >= max) {\n+        if (uri->path != NULL) {\n+            p = uri->path;\n+            \/*\n+             * the colon in file:\/\/\/d: should not be escaped or\n+             * Windows accesses fail later.\n+             *\/\n+            if ((uri->scheme != NULL) &&\n+                (p[0] == '\/') &&\n+                (((p[1] >= 'a') && (p[1] <= 'z')) ||\n+                 ((p[1] >= 'A') && (p[1] <= 'Z'))) &&\n+                (p[2] == ':') &&\n+                (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST \"file\"))) {\n+                if (len + 3 >= max) {\n@@ -1227,7 +1227,7 @@\n-        }\n-        ret[len++] = *p++;\n-        ret[len++] = *p++;\n-        ret[len++] = *p++;\n-        }\n-        while (*p != 0) {\n-        if (len + 3 >= max) {\n+                }\n+                ret[len++] = *p++;\n+                ret[len++] = *p++;\n+                ret[len++] = *p++;\n+            }\n+            while (*p != 0) {\n+                if (len + 3 >= max) {\n@@ -1237,2 +1237,2 @@\n-        }\n-        if ((IS_UNRESERVED(*(p))) || ((*(p) == '\/')) ||\n+                }\n+                if ((IS_UNRESERVED(*(p))) || ((*(p) == '\/')) ||\n@@ -1240,10 +1240,11 @@\n-                ((*(p) == '=')) || ((*(p) == '+')) || ((*(p) == '$')) ||\n-                ((*(p) == ',')))\n-            ret[len++] = *p++;\n-        else {\n-            int val = *(unsigned char *)p++;\n-            int hi = val \/ 0x10, lo = val % 0x10;\n-            ret[len++] = '%';\n-            ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n-            ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n-        }\n+                    ((*(p) == '=')) || ((*(p) == '+')) || ((*(p) == '$')) ||\n+                    ((*(p) == ',')))\n+                    ret[len++] = *p++;\n+                else {\n+                    int val = *(unsigned char *)p++;\n+                    int hi = val \/ 0x10, lo = val % 0x10;\n+                    ret[len++] = '%';\n+                    ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n+                    ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n+                }\n+            }\n@@ -1251,3 +1252,2 @@\n-    }\n-    if (uri->query_raw != NULL) {\n-        if (len + 1 >= max) {\n+        if (uri->query_raw != NULL) {\n+            if (len + 1 >= max) {\n@@ -1257,5 +1257,5 @@\n-        }\n-        ret[len++] = '?';\n-        p = uri->query_raw;\n-        while (*p != 0) {\n-        if (len + 1 >= max) {\n+            }\n+            ret[len++] = '?';\n+            p = uri->query_raw;\n+            while (*p != 0) {\n+                if (len + 1 >= max) {\n@@ -1265,5 +1265,5 @@\n-        }\n-        ret[len++] = *p++;\n-        }\n-    } else if (uri->query != NULL) {\n-        if (len + 3 >= max) {\n+                }\n+                ret[len++] = *p++;\n+            }\n+        } else if (uri->query != NULL) {\n+            if (len + 3 >= max) {\n@@ -1273,5 +1273,5 @@\n-        }\n-        ret[len++] = '?';\n-        p = uri->query;\n-        while (*p != 0) {\n-        if (len + 3 >= max) {\n+            }\n+            ret[len++] = '?';\n+            p = uri->query;\n+            while (*p != 0) {\n+                if (len + 3 >= max) {\n@@ -1281,10 +1281,11 @@\n-        }\n-        if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))\n-            ret[len++] = *p++;\n-        else {\n-            int val = *(unsigned char *)p++;\n-            int hi = val \/ 0x10, lo = val % 0x10;\n-            ret[len++] = '%';\n-            ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n-            ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n-        }\n+                }\n+                if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))\n+                    ret[len++] = *p++;\n+                else {\n+                    int val = *(unsigned char *)p++;\n+                    int hi = val \/ 0x10, lo = val % 0x10;\n+                    ret[len++] = '%';\n+                    ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n+                    ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n+                }\n+            }\n@@ -1293,1 +1294,0 @@\n-    }\n@@ -1295,1 +1295,1 @@\n-    if (len + 3 >= max) {\n+        if (len + 3 >= max) {\n@@ -1299,5 +1299,5 @@\n-    }\n-    ret[len++] = '#';\n-    p = uri->fragment;\n-    while (*p != 0) {\n-        if (len + 3 >= max) {\n+        }\n+        ret[len++] = '#';\n+        p = uri->fragment;\n+        while (*p != 0) {\n+            if (len + 3 >= max) {\n@@ -1307,9 +1307,10 @@\n-        }\n-        if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))\n-        ret[len++] = *p++;\n-        else {\n-        int val = *(unsigned char *)p++;\n-        int hi = val \/ 0x10, lo = val % 0x10;\n-        ret[len++] = '%';\n-        ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n-        ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n+            }\n+            if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))\n+                ret[len++] = *p++;\n+            else {\n+                int val = *(unsigned char *)p++;\n+                int hi = val \/ 0x10, lo = val % 0x10;\n+                ret[len++] = '%';\n+                ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n+                ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n+            }\n@@ -1318,1 +1319,0 @@\n-    }\n@@ -1345,2 +1345,2 @@\n-    fprintf(stream, \"%s\", (char *) out);\n-    xmlFree(out);\n+        fprintf(stream, \"%s\", (char *) out);\n+        xmlFree(out);\n@@ -1403,3 +1403,3 @@\n- *                                  *\n- *          Helper functions                *\n- *                                  *\n+ *                                                                      *\n+ *                      Helper functions                                *\n+ *                                                                      *\n@@ -1424,1 +1424,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1442,11 +1442,11 @@\n-    \/*\n-     * c) All occurrences of \".\/\", where \".\" is a complete path segment,\n-     *    are removed from the buffer string.\n-     *\/\n-    if ((cur[0] == '.') && (cur[1] == '\/')) {\n-        cur += 2;\n-        \/* '\/\/' normalization should be done at this point too *\/\n-        while (cur[0] == '\/')\n-        cur++;\n-        continue;\n-    }\n+        \/*\n+         * c) All occurrences of \".\/\", where \".\" is a complete path segment,\n+         *    are removed from the buffer string.\n+         *\/\n+        if ((cur[0] == '.') && (cur[1] == '\/')) {\n+            cur += 2;\n+            \/* '\/\/' normalization should be done at this point too *\/\n+            while (cur[0] == '\/')\n+                cur++;\n+            continue;\n+        }\n@@ -1454,6 +1454,6 @@\n-    \/*\n-     * d) If the buffer string ends with \".\" as a complete path segment,\n-     *    that \".\" is removed.\n-     *\/\n-    if ((cur[0] == '.') && (cur[1] == '\\0'))\n-        break;\n+        \/*\n+         * d) If the buffer string ends with \".\" as a complete path segment,\n+         *    that \".\" is removed.\n+         *\/\n+        if ((cur[0] == '.') && (cur[1] == '\\0'))\n+            break;\n@@ -1461,2 +1461,2 @@\n-    \/* Otherwise keep the segment.  *\/\n-    while (cur[0] != '\/') {\n+        \/* Otherwise keep the segment.  *\/\n+        while (cur[0] != '\/') {\n@@ -1465,5 +1465,5 @@\n-        (out++)[0] = (cur++)[0];\n-    }\n-    \/* normalize \/\/ *\/\n-    while ((cur[0] == '\/') && (cur[1] == '\/'))\n-        cur++;\n+            (out++)[0] = (cur++)[0];\n+        }\n+        \/* normalize \/\/ *\/\n+        while ((cur[0] == '\/') && (cur[1] == '\/'))\n+            cur++;\n@@ -1481,1 +1481,1 @@\n-    return(0);\n+        return(0);\n@@ -1584,1 +1584,1 @@\n-    cur += 3;\n+        cur += 3;\n@@ -1587,2 +1587,2 @@\n-    out = path;\n-    while (cur[0] != '\\0')\n+        out = path;\n+        while (cur[0] != '\\0')\n@@ -1590,1 +1590,1 @@\n-    out[0] = 0;\n+        out[0] = 0;\n@@ -1601,1 +1601,1 @@\n-    return(1);\n+        return(1);\n@@ -1625,1 +1625,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1630,2 +1630,2 @@\n-    ret = (char *) xmlMallocAtomic(len + 1);\n-    if (ret == NULL) {\n+        ret = (char *) xmlMallocAtomic(len + 1);\n+        if (ret == NULL) {\n@@ -1633,2 +1633,2 @@\n-        return(NULL);\n-    }\n+            return(NULL);\n+        }\n@@ -1636,1 +1636,1 @@\n-    ret = target;\n+        ret = target;\n@@ -1640,22 +1640,23 @@\n-    if ((len > 2) && (*in == '%') && (is_hex(in[1])) && (is_hex(in[2]))) {\n-        in++;\n-        if ((*in >= '0') && (*in <= '9'))\n-            *out = (*in - '0');\n-        else if ((*in >= 'a') && (*in <= 'f'))\n-            *out = (*in - 'a') + 10;\n-        else if ((*in >= 'A') && (*in <= 'F'))\n-            *out = (*in - 'A') + 10;\n-        in++;\n-        if ((*in >= '0') && (*in <= '9'))\n-            *out = *out * 16 + (*in - '0');\n-        else if ((*in >= 'a') && (*in <= 'f'))\n-            *out = *out * 16 + (*in - 'a') + 10;\n-        else if ((*in >= 'A') && (*in <= 'F'))\n-            *out = *out * 16 + (*in - 'A') + 10;\n-        in++;\n-        len -= 3;\n-        out++;\n-    } else {\n-        *out++ = *in++;\n-        len--;\n-    }\n+        if ((len > 2) && (*in == '%') && (is_hex(in[1])) && (is_hex(in[2]))) {\n+            int c = 0;\n+            in++;\n+            if ((*in >= '0') && (*in <= '9'))\n+                c = (*in - '0');\n+            else if ((*in >= 'a') && (*in <= 'f'))\n+                c = (*in - 'a') + 10;\n+            else if ((*in >= 'A') && (*in <= 'F'))\n+                c = (*in - 'A') + 10;\n+            in++;\n+            if ((*in >= '0') && (*in <= '9'))\n+                c = c * 16 + (*in - '0');\n+            else if ((*in >= 'a') && (*in <= 'f'))\n+                c = c * 16 + (*in - 'a') + 10;\n+            else if ((*in >= 'A') && (*in <= 'F'))\n+                c = c * 16 + (*in - 'A') + 10;\n+            in++;\n+            len -= 3;\n+            *out++ = (char) c;\n+        } else {\n+            *out++ = *in++;\n+            len--;\n+        }\n@@ -1685,1 +1686,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1687,1 +1688,1 @@\n-    return(xmlStrdup(str));\n+        return(xmlStrdup(str));\n@@ -1695,1 +1696,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1700,1 +1701,1 @@\n-    if (len - out <= 3) {\n+        if (len - out <= 3) {\n@@ -1702,1 +1703,1 @@\n-        if (temp == NULL) {\n+            if (temp == NULL) {\n@@ -1704,2 +1705,4 @@\n-        xmlFree(ret);\n-        return(NULL);\n+                xmlFree(ret);\n+                return(NULL);\n+            }\n+            ret = temp;\n@@ -1707,2 +1710,0 @@\n-        ret = temp;\n-    }\n@@ -1710,1 +1711,1 @@\n-    ch = *in;\n+        ch = *in;\n@@ -1712,17 +1713,17 @@\n-    if ((ch != '@') && (!IS_UNRESERVED(ch)) && (!xmlStrchr(list, ch))) {\n-        unsigned char val;\n-        ret[out++] = '%';\n-        val = ch >> 4;\n-        if (val <= 9)\n-        ret[out++] = '0' + val;\n-        else\n-        ret[out++] = 'A' + val - 0xA;\n-        val = ch & 0xF;\n-        if (val <= 9)\n-        ret[out++] = '0' + val;\n-        else\n-        ret[out++] = 'A' + val - 0xA;\n-        in++;\n-    } else {\n-        ret[out++] = *in++;\n-    }\n+        if ((ch != '@') && (!IS_UNRESERVED(ch)) && (!xmlStrchr(list, ch))) {\n+            unsigned char val;\n+            ret[out++] = '%';\n+            val = ch >> 4;\n+            if (val <= 9)\n+                ret[out++] = '0' + val;\n+            else\n+                ret[out++] = 'A' + val - 0xA;\n+            val = ch & 0xF;\n+            if (val <= 9)\n+                ret[out++] = '0' + val;\n+            else\n+                ret[out++] = 'A' + val - 0xA;\n+            in++;\n+        } else {\n+            ret[out++] = *in++;\n+        }\n@@ -1762,3 +1763,3 @@\n-    \/*\n-     * Allow escaping errors in the unescaped form\n-     *\/\n+        \/*\n+         * Allow escaping errors in the unescaped form\n+         *\/\n@@ -1870,3 +1871,3 @@\n- *                                  *\n- *          Public functions                *\n- *                                  *\n+ *                                                                      *\n+ *                      Public functions                                *\n+ *                                                                      *\n@@ -1907,1 +1908,1 @@\n-    ret = -1;\n+        ret = -1;\n@@ -1909,8 +1910,8 @@\n-    if (*URI) {\n-        ref = xmlCreateURI();\n-        if (ref == NULL)\n-        goto done;\n-        ret = xmlParseURIReference(ref, (const char *) URI);\n-    }\n-    else\n-        ret = 0;\n+        if (*URI) {\n+            ref = xmlCreateURI();\n+            if (ref == NULL)\n+                goto done;\n+            ret = xmlParseURIReference(ref, (const char *) URI);\n+        }\n+        else\n+            ret = 0;\n@@ -1919,1 +1920,1 @@\n-    goto done;\n+        goto done;\n@@ -1921,5 +1922,5 @@\n-    \/*\n-     * The URI is absolute don't modify.\n-     *\/\n-    val = xmlStrdup(URI);\n-    goto done;\n+        \/*\n+         * The URI is absolute don't modify.\n+         *\/\n+        val = xmlStrdup(URI);\n+        goto done;\n@@ -1928,1 +1929,1 @@\n-    ret = -1;\n+        ret = -1;\n@@ -1930,4 +1931,4 @@\n-    bas = xmlCreateURI();\n-    if (bas == NULL)\n-        goto done;\n-    ret = xmlParseURIReference(bas, (const char *) base);\n+        bas = xmlCreateURI();\n+        if (bas == NULL)\n+            goto done;\n+        ret = xmlParseURIReference(bas, (const char *) base);\n@@ -1936,3 +1937,3 @@\n-    if (ref)\n-        val = xmlSaveUri(ref);\n-    goto done;\n+        if (ref)\n+            val = xmlSaveUri(ref);\n+        goto done;\n@@ -1941,9 +1942,9 @@\n-    \/*\n-     * the base fragment must be ignored\n-     *\/\n-    if (bas->fragment != NULL) {\n-        xmlFree(bas->fragment);\n-        bas->fragment = NULL;\n-    }\n-    val = xmlSaveUri(bas);\n-    goto done;\n+        \/*\n+         * the base fragment must be ignored\n+         *\/\n+        if (bas->fragment != NULL) {\n+            xmlFree(bas->fragment);\n+            bas->fragment = NULL;\n+        }\n+        val = xmlSaveUri(bas);\n+        goto done;\n@@ -1966,1 +1967,1 @@\n-    goto done;\n+        goto done;\n@@ -1968,25 +1969,25 @@\n-    ((ref->authority == NULL) && (ref->server == NULL))) {\n-    if (bas->scheme != NULL)\n-        res->scheme = xmlMemStrdup(bas->scheme);\n-    if (bas->authority != NULL)\n-        res->authority = xmlMemStrdup(bas->authority);\n-    else if ((bas->server != NULL) || (bas->port == -1)) {\n-        if (bas->server != NULL)\n-        res->server = xmlMemStrdup(bas->server);\n-        if (bas->user != NULL)\n-        res->user = xmlMemStrdup(bas->user);\n-        res->port = bas->port;\n-    }\n-    if (bas->path != NULL)\n-        res->path = xmlMemStrdup(bas->path);\n-    if (ref->query_raw != NULL)\n-        res->query_raw = xmlMemStrdup (ref->query_raw);\n-    else if (ref->query != NULL)\n-        res->query = xmlMemStrdup(ref->query);\n-    else if (bas->query_raw != NULL)\n-        res->query_raw = xmlMemStrdup(bas->query_raw);\n-    else if (bas->query != NULL)\n-        res->query = xmlMemStrdup(bas->query);\n-    if (ref->fragment != NULL)\n-        res->fragment = xmlMemStrdup(ref->fragment);\n-    goto step_7;\n+        ((ref->authority == NULL) && (ref->server == NULL))) {\n+        if (bas->scheme != NULL)\n+            res->scheme = xmlMemStrdup(bas->scheme);\n+        if (bas->authority != NULL)\n+            res->authority = xmlMemStrdup(bas->authority);\n+        else if ((bas->server != NULL) || (bas->port == -1)) {\n+            if (bas->server != NULL)\n+                res->server = xmlMemStrdup(bas->server);\n+            if (bas->user != NULL)\n+                res->user = xmlMemStrdup(bas->user);\n+            res->port = bas->port;\n+        }\n+        if (bas->path != NULL)\n+            res->path = xmlMemStrdup(bas->path);\n+        if (ref->query_raw != NULL)\n+            res->query_raw = xmlMemStrdup (ref->query_raw);\n+        else if (ref->query != NULL)\n+            res->query = xmlMemStrdup(ref->query);\n+        else if (bas->query_raw != NULL)\n+            res->query_raw = xmlMemStrdup(bas->query_raw);\n+        else if (bas->query != NULL)\n+            res->query = xmlMemStrdup(bas->query);\n+        if (ref->fragment != NULL)\n+            res->fragment = xmlMemStrdup(ref->fragment);\n+        goto step_7;\n@@ -2002,2 +2003,2 @@\n-    val = xmlSaveUri(ref);\n-    goto done;\n+        val = xmlSaveUri(ref);\n+        goto done;\n@@ -2006,1 +2007,1 @@\n-    res->scheme = xmlMemStrdup(bas->scheme);\n+        res->scheme = xmlMemStrdup(bas->scheme);\n@@ -2009,1 +2010,1 @@\n-    res->query_raw = xmlMemStrdup(ref->query_raw);\n+        res->query_raw = xmlMemStrdup(ref->query_raw);\n@@ -2011,1 +2012,1 @@\n-    res->query = xmlMemStrdup(ref->query);\n+        res->query = xmlMemStrdup(ref->query);\n@@ -2013,1 +2014,1 @@\n-    res->fragment = xmlMemStrdup(ref->fragment);\n+        res->fragment = xmlMemStrdup(ref->fragment);\n@@ -2023,6 +2024,6 @@\n-    if (ref->authority != NULL)\n-        res->authority = xmlMemStrdup(ref->authority);\n-    else {\n-        res->server = xmlMemStrdup(ref->server);\n-        if (ref->user != NULL)\n-        res->user = xmlMemStrdup(ref->user);\n+        if (ref->authority != NULL)\n+            res->authority = xmlMemStrdup(ref->authority);\n+        else {\n+            res->server = xmlMemStrdup(ref->server);\n+            if (ref->user != NULL)\n+                res->user = xmlMemStrdup(ref->user);\n@@ -2030,4 +2031,4 @@\n-    }\n-    if (ref->path != NULL)\n-        res->path = xmlMemStrdup(ref->path);\n-    goto step_7;\n+        }\n+        if (ref->path != NULL)\n+            res->path = xmlMemStrdup(ref->path);\n+        goto step_7;\n@@ -2036,1 +2037,1 @@\n-    res->authority = xmlMemStrdup(bas->authority);\n+        res->authority = xmlMemStrdup(bas->authority);\n@@ -2038,5 +2039,5 @@\n-    if (bas->server != NULL)\n-        res->server = xmlMemStrdup(bas->server);\n-    if (bas->user != NULL)\n-        res->user = xmlMemStrdup(bas->user);\n-    res->port = bas->port;\n+        if (bas->server != NULL)\n+            res->server = xmlMemStrdup(bas->server);\n+        if (bas->user != NULL)\n+            res->user = xmlMemStrdup(bas->user);\n+        res->port = bas->port;\n@@ -2050,2 +2051,2 @@\n-    res->path = xmlMemStrdup(ref->path);\n-    goto step_7;\n+        res->path = xmlMemStrdup(ref->path);\n+        goto step_7;\n@@ -2065,1 +2066,1 @@\n-    len += strlen(ref->path);\n+        len += strlen(ref->path);\n@@ -2067,1 +2068,1 @@\n-    len += strlen(bas->path);\n+        len += strlen(bas->path);\n@@ -2071,1 +2072,1 @@\n-    goto done;\n+        goto done;\n@@ -2083,10 +2084,11 @@\n-    while (bas->path[cur] != 0) {\n-        while ((bas->path[cur] != 0) && (bas->path[cur] != '\/'))\n-        cur++;\n-        if (bas->path[cur] == 0)\n-        break;\n-\n-        cur++;\n-        while (out < cur) {\n-        res->path[out] = bas->path[out];\n-        out++;\n+        while (bas->path[cur] != 0) {\n+            while ((bas->path[cur] != 0) && (bas->path[cur] != '\/'))\n+                cur++;\n+            if (bas->path[cur] == 0)\n+                break;\n+\n+            cur++;\n+            while (out < cur) {\n+                res->path[out] = bas->path[out];\n+                out++;\n+            }\n@@ -2095,1 +2097,0 @@\n-    }\n@@ -2103,9 +2104,9 @@\n-    indx = 0;\n-    \/*\n-     * Ensure the path includes a '\/'\n-     *\/\n-    if ((out == 0) && (bas->server != NULL))\n-        res->path[out++] = '\/';\n-    while (ref->path[indx] != 0) {\n-        res->path[out++] = ref->path[indx++];\n-    }\n+        indx = 0;\n+        \/*\n+         * Ensure the path includes a '\/'\n+         *\/\n+        if ((out == 0) && (bas->server != NULL))\n+            res->path[out++] = '\/';\n+        while (ref->path[indx] != 0) {\n+            res->path[out++] = ref->path[indx++];\n+        }\n@@ -2131,1 +2132,1 @@\n-    xmlFreeURI(ref);\n+        xmlFreeURI(ref);\n@@ -2133,1 +2134,1 @@\n-    xmlFreeURI(bas);\n+        xmlFreeURI(bas);\n@@ -2135,1 +2136,1 @@\n-    xmlFreeURI(res);\n+        xmlFreeURI(res);\n@@ -2185,1 +2186,1 @@\n-    return NULL;\n+        return NULL;\n@@ -2192,1 +2193,1 @@\n-    return NULL;\n+        return NULL;\n@@ -2195,3 +2196,3 @@\n-    ret = xmlParseURIReference (ref, (const char *) URI);\n-    if (ret != 0)\n-        goto done;      \/* Error in URI, return NULL *\/\n+        ret = xmlParseURIReference (ref, (const char *) URI);\n+        if (ret != 0)\n+            goto done;          \/* Error in URI, return NULL *\/\n@@ -2199,1 +2200,1 @@\n-    ref->path = (char *)xmlStrdup(URI);\n+        ref->path = (char *)xmlStrdup(URI);\n@@ -2205,2 +2206,2 @@\n-    val = xmlStrdup (URI);\n-    goto done;\n+        val = xmlStrdup (URI);\n+        goto done;\n@@ -2210,1 +2211,1 @@\n-    goto done;\n+        goto done;\n@@ -2212,3 +2213,3 @@\n-    ret = xmlParseURIReference (bas, (const char *) base);\n-    if (ret != 0)\n-        goto done;      \/* Error in base, return NULL *\/\n+        ret = xmlParseURIReference (bas, (const char *) base);\n+        if (ret != 0)\n+            goto done;          \/* Error in base, return NULL *\/\n@@ -2216,1 +2217,1 @@\n-    bas->path = (char *)xmlStrdup(base);\n+        bas->path = (char *)xmlStrdup(base);\n@@ -2223,5 +2224,5 @@\n-    ((bas->scheme == NULL) ||\n-     (xmlStrcmp ((xmlChar *)bas->scheme, (xmlChar *)ref->scheme)) ||\n-     (xmlStrcmp ((xmlChar *)bas->server, (xmlChar *)ref->server)))) {\n-    val = xmlStrdup (URI);\n-    goto done;\n+        ((bas->scheme == NULL) ||\n+         (xmlStrcmp ((xmlChar *)bas->scheme, (xmlChar *)ref->scheme)) ||\n+         (xmlStrcmp ((xmlChar *)bas->server, (xmlChar *)ref->server)))) {\n+        val = xmlStrdup (URI);\n+        goto done;\n@@ -2230,2 +2231,2 @@\n-    val = xmlStrdup(BAD_CAST \"\");\n-    goto done;\n+        val = xmlStrdup(BAD_CAST \"\");\n+        goto done;\n@@ -2234,2 +2235,2 @@\n-    val = xmlStrdup((xmlChar *)ref->path);\n-    goto done;\n+        val = xmlStrdup((xmlChar *)ref->path);\n+        goto done;\n@@ -2239,1 +2240,1 @@\n-    remove_path = 1;\n+        remove_path = 1;\n@@ -2256,1 +2257,1 @@\n-    if ((*rptr == '.') && (rptr[1] == '\/'))\n+        if ((*rptr == '.') && (rptr[1] == '\/'))\n@@ -2258,1 +2259,1 @@\n-    if ((*bptr == '.') && (bptr[1] == '\/'))\n+        if ((*bptr == '.') && (bptr[1] == '\/'))\n@@ -2260,9 +2261,9 @@\n-    else if ((*bptr == '\/') && (*rptr != '\/'))\n-        bptr++;\n-    while ((bptr[pos] == rptr[pos]) && (bptr[pos] != 0))\n-        pos++;\n-\n-    if (bptr[pos] == rptr[pos]) {\n-        val = xmlStrdup(BAD_CAST \"\");\n-        goto done;      \/* (I can't imagine why anyone would do this) *\/\n-    }\n+        else if ((*bptr == '\/') && (*rptr != '\/'))\n+            bptr++;\n+        while ((bptr[pos] == rptr[pos]) && (bptr[pos] != 0))\n+            pos++;\n+\n+        if (bptr[pos] == rptr[pos]) {\n+            val = xmlStrdup(BAD_CAST \"\");\n+            goto done;          \/* (I can't imagine why anyone would do this) *\/\n+        }\n@@ -2270,10 +2271,10 @@\n-    \/*\n-     * In URI, \"back up\" to the last '\/' encountered.  This will be the\n-     * beginning of the \"unique\" suffix of URI\n-     *\/\n-    ix = pos;\n-    for (; ix > 0; ix--) {\n-        if (rptr[ix - 1] == '\/')\n-        break;\n-    }\n-    uptr = (xmlChar *)&rptr[ix];\n+        \/*\n+         * In URI, \"back up\" to the last '\/' encountered.  This will be the\n+         * beginning of the \"unique\" suffix of URI\n+         *\/\n+        ix = pos;\n+        for (; ix > 0; ix--) {\n+            if (rptr[ix - 1] == '\/')\n+                break;\n+        }\n+        uptr = (xmlChar *)&rptr[ix];\n@@ -2281,7 +2282,7 @@\n-    \/*\n-     * In base, count the number of '\/' from the differing point\n-     *\/\n-    for (; bptr[ix] != 0; ix++) {\n-        if (bptr[ix] == '\/')\n-        nbslash++;\n-    }\n+        \/*\n+         * In base, count the number of '\/' from the differing point\n+         *\/\n+        for (; bptr[ix] != 0; ix++) {\n+            if (bptr[ix] == '\/')\n+                nbslash++;\n+        }\n@@ -2289,7 +2290,7 @@\n-    \/*\n-     * e.g: URI=\"foo\/\" base=\"foo\/bar\" -> \".\/\"\n-     *\/\n-    if (nbslash == 0 && !uptr[0]) {\n-        val = xmlStrdup(BAD_CAST \".\/\");\n-        goto done;\n-    }\n+        \/*\n+         * e.g: URI=\"foo\/\" base=\"foo\/bar\" -> \".\/\"\n+         *\/\n+        if (nbslash == 0 && !uptr[0]) {\n+            val = xmlStrdup(BAD_CAST \".\/\");\n+            goto done;\n+        }\n@@ -2297,1 +2298,1 @@\n-    len = xmlStrlen (uptr) + 1;\n+        len = xmlStrlen (uptr) + 1;\n@@ -2301,4 +2302,4 @@\n-    if (uptr != NULL)\n-        \/* exception characters from xmlSaveUri *\/\n-        val = xmlURIEscapeStr(uptr, BAD_CAST \"\/;&=+$,\");\n-    goto done;\n+        if (uptr != NULL)\n+            \/* exception characters from xmlSaveUri *\/\n+            val = xmlURIEscapeStr(uptr, BAD_CAST \"\/;&=+$,\");\n+        goto done;\n@@ -2315,1 +2316,1 @@\n-    goto done;\n+        goto done;\n@@ -2322,3 +2323,3 @@\n-    *vptr++ = '.';\n-    *vptr++ = '.';\n-    *vptr++ = '\/';\n+        *vptr++ = '.';\n+        *vptr++ = '.';\n+        *vptr++ = '\/';\n@@ -2331,3 +2332,7 @@\n-        (uptr[0] == '\/') && (vptr[-1] == '\/')) {\n-        memcpy (vptr, uptr + 1, len - 1);\n-        vptr[len - 2] = 0;\n+            (uptr[0] == '\/') && (vptr[-1] == '\/')) {\n+            memcpy (vptr, uptr + 1, len - 1);\n+            vptr[len - 2] = 0;\n+        } else {\n+            memcpy (vptr, uptr, len);\n+            vptr[len - 1] = 0;\n+        }\n@@ -2335,1 +2340,0 @@\n-        memcpy (vptr, uptr, len);\n@@ -2338,3 +2342,0 @@\n-    } else {\n-    vptr[len - 1] = 0;\n-    }\n@@ -2344,1 +2345,1 @@\n-    \/* exception characters from xmlSaveUri *\/\n+        \/* exception characters from xmlSaveUri *\/\n@@ -2355,1 +2356,1 @@\n-    xmlFreeURI (ref);\n+        xmlFreeURI (ref);\n@@ -2357,1 +2358,1 @@\n-    xmlFreeURI (bas);\n+        xmlFreeURI (bas);\n@@ -2373,5 +2374,5 @@\n-#define IS_WINDOWS_PATH(p)                  \\\n-    ((p != NULL) &&                     \\\n-     (((p[0] >= 'a') && (p[0] <= 'z')) ||           \\\n-      ((p[0] >= 'A') && (p[0] <= 'Z'))) &&          \\\n-     (p[1] == ':') && ((p[2] == '\/') || (p[2] == '\\\\')))\n+#define IS_WINDOWS_PATH(p)                                      \\\n+        ((p != NULL) &&                                         \\\n+         (((p[0] >= 'a') && (p[0] <= 'z')) ||                   \\\n+          ((p[0] >= 'A') && (p[0] <= 'Z'))) &&                  \\\n+         (p[1] == ':') && ((p[2] == '\/') || (p[2] == '\\\\')))\n@@ -2394,1 +2395,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2406,1 +2407,1 @@\n-    return xmlStrdup((const xmlChar *) path);\n+        return xmlStrdup((const xmlChar *) path);\n@@ -2409,1 +2410,1 @@\n-    \/* sanitize filename starting with \/\/ so it can be used as URI *\/\n+        \/* sanitize filename starting with \/\/ so it can be used as URI *\/\n@@ -2414,2 +2415,2 @@\n-    xmlFreeURI(uri);\n-    return xmlStrdup(path);\n+        xmlFreeURI(uri);\n+        return xmlStrdup(path);\n@@ -2422,2 +2423,2 @@\n-    unsigned char c;\n-    xmlChar *escURI;\n+        unsigned char c;\n+        xmlChar *escURI;\n@@ -2426,12 +2427,7 @@\n-     * this looks like an URI where some parts have not been\n-     * escaped leading to a parsing problem.  Check that the first\n-     * part matches a protocol.\n-     *\/\n-    l = absuri - path;\n-    \/* Bypass if first part (part before the ':\/\/') is > 20 chars *\/\n-    if ((l <= 0) || (l > 20))\n-        goto path_processing;\n-    \/* Bypass if any non-alpha characters are present in first part *\/\n-    for (j = 0;j < l;j++) {\n-        c = path[j];\n-        if (!(((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'))))\n+         * this looks like an URI where some parts have not been\n+         * escaped leading to a parsing problem.  Check that the first\n+         * part matches a protocol.\n+         *\/\n+        l = absuri - path;\n+        \/* Bypass if first part (part before the ':\/\/') is > 20 chars *\/\n+        if ((l <= 0) || (l > 20))\n@@ -2439,1 +2435,6 @@\n-    }\n+        \/* Bypass if any non-alpha characters are present in first part *\/\n+        for (j = 0;j < l;j++) {\n+            c = path[j];\n+            if (!(((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z'))))\n+                goto path_processing;\n+        }\n@@ -2441,1 +2442,1 @@\n-    \/* Escape all except the characters specified in the supplied path *\/\n+        \/* Escape all except the characters specified in the supplied path *\/\n@@ -2443,8 +2444,8 @@\n-    if (escURI != NULL) {\n-        \/* Try parsing the escaped path *\/\n-        uri = xmlParseURI((const char *) escURI);\n-        \/* If successful, return the escaped string *\/\n-        if (uri != NULL) {\n-            xmlFreeURI(uri);\n-        return escURI;\n-        }\n+        if (escURI != NULL) {\n+            \/* Try parsing the escaped path *\/\n+            uri = xmlParseURI((const char *) escURI);\n+            \/* If successful, return the escaped string *\/\n+            if (uri != NULL) {\n+                xmlFreeURI(uri);\n+                return escURI;\n+            }\n@@ -2452,1 +2453,1 @@\n-    }\n+        }\n@@ -2462,1 +2463,1 @@\n-    if (uri == NULL) {      \/* Guard against 'out of memory' *\/\n+    if (uri == NULL) {          \/* Guard against 'out of memory' *\/\n@@ -2469,11 +2470,11 @@\n-    uri->scheme = (char *) xmlStrdup(BAD_CAST \"file\");\n-    \/* allocate space for leading '\/' + path + string terminator *\/\n-    uri->path = xmlMallocAtomic(len + 2);\n-    if (uri->path == NULL) {\n-        xmlFreeURI(uri);    \/* Guard against 'out of memory' *\/\n-        return(NULL);\n-    }\n-    \/* Put in leading '\/' plus path *\/\n-    uri->path[0] = '\/';\n-    p = uri->path + 1;\n-    strncpy(p, (char *) path, len + 1);\n+        uri->scheme = (char *) xmlStrdup(BAD_CAST \"file\");\n+        \/* allocate space for leading '\/' + path + string terminator *\/\n+        uri->path = xmlMallocAtomic(len + 2);\n+        if (uri->path == NULL) {\n+            xmlFreeURI(uri);    \/* Guard against 'out of memory' *\/\n+            return(NULL);\n+        }\n+        \/* Put in leading '\/' plus path *\/\n+        uri->path[0] = '\/';\n+        p = uri->path + 1;\n+        strncpy(p, (char *) path, len + 1);\n@@ -2481,6 +2482,6 @@\n-    uri->path = (char *) xmlStrdup(path);\n-    if (uri->path == NULL) {\n-        xmlFreeURI(uri);\n-        return(NULL);\n-    }\n-    p = uri->path;\n+        uri->path = (char *) xmlStrdup(path);\n+        if (uri->path == NULL) {\n+            xmlFreeURI(uri);\n+            return(NULL);\n+        }\n+        p = uri->path;\n@@ -2490,3 +2491,3 @@\n-    if (*p == '\\\\')\n-        *p = '\/';\n-    p++;\n+        if (*p == '\\\\')\n+            *p = '\/';\n+        p++;\n@@ -2496,1 +2497,1 @@\n-    ret = xmlStrdup((const xmlChar *) uri->path);\n+        ret = xmlStrdup((const xmlChar *) uri->path);\n@@ -2498,1 +2499,1 @@\n-    ret = xmlSaveUri(uri);\n+        ret = xmlSaveUri(uri);\n@@ -2530,2 +2531,2 @@\n-    xmlFreeURI(uri);\n-    return xmlStrdup(path);\n+        xmlFreeURI(uri);\n+        return xmlStrdup(path);\n@@ -2541,2 +2542,2 @@\n-    xmlFreeURI(uri);\n-    return cal;\n+        xmlFreeURI(uri);\n+        return cal;\n@@ -2549,3 +2550,3 @@\n-    if (*ret == '\\\\')\n-        *ret = '\/';\n-    ret++;\n+        if (*ret == '\\\\')\n+            *ret = '\/';\n+        ret++;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/uri.c","additions":684,"deletions":683,"binary":false,"changes":1367,"status":"modified"},{"patch":"@@ -2610,0 +2610,47 @@\n+\/**\n+ * xmlValidNormalizeString:\n+ * @str: a string\n+ *\n+ * Normalize a string in-place.\n+ *\/\n+static void\n+xmlValidNormalizeString(xmlChar *str) {\n+    xmlChar *dst;\n+    const xmlChar *src;\n+\n+    if (str == NULL)\n+        return;\n+    src = str;\n+    dst = str;\n+\n+    while (*src == 0x20) src++;\n+    while (*src != 0) {\n+    if (*src == 0x20) {\n+        while (*src == 0x20) src++;\n+        if (*src != 0)\n+        *dst++ = 0x20;\n+    } else {\n+        *dst++ = *src++;\n+    }\n+    }\n+    *dst = 0;\n+}\n+\n+static int\n+xmlIsStreaming(xmlValidCtxtPtr ctxt) {\n+    xmlParserCtxtPtr pctxt;\n+\n+    if (ctxt == NULL)\n+        return(0);\n+    \/*\n+     * These magic values are also abused to detect whether we're validating\n+     * while parsing a document. In this case, userData points to the parser\n+     * context.\n+     *\/\n+    if ((ctxt->finishDtd != XML_CTXT_FINISH_DTD_0) &&\n+        (ctxt->finishDtd != XML_CTXT_FINISH_DTD_1))\n+        return(0);\n+    pctxt = ctxt->userData;\n+    return(pctxt->parseMode == XML_PARSE_READER);\n+}\n+\n@@ -2653,1 +2700,1 @@\n-    if (value == NULL) {\n+    if ((value == NULL) || (value[0] == 0)) {\n@@ -2684,1 +2731,1 @@\n-    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n+    if (xmlIsStreaming(ctxt)) {\n@@ -2823,0 +2870,1 @@\n+    xmlValidNormalizeString(ID);\n@@ -3012,1 +3060,1 @@\n-    if ((ctxt != NULL) && (ctxt->vstateNr != 0)) {\n+    if (xmlIsStreaming(ctxt)) {\n@@ -4031,2 +4079,1 @@\n-    xmlChar *ret, *dst;\n-    const xmlChar *src;\n+    xmlChar *ret;\n@@ -4073,13 +4120,1 @@\n-    src = value;\n-    dst = ret;\n-    while (*src == 0x20) src++;\n-    while (*src != 0) {\n-    if (*src == 0x20) {\n-        while (*src == 0x20) src++;\n-        if (*src != 0)\n-        *dst++ = 0x20;\n-    } else {\n-        *dst++ = *src++;\n-    }\n-    }\n-    *dst = 0;\n+    xmlValidNormalizeString(ret);\n@@ -4117,2 +4152,1 @@\n-    xmlChar *ret, *dst;\n-    const xmlChar *src;\n+    xmlChar *ret;\n@@ -4148,13 +4182,1 @@\n-    src = value;\n-    dst = ret;\n-    while (*src == 0x20) src++;\n-    while (*src != 0) {\n-    if (*src == 0x20) {\n-        while (*src == 0x20) src++;\n-        if (*src != 0)\n-        *dst++ = 0x20;\n-    } else {\n-        *dst++ = *src++;\n-    }\n-    }\n-    *dst = 0;\n+    xmlValidNormalizeString(ret);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/valid.c","additions":55,"deletions":33,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-Rather, it's a readme for the VC10 project files, attached to the libxml2 proejct.\r\n+Rather, it's a readme for the VC10 project files, attached to the libxml2 project.\r\n@@ -12,1 +12,1 @@\n-2) check and correct paths for dependent \"iconv\" project which most certaily \r\n+2) check and correct paths for dependent \"iconv\" project which most certainly \r\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/win32\/VC10\/README.vc10","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -183,14 +183,0 @@\n-\tif (useCvsVer && fso.FileExists(\"..\\\\CVS\\\\Entries\")) {\n-\t\tcf = fso.OpenTextFile(\"..\\\\CVS\\\\Entries\", 1);\n-\t\twhile (cf.AtEndOfStream != true) {\n-\t\t\tln = cf.ReadLine();\n-\t\t\ts = new String(ln);\n-\t\t\tif (s.search(\/^\\\/ChangeLog\\\/\/) != -1) {\n-\t\t\t\tiDot = s.indexOf(\".\");\n-\t\t\t\tiSlash = s.indexOf(\"\/\", iDot);\n-\t\t\t\tverCvs = \"CVS\" + s.substring(iDot + 1, iSlash);\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\t\tcf.Close();\n-\t}\n@@ -411,0 +397,8 @@\n+\t\t} else if (s.search(\/\\@WITH_ZLIB\\@\/) != -1) {\n+\t\t\tof.WriteLine(s.replace(\/\\@WITH_ZLIB\\@\/, withZlib? \"1\" : \"0\"));\n+\t\t} else if (s.search(\/\\@WITH_LZMA\\@\/) != -1) {\n+\t\t\tof.WriteLine(s.replace(\/\\@WITH_LZMA\\@\/, withLzma? \"1\" : \"0\"));\n+\t\t} else if (s.search(\/\\@WITH_ICONV\\@\/) != -1) {\n+            of.WriteLine(s.replace(\/\\@WITH_ICONV\\@\/, withIconv? \"1\" : \"0\"));\n+\t\t} else if (s.search(\/\\@WITH_ICU\\@\/) != -1) {\n+\t\t\tof.WriteLine(s.replace(\/\\@WITH_ICU\\@\/, withIcu? \"1\" : \"0\"));\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/win32\/configure.js","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1413,0 +1413,1 @@\n+xmlPopOutputCallbacks\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/win32\/libxml2.def.src","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -128,3 +128,3 @@\n- *                                  *\n- *      Tree memory error handler               *\n- *                                  *\n+ *                                                                      *\n+ *              Tree memory error handler                               *\n+ *                                                                      *\n@@ -135,1 +135,1 @@\n-    \"Permission denied\",    \/* EACCES *\/\n+    \"Permission denied\",        \/* EACCES *\/\n@@ -137,5 +137,5 @@\n-    \"Bad file descriptor\",  \/* EBADF *\/\n-    \"Bad message\",      \/* EBADMSG *\/\n-    \"Resource busy\",        \/* EBUSY *\/\n-    \"Operation canceled\",   \/* ECANCELED *\/\n-    \"No child processes\",   \/* ECHILD *\/\n+    \"Bad file descriptor\",      \/* EBADF *\/\n+    \"Bad message\",              \/* EBADMSG *\/\n+    \"Resource busy\",            \/* EBUSY *\/\n+    \"Operation canceled\",       \/* ECANCELED *\/\n+    \"No child processes\",       \/* ECHILD *\/\n@@ -143,4 +143,4 @@\n-    \"Domain error\",     \/* EDOM *\/\n-    \"File exists\",      \/* EEXIST *\/\n-    \"Bad address\",      \/* EFAULT *\/\n-    \"File too large\",       \/* EFBIG *\/\n+    \"Domain error\",             \/* EDOM *\/\n+    \"File exists\",              \/* EEXIST *\/\n+    \"Bad address\",              \/* EFAULT *\/\n+    \"File too large\",           \/* EFBIG *\/\n@@ -149,5 +149,5 @@\n-    \"Invalid argument\",     \/* EINVAL *\/\n-    \"Input\/output error\",   \/* EIO *\/\n-    \"Is a directory\",       \/* EISDIR *\/\n-    \"Too many open files\",  \/* EMFILE *\/\n-    \"Too many links\",       \/* EMLINK *\/\n+    \"Invalid argument\",         \/* EINVAL *\/\n+    \"Input\/output error\",       \/* EIO *\/\n+    \"Is a directory\",           \/* EISDIR *\/\n+    \"Too many open files\",      \/* EMFILE *\/\n+    \"Too many links\",           \/* EMLINK *\/\n@@ -155,1 +155,1 @@\n-    \"Filename too long\",    \/* ENAMETOOLONG *\/\n+    \"Filename too long\",        \/* ENAMETOOLONG *\/\n@@ -157,1 +157,1 @@\n-    \"No such device\",       \/* ENODEV *\/\n+    \"No such device\",           \/* ENODEV *\/\n@@ -159,3 +159,3 @@\n-    \"Exec format error\",    \/* ENOEXEC *\/\n-    \"No locks available\",   \/* ENOLCK *\/\n-    \"Not enough space\",     \/* ENOMEM *\/\n+    \"Exec format error\",        \/* ENOEXEC *\/\n+    \"No locks available\",       \/* ENOLCK *\/\n+    \"Not enough space\",         \/* ENOMEM *\/\n@@ -164,3 +164,3 @@\n-    \"Not a directory\",      \/* ENOTDIR *\/\n-    \"Directory not empty\",  \/* ENOTEMPTY *\/\n-    \"Not supported\",        \/* ENOTSUP *\/\n+    \"Not a directory\",          \/* ENOTDIR *\/\n+    \"Directory not empty\",      \/* ENOTEMPTY *\/\n+    \"Not supported\",            \/* ENOTSUP *\/\n@@ -170,2 +170,2 @@\n-    \"Broken pipe\",      \/* EPIPE *\/\n-    \"Result too large\",     \/* ERANGE *\/\n+    \"Broken pipe\",              \/* EPIPE *\/\n+    \"Result too large\",         \/* ERANGE *\/\n@@ -173,4 +173,4 @@\n-    \"Invalid seek\",     \/* ESPIPE *\/\n-    \"No such process\",      \/* ESRCH *\/\n-    \"Operation timed out\",  \/* ETIMEDOUT *\/\n-    \"Improper link\",        \/* EXDEV *\/\n+    \"Invalid seek\",             \/* ESPIPE *\/\n+    \"No such process\",          \/* ESRCH *\/\n+    \"Operation timed out\",      \/* ETIMEDOUT *\/\n+    \"Improper link\",            \/* EXDEV *\/\n@@ -178,1 +178,1 @@\n-    \"encoder error\",        \/* XML_IO_ENCODER *\/\n+    \"encoder error\",            \/* XML_IO_ENCODER *\/\n@@ -184,6 +184,6 @@\n-    \"not a socket\",     \/* ENOTSOCK *\/\n-    \"already connected\",    \/* EISCONN *\/\n-    \"connection refused\",   \/* ECONNREFUSED *\/\n-    \"unreachable network\",  \/* ENETUNREACH *\/\n-    \"address in use\",       \/* EADDRINUSE *\/\n-    \"already in use\",       \/* EALREADY *\/\n+    \"not a socket\",             \/* ENOTSOCK *\/\n+    \"already connected\",        \/* EISCONN *\/\n+    \"connection refused\",       \/* ECONNREFUSED *\/\n+    \"unreachable network\",      \/* ENETUNREACH *\/\n+    \"address in use\",           \/* EADDRINUSE *\/\n+    \"already in use\",           \/* EALREADY *\/\n@@ -252,1 +252,1 @@\n-    if (errno == 0) code = 0;\n+        if (errno == 0) code = 0;\n@@ -447,1 +447,1 @@\n-    return;\n+        return;\n@@ -450,9 +450,9 @@\n-        channel = ctxt->sax->error;\n-        level = XML_ERR_ERROR;\n-    } else {\n-        channel = ctxt->sax->warning;\n-        level = XML_ERR_WARNING;\n-    }\n-    if (ctxt->sax->initialized == XML_SAX2_MAGIC)\n-        schannel = ctxt->sax->serror;\n-    data = ctxt->userData;\n+            channel = ctxt->sax->error;\n+            level = XML_ERR_ERROR;\n+        } else {\n+            channel = ctxt->sax->warning;\n+            level = XML_ERR_WARNING;\n+        }\n+        if (ctxt->sax->initialized == XML_SAX2_MAGIC)\n+            schannel = ctxt->sax->serror;\n+        data = ctxt->userData;\n@@ -462,2 +462,2 @@\n-            filename, NULL, NULL, 0, 0,\n-            msg, filename);\n+                    filename, NULL, NULL, 0, 0,\n+                    msg, filename);\n@@ -468,3 +468,3 @@\n- *                                  *\n- *      Tree memory error handler               *\n- *                                  *\n+ *                                                                      *\n+ *              Tree memory error handler                               *\n+ *                                                                      *\n@@ -593,3 +593,3 @@\n- *                                  *\n- *      Standard I\/O for file accesses              *\n- *                                  *\n+ *                                                                      *\n+ *              Standard I\/O for file accesses                          *\n+ *                                                                      *\n@@ -641,1 +641,1 @@\n-    int d, m = (strstr(mode, \"r\") ? O_RDONLY : O_RDWR);\n+        int d, m = (strstr(mode, \"r\") ? O_RDONLY : O_RDWR);\n@@ -645,3 +645,3 @@\n-    d = _wopen(wPath, m);\n-    if (d >= 0)\n-        fd = gzdopen(d, mode);\n+        d = _wopen(wPath, m);\n+        if (d >= 0)\n+            fd = gzdopen(d, mode);\n@@ -706,1 +706,1 @@\n-    return(0);\n+        return(0);\n@@ -715,2 +715,2 @@\n-    (path[3] == '\\\\') )\n-        return 1;\n+        (path[3] == '\\\\') )\n+            return 1;\n@@ -781,2 +781,2 @@\n-    ret = write((int) (ptrdiff_t) context, &buffer[0], len);\n-    if (ret < 0) xmlIOErr(0, \"write()\");\n+        ret = write((int) (ptrdiff_t) context, &buffer[0], len);\n+        if (ret < 0) xmlIOErr(0, \"write()\");\n@@ -835,2 +835,2 @@\n-    fd = stdin;\n-    return((void *) fd);\n+        fd = stdin;\n+        return((void *) fd);\n@@ -841,1 +841,1 @@\n-    path = &filename[17];\n+        path = &filename[17];\n@@ -843,1 +843,1 @@\n-    path = &filename[16];\n+        path = &filename[16];\n@@ -847,1 +847,1 @@\n-    path = &filename[8];\n+        path = &filename[8];\n@@ -849,1 +849,1 @@\n-    path = &filename[7];\n+        path = &filename[7];\n@@ -854,1 +854,1 @@\n-    path = &filename[6];\n+        path = &filename[6];\n@@ -856,1 +856,1 @@\n-    path = &filename[5];\n+        path = &filename[5];\n@@ -891,5 +891,5 @@\n-    unescaped = xmlURIUnescapeString(filename, 0, NULL);\n-    if (unescaped != NULL) {\n-        retval = xmlFileOpen_real(unescaped);\n-        xmlFree(unescaped);\n-    }\n+        unescaped = xmlURIUnescapeString(filename, 0, NULL);\n+        if (unescaped != NULL) {\n+            retval = xmlFileOpen_real(unescaped);\n+            xmlFree(unescaped);\n+        }\n@@ -917,2 +917,2 @@\n-    fd = stdout;\n-    return((void *) fd);\n+        fd = stdout;\n+        return((void *) fd);\n@@ -923,1 +923,1 @@\n-    path = &filename[17];\n+        path = &filename[17];\n@@ -925,1 +925,1 @@\n-    path = &filename[16];\n+        path = &filename[16];\n@@ -929,1 +929,1 @@\n-    path = &filename[8];\n+        path = &filename[8];\n@@ -931,1 +931,1 @@\n-    path = &filename[7];\n+        path = &filename[7];\n@@ -934,1 +934,1 @@\n-    path = filename;\n+        path = filename;\n@@ -937,1 +937,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -992,1 +992,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1016,3 +1016,3 @@\n-    if (ret < 0)\n-        xmlIOErr(0, \"fflush()\");\n-    return(0);\n+        if (ret < 0)\n+            xmlIOErr(0, \"fflush()\");\n+        return(0);\n@@ -1021,1 +1021,1 @@\n-    return(0);\n+        return(0);\n@@ -1070,3 +1070,3 @@\n- *                                  *\n- *      I\/O for compressed file accesses            *\n- *                                  *\n+ *                                                                      *\n+ *              I\/O for compressed file accesses                        *\n+ *                                                                      *\n@@ -1108,1 +1108,1 @@\n-    return((void *) fd);\n+        return((void *) fd);\n@@ -1113,1 +1113,1 @@\n-    path = &filename[17];\n+        path = &filename[17];\n@@ -1115,1 +1115,1 @@\n-    path = &filename[16];\n+        path = &filename[16];\n@@ -1119,1 +1119,1 @@\n-    path = &filename[8];\n+        path = &filename[8];\n@@ -1121,1 +1121,1 @@\n-    path = &filename[7];\n+        path = &filename[7];\n@@ -1124,1 +1124,1 @@\n-    path = filename;\n+        path = filename;\n@@ -1127,1 +1127,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1153,5 +1153,5 @@\n-    unescaped = xmlURIUnescapeString(filename, 0, NULL);\n-    if (unescaped != NULL) {\n-        retval = xmlGzfileOpen_real(unescaped);\n-    }\n-    xmlFree(unescaped);\n+        unescaped = xmlURIUnescapeString(filename, 0, NULL);\n+        if (unescaped != NULL) {\n+            retval = xmlGzfileOpen_real(unescaped);\n+        }\n+        xmlFree(unescaped);\n@@ -1187,1 +1187,1 @@\n-    return((void *) fd);\n+        return((void *) fd);\n@@ -1192,1 +1192,1 @@\n-    path = &filename[17];\n+        path = &filename[17];\n@@ -1194,1 +1194,1 @@\n-    path = &filename[16];\n+        path = &filename[16];\n@@ -1198,1 +1198,1 @@\n-    path = &filename[8];\n+        path = &filename[8];\n@@ -1200,1 +1200,1 @@\n-    path = &filename[7];\n+        path = &filename[7];\n@@ -1203,1 +1203,1 @@\n-    path = filename;\n+        path = filename;\n@@ -1206,1 +1206,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1275,3 +1275,3 @@\n- *                                  *\n- *      I\/O for compressed file accesses            *\n- *                                  *\n+ *                                                                      *\n+ *              I\/O for compressed file accesses                        *\n+ *                                                                      *\n@@ -1309,1 +1309,1 @@\n-    return((void *) fd);\n+        return((void *) fd);\n@@ -1313,1 +1313,1 @@\n-    path = &filename[16];\n+        path = &filename[16];\n@@ -1315,1 +1315,1 @@\n-    path = &filename[7];\n+        path = &filename[7];\n@@ -1318,1 +1318,1 @@\n-    path = &filename[5];\n+        path = &filename[5];\n@@ -1320,1 +1320,1 @@\n-    path = filename;\n+        path = filename;\n@@ -1323,1 +1323,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1347,5 +1347,5 @@\n-    unescaped = xmlURIUnescapeString(filename, 0, NULL);\n-    if (unescaped != NULL) {\n-        retval = xmlXzfileOpen_real(unescaped);\n-    }\n-    xmlFree(unescaped);\n+        unescaped = xmlURIUnescapeString(filename, 0, NULL);\n+        if (unescaped != NULL) {\n+            retval = xmlXzfileOpen_real(unescaped);\n+        }\n+        xmlFree(unescaped);\n@@ -1394,3 +1394,3 @@\n- *                                  *\n- *          I\/O for HTTP file accesses          *\n- *                                  *\n+ *                                                                      *\n+ *                      I\/O for HTTP file accesses                      *\n+ *                                                                      *\n@@ -1402,1 +1402,1 @@\n-    int         compression;\n+    int                 compression;\n@@ -1404,1 +1404,1 @@\n-    char *      uri;\n+    char *              uri;\n@@ -1406,1 +1406,1 @@\n-    void *      doc_buff;\n+    void *              doc_buff;\n@@ -1412,7 +1412,7 @@\n-#define DFLT_WBITS      ( -15 )\n-#define DFLT_MEM_LVL        ( 8 )\n-#define GZ_MAGIC1       ( 0x1f )\n-#define GZ_MAGIC2       ( 0x8b )\n-#define LXML_ZLIB_OS_CODE   ( 0x03 )\n-#define INIT_HTTP_BUFF_SIZE ( 32768 )\n-#define DFLT_ZLIB_RATIO     ( 5 )\n+#define DFLT_WBITS              ( -15 )\n+#define DFLT_MEM_LVL            ( 8 )\n+#define GZ_MAGIC1               ( 0x1f )\n+#define GZ_MAGIC2               ( 0x8b )\n+#define LXML_ZLIB_OS_CODE       ( 0x03 )\n+#define INIT_HTTP_BUFF_SIZE     ( 32768 )\n+#define DFLT_ZLIB_RATIO         ( 5 )\n@@ -1427,2 +1427,2 @@\n-   unsigned long    size;\n-   unsigned long    crc;\n+   unsigned long        size;\n+   unsigned long        crc;\n@@ -1430,2 +1430,2 @@\n-   unsigned char *  zbuff;\n-   z_stream     zctrl;\n+   unsigned char *      zbuff;\n+   z_stream             zctrl;\n@@ -1446,1 +1446,1 @@\n-    int     idx;\n+    int         idx;\n@@ -1449,1 +1449,1 @@\n-    return;\n+        return;\n@@ -1459,3 +1459,3 @@\n-    *buff->zctrl.next_out = ( data & 0xff );\n-    data >>= 8;\n-    buff->zctrl.next_out++;\n+        *buff->zctrl.next_out = ( data & 0xff );\n+        data >>= 8;\n+        buff->zctrl.next_out++;\n@@ -1482,1 +1482,1 @@\n-    return;\n+        return;\n@@ -1488,3 +1488,3 @@\n-    xmlGenericError( xmlGenericErrorContext,\n-            \"xmlFreeZMemBuff:  Error releasing zlib context:  %d\\n\",\n-            z_err );\n+        xmlGenericError( xmlGenericErrorContext,\n+                        \"xmlFreeZMemBuff:  Error releasing zlib context:  %d\\n\",\n+                        z_err );\n@@ -1512,3 +1512,3 @@\n-    int         z_err;\n-    int         hdr_lgth;\n-    xmlZMemBuffPtr  buff = NULL;\n+    int                 z_err;\n+    int                 hdr_lgth;\n+    xmlZMemBuffPtr      buff = NULL;\n@@ -1517,1 +1517,1 @@\n-    return ( NULL );\n+        return ( NULL );\n@@ -1523,2 +1523,2 @@\n-    xmlIOErrMemory(\"creating buffer context\");\n-    return ( NULL );\n+        xmlIOErrMemory(\"creating buffer context\");\n+        return ( NULL );\n@@ -1531,3 +1531,3 @@\n-    xmlFreeZMemBuff( buff );\n-    xmlIOErrMemory(\"creating buffer\");\n-    return ( NULL );\n+        xmlFreeZMemBuff( buff );\n+        xmlIOErrMemory(\"creating buffer\");\n+        return ( NULL );\n@@ -1537,1 +1537,1 @@\n-                DFLT_WBITS, DFLT_MEM_LVL, Z_DEFAULT_STRATEGY );\n+                            DFLT_WBITS, DFLT_MEM_LVL, Z_DEFAULT_STRATEGY );\n@@ -1539,9 +1539,9 @@\n-    xmlChar msg[500];\n-    xmlFreeZMemBuff( buff );\n-    buff = NULL;\n-    xmlStrPrintf(msg, 500,\n-            \"xmlCreateZMemBuff:  %s %d\\n\",\n-            \"Error initializing compression context.  ZLIB error:\",\n-            z_err );\n-    xmlIOErr(XML_IO_WRITE, (const char *) msg);\n-    return ( NULL );\n+        xmlChar msg[500];\n+        xmlFreeZMemBuff( buff );\n+        buff = NULL;\n+        xmlStrPrintf(msg, 500,\n+                    \"xmlCreateZMemBuff:  %s %d\\n\",\n+                    \"Error initializing compression context.  ZLIB error:\",\n+                    z_err );\n+        xmlIOErr(XML_IO_WRITE, (const char *) msg);\n+        return ( NULL );\n@@ -1553,3 +1553,3 @@\n-            \"%c%c%c%c%c%c%c%c%c%c\",\n-            GZ_MAGIC1, GZ_MAGIC2, Z_DEFLATED,\n-            0, 0, 0, 0, 0, 0, LXML_ZLIB_OS_CODE );\n+                        \"%c%c%c%c%c%c%c%c%c%c\",\n+                        GZ_MAGIC1, GZ_MAGIC2, Z_DEFLATED,\n+                        0, 0, 0, 0, 0, 0, LXML_ZLIB_OS_CODE );\n@@ -1576,3 +1576,3 @@\n-    int         rc = -1;\n-    size_t      new_size;\n-    size_t      cur_used;\n+    int                 rc = -1;\n+    size_t              new_size;\n+    size_t              cur_used;\n@@ -1580,1 +1580,1 @@\n-    unsigned char * tmp_ptr = NULL;\n+    unsigned char *     tmp_ptr = NULL;\n@@ -1583,1 +1583,1 @@\n-    return ( -1 );\n+        return ( -1 );\n@@ -1586,1 +1586,1 @@\n-    return ( 0 );\n+        return ( 0 );\n@@ -1593,5 +1593,5 @@\n-    xmlGenericError( xmlGenericErrorContext,\n-            \"xmlZMemBuffExtend:  %s\\n%s %d bytes.\\n\",\n-            \"Buffer overwrite detected during compressed memory\",\n-            \"buffer extension.  Overflowed by\",\n-            (cur_used - new_size ) );\n+        xmlGenericError( xmlGenericErrorContext,\n+                        \"xmlZMemBuffExtend:  %s\\n%s %d bytes.\\n\",\n+                        \"Buffer overwrite detected during compressed memory\",\n+                        \"buffer extension.  Overflowed by\",\n+                        (cur_used - new_size ) );\n@@ -1602,5 +1602,5 @@\n-    rc = 0;\n-    buff->size  = new_size;\n-    buff->zbuff = tmp_ptr;\n-    buff->zctrl.next_out  = tmp_ptr + cur_used;\n-    buff->zctrl.avail_out = new_size - cur_used;\n+        rc = 0;\n+        buff->size  = new_size;\n+        buff->zbuff = tmp_ptr;\n+        buff->zctrl.next_out  = tmp_ptr + cur_used;\n+        buff->zctrl.avail_out = new_size - cur_used;\n@@ -1609,6 +1609,6 @@\n-    xmlChar msg[500];\n-    xmlStrPrintf(msg, 500,\n-            \"xmlZMemBuffExtend:  %s %lu bytes.\\n\",\n-            \"Allocation failure extending output buffer to\",\n-            (unsigned long) new_size );\n-    xmlIOErr(XML_IO_WRITE, (const char *) msg);\n+        xmlChar msg[500];\n+        xmlStrPrintf(msg, 500,\n+                    \"xmlZMemBuffExtend:  %s %lu bytes.\\n\",\n+                    \"Allocation failure extending output buffer to\",\n+                    (unsigned long) new_size );\n+        xmlIOErr(XML_IO_WRITE, (const char *) msg);\n@@ -1634,2 +1634,2 @@\n-    int     z_err;\n-    size_t  min_accept;\n+    int         z_err;\n+    size_t      min_accept;\n@@ -1638,1 +1638,1 @@\n-    return ( -1 );\n+        return ( -1 );\n@@ -1643,9 +1643,9 @@\n-    \/*\n-    **  Extend the buffer prior to deflate call if a reasonable amount\n-    **  of output buffer space is not available.\n-    *\/\n-    min_accept = buff->zctrl.avail_in \/ DFLT_ZLIB_RATIO;\n-    if ( buff->zctrl.avail_out <= min_accept ) {\n-        if ( xmlZMemBuffExtend( buff, buff->size ) == -1 )\n-        return ( -1 );\n-    }\n+        \/*\n+        **  Extend the buffer prior to deflate call if a reasonable amount\n+        **  of output buffer space is not available.\n+        *\/\n+        min_accept = buff->zctrl.avail_in \/ DFLT_ZLIB_RATIO;\n+        if ( buff->zctrl.avail_out <= min_accept ) {\n+            if ( xmlZMemBuffExtend( buff, buff->size ) == -1 )\n+                return ( -1 );\n+        }\n@@ -1653,10 +1653,10 @@\n-    z_err = deflate( &buff->zctrl, Z_NO_FLUSH );\n-    if ( z_err != Z_OK ) {\n-        xmlChar msg[500];\n-        xmlStrPrintf(msg, 500,\n-            \"xmlZMemBuffAppend:  %s %d %s - %d\",\n-            \"Compression error while appending\",\n-            len, \"bytes to buffer.  ZLIB error\", z_err );\n-        xmlIOErr(XML_IO_WRITE, (const char *) msg);\n-        return ( -1 );\n-    }\n+        z_err = deflate( &buff->zctrl, Z_NO_FLUSH );\n+        if ( z_err != Z_OK ) {\n+            xmlChar msg[500];\n+            xmlStrPrintf(msg, 500,\n+                        \"xmlZMemBuffAppend:  %s %d %s - %d\",\n+                        \"Compression error while appending\",\n+                        len, \"bytes to buffer.  ZLIB error\", z_err );\n+            xmlIOErr(XML_IO_WRITE, (const char *) msg);\n+            return ( -1 );\n+        }\n@@ -1684,2 +1684,2 @@\n-    int     zlgth = -1;\n-    int     z_err;\n+    int         zlgth = -1;\n+    int         z_err;\n@@ -1688,1 +1688,1 @@\n-    return ( -1 );\n+        return ( -1 );\n@@ -1694,3 +1694,3 @@\n-    z_err = deflate( &buff->zctrl, Z_FINISH );\n-    if ( z_err == Z_OK ) {\n-        \/*  In this case Z_OK means more buffer space needed  *\/\n+        z_err = deflate( &buff->zctrl, Z_FINISH );\n+        if ( z_err == Z_OK ) {\n+            \/*  In this case Z_OK means more buffer space needed  *\/\n@@ -1698,3 +1698,3 @@\n-        if ( xmlZMemBuffExtend( buff, buff->size ) == -1 )\n-        return ( -1 );\n-    }\n+            if ( xmlZMemBuffExtend( buff, buff->size ) == -1 )\n+                return ( -1 );\n+        }\n@@ -1708,1 +1708,1 @@\n-    \/*  Need to append the gzip data trailer  *\/\n+        \/*  Need to append the gzip data trailer  *\/\n@@ -1710,4 +1710,4 @@\n-    if ( buff->zctrl.avail_out < ( 2 * sizeof( unsigned long ) ) ) {\n-        if ( xmlZMemBuffExtend(buff, (2 * sizeof(unsigned long))) == -1 )\n-        return ( -1 );\n-    }\n+        if ( buff->zctrl.avail_out < ( 2 * sizeof( unsigned long ) ) ) {\n+            if ( xmlZMemBuffExtend(buff, (2 * sizeof(unsigned long))) == -1 )\n+                return ( -1 );\n+        }\n@@ -1715,4 +1715,4 @@\n-    \/*\n-    **  For whatever reason, the CRC and length data are pushed out\n-    **  in reverse byte order.  So a memcpy can't be used here.\n-    *\/\n+        \/*\n+        **  For whatever reason, the CRC and length data are pushed out\n+        **  in reverse byte order.  So a memcpy can't be used here.\n+        *\/\n@@ -1720,2 +1720,2 @@\n-    append_reverse_ulong( buff, buff->crc );\n-    append_reverse_ulong( buff, buff->zctrl.total_in );\n+        append_reverse_ulong( buff, buff->crc );\n+        append_reverse_ulong( buff, buff->zctrl.total_in );\n@@ -1723,2 +1723,2 @@\n-    zlgth = buff->zctrl.next_out - buff->zbuff;\n-    *data_ref = (char *)buff->zbuff;\n+        zlgth = buff->zctrl.next_out - buff->zbuff;\n+        *data_ref = (char *)buff->zbuff;\n@@ -1728,5 +1728,5 @@\n-    xmlChar msg[500];\n-    xmlStrPrintf(msg, 500,\n-            \"xmlZMemBuffGetContent:  %s - %d\\n\",\n-            \"Error flushing zlib buffers.  Error code\", z_err );\n-    xmlIOErr(XML_IO_WRITE, (const char *) msg);\n+        xmlChar msg[500];\n+        xmlStrPrintf(msg, 500,\n+                    \"xmlZMemBuffGetContent:  %s - %d\\n\",\n+                    \"Error flushing zlib buffers.  Error code\", z_err );\n+        xmlIOErr(XML_IO_WRITE, (const char *) msg);\n@@ -1753,1 +1753,1 @@\n-    xmlFree( ctxt->uri );\n+        xmlFree( ctxt->uri );\n@@ -1758,4 +1758,4 @@\n-    if ( ctxt->compression > 0 ) {\n-        xmlFreeZMemBuff( ctxt->doc_buff );\n-    }\n-    else\n+        if ( ctxt->compression > 0 ) {\n+            xmlFreeZMemBuff( ctxt->doc_buff );\n+        }\n+        else\n@@ -1763,3 +1763,3 @@\n-    {\n-        xmlOutputBufferClose( ctxt->doc_buff );\n-    }\n+        {\n+            xmlOutputBufferClose( ctxt->doc_buff );\n+        }\n@@ -1785,1 +1785,1 @@\n-    return(1);\n+        return(1);\n@@ -1825,1 +1825,1 @@\n-    xmlIOErrMemory(\"creating HTTP output context\");\n+        xmlIOErrMemory(\"creating HTTP output context\");\n@@ -1833,1 +1833,1 @@\n-    xmlIOErrMemory(\"copying URI\");\n+        xmlIOErrMemory(\"copying URI\");\n@@ -1915,1 +1915,1 @@\n-    xmlIOHTTPWriteCtxtPtr   ctxt = context;\n+    xmlIOHTTPWriteCtxtPtr       ctxt = context;\n@@ -1918,1 +1918,1 @@\n-    return ( -1 );\n+        return ( -1 );\n@@ -1922,1 +1922,1 @@\n-    \/*  Use gzwrite or fwrite as previously setup in the open call  *\/\n+        \/*  Use gzwrite or fwrite as previously setup in the open call  *\/\n@@ -1925,2 +1925,2 @@\n-    if ( ctxt->compression > 0 )\n-        len = xmlZMemBuffAppend( ctxt->doc_buff, buffer, len );\n+        if ( ctxt->compression > 0 )\n+            len = xmlZMemBuffAppend( ctxt->doc_buff, buffer, len );\n@@ -1928,1 +1928,1 @@\n-    else\n+        else\n@@ -1930,11 +1930,11 @@\n-        len = xmlOutputBufferWrite( ctxt->doc_buff, len, buffer );\n-\n-    if ( len < 0 ) {\n-        xmlChar msg[500];\n-        xmlStrPrintf(msg, 500,\n-            \"xmlIOHTTPWrite:  %s\\n%s '%s'.\\n\",\n-            \"Error appending to internal buffer.\",\n-            \"Error sending document to URI\",\n-            ctxt->uri );\n-        xmlIOErr(XML_IO_WRITE, (const char *) msg);\n-    }\n+            len = xmlOutputBufferWrite( ctxt->doc_buff, len, buffer );\n+\n+        if ( len < 0 ) {\n+            xmlChar msg[500];\n+            xmlStrPrintf(msg, 500,\n+                        \"xmlIOHTTPWrite:  %s\\n%s '%s'.\\n\",\n+                        \"Error appending to internal buffer.\",\n+                        \"Error sending document to URI\",\n+                        ctxt->uri );\n+            xmlIOErr(XML_IO_WRITE, (const char *) msg);\n+        }\n@@ -1973,4 +1973,4 @@\n-    int             close_rc = -1;\n-    int             http_rtn = 0;\n-    int             content_lgth = 0;\n-    xmlIOHTTPWriteCtxtPtr   ctxt = context;\n+    int                         close_rc = -1;\n+    int                         http_rtn = 0;\n+    int                         content_lgth = 0;\n+    xmlIOHTTPWriteCtxtPtr       ctxt = context;\n@@ -1978,4 +1978,4 @@\n-    char *          http_content = NULL;\n-    char *          content_encoding = NULL;\n-    char *          content_type = (char *) \"text\/xml\";\n-    void *          http_ctxt = NULL;\n+    char *                      http_content = NULL;\n+    char *                      content_encoding = NULL;\n+    char *                      content_type = (char *) \"text\/xml\";\n+    void *                      http_ctxt = NULL;\n@@ -1984,1 +1984,1 @@\n-    return ( -1 );\n+        return ( -1 );\n@@ -1991,2 +1991,2 @@\n-    content_lgth = xmlZMemBuffGetContent( ctxt->doc_buff, &http_content );\n-    content_encoding = (char *) \"Content-Encoding: gzip\";\n+        content_lgth = xmlZMemBuffGetContent( ctxt->doc_buff, &http_content );\n+        content_encoding = (char *) \"Content-Encoding: gzip\";\n@@ -1997,1 +1997,1 @@\n-    \/*  Pull the data out of the memory output buffer  *\/\n+        \/*  Pull the data out of the memory output buffer  *\/\n@@ -1999,3 +1999,3 @@\n-    xmlOutputBufferPtr  dctxt = ctxt->doc_buff;\n-    http_content = (char *) xmlBufContent(dctxt->buffer);\n-    content_lgth = xmlBufUse(dctxt->buffer);\n+        xmlOutputBufferPtr      dctxt = ctxt->doc_buff;\n+        http_content = (char *) xmlBufContent(dctxt->buffer);\n+        content_lgth = xmlBufUse(dctxt->buffer);\n@@ -2005,6 +2005,6 @@\n-    xmlChar msg[500];\n-    xmlStrPrintf(msg, 500,\n-             \"xmlIOHTTPCloseWrite:  %s '%s' %s '%s'.\\n\",\n-             \"Error retrieving content.\\nUnable to\",\n-             http_mthd, \"data to URI\", ctxt->uri );\n-    xmlIOErr(XML_IO_WRITE, (const char *) msg);\n+        xmlChar msg[500];\n+        xmlStrPrintf(msg, 500,\n+                     \"xmlIOHTTPCloseWrite:  %s '%s' %s '%s'.\\n\",\n+                     \"Error retrieving content.\\nUnable to\",\n+                     http_mthd, \"data to URI\", ctxt->uri );\n+        xmlIOErr(XML_IO_WRITE, (const char *) msg);\n@@ -2015,3 +2015,3 @@\n-    http_ctxt = xmlNanoHTTPMethod( ctxt->uri, http_mthd, http_content,\n-                    &content_type, content_encoding,\n-                    content_lgth );\n+        http_ctxt = xmlNanoHTTPMethod( ctxt->uri, http_mthd, http_content,\n+                                        &content_type, content_encoding,\n+                                        content_lgth );\n@@ -2019,1 +2019,1 @@\n-    if ( http_ctxt != NULL ) {\n+        if ( http_ctxt != NULL ) {\n@@ -2021,1 +2021,1 @@\n-        \/*  If testing\/debugging - dump reply with request content  *\/\n+            \/*  If testing\/debugging - dump reply with request content  *\/\n@@ -2023,15 +2023,4 @@\n-        FILE *  tst_file = NULL;\n-        char    buffer[ 4096 ];\n-        char *  dump_name = NULL;\n-        int     avail;\n-\n-        xmlGenericError( xmlGenericErrorContext,\n-            \"xmlNanoHTTPCloseWrite:  HTTP %s to\\n%s returned %d.\\n\",\n-            http_mthd, ctxt->uri,\n-            xmlNanoHTTPReturnCode( http_ctxt ) );\n-\n-        \/*\n-        **  Since either content or reply may be gzipped,\n-        **  dump them to separate files instead of the\n-        **  standard error context.\n-        *\/\n+            FILE *      tst_file = NULL;\n+            char        buffer[ 4096 ];\n+            char *      dump_name = NULL;\n+            int         avail;\n@@ -2039,6 +2028,0 @@\n-        dump_name = tempnam( NULL, \"lxml\" );\n-        if ( dump_name != NULL ) {\n-        (void)snprintf( buffer, sizeof(buffer), \"%s.content\", dump_name );\n-\n-        tst_file = fopen( buffer, \"wb\" );\n-        if ( tst_file != NULL ) {\n@@ -2046,6 +2029,23 @@\n-            \"Transmitted content saved in file:  %s\\n\", buffer );\n-\n-            fwrite( http_content, sizeof( char ),\n-                    content_lgth, tst_file );\n-            fclose( tst_file );\n-        }\n+                        \"xmlNanoHTTPCloseWrite:  HTTP %s to\\n%s returned %d.\\n\",\n+                        http_mthd, ctxt->uri,\n+                        xmlNanoHTTPReturnCode( http_ctxt ) );\n+\n+            \/*\n+            **  Since either content or reply may be gzipped,\n+            **  dump them to separate files instead of the\n+            **  standard error context.\n+            *\/\n+\n+            dump_name = tempnam( NULL, \"lxml\" );\n+            if ( dump_name != NULL ) {\n+                (void)snprintf( buffer, sizeof(buffer), \"%s.content\", dump_name );\n+\n+                tst_file = fopen( buffer, \"wb\" );\n+                if ( tst_file != NULL ) {\n+                    xmlGenericError( xmlGenericErrorContext,\n+                        \"Transmitted content saved in file:  %s\\n\", buffer );\n+\n+                    fwrite( http_content, sizeof( char ),\n+                                        content_lgth, tst_file );\n+                    fclose( tst_file );\n+                }\n@@ -2053,5 +2053,5 @@\n-        (void)snprintf( buffer, sizeof(buffer), \"%s.reply\", dump_name );\n-        tst_file = fopen( buffer, \"wb\" );\n-        if ( tst_file != NULL ) {\n-            xmlGenericError( xmlGenericErrorContext,\n-            \"Reply content saved in file:  %s\\n\", buffer );\n+                (void)snprintf( buffer, sizeof(buffer), \"%s.reply\", dump_name );\n+                tst_file = fopen( buffer, \"wb\" );\n+                if ( tst_file != NULL ) {\n+                    xmlGenericError( xmlGenericErrorContext,\n+                        \"Reply content saved in file:  %s\\n\", buffer );\n@@ -2060,2 +2060,2 @@\n-            while ( (avail = xmlNanoHTTPRead( http_ctxt,\n-                    buffer, sizeof( buffer ) )) > 0 ) {\n+                    while ( (avail = xmlNanoHTTPRead( http_ctxt,\n+                                        buffer, sizeof( buffer ) )) > 0 ) {\n@@ -2063,2 +2063,2 @@\n-            fwrite( buffer, sizeof( char ), avail, tst_file );\n-            }\n+                        fwrite( buffer, sizeof( char ), avail, tst_file );\n+                    }\n@@ -2066,2 +2066,2 @@\n-            fclose( tst_file );\n-        }\n+                    fclose( tst_file );\n+                }\n@@ -2069,2 +2069,2 @@\n-        free( dump_name );\n-        }\n+                free( dump_name );\n+            }\n@@ -2073,4 +2073,4 @@\n-        http_rtn = xmlNanoHTTPReturnCode( http_ctxt );\n-        if ( ( http_rtn >= 200 ) && ( http_rtn < 300 ) )\n-        close_rc = 0;\n-        else {\n+            http_rtn = xmlNanoHTTPReturnCode( http_ctxt );\n+            if ( ( http_rtn >= 200 ) && ( http_rtn < 300 ) )\n+                close_rc = 0;\n+            else {\n@@ -2080,4 +2080,4 @@\n-                http_mthd, content_lgth,\n-                \"bytes to URI\", ctxt->uri,\n-                \"failed.  HTTP return code:\", http_rtn );\n-        xmlIOErr(XML_IO_WRITE, (const char *) msg);\n+                            http_mthd, content_lgth,\n+                            \"bytes to URI\", ctxt->uri,\n+                            \"failed.  HTTP return code:\", http_rtn );\n+                xmlIOErr(XML_IO_WRITE, (const char *) msg);\n@@ -2086,3 +2086,3 @@\n-        xmlNanoHTTPClose( http_ctxt );\n-        xmlFree( content_type );\n-    }\n+            xmlNanoHTTPClose( http_ctxt );\n+            xmlFree( content_type );\n+        }\n@@ -2130,3 +2130,3 @@\n- *                                  *\n- *          I\/O for FTP file accesses           *\n- *                                  *\n+ *                                                                      *\n+ *                      I\/O for FTP file accesses                       *\n+ *                                                                      *\n@@ -2145,1 +2145,1 @@\n-    return(1);\n+        return(1);\n@@ -2206,2 +2206,2 @@\n-    xmlInputOpenCallback openFunc, xmlInputReadCallback readFunc,\n-    xmlInputCloseCallback closeFunc) {\n+        xmlInputOpenCallback openFunc, xmlInputReadCallback readFunc,\n+        xmlInputCloseCallback closeFunc) {\n@@ -2209,1 +2209,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2233,2 +2233,2 @@\n-    xmlOutputOpenCallback openFunc, xmlOutputWriteCallback writeFunc,\n-    xmlOutputCloseCallback closeFunc) {\n+        xmlOutputOpenCallback openFunc, xmlOutputWriteCallback writeFunc,\n+        xmlOutputCloseCallback closeFunc) {\n@@ -2236,1 +2236,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2255,1 +2255,1 @@\n-    return;\n+        return;\n@@ -2258,1 +2258,1 @@\n-                          xmlFileRead, xmlFileClose);\n+                              xmlFileRead, xmlFileClose);\n@@ -2261,1 +2261,1 @@\n-                          xmlGzfileRead, xmlGzfileClose);\n+                              xmlGzfileRead, xmlGzfileClose);\n@@ -2265,1 +2265,1 @@\n-                          xmlXzfileRead, xmlXzfileClose);\n+                              xmlXzfileRead, xmlXzfileClose);\n@@ -2270,1 +2270,1 @@\n-                          xmlIOHTTPRead, xmlIOHTTPClose);\n+                              xmlIOHTTPRead, xmlIOHTTPClose);\n@@ -2275,1 +2275,1 @@\n-                          xmlIOFTPRead, xmlIOFTPClose);\n+                              xmlIOFTPRead, xmlIOFTPClose);\n@@ -2289,1 +2289,1 @@\n-    return;\n+        return;\n@@ -2292,1 +2292,1 @@\n-                          xmlFileWrite, xmlFileClose);\n+                              xmlFileWrite, xmlFileClose);\n@@ -2296,1 +2296,1 @@\n-                           xmlIOHTTPWrite, xmlIOHTTPClosePut);\n+                               xmlIOHTTPWrite, xmlIOHTTPClosePut);\n@@ -2306,1 +2306,1 @@\n-                           xmlGzfileWrite, xmlGzfileClose);\n+                               xmlGzfileWrite, xmlGzfileClose);\n@@ -2312,1 +2312,1 @@\n-                           xmlIOFTPWrite, xmlIOFTPClose);\n+                               xmlIOFTPWrite, xmlIOFTPClose);\n@@ -2333,1 +2333,1 @@\n-    xmlRegisterDefaultOutputCallbacks( );\n+        xmlRegisterDefaultOutputCallbacks( );\n@@ -2336,1 +2336,1 @@\n-                           xmlIOHTTPWrite, xmlIOHTTPClosePost);\n+                               xmlIOHTTPWrite, xmlIOHTTPClosePost);\n@@ -2356,2 +2356,2 @@\n-    xmlIOErrMemory(\"creating input buffer\");\n-    return(NULL);\n+        xmlIOErrMemory(\"creating input buffer\");\n+        return(NULL);\n@@ -2363,1 +2363,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2395,2 +2395,2 @@\n-    xmlIOErrMemory(\"creating output buffer\");\n-    return(NULL);\n+        xmlIOErrMemory(\"creating output buffer\");\n+        return(NULL);\n@@ -2402,1 +2402,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2412,1 +2412,1 @@\n-    if (ret->conv == NULL) {\n+        if (ret->conv == NULL) {\n@@ -2414,3 +2414,3 @@\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n+            xmlFree(ret);\n+            return(NULL);\n+        }\n@@ -2418,4 +2418,4 @@\n-    \/*\n-     * This call is designed to initiate the encoder state\n-     *\/\n-    xmlCharEncOutput(ret, 1);\n+        \/*\n+         * This call is designed to initiate the encoder state\n+         *\/\n+        xmlCharEncOutput(ret, 1);\n@@ -2446,2 +2446,2 @@\n-    xmlIOErrMemory(\"creating output buffer\");\n-    return(NULL);\n+        xmlIOErrMemory(\"creating output buffer\");\n+        return(NULL);\n@@ -2453,1 +2453,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2465,1 +2465,1 @@\n-    if (ret->conv == NULL) {\n+        if (ret->conv == NULL) {\n@@ -2467,3 +2467,3 @@\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n+            xmlFree(ret);\n+            return(NULL);\n+        }\n@@ -2471,3 +2471,3 @@\n-    \/*\n-     * This call is designed to initiate the encoder state\n-     *\/\n+        \/*\n+         * This call is designed to initiate the encoder state\n+         *\/\n@@ -2499,1 +2499,1 @@\n-    in->raw = NULL;\n+        in->raw = NULL;\n@@ -2505,1 +2505,1 @@\n-    in->closecallback(in->context);\n+        in->closecallback(in->context);\n@@ -2509,1 +2509,1 @@\n-    in->buffer = NULL;\n+        in->buffer = NULL;\n@@ -2565,1 +2565,1 @@\n-    xmlRegisterDefaultInputCallbacks();\n+        xmlRegisterDefaultInputCallbacks();\n@@ -2574,7 +2574,8 @@\n-    for (i = xmlInputCallbackNr - 1;i >= 0;i--) {\n-        if ((xmlInputCallbackTable[i].matchcallback != NULL) &&\n-        (xmlInputCallbackTable[i].matchcallback(URI) != 0)) {\n-        context = xmlInputCallbackTable[i].opencallback(URI);\n-        if (context != NULL) {\n-            break;\n-        }\n+        for (i = xmlInputCallbackNr - 1;i >= 0;i--) {\n+            if ((xmlInputCallbackTable[i].matchcallback != NULL) &&\n+                (xmlInputCallbackTable[i].matchcallback(URI) != 0)) {\n+                context = xmlInputCallbackTable[i].opencallback(URI);\n+                if (context != NULL) {\n+                    break;\n+                }\n+            }\n@@ -2583,1 +2584,0 @@\n-    }\n@@ -2585,1 +2585,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2593,3 +2593,3 @@\n-    ret->context = context;\n-    ret->readcallback = xmlInputCallbackTable[i].readcallback;\n-    ret->closecallback = xmlInputCallbackTable[i].closecallback;\n+        ret->context = context;\n+        ret->readcallback = xmlInputCallbackTable[i].readcallback;\n+        ret->closecallback = xmlInputCallbackTable[i].closecallback;\n@@ -2597,2 +2597,2 @@\n-    if ((xmlInputCallbackTable[i].opencallback == xmlGzfileOpen) &&\n-        (strcmp(URI, \"-\") != 0)) {\n+        if ((xmlInputCallbackTable[i].opencallback == xmlGzfileOpen) &&\n+                (strcmp(URI, \"-\") != 0)) {\n@@ -2602,11 +2602,11 @@\n-        if (((z_stream *)context)->avail_in > 4) {\n-            char *cptr, buff4[4];\n-        cptr = (char *) ((z_stream *)context)->next_in;\n-        if (gzread(context, buff4, 4) == 4) {\n-            if (strncmp(buff4, cptr, 4) == 0)\n-                ret->compressed = 0;\n-            else\n-                ret->compressed = 1;\n-            gzrewind(context);\n-        }\n-        }\n+            if (((z_stream *)context)->avail_in > 4) {\n+                char *cptr, buff4[4];\n+                cptr = (char *) ((z_stream *)context)->next_in;\n+                if (gzread(context, buff4, 4) == 4) {\n+                    if (strncmp(buff4, cptr, 4) == 0)\n+                        ret->compressed = 0;\n+                    else\n+                        ret->compressed = 1;\n+                    gzrewind(context);\n+                }\n+            }\n@@ -2614,1 +2614,1 @@\n-    }\n+        }\n@@ -2617,2 +2617,2 @@\n-    if ((xmlInputCallbackTable[i].opencallback == xmlXzfileOpen) &&\n-        (strcmp(URI, \"-\") != 0)) {\n+        if ((xmlInputCallbackTable[i].opencallback == xmlXzfileOpen) &&\n+                (strcmp(URI, \"-\") != 0)) {\n@@ -2620,1 +2620,1 @@\n-    }\n+        }\n@@ -2645,3 +2645,3 @@\n-        return xmlParserInputBufferCreateFilenameValue(URI, enc);\n-    }\n-    return __xmlParserInputBufferCreateFilename(URI, enc);\n+                return xmlParserInputBufferCreateFilenameValue(URI, enc);\n+        }\n+        return __xmlParserInputBufferCreateFilename(URI, enc);\n@@ -2665,1 +2665,1 @@\n-    xmlRegisterDefaultOutputCallbacks();\n+        xmlRegisterDefaultOutputCallbacks();\n@@ -2673,2 +2673,2 @@\n-        (!xmlStrEqual(BAD_CAST puri->scheme, BAD_CAST \"file\")))\n-        is_file_uri = 0;\n+            (!xmlStrEqual(BAD_CAST puri->scheme, BAD_CAST \"file\")))\n+            is_file_uri = 0;\n@@ -2676,7 +2676,7 @@\n-    \/*\n-     * try to limit the damages of the URI unescaping code.\n-     *\/\n-    if ((puri->scheme == NULL) ||\n-        (xmlStrEqual(BAD_CAST puri->scheme, BAD_CAST \"file\")))\n-        unescaped = xmlURIUnescapeString(URI, 0, NULL);\n-    xmlFreeURI(puri);\n+        \/*\n+         * try to limit the damages of the URI unescaping code.\n+         *\/\n+        if ((puri->scheme == NULL) ||\n+            (xmlStrEqual(BAD_CAST puri->scheme, BAD_CAST \"file\")))\n+            unescaped = xmlURIUnescapeString(URI, 0, NULL);\n+        xmlFreeURI(puri);\n@@ -2692,11 +2692,12 @@\n-    if ((compression > 0) && (compression <= 9) && (is_file_uri == 1)) {\n-        context = xmlGzfileOpenW(unescaped, compression);\n-        if (context != NULL) {\n-        ret = xmlAllocOutputBufferInternal(encoder);\n-        if (ret != NULL) {\n-            ret->context = context;\n-            ret->writecallback = xmlGzfileWrite;\n-            ret->closecallback = xmlGzfileClose;\n-        }\n-        xmlFree(unescaped);\n-        return(ret);\n+        if ((compression > 0) && (compression <= 9) && (is_file_uri == 1)) {\n+            context = xmlGzfileOpenW(unescaped, compression);\n+            if (context != NULL) {\n+                ret = xmlAllocOutputBufferInternal(encoder);\n+                if (ret != NULL) {\n+                    ret->context = context;\n+                    ret->writecallback = xmlGzfileWrite;\n+                    ret->closecallback = xmlGzfileClose;\n+                }\n+                xmlFree(unescaped);\n+                return(ret);\n+            }\n@@ -2704,1 +2705,0 @@\n-    }\n@@ -2706,3 +2706,3 @@\n-    for (i = xmlOutputCallbackNr - 1;i >= 0;i--) {\n-        if ((xmlOutputCallbackTable[i].matchcallback != NULL) &&\n-        (xmlOutputCallbackTable[i].matchcallback(unescaped) != 0)) {\n+        for (i = xmlOutputCallbackNr - 1;i >= 0;i--) {\n+            if ((xmlOutputCallbackTable[i].matchcallback != NULL) &&\n+                (xmlOutputCallbackTable[i].matchcallback(unescaped) != 0)) {\n@@ -2710,4 +2710,4 @@\n-        \/*  Need to pass compression parameter into HTTP open calls  *\/\n-        if (xmlOutputCallbackTable[i].matchcallback == xmlIOHTTPMatch)\n-            context = xmlIOHTTPOpenW(unescaped, compression);\n-        else\n+                \/*  Need to pass compression parameter into HTTP open calls  *\/\n+                if (xmlOutputCallbackTable[i].matchcallback == xmlIOHTTPMatch)\n+                    context = xmlIOHTTPOpenW(unescaped, compression);\n+                else\n@@ -2715,3 +2715,4 @@\n-            context = xmlOutputCallbackTable[i].opencallback(unescaped);\n-        if (context != NULL)\n-            break;\n+                    context = xmlOutputCallbackTable[i].opencallback(unescaped);\n+                if (context != NULL)\n+                    break;\n+            }\n@@ -2719,2 +2720,1 @@\n-    }\n-    xmlFree(unescaped);\n+        xmlFree(unescaped);\n@@ -2729,10 +2729,13 @@\n-    if ((compression > 0) && (compression <= 9) && (is_file_uri == 1)) {\n-        context = xmlGzfileOpenW(URI, compression);\n-        if (context != NULL) {\n-        ret = xmlAllocOutputBufferInternal(encoder);\n-        if (ret != NULL) {\n-            ret->context = context;\n-            ret->writecallback = xmlGzfileWrite;\n-            ret->closecallback = xmlGzfileClose;\n-        }\n-        return(ret);\n+        if ((compression > 0) && (compression <= 9) && (is_file_uri == 1)) {\n+            context = xmlGzfileOpenW(URI, compression);\n+            if (context != NULL) {\n+                ret = xmlAllocOutputBufferInternal(encoder);\n+                if (ret != NULL) {\n+                    ret->context = context;\n+                    ret->writecallback = xmlGzfileWrite;\n+                    ret->closecallback = xmlGzfileClose;\n+                }\n+                else\n+                    xmlGzfileClose(context);\n+                return(ret);\n+            }\n@@ -2740,1 +2743,0 @@\n-    }\n@@ -2742,3 +2744,3 @@\n-    for (i = xmlOutputCallbackNr - 1;i >= 0;i--) {\n-        if ((xmlOutputCallbackTable[i].matchcallback != NULL) &&\n-        (xmlOutputCallbackTable[i].matchcallback(URI) != 0)) {\n+        for (i = xmlOutputCallbackNr - 1;i >= 0;i--) {\n+            if ((xmlOutputCallbackTable[i].matchcallback != NULL) &&\n+                (xmlOutputCallbackTable[i].matchcallback(URI) != 0)) {\n@@ -2746,4 +2748,4 @@\n-        \/*  Need to pass compression parameter into HTTP open calls  *\/\n-        if (xmlOutputCallbackTable[i].matchcallback == xmlIOHTTPMatch)\n-            context = xmlIOHTTPOpenW(URI, compression);\n-        else\n+                \/*  Need to pass compression parameter into HTTP open calls  *\/\n+                if (xmlOutputCallbackTable[i].matchcallback == xmlIOHTTPMatch)\n+                    context = xmlIOHTTPOpenW(URI, compression);\n+                else\n@@ -2751,3 +2753,4 @@\n-            context = xmlOutputCallbackTable[i].opencallback(URI);\n-        if (context != NULL)\n-            break;\n+                    context = xmlOutputCallbackTable[i].opencallback(URI);\n+                if (context != NULL)\n+                    break;\n+            }\n@@ -2756,1 +2759,0 @@\n-    }\n@@ -2759,1 +2761,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2767,3 +2769,3 @@\n-    ret->context = context;\n-    ret->writecallback = xmlOutputCallbackTable[i].writecallback;\n-    ret->closecallback = xmlOutputCallbackTable[i].closecallback;\n+        ret->context = context;\n+        ret->writecallback = xmlOutputCallbackTable[i].writecallback;\n+        ret->closecallback = xmlOutputCallbackTable[i].closecallback;\n@@ -2794,3 +2796,3 @@\n-        return xmlOutputBufferCreateFilenameValue(URI, encoder, compression);\n-    }\n-    return __xmlOutputBufferCreateFilename(URI, encoder, compression);\n+                return xmlOutputBufferCreateFilenameValue(URI, encoder, compression);\n+        }\n+        return __xmlOutputBufferCreateFilename(URI, encoder, compression);\n@@ -2815,1 +2817,1 @@\n-    xmlRegisterDefaultInputCallbacks();\n+        xmlRegisterDefaultInputCallbacks();\n@@ -2822,2 +2824,2 @@\n-    ret->readcallback = xmlFileRead;\n-    ret->closecallback = xmlFileFlush;\n+        ret->readcallback = xmlFileRead;\n+        ret->closecallback = xmlFileFlush;\n@@ -2845,1 +2847,1 @@\n-    xmlRegisterDefaultOutputCallbacks();\n+        xmlRegisterDefaultOutputCallbacks();\n@@ -2852,2 +2854,2 @@\n-    ret->writecallback = xmlFileWrite;\n-    ret->closecallback = xmlFileFlush;\n+        ret->writecallback = xmlFileWrite;\n+        ret->closecallback = xmlFileFlush;\n@@ -2935,2 +2937,2 @@\n-    ret->readcallback = xmlFdRead;\n-    ret->closecallback = xmlFdClose;\n+        ret->readcallback = xmlFdRead;\n+        ret->closecallback = xmlFdClose;\n@@ -2964,7 +2966,7 @@\n-    ret->readcallback = xmlInputReadCallbackNop;\n-    ret->closecallback = NULL;\n-    errcode = xmlBufAdd(ret->buffer, (const xmlChar *) mem, size);\n-    if (errcode != 0) {\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n+        ret->readcallback = xmlInputReadCallbackNop;\n+        ret->closecallback = NULL;\n+        errcode = xmlBufAdd(ret->buffer, (const xmlChar *) mem, size);\n+        if (errcode != 0) {\n+            xmlFree(ret);\n+            return(NULL);\n+        }\n@@ -2999,2 +3001,2 @@\n-    xmlIOErrMemory(\"creating input buffer\");\n-    return(NULL);\n+        xmlIOErrMemory(\"creating input buffer\");\n+        return(NULL);\n@@ -3006,1 +3008,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3041,2 +3043,2 @@\n-    ret->writecallback = xmlFdWrite;\n-    ret->closecallback = NULL;\n+        ret->writecallback = xmlFdWrite;\n+        ret->closecallback = NULL;\n@@ -3063,1 +3065,1 @@\n-     xmlInputCloseCallback  ioclose, void *ioctx, xmlCharEncoding enc) {\n+         xmlInputCloseCallback  ioclose, void *ioctx, xmlCharEncoding enc) {\n@@ -3071,2 +3073,2 @@\n-    ret->readcallback = ioread;\n-    ret->closecallback = ioclose;\n+        ret->readcallback = ioread;\n+        ret->closecallback = ioclose;\n@@ -3093,2 +3095,2 @@\n-     xmlOutputCloseCallback  ioclose, void *ioctx,\n-     xmlCharEncodingHandlerPtr encoder) {\n+         xmlOutputCloseCallback  ioclose, void *ioctx,\n+         xmlCharEncodingHandlerPtr encoder) {\n@@ -3102,2 +3104,2 @@\n-    ret->writecallback = iowrite;\n-    ret->closecallback = ioclose;\n+        ret->writecallback = iowrite;\n+        ret->closecallback = ioclose;\n@@ -3123,2 +3125,2 @@\n-        old = __xmlParserInputBufferCreateFilename;\n-    }\n+                old = __xmlParserInputBufferCreateFilename;\n+        }\n@@ -3144,2 +3146,2 @@\n-        old = __xmlOutputBufferCreateFilename;\n-    }\n+                old = __xmlOutputBufferCreateFilename;\n+        }\n@@ -3166,1 +3168,1 @@\n-                     int len, const char *buf) {\n+                         int len, const char *buf) {\n@@ -3176,2 +3178,2 @@\n-     * Store the data in the incoming raw buffer\n-     *\/\n+         * Store the data in the incoming raw buffer\n+         *\/\n@@ -3179,5 +3181,5 @@\n-        in->raw = xmlBufCreate();\n-    }\n-    ret = xmlBufAdd(in->raw, (const xmlChar *) buf, len);\n-    if (ret != 0)\n-        return(-1);\n+            in->raw = xmlBufCreate();\n+        }\n+        ret = xmlBufAdd(in->raw, (const xmlChar *) buf, len);\n+        if (ret != 0)\n+            return(-1);\n@@ -3185,11 +3187,11 @@\n-    \/*\n-     * convert as much as possible to the parser reading buffer.\n-     *\/\n-    use = xmlBufUse(in->raw);\n-    nbchars = xmlCharEncInput(in, 1);\n-    if (nbchars < 0) {\n-        xmlIOErr(XML_IO_ENCODER, NULL);\n-        in->error = XML_IO_ENCODER;\n-        return(-1);\n-    }\n-    in->rawconsumed += (use - xmlBufUse(in->raw));\n+        \/*\n+         * convert as much as possible to the parser reading buffer.\n+         *\/\n+        use = xmlBufUse(in->raw);\n+        nbchars = xmlCharEncInput(in, 1);\n+        if (nbchars < 0) {\n+            xmlIOErr(XML_IO_ENCODER, NULL);\n+            in->error = XML_IO_ENCODER;\n+            return(-1);\n+        }\n+        in->rawconsumed += (use - xmlBufUse(in->raw));\n@@ -3197,1 +3199,1 @@\n-    nbchars = len;\n+        nbchars = len;\n@@ -3199,2 +3201,2 @@\n-    if (ret != 0)\n-        return(-1);\n+        if (ret != 0)\n+            return(-1);\n@@ -3204,1 +3206,1 @@\n-        \"I\/O: pushed %d chars, buffer %d\/%d\\n\",\n+            \"I\/O: pushed %d chars, buffer %d\/%d\\n\",\n@@ -3218,2 +3220,2 @@\n-        char * buffer ATTRIBUTE_UNUSED,\n-        int len ATTRIBUTE_UNUSED) {\n+            char * buffer ATTRIBUTE_UNUSED,\n+            int len ATTRIBUTE_UNUSED) {\n@@ -3249,3 +3251,3 @@\n-    xmlIOErr(XML_IO_BUFFER_FULL, NULL);\n-    in->error = XML_IO_BUFFER_FULL;\n-    return(-1);\n+        xmlIOErr(XML_IO_BUFFER_FULL, NULL);\n+        in->error = XML_IO_BUFFER_FULL;\n+        return(-1);\n@@ -3265,3 +3267,3 @@\n-    res = in->readcallback(in->context, &buffer[0], len);\n-    if (res <= 0)\n-        in->readcallback = endOfInput;\n+        res = in->readcallback(in->context, &buffer[0], len);\n+        if (res <= 0)\n+            in->readcallback = endOfInput;\n@@ -3269,3 +3271,3 @@\n-    xmlIOErr(XML_IO_NO_INPUT, NULL);\n-    in->error = XML_IO_NO_INPUT;\n-    return(-1);\n+        xmlIOErr(XML_IO_NO_INPUT, NULL);\n+        in->error = XML_IO_NO_INPUT;\n+        return(-1);\n@@ -3274,1 +3276,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3282,1 +3284,1 @@\n-    if (in->readcallback == xmlXzfileRead)\n+        if (in->readcallback == xmlXzfileRead)\n@@ -3292,2 +3294,2 @@\n-     * Store the data in the incoming raw buffer\n-     *\/\n+         * Store the data in the incoming raw buffer\n+         *\/\n@@ -3295,5 +3297,5 @@\n-        in->raw = xmlBufCreate();\n-    }\n-    res = xmlBufAdd(in->raw, (const xmlChar *) buffer, len);\n-    if (res != 0)\n-        return(-1);\n+            in->raw = xmlBufCreate();\n+        }\n+        res = xmlBufAdd(in->raw, (const xmlChar *) buffer, len);\n+        if (res != 0)\n+            return(-1);\n@@ -3301,11 +3303,11 @@\n-    \/*\n-     * convert as much as possible to the parser reading buffer.\n-     *\/\n-    use = xmlBufUse(in->raw);\n-    nbchars = xmlCharEncInput(in, 1);\n-    if (nbchars < 0) {\n-        xmlIOErr(XML_IO_ENCODER, NULL);\n-        in->error = XML_IO_ENCODER;\n-        return(-1);\n-    }\n-    in->rawconsumed += (use - xmlBufUse(in->raw));\n+        \/*\n+         * convert as much as possible to the parser reading buffer.\n+         *\/\n+        use = xmlBufUse(in->raw);\n+        nbchars = xmlCharEncInput(in, 1);\n+        if (nbchars < 0) {\n+            xmlIOErr(XML_IO_ENCODER, NULL);\n+            in->error = XML_IO_ENCODER;\n+            return(-1);\n+        }\n+        in->rawconsumed += (use - xmlBufUse(in->raw));\n@@ -3313,1 +3315,1 @@\n-    nbchars = len;\n+        nbchars = len;\n@@ -3318,1 +3320,1 @@\n-        \"I\/O: read %d chars, buffer %d\\n\",\n+            \"I\/O: read %d chars, buffer %d\\n\",\n@@ -3340,1 +3342,1 @@\n-    return(xmlParserInputBufferGrow(in, len));\n+        return(xmlParserInputBufferGrow(in, len));\n@@ -3342,1 +3344,1 @@\n-    return(0);\n+        return(0);\n@@ -3374,3 +3376,3 @@\n-    chunk = len;\n-    if (chunk > 4 * MINLEN)\n-        chunk = 4 * MINLEN;\n+        chunk = len;\n+        if (chunk > 4 * MINLEN)\n+            chunk = 4 * MINLEN;\n@@ -3378,4 +3380,0 @@\n-    \/*\n-     * first handle encoding stuff.\n-     *\/\n-    if (out->encoder != NULL) {\n@@ -3383,1 +3381,1 @@\n-         * Store the data in the incoming raw buffer\n+         * first handle encoding stuff.\n@@ -3385,6 +3383,10 @@\n-        if (out->conv == NULL) {\n-        out->conv = xmlBufCreate();\n-        }\n-        ret = xmlBufAdd(out->buffer, (const xmlChar *) buf, chunk);\n-        if (ret != 0)\n-            return(-1);\n+        if (out->encoder != NULL) {\n+            \/*\n+             * Store the data in the incoming raw buffer\n+             *\/\n+            if (out->conv == NULL) {\n+                out->conv = xmlBufCreate();\n+            }\n+            ret = xmlBufAdd(out->buffer, (const xmlChar *) buf, chunk);\n+            if (ret != 0)\n+                return(-1);\n@@ -3392,2 +3394,2 @@\n-        if ((xmlBufUse(out->buffer) < MINLEN) && (chunk == len))\n-        goto done;\n+            if ((xmlBufUse(out->buffer) < MINLEN) && (chunk == len))\n+                goto done;\n@@ -3395,8 +3397,21 @@\n-        \/*\n-         * convert as much as possible to the parser reading buffer.\n-         *\/\n-        ret = xmlCharEncOutput(out, 0);\n-        if ((ret < 0) && (ret != -3)) {\n-        xmlIOErr(XML_IO_ENCODER, NULL);\n-        out->error = XML_IO_ENCODER;\n-        return(-1);\n+            \/*\n+             * convert as much as possible to the parser reading buffer.\n+             *\/\n+            ret = xmlCharEncOutput(out, 0);\n+            if ((ret < 0) && (ret != -3)) {\n+                xmlIOErr(XML_IO_ENCODER, NULL);\n+                out->error = XML_IO_ENCODER;\n+                return(-1);\n+            }\n+            if (out->writecallback)\n+                nbchars = xmlBufUse(out->conv);\n+            else\n+                nbchars = ret >= 0 ? ret : 0;\n+        } else {\n+            ret = xmlBufAdd(out->buffer, (const xmlChar *) buf, chunk);\n+            if (ret != 0)\n+                return(-1);\n+            if (out->writecallback)\n+                nbchars = xmlBufUse(out->buffer);\n+            else\n+                nbchars = chunk;\n@@ -3404,9 +3419,2 @@\n-            nbchars = ret >= 0 ? ret : 0;\n-    } else {\n-        ret = xmlBufAdd(out->buffer, (const xmlChar *) buf, chunk);\n-        if (ret != 0)\n-            return(-1);\n-            nbchars = chunk;\n-    }\n-    buf += chunk;\n-    len -= chunk;\n+        buf += chunk;\n+        len -= chunk;\n@@ -3414,1 +3422,1 @@\n-    if (out->writecallback) {\n+        if (out->writecallback) {\n@@ -3418,5 +3426,5 @@\n-        \/*\n-         * second write the stuff to the I\/O channel\n-         *\/\n-        if (out->encoder != NULL) {\n-        ret = out->writecallback(out->context,\n+            \/*\n+             * second write the stuff to the I\/O channel\n+             *\/\n+            if (out->encoder != NULL) {\n+                ret = out->writecallback(out->context,\n@@ -3424,4 +3432,4 @@\n-        if (ret >= 0)\n-            xmlBufShrink(out->conv, ret);\n-        } else {\n-        ret = out->writecallback(out->context,\n+                if (ret >= 0)\n+                    xmlBufShrink(out->conv, ret);\n+            } else {\n+                ret = out->writecallback(out->context,\n@@ -3429,8 +3437,8 @@\n-        if (ret >= 0)\n-            xmlBufShrink(out->buffer, ret);\n-        }\n-        if (ret < 0) {\n-        xmlIOErr(XML_IO_WRITE, NULL);\n-        out->error = XML_IO_WRITE;\n-        return(ret);\n-        }\n+                if (ret >= 0)\n+                    xmlBufShrink(out->buffer, ret);\n+            }\n+            if (ret < 0) {\n+                xmlIOErr(XML_IO_WRITE, NULL);\n+                out->error = XML_IO_WRITE;\n+                return(ret);\n+            }\n@@ -3441,2 +3449,2 @@\n-    }\n-    written += nbchars;\n+        }\n+        written += nbchars;\n@@ -3448,1 +3456,1 @@\n-        \"I\/O: wrote %d chars\\n\", written);\n+            \"I\/O: wrote %d chars\\n\", written);\n@@ -3477,30 +3485,30 @@\n-    if (*in == '<') {\n-        if (outend - out < 4) break;\n-        *out++ = '&';\n-        *out++ = 'l';\n-        *out++ = 't';\n-        *out++ = ';';\n-    } else if (*in == '>') {\n-        if (outend - out < 4) break;\n-        *out++ = '&';\n-        *out++ = 'g';\n-        *out++ = 't';\n-        *out++ = ';';\n-    } else if (*in == '&') {\n-        if (outend - out < 5) break;\n-        *out++ = '&';\n-        *out++ = 'a';\n-        *out++ = 'm';\n-        *out++ = 'p';\n-        *out++ = ';';\n-    } else if (*in == '\\r') {\n-        if (outend - out < 5) break;\n-        *out++ = '&';\n-        *out++ = '#';\n-        *out++ = '1';\n-        *out++ = '3';\n-        *out++ = ';';\n-    } else {\n-        *out++ = (unsigned char) *in;\n-    }\n-    ++in;\n+        if (*in == '<') {\n+            if (outend - out < 4) break;\n+            *out++ = '&';\n+            *out++ = 'l';\n+            *out++ = 't';\n+            *out++ = ';';\n+        } else if (*in == '>') {\n+            if (outend - out < 4) break;\n+            *out++ = '&';\n+            *out++ = 'g';\n+            *out++ = 't';\n+            *out++ = ';';\n+        } else if (*in == '&') {\n+            if (outend - out < 5) break;\n+            *out++ = '&';\n+            *out++ = 'a';\n+            *out++ = 'm';\n+            *out++ = 'p';\n+            *out++ = ';';\n+        } else if (*in == '\\r') {\n+            if (outend - out < 5) break;\n+            *out++ = '&';\n+            *out++ = '#';\n+            *out++ = '1';\n+            *out++ = '3';\n+            *out++ = ';';\n+        } else {\n+            *out++ = (unsigned char) *in;\n+        }\n+        ++in;\n@@ -3541,1 +3549,1 @@\n-    (xmlBufGetAllocationScheme(out->buffer) == XML_BUFFER_ALLOC_IMMUTABLE))\n+        (xmlBufGetAllocationScheme(out->buffer) == XML_BUFFER_ALLOC_IMMUTABLE))\n@@ -3552,4 +3560,4 @@\n-     * how many bytes to consume and how many bytes to store.\n-     *\/\n-    cons = len;\n-    chunk = xmlBufAvail(out->buffer) - 1;\n+         * how many bytes to consume and how many bytes to store.\n+         *\/\n+        cons = len;\n+        chunk = xmlBufAvail(out->buffer) - 1;\n@@ -3558,6 +3566,6 @@\n-     * make sure we have enough room to save first, if this is\n-     * not the case force a flush, but make sure we stay in the loop\n-     *\/\n-    if (chunk < 40) {\n-        if (xmlBufGrow(out->buffer, 100) < 0)\n-            return(-1);\n+         * make sure we have enough room to save first, if this is\n+         * not the case force a flush, but make sure we stay in the loop\n+         *\/\n+        if (chunk < 40) {\n+            if (xmlBufGrow(out->buffer, 100) < 0)\n+                return(-1);\n@@ -3565,2 +3573,2 @@\n-        continue;\n-    }\n+            continue;\n+        }\n@@ -3568,4 +3576,0 @@\n-    \/*\n-     * first handle encoding stuff.\n-     *\/\n-    if (out->encoder != NULL) {\n@@ -3573,1 +3577,1 @@\n-         * Store the data in the incoming raw buffer\n+         * first handle encoding stuff.\n@@ -3575,7 +3579,11 @@\n-        if (out->conv == NULL) {\n-        out->conv = xmlBufCreate();\n-        }\n-        ret = escaping(xmlBufEnd(out->buffer) ,\n-                       &chunk, str, &cons);\n-        if ((ret < 0) || (chunk == 0)) \/* chunk==0 => nothing done *\/\n-            return(-1);\n+        if (out->encoder != NULL) {\n+            \/*\n+             * Store the data in the incoming raw buffer\n+             *\/\n+            if (out->conv == NULL) {\n+                out->conv = xmlBufCreate();\n+            }\n+            ret = escaping(xmlBufEnd(out->buffer) ,\n+                           &chunk, str, &cons);\n+            if ((ret < 0) || (chunk == 0)) \/* chunk==0 => nothing done *\/\n+                return(-1);\n@@ -3584,2 +3592,2 @@\n-        if ((xmlBufUse(out->buffer) < MINLEN) && (cons == len))\n-        goto done;\n+            if ((xmlBufUse(out->buffer) < MINLEN) && (cons == len))\n+                goto done;\n@@ -3587,14 +3595,17 @@\n-        \/*\n-         * convert as much as possible to the output buffer.\n-         *\/\n-        ret = xmlCharEncOutput(out, 0);\n-        if ((ret < 0) && (ret != -3)) {\n-        xmlIOErr(XML_IO_ENCODER, NULL);\n-        out->error = XML_IO_ENCODER;\n-        return(-1);\n-        }\n-            nbchars = ret >= 0 ? ret : 0;\n-    } else {\n-        ret = escaping(xmlBufEnd(out->buffer), &chunk, str, &cons);\n-        if ((ret < 0) || (chunk == 0)) \/* chunk==0 => nothing done *\/\n-            return(-1);\n+            \/*\n+             * convert as much as possible to the output buffer.\n+             *\/\n+            ret = xmlCharEncOutput(out, 0);\n+            if ((ret < 0) && (ret != -3)) {\n+                xmlIOErr(XML_IO_ENCODER, NULL);\n+                out->error = XML_IO_ENCODER;\n+                return(-1);\n+            }\n+            if (out->writecallback)\n+                nbchars = xmlBufUse(out->conv);\n+            else\n+                nbchars = ret >= 0 ? ret : 0;\n+        } else {\n+            ret = escaping(xmlBufEnd(out->buffer), &chunk, str, &cons);\n+            if ((ret < 0) || (chunk == 0)) \/* chunk==0 => nothing done *\/\n+                return(-1);\n@@ -3602,4 +3613,7 @@\n-            nbchars = chunk;\n-    }\n-    str += cons;\n-    len -= cons;\n+            if (out->writecallback)\n+                nbchars = xmlBufUse(out->buffer);\n+            else\n+                nbchars = chunk;\n+        }\n+        str += cons;\n+        len -= cons;\n@@ -3607,1 +3621,1 @@\n-    if (out->writecallback) {\n+        if (out->writecallback) {\n@@ -3611,5 +3625,5 @@\n-        \/*\n-         * second write the stuff to the I\/O channel\n-         *\/\n-        if (out->encoder != NULL) {\n-        ret = out->writecallback(out->context,\n+            \/*\n+             * second write the stuff to the I\/O channel\n+             *\/\n+            if (out->encoder != NULL) {\n+                ret = out->writecallback(out->context,\n@@ -3617,4 +3631,4 @@\n-        if (ret >= 0)\n-            xmlBufShrink(out->conv, ret);\n-        } else {\n-        ret = out->writecallback(out->context,\n+                if (ret >= 0)\n+                    xmlBufShrink(out->conv, ret);\n+            } else {\n+                ret = out->writecallback(out->context,\n@@ -3622,8 +3636,8 @@\n-        if (ret >= 0)\n-            xmlBufShrink(out->buffer, ret);\n-        }\n-        if (ret < 0) {\n-        xmlIOErr(XML_IO_WRITE, NULL);\n-        out->error = XML_IO_WRITE;\n-        return(ret);\n-        }\n+                if (ret >= 0)\n+                    xmlBufShrink(out->buffer, ret);\n+            }\n+            if (ret < 0) {\n+                xmlIOErr(XML_IO_WRITE, NULL);\n+                out->error = XML_IO_WRITE;\n+                return(ret);\n+            }\n@@ -3634,4 +3648,4 @@\n-    } else if (xmlBufAvail(out->buffer) < MINLEN) {\n-        xmlBufGrow(out->buffer, MINLEN);\n-    }\n-    written += nbchars;\n+        } else if (xmlBufAvail(out->buffer) < MINLEN) {\n+            xmlBufGrow(out->buffer, MINLEN);\n+        }\n+        written += nbchars;\n@@ -3643,1 +3657,1 @@\n-        \"I\/O: wrote %d chars\\n\", written);\n+            \"I\/O: wrote %d chars\\n\", written);\n@@ -3671,1 +3685,1 @@\n-    return(xmlOutputBufferWrite(out, len, str));\n+        return(xmlOutputBufferWrite(out, len, str));\n@@ -3692,11 +3706,11 @@\n-    \/*\n-     * convert as much as possible to the parser output buffer.\n-     *\/\n-    do {\n-        nbchars = xmlCharEncOutput(out, 0);\n-        if (nbchars < 0) {\n-        xmlIOErr(XML_IO_ENCODER, NULL);\n-        out->error = XML_IO_ENCODER;\n-        return(-1);\n-        }\n-    } while (nbchars);\n+        \/*\n+         * convert as much as possible to the parser output buffer.\n+         *\/\n+        do {\n+            nbchars = xmlCharEncOutput(out, 0);\n+            if (nbchars < 0) {\n+                xmlIOErr(XML_IO_ENCODER, NULL);\n+                out->error = XML_IO_ENCODER;\n+                return(-1);\n+            }\n+        } while (nbchars);\n@@ -3709,2 +3723,2 @@\n-    (out->writecallback != NULL)) {\n-    ret = out->writecallback(out->context,\n+        (out->writecallback != NULL)) {\n+        ret = out->writecallback(out->context,\n@@ -3713,2 +3727,2 @@\n-    if (ret >= 0)\n-        xmlBufShrink(out->conv, ret);\n+        if (ret >= 0)\n+            xmlBufShrink(out->conv, ret);\n@@ -3716,1 +3730,1 @@\n-    ret = out->writecallback(out->context,\n+        ret = out->writecallback(out->context,\n@@ -3719,2 +3733,2 @@\n-    if (ret >= 0)\n-        xmlBufShrink(out->buffer, ret);\n+        if (ret >= 0)\n+            xmlBufShrink(out->buffer, ret);\n@@ -3723,3 +3737,3 @@\n-    xmlIOErr(XML_IO_FLUSH, NULL);\n-    out->error = XML_IO_FLUSH;\n-    return(ret);\n+        xmlIOErr(XML_IO_FLUSH, NULL);\n+        out->error = XML_IO_FLUSH;\n+        return(ret);\n@@ -3734,1 +3748,1 @@\n-        \"I\/O: flushed %d chars\\n\", ret);\n+            \"I\/O: flushed %d chars\\n\", ret);\n@@ -3759,1 +3773,1 @@\n-    xmlRegisterDefaultInputCallbacks();\n+        xmlRegisterDefaultInputCallbacks();\n@@ -3774,1 +3788,1 @@\n-     cur --;\n+         cur --;\n@@ -3778,2 +3792,2 @@\n-    else *cur = 0;\n-    ret = xmlMemStrdup(dir);\n+        else *cur = 0;\n+        ret = xmlMemStrdup(dir);\n@@ -3782,3 +3796,3 @@\n-        dir[1023] = 0;\n-        ret = xmlMemStrdup(dir);\n-    }\n+            dir[1023] = 0;\n+            ret = xmlMemStrdup(dir);\n+        }\n@@ -3791,3 +3805,3 @@\n- *                              *\n- *      External entities loading           *\n- *                              *\n+ *                                                              *\n+ *              External entities loading                       *\n+ *                                                              *\n@@ -3822,2 +3836,2 @@\n-        if (ret->filename != NULL)\n-        __xmlLoaderErr(ctxt, \"failed to load HTTP resource \\\"%s\\\"\\n\",\n+            if (ret->filename != NULL)\n+                __xmlLoaderErr(ctxt, \"failed to load HTTP resource \\\"%s\\\"\\n\",\n@@ -3825,2 +3839,2 @@\n-        else\n-        __xmlLoaderErr(ctxt, \"failed to load HTTP resource\\n\", NULL);\n+            else\n+                __xmlLoaderErr(ctxt, \"failed to load HTTP resource\\n\", NULL);\n@@ -3874,1 +3888,1 @@\n-    return(0);\n+        return(0);\n@@ -3878,1 +3892,1 @@\n-    path = &URL[17];\n+        path = &URL[17];\n@@ -3880,1 +3894,1 @@\n-    path = &URL[16];\n+        path = &URL[16];\n@@ -3884,1 +3898,1 @@\n-    path = &URL[8];\n+        path = &URL[8];\n@@ -3886,1 +3900,1 @@\n-    path = &URL[7];\n+        path = &URL[7];\n@@ -3889,1 +3903,1 @@\n-    path = URL;\n+        path = URL;\n@@ -3921,28 +3935,3 @@\n-    \/*\n-     * Do a local lookup\n-     *\/\n-    if ((ctxt != NULL) && (ctxt->catalogs != NULL) &&\n-        ((pref == XML_CATA_ALLOW_ALL) ||\n-         (pref == XML_CATA_ALLOW_DOCUMENT))) {\n-        resource = xmlCatalogLocalResolve(ctxt->catalogs,\n-                          (const xmlChar *)ID,\n-                          (const xmlChar *)URL);\n-        }\n-    \/*\n-     * Try a global lookup\n-     *\/\n-    if ((resource == NULL) &&\n-        ((pref == XML_CATA_ALLOW_ALL) ||\n-         (pref == XML_CATA_ALLOW_GLOBAL))) {\n-        resource = xmlCatalogResolve((const xmlChar *)ID,\n-                     (const xmlChar *)URL);\n-    }\n-    if ((resource == NULL) && (URL != NULL))\n-        resource = xmlStrdup((const xmlChar *) URL);\n-\n-    \/*\n-     * TODO: do an URI lookup on the reference\n-     *\/\n-    if ((resource != NULL) && (!xmlNoNetExists((const char *)resource))) {\n-        xmlChar *tmp = NULL;\n-\n+        \/*\n+         * Do a local lookup\n+         *\/\n@@ -3950,3 +3939,5 @@\n-        ((pref == XML_CATA_ALLOW_ALL) ||\n-         (pref == XML_CATA_ALLOW_DOCUMENT))) {\n-        tmp = xmlCatalogLocalResolveURI(ctxt->catalogs, resource);\n+            ((pref == XML_CATA_ALLOW_ALL) ||\n+             (pref == XML_CATA_ALLOW_DOCUMENT))) {\n+            resource = xmlCatalogLocalResolve(ctxt->catalogs,\n+                                              (const xmlChar *)ID,\n+                                              (const xmlChar *)URL);\n@@ -3954,2 +3945,5 @@\n-        if ((tmp == NULL) &&\n-        ((pref == XML_CATA_ALLOW_ALL) ||\n+        \/*\n+         * Try a global lookup\n+         *\/\n+        if ((resource == NULL) &&\n+            ((pref == XML_CATA_ALLOW_ALL) ||\n@@ -3957,1 +3951,2 @@\n-        tmp = xmlCatalogResolveURI(resource);\n+            resource = xmlCatalogResolve((const xmlChar *)ID,\n+                                         (const xmlChar *)URL);\n@@ -3959,0 +3954,2 @@\n+        if ((resource == NULL) && (URL != NULL))\n+            resource = xmlStrdup((const xmlChar *) URL);\n@@ -3960,3 +3957,21 @@\n-        if (tmp != NULL) {\n-        xmlFree(resource);\n-        resource = tmp;\n+        \/*\n+         * TODO: do an URI lookup on the reference\n+         *\/\n+        if ((resource != NULL) && (!xmlNoNetExists((const char *)resource))) {\n+            xmlChar *tmp = NULL;\n+\n+            if ((ctxt != NULL) && (ctxt->catalogs != NULL) &&\n+                ((pref == XML_CATA_ALLOW_ALL) ||\n+                 (pref == XML_CATA_ALLOW_DOCUMENT))) {\n+                tmp = xmlCatalogLocalResolveURI(ctxt->catalogs, resource);\n+            }\n+            if ((tmp == NULL) &&\n+                ((pref == XML_CATA_ALLOW_ALL) ||\n+                 (pref == XML_CATA_ALLOW_GLOBAL))) {\n+                tmp = xmlCatalogResolveURI(resource);\n+            }\n+\n+            if (tmp != NULL) {\n+                xmlFree(resource);\n+                resource = tmp;\n+            }\n@@ -3965,1 +3980,0 @@\n-    }\n@@ -3996,1 +4010,1 @@\n-    ctxt->options -= XML_PARSE_NONET;\n+        ctxt->options -= XML_PARSE_NONET;\n@@ -3998,2 +4012,2 @@\n-    ctxt->options = options;\n-    return(ret);\n+        ctxt->options = options;\n+        return(ret);\n@@ -4061,2 +4075,2 @@\n-    char *canonicFilename;\n-    xmlParserInputPtr ret;\n+        char *canonicFilename;\n+        xmlParserInputPtr ret;\n@@ -4064,2 +4078,2 @@\n-    canonicFilename = (char *) xmlCanonicPath((const xmlChar *) URL);\n-    if (canonicFilename == NULL) {\n+        canonicFilename = (char *) xmlCanonicPath((const xmlChar *) URL);\n+        if (canonicFilename == NULL) {\n@@ -4067,2 +4081,2 @@\n-        return(NULL);\n-    }\n+            return(NULL);\n+        }\n@@ -4070,3 +4084,3 @@\n-    ret = xmlCurrentExternalEntityLoader(canonicFilename, ID, ctxt);\n-    xmlFree(canonicFilename);\n-    return(ret);\n+        ret = xmlCurrentExternalEntityLoader(canonicFilename, ID, ctxt);\n+        xmlFree(canonicFilename);\n+        return(ret);\n@@ -4078,3 +4092,3 @@\n- *                                  *\n- *      Disabling Network access                *\n- *                                  *\n+ *                                                                      *\n+ *              Disabling Network access                                *\n+ *                                                                      *\n@@ -4105,1 +4119,1 @@\n-    resource = (xmlChar *) URL;\n+        resource = (xmlChar *) URL;\n@@ -4111,4 +4125,4 @@\n-        if (resource != (xmlChar *) URL)\n-        xmlFree(resource);\n-        return(NULL);\n-    }\n+            if (resource != (xmlChar *) URL)\n+                xmlFree(resource);\n+            return(NULL);\n+        }\n@@ -4118,1 +4132,1 @@\n-    xmlFree(resource);\n+        xmlFree(resource);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlIO.c","additions":856,"deletions":842,"binary":false,"changes":1698,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-#include <libxml\/globals.h> \/* must come before xmlmemory.h *\/\n+#include <libxml\/globals.h>     \/* must come before xmlmemory.h *\/\n@@ -60,3 +60,3 @@\n- *                                  *\n- *      Macros, variables and associated types          *\n- *                                  *\n+ *                                                                      *\n+ *              Macros, variables and associated types                  *\n+ *                                                                      *\n@@ -81,1 +81,1 @@\n-#define MEMTAG 0x5aa5\n+#define MEMTAG 0x5aa5U\n@@ -110,1 +110,1 @@\n-              \/ ALIGN_SIZE ) * ALIGN_SIZE)\n+                      \/ ALIGN_SIZE ) * ALIGN_SIZE)\n@@ -147,1 +147,1 @@\n-        \"xmlMallocBreakpoint reached on block %d\\n\", xmlMemStopAtBlock);\n+            \"xmlMallocBreakpoint reached on block %d\\n\", xmlMemStopAtBlock);\n@@ -170,1 +170,1 @@\n-        \"Malloc(%d)\\n\",size);\n+            \"Malloc(%d)\\n\",size);\n@@ -176,4 +176,4 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"xmlMallocLoc : Unsigned overflow\\n\");\n-    xmlMemoryDump();\n-    return(NULL);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"xmlMallocLoc : Unsigned overflow\\n\");\n+        xmlMemoryDump();\n+        return(NULL);\n@@ -185,4 +185,4 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"xmlMallocLoc : Out of free space\\n\");\n-    xmlMemoryDump();\n-    return(NULL);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"xmlMallocLoc : Out of free space\\n\");\n+        xmlMemoryDump();\n+        return(NULL);\n@@ -207,1 +207,1 @@\n-        \"Malloc(%d) Ok\\n\",size);\n+            \"Malloc(%d) Ok\\n\",size);\n@@ -215,4 +215,4 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"%p : Malloc(%lu) Ok\\n\", xmlMemTraceBlockAt,\n-            (long unsigned)size);\n-    xmlMallocBreakpoint();\n+        xmlGenericError(xmlGenericErrorContext,\n+                        \"%p : Malloc(%lu) Ok\\n\", xmlMemTraceBlockAt,\n+                        (long unsigned)size);\n+        xmlMallocBreakpoint();\n@@ -246,1 +246,1 @@\n-        \"Malloc(%d)\\n\",size);\n+            \"Malloc(%d)\\n\",size);\n@@ -252,4 +252,4 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"xmlMallocAtomicLoc : Unsigned overflow\\n\");\n-    xmlMemoryDump();\n-    return(NULL);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"xmlMallocAtomicLoc : Unsigned overflow\\n\");\n+        xmlMemoryDump();\n+        return(NULL);\n@@ -261,4 +261,4 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"xmlMallocAtomicLoc : Out of free space\\n\");\n-    xmlMemoryDump();\n-    return(NULL);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"xmlMallocAtomicLoc : Out of free space\\n\");\n+        xmlMemoryDump();\n+        return(NULL);\n@@ -283,1 +283,1 @@\n-        \"Malloc(%d) Ok\\n\",size);\n+            \"Malloc(%d) Ok\\n\",size);\n@@ -291,4 +291,4 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"%p : Malloc(%lu) Ok\\n\", xmlMemTraceBlockAt,\n-            (long unsigned)size);\n-    xmlMallocBreakpoint();\n+        xmlGenericError(xmlGenericErrorContext,\n+                        \"%p : Malloc(%lu) Ok\\n\", xmlMemTraceBlockAt,\n+                        (long unsigned)size);\n+        xmlMallocBreakpoint();\n@@ -348,1 +348,1 @@\n-     goto error;\n+         goto error;\n@@ -363,4 +363,4 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"xmlReallocLoc : Unsigned overflow\\n\");\n-    xmlMemoryDump();\n-    return(NULL);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"xmlReallocLoc : Unsigned overflow\\n\");\n+        xmlMemoryDump();\n+        return(NULL);\n@@ -371,2 +371,2 @@\n-     free(p);\n-     goto error;\n+         free(p);\n+         goto error;\n@@ -376,5 +376,5 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"%p : Realloced(%lu -> %lu) Ok\\n\",\n-            xmlMemTraceBlockAt, (long unsigned)p->mh_size,\n-            (long unsigned)size);\n-    xmlMallocBreakpoint();\n+        xmlGenericError(xmlGenericErrorContext,\n+                        \"%p : Realloced(%lu -> %lu) Ok\\n\",\n+                        xmlMemTraceBlockAt, (long unsigned)p->mh_size,\n+                        (long unsigned)size);\n+        xmlMallocBreakpoint();\n@@ -401,1 +401,1 @@\n-        \"Realloced(%d to %d) Ok\\n\", oldsize, size);\n+            \"Realloced(%d to %d) Ok\\n\", oldsize, size);\n@@ -440,1 +440,1 @@\n-    return;\n+        return;\n@@ -443,2 +443,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"trying to free pointer from freed area\\n\");\n+        xmlGenericError(xmlGenericErrorContext,\n+            \"trying to free pointer from freed area\\n\");\n@@ -449,3 +449,3 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"%p : Freed()\\n\", xmlMemTraceBlockAt);\n-    xmlMallocBreakpoint();\n+        xmlGenericError(xmlGenericErrorContext,\n+                        \"%p : Freed()\\n\", xmlMemTraceBlockAt);\n+        xmlMallocBreakpoint();\n@@ -483,1 +483,1 @@\n-        \"Freed(%d) Ok\\n\", size);\n+            \"Freed(%d) Ok\\n\", size);\n@@ -490,1 +490,1 @@\n-        \"xmlMemFree(%p) error\\n\", ptr);\n+            \"xmlMemFree(%p) error\\n\", ptr);\n@@ -517,4 +517,4 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"xmlMemStrdupLoc : Unsigned overflow\\n\");\n-    xmlMemoryDump();\n-    return(NULL);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"xmlMemStrdupLoc : Unsigned overflow\\n\");\n+        xmlMemoryDump();\n+        return(NULL);\n@@ -551,3 +551,3 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-            \"%p : Strdup() Ok\\n\", xmlMemTraceBlockAt);\n-    xmlMallocBreakpoint();\n+        xmlGenericError(xmlGenericErrorContext,\n+                        \"%p : Strdup() Ok\\n\", xmlMemTraceBlockAt);\n+        xmlMallocBreakpoint();\n@@ -628,2 +628,2 @@\n-    fprintf(fp, \" NULL\");\n-    return;\n+        fprintf(fp, \" NULL\");\n+        return;\n@@ -636,1 +636,1 @@\n-    if (!isprint((unsigned char) buf[i])) break;\n+        if (!isprint((unsigned char) buf[i])) break;\n@@ -640,2 +640,2 @@\n-        MEMHDR *q;\n-        void *cur;\n+            MEMHDR *q;\n+            void *cur;\n@@ -644,14 +644,15 @@\n-        cur = *((void **) &buf[j]);\n-        q = CLIENT_2_HDR(cur);\n-        p = memlist;\n-        k = 0;\n-        while (p != NULL) {\n-            if (p == q) break;\n-            p = p->mh_next;\n-            if (k++ > 100) break;\n-        }\n-        if ((p != NULL) && (p == q)) {\n-            fprintf(fp, \" pointer to #%lu at index %d\",\n-                    p->mh_number, j);\n-            return;\n-        }\n+                cur = *((void **) &buf[j]);\n+                q = CLIENT_2_HDR(cur);\n+                p = memlist;\n+                k = 0;\n+                while (p != NULL) {\n+                    if (p == q) break;\n+                    p = p->mh_next;\n+                    if (k++ > 100) break;\n+                }\n+                if ((p != NULL) && (p == q)) {\n+                    fprintf(fp, \" pointer to #%lu at index %d\",\n+                            p->mh_number, j);\n+                    return;\n+                }\n+            }\n@@ -659,1 +660,0 @@\n-    }\n@@ -664,1 +664,1 @@\n-    else {\n+        else {\n@@ -666,1 +666,1 @@\n-        for (j = 0;j < i;j++)\n+            for (j = 0;j < i;j++)\n@@ -669,1 +669,1 @@\n-    }\n+        }\n@@ -698,3 +698,3 @@\n-    fp = fopen(\".memorylist\", \"w\");\n-    if (fp == NULL)\n-        return;\n+        fp = fopen(\".memorylist\", \"w\");\n+        if (fp == NULL)\n+            return;\n@@ -711,2 +711,2 @@\n-      fprintf(fp,\"%-5u  %6lu %6lu \",idx++,p->mh_number,\n-          (unsigned long)p->mh_size);\n+          fprintf(fp,\"%-5u  %6lu %6lu \",idx++,p->mh_number,\n+                  (unsigned long)p->mh_size);\n@@ -720,5 +720,5 @@\n-            fprintf(fp,\"Unknown memory block, may be corrupted\");\n-        xmlMutexUnlock(xmlMemMutex);\n-        if (old_fp == NULL)\n-            fclose(fp);\n-        return;\n+                fprintf(fp,\"Unknown memory block, may be corrupted\");\n+                xmlMutexUnlock(xmlMemMutex);\n+                if (old_fp == NULL)\n+                    fclose(fp);\n+                return;\n@@ -726,1 +726,1 @@\n-    if (p->mh_file != NULL) fprintf(fp,\"%s(%u)\", p->mh_file, p->mh_line);\n+        if (p->mh_file != NULL) fprintf(fp,\"%s(%u)\", p->mh_file, p->mh_line);\n@@ -728,1 +728,1 @@\n-          fprintf(fp,\"  INVALID\");\n+              fprintf(fp,\"  INVALID\");\n@@ -730,4 +730,4 @@\n-    if (nb < 100)\n-        xmlMemContentShow(fp, p);\n-    else\n-        fprintf(fp,\" skip\");\n+        if (nb < 100)\n+            xmlMemContentShow(fp, p);\n+        else\n+            fprintf(fp,\" skip\");\n@@ -736,1 +736,1 @@\n-    nbBytes -= (unsigned long)p->mh_size;\n+        nbBytes -= (unsigned long)p->mh_size;\n@@ -744,1 +744,1 @@\n-    fclose(fp);\n+        fclose(fp);\n@@ -771,3 +771,3 @@\n-    fp = fopen(\".memorylist\", \"w\");\n-    if (fp == NULL)\n-        return;\n+        fp = fopen(\".memorylist\", \"w\");\n+        if (fp == NULL)\n+            return;\n@@ -792,2 +792,2 @@\n-      fprintf(fp,\"%-5u  %6lu %6lu \",idx++,p->mh_number,\n-          (unsigned long)p->mh_size);\n+          fprintf(fp,\"%-5u  %6lu %6lu \",idx++,p->mh_number,\n+                  (unsigned long)p->mh_size);\n@@ -801,5 +801,5 @@\n-            fprintf(fp,\"Unknown memory block, may be corrupted\");\n-        xmlMutexUnlock(xmlMemMutex);\n-        if (old_fp == NULL)\n-            fclose(fp);\n-        return;\n+                fprintf(fp,\"Unknown memory block, may be corrupted\");\n+                xmlMutexUnlock(xmlMemMutex);\n+                if (old_fp == NULL)\n+                    fclose(fp);\n+                return;\n@@ -807,1 +807,1 @@\n-    if (p->mh_file != NULL) fprintf(fp,\"%s(%u)\", p->mh_file, p->mh_line);\n+        if (p->mh_file != NULL) fprintf(fp,\"%s(%u)\", p->mh_file, p->mh_line);\n@@ -809,1 +809,1 @@\n-          fprintf(fp,\"  INVALID\");\n+              fprintf(fp,\"  INVALID\");\n@@ -811,4 +811,4 @@\n-    if (nb < 100)\n-        xmlMemContentShow(fp, p);\n-    else\n-        fprintf(fp,\" skip\");\n+        if (nb < 100)\n+            xmlMemContentShow(fp, p);\n+        else\n+            fprintf(fp,\" skip\");\n@@ -824,1 +824,1 @@\n-    fclose(fp);\n+        fclose(fp);\n@@ -865,1 +865,1 @@\n-         \"Memory tag error occurs :%p \\n\\t bye\\n\", p);\n+             \"Memory tag error occurs :%p \\n\\t bye\\n\", p);\n@@ -893,2 +893,2 @@\n-    fprintf(fp,\"      MEMORY ALLOCATED : %lu, MAX was %lu\\n\",\n-        debugMemSize, debugMaxMemSize);\n+        fprintf(fp,\"      MEMORY ALLOCATED : %lu, MAX was %lu\\n\",\n+                debugMemSize, debugMaxMemSize);\n@@ -898,11 +898,20 @@\n-    fprintf(fp,\"NUMBER   SIZE  TYPE   WHERE\\n\");\n-    p = memlist;\n-    while ((p) && nr > 0) {\n-          fprintf(fp,\"%6lu %6lu \",p->mh_number,(unsigned long)p->mh_size);\n-        switch (p->mh_type) {\n-           case STRDUP_TYPE:fprintf(fp,\"strdup()  in \");break;\n-           case MALLOC_TYPE:fprintf(fp,\"malloc()  in \");break;\n-           case MALLOC_ATOMIC_TYPE:fprintf(fp,\"atomicmalloc()  in \");break;\n-          case REALLOC_TYPE:fprintf(fp,\"realloc() in \");break;\n-          case REALLOC_ATOMIC_TYPE:fprintf(fp,\"atomicrealloc() in \");break;\n-        default:fprintf(fp,\"   ???    in \");break;\n+        fprintf(fp,\"NUMBER   SIZE  TYPE   WHERE\\n\");\n+        p = memlist;\n+        while ((p) && nr > 0) {\n+              fprintf(fp,\"%6lu %6lu \",p->mh_number,(unsigned long)p->mh_size);\n+            switch (p->mh_type) {\n+               case STRDUP_TYPE:fprintf(fp,\"strdup()  in \");break;\n+               case MALLOC_TYPE:fprintf(fp,\"malloc()  in \");break;\n+               case MALLOC_ATOMIC_TYPE:fprintf(fp,\"atomicmalloc()  in \");break;\n+              case REALLOC_TYPE:fprintf(fp,\"realloc() in \");break;\n+              case REALLOC_ATOMIC_TYPE:fprintf(fp,\"atomicrealloc() in \");break;\n+                default:fprintf(fp,\"   ???    in \");break;\n+            }\n+            if (p->mh_file != NULL)\n+                fprintf(fp,\"%s(%u)\", p->mh_file, p->mh_line);\n+            if (p->mh_tag != MEMTAG)\n+                fprintf(fp,\"  INVALID\");\n+            xmlMemContentShow(fp, p);\n+            fprintf(fp,\"\\n\");\n+            nr--;\n+            p = p->mh_next;\n@@ -910,9 +919,0 @@\n-        if (p->mh_file != NULL)\n-            fprintf(fp,\"%s(%u)\", p->mh_file, p->mh_line);\n-        if (p->mh_tag != MEMTAG)\n-        fprintf(fp,\"  INVALID\");\n-        xmlMemContentShow(fp, p);\n-        fprintf(fp,\"\\n\");\n-        nr--;\n-        p = p->mh_next;\n-    }\n@@ -937,1 +937,1 @@\n-    return;\n+        return;\n@@ -940,1 +940,1 @@\n-    xmlMemoryDumpFile = stderr;\n+        xmlMemoryDumpFile = stderr;\n@@ -951,3 +951,3 @@\n- *                              *\n- *      Initialization Routines             *\n- *                              *\n+ *                                                              *\n+ *              Initialization Routines                         *\n+ *                                                              *\n@@ -971,1 +971,1 @@\n-         \"xmlInitMemory()\\n\");\n+             \"xmlInitMemory()\\n\");\n@@ -996,1 +996,1 @@\n-         \"xmlInitMemory() Ok\\n\");\n+             \"xmlInitMemory() Ok\\n\");\n@@ -1011,1 +1011,1 @@\n-         \"xmlCleanupMemory()\\n\");\n+             \"xmlCleanupMemory()\\n\");\n@@ -1021,1 +1021,1 @@\n-         \"xmlCleanupMemory() Ok\\n\");\n+             \"xmlCleanupMemory() Ok\\n\");\n@@ -1045,1 +1045,1 @@\n-         \"xmlMemSetup()\\n\");\n+             \"xmlMemSetup()\\n\");\n@@ -1048,1 +1048,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1050,1 +1050,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1052,1 +1052,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1054,1 +1054,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1062,1 +1062,1 @@\n-         \"xmlMemSetup() Ok\\n\");\n+             \"xmlMemSetup() Ok\\n\");\n@@ -1080,1 +1080,1 @@\n-      xmlReallocFunc *reallocFunc, xmlStrdupFunc *strdupFunc) {\n+          xmlReallocFunc *reallocFunc, xmlStrdupFunc *strdupFunc) {\n@@ -1109,1 +1109,1 @@\n-          xmlStrdupFunc strdupFunc) {\n+              xmlStrdupFunc strdupFunc) {\n@@ -1112,1 +1112,1 @@\n-         \"xmlGcMemSetup()\\n\");\n+             \"xmlGcMemSetup()\\n\");\n@@ -1115,1 +1115,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1117,1 +1117,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1119,1 +1119,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1121,1 +1121,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1123,1 +1123,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1131,1 +1131,1 @@\n-         \"xmlGcMemSetup() Ok\\n\");\n+             \"xmlGcMemSetup() Ok\\n\");\n@@ -1153,1 +1153,1 @@\n-        xmlStrdupFunc *strdupFunc) {\n+            xmlStrdupFunc *strdupFunc) {\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlmemory.c","additions":169,"deletions":169,"binary":false,"changes":338,"status":"modified"},{"patch":"@@ -89,3 +89,3 @@\n-#define TODO                                \\\n-    xmlGenericError(xmlGenericErrorContext,             \\\n-        \"Unimplemented block at %s:%d\\n\",               \\\n+#define TODO                                                            \\\n+    xmlGenericError(xmlGenericErrorContext,                             \\\n+            \"Unimplemented block at %s:%d\\n\",                           \\\n@@ -102,4 +102,4 @@\n- *                                  *\n- *  The parser: maps the Text Reader API on top of the existing *\n- *      parsing routines building a tree            *\n- *                                  *\n+ *                                                                      *\n+ *      The parser: maps the Text Reader API on top of the existing     *\n+ *              parsing routines building a tree                        *\n+ *                                                                      *\n@@ -109,1 +109,1 @@\n-#define XML_TEXTREADER_CTXT 2\n+#define XML_TEXTREADER_CTXT     2\n@@ -130,2 +130,2 @@\n-    int             mode;   \/* the parsing mode *\/\n-    xmlDocPtr           doc;    \/* when walking an existing doc *\/\n+    int                         mode;   \/* the parsing mode *\/\n+    xmlDocPtr                   doc;    \/* when walking an existing doc *\/\n@@ -133,20 +133,20 @@\n-    int             allocs; \/* what structure were deallocated *\/\n-    xmlTextReaderState      state;\n-    xmlParserCtxtPtr        ctxt;   \/* the parser context *\/\n-    xmlSAXHandlerPtr        sax;    \/* the parser SAX callbacks *\/\n-    xmlParserInputBufferPtr input;  \/* the input *\/\n-    startElementSAXFunc     startElement;\/* initial SAX callbacks *\/\n-    endElementSAXFunc       endElement;  \/* idem *\/\n-    startElementNsSAX2Func  startElementNs;\/* idem *\/\n-    endElementNsSAX2Func    endElementNs;  \/* idem *\/\n-    charactersSAXFunc       characters;\n-    cdataBlockSAXFunc       cdataBlock;\n-    unsigned int        base;   \/* base of the segment in the input *\/\n-    unsigned int        cur;    \/* current position in the input *\/\n-    xmlNodePtr          node;   \/* current node *\/\n-    xmlNodePtr          curnode;\/* current attribute node *\/\n-    int             depth;  \/* depth of the current node *\/\n-    xmlNodePtr          faketext;\/* fake xmlNs chld *\/\n-    int             preserve;\/* preserve the resulting document *\/\n-    xmlBufPtr               buffer; \/* used to return const xmlChar * *\/\n-    xmlDictPtr          dict;   \/* the context dictionary *\/\n+    int                         allocs; \/* what structure were deallocated *\/\n+    xmlTextReaderState          state;\n+    xmlParserCtxtPtr            ctxt;   \/* the parser context *\/\n+    xmlSAXHandlerPtr            sax;    \/* the parser SAX callbacks *\/\n+    xmlParserInputBufferPtr     input;  \/* the input *\/\n+    startElementSAXFunc         startElement;\/* initial SAX callbacks *\/\n+    endElementSAXFunc           endElement;  \/* idem *\/\n+    startElementNsSAX2Func      startElementNs;\/* idem *\/\n+    endElementNsSAX2Func        endElementNs;  \/* idem *\/\n+    charactersSAXFunc           characters;\n+    cdataBlockSAXFunc           cdataBlock;\n+    unsigned int                base;   \/* base of the segment in the input *\/\n+    unsigned int                cur;    \/* current position in the input *\/\n+    xmlNodePtr                  node;   \/* current node *\/\n+    xmlNodePtr                  curnode;\/* current attribute node *\/\n+    int                         depth;  \/* depth of the current node *\/\n+    xmlNodePtr                  faketext;\/* fake xmlNs chld *\/\n+    int                         preserve;\/* preserve the resulting document *\/\n+    xmlBufPtr                   buffer; \/* used to return const xmlChar * *\/\n+    xmlDictPtr                  dict;   \/* the context dictionary *\/\n@@ -176,1 +176,1 @@\n-    xmlSchemaSAXPlugPtr   xsdPlug;  \/* the schemas plug in SAX pipeline *\/\n+    xmlSchemaSAXPlugPtr   xsdPlug;      \/* the schemas plug in SAX pipeline *\/\n@@ -180,1 +180,1 @@\n-    int                xinclude;    \/* is xinclude asked for *\/\n+    int                xinclude;        \/* is xinclude asked for *\/\n@@ -182,2 +182,2 @@\n-    xmlXIncludeCtxtPtr xincctxt;    \/* the xinclude context *\/\n-    int                in_xinclude; \/* counts for xinclude *\/\n+    xmlXIncludeCtxtPtr xincctxt;        \/* the xinclude context *\/\n+    int                in_xinclude;     \/* counts for xinclude *\/\n@@ -190,2 +190,2 @@\n-    int                preserves;   \/* level of preserves *\/\n-    int                parserFlags; \/* the set of options set *\/\n+    int                preserves;       \/* level of preserves *\/\n+    int                parserFlags;     \/* the set of options set *\/\n@@ -196,3 +196,3 @@\n-#define NODE_IS_EMPTY       0x1\n-#define NODE_IS_PRESERVED   0x2\n-#define NODE_IS_SPRESERVED  0x4\n+#define NODE_IS_EMPTY           0x1\n+#define NODE_IS_PRESERVED       0x2\n+#define NODE_IS_SPRESERVED      0x4\n@@ -212,3 +212,3 @@\n- *                                  *\n- *  Our own version of the freeing routines as we recycle nodes *\n- *                                  *\n+ *                                                                      *\n+ *      Our own version of the freeing routines as we recycle nodes     *\n+ *                                                                      *\n@@ -223,4 +223,4 @@\n-#define DICT_FREE(str)                      \\\n-    if ((str) && ((!dict) ||                \\\n-        (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \\\n-        xmlFree((char *)(str));\n+#define DICT_FREE(str)                                          \\\n+        if ((str) && ((!dict) ||                                \\\n+            (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \\\n+            xmlFree((char *)(str));\n@@ -247,1 +247,1 @@\n-    DICT_FREE(id->value)\n+        DICT_FREE(id->value)\n@@ -249,1 +249,1 @@\n-    DICT_FREE(id->name)\n+        DICT_FREE(id->name)\n@@ -276,1 +276,1 @@\n-    return(-1);\n+        return(-1);\n@@ -280,1 +280,1 @@\n-    return(-1);\n+        return(-1);\n@@ -353,1 +353,1 @@\n-    dict = reader->ctxt->dict;\n+        dict = reader->ctxt->dict;\n@@ -359,1 +359,1 @@\n-    xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);\n+        xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);\n@@ -364,3 +364,3 @@\n-        xmlTextReaderRemoveID(cur->parent->doc, cur);\n-    if (((cur->parent->doc->intSubset != NULL) ||\n-         (cur->parent->doc->extSubset != NULL)) &&\n+            xmlTextReaderRemoveID(cur->parent->doc, cur);\n+        if (((cur->parent->doc->intSubset != NULL) ||\n+             (cur->parent->doc->extSubset != NULL)) &&\n@@ -377,2 +377,2 @@\n-    reader->ctxt->freeAttrs = cur;\n-    reader->ctxt->freeAttrsNr++;\n+        reader->ctxt->freeAttrs = cur;\n+        reader->ctxt->freeAttrsNr++;\n@@ -380,1 +380,1 @@\n-    xmlFree(cur);\n+        xmlFree(cur);\n@@ -398,1 +398,1 @@\n-    cur = next;\n+        cur = next;\n@@ -418,1 +418,1 @@\n-    dict = reader->ctxt->dict;\n+        dict = reader->ctxt->dict;\n@@ -423,2 +423,2 @@\n-    xmlFreeNsList((xmlNsPtr) cur);\n-    return;\n+        xmlFreeNsList((xmlNsPtr) cur);\n+        return;\n@@ -427,3 +427,3 @@\n-    (cur->type == XML_HTML_DOCUMENT_NODE)) {\n-    xmlFreeDoc((xmlDocPtr) cur);\n-    return;\n+        (cur->type == XML_HTML_DOCUMENT_NODE)) {\n+        xmlFreeDoc((xmlDocPtr) cur);\n+        return;\n@@ -443,39 +443,40 @@\n-    \/* unroll to speed up freeing the document *\/\n-    if (cur->type != XML_DTD_NODE) {\n-\n-        if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n-        xmlDeregisterNodeDefaultValue(cur);\n-\n-        if (((cur->type == XML_ELEMENT_NODE) ||\n-         (cur->type == XML_XINCLUDE_START) ||\n-         (cur->type == XML_XINCLUDE_END)) &&\n-        (cur->properties != NULL))\n-        xmlTextReaderFreePropList(reader, cur->properties);\n-        if ((cur->content != (xmlChar *) &(cur->properties)) &&\n-            (cur->type != XML_ELEMENT_NODE) &&\n-        (cur->type != XML_XINCLUDE_START) &&\n-        (cur->type != XML_XINCLUDE_END) &&\n-        (cur->type != XML_ENTITY_REF_NODE)) {\n-        DICT_FREE(cur->content);\n-        }\n-        if (((cur->type == XML_ELEMENT_NODE) ||\n-             (cur->type == XML_XINCLUDE_START) ||\n-         (cur->type == XML_XINCLUDE_END)) &&\n-        (cur->nsDef != NULL))\n-        xmlFreeNsList(cur->nsDef);\n-\n-        \/*\n-         * we don't free element names here they are interned now\n-         *\/\n-        if ((cur->type != XML_TEXT_NODE) &&\n-        (cur->type != XML_COMMENT_NODE))\n-        DICT_FREE(cur->name);\n-        if (((cur->type == XML_ELEMENT_NODE) ||\n-         (cur->type == XML_TEXT_NODE)) &&\n-            (reader != NULL) && (reader->ctxt != NULL) &&\n-        (reader->ctxt->freeElemsNr < MAX_FREE_NODES)) {\n-            cur->next = reader->ctxt->freeElems;\n-        reader->ctxt->freeElems = cur;\n-        reader->ctxt->freeElemsNr++;\n-        } else {\n-        xmlFree(cur);\n+        \/* unroll to speed up freeing the document *\/\n+        if (cur->type != XML_DTD_NODE) {\n+\n+            if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n+                xmlDeregisterNodeDefaultValue(cur);\n+\n+            if (((cur->type == XML_ELEMENT_NODE) ||\n+                 (cur->type == XML_XINCLUDE_START) ||\n+                 (cur->type == XML_XINCLUDE_END)) &&\n+                (cur->properties != NULL))\n+                xmlTextReaderFreePropList(reader, cur->properties);\n+            if ((cur->content != (xmlChar *) &(cur->properties)) &&\n+                (cur->type != XML_ELEMENT_NODE) &&\n+                (cur->type != XML_XINCLUDE_START) &&\n+                (cur->type != XML_XINCLUDE_END) &&\n+                (cur->type != XML_ENTITY_REF_NODE)) {\n+                DICT_FREE(cur->content);\n+            }\n+            if (((cur->type == XML_ELEMENT_NODE) ||\n+                 (cur->type == XML_XINCLUDE_START) ||\n+                 (cur->type == XML_XINCLUDE_END)) &&\n+                (cur->nsDef != NULL))\n+                xmlFreeNsList(cur->nsDef);\n+\n+            \/*\n+             * we don't free element names here they are interned now\n+             *\/\n+            if ((cur->type != XML_TEXT_NODE) &&\n+                (cur->type != XML_COMMENT_NODE))\n+                DICT_FREE(cur->name);\n+            if (((cur->type == XML_ELEMENT_NODE) ||\n+                 (cur->type == XML_TEXT_NODE)) &&\n+                (reader != NULL) && (reader->ctxt != NULL) &&\n+                (reader->ctxt->freeElemsNr < MAX_FREE_NODES)) {\n+                cur->next = reader->ctxt->freeElems;\n+                reader->ctxt->freeElems = cur;\n+                reader->ctxt->freeElemsNr++;\n+            } else {\n+                xmlFree(cur);\n+            }\n@@ -483,1 +484,0 @@\n-    }\n@@ -486,1 +486,1 @@\n-        cur = next;\n+            cur = next;\n@@ -510,1 +510,1 @@\n-    dict = reader->ctxt->dict;\n+        dict = reader->ctxt->dict;\n@@ -514,2 +514,2 @@\n-    xmlFreeDtd((xmlDtdPtr) cur);\n-    return;\n+        xmlFreeDtd((xmlDtdPtr) cur);\n+        return;\n@@ -518,1 +518,1 @@\n-    xmlFreeNs((xmlNsPtr) cur);\n+        xmlFreeNs((xmlNsPtr) cur);\n@@ -522,2 +522,2 @@\n-    xmlTextReaderFreeProp(reader, (xmlAttrPtr) cur);\n-    return;\n+        xmlTextReaderFreeProp(reader, (xmlAttrPtr) cur);\n+        return;\n@@ -527,4 +527,4 @@\n-    (cur->type != XML_ENTITY_REF_NODE)) {\n-    if (cur->children->parent == cur)\n-        xmlTextReaderFreeNodeList(reader, cur->children);\n-    cur->children = NULL;\n+        (cur->type != XML_ENTITY_REF_NODE)) {\n+        if (cur->children->parent == cur)\n+            xmlTextReaderFreeNodeList(reader, cur->children);\n+        cur->children = NULL;\n@@ -534,1 +534,1 @@\n-    xmlDeregisterNodeDefaultValue(cur);\n+        xmlDeregisterNodeDefaultValue(cur);\n@@ -537,4 +537,4 @@\n-     (cur->type == XML_XINCLUDE_START) ||\n-     (cur->type == XML_XINCLUDE_END)) &&\n-    (cur->properties != NULL))\n-    xmlTextReaderFreePropList(reader, cur->properties);\n+         (cur->type == XML_XINCLUDE_START) ||\n+         (cur->type == XML_XINCLUDE_END)) &&\n+        (cur->properties != NULL))\n+        xmlTextReaderFreePropList(reader, cur->properties);\n@@ -543,4 +543,4 @@\n-    (cur->type != XML_XINCLUDE_START) &&\n-    (cur->type != XML_XINCLUDE_END) &&\n-    (cur->type != XML_ENTITY_REF_NODE)) {\n-    DICT_FREE(cur->content);\n+        (cur->type != XML_XINCLUDE_START) &&\n+        (cur->type != XML_XINCLUDE_END) &&\n+        (cur->type != XML_ENTITY_REF_NODE)) {\n+        DICT_FREE(cur->content);\n@@ -549,4 +549,4 @@\n-     (cur->type == XML_XINCLUDE_START) ||\n-     (cur->type == XML_XINCLUDE_END)) &&\n-    (cur->nsDef != NULL))\n-    xmlFreeNsList(cur->nsDef);\n+         (cur->type == XML_XINCLUDE_START) ||\n+         (cur->type == XML_XINCLUDE_END)) &&\n+        (cur->nsDef != NULL))\n+        xmlFreeNsList(cur->nsDef);\n@@ -559,1 +559,1 @@\n-    DICT_FREE(cur->name);\n+        DICT_FREE(cur->name);\n@@ -562,6 +562,6 @@\n-     (cur->type == XML_TEXT_NODE)) &&\n-    (reader != NULL) && (reader->ctxt != NULL) &&\n-    (reader->ctxt->freeElemsNr < MAX_FREE_NODES)) {\n-    cur->next = reader->ctxt->freeElems;\n-    reader->ctxt->freeElems = cur;\n-    reader->ctxt->freeElemsNr++;\n+         (cur->type == XML_TEXT_NODE)) &&\n+        (reader != NULL) && (reader->ctxt != NULL) &&\n+        (reader->ctxt->freeElemsNr < MAX_FREE_NODES)) {\n+        cur->next = reader->ctxt->freeElems;\n+        reader->ctxt->freeElems = cur;\n+        reader->ctxt->freeElemsNr++;\n@@ -569,1 +569,1 @@\n-    xmlFree(cur);\n+        xmlFree(cur);\n@@ -603,1 +603,1 @@\n-    xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);\n+        xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);\n@@ -615,1 +615,1 @@\n-    extSubset = NULL;\n+        extSubset = NULL;\n@@ -617,3 +617,3 @@\n-    xmlUnlinkNode((xmlNodePtr) cur->extSubset);\n-    cur->extSubset = NULL;\n-    xmlFreeDtd(extSubset);\n+        xmlUnlinkNode((xmlNodePtr) cur->extSubset);\n+        cur->extSubset = NULL;\n+        xmlFreeDtd(extSubset);\n@@ -622,3 +622,3 @@\n-    xmlUnlinkNode((xmlNodePtr) cur->intSubset);\n-    cur->intSubset = NULL;\n-    xmlFreeDtd(intSubset);\n+        xmlUnlinkNode((xmlNodePtr) cur->intSubset);\n+        cur->intSubset = NULL;\n+        xmlFreeDtd(intSubset);\n@@ -640,3 +640,3 @@\n- *                                  *\n- *          The reader core parser              *\n- *                                  *\n+ *                                                                      *\n+ *                      The reader core parser                          *\n+ *                                                                      *\n@@ -648,2 +648,2 @@\n-    fprintf(stderr, \"xmlTextReader NULL\\n\");\n-    return;\n+        fprintf(stderr, \"xmlTextReader NULL\\n\");\n+        return;\n@@ -652,1 +652,1 @@\n-        reader->state, reader->depth);\n+            reader->state, reader->depth);\n@@ -654,1 +654,1 @@\n-    fprintf(stderr, \"node = NULL\\n\");\n+        fprintf(stderr, \"node = NULL\\n\");\n@@ -656,1 +656,1 @@\n-    fprintf(stderr, \"node %s\\n\", reader->node->name);\n+        fprintf(stderr, \"node %s\\n\", reader->node->name);\n@@ -659,1 +659,1 @@\n-        reader->base, reader->cur, reader->ctxt->nodeNr);\n+            reader->base, reader->cur, reader->ctxt->nodeNr);\n@@ -661,1 +661,1 @@\n-    fprintf(stderr, \"buffer is NULL\\n\");\n+        fprintf(stderr, \"buffer is NULL\\n\");\n@@ -664,2 +664,2 @@\n-    xmlDebugDumpString(stderr,\n-        &reader->input->buffer->content[reader->cur]);\n+        xmlDebugDumpString(stderr,\n+                &reader->input->buffer->content[reader->cur]);\n@@ -667,1 +667,1 @@\n-    fprintf(stderr, \"\\n\");\n+        fprintf(stderr, \"\\n\");\n@@ -685,3 +685,3 @@\n-    reader->entMax = 10;\n-    reader->entTab = (xmlNodePtr *) xmlMalloc(reader->entMax *\n-                                          sizeof(reader->entTab[0]));\n+        reader->entMax = 10;\n+        reader->entTab = (xmlNodePtr *) xmlMalloc(reader->entMax *\n+                                                  sizeof(reader->entTab[0]));\n@@ -744,1 +744,1 @@\n-                      const xmlChar **atts) {\n+                          const xmlChar **atts) {\n@@ -752,5 +752,5 @@\n-    reader->startElement(ctx, fullname, atts);\n-    if ((ctxt->node != NULL) && (ctxt->input != NULL) &&\n-        (ctxt->input->cur != NULL) && (ctxt->input->cur[0] == '\/') &&\n-        (ctxt->input->cur[1] == '>'))\n-        ctxt->node->extra = NODE_IS_EMPTY;\n+        reader->startElement(ctx, fullname, atts);\n+        if ((ctxt->node != NULL) && (ctxt->input != NULL) &&\n+            (ctxt->input->cur != NULL) && (ctxt->input->cur[0] == '\/') &&\n+            (ctxt->input->cur[1] == '>'))\n+            ctxt->node->extra = NODE_IS_EMPTY;\n@@ -759,1 +759,1 @@\n-    reader->state = XML_TEXTREADER_ELEMENT;\n+        reader->state = XML_TEXTREADER_ELEMENT;\n@@ -778,1 +778,1 @@\n-    reader->endElement(ctx, fullname);\n+        reader->endElement(ctx, fullname);\n@@ -800,7 +800,7 @@\n-              const xmlChar *prefix,\n-              const xmlChar *URI,\n-              int nb_namespaces,\n-              const xmlChar **namespaces,\n-              int nb_attributes,\n-              int nb_defaulted,\n-              const xmlChar **attributes)\n+                      const xmlChar *prefix,\n+                      const xmlChar *URI,\n+                      int nb_namespaces,\n+                      const xmlChar **namespaces,\n+                      int nb_attributes,\n+                      int nb_defaulted,\n+                      const xmlChar **attributes)\n@@ -815,7 +815,7 @@\n-    reader->startElementNs(ctx, localname, prefix, URI, nb_namespaces,\n-                           namespaces, nb_attributes, nb_defaulted,\n-                   attributes);\n-    if ((ctxt->node != NULL) && (ctxt->input != NULL) &&\n-        (ctxt->input->cur != NULL) && (ctxt->input->cur[0] == '\/') &&\n-        (ctxt->input->cur[1] == '>'))\n-        ctxt->node->extra = NODE_IS_EMPTY;\n+        reader->startElementNs(ctx, localname, prefix, URI, nb_namespaces,\n+                               namespaces, nb_attributes, nb_defaulted,\n+                               attributes);\n+        if ((ctxt->node != NULL) && (ctxt->input != NULL) &&\n+            (ctxt->input->cur != NULL) && (ctxt->input->cur[0] == '\/') &&\n+            (ctxt->input->cur[1] == '>'))\n+            ctxt->node->extra = NODE_IS_EMPTY;\n@@ -824,1 +824,1 @@\n-    reader->state = XML_TEXTREADER_ELEMENT;\n+        reader->state = XML_TEXTREADER_ELEMENT;\n@@ -840,1 +840,1 @@\n-                  const xmlChar * URI)\n+                          const xmlChar * URI)\n@@ -849,1 +849,1 @@\n-    reader->endElementNs(ctx, localname, prefix, URI);\n+        reader->endElementNs(ctx, localname, prefix, URI);\n@@ -872,1 +872,1 @@\n-    reader->characters(ctx, ch, len);\n+        reader->characters(ctx, ch, len);\n@@ -894,1 +894,1 @@\n-    reader->cdataBlock(ctx, ch, len);\n+        reader->cdataBlock(ctx, ch, len);\n@@ -915,1 +915,1 @@\n-    return(-1);\n+        return(-1);\n@@ -923,1 +923,27 @@\n-    if (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {\n+        if (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {\n+            \/*\n+             * Refill the buffer unless we are at the end of the stream\n+             *\/\n+            if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n+                val = xmlParserInputBufferRead(reader->input, 4096);\n+                if ((val == 0) &&\n+                    (alloc == XML_BUFFER_ALLOC_IMMUTABLE)) {\n+                    if (xmlBufUse(inbuf) == reader->cur) {\n+                        reader->mode = XML_TEXTREADER_MODE_EOF;\n+                        reader->state = oldstate;\n+                    }\n+                } else if (val < 0) {\n+                    reader->mode = XML_TEXTREADER_MODE_EOF;\n+                    reader->state = oldstate;\n+                    if ((oldstate != XML_TEXTREADER_START) ||\n+                        (reader->ctxt->myDoc != NULL))\n+                        return(val);\n+                } else if (val == 0) {\n+                    \/* mark the end of the stream and process the remains *\/\n+                    reader->mode = XML_TEXTREADER_MODE_EOF;\n+                    break;\n+                }\n+\n+            } else\n+                break;\n+        }\n@@ -925,1 +951,2 @@\n-         * Refill the buffer unless we are at the end of the stream\n+         * parse by block of CHUNK_SIZE bytes, various tests show that\n+         * it's the best tradeoff at least on a 1.2GH Duron\n@@ -927,29 +954,2 @@\n-        if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n-        val = xmlParserInputBufferRead(reader->input, 4096);\n-        if ((val == 0) &&\n-            (alloc == XML_BUFFER_ALLOC_IMMUTABLE)) {\n-            if (xmlBufUse(inbuf) == reader->cur) {\n-            reader->mode = XML_TEXTREADER_MODE_EOF;\n-            reader->state = oldstate;\n-            }\n-        } else if (val < 0) {\n-            reader->mode = XML_TEXTREADER_MODE_EOF;\n-            reader->state = oldstate;\n-            if ((oldstate != XML_TEXTREADER_START) ||\n-            (reader->ctxt->myDoc != NULL))\n-            return(val);\n-        } else if (val == 0) {\n-            \/* mark the end of the stream and process the remains *\/\n-            reader->mode = XML_TEXTREADER_MODE_EOF;\n-            break;\n-        }\n-\n-        } else\n-        break;\n-    }\n-    \/*\n-     * parse by block of CHUNK_SIZE bytes, various tests show that\n-     * it's the best tradeoff at least on a 1.2GH Duron\n-     *\/\n-    if (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {\n-        val = xmlParseChunk(reader->ctxt,\n+        if (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {\n+            val = xmlParseChunk(reader->ctxt,\n@@ -958,15 +958,15 @@\n-        reader->cur += CHUNK_SIZE;\n-        if (val != 0)\n-        reader->ctxt->wellFormed = 0;\n-        if (reader->ctxt->wellFormed == 0)\n-        break;\n-    } else {\n-        s = xmlBufUse(inbuf) - reader->cur;\n-        val = xmlParseChunk(reader->ctxt,\n-         (const char *) xmlBufContent(inbuf) + reader->cur,\n-                    s, 0);\n-        reader->cur += s;\n-        if (val != 0)\n-        reader->ctxt->wellFormed = 0;\n-        break;\n-    }\n+            reader->cur += CHUNK_SIZE;\n+            if (val != 0)\n+                reader->ctxt->wellFormed = 0;\n+            if (reader->ctxt->wellFormed == 0)\n+                break;\n+        } else {\n+            s = xmlBufUse(inbuf) - reader->cur;\n+            val = xmlParseChunk(reader->ctxt,\n+                 (const char *) xmlBufContent(inbuf) + reader->cur,\n+                                s, 0);\n+            reader->cur += s;\n+            if (val != 0)\n+                reader->ctxt->wellFormed = 0;\n+            break;\n+        }\n@@ -980,6 +980,7 @@\n-        if ((reader->cur >= 4096) &&\n-        (xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {\n-        val = xmlBufShrink(inbuf, reader->cur);\n-        if (val >= 0) {\n-            reader->cur -= val;\n-        }\n+            if ((reader->cur >= 4096) &&\n+                (xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {\n+                val = xmlBufShrink(inbuf, reader->cur);\n+                if (val >= 0) {\n+                    reader->cur -= val;\n+                }\n+            }\n@@ -988,1 +989,0 @@\n-    }\n@@ -995,12 +995,13 @@\n-    if (reader->state != XML_TEXTREADER_DONE) {\n-        s = xmlBufUse(inbuf) - reader->cur;\n-        val = xmlParseChunk(reader->ctxt,\n-         (const char *) xmlBufContent(inbuf) + reader->cur,\n-                    s, 1);\n-        reader->cur = xmlBufUse(inbuf);\n-        reader->state  = XML_TEXTREADER_DONE;\n-        if (val != 0) {\n-            if (reader->ctxt->wellFormed)\n-            reader->ctxt->wellFormed = 0;\n-        else\n-            return(-1);\n+        if (reader->state != XML_TEXTREADER_DONE) {\n+            s = xmlBufUse(inbuf) - reader->cur;\n+            val = xmlParseChunk(reader->ctxt,\n+                 (const char *) xmlBufContent(inbuf) + reader->cur,\n+                                s, 1);\n+            reader->cur = xmlBufUse(inbuf);\n+            reader->state  = XML_TEXTREADER_DONE;\n+            if (val != 0) {\n+                if (reader->ctxt->wellFormed)\n+                    reader->ctxt->wellFormed = 0;\n+                else\n+                    return(-1);\n+            }\n@@ -1009,1 +1010,0 @@\n-    }\n@@ -1012,1 +1012,1 @@\n-    reader->mode = XML_TEXTREADER_MODE_EOF;\n+        reader->mode = XML_TEXTREADER_MODE_EOF;\n@@ -1033,15 +1033,15 @@\n-    if ((node->ns == NULL) || (node->ns->prefix == NULL)) {\n-        reader->ctxt->valid &= xmlValidatePushElement(&reader->ctxt->vctxt,\n-                    reader->ctxt->myDoc, node, node->name);\n-    } else {\n-        \/* TODO use the BuildQName interface *\/\n-        xmlChar *qname;\n-\n-        qname = xmlStrdup(node->ns->prefix);\n-        qname = xmlStrcat(qname, BAD_CAST \":\");\n-        qname = xmlStrcat(qname, node->name);\n-        reader->ctxt->valid &= xmlValidatePushElement(&reader->ctxt->vctxt,\n-                    reader->ctxt->myDoc, node, qname);\n-        if (qname != NULL)\n-        xmlFree(qname);\n-    }\n+        if ((node->ns == NULL) || (node->ns->prefix == NULL)) {\n+            reader->ctxt->valid &= xmlValidatePushElement(&reader->ctxt->vctxt,\n+                                    reader->ctxt->myDoc, node, node->name);\n+        } else {\n+            \/* TODO use the BuildQName interface *\/\n+            xmlChar *qname;\n+\n+            qname = xmlStrdup(node->ns->prefix);\n+            qname = xmlStrcat(qname, BAD_CAST \":\");\n+            qname = xmlStrcat(qname, node->name);\n+            reader->ctxt->valid &= xmlValidatePushElement(&reader->ctxt->vctxt,\n+                                    reader->ctxt->myDoc, node, qname);\n+            if (qname != NULL)\n+                xmlFree(qname);\n+        }\n@@ -1053,18 +1053,19 @@\n-    int ret;\n-\n-    if (reader->rngFullNode != NULL) return;\n-    ret = xmlRelaxNGValidatePushElement(reader->rngValidCtxt,\n-                                        reader->ctxt->myDoc,\n-                        node);\n-    if (ret == 0) {\n-        \/*\n-         * this element requires a full tree\n-         *\/\n-        node = xmlTextReaderExpand(reader);\n-        if (node == NULL) {\n-            ret = -1;\n-        } else {\n-        ret = xmlRelaxNGValidateFullElement(reader->rngValidCtxt,\n-                            reader->ctxt->myDoc,\n-                            node);\n-        reader->rngFullNode = node;\n+        int ret;\n+\n+        if (reader->rngFullNode != NULL) return;\n+        ret = xmlRelaxNGValidatePushElement(reader->rngValidCtxt,\n+                                            reader->ctxt->myDoc,\n+                                            node);\n+        if (ret == 0) {\n+            \/*\n+             * this element requires a full tree\n+             *\/\n+            node = xmlTextReaderExpand(reader);\n+            if (node == NULL) {\n+                ret = -1;\n+            } else {\n+                ret = xmlRelaxNGValidateFullElement(reader->rngValidCtxt,\n+                                                    reader->ctxt->myDoc,\n+                                                    node);\n+                reader->rngFullNode = node;\n+            }\n@@ -1072,3 +1073,2 @@\n-    }\n-    if (ret != 1)\n-        reader->rngValidErrors++;\n+        if (ret != 1)\n+            reader->rngValidErrors++;\n@@ -1093,2 +1093,2 @@\n-    reader->ctxt->valid &= xmlValidatePushCData(&reader->ctxt->vctxt,\n-                                                data, len);\n+        reader->ctxt->valid &= xmlValidatePushCData(&reader->ctxt->vctxt,\n+                                                    data, len);\n@@ -1100,1 +1100,1 @@\n-    int ret;\n+        int ret;\n@@ -1102,4 +1102,4 @@\n-    if (reader->rngFullNode != NULL) return;\n-    ret = xmlRelaxNGValidatePushCData(reader->rngValidCtxt, data, len);\n-    if (ret != 1)\n-        reader->rngValidErrors++;\n+        if (reader->rngFullNode != NULL) return;\n+        ret = xmlRelaxNGValidatePushCData(reader->rngValidCtxt, data, len);\n+        if (ret != 1)\n+            reader->rngValidErrors++;\n@@ -1123,15 +1123,15 @@\n-    if ((node->ns == NULL) || (node->ns->prefix == NULL)) {\n-        reader->ctxt->valid &= xmlValidatePopElement(&reader->ctxt->vctxt,\n-                    reader->ctxt->myDoc, node, node->name);\n-    } else {\n-        \/* TODO use the BuildQName interface *\/\n-        xmlChar *qname;\n-\n-        qname = xmlStrdup(node->ns->prefix);\n-        qname = xmlStrcat(qname, BAD_CAST \":\");\n-        qname = xmlStrcat(qname, node->name);\n-        reader->ctxt->valid &= xmlValidatePopElement(&reader->ctxt->vctxt,\n-                    reader->ctxt->myDoc, node, qname);\n-        if (qname != NULL)\n-        xmlFree(qname);\n-    }\n+        if ((node->ns == NULL) || (node->ns->prefix == NULL)) {\n+            reader->ctxt->valid &= xmlValidatePopElement(&reader->ctxt->vctxt,\n+                                    reader->ctxt->myDoc, node, node->name);\n+        } else {\n+            \/* TODO use the BuildQName interface *\/\n+            xmlChar *qname;\n+\n+            qname = xmlStrdup(node->ns->prefix);\n+            qname = xmlStrcat(qname, BAD_CAST \":\");\n+            qname = xmlStrcat(qname, node->name);\n+            reader->ctxt->valid &= xmlValidatePopElement(&reader->ctxt->vctxt,\n+                                    reader->ctxt->myDoc, node, qname);\n+            if (qname != NULL)\n+                xmlFree(qname);\n+        }\n@@ -1143,1 +1143,1 @@\n-    int ret;\n+        int ret;\n@@ -1145,10 +1145,10 @@\n-    if (reader->rngFullNode != NULL) {\n-        if (node == reader->rngFullNode)\n-            reader->rngFullNode = NULL;\n-        return;\n-    }\n-    ret = xmlRelaxNGValidatePopElement(reader->rngValidCtxt,\n-                                       reader->ctxt->myDoc,\n-                       node);\n-    if (ret != 1)\n-        reader->rngValidErrors++;\n+        if (reader->rngFullNode != NULL) {\n+            if (node == reader->rngFullNode)\n+                reader->rngFullNode = NULL;\n+            return;\n+        }\n+        ret = xmlRelaxNGValidatePopElement(reader->rngValidCtxt,\n+                                           reader->ctxt->myDoc,\n+                                           node);\n+        if (ret != 1)\n+            reader->rngValidErrors++;\n@@ -1173,13 +1173,13 @@\n-    if (node->type == XML_ENTITY_REF_NODE) {\n-        if ((node->children != NULL) &&\n-        (node->children->type == XML_ENTITY_DECL) &&\n-        (node->children->children != NULL)) {\n-        xmlTextReaderEntPush(reader, node);\n-        node = node->children->children;\n-        continue;\n-        } else {\n-        \/*\n-         * The error has probably been raised already.\n-         *\/\n-        if (node == oldnode)\n-            break;\n+        if (node->type == XML_ENTITY_REF_NODE) {\n+            if ((node->children != NULL) &&\n+                (node->children->type == XML_ENTITY_DECL) &&\n+                (node->children->children != NULL)) {\n+                xmlTextReaderEntPush(reader, node);\n+                node = node->children->children;\n+                continue;\n+            } else {\n+                \/*\n+                 * The error has probably been raised already.\n+                 *\/\n+                if (node == oldnode)\n+                    break;\n@@ -1187,1 +1187,1 @@\n-        }\n+            }\n@@ -1189,5 +1189,5 @@\n-    } else if (node->type == XML_ELEMENT_NODE) {\n-        reader->node = node;\n-        xmlTextReaderValidatePush(reader);\n-    } else if ((node->type == XML_TEXT_NODE) ||\n-           (node->type == XML_CDATA_SECTION_NODE)) {\n+        } else if (node->type == XML_ELEMENT_NODE) {\n+            reader->node = node;\n+            xmlTextReaderValidatePush(reader);\n+        } else if ((node->type == XML_TEXT_NODE) ||\n+                   (node->type == XML_CDATA_SECTION_NODE)) {\n@@ -1195,1 +1195,1 @@\n-                                   xmlStrlen(node->content));\n+                                       xmlStrlen(node->content));\n@@ -1197,31 +1197,0 @@\n-    }\n-\n-    \/*\n-     * go to next node\n-     *\/\n-    if (node->children != NULL) {\n-        node = node->children;\n-        continue;\n-    } else if (node->type == XML_ELEMENT_NODE) {\n-        xmlTextReaderValidatePop(reader);\n-    }\n-skip_children:\n-    if (node->next != NULL) {\n-        node = node->next;\n-        continue;\n-    }\n-    do {\n-        node = node->parent;\n-        if (node->type == XML_ELEMENT_NODE) {\n-            xmlNodePtr tmp;\n-        if (reader->entNr == 0) {\n-            while ((tmp = node->last) != NULL) {\n-            if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n-                xmlUnlinkNode(tmp);\n-                xmlTextReaderFreeNode(reader, tmp);\n-            } else\n-                break;\n-            }\n-        }\n-        reader->node = node;\n-        xmlTextReaderValidatePop(reader);\n@@ -1229,3 +1198,9 @@\n-        if ((node->type == XML_ENTITY_DECL) &&\n-        (reader->ent != NULL) && (reader->ent->children == node)) {\n-        node = xmlTextReaderEntPop(reader);\n+\n+        \/*\n+         * go to next node\n+         *\/\n+        if (node->children != NULL) {\n+            node = node->children;\n+            continue;\n+        } else if (node->type == XML_ELEMENT_NODE) {\n+            xmlTextReaderValidatePop(reader);\n@@ -1233,2 +1208,1 @@\n-        if (node == oldnode)\n-        break;\n+skip_children:\n@@ -1236,2 +1210,2 @@\n-        node = node->next;\n-        break;\n+            node = node->next;\n+            continue;\n@@ -1239,1 +1213,27 @@\n-    } while ((node != NULL) && (node != oldnode));\n+        do {\n+            node = node->parent;\n+            if (node->type == XML_ELEMENT_NODE) {\n+                xmlNodePtr tmp;\n+                if (reader->entNr == 0) {\n+                    while ((tmp = node->last) != NULL) {\n+                        if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n+                            xmlUnlinkNode(tmp);\n+                            xmlTextReaderFreeNode(reader, tmp);\n+                        } else\n+                            break;\n+                    }\n+                }\n+                reader->node = node;\n+                xmlTextReaderValidatePop(reader);\n+            }\n+            if ((node->type == XML_ENTITY_DECL) &&\n+                (reader->ent != NULL) && (reader->ent->children == node)) {\n+                node = xmlTextReaderEntPop(reader);\n+            }\n+            if (node == oldnode)\n+                break;\n+            if (node->next != NULL) {\n+                node = node->next;\n+                break;\n+            }\n+        } while ((node != NULL) && (node != oldnode));\n@@ -1284,1 +1284,1 @@\n-    if (reader->ctxt->instate == XML_PARSER_EOF) return(1);\n+        if (reader->ctxt->instate == XML_PARSER_EOF) return(1);\n@@ -1287,10 +1287,10 @@\n-        return(1);\n-    if (reader->ctxt->nodeNr < reader->depth)\n-        return(1);\n-    if (reader->mode == XML_TEXTREADER_MODE_EOF)\n-        return(1);\n-    val = xmlTextReaderPushData(reader);\n-    if (val < 0){\n-        reader->mode = XML_TEXTREADER_MODE_ERROR;\n-        return(-1);\n-    }\n+            return(1);\n+        if (reader->ctxt->nodeNr < reader->depth)\n+            return(1);\n+        if (reader->mode == XML_TEXTREADER_MODE_EOF)\n+            return(1);\n+        val = xmlTextReaderPushData(reader);\n+        if (val < 0){\n+            reader->mode = XML_TEXTREADER_MODE_ERROR;\n+            return(-1);\n+        }\n@@ -1333,1 +1333,1 @@\n-       tmp = xmlTextReaderCollectSiblings(node->children);\n+           tmp = xmlTextReaderCollectSiblings(node->children);\n@@ -1335,2 +1335,2 @@\n-       xmlFree(tmp);\n-       break;\n+           xmlFree(tmp);\n+           break;\n@@ -1366,1 +1366,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1371,1 +1371,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1378,27 +1378,31 @@\n-    reader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n-    \/*\n-     * Initial state\n-     *\/\n-    do {\n-        val = xmlTextReaderPushData(reader);\n-        if (val < 0){\n-            reader->mode = XML_TEXTREADER_MODE_ERROR;\n-            reader->state = XML_TEXTREADER_ERROR;\n-        return(-1);\n-        }\n-    } while ((reader->ctxt->node == NULL) &&\n-         ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n-          (reader->state != XML_TEXTREADER_DONE)));\n-    if (reader->ctxt->node == NULL) {\n-        if (reader->ctxt->myDoc != NULL) {\n-        reader->node = reader->ctxt->myDoc->children;\n-        }\n-        if (reader->node == NULL){\n-            reader->mode = XML_TEXTREADER_MODE_ERROR;\n-            reader->state = XML_TEXTREADER_ERROR;\n-        return(-1);\n-        }\n-        reader->state = XML_TEXTREADER_ELEMENT;\n-    } else {\n-        if (reader->ctxt->myDoc != NULL) {\n-        reader->node = reader->ctxt->myDoc->children;\n+        reader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n+        \/*\n+         * Initial state\n+         *\/\n+        do {\n+            val = xmlTextReaderPushData(reader);\n+                if (val < 0){\n+                        reader->mode = XML_TEXTREADER_MODE_ERROR;\n+                        reader->state = XML_TEXTREADER_ERROR;\n+                return(-1);\n+                }\n+        } while ((reader->ctxt->node == NULL) &&\n+                 ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n+                  (reader->state != XML_TEXTREADER_DONE)));\n+        if (reader->ctxt->node == NULL) {\n+            if (reader->ctxt->myDoc != NULL) {\n+                reader->node = reader->ctxt->myDoc->children;\n+            }\n+            if (reader->node == NULL){\n+                        reader->mode = XML_TEXTREADER_MODE_ERROR;\n+                        reader->state = XML_TEXTREADER_ERROR;\n+                return(-1);\n+                }\n+            reader->state = XML_TEXTREADER_ELEMENT;\n+        } else {\n+            if (reader->ctxt->myDoc != NULL) {\n+                reader->node = reader->ctxt->myDoc->children;\n+            }\n+            if (reader->node == NULL)\n+                reader->node = reader->ctxt->nodeTab[0];\n+            reader->state = XML_TEXTREADER_ELEMENT;\n@@ -1406,7 +1410,3 @@\n-        if (reader->node == NULL)\n-        reader->node = reader->ctxt->nodeTab[0];\n-        reader->state = XML_TEXTREADER_ELEMENT;\n-    }\n-    reader->depth = 0;\n-    reader->ctxt->parseMode = XML_PARSE_READER;\n-    goto node_found;\n+        reader->depth = 0;\n+        reader->ctxt->parseMode = XML_PARSE_READER;\n+        goto node_found;\n@@ -1420,4 +1420,4 @@\n-    if (reader->mode == XML_TEXTREADER_MODE_EOF)\n-        return(0);\n-    else\n-        return(-1);\n+        if (reader->mode == XML_TEXTREADER_MODE_EOF)\n+            return(0);\n+        else\n+            return(-1);\n@@ -1432,1 +1432,1 @@\n-       (reader->ctxt->nodeNr == olddepth) &&\n+           (reader->ctxt->nodeNr == olddepth) &&\n@@ -1435,19 +1435,19 @@\n-        (reader->node->type == XML_ENTITY_REF_NODE) ||\n-        ((reader->node->children != NULL) &&\n-         (reader->node->children->type == XML_TEXT_NODE) &&\n-         (reader->node->children->next == NULL)) ||\n-        (reader->node->type == XML_DTD_NODE) ||\n-        (reader->node->type == XML_DOCUMENT_NODE) ||\n-        (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n-       ((reader->ctxt->node == NULL) ||\n-        (reader->ctxt->node == reader->node) ||\n-        (reader->ctxt->node == reader->node->parent)) &&\n-       (reader->ctxt->instate != XML_PARSER_EOF)) {\n-    val = xmlTextReaderPushData(reader);\n-    if (val < 0){\n-        reader->mode = XML_TEXTREADER_MODE_ERROR;\n-        reader->state = XML_TEXTREADER_ERROR;\n-        return(-1);\n-    }\n-    if (reader->node == NULL)\n-        goto node_end;\n+            (reader->node->type == XML_ENTITY_REF_NODE) ||\n+            ((reader->node->children != NULL) &&\n+             (reader->node->children->type == XML_TEXT_NODE) &&\n+             (reader->node->children->next == NULL)) ||\n+            (reader->node->type == XML_DTD_NODE) ||\n+            (reader->node->type == XML_DOCUMENT_NODE) ||\n+            (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n+           ((reader->ctxt->node == NULL) ||\n+            (reader->ctxt->node == reader->node) ||\n+            (reader->ctxt->node == reader->node->parent)) &&\n+           (reader->ctxt->instate != XML_PARSER_EOF)) {\n+        val = xmlTextReaderPushData(reader);\n+        if (val < 0){\n+                reader->mode = XML_TEXTREADER_MODE_ERROR;\n+                reader->state = XML_TEXTREADER_ERROR;\n+            return(-1);\n+        }\n+        if (reader->node == NULL)\n+            goto node_end;\n@@ -1456,9 +1456,9 @@\n-    if ((reader->node->children != NULL) &&\n-        (reader->node->type != XML_ENTITY_REF_NODE) &&\n-        (reader->node->type != XML_XINCLUDE_START) &&\n-        (reader->node->type != XML_DTD_NODE)) {\n-        reader->node = reader->node->children;\n-        reader->depth++;\n-        reader->state = XML_TEXTREADER_ELEMENT;\n-        goto node_found;\n-    }\n+        if ((reader->node->children != NULL) &&\n+            (reader->node->type != XML_ENTITY_REF_NODE) &&\n+            (reader->node->type != XML_XINCLUDE_START) &&\n+            (reader->node->type != XML_DTD_NODE)) {\n+            reader->node = reader->node->children;\n+            reader->depth++;\n+            reader->state = XML_TEXTREADER_ELEMENT;\n+            goto node_found;\n+        }\n@@ -1467,1 +1467,1 @@\n-    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n+        if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n@@ -1469,2 +1469,2 @@\n-        (reader->node->children == NULL) &&\n-        ((reader->node->extra & NODE_IS_EMPTY) == 0)\n+            (reader->node->children == NULL) &&\n+            ((reader->node->extra & NODE_IS_EMPTY) == 0)\n@@ -1472,1 +1472,1 @@\n-        && (reader->in_xinclude <= 0)\n+            && (reader->in_xinclude <= 0)\n@@ -1474,4 +1474,4 @@\n-        ) {\n-        reader->state = XML_TEXTREADER_END;\n-        goto node_found;\n-    }\n+            ) {\n+            reader->state = XML_TEXTREADER_END;\n+            goto node_found;\n+        }\n@@ -1479,3 +1479,3 @@\n-    if ((reader->validate) &&\n-        (reader->node->type == XML_ELEMENT_NODE))\n-        xmlTextReaderValidatePop(reader);\n+        if ((reader->validate) &&\n+            (reader->node->type == XML_ELEMENT_NODE))\n+            xmlTextReaderValidatePop(reader);\n@@ -1484,4 +1484,4 @@\n-        (reader->node->extra & NODE_IS_SPRESERVED))\n-        reader->preserves--;\n-    reader->node = reader->node->next;\n-    reader->state = XML_TEXTREADER_ELEMENT;\n+            (reader->node->extra & NODE_IS_SPRESERVED))\n+            reader->preserves--;\n+        reader->node = reader->node->next;\n+        reader->state = XML_TEXTREADER_ELEMENT;\n@@ -1489,4 +1489,4 @@\n-    \/*\n-     * Cleanup of the old node\n-     *\/\n-    if ((reader->preserves == 0) &&\n+        \/*\n+         * Cleanup of the old node\n+         *\/\n+        if ((reader->preserves == 0) &&\n@@ -1494,1 +1494,1 @@\n-        (reader->in_xinclude == 0) &&\n+            (reader->in_xinclude == 0) &&\n@@ -1496,2 +1496,2 @@\n-        (reader->entNr == 0) &&\n-        (reader->node->prev != NULL) &&\n+            (reader->entNr == 0) &&\n+            (reader->node->prev != NULL) &&\n@@ -1499,2 +1499,2 @@\n-        xmlNodePtr tmp = reader->node->prev;\n-        if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n+            xmlNodePtr tmp = reader->node->prev;\n+            if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n@@ -1503,2 +1503,3 @@\n-        xmlUnlinkNode(tmp);\n-        xmlTextReaderFreeNode(reader, tmp);\n+                xmlUnlinkNode(tmp);\n+                xmlTextReaderFreeNode(reader, tmp);\n+            }\n@@ -1506,1 +1507,0 @@\n-    }\n@@ -1508,1 +1508,1 @@\n-    goto node_found;\n+        goto node_found;\n@@ -1511,5 +1511,5 @@\n-    (reader->node->type == XML_ELEMENT_NODE) &&\n-    (reader->node->children == NULL) &&\n-    ((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n-    reader->state = XML_TEXTREADER_END;\n-    goto node_found;\n+        (reader->node->type == XML_ELEMENT_NODE) &&\n+        (reader->node->children == NULL) &&\n+        ((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n+        reader->state = XML_TEXTREADER_END;\n+        goto node_found;\n@@ -1519,1 +1519,1 @@\n-    xmlTextReaderValidatePop(reader);\n+        xmlTextReaderValidatePop(reader);\n@@ -1522,2 +1522,2 @@\n-    (reader->node->extra & NODE_IS_SPRESERVED))\n-    reader->preserves--;\n+        (reader->node->extra & NODE_IS_SPRESERVED))\n+        reader->preserves--;\n@@ -1526,1 +1526,1 @@\n-    (reader->node->type == XML_DOCUMENT_NODE) ||\n+        (reader->node->type == XML_DOCUMENT_NODE) ||\n@@ -1528,1 +1528,1 @@\n-    (reader->node->type == XML_DOCB_DOCUMENT_NODE) ||\n+        (reader->node->type == XML_DOCB_DOCUMENT_NODE) ||\n@@ -1530,9 +1530,9 @@\n-    (reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n-    if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n-        val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n-        reader->state = XML_TEXTREADER_DONE;\n-        if (val != 0)\n-            return(-1);\n-    }\n-    reader->node = NULL;\n-    reader->depth = -1;\n+        (reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n+        if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n+            val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n+            reader->state = XML_TEXTREADER_DONE;\n+            if (val != 0)\n+                return(-1);\n+        }\n+        reader->node = NULL;\n+        reader->depth = -1;\n@@ -1540,4 +1540,4 @@\n-    \/*\n-     * Cleanup of the old node\n-     *\/\n-    if ((oldnode != NULL) && (reader->preserves == 0) &&\n+        \/*\n+         * Cleanup of the old node\n+         *\/\n+        if ((oldnode != NULL) && (reader->preserves == 0) &&\n@@ -1545,1 +1545,1 @@\n-        (reader->in_xinclude == 0) &&\n+            (reader->in_xinclude == 0) &&\n@@ -1547,6 +1547,6 @@\n-        (reader->entNr == 0) &&\n-        (oldnode->type != XML_DTD_NODE) &&\n-        ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n-        xmlUnlinkNode(oldnode);\n-        xmlTextReaderFreeNode(reader, oldnode);\n-    }\n+            (reader->entNr == 0) &&\n+            (oldnode->type != XML_DTD_NODE) &&\n+            ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n+            xmlUnlinkNode(oldnode);\n+            xmlTextReaderFreeNode(reader, oldnode);\n+        }\n@@ -1554,1 +1554,1 @@\n-    goto node_end;\n+        goto node_end;\n@@ -1560,1 +1560,1 @@\n-    (reader->entNr == 0) &&\n+        (reader->entNr == 0) &&\n@@ -1563,3 +1563,3 @@\n-    xmlNodePtr tmp = reader->node->last;\n-    xmlUnlinkNode(tmp);\n-    xmlTextReaderFreeNode(reader, tmp);\n+        xmlNodePtr tmp = reader->node->last;\n+        xmlUnlinkNode(tmp);\n+        xmlTextReaderFreeNode(reader, tmp);\n@@ -1579,1 +1579,1 @@\n-     (reader->node->type == XML_CDATA_SECTION_NODE))) {\n+         (reader->node->type == XML_CDATA_SECTION_NODE))) {\n@@ -1581,1 +1581,1 @@\n-            return -1;\n+                return -1;\n@@ -1590,15 +1590,15 @@\n-    (reader->node->type == XML_ELEMENT_NODE) &&\n-    (reader->node->ns != NULL) &&\n-    ((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n-     (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n-    if (reader->xincctxt == NULL) {\n-        reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n-        xmlXIncludeSetFlags(reader->xincctxt,\n-                            reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n-    }\n-    \/*\n-     * expand that node and process it\n-     *\/\n-    if (xmlTextReaderExpand(reader) == NULL)\n-        return -1;\n-    xmlXIncludeProcessNode(reader->xincctxt, reader->node);\n+        (reader->node->type == XML_ELEMENT_NODE) &&\n+        (reader->node->ns != NULL) &&\n+        ((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n+         (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n+        if (reader->xincctxt == NULL) {\n+            reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n+            xmlXIncludeSetFlags(reader->xincctxt,\n+                                reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n+        }\n+        \/*\n+         * expand that node and process it\n+         *\/\n+        if (xmlTextReaderExpand(reader) == NULL)\n+            return -1;\n+        xmlXIncludeProcessNode(reader->xincctxt, reader->node);\n@@ -1608,1 +1608,1 @@\n-    goto get_next_node;\n+        goto get_next_node;\n@@ -1612,1 +1612,1 @@\n-    goto get_next_node;\n+        goto get_next_node;\n@@ -1619,8 +1619,8 @@\n-    (reader->node->type == XML_ENTITY_REF_NODE) &&\n-    (reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n-    if ((reader->node->children != NULL) &&\n-        (reader->node->children->type == XML_ENTITY_DECL) &&\n-        (reader->node->children->children != NULL)) {\n-        xmlTextReaderEntPush(reader, reader->node);\n-        reader->node = reader->node->children->children;\n-    }\n+        (reader->node->type == XML_ENTITY_REF_NODE) &&\n+        (reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n+        if ((reader->node->children != NULL) &&\n+            (reader->node->children->type == XML_ENTITY_DECL) &&\n+            (reader->node->children->children != NULL)) {\n+            xmlTextReaderEntPush(reader, reader->node);\n+            reader->node = reader->node->children->children;\n+        }\n@@ -1629,3 +1629,3 @@\n-           (reader->node->type == XML_ENTITY_REF_NODE) &&\n-           (reader->ctxt != NULL) && (reader->validate)) {\n-    xmlTextReaderValidateEntity(reader);\n+               (reader->node->type == XML_ENTITY_REF_NODE) &&\n+               (reader->ctxt != NULL) && (reader->validate)) {\n+        xmlTextReaderValidateEntity(reader);\n@@ -1635,4 +1635,4 @@\n-    (reader->node->type == XML_ENTITY_DECL) &&\n-    (reader->ent != NULL) && (reader->ent->children == reader->node)) {\n-    reader->node = xmlTextReaderEntPop(reader);\n-    reader->depth++;\n+        (reader->node->type == XML_ENTITY_DECL) &&\n+        (reader->ent != NULL) && (reader->ent->children == reader->node)) {\n+        reader->node = xmlTextReaderEntPop(reader);\n+        reader->depth++;\n@@ -1643,1 +1643,1 @@\n-    xmlNodePtr node = reader->node;\n+        xmlNodePtr node = reader->node;\n@@ -1645,1 +1645,1 @@\n-    if ((node->type == XML_ELEMENT_NODE) &&\n+        if ((node->type == XML_ELEMENT_NODE) &&\n@@ -1647,4 +1647,4 @@\n-         (reader->state != XML_TEXTREADER_BACKTRACK))) {\n-        xmlTextReaderValidatePush(reader);\n-    } else if ((node->type == XML_TEXT_NODE) ||\n-           (node->type == XML_CDATA_SECTION_NODE)) {\n+             (reader->state != XML_TEXTREADER_BACKTRACK))) {\n+            xmlTextReaderValidatePush(reader);\n+        } else if ((node->type == XML_TEXT_NODE) ||\n+                   (node->type == XML_CDATA_SECTION_NODE)) {\n@@ -1652,2 +1652,2 @@\n-                                   xmlStrlen(node->content));\n-    }\n+                                       xmlStrlen(node->content));\n+        }\n@@ -1660,4 +1660,4 @@\n-    for (i = 0;i < reader->patternNr;i++) {\n-         if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n-             xmlTextReaderPreserve(reader);\n-         break;\n+        for (i = 0;i < reader->patternNr;i++) {\n+             if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n+                 xmlTextReaderPreserve(reader);\n+                 break;\n@@ -1665,1 +1665,1 @@\n-    }\n+        }\n@@ -1671,2 +1671,2 @@\n-    (reader->xsdValidCtxt != NULL)) {\n-    reader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n+        (reader->xsdValidCtxt != NULL)) {\n+        reader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n@@ -1692,1 +1692,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1735,1 +1735,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1747,2 +1747,2 @@\n-    if (ret != 1)\n-        return(ret);\n+        if (ret != 1)\n+            return(ret);\n@@ -1827,5 +1827,5 @@\n-    if (node->type == XML_DTD_NODE) {\n-        node = (xmlNodePtr) xmlCopyDtd((xmlDtdPtr) node);\n-    } else {\n-        node = xmlDocCopyNode(node, doc, 1);\n-    }\n+        if (node->type == XML_DTD_NODE) {\n+                node = (xmlNodePtr) xmlCopyDtd((xmlDtdPtr) node);\n+        } else {\n+                node = xmlDocCopyNode(node, doc, 1);\n+        }\n@@ -1873,4 +1873,4 @@\n-    if (xmlTextReaderDoExpand(reader) != -1) {\n-        return xmlTextReaderCollectSiblings(node->children);\n-    }\n-    break;\n+        if (xmlTextReaderDoExpand(reader) != -1) {\n+            return xmlTextReaderCollectSiblings(node->children);\n+        }\n+        break;\n@@ -1878,2 +1878,2 @@\n-    TODO\n-    break;\n+        TODO\n+        break;\n@@ -1904,2 +1904,2 @@\n-                    int offset ATTRIBUTE_UNUSED,\n-            int len ATTRIBUTE_UNUSED) {\n+                        int offset ATTRIBUTE_UNUSED,\n+                        int len ATTRIBUTE_UNUSED) {\n@@ -1907,1 +1907,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1909,1 +1909,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1912,1 +1912,1 @@\n-    return(0);\n+        return(0);\n@@ -1934,2 +1934,2 @@\n-                    int offset ATTRIBUTE_UNUSED,\n-            int len ATTRIBUTE_UNUSED) {\n+                        int offset ATTRIBUTE_UNUSED,\n+                        int len ATTRIBUTE_UNUSED) {\n@@ -1937,1 +1937,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1939,1 +1939,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1942,1 +1942,1 @@\n-    return(0);\n+        return(0);\n@@ -1949,3 +1949,3 @@\n- *                                  *\n- *          Operating on a preparsed tree           *\n- *                                  *\n+ *                                                                      *\n+ *                      Operating on a preparsed tree                   *\n+ *                                                                      *\n@@ -1974,2 +1974,2 @@\n-    \/* Here removed traversal to child, because we want to skip the subtree,\n-    replace with traversal to sibling to skip subtree *\/\n+        \/* Here removed traversal to child, because we want to skip the subtree,\n+        replace with traversal to sibling to skip subtree *\/\n@@ -1977,1 +1977,1 @@\n-        \/* Move to sibling if present,skipping sub-tree *\/\n+            \/* Move to sibling if present,skipping sub-tree *\/\n@@ -1983,5 +1983,5 @@\n-    \/* if reader->node->next is NULL mean no subtree for current node,\n-    so need to move to sibling of parent node if present *\/\n-    reader->state = XML_TEXTREADER_BACKTRACK;\n-    \/* This will move to parent if present *\/\n-    xmlTextReaderRead(reader);\n+        \/* if reader->node->next is NULL mean no subtree for current node,\n+        so need to move to sibling of parent node if present *\/\n+        reader->state = XML_TEXTREADER_BACKTRACK;\n+        \/* This will move to parent if present *\/\n+        xmlTextReaderRead(reader);\n@@ -2005,1 +2005,1 @@\n-    \/* Repeat process to move to sibling of parent node if present *\/\n+        \/* Repeat process to move to sibling of parent node if present *\/\n@@ -2044,1 +2044,1 @@\n-    (reader->node->type != XML_ENTITY_REF_NODE)) {\n+        (reader->node->type != XML_ENTITY_REF_NODE)) {\n@@ -2066,1 +2066,1 @@\n-        (reader->node->parent->type == XML_HTML_DOCUMENT_NODE)) {\n+            (reader->node->parent->type == XML_HTML_DOCUMENT_NODE)) {\n@@ -2082,1 +2082,1 @@\n-    goto next_node;\n+        goto next_node;\n@@ -2104,1 +2104,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2123,3 +2123,3 @@\n- *                                  *\n- *          Constructor and destructors         *\n- *                                  *\n+ *                                                                      *\n+ *                      Constructor and destructors                     *\n+ *                                                                      *\n@@ -2141,1 +2141,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2145,2 +2145,2 @@\n-        \"xmlNewTextReader : malloc failed\\n\");\n-    return(NULL);\n+                \"xmlNewTextReader : malloc failed\\n\");\n+        return(NULL);\n@@ -2158,2 +2158,2 @@\n-        \"xmlNewTextReader : malloc failed\\n\");\n-    return(NULL);\n+                \"xmlNewTextReader : malloc failed\\n\");\n+        return(NULL);\n@@ -2163,1 +2163,1 @@\n-                  XML_BUFFER_ALLOC_BOUNDED);\n+                              XML_BUFFER_ALLOC_BOUNDED);\n@@ -2166,2 +2166,2 @@\n-    xmlBufFree(ret->buffer);\n-    xmlFree(ret);\n+        xmlBufFree(ret->buffer);\n+        xmlFree(ret);\n@@ -2169,2 +2169,2 @@\n-        \"xmlNewTextReader : malloc failed\\n\");\n-    return(NULL);\n+                \"xmlNewTextReader : malloc failed\\n\");\n+        return(NULL);\n@@ -2180,4 +2180,4 @@\n-    ret->startElementNs = ret->sax->startElementNs;\n-    ret->sax->startElementNs = xmlTextReaderStartElementNs;\n-    ret->endElementNs = ret->sax->endElementNs;\n-    ret->sax->endElementNs = xmlTextReaderEndElementNs;\n+        ret->startElementNs = ret->sax->startElementNs;\n+        ret->sax->startElementNs = xmlTextReaderStartElementNs;\n+        ret->endElementNs = ret->sax->endElementNs;\n+        ret->sax->endElementNs = xmlTextReaderEndElementNs;\n@@ -2186,2 +2186,2 @@\n-    ret->startElementNs = NULL;\n-    ret->endElementNs = NULL;\n+        ret->startElementNs = NULL;\n+        ret->endElementNs = NULL;\n@@ -2200,1 +2200,1 @@\n-    xmlParserInputBufferRead(input, 4);\n+        xmlParserInputBufferRead(input, 4);\n@@ -2203,2 +2203,2 @@\n-    ret->ctxt = xmlCreatePushParserCtxt(ret->sax, NULL,\n-                 (const char *) xmlBufContent(ret->input->buffer),\n+        ret->ctxt = xmlCreatePushParserCtxt(ret->sax, NULL,\n+                             (const char *) xmlBufContent(ret->input->buffer),\n@@ -2206,2 +2206,2 @@\n-    ret->base = 0;\n-    ret->cur = 4;\n+        ret->base = 0;\n+        ret->cur = 4;\n@@ -2209,3 +2209,3 @@\n-    ret->ctxt = xmlCreatePushParserCtxt(ret->sax, NULL, NULL, 0, URI);\n-    ret->base = 0;\n-    ret->cur = 0;\n+        ret->ctxt = xmlCreatePushParserCtxt(ret->sax, NULL, NULL, 0, URI);\n+        ret->base = 0;\n+        ret->cur = 0;\n@@ -2216,5 +2216,5 @@\n-        \"xmlNewTextReader : malloc failed\\n\");\n-    xmlBufFree(ret->buffer);\n-    xmlFree(ret->sax);\n-    xmlFree(ret);\n-    return(NULL);\n+                \"xmlNewTextReader : malloc failed\\n\");\n+        xmlBufFree(ret->buffer);\n+        xmlFree(ret->sax);\n+        xmlFree(ret);\n+        return(NULL);\n@@ -2258,1 +2258,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2261,2 +2261,2 @@\n-    xmlFreeParserInputBuffer(input);\n-    return(NULL);\n+        xmlFreeParserInputBuffer(input);\n+        return(NULL);\n@@ -2270,1 +2270,1 @@\n-    xmlFree(directory);\n+        xmlFree(directory);\n@@ -2283,1 +2283,1 @@\n-    return;\n+        return;\n@@ -2286,2 +2286,2 @@\n-    xmlRelaxNGFree(reader->rngSchemas);\n-    reader->rngSchemas = NULL;\n+        xmlRelaxNGFree(reader->rngSchemas);\n+        reader->rngSchemas = NULL;\n@@ -2290,3 +2290,3 @@\n-    if (! reader->rngPreserveCtxt)\n-        xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);\n-    reader->rngValidCtxt = NULL;\n+        if (! reader->rngPreserveCtxt)\n+            xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);\n+        reader->rngValidCtxt = NULL;\n@@ -2295,2 +2295,2 @@\n-    xmlSchemaSAXUnplug(reader->xsdPlug);\n-    reader->xsdPlug = NULL;\n+        xmlSchemaSAXUnplug(reader->xsdPlug);\n+        reader->xsdPlug = NULL;\n@@ -2299,3 +2299,3 @@\n-    if (! reader->xsdPreserveCtxt)\n-        xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n-    reader->xsdValidCtxt = NULL;\n+        if (! reader->xsdPreserveCtxt)\n+            xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n+        reader->xsdValidCtxt = NULL;\n@@ -2304,2 +2304,2 @@\n-    xmlSchemaFree(reader->xsdSchemas);\n-    reader->xsdSchemas = NULL;\n+        xmlSchemaFree(reader->xsdSchemas);\n+        reader->xsdSchemas = NULL;\n@@ -2310,1 +2310,1 @@\n-    xmlXIncludeFreeContext(reader->xincctxt);\n+        xmlXIncludeFreeContext(reader->xincctxt);\n@@ -2315,5 +2315,5 @@\n-    for (i = 0;i < reader->patternNr;i++) {\n-        if (reader->patternTab[i] != NULL)\n-            xmlFreePattern(reader->patternTab[i]);\n-    }\n-    xmlFree(reader->patternTab);\n+        for (i = 0;i < reader->patternNr;i++) {\n+            if (reader->patternTab[i] != NULL)\n+                xmlFreePattern(reader->patternTab[i]);\n+        }\n+        xmlFree(reader->patternTab);\n@@ -2323,1 +2323,1 @@\n-    xmlFreeNode(reader->faketext);\n+        xmlFreeNode(reader->faketext);\n@@ -2327,1 +2327,1 @@\n-        reader->dict = NULL;\n+            reader->dict = NULL;\n@@ -2329,2 +2329,2 @@\n-    if ((reader->ctxt->vctxt.vstateTab != NULL) &&\n-        (reader->ctxt->vctxt.vstateMax > 0)){\n+        if ((reader->ctxt->vctxt.vstateTab != NULL) &&\n+            (reader->ctxt->vctxt.vstateMax > 0)){\n@@ -2335,4 +2335,4 @@\n-        xmlFree(reader->ctxt->vctxt.vstateTab);\n-        reader->ctxt->vctxt.vstateTab = NULL;\n-        reader->ctxt->vctxt.vstateMax = 0;\n-    }\n+            xmlFree(reader->ctxt->vctxt.vstateTab);\n+            reader->ctxt->vctxt.vstateTab = NULL;\n+            reader->ctxt->vctxt.vstateMax = 0;\n+        }\n@@ -2340,7 +2340,7 @@\n-    if (reader->ctxt->myDoc != NULL) {\n-        if (reader->preserve == 0)\n-        xmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);\n-        reader->ctxt->myDoc = NULL;\n-    }\n-    if (reader->allocs & XML_TEXTREADER_CTXT)\n-        xmlFreeParserCtxt(reader->ctxt);\n+        if (reader->ctxt->myDoc != NULL) {\n+            if (reader->preserve == 0)\n+                xmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);\n+            reader->ctxt->myDoc = NULL;\n+        }\n+        if (reader->allocs & XML_TEXTREADER_CTXT)\n+            xmlFreeParserCtxt(reader->ctxt);\n@@ -2349,1 +2349,1 @@\n-    xmlFree(reader->sax);\n+        xmlFree(reader->sax);\n@@ -2351,1 +2351,1 @@\n-    xmlFreeParserInputBuffer(reader->input);\n+        xmlFreeParserInputBuffer(reader->input);\n@@ -2355,1 +2355,1 @@\n-    xmlFree(reader->entTab);\n+        xmlFree(reader->entTab);\n@@ -2362,3 +2362,3 @@\n- *                                  *\n- *          Methods for XmlTextReader           *\n- *                                  *\n+ *                                                                      *\n+ *                      Methods for XmlTextReader                       *\n+ *                                                                      *\n@@ -2378,1 +2378,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2383,6 +2383,6 @@\n-    xmlStopParser(reader->ctxt);\n-    if (reader->ctxt->myDoc != NULL) {\n-        if (reader->preserve == 0)\n-        xmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);\n-        reader->ctxt->myDoc = NULL;\n-    }\n+        xmlStopParser(reader->ctxt);\n+        if (reader->ctxt->myDoc != NULL) {\n+            if (reader->preserve == 0)\n+                xmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);\n+            reader->ctxt->myDoc = NULL;\n+        }\n@@ -2391,2 +2391,2 @@\n-    xmlFreeParserInputBuffer(reader->input);\n-    reader->allocs -= XML_TEXTREADER_INPUT;\n+        xmlFreeParserInputBuffer(reader->input);\n+        reader->allocs -= XML_TEXTREADER_INPUT;\n@@ -2416,1 +2416,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2418,1 +2418,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2420,1 +2420,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2423,1 +2423,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2427,1 +2427,1 @@\n-    ns = ns->next;\n+        ns = ns->next;\n@@ -2430,1 +2430,1 @@\n-    return(xmlStrdup(ns->href));\n+        return(xmlStrdup(ns->href));\n@@ -2433,4 +2433,0 @@\n-    if (cur == NULL)\n-    return(NULL);\n-    for (;i < no;i++) {\n-    cur = cur->next;\n@@ -2439,0 +2435,4 @@\n+    for (;i < no;i++) {\n+        cur = cur->next;\n+        if (cur == NULL)\n+            return(NULL);\n@@ -2465,1 +2465,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2467,1 +2467,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2469,1 +2469,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2473,1 +2473,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2477,8 +2477,12 @@\n-        \/*\n-         * Namespace default decl\n-         *\/\n-        if (xmlStrEqual(name, BAD_CAST \"xmlns\")) {\n-            ns = reader->node->nsDef;\n-            while (ns != NULL) {\n-                if (ns->prefix == NULL) {\n-                    return(xmlStrdup(ns->href));\n+                \/*\n+                 * Namespace default decl\n+                 *\/\n+                if (xmlStrEqual(name, BAD_CAST \"xmlns\")) {\n+                        ns = reader->node->nsDef;\n+                        while (ns != NULL) {\n+                                if (ns->prefix == NULL) {\n+                                        return(xmlStrdup(ns->href));\n+                                }\n+                                ns = ns->next;\n+                        }\n+                        return NULL;\n@@ -2486,3 +2490,1 @@\n-                ns = ns->next;\n-            }\n-            return NULL;\n+                return(xmlGetNoNsProp(reader->node, name));\n@@ -2490,2 +2492,0 @@\n-        return(xmlGetNoNsProp(reader->node, name));\n-    }\n@@ -2497,8 +2497,8 @@\n-        ns = reader->node->nsDef;\n-        while (ns != NULL) {\n-            if ((ns->prefix != NULL) && (xmlStrEqual(ns->prefix, localname))) {\n-                ret = xmlStrdup(ns->href);\n-                break;\n-            }\n-            ns = ns->next;\n-        }\n+                ns = reader->node->nsDef;\n+                while (ns != NULL) {\n+                        if ((ns->prefix != NULL) && (xmlStrEqual(ns->prefix, localname))) {\n+                                ret = xmlStrdup(ns->href);\n+                                break;\n+                        }\n+                        ns = ns->next;\n+                }\n@@ -2506,4 +2506,4 @@\n-        ns = xmlSearchNs(reader->node->doc, reader->node, prefix);\n-        if (ns != NULL)\n-            ret = xmlGetNsProp(reader->node, localname, ns->href);\n-    }\n+                ns = xmlSearchNs(reader->node->doc, reader->node, prefix);\n+                if (ns != NULL)\n+                        ret = xmlGetNsProp(reader->node, localname, ns->href);\n+        }\n@@ -2531,1 +2531,1 @@\n-                const xmlChar *namespaceURI) {\n+                            const xmlChar *namespaceURI) {\n@@ -2536,1 +2536,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2538,1 +2538,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2540,1 +2540,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2544,1 +2544,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2547,12 +2547,12 @@\n-        if (! xmlStrEqual(localName, BAD_CAST \"xmlns\")) {\n-            prefix = BAD_CAST localName;\n-        }\n-        ns = reader->node->nsDef;\n-        while (ns != NULL) {\n-            if ((prefix == NULL && ns->prefix == NULL) ||\n-                ((ns->prefix != NULL) && (xmlStrEqual(ns->prefix, localName)))) {\n-                return xmlStrdup(ns->href);\n-            }\n-            ns = ns->next;\n-        }\n-        return NULL;\n+                if (! xmlStrEqual(localName, BAD_CAST \"xmlns\")) {\n+                        prefix = BAD_CAST localName;\n+                }\n+                ns = reader->node->nsDef;\n+                while (ns != NULL) {\n+                        if ((prefix == NULL && ns->prefix == NULL) ||\n+                                ((ns->prefix != NULL) && (xmlStrEqual(ns->prefix, localName)))) {\n+                                return xmlStrdup(ns->href);\n+                        }\n+                        ns = ns->next;\n+                }\n+                return NULL;\n@@ -2584,1 +2584,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2586,1 +2586,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2592,6 +2592,6 @@\n-    xmlStopParser(reader->ctxt);\n-    if (reader->ctxt->myDoc != NULL) {\n-        if (reader->preserve == 0)\n-        xmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);\n-        reader->ctxt->myDoc = NULL;\n-    }\n+        xmlStopParser(reader->ctxt);\n+        if (reader->ctxt->myDoc != NULL) {\n+            if (reader->preserve == 0)\n+                xmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);\n+            reader->ctxt->myDoc = NULL;\n+        }\n@@ -2600,3 +2600,3 @@\n-    ret = reader->input;\n-    reader->input = NULL;\n-    reader->allocs -= XML_TEXTREADER_INPUT;\n+        ret = reader->input;\n+        reader->input = NULL;\n+        reader->allocs -= XML_TEXTREADER_INPUT;\n@@ -2604,8 +2604,8 @@\n-    \/*\n-     * Hum, one may need to duplicate the data structure because\n-     * without reference counting the input may be freed twice:\n-     *   - by the layer which allocated it.\n-     *   - by the layer to which would have been returned to.\n-     *\/\n-    TODO\n-    return(NULL);\n+        \/*\n+         * Hum, one may need to duplicate the data structure because\n+         * without reference counting the input may be freed twice:\n+         *   - by the layer which allocated it.\n+         *   - by the layer to which would have been returned to.\n+         *\/\n+        TODO\n+        return(NULL);\n@@ -2632,1 +2632,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2634,1 +2634,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2638,1 +2638,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2660,1 +2660,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2662,1 +2662,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2665,1 +2665,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2671,1 +2671,1 @@\n-    ns = ns->next;\n+        ns = ns->next;\n@@ -2674,2 +2674,2 @@\n-    reader->curnode = (xmlNodePtr) ns;\n-    return(1);\n+        reader->curnode = (xmlNodePtr) ns;\n+        return(1);\n@@ -2679,4 +2679,0 @@\n-    if (cur == NULL)\n-    return(0);\n-    for (;i < no;i++) {\n-    cur = cur->next;\n@@ -2685,0 +2681,4 @@\n+    for (;i < no;i++) {\n+        cur = cur->next;\n+        if (cur == NULL)\n+            return(0);\n@@ -2710,1 +2710,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2712,1 +2712,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2716,1 +2716,1 @@\n-    return(0);\n+        return(0);\n@@ -2720,0 +2720,32 @@\n+        \/*\n+         * Namespace default decl\n+         *\/\n+        if (xmlStrEqual(name, BAD_CAST \"xmlns\")) {\n+            ns = reader->node->nsDef;\n+            while (ns != NULL) {\n+                if (ns->prefix == NULL) {\n+                    reader->curnode = (xmlNodePtr) ns;\n+                    return(1);\n+                }\n+                ns = ns->next;\n+            }\n+            return(0);\n+        }\n+\n+        prop = reader->node->properties;\n+        while (prop != NULL) {\n+            \/*\n+             * One need to have\n+             *   - same attribute names\n+             *   - and the attribute carrying that namespace\n+             *\/\n+            if ((xmlStrEqual(prop->name, name)) &&\n+                ((prop->ns == NULL) || (prop->ns->prefix == NULL))) {\n+                reader->curnode = (xmlNodePtr) prop;\n+                return(1);\n+            }\n+            prop = prop->next;\n+        }\n+        return(0);\n+    }\n+\n@@ -2723,1 +2755,1 @@\n-    if (xmlStrEqual(name, BAD_CAST \"xmlns\")) {\n+    if (xmlStrEqual(prefix, BAD_CAST \"xmlns\")) {\n@@ -2726,3 +2758,5 @@\n-        if (ns->prefix == NULL) {\n-            reader->curnode = (xmlNodePtr) ns;\n-            return(1);\n+            if ((ns->prefix != NULL) && (xmlStrEqual(ns->prefix, localname))) {\n+                reader->curnode = (xmlNodePtr) ns;\n+                goto found;\n+            }\n+            ns = ns->next;\n@@ -2730,3 +2764,1 @@\n-        ns = ns->next;\n-        }\n-        return(0);\n+        goto not_found;\n@@ -2734,1 +2766,0 @@\n-\n@@ -2742,4 +2773,4 @@\n-        if ((xmlStrEqual(prop->name, name)) &&\n-        ((prop->ns == NULL) || (prop->ns->prefix == NULL))) {\n-        reader->curnode = (xmlNodePtr) prop;\n-        return(1);\n+        if ((xmlStrEqual(prop->name, localname)) &&\n+            (prop->ns != NULL) && (xmlStrEqual(prop->ns->prefix, prefix))) {\n+            reader->curnode = (xmlNodePtr) prop;\n+            goto found;\n@@ -2749,31 +2780,0 @@\n-    return(0);\n-    }\n-\n-    \/*\n-     * Namespace default decl\n-     *\/\n-    if (xmlStrEqual(prefix, BAD_CAST \"xmlns\")) {\n-    ns = reader->node->nsDef;\n-    while (ns != NULL) {\n-        if ((ns->prefix != NULL) && (xmlStrEqual(ns->prefix, localname))) {\n-        reader->curnode = (xmlNodePtr) ns;\n-        goto found;\n-        }\n-        ns = ns->next;\n-    }\n-    goto not_found;\n-    }\n-    prop = reader->node->properties;\n-    while (prop != NULL) {\n-    \/*\n-     * One need to have\n-     *   - same attribute names\n-     *   - and the attribute carrying that namespace\n-     *\/\n-    if ((xmlStrEqual(prop->name, localname)) &&\n-        (prop->ns != NULL) && (xmlStrEqual(prop->ns->prefix, prefix))) {\n-        reader->curnode = (xmlNodePtr) prop;\n-        goto found;\n-    }\n-    prop = prop->next;\n-    }\n@@ -2808,1 +2808,1 @@\n-    const xmlChar *localName, const xmlChar *namespaceURI) {\n+        const xmlChar *localName, const xmlChar *namespaceURI) {\n@@ -2815,1 +2815,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2817,1 +2817,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2819,1 +2819,1 @@\n-    return(0);\n+        return(0);\n@@ -2823,13 +2823,13 @@\n-        if (! xmlStrEqual(localName, BAD_CAST \"xmlns\")) {\n-            prefix = BAD_CAST localName;\n-        }\n-        ns = reader->node->nsDef;\n-        while (ns != NULL) {\n-            if ((prefix == NULL && ns->prefix == NULL) ||\n-                ((ns->prefix != NULL) && (xmlStrEqual(ns->prefix, localName)))) {\n-                reader->curnode = (xmlNodePtr) ns;\n-                return(1);\n-            }\n-            ns = ns->next;\n-        }\n-        return(0);\n+                if (! xmlStrEqual(localName, BAD_CAST \"xmlns\")) {\n+                        prefix = BAD_CAST localName;\n+                }\n+                ns = reader->node->nsDef;\n+                while (ns != NULL) {\n+                        if ((prefix == NULL && ns->prefix == NULL) ||\n+                                ((ns->prefix != NULL) && (xmlStrEqual(ns->prefix, localName)))) {\n+                                reader->curnode = (xmlNodePtr) ns;\n+                                return(1);\n+                        }\n+                        ns = ns->next;\n+                }\n+                return(0);\n@@ -2840,5 +2840,5 @@\n-    \/*\n-     * One need to have\n-     *   - same attribute names\n-     *   - and the attribute carrying that namespace\n-     *\/\n+        \/*\n+         * One need to have\n+         *   - same attribute names\n+         *   - and the attribute carrying that namespace\n+         *\/\n@@ -2846,4 +2846,4 @@\n-        ((prop->ns != NULL) &&\n-         (xmlStrEqual(prop->ns->href, namespaceURI)))) {\n-        reader->curnode = (xmlNodePtr) prop;\n-        return(1);\n+            ((prop->ns != NULL) &&\n+             (xmlStrEqual(prop->ns->href, namespaceURI)))) {\n+            reader->curnode = (xmlNodePtr) prop;\n+            return(1);\n@@ -2851,1 +2851,1 @@\n-    prop = prop->next;\n+        prop = prop->next;\n@@ -2868,1 +2868,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2870,1 +2870,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2872,1 +2872,1 @@\n-    return(0);\n+        return(0);\n@@ -2875,2 +2875,2 @@\n-    reader->curnode = (xmlNodePtr) reader->node->nsDef;\n-    return(1);\n+        reader->curnode = (xmlNodePtr) reader->node->nsDef;\n+        return(1);\n@@ -2879,2 +2879,2 @@\n-    reader->curnode = (xmlNodePtr) reader->node->properties;\n-    return(1);\n+        reader->curnode = (xmlNodePtr) reader->node->properties;\n+        return(1);\n@@ -2897,1 +2897,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2899,1 +2899,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2901,1 +2901,1 @@\n-    return(0);\n+        return(0);\n@@ -2903,1 +2903,1 @@\n-    return(xmlTextReaderMoveToFirstAttribute(reader));\n+        return(xmlTextReaderMoveToFirstAttribute(reader));\n@@ -2906,10 +2906,10 @@\n-    xmlNsPtr ns = (xmlNsPtr) reader->curnode;\n-    if (ns->next != NULL) {\n-        reader->curnode = (xmlNodePtr) ns->next;\n-        return(1);\n-    }\n-    if (reader->node->properties != NULL) {\n-        reader->curnode = (xmlNodePtr) reader->node->properties;\n-        return(1);\n-    }\n-    return(0);\n+        xmlNsPtr ns = (xmlNsPtr) reader->curnode;\n+        if (ns->next != NULL) {\n+            reader->curnode = (xmlNodePtr) ns->next;\n+            return(1);\n+        }\n+        if (reader->node->properties != NULL) {\n+            reader->curnode = (xmlNodePtr) reader->node->properties;\n+            return(1);\n+        }\n+        return(0);\n@@ -2917,3 +2917,3 @@\n-           (reader->curnode->next != NULL)) {\n-    reader->curnode = reader->curnode->next;\n-    return(1);\n+               (reader->curnode->next != NULL)) {\n+        reader->curnode = reader->curnode->next;\n+        return(1);\n@@ -2936,1 +2936,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2938,1 +2938,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2940,1 +2940,1 @@\n-    return(0);\n+        return(0);\n@@ -2942,2 +2942,2 @@\n-    reader->curnode = NULL;\n-    return(1);\n+        reader->curnode = NULL;\n+        return(1);\n@@ -2961,1 +2961,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2963,1 +2963,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2965,3 +2965,0 @@\n-    return(0);\n-    if (reader->curnode->type == XML_ATTRIBUTE_NODE) {\n-    if (reader->curnode->children == NULL)\n@@ -2969,1 +2966,4 @@\n-    reader->curnode = reader->curnode->children;\n+    if (reader->curnode->type == XML_ATTRIBUTE_NODE) {\n+        if (reader->curnode->children == NULL)\n+            return(0);\n+        reader->curnode = reader->curnode->children;\n@@ -2971,1 +2971,1 @@\n-    xmlNsPtr ns = (xmlNsPtr) reader->curnode;\n+        xmlNsPtr ns = (xmlNsPtr) reader->curnode;\n@@ -2973,4 +2973,4 @@\n-    if (reader->faketext == NULL) {\n-        reader->faketext = xmlNewDocText(reader->node->doc,\n-                                     ns->href);\n-    } else {\n+        if (reader->faketext == NULL) {\n+            reader->faketext = xmlNewDocText(reader->node->doc,\n+                                             ns->href);\n+        } else {\n@@ -2978,6 +2978,6 @@\n-            (reader->faketext->content !=\n-         (xmlChar *) &(reader->faketext->properties)))\n-        xmlFree(reader->faketext->content);\n-        reader->faketext->content = xmlStrdup(ns->href);\n-    }\n-    reader->curnode = reader->faketext;\n+                (reader->faketext->content !=\n+                 (xmlChar *) &(reader->faketext->properties)))\n+                xmlFree(reader->faketext->content);\n+            reader->faketext->content = xmlStrdup(ns->href);\n+        }\n+        reader->curnode = reader->faketext;\n@@ -2985,3 +2985,3 @@\n-    if (reader->curnode->next == NULL)\n-        return(0);\n-    reader->curnode = reader->curnode->next;\n+        if (reader->curnode->next == NULL)\n+            return(0);\n+        reader->curnode = reader->curnode->next;\n@@ -3005,1 +3005,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3009,1 +3009,1 @@\n-    doc = reader->ctxt->myDoc;\n+        doc = reader->ctxt->myDoc;\n@@ -3011,1 +3011,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3014,1 +3014,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3021,3 +3021,3 @@\n- *                                  *\n- *          Access API to the current node          *\n- *                                  *\n+ *                                                                      *\n+ *                      Access API to the current node                  *\n+ *                                                                      *\n@@ -3041,1 +3041,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3043,1 +3043,1 @@\n-    return(0);\n+        return(0);\n@@ -3046,1 +3046,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3048,1 +3048,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3051,1 +3051,1 @@\n-    return(0);\n+        return(0);\n@@ -3053,2 +3053,2 @@\n-    (reader->state == XML_TEXTREADER_BACKTRACK))\n-    return(0);\n+        (reader->state == XML_TEXTREADER_BACKTRACK))\n+        return(0);\n@@ -3058,2 +3058,2 @@\n-    ret++;\n-    attr = attr->next;\n+        ret++;\n+        attr = attr->next;\n@@ -3063,2 +3063,2 @@\n-    ret++;\n-    ns = ns->next;\n+        ret++;\n+        ns = ns->next;\n@@ -3084,1 +3084,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3086,1 +3086,1 @@\n-    return(XML_READER_TYPE_NONE);\n+        return(XML_READER_TYPE_NONE);\n@@ -3088,1 +3088,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3090,1 +3090,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3093,4 +3093,4 @@\n-        if ((reader->state == XML_TEXTREADER_END) ||\n-        (reader->state == XML_TEXTREADER_BACKTRACK))\n-        return(XML_READER_TYPE_END_ELEMENT);\n-        return(XML_READER_TYPE_ELEMENT);\n+            if ((reader->state == XML_TEXTREADER_END) ||\n+                (reader->state == XML_TEXTREADER_BACKTRACK))\n+                return(XML_READER_TYPE_END_ELEMENT);\n+            return(XML_READER_TYPE_ELEMENT);\n@@ -3099,1 +3099,1 @@\n-        return(XML_READER_TYPE_ATTRIBUTE);\n+            return(XML_READER_TYPE_ATTRIBUTE);\n@@ -3101,8 +3101,8 @@\n-        if (xmlIsBlankNode(reader->node)) {\n-        if (xmlNodeGetSpacePreserve(reader->node))\n-            return(XML_READER_TYPE_SIGNIFICANT_WHITESPACE);\n-        else\n-            return(XML_READER_TYPE_WHITESPACE);\n-        } else {\n-        return(XML_READER_TYPE_TEXT);\n-        }\n+            if (xmlIsBlankNode(reader->node)) {\n+                if (xmlNodeGetSpacePreserve(reader->node))\n+                    return(XML_READER_TYPE_SIGNIFICANT_WHITESPACE);\n+                else\n+                    return(XML_READER_TYPE_WHITESPACE);\n+            } else {\n+                return(XML_READER_TYPE_TEXT);\n+            }\n@@ -3110,1 +3110,1 @@\n-        return(XML_READER_TYPE_CDATA);\n+            return(XML_READER_TYPE_CDATA);\n@@ -3112,1 +3112,1 @@\n-        return(XML_READER_TYPE_ENTITY_REFERENCE);\n+            return(XML_READER_TYPE_ENTITY_REFERENCE);\n@@ -3114,1 +3114,1 @@\n-        return(XML_READER_TYPE_ENTITY);\n+            return(XML_READER_TYPE_ENTITY);\n@@ -3116,1 +3116,1 @@\n-        return(XML_READER_TYPE_PROCESSING_INSTRUCTION);\n+            return(XML_READER_TYPE_PROCESSING_INSTRUCTION);\n@@ -3118,1 +3118,1 @@\n-        return(XML_READER_TYPE_COMMENT);\n+            return(XML_READER_TYPE_COMMENT);\n@@ -3124,1 +3124,1 @@\n-        return(XML_READER_TYPE_DOCUMENT);\n+            return(XML_READER_TYPE_DOCUMENT);\n@@ -3126,1 +3126,1 @@\n-        return(XML_READER_TYPE_DOCUMENT_FRAGMENT);\n+            return(XML_READER_TYPE_DOCUMENT_FRAGMENT);\n@@ -3128,1 +3128,1 @@\n-        return(XML_READER_TYPE_NOTATION);\n+            return(XML_READER_TYPE_NOTATION);\n@@ -3131,1 +3131,1 @@\n-        return(XML_READER_TYPE_DOCUMENT_TYPE);\n+            return(XML_READER_TYPE_DOCUMENT_TYPE);\n@@ -3138,1 +3138,1 @@\n-        return(XML_READER_TYPE_NONE);\n+            return(XML_READER_TYPE_NONE);\n@@ -3154,1 +3154,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3156,1 +3156,1 @@\n-    return(0);\n+        return(0);\n@@ -3158,1 +3158,1 @@\n-    return(0);\n+        return(0);\n@@ -3160,1 +3160,1 @@\n-    return(0);\n+        return(0);\n@@ -3162,1 +3162,1 @@\n-    return(0);\n+        return(0);\n@@ -3185,1 +3185,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3187,1 +3187,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3189,1 +3189,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3191,5 +3191,5 @@\n-    xmlNsPtr ns = (xmlNsPtr) node;\n-    if (ns->prefix == NULL)\n-        return(xmlStrdup(BAD_CAST \"xmlns\"));\n-    else\n-        return(xmlStrdup(ns->prefix));\n+        xmlNsPtr ns = (xmlNsPtr) node;\n+        if (ns->prefix == NULL)\n+            return(xmlStrdup(BAD_CAST \"xmlns\"));\n+        else\n+            return(xmlStrdup(ns->prefix));\n@@ -3198,2 +3198,2 @@\n-    (node->type != XML_ATTRIBUTE_NODE))\n-    return(xmlTextReaderName(reader));\n+        (node->type != XML_ATTRIBUTE_NODE))\n+        return(xmlTextReaderName(reader));\n@@ -3216,1 +3216,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3218,1 +3218,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3220,1 +3220,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3222,5 +3222,5 @@\n-    xmlNsPtr ns = (xmlNsPtr) node;\n-    if (ns->prefix == NULL)\n-        return(CONSTSTR(BAD_CAST \"xmlns\"));\n-    else\n-        return(ns->prefix);\n+        xmlNsPtr ns = (xmlNsPtr) node;\n+        if (ns->prefix == NULL)\n+            return(CONSTSTR(BAD_CAST \"xmlns\"));\n+        else\n+            return(ns->prefix);\n@@ -3229,2 +3229,2 @@\n-    (node->type != XML_ATTRIBUTE_NODE))\n-    return(xmlTextReaderConstName(reader));\n+        (node->type != XML_ATTRIBUTE_NODE))\n+        return(xmlTextReaderConstName(reader));\n@@ -3249,1 +3249,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3251,1 +3251,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3253,1 +3253,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3257,8 +3257,8 @@\n-        if ((node->ns == NULL) ||\n-        (node->ns->prefix == NULL))\n-        return(xmlStrdup(node->name));\n-\n-        ret = xmlStrdup(node->ns->prefix);\n-        ret = xmlStrcat(ret, BAD_CAST \":\");\n-        ret = xmlStrcat(ret, node->name);\n-        return(ret);\n+            if ((node->ns == NULL) ||\n+                (node->ns->prefix == NULL))\n+                return(xmlStrdup(node->name));\n+\n+            ret = xmlStrdup(node->ns->prefix);\n+            ret = xmlStrcat(ret, BAD_CAST \":\");\n+            ret = xmlStrcat(ret, node->name);\n+            return(ret);\n@@ -3266,1 +3266,1 @@\n-        return(xmlStrdup(BAD_CAST \"#text\"));\n+            return(xmlStrdup(BAD_CAST \"#text\"));\n@@ -3268,1 +3268,1 @@\n-        return(xmlStrdup(BAD_CAST \"#cdata-section\"));\n+            return(xmlStrdup(BAD_CAST \"#cdata-section\"));\n@@ -3271,1 +3271,1 @@\n-        return(xmlStrdup(node->name));\n+            return(xmlStrdup(node->name));\n@@ -3273,1 +3273,1 @@\n-        return(xmlStrdup(node->name));\n+            return(xmlStrdup(node->name));\n@@ -3275,1 +3275,1 @@\n-        return(xmlStrdup(BAD_CAST \"#comment\"));\n+            return(xmlStrdup(BAD_CAST \"#comment\"));\n@@ -3281,1 +3281,1 @@\n-        return(xmlStrdup(BAD_CAST \"#document\"));\n+            return(xmlStrdup(BAD_CAST \"#document\"));\n@@ -3283,1 +3283,1 @@\n-        return(xmlStrdup(BAD_CAST \"#document-fragment\"));\n+            return(xmlStrdup(BAD_CAST \"#document-fragment\"));\n@@ -3285,1 +3285,1 @@\n-        return(xmlStrdup(node->name));\n+            return(xmlStrdup(node->name));\n@@ -3288,1 +3288,1 @@\n-        return(xmlStrdup(node->name));\n+            return(xmlStrdup(node->name));\n@@ -3290,9 +3290,9 @@\n-        xmlNsPtr ns = (xmlNsPtr) node;\n-\n-        ret = xmlStrdup(BAD_CAST \"xmlns\");\n-        if (ns->prefix == NULL)\n-        return(ret);\n-        ret = xmlStrcat(ret, BAD_CAST \":\");\n-        ret = xmlStrcat(ret, ns->prefix);\n-        return(ret);\n-    }\n+            xmlNsPtr ns = (xmlNsPtr) node;\n+\n+            ret = xmlStrdup(BAD_CAST \"xmlns\");\n+            if (ns->prefix == NULL)\n+                return(ret);\n+            ret = xmlStrcat(ret, BAD_CAST \":\");\n+            ret = xmlStrcat(ret, ns->prefix);\n+            return(ret);\n+        }\n@@ -3305,1 +3305,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -3324,1 +3324,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3326,1 +3326,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3328,1 +3328,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3332,4 +3332,4 @@\n-        if ((node->ns == NULL) ||\n-        (node->ns->prefix == NULL))\n-        return(node->name);\n-        return(CONSTQSTR(node->ns->prefix, node->name));\n+            if ((node->ns == NULL) ||\n+                (node->ns->prefix == NULL))\n+                return(node->name);\n+            return(CONSTQSTR(node->ns->prefix, node->name));\n@@ -3337,1 +3337,1 @@\n-        return(CONSTSTR(BAD_CAST \"#text\"));\n+            return(CONSTSTR(BAD_CAST \"#text\"));\n@@ -3339,1 +3339,1 @@\n-        return(CONSTSTR(BAD_CAST \"#cdata-section\"));\n+            return(CONSTSTR(BAD_CAST \"#cdata-section\"));\n@@ -3342,1 +3342,1 @@\n-        return(CONSTSTR(node->name));\n+            return(CONSTSTR(node->name));\n@@ -3344,1 +3344,1 @@\n-        return(CONSTSTR(node->name));\n+            return(CONSTSTR(node->name));\n@@ -3346,1 +3346,1 @@\n-        return(CONSTSTR(BAD_CAST \"#comment\"));\n+            return(CONSTSTR(BAD_CAST \"#comment\"));\n@@ -3352,1 +3352,1 @@\n-        return(CONSTSTR(BAD_CAST \"#document\"));\n+            return(CONSTSTR(BAD_CAST \"#document\"));\n@@ -3354,1 +3354,1 @@\n-        return(CONSTSTR(BAD_CAST \"#document-fragment\"));\n+            return(CONSTSTR(BAD_CAST \"#document-fragment\"));\n@@ -3356,1 +3356,1 @@\n-        return(CONSTSTR(node->name));\n+            return(CONSTSTR(node->name));\n@@ -3359,1 +3359,1 @@\n-        return(CONSTSTR(node->name));\n+            return(CONSTSTR(node->name));\n@@ -3361,1 +3361,1 @@\n-        xmlNsPtr ns = (xmlNsPtr) node;\n+            xmlNsPtr ns = (xmlNsPtr) node;\n@@ -3363,4 +3363,4 @@\n-        if (ns->prefix == NULL)\n-        return(CONSTSTR(BAD_CAST \"xmlns\"));\n-        return(CONSTQSTR(BAD_CAST \"xmlns\", ns->prefix));\n-    }\n+            if (ns->prefix == NULL)\n+                return(CONSTSTR(BAD_CAST \"xmlns\"));\n+            return(CONSTQSTR(BAD_CAST \"xmlns\", ns->prefix));\n+        }\n@@ -3373,1 +3373,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -3391,1 +3391,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3393,1 +3393,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3395,1 +3395,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3397,4 +3397,4 @@\n-    xmlNsPtr ns = (xmlNsPtr) node;\n-    if (ns->prefix == NULL)\n-        return(NULL);\n-    return(xmlStrdup(BAD_CAST \"xmlns\"));\n+        xmlNsPtr ns = (xmlNsPtr) node;\n+        if (ns->prefix == NULL)\n+            return(NULL);\n+        return(xmlStrdup(BAD_CAST \"xmlns\"));\n@@ -3403,2 +3403,2 @@\n-    (node->type != XML_ATTRIBUTE_NODE))\n-    return(NULL);\n+        (node->type != XML_ATTRIBUTE_NODE))\n+        return(NULL);\n@@ -3406,1 +3406,1 @@\n-    return(xmlStrdup(node->ns->prefix));\n+        return(xmlStrdup(node->ns->prefix));\n@@ -3423,1 +3423,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3425,1 +3425,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3427,1 +3427,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3429,4 +3429,4 @@\n-    xmlNsPtr ns = (xmlNsPtr) node;\n-    if (ns->prefix == NULL)\n-        return(NULL);\n-    return(CONSTSTR(BAD_CAST \"xmlns\"));\n+        xmlNsPtr ns = (xmlNsPtr) node;\n+        if (ns->prefix == NULL)\n+            return(NULL);\n+        return(CONSTSTR(BAD_CAST \"xmlns\"));\n@@ -3435,2 +3435,2 @@\n-    (node->type != XML_ATTRIBUTE_NODE))\n-    return(NULL);\n+        (node->type != XML_ATTRIBUTE_NODE))\n+        return(NULL);\n@@ -3438,1 +3438,1 @@\n-    return(CONSTSTR(node->ns->prefix));\n+        return(CONSTSTR(node->ns->prefix));\n@@ -3455,1 +3455,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3457,1 +3457,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3459,1 +3459,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3461,1 +3461,1 @@\n-    return(xmlStrdup(BAD_CAST \"http:\/\/www.w3.org\/2000\/xmlns\/\"));\n+        return(xmlStrdup(BAD_CAST \"http:\/\/www.w3.org\/2000\/xmlns\/\"));\n@@ -3463,2 +3463,2 @@\n-    (node->type != XML_ATTRIBUTE_NODE))\n-    return(NULL);\n+        (node->type != XML_ATTRIBUTE_NODE))\n+        return(NULL);\n@@ -3466,1 +3466,1 @@\n-    return(xmlStrdup(node->ns->href));\n+        return(xmlStrdup(node->ns->href));\n@@ -3483,1 +3483,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3485,1 +3485,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3487,1 +3487,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3489,1 +3489,1 @@\n-    return(CONSTSTR(BAD_CAST \"http:\/\/www.w3.org\/2000\/xmlns\/\"));\n+        return(CONSTSTR(BAD_CAST \"http:\/\/www.w3.org\/2000\/xmlns\/\"));\n@@ -3491,2 +3491,2 @@\n-    (node->type != XML_ATTRIBUTE_NODE))\n-    return(NULL);\n+        (node->type != XML_ATTRIBUTE_NODE))\n+        return(NULL);\n@@ -3494,1 +3494,1 @@\n-    return(CONSTSTR(node->ns->href));\n+        return(CONSTSTR(node->ns->href));\n@@ -3510,1 +3510,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3529,1 +3529,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3549,1 +3549,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3551,1 +3551,1 @@\n-    return(0);\n+        return(0);\n@@ -3554,4 +3554,4 @@\n-    if ((reader->curnode->type == XML_ATTRIBUTE_NODE) ||\n-        (reader->curnode->type == XML_NAMESPACE_DECL))\n-        return(reader->depth + 1);\n-    return(reader->depth + 2);\n+        if ((reader->curnode->type == XML_ATTRIBUTE_NODE) ||\n+            (reader->curnode->type == XML_NAMESPACE_DECL))\n+            return(reader->depth + 1);\n+        return(reader->depth + 2);\n@@ -3574,1 +3574,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3576,1 +3576,1 @@\n-    return(0);\n+        return(0);\n@@ -3578,1 +3578,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3580,1 +3580,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3583,2 +3583,2 @@\n-    ((node->properties != NULL) || (node->nsDef != NULL)))\n-    return(1);\n+        ((node->properties != NULL) || (node->nsDef != NULL)))\n+        return(1);\n@@ -3601,1 +3601,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3603,1 +3603,1 @@\n-    return(0);\n+        return(0);\n@@ -3605,1 +3605,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3607,1 +3607,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3616,3 +3616,3 @@\n-        return(1);\n-    default:\n-        break;\n+            return(1);\n+        default:\n+            break;\n@@ -3636,1 +3636,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3638,1 +3638,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3640,1 +3640,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3642,1 +3642,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3646,1 +3646,1 @@\n-        return(xmlStrdup(((xmlNsPtr) node)->href));\n+            return(xmlStrdup(((xmlNsPtr) node)->href));\n@@ -3648,1 +3648,1 @@\n-        xmlAttrPtr attr = (xmlAttrPtr) node;\n+            xmlAttrPtr attr = (xmlAttrPtr) node;\n@@ -3650,7 +3650,7 @@\n-        if (attr->parent != NULL)\n-        return (xmlNodeListGetString\n-            (attr->parent->doc, attr->children, 1));\n-        else\n-        return (xmlNodeListGetString(NULL, attr->children, 1));\n-        break;\n-    }\n+            if (attr->parent != NULL)\n+                return (xmlNodeListGetString\n+                        (attr->parent->doc, attr->children, 1));\n+            else\n+                return (xmlNodeListGetString(NULL, attr->children, 1));\n+            break;\n+        }\n@@ -3663,2 +3663,2 @@\n-    default:\n-        break;\n+        default:\n+            break;\n@@ -3682,1 +3682,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3684,1 +3684,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3686,1 +3686,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3688,1 +3688,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3692,1 +3692,1 @@\n-        return(((xmlNsPtr) node)->href);\n+            return(((xmlNsPtr) node)->href);\n@@ -3694,10 +3694,10 @@\n-        xmlAttrPtr attr = (xmlAttrPtr) node;\n-        const xmlChar *ret;\n-\n-        if ((attr->children != NULL) &&\n-            (attr->children->type == XML_TEXT_NODE) &&\n-        (attr->children->next == NULL))\n-        return(attr->children->content);\n-        else {\n-        if (reader->buffer == NULL) {\n-            reader->buffer = xmlBufCreateSize(100);\n+            xmlAttrPtr attr = (xmlAttrPtr) node;\n+            const xmlChar *ret;\n+\n+            if ((attr->children != NULL) &&\n+                (attr->children->type == XML_TEXT_NODE) &&\n+                (attr->children->next == NULL))\n+                return(attr->children->content);\n+            else {\n+                if (reader->buffer == NULL) {\n+                    reader->buffer = xmlBufCreateSize(100);\n@@ -3709,2 +3709,2 @@\n-            xmlBufSetAllocationScheme(reader->buffer,\n-                                      XML_BUFFER_ALLOC_BOUNDED);\n+                    xmlBufSetAllocationScheme(reader->buffer,\n+                                              XML_BUFFER_ALLOC_BOUNDED);\n@@ -3713,11 +3713,13 @@\n-            xmlBufGetNodeContent(reader->buffer, node);\n-        ret = xmlBufContent(reader->buffer);\n-        if (ret == NULL) {\n-            \/* error on the buffer best to reallocate *\/\n-            xmlBufFree(reader->buffer);\n-            reader->buffer = xmlBufCreateSize(100);\n-            xmlBufSetAllocationScheme(reader->buffer,\n-                                      XML_BUFFER_ALLOC_BOUNDED);\n-            ret = BAD_CAST \"\";\n-        }\n-        return(ret);\n+                xmlBufGetNodeContent(reader->buffer, node);\n+                ret = xmlBufContent(reader->buffer);\n+                if (ret == NULL) {\n+                    \/* error on the buffer best to reallocate *\/\n+                    xmlBufFree(reader->buffer);\n+                    reader->buffer = xmlBufCreateSize(100);\n+                    xmlBufSetAllocationScheme(reader->buffer,\n+                                              XML_BUFFER_ALLOC_BOUNDED);\n+                    ret = BAD_CAST \"\";\n+                }\n+                return(ret);\n+            }\n+            break;\n@@ -3725,2 +3727,0 @@\n-        break;\n-    }\n@@ -3731,3 +3731,3 @@\n-        return(node->content);\n-    default:\n-        break;\n+            return(node->content);\n+        default:\n+            break;\n@@ -3750,1 +3750,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3765,1 +3765,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3782,1 +3782,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3784,1 +3784,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3802,1 +3802,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3804,1 +3804,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3827,1 +3827,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3846,1 +3846,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3851,3 +3851,3 @@\n- *                                  *\n- *          Extensions to the base APIs         *\n- *                                  *\n+ *                                                                      *\n+ *                      Extensions to the base APIs                     *\n+ *                                                                      *\n@@ -3874,1 +3874,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3879,10 +3879,10 @@\n-        if (value != 0) {\n-        if (ctxt->loadsubset == 0) {\n-            if (reader->mode != XML_TEXTREADER_MODE_INITIAL)\n-            return(-1);\n-            ctxt->loadsubset = XML_DETECT_IDS;\n-        }\n-        } else {\n-        ctxt->loadsubset = 0;\n-        }\n-        return(0);\n+            if (value != 0) {\n+                if (ctxt->loadsubset == 0) {\n+                    if (reader->mode != XML_TEXTREADER_MODE_INITIAL)\n+                        return(-1);\n+                    ctxt->loadsubset = XML_DETECT_IDS;\n+                }\n+            } else {\n+                ctxt->loadsubset = 0;\n+            }\n+            return(0);\n@@ -3890,7 +3890,7 @@\n-        if (value != 0) {\n-        ctxt->loadsubset |= XML_COMPLETE_ATTRS;\n-        } else {\n-        if (ctxt->loadsubset & XML_COMPLETE_ATTRS)\n-            ctxt->loadsubset -= XML_COMPLETE_ATTRS;\n-        }\n-        return(0);\n+            if (value != 0) {\n+                ctxt->loadsubset |= XML_COMPLETE_ATTRS;\n+            } else {\n+                if (ctxt->loadsubset & XML_COMPLETE_ATTRS)\n+                    ctxt->loadsubset -= XML_COMPLETE_ATTRS;\n+            }\n+            return(0);\n@@ -3898,1 +3898,1 @@\n-        if (value != 0) {\n+            if (value != 0) {\n@@ -3900,3 +3900,3 @@\n-        ctxt->validate = 1;\n-        reader->validate = XML_TEXTREADER_VALIDATE_DTD;\n-        } else {\n+                ctxt->validate = 1;\n+                reader->validate = XML_TEXTREADER_VALIDATE_DTD;\n+            } else {\n@@ -3904,3 +3904,3 @@\n-        ctxt->validate = 0;\n-        }\n-        return(0);\n+                ctxt->validate = 0;\n+            }\n+            return(0);\n@@ -3908,1 +3908,1 @@\n-        if (value != 0) {\n+            if (value != 0) {\n@@ -3910,2 +3910,2 @@\n-        ctxt->replaceEntities = 1;\n-        } else {\n+                ctxt->replaceEntities = 1;\n+            } else {\n@@ -3913,3 +3913,3 @@\n-        ctxt->replaceEntities = 0;\n-        }\n-        return(0);\n+                ctxt->replaceEntities = 0;\n+            }\n+            return(0);\n@@ -3935,1 +3935,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3940,3 +3940,3 @@\n-        if ((ctxt->loadsubset != 0) || (ctxt->validate != 0))\n-        return(1);\n-        return(0);\n+            if ((ctxt->loadsubset != 0) || (ctxt->validate != 0))\n+                return(1);\n+            return(0);\n@@ -3944,3 +3944,3 @@\n-        if (ctxt->loadsubset & XML_COMPLETE_ATTRS)\n-        return(1);\n-        return(0);\n+            if (ctxt->loadsubset & XML_COMPLETE_ATTRS)\n+                return(1);\n+            return(0);\n@@ -3948,3 +3948,3 @@\n-        return(reader->validate);\n-    case XML_PARSER_SUBST_ENTITIES:\n-        return(ctxt->replaceEntities);\n+            return(reader->validate);\n+        case XML_PARSER_SUBST_ENTITIES:\n+            return(ctxt->replaceEntities);\n@@ -4005,1 +4005,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4008,1 +4008,1 @@\n-    return(reader->curnode);\n+        return(reader->curnode);\n@@ -4027,1 +4027,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4037,2 +4037,2 @@\n-    cur->extra |= NODE_IS_PRESERVED;\n-    cur->extra |= NODE_IS_SPRESERVED;\n+        cur->extra |= NODE_IS_PRESERVED;\n+        cur->extra |= NODE_IS_SPRESERVED;\n@@ -4045,2 +4045,2 @@\n-        parent->extra |= NODE_IS_PRESERVED;\n-    parent = parent->parent;\n+            parent->extra |= NODE_IS_PRESERVED;\n+        parent = parent->parent;\n@@ -4071,1 +4071,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4078,3 +4078,3 @@\n-    reader->patternMax = 4;\n-    reader->patternTab = (xmlPatternPtr *) xmlMalloc(reader->patternMax *\n-                          sizeof(reader->patternTab[0]));\n+        reader->patternMax = 4;\n+        reader->patternTab = (xmlPatternPtr *) xmlMalloc(reader->patternMax *\n+                                              sizeof(reader->patternTab[0]));\n@@ -4089,1 +4089,1 @@\n-    tmp = (xmlPatternPtr *) xmlRealloc(reader->patternTab,\n+        tmp = (xmlPatternPtr *) xmlRealloc(reader->patternTab,\n@@ -4094,1 +4094,1 @@\n-        reader->patternMax \/= 2;\n+            reader->patternMax \/= 2;\n@@ -4097,1 +4097,1 @@\n-    reader->patternTab = tmp;\n+        reader->patternTab = tmp;\n@@ -4119,1 +4119,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4123,1 +4123,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4224,3 +4224,3 @@\n-        xmlRelaxNGFree(reader->rngSchemas);\n-        reader->rngSchemas = NULL;\n-    }\n+            xmlRelaxNGFree(reader->rngSchemas);\n+            reader->rngSchemas = NULL;\n+        }\n@@ -4228,3 +4228,3 @@\n-        if (! reader->rngPreserveCtxt)\n-        xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);\n-        reader->rngValidCtxt = NULL;\n+            if (! reader->rngPreserveCtxt)\n+                xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);\n+            reader->rngValidCtxt = NULL;\n@@ -4232,2 +4232,2 @@\n-    reader->rngPreserveCtxt = 0;\n-    return(0);\n+        reader->rngPreserveCtxt = 0;\n+        return(0);\n@@ -4236,1 +4236,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4238,2 +4238,2 @@\n-    xmlRelaxNGFree(reader->rngSchemas);\n-    reader->rngSchemas = NULL;\n+        xmlRelaxNGFree(reader->rngSchemas);\n+        reader->rngSchemas = NULL;\n@@ -4242,3 +4242,3 @@\n-    if (! reader->rngPreserveCtxt)\n-        xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);\n-    reader->rngValidCtxt = NULL;\n+        if (! reader->rngPreserveCtxt)\n+            xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);\n+        reader->rngValidCtxt = NULL;\n@@ -4251,4 +4251,4 @@\n-    xmlRelaxNGSetValidErrors(reader->rngValidCtxt,\n-            xmlTextReaderValidityErrorRelay,\n-            xmlTextReaderValidityWarningRelay,\n-            reader);\n+        xmlRelaxNGSetValidErrors(reader->rngValidCtxt,\n+                        xmlTextReaderValidityErrorRelay,\n+                        xmlTextReaderValidityWarningRelay,\n+                        reader);\n@@ -4256,4 +4256,4 @@\n-    if (reader->sErrorFunc != NULL) {\n-        xmlRelaxNGSetValidStructuredErrors(reader->rngValidCtxt,\n-            xmlTextReaderValidityStructuredRelay,\n-            reader);\n+        if (reader->sErrorFunc != NULL) {\n+                xmlRelaxNGSetValidStructuredErrors(reader->rngValidCtxt,\n+                        xmlTextReaderValidityStructuredRelay,\n+                        reader);\n@@ -4292,5 +4292,5 @@\n-    if (file != NULL)\n-        *file = reader->ctxt->input->filename;\n-    if (line != NULL)\n-        *line = reader->ctxt->input->line;\n-    return(0);\n+        if (file != NULL)\n+            *file = reader->ctxt->input->filename;\n+        if (line != NULL)\n+            *line = reader->ctxt->input->line;\n+        return(0);\n@@ -4300,1 +4300,1 @@\n-    int ret = 0;\n+        int ret = 0;\n@@ -4302,5 +4302,5 @@\n-    if (line != NULL) {\n-        res = xmlGetLineNo(reader->node);\n-        if (res > 0)\n-            *line = (unsigned long) res;\n-        else\n+        if (line != NULL) {\n+            res = xmlGetLineNo(reader->node);\n+            if (res > 0)\n+                *line = (unsigned long) res;\n+            else\n@@ -4308,1 +4308,1 @@\n-    }\n+        }\n@@ -4310,4 +4310,4 @@\n-        xmlDocPtr doc = reader->node->doc;\n-        if ((doc != NULL) && (doc->URL != NULL))\n-            *file = (const char *) doc->URL;\n-        else\n+            xmlDocPtr doc = reader->node->doc;\n+            if ((doc != NULL) && (doc->URL != NULL))\n+                *file = (const char *) doc->URL;\n+            else\n@@ -4315,2 +4315,2 @@\n-    }\n-    return(ret);\n+        }\n+        return(ret);\n@@ -4340,4 +4340,4 @@\n-    if (reader->xsdPlug != NULL) {\n-        xmlSchemaSAXUnplug(reader->xsdPlug);\n-        reader->xsdPlug = NULL;\n-    }\n+        if (reader->xsdPlug != NULL) {\n+            xmlSchemaSAXUnplug(reader->xsdPlug);\n+            reader->xsdPlug = NULL;\n+        }\n@@ -4345,3 +4345,3 @@\n-        if (! reader->xsdPreserveCtxt)\n-        xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n-        reader->xsdValidCtxt = NULL;\n+            if (! reader->xsdPreserveCtxt)\n+                xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n+            reader->xsdValidCtxt = NULL;\n@@ -4349,1 +4349,1 @@\n-    reader->xsdPreserveCtxt = 0;\n+        reader->xsdPreserveCtxt = 0;\n@@ -4351,4 +4351,4 @@\n-        xmlSchemaFree(reader->xsdSchemas);\n-        reader->xsdSchemas = NULL;\n-    }\n-    return(0);\n+            xmlSchemaFree(reader->xsdSchemas);\n+            reader->xsdSchemas = NULL;\n+        }\n+        return(0);\n@@ -4357,1 +4357,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4359,2 +4359,2 @@\n-    xmlSchemaSAXUnplug(reader->xsdPlug);\n-    reader->xsdPlug = NULL;\n+        xmlSchemaSAXUnplug(reader->xsdPlug);\n+        reader->xsdPlug = NULL;\n@@ -4363,3 +4363,3 @@\n-    if (! reader->xsdPreserveCtxt)\n-        xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n-    reader->xsdValidCtxt = NULL;\n+        if (! reader->xsdPreserveCtxt)\n+            xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n+        reader->xsdValidCtxt = NULL;\n@@ -4369,2 +4369,2 @@\n-    xmlSchemaFree(reader->xsdSchemas);\n-    reader->xsdSchemas = NULL;\n+        xmlSchemaFree(reader->xsdSchemas);\n+        reader->xsdSchemas = NULL;\n@@ -4374,2 +4374,2 @@\n-    xmlSchemaFree(reader->xsdSchemas);\n-    reader->xsdSchemas = NULL;\n+        xmlSchemaFree(reader->xsdSchemas);\n+        reader->xsdSchemas = NULL;\n@@ -4380,1 +4380,1 @@\n-                       &(reader->ctxt->userData));\n+                                       &(reader->ctxt->userData));\n@@ -4382,5 +4382,5 @@\n-    xmlSchemaFree(reader->xsdSchemas);\n-    reader->xsdSchemas = NULL;\n-    xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n-    reader->xsdValidCtxt = NULL;\n-    return(-1);\n+        xmlSchemaFree(reader->xsdSchemas);\n+        reader->xsdSchemas = NULL;\n+        xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n+        reader->xsdValidCtxt = NULL;\n+        return(-1);\n@@ -4390,1 +4390,1 @@\n-                (void *) reader);\n+                                (void *) reader);\n@@ -4393,4 +4393,4 @@\n-    xmlSchemaSetValidErrors(reader->xsdValidCtxt,\n-            xmlTextReaderValidityErrorRelay,\n-            xmlTextReaderValidityWarningRelay,\n-            reader);\n+        xmlSchemaSetValidErrors(reader->xsdValidCtxt,\n+                        xmlTextReaderValidityErrorRelay,\n+                        xmlTextReaderValidityWarningRelay,\n+                        reader);\n@@ -4398,4 +4398,4 @@\n-    if (reader->sErrorFunc != NULL) {\n-        xmlSchemaSetValidStructuredErrors(reader->xsdValidCtxt,\n-            xmlTextReaderValidityStructuredRelay,\n-            reader);\n+        if (reader->sErrorFunc != NULL) {\n+                xmlSchemaSetValidStructuredErrors(reader->xsdValidCtxt,\n+                        xmlTextReaderValidityStructuredRelay,\n+                        reader);\n@@ -4420,1 +4420,1 @@\n- *     -1 in case of error.\n+ *         -1 in case of error.\n@@ -4424,3 +4424,3 @@\n-                     const char *rng,\n-                     xmlRelaxNGValidCtxtPtr ctxt,\n-                     int options ATTRIBUTE_UNUSED)\n+                                     const char *rng,\n+                                     xmlRelaxNGValidCtxtPtr ctxt,\n+                                     int options ATTRIBUTE_UNUSED)\n@@ -4429,1 +4429,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4432,1 +4432,1 @@\n-    return (-1);\n+        return (-1);\n@@ -4435,3 +4435,3 @@\n-    ((reader->mode != XML_TEXTREADER_MODE_INITIAL) ||\n-     (reader->ctxt == NULL)))\n-    return(-1);\n+        ((reader->mode != XML_TEXTREADER_MODE_INITIAL) ||\n+         (reader->ctxt == NULL)))\n+        return(-1);\n@@ -4441,3 +4441,3 @@\n-    if ( !reader->rngPreserveCtxt)\n-        xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);\n-    reader->rngValidCtxt = NULL;\n+        if ( !reader->rngPreserveCtxt)\n+            xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);\n+        reader->rngValidCtxt = NULL;\n@@ -4447,2 +4447,2 @@\n-    xmlRelaxNGFree(reader->rngSchemas);\n-    reader->rngSchemas = NULL;\n+        xmlRelaxNGFree(reader->rngSchemas);\n+        reader->rngSchemas = NULL;\n@@ -4452,2 +4452,2 @@\n-    \/* We just want to deactivate the validation, so get out. *\/\n-    return(0);\n+        \/* We just want to deactivate the validation, so get out. *\/\n+        return(0);\n@@ -4458,25 +4458,25 @@\n-    xmlRelaxNGParserCtxtPtr pctxt;\n-    \/* Parse the schema and create validation environment. *\/\n-\n-    pctxt = xmlRelaxNGNewParserCtxt(rng);\n-    if (reader->errorFunc != NULL) {\n-        xmlRelaxNGSetParserErrors(pctxt,\n-        xmlTextReaderValidityErrorRelay,\n-        xmlTextReaderValidityWarningRelay,\n-        reader);\n-    }\n-    if (reader->sErrorFunc != NULL) {\n-        xmlRelaxNGSetValidStructuredErrors(reader->rngValidCtxt,\n-        xmlTextReaderValidityStructuredRelay,\n-        reader);\n-    }\n-    reader->rngSchemas = xmlRelaxNGParse(pctxt);\n-    xmlRelaxNGFreeParserCtxt(pctxt);\n-    if (reader->rngSchemas == NULL)\n-        return(-1);\n-    reader->rngValidCtxt = xmlRelaxNGNewValidCtxt(reader->rngSchemas);\n-    if (reader->rngValidCtxt == NULL) {\n-        xmlRelaxNGFree(reader->rngSchemas);\n-        reader->rngSchemas = NULL;\n-        return(-1);\n-    }\n+        xmlRelaxNGParserCtxtPtr pctxt;\n+        \/* Parse the schema and create validation environment. *\/\n+\n+        pctxt = xmlRelaxNGNewParserCtxt(rng);\n+        if (reader->errorFunc != NULL) {\n+            xmlRelaxNGSetParserErrors(pctxt,\n+                xmlTextReaderValidityErrorRelay,\n+                xmlTextReaderValidityWarningRelay,\n+                reader);\n+        }\n+        if (reader->sErrorFunc != NULL) {\n+            xmlRelaxNGSetValidStructuredErrors(reader->rngValidCtxt,\n+                xmlTextReaderValidityStructuredRelay,\n+                reader);\n+        }\n+        reader->rngSchemas = xmlRelaxNGParse(pctxt);\n+        xmlRelaxNGFreeParserCtxt(pctxt);\n+        if (reader->rngSchemas == NULL)\n+            return(-1);\n+        reader->rngValidCtxt = xmlRelaxNGNewValidCtxt(reader->rngSchemas);\n+        if (reader->rngValidCtxt == NULL) {\n+            xmlRelaxNGFree(reader->rngSchemas);\n+            reader->rngSchemas = NULL;\n+            return(-1);\n+        }\n@@ -4484,3 +4484,3 @@\n-    \/* Use the given validation context. *\/\n-    reader->rngValidCtxt = ctxt;\n-    reader->rngPreserveCtxt = 1;\n+        \/* Use the given validation context. *\/\n+        reader->rngValidCtxt = ctxt;\n+        reader->rngPreserveCtxt = 1;\n@@ -4495,4 +4495,4 @@\n-    xmlRelaxNGSetValidErrors(reader->rngValidCtxt,\n-             xmlTextReaderValidityErrorRelay,\n-             xmlTextReaderValidityWarningRelay,\n-             reader);\n+        xmlRelaxNGSetValidErrors(reader->rngValidCtxt,\n+                         xmlTextReaderValidityErrorRelay,\n+                         xmlTextReaderValidityWarningRelay,\n+                         reader);\n@@ -4500,4 +4500,4 @@\n-    if (reader->sErrorFunc != NULL) {\n-        xmlRelaxNGSetValidStructuredErrors(reader->rngValidCtxt,\n-            xmlTextReaderValidityStructuredRelay,\n-            reader);\n+        if (reader->sErrorFunc != NULL) {\n+                xmlRelaxNGSetValidStructuredErrors(reader->rngValidCtxt,\n+                        xmlTextReaderValidityStructuredRelay,\n+                        reader);\n@@ -4527,3 +4527,3 @@\n-                    const char *xsd,\n-                    xmlSchemaValidCtxtPtr ctxt,\n-                    int options ATTRIBUTE_UNUSED)\n+                                    const char *xsd,\n+                                    xmlSchemaValidCtxtPtr ctxt,\n+                                    int options ATTRIBUTE_UNUSED)\n@@ -4535,1 +4535,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4538,1 +4538,1 @@\n-    ((reader->mode != XML_TEXTREADER_MODE_INITIAL) ||\n+        ((reader->mode != XML_TEXTREADER_MODE_INITIAL) ||\n@@ -4540,1 +4540,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4544,2 +4544,2 @@\n-    xmlSchemaSAXUnplug(reader->xsdPlug);\n-    reader->xsdPlug = NULL;\n+        xmlSchemaSAXUnplug(reader->xsdPlug);\n+        reader->xsdPlug = NULL;\n@@ -4548,3 +4548,3 @@\n-    if (! reader->xsdPreserveCtxt)\n-        xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n-    reader->xsdValidCtxt = NULL;\n+        if (! reader->xsdPreserveCtxt)\n+            xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n+        reader->xsdValidCtxt = NULL;\n@@ -4554,2 +4554,2 @@\n-    xmlSchemaFree(reader->xsdSchemas);\n-    reader->xsdSchemas = NULL;\n+        xmlSchemaFree(reader->xsdSchemas);\n+        reader->xsdSchemas = NULL;\n@@ -4559,2 +4559,2 @@\n-    \/* We just want to deactivate the validation, so get out. *\/\n-    return(0);\n+        \/* We just want to deactivate the validation, so get out. *\/\n+        return(0);\n@@ -4564,29 +4564,29 @@\n-    xmlSchemaParserCtxtPtr pctxt;\n-    \/* Parse the schema and create validation environment. *\/\n-    pctxt = xmlSchemaNewParserCtxt(xsd);\n-    if (reader->errorFunc != NULL) {\n-        xmlSchemaSetParserErrors(pctxt,\n-        xmlTextReaderValidityErrorRelay,\n-        xmlTextReaderValidityWarningRelay,\n-        reader);\n-    }\n-    reader->xsdSchemas = xmlSchemaParse(pctxt);\n-    xmlSchemaFreeParserCtxt(pctxt);\n-    if (reader->xsdSchemas == NULL)\n-        return(-1);\n-    reader->xsdValidCtxt = xmlSchemaNewValidCtxt(reader->xsdSchemas);\n-    if (reader->xsdValidCtxt == NULL) {\n-        xmlSchemaFree(reader->xsdSchemas);\n-        reader->xsdSchemas = NULL;\n-        return(-1);\n-    }\n-    reader->xsdPlug = xmlSchemaSAXPlug(reader->xsdValidCtxt,\n-        &(reader->ctxt->sax),\n-        &(reader->ctxt->userData));\n-    if (reader->xsdPlug == NULL) {\n-        xmlSchemaFree(reader->xsdSchemas);\n-        reader->xsdSchemas = NULL;\n-        xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n-        reader->xsdValidCtxt = NULL;\n-        return(-1);\n-    }\n+        xmlSchemaParserCtxtPtr pctxt;\n+        \/* Parse the schema and create validation environment. *\/\n+        pctxt = xmlSchemaNewParserCtxt(xsd);\n+        if (reader->errorFunc != NULL) {\n+            xmlSchemaSetParserErrors(pctxt,\n+                xmlTextReaderValidityErrorRelay,\n+                xmlTextReaderValidityWarningRelay,\n+                reader);\n+        }\n+        reader->xsdSchemas = xmlSchemaParse(pctxt);\n+        xmlSchemaFreeParserCtxt(pctxt);\n+        if (reader->xsdSchemas == NULL)\n+            return(-1);\n+        reader->xsdValidCtxt = xmlSchemaNewValidCtxt(reader->xsdSchemas);\n+        if (reader->xsdValidCtxt == NULL) {\n+            xmlSchemaFree(reader->xsdSchemas);\n+            reader->xsdSchemas = NULL;\n+            return(-1);\n+        }\n+        reader->xsdPlug = xmlSchemaSAXPlug(reader->xsdValidCtxt,\n+            &(reader->ctxt->sax),\n+            &(reader->ctxt->userData));\n+        if (reader->xsdPlug == NULL) {\n+            xmlSchemaFree(reader->xsdSchemas);\n+            reader->xsdSchemas = NULL;\n+            xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n+            reader->xsdValidCtxt = NULL;\n+            return(-1);\n+        }\n@@ -4594,11 +4594,11 @@\n-    \/* Use the given validation context. *\/\n-    reader->xsdValidCtxt = ctxt;\n-    reader->xsdPreserveCtxt = 1;\n-    reader->xsdPlug = xmlSchemaSAXPlug(reader->xsdValidCtxt,\n-        &(reader->ctxt->sax),\n-        &(reader->ctxt->userData));\n-    if (reader->xsdPlug == NULL) {\n-        reader->xsdValidCtxt = NULL;\n-        reader->xsdPreserveCtxt = 0;\n-        return(-1);\n-    }\n+        \/* Use the given validation context. *\/\n+        reader->xsdValidCtxt = ctxt;\n+        reader->xsdPreserveCtxt = 1;\n+        reader->xsdPlug = xmlSchemaSAXPlug(reader->xsdValidCtxt,\n+            &(reader->ctxt->sax),\n+            &(reader->ctxt->userData));\n+        if (reader->xsdPlug == NULL) {\n+            reader->xsdValidCtxt = NULL;\n+            reader->xsdPreserveCtxt = 0;\n+            return(-1);\n+        }\n@@ -4608,1 +4608,1 @@\n-                (void *) reader);\n+                                (void *) reader);\n@@ -4616,4 +4616,4 @@\n-    xmlSchemaSetValidErrors(reader->xsdValidCtxt,\n-             xmlTextReaderValidityErrorRelay,\n-             xmlTextReaderValidityWarningRelay,\n-             reader);\n+        xmlSchemaSetValidErrors(reader->xsdValidCtxt,\n+                         xmlTextReaderValidityErrorRelay,\n+                         xmlTextReaderValidityWarningRelay,\n+                         reader);\n@@ -4621,4 +4621,4 @@\n-    if (reader->sErrorFunc != NULL) {\n-        xmlSchemaSetValidStructuredErrors(reader->xsdValidCtxt,\n-            xmlTextReaderValidityStructuredRelay,\n-            reader);\n+        if (reader->sErrorFunc != NULL) {\n+                xmlSchemaSetValidStructuredErrors(reader->xsdValidCtxt,\n+                        xmlTextReaderValidityStructuredRelay,\n+                        reader);\n@@ -4646,2 +4646,2 @@\n-                    xmlSchemaValidCtxtPtr ctxt,\n-                    int options)\n+                                    xmlSchemaValidCtxtPtr ctxt,\n+                                    int options)\n@@ -4685,2 +4685,2 @@\n-                 xmlRelaxNGValidCtxtPtr ctxt,\n-                 int options)\n+                                 xmlRelaxNGValidCtxtPtr ctxt,\n+                                 int options)\n@@ -4726,1 +4726,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4728,1 +4728,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4730,1 +4730,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -4732,1 +4732,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -4735,1 +4735,1 @@\n-    return(1);\n+        return(1);\n@@ -4737,1 +4737,1 @@\n-    return(0);\n+        return(0);\n@@ -4753,1 +4753,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4757,1 +4757,1 @@\n-    doc = reader->ctxt->myDoc;\n+        doc = reader->ctxt->myDoc;\n@@ -4759,1 +4759,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4762,1 +4762,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4781,1 +4781,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4785,1 +4785,1 @@\n-    doc = reader->ctxt->myDoc;\n+        doc = reader->ctxt->myDoc;\n@@ -4787,1 +4787,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4793,3 +4793,3 @@\n- *                                  *\n- *          Error Handling Extensions                       *\n- *                                  *\n+ *                                                                      *\n+ *                      Error Handling Extensions                       *\n+ *                                                                      *\n@@ -4812,6 +4812,6 @@\n-        xmlGenericError(xmlGenericErrorContext, \"vsnprintf failed !\\n\");\n-        if (str)\n-        xmlFree(str);\n-        return NULL;\n-    }\n-    if ((chars < size) || (size == MAX_ERR_MSG_SIZE))\n+            xmlGenericError(xmlGenericErrorContext, \"vsnprintf failed !\\n\");\n+            if (str)\n+                xmlFree(str);\n+            return NULL;\n+        }\n+        if ((chars < size) || (size == MAX_ERR_MSG_SIZE))\n@@ -4820,3 +4820,3 @@\n-    size = chars + 1;\n-    else\n-        size = MAX_ERR_MSG_SIZE;\n+        size = chars + 1;\n+        else\n+                size = MAX_ERR_MSG_SIZE;\n@@ -4824,2 +4824,2 @@\n-        xmlGenericError(xmlGenericErrorContext, \"xmlRealloc failed !\\n\");\n-        if (str)\n+            xmlGenericError(xmlGenericErrorContext, \"xmlRealloc failed !\\n\");\n+            if (str)\n@@ -4852,10 +4852,1 @@\n-    ret = xmlGetLineNo(ctx->node);\n-    }\n-    else {\n-    \/* inspired from error.c *\/\n-    xmlParserInputPtr input;\n-    input = ctx->input;\n-    if ((input->filename == NULL) && (ctx->inputNr > 1))\n-        input = ctx->inputTab[ctx->inputNr - 2];\n-    if (input != NULL) {\n-        ret = input->line;\n+        ret = xmlGetLineNo(ctx->node);\n@@ -4864,2 +4855,11 @@\n-        ret = -1;\n-    }\n+        \/* inspired from error.c *\/\n+        xmlParserInputPtr input;\n+        input = ctx->input;\n+        if ((input->filename == NULL) && (ctx->inputNr > 1))\n+            input = ctx->inputTab[ctx->inputNr - 2];\n+        if (input != NULL) {\n+            ret = input->line;\n+        }\n+        else {\n+            ret = -1;\n+        }\n@@ -4889,10 +4889,1 @@\n-    ret = xmlNodeGetBase(NULL,ctx->node);\n-    }\n-    else {\n-    \/* inspired from error.c *\/\n-    xmlParserInputPtr input;\n-    input = ctx->input;\n-    if ((input->filename == NULL) && (ctx->inputNr > 1))\n-        input = ctx->inputTab[ctx->inputNr - 2];\n-    if (input != NULL) {\n-        ret = xmlStrdup(BAD_CAST input->filename);\n+        ret = xmlNodeGetBase(NULL,ctx->node);\n@@ -4901,2 +4892,11 @@\n-        ret = NULL;\n-    }\n+        \/* inspired from error.c *\/\n+        xmlParserInputPtr input;\n+        input = ctx->input;\n+        if ((input->filename == NULL) && (ctx->inputNr > 1))\n+            input = ctx->inputTab[ctx->inputNr - 2];\n+        if (input != NULL) {\n+            ret = xmlStrdup(BAD_CAST input->filename);\n+        }\n+        else {\n+            ret = NULL;\n+        }\n@@ -5176,3 +5176,3 @@\n- *                                  *\n- *  New set (2.6.0) of simpler and more flexible APIs       *\n- *                                  *\n+ *                                                                      *\n+ *      New set (2.6.0) of simpler and more flexible APIs               *\n+ *                                                                      *\n@@ -5201,1 +5201,1 @@\n-        xmlFreeParserInputBuffer(input);\n+            xmlFreeParserInputBuffer(input);\n@@ -5217,3 +5217,3 @@\n-    xmlFreeParserInputBuffer(reader->input);\n-    reader->input = NULL;\n-    reader->allocs -= XML_TEXTREADER_INPUT;\n+        xmlFreeParserInputBuffer(reader->input);\n+        reader->input = NULL;\n+        reader->allocs -= XML_TEXTREADER_INPUT;\n@@ -5222,2 +5222,2 @@\n-    reader->input = input;\n-    reader->allocs |= XML_TEXTREADER_INPUT;\n+        reader->input = input;\n+        reader->allocs |= XML_TEXTREADER_INPUT;\n@@ -5234,1 +5234,1 @@\n-                  XML_BUFFER_ALLOC_BOUNDED);\n+                              XML_BUFFER_ALLOC_BOUNDED);\n@@ -5236,1 +5236,1 @@\n-    reader->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));\n+        reader->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));\n@@ -5276,1 +5276,1 @@\n-               (const char *) xmlBufContent(reader->input->buffer),\n+                       (const char *) xmlBufContent(reader->input->buffer),\n@@ -5287,12 +5287,12 @@\n-        xmlParserInputPtr inputStream;\n-        xmlParserInputBufferPtr buf;\n-        xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;\n-\n-        xmlCtxtReset(reader->ctxt);\n-        buf = xmlAllocParserInputBuffer(enc);\n-        if (buf == NULL) return(-1);\n-        inputStream = xmlNewInputStream(reader->ctxt);\n-        if (inputStream == NULL) {\n-        xmlFreeParserInputBuffer(buf);\n-        return(-1);\n-        }\n+            xmlParserInputPtr inputStream;\n+            xmlParserInputBufferPtr buf;\n+            xmlCharEncoding enc = XML_CHAR_ENCODING_NONE;\n+\n+            xmlCtxtReset(reader->ctxt);\n+            buf = xmlAllocParserInputBuffer(enc);\n+            if (buf == NULL) return(-1);\n+            inputStream = xmlNewInputStream(reader->ctxt);\n+            if (inputStream == NULL) {\n+                xmlFreeParserInputBuffer(buf);\n+                return(-1);\n+            }\n@@ -5300,6 +5300,6 @@\n-        if (URL == NULL)\n-        inputStream->filename = NULL;\n-        else\n-        inputStream->filename = (char *)\n-            xmlCanonicPath((const xmlChar *) URL);\n-        inputStream->buf = buf;\n+            if (URL == NULL)\n+                inputStream->filename = NULL;\n+            else\n+                inputStream->filename = (char *)\n+                    xmlCanonicPath((const xmlChar *) URL);\n+            inputStream->buf = buf;\n@@ -5308,3 +5308,3 @@\n-        inputPush(reader->ctxt, inputStream);\n-        reader->cur = 0;\n-    }\n+            inputPush(reader->ctxt, inputStream);\n+            reader->cur = 0;\n+        }\n@@ -5319,3 +5319,6 @@\n-        if (reader->dict != reader->ctxt->dict) {\n-        xmlDictFree(reader->dict);\n-        reader->dict = reader->ctxt->dict;\n+            if (reader->dict != reader->ctxt->dict) {\n+                xmlDictFree(reader->dict);\n+                reader->dict = reader->ctxt->dict;\n+            }\n+        } else {\n+            reader->ctxt->dict = reader->dict;\n@@ -5324,5 +5327,2 @@\n-        reader->ctxt->dict = reader->dict;\n-    }\n-    } else {\n-    if (reader->ctxt->dict == NULL)\n-        reader->ctxt->dict = xmlDictCreate();\n+        if (reader->ctxt->dict == NULL)\n+            reader->ctxt->dict = xmlDictCreate();\n@@ -5342,2 +5342,2 @@\n-    xmlXIncludeFreeContext(reader->xincctxt);\n-    reader->xincctxt = NULL;\n+        xmlXIncludeFreeContext(reader->xincctxt);\n+        reader->xincctxt = NULL;\n@@ -5347,2 +5347,2 @@\n-    reader->xinclude_name = xmlDictLookup(reader->dict, XINCLUDE_NODE, -1);\n-    options -= XML_PARSE_XINCLUDE;\n+        reader->xinclude_name = xmlDictLookup(reader->dict, XINCLUDE_NODE, -1);\n+        options -= XML_PARSE_XINCLUDE;\n@@ -5356,1 +5356,1 @@\n-    reader->patternMax = 0;\n+        reader->patternMax = 0;\n@@ -5360,2 +5360,2 @@\n-    if (reader->patternTab[reader->patternNr] != NULL) {\n-        xmlFreePattern(reader->patternTab[reader->patternNr]);\n+        if (reader->patternTab[reader->patternNr] != NULL) {\n+            xmlFreePattern(reader->patternTab[reader->patternNr]);\n@@ -5363,1 +5363,1 @@\n-    }\n+        }\n@@ -5428,2 +5428,2 @@\n-        \"xmlNewTextReader : malloc failed\\n\");\n-    return(NULL);\n+                \"xmlNewTextReader : malloc failed\\n\");\n+        return(NULL);\n@@ -5631,1 +5631,1 @@\n-    xmlCtxtReset(reader->ctxt);\n+        xmlCtxtReset(reader->ctxt);\n@@ -5646,3 +5646,3 @@\n-        reader->dict = reader->ctxt->dict;\n-    else\n-        reader->dict = xmlDictCreate();\n+            reader->dict = reader->ctxt->dict;\n+        else\n+            reader->dict = xmlDictCreate();\n@@ -5824,3 +5824,3 @@\n- *                                  *\n- *          Utilities                   *\n- *                                  *\n+ *                                                                      *\n+ *                      Utilities                                       *\n+ *                                                                      *\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlreader.c","additions":1514,"deletions":1514,"binary":false,"changes":3028,"status":"modified"},{"patch":"@@ -27,3 +27,3 @@\n- *                                  *\n- *          XHTML detection                 *\n- *                                  *\n+ *                                                                      *\n+ *                      XHTML detection                                 *\n+ *                                                                      *\n@@ -57,1 +57,1 @@\n-    return(-1);\n+        return(-1);\n@@ -59,3 +59,3 @@\n-    if (xmlStrEqual(publicID, XHTML_STRICT_PUBLIC_ID)) return(1);\n-    if (xmlStrEqual(publicID, XHTML_FRAME_PUBLIC_ID)) return(1);\n-    if (xmlStrEqual(publicID, XHTML_TRANS_PUBLIC_ID)) return(1);\n+        if (xmlStrEqual(publicID, XHTML_STRICT_PUBLIC_ID)) return(1);\n+        if (xmlStrEqual(publicID, XHTML_FRAME_PUBLIC_ID)) return(1);\n+        if (xmlStrEqual(publicID, XHTML_TRANS_PUBLIC_ID)) return(1);\n@@ -64,3 +64,3 @@\n-    if (xmlStrEqual(systemID, XHTML_STRICT_SYSTEM_ID)) return(1);\n-    if (xmlStrEqual(systemID, XHTML_FRAME_SYSTEM_ID)) return(1);\n-    if (xmlStrEqual(systemID, XHTML_TRANS_SYSTEM_ID)) return(1);\n+        if (xmlStrEqual(systemID, XHTML_STRICT_SYSTEM_ID)) return(1);\n+        if (xmlStrEqual(systemID, XHTML_FRAME_SYSTEM_ID)) return(1);\n+        if (xmlStrEqual(systemID, XHTML_TRANS_SYSTEM_ID)) return(1);\n@@ -73,3 +73,3 @@\n-#define TODO                                \\\n-    xmlGenericError(xmlGenericErrorContext,             \\\n-        \"Unimplemented block at %s:%d\\n\",               \\\n+#define TODO                                                            \\\n+    xmlGenericError(xmlGenericErrorContext,                             \\\n+            \"Unimplemented block at %s:%d\\n\",                           \\\n@@ -89,1 +89,1 @@\n-    char indent[MAX_INDENT + 1];    \/* array for indenting output *\/\n+    char indent[MAX_INDENT + 1];        \/* array for indenting output *\/\n@@ -97,3 +97,3 @@\n- *                                  *\n- *          Output error handlers               *\n- *                                  *\n+ *                                                                      *\n+ *                      Output error handlers                           *\n+ *                                                                      *\n@@ -128,13 +128,13 @@\n-        msg = \"string is not in UTF-8\\n\";\n-        break;\n-    case XML_SAVE_CHAR_INVALID:\n-        msg = \"invalid character value\\n\";\n-        break;\n-    case XML_SAVE_UNKNOWN_ENCODING:\n-        msg = \"unknown encoding %s\\n\";\n-        break;\n-    case XML_SAVE_NO_DOCTYPE:\n-        msg = \"document has no DOCTYPE\\n\";\n-        break;\n-    default:\n-        msg = \"unexpected error number\\n\";\n+            msg = \"string is not in UTF-8\\n\";\n+            break;\n+        case XML_SAVE_CHAR_INVALID:\n+            msg = \"invalid character value\\n\";\n+            break;\n+        case XML_SAVE_UNKNOWN_ENCODING:\n+            msg = \"unknown encoding %s\\n\";\n+            break;\n+        case XML_SAVE_NO_DOCTYPE:\n+            msg = \"document has no DOCTYPE\\n\";\n+            break;\n+        default:\n+            msg = \"unexpected error number\\n\";\n@@ -146,3 +146,3 @@\n- *                                  *\n- *          Special escaping routines           *\n- *                                  *\n+ *                                                                      *\n+ *                      Special escaping routines                       *\n+ *                                                                      *\n@@ -165,20 +165,20 @@\n-    switch (val & 0xF) {\n-        case 0: *ptr-- = '0'; break;\n-        case 1: *ptr-- = '1'; break;\n-        case 2: *ptr-- = '2'; break;\n-        case 3: *ptr-- = '3'; break;\n-        case 4: *ptr-- = '4'; break;\n-        case 5: *ptr-- = '5'; break;\n-        case 6: *ptr-- = '6'; break;\n-        case 7: *ptr-- = '7'; break;\n-        case 8: *ptr-- = '8'; break;\n-        case 9: *ptr-- = '9'; break;\n-        case 0xA: *ptr-- = 'A'; break;\n-        case 0xB: *ptr-- = 'B'; break;\n-        case 0xC: *ptr-- = 'C'; break;\n-        case 0xD: *ptr-- = 'D'; break;\n-        case 0xE: *ptr-- = 'E'; break;\n-        case 0xF: *ptr-- = 'F'; break;\n-        default: *ptr-- = '0'; break;\n-    }\n-    val >>= 4;\n+        switch (val & 0xF) {\n+            case 0: *ptr-- = '0'; break;\n+            case 1: *ptr-- = '1'; break;\n+            case 2: *ptr-- = '2'; break;\n+            case 3: *ptr-- = '3'; break;\n+            case 4: *ptr-- = '4'; break;\n+            case 5: *ptr-- = '5'; break;\n+            case 6: *ptr-- = '6'; break;\n+            case 7: *ptr-- = '7'; break;\n+            case 8: *ptr-- = '8'; break;\n+            case 9: *ptr-- = '9'; break;\n+            case 0xA: *ptr-- = 'A'; break;\n+            case 0xB: *ptr-- = 'B'; break;\n+            case 0xC: *ptr-- = 'C'; break;\n+            case 0xD: *ptr-- = 'D'; break;\n+            case 0xE: *ptr-- = 'E'; break;\n+            case 0xF: *ptr-- = 'F'; break;\n+            default: *ptr-- = '0'; break;\n+        }\n+        val >>= 4;\n@@ -218,66 +218,84 @@\n-    if (*in == '<') {\n-        if (outend - out < 4) break;\n-        *out++ = '&';\n-        *out++ = 'l';\n-        *out++ = 't';\n-        *out++ = ';';\n-        in++;\n-        continue;\n-    } else if (*in == '>') {\n-        if (outend - out < 4) break;\n-        *out++ = '&';\n-        *out++ = 'g';\n-        *out++ = 't';\n-        *out++ = ';';\n-        in++;\n-        continue;\n-    } else if (*in == '&') {\n-        if (outend - out < 5) break;\n-        *out++ = '&';\n-        *out++ = 'a';\n-        *out++ = 'm';\n-        *out++ = 'p';\n-        *out++ = ';';\n-        in++;\n-        continue;\n-    } else if (((*in >= 0x20) && (*in < 0x80)) ||\n-               (*in == '\\n') || (*in == '\\t')) {\n-        \/*\n-         * default case, just copy !\n-         *\/\n-        *out++ = *in++;\n-        continue;\n-    } else if (*in >= 0x80) {\n-        \/*\n-         * We assume we have UTF-8 input.\n-         *\/\n-        if (outend - out < 11) break;\n-\n-        if (*in < 0xC0) {\n-        xmlSaveErr(XML_SAVE_NOT_UTF8, NULL, NULL);\n-        in++;\n-        goto error;\n-        } else if (*in < 0xE0) {\n-        if (inend - in < 2) break;\n-        val = (in[0]) & 0x1F;\n-        val <<= 6;\n-        val |= (in[1]) & 0x3F;\n-        in += 2;\n-        } else if (*in < 0xF0) {\n-        if (inend - in < 3) break;\n-        val = (in[0]) & 0x0F;\n-        val <<= 6;\n-        val |= (in[1]) & 0x3F;\n-        val <<= 6;\n-        val |= (in[2]) & 0x3F;\n-        in += 3;\n-        } else if (*in < 0xF8) {\n-        if (inend - in < 4) break;\n-        val = (in[0]) & 0x07;\n-        val <<= 6;\n-        val |= (in[1]) & 0x3F;\n-        val <<= 6;\n-        val |= (in[2]) & 0x3F;\n-        val <<= 6;\n-        val |= (in[3]) & 0x3F;\n-        in += 4;\n+        if (*in == '<') {\n+            if (outend - out < 4) break;\n+            *out++ = '&';\n+            *out++ = 'l';\n+            *out++ = 't';\n+            *out++ = ';';\n+            in++;\n+            continue;\n+        } else if (*in == '>') {\n+            if (outend - out < 4) break;\n+            *out++ = '&';\n+            *out++ = 'g';\n+            *out++ = 't';\n+            *out++ = ';';\n+            in++;\n+            continue;\n+        } else if (*in == '&') {\n+            if (outend - out < 5) break;\n+            *out++ = '&';\n+            *out++ = 'a';\n+            *out++ = 'm';\n+            *out++ = 'p';\n+            *out++ = ';';\n+            in++;\n+            continue;\n+        } else if (((*in >= 0x20) && (*in < 0x80)) ||\n+                   (*in == '\\n') || (*in == '\\t')) {\n+            \/*\n+             * default case, just copy !\n+             *\/\n+            *out++ = *in++;\n+            continue;\n+        } else if (*in >= 0x80) {\n+            \/*\n+             * We assume we have UTF-8 input.\n+             *\/\n+            if (outend - out < 11) break;\n+\n+            if (*in < 0xC0) {\n+                xmlSaveErr(XML_SAVE_NOT_UTF8, NULL, NULL);\n+                in++;\n+                goto error;\n+            } else if (*in < 0xE0) {\n+                if (inend - in < 2) break;\n+                val = (in[0]) & 0x1F;\n+                val <<= 6;\n+                val |= (in[1]) & 0x3F;\n+                in += 2;\n+            } else if (*in < 0xF0) {\n+                if (inend - in < 3) break;\n+                val = (in[0]) & 0x0F;\n+                val <<= 6;\n+                val |= (in[1]) & 0x3F;\n+                val <<= 6;\n+                val |= (in[2]) & 0x3F;\n+                in += 3;\n+            } else if (*in < 0xF8) {\n+                if (inend - in < 4) break;\n+                val = (in[0]) & 0x07;\n+                val <<= 6;\n+                val |= (in[1]) & 0x3F;\n+                val <<= 6;\n+                val |= (in[2]) & 0x3F;\n+                val <<= 6;\n+                val |= (in[3]) & 0x3F;\n+                in += 4;\n+            } else {\n+                xmlSaveErr(XML_SAVE_CHAR_INVALID, NULL, NULL);\n+                in++;\n+                goto error;\n+            }\n+            if (!IS_CHAR(val)) {\n+                xmlSaveErr(XML_SAVE_CHAR_INVALID, NULL, NULL);\n+                in++;\n+                goto error;\n+            }\n+\n+            \/*\n+             * We could do multiple things here. Just save as a char ref\n+             *\/\n+            out = xmlSerializeHexCharRef(out, val);\n+        } else if (IS_BYTE_CHAR(*in)) {\n+            if (outend - out < 6) break;\n+            out = xmlSerializeHexCharRef(out, *in++);\n@@ -285,8 +303,4 @@\n-        xmlSaveErr(XML_SAVE_CHAR_INVALID, NULL, NULL);\n-        in++;\n-        goto error;\n-        }\n-        if (!IS_CHAR(val)) {\n-        xmlSaveErr(XML_SAVE_CHAR_INVALID, NULL, NULL);\n-        in++;\n-        goto error;\n+            xmlGenericError(xmlGenericErrorContext,\n+                \"xmlEscapeEntities : char out of range\\n\");\n+            in++;\n+            goto error;\n@@ -294,14 +308,0 @@\n-\n-        \/*\n-         * We could do multiple things here. Just save as a char ref\n-         *\/\n-        out = xmlSerializeHexCharRef(out, val);\n-    } else if (IS_BYTE_CHAR(*in)) {\n-        if (outend - out < 6) break;\n-        out = xmlSerializeHexCharRef(out, *in++);\n-    } else {\n-        xmlGenericError(xmlGenericErrorContext,\n-        \"xmlEscapeEntities : char out of range\\n\");\n-        in++;\n-        goto error;\n-    }\n@@ -319,3 +319,3 @@\n- *                                  *\n- *          Allocation and deallocation         *\n- *                                  *\n+ *                                                                      *\n+ *                      Allocation and deallocation                     *\n+ *                                                                      *\n@@ -342,5 +342,5 @@\n-    ctxt->indent_size = len;\n-    ctxt->indent_nr = MAX_INDENT \/ ctxt->indent_size;\n-    for (i = 0;i < ctxt->indent_nr;i++)\n-        memcpy(&ctxt->indent[i * ctxt->indent_size], xmlTreeIndentString,\n-           ctxt->indent_size);\n+        ctxt->indent_size = len;\n+        ctxt->indent_nr = MAX_INDENT \/ ctxt->indent_size;\n+        for (i = 0;i < ctxt->indent_nr;i++)\n+            memcpy(&ctxt->indent[i * ctxt->indent_size], xmlTreeIndentString,\n+                   ctxt->indent_size);\n@@ -351,1 +351,1 @@\n-    ctxt->options |= XML_SAVE_NO_EMPTY;\n+        ctxt->options |= XML_SAVE_NO_EMPTY;\n@@ -385,2 +385,2 @@\n-    xmlSaveErrMemory(\"creating saving context\");\n-    return ( NULL );\n+        xmlSaveErrMemory(\"creating saving context\");\n+        return ( NULL );\n@@ -392,2 +392,2 @@\n-    if (ret->handler == NULL) {\n-        xmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);\n+        if (ret->handler == NULL) {\n+            xmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);\n@@ -395,2 +395,2 @@\n-        return(NULL);\n-    }\n+            return(NULL);\n+        }\n@@ -398,1 +398,1 @@\n-    ret->escape = NULL;\n+        ret->escape = NULL;\n@@ -408,1 +408,1 @@\n-    options |= XML_SAVE_NO_EMPTY;\n+        options |= XML_SAVE_NO_EMPTY;\n@@ -421,3 +421,3 @@\n- *                                  *\n- *      Dumping XML tree content to a simple buffer     *\n- *                                  *\n+ *                                                                      *\n+ *              Dumping XML tree content to a simple buffer             *\n+ *                                                                      *\n@@ -442,3 +442,3 @@\n-            xmlBufAttrSerializeTxtContent(buf->buffer, attr->doc,\n-                                      attr, children->content);\n-        break;\n+                xmlBufAttrSerializeTxtContent(buf->buffer, attr->doc,\n+                                              attr, children->content);\n+                break;\n@@ -550,3 +550,3 @@\n- *                                  *\n- *      Dumping XML tree content to an I\/O output buffer    *\n- *                                  *\n+ *                                                                      *\n+ *              Dumping XML tree content to an I\/O output buffer        *\n+ *                                                                      *\n@@ -559,15 +559,15 @@\n-    buf->encoder = xmlFindCharEncodingHandler((const char *)encoding);\n-    if (buf->encoder == NULL) {\n-        xmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL,\n-               (const char *)encoding);\n-        return(-1);\n-    }\n-    buf->conv = xmlBufCreate();\n-    if (buf->conv == NULL) {\n-        xmlCharEncCloseFunc(buf->encoder);\n-        xmlSaveErrMemory(\"creating encoding buffer\");\n-        return(-1);\n-    }\n-    \/*\n-     * initialize the state, e.g. if outputting a BOM\n-     *\/\n+        buf->encoder = xmlFindCharEncodingHandler((const char *)encoding);\n+        if (buf->encoder == NULL) {\n+            xmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL,\n+                       (const char *)encoding);\n+            return(-1);\n+        }\n+        buf->conv = xmlBufCreate();\n+        if (buf->conv == NULL) {\n+            xmlCharEncCloseFunc(buf->encoder);\n+            xmlSaveErrMemory(\"creating encoding buffer\");\n+            return(-1);\n+        }\n+        \/*\n+         * initialize the state, e.g. if outputting a BOM\n+         *\/\n@@ -633,2 +633,2 @@\n-    if (xmlStrEqual(cur->prefix, BAD_CAST \"xml\"))\n-        return;\n+        if (xmlStrEqual(cur->prefix, BAD_CAST \"xml\"))\n+            return;\n@@ -636,4 +636,4 @@\n-    if (ctxt != NULL && ctxt->format == 2)\n-        xmlOutputBufferWriteWSNonSig(ctxt, 2);\n-    else\n-        xmlOutputBufferWrite(buf, 1, \" \");\n+        if (ctxt != NULL && ctxt->format == 2)\n+            xmlOutputBufferWriteWSNonSig(ctxt, 2);\n+        else\n+            xmlOutputBufferWrite(buf, 1, \" \");\n@@ -642,7 +642,7 @@\n-    if (cur->prefix != NULL) {\n-        xmlOutputBufferWrite(buf, 6, \"xmlns:\");\n-        xmlOutputBufferWriteString(buf, (const char *)cur->prefix);\n-    } else\n-        xmlOutputBufferWrite(buf, 5, \"xmlns\");\n-    xmlOutputBufferWrite(buf, 1, \"=\");\n-    xmlBufWriteQuotedString(buf->buffer, cur->href);\n+        if (cur->prefix != NULL) {\n+            xmlOutputBufferWrite(buf, 6, \"xmlns:\");\n+            xmlOutputBufferWriteString(buf, (const char *)cur->prefix);\n+        } else\n+            xmlOutputBufferWrite(buf, 5, \"xmlns\");\n+        xmlOutputBufferWrite(buf, 1, \"=\");\n+        xmlBufWriteQuotedString(buf->buffer, cur->href);\n@@ -677,1 +677,1 @@\n-    cur = cur->next;\n+        cur = cur->next;\n@@ -693,1 +693,1 @@\n-    cur = cur->next;\n+        cur = cur->next;\n@@ -717,4 +717,4 @@\n-    xmlOutputBufferWrite(buf, 8, \" PUBLIC \");\n-    xmlBufWriteQuotedString(buf->buffer, dtd->ExternalID);\n-    xmlOutputBufferWrite(buf, 1, \" \");\n-    xmlBufWriteQuotedString(buf->buffer, dtd->SystemID);\n+        xmlOutputBufferWrite(buf, 8, \" PUBLIC \");\n+        xmlBufWriteQuotedString(buf->buffer, dtd->ExternalID);\n+        xmlOutputBufferWrite(buf, 1, \" \");\n+        xmlBufWriteQuotedString(buf->buffer, dtd->SystemID);\n@@ -722,2 +722,2 @@\n-    xmlOutputBufferWrite(buf, 8, \" SYSTEM \");\n-    xmlBufWriteQuotedString(buf->buffer, dtd->SystemID);\n+        xmlOutputBufferWrite(buf, 8, \" SYSTEM \");\n+        xmlBufWriteQuotedString(buf->buffer, dtd->SystemID);\n@@ -727,3 +727,3 @@\n-    (dtd->pentities == NULL)) {\n-    xmlOutputBufferWrite(buf, 1, \">\");\n-    return;\n+        (dtd->pentities == NULL)) {\n+        xmlOutputBufferWrite(buf, 1, \">\");\n+        return;\n@@ -773,1 +773,1 @@\n-    xmlOutputBufferWrite(buf, 1, \":\");\n+        xmlOutputBufferWrite(buf, 1, \":\");\n@@ -802,5 +802,5 @@\n-    if (ctxt->encoding != NULL) {\n-        doc->encoding = BAD_CAST ctxt->encoding;\n-    } else if (doc->encoding != NULL) {\n-        encoding = doc->encoding;\n-    }\n+        if (ctxt->encoding != NULL) {\n+            doc->encoding = BAD_CAST ctxt->encoding;\n+        } else if (doc->encoding != NULL) {\n+            encoding = doc->encoding;\n+        }\n@@ -810,1 +810,1 @@\n-    htmlSetMetaEncoding(doc, (const xmlChar *) encoding);\n+        htmlSetMetaEncoding(doc, (const xmlChar *) encoding);\n@@ -812,1 +812,1 @@\n-    encoding = htmlGetMetaEncoding(doc);\n+        encoding = htmlGetMetaEncoding(doc);\n@@ -814,1 +814,1 @@\n-    encoding = BAD_CAST \"HTML\";\n+        encoding = BAD_CAST \"HTML\";\n@@ -816,6 +816,6 @@\n-    (buf->encoder == NULL) && (buf->conv == NULL)) {\n-    if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {\n-        doc->encoding = oldenc;\n-        return(-1);\n-    }\n-    switched_encoding = 1;\n+        (buf->encoder == NULL) && (buf->conv == NULL)) {\n+        if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {\n+            doc->encoding = oldenc;\n+            return(-1);\n+        }\n+        switched_encoding = 1;\n@@ -824,2 +824,2 @@\n-    htmlNodeDumpFormatOutput(buf, doc, cur,\n-                       (const char *)encoding, 1);\n+        htmlNodeDumpFormatOutput(buf, doc, cur,\n+                                       (const char *)encoding, 1);\n@@ -827,2 +827,2 @@\n-    htmlNodeDumpFormatOutput(buf, doc, cur,\n-                       (const char *)encoding, 0);\n+        htmlNodeDumpFormatOutput(buf, doc, cur,\n+                                       (const char *)encoding, 0);\n@@ -833,1 +833,1 @@\n-    xmlSaveClearEncoding(ctxt);\n+        xmlSaveClearEncoding(ctxt);\n@@ -836,1 +836,1 @@\n-    doc->encoding = oldenc;\n+        doc->encoding = oldenc;\n@@ -850,1 +850,1 @@\n-    xmlNodePtr tmp, root, unformattedNode = NULL;\n+    xmlNodePtr tmp, root, unformattedNode = NULL, parent;\n@@ -859,0 +859,1 @@\n+    parent = cur->parent;\n@@ -863,2 +864,2 @@\n-        xmlDocContentDumpOutput(ctxt, (xmlDocPtr) cur);\n-        break;\n+            xmlDocContentDumpOutput(ctxt, (xmlDocPtr) cur);\n+            break;\n@@ -871,1 +872,3 @@\n-            if (cur->children != NULL) {\n+            \/* Always validate cur->parent when descending. *\/\n+            if ((cur->parent == parent) && (cur->children != NULL)) {\n+                parent = cur;\n@@ -875,1 +878,1 @@\n-        break;\n+            break;\n@@ -890,5 +893,16 @@\n-        if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))\n-        xmlOutputBufferWrite(buf, ctxt->indent_size *\n-                     (ctxt->level > ctxt->indent_nr ?\n-                      ctxt->indent_nr : ctxt->level),\n-                     ctxt->indent);\n+            if ((cur != root) && (ctxt->format == 1) &&\n+                (xmlIndentTreeOutput))\n+                xmlOutputBufferWrite(buf, ctxt->indent_size *\n+                                     (ctxt->level > ctxt->indent_nr ?\n+                                      ctxt->indent_nr : ctxt->level),\n+                                     ctxt->indent);\n+\n+            \/*\n+             * Some users like lxml are known to pass nodes with a corrupted\n+             * tree structure. Fall back to a recursive call to handle this\n+             * case.\n+             *\/\n+            if ((cur->parent != parent) && (cur->children != NULL)) {\n+                xmlNodeDumpOutputInternal(ctxt, cur);\n+                break;\n+            }\n@@ -945,0 +959,1 @@\n+                parent = cur;\n@@ -952,1 +967,1 @@\n-        if (cur->content == NULL)\n+            if (cur->content == NULL)\n@@ -954,1 +969,1 @@\n-        if (cur->name != xmlStringTextNoenc) {\n+            if (cur->name != xmlStringTextNoenc) {\n@@ -956,7 +971,7 @@\n-        } else {\n-        \/*\n-         * Disable escaping, needed for XSLT\n-         *\/\n-        xmlOutputBufferWriteString(buf, (const char *) cur->content);\n-        }\n-        break;\n+            } else {\n+                \/*\n+                 * Disable escaping, needed for XSLT\n+                 *\/\n+                xmlOutputBufferWriteString(buf, (const char *) cur->content);\n+            }\n+            break;\n@@ -965,5 +980,5 @@\n-        if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))\n-        xmlOutputBufferWrite(buf, ctxt->indent_size *\n-                     (ctxt->level > ctxt->indent_nr ?\n-                      ctxt->indent_nr : ctxt->level),\n-                     ctxt->indent);\n+            if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))\n+                xmlOutputBufferWrite(buf, ctxt->indent_size *\n+                                     (ctxt->level > ctxt->indent_nr ?\n+                                      ctxt->indent_nr : ctxt->level),\n+                                     ctxt->indent);\n@@ -993,5 +1008,5 @@\n-        if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))\n-        xmlOutputBufferWrite(buf, ctxt->indent_size *\n-                     (ctxt->level > ctxt->indent_nr ?\n-                      ctxt->indent_nr : ctxt->level),\n-                     ctxt->indent);\n+            if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))\n+                xmlOutputBufferWrite(buf, ctxt->indent_size *\n+                                     (ctxt->level > ctxt->indent_nr ?\n+                                      ctxt->indent_nr : ctxt->level),\n+                                     ctxt->indent);\n@@ -1061,7 +1076,3 @@\n-            \/*\n-             * The parent should never be NULL here but we want to handle\n-             * corrupted documents gracefully.\n-             *\/\n-            if (cur->parent == NULL)\n-                return;\n-            cur = cur->parent;\n+            cur = parent;\n+            \/* cur->parent was validated when descending. *\/\n+            parent = cur->parent;\n@@ -1123,1 +1134,1 @@\n-     return(-1);\n+         return(-1);\n@@ -1128,1 +1139,1 @@\n-    encoding = cur->encoding;\n+        encoding = cur->encoding;\n@@ -1137,1 +1148,1 @@\n-        htmlSetMetaEncoding(cur, (const xmlChar *) encoding);\n+            htmlSetMetaEncoding(cur, (const xmlChar *) encoding);\n@@ -1139,1 +1150,1 @@\n-        encoding = htmlGetMetaEncoding(cur);\n+            encoding = htmlGetMetaEncoding(cur);\n@@ -1141,6 +1152,7 @@\n-        encoding = BAD_CAST \"HTML\";\n-    if ((encoding != NULL) && (oldctxtenc == NULL) &&\n-        (buf->encoder == NULL) && (buf->conv == NULL)) {\n-        if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {\n-        cur->encoding = oldenc;\n-        return(-1);\n+            encoding = BAD_CAST \"HTML\";\n+        if ((encoding != NULL) && (oldctxtenc == NULL) &&\n+            (buf->encoder == NULL) && (buf->conv == NULL)) {\n+            if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {\n+                cur->encoding = oldenc;\n+                return(-1);\n+            }\n@@ -1148,1 +1160,0 @@\n-    }\n@@ -1150,8 +1161,8 @@\n-        htmlDocContentDumpFormatOutput(buf, cur,\n-                                       (const char *)encoding, 1);\n-    else\n-        htmlDocContentDumpFormatOutput(buf, cur,\n-                                       (const char *)encoding, 0);\n-    if (ctxt->encoding != NULL)\n-        cur->encoding = oldenc;\n-    return(0);\n+            htmlDocContentDumpFormatOutput(buf, cur,\n+                                           (const char *)encoding, 1);\n+        else\n+            htmlDocContentDumpFormatOutput(buf, cur,\n+                                           (const char *)encoding, 0);\n+        if (ctxt->encoding != NULL)\n+            cur->encoding = oldenc;\n+        return(0);\n@@ -1164,17 +1175,22 @@\n-    enc = xmlParseCharEncoding((const char*) encoding);\n-    if ((encoding != NULL) && (oldctxtenc == NULL) &&\n-        (buf->encoder == NULL) && (buf->conv == NULL) &&\n-        ((ctxt->options & XML_SAVE_NO_DECL) == 0)) {\n-        if ((enc != XML_CHAR_ENCODING_UTF8) &&\n-        (enc != XML_CHAR_ENCODING_NONE) &&\n-        (enc != XML_CHAR_ENCODING_ASCII)) {\n-        \/*\n-         * we need to switch to this encoding but just for this\n-         * document since we output the XMLDecl the conversion\n-         * must be done to not generate not well formed documents.\n-         *\/\n-        if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {\n-            cur->encoding = oldenc;\n-            return(-1);\n-        }\n-        switched_encoding = 1;\n+        enc = xmlParseCharEncoding((const char*) encoding);\n+        if ((encoding != NULL) && (oldctxtenc == NULL) &&\n+            (buf->encoder == NULL) && (buf->conv == NULL) &&\n+            ((ctxt->options & XML_SAVE_NO_DECL) == 0)) {\n+            if ((enc != XML_CHAR_ENCODING_UTF8) &&\n+                (enc != XML_CHAR_ENCODING_NONE) &&\n+                (enc != XML_CHAR_ENCODING_ASCII)) {\n+                \/*\n+                 * we need to switch to this encoding but just for this\n+                 * document since we output the XMLDecl the conversion\n+                 * must be done to not generate not well formed documents.\n+                 *\/\n+                if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {\n+                    cur->encoding = oldenc;\n+                    return(-1);\n+                }\n+                switched_encoding = 1;\n+            }\n+            if (ctxt->escape == xmlEscapeEntities)\n+                ctxt->escape = NULL;\n+            if (ctxt->escapeAttr == xmlEscapeEntities)\n+                ctxt->escapeAttr = NULL;\n@@ -1182,5 +1198,0 @@\n-        if (ctxt->escape == xmlEscapeEntities)\n-        ctxt->escape = NULL;\n-        if (ctxt->escapeAttr == xmlEscapeEntities)\n-        ctxt->escapeAttr = NULL;\n-    }\n@@ -1189,20 +1200,22 @@\n-    \/*\n-     * Save the XML declaration\n-     *\/\n-    if ((ctxt->options & XML_SAVE_NO_DECL) == 0) {\n-        xmlOutputBufferWrite(buf, 14, \"<?xml version=\");\n-        if (cur->version != NULL)\n-        xmlBufWriteQuotedString(buf->buffer, cur->version);\n-        else\n-        xmlOutputBufferWrite(buf, 5, \"\\\"1.0\\\"\");\n-        if (encoding != NULL) {\n-        xmlOutputBufferWrite(buf, 10, \" encoding=\");\n-        xmlBufWriteQuotedString(buf->buffer, (xmlChar *) encoding);\n-        }\n-        switch (cur->standalone) {\n-        case 0:\n-            xmlOutputBufferWrite(buf, 16, \" standalone=\\\"no\\\"\");\n-            break;\n-        case 1:\n-            xmlOutputBufferWrite(buf, 17, \" standalone=\\\"yes\\\"\");\n-            break;\n+        \/*\n+         * Save the XML declaration\n+         *\/\n+        if ((ctxt->options & XML_SAVE_NO_DECL) == 0) {\n+            xmlOutputBufferWrite(buf, 14, \"<?xml version=\");\n+            if (cur->version != NULL)\n+                xmlBufWriteQuotedString(buf->buffer, cur->version);\n+            else\n+                xmlOutputBufferWrite(buf, 5, \"\\\"1.0\\\"\");\n+            if (encoding != NULL) {\n+                xmlOutputBufferWrite(buf, 10, \" encoding=\");\n+                xmlBufWriteQuotedString(buf->buffer, (xmlChar *) encoding);\n+            }\n+            switch (cur->standalone) {\n+                case 0:\n+                    xmlOutputBufferWrite(buf, 16, \" standalone=\\\"no\\\"\");\n+                    break;\n+                case 1:\n+                    xmlOutputBufferWrite(buf, 17, \" standalone=\\\"yes\\\"\");\n+                    break;\n+            }\n+            xmlOutputBufferWrite(buf, 3, \"?>\\n\");\n@@ -1210,2 +1223,0 @@\n-        xmlOutputBufferWrite(buf, 3, \"?>\\n\");\n-    }\n@@ -1216,5 +1227,6 @@\n-    if ((ctxt->options & XML_SAVE_NO_XHTML) == 0) {\n-        dtd = xmlGetIntSubset(cur);\n-        if (dtd != NULL) {\n-        is_xhtml = xmlIsXHTML(dtd->SystemID, dtd->ExternalID);\n-        if (is_xhtml < 0) is_xhtml = 0;\n+        if ((ctxt->options & XML_SAVE_NO_XHTML) == 0) {\n+            dtd = xmlGetIntSubset(cur);\n+            if (dtd != NULL) {\n+                is_xhtml = xmlIsXHTML(dtd->SystemID, dtd->ExternalID);\n+                if (is_xhtml < 0) is_xhtml = 0;\n+            }\n@@ -1222,1 +1234,0 @@\n-    }\n@@ -1224,2 +1235,2 @@\n-    if (cur->children != NULL) {\n-        xmlNodePtr child = cur->children;\n+        if (cur->children != NULL) {\n+            xmlNodePtr child = cur->children;\n@@ -1227,2 +1238,2 @@\n-        while (child != NULL) {\n-        ctxt->level = 0;\n+            while (child != NULL) {\n+                ctxt->level = 0;\n@@ -1230,3 +1241,3 @@\n-        if (is_xhtml)\n-            xhtmlNodeDumpOutput(ctxt, child);\n-        else\n+                if (is_xhtml)\n+                    xhtmlNodeDumpOutput(ctxt, child);\n+                else\n@@ -1234,1 +1245,1 @@\n-            xmlNodeDumpOutputInternal(ctxt, child);\n+                    xmlNodeDumpOutputInternal(ctxt, child);\n@@ -1238,1 +1249,2 @@\n-        child = child->next;\n+                child = child->next;\n+            }\n@@ -1241,1 +1253,0 @@\n-    }\n@@ -1247,3 +1258,3 @@\n-    xmlSaveClearEncoding(ctxt);\n-    ctxt->escape = oldescape;\n-    ctxt->escapeAttr = oldescapeAttr;\n+        xmlSaveClearEncoding(ctxt);\n+        ctxt->escape = oldescape;\n+        ctxt->escapeAttr = oldescapeAttr;\n@@ -1257,3 +1268,3 @@\n- *                                  *\n- *      Functions specific to XHTML serialization       *\n- *                                  *\n+ *                                                                      *\n+ *              Functions specific to XHTML serialization               *\n+ *                                                                      *\n@@ -1273,1 +1284,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1275,29 +1286,0 @@\n-    return(0);\n-    if ((node->ns != NULL) && (!xmlStrEqual(node->ns->href, XHTML_NS_NAME)))\n-    return(0);\n-    if (node->children != NULL)\n-    return(0);\n-    switch (node->name[0]) {\n-    case 'a':\n-        if (xmlStrEqual(node->name, BAD_CAST \"area\"))\n-        return(1);\n-        return(0);\n-    case 'b':\n-        if (xmlStrEqual(node->name, BAD_CAST \"br\"))\n-        return(1);\n-        if (xmlStrEqual(node->name, BAD_CAST \"base\"))\n-        return(1);\n-        if (xmlStrEqual(node->name, BAD_CAST \"basefont\"))\n-        return(1);\n-        return(0);\n-    case 'c':\n-        if (xmlStrEqual(node->name, BAD_CAST \"col\"))\n-        return(1);\n-        return(0);\n-    case 'f':\n-        if (xmlStrEqual(node->name, BAD_CAST \"frame\"))\n-        return(1);\n-        return(0);\n-    case 'h':\n-        if (xmlStrEqual(node->name, BAD_CAST \"hr\"))\n-        return(1);\n@@ -1305,15 +1287,1 @@\n-    case 'i':\n-        if (xmlStrEqual(node->name, BAD_CAST \"img\"))\n-        return(1);\n-        if (xmlStrEqual(node->name, BAD_CAST \"input\"))\n-        return(1);\n-        if (xmlStrEqual(node->name, BAD_CAST \"isindex\"))\n-        return(1);\n-        return(0);\n-    case 'l':\n-        if (xmlStrEqual(node->name, BAD_CAST \"link\"))\n-        return(1);\n-        return(0);\n-    case 'm':\n-        if (xmlStrEqual(node->name, BAD_CAST \"meta\"))\n-        return(1);\n+    if ((node->ns != NULL) && (!xmlStrEqual(node->ns->href, XHTML_NS_NAME)))\n@@ -1321,3 +1289,1 @@\n-    case 'p':\n-        if (xmlStrEqual(node->name, BAD_CAST \"param\"))\n-        return(1);\n+    if (node->children != NULL)\n@@ -1325,0 +1291,45 @@\n+    switch (node->name[0]) {\n+        case 'a':\n+            if (xmlStrEqual(node->name, BAD_CAST \"area\"))\n+                return(1);\n+            return(0);\n+        case 'b':\n+            if (xmlStrEqual(node->name, BAD_CAST \"br\"))\n+                return(1);\n+            if (xmlStrEqual(node->name, BAD_CAST \"base\"))\n+                return(1);\n+            if (xmlStrEqual(node->name, BAD_CAST \"basefont\"))\n+                return(1);\n+            return(0);\n+        case 'c':\n+            if (xmlStrEqual(node->name, BAD_CAST \"col\"))\n+                return(1);\n+            return(0);\n+        case 'f':\n+            if (xmlStrEqual(node->name, BAD_CAST \"frame\"))\n+                return(1);\n+            return(0);\n+        case 'h':\n+            if (xmlStrEqual(node->name, BAD_CAST \"hr\"))\n+                return(1);\n+            return(0);\n+        case 'i':\n+            if (xmlStrEqual(node->name, BAD_CAST \"img\"))\n+                return(1);\n+            if (xmlStrEqual(node->name, BAD_CAST \"input\"))\n+                return(1);\n+            if (xmlStrEqual(node->name, BAD_CAST \"isindex\"))\n+                return(1);\n+            return(0);\n+        case 'l':\n+            if (xmlStrEqual(node->name, BAD_CAST \"link\"))\n+                return(1);\n+            return(0);\n+        case 'm':\n+            if (xmlStrEqual(node->name, BAD_CAST \"meta\"))\n+                return(1);\n+            return(0);\n+        case 'p':\n+            if (xmlStrEqual(node->name, BAD_CAST \"param\"))\n+                return(1);\n+            return(0);\n@@ -1348,23 +1359,23 @@\n-    if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST \"id\")))\n-        id = cur;\n-    else\n-    if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST \"name\")))\n-        name = cur;\n-    else\n-    if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST \"lang\")))\n-        lang = cur;\n-    else\n-    if ((cur->ns != NULL) && (xmlStrEqual(cur->name, BAD_CAST \"lang\")) &&\n-        (xmlStrEqual(cur->ns->prefix, BAD_CAST \"xml\")))\n-        xml_lang = cur;\n-    else if ((cur->ns == NULL) &&\n-         ((cur->children == NULL) ||\n-          (cur->children->content == NULL) ||\n-          (cur->children->content[0] == 0)) &&\n-         (htmlIsBooleanAttr(cur->name))) {\n-        if (cur->children != NULL)\n-        xmlFreeNode(cur->children);\n-        cur->children = xmlNewText(cur->name);\n-        if (cur->children != NULL)\n-        cur->children->parent = (xmlNodePtr) cur;\n-    }\n+        if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST \"id\")))\n+            id = cur;\n+        else\n+        if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST \"name\")))\n+            name = cur;\n+        else\n+        if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST \"lang\")))\n+            lang = cur;\n+        else\n+        if ((cur->ns != NULL) && (xmlStrEqual(cur->name, BAD_CAST \"lang\")) &&\n+            (xmlStrEqual(cur->ns->prefix, BAD_CAST \"xml\")))\n+            xml_lang = cur;\n+        else if ((cur->ns == NULL) &&\n+                 ((cur->children == NULL) ||\n+                  (cur->children->content == NULL) ||\n+                  (cur->children->content[0] == 0)) &&\n+                 (htmlIsBooleanAttr(cur->name))) {\n+            if (cur->children != NULL)\n+                xmlFreeNode(cur->children);\n+            cur->children = xmlNewText(cur->name);\n+            if (cur->children != NULL)\n+                cur->children->parent = (xmlNodePtr) cur;\n+        }\n@@ -1372,1 +1383,1 @@\n-    cur = cur->next;\n+        cur = cur->next;\n@@ -1378,14 +1389,14 @@\n-    if ((parent != NULL) && (parent->name != NULL) &&\n-        ((xmlStrEqual(parent->name, BAD_CAST \"a\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"p\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"div\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"img\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"map\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"applet\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"form\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"frame\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"iframe\")))) {\n-        xmlOutputBufferWrite(buf, 5, \" id=\\\"\");\n-        xmlAttrSerializeContent(buf, name);\n-        xmlOutputBufferWrite(buf, 1, \"\\\"\");\n-    }\n+        if ((parent != NULL) && (parent->name != NULL) &&\n+            ((xmlStrEqual(parent->name, BAD_CAST \"a\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"p\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"div\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"img\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"map\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"applet\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"form\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"frame\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"iframe\")))) {\n+            xmlOutputBufferWrite(buf, 5, \" id=\\\"\");\n+            xmlAttrSerializeContent(buf, name);\n+            xmlOutputBufferWrite(buf, 1, \"\\\"\");\n+        }\n@@ -1397,3 +1408,3 @@\n-    xmlOutputBufferWrite(buf, 11, \" xml:lang=\\\"\");\n-    xmlAttrSerializeContent(buf, lang);\n-    xmlOutputBufferWrite(buf, 1, \"\\\"\");\n+        xmlOutputBufferWrite(buf, 11, \" xml:lang=\\\"\");\n+        xmlAttrSerializeContent(buf, lang);\n+        xmlOutputBufferWrite(buf, 1, \"\\\"\");\n@@ -1402,3 +1413,3 @@\n-    xmlOutputBufferWrite(buf, 7, \" lang=\\\"\");\n-    xmlAttrSerializeContent(buf, xml_lang);\n-    xmlOutputBufferWrite(buf, 1, \"\\\"\");\n+        xmlOutputBufferWrite(buf, 7, \" lang=\\\"\");\n+        xmlAttrSerializeContent(buf, xml_lang);\n+        xmlOutputBufferWrite(buf, 1, \"\\\"\");\n@@ -1434,1 +1445,1 @@\n-        break;\n+            break;\n@@ -1437,2 +1448,2 @@\n-        xmlNsDumpOutputCtxt(ctxt, (xmlNsPtr) cur);\n-        break;\n+            xmlNsDumpOutputCtxt(ctxt, (xmlNsPtr) cur);\n+            break;\n@@ -1442,1 +1453,1 @@\n-        break;\n+            break;\n@@ -1453,1 +1464,1 @@\n-        break;\n+            break;\n@@ -1457,1 +1468,1 @@\n-        break;\n+            break;\n@@ -1461,1 +1472,1 @@\n-        break;\n+            break;\n@@ -1466,5 +1477,5 @@\n-        if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))\n-        xmlOutputBufferWrite(buf, ctxt->indent_size *\n-                     (ctxt->level > ctxt->indent_nr ?\n-                      ctxt->indent_nr : ctxt->level),\n-                     ctxt->indent);\n+            if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))\n+                xmlOutputBufferWrite(buf, ctxt->indent_size *\n+                                     (ctxt->level > ctxt->indent_nr ?\n+                                      ctxt->indent_nr : ctxt->level),\n+                                     ctxt->indent);\n@@ -1608,1 +1619,1 @@\n-        if (cur->content == NULL)\n+            if (cur->content == NULL)\n@@ -1610,2 +1621,2 @@\n-        if ((cur->name == xmlStringText) ||\n-        (cur->name != xmlStringTextNoenc)) {\n+            if ((cur->name == xmlStringText) ||\n+                (cur->name != xmlStringTextNoenc)) {\n@@ -1613,7 +1624,7 @@\n-        } else {\n-        \/*\n-         * Disable escaping, needed for XSLT\n-         *\/\n-        xmlOutputBufferWriteString(buf, (const char *) cur->content);\n-        }\n-        break;\n+            } else {\n+                \/*\n+                 * Disable escaping, needed for XSLT\n+                 *\/\n+                xmlOutputBufferWriteString(buf, (const char *) cur->content);\n+            }\n+            break;\n@@ -1679,1 +1690,1 @@\n-        break;\n+            break;\n@@ -1732,3 +1743,3 @@\n- *                                  *\n- *          Public entry points             *\n- *                                  *\n+ *                                                                      *\n+ *                      Public entry points                             *\n+ *                                                                      *\n@@ -1758,2 +1769,2 @@\n-    xmlFreeSaveCtxt(ret);\n-    return(NULL);\n+        xmlFreeSaveCtxt(ret);\n+        return(NULL);\n@@ -1788,2 +1799,2 @@\n-    xmlFreeSaveCtxt(ret);\n-    return(NULL);\n+        xmlFreeSaveCtxt(ret);\n+        return(NULL);\n@@ -1816,2 +1827,2 @@\n-    xmlFreeSaveCtxt(ret);\n-    return(NULL);\n+        xmlFreeSaveCtxt(ret);\n+        return(NULL);\n@@ -1847,2 +1858,2 @@\n-    xmlFreeSaveCtxt(ret);\n-    return(NULL);\n+        xmlFreeSaveCtxt(ret);\n+        return(NULL);\n@@ -1901,2 +1912,2 @@\n-    htmlNodeDumpOutputInternal(ctxt, cur);\n-    return(ret);\n+        htmlNodeDumpOutputInternal(ctxt, cur);\n+        return(ret);\n@@ -1981,3 +1992,3 @@\n- *                                  *\n- *      Public entry points based on buffers            *\n- *                                  *\n+ *                                                                      *\n+ *              Public entry points based on buffers                    *\n+ *                                                                      *\n@@ -2048,1 +2059,1 @@\n-               ((doc == NULL) || (doc->encoding == NULL))) {\n+                   ((doc == NULL) || (doc->encoding == NULL))) {\n@@ -2059,1 +2070,1 @@\n-        xmlSerializeHexCharRef(tmp, *cur);\n+                xmlSerializeHexCharRef(tmp, *cur);\n@@ -2088,1 +2099,1 @@\n-        xmlSerializeHexCharRef(tmp, *cur);\n+                xmlSerializeHexCharRef(tmp, *cur);\n@@ -2098,1 +2109,1 @@\n-        xmlSerializeHexCharRef(tmp, val);\n+            xmlSerializeHexCharRef(tmp, val);\n@@ -2269,1 +2280,1 @@\n-    xmlSaveErr(XML_ERR_INTERNAL_ERROR, cur, \"HTML support not compiled in\\n\");\n+        xmlSaveErr(XML_ERR_INTERNAL_ERROR, cur, \"HTML support not compiled in\\n\");\n@@ -2277,3 +2288,3 @@\n- *                                  *\n- *      Saving functions front-ends             *\n- *                                  *\n+ *                                                                      *\n+ *              Saving functions front-ends                             *\n+ *                                                                      *\n@@ -2323,3 +2334,3 @@\n-    is_xhtml = xmlIsXHTML(dtd->SystemID, dtd->ExternalID);\n-    if (is_xhtml < 0)\n-        is_xhtml = 0;\n+        is_xhtml = xmlIsXHTML(dtd->SystemID, dtd->ExternalID);\n+        if (is_xhtml < 0)\n+            is_xhtml = 0;\n@@ -2352,2 +2363,2 @@\n-        int * doc_txt_len, const char * txt_encoding,\n-        int format) {\n+                int * doc_txt_len, const char * txt_encoding,\n+                int format) {\n@@ -2382,1 +2393,1 @@\n-    txt_encoding = (const char *) out_doc->encoding;\n+        txt_encoding = (const char *) out_doc->encoding;\n@@ -2384,6 +2395,6 @@\n-    conv_hdlr = xmlFindCharEncodingHandler(txt_encoding);\n-    if ( conv_hdlr == NULL ) {\n-        xmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, (xmlNodePtr) out_doc,\n-               txt_encoding);\n-        return;\n-    }\n+        conv_hdlr = xmlFindCharEncodingHandler(txt_encoding);\n+        if ( conv_hdlr == NULL ) {\n+            xmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, (xmlNodePtr) out_doc,\n+                       txt_encoding);\n+            return;\n+        }\n@@ -2407,2 +2418,2 @@\n-    *doc_txt_len = xmlBufUse(out_buff->conv);\n-    *doc_txt_ptr = xmlStrndup(xmlBufContent(out_buff->conv), *doc_txt_len);\n+        *doc_txt_len = xmlBufUse(out_buff->conv);\n+        *doc_txt_ptr = xmlStrndup(xmlBufContent(out_buff->conv), *doc_txt_len);\n@@ -2410,2 +2421,2 @@\n-    *doc_txt_len = xmlBufUse(out_buff->buffer);\n-    *doc_txt_ptr = xmlStrndup(xmlBufContent(out_buff->buffer),*doc_txt_len);\n+        *doc_txt_len = xmlBufUse(out_buff->buffer);\n+        *doc_txt_ptr = xmlStrndup(xmlBufContent(out_buff->buffer),*doc_txt_len);\n@@ -2471,1 +2482,1 @@\n-                int * doc_txt_len, const char * txt_encoding) {\n+                    int * doc_txt_len, const char * txt_encoding) {\n@@ -2473,1 +2484,1 @@\n-                          txt_encoding, 0);\n+                              txt_encoding, 0);\n@@ -2499,1 +2510,1 @@\n-        \"xmlDocDump : document == NULL\\n\");\n+                \"xmlDocDump : document == NULL\\n\");\n@@ -2501,1 +2512,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2506,6 +2517,6 @@\n-    handler = xmlFindCharEncodingHandler(encoding);\n-    if (handler == NULL) {\n-        xmlFree((char *) cur->encoding);\n-        cur->encoding = NULL;\n-        encoding = NULL;\n-    }\n+        handler = xmlFindCharEncodingHandler(encoding);\n+        if (handler == NULL) {\n+            xmlFree((char *) cur->encoding);\n+            cur->encoding = NULL;\n+            encoding = NULL;\n+        }\n@@ -2562,1 +2573,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2599,1 +2610,1 @@\n-     (cur->type != XML_HTML_DOCUMENT_NODE))) {\n+         (cur->type != XML_HTML_DOCUMENT_NODE))) {\n@@ -2601,1 +2612,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2630,1 +2641,1 @@\n-            const char * encoding, int format ) {\n+                        const char * encoding, int format ) {\n@@ -2637,1 +2648,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2640,1 +2651,1 @@\n-    encoding = (const char *) cur->encoding;\n+        encoding = (const char *) cur->encoding;\n@@ -2644,3 +2655,3 @@\n-        handler = xmlFindCharEncodingHandler(encoding);\n-        if (handler == NULL)\n-        return(-1);\n+            handler = xmlFindCharEncodingHandler(encoding);\n+            if (handler == NULL)\n+                return(-1);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlsave.c","additions":533,"deletions":522,"binary":false,"changes":1055,"status":"modified"},{"patch":"@@ -21,0 +21,1 @@\n+#include <limits.h>\n@@ -45,1 +46,1 @@\n-    ret = (xmlChar *) xmlMallocAtomic((len + 1) * sizeof(xmlChar));\n+    ret = (xmlChar *) xmlMallocAtomic(((size_t) len + 1) * sizeof(xmlChar));\n@@ -90,1 +91,1 @@\n-    ret = (xmlChar *) xmlMallocAtomic((len + 1) * sizeof(xmlChar));\n+    ret = (xmlChar *) xmlMallocAtomic(((size_t) len + 1) * sizeof(xmlChar));\n@@ -426,1 +427,1 @@\n-    int len = 0;\n+    size_t len = 0;\n@@ -433,1 +434,1 @@\n-    return(len);\n+    return(len > INT_MAX ? 0 : len);\n@@ -458,1 +459,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -463,1 +464,1 @@\n-    if (size < 0)\n+    if ((size < 0) || (size > INT_MAX - len))\n@@ -465,1 +466,1 @@\n-    ret = (xmlChar *) xmlRealloc(cur, (size + len + 1) * sizeof(xmlChar));\n+    ret = (xmlChar *) xmlRealloc(cur, ((size_t) size + len + 1) * sizeof(xmlChar));\n@@ -503,1 +504,1 @@\n-    if (size < 0)\n+    if ((size < 0) || (size > INT_MAX - len))\n@@ -505,1 +506,1 @@\n-    ret = (xmlChar *) xmlMalloc((size + len + 1) * sizeof(xmlChar));\n+    ret = (xmlChar *) xmlMalloc(((size_t) size + len + 1) * sizeof(xmlChar));\n@@ -670,1 +671,1 @@\n-    int ret = 0;\n+    size_t ret = 0;\n@@ -697,1 +698,1 @@\n-    return(ret);\n+    return(ret > INT_MAX ? 0 : ret);\n@@ -766,1 +767,1 @@\n-    *len = 0;\n+        *len = 0;\n@@ -799,16 +800,20 @@\n-    for (ix = 0; (c = utf[ix]);) {      \/* string is 0-terminated *\/\n-        if ((c & 0x80) == 0x00) {   \/* 1-byte code, starts with 10 *\/\n-            ix++;\n-    } else if ((c & 0xe0) == 0xc0) {\/* 2-byte code, starts with 110 *\/\n-        if ((utf[ix+1] & 0xc0 ) != 0x80)\n-            return 0;\n-        ix += 2;\n-    } else if ((c & 0xf0) == 0xe0) {\/* 3-byte code, starts with 1110 *\/\n-        if (((utf[ix+1] & 0xc0) != 0x80) ||\n-            ((utf[ix+2] & 0xc0) != 0x80))\n-            return 0;\n-        ix += 3;\n-    } else if ((c & 0xf8) == 0xf0) {\/* 4-byte code, starts with 11110 *\/\n-        if (((utf[ix+1] & 0xc0) != 0x80) ||\n-            ((utf[ix+2] & 0xc0) != 0x80) ||\n-        ((utf[ix+3] & 0xc0) != 0x80))\n+    while ((c = utf[0])) {      \/* string is 0-terminated *\/\n+        ix = 0;\n+        if ((c & 0x80) == 0x00) {       \/* 1-byte code, starts with 10 *\/\n+            ix = 1;\n+        } else if ((c & 0xe0) == 0xc0) {\/* 2-byte code, starts with 110 *\/\n+            if ((utf[1] & 0xc0 ) != 0x80)\n+                return 0;\n+            ix = 2;\n+        } else if ((c & 0xf0) == 0xe0) {\/* 3-byte code, starts with 1110 *\/\n+            if (((utf[1] & 0xc0) != 0x80) ||\n+                ((utf[2] & 0xc0) != 0x80))\n+                    return 0;\n+            ix = 3;\n+        } else if ((c & 0xf8) == 0xf0) {\/* 4-byte code, starts with 11110 *\/\n+            if (((utf[1] & 0xc0) != 0x80) ||\n+                ((utf[2] & 0xc0) != 0x80) ||\n+                ((utf[3] & 0xc0) != 0x80))\n+                    return 0;\n+            ix = 4;\n+        } else                          \/* unknown encoding *\/\n@@ -816,3 +821,1 @@\n-        ix += 4;\n-    } else              \/* unknown encoding *\/\n-        return 0;\n+        utf += ix;\n@@ -837,2 +840,3 @@\n-    const xmlChar   *ptr=utf;\n-    xmlChar         ch;\n+    const xmlChar *ptr=utf;\n+    int ch;\n+    size_t ret;\n@@ -851,1 +855,1 @@\n-        if (*ptr == 0) break;\n+                if (*ptr == 0) break;\n@@ -853,1 +857,1 @@\n-        }\n+            }\n@@ -855,1 +859,2 @@\n-    return (ptr - utf);\n+    ret = ptr - utf;\n+    return (ret > INT_MAX ? 0 : ret);\n@@ -875,1 +880,1 @@\n-    ret = (xmlChar *) xmlMallocAtomic((i + 1) * sizeof(xmlChar));\n+    ret = (xmlChar *) xmlMallocAtomic(((size_t) i + 1) * sizeof(xmlChar));\n@@ -877,3 +882,0 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"malloc of %ld byte failed\\n\",\n-                (len + 1) * (long)sizeof(xmlChar));\n@@ -899,1 +901,1 @@\n-    xmlChar ch;\n+    int ch;\n@@ -931,2 +933,3 @@\n-    int i, size;\n-    xmlChar ch;\n+    size_t i;\n+    int size;\n+    int ch;\n@@ -938,1 +941,1 @@\n-                return(i);\n+                return(i > INT_MAX ? 0 : i);\n@@ -968,2 +971,2 @@\n-    int            i;\n-    xmlChar ch;\n+    int i;\n+    int ch;\n@@ -1025,0 +1028,2 @@\n+    if ((count > INT_MAX) || (msgLen > INT_MAX - count))\n+        return(NULL);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlstring.c","additions":51,"deletions":46,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-    int         numentries;\n+    int             numentries;\n@@ -956,7 +956,7 @@\n-    mid = (low + high) \/ 2;\n-    if ((cmp=strcmp(tname, sptr[mid].rangename)) == 0)\n-        return (sptr[mid].func);\n-    if (cmp < 0)\n-        high = mid - 1;\n-    else\n-        low = mid + 1;\n+        mid = (low + high) \/ 2;\n+        if ((cmp=strcmp(tname, sptr[mid].rangename)) == 0)\n+            return (sptr[mid].func);\n+        if (cmp < 0)\n+            high = mid - 1;\n+        else\n+            low = mid + 1;\n@@ -2648,1 +2648,1 @@\n-    return (-1);\n+        return (-1);\n@@ -3173,1 +3173,1 @@\n-    return (-1);\n+        return (-1);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlunicode.c","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -138,3 +138,3 @@\n-    __xmlRaiseError(NULL, NULL, NULL, ctxt->ctxt,\n-                NULL, XML_FROM_WRITER, error, XML_ERR_FATAL,\n-            NULL, 0, NULL, NULL, NULL, 0, 0, \"%s\", msg);\n+        __xmlRaiseError(NULL, NULL, NULL, ctxt->ctxt,\n+                    NULL, XML_FROM_WRITER, error, XML_ERR_FATAL,\n+                    NULL, 0, NULL, NULL, NULL, 0, 0, \"%s\", msg);\n@@ -142,1 +142,1 @@\n-    __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_WRITER, error,\n+        __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_WRITER, error,\n@@ -161,3 +161,3 @@\n-    __xmlRaiseError(NULL, NULL, NULL, ctxt->ctxt,\n-                NULL, XML_FROM_WRITER, error, XML_ERR_FATAL,\n-            NULL, 0, NULL, NULL, NULL, val, 0, msg, val);\n+        __xmlRaiseError(NULL, NULL, NULL, ctxt->ctxt,\n+                    NULL, XML_FROM_WRITER, error, XML_ERR_FATAL,\n+                    NULL, 0, NULL, NULL, NULL, val, 0, msg, val);\n@@ -165,1 +165,1 @@\n-    __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_WRITER, error,\n+        __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_WRITER, error,\n@@ -405,1 +405,1 @@\n-    ret->no_doc_free = 1;\n+        ret->no_doc_free = 1;\n@@ -493,3 +493,3 @@\n-        xmlFreeDoc(writer->ctxt->myDoc);\n-        writer->ctxt->myDoc = NULL;\n-    }\n+            xmlFreeDoc(writer->ctxt->myDoc);\n+            writer->ctxt->myDoc = NULL;\n+        }\n@@ -552,3 +552,3 @@\n-    if (writer->out->conv == NULL) {\n-        writer->out->conv = xmlBufCreateSize(4000);\n-    }\n+        if (writer->out->conv == NULL) {\n+            writer->out->conv = xmlBufCreateSize(4000);\n+        }\n@@ -977,6 +977,6 @@\n-                case XML_TEXTWRITER_ATTRIBUTE:\n-                    count = xmlTextWriterEndAttribute(writer);\n-                    if (count < 0)\n-                        return -1;\n-                    sum += count;\n-                    \/* fallthrough *\/\n+                                case XML_TEXTWRITER_ATTRIBUTE:\n+                                        count = xmlTextWriterEndAttribute(writer);\n+                                        if (count < 0)\n+                                                return -1;\n+                                        sum += count;\n+                                        \/* fallthrough *\/\n@@ -1500,1 +1500,1 @@\n-            xmlOutputBufferWriteEscape(writer->out, content, NULL);\n+                    xmlOutputBufferWriteEscape(writer->out, content, NULL);\n@@ -1509,2 +1509,2 @@\n-        default:\n-            break;\n+                default:\n+                    break;\n@@ -1546,4 +1546,4 @@\n-         'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',\n-         'a','b','c','d','e','f','g','h','i','j','k','l','m',\n-         'n','o','p','q','r','s','t','u','v','w','x','y','z',\n-         '0','1','2','3','4','5','6','7','8','9','+','\/'};\n+             'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',\n+             'a','b','c','d','e','f','g','h','i','j','k','l','m',\n+             'n','o','p','q','r','s','t','u','v','w','x','y','z',\n+             '0','1','2','3','4','5','6','7','8','9','+','\/'};\n@@ -1678,1 +1678,1 @@\n-    {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n+        {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n@@ -1873,1 +1873,1 @@\n-                                        \"xmlTextWriterStartAttributeNS : out of memory!\\n\");\n+                                                                        \"xmlTextWriterStartAttributeNS : out of memory!\\n\");\n@@ -2240,4 +2240,4 @@\n-    count = xmlTextWriterWriteString(writer, content);\n-    if (count == -1)\n-        return -1;\n-    sum += count;\n+        count = xmlTextWriterWriteString(writer, content);\n+        if (count == -1)\n+            return -1;\n+        sum += count;\n@@ -2503,2 +2503,2 @@\n-    if (count < 0)\n-    return -1;\n+        if (count < 0)\n+        return -1;\n@@ -2632,1 +2632,1 @@\n-        case XML_TEXTWRITER_TEXT:\n+                case XML_TEXTWRITER_TEXT:\n@@ -2928,1 +2928,1 @@\n-            if (writer->indent)\n+                        if (writer->indent)\n@@ -4486,1 +4486,1 @@\n-    va_end(locarg);\n+        va_end(locarg);\n@@ -4495,1 +4495,1 @@\n-    VA_COPY(locarg, argptr);\n+        VA_COPY(locarg, argptr);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlwriter.c","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -71,3 +71,3 @@\n-#define TODO                                \\\n-    xmlGenericError(xmlGenericErrorContext,             \\\n-        \"Unimplemented block at %s:%d\\n\",               \\\n+#define TODO                                                            \\\n+    xmlGenericError(xmlGenericErrorContext,                             \\\n+            \"Unimplemented block at %s:%d\\n\",                           \\\n@@ -177,1 +177,1 @@\n-    return(-2);\n+        return(-2);\n@@ -180,1 +180,1 @@\n-    return(0);\n+        return(0);\n@@ -186,36 +186,14 @@\n-    case XML_ELEMENT_NODE:\n-        if (node2->type == XML_ELEMENT_NODE) {\n-        if ((0 > (ptrdiff_t) node1->content) &&\n-            (0 > (ptrdiff_t) node2->content) &&\n-            (node1->doc == node2->doc))\n-        {\n-            l1 = -((ptrdiff_t) node1->content);\n-            l2 = -((ptrdiff_t) node2->content);\n-            if (l1 < l2)\n-            return(1);\n-            if (l1 > l2)\n-            return(-1);\n-        } else\n-            goto turtle_comparison;\n-        }\n-        break;\n-    case XML_ATTRIBUTE_NODE:\n-        precedence1 = 1; \/* element is owner *\/\n-        miscNode1 = node1;\n-        node1 = node1->parent;\n-        misc = 1;\n-        break;\n-    case XML_TEXT_NODE:\n-    case XML_CDATA_SECTION_NODE:\n-    case XML_COMMENT_NODE:\n-    case XML_PI_NODE: {\n-        miscNode1 = node1;\n-        \/*\n-        * Find nearest element node.\n-        *\/\n-        if (node1->prev != NULL) {\n-        do {\n-            node1 = node1->prev;\n-            if (node1->type == XML_ELEMENT_NODE) {\n-            precedence1 = 3; \/* element in prev-sibl axis *\/\n-            break;\n+        case XML_ELEMENT_NODE:\n+            if (node2->type == XML_ELEMENT_NODE) {\n+                if ((0 > (ptrdiff_t) node1->content) &&\n+                    (0 > (ptrdiff_t) node2->content) &&\n+                    (node1->doc == node2->doc))\n+                {\n+                    l1 = -((ptrdiff_t) node1->content);\n+                    l2 = -((ptrdiff_t) node2->content);\n+                    if (l1 < l2)\n+                        return(1);\n+                    if (l1 > l2)\n+                        return(-1);\n+                } else\n+                    goto turtle_comparison;\n@@ -223,6 +201,4 @@\n-            if (node1->prev == NULL) {\n-            precedence1 = 2; \/* element is parent *\/\n-            \/*\n-            * URGENT TODO: Are there any cases, where the\n-            * parent of such a node is not an element node?\n-            *\/\n+            break;\n+        case XML_ATTRIBUTE_NODE:\n+            precedence1 = 1; \/* element is owner *\/\n+            miscNode1 = node1;\n@@ -230,0 +206,1 @@\n+            misc = 1;\n@@ -231,0 +208,28 @@\n+        case XML_TEXT_NODE:\n+        case XML_CDATA_SECTION_NODE:\n+        case XML_COMMENT_NODE:\n+        case XML_PI_NODE: {\n+            miscNode1 = node1;\n+            \/*\n+            * Find nearest element node.\n+            *\/\n+            if (node1->prev != NULL) {\n+                do {\n+                    node1 = node1->prev;\n+                    if (node1->type == XML_ELEMENT_NODE) {\n+                        precedence1 = 3; \/* element in prev-sibl axis *\/\n+                        break;\n+                    }\n+                    if (node1->prev == NULL) {\n+                        precedence1 = 2; \/* element is parent *\/\n+                        \/*\n+                        * URGENT TODO: Are there any cases, where the\n+                        * parent of such a node is not an element node?\n+                        *\/\n+                        node1 = node1->parent;\n+                        break;\n+                    }\n+                } while (1);\n+            } else {\n+                precedence1 = 2; \/* element is parent *\/\n+                node1 = node1->parent;\n@@ -232,4 +237,9 @@\n-        } while (1);\n-        } else {\n-        precedence1 = 2; \/* element is parent *\/\n-        node1 = node1->parent;\n+            if ((node1 == NULL) || (node1->type != XML_ELEMENT_NODE) ||\n+                (0 <= (ptrdiff_t) node1->content)) {\n+                \/*\n+                * Fallback for whatever case.\n+                *\/\n+                node1 = miscNode1;\n+                precedence1 = 0;\n+            } else\n+                misc = 1;\n@@ -237,18 +247,8 @@\n-        if ((node1 == NULL) || (node1->type != XML_ELEMENT_NODE) ||\n-        (0 <= (ptrdiff_t) node1->content)) {\n-        \/*\n-        * Fallback for whatever case.\n-        *\/\n-        node1 = miscNode1;\n-        precedence1 = 0;\n-        } else\n-        misc = 1;\n-    }\n-        break;\n-    case XML_NAMESPACE_DECL:\n-        \/*\n-        * TODO: why do we return 1 for namespace nodes?\n-        *\/\n-        return(1);\n-    default:\n-        break;\n+            break;\n+        case XML_NAMESPACE_DECL:\n+            \/*\n+            * TODO: why do we return 1 for namespace nodes?\n+            *\/\n+            return(1);\n+        default:\n+            break;\n@@ -257,18 +257,1 @@\n-    case XML_ELEMENT_NODE:\n-        break;\n-    case XML_ATTRIBUTE_NODE:\n-        precedence2 = 1; \/* element is owner *\/\n-        miscNode2 = node2;\n-        node2 = node2->parent;\n-        misc = 1;\n-        break;\n-    case XML_TEXT_NODE:\n-    case XML_CDATA_SECTION_NODE:\n-    case XML_COMMENT_NODE:\n-    case XML_PI_NODE: {\n-        miscNode2 = node2;\n-        if (node2->prev != NULL) {\n-        do {\n-            node2 = node2->prev;\n-            if (node2->type == XML_ELEMENT_NODE) {\n-            precedence2 = 3; \/* element in prev-sibl axis *\/\n+        case XML_ELEMENT_NODE:\n@@ -276,3 +259,3 @@\n-            }\n-            if (node2->prev == NULL) {\n-            precedence2 = 2; \/* element is parent *\/\n+        case XML_ATTRIBUTE_NODE:\n+            precedence2 = 1; \/* element is owner *\/\n+            miscNode2 = node2;\n@@ -280,0 +263,1 @@\n+            misc = 1;\n@@ -281,0 +265,21 @@\n+        case XML_TEXT_NODE:\n+        case XML_CDATA_SECTION_NODE:\n+        case XML_COMMENT_NODE:\n+        case XML_PI_NODE: {\n+            miscNode2 = node2;\n+            if (node2->prev != NULL) {\n+                do {\n+                    node2 = node2->prev;\n+                    if (node2->type == XML_ELEMENT_NODE) {\n+                        precedence2 = 3; \/* element in prev-sibl axis *\/\n+                        break;\n+                    }\n+                    if (node2->prev == NULL) {\n+                        precedence2 = 2; \/* element is parent *\/\n+                        node2 = node2->parent;\n+                        break;\n+                    }\n+                } while (1);\n+            } else {\n+                precedence2 = 2; \/* element is parent *\/\n+                node2 = node2->parent;\n@@ -282,4 +287,7 @@\n-        } while (1);\n-        } else {\n-        precedence2 = 2; \/* element is parent *\/\n-        node2 = node2->parent;\n+            if ((node2 == NULL) || (node2->type != XML_ELEMENT_NODE) ||\n+                (0 <= (ptrdiff_t) node2->content))\n+            {\n+                node2 = miscNode2;\n+                precedence2 = 0;\n+            } else\n+                misc = 1;\n@@ -287,13 +295,5 @@\n-        if ((node2 == NULL) || (node2->type != XML_ELEMENT_NODE) ||\n-        (0 <= (ptrdiff_t) node2->content))\n-        {\n-        node2 = miscNode2;\n-        precedence2 = 0;\n-        } else\n-        misc = 1;\n-    }\n-        break;\n-    case XML_NAMESPACE_DECL:\n-        return(1);\n-    default:\n-        break;\n+            break;\n+        case XML_NAMESPACE_DECL:\n+            return(1);\n+        default:\n+            break;\n@@ -302,13 +302,26 @@\n-    if (node1 == node2) {\n-        if (precedence1 == precedence2) {\n-        \/*\n-        * The ugly case; but normally there aren't many\n-        * adjacent non-element nodes around.\n-        *\/\n-        cur = miscNode2->prev;\n-        while (cur != NULL) {\n-            if (cur == miscNode1)\n-            return(1);\n-            if (cur->type == XML_ELEMENT_NODE)\n-            return(-1);\n-            cur = cur->prev;\n+        if (node1 == node2) {\n+            if (precedence1 == precedence2) {\n+                \/*\n+                * The ugly case; but normally there aren't many\n+                * adjacent non-element nodes around.\n+                *\/\n+                cur = miscNode2->prev;\n+                while (cur != NULL) {\n+                    if (cur == miscNode1)\n+                        return(1);\n+                    if (cur->type == XML_ELEMENT_NODE)\n+                        return(-1);\n+                    cur = cur->prev;\n+                }\n+                return (-1);\n+            } else {\n+                \/*\n+                * Evaluate based on higher precedence wrt to the element.\n+                * TODO: This assumes attributes are sorted before content.\n+                *   Is this 100% correct?\n+                *\/\n+                if (precedence1 < precedence2)\n+                    return(1);\n+                else\n+                    return(-1);\n+            }\n@@ -316,2 +329,0 @@\n-        return (-1);\n-        } else {\n@@ -319,3 +330,7 @@\n-        * Evaluate based on higher precedence wrt to the element.\n-        * TODO: This assumes attributes are sorted before content.\n-        *   Is this 100% correct?\n+        * Special case: One of the helper-elements is contained by the other.\n+        * <foo>\n+        *   <node2>\n+        *     <node1>Text-1(precedence1 == 2)<\/node1>\n+        *   <\/node2>\n+        *   Text-6(precedence2 == 3)\n+        * <\/foo>\n@@ -323,21 +338,7 @@\n-        if (precedence1 < precedence2)\n-            return(1);\n-        else\n-            return(-1);\n-        }\n-    }\n-    \/*\n-    * Special case: One of the helper-elements is contained by the other.\n-    * <foo>\n-    *   <node2>\n-    *     <node1>Text-1(precedence1 == 2)<\/node1>\n-    *   <\/node2>\n-    *   Text-6(precedence2 == 3)\n-    * <\/foo>\n-    *\/\n-    if ((precedence2 == 3) && (precedence1 > 1)) {\n-        cur = node1->parent;\n-        while (cur) {\n-        if (cur == node2)\n-            return(1);\n-        cur = cur->parent;\n+        if ((precedence2 == 3) && (precedence1 > 1)) {\n+            cur = node1->parent;\n+            while (cur) {\n+                if (cur == node2)\n+                    return(1);\n+                cur = cur->parent;\n+            }\n@@ -345,7 +346,7 @@\n-    }\n-    if ((precedence1 == 3) && (precedence2 > 1)) {\n-        cur = node2->parent;\n-        while (cur) {\n-        if (cur == node1)\n-            return(-1);\n-        cur = cur->parent;\n+        if ((precedence1 == 3) && (precedence2 > 1)) {\n+            cur = node2->parent;\n+            while (cur) {\n+                if (cur == node1)\n+                    return(-1);\n+                cur = cur->parent;\n+            }\n@@ -354,1 +355,0 @@\n-    }\n@@ -360,11 +360,11 @@\n-    (node2->type == XML_ELEMENT_NODE) &&\n-    (0 > (ptrdiff_t) node1->content) &&\n-    (0 > (ptrdiff_t) node2->content) &&\n-    (node1->doc == node2->doc)) {\n-\n-    l1 = -((ptrdiff_t) node1->content);\n-    l2 = -((ptrdiff_t) node2->content);\n-    if (l1 < l2)\n-        return(1);\n-    if (l1 > l2)\n-        return(-1);\n+        (node2->type == XML_ELEMENT_NODE) &&\n+        (0 > (ptrdiff_t) node1->content) &&\n+        (0 > (ptrdiff_t) node2->content) &&\n+        (node1->doc == node2->doc)) {\n+\n+        l1 = -((ptrdiff_t) node1->content);\n+        l2 = -((ptrdiff_t) node2->content);\n+        if (l1 < l2)\n+            return(1);\n+        if (l1 > l2)\n+            return(-1);\n@@ -376,1 +376,1 @@\n-    return(1);\n+        return(1);\n@@ -378,1 +378,1 @@\n-    return(-1);\n+        return(-1);\n@@ -383,3 +383,3 @@\n-    if (cur->parent == node1)\n-        return(1);\n-    depth2++;\n+        if (cur->parent == node1)\n+            return(1);\n+        depth2++;\n@@ -389,3 +389,3 @@\n-    if (cur->parent == node2)\n-        return(-1);\n-    depth1++;\n+        if (cur->parent == node2)\n+            return(-1);\n+        depth1++;\n@@ -397,1 +397,1 @@\n-    return(-2);\n+        return(-2);\n@@ -403,2 +403,2 @@\n-    depth1--;\n-    node1 = node1->parent;\n+        depth1--;\n+        node1 = node1->parent;\n@@ -407,2 +407,2 @@\n-    depth2--;\n-    node2 = node2->parent;\n+        depth2--;\n+        node2 = node2->parent;\n@@ -411,5 +411,5 @@\n-    node1 = node1->parent;\n-    node2 = node2->parent;\n-    \/* should not happen but just in case ... *\/\n-    if ((node1 == NULL) || (node2 == NULL))\n-        return(-2);\n+        node1 = node1->parent;\n+        node2 = node2->parent;\n+        \/* should not happen but just in case ... *\/\n+        if ((node1 == NULL) || (node2 == NULL))\n+            return(-2);\n@@ -421,1 +421,1 @@\n-    return(1);\n+        return(1);\n@@ -423,1 +423,1 @@\n-    return(-1);\n+        return(-1);\n@@ -428,11 +428,11 @@\n-    (node2->type == XML_ELEMENT_NODE) &&\n-    (0 > (ptrdiff_t) node1->content) &&\n-    (0 > (ptrdiff_t) node2->content) &&\n-    (node1->doc == node2->doc)) {\n-\n-    l1 = -((ptrdiff_t) node1->content);\n-    l2 = -((ptrdiff_t) node2->content);\n-    if (l1 < l2)\n-        return(1);\n-    if (l1 > l2)\n-        return(-1);\n+        (node2->type == XML_ELEMENT_NODE) &&\n+        (0 > (ptrdiff_t) node1->content) &&\n+        (0 > (ptrdiff_t) node2->content) &&\n+        (node1->doc == node2->doc)) {\n+\n+        l1 = -((ptrdiff_t) node1->content);\n+        l2 = -((ptrdiff_t) node2->content);\n+        if (l1 < l2)\n+            return(1);\n+        if (l1 > l2)\n+            return(-1);\n@@ -442,2 +442,2 @@\n-    if (cur == node2)\n-        return(1);\n+        if (cur == node2)\n+            return(1);\n@@ -486,3 +486,3 @@\n- *                                  *\n- *          Floating point stuff                *\n- *                                  *\n+ *                                                                      *\n+ *                      Floating point stuff                            *\n+ *                                                                      *\n@@ -576,3 +576,3 @@\n- *                                  *\n- *          Error handling routines             *\n- *                                  *\n+ *                                                                      *\n+ *                      Error handling routines                         *\n+ *                                                                      *\n@@ -587,1 +587,1 @@\n-#define XP_ERRORNULL(X)                         \\\n+#define XP_ERRORNULL(X)                                                 \\\n@@ -621,1 +621,1 @@\n-    \"?? Unknown error ??\\n\" \/* Must be last in the list! *\/\n+    \"?? Unknown error ??\\n\"     \/* Must be last in the list! *\/\n@@ -624,1 +624,1 @@\n-           sizeof(xmlXPathErrorMessages[0])) - 1)\n+                   sizeof(xmlXPathErrorMessages[0])) - 1)\n@@ -646,1 +646,1 @@\n-           xmlStrdup(BAD_CAST \"Memory allocation failed\\n\");\n+               xmlStrdup(BAD_CAST \"Memory allocation failed\\n\");\n@@ -650,2 +650,2 @@\n-    if (ctxt->error != NULL)\n-        ctxt->error(ctxt->userData, &ctxt->lastError);\n+        if (ctxt->error != NULL)\n+            ctxt->error(ctxt->userData, &ctxt->lastError);\n@@ -679,1 +679,1 @@\n-    xmlXPathErrMemory(NULL, extra);\n+        xmlXPathErrMemory(NULL, extra);\n@@ -681,2 +681,2 @@\n-    ctxt->error = XPATH_MEMORY_ERROR;\n-    xmlXPathErrMemory(ctxt->context, extra);\n+        ctxt->error = XPATH_MEMORY_ERROR;\n+        xmlXPathErrMemory(ctxt->context, extra);\n@@ -697,1 +697,1 @@\n-    error = MAXERRNO;\n+        error = MAXERRNO;\n@@ -699,7 +699,7 @@\n-    __xmlRaiseError(NULL, NULL, NULL,\n-            NULL, NULL, XML_FROM_XPATH,\n-            error + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,\n-            XML_ERR_ERROR, NULL, 0,\n-            NULL, NULL, NULL, 0, 0,\n-            \"%s\", xmlXPathErrorMessages[error]);\n-    return;\n+        __xmlRaiseError(NULL, NULL, NULL,\n+                        NULL, NULL, XML_FROM_XPATH,\n+                        error + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,\n+                        XML_ERR_ERROR, NULL, 0,\n+                        NULL, NULL, NULL, 0, 0,\n+                        \"%s\", xmlXPathErrorMessages[error]);\n+        return;\n@@ -709,8 +709,8 @@\n-    __xmlRaiseError(NULL, NULL, NULL,\n-            NULL, NULL, XML_FROM_XPATH,\n-            error + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,\n-            XML_ERR_ERROR, NULL, 0,\n-            (const char *) ctxt->base, NULL, NULL,\n-            ctxt->cur - ctxt->base, 0,\n-            \"%s\", xmlXPathErrorMessages[error]);\n-    return;\n+        __xmlRaiseError(NULL, NULL, NULL,\n+                        NULL, NULL, XML_FROM_XPATH,\n+                        error + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,\n+                        XML_ERR_ERROR, NULL, 0,\n+                        (const char *) ctxt->base, NULL, NULL,\n+                        ctxt->cur - ctxt->base, 0,\n+                        \"%s\", xmlXPathErrorMessages[error]);\n+        return;\n@@ -730,2 +730,2 @@\n-    ctxt->context->error(ctxt->context->userData,\n-                         &ctxt->context->lastError);\n+        ctxt->context->error(ctxt->context->userData,\n+                             &ctxt->context->lastError);\n@@ -733,7 +733,7 @@\n-    __xmlRaiseError(NULL, NULL, NULL,\n-            NULL, ctxt->context->debugNode, XML_FROM_XPATH,\n-            error + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,\n-            XML_ERR_ERROR, NULL, 0,\n-            (const char *) ctxt->base, NULL, NULL,\n-            ctxt->cur - ctxt->base, 0,\n-            \"%s\", xmlXPathErrorMessages[error]);\n+        __xmlRaiseError(NULL, NULL, NULL,\n+                        NULL, ctxt->context->debugNode, XML_FROM_XPATH,\n+                        error + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,\n+                        XML_ERR_ERROR, NULL, 0,\n+                        (const char *) ctxt->base, NULL, NULL,\n+                        ctxt->cur - ctxt->base, 0,\n+                        \"%s\", xmlXPathErrorMessages[error]);\n@@ -786,3 +786,3 @@\n- *                                  *\n- *          Utilities                   *\n- *                                  *\n+ *                                                                      *\n+ *                      Utilities                                       *\n+ *                                                                      *\n@@ -809,2 +809,2 @@\n-               void *item,\n-               int initialSize)\n+                       void *item,\n+                       int initialSize)\n@@ -813,10 +813,10 @@\n-    if (initialSize <= 0)\n-        initialSize = 1;\n-    list->items = (void **) xmlMalloc(initialSize * sizeof(void *));\n-    if (list->items == NULL) {\n-        xmlXPathErrMemory(NULL,\n-        \"xmlPointerListCreate: allocating item\\n\");\n-        return(-1);\n-    }\n-    list->number = 0;\n-    list->size = initialSize;\n+        if (initialSize <= 0)\n+            initialSize = 1;\n+        list->items = (void **) xmlMalloc(initialSize * sizeof(void *));\n+        if (list->items == NULL) {\n+            xmlXPathErrMemory(NULL,\n+                \"xmlPointerListCreate: allocating item\\n\");\n+            return(-1);\n+        }\n+        list->number = 0;\n+        list->size = initialSize;\n@@ -825,2 +825,11 @@\n-        xmlXPathErrMemory(NULL,\n-        \"xmlPointerListAddSize: re-allocating item\\n\");\n+            xmlXPathErrMemory(NULL,\n+                \"xmlPointerListAddSize: re-allocating item\\n\");\n+            return(-1);\n+        }\n+        list->size *= 2;\n+        list->items = (void **) xmlRealloc(list->items,\n+            list->size * sizeof(void *));\n+        if (list->items == NULL) {\n+            xmlXPathErrMemory(NULL,\n+                \"xmlPointerListAddSize: re-allocating item\\n\");\n+            list->size = 0;\n@@ -829,9 +838,0 @@\n-    list->size *= 2;\n-    list->items = (void **) xmlRealloc(list->items,\n-        list->size * sizeof(void *));\n-    if (list->items == NULL) {\n-        xmlXPathErrMemory(NULL,\n-        \"xmlPointerListAddSize: re-allocating item\\n\");\n-        list->size = 0;\n-        return(-1);\n-    }\n@@ -857,3 +857,3 @@\n-    xmlXPathErrMemory(NULL,\n-        \"xmlPointerListCreate: allocating item\\n\");\n-    return (NULL);\n+        xmlXPathErrMemory(NULL,\n+            \"xmlPointerListCreate: allocating item\\n\");\n+        return (NULL);\n@@ -863,2 +863,2 @@\n-    xmlPointerListAddSize(ret, NULL, initialSize);\n-    ret->number = 0;\n+        xmlPointerListAddSize(ret, NULL, initialSize);\n+        ret->number = 0;\n@@ -879,1 +879,1 @@\n-    return;\n+        return;\n@@ -881,1 +881,1 @@\n-    xmlFree(list->items);\n+        xmlFree(list->items);\n@@ -886,3 +886,3 @@\n- *                                  *\n- *          Parser Types                    *\n- *                                  *\n+ *                                                                      *\n+ *                      Parser Types                                    *\n+ *                                                                      *\n@@ -954,3 +954,3 @@\n-    xmlXPathOp op;      \/* The identifier of the operation *\/\n-    int ch1;            \/* First child *\/\n-    int ch2;            \/* Second child *\/\n+    xmlXPathOp op;              \/* The identifier of the operation *\/\n+    int ch1;                    \/* First child *\/\n+    int ch2;                    \/* Second child *\/\n@@ -967,6 +967,6 @@\n-    int nbStep;         \/* Number of steps in this expression *\/\n-    int maxStep;        \/* Maximum number of steps allocated *\/\n-    xmlXPathStepOp *steps;  \/* ops for computation of this expression *\/\n-    int last;           \/* index of last step in expression *\/\n-    xmlChar *expr;      \/* the expression being computed *\/\n-    xmlDictPtr dict;        \/* the dictionary to use if any *\/\n+    int nbStep;                 \/* Number of steps in this expression *\/\n+    int maxStep;                \/* Maximum number of steps allocated *\/\n+    xmlXPathStepOp *steps;      \/* ops for computation of this expression *\/\n+    int last;                   \/* index of last step in expression *\/\n+    xmlChar *expr;              \/* the expression being computed *\/\n+    xmlDictPtr dict;            \/* the dictionary to use if any *\/\n@@ -983,3 +983,3 @@\n- *                                  *\n- *          Forward declarations                *\n- *                                  *\n+ *                                                                      *\n+ *                      Forward declarations                            *\n+ *                                                                      *\n@@ -996,2 +996,2 @@\n-                xmlXPathStepOpPtr op,\n-                int isPredicate);\n+                            xmlXPathStepOpPtr op,\n+                            int isPredicate);\n@@ -1002,3 +1002,3 @@\n- *                                  *\n- *          Parser Type functions               *\n- *                                  *\n+ *                                                                      *\n+ *                      Parser Type functions                           *\n+ *                                                                      *\n@@ -1021,1 +1021,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1027,1 +1027,1 @@\n-                                       sizeof(xmlXPathStepOp));\n+                                           sizeof(xmlXPathStepOp));\n@@ -1030,2 +1030,2 @@\n-    xmlFree(cur);\n-    return(NULL);\n+        xmlFree(cur);\n+        return(NULL);\n@@ -1056,7 +1056,10 @@\n-    for (i = 0; i < comp->nbStep; i++) {\n-        op = &comp->steps[i];\n-        if (op->value4 != NULL) {\n-        if (op->op == XPATH_OP_VALUE)\n-            xmlXPathFreeObject(op->value4);\n-        else\n-            xmlFree(op->value4);\n+        for (i = 0; i < comp->nbStep; i++) {\n+            op = &comp->steps[i];\n+            if (op->value4 != NULL) {\n+                if (op->op == XPATH_OP_VALUE)\n+                    xmlXPathFreeObject(op->value4);\n+                else\n+                    xmlFree(op->value4);\n+            }\n+            if (op->value5 != NULL)\n+                xmlFree(op->value5);\n@@ -1064,3 +1067,0 @@\n-        if (op->value5 != NULL)\n-        xmlFree(op->value5);\n-    }\n@@ -1068,5 +1068,6 @@\n-    for (i = 0; i < comp->nbStep; i++) {\n-        op = &comp->steps[i];\n-        if (op->value4 != NULL) {\n-        if (op->op == XPATH_OP_VALUE)\n-            xmlXPathFreeObject(op->value4);\n+        for (i = 0; i < comp->nbStep; i++) {\n+            op = &comp->steps[i];\n+            if (op->value4 != NULL) {\n+                if (op->op == XPATH_OP_VALUE)\n+                    xmlXPathFreeObject(op->value4);\n+            }\n@@ -1074,1 +1075,0 @@\n-    }\n@@ -1119,1 +1119,1 @@\n-    xmlXPathStepOp *real;\n+        xmlXPathStepOp *real;\n@@ -1122,2 +1122,2 @@\n-        xmlXPathPErrMemory(ctxt, \"adding step\\n\");\n-        return(-1);\n+            xmlXPathPErrMemory(ctxt, \"adding step\\n\");\n+            return(-1);\n@@ -1125,9 +1125,9 @@\n-    comp->maxStep *= 2;\n-    real = (xmlXPathStepOp *) xmlRealloc(comp->steps,\n-                              comp->maxStep * sizeof(xmlXPathStepOp));\n-    if (real == NULL) {\n-        comp->maxStep \/= 2;\n-        xmlXPathPErrMemory(ctxt, \"adding step\\n\");\n-        return(-1);\n-    }\n-    comp->steps = real;\n+        comp->maxStep *= 2;\n+        real = (xmlXPathStepOp *) xmlRealloc(comp->steps,\n+                                      comp->maxStep * sizeof(xmlXPathStepOp));\n+        if (real == NULL) {\n+            comp->maxStep \/= 2;\n+            xmlXPathPErrMemory(ctxt, \"adding step\\n\");\n+            return(-1);\n+        }\n+        comp->steps = real;\n@@ -1144,1 +1144,1 @@\n-     (op == XPATH_OP_COLLECT))) {\n+         (op == XPATH_OP_COLLECT))) {\n@@ -1146,5 +1146,5 @@\n-        comp->steps[comp->nbStep].value4 = (xmlChar *)\n-            (void *)xmlDictLookup(comp->dict, value4, -1);\n-        xmlFree(value4);\n-    } else\n-        comp->steps[comp->nbStep].value4 = NULL;\n+            comp->steps[comp->nbStep].value4 = (xmlChar *)\n+                (void *)xmlDictLookup(comp->dict, value4, -1);\n+            xmlFree(value4);\n+        } else\n+            comp->steps[comp->nbStep].value4 = NULL;\n@@ -1152,5 +1152,5 @@\n-        comp->steps[comp->nbStep].value5 = (xmlChar *)\n-            (void *)xmlDictLookup(comp->dict, value5, -1);\n-        xmlFree(value5);\n-    } else\n-        comp->steps[comp->nbStep].value5 = NULL;\n+            comp->steps[comp->nbStep].value5 = (xmlChar *)\n+                (void *)xmlDictLookup(comp->dict, value5, -1);\n+            xmlFree(value5);\n+        } else\n+            comp->steps[comp->nbStep].value5 = NULL;\n@@ -1158,2 +1158,2 @@\n-    comp->steps[comp->nbStep].value4 = value4;\n-    comp->steps[comp->nbStep].value5 = value5;\n+        comp->steps[comp->nbStep].value4 = value4;\n+        comp->steps[comp->nbStep].value5 = value5;\n@@ -1183,1 +1183,1 @@\n-    return;\n+        return;\n@@ -1191,6 +1191,6 @@\n-#define PUSH_FULL_EXPR(op, op1, op2, val, val2, val3, val4, val5)   \\\n-    xmlXPathCompExprAdd(ctxt, (op1), (op2),         \\\n-                    (op), (val), (val2), (val3), (val4), (val5))\n-#define PUSH_LONG_EXPR(op, val, val2, val3, val4, val5)         \\\n-    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,     \\\n-                    (op), (val), (val2), (val3), (val4), (val5))\n+#define PUSH_FULL_EXPR(op, op1, op2, val, val2, val3, val4, val5)       \\\n+    xmlXPathCompExprAdd(ctxt, (op1), (op2),                     \\\n+                        (op), (val), (val2), (val3), (val4), (val5))\n+#define PUSH_LONG_EXPR(op, val, val2, val3, val4, val5)                 \\\n+    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,             \\\n+                        (op), (val), (val2), (val3), (val4), (val5))\n@@ -1198,1 +1198,1 @@\n-#define PUSH_LEAVE_EXPR(op, val, val2)                  \\\n+#define PUSH_LEAVE_EXPR(op, val, val2)                                  \\\n@@ -1201,1 +1201,1 @@\n-#define PUSH_UNARY_EXPR(op, ch, val, val2)              \\\n+#define PUSH_UNARY_EXPR(op, ch, val, val2)                              \\\n@@ -1204,3 +1204,3 @@\n-#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)           \\\n-xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),           \\\n-            (val), (val2), 0 ,NULL ,NULL)\n+#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)                       \\\n+xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),                   \\\n+                        (val), (val2), 0 ,NULL ,NULL)\n@@ -1209,3 +1209,3 @@\n- *                                  *\n- *      XPath object cache structures               *\n- *                                  *\n+ *                                                                      *\n+ *              XPath object cache structures                           *\n+ *                                                                      *\n@@ -1261,3 +1261,3 @@\n- *                                  *\n- *      Debugging related functions             *\n- *                                  *\n+ *                                                                      *\n+ *              Debugging related functions                             *\n+ *                                                                      *\n@@ -1266,3 +1266,3 @@\n-#define STRANGE                         \\\n-    xmlGenericError(xmlGenericErrorContext,             \\\n-        \"Internal error at %s:%d\\n\",                \\\n+#define STRANGE                                                 \\\n+    xmlGenericError(xmlGenericErrorContext,                             \\\n+            \"Internal error at %s:%d\\n\",                                \\\n@@ -1281,3 +1281,3 @@\n-    fprintf(output, \"%s\", shift);\n-    fprintf(output, \"Node is NULL !\\n\");\n-    return;\n+        fprintf(output, \"%s\", shift);\n+        fprintf(output, \"Node is NULL !\\n\");\n+        return;\n@@ -1288,3 +1288,3 @@\n-         (cur->type == XML_HTML_DOCUMENT_NODE)) {\n-    fprintf(output, \"%s\", shift);\n-    fprintf(output, \" \/\\n\");\n+             (cur->type == XML_HTML_DOCUMENT_NODE)) {\n+        fprintf(output, \"%s\", shift);\n+        fprintf(output, \" \/\\n\");\n@@ -1292,1 +1292,1 @@\n-    xmlDebugDumpAttr(output, (xmlAttrPtr)cur, depth);\n+        xmlDebugDumpAttr(output, (xmlAttrPtr)cur, depth);\n@@ -1294,1 +1294,1 @@\n-    xmlDebugDumpOneNode(output, cur, depth);\n+        xmlDebugDumpOneNode(output, cur, depth);\n@@ -1306,3 +1306,3 @@\n-    fprintf(output, \"%s\", shift);\n-    fprintf(output, \"Node is NULL !\\n\");\n-    return;\n+        fprintf(output, \"%s\", shift);\n+        fprintf(output, \"Node is NULL !\\n\");\n+        return;\n@@ -1313,3 +1313,3 @@\n-    tmp = cur;\n-    cur = cur->next;\n-    xmlDebugDumpOneNode(output, tmp, depth);\n+        tmp = cur;\n+        cur = cur->next;\n+        xmlDebugDumpOneNode(output, tmp, depth);\n@@ -1329,3 +1329,3 @@\n-    fprintf(output, \"%s\", shift);\n-    fprintf(output, \"NodeSet is NULL !\\n\");\n-    return;\n+        fprintf(output, \"%s\", shift);\n+        fprintf(output, \"NodeSet is NULL !\\n\");\n+        return;\n@@ -1336,6 +1336,6 @@\n-    fprintf(output, \"Set contains %d nodes:\\n\", cur->nodeNr);\n-    for (i = 0;i < cur->nodeNr;i++) {\n-        fprintf(output, \"%s\", shift);\n-        fprintf(output, \"%d\", i + 1);\n-        xmlXPathDebugDumpNode(output, cur->nodeTab[i], depth + 1);\n-    }\n+        fprintf(output, \"Set contains %d nodes:\\n\", cur->nodeNr);\n+        for (i = 0;i < cur->nodeNr;i++) {\n+            fprintf(output, \"%s\", shift);\n+            fprintf(output, \"%d\", i + 1);\n+            xmlXPathDebugDumpNode(output, cur->nodeTab[i], depth + 1);\n+        }\n@@ -1355,3 +1355,3 @@\n-    fprintf(output, \"%s\", shift);\n-    fprintf(output, \"Value Tree is NULL !\\n\");\n-    return;\n+        fprintf(output, \"%s\", shift);\n+        fprintf(output, \"Value Tree is NULL !\\n\");\n+        return;\n@@ -1376,3 +1376,3 @@\n-    fprintf(output, \"%s\", shift);\n-    fprintf(output, \"LocationSet is NULL !\\n\");\n-    return;\n+        fprintf(output, \"%s\", shift);\n+        fprintf(output, \"LocationSet is NULL !\\n\");\n+        return;\n@@ -1383,1 +1383,1 @@\n-    fprintf(output, \"%s\", shift);\n+        fprintf(output, \"%s\", shift);\n@@ -1385,1 +1385,1 @@\n-    xmlXPathDebugDumpObject(output, cur->locTab[i], depth + 1);\n+        xmlXPathDebugDumpObject(output, cur->locTab[i], depth + 1);\n@@ -1414,1 +1414,1 @@\n-    return;\n+        return;\n@@ -1418,2 +1418,2 @@\n-        fprintf(output, \"Object is uninitialized\\n\");\n-        break;\n+            fprintf(output, \"Object is uninitialized\\n\");\n+            break;\n@@ -1421,7 +1421,7 @@\n-        fprintf(output, \"Object is a Node Set :\\n\");\n-        xmlXPathDebugDumpNodeSet(output, cur->nodesetval, depth);\n-        break;\n-    case XPATH_XSLT_TREE:\n-        fprintf(output, \"Object is an XSLT value tree :\\n\");\n-        xmlXPathDebugDumpValueTree(output, cur->nodesetval, depth);\n-        break;\n+            fprintf(output, \"Object is a Node Set :\\n\");\n+            xmlXPathDebugDumpNodeSet(output, cur->nodesetval, depth);\n+            break;\n+        case XPATH_XSLT_TREE:\n+            fprintf(output, \"Object is an XSLT value tree :\\n\");\n+            xmlXPathDebugDumpValueTree(output, cur->nodesetval, depth);\n+            break;\n@@ -1429,4 +1429,4 @@\n-        fprintf(output, \"Object is a Boolean : \");\n-        if (cur->boolval) fprintf(output, \"true\\n\");\n-        else fprintf(output, \"false\\n\");\n-        break;\n+            fprintf(output, \"Object is a Boolean : \");\n+            if (cur->boolval) fprintf(output, \"true\\n\");\n+            else fprintf(output, \"false\\n\");\n+            break;\n@@ -1434,11 +1434,11 @@\n-        switch (xmlXPathIsInf(cur->floatval)) {\n-        case 1:\n-        fprintf(output, \"Object is a number : Infinity\\n\");\n-        break;\n-        case -1:\n-        fprintf(output, \"Object is a number : -Infinity\\n\");\n-        break;\n-        default:\n-        if (xmlXPathIsNaN(cur->floatval)) {\n-            fprintf(output, \"Object is a number : NaN\\n\");\n-        } else if (cur->floatval == 0) {\n+            switch (xmlXPathIsInf(cur->floatval)) {\n+            case 1:\n+                fprintf(output, \"Object is a number : Infinity\\n\");\n+                break;\n+            case -1:\n+                fprintf(output, \"Object is a number : -Infinity\\n\");\n+                break;\n+            default:\n+                if (xmlXPathIsNaN(cur->floatval)) {\n+                    fprintf(output, \"Object is a number : NaN\\n\");\n+                } else if (cur->floatval == 0) {\n@@ -1446,6 +1446,6 @@\n-            fprintf(output, \"Object is a number : 0\\n\");\n-        } else {\n-            fprintf(output, \"Object is a number : %0g\\n\", cur->floatval);\n-        }\n-        }\n-        break;\n+                    fprintf(output, \"Object is a number : 0\\n\");\n+                } else {\n+                    fprintf(output, \"Object is a number : %0g\\n\", cur->floatval);\n+                }\n+            }\n+            break;\n@@ -1453,49 +1453,49 @@\n-        fprintf(output, \"Object is a string : \");\n-        xmlDebugDumpString(output, cur->stringval);\n-        fprintf(output, \"\\n\");\n-        break;\n-    case XPATH_POINT:\n-        fprintf(output, \"Object is a point : index %d in node\", cur->index);\n-        xmlXPathDebugDumpNode(output, (xmlNodePtr) cur->user, depth + 1);\n-        fprintf(output, \"\\n\");\n-        break;\n-    case XPATH_RANGE:\n-        if ((cur->user2 == NULL) ||\n-        ((cur->user2 == cur->user) && (cur->index == cur->index2))) {\n-        fprintf(output, \"Object is a collapsed range :\\n\");\n-        fprintf(output, \"%s\", shift);\n-        if (cur->index >= 0)\n-            fprintf(output, \"index %d in \", cur->index);\n-        fprintf(output, \"node\\n\");\n-        xmlXPathDebugDumpNode(output, (xmlNodePtr) cur->user,\n-                          depth + 1);\n-        } else  {\n-        fprintf(output, \"Object is a range :\\n\");\n-        fprintf(output, \"%s\", shift);\n-        fprintf(output, \"From \");\n-        if (cur->index >= 0)\n-            fprintf(output, \"index %d in \", cur->index);\n-        fprintf(output, \"node\\n\");\n-        xmlXPathDebugDumpNode(output, (xmlNodePtr) cur->user,\n-                          depth + 1);\n-        fprintf(output, \"%s\", shift);\n-        fprintf(output, \"To \");\n-        if (cur->index2 >= 0)\n-            fprintf(output, \"index %d in \", cur->index2);\n-        fprintf(output, \"node\\n\");\n-        xmlXPathDebugDumpNode(output, (xmlNodePtr) cur->user2,\n-                          depth + 1);\n-        fprintf(output, \"\\n\");\n-        }\n-        break;\n-    case XPATH_LOCATIONSET:\n-#if defined(LIBXML_XPTR_ENABLED)\n-        fprintf(output, \"Object is a Location Set:\\n\");\n-        xmlXPathDebugDumpLocationSet(output,\n-            (xmlLocationSetPtr) cur->user, depth);\n-#endif\n-        break;\n-    case XPATH_USERS:\n-        fprintf(output, \"Object is user defined\\n\");\n-        break;\n-    }\n+            fprintf(output, \"Object is a string : \");\n+            xmlDebugDumpString(output, cur->stringval);\n+            fprintf(output, \"\\n\");\n+            break;\n+        case XPATH_POINT:\n+            fprintf(output, \"Object is a point : index %d in node\", cur->index);\n+            xmlXPathDebugDumpNode(output, (xmlNodePtr) cur->user, depth + 1);\n+            fprintf(output, \"\\n\");\n+            break;\n+        case XPATH_RANGE:\n+            if ((cur->user2 == NULL) ||\n+                ((cur->user2 == cur->user) && (cur->index == cur->index2))) {\n+                fprintf(output, \"Object is a collapsed range :\\n\");\n+                fprintf(output, \"%s\", shift);\n+                if (cur->index >= 0)\n+                    fprintf(output, \"index %d in \", cur->index);\n+                fprintf(output, \"node\\n\");\n+                xmlXPathDebugDumpNode(output, (xmlNodePtr) cur->user,\n+                                      depth + 1);\n+            } else  {\n+                fprintf(output, \"Object is a range :\\n\");\n+                fprintf(output, \"%s\", shift);\n+                fprintf(output, \"From \");\n+                if (cur->index >= 0)\n+                    fprintf(output, \"index %d in \", cur->index);\n+                fprintf(output, \"node\\n\");\n+                xmlXPathDebugDumpNode(output, (xmlNodePtr) cur->user,\n+                                      depth + 1);\n+                fprintf(output, \"%s\", shift);\n+                fprintf(output, \"To \");\n+                if (cur->index2 >= 0)\n+                    fprintf(output, \"index %d in \", cur->index2);\n+                fprintf(output, \"node\\n\");\n+                xmlXPathDebugDumpNode(output, (xmlNodePtr) cur->user2,\n+                                      depth + 1);\n+                fprintf(output, \"\\n\");\n+            }\n+            break;\n+        case XPATH_LOCATIONSET:\n+#if defined(LIBXML_XPTR_ENABLED)\n+            fprintf(output, \"Object is a Location Set:\\n\");\n+            xmlXPathDebugDumpLocationSet(output,\n+                    (xmlLocationSetPtr) cur->user, depth);\n+#endif\n+            break;\n+        case XPATH_USERS:\n+            fprintf(output, \"Object is user defined\\n\");\n+            break;\n+    }\n@@ -1506,1 +1506,1 @@\n-                         xmlXPathStepOpPtr op, int depth) {\n+                             xmlXPathStepOpPtr op, int depth) {\n@@ -1516,2 +1516,2 @@\n-    fprintf(output, \"Step is NULL\\n\");\n-    return;\n+        fprintf(output, \"Step is NULL\\n\");\n+        return;\n@@ -1521,1 +1521,1 @@\n-        fprintf(output, \"END\"); break;\n+            fprintf(output, \"END\"); break;\n@@ -1523,1 +1523,1 @@\n-        fprintf(output, \"AND\"); break;\n+            fprintf(output, \"AND\"); break;\n@@ -1525,1 +1525,1 @@\n-        fprintf(output, \"OR\"); break;\n+            fprintf(output, \"OR\"); break;\n@@ -1527,5 +1527,5 @@\n-         if (op->value)\n-         fprintf(output, \"EQUAL =\");\n-         else\n-         fprintf(output, \"EQUAL !=\");\n-         break;\n+             if (op->value)\n+                 fprintf(output, \"EQUAL =\");\n+             else\n+                 fprintf(output, \"EQUAL !=\");\n+             break;\n@@ -1533,7 +1533,7 @@\n-         if (op->value)\n-         fprintf(output, \"CMP <\");\n-         else\n-         fprintf(output, \"CMP >\");\n-         if (!op->value2)\n-         fprintf(output, \"=\");\n-         break;\n+             if (op->value)\n+                 fprintf(output, \"CMP <\");\n+             else\n+                 fprintf(output, \"CMP >\");\n+             if (!op->value2)\n+                 fprintf(output, \"=\");\n+             break;\n@@ -1541,9 +1541,9 @@\n-         if (op->value == 0)\n-         fprintf(output, \"PLUS -\");\n-         else if (op->value == 1)\n-         fprintf(output, \"PLUS +\");\n-         else if (op->value == 2)\n-         fprintf(output, \"PLUS unary -\");\n-         else if (op->value == 3)\n-         fprintf(output, \"PLUS unary - -\");\n-         break;\n+             if (op->value == 0)\n+                 fprintf(output, \"PLUS -\");\n+             else if (op->value == 1)\n+                 fprintf(output, \"PLUS +\");\n+             else if (op->value == 2)\n+                 fprintf(output, \"PLUS unary -\");\n+             else if (op->value == 3)\n+                 fprintf(output, \"PLUS unary - -\");\n+             break;\n@@ -1551,7 +1551,7 @@\n-         if (op->value == 0)\n-         fprintf(output, \"MULT *\");\n-         else if (op->value == 1)\n-         fprintf(output, \"MULT div\");\n-         else\n-         fprintf(output, \"MULT mod\");\n-         break;\n+             if (op->value == 0)\n+                 fprintf(output, \"MULT *\");\n+             else if (op->value == 1)\n+                 fprintf(output, \"MULT div\");\n+             else\n+                 fprintf(output, \"MULT mod\");\n+             break;\n@@ -1559,1 +1559,1 @@\n-         fprintf(output, \"UNION\"); break;\n+             fprintf(output, \"UNION\"); break;\n@@ -1561,1 +1561,1 @@\n-         fprintf(output, \"ROOT\"); break;\n+             fprintf(output, \"ROOT\"); break;\n@@ -1563,1 +1563,1 @@\n-         fprintf(output, \"NODE\"); break;\n+             fprintf(output, \"NODE\"); break;\n@@ -1565,1 +1565,1 @@\n-         fprintf(output, \"SORT\"); break;\n+             fprintf(output, \"SORT\"); break;\n@@ -1567,36 +1567,36 @@\n-        xmlXPathAxisVal axis = (xmlXPathAxisVal)op->value;\n-        xmlXPathTestVal test = (xmlXPathTestVal)op->value2;\n-        xmlXPathTypeVal type = (xmlXPathTypeVal)op->value3;\n-        const xmlChar *prefix = op->value4;\n-        const xmlChar *name = op->value5;\n-\n-        fprintf(output, \"COLLECT \");\n-        switch (axis) {\n-        case AXIS_ANCESTOR:\n-            fprintf(output, \" 'ancestors' \"); break;\n-        case AXIS_ANCESTOR_OR_SELF:\n-            fprintf(output, \" 'ancestors-or-self' \"); break;\n-        case AXIS_ATTRIBUTE:\n-            fprintf(output, \" 'attributes' \"); break;\n-        case AXIS_CHILD:\n-            fprintf(output, \" 'child' \"); break;\n-        case AXIS_DESCENDANT:\n-            fprintf(output, \" 'descendant' \"); break;\n-        case AXIS_DESCENDANT_OR_SELF:\n-            fprintf(output, \" 'descendant-or-self' \"); break;\n-        case AXIS_FOLLOWING:\n-            fprintf(output, \" 'following' \"); break;\n-        case AXIS_FOLLOWING_SIBLING:\n-            fprintf(output, \" 'following-siblings' \"); break;\n-        case AXIS_NAMESPACE:\n-            fprintf(output, \" 'namespace' \"); break;\n-        case AXIS_PARENT:\n-            fprintf(output, \" 'parent' \"); break;\n-        case AXIS_PRECEDING:\n-            fprintf(output, \" 'preceding' \"); break;\n-        case AXIS_PRECEDING_SIBLING:\n-            fprintf(output, \" 'preceding-sibling' \"); break;\n-        case AXIS_SELF:\n-            fprintf(output, \" 'self' \"); break;\n-        }\n-        switch (test) {\n+            xmlXPathAxisVal axis = (xmlXPathAxisVal)op->value;\n+            xmlXPathTestVal test = (xmlXPathTestVal)op->value2;\n+            xmlXPathTypeVal type = (xmlXPathTypeVal)op->value3;\n+            const xmlChar *prefix = op->value4;\n+            const xmlChar *name = op->value5;\n+\n+            fprintf(output, \"COLLECT \");\n+            switch (axis) {\n+                case AXIS_ANCESTOR:\n+                    fprintf(output, \" 'ancestors' \"); break;\n+                case AXIS_ANCESTOR_OR_SELF:\n+                    fprintf(output, \" 'ancestors-or-self' \"); break;\n+                case AXIS_ATTRIBUTE:\n+                    fprintf(output, \" 'attributes' \"); break;\n+                case AXIS_CHILD:\n+                    fprintf(output, \" 'child' \"); break;\n+                case AXIS_DESCENDANT:\n+                    fprintf(output, \" 'descendant' \"); break;\n+                case AXIS_DESCENDANT_OR_SELF:\n+                    fprintf(output, \" 'descendant-or-self' \"); break;\n+                case AXIS_FOLLOWING:\n+                    fprintf(output, \" 'following' \"); break;\n+                case AXIS_FOLLOWING_SIBLING:\n+                    fprintf(output, \" 'following-siblings' \"); break;\n+                case AXIS_NAMESPACE:\n+                    fprintf(output, \" 'namespace' \"); break;\n+                case AXIS_PARENT:\n+                    fprintf(output, \" 'parent' \"); break;\n+                case AXIS_PRECEDING:\n+                    fprintf(output, \" 'preceding' \"); break;\n+                case AXIS_PRECEDING_SIBLING:\n+                    fprintf(output, \" 'preceding-sibling' \"); break;\n+                case AXIS_SELF:\n+                    fprintf(output, \" 'self' \"); break;\n+            }\n+            switch (test) {\n@@ -1604,1 +1604,1 @@\n-            fprintf(output, \"'none' \"); break;\n+                    fprintf(output, \"'none' \"); break;\n@@ -1606,1 +1606,1 @@\n-            fprintf(output, \"'type' \"); break;\n+                    fprintf(output, \"'type' \"); break;\n@@ -1608,1 +1608,1 @@\n-            fprintf(output, \"'PI' \"); break;\n+                    fprintf(output, \"'PI' \"); break;\n@@ -1610,1 +1610,1 @@\n-            fprintf(output, \"'all' \"); break;\n+                    fprintf(output, \"'all' \"); break;\n@@ -1612,1 +1612,1 @@\n-            fprintf(output, \"'namespace' \"); break;\n+                    fprintf(output, \"'namespace' \"); break;\n@@ -1614,3 +1614,3 @@\n-            fprintf(output, \"'name' \"); break;\n-        }\n-        switch (type) {\n+                    fprintf(output, \"'name' \"); break;\n+            }\n+            switch (type) {\n@@ -1618,1 +1618,1 @@\n-            fprintf(output, \"'node' \"); break;\n+                    fprintf(output, \"'node' \"); break;\n@@ -1620,1 +1620,1 @@\n-            fprintf(output, \"'comment' \"); break;\n+                    fprintf(output, \"'comment' \"); break;\n@@ -1622,1 +1622,1 @@\n-            fprintf(output, \"'text' \"); break;\n+                    fprintf(output, \"'text' \"); break;\n@@ -1624,7 +1624,7 @@\n-            fprintf(output, \"'PI' \"); break;\n-        }\n-        if (prefix != NULL)\n-        fprintf(output, \"%s:\", prefix);\n-        if (name != NULL)\n-        fprintf(output, \"%s\", (const char *) name);\n-        break;\n+                    fprintf(output, \"'PI' \"); break;\n+            }\n+            if (prefix != NULL)\n+                fprintf(output, \"%s:\", prefix);\n+            if (name != NULL)\n+                fprintf(output, \"%s\", (const char *) name);\n+            break;\n@@ -1633,2 +1633,2 @@\n-    case XPATH_OP_VALUE: {\n-        xmlXPathObjectPtr object = (xmlXPathObjectPtr) op->value4;\n+        case XPATH_OP_VALUE: {\n+            xmlXPathObjectPtr object = (xmlXPathObjectPtr) op->value4;\n@@ -1636,7 +1636,7 @@\n-        fprintf(output, \"ELEM \");\n-        xmlXPathDebugDumpObject(output, object, 0);\n-        goto finish;\n-    }\n-    case XPATH_OP_VARIABLE: {\n-        const xmlChar *prefix = op->value5;\n-        const xmlChar *name = op->value4;\n+            fprintf(output, \"ELEM \");\n+            xmlXPathDebugDumpObject(output, object, 0);\n+            goto finish;\n+        }\n+        case XPATH_OP_VARIABLE: {\n+            const xmlChar *prefix = op->value5;\n+            const xmlChar *name = op->value4;\n@@ -1644,10 +1644,10 @@\n-        if (prefix != NULL)\n-        fprintf(output, \"VARIABLE %s:%s\", prefix, name);\n-        else\n-        fprintf(output, \"VARIABLE %s\", name);\n-        break;\n-    }\n-    case XPATH_OP_FUNCTION: {\n-        int nbargs = op->value;\n-        const xmlChar *prefix = op->value5;\n-        const xmlChar *name = op->value4;\n+            if (prefix != NULL)\n+                fprintf(output, \"VARIABLE %s:%s\", prefix, name);\n+            else\n+                fprintf(output, \"VARIABLE %s\", name);\n+            break;\n+        }\n+        case XPATH_OP_FUNCTION: {\n+            int nbargs = op->value;\n+            const xmlChar *prefix = op->value5;\n+            const xmlChar *name = op->value4;\n@@ -1655,7 +1655,7 @@\n-        if (prefix != NULL)\n-        fprintf(output, \"FUNCTION %s:%s(%d args)\",\n-            prefix, name, nbargs);\n-        else\n-        fprintf(output, \"FUNCTION %s(%d args)\", name, nbargs);\n-        break;\n-    }\n+            if (prefix != NULL)\n+                fprintf(output, \"FUNCTION %s:%s(%d args)\",\n+                        prefix, name, nbargs);\n+            else\n+                fprintf(output, \"FUNCTION %s(%d args)\", name, nbargs);\n+            break;\n+        }\n@@ -1668,1 +1668,1 @@\n-    default:\n+        default:\n@@ -1674,1 +1674,1 @@\n-    xmlXPathDebugDumpStepOp(output, comp, &comp->steps[op->ch1], depth + 1);\n+        xmlXPathDebugDumpStepOp(output, comp, &comp->steps[op->ch1], depth + 1);\n@@ -1676,1 +1676,1 @@\n-    xmlXPathDebugDumpStepOp(output, comp, &comp->steps[op->ch2], depth + 1);\n+        xmlXPathDebugDumpStepOp(output, comp, &comp->steps[op->ch2], depth + 1);\n@@ -1689,1 +1689,1 @@\n-                      int depth) {\n+                          int depth) {\n@@ -1759,28 +1759,28 @@\n-    if (ctxt->cache != NULL) {\n-        xmlXPathContextCachePtr cache =\n-        (xmlXPathContextCachePtr) ctxt->cache;\n-\n-        cache->dbgCachedAll = 0;\n-        cache->dbgCachedNodeset = 0;\n-        cache->dbgCachedString = 0;\n-        cache->dbgCachedBool = 0;\n-        cache->dbgCachedNumber = 0;\n-        cache->dbgCachedPoint = 0;\n-        cache->dbgCachedRange = 0;\n-        cache->dbgCachedLocset = 0;\n-        cache->dbgCachedUsers = 0;\n-        cache->dbgCachedXSLTTree = 0;\n-        cache->dbgCachedUndefined = 0;\n-\n-        cache->dbgReusedAll = 0;\n-        cache->dbgReusedNodeset = 0;\n-        cache->dbgReusedString = 0;\n-        cache->dbgReusedBool = 0;\n-        cache->dbgReusedNumber = 0;\n-        cache->dbgReusedPoint = 0;\n-        cache->dbgReusedRange = 0;\n-        cache->dbgReusedLocset = 0;\n-        cache->dbgReusedUsers = 0;\n-        cache->dbgReusedXSLTTree = 0;\n-        cache->dbgReusedUndefined = 0;\n-    }\n+        if (ctxt->cache != NULL) {\n+            xmlXPathContextCachePtr cache =\n+                (xmlXPathContextCachePtr) ctxt->cache;\n+\n+            cache->dbgCachedAll = 0;\n+            cache->dbgCachedNodeset = 0;\n+            cache->dbgCachedString = 0;\n+            cache->dbgCachedBool = 0;\n+            cache->dbgCachedNumber = 0;\n+            cache->dbgCachedPoint = 0;\n+            cache->dbgCachedRange = 0;\n+            cache->dbgCachedLocset = 0;\n+            cache->dbgCachedUsers = 0;\n+            cache->dbgCachedXSLTTree = 0;\n+            cache->dbgCachedUndefined = 0;\n+\n+            cache->dbgReusedAll = 0;\n+            cache->dbgReusedNodeset = 0;\n+            cache->dbgReusedString = 0;\n+            cache->dbgReusedBool = 0;\n+            cache->dbgReusedNumber = 0;\n+            cache->dbgReusedPoint = 0;\n+            cache->dbgReusedRange = 0;\n+            cache->dbgReusedLocset = 0;\n+            cache->dbgReusedUsers = 0;\n+            cache->dbgReusedXSLTTree = 0;\n+            cache->dbgReusedUndefined = 0;\n+        }\n@@ -1829,1 +1829,1 @@\n-                  xmlXPathObjectType objType)\n+                              xmlXPathObjectType objType)\n@@ -1834,3 +1834,5 @@\n-    if (ctxt->cache != NULL) {\n-        xmlXPathContextCachePtr cache =\n-        (xmlXPathContextCachePtr) ctxt->cache;\n+        if (ctxt->cache != NULL) {\n+            xmlXPathContextCachePtr cache =\n+                (xmlXPathContextCachePtr) ctxt->cache;\n+\n+            isCached = 1;\n@@ -1838,1 +1840,37 @@\n-        isCached = 1;\n+            cache->dbgReusedAll++;\n+            switch (objType) {\n+                case XPATH_UNDEFINED:\n+                    cache->dbgReusedUndefined++;\n+                    break;\n+                case XPATH_NODESET:\n+                    cache->dbgReusedNodeset++;\n+                    break;\n+                case XPATH_BOOLEAN:\n+                    cache->dbgReusedBool++;\n+                    break;\n+                case XPATH_NUMBER:\n+                    cache->dbgReusedNumber++;\n+                    break;\n+                case XPATH_STRING:\n+                    cache->dbgReusedString++;\n+                    break;\n+                case XPATH_POINT:\n+                    cache->dbgReusedPoint++;\n+                    break;\n+                case XPATH_RANGE:\n+                    cache->dbgReusedRange++;\n+                    break;\n+                case XPATH_LOCATIONSET:\n+                    cache->dbgReusedLocset++;\n+                    break;\n+                case XPATH_USERS:\n+                    cache->dbgReusedUsers++;\n+                    break;\n+                case XPATH_XSLT_TREE:\n+                    cache->dbgReusedXSLTTree++;\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+    }\n@@ -1840,2 +1878,1 @@\n-        cache->dbgReusedAll++;\n-        switch (objType) {\n+    switch (objType) {\n@@ -1843,1 +1880,7 @@\n-            cache->dbgReusedUndefined++;\n+            if (! isCached)\n+                xmlXPathDebugObjTotalUndefined++;\n+            xmlXPathDebugObjCounterUndefined++;\n+            if (xmlXPathDebugObjCounterUndefined >\n+                xmlXPathDebugObjMaxUndefined)\n+                xmlXPathDebugObjMaxUndefined =\n+                    xmlXPathDebugObjCounterUndefined;\n@@ -1846,1 +1889,7 @@\n-            cache->dbgReusedNodeset++;\n+            if (! isCached)\n+                xmlXPathDebugObjTotalNodeset++;\n+            xmlXPathDebugObjCounterNodeset++;\n+            if (xmlXPathDebugObjCounterNodeset >\n+                xmlXPathDebugObjMaxNodeset)\n+                xmlXPathDebugObjMaxNodeset =\n+                    xmlXPathDebugObjCounterNodeset;\n@@ -1849,1 +1898,7 @@\n-            cache->dbgReusedBool++;\n+            if (! isCached)\n+                xmlXPathDebugObjTotalBool++;\n+            xmlXPathDebugObjCounterBool++;\n+            if (xmlXPathDebugObjCounterBool >\n+                xmlXPathDebugObjMaxBool)\n+                xmlXPathDebugObjMaxBool =\n+                    xmlXPathDebugObjCounterBool;\n@@ -1852,1 +1907,7 @@\n-            cache->dbgReusedNumber++;\n+            if (! isCached)\n+                xmlXPathDebugObjTotalNumber++;\n+            xmlXPathDebugObjCounterNumber++;\n+            if (xmlXPathDebugObjCounterNumber >\n+                xmlXPathDebugObjMaxNumber)\n+                xmlXPathDebugObjMaxNumber =\n+                    xmlXPathDebugObjCounterNumber;\n@@ -1855,1 +1916,7 @@\n-            cache->dbgReusedString++;\n+            if (! isCached)\n+                xmlXPathDebugObjTotalString++;\n+            xmlXPathDebugObjCounterString++;\n+            if (xmlXPathDebugObjCounterString >\n+                xmlXPathDebugObjMaxString)\n+                xmlXPathDebugObjMaxString =\n+                    xmlXPathDebugObjCounterString;\n@@ -1858,1 +1925,7 @@\n-            cache->dbgReusedPoint++;\n+            if (! isCached)\n+                xmlXPathDebugObjTotalPoint++;\n+            xmlXPathDebugObjCounterPoint++;\n+            if (xmlXPathDebugObjCounterPoint >\n+                xmlXPathDebugObjMaxPoint)\n+                xmlXPathDebugObjMaxPoint =\n+                    xmlXPathDebugObjCounterPoint;\n@@ -1861,1 +1934,7 @@\n-            cache->dbgReusedRange++;\n+            if (! isCached)\n+                xmlXPathDebugObjTotalRange++;\n+            xmlXPathDebugObjCounterRange++;\n+            if (xmlXPathDebugObjCounterRange >\n+                xmlXPathDebugObjMaxRange)\n+                xmlXPathDebugObjMaxRange =\n+                    xmlXPathDebugObjCounterRange;\n@@ -1864,1 +1943,7 @@\n-            cache->dbgReusedLocset++;\n+            if (! isCached)\n+                xmlXPathDebugObjTotalLocset++;\n+            xmlXPathDebugObjCounterLocset++;\n+            if (xmlXPathDebugObjCounterLocset >\n+                xmlXPathDebugObjMaxLocset)\n+                xmlXPathDebugObjMaxLocset =\n+                    xmlXPathDebugObjCounterLocset;\n@@ -1867,1 +1952,7 @@\n-            cache->dbgReusedUsers++;\n+            if (! isCached)\n+                xmlXPathDebugObjTotalUsers++;\n+            xmlXPathDebugObjCounterUsers++;\n+            if (xmlXPathDebugObjCounterUsers >\n+                xmlXPathDebugObjMaxUsers)\n+                xmlXPathDebugObjMaxUsers =\n+                    xmlXPathDebugObjCounterUsers;\n@@ -1870,1 +1961,7 @@\n-            cache->dbgReusedXSLTTree++;\n+            if (! isCached)\n+                xmlXPathDebugObjTotalXSLTTree++;\n+            xmlXPathDebugObjCounterXSLTTree++;\n+            if (xmlXPathDebugObjCounterXSLTTree >\n+                xmlXPathDebugObjMaxXSLTTree)\n+                xmlXPathDebugObjMaxXSLTTree =\n+                    xmlXPathDebugObjCounterXSLTTree;\n@@ -1874,97 +1971,0 @@\n-        }\n-    }\n-    }\n-\n-    switch (objType) {\n-    case XPATH_UNDEFINED:\n-        if (! isCached)\n-        xmlXPathDebugObjTotalUndefined++;\n-        xmlXPathDebugObjCounterUndefined++;\n-        if (xmlXPathDebugObjCounterUndefined >\n-        xmlXPathDebugObjMaxUndefined)\n-        xmlXPathDebugObjMaxUndefined =\n-            xmlXPathDebugObjCounterUndefined;\n-        break;\n-    case XPATH_NODESET:\n-        if (! isCached)\n-        xmlXPathDebugObjTotalNodeset++;\n-        xmlXPathDebugObjCounterNodeset++;\n-        if (xmlXPathDebugObjCounterNodeset >\n-        xmlXPathDebugObjMaxNodeset)\n-        xmlXPathDebugObjMaxNodeset =\n-            xmlXPathDebugObjCounterNodeset;\n-        break;\n-    case XPATH_BOOLEAN:\n-        if (! isCached)\n-        xmlXPathDebugObjTotalBool++;\n-        xmlXPathDebugObjCounterBool++;\n-        if (xmlXPathDebugObjCounterBool >\n-        xmlXPathDebugObjMaxBool)\n-        xmlXPathDebugObjMaxBool =\n-            xmlXPathDebugObjCounterBool;\n-        break;\n-    case XPATH_NUMBER:\n-        if (! isCached)\n-        xmlXPathDebugObjTotalNumber++;\n-        xmlXPathDebugObjCounterNumber++;\n-        if (xmlXPathDebugObjCounterNumber >\n-        xmlXPathDebugObjMaxNumber)\n-        xmlXPathDebugObjMaxNumber =\n-            xmlXPathDebugObjCounterNumber;\n-        break;\n-    case XPATH_STRING:\n-        if (! isCached)\n-        xmlXPathDebugObjTotalString++;\n-        xmlXPathDebugObjCounterString++;\n-        if (xmlXPathDebugObjCounterString >\n-        xmlXPathDebugObjMaxString)\n-        xmlXPathDebugObjMaxString =\n-            xmlXPathDebugObjCounterString;\n-        break;\n-    case XPATH_POINT:\n-        if (! isCached)\n-        xmlXPathDebugObjTotalPoint++;\n-        xmlXPathDebugObjCounterPoint++;\n-        if (xmlXPathDebugObjCounterPoint >\n-        xmlXPathDebugObjMaxPoint)\n-        xmlXPathDebugObjMaxPoint =\n-            xmlXPathDebugObjCounterPoint;\n-        break;\n-    case XPATH_RANGE:\n-        if (! isCached)\n-        xmlXPathDebugObjTotalRange++;\n-        xmlXPathDebugObjCounterRange++;\n-        if (xmlXPathDebugObjCounterRange >\n-        xmlXPathDebugObjMaxRange)\n-        xmlXPathDebugObjMaxRange =\n-            xmlXPathDebugObjCounterRange;\n-        break;\n-    case XPATH_LOCATIONSET:\n-        if (! isCached)\n-        xmlXPathDebugObjTotalLocset++;\n-        xmlXPathDebugObjCounterLocset++;\n-        if (xmlXPathDebugObjCounterLocset >\n-        xmlXPathDebugObjMaxLocset)\n-        xmlXPathDebugObjMaxLocset =\n-            xmlXPathDebugObjCounterLocset;\n-        break;\n-    case XPATH_USERS:\n-        if (! isCached)\n-        xmlXPathDebugObjTotalUsers++;\n-        xmlXPathDebugObjCounterUsers++;\n-        if (xmlXPathDebugObjCounterUsers >\n-        xmlXPathDebugObjMaxUsers)\n-        xmlXPathDebugObjMaxUsers =\n-            xmlXPathDebugObjCounterUsers;\n-        break;\n-    case XPATH_XSLT_TREE:\n-        if (! isCached)\n-        xmlXPathDebugObjTotalXSLTTree++;\n-        xmlXPathDebugObjCounterXSLTTree++;\n-        if (xmlXPathDebugObjCounterXSLTTree >\n-        xmlXPathDebugObjMaxXSLTTree)\n-        xmlXPathDebugObjMaxXSLTTree =\n-            xmlXPathDebugObjCounterXSLTTree;\n-        break;\n-    default:\n-        break;\n@@ -1973,1 +1973,1 @@\n-    xmlXPathDebugObjTotalAll++;\n+        xmlXPathDebugObjTotalAll++;\n@@ -1976,3 +1976,3 @@\n-    xmlXPathDebugObjMaxAll)\n-    xmlXPathDebugObjMaxAll =\n-        xmlXPathDebugObjCounterAll;\n+        xmlXPathDebugObjMaxAll)\n+        xmlXPathDebugObjMaxAll =\n+            xmlXPathDebugObjCounterAll;\n@@ -1983,1 +1983,1 @@\n-                  xmlXPathObjectType objType)\n+                              xmlXPathObjectType objType)\n@@ -1988,3 +1988,3 @@\n-    if (ctxt->cache != NULL) {\n-        xmlXPathContextCachePtr cache =\n-        (xmlXPathContextCachePtr) ctxt->cache;\n+        if (ctxt->cache != NULL) {\n+            xmlXPathContextCachePtr cache =\n+                (xmlXPathContextCachePtr) ctxt->cache;\n@@ -1992,1 +1992,37 @@\n-        isCached = 1;\n+            isCached = 1;\n+\n+            cache->dbgCachedAll++;\n+            switch (objType) {\n+                case XPATH_UNDEFINED:\n+                    cache->dbgCachedUndefined++;\n+                    break;\n+                case XPATH_NODESET:\n+                    cache->dbgCachedNodeset++;\n+                    break;\n+                case XPATH_BOOLEAN:\n+                    cache->dbgCachedBool++;\n+                    break;\n+                case XPATH_NUMBER:\n+                    cache->dbgCachedNumber++;\n+                    break;\n+                case XPATH_STRING:\n+                    cache->dbgCachedString++;\n+                    break;\n+                case XPATH_POINT:\n+                    cache->dbgCachedPoint++;\n+                    break;\n+                case XPATH_RANGE:\n+                    cache->dbgCachedRange++;\n+                    break;\n+                case XPATH_LOCATIONSET:\n+                    cache->dbgCachedLocset++;\n+                    break;\n+                case XPATH_USERS:\n+                    cache->dbgCachedUsers++;\n+                    break;\n+                case XPATH_XSLT_TREE:\n+                    cache->dbgCachedXSLTTree++;\n+                    break;\n+                default:\n+                    break;\n+            }\n@@ -1994,2 +2030,3 @@\n-        cache->dbgCachedAll++;\n-        switch (objType) {\n+        }\n+    }\n+    switch (objType) {\n@@ -1997,1 +2034,1 @@\n-            cache->dbgCachedUndefined++;\n+            xmlXPathDebugObjCounterUndefined--;\n@@ -2000,1 +2037,1 @@\n-            cache->dbgCachedNodeset++;\n+            xmlXPathDebugObjCounterNodeset--;\n@@ -2003,1 +2040,1 @@\n-            cache->dbgCachedBool++;\n+            xmlXPathDebugObjCounterBool--;\n@@ -2006,1 +2043,1 @@\n-            cache->dbgCachedNumber++;\n+            xmlXPathDebugObjCounterNumber--;\n@@ -2009,1 +2046,1 @@\n-            cache->dbgCachedString++;\n+            xmlXPathDebugObjCounterString--;\n@@ -2012,1 +2049,1 @@\n-            cache->dbgCachedPoint++;\n+            xmlXPathDebugObjCounterPoint--;\n@@ -2015,1 +2052,1 @@\n-            cache->dbgCachedRange++;\n+            xmlXPathDebugObjCounterRange--;\n@@ -2018,1 +2055,1 @@\n-            cache->dbgCachedLocset++;\n+            xmlXPathDebugObjCounterLocset--;\n@@ -2021,1 +2058,1 @@\n-            cache->dbgCachedUsers++;\n+            xmlXPathDebugObjCounterUsers--;\n@@ -2024,1 +2061,1 @@\n-            cache->dbgCachedXSLTTree++;\n+            xmlXPathDebugObjCounterXSLTTree--;\n@@ -2028,37 +2065,0 @@\n-        }\n-\n-    }\n-    }\n-    switch (objType) {\n-    case XPATH_UNDEFINED:\n-        xmlXPathDebugObjCounterUndefined--;\n-        break;\n-    case XPATH_NODESET:\n-        xmlXPathDebugObjCounterNodeset--;\n-        break;\n-    case XPATH_BOOLEAN:\n-        xmlXPathDebugObjCounterBool--;\n-        break;\n-    case XPATH_NUMBER:\n-        xmlXPathDebugObjCounterNumber--;\n-        break;\n-    case XPATH_STRING:\n-        xmlXPathDebugObjCounterString--;\n-        break;\n-    case XPATH_POINT:\n-        xmlXPathDebugObjCounterPoint--;\n-        break;\n-    case XPATH_RANGE:\n-        xmlXPathDebugObjCounterRange--;\n-        break;\n-    case XPATH_LOCATIONSET:\n-        xmlXPathDebugObjCounterLocset--;\n-        break;\n-    case XPATH_USERS:\n-        xmlXPathDebugObjCounterUsers--;\n-        break;\n-    case XPATH_XSLT_TREE:\n-        xmlXPathDebugObjCounterXSLTTree--;\n-        break;\n-    default:\n-        break;\n@@ -2073,1 +2073,1 @@\n-    reqXSLTTree, reqUndefined;\n+        reqXSLTTree, reqUndefined;\n@@ -2075,1 +2075,1 @@\n-    caNumber = 0, caXSLTTree = 0, caUndefined = 0;\n+        caNumber = 0, caXSLTTree = 0, caUndefined = 0;\n@@ -2077,1 +2077,1 @@\n-    reNumber = 0, reXSLTTree = 0, reUndefined = 0;\n+        reNumber = 0, reXSLTTree = 0, reUndefined = 0;\n@@ -2091,38 +2091,38 @@\n-    if (ctxt->cache != NULL) {\n-        xmlXPathContextCachePtr cache =\n-        (xmlXPathContextCachePtr) ctxt->cache;\n-\n-        reAll = cache->dbgReusedAll;\n-        reqAll += reAll;\n-        reNodeset = cache->dbgReusedNodeset;\n-        reqNodeset += reNodeset;\n-        reString = cache->dbgReusedString;\n-        reqString += reString;\n-        reBool = cache->dbgReusedBool;\n-        reqBool += reBool;\n-        reNumber = cache->dbgReusedNumber;\n-        reqNumber += reNumber;\n-        reXSLTTree = cache->dbgReusedXSLTTree;\n-        reqXSLTTree += reXSLTTree;\n-        reUndefined = cache->dbgReusedUndefined;\n-        reqUndefined += reUndefined;\n-\n-        caAll = cache->dbgCachedAll;\n-        caBool = cache->dbgCachedBool;\n-        caNodeset = cache->dbgCachedNodeset;\n-        caString = cache->dbgCachedString;\n-        caNumber = cache->dbgCachedNumber;\n-        caXSLTTree = cache->dbgCachedXSLTTree;\n-        caUndefined = cache->dbgCachedUndefined;\n-\n-        if (cache->nodesetObjs)\n-        leftObjs -= cache->nodesetObjs->number;\n-        if (cache->stringObjs)\n-        leftObjs -= cache->stringObjs->number;\n-        if (cache->booleanObjs)\n-        leftObjs -= cache->booleanObjs->number;\n-        if (cache->numberObjs)\n-        leftObjs -= cache->numberObjs->number;\n-        if (cache->miscObjs)\n-        leftObjs -= cache->miscObjs->number;\n-    }\n+        if (ctxt->cache != NULL) {\n+            xmlXPathContextCachePtr cache =\n+                (xmlXPathContextCachePtr) ctxt->cache;\n+\n+            reAll = cache->dbgReusedAll;\n+            reqAll += reAll;\n+            reNodeset = cache->dbgReusedNodeset;\n+            reqNodeset += reNodeset;\n+            reString = cache->dbgReusedString;\n+            reqString += reString;\n+            reBool = cache->dbgReusedBool;\n+            reqBool += reBool;\n+            reNumber = cache->dbgReusedNumber;\n+            reqNumber += reNumber;\n+            reXSLTTree = cache->dbgReusedXSLTTree;\n+            reqXSLTTree += reXSLTTree;\n+            reUndefined = cache->dbgReusedUndefined;\n+            reqUndefined += reUndefined;\n+\n+            caAll = cache->dbgCachedAll;\n+            caBool = cache->dbgCachedBool;\n+            caNodeset = cache->dbgCachedNodeset;\n+            caString = cache->dbgCachedString;\n+            caNumber = cache->dbgCachedNumber;\n+            caXSLTTree = cache->dbgCachedXSLTTree;\n+            caUndefined = cache->dbgCachedUndefined;\n+\n+            if (cache->nodesetObjs)\n+                leftObjs -= cache->nodesetObjs->number;\n+            if (cache->stringObjs)\n+                leftObjs -= cache->stringObjs->number;\n+            if (cache->booleanObjs)\n+                leftObjs -= cache->booleanObjs->number;\n+            if (cache->numberObjs)\n+                leftObjs -= cache->numberObjs->number;\n+            if (cache->miscObjs)\n+                leftObjs -= cache->miscObjs->number;\n+        }\n@@ -2181,3 +2181,3 @@\n- *                                  *\n- *          XPath object caching                *\n- *                                  *\n+ *                                                                      *\n+ *                      XPath object caching                            *\n+ *                                                                      *\n@@ -2201,1 +2201,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2219,1 +2219,1 @@\n-    return;\n+        return;\n@@ -2222,11 +2222,11 @@\n-    obj = list->items[i];\n-    \/*\n-    * Note that it is already assured that we don't need to\n-    * look out for namespace nodes in the node-set.\n-    *\/\n-    if (obj->nodesetval != NULL) {\n-        if (obj->nodesetval->nodeTab != NULL)\n-        xmlFree(obj->nodesetval->nodeTab);\n-        xmlFree(obj->nodesetval);\n-    }\n-    xmlFree(obj);\n+        obj = list->items[i];\n+        \/*\n+        * Note that it is already assured that we don't need to\n+        * look out for namespace nodes in the node-set.\n+        *\/\n+        if (obj->nodesetval != NULL) {\n+            if (obj->nodesetval->nodeTab != NULL)\n+                xmlFree(obj->nodesetval->nodeTab);\n+            xmlFree(obj->nodesetval);\n+        }\n+        xmlFree(obj);\n@@ -2234,1 +2234,1 @@\n-    xmlXPathDebugObjCounterAll--;\n+        xmlXPathDebugObjCounterAll--;\n@@ -2244,1 +2244,1 @@\n-    return;\n+        return;\n@@ -2246,1 +2246,1 @@\n-    xmlXPathCacheFreeObjectList(cache->nodesetObjs);\n+        xmlXPathCacheFreeObjectList(cache->nodesetObjs);\n@@ -2248,1 +2248,1 @@\n-    xmlXPathCacheFreeObjectList(cache->stringObjs);\n+        xmlXPathCacheFreeObjectList(cache->stringObjs);\n@@ -2250,1 +2250,1 @@\n-    xmlXPathCacheFreeObjectList(cache->booleanObjs);\n+        xmlXPathCacheFreeObjectList(cache->booleanObjs);\n@@ -2252,1 +2252,1 @@\n-    xmlXPathCacheFreeObjectList(cache->numberObjs);\n+        xmlXPathCacheFreeObjectList(cache->numberObjs);\n@@ -2254,1 +2254,1 @@\n-    xmlXPathCacheFreeObjectList(cache->miscObjs);\n+        xmlXPathCacheFreeObjectList(cache->miscObjs);\n@@ -2282,3 +2282,3 @@\n-            int active,\n-            int value,\n-            int options)\n+                        int active,\n+                        int value,\n+                        int options)\n@@ -2287,1 +2287,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2289,1 +2289,1 @@\n-    xmlXPathContextCachePtr cache;\n+        xmlXPathContextCachePtr cache;\n@@ -2291,15 +2291,15 @@\n-    if (ctxt->cache == NULL) {\n-        ctxt->cache = xmlXPathNewCache();\n-        if (ctxt->cache == NULL)\n-        return(-1);\n-    }\n-    cache = (xmlXPathContextCachePtr) ctxt->cache;\n-    if (options == 0) {\n-        if (value < 0)\n-        value = 100;\n-        cache->maxNodeset = value;\n-        cache->maxString = value;\n-        cache->maxNumber = value;\n-        cache->maxBoolean = value;\n-        cache->maxMisc = value;\n-    }\n+        if (ctxt->cache == NULL) {\n+            ctxt->cache = xmlXPathNewCache();\n+            if (ctxt->cache == NULL)\n+                return(-1);\n+        }\n+        cache = (xmlXPathContextCachePtr) ctxt->cache;\n+        if (options == 0) {\n+            if (value < 0)\n+                value = 100;\n+            cache->maxNodeset = value;\n+            cache->maxString = value;\n+            cache->maxNumber = value;\n+            cache->maxBoolean = value;\n+            cache->maxMisc = value;\n+        }\n@@ -2307,2 +2307,2 @@\n-    xmlXPathFreeCache((xmlXPathContextCachePtr) ctxt->cache);\n-    ctxt->cache = NULL;\n+        xmlXPathFreeCache((xmlXPathContextCachePtr) ctxt->cache);\n+        ctxt->cache = NULL;\n@@ -2327,2 +2327,2 @@\n-    xmlXPathContextCachePtr cache =\n-        (xmlXPathContextCachePtr) ctxt->cache;\n+        xmlXPathContextCachePtr cache =\n+            (xmlXPathContextCachePtr) ctxt->cache;\n@@ -2330,4 +2330,4 @@\n-    if ((cache->miscObjs != NULL) &&\n-        (cache->miscObjs->number != 0))\n-    {\n-        xmlXPathObjectPtr ret;\n+        if ((cache->miscObjs != NULL) &&\n+            (cache->miscObjs->number != 0))\n+        {\n+            xmlXPathObjectPtr ret;\n@@ -2335,4 +2335,4 @@\n-        ret = (xmlXPathObjectPtr)\n-        cache->miscObjs->items[--cache->miscObjs->number];\n-        ret->type = XPATH_NODESET;\n-        ret->nodesetval = val;\n+            ret = (xmlXPathObjectPtr)\n+                cache->miscObjs->items[--cache->miscObjs->number];\n+            ret->type = XPATH_NODESET;\n+            ret->nodesetval = val;\n@@ -2340,1 +2340,1 @@\n-        xmlXPathDebugObjUsageRequested(ctxt, XPATH_NODESET);\n+            xmlXPathDebugObjUsageRequested(ctxt, XPATH_NODESET);\n@@ -2342,2 +2342,2 @@\n-        return(ret);\n-    }\n+            return(ret);\n+        }\n@@ -2364,1 +2364,1 @@\n-    xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n+        xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n@@ -2366,3 +2366,3 @@\n-    if ((cache->stringObjs != NULL) &&\n-        (cache->stringObjs->number != 0))\n-    {\n+        if ((cache->stringObjs != NULL) &&\n+            (cache->stringObjs->number != 0))\n+        {\n@@ -2370,1 +2370,1 @@\n-        xmlXPathObjectPtr ret;\n+            xmlXPathObjectPtr ret;\n@@ -2372,4 +2372,4 @@\n-        ret = (xmlXPathObjectPtr)\n-        cache->stringObjs->items[--cache->stringObjs->number];\n-        ret->type = XPATH_STRING;\n-        ret->stringval = val;\n+            ret = (xmlXPathObjectPtr)\n+                cache->stringObjs->items[--cache->stringObjs->number];\n+            ret->type = XPATH_STRING;\n+            ret->stringval = val;\n@@ -2377,1 +2377,1 @@\n-        xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n+            xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n@@ -2379,10 +2379,10 @@\n-        return(ret);\n-    } else if ((cache->miscObjs != NULL) &&\n-        (cache->miscObjs->number != 0))\n-    {\n-        xmlXPathObjectPtr ret;\n-        \/*\n-        * Fallback to misc-cache.\n-        *\/\n-        ret = (xmlXPathObjectPtr)\n-        cache->miscObjs->items[--cache->miscObjs->number];\n+            return(ret);\n+        } else if ((cache->miscObjs != NULL) &&\n+            (cache->miscObjs->number != 0))\n+        {\n+            xmlXPathObjectPtr ret;\n+            \/*\n+            * Fallback to misc-cache.\n+            *\/\n+            ret = (xmlXPathObjectPtr)\n+                cache->miscObjs->items[--cache->miscObjs->number];\n@@ -2390,2 +2390,2 @@\n-        ret->type = XPATH_STRING;\n-        ret->stringval = val;\n+            ret->type = XPATH_STRING;\n+            ret->stringval = val;\n@@ -2393,1 +2393,1 @@\n-        xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n+            xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n@@ -2395,2 +2395,2 @@\n-        return(ret);\n-    }\n+            return(ret);\n+        }\n@@ -2416,1 +2416,1 @@\n-    xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n+        xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n@@ -2418,14 +2418,2 @@\n-    if ((cache->nodesetObjs != NULL) &&\n-        (cache->nodesetObjs->number != 0))\n-    {\n-        xmlXPathObjectPtr ret;\n-        \/*\n-        * Use the nodeset-cache.\n-        *\/\n-        ret = (xmlXPathObjectPtr)\n-        cache->nodesetObjs->items[--cache->nodesetObjs->number];\n-        ret->type = XPATH_NODESET;\n-        ret->boolval = 0;\n-        if (val) {\n-        if ((ret->nodesetval->nodeMax == 0) ||\n-            (val->type == XML_NAMESPACE_DECL))\n+        if ((cache->nodesetObjs != NULL) &&\n+            (cache->nodesetObjs->number != 0))\n@@ -2433,0 +2421,12 @@\n+            xmlXPathObjectPtr ret;\n+            \/*\n+            * Use the nodeset-cache.\n+            *\/\n+            ret = (xmlXPathObjectPtr)\n+                cache->nodesetObjs->items[--cache->nodesetObjs->number];\n+            ret->type = XPATH_NODESET;\n+            ret->boolval = 0;\n+            if (val) {\n+                if ((ret->nodesetval->nodeMax == 0) ||\n+                    (val->type == XML_NAMESPACE_DECL))\n+                {\n@@ -2434,6 +2434,6 @@\n-            xmlXPathNodeSetAddUnique(ret->nodesetval, val);\n-        } else {\n-            ret->nodesetval->nodeTab[0] = val;\n-            ret->nodesetval->nodeNr = 1;\n-        }\n-        }\n+                    xmlXPathNodeSetAddUnique(ret->nodesetval, val);\n+                } else {\n+                    ret->nodesetval->nodeTab[0] = val;\n+                    ret->nodesetval->nodeNr = 1;\n+                }\n+            }\n@@ -2441,1 +2441,1 @@\n-        xmlXPathDebugObjUsageRequested(ctxt, XPATH_NODESET);\n+            xmlXPathDebugObjUsageRequested(ctxt, XPATH_NODESET);\n@@ -2443,8 +2443,8 @@\n-        return(ret);\n-    } else if ((cache->miscObjs != NULL) &&\n-        (cache->miscObjs->number != 0))\n-    {\n-        xmlXPathObjectPtr ret;\n-        \/*\n-        * Fallback to misc-cache.\n-        *\/\n+            return(ret);\n+        } else if ((cache->miscObjs != NULL) &&\n+            (cache->miscObjs->number != 0))\n+        {\n+            xmlXPathObjectPtr ret;\n+            \/*\n+            * Fallback to misc-cache.\n+            *\/\n@@ -2452,2 +2452,2 @@\n-        ret = (xmlXPathObjectPtr)\n-        cache->miscObjs->items[--cache->miscObjs->number];\n+            ret = (xmlXPathObjectPtr)\n+                cache->miscObjs->items[--cache->miscObjs->number];\n@@ -2455,8 +2455,8 @@\n-        ret->type = XPATH_NODESET;\n-        ret->boolval = 0;\n-        ret->nodesetval = xmlXPathNodeSetCreate(val);\n-        if (ret->nodesetval == NULL) {\n-        ctxt->lastError.domain = XML_FROM_XPATH;\n-        ctxt->lastError.code = XML_ERR_NO_MEMORY;\n-        return(NULL);\n-        }\n+            ret->type = XPATH_NODESET;\n+            ret->boolval = 0;\n+            ret->nodesetval = xmlXPathNodeSetCreate(val);\n+            if (ret->nodesetval == NULL) {\n+                ctxt->lastError.domain = XML_FROM_XPATH;\n+                ctxt->lastError.code = XML_ERR_NO_MEMORY;\n+                return(NULL);\n+            }\n@@ -2464,1 +2464,1 @@\n-        xmlXPathDebugObjUsageRequested(ctxt, XPATH_NODESET);\n+            xmlXPathDebugObjUsageRequested(ctxt, XPATH_NODESET);\n@@ -2466,2 +2466,2 @@\n-        return(ret);\n-    }\n+            return(ret);\n+        }\n@@ -2486,1 +2486,1 @@\n-    xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n+        xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n@@ -2488,4 +2488,4 @@\n-    if ((cache->stringObjs != NULL) &&\n-        (cache->stringObjs->number != 0))\n-    {\n-        xmlXPathObjectPtr ret;\n+        if ((cache->stringObjs != NULL) &&\n+            (cache->stringObjs->number != 0))\n+        {\n+            xmlXPathObjectPtr ret;\n@@ -2493,2 +2493,2 @@\n-        ret = (xmlXPathObjectPtr)\n-        cache->stringObjs->items[--cache->stringObjs->number];\n+            ret = (xmlXPathObjectPtr)\n+                cache->stringObjs->items[--cache->stringObjs->number];\n@@ -2496,2 +2496,2 @@\n-        ret->type = XPATH_STRING;\n-        ret->stringval = xmlStrdup(BAD_CAST val);\n+            ret->type = XPATH_STRING;\n+            ret->stringval = xmlStrdup(BAD_CAST val);\n@@ -2499,1 +2499,1 @@\n-        xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n+            xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n@@ -2501,5 +2501,5 @@\n-        return(ret);\n-    } else if ((cache->miscObjs != NULL) &&\n-        (cache->miscObjs->number != 0))\n-    {\n-        xmlXPathObjectPtr ret;\n+            return(ret);\n+        } else if ((cache->miscObjs != NULL) &&\n+            (cache->miscObjs->number != 0))\n+        {\n+            xmlXPathObjectPtr ret;\n@@ -2507,2 +2507,2 @@\n-        ret = (xmlXPathObjectPtr)\n-        cache->miscObjs->items[--cache->miscObjs->number];\n+            ret = (xmlXPathObjectPtr)\n+                cache->miscObjs->items[--cache->miscObjs->number];\n@@ -2510,2 +2510,2 @@\n-        ret->type = XPATH_STRING;\n-        ret->stringval = xmlStrdup(BAD_CAST val);\n+            ret->type = XPATH_STRING;\n+            ret->stringval = xmlStrdup(BAD_CAST val);\n@@ -2513,1 +2513,1 @@\n-        xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n+            xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n@@ -2515,2 +2515,2 @@\n-        return(ret);\n-    }\n+            return(ret);\n+        }\n@@ -2535,1 +2535,1 @@\n-    xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n+        xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n@@ -2537,4 +2537,4 @@\n-    if ((cache->stringObjs != NULL) &&\n-        (cache->stringObjs->number != 0))\n-    {\n-        xmlXPathObjectPtr ret;\n+        if ((cache->stringObjs != NULL) &&\n+            (cache->stringObjs->number != 0))\n+        {\n+            xmlXPathObjectPtr ret;\n@@ -2542,7 +2542,7 @@\n-        ret = (xmlXPathObjectPtr)\n-        cache->stringObjs->items[--cache->stringObjs->number];\n-        ret->type = XPATH_STRING;\n-        if (val != NULL)\n-        ret->stringval = xmlStrdup(val);\n-        else\n-        ret->stringval = xmlStrdup((const xmlChar *)\"\");\n+            ret = (xmlXPathObjectPtr)\n+                cache->stringObjs->items[--cache->stringObjs->number];\n+            ret->type = XPATH_STRING;\n+            if (val != NULL)\n+                ret->stringval = xmlStrdup(val);\n+            else\n+                ret->stringval = xmlStrdup((const xmlChar *)\"\");\n@@ -2550,1 +2550,1 @@\n-        xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n+            xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n@@ -2552,5 +2552,5 @@\n-        return(ret);\n-    } else if ((cache->miscObjs != NULL) &&\n-        (cache->miscObjs->number != 0))\n-    {\n-        xmlXPathObjectPtr ret;\n+            return(ret);\n+        } else if ((cache->miscObjs != NULL) &&\n+            (cache->miscObjs->number != 0))\n+        {\n+            xmlXPathObjectPtr ret;\n@@ -2558,2 +2558,2 @@\n-        ret = (xmlXPathObjectPtr)\n-        cache->miscObjs->items[--cache->miscObjs->number];\n+            ret = (xmlXPathObjectPtr)\n+                cache->miscObjs->items[--cache->miscObjs->number];\n@@ -2561,5 +2561,5 @@\n-        ret->type = XPATH_STRING;\n-        if (val != NULL)\n-        ret->stringval = xmlStrdup(val);\n-        else\n-        ret->stringval = xmlStrdup((const xmlChar *)\"\");\n+            ret->type = XPATH_STRING;\n+            if (val != NULL)\n+                ret->stringval = xmlStrdup(val);\n+            else\n+                ret->stringval = xmlStrdup((const xmlChar *)\"\");\n@@ -2567,1 +2567,1 @@\n-        xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n+            xmlXPathDebugObjUsageRequested(ctxt, XPATH_STRING);\n@@ -2569,2 +2569,2 @@\n-        return(ret);\n-    }\n+            return(ret);\n+        }\n@@ -2589,1 +2589,1 @@\n-    xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n+        xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n@@ -2591,4 +2591,4 @@\n-    if ((cache->booleanObjs != NULL) &&\n-        (cache->booleanObjs->number != 0))\n-    {\n-        xmlXPathObjectPtr ret;\n+        if ((cache->booleanObjs != NULL) &&\n+            (cache->booleanObjs->number != 0))\n+        {\n+            xmlXPathObjectPtr ret;\n@@ -2596,4 +2596,4 @@\n-        ret = (xmlXPathObjectPtr)\n-        cache->booleanObjs->items[--cache->booleanObjs->number];\n-        ret->type = XPATH_BOOLEAN;\n-        ret->boolval = (val != 0);\n+            ret = (xmlXPathObjectPtr)\n+                cache->booleanObjs->items[--cache->booleanObjs->number];\n+            ret->type = XPATH_BOOLEAN;\n+            ret->boolval = (val != 0);\n@@ -2601,1 +2601,1 @@\n-        xmlXPathDebugObjUsageRequested(ctxt, XPATH_BOOLEAN);\n+            xmlXPathDebugObjUsageRequested(ctxt, XPATH_BOOLEAN);\n@@ -2603,5 +2603,5 @@\n-        return(ret);\n-    } else if ((cache->miscObjs != NULL) &&\n-        (cache->miscObjs->number != 0))\n-    {\n-        xmlXPathObjectPtr ret;\n+            return(ret);\n+        } else if ((cache->miscObjs != NULL) &&\n+            (cache->miscObjs->number != 0))\n+        {\n+            xmlXPathObjectPtr ret;\n@@ -2609,2 +2609,2 @@\n-        ret = (xmlXPathObjectPtr)\n-        cache->miscObjs->items[--cache->miscObjs->number];\n+            ret = (xmlXPathObjectPtr)\n+                cache->miscObjs->items[--cache->miscObjs->number];\n@@ -2612,2 +2612,2 @@\n-        ret->type = XPATH_BOOLEAN;\n-        ret->boolval = (val != 0);\n+            ret->type = XPATH_BOOLEAN;\n+            ret->boolval = (val != 0);\n@@ -2615,1 +2615,1 @@\n-        xmlXPathDebugObjUsageRequested(ctxt, XPATH_BOOLEAN);\n+            xmlXPathDebugObjUsageRequested(ctxt, XPATH_BOOLEAN);\n@@ -2617,2 +2617,2 @@\n-        return(ret);\n-    }\n+            return(ret);\n+        }\n@@ -2637,1 +2637,1 @@\n-    xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n+        xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n@@ -2639,4 +2639,4 @@\n-    if ((cache->numberObjs != NULL) &&\n-        (cache->numberObjs->number != 0))\n-    {\n-        xmlXPathObjectPtr ret;\n+        if ((cache->numberObjs != NULL) &&\n+            (cache->numberObjs->number != 0))\n+        {\n+            xmlXPathObjectPtr ret;\n@@ -2644,4 +2644,4 @@\n-        ret = (xmlXPathObjectPtr)\n-        cache->numberObjs->items[--cache->numberObjs->number];\n-        ret->type = XPATH_NUMBER;\n-        ret->floatval = val;\n+            ret = (xmlXPathObjectPtr)\n+                cache->numberObjs->items[--cache->numberObjs->number];\n+            ret->type = XPATH_NUMBER;\n+            ret->floatval = val;\n@@ -2649,1 +2649,1 @@\n-        xmlXPathDebugObjUsageRequested(ctxt, XPATH_NUMBER);\n+            xmlXPathDebugObjUsageRequested(ctxt, XPATH_NUMBER);\n@@ -2651,5 +2651,5 @@\n-        return(ret);\n-    } else if ((cache->miscObjs != NULL) &&\n-        (cache->miscObjs->number != 0))\n-    {\n-        xmlXPathObjectPtr ret;\n+            return(ret);\n+        } else if ((cache->miscObjs != NULL) &&\n+            (cache->miscObjs->number != 0))\n+        {\n+            xmlXPathObjectPtr ret;\n@@ -2657,2 +2657,2 @@\n-        ret = (xmlXPathObjectPtr)\n-        cache->miscObjs->items[--cache->miscObjs->number];\n+            ret = (xmlXPathObjectPtr)\n+                cache->miscObjs->items[--cache->miscObjs->number];\n@@ -2660,2 +2660,2 @@\n-        ret->type = XPATH_NUMBER;\n-        ret->floatval = val;\n+            ret->type = XPATH_NUMBER;\n+            ret->floatval = val;\n@@ -2663,1 +2663,1 @@\n-        xmlXPathDebugObjUsageRequested(ctxt, XPATH_NUMBER);\n+            xmlXPathDebugObjUsageRequested(ctxt, XPATH_NUMBER);\n@@ -2665,2 +2665,2 @@\n-        return(ret);\n-    }\n+            return(ret);\n+        }\n@@ -2688,1 +2688,1 @@\n-    return(xmlXPathCacheNewCString(ctxt, \"\"));\n+        return(xmlXPathCacheNewCString(ctxt, \"\"));\n@@ -2693,1 +2693,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"STRING: undefined\\n\");\n+        xmlGenericError(xmlGenericErrorContext, \"STRING: undefined\\n\");\n@@ -2695,1 +2695,1 @@\n-    break;\n+        break;\n@@ -2698,2 +2698,2 @@\n-    res = xmlXPathCastNodeSetToString(val->nodesetval);\n-    break;\n+        res = xmlXPathCastNodeSetToString(val->nodesetval);\n+        break;\n@@ -2701,1 +2701,1 @@\n-    return(val);\n+        return(val);\n@@ -2703,2 +2703,2 @@\n-    res = xmlXPathCastBooleanToString(val->boolval);\n-    break;\n+        res = xmlXPathCastBooleanToString(val->boolval);\n+        break;\n@@ -2706,2 +2706,2 @@\n-    res = xmlXPathCastNumberToString(val->floatval);\n-    break;\n+        res = xmlXPathCastNumberToString(val->floatval);\n+        break;\n@@ -2712,2 +2712,2 @@\n-    TODO;\n-    break;\n+        TODO;\n+        break;\n@@ -2717,1 +2717,1 @@\n-    return(xmlXPathCacheNewCString(ctxt, \"\"));\n+        return(xmlXPathCacheNewCString(ctxt, \"\"));\n@@ -2735,1 +2735,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2738,13 +2738,13 @@\n-    switch (val->type) {\n-        case XPATH_NODESET:\n-        return(xmlXPathCacheWrapNodeSet(ctxt,\n-            xmlXPathNodeSetMerge(NULL, val->nodesetval)));\n-        case XPATH_STRING:\n-        return(xmlXPathCacheNewString(ctxt, val->stringval));\n-        case XPATH_BOOLEAN:\n-        return(xmlXPathCacheNewBoolean(ctxt, val->boolval));\n-        case XPATH_NUMBER:\n-        return(xmlXPathCacheNewFloat(ctxt, val->floatval));\n-        default:\n-        break;\n-    }\n+        switch (val->type) {\n+            case XPATH_NODESET:\n+                return(xmlXPathCacheWrapNodeSet(ctxt,\n+                    xmlXPathNodeSetMerge(NULL, val->nodesetval)));\n+            case XPATH_STRING:\n+                return(xmlXPathCacheNewString(ctxt, val->stringval));\n+            case XPATH_BOOLEAN:\n+                return(xmlXPathCacheNewBoolean(ctxt, val->boolval));\n+            case XPATH_NUMBER:\n+                return(xmlXPathCacheNewFloat(ctxt, val->floatval));\n+            default:\n+                break;\n+        }\n@@ -2771,1 +2771,1 @@\n-    return(xmlXPathCacheNewBoolean(ctxt, 0));\n+        return(xmlXPathCacheNewBoolean(ctxt, 0));\n@@ -2773,1 +2773,1 @@\n-    return(val);\n+        return(val);\n@@ -2795,1 +2795,1 @@\n-    return(xmlXPathCacheNewFloat(ctxt, 0.0));\n+        return(xmlXPathCacheNewFloat(ctxt, 0.0));\n@@ -2797,1 +2797,1 @@\n-    return(val);\n+        return(val);\n@@ -2804,3 +2804,3 @@\n- *                                  *\n- *      Parser stacks related functions and macros      *\n- *                                  *\n+ *                                                                      *\n+ *              Parser stacks related functions and macros              *\n+ *                                                                      *\n@@ -2894,1 +2894,1 @@\n-    ctxt->error = XPATH_MEMORY_ERROR;\n+        ctxt->error = XPATH_MEMORY_ERROR;\n@@ -2912,1 +2912,1 @@\n-    ctxt->valueTab = tmp;\n+        ctxt->valueTab = tmp;\n@@ -2935,2 +2935,2 @@\n-    xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n-    return(0);\n+        xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n+        return(0);\n@@ -2939,1 +2939,1 @@\n-    ret = xmlXPathCastToBoolean(obj);\n+        ret = xmlXPathCastToBoolean(obj);\n@@ -2962,2 +2962,2 @@\n-    xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n-    return(0);\n+        xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n+        return(0);\n@@ -2966,1 +2966,1 @@\n-    ret = xmlXPathCastToNumber(obj);\n+        ret = xmlXPathCastToNumber(obj);\n@@ -2989,2 +2989,2 @@\n-    xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n-    return(NULL);\n+        xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n+        return(NULL);\n@@ -2995,1 +2995,1 @@\n-    obj->stringval = NULL;\n+        obj->stringval = NULL;\n@@ -3016,2 +3016,2 @@\n-    xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n-    return(NULL);\n+        xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n+        return(NULL);\n@@ -3020,2 +3020,2 @@\n-    xmlXPathSetTypeError(ctxt);\n-    return(NULL);\n+        xmlXPathSetTypeError(ctxt);\n+        return(NULL);\n@@ -3050,2 +3050,2 @@\n-    xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n-    return(NULL);\n+        xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n+        return(NULL);\n@@ -3054,2 +3054,2 @@\n-    xmlXPathSetTypeError(ctxt);\n-    return(NULL);\n+        xmlXPathSetTypeError(ctxt);\n+        return(NULL);\n@@ -3099,1 +3099,1 @@\n-#define SKIP_BLANKS                         \\\n+#define SKIP_BLANKS                                                     \\\n@@ -3134,3 +3134,3 @@\n-    if (buffersize > (int)sizeof(\"Infinity\"))\n-        snprintf(buffer, buffersize, \"Infinity\");\n-    break;\n+        if (buffersize > (int)sizeof(\"Infinity\"))\n+            snprintf(buffer, buffersize, \"Infinity\");\n+        break;\n@@ -3138,3 +3138,3 @@\n-    if (buffersize > (int)sizeof(\"-Infinity\"))\n-        snprintf(buffer, buffersize, \"-Infinity\");\n-    break;\n+        if (buffersize > (int)sizeof(\"-Infinity\"))\n+            snprintf(buffer, buffersize, \"-Infinity\");\n+        break;\n@@ -3142,4 +3142,4 @@\n-    if (xmlXPathIsNaN(number)) {\n-        if (buffersize > (int)sizeof(\"NaN\"))\n-        snprintf(buffer, buffersize, \"NaN\");\n-    } else if (number == 0) {\n+        if (xmlXPathIsNaN(number)) {\n+            if (buffersize > (int)sizeof(\"NaN\"))\n+                snprintf(buffer, buffersize, \"NaN\");\n+        } else if (number == 0) {\n@@ -3147,2 +3147,2 @@\n-        snprintf(buffer, buffersize, \"0\");\n-    } else if ((number > INT_MIN) && (number < INT_MAX) &&\n+            snprintf(buffer, buffersize, \"0\");\n+        } else if ((number > INT_MIN) && (number < INT_MAX) &&\n@@ -3150,3 +3150,3 @@\n-        char work[30];\n-        char *ptr, *cur;\n-        int value = (int) number;\n+            char work[30];\n+            char *ptr, *cur;\n+            int value = (int) number;\n@@ -3155,2 +3155,15 @@\n-        if (value == 0) {\n-        *ptr++ = '0';\n+            if (value == 0) {\n+                *ptr++ = '0';\n+            } else {\n+                snprintf(work, 29, \"%d\", value);\n+                cur = &work[0];\n+                while ((*cur) && (ptr - buffer < buffersize)) {\n+                    *ptr++ = *cur++;\n+                }\n+            }\n+            if (ptr - buffer < buffersize) {\n+                *ptr = 0;\n+            } else if (buffersize > 0) {\n+                ptr--;\n+                *ptr = 0;\n+            }\n@@ -3158,30 +3171,15 @@\n-        snprintf(work, 29, \"%d\", value);\n-        cur = &work[0];\n-        while ((*cur) && (ptr - buffer < buffersize)) {\n-            *ptr++ = *cur++;\n-        }\n-        }\n-        if (ptr - buffer < buffersize) {\n-        *ptr = 0;\n-        } else if (buffersize > 0) {\n-        ptr--;\n-        *ptr = 0;\n-        }\n-    } else {\n-        \/*\n-          For the dimension of work,\n-              DBL_DIG is number of significant digits\n-          EXPONENT is only needed for \"scientific notation\"\n-              3 is sign, decimal point, and terminating zero\n-          LOWER_DOUBLE_EXP is max number of leading zeroes in fraction\n-          Note that this dimension is slightly (a few characters)\n-          larger than actually necessary.\n-        *\/\n-        char work[DBL_DIG + EXPONENT_DIGITS + 3 + LOWER_DOUBLE_EXP];\n-        int integer_place, fraction_place;\n-        char *ptr;\n-        char *after_fraction;\n-        double absolute_value;\n-        int size;\n-\n-        absolute_value = fabs(number);\n+            \/*\n+              For the dimension of work,\n+                  DBL_DIG is number of significant digits\n+                  EXPONENT is only needed for \"scientific notation\"\n+                  3 is sign, decimal point, and terminating zero\n+                  LOWER_DOUBLE_EXP is max number of leading zeroes in fraction\n+              Note that this dimension is slightly (a few characters)\n+              larger than actually necessary.\n+            *\/\n+            char work[DBL_DIG + EXPONENT_DIGITS + 3 + LOWER_DOUBLE_EXP];\n+            int integer_place, fraction_place;\n+            char *ptr;\n+            char *after_fraction;\n+            double absolute_value;\n+            int size;\n@@ -3189,14 +3187,1 @@\n-        \/*\n-         * First choose format - scientific or regular floating point.\n-         * In either case, result is in work, and after_fraction points\n-         * just past the fractional part.\n-        *\/\n-        if ( ((absolute_value > UPPER_DOUBLE) ||\n-          (absolute_value < LOWER_DOUBLE)) &&\n-         (absolute_value != 0.0) ) {\n-        \/* Use scientific notation *\/\n-        integer_place = DBL_DIG + EXPONENT_DIGITS + 1;\n-        fraction_place = DBL_DIG - 1;\n-        size = snprintf(work, sizeof(work),\"%*.*e\",\n-             integer_place, fraction_place, number);\n-        while ((size > 0) && (work[size] != 'e')) size--;\n+            absolute_value = fabs(number);\n@@ -3204,15 +3189,14 @@\n-        }\n-        else {\n-        \/* Use regular notation *\/\n-        if (absolute_value > 0.0) {\n-            integer_place = (int)log10(absolute_value);\n-            if (integer_place > 0)\n-                fraction_place = DBL_DIG - integer_place - 1;\n-            else\n-                fraction_place = DBL_DIG - integer_place;\n-        } else {\n-            fraction_place = 1;\n-        }\n-        size = snprintf(work, sizeof(work), \"%0.*f\",\n-                fraction_place, number);\n-        }\n+            \/*\n+             * First choose format - scientific or regular floating point.\n+             * In either case, result is in work, and after_fraction points\n+             * just past the fractional part.\n+            *\/\n+            if ( ((absolute_value > UPPER_DOUBLE) ||\n+                  (absolute_value < LOWER_DOUBLE)) &&\n+                 (absolute_value != 0.0) ) {\n+                \/* Use scientific notation *\/\n+                integer_place = DBL_DIG + EXPONENT_DIGITS + 1;\n+                fraction_place = DBL_DIG - 1;\n+                size = snprintf(work, sizeof(work),\"%*.*e\",\n+                         integer_place, fraction_place, number);\n+                while ((size > 0) && (work[size] != 'e')) size--;\n@@ -3220,5 +3204,15 @@\n-        \/* Remove leading spaces sometimes inserted by snprintf *\/\n-        while (work[0] == ' ') {\n-            for (ptr = &work[0];(ptr[0] = ptr[1]);ptr++);\n-        size--;\n-        }\n+            }\n+            else {\n+                \/* Use regular notation *\/\n+                if (absolute_value > 0.0) {\n+                    integer_place = (int)log10(absolute_value);\n+                    if (integer_place > 0)\n+                        fraction_place = DBL_DIG - integer_place - 1;\n+                    else\n+                        fraction_place = DBL_DIG - integer_place;\n+                } else {\n+                    fraction_place = 1;\n+                }\n+                size = snprintf(work, sizeof(work), \"%0.*f\",\n+                                fraction_place, number);\n+            }\n@@ -3226,8 +3220,5 @@\n-        \/* Remove fractional trailing zeroes *\/\n-        after_fraction = work + size;\n-        ptr = after_fraction;\n-        while (*(--ptr) == '0')\n-        ;\n-        if (*ptr != '.')\n-            ptr++;\n-        while ((*ptr++ = *after_fraction++) != 0);\n+            \/* Remove leading spaces sometimes inserted by snprintf *\/\n+            while (work[0] == ' ') {\n+                for (ptr = &work[0];(ptr[0] = ptr[1]);ptr++);\n+                size--;\n+            }\n@@ -3235,5 +3226,16 @@\n-        \/* Finally copy result back to caller *\/\n-        size = strlen(work) + 1;\n-        if (size > buffersize) {\n-        work[buffersize - 1] = 0;\n-        size = buffersize;\n+            \/* Remove fractional trailing zeroes *\/\n+            after_fraction = work + size;\n+            ptr = after_fraction;\n+            while (*(--ptr) == '0')\n+                ;\n+            if (*ptr != '.')\n+                ptr++;\n+            while ((*ptr++ = *after_fraction++) != 0);\n+\n+            \/* Finally copy result back to caller *\/\n+            size = strlen(work) + 1;\n+            if (size > buffersize) {\n+                work[buffersize - 1] = 0;\n+                size = buffersize;\n+            }\n+            memmove(buffer, work, size);\n@@ -3241,3 +3243,1 @@\n-        memmove(buffer, work, size);\n-    }\n-    break;\n+        break;\n@@ -3249,3 +3249,3 @@\n- *                                  *\n- *          Routines to handle NodeSets         *\n- *                                  *\n+ *                                                                      *\n+ *                      Routines to handle NodeSets                     *\n+ *                                                                      *\n@@ -3273,1 +3273,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3276,18 +3276,6 @@\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        cur->content = (void *) (-(++count));\n-        if (cur->children != NULL) {\n-        cur = cur->children;\n-        continue;\n-        }\n-    }\n-    if (cur->next != NULL) {\n-        cur = cur->next;\n-        continue;\n-    }\n-    do {\n-        cur = cur->parent;\n-        if (cur == NULL)\n-        break;\n-        if (cur == (xmlNodePtr) doc) {\n-        cur = NULL;\n-        break;\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            cur->content = (void *) (-(++count));\n+            if (cur->children != NULL) {\n+                cur = cur->children;\n+                continue;\n+            }\n@@ -3296,2 +3284,2 @@\n-        cur = cur->next;\n-        break;\n+            cur = cur->next;\n+            continue;\n@@ -3299,1 +3287,13 @@\n-    } while (cur != NULL);\n+        do {\n+            cur = cur->parent;\n+            if (cur == NULL)\n+                break;\n+            if (cur == (xmlNodePtr) doc) {\n+                cur = NULL;\n+                break;\n+            }\n+            if (cur->next != NULL) {\n+                cur = cur->next;\n+                break;\n+            }\n+        } while (cur != NULL);\n@@ -3322,1 +3322,1 @@\n-    return(-2);\n+        return(-2);\n@@ -3326,2 +3326,2 @@\n-    if (node1 == node2)     \/* trivial case *\/\n-    return(0);\n+    if (node1 == node2)         \/* trivial case *\/\n+        return(0);\n@@ -3329,3 +3329,3 @@\n-    attr1 = 1;\n-    attrNode1 = node1;\n-    node1 = node1->parent;\n+        attr1 = 1;\n+        attrNode1 = node1;\n+        node1 = node1->parent;\n@@ -3334,3 +3334,3 @@\n-    attr2 = 1;\n-    attrNode2 = node2;\n-    node2 = node2->parent;\n+        attr2 = 1;\n+        attrNode2 = node2;\n+        node2 = node2->parent;\n@@ -3339,10 +3339,12 @@\n-    if (attr1 == attr2) {\n-        \/* not required, but we keep attributes in order *\/\n-        if (attr1 != 0) {\n-            cur = attrNode2->prev;\n-        while (cur != NULL) {\n-            if (cur == attrNode1)\n-                return (1);\n-            cur = cur->prev;\n-        }\n-        return (-1);\n+        if (attr1 == attr2) {\n+            \/* not required, but we keep attributes in order *\/\n+            if (attr1 != 0) {\n+                cur = attrNode2->prev;\n+                while (cur != NULL) {\n+                    if (cur == attrNode1)\n+                        return (1);\n+                    cur = cur->prev;\n+                }\n+                return (-1);\n+            }\n+            return(0);\n@@ -3350,5 +3352,3 @@\n-        return(0);\n-    }\n-    if (attr2 == 1)\n-        return(1);\n-    return(-1);\n+        if (attr2 == 1)\n+            return(1);\n+        return(-1);\n@@ -3358,1 +3358,1 @@\n-    return(1);\n+        return(1);\n@@ -3360,1 +3360,1 @@\n-    return(1);\n+        return(1);\n@@ -3362,1 +3362,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3368,12 +3368,12 @@\n-    (node2->type == XML_ELEMENT_NODE) &&\n-    (0 > (ptrdiff_t) node1->content) &&\n-    (0 > (ptrdiff_t) node2->content) &&\n-    (node1->doc == node2->doc)) {\n-    ptrdiff_t l1, l2;\n-\n-    l1 = -((ptrdiff_t) node1->content);\n-    l2 = -((ptrdiff_t) node2->content);\n-    if (l1 < l2)\n-        return(1);\n-    if (l1 > l2)\n-        return(-1);\n+        (node2->type == XML_ELEMENT_NODE) &&\n+        (0 > (ptrdiff_t) node1->content) &&\n+        (0 > (ptrdiff_t) node2->content) &&\n+        (node1->doc == node2->doc)) {\n+        ptrdiff_t l1, l2;\n+\n+        l1 = -((ptrdiff_t) node1->content);\n+        l2 = -((ptrdiff_t) node2->content);\n+        if (l1 < l2)\n+            return(1);\n+        if (l1 > l2)\n+            return(-1);\n@@ -3386,3 +3386,3 @@\n-    if (cur->parent == node1)\n-        return(1);\n-    depth2++;\n+        if (cur->parent == node1)\n+            return(1);\n+        depth2++;\n@@ -3392,3 +3392,3 @@\n-    if (cur->parent == node2)\n-        return(-1);\n-    depth1++;\n+        if (cur->parent == node2)\n+            return(-1);\n+        depth1++;\n@@ -3400,1 +3400,1 @@\n-    return(-2);\n+        return(-2);\n@@ -3406,2 +3406,2 @@\n-    depth1--;\n-    node1 = node1->parent;\n+        depth1--;\n+        node1 = node1->parent;\n@@ -3410,2 +3410,2 @@\n-    depth2--;\n-    node2 = node2->parent;\n+        depth2--;\n+        node2 = node2->parent;\n@@ -3414,5 +3414,5 @@\n-    node1 = node1->parent;\n-    node2 = node2->parent;\n-    \/* should not happen but just in case ... *\/\n-    if ((node1 == NULL) || (node2 == NULL))\n-        return(-2);\n+        node1 = node1->parent;\n+        node2 = node2->parent;\n+        \/* should not happen but just in case ... *\/\n+        if ((node1 == NULL) || (node2 == NULL))\n+            return(-2);\n@@ -3424,1 +3424,1 @@\n-    return(1);\n+        return(1);\n@@ -3426,1 +3426,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3431,12 +3431,12 @@\n-    (node2->type == XML_ELEMENT_NODE) &&\n-    (0 > (ptrdiff_t) node1->content) &&\n-    (0 > (ptrdiff_t) node2->content) &&\n-    (node1->doc == node2->doc)) {\n-    ptrdiff_t l1, l2;\n-\n-    l1 = -((ptrdiff_t) node1->content);\n-    l2 = -((ptrdiff_t) node2->content);\n-    if (l1 < l2)\n-        return(1);\n-    if (l1 > l2)\n-        return(-1);\n+        (node2->type == XML_ELEMENT_NODE) &&\n+        (0 > (ptrdiff_t) node1->content) &&\n+        (0 > (ptrdiff_t) node2->content) &&\n+        (node1->doc == node2->doc)) {\n+        ptrdiff_t l1, l2;\n+\n+        l1 = -((ptrdiff_t) node1->content);\n+        l2 = -((ptrdiff_t) node2->content);\n+        if (l1 < l2)\n+            return(1);\n+        if (l1 > l2)\n+            return(-1);\n@@ -3446,2 +3446,2 @@\n-    if (cur == node2)\n-        return(1);\n+        if (cur == node2)\n+            return(1);\n@@ -3465,1 +3465,1 @@\n-    return;\n+        return;\n@@ -3474,3 +3474,3 @@\n-    for (i = incr; i < len; i++) {\n-        j = i - incr;\n-        while (j >= 0) {\n+        for (i = incr; i < len; i++) {\n+            j = i - incr;\n+            while (j >= 0) {\n@@ -3478,2 +3478,2 @@\n-        if (xmlXPathCmpNodesExt(set->nodeTab[j],\n-            set->nodeTab[j + incr]) == -1)\n+                if (xmlXPathCmpNodesExt(set->nodeTab[j],\n+                        set->nodeTab[j + incr]) == -1)\n@@ -3481,2 +3481,2 @@\n-        if (xmlXPathCmpNodes(set->nodeTab[j],\n-            set->nodeTab[j + incr]) == -1)\n+                if (xmlXPathCmpNodes(set->nodeTab[j],\n+                        set->nodeTab[j + incr]) == -1)\n@@ -3484,7 +3484,8 @@\n-        {\n-            tmp = set->nodeTab[j];\n-            set->nodeTab[j] = set->nodeTab[j + incr];\n-            set->nodeTab[j + incr] = tmp;\n-            j -= incr;\n-        } else\n-            break;\n+                {\n+                    tmp = set->nodeTab[j];\n+                    set->nodeTab[j] = set->nodeTab[j + incr];\n+                    set->nodeTab[j + incr] = tmp;\n+                    j -= incr;\n+                } else\n+                    break;\n+            }\n@@ -3493,1 +3494,0 @@\n-    }\n@@ -3499,1 +3499,1 @@\n-#define XML_NODESET_DEFAULT 10\n+#define XML_NODESET_DEFAULT     10\n@@ -3516,1 +3516,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3518,1 +3518,1 @@\n-    return((xmlNodePtr) ns);\n+        return((xmlNodePtr) ns);\n@@ -3526,1 +3526,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3531,1 +3531,1 @@\n-    cur->href = xmlStrdup(ns->href);\n+        cur->href = xmlStrdup(ns->href);\n@@ -3533,1 +3533,1 @@\n-    cur->prefix = xmlStrdup(ns->prefix);\n+        cur->prefix = xmlStrdup(ns->prefix);\n@@ -3549,1 +3549,1 @@\n-    return;\n+        return;\n@@ -3552,5 +3552,5 @@\n-    if (ns->href != NULL)\n-        xmlFree((xmlChar *)ns->href);\n-    if (ns->prefix != NULL)\n-        xmlFree((xmlChar *)ns->prefix);\n-    xmlFree(ns);\n+        if (ns->href != NULL)\n+            xmlFree((xmlChar *)ns->href);\n+        if (ns->prefix != NULL)\n+            xmlFree((xmlChar *)ns->prefix);\n+        xmlFree(ns);\n@@ -3575,1 +3575,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3580,8 +3580,8 @@\n-                         sizeof(xmlNodePtr));\n-    if (ret->nodeTab == NULL) {\n-        xmlXPathErrMemory(NULL, \"creating nodeset\\n\");\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n-    memset(ret->nodeTab, 0 ,\n-           XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n+                                             sizeof(xmlNodePtr));\n+        if (ret->nodeTab == NULL) {\n+            xmlXPathErrMemory(NULL, \"creating nodeset\\n\");\n+            xmlFree(ret);\n+            return(NULL);\n+        }\n+        memset(ret->nodeTab, 0 ,\n+               XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n@@ -3589,2 +3589,2 @@\n-    if (val->type == XML_NAMESPACE_DECL) {\n-        xmlNsPtr ns = (xmlNsPtr) val;\n+        if (val->type == XML_NAMESPACE_DECL) {\n+            xmlNsPtr ns = (xmlNsPtr) val;\n@@ -3593,4 +3593,4 @@\n-        ret->nodeTab[ret->nodeNr++] =\n-        xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n-    } else\n-        ret->nodeTab[ret->nodeNr++] = val;\n+            ret->nodeTab[ret->nodeNr++] =\n+                xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n+        } else\n+            ret->nodeTab[ret->nodeNr++] = val;\n@@ -3616,11 +3616,12 @@\n-    for (i = 0; i < cur->nodeNr; i++) {\n-        if (cur->nodeTab[i]->type == XML_NAMESPACE_DECL) {\n-        xmlNsPtr ns1, ns2;\n-\n-        ns1 = (xmlNsPtr) val;\n-        ns2 = (xmlNsPtr) cur->nodeTab[i];\n-        if (ns1 == ns2)\n-            return(1);\n-        if ((ns1->next != NULL) && (ns2->next == ns1->next) &&\n-                (xmlStrEqual(ns1->prefix, ns2->prefix)))\n-            return(1);\n+        for (i = 0; i < cur->nodeNr; i++) {\n+            if (cur->nodeTab[i]->type == XML_NAMESPACE_DECL) {\n+                xmlNsPtr ns1, ns2;\n+\n+                ns1 = (xmlNsPtr) val;\n+                ns2 = (xmlNsPtr) cur->nodeTab[i];\n+                if (ns1 == ns2)\n+                    return(1);\n+                if ((ns1->next != NULL) && (ns2->next == ns1->next) &&\n+                    (xmlStrEqual(ns1->prefix, ns2->prefix)))\n+                    return(1);\n+            }\n@@ -3628,1 +3629,0 @@\n-    }\n@@ -3630,4 +3630,4 @@\n-    for (i = 0; i < cur->nodeNr; i++) {\n-        if (cur->nodeTab[i] == val)\n-        return(1);\n-    }\n+        for (i = 0; i < cur->nodeNr; i++) {\n+            if (cur->nodeTab[i] == val)\n+                return(1);\n+        }\n@@ -3655,2 +3655,2 @@\n-    (node->type != XML_ELEMENT_NODE))\n-    return(-1);\n+        (node->type != XML_ELEMENT_NODE))\n+        return(-1);\n@@ -3664,4 +3664,4 @@\n-        (cur->nodeTab[i]->type == XML_NAMESPACE_DECL) &&\n-        (((xmlNsPtr)cur->nodeTab[i])->next == (xmlNsPtr) node) &&\n-        (xmlStrEqual(ns->prefix, ((xmlNsPtr)cur->nodeTab[i])->prefix)))\n-        return(0);\n+            (cur->nodeTab[i]->type == XML_NAMESPACE_DECL) &&\n+            (((xmlNsPtr)cur->nodeTab[i])->next == (xmlNsPtr) node) &&\n+            (xmlStrEqual(ns->prefix, ((xmlNsPtr)cur->nodeTab[i])->prefix)))\n+            return(0);\n@@ -3675,7 +3675,7 @@\n-                         sizeof(xmlNodePtr));\n-    if (cur->nodeTab == NULL) {\n-        xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n-        return(-1);\n-    }\n-    memset(cur->nodeTab, 0 ,\n-           XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n+                                             sizeof(xmlNodePtr));\n+        if (cur->nodeTab == NULL) {\n+            xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n+            return(-1);\n+        }\n+        memset(cur->nodeTab, 0 ,\n+               XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n@@ -3690,6 +3690,6 @@\n-    temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *\n-                      sizeof(xmlNodePtr));\n-    if (temp == NULL) {\n-        xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n-        return(-1);\n-    }\n+        temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *\n+                                      sizeof(xmlNodePtr));\n+        if (temp == NULL) {\n+            xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n+            return(-1);\n+        }\n@@ -3697,1 +3697,1 @@\n-    cur->nodeTab = temp;\n+        cur->nodeTab = temp;\n@@ -3731,7 +3731,7 @@\n-                         sizeof(xmlNodePtr));\n-    if (cur->nodeTab == NULL) {\n-        xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n-        return(-1);\n-    }\n-    memset(cur->nodeTab, 0 ,\n-           XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n+                                             sizeof(xmlNodePtr));\n+        if (cur->nodeTab == NULL) {\n+            xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n+            return(-1);\n+        }\n+        memset(cur->nodeTab, 0 ,\n+               XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n@@ -3746,6 +3746,6 @@\n-    temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *\n-                      sizeof(xmlNodePtr));\n-    if (temp == NULL) {\n-        xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n-        return(-1);\n-    }\n+        temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *\n+                                      sizeof(xmlNodePtr));\n+        if (temp == NULL) {\n+            xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n+            return(-1);\n+        }\n@@ -3753,1 +3753,1 @@\n-    cur->nodeTab = temp;\n+        cur->nodeTab = temp;\n@@ -3756,1 +3756,1 @@\n-    xmlNsPtr ns = (xmlNsPtr) val;\n+        xmlNsPtr ns = (xmlNsPtr) val;\n@@ -3759,2 +3759,2 @@\n-    cur->nodeTab[cur->nodeNr++] =\n-        xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n+        cur->nodeTab[cur->nodeNr++] =\n+            xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n@@ -3762,1 +3762,1 @@\n-    cur->nodeTab[cur->nodeNr++] = val;\n+        cur->nodeTab[cur->nodeNr++] = val;\n@@ -3786,7 +3786,7 @@\n-                         sizeof(xmlNodePtr));\n-    if (cur->nodeTab == NULL) {\n-        xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n-        return(-1);\n-    }\n-    memset(cur->nodeTab, 0 ,\n-           XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n+                                             sizeof(xmlNodePtr));\n+        if (cur->nodeTab == NULL) {\n+            xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n+            return(-1);\n+        }\n+        memset(cur->nodeTab, 0 ,\n+               XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n@@ -3801,7 +3801,7 @@\n-    temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *\n-                      sizeof(xmlNodePtr));\n-    if (temp == NULL) {\n-        xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n-        return(-1);\n-    }\n-    cur->nodeTab = temp;\n+        temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *\n+                                      sizeof(xmlNodePtr));\n+        if (temp == NULL) {\n+            xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n+            return(-1);\n+        }\n+        cur->nodeTab = temp;\n@@ -3811,1 +3811,1 @@\n-    xmlNsPtr ns = (xmlNsPtr) val;\n+        xmlNsPtr ns = (xmlNsPtr) val;\n@@ -3814,2 +3814,2 @@\n-    cur->nodeTab[cur->nodeNr++] =\n-        xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n+        cur->nodeTab[cur->nodeNr++] =\n+            xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n@@ -3817,1 +3817,1 @@\n-    cur->nodeTab[cur->nodeNr++] = val;\n+        cur->nodeTab[cur->nodeNr++] = val;\n@@ -3838,1 +3838,1 @@\n-    val1 = xmlXPathNodeSetCreate(NULL);\n+        val1 = xmlXPathNodeSetCreate(NULL);\n@@ -3842,27 +3842,27 @@\n-    \/*\n-    * TODO: The optimization won't work in every case, since\n-    *  those nasty namespace nodes need to be added with\n-    *  xmlXPathNodeSetDupNs() to the set; thus a pure\n-    *  memcpy is not possible.\n-    *  If there was a flag on the nodesetval, indicating that\n-    *  some temporary nodes are in, that would be helpful.\n-    *\/\n-    \/*\n-    * Optimization: Create an equally sized node-set\n-    * and memcpy the content.\n-    *\/\n-    val1 = xmlXPathNodeSetCreateSize(val2->nodeNr);\n-    if (val1 == NULL)\n-        return(NULL);\n-    if (val2->nodeNr != 0) {\n-        if (val2->nodeNr == 1)\n-        *(val1->nodeTab) = *(val2->nodeTab);\n-        else {\n-        memcpy(val1->nodeTab, val2->nodeTab,\n-            val2->nodeNr * sizeof(xmlNodePtr));\n-        }\n-        val1->nodeNr = val2->nodeNr;\n-    }\n-    return(val1);\n-#endif\n-    }\n+        \/*\n+        * TODO: The optimization won't work in every case, since\n+        *  those nasty namespace nodes need to be added with\n+        *  xmlXPathNodeSetDupNs() to the set; thus a pure\n+        *  memcpy is not possible.\n+        *  If there was a flag on the nodesetval, indicating that\n+        *  some temporary nodes are in, that would be helpful.\n+        *\/\n+        \/*\n+        * Optimization: Create an equally sized node-set\n+        * and memcpy the content.\n+        *\/\n+        val1 = xmlXPathNodeSetCreateSize(val2->nodeNr);\n+        if (val1 == NULL)\n+            return(NULL);\n+        if (val2->nodeNr != 0) {\n+            if (val2->nodeNr == 1)\n+                *(val1->nodeTab) = *(val2->nodeTab);\n+            else {\n+                memcpy(val1->nodeTab, val2->nodeTab,\n+                    val2->nodeNr * sizeof(xmlNodePtr));\n+            }\n+            val1->nodeNr = val2->nodeNr;\n+        }\n+        return(val1);\n+#endif\n+    }\n@@ -3874,19 +3874,20 @@\n-    n2 = val2->nodeTab[i];\n-    \/*\n-     * check against duplicates\n-     *\/\n-    skip = 0;\n-    for (j = 0; j < initNr; j++) {\n-        n1 = val1->nodeTab[j];\n-        if (n1 == n2) {\n-        skip = 1;\n-        break;\n-        } else if ((n1->type == XML_NAMESPACE_DECL) &&\n-               (n2->type == XML_NAMESPACE_DECL)) {\n-        if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&\n-            (xmlStrEqual(((xmlNsPtr) n1)->prefix,\n-            ((xmlNsPtr) n2)->prefix)))\n-        {\n-            skip = 1;\n-            break;\n-        }\n+        n2 = val2->nodeTab[i];\n+        \/*\n+         * check against duplicates\n+         *\/\n+        skip = 0;\n+        for (j = 0; j < initNr; j++) {\n+            n1 = val1->nodeTab[j];\n+            if (n1 == n2) {\n+                skip = 1;\n+                break;\n+            } else if ((n1->type == XML_NAMESPACE_DECL) &&\n+                       (n2->type == XML_NAMESPACE_DECL)) {\n+                if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&\n+                    (xmlStrEqual(((xmlNsPtr) n1)->prefix,\n+                        ((xmlNsPtr) n2)->prefix)))\n+                {\n+                    skip = 1;\n+                    break;\n+                }\n+            }\n@@ -3894,3 +3895,2 @@\n-    }\n-    if (skip)\n-        continue;\n+        if (skip)\n+            continue;\n@@ -3898,15 +3898,15 @@\n-    \/*\n-     * grow the nodeTab if needed\n-     *\/\n-    if (val1->nodeMax == 0) {\n-        val1->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n-                            sizeof(xmlNodePtr));\n-        if (val1->nodeTab == NULL) {\n-            xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n-        return(NULL);\n-        }\n-        memset(val1->nodeTab, 0 ,\n-           XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n-        val1->nodeMax = XML_NODESET_DEFAULT;\n-    } else if (val1->nodeNr == val1->nodeMax) {\n-        xmlNodePtr *temp;\n+        \/*\n+         * grow the nodeTab if needed\n+         *\/\n+        if (val1->nodeMax == 0) {\n+            val1->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n+                                                    sizeof(xmlNodePtr));\n+            if (val1->nodeTab == NULL) {\n+                xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n+                return(NULL);\n+            }\n+            memset(val1->nodeTab, 0 ,\n+                   XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n+            val1->nodeMax = XML_NODESET_DEFAULT;\n+        } else if (val1->nodeNr == val1->nodeMax) {\n+            xmlNodePtr *temp;\n@@ -3918,5 +3918,8 @@\n-        temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax * 2 *\n-                         sizeof(xmlNodePtr));\n-        if (temp == NULL) {\n-            xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n-        return(NULL);\n+            temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax * 2 *\n+                                             sizeof(xmlNodePtr));\n+            if (temp == NULL) {\n+                xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n+                return(NULL);\n+            }\n+            val1->nodeTab = temp;\n+            val1->nodeMax *= 2;\n@@ -3924,5 +3927,2 @@\n-        val1->nodeTab = temp;\n-        val1->nodeMax *= 2;\n-    }\n-    if (n2->type == XML_NAMESPACE_DECL) {\n-        xmlNsPtr ns = (xmlNsPtr) n2;\n+        if (n2->type == XML_NAMESPACE_DECL) {\n+            xmlNsPtr ns = (xmlNsPtr) n2;\n@@ -3931,4 +3931,4 @@\n-        val1->nodeTab[val1->nodeNr++] =\n-        xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n-    } else\n-        val1->nodeTab[val1->nodeNr++] = n2;\n+            val1->nodeTab[val1->nodeNr++] =\n+                xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n+        } else\n+            val1->nodeTab[val1->nodeNr++] = n2;\n@@ -3955,2 +3955,2 @@\n-    int i, j, initNbSet1;\n-    xmlNodePtr n1, n2;\n+        int i, j, initNbSet1;\n+        xmlNodePtr n1, n2;\n@@ -3958,17 +3958,3 @@\n-    initNbSet1 = set1->nodeNr;\n-    for (i = 0;i < set2->nodeNr;i++) {\n-        n2 = set2->nodeTab[i];\n-        \/*\n-        * Skip duplicates.\n-        *\/\n-        for (j = 0; j < initNbSet1; j++) {\n-        n1 = set1->nodeTab[j];\n-        if (n1 == n2) {\n-            goto skip_node;\n-        } else if ((n1->type == XML_NAMESPACE_DECL) &&\n-            (n2->type == XML_NAMESPACE_DECL))\n-        {\n-            if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&\n-            (xmlStrEqual(((xmlNsPtr) n1)->prefix,\n-            ((xmlNsPtr) n2)->prefix)))\n-            {\n+        initNbSet1 = set1->nodeNr;\n+        for (i = 0;i < set2->nodeNr;i++) {\n+            n2 = set2->nodeTab[i];\n@@ -3976,1 +3962,1 @@\n-            * Free the namespace node.\n+            * Skip duplicates.\n@@ -3978,3 +3964,19 @@\n-            set2->nodeTab[i] = NULL;\n-            xmlXPathNodeSetFreeNs((xmlNsPtr) n2);\n-            goto skip_node;\n+            for (j = 0; j < initNbSet1; j++) {\n+                n1 = set1->nodeTab[j];\n+                if (n1 == n2) {\n+                    goto skip_node;\n+                } else if ((n1->type == XML_NAMESPACE_DECL) &&\n+                    (n2->type == XML_NAMESPACE_DECL))\n+                {\n+                    if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&\n+                        (xmlStrEqual(((xmlNsPtr) n1)->prefix,\n+                        ((xmlNsPtr) n2)->prefix)))\n+                    {\n+                        \/*\n+                        * Free the namespace node.\n+                        *\/\n+                        set2->nodeTab[i] = NULL;\n+                        xmlXPathNodeSetFreeNs((xmlNsPtr) n2);\n+                        goto skip_node;\n+                    }\n+                }\n@@ -3982,17 +3984,15 @@\n-        }\n-        }\n-        \/*\n-        * grow the nodeTab if needed\n-        *\/\n-        if (set1->nodeMax == 0) {\n-        set1->nodeTab = (xmlNodePtr *) xmlMalloc(\n-            XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n-        if (set1->nodeTab == NULL) {\n-            xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n-            return(NULL);\n-        }\n-        memset(set1->nodeTab, 0,\n-            XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n-        set1->nodeMax = XML_NODESET_DEFAULT;\n-        } else if (set1->nodeNr >= set1->nodeMax) {\n-        xmlNodePtr *temp;\n+            \/*\n+            * grow the nodeTab if needed\n+            *\/\n+            if (set1->nodeMax == 0) {\n+                set1->nodeTab = (xmlNodePtr *) xmlMalloc(\n+                    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n+                if (set1->nodeTab == NULL) {\n+                    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n+                    return(NULL);\n+                }\n+                memset(set1->nodeTab, 0,\n+                    XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n+                set1->nodeMax = XML_NODESET_DEFAULT;\n+            } else if (set1->nodeNr >= set1->nodeMax) {\n+                xmlNodePtr *temp;\n@@ -4004,10 +4004,10 @@\n-        temp = (xmlNodePtr *) xmlRealloc(\n-            set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));\n-        if (temp == NULL) {\n-            xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n-            return(NULL);\n-        }\n-        set1->nodeTab = temp;\n-        set1->nodeMax *= 2;\n-        }\n-        set1->nodeTab[set1->nodeNr++] = n2;\n+                temp = (xmlNodePtr *) xmlRealloc(\n+                    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));\n+                if (temp == NULL) {\n+                    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n+                    return(NULL);\n+                }\n+                set1->nodeTab = temp;\n+                set1->nodeMax *= 2;\n+            }\n+            set1->nodeTab[set1->nodeNr++] = n2;\n@@ -4015,2 +4015,2 @@\n-        {}\n-    }\n+            {}\n+        }\n@@ -4036,17 +4036,17 @@\n-    int i;\n-    xmlNodePtr n2;\n-\n-    for (i = 0;i < set2->nodeNr;i++) {\n-        n2 = set2->nodeTab[i];\n-        if (set1->nodeMax == 0) {\n-        set1->nodeTab = (xmlNodePtr *) xmlMalloc(\n-            XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n-        if (set1->nodeTab == NULL) {\n-            xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n-            return(NULL);\n-        }\n-        memset(set1->nodeTab, 0,\n-            XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n-        set1->nodeMax = XML_NODESET_DEFAULT;\n-        } else if (set1->nodeNr >= set1->nodeMax) {\n-        xmlNodePtr *temp;\n+        int i;\n+        xmlNodePtr n2;\n+\n+        for (i = 0;i < set2->nodeNr;i++) {\n+            n2 = set2->nodeTab[i];\n+            if (set1->nodeMax == 0) {\n+                set1->nodeTab = (xmlNodePtr *) xmlMalloc(\n+                    XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n+                if (set1->nodeTab == NULL) {\n+                    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n+                    return(NULL);\n+                }\n+                memset(set1->nodeTab, 0,\n+                    XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n+                set1->nodeMax = XML_NODESET_DEFAULT;\n+            } else if (set1->nodeNr >= set1->nodeMax) {\n+                xmlNodePtr *temp;\n@@ -4058,8 +4058,10 @@\n-        temp = (xmlNodePtr *) xmlRealloc(\n-            set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));\n-        if (temp == NULL) {\n-            xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n-            return(NULL);\n-        }\n-        set1->nodeTab = temp;\n-        set1->nodeMax *= 2;\n+                temp = (xmlNodePtr *) xmlRealloc(\n+                    set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));\n+                if (temp == NULL) {\n+                    xmlXPathErrMemory(NULL, \"merging nodeset\\n\");\n+                    return(NULL);\n+                }\n+                set1->nodeTab = temp;\n+                set1->nodeMax *= 2;\n+            }\n+            set1->nodeTab[set1->nodeNr++] = n2;\n@@ -4067,2 +4069,0 @@\n-        set1->nodeTab[set1->nodeNr++] = n2;\n-    }\n@@ -4094,1 +4094,1 @@\n-    if (i >= cur->nodeNr) { \/* not found *\/\n+    if (i >= cur->nodeNr) {     \/* not found *\/\n@@ -4097,2 +4097,2 @@\n-            \"xmlXPathNodeSetDel: Node %s wasn't found in NodeList\\n\",\n-        val->name);\n+                \"xmlXPathNodeSetDel: Node %s wasn't found in NodeList\\n\",\n+                val->name);\n@@ -4103,2 +4103,2 @@\n-    (cur->nodeTab[i]->type == XML_NAMESPACE_DECL))\n-    xmlXPathNodeSetFreeNs((xmlNsPtr) cur->nodeTab[i]);\n+        (cur->nodeTab[i]->type == XML_NAMESPACE_DECL))\n+        xmlXPathNodeSetFreeNs((xmlNsPtr) cur->nodeTab[i]);\n@@ -4123,2 +4123,2 @@\n-    (cur->nodeTab[val]->type == XML_NAMESPACE_DECL))\n-    xmlXPathNodeSetFreeNs((xmlNsPtr) cur->nodeTab[val]);\n+        (cur->nodeTab[val]->type == XML_NAMESPACE_DECL))\n+        xmlXPathNodeSetFreeNs((xmlNsPtr) cur->nodeTab[val]);\n@@ -4141,1 +4141,1 @@\n-    int i;\n+        int i;\n@@ -4143,6 +4143,6 @@\n-    \/* @@ with_ns to check whether namespace nodes should be looked at @@ *\/\n-    for (i = 0;i < obj->nodeNr;i++)\n-        if ((obj->nodeTab[i] != NULL) &&\n-        (obj->nodeTab[i]->type == XML_NAMESPACE_DECL))\n-        xmlXPathNodeSetFreeNs((xmlNsPtr) obj->nodeTab[i]);\n-    xmlFree(obj->nodeTab);\n+        \/* @@ with_ns to check whether namespace nodes should be looked at @@ *\/\n+        for (i = 0;i < obj->nodeNr;i++)\n+            if ((obj->nodeTab[i] != NULL) &&\n+                (obj->nodeTab[i]->type == XML_NAMESPACE_DECL))\n+                xmlXPathNodeSetFreeNs((xmlNsPtr) obj->nodeTab[i]);\n+        xmlFree(obj->nodeTab);\n@@ -4166,1 +4166,1 @@\n-    return;\n+        return;\n@@ -4168,2 +4168,2 @@\n-    int i;\n-    xmlNodePtr node;\n+        int i;\n+        xmlNodePtr node;\n@@ -4171,6 +4171,6 @@\n-    for (i = pos; i < set->nodeNr; i++) {\n-        node = set->nodeTab[i];\n-        if ((node != NULL) &&\n-        (node->type == XML_NAMESPACE_DECL))\n-        xmlXPathNodeSetFreeNs((xmlNsPtr) node);\n-    }\n+        for (i = pos; i < set->nodeNr; i++) {\n+            node = set->nodeTab[i];\n+            if ((node != NULL) &&\n+                (node->type == XML_NAMESPACE_DECL))\n+                xmlXPathNodeSetFreeNs((xmlNsPtr) node);\n+        }\n@@ -4210,1 +4210,1 @@\n-    return;\n+        return;\n@@ -4235,7 +4235,8 @@\n-    for (i = 0;i < obj->nodeNr;i++) {\n-        if (obj->nodeTab[i] != NULL) {\n-        if (obj->nodeTab[i]->type == XML_NAMESPACE_DECL) {\n-            xmlXPathNodeSetFreeNs((xmlNsPtr) obj->nodeTab[i]);\n-        } else {\n-            xmlFreeNodeList(obj->nodeTab[i]);\n-        }\n+        for (i = 0;i < obj->nodeNr;i++) {\n+            if (obj->nodeTab[i] != NULL) {\n+                if (obj->nodeTab[i]->type == XML_NAMESPACE_DECL) {\n+                    xmlXPathNodeSetFreeNs((xmlNsPtr) obj->nodeTab[i]);\n+                } else {\n+                    xmlFreeNodeList(obj->nodeTab[i]);\n+                }\n+            }\n@@ -4243,2 +4244,1 @@\n-    }\n-    xmlFree(obj->nodeTab);\n+        xmlFree(obj->nodeTab);\n@@ -4264,1 +4264,1 @@\n-    return;\n+        return;\n@@ -4268,1 +4268,1 @@\n-    return;\n+        return;\n@@ -4271,2 +4271,2 @@\n-    fprintf(output, \" nodeTab == NULL !\\n\");\n-    return;\n+        fprintf(output, \" nodeTab == NULL !\\n\");\n+        return;\n@@ -4276,2 +4276,2 @@\n-        fprintf(output, \" NULL !\\n\");\n-        return;\n+            fprintf(output, \" NULL !\\n\");\n+            return;\n@@ -4279,6 +4279,6 @@\n-    if ((obj->nodeTab[i]->type == XML_DOCUMENT_NODE) ||\n-        (obj->nodeTab[i]->type == XML_HTML_DOCUMENT_NODE))\n-        fprintf(output, \" \/\");\n-    else if (obj->nodeTab[i]->name == NULL)\n-        fprintf(output, \" noname!\");\n-    else fprintf(output, \" %s\", obj->nodeTab[i]->name);\n+        if ((obj->nodeTab[i]->type == XML_DOCUMENT_NODE) ||\n+            (obj->nodeTab[i]->type == XML_HTML_DOCUMENT_NODE))\n+            fprintf(output, \" \/\");\n+        else if (obj->nodeTab[i]->name == NULL)\n+            fprintf(output, \" noname!\");\n+        else fprintf(output, \" %s\", obj->nodeTab[i]->name);\n@@ -4306,1 +4306,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4336,1 +4336,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4374,1 +4374,2 @@\n-            < 0) break;\n+                    < 0) break;\n+            }\n@@ -4377,1 +4378,0 @@\n-    }\n@@ -4397,1 +4397,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4442,1 +4442,1 @@\n-    return(nodes1);\n+        return(nodes1);\n@@ -4447,1 +4447,1 @@\n-    return(ret);\n+        return(ret);\n@@ -4452,2 +4452,2 @@\n-    cur = xmlXPathNodeSetItem(nodes1, i);\n-    if (!xmlXPathNodeSetContains(nodes2, cur)) {\n+        cur = xmlXPathNodeSetItem(nodes1, i);\n+        if (!xmlXPathNodeSetContains(nodes2, cur)) {\n@@ -4455,3 +4455,3 @@\n-        if (xmlXPathNodeSetAddUnique(ret, cur) < 0)\n-            break;\n-    }\n+            if (xmlXPathNodeSetAddUnique(ret, cur) < 0)\n+                break;\n+        }\n@@ -4482,1 +4482,1 @@\n-    return(ret);\n+        return(ret);\n@@ -4484,1 +4484,1 @@\n-    return(ret);\n+        return(ret);\n@@ -4489,2 +4489,2 @@\n-    cur = xmlXPathNodeSetItem(nodes1, i);\n-    if (xmlXPathNodeSetContains(nodes2, cur)) {\n+        cur = xmlXPathNodeSetItem(nodes1, i);\n+        if (xmlXPathNodeSetContains(nodes2, cur)) {\n@@ -4492,3 +4492,3 @@\n-        if (xmlXPathNodeSetAddUnique(ret, cur) < 0)\n-            break;\n-    }\n+            if (xmlXPathNodeSetAddUnique(ret, cur) < 0)\n+                break;\n+        }\n@@ -4518,1 +4518,1 @@\n-    return(nodes);\n+        return(nodes);\n@@ -4526,4 +4526,4 @@\n-    cur = xmlXPathNodeSetItem(nodes, i);\n-    strval = xmlXPathCastNodeToString(cur);\n-    if (xmlHashLookup(hash, strval) == NULL) {\n-        xmlHashAddEntry(hash, strval, strval);\n+        cur = xmlXPathNodeSetItem(nodes, i);\n+        strval = xmlXPathCastNodeToString(cur);\n+        if (xmlHashLookup(hash, strval) == NULL) {\n+            xmlHashAddEntry(hash, strval, strval);\n@@ -4531,5 +4531,5 @@\n-        if (xmlXPathNodeSetAddUnique(ret, cur) < 0)\n-            break;\n-    } else {\n-        xmlFree(strval);\n-    }\n+            if (xmlXPathNodeSetAddUnique(ret, cur) < 0)\n+                break;\n+        } else {\n+            xmlFree(strval);\n+        }\n@@ -4556,1 +4556,1 @@\n-    return(nodes);\n+        return(nodes);\n@@ -4579,2 +4579,2 @@\n-    xmlXPathNodeSetIsEmpty(nodes2))\n-    return(0);\n+        xmlXPathNodeSetIsEmpty(nodes2))\n+        return(0);\n@@ -4584,3 +4584,3 @@\n-    cur = xmlXPathNodeSetItem(nodes1, i);\n-    if (xmlXPathNodeSetContains(nodes2, cur))\n-        return(1);\n+        cur = xmlXPathNodeSetItem(nodes1, i);\n+        if (xmlXPathNodeSetContains(nodes2, cur))\n+            return(1);\n@@ -4610,1 +4610,1 @@\n-    return(nodes);\n+        return(nodes);\n@@ -4616,2 +4616,2 @@\n-    (!xmlXPathNodeSetContains(nodes, node)))\n-    return(ret);\n+        (!xmlXPathNodeSetContains(nodes, node)))\n+        return(ret);\n@@ -4621,3 +4621,3 @@\n-    cur = xmlXPathNodeSetItem(nodes, i);\n-    if (cur == node)\n-        break;\n+        cur = xmlXPathNodeSetItem(nodes, i);\n+        if (cur == node)\n+            break;\n@@ -4625,2 +4625,2 @@\n-    if (xmlXPathNodeSetAddUnique(ret, cur) < 0)\n-        break;\n+        if (xmlXPathNodeSetAddUnique(ret, cur) < 0)\n+            break;\n@@ -4666,1 +4666,1 @@\n-    return(nodes1);\n+        return(nodes1);\n@@ -4668,1 +4668,1 @@\n-                     xmlXPathNodeSetItem(nodes2, 1)));\n+                                     xmlXPathNodeSetItem(nodes2, 1)));\n@@ -4688,1 +4688,1 @@\n-    return(nodes1);\n+        return(nodes1);\n@@ -4690,1 +4690,1 @@\n-    return(xmlXPathNodeSetCreate(NULL));\n+        return(xmlXPathNodeSetCreate(NULL));\n@@ -4694,1 +4694,1 @@\n-                     xmlXPathNodeSetItem(nodes2, 1)));\n+                                     xmlXPathNodeSetItem(nodes2, 1)));\n@@ -4716,1 +4716,1 @@\n-    return(nodes);\n+        return(nodes);\n@@ -4722,2 +4722,2 @@\n-    (!xmlXPathNodeSetContains(nodes, node)))\n-    return(ret);\n+        (!xmlXPathNodeSetContains(nodes, node)))\n+        return(ret);\n@@ -4727,3 +4727,3 @@\n-    cur = xmlXPathNodeSetItem(nodes, i);\n-    if (cur == node)\n-        break;\n+        cur = xmlXPathNodeSetItem(nodes, i);\n+        if (cur == node)\n+            break;\n@@ -4731,2 +4731,2 @@\n-    if (xmlXPathNodeSetAddUnique(ret, cur) < 0)\n-        break;\n+        if (xmlXPathNodeSetAddUnique(ret, cur) < 0)\n+            break;\n@@ -4773,1 +4773,1 @@\n-    return(nodes1);\n+        return(nodes1);\n@@ -4775,1 +4775,1 @@\n-                      xmlXPathNodeSetItem(nodes2, 0)));\n+                                      xmlXPathNodeSetItem(nodes2, 0)));\n@@ -4795,1 +4795,1 @@\n-    return(nodes1);\n+        return(nodes1);\n@@ -4797,1 +4797,1 @@\n-    return(xmlXPathNodeSetCreate(NULL));\n+        return(xmlXPathNodeSetCreate(NULL));\n@@ -4801,1 +4801,1 @@\n-                      xmlXPathNodeSetItem(nodes2, 0)));\n+                                      xmlXPathNodeSetItem(nodes2, 0)));\n@@ -4805,3 +4805,3 @@\n- *                                  *\n- *      Routines to handle extra functions          *\n- *                                  *\n+ *                                                                      *\n+ *              Routines to handle extra functions                      *\n+ *                                                                      *\n@@ -4822,1 +4822,1 @@\n-             xmlXPathFunction f) {\n+                     xmlXPathFunction f) {\n@@ -4839,1 +4839,1 @@\n-               const xmlChar *ns_uri, xmlXPathFunction f) {\n+                       const xmlChar *ns_uri, xmlXPathFunction f) {\n@@ -4841,1 +4841,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4843,1 +4843,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4846,1 +4846,1 @@\n-    ctxt->funcHash = xmlHashCreate(0);\n+        ctxt->funcHash = xmlHashCreate(0);\n@@ -4848,1 +4848,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4866,2 +4866,2 @@\n-                xmlXPathFuncLookupFunc f,\n-                void *funcCtxt) {\n+                            xmlXPathFuncLookupFunc f,\n+                            void *funcCtxt) {\n@@ -4869,1 +4869,1 @@\n-    return;\n+        return;\n@@ -4887,1 +4887,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -4890,2 +4890,2 @@\n-    xmlXPathFunction ret;\n-    xmlXPathFuncLookupFunc f;\n+        xmlXPathFunction ret;\n+        xmlXPathFuncLookupFunc f;\n@@ -4893,4 +4893,4 @@\n-    f = ctxt->funcLookupFunc;\n-    ret = f(ctxt->funcLookupData, name, NULL);\n-    if (ret != NULL)\n-        return(ret);\n+        f = ctxt->funcLookupFunc;\n+        ret = f(ctxt->funcLookupData, name, NULL);\n+        if (ret != NULL)\n+            return(ret);\n@@ -4914,1 +4914,1 @@\n-             const xmlChar *ns_uri) {\n+                         const xmlChar *ns_uri) {\n@@ -4918,1 +4918,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4920,1 +4920,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4923,1 +4923,1 @@\n-    xmlXPathFuncLookupFunc f;\n+        xmlXPathFuncLookupFunc f;\n@@ -4925,4 +4925,4 @@\n-    f = ctxt->funcLookupFunc;\n-    ret = f(ctxt->funcLookupData, name, ns_uri);\n-    if (ret != NULL)\n-        return(ret);\n+        f = ctxt->funcLookupFunc;\n+        ret = f(ctxt->funcLookupData, name, ns_uri);\n+        if (ret != NULL)\n+            return(ret);\n@@ -4932,1 +4932,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4949,1 +4949,1 @@\n-    return;\n+        return;\n@@ -4956,3 +4956,3 @@\n- *                                  *\n- *          Routines to handle Variables            *\n- *                                  *\n+ *                                                                      *\n+ *                      Routines to handle Variables                    *\n+ *                                                                      *\n@@ -4974,1 +4974,1 @@\n-             xmlXPathObjectPtr value) {\n+                         xmlXPathObjectPtr value) {\n@@ -4992,2 +4992,2 @@\n-               const xmlChar *ns_uri,\n-               xmlXPathObjectPtr value) {\n+                           const xmlChar *ns_uri,\n+                           xmlXPathObjectPtr value) {\n@@ -4995,1 +4995,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4997,1 +4997,1 @@\n-    return(-1);\n+        return(-1);\n@@ -5000,1 +5000,1 @@\n-    ctxt->varHash = xmlHashCreate(0);\n+        ctxt->varHash = xmlHashCreate(0);\n@@ -5002,1 +5002,1 @@\n-    return(-1);\n+        return(-1);\n@@ -5005,1 +5005,1 @@\n-                               xmlXPathFreeObjectEntry));\n+                                   xmlXPathFreeObjectEntry));\n@@ -5007,1 +5007,1 @@\n-                   (void *) value, xmlXPathFreeObjectEntry));\n+                               (void *) value, xmlXPathFreeObjectEntry));\n@@ -5020,1 +5020,1 @@\n-     xmlXPathVariableLookupFunc f, void *data) {\n+         xmlXPathVariableLookupFunc f, void *data) {\n@@ -5022,1 +5022,1 @@\n-    return;\n+        return;\n@@ -5040,1 +5040,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5043,1 +5043,1 @@\n-    xmlXPathObjectPtr ret;\n+        xmlXPathObjectPtr ret;\n@@ -5045,3 +5045,3 @@\n-    ret = ((xmlXPathVariableLookupFunc)ctxt->varLookupFunc)\n-            (ctxt->varLookupData, name, NULL);\n-    return(ret);\n+        ret = ((xmlXPathVariableLookupFunc)ctxt->varLookupFunc)\n+                (ctxt->varLookupData, name, NULL);\n+        return(ret);\n@@ -5065,1 +5065,1 @@\n-             const xmlChar *ns_uri) {\n+                         const xmlChar *ns_uri) {\n@@ -5067,1 +5067,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5070,1 +5070,1 @@\n-    xmlXPathObjectPtr ret;\n+        xmlXPathObjectPtr ret;\n@@ -5072,3 +5072,3 @@\n-    ret = ((xmlXPathVariableLookupFunc)ctxt->varLookupFunc)\n-            (ctxt->varLookupData, name, ns_uri);\n-    if (ret != NULL) return(ret);\n+        ret = ((xmlXPathVariableLookupFunc)ctxt->varLookupFunc)\n+                (ctxt->varLookupData, name, ns_uri);\n+        if (ret != NULL) return(ret);\n@@ -5078,1 +5078,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5080,1 +5080,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5083,1 +5083,1 @@\n-        xmlHashLookup2(ctxt->varHash, name, ns_uri)));\n+                xmlHashLookup2(ctxt->varHash, name, ns_uri)));\n@@ -5095,1 +5095,1 @@\n-    return;\n+        return;\n@@ -5114,1 +5114,1 @@\n-               const xmlChar *ns_uri) {\n+                           const xmlChar *ns_uri) {\n@@ -5116,1 +5116,1 @@\n-    return(-1);\n+        return(-1);\n@@ -5118,1 +5118,1 @@\n-    return(-1);\n+        return(-1);\n@@ -5120,1 +5120,1 @@\n-    return(-1);\n+        return(-1);\n@@ -5123,1 +5123,1 @@\n-    ctxt->nsHash = xmlHashCreate(10);\n+        ctxt->nsHash = xmlHashCreate(10);\n@@ -5125,1 +5125,1 @@\n-    return(-1);\n+        return(-1);\n@@ -5128,1 +5128,1 @@\n-                              xmlHashDefaultDeallocator));\n+                                  xmlHashDefaultDeallocator));\n@@ -5130,1 +5130,1 @@\n-                  xmlHashDefaultDeallocator));\n+                              xmlHashDefaultDeallocator));\n@@ -5146,1 +5146,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5148,1 +5148,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5152,1 +5152,1 @@\n-    return(XML_XML_NAMESPACE);\n+        return(XML_XML_NAMESPACE);\n@@ -5156,1 +5156,1 @@\n-    int i;\n+        int i;\n@@ -5158,5 +5158,5 @@\n-    for (i = 0;i < ctxt->nsNr;i++) {\n-        if ((ctxt->namespaces[i] != NULL) &&\n-        (xmlStrEqual(ctxt->namespaces[i]->prefix, prefix)))\n-        return(ctxt->namespaces[i]->href);\n-    }\n+        for (i = 0;i < ctxt->nsNr;i++) {\n+            if ((ctxt->namespaces[i] != NULL) &&\n+                (xmlStrEqual(ctxt->namespaces[i]->prefix, prefix)))\n+                return(ctxt->namespaces[i]->href);\n+        }\n@@ -5177,1 +5177,1 @@\n-    return;\n+        return;\n@@ -5184,3 +5184,3 @@\n- *                                  *\n- *          Routines to handle Values           *\n- *                                  *\n+ *                                                                      *\n+ *                      Routines to handle Values                       *\n+ *                                                                      *\n@@ -5206,1 +5206,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5232,1 +5232,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5258,1 +5258,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5263,1 +5263,1 @@\n-    ret->stringval = xmlStrdup(val);\n+        ret->stringval = xmlStrdup(val);\n@@ -5265,1 +5265,1 @@\n-    ret->stringval = xmlStrdup((const xmlChar *)\"\");\n+        ret->stringval = xmlStrdup((const xmlChar *)\"\");\n@@ -5287,1 +5287,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5313,1 +5313,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5352,1 +5352,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5376,1 +5376,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5381,1 +5381,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5388,9 +5388,9 @@\n-    case XPATH_BOOLEAN:\n-    case XPATH_NUMBER:\n-    case XPATH_POINT:\n-    case XPATH_RANGE:\n-        break;\n-    case XPATH_STRING:\n-        ret->stringval = xmlStrdup(val->stringval);\n-        break;\n-    case XPATH_XSLT_TREE:\n+        case XPATH_BOOLEAN:\n+        case XPATH_NUMBER:\n+        case XPATH_POINT:\n+        case XPATH_RANGE:\n+            break;\n+        case XPATH_STRING:\n+            ret->stringval = xmlStrdup(val->stringval);\n+            break;\n+        case XPATH_XSLT_TREE:\n@@ -5403,19 +5403,19 @@\n-        if ((val->nodesetval != NULL) &&\n-        (val->nodesetval->nodeTab != NULL)) {\n-        xmlNodePtr cur, tmp;\n-        xmlDocPtr top;\n-\n-        ret->boolval = 1;\n-        top =  xmlNewDoc(NULL);\n-        top->name = (char *)\n-            xmlStrdup(val->nodesetval->nodeTab[0]->name);\n-        ret->user = top;\n-        if (top != NULL) {\n-            top->doc = top;\n-            cur = val->nodesetval->nodeTab[0]->children;\n-            while (cur != NULL) {\n-            tmp = xmlDocCopyNode(cur, top, 1);\n-            xmlAddChild((xmlNodePtr) top, tmp);\n-            cur = cur->next;\n-            }\n-        }\n+            if ((val->nodesetval != NULL) &&\n+                (val->nodesetval->nodeTab != NULL)) {\n+                xmlNodePtr cur, tmp;\n+                xmlDocPtr top;\n+\n+                ret->boolval = 1;\n+                top =  xmlNewDoc(NULL);\n+                top->name = (char *)\n+                    xmlStrdup(val->nodesetval->nodeTab[0]->name);\n+                ret->user = top;\n+                if (top != NULL) {\n+                    top->doc = top;\n+                    cur = val->nodesetval->nodeTab[0]->children;\n+                    while (cur != NULL) {\n+                        tmp = xmlDocCopyNode(cur, top, 1);\n+                        xmlAddChild((xmlNodePtr) top, tmp);\n+                        cur = cur->next;\n+                    }\n+                }\n@@ -5423,5 +5423,5 @@\n-        ret->nodesetval = xmlXPathNodeSetCreate((xmlNodePtr) top);\n-        } else\n-        ret->nodesetval = xmlXPathNodeSetCreate(NULL);\n-        \/* Deallocate the copied tree value *\/\n-        break;\n+                ret->nodesetval = xmlXPathNodeSetCreate((xmlNodePtr) top);\n+            } else\n+                ret->nodesetval = xmlXPathNodeSetCreate(NULL);\n+            \/* Deallocate the copied tree value *\/\n+            break;\n@@ -5429,1 +5429,1 @@\n-    case XPATH_NODESET:\n+        case XPATH_NODESET:\n@@ -5431,5 +5431,5 @@\n-        ret->nodesetval = xmlXPathNodeSetMerge(NULL, val->nodesetval);\n-        \/* Do not deallocate the copied tree value *\/\n-        ret->boolval = 0;\n-        break;\n-    case XPATH_LOCATIONSET:\n+            ret->nodesetval = xmlXPathNodeSetMerge(NULL, val->nodesetval);\n+            \/* Do not deallocate the copied tree value *\/\n+            ret->boolval = 0;\n+            break;\n+        case XPATH_LOCATIONSET:\n@@ -5437,5 +5437,5 @@\n-    {\n-        xmlLocationSetPtr loc = val->user;\n-        ret->user = (void *) xmlXPtrLocationSetMerge(NULL, loc);\n-        break;\n-    }\n+        {\n+            xmlLocationSetPtr loc = val->user;\n+            ret->user = (void *) xmlXPtrLocationSetMerge(NULL, loc);\n+            break;\n+        }\n@@ -5444,2 +5444,2 @@\n-        ret->user = val->user;\n-        break;\n+            ret->user = val->user;\n+            break;\n@@ -5447,4 +5447,4 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"xmlXPathObjectCopy: unsupported type %d\\n\",\n-            val->type);\n-        break;\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"xmlXPathObjectCopy: unsupported type %d\\n\",\n+                    val->type);\n+            break;\n@@ -5465,1 +5465,1 @@\n-    if (obj->boolval) {\n+        if (obj->boolval) {\n@@ -5467,1 +5467,1 @@\n-        if (obj->user != NULL) {\n+            if (obj->user != NULL) {\n@@ -5469,2 +5469,2 @@\n-        xmlFreeNodeList((xmlNodePtr) obj->user);\n-        } else\n+                xmlFreeNodeList((xmlNodePtr) obj->user);\n+            } else\n@@ -5472,7 +5472,7 @@\n-        obj->type = XPATH_XSLT_TREE; \/* TODO: Just for debugging. *\/\n-        if (obj->nodesetval != NULL)\n-        xmlXPathFreeValueTree(obj->nodesetval);\n-    } else {\n-        if (obj->nodesetval != NULL)\n-        xmlXPathFreeNodeSet(obj->nodesetval);\n-    }\n+            obj->type = XPATH_XSLT_TREE; \/* TODO: Just for debugging. *\/\n+            if (obj->nodesetval != NULL)\n+                xmlXPathFreeValueTree(obj->nodesetval);\n+        } else {\n+            if (obj->nodesetval != NULL)\n+                xmlXPathFreeNodeSet(obj->nodesetval);\n+        }\n@@ -5481,2 +5481,2 @@\n-    if (obj->user != NULL)\n-        xmlXPtrFreeLocationSet(obj->user);\n+        if (obj->user != NULL)\n+            xmlXPtrFreeLocationSet(obj->user);\n@@ -5485,2 +5485,2 @@\n-    if (obj->stringval != NULL)\n-        xmlFree(obj->stringval);\n+        if (obj->stringval != NULL)\n+            xmlFree(obj->stringval);\n@@ -5510,1 +5510,1 @@\n-    sl = xmlPointerListCreate(10); if (sl == NULL) goto free_obj; } \\\n+        sl = xmlPointerListCreate(10); if (sl == NULL) goto free_obj; } \\\n@@ -5516,1 +5516,1 @@\n-    return;\n+        return;\n@@ -5518,1 +5518,1 @@\n-     xmlXPathFreeObject(obj);\n+         xmlXPathFreeObject(obj);\n@@ -5520,2 +5520,2 @@\n-    xmlXPathContextCachePtr cache =\n-        (xmlXPathContextCachePtr) ctxt->cache;\n+        xmlXPathContextCachePtr cache =\n+            (xmlXPathContextCachePtr) ctxt->cache;\n@@ -5523,28 +5523,28 @@\n-    switch (obj->type) {\n-        case XPATH_NODESET:\n-        case XPATH_XSLT_TREE:\n-        if (obj->nodesetval != NULL) {\n-            if (obj->boolval) {\n-            \/*\n-            * It looks like the @boolval is used for\n-            * evaluation if this an XSLT Result Tree Fragment.\n-            * TODO: Check if this assumption is correct.\n-            *\/\n-            obj->type = XPATH_XSLT_TREE; \/* just for debugging *\/\n-            xmlXPathFreeValueTree(obj->nodesetval);\n-            obj->nodesetval = NULL;\n-            } else if ((obj->nodesetval->nodeMax <= 40) &&\n-            (XP_CACHE_WANTS(cache->nodesetObjs,\n-                    cache->maxNodeset)))\n-            {\n-            XP_CACHE_ADD(cache->nodesetObjs, obj);\n-            goto obj_cached;\n-            } else {\n-            xmlXPathFreeNodeSet(obj->nodesetval);\n-            obj->nodesetval = NULL;\n-            }\n-        }\n-        break;\n-        case XPATH_STRING:\n-        if (obj->stringval != NULL)\n-            xmlFree(obj->stringval);\n+        switch (obj->type) {\n+            case XPATH_NODESET:\n+            case XPATH_XSLT_TREE:\n+                if (obj->nodesetval != NULL) {\n+                    if (obj->boolval) {\n+                        \/*\n+                        * It looks like the @boolval is used for\n+                        * evaluation if this an XSLT Result Tree Fragment.\n+                        * TODO: Check if this assumption is correct.\n+                        *\/\n+                        obj->type = XPATH_XSLT_TREE; \/* just for debugging *\/\n+                        xmlXPathFreeValueTree(obj->nodesetval);\n+                        obj->nodesetval = NULL;\n+                    } else if ((obj->nodesetval->nodeMax <= 40) &&\n+                        (XP_CACHE_WANTS(cache->nodesetObjs,\n+                                        cache->maxNodeset)))\n+                    {\n+                        XP_CACHE_ADD(cache->nodesetObjs, obj);\n+                        goto obj_cached;\n+                    } else {\n+                        xmlXPathFreeNodeSet(obj->nodesetval);\n+                        obj->nodesetval = NULL;\n+                    }\n+                }\n+                break;\n+            case XPATH_STRING:\n+                if (obj->stringval != NULL)\n+                    xmlFree(obj->stringval);\n@@ -5552,17 +5552,17 @@\n-        if (XP_CACHE_WANTS(cache->stringObjs, cache->maxString)) {\n-            XP_CACHE_ADD(cache->stringObjs, obj);\n-            goto obj_cached;\n-        }\n-        break;\n-        case XPATH_BOOLEAN:\n-        if (XP_CACHE_WANTS(cache->booleanObjs, cache->maxBoolean)) {\n-            XP_CACHE_ADD(cache->booleanObjs, obj);\n-            goto obj_cached;\n-        }\n-        break;\n-        case XPATH_NUMBER:\n-        if (XP_CACHE_WANTS(cache->numberObjs, cache->maxNumber)) {\n-            XP_CACHE_ADD(cache->numberObjs, obj);\n-            goto obj_cached;\n-        }\n-        break;\n+                if (XP_CACHE_WANTS(cache->stringObjs, cache->maxString)) {\n+                    XP_CACHE_ADD(cache->stringObjs, obj);\n+                    goto obj_cached;\n+                }\n+                break;\n+            case XPATH_BOOLEAN:\n+                if (XP_CACHE_WANTS(cache->booleanObjs, cache->maxBoolean)) {\n+                    XP_CACHE_ADD(cache->booleanObjs, obj);\n+                    goto obj_cached;\n+                }\n+                break;\n+            case XPATH_NUMBER:\n+                if (XP_CACHE_WANTS(cache->numberObjs, cache->maxNumber)) {\n+                    XP_CACHE_ADD(cache->numberObjs, obj);\n+                    goto obj_cached;\n+                }\n+                break;\n@@ -5570,5 +5570,5 @@\n-        case XPATH_LOCATIONSET:\n-        if (obj->user != NULL) {\n-            xmlXPtrFreeLocationSet(obj->user);\n-        }\n-        goto free_obj;\n+            case XPATH_LOCATIONSET:\n+                if (obj->user != NULL) {\n+                    xmlXPtrFreeLocationSet(obj->user);\n+                }\n+                goto free_obj;\n@@ -5576,3 +5576,3 @@\n-        default:\n-        goto free_obj;\n-    }\n+            default:\n+                goto free_obj;\n+        }\n@@ -5580,7 +5580,7 @@\n-    \/*\n-    * Fallback to adding to the misc-objects slot.\n-    *\/\n-    if (XP_CACHE_WANTS(cache->miscObjs, cache->maxMisc)) {\n-        XP_CACHE_ADD(cache->miscObjs, obj);\n-    } else\n-        goto free_obj;\n+        \/*\n+        * Fallback to adding to the misc-objects slot.\n+        *\/\n+        if (XP_CACHE_WANTS(cache->miscObjs, cache->maxMisc)) {\n+            XP_CACHE_ADD(cache->miscObjs, obj);\n+        } else\n+            goto free_obj;\n@@ -5591,1 +5591,1 @@\n-    xmlXPathDebugObjUsageReleased(ctxt, obj->type);\n+        xmlXPathDebugObjUsageReleased(ctxt, obj->type);\n@@ -5594,12 +5594,2 @@\n-    if (obj->nodesetval != NULL) {\n-        xmlNodeSetPtr tmpset = obj->nodesetval;\n-\n-        \/*\n-        * TODO: Due to those nasty ns-nodes, we need to traverse\n-        *  the list and free the ns-nodes.\n-        * URGENT TODO: Check if it's actually slowing things down.\n-        *  Maybe we shouldn't try to preserve the list.\n-        *\/\n-        if (tmpset->nodeNr > 1) {\n-        int i;\n-        xmlNodePtr node;\n+        if (obj->nodesetval != NULL) {\n+            xmlNodeSetPtr tmpset = obj->nodesetval;\n@@ -5607,6 +5597,22 @@\n-        for (i = 0; i < tmpset->nodeNr; i++) {\n-            node = tmpset->nodeTab[i];\n-            if ((node != NULL) &&\n-            (node->type == XML_NAMESPACE_DECL))\n-            {\n-            xmlXPathNodeSetFreeNs((xmlNsPtr) node);\n+            \/*\n+            * TODO: Due to those nasty ns-nodes, we need to traverse\n+            *  the list and free the ns-nodes.\n+            * URGENT TODO: Check if it's actually slowing things down.\n+            *  Maybe we shouldn't try to preserve the list.\n+            *\/\n+            if (tmpset->nodeNr > 1) {\n+                int i;\n+                xmlNodePtr node;\n+\n+                for (i = 0; i < tmpset->nodeNr; i++) {\n+                    node = tmpset->nodeTab[i];\n+                    if ((node != NULL) &&\n+                        (node->type == XML_NAMESPACE_DECL))\n+                    {\n+                        xmlXPathNodeSetFreeNs((xmlNsPtr) node);\n+                    }\n+                }\n+            } else if (tmpset->nodeNr == 1) {\n+                if ((tmpset->nodeTab[0] != NULL) &&\n+                    (tmpset->nodeTab[0]->type == XML_NAMESPACE_DECL))\n+                    xmlXPathNodeSetFreeNs((xmlNsPtr) tmpset->nodeTab[0]);\n@@ -5614,11 +5620,5 @@\n-        }\n-        } else if (tmpset->nodeNr == 1) {\n-        if ((tmpset->nodeTab[0] != NULL) &&\n-            (tmpset->nodeTab[0]->type == XML_NAMESPACE_DECL))\n-            xmlXPathNodeSetFreeNs((xmlNsPtr) tmpset->nodeTab[0]);\n-        }\n-        tmpset->nodeNr = 0;\n-        memset(obj, 0, sizeof(xmlXPathObject));\n-        obj->nodesetval = tmpset;\n-    } else\n-        memset(obj, 0, sizeof(xmlXPathObject));\n+            tmpset->nodeNr = 0;\n+            memset(obj, 0, sizeof(xmlXPathObject));\n+            obj->nodesetval = tmpset;\n+        } else\n+            memset(obj, 0, sizeof(xmlXPathObject));\n@@ -5626,1 +5626,1 @@\n-    return;\n+        return;\n@@ -5629,5 +5629,5 @@\n-    \/*\n-    * Cache is full; free the object.\n-    *\/\n-    if (obj->nodesetval != NULL)\n-        xmlXPathFreeNodeSet(obj->nodesetval);\n+        \/*\n+        * Cache is full; free the object.\n+        *\/\n+        if (obj->nodesetval != NULL)\n+            xmlXPathFreeNodeSet(obj->nodesetval);\n@@ -5635,1 +5635,1 @@\n-    xmlXPathDebugObjUsageReleased(NULL, obj->type);\n+        xmlXPathDebugObjUsageReleased(NULL, obj->type);\n@@ -5637,1 +5637,1 @@\n-    xmlFree(obj);\n+        xmlFree(obj);\n@@ -5644,3 +5644,3 @@\n- *                                  *\n- *          Type Casting Routines               *\n- *                                  *\n+ *                                                                      *\n+ *                      Type Casting Routines                           *\n+ *                                                                      *\n@@ -5661,1 +5661,1 @@\n-    ret = xmlStrdup((const xmlChar *) \"true\");\n+        ret = xmlStrdup((const xmlChar *) \"true\");\n@@ -5663,1 +5663,1 @@\n-    ret = xmlStrdup((const xmlChar *) \"false\");\n+        ret = xmlStrdup((const xmlChar *) \"false\");\n@@ -5680,2 +5680,2 @@\n-    ret = xmlStrdup((const xmlChar *) \"Infinity\");\n-    break;\n+        ret = xmlStrdup((const xmlChar *) \"Infinity\");\n+        break;\n@@ -5683,2 +5683,2 @@\n-    ret = xmlStrdup((const xmlChar *) \"-Infinity\");\n-    break;\n+        ret = xmlStrdup((const xmlChar *) \"-Infinity\");\n+        break;\n@@ -5686,3 +5686,3 @@\n-    if (xmlXPathIsNaN(val)) {\n-        ret = xmlStrdup((const xmlChar *) \"NaN\");\n-    } else if (val == 0) {\n+        if (xmlXPathIsNaN(val)) {\n+            ret = xmlStrdup((const xmlChar *) \"NaN\");\n+        } else if (val == 0) {\n@@ -5690,8 +5690,8 @@\n-        ret = xmlStrdup((const xmlChar *) \"0\");\n-    } else {\n-        \/* could be improved *\/\n-        char buf[100];\n-        xmlXPathFormatNumber(val, buf, 99);\n-        buf[99] = 0;\n-        ret = xmlStrdup((const xmlChar *) buf);\n-    }\n+            ret = xmlStrdup((const xmlChar *) \"0\");\n+        } else {\n+            \/* could be improved *\/\n+            char buf[100];\n+            xmlXPathFormatNumber(val, buf, 99);\n+            buf[99] = 0;\n+            ret = xmlStrdup((const xmlChar *) buf);\n+        }\n@@ -5714,1 +5714,1 @@\n-    ret = xmlStrdup((const xmlChar *) \"\");\n+        ret = xmlStrdup((const xmlChar *) \"\");\n@@ -5729,1 +5729,1 @@\n-    return(xmlStrdup((const xmlChar *) \"\"));\n+        return(xmlStrdup((const xmlChar *) \"\"));\n@@ -5732,1 +5732,1 @@\n-    xmlXPathNodeSetSort(ns);\n+        xmlXPathNodeSetSort(ns);\n@@ -5750,1 +5750,1 @@\n-    return(xmlStrdup((const xmlChar *) \"\"));\n+        return(xmlStrdup((const xmlChar *) \"\"));\n@@ -5752,1 +5752,1 @@\n-    case XPATH_UNDEFINED:\n+        case XPATH_UNDEFINED:\n@@ -5754,1 +5754,1 @@\n-        xmlGenericError(xmlGenericErrorContext, \"String: undefined\\n\");\n+            xmlGenericError(xmlGenericErrorContext, \"String: undefined\\n\");\n@@ -5756,2 +5756,2 @@\n-        ret = xmlStrdup((const xmlChar *) \"\");\n-        break;\n+            ret = xmlStrdup((const xmlChar *) \"\");\n+            break;\n@@ -5760,4 +5760,4 @@\n-        ret = xmlXPathCastNodeSetToString(val->nodesetval);\n-        break;\n-    case XPATH_STRING:\n-        return(xmlStrdup(val->stringval));\n+            ret = xmlXPathCastNodeSetToString(val->nodesetval);\n+            break;\n+        case XPATH_STRING:\n+            return(xmlStrdup(val->stringval));\n@@ -5765,13 +5765,13 @@\n-        ret = xmlXPathCastBooleanToString(val->boolval);\n-        break;\n-    case XPATH_NUMBER: {\n-        ret = xmlXPathCastNumberToString(val->floatval);\n-        break;\n-    }\n-    case XPATH_USERS:\n-    case XPATH_POINT:\n-    case XPATH_RANGE:\n-    case XPATH_LOCATIONSET:\n-        TODO\n-        ret = xmlStrdup((const xmlChar *) \"\");\n-        break;\n+            ret = xmlXPathCastBooleanToString(val->boolval);\n+            break;\n+        case XPATH_NUMBER: {\n+            ret = xmlXPathCastNumberToString(val->floatval);\n+            break;\n+        }\n+        case XPATH_USERS:\n+        case XPATH_POINT:\n+        case XPATH_RANGE:\n+        case XPATH_LOCATIONSET:\n+            TODO\n+            ret = xmlStrdup((const xmlChar *) \"\");\n+            break;\n@@ -5796,1 +5796,1 @@\n-    return(xmlXPathNewCString(\"\"));\n+        return(xmlXPathNewCString(\"\"));\n@@ -5801,1 +5801,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"STRING: undefined\\n\");\n+        xmlGenericError(xmlGenericErrorContext, \"STRING: undefined\\n\");\n@@ -5803,1 +5803,1 @@\n-    break;\n+        break;\n@@ -5806,2 +5806,2 @@\n-    res = xmlXPathCastNodeSetToString(val->nodesetval);\n-    break;\n+        res = xmlXPathCastNodeSetToString(val->nodesetval);\n+        break;\n@@ -5809,1 +5809,1 @@\n-    return(val);\n+        return(val);\n@@ -5811,2 +5811,2 @@\n-    res = xmlXPathCastBooleanToString(val->boolval);\n-    break;\n+        res = xmlXPathCastBooleanToString(val->boolval);\n+        break;\n@@ -5814,2 +5814,2 @@\n-    res = xmlXPathCastNumberToString(val->floatval);\n-    break;\n+        res = xmlXPathCastNumberToString(val->floatval);\n+        break;\n@@ -5820,2 +5820,2 @@\n-    TODO;\n-    break;\n+        TODO;\n+        break;\n@@ -5825,1 +5825,1 @@\n-    return(xmlXPathNewCString(\"\"));\n+        return(xmlXPathNewCString(\"\"));\n@@ -5840,1 +5840,1 @@\n-    return(1.0);\n+        return(1.0);\n@@ -5871,1 +5871,1 @@\n-    return(xmlXPathNAN);\n+        return(xmlXPathNAN);\n@@ -5874,1 +5874,1 @@\n-    return(xmlXPathNAN);\n+        return(xmlXPathNAN);\n@@ -5895,1 +5895,1 @@\n-    return(xmlXPathNAN);\n+        return(xmlXPathNAN);\n@@ -5915,1 +5915,1 @@\n-    return(xmlXPathNAN);\n+        return(xmlXPathNAN);\n@@ -5919,1 +5919,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"NUMBER: undefined\\n\");\n+        xmlGenericError(xmlGenericErrorContext, \"NUMBER: undefined\\n\");\n@@ -5921,2 +5921,2 @@\n-    ret = xmlXPathNAN;\n-    break;\n+        ret = xmlXPathNAN;\n+        break;\n@@ -5925,2 +5925,2 @@\n-    ret = xmlXPathCastNodeSetToNumber(val->nodesetval);\n-    break;\n+        ret = xmlXPathCastNodeSetToNumber(val->nodesetval);\n+        break;\n@@ -5928,2 +5928,2 @@\n-    ret = xmlXPathCastStringToNumber(val->stringval);\n-    break;\n+        ret = xmlXPathCastStringToNumber(val->stringval);\n+        break;\n@@ -5931,2 +5931,2 @@\n-    ret = val->floatval;\n-    break;\n+        ret = val->floatval;\n+        break;\n@@ -5934,2 +5934,2 @@\n-    ret = xmlXPathCastBooleanToNumber(val->boolval);\n-    break;\n+        ret = xmlXPathCastBooleanToNumber(val->boolval);\n+        break;\n@@ -5940,3 +5940,3 @@\n-    TODO;\n-    ret = xmlXPathNAN;\n-    break;\n+        TODO;\n+        ret = xmlXPathNAN;\n+        break;\n@@ -5961,1 +5961,1 @@\n-    return(xmlXPathNewFloat(0.0));\n+        return(xmlXPathNewFloat(0.0));\n@@ -5963,1 +5963,1 @@\n-    return(val);\n+        return(val);\n@@ -5980,1 +5980,1 @@\n-     return(0);\n+         return(0);\n@@ -5995,1 +5995,1 @@\n-    return(0);\n+        return(0);\n@@ -6010,1 +6010,1 @@\n-    return(0);\n+        return(0);\n@@ -6027,1 +6027,1 @@\n-    return(0);\n+        return(0);\n@@ -6031,1 +6031,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"BOOLEAN: undefined\\n\");\n+        xmlGenericError(xmlGenericErrorContext, \"BOOLEAN: undefined\\n\");\n@@ -6033,2 +6033,2 @@\n-    ret = 0;\n-    break;\n+        ret = 0;\n+        break;\n@@ -6037,2 +6037,2 @@\n-    ret = xmlXPathCastNodeSetToBoolean(val->nodesetval);\n-    break;\n+        ret = xmlXPathCastNodeSetToBoolean(val->nodesetval);\n+        break;\n@@ -6040,2 +6040,2 @@\n-    ret = xmlXPathCastStringToBoolean(val->stringval);\n-    break;\n+        ret = xmlXPathCastStringToBoolean(val->stringval);\n+        break;\n@@ -6043,2 +6043,2 @@\n-    ret = xmlXPathCastNumberToBoolean(val->floatval);\n-    break;\n+        ret = xmlXPathCastNumberToBoolean(val->floatval);\n+        break;\n@@ -6046,2 +6046,2 @@\n-    ret = val->boolval;\n-    break;\n+        ret = val->boolval;\n+        break;\n@@ -6052,3 +6052,3 @@\n-    TODO;\n-    ret = 0;\n-    break;\n+        TODO;\n+        ret = 0;\n+        break;\n@@ -6074,1 +6074,1 @@\n-    return(xmlXPathNewBoolean(0));\n+        return(xmlXPathNewBoolean(0));\n@@ -6076,1 +6076,1 @@\n-    return(val);\n+        return(val);\n@@ -6083,3 +6083,3 @@\n- *                                  *\n- *      Routines to handle XPath contexts           *\n- *                                  *\n+ *                                                                      *\n+ *              Routines to handle XPath contexts                       *\n+ *                                                                      *\n@@ -6103,1 +6103,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6129,2 +6129,2 @@\n-    xmlXPathFreeContext(ret);\n-    return(NULL);\n+        xmlXPathFreeContext(ret);\n+        return(NULL);\n@@ -6150,1 +6150,1 @@\n-    xmlXPathFreeCache((xmlXPathContextCachePtr) ctxt->cache);\n+        xmlXPathFreeCache((xmlXPathContextCachePtr) ctxt->cache);\n@@ -6159,3 +6159,3 @@\n- *                                  *\n- *      Routines to handle XPath parser contexts        *\n- *                                  *\n+ *                                                                      *\n+ *              Routines to handle XPath parser contexts                *\n+ *                                                                      *\n@@ -6164,10 +6164,10 @@\n-#define CHECK_CTXT(ctxt)                        \\\n-    if (ctxt == NULL) {                     \\\n-    __xmlRaiseError(NULL, NULL, NULL,               \\\n-        NULL, NULL, XML_FROM_XPATH,             \\\n-        XML_ERR_INTERNAL_ERROR, XML_ERR_FATAL,          \\\n-        __FILE__, __LINE__,                 \\\n-        NULL, NULL, NULL, 0, 0,                 \\\n-        \"NULL context pointer\\n\");              \\\n-    return(NULL);                           \\\n-    }                                   \\\n+#define CHECK_CTXT(ctxt)                                                \\\n+    if (ctxt == NULL) {                                         \\\n+        __xmlRaiseError(NULL, NULL, NULL,                               \\\n+                NULL, NULL, XML_FROM_XPATH,                             \\\n+                XML_ERR_INTERNAL_ERROR, XML_ERR_FATAL,                  \\\n+                __FILE__, __LINE__,                                     \\\n+                NULL, NULL, NULL, 0, 0,                                 \\\n+                \"NULL context pointer\\n\");                              \\\n+        return(NULL);                                                   \\\n+    }                                                                   \\\n@@ -6175,10 +6175,10 @@\n-#define CHECK_CTXT_NEG(ctxt)                        \\\n-    if (ctxt == NULL) {                     \\\n-    __xmlRaiseError(NULL, NULL, NULL,               \\\n-        NULL, NULL, XML_FROM_XPATH,             \\\n-        XML_ERR_INTERNAL_ERROR, XML_ERR_FATAL,          \\\n-        __FILE__, __LINE__,                 \\\n-        NULL, NULL, NULL, 0, 0,                 \\\n-        \"NULL context pointer\\n\");              \\\n-    return(-1);                         \\\n-    }                                   \\\n+#define CHECK_CTXT_NEG(ctxt)                                            \\\n+    if (ctxt == NULL) {                                         \\\n+        __xmlRaiseError(NULL, NULL, NULL,                               \\\n+                NULL, NULL, XML_FROM_XPATH,                             \\\n+                XML_ERR_INTERNAL_ERROR, XML_ERR_FATAL,                  \\\n+                __FILE__, __LINE__,                                     \\\n+                NULL, NULL, NULL, 0, 0,                                 \\\n+                \"NULL context pointer\\n\");                              \\\n+        return(-1);                                                     \\\n+    }                                                                   \\\n@@ -6187,5 +6187,5 @@\n-#define CHECK_CONTEXT(ctxt)                     \\\n-    if ((ctxt == NULL) || (ctxt->doc == NULL) ||            \\\n-        (ctxt->doc->children == NULL)) {                \\\n-    xmlXPatherror(ctxt, __FILE__, __LINE__, XPATH_INVALID_CTXT);    \\\n-    return(NULL);                           \\\n+#define CHECK_CONTEXT(ctxt)                                             \\\n+    if ((ctxt == NULL) || (ctxt->doc == NULL) ||                        \\\n+        (ctxt->doc->children == NULL)) {                                \\\n+        xmlXPatherror(ctxt, __FILE__, __LINE__, XPATH_INVALID_CTXT);    \\\n+        return(NULL);                                                   \\\n@@ -6211,1 +6211,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6219,3 +6219,3 @@\n-    xmlFree(ret->valueTab);\n-    xmlFree(ret);\n-    return(NULL);\n+        xmlFree(ret->valueTab);\n+        xmlFree(ret);\n+        return(NULL);\n@@ -6225,1 +6225,1 @@\n-    xmlDictReference(ret->comp->dict);\n+        xmlDictReference(ret->comp->dict);\n@@ -6247,1 +6247,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6255,3 +6255,3 @@\n-    xmlFree(ret);\n-    xmlXPathErrMemory(ctxt, \"creating evaluation context\\n\");\n-    return(NULL);\n+        xmlFree(ret);\n+        xmlXPathErrMemory(ctxt, \"creating evaluation context\\n\");\n+        return(NULL);\n@@ -6291,4 +6291,4 @@\n-    if (ctxt->comp->stream != NULL) {\n-        xmlFreePatternList(ctxt->comp->stream);\n-        ctxt->comp->stream = NULL;\n-    }\n+        if (ctxt->comp->stream != NULL) {\n+            xmlFreePatternList(ctxt->comp->stream);\n+            ctxt->comp->stream = NULL;\n+        }\n@@ -6296,1 +6296,1 @@\n-    xmlXPathFreeCompExpr(ctxt->comp);\n+        xmlXPathFreeCompExpr(ctxt->comp);\n@@ -6302,3 +6302,3 @@\n- *                                  *\n- *      The implicit core function library          *\n- *                                  *\n+ *                                                                      *\n+ *              The implicit core function library                      *\n+ *                                                                      *\n@@ -6324,1 +6324,1 @@\n-    return(0);\n+        return(0);\n@@ -6327,5 +6327,5 @@\n-    tmp = xmlDocGetRootElement((xmlDocPtr) node);\n-    if (tmp == NULL)\n-        node = node->children;\n-    else\n-        node = tmp;\n+        tmp = xmlDocGetRootElement((xmlDocPtr) node);\n+        if (tmp == NULL)\n+            node = node->children;\n+        else\n+            node = tmp;\n@@ -6333,2 +6333,2 @@\n-    if (node == NULL)\n-        return(0);\n+        if (node == NULL)\n+            return(0);\n@@ -6338,30 +6338,2 @@\n-    case XML_COMMENT_NODE:\n-    case XML_PI_NODE:\n-    case XML_CDATA_SECTION_NODE:\n-    case XML_TEXT_NODE:\n-        string = node->content;\n-        if (string == NULL)\n-        return(0);\n-        if (string[0] == 0)\n-        return(0);\n-        return(((unsigned int) string[0]) +\n-           (((unsigned int) string[1]) << 8));\n-    case XML_NAMESPACE_DECL:\n-        string = ((xmlNsPtr)node)->href;\n-        if (string == NULL)\n-        return(0);\n-        if (string[0] == 0)\n-        return(0);\n-        return(((unsigned int) string[0]) +\n-           (((unsigned int) string[1]) << 8));\n-    case XML_ATTRIBUTE_NODE:\n-        tmp = ((xmlAttrPtr) node)->children;\n-        break;\n-    case XML_ELEMENT_NODE:\n-        tmp = node->children;\n-        break;\n-    default:\n-        return(0);\n-    }\n-    while (tmp != NULL) {\n-    switch (tmp->type) {\n+        case XML_COMMENT_NODE:\n+        case XML_PI_NODE:\n@@ -6370,2 +6342,21 @@\n-        string = tmp->content;\n-        break;\n+            string = node->content;\n+            if (string == NULL)\n+                return(0);\n+            if (string[0] == 0)\n+                return(0);\n+            return(((unsigned int) string[0]) +\n+                   (((unsigned int) string[1]) << 8));\n+        case XML_NAMESPACE_DECL:\n+            string = ((xmlNsPtr)node)->href;\n+            if (string == NULL)\n+                return(0);\n+            if (string[0] == 0)\n+                return(0);\n+            return(((unsigned int) string[0]) +\n+                   (((unsigned int) string[1]) << 8));\n+        case XML_ATTRIBUTE_NODE:\n+            tmp = ((xmlAttrPtr) node)->children;\n+            break;\n+        case XML_ELEMENT_NODE:\n+            tmp = node->children;\n+            break;\n@@ -6373,2 +6364,1 @@\n-                string = NULL;\n-        break;\n+            return(0);\n@@ -6376,3 +6366,9 @@\n-    if ((string != NULL) && (string[0] != 0)) {\n-        if (len == 1) {\n-        return(ret + (((unsigned int) string[0]) << 8));\n+    while (tmp != NULL) {\n+        switch (tmp->type) {\n+            case XML_CDATA_SECTION_NODE:\n+            case XML_TEXT_NODE:\n+                string = tmp->content;\n+                break;\n+            default:\n+                string = NULL;\n+                break;\n@@ -6380,6 +6376,11 @@\n-        if (string[1] == 0) {\n-        len = 1;\n-        ret = (unsigned int) string[0];\n-        } else {\n-        return(((unsigned int) string[0]) +\n-               (((unsigned int) string[1]) << 8));\n+        if ((string != NULL) && (string[0] != 0)) {\n+            if (len == 1) {\n+                return(ret + (((unsigned int) string[0]) << 8));\n+            }\n+            if (string[1] == 0) {\n+                len = 1;\n+                ret = (unsigned int) string[0];\n+            } else {\n+                return(((unsigned int) string[0]) +\n+                       (((unsigned int) string[1]) << 8));\n+            }\n@@ -6387,8 +6388,8 @@\n-    }\n-    \/*\n-     * Skip to next node\n-     *\/\n-    if ((tmp->children != NULL) && (tmp->type != XML_DTD_NODE)) {\n-        if (tmp->children->type != XML_ENTITY_DECL) {\n-        tmp = tmp->children;\n-        continue;\n+        \/*\n+         * Skip to next node\n+         *\/\n+        if ((tmp->children != NULL) && (tmp->type != XML_DTD_NODE)) {\n+            if (tmp->children->type != XML_ENTITY_DECL) {\n+                tmp = tmp->children;\n+                continue;\n+            }\n@@ -6396,8 +6397,2 @@\n-    }\n-    if (tmp == node)\n-        break;\n-\n-    if (tmp->next != NULL) {\n-        tmp = tmp->next;\n-        continue;\n-    }\n+        if (tmp == node)\n+            break;\n@@ -6405,8 +6400,0 @@\n-    do {\n-        tmp = tmp->parent;\n-        if (tmp == NULL)\n-        break;\n-        if (tmp == node) {\n-        tmp = NULL;\n-        break;\n-        }\n@@ -6414,2 +6401,2 @@\n-        tmp = tmp->next;\n-        break;\n+            tmp = tmp->next;\n+            continue;\n@@ -6417,1 +6404,14 @@\n-    } while (tmp != NULL);\n+\n+        do {\n+            tmp = tmp->parent;\n+            if (tmp == NULL)\n+                break;\n+            if (tmp == node) {\n+                tmp = NULL;\n+                break;\n+            }\n+            if (tmp->next != NULL) {\n+                tmp = tmp->next;\n+                break;\n+            }\n+        } while (tmp != NULL);\n@@ -6434,1 +6434,1 @@\n-    return((unsigned int) 0);\n+        return((unsigned int) 0);\n@@ -6436,1 +6436,1 @@\n-    return(0);\n+        return(0);\n@@ -6438,1 +6438,1 @@\n-       (((unsigned int) string[1]) << 8));\n+           (((unsigned int) string[1]) << 8));\n@@ -6465,1 +6465,1 @@\n-                        xmlXPathObjectPtr arg, xmlXPathObjectPtr f) {\n+                            xmlXPathObjectPtr arg, xmlXPathObjectPtr f) {\n@@ -6471,3 +6471,3 @@\n-    ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE))) {\n-    xmlXPathReleaseObject(ctxt->context, arg);\n-    xmlXPathReleaseObject(ctxt->context, f);\n+        ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE))) {\n+        xmlXPathReleaseObject(ctxt->context, arg);\n+        xmlXPathReleaseObject(ctxt->context, f);\n@@ -6478,13 +6478,13 @@\n-    for (i = 0;i < ns->nodeNr;i++) {\n-         str2 = xmlXPathCastNodeToString(ns->nodeTab[i]);\n-         if (str2 != NULL) {\n-         valuePush(ctxt,\n-               xmlXPathCacheNewString(ctxt->context, str2));\n-         xmlFree(str2);\n-         xmlXPathNumberFunction(ctxt, 1);\n-         valuePush(ctxt, xmlXPathCacheObjectCopy(ctxt->context, f));\n-         ret = xmlXPathCompareValues(ctxt, inf, strict);\n-         if (ret)\n-             break;\n-         }\n-    }\n+        for (i = 0;i < ns->nodeNr;i++) {\n+             str2 = xmlXPathCastNodeToString(ns->nodeTab[i]);\n+             if (str2 != NULL) {\n+                 valuePush(ctxt,\n+                           xmlXPathCacheNewString(ctxt->context, str2));\n+                 xmlFree(str2);\n+                 xmlXPathNumberFunction(ctxt, 1);\n+                 valuePush(ctxt, xmlXPathCacheObjectCopy(ctxt->context, f));\n+                 ret = xmlXPathCompareValues(ctxt, inf, strict);\n+                 if (ret)\n+                     break;\n+             }\n+        }\n@@ -6520,1 +6520,1 @@\n-                        xmlXPathObjectPtr arg, xmlXPathObjectPtr s) {\n+                            xmlXPathObjectPtr arg, xmlXPathObjectPtr s) {\n@@ -6526,3 +6526,3 @@\n-    ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE))) {\n-    xmlXPathReleaseObject(ctxt->context, arg);\n-    xmlXPathReleaseObject(ctxt->context, s);\n+        ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE))) {\n+        xmlXPathReleaseObject(ctxt->context, arg);\n+        xmlXPathReleaseObject(ctxt->context, s);\n@@ -6533,12 +6533,12 @@\n-    for (i = 0;i < ns->nodeNr;i++) {\n-         str2 = xmlXPathCastNodeToString(ns->nodeTab[i]);\n-         if (str2 != NULL) {\n-         valuePush(ctxt,\n-               xmlXPathCacheNewString(ctxt->context, str2));\n-         xmlFree(str2);\n-         valuePush(ctxt, xmlXPathCacheObjectCopy(ctxt->context, s));\n-         ret = xmlXPathCompareValues(ctxt, inf, strict);\n-         if (ret)\n-             break;\n-         }\n-    }\n+        for (i = 0;i < ns->nodeNr;i++) {\n+             str2 = xmlXPathCastNodeToString(ns->nodeTab[i]);\n+             if (str2 != NULL) {\n+                 valuePush(ctxt,\n+                           xmlXPathCacheNewString(ctxt->context, str2));\n+                 xmlFree(str2);\n+                 valuePush(ctxt, xmlXPathCacheObjectCopy(ctxt->context, s));\n+                 ret = xmlXPathCompareValues(ctxt, inf, strict);\n+                 if (ret)\n+                     break;\n+             }\n+        }\n@@ -6581,1 +6581,1 @@\n-                    xmlXPathObjectPtr arg1, xmlXPathObjectPtr arg2) {\n+                        xmlXPathObjectPtr arg1, xmlXPathObjectPtr arg2) {\n@@ -6590,2 +6590,2 @@\n-    ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE))) {\n-    xmlXPathFreeObject(arg2);\n+        ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE))) {\n+        xmlXPathFreeObject(arg2);\n@@ -6595,3 +6595,3 @@\n-    ((arg2->type != XPATH_NODESET) && (arg2->type != XPATH_XSLT_TREE))) {\n-    xmlXPathFreeObject(arg1);\n-    xmlXPathFreeObject(arg2);\n+        ((arg2->type != XPATH_NODESET) && (arg2->type != XPATH_XSLT_TREE))) {\n+        xmlXPathFreeObject(arg1);\n+        xmlXPathFreeObject(arg2);\n@@ -6605,3 +6605,3 @@\n-    xmlXPathFreeObject(arg1);\n-    xmlXPathFreeObject(arg2);\n-    return(0);\n+        xmlXPathFreeObject(arg1);\n+        xmlXPathFreeObject(arg2);\n+        return(0);\n@@ -6610,3 +6610,3 @@\n-    xmlXPathFreeObject(arg1);\n-    xmlXPathFreeObject(arg2);\n-    return(0);\n+        xmlXPathFreeObject(arg1);\n+        xmlXPathFreeObject(arg2);\n+        return(0);\n@@ -6619,3 +6619,3 @@\n-    xmlXPathFreeObject(arg1);\n-    xmlXPathFreeObject(arg2);\n-    return(0);\n+        xmlXPathFreeObject(arg1);\n+        xmlXPathFreeObject(arg2);\n+        return(0);\n@@ -6624,6 +6624,19 @@\n-    val1 = xmlXPathCastNodeToNumber(ns1->nodeTab[i]);\n-    if (xmlXPathIsNaN(val1))\n-        continue;\n-    for (j = 0;j < ns2->nodeNr;j++) {\n-        if (init == 0) {\n-        values2[j] = xmlXPathCastNodeToNumber(ns2->nodeTab[j]);\n+        val1 = xmlXPathCastNodeToNumber(ns1->nodeTab[i]);\n+        if (xmlXPathIsNaN(val1))\n+            continue;\n+        for (j = 0;j < ns2->nodeNr;j++) {\n+            if (init == 0) {\n+                values2[j] = xmlXPathCastNodeToNumber(ns2->nodeTab[j]);\n+            }\n+            if (xmlXPathIsNaN(values2[j]))\n+                continue;\n+            if (inf && strict)\n+                ret = (val1 < values2[j]);\n+            else if (inf && !strict)\n+                ret = (val1 <= values2[j]);\n+            else if (!inf && strict)\n+                ret = (val1 > values2[j]);\n+            else if (!inf && !strict)\n+                ret = (val1 >= values2[j]);\n+            if (ret)\n+                break;\n@@ -6631,10 +6644,0 @@\n-        if (xmlXPathIsNaN(values2[j]))\n-        continue;\n-        if (inf && strict)\n-        ret = (val1 < values2[j]);\n-        else if (inf && !strict)\n-        ret = (val1 <= values2[j]);\n-        else if (!inf && strict)\n-        ret = (val1 > values2[j]);\n-        else if (!inf && !strict)\n-        ret = (val1 >= values2[j]);\n@@ -6642,5 +6645,2 @@\n-        break;\n-    }\n-    if (ret)\n-        break;\n-    init = 1;\n+            break;\n+        init = 1;\n@@ -6677,1 +6677,1 @@\n-                        xmlXPathObjectPtr arg, xmlXPathObjectPtr val) {\n+                            xmlXPathObjectPtr arg, xmlXPathObjectPtr val) {\n@@ -6679,1 +6679,1 @@\n-    ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE)))\n+        ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE)))\n@@ -6684,1 +6684,1 @@\n-        return(xmlXPathCompareNodeSetFloat(ctxt, inf, strict, arg, val));\n+            return(xmlXPathCompareNodeSetFloat(ctxt, inf, strict, arg, val));\n@@ -6687,1 +6687,1 @@\n-        return(xmlXPathCompareNodeSets(inf, strict, arg, val));\n+            return(xmlXPathCompareNodeSets(inf, strict, arg, val));\n@@ -6689,1 +6689,1 @@\n-        return(xmlXPathCompareNodeSetString(ctxt, inf, strict, arg, val));\n+            return(xmlXPathCompareNodeSetString(ctxt, inf, strict, arg, val));\n@@ -6691,5 +6691,5 @@\n-        valuePush(ctxt, arg);\n-        xmlXPathBooleanFunction(ctxt, 1);\n-        valuePush(ctxt, val);\n-        return(xmlXPathCompareValues(ctxt, inf, strict));\n-    default:\n+            valuePush(ctxt, arg);\n+            xmlXPathBooleanFunction(ctxt, 1);\n+            valuePush(ctxt, val);\n+            return(xmlXPathCompareValues(ctxt, inf, strict));\n+        default:\n@@ -6745,2 +6745,2 @@\n-        if (neq)\n-            continue;\n+                if (neq)\n+                    continue;\n@@ -6748,3 +6748,3 @@\n-        } else if ((str2 == NULL) && (xmlStrEqual(str, BAD_CAST \"\"))) {\n-        if (neq)\n-            continue;\n+            } else if ((str2 == NULL) && (xmlStrEqual(str, BAD_CAST \"\"))) {\n+                if (neq)\n+                    continue;\n@@ -6753,4 +6753,4 @@\n-        if (str2 != NULL)\n-            xmlFree(str2);\n-        return (1);\n-        }\n+                if (str2 != NULL)\n+                    xmlFree(str2);\n+                return (1);\n+            }\n@@ -6760,1 +6760,1 @@\n-        return (1);\n+            return (1);\n@@ -6790,1 +6790,1 @@\n-    ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE)))\n+        ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE)))\n@@ -6795,16 +6795,21 @@\n-    for (i=0;i<ns->nodeNr;i++) {\n-        str2 = xmlXPathCastNodeToString(ns->nodeTab[i]);\n-        if (str2 != NULL) {\n-        valuePush(ctxt, xmlXPathCacheNewString(ctxt->context, str2));\n-        xmlFree(str2);\n-        xmlXPathNumberFunction(ctxt, 1);\n-        val = valuePop(ctxt);\n-        v = val->floatval;\n-        xmlXPathReleaseObject(ctxt->context, val);\n-        if (!xmlXPathIsNaN(v)) {\n-            if ((!neq) && (v==f)) {\n-            ret = 1;\n-            break;\n-            } else if ((neq) && (v!=f)) {\n-            ret = 1;\n-            break;\n+        for (i=0;i<ns->nodeNr;i++) {\n+            str2 = xmlXPathCastNodeToString(ns->nodeTab[i]);\n+            if (str2 != NULL) {\n+                valuePush(ctxt, xmlXPathCacheNewString(ctxt->context, str2));\n+                xmlFree(str2);\n+                xmlXPathNumberFunction(ctxt, 1);\n+                val = valuePop(ctxt);\n+                v = val->floatval;\n+                xmlXPathReleaseObject(ctxt->context, val);\n+                if (!xmlXPathIsNaN(v)) {\n+                    if ((!neq) && (v==f)) {\n+                        ret = 1;\n+                        break;\n+                    } else if ((neq) && (v!=f)) {\n+                        ret = 1;\n+                        break;\n+                    }\n+                } else {        \/* NaN is unequal to any value *\/\n+                    if (neq)\n+                        ret = 1;\n+                }\n@@ -6812,3 +6817,0 @@\n-        } else {    \/* NaN is unequal to any value *\/\n-            if (neq)\n-            ret = 1;\n@@ -6816,2 +6818,0 @@\n-        }\n-    }\n@@ -6853,1 +6853,1 @@\n-    ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)))\n+        ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)))\n@@ -6856,1 +6856,1 @@\n-    ((arg2->type != XPATH_NODESET) && (arg2->type != XPATH_XSLT_TREE)))\n+        ((arg2->type != XPATH_NODESET) && (arg2->type != XPATH_XSLT_TREE)))\n@@ -6863,1 +6863,1 @@\n-    return(0);\n+        return(0);\n@@ -6865,1 +6865,1 @@\n-    return(0);\n+        return(0);\n@@ -6871,4 +6871,4 @@\n-    for (i = 0;i < ns1->nodeNr;i++)\n-        for (j = 0;j < ns2->nodeNr;j++)\n-        if (ns1->nodeTab[i] == ns2->nodeTab[j])\n-            return(1);\n+        for (i = 0;i < ns1->nodeNr;i++)\n+            for (j = 0;j < ns2->nodeNr;j++)\n+                if (ns1->nodeTab[i] == ns2->nodeTab[j])\n+                    return(1);\n@@ -6880,1 +6880,1 @@\n-    return(0);\n+        return(0);\n@@ -6886,2 +6886,2 @@\n-    xmlFree(values1);\n-    return(0);\n+        xmlFree(values1);\n+        return(0);\n@@ -6894,3 +6894,3 @@\n-    xmlFree(hashs1);\n-    xmlFree(values1);\n-    return(0);\n+        xmlFree(hashs1);\n+        xmlFree(values1);\n+        return(0);\n@@ -6902,4 +6902,4 @@\n-    xmlFree(hashs1);\n-    xmlFree(values1);\n-    xmlFree(values2);\n-    return(0);\n+        xmlFree(hashs1);\n+        xmlFree(values1);\n+        xmlFree(values2);\n+        return(0);\n@@ -6909,9 +6909,19 @@\n-    hashs1[i] = xmlXPathNodeValHash(ns1->nodeTab[i]);\n-    for (j = 0;j < ns2->nodeNr;j++) {\n-        if (i == 0)\n-        hashs2[j] = xmlXPathNodeValHash(ns2->nodeTab[j]);\n-        if (hashs1[i] != hashs2[j]) {\n-        if (neq) {\n-            ret = 1;\n-            break;\n-        }\n+        hashs1[i] = xmlXPathNodeValHash(ns1->nodeTab[i]);\n+        for (j = 0;j < ns2->nodeNr;j++) {\n+            if (i == 0)\n+                hashs2[j] = xmlXPathNodeValHash(ns2->nodeTab[j]);\n+            if (hashs1[i] != hashs2[j]) {\n+                if (neq) {\n+                    ret = 1;\n+                    break;\n+                }\n+            }\n+            else {\n+                if (values1[i] == NULL)\n+                    values1[i] = xmlNodeGetContent(ns1->nodeTab[i]);\n+                if (values2[j] == NULL)\n+                    values2[j] = xmlNodeGetContent(ns2->nodeTab[j]);\n+                ret = xmlStrEqual(values1[i], values2[j]) ^ neq;\n+                if (ret)\n+                    break;\n+            }\n@@ -6919,6 +6929,0 @@\n-        else {\n-        if (values1[i] == NULL)\n-            values1[i] = xmlNodeGetContent(ns1->nodeTab[i]);\n-        if (values2[j] == NULL)\n-            values2[j] = xmlNodeGetContent(ns2->nodeTab[j]);\n-        ret = xmlStrEqual(values1[i], values2[j]) ^ neq;\n@@ -6927,4 +6931,0 @@\n-        }\n-    }\n-    if (ret)\n-        break;\n@@ -6933,2 +6933,2 @@\n-    if (values1[i] != NULL)\n-        xmlFree(values1[i]);\n+        if (values1[i] != NULL)\n+            xmlFree(values1[i]);\n@@ -6936,2 +6936,2 @@\n-    if (values2[j] != NULL)\n-        xmlFree(values2[j]);\n+        if (values2[j] != NULL)\n+            xmlFree(values2[j]);\n@@ -6955,8 +6955,0 @@\n-#ifdef DEBUG_EXPR\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"Equal: undefined\\n\");\n-#endif\n-        break;\n-        case XPATH_BOOLEAN:\n-        switch (arg2->type) {\n-            case XPATH_UNDEFINED:\n@@ -6965,1 +6957,1 @@\n-                \"Equal: undefined\\n\");\n+                    \"Equal: undefined\\n\");\n@@ -6969,0 +6961,2 @@\n+            switch (arg2->type) {\n+                case XPATH_UNDEFINED:\n@@ -6970,3 +6964,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"Equal: %d boolean %d \\n\",\n-                arg1->boolval, arg2->boolval);\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"Equal: undefined\\n\");\n@@ -6974,21 +6967,30 @@\n-            ret = (arg1->boolval == arg2->boolval);\n-            break;\n-        case XPATH_NUMBER:\n-            ret = (arg1->boolval ==\n-               xmlXPathCastNumberToBoolean(arg2->floatval));\n-            break;\n-        case XPATH_STRING:\n-            if ((arg2->stringval == NULL) ||\n-            (arg2->stringval[0] == 0)) ret = 0;\n-            else\n-            ret = 1;\n-            ret = (arg1->boolval == ret);\n-            break;\n-        case XPATH_USERS:\n-        case XPATH_POINT:\n-        case XPATH_RANGE:\n-        case XPATH_LOCATIONSET:\n-            TODO\n-            break;\n-        case XPATH_NODESET:\n-        case XPATH_XSLT_TREE:\n+                    break;\n+                case XPATH_BOOLEAN:\n+#ifdef DEBUG_EXPR\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"Equal: %d boolean %d \\n\",\n+                            arg1->boolval, arg2->boolval);\n+#endif\n+                    ret = (arg1->boolval == arg2->boolval);\n+                    break;\n+                case XPATH_NUMBER:\n+                    ret = (arg1->boolval ==\n+                           xmlXPathCastNumberToBoolean(arg2->floatval));\n+                    break;\n+                case XPATH_STRING:\n+                    if ((arg2->stringval == NULL) ||\n+                        (arg2->stringval[0] == 0)) ret = 0;\n+                    else\n+                        ret = 1;\n+                    ret = (arg1->boolval == ret);\n+                    break;\n+                case XPATH_USERS:\n+                case XPATH_POINT:\n+                case XPATH_RANGE:\n+                case XPATH_LOCATIONSET:\n+                    TODO\n+                    break;\n+                case XPATH_NODESET:\n+                case XPATH_XSLT_TREE:\n+                    break;\n+            }\n@@ -6996,2 +6998,0 @@\n-        }\n-        break;\n@@ -6999,2 +6999,2 @@\n-        switch (arg2->type) {\n-            case XPATH_UNDEFINED:\n+            switch (arg2->type) {\n+                case XPATH_UNDEFINED:\n@@ -7002,2 +7002,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"Equal: undefined\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"Equal: undefined\\n\");\n@@ -7005,9 +7005,9 @@\n-            break;\n-        case XPATH_BOOLEAN:\n-            ret = (arg2->boolval==\n-               xmlXPathCastNumberToBoolean(arg1->floatval));\n-            break;\n-        case XPATH_STRING:\n-            valuePush(ctxt, arg2);\n-            xmlXPathNumberFunction(ctxt, 1);\n-            arg2 = valuePop(ctxt);\n+                    break;\n+                case XPATH_BOOLEAN:\n+                    ret = (arg2->boolval==\n+                           xmlXPathCastNumberToBoolean(arg1->floatval));\n+                    break;\n+                case XPATH_STRING:\n+                    valuePush(ctxt, arg2);\n+                    xmlXPathNumberFunction(ctxt, 1);\n+                    arg2 = valuePop(ctxt);\n@@ -7015,27 +7015,38 @@\n-        case XPATH_NUMBER:\n-            \/* Hand check NaN and Infinity equalities *\/\n-            if (xmlXPathIsNaN(arg1->floatval) ||\n-                xmlXPathIsNaN(arg2->floatval)) {\n-                ret = 0;\n-            } else if (xmlXPathIsInf(arg1->floatval) == 1) {\n-                if (xmlXPathIsInf(arg2->floatval) == 1)\n-                ret = 1;\n-            else\n-                ret = 0;\n-            } else if (xmlXPathIsInf(arg1->floatval) == -1) {\n-            if (xmlXPathIsInf(arg2->floatval) == -1)\n-                ret = 1;\n-            else\n-                ret = 0;\n-            } else if (xmlXPathIsInf(arg2->floatval) == 1) {\n-            if (xmlXPathIsInf(arg1->floatval) == 1)\n-                ret = 1;\n-            else\n-                ret = 0;\n-            } else if (xmlXPathIsInf(arg2->floatval) == -1) {\n-            if (xmlXPathIsInf(arg1->floatval) == -1)\n-                ret = 1;\n-            else\n-                ret = 0;\n-            } else {\n-                ret = (arg1->floatval == arg2->floatval);\n+                case XPATH_NUMBER:\n+                    \/* Hand check NaN and Infinity equalities *\/\n+                    if (xmlXPathIsNaN(arg1->floatval) ||\n+                            xmlXPathIsNaN(arg2->floatval)) {\n+                        ret = 0;\n+                    } else if (xmlXPathIsInf(arg1->floatval) == 1) {\n+                        if (xmlXPathIsInf(arg2->floatval) == 1)\n+                            ret = 1;\n+                        else\n+                            ret = 0;\n+                    } else if (xmlXPathIsInf(arg1->floatval) == -1) {\n+                        if (xmlXPathIsInf(arg2->floatval) == -1)\n+                            ret = 1;\n+                        else\n+                            ret = 0;\n+                    } else if (xmlXPathIsInf(arg2->floatval) == 1) {\n+                        if (xmlXPathIsInf(arg1->floatval) == 1)\n+                            ret = 1;\n+                        else\n+                            ret = 0;\n+                    } else if (xmlXPathIsInf(arg2->floatval) == -1) {\n+                        if (xmlXPathIsInf(arg1->floatval) == -1)\n+                            ret = 1;\n+                        else\n+                            ret = 0;\n+                    } else {\n+                        ret = (arg1->floatval == arg2->floatval);\n+                    }\n+                    break;\n+                case XPATH_USERS:\n+                case XPATH_POINT:\n+                case XPATH_RANGE:\n+                case XPATH_LOCATIONSET:\n+                    TODO\n+                    break;\n+                case XPATH_NODESET:\n+                case XPATH_XSLT_TREE:\n+                    break;\n@@ -7044,11 +7055,0 @@\n-        case XPATH_USERS:\n-        case XPATH_POINT:\n-        case XPATH_RANGE:\n-        case XPATH_LOCATIONSET:\n-            TODO\n-            break;\n-        case XPATH_NODESET:\n-        case XPATH_XSLT_TREE:\n-            break;\n-        }\n-        break;\n@@ -7056,2 +7056,2 @@\n-        switch (arg2->type) {\n-            case XPATH_UNDEFINED:\n+            switch (arg2->type) {\n+                case XPATH_UNDEFINED:\n@@ -7059,2 +7059,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"Equal: undefined\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"Equal: undefined\\n\");\n@@ -7062,41 +7062,52 @@\n-            break;\n-        case XPATH_BOOLEAN:\n-            if ((arg1->stringval == NULL) ||\n-            (arg1->stringval[0] == 0)) ret = 0;\n-            else\n-            ret = 1;\n-            ret = (arg2->boolval == ret);\n-            break;\n-        case XPATH_STRING:\n-            ret = xmlStrEqual(arg1->stringval, arg2->stringval);\n-            break;\n-        case XPATH_NUMBER:\n-            valuePush(ctxt, arg1);\n-            xmlXPathNumberFunction(ctxt, 1);\n-            arg1 = valuePop(ctxt);\n-            \/* Hand check NaN and Infinity equalities *\/\n-            if (xmlXPathIsNaN(arg1->floatval) ||\n-                xmlXPathIsNaN(arg2->floatval)) {\n-                ret = 0;\n-            } else if (xmlXPathIsInf(arg1->floatval) == 1) {\n-            if (xmlXPathIsInf(arg2->floatval) == 1)\n-                ret = 1;\n-            else\n-                ret = 0;\n-            } else if (xmlXPathIsInf(arg1->floatval) == -1) {\n-            if (xmlXPathIsInf(arg2->floatval) == -1)\n-                ret = 1;\n-            else\n-                ret = 0;\n-            } else if (xmlXPathIsInf(arg2->floatval) == 1) {\n-            if (xmlXPathIsInf(arg1->floatval) == 1)\n-                ret = 1;\n-            else\n-                ret = 0;\n-            } else if (xmlXPathIsInf(arg2->floatval) == -1) {\n-            if (xmlXPathIsInf(arg1->floatval) == -1)\n-                ret = 1;\n-            else\n-                ret = 0;\n-            } else {\n-                ret = (arg1->floatval == arg2->floatval);\n+                    break;\n+                case XPATH_BOOLEAN:\n+                    if ((arg1->stringval == NULL) ||\n+                        (arg1->stringval[0] == 0)) ret = 0;\n+                    else\n+                        ret = 1;\n+                    ret = (arg2->boolval == ret);\n+                    break;\n+                case XPATH_STRING:\n+                    ret = xmlStrEqual(arg1->stringval, arg2->stringval);\n+                    break;\n+                case XPATH_NUMBER:\n+                    valuePush(ctxt, arg1);\n+                    xmlXPathNumberFunction(ctxt, 1);\n+                    arg1 = valuePop(ctxt);\n+                    \/* Hand check NaN and Infinity equalities *\/\n+                    if (xmlXPathIsNaN(arg1->floatval) ||\n+                            xmlXPathIsNaN(arg2->floatval)) {\n+                        ret = 0;\n+                    } else if (xmlXPathIsInf(arg1->floatval) == 1) {\n+                        if (xmlXPathIsInf(arg2->floatval) == 1)\n+                            ret = 1;\n+                        else\n+                            ret = 0;\n+                    } else if (xmlXPathIsInf(arg1->floatval) == -1) {\n+                        if (xmlXPathIsInf(arg2->floatval) == -1)\n+                            ret = 1;\n+                        else\n+                            ret = 0;\n+                    } else if (xmlXPathIsInf(arg2->floatval) == 1) {\n+                        if (xmlXPathIsInf(arg1->floatval) == 1)\n+                            ret = 1;\n+                        else\n+                            ret = 0;\n+                    } else if (xmlXPathIsInf(arg2->floatval) == -1) {\n+                        if (xmlXPathIsInf(arg1->floatval) == -1)\n+                            ret = 1;\n+                        else\n+                            ret = 0;\n+                    } else {\n+                        ret = (arg1->floatval == arg2->floatval);\n+                    }\n+                    break;\n+                case XPATH_USERS:\n+                case XPATH_POINT:\n+                case XPATH_RANGE:\n+                case XPATH_LOCATIONSET:\n+                    TODO\n+                    break;\n+                case XPATH_NODESET:\n+                case XPATH_XSLT_TREE:\n+                    break;\n@@ -7114,11 +7125,0 @@\n-        }\n-        break;\n-        case XPATH_USERS:\n-    case XPATH_POINT:\n-    case XPATH_RANGE:\n-    case XPATH_LOCATIONSET:\n-        TODO\n-        break;\n-    case XPATH_NODESET:\n-    case XPATH_XSLT_TREE:\n-        break;\n@@ -7148,5 +7148,5 @@\n-    if (arg1 != NULL)\n-        xmlXPathReleaseObject(ctxt->context, arg1);\n-    else\n-        xmlXPathReleaseObject(ctxt->context, arg2);\n-    XP_ERROR0(XPATH_INVALID_OPERAND);\n+        if (arg1 != NULL)\n+            xmlXPathReleaseObject(ctxt->context, arg1);\n+        else\n+            xmlXPathReleaseObject(ctxt->context, arg2);\n+        XP_ERROR0(XPATH_INVALID_OPERAND);\n@@ -7158,1 +7158,1 @@\n-        \"Equal: by pointer\\n\");\n+                \"Equal: by pointer\\n\");\n@@ -7160,1 +7160,1 @@\n-    xmlXPathFreeObject(arg1);\n+        xmlXPathFreeObject(arg1);\n@@ -7169,10 +7169,10 @@\n-    \/*\n-     *Hack it to assure arg1 is the nodeset\n-     *\/\n-    if ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)) {\n-        argtmp = arg2;\n-        arg2 = arg1;\n-        arg1 = argtmp;\n-    }\n-    switch (arg2->type) {\n-        case XPATH_UNDEFINED:\n+        \/*\n+         *Hack it to assure arg1 is the nodeset\n+         *\/\n+        if ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)) {\n+                argtmp = arg2;\n+                arg2 = arg1;\n+                arg1 = argtmp;\n+        }\n+        switch (arg2->type) {\n+            case XPATH_UNDEFINED:\n@@ -7180,2 +7180,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"Equal: undefined\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"Equal: undefined\\n\");\n@@ -7183,28 +7183,28 @@\n-        break;\n-        case XPATH_NODESET:\n-        case XPATH_XSLT_TREE:\n-        ret = xmlXPathEqualNodeSets(arg1, arg2, 0);\n-        break;\n-        case XPATH_BOOLEAN:\n-        if ((arg1->nodesetval == NULL) ||\n-          (arg1->nodesetval->nodeNr == 0)) ret = 0;\n-        else\n-            ret = 1;\n-        ret = (ret == arg2->boolval);\n-        break;\n-        case XPATH_NUMBER:\n-        ret = xmlXPathEqualNodeSetFloat(ctxt, arg1, arg2->floatval, 0);\n-        break;\n-        case XPATH_STRING:\n-        ret = xmlXPathEqualNodeSetString(arg1, arg2->stringval, 0);\n-        break;\n-        case XPATH_USERS:\n-        case XPATH_POINT:\n-        case XPATH_RANGE:\n-        case XPATH_LOCATIONSET:\n-        TODO\n-        break;\n-    }\n-    xmlXPathReleaseObject(ctxt->context, arg1);\n-    xmlXPathReleaseObject(ctxt->context, arg2);\n-    return(ret);\n+                break;\n+            case XPATH_NODESET:\n+            case XPATH_XSLT_TREE:\n+                ret = xmlXPathEqualNodeSets(arg1, arg2, 0);\n+                break;\n+            case XPATH_BOOLEAN:\n+                if ((arg1->nodesetval == NULL) ||\n+                  (arg1->nodesetval->nodeNr == 0)) ret = 0;\n+                else\n+                    ret = 1;\n+                ret = (ret == arg2->boolval);\n+                break;\n+            case XPATH_NUMBER:\n+                ret = xmlXPathEqualNodeSetFloat(ctxt, arg1, arg2->floatval, 0);\n+                break;\n+            case XPATH_STRING:\n+                ret = xmlXPathEqualNodeSetString(arg1, arg2->stringval, 0);\n+                break;\n+            case XPATH_USERS:\n+            case XPATH_POINT:\n+            case XPATH_RANGE:\n+            case XPATH_LOCATIONSET:\n+                TODO\n+                break;\n+        }\n+        xmlXPathReleaseObject(ctxt->context, arg1);\n+        xmlXPathReleaseObject(ctxt->context, arg2);\n+        return(ret);\n@@ -7233,5 +7233,5 @@\n-    if (arg1 != NULL)\n-        xmlXPathReleaseObject(ctxt->context, arg1);\n-    else\n-        xmlXPathReleaseObject(ctxt->context, arg2);\n-    XP_ERROR0(XPATH_INVALID_OPERAND);\n+        if (arg1 != NULL)\n+            xmlXPathReleaseObject(ctxt->context, arg1);\n+        else\n+            xmlXPathReleaseObject(ctxt->context, arg2);\n+        XP_ERROR0(XPATH_INVALID_OPERAND);\n@@ -7243,1 +7243,1 @@\n-        \"NotEqual: by pointer\\n\");\n+                \"NotEqual: by pointer\\n\");\n@@ -7245,1 +7245,1 @@\n-    xmlXPathReleaseObject(ctxt->context, arg1);\n+        xmlXPathReleaseObject(ctxt->context, arg1);\n@@ -7254,10 +7254,10 @@\n-    \/*\n-     *Hack it to assure arg1 is the nodeset\n-     *\/\n-    if ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)) {\n-        argtmp = arg2;\n-        arg2 = arg1;\n-        arg1 = argtmp;\n-    }\n-    switch (arg2->type) {\n-        case XPATH_UNDEFINED:\n+        \/*\n+         *Hack it to assure arg1 is the nodeset\n+         *\/\n+        if ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)) {\n+                argtmp = arg2;\n+                arg2 = arg1;\n+                arg1 = argtmp;\n+        }\n+        switch (arg2->type) {\n+            case XPATH_UNDEFINED:\n@@ -7265,2 +7265,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"NotEqual: undefined\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"NotEqual: undefined\\n\");\n@@ -7268,28 +7268,28 @@\n-        break;\n-        case XPATH_NODESET:\n-        case XPATH_XSLT_TREE:\n-        ret = xmlXPathEqualNodeSets(arg1, arg2, 1);\n-        break;\n-        case XPATH_BOOLEAN:\n-        if ((arg1->nodesetval == NULL) ||\n-          (arg1->nodesetval->nodeNr == 0)) ret = 0;\n-        else\n-            ret = 1;\n-        ret = (ret != arg2->boolval);\n-        break;\n-        case XPATH_NUMBER:\n-        ret = xmlXPathEqualNodeSetFloat(ctxt, arg1, arg2->floatval, 1);\n-        break;\n-        case XPATH_STRING:\n-        ret = xmlXPathEqualNodeSetString(arg1, arg2->stringval,1);\n-        break;\n-        case XPATH_USERS:\n-        case XPATH_POINT:\n-        case XPATH_RANGE:\n-        case XPATH_LOCATIONSET:\n-        TODO\n-        break;\n-    }\n-    xmlXPathReleaseObject(ctxt->context, arg1);\n-    xmlXPathReleaseObject(ctxt->context, arg2);\n-    return(ret);\n+                break;\n+            case XPATH_NODESET:\n+            case XPATH_XSLT_TREE:\n+                ret = xmlXPathEqualNodeSets(arg1, arg2, 1);\n+                break;\n+            case XPATH_BOOLEAN:\n+                if ((arg1->nodesetval == NULL) ||\n+                  (arg1->nodesetval->nodeNr == 0)) ret = 0;\n+                else\n+                    ret = 1;\n+                ret = (ret != arg2->boolval);\n+                break;\n+            case XPATH_NUMBER:\n+                ret = xmlXPathEqualNodeSetFloat(ctxt, arg1, arg2->floatval, 1);\n+                break;\n+            case XPATH_STRING:\n+                ret = xmlXPathEqualNodeSetString(arg1, arg2->stringval,1);\n+                break;\n+            case XPATH_USERS:\n+            case XPATH_POINT:\n+            case XPATH_RANGE:\n+            case XPATH_LOCATIONSET:\n+                TODO\n+                break;\n+        }\n+        xmlXPathReleaseObject(ctxt->context, arg1);\n+        xmlXPathReleaseObject(ctxt->context, arg2);\n+        return(ret);\n@@ -7334,5 +7334,5 @@\n-    if (arg1 != NULL)\n-        xmlXPathReleaseObject(ctxt->context, arg1);\n-    else\n-        xmlXPathReleaseObject(ctxt->context, arg2);\n-    XP_ERROR0(XPATH_INVALID_OPERAND);\n+        if (arg1 != NULL)\n+            xmlXPathReleaseObject(ctxt->context, arg1);\n+        else\n+            xmlXPathReleaseObject(ctxt->context, arg2);\n+        XP_ERROR0(XPATH_INVALID_OPERAND);\n@@ -7343,12 +7343,8 @@\n-    \/*\n-     * If either argument is a XPATH_NODESET or XPATH_XSLT_TREE the two arguments\n-     * are not freed from within this routine; they will be freed from the\n-     * called routine, e.g. xmlXPathCompareNodeSets or xmlXPathCompareNodeSetValue\n-     *\/\n-    if (((arg2->type == XPATH_NODESET) || (arg2->type == XPATH_XSLT_TREE)) &&\n-      ((arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE))){\n-        ret = xmlXPathCompareNodeSets(inf, strict, arg1, arg2);\n-    } else {\n-        if ((arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE)) {\n-        ret = xmlXPathCompareNodeSetValue(ctxt, inf, strict,\n-                                      arg1, arg2);\n+        \/*\n+         * If either argument is a XPATH_NODESET or XPATH_XSLT_TREE the two arguments\n+         * are not freed from within this routine; they will be freed from the\n+         * called routine, e.g. xmlXPathCompareNodeSets or xmlXPathCompareNodeSetValue\n+         *\/\n+        if (((arg2->type == XPATH_NODESET) || (arg2->type == XPATH_XSLT_TREE)) &&\n+          ((arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE))){\n+            ret = xmlXPathCompareNodeSets(inf, strict, arg1, arg2);\n@@ -7356,2 +7352,7 @@\n-        ret = xmlXPathCompareNodeSetValue(ctxt, !inf, strict,\n-                                      arg2, arg1);\n+            if ((arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE)) {\n+                ret = xmlXPathCompareNodeSetValue(ctxt, inf, strict,\n+                                                  arg1, arg2);\n+            } else {\n+                ret = xmlXPathCompareNodeSetValue(ctxt, !inf, strict,\n+                                                  arg2, arg1);\n+            }\n@@ -7359,2 +7360,1 @@\n-    }\n-    return(ret);\n+        return(ret);\n@@ -7364,3 +7364,3 @@\n-    valuePush(ctxt, arg1);\n-    xmlXPathNumberFunction(ctxt, 1);\n-    arg1 = valuePop(ctxt);\n+        valuePush(ctxt, arg1);\n+        xmlXPathNumberFunction(ctxt, 1);\n+        arg1 = valuePop(ctxt);\n@@ -7369,3 +7369,3 @@\n-    xmlXPathFreeObject(arg1);\n-    xmlXPathFreeObject(arg2);\n-    XP_ERROR0(XPATH_INVALID_OPERAND);\n+        xmlXPathFreeObject(arg1);\n+        xmlXPathFreeObject(arg2);\n+        XP_ERROR0(XPATH_INVALID_OPERAND);\n@@ -7374,3 +7374,3 @@\n-    valuePush(ctxt, arg2);\n-    xmlXPathNumberFunction(ctxt, 1);\n-    arg2 = valuePop(ctxt);\n+        valuePush(ctxt, arg2);\n+        xmlXPathNumberFunction(ctxt, 1);\n+        arg2 = valuePop(ctxt);\n@@ -7379,3 +7379,3 @@\n-    xmlXPathReleaseObject(ctxt->context, arg1);\n-    xmlXPathReleaseObject(ctxt->context, arg2);\n-    XP_ERROR0(XPATH_INVALID_OPERAND);\n+        xmlXPathReleaseObject(ctxt->context, arg1);\n+        xmlXPathReleaseObject(ctxt->context, arg2);\n+        XP_ERROR0(XPATH_INVALID_OPERAND);\n@@ -7389,1 +7389,1 @@\n-    ret=0;\n+        ret=0;\n@@ -7391,10 +7391,11 @@\n-    arg1i=xmlXPathIsInf(arg1->floatval);\n-    arg2i=xmlXPathIsInf(arg2->floatval);\n-    if (inf && strict) {\n-        if ((arg1i == -1 && arg2i != -1) ||\n-        (arg2i == 1 && arg1i != 1)) {\n-        ret = 1;\n-        } else if (arg1i == 0 && arg2i == 0) {\n-        ret = (arg1->floatval < arg2->floatval);\n-        } else {\n-        ret = 0;\n+        arg1i=xmlXPathIsInf(arg1->floatval);\n+        arg2i=xmlXPathIsInf(arg2->floatval);\n+        if (inf && strict) {\n+            if ((arg1i == -1 && arg2i != -1) ||\n+                (arg2i == 1 && arg1i != 1)) {\n+                ret = 1;\n+            } else if (arg1i == 0 && arg2i == 0) {\n+                ret = (arg1->floatval < arg2->floatval);\n+            } else {\n+                ret = 0;\n+            }\n@@ -7402,8 +7403,8 @@\n-    }\n-    else if (inf && !strict) {\n-        if (arg1i == -1 || arg2i == 1) {\n-        ret = 1;\n-        } else if (arg1i == 0 && arg2i == 0) {\n-        ret = (arg1->floatval <= arg2->floatval);\n-        } else {\n-        ret = 0;\n+        else if (inf && !strict) {\n+            if (arg1i == -1 || arg2i == 1) {\n+                ret = 1;\n+            } else if (arg1i == 0 && arg2i == 0) {\n+                ret = (arg1->floatval <= arg2->floatval);\n+            } else {\n+                ret = 0;\n+            }\n@@ -7411,9 +7412,9 @@\n-    }\n-    else if (!inf && strict) {\n-        if ((arg1i == 1 && arg2i != 1) ||\n-        (arg2i == -1 && arg1i != -1)) {\n-        ret = 1;\n-        } else if (arg1i == 0 && arg2i == 0) {\n-        ret = (arg1->floatval > arg2->floatval);\n-        } else {\n-        ret = 0;\n+        else if (!inf && strict) {\n+            if ((arg1i == 1 && arg2i != 1) ||\n+                (arg2i == -1 && arg1i != -1)) {\n+                ret = 1;\n+            } else if (arg1i == 0 && arg2i == 0) {\n+                ret = (arg1->floatval > arg2->floatval);\n+            } else {\n+                ret = 0;\n+            }\n@@ -7421,8 +7422,8 @@\n-    }\n-    else if (!inf && !strict) {\n-        if (arg1i == 1 || arg2i == -1) {\n-        ret = 1;\n-        } else if (arg1i == 0 && arg2i == 0) {\n-        ret = (arg1->floatval >= arg2->floatval);\n-        } else {\n-        ret = 0;\n+        else if (!inf && !strict) {\n+            if (arg1i == 1 || arg2i == -1) {\n+                ret = 1;\n+            } else if (arg1i == 0 && arg2i == 0) {\n+                ret = (arg1->floatval >= arg2->floatval);\n+            } else {\n+                ret = 0;\n+            }\n@@ -7431,1 +7432,0 @@\n-    }\n@@ -7468,1 +7468,1 @@\n-    XP_ERROR(XPATH_INVALID_OPERAND);\n+        XP_ERROR(XPATH_INVALID_OPERAND);\n@@ -7491,1 +7491,1 @@\n-    XP_ERROR(XPATH_INVALID_OPERAND);\n+        XP_ERROR(XPATH_INVALID_OPERAND);\n@@ -7514,1 +7514,1 @@\n-    XP_ERROR(XPATH_INVALID_OPERAND);\n+        XP_ERROR(XPATH_INVALID_OPERAND);\n@@ -7538,1 +7538,1 @@\n-    XP_ERROR(XPATH_INVALID_OPERAND);\n+        XP_ERROR(XPATH_INVALID_OPERAND);\n@@ -7561,1 +7561,1 @@\n-    XP_ERROR(XPATH_INVALID_OPERAND);\n+        XP_ERROR(XPATH_INVALID_OPERAND);\n@@ -7568,1 +7568,1 @@\n-    ctxt->value->floatval = xmlXPathNAN;\n+        ctxt->value->floatval = xmlXPathNAN;\n@@ -7570,1 +7570,1 @@\n-    ctxt->value->floatval = fmod(arg1, arg2);\n+        ctxt->value->floatval = fmod(arg1, arg2);\n@@ -7575,3 +7575,3 @@\n- *                                  *\n- *      The traversal functions                 *\n- *                                  *\n+ *                                                                      *\n+ *              The traversal functions                                 *\n+ *                                                                      *\n@@ -7603,1 +7603,1 @@\n-            (xmlNodeSetPtr, xmlNodeSetPtr);\n+                    (xmlNodeSetPtr, xmlNodeSetPtr);\n@@ -7638,2 +7638,2 @@\n-    if (ctxt->context->node == NULL) return(NULL);\n-    switch (ctxt->context->node->type) {\n+        if (ctxt->context->node == NULL) return(NULL);\n+        switch (ctxt->context->node->type) {\n@@ -7649,1 +7649,1 @@\n-        return(ctxt->context->node->children);\n+                return(ctxt->context->node->children);\n@@ -7655,1 +7655,1 @@\n-        case XML_DOCB_DOCUMENT_NODE:\n+            case XML_DOCB_DOCUMENT_NODE:\n@@ -7657,4 +7657,4 @@\n-        return(((xmlDocPtr) ctxt->context->node)->children);\n-        case XML_ELEMENT_DECL:\n-        case XML_ATTRIBUTE_DECL:\n-        case XML_ENTITY_DECL:\n+                return(((xmlDocPtr) ctxt->context->node)->children);\n+            case XML_ELEMENT_DECL:\n+            case XML_ATTRIBUTE_DECL:\n+            case XML_ENTITY_DECL:\n@@ -7662,3 +7662,5 @@\n-        case XML_NAMESPACE_DECL:\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n+            case XML_NAMESPACE_DECL:\n+            case XML_XINCLUDE_START:\n+            case XML_XINCLUDE_END:\n+                return(NULL);\n+        }\n@@ -7667,2 +7669,0 @@\n-    return(NULL);\n-    }\n@@ -7671,1 +7671,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -7689,6 +7689,6 @@\n-    cur = ctxt->context->node;\n-    if (cur == NULL) return(NULL);\n-    \/*\n-    * Get the first element child.\n-    *\/\n-    switch (cur->type) {\n+        cur = ctxt->context->node;\n+        if (cur == NULL) return(NULL);\n+        \/*\n+        * Get the first element child.\n+        *\/\n+        switch (cur->type) {\n@@ -7696,2 +7696,2 @@\n-        case XML_DOCUMENT_FRAG_NODE:\n-        case XML_ENTITY_REF_NODE: \/* URGENT TODO: entify-refs as well? *\/\n+            case XML_DOCUMENT_FRAG_NODE:\n+            case XML_ENTITY_REF_NODE: \/* URGENT TODO: entify-refs as well? *\/\n@@ -7699,11 +7699,11 @@\n-        cur = cur->children;\n-        if (cur != NULL) {\n-            if (cur->type == XML_ELEMENT_NODE)\n-            return(cur);\n-            do {\n-            cur = cur->next;\n-            } while ((cur != NULL) &&\n-            (cur->type != XML_ELEMENT_NODE));\n-            return(cur);\n-        }\n-        return(NULL);\n+                cur = cur->children;\n+                if (cur != NULL) {\n+                    if (cur->type == XML_ELEMENT_NODE)\n+                        return(cur);\n+                    do {\n+                        cur = cur->next;\n+                    } while ((cur != NULL) &&\n+                        (cur->type != XML_ELEMENT_NODE));\n+                    return(cur);\n+                }\n+                return(NULL);\n@@ -7713,1 +7713,1 @@\n-        case XML_DOCB_DOCUMENT_NODE:\n+            case XML_DOCB_DOCUMENT_NODE:\n@@ -7715,2 +7715,4 @@\n-        return(xmlDocGetRootElement((xmlDocPtr) cur));\n-        default:\n+                return(xmlDocGetRootElement((xmlDocPtr) cur));\n+            default:\n+                return(NULL);\n+        }\n@@ -7719,2 +7721,0 @@\n-    return(NULL);\n-    }\n@@ -7725,12 +7725,12 @@\n-    case XML_ELEMENT_NODE:\n-    case XML_TEXT_NODE:\n-    case XML_ENTITY_REF_NODE:\n-    case XML_ENTITY_NODE:\n-    case XML_CDATA_SECTION_NODE:\n-    case XML_PI_NODE:\n-    case XML_COMMENT_NODE:\n-    case XML_XINCLUDE_END:\n-        break;\n-    \/* case XML_DTD_NODE: *\/ \/* URGENT TODO: DTD-node as well? *\/\n-    default:\n-        return(NULL);\n+        case XML_ELEMENT_NODE:\n+        case XML_TEXT_NODE:\n+        case XML_ENTITY_REF_NODE:\n+        case XML_ENTITY_NODE:\n+        case XML_CDATA_SECTION_NODE:\n+        case XML_PI_NODE:\n+        case XML_COMMENT_NODE:\n+        case XML_XINCLUDE_END:\n+            break;\n+        \/* case XML_DTD_NODE: *\/ \/* URGENT TODO: DTD-node as well? *\/\n+        default:\n+            return(NULL);\n@@ -7739,4 +7739,2 @@\n-    if (cur->next->type == XML_ELEMENT_NODE)\n-        return(cur->next);\n-    cur = cur->next;\n-    do {\n+        if (cur->next->type == XML_ELEMENT_NODE)\n+            return(cur->next);\n@@ -7744,2 +7742,4 @@\n-    } while ((cur != NULL) && (cur->type != XML_ELEMENT_NODE));\n-    return(cur);\n+        do {\n+            cur = cur->next;\n+        } while ((cur != NULL) && (cur->type != XML_ELEMENT_NODE));\n+        return(cur);\n@@ -7765,1 +7765,1 @@\n-                       xmlNodePtr contextNode)\n+                                       xmlNodePtr contextNode)\n@@ -7768,7 +7768,7 @@\n-    if (contextNode == NULL)\n-        return(NULL);\n-    switch (contextNode->type) {\n-        case XML_ELEMENT_NODE:\n-        case XML_XINCLUDE_START:\n-        case XML_DOCUMENT_FRAG_NODE:\n-        case XML_DOCUMENT_NODE:\n+        if (contextNode == NULL)\n+            return(NULL);\n+        switch (contextNode->type) {\n+            case XML_ELEMENT_NODE:\n+            case XML_XINCLUDE_START:\n+            case XML_DOCUMENT_FRAG_NODE:\n+            case XML_DOCUMENT_NODE:\n@@ -7776,1 +7776,1 @@\n-        case XML_DOCB_DOCUMENT_NODE:\n+            case XML_DOCB_DOCUMENT_NODE:\n@@ -7778,3 +7778,5 @@\n-        case XML_HTML_DOCUMENT_NODE:\n-        return(contextNode);\n-        default:\n+            case XML_HTML_DOCUMENT_NODE:\n+                return(contextNode);\n+            default:\n+                return(NULL);\n+        }\n@@ -7782,2 +7784,0 @@\n-    }\n-    return(NULL);\n@@ -7785,1 +7785,1 @@\n-    xmlNodePtr start = cur;\n+        xmlNodePtr start = cur;\n@@ -7787,15 +7787,15 @@\n-    while (cur != NULL) {\n-        switch (cur->type) {\n-        case XML_ELEMENT_NODE:\n-        \/* TODO: OK to have XInclude here? *\/\n-        case XML_XINCLUDE_START:\n-        case XML_DOCUMENT_FRAG_NODE:\n-            if (cur != start)\n-            return(cur);\n-            if (cur->children != NULL) {\n-            cur = cur->children;\n-            continue;\n-            }\n-            break;\n-        \/* Not sure if we need those here. *\/\n-        case XML_DOCUMENT_NODE:\n+        while (cur != NULL) {\n+            switch (cur->type) {\n+                case XML_ELEMENT_NODE:\n+                \/* TODO: OK to have XInclude here? *\/\n+                case XML_XINCLUDE_START:\n+                case XML_DOCUMENT_FRAG_NODE:\n+                    if (cur != start)\n+                        return(cur);\n+                    if (cur->children != NULL) {\n+                        cur = cur->children;\n+                        continue;\n+                    }\n+                    break;\n+                \/* Not sure if we need those here. *\/\n+                case XML_DOCUMENT_NODE:\n@@ -7803,1 +7803,1 @@\n-        case XML_DOCB_DOCUMENT_NODE:\n+                case XML_DOCB_DOCUMENT_NODE:\n@@ -7805,7 +7805,7 @@\n-        case XML_HTML_DOCUMENT_NODE:\n-            if (cur != start)\n-            return(cur);\n-            return(xmlDocGetRootElement((xmlDocPtr) cur));\n-        default:\n-            break;\n-        }\n+                case XML_HTML_DOCUMENT_NODE:\n+                    if (cur != start)\n+                        return(cur);\n+                    return(xmlDocGetRootElement((xmlDocPtr) cur));\n+                default:\n+                    break;\n+            }\n@@ -7814,7 +7814,8 @@\n-        if ((cur == NULL) || (cur == contextNode))\n-        return(NULL);\n-        if (cur->next != NULL) {\n-        cur = cur->next;\n-        } else {\n-        cur = cur->parent;\n-        goto next_sibling;\n+            if ((cur == NULL) || (cur == contextNode))\n+                return(NULL);\n+            if (cur->next != NULL) {\n+                cur = cur->next;\n+            } else {\n+                cur = cur->parent;\n+                goto next_sibling;\n+            }\n@@ -7823,1 +7824,0 @@\n-    }\n@@ -7843,5 +7843,5 @@\n-    if (ctxt->context->node == NULL)\n-        return(NULL);\n-    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n-        (ctxt->context->node->type == XML_NAMESPACE_DECL))\n-        return(NULL);\n+        if (ctxt->context->node == NULL)\n+            return(NULL);\n+        if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n+            (ctxt->context->node->type == XML_NAMESPACE_DECL))\n+            return(NULL);\n@@ -7850,1 +7850,1 @@\n-        return(ctxt->context->doc->children);\n+            return(ctxt->context->doc->children);\n@@ -7857,5 +7857,0 @@\n-    \/*\n-     * Do not descend on entities declarations\n-     *\/\n-    if (cur->children->type != XML_ENTITY_DECL) {\n-        cur = cur->children;\n@@ -7863,1 +7858,1 @@\n-         * Skip DTDs\n+         * Do not descend on entities declarations\n@@ -7865,3 +7860,8 @@\n-        if (cur->type != XML_DTD_NODE)\n-        return(cur);\n-    }\n+        if (cur->children->type != XML_ENTITY_DECL) {\n+            cur = cur->children;\n+            \/*\n+             * Skip DTDs\n+             *\/\n+            if (cur->type != XML_DTD_NODE)\n+                return(cur);\n+        }\n@@ -7873,4 +7873,4 @@\n-    cur = cur->next;\n-    if ((cur->type != XML_ENTITY_DECL) &&\n-        (cur->type != XML_DTD_NODE))\n-        return(cur);\n+        cur = cur->next;\n+        if ((cur->type != XML_ENTITY_DECL) &&\n+            (cur->type != XML_DTD_NODE))\n+            return(cur);\n@@ -7881,6 +7881,6 @@\n-    if (cur == NULL) break;\n-    if (cur == ctxt->context->node) return(NULL);\n-    if (cur->next != NULL) {\n-        cur = cur->next;\n-        return(cur);\n-    }\n+        if (cur == NULL) break;\n+        if (cur == ctxt->context->node) return(NULL);\n+        if (cur->next != NULL) {\n+            cur = cur->next;\n+            return(cur);\n+        }\n@@ -7938,2 +7938,2 @@\n-    if (ctxt->context->node == NULL) return(NULL);\n-    switch (ctxt->context->node->type) {\n+        if (ctxt->context->node == NULL) return(NULL);\n+        switch (ctxt->context->node->type) {\n@@ -7949,13 +7949,13 @@\n-        case XML_ELEMENT_DECL:\n-        case XML_ATTRIBUTE_DECL:\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-        case XML_ENTITY_DECL:\n-        if (ctxt->context->node->parent == NULL)\n-            return((xmlNodePtr) ctxt->context->doc);\n-        if ((ctxt->context->node->parent->type == XML_ELEMENT_NODE) &&\n-            ((ctxt->context->node->parent->name[0] == ' ') ||\n-             (xmlStrEqual(ctxt->context->node->parent->name,\n-                 BAD_CAST \"fake node libxslt\"))))\n-            return(NULL);\n-        return(ctxt->context->node->parent);\n+            case XML_ELEMENT_DECL:\n+            case XML_ATTRIBUTE_DECL:\n+            case XML_XINCLUDE_START:\n+            case XML_XINCLUDE_END:\n+            case XML_ENTITY_DECL:\n+                if (ctxt->context->node->parent == NULL)\n+                    return((xmlNodePtr) ctxt->context->doc);\n+                if ((ctxt->context->node->parent->type == XML_ELEMENT_NODE) &&\n+                    ((ctxt->context->node->parent->name[0] == ' ') ||\n+                     (xmlStrEqual(ctxt->context->node->parent->name,\n+                                 BAD_CAST \"fake node libxslt\"))))\n+                    return(NULL);\n+                return(ctxt->context->node->parent);\n@@ -7963,1 +7963,1 @@\n-        xmlAttrPtr att = (xmlAttrPtr) ctxt->context->node;\n+                xmlAttrPtr att = (xmlAttrPtr) ctxt->context->node;\n@@ -7965,2 +7965,2 @@\n-        return(att->parent);\n-        }\n+                return(att->parent);\n+            }\n@@ -7972,1 +7972,1 @@\n-        case XML_DOCB_DOCUMENT_NODE:\n+            case XML_DOCB_DOCUMENT_NODE:\n@@ -7975,2 +7975,2 @@\n-        case XML_NAMESPACE_DECL: {\n-        xmlNsPtr ns = (xmlNsPtr) ctxt->context->node;\n+            case XML_NAMESPACE_DECL: {\n+                xmlNsPtr ns = (xmlNsPtr) ctxt->context->node;\n@@ -7978,3 +7978,3 @@\n-        if ((ns->next != NULL) &&\n-            (ns->next->type != XML_NAMESPACE_DECL))\n-            return((xmlNodePtr) ns->next);\n+                if ((ns->next != NULL) &&\n+                    (ns->next->type != XML_NAMESPACE_DECL))\n+                    return((xmlNodePtr) ns->next);\n@@ -7982,0 +7982,1 @@\n+            }\n@@ -7984,1 +7985,0 @@\n-    }\n@@ -8011,2 +8011,2 @@\n-    if (ctxt->context->node == NULL) return(NULL);\n-    switch (ctxt->context->node->type) {\n+        if (ctxt->context->node == NULL) return(NULL);\n+        switch (ctxt->context->node->type) {\n@@ -8020,4 +8020,4 @@\n-        case XML_DTD_NODE:\n-        case XML_ELEMENT_DECL:\n-        case XML_ATTRIBUTE_DECL:\n-        case XML_ENTITY_DECL:\n+            case XML_DTD_NODE:\n+            case XML_ELEMENT_DECL:\n+            case XML_ATTRIBUTE_DECL:\n+            case XML_ENTITY_DECL:\n@@ -8025,10 +8025,10 @@\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-        if (ctxt->context->node->parent == NULL)\n-            return((xmlNodePtr) ctxt->context->doc);\n-        if ((ctxt->context->node->parent->type == XML_ELEMENT_NODE) &&\n-            ((ctxt->context->node->parent->name[0] == ' ') ||\n-             (xmlStrEqual(ctxt->context->node->parent->name,\n-                 BAD_CAST \"fake node libxslt\"))))\n-            return(NULL);\n-        return(ctxt->context->node->parent);\n+            case XML_XINCLUDE_START:\n+            case XML_XINCLUDE_END:\n+                if (ctxt->context->node->parent == NULL)\n+                    return((xmlNodePtr) ctxt->context->doc);\n+                if ((ctxt->context->node->parent->type == XML_ELEMENT_NODE) &&\n+                    ((ctxt->context->node->parent->name[0] == ' ') ||\n+                     (xmlStrEqual(ctxt->context->node->parent->name,\n+                                 BAD_CAST \"fake node libxslt\"))))\n+                    return(NULL);\n+                return(ctxt->context->node->parent);\n@@ -8036,1 +8036,1 @@\n-        xmlAttrPtr tmp = (xmlAttrPtr) ctxt->context->node;\n+                xmlAttrPtr tmp = (xmlAttrPtr) ctxt->context->node;\n@@ -8038,2 +8038,2 @@\n-        return(tmp->parent);\n-        }\n+                return(tmp->parent);\n+            }\n@@ -8045,1 +8045,1 @@\n-        case XML_DOCB_DOCUMENT_NODE:\n+            case XML_DOCB_DOCUMENT_NODE:\n@@ -8048,2 +8048,2 @@\n-        case XML_NAMESPACE_DECL: {\n-        xmlNsPtr ns = (xmlNsPtr) ctxt->context->node;\n+            case XML_NAMESPACE_DECL: {\n+                xmlNsPtr ns = (xmlNsPtr) ctxt->context->node;\n@@ -8051,4 +8051,4 @@\n-        if ((ns->next != NULL) &&\n-            (ns->next->type != XML_NAMESPACE_DECL))\n-            return((xmlNodePtr) ns->next);\n-        \/* Bad, how did that namespace end up here ? *\/\n+                if ((ns->next != NULL) &&\n+                    (ns->next->type != XML_NAMESPACE_DECL))\n+                    return((xmlNodePtr) ns->next);\n+                \/* Bad, how did that namespace end up here ? *\/\n@@ -8056,0 +8056,1 @@\n+            }\n@@ -8057,2 +8058,1 @@\n-    }\n-    return(NULL);\n+        return(NULL);\n@@ -8061,1 +8061,1 @@\n-    return((xmlNodePtr) ctxt->context->doc);\n+        return((xmlNodePtr) ctxt->context->doc);\n@@ -8063,1 +8063,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -8065,9 +8065,9 @@\n-    case XML_ELEMENT_NODE:\n-    case XML_TEXT_NODE:\n-    case XML_CDATA_SECTION_NODE:\n-    case XML_ENTITY_REF_NODE:\n-    case XML_ENTITY_NODE:\n-    case XML_PI_NODE:\n-    case XML_COMMENT_NODE:\n-    case XML_NOTATION_NODE:\n-    case XML_DTD_NODE:\n+        case XML_ELEMENT_NODE:\n+        case XML_TEXT_NODE:\n+        case XML_CDATA_SECTION_NODE:\n+        case XML_ENTITY_REF_NODE:\n+        case XML_ENTITY_NODE:\n+        case XML_PI_NODE:\n+        case XML_COMMENT_NODE:\n+        case XML_NOTATION_NODE:\n+        case XML_DTD_NODE:\n@@ -8077,12 +8077,12 @@\n-    case XML_XINCLUDE_START:\n-    case XML_XINCLUDE_END:\n-        if (cur->parent == NULL)\n-        return(NULL);\n-        if ((cur->parent->type == XML_ELEMENT_NODE) &&\n-        ((cur->parent->name[0] == ' ') ||\n-         (xmlStrEqual(cur->parent->name,\n-                  BAD_CAST \"fake node libxslt\"))))\n-        return(NULL);\n-        return(cur->parent);\n-    case XML_ATTRIBUTE_NODE: {\n-        xmlAttrPtr att = (xmlAttrPtr) cur;\n+        case XML_XINCLUDE_START:\n+        case XML_XINCLUDE_END:\n+            if (cur->parent == NULL)\n+                return(NULL);\n+            if ((cur->parent->type == XML_ELEMENT_NODE) &&\n+                ((cur->parent->name[0] == ' ') ||\n+                 (xmlStrEqual(cur->parent->name,\n+                              BAD_CAST \"fake node libxslt\"))))\n+                return(NULL);\n+            return(cur->parent);\n+        case XML_ATTRIBUTE_NODE: {\n+            xmlAttrPtr att = (xmlAttrPtr) cur;\n@@ -8090,4 +8090,4 @@\n-        return(att->parent);\n-    }\n-    case XML_NAMESPACE_DECL: {\n-        xmlNsPtr ns = (xmlNsPtr) cur;\n+            return(att->parent);\n+        }\n+        case XML_NAMESPACE_DECL: {\n+            xmlNsPtr ns = (xmlNsPtr) cur;\n@@ -8095,4 +8095,4 @@\n-        if ((ns->next != NULL) &&\n-            (ns->next->type != XML_NAMESPACE_DECL))\n-            return((xmlNodePtr) ns->next);\n-        \/* Bad, how did that namespace end up here ? *\/\n+            if ((ns->next != NULL) &&\n+                (ns->next->type != XML_NAMESPACE_DECL))\n+                return((xmlNodePtr) ns->next);\n+            \/* Bad, how did that namespace end up here ? *\/\n@@ -8100,5 +8100,5 @@\n-    }\n-    case XML_DOCUMENT_NODE:\n-    case XML_DOCUMENT_TYPE_NODE:\n-    case XML_DOCUMENT_FRAG_NODE:\n-    case XML_HTML_DOCUMENT_NODE:\n+        }\n+        case XML_DOCUMENT_NODE:\n+        case XML_DOCUMENT_TYPE_NODE:\n+        case XML_DOCUMENT_FRAG_NODE:\n+        case XML_HTML_DOCUMENT_NODE:\n@@ -8106,1 +8106,1 @@\n-    case XML_DOCB_DOCUMENT_NODE:\n+        case XML_DOCB_DOCUMENT_NODE:\n@@ -8108,1 +8108,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -8149,2 +8149,2 @@\n-    (ctxt->context->node->type == XML_NAMESPACE_DECL))\n-    return(NULL);\n+        (ctxt->context->node->type == XML_NAMESPACE_DECL))\n+        return(NULL);\n@@ -8174,2 +8174,2 @@\n-    (ctxt->context->node->type == XML_NAMESPACE_DECL))\n-    return(NULL);\n+        (ctxt->context->node->type == XML_NAMESPACE_DECL))\n+        return(NULL);\n@@ -8181,3 +8181,3 @@\n-    cur = cur->prev;\n-    if (cur == NULL)\n-        return(ctxt->context->node->prev);\n+        cur = cur->prev;\n+        if (cur == NULL)\n+            return(ctxt->context->node->prev);\n@@ -8256,1 +8256,1 @@\n-    node = node->parent;\n+        node = node->parent;\n@@ -8292,1 +8292,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -8294,1 +8294,1 @@\n-    cur = cur->prev;\n+        cur = cur->prev;\n@@ -8349,1 +8349,1 @@\n-    cur = cur->prev;\n+        cur = cur->prev;\n@@ -8386,7 +8386,8 @@\n-        xmlFree(ctxt->context->tmpNsList);\n-    ctxt->context->tmpNsList =\n-        xmlGetNsList(ctxt->context->doc, ctxt->context->node);\n-    ctxt->context->tmpNsNr = 0;\n-    if (ctxt->context->tmpNsList != NULL) {\n-        while (ctxt->context->tmpNsList[ctxt->context->tmpNsNr] != NULL) {\n-        ctxt->context->tmpNsNr++;\n+            xmlFree(ctxt->context->tmpNsList);\n+        ctxt->context->tmpNsList =\n+            xmlGetNsList(ctxt->context->doc, ctxt->context->node);\n+        ctxt->context->tmpNsNr = 0;\n+        if (ctxt->context->tmpNsList != NULL) {\n+            while (ctxt->context->tmpNsList[ctxt->context->tmpNsNr] != NULL) {\n+                ctxt->context->tmpNsNr++;\n+            }\n@@ -8394,2 +8395,1 @@\n-    }\n-    return((xmlNodePtr) xmlXPathXMLNamespace);\n+        return((xmlNodePtr) xmlXPathXMLNamespace);\n@@ -8398,1 +8398,1 @@\n-    return (xmlNodePtr)ctxt->context->tmpNsList[--ctxt->context->tmpNsNr];\n+        return (xmlNodePtr)ctxt->context->tmpNsList[--ctxt->context->tmpNsNr];\n@@ -8400,4 +8400,4 @@\n-    if (ctxt->context->tmpNsList != NULL)\n-        xmlFree(ctxt->context->tmpNsList);\n-    ctxt->context->tmpNsList = NULL;\n-    return(NULL);\n+        if (ctxt->context->tmpNsList != NULL)\n+            xmlFree(ctxt->context->tmpNsList);\n+        ctxt->context->tmpNsList = NULL;\n+        return(NULL);\n@@ -8421,1 +8421,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -8423,1 +8423,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -8426,1 +8426,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -8433,3 +8433,3 @@\n- *                                  *\n- *      NodeTest Functions                  *\n- *                                  *\n+ *                                                                      *\n+ *              NodeTest Functions                                      *\n+ *                                                                      *\n@@ -8438,1 +8438,1 @@\n-#define IS_FUNCTION         200\n+#define IS_FUNCTION                     200\n@@ -8442,3 +8442,3 @@\n- *                                  *\n- *      Implicit tree core function library         *\n- *                                  *\n+ *                                                                      *\n+ *              Implicit tree core function library                     *\n+ *                                                                      *\n@@ -8456,1 +8456,1 @@\n-    return;\n+        return;\n@@ -8458,1 +8458,1 @@\n-    (xmlNodePtr) ctxt->context->doc));\n+        (xmlNodePtr) ctxt->context->doc));\n@@ -8462,2 +8462,2 @@\n- *                                  *\n- *      The explicit core function library          *\n+ *                                                                      *\n+ *              The explicit core function library                      *\n@@ -8465,1 +8465,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -8482,3 +8482,3 @@\n-    valuePush(ctxt,\n-        xmlXPathCacheNewFloat(ctxt->context,\n-        (double) ctxt->context->contextSize));\n+        valuePush(ctxt,\n+            xmlXPathCacheNewFloat(ctxt->context,\n+                (double) ctxt->context->contextSize));\n@@ -8486,2 +8486,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"last() : %d\\n\", ctxt->context->contextSize);\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"last() : %d\\n\", ctxt->context->contextSize);\n@@ -8490,1 +8490,1 @@\n-    XP_ERROR(XPATH_INVALID_CTXT_SIZE);\n+        XP_ERROR(XPATH_INVALID_CTXT_SIZE);\n@@ -8509,3 +8509,3 @@\n-    valuePush(ctxt,\n-          xmlXPathCacheNewFloat(ctxt->context,\n-        (double) ctxt->context->proximityPosition));\n+        valuePush(ctxt,\n+              xmlXPathCacheNewFloat(ctxt->context,\n+                (double) ctxt->context->proximityPosition));\n@@ -8513,2 +8513,2 @@\n-    xmlGenericError(xmlGenericErrorContext, \"position() : %d\\n\",\n-        ctxt->context->proximityPosition);\n+        xmlGenericError(xmlGenericErrorContext, \"position() : %d\\n\",\n+                ctxt->context->proximityPosition);\n@@ -8517,1 +8517,1 @@\n-    XP_ERROR(XPATH_INVALID_CTXT_POSITION);\n+        XP_ERROR(XPATH_INVALID_CTXT_POSITION);\n@@ -8535,3 +8535,3 @@\n-    ((ctxt->value->type != XPATH_NODESET) &&\n-     (ctxt->value->type != XPATH_XSLT_TREE)))\n-    XP_ERROR(XPATH_INVALID_TYPE);\n+        ((ctxt->value->type != XPATH_NODESET) &&\n+         (ctxt->value->type != XPATH_XSLT_TREE)))\n+        XP_ERROR(XPATH_INVALID_TYPE);\n@@ -8541,1 +8541,1 @@\n-    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, (double) 0));\n+        valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, (double) 0));\n@@ -8543,2 +8543,2 @@\n-    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context,\n-        (double) cur->nodesetval->nodeNr));\n+        valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context,\n+            (double) cur->nodesetval->nodeNr));\n@@ -8573,2 +8573,2 @@\n-    while ((!IS_BLANK_CH(*cur)) && (*cur != 0))\n-        cur++;\n+        while ((!IS_BLANK_CH(*cur)) && (*cur != 0))\n+            cur++;\n@@ -8577,16 +8577,16 @@\n-    if (ID != NULL) {\n-        \/*\n-         * We used to check the fact that the value passed\n-         * was an NCName, but this generated much troubles for\n-         * me and Aleksey Sanin, people blatantly violated that\n-         * constraint, like Visa3D spec.\n-         * if (xmlValidateNCName(ID, 1) == 0)\n-         *\/\n-        attr = xmlGetID(doc, ID);\n-        if (attr != NULL) {\n-        if (attr->type == XML_ATTRIBUTE_NODE)\n-            elem = attr->parent;\n-        else if (attr->type == XML_ELEMENT_NODE)\n-            elem = (xmlNodePtr) attr;\n-        else\n-            elem = NULL;\n+        if (ID != NULL) {\n+            \/*\n+             * We used to check the fact that the value passed\n+             * was an NCName, but this generated much troubles for\n+             * me and Aleksey Sanin, people blatantly violated that\n+             * constraint, like Visa3D spec.\n+             * if (xmlValidateNCName(ID, 1) == 0)\n+             *\/\n+            attr = xmlGetID(doc, ID);\n+            if (attr != NULL) {\n+                if (attr->type == XML_ATTRIBUTE_NODE)\n+                    elem = attr->parent;\n+                else if (attr->type == XML_ELEMENT_NODE)\n+                    elem = (xmlNodePtr) attr;\n+                else\n+                    elem = NULL;\n@@ -8594,2 +8594,4 @@\n-        if (elem != NULL)\n-            xmlXPathNodeSetAdd(ret, elem);\n+                if (elem != NULL)\n+                    xmlXPathNodeSetAdd(ret, elem);\n+            }\n+            xmlFree(ID);\n@@ -8597,2 +8599,0 @@\n-        xmlFree(ID);\n-    }\n@@ -8600,2 +8600,2 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n-    ids = cur;\n+        while (IS_BLANK_CH(*cur)) cur++;\n+        ids = cur;\n@@ -8634,2 +8634,2 @@\n-    xmlNodeSetPtr ns;\n-    int i;\n+        xmlNodeSetPtr ns;\n+        int i;\n@@ -8638,1 +8638,1 @@\n-    ret = xmlXPathNodeSetCreate(NULL);\n+        ret = xmlXPathNodeSetCreate(NULL);\n@@ -8640,5 +8640,5 @@\n-    if (obj->nodesetval != NULL) {\n-        for (i = 0; i < obj->nodesetval->nodeNr; i++) {\n-        tokens =\n-            xmlXPathCastNodeToString(obj->nodesetval->nodeTab[i]);\n-        ns = xmlXPathGetElementsByIds(ctxt->context->doc, tokens);\n+        if (obj->nodesetval != NULL) {\n+            for (i = 0; i < obj->nodesetval->nodeNr; i++) {\n+                tokens =\n+                    xmlXPathCastNodeToString(obj->nodesetval->nodeTab[i]);\n+                ns = xmlXPathGetElementsByIds(ctxt->context->doc, tokens);\n@@ -8646,4 +8646,5 @@\n-        ret = xmlXPathNodeSetMerge(ret, ns);\n-        xmlXPathFreeNodeSet(ns);\n-        if (tokens != NULL)\n-            xmlFree(tokens);\n+                ret = xmlXPathNodeSetMerge(ret, ns);\n+                xmlXPathFreeNodeSet(ns);\n+                if (tokens != NULL)\n+                    xmlFree(tokens);\n+            }\n@@ -8651,4 +8652,3 @@\n-    }\n-    xmlXPathReleaseObject(ctxt->context, obj);\n-    valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt->context, ret));\n-    return;\n+        xmlXPathReleaseObject(ctxt->context, obj);\n+        valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt->context, ret));\n+        return;\n@@ -8684,3 +8684,3 @@\n-    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n-        ctxt->context->node));\n-    nargs = 1;\n+        valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n+            ctxt->context->node));\n+        nargs = 1;\n@@ -8691,3 +8691,3 @@\n-    ((ctxt->value->type != XPATH_NODESET) &&\n-     (ctxt->value->type != XPATH_XSLT_TREE)))\n-    XP_ERROR(XPATH_INVALID_TYPE);\n+        ((ctxt->value->type != XPATH_NODESET) &&\n+         (ctxt->value->type != XPATH_XSLT_TREE)))\n+        XP_ERROR(XPATH_INVALID_TYPE);\n@@ -8697,19 +8697,0 @@\n-    valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, \"\"));\n-    } else {\n-    int i = 0; \/* Should be first in document order !!!!! *\/\n-    switch (cur->nodesetval->nodeTab[i]->type) {\n-    case XML_ELEMENT_NODE:\n-    case XML_ATTRIBUTE_NODE:\n-    case XML_PI_NODE:\n-        if (cur->nodesetval->nodeTab[i]->name[0] == ' ')\n-        valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, \"\"));\n-        else\n-        valuePush(ctxt,\n-              xmlXPathCacheNewString(ctxt->context,\n-            cur->nodesetval->nodeTab[i]->name));\n-        break;\n-    case XML_NAMESPACE_DECL:\n-        valuePush(ctxt, xmlXPathCacheNewString(ctxt->context,\n-            ((xmlNsPtr)cur->nodesetval->nodeTab[i])->prefix));\n-        break;\n-    default:\n@@ -8717,1 +8698,20 @@\n-    }\n+    } else {\n+        int i = 0; \/* Should be first in document order !!!!! *\/\n+        switch (cur->nodesetval->nodeTab[i]->type) {\n+        case XML_ELEMENT_NODE:\n+        case XML_ATTRIBUTE_NODE:\n+        case XML_PI_NODE:\n+            if (cur->nodesetval->nodeTab[i]->name[0] == ' ')\n+                valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, \"\"));\n+            else\n+                valuePush(ctxt,\n+                      xmlXPathCacheNewString(ctxt->context,\n+                        cur->nodesetval->nodeTab[i]->name));\n+            break;\n+        case XML_NAMESPACE_DECL:\n+            valuePush(ctxt, xmlXPathCacheNewString(ctxt->context,\n+                        ((xmlNsPtr)cur->nodesetval->nodeTab[i])->prefix));\n+            break;\n+        default:\n+            valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, \"\"));\n+        }\n@@ -8743,3 +8743,3 @@\n-    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n-        ctxt->context->node));\n-    nargs = 1;\n+        valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n+            ctxt->context->node));\n+        nargs = 1;\n@@ -8749,3 +8749,3 @@\n-    ((ctxt->value->type != XPATH_NODESET) &&\n-     (ctxt->value->type != XPATH_XSLT_TREE)))\n-    XP_ERROR(XPATH_INVALID_TYPE);\n+        ((ctxt->value->type != XPATH_NODESET) &&\n+         (ctxt->value->type != XPATH_XSLT_TREE)))\n+        XP_ERROR(XPATH_INVALID_TYPE);\n@@ -8755,13 +8755,0 @@\n-    valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, \"\"));\n-    } else {\n-    int i = 0; \/* Should be first in document order !!!!! *\/\n-    switch (cur->nodesetval->nodeTab[i]->type) {\n-    case XML_ELEMENT_NODE:\n-    case XML_ATTRIBUTE_NODE:\n-        if (cur->nodesetval->nodeTab[i]->ns == NULL)\n-        valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, \"\"));\n-        else\n-        valuePush(ctxt, xmlXPathCacheNewString(ctxt->context,\n-              cur->nodesetval->nodeTab[i]->ns->href));\n-        break;\n-    default:\n@@ -8769,1 +8756,14 @@\n-    }\n+    } else {\n+        int i = 0; \/* Should be first in document order !!!!! *\/\n+        switch (cur->nodesetval->nodeTab[i]->type) {\n+        case XML_ELEMENT_NODE:\n+        case XML_ATTRIBUTE_NODE:\n+            if (cur->nodesetval->nodeTab[i]->ns == NULL)\n+                valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, \"\"));\n+            else\n+                valuePush(ctxt, xmlXPathCacheNewString(ctxt->context,\n+                          cur->nodesetval->nodeTab[i]->ns->href));\n+            break;\n+        default:\n+            valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, \"\"));\n+        }\n@@ -8802,2 +8802,2 @@\n-    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n-        ctxt->context->node));\n+        valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n+            ctxt->context->node));\n@@ -8822,4 +8822,4 @@\n-        if (cur->nodesetval->nodeTab[i]->name[0] == ' ')\n-            valuePush(ctxt,\n-            xmlXPathCacheNewCString(ctxt->context, \"\"));\n-        else if ((cur->nodesetval->nodeTab[i]->ns == NULL) ||\n+                if (cur->nodesetval->nodeTab[i]->name[0] == ' ')\n+                    valuePush(ctxt,\n+                        xmlXPathCacheNewCString(ctxt->context, \"\"));\n+                else if ((cur->nodesetval->nodeTab[i]->ns == NULL) ||\n@@ -8827,16 +8827,16 @@\n-            valuePush(ctxt,\n-                xmlXPathCacheNewString(ctxt->context,\n-                cur->nodesetval->nodeTab[i]->name));\n-        } else {\n-            xmlChar *fullname;\n-\n-            fullname = xmlBuildQName(cur->nodesetval->nodeTab[i]->name,\n-                     cur->nodesetval->nodeTab[i]->ns->prefix,\n-                     NULL, 0);\n-            if (fullname == cur->nodesetval->nodeTab[i]->name)\n-            fullname = xmlStrdup(cur->nodesetval->nodeTab[i]->name);\n-            if (fullname == NULL) {\n-            XP_ERROR(XPATH_MEMORY_ERROR);\n-            }\n-            valuePush(ctxt, xmlXPathCacheWrapString(\n-            ctxt->context, fullname));\n+                    valuePush(ctxt,\n+                        xmlXPathCacheNewString(ctxt->context,\n+                            cur->nodesetval->nodeTab[i]->name));\n+                } else {\n+                    xmlChar *fullname;\n+\n+                    fullname = xmlBuildQName(cur->nodesetval->nodeTab[i]->name,\n+                                     cur->nodesetval->nodeTab[i]->ns->prefix,\n+                                     NULL, 0);\n+                    if (fullname == cur->nodesetval->nodeTab[i]->name)\n+                        fullname = xmlStrdup(cur->nodesetval->nodeTab[i]->name);\n+                    if (fullname == NULL) {\n+                        XP_ERROR(XPATH_MEMORY_ERROR);\n+                    }\n+                    valuePush(ctxt, xmlXPathCacheWrapString(\n+                        ctxt->context, fullname));\n@@ -8846,2 +8846,2 @@\n-        valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n-            cur->nodesetval->nodeTab[i]));\n+                valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n+                    cur->nodesetval->nodeTab[i]));\n@@ -8898,3 +8898,3 @@\n-    xmlXPathCacheWrapString(ctxt->context,\n-        xmlXPathCastNodeToString(ctxt->context->node)));\n-    return;\n+        xmlXPathCacheWrapString(ctxt->context,\n+            xmlXPathCastNodeToString(ctxt->context->node)));\n+        return;\n@@ -8927,5 +8927,5 @@\n-        return;\n-    if (ctxt->context->node == NULL) {\n-        valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, 0));\n-    } else {\n-        xmlChar *content;\n+            return;\n+        if (ctxt->context->node == NULL) {\n+            valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, 0));\n+        } else {\n+            xmlChar *content;\n@@ -8933,6 +8933,6 @@\n-        content = xmlXPathCastNodeToString(ctxt->context->node);\n-        valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context,\n-        xmlUTF8Strlen(content)));\n-        xmlFree(content);\n-    }\n-    return;\n+            content = xmlXPathCastNodeToString(ctxt->context->node);\n+            valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context,\n+                xmlUTF8Strlen(content)));\n+            xmlFree(content);\n+        }\n+        return;\n@@ -8945,1 +8945,1 @@\n-    xmlUTF8Strlen(cur->stringval)));\n+        xmlUTF8Strlen(cur->stringval)));\n@@ -8965,1 +8965,1 @@\n-    CHECK_ARITY(2);\n+        CHECK_ARITY(2);\n@@ -8971,2 +8971,2 @@\n-    xmlXPathReleaseObject(ctxt->context, cur);\n-    return;\n+        xmlXPathReleaseObject(ctxt->context, cur);\n+        return;\n@@ -8977,3 +8977,10 @@\n-    CAST_TO_STRING;\n-    newobj = valuePop(ctxt);\n-    if ((newobj == NULL) || (newobj->type != XPATH_STRING)) {\n+        CAST_TO_STRING;\n+        newobj = valuePop(ctxt);\n+        if ((newobj == NULL) || (newobj->type != XPATH_STRING)) {\n+            xmlXPathReleaseObject(ctxt->context, newobj);\n+            xmlXPathReleaseObject(ctxt->context, cur);\n+            XP_ERROR(XPATH_INVALID_TYPE);\n+        }\n+        tmp = xmlStrcat(newobj->stringval, cur->stringval);\n+        newobj->stringval = cur->stringval;\n+        cur->stringval = tmp;\n@@ -8981,8 +8988,1 @@\n-        xmlXPathReleaseObject(ctxt->context, cur);\n-        XP_ERROR(XPATH_INVALID_TYPE);\n-    }\n-    tmp = xmlStrcat(newobj->stringval, cur->stringval);\n-    newobj->stringval = cur->stringval;\n-    cur->stringval = tmp;\n-    xmlXPathReleaseObject(ctxt->context, newobj);\n-    nargs--;\n+        nargs--;\n@@ -9015,3 +9015,3 @@\n-    xmlXPathReleaseObject(ctxt->context, hay);\n-    xmlXPathReleaseObject(ctxt->context, needle);\n-    XP_ERROR(XPATH_INVALID_TYPE);\n+        xmlXPathReleaseObject(ctxt->context, hay);\n+        xmlXPathReleaseObject(ctxt->context, needle);\n+        XP_ERROR(XPATH_INVALID_TYPE);\n@@ -9020,1 +9020,1 @@\n-    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 1));\n+        valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 1));\n@@ -9022,1 +9022,1 @@\n-    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 0));\n+        valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, 0));\n@@ -9050,3 +9050,3 @@\n-    xmlXPathReleaseObject(ctxt->context, hay);\n-    xmlXPathReleaseObject(ctxt->context, needle);\n-    XP_ERROR(XPATH_INVALID_TYPE);\n+        xmlXPathReleaseObject(ctxt->context, hay);\n+        xmlXPathReleaseObject(ctxt->context, needle);\n+        XP_ERROR(XPATH_INVALID_TYPE);\n@@ -9098,1 +9098,1 @@\n-    CHECK_ARITY(2);\n+        CHECK_ARITY(2);\n@@ -9101,1 +9101,1 @@\n-    CHECK_ARITY(3);\n+        CHECK_ARITY(3);\n@@ -9107,5 +9107,5 @@\n-    CAST_TO_NUMBER;\n-    CHECK_TYPE(XPATH_NUMBER);\n-    len = valuePop(ctxt);\n-    le = len->floatval;\n-    xmlXPathReleaseObject(ctxt->context, len);\n+        CAST_TO_NUMBER;\n+        CHECK_TYPE(XPATH_NUMBER);\n+        len = valuePop(ctxt);\n+        le = len->floatval;\n+        xmlXPathReleaseObject(ctxt->context, len);\n@@ -9152,2 +9152,2 @@\n-    valuePush(ctxt, xmlXPathCacheNewString(ctxt->context, ret));\n-    xmlFree(ret);\n+        valuePush(ctxt, xmlXPathCacheNewString(ctxt->context, ret));\n+        xmlFree(ret);\n@@ -9155,1 +9155,1 @@\n-    valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, \"\"));\n+        valuePush(ctxt, xmlXPathCacheNewCString(ctxt->context, \"\"));\n@@ -9196,1 +9196,1 @@\n-    xmlBufContent(target)));\n+        xmlBufContent(target)));\n@@ -9237,1 +9237,1 @@\n-           xmlStrlen(str->stringval) - offset);\n+                   xmlStrlen(str->stringval) - offset);\n@@ -9240,1 +9240,1 @@\n-    xmlBufContent(target)));\n+        xmlBufContent(target)));\n@@ -9272,2 +9272,2 @@\n-      xmlXPathCacheWrapString(ctxt->context,\n-        xmlXPathCastNodeToString(ctxt->context->node)));\n+          xmlXPathCacheWrapString(ctxt->context,\n+            xmlXPathCastNodeToString(ctxt->context->node)));\n@@ -9294,1 +9294,1 @@\n-    blank = 0x20;\n+        blank = 0x20;\n@@ -9296,5 +9296,5 @@\n-    if (blank) {\n-      xmlBufAdd(target, &blank, 1);\n-      blank = 0;\n-    }\n-    xmlBufAdd(target, source, 1);\n+        if (blank) {\n+          xmlBufAdd(target, &blank, 1);\n+          blank = 0;\n+        }\n+        xmlBufAdd(target, source, 1);\n@@ -9305,1 +9305,1 @@\n-    xmlBufContent(target)));\n+        xmlBufContent(target)));\n@@ -9354,19 +9354,19 @@\n-    max = xmlUTF8Strlen(to->stringval);\n-    for (cptr = str->stringval; (ch=*cptr); ) {\n-        offset = xmlUTF8Strloc(from->stringval, cptr);\n-        if (offset >= 0) {\n-        if (offset < max) {\n-            point = xmlUTF8Strpos(to->stringval, offset);\n-            if (point)\n-            xmlBufAdd(target, point, xmlUTF8Strsize(point, 1));\n-        }\n-        } else\n-        xmlBufAdd(target, cptr, xmlUTF8Strsize(cptr, 1));\n-\n-        \/* Step to next character in input *\/\n-        cptr++;\n-        if ( ch & 0x80 ) {\n-        \/* if not simple ascii, verify proper format *\/\n-        if ( (ch & 0xc0) != 0xc0 ) {\n-            xmlGenericError(xmlGenericErrorContext,\n-            \"xmlXPathTranslateFunction: Invalid UTF8 string\\n\");\n+        max = xmlUTF8Strlen(to->stringval);\n+        for (cptr = str->stringval; (ch=*cptr); ) {\n+            offset = xmlUTF8Strloc(from->stringval, cptr);\n+            if (offset >= 0) {\n+                if (offset < max) {\n+                    point = xmlUTF8Strpos(to->stringval, offset);\n+                    if (point)\n+                        xmlBufAdd(target, point, xmlUTF8Strsize(point, 1));\n+                }\n+            } else\n+                xmlBufAdd(target, cptr, xmlUTF8Strsize(cptr, 1));\n+\n+            \/* Step to next character in input *\/\n+            cptr++;\n+            if ( ch & 0x80 ) {\n+                \/* if not simple ascii, verify proper format *\/\n+                if ( (ch & 0xc0) != 0xc0 ) {\n+                    xmlGenericError(xmlGenericErrorContext,\n+                        \"xmlXPathTranslateFunction: Invalid UTF8 string\\n\");\n@@ -9374,7 +9374,7 @@\n-            break;\n-        }\n-        \/* then skip over remaining bytes for this char *\/\n-        while ( (ch <<= 1) & 0x80 )\n-            if ( (*cptr++ & 0xc0) != 0x80 ) {\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"xmlXPathTranslateFunction: Invalid UTF8 string\\n\");\n+                    break;\n+                }\n+                \/* then skip over remaining bytes for this char *\/\n+                while ( (ch <<= 1) & 0x80 )\n+                    if ( (*cptr++ & 0xc0) != 0x80 ) {\n+                        xmlGenericError(xmlGenericErrorContext,\n+                            \"xmlXPathTranslateFunction: Invalid UTF8 string\\n\");\n@@ -9382,1 +9382,4 @@\n-            break;\n+                        break;\n+                    }\n+                if (ch & 0x80) \/* must have had error encountered *\/\n+                    break;\n@@ -9384,2 +9387,0 @@\n-        if (ch & 0x80) \/* must have had error encountered *\/\n-            break;\n@@ -9388,1 +9389,0 @@\n-    }\n@@ -9390,1 +9390,1 @@\n-    xmlBufContent(target)));\n+        xmlBufContent(target)));\n@@ -9504,4 +9504,4 @@\n-        if (toupper(lang[i]) != toupper(theLang[i]))\n-            goto not_equal;\n-    if ((theLang[i] == 0) || (theLang[i] == '-'))\n-        ret = 1;\n+            if (toupper(lang[i]) != toupper(theLang[i]))\n+                goto not_equal;\n+        if ((theLang[i] == 0) || (theLang[i] == '-'))\n+            ret = 1;\n@@ -9511,1 +9511,1 @@\n-    xmlFree((void *)theLang);\n+        xmlFree((void *)theLang);\n@@ -9532,4 +9532,4 @@\n-    if (ctxt->context->node == NULL) {\n-        valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, 0.0));\n-    } else {\n-        xmlChar* content = xmlNodeGetContent(ctxt->context->node);\n+        if (ctxt->context->node == NULL) {\n+            valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, 0.0));\n+        } else {\n+            xmlChar* content = xmlNodeGetContent(ctxt->context->node);\n@@ -9537,5 +9537,5 @@\n-        res = xmlXPathStringEvalNumber(content);\n-        valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, res));\n-        xmlFree(content);\n-    }\n-    return;\n+            res = xmlXPathStringEvalNumber(content);\n+            valuePush(ctxt, xmlXPathCacheNewFloat(ctxt->context, res));\n+            xmlFree(content);\n+        }\n+        return;\n@@ -9567,3 +9567,3 @@\n-    ((ctxt->value->type != XPATH_NODESET) &&\n-     (ctxt->value->type != XPATH_XSLT_TREE)))\n-    XP_ERROR(XPATH_INVALID_TYPE);\n+        ((ctxt->value->type != XPATH_NODESET) &&\n+         (ctxt->value->type != XPATH_XSLT_TREE)))\n+        XP_ERROR(XPATH_INVALID_TYPE);\n@@ -9573,3 +9573,3 @@\n-    for (i = 0; i < cur->nodesetval->nodeNr; i++) {\n-        res += xmlXPathCastNodeToNumber(cur->nodesetval->nodeTab[i]);\n-    }\n+        for (i = 0; i < cur->nodesetval->nodeNr; i++) {\n+            res += xmlXPathCastNodeToNumber(cur->nodesetval->nodeTab[i]);\n+        }\n@@ -9658,3 +9658,3 @@\n- *                                  *\n- *          The Parser                  *\n- *                                  *\n+ *                                                                      *\n+ *                      The Parser                                      *\n+ *                                                                      *\n@@ -9672,1 +9672,1 @@\n-                                      int qualified);\n+                                          int qualified);\n@@ -9693,1 +9693,1 @@\n-    return(0);\n+        return(0);\n@@ -9709,9 +9709,1 @@\n-    if ((cur[1] & 0xc0) != 0x80)\n-        goto encoding_error;\n-    if ((c & 0xe0) == 0xe0) {\n-\n-        if ((cur[2] & 0xc0) != 0x80)\n-        goto encoding_error;\n-        if ((c & 0xf0) == 0xf0) {\n-        if (((c & 0xf8) != 0xf0) ||\n-            ((cur[3] & 0xc0) != 0x80))\n+        if ((cur[1] & 0xc0) != 0x80)\n@@ -9719,6 +9711,21 @@\n-        \/* 4-byte code *\/\n-        *len = 4;\n-        val = (cur[0] & 0x7) << 18;\n-        val |= (cur[1] & 0x3f) << 12;\n-        val |= (cur[2] & 0x3f) << 6;\n-        val |= cur[3] & 0x3f;\n+        if ((c & 0xe0) == 0xe0) {\n+\n+            if ((cur[2] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xf0) == 0xf0) {\n+                if (((c & 0xf8) != 0xf0) ||\n+                    ((cur[3] & 0xc0) != 0x80))\n+                    goto encoding_error;\n+                \/* 4-byte code *\/\n+                *len = 4;\n+                val = (cur[0] & 0x7) << 18;\n+                val |= (cur[1] & 0x3f) << 12;\n+                val |= (cur[2] & 0x3f) << 6;\n+                val |= cur[3] & 0x3f;\n+            } else {\n+              \/* 3-byte code *\/\n+                *len = 3;\n+                val = (cur[0] & 0xf) << 12;\n+                val |= (cur[1] & 0x3f) << 6;\n+                val |= cur[2] & 0x3f;\n+            }\n@@ -9726,5 +9733,4 @@\n-          \/* 3-byte code *\/\n-        *len = 3;\n-        val = (cur[0] & 0xf) << 12;\n-        val |= (cur[1] & 0x3f) << 6;\n-        val |= cur[2] & 0x3f;\n+          \/* 2-byte code *\/\n+            *len = 2;\n+            val = (cur[0] & 0x1f) << 6;\n+            val |= cur[1] & 0x3f;\n@@ -9732,0 +9738,4 @@\n+        if (!IS_CHAR(val)) {\n+            XP_ERROR0(XPATH_INVALID_CHAR_ERROR);\n+        }\n+        return(val);\n@@ -9733,13 +9743,3 @@\n-      \/* 2-byte code *\/\n-        *len = 2;\n-        val = (cur[0] & 0x1f) << 6;\n-        val |= cur[1] & 0x3f;\n-    }\n-    if (!IS_CHAR(val)) {\n-        XP_ERROR0(XPATH_INVALID_CHAR_ERROR);\n-    }\n-    return(val);\n-    } else {\n-    \/* 1-byte code *\/\n-    *len = 1;\n-    return((int) *cur);\n+        \/* 1-byte code *\/\n+        *len = 1;\n+        return((int) *cur);\n@@ -9785,8 +9785,2 @@\n-    ((*in >= 0x41) && (*in <= 0x5A)) ||\n-    (*in == '_')) {\n-    in++;\n-    while (((*in >= 0x61) && (*in <= 0x7A)) ||\n-           ((*in >= 0x41) && (*in <= 0x5A)) ||\n-           ((*in >= 0x30) && (*in <= 0x39)) ||\n-           (*in == '_') || (*in == '.') ||\n-           (*in == '-'))\n+        ((*in >= 0x41) && (*in <= 0x5A)) ||\n+        (*in == '_')) {\n@@ -9794,1 +9788,7 @@\n-    if ((*in == ' ') || (*in == '>') || (*in == '\/') ||\n+        while (((*in >= 0x61) && (*in <= 0x7A)) ||\n+               ((*in >= 0x41) && (*in <= 0x5A)) ||\n+               ((*in >= 0x30) && (*in <= 0x39)) ||\n+               (*in == '_') || (*in == '.') ||\n+               (*in == '-'))\n+            in++;\n+        if ((*in == ' ') || (*in == '>') || (*in == '\/') ||\n@@ -9797,7 +9797,7 @@\n-        count = in - ctxt->cur;\n-        if (count == 0)\n-        return(NULL);\n-        ret = xmlStrndup(ctxt->cur, count);\n-        ctxt->cur = in;\n-        return(ret);\n-    }\n+            count = in - ctxt->cur;\n+            if (count == 0)\n+                return(NULL);\n+            ret = xmlStrndup(ctxt->cur, count);\n+            ctxt->cur = in;\n+            return(ret);\n+        }\n@@ -9834,2 +9834,2 @@\n-    NEXT;\n-    ret = xmlXPathParseNCName(ctxt);\n+        NEXT;\n+        ret = xmlXPathParseNCName(ctxt);\n@@ -9866,8 +9866,2 @@\n-    ((*in >= 0x41) && (*in <= 0x5A)) ||\n-    (*in == '_') || (*in == ':')) {\n-    in++;\n-    while (((*in >= 0x61) && (*in <= 0x7A)) ||\n-           ((*in >= 0x41) && (*in <= 0x5A)) ||\n-           ((*in >= 0x30) && (*in <= 0x39)) ||\n-           (*in == '_') || (*in == '-') ||\n-           (*in == ':') || (*in == '.'))\n+        ((*in >= 0x41) && (*in <= 0x5A)) ||\n+        (*in == '_') || (*in == ':')) {\n@@ -9875,2 +9869,8 @@\n-    if ((*in > 0) && (*in < 0x80)) {\n-        count = in - ctxt->cur;\n+        while (((*in >= 0x61) && (*in <= 0x7A)) ||\n+               ((*in >= 0x41) && (*in <= 0x5A)) ||\n+               ((*in >= 0x30) && (*in <= 0x39)) ||\n+               (*in == '_') || (*in == '-') ||\n+               (*in == ':') || (*in == '.'))\n+            in++;\n+        if ((*in > 0) && (*in < 0x80)) {\n+            count = in - ctxt->cur;\n@@ -9881,4 +9881,4 @@\n-        ret = xmlStrndup(ctxt->cur, count);\n-        ctxt->cur = in;\n-        return(ret);\n-    }\n+            ret = xmlStrndup(ctxt->cur, count);\n+            ctxt->cur = in;\n+            return(ret);\n+        }\n@@ -9902,1 +9902,1 @@\n-    (!IS_LETTER(c) && (c != '_') &&\n+        (!IS_LETTER(c) && (c != '_') &&\n@@ -9904,1 +9904,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -9908,1 +9908,1 @@\n-       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n+           ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n@@ -9910,13 +9910,13 @@\n-        (c == '_') || ((qualified) && (c == ':')) ||\n-        (IS_COMBINING(c)) ||\n-        (IS_EXTENDER(c)))) {\n-    COPY_BUF(l,buf,len,c);\n-    NEXTL(l);\n-    c = CUR_CHAR(l);\n-    if (len >= XML_MAX_NAMELEN) {\n-        \/*\n-         * Okay someone managed to make a huge name, so he's ready to pay\n-         * for the processing speed.\n-         *\/\n-        xmlChar *buffer;\n-        int max = len * 2;\n+            (c == '_') || ((qualified) && (c == ':')) ||\n+            (IS_COMBINING(c)) ||\n+            (IS_EXTENDER(c)))) {\n+        COPY_BUF(l,buf,len,c);\n+        NEXTL(l);\n+        c = CUR_CHAR(l);\n+        if (len >= XML_MAX_NAMELEN) {\n+            \/*\n+             * Okay someone managed to make a huge name, so he's ready to pay\n+             * for the processing speed.\n+             *\/\n+            xmlChar *buffer;\n+            int max = len * 2;\n@@ -9927,11 +9927,11 @@\n-        buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));\n-        if (buffer == NULL) {\n-        XP_ERRORNULL(XPATH_MEMORY_ERROR);\n-        }\n-        memcpy(buffer, buf, len);\n-        while ((IS_LETTER(c)) || (IS_DIGIT(c)) || \/* test bigname.xml *\/\n-           (c == '.') || (c == '-') ||\n-           (c == '_') || ((qualified) && (c == ':')) ||\n-           (IS_COMBINING(c)) ||\n-           (IS_EXTENDER(c))) {\n-        if (len + 10 > max) {\n+            buffer = (xmlChar *) xmlMallocAtomic(max * sizeof(xmlChar));\n+            if (buffer == NULL) {\n+                XP_ERRORNULL(XPATH_MEMORY_ERROR);\n+            }\n+            memcpy(buffer, buf, len);\n+            while ((IS_LETTER(c)) || (IS_DIGIT(c)) || \/* test bigname.xml *\/\n+                   (c == '.') || (c == '-') ||\n+                   (c == '_') || ((qualified) && (c == ':')) ||\n+                   (IS_COMBINING(c)) ||\n+                   (IS_EXTENDER(c))) {\n+                if (len + 10 > max) {\n@@ -9943,4 +9943,4 @@\n-            max *= 2;\n-            tmp = (xmlChar *) xmlRealloc(buffer,\n-                                     max * sizeof(xmlChar));\n-            if (tmp == NULL) {\n+                    max *= 2;\n+                    tmp = (xmlChar *) xmlRealloc(buffer,\n+                                                 max * sizeof(xmlChar));\n+                    if (tmp == NULL) {\n@@ -9948,2 +9948,2 @@\n-            XP_ERRORNULL(XPATH_MEMORY_ERROR);\n-            }\n+                        XP_ERRORNULL(XPATH_MEMORY_ERROR);\n+                    }\n@@ -9951,0 +9951,7 @@\n+                }\n+                COPY_BUF(l,buffer,len,c);\n+                NEXTL(l);\n+                c = CUR_CHAR(l);\n+            }\n+            buffer[len] = 0;\n+            return(buffer);\n@@ -9952,7 +9959,0 @@\n-        COPY_BUF(l,buffer,len,c);\n-        NEXTL(l);\n-        c = CUR_CHAR(l);\n-        }\n-        buffer[len] = 0;\n-        return(buffer);\n-    }\n@@ -9961,1 +9961,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -10001,2 +10001,2 @@\n-    isneg = 1;\n-    cur++;\n+        isneg = 1;\n+        cur++;\n@@ -10012,6 +10012,6 @@\n-    ret = ret * 10;\n-    tmp = (*cur - '0');\n-    ok = 1;\n-    cur++;\n-    temp = (double) tmp;\n-    ret = ret + temp;\n+        ret = ret * 10;\n+        tmp = (*cur - '0');\n+        ok = 1;\n+        cur++;\n+        temp = (double) tmp;\n+        ret = ret + temp;\n@@ -10022,3 +10022,3 @@\n-    ret = ret * 10 + (*cur - '0');\n-    ok = 1;\n-    cur++;\n+        ret = ret * 10 + (*cur - '0');\n+        ok = 1;\n+        cur++;\n@@ -10029,2 +10029,2 @@\n-    int v, frac = 0, max;\n-    double fraction = 0;\n+        int v, frac = 0, max;\n+        double fraction = 0;\n@@ -10033,3 +10033,3 @@\n-    if (((*cur < '0') || (*cur > '9')) && (!ok)) {\n-        return(xmlXPathNAN);\n-    }\n+        if (((*cur < '0') || (*cur > '9')) && (!ok)) {\n+            return(xmlXPathNAN);\n+        }\n@@ -10037,2 +10037,2 @@\n-        frac = frac + 1;\n-        cur++;\n+            frac = frac + 1;\n+            cur++;\n@@ -10041,10 +10041,10 @@\n-    while (((*cur >= '0') && (*cur <= '9')) && (frac < max)) {\n-        v = (*cur - '0');\n-        fraction = fraction * 10 + v;\n-        frac = frac + 1;\n-        cur++;\n-    }\n-    fraction \/= pow(10.0, frac);\n-    ret = ret + fraction;\n-    while ((*cur >= '0') && (*cur <= '9'))\n-        cur++;\n+        while (((*cur >= '0') && (*cur <= '9')) && (frac < max)) {\n+            v = (*cur - '0');\n+            fraction = fraction * 10 + v;\n+            frac = frac + 1;\n+            cur++;\n+        }\n+        fraction \/= pow(10.0, frac);\n+        ret = ret + fraction;\n+        while ((*cur >= '0') && (*cur <= '9'))\n+            cur++;\n@@ -10055,2 +10055,2 @@\n-    is_exponent_negative = 1;\n-    cur++;\n+        is_exponent_negative = 1;\n+        cur++;\n@@ -10062,2 +10062,2 @@\n-      exponent = exponent * 10 + (*cur - '0');\n-    cur++;\n+          exponent = exponent * 10 + (*cur - '0');\n+        cur++;\n@@ -10109,2 +10109,2 @@\n-    ret = ret * 10;\n-    tmp = (CUR - '0');\n+        ret = ret * 10;\n+        tmp = (CUR - '0');\n@@ -10113,2 +10113,2 @@\n-    temp = (double) tmp;\n-    ret = ret + temp;\n+        temp = (double) tmp;\n+        ret = ret + temp;\n@@ -10119,3 +10119,3 @@\n-    ret = ret * 10 + (CUR - '0');\n-    ok = 1;\n-    NEXT;\n+        ret = ret * 10 + (CUR - '0');\n+        ok = 1;\n+        NEXT;\n@@ -10125,2 +10125,2 @@\n-    int v, frac = 0, max;\n-    double fraction = 0;\n+        int v, frac = 0, max;\n+        double fraction = 0;\n@@ -10138,3 +10138,3 @@\n-        v = (CUR - '0');\n-        fraction = fraction * 10 + v;\n-        frac = frac + 1;\n+            v = (CUR - '0');\n+            fraction = fraction * 10 + v;\n+            frac = frac + 1;\n@@ -10154,2 +10154,2 @@\n-        NEXT;\n-    }\n+            NEXT;\n+        }\n@@ -10167,1 +10167,1 @@\n-    ctxt->error = XPATH_MEMORY_ERROR;\n+        ctxt->error = XPATH_MEMORY_ERROR;\n@@ -10192,8 +10192,8 @@\n-    q = CUR_PTR;\n-    while ((IS_CHAR_CH(CUR)) && (CUR != '\"'))\n-        NEXT;\n-    if (!IS_CHAR_CH(CUR)) {\n-        XP_ERRORNULL(XPATH_UNFINISHED_LITERAL_ERROR);\n-    } else {\n-        ret = xmlStrndup(q, CUR_PTR - q);\n-        NEXT;\n+        q = CUR_PTR;\n+        while ((IS_CHAR_CH(CUR)) && (CUR != '\"'))\n+            NEXT;\n+        if (!IS_CHAR_CH(CUR)) {\n+            XP_ERRORNULL(XPATH_UNFINISHED_LITERAL_ERROR);\n+        } else {\n+            ret = xmlStrndup(q, CUR_PTR - q);\n+            NEXT;\n@@ -10203,8 +10203,8 @@\n-    q = CUR_PTR;\n-    while ((IS_CHAR_CH(CUR)) && (CUR != '\\''))\n-        NEXT;\n-    if (!IS_CHAR_CH(CUR)) {\n-        XP_ERRORNULL(XPATH_UNFINISHED_LITERAL_ERROR);\n-    } else {\n-        ret = xmlStrndup(q, CUR_PTR - q);\n-        NEXT;\n+        q = CUR_PTR;\n+        while ((IS_CHAR_CH(CUR)) && (CUR != '\\''))\n+            NEXT;\n+        if (!IS_CHAR_CH(CUR)) {\n+            XP_ERRORNULL(XPATH_UNFINISHED_LITERAL_ERROR);\n+        } else {\n+            ret = xmlStrndup(q, CUR_PTR - q);\n+            NEXT;\n@@ -10213,1 +10213,1 @@\n-    XP_ERRORNULL(XPATH_START_LITERAL_ERROR);\n+        XP_ERRORNULL(XPATH_START_LITERAL_ERROR);\n@@ -10237,8 +10237,8 @@\n-    q = CUR_PTR;\n-    while ((IS_CHAR_CH(CUR)) && (CUR != '\"'))\n-        NEXT;\n-    if (!IS_CHAR_CH(CUR)) {\n-        XP_ERROR(XPATH_UNFINISHED_LITERAL_ERROR);\n-    } else {\n-        ret = xmlStrndup(q, CUR_PTR - q);\n-        NEXT;\n+        q = CUR_PTR;\n+        while ((IS_CHAR_CH(CUR)) && (CUR != '\"'))\n+            NEXT;\n+        if (!IS_CHAR_CH(CUR)) {\n+            XP_ERROR(XPATH_UNFINISHED_LITERAL_ERROR);\n+        } else {\n+            ret = xmlStrndup(q, CUR_PTR - q);\n+            NEXT;\n@@ -10248,8 +10248,8 @@\n-    q = CUR_PTR;\n-    while ((IS_CHAR_CH(CUR)) && (CUR != '\\''))\n-        NEXT;\n-    if (!IS_CHAR_CH(CUR)) {\n-        XP_ERROR(XPATH_UNFINISHED_LITERAL_ERROR);\n-    } else {\n-        ret = xmlStrndup(q, CUR_PTR - q);\n-        NEXT;\n+        q = CUR_PTR;\n+        while ((IS_CHAR_CH(CUR)) && (CUR != '\\''))\n+            NEXT;\n+        if (!IS_CHAR_CH(CUR)) {\n+            XP_ERROR(XPATH_UNFINISHED_LITERAL_ERROR);\n+        } else {\n+            ret = xmlStrndup(q, CUR_PTR - q);\n+            NEXT;\n@@ -10258,1 +10258,1 @@\n-    XP_ERROR(XPATH_START_LITERAL_ERROR);\n+        XP_ERROR(XPATH_START_LITERAL_ERROR);\n@@ -10263,1 +10263,1 @@\n-    ctxt->error = XPATH_MEMORY_ERROR;\n+        ctxt->error = XPATH_MEMORY_ERROR;\n@@ -10295,1 +10295,1 @@\n-    XP_ERROR(XPATH_VARIABLE_REF_ERROR);\n+        XP_ERROR(XPATH_VARIABLE_REF_ERROR);\n@@ -10301,1 +10301,1 @@\n-    XP_ERROR(XPATH_VARIABLE_REF_ERROR);\n+        XP_ERROR(XPATH_VARIABLE_REF_ERROR);\n@@ -10310,1 +10310,1 @@\n-    XP_ERROR(XPATH_FORBID_VARIABLE_ERROR);\n+        XP_ERROR(XPATH_FORBID_VARIABLE_ERROR);\n@@ -10330,1 +10330,1 @@\n-    return(0);\n+        return(0);\n@@ -10333,1 +10333,1 @@\n-    return(1);\n+        return(1);\n@@ -10335,1 +10335,1 @@\n-    return(1);\n+        return(1);\n@@ -10337,1 +10337,1 @@\n-    return(1);\n+        return(1);\n@@ -10339,1 +10339,1 @@\n-    return(1);\n+        return(1);\n@@ -10362,2 +10362,2 @@\n-    xmlFree(prefix);\n-    XP_ERROR(XPATH_EXPR_ERROR);\n+        xmlFree(prefix);\n+        XP_ERROR(XPATH_EXPR_ERROR);\n@@ -10368,2 +10368,2 @@\n-    xmlGenericError(xmlGenericErrorContext, \"Calling function %s\\n\",\n-            name);\n+        xmlGenericError(xmlGenericErrorContext, \"Calling function %s\\n\",\n+                        name);\n@@ -10371,2 +10371,2 @@\n-    xmlGenericError(xmlGenericErrorContext, \"Calling function %s:%s\\n\",\n-            prefix, name);\n+        xmlGenericError(xmlGenericErrorContext, \"Calling function %s:%s\\n\",\n+                        prefix, name);\n@@ -10376,3 +10376,3 @@\n-    xmlFree(name);\n-    xmlFree(prefix);\n-    XP_ERROR(XPATH_EXPR_ERROR);\n+        xmlFree(name);\n+        xmlFree(prefix);\n+        XP_ERROR(XPATH_EXPR_ERROR);\n@@ -10387,1 +10387,1 @@\n-    xmlStrEqual(name, BAD_CAST \"count\"))\n+        xmlStrEqual(name, BAD_CAST \"count\"))\n@@ -10389,1 +10389,1 @@\n-    sort = 0;\n+        sort = 0;\n@@ -10393,16 +10393,19 @@\n-    while (CUR != 0) {\n-        int op1 = ctxt->comp->last;\n-        ctxt->comp->last = -1;\n-        xmlXPathCompileExpr(ctxt, sort);\n-        if (ctxt->error != XPATH_EXPRESSION_OK) {\n-        xmlFree(name);\n-        xmlFree(prefix);\n-        return;\n-        }\n-        PUSH_BINARY_EXPR(XPATH_OP_ARG, op1, ctxt->comp->last, 0, 0);\n-        nbargs++;\n-        if (CUR == ')') break;\n-        if (CUR != ',') {\n-        xmlFree(name);\n-        xmlFree(prefix);\n-        XP_ERROR(XPATH_EXPR_ERROR);\n+        while (CUR != 0) {\n+            int op1 = ctxt->comp->last;\n+            ctxt->comp->last = -1;\n+            xmlXPathCompileExpr(ctxt, sort);\n+            if (ctxt->error != XPATH_EXPRESSION_OK) {\n+                xmlFree(name);\n+                xmlFree(prefix);\n+                return;\n+            }\n+            PUSH_BINARY_EXPR(XPATH_OP_ARG, op1, ctxt->comp->last, 0, 0);\n+            nbargs++;\n+            if (CUR == ')') break;\n+            if (CUR != ',') {\n+                xmlFree(name);\n+                xmlFree(prefix);\n+                XP_ERROR(XPATH_EXPR_ERROR);\n+            }\n+            NEXT;\n+            SKIP_BLANKS;\n@@ -10410,3 +10413,0 @@\n-        NEXT;\n-        SKIP_BLANKS;\n-    }\n@@ -10439,9 +10439,9 @@\n-    NEXT;\n-    SKIP_BLANKS;\n-    xmlXPathCompileExpr(ctxt, 1);\n-    CHECK_ERROR;\n-    if (CUR != ')') {\n-        XP_ERROR(XPATH_EXPR_ERROR);\n-    }\n-    NEXT;\n-    SKIP_BLANKS;\n+        NEXT;\n+        SKIP_BLANKS;\n+        xmlXPathCompileExpr(ctxt, 1);\n+        CHECK_ERROR;\n+        if (CUR != ')') {\n+            XP_ERROR(XPATH_EXPR_ERROR);\n+        }\n+        NEXT;\n+        SKIP_BLANKS;\n@@ -10449,1 +10449,1 @@\n-    xmlXPathCompNumber(ctxt);\n+        xmlXPathCompNumber(ctxt);\n@@ -10451,1 +10451,1 @@\n-    xmlXPathCompLiteral(ctxt);\n+        xmlXPathCompLiteral(ctxt);\n@@ -10453,1 +10453,1 @@\n-    xmlXPathCompFunctionCall(ctxt);\n+        xmlXPathCompFunctionCall(ctxt);\n@@ -10480,2 +10480,2 @@\n-    xmlXPathCompPredicate(ctxt, 1);\n-    SKIP_BLANKS;\n+        xmlXPathCompPredicate(ctxt, 1);\n+        SKIP_BLANKS;\n@@ -10515,1 +10515,1 @@\n-    (!IS_LETTER(c) && (c != '_') &&\n+        (!IS_LETTER(c) && (c != '_') &&\n@@ -10517,1 +10517,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -10521,1 +10521,1 @@\n-       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n+           ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n@@ -10523,6 +10523,6 @@\n-        (c == '_') || (c == ':') ||\n-        (IS_COMBINING(c)) ||\n-        (IS_EXTENDER(c)))) {\n-    len += l;\n-    NEXTL(l);\n-    c = CUR_CHAR(l);\n+            (c == '_') || (c == ':') ||\n+            (IS_COMBINING(c)) ||\n+            (IS_EXTENDER(c)))) {\n+        len += l;\n+        NEXTL(l);\n+        c = CUR_CHAR(l);\n@@ -10560,1 +10560,1 @@\n-    (IS_ASCII_DIGIT(CUR)) ||\n+        (IS_ASCII_DIGIT(CUR)) ||\n@@ -10562,2 +10562,2 @@\n-    (CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {\n-    lc = 0;\n+        (CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {\n+        lc = 0;\n@@ -10565,2 +10565,2 @@\n-    \/* relative or absolute location path *\/\n-    lc = 1;\n+        \/* relative or absolute location path *\/\n+        lc = 1;\n@@ -10568,2 +10568,2 @@\n-    \/* relative or absolute location path *\/\n-    lc = 1;\n+        \/* relative or absolute location path *\/\n+        lc = 1;\n@@ -10571,2 +10571,2 @@\n-    \/* relative abbreviated attribute location path *\/\n-    lc = 1;\n+        \/* relative abbreviated attribute location path *\/\n+        lc = 1;\n@@ -10574,2 +10574,2 @@\n-    \/* relative abbreviated attribute location path *\/\n-    lc = 1;\n+        \/* relative abbreviated attribute location path *\/\n+        lc = 1;\n@@ -10577,14 +10577,14 @@\n-    \/*\n-     * Problem is finding if we have a name here whether it's:\n-     *   - a nodetype\n-     *   - a function call in which case it's followed by '('\n-     *   - an axis in which case it's followed by ':'\n-     *   - a element name\n-     * We do an a priori analysis here rather than having to\n-     * maintain parsed token content through the recursive function\n-     * calls. This looks uglier but makes the code easier to\n-     * read\/write\/debug.\n-     *\/\n-    SKIP_BLANKS;\n-    name = xmlXPathScanName(ctxt);\n-    if ((name != NULL) && (xmlStrstr(name, (xmlChar *) \"::\") != NULL)) {\n+        \/*\n+         * Problem is finding if we have a name here whether it's:\n+         *   - a nodetype\n+         *   - a function call in which case it's followed by '('\n+         *   - an axis in which case it's followed by ':'\n+         *   - a element name\n+         * We do an a priori analysis here rather than having to\n+         * maintain parsed token content through the recursive function\n+         * calls. This looks uglier but makes the code easier to\n+         * read\/write\/debug.\n+         *\/\n+        SKIP_BLANKS;\n+        name = xmlXPathScanName(ctxt);\n+        if ((name != NULL) && (xmlStrstr(name, (xmlChar *) \"::\") != NULL)) {\n@@ -10592,2 +10592,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PathExpr: Axis\\n\");\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"PathExpr: Axis\\n\");\n@@ -10595,4 +10595,4 @@\n-        lc = 1;\n-        xmlFree(name);\n-    } else if (name != NULL) {\n-        int len =xmlStrlen(name);\n+            lc = 1;\n+            xmlFree(name);\n+        } else if (name != NULL) {\n+            int len =xmlStrlen(name);\n@@ -10601,3 +10601,3 @@\n-        while (NXT(len) != 0) {\n-        if (NXT(len) == '\/') {\n-            \/* element name *\/\n+            while (NXT(len) != 0) {\n+                if (NXT(len) == '\/') {\n+                    \/* element name *\/\n@@ -10605,2 +10605,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PathExpr: AbbrRelLocation\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"PathExpr: AbbrRelLocation\\n\");\n@@ -10608,6 +10608,6 @@\n-            lc = 1;\n-            break;\n-        } else if (IS_BLANK_CH(NXT(len))) {\n-            \/* ignore blanks *\/\n-            ;\n-        } else if (NXT(len) == ':') {\n+                    lc = 1;\n+                    break;\n+                } else if (IS_BLANK_CH(NXT(len))) {\n+                    \/* ignore blanks *\/\n+                    ;\n+                } else if (NXT(len) == ':') {\n@@ -10615,2 +10615,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PathExpr: AbbrRelLocation\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"PathExpr: AbbrRelLocation\\n\");\n@@ -10618,5 +10618,5 @@\n-            lc = 1;\n-            break;\n-        } else if ((NXT(len) == '(')) {\n-            \/* Node Type or Function *\/\n-            if (xmlXPathIsNodeType(name)) {\n+                    lc = 1;\n+                    break;\n+                } else if ((NXT(len) == '(')) {\n+                    \/* Node Type or Function *\/\n+                    if (xmlXPathIsNodeType(name)) {\n@@ -10624,2 +10624,2 @@\n-                xmlGenericError(xmlGenericErrorContext,\n-                \"PathExpr: Type search\\n\");\n+                        xmlGenericError(xmlGenericErrorContext,\n+                                \"PathExpr: Type search\\n\");\n@@ -10627,1 +10627,1 @@\n-            lc = 1;\n+                        lc = 1;\n@@ -10633,1 +10633,1 @@\n-            } else {\n+                    } else {\n@@ -10635,2 +10635,2 @@\n-                xmlGenericError(xmlGenericErrorContext,\n-                \"PathExpr: function call\\n\");\n+                        xmlGenericError(xmlGenericErrorContext,\n+                                \"PathExpr: function call\\n\");\n@@ -10638,2 +10638,2 @@\n-            lc = 0;\n-            }\n+                        lc = 0;\n+                    }\n@@ -10641,2 +10641,2 @@\n-        } else if ((NXT(len) == '[')) {\n-            \/* element name *\/\n+                } else if ((NXT(len) == '[')) {\n+                    \/* element name *\/\n@@ -10644,2 +10644,2 @@\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"PathExpr: AbbrRelLocation\\n\");\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"PathExpr: AbbrRelLocation\\n\");\n@@ -10647,13 +10647,13 @@\n-            lc = 1;\n-            break;\n-        } else if ((NXT(len) == '<') || (NXT(len) == '>') ||\n-               (NXT(len) == '=')) {\n-            lc = 1;\n-            break;\n-        } else {\n-            lc = 1;\n-            break;\n-        }\n-        len++;\n-        }\n-        if (NXT(len) == 0) {\n+                    lc = 1;\n+                    break;\n+                } else if ((NXT(len) == '<') || (NXT(len) == '>') ||\n+                           (NXT(len) == '=')) {\n+                    lc = 1;\n+                    break;\n+                } else {\n+                    lc = 1;\n+                    break;\n+                }\n+                len++;\n+            }\n+            if (NXT(len) == 0) {\n@@ -10661,2 +10661,2 @@\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"PathExpr: AbbrRelLocation\\n\");\n+                xmlGenericError(xmlGenericErrorContext,\n+                        \"PathExpr: AbbrRelLocation\\n\");\n@@ -10664,2 +10664,7 @@\n-        \/* element name *\/\n-        lc = 1;\n+                \/* element name *\/\n+                lc = 1;\n+            }\n+            xmlFree(name);\n+        } else {\n+            \/* make sure all cases are covered explicitly *\/\n+            XP_ERROR(XPATH_EXPR_ERROR);\n@@ -10667,5 +10672,0 @@\n-        xmlFree(name);\n-    } else {\n-        \/* make sure all cases are covered explicitly *\/\n-        XP_ERROR(XPATH_EXPR_ERROR);\n-    }\n@@ -10675,6 +10675,6 @@\n-    if (CUR == '\/') {\n-        PUSH_LEAVE_EXPR(XPATH_OP_ROOT, 0, 0);\n-    } else {\n-        PUSH_LEAVE_EXPR(XPATH_OP_NODE, 0, 0);\n-    }\n-    xmlXPathCompLocationPath(ctxt);\n+        if (CUR == '\/') {\n+            PUSH_LEAVE_EXPR(XPATH_OP_ROOT, 0, 0);\n+        } else {\n+            PUSH_LEAVE_EXPR(XPATH_OP_NODE, 0, 0);\n+        }\n+        xmlXPathCompLocationPath(ctxt);\n@@ -10682,5 +10682,5 @@\n-    xmlXPathCompFilterExpr(ctxt);\n-    CHECK_ERROR;\n-    if ((CUR == '\/') && (NXT(1) == '\/')) {\n-        SKIP(2);\n-        SKIP_BLANKS;\n+        xmlXPathCompFilterExpr(ctxt);\n+        CHECK_ERROR;\n+        if ((CUR == '\/') && (NXT(1) == '\/')) {\n+            SKIP(2);\n+            SKIP_BLANKS;\n@@ -10688,2 +10688,2 @@\n-        PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,\n-            NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n+            PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,\n+                    NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n@@ -10691,4 +10691,4 @@\n-        xmlXPathCompRelativeLocationPath(ctxt);\n-    } else if (CUR == '\/') {\n-        xmlXPathCompRelativeLocationPath(ctxt);\n-    }\n+            xmlXPathCompRelativeLocationPath(ctxt);\n+        } else if (CUR == '\/') {\n+            xmlXPathCompRelativeLocationPath(ctxt);\n+        }\n@@ -10715,2 +10715,2 @@\n-    int op1 = ctxt->comp->last;\n-    PUSH_LEAVE_EXPR(XPATH_OP_NODE, 0, 0);\n+        int op1 = ctxt->comp->last;\n+        PUSH_LEAVE_EXPR(XPATH_OP_NODE, 0, 0);\n@@ -10718,3 +10718,3 @@\n-    NEXT;\n-    SKIP_BLANKS;\n-    xmlXPathCompPathExpr(ctxt);\n+        NEXT;\n+        SKIP_BLANKS;\n+        xmlXPathCompPathExpr(ctxt);\n@@ -10722,1 +10722,1 @@\n-    PUSH_BINARY_EXPR(XPATH_OP_UNION, op1, ctxt->comp->last, 0, 0);\n+        PUSH_BINARY_EXPR(XPATH_OP_UNION, op1, ctxt->comp->last, 0, 0);\n@@ -10724,1 +10724,1 @@\n-    SKIP_BLANKS;\n+        SKIP_BLANKS;\n@@ -10746,3 +10746,3 @@\n-    found = 1;\n-    NEXT;\n-    SKIP_BLANKS;\n+        found = 1;\n+        NEXT;\n+        SKIP_BLANKS;\n@@ -10754,4 +10754,4 @@\n-    if (minus)\n-        PUSH_UNARY_EXPR(XPATH_OP_PLUS, ctxt->comp->last, 2, 0);\n-    else\n-        PUSH_UNARY_EXPR(XPATH_OP_PLUS, ctxt->comp->last, 3, 0);\n+        if (minus)\n+            PUSH_UNARY_EXPR(XPATH_OP_PLUS, ctxt->comp->last, 2, 0);\n+        else\n+            PUSH_UNARY_EXPR(XPATH_OP_PLUS, ctxt->comp->last, 3, 0);\n@@ -10782,2 +10782,2 @@\n-    int op = -1;\n-    int op1 = ctxt->comp->last;\n+        int op = -1;\n+        int op1 = ctxt->comp->last;\n@@ -10786,10 +10786,10 @@\n-        op = 0;\n-        NEXT;\n-    } else if (CUR == 'd') {\n-        op = 1;\n-        SKIP(3);\n-    } else if (CUR == 'm') {\n-        op = 2;\n-        SKIP(3);\n-    }\n-    SKIP_BLANKS;\n+            op = 0;\n+            NEXT;\n+        } else if (CUR == 'd') {\n+            op = 1;\n+            SKIP(3);\n+        } else if (CUR == 'm') {\n+            op = 2;\n+            SKIP(3);\n+        }\n+        SKIP_BLANKS;\n@@ -10797,3 +10797,3 @@\n-    CHECK_ERROR;\n-    PUSH_BINARY_EXPR(XPATH_OP_MULT, op1, ctxt->comp->last, op, 0);\n-    SKIP_BLANKS;\n+        CHECK_ERROR;\n+        PUSH_BINARY_EXPR(XPATH_OP_MULT, op1, ctxt->comp->last, op, 0);\n+        SKIP_BLANKS;\n@@ -10821,2 +10821,2 @@\n-    int plus;\n-    int op1 = ctxt->comp->last;\n+        int plus;\n+        int op1 = ctxt->comp->last;\n@@ -10825,3 +10825,3 @@\n-    else plus = 0;\n-    NEXT;\n-    SKIP_BLANKS;\n+        else plus = 0;\n+        NEXT;\n+        SKIP_BLANKS;\n@@ -10829,3 +10829,3 @@\n-    CHECK_ERROR;\n-    PUSH_BINARY_EXPR(XPATH_OP_PLUS, op1, ctxt->comp->last, plus, 0);\n-    SKIP_BLANKS;\n+        CHECK_ERROR;\n+        PUSH_BINARY_EXPR(XPATH_OP_PLUS, op1, ctxt->comp->last, plus, 0);\n+        SKIP_BLANKS;\n@@ -10859,2 +10859,2 @@\n-    int inf, strict;\n-    int op1 = ctxt->comp->last;\n+        int inf, strict;\n+        int op1 = ctxt->comp->last;\n@@ -10863,6 +10863,6 @@\n-    else inf = 0;\n-    if (NXT(1) == '=') strict = 0;\n-    else strict = 1;\n-    NEXT;\n-    if (!strict) NEXT;\n-    SKIP_BLANKS;\n+        else inf = 0;\n+        if (NXT(1) == '=') strict = 0;\n+        else strict = 1;\n+        NEXT;\n+        if (!strict) NEXT;\n+        SKIP_BLANKS;\n@@ -10870,3 +10870,3 @@\n-    CHECK_ERROR;\n-    PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);\n-    SKIP_BLANKS;\n+        CHECK_ERROR;\n+        PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);\n+        SKIP_BLANKS;\n@@ -10898,2 +10898,2 @@\n-    int eq;\n-    int op1 = ctxt->comp->last;\n+        int eq;\n+        int op1 = ctxt->comp->last;\n@@ -10902,4 +10902,4 @@\n-    else eq = 0;\n-    NEXT;\n-    if (!eq) NEXT;\n-    SKIP_BLANKS;\n+        else eq = 0;\n+        NEXT;\n+        if (!eq) NEXT;\n+        SKIP_BLANKS;\n@@ -10907,3 +10907,3 @@\n-    CHECK_ERROR;\n-    PUSH_BINARY_EXPR(XPATH_OP_EQUAL, op1, ctxt->comp->last, eq, 0);\n-    SKIP_BLANKS;\n+        CHECK_ERROR;\n+        PUSH_BINARY_EXPR(XPATH_OP_EQUAL, op1, ctxt->comp->last, eq, 0);\n+        SKIP_BLANKS;\n@@ -10929,1 +10929,1 @@\n-    int op1 = ctxt->comp->last;\n+        int op1 = ctxt->comp->last;\n@@ -10931,1 +10931,1 @@\n-    SKIP_BLANKS;\n+        SKIP_BLANKS;\n@@ -10933,3 +10933,3 @@\n-    CHECK_ERROR;\n-    PUSH_BINARY_EXPR(XPATH_OP_AND, op1, ctxt->comp->last, 0, 0);\n-    SKIP_BLANKS;\n+        CHECK_ERROR;\n+        PUSH_BINARY_EXPR(XPATH_OP_AND, op1, ctxt->comp->last, 0, 0);\n+        SKIP_BLANKS;\n@@ -10967,1 +10967,1 @@\n-    int op1 = ctxt->comp->last;\n+        int op1 = ctxt->comp->last;\n@@ -10969,1 +10969,1 @@\n-    SKIP_BLANKS;\n+        SKIP_BLANKS;\n@@ -10971,3 +10971,3 @@\n-    CHECK_ERROR;\n-    PUSH_BINARY_EXPR(XPATH_OP_OR, op1, ctxt->comp->last, 0, 0);\n-    SKIP_BLANKS;\n+        CHECK_ERROR;\n+        PUSH_BINARY_EXPR(XPATH_OP_OR, op1, ctxt->comp->last, 0, 0);\n+        SKIP_BLANKS;\n@@ -10976,7 +10976,7 @@\n-    \/* more ops could be optimized too *\/\n-    \/*\n-    * This is the main place to eliminate sorting for\n-    * operations which don't require a sorted node-set.\n-    * E.g. count().\n-    *\/\n-    PUSH_UNARY_EXPR(XPATH_OP_SORT, ctxt->comp->last , 0, 0);\n+        \/* more ops could be optimized too *\/\n+        \/*\n+        * This is the main place to eliminate sorting for\n+        * operations which don't require a sorted node-set.\n+        * E.g. count().\n+        *\/\n+        PUSH_UNARY_EXPR(XPATH_OP_SORT, ctxt->comp->last , 0, 0);\n@@ -10986,1 +10986,1 @@\n-        xpctxt->depth -= 1;\n+        xpctxt->depth -= 10;\n@@ -11005,1 +11005,1 @@\n-    XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);\n+        XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);\n@@ -11021,1 +11021,1 @@\n-    xmlXPathCompileExpr(ctxt, 0);\n+        xmlXPathCompileExpr(ctxt, 0);\n@@ -11023,1 +11023,1 @@\n-    xmlXPathCompileExpr(ctxt, 1);\n+        xmlXPathCompileExpr(ctxt, 1);\n@@ -11027,1 +11027,1 @@\n-    XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);\n+        XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);\n@@ -11031,1 +11031,1 @@\n-    PUSH_BINARY_EXPR(XPATH_OP_FILTER, op1, ctxt->comp->last, 0, 0);\n+        PUSH_BINARY_EXPR(XPATH_OP_FILTER, op1, ctxt->comp->last, 0, 0);\n@@ -11033,1 +11033,1 @@\n-    PUSH_BINARY_EXPR(XPATH_OP_PREDICATE, op1, ctxt->comp->last, 0, 0);\n+        PUSH_BINARY_EXPR(XPATH_OP_PREDICATE, op1, ctxt->comp->last, 0, 0);\n@@ -11047,2 +11047,2 @@\n- *          | NodeType '(' ')'\n- *          | 'processing-instruction' '(' Literal ')'\n+ *                  | NodeType '(' ')'\n+ *                  | 'processing-instruction' '(' Literal ')'\n@@ -11051,2 +11051,2 @@\n- *          | NCName ':' '*'\n- *          | QName\n+ *                  | NCName ':' '*'\n+ *                  | QName\n@@ -11054,3 +11054,3 @@\n- *         | 'text'\n- *         | 'processing-instruction'\n- *         | 'node'\n+ *                 | 'text'\n+ *                 | 'processing-instruction'\n+ *                 | 'node'\n@@ -11062,2 +11062,2 @@\n-                 xmlXPathTypeVal *type, xmlChar **prefix,\n-             xmlChar *name) {\n+                     xmlXPathTypeVal *type, xmlChar **prefix,\n+                     xmlChar *name) {\n@@ -11067,2 +11067,2 @@\n-    STRANGE;\n-    return(NULL);\n+        STRANGE;\n+        return(NULL);\n@@ -11076,6 +11076,6 @@\n-    \/*\n-     * All elements\n-     *\/\n-    NEXT;\n-    *test = NODE_TEST_ALL;\n-    return(NULL);\n+        \/*\n+         * All elements\n+         *\/\n+        NEXT;\n+        *test = NODE_TEST_ALL;\n+        return(NULL);\n@@ -11085,1 +11085,1 @@\n-    name = xmlXPathParseNCName(ctxt);\n+        name = xmlXPathParseNCName(ctxt);\n@@ -11087,1 +11087,1 @@\n-    XP_ERRORNULL(XPATH_EXPR_ERROR);\n+        XP_ERRORNULL(XPATH_EXPR_ERROR);\n@@ -11093,22 +11093,1 @@\n-    NEXT;\n-    \/*\n-     * NodeType or PI search\n-     *\/\n-    if (xmlStrEqual(name, BAD_CAST \"comment\"))\n-        *type = NODE_TYPE_COMMENT;\n-    else if (xmlStrEqual(name, BAD_CAST \"node\"))\n-        *type = NODE_TYPE_NODE;\n-    else if (xmlStrEqual(name, BAD_CAST \"processing-instruction\"))\n-        *type = NODE_TYPE_PI;\n-    else if (xmlStrEqual(name, BAD_CAST \"text\"))\n-        *type = NODE_TYPE_TEXT;\n-    else {\n-        if (name != NULL)\n-        xmlFree(name);\n-        XP_ERRORNULL(XPATH_EXPR_ERROR);\n-    }\n-\n-    *test = NODE_TEST_TYPE;\n-\n-    SKIP_BLANKS;\n-    if (*type == NODE_TYPE_PI) {\n+        NEXT;\n@@ -11116,1 +11095,1 @@\n-         * Specific case: search a PI by name.\n+         * NodeType or PI search\n@@ -11118,7 +11097,16 @@\n-        if (name != NULL)\n-        xmlFree(name);\n-        name = NULL;\n-        if (CUR != ')') {\n-        name = xmlXPathParseLiteral(ctxt);\n-        CHECK_ERROR NULL;\n-        *test = NODE_TEST_PI;\n+        if (xmlStrEqual(name, BAD_CAST \"comment\"))\n+            *type = NODE_TYPE_COMMENT;\n+        else if (xmlStrEqual(name, BAD_CAST \"node\"))\n+            *type = NODE_TYPE_NODE;\n+        else if (xmlStrEqual(name, BAD_CAST \"processing-instruction\"))\n+            *type = NODE_TYPE_PI;\n+        else if (xmlStrEqual(name, BAD_CAST \"text\"))\n+            *type = NODE_TYPE_TEXT;\n+        else {\n+            if (name != NULL)\n+                xmlFree(name);\n+            XP_ERRORNULL(XPATH_EXPR_ERROR);\n+        }\n+\n+        *test = NODE_TEST_TYPE;\n+\n@@ -11126,0 +11114,15 @@\n+        if (*type == NODE_TYPE_PI) {\n+            \/*\n+             * Specific case: search a PI by name.\n+             *\/\n+            if (name != NULL)\n+                xmlFree(name);\n+            name = NULL;\n+            if (CUR != ')') {\n+                name = xmlXPathParseLiteral(ctxt);\n+                if (name == NULL) {\n+                    XP_ERRORNULL(XPATH_EXPR_ERROR);\n+                }\n+                *test = NODE_TEST_PI;\n+                SKIP_BLANKS;\n+            }\n@@ -11127,8 +11130,7 @@\n-    }\n-    if (CUR != ')') {\n-        if (name != NULL)\n-        xmlFree(name);\n-        XP_ERRORNULL(XPATH_UNCLOSED_ERROR);\n-    }\n-    NEXT;\n-    return(name);\n+        if (CUR != ')') {\n+            if (name != NULL)\n+                xmlFree(name);\n+            XP_ERRORNULL(XPATH_UNCLOSED_ERROR);\n+        }\n+        NEXT;\n+        return(name);\n@@ -11138,1 +11140,1 @@\n-    NEXT;\n+        NEXT;\n@@ -11140,7 +11142,7 @@\n-    \/*\n-     * Since currently the parser context don't have a\n-     * namespace list associated:\n-     * The namespace name for this prefix can be computed\n-     * only at evaluation time. The compilation is done\n-     * outside of any context.\n-     *\/\n+        \/*\n+         * Since currently the parser context don't have a\n+         * namespace list associated:\n+         * The namespace name for this prefix can be computed\n+         * only at evaluation time. The compilation is done\n+         * outside of any context.\n+         *\/\n@@ -11148,6 +11150,6 @@\n-    *prefix = xmlXPathNsLookup(ctxt->context, name);\n-    if (name != NULL)\n-        xmlFree(name);\n-    if (*prefix == NULL) {\n-        XP_ERROR0(XPATH_UNDEF_PREFIX_ERROR);\n-    }\n+        *prefix = xmlXPathNsLookup(ctxt->context, name);\n+        if (name != NULL)\n+            xmlFree(name);\n+        if (*prefix == NULL) {\n+            XP_ERROR0(XPATH_UNDEF_PREFIX_ERROR);\n+        }\n@@ -11155,1 +11157,1 @@\n-    *prefix = name;\n+        *prefix = name;\n@@ -11158,8 +11160,8 @@\n-    if (CUR == '*') {\n-        \/*\n-         * All elements\n-         *\/\n-        NEXT;\n-        *test = NODE_TEST_ALL;\n-        return(NULL);\n-    }\n+        if (CUR == '*') {\n+            \/*\n+             * All elements\n+             *\/\n+            NEXT;\n+            *test = NODE_TEST_ALL;\n+            return(NULL);\n+        }\n@@ -11167,4 +11169,4 @@\n-    name = xmlXPathParseNCName(ctxt);\n-    if (name == NULL) {\n-        XP_ERRORNULL(XPATH_EXPR_ERROR);\n-    }\n+        name = xmlXPathParseNCName(ctxt);\n+        if (name == NULL) {\n+            XP_ERRORNULL(XPATH_EXPR_ERROR);\n+        }\n@@ -11199,40 +11201,40 @@\n-    case 'a':\n-        if (xmlStrEqual(name, BAD_CAST \"ancestor\"))\n-        ret = AXIS_ANCESTOR;\n-        if (xmlStrEqual(name, BAD_CAST \"ancestor-or-self\"))\n-        ret = AXIS_ANCESTOR_OR_SELF;\n-        if (xmlStrEqual(name, BAD_CAST \"attribute\"))\n-        ret = AXIS_ATTRIBUTE;\n-        break;\n-    case 'c':\n-        if (xmlStrEqual(name, BAD_CAST \"child\"))\n-        ret = AXIS_CHILD;\n-        break;\n-    case 'd':\n-        if (xmlStrEqual(name, BAD_CAST \"descendant\"))\n-        ret = AXIS_DESCENDANT;\n-        if (xmlStrEqual(name, BAD_CAST \"descendant-or-self\"))\n-        ret = AXIS_DESCENDANT_OR_SELF;\n-        break;\n-    case 'f':\n-        if (xmlStrEqual(name, BAD_CAST \"following\"))\n-        ret = AXIS_FOLLOWING;\n-        if (xmlStrEqual(name, BAD_CAST \"following-sibling\"))\n-        ret = AXIS_FOLLOWING_SIBLING;\n-        break;\n-    case 'n':\n-        if (xmlStrEqual(name, BAD_CAST \"namespace\"))\n-        ret = AXIS_NAMESPACE;\n-        break;\n-    case 'p':\n-        if (xmlStrEqual(name, BAD_CAST \"parent\"))\n-        ret = AXIS_PARENT;\n-        if (xmlStrEqual(name, BAD_CAST \"preceding\"))\n-        ret = AXIS_PRECEDING;\n-        if (xmlStrEqual(name, BAD_CAST \"preceding-sibling\"))\n-        ret = AXIS_PRECEDING_SIBLING;\n-        break;\n-    case 's':\n-        if (xmlStrEqual(name, BAD_CAST \"self\"))\n-        ret = AXIS_SELF;\n-        break;\n+        case 'a':\n+            if (xmlStrEqual(name, BAD_CAST \"ancestor\"))\n+                ret = AXIS_ANCESTOR;\n+            if (xmlStrEqual(name, BAD_CAST \"ancestor-or-self\"))\n+                ret = AXIS_ANCESTOR_OR_SELF;\n+            if (xmlStrEqual(name, BAD_CAST \"attribute\"))\n+                ret = AXIS_ATTRIBUTE;\n+            break;\n+        case 'c':\n+            if (xmlStrEqual(name, BAD_CAST \"child\"))\n+                ret = AXIS_CHILD;\n+            break;\n+        case 'd':\n+            if (xmlStrEqual(name, BAD_CAST \"descendant\"))\n+                ret = AXIS_DESCENDANT;\n+            if (xmlStrEqual(name, BAD_CAST \"descendant-or-self\"))\n+                ret = AXIS_DESCENDANT_OR_SELF;\n+            break;\n+        case 'f':\n+            if (xmlStrEqual(name, BAD_CAST \"following\"))\n+                ret = AXIS_FOLLOWING;\n+            if (xmlStrEqual(name, BAD_CAST \"following-sibling\"))\n+                ret = AXIS_FOLLOWING_SIBLING;\n+            break;\n+        case 'n':\n+            if (xmlStrEqual(name, BAD_CAST \"namespace\"))\n+                ret = AXIS_NAMESPACE;\n+            break;\n+        case 'p':\n+            if (xmlStrEqual(name, BAD_CAST \"parent\"))\n+                ret = AXIS_PARENT;\n+            if (xmlStrEqual(name, BAD_CAST \"preceding\"))\n+                ret = AXIS_PRECEDING;\n+            if (xmlStrEqual(name, BAD_CAST \"preceding-sibling\"))\n+                ret = AXIS_PRECEDING_SIBLING;\n+            break;\n+        case 's':\n+            if (xmlStrEqual(name, BAD_CAST \"self\"))\n+                ret = AXIS_SELF;\n+            break;\n@@ -11284,4 +11286,4 @@\n-    SKIP(2);\n-    SKIP_BLANKS;\n-    PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_PARENT,\n-            NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n+        SKIP(2);\n+        SKIP_BLANKS;\n+        PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_PARENT,\n+                    NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n@@ -11289,2 +11291,2 @@\n-    NEXT;\n-    SKIP_BLANKS;\n+        NEXT;\n+        SKIP_BLANKS;\n@@ -11292,6 +11294,6 @@\n-    xmlChar *name = NULL;\n-    xmlChar *prefix = NULL;\n-    xmlXPathTestVal test = (xmlXPathTestVal) 0;\n-    xmlXPathAxisVal axis = (xmlXPathAxisVal) 0;\n-    xmlXPathTypeVal type = (xmlXPathTypeVal) 0;\n-    int op1;\n+        xmlChar *name = NULL;\n+        xmlChar *prefix = NULL;\n+        xmlXPathTestVal test = (xmlXPathTestVal) 0;\n+        xmlXPathAxisVal axis = (xmlXPathAxisVal) 0;\n+        xmlXPathTypeVal type = (xmlXPathTypeVal) 0;\n+        int op1;\n@@ -11299,3 +11301,3 @@\n-    \/*\n-     * The modification needed for XPointer change to the production\n-     *\/\n+        \/*\n+         * The modification needed for XPointer change to the production\n+         *\/\n@@ -11303,3 +11305,3 @@\n-    if (ctxt->xptr) {\n-        name = xmlXPathParseNCName(ctxt);\n-        if ((name != NULL) && (xmlStrEqual(name, BAD_CAST \"range-to\"))) {\n+        if (ctxt->xptr) {\n+            name = xmlXPathParseNCName(ctxt);\n+            if ((name != NULL) && (xmlStrEqual(name, BAD_CAST \"range-to\"))) {\n@@ -11307,7 +11309,7 @@\n-        xmlFree(name);\n-        SKIP_BLANKS;\n-        if (CUR != '(') {\n-            XP_ERROR(XPATH_EXPR_ERROR);\n-        }\n-        NEXT;\n-        SKIP_BLANKS;\n+                xmlFree(name);\n+                SKIP_BLANKS;\n+                if (CUR != '(') {\n+                    XP_ERROR(XPATH_EXPR_ERROR);\n+                }\n+                NEXT;\n+                SKIP_BLANKS;\n@@ -11315,3 +11317,3 @@\n-        xmlXPathCompileExpr(ctxt, 1);\n-        \/* PUSH_BINARY_EXPR(XPATH_OP_RANGETO, op2, ctxt->comp->last, 0, 0); *\/\n-        CHECK_ERROR;\n+                xmlXPathCompileExpr(ctxt, 1);\n+                \/* PUSH_BINARY_EXPR(XPATH_OP_RANGETO, op2, ctxt->comp->last, 0, 0); *\/\n+                CHECK_ERROR;\n@@ -11319,7 +11321,8 @@\n-        SKIP_BLANKS;\n-        if (CUR != ')') {\n-            XP_ERROR(XPATH_EXPR_ERROR);\n-        }\n-        NEXT;\n-        rangeto = 1;\n-        goto eval_predicates;\n+                SKIP_BLANKS;\n+                if (CUR != ')') {\n+                    XP_ERROR(XPATH_EXPR_ERROR);\n+                }\n+                NEXT;\n+                rangeto = 1;\n+                goto eval_predicates;\n+            }\n@@ -11327,1 +11330,0 @@\n-    }\n@@ -11329,18 +11331,1 @@\n-    if (CUR == '*') {\n-        axis = AXIS_CHILD;\n-    } else {\n-        if (name == NULL)\n-        name = xmlXPathParseNCName(ctxt);\n-        if (name != NULL) {\n-        axis = xmlXPathIsAxisName(name);\n-        if (axis != 0) {\n-            SKIP_BLANKS;\n-            if ((CUR == ':') && (NXT(1) == ':')) {\n-            SKIP(2);\n-            xmlFree(name);\n-            name = NULL;\n-            } else {\n-            \/* an element name can conflict with an axis one :-\\ *\/\n-            axis = AXIS_CHILD;\n-            }\n-        } else {\n+        if (CUR == '*') {\n@@ -11348,4 +11333,0 @@\n-        }\n-        } else if (CUR == '@') {\n-        NEXT;\n-        axis = AXIS_ATTRIBUTE;\n@@ -11353,1 +11334,23 @@\n-        axis = AXIS_CHILD;\n+            if (name == NULL)\n+                name = xmlXPathParseNCName(ctxt);\n+            if (name != NULL) {\n+                axis = xmlXPathIsAxisName(name);\n+                if (axis != 0) {\n+                    SKIP_BLANKS;\n+                    if ((CUR == ':') && (NXT(1) == ':')) {\n+                        SKIP(2);\n+                        xmlFree(name);\n+                        name = NULL;\n+                    } else {\n+                        \/* an element name can conflict with an axis one :-\\ *\/\n+                        axis = AXIS_CHILD;\n+                    }\n+                } else {\n+                    axis = AXIS_CHILD;\n+                }\n+            } else if (CUR == '@') {\n+                NEXT;\n+                axis = AXIS_ATTRIBUTE;\n+            } else {\n+                axis = AXIS_CHILD;\n+            }\n@@ -11355,1 +11358,0 @@\n-    }\n@@ -11362,3 +11364,3 @@\n-    name = xmlXPathCompNodeTest(ctxt, &test, &type, &prefix, name);\n-    if (test == 0)\n-        return;\n+        name = xmlXPathCompNodeTest(ctxt, &test, &type, &prefix, name);\n+        if (test == 0)\n+            return;\n@@ -11367,3 +11369,4 @@\n-        (ctxt->context->flags & XML_XPATH_CHECKNS)) {\n-        if (xmlXPathNsLookup(ctxt->context, prefix) == NULL) {\n-        xmlXPathErr(ctxt, XPATH_UNDEF_PREFIX_ERROR);\n+            (ctxt->context->flags & XML_XPATH_CHECKNS)) {\n+            if (xmlXPathNsLookup(ctxt->context, prefix) == NULL) {\n+                xmlXPathErr(ctxt, XPATH_UNDEF_PREFIX_ERROR);\n+            }\n@@ -11371,1 +11374,0 @@\n-    }\n@@ -11373,2 +11375,2 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"Basis : computing new set\\n\");\n+        xmlGenericError(xmlGenericErrorContext,\n+                \"Basis : computing new set\\n\");\n@@ -11378,7 +11380,7 @@\n-    xmlGenericError(xmlGenericErrorContext, \"Basis : \");\n-    if (ctxt->value == NULL)\n-        xmlGenericError(xmlGenericErrorContext, \"no value\\n\");\n-    else if (ctxt->value->nodesetval == NULL)\n-        xmlGenericError(xmlGenericErrorContext, \"Empty\\n\");\n-    else\n-        xmlGenericErrorContextNodeSet(stdout, ctxt->value->nodesetval);\n+        xmlGenericError(xmlGenericErrorContext, \"Basis : \");\n+        if (ctxt->value == NULL)\n+            xmlGenericError(xmlGenericErrorContext, \"no value\\n\");\n+        else if (ctxt->value->nodesetval == NULL)\n+            xmlGenericError(xmlGenericErrorContext, \"Empty\\n\");\n+        else\n+            xmlGenericErrorContextNodeSet(stdout, ctxt->value->nodesetval);\n@@ -11390,2 +11392,2 @@\n-    op1 = ctxt->comp->last;\n-    ctxt->comp->last = -1;\n+        op1 = ctxt->comp->last;\n+        ctxt->comp->last = -1;\n@@ -11393,4 +11395,4 @@\n-    SKIP_BLANKS;\n-    while (CUR == '[') {\n-        xmlXPathCompPredicate(ctxt, 0);\n-    }\n+        SKIP_BLANKS;\n+        while (CUR == '[') {\n+            xmlXPathCompPredicate(ctxt, 0);\n+        }\n@@ -11399,3 +11401,3 @@\n-    if (rangeto) {\n-        PUSH_BINARY_EXPR(XPATH_OP_RANGETO, op2, op1, 0, 0);\n-    } else\n+        if (rangeto) {\n+            PUSH_BINARY_EXPR(XPATH_OP_RANGETO, op2, op1, 0, 0);\n+        } else\n@@ -11412,1 +11414,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"no value\\n\");\n+        xmlGenericError(xmlGenericErrorContext, \"no value\\n\");\n@@ -11414,1 +11416,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"Empty\\n\");\n+        xmlGenericError(xmlGenericErrorContext, \"Empty\\n\");\n@@ -11416,2 +11418,2 @@\n-    xmlGenericErrorContextNodeSet(xmlGenericErrorContext,\n-        ctxt->value->nodesetval);\n+        xmlGenericErrorContextNodeSet(xmlGenericErrorContext,\n+                ctxt->value->nodesetval);\n@@ -11436,13 +11438,0 @@\n-    if ((CUR == '\/') && (NXT(1) == '\/')) {\n-    SKIP(2);\n-    SKIP_BLANKS;\n-    PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,\n-                 NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n-    } else if (CUR == '\/') {\n-        NEXT;\n-    SKIP_BLANKS;\n-    }\n-    xmlXPathCompStep(ctxt);\n-    CHECK_ERROR;\n-    SKIP_BLANKS;\n-    while (CUR == '\/') {\n@@ -11453,2 +11442,1 @@\n-                 NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n-        xmlXPathCompStep(ctxt);\n+                         NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n@@ -11456,1 +11444,1 @@\n-        NEXT;\n+            NEXT;\n@@ -11458,1 +11446,0 @@\n-        xmlXPathCompStep(ctxt);\n@@ -11460,0 +11447,2 @@\n+    xmlXPathCompStep(ctxt);\n+    CHECK_ERROR;\n@@ -11461,0 +11450,13 @@\n+    while (CUR == '\/') {\n+        if ((CUR == '\/') && (NXT(1) == '\/')) {\n+            SKIP(2);\n+            SKIP_BLANKS;\n+            PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,\n+                             NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n+            xmlXPathCompStep(ctxt);\n+        } else if (CUR == '\/') {\n+            NEXT;\n+            SKIP_BLANKS;\n+            xmlXPathCompStep(ctxt);\n+        }\n+        SKIP_BLANKS;\n@@ -11491,14 +11493,16 @@\n-    while (CUR == '\/') {\n-        if ((CUR == '\/') && (NXT(1) == '\/')) {\n-        SKIP(2);\n-        SKIP_BLANKS;\n-        PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,\n-                 NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n-        xmlXPathCompRelativeLocationPath(ctxt);\n-        } else if (CUR == '\/') {\n-        NEXT;\n-        SKIP_BLANKS;\n-        if ((CUR != 0 ) &&\n-            ((IS_ASCII_LETTER(CUR)) || (CUR == '_') || (CUR == '.') ||\n-             (CUR == '@') || (CUR == '*')))\n-            xmlXPathCompRelativeLocationPath(ctxt);\n+        while (CUR == '\/') {\n+            if ((CUR == '\/') && (NXT(1) == '\/')) {\n+                SKIP(2);\n+                SKIP_BLANKS;\n+                PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,\n+                             NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n+                xmlXPathCompRelativeLocationPath(ctxt);\n+            } else if (CUR == '\/') {\n+                NEXT;\n+                SKIP_BLANKS;\n+                if ((CUR != 0 ) &&\n+                    ((IS_ASCII_LETTER(CUR)) || (CUR == '_') || (CUR == '.') ||\n+                     (CUR == '@') || (CUR == '*')))\n+                    xmlXPathCompRelativeLocationPath(ctxt);\n+            }\n+            CHECK_ERROR;\n@@ -11506,2 +11510,0 @@\n-        CHECK_ERROR;\n-    }\n@@ -11512,3 +11514,3 @@\n- *                                  *\n- *      XPath precompiled expression evaluation         *\n- *                                  *\n+ *                                                                      *\n+ *              XPath precompiled expression evaluation                 *\n+ *                                                                      *\n@@ -11523,1 +11525,1 @@\n-              int nbNodes)\n+                          int nbNodes)\n@@ -11572,1 +11574,1 @@\n-    \" context contains %d nodes\\n\", nbNodes);\n+        \" context contains %d nodes\\n\", nbNodes);\n@@ -11622,2 +11624,2 @@\n-              xmlNodeSetPtr set,\n-              int filterOpIndex,\n+                      xmlNodeSetPtr set,\n+                      int filterOpIndex,\n@@ -11625,1 +11627,1 @@\n-              int hasNsNodes)\n+                      int hasNsNodes)\n@@ -11756,2 +11758,2 @@\n-                  xmlLocationSetPtr locset,\n-                  int filterOpIndex,\n+                          xmlLocationSetPtr locset,\n+                          int filterOpIndex,\n@@ -11875,2 +11877,2 @@\n-                xmlXPathStepOpPtr op,\n-                xmlNodeSetPtr set,\n+                            xmlXPathStepOpPtr op,\n+                            xmlNodeSetPtr set,\n@@ -11878,1 +11880,1 @@\n-                int hasNsNodes)\n+                            int hasNsNodes)\n@@ -11881,5 +11883,5 @@\n-    xmlXPathCompExprPtr comp = ctxt->comp;\n-    \/*\n-    * Process inner predicates first.\n-    *\/\n-    if (comp->steps[op->ch1].op != XPATH_OP_PREDICATE) {\n+        xmlXPathCompExprPtr comp = ctxt->comp;\n+        \/*\n+        * Process inner predicates first.\n+        *\/\n+        if (comp->steps[op->ch1].op != XPATH_OP_PREDICATE) {\n@@ -11889,1 +11891,1 @@\n-    }\n+        }\n@@ -11893,1 +11895,1 @@\n-    xmlXPathCompOpEvalPredicate(ctxt, &comp->steps[op->ch1], set,\n+        xmlXPathCompOpEvalPredicate(ctxt, &comp->steps[op->ch1], set,\n@@ -11896,1 +11898,1 @@\n-    CHECK_ERROR;\n+        CHECK_ERROR;\n@@ -11905,2 +11907,2 @@\n-                xmlXPathStepOpPtr op,\n-                int *maxPos)\n+                            xmlXPathStepOpPtr op,\n+                            int *maxPos)\n@@ -11925,1 +11927,1 @@\n-    return(0);\n+        return(0);\n@@ -11928,1 +11930,1 @@\n-    exprOp = &ctxt->comp->steps[op->ch2];\n+        exprOp = &ctxt->comp->steps[op->ch2];\n@@ -11930,1 +11932,1 @@\n-    return(0);\n+        return(0);\n@@ -11933,3 +11935,3 @@\n-    (exprOp->op == XPATH_OP_VALUE) &&\n-    (exprOp->value4 != NULL) &&\n-    (((xmlXPathObjectPtr) exprOp->value4)->type == XPATH_NUMBER))\n+        (exprOp->op == XPATH_OP_VALUE) &&\n+        (exprOp->value4 != NULL) &&\n+        (((xmlXPathObjectPtr) exprOp->value4)->type == XPATH_NUMBER))\n@@ -11939,10 +11941,10 @@\n-    \/*\n-    * We have a \"[n]\" predicate here.\n-    * TODO: Unfortunately this simplistic test here is not\n-    * able to detect a position() predicate in compound\n-    * expressions like \"[@attr = 'a\" and position() = 1],\n-    * and even not the usage of position() in\n-    * \"[position() = 1]\"; thus - obviously - a position-range,\n-    * like it \"[position() < 5]\", is also not detected.\n-    * Maybe we could rewrite the AST to ease the optimization.\n-    *\/\n+        \/*\n+        * We have a \"[n]\" predicate here.\n+        * TODO: Unfortunately this simplistic test here is not\n+        * able to detect a position() predicate in compound\n+        * expressions like \"[@attr = 'a\" and position() = 1],\n+        * and even not the usage of position() in\n+        * \"[position() = 1]\"; thus - obviously - a position-range,\n+        * like it \"[position() < 5]\", is also not detected.\n+        * Maybe we could rewrite the AST to ease the optimization.\n+        *\/\n@@ -11951,1 +11953,1 @@\n-        *maxPos = (int) floatval;\n+            *maxPos = (int) floatval;\n@@ -11962,2 +11964,2 @@\n-               xmlNodePtr * first, xmlNodePtr * last,\n-               int toBool)\n+                           xmlNodePtr * first, xmlNodePtr * last,\n+                           int toBool)\n@@ -11968,1 +11970,5 @@\n-    if (++pos == maxPos) { \\\n+        if (++pos == maxPos) { \\\n+            if (addNode(seq, cur) < 0) \\\n+                ctxt->error = XPATH_MEMORY_ERROR; \\\n+            goto axis_range_end; } \\\n+    } else { \\\n@@ -11971,5 +11977,1 @@\n-        goto axis_range_end; } \\\n-    } else { \\\n-    if (addNode(seq, cur) < 0) \\\n-        ctxt->error = XPATH_MEMORY_ERROR; \\\n-    if (breakOnFirstHit) goto first_hit; }\n+        if (breakOnFirstHit) goto first_hit; }\n@@ -11979,1 +11981,6 @@\n-    if (++pos == maxPos) { \\\n+        if (++pos == maxPos) { \\\n+            hasNsNodes = 1; \\\n+            if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \\\n+                ctxt->error = XPATH_MEMORY_ERROR; \\\n+        goto axis_range_end; } \\\n+    } else { \\\n@@ -11983,6 +11990,1 @@\n-    goto axis_range_end; } \\\n-    } else { \\\n-    hasNsNodes = 1; \\\n-    if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \\\n-        ctxt->error = XPATH_MEMORY_ERROR; \\\n-    if (breakOnFirstHit) goto first_hit; }\n+        if (breakOnFirstHit) goto first_hit; }\n@@ -12036,1 +12038,1 @@\n-        xmlXPathReleaseObject(xpctxt, obj);\n+            xmlXPathReleaseObject(xpctxt, obj);\n@@ -12038,1 +12040,1 @@\n-    }\n+        }\n@@ -12065,1 +12067,1 @@\n-        last = NULL;\n+            last = NULL;\n@@ -12067,1 +12069,1 @@\n-        mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;\n+            mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;\n@@ -12070,11 +12072,11 @@\n-        last = NULL;\n-        if (((test == NODE_TEST_NAME) || (test == NODE_TEST_ALL)) &&\n-        (type == NODE_TYPE_NODE))\n-        {\n-        \/*\n-        * Optimization if an element node type is 'element'.\n-        *\/\n-        next = xmlXPathNextChildElement;\n-        } else\n-        next = xmlXPathNextChild;\n-        mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;\n+            last = NULL;\n+            if (((test == NODE_TEST_NAME) || (test == NODE_TEST_ALL)) &&\n+                (type == NODE_TYPE_NODE))\n+            {\n+                \/*\n+                * Optimization if an element node type is 'element'.\n+                *\/\n+                next = xmlXPathNextChildElement;\n+            } else\n+                next = xmlXPathNextChild;\n+            mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;\n@@ -12083,1 +12085,1 @@\n-        last = NULL;\n+            last = NULL;\n@@ -12087,1 +12089,1 @@\n-        last = NULL;\n+            last = NULL;\n@@ -12091,1 +12093,1 @@\n-        last = NULL;\n+            last = NULL;\n@@ -12095,1 +12097,1 @@\n-        last = NULL;\n+            last = NULL;\n@@ -12100,1 +12102,1 @@\n-        last = NULL;\n+            last = NULL;\n@@ -12102,1 +12104,1 @@\n-        mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;\n+            mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;\n@@ -12118,1 +12120,1 @@\n-        last = NULL;\n+            last = NULL;\n@@ -12120,1 +12122,1 @@\n-        mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;\n+            mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;\n@@ -12126,1 +12128,1 @@\n-    (obj->nodesetval != NULL) ? obj->nodesetval->nodeNr : 0);\n+        (obj->nodesetval != NULL) ? obj->nodesetval->nodeNr : 0);\n@@ -12130,1 +12132,1 @@\n-    xmlXPathReleaseObject(xpctxt, obj);\n+        xmlXPathReleaseObject(xpctxt, obj);\n@@ -12135,1 +12137,1 @@\n-    xmlXPathReleaseObject(xpctxt, obj);\n+        xmlXPathReleaseObject(xpctxt, obj);\n@@ -12162,12 +12164,0 @@\n-    \/*\n-    * There's at least one predicate. 16 == XPATH_OP_PREDICATE\n-    *\/\n-    predOp = &ctxt->comp->steps[op->ch2];\n-    if (xmlXPathIsPositionalPredicate(ctxt, predOp, &maxPos)) {\n-        if (predOp->ch1 != -1) {\n-        \/*\n-        * Use the next inner predicate operator.\n-        *\/\n-        predOp = &ctxt->comp->steps[predOp->ch1];\n-        hasPredicateRange = 1;\n-        } else {\n@@ -12175,1 +12165,1 @@\n-        * There's no other predicate than the [n] predicate.\n+        * There's at least one predicate. 16 == XPATH_OP_PREDICATE\n@@ -12177,2 +12167,15 @@\n-        predOp = NULL;\n-        hasAxisRange = 1;\n+        predOp = &ctxt->comp->steps[op->ch2];\n+        if (xmlXPathIsPositionalPredicate(ctxt, predOp, &maxPos)) {\n+            if (predOp->ch1 != -1) {\n+                \/*\n+                * Use the next inner predicate operator.\n+                *\/\n+                predOp = &ctxt->comp->steps[predOp->ch1];\n+                hasPredicateRange = 1;\n+            } else {\n+                \/*\n+                * There's no other predicate than the [n] predicate.\n+                *\/\n+                predOp = NULL;\n+                hasAxisRange = 1;\n+            }\n@@ -12181,1 +12184,0 @@\n-    }\n@@ -12206,1 +12208,1 @@\n-    xpctxt->node = contextSeq->nodeTab[contextIdx++];\n+        xpctxt->node = contextSeq->nodeTab[contextIdx++];\n@@ -12208,2 +12210,0 @@\n-    if (seq == NULL) {\n-        seq = xmlXPathNodeSetCreate(NULL);\n@@ -12211,0 +12211,2 @@\n+            seq = xmlXPathNodeSetCreate(NULL);\n+            if (seq == NULL) {\n@@ -12212,2 +12214,3 @@\n-        total = 0;\n-        goto error;\n+                total = 0;\n+                goto error;\n+            }\n@@ -12215,7 +12218,6 @@\n-    }\n-    \/*\n-    * Traverse the axis and test the nodes.\n-    *\/\n-    pos = 0;\n-    cur = NULL;\n-    hasNsNodes = 0;\n+        \/*\n+        * Traverse the axis and test the nodes.\n+        *\/\n+        pos = 0;\n+        cur = NULL;\n+        hasNsNodes = 0;\n@@ -12230,3 +12232,3 @@\n-        \/*\n-        * QUESTION TODO: What does the \"first\" and \"last\" stuff do?\n-        *\/\n+            \/*\n+            * QUESTION TODO: What does the \"first\" and \"last\" stuff do?\n+            *\/\n@@ -12234,3 +12236,3 @@\n-        if (*first == cur)\n-            break;\n-        if (((total % 256) == 0) &&\n+                if (*first == cur)\n+                    break;\n+                if (((total % 256) == 0) &&\n@@ -12238,1 +12240,1 @@\n-            (xmlXPathCmpNodesExt(*first, cur) >= 0))\n+                    (xmlXPathCmpNodesExt(*first, cur) >= 0))\n@@ -12240,1 +12242,1 @@\n-            (xmlXPathCmpNodes(*first, cur) >= 0))\n+                    (xmlXPathCmpNodes(*first, cur) >= 0))\n@@ -12242,8 +12244,8 @@\n-        {\n-            break;\n-        }\n-        }\n-        if ((last != NULL) && (*last != NULL)) {\n-        if (*last == cur)\n-            break;\n-        if (((total % 256) == 0) &&\n+                {\n+                    break;\n+                }\n+            }\n+            if ((last != NULL) && (*last != NULL)) {\n+                if (*last == cur)\n+                    break;\n+                if (((total % 256) == 0) &&\n@@ -12251,1 +12253,1 @@\n-            (xmlXPathCmpNodesExt(cur, *last) >= 0))\n+                    (xmlXPathCmpNodesExt(cur, *last) >= 0))\n@@ -12253,1 +12255,1 @@\n-            (xmlXPathCmpNodes(cur, *last) >= 0))\n+                    (xmlXPathCmpNodes(cur, *last) >= 0))\n@@ -12255,4 +12257,4 @@\n-        {\n-            break;\n-        }\n-        }\n+                {\n+                    break;\n+                }\n+            }\n@@ -12266,1 +12268,1 @@\n-        switch (test) {\n+            switch (test) {\n@@ -12268,1 +12270,1 @@\n-            total = 0;\n+                    total = 0;\n@@ -12270,1 +12272,1 @@\n-            goto error;\n+                    goto error;\n@@ -12272,4 +12274,4 @@\n-            if (type == NODE_TYPE_NODE) {\n-            switch (cur->type) {\n-                case XML_DOCUMENT_NODE:\n-                case XML_HTML_DOCUMENT_NODE:\n+                    if (type == NODE_TYPE_NODE) {\n+                        switch (cur->type) {\n+                            case XML_DOCUMENT_NODE:\n+                            case XML_HTML_DOCUMENT_NODE:\n@@ -12277,18 +12279,18 @@\n-                case XML_DOCB_DOCUMENT_NODE:\n-#endif\n-                case XML_ELEMENT_NODE:\n-                case XML_ATTRIBUTE_NODE:\n-                case XML_PI_NODE:\n-                case XML_COMMENT_NODE:\n-                case XML_CDATA_SECTION_NODE:\n-                case XML_TEXT_NODE:\n-                XP_TEST_HIT\n-                break;\n-                case XML_NAMESPACE_DECL: {\n-                if (axis == AXIS_NAMESPACE) {\n-                    XP_TEST_HIT_NS\n-                } else {\n-                                hasNsNodes = 1;\n-                    XP_TEST_HIT\n-                }\n-                break;\n+                            case XML_DOCB_DOCUMENT_NODE:\n+#endif\n+                            case XML_ELEMENT_NODE:\n+                            case XML_ATTRIBUTE_NODE:\n+                            case XML_PI_NODE:\n+                            case XML_COMMENT_NODE:\n+                            case XML_CDATA_SECTION_NODE:\n+                            case XML_TEXT_NODE:\n+                                XP_TEST_HIT\n+                                break;\n+                            case XML_NAMESPACE_DECL: {\n+                                if (axis == AXIS_NAMESPACE) {\n+                                    XP_TEST_HIT_NS\n+                                } else {\n+                                    hasNsNodes = 1;\n+                                    XP_TEST_HIT\n+                                }\n+                                break;\n@@ -12296,14 +12298,14 @@\n-                default:\n-                break;\n-            }\n-            } else if (cur->type == (xmlElementType) type) {\n-            if (cur->type == XML_NAMESPACE_DECL)\n-                XP_TEST_HIT_NS\n-            else\n-                XP_TEST_HIT\n-            } else if ((type == NODE_TYPE_TEXT) &&\n-             (cur->type == XML_CDATA_SECTION_NODE))\n-            {\n-            XP_TEST_HIT\n-            }\n-            break;\n+                            default:\n+                                break;\n+                        }\n+                    } else if (cur->type == (xmlElementType) type) {\n+                        if (cur->type == XML_NAMESPACE_DECL)\n+                            XP_TEST_HIT_NS\n+                        else\n+                            XP_TEST_HIT\n+                    } else if ((type == NODE_TYPE_TEXT) &&\n+                         (cur->type == XML_CDATA_SECTION_NODE))\n+                    {\n+                        XP_TEST_HIT\n+                    }\n+                    break;\n@@ -12313,2 +12315,2 @@\n-            {\n-            XP_TEST_HIT\n+                    {\n+                        XP_TEST_HIT\n@@ -12320,1 +12322,1 @@\n-            {\n+                        {\n@@ -12322,2 +12324,2 @@\n-                {\n-                XP_TEST_HIT\n+                            {\n+                                XP_TEST_HIT\n@@ -12325,3 +12327,3 @@\n-                (xmlStrEqual(URI, cur->ns->href)))\n-                {\n-                XP_TEST_HIT\n+                                (xmlStrEqual(URI, cur->ns->href)))\n+                            {\n+                                XP_TEST_HIT\n@@ -12332,2 +12334,2 @@\n-            {\n-                XP_TEST_HIT_NS\n+                        {\n+                            XP_TEST_HIT_NS\n@@ -12338,2 +12340,2 @@\n-                {\n-                XP_TEST_HIT\n+                            {\n+                                XP_TEST_HIT\n@@ -12342,3 +12344,3 @@\n-                (xmlStrEqual(URI, cur->ns->href)))\n-                {\n-                XP_TEST_HIT\n+                                (xmlStrEqual(URI, cur->ns->href)))\n+                            {\n+                                XP_TEST_HIT\n@@ -12356,2 +12358,2 @@\n-                break;\n-            } else if (axis == AXIS_NAMESPACE) {\n+                            break;\n+                    } else if (axis == AXIS_NAMESPACE) {\n@@ -12359,5 +12361,5 @@\n-                break;\n-            } else {\n-                if (cur->type != XML_ELEMENT_NODE)\n-                break;\n-            }\n+                            break;\n+                    } else {\n+                        if (cur->type != XML_ELEMENT_NODE)\n+                            break;\n+                    }\n@@ -12369,2 +12371,2 @@\n-                    {\n-                    XP_TEST_HIT\n+                                    {\n+                                        XP_TEST_HIT\n@@ -12375,2 +12377,2 @@\n-                    {\n-                    XP_TEST_HIT\n+                                    {\n+                                        XP_TEST_HIT\n@@ -12388,2 +12390,2 @@\n-                    {\n-                        XP_TEST_HIT\n+                                        {\n+                                            XP_TEST_HIT\n@@ -12394,3 +12396,3 @@\n-                          attr->ns->href)))\n-                    {\n-                        XP_TEST_HIT\n+                                              attr->ns->href)))\n+                                        {\n+                                            XP_TEST_HIT\n@@ -12408,2 +12410,2 @@\n-                {\n-                    XP_TEST_HIT_NS\n+                                {\n+                                    XP_TEST_HIT_NS\n@@ -12417,1 +12419,1 @@\n-        } \/* switch(test) *\/\n+            } \/* switch(test) *\/\n@@ -12420,1 +12422,1 @@\n-    goto apply_predicates;\n+        goto apply_predicates;\n@@ -12423,10 +12425,10 @@\n-    \/*\n-    * We have a \"\/foo[n]\", and position() = n was reached.\n-    * Note that we can have as well \"\/foo\/::parent::foo[1]\", so\n-    * a duplicate-aware merge is still needed.\n-    * Merge with the result.\n-    *\/\n-    if (outSeq == NULL) {\n-        outSeq = seq;\n-        seq = NULL;\n-    } else\n+        \/*\n+        * We have a \"\/foo[n]\", and position() = n was reached.\n+        * Note that we can have as well \"\/foo\/::parent::foo[1]\", so\n+        * a duplicate-aware merge is still needed.\n+        * Merge with the result.\n+        *\/\n+        if (outSeq == NULL) {\n+            outSeq = seq;\n+            seq = NULL;\n+        } else\n@@ -12434,7 +12436,7 @@\n-        outSeq = mergeAndClear(outSeq, seq);\n-    \/*\n-    * Break if only a true\/false result was requested.\n-    *\/\n-    if (toBool)\n-        break;\n-    continue;\n+            outSeq = mergeAndClear(outSeq, seq);\n+        \/*\n+        * Break if only a true\/false result was requested.\n+        *\/\n+        if (toBool)\n+            break;\n+        continue;\n@@ -12443,8 +12445,8 @@\n-    \/*\n-    * Break if only a true\/false result was requested and\n-    * no predicates existed and a node test succeeded.\n-    *\/\n-    if (outSeq == NULL) {\n-        outSeq = seq;\n-        seq = NULL;\n-    } else\n+        \/*\n+        * Break if only a true\/false result was requested and\n+        * no predicates existed and a node test succeeded.\n+        *\/\n+        if (outSeq == NULL) {\n+            outSeq = seq;\n+            seq = NULL;\n+        } else\n@@ -12452,2 +12454,2 @@\n-        outSeq = mergeAndClear(outSeq, seq);\n-    break;\n+            outSeq = mergeAndClear(outSeq, seq);\n+        break;\n@@ -12456,2 +12458,2 @@\n-    if (seq != NULL)\n-        nbMatches += seq->nodeNr;\n+        if (seq != NULL)\n+            nbMatches += seq->nodeNr;\n@@ -12462,1 +12464,1 @@\n-        goto error;\n+            goto error;\n@@ -12465,14 +12467,1 @@\n-    * Apply predicates.\n-    *\/\n-        if ((predOp != NULL) && (seq->nodeNr > 0)) {\n-        \/*\n-        * E.g. when we have a \"\/foo[some expression][n]\".\n-        *\/\n-        \/*\n-        * QUESTION TODO: The old predicate evaluation took into\n-        *  account location-sets.\n-        *  (E.g. ctxt->value->type == XPATH_LOCATIONSET)\n-        *  Do we expect such a set here?\n-        *  All what I learned now from the evaluation semantics\n-        *  does not indicate that a location-set will be processed\n-        *  here, so this looks OK.\n+        * Apply predicates.\n@@ -12480,22 +12469,35 @@\n-        \/*\n-        * Iterate over all predicates, starting with the outermost\n-        * predicate.\n-        * TODO: Problem: we cannot execute the inner predicates first\n-        *  since we cannot go back *up* the operator tree!\n-        *  Options we have:\n-        *  1) Use of recursive functions (like is it currently done\n-        *     via xmlXPathCompOpEval())\n-        *  2) Add a predicate evaluation information stack to the\n-        *     context struct\n-        *  3) Change the way the operators are linked; we need a\n-        *     \"parent\" field on xmlXPathStepOp\n-        *\n-        * For the moment, I'll try to solve this with a recursive\n-        * function: xmlXPathCompOpEvalPredicate().\n-        *\/\n-        if (hasPredicateRange != 0)\n-        xmlXPathCompOpEvalPredicate(ctxt, predOp, seq, maxPos, maxPos,\n-                        hasNsNodes);\n-        else\n-        xmlXPathCompOpEvalPredicate(ctxt, predOp, seq, 1, seq->nodeNr,\n-                        hasNsNodes);\n+        if ((predOp != NULL) && (seq->nodeNr > 0)) {\n+            \/*\n+            * E.g. when we have a \"\/foo[some expression][n]\".\n+            *\/\n+            \/*\n+            * QUESTION TODO: The old predicate evaluation took into\n+            *  account location-sets.\n+            *  (E.g. ctxt->value->type == XPATH_LOCATIONSET)\n+            *  Do we expect such a set here?\n+            *  All what I learned now from the evaluation semantics\n+            *  does not indicate that a location-set will be processed\n+            *  here, so this looks OK.\n+            *\/\n+            \/*\n+            * Iterate over all predicates, starting with the outermost\n+            * predicate.\n+            * TODO: Problem: we cannot execute the inner predicates first\n+            *  since we cannot go back *up* the operator tree!\n+            *  Options we have:\n+            *  1) Use of recursive functions (like is it currently done\n+            *     via xmlXPathCompOpEval())\n+            *  2) Add a predicate evaluation information stack to the\n+            *     context struct\n+            *  3) Change the way the operators are linked; we need a\n+            *     \"parent\" field on xmlXPathStepOp\n+            *\n+            * For the moment, I'll try to solve this with a recursive\n+            * function: xmlXPathCompOpEvalPredicate().\n+            *\/\n+            if (hasPredicateRange != 0)\n+                xmlXPathCompOpEvalPredicate(ctxt, predOp, seq, maxPos, maxPos,\n+                                            hasNsNodes);\n+            else\n+                xmlXPathCompOpEvalPredicate(ctxt, predOp, seq, 1, seq->nodeNr,\n+                                            hasNsNodes);\n@@ -12503,4 +12505,4 @@\n-        if (ctxt->error != XPATH_EXPRESSION_OK) {\n-        total = 0;\n-        goto error;\n-        }\n+            if (ctxt->error != XPATH_EXPRESSION_OK) {\n+                total = 0;\n+                goto error;\n+            }\n@@ -12510,7 +12512,7 @@\n-        \/*\n-        * Add to result set.\n-        *\/\n-        if (outSeq == NULL) {\n-        outSeq = seq;\n-        seq = NULL;\n-        } else {\n+            \/*\n+            * Add to result set.\n+            *\/\n+            if (outSeq == NULL) {\n+                outSeq = seq;\n+                seq = NULL;\n+            } else {\n@@ -12518,2 +12520,2 @@\n-        outSeq = mergeAndClear(outSeq, seq);\n-        }\n+                outSeq = mergeAndClear(outSeq, seq);\n+            }\n@@ -12523,1 +12525,1 @@\n-    }\n+        }\n@@ -12528,9 +12530,9 @@\n-    \/*\n-    * QUESTION TODO: What does this do and why?\n-    * TODO: Do we have to do this also for the \"error\"\n-    * cleanup further down?\n-    *\/\n-    ctxt->value->boolval = 1;\n-    ctxt->value->user = obj->user;\n-    obj->user = NULL;\n-    obj->boolval = 0;\n+        \/*\n+        * QUESTION TODO: What does this do and why?\n+        * TODO: Do we have to do this also for the \"error\"\n+        * cleanup further down?\n+        *\/\n+        ctxt->value->boolval = 1;\n+        ctxt->value->user = obj->user;\n+        obj->user = NULL;\n+        obj->boolval = 0;\n@@ -12544,3 +12546,3 @@\n-    if ((seq != NULL) && (seq->nodeNr == 0))\n-        outSeq = seq;\n-    else\n+        if ((seq != NULL) && (seq->nodeNr == 0))\n+            outSeq = seq;\n+        else\n@@ -12548,1 +12550,1 @@\n-        outSeq = xmlXPathNodeSetCreate(NULL);\n+            outSeq = xmlXPathNodeSetCreate(NULL);\n@@ -12551,1 +12553,1 @@\n-     xmlXPathFreeNodeSet(seq);\n+         xmlXPathFreeNodeSet(seq);\n@@ -12573,2 +12575,2 @@\n-    \"\\nExamined %d nodes, found %d nodes at that step\\n\",\n-    total, nbMatches);\n+        \"\\nExamined %d nodes, found %d nodes at that step\\n\",\n+        total, nbMatches);\n@@ -12582,1 +12584,1 @@\n-                  xmlXPathStepOpPtr op, xmlNodePtr * first);\n+                              xmlXPathStepOpPtr op, xmlNodePtr * first);\n@@ -12617,1 +12619,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -12625,9 +12627,9 @@\n-        \/*\n-        * OPTIMIZE TODO: This implicitly sorts\n-        *  the result, even if not needed. E.g. if the argument\n-        *  of the count() function, no sorting is needed.\n-        * OPTIMIZE TODO: How do we know if the node-list wasn't\n-        *  already sorted?\n-        *\/\n-        if (ctxt->value->nodesetval->nodeNr > 1)\n-            xmlXPathNodeSetSort(ctxt->value->nodesetval);\n+                \/*\n+                * OPTIMIZE TODO: This implicitly sorts\n+                *  the result, even if not needed. E.g. if the argument\n+                *  of the count() function, no sorting is needed.\n+                * OPTIMIZE TODO: How do we know if the node-list wasn't\n+                *  already sorted?\n+                *\/\n+                if (ctxt->value->nodesetval->nodeNr > 1)\n+                    xmlXPathNodeSetSort(ctxt->value->nodesetval);\n@@ -12639,1 +12641,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -12645,2 +12647,2 @@\n-            xmlXPathReleaseObject(ctxt->context, arg1);\n-            xmlXPathReleaseObject(ctxt->context, arg2);\n+                xmlXPathReleaseObject(ctxt->context, arg1);\n+                xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -12656,2 +12658,2 @@\n-            xmlXPathReleaseObject(ctxt->context, arg1);\n-            xmlXPathReleaseObject(ctxt->context, arg2);\n+                xmlXPathReleaseObject(ctxt->context, arg1);\n+                xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -12665,1 +12667,1 @@\n-        xmlXPathReleaseObject(ctxt->context, arg2);\n+            xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -12667,2 +12669,2 @@\n-        if (total > cur)\n-        xmlXPathCompSwap(op);\n+            if (total > cur)\n+                xmlXPathCompSwap(op);\n@@ -12677,1 +12679,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -12680,3 +12682,3 @@\n-        CHECK_ERROR0;\n-        valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n-        ctxt->context->node));\n+            CHECK_ERROR0;\n+            valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n+                ctxt->context->node));\n@@ -12689,1 +12691,1 @@\n-        CHECK_ERROR0;\n+                CHECK_ERROR0;\n@@ -12697,1 +12699,1 @@\n-            (xmlXPathObjectPtr) op->value4));\n+                        (xmlXPathObjectPtr) op->value4));\n@@ -12704,1 +12706,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -12708,1 +12710,1 @@\n-        && (ctxt->value->nodesetval->nodeNr > 1))\n+                && (ctxt->value->nodesetval->nodeNr > 1))\n@@ -12712,1 +12714,1 @@\n-    case XPATH_OP_FILTER:\n+        case XPATH_OP_FILTER:\n@@ -12757,1 +12759,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -12765,2 +12767,2 @@\n-        if (ctxt->value->nodesetval->nodeNr > 1)\n-            xmlXPathNodeSetSort(ctxt->value->nodesetval);\n+                if (ctxt->value->nodesetval->nodeNr > 1)\n+                    xmlXPathNodeSetSort(ctxt->value->nodesetval);\n@@ -12774,1 +12776,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -12785,2 +12787,2 @@\n-            xmlXPathReleaseObject(ctxt->context, arg1);\n-            xmlXPathReleaseObject(ctxt->context, arg2);\n+                xmlXPathReleaseObject(ctxt->context, arg1);\n+                xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -12796,2 +12798,2 @@\n-            xmlXPathReleaseObject(ctxt->context, arg1);\n-            xmlXPathReleaseObject(ctxt->context, arg2);\n+                xmlXPathReleaseObject(ctxt->context, arg1);\n+                xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -12805,1 +12807,1 @@\n-        xmlXPathReleaseObject(ctxt->context, arg2);\n+            xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -12807,2 +12809,2 @@\n-        if (total > cur)\n-        xmlXPathCompSwap(op);\n+            if (total > cur)\n+                xmlXPathCompSwap(op);\n@@ -12817,1 +12819,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -12820,3 +12822,3 @@\n-        CHECK_ERROR0;\n-        valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n-        ctxt->context->node));\n+            CHECK_ERROR0;\n+            valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n+                ctxt->context->node));\n@@ -12829,1 +12831,1 @@\n-        CHECK_ERROR0;\n+                CHECK_ERROR0;\n@@ -12837,1 +12839,1 @@\n-            (xmlXPathObjectPtr) op->value4));\n+                        (xmlXPathObjectPtr) op->value4));\n@@ -12844,1 +12846,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -12848,1 +12850,1 @@\n-        && (ctxt->value->nodesetval->nodeNr > 1))\n+                && (ctxt->value->nodesetval->nodeNr > 1))\n@@ -12863,1 +12865,1 @@\n-                  xmlXPathStepOpPtr op, xmlNodePtr * first)\n+                              xmlXPathStepOpPtr op, xmlNodePtr * first)\n@@ -12875,27 +12877,27 @@\n-    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n-    (comp->steps[op->ch2].op == XPATH_OP_SORT)) {\n-    int f = comp->steps[op->ch2].ch1;\n-\n-    if ((f != -1) &&\n-        (comp->steps[f].op == XPATH_OP_FUNCTION) &&\n-        (comp->steps[f].value5 == NULL) &&\n-        (comp->steps[f].value == 0) &&\n-        (comp->steps[f].value4 != NULL) &&\n-        (xmlStrEqual\n-        (comp->steps[f].value4, BAD_CAST \"last\"))) {\n-        xmlNodePtr last = NULL;\n-\n-        total +=\n-        xmlXPathCompOpEvalLast(ctxt,\n-            &comp->steps[op->ch1],\n-            &last);\n-        CHECK_ERROR0;\n-        \/*\n-        * The nodeset should be in document order,\n-        * Keep only the last value\n-        *\/\n-        if ((ctxt->value != NULL) &&\n-        (ctxt->value->type == XPATH_NODESET) &&\n-        (ctxt->value->nodesetval != NULL) &&\n-        (ctxt->value->nodesetval->nodeTab != NULL) &&\n-        (ctxt->value->nodesetval->nodeNr > 1)) {\n+        (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n+        (comp->steps[op->ch2].op == XPATH_OP_SORT)) {\n+        int f = comp->steps[op->ch2].ch1;\n+\n+        if ((f != -1) &&\n+            (comp->steps[f].op == XPATH_OP_FUNCTION) &&\n+            (comp->steps[f].value5 == NULL) &&\n+            (comp->steps[f].value == 0) &&\n+            (comp->steps[f].value4 != NULL) &&\n+            (xmlStrEqual\n+            (comp->steps[f].value4, BAD_CAST \"last\"))) {\n+            xmlNodePtr last = NULL;\n+\n+            total +=\n+                xmlXPathCompOpEvalLast(ctxt,\n+                    &comp->steps[op->ch1],\n+                    &last);\n+            CHECK_ERROR0;\n+            \/*\n+            * The nodeset should be in document order,\n+            * Keep only the last value\n+            *\/\n+            if ((ctxt->value != NULL) &&\n+                (ctxt->value->type == XPATH_NODESET) &&\n+                (ctxt->value->nodesetval != NULL) &&\n+                (ctxt->value->nodesetval->nodeTab != NULL) &&\n+                (ctxt->value->nodesetval->nodeNr > 1)) {\n@@ -12903,1 +12905,3 @@\n-        *first = *(ctxt->value->nodesetval->nodeTab);\n+                *first = *(ctxt->value->nodesetval->nodeTab);\n+            }\n+            return (total);\n@@ -12905,2 +12909,0 @@\n-        return (total);\n-    }\n@@ -12910,1 +12912,1 @@\n-    total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n+        total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n@@ -12913,1 +12915,1 @@\n-    return (total);\n+        return (total);\n@@ -12915,1 +12917,1 @@\n-    return (total);\n+        return (total);\n@@ -12930,1 +12932,1 @@\n-    return (total);\n+        return (total);\n@@ -12974,1 +12976,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -12980,4 +12982,4 @@\n-        if (ctxt->error) {\n-        xmlXPathFreeObject(arg2);\n-        break;\n-        }\n+            if (ctxt->error) {\n+                xmlXPathFreeObject(arg2);\n+                break;\n+            }\n@@ -12987,1 +12989,1 @@\n-        xmlXPathReleaseObject(ctxt->context, arg2);\n+            xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -12991,1 +12993,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -12997,4 +12999,4 @@\n-        if (ctxt->error) {\n-        xmlXPathFreeObject(arg2);\n-        break;\n-        }\n+            if (ctxt->error) {\n+                xmlXPathFreeObject(arg2);\n+                break;\n+            }\n@@ -13004,1 +13006,1 @@\n-        xmlXPathReleaseObject(ctxt->context, arg2);\n+            xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -13008,1 +13010,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -13010,6 +13012,6 @@\n-        CHECK_ERROR0;\n-        if (op->value)\n-        equal = xmlXPathEqualValues(ctxt);\n-        else\n-        equal = xmlXPathNotEqualValues(ctxt);\n-        valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, equal));\n+            CHECK_ERROR0;\n+            if (op->value)\n+                equal = xmlXPathEqualValues(ctxt);\n+            else\n+                equal = xmlXPathNotEqualValues(ctxt);\n+            valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, equal));\n@@ -13019,1 +13021,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -13021,1 +13023,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -13023,1 +13025,1 @@\n-        valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, ret));\n+            valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt->context, ret));\n@@ -13027,1 +13029,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -13030,2 +13032,2 @@\n-        }\n-        CHECK_ERROR0;\n+            }\n+            CHECK_ERROR0;\n@@ -13045,1 +13047,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -13047,1 +13049,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -13057,1 +13059,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -13059,1 +13061,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -13065,2 +13067,2 @@\n-            xmlXPathReleaseObject(ctxt->context, arg1);\n-            xmlXPathReleaseObject(ctxt->context, arg2);\n+                xmlXPathReleaseObject(ctxt->context, arg1);\n+                xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -13076,2 +13078,2 @@\n-            xmlXPathReleaseObject(ctxt->context, arg1);\n-            xmlXPathReleaseObject(ctxt->context, arg2);\n+                xmlXPathReleaseObject(ctxt->context, arg1);\n+                xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -13081,4 +13083,4 @@\n-        if ((arg1->nodesetval == NULL) ||\n-        ((arg2->nodesetval != NULL) &&\n-         (arg2->nodesetval->nodeNr != 0)))\n-        {\n+            if ((arg1->nodesetval == NULL) ||\n+                ((arg2->nodesetval != NULL) &&\n+                 (arg2->nodesetval->nodeNr != 0)))\n+            {\n@@ -13086,3 +13088,3 @@\n-        arg1->nodesetval = xmlXPathNodeSetMerge(arg1->nodesetval,\n-                            arg2->nodesetval);\n-        }\n+                arg1->nodesetval = xmlXPathNodeSetMerge(arg1->nodesetval,\n+                                                        arg2->nodesetval);\n+            }\n@@ -13091,1 +13093,1 @@\n-        xmlXPathReleaseObject(ctxt->context, arg2);\n+            xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -13099,1 +13101,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -13102,3 +13104,3 @@\n-        CHECK_ERROR0;\n-        valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n-        ctxt->context->node));\n+            CHECK_ERROR0;\n+            valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt->context,\n+                ctxt->context->node));\n@@ -13111,1 +13113,1 @@\n-        CHECK_ERROR0;\n+                CHECK_ERROR0;\n@@ -13119,1 +13121,1 @@\n-            (xmlXPathObjectPtr) op->value4));\n+                        (xmlXPathObjectPtr) op->value4));\n@@ -13122,1 +13124,1 @@\n-        xmlXPathObjectPtr val;\n+                xmlXPathObjectPtr val;\n@@ -13128,3 +13130,3 @@\n-            val = xmlXPathVariableLookup(ctxt->context, op->value4);\n-            if (val == NULL)\n-            XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);\n+                    val = xmlXPathVariableLookup(ctxt->context, op->value4);\n+                    if (val == NULL)\n+                        XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);\n@@ -13132,1 +13134,1 @@\n-        } else {\n+                } else {\n@@ -13143,1 +13145,1 @@\n-            val = xmlXPathVariableLookupNS(ctxt->context,\n+                    val = xmlXPathVariableLookupNS(ctxt->context,\n@@ -13145,2 +13147,2 @@\n-            if (val == NULL)\n-            XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);\n+                    if (val == NULL)\n+                        XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);\n@@ -13154,1 +13156,1 @@\n-        int i;\n+                int i;\n@@ -13166,4 +13168,4 @@\n-        if (ctxt->valueNr < ctxt->valueFrame + op->value) {\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"xmlXPathCompOpEval: parameter error\\n\");\n-            ctxt->error = XPATH_INVALID_OPERAND;\n+                if (ctxt->valueNr < ctxt->valueFrame + op->value) {\n+                    xmlGenericError(xmlGenericErrorContext,\n+                            \"xmlXPathCompOpEval: parameter error\\n\");\n+                    ctxt->error = XPATH_INVALID_OPERAND;\n@@ -13171,7 +13173,7 @@\n-            break;\n-        }\n-        for (i = 0; i < op->value; i++) {\n-            if (ctxt->valueTab[(ctxt->valueNr - 1) - i] == NULL) {\n-            xmlGenericError(xmlGenericErrorContext,\n-                \"xmlXPathCompOpEval: parameter error\\n\");\n-            ctxt->error = XPATH_INVALID_OPERAND;\n+                    break;\n+                }\n+                for (i = 0; i < op->value; i++) {\n+                    if (ctxt->valueTab[(ctxt->valueNr - 1) - i] == NULL) {\n+                        xmlGenericError(xmlGenericErrorContext,\n+                                \"xmlXPathCompOpEval: parameter error\\n\");\n+                        ctxt->error = XPATH_INVALID_OPERAND;\n@@ -13179,2 +13181,2 @@\n-            break;\n-            }\n+                        break;\n+                    }\n@@ -13229,1 +13231,1 @@\n-            CHECK_ERROR0;\n+                CHECK_ERROR0;\n@@ -13233,2 +13235,2 @@\n-            CHECK_ERROR0;\n-        }\n+                CHECK_ERROR0;\n+            }\n@@ -13245,9 +13247,9 @@\n-            \/*\n-            * FILTER TODO: Can we assume that the inner processing\n-            *  will result in an ordered list if we have an\n-            *  XPATH_OP_FILTER?\n-            *  What about an additional field or flag on\n-            *  xmlXPathObject like @sorted ? This way we wouldn't need\n-            *  to assume anything, so it would be more robust and\n-            *  easier to optimize.\n-            *\/\n+                    \/*\n+                    * FILTER TODO: Can we assume that the inner processing\n+                    *  will result in an ordered list if we have an\n+                    *  XPATH_OP_FILTER?\n+                    *  What about an additional field or flag on\n+                    *  xmlXPathObject like @sorted ? This way we wouldn't need\n+                    *  to assume anything, so it would be more robust and\n+                    *  easier to optimize.\n+                    *\/\n@@ -13255,1 +13257,1 @@\n-             (comp->steps[op->ch1].op == XPATH_OP_FILTER)) && \/* 17 *\/\n+                     (comp->steps[op->ch1].op == XPATH_OP_FILTER)) && \/* 17 *\/\n@@ -13257,1 +13259,1 @@\n-            (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n+                    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n@@ -13271,1 +13273,1 @@\n-            CHECK_ERROR0;\n+                        CHECK_ERROR0;\n@@ -13306,1 +13308,1 @@\n-            CHECK_ERROR0;\n+                        CHECK_ERROR0;\n@@ -13320,11 +13322,11 @@\n-        \/*\n-        * Process inner predicates first.\n-        * Example \"index[parent::book][1]\":\n-        * ...\n-        *   PREDICATE   <-- we are here \"[1]\"\n-        *     PREDICATE <-- process \"[parent::book]\" first\n-        *       SORT\n-        *         COLLECT  'parent' 'name' 'node' book\n-        *           NODE\n-        *     ELEM Object is a number : 1\n-        *\/\n+                \/*\n+                * Process inner predicates first.\n+                * Example \"index[parent::book][1]\":\n+                * ...\n+                *   PREDICATE   <-- we are here \"[1]\"\n+                *     PREDICATE <-- process \"[parent::book]\" first\n+                *       SORT\n+                *         COLLECT  'parent' 'name' 'node' book\n+                *           NODE\n+                *     ELEM Object is a number : 1\n+                *\/\n@@ -13334,1 +13336,1 @@\n-        CHECK_ERROR0;\n+                CHECK_ERROR0;\n@@ -13362,1 +13364,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -13366,2 +13368,2 @@\n-        (ctxt->value->nodesetval->nodeNr > 1))\n-        {\n+                (ctxt->value->nodesetval->nodeNr > 1))\n+            {\n@@ -13369,1 +13371,1 @@\n-        }\n+            }\n@@ -13377,1 +13379,1 @@\n-            xmlLocationSetPtr oldlocset;\n+                    xmlLocationSetPtr oldlocset;\n@@ -13420,2 +13422,2 @@\n-            tmp = xmlXPathCacheNewNodeSet(ctxt->context,\n-                ctxt->context->node);\n+                        tmp = xmlXPathCacheNewNodeSet(ctxt->context,\n+                            ctxt->context->node);\n@@ -13428,1 +13430,1 @@\n-            if (ctxt->error != XPATH_EXPRESSION_OK) {\n+                        if (ctxt->error != XPATH_EXPRESSION_OK) {\n@@ -13431,1 +13433,1 @@\n-            }\n+                        }\n@@ -13434,16 +13436,16 @@\n-            if (res->type == XPATH_LOCATIONSET) {\n-                xmlLocationSetPtr rloc =\n-                    (xmlLocationSetPtr)res->user;\n-                for (j=0; j<rloc->locNr; j++) {\n-                    range = xmlXPtrNewRange(\n-                  oldlocset->locTab[i]->user,\n-                  oldlocset->locTab[i]->index,\n-                  rloc->locTab[j]->user2,\n-                  rloc->locTab[j]->index2);\n-                if (range != NULL) {\n-                    xmlXPtrLocationSetAdd(newlocset, range);\n-                }\n-                }\n-            } else {\n-                range = xmlXPtrNewRangeNodeObject(\n-                (xmlNodePtr)oldlocset->locTab[i]->user, res);\n+                        if (res->type == XPATH_LOCATIONSET) {\n+                            xmlLocationSetPtr rloc =\n+                                (xmlLocationSetPtr)res->user;\n+                            for (j=0; j<rloc->locNr; j++) {\n+                                range = xmlXPtrNewRange(\n+                                  oldlocset->locTab[i]->user,\n+                                  oldlocset->locTab[i]->index,\n+                                  rloc->locTab[j]->user2,\n+                                  rloc->locTab[j]->index2);\n+                                if (range != NULL) {\n+                                    xmlXPtrLocationSetAdd(newlocset, range);\n+                                }\n+                            }\n+                        } else {\n+                            range = xmlXPtrNewRangeNodeObject(\n+                                (xmlNodePtr)oldlocset->locTab[i]->user, res);\n@@ -13452,1 +13454,1 @@\n-                }\n+                            }\n@@ -13459,2 +13461,2 @@\n-                xmlXPathReleaseObject(ctxt->context, res);\n-            }\n+                            xmlXPathReleaseObject(ctxt->context, res);\n+                        }\n@@ -13463,1 +13465,1 @@\n-                xmlXPathReleaseObject(ctxt->context, res);\n+                            xmlXPathReleaseObject(ctxt->context, res);\n@@ -13466,1 +13468,1 @@\n-        } else {    \/* Not a location set *\/\n+                } else {        \/* Not a location set *\/\n@@ -13480,5 +13482,5 @@\n-                \/*\n-                * OPTIMIZE TODO: Avoid recreation for every iteration.\n-                *\/\n-                tmp = xmlXPathCacheNewNodeSet(ctxt->context,\n-                ctxt->context->node);\n+                            \/*\n+                            * OPTIMIZE TODO: Avoid recreation for every iteration.\n+                            *\/\n+                            tmp = xmlXPathCacheNewNodeSet(ctxt->context,\n+                                ctxt->context->node);\n@@ -13491,1 +13493,1 @@\n-                if (ctxt->error != XPATH_EXPRESSION_OK) {\n+                            if (ctxt->error != XPATH_EXPRESSION_OK) {\n@@ -13494,1 +13496,1 @@\n-                }\n+                            }\n@@ -13508,2 +13510,2 @@\n-                xmlXPathReleaseObject(ctxt->context, res);\n-                }\n+                                xmlXPathReleaseObject(ctxt->context, res);\n+                            }\n@@ -13512,1 +13514,1 @@\n-                xmlXPathReleaseObject(ctxt->context, res);\n+                                xmlXPathReleaseObject(ctxt->context, res);\n@@ -13523,1 +13525,1 @@\n-        xmlXPathReleaseObject(ctxt->context, obj);\n+                xmlXPathReleaseObject(ctxt->context, obj);\n@@ -13551,2 +13553,2 @@\n-                xmlXPathStepOpPtr op,\n-                int isPredicate)\n+                            xmlXPathStepOpPtr op,\n+                            int isPredicate)\n@@ -13563,9 +13565,9 @@\n-    case XPATH_OP_VALUE:\n-        resObj = (xmlXPathObjectPtr) op->value4;\n-        if (isPredicate)\n-        return(xmlXPathEvaluatePredicateResult(ctxt, resObj));\n-        return(xmlXPathCastToBoolean(resObj));\n-    case XPATH_OP_SORT:\n-        \/*\n-        * We don't need sorting for boolean results. Skip this one.\n-        *\/\n+        case XPATH_OP_VALUE:\n+            resObj = (xmlXPathObjectPtr) op->value4;\n+            if (isPredicate)\n+                return(xmlXPathEvaluatePredicateResult(ctxt, resObj));\n+            return(xmlXPathCastToBoolean(resObj));\n+        case XPATH_OP_SORT:\n+            \/*\n+            * We don't need sorting for boolean results. Skip this one.\n+            *\/\n@@ -13573,7 +13575,7 @@\n-        op = &ctxt->comp->steps[op->ch1];\n-        goto start;\n-        }\n-        return(0);\n-    case XPATH_OP_COLLECT:\n-        if (op->ch1 == -1)\n-        return(0);\n+                op = &ctxt->comp->steps[op->ch1];\n+                goto start;\n+            }\n+            return(0);\n+        case XPATH_OP_COLLECT:\n+            if (op->ch1 == -1)\n+                return(0);\n@@ -13582,2 +13584,2 @@\n-        if (ctxt->error != XPATH_EXPRESSION_OK)\n-        return(-1);\n+            if (ctxt->error != XPATH_EXPRESSION_OK)\n+                return(-1);\n@@ -13586,2 +13588,2 @@\n-        if (ctxt->error != XPATH_EXPRESSION_OK)\n-        return(-1);\n+            if (ctxt->error != XPATH_EXPRESSION_OK)\n+                return(-1);\n@@ -13589,11 +13591,11 @@\n-        resObj = valuePop(ctxt);\n-        if (resObj == NULL)\n-        return(-1);\n-        break;\n-    default:\n-        \/*\n-        * Fallback to call xmlXPathCompOpEval().\n-        *\/\n-        xmlXPathCompOpEval(ctxt, op);\n-        if (ctxt->error != XPATH_EXPRESSION_OK)\n-        return(-1);\n+            resObj = valuePop(ctxt);\n+            if (resObj == NULL)\n+                return(-1);\n+            break;\n+        default:\n+            \/*\n+            * Fallback to call xmlXPathCompOpEval().\n+            *\/\n+            xmlXPathCompOpEval(ctxt, op);\n+            if (ctxt->error != XPATH_EXPRESSION_OK)\n+                return(-1);\n@@ -13601,4 +13603,4 @@\n-        resObj = valuePop(ctxt);\n-        if (resObj == NULL)\n-        return(-1);\n-        break;\n+            resObj = valuePop(ctxt);\n+            if (resObj == NULL)\n+                return(-1);\n+            break;\n@@ -13608,1 +13610,1 @@\n-    int res;\n+        int res;\n@@ -13610,17 +13612,17 @@\n-    if (resObj->type == XPATH_BOOLEAN) {\n-        res = resObj->boolval;\n-    } else if (isPredicate) {\n-        \/*\n-        * For predicates a result of type \"number\" is handled\n-        * differently:\n-        * SPEC XPath 1.0:\n-        * \"If the result is a number, the result will be converted\n-        *  to true if the number is equal to the context position\n-        *  and will be converted to false otherwise;\"\n-        *\/\n-        res = xmlXPathEvaluatePredicateResult(ctxt, resObj);\n-    } else {\n-        res = xmlXPathCastToBoolean(resObj);\n-    }\n-    xmlXPathReleaseObject(ctxt->context, resObj);\n-    return(res);\n+        if (resObj->type == XPATH_BOOLEAN) {\n+            res = resObj->boolval;\n+        } else if (isPredicate) {\n+            \/*\n+            * For predicates a result of type \"number\" is handled\n+            * differently:\n+            * SPEC XPath 1.0:\n+            * \"If the result is a number, the result will be converted\n+            *  to true if the number is equal to the context position\n+            *  and will be converted to false otherwise;\"\n+            *\/\n+            res = xmlXPathEvaluatePredicateResult(ctxt, resObj);\n+        } else {\n+            res = xmlXPathCastToBoolean(resObj);\n+        }\n+        xmlXPathReleaseObject(ctxt->context, resObj);\n+        return(res);\n@@ -13641,1 +13643,1 @@\n-              xmlXPathObjectPtr *resultSeq, int toBool)\n+                      xmlXPathObjectPtr *resultSeq, int toBool)\n@@ -13670,5 +13672,5 @@\n-    if (resultSeq == NULL)\n-        return(-1);\n-    *resultSeq = xmlXPathCacheNewNodeSet(ctxt, NULL);\n-    if (*resultSeq == NULL)\n-        return(-1);\n+        if (resultSeq == NULL)\n+            return(-1);\n+        *resultSeq = xmlXPathCacheNewNodeSet(ctxt, NULL);\n+        if (*resultSeq == NULL)\n+            return(-1);\n@@ -13681,4 +13683,4 @@\n-    if (from_root) {\n-        \/* Select \"\/\" *\/\n-        if (toBool)\n-        return(1);\n+        if (from_root) {\n+            \/* Select \"\/\" *\/\n+            if (toBool)\n+                return(1);\n@@ -13686,6 +13688,6 @@\n-        xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval,\n-                             (xmlNodePtr) ctxt->doc);\n-    } else {\n-        \/* Select \"self::node()\" *\/\n-        if (toBool)\n-        return(1);\n+            xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval,\n+                                     (xmlNodePtr) ctxt->doc);\n+        } else {\n+            \/* Select \"self::node()\" *\/\n+            if (toBool)\n+                return(1);\n@@ -13693,2 +13695,2 @@\n-        xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval, ctxt->node);\n-    }\n+            xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval, ctxt->node);\n+        }\n@@ -13697,1 +13699,1 @@\n-    return(0);\n+        return(0);\n@@ -13711,2 +13713,2 @@\n-            cur = ctxt->node;\n-        break;\n+                cur = ctxt->node;\n+                break;\n@@ -13729,3 +13731,3 @@\n-        break;\n-    }\n-    limit = cur;\n+                break;\n+        }\n+        limit = cur;\n@@ -13739,4 +13741,4 @@\n-    \/*\n-    * QUESTION TODO: Is this an error?\n-    *\/\n-    return(0);\n+        \/*\n+        * QUESTION TODO: Is this an error?\n+        *\/\n+        return(0);\n@@ -13748,5 +13750,5 @@\n-    ret = xmlStreamPush(patstream, NULL, NULL);\n-    if (ret < 0) {\n-    } else if (ret == 1) {\n-        if (toBool)\n-        goto return_1;\n+        ret = xmlStreamPush(patstream, NULL, NULL);\n+        if (ret < 0) {\n+        } else if (ret == 1) {\n+            if (toBool)\n+                goto return_1;\n@@ -13754,2 +13756,2 @@\n-        xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval, cur);\n-    }\n+            xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval, cur);\n+        }\n@@ -13773,13 +13775,13 @@\n-    switch (cur->type) {\n-        case XML_ELEMENT_NODE:\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        case XML_COMMENT_NODE:\n-        case XML_PI_NODE:\n-        if (cur->type == XML_ELEMENT_NODE) {\n-            ret = xmlStreamPush(patstream, cur->name,\n-                (cur->ns ? cur->ns->href : NULL));\n-        } else if (eval_all_nodes)\n-            ret = xmlStreamPushNode(patstream, NULL, NULL, cur->type);\n-        else\n-            break;\n+        switch (cur->type) {\n+            case XML_ELEMENT_NODE:\n+            case XML_TEXT_NODE:\n+            case XML_CDATA_SECTION_NODE:\n+            case XML_COMMENT_NODE:\n+            case XML_PI_NODE:\n+                if (cur->type == XML_ELEMENT_NODE) {\n+                    ret = xmlStreamPush(patstream, cur->name,\n+                                (cur->ns ? cur->ns->href : NULL));\n+                } else if (eval_all_nodes)\n+                    ret = xmlStreamPushNode(patstream, NULL, NULL, cur->type);\n+                else\n+                    break;\n@@ -13787,9 +13789,38 @@\n-        if (ret < 0) {\n-            \/* NOP. *\/\n-        } else if (ret == 1) {\n-            if (toBool)\n-            goto return_1;\n-            if (xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval, cur)\n-                < 0) {\n-            ctxt->lastError.domain = XML_FROM_XPATH;\n-            ctxt->lastError.code = XML_ERR_NO_MEMORY;\n+                if (ret < 0) {\n+                    \/* NOP. *\/\n+                } else if (ret == 1) {\n+                    if (toBool)\n+                        goto return_1;\n+                    if (xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval, cur)\n+                        < 0) {\n+                        ctxt->lastError.domain = XML_FROM_XPATH;\n+                        ctxt->lastError.code = XML_ERR_NO_MEMORY;\n+                    }\n+                }\n+                if ((cur->children == NULL) || (depth >= max_depth)) {\n+                    ret = xmlStreamPop(patstream);\n+                    while (cur->next != NULL) {\n+                        cur = cur->next;\n+                        if ((cur->type != XML_ENTITY_DECL) &&\n+                            (cur->type != XML_DTD_NODE))\n+                            goto next_node;\n+                    }\n+                }\n+            default:\n+                break;\n+        }\n+\n+scan_children:\n+        if (cur->type == XML_NAMESPACE_DECL) break;\n+        if ((cur->children != NULL) && (depth < max_depth)) {\n+            \/*\n+             * Do not descend on entities declarations\n+             *\/\n+            if (cur->children->type != XML_ENTITY_DECL) {\n+                cur = cur->children;\n+                depth++;\n+                \/*\n+                 * Skip DTDs\n+                 *\/\n+                if (cur->type != XML_DTD_NODE)\n+                    continue;\n@@ -13798,3 +13829,5 @@\n-        if ((cur->children == NULL) || (depth >= max_depth)) {\n-            ret = xmlStreamPop(patstream);\n-            while (cur->next != NULL) {\n+\n+        if (cur == limit)\n+            break;\n+\n+        while (cur->next != NULL) {\n@@ -13805,20 +13838,0 @@\n-            }\n-        }\n-        default:\n-        break;\n-    }\n-\n-scan_children:\n-    if (cur->type == XML_NAMESPACE_DECL) break;\n-    if ((cur->children != NULL) && (depth < max_depth)) {\n-        \/*\n-         * Do not descend on entities declarations\n-         *\/\n-        if (cur->children->type != XML_ENTITY_DECL) {\n-        cur = cur->children;\n-        depth++;\n-        \/*\n-         * Skip DTDs\n-         *\/\n-        if (cur->type != XML_DTD_NODE)\n-            continue;\n@@ -13826,11 +13839,0 @@\n-    }\n-\n-    if (cur == limit)\n-        break;\n-\n-    while (cur->next != NULL) {\n-        cur = cur->next;\n-        if ((cur->type != XML_ENTITY_DECL) &&\n-        (cur->type != XML_DTD_NODE))\n-        goto next_node;\n-    }\n@@ -13838,4 +13840,4 @@\n-    do {\n-        cur = cur->parent;\n-        depth--;\n-        if ((cur == NULL) || (cur == limit) ||\n+        do {\n+            cur = cur->parent;\n+            depth--;\n+            if ((cur == NULL) || (cur == limit) ||\n@@ -13843,16 +13845,16 @@\n-            goto done;\n-        if (cur->type == XML_ELEMENT_NODE) {\n-        ret = xmlStreamPop(patstream);\n-        } else if ((eval_all_nodes) &&\n-        ((cur->type == XML_TEXT_NODE) ||\n-         (cur->type == XML_CDATA_SECTION_NODE) ||\n-         (cur->type == XML_COMMENT_NODE) ||\n-         (cur->type == XML_PI_NODE)))\n-        {\n-        ret = xmlStreamPop(patstream);\n-        }\n-        if (cur->next != NULL) {\n-        cur = cur->next;\n-        break;\n-        }\n-    } while (cur != NULL);\n+                goto done;\n+            if (cur->type == XML_ELEMENT_NODE) {\n+                ret = xmlStreamPop(patstream);\n+            } else if ((eval_all_nodes) &&\n+                ((cur->type == XML_TEXT_NODE) ||\n+                 (cur->type == XML_CDATA_SECTION_NODE) ||\n+                 (cur->type == XML_COMMENT_NODE) ||\n+                 (cur->type == XML_PI_NODE)))\n+            {\n+                ret = xmlStreamPop(patstream);\n+            }\n+            if (cur->next != NULL) {\n+                cur = cur->next;\n+                break;\n+            }\n+        } while (cur != NULL);\n@@ -13870,1 +13872,1 @@\n-    xmlFreeStreamCtxt(patstream);\n+        xmlFreeStreamCtxt(patstream);\n@@ -13875,1 +13877,1 @@\n-    xmlFreeStreamCtxt(patstream);\n+        xmlFreeStreamCtxt(patstream);\n@@ -13893,1 +13895,1 @@\n-    return(-1);\n+        return(-1);\n@@ -13898,10 +13900,10 @@\n-    \/* Allocate the value stack *\/\n-    ctxt->valueTab = (xmlXPathObjectPtr *)\n-             xmlMalloc(10 * sizeof(xmlXPathObjectPtr));\n-    if (ctxt->valueTab == NULL) {\n-        xmlXPathPErrMemory(ctxt, \"creating evaluation context\\n\");\n-        xmlFree(ctxt);\n-    }\n-    ctxt->valueNr = 0;\n-    ctxt->valueMax = 10;\n-    ctxt->value = NULL;\n+        \/* Allocate the value stack *\/\n+        ctxt->valueTab = (xmlXPathObjectPtr *)\n+                         xmlMalloc(10 * sizeof(xmlXPathObjectPtr));\n+        if (ctxt->valueTab == NULL) {\n+            xmlXPathPErrMemory(ctxt, \"creating evaluation context\\n\");\n+            xmlFree(ctxt);\n+        }\n+        ctxt->valueNr = 0;\n+        ctxt->valueMax = 10;\n+        ctxt->value = NULL;\n@@ -13912,1 +13914,1 @@\n-    int res;\n+        int res;\n@@ -13914,10 +13916,10 @@\n-    if (toBool) {\n-        \/*\n-        * Evaluation to boolean result.\n-        *\/\n-        res = xmlXPathRunStreamEval(ctxt->context,\n-        ctxt->comp->stream, NULL, 1);\n-        if (res != -1)\n-        return(res);\n-    } else {\n-        xmlXPathObjectPtr resObj = NULL;\n+        if (toBool) {\n+            \/*\n+            * Evaluation to boolean result.\n+            *\/\n+            res = xmlXPathRunStreamEval(ctxt->context,\n+                ctxt->comp->stream, NULL, 1);\n+            if (res != -1)\n+                return(res);\n+        } else {\n+            xmlXPathObjectPtr resObj = NULL;\n@@ -13925,5 +13927,5 @@\n-        \/*\n-        * Evaluation to a sequence.\n-        *\/\n-        res = xmlXPathRunStreamEval(ctxt->context,\n-        ctxt->comp->stream, &resObj, 0);\n+            \/*\n+            * Evaluation to a sequence.\n+            *\/\n+            res = xmlXPathRunStreamEval(ctxt->context,\n+                ctxt->comp->stream, &resObj, 0);\n@@ -13931,3 +13933,6 @@\n-        if ((res != -1) && (resObj != NULL)) {\n-        valuePush(ctxt, resObj);\n-        return(0);\n+            if ((res != -1) && (resObj != NULL)) {\n+                valuePush(ctxt, resObj);\n+                return(0);\n+            }\n+            if (resObj != NULL)\n+                xmlXPathReleaseObject(ctxt->context, resObj);\n@@ -13935,7 +13940,4 @@\n-        if (resObj != NULL)\n-        xmlXPathReleaseObject(ctxt->context, resObj);\n-    }\n-    \/*\n-    * QUESTION TODO: This falls back to normal XPath evaluation\n-    * if res == -1. Is this intended?\n-    *\/\n+        \/*\n+        * QUESTION TODO: This falls back to normal XPath evaluation\n+        * if res == -1. Is this intended?\n+        *\/\n@@ -13946,3 +13948,3 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"xmlXPathRunEval: last is less than zero\\n\");\n-    return(-1);\n+        xmlGenericError(xmlGenericErrorContext,\n+            \"xmlXPathRunEval: last is less than zero\\n\");\n+        return(-1);\n@@ -13951,2 +13953,2 @@\n-    return(xmlXPathCompOpEvalToBoolean(ctxt,\n-        &comp->steps[comp->last], 0));\n+        return(xmlXPathCompOpEvalToBoolean(ctxt,\n+            &comp->steps[comp->last], 0));\n@@ -13954,1 +13956,1 @@\n-    xmlXPathCompOpEval(ctxt, &comp->steps[comp->last]);\n+        xmlXPathCompOpEval(ctxt, &comp->steps[comp->last]);\n@@ -13960,3 +13962,3 @@\n- *                                  *\n- *          Public interfaces               *\n- *                                  *\n+ *                                                                      *\n+ *                      Public interfaces                               *\n+ *                                                                      *\n@@ -13986,1 +13988,1 @@\n-        return(res->boolval);\n+            return(res->boolval);\n@@ -13988,1 +13990,1 @@\n-        return(res->floatval == ctxt->proximityPosition);\n+            return(res->floatval == ctxt->proximityPosition);\n@@ -13991,3 +13993,3 @@\n-        if (res->nodesetval == NULL)\n-        return(0);\n-        return(res->nodesetval->nodeNr != 0);\n+            if (res->nodesetval == NULL)\n+                return(0);\n+            return(res->nodesetval->nodeNr != 0);\n@@ -13995,2 +13997,2 @@\n-        return((res->stringval != NULL) &&\n-               (xmlStrlen(res->stringval) != 0));\n+            return((res->stringval != NULL) &&\n+                   (xmlStrlen(res->stringval) != 0));\n@@ -13998,1 +14000,1 @@\n-        STRANGE\n+            STRANGE\n@@ -14025,1 +14027,1 @@\n-        return(res->boolval);\n+            return(res->boolval);\n@@ -14028,2 +14030,2 @@\n-        return((res->floatval == ctxt->context->proximityPosition) &&\n-               (!xmlXPathIsNaN(res->floatval))); \/* MSC pbm Mark Vakoc !*\/\n+            return((res->floatval == ctxt->context->proximityPosition) &&\n+                   (!xmlXPathIsNaN(res->floatval))); \/* MSC pbm Mark Vakoc !*\/\n@@ -14031,1 +14033,1 @@\n-        return(res->floatval == ctxt->context->proximityPosition);\n+            return(res->floatval == ctxt->context->proximityPosition);\n@@ -14035,3 +14037,3 @@\n-        if (res->nodesetval == NULL)\n-        return(0);\n-        return(res->nodesetval->nodeNr != 0);\n+            if (res->nodesetval == NULL)\n+                return(0);\n+            return(res->nodesetval->nodeNr != 0);\n@@ -14039,1 +14041,1 @@\n-        return((res->stringval != NULL) && (res->stringval[0] != 0));\n+            return((res->stringval != NULL) && (res->stringval[0] != 0));\n@@ -14041,6 +14043,6 @@\n-    case XPATH_LOCATIONSET:{\n-        xmlLocationSetPtr ptr = res->user;\n-        if (ptr == NULL)\n-            return(0);\n-        return (ptr->locNr != 0);\n-        }\n+        case XPATH_LOCATIONSET:{\n+            xmlLocationSetPtr ptr = res->user;\n+            if (ptr == NULL)\n+                return(0);\n+            return (ptr->locNr != 0);\n+            }\n@@ -14049,1 +14051,1 @@\n-        STRANGE\n+            STRANGE\n@@ -14079,15 +14081,1 @@\n-    const xmlChar *tmp;\n-\n-    \/*\n-     * We don't try to handle expressions using the verbose axis\n-     * specifiers (\"::\"), just the simplified form at this point.\n-     * Additionally, if there is no list of namespaces available and\n-     *  there's a \":\" in the expression, indicating a prefixed QName,\n-     *  then we won't try to compile either. xmlPatterncompile() needs\n-     *  to have a list of namespaces at compilation time in order to\n-     *  compile prefixed name tests.\n-     *\/\n-    tmp = xmlStrchr(str, ':');\n-    if ((tmp != NULL) &&\n-        ((ctxt == NULL) || (ctxt->nsNr == 0) || (tmp[1] == ':')))\n-        return(NULL);\n+        const xmlChar *tmp;\n@@ -14095,6 +14083,12 @@\n-    if (ctxt != NULL) {\n-        dict = ctxt->dict;\n-        if (ctxt->nsNr > 0) {\n-        namespaces = xmlMalloc(2 * (ctxt->nsNr + 1) * sizeof(xmlChar*));\n-        if (namespaces == NULL) {\n-            xmlXPathErrMemory(ctxt, \"allocating namespaces array\\n\");\n+        \/*\n+         * We don't try to handle expressions using the verbose axis\n+         * specifiers (\"::\"), just the simplified form at this point.\n+         * Additionally, if there is no list of namespaces available and\n+         *  there's a \":\" in the expression, indicating a prefixed QName,\n+         *  then we won't try to compile either. xmlPatterncompile() needs\n+         *  to have a list of namespaces at compilation time in order to\n+         *  compile prefixed name tests.\n+         *\/\n+        tmp = xmlStrchr(str, ':');\n+        if ((tmp != NULL) &&\n+            ((ctxt == NULL) || (ctxt->nsNr == 0) || (tmp[1] == ':')))\n@@ -14102,0 +14096,17 @@\n+\n+        if (ctxt != NULL) {\n+            dict = ctxt->dict;\n+            if (ctxt->nsNr > 0) {\n+                namespaces = xmlMalloc(2 * (ctxt->nsNr + 1) * sizeof(xmlChar*));\n+                if (namespaces == NULL) {\n+                    xmlXPathErrMemory(ctxt, \"allocating namespaces array\\n\");\n+                    return(NULL);\n+                }\n+                for (i = 0, j = 0; (j < ctxt->nsNr); j++) {\n+                    ns = ctxt->namespaces[j];\n+                    namespaces[i++] = ns->href;\n+                    namespaces[i++] = ns->prefix;\n+                }\n+                namespaces[i++] = NULL;\n+                namespaces[i] = NULL;\n+            }\n@@ -14103,9 +14114,0 @@\n-        for (i = 0, j = 0; (j < ctxt->nsNr); j++) {\n-            ns = ctxt->namespaces[j];\n-            namespaces[i++] = ns->href;\n-            namespaces[i++] = ns->prefix;\n-        }\n-        namespaces[i++] = NULL;\n-        namespaces[i] = NULL;\n-        }\n-    }\n@@ -14113,9 +14115,3 @@\n-    stream = xmlPatterncompile(str, dict, XML_PATTERN_XPATH, namespaces);\n-    if (namespaces != NULL) {\n-        xmlFree((xmlChar **)namespaces);\n-    }\n-    if ((stream != NULL) && (xmlPatternStreamable(stream) == 1)) {\n-        comp = xmlXPathNewCompExpr();\n-        if (comp == NULL) {\n-        xmlXPathErrMemory(ctxt, \"allocating streamable expression\\n\");\n-        return(NULL);\n+        stream = xmlPatterncompile(str, dict, XML_PATTERN_XPATH, namespaces);\n+        if (namespaces != NULL) {\n+            xmlFree((xmlChar **)namespaces);\n@@ -14123,7 +14119,13 @@\n-        comp->stream = stream;\n-        comp->dict = dict;\n-        if (comp->dict)\n-        xmlDictReference(comp->dict);\n-        return(comp);\n-    }\n-    xmlFreePattern(stream);\n+        if ((stream != NULL) && (xmlPatternStreamable(stream) == 1)) {\n+            comp = xmlXPathNewCompExpr();\n+            if (comp == NULL) {\n+                xmlXPathErrMemory(ctxt, \"allocating streamable expression\\n\");\n+                return(NULL);\n+            }\n+            comp->stream = stream;\n+            comp->dict = dict;\n+            if (comp->dict)\n+                xmlDictReference(comp->dict);\n+            return(comp);\n+        }\n+        xmlFreePattern(stream);\n@@ -14189,1 +14191,1 @@\n-    }\n+        }\n@@ -14206,1 +14208,1 @@\n-    xmlXPathOptimizeExpression(pctxt, &comp->steps[op->ch2]);\n+        xmlXPathOptimizeExpression(pctxt, &comp->steps[op->ch2]);\n@@ -14248,8 +14250,8 @@\n-    \/*\n-     * aleksey: in some cases this line prints *second* error message\n-     * (see bug #78858) and probably this should be fixed.\n-     * However, we are not sure that all error messages are printed\n-     * out in other places. It's not critical so we leave it as-is for now\n-     *\/\n-    xmlXPatherror(pctxt, __FILE__, __LINE__, XPATH_EXPR_ERROR);\n-    comp = NULL;\n+        \/*\n+         * aleksey: in some cases this line prints *second* error message\n+         * (see bug #78858) and probably this should be fixed.\n+         * However, we are not sure that all error messages are printed\n+         * out in other places. It's not critical so we leave it as-is for now\n+         *\/\n+        xmlXPatherror(pctxt, __FILE__, __LINE__, XPATH_EXPR_ERROR);\n+        comp = NULL;\n@@ -14257,2 +14259,2 @@\n-    comp = pctxt->comp;\n-    if ((comp->nbStep > 1) && (comp->last >= 0)) {\n+        comp = pctxt->comp;\n+        if ((comp->nbStep > 1) && (comp->last >= 0)) {\n@@ -14261,3 +14263,3 @@\n-        xmlXPathOptimizeExpression(pctxt, &comp->steps[comp->last]);\n-    }\n-    pctxt->comp = NULL;\n+            xmlXPathOptimizeExpression(pctxt, &comp->steps[comp->last]);\n+        }\n+        pctxt->comp = NULL;\n@@ -14268,1 +14270,1 @@\n-    comp->expr = xmlStrdup(str);\n+        comp->expr = xmlStrdup(str);\n@@ -14270,2 +14272,2 @@\n-    comp->string = xmlStrdup(str);\n-    comp->nb = 0;\n+        comp->string = xmlStrdup(str);\n+        comp->nb = 0;\n@@ -14306,3 +14308,3 @@\n-                 xmlXPathContextPtr ctxt,\n-                 xmlXPathObjectPtr *resObjPtr,\n-                 int toBool)\n+                             xmlXPathContextPtr ctxt,\n+                             xmlXPathObjectPtr *resObjPtr,\n+                             int toBool)\n@@ -14320,1 +14322,1 @@\n-    return(-1);\n+        return(-1);\n@@ -14326,1 +14328,1 @@\n-    xmlXPathDisableOptimizer = 1;\n+        xmlXPathDisableOptimizer = 1;\n@@ -14332,2 +14334,2 @@\n-    fprintf(stderr, \"100 x %s\\n\", comp->string);\n-    comp->nb = 0;\n+        fprintf(stderr, \"100 x %s\\n\", comp->string);\n+        comp->nb = 0;\n@@ -14400,1 +14402,1 @@\n-                  xmlXPathContextPtr ctxt)\n+                              xmlXPathContextPtr ctxt)\n@@ -14424,1 +14426,1 @@\n-        xmlXPathFreeCompExpr(ctxt->comp);\n+            xmlXPathFreeCompExpr(ctxt->comp);\n@@ -14431,1 +14433,1 @@\n-    xmlXPathCompileExpr(ctxt, 1);\n+        xmlXPathCompileExpr(ctxt, 1);\n@@ -14438,1 +14440,1 @@\n-    if ((ctxt->comp->nbStep > 1) && (ctxt->comp->last >= 0)) {\n+        if ((ctxt->comp->nbStep > 1) && (ctxt->comp->last >= 0)) {\n@@ -14441,2 +14443,2 @@\n-        xmlXPathOptimizeExpression(ctxt,\n-        &ctxt->comp->steps[ctxt->comp->last]);\n+            xmlXPathOptimizeExpression(ctxt,\n+                &ctxt->comp->steps[ctxt->comp->last]);\n@@ -14474,1 +14476,1 @@\n-    res = NULL;\n+        res = NULL;\n@@ -14476,1 +14478,1 @@\n-    res = valuePop(ctxt);\n+        res = valuePop(ctxt);\n@@ -14508,1 +14510,1 @@\n-    return(0);\n+        return(0);\n@@ -14550,3 +14552,3 @@\n- *                                  *\n- *  Extra functions not pertaining to the XPath spec        *\n- *                                  *\n+ *                                                                      *\n+ *      Extra functions not pertaining to the XPath spec                *\n+ *                                                                      *\n@@ -14623,31 +14625,32 @@\n-    for (cptr = str->stringval; *cptr; cptr++) {\n-        if ((*cptr >= 'A' && *cptr <= 'Z') ||\n-        (*cptr >= 'a' && *cptr <= 'z') ||\n-        (*cptr >= '0' && *cptr <= '9') ||\n-        *cptr == '-' || *cptr == '_' || *cptr == '.' ||\n-        *cptr == '!' || *cptr == '~' || *cptr == '*' ||\n-        *cptr == '\\''|| *cptr == '(' || *cptr == ')' ||\n-        (*cptr == '%' &&\n-         ((cptr[1] >= 'A' && cptr[1] <= 'F') ||\n-          (cptr[1] >= 'a' && cptr[1] <= 'f') ||\n-          (cptr[1] >= '0' && cptr[1] <= '9')) &&\n-         ((cptr[2] >= 'A' && cptr[2] <= 'F') ||\n-          (cptr[2] >= 'a' && cptr[2] <= 'f') ||\n-          (cptr[2] >= '0' && cptr[2] <= '9'))) ||\n-        (!escape_reserved &&\n-         (*cptr == ';' || *cptr == '\/' || *cptr == '?' ||\n-          *cptr == ':' || *cptr == '@' || *cptr == '&' ||\n-          *cptr == '=' || *cptr == '+' || *cptr == '$' ||\n-          *cptr == ','))) {\n-        xmlBufAdd(target, cptr, 1);\n-        } else {\n-        if ((*cptr >> 4) < 10)\n-            escape[1] = '0' + (*cptr >> 4);\n-        else\n-            escape[1] = 'A' - 10 + (*cptr >> 4);\n-        if ((*cptr & 0xF) < 10)\n-            escape[2] = '0' + (*cptr & 0xF);\n-        else\n-            escape[2] = 'A' - 10 + (*cptr & 0xF);\n-\n-        xmlBufAdd(target, &escape[0], 3);\n+        for (cptr = str->stringval; *cptr; cptr++) {\n+            if ((*cptr >= 'A' && *cptr <= 'Z') ||\n+                (*cptr >= 'a' && *cptr <= 'z') ||\n+                (*cptr >= '0' && *cptr <= '9') ||\n+                *cptr == '-' || *cptr == '_' || *cptr == '.' ||\n+                *cptr == '!' || *cptr == '~' || *cptr == '*' ||\n+                *cptr == '\\''|| *cptr == '(' || *cptr == ')' ||\n+                (*cptr == '%' &&\n+                 ((cptr[1] >= 'A' && cptr[1] <= 'F') ||\n+                  (cptr[1] >= 'a' && cptr[1] <= 'f') ||\n+                  (cptr[1] >= '0' && cptr[1] <= '9')) &&\n+                 ((cptr[2] >= 'A' && cptr[2] <= 'F') ||\n+                  (cptr[2] >= 'a' && cptr[2] <= 'f') ||\n+                  (cptr[2] >= '0' && cptr[2] <= '9'))) ||\n+                (!escape_reserved &&\n+                 (*cptr == ';' || *cptr == '\/' || *cptr == '?' ||\n+                  *cptr == ':' || *cptr == '@' || *cptr == '&' ||\n+                  *cptr == '=' || *cptr == '+' || *cptr == '$' ||\n+                  *cptr == ','))) {\n+                xmlBufAdd(target, cptr, 1);\n+            } else {\n+                if ((*cptr >> 4) < 10)\n+                    escape[1] = '0' + (*cptr >> 4);\n+                else\n+                    escape[1] = 'A' - 10 + (*cptr >> 4);\n+                if ((*cptr & 0xF) < 10)\n+                    escape[2] = '0' + (*cptr & 0xF);\n+                else\n+                    escape[2] = 'A' - 10 + (*cptr & 0xF);\n+\n+                xmlBufAdd(target, &escape[0], 3);\n+            }\n@@ -14656,1 +14659,0 @@\n-    }\n@@ -14658,1 +14660,1 @@\n-    xmlBufContent(target)));\n+        xmlBufContent(target)));\n@@ -14728,1 +14730,1 @@\n-     (const xmlChar *)\"http:\/\/www.w3.org\/2002\/08\/xquery-functions\",\n+         (const xmlChar *)\"http:\/\/www.w3.org\/2002\/08\/xquery-functions\",\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xpath.c","additions":4689,"deletions":4687,"binary":false,"changes":9376,"status":"modified"},{"patch":"@@ -8,1 +8,2 @@\n-#define HAVE_STDINT_H\n+#define SEND_ARG2_CAST\n+#define GETHOSTBYNAME_ARG_CAST\n@@ -93,1 +94,1 @@\n-#if _MSC_VER < 1900 \/\/ Cannot define this in VS 2015 and above!\n+#if _MSC_VER < 1900\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/win32\/config.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#define LIBXML_DOTTED_VERSION \"2.9.12\"\n+#define LIBXML_DOTTED_VERSION \"2.9.13\"\n@@ -39,1 +39,1 @@\n-#define LIBXML_VERSION 20912\n+#define LIBXML_VERSION 20913\n@@ -46,1 +46,1 @@\n-#define LIBXML_VERSION_STRING \"20912\"\n+#define LIBXML_VERSION_STRING \"20913\"\n@@ -51,1 +51,1 @@\n- * extra version information, used to show a CVS compilation\n+ * extra version information, used to show a git commit description\n@@ -61,1 +61,1 @@\n-#define LIBXML_TEST_VERSION xmlCheckVersion(20912);\n+#define LIBXML_TEST_VERSION xmlCheckVersion(20913);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/win32\/include\/libxml\/xmlversion.h","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}