{"files":[{"patch":"@@ -293,2 +293,2 @@\n-        int index = t.getTablePosition().getRow();\n-        List<S> list = t.getTableView().getItems();\n+        int index = t.getTablePosition() != null ? t.getTablePosition().getRow() : -1;\n+        List<S> list = t.getTableView() != null ? t.getTableView().getItems() : null;\n@@ -798,1 +798,1 @@\n-            return pos.getTableView();\n+            return pos != null ? pos.getTableView() : null;\n@@ -807,1 +807,1 @@\n-            return pos.getTableColumn();\n+            return pos != null ? pos.getTableColumn() : null;\n@@ -856,1 +856,1 @@\n-            List<S> items = getTableView().getItems();\n+            List<S> items = getTableView() != null ? getTableView().getItems() : null;\n@@ -859,1 +859,1 @@\n-            int row = pos.getRow();\n+            int row = pos != null ? pos.getRow() : -1;\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TableColumn.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -288,1 +288,3 @@\n-                ObservableValue<T> ov = getCellObservableValue(t.getRowValue());\n+                TreeItem<S> rowValue = t.getRowValue();\n+                if (rowValue == null) return;\n+                ObservableValue<T> ov = getCellObservableValue(rowValue);\n@@ -775,1 +777,1 @@\n-            return pos.getTreeTableView();\n+            return pos != null ? pos.getTreeTableView() : null;\n@@ -784,1 +786,1 @@\n-            return pos.getTableColumn();\n+            return pos != null ? pos.getTableColumn() : null;\n@@ -833,3 +835,0 @@\n-\/\/            List<S> items = getTreeTableView().getItems();\n-\/\/            if (items == null) return null;\n-\n@@ -837,2 +836,3 @@\n-            int row = pos.getRow();\n-            if (row < 0 || row >= treeTable.getExpandedItemCount()) return null;\n+            int row = pos != null ? pos.getRow() : -1;\n+            int expandedItemCount = treeTable != null ? treeTable.getExpandedItemCount() : 0;\n+            if (row < 0 || row >= expandedItemCount) return null;\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeTableColumn.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.control;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import static javafx.scene.control.TableColumn.*;\n+import static org.junit.Assert.*;\n+\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n+import javafx.event.Event;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TableColumn.CellEditEvent;\n+import javafx.scene.control.TablePosition;\n+import javafx.scene.control.TableView;\n+\n+\/**\n+ * Test cell edit event for TableColumn: must not throw NPE in accessors (JDK-8269871).\n+ *\/\n+public class CellEditEventOfTableColumnTest {\n+\n+    private TableView<String> table;\n+    private TableColumn<String, String> editingColumn;\n+\n+\/\/---------------- default commit handler\n+\n+    @Test\n+    public void testDefaultOnCommitHandlerTablePositionWithNullTable() {\n+        String edited = \"edited\";\n+        TablePosition<String, String> pos = new TablePosition<>(null, 1, editingColumn);\n+        CellEditEvent<String, String> event = new CellEditEvent<>(table, pos, editCommitEvent(), edited);\n+        Event.fireEvent(editingColumn, event);\n+    }\n+\n+    @Test\n+    public void testDefaultOnCommitHandlerNullTablePosition() {\n+        String edited = \"edited\";\n+        CellEditEvent<String, String> event = new CellEditEvent<>(table, null, editCommitEvent(), edited);\n+        Event.fireEvent(editingColumn, event);\n+    }\n+\n+\/\/---------------- accessors in CellEditEvent\n+\n+    @Test\n+    public void testNullTablePositionGetTableView() {\n+        CellEditEvent<String, String> ev = new CellEditEvent<>(table, null, editAnyEvent(), null);\n+        assertNull(\"table must be null for null pos\", ev.getTableView());\n+    }\n+\n+    @Test\n+    public void testNullTablePositionGetTableColumn() {\n+        CellEditEvent<String, String> ev = new CellEditEvent<>(table, null, editAnyEvent(), null);\n+        assertNull(\"column must be null for null pos\", ev.getTableColumn());\n+    }\n+\n+    @Test\n+    public void testNullTablePositionGetOldValue() {\n+        CellEditEvent<String, String> ev = new CellEditEvent<>(table, null, editAnyEvent(), null);\n+        assertNull(\"oldValue must be null for null pos\", ev.getOldValue());\n+    }\n+\n+    @Test\n+    public void testNullTablePositionGetRowValue() {\n+        CellEditEvent<String, String> ev = new CellEditEvent<>(table, null, editAnyEvent(), null);\n+        assertNull(\"rowValue must be null for null pos\", ev.getRowValue());\n+    }\n+\n+    @Test\n+    public void testNullTablePositionGetNewValue() {\n+        String editedValue = \"edited\";\n+        CellEditEvent<String, String> ev = new CellEditEvent<>(table, null, editAnyEvent(), editedValue);\n+        assertEquals(\"editedValue must be available for null pos\", editedValue, ev.getNewValue());\n+    }\n+\n+    @Test\n+    public void testTablePositionWithNullTable() {\n+        String editedValue = \"edited\";\n+        TablePosition<String, String> pos = new TablePosition<>(null, 1, editingColumn);\n+        CellEditEvent<String, String> ev = new CellEditEvent<>(table, pos, editAnyEvent(), editedValue);\n+        assertNull(\"rowValue must be null for null pos\", ev.getRowValue());\n+    }\n+\n+\/\/---------- event source\n+\n+    @Ignore(\"JDK-8271474\")\n+    @Test\n+    public void testNullTable() {\n+        new CellEditEvent<Object, Object>(null, \/\/ null table must not throw NPE\n+                new TablePosition<>(null, -1, null), editAnyEvent(), null);\n+    }\n+\n+    @Test\n+    public void testCellEditEventDifferentSource() {\n+        assertCellEditEvent(new TableView<>());\n+    }\n+\n+    @Test\n+    public void testCellEditEventSameSource() {\n+        assertCellEditEvent(table);\n+    }\n+\n+    @Ignore(\"JDK-8271474\")\n+    @Test\n+    public void testCellEditEventNullSource() {\n+        assertCellEditEvent(null);\n+    }\n+\n+    \/**\n+     * Creates a CellEditEvent with the given source and TablePosition\n+     * having default values and asserts its state.\n+     *\/\n+    private void assertCellEditEvent(TableView<String> source) {\n+        int editingRow = 1;\n+        String editedValue = \"edited\";\n+        String rowValue = table.getItems().get(editingRow);\n+        String oldValue = editingColumn.getCellData(editingRow);\n+        TablePosition<String, String> pos = new TablePosition<>(table, editingRow, editingColumn);\n+        CellEditEvent<String, String> event = new CellEditEvent<>(source, pos, editAnyEvent(), editedValue);\n+        if (source != null) {\n+            assertEquals(source, event.getSource());\n+        }\n+        assertCellEditEventState(event, table, editingColumn, pos, editedValue, oldValue, rowValue);\n+    }\n+\n+    \/**\n+     * Asserts state of the CellEditEvent.\n+     *\/\n+    private <S, T> void assertCellEditEventState(CellEditEvent<S, T> event,\n+            TableView<S> table, TableColumn<S, T> tableColumn, TablePosition<S, T> pos,\n+            T newValue, T oldValue, S rowValue) {\n+        assertEquals(newValue, event.getNewValue());\n+        assertEquals(oldValue, event.getOldValue());\n+        assertEquals(rowValue, event.getRowValue());\n+        assertEquals(tableColumn, event.getTableColumn());\n+        assertEquals(pos, event.getTablePosition());\n+        assertEquals(table, event.getTableView());\n+    }\n+\n+\/\/------------ init\n+\n+    @Before public void setup() {\n+        Thread.currentThread().setUncaughtExceptionHandler((thread, throwable) -> {\n+            if (throwable instanceof RuntimeException) {\n+                throw (RuntimeException)throwable;\n+            } else {\n+                Thread.currentThread().getThreadGroup().uncaughtException(thread, throwable);\n+            }\n+        });\n+\n+        ObservableList<String> model = FXCollections.observableArrayList(\"Four\", \"Five\", \"Fear\");\n+        table = new TableView<String>(model);\n+        editingColumn = new TableColumn<>(\"TEST\");\n+        editingColumn.setCellValueFactory(e -> new SimpleStringProperty(e.getValue()));\n+        table.getColumns().addAll(editingColumn);\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        Thread.currentThread().setUncaughtExceptionHandler(null);\n+    }\n+\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/CellEditEventOfTableColumnTest.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.control;\n+\n+import java.util.stream.Collectors;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import static javafx.scene.control.TreeTableColumn.editCommitEvent;\n+import static javafx.scene.control.TreeTableColumn.*;\n+import static org.junit.Assert.*;\n+\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n+import javafx.event.Event;\n+import javafx.scene.control.TreeItem;\n+import javafx.scene.control.TreeTableColumn;\n+import javafx.scene.control.TreeTableColumn.CellEditEvent;\n+import javafx.scene.control.TreeTablePosition;\n+import javafx.scene.control.TreeTableView;\n+\n+\/**\n+ * Test cell edit event for TableColumn: must not throw NPE in accessors (JDK-8269871).\n+ *\/\n+public class CellEditEventOfTreeTableColumnTest {\n+\n+    private TreeTableView<String> table;\n+    private TreeTableColumn<String, String> editingColumn;\n+\n+\/\/------------ default commit handler\n+\n+    @Test\n+    public void testDefaultOnCommitHandlerTablePositionWithNullTable() {\n+        String edited = \"edited\";\n+        TreeTablePosition<String, String> pos = new TreeTablePosition<>(null, 1, editingColumn);\n+        CellEditEvent<String, String> event = new CellEditEvent<>(table, pos, editCommitEvent(), edited);\n+        Event.fireEvent(editingColumn, event);\n+    }\n+\n+    @Test\n+    public void testDefaultOnCommitHandlerNullTablePosition() {\n+        String edited = \"edited\";\n+        CellEditEvent<String, String> event = new CellEditEvent<>(table, null, editCommitEvent(), edited);\n+        Event.fireEvent(editingColumn, event);\n+    }\n+\n+  \/\/---------------- accessors in CellEditEvent\n+\n+    @Test\n+    public void testNullTablePositionGetTableView() {\n+        CellEditEvent<String, String> ev = new CellEditEvent<>(table, null, editAnyEvent(), null);\n+        assertNull(\"treeTable must be null if pos is null\", ev.getTreeTableView());\n+    }\n+\n+    @Test\n+    public void testNullTablePositionGetTableColumn() {\n+        CellEditEvent<String, String> ev = new CellEditEvent<>(table, null, editAnyEvent(), null);\n+        assertNull(\"column must be null for null pos\", ev.getTableColumn());\n+    }\n+\n+    @Test\n+    public void testNullTablePositionGetOldValue() {\n+        CellEditEvent<String, String> ev = new CellEditEvent<>(table, null, editAnyEvent(), null);\n+        assertNull(\"oldValue must be null for null pos\", ev.getOldValue());\n+    }\n+\n+    @Test\n+    public void testNullTablePositionGetRowValue() {\n+        CellEditEvent<String, String> ev = new CellEditEvent<>(table, null, editAnyEvent(), null);\n+        assertNull(\"rowValue must be null for null pos\", ev.getRowValue());\n+    }\n+\n+    @Test\n+    public void testNullTablePositionGetNewValue() {\n+        String editedValue = \"edited\";\n+        CellEditEvent<String, String> ev = new CellEditEvent<>(table, null, editAnyEvent(), editedValue);\n+        assertEquals(\"editedValue must be available for null pos\", editedValue, ev.getNewValue());\n+    }\n+\n+    @Test\n+    public void testTablePositionWithNullTable() {\n+        String editedValue = \"edited\";\n+        TreeTablePosition<String, String> pos = new TreeTablePosition<>(null, 1, editingColumn);\n+        CellEditEvent<String, String> ev = new CellEditEvent<>(table, pos, editAnyEvent(), editedValue);\n+        assertNull(\"rowValue must be null for null pos\", ev.getRowValue());\n+    }\n+\n+\/\/ ------------- event source\n+\n+    @Ignore(\"JDK-8271474\")\n+    @Test\n+    public void testNullTable() {\n+        new CellEditEvent<Object, Object>(null, \/\/ null table must not throw NPE\n+                new TreeTablePosition<>(null, -1, null), editAnyEvent(), null);\n+    }\n+\n+    @Test\n+    public void testCellEditEventDifferentSource() {\n+        assertCellEditEvent(new TreeTableView<>());\n+    }\n+\n+    @Test\n+    public void testCellEditEventSameSource() {\n+        assertCellEditEvent(table);\n+    }\n+\n+    @Ignore(\"JDK-8271474\")\n+    @Test\n+    public void testCellEditEventNullSource() {\n+        assertCellEditEvent(null);\n+    }\n+\n+    \/**\n+     * Creates a CellEditEvent with the given source, not-null position and asserts\n+     * all properties of the event.\n+     *\n+     * @param source the source of the event\n+     *\/\n+    private void assertCellEditEvent(TreeTableView<String> source) {\n+        int editingRow = 1;\n+        String editedValue = \"edited\";\n+        TreeItem<String> rowValue = table.getTreeItem(editingRow);\n+        String oldValue = rowValue.getValue();\n+        TreeTablePosition<String, String> pos = new TreeTablePosition<>(table, editingRow, editingColumn);\n+        CellEditEvent<String,String> ev = new CellEditEvent<String, String>(source, pos, editAnyEvent(), editedValue);\n+        if (source != null) {\n+            assertEquals(source, ev.getSource());\n+        }\n+        assertCellEditEventState(ev, table, editingColumn, pos, editedValue, oldValue, rowValue);\n+    }\n+\n+    \/**\n+     * Asserts all properties of the event against the given expected values.\n+     *\/\n+    private <S, T> void assertCellEditEventState(CellEditEvent<S, T> event,\n+            TreeTableView<S> table, TreeTableColumn<S, T> tableColumn, TreeTablePosition<S, T> pos,\n+            T newValue, T oldValue, TreeItem<S> rowValue) {\n+        assertEquals(newValue, event.getNewValue());\n+        assertEquals(oldValue, event.getOldValue());\n+        assertEquals(rowValue, event.getRowValue());\n+        assertEquals(tableColumn, event.getTableColumn());\n+        assertEquals(pos, event.getTreeTablePosition());\n+        assertEquals(table, event.getTreeTableView());\n+    }\n+\n+\/\/------------ init\n+\n+    @Before public void setup() {\n+        Thread.currentThread().setUncaughtExceptionHandler((thread, throwable) -> {\n+            if (throwable instanceof RuntimeException) {\n+                throw (RuntimeException)throwable;\n+            } else {\n+                Thread.currentThread().getThreadGroup().uncaughtException(thread, throwable);\n+            }\n+        });\n+\n+        TreeItem<String> root = new TreeItem<>(\"root\");\n+        root.setExpanded(true);\n+        ObservableList<String> model = FXCollections.observableArrayList(\"Four\", \"Five\", \"Fear\");\n+        root.getChildren().addAll(model.stream().map(TreeItem::new).collect(Collectors.toList()));\n+        table = new TreeTableView<String>(root);\n+        editingColumn = new TreeTableColumn<>(\"TEST\");\n+        table.getColumns().addAll(editingColumn);\n+        editingColumn.setCellValueFactory(e -> e.getValue().valueProperty());\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        Thread.currentThread().setUncaughtExceptionHandler(null);\n+    }\n+\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/CellEditEventOfTreeTableColumnTest.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1057,1 +1057,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -1061,1 +1061,0 @@\n-        TablePosition<Person,String> pos = new TablePosition<Person, String>(table, 0, column);\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TableColumnTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1083,1 +1083,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -1087,1 +1087,0 @@\n-        TreeTablePosition<Person,String> pos = new TreeTablePosition<Person, String>(table, 0, column);\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeTableColumnTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}