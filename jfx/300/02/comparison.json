{"files":[{"patch":"@@ -155,1 +155,0 @@\n-    private boolean isSelectingTab;\n@@ -203,2 +202,8 @@\n-        registerChangeListener(control.widthProperty(), e -> clipRect.setWidth(getSkinnable().getWidth()));\n-        registerChangeListener(control.heightProperty(), e -> clipRect.setHeight(getSkinnable().getHeight()));\n+        registerChangeListener(control.widthProperty(), e -> {\n+            tabHeaderArea.invalidateScrollOffset();\n+            clipRect.setWidth(getSkinnable().getWidth());\n+        });\n+        registerChangeListener(control.heightProperty(), e -> {\n+            tabHeaderArea.invalidateScrollOffset();\n+            clipRect.setHeight(getSkinnable().getHeight());\n+        });\n@@ -217,1 +222,0 @@\n-        isSelectingTab = false;\n@@ -435,1 +439,1 @@\n-        isSelectingTab = true;\n+        tabHeaderArea.invalidateScrollOffset();\n@@ -681,1 +685,1 @@\n-        tabHeaderArea.setScrollOffset(0.0F);\n+        tabHeaderArea.invalidateScrollOffset();\n@@ -812,0 +816,1 @@\n+        private boolean scrollOffsetDirty = true;\n@@ -845,1 +850,1 @@\n-                        if (isSelectingTab) {\n+                        if (scrollOffsetDirty) {\n@@ -847,2 +852,1 @@\n-                        } else {\n-                            validateScrollOffset();\n+                            scrollOffsetDirty = false;\n@@ -850,0 +854,2 @@\n+                        \/\/ ensure there's no gap between last visible tab and trailing edge\n+                        validateScrollOffset();\n@@ -851,1 +857,0 @@\n-                    isSelectingTab = false;\n@@ -984,0 +989,1 @@\n+            invalidateScrollOffset();\n@@ -991,0 +997,1 @@\n+            invalidateScrollOffset();\n@@ -998,0 +1005,1 @@\n+            invalidateScrollOffset();\n@@ -1056,0 +1064,4 @@\n+        public void invalidateScrollOffset() {\n+            scrollOffsetDirty = true;\n+        }\n+\n@@ -2244,0 +2256,1 @@\n+        tabHeaderArea.invalidateScrollOffset();\n@@ -2297,0 +2310,12 @@\n+\n+    double test_getHeaderAreaScrollOffset() {\n+        return tabHeaderArea.getScrollOffset();\n+    }\n+\n+    void test_setHeaderAreaScrollOffset(double offset) {\n+        tabHeaderArea.setScrollOffset(offset);\n+    }\n+\n+    boolean test_isTabsFit() {\n+        return tabHeaderArea.tabsFit();\n+    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TabPaneSkin.java","additions":35,"deletions":10,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -49,0 +49,16 @@\n+\n+    public static double getHeaderAreaScrollOffset(TabPane tabPane) {\n+        TabPaneSkin skin = (TabPaneSkin) tabPane.getSkin();\n+        return skin.test_getHeaderAreaScrollOffset();\n+    }\n+\n+    public static void setHeaderAreaScrollOffset(TabPane tabPane, double offset) {\n+        TabPaneSkin skin = (TabPaneSkin) tabPane.getSkin();\n+        skin.test_setHeaderAreaScrollOffset(offset);\n+    }\n+\n+    public static boolean isTabsFit(TabPane tabPane) {\n+        TabPaneSkin skin = (TabPaneSkin) tabPane.getSkin();\n+        return skin.test_isTabsFit();\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/shims\/java\/javafx\/scene\/control\/skin\/TabPaneSkinShim.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,466 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.control.skin;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import com.sun.javafx.scene.control.TabObservableList;\n+import com.sun.javafx.tk.Toolkit;\n+\n+import static javafx.scene.control.skin.TabPaneSkinShim.*;\n+import static org.junit.Assert.*;\n+\n+import javafx.geometry.Side;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.Tab;\n+import javafx.scene.control.TabPane;\n+import javafx.scene.control.skin.TabPaneSkin;\n+import javafx.scene.layout.Pane;\n+import javafx.scene.layout.VBox;\n+import javafx.stage.Stage;\n+\n+\/**\n+ * Tests around keeping the selected tab header in visible range of header area.\n+ *\/\n+public class TabPaneHeaderScrollTest {\n+\n+    \/\/ many tabs, exceeding width\n+    private static final int TAB_COUNT = 30;\n+    \/\/ subset for qualitative scroll asserts\n+    private static final int THIRD_OF = TAB_COUNT \/ 3;\n+    \/\/ tabs to just fit\n+    private static final int FITTING = 7;\n+\n+    private Scene scene;\n+    private Stage stage;\n+    private Pane root;\n+    private TabPane tabPane;\n+\n+\/\/-------- tests around JDK-8252236\n+\n+    @Test\n+    public void testMoveBySetAll() {\n+        showTabPane();\n+        \/\/ select last for max scrolling\n+        int last = tabPane.getTabs().size() - 1;\n+        tabPane.getSelectionModel().select(last);\n+        Tab selectedTab = tabPane.getSelectionModel().getSelectedItem();\n+        Toolkit.getToolkit().firePulse();\n+        \/\/ move selected tab to first\n+        List<Tab> tabs = new ArrayList<>(tabPane.getTabs());\n+        tabs.remove(selectedTab);\n+        tabs.add(0, selectedTab);\n+        tabPane.getTabs().setAll(tabs);\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(\"scrolled to leading edge\", 0, getHeaderAreaScrollOffset(tabPane), 1);\n+    }\n+\n+    \/**\n+     * This test passes without the fix, must pass after as well.\n+     *\/\n+    @Test\n+    public void testMoveByTabObservableList() {\n+        showTabPane();\n+        \/\/ select last for max scrolling\n+        int last = tabPane.getTabs().size() - 1;\n+        tabPane.getSelectionModel().select(last);\n+        Tab selectedTab = tabPane.getSelectionModel().getSelectedItem();\n+        Toolkit.getToolkit().firePulse();\n+        \/\/ move selected tab to first\n+        ((TabObservableList<Tab>) tabPane.getTabs()).reorder(selectedTab, tabPane.getTabs().get(0));\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(\"scrolled to leading edge\", 0, getHeaderAreaScrollOffset(tabPane), 1);\n+    }\n+\n+    \/**\n+     * Scroll to last (by selecting it) -> remove last.\n+     *\n+     * Without fix, fails by not scrolling at all: the gap is increasing every time the\n+     * last selected (after removal that's the previous) is removed.\n+     *\n+     *\/\n+    @Test\n+    public void testRemoveSelectedAsLast() {\n+        showTabPane();\n+        int last = tabPane.getTabs().size() - 1;\n+        Tab secondLastTab = tabPane.getTabs().get(last - 1);\n+        Tab lastTab = tabPane.getTabs().get(last);\n+        \/\/ select for max scroll\n+        tabPane.getSelectionModel().select(last);\n+        Toolkit.getToolkit().firePulse();\n+\n+        \/\/ at this point, the header is scrolled such that the last is at the very right\n+        double scrollOffset = getHeaderAreaScrollOffset(tabPane);\n+        double lastTabOffset = getTabHeaderOffset(tabPane, lastTab);\n+        double secondLastTabOffset = getTabHeaderOffset(tabPane, secondLastTab);\n+        \/\/ expected change in scroll offset\n+        double expectedDelta = lastTabOffset - secondLastTabOffset;\n+\n+        \/\/ remove last (== selected)\n+        tabPane.getTabs().remove(last);\n+        Toolkit.getToolkit().firePulse();\n+\n+        assertEquals(\"scrollOffset adjusted: \", scrollOffset + expectedDelta, getHeaderAreaScrollOffset(tabPane), 1);\n+    }\n+\n+    \/**\n+     * Scroll to last (by selecting it) -> select previous -> remove last.\n+     *\n+     * This test passes without the fix, must pass after as well.\n+     *\/\n+    @Test\n+    public void testRemoveLastIfSelectedIsSecondLast() {\n+        showTabPane();\n+        int last = tabPane.getTabs().size() - 1;\n+        Tab lastTab = tabPane.getTabs().get(last);\n+        int secondLast = last - 1;\n+        Tab secondLastTab = tabPane.getTabs().get(secondLast);\n+\n+        \/\/ select for max scroll\n+        tabPane.getSelectionModel().select(last);\n+        Toolkit.getToolkit().firePulse();\n+\n+        \/\/ at this point, the header is scrolled such that the last is at the very right\n+        double scrollOffset = getHeaderAreaScrollOffset(tabPane);\n+        double lastTabOffest = getTabHeaderOffset(tabPane, lastTab);\n+        double secondeLastTabOffset = getTabHeaderOffset(tabPane, secondLastTab);\n+        \/\/ expected change in scroll offset\n+        double expectedDelta = lastTabOffest - secondeLastTabOffset;\n+\n+        \/\/ select previous tab\n+        tabPane.getSelectionModel().select(secondLast);\n+        Toolkit.getToolkit().firePulse();\n+\n+         \/\/ remove last\n+        tabPane.getTabs().remove(last);\n+        Toolkit.getToolkit().firePulse();\n+\n+        assertEquals(\"scrollOffset adjusted: \", scrollOffset + expectedDelta, getHeaderAreaScrollOffset(tabPane), 1);\n+    }\n+\n+    @Test\n+    public void testRemoveBefore() {\n+        showTabPane();\n+        int selected = 4;\n+        tabPane.getSelectionModel().select(selected);\n+        Tab selectedTab = tabPane.getSelectionModel().getSelectedItem();\n+        Toolkit.getToolkit().firePulse();\n+        \/\/ state before tabs modification\n+        double selectedTabOffset = getTabHeaderOffset(tabPane, selectedTab);\n+        double scrollOffset = getHeaderAreaScrollOffset(tabPane);\n+        assertEquals(\"sanity: tab visible but not scrolled\", 0, scrollOffset, 1);\n+\n+        \/\/ scroll selected to leading edge\n+        setHeaderAreaScrollOffset(tabPane, - selectedTabOffset);\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(\"sanity: really scrolled\", - selectedTabOffset, getHeaderAreaScrollOffset(tabPane), 1);\n+        tabPane.getTabs().remove(0);\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(\"scroll offset\", - getTabHeaderOffset(tabPane, selectedTab), getHeaderAreaScrollOffset(tabPane), 1);\n+    }\n+\n+    @Test\n+    public void testAddBefore() {\n+        showTabPane();\n+        int last = tabPane.getTabs().size() - 1;\n+        tabPane.getSelectionModel().select(last);\n+        Tab selectedTab = tabPane.getSelectionModel().getSelectedItem();\n+        Toolkit.getToolkit().firePulse();\n+        \/\/ state before tabs modification\n+        double selectedTabOffset = getTabHeaderOffset(tabPane, selectedTab);\n+        double scrollOffset = getHeaderAreaScrollOffset(tabPane);\n+\n+        Tab added = new Tab(\"added\", new Label(\"added\"));\n+        tabPane.getTabs().add(0, added);\n+        Toolkit.getToolkit().firePulse();\n+        Node addedHeader = getTabHeaderFor(tabPane, added);\n+        double addedWidth = addedHeader.prefWidth(-1);\n+        assertEquals(\"sanity\", selectedTabOffset + addedWidth, getTabHeaderOffset(tabPane, selectedTab), 1);\n+        assertEquals(\"scroll offset\", scrollOffset - addedWidth, getHeaderAreaScrollOffset(tabPane), 1);\n+    }\n+\n+    \/**\n+     * Test scroll on changing tabPane width.\n+     *\/\n+    @Test\n+    public void testDecreaseWidth() {\n+        assertScrollOnDecreaseSize(Side.TOP);\n+    }\n+\n+    \/**\n+     * Test scroll on changing tabPane height.\n+     *\/\n+    @Test\n+    public void testDecreaseHeight() {\n+        assertScrollOnDecreaseSize(Side.RIGHT);\n+    }\n+\n+    private void assertScrollOnDecreaseSize(Side side) {\n+        \/\/ init and configure tabPane with fitting # of tabs\n+        TabPane tabPane = createTabPane(FITTING);\n+        tabPane.setSide(side);\n+        showTabPane(tabPane);\n+        tabPane.getSelectionModel().select(tabPane.getTabs().size() - 1);\n+        Toolkit.getToolkit().firePulse();\n+        Node header = getSelectedTabHeader(tabPane);\n+        double tabOffset = getTabHeaderOffset(tabPane, tabPane.getSelectionModel().getSelectedItem());\n+\n+        \/\/ assert scroll state (== no scroll) before resize\n+        double noScrollOffset = getHeaderAreaScrollOffset(tabPane);\n+        assertEquals(\"scrollOffset for fitting tabs\", 0, noScrollOffset, 1);\n+        assertEquals(\"bounds minX\", tabOffset, header.getBoundsInParent().getMinX(), 1);\n+\n+        \/\/ force resize of tabPane by decreasing max size.\n+        if (side.isHorizontal()) {\n+            tabPane.setMaxWidth(stage.getWidth()\/2);\n+        } else {\n+            tabPane.setMaxHeight(stage.getHeight()\/2);\n+        }\n+        Toolkit.getToolkit().firePulse();\n+\n+        \/\/ assert scroll state after resize\n+        double scrollOffset = getHeaderAreaScrollOffset(tabPane);\n+        assertFalse(\"sanity: not fitting after resize\", isTabsFit(tabPane));\n+        assertTrue(\"header must be scrolled\", scrollOffset < 0);\n+        assertEquals(\"bounds minX\", tabOffset, - scrollOffset + header.getBoundsInParent().getMinX(), 0);\n+    }\n+\n+    \/**\n+     * Sanity test of tabPane configured with FITTING count of tabs.\n+     * Beware: this might be context dependent - if this fails,\n+     * testing of change of width\/height most probably are unreliable.\n+     *\/\n+    @Test\n+    public void testTabsFitHorizontal() {\n+        assertTabsFit(Side.TOP);\n+    }\n+\n+    @Test\n+    public void testTabsFitVertical() {\n+        assertTabsFit(Side.RIGHT);\n+    }\n+\n+    private void assertTabsFit(Side side) {\n+        TabPane tabPane = createTabPane(FITTING);\n+        tabPane.setSide(side);\n+        showTabPane(tabPane);\n+        assertTrue(isTabsFit(tabPane));\n+        tabPane.getTabs().add(new Tab(\"tab + x\"));\n+        Toolkit.getToolkit().firePulse();\n+        assertFalse(isTabsFit(tabPane));\n+    }\n+\n+    \/**\n+     * Test scroll on change side.\n+     *\/\n+    @Test\n+    public void testChangeSide() {\n+        showTabPane();\n+        tabPane.getSelectionModel().select(tabPane.getTabs().size() - 1);\n+        Toolkit.getToolkit().firePulse();\n+        tabPane.setSide(Side.BOTTOM);\n+        Toolkit.getToolkit().firePulse();\n+        assertScrolledToLastAndBack();\n+    }\n+\n+    \/**\n+     * Test scroll to initially selected tab.\n+     *\/\n+    @Test\n+    public void testInitialSelect() {\n+        tabPane.getSelectionModel().select(tabPane.getTabs().size() - 1);\n+        showTabPane();\n+        assertScrolledToLastAndBack();\n+    }\n+\n+    \/**\n+     * Sanity test: selecting tab after showing.\n+     *\/\n+    @Test\n+    public void testSelect() {\n+        showTabPane();\n+        assertEquals(0, getHeaderAreaScrollOffset(tabPane), 1);\n+        tabPane.getSelectionModel().select(tabPane.getTabs().size() - 1);\n+        Toolkit.getToolkit().firePulse();\n+        assertScrolledToLastAndBack();\n+    }\n+\n+    \/**\n+     * Qualitative assert that tabHeaderArea of default TabPane is scrolled as expected.\n+     * The tabPane must be configured to have the last tab selected.\n+     * Then selects second tab and asserts that headerArea is scrolled back\n+     * to show the tab at the leading edge.\n+     *\/\n+    private void assertScrolledToLastAndBack() {\n+        Node firstHeader = getTabHeaderFor(tabPane, tabPane.getTabs().get(0));\n+        \/\/ rough measure for one header\n+        double scrollPerTab = firstHeader.prefWidth(-1);\n+        double scrollPerThirdOfTabs = THIRD_OF * scrollPerTab;\n+        double scrollOffset = getHeaderAreaScrollOffset(tabPane);\n+        assertTrue(\"scrollOffset must be negative\", scrollOffset < 0);\n+        assertTrue(\"scrollOffset \" + scrollOffset + \"must be much greater than multiple tab widths \" + scrollPerThirdOfTabs ,\n+                scrollPerThirdOfTabs < - scrollOffset);\n+        tabPane.getSelectionModel().select(1);\n+        Toolkit.getToolkit().firePulse();\n+        \/\/ scrolled back such that second header is at the leading edge of the header area\n+        assertEquals(\"scrollOffset\", scrollPerTab, - getHeaderAreaScrollOffset(tabPane), 1);\n+    }\n+\n+\/\/------------- setup and initial state testing\n+\n+    \/**\n+     * Show the default TabPane.\n+     *\/\n+    protected void showTabPane() {\n+        showTabPane(tabPane);\n+    }\n+\n+    \/**\n+     * Ensures the control is shown in an active scenegraph.\n+     *\n+     * @param control the control to show\n+     *\/\n+    protected void showTabPane(TabPane tabPane) {\n+        if (root == null) {\n+            root = new VBox();\n+            \/\/ need to bound the size here, otherwise it's just as big as needed\n+            scene = new Scene(root, 600, 600);\n+            stage = new Stage();\n+            stage.setScene(scene);\n+            stage.show();\n+        }\n+        \/\/ need single child, otherwise the outcome might depend on layout\n+        root.getChildren().setAll(tabPane);\n+        \/\/ needed if the hierarchy is changed after showing the stage\n+        Toolkit.getToolkit().firePulse();\n+        disableAnimations((TabPaneSkin) tabPane.getSkin());\n+    }\n+\n+\/\/----------------- setup and initial\n+\n+    @Test\n+    public void testShowAlternativeTabPane() {\n+        \/\/ show default tabPane\n+        showTabPane();\n+        List<Node> expected = List.of(tabPane);\n+        assertEquals(expected, root.getChildren());\n+        \/\/ show alternative\n+        TabPane alternativeTabPane = createTabPane();\n+        showTabPane(alternativeTabPane);\n+        List<Node> alternative = List.of(alternativeTabPane);\n+        assertEquals(alternative, root.getChildren());\n+    }\n+\n+    @Test\n+    public void testShowTabPane() {\n+        assertNotNull(tabPane);\n+        assertSame(Side.TOP, tabPane.getSide());\n+        showTabPane();\n+        List<Node> expected = List.of(tabPane);\n+        assertEquals(expected, root.getChildren());\n+    }\n+\n+    protected TabPane createTabPane() {\n+        return createTabPane(TAB_COUNT);\n+    }\n+\n+    protected TabPane createTabPane(int max) {\n+        TabPane tabPane = new TabPane();\n+        for (int i = 0; i < max; i++) {\n+            Tab tab = new Tab(\"Tab \" + i, new Label(\"Content for \" + i));\n+            tabPane.getTabs().add(tab);\n+        }\n+        return tabPane;\n+    }\n+\n+    @Before\n+    public void setup() {\n+        Thread.currentThread().setUncaughtExceptionHandler((thread, throwable) -> {\n+            if (throwable instanceof RuntimeException) {\n+                throw (RuntimeException)throwable;\n+            } else {\n+                Thread.currentThread().getThreadGroup().uncaughtException(thread, throwable);\n+            }\n+        });\n+        tabPane = createTabPane();\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        if (stage != null) stage.hide();\n+        Thread.currentThread().setUncaughtExceptionHandler(null);\n+    }\n+\n+\/\/------------------- helpers to access tab headers\n+\n+    public static double getTabHeaderOffset(TabPane tabPane, Tab tab) {\n+        Objects.requireNonNull(tabPane, \"tabPane must not be null\");\n+        Objects.requireNonNull(tab, \"tab must not be null\");\n+        if (!tabPane.getTabs().contains(tab)) throw new IllegalStateException(\"tab must be contained\");\n+        List<Node> headers = getTabHeaders(tabPane);\n+        double offset = 0;\n+        for (Node node : headers) {\n+            if (getTabFor(node) == tab) break;\n+            offset += node.prefWidth(-1);\n+        }\n+        return offset;\n+    }\n+\n+    public static Node getSelectedTabHeader(TabPane tabPane) {\n+        Objects.requireNonNull(tabPane, \"tabPane must not be null\");\n+        if (tabPane.getTabs().isEmpty()) throw new IllegalStateException(\"tabs must not be empty\");\n+        Tab tab = tabPane.getSelectionModel().getSelectedItem();\n+        return getTabHeaderFor(tabPane, tab);\n+    }\n+\n+    public static Node getTabHeaderFor(TabPane tabPane, Tab tab) {\n+        Objects.requireNonNull(tabPane, \"tabPane must not be null\");\n+        Objects.requireNonNull(tab, \"tab must not be null\");\n+        if (!tabPane.getTabs().contains(tab)) throw new IllegalStateException(\"tab must be contained\");\n+        List<Node> headers = getTabHeaders(tabPane);\n+        Optional<Node> tabHeader = headers.stream()\n+                .filter(node -> getTabFor(node) == tab)\n+                .findFirst();\n+        return tabHeader.get();\n+    }\n+\n+    public static Tab getTabFor(Node tabHeader) {\n+        Objects.requireNonNull(tabHeader, \"tabHeader must not be null\");\n+        Object tab = tabHeader.getProperties().get(Tab.class);\n+        if (tab instanceof Tab) return (Tab) tab;\n+        throw new IllegalStateException(\"node is not a tabHeader \" + tabHeader);\n+    }\n+\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/TabPaneHeaderScrollTest.java","additions":466,"deletions":0,"binary":false,"changes":466,"status":"added"}]}