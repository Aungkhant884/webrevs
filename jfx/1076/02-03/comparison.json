{"files":[{"patch":"@@ -185,1 +185,1 @@\n-        T t = cast(o);\n+        Class<T> elementType = getElementType();\n@@ -187,1 +187,1 @@\n-        if (t == null) {  \/\/ if cast failed, it can't be part of this set, so not modified\n+        if (!elementType.isInstance(o)) {  \/\/ if cast failed, it can't be part of this set, so not modified\n@@ -191,2 +191,4 @@\n-        final int element = getIndex(t) \/ Long.SIZE;\n-        final long bit = 1l << (getIndex(t) % Long.SIZE);\n+        T t = elementType.cast(o);\n+        int index = getIndex(t);\n+        int element = index \/ Long.SIZE;\n+        long bit = 1l << (index % Long.SIZE);\n@@ -227,1 +229,1 @@\n-        final T t = cast(o);\n+        Class<T> elementType = getElementType();\n@@ -229,1 +231,1 @@\n-        if (t == null) {  \/\/ if cast failed, it can't be part of this set\n+        if (!elementType.isInstance(o)) {\n@@ -233,1 +235,1 @@\n-        int index = getIndex(t);\n+        int index = getIndex(elementType.cast(o));\n@@ -545,1 +547,14 @@\n-        if (obj instanceof BitSet<?> bitSet) {  \/\/ fast path if other is a BitSet\n+\n+        if (obj instanceof BitSet<?> bitSet && getElementType().equals(bitSet.getElementType())) {\n+\n+            \/*\n+             * For historic reasons, a potentially faster path is entered here to do a comparison of the\n+             * underlying long array directly. The proof of whether it is actually faster is lost, but\n+             * it is assumed it is until proven otherwise. Note that in the past the element type was NOT\n+             * considered, and potentially two bit sets with the same pattern could be considered equal\n+             * despite having different classes stored in them.\n+             *\n+             * Now if the two sets contain different element types, we enter the much safer default\n+             * path, which takes the equals implementation of each element correctly into consideration.\n+             *\/\n+\n@@ -555,0 +570,1 @@\n+        int max = Math.max(a, b);\n@@ -556,7 +572,3 @@\n-        if (a != b) {\n-            return false;\n-        }\n-\n-        for (int m = 0; m < a; m++) {\n-            long m0 = this.bits[m];\n-            long m1 = other.bits[m];\n+        for (int i = 0; i < max; i++) {\n+            long m0 = i >= a ? 0 : this.bits[i];\n+            long m1 = i >= b ? 0 : other.bits[i];\n@@ -576,2 +588,1 @@\n-     * Return {@code obj} if it is an instance of type {@code T},\n-     * otherwise return {@code null}.\n+     * Returns the element type.\n@@ -579,3 +590,1 @@\n-     * @param obj the object to cast, cannot be {@code null}\n-     * @return a type T, or {@code null} if the argument was not of this type\n-     * @throws NullPointerException when {@code obj} is {@code null}\n+     * @return a {@link Class} of type {@code T}, never {@code null}\n@@ -583,1 +592,1 @@\n-    protected abstract T cast(Object obj);\n+    protected abstract Class<T> getElementType();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/BitSet.java","additions":30,"deletions":21,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -68,6 +68,2 @@\n-    protected PseudoClass cast(Object o) {\n-        if (o == null) {\n-            throw new NullPointerException(\"null arg\");\n-        }\n-\n-        return o instanceof PseudoClass pseudoClass ? pseudoClass : null;\n+    protected Class<PseudoClass> getElementType() {\n+        return PseudoClass.class;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/PseudoClassState.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -76,6 +76,2 @@\n-    protected StyleClass cast(Object o) {\n-        if (o == null) {\n-            throw new NullPointerException(\"null arg\");\n-        }\n-\n-        return o instanceof StyleClass styleClass ? styleClass : null;\n+    protected Class<StyleClass> getElementType() {\n+        return StyleClass.class;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/StyleClassSet.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+package test.com.sun.javafx.css;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.sun.javafx.css.PseudoClassState;\n+import com.sun.javafx.css.PseudoClassStateShim;\n+import com.sun.javafx.css.StyleClassSet;\n+\n+import javafx.css.PseudoClass;\n+import javafx.css.StyleClass;\n+\n+public class BitSetTest {\n+\n+    @Test\n+    void twoNonEmptyBitSetsWithSamePatternAndSizeShouldNotBeConsideredEqualsWhenElementTypesAreDifferent() {\n+        StyleClassSet set1 = new StyleClassSet();\n+        PseudoClassState set2 = new PseudoClassState();\n+\n+        PseudoClass pseudoClass = PseudoClass.getPseudoClass(\"abc\");\n+\n+        int index = PseudoClassStateShim.pseudoClassMap.get(pseudoClass.getPseudoClassName());\n+\n+        set1.add(new StyleClass(\"xyz\", index));  \/\/ no idea why this is public API, but I'll take it\n+        set2.add(pseudoClass);\n+\n+        \/*\n+         * The two sets above contain elements of different types (PseudoClass and StyleClass)\n+         * and therefore should never be equal, despite their bit pattern being the same:\n+         *\/\n+\n+        assertNotEquals(set1, set2);\n+    }\n+\n+    @Test\n+    void shouldBeEqual() {\n+        StyleClassSet set1 = new StyleClassSet();\n+        StyleClassSet set2 = new StyleClassSet();\n+\n+        set1.add(StyleClassSet.getStyleClass(\"abc\"));\n+        set2.add(StyleClassSet.getStyleClass(\"abc\"));\n+\n+        assertEquals(set1, set2);\n+\n+        for (int i = 0; i < 1000; i++) {\n+            \/\/ grow internal bit set array:\n+            set1.add(StyleClassSet.getStyleClass(\"\" + i));\n+\n+            assertNotEquals(set1, set2);\n+        }\n+\n+        for (int i = 0; i < 1000; i++) {\n+            set1.remove(StyleClassSet.getStyleClass(\"\" + i));\n+        }\n+\n+        \/\/ still equal despite internal array sizes being different size:\n+        assertEquals(set1, set2);\n+    }\n+\n+    @Test\n+    void twoEmptyBitSetsShouldBeEqual() {\n+\n+        \/*\n+         * Per Set contract, the empty set is equal to any other empty set.\n+         *\/\n+\n+        assertEquals(new StyleClassSet(), new PseudoClassState());\n+        assertEquals(new PseudoClassState(), new StyleClassSet());\n+        assertEquals(Set.of(), new PseudoClassState());\n+        assertEquals(new PseudoClassState(), Set.of());\n+        assertEquals(Set.of(), new StyleClassSet());\n+        assertEquals(new StyleClassSet(), Set.of());\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/css\/BitSetTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}