{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,5 @@\n+import java.util.AbstractSet;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n@@ -28,0 +33,1 @@\n+\n@@ -33,4 +39,0 @@\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.NoSuchElementException;\n-\n@@ -42,1 +44,1 @@\n-abstract class BitSet<T> implements ObservableSet<T> {\n+abstract class BitSet<T> extends AbstractSet<T> implements ObservableSet<T> {\n@@ -183,1 +185,1 @@\n-        T t = cast(o);\n+        Class<T> elementType = getElementType();\n@@ -185,2 +187,8 @@\n-        final int element = getIndex(t) \/ Long.SIZE;\n-        final long bit = 1l << (getIndex(t) % Long.SIZE);\n+        if (!elementType.isInstance(o)) {  \/\/ if cast failed, it can't be part of this set, so not modified\n+            return false;\n+        }\n+\n+        T t = elementType.cast(o);\n+        int index = getIndex(t);\n+        int element = index \/ Long.SIZE;\n+        long bit = 1l << (index % Long.SIZE);\n@@ -221,1 +229,1 @@\n-        final T t = cast(o);\n+        Class<T> elementType = getElementType();\n@@ -223,2 +231,7 @@\n-        final int element = getIndex(t) \/ Long.SIZE;\n-        final long bit = 1l << (getIndex(t) % Long.SIZE);\n+        if (!elementType.isInstance(o)) {\n+            return false;\n+        }\n+\n+        int index = getIndex(elementType.cast(o));\n+        int element = index \/ Long.SIZE;\n+        long bit = 1L << (index % Long.SIZE);\n@@ -229,1 +242,0 @@\n-    \/** {@inheritDoc} *\/\n@@ -232,0 +244,3 @@\n+        if (c == null) {\n+           throw new NullPointerException(\"c cannot be null\");\n+        }\n@@ -233,3 +248,8 @@\n-        if (c == null || this.getClass() != c.getClass()) {\n-            \/\/ this not modified!\n-            return false;\n+        if (this.getClass() != c.getClass()) {\n+            for (Object obj : c) {\n+                if (!contains(obj)) {\n+                    return false;\n+                }\n+            }\n+\n+            return true;\n@@ -257,2 +277,0 @@\n-\n-    \/** {@inheritDoc} *\/\n@@ -261,0 +279,3 @@\n+        if (c == null) {\n+            throw new NullPointerException(\"c cannot be null\");\n+        }\n@@ -262,3 +283,8 @@\n-        if (c == null || this.getClass() != c.getClass()) {\n-            \/\/ this not modified!\n-            return false;\n+        if (this.getClass() != c.getClass()) {\n+            boolean modified = false;\n+\n+            for (T obj : c) {\n+                modified |= add(obj);\n+            }\n+\n+            return modified;\n@@ -330,1 +356,0 @@\n-    \/** {@inheritDoc} *\/\n@@ -333,0 +358,3 @@\n+        if (c == null) {\n+            throw new NullPointerException(\"c cannot be null\");\n+        }\n@@ -334,3 +362,13 @@\n-        if (c == null || this.getClass() != c.getClass()) {\n-            clear();\n-            return true;\n+        if (this.getClass() != c.getClass()) {\n+            boolean modified = false;\n+\n+            for (Iterator<T> iterator = this.iterator(); iterator.hasNext();) {\n+                T obj = iterator.next();\n+\n+                if (!c.contains(obj)) {\n+                    iterator.remove();\n+                    modified = true;\n+                }\n+            }\n+\n+            return modified;\n@@ -411,2 +449,0 @@\n-\n-    \/** {@inheritDoc} *\/\n@@ -415,0 +451,3 @@\n+        if (c == null) {\n+            throw new NullPointerException(\"c cannot be null\");\n+        }\n@@ -416,3 +455,8 @@\n-        if (c == null || this.getClass() != c.getClass()) {\n-            \/\/ this not modified!\n-            return false;\n+        if (this.getClass() != c.getClass()) {\n+            boolean modified = false;\n+\n+            for (Object obj : c) {\n+                modified |= remove(obj);\n+            }\n+\n+            return modified;\n@@ -476,1 +520,0 @@\n-    \/** {@inheritDoc} *\/\n@@ -496,12 +539,0 @@\n-    @Override\n-    public int hashCode() {\n-        int hash = 7;\n-        if (bits.length > 0) {\n-            for (int n = 0; n < bits.length; n++) {\n-                final long mask = bits[n];\n-                hash = 71 * hash + (int)(mask ^ (mask >>> 32));\n-            }\n-        }\n-        return hash;\n-    }\n-\n@@ -510,2 +541,4 @@\n-\n-        if (this == obj) {\n+        \/\/ Note: overridden to provide a fast path; must still respect Set contract or it\n+        \/\/ will not interact correctly with other sets; same goes for hashCode, do not\n+        \/\/ override arbitrarily!\n+        if (obj == this) {\n@@ -515,2 +548,14 @@\n-        if (obj == null || this.getClass() != obj.getClass()) {\n-            return false;\n+        if (obj instanceof BitSet<?> bitSet && getElementType().equals(bitSet.getElementType())) {\n+\n+            \/*\n+             * For historic reasons, a potentially faster path is entered here to do a comparison of the\n+             * underlying long array directly. The proof of whether it is actually faster is lost, but\n+             * it is assumed it is until proven otherwise. Note that in the past the element type was NOT\n+             * considered, and potentially two bit sets with the same pattern could be considered equal\n+             * despite having different classes stored in them.\n+             *\n+             * Now if the two sets contain different element types, we enter the much safer default\n+             * path, which takes the equals implementation of each element correctly into consideration.\n+             *\/\n+\n+            return equalsBitSet(bitSet);\n@@ -519,1 +564,2 @@\n-        final BitSet other = (BitSet) obj;\n+        return super.equals(obj);\n+    }\n@@ -521,2 +567,4 @@\n-        final int a = this.bits != null ? this.bits.length : 0;\n-        final int b = other.bits != null ? other.bits.length : 0;\n+    private boolean equalsBitSet(BitSet<?> other) {\n+        int a = this.bits != null ? this.bits.length : 0;\n+        int b = other.bits != null ? other.bits.length : 0;\n+        int max = Math.max(a, b);\n@@ -524,1 +572,3 @@\n-        if (a != b) return false;\n+        for (int i = 0; i < max; i++) {\n+            long m0 = i >= a ? 0 : this.bits[i];\n+            long m1 = i >= b ? 0 : other.bits[i];\n@@ -526,3 +576,0 @@\n-        for(int m=0; m<a; m++) {\n-            final long m0 = this.bits[m];\n-            final long m1 = other.bits[m];\n@@ -533,0 +580,1 @@\n+\n@@ -536,2 +584,2 @@\n-    abstract protected T getT(int index);\n-    abstract protected int getIndex(T t);\n+    protected abstract T getT(int index);\n+    protected abstract int getIndex(T t);\n@@ -539,5 +587,4 @@\n-    \/*\n-     * Try to cast the arg to a T.\n-     * @throws ClassCastException if the class of the argument is\n-     *         is not a T\n-     * @throws NullPointerException if the argument is null\n+    \/**\n+     * Returns the element type.\n+     *\n+     * @return a {@link Class} of type {@code T}, never {@code null}\n@@ -545,1 +592,1 @@\n-    abstract protected T cast(Object o);\n+    protected abstract Class<T> getElementType();\n@@ -547,1 +594,1 @@\n-    protected long[] getBits() {\n+    long[] getBits() {\n@@ -604,1 +651,1 @@\n-            SetListenerHelper.removeListener(listenerHelper, setChangeListener);\n+            listenerHelper = SetListenerHelper.removeListener(listenerHelper, setChangeListener);\n@@ -618,1 +665,1 @@\n-            SetListenerHelper.removeListener(listenerHelper, invalidationListener);\n+            listenerHelper = SetListenerHelper.removeListener(listenerHelper, invalidationListener);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/BitSet.java","additions":112,"deletions":65,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.javafx.css;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import javafx.css.PseudoClass;\n+\n+\/**\n+ * A cache for immutable sets of {@link PseudoClass}es.\n+ *\/\n+public class ImmutablePseudoClassSetsCache {\n+    private static final Map<Set<PseudoClass>, Set<PseudoClass>> CACHE = new HashMap<>();\n+\n+    \/**\n+     * Returns an immutable set of {@link PseudoClass}es.\n+     * <p>\n+     * Note: this method may or may not return the same instance for the same set of\n+     * {@link PseudoClass}es.\n+     *\n+     * @param pseudoClasses a set of {@link PseudoClass} to make immutable, cannot be {@code null}\n+     * @return an immutable set of {@link PseudoClass}es, never {@code null}\n+     * @throws NullPointerException when {@code pseudoClasses} is {@code null} or contains {@code null}s\n+     *\/\n+    public static Set<PseudoClass> of(Set<PseudoClass> pseudoClasses) {\n+        return CACHE.computeIfAbsent(\n+            Objects.requireNonNull(pseudoClasses, \"pseudoClasses cannot be null\"),\n+            k -> Set.copyOf(pseudoClasses)\n+        );\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/ImmutablePseudoClassSetsCache.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,29 +57,0 @@\n-    \/** {@inheritDoc} *\/\n-    @Override\n-    public Object[] toArray() {\n-        return toArray(new PseudoClass[size()]);\n-    }\n-\n-    \/** {@inheritDoc} *\/\n-    @Override\n-    public <T> T[] toArray(T[] a) {\n-        if (a.length < size()) {\n-            a = (T[]) new PseudoClass[size()];\n-        }\n-        int index = 0;\n-        while(index < getBits().length) {\n-            final long state = getBits()[index];\n-            for(int bit=0; bit<Long.SIZE; bit++) {\n-                long mask = 1l << bit;\n-                if ((state & mask) == mask) {\n-                    int n = index * Long.SIZE + bit;\n-                    PseudoClass impl = getPseudoClass(n);\n-                    a[index++] = (T) impl;\n-                }\n-\n-            }\n-        }\n-        return a;\n-    }\n-\n-\n@@ -97,6 +68,2 @@\n-    protected PseudoClass cast(Object o) {\n-        if (o == null) {\n-            throw new NullPointerException(\"null arg\");\n-        }\n-        PseudoClass pseudoClass = (PseudoClass) o;\n-        return pseudoClass;\n+    protected Class<PseudoClass> getElementType() {\n+        return PseudoClass.class;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/PseudoClassState.java","additions":3,"deletions":36,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,2 +71,1 @@\n-                this.pseudoClassStates[n] = new PseudoClassState();\n-                this.pseudoClassStates[n].addAll(pseudoClassStates[n]);\n+                this.pseudoClassStates[n] = ImmutablePseudoClassSetsCache.of(pseudoClassStates[n]);\n@@ -93,1 +92,1 @@\n-                final int iMax = pseudoClassStates != null ? pseudoClassStates.length : 0;\n+                final int iMax = pseudoClassStates.length;\n@@ -132,10 +131,0 @@\n-            \/\/ either both must be null or both must be not-null\n-            if ((pseudoClassStates == null) ^ (other.pseudoClassStates == null)) {\n-                return false;\n-            }\n-\n-            \/\/ if one is null, the other is too.\n-            if (pseudoClassStates == null) {\n-                return true;\n-            }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/StyleCacheEntry.java","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,29 +61,0 @@\n-    \/** {@inheritDoc} *\/\n-    @Override\n-    public Object[] toArray() {\n-        return toArray(new StyleClass[size()]);\n-    }\n-\n-    \/** {@inheritDoc} *\/\n-    @Override\n-    public <T> T[] toArray(T[] a) {\n-        if (a.length < size()) {\n-            a = (T[]) new StyleClass[size()];\n-        }\n-        int index = 0;\n-        while(index < getBits().length) {\n-            final long state = getBits()[index];\n-            for(int bit=0; bit<Long.SIZE; bit++) {\n-                long mask = 1l << bit;\n-                if ((state & mask) == mask) {\n-                    int n = index * Long.SIZE + bit;\n-                    StyleClass impl = getStyleClass(n);\n-                    a[index++] = (T) impl;\n-                }\n-\n-            }\n-        }\n-        return a;\n-    }\n-\n-\n@@ -105,6 +76,2 @@\n-    protected StyleClass cast(Object o) {\n-        if (o == null) {\n-            throw new NullPointerException(\"null arg\");\n-        }\n-        StyleClass styleClass = (StyleClass) o;\n-        return styleClass;\n+    protected Class<StyleClass> getElementType() {\n+        return StyleClass.class;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/StyleClassSet.java","additions":3,"deletions":36,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -154,1 +154,3 @@\n-                    pseudoClassOut.addAll(pseudoClassIn);\n+                    if (pseudoClassIn != null) {\n+                        pseudoClassOut.addAll(pseudoClassIn);\n+                    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/CompoundSelector.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import com.sun.javafx.css.PseudoClassState;\n-\n@@ -32,0 +30,3 @@\n+import java.util.Set;\n+\n+import com.sun.javafx.css.ImmutablePseudoClassSetsCache;\n@@ -44,1 +45,1 @@\n-    final PseudoClassState pseudoClasses;\n+    final Set<PseudoClass> pseudoClasses;\n@@ -52,1 +53,1 @@\n-    Match(final Selector selector, PseudoClassState pseudoClasses, int idCount, int styleClassCount) {\n+    Match(final Selector selector, Set<PseudoClass> pseudoClasses, int idCount, int styleClassCount) {\n@@ -54,0 +55,2 @@\n+        assert pseudoClasses != null;\n+\n@@ -57,4 +60,3 @@\n-        this.pseudoClasses = pseudoClasses;\n-        int nPseudoClasses = pseudoClasses != null ? pseudoClasses.size() : 0;\n-        if (selector instanceof SimpleSelector) {\n-            final SimpleSelector simple = (SimpleSelector)selector;\n+        this.pseudoClasses = ImmutablePseudoClassSetsCache.of(pseudoClasses);\n+        int nPseudoClasses = pseudoClasses.size();\n+        if (selector instanceof SimpleSelector simple) {\n@@ -70,1 +72,2 @@\n-     * @return the {@code Selector}\n+     *\n+     * @return the {@code Selector}, never {@code null}\n@@ -78,1 +81,2 @@\n-     * @return the pseudo class state\n+     *\n+     * @return an immutable set of {@link PseudoClass}es, never {@code null}\n@@ -80,1 +84,1 @@\n-    public PseudoClassState getPseudoClasses() {\n+    public Set<PseudoClass> getPseudoClasses() {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/Match.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import com.sun.javafx.css.ImmutablePseudoClassSetsCache;\n@@ -112,1 +113,1 @@\n-    final private PseudoClassState pseudoClassState;\n+    final private Set<PseudoClass> pseudoClassState;\n@@ -114,0 +115,1 @@\n+    \/\/ for test purposes\n@@ -118,22 +120,0 @@\n-    \/**\n-     * Gets an immutable list of {@code String}s of pseudo classes of the {@code Selector}\n-     * @return an immutable list of {@code String}s\n-     *\/\n-    List<String> getPseudoclasses() {\n-\n-        final List<String> names = new ArrayList<>();\n-\n-        Iterator<PseudoClass> iter = pseudoClassState.iterator();\n-        while (iter.hasNext()) {\n-            names.add(iter.next().getPseudoClassName());\n-        }\n-\n-        if (nodeOrientation == RIGHT_TO_LEFT) {\n-            names.add(\"dir(rtl)\");\n-        } else if (nodeOrientation == LEFT_TO_RIGHT) {\n-            names.add(\"dir(ltr)\");\n-        }\n-\n-        return Collections.unmodifiableList(names);\n-    }\n-\n@@ -185,1 +165,1 @@\n-        this.pseudoClassState = new PseudoClassState();\n+        PseudoClassState pcs = new PseudoClassState();\n@@ -202,2 +182,1 @@\n-            final PseudoClass pseudoClass = PseudoClassState.getPseudoClass(pclass);\n-            this.pseudoClassState.add(pseudoClass);\n+            pcs.add(PseudoClassState.getPseudoClass(pclass));\n@@ -206,0 +185,1 @@\n+        this.pseudoClassState = ImmutablePseudoClassSetsCache.of(pcs);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/SimpleSelector.java","additions":7,"deletions":27,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+import com.sun.javafx.css.ImmutablePseudoClassSetsCache;\n+\n@@ -83,1 +85,0 @@\n-        this.triggerStates = new PseudoClassState();\n@@ -134,1 +135,4 @@\n-            node.styleHelper.triggerStates.addAll(triggerStates[0]);\n+\n+            if (triggerStates[0] != null) {\n+                node.styleHelper.triggerStates.addAll(triggerStates[0]);\n+            }\n@@ -174,1 +178,4 @@\n-        helper.triggerStates.addAll(triggerStates[0]);\n+\n+        if (triggerStates[0] != null) {\n+            helper.triggerStates.addAll(triggerStates[0]);\n+        }\n@@ -511,1 +518,1 @@\n-    private PseudoClassState triggerStates = new PseudoClassState();\n+    private final PseudoClassState triggerStates = new PseudoClassState();\n@@ -550,1 +557,1 @@\n-        final Set<PseudoClass>[] retainedStates = new PseudoClassState[depth];\n+        final Set<PseudoClass>[] retainedStates = new Set[depth];\n@@ -561,0 +568,1 @@\n+\n@@ -562,8 +570,7 @@\n-            final CssStyleHelper helper = (parent instanceof Node) ? parent.styleHelper : null;\n-            if (helper != null) {\n-                final Set<PseudoClass> pseudoClassState = parent.pseudoClassStates;\n-                retainedStates[count] = new PseudoClassState();\n-                retainedStates[count].addAll(pseudoClassState);\n-                \/\/ retainAll method takes the intersection of pseudoClassState and helper.triggerStates\n-                retainedStates[count].retainAll(helper.triggerStates);\n-                count += 1;\n+            if (parent.styleHelper != null) {\n+                PseudoClassState pseudoClassState = new PseudoClassState();\n+\n+                pseudoClassState.addAll(parent.pseudoClassStates);\n+                pseudoClassState.retainAll(parent.styleHelper.triggerStates);\n+\n+                retainedStates[count++] = ImmutablePseudoClassSetsCache.of(pseudoClassState);\n@@ -571,0 +578,1 @@\n+\n@@ -574,1 +582,5 @@\n-        final Set<PseudoClass>[] transitionStates = new PseudoClassState[count];\n+        if (count == depth) {\n+          return retainedStates;\n+        }\n+\n+        final Set<PseudoClass>[] transitionStates = new Set[count];\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/CssStyleHelper.java","additions":26,"deletions":14,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+package test.com.sun.javafx.css;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.sun.javafx.css.PseudoClassState;\n+import com.sun.javafx.css.PseudoClassStateShim;\n+import com.sun.javafx.css.StyleClassSet;\n+\n+import javafx.css.PseudoClass;\n+import javafx.css.StyleClass;\n+\n+public class BitSetTest {\n+\n+    @Test\n+    void twoNonEmptyBitSetsWithSamePatternAndSizeShouldNotBeConsideredEqualsWhenElementTypesAreDifferent() {\n+        StyleClassSet set1 = new StyleClassSet();\n+        PseudoClassState set2 = new PseudoClassState();\n+\n+        PseudoClass pseudoClass = PseudoClass.getPseudoClass(\"abc\");\n+\n+        int index = PseudoClassStateShim.pseudoClassMap.get(pseudoClass.getPseudoClassName());\n+\n+        set1.add(new StyleClass(\"xyz\", index));  \/\/ no idea why this is public API, but I'll take it\n+        set2.add(pseudoClass);\n+\n+        \/*\n+         * The two sets above contain elements of different types (PseudoClass and StyleClass)\n+         * and therefore should never be equal, despite their bit pattern being the same:\n+         *\/\n+\n+        assertNotEquals(set1, set2);\n+    }\n+\n+    @Test\n+    void shouldBeEqual() {\n+        StyleClassSet set1 = new StyleClassSet();\n+        StyleClassSet set2 = new StyleClassSet();\n+\n+        set1.add(StyleClassSet.getStyleClass(\"abc\"));\n+        set2.add(StyleClassSet.getStyleClass(\"abc\"));\n+\n+        assertEquals(set1, set2);\n+\n+        for (int i = 0; i < 1000; i++) {\n+            \/\/ grow internal bit set array:\n+            set1.add(StyleClassSet.getStyleClass(\"\" + i));\n+\n+            assertNotEquals(set1, set2);\n+        }\n+\n+        for (int i = 0; i < 1000; i++) {\n+            set1.remove(StyleClassSet.getStyleClass(\"\" + i));\n+        }\n+\n+        \/\/ still equal despite internal array sizes being different size:\n+        assertEquals(set1, set2);\n+    }\n+\n+    @Test\n+    void twoEmptyBitSetsShouldBeEqual() {\n+\n+        \/*\n+         * Per Set contract, the empty set is equal to any other empty set.\n+         *\/\n+\n+        assertEquals(new StyleClassSet(), new PseudoClassState());\n+        assertEquals(new PseudoClassState(), new StyleClassSet());\n+        assertEquals(Set.of(), new PseudoClassState());\n+        assertEquals(new PseudoClassState(), Set.of());\n+        assertEquals(Set.of(), new StyleClassSet());\n+        assertEquals(new StyleClassSet(), Set.of());\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/css\/BitSetTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+package test.com.sun.javafx.css;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import com.sun.javafx.css.ImmutablePseudoClassSetsCache;\n+import com.sun.javafx.css.PseudoClassState;\n+\n+import javafx.css.PseudoClass;\n+\n+public class ImmutablePseudoClassSetsCacheTest {\n+\n+    @Test\n+    void shouldCacheSets() {\n+        Set<PseudoClass> myOwnSet = Set.of(PseudoClass.getPseudoClass(\"a\"));\n+        Set<PseudoClass> pseudoClassState = new PseudoClassState();\n+\n+        pseudoClassState.add(PseudoClass.getPseudoClass(\"a\"));\n+\n+        Set<PseudoClass> set1 = ImmutablePseudoClassSetsCache.of(new HashSet<>(Set.of(PseudoClass.getPseudoClass(\"a\"))));\n+        Set<PseudoClass> set2 = ImmutablePseudoClassSetsCache.of(new HashSet<>(myOwnSet));\n+        Set<PseudoClass> set3 = ImmutablePseudoClassSetsCache.of(myOwnSet);\n+        Set<PseudoClass> set4 = ImmutablePseudoClassSetsCache.of(pseudoClassState);\n+        Set<PseudoClass> set5 = ImmutablePseudoClassSetsCache.of(Set.of(PseudoClass.getPseudoClass(\"b\")));\n+\n+        assertEquals(set1, set2);\n+        assertEquals(set2, set3);\n+        assertEquals(set3, set4);\n+        assertNotEquals(set1, set5);\n+        assertNotEquals(set2, set5);\n+        assertNotEquals(set3, set5);\n+        assertNotEquals(set4, set5);\n+\n+        assertTrue(set1 == set2);\n+        assertTrue(set2 == set3);\n+        assertTrue(set3 == set4);\n+\n+        assertEquals(myOwnSet, set1);\n+\n+        \/\/ this does not need to be true if this set was not the first one cached\n+        assertFalse(myOwnSet == set1);\n+\n+        \/\/ tests if hashCode\/equals of BitSet respects contract...\n+        assertEquals(myOwnSet.hashCode(), pseudoClassState.hashCode());\n+        assertTrue(myOwnSet.equals(pseudoClassState));\n+        assertTrue(pseudoClassState.equals(myOwnSet));\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/css\/ImmutablePseudoClassSetsCacheTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -612,7 +612,0 @@\n-        BitSetShim.retainAll(aStates, bStates);\n-        List<PseudoClass> states = new ArrayList<>();\n-        Iterator<PseudoClass> iter = BitSetShim.iterator(aStates);\n-        while (iter.hasNext()) {\n-            states.add(iter.next());\n-        }\n-        assertEquals(0, states.size(), 0.000001);\n@@ -620,0 +613,1 @@\n+        assertThrows(NullPointerException.class, () -> BitSetShim.retainAll(aStates, bStates));\n@@ -718,7 +712,0 @@\n-        BitSetShim.addAll(aStates, bStates);\n-        List<PseudoClass> states = new ArrayList<>();\n-        Iterator<PseudoClass> iter = BitSetShim.iterator(aStates);\n-        while (iter.hasNext()) {\n-            states.add(iter.next());\n-        }\n-        assertEquals(0, states.size(), 0.000001);\n@@ -726,0 +713,1 @@\n+        assertThrows(NullPointerException.class, () -> BitSetShim.addAll(aStates, bStates));\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/css\/PseudoClassTest.java","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"}]}