{"files":[{"patch":"@@ -69,0 +69,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -173,1 +174,1 @@\n-                        NodeHelper.traverse(gridPane, Direction.PREVIOUS);\n+                        NodeHelper.traverse(gridPane, Direction.PREVIOUS, TraversalMethod.DEFAULT);\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/DatePickerContent.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -181,2 +181,1 @@\n-        \/\/ if the button is not already focused, then request the focus\n-        if (! getNode().isFocused() && getNode().isFocusTraversable()) {\n+        if (getNode().isFocusTraversable()) {\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/ButtonBehavior.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -93,1 +94,1 @@\n-    public static void traverse(final Node node, final Direction dir) {\n+    public static void traverse(final Node node, final Direction dir, TraversalMethod method) {\n@@ -98,1 +99,1 @@\n-        NodeHelper.traverse(node, dir);\n+        NodeHelper.traverse(node, dir, method);\n@@ -106,1 +107,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.UP);\n+        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.UP, TraversalMethod.KEY);\n@@ -114,1 +115,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.DOWN);\n+        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.DOWN, TraversalMethod.KEY);\n@@ -122,1 +123,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.LEFT);\n+        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n@@ -130,1 +131,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.RIGHT);\n+        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n@@ -138,1 +139,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.NEXT);\n+        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.NEXT, TraversalMethod.KEY);\n@@ -146,1 +147,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.PREVIOUS);\n+        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.PREVIOUS, TraversalMethod.KEY);\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/FocusTraversalInputMap.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -112,2 +112,1 @@\n-        \/\/ If not already focused, request focus\n-        if (!slider.isFocused()) slider.requestFocus();\n+        slider.requestFocus();\n@@ -126,1 +125,0 @@\n-        \/\/ If not already focused, request focus\n@@ -128,1 +126,1 @@\n-        if (!slider.isFocused())  slider.requestFocus();\n+        slider.requestFocus();\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/SliderBehavior.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -107,1 +108,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS, TraversalMethod.KEY);\n@@ -110,1 +111,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT, TraversalMethod.KEY);\n@@ -115,1 +116,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP, TraversalMethod.KEY);\n@@ -119,1 +120,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN, TraversalMethod.KEY);\n@@ -123,1 +124,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n@@ -127,1 +128,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TwoLevelFocusBehavior.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -87,1 +88,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS, TraversalMethod.KEY);\n@@ -90,1 +91,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT, TraversalMethod.KEY);\n@@ -95,1 +96,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP, TraversalMethod.KEY);\n@@ -99,1 +100,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN, TraversalMethod.KEY);\n@@ -103,1 +104,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n@@ -107,1 +108,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TwoLevelFocusComboBehavior.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -89,1 +90,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS, TraversalMethod.KEY);\n@@ -92,1 +93,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT, TraversalMethod.KEY);\n@@ -97,1 +98,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP, TraversalMethod.KEY);\n@@ -101,1 +102,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN, TraversalMethod.KEY);\n@@ -105,1 +106,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n@@ -109,1 +110,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TwoLevelFocusListBehavior.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -108,1 +109,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS, TraversalMethod.KEY);\n@@ -111,1 +112,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT, TraversalMethod.KEY);\n@@ -116,1 +117,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP, TraversalMethod.KEY);\n@@ -120,1 +121,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN, TraversalMethod.KEY);\n@@ -124,1 +125,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n@@ -128,1 +129,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n@@ -168,1 +169,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n@@ -174,1 +175,1 @@\n-                                  NodeHelper.traverse(node, com.sun.javafx.scene.traversal.Direction.LEFT);\n+                                  NodeHelper.traverse(node, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n@@ -181,1 +182,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n@@ -187,1 +188,1 @@\n-                                  NodeHelper.traverse(node, com.sun.javafx.scene.traversal.Direction.RIGHT);\n+                                  NodeHelper.traverse(node, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TwoLevelFocusPopupBehavior.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1774,0 +1774,8 @@\n+        <th class=\"propertyname\" scope=\"row\">focus-visible<\/th>\n+          <td>applies when the <strong>focusVisible<\/strong> variable is true<\/td>\n+        <\/tr>\n+        <tr>\n+        <th class=\"propertyname\" scope=\"row\">focus-within<\/th>\n+          <td>applies when the <strong>focusWithin<\/strong> variable is true<\/td>\n+        <\/tr>\n+        <tr>\n","filename":"modules\/javafx.graphics\/src\/main\/docs\/javafx\/scene\/doc-files\/cssref.html","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -102,1 +103,1 @@\n-        if (NodeHelper.traverse(node, dir)) {\n+        if (NodeHelper.traverse(node, dir, TraversalMethod.KEY)) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/KeyboardShortcutsHandler.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -236,2 +237,2 @@\n-    public static boolean traverse(Node node, Direction direction) {\n-        return nodeAccessor.traverse(node, direction);\n+    public static boolean traverse(Node node, Direction direction, TraversalMethod method) {\n+        return nodeAccessor.traverse(node, direction, method);\n@@ -310,0 +311,4 @@\n+    public static void requestFocusVisible(Node node) {\n+        nodeAccessor.requestFocusVisible(node);\n+    }\n+\n@@ -349,1 +354,1 @@\n-        boolean traverse(Node node, Direction direction);\n+        boolean traverse(Node node, Direction direction, TraversalMethod method);\n@@ -369,0 +374,1 @@\n+        void requestFocusVisible(Node node);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/NodeHelper.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.scene.NodeHelper;\n@@ -67,0 +68,1 @@\n+     * @param method the traversal method\n@@ -69,1 +71,1 @@\n-    public final Node trav(Node node, Direction dir) {\n+    public final Node trav(Node node, Direction dir, TraversalMethod method) {\n@@ -104,1 +106,1 @@\n-            focusAndNotify(newNode);\n+            focusAndNotify(newNode, method);\n@@ -109,2 +111,7 @@\n-    private void focusAndNotify(Node newNode) {\n-        newNode.requestFocus();\n+    private void focusAndNotify(Node newNode, TraversalMethod method) {\n+        if (method == TraversalMethod.KEY) {\n+            NodeHelper.requestFocusVisible(newNode);\n+        } else {\n+            newNode.requestFocus();\n+        }\n+\n@@ -132,1 +139,1 @@\n-        if (n != null) focusAndNotify(n);\n+        if (n != null) focusAndNotify(n, TraversalMethod.DEFAULT);\n@@ -142,1 +149,1 @@\n-        if (n != null) focusAndNotify(n);\n+        if (n != null) focusAndNotify(n, TraversalMethod.DEFAULT);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/TopMostTraversalEngine.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene.traversal;\n+\n+\/**\n+ * Specifies the traversal method.\n+ *\/\n+public enum TraversalMethod {\n+    \/**\n+     * Traversal was initiated programmatically or by clicking.\n+     *\/\n+    DEFAULT,\n+\n+    \/**\n+     * Traversal was initiated by pressing a key on the keyboard.\n+     *\/\n+    KEY\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/TraversalMethod.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -525,2 +526,2 @@\n-            public boolean traverse(Node node, Direction direction) {\n-                return node.traverse(direction);\n+            public boolean traverse(Node node, Direction direction, TraversalMethod method) {\n+                return node.traverse(direction, method);\n@@ -622,0 +623,5 @@\n+\n+            @Override\n+            public void requestFocusVisible(Node node) {\n+                node.requestFocusVisible();\n+            }\n@@ -954,0 +960,1 @@\n+                        updateRemovedParentFocus(oldParent);\n@@ -8110,1 +8117,1 @@\n-    final class FocusedProperty extends ReadOnlyBooleanPropertyBase {\n+    abstract class FocusPropertyBase extends ReadOnlyBooleanPropertyBase {\n@@ -8112,2 +8119,1 @@\n-        private boolean valid = true;\n-        private boolean needsChangeEvent = false;\n+        private boolean lastNotifiedValue;\n@@ -8115,5 +8121,5 @@\n-        public void store(final boolean value) {\n-            if (value != this.value) {\n-                this.value = value;\n-                markInvalid();\n-            }\n+        protected abstract PseudoClass getPseudoClass();\n+\n+        @Override\n+        public Object getBean() {\n+            return Node.this;\n@@ -8122,5 +8128,3 @@\n-        public void notifyListeners() {\n-            if (needsChangeEvent) {\n-                fireValueChangedEvent();\n-                needsChangeEvent = false;\n-            }\n+        @Override\n+        public boolean get() {\n+            return value;\n@@ -8129,3 +8133,3 @@\n-        private void markInvalid() {\n-            if (valid) {\n-                valid = false;\n+        public void set(boolean value) {\n+            this.value = value;\n+        }\n@@ -8133,5 +8137,4 @@\n-                pseudoClassStateChanged(FOCUSED_PSEUDOCLASS_STATE, get());\n-                PlatformLogger logger = Logging.getFocusLogger();\n-                if (logger.isLoggable(Level.FINE)) {\n-                    logger.fine(this + \" focused=\" + get());\n-                }\n+        protected boolean notifyListeners() {\n+            if (lastNotifiedValue == value) {\n+                return false;\n+            }\n@@ -8139,1 +8142,2 @@\n-                needsChangeEvent = true;\n+            lastNotifiedValue = value;\n+            pseudoClassStateChanged(getPseudoClass(), value);\n@@ -8141,1 +8145,3 @@\n-                notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUSED);\n+            PlatformLogger logger = Logging.getFocusLogger();\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(this + \" \" + getName() + \"=\" + get());\n@@ -8143,1 +8149,0 @@\n-        }\n@@ -8145,4 +8150,2 @@\n-        @Override\n-        public boolean get() {\n-            valid = true;\n-            return value;\n+            fireValueChangedEvent();\n+            return true;\n@@ -8150,0 +8153,1 @@\n+    }\n@@ -8151,4 +8155,9 @@\n-        @Override\n-        public Object getBean() {\n-            return Node.this;\n-        }\n+    \/**\n+     * Sets the value of the {@link #focused} and {@link #focusVisible} properties\n+     * without firing change events. The value of {@link #focusWithin} is set\n+     * by the implementation of {@link #focused}.\n+     *\/\n+    final void setFocusQuietly(boolean focused, boolean focusVisible) {\n+        this.focused.set(focused);\n+        this.focusVisible.set(focused && focusVisible);\n+    }\n@@ -8156,3 +8165,31 @@\n-        @Override\n-        public String getName() {\n-            return \"focused\";\n+    \/**\n+     * Fires change notifications if the value of {@link #focused}, {@link #focusVisible}\n+     * or {@link #focusWithin} has changed. Change notifications for {@link #focusWithin}\n+     * are fired on the current node and on all of its parents, if necessary.\n+     *\/\n+    final void notifyFocusListeners() {\n+        focused.notifyListeners();\n+        focusVisible.notifyListeners();\n+\n+        Node node = this;\n+        do {\n+            node.focusWithin.notifyListeners();\n+            node = node.getParent();\n+        } while (node != null);\n+    }\n+\n+    \/**\n+     * Called when the current node was removed from the scene graph in order to clear\n+     * the focus bits of the former parents.\n+     *\/\n+    private void updateRemovedParentFocus(Node oldParent) {\n+        if (oldParent != null && focusWithin.get()) {\n+            Node node = oldParent;\n+            while (node != null) {\n+                node.focused.set(false);\n+                node.focusVisible.set(false);\n+                node.focusWithin.set(false);\n+                node = node.getParent();\n+            }\n+\n+            oldParent.notifyFocusListeners();\n@@ -8171,1 +8208,5 @@\n-    private FocusedProperty focused;\n+    private final FocusPropertyBase focused = new FocusPropertyBase() {\n+        @Override\n+        protected PseudoClass getPseudoClass() {\n+            return FOCUSED_PSEUDOCLASS_STATE;\n+        }\n@@ -8173,5 +8214,12 @@\n-    protected final void setFocused(boolean value) {\n-        FocusedProperty fp = focusedPropertyImpl();\n-        if (fp.value != value) {\n-            fp.store(value);\n-            fp.notifyListeners();\n+        @Override\n+        public String getName() {\n+            return \"focused\";\n+        }\n+\n+        @Override\n+        protected boolean notifyListeners() {\n+            if (super.notifyListeners()) {\n+                notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUSED);\n+                return true;\n+            }\n+            return false;\n@@ -8179,0 +8227,18 @@\n+\n+        @Override\n+        public void set(boolean value) {\n+            if (get() != value) {\n+                super.set(value);\n+\n+                Node node = Node.this;\n+                do {\n+                    node.focusWithin.set(value);\n+                    node = node.getParent();\n+                } while (node != null);\n+            }\n+        }\n+    };\n+\n+    protected final void setFocused(boolean value) {\n+        setFocusQuietly(value, false);\n+        notifyFocusListeners();\n@@ -8182,1 +8248,1 @@\n-        return focused == null ? false : focused.get();\n+        return focused.get();\n@@ -8186,1 +8252,1 @@\n-        return focusedPropertyImpl();\n+        return focused;\n@@ -8189,3 +8255,13 @@\n-    private FocusedProperty focusedPropertyImpl() {\n-        if (focused == null) {\n-            focused = new FocusedProperty();\n+    \/**\n+     * Indicates whether this {@code Node} should visibly indicate focus.\n+     * This flag is set when the node acquires input focus via keyboard navigation,\n+     * and it is cleared when the node loses focus, or when {@link #requestFocus()}\n+     * is called.\n+     *\n+     * @defaultValue false\n+     * @since 18\n+     *\/\n+    private final FocusPropertyBase focusVisible = new FocusPropertyBase() {\n+        @Override\n+        protected PseudoClass getPseudoClass() {\n+            return FOCUS_VISIBLE_PSEUDOCLASS_STATE;\n@@ -8193,1 +8269,40 @@\n-        return focused;\n+\n+        @Override\n+        public String getName() {\n+            return \"focusVisible\";\n+        }\n+    };\n+\n+    public final boolean isFocusVisible() {\n+        return focusVisible.get();\n+    }\n+\n+    public final ReadOnlyBooleanProperty focusVisibleProperty() {\n+        return focusVisible;\n+    }\n+\n+    \/**\n+     * Indicates whether this {@code Node} or any of its children currently\n+     * has the input focus.\n+     *\n+     * @defaultValue false\n+     * @since 18\n+     *\/\n+    private final FocusPropertyBase focusWithin = new FocusPropertyBase() {\n+        @Override\n+        protected PseudoClass getPseudoClass() {\n+            return FOCUS_WITHIN_PSEUDOCLASS_STATE;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return \"focusWithin\";\n+        }\n+    };\n+\n+    public final boolean isFocusWithin() {\n+        return focusWithin.get();\n+    }\n+\n+    public final ReadOnlyBooleanProperty focusWithinProperty() {\n+        return focusWithin;\n@@ -8282,0 +8397,1 @@\n+     * <p>This method will clear the {@link #focusVisible} flag.\n@@ -8285,1 +8401,11 @@\n-            getScene().requestFocus(this);\n+            getScene().requestFocus(this, false);\n+        }\n+    }\n+\n+    \/**\n+     * Requests focus as if by calling {@link #requestFocus()}, and additionally\n+     * sets the {@link #focusVisible} flag.\n+     *\/\n+    private void requestFocusVisible() {\n+        if (getScene() != null) {\n+            getScene().requestFocus(this, true);\n@@ -8295,1 +8421,1 @@\n-    final boolean traverse(Direction dir) {\n+    final boolean traverse(Direction dir, TraversalMethod method) {\n@@ -8299,1 +8425,1 @@\n-        return getScene().traverse(this, dir);\n+        return getScene().traverse(this, dir, method);\n@@ -9590,0 +9716,2 @@\n+    private static final PseudoClass FOCUS_VISIBLE_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(\"focus-visible\");\n+    private static final PseudoClass FOCUS_WITHIN_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(\"focus-within\");\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Node.java","additions":180,"deletions":52,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -2093,1 +2094,1 @@\n-    boolean traverse(Node node, Direction dir) {\n+    boolean traverse(Node node, Direction dir, TraversalMethod method) {\n@@ -2095,1 +2096,1 @@\n-            return node.getSubScene().traverse(node, dir);\n+            return node.getSubScene().traverse(node, dir, method);\n@@ -2097,1 +2098,1 @@\n-        return traversalEngine.trav(node, dir) != null;\n+        return traversalEngine.trav(node, dir, method) != null;\n@@ -2116,1 +2117,1 @@\n-        traverse(node, Direction.NEXT);\n+        traverse(node, Direction.NEXT, TraversalMethod.DEFAULT);\n@@ -2129,2 +2130,2 @@\n-    void requestFocus(Node node) {\n-        getKeyHandler().requestFocus(node);\n+    void requestFocus(Node node, boolean focusVisible) {\n+        getKeyHandler().requestFocus(node, focusVisible);\n@@ -2146,1 +2147,1 @@\n-                ((Node.FocusedProperty) oldFocusOwner.focusedProperty()).store(false);\n+                oldFocusOwner.setFocusQuietly(false, false);\n@@ -2150,1 +2151,1 @@\n-                ((Node.FocusedProperty) value.focusedProperty()).store(keyHandler.windowFocused);\n+                value.setFocusQuietly(keyHandler.windowFocused, keyHandler.focusVisible);\n@@ -2163,1 +2164,1 @@\n-                ((Node.FocusedProperty) localOldOwner.focusedProperty()).notifyListeners();\n+                localOldOwner.notifyFocusListeners();\n@@ -2166,1 +2167,1 @@\n-                ((Node.FocusedProperty) value.focusedProperty()).notifyListeners();\n+                value.notifyFocusListeners();\n@@ -2440,1 +2441,1 @@\n-                    Scene.this.requestFocus(null);\n+                    Scene.this.requestFocus(null, false);\n@@ -2443,1 +2444,1 @@\n-                    Scene.this.requestFocus(null);\n+                    Scene.this.requestFocus(null, false);\n@@ -4016,0 +4017,2 @@\n+        boolean focusVisible;\n+\n@@ -4032,0 +4035,6 @@\n+        private void setFocusVisible(Node node, boolean focusVisible) {\n+            Node.FocusPropertyBase property = (Node.FocusPropertyBase)node.focusVisibleProperty();\n+            property.set(focusVisible);\n+            property.notifyListeners();\n+        }\n+\n@@ -4037,1 +4046,2 @@\n-                getFocusOwner().setFocused(windowFocused);\n+                getFocusOwner().setFocusQuietly(windowFocused, focusVisible);\n+                getFocusOwner().notifyFocusListeners();\n@@ -4072,3 +4082,10 @@\n-        private void requestFocus(Node node) {\n-            if (getFocusOwner() == node || (node != null && !node.isCanReceiveFocus())) {\n-                return;\n+        private void requestFocus(Node node, boolean focusVisible) {\n+            if (node == null) {\n+                setFocusOwner(null);\n+            } else if (node.isCanReceiveFocus()) {\n+                if (node != getFocusOwner()) {\n+                    this.focusVisible = focusVisible;\n+                    setFocusOwner(node);\n+                } else {\n+                    setFocusVisible(node, focusVisible);\n+                }\n@@ -4076,1 +4093,0 @@\n-            setFocusOwner(node);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":33,"deletions":17,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -759,2 +760,2 @@\n-    boolean traverse(Node node, Direction dir) {\n-        return traversalEngine.trav(node, dir) != null;\n+    boolean traverse(Node node, Direction dir, TraversalMethod method) {\n+        return traversalEngine.trav(node, dir, method) != null;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/SubScene.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -262,1 +263,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT));\n+        assertEquals(n2, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n@@ -274,1 +275,1 @@\n-        assertEquals(ng1, engine.trav(n1, Direction.NEXT));\n+        assertEquals(ng1, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n@@ -285,1 +286,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT));\n+        assertEquals(n2, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n@@ -296,1 +297,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT));\n+        assertEquals(n2, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n@@ -307,1 +308,1 @@\n-        assertEquals(g, engine.trav(n1, Direction.NEXT));\n+        assertEquals(g, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n@@ -337,1 +338,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT));\n+        assertEquals(n2, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n@@ -370,1 +371,1 @@\n-        assertEquals(n3, engine.trav(n1, Direction.NEXT));\n+        assertEquals(n3, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n@@ -382,1 +383,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT_IN_LINE));\n+        assertEquals(n2, engine.trav(n1, Direction.NEXT_IN_LINE, TraversalMethod.DEFAULT));\n@@ -394,1 +395,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS));\n+        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n@@ -406,1 +407,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS));\n+        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n@@ -417,1 +418,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS));\n+        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n@@ -429,1 +430,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS));\n+        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n@@ -441,1 +442,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS));\n+        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n@@ -453,1 +454,1 @@\n-        assertEquals(g, engine.trav(n2, Direction.PREVIOUS));\n+        assertEquals(g, engine.trav(n2, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n@@ -463,1 +464,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT));\n+        assertEquals(n2, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n@@ -474,1 +475,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS));\n+        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n@@ -505,1 +506,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS));\n+        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/traversal\/TopMostTraversalEngineTest.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -184,1 +185,1 @@\n-        traversalEngine.trav(keypadNodes[fromNumber - 1], direction);\n+        traversalEngine.trav(keypadNodes[fromNumber - 1], direction, TraversalMethod.DEFAULT);\n@@ -192,1 +193,1 @@\n-        traversalEngine.trav(keypadNodes[fromNumber - 1], direction);\n+        traversalEngine.trav(keypadNodes[fromNumber - 1], direction, TraversalMethod.DEFAULT);\n@@ -202,1 +203,1 @@\n-        traversalEngine.trav(keypadNodes[fromNumber - 1], direction);\n+        traversalEngine.trav(keypadNodes[fromNumber - 1], direction, TraversalMethod.DEFAULT);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/traversal\/TraversalTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -127,1 +128,1 @@\n-        traversalEngine.trav(keypadNodes[fromNumber], direction);\n+        traversalEngine.trav(keypadNodes[fromNumber], direction, TraversalMethod.DEFAULT);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/traversal\/TraverseInvisibleTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import javafx.event.Event;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.KeyEvent;\n@@ -42,4 +45,1 @@\n-import javafx.beans.InvalidationListener;\n-import javafx.beans.Observable;\n-import javafx.beans.value.ChangeListener;\n-import javafx.beans.value.ObservableValue;\n+\n@@ -116,0 +116,1 @@\n+        assertTrue(n.getPseudoClassStates().stream().anyMatch(pc -> pc.getPseudoClassName().equals(\"focused\")));\n@@ -121,0 +122,1 @@\n+        assertFalse(n.getPseudoClassStates().stream().anyMatch(pc -> pc.getPseudoClassName().equals(\"focused\")));\n@@ -127,0 +129,36 @@\n+    private void assertIsFocusVisible(Node n) {\n+        assertTrue(n.isFocusVisible());\n+        assertTrue(n.getPseudoClassStates().stream().anyMatch(pc -> pc.getPseudoClassName().equals(\"focus-visible\")));\n+    }\n+\n+    private void assertNotFocusVisible(Node n) {\n+        assertFalse(n.isFocusVisible());\n+        assertFalse(n.getPseudoClassStates().stream().anyMatch(pc -> pc.getPseudoClassName().equals(\"focus-visible\")));\n+    }\n+\n+    private void assertIsFocusWithin(Node n) {\n+        assertTrue(n.isFocusWithin());\n+        assertTrue(n.getPseudoClassStates().stream().anyMatch(pc -> pc.getPseudoClassName().equals(\"focus-within\")));\n+    }\n+\n+    private void assertNotFocusWithin(Node n) {\n+        assertFalse(n.isFocusWithin());\n+        assertFalse(n.getPseudoClassStates().stream().anyMatch(pc -> pc.getPseudoClassName().equals(\"focus-within\")));\n+    }\n+\n+    private void assertIsFocusWithinParents(Node n) {\n+        do {\n+            assertTrue(n.isFocusWithin());\n+            assertTrue(n.getPseudoClassStates().stream().anyMatch(pc -> pc.getPseudoClassName().equals(\"focus-within\")));\n+            n = n.getParent();\n+        } while (n != null);\n+    }\n+\n+    private void assertNotFocusWithinParents(Node n) {\n+        do {\n+            assertFalse(n.isFocusWithin());\n+            assertFalse(n.getPseudoClassStates().stream().anyMatch(pc -> pc.getPseudoClassName().equals(\"focus-within\")));\n+            n = n.getParent();\n+        } while (n != null);\n+    }\n+\n@@ -735,2 +773,162 @@\n-    \/\/ TODO: tests for moving nodes between scenes\n-    \/\/ and active and inactive stages\n+    private void fireTabKeyEvent(Node node) {\n+        Event.fireEvent(node, new KeyEvent(KeyEvent.KEY_PRESSED, null, null, KeyCode.TAB, false, false, false, false));\n+        Event.fireEvent(node, new KeyEvent(KeyEvent.KEY_RELEASED, null, null, KeyCode.TAB, false, false, false, false));\n+    }\n+\n+    \/**\n+     * If a node acquires focus by calling {@link Node#requestFocus()}, it does not acquire visible focus.\n+     *\/\n+    @Test public void testDefaultFocusTraversalDoesNotSetFocusVisible() {\n+        Node node = n();\n+        scene.setRoot(new Group(node));\n+\n+        assertNotFocused(scene, node);\n+        assertNotFocusVisible(node);\n+\n+        node.requestFocus();\n+\n+        assertIsFocused(scene, node);\n+        assertNotFocusVisible(node);\n+    }\n+\n+    \/**\n+     * If a node acquires focus when the TAB key is pressed, it also acquires visible focus.\n+     *\/\n+    @Test public void testKeyFocusTraversalSetsFocusVisible() {\n+        Node node = n();\n+        Group g = new Group(node);\n+        scene.setRoot(g);\n+\n+        assertNotFocused(scene, node);\n+        assertNotFocusVisible(node);\n+\n+        fireTabKeyEvent(g);\n+\n+        assertIsFocused(scene, node);\n+        assertIsFocusVisible(node);\n+    }\n+\n+    \/**\n+     * If {@link Node#requestFocus()} is called on a node that has acquired visible focus,\n+     * visible focus is removed from the node.\n+     *\/\n+    @Test public void testFocusVisibleIsRemovedByDefaultRequestFocus() {\n+        Node node = n();\n+        Group g = new Group(node);\n+        scene.setRoot(g);\n+        fireTabKeyEvent(g);\n+\n+        assertIsFocused(scene, node);\n+        assertIsFocusVisible(node);\n+\n+        node.requestFocus();\n+\n+        assertIsFocused(scene, node);\n+        assertNotFocusVisible(node);\n+    }\n+\n+    \/**\n+     * When a node loses focus, it also loses visible focus.\n+     *\/\n+    @Test public void testVisibleFocusIsRemovedWhenFocusIsRemoved() {\n+        Node node1 = n();\n+        Node node2 = n();\n+        Group g = new Group(node1, node2);\n+        scene.setRoot(g);\n+        fireTabKeyEvent(g);\n+\n+        assertIsFocused(scene, node1);\n+        assertIsFocusVisible(node1);\n+\n+        node2.requestFocus();\n+\n+        assertNotFocused(scene, node1);\n+        assertNotFocusVisible(node1);\n+    }\n+\n+    \/**\n+     * When a node acquires focus, the focusWithin property is set on the node\n+     * and all of its parents.\n+     *\/\n+    @Test public void testFocusWithinIsTrueOnAllParents() {\n+        Node node1 = n();\n+        Group g = new Group(new Group(new Group(node1)));\n+        scene.setRoot(g);\n+\n+        assertNotFocusWithinParents(node1);\n+\n+        node1.requestFocus();\n+\n+        assertIsFocusWithinParents(node1);\n+    }\n+\n+    \/**\n+     * When a node loses focus, the focusWithin property of its parents is cleared.\n+     *\/\n+    @Test public void testFocusWithinIsRemovedFromParentsAfterChangingFocusOwner() {\n+        Node node1 = n(), node2 = n();\n+        Group g = new Group(new Group(new Group(node1)), new Group(new Group(node2)));\n+        scene.setRoot(g);\n+\n+        assertNotFocusWithinParents(node1);\n+        assertNotFocusWithinParents(node2);\n+\n+        node1.requestFocus();\n+\n+        assertIsFocusWithinParents(node1);\n+        assertNotFocusWithin(node2);\n+        assertNotFocusWithin(node2.getParent());\n+        assertNotFocusWithin(node2.getParent().getParent());\n+\n+        node2.requestFocus();\n+\n+        assertIsFocusWithinParents(node2);\n+        assertNotFocusWithin(node1);\n+        assertNotFocusWithin(node1.getParent());\n+        assertNotFocusWithin(node1.getParent().getParent());\n+    }\n+\n+    \/**\n+     * When a node loses focus, all of its parents also lose focusWithin.\n+     * However, if focus transitions to a new node, and the new node is also a child of the\n+     * parent that just lost focusWithin, the parent will re-gain focusWithin.\n+     *\n+     * Since focus traversal is specified to be an atomic operation, the fact that\n+     * the parent technically lost and re-gained focusWithin must not be observable.\n+     *\/\n+    @Test public void testFocusWithinListenerIsNotInvokedIfPropertyDidNotEffectivelyChange() {\n+        Node node1 = n(), node2 = n();\n+        Group g = new Group(new Group(new Group(node1)), new Group(new Group(node2)));\n+        scene.setRoot(g);\n+\n+        List<Boolean> focusWithinValues = new ArrayList<>();\n+        g.focusWithinProperty().addListener((observable, oldValue, newValue) -> focusWithinValues.add(newValue));\n+\n+        node1.requestFocus();\n+        assertEquals(1, focusWithinValues.size());\n+        assertEquals(Boolean.TRUE, focusWithinValues.get(0));\n+\n+        node2.requestFocus();\n+        assertEquals(1, focusWithinValues.size());\n+        assertEquals(Boolean.TRUE, focusWithinValues.get(0));\n+    }\n+\n+    \/**\n+     * When a focused node is removed from the scene graph, the focus states\n+     * of its former parents are cleared.\n+     *\/\n+    @Test public void testFocusStatesAreClearedFromFormerParentsOfFocusedNode() {\n+        Node node1 = n(), node2 = n();\n+        Group g2, g3, g1 = new Group(g2 = new Group(g3 = new Group(node1)), new Group(new Group(node2)));\n+        scene.setRoot(g1);\n+\n+        node1.requestFocus();\n+        assertIsFocusWithin(g1);\n+        assertIsFocusWithin(g2);\n+        assertIsFocusWithin(g3);\n+\n+        g2.getChildren().remove(0);\n+        assertNotFocusWithin(g1);\n+        assertNotFocusWithin(g2);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/FocusTest.java","additions":204,"deletions":6,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -117,1 +118,1 @@\n-        NodeHelper.traverse(accessor.getView(), forward ? Direction.NEXT : Direction.PREVIOUS);\n+        NodeHelper.traverse(accessor.getView(), forward ? Direction.NEXT : Direction.PREVIOUS, TraversalMethod.DEFAULT);\n","filename":"modules\/javafx.web\/src\/main\/java\/com\/sun\/javafx\/webkit\/WebPageClientImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}