{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -173,1 +174,1 @@\n-                        NodeHelper.traverse(gridPane, Direction.PREVIOUS);\n+                        NodeHelper.traverse(gridPane, Direction.PREVIOUS, TraversalMethod.DEFAULT);\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/DatePickerContent.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,2 +181,1 @@\n-        \/\/ if the button is not already focused, then request the focus\n-        if (! getNode().isFocused() && getNode().isFocusTraversable()) {\n+        if (getNode().isFocusTraversable()) {\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/ButtonBehavior.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -89,0 +90,1 @@\n+     * @param method The focus traversal method\n@@ -90,1 +92,1 @@\n-    public static void traverse(final Node node, final Direction dir) {\n+    public static void traverse(final Node node, final Direction dir, TraversalMethod method) {\n@@ -95,1 +97,1 @@\n-        NodeHelper.traverse(node, dir);\n+        NodeHelper.traverse(node, dir, method);\n@@ -103,1 +105,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.UP);\n+        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.UP, TraversalMethod.KEY);\n@@ -111,1 +113,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.DOWN);\n+        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.DOWN, TraversalMethod.KEY);\n@@ -119,1 +121,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.LEFT);\n+        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n@@ -127,1 +129,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.RIGHT);\n+        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n@@ -135,1 +137,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.NEXT);\n+        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.NEXT, TraversalMethod.KEY);\n@@ -143,1 +145,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.PREVIOUS);\n+        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.PREVIOUS, TraversalMethod.KEY);\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/FocusTraversalInputMap.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,2 +112,1 @@\n-        \/\/ If not already focused, request focus\n-        if (!slider.isFocused()) slider.requestFocus();\n+        slider.requestFocus();\n@@ -126,1 +125,0 @@\n-        \/\/ If not already focused, request focus\n@@ -128,1 +126,1 @@\n-        if (!slider.isFocused())  slider.requestFocus();\n+        slider.requestFocus();\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/SliderBehavior.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -107,1 +108,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS, TraversalMethod.KEY);\n@@ -110,1 +111,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT, TraversalMethod.KEY);\n@@ -115,1 +116,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP, TraversalMethod.KEY);\n@@ -119,1 +120,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN, TraversalMethod.KEY);\n@@ -123,1 +124,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n@@ -127,1 +128,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TwoLevelFocusBehavior.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -87,1 +88,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS, TraversalMethod.KEY);\n@@ -90,1 +91,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT, TraversalMethod.KEY);\n@@ -95,1 +96,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP, TraversalMethod.KEY);\n@@ -99,1 +100,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN, TraversalMethod.KEY);\n@@ -103,1 +104,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n@@ -107,1 +108,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TwoLevelFocusComboBehavior.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -89,1 +90,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS, TraversalMethod.KEY);\n@@ -92,1 +93,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT, TraversalMethod.KEY);\n@@ -97,1 +98,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP, TraversalMethod.KEY);\n@@ -101,1 +102,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN, TraversalMethod.KEY);\n@@ -105,1 +106,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n@@ -109,1 +110,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TwoLevelFocusListBehavior.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -108,1 +109,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS, TraversalMethod.KEY);\n@@ -111,1 +112,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT, TraversalMethod.KEY);\n@@ -116,1 +117,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP, TraversalMethod.KEY);\n@@ -120,1 +121,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN, TraversalMethod.KEY);\n@@ -124,1 +125,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n@@ -128,1 +129,1 @@\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT);\n+                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n@@ -168,1 +169,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n@@ -174,1 +175,1 @@\n-                                  NodeHelper.traverse(node, com.sun.javafx.scene.traversal.Direction.LEFT);\n+                                  NodeHelper.traverse(node, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n@@ -181,1 +182,1 @@\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT);\n+                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n@@ -187,1 +188,1 @@\n-                                  NodeHelper.traverse(node, com.sun.javafx.scene.traversal.Direction.RIGHT);\n+                                  NodeHelper.traverse(node, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TwoLevelFocusPopupBehavior.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1781,0 +1781,8 @@\n+        <th class=\"propertyname\" scope=\"row\">focus-visible<\/th>\n+          <td>applies when the <strong>focusVisible<\/strong> variable is true<\/td>\n+        <\/tr>\n+        <tr>\n+        <th class=\"propertyname\" scope=\"row\">focus-within<\/th>\n+          <td>applies when the <strong>focusWithin<\/strong> variable is true<\/td>\n+        <\/tr>\n+        <tr>\n","filename":"modules\/javafx.graphics\/src\/main\/docs\/javafx\/scene\/doc-files\/cssref.html","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -102,1 +103,1 @@\n-        if (NodeHelper.traverse(node, dir)) {\n+        if (NodeHelper.traverse(node, dir, TraversalMethod.KEY)) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/KeyboardShortcutsHandler.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -236,2 +237,2 @@\n-    public static boolean traverse(Node node, Direction direction) {\n-        return nodeAccessor.traverse(node, direction);\n+    public static boolean traverse(Node node, Direction direction, TraversalMethod method) {\n+        return nodeAccessor.traverse(node, direction, method);\n@@ -310,0 +311,4 @@\n+    public static void requestFocusVisible(Node node) {\n+        nodeAccessor.requestFocusVisible(node);\n+    }\n+\n@@ -349,1 +354,1 @@\n-        boolean traverse(Node node, Direction direction);\n+        boolean traverse(Node node, Direction direction, TraversalMethod method);\n@@ -369,0 +374,1 @@\n+        void requestFocusVisible(Node node);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/NodeHelper.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.scene.NodeHelper;\n@@ -67,0 +68,1 @@\n+     * @param method the traversal method\n@@ -69,1 +71,1 @@\n-    public final Node trav(Node node, Direction dir) {\n+    public final Node trav(Node node, Direction dir, TraversalMethod method) {\n@@ -104,1 +106,1 @@\n-            focusAndNotify(newNode);\n+            focusAndNotify(newNode, method);\n@@ -109,2 +111,7 @@\n-    private void focusAndNotify(Node newNode) {\n-        newNode.requestFocus();\n+    private void focusAndNotify(Node newNode, TraversalMethod method) {\n+        if (method == TraversalMethod.KEY) {\n+            NodeHelper.requestFocusVisible(newNode);\n+        } else {\n+            newNode.requestFocus();\n+        }\n+\n@@ -132,1 +139,1 @@\n-        if (n != null) focusAndNotify(n);\n+        if (n != null) focusAndNotify(n, TraversalMethod.DEFAULT);\n@@ -142,1 +149,1 @@\n-        if (n != null) focusAndNotify(n);\n+        if (n != null) focusAndNotify(n, TraversalMethod.DEFAULT);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/TopMostTraversalEngine.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene.traversal;\n+\n+\/**\n+ * Specifies the traversal method.\n+ *\/\n+public enum TraversalMethod {\n+    \/**\n+     * Traversal was initiated programmatically or by clicking.\n+     *\/\n+    DEFAULT,\n+\n+    \/**\n+     * Traversal was initiated by pressing a key on the keyboard.\n+     *\/\n+    KEY\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/TraversalMethod.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -525,2 +526,2 @@\n-            public boolean traverse(Node node, Direction direction) {\n-                return node.traverse(direction);\n+            public boolean traverse(Node node, Direction direction, TraversalMethod method) {\n+                return node.traverse(direction, method);\n@@ -622,0 +623,5 @@\n+\n+            @Override\n+            public void requestFocusVisible(Node node) {\n+                node.requestFocusVisible();\n+            }\n@@ -954,0 +960,1 @@\n+                        updateRemovedParentFocus(oldParent);\n@@ -8115,1 +8122,1 @@\n-    final class FocusedProperty extends ReadOnlyBooleanPropertyBase {\n+    abstract class FocusPropertyBase extends ReadOnlyBooleanPropertyBase {\n@@ -8117,2 +8124,1 @@\n-        private boolean valid = true;\n-        private boolean needsChangeEvent = false;\n+        private boolean lastNotifiedValue;\n@@ -8120,5 +8126,5 @@\n-        public void store(final boolean value) {\n-            if (value != this.value) {\n-                this.value = value;\n-                markInvalid();\n-            }\n+        protected abstract PseudoClass getPseudoClass();\n+\n+        @Override\n+        public Object getBean() {\n+            return Node.this;\n@@ -8127,5 +8133,3 @@\n-        public void notifyListeners() {\n-            if (needsChangeEvent) {\n-                fireValueChangedEvent();\n-                needsChangeEvent = false;\n-            }\n+        @Override\n+        public boolean get() {\n+            return value;\n@@ -8134,3 +8138,3 @@\n-        private void markInvalid() {\n-            if (valid) {\n-                valid = false;\n+        public void set(boolean value) {\n+            this.value = value;\n+        }\n@@ -8138,5 +8142,4 @@\n-                pseudoClassStateChanged(FOCUSED_PSEUDOCLASS_STATE, get());\n-                PlatformLogger logger = Logging.getFocusLogger();\n-                if (logger.isLoggable(Level.FINE)) {\n-                    logger.fine(this + \" focused=\" + get());\n-                }\n+        protected boolean notifyListeners() {\n+            if (lastNotifiedValue == value) {\n+                return false;\n+            }\n@@ -8144,1 +8147,2 @@\n-                needsChangeEvent = true;\n+            lastNotifiedValue = value;\n+            pseudoClassStateChanged(getPseudoClass(), value);\n@@ -8146,1 +8150,3 @@\n-                notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUSED);\n+            PlatformLogger logger = Logging.getFocusLogger();\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(this + \" \" + getName() + \"=\" + get());\n@@ -8148,1 +8154,0 @@\n-        }\n@@ -8150,4 +8155,2 @@\n-        @Override\n-        public boolean get() {\n-            valid = true;\n-            return value;\n+            fireValueChangedEvent();\n+            return true;\n@@ -8155,0 +8158,1 @@\n+    }\n@@ -8156,4 +8160,9 @@\n-        @Override\n-        public Object getBean() {\n-            return Node.this;\n-        }\n+    \/**\n+     * Sets the value of the {@link #focused} and {@link #focusVisible} properties\n+     * without firing change events. The value of {@link #focusWithin} is set\n+     * by the implementation of {@link #focused}.\n+     *\/\n+    final void setFocusQuietly(boolean focused, boolean focusVisible) {\n+        this.focused.set(focused);\n+        this.focusVisible.set(focused && focusVisible);\n+    }\n@@ -8161,3 +8170,31 @@\n-        @Override\n-        public String getName() {\n-            return \"focused\";\n+    \/**\n+     * Fires change notifications if the value of {@link #focused}, {@link #focusVisible}\n+     * or {@link #focusWithin} has changed. Change notifications for {@link #focusWithin}\n+     * are fired on the current node and on all of its parents, if necessary.\n+     *\/\n+    final void notifyFocusListeners() {\n+        focused.notifyListeners();\n+        focusVisible.notifyListeners();\n+\n+        Node node = this;\n+        do {\n+            node.focusWithin.notifyListeners();\n+            node = node.getParent();\n+        } while (node != null);\n+    }\n+\n+    \/**\n+     * Called when the current node was removed from the scene graph in order to clear\n+     * the focus bits of the former parents.\n+     *\/\n+    private void updateRemovedParentFocus(Node oldParent) {\n+        if (oldParent != null && focusWithin.get()) {\n+            Node node = oldParent;\n+            while (node != null) {\n+                node.focused.set(false);\n+                node.focusVisible.set(false);\n+                node.focusWithin.set(false);\n+                node = node.getParent();\n+            }\n+\n+            oldParent.notifyFocusListeners();\n@@ -8176,1 +8213,5 @@\n-    private FocusedProperty focused;\n+    private final FocusPropertyBase focused = new FocusPropertyBase() {\n+        @Override\n+        protected PseudoClass getPseudoClass() {\n+            return FOCUSED_PSEUDOCLASS_STATE;\n+        }\n@@ -8178,5 +8219,12 @@\n-    protected final void setFocused(boolean value) {\n-        FocusedProperty fp = focusedPropertyImpl();\n-        if (fp.value != value) {\n-            fp.store(value);\n-            fp.notifyListeners();\n+        @Override\n+        public String getName() {\n+            return \"focused\";\n+        }\n+\n+        @Override\n+        protected boolean notifyListeners() {\n+            if (super.notifyListeners()) {\n+                notifyAccessibleAttributeChanged(AccessibleAttribute.FOCUSED);\n+                return true;\n+            }\n+            return false;\n@@ -8184,0 +8232,18 @@\n+\n+        @Override\n+        public void set(boolean value) {\n+            if (get() != value) {\n+                super.set(value);\n+\n+                Node node = Node.this;\n+                do {\n+                    node.focusWithin.set(value);\n+                    node = node.getParent();\n+                } while (node != null);\n+            }\n+        }\n+    };\n+\n+    protected final void setFocused(boolean value) {\n+        setFocusQuietly(value, false);\n+        notifyFocusListeners();\n@@ -8187,1 +8253,1 @@\n-        return focused == null ? false : focused.get();\n+        return focused.get();\n@@ -8191,1 +8257,1 @@\n-        return focusedPropertyImpl();\n+        return focused;\n@@ -8194,3 +8260,13 @@\n-    private FocusedProperty focusedPropertyImpl() {\n-        if (focused == null) {\n-            focused = new FocusedProperty();\n+    \/**\n+     * Indicates whether this {@code Node} should visibly indicate focus.\n+     * This flag is set when the node acquires input focus via keyboard navigation,\n+     * and it is cleared when the node loses focus or when {@link #requestFocus()}\n+     * is called.\n+     *\n+     * @defaultValue false\n+     * @since 19\n+     *\/\n+    final FocusPropertyBase focusVisible = new FocusPropertyBase() {\n+        @Override\n+        protected PseudoClass getPseudoClass() {\n+            return FOCUS_VISIBLE_PSEUDOCLASS_STATE;\n@@ -8198,1 +8274,40 @@\n-        return focused;\n+\n+        @Override\n+        public String getName() {\n+            return \"focusVisible\";\n+        }\n+    };\n+\n+    public final boolean isFocusVisible() {\n+        return focusVisible.get();\n+    }\n+\n+    public final ReadOnlyBooleanProperty focusVisibleProperty() {\n+        return focusVisible;\n+    }\n+\n+    \/**\n+     * Indicates whether this {@code Node} or any of its descendants currently\n+     * has the input focus.\n+     *\n+     * @defaultValue false\n+     * @since 19\n+     *\/\n+    private final FocusPropertyBase focusWithin = new FocusPropertyBase() {\n+        @Override\n+        protected PseudoClass getPseudoClass() {\n+            return FOCUS_WITHIN_PSEUDOCLASS_STATE;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return \"focusWithin\";\n+        }\n+    };\n+\n+    public final boolean isFocusWithin() {\n+        return focusWithin.get();\n+    }\n+\n+    public final ReadOnlyBooleanProperty focusWithinProperty() {\n+        return focusWithin;\n@@ -8287,0 +8402,1 @@\n+     * <p>This method will clear the {@link #focusVisible} flag.\n@@ -8290,1 +8406,11 @@\n-            getScene().requestFocus(this);\n+            getScene().requestFocus(this, false);\n+        }\n+    }\n+\n+    \/**\n+     * Requests focus as if by calling {@link #requestFocus()}, and additionally\n+     * sets the {@link #focusVisible} flag.\n+     *\/\n+    private void requestFocusVisible() {\n+        if (getScene() != null) {\n+            getScene().requestFocus(this, true);\n@@ -8300,1 +8426,1 @@\n-    final boolean traverse(Direction dir) {\n+    final boolean traverse(Direction dir, TraversalMethod method) {\n@@ -8304,1 +8430,1 @@\n-        return getScene().traverse(this, dir);\n+        return getScene().traverse(this, dir, method);\n@@ -9611,0 +9737,2 @@\n+    private static final PseudoClass FOCUS_VISIBLE_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(\"focus-visible\");\n+    private static final PseudoClass FOCUS_WITHIN_PSEUDOCLASS_STATE = PseudoClass.getPseudoClass(\"focus-within\");\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Node.java","additions":181,"deletions":53,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -2113,1 +2114,1 @@\n-    boolean traverse(Node node, Direction dir) {\n+    boolean traverse(Node node, Direction dir, TraversalMethod method) {\n@@ -2115,1 +2116,1 @@\n-            return node.getSubScene().traverse(node, dir);\n+            return node.getSubScene().traverse(node, dir, method);\n@@ -2117,1 +2118,1 @@\n-        return traversalEngine.trav(node, dir) != null;\n+        return traversalEngine.trav(node, dir, method) != null;\n@@ -2136,1 +2137,1 @@\n-        traverse(node, Direction.NEXT);\n+        traverse(node, Direction.NEXT, TraversalMethod.DEFAULT);\n@@ -2149,2 +2150,2 @@\n-    void requestFocus(Node node) {\n-        getKeyHandler().requestFocus(node);\n+    void requestFocus(Node node, boolean focusVisible) {\n+        getKeyHandler().requestFocus(node, focusVisible);\n@@ -2166,1 +2167,1 @@\n-                ((Node.FocusedProperty) oldFocusOwner.focusedProperty()).store(false);\n+                oldFocusOwner.setFocusQuietly(false, false);\n@@ -2170,1 +2171,1 @@\n-                ((Node.FocusedProperty) value.focusedProperty()).store(keyHandler.windowFocused);\n+                value.setFocusQuietly(keyHandler.windowFocused, keyHandler.focusVisible);\n@@ -2183,1 +2184,1 @@\n-                ((Node.FocusedProperty) localOldOwner.focusedProperty()).notifyListeners();\n+                localOldOwner.notifyFocusListeners();\n@@ -2186,1 +2187,1 @@\n-                ((Node.FocusedProperty) value.focusedProperty()).notifyListeners();\n+                value.notifyFocusListeners();\n@@ -2460,1 +2461,1 @@\n-                    Scene.this.requestFocus(null);\n+                    Scene.this.requestFocus(null, false);\n@@ -2463,1 +2464,1 @@\n-                    Scene.this.requestFocus(null);\n+                    Scene.this.requestFocus(null, false);\n@@ -4036,0 +4037,2 @@\n+        boolean focusVisible;\n+\n@@ -4052,0 +4055,5 @@\n+        private void setFocusVisible(Node node, boolean focusVisible) {\n+            node.focusVisible.set(focusVisible);\n+            node.focusVisible.notifyListeners();\n+        }\n+\n@@ -4057,1 +4065,2 @@\n-                getFocusOwner().setFocused(windowFocused);\n+                getFocusOwner().setFocusQuietly(windowFocused, focusVisible);\n+                getFocusOwner().notifyFocusListeners();\n@@ -4092,3 +4101,10 @@\n-        private void requestFocus(Node node) {\n-            if (getFocusOwner() == node || (node != null && !node.isCanReceiveFocus())) {\n-                return;\n+        private void requestFocus(Node node, boolean focusVisible) {\n+            if (node == null) {\n+                setFocusOwner(null);\n+            } else if (node.isCanReceiveFocus()) {\n+                if (node != getFocusOwner()) {\n+                    this.focusVisible = focusVisible;\n+                    setFocusOwner(node);\n+                } else {\n+                    setFocusVisible(node, focusVisible);\n+                }\n@@ -4096,1 +4112,0 @@\n-            setFocusOwner(node);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":33,"deletions":18,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -771,2 +772,2 @@\n-    boolean traverse(Node node, Direction dir) {\n-        return traversalEngine.trav(node, dir) != null;\n+    boolean traverse(Node node, Direction dir, TraversalMethod method) {\n+        return traversalEngine.trav(node, dir, method) != null;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/SubScene.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.HashMap;\n@@ -34,0 +35,1 @@\n+import java.util.Map;\n@@ -40,0 +42,2 @@\n+\n+import org.junit.AfterClass;\n@@ -41,0 +45,1 @@\n+import org.junit.BeforeClass;\n@@ -49,1 +54,31 @@\n-    public PseudoClassTest() {\n+    private static Map<String, Integer> initialPseudoClassMap;\n+    private static List<PseudoClass> initialPseudoClasses;\n+\n+    \/**\n+     * Before we run any of the tests in this class, we must store the current content\n+     * of both the 'PseudoClassState.pseudoClassMap' and 'PseudoClassState.pseudoClasses'\n+     * static fields, and restore the exact content after we have completed all tests.\n+     *\n+     * Once a pseudo-class has been loaded via 'PseudoClass.getPseudoClass(String)', the\n+     * returned singleton 'PseudoClassImpl' instance will be stored in the static list\n+     * 'PseudoClassState.pseudoClasses', and the instance will store the index of itself\n+     * in this list.\n+     *\n+     * Clearing the content of 'pseudoClassMap' and 'pseudoClasses' will therefore break\n+     * existing 'PseudoClass' instances, because their stored index will no longer refer\n+     * to the correct instance in the 'pseudoClasses' list. This can cause other tests\n+     * that happen to use a broken pseudo-class instance to fail undeterministically,\n+     * depending on whether or not they are executed before or after this class.\n+     *\/\n+    @BeforeClass\n+    public static void beforeClass() {\n+        initialPseudoClassMap = new HashMap<>(PseudoClassStateShim.pseudoClassMap);\n+        initialPseudoClasses = new ArrayList<>(PseudoClassStateShim.pseudoClasses);\n+    }\n+\n+    @AfterClass\n+    public static void afterClass() {\n+        PseudoClassStateShim.pseudoClassMap.clear();\n+        PseudoClassStateShim.pseudoClassMap.putAll(initialPseudoClassMap);\n+        PseudoClassStateShim.pseudoClasses.clear();\n+        PseudoClassStateShim.pseudoClasses.addAll(initialPseudoClasses);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/css\/PseudoClassTest.java","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -262,1 +263,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT));\n+        assertEquals(n2, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n@@ -274,1 +275,1 @@\n-        assertEquals(ng1, engine.trav(n1, Direction.NEXT));\n+        assertEquals(ng1, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n@@ -285,1 +286,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT));\n+        assertEquals(n2, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n@@ -296,1 +297,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT));\n+        assertEquals(n2, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n@@ -307,1 +308,1 @@\n-        assertEquals(g, engine.trav(n1, Direction.NEXT));\n+        assertEquals(g, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n@@ -337,1 +338,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT));\n+        assertEquals(n2, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n@@ -370,1 +371,1 @@\n-        assertEquals(n3, engine.trav(n1, Direction.NEXT));\n+        assertEquals(n3, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n@@ -382,1 +383,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT_IN_LINE));\n+        assertEquals(n2, engine.trav(n1, Direction.NEXT_IN_LINE, TraversalMethod.DEFAULT));\n@@ -394,1 +395,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS));\n+        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n@@ -406,1 +407,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS));\n+        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n@@ -417,1 +418,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS));\n+        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n@@ -429,1 +430,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS));\n+        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n@@ -441,1 +442,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS));\n+        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n@@ -453,1 +454,1 @@\n-        assertEquals(g, engine.trav(n2, Direction.PREVIOUS));\n+        assertEquals(g, engine.trav(n2, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n@@ -463,1 +464,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT));\n+        assertEquals(n2, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n@@ -474,1 +475,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS));\n+        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n@@ -505,1 +506,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS));\n+        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/traversal\/TopMostTraversalEngineTest.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -184,1 +185,1 @@\n-        traversalEngine.trav(keypadNodes[fromNumber - 1], direction);\n+        traversalEngine.trav(keypadNodes[fromNumber - 1], direction, TraversalMethod.DEFAULT);\n@@ -192,1 +193,1 @@\n-        traversalEngine.trav(keypadNodes[fromNumber - 1], direction);\n+        traversalEngine.trav(keypadNodes[fromNumber - 1], direction, TraversalMethod.DEFAULT);\n@@ -202,1 +203,1 @@\n-        traversalEngine.trav(keypadNodes[fromNumber - 1], direction);\n+        traversalEngine.trav(keypadNodes[fromNumber - 1], direction, TraversalMethod.DEFAULT);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/traversal\/TraversalTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -127,1 +128,1 @@\n-        traversalEngine.trav(keypadNodes[fromNumber], direction);\n+        traversalEngine.trav(keypadNodes[fromNumber], direction, TraversalMethod.DEFAULT);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/traversal\/TraverseInvisibleTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+import javafx.event.Event;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.KeyEvent;\n@@ -42,4 +45,1 @@\n-import javafx.beans.InvalidationListener;\n-import javafx.beans.Observable;\n-import javafx.beans.value.ChangeListener;\n-import javafx.beans.value.ObservableValue;\n+\n@@ -116,0 +116,1 @@\n+        assertTrue(n.getPseudoClassStates().stream().anyMatch(pc -> pc.getPseudoClassName().equals(\"focused\")));\n@@ -121,0 +122,1 @@\n+        assertFalse(n.getPseudoClassStates().stream().anyMatch(pc -> pc.getPseudoClassName().equals(\"focused\")));\n@@ -127,0 +129,36 @@\n+    private void assertIsFocusVisible(Node n) {\n+        assertTrue(n.isFocusVisible());\n+        assertTrue(n.getPseudoClassStates().stream().anyMatch(pc -> pc.getPseudoClassName().equals(\"focus-visible\")));\n+    }\n+\n+    private void assertNotFocusVisible(Node n) {\n+        assertFalse(n.isFocusVisible());\n+        assertFalse(n.getPseudoClassStates().stream().anyMatch(pc -> pc.getPseudoClassName().equals(\"focus-visible\")));\n+    }\n+\n+    private void assertIsFocusWithin(Node n) {\n+        assertTrue(n.isFocusWithin());\n+        assertTrue(n.getPseudoClassStates().stream().anyMatch(pc -> pc.getPseudoClassName().equals(\"focus-within\")));\n+    }\n+\n+    private void assertNotFocusWithin(Node n) {\n+        assertFalse(n.isFocusWithin());\n+        assertFalse(n.getPseudoClassStates().stream().anyMatch(pc -> pc.getPseudoClassName().equals(\"focus-within\")));\n+    }\n+\n+    private void assertIsFocusWithinParents(Node n) {\n+        do {\n+            assertTrue(n.isFocusWithin());\n+            assertTrue(n.getPseudoClassStates().stream().anyMatch(pc -> pc.getPseudoClassName().equals(\"focus-within\")));\n+            n = n.getParent();\n+        } while (n != null);\n+    }\n+\n+    private void assertNotFocusWithinParents(Node n) {\n+        do {\n+            assertFalse(n.isFocusWithin());\n+            assertFalse(n.getPseudoClassStates().stream().anyMatch(pc -> pc.getPseudoClassName().equals(\"focus-within\")));\n+            n = n.getParent();\n+        } while (n != null);\n+    }\n+\n@@ -735,2 +773,164 @@\n-    \/\/ TODO: tests for moving nodes between scenes\n-    \/\/ and active and inactive stages\n+    private void fireTabKeyEvent(Node node) {\n+        Event.fireEvent(node, new KeyEvent(KeyEvent.KEY_PRESSED, null, null, KeyCode.TAB, false, false, false, false));\n+        Event.fireEvent(node, new KeyEvent(KeyEvent.KEY_RELEASED, null, null, KeyCode.TAB, false, false, false, false));\n+    }\n+\n+    \/**\n+     * If a node acquires focus by calling {@link Node#requestFocus()}, it does not acquire visible focus.\n+     *\/\n+    @Test public void testDefaultFocusTraversalDoesNotSetFocusVisible() {\n+        Node node = n();\n+        scene.setRoot(new Group(node));\n+\n+        assertNotFocused(scene, node);\n+        assertNotFocusVisible(node);\n+\n+        node.requestFocus();\n+\n+        assertIsFocused(scene, node);\n+        assertNotFocusVisible(node);\n+    }\n+\n+    \/**\n+     * If a node acquires focus when the TAB key is pressed, it also acquires visible focus.\n+     *\/\n+    @Test public void testKeyFocusTraversalSetsFocusVisible() {\n+        Node node = n();\n+        Group g = new Group(node);\n+        scene.setRoot(g);\n+\n+        assertNotFocused(scene, node);\n+        assertNotFocusVisible(node);\n+\n+        fireTabKeyEvent(g);\n+\n+        assertIsFocused(scene, node);\n+        assertIsFocusVisible(node);\n+    }\n+\n+    \/**\n+     * If {@link Node#requestFocus()} is called on a node that has acquired visible focus,\n+     * visible focus is removed from the node.\n+     *\/\n+    @Test public void testFocusVisibleIsRemovedByDefaultRequestFocus() {\n+        Node node = n();\n+        Group g = new Group(node);\n+        scene.setRoot(g);\n+        fireTabKeyEvent(g);\n+\n+        assertIsFocused(scene, node);\n+        assertIsFocusVisible(node);\n+\n+        node.requestFocus();\n+\n+        assertIsFocused(scene, node);\n+        assertNotFocusVisible(node);\n+    }\n+\n+    \/**\n+     * When a node loses focus, it also loses visible focus.\n+     *\/\n+    @Test public void testVisibleFocusIsRemovedWhenFocusIsRemoved() {\n+        Node node1 = n();\n+        Node node2 = n();\n+        Group g = new Group(node1, node2);\n+        scene.setRoot(g);\n+        fireTabKeyEvent(g);\n+\n+        assertIsFocused(scene, node1);\n+        assertIsFocusVisible(node1);\n+\n+        node2.requestFocus();\n+\n+        assertNotFocused(scene, node1);\n+        assertNotFocusVisible(node1);\n+        assertIsFocused(scene, node2);\n+        assertNotFocusVisible(node2);\n+    }\n+\n+    \/**\n+     * When a node acquires focus, the focusWithin property is set on the node\n+     * and all of its parents.\n+     *\/\n+    @Test public void testFocusWithinIsTrueOnAllParents() {\n+        Node node1 = n();\n+        Group g = new Group(new Group(new Group(node1)));\n+        scene.setRoot(g);\n+\n+        assertNotFocusWithinParents(node1);\n+\n+        node1.requestFocus();\n+\n+        assertIsFocusWithinParents(node1);\n+    }\n+\n+    \/**\n+     * When a node loses focus, the focusWithin property of its parents is cleared.\n+     *\/\n+    @Test public void testFocusWithinIsRemovedFromParentsAfterChangingFocusOwner() {\n+        Node node1 = n(), node2 = n();\n+        Group g = new Group(new Group(new Group(node1)), new Group(new Group(node2)));\n+        scene.setRoot(g);\n+\n+        assertNotFocusWithinParents(node1);\n+        assertNotFocusWithinParents(node2);\n+\n+        node1.requestFocus();\n+\n+        assertIsFocusWithinParents(node1);\n+        assertNotFocusWithin(node2);\n+        assertNotFocusWithin(node2.getParent());\n+        assertNotFocusWithin(node2.getParent().getParent());\n+\n+        node2.requestFocus();\n+\n+        assertIsFocusWithinParents(node2);\n+        assertNotFocusWithin(node1);\n+        assertNotFocusWithin(node1.getParent());\n+        assertNotFocusWithin(node1.getParent().getParent());\n+    }\n+\n+    \/**\n+     * When a node loses focus, all of its parents also lose focusWithin.\n+     * However, if focus transitions to a new node, and the new node is also a child of the\n+     * parent that just lost focusWithin, the parent will re-gain focusWithin.\n+     *\n+     * Since focus traversal is specified to be an atomic operation, the fact that\n+     * the parent technically lost and re-gained focusWithin must not be observable.\n+     *\/\n+    @Test public void testFocusWithinListenerIsNotInvokedIfPropertyDidNotEffectivelyChange() {\n+        Node node1 = n(), node2 = n();\n+        Group g = new Group(new Group(new Group(node1)), new Group(new Group(node2)));\n+        scene.setRoot(g);\n+\n+        List<Boolean> focusWithinValues = new ArrayList<>();\n+        g.focusWithinProperty().addListener((observable, oldValue, newValue) -> focusWithinValues.add(newValue));\n+\n+        node1.requestFocus();\n+        assertEquals(1, focusWithinValues.size());\n+        assertEquals(Boolean.TRUE, focusWithinValues.get(0));\n+\n+        node2.requestFocus();\n+        assertEquals(1, focusWithinValues.size());\n+        assertEquals(Boolean.TRUE, focusWithinValues.get(0));\n+    }\n+\n+    \/**\n+     * When a focused node is removed from the scene graph, the focus states\n+     * of its former parents are cleared.\n+     *\/\n+    @Test public void testFocusStatesAreClearedFromFormerParentsOfFocusedNode() {\n+        Node node1 = n(), node2 = n();\n+        Group g2, g3, g1 = new Group(g2 = new Group(g3 = new Group(node1)), new Group(new Group(node2)));\n+        scene.setRoot(g1);\n+\n+        node1.requestFocus();\n+        assertIsFocusWithin(g1);\n+        assertIsFocusWithin(g2);\n+        assertIsFocusWithin(g3);\n+\n+        g2.getChildren().remove(0);\n+        assertNotFocusWithin(g1);\n+        assertNotFocusWithin(g2);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/FocusTest.java","additions":207,"deletions":7,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -114,1 +115,1 @@\n-        NodeHelper.traverse(accessor.getView(), forward ? Direction.NEXT : Direction.PREVIOUS);\n+        NodeHelper.traverse(accessor.getView(), forward ? Direction.NEXT : Direction.PREVIOUS, TraversalMethod.DEFAULT);\n","filename":"modules\/javafx.web\/src\/main\/java\/com\/sun\/javafx\/webkit\/WebPageClientImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}