{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import java.util.Objects;\n@@ -97,0 +98,1 @@\n+        Objects.checkIndex(index, size() + 1);\n@@ -161,0 +163,1 @@\n+        Objects.checkFromToIndex(fromIndex, toIndex, size());\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/ObservableListWrapper.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import java.util.Objects;\n+\n@@ -113,0 +115,1 @@\n+        Objects.requireNonNull(col);\n@@ -164,0 +167,1 @@\n+        Objects.checkFromToIndex(from, to, size());\n@@ -233,0 +237,1 @@\n+        Objects.requireNonNull(c);\n@@ -248,0 +253,2 @@\n+        Objects.requireNonNull(c);\n+        Objects.checkIndex(index, size() + 1);\n@@ -263,0 +270,1 @@\n+        Objects.requireNonNull(c);\n@@ -278,0 +286,1 @@\n+        Objects.requireNonNull(c);\n@@ -316,0 +325,1 @@\n+        Objects.checkIndex(index, size() + 1);\n@@ -328,0 +338,1 @@\n+        Objects.checkIndex(index, size());\n@@ -463,0 +474,1 @@\n+            Objects.requireNonNull(c);\n@@ -479,0 +491,2 @@\n+            Objects.requireNonNull(c);\n+            Objects.checkIndex(index, size() + 1);\n@@ -495,0 +509,1 @@\n+            Objects.requireNonNull(c);\n@@ -511,0 +526,1 @@\n+            Objects.requireNonNull(c);\n@@ -553,0 +569,1 @@\n+            Objects.checkIndex(index, size() + 1);\n@@ -566,0 +583,1 @@\n+            Objects.checkIndex(index, size());\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/VetoableListDecorator.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+\n+import java.util.Collection;\n@@ -841,0 +843,87 @@\n+    @Test\n+    public void testNegativeIndex_Add() {\n+        Group g = new Group();\n+        g.getChildren().addAll(new Rectangle(), new Rectangle());\n+\n+        int preTestSize = g.getChildren().size();\n+\n+        \/\/ Adding an object at a negative or too big index should throw IndexOutOfBoundsException and not modify internal state\n+        assertThrows(IndexOutOfBoundsException.class, () -> g.getChildren().add(-1, new Rectangle()));\n+        assertEquals(preTestSize, g.getChildren().size());\n+\n+        assertThrows(IndexOutOfBoundsException.class, () -> g.getChildren().add(g.getChildren().size() + 1, new Rectangle()));\n+        assertEquals(preTestSize, g.getChildren().size());\n+\n+        \/\/ below call should throw no exception - if it does, internal state is corrupted\n+        g.getChildren().remove(0);\n+    }\n+\n+    @Test\n+    public void testNegativeIndex_Set() {\n+        Group g = new Group();\n+        g.getChildren().addAll(new Rectangle(), new Rectangle());\n+\n+        int preTestSize = g.getChildren().size();\n+\n+        \/\/ Setting an object at a negative or too big index should throw IndexOutOfBoundsException and not modify internal state\n+        assertThrows(IndexOutOfBoundsException.class, () -> g.getChildren().set(-1, new Rectangle()));\n+        assertEquals(preTestSize, g.getChildren().size());\n+\n+        assertThrows(IndexOutOfBoundsException.class, () -> g.getChildren().set(g.getChildren().size(), new Rectangle()));\n+        assertEquals(preTestSize, g.getChildren().size());\n+\n+        \/\/ below call should throw no exception - if it does, internal state is corrupted\n+        g.getChildren().remove(0);\n+    }\n+\n+    @Test\n+    public void testNegativeIndex_Remove() {\n+        Group g = new Group();\n+        g.getChildren().addAll(new Rectangle(), new Rectangle());\n+\n+        int preTestSize = g.getChildren().size();\n+\n+        \/\/ Removing an object at negative or too big index should throw IndexOutOfBoundsException and not modify internal state\n+        assertThrows(IndexOutOfBoundsException.class, () -> g.getChildren().remove(-1));\n+        assertEquals(preTestSize, g.getChildren().size());\n+\n+        assertThrows(IndexOutOfBoundsException.class, () -> g.getChildren().remove(g.getChildren().size()));\n+        assertEquals(preTestSize, g.getChildren().size());\n+\n+        \/\/ below call should throw no exception - if it does, internal state is corrupted\n+        g.getChildren().remove(0);\n+    }\n+\n+    @Test\n+    public void testNullObject_AddAll() {\n+        Group g = new Group();\n+        g.getChildren().addAll(new Rectangle(), new Rectangle());\n+\n+        int preTestSize = g.getChildren().size();\n+\n+        \/\/ Adding a null object should throw NPE and not modify internal state\n+        assertThrows(NullPointerException.class, () -> g.getChildren().addAll((Collection<Node>)null));\n+        assertEquals(preTestSize, g.getChildren().size());\n+\n+        assertThrows(NullPointerException.class, () -> g.getChildren().addAll(0, (Collection<Node>)null));\n+        assertEquals(preTestSize, g.getChildren().size());\n+\n+        \/\/ below call should throw no exception - if it does, internal state is corrupted\n+        g.getChildren().remove(0);\n+    }\n+\n+    @Test\n+    public void testNullObject_SetAll() {\n+        Group g = new Group();\n+        g.getChildren().addAll(new Rectangle(), new Rectangle());\n+\n+        int preTestSize = g.getChildren().size();\n+\n+        \/\/ Setting a null object should throw NPE and not modify internal state\n+        assertThrows(NullPointerException.class, () -> g.getChildren().setAll((Collection<Node>)null));\n+        assertEquals(preTestSize, g.getChildren().size());\n+\n+        \/\/ below call should throw no exception - if it does, internal state is corrupted\n+        g.getChildren().remove(0);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/ParentTest.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"}]}