{"files":[{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.binding;\n+\n+\/**\n+ * Marker interface for {@link javafx.beans.value.ObservableValue}s which support\n+ * concurrent modification of their listeners.\n+ *\/\n+public interface ConcurrentListenerAccess {\n+\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ConcurrentListenerAccess.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.binding;\n+\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.WeakReference;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Objects;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.Observable;\n+import javafx.beans.WeakListener;\n+\n+\/**\n+ * This class is used for cleaning up weak listener stubs registered by the\n+ * various *PropertyBase classes.\n+ *\n+ * A Cleaner is not used here as calling {@link Observable#removeListener(InvalidationListener)}\n+ * cannot be guaranteed to be executed very quick and not to block (as per Cleaner requirements).\n+ *\/\n+public class ListenerRemover {\n+\n+    private static final ReferenceQueue<?> QUEUE = new ReferenceQueue<>();\n+\n+    \/**\n+     * When ref becomes weakly reachable, remove weakListener from target.\n+     *\n+     * @param <T> the type of reference\n+     * @param <L> the listener type\n+     * @param ref an object to monitor for weak reachability, cannot be {@code null}\n+     * @param weakListener a listener implementing {@link WeakListener} and {@link InvalidationListener}, cannot be {@code null}\n+     * @param target an {@link Observable} from which to remove the listener, cannot be {@code null}\n+     * @return a {@link WeakReference}, never {@code null}\n+     *\/\n+    public static final <T, L extends InvalidationListener & WeakListener> WeakReference<T> whenWeaklyReachable(T ref, L weakListener, Observable target) {\n+        return new TrackingWeakReference<>(\n+            Objects.requireNonNull(ref, \"ref\"),\n+            Objects.requireNonNull(weakListener, \"weakListener\"),\n+            Objects.requireNonNull(target, \"target\")\n+        );\n+    }\n+\n+    private static class TrackingWeakReference<T> extends WeakReference<T> {\n+        final InvalidationListener weakListener;\n+        final Observable target;\n+\n+        public TrackingWeakReference(T referent, InvalidationListener weakListener, Observable target) {\n+            super(referent, queue());\n+\n+            this.weakListener = weakListener;\n+            this.target = target;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final <T> ReferenceQueue<T> queue() {\n+        return (ReferenceQueue<T>)QUEUE;\n+    }\n+\n+    static {\n+        AccessController.doPrivileged(\n+            new PrivilegedAction<Object>() {\n+                @Override\n+                public Object run() {\n+\n+                    \/*\n+                     * The thread must be a member of a thread group\n+                     * which will not get GCed before VM exit.\n+                     * Make its parent the top-level thread group.\n+                     *\/\n+\n+                    ThreadGroup tg = Thread.currentThread().getThreadGroup();\n+\n+                    for (ThreadGroup tgn = tg;\n+                         tgn != null;\n+                         tg = tgn, tgn = tg.getParent());\n+\n+                    Thread t = new Thread(tg, ListenerRemover::run, \"Listener Stub Disposer\");\n+\n+                    t.setContextClassLoader(null);\n+                    t.setDaemon(true);\n+                    t.setPriority(Thread.MAX_PRIORITY);\n+                    t.start();\n+\n+                    return null;\n+                }\n+            }\n+        );\n+    }\n+\n+    private static void run() {\n+        while (true) {\n+            try {\n+                TrackingWeakReference<?> ref = (TrackingWeakReference<?>) QUEUE.remove();\n+\n+                ref.target.removeListener(ref.weakListener);\n+            } catch (Exception e) {\n+                System.out.println(\"Exception while removing weak listener stub: \" + e);\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ListenerRemover.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+import com.sun.javafx.binding.ConcurrentListenerAccess;\n@@ -62,1 +63,1 @@\n-        Binding<T> {\n+        Binding<T>, ConcurrentListenerAccess {\n@@ -76,1 +77,1 @@\n-    public void addListener(InvalidationListener listener) {\n+    public synchronized void addListener(InvalidationListener listener) {\n@@ -81,1 +82,1 @@\n-    public void removeListener(InvalidationListener listener) {\n+    public synchronized void removeListener(InvalidationListener listener) {\n@@ -86,1 +87,1 @@\n-    public void addListener(ChangeListener<? super T> listener) {\n+    public synchronized void addListener(ChangeListener<? super T> listener) {\n@@ -91,1 +92,1 @@\n-    public void removeListener(ChangeListener<? super T> listener) {\n+    public synchronized void removeListener(ChangeListener<? super T> listener) {\n@@ -182,1 +183,5 @@\n-            ExpressionHelper.fireValueChangedEvent(helper);\n+\n+            synchronized(this) {\n+                ExpressionHelper.fireValueChangedEvent(helper);\n+            }\n+\n@@ -200,1 +205,1 @@\n-    protected final boolean isObserved() {\n+    protected synchronized final boolean isObserved() {\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/binding\/ObjectBinding.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.ref.WeakReference;\n+\n@@ -30,0 +32,1 @@\n+import javafx.beans.WeakListener;\n@@ -33,0 +36,2 @@\n+import com.sun.javafx.binding.ConcurrentListenerAccess;\n+import com.sun.javafx.binding.ListenerRemover;\n@@ -34,2 +39,0 @@\n-import java.lang.ref.WeakReference;\n-import javafx.beans.WeakListener;\n@@ -172,1 +175,1 @@\n-                listener = new Listener(this);\n+                listener = new Listener(this, observable);\n@@ -224,2 +227,4 @@\n-        public Listener(ObjectPropertyBase<?> ref) {\n-            this.wref = new WeakReference<ObjectPropertyBase<?>>(ref);\n+        public Listener(ObjectPropertyBase<?> ref, Observable observable) {\n+            this.wref = observable instanceof ConcurrentListenerAccess\n+                    ? ListenerRemover.whenWeaklyReachable(ref, this, observable)\n+                    : new WeakReference<ObjectPropertyBase<?>>(ref);\n@@ -231,3 +236,1 @@\n-            if (ref == null) {\n-                observable.removeListener(this);\n-            } else {\n+            if (ref != null) {\n@@ -236,0 +239,3 @@\n+            else if(!(observable instanceof ConcurrentListenerAccess)) {\n+                observable.removeListener(this);\n+            }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ObjectPropertyBase.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"}]}