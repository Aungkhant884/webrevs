{"files":[{"patch":"@@ -98,2 +98,12 @@\n-     * Creates a {@link Subscription} on this value which calls the given\n-     * {@code runnable} whenever it becomes invalid.\n+     * Creates a {@link Subscription} on this {@code Observable} which calls\n+     * {@code invalidationSubscriber} whenever it becomes invalid. If the same\n+     * subscriber is subscribed more than once, then it will be notified more\n+     * than once. That is, no check is made to ensure uniqueness.\n+     * <p>\n+     * Note that the same subscriber instance may be safely subscribed for\n+     * different {@code Observables}.\n+     * <p>\n+     * Also note that when subscribing on an {@code Observable} with a longer\n+     * lifecycle than the subscriber, the subscriber must be unsubscribed\n+     * when no longer needed as the subscription will otherwise keep the subscriber\n+     * from being garbage collected.\n@@ -101,1 +111,1 @@\n-     * @param subscriber a {@code Runnable} to call whenever this\n+     * @param invalidationSubscriber a {@code Runnable} to call whenever this\n@@ -106,0 +116,1 @@\n+     * @see #addListener(InvalidationListener)\n@@ -108,3 +119,3 @@\n-    default Subscription subscribe(Runnable subscriber) {\n-        Objects.requireNonNull(subscriber, \"subscriber cannot be null\");\n-        InvalidationListener listener = obs -> subscriber.run();\n+    default Subscription subscribe(Runnable invalidationSubscriber) {\n+        Objects.requireNonNull(invalidationSubscriber, \"invalidationSubscriber cannot be null\");\n+        InvalidationListener listener = obs -> invalidationSubscriber.run();\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/Observable.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -306,4 +306,3 @@\n-     * Creates a {@link Subscription} on this value which calls the given\n-     * {@code subscriber} with the old and new value of this value whenever it\n-     * changes.<p>\n-     *\n+     * Creates a {@link Subscription} on this {@code Observable} which calls the given\n+     * {@code changeSubscriber} with the old and new value whenever its value changes.\n+     * <p>\n@@ -312,0 +311,11 @@\n+     * <p>\n+     * Note that the same subscriber instance may be safely subscribed for\n+     * different {@code Observables}.\n+     * <p>\n+     * Also note that when subscribing on an {@code Observable} with a longer\n+     * lifecycle than the subscriber, the subscriber must be unsubscribed\n+     * when no longer needed as the subscription will otherwise keep the subscriber\n+     * from being garbage collected. Considering creating a derived {@code ObservableValue}\n+     * using {@link #when(ObservableValue)} and subscribing on this derived observable value\n+     * to automatically decouple the lifecycle of the subscriber from this\n+     * {@code ObservableValue} when some condition holds.\n@@ -313,1 +323,1 @@\n-     * @param subscriber a {@code BiConsumer} to supply with the old and new values\n+     * @param changeSubscriber a {@code BiConsumer} to supply with the old and new values\n@@ -318,0 +328,1 @@\n+     * @see #addListener(ChangeListener)\n@@ -320,3 +331,3 @@\n-    default Subscription subscribe(BiConsumer<? super T, ? super T> subscriber) {\n-      Objects.requireNonNull(subscriber, \"subscriber cannot be null\");\n-      ChangeListener<T> listener = (obs, old, current) -> subscriber.accept(old, current);\n+    default Subscription subscribe(BiConsumer<? super T, ? super T> changeSubscriber) {\n+      Objects.requireNonNull(changeSubscriber, \"changeSubscriber cannot be null\");\n+      ChangeListener<T> listener = (obs, old, current) -> changeSubscriber.accept(old, current);\n@@ -332,1 +343,12 @@\n-     * subsequent changes in value.\n+     * subsequent values whenever its value changes.\n+     * <p>\n+     * Note that the same subscriber instance may be safely subscribed for\n+     * different {@code Observables}.\n+     * <p>\n+     * Also note that when subscribing on an {@code Observable} with a longer\n+     * lifecycle than the subscriber, the subscriber must be unsubscribed\n+     * when no longer needed as the subscription will otherwise keep the subscriber\n+     * from being garbage collected. Considering creating a derived {@code ObservableValue}\n+     * using {@link #when(ObservableValue)} and subscribing on this derived observable value\n+     * to automatically decouple the lifecycle of the subscriber from this\n+     * {@code ObservableValue} when some condition holds.\n@@ -334,1 +356,1 @@\n-     * @param subscriber a {@link Consumer} to supply with the values of this\n+     * @param valueSubscriber a {@link Consumer} to supply with the values of this\n@@ -341,3 +363,3 @@\n-    default Subscription subscribe(Consumer<? super T> subscriber) {\n-        Objects.requireNonNull(subscriber, \"subscriber cannot be null\");\n-        ChangeListener<T> listener = (obs, old, current) -> subscriber.accept(current);\n+    default Subscription subscribe(Consumer<? super T> valueSubscriber) {\n+        Objects.requireNonNull(valueSubscriber, \"valueSubscriber cannot be null\");\n+        ChangeListener<T> listener = (obs, old, current) -> valueSubscriber.accept(current);\n@@ -345,1 +367,1 @@\n-        subscriber.accept(getValue());  \/\/ eagerly send current value\n+        valueSubscriber.accept(getValue());  \/\/ eagerly send current value\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/ObservableValue.java","additions":36,"deletions":14,"binary":false,"changes":50,"status":"modified"}]}