{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import javafx.beans.Subscription;\n@@ -44,1 +45,1 @@\n-        Subscription.subscribe(nonNullCondition, this::conditionChanged);\n+        nonNullCondition.subscribe(this::conditionChanged);\n@@ -78,1 +79,1 @@\n-                subscription = Subscription.subscribeInvalidations(source, this::invalidate);\n+                subscription = source.subscribe(this::invalidate);\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ConditionalBinding.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import javafx.beans.Subscription;\n@@ -74,1 +75,1 @@\n-            indirectSourceSubscription = newIndirectSource == null ? Subscription.EMPTY : Subscription.subscribeInvalidations(newIndirectSource, this::invalidate);\n+            indirectSourceSubscription = newIndirectSource == null ? Subscription.EMPTY : newIndirectSource.subscribe(this::invalidate);\n@@ -83,1 +84,1 @@\n-        Subscription subscription = Subscription.subscribeInvalidations(source, this::invalidateAll);\n+        Subscription subscription = source.subscribe(this::invalidateAll);\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/FlatMappedBinding.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javafx.beans.Subscription;\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/LazyObjectBinding.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import javafx.beans.Subscription;\n@@ -52,1 +53,1 @@\n-        return Subscription.subscribeInvalidations(source, this::invalidate); \/\/ start observing source\n+        return source.subscribe(this::invalidate); \/\/ start observing source\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/MappedBinding.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import javafx.beans.Subscription;\n@@ -51,1 +52,1 @@\n-        return Subscription.subscribeInvalidations(source, this::invalidate); \/\/ start observing source\n+        return source.subscribe(this::invalidate); \/\/ start observing source\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/OrElseBinding.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.binding;\n-\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-\n-import javafx.beans.InvalidationListener;\n-import javafx.beans.value.ChangeListener;\n-import javafx.beans.value.ObservableValue;\n-\n-\/**\n- * A subscription encapsulates how to cancel it without having\n- * to keep track of how it was created.\n- *\n- * <p>For example:\n- *\n- * <p>{@code Subscription s = property.subscribe(System.out::println)}\n- *\n- * <p>The function passed in to {@code subscribe} does not need to be stored\n- * in order to clean up the subscription later.\n- *\/\n-@FunctionalInterface\n-public interface Subscription {\n-\n-    \/**\n-     * An empty subscription. Does nothing when cancelled.\n-     *\/\n-    static final Subscription EMPTY = () -> {};\n-\n-    \/**\n-     * Cancels this subscription.\n-     *\/\n-    void unsubscribe();\n-\n-    \/**\n-     * Combines this {@link Subscription} with the given {@code Subscription}\n-     * and returns a new {@code Subscription} which will cancel both when\n-     * cancelled.\n-     *\n-     * @param other another {@link Subscription}, cannot be {@code null}\n-     * @return a combined {@link Subscription} which will cancel both when\n-     *     cancelled, never {@code null}\n-     * @throws NullPointerException when {@code other} is {@code null}\n-     *\/\n-    default Subscription and(Subscription other) {\n-        Objects.requireNonNull(other);\n-\n-        return () -> {\n-            unsubscribe();\n-            other.unsubscribe();\n-        };\n-    }\n-\n-    \/**\n-     * Creates a {@link Subscription} on this {@link ObservableValue} which\n-     * immediately provides its current value to the given {@code subscriber},\n-     * followed by any subsequent changes in value.\n-     *\n-     * @param subscriber a {@link Consumer} to supply with the values of this\n-     *     {@link ObservableValue}, cannot be {@code null}\n-     * @return a {@link Subscription} which can be used to cancel this\n-     *     subscription, never {@code null}\n-     * @throws NullPointerException when {@code observableValue} or {@code subscriber} is {@code null}\n-     *\/\n-    static <T> Subscription subscribe(ObservableValue<T> observableValue, Consumer<? super T> subscriber) {\n-        Objects.requireNonNull(observableValue);\n-        Objects.requireNonNull(subscriber);\n-\n-        ChangeListener<T> listener = (obs, old, current) -> subscriber.accept(current);\n-\n-        subscriber.accept(observableValue.getValue());  \/\/ eagerly send current value\n-        observableValue.addListener(listener);\n-\n-        return () -> observableValue.removeListener(listener);\n-    }\n-\n-    \/**\n-     * Creates a {@link Subscription} on this {@link ObservableValue} which\n-     * calls the given {@code runnable} whenever this {@code ObservableValue}\n-     * becomes invalid.\n-     *\n-     * @param runnable a {@link Runnable} to call whenever this\n-     *     {@link ObservableValue} becomes invalid, cannot be @{code null}\n-     * @return a {@link Subscription} which can be used to cancel this\n-     *     subscription, never @{code null}\n-     * @throws NullPointerException when {@code observableValue} or {@code runnable} is {@code null}\n-     *\/\n-    static Subscription subscribeInvalidations(ObservableValue<?> observableValue, Runnable runnable) {\n-        Objects.requireNonNull(observableValue);\n-        Objects.requireNonNull(runnable);\n-\n-        InvalidationListener listener = obs -> runnable.run();\n-\n-        observableValue.addListener(listener);\n-\n-        return () -> observableValue.removeListener(listener);\n-    }\n-}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/Subscription.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Objects;\n@@ -96,0 +97,30 @@\n+    \/**\n+     * Creates a {@link Subscription} on this {@code Observable} which calls\n+     * {@code invalidationSubscriber} whenever it becomes invalid. If the same\n+     * subscriber is subscribed more than once, then it will be notified more\n+     * than once. That is, no check is made to ensure uniqueness.\n+     * <p>\n+     * Note that the same subscriber instance may be safely subscribed for\n+     * different {@code Observables}.\n+     * <p>\n+     * Also note that when subscribing on an {@code Observable} with a longer\n+     * lifecycle than the subscriber, the subscriber must be unsubscribed\n+     * when no longer needed as the subscription will otherwise keep the subscriber\n+     * from being garbage collected.\n+     *\n+     * @param invalidationSubscriber a {@code Runnable} to call whenever this\n+     *     value becomes invalid, cannot be {@code null}\n+     * @return a {@code Subscription} which can be used to cancel this\n+     *     subscription, never {@code null}\n+     * @throws NullPointerException if the subscriber is {@code null}\n+     * @see #addListener(InvalidationListener)\n+     * @since 21\n+     *\/\n+    default Subscription subscribe(Runnable invalidationSubscriber) {\n+        Objects.requireNonNull(invalidationSubscriber, \"invalidationSubscriber cannot be null\");\n+        InvalidationListener listener = obs -> invalidationSubscriber.run();\n+\n+        addListener(listener);\n+\n+        return () -> removeListener(listener);\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/Observable.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.beans;\n+\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/**\n+ * A subscription encapsulates how to cancel it without having\n+ * to keep track of how it was created.\n+ *\n+ * @since 21\n+ *\/\n+@FunctionalInterface\n+public interface Subscription {\n+\n+    \/**\n+     * An empty subscription. Does nothing when cancelled.\n+     *\/\n+    static final Subscription EMPTY = () -> {};\n+\n+    \/**\n+     * Returns a {@code Subscription} which combines all of the given\n+     * subscriptions.\n+     *\n+     * @param subscriptions an array of subscriptions to combine, cannot be {@code null} or contain {@code null}\n+     * @return a {@code Subscription}, never {@code null}\n+     * @throws NullPointerException when {@code subscriptions} is {@code null} or contains {@code null}\n+     *\/\n+    static Subscription combine(Subscription... subscriptions) {\n+        List<Subscription> list = List.of(subscriptions);\n+\n+        return () -> list.forEach(Subscription::unsubscribe);\n+    }\n+\n+    \/**\n+     * Cancels this subscription, or does nothing if already cancelled.<p>\n+     *\n+     * Implementors must ensure the implementation is idempotent.\n+     *\/\n+    void unsubscribe();\n+\n+    \/**\n+     * Combines this {@link Subscription} with the given {@code Subscription}\n+     * and returns a new {@code Subscription} which will cancel both when\n+     * cancelled.\n+     *\n+     * <p>This is equivalent to {@code Subscription.combine(this, other)}.\n+     *\n+     * @param other another {@code Subscription}, cannot be {@code null}\n+     * @return a combined {@code Subscription} which will cancel both when\n+     *     cancelled, never {@code null}\n+     * @throws NullPointerException when {@code other} is {@code null}\n+     *\/\n+    default Subscription and(Subscription other) {\n+        Objects.requireNonNull(other, \"other cannot be null\");\n+\n+        return () -> {\n+            unsubscribe();\n+            other.unsubscribe();\n+        };\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/Subscription.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n@@ -37,0 +40,1 @@\n+import javafx.beans.Subscription;\n@@ -300,0 +304,68 @@\n+\n+    \/**\n+     * Creates a {@link Subscription} on this {@code Observable} which calls the given\n+     * {@code changeSubscriber} with the old and new value whenever its value changes.\n+     * <p>\n+     * The parameters supplied to the {@link BiConsumer} are the old and new value\n+     * respectively.\n+     * <p>\n+     * Note that the same subscriber instance may be safely subscribed for\n+     * different {@code Observables}.\n+     * <p>\n+     * Also note that when subscribing on an {@code Observable} with a longer\n+     * lifecycle than the subscriber, the subscriber must be unsubscribed\n+     * when no longer needed as the subscription will otherwise keep the subscriber\n+     * from being garbage collected. Considering creating a derived {@code ObservableValue}\n+     * using {@link #when(ObservableValue)} and subscribing on this derived observable value\n+     * to automatically decouple the lifecycle of the subscriber from this\n+     * {@code ObservableValue} when some condition holds.\n+     *\n+     * @param changeSubscriber a {@code BiConsumer} to supply with the old and new values\n+     *     of this {@code ObservableValue}, cannot be {@code null}\n+     * @return a {@code Subscription} which can be used to cancel this\n+     *     subscription, never {@code null}\n+     * @throws NullPointerException if the subscriber is {@code null}\n+     * @see #addListener(ChangeListener)\n+     * @since 21\n+     *\/\n+    default Subscription subscribe(BiConsumer<? super T, ? super T> changeSubscriber) {\n+      Objects.requireNonNull(changeSubscriber, \"changeSubscriber cannot be null\");\n+      ChangeListener<T> listener = (obs, old, current) -> changeSubscriber.accept(old, current);\n+\n+      addListener(listener);\n+\n+      return () -> removeListener(listener);\n+    }\n+\n+    \/**\n+     * Creates a {@link Subscription} on this value which immediately provides\n+     * the current value to the given {@code valueSubscriber}, followed by any\n+     * subsequent values whenever its value changes.\n+     * <p>\n+     * Note that the same subscriber instance may be safely subscribed for\n+     * different {@code Observables}.\n+     * <p>\n+     * Also note that when subscribing on an {@code Observable} with a longer\n+     * lifecycle than the subscriber, the subscriber must be unsubscribed\n+     * when no longer needed as the subscription will otherwise keep the subscriber\n+     * from being garbage collected. Considering creating a derived {@code ObservableValue}\n+     * using {@link #when(ObservableValue)} and subscribing on this derived observable value\n+     * to automatically decouple the lifecycle of the subscriber from this\n+     * {@code ObservableValue} when some condition holds.\n+     *\n+     * @param valueSubscriber a {@link Consumer} to supply with the values of this\n+     *     {@code ObservableValue}, cannot be {@code null}\n+     * @return a {@code Subscription} which can be used to cancel this\n+     *     subscription, never {@code null}\n+     * @throws NullPointerException if the subscriber is {@code null}\n+     * @since 21\n+     *\/\n+    default Subscription subscribe(Consumer<? super T> valueSubscriber) {\n+        Objects.requireNonNull(valueSubscriber, \"valueSubscriber cannot be null\");\n+        ChangeListener<T> listener = (obs, old, current) -> valueSubscriber.accept(current);\n+\n+        valueSubscriber.accept(getValue());  \/\/ eagerly send current value\n+        addListener(listener);\n+\n+        return () -> removeListener(listener);\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/ObservableValue.java","additions":73,"deletions":1,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import javafx.beans.Subscription;\n+\n","filename":"modules\/javafx.base\/src\/shims\/java\/com\/sun\/javafx\/binding\/LazyObjectBindingStub.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.beans;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import javafx.beans.Subscription;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.beans.property.StringProperty;\n+\n+public class ObservableSubscriptionsTest {\n+    private final StringProperty value = new SimpleStringProperty(\"Initial\");\n+\n+    @Test\n+    void subscribeRunnableShouldCallSubscriberWhenObservableInvalidated() {\n+        AtomicInteger calls = new AtomicInteger();\n+\n+        assertEquals(0, calls.get());\n+\n+        Subscription subscription = value.subscribe(() -> calls.addAndGet(1));\n+\n+        assertEquals(0, calls.get());\n+\n+        value.set(\"A\");\n+\n+        assertEquals(1, calls.get());\n+\n+        value.set(\"B\");\n+\n+        assertEquals(1, calls.get());  \/\/ already invalid, not called again\n+\n+        value.get();\n+        value.set(\"C\");\n+\n+        assertEquals(2, calls.get());\n+\n+        subscription.unsubscribe();\n+\n+        value.get();\n+        value.set(\"C\");\n+\n+        assertEquals(2, calls.get());  \/\/ unsubscribed, not called\n+    }\n+\n+    @Test\n+    void subscribeRunnableShouldRejectNull() {\n+        assertThrows(NullPointerException.class, () -> value.subscribe((Runnable) null));\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/ObservableSubscriptionsTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.beans;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import javafx.beans.Subscription;\n+\n+public class SubscriptionTest {\n+\n+    @Test\n+    void ofShouldReturnSubscriptionWhichCanCancelAllGivenSubscriptions() {\n+        AtomicReference<String> a = new AtomicReference<>();\n+        AtomicReference<String> b = new AtomicReference<>();\n+        AtomicReference<String> c = new AtomicReference<>();\n+\n+        Subscription subscription = Subscription.combine(\n+            () -> a.set(\"canceled\"),\n+            () -> b.set(\"canceled\"),\n+            () -> c.set(\"canceled\")\n+        );\n+\n+        assertNull(a.get());\n+        assertNull(b.get());\n+        assertNull(c.get());\n+\n+        subscription.unsubscribe();\n+\n+        assertEquals(\"canceled\", a.get());\n+        assertEquals(\"canceled\", b.get());\n+        assertEquals(\"canceled\", c.get());\n+    }\n+\n+    @Test\n+    void ofShouldRejectNulls() {\n+        assertThrows(NullPointerException.class, () -> Subscription.combine((Subscription[]) null));\n+        assertThrows(NullPointerException.class, () -> Subscription.combine((Subscription) null));\n+        assertThrows(NullPointerException.class, () -> Subscription.combine(Subscription.EMPTY, null, () -> {}));\n+    }\n+\n+    @Test\n+    void andShouldReturnSubscriptionWhichCanCancelBothSubscriptions() {\n+        AtomicReference<String> a = new AtomicReference<>();\n+        AtomicReference<String> b = new AtomicReference<>();\n+\n+        Subscription subscription1 = () -> a.set(\"canceled\");\n+        Subscription subscription2 = () -> b.set(\"canceled\");\n+\n+        Subscription combined = subscription1.and(subscription2);\n+\n+        assertNull(a.get());\n+        assertNull(b.get());\n+\n+        combined.unsubscribe();\n+\n+        assertEquals(\"canceled\", a.get());\n+        assertEquals(\"canceled\", b.get());\n+    }\n+\n+    @Test\n+    void andShouldRejectNull() {\n+        assertThrows(NullPointerException.class, () -> Subscription.EMPTY.and(null));\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/SubscriptionTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.beans.value;\n+\n+import static org.junit.Assert.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import javafx.beans.Subscription;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.beans.property.StringProperty;\n+\n+public class ObservableValueSubscriptionsTest {\n+    private final StringProperty value = new SimpleStringProperty(\"Initial\");\n+\n+    @Test\n+    void subscribeConsumerShouldCallSubscriberImmediatelyAndAfterEachChange() {\n+        AtomicReference<String> lastCall = new AtomicReference<>();\n+\n+        assertNull(lastCall.get());\n+\n+        Subscription subscription = value.subscribe(lastCall::set);\n+\n+        assertEquals(\"Initial\", lastCall.get());  \/\/ provides initial upon subscribing\n+\n+        value.set(\"A\");\n+\n+        assertEquals(\"A\", lastCall.get());\n+\n+        value.set(\"B\");\n+\n+        assertEquals(\"B\", lastCall.get());\n+\n+        lastCall.set(null);\n+\n+        value.set(\"B\");\n+\n+        assertNull(lastCall.get());  \/\/ unchanged when changing from B to B\n+\n+        subscription.unsubscribe();\n+\n+        value.set(\"C\");\n+\n+        assertNull(lastCall.get());  \/\/ unchanged as unsubscribed\n+    }\n+\n+    @Test\n+    void subscribeConsumerShouldRejectNull() {\n+        assertThrows(NullPointerException.class, () -> value.subscribe((Consumer<String>) null));\n+    }\n+\n+    @Test\n+    void subscribeBiConsumerShouldCallSubscriberAfterEachChange() {\n+        AtomicReference<String> lastCall = new AtomicReference<>();\n+\n+        assertNull(lastCall.get());\n+\n+        Subscription subscription = value.subscribe((old, current) -> lastCall.set(old + \" -> \" + current));\n+\n+        assertNull(lastCall.get());  \/\/ Nothing happens upon subscribing\n+\n+        value.set(\"A\");\n+\n+        assertEquals(\"Initial -> A\", lastCall.get());\n+\n+        value.set(\"B\");\n+\n+        assertEquals(\"A -> B\", lastCall.get());\n+\n+        lastCall.set(null);\n+\n+        value.set(\"B\");\n+\n+        assertNull(lastCall.get());  \/\/ unchanged when changing from B to B\n+\n+        subscription.unsubscribe();\n+\n+        value.set(\"C\");\n+\n+        assertNull(lastCall.get());  \/\/ unchanged as unsubscribed\n+    }\n+\n+    @Test\n+    void subscribeBiConsumerShouldRejectNull() {\n+        assertThrows(NullPointerException.class, () -> value.subscribe((BiConsumer<String, String>) null));\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/ObservableValueSubscriptionsTest.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"}]}