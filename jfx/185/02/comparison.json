{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.javafx.scene.TreeShowingExpression;\n@@ -107,0 +108,1 @@\n+    private TreeShowingExpression treeShowingExpression;\n@@ -128,0 +130,1 @@\n+        this.treeShowingExpression = new TreeShowingExpression(control);\n@@ -132,1 +135,0 @@\n-        registerChangeListener(NodeHelper.treeShowingProperty(control), e -> updateAnimation());\n@@ -134,0 +136,1 @@\n+        registerChangeListener(treeShowingExpression, e -> updateAnimation());\n@@ -235,0 +238,2 @@\n+        treeShowingExpression.dispose();\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/ProgressIndicatorSkin.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -297,4 +297,0 @@\n-    public static BooleanExpression treeShowingProperty(Node node) {\n-        return nodeAccessor.treeShowingProperty(node);\n-    }\n-\n@@ -364,1 +360,0 @@\n-        BooleanExpression treeShowingProperty(Node node);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/NodeHelper.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene;\n+\n+import com.sun.javafx.binding.ExpressionHelper;\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.binding.BooleanExpression;\n+import javafx.beans.value.ChangeListener;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.stage.Window;\n+\n+\/**\n+ * Used to observe changes in tree showing status for a {@link Node}.  For a Node's tree to be showing\n+ * it must be visible, its ancestors must be visible, the node must be part of a {@link Scene} and\n+ * the scene must have a {@link Window} which is currently showing.<p>\n+ *\n+ * This class provides the exact same functionality as {@link NodeHelper#isTreeShowing(Node)} in\n+ * an observable form.\n+ *\/\n+public class TreeShowingExpression extends BooleanExpression {\n+    private final ChangeListener<Boolean> windowShowingChangedListener = (obs, oldVal, newVal) -> updateTreeShowing();\n+\n+    private final ChangeListener<Window> sceneWindowChangedListener = (scene, oldWindow, newWindow) -> {\n+        if (oldWindow != null) {\n+            oldWindow.showingProperty().removeListener(windowShowingChangedListener);\n+        }\n+        if (newWindow != null) {\n+            newWindow.showingProperty().addListener(windowShowingChangedListener);\n+        }\n+        updateTreeShowing();\n+    };\n+\n+    private final ChangeListener<Scene> nodeSceneChangedListener = (node, oldScene, newScene) -> {\n+        if (oldScene != null) {\n+            oldScene.windowProperty().removeListener(sceneWindowChangedListener);\n+        }\n+        if (newScene != null) {\n+            newScene.windowProperty().addListener(sceneWindowChangedListener);\n+        }\n+\n+        sceneWindowChangedListener.changed(\n+            null,\n+            oldScene == null ? null : oldScene.getWindow(),\n+            newScene == null ? null : newScene.getWindow()\n+        );\n+    };\n+\n+    private final Node node;\n+\n+    private ExpressionHelper<Boolean> helper;\n+    private boolean valid;\n+    private boolean treeShowing;\n+\n+    \/**\n+     * Constructs a new instance.\n+     *\n+     * @param node a {@link Node} for which the tree showing status should be observed, cannot be null\n+     *\/\n+    public TreeShowingExpression(Node node) {\n+        this.node = node;\n+        this.node.sceneProperty().addListener(nodeSceneChangedListener);\n+\n+        NodeHelper.treeVisibleProperty(node).addListener(windowShowingChangedListener);\n+\n+        nodeSceneChangedListener.changed(null, null, node.getScene());\n+    }\n+\n+    \/**\n+     * Cleans up any listeners that this class may have registered on the {@link Node}\n+     * that was supplied at construction.\n+     *\/\n+    public void dispose() {\n+        node.sceneProperty().removeListener(nodeSceneChangedListener);\n+\n+        NodeHelper.treeVisibleProperty(node).removeListener(windowShowingChangedListener);\n+    }\n+\n+    private void updateTreeShowing() {\n+        boolean newValue = NodeHelper.isTreeShowing(node);\n+\n+        if (newValue != treeShowing) {\n+            treeShowing = newValue;\n+            invalidate();\n+        }\n+    }\n+\n+    @Override\n+    public void addListener(InvalidationListener listener) {\n+        helper = ExpressionHelper.addListener(helper, this, listener);\n+    }\n+\n+    @Override\n+    public void removeListener(InvalidationListener listener) {\n+        helper = ExpressionHelper.removeListener(helper, listener);\n+    }\n+\n+    @Override\n+    public void addListener(ChangeListener<? super Boolean> listener) {\n+        helper = ExpressionHelper.addListener(helper, this, listener);\n+    }\n+\n+    @Override\n+    public void removeListener(ChangeListener<? super Boolean> listener) {\n+        helper = ExpressionHelper.removeListener(helper, listener);\n+    }\n+\n+    protected void invalidate() {\n+        if (valid) {\n+            valid = false;\n+            ExpressionHelper.fireValueChangedEvent(helper);\n+        }\n+    }\n+\n+    @Override\n+    public boolean get() {\n+        if (!valid) {\n+            updateTreeShowing();\n+            valid = true;\n+        }\n+\n+        return treeShowing;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/TreeShowingExpression.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -606,5 +606,0 @@\n-            @Override\n-            public BooleanExpression treeShowingProperty(Node node) {\n-                return node.treeShowingProperty();\n-            }\n-\n@@ -1009,14 +1004,0 @@\n-    private final ChangeListener<Boolean> windowShowingChangedListener\n-            = (win, oldVal, newVal) -> updateTreeShowing();\n-\n-    private final ChangeListener<Window> sceneWindowChangedListener = (scene, oldWindow, newWindow) -> {\n-        \/\/ Replace the windowShowingListener and call updateTreeShowing()\n-        if (oldWindow != null) {\n-            oldWindow.showingProperty().removeListener(windowShowingChangedListener);\n-        }\n-        if (newWindow != null) {\n-            newWindow.showingProperty().addListener(windowShowingChangedListener);\n-        }\n-        updateTreeShowing();\n-    };\n-\n@@ -1084,20 +1065,0 @@\n-        \/\/ isTreeShowing needs to take into account of Window's showing\n-        if (oldScene != null) {\n-            oldScene.windowProperty().removeListener(sceneWindowChangedListener);\n-\n-            Window window = oldScene.windowProperty().get();\n-            if (window != null) {\n-                window.showingProperty().removeListener(windowShowingChangedListener);\n-            }\n-        }\n-        if (newScene != null) {\n-            newScene.windowProperty().addListener(sceneWindowChangedListener);\n-\n-            Window window = newScene.windowProperty().get();\n-            if (window != null) {\n-                window.showingProperty().addListener(windowShowingChangedListener);\n-            }\n-\n-        }\n-        updateTreeShowing();\n-\n@@ -8426,14 +8387,0 @@\n-    private void updateTreeShowing() {\n-        setTreeShowing(isTreeVisible() && isWindowShowing());\n-    }\n-\n-    private boolean treeShowing;\n-    private TreeShowingPropertyReadOnly treeShowingRO;\n-\n-    final void setTreeShowing(boolean value) {\n-        if (treeShowing != value) {\n-            treeShowing = value;\n-            ((TreeShowingPropertyReadOnly) treeShowingProperty()).invalidate();\n-        }\n-    }\n-\n@@ -8441,48 +8388,1 @@\n-        return treeShowingProperty().get();\n-    }\n-\n-    final BooleanExpression treeShowingProperty() {\n-        if (treeShowingRO == null) {\n-            treeShowingRO = new TreeShowingPropertyReadOnly();\n-        }\n-        return treeShowingRO;\n-    }\n-\n-    class TreeShowingPropertyReadOnly extends BooleanExpression {\n-\n-        private ExpressionHelper<Boolean> helper;\n-        private boolean valid;\n-\n-        @Override\n-        public void addListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n-        }\n-\n-        @Override\n-        public void removeListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n-        }\n-\n-        @Override\n-        public void addListener(ChangeListener<? super Boolean> listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n-        }\n-\n-        @Override\n-        public void removeListener(ChangeListener<? super Boolean> listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n-        }\n-\n-        protected void invalidate() {\n-            if (valid) {\n-                valid = false;\n-                ExpressionHelper.fireValueChangedEvent(helper);\n-            }\n-        }\n-\n-        @Override\n-        public boolean get() {\n-            valid = true;\n-            return Node.this.treeShowing;\n-        }\n-\n+        return isTreeVisible() && isWindowShowing();\n@@ -8507,2 +8407,0 @@\n-\n-        updateTreeShowing();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Node.java","additions":1,"deletions":103,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-                    \/\/ disabled, isTreeVisible and isTreeShowing properties are inherited\n+                    \/\/ disabled and isTreeVisible properties are inherited\n@@ -312,1 +312,0 @@\n-                    _value.setTreeShowing(isTreeShowing());\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/SubScene.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.scene.TreeShowingExpression;\n@@ -65,1 +66,1 @@\n-import com.sun.javafx.scene.NodeHelper;\n+\n@@ -152,0 +153,1 @@\n+    private TreeShowingExpression treeShowingExpression;\n@@ -413,1 +415,2 @@\n-            NodeHelper.treeShowingProperty(ownerNode).addListener(weakOwnerNodeListener);\n+            treeShowingExpression = new TreeShowingExpression(ownerNode);\n+            treeShowingExpression.addListener(weakOwnerNodeListener);\n@@ -490,1 +493,5 @@\n-        if (getOwnerNode() != null) NodeHelper.treeShowingProperty(getOwnerNode()).removeListener(weakOwnerNodeListener);\n+        if (treeShowingExpression != null) {\n+            treeShowingExpression.removeListener(weakOwnerNodeListener);\n+            treeShowingExpression.dispose();\n+            treeShowingExpression = null;\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/PopupWindow.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene;\n+\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.StackPane;\n+import javafx.stage.Stage;\n+import javafx.stage.WindowEvent;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import test.util.Util;\n+\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+\/**\n+ * TODO fix\n+ * This test is based on the test case reported in JDK-8209830\n+ *\n+ * Redundant CSS Re-application was avoided in JDK-8193445.\n+ * It results in faster application of CSS on Controls (Nodes). In turn,\n+ * resulting in improved Node creation\/addition time to a Scene.\n+ *\n+ * The goal of this test is *NOT* to measure absolute performance, but to show\n+ * creating and adding 500 Nodes to a scene does not take more than a\n+ * particular threshold of time.\n+ *\n+ * The selected thresold is larger than actual observed time.\n+ * It is not a benchmark value. It is good enough to catch the regression\n+ * in performance, if any.\n+ *\/\n+\n+public class NodeTreeShowingTest {\n+\n+    private static CountDownLatch startupLatch;\n+    private static Stage stage;\n+    private static BorderPane rootPane;\n+\n+    public static class TestApp extends Application {\n+\n+        @Override\n+        public void start(Stage primaryStage) throws Exception {\n+            stage = primaryStage;\n+            rootPane = new BorderPane();\n+            stage.setScene(new Scene(rootPane));\n+            stage.addEventHandler(WindowEvent.WINDOW_SHOWN, e -> {\n+                Platform.runLater(() -> startupLatch.countDown());\n+            });\n+            stage.show();\n+        }\n+    }\n+\n+    @BeforeClass\n+    public static void initFX() throws Exception {\n+        startupLatch = new CountDownLatch(1);\n+        new Thread(() -> Application.launch(NodeTreeShowingTest.TestApp.class, (String[]) null)).start();\n+\n+        assertTrue(\"Timeout waiting for FX runtime to start\", startupLatch.await(15, TimeUnit.SECONDS));\n+    }\n+\n+    private StackPane createNodesRecursively(int count, int level) {\n+        StackPane pane = new StackPane();\n+\n+        for (int i = 0; i < count; i++) {\n+            pane.getChildren().add(level == 1 ? new StackPane() : createNodesRecursively(count, level - 1));\n+        }\n+\n+        return pane;\n+    }\n+\n+    \/**\n+     * This tests how quickly Nodes can be added and removed from a very large Scene.  Specifically,\n+     * this test was created to ensure that not every Node in the Scene creates a listener on its\n+     * Scene (and\/or its associated Window).  With a large amount of Nodes in a Scene the listener\n+     * lists of the associated Scene and\/or Window can become very large and adding or removing\n+     * a Node takes a performance hit.\n+     *\/\n+    @Test\n+    public void testAddRemovalSpeedInHugeScene() throws Exception {\n+        Random rnd = new Random(0);  \/\/ seed random to keep it predictable\n+        int loopCount = 10000;\n+        int levels = 13;\n+        int nodesPerLevel = 2;  \/\/ total nodes is (nodesPerLevel ^ levels) * 2 - 1\n+        int leafCount = (int)Math.pow(nodesPerLevel, levels);\n+        int total = leafCount * 2 - 1;\n+        StackPane testNode = new StackPane();\n+        StackPane root = createNodesRecursively(nodesPerLevel, levels);\n+        AtomicLong bestMillis = new AtomicLong(Long.MAX_VALUE);\n+\n+        Util.runAndWait(() -> {\n+            rootPane.setCenter(root);\n+        });\n+\n+        for(int j = 0; j < 5; j++) {\n+            int loopNumber = j + 1;\n+\n+            Util.runAndWait(() -> {\n+                \/\/ Compute time it takes to add\/remove Nodes at random spots\n+                long startTime = System.currentTimeMillis();\n+\n+                for (int i = 0; i < loopCount; i++) {\n+                    \/\/ Find a random leaf to remove\/re-add a child:\n+                    int index = rnd.nextInt(leafCount);\n+                    StackPane current = root;\n+\n+                    while (index >= nodesPerLevel) {\n+                        current = (StackPane) current.getChildren().get(index % nodesPerLevel);\n+                        index \/= nodesPerLevel;\n+                    }\n+\n+                    current.getChildren().add(current.getChildren().remove(index));\n+                }\n+\n+                long endTime = System.currentTimeMillis();\n+\n+                bestMillis.set(Math.min(endTime - startTime, bestMillis.get()));\n+\n+                System.out.println(\"Loop \" + loopNumber + \": Time to add\/remove \" + loopCount + \" nodes in \"\n+                        + \"a Scene consisting of \" + total + \" nodes = \" + (endTime - startTime) + \" mSec\");\n+            });\n+        }\n+\n+        \/\/ NOTE : 800 mSec is not a benchmark value\n+        \/\/ It is good enough to catch the regression in performance, if any\n+        assertTrue(\"Time to add\/remove \" + loopCount + \" nodes in a large Scene is more than 800 mSec\", bestMillis.get() <= 800);\n+    }\n+\n+    @AfterClass\n+    public static void teardownOnce() {\n+        Platform.runLater(() -> {\n+            stage.hide();\n+            Platform.exit();\n+        });\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/NodeTreeShowingTest.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"}]}