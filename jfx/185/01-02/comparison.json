{"files":[{"patch":"@@ -130,0 +130,1 @@\n+        this.treeShowingExpression = new TreeShowingExpression(control);\n@@ -135,3 +136,1 @@\n-\n-        treeShowingExpression = new TreeShowingExpression(control);\n-        treeShowingExpression.addListener((obs, old, current) -> updateAnimation());\n+        registerChangeListener(treeShowingExpression, e -> updateAnimation());\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/ProgressIndicatorSkin.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene;\n+\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.StackPane;\n+import javafx.stage.Stage;\n+import javafx.stage.WindowEvent;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import test.util.Util;\n+\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+\/**\n+ * TODO fix\n+ * This test is based on the test case reported in JDK-8209830\n+ *\n+ * Redundant CSS Re-application was avoided in JDK-8193445.\n+ * It results in faster application of CSS on Controls (Nodes). In turn,\n+ * resulting in improved Node creation\/addition time to a Scene.\n+ *\n+ * The goal of this test is *NOT* to measure absolute performance, but to show\n+ * creating and adding 500 Nodes to a scene does not take more than a\n+ * particular threshold of time.\n+ *\n+ * The selected thresold is larger than actual observed time.\n+ * It is not a benchmark value. It is good enough to catch the regression\n+ * in performance, if any.\n+ *\/\n+\n+public class NodeTreeShowingTest {\n+\n+    private static CountDownLatch startupLatch;\n+    private static Stage stage;\n+    private static BorderPane rootPane;\n+\n+    public static class TestApp extends Application {\n+\n+        @Override\n+        public void start(Stage primaryStage) throws Exception {\n+            stage = primaryStage;\n+            rootPane = new BorderPane();\n+            stage.setScene(new Scene(rootPane));\n+            stage.addEventHandler(WindowEvent.WINDOW_SHOWN, e -> {\n+                Platform.runLater(() -> startupLatch.countDown());\n+            });\n+            stage.show();\n+        }\n+    }\n+\n+    @BeforeClass\n+    public static void initFX() throws Exception {\n+        startupLatch = new CountDownLatch(1);\n+        new Thread(() -> Application.launch(NodeTreeShowingTest.TestApp.class, (String[]) null)).start();\n+\n+        assertTrue(\"Timeout waiting for FX runtime to start\", startupLatch.await(15, TimeUnit.SECONDS));\n+    }\n+\n+    private StackPane createNodesRecursively(int count, int level) {\n+        StackPane pane = new StackPane();\n+\n+        for (int i = 0; i < count; i++) {\n+            pane.getChildren().add(level == 1 ? new StackPane() : createNodesRecursively(count, level - 1));\n+        }\n+\n+        return pane;\n+    }\n+\n+    \/**\n+     * This tests how quickly Nodes can be added and removed from a very large Scene.  Specifically,\n+     * this test was created to ensure that not every Node in the Scene creates a listener on its\n+     * Scene (and\/or its associated Window).  With a large amount of Nodes in a Scene the listener\n+     * lists of the associated Scene and\/or Window can become very large and adding or removing\n+     * a Node takes a performance hit.\n+     *\/\n+    @Test\n+    public void testAddRemovalSpeedInHugeScene() throws Exception {\n+        Random rnd = new Random(0);  \/\/ seed random to keep it predictable\n+        int loopCount = 10000;\n+        int levels = 13;\n+        int nodesPerLevel = 2;  \/\/ total nodes is (nodesPerLevel ^ levels) * 2 - 1\n+        int leafCount = (int)Math.pow(nodesPerLevel, levels);\n+        int total = leafCount * 2 - 1;\n+        StackPane testNode = new StackPane();\n+        StackPane root = createNodesRecursively(nodesPerLevel, levels);\n+        AtomicLong bestMillis = new AtomicLong(Long.MAX_VALUE);\n+\n+        Util.runAndWait(() -> {\n+            rootPane.setCenter(root);\n+        });\n+\n+        for(int j = 0; j < 5; j++) {\n+            int loopNumber = j + 1;\n+\n+            Util.runAndWait(() -> {\n+                \/\/ Compute time it takes to add\/remove Nodes at random spots\n+                long startTime = System.currentTimeMillis();\n+\n+                for (int i = 0; i < loopCount; i++) {\n+                    \/\/ Find a random leaf to remove\/re-add a child:\n+                    int index = rnd.nextInt(leafCount);\n+                    StackPane current = root;\n+\n+                    while (index >= nodesPerLevel) {\n+                        current = (StackPane) current.getChildren().get(index % nodesPerLevel);\n+                        index \/= nodesPerLevel;\n+                    }\n+\n+                    current.getChildren().add(current.getChildren().remove(index));\n+                }\n+\n+                long endTime = System.currentTimeMillis();\n+\n+                bestMillis.set(Math.min(endTime - startTime, bestMillis.get()));\n+\n+                System.out.println(\"Loop \" + loopNumber + \": Time to add\/remove \" + loopCount + \" nodes in \"\n+                        + \"a Scene consisting of \" + total + \" nodes = \" + (endTime - startTime) + \" mSec\");\n+            });\n+        }\n+\n+        \/\/ NOTE : 800 mSec is not a benchmark value\n+        \/\/ It is good enough to catch the regression in performance, if any\n+        assertTrue(\"Time to add\/remove \" + loopCount + \" nodes in a large Scene is more than 800 mSec\", bestMillis.get() <= 800);\n+    }\n+\n+    @AfterClass\n+    public static void teardownOnce() {\n+        Platform.runLater(() -> {\n+            stage.hide();\n+            Platform.exit();\n+        });\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/NodeTreeShowingTest.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"}]}