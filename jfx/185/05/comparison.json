{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.javafx.scene.TreeShowingExpression;\n@@ -107,0 +108,1 @@\n+    private TreeShowingExpression treeShowingExpression;\n@@ -128,0 +130,1 @@\n+        this.treeShowingExpression = new TreeShowingExpression(control);\n@@ -132,1 +135,0 @@\n-        registerChangeListener(NodeHelper.treeShowingProperty(control), e -> updateAnimation());\n@@ -134,0 +136,1 @@\n+        registerChangeListener(treeShowingExpression, e -> updateAnimation());\n@@ -235,0 +238,2 @@\n+        treeShowingExpression.dispose();\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/ProgressIndicatorSkin.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -297,4 +297,0 @@\n-    public static BooleanExpression treeShowingProperty(Node node) {\n-        return nodeAccessor.treeShowingProperty(node);\n-    }\n-\n@@ -364,1 +360,0 @@\n-        BooleanExpression treeShowingProperty(Node node);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/NodeHelper.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene;\n+\n+import com.sun.javafx.binding.ExpressionHelper;\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.binding.BooleanExpression;\n+import javafx.beans.value.ChangeListener;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.stage.Window;\n+\n+\/**\n+ * Used to observe changes in tree showing status for a {@link Node}.  For a Node's tree to be showing\n+ * it must be visible, its ancestors must be visible, the node must be part of a {@link Scene} and\n+ * the scene must have a {@link Window} which is currently showing.<p>\n+ *\n+ * This class provides the exact same functionality as {@link NodeHelper#isTreeShowing(Node)} in\n+ * an observable form.\n+ *\/\n+public class TreeShowingExpression extends BooleanExpression {\n+    private final ChangeListener<Boolean> windowShowingChangedListener = (obs, old, current) -> updateTreeShowing();\n+    private final ChangeListener<Window> sceneWindowChangedListener = (obs, old, current) -> windowChanged(old, current);\n+    private final ChangeListener<Scene> nodeSceneChangedListener = (obs, old, current) -> sceneChanged(old, current);\n+\n+    private final Node node;\n+\n+    private ExpressionHelper<Boolean> helper;\n+    private boolean valid;\n+    private boolean treeShowing;\n+\n+    \/**\n+     * Constructs a new instance.\n+     *\n+     * @param node a {@link Node} for which the tree showing status should be observed, cannot be null\n+     *\/\n+    public TreeShowingExpression(Node node) {\n+        this.node = node;\n+        this.node.sceneProperty().addListener(nodeSceneChangedListener);\n+\n+        NodeHelper.treeVisibleProperty(node).addListener(windowShowingChangedListener);\n+\n+        sceneChanged(null, node.getScene());\n+    }\n+\n+    \/**\n+     * Cleans up any listeners that this class may have registered on the {@link Node}\n+     * that was supplied at construction.\n+     *\/\n+    public void dispose() {\n+        node.sceneProperty().removeListener(nodeSceneChangedListener);\n+\n+        NodeHelper.treeVisibleProperty(node).removeListener(windowShowingChangedListener);\n+\n+        valid = false;  \/\/ prevents unregistration from triggering an invalidation notification\n+        sceneChanged(node.getScene(), null);\n+    }\n+\n+    @Override\n+    public void addListener(InvalidationListener listener) {\n+        helper = ExpressionHelper.addListener(helper, this, listener);\n+    }\n+\n+    @Override\n+    public void removeListener(InvalidationListener listener) {\n+        helper = ExpressionHelper.removeListener(helper, listener);\n+    }\n+\n+    @Override\n+    public void addListener(ChangeListener<? super Boolean> listener) {\n+        helper = ExpressionHelper.addListener(helper, this, listener);\n+    }\n+\n+    @Override\n+    public void removeListener(ChangeListener<? super Boolean> listener) {\n+        helper = ExpressionHelper.removeListener(helper, listener);\n+    }\n+\n+    protected void invalidate() {\n+        if (valid) {\n+            valid = false;\n+            ExpressionHelper.fireValueChangedEvent(helper);\n+        }\n+    }\n+\n+    @Override\n+    public boolean get() {\n+        if (!valid) {\n+            updateTreeShowing();\n+            valid = true;\n+        }\n+\n+        return treeShowing;\n+    }\n+\n+    private void sceneChanged(Scene oldScene, Scene newScene) {\n+        if (oldScene != null) {\n+            oldScene.windowProperty().removeListener(sceneWindowChangedListener);\n+        }\n+        if (newScene != null) {\n+            newScene.windowProperty().addListener(sceneWindowChangedListener);\n+        }\n+\n+        windowChanged(\n+            oldScene == null ? null : oldScene.getWindow(),\n+            newScene == null ? null : newScene.getWindow()\n+        );\n+    }\n+\n+    private void windowChanged(Window oldWindow, Window newWindow) {\n+        if (oldWindow != null) {\n+            oldWindow.showingProperty().removeListener(windowShowingChangedListener);\n+        }\n+        if (newWindow != null) {\n+            newWindow.showingProperty().addListener(windowShowingChangedListener);\n+        }\n+\n+        updateTreeShowing();\n+    }\n+\n+    private void updateTreeShowing() {\n+        boolean newValue = NodeHelper.isTreeShowing(node);\n+\n+        if (newValue != treeShowing) {\n+            treeShowing = newValue;\n+            invalidate();\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/TreeShowingExpression.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -606,5 +606,0 @@\n-            @Override\n-            public BooleanExpression treeShowingProperty(Node node) {\n-                return node.treeShowingProperty();\n-            }\n-\n@@ -1009,14 +1004,0 @@\n-    private final ChangeListener<Boolean> windowShowingChangedListener\n-            = (win, oldVal, newVal) -> updateTreeShowing();\n-\n-    private final ChangeListener<Window> sceneWindowChangedListener = (scene, oldWindow, newWindow) -> {\n-        \/\/ Replace the windowShowingListener and call updateTreeShowing()\n-        if (oldWindow != null) {\n-            oldWindow.showingProperty().removeListener(windowShowingChangedListener);\n-        }\n-        if (newWindow != null) {\n-            newWindow.showingProperty().addListener(windowShowingChangedListener);\n-        }\n-        updateTreeShowing();\n-    };\n-\n@@ -1084,20 +1065,0 @@\n-        \/\/ isTreeShowing needs to take into account of Window's showing\n-        if (oldScene != null) {\n-            oldScene.windowProperty().removeListener(sceneWindowChangedListener);\n-\n-            Window window = oldScene.windowProperty().get();\n-            if (window != null) {\n-                window.showingProperty().removeListener(windowShowingChangedListener);\n-            }\n-        }\n-        if (newScene != null) {\n-            newScene.windowProperty().addListener(sceneWindowChangedListener);\n-\n-            Window window = newScene.windowProperty().get();\n-            if (window != null) {\n-                window.showingProperty().addListener(windowShowingChangedListener);\n-            }\n-\n-        }\n-        updateTreeShowing();\n-\n@@ -8426,14 +8387,0 @@\n-    private void updateTreeShowing() {\n-        setTreeShowing(isTreeVisible() && isWindowShowing());\n-    }\n-\n-    private boolean treeShowing;\n-    private TreeShowingPropertyReadOnly treeShowingRO;\n-\n-    final void setTreeShowing(boolean value) {\n-        if (treeShowing != value) {\n-            treeShowing = value;\n-            ((TreeShowingPropertyReadOnly) treeShowingProperty()).invalidate();\n-        }\n-    }\n-\n@@ -8441,48 +8388,1 @@\n-        return treeShowingProperty().get();\n-    }\n-\n-    final BooleanExpression treeShowingProperty() {\n-        if (treeShowingRO == null) {\n-            treeShowingRO = new TreeShowingPropertyReadOnly();\n-        }\n-        return treeShowingRO;\n-    }\n-\n-    class TreeShowingPropertyReadOnly extends BooleanExpression {\n-\n-        private ExpressionHelper<Boolean> helper;\n-        private boolean valid;\n-\n-        @Override\n-        public void addListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n-        }\n-\n-        @Override\n-        public void removeListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n-        }\n-\n-        @Override\n-        public void addListener(ChangeListener<? super Boolean> listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n-        }\n-\n-        @Override\n-        public void removeListener(ChangeListener<? super Boolean> listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n-        }\n-\n-        protected void invalidate() {\n-            if (valid) {\n-                valid = false;\n-                ExpressionHelper.fireValueChangedEvent(helper);\n-            }\n-        }\n-\n-        @Override\n-        public boolean get() {\n-            valid = true;\n-            return Node.this.treeShowing;\n-        }\n-\n+        return isTreeVisible() && isWindowShowing();\n@@ -8507,2 +8407,0 @@\n-\n-        updateTreeShowing();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Node.java","additions":2,"deletions":104,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -309,1 +309,1 @@\n-                    \/\/ disabled, isTreeVisible and isTreeShowing properties are inherited\n+                    \/\/ disabled and isTreeVisible properties are inherited\n@@ -312,1 +312,0 @@\n-                    _value.setTreeShowing(isTreeShowing());\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/SubScene.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.scene.TreeShowingExpression;\n@@ -65,1 +66,1 @@\n-import com.sun.javafx.scene.NodeHelper;\n+\n@@ -152,0 +153,1 @@\n+    private TreeShowingExpression treeShowingExpression;\n@@ -413,1 +415,2 @@\n-            NodeHelper.treeShowingProperty(ownerNode).addListener(weakOwnerNodeListener);\n+            treeShowingExpression = new TreeShowingExpression(ownerNode);\n+            treeShowingExpression.addListener(weakOwnerNodeListener);\n@@ -490,1 +493,5 @@\n-        if (getOwnerNode() != null) NodeHelper.treeShowingProperty(getOwnerNode()).removeListener(weakOwnerNodeListener);\n+        if (treeShowingExpression != null) {\n+            treeShowingExpression.removeListener(weakOwnerNodeListener);\n+            treeShowingExpression.dispose();\n+            treeShowingExpression = null;\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/PopupWindow.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,318 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.scene;\n+\n+import com.sun.javafx.scene.TreeShowingExpression;\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.value.ChangeListener;\n+import javafx.scene.Node;\n+import javafx.scene.Parent;\n+import javafx.scene.Scene;\n+import javafx.scene.SubScene;\n+import javafx.scene.layout.StackPane;\n+import javafx.stage.Stage;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class TreeShowingExpressionTest {\n+    private final Parent root;\n+    private final Node node;\n+    private final TreeShowingExpression expression;\n+\n+    @Parameters\n+    public static Collection<Object[]> parameters() {\n+        Supplier<RootAndNodeToTest> supplier1 = () -> {\n+            Node node = new StackPane();\n+            return new RootAndNodeToTest(new StackPane(node), node);\n+        };\n+\n+        Supplier<RootAndNodeToTest> supplier2 = () -> {\n+            StackPane node = new StackPane();\n+            return new RootAndNodeToTest(new StackPane(new SubScene(node, 100.0, 100.0)), node);\n+        };\n+\n+        return Arrays.asList(new Object[][] { { supplier1 }, { supplier2 } });\n+    }\n+\n+    static class RootAndNodeToTest {\n+        RootAndNodeToTest(Parent root, Node nodeToTest) {\n+            this.root = root;\n+            this.nodeToTest = nodeToTest;\n+        }\n+\n+        Parent root;\n+        Node nodeToTest;\n+    }\n+\n+    public TreeShowingExpressionTest(Supplier<RootAndNodeToTest> nodeSupplier) {\n+        RootAndNodeToTest nodes = nodeSupplier.get();\n+\n+        this.root = nodes.root;\n+        this.node = nodes.nodeToTest;\n+        this.expression = new TreeShowingExpression(this.node);\n+    }\n+\n+    @Test\n+    public void nodeNotAttachedToSceneShouldNotBeShowing() {\n+        assertFalse(expression.get());\n+    }\n+\n+    @Test\n+    public void getShouldTrackChangesInShowingStateForGivenNode() {\n+        assertFalse(expression.get());  \/\/ not showing initially as not attached to a Scene\n+\n+        Scene scene = new Scene(root);\n+\n+        assertFalse(expression.get());  \/\/ not showing because Scene is not attached to a Window\n+\n+        Stage stage = new Stage();\n+        stage.setScene(scene);\n+\n+        assertFalse(expression.get());  \/\/ not showing as Window is not shown\n+\n+        stage.show();\n+\n+        assertTrue(expression.get());  \/\/ showing as Window is shown\n+\n+        stage.hide();\n+\n+        assertFalse(expression.get());  \/\/ not showing again as Window is hidden\n+    }\n+\n+    @Test\n+    public void changeListenerShouldRegisterAndUnregisterCorrectly() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+        ChangeListener<Boolean> listener = (obs, old, current) -> state.set(current);\n+\n+        expression.addListener(listener);\n+\n+        assertNull(state.getAndSet(null));  \/\/ no change fired so far\n+\n+        Stage stage = new Stage();\n+        stage.setScene(new Scene(root));\n+        stage.show();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect a change indicating the node is showing now\n+\n+        expression.removeListener(listener);\n+\n+        stage.hide();\n+\n+        assertNull(state.getAndSet(null));  \/\/ no change fired as listener was unregistered\n+    }\n+\n+    @Test\n+    public void invalidationListenerShouldRegisterAndUnregisterCorrectly() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+        InvalidationListener listener = obs -> state.set(true);\n+\n+        expression.addListener(listener);\n+\n+        assertNull(state.getAndSet(null));  \/\/ no invalidation fired so far\n+\n+        Stage stage = new Stage();\n+        stage.setScene(new Scene(root));\n+        stage.show();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as node is showing now\n+\n+        expression.get();  \/\/ make valid again\n+        expression.removeListener(listener);\n+\n+        stage.hide();\n+\n+        assertNull(state.getAndSet(null));  \/\/ expect no invalidation as listener was unregistered\n+    }\n+\n+    @Test\n+    public void changeListenerShouldTrackShowingState() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+\n+        expression.addListener((obs, old, current) -> state.set(current));\n+\n+        assertNull(state.getAndSet(null));  \/\/ no change fired so far\n+\n+        Scene scene = new Scene(root);\n+\n+        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no change\n+\n+        Stage stage = new Stage();\n+        stage.setWidth(100);\n+        stage.setHeight(100);\n+        stage.setScene(scene);\n+\n+        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no change\n+\n+        stage.show();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect a change indicating the node is showing now\n+\n+        stage.setScene(null);\n+\n+        assertFalse(state.getAndSet(null));  \/\/ detaching stage from scene should fire not showing change\n+\n+        stage.setScene(scene);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ reattaching stage should fire showing change\n+\n+        stage.hide();\n+\n+        assertFalse(state.getAndSet(null));  \/\/ expect a change indicating the node is no longer showing\n+\n+        Stage stage2 = new Stage();\n+        stage2.setWidth(100);\n+        stage2.setHeight(100);\n+        stage2.show();\n+        stage2.setScene(scene);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ switching between invisible\/visible Scene should trigger showing change\n+\n+        stage2.hide();\n+\n+        assertFalse(state.getAndSet(null));  \/\/ hiding attached window should trigger not showing change\n+\n+        stage.show();\n+\n+        assertNull(state.getAndSet(null));  \/\/ changing visibility of unattached stage should not do anything\n+\n+        scene.setRoot(new StackPane());\n+        Scene scene2 = new Scene(root);\n+        stage.setScene(scene2);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ making root part of a different visible scene should trigger showing change\n+    }\n+\n+    @Test\n+    public void invalidationListenerShouldNotifyOfChangesInShowingState() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+\n+        expression.addListener(obs -> state.set(true));\n+\n+        assertNull(state.getAndSet(null));  \/\/ no invalidation fired so far\n+\n+        Scene scene = new Scene(root);\n+\n+        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no invalidation\n+\n+        Stage stage = new Stage();\n+        stage.setWidth(100);\n+        stage.setHeight(100);\n+        stage.setScene(scene);\n+\n+        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no invalidation\n+\n+        stage.show();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as the node is showing now\n+\n+        expression.get();  \/\/ make valid\n+        stage.setScene(null);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ detaching stage from scene should fire invalidation\n+\n+        expression.get();  \/\/ make valid\n+        stage.setScene(scene);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ reattaching stage should fire invalidation\n+\n+        \/\/ didn't make valid here\n+        stage.hide();\n+\n+        assertNull(state.getAndSet(null));  \/\/ expect nothing as expression still invalid\n+\n+        stage.show();\n+        expression.get();  \/\/ make valid\n+        stage.hide();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as the node is no longer showing now\n+\n+        Stage stage2 = new Stage();\n+        stage2.setWidth(100);\n+        stage2.setHeight(100);\n+        stage2.show();\n+        expression.get();  \/\/ make valid\n+        stage2.setScene(scene);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ switching between invisible\/visible Scene should trigger invalidation\n+\n+        expression.get();  \/\/ make valid\n+        stage2.hide();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ hiding attached window should trigger invalidation\n+\n+        expression.get();  \/\/ make valid\n+        stage.show();\n+\n+        assertNull(state.getAndSet(null));  \/\/ changing visibility of unattached stage should not do anything\n+\n+        scene.setRoot(new StackPane());\n+        Scene scene2 = new Scene(root);\n+        expression.get();  \/\/ make valid\n+        stage.setScene(scene2);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ making root part of a different visible scene should trigger invalidation\n+    }\n+\n+    @Test\n+    public void disposeShouldUnregisterListenersOnGivenNode() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+\n+        expression.addListener((obs, old, current) -> state.set(current));\n+\n+        \/\/ verify change listener works:\n+        Stage stage = new Stage();\n+        Scene scene = new Scene(root);\n+        stage.setScene(scene);\n+        stage.show();\n+        assertTrue(state.getAndSet(null));\n+\n+        expression.dispose();\n+\n+        \/\/ verify change listener no longer responds:\n+        stage.hide();\n+        assertNull(state.getAndSet(null));\n+\n+        \/\/ another check:\n+        Stage stage2 = new Stage();\n+        stage2.setWidth(100);\n+        stage2.setHeight(100);\n+        stage2.show();\n+        scene.setRoot(new StackPane());\n+        stage2.setScene(new Scene(root));\n+        assertNull(state.getAndSet(null));\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/TreeShowingExpressionTest.java","additions":318,"deletions":0,"binary":false,"changes":318,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene;\n+\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.StackPane;\n+import javafx.stage.Stage;\n+import javafx.stage.WindowEvent;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import test.util.Util;\n+\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+\/**\n+ * Tests for regressions in performance of manipulating Nodes in a very large\n+ * Scene (see JDK-8252935).\n+ *\n+ * Specifically, this test was created for the Tree Showing property which\n+ * (before this fix) involved registering a listener to Scene and Window by\n+ * each Node, causing large listeners lists on the Window property in Scene\n+ * and the Showing property in Window.  The large lists of listeners would\n+ * cause noticeable performance issues in Scenes with 10-20k+ Nodes (which\n+ * for example can happen with a TableView with many visible small cells).\n+ *\n+ * The goal of this test is *NOT* to measure absolute performance, but to show\n+ * that adding and removing Nodes (which involves registering and unregistering\n+ * listeners) in a very large Scene does not take more than a particular\n+ * threshold of time.\n+ *\n+ * The selected threshold is larger than actual observed time.\n+ * It is not a benchmark value. It is good enough to catch the regression\n+ * in performance, if any.\n+ *\/\n+\n+public class NodeTreeShowingTest {\n+\n+    private static CountDownLatch startupLatch;\n+    private static Stage stage;\n+    private static BorderPane rootPane;\n+\n+    public static class TestApp extends Application {\n+\n+        @Override\n+        public void start(Stage primaryStage) throws Exception {\n+            stage = primaryStage;\n+            rootPane = new BorderPane();\n+            stage.setScene(new Scene(rootPane));\n+            stage.addEventHandler(WindowEvent.WINDOW_SHOWN, e -> {\n+                Platform.runLater(() -> startupLatch.countDown());\n+            });\n+            stage.show();\n+        }\n+    }\n+\n+    @BeforeClass\n+    public static void initFX() throws Exception {\n+        startupLatch = new CountDownLatch(1);\n+        new Thread(() -> Application.launch(NodeTreeShowingTest.TestApp.class, (String[]) null)).start();\n+\n+        assertTrue(\"Timeout waiting for FX runtime to start\", startupLatch.await(15, TimeUnit.SECONDS));\n+    }\n+\n+    private StackPane createNodesRecursively(int count, int level) {\n+        StackPane pane = new StackPane();\n+\n+        for (int i = 0; i < count; i++) {\n+            pane.getChildren().add(level == 1 ? new StackPane() : createNodesRecursively(count, level - 1));\n+        }\n+\n+        return pane;\n+    }\n+\n+    \/**\n+     * This tests how quickly Nodes can be added and removed from a very large Scene.  Specifically,\n+     * this test was created to ensure that not every Node in the Scene creates a listener on its\n+     * Scene (and\/or its associated Window).  With a large amount of Nodes in a Scene the listener\n+     * lists of the associated Scene and\/or Window can become very large and adding or removing\n+     * a Node takes a performance hit.\n+     *\/\n+    @Test\n+    public void testAddRemovalSpeedInHugeScene() throws Exception {\n+        Random rnd = new Random(0);  \/\/ seed random to keep it predictable\n+        int loopCount = 10000;\n+        int levels = 13;\n+        int nodesPerLevel = 2;  \/\/ total nodes is (nodesPerLevel ^ levels) * 2 - 1\n+        int leafCount = (int)Math.pow(nodesPerLevel, levels);\n+        int total = leafCount * 2 - 1;\n+        StackPane testNode = new StackPane();\n+        StackPane root = createNodesRecursively(nodesPerLevel, levels);\n+        AtomicLong bestMillis = new AtomicLong(Long.MAX_VALUE);\n+\n+        Util.runAndWait(() -> {\n+            rootPane.setCenter(root);\n+        });\n+\n+        for (int j = 0; j < 5; j++) {\n+            int loopNumber = j + 1;\n+\n+            Util.runAndWait(() -> {\n+                \/\/ Compute time it takes to add\/remove Nodes at random spots\n+                long startTime = System.currentTimeMillis();\n+\n+                for (int i = 0; i < loopCount; i++) {\n+                    \/\/ Find a random leaf to remove\/re-add a child:\n+                    int index = rnd.nextInt(leafCount);\n+                    StackPane current = root;\n+\n+                    while (index >= nodesPerLevel) {\n+                        current = (StackPane) current.getChildren().get(index % nodesPerLevel);\n+                        index \/= nodesPerLevel;\n+                    }\n+\n+                    current.getChildren().add(current.getChildren().remove(index));\n+                }\n+\n+                long endTime = System.currentTimeMillis();\n+\n+                bestMillis.set(Math.min(endTime - startTime, bestMillis.get()));\n+\n+                System.out.println(\"Loop \" + loopNumber + \": Time to add\/remove \" + loopCount + \" nodes in \"\n+                        + \"a Scene consisting of \" + total + \" nodes = \" + (endTime - startTime) + \" mSec\");\n+            });\n+        }\n+\n+        \/\/ NOTE : 800 mSec is not a benchmark value\n+        \/\/ It is good enough to catch the regression in performance, if any\n+        assertTrue(\"Time to add\/remove \" + loopCount + \" nodes in a large Scene is more than 800 mSec (\" + bestMillis.get() + \")\", bestMillis.get() <= 800);\n+    }\n+\n+    @AfterClass\n+    public static void teardownOnce() {\n+        Platform.runLater(() -> {\n+            stage.hide();\n+            Platform.exit();\n+        });\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/NodeTreeShowingTest.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"}]}