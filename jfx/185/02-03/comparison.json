{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/ProgressIndicatorSkin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-        nodeSceneChangedListener.changed(null, null, node.getScene());\n+        nodeSceneChangedListener.changed(null, null, node.getScene());  \/\/ registers listeners on Window\/Showing\n@@ -100,0 +100,3 @@\n+\n+        valid = false;  \/\/ prevents unregistration from triggering an invalidation notification\n+        nodeSceneChangedListener.changed(null, node.getScene(), null);  \/\/ unregisters listeners on Window\/Showing\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/TreeShowingExpression.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Node.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/SubScene.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/PopupWindow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,318 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.scene;\n+\n+import com.sun.javafx.scene.TreeShowingExpression;\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.value.ChangeListener;\n+import javafx.scene.Node;\n+import javafx.scene.Parent;\n+import javafx.scene.Scene;\n+import javafx.scene.SubScene;\n+import javafx.scene.layout.StackPane;\n+import javafx.stage.Stage;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class TreeShowingExpressionTest {\n+    private final Parent root;\n+    private final Node node;\n+    private final TreeShowingExpression expression;\n+\n+    @Parameters\n+    public static Collection<Object[]> parameters() {\n+        Supplier<RootAndNodeToTest> supplier1 = () -> {\n+            Node node = new StackPane();\n+            return new RootAndNodeToTest(new StackPane(node), node);\n+        };\n+\n+        Supplier<RootAndNodeToTest> supplier2 = () -> {\n+            StackPane node = new StackPane();\n+            return new RootAndNodeToTest(new StackPane(new SubScene(node, 100.0, 100.0)), node);\n+        };\n+\n+        return Arrays.asList(new Object[][] { { supplier1 }, { supplier2 } });\n+    }\n+\n+    static class RootAndNodeToTest {\n+        RootAndNodeToTest(Parent root, Node nodeToTest) {\n+            this.root = root;\n+            this.nodeToTest = nodeToTest;\n+        }\n+\n+        Parent root;\n+        Node nodeToTest;\n+    }\n+\n+    public TreeShowingExpressionTest(Supplier<RootAndNodeToTest> nodeSupplier) {\n+        RootAndNodeToTest nodes = nodeSupplier.get();\n+\n+        this.root = nodes.root;\n+        this.node = nodes.nodeToTest;\n+        this.expression = new TreeShowingExpression(this.node);\n+    }\n+\n+    @Test\n+    public void nodeNotAttachedToSceneShouldNotBeShowing() {\n+        assertFalse(expression.get());\n+    }\n+\n+    @Test\n+    public void getShouldTrackChangesInShowingStateForGivenNode() {\n+        assertFalse(expression.get());  \/\/ not showing initially as not attached to a Scene\n+\n+        Scene scene = new Scene(root);\n+\n+        assertFalse(expression.get());  \/\/ not showing because Scene is not attached to a Window\n+\n+        Stage stage = new Stage();\n+        stage.setScene(scene);\n+\n+        assertFalse(expression.get());  \/\/ not showing as Window is not shown\n+\n+        stage.show();\n+\n+        assertTrue(expression.get());  \/\/ showing as Window is shown\n+\n+        stage.hide();\n+\n+        assertFalse(expression.get());  \/\/ not showing again as Window is hidden\n+    }\n+\n+    @Test\n+    public void changeListenerShouldRegisterAndUnregisterCorrectly() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+        ChangeListener<Boolean> listener = (obs, old, current) -> state.set(current);\n+\n+        expression.addListener(listener);\n+\n+        assertNull(state.getAndSet(null));  \/\/ no change fired so far\n+\n+        Stage stage = new Stage();\n+        stage.setScene(new Scene(root));\n+        stage.show();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect a change indicating the node is showing now\n+\n+        expression.removeListener(listener);\n+\n+        stage.hide();\n+\n+        assertNull(state.getAndSet(null));  \/\/ no change fired as listener was unregistered\n+    }\n+\n+    @Test\n+    public void invalidationListenerShouldRegisterAndUnregisterCorrectly() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+        InvalidationListener listener = obs -> state.set(true);\n+\n+        expression.addListener(listener);\n+\n+        assertNull(state.getAndSet(null));  \/\/ no invalidation fired so far\n+\n+        Stage stage = new Stage();\n+        stage.setScene(new Scene(root));\n+        stage.show();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as node is showing now\n+\n+        expression.get();  \/\/ make valid again\n+        expression.removeListener(listener);\n+\n+        stage.hide();\n+\n+        assertNull(state.getAndSet(null));  \/\/ expect no invalidation as listener was unregistered\n+    }\n+\n+    @Test\n+    public void changeListenerShouldTrackShowingState() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+\n+        expression.addListener((obs, old, current) -> state.set(current));\n+\n+        assertNull(state.getAndSet(null));  \/\/ no change fired so far\n+\n+        Scene scene = new Scene(root);\n+\n+        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no change\n+\n+        Stage stage = new Stage();\n+        stage.setWidth(100);\n+        stage.setHeight(100);\n+        stage.setScene(scene);\n+\n+        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no change\n+\n+        stage.show();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect a change indicating the node is showing now\n+\n+        stage.setScene(null);\n+\n+        assertFalse(state.getAndSet(null));  \/\/ detaching stage from scene should fire not showing change\n+\n+        stage.setScene(scene);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ reattaching stage should fire showing change\n+\n+        stage.hide();\n+\n+        assertFalse(state.getAndSet(null));  \/\/ expect a change indicating the node is no longer showing\n+\n+        Stage stage2 = new Stage();\n+        stage2.setWidth(100);\n+        stage2.setHeight(100);\n+        stage2.show();\n+        stage2.setScene(scene);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ switching between invisible\/visible Scene should trigger showing change\n+\n+        stage2.hide();\n+\n+        assertFalse(state.getAndSet(null));  \/\/ hiding attached window should trigger not showing change\n+\n+        stage.show();\n+\n+        assertNull(state.getAndSet(null));  \/\/ changing visibility of unattached stage should not do anything\n+\n+        scene.setRoot(new StackPane());\n+        Scene scene2 = new Scene(root);\n+        stage.setScene(scene2);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ making root part of a different visible scene should trigger showing change\n+    }\n+\n+    @Test\n+    public void invalidationListenerShouldNotifyOfChangesInShowingState() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+\n+        expression.addListener(obs -> state.set(true));\n+\n+        assertNull(state.getAndSet(null));  \/\/ no invalidation fired so far\n+\n+        Scene scene = new Scene(root);\n+\n+        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no invalidation\n+\n+        Stage stage = new Stage();\n+        stage.setWidth(100);\n+        stage.setHeight(100);\n+        stage.setScene(scene);\n+\n+        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no invalidation\n+\n+        stage.show();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as the node is showing now\n+\n+        expression.get();  \/\/ make valid\n+        stage.setScene(null);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ detaching stage from scene should fire invalidation\n+\n+        expression.get();  \/\/ make valid\n+        stage.setScene(scene);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ reattaching stage should fire invalidation\n+\n+        \/\/ didn't make valid here\n+        stage.hide();\n+\n+        assertNull(state.getAndSet(null));  \/\/ expect nothing as expression still invalid\n+\n+        stage.show();\n+        expression.get();  \/\/ make valid\n+        stage.hide();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as the node is no longer showing now\n+\n+        Stage stage2 = new Stage();\n+        stage2.setWidth(100);\n+        stage2.setHeight(100);\n+        stage2.show();\n+        expression.get();  \/\/ make valid\n+        stage2.setScene(scene);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ switching between invisible\/visible Scene should trigger invalidation\n+\n+        expression.get();  \/\/ make valid\n+        stage2.hide();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ hiding attached window should trigger invalidation\n+\n+        expression.get();  \/\/ make valid\n+        stage.show();\n+\n+        assertNull(state.getAndSet(null));  \/\/ changing visibility of unattached stage should not do anything\n+\n+        scene.setRoot(new StackPane());\n+        Scene scene2 = new Scene(root);\n+        expression.get();  \/\/ make valid\n+        stage.setScene(scene2);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ making root part of a different visible scene should trigger invalidation\n+    }\n+\n+    @Test\n+    public void disposeShouldUnregisterListenersOnGivenNode() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+\n+        expression.addListener((obs, old, current) -> state.set(current));\n+\n+        \/\/ verify change listener works:\n+        Stage stage = new Stage();\n+        Scene scene = new Scene(root);\n+        stage.setScene(scene);\n+        stage.show();\n+        assertTrue(state.getAndSet(null));\n+\n+        expression.dispose();\n+\n+        \/\/ verify change listener no longer responds:\n+        stage.hide();\n+        assertNull(state.getAndSet(null));\n+\n+        \/\/ another check:\n+        Stage stage2 = new Stage();\n+        stage2.setWidth(100);\n+        stage2.setHeight(100);\n+        stage2.show();\n+        scene.setRoot(new StackPane());\n+        stage2.setScene(new Scene(root));\n+        assertNull(state.getAndSet(null));\n+    }\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/TreeShowingExpressionTest.java","additions":318,"deletions":0,"binary":false,"changes":318,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,2 +48,2 @@\n- * TODO fix\n- * This test is based on the test case reported in JDK-8209830\n+ * Tests for regressions in performance of manipulating Nodes in a very large\n+ * Scene (see JDK-8252935).\n@@ -51,3 +51,6 @@\n- * Redundant CSS Re-application was avoided in JDK-8193445.\n- * It results in faster application of CSS on Controls (Nodes). In turn,\n- * resulting in improved Node creation\/addition time to a Scene.\n+ * Specifically, this test was created for the Tree Showing property which\n+ * (before this fix) involved registering a listener to Scene and Window by\n+ * each Node, causing large listeners lists on the Window property in Scene\n+ * and the Showing property in Window.  The large lists of listeners would\n+ * cause noticeable performance issues in Scenes with 10-20k+ Nodes (which\n+ * for example can happen with a TableView with many visible small cells).\n@@ -56,2 +59,3 @@\n- * creating and adding 500 Nodes to a scene does not take more than a\n- * particular threshold of time.\n+ * that adding and removing Nodes (which involves registering and unregistering\n+ * listeners) in a very large Scene does not take more than a particular\n+ * threshold of time.\n@@ -59,1 +63,1 @@\n- * The selected thresold is larger than actual observed time.\n+ * The selected threshold is larger than actual observed time.\n@@ -125,1 +129,1 @@\n-        for(int j = 0; j < 5; j++) {\n+        for (int j = 0; j < 5; j++) {\n@@ -156,1 +160,1 @@\n-        assertTrue(\"Time to add\/remove \" + loopCount + \" nodes in a large Scene is more than 800 mSec\", bestMillis.get() <= 800);\n+        assertTrue(\"Time to add\/remove \" + loopCount + \" nodes in a large Scene is more than 800 mSec (\" + bestMillis.get() + \")\", bestMillis.get() <= 800);\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/NodeTreeShowingTest.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"}]}