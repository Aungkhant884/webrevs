{"files":[{"patch":"@@ -340,0 +340,1 @@\n+            updateEditing();\n@@ -542,14 +543,13 @@\n-\n-        \/\/ Check that the list is specified, and my index is not -1\n-        if (index != -1 && list != null) {\n-            \/\/ If my index is the index being edited and I'm not currently in\n-            \/\/ the edit mode, then I need to enter the edit mode\n-            if (index == editIndex && !editing) {\n-                startEdit();\n-            } else if (index != editIndex && editing) {\n-                \/\/ If my index is not the one being edited then I need to cancel\n-                \/\/ the edit. The tricky thing here is that as part of this call\n-                \/\/ I cannot end up calling list.edit(-1) the way that the standard\n-                \/\/ cancelEdit method would do. Yet, I need to call cancelEdit\n-                \/\/ so that subclasses which override cancelEdit can execute. So,\n-                \/\/ I have to use a kind of hacky flag workaround.\n+        final boolean match = (list != null) && (index != -1) && (index == editIndex);\n+\n+        if (match && !editing) {\n+            startEdit();\n+        } else if (!match && editing) {\n+            \/\/ If my index is not the one being edited then I need to cancel\n+            \/\/ the edit. The tricky thing here is that as part of this call\n+            \/\/ I cannot end up calling list.edit(-1) the way that the standard\n+            \/\/ cancelEdit method would do. Yet, I need to call cancelEdit\n+            \/\/ so that subclasses which override cancelEdit can execute. So,\n+            \/\/ I have to use a kind of hacky flag workaround.\n+            try {\n+                \/\/ try-finally to make certain that the flag is reliably reset to true\n@@ -558,0 +558,1 @@\n+            } finally {\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/ListCell.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import javafx.scene.control.ListView.EditEvent;\n@@ -41,0 +42,3 @@\n+import java.util.List;\n+import java.util.ArrayList;\n+import org.junit.After;\n@@ -56,0 +60,8 @@\n+        Thread.currentThread().setUncaughtExceptionHandler((thread, throwable) -> {\n+            if (throwable instanceof RuntimeException) {\n+                throw (RuntimeException)throwable;\n+            } else {\n+                Thread.currentThread().getThreadGroup().uncaughtException(thread, throwable);\n+            }\n+        });\n+\n@@ -61,0 +73,4 @@\n+    @After public void cleanup() {\n+        Thread.currentThread().setUncaughtExceptionHandler(null);\n+    }\n+\n@@ -836,0 +852,119 @@\n+    @Test\n+    public void testChangeIndexToEditing1_jdk_8264127() {\n+        assertChangeIndexToEditing(0, 1);\n+    }\n+\n+    @Test\n+    public void testChangeIndexToEditing2_jdk_8264127() {\n+        assertChangeIndexToEditing(-1, 1);\n+    }\n+\n+    @Test\n+    public void testChangeIndexToEditing3_jdk_8264127() {\n+        assertChangeIndexToEditing(1, 0);\n+    }\n+\n+    @Test\n+    public void testChangeIndexToEditing4_jdk_8264127() {\n+        assertChangeIndexToEditing(-1, 0);\n+    }\n+\n+\n+\n+    private void assertChangeIndexToEditing(int initialCellIndex, int listEditingIndex) {\n+        list.getFocusModel().focus(-1);\n+        List<EditEvent> events = new ArrayList<EditEvent>();\n+        list.setOnEditStart(e -> {\n+            events.add(e);\n+        });\n+        list.setEditable(true);\n+        cell.updateListView(list);\n+        cell.updateIndex(initialCellIndex);\n+        list.edit(listEditingIndex);\n+        assertEquals(\"sanity: list editingIndex \", listEditingIndex, list.getEditingIndex());\n+        assertFalse(\"sanity: cell must not be editing\", cell.isEditing());\n+        cell.updateIndex(listEditingIndex);\n+        assertEquals(\"sanity: index updated \", listEditingIndex, cell.getIndex());\n+        assertEquals(\"list editingIndex unchanged by cell\", listEditingIndex, list.getEditingIndex());\n+        assertTrue(cell.isEditing());\n+        assertEquals(1, events.size());\n+    }\n+\n+    @Test\n+    public void testChangeIndexOffEditing0_jdk_8264127() {\n+        assertUpdateCellIndexOffEditing(1, 0);\n+    }\n+    @Test\n+    public void testChangeIndexOffEditing1_jdk_8264127() {\n+        assertUpdateCellIndexOffEditing(1, -1);\n+    }\n+    @Test\n+    public void testChangeIndexOffEditing2_jdk_8264127() {\n+        assertUpdateCellIndexOffEditing(0, 1);\n+    }\n+    @Test\n+    public void testChangeIndexOffEditing3_jdk_8264127() {\n+        assertUpdateCellIndexOffEditing(0, -1);\n+    }\n+\n+    public void assertUpdateCellIndexOffEditing(int editingIndex, int cancelIndex) {\n+        list.getFocusModel().focus(-1);\n+        List<EditEvent> events = new ArrayList<EditEvent>();\n+        list.setOnEditCancel(e -> {\n+            events.add(e);\n+        });\n+        list.setEditable(true);\n+        cell.updateListView(list);\n+        cell.updateIndex(editingIndex);\n+        list.edit(editingIndex);\n+        assertEquals(\"sanity: list editingIndex \", editingIndex, list.getEditingIndex());\n+        assertTrue(\"sanity: cell must be editing\", cell.isEditing());\n+        cell.updateIndex(cancelIndex); \/\/ change cell index to negative\n+        assertEquals(\"sanity: index updated \", cancelIndex, cell.getIndex());\n+        assertEquals(\"list editingIndex unchanged by cell\", editingIndex, list.getEditingIndex());\n+        assertFalse(\"cell must not be editing if cell index is \" + cell.getIndex(), cell.isEditing());\n+        assertEquals(1, events.size());\n+    }\n+\n+    @Test\n+    public void testMisbehavingCancelEditTerminatesEdit() {\n+        ListCell<String> cell = new MisbehavingOnCancelListCell<>();\n+\n+        list.setEditable(true);\n+        cell.updateListView(list);\n+\n+        int editingIndex = 1;\n+        int intermediate = 0;\n+        int notEditingIndex = -1;\n+        cell.updateIndex(editingIndex);\n+        list.edit(editingIndex);\n+        assertTrue(\"sanity: \", cell.isEditing());\n+        try {\n+            list.edit(intermediate);\n+        } catch (Exception ex) {\n+            \/\/ just catching to test in finally\n+        } finally {\n+            assertFalse(\"cell must not be editing\", cell.isEditing());\n+            assertEquals(\"list must be editing at intermediate index\", intermediate, list.getEditingIndex());\n+        }\n+        \/\/ test editing: second round\n+        \/\/ switch cell off editing by cell api\n+        list.edit(editingIndex);\n+        assertTrue(\"sanity: \", cell.isEditing());\n+        try {\n+            cell.cancelEdit();\n+        } catch (Exception ex) {\n+            \/\/ just catching to test in finally\n+        } finally {\n+            assertFalse(\"cell must not be editing\", cell.isEditing());\n+            assertEquals(\"list editing must be cancelled by cell\", notEditingIndex, list.getEditingIndex());\n+        }\n+    }\n+\n+    public static class MisbehavingOnCancelListCell<T> extends ListCell<T> {\n+        @Override\n+        public void cancelEdit() {\n+            super.cancelEdit();\n+            throw new RuntimeException(\"violating contract\");\n+        }\n+    }\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/ListCellTest.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"modified"}]}