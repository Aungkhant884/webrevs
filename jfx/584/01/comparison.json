{"files":[{"patch":"@@ -406,0 +406,3 @@\n+    private final Map<TKPulseListener,AccessControlContext> cleanupListeners =\n+            new WeakHashMap<TKPulseListener,AccessControlContext>();\n+    @SuppressWarnings(\"removal\")\n@@ -440,0 +443,2 @@\n+        final Map<TKPulseListener,AccessControlContext> cleanupList =\n+                new WeakHashMap<TKPulseListener,AccessControlContext>();\n@@ -445,0 +450,2 @@\n+            cleanupList.putAll(cleanupListeners);\n+            cleanupListeners.clear();\n@@ -455,0 +462,3 @@\n+        for (@SuppressWarnings(\"removal\") Map.Entry<TKPulseListener,AccessControlContext> entry : cleanupList.entrySet()) {\n+            runPulse(entry.getKey(), entry.getValue());\n+        }\n@@ -506,0 +516,5 @@\n+    public void addCleanupListener(TKPulseListener listener) {\n+        AccessControlContext acc = AccessController.getContext();\n+        cleanupListeners.put(listener,acc);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/Toolkit.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import javafx.beans.value.ChangeListener;\n@@ -547,0 +548,1 @@\n+            checkCleanDirtyNodes();\n@@ -720,0 +722,15 @@\n+    private boolean cleanupAdded = false;\n+    private TKPulseListener cleanupListener = () -> {\n+        cleanupAdded = false;\n+        \/\/ JDK-8269907 - This is important, to avoid memoryleaks in dirtyNodes and Parent.removed\n+        scenePulseListener.synchronizeSceneNodes();\n+    };\n+    private void checkCleanDirtyNodes() {\n+        if(!cleanupAdded) {\n+            if((window.get() == null || !window.get().isShowing()) && dirtyNodesSize > 0) {\n+                Toolkit.getToolkit().addCleanupListener(cleanupListener);\n+                cleanupAdded = true;\n+            }\n+        }\n+    }\n+\n@@ -4084,0 +4101,1 @@\n+                oldWindow.showingProperty().removeListener(sceneWindowShowingListener);\n@@ -4088,0 +4106,1 @@\n+                window.showingProperty().addListener(sceneWindowShowingListener);\n@@ -4093,0 +4112,2 @@\n+\n+            checkCleanDirtyNodes();\n@@ -4095,0 +4116,1 @@\n+        private final ChangeListener<Boolean> sceneWindowShowingListener = (p, o, n) -> {checkCleanDirtyNodes(); } ;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene;\n+\n+import javafx.application.Platform;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Label;\n+import javafx.scene.layout.StackPane;\n+import javafx.stage.Stage;\n+import junit.framework.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import test.util.Util;\n+import test.util.memory.JMemoryBuddy;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static test.util.Util.TIMEOUT;\n+\n+public class DirtyNodesLeakTest {\n+\n+    @BeforeClass\n+    public static void initFX() throws Exception {\n+        CountDownLatch startupLatch = new CountDownLatch(1);\n+        Platform.setImplicitExit(false);\n+        Platform.startup(startupLatch::countDown);\n+        Assert.assertTrue(\"Timeout waiting for FX runtime to start\",\n+                startupLatch.await(TIMEOUT, TimeUnit.MILLISECONDS));\n+    }\n+\n+    @Test\n+    public void leakDirtyNodeAndParentRemoved() throws Exception {\n+        JMemoryBuddy.memoryTest((checker) -> {\n+            CountDownLatch showingLatch = new CountDownLatch(1);\n+            Util.runAndWait(() -> {\n+                Stage stage = new Stage();\n+                Label label = new Label(\"Hello!!\");\n+                StackPane root = new StackPane(label);\n+                Scene scene = new Scene(root);\n+                stage.setScene(scene);\n+\n+                checker.setAsReferenced(scene);\n+                checker.assertCollectable(label);\n+                stage.setOnShown(l -> {\n+                    Platform.runLater(() -> {\n+                        root.getChildren().clear();\n+                        stage.close();\n+                        showingLatch.countDown();\n+                    });\n+                });\n+                stage.show();\n+            });\n+            try {\n+                Assert.assertTrue(\"Timeout waiting for setOnShown\", showingLatch.await(15, TimeUnit.SECONDS));\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/DirtyNodesLeakTest.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"}]}