{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import java.util.concurrent.TimeUnit;\n+\n@@ -29,0 +31,2 @@\n+    static final long INITIAL_VELOCITY_THRESHOLD_NANOS = 100L * 1000;\n+    static final double NANOS_TO_SECONDS = 1.0 \/ TimeUnit.SECONDS.toNanos(1);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/GestureRecognizer.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,2 @@\n-    private ViewScene scene;\n+    private final ViewScene scene;\n+    private final PrivilegedSceneListenerAccessor privilegedSceneListenerAccessor;\n@@ -85,0 +86,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -87,0 +89,9 @@\n+        this.privilegedSceneListenerAccessor = consumer -> AccessController.doPrivileged(\n+            (PrivilegedAction<Void>) () -> {\n+                if (scene.sceneListener != null) {\n+                    consumer.accept(scene.sceneListener);\n+                }\n+                return null;\n+            },\n+            scene.getAccessControlContext()\n+        );\n@@ -98,1 +109,1 @@\n-            gestures.add(new RotateGestureRecognizer(scene));\n+            gestures.add(new RotateGestureRecognizer(privilegedSceneListenerAccessor));\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/GlassViewEventHandler.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,13 @@\n+package com.sun.javafx.tk.quantum;\n+\n+import java.util.function.Consumer;\n+\n+import com.sun.javafx.tk.TKSceneListener;\n+\n+\/**\n+ * Interface that allows access to {@link TKSceneListener} when it is\n+ * not {@code null}.\n+ *\/\n+public interface PrivilegedSceneListenerAccessor {\n+    void withSceneListener(Consumer<TKSceneListener> consumer);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/PrivilegedSceneListenerAccessor.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -44,2 +44,2 @@\n-class RotateGestureRecognizer implements GestureRecognizer {\n-    private ViewScene scene;\n+public class RotateGestureRecognizer implements GestureRecognizer {\n+    private PrivilegedSceneListenerAccessor accessor;\n@@ -95,2 +95,2 @@\n-    RotateGestureRecognizer(final ViewScene scene) {\n-        this.scene = scene;\n+    public RotateGestureRecognizer(PrivilegedSceneListenerAccessor accessor) {\n+        this.accessor = accessor;\n@@ -317,1 +317,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -319,15 +318,13 @@\n-        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-            if (scene.sceneListener != null) {\n-                scene.sceneListener.rotateEvent(RotateEvent.ROTATION_STARTED,\n-                    0, 0,\n-                    centerX, centerY,\n-                    centerAbsX, centerAbsY,\n-                    (modifiers & KeyEvent.MODIFIER_SHIFT) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_CONTROL) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_ALT) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_WINDOWS) != 0,\n-                    direct,\n-                    false \/*inertia*\/);\n-            }\n-            return null;\n-        }, scene.getAccessControlContext());\n+        accessor.withSceneListener(sceneListener -> {\n+            sceneListener.rotateEvent(RotateEvent.ROTATION_STARTED,\n+                0, 0,\n+                centerX, centerY,\n+                centerAbsX, centerAbsY,\n+                (modifiers & KeyEvent.MODIFIER_SHIFT) != 0,\n+                (modifiers & KeyEvent.MODIFIER_CONTROL) != 0,\n+                (modifiers & KeyEvent.MODIFIER_ALT) != 0,\n+                (modifiers & KeyEvent.MODIFIER_WINDOWS) != 0,\n+                direct,\n+                false  \/\/ inertia\n+            );\n+        });\n@@ -336,1 +333,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -338,14 +334,12 @@\n-        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-            if (scene.sceneListener != null) {\n-                scene.sceneListener.rotateEvent(RotateEvent.ROTATE,\n-                    currentRotation, totalRotation,\n-                    centerX, centerY,\n-                    centerAbsX, centerAbsY,\n-                    (modifiers & KeyEvent.MODIFIER_SHIFT) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_CONTROL) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_ALT) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_WINDOWS) != 0,\n-                    direct, isInertia);\n-            }\n-            return null;\n-        }, scene.getAccessControlContext());\n+        accessor.withSceneListener(sceneListener -> {\n+            sceneListener.rotateEvent(RotateEvent.ROTATE,\n+                currentRotation, totalRotation,\n+                centerX, centerY,\n+                centerAbsX, centerAbsY,\n+                (modifiers & KeyEvent.MODIFIER_SHIFT) != 0,\n+                (modifiers & KeyEvent.MODIFIER_CONTROL) != 0,\n+                (modifiers & KeyEvent.MODIFIER_ALT) != 0,\n+                (modifiers & KeyEvent.MODIFIER_WINDOWS) != 0,\n+                direct, isInertia\n+            );\n+        });\n@@ -354,1 +348,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -356,15 +349,13 @@\n-        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-            if (scene.sceneListener != null) {\n-                scene.sceneListener.rotateEvent(RotateEvent.ROTATION_FINISHED,\n-                    0, totalRotation,\n-                    centerX, centerY,\n-                    centerAbsX, centerAbsY,\n-                    (modifiers & KeyEvent.MODIFIER_SHIFT) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_CONTROL) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_ALT) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_WINDOWS) != 0,\n-                    direct,\n-                    false \/*inertia*\/);\n-            }\n-            return null;\n-        }, scene.getAccessControlContext());\n+        accessor.withSceneListener(sceneListener -> {\n+            sceneListener.rotateEvent(RotateEvent.ROTATION_FINISHED,\n+                0, totalRotation,\n+                centerX, centerY,\n+                centerAbsX, centerAbsY,\n+                (modifiers & KeyEvent.MODIFIER_SHIFT) != 0,\n+                (modifiers & KeyEvent.MODIFIER_CONTROL) != 0,\n+                (modifiers & KeyEvent.MODIFIER_ALT) != 0,\n+                (modifiers & KeyEvent.MODIFIER_WINDOWS) != 0,\n+                direct,\n+                false  \/\/ inertia\n+            );\n+        });\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/RotateGestureRecognizer.java","additions":42,"deletions":51,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import com.sun.glass.events.KeyEvent;\n-import com.sun.glass.events.TouchEvent;\n-\n@@ -35,2 +32,5 @@\n-import javafx.util.Duration;\n-import javafx.scene.input.ScrollEvent;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.sun.glass.events.KeyEvent;\n+import com.sun.glass.events.TouchEvent;\n+\n@@ -43,0 +43,2 @@\n+import javafx.scene.input.ScrollEvent;\n+import javafx.util.Duration;\n@@ -45,5 +47,8 @@\n-    \/\/ gesture will be activated if |scroll amount| > SCROLL_THRESHOLD\n-    private static double SCROLL_THRESHOLD = 10; \/\/in pixels\n-    private static boolean SCROLL_INERTIA_ENABLED = true;\n-    private static double MAX_INITIAL_VELOCITY = 1000;\n-    private static double SCROLL_INERTIA_MILLIS = 1500;\n+    private static final double MAX_INITIAL_VELOCITY = 1000;\n+    private static final double SCROLL_INERTIA_MILLIS = 1500;\n+    private static final long SCROLL_INERTIA_THRESHOLD_NANOS = TimeUnit.MILLISECONDS.toNanos(300);\n+\n+    \/\/ gesture will be activated if |scroll amount| > scrollThreshold\n+    private static double scrollThreshold = 10; \/\/in pixels\n+    private static boolean scrollInertiaEnabled = true;\n+\n@@ -55,1 +60,1 @@\n-                SCROLL_THRESHOLD = Double.valueOf(s);\n+                scrollThreshold = Double.valueOf(s);\n@@ -59,1 +64,1 @@\n-                SCROLL_INERTIA_ENABLED = Boolean.valueOf(s);\n+                scrollInertiaEnabled = Boolean.valueOf(s);\n@@ -65,1 +70,3 @@\n-    private ViewScene scene;\n+    private final Timeline inertiaTimeline = new Timeline();\n+    private final DoubleProperty inertiaScrollVelocity = new SimpleDoubleProperty();\n+    private final Map<Long, TouchPointTracker> trackers = new HashMap<>();\n@@ -67,0 +74,1 @@\n+    private ViewScene scene;\n@@ -68,7 +76,2 @@\n-    private Timeline inertiaTimeline = new Timeline();\n-    private DoubleProperty inertiaScrollVelocity = new SimpleDoubleProperty();\n-    private double initialInertiaScrollVelocity = 0;\n-    private double scrollStartTime = 0;\n-    private double lastTouchEventTime = 0;\n-\n-    private Map<Long, TouchPointTracker> trackers = new HashMap<>();\n+    private double initialInertiaScrollVelocity;\n+    private long scrollStartNanos;\n@@ -79,1 +82,1 @@\n-    private int currentTouchCount = 0;\n+    private int currentTouchCount;\n@@ -91,1 +94,1 @@\n-    double inertiaLastTime = 0;\n+    private double inertiaLastTime;\n@@ -126,1 +129,1 @@\n-                touchPressed(touchId, time, x, y, xAbs, yAbs);\n+                touchPressed(touchId, x, y, xAbs, yAbs);\n@@ -131,1 +134,1 @@\n-                touchMoved(touchId, time, x, y, xAbs, yAbs);\n+                touchMoved(touchId, x, y, xAbs, yAbs);\n@@ -135,1 +138,1 @@\n-                touchReleased(touchId, time, x, y, xAbs, yAbs);\n+                touchReleased(touchId);\n@@ -165,2 +168,1 @@\n-    public void notifyEndTouchEvent(long time) {\n-        lastTouchEventTime = time;\n+    public void notifyEndTouchEvent(long nanos) {\n@@ -176,3 +178,4 @@\n-                if (SCROLL_INERTIA_ENABLED) {\n-                    double timeFromLastScroll = ((double)time - scrollStartTime) \/ 1000000;\n-                    if (timeFromLastScroll < 300) {\n+                if (scrollInertiaEnabled) {\n+                    double nanosSinceLastScroll = nanos - scrollStartNanos;\n+\n+                    if (nanosSinceLastScroll < SCROLL_INERTIA_THRESHOLD_NANOS) {\n@@ -191,4 +194,1 @@\n-                                event -> {\n-                                    \/\/stop inertia\n-                                    reset();\n-                                },\n+                                event -> reset(),  \/\/ stop inertia\n@@ -235,1 +235,1 @@\n-                    if ( Math.abs(deltaX) > SCROLL_THRESHOLD || Math.abs(deltaY) > SCROLL_THRESHOLD) {\n+                    if ( Math.abs(deltaX) > scrollThreshold || Math.abs(deltaY) > scrollThreshold) {\n@@ -245,2 +245,3 @@\n-                    double timePassed = ((double)time - scrollStartTime) \/ 1000000000;\n-                    if (timePassed > 1e-4) {\n+                    long nanosPassed = nanos - scrollStartNanos;\n+\n+                    if (nanosPassed > INITIAL_VELOCITY_THRESHOLD_NANOS) {\n@@ -251,1 +252,1 @@\n-                        initialInertiaScrollVelocity = scrollMagnitude \/ timePassed;\n+                        initialInertiaScrollVelocity = scrollMagnitude \/ nanosPassed * NANOS_TO_SECONDS;\n@@ -253,1 +254,1 @@\n-                        scrollStartTime = time;\n+                        scrollStartNanos = nanos;\n@@ -329,1 +330,1 @@\n-    public void params(int modifiers, boolean direct) {\n+    private void params(int modifiers, boolean direct) {\n@@ -334,1 +335,1 @@\n-    public void touchPressed(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n+    private void touchPressed(long id, int x, int y, int xAbs, int yAbs) {\n@@ -337,1 +338,1 @@\n-        tracker.update(nanos, x, y, xAbs, yAbs);\n+        tracker.update(x, y, xAbs, yAbs);\n@@ -341,1 +342,1 @@\n-    public void touchReleased(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n+    private void touchReleased(long id) {\n@@ -355,1 +356,1 @@\n-    public void touchMoved(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n+    private void touchMoved(long id, int x, int y, int xAbs, int yAbs) {\n@@ -367,1 +368,1 @@\n-        tracker.update(nanos, x, y, xAbs, yAbs);\n+        tracker.update(x, y, xAbs, yAbs);\n@@ -370,1 +371,1 @@\n-    void reset() {\n+    private void reset() {\n@@ -380,1 +381,1 @@\n-        public void update(long nanos, double x, double y, double absX, double absY) {\n+        public void update(double x, double y, double absX, double absY) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/ScrollGestureRecognizer.java","additions":48,"deletions":47,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import com.sun.glass.events.KeyEvent;\n-import com.sun.glass.events.TouchEvent;\n-\n@@ -35,2 +32,5 @@\n-import javafx.util.Duration;\n-import javafx.scene.input.ZoomEvent;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.sun.glass.events.KeyEvent;\n+import com.sun.glass.events.TouchEvent;\n+\n@@ -43,0 +43,2 @@\n+import javafx.scene.input.ZoomEvent;\n+import javafx.util.Duration;\n@@ -45,8 +47,8 @@\n-    \/\/ gesture will be activated if |zoomFactor - 1| > ZOOM_FACTOR_THRESHOLD\n-    private static double ZOOM_FACTOR_THRESHOLD = 0.1;\n-    private static boolean ZOOM_INERTIA_ENABLED = true;\n-    private static double MAX_ZOOMIN_VELOCITY = 3.0;\n-    private static double MAX_ZOOMOUT_VELOCITY = 0.3333;\n-    private static double ZOOM_INERTIA_MILLIS = 500;\n-    private static double MAX_ZOOM_IN_FACTOR = 10;\n-    private static double MAX_ZOOM_OUT_FACTOR = 0.1;\n+    private static final double ZOOM_INERTIA_MILLIS = 500;\n+    private static final double MAX_ZOOM_IN_FACTOR = 10;\n+    private static final double MAX_ZOOM_OUT_FACTOR = 0.1;\n+    private static final long ZOOM_INERTIA_THRESHOLD_NANOS = TimeUnit.MILLISECONDS.toNanos(200);\n+\n+    \/\/ gesture will be activated if |zoomFactor - 1| > zoomFactorThreshold\n+    private static double zoomFactorThreshold = 0.1;\n+    private static boolean zoomInertiaEnabled = true;\n@@ -59,1 +61,1 @@\n-                ZOOM_FACTOR_THRESHOLD = Double.valueOf(s);\n+                zoomFactorThreshold = Double.valueOf(s);\n@@ -63,1 +65,1 @@\n-                ZOOM_INERTIA_ENABLED = Boolean.valueOf(s);\n+                zoomInertiaEnabled = Boolean.valueOf(s);\n@@ -69,0 +71,4 @@\n+    private final Timeline inertiaTimeline = new Timeline();\n+    private final DoubleProperty inertiaZoomVelocity = new SimpleDoubleProperty();\n+    private final Map<Long, TouchPointTracker> trackers = new HashMap<>();\n+\n@@ -70,5 +76,2 @@\n-    private Timeline inertiaTimeline = new Timeline();\n-    private DoubleProperty inertiaZoomVelocity = new SimpleDoubleProperty();\n-    private double initialInertiaZoomVelocity = 0;\n-    private double zoomStartTime = 0;\n-    private double lastTouchEventTime = 0;\n+    private double initialInertiaZoomVelocity;\n+    private long zoomStartNanos;\n@@ -77,3 +80,0 @@\n-\n-    private Map<Long, TouchPointTracker> trackers = new HashMap<>();\n-\n@@ -89,1 +89,0 @@\n-    private double currentDistance;\n@@ -93,1 +92,1 @@\n-    double inertiaLastTime = 0;\n+    private double inertiaLastTime;\n@@ -125,1 +124,1 @@\n-                touchPressed(touchId, time, x, y, xAbs, yAbs);\n+                touchPressed(touchId, x, y, xAbs, yAbs);\n@@ -130,1 +129,1 @@\n-                touchMoved(touchId, time, x, y, xAbs, yAbs);\n+                touchMoved(touchId, x, y, xAbs, yAbs);\n@@ -134,1 +133,1 @@\n-                touchReleased(touchId, time, x, y, xAbs, yAbs);\n+                touchReleased(touchId);\n@@ -179,2 +178,1 @@\n-    public void notifyEndTouchEvent(long time) {\n-        lastTouchEventTime = time;\n+    public void notifyEndTouchEvent(long nanos) {\n@@ -190,3 +188,4 @@\n-            if (ZOOM_INERTIA_ENABLED && (state == ZoomRecognitionState.PRE_INERTIA || state == ZoomRecognitionState.ACTIVE)) {\n-                double timeFromLastZoom = ((double)time - zoomStartTime) \/ 1000000;\n-                if (initialInertiaZoomVelocity != 0 && timeFromLastZoom < 200) {\n+            if (zoomInertiaEnabled && (state == ZoomRecognitionState.PRE_INERTIA || state == ZoomRecognitionState.ACTIVE)) {\n+                long nanosSinceLastZoom = nanos - zoomStartNanos;\n+\n+                if (initialInertiaZoomVelocity != 0 && nanosSinceLastZoom < ZOOM_INERTIA_THRESHOLD_NANOS) {\n@@ -217,1 +216,0 @@\n-                            \/\/Duration.millis(ZOOM_INERTIA_MILLIS * Math.abs(initialInertiaZoomVelocity - 1) \/ (MAX_ZOOMIN_VELOCITY - 1)),\n@@ -219,4 +217,1 @@\n-                            event -> {\n-                                \/\/stop inertia\n-                                reset();\n-                            },\n+                            event -> reset(),  \/\/ stop inertia\n@@ -243,1 +238,1 @@\n-                    if (ZOOM_INERTIA_ENABLED) {\n+                    if (zoomInertiaEnabled) {\n@@ -255,1 +250,1 @@\n-                    zoomStartTime = time;\n+                    zoomStartNanos = nanos;\n@@ -268,1 +263,1 @@\n-                        if ( Math.abs(zoomFactor - 1) > ZOOM_FACTOR_THRESHOLD) {\n+                        if ( Math.abs(zoomFactor - 1) > zoomFactorThreshold) {\n@@ -278,4 +273,5 @@\n-                        double timePassed = ((double)time - zoomStartTime) \/ 1000000000;\n-                        if (timePassed > 1e-4) {\n-                            initialInertiaZoomVelocity = (totalZoomFactor - prevTotalZoomFactor) \/ timePassed;\n-                            zoomStartTime = time;\n+                        long nanosPassed = nanos - zoomStartNanos;\n+\n+                        if (nanosPassed > INITIAL_VELOCITY_THRESHOLD_NANOS) {\n+                            initialInertiaZoomVelocity = (totalZoomFactor - prevTotalZoomFactor) \/ nanosPassed * NANOS_TO_SECONDS;\n+                            zoomStartNanos = nanos;\n@@ -347,1 +343,1 @@\n-    public void params(int modifiers, boolean direct) {\n+    private void params(int modifiers, boolean direct) {\n@@ -352,1 +348,1 @@\n-    public void touchPressed(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n+    private void touchPressed(long id, int x, int y, int xAbs, int yAbs) {\n@@ -355,1 +351,1 @@\n-        tracker.update(nanos, x, y, xAbs, yAbs);\n+        tracker.update(x, y, xAbs, yAbs);\n@@ -359,1 +355,1 @@\n-    public void touchReleased(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n+    private void touchReleased(long id) {\n@@ -373,1 +369,1 @@\n-    public void touchMoved(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n+    private void touchMoved(long id, int x, int y, int xAbs, int yAbs) {\n@@ -385,1 +381,1 @@\n-        tracker.update(nanos, x, y, xAbs, yAbs);\n+        tracker.update(x, y, xAbs, yAbs);\n@@ -388,1 +384,1 @@\n-    void reset() {\n+    private void reset() {\n@@ -398,1 +394,1 @@\n-        public void update(long nanos, double x, double y, double absX, double absY) {\n+        public void update(double x, double y, double absX, double absY) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/ZoomGestureRecognizer.java","additions":49,"deletions":53,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -0,0 +1,325 @@\n+package test.com.sun.javafx.tk.quantum;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import com.sun.glass.events.TouchEvent;\n+import com.sun.glass.ui.Accessible;\n+import com.sun.javafx.tk.TKSceneListener;\n+import com.sun.javafx.tk.Toolkit;\n+import com.sun.javafx.tk.quantum.PrivilegedSceneListenerAccessor;\n+import com.sun.javafx.tk.quantum.RotateGestureRecognizer;\n+\n+import javafx.collections.ObservableList;\n+import javafx.event.EventType;\n+import javafx.scene.input.InputMethodEvent;\n+import javafx.scene.input.InputMethodTextRun;\n+import javafx.scene.input.KeyEvent;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.input.RotateEvent;\n+import javafx.scene.input.ScrollEvent;\n+import javafx.scene.input.SwipeEvent;\n+import javafx.scene.input.TouchPoint.State;\n+import javafx.scene.input.ZoomEvent;\n+import test.com.sun.javafx.pgstub.StubToolkit;\n+\n+public class RotateGestureRecognizerTest {\n+    private static final double EPSILON = 0.0001;\n+\n+    private final List<RotationEvent> rotationEvents = new ArrayList<>();\n+    private final StubToolkit toolkit = (StubToolkit) Toolkit.getToolkit();\n+    private final RotateGestureRecognizer recognizer = new RotateGestureRecognizer(createAccessor());\n+\n+    private long nanos;\n+\n+    @Nested\n+    class WhenThereAreTwoTouches {\n+        {\n+            clearEvents();\n+            passTime(0);\n+            \/\/passTime(Long.MAX_VALUE \/ 1000 \/ 1000 - 10000000);  \/\/ a value close to Long.MAX_VALUE in nanos to test accuracy\n+\n+            recognizer.notifyBeginTouchEvent(nanos, 0, false, 0);\n+            recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_PRESSED, 1, 100, 100, 100, 100);\n+            recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_PRESSED, 2, 150, 100, 150, 100);\n+            recognizer.notifyEndTouchEvent(nanos);\n+        }\n+\n+        @Test\n+        void shouldHaveNoEvents() {\n+            assertNoRotationEvents();\n+        }\n+\n+        @Nested\n+        class AndTouchesAreReleased {\n+            {\n+                clearEvents();\n+                passTime(100);\n+\n+                recognizer.notifyBeginTouchEvent(nanos, 0, false, 0);\n+                recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_RELEASED, 1, 100, 100, 100, 100);\n+                recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_RELEASED, 2, 150, 100, 150, 100);\n+                recognizer.notifyEndTouchEvent(nanos);\n+            }\n+\n+            @Test\n+            void shouldSendNoEvents() {\n+                assertNoRotationEvents();\n+            }\n+        }\n+\n+        @Nested\n+        class AndSecondTouchIsMoved45DegreesCCW {\n+            {\n+                clearEvents();\n+                passTime(100);\n+\n+                recognizer.notifyBeginTouchEvent(nanos, 0, false, 0);\n+                recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_MOVED, 2, 150, 50, 150, 50);\n+                recognizer.notifyEndTouchEvent(nanos);\n+            }\n+\n+            @Test\n+            void shouldSendStartRotationEvents() {\n+                assertRotationEvent(new RotationEvent(RotateEvent.ROTATION_STARTED, 0, 0, 125, 75, 125, 75, false));\n+                assertRotationEvent(new RotationEvent(RotateEvent.ROTATE, -45, -45, 125, 75, 125, 75, false));\n+            }\n+\n+            @Nested\n+            class AndSecondTouchIsReleased {\n+                {\n+                    clearEvents();\n+                    passTime(100);\n+\n+                    recognizer.notifyBeginTouchEvent(nanos, 0, false, 0);\n+                    recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_RELEASED, 2, 150, 50, 150, 50);\n+                    recognizer.notifyEndTouchEvent(nanos);\n+                }\n+\n+                @Test\n+                void shouldSendRotationFinishedEventAndDoNoInertia() {\n+                    assertRotationEvent(new RotationEvent(RotateEvent.ROTATION_FINISHED, 0, -45, 125, 75, 125, 75, false));\n+\n+                    passTime(250);\n+\n+                    assertNoRotationEvents();\n+                }\n+            }\n+\n+            @Nested\n+            class AndSecondTouchIsMovedAnother45DegreesCCW {\n+                {\n+                    clearEvents();\n+                    passTime(100);\n+\n+                    recognizer.notifyBeginTouchEvent(nanos, 0, false, 0);\n+                    recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_MOVED, 2, 100, 50, 100, 50);\n+                    recognizer.notifyEndTouchEvent(nanos);\n+                }\n+\n+                @Test\n+                void shouldSendAnotherRotationEvent() {\n+                    assertRotationEvent(new RotationEvent(RotateEvent.ROTATE, -45, -90, 100, 75, 100, 75, false));\n+                }\n+\n+                @Nested\n+                class AndBothTouchesAreReleased {\n+                    {\n+                        clearEvents();\n+\n+                        recognizer.notifyBeginTouchEvent(nanos, 0, false, 0);\n+                        recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_RELEASED, 1, 100, 100, 100, 100);\n+                        recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_RELEASED, 2, 100, 50, 100, 50);\n+                        recognizer.notifyEndTouchEvent(nanos);\n+                    }\n+\n+                    @Test\n+                    void shouldSendRotationFinishedEvent() {\n+                        assertRotationEvent(new RotationEvent(RotateEvent.ROTATION_FINISHED, 0, -90, 100, 75, 100, 75, false));\n+                    }\n+\n+                    @Nested\n+                    class AndTimePasses {\n+                        {\n+                            clearEvents();\n+                            passTime(250);\n+                        }\n+\n+                        @Test\n+                        void shouldDoInertia() {\n+                            assertRotationEvent(new RotationEvent(RotateEvent.ROTATE, -91.6666, -181.6666, 100, 75, 100, 75, true));\n+\n+                            \/\/ Trigger a few more inertia events:\n+                            passTime(250);\n+                            passTime(250);\n+                            passTime(250);\n+                            passTime(250);\n+                            passTime(250);\n+\n+                            \/\/ Assert Inertia events; angle moved slowly reduces to 0:\n+                            assertRotationEvent(new RotationEvent(RotateEvent.ROTATE, -70.8333, -252.5000, 100, 75, 100, 75, true));\n+                            assertRotationEvent(new RotationEvent(RotateEvent.ROTATE, -50.0000, -302.5000, 100, 75, 100, 75, true));\n+                            assertRotationEvent(new RotationEvent(RotateEvent.ROTATE, -29.1666, -331.6666, 100, 75, 100, 75, true));\n+                            assertRotationEvent(new RotationEvent(RotateEvent.ROTATE,  -8.3333, -340.0000, 100, 75, 100, 75, true));\n+                            assertRotationEvent(new RotationEvent(RotateEvent.ROTATE,      0.0, -340.0000, 100, 75, 100, 75, true));\n+                        }\n+\n+                        @Nested\n+                        class AndASingleTouchOccurs {\n+                            {\n+                                \/\/ Initial inertia event:\n+                                assertRotationEvent(new RotationEvent(RotateEvent.ROTATE, -91.6666, -181.6666, 100, 75, 100, 75, true));\n+\n+                                passTime(250);\n+\n+                                \/\/ Second intetia event:\n+                                assertRotationEvent(new RotationEvent(RotateEvent.ROTATE, -70.8333, -252.5000, 100, 75, 100, 75, true));\n+\n+                                \/\/ Halt inertia:\n+                                recognizer.notifyBeginTouchEvent(nanos, 0, false, 0);\n+                                recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_PRESSED, 3, 200, 200, 200, 200);\n+                                recognizer.notifyEndTouchEvent(nanos);\n+                            }\n+\n+                            @Test\n+                            void shouldHaltInertia() {\n+                                assertNoRotationEvents();\n+                                passTime(250);\n+                                assertNoRotationEvents();\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void assertRotationEvent(RotationEvent rotationEvent) {\n+        assertTrue(rotationEvents.size() > 0, \"Expected rotation event, but none available\");\n+\n+        RotationEvent remove = rotationEvents.remove(0);\n+\n+        assertTrue(rotationEvent.anglesCloseToEquals(remove), remove + \" must match \" + rotationEvent);\n+    }\n+\n+    private void assertNoRotationEvents() {\n+        assertTrue(rotationEvents.isEmpty(), \"No rotation event expected, but there were some available: \" + rotationEvents);\n+    }\n+\n+    private void clearEvents() {\n+        rotationEvents.clear();\n+    }\n+\n+    private void passTime(long millis) {\n+        nanos += millis * 1000 * 1000;\n+        toolkit.setAnimationTime(nanos \/ 1000 \/ 1000);\n+    }\n+\n+    private record RotationEvent(EventType<RotateEvent> eventType, double angle, double totalAngle, double x,\n+            double y, double screenX, double screenY, boolean inertia) {\n+\n+        public boolean anglesCloseToEquals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null || getClass() != obj.getClass()) {\n+                return false;\n+            }\n+\n+            RotationEvent other = (RotationEvent) obj;\n+            return Math.abs(angle - other.angle) < EPSILON\n+                && Objects.equals(eventType, other.eventType)\n+                && inertia == other.inertia\n+                && Double.doubleToLongBits(screenX) == Double.doubleToLongBits(other.screenX)\n+                && Double.doubleToLongBits(screenY) == Double.doubleToLongBits(other.screenY)\n+                && Math.abs(totalAngle - other.totalAngle) < EPSILON\n+                && Double.doubleToLongBits(x) == Double.doubleToLongBits(other.x)\n+                && Double.doubleToLongBits(y) == Double.doubleToLongBits(other.y);\n+        }\n+    }\n+\n+    private PrivilegedSceneListenerAccessor createAccessor() {\n+        return consumer -> consumer.accept(new TKSceneListener() {\n+            @Override\n+            public void changedLocation(float x, float y) {\n+            }\n+\n+            @Override\n+            public void changedSize(float width, float height) {\n+            }\n+\n+            @Override\n+            public void mouseEvent(EventType<MouseEvent> type, double x, double y, double screenX, double screenY,\n+                    MouseButton button, boolean popupTrigger, boolean synthesized, boolean shiftDown,\n+                    boolean controlDown, boolean altDown, boolean metaDown, boolean primaryDown, boolean middleDown,\n+                    boolean secondaryDown, boolean backDown, boolean forwardDown) {\n+            }\n+\n+            @Override\n+            public void keyEvent(KeyEvent keyEvent) {\n+            }\n+\n+            @Override\n+            public void inputMethodEvent(EventType<InputMethodEvent> type,\n+                    ObservableList<InputMethodTextRun> composed, String committed, int caretPosition) {\n+            }\n+\n+            @Override\n+            public void scrollEvent(EventType<ScrollEvent> eventType, double scrollX, double scrollY,\n+                    double totalScrollX, double totalScrollY, double xMultiplier, double yMultiplier,\n+                    int touchCount, int scrollTextX, int scrollTextY, int defaultTextX, int defaultTextY, double x,\n+                    double y, double screenX, double screenY, boolean _shiftDown, boolean _controlDown,\n+                    boolean _altDown, boolean _metaDown, boolean _direct, boolean _inertia) {\n+            }\n+\n+            @Override\n+            public void menuEvent(double x, double y, double xAbs, double yAbs, boolean isKeyboardTrigger) {\n+            }\n+\n+            @Override\n+            public void zoomEvent(EventType<ZoomEvent> eventType, double zoomFactor, double totalZoomFactor,\n+                    double x, double y, double screenX, double screenY, boolean _shiftDown, boolean _controlDown,\n+                    boolean _altDown, boolean _metaDown, boolean _direct, boolean _inertia) {\n+            }\n+\n+\n+            @Override\n+            public void rotateEvent(EventType<RotateEvent> eventType, double angle, double totalAngle, double x,\n+                    double y, double screenX, double screenY, boolean _shiftDown, boolean _controlDown,\n+                    boolean _altDown, boolean _metaDown, boolean _direct, boolean _inertia) {\n+                rotationEvents.add(new RotationEvent(eventType, angle, totalAngle, x, y, screenX, screenY, _inertia));\n+            }\n+\n+            @Override\n+            public void swipeEvent(EventType<SwipeEvent> eventType, int touchCount, double x, double y,\n+                    double screenX, double screenY, boolean _shiftDown, boolean _controlDown, boolean _altDown,\n+                    boolean _metaDown, boolean _direct) {\n+            }\n+\n+            @Override\n+            public void touchEventBegin(long time, int touchCount, boolean isDirect, boolean _shiftDown,\n+                    boolean _controlDown, boolean _altDown, boolean _metaDown) {\n+            }\n+\n+            @Override\n+            public void touchEventNext(State state, long touchId, double x, double y, double xAbs, double yAbs) {\n+            }\n+\n+            @Override\n+            public void touchEventEnd() {\n+            }\n+\n+            @Override\n+            public Accessible getSceneAccessible() {\n+                return null;\n+            }\n+        });\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/tk\/quantum\/RotateGestureRecognizerTest.java","additions":325,"deletions":0,"binary":false,"changes":325,"status":"added"}]}