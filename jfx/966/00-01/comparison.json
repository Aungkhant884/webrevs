{"files":[{"patch":"@@ -81,1 +81,2 @@\n-    private ViewScene scene;\n+    private final ViewScene scene;\n+    private final PrivilegedSceneListenerAccessor privilegedSceneListenerAccessor;\n@@ -85,0 +86,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -87,0 +89,9 @@\n+        this.privilegedSceneListenerAccessor = consumer -> AccessController.doPrivileged(\n+            (PrivilegedAction<Void>) () -> {\n+                if (scene.sceneListener != null) {\n+                    consumer.accept(scene.sceneListener);\n+                }\n+                return null;\n+            },\n+            scene.getAccessControlContext()\n+        );\n@@ -98,1 +109,1 @@\n-            gestures.add(new RotateGestureRecognizer(scene));\n+            gestures.add(new RotateGestureRecognizer(privilegedSceneListenerAccessor));\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/GlassViewEventHandler.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,13 @@\n+package com.sun.javafx.tk.quantum;\n+\n+import java.util.function.Consumer;\n+\n+import com.sun.javafx.tk.TKSceneListener;\n+\n+\/**\n+ * Interface that allows access to {@link TKSceneListener} when it is\n+ * not {@code null}.\n+ *\/\n+public interface PrivilegedSceneListenerAccessor {\n+    void withSceneListener(Consumer<TKSceneListener> consumer);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/PrivilegedSceneListenerAccessor.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -28,0 +28,3 @@\n+import com.sun.glass.events.KeyEvent;\n+import com.sun.glass.events.TouchEvent;\n+\n@@ -32,5 +35,5 @@\n-import java.util.concurrent.TimeUnit;\n-\n-import com.sun.glass.events.KeyEvent;\n-import com.sun.glass.events.TouchEvent;\n-\n+import java.util.Set;\n+import javafx.util.Duration;\n+import javafx.event.EventType;\n+import javafx.scene.input.RotateEvent;\n+import javafx.animation.Animation;\n@@ -43,7 +46,0 @@\n-import javafx.scene.input.RotateEvent;\n-import javafx.util.Duration;\n-\n-class RotateGestureRecognizer implements GestureRecognizer {\n-    private static final double MAX_INITIAL_VELOCITY = 500;\n-    private static final double ROTATION_INERTIA_MILLIS = 1500;\n-    private static final long ROTATION_INERTIA_THRESHOLD_NANOS = TimeUnit.MILLISECONDS.toNanos(300);\n@@ -51,3 +47,2 @@\n-    \/\/ gesture will be activated if |rotation| > rotationThresholdDegrees\n-    private static double rotationThresholdDegrees = 5;\n-    private static boolean rotationInertiaEnabled = true;\n+public class RotateGestureRecognizer implements GestureRecognizer {\n+    private PrivilegedSceneListenerAccessor accessor;\n@@ -55,0 +50,5 @@\n+    \/\/ gesture will be activated if |rotation| > ROTATATION_THRESHOLD\n+    private static double ROTATATION_THRESHOLD = 5; \/\/in degrees\n+    private static boolean ROTATION_INERTIA_ENABLED = true;\n+    private static double MAX_INITIAL_VELOCITY = 500;\n+    private static double ROTATION_INERTIA_MILLIS = 1500;\n@@ -60,1 +60,1 @@\n-                rotationThresholdDegrees = Double.valueOf(s);\n+                ROTATATION_THRESHOLD = Double.valueOf(s);\n@@ -64,1 +64,1 @@\n-                rotationInertiaEnabled = Boolean.valueOf(s);\n+                ROTATION_INERTIA_ENABLED = Boolean.valueOf(s);\n@@ -70,5 +70,0 @@\n-    private final Timeline inertiaTimeline = new Timeline();\n-    private final DoubleProperty inertiaRotationVelocity = new SimpleDoubleProperty();\n-    private final Map<Long, TouchPointTracker> trackers = new HashMap<>();  \/\/ from MultiTouchTracker\n-\n-    private ViewScene scene;\n@@ -76,2 +71,5 @@\n-    private double initialInertiaRotationVelocity;\n-    private long rotationStartNanos;\n+    private Timeline inertiaTimeline = new Timeline();\n+    private DoubleProperty inertiaRotationVelocity = new SimpleDoubleProperty();\n+    private double initialInertiaRotationVelocity = 0;\n+    private double rotationStartTime = 0;\n+    private double lastTouchEventTime = 0;\n@@ -79,2 +77,3 @@\n-    private int modifiers;\n-    private boolean direct;\n+    \/\/ from MultiTouchTracker\n+    Map<Long, TouchPointTracker> trackers =\n+            new HashMap<Long, TouchPointTracker>();\n@@ -82,1 +81,5 @@\n-    private int currentTouchCount;\n+    int modifiers;\n+    boolean direct;\n+\n+    \/\/private int touchCount;\n+    private int currentTouchCount = 0;\n@@ -85,12 +88,13 @@\n-    private long touchPointID1 = -1;\n-    private long touchPointID2 = -1;\n-    private double centerX, centerY;\n-    private double centerAbsX, centerAbsY;\n-\n-    private double currentRotation;\n-    private double angleReference;\n-    private double totalRotation;\n-    private double inertiaLastTime;\n-\n-    RotateGestureRecognizer(final ViewScene scene) {\n-        this.scene = scene;\n+    int touchPointsInEvent;\n+    long touchPointID1 = -1;\n+    long touchPointID2 = -1;\n+    double centerX, centerY;\n+    double centerAbsX, centerAbsY;\n+\n+    double currentRotation;\n+    double angleReference;\n+    double totalRotation = 0;\n+    double inertiaLastTime = 0;\n+\n+    public RotateGestureRecognizer(PrivilegedSceneListenerAccessor accessor) {\n+        this.accessor = accessor;\n@@ -114,0 +118,1 @@\n+        touchPointsInEvent = 0;\n@@ -119,0 +124,1 @@\n+        touchPointsInEvent++;\n@@ -123,1 +129,1 @@\n-                touchPressed(touchId, x, y, xAbs, yAbs);\n+                touchPressed(touchId, time, x, y, xAbs, yAbs);\n@@ -128,1 +134,1 @@\n-                touchMoved(touchId, x, y, xAbs, yAbs);\n+                touchMoved(touchId, time, x, y, xAbs, yAbs);\n@@ -132,1 +138,1 @@\n-                touchReleased(touchId);\n+                touchReleased(touchId, time, x, y, xAbs, yAbs);\n@@ -216,1 +222,2 @@\n-    public void notifyEndTouchEvent(long nanos) {\n+    public void notifyEndTouchEvent(long time) {\n+        lastTouchEventTime = time;\n@@ -226,4 +233,3 @@\n-            if (rotationInertiaEnabled && (state == RotateRecognitionState.PRE_INERTIA || state == RotateRecognitionState.ACTIVE)) {\n-                long nanosSinceLastRotation = nanos - rotationStartNanos;\n-\n-                if (nanosSinceLastRotation < ROTATION_INERTIA_THRESHOLD_NANOS) {\n+            if (ROTATION_INERTIA_ENABLED && (state == RotateRecognitionState.PRE_INERTIA || state == RotateRecognitionState.ACTIVE)) {\n+                double timeFromLastRotation = ((double)time - rotationStartTime) \/ 1000000;\n+                if (timeFromLastRotation < 300) {\n@@ -244,1 +250,4 @@\n-                            event -> reset(),  \/\/ stop inertia\n+                            event -> {\n+                                \/\/stop inertia\n+                                reset();\n+                            },\n@@ -262,1 +271,1 @@\n-                    if (rotationInertiaEnabled) {\n+                    if (ROTATION_INERTIA_ENABLED) {\n@@ -291,1 +300,1 @@\n-                        if (Math.abs(currentRotation) > rotationThresholdDegrees) {\n+                        if (Math.abs(currentRotation) > ROTATATION_THRESHOLD) {\n@@ -301,5 +310,4 @@\n-                        long nanosPassed = nanos - rotationStartNanos;\n-\n-                        if (nanosPassed > INITIAL_VELOCITY_THRESHOLD_NANOS) {\n-                            initialInertiaRotationVelocity = currentRotation \/ nanosPassed * NANOS_TO_SECONDS;\n-                            rotationStartNanos = nanos;\n+                        double timePassed = ((double)time - rotationStartTime) \/ 1000000000;\n+                        if (timePassed > 1e-4) {\n+                            initialInertiaRotationVelocity = currentRotation \/ timePassed;\n+                            rotationStartTime = time;\n@@ -313,1 +321,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -315,15 +322,13 @@\n-        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-            if (scene.sceneListener != null) {\n-                scene.sceneListener.rotateEvent(RotateEvent.ROTATION_STARTED,\n-                    0, 0,\n-                    centerX, centerY,\n-                    centerAbsX, centerAbsY,\n-                    (modifiers & KeyEvent.MODIFIER_SHIFT) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_CONTROL) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_ALT) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_WINDOWS) != 0,\n-                    direct,\n-                    false \/*inertia*\/);\n-            }\n-            return null;\n-        }, scene.getAccessControlContext());\n+        accessor.withSceneListener(sceneListener -> {\n+            sceneListener.rotateEvent(RotateEvent.ROTATION_STARTED,\n+                0, 0,\n+                centerX, centerY,\n+                centerAbsX, centerAbsY,\n+                (modifiers & KeyEvent.MODIFIER_SHIFT) != 0,\n+                (modifiers & KeyEvent.MODIFIER_CONTROL) != 0,\n+                (modifiers & KeyEvent.MODIFIER_ALT) != 0,\n+                (modifiers & KeyEvent.MODIFIER_WINDOWS) != 0,\n+                direct,\n+                false  \/\/ inertia\n+            );\n+        });\n@@ -332,1 +337,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -334,14 +338,12 @@\n-        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-            if (scene.sceneListener != null) {\n-                scene.sceneListener.rotateEvent(RotateEvent.ROTATE,\n-                    currentRotation, totalRotation,\n-                    centerX, centerY,\n-                    centerAbsX, centerAbsY,\n-                    (modifiers & KeyEvent.MODIFIER_SHIFT) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_CONTROL) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_ALT) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_WINDOWS) != 0,\n-                    direct, isInertia);\n-            }\n-            return null;\n-        }, scene.getAccessControlContext());\n+        accessor.withSceneListener(sceneListener -> {\n+            sceneListener.rotateEvent(RotateEvent.ROTATE,\n+                currentRotation, totalRotation,\n+                centerX, centerY,\n+                centerAbsX, centerAbsY,\n+                (modifiers & KeyEvent.MODIFIER_SHIFT) != 0,\n+                (modifiers & KeyEvent.MODIFIER_CONTROL) != 0,\n+                (modifiers & KeyEvent.MODIFIER_ALT) != 0,\n+                (modifiers & KeyEvent.MODIFIER_WINDOWS) != 0,\n+                direct, isInertia\n+            );\n+        });\n@@ -350,1 +352,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -352,15 +353,13 @@\n-        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n-            if (scene.sceneListener != null) {\n-                scene.sceneListener.rotateEvent(RotateEvent.ROTATION_FINISHED,\n-                    0, totalRotation,\n-                    centerX, centerY,\n-                    centerAbsX, centerAbsY,\n-                    (modifiers & KeyEvent.MODIFIER_SHIFT) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_CONTROL) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_ALT) != 0,\n-                    (modifiers & KeyEvent.MODIFIER_WINDOWS) != 0,\n-                    direct,\n-                    false \/*inertia*\/);\n-            }\n-            return null;\n-        }, scene.getAccessControlContext());\n+        accessor.withSceneListener(sceneListener -> {\n+            sceneListener.rotateEvent(RotateEvent.ROTATION_FINISHED,\n+                0, totalRotation,\n+                centerX, centerY,\n+                centerAbsX, centerAbsY,\n+                (modifiers & KeyEvent.MODIFIER_SHIFT) != 0,\n+                (modifiers & KeyEvent.MODIFIER_CONTROL) != 0,\n+                (modifiers & KeyEvent.MODIFIER_ALT) != 0,\n+                (modifiers & KeyEvent.MODIFIER_WINDOWS) != 0,\n+                direct,\n+                false  \/\/ inertia\n+            );\n+        });\n@@ -369,1 +368,1 @@\n-    private void params(int modifiers, boolean direct) {\n+    public void params(int modifiers, boolean direct) {\n@@ -374,1 +373,1 @@\n-    private void touchPressed(long id, int x, int y, int xAbs, int yAbs) {\n+    public void touchPressed(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n@@ -377,1 +376,1 @@\n-        tracker.update(x, y, xAbs, yAbs);\n+        tracker.update(nanos, x, y, xAbs, yAbs);\n@@ -381,1 +380,1 @@\n-    private void touchReleased(long id) {\n+    public void touchReleased(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n@@ -395,1 +394,1 @@\n-    private void touchMoved(long id, int x, int y, int xAbs, int yAbs) {\n+    public void touchMoved(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n@@ -407,1 +406,1 @@\n-        tracker.update(x, y, xAbs, yAbs);\n+        tracker.update(nanos, x, y, xAbs, yAbs);\n@@ -410,1 +409,1 @@\n-    private void reset() {\n+    void reset() {\n@@ -422,1 +421,1 @@\n-        public void update(double x, double y, double absX, double absY) {\n+        public void update(long nanos, double x, double y, double absX, double absY) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/RotateGestureRecognizer.java","additions":109,"deletions":110,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -0,0 +1,325 @@\n+package test.com.sun.javafx.tk.quantum;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import com.sun.glass.events.TouchEvent;\n+import com.sun.glass.ui.Accessible;\n+import com.sun.javafx.tk.TKSceneListener;\n+import com.sun.javafx.tk.Toolkit;\n+import com.sun.javafx.tk.quantum.PrivilegedSceneListenerAccessor;\n+import com.sun.javafx.tk.quantum.RotateGestureRecognizer;\n+\n+import javafx.collections.ObservableList;\n+import javafx.event.EventType;\n+import javafx.scene.input.InputMethodEvent;\n+import javafx.scene.input.InputMethodTextRun;\n+import javafx.scene.input.KeyEvent;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.input.RotateEvent;\n+import javafx.scene.input.ScrollEvent;\n+import javafx.scene.input.SwipeEvent;\n+import javafx.scene.input.TouchPoint.State;\n+import javafx.scene.input.ZoomEvent;\n+import test.com.sun.javafx.pgstub.StubToolkit;\n+\n+public class RotateGestureRecognizerTest {\n+    private static final double EPSILON = 0.0001;\n+\n+    private final List<RotationEvent> rotationEvents = new ArrayList<>();\n+    private final StubToolkit toolkit = (StubToolkit) Toolkit.getToolkit();\n+    private final RotateGestureRecognizer recognizer = new RotateGestureRecognizer(createAccessor());\n+\n+    private long nanos;\n+\n+    @Nested\n+    class WhenThereAreTwoTouches {\n+        {\n+            clearEvents();\n+            passTime(0);\n+            \/\/passTime(Long.MAX_VALUE \/ 1000 \/ 1000 - 10000000);  \/\/ a value close to Long.MAX_VALUE in nanos to test accuracy\n+\n+            recognizer.notifyBeginTouchEvent(nanos, 0, false, 0);\n+            recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_PRESSED, 1, 100, 100, 100, 100);\n+            recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_PRESSED, 2, 150, 100, 150, 100);\n+            recognizer.notifyEndTouchEvent(nanos);\n+        }\n+\n+        @Test\n+        void shouldHaveNoEvents() {\n+            assertNoRotationEvents();\n+        }\n+\n+        @Nested\n+        class AndTouchesAreReleased {\n+            {\n+                clearEvents();\n+                passTime(100);\n+\n+                recognizer.notifyBeginTouchEvent(nanos, 0, false, 0);\n+                recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_RELEASED, 1, 100, 100, 100, 100);\n+                recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_RELEASED, 2, 150, 100, 150, 100);\n+                recognizer.notifyEndTouchEvent(nanos);\n+            }\n+\n+            @Test\n+            void shouldSendNoEvents() {\n+                assertNoRotationEvents();\n+            }\n+        }\n+\n+        @Nested\n+        class AndSecondTouchIsMoved45DegreesCCW {\n+            {\n+                clearEvents();\n+                passTime(100);\n+\n+                recognizer.notifyBeginTouchEvent(nanos, 0, false, 0);\n+                recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_MOVED, 2, 150, 50, 150, 50);\n+                recognizer.notifyEndTouchEvent(nanos);\n+            }\n+\n+            @Test\n+            void shouldSendStartRotationEvents() {\n+                assertRotationEvent(new RotationEvent(RotateEvent.ROTATION_STARTED, 0, 0, 125, 75, 125, 75, false));\n+                assertRotationEvent(new RotationEvent(RotateEvent.ROTATE, -45, -45, 125, 75, 125, 75, false));\n+            }\n+\n+            @Nested\n+            class AndSecondTouchIsReleased {\n+                {\n+                    clearEvents();\n+                    passTime(100);\n+\n+                    recognizer.notifyBeginTouchEvent(nanos, 0, false, 0);\n+                    recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_RELEASED, 2, 150, 50, 150, 50);\n+                    recognizer.notifyEndTouchEvent(nanos);\n+                }\n+\n+                @Test\n+                void shouldSendRotationFinishedEventAndDoNoInertia() {\n+                    assertRotationEvent(new RotationEvent(RotateEvent.ROTATION_FINISHED, 0, -45, 125, 75, 125, 75, false));\n+\n+                    passTime(250);\n+\n+                    assertNoRotationEvents();\n+                }\n+            }\n+\n+            @Nested\n+            class AndSecondTouchIsMovedAnother45DegreesCCW {\n+                {\n+                    clearEvents();\n+                    passTime(100);\n+\n+                    recognizer.notifyBeginTouchEvent(nanos, 0, false, 0);\n+                    recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_MOVED, 2, 100, 50, 100, 50);\n+                    recognizer.notifyEndTouchEvent(nanos);\n+                }\n+\n+                @Test\n+                void shouldSendAnotherRotationEvent() {\n+                    assertRotationEvent(new RotationEvent(RotateEvent.ROTATE, -45, -90, 100, 75, 100, 75, false));\n+                }\n+\n+                @Nested\n+                class AndBothTouchesAreReleased {\n+                    {\n+                        clearEvents();\n+\n+                        recognizer.notifyBeginTouchEvent(nanos, 0, false, 0);\n+                        recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_RELEASED, 1, 100, 100, 100, 100);\n+                        recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_RELEASED, 2, 100, 50, 100, 50);\n+                        recognizer.notifyEndTouchEvent(nanos);\n+                    }\n+\n+                    @Test\n+                    void shouldSendRotationFinishedEvent() {\n+                        assertRotationEvent(new RotationEvent(RotateEvent.ROTATION_FINISHED, 0, -90, 100, 75, 100, 75, false));\n+                    }\n+\n+                    @Nested\n+                    class AndTimePasses {\n+                        {\n+                            clearEvents();\n+                            passTime(250);\n+                        }\n+\n+                        @Test\n+                        void shouldDoInertia() {\n+                            assertRotationEvent(new RotationEvent(RotateEvent.ROTATE, -91.6666, -181.6666, 100, 75, 100, 75, true));\n+\n+                            \/\/ Trigger a few more inertia events:\n+                            passTime(250);\n+                            passTime(250);\n+                            passTime(250);\n+                            passTime(250);\n+                            passTime(250);\n+\n+                            \/\/ Assert Inertia events; angle moved slowly reduces to 0:\n+                            assertRotationEvent(new RotationEvent(RotateEvent.ROTATE, -70.8333, -252.5000, 100, 75, 100, 75, true));\n+                            assertRotationEvent(new RotationEvent(RotateEvent.ROTATE, -50.0000, -302.5000, 100, 75, 100, 75, true));\n+                            assertRotationEvent(new RotationEvent(RotateEvent.ROTATE, -29.1666, -331.6666, 100, 75, 100, 75, true));\n+                            assertRotationEvent(new RotationEvent(RotateEvent.ROTATE,  -8.3333, -340.0000, 100, 75, 100, 75, true));\n+                            assertRotationEvent(new RotationEvent(RotateEvent.ROTATE,      0.0, -340.0000, 100, 75, 100, 75, true));\n+                        }\n+\n+                        @Nested\n+                        class AndASingleTouchOccurs {\n+                            {\n+                                \/\/ Initial inertia event:\n+                                assertRotationEvent(new RotationEvent(RotateEvent.ROTATE, -91.6666, -181.6666, 100, 75, 100, 75, true));\n+\n+                                passTime(250);\n+\n+                                \/\/ Second intetia event:\n+                                assertRotationEvent(new RotationEvent(RotateEvent.ROTATE, -70.8333, -252.5000, 100, 75, 100, 75, true));\n+\n+                                \/\/ Halt inertia:\n+                                recognizer.notifyBeginTouchEvent(nanos, 0, false, 0);\n+                                recognizer.notifyNextTouchEvent(nanos, TouchEvent.TOUCH_PRESSED, 3, 200, 200, 200, 200);\n+                                recognizer.notifyEndTouchEvent(nanos);\n+                            }\n+\n+                            @Test\n+                            void shouldHaltInertia() {\n+                                assertNoRotationEvents();\n+                                passTime(250);\n+                                assertNoRotationEvents();\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void assertRotationEvent(RotationEvent rotationEvent) {\n+        assertTrue(rotationEvents.size() > 0, \"Expected rotation event, but none available\");\n+\n+        RotationEvent remove = rotationEvents.remove(0);\n+\n+        assertTrue(rotationEvent.anglesCloseToEquals(remove), remove + \" must match \" + rotationEvent);\n+    }\n+\n+    private void assertNoRotationEvents() {\n+        assertTrue(rotationEvents.isEmpty(), \"No rotation event expected, but there were some available: \" + rotationEvents);\n+    }\n+\n+    private void clearEvents() {\n+        rotationEvents.clear();\n+    }\n+\n+    private void passTime(long millis) {\n+        nanos += millis * 1000 * 1000;\n+        toolkit.setAnimationTime(nanos \/ 1000 \/ 1000);\n+    }\n+\n+    private record RotationEvent(EventType<RotateEvent> eventType, double angle, double totalAngle, double x,\n+            double y, double screenX, double screenY, boolean inertia) {\n+\n+        public boolean anglesCloseToEquals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null || getClass() != obj.getClass()) {\n+                return false;\n+            }\n+\n+            RotationEvent other = (RotationEvent) obj;\n+            return Math.abs(angle - other.angle) < EPSILON\n+                && Objects.equals(eventType, other.eventType)\n+                && inertia == other.inertia\n+                && Double.doubleToLongBits(screenX) == Double.doubleToLongBits(other.screenX)\n+                && Double.doubleToLongBits(screenY) == Double.doubleToLongBits(other.screenY)\n+                && Math.abs(totalAngle - other.totalAngle) < EPSILON\n+                && Double.doubleToLongBits(x) == Double.doubleToLongBits(other.x)\n+                && Double.doubleToLongBits(y) == Double.doubleToLongBits(other.y);\n+        }\n+    }\n+\n+    private PrivilegedSceneListenerAccessor createAccessor() {\n+        return consumer -> consumer.accept(new TKSceneListener() {\n+            @Override\n+            public void changedLocation(float x, float y) {\n+            }\n+\n+            @Override\n+            public void changedSize(float width, float height) {\n+            }\n+\n+            @Override\n+            public void mouseEvent(EventType<MouseEvent> type, double x, double y, double screenX, double screenY,\n+                    MouseButton button, boolean popupTrigger, boolean synthesized, boolean shiftDown,\n+                    boolean controlDown, boolean altDown, boolean metaDown, boolean primaryDown, boolean middleDown,\n+                    boolean secondaryDown, boolean backDown, boolean forwardDown) {\n+            }\n+\n+            @Override\n+            public void keyEvent(KeyEvent keyEvent) {\n+            }\n+\n+            @Override\n+            public void inputMethodEvent(EventType<InputMethodEvent> type,\n+                    ObservableList<InputMethodTextRun> composed, String committed, int caretPosition) {\n+            }\n+\n+            @Override\n+            public void scrollEvent(EventType<ScrollEvent> eventType, double scrollX, double scrollY,\n+                    double totalScrollX, double totalScrollY, double xMultiplier, double yMultiplier,\n+                    int touchCount, int scrollTextX, int scrollTextY, int defaultTextX, int defaultTextY, double x,\n+                    double y, double screenX, double screenY, boolean _shiftDown, boolean _controlDown,\n+                    boolean _altDown, boolean _metaDown, boolean _direct, boolean _inertia) {\n+            }\n+\n+            @Override\n+            public void menuEvent(double x, double y, double xAbs, double yAbs, boolean isKeyboardTrigger) {\n+            }\n+\n+            @Override\n+            public void zoomEvent(EventType<ZoomEvent> eventType, double zoomFactor, double totalZoomFactor,\n+                    double x, double y, double screenX, double screenY, boolean _shiftDown, boolean _controlDown,\n+                    boolean _altDown, boolean _metaDown, boolean _direct, boolean _inertia) {\n+            }\n+\n+\n+            @Override\n+            public void rotateEvent(EventType<RotateEvent> eventType, double angle, double totalAngle, double x,\n+                    double y, double screenX, double screenY, boolean _shiftDown, boolean _controlDown,\n+                    boolean _altDown, boolean _metaDown, boolean _direct, boolean _inertia) {\n+                rotationEvents.add(new RotationEvent(eventType, angle, totalAngle, x, y, screenX, screenY, _inertia));\n+            }\n+\n+            @Override\n+            public void swipeEvent(EventType<SwipeEvent> eventType, int touchCount, double x, double y,\n+                    double screenX, double screenY, boolean _shiftDown, boolean _controlDown, boolean _altDown,\n+                    boolean _metaDown, boolean _direct) {\n+            }\n+\n+            @Override\n+            public void touchEventBegin(long time, int touchCount, boolean isDirect, boolean _shiftDown,\n+                    boolean _controlDown, boolean _altDown, boolean _metaDown) {\n+            }\n+\n+            @Override\n+            public void touchEventNext(State state, long touchId, double x, double y, double xAbs, double yAbs) {\n+            }\n+\n+            @Override\n+            public void touchEventEnd() {\n+            }\n+\n+            @Override\n+            public Accessible getSceneAccessible() {\n+                return null;\n+            }\n+        });\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/tk\/quantum\/RotateGestureRecognizerTest.java","additions":325,"deletions":0,"binary":false,"changes":325,"status":"added"}]}