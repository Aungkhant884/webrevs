{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import java.util.concurrent.TimeUnit;\n+\n@@ -29,0 +31,2 @@\n+    static final long INITIAL_VELOCITY_THRESHOLD_NANOS = 100L * 1000;\n+    static final double NANOS_TO_SECONDS = 1.0 \/ TimeUnit.SECONDS.toNanos(1);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/GestureRecognizer.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import com.sun.glass.events.KeyEvent;\n-import com.sun.glass.events.TouchEvent;\n-\n@@ -35,5 +32,5 @@\n-import java.util.Set;\n-import javafx.util.Duration;\n-import javafx.event.EventType;\n-import javafx.scene.input.RotateEvent;\n-import javafx.animation.Animation;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.sun.glass.events.KeyEvent;\n+import com.sun.glass.events.TouchEvent;\n+\n@@ -46,0 +43,2 @@\n+import javafx.scene.input.RotateEvent;\n+import javafx.util.Duration;\n@@ -48,1 +47,7 @@\n-    private ViewScene scene;\n+    private static final double MAX_INITIAL_VELOCITY = 500;\n+    private static final double ROTATION_INERTIA_MILLIS = 1500;\n+    private static final long ROTATION_INERTIA_THRESHOLD_NANOS = TimeUnit.MILLISECONDS.toNanos(300);\n+\n+    \/\/ gesture will be activated if |rotation| > rotationThresholdDegrees\n+    private static double rotationThresholdDegrees = 5;\n+    private static boolean rotationInertiaEnabled = true;\n@@ -50,5 +55,0 @@\n-    \/\/ gesture will be activated if |rotation| > ROTATATION_THRESHOLD\n-    private static double ROTATATION_THRESHOLD = 5; \/\/in degrees\n-    private static boolean ROTATION_INERTIA_ENABLED = true;\n-    private static double MAX_INITIAL_VELOCITY = 500;\n-    private static double ROTATION_INERTIA_MILLIS = 1500;\n@@ -60,1 +60,1 @@\n-                ROTATATION_THRESHOLD = Double.valueOf(s);\n+                rotationThresholdDegrees = Double.valueOf(s);\n@@ -64,1 +64,1 @@\n-                ROTATION_INERTIA_ENABLED = Boolean.valueOf(s);\n+                rotationInertiaEnabled = Boolean.valueOf(s);\n@@ -70,6 +70,3 @@\n-    private RotateRecognitionState state = RotateRecognitionState.IDLE;\n-    private Timeline inertiaTimeline = new Timeline();\n-    private DoubleProperty inertiaRotationVelocity = new SimpleDoubleProperty();\n-    private double initialInertiaRotationVelocity = 0;\n-    private double rotationStartTime = 0;\n-    private double lastTouchEventTime = 0;\n+    private final Timeline inertiaTimeline = new Timeline();\n+    private final DoubleProperty inertiaRotationVelocity = new SimpleDoubleProperty();\n+    private final Map<Long, TouchPointTracker> trackers = new HashMap<>();  \/\/ from MultiTouchTracker\n@@ -77,3 +74,4 @@\n-    \/\/ from MultiTouchTracker\n-    Map<Long, TouchPointTracker> trackers =\n-            new HashMap<Long, TouchPointTracker>();\n+    private ViewScene scene;\n+    private RotateRecognitionState state = RotateRecognitionState.IDLE;\n+    private double initialInertiaRotationVelocity;\n+    private long rotationStartNanos;\n@@ -81,2 +79,2 @@\n-    int modifiers;\n-    boolean direct;\n+    private int modifiers;\n+    private boolean direct;\n@@ -84,2 +82,1 @@\n-    \/\/private int touchCount;\n-    private int currentTouchCount = 0;\n+    private int currentTouchCount;\n@@ -88,5 +85,4 @@\n-    int touchPointsInEvent;\n-    long touchPointID1 = -1;\n-    long touchPointID2 = -1;\n-    double centerX, centerY;\n-    double centerAbsX, centerAbsY;\n+    private long touchPointID1 = -1;\n+    private long touchPointID2 = -1;\n+    private double centerX, centerY;\n+    private double centerAbsX, centerAbsY;\n@@ -94,4 +90,4 @@\n-    double currentRotation;\n-    double angleReference;\n-    double totalRotation = 0;\n-    double inertiaLastTime = 0;\n+    private double currentRotation;\n+    private double angleReference;\n+    private double totalRotation;\n+    private double inertiaLastTime;\n@@ -118,1 +114,0 @@\n-        touchPointsInEvent = 0;\n@@ -124,1 +119,0 @@\n-        touchPointsInEvent++;\n@@ -129,1 +123,1 @@\n-                touchPressed(touchId, time, x, y, xAbs, yAbs);\n+                touchPressed(touchId, x, y, xAbs, yAbs);\n@@ -134,1 +128,1 @@\n-                touchMoved(touchId, time, x, y, xAbs, yAbs);\n+                touchMoved(touchId, x, y, xAbs, yAbs);\n@@ -138,1 +132,1 @@\n-                touchReleased(touchId, time, x, y, xAbs, yAbs);\n+                touchReleased(touchId);\n@@ -222,2 +216,1 @@\n-    public void notifyEndTouchEvent(long time) {\n-        lastTouchEventTime = time;\n+    public void notifyEndTouchEvent(long nanos) {\n@@ -233,3 +226,4 @@\n-            if (ROTATION_INERTIA_ENABLED && (state == RotateRecognitionState.PRE_INERTIA || state == RotateRecognitionState.ACTIVE)) {\n-                double timeFromLastRotation = ((double)time - rotationStartTime) \/ 1000000;\n-                if (timeFromLastRotation < 300) {\n+            if (rotationInertiaEnabled && (state == RotateRecognitionState.PRE_INERTIA || state == RotateRecognitionState.ACTIVE)) {\n+                long nanosSinceLastRotation = nanos - rotationStartNanos;\n+\n+                if (nanosSinceLastRotation < ROTATION_INERTIA_THRESHOLD_NANOS) {\n@@ -250,4 +244,1 @@\n-                            event -> {\n-                                \/\/stop inertia\n-                                reset();\n-                            },\n+                            event -> reset(),  \/\/ stop inertia\n@@ -271,1 +262,1 @@\n-                    if (ROTATION_INERTIA_ENABLED) {\n+                    if (rotationInertiaEnabled) {\n@@ -300,1 +291,1 @@\n-                        if (Math.abs(currentRotation) > ROTATATION_THRESHOLD) {\n+                        if (Math.abs(currentRotation) > rotationThresholdDegrees) {\n@@ -310,4 +301,5 @@\n-                        double timePassed = ((double)time - rotationStartTime) \/ 1000000000;\n-                        if (timePassed > 1e-4) {\n-                            initialInertiaRotationVelocity = currentRotation \/ timePassed;\n-                            rotationStartTime = time;\n+                        long nanosPassed = nanos - rotationStartNanos;\n+\n+                        if (nanosPassed > INITIAL_VELOCITY_THRESHOLD_NANOS) {\n+                            initialInertiaRotationVelocity = currentRotation \/ nanosPassed * NANOS_TO_SECONDS;\n+                            rotationStartNanos = nanos;\n@@ -377,1 +369,1 @@\n-    public void params(int modifiers, boolean direct) {\n+    private void params(int modifiers, boolean direct) {\n@@ -382,1 +374,1 @@\n-    public void touchPressed(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n+    private void touchPressed(long id, int x, int y, int xAbs, int yAbs) {\n@@ -385,1 +377,1 @@\n-        tracker.update(nanos, x, y, xAbs, yAbs);\n+        tracker.update(x, y, xAbs, yAbs);\n@@ -389,1 +381,1 @@\n-    public void touchReleased(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n+    private void touchReleased(long id) {\n@@ -403,1 +395,1 @@\n-    public void touchMoved(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n+    private void touchMoved(long id, int x, int y, int xAbs, int yAbs) {\n@@ -415,1 +407,1 @@\n-        tracker.update(nanos, x, y, xAbs, yAbs);\n+        tracker.update(x, y, xAbs, yAbs);\n@@ -418,1 +410,1 @@\n-    void reset() {\n+    private void reset() {\n@@ -430,1 +422,1 @@\n-        public void update(long nanos, double x, double y, double absX, double absY) {\n+        public void update(double x, double y, double absX, double absY) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/RotateGestureRecognizer.java","additions":58,"deletions":66,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import com.sun.glass.events.KeyEvent;\n-import com.sun.glass.events.TouchEvent;\n-\n@@ -35,4 +32,5 @@\n-import javafx.util.Duration;\n-import javafx.event.EventType;\n-import javafx.scene.input.ScrollEvent;\n-import javafx.animation.Animation;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.sun.glass.events.KeyEvent;\n+import com.sun.glass.events.TouchEvent;\n+\n@@ -45,0 +43,2 @@\n+import javafx.scene.input.ScrollEvent;\n+import javafx.util.Duration;\n@@ -47,5 +47,8 @@\n-    \/\/ gesture will be activated if |scroll amount| > SCROLL_THRESHOLD\n-    private static double SCROLL_THRESHOLD = 10; \/\/in pixels\n-    private static boolean SCROLL_INERTIA_ENABLED = true;\n-    private static double MAX_INITIAL_VELOCITY = 1000;\n-    private static double SCROLL_INERTIA_MILLIS = 1500;\n+    private static final double MAX_INITIAL_VELOCITY = 1000;\n+    private static final double SCROLL_INERTIA_MILLIS = 1500;\n+    private static final long SCROLL_INERTIA_THRESHOLD_NANOS = TimeUnit.MILLISECONDS.toNanos(300);\n+\n+    \/\/ gesture will be activated if |scroll amount| > scrollThreshold\n+    private static double scrollThreshold = 10; \/\/in pixels\n+    private static boolean scrollInertiaEnabled = true;\n+\n@@ -57,1 +60,1 @@\n-                SCROLL_THRESHOLD = Double.valueOf(s);\n+                scrollThreshold = Double.valueOf(s);\n@@ -61,1 +64,1 @@\n-                SCROLL_INERTIA_ENABLED = Boolean.valueOf(s);\n+                scrollInertiaEnabled = Boolean.valueOf(s);\n@@ -67,1 +70,3 @@\n-    private ViewScene scene;\n+    private final Timeline inertiaTimeline = new Timeline();\n+    private final DoubleProperty inertiaScrollVelocity = new SimpleDoubleProperty();\n+    private final Map<Long, TouchPointTracker> trackers = new HashMap<>();\n@@ -69,0 +74,1 @@\n+    private ViewScene scene;\n@@ -70,8 +76,2 @@\n-    private Timeline inertiaTimeline = new Timeline();\n-    private DoubleProperty inertiaScrollVelocity = new SimpleDoubleProperty();\n-    private double initialInertiaScrollVelocity = 0;\n-    private double scrollStartTime = 0;\n-    private double lastTouchEventTime = 0;\n-\n-    private Map<Long, TouchPointTracker> trackers =\n-            new HashMap<Long, TouchPointTracker>();\n+    private double initialInertiaScrollVelocity;\n+    private long scrollStartNanos;\n@@ -82,1 +82,1 @@\n-    private int currentTouchCount = 0;\n+    private int currentTouchCount;\n@@ -94,1 +94,1 @@\n-    double inertiaLastTime = 0;\n+    private double inertiaLastTime;\n@@ -129,1 +129,1 @@\n-                touchPressed(touchId, time, x, y, xAbs, yAbs);\n+                touchPressed(touchId, x, y, xAbs, yAbs);\n@@ -134,1 +134,1 @@\n-                touchMoved(touchId, time, x, y, xAbs, yAbs);\n+                touchMoved(touchId, x, y, xAbs, yAbs);\n@@ -138,1 +138,1 @@\n-                touchReleased(touchId, time, x, y, xAbs, yAbs);\n+                touchReleased(touchId);\n@@ -168,2 +168,1 @@\n-    public void notifyEndTouchEvent(long time) {\n-        lastTouchEventTime = time;\n+    public void notifyEndTouchEvent(long nanos) {\n@@ -179,3 +178,4 @@\n-                if (SCROLL_INERTIA_ENABLED) {\n-                    double timeFromLastScroll = ((double)time - scrollStartTime) \/ 1000000;\n-                    if (timeFromLastScroll < 300) {\n+                if (scrollInertiaEnabled) {\n+                    double nanosSinceLastScroll = nanos - scrollStartNanos;\n+\n+                    if (nanosSinceLastScroll < SCROLL_INERTIA_THRESHOLD_NANOS) {\n@@ -194,4 +194,1 @@\n-                                event -> {\n-                                    \/\/stop inertia\n-                                    reset();\n-                                },\n+                                event -> reset(),  \/\/ stop inertia\n@@ -238,1 +235,1 @@\n-                    if ( Math.abs(deltaX) > SCROLL_THRESHOLD || Math.abs(deltaY) > SCROLL_THRESHOLD) {\n+                    if ( Math.abs(deltaX) > scrollThreshold || Math.abs(deltaY) > scrollThreshold) {\n@@ -248,2 +245,3 @@\n-                    double timePassed = ((double)time - scrollStartTime) \/ 1000000000;\n-                    if (timePassed > 1e-4) {\n+                    long nanosPassed = nanos - scrollStartNanos;\n+\n+                    if (nanosPassed > INITIAL_VELOCITY_THRESHOLD_NANOS) {\n@@ -254,1 +252,1 @@\n-                        initialInertiaScrollVelocity = scrollMagnitude \/ timePassed;\n+                        initialInertiaScrollVelocity = scrollMagnitude \/ nanosPassed * NANOS_TO_SECONDS;\n@@ -256,1 +254,1 @@\n-                        scrollStartTime = time;\n+                        scrollStartNanos = nanos;\n@@ -332,1 +330,1 @@\n-    public void params(int modifiers, boolean direct) {\n+    private void params(int modifiers, boolean direct) {\n@@ -337,1 +335,1 @@\n-    public void touchPressed(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n+    private void touchPressed(long id, int x, int y, int xAbs, int yAbs) {\n@@ -340,1 +338,1 @@\n-        tracker.update(nanos, x, y, xAbs, yAbs);\n+        tracker.update(x, y, xAbs, yAbs);\n@@ -344,1 +342,1 @@\n-    public void touchReleased(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n+    private void touchReleased(long id) {\n@@ -358,1 +356,1 @@\n-    public void touchMoved(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n+    private void touchMoved(long id, int x, int y, int xAbs, int yAbs) {\n@@ -370,1 +368,1 @@\n-        tracker.update(nanos, x, y, xAbs, yAbs);\n+        tracker.update(x, y, xAbs, yAbs);\n@@ -373,1 +371,1 @@\n-    void reset() {\n+    private void reset() {\n@@ -383,1 +381,1 @@\n-        public void update(long nanos, double x, double y, double absX, double absY) {\n+        public void update(double x, double y, double absX, double absY) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/ScrollGestureRecognizer.java","additions":48,"deletions":50,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import com.sun.glass.events.KeyEvent;\n-import com.sun.glass.events.TouchEvent;\n-\n@@ -35,4 +32,5 @@\n-import javafx.util.Duration;\n-import javafx.event.EventType;\n-import javafx.scene.input.ZoomEvent;\n-import javafx.animation.Animation;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.sun.glass.events.KeyEvent;\n+import com.sun.glass.events.TouchEvent;\n+\n@@ -45,0 +43,2 @@\n+import javafx.scene.input.ZoomEvent;\n+import javafx.util.Duration;\n@@ -47,8 +47,8 @@\n-    \/\/ gesture will be activated if |zoomFactor - 1| > ZOOM_FACTOR_THRESHOLD\n-    private static double ZOOM_FACTOR_THRESHOLD = 0.1;\n-    private static boolean ZOOM_INERTIA_ENABLED = true;\n-    private static double MAX_ZOOMIN_VELOCITY = 3.0;\n-    private static double MAX_ZOOMOUT_VELOCITY = 0.3333;\n-    private static double ZOOM_INERTIA_MILLIS = 500;\n-    private static double MAX_ZOOM_IN_FACTOR = 10;\n-    private static double MAX_ZOOM_OUT_FACTOR = 0.1;\n+    private static final double ZOOM_INERTIA_MILLIS = 500;\n+    private static final double MAX_ZOOM_IN_FACTOR = 10;\n+    private static final double MAX_ZOOM_OUT_FACTOR = 0.1;\n+    private static final long ZOOM_INERTIA_THRESHOLD_NANOS = TimeUnit.MILLISECONDS.toNanos(200);\n+\n+    \/\/ gesture will be activated if |zoomFactor - 1| > zoomFactorThreshold\n+    private static double zoomFactorThreshold = 0.1;\n+    private static boolean zoomInertiaEnabled = true;\n@@ -61,1 +61,1 @@\n-                ZOOM_FACTOR_THRESHOLD = Double.valueOf(s);\n+                zoomFactorThreshold = Double.valueOf(s);\n@@ -65,1 +65,1 @@\n-                ZOOM_INERTIA_ENABLED = Boolean.valueOf(s);\n+                zoomInertiaEnabled = Boolean.valueOf(s);\n@@ -71,0 +71,4 @@\n+    private final Timeline inertiaTimeline = new Timeline();\n+    private final DoubleProperty inertiaZoomVelocity = new SimpleDoubleProperty();\n+    private final Map<Long, TouchPointTracker> trackers = new HashMap<>();\n+\n@@ -72,5 +76,2 @@\n-    private Timeline inertiaTimeline = new Timeline();\n-    private DoubleProperty inertiaZoomVelocity = new SimpleDoubleProperty();\n-    private double initialInertiaZoomVelocity = 0;\n-    private double zoomStartTime = 0;\n-    private double lastTouchEventTime = 0;\n+    private double initialInertiaZoomVelocity;\n+    private long zoomStartNanos;\n@@ -80,3 +81,0 @@\n-    private Map<Long, TouchPointTracker> trackers =\n-            new HashMap<Long, TouchPointTracker>();\n-\n@@ -92,1 +90,0 @@\n-    private double currentDistance;\n@@ -96,1 +93,1 @@\n-    double inertiaLastTime = 0;\n+    private double inertiaLastTime;\n@@ -128,1 +125,1 @@\n-                touchPressed(touchId, time, x, y, xAbs, yAbs);\n+                touchPressed(touchId, x, y, xAbs, yAbs);\n@@ -133,1 +130,1 @@\n-                touchMoved(touchId, time, x, y, xAbs, yAbs);\n+                touchMoved(touchId, x, y, xAbs, yAbs);\n@@ -137,1 +134,1 @@\n-                touchReleased(touchId, time, x, y, xAbs, yAbs);\n+                touchReleased(touchId);\n@@ -182,2 +179,1 @@\n-    public void notifyEndTouchEvent(long time) {\n-        lastTouchEventTime = time;\n+    public void notifyEndTouchEvent(long nanos) {\n@@ -193,3 +189,4 @@\n-            if (ZOOM_INERTIA_ENABLED && (state == ZoomRecognitionState.PRE_INERTIA || state == ZoomRecognitionState.ACTIVE)) {\n-                double timeFromLastZoom = ((double)time - zoomStartTime) \/ 1000000;\n-                if (initialInertiaZoomVelocity != 0 && timeFromLastZoom < 200) {\n+            if (zoomInertiaEnabled && (state == ZoomRecognitionState.PRE_INERTIA || state == ZoomRecognitionState.ACTIVE)) {\n+                long nanosSinceLastZoom = nanos - zoomStartNanos;\n+\n+                if (initialInertiaZoomVelocity != 0 && nanosSinceLastZoom < ZOOM_INERTIA_THRESHOLD_NANOS) {\n@@ -220,1 +217,0 @@\n-                            \/\/Duration.millis(ZOOM_INERTIA_MILLIS * Math.abs(initialInertiaZoomVelocity - 1) \/ (MAX_ZOOMIN_VELOCITY - 1)),\n@@ -222,4 +218,1 @@\n-                            event -> {\n-                                \/\/stop inertia\n-                                reset();\n-                            },\n+                            event -> reset(),  \/\/ stop inertia\n@@ -246,1 +239,1 @@\n-                    if (ZOOM_INERTIA_ENABLED) {\n+                    if (zoomInertiaEnabled) {\n@@ -258,1 +251,1 @@\n-                    zoomStartTime = time;\n+                    zoomStartNanos = nanos;\n@@ -271,1 +264,1 @@\n-                        if ( Math.abs(zoomFactor - 1) > ZOOM_FACTOR_THRESHOLD) {\n+                        if ( Math.abs(zoomFactor - 1) > zoomFactorThreshold) {\n@@ -281,4 +274,5 @@\n-                        double timePassed = ((double)time - zoomStartTime) \/ 1000000000;\n-                        if (timePassed > 1e-4) {\n-                            initialInertiaZoomVelocity = (totalZoomFactor - prevTotalZoomFactor) \/ timePassed;\n-                            zoomStartTime = time;\n+                        long nanosPassed = nanos - zoomStartNanos;\n+\n+                        if (nanosPassed > INITIAL_VELOCITY_THRESHOLD_NANOS) {\n+                            initialInertiaZoomVelocity = (totalZoomFactor - prevTotalZoomFactor) \/ nanosPassed * NANOS_TO_SECONDS;\n+                            zoomStartNanos = nanos;\n@@ -350,1 +344,1 @@\n-    public void params(int modifiers, boolean direct) {\n+    private void params(int modifiers, boolean direct) {\n@@ -355,1 +349,1 @@\n-    public void touchPressed(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n+    private void touchPressed(long id, int x, int y, int xAbs, int yAbs) {\n@@ -358,1 +352,1 @@\n-        tracker.update(nanos, x, y, xAbs, yAbs);\n+        tracker.update(x, y, xAbs, yAbs);\n@@ -362,1 +356,1 @@\n-    public void touchReleased(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n+    private void touchReleased(long id) {\n@@ -376,1 +370,1 @@\n-    public void touchMoved(long id, long nanos, int x, int y, int xAbs, int yAbs) {\n+    private void touchMoved(long id, int x, int y, int xAbs, int yAbs) {\n@@ -388,1 +382,1 @@\n-        tracker.update(nanos, x, y, xAbs, yAbs);\n+        tracker.update(x, y, xAbs, yAbs);\n@@ -391,1 +385,1 @@\n-    void reset() {\n+    private void reset() {\n@@ -401,1 +395,1 @@\n-        public void update(long nanos, double x, double y, double absX, double absY) {\n+        public void update(double x, double y, double absX, double absY) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/ZoomGestureRecognizer.java","additions":49,"deletions":55,"binary":false,"changes":104,"status":"modified"}]}