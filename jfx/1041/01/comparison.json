{"files":[{"patch":"@@ -28,3 +28,0 @@\n-import javafx.collections.ModifiableObservableListBase;\n-import com.sun.javafx.collections.NonIterableChange.SimplePermutationChange;\n-\n@@ -36,0 +33,3 @@\n+\n+import com.sun.javafx.collections.NonIterableChange.SimplePermutationChange;\n+\n@@ -38,0 +38,1 @@\n+import javafx.collections.ModifiableObservableListBase;\n@@ -44,2 +45,1 @@\n-public class ObservableListWrapper<E> extends ModifiableObservableListBase<E> implements\n-        SortableList<E>, RandomAccess {\n+public class ObservableListWrapper<E> extends ModifiableObservableListBase<E> implements SortableList<E>, RandomAccess {\n@@ -48,1 +48,0 @@\n-\n@@ -225,12 +224,2 @@\n-    public void sort() {\n-        sort(null);\n-    }\n-\n-    @Override\n-    public void sort(Comparator<? super E> comparator) {\n-        if (backingList.isEmpty()) {\n-            return;\n-        }\n-        @SuppressWarnings(\"unchecked\")\n-        int[] perm = comparator == null ? getSortHelper().sort((List<? extends Comparable<Object>>) backingList)\n-                : getSortHelper().sort(backingList, comparator);\n+    public void doSort(Comparator<? super E> comparator) {\n+        int[] perm = getSortHelper().sort(backingList, comparator);\n@@ -246,1 +235,0 @@\n-\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/ObservableListWrapper.java","additions":7,"deletions":19,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,0 +33,3 @@\n+\n+import com.sun.javafx.collections.NonIterableChange.SimplePermutationChange;\n+\n@@ -38,1 +41,2 @@\n-public class ObservableSequentialListWrapper<E> extends ModifiableObservableListBase<E> implements SortableList<E>{\n+public class ObservableSequentialListWrapper<E> extends ModifiableObservableListBase<E> implements SortableList<E> {\n+\n@@ -41,1 +45,0 @@\n-    private SortHelper helper;\n@@ -241,4 +244,1 @@\n-    @Override\n-    public void sort() {\n-        sort(null);\n-    }\n+    private SortHelper helper;\n@@ -247,9 +247,3 @@\n-    public void sort(Comparator<? super E> comparator) {\n-        if (backingList.isEmpty()) {\n-            return;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")\n-        int[] perm = comparator == null ? getSortHelper().sort((List<? extends Comparable<Object>>) backingList)\n-                : getSortHelper().sort(backingList, comparator);\n-        fireChange(new NonIterableChange.SimplePermutationChange<>(0, size(), perm, this));\n+    public void doSort(Comparator<? super E> comparator) {\n+        int[] perm = getSortHelper().sort(backingList, comparator);\n+        fireChange(new SimplePermutationChange<>(0, size(), perm, this));\n@@ -264,1 +258,0 @@\n-\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/ObservableSequentialListWrapper.java","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -35,2 +35,4 @@\n- * Helper class that contains algorithms taken from JDK that additionally\n- * tracks the permutation that's created thorough the process\n+ * A helper class containing algorithms taken from JDK 6 that additionally track the permutations that're created\n+ * during the process.\n+ *\n+ * @see Arrays\n@@ -39,0 +41,1 @@\n+\n@@ -44,9 +47,5 @@\n-    public <T extends Comparable<? super T>> int[] sort(List<T> list) {\n-        T[] a = (T[]) Array.newInstance(Comparable.class, list.size());\n-        try {\n-            a = list.toArray(a);\n-        } catch (ArrayStoreException e) {\n-            \/\/ this means this is not comparable (used without generics)\n-            throw new ClassCastException();\n-        }\n-        int[] result = sort(a);\n+    \/\/ Used only by Observable[Sequential]ListWrapper, comparator can't be null here\n+    public <T> int[] sort(List<T> list, Comparator<? super T> comparator) {\n+        @SuppressWarnings(\"unchecked\")\n+        T[] a = (T[]) list.toArray();\n+        int[] result = sort(a, comparator);\n@@ -54,1 +53,1 @@\n-        for (int j=0; j<a.length; j++) {\n+        for (int j = 0; j < a.length; j++) {\n@@ -61,22 +60,4 @@\n-    public <T> int[] sort(List<T> list, Comparator<? super T> c) {\n-        Object[] a = list.toArray();\n-        int[] result = sort(a, (Comparator)c);\n-        ListIterator i = list.listIterator();\n-        for (int j=0; j<a.length; j++) {\n-            i.next();\n-            i.set(a[j]);\n-        }\n-        return result;\n-    }\n-\n-    public <T extends Comparable<? super T>> int[] sort(T[] a) {\n-        return sort(a, null);\n-    }\n-\n-    public <T> int[] sort(T[] a, Comparator<? super T> c) {\n-        T[] aux = a.clone();\n-        int[] result = initPermutation(a.length);\n-        if (c==null)\n-            mergeSort(aux, a, 0, a.length, 0);\n-        else\n-            mergeSort(aux, a, 0, a.length, 0, c);\n+    private <T> int[] sort(T[] items, Comparator<? super T> comparator) {\n+        T[] aux = items.clone();\n+        int[] result = initPermutation(items.length);\n+        mergeSort(aux, items, 0, items.length, 0, comparator);\n@@ -88,9 +69,6 @@\n-    public <T> int[] sort(T[] a, int fromIndex, int toIndex,\n-                Comparator<? super T> c) {\n-        rangeCheck(a.length, fromIndex, toIndex);\n-        T[] aux = copyOfRange(a, fromIndex, toIndex);\n-        int[] result = initPermutation(a.length);\n-        if (c==null)\n-            mergeSort(aux, a, fromIndex, toIndex, -fromIndex);\n-        else\n-            mergeSort(aux, a, fromIndex, toIndex, -fromIndex, c);\n+    \/\/ Used only by {@link SortedList}, comparator can't be null here\n+    public <T> int[] sort(T[] items, int fromIndex, int toIndex, Comparator<? super T> comparator) {\n+        rangeCheck(items.length, fromIndex, toIndex);\n+        T[] aux = copyOfRange(items, fromIndex, toIndex);\n+        int[] result = initPermutation(items.length);\n+        mergeSort(aux, items, fromIndex, toIndex, -fromIndex, comparator);\n@@ -102,5 +80,6 @@\n-    public int[] sort(int[] a, int fromIndex, int toIndex) {\n-        rangeCheck(a.length, fromIndex, toIndex);\n-        int[] aux = copyOfRange(a, fromIndex, toIndex);\n-        int[] result = initPermutation(a.length);\n-        mergeSort(aux, a, fromIndex, toIndex, -fromIndex);\n+    \/\/ used only by {@link FilteredList}\n+    public int[] sort(int[] indices, int fromIndex, int toIndex) {\n+        rangeCheck(indices.length, fromIndex, toIndex);\n+        int[] aux = copyOfRange(indices, fromIndex, toIndex);\n+        int[] result = initPermutation(indices.length);\n+        mergeSort(aux, indices, fromIndex, toIndex, -fromIndex);\n@@ -113,4 +92,4 @@\n-        if (fromIndex > toIndex)\n-            throw new IllegalArgumentException(\"fromIndex(\" + fromIndex +\n-                       \") > toIndex(\" + toIndex+\")\");\n-        if (fromIndex < 0)\n+        if (fromIndex > toIndex) {\n+            throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\n+        }\n+        if (fromIndex < 0) {\n@@ -118,1 +97,2 @@\n-        if (toIndex > arrayLen)\n+        }\n+        if (toIndex > arrayLen) {\n@@ -120,0 +100,1 @@\n+        }\n@@ -125,1 +106,1 @@\n-        if (newLength < 0)\n+        if (newLength < 0) {\n@@ -127,0 +108,1 @@\n+        }\n@@ -128,2 +110,1 @@\n-        System.arraycopy(original, from, copy, 0,\n-                         Math.min(original.length - from, newLength));\n+        System.arraycopy(original, from, copy, 0, Math.min(original.length - from, newLength));\n@@ -137,1 +118,1 @@\n-    private static <T,U> T[] copyOfRange(U[] original, int from, int to, Class<? extends T[]> newType) {\n+    private static <T, U> T[] copyOfRange(U[] original, int from, int to, Class<? extends T[]> newType) {\n@@ -139,1 +120,1 @@\n-        if (newLength < 0)\n+        if (newLength < 0) {\n@@ -141,5 +122,4 @@\n-        T[] copy = ((Object)newType == (Object)Object[].class)\n-            ? (T[]) new Object[newLength]\n-            : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n-        System.arraycopy(original, from, copy, 0,\n-                         Math.min(original.length - from, newLength));\n+        }\n+        T[] copy = ((Object) newType == (Object) Object[].class) ? (T[]) new Object[newLength]\n+                : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n+        System.arraycopy(original, from, copy, 0, Math.min(original.length - from, newLength));\n@@ -149,8 +129,2 @@\n-    \/**\n-     * Merge sort from Oracle JDK 6\n-     *\/\n-    private void mergeSort(int[] src,\n-                  int[] dest,\n-                  int low,\n-                  int high,\n-                  int off) {\n+\n+    private void mergeSort(int[] src, int[] dest, int low, int high, int off) {\n@@ -161,4 +135,5 @@\n-            for (int i=low; i<high; i++)\n-                for (int j=i; j>low &&\n-                     ((Comparable) dest[j-1]).compareTo(dest[j])>0; j--)\n-                    swap(dest, j, j-1);\n+            for (int i = low; i < high; i++) {\n+                for (int j = i; j > low && Integer.compare(dest[j - 1], dest[j]) > 0; j--) {\n+                    swap(dest, j, j - 1);\n+                }\n+            }\n@@ -169,1 +144,1 @@\n-        int destLow  = low;\n+        int destLow = low;\n@@ -171,1 +146,1 @@\n-        low  += off;\n+        low += off;\n@@ -177,1 +152,1 @@\n-        \/\/ If list is already sorted, just copy from src to dest.  This is an\n+        \/\/ If list is already sorted, just copy from src to dest. This is an\n@@ -179,1 +154,1 @@\n-        if (((Comparable)src[mid-1]).compareTo(src[mid]) <= 0) {\n+        if (Integer.compare(src[mid - 1], src[mid]) <= 0) {\n@@ -185,2 +160,2 @@\n-        for(int i = destLow, p = low, q = mid; i < destHigh; i++) {\n-            if (q >= high || p < mid && ((Comparable)src[p]).compareTo(src[q])<=0) {\n+        for (int i = destLow, p = low, q = mid; i < destHigh; i++) {\n+            if (q >= high || p < mid && Integer.compare(src[p], src[q]) <= 0) {\n@@ -200,8 +175,2 @@\n-    \/**\n-     * Merge sort from Oracle JDK 6\n-     *\/\n-    private void mergeSort(Object[] src,\n-                  Object[] dest,\n-                  int low,\n-                  int high,\n-                  int off) {\n+\n+    private <T> void mergeSort(T[] src, T[] dest, int low, int high, int off, Comparator<? super T> comparator) {\n@@ -212,4 +181,5 @@\n-            for (int i=low; i<high; i++)\n-                for (int j=i; j>low &&\n-                     ((Comparable) dest[j-1]).compareTo(dest[j])>0; j--)\n-                    swap(dest, j, j-1);\n+            for (int i = low; i < high; i++) {\n+                for (int j = i; j > low && comparator.compare(dest[j - 1], dest[j]) > 0; j--) {\n+                    swap(dest, j, j - 1);\n+                }\n+            }\n@@ -220,1 +190,1 @@\n-        int destLow  = low;\n+        int destLow = low;\n@@ -222,1 +192,1 @@\n-        low  += off;\n+        low += off;\n@@ -225,2 +195,2 @@\n-        mergeSort(dest, src, low, mid, -off);\n-        mergeSort(dest, src, mid, high, -off);\n+        mergeSort(dest, src, low, mid, -off, comparator);\n+        mergeSort(dest, src, mid, high, -off, comparator);\n@@ -228,1 +198,1 @@\n-        \/\/ If list is already sorted, just copy from src to dest.  This is an\n+        \/\/ If list is already sorted, just copy from src to dest. This is an\n@@ -230,1 +200,1 @@\n-        if (((Comparable)src[mid-1]).compareTo(src[mid]) <= 0) {\n+        if (comparator.compare(src[mid - 1], src[mid]) <= 0) {\n@@ -236,48 +206,2 @@\n-        for(int i = destLow, p = low, q = mid; i < destHigh; i++) {\n-            if (q >= high || p < mid && ((Comparable)src[p]).compareTo(src[q])<=0) {\n-                dest[i] = src[p];\n-                permutation[reversePermutation[p++]] = i;\n-            } else {\n-                dest[i] = src[q];\n-                permutation[reversePermutation[q++]] = i;\n-            }\n-        }\n-\n-        for (int i = destLow; i < destHigh; ++i) {\n-            reversePermutation[permutation[i]] = i;\n-        }\n-    }\n-\n-    private void mergeSort(Object[] src,\n-                  Object[] dest,\n-                  int low, int high, int off,\n-                  Comparator c) {\n-        int length = high - low;\n-\n-        \/\/ Insertion sort on smallest arrays\n-        if (length < INSERTIONSORT_THRESHOLD) {\n-            for (int i=low; i<high; i++)\n-            for (int j=i; j>low && c.compare(dest[j-1], dest[j])>0; j--)\n-                swap(dest, j, j-1);\n-            return;\n-        }\n-\n-        \/\/ Recursively sort halves of dest into src\n-        int destLow  = low;\n-        int destHigh = high;\n-        low  += off;\n-        high += off;\n-        int mid = (low + high) >>> 1;\n-        mergeSort(dest, src, low, mid, -off, c);\n-        mergeSort(dest, src, mid, high, -off, c);\n-\n-        \/\/ If list is already sorted, just copy from src to dest.  This is an\n-        \/\/ optimization that results in faster sorts for nearly ordered lists.\n-        if (c.compare(src[mid-1], src[mid]) <= 0) {\n-           System.arraycopy(src, low, dest, destLow, length);\n-           return;\n-        }\n-\n-        \/\/ Merge sorted halves (now in src) into dest\n-        for(int i = destLow, p = low, q = mid; i < destHigh; i++) {\n-            if (q >= high || p < mid && c.compare(src[p], src[q]) <= 0) {\n+        for (int i = destLow, p = low, q = mid; i < destHigh; i++) {\n+            if (q >= high || p < mid && comparator.compare(src[p], src[q]) <= 0) {\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/SortHelper.java","additions":71,"deletions":147,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -29,1 +29,3 @@\n-import java.util.List;\n+\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n@@ -32,4 +34,5 @@\n- * SortableList is a list that can sort itself in an efficient way, in contrast to the\n- * Collections.sort() method which threat all lists the same way.\n- * E.g. ObservableList can sort and fire only one notification.\n- * @param <E>\n+ * A helper and marker interface used for {@code ObservableList}s that implement sorting algorithms that report\n+ * the sort as one change.\n+ *\n+ * @param <E> the element type of the list\n+ * @see FXCollections#sort(ObservableList, Comparator)\n@@ -37,1 +40,1 @@\n-public interface SortableList<E> extends List<E> {\n+public interface SortableList<E> extends ObservableList<E> {\n@@ -39,6 +42,10 @@\n-    \/**\n-     * Sort using default comparator\n-     * @throws ClassCastException if some of the elements cannot be cast to Comparable\n-     * @throws UnsupportedOperationException if list's iterator doesn't support set\n-     *\/\n-    public void sort();\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public default void sort(Comparator<? super E> comparator) {\n+        if (size() == 0 || size() == 1) {\n+            return;\n+        }\n+        \/\/ The cast will succeed, but a ClassCastException will be thrown as specified when compare is called\n+        comparator = comparator != null ? comparator : (Comparator<? super E>) Comparator.naturalOrder();\n+        doSort(comparator);\n+    }\n@@ -47,6 +54,3 @@\n-     * Sort using comparator\n-     * @param comparator the comparator to use\n-     * @throws ClassCastException if the list contains elements that are not\n-     *         <i>mutually comparable<\/i> using the specified comparator.\n-     * @throws UnsupportedOperationException if the specified list's\n-     *         list-iterator does not support the <tt>set<\/tt> operation.\n+     * Sorts the list and reports it as one change event.\n+     *\n+     * @param comparator the comparator for the sorting; never {@code null}\n@@ -54,3 +58,1 @@\n-    @Override\n-    public void sort(Comparator<? super E> comparator);\n-\n+    void doSort(Comparator<? super E> comparator);\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/SortableList.java","additions":23,"deletions":21,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -670,1 +670,1 @@\n-     * Sorts the provided observable list.\n+     * Sorts the provided observable list as specified in {@link java.util.Collections#sort(List) Collections.sort(List)}.\n@@ -672,1 +672,2 @@\n-     * @param <T> The type of List to be wrapped\n+     *\n+     * @param <T> the element type of the list\n@@ -674,1 +675,0 @@\n-     * @see Collections#sort(java.util.List)\n@@ -677,7 +677,1 @@\n-        if (list instanceof SortableList<?> sortableList) {\n-            sortableList.sort();\n-        } else {\n-            List<T> newContent = new ArrayList<>(list);\n-            Collections.sort(newContent);\n-            list.setAll(newContent);\n-        }\n+        sort(list, Comparator.naturalOrder());\n@@ -687,1 +681,2 @@\n-     * Sorts the provided observable list using the c comparator.\n+     * Sorts the provided observable list as specified in\n+     * {@link java.util.Collections#sort(List, Comparator) Collections.sort(List, Comparator)}.\n@@ -689,1 +684,2 @@\n-     * @param <T> The type of List to be wrapped\n+     *\n+     * @param <T> the element type of the list\n@@ -691,2 +687,2 @@\n-     * @param c comparator used for sorting. Null if natural ordering is required.\n-     * @see Collections#sort(java.util.List, java.util.Comparator)\n+     * @param comparator the comparator to determine the order of the list. A {@code null} value indicates that the\n+     *      elements' <i>natural ordering<\/i> should be used.\n@@ -694,2 +690,1 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public static <T> void sort(ObservableList<T> list, Comparator<? super T> c) {\n+    public static <T> void sort(ObservableList<T> list, Comparator<? super T> comparator) {\n@@ -697,1 +692,1 @@\n-            ((SortableList<? extends T>)list).sort(c);\n+            list.sort(comparator);\n@@ -700,1 +695,1 @@\n-            Collections.sort(newContent, c);\n+            newContent.sort(comparator);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/collections\/FXCollections.java","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"}]}