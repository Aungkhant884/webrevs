{"files":[{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.binding;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+\n+\/**\n+ * A subscription encapsulates how to cancel it without having\n+ * to keep track of how it was created.<p>\n+ *\n+ * For example:<p>\n+ * <pre>Subscription s = property.subscribe(System.out::println)<\/pre>\n+ * The function passed in to {@code subscribe} does not need to be stored\n+ * in order to clean up the subscription later.\n+ *\/\n+@FunctionalInterface\n+public interface Subscription {\n+\n+    \/**\n+     * An empty subscription. Does nothing when cancelled.\n+     *\/\n+    static final Subscription EMPTY = () -> {};\n+\n+    \/**\n+     * Cancels this subscription.\n+     *\/\n+    void unsubscribe();\n+\n+    \/**\n+     * Combines this {@link Subscription} with the given {@code Subscription}\n+     * and returns a new {@code Subscription} which will cancel both when\n+     * cancelled.\n+     *\n+     * @param other another {@link Subscription}, cannot be null\n+     * @return a combined {@link Subscription} which will cancel both when\n+     *     cancelled, never null\n+     *\/\n+    default Subscription and(Subscription other) {\n+        Objects.requireNonNull(other);\n+\n+        return () -> {\n+            unsubscribe();\n+            other.unsubscribe();\n+        };\n+    }\n+\n+    \/**\n+     * Creates a {@link Subscription} on this {@link ObservableValue} which\n+     * immediately provides its current value to the given {@code subscriber},\n+     * followed by any subsequent changes in value.\n+     *\n+     * @param subscriber a {@link Consumer} to supply with the values of this\n+     *     {@link ObservableValue}, cannot be null\n+     * @return a {@link Subscription} which can be used to cancel this\n+     *     subscription, never null\n+     *\/\n+    static <T> Subscription subscribe(ObservableValue<T> observableValue, Consumer<? super T> subscriber) {\n+        ChangeListener<T> listener = (obs, old, current) -> subscriber.accept(current);\n+\n+        subscriber.accept(observableValue.getValue());  \/\/ eagerly send current value\n+        observableValue.addListener(listener);\n+\n+        return () -> observableValue.removeListener(listener);\n+    }\n+\n+    \/**\n+     * Creates a {@link Subscription} on this {@link ObservableValue} which\n+     * calls the given {@code runnable} whenever this {@code ObservableValue}\n+     * becomes invalid.\n+     *\n+     * @param runnable a {@link Runnable} to call whenever this\n+     *     {@link ObservableValue} becomes invalid, cannot be null\n+     * @return a {@link Subscription} which can be used to cancel this\n+     *     subscription, never null\n+     *\/\n+    static Subscription subscribeInvalidations(ObservableValue<?> observableValue, Runnable runnable) {\n+        InvalidationListener listener = obs -> runnable.run();\n+\n+        observableValue.addListener(listener);\n+\n+        return () -> observableValue.removeListener(listener);\n+    }\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/Subscription.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,4 @@\n-            valid = true;\n+\n+            if (allowValidation()) {\n+                valid = true;\n+            }\n@@ -185,0 +188,22 @@\n+    \/**\n+     * Returns {@code true} when this binding currently has one or more\n+     * listeners, otherwise {@code false}.\n+     *\n+     * @return {@code true} when this binding currently has one or more\n+     *     listeners, otherwise {@code false}\n+     *\/\n+    protected final boolean isObserved() {\n+        return helper != null;\n+    }\n+\n+    \/**\n+     * Can be overriden in extending classes to prevent a binding from becoming\n+     * valid. The default implementation always allows bindings to become valid.\n+     *\n+     * @return {@code true} if this binding is allowed to become valid, otherwise\n+     *     {@code false}\n+     *\/\n+    protected boolean allowValidation() {\n+        return true;\n+    }\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/binding\/ObjectBinding.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.beans.value;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import com.sun.javafx.binding.Subscription;\n+\n+class FlatMappedBinding<S, T> extends LazyObjectBinding<T> {\n+    private final ObservableValue<S> source;\n+    private final Function<? super S, ? extends ObservableValue<? extends T>> mapper;\n+\n+    private Subscription mappedSubscription = Subscription.EMPTY;\n+\n+    public FlatMappedBinding(ObservableValue<S> source, Function<? super S, ? extends ObservableValue<? extends T>> mapper) {\n+        this.source = Objects.requireNonNull(source, \"source cannot be null\");\n+        this.mapper = Objects.requireNonNull(mapper, \"mapper cannot be null\");\n+    }\n+\n+    @Override\n+    protected T computeValue() {\n+        S value = source.getValue();\n+        ObservableValue<? extends T> mapped = value == null ? null : mapper.apply(value);\n+\n+        if (isObserved()) {\n+            mappedSubscription.unsubscribe();\n+            mappedSubscription = mapped == null ? Subscription.EMPTY : Subscription.subscribeInvalidations(mapped, this::invalidate);\n+        }\n+\n+        return mapped == null ? null : mapped.getValue();\n+    }\n+\n+    @Override\n+    protected Subscription observeInputs() {\n+        Subscription subscription = Subscription.subscribeInvalidations(source, this::invalidate);\n+\n+        return () -> {\n+            subscription.unsubscribe();\n+            mappedSubscription.unsubscribe();\n+            mappedSubscription = Subscription.EMPTY;\n+        };\n+    }\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/FlatMappedBinding.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.beans.value;\n+\n+import com.sun.javafx.binding.Subscription;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.binding.ObjectBinding;\n+\n+\/**\n+ * Extends {@link ObjectBinding} with the ability to lazily register and eagerly unregister listeners on its\n+ * dependencies.\n+ *\n+ * @param <T> the type of the wrapped {@code Object}\n+ *\/\n+abstract class LazyObjectBinding<T> extends ObjectBinding<T> {\n+    private Subscription subscription;\n+    private boolean wasObserved;\n+\n+    @Override\n+    public void addListener(ChangeListener<? super T> listener) {\n+        super.addListener(listener);\n+\n+        updateSubcriptionAfterAdd();\n+    }\n+\n+    @Override\n+    public void removeListener(ChangeListener<? super T> listener) {\n+        super.removeListener(listener);\n+\n+        updateSubcriptionAfterRemove();\n+    }\n+\n+    @Override\n+    public void addListener(InvalidationListener listener) {\n+        super.addListener(listener);\n+\n+        updateSubcriptionAfterAdd();\n+    }\n+\n+    @Override\n+    public void removeListener(InvalidationListener listener) {\n+        super.removeListener(listener);\n+\n+        updateSubcriptionAfterRemove();\n+    }\n+\n+    @Override\n+    protected boolean allowValidation() {\n+        return isObserved();\n+    }\n+\n+    \/**\n+     * Called after a listener was added to start observing inputs, if they're not observed already.\n+     *\/\n+    private void updateSubcriptionAfterAdd() {\n+        if (!wasObserved) { \/\/ was first observer registered?\n+            subscription = observeInputs(); \/\/ start observing source\n+\n+            \/*\n+             * Although the act of registering a listener already attempts to make\n+             * this binding valid, allowValidation won't allow it as the binding is\n+             * not observed yet. This is because isObserved will not yet return true\n+             * when the process of registering the listener hasn't completed yet.\n+             *\n+             * As the binding must be valid after it becomes observed the first time\n+             * 'get' is called again.\n+             *\/\n+\n+            get(); \/\/ make binding valid as source wasn't tracked until now\n+            wasObserved = true;\n+        }\n+    }\n+\n+    \/**\n+     * Called after a listener was removed to stop observing inputs, if this was the last listener\n+     * observing this binding.\n+     *\/\n+    private void updateSubcriptionAfterRemove() {\n+        if (wasObserved && !isObserved()) { \/\/ was last observer unregistered?\n+            subscription.unsubscribe();\n+            subscription = null;\n+            invalidate(); \/\/ make binding invalid as source is no longer tracked\n+            wasObserved = false;\n+        }\n+    }\n+\n+    \/**\n+     * Called when this binding was previously not observed and a new observer was added. Implementors must return a\n+     * {@link Subscription} which will be cancelled when this binding no longer has any observers.\n+     *\n+     * @return a {@link Subscription} which will be cancelled when this binding no longer has any observers, never null\n+     *\/\n+    protected abstract Subscription observeInputs();\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/LazyObjectBinding.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.beans.value;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import com.sun.javafx.binding.Subscription;\n+\n+class MappedBinding<S, T> extends LazyObjectBinding<T> {\n+    private final ObservableValue<S> source;\n+    private final Function<? super S, ? extends T> mapper;\n+\n+    public MappedBinding(ObservableValue<S> source, Function<? super S, ? extends T> mapper) {\n+        this.source = Objects.requireNonNull(source, \"source cannot be null\");\n+        this.mapper = Objects.requireNonNull(mapper, \"mapper cannot be null\");\n+    }\n+\n+    @Override\n+    protected Subscription observeInputs() {\n+        return Subscription.subscribeInvalidations(source, this::invalidate); \/\/ start observing source\n+    }\n+\n+    @Override\n+    protected T computeValue() {\n+        S value = source.getValue();\n+\n+        return value == null ? null : mapper.apply(value);\n+    }\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/MappedBinding.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.util.function.Function;\n+\n@@ -140,0 +142,51 @@\n+\n+    \/**\n+     * Returns an {@link ObservableValue} which provides a mapping of the value\n+     * held by this {@code ObservableValue}, and provides {@code null} when this\n+     * {@code ObservableValue} holds {@code null}.\n+     *\n+     * @param <U> the type of values held by the resulting {@code ObservableValue}\n+     * @param mapper a {@link Function} which converts a given value to a new value, cannot be null\n+     * @return an {@link ObservableValue} which provides a mapping of the value\n+     *     held by this {@code ObservableValue}, and provides {@code null} when\n+     *     this {@code ObservableValue} holds {@code null}, never null\n+     *\/\n+    default <U> ObservableValue<U> map(Function<? super T, ? extends U> mapper) {\n+        return new MappedBinding<>(this, mapper);\n+    }\n+\n+    \/**\n+     * Returns an {@link ObservableValue} which provides a mapping of the value\n+     * held by this {@code ObservableValue}, or {@code constant} when this\n+     * {@code ObservableValue} holds {@code null}.\n+     *\n+     * @param constant an alternative value to use when this {@code ObservableValue}\n+     *     holds {@code null}, can be null\n+     * @return an {@link ObservableValue} which provides a mapping of the value\n+     *     held by this {@code ObservableValue}, or {@code constant} when this\n+     *     {@code ObservableValue} holds {@code null}, never null\n+     *\/\n+    default ObservableValue<T> orElse(T constant) {\n+        return new OrElseBinding<>(this, constant);\n+    }\n+\n+    \/**\n+     * Returns an {@link ObservableValue} which provides the value in the {@code\n+     * ObservableValue} given by applying {@code mapper} on the value held by this\n+     * {@code ObservableValue}, and is {@code null} when this\n+     * {@code ObservableValue} holds {@code null}.<p>\n+     *\n+     * Returning {@code null} from {@code mapper} will result in an\n+     * {@code ObservableValue} which holds {@code null}.\n+     *\n+     * @param <U> the type of values held by the resulting {@code ObservableValue}\n+     * @param mapper a {@link Function} which converts a given value to an\n+     *     {@code ObservableValue}, cannot be null\n+     * @return an {@link ObservableValue} which provides the value in the\n+     *     {@code ObservableValue} given by applying {@code mapper} on the value\n+     *     held by this {@code ObservableValue}, and is {@code null} when this\n+     *     {@code ObservableValue} holds {@code null}, never null\n+     *\/\n+    default <U> ObservableValue<U> flatMap(Function<? super T, ? extends ObservableValue<? extends U>> mapper) {\n+        return new FlatMappedBinding<>(this, mapper);\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/ObservableValue.java","additions":54,"deletions":1,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.beans.value;\n+\n+import java.util.Objects;\n+\n+import com.sun.javafx.binding.Subscription;\n+\n+class OrElseBinding<T> extends LazyObjectBinding<T> {\n+    private final ObservableValue<T> source;\n+    private final T constant;\n+\n+    public OrElseBinding(ObservableValue<T> source, T constant) {\n+        this.source = Objects.requireNonNull(source, \"source cannot be null\");\n+        this.constant = constant;\n+    }\n+\n+    @Override\n+    protected Subscription observeInputs() {\n+        return Subscription.subscribeInvalidations(source, this::invalidate); \/\/ start observing source\n+    }\n+\n+    @Override\n+    protected T computeValue() {\n+        T value = source.getValue();\n+\n+        return value == null ? constant : value;\n+    }\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/OrElseBinding.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.beans.value;\n+\n+import com.sun.javafx.binding.Subscription;\n+\n+\/**\n+ * Stub to allow testing of package private LazyObjectBinding.\n+ *\/\n+public class LazyObjectBindingStub<T> extends LazyObjectBinding<T> {\n+    public int computeValueCalls;\n+    public int startObservingCalls;\n+    public int stopObservingCalls;\n+\n+    @Override\n+    protected T computeValue() {\n+        computeValueCalls++;\n+\n+        return null;\n+    }\n+\n+    @Override\n+    protected Subscription observeInputs() {\n+        startObservingCalls++;\n+\n+        return () -> {\n+            stopObservingCalls++;\n+        };\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/shims\/java\/javafx\/beans\/value\/LazyObjectBindingStub.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.beans.value;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.LazyObjectBindingStub;\n+\n+public class LazyObjectBindingTest {\n+    private LazyObjectBindingStub<String> binding = new LazyObjectBindingStub<>();\n+\n+    void resetCounters() {\n+        binding.startObservingCalls = 0;\n+        binding.computeValueCalls = 0;\n+        binding.stopObservingCalls = 0;\n+    }\n+\n+    @Test\n+    void shouldBeInvalidInitially() {\n+        assertFalse(binding.isValid());\n+    }\n+\n+    @Nested\n+    class WhenObservedWithInvalidationListener {\n+        private InvalidationListener invalidationListener = obs -> {};\n+\n+        {\n+            binding.addListener(invalidationListener);\n+        }\n+\n+        @Test\n+        void shouldBeValid() {\n+            assertTrue(binding.isValid());\n+        }\n+\n+        @Test\n+        void shouldStartObservingSource() {\n+            assertEquals(1, binding.startObservingCalls);\n+        }\n+\n+        @Test\n+        void shouldNotStopObservingSource() {\n+            assertEquals(0, binding.stopObservingCalls);\n+        }\n+\n+        @Test\n+        void shouldCallComputeValueOneOrTwoTimes() {\n+\n+            \/*\n+             * The binding is made valid twice currently, once when\n+             * the listener is registered, and again after the observing of\n+             * inputs starts. The first time the binding does not become\n+             * valid because it is not yet considered \"observed\" as the\n+             * computeValue call occurs in the middle of the listener\n+             * registration process.\n+             *\/\n+\n+            assertTrue(binding.computeValueCalls >= 1 && binding.computeValueCalls <= 2);\n+        }\n+\n+        @Nested\n+        class AndWhenObservedAgain {\n+            private ChangeListener<String> changeListener = (obs, old, current) -> {};\n+\n+            {\n+                resetCounters();\n+                binding.addListener(changeListener);\n+            }\n+\n+            @Test\n+            void shouldStillBeValid() {\n+                assertTrue(binding.isValid());\n+            }\n+\n+            @Test\n+            void shouldNotStartObservingSourceAgain() {\n+                assertEquals(0, binding.startObservingCalls);\n+            }\n+\n+            @Test\n+            void shouldNotStopObservingSource() {\n+                assertEquals(0, binding.stopObservingCalls);\n+            }\n+\n+            @Test\n+            void shouldNotComputeValueAgain() {\n+                assertEquals(0, binding.computeValueCalls);\n+            }\n+\n+            @Nested\n+            class AndThenOneObserverIsRemoved {\n+                {\n+                    resetCounters();\n+                    binding.removeListener(changeListener);\n+                }\n+\n+                @Test\n+                void shouldStillBeValid() {\n+                    assertTrue(binding.isValid());\n+                }\n+\n+                @Test\n+                void shouldNotStartObservingSourceAgain() {\n+                    assertEquals(0, binding.startObservingCalls);\n+                }\n+\n+                @Test\n+                void shouldNotStopObservingSource() {\n+                    assertEquals(0, binding.stopObservingCalls);\n+                }\n+\n+                @Test\n+                void shouldNotComputeValueAgain() {\n+                    assertEquals(0, binding.computeValueCalls);\n+                }\n+\n+                @Nested\n+                class AndThenTheLastObserverIsRemoved {\n+                    {\n+                        resetCounters();\n+                        binding.removeListener(invalidationListener);\n+                    }\n+\n+                    @Test\n+                    void shouldNotStartObservingSource() {\n+                        assertEquals(0, binding.startObservingCalls);\n+                    }\n+\n+                    @Test\n+                    void shouldStopObservingSource() {\n+                        assertEquals(1, binding.stopObservingCalls);\n+                    }\n+\n+                    @Test\n+                    void shouldNotComputeValue() {\n+                        assertEquals(0, binding.computeValueCalls);\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeValid() {\n+                        assertFalse(binding.isValid());\n+                    }\n+\n+                    @Nested\n+                    class AndTheListenerIsRemovedAgain {\n+                        {\n+                            resetCounters();\n+                            binding.removeListener(invalidationListener);\n+                        }\n+\n+                        @Test\n+                        void shouldNotStartObservingSource() {\n+                            assertEquals(0, binding.startObservingCalls);\n+                        }\n+\n+                        @Test\n+                        void shouldNotStopObservingSource() {\n+                            assertEquals(0, binding.stopObservingCalls);\n+                        }\n+\n+                        @Test\n+                        void shouldNotComputeValue() {\n+                            assertEquals(0, binding.computeValueCalls);\n+                        }\n+\n+                        @Test\n+                        void shouldNotBeValid() {\n+                            assertFalse(binding.isValid());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/LazyObjectBindingTest.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,368 @@\n+package test.javafx.beans.value;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.beans.property.StringProperty;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+\n+public class ObservableValueFluentBindingsTest {\n+    private StringProperty property = new SimpleStringProperty(\"A\");\n+\n+    @Nested\n+    class When_map_Called {\n+        @Nested\n+        class WithNull {\n+            @Test\n+            void shouldThrowNullPointerException() {\n+                assertThrows(NullPointerException.class, () -> property.map(null));\n+            }\n+        }\n+\n+        @Nested\n+        class WithNotNullReturns_ObservableValue_Which {\n+            private ObservableValue<String> observableValue = property.map(v -> v + \"Z\");\n+\n+            @Test\n+            void shouldNotBeNull() {\n+                assertNotNull(observableValue);\n+            }\n+\n+            @Test\n+            void shouldNotBeStronglyReferenced() {\n+                ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+            }\n+\n+            @Nested\n+            class When_getValue_Called {\n+                @Test\n+                void shouldReturnPropertyValuesWithOperationApplied() {\n+                    assertEquals(\"AZ\", observableValue.getValue());\n+\n+                    property.set(\"B\");\n+\n+                    assertEquals(\"BZ\", observableValue.getValue());\n+                }\n+\n+                @Test\n+                void shouldNotOperateOnNull() {\n+                    property.set(null);\n+\n+                    assertNull(observableValue.getValue());\n+                }\n+            }\n+\n+            @Nested\n+            class WhenObserved {\n+                private List<String> values = new ArrayList<>();\n+                private ChangeListener<String> changeListener = (obs, old, current) -> values.add(current);\n+\n+                {\n+                    observableValue.addListener(changeListener);\n+                }\n+\n+                @Test\n+                void shouldApplyOperation() {\n+                    assertTrue(values.isEmpty());\n+\n+                    property.set(\"C\");\n+\n+                    assertEquals(List.of(\"CZ\"), values);\n+                }\n+\n+                @Test\n+                void shouldNotOperateOnNull() {\n+                    property.set(null);\n+\n+                    assertEquals(Arrays.asList((String) null), values);\n+                }\n+\n+                @Test\n+                void shouldBeStronglyReferenced() {\n+                    ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> observableValue = null);\n+                }\n+\n+                @Nested\n+                class AndWhenUnobserved {\n+                    {\n+                        property.setValue(\"B\");\n+                        property.setValue(\"A\");\n+\n+                        assertEquals(List.of(\"BZ\", \"AZ\"), values);\n+\n+                        values.clear();\n+\n+                        observableValue.removeListener(changeListener);\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeCalled() {\n+                        assertTrue(values.isEmpty());\n+\n+                        property.set(\"C\");\n+\n+                        assertTrue(values.isEmpty());\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeStronglyReferenced() {\n+                        ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Nested\n+    class When_orElse_CalledReturns_ObservableValue_Which {\n+        private ObservableValue<String> observableValue = property.orElse(\"null\");\n+\n+        @Test\n+        void shouldNotBeNull() {\n+            assertNotNull(observableValue);\n+        }\n+\n+        @Test\n+        void shouldNotBeStronglyReferenced() {\n+            ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+        }\n+\n+        @Nested\n+        class When_getValue_Called {\n+            @Test\n+            void shouldReturnPropertyValuesWithOperationApplied() {\n+                assertEquals(\"A\", observableValue.getValue());\n+\n+                property.set(null);\n+\n+                assertEquals(\"null\", observableValue.getValue());\n+            }\n+        }\n+\n+        @Nested\n+        class WhenObserved {\n+            private List<String> values = new ArrayList<>();\n+            private ChangeListener<String> changeListener = (obs, old, current) -> values.add(current);\n+\n+            {\n+                observableValue.addListener(changeListener);\n+            }\n+\n+            @Test\n+            void shouldApplyOperation() {\n+                assertTrue(values.isEmpty());\n+\n+                property.set(\"C\");\n+\n+                assertEquals(List.of(\"C\"), values);\n+\n+                values.clear();\n+                property.set(null);\n+\n+                assertEquals(List.of(\"null\"), values);\n+            }\n+\n+            @Test\n+            void shouldBeStronglyReferenced() {\n+                ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> observableValue = null);\n+            }\n+\n+            @Nested\n+            class AndWhenUnobserved {\n+                {\n+                    property.setValue(\"B\");\n+                    property.setValue(null);\n+\n+                    assertEquals(List.of(\"B\", \"null\"), values);\n+\n+                    values.clear();\n+\n+                    observableValue.removeListener(changeListener);\n+                }\n+\n+                @Test\n+                void shouldNoLongerBeCalled() {\n+                    assertTrue(values.isEmpty());\n+\n+                    property.set(\"C\");\n+\n+                    assertTrue(values.isEmpty());\n+                }\n+\n+                @Test\n+                void shouldNoLongerBeStronglyReferenced() {\n+                    ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Nested\n+    class When_flatMap_Called {\n+        @Nested\n+        class WithNull {\n+            @Test\n+            void shouldThrowNullPointerException() {\n+                assertThrows(NullPointerException.class, () -> property.flatMap(null));\n+            }\n+        }\n+        \/\/ TODO test for when something is flatMapped to null in getValue call\n+\n+        @Nested\n+        class WithNotNullReturns_ObservableValue_Which {\n+            private ObjectProperty<Integer> altA = new SimpleObjectProperty<>(65);\n+            private ObjectProperty<Integer> altOther = new SimpleObjectProperty<>(0);\n+            private ObservableValue<Integer> observableValue = property.flatMap(v -> \"A\".equals(v) ? altA : altOther);\n+\n+            @Test\n+            void shouldNotBeNull() {\n+                assertNotNull(observableValue);\n+            }\n+\n+            @Test\n+            void shouldNotBeStronglyReferenced() {\n+                ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+            }\n+\n+            @Nested\n+            class When_getValue_Called {\n+                @Test\n+                void shouldReturnPropertyValuesWithOperationApplied() {\n+                    assertEquals((Integer) 65, observableValue.getValue());\n+\n+                    property.set(\"D\");\n+\n+                    assertEquals((Integer) 0, observableValue.getValue());\n+\n+                    altOther.setValue(1);\n+\n+                    assertEquals((Integer) 1, observableValue.getValue());\n+\n+                    altA.setValue(66);\n+\n+                    assertEquals((Integer) 1, observableValue.getValue());\n+\n+                    property.set(\"A\");\n+\n+                    assertEquals((Integer) 66, observableValue.getValue());\n+                }\n+\n+                @Test\n+                void shouldNotOperateOnNull() {\n+                    property.set(null);\n+\n+                    assertNull(observableValue.getValue());\n+                }\n+\n+                @Test\n+                void shouldIgnoreFlatMapsToNull() {\n+                    altA = null;\n+\n+                    assertNull(observableValue.getValue());\n+                }\n+            }\n+\n+            @Nested\n+            class WhenObserved {\n+                private List<Integer> values = new ArrayList<>();\n+                private ChangeListener<Integer> changeListener = (obs, old, current) -> values.add(current);\n+\n+                {\n+                    observableValue.addListener(changeListener);\n+                }\n+\n+                @Test\n+                void shouldApplyOperation() {\n+                    assertTrue(values.isEmpty());\n+\n+                    altA.set(66);\n+\n+                    assertEquals(List.of(66), values);\n+\n+                    values.clear();\n+                    property.set(\"D\");\n+\n+                    assertEquals(List.of(0), values);\n+\n+                    values.clear();\n+                    altA.set(67);\n+\n+                    assertEquals(List.of(), values);\n+\n+                    values.clear();\n+                    altOther.set(1);\n+\n+                    assertEquals(List.of(1), values);\n+\n+                    values.clear();\n+                    property.set(\"A\");\n+\n+                    assertEquals(List.of(67), values);\n+                }\n+\n+                @Test\n+                void shouldNotOperateOnNull() {\n+                    property.set(null);\n+\n+                    assertEquals(Arrays.asList((String) null), values);\n+                }\n+\n+                @Test\n+                void shouldIgnoreFlatMapsToNull() {\n+                    altOther = null;\n+\n+                    property.set(\"D\");\n+\n+                    assertEquals(Arrays.asList((String) null), values);\n+                }\n+\n+                @Test\n+                void shouldBeStronglyReferenced() {\n+                    ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> observableValue = null);\n+                }\n+\n+                @Nested\n+                class AndWhenUnobserved {\n+                    {\n+                        property.setValue(\"B\");\n+                        property.setValue(\"A\");\n+\n+                        assertEquals(List.of(0, 65), values);\n+\n+                        values.clear();\n+\n+                        observableValue.removeListener(changeListener);\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeCalled() {\n+                        assertTrue(values.isEmpty());\n+\n+                        property.set(\"C\");\n+\n+                        assertTrue(values.isEmpty());\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeStronglyReferenced() {\n+                        ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/ObservableValueFluentBindingsTest.java","additions":368,"deletions":0,"binary":false,"changes":368,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+package test.javafx.beans.value;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+\n+import java.lang.ref.WeakReference;\n+\n+public class ReferenceAsserts {\n+\n+    public static void testIfStronglyReferenced(Object obj, Runnable clearRefs) {\n+        WeakReference<Object> ref = new WeakReference<>(obj);\n+\n+        clearRefs.run();\n+        obj = null;\n+\n+        System.gc();\n+\n+        assertNotNull(ref.get());\n+    }\n+\n+    public static void testIfNotStronglyReferenced(Object obj, Runnable clearRefs) {\n+        WeakReference<Object> ref = new WeakReference<>(obj);\n+\n+        clearRefs.run();\n+        obj = null;\n+\n+        System.gc();\n+\n+        assertNull(ref.get());\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/ReferenceAsserts.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"}]}