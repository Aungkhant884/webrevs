{"files":[{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.binding;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import javafx.beans.value.ObservableValue;\n+\n+\/**\n+ * A binding holding the value of an indirect source. The indirect source results from\n+ * applying a mapping to the given source.\n+ *\n+ * <p>Implementation:\n+ *\n+ * <p>In a flat mapped binding there are always two subscriptions involved:\n+ * <ul>\n+ * <li>The subscription on its source<\/li>\n+ * <li>The subscription on the value resulting from the mapping of the source: the indirect source<\/li>\n+ * <\/ul>\n+ * The subscription on its given source is present when this binding itself is observed and not present otherwise.\n+ *\n+ * <p>The subscription on the indirect source must change whenever the value of the given source changes or is invalidated. More\n+ * specifically, when the given source is invalidated the indirect subscription should be removed, and when it is revalidated it\n+ * should resubscribe to the newly calculated indirect source. The binding avoids resubscribing when only the value of\n+ * the indirect source changes.\n+ *\n+ * @param <S> the type of the source\n+ * @param <T> the type of the resulting binding\n+ *\/\n+public class FlatMappedBinding<S, T> extends LazyObjectBinding<T> {\n+\n+    private final ObservableValue<S> source;\n+    private final Function<? super S, ? extends ObservableValue<? extends T>> mapper;\n+\n+    private Subscription indirectSourceSubscription = Subscription.EMPTY;\n+    private ObservableValue<? extends T> indirectSource;\n+\n+    public FlatMappedBinding(ObservableValue<S> source, Function<? super S, ? extends ObservableValue<? extends T>> mapper) {\n+        this.source = Objects.requireNonNull(source, \"source cannot be null\");\n+        this.mapper = Objects.requireNonNull(mapper, \"mapper cannot be null\");\n+    }\n+\n+    @Override\n+    protected T computeValue() {\n+        S value = source.getValue();\n+        ObservableValue<? extends T> newIndirectSource = value == null ? null : mapper.apply(value);\n+\n+        if (isObserved() && indirectSource != newIndirectSource) {  \/\/ only resubscribe when observed and the indirect source changed\n+            indirectSourceSubscription.unsubscribe();\n+            indirectSourceSubscription = newIndirectSource == null ? Subscription.EMPTY : Subscription.subscribeInvalidations(newIndirectSource, this::invalidate);\n+            indirectSource = newIndirectSource;\n+        }\n+\n+        return newIndirectSource == null ? null : newIndirectSource.getValue();\n+    }\n+\n+    @Override\n+    protected Subscription observeSources() {\n+        Subscription subscription = Subscription.subscribeInvalidations(source, this::invalidateAll);\n+\n+        return () -> {\n+            subscription.unsubscribe();\n+            unsubscribeIndirectSource();\n+        };\n+    }\n+\n+    \/**\n+     * Called when the primary source changes. Invalidates this binding and unsubscribes the indirect source\n+     * to avoid holding a strong reference to it. If the binding becomes valid later, {@link #computeValue()} will\n+     * subscribe to a newly calculated indirect source.\n+     *\n+     * <p>Note that this only needs to be called for changes of the primary source; changes in the indirect\n+     * source only need to invalidate this binding without also unsubscribing, as it would be wasteful to resubscribe\n+     * to the same indirect source for each invalidation of that source.\n+     *\/\n+    private void invalidateAll() {\n+        unsubscribeIndirectSource();\n+        invalidate();\n+    }\n+\n+    private void unsubscribeIndirectSource() {\n+        indirectSourceSubscription.unsubscribe();\n+        indirectSourceSubscription = Subscription.EMPTY;\n+        indirectSource = null;\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/FlatMappedBinding.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -26,3 +26,1 @@\n-package javafx.beans.value;\n-\n-import com.sun.javafx.binding.Subscription;\n+package com.sun.javafx.binding;\n@@ -32,0 +30,1 @@\n+import javafx.beans.value.ChangeListener;\n@@ -48,1 +47,1 @@\n-        updateSubcriptionAfterAdd();\n+        updateSubscriptionAfterAdd();\n@@ -55,1 +54,1 @@\n-        updateSubcriptionAfterRemove();\n+        updateSubscriptionAfterRemove();\n@@ -62,1 +61,1 @@\n-        updateSubcriptionAfterAdd();\n+        updateSubscriptionAfterAdd();\n@@ -69,1 +68,1 @@\n-        updateSubcriptionAfterRemove();\n+        updateSubscriptionAfterRemove();\n@@ -80,1 +79,1 @@\n-    private void updateSubcriptionAfterAdd() {\n+    private void updateSubscriptionAfterAdd() {\n@@ -82,1 +81,1 @@\n-            subscription = observeInputs(); \/\/ start observing source\n+            subscription = observeSources(); \/\/ start observing source\n@@ -111,1 +110,1 @@\n-    private void updateSubcriptionAfterRemove() {\n+    private void updateSubscriptionAfterRemove() {\n@@ -126,1 +125,1 @@\n-    protected abstract Subscription observeInputs();\n+    protected abstract Subscription observeSources();\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/LazyObjectBinding.java","additions":10,"deletions":11,"binary":false,"changes":21,"previous_filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/LazyObjectBinding.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package javafx.beans.value;\n+package com.sun.javafx.binding;\n@@ -31,1 +31,1 @@\n-import com.sun.javafx.binding.Subscription;\n+import javafx.beans.value.ObservableValue;\n@@ -33,1 +33,1 @@\n-class MappedBinding<S, T> extends LazyObjectBinding<T> {\n+public class MappedBinding<S, T> extends LazyObjectBinding<T> {\n@@ -51,1 +51,1 @@\n-    protected Subscription observeInputs() {\n+    protected Subscription observeSources() {\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/MappedBinding.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/MappedBinding.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package javafx.beans.value;\n+package com.sun.javafx.binding;\n@@ -30,1 +30,1 @@\n-import com.sun.javafx.binding.Subscription;\n+import javafx.beans.value.ObservableValue;\n@@ -32,1 +32,1 @@\n-class OrElseBinding<T> extends LazyObjectBinding<T> {\n+public class OrElseBinding<T> extends LazyObjectBinding<T> {\n@@ -50,1 +50,1 @@\n-    protected Subscription observeInputs() {\n+    protected Subscription observeSources() {\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/OrElseBinding.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/OrElseBinding.java","status":"renamed"},{"patch":"@@ -440,0 +440,4 @@\n+     * <p>\n+     * Since 19, it is recommended to use {@link ObservableValue#flatMap(java.util.function.Function)}\n+     * to select a nested member of an {@link ObservableValue}.\n+     * <\/p>\n@@ -447,0 +451,1 @@\n+     * @see ObservableValue#flatMap(java.util.function.Function)\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/binding\/Bindings.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2021 Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javafx.beans.value;\n-\n-import java.util.Objects;\n-import java.util.function.Function;\n-\n-import com.sun.javafx.binding.Subscription;\n-\n-class FlatMappedBinding<S, T> extends LazyObjectBinding<T> {\n-\n-    private final ObservableValue<S> source;\n-    private final Function<? super S, ? extends ObservableValue<? extends T>> mapper;\n-\n-    private Subscription mappedSubscription = Subscription.EMPTY;\n-\n-    public FlatMappedBinding(ObservableValue<S> source, Function<? super S, ? extends ObservableValue<? extends T>> mapper) {\n-        this.source = Objects.requireNonNull(source, \"source cannot be null\");\n-        this.mapper = Objects.requireNonNull(mapper, \"mapper cannot be null\");\n-    }\n-\n-    @Override\n-    protected T computeValue() {\n-        S value = source.getValue();\n-        ObservableValue<? extends T> mapped = value == null ? null : mapper.apply(value);\n-\n-        if (isObserved()) {\n-            mappedSubscription.unsubscribe();\n-            mappedSubscription = mapped == null ? Subscription.EMPTY : Subscription.subscribeInvalidations(mapped, this::invalidate);\n-        }\n-\n-        return mapped == null ? null : mapped.getValue();\n-    }\n-\n-    @Override\n-    protected Subscription observeInputs() {\n-        Subscription subscription = Subscription.subscribeInvalidations(source, this::invalidate);\n-\n-        return () -> {\n-            subscription.unsubscribe();\n-            mappedSubscription.unsubscribe();\n-            mappedSubscription = Subscription.EMPTY;\n-        };\n-    }\n-}\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/FlatMappedBinding.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"},{"patch":"@@ -30,0 +30,4 @@\n+import com.sun.javafx.binding.FlatMappedBinding;\n+import com.sun.javafx.binding.MappedBinding;\n+import com.sun.javafx.binding.OrElseBinding;\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/ObservableValue.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,3 +26,1 @@\n-package javafx.beans.value;\n-\n-import com.sun.javafx.binding.Subscription;\n+package com.sun.javafx.binding;\n@@ -47,1 +45,1 @@\n-    protected Subscription observeInputs() {\n+    protected Subscription observeSources() {\n","filename":"modules\/javafx.base\/src\/shims\/java\/com\/sun\/javafx\/binding\/LazyObjectBindingStub.java","additions":2,"deletions":4,"binary":false,"changes":6,"previous_filename":"modules\/javafx.base\/src\/shims\/java\/javafx\/beans\/value\/LazyObjectBindingStub.java","status":"renamed"},{"patch":"@@ -35,0 +35,2 @@\n+import com.sun.javafx.binding.LazyObjectBindingStub;\n+\n@@ -37,1 +39,0 @@\n-import javafx.beans.value.LazyObjectBindingStub;\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/LazyObjectBindingTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import javafx.beans.InvalidationListener;\n@@ -47,0 +48,1 @@\n+    private int invalidations;\n@@ -51,0 +53,1 @@\n+    private final InvalidationListener invalidationListener = obs -> invalidations++;\n@@ -99,1 +102,1 @@\n-            class WhenObserved {\n+            class WhenObservedForInvalidations {\n@@ -101,1 +104,48 @@\n-                    startObserving(observableValue);\n+                    startObservingInvalidations(observableValue);\n+                }\n+\n+                @Test\n+                void shouldOnlyInvalidateOnce() {\n+                    assertNotInvalidated();\n+\n+                    property.set(\"Left\");\n+\n+                    assertInvalidated();\n+\n+                    property.set(\"Right\");\n+\n+                    assertNotInvalidated();\n+                }\n+\n+                @Test\n+                void shouldBeStronglyReferenced() {\n+                    ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> observableValue = null);\n+                }\n+\n+                @Nested\n+                class AndWhenUnobserved {\n+                    {\n+                        stopObservingInvalidations(observableValue);\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeCalled() {\n+                        assertNotInvalidated();\n+\n+                        property.set(\"Left\");\n+                        property.set(\"Right\");\n+\n+                        assertNotInvalidated();\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeStronglyReferenced() {\n+                        ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+                    }\n+                }\n+            }\n+\n+            @Nested\n+            class WhenObservedForChanges {\n+                {\n+                    startObservingChanges(observableValue);\n@@ -128,1 +178,1 @@\n-                        stopObserving(observableValue);\n+                        stopObservingChanges(observableValue);\n@@ -164,1 +214,1 @@\n-                class WhenObserved {\n+                class WhenObservedForChanges {\n@@ -166,1 +216,1 @@\n-                        startObserving(observableValue);\n+                        startObservingChanges(observableValue);\n@@ -190,1 +240,1 @@\n-                            stopObserving(observableValue);\n+                            stopObservingChanges(observableValue);\n@@ -227,1 +277,1 @@\n-                class WhenObserved {\n+                class WhenObservedForChanges {\n@@ -229,1 +279,1 @@\n-                        startObserving(observableValue);\n+                        startObservingChanges(observableValue);\n@@ -253,1 +303,1 @@\n-                            stopObserving(observableValue);\n+                            stopObservingChanges(observableValue);\n@@ -303,1 +353,1 @@\n-        class WhenObserved {\n+        class WhenObservedForInvalidations {\n@@ -305,1 +355,48 @@\n-                startObserving(observableValue);\n+                startObservingInvalidations(observableValue);\n+            }\n+\n+            @Test\n+            void shouldOnlyInvalidateOnce() {\n+                assertNotInvalidated();\n+\n+                property.set(\"Left\");\n+\n+                assertInvalidated();\n+\n+                property.set(null);\n+\n+                assertNotInvalidated();\n+            }\n+\n+            @Test\n+            void shouldBeStronglyReferenced() {\n+                ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> observableValue = null);\n+            }\n+\n+            @Nested\n+            class AndWhenUnobserved {\n+                {\n+                    stopObservingInvalidations(observableValue);\n+                }\n+\n+                @Test\n+                void shouldNoLongerBeCalled() {\n+                    assertNotInvalidated();\n+\n+                    property.set(\"Left\");\n+                    property.set(null);\n+\n+                    assertNotInvalidated();\n+                }\n+\n+                @Test\n+                void shouldNoLongerBeStronglyReferenced() {\n+                    ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+                }\n+            }\n+        }\n+\n+        @Nested\n+        class WhenObservedForChanges {\n+            {\n+                startObservingChanges(observableValue);\n@@ -329,1 +426,1 @@\n-                    stopObserving(observableValue);\n+                    stopObservingChanges(observableValue);\n@@ -363,0 +460,3 @@\n+            private int subscribeCount;\n+            private int unsubscribeCount;\n+\n@@ -365,1 +465,16 @@\n-            private StringProperty unknown = new SimpleStringProperty(\"UNKNOWN\");\n+            private StringProperty unknown = new SimpleStringProperty(\"UNKNOWN\") {\n+                @Override\n+                public void addListener(InvalidationListener listener) {\n+                    super.addListener(listener);\n+\n+                    subscribeCount++;\n+                };\n+\n+                @Override\n+                public void removeListener(InvalidationListener listener) {\n+                    super.removeListener(listener);\n+\n+                    unsubscribeCount++;\n+                };\n+            };\n+\n@@ -420,1 +535,78 @@\n-            class WhenObserved {\n+            class WhenObservedForInvalidations {\n+                {\n+                    startObservingInvalidations(observableValue);\n+                }\n+\n+                @Test\n+                void shouldOnlyInvalidateOnce() {\n+                    assertNotInvalidated();\n+\n+                    unknown.set(\"UNKNOWN+1\");\n+\n+                    assertInvalidated();\n+\n+                    property.set(\"Right\");\n+\n+                    assertNotInvalidated();\n+                }\n+\n+                @Test\n+                void shouldNotResubscribeToMappedPropertyOnEachValidation() {\n+                    assertEquals(1, subscribeCount);\n+                    assertEquals(0, unsubscribeCount);\n+\n+                    unknown.set(\"A\");\n+                    observableValue.getValue();\n+                    unknown.set(\"B\");\n+                    observableValue.getValue();\n+                    unknown.set(\"C\");\n+                    observableValue.getValue();\n+\n+                    assertEquals(1, subscribeCount);\n+                    assertEquals(0, unsubscribeCount);\n+                }\n+\n+                @Test\n+                void shouldBeStronglyReferenced() {\n+                    ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> observableValue = null);\n+                }\n+\n+                @Test\n+                void shouldStronglyReferMappedProperty() {\n+                    ReferenceAsserts.testIfStronglyReferenced(unknown, () -> unknown = null);\n+                }\n+\n+                @Test\n+                void shouldNotStronglyReferOldMappedProperty() {\n+                    property.set(\"Right\");\n+\n+                    ReferenceAsserts.testIfNotStronglyReferenced(unknown, () -> unknown = null);\n+                }\n+\n+                @Nested\n+                class AndWhenUnobserved {\n+                    {\n+                        stopObservingInvalidations(observableValue);\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeCalled() {\n+                        assertNotInvalidated();\n+\n+                        property.set(\"Left\");\n+                        property.set(\"Right\");\n+                        property.set(\"Unknown\");\n+\n+                        assertNotInvalidated();\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeStronglyReferenced() {\n+                        ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+                        ReferenceAsserts.testIfNotStronglyReferenced(unknown, () -> unknown = null);\n+                    }\n+                }\n+            }\n+\n+            @Nested\n+            class WhenObservedForChanges {\n@@ -422,1 +614,1 @@\n-                    startObserving(observableValue);\n+                    startObservingChanges(observableValue);\n@@ -451,0 +643,13 @@\n+                @Test\n+                void shouldNotResubscribeToMappedPropertyOnEachValidation() {\n+                    assertEquals(1, subscribeCount);\n+                    assertEquals(0, unsubscribeCount);\n+\n+                    unknown.set(\"A\");\n+                    unknown.set(\"B\");\n+                    unknown.set(\"C\");\n+\n+                    assertEquals(1, subscribeCount);\n+                    assertEquals(0, unsubscribeCount);\n+                }\n+\n@@ -483,0 +688,12 @@\n+                @Test\n+                void shouldStronglyReferMappedProperty() {\n+                    ReferenceAsserts.testIfStronglyReferenced(unknown, () -> unknown = null);\n+                }\n+\n+                @Test\n+                void shouldNotStronglyReferOldMappedProperty() {\n+                    property.set(\"Right\");\n+\n+                    ReferenceAsserts.testIfNotStronglyReferenced(unknown, () -> unknown = null);\n+                }\n+\n@@ -486,1 +703,1 @@\n-                        stopObserving(observableValue);\n+                        stopObservingChanges(observableValue);\n@@ -503,0 +720,1 @@\n+                        ReferenceAsserts.testIfNotStronglyReferenced(unknown, () -> unknown = null);\n@@ -524,1 +742,1 @@\n-                class WhenObserved {\n+                class WhenObservedForChanges {\n@@ -526,1 +744,1 @@\n-                        startObserving(observableValue);\n+                        startObservingChanges(observableValue);\n@@ -558,1 +776,1 @@\n-                            stopObserving(observableValue);\n+                            stopObservingChanges(observableValue);\n@@ -595,1 +813,1 @@\n-                class WhenObserved {\n+                class WhenObservedForChanges {\n@@ -597,1 +815,1 @@\n-                        startObserving(observableValue);\n+                        startObservingChanges(observableValue);\n@@ -641,1 +859,1 @@\n-                            stopObserving(observableValue);\n+                            stopObservingChanges(observableValue);\n@@ -681,3 +899,2 @@\n-     * Starts observing the given observable value. This will do\n-     * a sanity check that the observer is currently not working\n-     * before adding it.\n+     * Starts observing the given observable value for changes. This will do\n+     * a sanity check that the observer is currently not working before adding it.\n@@ -687,1 +904,1 @@\n-    private void startObserving(ObservableValue<String> observableValue) {\n+    private void startObservingChanges(ObservableValue<String> observableValue) {\n@@ -700,3 +917,2 @@\n-     * Stops observing the given observable value. This will do a\n-     * sanity check that the observer is currently working before\n-     * removing it.\n+     * Stops observing the given observable value for changes. This will do a\n+     * sanity check that the observer is currently working before removing it.\n@@ -706,1 +922,1 @@\n-    private void stopObserving(ObservableValue<String> observableValue) {\n+    private void stopObservingChanges(ObservableValue<String> observableValue) {\n@@ -718,0 +934,53 @@\n+\n+    \/**\n+     * Ensures no invalidations occurred since the last check.\n+     *\/\n+    private void assertNotInvalidated() {\n+        assertEquals(0, invalidations);\n+    }\n+\n+    \/**\n+     * Ensures that an invalidation occurred since last check.\n+     *\/\n+    private void assertInvalidated() {\n+        assertEquals(1, invalidations);\n+        invalidations = 0;\n+    }\n+\n+    \/**\n+     * Starts observing the given observable value for invalidations. This will do\n+     * a sanity check that the observer is currently not working before adding it.\n+     *\n+     * @param observableValue an {@code ObservableValue}, cannot be {@code null}\n+     *\/\n+    private void startObservingInvalidations(ObservableValue<String> observableValue) {\n+        invalidations = 0;\n+\n+        property.getValue();\n+        property.setValue(\"Left\");\n+        property.setValue(\"Right\");\n+        property.setValue(\"Initial\");\n+\n+        assertNotInvalidated();\n+\n+        observableValue.addListener(invalidationListener);\n+    }\n+\n+    \/**\n+     * Stops observing the given observable value for invalidations. This will do a\n+     * sanity check that the observer is currently working before removing it.\n+     *\n+     * @param observableValue an {@code ObservableValue}, cannot be {@code null}\n+     *\/\n+    private void stopObservingInvalidations(ObservableValue<String> observableValue) {\n+        invalidations = 0;\n+\n+        property.getValue();\n+        property.setValue(\"Left\");\n+        property.setValue(\"Right\");\n+        property.setValue(\"Initial\");\n+\n+        assertInvalidated();\n+\n+        observableValue.removeListener(invalidationListener);\n+    }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/ObservableValueFluentBindingsTest.java","additions":299,"deletions":30,"binary":false,"changes":329,"status":"modified"}]}