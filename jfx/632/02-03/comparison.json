{"files":[{"patch":"@@ -35,2 +35,0 @@\n-import javafx.beans.InvalidationListener;\n-import javafx.beans.Observable;\n@@ -50,1 +48,0 @@\n-import javafx.scene.layout.Region;\n@@ -104,0 +101,28 @@\n+        setupTreeTableViewListeners();\n+    }\n+\n+    \/\/ FIXME: replace listener to fixedCellSize with direct lookup - JDK-8277000\n+    private void setupTreeTableViewListeners() {\n+        TableView<T> tableView = getSkinnable().getTableView();\n+        if (tableView == null) {\n+            registerInvalidationListener(getSkinnable().tableViewProperty(), e -> {\n+                unregisterInvalidationListeners(getSkinnable().tableViewProperty());\n+                setupTreeTableViewListeners();\n+            });\n+        } else {\n+            DoubleProperty fixedCellSizeProperty = tableView.fixedCellSizeProperty();\n+            if (fixedCellSizeProperty != null) {\n+                registerChangeListener(fixedCellSizeProperty, e -> {\n+                    fixedCellSize = fixedCellSizeProperty.get();\n+                    fixedCellSizeEnabled = fixedCellSize > 0;\n+                });\n+                fixedCellSize = fixedCellSizeProperty.get();\n+                fixedCellSizeEnabled = fixedCellSize > 0;\n+\n+                \/\/ JDK-8144500:\n+                \/\/ When in fixed cell size mode, we must listen to the width of the virtual flow, so\n+                \/\/ that when it changes, we can appropriately add \/ remove cells that may or may not\n+                \/\/ be required (because we remove all cells that are not visible).\n+                registerChangeListener(getVirtualFlow().widthProperty(), e -> tableView.requestLayout());\n+            }\n+        }\n@@ -175,5 +200,0 @@\n-    @Override\n-    double getFixedCellSize() {\n-        return getTableView() != null ? getTableView().getFixedCellSize() : Region.USE_COMPUTED_SIZE ;\n-    }\n-\n@@ -216,5 +236,0 @@\n-            \/\/ JDK-8144500:\n-            \/\/ When in fixed cell size mode, we must listen to the width of the virtual flow, so\n-            \/\/ that when it changes, we can appropriately add \/ remove cells that may or may not\n-            \/\/ be required (because we remove all cells that are not visible).\n-            registerChangeListener(getVirtualFlow().widthProperty(), e -> tableView.requestLayout());\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableRowSkin.java","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import javafx.beans.property.DoubleProperty;\n@@ -37,1 +36,0 @@\n-import javafx.collections.ListChangeListener;\n@@ -39,1 +37,0 @@\n-import javafx.collections.WeakListChangeListener;\n@@ -107,1 +104,0 @@\n-\n@@ -136,0 +132,4 @@\n+    \/\/ FIXME: replace cached values with direct lookup - JDK-8277000\n+    double fixedCellSize;\n+    boolean fixedCellSizeEnabled;\n+\n@@ -338,1 +338,1 @@\n-            if (isFixedCellSizeEnabled()) {\n+            if (fixedCellSizeEnabled) {\n@@ -350,1 +350,1 @@\n-                height = getFixedCellSize();\n+                height = fixedCellSize;\n@@ -357,1 +357,1 @@\n-                if (isFixedCellSizeEnabled() && tableCell.getParent() == null) {\n+                if (fixedCellSizeEnabled && tableCell.getParent() == null) {\n@@ -436,1 +436,1 @@\n-                if (isFixedCellSizeEnabled()) {\n+                if (fixedCellSizeEnabled) {\n@@ -535,1 +535,1 @@\n-        if (isFixedCellSizeEnabled()) {\n+        if (fixedCellSizeEnabled) {\n@@ -574,2 +574,2 @@\n-        if (isFixedCellSizeEnabled()) {\n-            return getFixedCellSize();\n+        if (fixedCellSizeEnabled) {\n+            return fixedCellSize;\n@@ -604,2 +604,2 @@\n-        if (isFixedCellSizeEnabled()) {\n-            return getFixedCellSize();\n+        if (fixedCellSizeEnabled) {\n+            return fixedCellSize;\n@@ -632,2 +632,2 @@\n-        if (isFixedCellSizeEnabled()) {\n-            return getFixedCellSize();\n+        if (fixedCellSizeEnabled) {\n+            return fixedCellSize;\n@@ -638,12 +638,0 @@\n-    \/**\n-     * Returns the fixedCellSize of the row's control.\n-     *\/\n-    abstract double getFixedCellSize();\n-\n-    \/**\n-     * Returns true if fixedCellSize is greater than 0, false otherwise.\n-     *\/\n-    boolean isFixedCellSizeEnabled() {\n-        return getFixedCellSize() > 0;\n-    }\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableRowSkinBase.java","additions":15,"deletions":27,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-import javafx.scene.layout.Region;\n@@ -118,0 +117,36 @@\n+        setupTreeTableViewListeners();\n+    }\n+\n+    \/\/ FIXME: replace listener to fixedCellSize with direct lookup - JDK-8277000\n+    private void setupTreeTableViewListeners() {\n+        TreeTableView<T> treeTableView = getSkinnable().getTreeTableView();\n+        if (treeTableView == null) {\n+            registerInvalidationListener(getSkinnable().treeTableViewProperty(), e -> {\n+                unregisterInvalidationListeners(getSkinnable().treeTableViewProperty());\n+                setupTreeTableViewListeners();\n+            });\n+        } else {\n+            registerChangeListener(treeTableView.treeColumnProperty(), e -> {\n+                \/\/ Fix for RT-27782: Need to set isDirty to true, rather than the\n+                \/\/ cheaper updateCells, as otherwise the text indentation will not\n+                \/\/ be recalculated in TreeTableCellSkin.leftLabelPadding()\n+                isDirty = true;\n+                getSkinnable().requestLayout();\n+            });\n+\n+            DoubleProperty fixedCellSizeProperty = getTreeTableView().fixedCellSizeProperty();\n+            if (fixedCellSizeProperty != null) {\n+                registerChangeListener(fixedCellSizeProperty, e -> {\n+                    fixedCellSize = fixedCellSizeProperty.get();\n+                    fixedCellSizeEnabled = fixedCellSize > 0;\n+                });\n+                fixedCellSize = fixedCellSizeProperty.get();\n+                fixedCellSizeEnabled = fixedCellSize > 0;\n+\n+                \/\/ JDK-8144500:\n+                \/\/ When in fixed cell size mode, we must listen to the width of the virtual flow, so\n+                \/\/ that when it changes, we can appropriately add \/ remove cells that may or may not\n+                \/\/ be required (because we remove all cells that are not visible).\n+                registerChangeListener(getVirtualFlow().widthProperty(), e -> treeTableView.requestLayout());\n+            }\n+        }\n@@ -222,5 +257,0 @@\n-    @Override\n-    double getFixedCellSize() {\n-        return getTreeTableView() != null ? getTreeTableView().getFixedCellSize() : Region.USE_COMPUTED_SIZE ;\n-    }\n-\n@@ -358,9 +388,0 @@\n-        if (tableView != null) {\n-            registerChangeListener(tableView.treeColumnProperty(), e -> {\n-                \/\/ Fix for RT-27782: Need to set isDirty to true, rather than the\n-                \/\/ cheaper updateCells, as otherwise the text indentation will not\n-                \/\/ be recalculated in TreeTableCellSkin.leftLabelPadding()\n-                isDirty = true;\n-                getSkinnable().requestLayout();\n-            });\n-        }\n@@ -369,5 +390,0 @@\n-            \/\/ JDK-8144500:\n-            \/\/ When in fixed cell size mode, we must listen to the width of the virtual flow, so\n-            \/\/ that when it changes, we can appropriately add \/ remove cells that may or may not\n-            \/\/ be required (because we remove all cells that are not visible).\n-            registerChangeListener(getVirtualFlow().widthProperty(), e -> tableView.requestLayout());\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TreeTableRowSkin.java","additions":36,"deletions":20,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import javafx.beans.Observable;\n@@ -32,0 +33,1 @@\n+import javafx.collections.ListChangeListener.Change;\n@@ -41,1 +43,1 @@\n-\/\/--------------- statics --------------\n+    \/\/--------------- statics --------------\n@@ -43,1 +45,1 @@\n-    public static List<Node> getChildren(SkinBase skin) {\n+    public static List<Node> getChildren(SkinBase<?> skin) {\n@@ -49,1 +51,1 @@\n-    public static Consumer<ObservableValue<?>> unregisterChangeListeners(SkinBase skin, ObservableValue<?> ov) {\n+    public static Consumer<ObservableValue<?>> unregisterChangeListeners(SkinBase<?> skin, ObservableValue<?> ov) {\n@@ -53,2 +55,2 @@\n-    public static Consumer<ObservableValue<?>> unregisterInvalidationListeners(SkinBase skin, ObservableValue<?> ov) {\n-        return skin.unregisterChangeListeners(ov);\n+    public static Consumer<Observable> unregisterInvalidationListeners(SkinBase<?> skin, Observable ov) {\n+        return skin.unregisterInvalidationListeners(ov);\n@@ -57,1 +59,1 @@\n-    public static Consumer<ObservableList<?>> unregisterListChangeListeners(SkinBase skin, ObservableList<?> ov) {\n+    public static Consumer<Change<?>> unregisterListChangeListeners(SkinBase<?> skin, ObservableList<?> ov) {\n","filename":"modules\/javafx.controls\/src\/shims\/java\/javafx\/scene\/control\/SkinBaseShim.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import javafx.scene.control.TableCell;\n@@ -122,1 +121,1 @@\n-        return skin.isFixedCellSizeEnabled();\n+        return skin.fixedCellSizeEnabled;\n@@ -127,1 +126,1 @@\n-        return skin.isFixedCellSizeEnabled();\n+        return skin.fixedCellSizeEnabled;\n","filename":"modules\/javafx.controls\/src\/shims\/java\/javafx\/scene\/control\/skin\/TableSkinShim.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,0 +49,3 @@\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n@@ -64,0 +67,1 @@\n+import javafx.scene.control.TableColumnBase;\n@@ -88,0 +92,1 @@\n+import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;\n@@ -101,0 +106,43 @@\n+    \/**\n+     * Test access to fixedCellSize via lookup (not listener)\n+     *\/\n+    @Ignore(\"JDK-8277000\")\n+    @Test\n+    public void testTreeTableRowFixedCellSizeListener() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        TreeTableRowSkin<?> rowSkin = (TreeTableRowSkin<?>) tableRow.getSkin();\n+        assertNull(\"row skin must not have listener to fixedCellSize\",\n+                unregisterChangeListeners(rowSkin, tableView.fixedCellSizeProperty()));\n+    }\n+\n+    \/**\n+     * Guard against incorrect initial prefWidth with many columns and fixedCellSize.\n+     * See JDK-8274061 for details.\n+     *\/\n+    @Test\n+    public void testTreeTablePrefRowWidthFixedCellSize() {\n+        TreeTableView<String[]> table = createManyColumnsTreeTableView(true);\n+        showControl(table, false, 300, 800);\n+        double totalColumnWidth = table.getVisibleLeafColumns().stream()\n+                .mapToDouble(col -> col.getWidth())\n+                .sum();\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) VirtualFlowTestUtils.getCell(table, 2);\n+        assertEquals(\"pref row width for fixed cell size\", totalColumnWidth, tableRow.prefWidth(-1), .1);\n+    }\n+\n+    \/**\n+     * Sanity test: pref width of tableRow if !fixedCellSize\n+     *\/\n+    @Test\n+    public void testTreeTablePrefRowTreeTable() {\n+        TreeTableView<String[]> table = createManyColumnsTreeTableView(false);\n+        showControl(table, false, 300, 800);\n+        double totalColumnWidth = table.getVisibleLeafColumns().stream()\n+                .mapToDouble(col -> col.getWidth())\n+                .sum();\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) VirtualFlowTestUtils.getCell(table, 2);\n+        assertEquals(\"sanity: pref row witdh for not fixed cell size\", totalColumnWidth, tableRow.prefWidth(-1), .1);\n+    }\n+\n@@ -392,0 +440,38 @@\n+    \/**\n+     * Creates and returns a treeTable with many columns of width COL_WIDTH each,\n+     * setting the fixedCellSize of FIXED_CELL_SIZE if useFixedCellSize is true.\n+     *\/\n+    private TreeTableView<String[]> createManyColumnsTreeTableView(boolean useFixedCellSize) {\n+        final TreeTableView<String[]> tableView = new TreeTableView<>();\n+        final ObservableList<TreeTableColumn<String[], ?>> columns = tableView\n+                .getColumns();\n+\/\/        tableView.getSelectionModel().setCellSelectionEnabled(true);\n+        for (int i = 0; i < COL_COUNT; i++) {\n+            TreeTableColumn<String[], String> column = new TreeTableColumn<>(\"Col\" + i);\n+            final int colIndex = i;\n+            column.setCellValueFactory((cell) -> new SimpleStringProperty(\n+                    cell.getValue().getValue()[colIndex]));\n+            columns.add(column);\n+            sizeColumn(column, COL_WIDTH);\n+        }\n+        ObservableList<String[]> items = FXCollections.observableArrayList();\n+        for (int i = 0; i < ROW_COUNT; i++) {\n+            String[] rec = new String[COL_COUNT];\n+            for (int j = 0; j < rec.length; j++) {\n+                rec[j] = i + \":\" + j;\n+            }\n+            items.add(rec);\n+        }\n+        TreeItem<String[]> root = new TreeItem<>(items.get(0));\n+        root.setExpanded(true);\n+        for (int i = 1; i < items.size(); i++) {\n+            root.getChildren().add(new TreeItem<>(items.get(i)));\n+        }\n+        tableView.setRoot(root);\n+        if (useFixedCellSize) {\n+            tableView.setFixedCellSize(FIXED_CELL_SIZE);\n+        }\n+\n+        return tableView;\n+    }\n+\n@@ -435,0 +521,43 @@\n+    \/**\n+     * Test access to fixedCellSize via lookup (not listener)\n+     *\/\n+    @Ignore(\"JDK-8277000\")\n+    @Test\n+    public void testTableRowFixedCellSizeListener() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        TableRowSkin<?> rowSkin = (TableRowSkin<?>) tableRow.getSkin();\n+        assertNull(\"row skin must not have listener to fixedCellSize\",\n+                unregisterChangeListeners(rowSkin, tableView.fixedCellSizeProperty()));\n+    }\n+\n+    \/**\n+     * Guard against incorrect initial prefWidth with many columns and fixedCellSize.\n+     * See JDK-8274061 for details.\n+     *\/\n+    @Test\n+    public void testTablePrefRowWidthFixedCellSize() {\n+        TableView<String[]> table = createManyColumnsTableView(true);\n+        showControl(table, false, 300, 800);\n+        double totalColumnWidth = table.getVisibleLeafColumns().stream()\n+                .mapToDouble(col -> col.getWidth())\n+                .sum();\n+        TableRow<?> tableRow = (TableRow<?>) VirtualFlowTestUtils.getCell(table, 2);\n+        assertEquals(\"pref row width for fixed cell size\", totalColumnWidth, tableRow.prefWidth(-1), .1);\n+    }\n+\n+    \/**\n+     * Sanity test: pref width of tableRow if !fixedCellSize\n+     *\/\n+    @Test\n+    public void testTablePrefRowWidth() {\n+        TableView<String[]> table = createManyColumnsTableView(false);\n+        showControl(table, false, 300, 800);\n+        double totalColumnWidth = table.getVisibleLeafColumns().stream()\n+                .mapToDouble(col -> col.getWidth())\n+                .sum();\n+        TableRow<?> tableRow = (TableRow<?>) VirtualFlowTestUtils.getCell(table, 2);\n+        assertEquals(\"sanity: pref row witdh for not fixed cell size\", totalColumnWidth, tableRow.prefWidth(-1), .1);\n+    }\n+\n@@ -644,0 +773,44 @@\n+    private static final int COL_COUNT = 50;\n+    private static final int ROW_COUNT = 10;\n+    private static final double COL_WIDTH = 50;\n+    private static final double FIXED_CELL_SIZE = 24;\n+\n+    \/**\n+     * Creates and returns a table with many columns of width COL_WIDTH each,\n+     * setting the fixedCellSize of FIXED_CELL_SIZE if useFixedCellSize is true.\n+     *\/\n+    private TableView<String[]> createManyColumnsTableView(boolean useFixedCellSize) {\n+        final TableView<String[]> tableView = new TableView<>();\n+        final ObservableList<TableColumn<String[], ?>> columns = tableView\n+                .getColumns();\n+        tableView.getSelectionModel().setCellSelectionEnabled(true);\n+        for (int i = 0; i < COL_COUNT; i++) {\n+            TableColumn<String[], String> column = new TableColumn<>(\"Col\" + i);\n+            final int colIndex = i;\n+            column.setCellValueFactory((cell) -> new SimpleStringProperty(\n+                    cell.getValue()[colIndex]));\n+            columns.add(column);\n+            sizeColumn(column, COL_WIDTH);\n+        }\n+        ObservableList<String[]> items = tableView.getItems();\n+        for (int i = 0; i < ROW_COUNT; i++) {\n+            String[] rec = new String[COL_COUNT];\n+            for (int j = 0; j < rec.length; j++) {\n+                rec[j] = i + \":\" + j;\n+            }\n+            items.add(rec);\n+        }\n+        if (useFixedCellSize) {\n+            tableView.setFixedCellSize(FIXED_CELL_SIZE);\n+        }\n+\n+        return tableView;\n+    }\n+\n+    private void sizeColumn(TableColumnBase<?, ?> column, double width) {\n+        column.setPrefWidth(width);\n+        column.setMinWidth(width);\n+        column.setMaxWidth(width);\n+    }\n+\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/SkinCleanupTest.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"modified"}]}