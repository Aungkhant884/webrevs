{"files":[{"patch":"@@ -33,11 +33,0 @@\n-import javafx.beans.InvalidationListener;\n-import javafx.beans.Observable;\n-import javafx.beans.property.DoubleProperty;\n-import javafx.scene.control.Accordion;\n-import javafx.scene.control.Button;\n-import javafx.scene.control.TableCell;\n-import javafx.scene.control.TableColumn;\n-import javafx.scene.control.TablePosition;\n-import javafx.scene.control.TableRow;\n-import javafx.scene.control.TableView;\n-\n@@ -46,1 +35,1 @@\n-import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.DoubleProperty;\n@@ -52,0 +41,2 @@\n+import javafx.scene.control.TableCell;\n+import javafx.scene.control.TableColumn;\n@@ -53,0 +44,3 @@\n+import javafx.scene.control.TablePosition;\n+import javafx.scene.control.TableRow;\n+import javafx.scene.control.TableView;\n@@ -54,1 +48,0 @@\n-import javafx.scene.control.TreeTableView;\n@@ -111,0 +104,1 @@\n+    \/\/ FIXME: replace listener to fixedCellSize with direct lookup - JDK-8277000\n@@ -114,5 +108,3 @@\n-            getSkinnable().tableViewProperty().addListener(new InvalidationListener() {\n-                @Override public void invalidated(Observable observable) {\n-                    getSkinnable().tableViewProperty().removeListener(this);\n-                    setupTreeTableViewListeners();\n-                }\n+            registerInvalidationListener(getSkinnable().tableViewProperty(), e -> {\n+                unregisterInvalidationListeners(getSkinnable().tableViewProperty());\n+                setupTreeTableViewListeners();\n@@ -139,2 +131,0 @@\n-\n-\n@@ -248,0 +238,6 @@\n+\n+    \/\/ test-only\n+    TableViewSkin<T> getTableViewSkin() {\n+        return tableViewSkin;\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableRowSkin.java","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import javafx.beans.property.DoubleProperty;\n@@ -37,1 +36,0 @@\n-import javafx.collections.ListChangeListener;\n@@ -39,1 +37,0 @@\n-import javafx.collections.WeakListChangeListener;\n@@ -107,1 +104,0 @@\n-\n@@ -136,0 +132,1 @@\n+    \/\/ FIXME: replace cached values with direct lookup - JDK-8277000\n@@ -140,1 +137,0 @@\n-\n@@ -165,1 +161,1 @@\n-        getVisibleLeafColumns().addListener(weakVisibleLeafColumnsListener);\n+        registerListChangeListener(getVisibleLeafColumns(), c -> updateLeafColumns());\n@@ -171,1 +167,1 @@\n-        control.itemProperty().addListener(o -> requestCellUpdate());\n+        registerInvalidationListener(control.itemProperty(), o -> requestCellUpdate());\n@@ -191,1 +187,1 @@\n-    private ListChangeListener<TableColumnBase> visibleLeafColumnsListener = c -> {\n+    private void updateLeafColumns() {\n@@ -194,6 +190,1 @@\n-    };\n-\n-    private WeakListChangeListener<TableColumnBase> weakVisibleLeafColumnsListener =\n-            new WeakListChangeListener<>(visibleLeafColumnsListener);\n-\n-\n+    }\n@@ -658,0 +649,4 @@\n+    \/\/ test-only\n+    boolean isDirty() {\n+        return isDirty;\n+    }\n@@ -659,0 +654,4 @@\n+    \/\/ test-only\n+    void setDirty(boolean dirty) {\n+        isDirty = dirty;\n+    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableRowSkinBase.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import javafx.beans.InvalidationListener;\n-import javafx.beans.Observable;\n@@ -59,1 +57,0 @@\n-import javafx.scene.control.TreeView;\n@@ -123,0 +120,1 @@\n+    \/\/ FIXME: replace listener to fixedCellSize with direct lookup - JDK-8277000\n@@ -126,5 +124,3 @@\n-            getSkinnable().treeTableViewProperty().addListener(new InvalidationListener() {\n-                @Override public void invalidated(Observable observable) {\n-                    getSkinnable().treeTableViewProperty().removeListener(this);\n-                    setupTreeTableViewListeners();\n-                }\n+            registerInvalidationListener(getSkinnable().treeTableViewProperty(), e -> {\n+                unregisterInvalidationListeners(getSkinnable().treeTableViewProperty());\n+                setupTreeTableViewListeners();\n@@ -166,1 +162,1 @@\n-    private final InvalidationListener graphicListener = o -> {\n+    private void updateTreeItemGraphic() {\n@@ -169,2 +165,1 @@\n-    };\n-\n+    }\n@@ -256,1 +251,0 @@\n-\n@@ -334,2 +328,0 @@\n-        TreeTableRow<T> treeTableRow = getSkinnable();\n-        if (treeTableRow == null) return null;\n@@ -337,1 +329,0 @@\n-\n@@ -342,3 +333,1 @@\n-        if (treeItem != null) {\n-            treeItem.graphicProperty().removeListener(graphicListener);\n-        }\n+        unregisterInvalidationListeners(graphicProperty());\n@@ -346,3 +335,1 @@\n-        if (treeItem != null) {\n-            treeItem.graphicProperty().addListener(graphicListener);\n-        }\n+        registerInvalidationListener(graphicProperty(), e -> updateTreeItemGraphic());\n@@ -406,0 +393,9 @@\n+    \/\/ test-only\n+    TreeTableViewSkin<T> getTableViewSkin() {\n+        return treeTableViewSkin;\n+    }\n+\n+    \/\/ test-only\n+    TreeItem<T> getTreeItem() {\n+        return (TreeItem<T>) treeItem;\n+    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TreeTableRowSkin.java","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,0 +29,6 @@\n+import java.util.function.Consumer;\n+\n+import javafx.beans.Observable;\n+import javafx.beans.value.ObservableValue;\n+import javafx.collections.ListChangeListener.Change;\n+import javafx.collections.ObservableList;\n@@ -39,1 +45,1 @@\n-    public static List<Node> getChildren(SkinBase skin) {\n+    public static List<Node> getChildren(SkinBase<?> skin) {\n@@ -42,0 +48,15 @@\n+\n+\/\/-------------- access listener api\n+\n+    public static Consumer<ObservableValue<?>> unregisterChangeListeners(SkinBase<?> skin, ObservableValue<?> ov) {\n+        return skin.unregisterChangeListeners(ov);\n+    }\n+\n+    public static Consumer<Observable> unregisterInvalidationListeners(SkinBase<?> skin, Observable ov) {\n+        return skin.unregisterInvalidationListeners(ov);\n+    }\n+\n+    public static Consumer<Change<?>> unregisterListChangeListeners(SkinBase<?> skin, ObservableList<?> ov) {\n+        return skin.unregisterListChangeListeners(ov);\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/shims\/java\/javafx\/scene\/control\/SkinBaseShim.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.scene.control.skin;\n+\n+import java.util.List;\n+\n+import javafx.beans.property.ObjectProperty;\n+import javafx.collections.ObservableList;\n+import javafx.scene.Node;\n+import javafx.scene.control.IndexedCell;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TableRow;\n+import javafx.scene.control.TableView;\n+import javafx.scene.control.TreeItem;\n+import javafx.scene.control.TreeTableRow;\n+import javafx.scene.control.TreeTableView;\n+\n+\/**\n+ * Utility methods to access package-private api in Table-related skins.\n+ *\/\n+public class TableSkinShim {\n+\n+    \/**\n+     * Returns the TableHeaderRow of the skin's table if that is of type TableViewSkinBase\n+     * or null if not.\n+     *\n+     * @param <T>\n+     * @param table the table to get the TableHeaderRow from\n+     * @return the tableHeaderRow of the table's skin or null if the skin not of type\n+     *    TableViewSkinBase\n+     *\/\n+    public static <T> TableHeaderRow getTableHeaderRow(TableView<T> table) {\n+        if (table.getSkin() instanceof TableViewSkinBase) {\n+            return getTableHeaderRow((TableViewSkinBase) table.getSkin());\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns the TableHeaderRow of the given skin.\n+     *\n+     * @param <T>\n+     * @param skin the skin to get the TableHeaderRow from\n+     * @return\n+     * @throws NullPointerException if skin is null\n+     *\/\n+    public static <T> TableHeaderRow getTableHeaderRow(TableViewSkinBase skin) {\n+        return skin.getTableHeaderRow();\n+    }\n+\n+    \/**\n+     * Returns the TableColumnHeader for the given column or null if not available.\n+     *\n+     * @param <T>\n+     * @param column\n+     * @return\n+     *\/\n+    public static <T> TableColumnHeader getColumnHeaderFor(TableColumn<T, ?> column) {\n+        TableView<T> table = column.getTableView();\n+        TableHeaderRow tableHeader = getTableHeaderRow(table);\n+        if (tableHeader != null) {\n+            return tableHeader.getColumnHeaderFor(column);\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns the VirtualFlow from the table's skin which must be of type\n+     * TableViewSkin.\n+     *\/\n+    public static VirtualFlow<?> getVirtualFlow(TableView<?> table) {\n+        TableViewSkin<?> skin = (TableViewSkin<?>) table.getSkin();\n+        return skin.getVirtualFlow();\n+    }\n+\n+    \/**\n+     * Returns the VirtualFlow from the table's skin which must be of type\n+     * TreeTableViewSkin.\n+     *\/\n+    public static VirtualFlow<?> getVirtualFlow(TreeTableView<?> table) {\n+        TreeTableViewSkin<?> skin = (TreeTableViewSkin<?>) table.getSkin();\n+        return skin.getVirtualFlow();\n+    }\n+\n+\/\/    public static <T> TableRow<T> getCell(TableView<T> table, int index) {\n+\/\/        VirtualFlow flow = getVirtualFlow(table);\n+\/\/        return (TableRow<T>) flow.getCell(index);\n+\/\/    }\n+\/\/\n+\/\/    public static <T> TreeTableRow<T> getCell(TreeTableView<T> table, int index) {\n+\/\/        VirtualFlow flow = getVirtualFlow(table);\n+\/\/        return (TreeTableRow<T>) flow.getCell(index);\n+\/\/    }\n+\/\/----------------- Tree\/TableRowSkin state\n+\n+    public static <T> boolean isFixedCellSizeEnabled(TableRow<T> tableRow) {\n+        TableRowSkin<T> skin = (TableRowSkin<T>) tableRow.getSkin();\n+        return skin.fixedCellSizeEnabled;\n+    }\n+\n+    public static <T> boolean isFixedCellSizeEnabled(TreeTableRow<T> tableRow) {\n+        TreeTableRowSkin<T> skin = (TreeTableRowSkin<T>) tableRow.getSkin();\n+        return skin.fixedCellSizeEnabled;\n+    }\n+\n+    public static <T> boolean isDirty(TableRow<T> tableRow) {\n+        TableRowSkin<T> skin = (TableRowSkin<T>) tableRow.getSkin();\n+        return skin.isDirty();\n+    }\n+\n+    public static <T> boolean isDirty(TreeTableRow<T> tableRow) {\n+        TreeTableRowSkin<T> skin = (TreeTableRowSkin<T>) tableRow.getSkin();\n+        return skin.isDirty();\n+    }\n+\n+    public static <T> void setDirty(TableRow<T> tableRow, boolean dirty) {\n+        TableRowSkin<T> skin = (TableRowSkin<T>) tableRow.getSkin();\n+        skin.setDirty(dirty);\n+    }\n+\n+    public static <T> ObservableList<TableColumn<T, ?>> getVisibleLeafColumns(TableRow<T> tableRow) {\n+        TableRowSkin<T> skin = (TableRowSkin<T>) tableRow.getSkin();\n+        return skin.getVisibleLeafColumns();\n+    }\n+\n+    public static <T> TableViewSkin<T> getTableViewSkin(TableRow<T> tableRow) {\n+        TableRowSkin<T> skin = (TableRowSkin<T>) tableRow.getSkin();\n+        return skin.getTableViewSkin();\n+    }\n+\n+    public static <T> TreeTableViewSkin<T> getTableViewSkin(TreeTableRow<T> tableRow) {\n+        TreeTableRowSkin<T> skin = (TreeTableRowSkin<T>) tableRow.getSkin();\n+        return skin.getTableViewSkin();\n+    }\n+\n+    public static <T> TreeItem<T> getTreeItem(TreeTableRow<T> tableRow) {\n+        TreeTableRowSkin<T> skin = (TreeTableRowSkin<T>) tableRow.getSkin();\n+        return skin.getTreeItem();\n+    }\n+\n+    public static <T> ObjectProperty<Node> graphicProperty(TreeTableRow<T> tableRow) {\n+        TreeTableRowSkin<T> skin = (TreeTableRowSkin<T>) tableRow.getSkin();\n+        return skin.graphicProperty();\n+    }\n+\n+\n+    public static <T> VirtualFlow<?> getVirtualFlow(TableRow<T> table) {\n+        TableRowSkin<T> skin = (TableRowSkin<T>) table.getSkin();\n+        return skin.getVirtualFlow();\n+    }\n+\n+    public static <T> VirtualFlow<?> getVirtualFlow(TreeTableRow<T> table) {\n+        TreeTableRowSkin<T> skin = (TreeTableRowSkin<T>) table.getSkin();\n+        return skin.getVirtualFlow();\n+    }\n+\n+    public static List<IndexedCell<?>> getCells(TableRow tableRow) {\n+        TableRowSkin skin = (TableRowSkin) tableRow.getSkin();\n+        return skin.cells;\n+    }\n+\n+    public static List<IndexedCell<?>> getCells(TreeTableRow<?> tableRow) {\n+        TreeTableRowSkin skin = (TreeTableRowSkin) tableRow.getSkin();\n+        return skin.cells;\n+    }\n+\n+\n+\n+}\n","filename":"modules\/javafx.controls\/src\/shims\/java\/javafx\/scene\/control\/skin\/TableSkinShim.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -33,0 +33,2 @@\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n@@ -110,0 +112,10 @@\n+\n+    public static ObservableList<Person> persons() {\n+        return FXCollections.observableArrayList(\n+                new Person(\"Jacob\", \"Smith\", \"jacob.smith@example.com\"),\n+                new Person(\"Isabella\", \"Johnson\", \"isabella.johnson@example.com\"),\n+                new Person(\"Ethan\", \"Williams\", \"ethan.williams@example.com\"),\n+                new Person(\"Emma\", \"Jones\", \"emma.jones@example.com\"),\n+                new Person(\"Michael\", \"Brown\", \"michael.brown@example.com\")\n+                );\n+    }\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/control\/test\/Person.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.stream.Collectors;\n@@ -40,0 +41,3 @@\n+import static javafx.scene.control.SkinBaseShim.*;\n+import static javafx.scene.control.skin.TableSkinShim.*;\n+import static javafx.scene.control.skin.TableSkinShim.getVirtualFlow;\n@@ -43,0 +47,1 @@\n+import static test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils.*;\n@@ -44,0 +49,3 @@\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n@@ -51,0 +59,2 @@\n+import javafx.scene.control.IndexedCell;\n+import javafx.scene.control.Label;\n@@ -56,0 +66,4 @@\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TableColumnBase;\n+import javafx.scene.control.TableRow;\n+import javafx.scene.control.TableView;\n@@ -61,0 +75,3 @@\n+import javafx.scene.control.TreeTableColumn;\n+import javafx.scene.control.TreeTableRow;\n+import javafx.scene.control.TreeTableView;\n@@ -62,0 +79,5 @@\n+import javafx.scene.control.cell.PropertyValueFactory;\n+import javafx.scene.control.cell.TreeItemPropertyValueFactory;\n+import javafx.scene.control.skin.TableRowSkin;\n+import javafx.scene.control.skin.TreeTableRowSkin;\n+import javafx.scene.control.skin.VirtualFlow;\n@@ -70,0 +92,2 @@\n+import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;\n+import test.com.sun.javafx.scene.control.test.Person;\n@@ -80,0 +104,745 @@\n+\/\/------------- TreeTableRow\n+\n+    \/**\n+     * Test access to fixedCellSize via lookup (not listener)\n+     *\/\n+    @Ignore(\"JDK-8277000\")\n+    @Test\n+    public void testTreeTableRowFixedCellSizeListener() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        TreeTableRowSkin<?> rowSkin = (TreeTableRowSkin<?>) tableRow.getSkin();\n+        assertNull(\"row skin must not have listener to fixedCellSize\",\n+                unregisterChangeListeners(rowSkin, tableView.fixedCellSizeProperty()));\n+    }\n+\n+    \/**\n+     * Guard against incorrect initial prefWidth with many columns and fixedCellSize.\n+     * See JDK-8274061 for details.\n+     *\/\n+    @Test\n+    public void testTreeTablePrefRowWidthFixedCellSize() {\n+        TreeTableView<String[]> table = createManyColumnsTreeTableView(true);\n+        showControl(table, false, 300, 800);\n+        double totalColumnWidth = table.getVisibleLeafColumns().stream()\n+                .mapToDouble(col -> col.getWidth())\n+                .sum();\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) VirtualFlowTestUtils.getCell(table, 2);\n+        assertEquals(\"pref row width for fixed cell size\", totalColumnWidth, tableRow.prefWidth(-1), .1);\n+    }\n+\n+    \/**\n+     * Sanity test: pref width of tableRow if !fixedCellSize\n+     *\/\n+    @Test\n+    public void testTreeTablePrefRowTreeTable() {\n+        TreeTableView<String[]> table = createManyColumnsTreeTableView(false);\n+        showControl(table, false, 300, 800);\n+        double totalColumnWidth = table.getVisibleLeafColumns().stream()\n+                .mapToDouble(col -> col.getWidth())\n+                .sum();\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) VirtualFlowTestUtils.getCell(table, 2);\n+        assertEquals(\"sanity: pref row witdh for not fixed cell size\", totalColumnWidth, tableRow.prefWidth(-1), .1);\n+    }\n+\n+    \/**\n+     * Sanity test: listener to treeColumn working without side-effects\n+     * after replacing skin.\n+     *\/\n+    @Test\n+    public void testTreeTableRowTreeColumnListenerReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        tableView.setTreeColumn(tableView.getColumns().get(1));\n+        \/\/ note: the actual update happens only in layout, test the marker here\n+        assertTrue(\"dirty marker must have been set\", isDirty(tableRow));\n+    }\n+\n+    \/**\n+     * Sanity test: listener to treeColumn working.\n+     *\/\n+    @Test\n+    public void testTreeTableRowTreeColumnListener() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        tableView.setTreeColumn(tableView.getColumns().get(1));\n+        \/\/ note: the actual update happens only in layout, test the marker here\n+        assertTrue(\"dirty marker must have been set\", isDirty(tableRow));\n+    }\n+\n+    @Test\n+    public void testTreeTableRowGraphicListenerReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        int index = 1;\n+        Label graphic = new Label(\"dummy\");\n+        TreeItem<Person> treeItem = tableView.getTreeItem(index);\n+        treeItem.setGraphic(graphic);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, index);\n+        replaceSkin(tableView);\n+        \/\/ note: need an actual layout to update the children here, firePulse in _not_ enough\n+        tableRow.layout();\n+        assertEquals(index, tableRow.getIndex());\n+        assertTrue(tableRow.getChildrenUnmodifiable().contains(graphic));\n+    }\n+\n+    \/**\n+     * Sanity test: row graphic is updated on changing treeItem's graphic.\n+     *\/\n+    @Test\n+    public void testTreeTableRowGraphicListener() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        int index = 1;\n+        Label graphic = new Label(\"dummy\");\n+        tableView.getTreeItem(index).setGraphic(graphic);\n+        Toolkit.getToolkit().firePulse();\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, index);\n+        assertTrue(tableRow.getChildrenUnmodifiable().contains(graphic));\n+    }\n+\n+    @Test\n+    public void testTreeTableRowFixedCellSizeReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        double fixed = 200;\n+        tableView.setFixedCellSize(fixed);\n+        assertEquals(\"fixed cell size: \", fixed, tableRow.prefHeight(-1), 1);\n+    }\n+\n+    \/**\n+     * Sanity test: row respects fixedCellSize.\n+     *\/\n+    @Test\n+    public void testTreeTableRowFixedCellSize() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        double fixed = 200;\n+        tableView.setFixedCellSize(fixed);\n+        assertEquals(\"fixed cell size: \", fixed, tableRow.prefHeight(-1), 1);\n+    }\n+\n+    @Test\n+    public void testTreeTableRowFixedCellSizeEnabledReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        assertFalse(\"fixed cell size disabled initially\", isFixedCellSizeEnabled(tableRow));\n+        double fixed = 200;\n+        tableView.setFixedCellSize(fixed);\n+        assertTrue(\"fixed cell size enabled\", isFixedCellSizeEnabled(tableRow));\n+    }\n+\n+    \/**\n+     * Sanity test: fixedCellSizeEnabled.\n+     *\/\n+    @Test\n+    public void testTreeTableRowFixedCellSizeEnabled() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        assertFalse(\"fixed cell size disabled initially\", isFixedCellSizeEnabled(tableRow));\n+        double fixed = 200;\n+        tableView.setFixedCellSize(fixed);\n+        assertTrue(\"fixed cell size enabled\", isFixedCellSizeEnabled(tableRow));\n+    }\n+\n+    @Test\n+    public void testTreeTableRowVirtualFlowWidthListenerReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        VirtualFlow<?> flow = getVirtualFlow(tableView);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        Toolkit.getToolkit().firePulse();\n+        TreeTableRowSkin<?> rowSkin = (TreeTableRowSkin<?>) tableRow.getSkin();\n+        assertNotNull(\"row skin must have listener to virtualFlow width\",\n+                unregisterChangeListeners(rowSkin, flow.widthProperty()));\n+    }\n+\n+    \/**\n+     * Sanity: listener to flow's width is registered.\n+     *\/\n+    @Test\n+    public void testTreeTableRowVirtualFlowWidthListener() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        VirtualFlow<?> flow = getVirtualFlow(tableView);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        TreeTableRowSkin<?> rowSkin = (TreeTableRowSkin<?>) tableRow.getSkin();\n+        assertNotNull(\"row skin must have listener to virtualFlow width\",\n+                unregisterChangeListeners(rowSkin, flow.widthProperty()));\n+    }\n+\n+    \/**\n+     * Sanity: children don't pile up with fixedCellSize.\n+     *\/\n+    @Test\n+    public void testTreeTableRowChildCountFixedCellSizeReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        tableView.setFixedCellSize(100);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 0);\n+        int childCount = tableRow.getChildrenUnmodifiable().size();\n+        replaceSkin(tableRow);\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(childCount, tableRow.getChildrenUnmodifiable().size());\n+    }\n+\n+    \/**\n+     * Sanity: children don't pile up.\n+     *\/\n+    @Test\n+    public void testTreeTableRowChildCountReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 0);\n+        int childCount = tableRow.getChildrenUnmodifiable().size();\n+        replaceSkin(tableRow);\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(childCount, tableRow.getChildrenUnmodifiable().size());\n+    }\n+\n+    @Test\n+    public void testTreeTableRowVirtualFlowReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        assertEquals(tableView.getSkin(), getTableViewSkin(tableRow));\n+        assertEquals(getVirtualFlow(tableView), getVirtualFlow(tableRow));\n+    }\n+\n+    \/**\n+     * Sanity: invariants of skin\/flow in rowSkin\n+     *\/\n+    @Test\n+    public void testTreeTableRowVirtualFlow() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        assertEquals(tableView.getSkin(), getTableViewSkin(tableRow));\n+        assertEquals(getVirtualFlow(tableView), getVirtualFlow(tableRow));\n+    }\n+\n+    \/**\n+     * Here we configure a tableRow with table and install the row's skin.\n+     *\/\n+    @Ignore(\"JDK-8274065\")\n+    @Test\n+    public void testTreeTableRowVirtualFlowInstallSkin() {\n+        TreeTableRow<?> tableRow = createTreeTableRow(1);\n+        installDefaultSkin(tableRow);\n+        TreeTableView<?> tableView = tableRow.getTreeTableView();\n+        assertEquals(tableView.getSkin(), getTableViewSkin(tableRow));\n+        assertEquals(getVirtualFlow(tableView), getVirtualFlow(tableRow));\n+    }\n+\n+    @Test\n+    public void testTreeTableRowWithGraphicMemoryLeak() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        tableView.getTreeItem(1).setGraphic(new Label(\"nothing\"));\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        WeakReference<?> weakRef = new WeakReference<>(replaceSkin(tableRow));\n+        assertNotNull(weakRef.get());\n+        attemptGC(weakRef);\n+        assertEquals(\"Skin must be gc'ed\", null, weakRef.get());\n+    }\n+\n+    \/**\n+     * Fails in install skin NPE\n+     *\/\n+    @Ignore(\"JDK-8274065\")\n+    @Test\n+    public void testTreeTableRowWithGraphicMemoryLeakInstallSkin() {\n+        TreeTableRow<?> tableRow = createTreeTableRow(1);\n+        installDefaultSkin(tableRow);\n+        tableRow.getTreeTableView().getTreeItem(1).setGraphic(new Label(\"nothing\"));\n+        WeakReference<?> weakRef = new WeakReference<>(replaceSkin(tableRow));\n+        assertNotNull(weakRef.get());\n+        attemptGC(weakRef);\n+        assertEquals(\"Skin must be gc'ed\", null, weakRef.get());\n+    }\n+\n+\n+\/\/--- TableRowSkinBase (tested against TreeTableRow)\n+\n+    \/**\n+     * NPE from listener in previous skin if not removed.\n+     *\/\n+    @Test\n+    public void testTreeTableRowLeafColumnsListenerReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        tableView.getColumns().get(0).setVisible(false);\n+        assertTrue(\"dirty marker must have been set\", isDirty(tableRow));\n+    }\n+\n+    \/**\n+     * Sanity test: child cells are updated on changing visible columns.\n+     *\/\n+    @Test\n+    public void testTreeTableRowLeafColumnsListener() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        tableView.getColumns().get(0).setVisible(false);\n+        assertTrue(\"dirty marker must have been set\", isDirty(tableRow));\n+    }\n+\n+    \/**\n+     *  NPE from listener in previous skin if not removed.\n+     *\/\n+    @Test\n+    public void testTreeTableRowItemListenerReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        int initial = 0;\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, initial);\n+        replaceSkin(tableRow);\n+        int index = 1;\n+        tableRow.updateIndex(index);\n+        List<IndexedCell<?>> cells = getCells(tableRow);\n+        assertEquals(tableView.getVisibleLeafColumns().size(), cells.size());\n+        assertEquals(\"cell index must be updated\", index, cells.get(0).getIndex());\n+    }\n+\n+    \/**\n+     * Sanity test: child cell's index is updated\n+     *\/\n+    @Test\n+    public void testTreeTableRowItemListener() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        int initial = 0;\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, initial);\n+        int index = 1;\n+        tableRow.updateIndex(index);\n+        List<IndexedCell<?>> cells = getCells(tableRow);\n+        assertEquals(tableView.getVisibleLeafColumns().size(), cells.size());\n+        assertEquals(\"cell index must be updated\", index, cells.get(0).getIndex());\n+   }\n+\n+\n+\/\/-------------- helpers for TreeTableRow tests\n+\n+    \/**\n+     * Creates and returns a treeTable with many columns of width COL_WIDTH each,\n+     * setting the fixedCellSize of FIXED_CELL_SIZE if useFixedCellSize is true.\n+     *\/\n+    private TreeTableView<String[]> createManyColumnsTreeTableView(boolean useFixedCellSize) {\n+        final TreeTableView<String[]> tableView = new TreeTableView<>();\n+        final ObservableList<TreeTableColumn<String[], ?>> columns = tableView\n+                .getColumns();\n+\/\/        tableView.getSelectionModel().setCellSelectionEnabled(true);\n+        for (int i = 0; i < COL_COUNT; i++) {\n+            TreeTableColumn<String[], String> column = new TreeTableColumn<>(\"Col\" + i);\n+            final int colIndex = i;\n+            column.setCellValueFactory((cell) -> new SimpleStringProperty(\n+                    cell.getValue().getValue()[colIndex]));\n+            columns.add(column);\n+            sizeColumn(column, COL_WIDTH);\n+        }\n+        ObservableList<String[]> items = FXCollections.observableArrayList();\n+        for (int i = 0; i < ROW_COUNT; i++) {\n+            String[] rec = new String[COL_COUNT];\n+            for (int j = 0; j < rec.length; j++) {\n+                rec[j] = i + \":\" + j;\n+            }\n+            items.add(rec);\n+        }\n+        TreeItem<String[]> root = new TreeItem<>(items.get(0));\n+        root.setExpanded(true);\n+        for (int i = 1; i < items.size(); i++) {\n+            root.getChildren().add(new TreeItem<>(items.get(i)));\n+        }\n+        tableView.setRoot(root);\n+        if (useFixedCellSize) {\n+            tableView.setFixedCellSize(FIXED_CELL_SIZE);\n+        }\n+\n+        return tableView;\n+    }\n+\n+    \/**\n+     * Creates and returns a TreeTableRow configured to test\n+     * intalling\/switching its skin reliably.\n+     *\n+     * - must be configure with a TableView that has a skin\n+     * - must not be empty\n+     *\/\n+    private TreeTableRow<?> createTreeTableRow(int index) {\n+        TreeTableView<Person> table = createPersonTreeTable(true);\n+        TreeTableRow<Person> tableRow = new TreeTableRow<>();\n+        \/\/ note: must updateTable before updateIndex\n+        tableRow.updateTreeTableView(table);\n+        tableRow.updateIndex(index);\n+        assertFalse(\"sanity: row must not be empty at index: \" + index, tableRow.isEmpty());\n+        return tableRow;\n+    }\n+\n+    \/**\n+     * Returns a table with two columns. Installs the default skin if\n+     * installSkin is true.\n+     *\/\n+    private TreeTableView<Person> createPersonTreeTable(boolean installSkin) {\n+        TreeItem<Person> root = new TreeItem<>(new Person(\"rootFirst\", \"rootLast\", \"root@nowhere.com\"));\n+        root.setExpanded(true);\n+        root.getChildren().addAll(\n+                Person.persons().stream()\n+                .map(TreeItem::new)\n+                .collect(Collectors.toList()));\n+        TreeTableView<Person> table = new TreeTableView<>(root);\n+        assertEquals(Person.persons().size() + 1, table.getExpandedItemCount());\n+        TreeTableColumn<Person, String> firstName = new TreeTableColumn<>(\"First Name\");\n+        firstName.setCellValueFactory(new TreeItemPropertyValueFactory<>(\"firstName\"));\n+        TreeTableColumn<Person, String> lastName = new TreeTableColumn<>(\"Last Name\");\n+        lastName.setCellValueFactory(new TreeItemPropertyValueFactory<>(\"lastName\"));\n+        table.getColumns().addAll(firstName, lastName);\n+        if (installSkin) {\n+            installDefaultSkin(table);\n+        }\n+        return table;\n+    }\n+\n+\/\/--------------------- TableRowSkin\n+\n+    \/**\n+     * Test access to fixedCellSize via lookup (not listener)\n+     *\/\n+    @Ignore(\"JDK-8277000\")\n+    @Test\n+    public void testTableRowFixedCellSizeListener() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        TableRowSkin<?> rowSkin = (TableRowSkin<?>) tableRow.getSkin();\n+        assertNull(\"row skin must not have listener to fixedCellSize\",\n+                unregisterChangeListeners(rowSkin, tableView.fixedCellSizeProperty()));\n+    }\n+\n+    \/**\n+     * Guard against incorrect initial prefWidth with many columns and fixedCellSize.\n+     * See JDK-8274061 for details.\n+     *\/\n+    @Test\n+    public void testTablePrefRowWidthFixedCellSize() {\n+        TableView<String[]> table = createManyColumnsTableView(true);\n+        showControl(table, false, 300, 800);\n+        double totalColumnWidth = table.getVisibleLeafColumns().stream()\n+                .mapToDouble(col -> col.getWidth())\n+                .sum();\n+        TableRow<?> tableRow = (TableRow<?>) VirtualFlowTestUtils.getCell(table, 2);\n+        assertEquals(\"pref row width for fixed cell size\", totalColumnWidth, tableRow.prefWidth(-1), .1);\n+    }\n+\n+    \/**\n+     * Sanity test: pref width of tableRow if !fixedCellSize\n+     *\/\n+    @Test\n+    public void testTablePrefRowWidth() {\n+        TableView<String[]> table = createManyColumnsTableView(false);\n+        showControl(table, false, 300, 800);\n+        double totalColumnWidth = table.getVisibleLeafColumns().stream()\n+                .mapToDouble(col -> col.getWidth())\n+                .sum();\n+        TableRow<?> tableRow = (TableRow<?>) VirtualFlowTestUtils.getCell(table, 2);\n+        assertEquals(\"sanity: pref row witdh for not fixed cell size\", totalColumnWidth, tableRow.prefWidth(-1), .1);\n+    }\n+\n+    @Test\n+    public void testTableRowFixedCellSizeReplaceSkin() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        double fixed = 200;\n+        tableView.setFixedCellSize(fixed);\n+        assertEquals(\"fixed cell size: \", fixed, tableRow.prefHeight(-1), 1);\n+    }\n+\n+    \/**\n+     * Sanity test: row respects fixedCellSize.\n+     *\/\n+    @Test\n+    public void testTableRowFixedCellSize() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        double fixed = 200;\n+        tableView.setFixedCellSize(fixed);\n+        assertEquals(\"fixed cell size: \", fixed, tableRow.prefHeight(-1), 1);\n+    }\n+\n+    @Test\n+    public void testTableRowFixedCellSizeEnabledReplaceSkin() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        assertFalse(\"fixed cell size disabled initially\", isFixedCellSizeEnabled(tableRow));\n+        double fixed = 200;\n+        tableView.setFixedCellSize(fixed);\n+        assertTrue(\"fixed cell size enabled\", isFixedCellSizeEnabled(tableRow));\n+    }\n+\n+    \/**\n+     * Sanity test: fixedCellSizeEnabled.\n+     *\/\n+    @Test\n+    public void testTableRowFixedCellSizeEnabled() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        assertFalse(\"fixed cell size disabled initially\", isFixedCellSizeEnabled(tableRow));\n+        double fixed = 200;\n+        tableView.setFixedCellSize(fixed);\n+        assertTrue(\"fixed cell size enabled\", isFixedCellSizeEnabled(tableRow));\n+    }\n+\n+    @Test\n+    public void testTableRowVirtualFlowWidthListenerReplaceSkin() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        VirtualFlow<?> flow = getVirtualFlow(tableView);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        Toolkit.getToolkit().firePulse();\n+        TableRowSkin<?> rowSkin = (TableRowSkin<?>) tableRow.getSkin();\n+        assertNotNull(\"row skin must have listener to virtualFlow width\",\n+                unregisterChangeListeners(rowSkin, flow.widthProperty()));\n+    }\n+\n+    \/**\n+     * Sanity test: listener to flow's width is registered.\n+     *\/\n+    @Test\n+    public void testTableRowVirtualFlowWidthListener() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        VirtualFlow<?> flow = getVirtualFlow(tableView);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        TableRowSkin<?> rowSkin = (TableRowSkin<?>) tableRow.getSkin();\n+        assertNotNull(\"row skin must have listener to virtualFlow width\",\n+                unregisterChangeListeners(rowSkin, flow.widthProperty()));\n+    }\n+\n+    \/**\n+     * Sanity: children don't pile up with fixed cell size.\n+     *\/\n+    @Test\n+    public void testTableRowChildCountFixedCellSizeReplaceSkin() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        tableView.setFixedCellSize(100);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 0);\n+        int childCount = tableRow.getChildrenUnmodifiable().size();\n+        assertEquals(2, childCount);\n+        replaceSkin(tableRow);\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(childCount, tableRow.getChildrenUnmodifiable().size());\n+    }\n+\n+    \/**\n+     * Sanity: children don't pile up.\n+     *\/\n+    @Test\n+    public void testTableRowChildCountReplaceSkin() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 0);\n+        int childCount = tableRow.getChildrenUnmodifiable().size();\n+        assertEquals(2, childCount);\n+        replaceSkin(tableRow);\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(childCount, tableRow.getChildrenUnmodifiable().size());\n+    }\n+\n+    @Test\n+    public void testTableRowVirtualFlowReplaceSkin() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        assertEquals(tableView.getSkin(), getTableViewSkin(tableRow));\n+        assertEquals(getVirtualFlow(tableView), getVirtualFlow(tableRow));\n+    }\n+\n+    \/**\n+     * Sanity: invariants of skin\/flow in rowSkin\n+     *\/\n+    @Test\n+    public void testTableRowVirtualFlow() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        assertEquals(tableView.getSkin(), getTableViewSkin(tableRow));\n+        assertEquals(getVirtualFlow(tableView), getVirtualFlow(tableRow));\n+    }\n+\n+    \/**\n+     * Here we configure a tableRow with table and install the row's skin.\n+     *\/\n+    @Ignore(\"JDK-8274065\")\n+    @Test\n+    public void testTableRowVirtualFlowInstallSkin() {\n+        TableRow<?> tableRow = createTableRow(0);\n+        installDefaultSkin(tableRow);\n+        TableView<?> tableView = tableRow.getTableView();\n+        assertEquals(tableView.getSkin(), getTableViewSkin(tableRow));\n+        assertEquals(getVirtualFlow(tableView), getVirtualFlow(tableRow));\n+    }\n+\n+\n+\/\/---------------- TableRowSkinBase (tested against TableRow)\n+\n+    \/**\n+     * NPE from listener in previous skin if not removed.\n+     *\/\n+    @Test\n+    public void testTableRowLeafColumnsListenerReplaceSkin() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        tableView.getColumns().get(0).setVisible(false);\n+        \/\/ note: the actual update happens only in layout, test the marker here\n+        assertTrue(\"dirty marker must have been set\", isDirty(tableRow));\n+    }\n+\n+    \/**\n+     * Sanity: child cells are updated on changing visible columns.\n+     *\/\n+    @Test\n+    public void testTableRowLeafColumnsListener() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        tableView.getColumns().get(0).setVisible(false);\n+        \/\/ note: the actual update happens only in layout, test the marker here\n+        assertTrue(\"dirty marker must have been set\", isDirty(tableRow));\n+    }\n+\n+    \/**\n+     *  NPE from listener in previous skin if not removed.\n+     *\/\n+    @Test\n+    public void testTableRowItemListenerReplaceSkin() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        int initial = 0;\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, initial);\n+        replaceSkin(tableRow);\n+        int index = 1;\n+        tableRow.updateIndex(index);\n+        List<IndexedCell<?>> cells = getCells(tableRow);\n+        assertEquals(tableView.getVisibleLeafColumns().size(), cells.size());\n+        assertEquals(\"cell index must be updated\", index, cells.get(0).getIndex());\n+    }\n+\n+    \/**\n+     * Sanity: child cell's index is updated\n+     *\/\n+    @Test\n+    public void testTableRowItemListener() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        int initial = 0;\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, initial);\n+        int index = 1;\n+        tableRow.updateIndex(index);\n+        Toolkit.getToolkit().firePulse();\n+        List<IndexedCell<?>> cells = getCells(tableRow);\n+        assertEquals(tableView.getVisibleLeafColumns().size(), cells.size());\n+        assertEquals(\"cell index must be updated\", index, cells.get(0).getIndex());\n+   }\n+\n+\/\/-------------- helpers for TableRow tests\n+\n+    private static final int COL_COUNT = 50;\n+    private static final int ROW_COUNT = 10;\n+    private static final double COL_WIDTH = 50;\n+    private static final double FIXED_CELL_SIZE = 24;\n+\n+    \/**\n+     * Creates and returns a table with many columns of width COL_WIDTH each,\n+     * setting the fixedCellSize of FIXED_CELL_SIZE if useFixedCellSize is true.\n+     *\/\n+    private TableView<String[]> createManyColumnsTableView(boolean useFixedCellSize) {\n+        final TableView<String[]> tableView = new TableView<>();\n+        final ObservableList<TableColumn<String[], ?>> columns = tableView\n+                .getColumns();\n+        tableView.getSelectionModel().setCellSelectionEnabled(true);\n+        for (int i = 0; i < COL_COUNT; i++) {\n+            TableColumn<String[], String> column = new TableColumn<>(\"Col\" + i);\n+            final int colIndex = i;\n+            column.setCellValueFactory((cell) -> new SimpleStringProperty(\n+                    cell.getValue()[colIndex]));\n+            columns.add(column);\n+            sizeColumn(column, COL_WIDTH);\n+        }\n+        ObservableList<String[]> items = tableView.getItems();\n+        for (int i = 0; i < ROW_COUNT; i++) {\n+            String[] rec = new String[COL_COUNT];\n+            for (int j = 0; j < rec.length; j++) {\n+                rec[j] = i + \":\" + j;\n+            }\n+            items.add(rec);\n+        }\n+        if (useFixedCellSize) {\n+            tableView.setFixedCellSize(FIXED_CELL_SIZE);\n+        }\n+\n+        return tableView;\n+    }\n+\n+    private void sizeColumn(TableColumnBase<?, ?> column, double width) {\n+        column.setPrefWidth(width);\n+        column.setMinWidth(width);\n+        column.setMaxWidth(width);\n+    }\n+\n+\n+    \/**\n+     * Creates and returns a TableRow configured to test\n+     * intalling\/switching its skin reliably.\n+     *\/\n+    private TableRow<?> createTableRow(int index) {\n+        TableView<Person> table = createPersonTable(true);\n+        TableRow<Person> tableRow = new TableRow<>();\n+        \/\/ note: must updateTable before updateIndex\n+        tableRow.updateTableView(table);\n+        tableRow.updateIndex(index);\n+        assertFalse(\"sanity: row must not be empty at index: \" + index, tableRow.isEmpty());\n+        return tableRow;\n+    }\n+\n+    \/**\n+     * Returns a table with two columns. Installs the default skin if\n+     * installSkin is true.\n+     *\/\n+    private TableView<Person> createPersonTable(boolean installSkin) {\n+        TableView<Person> table = new TableView<>(Person.persons());\n+        TableColumn<Person, String> firstName = new TableColumn<>(\"First Name\");\n+        firstName.setCellValueFactory(new PropertyValueFactory<>(\"firstName\"));\n+        TableColumn<Person, String> lastName = new TableColumn<>(\"Last Name\");\n+        lastName.setCellValueFactory(new PropertyValueFactory<>(\"lastName\"));\n+        table.getColumns().addAll(firstName, lastName);\n+        if (installSkin) {\n+            installDefaultSkin(table);\n+        }\n+        return table;\n+    }\n+\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/SkinCleanupTest.java","additions":769,"deletions":0,"binary":false,"changes":769,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-import javafx.scene.control.TableRow;\n@@ -63,1 +62,0 @@\n-import javafx.scene.control.TreeTableRow;\n@@ -147,1 +145,0 @@\n-                TableRow.class,\n@@ -149,1 +146,0 @@\n-                TreeTableRow.class,\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/SkinMemoryLeakTest.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}