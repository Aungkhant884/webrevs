{"files":[{"patch":"@@ -33,0 +33,2 @@\n+import com.sun.javafx.scene.control.behavior.TableRowBehavior;\n+\n@@ -36,11 +38,0 @@\n-import javafx.scene.control.Accordion;\n-import javafx.scene.control.Button;\n-import javafx.scene.control.TableCell;\n-import javafx.scene.control.TableColumn;\n-import javafx.scene.control.TablePosition;\n-import javafx.scene.control.TableRow;\n-import javafx.scene.control.TableView;\n-\n-import com.sun.javafx.scene.control.behavior.TableRowBehavior;\n-\n-import javafx.beans.property.ObjectProperty;\n@@ -52,0 +43,2 @@\n+import javafx.scene.control.TableCell;\n+import javafx.scene.control.TableColumn;\n@@ -53,0 +46,3 @@\n+import javafx.scene.control.TablePosition;\n+import javafx.scene.control.TableRow;\n+import javafx.scene.control.TableView;\n@@ -54,1 +50,1 @@\n-import javafx.scene.control.TreeTableView;\n+import javafx.scene.layout.Region;\n@@ -108,29 +104,0 @@\n-        setupTreeTableViewListeners();\n-    }\n-\n-    private void setupTreeTableViewListeners() {\n-        TableView<T> tableView = getSkinnable().getTableView();\n-        if (tableView == null) {\n-            getSkinnable().tableViewProperty().addListener(new InvalidationListener() {\n-                @Override public void invalidated(Observable observable) {\n-                    getSkinnable().tableViewProperty().removeListener(this);\n-                    setupTreeTableViewListeners();\n-                }\n-            });\n-        } else {\n-            DoubleProperty fixedCellSizeProperty = tableView.fixedCellSizeProperty();\n-            if (fixedCellSizeProperty != null) {\n-                registerChangeListener(fixedCellSizeProperty, e -> {\n-                    fixedCellSize = fixedCellSizeProperty.get();\n-                    fixedCellSizeEnabled = fixedCellSize > 0;\n-                });\n-                fixedCellSize = fixedCellSizeProperty.get();\n-                fixedCellSizeEnabled = fixedCellSize > 0;\n-\n-                \/\/ JDK-8144500:\n-                \/\/ When in fixed cell size mode, we must listen to the width of the virtual flow, so\n-                \/\/ that when it changes, we can appropriately add \/ remove cells that may or may not\n-                \/\/ be required (because we remove all cells that are not visible).\n-                registerChangeListener(getVirtualFlow().widthProperty(), e -> tableView.requestLayout());\n-            }\n-        }\n@@ -139,2 +106,0 @@\n-\n-\n@@ -210,0 +175,5 @@\n+    @Override\n+    double getFixedCellSize() {\n+        return getTableView() != null ? getTableView().getFixedCellSize() : Region.USE_COMPUTED_SIZE ;\n+    }\n+\n@@ -246,0 +216,1 @@\n+            registerChangeListener(getVirtualFlow().widthProperty(), e -> tableView.requestLayout());\n@@ -248,0 +219,6 @@\n+\n+    \/\/ test-only\n+    TableViewSkin<T> getTableViewSkin() {\n+        return tableViewSkin;\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableRowSkin.java","additions":20,"deletions":43,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -136,4 +136,0 @@\n-    double fixedCellSize;\n-    boolean fixedCellSizeEnabled;\n-\n-\n@@ -165,1 +161,1 @@\n-        getVisibleLeafColumns().addListener(weakVisibleLeafColumnsListener);\n+        registerListChangeListener(getVisibleLeafColumns(), c -> updateLeafColumns());\n@@ -171,1 +167,1 @@\n-        control.itemProperty().addListener(o -> requestCellUpdate());\n+        registerInvalidationListener(control.itemProperty(), o -> requestCellUpdate());\n@@ -191,1 +187,1 @@\n-    private ListChangeListener<TableColumnBase> visibleLeafColumnsListener = c -> {\n+    private void updateLeafColumns() {\n@@ -194,6 +190,1 @@\n-    };\n-\n-    private WeakListChangeListener<TableColumnBase> weakVisibleLeafColumnsListener =\n-            new WeakListChangeListener<>(visibleLeafColumnsListener);\n-\n-\n+    }\n@@ -347,1 +338,1 @@\n-            if (fixedCellSizeEnabled) {\n+            if (isFixedCellSizeEnabled()) {\n@@ -359,1 +350,1 @@\n-                height = fixedCellSize;\n+                height = getFixedCellSize();\n@@ -366,1 +357,1 @@\n-                if (fixedCellSizeEnabled && tableCell.getParent() == null) {\n+                if (isFixedCellSizeEnabled() && tableCell.getParent() == null) {\n@@ -445,1 +436,1 @@\n-                if (fixedCellSizeEnabled) {\n+                if (isFixedCellSizeEnabled()) {\n@@ -544,1 +535,1 @@\n-        if (fixedCellSizeEnabled) {\n+        if (isFixedCellSizeEnabled()) {\n@@ -583,2 +574,2 @@\n-        if (fixedCellSizeEnabled) {\n-            return fixedCellSize;\n+        if (isFixedCellSizeEnabled()) {\n+            return getFixedCellSize();\n@@ -613,2 +604,2 @@\n-        if (fixedCellSizeEnabled) {\n-            return fixedCellSize;\n+        if (isFixedCellSizeEnabled()) {\n+            return getFixedCellSize();\n@@ -641,2 +632,2 @@\n-        if (fixedCellSizeEnabled) {\n-            return fixedCellSize;\n+        if (isFixedCellSizeEnabled()) {\n+            return getFixedCellSize();\n@@ -647,0 +638,12 @@\n+    \/**\n+     * Returns the fixedCellSize of the row's control.\n+     *\/\n+    abstract double getFixedCellSize();\n+\n+    \/**\n+     * Returns true if fixedCellSize is greater than 0, false otherwise.\n+     *\/\n+    boolean isFixedCellSizeEnabled() {\n+        return getFixedCellSize() > 0;\n+    }\n+\n@@ -658,0 +661,4 @@\n+    \/\/ test-only\n+    boolean isDirty() {\n+        return isDirty;\n+    }\n@@ -659,0 +666,4 @@\n+    \/\/ test-only\n+    void setDirty(boolean dirty) {\n+        isDirty = dirty;\n+    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableRowSkinBase.java","additions":35,"deletions":24,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import javafx.beans.InvalidationListener;\n-import javafx.beans.Observable;\n@@ -59,1 +57,1 @@\n-import javafx.scene.control.TreeView;\n+import javafx.scene.layout.Region;\n@@ -120,37 +118,0 @@\n-        setupTreeTableViewListeners();\n-    }\n-\n-    private void setupTreeTableViewListeners() {\n-        TreeTableView<T> treeTableView = getSkinnable().getTreeTableView();\n-        if (treeTableView == null) {\n-            getSkinnable().treeTableViewProperty().addListener(new InvalidationListener() {\n-                @Override public void invalidated(Observable observable) {\n-                    getSkinnable().treeTableViewProperty().removeListener(this);\n-                    setupTreeTableViewListeners();\n-                }\n-            });\n-        } else {\n-            registerChangeListener(treeTableView.treeColumnProperty(), e -> {\n-                \/\/ Fix for RT-27782: Need to set isDirty to true, rather than the\n-                \/\/ cheaper updateCells, as otherwise the text indentation will not\n-                \/\/ be recalculated in TreeTableCellSkin.leftLabelPadding()\n-                isDirty = true;\n-                getSkinnable().requestLayout();\n-            });\n-\n-            DoubleProperty fixedCellSizeProperty = getTreeTableView().fixedCellSizeProperty();\n-            if (fixedCellSizeProperty != null) {\n-                registerChangeListener(fixedCellSizeProperty, e -> {\n-                    fixedCellSize = fixedCellSizeProperty.get();\n-                    fixedCellSizeEnabled = fixedCellSize > 0;\n-                });\n-                fixedCellSize = fixedCellSizeProperty.get();\n-                fixedCellSizeEnabled = fixedCellSize > 0;\n-\n-                \/\/ JDK-8144500:\n-                \/\/ When in fixed cell size mode, we must listen to the width of the virtual flow, so\n-                \/\/ that when it changes, we can appropriately add \/ remove cells that may or may not\n-                \/\/ be required (because we remove all cells that are not visible).\n-                registerChangeListener(getVirtualFlow().widthProperty(), e -> treeTableView.requestLayout());\n-            }\n-        }\n@@ -166,1 +127,1 @@\n-    private final InvalidationListener graphicListener = o -> {\n+    private void updateTreeItemGraphic() {\n@@ -169,2 +130,1 @@\n-    };\n-\n+    }\n@@ -256,1 +216,0 @@\n-\n@@ -263,0 +222,5 @@\n+    @Override\n+    double getFixedCellSize() {\n+        return getTreeTableView() != null ? getTreeTableView().getFixedCellSize() : Region.USE_COMPUTED_SIZE ;\n+    }\n+\n@@ -335,1 +299,1 @@\n-        if (treeTableRow == null) return null;\n+        \/\/ FIXME: illegal access if skinnable is null\n@@ -342,3 +306,1 @@\n-        if (treeItem != null) {\n-            treeItem.graphicProperty().removeListener(graphicListener);\n-        }\n+        unregisterInvalidationListeners(graphicProperty());\n@@ -346,3 +308,1 @@\n-        if (treeItem != null) {\n-            treeItem.graphicProperty().addListener(graphicListener);\n-        }\n+        registerInvalidationListener(graphicProperty(), e -> updateTreeItemGraphic());\n@@ -401,0 +361,9 @@\n+        if (tableView != null) {\n+            registerChangeListener(tableView.treeColumnProperty(), e -> {\n+                \/\/ Fix for RT-27782: Need to set isDirty to true, rather than the\n+                \/\/ cheaper updateCells, as otherwise the text indentation will not\n+                \/\/ be recalculated in TreeTableCellSkin.leftLabelPadding()\n+                isDirty = true;\n+                getSkinnable().requestLayout();\n+            });\n+        }\n@@ -403,0 +372,1 @@\n+            registerChangeListener(getVirtualFlow().widthProperty(), e -> tableView.requestLayout());\n@@ -406,0 +376,9 @@\n+    \/\/ test-only\n+    TreeTableViewSkin<T> getTableViewSkin() {\n+        return treeTableViewSkin;\n+    }\n+\n+    \/\/ test-only\n+    TreeItem<T> getTreeItem() {\n+        return (TreeItem<T>) treeItem;\n+    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TreeTableRowSkin.java","additions":30,"deletions":51,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -29,0 +29,4 @@\n+import java.util.function.Consumer;\n+\n+import javafx.beans.value.ObservableValue;\n+import javafx.collections.ObservableList;\n@@ -37,1 +41,1 @@\n-    \/\/--------------- statics --------------\n+\/\/--------------- statics --------------\n@@ -42,0 +46,15 @@\n+\n+\/\/-------------- access listener api\n+\n+    public static Consumer<ObservableValue<?>> unregisterChangeListeners(SkinBase skin, ObservableValue<?> ov) {\n+        return skin.unregisterChangeListeners(ov);\n+    }\n+\n+    public static Consumer<ObservableValue<?>> unregisterInvalidationListeners(SkinBase skin, ObservableValue<?> ov) {\n+        return skin.unregisterChangeListeners(ov);\n+    }\n+\n+    public static Consumer<ObservableList<?>> unregisterListChangeListeners(SkinBase skin, ObservableList<?> ov) {\n+        return skin.unregisterListChangeListeners(ov);\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/shims\/java\/javafx\/scene\/control\/SkinBaseShim.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.scene.control.skin;\n+\n+import java.util.List;\n+\n+import javafx.beans.property.ObjectProperty;\n+import javafx.collections.ObservableList;\n+import javafx.scene.Node;\n+import javafx.scene.control.IndexedCell;\n+import javafx.scene.control.TableCell;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TableRow;\n+import javafx.scene.control.TableView;\n+import javafx.scene.control.TreeItem;\n+import javafx.scene.control.TreeTableRow;\n+import javafx.scene.control.TreeTableView;\n+\n+\/**\n+ * Utility methods to access package-private api in Table-related skins.\n+ *\/\n+public class TableSkinShim {\n+\n+    \/**\n+     * Returns the TableHeaderRow of the skin's table if that is of type TableViewSkinBase\n+     * or null if not.\n+     *\n+     * @param <T>\n+     * @param table the table to get the TableHeaderRow from\n+     * @return the tableHeaderRow of the table's skin or null if the skin not of type\n+     *    TableViewSkinBase\n+     *\/\n+    public static <T> TableHeaderRow getTableHeaderRow(TableView<T> table) {\n+        if (table.getSkin() instanceof TableViewSkinBase) {\n+            return getTableHeaderRow((TableViewSkinBase) table.getSkin());\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns the TableHeaderRow of the given skin.\n+     *\n+     * @param <T>\n+     * @param skin the skin to get the TableHeaderRow from\n+     * @return\n+     * @throws NullPointerException if skin is null\n+     *\/\n+    public static <T> TableHeaderRow getTableHeaderRow(TableViewSkinBase skin) {\n+        return skin.getTableHeaderRow();\n+    }\n+\n+    \/**\n+     * Returns the TableColumnHeader for the given column or null if not available.\n+     *\n+     * @param <T>\n+     * @param column\n+     * @return\n+     *\/\n+    public static <T> TableColumnHeader getColumnHeaderFor(TableColumn<T, ?> column) {\n+        TableView<T> table = column.getTableView();\n+        TableHeaderRow tableHeader = getTableHeaderRow(table);\n+        if (tableHeader != null) {\n+            return tableHeader.getColumnHeaderFor(column);\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns the VirtualFlow from the table's skin which must be of type\n+     * TableViewSkin.\n+     *\/\n+    public static VirtualFlow<?> getVirtualFlow(TableView<?> table) {\n+        TableViewSkin<?> skin = (TableViewSkin<?>) table.getSkin();\n+        return skin.getVirtualFlow();\n+    }\n+\n+    \/**\n+     * Returns the VirtualFlow from the table's skin which must be of type\n+     * TreeTableViewSkin.\n+     *\/\n+    public static VirtualFlow<?> getVirtualFlow(TreeTableView<?> table) {\n+        TreeTableViewSkin<?> skin = (TreeTableViewSkin<?>) table.getSkin();\n+        return skin.getVirtualFlow();\n+    }\n+\n+\/\/    public static <T> TableRow<T> getCell(TableView<T> table, int index) {\n+\/\/        VirtualFlow flow = getVirtualFlow(table);\n+\/\/        return (TableRow<T>) flow.getCell(index);\n+\/\/    }\n+\/\/\n+\/\/    public static <T> TreeTableRow<T> getCell(TreeTableView<T> table, int index) {\n+\/\/        VirtualFlow flow = getVirtualFlow(table);\n+\/\/        return (TreeTableRow<T>) flow.getCell(index);\n+\/\/    }\n+\/\/----------------- Tree\/TableRowSkin state\n+\n+    public static <T> boolean isFixedCellSizeEnabled(TableRow<T> tableRow) {\n+        TableRowSkin<T> skin = (TableRowSkin<T>) tableRow.getSkin();\n+        return skin.isFixedCellSizeEnabled();\n+    }\n+\n+    public static <T> boolean isFixedCellSizeEnabled(TreeTableRow<T> tableRow) {\n+        TreeTableRowSkin<T> skin = (TreeTableRowSkin<T>) tableRow.getSkin();\n+        return skin.isFixedCellSizeEnabled();\n+    }\n+\n+    public static <T> boolean isDirty(TableRow<T> tableRow) {\n+        TableRowSkin<T> skin = (TableRowSkin<T>) tableRow.getSkin();\n+        return skin.isDirty();\n+    }\n+\n+    public static <T> boolean isDirty(TreeTableRow<T> tableRow) {\n+        TreeTableRowSkin<T> skin = (TreeTableRowSkin<T>) tableRow.getSkin();\n+        return skin.isDirty();\n+    }\n+\n+    public static <T> void setDirty(TableRow<T> tableRow, boolean dirty) {\n+        TableRowSkin<T> skin = (TableRowSkin<T>) tableRow.getSkin();\n+        skin.setDirty(dirty);\n+    }\n+\n+    public static <T> ObservableList<TableColumn<T, ?>> getVisibleLeafColumns(TableRow<T> tableRow) {\n+        TableRowSkin<T> skin = (TableRowSkin<T>) tableRow.getSkin();\n+        return skin.getVisibleLeafColumns();\n+    }\n+\n+    public static <T> TableViewSkin<T> getTableViewSkin(TableRow<T> tableRow) {\n+        TableRowSkin<T> skin = (TableRowSkin<T>) tableRow.getSkin();\n+        return skin.getTableViewSkin();\n+    }\n+\n+    public static <T> TreeTableViewSkin<T> getTableViewSkin(TreeTableRow<T> tableRow) {\n+        TreeTableRowSkin<T> skin = (TreeTableRowSkin<T>) tableRow.getSkin();\n+        return skin.getTableViewSkin();\n+    }\n+\n+    public static <T> TreeItem<T> getTreeItem(TreeTableRow<T> tableRow) {\n+        TreeTableRowSkin<T> skin = (TreeTableRowSkin<T>) tableRow.getSkin();\n+        return skin.getTreeItem();\n+    }\n+\n+    public static <T> ObjectProperty<Node> graphicProperty(TreeTableRow<T> tableRow) {\n+        TreeTableRowSkin<T> skin = (TreeTableRowSkin<T>) tableRow.getSkin();\n+        return skin.graphicProperty();\n+    }\n+\n+\n+    public static <T> VirtualFlow<?> getVirtualFlow(TableRow<T> table) {\n+        TableRowSkin<T> skin = (TableRowSkin<T>) table.getSkin();\n+        return skin.getVirtualFlow();\n+    }\n+\n+    public static <T> VirtualFlow<?> getVirtualFlow(TreeTableRow<T> table) {\n+        TreeTableRowSkin<T> skin = (TreeTableRowSkin<T>) table.getSkin();\n+        return skin.getVirtualFlow();\n+    }\n+\n+    public static List<IndexedCell<?>> getCells(TableRow tableRow) {\n+        TableRowSkin skin = (TableRowSkin) tableRow.getSkin();\n+        return skin.cells;\n+    }\n+\n+    public static List<IndexedCell<?>> getCells(TreeTableRow<?> tableRow) {\n+        TreeTableRowSkin skin = (TreeTableRowSkin) tableRow.getSkin();\n+        return skin.cells;\n+    }\n+\n+\n+\n+}\n","filename":"modules\/javafx.controls\/src\/shims\/java\/javafx\/scene\/control\/skin\/TableSkinShim.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -33,0 +33,2 @@\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n@@ -110,0 +112,10 @@\n+\n+    public static ObservableList<Person> persons() {\n+        return FXCollections.observableArrayList(\n+                new Person(\"Jacob\", \"Smith\", \"jacob.smith@example.com\"),\n+                new Person(\"Isabella\", \"Johnson\", \"isabella.johnson@example.com\"),\n+                new Person(\"Ethan\", \"Williams\", \"ethan.williams@example.com\"),\n+                new Person(\"Emma\", \"Jones\", \"emma.jones@example.com\"),\n+                new Person(\"Michael\", \"Brown\", \"michael.brown@example.com\")\n+                );\n+    }\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/control\/test\/Person.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.stream.Collectors;\n@@ -40,0 +41,3 @@\n+import static javafx.scene.control.SkinBaseShim.*;\n+import static javafx.scene.control.skin.TableSkinShim.*;\n+import static javafx.scene.control.skin.TableSkinShim.getVirtualFlow;\n@@ -43,0 +47,1 @@\n+import static test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils.*;\n@@ -51,0 +56,2 @@\n+import javafx.scene.control.IndexedCell;\n+import javafx.scene.control.Label;\n@@ -56,0 +63,3 @@\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TableRow;\n+import javafx.scene.control.TableView;\n@@ -61,0 +71,3 @@\n+import javafx.scene.control.TreeTableColumn;\n+import javafx.scene.control.TreeTableRow;\n+import javafx.scene.control.TreeTableView;\n@@ -62,0 +75,5 @@\n+import javafx.scene.control.cell.PropertyValueFactory;\n+import javafx.scene.control.cell.TreeItemPropertyValueFactory;\n+import javafx.scene.control.skin.TableRowSkin;\n+import javafx.scene.control.skin.TreeTableRowSkin;\n+import javafx.scene.control.skin.VirtualFlow;\n@@ -70,0 +88,1 @@\n+import test.com.sun.javafx.scene.control.test.Person;\n@@ -80,0 +99,576 @@\n+\/\/------------- TreeTableRow\n+\n+    \/**\n+     * Sanity test: child cells are updated on changing visible columns.\n+     *\/\n+    @Test\n+    public void testTreeTableRowTreeColumnListenerReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        tableView.setTreeColumn(tableView.getColumns().get(1));\n+        \/\/ note: the actual update happens only in layout, test the marker here\n+        assertTrue(\"dirty marker must have been set\", isDirty(tableRow));\n+    }\n+\n+    \/**\n+     * Sanity test: child cells are updated on changing visible columns.\n+     *\/\n+    @Test\n+    public void testTreeTableRowTreeColumnListener() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        tableView.setTreeColumn(tableView.getColumns().get(1));\n+        \/\/ note: the actual update happens only in layout, test the marker here\n+        assertTrue(\"dirty marker must have been set\", isDirty(tableRow));\n+    }\n+\n+    @Test\n+    public void testTreeTableRowGraphicListenerReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        int index = 1;\n+        Label graphic = new Label(\"dummy\");\n+        TreeItem<Person> treeItem = tableView.getTreeItem(index);\n+        treeItem.setGraphic(graphic);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, index);\n+        replaceSkin(tableView);\n+        \/\/ note: need an actual layout to update the children here, firePulse in _not_ enough\n+        tableRow.layout();\n+        assertEquals(index, tableRow.getIndex());\n+        assertTrue(tableRow.getChildrenUnmodifiable().contains(graphic));\n+    }\n+\n+    \/**\n+     * Sanity test: row graphic is updated on changing treeItem's graphic.\n+     *\/\n+    @Test\n+    public void testTreeTableRowGraphicListener() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        int index = 1;\n+        Label graphic = new Label(\"dummy\");\n+        tableView.getTreeItem(index).setGraphic(graphic);\n+        Toolkit.getToolkit().firePulse();\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, index);\n+        assertTrue(tableRow.getChildrenUnmodifiable().contains(graphic));\n+    }\n+\n+    @Test\n+    public void testTreeTableRowFixedCellSizeReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        double fixed = 200;\n+        tableView.setFixedCellSize(fixed);\n+        assertEquals(\"fixed cell size: \", fixed, tableRow.prefHeight(-1), 1);\n+    }\n+\n+    \/**\n+     * Sanity test: row respects fixedCellSize.\n+     *\/\n+    @Test\n+    public void testTreeTableRowFixedCellSize() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        double fixed = 200;\n+        tableView.setFixedCellSize(fixed);\n+        assertEquals(\"fixed cell size: \", fixed, tableRow.prefHeight(-1), 1);\n+    }\n+\n+    @Test\n+    public void testTreeTableRowFixedCellSizeEnabledReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        assertFalse(\"fixed cell size disabled initially\", isFixedCellSizeEnabled(tableRow));\n+        double fixed = 200;\n+        tableView.setFixedCellSize(fixed);\n+        assertTrue(\"fixed cell size enabled\", isFixedCellSizeEnabled(tableRow));\n+    }\n+\n+    \/**\n+     * Sanity test: fixedCellSizeEnabled.\n+     *\/\n+    @Test\n+    public void testTreeTableRowFixedCellSizeEnabled() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        assertFalse(\"fixed cell size disabled initially\", isFixedCellSizeEnabled(tableRow));\n+        double fixed = 200;\n+        tableView.setFixedCellSize(fixed);\n+        assertTrue(\"fixed cell size enabled\", isFixedCellSizeEnabled(tableRow));\n+    }\n+\n+    @Test\n+    public void testTreeTableRowVirtualFlowWidthListenerReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        VirtualFlow<?> flow = getVirtualFlow(tableView);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        Toolkit.getToolkit().firePulse();\n+        TreeTableRowSkin<?> rowSkin = (TreeTableRowSkin<?>) tableRow.getSkin();\n+        assertNotNull(\"row skin must have listener to virtualFlow width\",\n+                unregisterChangeListeners(rowSkin, flow.widthProperty()));\n+    }\n+\n+    \/**\n+     * Sanity: listener to flow's width is registered.\n+     *\/\n+    @Test\n+    public void testTreeTableRowVirtualFlowWidthListener() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        VirtualFlow<?> flow = getVirtualFlow(tableView);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        TreeTableRowSkin<?> rowSkin = (TreeTableRowSkin<?>) tableRow.getSkin();\n+        assertNotNull(\"row skin must have listener to virtualFlow width\",\n+                unregisterChangeListeners(rowSkin, flow.widthProperty()));\n+    }\n+\n+    \/**\n+     * Sanity: children don't pile up with fixedCellSize.\n+     *\/\n+    @Test\n+    public void testTreeTableRowChildCountFixedCellSizeReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        tableView.setFixedCellSize(100);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 0);\n+        int childCount = tableRow.getChildrenUnmodifiable().size();\n+        replaceSkin(tableRow);\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(childCount, tableRow.getChildrenUnmodifiable().size());\n+    }\n+\n+    \/**\n+     * Sanity: children don't pile up.\n+     *\/\n+    @Test\n+    public void testTreeTableRowChildCountReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 0);\n+        int childCount = tableRow.getChildrenUnmodifiable().size();\n+        replaceSkin(tableRow);\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(childCount, tableRow.getChildrenUnmodifiable().size());\n+    }\n+\n+    @Test\n+    public void testTreeTableRowVirtualFlowReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        assertEquals(tableView.getSkin(), getTableViewSkin(tableRow));\n+        assertEquals(getVirtualFlow(tableView), getVirtualFlow(tableRow));\n+    }\n+\n+    \/**\n+     * Sanity: invariants of skin\/flow in rowSkin\n+     *\/\n+    @Test\n+    public void testTreeTableRowVirtualFlow() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        assertEquals(tableView.getSkin(), getTableViewSkin(tableRow));\n+        assertEquals(getVirtualFlow(tableView), getVirtualFlow(tableRow));\n+    }\n+\n+    \/**\n+     * Here we configure a tableRow with table and install the row's skin.\n+     *\/\n+    @Ignore(\"JDK-8274065\")\n+    @Test\n+    public void testTreeTableRowVirtualFlowInstallSkin() {\n+        TreeTableRow<?> tableRow = createTreeTableRow(1);\n+        installDefaultSkin(tableRow);\n+        TreeTableView<?> tableView = tableRow.getTreeTableView();\n+        assertEquals(tableView.getSkin(), getTableViewSkin(tableRow));\n+        assertEquals(getVirtualFlow(tableView), getVirtualFlow(tableRow));\n+    }\n+\n+    @Test\n+    public void testTreeTableRowWithGraphicMemoryLeak() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        tableView.getTreeItem(1).setGraphic(new Label(\"nothing\"));\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        WeakReference<?> weakRef = new WeakReference<>(replaceSkin(tableRow));\n+        assertNotNull(weakRef.get());\n+        attemptGC(weakRef);\n+        assertEquals(\"Skin must be gc'ed\", null, weakRef.get());\n+    }\n+\n+    \/**\n+     * Fails in install skin NPE\n+     *\/\n+    @Ignore(\"JDK-8274065\")\n+    @Test\n+    public void testTreeTableRowWithGraphicMemoryLeakInstallSkin() {\n+        TreeTableRow<?> tableRow = createTreeTableRow(1);\n+        installDefaultSkin(tableRow);\n+        tableRow.getTreeTableView().getTreeItem(1).setGraphic(new Label(\"nothing\"));\n+        WeakReference<?> weakRef = new WeakReference<>(replaceSkin(tableRow));\n+        assertNotNull(weakRef.get());\n+        attemptGC(weakRef);\n+        assertEquals(\"Skin must be gc'ed\", null, weakRef.get());\n+    }\n+\n+\n+\/\/--- TableRowSkinBase (tested against TreeTableRow)\n+\n+    \/**\n+     * NPE from listener in previous skin if not removed.\n+     *\/\n+    @Test\n+    public void testTreeTableRowLeafColumnsListenerReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        tableView.getColumns().get(0).setVisible(false);\n+        assertTrue(\"dirty marker must have been set\", isDirty(tableRow));\n+    }\n+\n+    \/**\n+     * Sanity test: child cells are updated on changing visible columns.\n+     *\/\n+    @Test\n+    public void testTreeTableRowLeafColumnsListener() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, 1);\n+        tableView.getColumns().get(0).setVisible(false);\n+        assertTrue(\"dirty marker must have been set\", isDirty(tableRow));\n+    }\n+\n+    \/**\n+     *  NPE from listener in previous skin if not removed.\n+     *\/\n+    @Test\n+    public void testTreeTableRowItemListenerReplaceSkin() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        int initial = 0;\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, initial);\n+        replaceSkin(tableRow);\n+        int index = 1;\n+        tableRow.updateIndex(index);\n+        List<IndexedCell<?>> cells = getCells(tableRow);\n+        assertEquals(tableView.getVisibleLeafColumns().size(), cells.size());\n+        assertEquals(\"cell index must be updated\", index, cells.get(0).getIndex());\n+    }\n+\n+    \/**\n+     * Sanity test: child cell's index is updated\n+     *\/\n+    @Test\n+    public void testTreeTableRowItemListener() {\n+        TreeTableView<Person> tableView = createPersonTreeTable(false);\n+        showControl(tableView, true);\n+        int initial = 0;\n+        TreeTableRow<?> tableRow = (TreeTableRow<?>) getCell(tableView, initial);\n+        int index = 1;\n+        tableRow.updateIndex(index);\n+        List<IndexedCell<?>> cells = getCells(tableRow);\n+        assertEquals(tableView.getVisibleLeafColumns().size(), cells.size());\n+        assertEquals(\"cell index must be updated\", index, cells.get(0).getIndex());\n+   }\n+\n+\n+\/\/-------------- helpers for TreeTableRow tests\n+\n+    \/**\n+     * Creates and returns a TreeTableRow configured to test\n+     * intalling\/switching its skin reliably.\n+     *\n+     * - must be configure with a TableView that has a skin\n+     * - must not be empty\n+     *\/\n+    private TreeTableRow<?> createTreeTableRow(int index) {\n+        TreeTableView<Person> table = createPersonTreeTable(true);\n+        TreeTableRow<Person> tableRow = new TreeTableRow<>();\n+        \/\/ note: must updateTable before updateIndex\n+        tableRow.updateTreeTableView(table);\n+        tableRow.updateIndex(index);\n+        assertFalse(\"sanity: row must not be empty at index: \" + index, tableRow.isEmpty());\n+        return tableRow;\n+    }\n+\n+    \/**\n+     * Returns a table with two columns. Installs the default skin if\n+     * installSkin is true.\n+     *\/\n+    private TreeTableView<Person> createPersonTreeTable(boolean installSkin) {\n+        TreeItem<Person> root = new TreeItem<>(new Person(\"rootFirst\", \"rootLast\", \"root@nowhere.com\"));\n+        root.setExpanded(true);\n+        root.getChildren().addAll(\n+                Person.persons().stream()\n+                .map(TreeItem::new)\n+                .collect(Collectors.toList()));\n+        TreeTableView<Person> table = new TreeTableView<>(root);\n+        assertEquals(Person.persons().size() + 1, table.getExpandedItemCount());\n+        TreeTableColumn<Person, String> firstName = new TreeTableColumn<>(\"First Name\");\n+        firstName.setCellValueFactory(new TreeItemPropertyValueFactory<>(\"firstName\"));\n+        TreeTableColumn<Person, String> lastName = new TreeTableColumn<>(\"Last Name\");\n+        lastName.setCellValueFactory(new TreeItemPropertyValueFactory<>(\"lastName\"));\n+        table.getColumns().addAll(firstName, lastName);\n+        if (installSkin) {\n+            installDefaultSkin(table);\n+        }\n+        return table;\n+    }\n+\n+\/\/--------------------- TableRowSkin\n+\n+    @Test\n+    public void testTableRowFixedCellSizeReplaceSkin() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        double fixed = 200;\n+        tableView.setFixedCellSize(fixed);\n+        assertEquals(\"fixed cell size: \", fixed, tableRow.prefHeight(-1), 1);\n+    }\n+\n+    \/**\n+     * Sanity test: row respects fixedCellSize.\n+     *\/\n+    @Test\n+    public void testTableRowFixedCellSize() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        double fixed = 200;\n+        tableView.setFixedCellSize(fixed);\n+        assertEquals(\"fixed cell size: \", fixed, tableRow.prefHeight(-1), 1);\n+    }\n+\n+    @Test\n+    public void testTableRowFixedCellSizeEnabledReplaceSkin() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        assertFalse(\"fixed cell size disabled initially\", isFixedCellSizeEnabled(tableRow));\n+        double fixed = 200;\n+        tableView.setFixedCellSize(fixed);\n+        assertTrue(\"fixed cell size enabled\", isFixedCellSizeEnabled(tableRow));\n+    }\n+\n+    \/**\n+     * Sanity test: fixedCellSizeEnabled.\n+     *\/\n+    @Test\n+    public void testTableRowFixedCellSizeEnabled() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        assertFalse(\"fixed cell size disabled initially\", isFixedCellSizeEnabled(tableRow));\n+        double fixed = 200;\n+        tableView.setFixedCellSize(fixed);\n+        assertTrue(\"fixed cell size enabled\", isFixedCellSizeEnabled(tableRow));\n+    }\n+\n+    @Test\n+    public void testTableRowVirtualFlowWidthListenerReplaceSkin() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        VirtualFlow<?> flow = getVirtualFlow(tableView);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        Toolkit.getToolkit().firePulse();\n+        TableRowSkin<?> rowSkin = (TableRowSkin<?>) tableRow.getSkin();\n+        assertNotNull(\"row skin must have listener to virtualFlow width\",\n+                unregisterChangeListeners(rowSkin, flow.widthProperty()));\n+    }\n+\n+    \/**\n+     * Sanity test: listener to flow's width is registered.\n+     *\/\n+    @Test\n+    public void testTableRowVirtualFlowWidthListener() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        VirtualFlow<?> flow = getVirtualFlow(tableView);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        TableRowSkin<?> rowSkin = (TableRowSkin<?>) tableRow.getSkin();\n+        assertNotNull(\"row skin must have listener to virtualFlow width\",\n+                unregisterChangeListeners(rowSkin, flow.widthProperty()));\n+    }\n+\n+    \/**\n+     * Sanity: children don't pile up with fixed cell size.\n+     *\/\n+    @Test\n+    public void testTableRowChildCountFixedCellSizeReplaceSkin() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        tableView.setFixedCellSize(100);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 0);\n+        int childCount = tableRow.getChildrenUnmodifiable().size();\n+        assertEquals(2, childCount);\n+        replaceSkin(tableRow);\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(childCount, tableRow.getChildrenUnmodifiable().size());\n+    }\n+\n+    \/**\n+     * Sanity: children don't pile up.\n+     *\/\n+    @Test\n+    public void testTableRowChildCountReplaceSkin() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 0);\n+        int childCount = tableRow.getChildrenUnmodifiable().size();\n+        assertEquals(2, childCount);\n+        replaceSkin(tableRow);\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(childCount, tableRow.getChildrenUnmodifiable().size());\n+    }\n+\n+    @Test\n+    public void testTableRowVirtualFlowReplaceSkin() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        assertEquals(tableView.getSkin(), getTableViewSkin(tableRow));\n+        assertEquals(getVirtualFlow(tableView), getVirtualFlow(tableRow));\n+    }\n+\n+    \/**\n+     * Sanity: invariants of skin\/flow in rowSkin\n+     *\/\n+    @Test\n+    public void testTableRowVirtualFlow() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        assertEquals(tableView.getSkin(), getTableViewSkin(tableRow));\n+        assertEquals(getVirtualFlow(tableView), getVirtualFlow(tableRow));\n+    }\n+\n+    \/**\n+     * Here we configure a tableRow with table and install the row's skin.\n+     *\/\n+    @Ignore(\"JDK-8274065\")\n+    @Test\n+    public void testTableRowVirtualFlowInstallSkin() {\n+        TableRow<?> tableRow = createTableRow(0);\n+        installDefaultSkin(tableRow);\n+        TableView<?> tableView = tableRow.getTableView();\n+        assertEquals(tableView.getSkin(), getTableViewSkin(tableRow));\n+        assertEquals(getVirtualFlow(tableView), getVirtualFlow(tableRow));\n+    }\n+\n+\n+\/\/---------------- TableRowSkinBase (tested against TableRow)\n+\n+    \/**\n+     * NPE from listener in previous skin if not removed.\n+     *\/\n+    @Test\n+    public void testTableRowLeafColumnsListenerReplaceSkin() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        replaceSkin(tableRow);\n+        tableView.getColumns().get(0).setVisible(false);\n+        \/\/ note: the actual update happens only in layout, test the marker here\n+        assertTrue(\"dirty marker must have been set\", isDirty(tableRow));\n+    }\n+\n+    \/**\n+     * Sanity: child cells are updated on changing visible columns.\n+     *\/\n+    @Test\n+    public void testTableRowLeafColumnsListener() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, 1);\n+        tableView.getColumns().get(0).setVisible(false);\n+        \/\/ note: the actual update happens only in layout, test the marker here\n+        assertTrue(\"dirty marker must have been set\", isDirty(tableRow));\n+    }\n+\n+    \/**\n+     *  NPE from listener in previous skin if not removed.\n+     *\/\n+    @Test\n+    public void testTableRowItemListenerReplaceSkin() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        int initial = 0;\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, initial);\n+        replaceSkin(tableRow);\n+        int index = 1;\n+        tableRow.updateIndex(index);\n+        List<IndexedCell<?>> cells = getCells(tableRow);\n+        assertEquals(tableView.getVisibleLeafColumns().size(), cells.size());\n+        assertEquals(\"cell index must be updated\", index, cells.get(0).getIndex());\n+    }\n+\n+    \/**\n+     * Sanity: child cell's index is updated\n+     *\/\n+    @Test\n+    public void testTableRowItemListener() {\n+        TableView<Person> tableView = createPersonTable(false);\n+        showControl(tableView, true);\n+        int initial = 0;\n+        TableRow<?> tableRow = (TableRow<?>) getCell(tableView, initial);\n+        int index = 1;\n+        tableRow.updateIndex(index);\n+        Toolkit.getToolkit().firePulse();\n+        List<IndexedCell<?>> cells = getCells(tableRow);\n+        assertEquals(tableView.getVisibleLeafColumns().size(), cells.size());\n+        assertEquals(\"cell index must be updated\", index, cells.get(0).getIndex());\n+   }\n+\n+\/\/-------------- helpers for TableRow tests\n+\n+    \/**\n+     * Creates and returns a TableRow configured to test\n+     * intalling\/switching its skin reliably.\n+     *\/\n+    private TableRow<?> createTableRow(int index) {\n+        TableView<Person> table = createPersonTable(true);\n+        TableRow<Person> tableRow = new TableRow<>();\n+        \/\/ note: must updateTable before updateIndex\n+        tableRow.updateTableView(table);\n+        tableRow.updateIndex(index);\n+        assertFalse(\"sanity: row must not be empty at index: \" + index, tableRow.isEmpty());\n+        return tableRow;\n+    }\n+\n+    \/**\n+     * Returns a table with two columns. Installs the default skin if\n+     * installSkin is true.\n+     *\/\n+    private TableView<Person> createPersonTable(boolean installSkin) {\n+        TableView<Person> table = new TableView<>(Person.persons());\n+        TableColumn<Person, String> firstName = new TableColumn<>(\"First Name\");\n+        firstName.setCellValueFactory(new PropertyValueFactory<>(\"firstName\"));\n+        TableColumn<Person, String> lastName = new TableColumn<>(\"Last Name\");\n+        lastName.setCellValueFactory(new PropertyValueFactory<>(\"lastName\"));\n+        table.getColumns().addAll(firstName, lastName);\n+        if (installSkin) {\n+            installDefaultSkin(table);\n+        }\n+        return table;\n+    }\n+\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/SkinCleanupTest.java","additions":595,"deletions":0,"binary":false,"changes":595,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-import javafx.scene.control.TableRow;\n@@ -63,1 +62,0 @@\n-import javafx.scene.control.TreeTableRow;\n@@ -147,1 +145,0 @@\n-                TableRow.class,\n@@ -149,1 +146,0 @@\n-                TreeTableRow.class,\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/SkinMemoryLeakTest.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}