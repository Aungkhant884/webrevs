{"files":[{"patch":"@@ -209,0 +209,4 @@\n+            \/\/ The pixel scale factors must be set to the rttGraphics, otherwise the position\n+            \/\/ of the lights will not be scaled correctly on retina displays\n+            \/\/ See https:\/\/bugs.openjdk.java.net\/browse\/JDK-8255015\n+            rttGraphics.setPixelScaleFactors(g.getPixelScaleFactorX(), g.getPixelScaleFactorY());\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/sg\/prism\/NGSubScene.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.robot.test3d;\n+\n+import static org.junit.Assume.assumeTrue;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import javafx.application.ConditionalFeature;\n+import javafx.application.Platform;\n+import javafx.scene.Group;\n+import javafx.scene.PerspectiveCamera;\n+import javafx.scene.Scene;\n+import javafx.scene.SceneAntialiasing;\n+import javafx.scene.SubScene;\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.PhongMaterial;\n+import javafx.scene.shape.Sphere;\n+import javafx.stage.Stage;\n+import test.robot.testharness.VisualTestBase;\n+\n+\/**\n+ * This test verifies the fix for JDK-8255015.\n+ * It ensures that a sphere is illuminated correctly by a PointLight in a SubScene.\n+ * The bug occurred on MacBooks with retina displays (maybe also on other systems with HiDPI displays).\n+ * It was caused by not using the pixel scale factor in SubScenes at the moment, when the light sources\n+ * were located and so they got wrong positions. This test does not check the light source positions or\n+ * the pixel scale factor, but it simply creates a test scene containing a sphere and a perspective\n+ * camera. Some pixels of the scene will be tested if they have got the expected color and brightness.\n+ *\/\n+public class PointLightIlluminationTest extends VisualTestBase {\n+\n+    private static final int    SCENE_WIDTH_HEIGHT = 100;\n+    private static final int    BACKGROUND_PIXEL_X = 1;\n+    private static final int    BACKGROUND_PIXEL_Y = 1;\n+    private static final double CORNER_FACTOR      = 0.218;\n+    private static final int    LEFT_CORNER_X      = (int) (SCENE_WIDTH_HEIGHT * CORNER_FACTOR);\n+    private static final int    RIGHT_CORNER_X     = (int) (SCENE_WIDTH_HEIGHT * (1 - CORNER_FACTOR));\n+    private static final int    UPPER_CORNER_Y     = (int) (SCENE_WIDTH_HEIGHT * CORNER_FACTOR);\n+    private static final int    LOWER_CORNER_Y     = (int) (SCENE_WIDTH_HEIGHT * (1 - CORNER_FACTOR));\n+    private static final double COLOR_TOLERANCE    = 0.07;\n+    private static Scene testScene;\n+\n+    @Before\n+    public void setupEach() {\n+        assumeTrue(Platform.isSupported(ConditionalFeature.SCENE3D));\n+        \/\/ Use the same test scene for all tests\n+        if (testScene == null) {\n+            runAndWait(() -> {\n+                Stage testStage = getStage();\n+                testScene = createTestScene();\n+                testStage.setScene(testScene);\n+                testStage.show();\n+            });\n+            \/\/ Ensure that the scene is really displayed, before the tests begin\n+            waitFirstFrame();\n+        }\n+    }\n+\n+    @Test(timeout = 15000)\n+    public void sceneBackgroundColorShouldBeBlue() {\n+        runAndWait(() -> {\n+            assertColorEquals(\n+                    Color.BLUE,\n+                    getColor(testScene, BACKGROUND_PIXEL_X, BACKGROUND_PIXEL_Y),\n+                    COLOR_TOLERANCE);\n+        });\n+    }\n+\n+    @Test(timeout = 15000)\n+    public void sphereUpperLeftPixelColorShouldBeDarkRed() {\n+        runAndWait(() -> {\n+            Color color = getColor(testScene, LEFT_CORNER_X, UPPER_CORNER_Y);\n+            assertColorEquals(Color.DARKRED, color, COLOR_TOLERANCE);\n+        });\n+    }\n+\n+    @Test(timeout = 15000)\n+    public void sphereUpperRightPixelColorShouldBeDarkRed() {\n+        runAndWait(() -> {\n+            Color color = getColor(testScene, RIGHT_CORNER_X, UPPER_CORNER_Y);\n+            assertColorEquals(Color.DARKRED, color, COLOR_TOLERANCE);\n+        });\n+    }\n+\n+    @Test(timeout = 15000)\n+    public void sphereLowerRightPixelColorShouldBeDarkRed() {\n+        runAndWait(() -> {\n+            Color color = getColor(testScene, RIGHT_CORNER_X, LOWER_CORNER_Y);\n+            assertColorEquals(Color.DARKRED, color, COLOR_TOLERANCE);\n+        });\n+    }\n+\n+    @Test(timeout = 15000)\n+    public void sphereLowerLeftPixelColorShouldBeDarkRed() {\n+        runAndWait(() -> {\n+            Color color = getColor(testScene, LEFT_CORNER_X, LOWER_CORNER_Y);\n+            assertColorEquals(Color.DARKRED, color, COLOR_TOLERANCE);\n+        });\n+    }\n+\n+    @Test(timeout = 15000)\n+    public void sphereCenterPixelColorShouldBeRed() {\n+        runAndWait(() -> {\n+            Color color = getColor(testScene, SCENE_WIDTH_HEIGHT \/ 2, SCENE_WIDTH_HEIGHT \/ 2);\n+            assertColorEquals(Color.RED, color, COLOR_TOLERANCE);\n+        });\n+    }\n+\n+    \/**\n+     * This method is overridden and doing nothing, so that the test stage and scene\n+     * will not be hidden (which is the default behavior in the super class). The same\n+     * scene can be used for all the illumination tests by this class.\n+     *\/\n+    @Override\n+    @After\n+    public void doTeardown() {\n+    }\n+\n+    \/**\n+     * Creates a new scene with a subscene which contains a perspective camera and a sphere\n+     * Although this test class checks the pointlight illumination, there is no explicit pointlight\n+     * in the scene. For the test, it is sufficient to use the default pointlight which is created\n+     * by the perspective camera and located at the same position like the camera.\n+     * @return Scene\n+     *\/\n+    private Scene createTestScene() {\n+        Sphere sphere = new Sphere(SCENE_WIDTH_HEIGHT \/ 2);\n+        \/\/ By moving the sphere and the camera away from point 0, the effect the bug JDK-8255015\n+        \/\/ becomes more visible, because all point light coordinates would be wrong, if the pixel scale\n+        \/\/ factor was not set correctly. If it was not moved away from point 0, only the Z coordinate\n+        \/\/ of the point light would be wrong.\n+        sphere.setTranslateX(SCENE_WIDTH_HEIGHT);\n+        sphere.setTranslateY(SCENE_WIDTH_HEIGHT);\n+        sphere.setMaterial(new PhongMaterial(Color.RED));\n+\n+        SubScene subScene = new SubScene(\n+                new Group(sphere),\n+                SCENE_WIDTH_HEIGHT,\n+                SCENE_WIDTH_HEIGHT,\n+                true,\n+                SceneAntialiasing.DISABLED);\n+        subScene.setFill(Color.BLUE);\n+\n+        PerspectiveCamera perspectiveCamera = new PerspectiveCamera(true);\n+        \/\/ Move the camera, so that it points directly to the center of the sphere.\n+        perspectiveCamera.setTranslateX(SCENE_WIDTH_HEIGHT);\n+        perspectiveCamera.setTranslateY(SCENE_WIDTH_HEIGHT);\n+        perspectiveCamera.setTranslateZ(-2 * SCENE_WIDTH_HEIGHT);\n+        perspectiveCamera.setFarClip(4 * SCENE_WIDTH_HEIGHT);\n+        subScene.setCamera(perspectiveCamera);\n+\n+        return new Scene(new Group(subScene), SCENE_WIDTH_HEIGHT, SCENE_WIDTH_HEIGHT);\n+    }\n+}\n\\ No newline at end of file\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/test3d\/PointLightIlluminationTest.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"}]}