{"files":[{"patch":"@@ -126,0 +126,2 @@\n+        if (mask < 0)\n+            return IntRange(INT_MIN & mask, mask & INT_MAX);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/b3\/B3ReduceStrength.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -807,0 +807,1 @@\n+void testCheckSubBitAnd();\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/b3\/testb3.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -499,0 +499,1 @@\n+    RUN(testCheckSubBitAnd());\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/b3\/testb3_1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1128,0 +1128,32 @@\n+void testCheckSubBitAnd()\n+{\n+    Procedure proc;\n+    if (proc.optLevel() < 1)\n+        return;\n+    BasicBlock* root = proc.addBlock();\n+    Value* zero = root->appendNew<Const32Value>(proc, Origin(), 0);\n+    Value* arg1 = root->appendNew<ArgumentRegValue>(proc, Origin(), GPRInfo::argumentGPR0);\n+    Value* truncatedArg1 = root->appendNew<Value>(proc, Trunc, Origin(), arg1);\n+    Value* minusTwo = root->appendNew<Const32Value>(proc, Origin(), -2);\n+    Value* bitAnd = root->appendNew<Value>(proc, BitAnd, Origin(), truncatedArg1, minusTwo);\n+    CheckValue* checkSub = root->appendNew<CheckValue>(proc, CheckSub, Origin(), zero, bitAnd);\n+    checkSub->setGenerator([&] (CCallHelpers& jit, const StackmapGenerationParams&) {\n+        AllowMacroScratchRegisterUsage allowScratch(jit);\n+        jit.move(CCallHelpers::TrustedImm32(42), GPRInfo::returnValueGPR);\n+        jit.emitFunctionEpilogue();\n+        jit.ret();\n+    });\n+    root->appendNewControlValue(proc, Return, Origin(), checkSub);\n+\n+    auto code = compileProc(proc);\n+\n+    CHECK_EQ(invoke<int>(*code, 1), 0);\n+    CHECK_EQ(invoke<int>(*code, 2), -2);\n+    CHECK_EQ(invoke<int>(*code, 3), -2);\n+    CHECK_EQ(invoke<int>(*code, -1), 2);\n+    CHECK_EQ(invoke<int>(*code, -2), 2);\n+    CHECK_EQ(invoke<int>(*code, -3), 4);\n+    CHECK_EQ(invoke<int>(*code, INT_MAX), -(INT_MAX - 1));\n+    CHECK_EQ(invoke<int>(*code, INT_MIN), 42);\n+}\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/b3\/testb3_5.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -457,1 +457,1 @@\n-                    auto groupName = tryConsumeGroupName();\n+                auto groupName = tryConsumeGroupName();\n@@ -461,11 +461,4 @@\n-                    if (groupName) {\n-                        if (m_captureGroupNames.contains(groupName.value())) {\n-                            delegate.atomNamedBackReference(groupName.value());\n-                            break;\n-                        }\n-\n-                    if (m_isNamedForwardReferenceAllowed) {\n-                        m_forwardReferenceNames.add(groupName.value());\n-                            delegate.atomNamedForwardReference(groupName.value());\n-                            break;\n-                        }\n+                if (groupName) {\n+                    if (m_captureGroupNames.contains(groupName.value())) {\n+                        delegate.atomNamedBackReference(groupName.value());\n+                        break;\n@@ -473,0 +466,7 @@\n+\n+                if (m_isNamedForwardReferenceAllowed) {\n+                    m_forwardReferenceNames.add(groupName.value());\n+                        delegate.atomNamedForwardReference(groupName.value());\n+                        break;\n+                    }\n+                }\n@@ -863,1 +863,1 @@\n-            parseTokens();\n+        parseTokens();\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/JavaScriptCore\/yarr\/YarrParser.h","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+#elif USE(64KB_PAGE_BLOCK) || CPU(PPC) || CPU(PPC64) || CPU(PPC64LE) || CPU(UNKNOWN)\n+constexpr size_t CeilingOnPageSize = 64 * KB;\n@@ -54,2 +56,0 @@\n-#elif CPU(UNKNOWN) || CPU(PPC) || CPU(PPC64) || CPU(PPC64LE)\n-constexpr size_t CeilingOnPageSize = 64 * KB;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WTF\/wtf\/PageBlock.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -601,1 +601,1 @@\n-        m_string = m_string.left(m_queryEnd);\n+    m_string = m_string.left(m_queryEnd);\n@@ -920,0 +920,2 @@\n+        5060, \/\/ SIP\n+        5061, \/\/ SIPS\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WTF\/wtf\/URL.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"Document.h\"\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/Modules\/webaudio\/AudioContext.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -684,1 +684,1 @@\n-        if (criteria.start == AccessibilitySearchTextStartFrom::Begin)\n+    if (criteria.start == AccessibilitySearchTextStartFrom::Begin)\n@@ -686,1 +686,1 @@\n-        else if (criteria.start == AccessibilitySearchTextStartFrom::End)\n+    else if (criteria.start == AccessibilitySearchTextStartFrom::End)\n@@ -690,1 +690,1 @@\n-        else\n+    else\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/accessibility\/AccessibilityObject.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3141,2 +3141,2 @@\n-        if (!page->chrome().client().supportsSettingCursor())\n-            return;\n+    if (!page->chrome().client().supportsSettingCursor())\n+        return;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/EventHandler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2541,3 +2541,3 @@\n-        if (shouldThrottle)\n-            scriptedAnimationController->addThrottlingReason(ThrottlingReason::OutsideViewport);\n-        else\n+    if (shouldThrottle)\n+        scriptedAnimationController->addThrottlingReason(ThrottlingReason::OutsideViewport);\n+    else\n@@ -4520,1 +4520,1 @@\n-    \/\/ No content yet.\n+        \/\/ No content yet.\n@@ -4523,2 +4523,2 @@\n-    if (!documentElement || !documentElement->renderer())\n-        return false;\n+        if (!documentElement || !documentElement->renderer())\n+            return false;\n@@ -4529,1 +4529,1 @@\n-    \/\/ FIXME: We should also ignore renderers with non-final style.\n+        \/\/ FIXME: We should also ignore renderers with non-final style.\n@@ -4531,1 +4531,1 @@\n-        return false;\n+            return false;\n@@ -4534,3 +4534,3 @@\n-    \/\/ Ensure that we always fire visually non-empty milestone eventually.\n-    if (finishedParsingMainDocument && frame().loader().isComplete())\n-        return true;\n+        \/\/ Ensure that we always fire visually non-empty milestone eventually.\n+        if (finishedParsingMainDocument && frame().loader().isComplete())\n+            return true;\n@@ -4538,2 +4538,9 @@\n-    auto isVisible = [](const Element* element) {\n-        if (!element || !element->renderer())\n+        auto isVisible = [](const Element* element) {\n+            if (!element || !element->renderer())\n+                return false;\n+            if (!element->renderer()->opacity())\n+                return false;\n+            return element->renderer()->style().visibility() == Visibility::Visible;\n+        };\n+\n+        if (!isVisible(documentElement))\n@@ -4541,1 +4548,2 @@\n-        if (!element->renderer()->opacity())\n+\n+        if (!isVisible(document.body()))\n@@ -4543,2 +4551,0 @@\n-        return element->renderer()->style().visibility() == Visibility::Visible;\n-    };\n@@ -4546,2 +4552,3 @@\n-    if (!isVisible(documentElement))\n-        return false;\n+        \/\/ The first few hundred characters rarely contain the interesting content of the page.\n+        if (m_visuallyNonEmptyCharacterCount > visualCharacterThreshold)\n+            return true;\n@@ -4549,2 +4556,3 @@\n-        if (!isVisible(document.body()))\n-        return false;\n+        \/\/ Use a threshold value to prevent very small amounts of visible content from triggering didFirstVisuallyNonEmptyLayout\n+        if (m_visuallyNonEmptyPixelCount > visualPixelThreshold)\n+            return true;\n@@ -4552,3 +4560,6 @@\n-    \/\/ The first few hundred characters rarely contain the interesting content of the page.\n-    if (m_visuallyNonEmptyCharacterCount > visualCharacterThreshold)\n-        return true;\n+        auto isMoreContentExpected = [&]() {\n+            ASSERT(finishedParsingMainDocument);\n+            \/\/ Pending css\/font loading means we should wait a little longer. Classic non-async, non-defer scripts are all processed by now.\n+            auto* documentLoader = frame().loader().documentLoader();\n+            if (!documentLoader)\n+                return false;\n@@ -4556,3 +4567,3 @@\n-    \/\/ Use a threshold value to prevent very small amounts of visible content from triggering didFirstVisuallyNonEmptyLayout\n-    if (m_visuallyNonEmptyPixelCount > visualPixelThreshold)\n-        return true;\n+            auto& resourceLoader = documentLoader->cachedResourceLoader();\n+            if (!resourceLoader.requestCount())\n+                return false;\n@@ -4560,5 +4571,7 @@\n-    auto isMoreContentExpected = [&]() {\n-        ASSERT(finishedParsingMainDocument);\n-        \/\/ Pending css\/font loading means we should wait a little longer. Classic non-async, non-defer scripts are all processed by now.\n-        auto* documentLoader = frame().loader().documentLoader();\n-        if (!documentLoader)\n+            auto& resources = resourceLoader.allCachedResources();\n+            for (auto& resource : resources) {\n+                if (resource.value->isLoaded())\n+                    continue;\n+                if (resource.value->type() == CachedResource::Type::CSSStyleSheet || resource.value->type() == CachedResource::Type::FontResource)\n+                    return true;\n+            }\n@@ -4566,0 +4579,1 @@\n+        };\n@@ -4567,3 +4581,3 @@\n-        auto& resourceLoader = documentLoader->cachedResourceLoader();\n-        if (!resourceLoader.requestCount())\n-            return false;\n+        \/\/ Finished parsing the main document and we still don't yet have enough content. Check if we might be getting some more.\n+        if (finishedParsingMainDocument)\n+            return !isMoreContentExpected();\n@@ -4571,7 +4585,0 @@\n-        auto& resources = resourceLoader.allCachedResources();\n-        for (auto& resource : resources) {\n-            if (resource.value->isLoaded())\n-                continue;\n-            if (resource.value->type() == CachedResource::Type::CSSStyleSheet || resource.value->type() == CachedResource::Type::FontResource)\n-                return true;\n-        }\n@@ -4581,7 +4588,0 @@\n-    \/\/ Finished parsing the main document and we still don't yet have enough content. Check if we might be getting some more.\n-    if (finishedParsingMainDocument)\n-        return !isMoreContentExpected();\n-\n-    return false;\n-    };\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/FrameView.cpp","additions":48,"deletions":48,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -80,0 +80,2 @@\n+    RefPtr<AsyncScrollingCoordinator> m_scrollingCoordinator;\n+\n@@ -92,2 +94,0 @@\n-    RefPtr<AsyncScrollingCoordinator> m_scrollingCoordinator;\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/scrolling\/ThreadedScrollingTree.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+    RefPtr<Nicosia::CompositionLayer> rootContentsLayer() const { return m_rootContentsLayer; }\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/scrolling\/nicosia\/ScrollingTreeFrameScrollingNodeNicosia.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#include \"AsyncScrollingCoordinator.h\"\n+#include \"NicosiaPlatformLayer.h\"\n@@ -76,0 +78,62 @@\n+using Nicosia::CompositionLayer;\n+\n+static void collectDescendantLayersAtPoint(Vector<RefPtr<CompositionLayer>>& layersAtPoint, RefPtr<CompositionLayer> parent, const FloatPoint& point)\n+{\n+    bool childExistsAtPoint = false;\n+\n+    parent->accessPending([&](const CompositionLayer::LayerState& state) {\n+        for (auto child : state.children) {\n+            bool containsPoint = false;\n+            FloatPoint transformedPoint;\n+            child->accessPending([&](const CompositionLayer::LayerState& childState) {\n+                if (!childState.transform.isInvertible())\n+                    return;\n+                float originX = childState.anchorPoint.x() * childState.size.width();\n+                float originY = childState.anchorPoint.y() * childState.size.height();\n+                auto transform = *(TransformationMatrix()\n+                    .translate3d(originX + childState.position.x(), originY + childState.position.y(), childState.anchorPoint.z())\n+                    .multiply(childState.transform)\n+                    .translate3d(-originX, -originY, -childState.anchorPoint.z()).inverse());\n+                auto childPoint = transform.projectPoint(point);\n+                if (FloatRect(FloatPoint(), childState.size).contains(childPoint)) {\n+                    containsPoint = true;\n+                    transformedPoint.set(childPoint.x(), childPoint.y());\n+                }\n+            });\n+            if (containsPoint) {\n+                childExistsAtPoint = true;\n+                collectDescendantLayersAtPoint(layersAtPoint, child, transformedPoint);\n+            }\n+        }\n+    });\n+\n+    if (!childExistsAtPoint)\n+        layersAtPoint.append(parent);\n+}\n+\n+RefPtr<ScrollingTreeNode> ScrollingTreeNicosia::scrollingNodeForPoint(FloatPoint point)\n+{\n+    auto* rootScrollingNode = rootNode();\n+    if (!rootScrollingNode)\n+        return nullptr;\n+\n+    LayerTreeHitTestLocker layerLocker(m_scrollingCoordinator.get());\n+\n+    auto rootContentsLayer = static_cast<ScrollingTreeFrameScrollingNodeNicosia*>(rootScrollingNode)->rootContentsLayer();\n+    Vector<RefPtr<CompositionLayer>> layersAtPoint;\n+    collectDescendantLayersAtPoint(layersAtPoint, rootContentsLayer, point);\n+\n+    ScrollingTreeNode* returnNode = nullptr;\n+    for (auto layer : WTF::makeReversedRange(layersAtPoint)) {\n+        layer->accessCommitted([&](const CompositionLayer::LayerState& state) {\n+            auto* scrollingNode = nodeForID(state.scrollingNodeID);\n+            if (is<ScrollingTreeScrollingNode>(scrollingNode))\n+                returnNode = scrollingNode;\n+        });\n+        if (returnNode)\n+            break;\n+    }\n+\n+    return returnNode ? returnNode : rootScrollingNode;\n+}\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/scrolling\/nicosia\/ScrollingTreeNicosia.cpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+\n+    RefPtr<ScrollingTreeNode> scrollingNodeForPoint(FloatPoint) final;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/page\/scrolling\/nicosia\/ScrollingTreeNicosia.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-    if (domain == \"outlook.live.com\"\n+    if (domain == \"outlook.office.com\"\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/UserAgentQuirks.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"ScrollTypes.h\"\n@@ -137,0 +138,1 @@\n+                    bool scrollingNodeChanged : 1;\n@@ -186,0 +188,1 @@\n+        WebCore::FloatRoundedRect backdropFiltersRect;\n@@ -201,0 +204,2 @@\n+\n+        WebCore::ScrollingNodeID scrollingNodeID { 0 };\n@@ -251,0 +256,2 @@\n+        if (pending.delta.backdropFiltersRectChanged)\n+            staging.backdropFiltersRect = pending.backdropFiltersRect;\n@@ -269,0 +276,3 @@\n+        if (pending.delta.scrollingNodeChanged)\n+            staging.scrollingNodeID = pending.scrollingNodeID;\n+\n@@ -293,0 +303,7 @@\n+    template<typename T>\n+    void accessPending(const T& functor)\n+    {\n+        LockHolder locker(PlatformLayer::m_state.lock);\n+        functor(m_state.pending);\n+    }\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/nicosia\/NicosiaPlatformLayer.h","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -50,0 +50,9 @@\n+\n+    \/\/ If the update happens for the same image and there's no buffer, keep the current one\n+    \/\/ so it can be received by the CoordinatedGraphicsScene. In that case we only need to update\n+    \/\/ the isVisible flag.\n+    if ((m_layerState.update.nativeImageID == m_update.update.nativeImageID) && !m_layerState.update.buffer) {\n+        m_update.update.isVisible = m_layerState.update.isVisible;\n+        return;\n+    }\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/nicosia\/texmap\/NicosiaImageBackingTextureMapperImpl.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+        uintptr_t nativeImageID { 0 };\n@@ -75,1 +76,0 @@\n-        uintptr_t nativeImageID { 0 };\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/nicosia\/texmap\/NicosiaImageBackingTextureMapperImpl.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+    m_filterInfo = FilterInfo();\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/texmap\/BitmapTextureGL.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,0 +65,31 @@\n+void ClipStack::addRoundedRect(const FloatRoundedRect& roundedRect, const TransformationMatrix& matrix)\n+{\n+    if (clipState.roundedRectCount >= s_roundedRectMaxClips)\n+        return;\n+\n+    \/\/ Ensure that the vectors holding the components have the required size.\n+    m_roundedRectComponents.grow(s_roundedRectComponentsArraySize);\n+    m_roundedRectInverseTransformComponents.grow(s_roundedRectInverseTransformComponentsArraySize);\n+\n+    \/\/ Copy the RoundedRect components to the appropriate position in the array.\n+    int basePosition = clipState.roundedRectCount * s_roundedRectComponentsPerRect;\n+    m_roundedRectComponents[basePosition] = roundedRect.rect().x();\n+    m_roundedRectComponents[basePosition + 1] = roundedRect.rect().y();\n+    m_roundedRectComponents[basePosition + 2] = roundedRect.rect().width();\n+    m_roundedRectComponents[basePosition + 3] = roundedRect.rect().height();\n+    m_roundedRectComponents[basePosition + 4] = roundedRect.radii().topLeft().width();\n+    m_roundedRectComponents[basePosition + 5] = roundedRect.radii().topLeft().height();\n+    m_roundedRectComponents[basePosition + 6] = roundedRect.radii().topRight().width();\n+    m_roundedRectComponents[basePosition + 7] = roundedRect.radii().topRight().height();\n+    m_roundedRectComponents[basePosition + 8] = roundedRect.radii().bottomLeft().width();\n+    m_roundedRectComponents[basePosition + 9] = roundedRect.radii().bottomLeft().height();\n+    m_roundedRectComponents[basePosition + 10] = roundedRect.radii().bottomRight().width();\n+    m_roundedRectComponents[basePosition + 11] = roundedRect.radii().bottomRight().height();\n+\n+    \/\/ Copy the TransformationMatrix components to the appropriate position in the array.\n+    basePosition = clipState.roundedRectCount * s_roundedRectInverseTransformComponentsPerRect;\n+    memcpy(m_roundedRectInverseTransformComponents.data() + basePosition, matrix.toColumnMajorFloatArray().data(), s_roundedRectInverseTransformComponentsPerRect * sizeof(float));\n+\n+    clipState.roundedRectCount++;\n+}\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/texmap\/ClipStack.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include \"FloatRoundedRect.h\"\n@@ -26,0 +27,1 @@\n+#include \"TransformationMatrix.h\"\n@@ -30,0 +32,17 @@\n+\/\/ Because GLSL uniform arrays need to have a defined size, we need to put a limit to the number of simultaneous\n+\/\/ rounded rectangle clips that we're going to allow. Currently this is defined to 10.\n+\/\/ This value must be kept in sync with the sizes defined in TextureMapperShaderProgram.cpp.\n+static const unsigned s_roundedRectMaxClips = 10;\n+\n+\/\/ When converting a rounded rectangle to an array of floats, we need 12 elements. So the size of the array\n+\/\/ required to contain the 10 rectangles is 12 * 10 = 120.\n+\/\/ This value must be kept in sync with the sizes defined in TextureMapperShaderProgram.cpp.\n+static const unsigned s_roundedRectComponentsPerRect = 12;\n+static const unsigned s_roundedRectComponentsArraySize = s_roundedRectMaxClips * s_roundedRectComponentsPerRect;\n+\n+\/\/ When converting a transformation matrix to an array of floats, we need 16 elements. So the size of the array\n+\/\/ required to contain the 10 matrices is 16 * 10 = 160.\n+\/\/ This value must be kept in sync with the sizes defined in TextureMapperShaderProgram.cpp.\n+static const unsigned s_roundedRectInverseTransformComponentsPerRect = 16;\n+static const unsigned s_roundedRectInverseTransformComponentsArraySize = s_roundedRectMaxClips * s_roundedRectInverseTransformComponentsPerRect;\n+\n@@ -33,1 +52,1 @@\n-        State(const IntRect& scissors = IntRect(), int stencil = 1)\n+        explicit State(const IntRect& scissors = IntRect())\n@@ -35,1 +54,0 @@\n-            , stencilIndex(stencil)\n@@ -39,1 +57,2 @@\n-        int stencilIndex;\n+        int stencilIndex { 1 };\n+        unsigned roundedRectCount { 0 };\n@@ -57,0 +76,7 @@\n+    void addRoundedRect(const FloatRoundedRect&, const TransformationMatrix&);\n+    const float* roundedRectComponents() const { return m_roundedRectComponents.data(); }\n+    const float* roundedRectInverseTransformComponents() const { return m_roundedRectInverseTransformComponents.data(); }\n+    unsigned roundedRectCount() const { return clipState.roundedRectCount; }\n+    bool isRoundedRectClipEnabled() const { return !!clipState.roundedRectCount; }\n+    bool isRoundedRectClipAllowed() const { return clipState.roundedRectCount < s_roundedRectMaxClips; }\n+\n@@ -68,0 +94,2 @@\n+    Vector<float, s_roundedRectComponentsArraySize> m_roundedRectComponents;\n+    Vector<float, s_roundedRectInverseTransformComponentsArraySize> m_roundedRectInverseTransformComponents;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/texmap\/ClipStack.h","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -501,1 +501,1 @@\n-        downcast<GraphicsLayerTextureMapper>(*replicaLayer()).updateBackingStoreIfNeeded();\n+        downcast<GraphicsLayerTextureMapper>(*replicaLayer()).updateBackingStoreIncludingSubLayers();\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/texmap\/GraphicsLayerTextureMapper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+class FloatRoundedRect;\n@@ -78,1 +79,1 @@\n-    virtual void beginClip(const TransformationMatrix&, const FloatRect&) = 0;\n+    virtual void beginClip(const TransformationMatrix&, const FloatRoundedRect&) = 0;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/texmap\/TextureMapper.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"FloatRoundedRect.h\"\n@@ -445,0 +446,9 @@\n+static void prepareRoundedRectClip(TextureMapperShaderProgram& program, const float* rects, const float* transforms, int nRects)\n+{\n+    glUseProgram(program.programID());\n+\n+    glUniform1i(program.roundedRectNumberLocation(), nRects);\n+    glUniform4fv(program.roundedRectLocation(), 3 * nRects, rects);\n+    glUniformMatrix4fv(program.roundedRectInverseTransformMatrixLocation(), nRects, false, transforms);\n+}\n+\n@@ -492,0 +502,5 @@\n+    if (clipStack().isRoundedRectClipEnabled()) {\n+        options |= TextureMapperShaderProgram::RoundedRectClip;\n+        flags |= ShouldBlend;\n+    }\n+\n@@ -497,0 +512,3 @@\n+    if (clipStack().isRoundedRectClipEnabled())\n+        prepareRoundedRectClip(program.get(), clipStack().roundedRectComponents(), clipStack().roundedRectInverseTransformComponents(), clipStack().roundedRectCount());\n+\n@@ -555,0 +573,5 @@\n+    if (clipStack().isRoundedRectClipEnabled()) {\n+        options |= TextureMapperShaderProgram::RoundedRectClip;\n+        flags |= ShouldBlend;\n+    }\n+\n@@ -560,0 +583,3 @@\n+    if (clipStack().isRoundedRectClipEnabled())\n+        prepareRoundedRectClip(program.get(), clipStack().roundedRectComponents(), clipStack().roundedRectInverseTransformComponents(), clipStack().roundedRectCount());\n+\n@@ -605,0 +631,5 @@\n+    if (clipStack().isRoundedRectClipEnabled()) {\n+        options |= TextureMapperShaderProgram::RoundedRectClip;\n+        flags |= ShouldBlend;\n+    }\n+\n@@ -610,0 +641,3 @@\n+    if (clipStack().isRoundedRectClipEnabled())\n+        prepareRoundedRectClip(program.get(), clipStack().roundedRectComponents(), clipStack().roundedRectInverseTransformComponents(), clipStack().roundedRectCount());\n+\n@@ -653,0 +687,5 @@\n+    if (clipStack().isRoundedRectClipEnabled()) {\n+        options |= TextureMapperShaderProgram::RoundedRectClip;\n+        flags |= ShouldBlend;\n+    }\n+\n@@ -658,0 +697,3 @@\n+    if (clipStack().isRoundedRectClipEnabled())\n+        prepareRoundedRectClip(program.get(), clipStack().roundedRectComponents(), clipStack().roundedRectInverseTransformComponents(), clipStack().roundedRectCount());\n+\n@@ -676,0 +718,5 @@\n+    if (clipStack().isRoundedRectClipEnabled()) {\n+        options |= TextureMapperShaderProgram::RoundedRectClip;\n+        flags |= ShouldBlend;\n+    }\n+\n@@ -679,0 +726,3 @@\n+    if (clipStack().isRoundedRectClipEnabled())\n+        prepareRoundedRectClip(program.get(), clipStack().roundedRectComponents(), clipStack().roundedRectInverseTransformComponents(), clipStack().roundedRectCount());\n+\n@@ -887,1 +937,29 @@\n-void TextureMapperGL::beginClip(const TransformationMatrix& modelViewMatrix, const FloatRect& targetRect)\n+bool TextureMapperGL::beginRoundedRectClip(const TransformationMatrix& modelViewMatrix, const FloatRoundedRect& targetRect)\n+{\n+    \/\/ This is implemented by telling the fragment shader to check whether each pixel is inside the rounded rectangle\n+    \/\/ before painting it.\n+    \/\/\n+    \/\/ Inside the shader, the math to check whether a point is inside the rounded rectangle requires the rectangle to\n+    \/\/ be aligned to the X and Y axis, which is not guaranteed if the transformation matrix includes rotations. In order\n+    \/\/ to avoid this, instead of applying the transformation to the rounded rectangle, we calculate the inverse\n+    \/\/ of the transformation and apply it to the pixels before checking whether they are inside the rounded rectangle.\n+    \/\/ This works fine as long as the transformation matrix is invertible.\n+    \/\/\n+    \/\/ There is a limit to the number of rounded rectangle clippings that can be done, that happens because the GLSL\n+    \/\/ arrays must have a predefined size. The limit is defined inside ClipStack, and that's why we need to call\n+    \/\/ clipStack().isRoundedRectClipAllowed() before trying to add a new clip.\n+\n+    if (!targetRect.isRounded() || !targetRect.isRenderable() || targetRect.isEmpty() || !modelViewMatrix.isInvertible() || !clipStack().isRoundedRectClipAllowed())\n+        return false;\n+\n+    FloatQuad quad = modelViewMatrix.projectQuad(targetRect.rect());\n+    IntRect rect = quad.enclosingBoundingBox();\n+\n+    clipStack().addRoundedRect(targetRect, modelViewMatrix.inverse().value());\n+    clipStack().intersect(rect);\n+    clipStack().applyIfNeeded();\n+\n+    return true;\n+}\n+\n+void TextureMapperGL::beginClip(const TransformationMatrix& modelViewMatrix, const FloatRoundedRect& targetRect)\n@@ -890,1 +968,4 @@\n-    if (beginScissorClip(modelViewMatrix, targetRect))\n+    if (beginRoundedRectClip(modelViewMatrix, targetRect))\n+        return;\n+\n+    if (beginScissorClip(modelViewMatrix, targetRect.rect()))\n@@ -905,1 +986,1 @@\n-    matrix.multiply(TransformationMatrix::rectToRect(FloatRect(0, 0, 1, 1), targetRect));\n+    matrix.multiply(TransformationMatrix::rectToRect(FloatRect(0, 0, 1, 1), targetRect.rect()));\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/texmap\/TextureMapperGL.cpp","additions":84,"deletions":3,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-    void beginClip(const TransformationMatrix&, const FloatRect&) override;\n+    void beginClip(const TransformationMatrix&, const FloatRoundedRect&) override;\n@@ -101,0 +101,1 @@\n+    bool beginRoundedRectClip(const TransformationMatrix&, const FloatRoundedRect&);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/texmap\/TextureMapperGL.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-void TextureMapperJava::beginClip(const TransformationMatrix& matrix, const FloatRect& rect)\n+void TextureMapperJava::beginClip(const TransformationMatrix& matrix, const FloatRoundedRect& rect)\n@@ -65,1 +65,1 @@\n-    context->clip(rect);\n+    context->clip(rect.rect());\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/texmap\/TextureMapperJava.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    void beginClip(const TransformationMatrix&, const FloatRect&) final;\n+    void beginClip(const TransformationMatrix&, const FloatRoundedRect&) final;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/texmap\/TextureMapperJava.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-    bool isReplica { false };\n@@ -79,0 +78,3 @@\n+        if (m_isReplica)\n+            m_layerTransforms.combined.translate(-m_state.pos.x(), -m_state.pos.y());\n+\n@@ -199,2 +201,1 @@\n-        \/\/ FIXME: TextureMapper::beginClip doesn't support FloatRoundedRect, so we need to convert m_state.contentsClippingRect to FloatRect.\n-        options.textureMapper.beginClip(transform, m_state.contentsClippingRect.rect());\n+        options.textureMapper.beginClip(transform, m_state.contentsClippingRect);\n@@ -230,1 +231,1 @@\n-        options.textureMapper.beginClip(clipTransform, layerRect());\n+        options.textureMapper.beginClip(clipTransform, m_state.backdropFiltersRect);\n@@ -246,1 +247,1 @@\n-        options.textureMapper.beginClip(clipTransform, layerRect());\n+        options.textureMapper.beginClip(clipTransform, FloatRoundedRect(layerRect()));\n@@ -292,4 +293,1 @@\n-        replicaOptions.isReplica = true;\n-        replicaOptions.transform\n-            .multiply(m_state.replicaLayer->m_layerTransforms.combined)\n-            .multiply(m_layerTransforms.combined.inverse().valueOr(TransformationMatrix()));\n+        replicaOptions.transform.multiply(replicaTransform());\n@@ -308,1 +306,1 @@\n-static void resolveOverlaps(Region& newRegion, Region& overlapRegion, Region& nonOverlapRegion)\n+static void resolveOverlaps(const IntRect& newRegion, Region& overlapRegion, Region& nonOverlapRegion)\n@@ -314,2 +312,4 @@\n-    newRegion.subtract(overlapRegion);\n-    nonOverlapRegion.unite(newRegion);\n+\n+    Region newNonOverlapRegion(newRegion);\n+    newNonOverlapRegion.subtract(overlapRegion);\n+    nonOverlapRegion.unite(newNonOverlapRegion);\n@@ -318,1 +318,1 @@\n-void TextureMapperLayer::computeOverlapRegions(Region& overlapRegion, Region& nonOverlapRegion, ResolveSelfOverlapMode mode)\n+void TextureMapperLayer::computeOverlapRegions(ComputeOverlapRegionData& data, const TransformationMatrix& accumulatedReplicaTransform, bool includesReplica)\n@@ -323,1 +323,1 @@\n-    FloatRect boundingRect;\n+    FloatRect localBoundingRect;\n@@ -325,1 +325,1 @@\n-        boundingRect = layerRect();\n+        localBoundingRect = layerRect();\n@@ -327,1 +327,1 @@\n-        boundingRect = m_state.contentsRect;\n+        localBoundingRect = m_state.contentsRect;\n@@ -329,1 +329,1 @@\n-    if (m_currentFilters.hasOutsets()) {\n+    if (m_currentFilters.hasOutsets() && !m_state.backdropLayer) {\n@@ -331,4 +331,2 @@\n-        IntRect unfilteredTargetRect(boundingRect);\n-        boundingRect.move(std::max(0, -outsets.left()), std::max(0, -outsets.top()));\n-        boundingRect.expand(outsets.left() + outsets.right(), outsets.top() + outsets.bottom());\n-        boundingRect.unite(unfilteredTargetRect);\n+        localBoundingRect.move(-outsets.left(), -outsets.top());\n+        localBoundingRect.expand(outsets.left() + outsets.right(), outsets.top() + outsets.bottom());\n@@ -337,5 +335,2 @@\n-    TransformationMatrix replicaMatrix;\n-    if (m_state.replicaLayer) {\n-        replicaMatrix = replicaTransform();\n-        boundingRect.unite(replicaMatrix.mapRect(boundingRect));\n-    }\n+    TransformationMatrix transform(accumulatedReplicaTransform);\n+    transform.multiply(m_layerTransforms.combined);\n@@ -343,1 +338,2 @@\n-    boundingRect = m_layerTransforms.combined.mapRect(boundingRect);\n+    IntRect viewportBoundingRect = enclosingIntRect(transform.mapRect(localBoundingRect));\n+    viewportBoundingRect.intersect(data.clipBounds);\n@@ -345,6 +341,7 @@\n-    \/\/ Count all masks and filters as overlap layers.\n-    if (hasFilters() || m_state.maskLayer || (m_state.replicaLayer && m_state.replicaLayer->m_state.maskLayer)) {\n-        Region newOverlapRegion(enclosingIntRect(boundingRect));\n-        nonOverlapRegion.subtract(newOverlapRegion);\n-        overlapRegion.unite(newOverlapRegion);\n-        return;\n+    switch (data.mode) {\n+    case ComputeOverlapRegionMode::Intersection:\n+        resolveOverlaps(viewportBoundingRect, data.overlapRegion, data.nonOverlapRegion);\n+        break;\n+    case ComputeOverlapRegionMode::Union:\n+        data.overlapRegion.unite(viewportBoundingRect);\n+        break;\n@@ -353,2 +350,5 @@\n-    Region newOverlapRegion;\n-    Region newNonOverlapRegion(enclosingIntRect(boundingRect));\n+    if (m_state.replicaLayer && includesReplica) {\n+        TransformationMatrix newReplicaTransform(accumulatedReplicaTransform);\n+        newReplicaTransform.multiply(replicaTransform());\n+        computeOverlapRegions(data, newReplicaTransform, false);\n+    }\n@@ -358,1 +358,1 @@\n-            child->computeOverlapRegions(newOverlapRegion, newNonOverlapRegion, ResolveSelfOverlapIfNeeded);\n+            child->computeOverlapRegions(data, accumulatedReplicaTransform);\n@@ -360,14 +360,0 @@\n-\n-    if (m_state.replicaLayer) {\n-        newOverlapRegion.unite(replicaMatrix.mapRect(newOverlapRegion.bounds()));\n-        Region replicaRegion(replicaMatrix.mapRect(newNonOverlapRegion.bounds()));\n-        resolveOverlaps(replicaRegion, newOverlapRegion, newNonOverlapRegion);\n-    }\n-\n-    if ((mode != ResolveSelfOverlapAlways) && shouldBlend()) {\n-        newNonOverlapRegion.unite(newOverlapRegion);\n-        newOverlapRegion = Region();\n-    }\n-\n-    overlapRegion.unite(newOverlapRegion);\n-    resolveOverlaps(newNonOverlapRegion, overlapRegion, nonOverlapRegion);\n@@ -380,1 +366,9 @@\n-    computeOverlapRegions(overlapRegion, nonOverlapRegion, ResolveSelfOverlapAlways);\n+    bool needsUnion = hasFilters() || m_state.maskLayer || (m_state.replicaLayer && m_state.replicaLayer->m_state.maskLayer);\n+    ComputeOverlapRegionData data {\n+        needsUnion ? ComputeOverlapRegionMode::Union : ComputeOverlapRegionMode::Intersection,\n+        options.textureMapper.clipBounds(),\n+        overlapRegion,\n+        nonOverlapRegion\n+    };\n+    data.clipBounds.move(-options.offset);\n+    computeOverlapRegions(data, options.transform);\n@@ -397,4 +391,1 @@\n-        if (!rect.intersects(options.textureMapper.clipBounds()))\n-            continue;\n-\n-        options.textureMapper.beginClip(TransformationMatrix(), rect);\n+        options.textureMapper.beginClip(TransformationMatrix(), FloatRoundedRect(rect));\n@@ -413,2 +404,0 @@\n-    IntRect adjustedClipBounds(options.textureMapper.clipBounds());\n-    adjustedClipBounds.move(-options.offset);\n@@ -420,2 +409,0 @@\n-                if (!tileRect.intersects(adjustedClipBounds))\n-                    continue;\n@@ -436,1 +423,1 @@\n-RefPtr<BitmapTexture> TextureMapperLayer::paintIntoSurface(const TextureMapperPaintOptions& options, const IntSize& size)\n+void TextureMapperLayer::paintIntoSurface(TextureMapperPaintOptions& options)\n@@ -438,4 +425,1 @@\n-    RefPtr<BitmapTexture> surface = options.textureMapper.acquireTextureFromPool(size, BitmapTexture::SupportsAlpha);\n-    TextureMapperPaintOptions paintOptions(options);\n-    paintOptions.surface = surface;\n-    options.textureMapper.bindSurface(surface.get());\n+    options.textureMapper.bindSurface(options.surface.get());\n@@ -443,0 +427,2 @@\n+        TextureMapperPaintOptions paintOptions(options);\n+        paintOptions.transform = TransformationMatrix();\n@@ -445,1 +431,0 @@\n-        paintOptions.backdropLayer = nullptr;\n@@ -447,1 +432,1 @@\n-        paintSelfAndChildren(paintOptions);\n+        paintSelfAndChildren(options);\n@@ -450,3 +435,2 @@\n-    surface = surface->applyFilters(options.textureMapper, m_currentFilters);\n-    options.textureMapper.bindSurface(surface.get());\n-    return surface;\n+    options.surface = options.surface->applyFilters(options.textureMapper, m_currentFilters);\n+    options.textureMapper.bindSurface(options.surface.get());\n@@ -457,0 +441,2 @@\n+    IntRect targetRect(rect);\n+    targetRect.move(options.offset);\n@@ -458,4 +444,1 @@\n-    TransformationMatrix targetTransform;\n-    targetTransform.translate(options.offset.width(), options.offset.height());\n-    targetTransform.multiply(options.transform);\n-    options.textureMapper.drawTexture(surface, rect, targetTransform, opacity);\n+    options.textureMapper.drawTexture(surface, targetRect, { }, opacity);\n@@ -466,2 +449,0 @@\n-    RefPtr<BitmapTexture> replicaSurface;\n-    RefPtr<BitmapTexture> mainSurface;\n@@ -469,1 +450,2 @@\n-    paintOptions.offset = -IntSize(rect.x(), rect.y());\n+    paintOptions.surface = options.textureMapper.acquireTextureFromPool(rect.size(), BitmapTexture::SupportsAlpha);\n+    paintOptions.offset = -toIntSize(rect.location());\n@@ -471,1 +453,0 @@\n-    paintOptions.transform = TransformationMatrix();\n@@ -473,5 +454,3 @@\n-        paintOptions.isReplica = true;\n-        paintOptions.transform = replicaTransform();\n-        replicaSurface = paintIntoSurface(paintOptions, rect.size());\n-        paintOptions.isReplica = false;\n-        paintOptions.transform = TransformationMatrix();\n+        paintOptions.transform.multiply(replicaTransform());\n+        paintIntoSurface(paintOptions);\n+        paintOptions.transform = options.transform;\n@@ -482,4 +461,1 @@\n-    if (replicaSurface && options.opacity == 1) {\n-        commitSurface(options, *replicaSurface, rect, 1);\n-        replicaSurface = nullptr;\n-    }\n+    paintIntoSurface(paintOptions);\n@@ -487,11 +463,1 @@\n-    if (m_isBackdrop && m_effectTarget->m_state.replicaLayer && options.isReplica)\n-        paintOptions.transform = m_effectTarget->replicaTransform();\n-\n-    mainSurface = paintIntoSurface(paintOptions, rect.size());\n-    if (replicaSurface) {\n-        options.textureMapper.bindSurface(replicaSurface.get());\n-        options.textureMapper.drawTexture(*mainSurface.get(), FloatRect(FloatPoint::zero(), rect.size()));\n-        mainSurface = replicaSurface;\n-    }\n-\n-    commitSurface(options, *mainSurface, rect, options.opacity);\n+    commitSurface(options, *paintOptions.surface, rect, options.opacity);\n@@ -573,0 +539,1 @@\n+        replicaLayer->m_isReplica = true;\n@@ -589,0 +556,5 @@\n+void TextureMapperLayer::setBackdropFiltersRect(const FloatRoundedRect& backdropFiltersRect)\n+{\n+    m_state.backdropFiltersRect = backdropFiltersRect;\n+}\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/texmap\/TextureMapperLayer.cpp","additions":69,"deletions":97,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+    void setBackdropFiltersRect(const FloatRoundedRect&);\n@@ -126,3 +127,3 @@\n-    enum ResolveSelfOverlapMode {\n-        ResolveSelfOverlapAlways = 0,\n-        ResolveSelfOverlapIfNeeded\n+    enum class ComputeOverlapRegionMode : uint8_t {\n+        Intersection,\n+        Union\n@@ -130,1 +131,7 @@\n-    void computeOverlapRegions(Region& overlapRegion, Region& nonOverlapRegion, ResolveSelfOverlapMode);\n+    struct ComputeOverlapRegionData {\n+        ComputeOverlapRegionMode mode;\n+        IntRect clipBounds;\n+        Region& overlapRegion;\n+        Region& nonOverlapRegion;\n+    };\n+    void computeOverlapRegions(ComputeOverlapRegionData&, const TransformationMatrix&, bool includesReplica = true);\n@@ -134,1 +141,1 @@\n-    RefPtr<BitmapTexture> paintIntoSurface(const TextureMapperPaintOptions&, const IntSize&);\n+    void paintIntoSurface(TextureMapperPaintOptions&);\n@@ -174,0 +181,1 @@\n+        FloatRoundedRect backdropFiltersRect;\n@@ -216,0 +224,1 @@\n+    bool m_isReplica { false };\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/texmap\/TextureMapperLayer.h","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+        varying vec4 v_nonProjectedPosition;\n@@ -81,0 +82,1 @@\n+        out vec4 v_nonProjectedPosition;\n@@ -136,1 +138,2 @@\n-            gl_Position = u_projectionMatrix * u_modelViewMatrix * vec4(position, 0., 1.);\n+            v_nonProjectedPosition = u_modelViewMatrix * vec4(position, 0., 1.);\n+            gl_Position = u_projectionMatrix * v_nonProjectedPosition;\n@@ -171,0 +174,10 @@\n+\/\/ The max number of stacked rounded rectangle clips allowed is 10, which is also the\n+\/\/ max number of transforms that we can get. We need 3 components for each rounded\n+\/\/ rectangle so we need 30 components to receive the 10 rectangles.\n+\/\/\n+\/\/ Keep this is sync with the values defined in ClipStack.h\n+#define ROUNDED_RECT_CONSTANTS                       \\\n+    GLSL_DIRECTIVE(define ROUNDED_RECT_MAX_RECTS 10) \\\n+    GLSL_DIRECTIVE(define ROUNDED_RECT_ARRAY_SIZE 30) \\\n+    GLSL_DIRECTIVE(define ROUNDED_RECT_INVERSE_TRANSFORM_ARRAY_SIZE 10)\n+\n@@ -178,0 +191,1 @@\n+    ROUNDED_RECT_CONSTANTS\n@@ -202,0 +216,1 @@\n+        varying vec4 v_nonProjectedPosition;\n@@ -211,0 +226,1 @@\n+        in vec4 v_nonProjectedPosition;\n@@ -229,0 +245,3 @@\n+        uniform int u_roundedRectNumber;\n+        uniform vec4 u_roundedRect[ROUNDED_RECT_ARRAY_SIZE];\n+        uniform mat4 u_roundedRectInverseTransformMatrix[ROUNDED_RECT_INVERSE_TRANSFORM_ARRAY_SIZE];\n@@ -346,1 +365,1 @@\n-            return SamplerFunction(s_sampler, coord) * float(coord.x > 0. && coord.y > 0. && coord.x < 1. && coord.y < 1.);\n+            return SamplerFunction(s_sampler, coord);\n@@ -377,1 +396,1 @@\n-        vec4 sourceOver(vec4 src, vec4 dst) { return src + dst * (1. - dst.a); }\n+        vec4 sourceOver(vec4 src, vec4 dst) { return src + dst * (1. - src.a); }\n@@ -393,0 +412,67 @@\n+        float ellipsisDist(vec2 p, vec2 radius)\n+        {\n+            if (radius == vec2(0, 0))\n+                return 0.0;\n+\n+            vec2 p0 = p \/ radius;\n+            vec2 p1 = 2.0 * p0 \/ radius;\n+\n+            return (dot(p0, p0) - 1.0) \/ length (p1);\n+        }\n+\n+        float ellipsisCoverage(vec2 point, vec2 center, vec2 radius)\n+        {\n+            float d = ellipsisDist(point - center, radius);\n+            return clamp(0.5 - d, 0.0, 1.0);\n+        }\n+\n+        float roundedRectCoverage(vec2 p, int index)\n+        {\n+            vec4 bounds = vec4(u_roundedRect[index].xy, u_roundedRect[index].xy + u_roundedRect[index].zw);\n+\n+            if (p.x < bounds.x || p.y < bounds.y || p.x >= bounds.z || p.y >= bounds.w)\n+                return 0.0;\n+\n+            vec2 topLeftRadii = u_roundedRect[index + 1].xy;\n+            vec2 topRightRadii = u_roundedRect[index + 1].zw;\n+            vec2 bottomLeftRadii = u_roundedRect[index + 2].xy;\n+            vec2 bottomRightRadii = u_roundedRect[index + 2].zw;\n+\n+            vec2 topLeftCenter = bounds.xy + topLeftRadii;\n+            vec2 topRightCenter = bounds.zy + (topRightRadii * vec2(-1, 1));\n+            vec2 bottomLeftCenter = bounds.xw + (bottomLeftRadii * vec2(1, -1));\n+            vec2 bottomRightCenter = bounds.zw + (bottomRightRadii * vec2(-1, -1));\n+\n+            if (p.x < topLeftCenter.x && p.y < topLeftCenter.y)\n+                return ellipsisCoverage(p, topLeftCenter, topLeftRadii);\n+\n+            if (p.x > topRightCenter.x && p.y < topRightCenter.y)\n+                return ellipsisCoverage(p, topRightCenter, topRightRadii);\n+\n+            if (p.x < bottomLeftCenter.x && p.y > bottomLeftCenter.y)\n+                return ellipsisCoverage(p, bottomLeftCenter, bottomLeftRadii);\n+\n+            if (p.x > bottomRightCenter.x && p.y > bottomRightCenter.y)\n+                return ellipsisCoverage(p, bottomRightCenter, bottomRightRadii);\n+\n+            return 1.0;\n+        }\n+\n+        void applyRoundedRectClip(inout vec4 color)\n+        {\n+            \/\/ This works by checking whether the fragment position, once the transform is applied,\n+            \/\/ is inside the defined rounded rectangle or not.\n+            \/\/\n+            \/\/ We can't use gl_fragCoord for the fragment position because thats the projected point\n+            \/\/ and the projection screws the Z component. We need the real 3D position that comes from\n+            \/\/ the nonProjectedPosition variable.\n+            int nRects = u_roundedRectNumber;\n+            if (nRects > ROUNDED_RECT_MAX_RECTS)\n+                nRects = ROUNDED_RECT_MAX_RECTS;\n+\n+            for (int rectIndex = 0; rectIndex < nRects; rectIndex++) {\n+                vec4 fragCoord = u_roundedRectInverseTransformMatrix[rectIndex] * v_nonProjectedPosition;\n+                color *= roundedRectCoverage(fragCoord.xy, rectIndex * 3);\n+            }\n+        }\n+\n@@ -418,0 +504,1 @@\n+            applyRoundedRectClipIfNeeded(color);\n@@ -451,0 +538,1 @@\n+    SET_APPLIER_FROM_OPTIONS(RoundedRectClip);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/texmap\/TextureMapperShaderProgram.cpp","additions":91,"deletions":3,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -51,0 +51,3 @@\n+    macro(roundedRectNumber) \\\n+    macro(roundedRect) \\\n+    macro(roundedRectInverseTransformMatrix) \\\n@@ -102,0 +105,1 @@\n+        RoundedRectClip  = 1L << 23,\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/texmap\/TextureMapperShaderProgram.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -248,0 +248,9 @@\n+void CoordinatedGraphicsLayer::setScrollingNodeID(ScrollingNodeID nodeID)\n+{\n+    if (scrollingNodeID() == nodeID)\n+        return;\n+\n+    GraphicsLayer::setScrollingNodeID(nodeID);\n+    m_nicosia.delta.scrollingNodeChanged = true;\n+}\n+\n@@ -534,0 +543,1 @@\n+\n@@ -876,1 +886,1 @@\n-        if (layerState.update.isVisible && layerState.nativeImageID != nativeImageID) {\n+        if (layerState.update.isVisible && layerState.update.nativeImageID != nativeImageID) {\n@@ -885,1 +895,1 @@\n-            layerState.nativeImageID = nativeImageID;\n+            layerState.update.nativeImageID = nativeImageID;\n@@ -959,0 +969,3 @@\n+                if (localDelta.backdropFiltersRectChanged)\n+                    state.backdropFiltersRect = m_backdropFiltersRect;\n+\n@@ -1002,0 +1015,2 @@\n+                if (localDelta.scrollingNodeChanged)\n+                    state.scrollingNodeID = scrollingNodeID();\n@@ -1188,1 +1203,0 @@\n-        layerState.nativeImageID = 0;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/texmap\/coordinated\/CoordinatedGraphicsLayer.cpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+    void setScrollingNodeID(ScrollingNodeID) override;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/graphics\/texmap\/coordinated\/CoordinatedGraphicsLayer.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -442,1 +442,4 @@\n-    switch (m_tainting) {\n+    \/\/ FIXME: we don't really need to construct a Tainting here, this is just a workaround\n+    \/\/ for a GCC 10 bug (see https:\/\/gcc.gnu.org\/bugzilla\/show_bug.cgi?id=97634), that will\n+    \/\/ be removed once the bug is fixed.\n+    switch (Tainting(m_tainting)) {\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebCore\/platform\/network\/ResourceResponseBase.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -441,1 +441,1 @@\n-    m_textureMapper->beginClip(matrix, clip);\n+    m_textureMapper->beginClip(matrix, FloatRoundedRect(clip));\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WebKitLegacy\/java\/WebCoreSupport\/WebPage.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,17 @@\n+# We can't use WEBKIT_OPTION_DEFINE for USE_64KB_PAGE_BLOCK because it's needed to set the default\n+# value of other options. Why do we need this option? Because JSC and bmalloc both want to know the\n+# userspace page size at compile time, which is impossible on Linux because it's a runtime setting.\n+# We cannot test the system page size at build time in hopes that it will be the same on the target\n+# system, because (a) cross compiling wouldn't work, and (b) the build system could use a different\n+# page size than the target system (which will be true for Fedora aarch64, because Fedora is built\n+# using RHEL), so the best we can do is guess based on based on the target CPU architecture. In\n+# practice, guessing works for all architectures except aarch64 (unless unusual page sizes are\n+# used), but it fails for aarch64 because distros are split between using 4 KB and 64 KB pages\n+# there. Most distros (including Fedora) use 4 KB, but RHEL uses 16 KB. SUSE actually supports both.\n+# Since there is no way to guess correctly, the best we can do is provide an option for it. You\n+# should probably only use this if building for aarch64. Otherwise, known CPUs except PowerPC\n+# will use 4 KB, while PowerPC and unknown CPUs will use 64 KB (see wtf\/PageBlock.h). aarch64 will\n+# continue to default to 4 KB because this is a better default on systems where it doesn't crash.\n+# (Linux aarch64 is different from Apple's ARM64, which uses 16 KB.)\n+option(USE_64KB_PAGE_BLOCK \"Force support 64 KB userspace page size (reduces security and performance)\" OFF)\n+\n@@ -65,1 +82,13 @@\n-    if (WTF_CPU_ARM64 OR WTF_CPU_X86_64)\n+    if (USE_64KB_PAGE_BLOCK)\n+        set(ENABLE_JIT_DEFAULT OFF)\n+        set(ENABLE_FTL_DEFAULT OFF)\n+        set(USE_SYSTEM_MALLOC_DEFAULT ON)\n+        if (WTF_CPU_ARM64)\n+            set(ENABLE_C_LOOP_DEFAULT OFF)\n+            set(ENABLE_SAMPLING_PROFILER_DEFAULT ON)\n+        else ()\n+            message(WARNING \"Building with USE_64KB_PAGE_BLOCK on an architecture other than aarch64 is unusual. Are you sure you want USE_64KB_PAGE_BLOCK?\")\n+            set(ENABLE_C_LOOP_DEFAULT ON)\n+            set(ENABLE_SAMPLING_PROFILER_DEFAULT OFF)\n+        endif ()\n+    elseif (WTF_CPU_ARM64 OR WTF_CPU_X86_64)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/cmake\/WebKitFeatures.cmake","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"}]}