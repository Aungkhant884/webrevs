{"files":[{"patch":"@@ -53,0 +53,1 @@\n+    private static final String LIST_LISTENER_HELPER_GENERIC               = \"com.sun.javafx.collections.ListListenerHelper$Generic\";\n@@ -202,1 +203,1 @@\n-        final Object helper = getExpressionHelper(observable);\n+        Object helper = getExpressionHelper(observable);\n@@ -204,1 +205,4 @@\n-            return Collections.emptyList();\n+            helper = getListExpressionHelper(observable);\n+            if (helper == null) {\n+                return Collections.emptyList();\n+            }\n@@ -237,0 +241,17 @@\n+        try {\n+            final Class clazz = Class.forName(LIST_LISTENER_HELPER_GENERIC);\n+            if (clazz.isAssignableFrom(helperClass)) {\n+                try {\n+                    final Field field = clazz.getDeclaredField(\"changeListeners\");\n+                    field.setAccessible(true);\n+                    final ListChangeListener<? super E>[] listeners = (ListChangeListener[])field.get(helper);\n+                    if (listeners != null) {\n+                        final Field sizeField = clazz.getDeclaredField(\"changeSize\");\n+                        sizeField.setAccessible(true);\n+                        final int size = sizeField.getInt(helper);\n+                        return Arrays.asList(Arrays.copyOf(listeners, size));\n+                    }\n+                } catch (Exception ex) { }\n+            }\n+        } catch (ClassNotFoundException ex) { }\n+\n@@ -331,0 +352,13 @@\n+    private static Object getListExpressionHelper(Object bean) {\n+        Class clazz = bean.getClass();\n+        while (clazz != Object.class) {\n+            try {\n+                final Field field = clazz.getDeclaredField(\"listenerHelper\");\n+                field.setAccessible(true);\n+                return field.get(bean);\n+            } catch (Exception ex) {}\n+            clazz = clazz.getSuperclass();\n+        }\n+        return null;\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ExpressionHelperUtility.java","additions":36,"deletions":2,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import java.util.Objects;\n@@ -135,0 +136,4 @@\n+    \/* It's okay to have the value Weak, because we only remember it to remove the listener later on *\/\n+    private static Map<ListChangeListener<MenuItem>, WeakReference<ListChangeListener<MenuItem>>>\n+            menuListChangeListenerMap = new WeakHashMap<>();\n+\n@@ -139,6 +144,8 @@\n-        items.addListener((ListChangeListener<MenuItem>) c -> {\n-            while (c.next()) {\n-                if (c.wasRemoved()) {\n-                    \/\/ remove accelerators from the scene\n-                    removeAcceleratorsFromScene(c.getRemoved(), scene);\n-                }\n+        ListChangeListener<MenuItem> listChangeListener = new IdentityWrapperListChangeListener(items) {\n+            @Override\n+            public void onChanged(Change<? extends MenuItem> c) {\n+                while (c.next()) {\n+                    if (c.wasRemoved()) {\n+                        \/\/ remove accelerators from the scene\n+                        removeAcceleratorsFromScene(c.getRemoved(), scene);\n+                    }\n@@ -146,2 +153,3 @@\n-                if (c.wasAdded()) {\n-                    ControlAcceleratorSupport.doAcceleratorInstall(c.getAddedSubList(), scene);\n+                    if (c.wasAdded()) {\n+                        ControlAcceleratorSupport.doAcceleratorInstall(c.getAddedSubList(), scene);\n+                    }\n@@ -150,1 +158,1 @@\n-        });\n+        };\n@@ -152,0 +160,2 @@\n+        menuListChangeListenerMap.put(listChangeListener, new WeakReference<>(listChangeListener));\n+        items.addListener(listChangeListener);\n@@ -228,1 +238,1 @@\n-    public static void removeAcceleratorsFromScene(List<? extends MenuItem> items, Tab anchor) {\n+    public static void removeAcceleratorsFromScene(ObservableList<? extends MenuItem> items, Tab anchor) {\n@@ -236,1 +246,1 @@\n-    public static void removeAcceleratorsFromScene(List<? extends MenuItem> items, TableColumnBase<?,?> anchor) {\n+    public static void removeAcceleratorsFromScene(ObservableList<? extends MenuItem> items, TableColumnBase<?,?> anchor) {\n@@ -247,1 +257,1 @@\n-    public static void removeAcceleratorsFromScene(List<? extends MenuItem> items, Node anchor) {\n+    public static void removeAcceleratorsFromScene(ObservableList<? extends MenuItem> items, Node anchor) {\n@@ -264,1 +274,12 @@\n-    public static void removeAcceleratorsFromScene(List<? extends MenuItem> items, Scene scene) {\n+    public static void removeAcceleratorsFromScene(ObservableList<? extends MenuItem> items, Scene scene) {\n+        WeakReference<ListChangeListener<MenuItem>> listenerW = menuListChangeListenerMap.get(new IdentityWrapperListChangeListener(items));\n+        if (listenerW != null) {\n+            ListChangeListener<MenuItem> listChangeListener = listenerW.get();\n+            if (listChangeListener != null) {\n+                items.removeListener(listChangeListener);\n+            }\n+        }\n+        removeAcceleratorsFromScene((List<MenuItem>)items, scene);\n+    }\n+\n+    private static void removeAcceleratorsFromScene(List<? extends MenuItem> items, Scene scene) {\n@@ -314,0 +335,36 @@\n+\n+    \/\/ We need to store all the listeners added to each ObservableList so that we can remove them. For this we need\n+    \/\/ a map mapping ObservableList to various listeners such as ListChangeListeners, but the map needs to be a\n+    \/\/ WeakHashMap.\n+    \/\/ The ideal key to the WeakHashMap would be the ObservableList itself, except for the fact that its equals method\n+    \/\/ compares the list contents. If a WeakIdentityHashMap existed, we could use that instead with the ObservableList\n+    \/\/ as the key.\n+    \/\/ We can't use an IdentityWrapper as the key to the HashMap because we need a strong reference (ideally from the\n+    \/\/ ObservableList itself) to the IdentityWrapper else it'll be garbage collected.\n+    \/\/ Since every ObservableList gets a ListChangeListener, we can use that as an IdentityWrapper and rely on the fact\n+    \/\/ ObservableList has a strong reference to the ListChangeListener.\n+    static class IdentityWrapperListChangeListener implements ListChangeListener<MenuItem> {\n+\n+        ObservableList<? extends MenuItem> innerList;\n+\n+        public IdentityWrapperListChangeListener(ObservableList<? extends MenuItem> list) {\n+            this.innerList = list;\n+        }\n+\n+        @Override\n+        public void onChanged(Change<? extends MenuItem> c) {\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hashCode(innerList);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || !(o instanceof IdentityWrapperListChangeListener)) return false;\n+            IdentityWrapperListChangeListener that = (IdentityWrapperListChangeListener) o;\n+            return innerList == that.innerList;\n+        }\n+    };\n@@ -315,0 +372,2 @@\n+\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/ControlAcceleratorSupport.java","additions":72,"deletions":13,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -10,0 +10,2 @@\n+--add-opens javafx.base\/com.sun.javafx.collections=ALL-UNNAMED\n+--add-opens javafx.base\/javafx.collections=ALL-UNNAMED\n","filename":"modules\/javafx.controls\/src\/test\/addExports","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,4 +29,3 @@\n-import javafx.scene.control.MenuBar;\n-import javafx.scene.control.Menu;\n-import javafx.scene.control.MenuButton;\n-import javafx.scene.control.MenuItem;\n+import javafx.collections.ListChangeListener;\n+import javafx.scene.Scene;\n+import javafx.scene.control.*;\n@@ -36,0 +35,1 @@\n+import org.junit.Ignore;\n@@ -42,0 +42,3 @@\n+\n+import java.lang.ref.WeakReference;\n+\n@@ -44,1 +47,1 @@\n-\n+import static org.junit.Assert.assertFalse;\n@@ -162,0 +165,224 @@\n+\n+    @Test\n+    public void testMenuButtonSceneChangeDoesntLeakScene() {\n+        \/\/ JDK-8283551\n+        \/\/ The scene was leaked in a ListChangeListener added by ControlAcceleratorSupport\n+        MenuItem menuItem = new MenuItem(\"Menu Item\");\n+        MenuButton menuButton = new MenuButton(\"Menu Button\", null, menuItem);\n+        StackPane root = new StackPane(menuButton);\n+        StackPane root2 = new StackPane();\n+        StageLoader sl1 = new StageLoader(root);\n+        StageLoader sl2 = new StageLoader(root2);\n+        WeakReference<Scene> scene1 = new WeakReference<>(sl1.getStage().getScene());\n+        root2.getChildren().add(menuButton);\n+        sl1.dispose();\n+        JMemoryBuddy.assertCollectable(scene1);\n+        sl2.dispose();\n+    }\n+\n+    @Test\n+    public void testMenuButtonSceneChangeDoesntAddExtraListChangeListeners() {\n+        \/\/ JDK-8283551\n+        MenuItem menuItem = new MenuItem(\"Menu Item\");\n+        Menu subMenu = new Menu(\"Sub Menu\", null);\n+        MenuButton menuButton = new MenuButton(\"Menu Button\", null, menuItem, subMenu);\n+\n+        StackPane root = new StackPane(menuButton);\n+        StackPane root2 = new StackPane();\n+        StageLoader sl1 = new StageLoader(root);\n+        StageLoader sl2 = new StageLoader(root2);\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(menuButton.getItems()).size());\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(subMenu.getItems()).size());\n+\n+        ListChangeListener originalMenuButtonListChangeListener =\n+                ExpressionHelperUtility.getListChangeListeners(menuButton.getItems()).get(1);\n+        ListChangeListener originalSubMenuListChangeListener =\n+                ExpressionHelperUtility.getListChangeListeners(subMenu.getItems()).get(1);\n+\n+        \/\/ move the menu to another scene and check that the listeners got removed and recreated\n+        root2.getChildren().add(menuButton);\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(menuButton.getItems()).size());\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(subMenu.getItems()).size());\n+\n+        ListChangeListener newMenuButtonListChangeListener =\n+                ExpressionHelperUtility.getListChangeListeners(menuButton.getItems()).get(1);\n+        ListChangeListener newSubMenuListChangeListener =\n+                ExpressionHelperUtility.getListChangeListeners(subMenu.getItems()).get(1);\n+\n+        \/\/ use == instead of .equals because the list change listeners override equals to compare the observable list\n+        assertFalse(originalMenuButtonListChangeListener == newMenuButtonListChangeListener);\n+        assertFalse(originalSubMenuListChangeListener == newSubMenuListChangeListener);\n+\n+        \/\/ Change to weak references and check that there are no remaining references\n+        WeakReference<ListChangeListener> wOriginalMenuButtonListChangeListener =\n+                new WeakReference<>(originalMenuButtonListChangeListener);\n+        WeakReference<ListChangeListener> wOriginalSubMenuListChangeListener =\n+                new WeakReference<>(originalSubMenuListChangeListener);\n+        originalMenuButtonListChangeListener = null;\n+        originalSubMenuListChangeListener = null;\n+        JMemoryBuddy.assertCollectable(wOriginalMenuButtonListChangeListener);\n+        JMemoryBuddy.assertCollectable(wOriginalSubMenuListChangeListener);\n+\n+        sl1.dispose();\n+        sl2.dispose();\n+    }\n+\n+    private void setActionMenuItem(Tab tab, MenuItem menuItem) {\n+        menuItem.setOnAction(e -> tab.setText(\"Tab Renamed\"));\n+    }\n+\n+    @Ignore(\"JDK-8283449\")\n+    @Test\n+    public void testTabWithContextMenuReferencingTabDoesntCauseMemoryLeak() {\n+        \/\/ JDK-8283449 Tab with context menu that references tab gets leaked\n+        Tab tab = new Tab(\"Tab\");\n+        TabPane tabPane = new TabPane(tab);\n+\n+        MenuItem menuItemWithReferenceToTab = new MenuItem(\"RenameTabMenuItem\");\n+        \/\/ method call so that we can set tab to null later without dealing with\n+        \/\/ \"variable used in lambda expression should be final or effectively final\"\n+        setActionMenuItem(tab, menuItemWithReferenceToTab);\n+        ContextMenu contextMenu = new ContextMenu(menuItemWithReferenceToTab);\n+        tab.setContextMenu(contextMenu);\n+\n+        StackPane root = new StackPane(tabPane);\n+        StageLoader sl = new StageLoader(root);\n+\n+        WeakReference<Tab> wTab = new WeakReference<>(tab);\n+        tab = null;\n+        JMemoryBuddy.assertNotCollectable(wTab);\n+        tabPane.getTabs().remove(0);\n+        JMemoryBuddy.assertCollectable(wTab);\n+        sl.dispose();\n+    }\n+\n+    @Test\n+    public void testSingleTabContextMenuGetsNewListChangeListenersWhenSceneChange() {\n+        \/\/ JDK-8283551\n+        \/\/ Test moving a tab pane from one scene to another removes and re-adds the appropriate ListChangeListeners\n+        Tab t = new Tab();\n+        TabPane tabPane = new TabPane(t);\n+\n+        ContextMenu contextMenu1 = new ContextMenu();\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        StackPane root = new StackPane(tabPane);\n+        t.setContextMenu(contextMenu1); \/\/ set before in scene\n+        StageLoader sl1 = new StageLoader(root);\n+\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        \/\/ removing and re-adding removes and re-adds listeners\n+        root.getChildren().clear();\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        root.getChildren().add(tabPane);\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        ListChangeListener<? super MenuItem> originalListener1 =\n+                ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).get(1);\n+\n+        StageLoader sl2 = new StageLoader(root); \/\/ change the scene\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        root.getChildren().clear();\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        root.getChildren().add(tabPane);\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+\n+        \/\/ the listeners are new\n+        for (ListChangeListener l : ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems())) {\n+            \/\/ can't use contains because the equals method for one of these listeners will return true\n+            assertFalse(l == originalListener1);\n+        }\n+        sl1.dispose();\n+        sl2.dispose();\n+    }\n+\n+    @Ignore\n+    @Test\n+    public void testMultipleTabContextMenuGetsNewListChangeListenersWhenSceneChange() {\n+        \/\/ JDK-8283551\n+        \/\/ Test moving a tab pane from one scene to another removes and re-adds the appropriate ListChangeListeners\n+        Tab t = new Tab();\n+        Tab t2 = new Tab();\n+        TabPane tabPane = new TabPane(t,t2);\n+\n+        ContextMenu contextMenu1 = new ContextMenu();\n+        ContextMenu contextMenu2 = new ContextMenu();\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+        StackPane root = new StackPane(tabPane);\n+        t.setContextMenu(contextMenu1); \/\/ set before in scene\n+        t2.setContextMenu(contextMenu2);\n+        StageLoader sl1 = new StageLoader(root);\n+\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+        \/\/ removing and re-adding removes and re-adds listeners\n+        root.getChildren().clear();\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+        root.getChildren().add(tabPane);\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+        ListChangeListener<? super MenuItem> originalListener1 =\n+                ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).get(1);\n+        ListChangeListener<? super MenuItem> originalListener2 =\n+                ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).get(1);\n+\n+        StageLoader sl2 = new StageLoader(root); \/\/ change the scene\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+        root.getChildren().clear();\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+        root.getChildren().add(tabPane);\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+\n+        \/\/ the listeners are new\n+        for (ListChangeListener l : ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems())) {\n+            \/\/ can't use contains because the equals method for one of these listeners will return true\n+            assertFalse(l == originalListener1);\n+        }\n+        for (ListChangeListener l : ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems())) {\n+            \/\/ can't use contains because the equals method for one of these listeners will return true\n+            assertFalse(l == originalListener2);\n+        }\n+        sl1.dispose();\n+        sl2.dispose();\n+    }\n+\n+    @Test\n+    public void testTabContextMenuSceneChangeDoesntLeakScene() {\n+        \/\/ JDK-8283551\n+        \/\/ The scene was leaked in a ListChangeListener added by ControlAcceleratorSupport\n+        \/\/ For tab context menus, either the ListChangeListener is removed when the TabPane changes scenes\n+        \/\/ or when a new context menu is set. Both removals are tested here.\n+\n+        Tab t = new Tab();\n+        TabPane tabPane = new TabPane(t);\n+\n+        ContextMenu contextMenu1 = new ContextMenu();\n+        ContextMenu contextMenu2 = new ContextMenu();\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+        StackPane root = new StackPane(tabPane);\n+        StageLoader sl1 = new StageLoader(root);\n+        t.setContextMenu(contextMenu1);\n+\n+        \/\/ adding the context menu to the tab adds a list change listener\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+\n+        \/\/ swapping the context menu removes the previously added list change listener\n+        t.setContextMenu(contextMenu2);\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+\n+        \/\/ This assert fails because right now each anchor has one scene change listener only\n+        \/\/ There needs to be a scene change listener per ObservableList\n+        \/\/assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+\n+        \/\/ Both context menus shouldn't have a list change listener that references the scene after its removed\n+        WeakReference<Scene> scene1 = new WeakReference<>(sl1.getStage().getScene());\n+        sl1.dispose();\n+\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+        JMemoryBuddy.assertCollectable(scene1);\n+    }\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/ControlAcceleratorSupportTest.java","additions":232,"deletions":5,"binary":false,"changes":237,"status":"modified"}]}