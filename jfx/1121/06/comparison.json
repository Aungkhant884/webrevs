{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3468,0 +3468,1 @@\n+        testImplementation project(\":base\").sourceSets.test.output\n","filename":"build.gradle","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.Collection;\n@@ -94,0 +95,32 @@\n+    \/**\n+     * Checks whether the content of all references from a WeakReference array can be collected.\n+     * @param weakReferences WeakReference objects to check.\n+     *\/\n+    public static void assertCollectable(WeakReference[] weakReferences) {\n+        for (WeakReference wr : weakReferences) {\n+            assertCollectable(wr);\n+        }\n+    }\n+\n+    \/**\n+     * Checks whether the content of all references from a WeakReference Collection can be collected.\n+     * @param weakReferences WeakReference objects to check.\n+     *\/\n+    public static <T> void assertCollectable(Collection<WeakReference<T>> weakReferences) {\n+        for (WeakReference<T> wr : weakReferences) {\n+            assertCollectable(wr);\n+        }\n+    }\n+\n+    \/**\n+     * Checks whether the content of provided WeakReference objects can be collected.\n+     * @param weakReference The WeakReference to check.\n+     * @param otherWeakReferences Other WeakReference objects to check.\n+     *\/\n+    public static void assertCollectable(WeakReference weakReference, WeakReference... otherWeakReferences) {\n+        assertCollectable(weakReference);\n+        for (WeakReference wr : otherWeakReferences) {\n+            assertCollectable(wr);\n+        }\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/util\/memory\/JMemoryBuddy.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-\t\t\t<attribute name=\"add-exports\" value=\"javafx.base\/com.sun.javafx=javafx.web\"\/>\n+\t\t\t<attribute name=\"add-exports\" value=\"javafx.base\/com.sun.javafx=javafx.web:javafx.base\/test.util.memory=javafx.web\"\/>\n","filename":"modules\/javafx.web\/.classpath","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+import test.util.memory.JMemoryBuddy;\n@@ -82,1 +83,1 @@\n-        Reference<?>[] willGC = new Reference[count];\n+        WeakReference<?>[] willGC = new WeakReference[count];\n@@ -91,15 +92,1 @@\n-        Thread.sleep(SLEEP_TIME);\n-\n-        for (int i = 0; i < 5; i++) {\n-            System.gc();\n-\n-            if (isAllElementsNull(willGC)) {\n-                break;\n-            }\n-\n-            Thread.sleep(SLEEP_TIME);\n-        }\n-\n-        assertNull(\"WebView has not been GCed\", willGC[0].get());\n-        assertNull(\"WebEngine has not been GCed\", willGC[1].get());\n-        assertNull(\"WebPage has not been GCed\", willGC[2].get());\n+        JMemoryBuddy.assertCollectable(willGC);\n@@ -119,1 +106,1 @@\n-        Reference<?>[] willGC = new Reference[count];\n+        WeakReference<?>[] willGC = new WeakReference[count];\n@@ -128,13 +115,1 @@\n-        Thread.sleep(SLEEP_TIME);\n-\n-        for (int i = 0; i < 5; i++) {\n-            System.gc();\n-\n-            if (isAllElementsNull(willGC)) {\n-                break;\n-            }\n-\n-            Thread.sleep(SLEEP_TIME);\n-        }\n-\n-        assertTrue(\"All JSObjects are GC'ed\", isAllElementsNull(willGC));\n+        JMemoryBuddy.assertCollectable(willGC);\n@@ -180,1 +155,1 @@\n-        Reference<?>[] willGC = new Reference[count];\n+        WeakReference<?>[] willGC = new WeakReference[count];\n@@ -239,15 +214,1 @@\n-        Thread.sleep(SLEEP_TIME);\n-\n-        for (int i = 0; i < 5; i++) {\n-            System.gc();\n-\n-            if (isAllElementsNull(willGC)) {\n-                break;\n-            }\n-\n-            Thread.sleep(SLEEP_TIME);\n-        }\n-\n-        \/\/ Give disposer a chance to run\n-        Thread.sleep(SLEEP_TIME);\n-        assertEquals(\"NodeImpl HashCount after dispose\", initialHashCount, NodeImplShim.test_getHashCount());\n+        JMemoryBuddy.assertCollectable(willGC);\n","filename":"modules\/javafx.web\/src\/test\/java\/test\/javafx\/scene\/web\/LeakTest.java","additions":8,"deletions":47,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,3 @@\n+import javax.swing.SwingUtilities;\n+\n+import java.lang.reflect.InvocationTargetException;\n@@ -48,0 +51,1 @@\n+import test.util.memory.JMemoryBuddy;\n@@ -53,1 +57,0 @@\n-    final static int GC_ATTEMPTS = 10;\n@@ -68,1 +71,1 @@\n-    public void testSwingNodeMemoryLeak() {\n+    public void testSwingNodeMemoryLeak() throws InvocationTargetException, InterruptedException {\n@@ -72,2 +75,6 @@\n-        attemptGCSwingNode();\n-        assertEquals(TOTAL_SWINGNODE, getCleanedUpSwingNodeCount());\n+\n+        \/\/ Invoke a noop on EDT thread and wait for a bit to make sure EDT processed node objects\n+        SwingUtilities.invokeAndWait(() -> {});\n+        Util.sleep(500);\n+\n+        JMemoryBuddy.assertCollectable(weakRefArrSN);\n@@ -115,15 +122,0 @@\n-    private void attemptGCSwingNode() {\n-        \/\/ Attempt gc GC_ATTEMPTS times\n-        for (int i = 0; i < GC_ATTEMPTS; i++) {\n-            System.gc();\n-            if (getCleanedUpSwingNodeCount() == TOTAL_SWINGNODE) {\n-                break;\n-            }\n-            try {\n-                Thread.sleep(500);\n-            } catch (InterruptedException e) {\n-                System.err.println(\"InterruptedException occurred during Thread.sleep()\");\n-            }\n-        }\n-    }\n-\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/embed\/swing\/SwingNodeDnDMemoryLeakTest.java","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -36,0 +37,1 @@\n+import javax.swing.SwingUtilities;\n@@ -50,0 +52,1 @@\n+import test.util.memory.JMemoryBuddy;\n@@ -72,4 +75,1 @@\n-    public void testSwingNodeMemoryLeak() {\n-        if (PlatformUtil.isMac()) {\n-            assumeTrue(Boolean.getBoolean(\"unstable.test\")); \/\/ JDK-8196614\n-        }\n+    public void testSwingNodeMemoryLeak() throws InterruptedException, InvocationTargetException {\n@@ -79,2 +79,0 @@\n-        attemptGCSwingNode();\n-        assertEquals(TOTAL_SWINGNODE, getCleanedUpSwingNodeCount());\n@@ -82,2 +80,6 @@\n-        attemptGCJLabel();\n-        assertEquals(TOTAL_SWINGNODE, getCleanedUpJLabelCount());\n+        \/\/ Invoke a noop on EDT thread and wait for a bit to make sure EDT processed node objects\n+        SwingUtilities.invokeAndWait(() -> {});\n+        Util.sleep(500);\n+\n+        JMemoryBuddy.assertCollectable(weakRefArrSN);\n+        JMemoryBuddy.assertCollectable(weakRefArrJL);\n@@ -123,29 +125,0 @@\n-    private void attemptGCSwingNode() {\n-        \/\/ Attempt gc GC_ATTEMPTS times\n-        for (int i = 0; i < GC_ATTEMPTS; i++) {\n-            System.gc();\n-            if (getCleanedUpSwingNodeCount() == TOTAL_SWINGNODE) {\n-                break;\n-            }\n-            try {\n-                Thread.sleep(250);\n-            } catch (InterruptedException e) {\n-                System.err.println(\"InterruptedException occurred during Thread.sleep()\");\n-            }\n-        }\n-    }\n-\n-    private void attemptGCJLabel() {\n-        \/\/ Attempt gc GC_ATTEMPTS times\n-        for (int i = 0; i < GC_ATTEMPTS; i++) {\n-            System.gc();\n-            if (getCleanedUpJLabelCount() == TOTAL_SWINGNODE) {\n-                break;\n-            }\n-            try {\n-                Thread.sleep(250);\n-            } catch (InterruptedException e) {\n-                System.err.println(\"InterruptedException occurred during Thread.sleep()\");\n-            }\n-        }\n-    }\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/embed\/swing\/SwingNodeMemoryLeakTest.java","additions":11,"deletions":38,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import test.util.memory.JMemoryBuddy;\n@@ -53,0 +54,2 @@\n+    private WeakReference<TitledPane> weakRefToPane;\n+\n@@ -80,14 +83,9 @@\n-        TitledPane pane = new TitledPane();\n-        accordion.getPanes().add(pane);\n-        WeakReference<TitledPane> weakRefToPane = new WeakReference<>(pane);\n-        pane = null;\n-        accordion.getPanes().clear();\n-        for (int i = 0; i < 10; i++) {\n-            System.gc();\n-            if (weakRefToPane.get() == null) {\n-                break;\n-            }\n-            Util.sleep(500);\n-        }\n-        \/\/ Ensure accordion's skin no longer hold a ref to titled pane.\n-        Assert.assertNull(\"Couldn't collect TitledPane\", weakRefToPane.get());\n+        Util.runAndWait(() -> {\n+            TitledPane pane = new TitledPane();\n+            accordion.getPanes().add(pane);\n+            weakRefToPane = new WeakReference<>(pane);\n+            pane = null;\n+            accordion.getPanes().clear();\n+        });\n+\n+        JMemoryBuddy.assertCollectable(weakRefToPane);\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/control\/AccordionTitlePaneLeakTest.java","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n-import junit.framework.Assert;\n@@ -46,0 +45,2 @@\n+import test.util.memory.JMemoryBuddy;\n+\n@@ -95,11 +96,2 @@\n-        for (int i = 0; i < 10; i++) {\n-            System.gc();\n-            if (tabWeakRef.get() == null &&\n-                textFieldWeakRef.get() == null) {\n-                break;\n-            }\n-            Util.sleep(500);\n-        }\n-        \/\/ Ensure that Tab and TextField are GCed.\n-        Assert.assertNull(\"Couldn't collect Tab\", tabWeakRef.get());\n-        Assert.assertNull(\"Couldn't collect TextField\", textFieldWeakRef.get());\n+\n+        JMemoryBuddy.assertCollectable(tabWeakRef, textFieldWeakRef);\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/control\/TabPaneHeaderLeakTest.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-import junit.framework.Assert;\n@@ -47,0 +46,1 @@\n+import test.util.memory.JMemoryBuddy;\n@@ -97,9 +97,2 @@\n-        for (int i = 0; i < 10; i++) {\n-            System.gc();\n-            if (shapeWeakRef.get() == null) {\n-                break;\n-            }\n-            Util.sleep(500);\n-        }\n-        \/\/ Ensure that Shape is GCed.\n-        Assert.assertNull(\"Couldn't collect Shape\", shapeWeakRef.get());\n+\n+        JMemoryBuddy.assertCollectable(shapeWeakRef);\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/shape\/ShapeViewOrderLeakTest.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import test.util.memory.JMemoryBuddy;\n@@ -79,15 +80,1 @@\n-        assertCollectable(closedFocusedStageWeak);\n-    }\n-\n-    public static void assertCollectable(WeakReference weakReference) throws Exception {\n-        int counter = 0;\n-\n-        System.gc();\n-\n-        while (counter < 10 && weakReference.get() != null) {\n-            Thread.sleep(100);\n-            counter = counter + 1;\n-            System.gc();\n-        }\n-\n-        Assert.assertNull(weakReference.get());\n+        JMemoryBuddy.assertCollectable(closedFocusedStageWeak);\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/FocusedWindowTestBase.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import test.util.memory.JMemoryBuddy;\n@@ -167,8 +168,1 @@\n-        for (int j = 0; j < 5; ++j) {\n-            System.gc();\n-            if (webViewRef.get() == null) {\n-                break;\n-            }\n-            Util.sleep(SLEEP_TIME);\n-        }\n-        assertNull(\"webViewRef is not null\", webViewRef.get());\n+        JMemoryBuddy.assertCollectable(webViewRef);\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/web\/TooltipFXTest.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"}]}