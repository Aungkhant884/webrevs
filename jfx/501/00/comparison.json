{"files":[{"patch":"@@ -484,0 +484,1 @@\n+            updateEditing();\n@@ -575,1 +576,7 @@\n-        if (index == -1 || tree == null || treeItem == null) return;\n+        if (index == -1 || tree == null || treeItem == null) {\n+            if (editing) {\n+                \/\/ JDK-8265210: must cancel edit if index changed to -1 by re-use\n+                doCancelEditing();\n+            }\n+            return;\n+        }\n@@ -584,6 +591,13 @@\n-            \/\/ If my tree item is not the one being edited then I need to cancel\n-            \/\/ the edit. The tricky thing here is that as part of this call\n-            \/\/ I cannot end up calling tree.edit(null) the way that the standard\n-            \/\/ cancelEdit method would do. Yet, I need to call cancelEdit\n-            \/\/ so that subclasses which override cancelEdit can execute. So,\n-            \/\/ I have to use a kind of hacky flag workaround.\n+            doCancelEditing();\n+        }\n+    }\n+\n+    private void doCancelEditing() {\n+        \/\/ If my tree item is not the one being edited then I need to cancel\n+        \/\/ the edit. The tricky thing here is that as part of this call\n+        \/\/ I cannot end up calling tree.edit(null) the way that the standard\n+        \/\/ cancelEdit method would do. Yet, I need to call cancelEdit\n+        \/\/ so that subclasses which override cancelEdit can execute. So,\n+        \/\/ I have to use a kind of hacky flag workaround.\n+        try {\n+            \/\/ try-finally to make certain that the flag is reliably reset to true\n@@ -592,0 +606,1 @@\n+        } finally {\n@@ -597,1 +612,0 @@\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeCell.java","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -88,0 +88,2 @@\n+        assertEquals(\"cancel event index must be same as editingIndex\",\n+                editingIndex, table.getEditingCell().getRow());\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TableCellEditingTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.control;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import static org.junit.Assert.*;\n+\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n+import javafx.scene.control.TreeCell;\n+import javafx.scene.control.TreeItem;\n+\/\/import javafx.scene.control.TableColumn;\n+\/\/import javafx.scene.control.TreeTableColumn.CellEditEvent;\n+import javafx.scene.control.TreeView;\n+import javafx.scene.control.TreeView.EditEvent;\n+\n+\/**\n+ * Test TreeCell editing state updated on re-use (aka: updateIndex(old, new)).\n+ *\n+ * This test is parameterized in cellIndex and editingIndex.\n+ *\n+ *\/\n+@RunWith(Parameterized.class)\n+public class TreeCellEditingTest {\n+    private TreeCell<String> cell;\n+    private TreeView<String> tree;\n+    private ObservableList<TreeItem<String>> model;\n+\n+    private int cellIndex;\n+    private int editingIndex;\n+\n+\/\/--------------- change off editing index\n+\n+    @Test\n+    public void testOffEditingIndex() {\n+        cell.updateIndex(editingIndex);\n+        TreeItem<String> editingItem = tree.getTreeItem(editingIndex);\n+        tree.edit(editingItem);\n+        assertTrue(\"sanity: cell is editing\", cell.isEditing());\n+        cell.updateIndex(cellIndex);\n+        assertEquals(\"sanity: cell index changed\", cellIndex, cell.getIndex());\n+        assertFalse(\"cell must not be editing on update from editingIndex \" + editingIndex\n+                + \" to cellIndex \" + cellIndex, cell.isEditing());\n+    }\n+\n+    @Test\n+    public void testCancelOffEditingIndex() {\n+        cell.updateIndex(editingIndex);\n+        TreeItem<String> editingItem = tree.getTreeItem(editingIndex);\n+        tree.edit(editingItem);\n+        List<EditEvent<String>> events = new ArrayList<>();\n+        tree.setOnEditCancel(events::add);\n+        cell.updateIndex(cellIndex);\n+        assertEquals(\"sanity: tree editing unchanged\", editingItem, tree.getEditingItem());\n+        assertEquals(\"sanity: editingIndex unchanged\", editingIndex, tree.getRow(editingItem));\n+        assertEquals(\"cell must have fired edit cancel\", 1, events.size());\n+    }\n+\n+    \/**\n+     * Extracted from testCancelOffEditingIndex to formally ignore\n+     * FIXME: move the assert to the other method, once the issue is solved\n+     *\/\n+    @Ignore(\"JDK-8267094\")\n+    @Test\n+    public void testCancelOffEditingIndexEventIndex() {\n+        cell.updateIndex(editingIndex);\n+        TreeItem<String> editingItem = tree.getTreeItem(editingIndex);\n+        tree.edit(editingItem);\n+        List<EditEvent<String>> events = new ArrayList<>();\n+        tree.setOnEditCancel(events::add);\n+        cell.updateIndex(cellIndex);\n+        assertEquals(\"cancel on updateIndex from \" + editingIndex + \" to \" + cellIndex + \"\\n  \",\n+                editingItem, events.get(0).getTreeItem());\n+    }\n+\n+\/\/--------------- change to editing index\n+\n+    @Test\n+    public void testToEditingIndex() {\n+        cell.updateIndex(cellIndex);\n+        TreeItem<String> editingItem = tree.getTreeItem(editingIndex);\n+        tree.edit(editingItem);\n+        assertFalse(\"sanity: cell must not be editing\", cell.isEditing());\n+        cell.updateIndex(editingIndex);\n+        assertEquals(\"sanity: cell at editing index\", editingIndex, cell.getIndex());\n+        assertTrue(\"cell must be editing on update from \" + cellIndex\n+                + \" to editingIndex \" + editingIndex, cell.isEditing());\n+    }\n+\n+    @Test\n+    public void testStartEvent() {\n+        cell.updateIndex(cellIndex);\n+        TreeItem<String> editingItem = tree.getTreeItem(editingIndex);\n+        tree.edit(editingItem);\n+        List<EditEvent<String>> events = new ArrayList<>();\n+        tree.setOnEditStart(events::add);\n+        cell.updateIndex(editingIndex);\n+        assertEquals(\"cell must have fired edit start on update from \" + cellIndex + \" to \" + editingIndex,\n+                1, events.size());\n+        assertEquals(\"treeItem of start event \", editingItem, events.get(0).getTreeItem());\n+    }\n+\n+\/\/------------- parameterized\n+\n+    \/\/ Note: name property not supported before junit 4.11\n+    @Parameterized.Parameters \/\/(name = \"{index}: cellIndex {0}, editingIndex {1}\")\n+    public static Collection<Object[]> data() {\n+     \/\/ [0] is cellIndex, [1] is editingIndex\n+        Object[][] data = new Object[][] {\n+            {1, 2}, \/\/ normal\n+            {0, 1}, \/\/ zero cell index\n+            {1, 0}, \/\/ zero editing index\n+            {-1, 1}, \/\/ negative cell\n+        };\n+        return Arrays.asList(data);\n+    }\n+\n+    public TreeCellEditingTest(int cellIndex, int editingIndex) {\n+        this.cellIndex = cellIndex;\n+        this.editingIndex = editingIndex;\n+    }\n+\n+\/\/-------------- setup and sanity\n+\n+    \/**\n+     * Sanity: cell editing state updated when on editing index.\n+     *\/\n+    @Test\n+    public void testEditOnCellIndex() {\n+        cell.updateIndex(editingIndex);\n+        TreeItem<String> editingItem = tree.getTreeItem(editingIndex);\n+        tree.edit(editingItem);\n+        assertTrue(\"sanity: cell must be editing\", cell.isEditing());\n+    }\n+\n+    \/**\n+     * Sanity: cell editing state unchanged when off editing index.\n+     *\/\n+    @Test\n+    public void testEditOffCellIndex() {\n+        cell.updateIndex(cellIndex);\n+        TreeItem<String> editingItem = tree.getTreeItem(editingIndex);\n+        tree.edit(editingItem);\n+        assertFalse(\"sanity: cell editing must be unchanged\", cell.isEditing());\n+    }\n+\n+    \/**\n+     * Test do-nothing block in indexChanged (was RT-31165, is JDK-8123482)\n+     *\/\n+    @Test\n+    public void testUpdateSameIndexWhileEdititing() {\n+        cell.updateIndex(editingIndex);\n+        TreeItem<String> editingItem = tree.getTreeItem(editingIndex);\n+        tree.edit(editingItem);\n+        List<EditEvent<String>> events = new ArrayList<>();\n+        tree.setOnEditCancel(events::add);\n+        tree.setOnEditCommit(events::add);\n+        tree.setOnEditStart(events::add);\n+        cell.updateIndex(editingIndex);\n+        assertEquals(editingItem, tree.getEditingItem());\n+        assertTrue(cell.isEditing());\n+        assertEquals(0, events.size());\n+    }\n+\n+    \/**\n+     * Test do-nothing block in indexChanged (was RT-31165, is JDK-8123482)\n+     *\/\n+    @Test\n+    public void testUpdateSameIndexWhileNotEdititing() {\n+        cell.updateIndex(cellIndex);\n+        TreeItem<String> editingItem = tree.getTreeItem(editingIndex);\n+        tree.edit(editingItem);\n+        List<EditEvent<String>> events = new ArrayList<>();\n+        tree.setOnEditCancel(events::add);\n+        tree.setOnEditCommit(events::add);\n+        tree.setOnEditStart(events::add);\n+        cell.updateIndex(cellIndex);\n+        assertEquals(editingItem, tree.getEditingItem());\n+        assertFalse(cell.isEditing());\n+        assertEquals(0, events.size());\n+    }\n+\n+    @Before public void setup() {\n+        cell = new TreeCell<String>();\n+        model = FXCollections.observableArrayList(new TreeItem<String>(\"zero\"),\n+                new TreeItem<String>(\"one\"), new TreeItem<String>(\"two\"));\n+        TreeItem<String> root = new TreeItem<>(\"root\");\n+        root.getChildren().addAll(model);\n+        root.setExpanded(true);\n+        tree = new TreeView<String>(root);\n+        tree.setEditable(true);\n+        tree.setShowRoot(false);\n+        \/\/ make sure that focus change doesn't interfere with tests\n+        \/\/ (editing cell loosing focus will be canceled from focusListener in Cell)\n+        tree.getFocusModel().focus(-1);\n+        cell.updateTreeView(tree);\n+        assertFalse(\"sanity: cellIndex not same as editingIndex\", cellIndex == editingIndex);\n+        assertTrue(\"sanity: valid editingIndex\", editingIndex < model.size());\n+    }\n+\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeCellEditingTest.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -90,0 +90,2 @@\n+        assertEquals(\"cancel event index must be same as editingIndex\",\n+                editingIndex, table.getEditingCell().getRow());\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeTableCellEditingTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,12 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n@@ -29,0 +41,1 @@\n+import com.sun.javafx.scene.control.VirtualScrollBar;\n@@ -30,11 +43,0 @@\n-import javafx.beans.property.ReadOnlyStringWrapper;\n-import javafx.scene.control.*;\n-import test.javafx.collections.MockListObserver;\n-import test.com.sun.javafx.scene.control.infrastructure.KeyEventFirer;\n-import test.com.sun.javafx.scene.control.infrastructure.KeyModifier;\n-import test.com.sun.javafx.scene.control.infrastructure.StageLoader;\n-import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;\n-import javafx.scene.control.skin.TextFieldSkin;\n-import test.com.sun.javafx.scene.control.test.Employee;\n-import test.com.sun.javafx.scene.control.test.Person;\n-import test.com.sun.javafx.scene.control.test.RT_22463_Person;\n@@ -43,3 +45,2 @@\n-import java.util.*;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.stream.Collectors;\n+import static org.junit.Assert.*;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils.*;\n@@ -50,4 +51,0 @@\n-import static test.com.sun.javafx.scene.control.infrastructure.ControlTestUtils.assertStyleClassContains;\n-import static org.junit.Assert.*;\n-import static org.junit.Assert.assertEquals;\n-\n@@ -65,0 +62,12 @@\n+import javafx.scene.control.Button;\n+import javafx.scene.control.FocusModel;\n+import javafx.scene.control.IndexedCell;\n+import javafx.scene.control.MultipleSelectionModel;\n+import javafx.scene.control.SelectionMode;\n+import javafx.scene.control.SelectionModel;\n+import javafx.scene.control.TextField;\n+import javafx.scene.control.TreeCell;\n+import javafx.scene.control.TreeCellShim;\n+import javafx.scene.control.TreeItem;\n+import javafx.scene.control.TreeView;\n+import javafx.scene.control.TreeViewShim;\n@@ -67,1 +76,1 @@\n-import com.sun.javafx.scene.control.VirtualScrollBar;\n+import javafx.scene.control.skin.TextFieldSkin;\n@@ -76,4 +85,8 @@\n-\n-import org.junit.Before;\n-import org.junit.Ignore;\n-import org.junit.Test;\n+import test.com.sun.javafx.scene.control.infrastructure.KeyEventFirer;\n+import test.com.sun.javafx.scene.control.infrastructure.KeyModifier;\n+import test.com.sun.javafx.scene.control.infrastructure.StageLoader;\n+import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;\n+import test.com.sun.javafx.scene.control.test.Employee;\n+import test.com.sun.javafx.scene.control.test.Person;\n+import test.com.sun.javafx.scene.control.test.RT_22463_Person;\n+import test.javafx.collections.MockListObserver;\n@@ -122,0 +135,8 @@\n+        Thread.currentThread().setUncaughtExceptionHandler((thread, throwable) -> {\n+            if (throwable instanceof RuntimeException) {\n+                throw (RuntimeException)throwable;\n+            } else {\n+                Thread.currentThread().getThreadGroup().uncaughtException(thread, throwable);\n+            }\n+        });\n+\n@@ -160,0 +181,5 @@\n+    @After\n+    public void cleanup() {\n+        Thread.currentThread().setUncaughtExceptionHandler(null);\n+    }\n+\n@@ -3705,0 +3731,59 @@\n+\n+\n+\n+    \/**\n+     * Test that cell.cancelEdit can switch tree editing off\n+     * even if a subclass violates its contract.\n+     *\n+     * For details, see https:\/\/bugs.openjdk.java.net\/browse\/JDK-8265206\n+     *\n+     *\/\n+    @Test\n+    public void testMisbehavingCancelEditTerminatesEdit() {\n+        \/\/ setup for editing\n+        TreeCell<String> cell = new MisbehavingOnCancelTreeCell<>();\n+        treeView.setEditable(true);\n+        installChildren();\n+        cell.updateTreeView(treeView);\n+        \/\/ test editing: first round\n+        \/\/ switch cell off editing by table api\n+        int editingIndex = 1;\n+        int intermediate = 0;\n+        cell.updateIndex(editingIndex);\n+        TreeItem editingItem = treeView.getTreeItem(editingIndex);\n+        TreeItem intermediateTreeItem = treeView.getTreeItem(intermediate);\n+        treeView.edit(editingItem);\n+        assertTrue(\"sanity: \", cell.isEditing());\n+        try {\n+            treeView.edit(intermediateTreeItem);\n+        } catch (Exception ex) {\n+            \/\/ catching to test in finally\n+        } finally {\n+            assertFalse(\"cell must not be editing\", cell.isEditing());\n+            assertEquals(\"table must be editing at intermediate index\",\n+                    intermediateTreeItem, treeView.getEditingItem());\n+        }\n+        \/\/ test editing: second round\n+        \/\/ switch cell off editing by cell api\n+        treeView.edit(editingItem);\n+        assertTrue(\"sanity: \", cell.isEditing());\n+        try {\n+            cell.cancelEdit();\n+        } catch (Exception ex) {\n+            \/\/ catching to test in finally\n+        } finally {\n+            assertFalse(\"cell must not be editing\", cell.isEditing());\n+            assertNull(\"table editing must be cancelled by cell\", treeView.getEditingItem());\n+        }\n+    }\n+\n+    public static class MisbehavingOnCancelTreeCell<S> extends TreeCell<S> {\n+\n+        @Override\n+        public void cancelEdit() {\n+            super.cancelEdit();\n+            throw new RuntimeException(\"violating contract\");\n+        }\n+\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeViewTest.java","additions":108,"deletions":23,"binary":false,"changes":131,"status":"modified"}]}