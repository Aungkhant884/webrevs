{"files":[{"patch":"@@ -186,0 +186,1 @@\n+        int i = 0;\n@@ -187,1 +188,2 @@\n-        for (int i = 0, length = s.length(); i < length; ++i) {\n+        \/\/ Parse the input string and stop after the first mnemonic.\n+        for (int length = s.length(); i < length; ++i) {\n@@ -190,0 +192,6 @@\n+            } else if (isExtendedMnemonic(s, i)) {\n+                mnemonic = String.valueOf(s.charAt(i + 2));\n+                mnemonicIndex = i;\n+                extendedMnemonicText = s.substring(i + 1, i + 4);\n+                i += 4;\n+                break;\n@@ -192,1 +200,0 @@\n-                builder.append(c);\n@@ -196,4 +203,1 @@\n-            } else if (isExtendedMnemonic(s, i)) {\n-                mnemonic = String.valueOf(s.charAt(i + 2));\n-                extendedMnemonicText = s.substring(i + 1, i + 4);\n-                i += 3;\n+                break;\n@@ -205,0 +209,4 @@\n+        if (s.length() > i) {\n+            builder.append(s.substring(i));\n+        }\n+\n@@ -219,0 +227,2 @@\n+     * A simple mnemonic is any two-character string similar to \"_x\", where x is not an\n+     * underscore or a whitespace character.\n@@ -223,1 +233,2 @@\n-            && Character.isAlphabetic(s.charAt(position + 1));\n+            && s.charAt(position + 1) != MNEMONIC_SYMBOL\n+            && !Character.isWhitespace(s.charAt(position + 1));\n@@ -228,0 +239,2 @@\n+     * An extended mnemonic is any four-character string similar to \"_(x)\", where x is any\n+     * character except whitespace.\n@@ -233,1 +246,1 @@\n-            && Character.isAlphabetic(s.charAt(position + 2))\n+            && !Character.isWhitespace(s.charAt(position + 2))\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TextBinding.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.scene.control.behavior;\n+\n+import com.sun.javafx.scene.control.behavior.TextBinding;\n+import javafx.scene.input.KeyCombination;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+\n+public class TextBindingTest {\n+\n+    private static void assertKeyCombination(String expected, KeyCombination actual) {\n+        if (com.sun.javafx.PlatformUtil.isMac()) {\n+            assertSame(KeyCombination.ModifierValue.DOWN, actual.getMeta());\n+        } else {\n+            assertSame(KeyCombination.ModifierValue.DOWN, actual.getAlt());\n+        }\n+\n+        assertEquals(expected, ((TextBinding.MnemonicKeyCombination)actual).getCharacter());\n+    }\n+\n+    @Test\n+    public void testSimpleMnemonicLetter() {\n+        var binding = new TextBinding(\"foo _bar\");\n+        assertEquals(\"foo bar\", binding.getText());\n+        assertEquals(\"b\", binding.getMnemonic());\n+        assertKeyCombination(\"b\", binding.getMnemonicKeyCombination());\n+        assertEquals(4, binding.getMnemonicIndex());\n+    }\n+\n+    @Test\n+    public void testSimpleMnemonicDigit() {\n+        var binding = new TextBinding(\"foo _1 bar\");\n+        assertEquals(\"foo 1 bar\", binding.getText());\n+        assertEquals(\"1\", binding.getMnemonic());\n+        assertKeyCombination(\"1\", binding.getMnemonicKeyCombination());\n+        assertEquals(4, binding.getMnemonicIndex());\n+    }\n+\n+    @Test\n+    public void testExtendedMnemonicLetter() {\n+        var binding = new TextBinding(\"foo _(x)bar\");\n+        assertEquals(\"foo bar\", binding.getText());\n+        assertEquals(\"x\", binding.getMnemonic());\n+        assertKeyCombination(\"x\", binding.getMnemonicKeyCombination());\n+        assertEquals(4, binding.getMnemonicIndex());\n+    }\n+\n+    @Test\n+    public void testExtendedMnemonicUnderscore() {\n+        var binding = new TextBinding(\"foo _(_)bar\");\n+        assertEquals(\"foo bar\", binding.getText());\n+        assertEquals(\"_\", binding.getMnemonic());\n+        assertKeyCombination(\"_\", binding.getMnemonicKeyCombination());\n+        assertEquals(4, binding.getMnemonicIndex());\n+    }\n+\n+    @Test\n+    public void testExtendedMnemonicClosingBrace() {\n+        var binding = new TextBinding(\"foo _())bar\");\n+        assertEquals(\"foo bar\", binding.getText());\n+        assertEquals(\")\", binding.getMnemonic());\n+        assertKeyCombination(\")\", binding.getMnemonicKeyCombination());\n+        assertEquals(4, binding.getMnemonicIndex());\n+    }\n+\n+    @Test\n+    public void testEscapedMnemonicSymbol() {\n+        var binding = new TextBinding(\"foo __bar\");\n+        assertEquals(\"foo _bar\", binding.getText());\n+        assertNull(binding.getMnemonic());\n+        assertNull(binding.getMnemonicKeyCombination());\n+        assertEquals(-1, binding.getMnemonicIndex());\n+    }\n+\n+    @Test\n+    public void testWhitespaceIsNotProcessedAsExtendedMnemonic() {\n+        var binding = new TextBinding(\"foo _( ) bar\");\n+        assertEquals(\"foo ( ) bar\", binding.getText());\n+        assertEquals(\"(\", binding.getMnemonic());\n+        assertKeyCombination(\"(\", binding.getMnemonicKeyCombination());\n+        assertEquals(4, binding.getMnemonicIndex());\n+    }\n+\n+    @Test\n+    public void testUnderscoreNotFollowedByAlphabeticCharIsNotAMnemonic() {\n+        var binding = new TextBinding(\"foo_ bar\");\n+        assertEquals(\"foo_ bar\", binding.getText());\n+        assertNull(binding.getMnemonic());\n+        assertNull(binding.getMnemonicKeyCombination());\n+        assertEquals(-1, binding.getMnemonicIndex());\n+    }\n+\n+    @Test\n+    public void testUnderscoreAtEndOfTextIsNotAMnemonic() {\n+        var binding = new TextBinding(\"foo_\");\n+        assertEquals(\"foo_\", binding.getText());\n+        assertNull(binding.getMnemonic());\n+        assertNull(binding.getMnemonicKeyCombination());\n+        assertEquals(-1, binding.getMnemonicIndex());\n+    }\n+\n+    @Test\n+    public void testMnemonicParsingStopsAfterFirstSimpleMnemonic() {\n+        var binding = new TextBinding(\"_foo _bar _qux\");\n+        assertEquals(\"foo _bar _qux\", binding.getText());\n+        assertEquals(\"f\", binding.getMnemonic());\n+        assertKeyCombination(\"f\", binding.getMnemonicKeyCombination());\n+        assertEquals(0, binding.getMnemonicIndex());\n+    }\n+\n+    @Test\n+    public void testMnemonicParsingStopsAfterFirstExtendedMnemonic() {\n+        var binding = new TextBinding(\"_(x)foo _bar _qux\");\n+        assertEquals(\"foo _bar _qux\", binding.getText());\n+        assertEquals(\"x\", binding.getMnemonic());\n+        assertKeyCombination(\"x\", binding.getMnemonicKeyCombination());\n+        assertEquals(0, binding.getMnemonicIndex());\n+    }\n+\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/control\/behavior\/TextBindingTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -2067,1 +2067,1 @@\n-    public void mnemonicSymbolIsRemovedFromDisplayedText() {\n+    public void testMnemonicIsProcessedWhenParsingIsEnabled() {\n@@ -2076,1 +2076,1 @@\n-    public void extendedMnemonicIsRemovedFromDisplayedText() {\n+    public void testExtendedMnemonicIsProcessedWhenParsingIsEnabled() {\n@@ -2085,3 +2085,3 @@\n-    public void escapedMnemonicSymbolIsRetainedInDisplayedText() {\n-        label.setMnemonicParsing(true);\n-        label.setText(\"foo __bar\");\n+    public void testMnemonicsAreNotProcessedWhenParsingIsDisabled() {\n+        label.setMnemonicParsing(false);\n+        label.setText(\"foo _bar\");\n@@ -2094,1 +2094,1 @@\n-    public void escapedMnemonicSymbolIsNotProcessedWhenMnemonicParsingIsDisabled() {\n+    public void testEscapedMnemonicSymbolIsNotProcessedWhenParsingIsDisabled() {\n@@ -2102,18 +2102,0 @@\n-    @Test\n-    public void underscoreNotFollowedByAlphabeticCharIsNotAMnemonic() {\n-        label.setMnemonicParsing(true);\n-        label.setText(\"foo_ bar\");\n-        label.autosize();\n-        skin.updateDisplayedText();\n-        assertEquals(\"foo_ bar\", LabelSkinBaseShim.getText(label).getText());\n-    }\n-\n-    @Test\n-    public void underscoreAtEndOfTextIsNotAMnemonic() {\n-        label.setMnemonicParsing(true);\n-        label.setText(\"foo_\");\n-        label.autosize();\n-        skin.updateDisplayedText();\n-        assertEquals(\"foo_\", LabelSkinBaseShim.getText(label).getText());\n-    }\n-\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/LabelSkinTest.java","additions":6,"deletions":24,"binary":false,"changes":30,"status":"modified"}]}