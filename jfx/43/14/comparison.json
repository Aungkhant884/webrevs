{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,6 @@\n+    @Override\n+    protected void updatePeerImpl(Node node) {\n+        super.updatePeerImpl(node);\n+        pointLightAccessor.doUpdatePeer(node);\n+    }\n+\n@@ -69,0 +75,1 @@\n+        void doUpdatePeer(Node node);\n@@ -70,1 +77,0 @@\n-\n@@ -72,1 +78,0 @@\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/PointLightHelper.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,3 @@\n- * TODO: 3D - Need documentation\n+ * The peer of the {@code PointLight} class. Holds the default values of {@code PointLight}'s\n+ * properties and updates the visuals via {@link NGNode#visualsChanged} when one of the current\n+ * values changes. The peer receives its changes by {@code PointLight.doUpdatePeer} calls.\n@@ -33,0 +35,9 @@\n+    \/** Constant attenuation factor default value *\/\n+    private static final float DEFAULT_CA = 1;\n+    \/** Linear attenuation factor default value *\/\n+    private static final float DEFAULT_LA = 0;\n+    \/** Quadratic attenuation factor default value *\/\n+    private static final float DEFAULT_QA = 0;\n+    \/** Max range default value *\/\n+    private static final float DEFAULT_MAX_RANGE = Float.POSITIVE_INFINITY;\n+\n@@ -36,0 +47,72 @@\n+    public static float getDefaultCa() {\n+        return DEFAULT_CA;\n+    }\n+\n+    public static float getDefaultLa() {\n+        return DEFAULT_LA;\n+    }\n+\n+    public static float getDefaultQa() {\n+        return DEFAULT_QA;\n+    }\n+\n+    public static float getDefaultMaxRange() {\n+        return DEFAULT_MAX_RANGE;\n+    }\n+\n+\n+    private float ca = DEFAULT_CA;\n+\n+    public float getCa() {\n+        return ca;\n+    }\n+\n+    public void setCa(float ca) {\n+        if (this.ca != ca) {\n+            this.ca = ca;\n+            visualsChanged();\n+        }\n+    }\n+\n+\n+    private float la = DEFAULT_LA;\n+\n+    public float getLa() {\n+        return la;\n+    }\n+\n+    public void setLa(float la) {\n+        if (this.la != la) {\n+            this.la = la;\n+            visualsChanged();\n+        }\n+    }\n+\n+\n+    private float qa = DEFAULT_QA;\n+\n+    public float getQa() {\n+        return qa;\n+    }\n+\n+    public void setQa(float qa) {\n+        if (this.qa != qa) {\n+            this.qa = qa;\n+            visualsChanged();\n+        }\n+    }\n+\n+\n+    private float maxRange = DEFAULT_MAX_RANGE;\n+\n+    public float getMaxRange() {\n+        return maxRange;\n+    }\n+\n+    public void setMaxRange(float maxRange) {\n+        maxRange = maxRange < 0 ? 0 : maxRange;\n+        if (this.maxRange != maxRange) {\n+            this.maxRange = maxRange;\n+            visualsChanged();\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/sg\/prism\/NGPointLight.java","additions":85,"deletions":2,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,1 +112,1 @@\n-            \/\/ is a single point white point light at camera eye position.\n+            \/\/ is a single white point light at camera eye position.\n@@ -119,1 +119,5 @@\n-                                   1.0f, 1.0f, 1.0f, 1.0f);\n+                                   1.0f, 1.0f, 1.0f, 1.0f,\n+                                   NGPointLight.getDefaultCa(),\n+                                   NGPointLight.getDefaultLa(),\n+                                   NGPointLight.getDefaultQa(),\n+                                   NGPointLight.getDefaultMaxRange());\n@@ -135,1 +139,1 @@\n-                     * There is a limit on the number of lights that can affect\n+                     * There is a limit on the number of point lights that can affect\n@@ -158,1 +162,5 @@\n-                                    rL, gL, bL, 1.0f);\n+                                    rL, gL, bL, 1.0f,\n+                                    light.getCa(),\n+                                    light.getLa(),\n+                                    light.getQa(),\n+                                    light.getMaxRange());\n@@ -176,1 +184,4 @@\n-                meshView.setPointLight(pointLightIdx++, 0, 0, 0, 0, 0, 0, 0);\n+                meshView.setPointLight(pointLightIdx++,\n+                        0, 0, 0, \/\/ x y z\n+                        0, 0, 0, 0, \/\/ r g b w\n+                        1, 0, 0, 0); \/\/ ca la qa maxRange\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/sg\/prism\/NGShape3D.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,2 @@\n-            float r, float g, float b, float w);\n+            float r, float g, float b, float w,\n+            float ca, float la, float qa, float maxRange);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/MeshView.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -429,1 +429,2 @@\n-            int index, float x, float y, float z, float r, float g, float b, float w);\n+            int index, float x, float y, float z, float r, float g, float b, float w,\n+            float ca, float la, float qa, float maxRange);\n@@ -554,2 +555,3 @@\n-    void setPointLight(long nativeMeshView, int index, float x, float y, float z, float r, float g, float b, float w) {\n-        nSetPointLight(pContext, nativeMeshView, index, x, y, z, r, g, b, w);\n+    void setPointLight(long nativeMeshView, int index, float x, float y, float z,\n+            float r, float g, float b, float w, float ca, float la, float qa, float maxRange) {\n+        nSetPointLight(pContext, nativeMeshView, index, x, y, z, r, g, b, w, ca, la, qa, maxRange);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/d3d\/D3DContext.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -84,1 +84,2 @@\n-    public void setPointLight(int index, float x, float y, float z, float r, float g, float b, float w) {\n+    public void setPointLight(int index, float x, float y, float z, float r, float g, float b, float w,\n+            float ca, float la, float qa, float maxRange) {\n@@ -87,1 +88,1 @@\n-            context.setPointLight(nativeHandle, index, x, y, z, r, g, b, w);\n+            context.setPointLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, maxRange);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/d3d\/D3DMeshView.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -452,2 +452,3 @@\n-    void setPointLight(long nativeHandle, int index, float x, float y, float z, float r, float g, float b, float w) {\n-        glContext.setPointLight(nativeHandle, index, x, y, z, r, g, b, w);\n+    void setPointLight(long nativeHandle, int index, float x, float y, float z, float r, float g, float b, float w,\n+            float ca, float la, float qa, float maxRange) {\n+        glContext.setPointLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, maxRange);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/ES2Context.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+    float ca, la, qa, maxRange;\n@@ -36,1 +37,1 @@\n-    ES2Light(float ix, float iy, float iz, float ir, float ig, float ib, float iw) {\n+    ES2Light(float ix, float iy, float iz, float ir, float ig, float ib, float iw, float ca, float la, float qa, float maxRange) {\n@@ -44,0 +45,4 @@\n+        this.ca = ca;\n+        this.la = la;\n+        this.qa = qa;\n+        this.maxRange = maxRange;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/ES2Light.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -104,1 +104,2 @@\n-    public void setPointLight(int index, float x, float y, float z, float r, float g, float b, float w) {\n+    public void setPointLight(int index, float x, float y, float z, float r, float g, float b, float w,\n+            float ca, float la, float qa, float maxRange) {\n@@ -107,2 +108,2 @@\n-            lights[index] = new ES2Light(x, y, z, r, g, b, w);\n-            context.setPointLight(nativeHandle, index, x, y, z, r, g, b, w);\n+            lights[index] = new ES2Light(x, y, z, r, g, b, w, ca, la, qa, maxRange);\n+            context.setPointLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, maxRange);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/ES2MeshView.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -207,1 +207,1 @@\n-        for(ES2Light light : meshView.getPointLights()) {\n+        for (ES2Light light : meshView.getPointLights()) {\n@@ -211,0 +211,2 @@\n+                shader.setConstant(\"lights[\" + i + \"].attn\", light.ca, light.la, light.qa);\n+                shader.setConstant(\"lights[\" + i + \"].range\", light.maxRange);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/ES2PhongShader.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,1 +255,2 @@\n-            int index, float x, float y, float z, float r, float g, float b, float w);\n+            int index, float x, float y, float z, float r, float g, float b, float w,\n+            float ca, float la, float qa, float maxRange);\n@@ -811,2 +812,3 @@\n-    void setPointLight(long nativeMeshViewInfo, int index, float x, float y, float z, float r, float g, float b, float w) {\n-        nSetPointLight(nativeCtxInfo, nativeMeshViewInfo, index, x, y, z, r, g, b, w);\n+    void setPointLight(long nativeMeshViewInfo, int index, float x, float y, float z, float r, float g, float b, float w,\n+            float ca, float la, float qa, float maxRange) {\n+        nSetPointLight(nativeCtxInfo, nativeMeshViewInfo, index, x, y, z, r, g, b, w, ca, la, qa, maxRange);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/GLContext.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import javafx.beans.property.DoubleProperty;\n@@ -49,0 +50,1 @@\n+import javafx.beans.property.SimpleDoubleProperty;\n@@ -280,0 +282,14 @@\n+    \/**\n+     * For use by implementing subclasses. Treat as protected.\n+     *\n+     * Creates and returns a SimpleDoubleProperty with an invalidation scheme.\n+     *\/\n+    DoubleProperty getLightDoubleProperty(String name, double initialValue) {\n+        return new SimpleDoubleProperty(this, name, initialValue) {\n+            @Override\n+            protected void invalidated() {\n+                NodeHelper.markDirty(LightBase.this, DirtyBits.NODE_LIGHT);\n+            }\n+        };\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/LightBase.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import com.sun.javafx.scene.NodeHelper;\n@@ -33,0 +32,2 @@\n+\n+import javafx.beans.property.DoubleProperty;\n@@ -34,0 +35,1 @@\n+import javafx.scene.paint.PhongMaterial;\n@@ -36,3 +38,17 @@\n- * Defines a point light source object. A light source that has a\n- * fixed point in space and radiates light equally in all directions\n- * away from itself.\n+ * A light source that radiates light equally in all directions away from itself. The location of the light\n+ * source is a single point in space. Any pixel within the range of the light will be illuminated by it,\n+ * unless it belongs to a {@code Shape3D} outside of its {@code scope}.\n+ * <p>\n+ * The light's intensity can be set to decrease over distance by attenuating it. The attenuation formula\n+ * <p>\n+ * {@code attn = 1 \/ (ca + la * dist + qa * dist^2)}\n+ * <p>\n+ * defines 3 coefficients: {@code ca}, {@code la}, and {@code qa}, which control the constant, linear, and\n+ * quadratic behaviors of intensity falloff over distance, respectively. The effective color of the light\n+ * at a given point in space is {@code color * attn}. It is possible, albeit unrealistic, to specify negative\n+ * values to attenuation coefficients. This allows the resulting attenuation factor to be negative, which\n+ * results in the light's color being subtracted from the material instead of added to it, thus creating a\n+ * \"shadow caster\".\n+ * <p>\n+ * For a realistic effect, {@code maxRange} should be set to a distance at which the attenuation is close to 0\n+ * as this will give a soft cutoff.\n@@ -41,0 +57,1 @@\n+ * @see PhongMaterial\n@@ -49,0 +66,5 @@\n+\n+            @Override\n+            public void doUpdatePeer(Node node) {\n+                ((PointLight) node).doUpdatePeer();\n+            }\n@@ -53,1 +75,1 @@\n-        \/\/ To initialize the class helper at the begining each constructor of this class\n+        \/\/ To initialize the class helper at the beginning each constructor of this class\n@@ -58,1 +80,1 @@\n-     * Creates a new instance of {@code PointLight} class with a default Color.WHITE light source.\n+     * Creates a new instance of {@code PointLight} class with a default {@code Color.WHITE} light source.\n@@ -73,0 +95,121 @@\n+    \/**\n+     * The maximum range of this {@code PointLight}. For a pixel to be affected by this light, its distance to the\n+     * light source must be less than or equal to the light's maximum range. Any negative value will be treated as 0.\n+     * <p>\n+     * Lower {@code maxRange} values can give better performance as pixels outside the range of the light\n+     * will not require complex calculation. The attenuation formula can be used to calculate a realistic\n+     * {@code maxRange} value by finding the distance where the attenuation is close enough to 0.\n+     * <p>\n+     * Nodes that are inside the light's range can still be excluded from the light's effect by removing them from\n+     * its {@link #getScope() scope} (or including them in its {@link #getExclusionScope() exclusion scope}). If a\n+     * node is known to always be outside of the light's range, it is more performant to exclude it from its scope.\n+     *\n+     * @defaultValue {@code Double.POSITIVE_INFINITY}\n+     * @since 16\n+     *\/\n+    private DoubleProperty maxRange;\n+\n+    public final void setMaxRange(double value) {\n+        maxRangeProperty().set(value);\n+    }\n+\n+    private static final double DEFAULT_MAX_RANGE = NGPointLight.getDefaultMaxRange();\n+\n+    public final double getMaxRange() {\n+        return maxRange == null ? DEFAULT_MAX_RANGE : maxRange.get();\n+    }\n+\n+    public final DoubleProperty maxRangeProperty() {\n+        if (maxRange == null) {\n+            maxRange = getLightDoubleProperty(\"maxRange\", DEFAULT_MAX_RANGE);\n+        }\n+        return maxRange;\n+    }\n+\n+    \/**\n+     * The constant attenuation coefficient. This is the term {@code ca} in the attenuation formula:\n+     * <p>\n+     * {@code attn = 1 \/ (ca + la * dist + qa * dist^2)}\n+     * <p>\n+     * where {@code dist} is the distance between the light source and the pixel.\n+     *\n+     * @defaultValue 1\n+     * @since 16\n+     *\/\n+    private DoubleProperty constantAttenuation;\n+\n+    public final void setConstantAttenuation(double value) {\n+        constantAttenuationProperty().set(value);\n+    }\n+\n+    private static final double DEFAULT_CONSTANT_ATTENUATION = NGPointLight.getDefaultCa();\n+\n+    public final double getConstantAttenuation() {\n+        return constantAttenuation == null ? DEFAULT_CONSTANT_ATTENUATION : constantAttenuation.get();\n+    }\n+\n+    public final DoubleProperty constantAttenuationProperty() {\n+        if (constantAttenuation == null) {\n+            constantAttenuation = getLightDoubleProperty(\"constantAttenuation\", DEFAULT_CONSTANT_ATTENUATION);\n+        }\n+        return constantAttenuation;\n+    }\n+\n+    \/**\n+     * The linear attenuation coefficient. This is the term {@code la} in the attenuation formula:\n+     * <p>\n+     * {@code attn = 1 \/ (ca + la * dist + qa * dist^2)}\n+     * <p>\n+     * where {@code dist} is the distance between the light source and the pixel.\n+     *\n+     * @defaultValue 0\n+     * @since 16\n+     *\/\n+    private DoubleProperty linearAttenuation;\n+\n+    public final void setLinearAttenuation(double value) {\n+        linearAttenuationProperty().set(value);\n+    }\n+\n+    private static final double DEFAULT_LINEAR_ATTENUATION = NGPointLight.getDefaultLa();\n+\n+    public final double getLinearAttenuation() {\n+        return linearAttenuation == null ? DEFAULT_LINEAR_ATTENUATION : linearAttenuation.get();\n+    }\n+\n+    public final DoubleProperty linearAttenuationProperty() {\n+        if (linearAttenuation == null) {\n+            linearAttenuation = getLightDoubleProperty(\"linearAttenuation\", DEFAULT_LINEAR_ATTENUATION);\n+        }\n+        return linearAttenuation;\n+    }\n+\n+    \/**\n+     * The quadratic attenuation coefficient. This is the term {@code qa} in the attenuation formula:\n+     * <p>\n+     * {@code attn = 1 \/ (ca + la * dist + qa * dist^2)}\n+     * <p>\n+     * where {@code dist} is the distance between the light source and the pixel.\n+     *\n+     * @defaultValue 0\n+     * @since 16\n+     *\/\n+    private DoubleProperty quadraticAttenuation;\n+\n+    public final void setQuadraticAttenuation(double value) {\n+        quadraticAttenuationProperty().set(value);\n+    }\n+\n+    private static final double DEFAULT_QUADRATIC_ATTENUATION = NGPointLight.getDefaultQa();\n+\n+    public final double getQuadraticAttenuation() {\n+        return quadraticAttenuation == null ? DEFAULT_QUADRATIC_ATTENUATION : quadraticAttenuation.get();\n+    }\n+\n+    public final DoubleProperty quadraticAttenuationProperty() {\n+        if (quadraticAttenuation == null) {\n+            quadraticAttenuation = getLightDoubleProperty(\"quadraticAttenuation\", DEFAULT_QUADRATIC_ATTENUATION);\n+        }\n+        return quadraticAttenuation;\n+    }\n+\n@@ -79,0 +222,10 @@\n+\n+    private void doUpdatePeer() {\n+        if (isDirty(DirtyBits.NODE_LIGHT)) {\n+            NGPointLight peer = getPeer();\n+            peer.setCa((float) getConstantAttenuation());\n+            peer.setLa((float) getLinearAttenuation());\n+            peer.setQa((float) getQuadraticAttenuation());\n+            peer.setMaxRange((float) getMaxRange());\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/PointLight.java","additions":160,"deletions":7,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -519,1 +519,2 @@\n-        jfloat x, jfloat y, jfloat z, jfloat r, jfloat g, jfloat b, jfloat w)\n+        jfloat x, jfloat y, jfloat z, jfloat r, jfloat g, jfloat b, jfloat w,\n+        jfloat ca, jfloat la, jfloat qa, jfloat range)\n@@ -524,2 +525,1 @@\n-\n-    meshView->setPointLight(index, x, y, z, r, g, b, w);\n+    meshView->setPointLight(index, x, y, z, r, g, b, w, ca, la, qa, range);\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DContext.cc","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,4 @@\n+    attenuation[0] = 1;\n+    attenuation[1] = 0;\n+    attenuation[2] = 0;\n+    maxRange = 0;\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DLight.cc","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+\/\/  void setRange(float r);\n@@ -42,0 +43,2 @@\n+    float attenuation[3]; \/\/ ca, la, qa\n+    float maxRange;\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DLight.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019 Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,2 @@\n-    float r, float g, float b, float w) {\n+        float r, float g, float b, float w,\n+        float ca, float la, float qa, float maxRange) {\n@@ -86,0 +87,4 @@\n+        lights[index].attenuation[0] = ca;\n+        lights[index].attenuation[1] = la;\n+        lights[index].attenuation[2] = qa;\n+        lights[index].maxRange = maxRange;\n@@ -157,2 +162,4 @@\n-    float lightsColor[12];\n-    for (int i = 0, j = 0; i < 3; i++) {\n+    float lightsColor[12];       \/\/ 3 lights x (3 color + 1 padding)\n+    float lightsAttenuation[12]; \/\/ 3 lights x (3 attenuation factors + 1 padding)\n+    float lightsRange[12];       \/\/ 3 lights x (1 maxRange + 3 padding)\n+    for (int i = 0, c = 0, a = 0, r = 0; i < 3; i++) {\n@@ -160,4 +167,14 @@\n-        lightsColor[j++] = lights[i].color[0] * w;\n-        lightsColor[j++] = lights[i].color[1] * w;\n-        lightsColor[j++] = lights[i].color[2] * w;\n-        lightsColor[j++] = 1;\n+        lightsColor[c++] = lights[i].color[0] * w;\n+        lightsColor[c++] = lights[i].color[1] * w;\n+        lightsColor[c++] = lights[i].color[2] * w;\n+        lightsColor[c++] = 1;\n+\n+        lightsAttenuation[a++] = lights[i].attenuation[0];\n+        lightsAttenuation[a++] = lights[i].attenuation[1];\n+        lightsAttenuation[a++] = lights[i].attenuation[2];\n+        lightsAttenuation[a++] = 0;\n+\n+        lightsRange[r++] = lights[i].maxRange;\n+        lightsRange[r++] = 0;\n+        lightsRange[r++] = 0;\n+        lightsRange[r++] = 0;\n@@ -170,0 +187,10 @@\n+    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_LIGHT_ATTENUATION, lightsAttenuation, 3));\n+    if (!status) {\n+        cout << \"D3DMeshView.render() - SetPixelShaderConstantF (PSR_LIGHT_ATTENUATION) failed !!!\" << endl;\n+        return;\n+    }\n+    status = SUCCEEDED(device->SetPixelShaderConstantF(PSR_LIGHT_RANGE, lightsRange, 3));\n+    if (!status) {\n+        cout << \"D3DMeshView.render() - SetPixelShaderConstantF (PSR_LIGHT_RANGE) failed !!!\" << endl;\n+        return;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DMeshView.cc","additions":35,"deletions":8,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,2 @@\n-    float r, float g, float b, float w);\n+        float r, float g, float b, float w,\n+        float ca, float la, float qa, float maxRange);\n@@ -53,1 +54,1 @@\n-    int  numLights;\n+    int numLights;\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DMeshView.h","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-\/\/ we have 32 constants for ps 2.0\n+\/\/ we have 224 float constants for ps 3.0\n@@ -45,1 +45,3 @@\n-#define PSR_LIGHTCOLOR 4\n+#define PSR_LIGHTCOLOR 4        \/\/ 3 lights + 2 reserve\n+#define PSR_LIGHT_ATTENUATION 9 \/\/ 3 lights + 2 reserve\n+#define PSR_LIGHT_RANGE 14      \/\/ 3 lights + 2 reserve\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DPhongShader.h","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,3 @@\n-float4 gLightColor[numMaxLights] : register(c4);  \/\/ [c4 .. c8]\n+float4 gLightColor[numMaxLights] : register(c4); \/\/ [c4 .. c8]\n+float4 gLightAttenuation[numMaxLights] : register(c9); \/\/ [c9 .. c13]\n+float4 gLightRange[numMaxLights] : register(c14); \/\/ [c14 .. c18]\n@@ -34,1 +36,1 @@\n-float4 gSomethingElse : register(c9);\n+float4 gSomethingElse : register(c19);\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/psConstants.h","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,4 +66,12 @@\n-    for (int i=_s; i<_e; i++) {\n-        float3 l = normalize(L[i].xyz);\n-        d += saturate(dot(n,l))*gLightColor[i].xyz;\n-        s += pow(saturate(dot(-refl, l)), power)*gLightColor[i].xyz;\n+    for (int i = _s; i < _e; i++) {\n+        float dist = length(L[i].xyz);\n+        if (dist <= gLightRange[i].x) {\n+            float ca = gLightAttenuation[i].x;\n+            float la = gLightAttenuation[i].y;\n+            float qa = gLightAttenuation[i].z;\n+            float3 attenuatedColor = gLightColor[i].xyz \/ (ca + la * dist + qa * dist * dist);\n+\n+            float3 l = normalize(L[i].xyz);\n+            d += saturate(dot(n, l)) * attenuatedColor;\n+            s += pow(saturate(dot(-refl, l)), power) * attenuatedColor;\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/psMath.h","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -2125,0 +2125,4 @@\n+    meshViewInfo->pointLightAttenuation[0] = 1;\n+    meshViewInfo->pointLightAttenuation[1] = 0;\n+    meshViewInfo->pointLightAttenuation[2] = 0;\n+    meshViewInfo->pointLightMaxRange = 0;\n@@ -2268,1 +2272,2 @@\n-        jint index, jfloat x, jfloat y, jfloat z, jfloat r, jfloat g, jfloat b, jfloat w)\n+        jint index, jfloat x, jfloat y, jfloat z, jfloat r, jfloat g, jfloat b, jfloat w,\n+        jfloat ca, jfloat la, jfloat qa, jfloat maxRange)\n@@ -2284,0 +2289,4 @@\n+    meshViewInfo->pointLightAttenuation[0] = ca;\n+    meshViewInfo->pointLightAttenuation[1] = la;\n+    meshViewInfo->pointLightAttenuation[2] = qa;\n+    meshViewInfo->pointLightMaxRange = maxRange;\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-es2\/GLContext.c","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -383,0 +383,2 @@\n+    GLfloat pointLightAttenuation[3];\n+    GLfloat pointLightMaxRange;\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-es2\/PrismES2Defs.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,2 @@\n+    vec3 attn;\n+    float range;\n@@ -98,1 +100,1 @@\n-     mat4 mvpMatrix = viewProjectionMatrix * worldMatrix;\n+    mat4 mvpMatrix = viewProjectionMatrix * worldMatrix;\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/prism\/es2\/glsl\/main.vert","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+    vec3 attn;\n+    float range;\n@@ -71,1 +73,0 @@\n-    gl_FragColor = vec4(0.0,0.0,0.0,1.0);\n@@ -76,2 +77,0 @@\n-    vec3 n = apply_normal();\n-\n@@ -81,1 +80,0 @@\n-    vec3 refl = reflect(normalize(eyePos), n);\n@@ -83,1 +81,0 @@\n-    float power = specular.a;\n@@ -85,3 +82,8 @@\n-    vec3 l = normalize(lightTangentSpacePositions[0].xyz);\n-    d = clamp(dot(n,l), 0.0, 1.0)*(lights[0].color).rgb;\n-    s = pow(clamp(dot(-refl, l), 0.0, 1.0), power)*lights[0].color.rgb;\n+    float maxRange = lights[0].range;\n+    float dist = length(lightTangentSpacePositions[0].xyz);\n+    if (dist <= maxRange) {\n+        vec3 n = apply_normal();\n+        vec3 refl = reflect(normalize(eyePos), n);\n+        vec3 l = normalize(lightTangentSpacePositions[0].xyz);\n+\n+        float power = specular.a;\n@@ -89,1 +91,5 @@\n-    vec3 rez = (ambientColor+d) * diffuse.xyz + s*specular.rgb;\n+        vec3 attenuatedColor = (lights[0].color).rgb \/ (lights[0].attn.x + lights[0].attn.y * dist + lights[0].attn.z * dist * dist);\n+        d = clamp(dot(n, l), 0.0, 1.0) * attenuatedColor;\n+        s = pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;\n+    }\n+    vec3 rez = (ambientColor + d) * diffuse.xyz + s * specular.rgb;\n@@ -92,1 +98,1 @@\n-    gl_FragColor = vec4(clamp(rez, 0.0, 1.0) , diffuse.a);\n+    gl_FragColor = vec4(clamp(rez, 0.0, 1.0), diffuse.a);\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/prism\/es2\/glsl\/main1Light.frag","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+    vec3 attn;\n+    float range;\n@@ -71,1 +73,0 @@\n-    gl_FragColor = vec4(0.0,0.0,0.0,1.0);\n@@ -77,0 +78,1 @@\n+    vec3 refl = reflect(normalize(eyePos), n);\n@@ -81,1 +83,0 @@\n-    vec3 refl = reflect(normalize(eyePos), n);\n@@ -85,9 +86,18 @@\n-    vec3 l = normalize(lightTangentSpacePositions[0].xyz);\n-    d = clamp(dot(n,l), 0.0, 1.0)*(lights[0].color).rgb;\n-    s = pow(clamp(dot(-refl, l), 0.0, 1.0), power)*lights[0].color.rgb;\n-\n-    l = normalize(lightTangentSpacePositions[1].xyz);\n-    d += clamp(dot(n,l), 0.0, 1.0)*(lights[1].color).rgb;\n-    s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * lights[1].color.rgb;\n-\n-    vec3 rez = (ambientColor+d) * diffuse.xyz + s*specular.rgb;\n+    float maxRange = lights[0].range;\n+    float dist = length(lightTangentSpacePositions[0].xyz);\n+    if (dist <= maxRange) {\n+        vec3 l = normalize(lightTangentSpacePositions[0].xyz);\n+        vec3 attenuatedColor = (lights[0].color).rgb \/ (lights[0].attn.x + lights[0].attn.y * dist + lights[0].attn.z * dist * dist);\n+        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;\n+        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;\n+    }\n+\n+    maxRange = lights[1].range;\n+    dist = length(lightTangentSpacePositions[1].xyz);\n+    if (dist <= maxRange) {\n+        vec3 l = normalize(lightTangentSpacePositions[1].xyz);\n+        vec3 attenuatedColor = (lights[1].color).rgb \/ (lights[1].attn.x + lights[1].attn.y * dist + lights[1].attn.z * dist * dist);\n+        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;\n+        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;\n+    }\n+    vec3 rez = (ambientColor + d) * diffuse.xyz + s * specular.rgb;\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/prism\/es2\/glsl\/main2Lights.frag","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+    vec3 attn;\n+    float range;\n@@ -71,1 +73,0 @@\n-    gl_FragColor = vec4(0.0,0.0,0.0,1.0);\n@@ -77,0 +78,1 @@\n+    vec3 refl = reflect(normalize(eyePos), n);\n@@ -81,1 +83,0 @@\n-    vec3 refl = reflect(normalize(eyePos), n);\n@@ -85,13 +86,28 @@\n-    vec3 l = normalize(lightTangentSpacePositions[0].xyz);\n-    d = clamp(dot(n,l), 0.0, 1.0)*(lights[0].color).rgb;\n-    s = pow(clamp(dot(-refl, l), 0.0, 1.0), power) * lights[0].color.rgb;\n-\n-    l = normalize(lightTangentSpacePositions[1].xyz);\n-    d += clamp(dot(n,l), 0.0, 1.0)*(lights[1].color).rgb;\n-    s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * lights[1].color.rgb;\n-\n-    l = normalize(lightTangentSpacePositions[2].xyz);\n-    d += clamp(dot(n,l), 0.0, 1.0)*(lights[2].color).rgb;\n-    s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * lights[2].color.rgb;\n-\n-    vec3 rez = (ambientColor+d) * diffuse.xyz + s*specular.rgb;\n+    float maxRange = lights[0].range;\n+    float dist = length(lightTangentSpacePositions[0].xyz);\n+    if (dist <= maxRange) {\n+        vec3 l = normalize(lightTangentSpacePositions[0].xyz);\n+        vec3 attenuatedColor = (lights[0].color).rgb \/ (lights[0].attn.x + lights[0].attn.y * dist + lights[0].attn.z * dist * dist);\n+        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;\n+        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;\n+    }\n+\n+    maxRange = lights[1].range;\n+    dist = length(lightTangentSpacePositions[1].xyz);\n+    if (dist <= maxRange) {\n+        vec3 l = normalize(lightTangentSpacePositions[1].xyz);\n+        vec3 attenuatedColor = (lights[1].color).rgb \/ (lights[1].attn.x + lights[1].attn.y * dist + lights[1].attn.z * dist * dist);\n+        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;\n+        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;\n+    }\n+\n+    maxRange = lights[2].range;\n+    dist = length(lightTangentSpacePositions[2].xyz);\n+    if (dist <= maxRange) {\n+        vec3 l = normalize(lightTangentSpacePositions[2].xyz);\n+        vec3 attenuatedColor = (lights[2].color).rgb \/ (lights[2].attn.x + lights[2].attn.y * dist + lights[2].attn.z * dist * dist);\n+        d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;\n+        s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;\n+    }\n+\n+    vec3 rez = (ambientColor + d) * diffuse.xyz + s * specular.rgb;\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/prism\/es2\/glsl\/main3Lights.frag","additions":31,"deletions":15,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package attenuation;\n+\n+import javafx.beans.property.DoubleProperty;\n+import javafx.scene.PointLight;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.Slider;\n+import javafx.scene.control.TextField;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.VBox;\n+import javafx.util.converter.NumberStringConverter;\n+\n+\/**\n+ * A {@code LightingSample} with additional controls for light attenuation.\n+ *\/\n+public class AttenLightingSample extends LightingSample {\n+\n+    @Override\n+    protected VBox addLightControls(PointLight light) {\n+        var vbox = super.addLightControls(light);\n+        var range = createSliderControl(\"range\", light.maxRangeProperty(), 0, 100, light.getMaxRange());\n+        var c = createSliderControl(\"constant\", light.constantAttenuationProperty(), -1, 1, light.getConstantAttenuation());\n+        var lc = createSliderControl(\"linear\", light.linearAttenuationProperty(), -1, 1, light.getLinearAttenuation());\n+        var qc = createSliderControl(\"quadratic\", light.quadraticAttenuationProperty(), -1, 1, light.getQuadraticAttenuation());\n+        vbox.getChildren().addAll(range, c, lc, qc);\n+        return vbox;\n+    }\n+\n+    private HBox createSliderControl(String name, DoubleProperty property, double min, double max, double start) {\n+        var slider = new Slider(min, max, start);\n+        slider.setShowTickMarks(true);\n+        slider.setShowTickLabels(true);\n+        property.bindBidirectional(slider.valueProperty());\n+        var tf = new TextField();\n+        tf.textProperty().bindBidirectional(slider.valueProperty(), new NumberStringConverter());\n+        tf.setMaxWidth(50);\n+        return new HBox(5, new Label(name), slider, tf);\n+    }\n+\n+    public static void main(String[] args) {\n+        launch(args);\n+    }\n+}\n","filename":"tests\/performance\/3DLighting\/attenuation\/AttenLightingSample.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package attenuation;\n+\n+import javafx.beans.property.BooleanProperty;\n+import javafx.beans.property.DoubleProperty;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.beans.property.SimpleDoubleProperty;\n+import javafx.scene.Group;\n+import javafx.scene.PerspectiveCamera;\n+import javafx.scene.PointLight;\n+import javafx.scene.SceneAntialiasing;\n+import javafx.scene.SubScene;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.input.ScrollEvent;\n+import javafx.scene.layout.Pane;\n+import javafx.scene.transform.Rotate;\n+import javafx.scene.transform.Translate;\n+\n+class CameraScene3D extends Pane {\n+\n+    public DoubleProperty xPan = new SimpleDoubleProperty();\n+    public DoubleProperty yPan = new SimpleDoubleProperty(-10);\n+    public DoubleProperty zoom = new SimpleDoubleProperty();\n+    public DoubleProperty zAngle = new SimpleDoubleProperty();\n+    public DoubleProperty isometricAngle = new SimpleDoubleProperty();\n+\n+    public DoubleProperty panSensitivity = new SimpleDoubleProperty(1);\n+    public DoubleProperty zoomSensitivity = new SimpleDoubleProperty(1);\n+    public DoubleProperty zRotationSensitivity = new SimpleDoubleProperty(1);\n+    public BooleanProperty isZoomTotal = new SimpleBooleanProperty();\n+\n+    protected PerspectiveCamera camera = new PerspectiveCamera(true);\n+\n+    public DoubleProperty farClip = new SimpleDoubleProperty(camera.getFarClip());\n+    public DoubleProperty nearClip = new SimpleDoubleProperty(camera.getNearClip());\n+    public DoubleProperty fieldOfView = new SimpleDoubleProperty(camera.getFieldOfView());\n+    public BooleanProperty verticalFOV = new SimpleBooleanProperty(camera.isVerticalFieldOfView());\n+\n+    protected PointLight camLight = new PointLight();\n+    public BooleanProperty camLightOn = new SimpleBooleanProperty(camLight.isLightOn());\n+\n+    public Group rootGroup = new Group();\n+\n+    public CameraScene3D() {\n+        setupCamera();\n+        createScenes();\n+        setUIBindings();\n+    }\n+\n+    private void setupCamera() {\n+        Translate panTranslation = new Translate();\n+        panTranslation.xProperty().bind(xPan);\n+        panTranslation.yProperty().bind(yPan);\n+\n+        Translate zoomTranslation = new Translate();\n+        zoomTranslation.zProperty().bind(zoom);\n+\n+        Rotate zRotation = new Rotate(0, Rotate.Y_AXIS);\n+        zRotation.angleProperty().bind(zAngle);\n+\n+        Rotate isometricRotation = new Rotate(0, Rotate.X_AXIS);\n+        isometricRotation.angleProperty().bind(isometricAngle);\n+\n+        camera.farClipProperty().bind(farClip);\n+        camera.nearClipProperty().bind(nearClip);\n+        camera.fieldOfViewProperty().bind(fieldOfView);\n+        camera.verticalFieldOfViewProperty().bind(verticalFOV);\n+\n+        camera.getTransforms().addAll(panTranslation, zRotation, isometricRotation, zoomTranslation);\n+\n+        camLight.lightOnProperty().bind(camLightOn);\n+        camLight.getTransforms().addAll(camera.getTransforms());\n+        camLightOn.set(false);\n+\n+        rootGroup.getTransforms().addAll();\n+        rootGroup.getChildren().add(camLight);\n+        rootGroup.setId(\"root group\");\n+    }\n+\n+    private void createScenes() {\n+        var aaScene = new SubScene(rootGroup, 0, 0, true, SceneAntialiasing.BALANCED);\n+        aaScene.setCamera(camera);\n+        aaScene.widthProperty().bind(widthProperty());\n+        aaScene.heightProperty().bind(heightProperty());\n+        aaScene.setOnMouseEntered(e -> aaScene.requestFocus());\n+        getChildren().setAll(aaScene);\n+    }\n+\n+    private double startX, startY, curX, curY;\n+\n+    private final void setUIBindings() {\n+        setOnRotate(e -> rotate(e.getAngle()));\n+        setOnZoom(e -> zoom(isZoomTotal.get() ? e.getTotalZoomFactor() : e.getZoomFactor()));\n+        setOnScroll(e -> {\n+            \/\/ touch scroll for moving the board\n+            if (e.getEventType() == ScrollEvent.SCROLL_STARTED)\n+                pan(e.getDeltaX(), e.getDeltaY());\n+            \/\/ mouse scroll for zoom\n+            else\n+                zoom(e.getDeltaY());\n+        });\n+\n+        setOnMousePressed(e -> {\n+            startX = curX = e.getX();\n+            startY = curY = e.getY();\n+        });\n+\n+        setOnMouseDragged(e -> {\n+            startX = curX;\n+            startY = curY;\n+            curX = e.getX();\n+            curY = e.getY();\n+            double deltaX = curX - startX;\n+            double deltaY = curY - startY;\n+            if (e.getButton() == MouseButton.PRIMARY) {\n+                pan(deltaX, deltaY);\n+            } else if (e.getButton() == MouseButton.SECONDARY) {\n+                boolean positiveX = curX > getWidth() \/ 2;\n+                boolean positiveY = curY > getHeight() \/ 2;\n+                deltaX = positiveY ? -deltaX : deltaX;\n+                deltaY = positiveX ? deltaY : -deltaY;\n+                rotate((deltaX + deltaY)\/2);\n+            }\n+        });\n+    }\n+\n+    private final double scaleFactor = 500;\n+\n+    private void pan(double deltaX, double deltaY) {\n+        double angle = Math.toRadians(zAngle.get());\n+        double cosA = Math.cos(angle);\n+        double sinA = Math.sin(angle);\n+        double rotatedDeltaX = deltaX *  cosA + deltaY * sinA;\n+        double rotatedDeltaY = deltaX * -sinA + deltaY * cosA;\n+        double panFactor = panSensitivity.get() * zoom.get() \/ scaleFactor;\n+        double newX = xPan.get() + rotatedDeltaX * panFactor;\n+        double newY = yPan.get() + rotatedDeltaY * panFactor;\n+        xPan.set(newX);\n+        yPan.set(newY);\n+    }\n+\n+    private void zoom(double amount) {\n+        zoom.set(zoom.get() - amount * zoomSensitivity.get() * zoom.get() \/ scaleFactor);\n+    }\n+\n+    private void rotate(double amount) {\n+        zAngle.set(zAngle.get() - amount * zRotationSensitivity.get());\n+    }\n+}\n","filename":"tests\/performance\/3DLighting\/attenuation\/CameraScene3D.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package attenuation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javafx.scene.AmbientLight;\n+import javafx.scene.PointLight;\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.PhongMaterial;\n+import javafx.scene.shape.MeshView;\n+import javafx.scene.shape.Shape3D;\n+import javafx.scene.shape.Sphere;\n+import javafx.scene.shape.TriangleMesh;\n+\n+class Environment extends CameraScene3D {\n+\n+    private final PointLight light1 = new PointLight(Color.RED);\n+    private final PointLight light2 = new PointLight(Color.BLUE);\n+    private final PointLight light3 = new PointLight(Color.MAGENTA);\n+    final PointLight[] lights = {light1, light2, light3};\n+\n+    private Shape3D currentShape;\n+\n+    private final AmbientLight worldLight = new AmbientLight();\n+\n+    Environment() {\n+        farClip.set(1000);\n+        zoom.set(-350);\n+\n+        for (var light : lights) {\n+            light.setTranslateZ(-50);\n+            var lightRep = new Sphere(2);\n+            lightRep.setMaterial(new PhongMaterial(light.getColor()));\n+            lightRep.translateXProperty().bind(light.translateXProperty());\n+            lightRep.translateYProperty().bind(light.translateYProperty());\n+            lightRep.translateZProperty().bind(light.translateZProperty());\n+            rootGroup.getChildren().addAll(light, lightRep);\n+        }\n+        light1.setTranslateX(40);\n+        light2.setTranslateX(-40);\n+        light1.setUserData(\"RED\");\n+        light2.setUserData(\"BLUE\");\n+        light3.setUserData(\"MAGENTA\");\n+\n+        rootGroup.getChildren().add(worldLight);\n+        rootGroup.setMouseTransparent(true);\n+    }\n+\n+    Sphere createSphere(int subdivisions) {\n+        return new Sphere(50, subdivisions);\n+    }\n+\n+    MeshView createMeshView(int quadNum) {\n+        \/\/ Points and texCoords array defining a single quad that will\n+        \/\/ be referenced by all pairs of triangles in the faces array\n+        final float[] points = {\n+            -75.0f,  75.0f, 0.0f,\n+             75.0f,  75.0f, 0.0f,\n+             75.0f, -75.0f, 0.0f,\n+            -75.0f, -75.0f, 0.0f\n+        };\n+        final float[] texCoords = {\n+            0.0f, 0.0f,\n+            1.0f, 0.0f,\n+            1.0f, 1.0f,\n+            0.0f, 1.0f\n+        };\n+        \/\/ List of faces defining a single quad (pair of triangles).\n+        \/\/ This is replicated for the desired number of quads\n+        var face = List.of(\n+            0, 0, 1, 1, 2, 2,\n+            0, 0, 2, 2, 3, 3\n+        );\n+\n+        var faces = new ArrayList<Integer>(quadNum * face.size());\n+        for (int i = 0; i < quadNum; i++) {\n+            faces.addAll(face);\n+        }\n+\n+        var mesh = new TriangleMesh();\n+        mesh.getPoints().setAll(points);\n+        mesh.getTexCoords().setAll(texCoords);\n+        int[] array = faces.stream().mapToInt(i -> i).toArray();\n+        mesh.getFaces().setAll(array);\n+\n+        var mv = new MeshView(mesh);\n+        return mv;\n+    }\n+\n+    void switchTo(Shape3D node) {\n+        worldLight.getExclusionScope().remove(currentShape);\n+        worldLight.getExclusionScope().add(node);\n+        rootGroup.getChildren().remove(currentShape);\n+        rootGroup.getChildren().add(node);\n+        currentShape = node;\n+    }\n+}\n","filename":"tests\/performance\/3DLighting\/attenuation\/Environment.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package attenuation;\n+\n+import javafx.animation.AnimationTimer;\n+\n+final class FPSCounter extends AnimationTimer {\n+\n+    private int skipFrames = 100;\n+    private long lastTime = -1;\n+    private long elapsedTime;\n+    private int elapsedFrames;\n+    private long totalElapsedTime;\n+    private int totalElapsedFrames;\n+\n+    @Override\n+    public void handle(long now) {\n+        if (skipFrames > 0) {\n+            --skipFrames;\n+            return;\n+        }\n+\n+        if (lastTime < 0) {\n+            lastTime = System.nanoTime();\n+            elapsedTime = 0;\n+            elapsedFrames = 0;\n+            totalElapsedTime = 0;\n+            totalElapsedFrames = 0;\n+            return;\n+        }\n+\n+        long currTime = System.nanoTime();\n+        elapsedTime += currTime - lastTime;\n+        elapsedFrames += 1;\n+        totalElapsedTime += currTime - lastTime;\n+        totalElapsedFrames += 1;\n+\n+        double elapsedSeconds = (double) elapsedTime \/ 1e9;\n+        double totalElapsedSeconds = (double) totalElapsedTime \/ 1e9;\n+        if (elapsedSeconds >= 5.0) {\n+            double fps = elapsedFrames \/ elapsedSeconds;\n+            System.out.println();\n+            System.out.println(\"instant fps: \" + fps);\n+            double avgFps = totalElapsedFrames \/ totalElapsedSeconds;\n+            System.out.println(\"average fps: \" + avgFps);\n+            System.out.flush();\n+            elapsedTime = 0;\n+            elapsedFrames = 0;\n+        }\n+\n+        lastTime = currTime;\n+    }\n+\n+    void reset() {\n+        skipFrames = 100;\n+        lastTime = -1;\n+        elapsedTime = 0;\n+        elapsedFrames = 0;\n+        totalElapsedTime = 0;\n+        totalElapsedFrames = 0;\n+        System.out.println();\n+        System.out.println(\" --------------------- \");\n+    }\n+}\n","filename":"tests\/performance\/3DLighting\/attenuation\/FPSCounter.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package attenuation;\n+\n+import javafx.animation.Animation;\n+import javafx.animation.TranslateTransition;\n+import javafx.application.Application;\n+import javafx.scene.PointLight;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.CheckBox;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.Separator;\n+import javafx.scene.control.Slider;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.Priority;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.shape.Shape3D;\n+import javafx.stage.Stage;\n+import javafx.util.Duration;\n+import javafx.util.converter.NumberStringConverter;\n+\n+\/**\n+ * A sample application for measuring FPS for various 3D nodes with environmental lighting.\n+ * <p>\n+ * <b>Important<\/b>: make sure that no other application on your system is rendering heavy graphics, like videos, to a screen,\n+ * as this will corrupt the measurement.\n+ *\/\n+public class LightingSample extends Application {\n+\n+    private final Environment environment = new Environment();\n+    private final TranslateTransition animation = createAnimation();\n+    private final FPSCounter fpsCouner = new FPSCounter();\n+\n+    @Override\n+    public void start(Stage stage) throws Exception {\n+        environment.setStyle(\"-fx-background-color: teal\");\n+\n+        var subdivisionSlider = new Slider(10, 200, 60);\n+        subdivisionSlider.setMajorTickUnit(10);\n+        setupSlier(subdivisionSlider);\n+\n+        var subdivisionLabel = new Label();\n+        subdivisionLabel.textProperty().bindBidirectional(subdivisionSlider.valueProperty(), new NumberStringConverter(\"#\"));\n+\n+        var sphere = new Button(\"Sphere\");\n+        sphere.setOnAction(e -> switchTo(environment.createSphere((int) subdivisionSlider.getValue())));\n+\n+        var quadSlider = new Slider(500, 10_000, 1000);\n+        quadSlider.setMajorTickUnit(500);\n+        setupSlier(quadSlider);\n+\n+        var quadLabel = new Label();\n+        quadLabel.textProperty().bindBidirectional(quadSlider.valueProperty(), new NumberStringConverter(\"#\"));\n+\n+        var mesh = new Button(\"Mesh\");\n+        mesh.setOnAction(e -> switchTo(environment.createMeshView((int) quadSlider.getValue())));\n+\n+        var sphereBox = new HBox(sphere, subdivisionSlider, subdivisionLabel);\n+        var meshBox = new HBox(mesh, quadSlider, quadLabel);\n+\n+        var controls = new VBox(sphereBox, meshBox);\n+        for (var light : environment.lights) {\n+            controls.getChildren().add(addLightControls(light));\n+        }\n+\n+        var hBox = new HBox(controls, environment);\n+        HBox.setHgrow(environment, Priority.ALWAYS);\n+        stage.setScene(new Scene(hBox));\n+        stage.setWidth(1100);\n+        stage.setHeight(735);\n+        stage.show();\n+    }\n+\n+    private void setupSlier(Slider slider) {\n+        slider.setMinorTickCount(0);\n+        slider.setShowTickLabels(true);\n+        slider.setShowTickMarks(true);\n+        slider.setSnapToTicks(true);\n+    }\n+\n+    protected VBox addLightControls(PointLight light) {\n+        var lightOn = new CheckBox(\"On\/Off\");\n+        lightOn.setSelected(true);\n+        light.lightOnProperty().bind(lightOn.selectedProperty());\n+        return new VBox(new Separator(), new Label(light.getUserData() + \" light\"), lightOn);\n+    }\n+\n+   private TranslateTransition createAnimation() {\n+        var anim = new TranslateTransition(Duration.seconds(2));\n+        anim.setAutoReverse(true);\n+        anim.setCycleCount(Animation.INDEFINITE);\n+        anim.setFromZ(150);\n+        anim.setToZ(0);\n+        return anim;\n+    }\n+\n+    private void switchTo(Shape3D node) {\n+        fpsCouner.stop();\n+        fpsCouner.reset();\n+        environment.switchTo(node);\n+        animation.setNode(node);\n+        animation.playFromStart();\n+        fpsCouner.start();\n+    }\n+\n+    public static void main(String[] args) {\n+        launch(args);\n+    }\n+}\n","filename":"tests\/performance\/3DLighting\/attenuation\/LightingSample.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.lighting3D;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assume.assumeTrue;\n+import static org.junit.Assert.assertEquals;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import javafx.application.Application;\n+import javafx.application.ConditionalFeature;\n+import javafx.application.Platform;\n+import javafx.scene.Group;\n+import javafx.scene.PointLight;\n+import javafx.scene.Scene;\n+import javafx.scene.paint.Color;\n+import javafx.scene.shape.Box;\n+import javafx.stage.Stage;\n+import javafx.stage.WindowEvent;\n+import test.util.Util;\n+\n+public class PointLightAttenuationTest {\n+\n+    \/\/ 1d\/255 is the smallest color resolution, but we use 10d\/255 to avoid precision problems\n+    private static final double DELTA = 10d\/255;\n+    private static final int LIGTH_DIST = 60;\n+    private static final int SAMPLE_DIST = 60;\n+\n+    private static CountDownLatch startupLatch;\n+    private static Stage stage;\n+    private static PointLight light = new PointLight(Color.BLUE);\n+    private static Box box = new Box(150, 150, 1);\n+\n+    public static void main(String[] args) throws Exception {\n+        initFX();\n+    }\n+\n+    @BeforeClass\n+    public static void initFX() throws Exception {\n+        assumeTrue(Platform.isSupported(ConditionalFeature.SCENE3D));\n+        startupLatch = new CountDownLatch(1);\n+        new Thread(() -> Application.launch(TestApp.class, (String[])null)).start();\n+        assertTrue(\"Timeout waiting for FX runtime to start\", startupLatch.await(15, TimeUnit.SECONDS));\n+    }\n+\n+    public static class TestApp extends Application {\n+\n+        @Override\n+        public void start(Stage mainStage) {\n+            stage = mainStage;\n+            light.setTranslateZ(-LIGTH_DIST);\n+            var root = new Group(light, box);\n+            var scene = new Scene(root);\n+            stage.setScene(scene);\n+            stage.addEventHandler(WindowEvent.WINDOW_SHOWN, e -> Platform.runLater(startupLatch::countDown));\n+            stage.show();\n+        }\n+    }\n+\n+    @Test\n+    public void testAttenuation() {\n+        Util.runAndWait(() -> {\n+            \/\/ Since there appears to be a bug in snapshot with subscene, we are taking a snapshot of the scene and not\n+            \/\/ the box, so the center of the box will be at the top left, (0, 0), of the image, and the light is\n+            \/\/ straight in front. Without attenuation, at (0, 0) it will give its full color. At (SAMPLE_DIST, 0) and\n+            \/\/ LIGTH_DIST == SAMPLE_DIST, it will give cos(45) = 1\/sqrt(2) of its color.\n+            var snapshot = box.getScene().snapshot(null);\n+            double nonAttenBlueCenter = snapshot.getPixelReader().getColor(0, 0).getBlue();\n+            double nonAttenBlueDiag = snapshot.getPixelReader().getColor(SAMPLE_DIST, 0).getBlue();\n+            assertEquals(\"Wrong color value\", 1, nonAttenBlueCenter, DELTA);\n+            assertEquals(\"Wrong color value\", 1\/Math.sqrt(2), nonAttenBlueDiag, DELTA);\n+\n+            double diagDist = Math.sqrt(LIGTH_DIST * LIGTH_DIST + SAMPLE_DIST * SAMPLE_DIST);\n+\n+            light.setLinearAttenuation(0.01);\n+            double attnCenter = 1 \/ (1 + 0.01 * LIGTH_DIST);\n+            double attnDiag = 1 \/ (1 + 0.01 * diagDist);\n+            snapshot = box.getScene().snapshot(null);\n+            double attenBlueCenter = snapshot.getPixelReader().getColor(0, 0).getBlue();\n+            double attenBlueDiag = snapshot.getPixelReader().getColor(SAMPLE_DIST, 0).getBlue();\n+            assertEquals(\"Wrong color value\", nonAttenBlueCenter * attnCenter, attenBlueCenter, DELTA);\n+            assertEquals(\"Wrong color value\", nonAttenBlueDiag * attnDiag, attenBlueDiag, DELTA);\n+\n+            light.setLinearAttenuation(0);\n+            light.setQuadraticAttenuation(0.01);\n+            attnCenter = 1 \/ (1 + 0.01 * LIGTH_DIST * LIGTH_DIST);\n+            attnDiag = 1 \/ (1 + 0.01 * diagDist * diagDist);\n+            snapshot = box.getScene().snapshot(null);\n+            attenBlueCenter = snapshot.getPixelReader().getColor(0, 0).getBlue();\n+            attenBlueDiag = snapshot.getPixelReader().getColor(SAMPLE_DIST, 0).getBlue();\n+            assertEquals(\"Wrong color value\", nonAttenBlueCenter * attnCenter, attenBlueCenter, DELTA);\n+            assertEquals(\"Wrong color value\", nonAttenBlueDiag * attnDiag, attenBlueDiag, DELTA);\n+\n+            light.setQuadraticAttenuation(0);\n+            light.setMaxRange((LIGTH_DIST + diagDist) \/ 2);\n+            snapshot = box.getScene().snapshot(null);\n+            nonAttenBlueCenter = snapshot.getPixelReader().getColor(0, 0).getBlue();\n+            nonAttenBlueDiag = snapshot.getPixelReader().getColor(SAMPLE_DIST, 0).getBlue();\n+            assertEquals(\"Wrong color value, should be in range\", 1, nonAttenBlueCenter, DELTA);\n+            assertEquals(\"Wrong color value, should be out of range\", 0, nonAttenBlueDiag, DELTA);\n+        });\n+    }\n+\n+    @AfterClass\n+    public static void teardown() {\n+        Platform.runLater(() -> {\n+            stage.hide();\n+            Platform.exit();\n+        });\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/lighting3D\/PointLightAttenuationTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"}]}