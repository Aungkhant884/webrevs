{"files":[{"patch":"@@ -196,0 +196,1 @@\n+        private boolean nestedEmission;\n@@ -339,0 +340,6 @@\n+            nestedEmission = true;\n+\n+            if (locked) {\n+                return;\n+            }\n+\n@@ -346,5 +353,11 @@\n-                for (int i = 0; i < curInvalidationSize; i++) {\n-                    try {\n-                        curInvalidationList[i].invalidated(observable);\n-                    } catch (Exception e) {\n-                        Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n+                T oldValue = currentValue;\n+\n+                while (nestedEmission) {\n+                    nestedEmission = false;\n+\n+                    for (int i = 0; i < curInvalidationSize; i++) {\n+                        try {\n+                            curInvalidationList[i].invalidated(observable);\n+                        } catch (Exception e) {\n+                            Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n+                        }\n@@ -352,11 +365,13 @@\n-                }\n-                if (curChangeSize > 0) {\n-                    final T oldValue = currentValue;\n-                    currentValue = observable.getValue();\n-                    final boolean changed = (currentValue == null)? (oldValue != null) : !currentValue.equals(oldValue);\n-                    if (changed) {\n-                        for (int i = 0; i < curChangeSize; i++) {\n-                            try {\n-                                curChangeList[i].changed(observable, oldValue, currentValue);\n-                            } catch (Exception e) {\n-                                Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n+                    if (curChangeSize > 0) {\n+                        currentValue = observable.getValue();\n+\n+                        T newValue = currentValue;\n+                        boolean changed = (newValue == null) ? (oldValue != null) : !newValue.equals(oldValue);\n+\n+                        if (changed) {\n+                            for (int i = 0; i < curChangeSize; i++) {\n+                                try {\n+                                    curChangeList[i].changed(observable, oldValue, newValue);\n+                                } catch (Exception e) {\n+                                    Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n+                                }\n@@ -365,0 +380,2 @@\n+\n+                        oldValue = newValue;\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ExpressionHelper.java","additions":33,"deletions":16,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -51,2 +51,7 @@\n-     * In general, it is considered bad practice to modify the observed value in\n-     * this method.\n+     * Changing the observed value in this method will result in all listeners\n+     * being notified of this latest change after the initial change\n+     * notification (with the original old and values) has completed.\n+     * The listeners that still needed to be notified may see a new value that\n+     * differs from a call to {@link ObservableValue#getValue}. All listeners are\n+     * then notified again with an old value equal to the initial new value,\n+     * and a new value with the latest value.\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/ChangeListener.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.ArrayList;\n@@ -43,0 +44,1 @@\n+import java.util.List;\n@@ -452,0 +454,63 @@\n+    @Test\n+    public void testChangeValueWhenLocked() {\n+        List<String> recording1 = new ArrayList<>();\n+        List<String> recording2 = new ArrayList<>();\n+        List<String> recording3 = new ArrayList<>();\n+\n+        final ChangeListener<Integer> recordingChangeListener1 = new ChangeListener<>() {\n+            @Override\n+            public void changed(ObservableValue<? extends Integer> observable, Integer oldValue, Integer newValue) {\n+                recording1.add(oldValue + \" -> \" + newValue);\n+            }\n+        };\n+\n+        final ChangeListener<Integer> recordingChangeListener2 = new ChangeListener<>() {\n+            @Override\n+            public void changed(ObservableValue<? extends Integer> observable, Integer oldValue, Integer newValue) {\n+                recording2.add(oldValue + \" -> \" + newValue);\n+            }\n+        };\n+\n+        final ChangeListener<Integer> changingListener = new ChangeListener<>() {\n+            @Override\n+            public void changed(ObservableValue<? extends Integer> observable, Integer oldValue, Integer newValue) {\n+                recording3.add(oldValue + \" -> \" + newValue);\n+                if(newValue % 2 != 0) {\n+                    ExpressionHelperTest.this.observable.set(newValue + 1);\n+                    ExpressionHelper.fireValueChangedEvent(helper);\n+                }\n+            }\n+        };\n+\n+        observable.set(1);\n+        ExpressionHelper.fireValueChangedEvent(helper);  \/\/ doing this before adding any listeners avoids an exception being logged\n+\n+        helper = ExpressionHelper.addListener(helper, observable, recordingChangeListener1);\n+        helper = ExpressionHelper.addListener(helper, observable, changingListener);\n+        helper = ExpressionHelper.addListener(helper, observable, recordingChangeListener2);\n+\n+        observable.set(2);\n+        ExpressionHelper.fireValueChangedEvent(helper);\n+\n+        assertEquals(\"1 -> 2\", recording1.get(0));\n+        assertEquals(\"1 -> 2\", recording2.get(0));\n+        assertEquals(1, recording1.size());\n+        assertEquals(1, recording2.size());\n+\n+        recording1.clear();\n+        recording2.clear();\n+\n+        observable.set(3);\n+        ExpressionHelper.fireValueChangedEvent(helper);\n+\n+        System.out.println(recording1);\n+        System.out.println(recording3);\n+        System.out.println(recording2);\n+        assertEquals(\"2 -> 3\", recording1.get(0));\n+        assertEquals(\"2 -> 3\", recording2.get(0));\n+        assertEquals(\"3 -> 4\", recording1.get(1));\n+        assertEquals(\"3 -> 4\", recording2.get(1));\n+        assertEquals(2, recording1.size());\n+        assertEquals(2, recording2.size());\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ExpressionHelperTest.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,402 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.beans;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.binding.Bindings;\n+import javafx.beans.property.Property;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.beans.property.SimpleDoubleProperty;\n+import javafx.beans.property.SimpleFloatProperty;\n+import javafx.beans.property.SimpleIntegerProperty;\n+import javafx.beans.property.SimpleLongProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+\n+public class ObservableValueTest {\n+    private static final int[] PATTERN = new int[] {1, 2, 0, 50, 3, 7};\n+\n+    \/*\n+     * ObservableValue cases to test:\n+     *\/\n+    static Stream<Arguments> inputs() {\n+        List<Case<?, ?>> cases = List.of(\n+            \/\/ cases for properties:\n+            Case.of(new SimpleBooleanProperty(), true, false),\n+            Case.of(new SimpleIntegerProperty(), 42, 47),\n+            Case.of(new SimpleLongProperty(), 42L, 47L),\n+            Case.of(new SimpleFloatProperty(), 0.5f, 1.0f),\n+            Case.of(new SimpleDoubleProperty(), 0.5, 1.0),\n+            Case.of(new SimpleStringProperty(), \"A\", \"B\"),\n+            Case.of(new SimpleObjectProperty<>(), \"A\", \"B\"),\n+\n+            \/\/ cases for bindings:\n+            Case.of(new SimpleBooleanProperty(), false, true, p -> p.not(), (p, v) -> p.setValue(!v)),\n+            Case.of(new SimpleIntegerProperty(), 42, 47, p -> p.add(2), (p, v) -> p.setValue(v.intValue() - 2)),\n+            Case.of(new SimpleLongProperty(), 42L, 47L, p -> p.add(2), (p, v) -> p.setValue(v.longValue() - 2)),\n+            Case.of(new SimpleFloatProperty(), 0.5f, 1.0f, p -> p.add(2), (p, v) -> p.setValue(v.floatValue() - 2)),\n+            Case.of(new SimpleDoubleProperty(), 0.5, 1.0, p -> p.add(2), (p, v) -> p.setValue(v.doubleValue() - 2)),\n+            Case.of(new SimpleStringProperty(), \"A!\", \"B!\", p -> p.concat(\"!\"), (p, v) -> p.setValue(v.substring(0, 1))),\n+            Case.of(new SimpleObjectProperty<>(), \"A!\", \"B!\", p -> Bindings.createObjectBinding(() -> (p.get() + \"!\").intern(), p), (p, v) -> p.setValue(v.substring(0, 1).intern())),  \/\/ intern() used to make sure ObjectBinding equality check works for this test\n+\n+            \/\/ cases for lazy bindings:\n+            Case.of(new SimpleObjectProperty<>(), 10, 12, p -> p.map(x -> x * 2), (p, v) -> p.setValue(v \/ 2))\n+        );\n+\n+        return cases.stream().map(c -> Arguments.of(new Action<>(c.observableValue), c.primaryValue, c.alternativeValue, c.valueSetter));\n+    }\n+\n+    \/*\n+     * Tests if the embedded ObservableValue correctly rejects null listener add\/removals.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldRejectNullListener(Action<T> action) {\n+        assertThrows(NullPointerException.class, () -> action.addListener((InvalidationListener)null));\n+        assertThrows(NullPointerException.class, () -> action.addListener((ChangeListener<T>)null));\n+        assertThrows(NullPointerException.class, () -> action.removeListener((InvalidationListener)null));\n+        assertThrows(NullPointerException.class, () -> action.removeListener((ChangeListener<T>)null));\n+    }\n+\n+    \/*\n+     * Tests if the embedded ObservableValue correctly ignores removal of non-existing listeners, regardless\n+     * of how many listeners are currently registered. As the same ObservableValue is used throughout the\n+     * test, also stresses the add\/remove listener code.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldIgnoreRemovingNonExistingListener(Action<T> action) {\n+        for(int[] counts : new Combinations(PATTERN)) {\n+            int invalidationListenerCount = counts[0];\n+            int changeListenerCount = counts[1];\n+\n+            action.setListenerCounts(invalidationListenerCount, changeListenerCount);\n+\n+            action.removeListener(obs -> {});\n+            action.removeListener((obs, old, current) -> {});\n+        }\n+    }\n+\n+    \/*\n+     * Tests if the embedded ObservableValue sends the correct Change and Invalidation events with various\n+     * combinations of invalidation and change listeners. As the same ObservableValue is used throughout the\n+     * test, also stresses the add\/remove listener code.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldSendCorrectEventsWithSeveralInvalidationAndChangeListeners(Action<T> action, T value1, T value2, Consumer<T> valueSetter) {\n+        for(int[] counts : new Combinations(PATTERN)) {\n+            int invalidationListenerCount = counts[0];\n+            int changeListenerCount = counts[1];\n+\n+            action.setListenerCounts(invalidationListenerCount, changeListenerCount);\n+\n+            valueSetter.accept(value2);\n+            action.assertEvents(\n+                changeListenerCount == 0 ? null : \"Change of %c from \" + value1 + \" to \" + value2,\n+                invalidationListenerCount == 0 ? null : \"Invalidation of %i\"\n+            );\n+\n+            if(changeListenerCount == 0) {\n+                valueSetter.accept(value1);\n+                action.assertEvents();  \/\/ when there are no change listeners, setting a different value (while invalid) should not trigger any events\n+            }\n+\n+            valueSetter.accept(value2);\n+            action.assertEvents();\n+\n+            assertEquals(value2, action.getValue());\n+            action.assertEvents();\n+\n+            valueSetter.accept(value2);\n+            action.assertEvents();\n+\n+            valueSetter.accept(value1);\n+            action.assertEvents(\n+                changeListenerCount == 0 ? null : \"Change of %c from \" + value2 + \" to \" + value1,\n+                invalidationListenerCount == 0 ? null : \"Invalidation of %i\"\n+            );\n+        }\n+    }\n+\n+    \/*\n+     * Tests if the embedded ObservableValue sends sensible change events when a nested change occurs.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"inputs\")\n+    <T> void shouldSendCorrectNestedEvents(Action<T> action, T value1, T value2, Consumer<T> valueSetter) {\n+        List<String> records = new ArrayList<>();\n+\n+        \/*\n+         * Create three listeners, with the \"middle\" one modifying the value back to value1.\n+         *\/\n+\n+        action.addListener((obs, old, current) -> records.add(\"Change of 0 from \" + old + \" to \" + current));\n+        action.addListener((obs, old, current) -> {\n+            records.add(\"Change of 1 from \" + old + \" to \" + current);\n+            if(current.equals(value2)) {\n+                valueSetter.accept(value1);\n+            }\n+        });\n+        action.addListener((obs, old, current) -> records.add(\"Change of 2 from \" + old + \" to \" + current));\n+\n+        \/*\n+         * Start test:\n+         *\/\n+\n+        valueSetter.accept(value2);\n+\n+        \/*\n+         * Verify the current implementation specific result (there are more combinations that could be considered\n+         * correct, but the test case simplifies this for now):\n+         *\/\n+\n+        assertEquals(\n+            List.of(\n+                \"Change of 0 from \" + value1 + \" to \" + value2,\n+                \"Change of 1 from \" + value1 + \" to \" + value2,\n+                \"Change of 2 from \" + value1 + \" to \" + value2,\n+                \"Change of 0 from \" + value2 + \" to \" + value1,\n+                \"Change of 1 from \" + value2 + \" to \" + value1,\n+                \"Change of 2 from \" + value2 + \" to \" + value1\n+            ),\n+            records\n+        );\n+    }\n+\n+    static class Action<T> implements ObservableValue<T> {\n+        private final List<InvalidationListener> invalidationListeners = new ArrayList<>();\n+        private final List<ChangeListener<Object>> changeListeners = new ArrayList<>();\n+        private final List<String> records = new ArrayList<>();\n+        private final ObservableValue<T> observableValue;\n+\n+        Action(ObservableValue<T> observableValue) {\n+            this.observableValue = observableValue;\n+        }\n+\n+        @Override\n+        public void addListener(InvalidationListener listener) {\n+            observableValue.addListener(listener);\n+        }\n+\n+        @Override\n+        public void addListener(ChangeListener<? super T> listener) {\n+            observableValue.addListener(listener);\n+        }\n+\n+        @Override\n+        public void removeListener(InvalidationListener listener) {\n+            observableValue.removeListener(listener);\n+        }\n+\n+        @Override\n+        public void removeListener(ChangeListener<? super T> listener) {\n+            observableValue.removeListener(listener);\n+        }\n+\n+        @Override\n+        public T getValue() {\n+            return observableValue.getValue();\n+        }\n+\n+        void setListenerCounts(int invalidationListenerCount, int changeListenerCount) {\n+            for(int i = invalidationListeners.size() - 1; i >= invalidationListenerCount; --i) {\n+                InvalidationListener invalidationListener = invalidationListeners.get(i);\n+\n+                invalidationListeners.remove(invalidationListener);\n+                observableValue.removeListener(invalidationListener);\n+            }\n+\n+            for(int i = changeListeners.size() - 1; i >= changeListenerCount; --i) {\n+                ChangeListener<Object> changeListener = changeListeners.get(i);\n+\n+                changeListeners.remove(changeListener);\n+                observableValue.removeListener(changeListener);\n+            }\n+\n+            for(int i = invalidationListeners.size(); i < invalidationListenerCount; i++) {\n+                int j = i;\n+\n+                InvalidationListener invalidationListener = obs -> {\n+                    records.add(\"Invalidation of \" + j);\n+                };\n+\n+                invalidationListeners.add(invalidationListener);\n+                observableValue.addListener(invalidationListener);\n+            }\n+\n+            for(int i = changeListeners.size(); i < changeListenerCount; i++) {\n+                int j = i;\n+\n+                ChangeListener<Object> changeListener = (obs, old, current) -> {\n+                    records.add(\"Change of \" + j + \" from \" + old + \" to \" + current);\n+                };\n+\n+                changeListeners.add(changeListener);\n+                observableValue.addListener(changeListener);\n+            }\n+        }\n+\n+        void assertEvents(String... expectedTemplates) {\n+            for(String expectedTemplate : expectedTemplates) {\n+                if(expectedTemplate == null) {\n+                    continue;\n+                }\n+\n+                if(expectedTemplate.contains(\"%c\")) {\n+                    if(changeListeners.isEmpty()) {\n+                        fail(\"Expected \\\"\" + expectedTemplate + \"\\\" to match at least once, but it didn't for: \" + this);\n+                    }\n+\n+                    for(int i = 0; i < changeListeners.size(); i++) {\n+                        String expected = expectedTemplate.replaceAll(\"%c\", \"\" + i);\n+                        assertTrue(records.remove(expected), () -> \"Expected \\\"\" + expected + \"\\\" but found none for: \" + this);\n+                    }\n+                }\n+                else if(expectedTemplate.contains(\"%i\")) {\n+                    if(invalidationListeners.isEmpty()) {\n+                        fail(\"Expected \\\"\" + expectedTemplate + \"\\\" to match at least once, but it didn't for: \" + this);\n+                    }\n+\n+                    for(int i = 0; i < invalidationListeners.size(); i++) {\n+                        String expected = expectedTemplate.replaceAll(\"%i\", \"\" + i);\n+                        assertTrue(records.remove(expected), () -> \"Expected \\\"\" + expected + \"\\\" but found none for: \" + this);\n+                    }\n+                }\n+            }\n+\n+            if(!records.isEmpty()) {\n+                fail(\"Did not expect: \" + records + \" for: \" + this);\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return observableValue + \"[il=\" + invalidationListeners.size() + \", cl=\" + changeListeners.size() + \"]\";\n+        }\n+    }\n+\n+    static class Case<P extends Property<T>, T> {\n+        final T primaryValue;\n+        final T alternativeValue;\n+        final Consumer<T> valueSetter;\n+        final ObservableValue<? super T> observableValue;\n+\n+        public Case(P property, T primaryValue, T alternativeValue, Function<P, ObservableValue<? super T>> modifier, BiConsumer<P, T> valueSetter) {\n+            this.primaryValue = primaryValue;\n+            this.alternativeValue = alternativeValue;\n+            this.valueSetter = (T v) -> valueSetter.accept(property, v);\n+            this.observableValue = modifier.apply(property);\n+\n+            this.valueSetter.accept(primaryValue);\n+        }\n+\n+        static <P extends Property<T>, T> Case<P, T> of(P property, T primaryValue, T alternativeValue, Function<P, ObservableValue<? super T>> modifier, BiConsumer<P, T> valueSetter) {\n+            return new Case<>(property, primaryValue, alternativeValue, modifier, valueSetter);\n+        }\n+\n+        static <P extends Property<T>, T> Case<P, T> of(P property, T primaryValue, T alternativeValue) {\n+            return new Case<>(property, primaryValue, alternativeValue, p -> p, (p, v) -> p.setValue(v));\n+        }\n+    }\n+\n+    \/**\n+     * Takes a list of values and creates an iterator of pairs of those values. The iterator\n+     * does not only return all possible pair combinations, but also different transitions between\n+     * two pairs. Effectively, given x values it returns x^3 combinations.\n+     *\/\n+    private static class Combinations implements Iterable<int[]> {\n+        private final int[] values;\n+\n+        public Combinations(int[] values) {\n+            this.values = values;\n+        }\n+\n+        @Override\n+        public Iterator<int[]> iterator() {\n+            return new Combinator(values);\n+        }\n+    }\n+\n+    private static class Combinator implements Iterator<int[]> {\n+        private final int[] values;\n+        private final int m;\n+\n+        private int s;\n+        private int x;\n+        private int y;\n+\n+        public Combinator(int[] values) {\n+            this.values = values;\n+            this.m = values.length;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return y < m;\n+        }\n+\n+        @Override\n+        public int[] next() {\n+            if(!hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+\n+            int[] next = new int[] {values[x], values[(y + s) % m]};\n+\n+            if(++s == m) {\n+                s = 0;\n+\n+                if(++x == m) {\n+                    x = 0;\n+                    y++;\n+                }\n+            }\n+\n+            return next;\n+        }\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/ObservableValueTest.java","additions":402,"deletions":0,"binary":false,"changes":402,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+\n@@ -40,1 +41,0 @@\n-    private boolean noChangeInValue = false;\n@@ -102,1 +102,0 @@\n-        if (noChangeInValue) return;\n@@ -111,5 +110,5 @@\n-                    \/\/ calling setText results in updateValue - so we set this flag to true\n-                    \/\/ so that when this is true updateValue simply returns.\n-                    noChangeInValue = true;\n-                    getTextField().setText(Utils.formatHexString(newValue));\n-                    noChangeInValue = false;\n+                    String newText = Utils.formatHexString(newValue);\n+\n+                    if (!newText.equals(text)) {\n+                        getTextField().setText(newText);\n+                    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/skin\/WebColorFieldSkin.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"}]}