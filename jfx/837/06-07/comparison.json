{"files":[{"patch":"@@ -28,0 +28,4 @@\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+\n@@ -32,2 +36,0 @@\n-import java.util.Arrays;\n-\n@@ -46,30 +48,1 @@\n-    \/**\n-     * Event emission states.\n-     *\n-     * <h3>Allowed Transitions:<\/h3>\n-     *\n-     * <table rules=\"all\" cellpadding=4px>\n-     * <tr><th>Current<\/th><th>Next<\/th><\/tr>\n-     * <tr><td>{@code IDLE}<\/td><td>{@code REQUESTED}<\/td><\/tr>\n-     * <tr><td>{@code REQUESTED}<\/td><td>{@code RUNNING}<\/td><\/tr>\n-     * <tr><td>{@code RUNNING}<\/td><td>{@code REQUESTED} or {@code IDLE}<\/td><\/tr>\n-     * <\/table>\n-     *\/\n-    private enum Emission {\n-\n-        \/**\n-         * No event emission is running.\n-         *\/\n-        IDLE,\n-\n-        \/**\n-         * An event emission is in progress.\n-         *\/\n-        RUNNING,\n-\n-        \/**\n-         * An event emission is requested; if one is running, it will\n-         * run immediately after the current one finishes.\n-         *\/\n-        REQUESTED\n-    }\n+    private static record NestedChange<T>(T value) {}\n@@ -169,1 +142,1 @@\n-                Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n+                forwardToUncaughtExceptionHandler(e);\n@@ -178,1 +151,12 @@\n-        private Emission emission = Emission.IDLE;\n+\n+        \/**\n+         * {@code true} when an emission is currently in progress. When\n+         * an emission is in progress, nested changes must be queued.\n+         *\/\n+        private boolean emissionInProgress;\n+\n+        \/**\n+         * When not {@code null}, contains nested changes that will be\n+         * emitted in order once the current emission finishes.\n+         *\/\n+        private Deque<NestedChange<T>> nestedChanges;\n@@ -206,0 +190,18 @@\n+        private void addNotifyValue() {\n+            if (nestedChanges == null) {\n+                nestedChanges = new ArrayDeque<>();\n+            }\n+\n+            nestedChanges.add(new NestedChange<>(observable.getValue()));\n+        }\n+\n+        private T nextNotifyValue() {\n+            T value = nestedChanges == null ? observable.getValue() : nestedChanges.removeFirst().value;\n+\n+            if (nestedChanges != null && nestedChanges.isEmpty()) {\n+                nestedChanges = null;\n+            }\n+\n+            return value;\n+        }\n+\n@@ -208,3 +210,2 @@\n-            boolean idle = emission == Emission.IDLE;\n-\n-            emission = Emission.REQUESTED;\n+            if (emissionInProgress) {\n+                addNotifyValue();\n@@ -212,1 +213,0 @@\n-            if (!idle) {\n@@ -216,3 +216,1 @@\n-            try {\n-                while (emission == Emission.REQUESTED) {\n-                    emission = Emission.RUNNING;\n+            emissionInProgress = true;\n@@ -220,9 +218,12 @@\n-                    final T oldValue = currentValue;\n-                    currentValue = observable.getValue();\n-                    final boolean changed = (currentValue == null)? (oldValue != null) : !currentValue.equals(oldValue);\n-                    if (changed) {\n-                        try {\n-                            listener.changed(observable, oldValue, currentValue);\n-                        } catch (Exception e) {\n-                            Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n-                        }\n+            do {\n+                T oldValue = currentValue;\n+\n+                currentValue = nextNotifyValue();\n+\n+                boolean changed = (currentValue == null) ? (oldValue != null) : !currentValue.equals(oldValue);\n+\n+                if (changed) {\n+                    try {\n+                        listener.changed(observable, oldValue, currentValue);\n+                    } catch (Exception e) {\n+                        forwardToUncaughtExceptionHandler(e);\n@@ -231,4 +232,3 @@\n-            }\n-            finally {\n-                emission = Emission.IDLE;\n-            }\n+            } while (nestedChanges != null);\n+\n+            emissionInProgress = false;\n@@ -244,1 +244,0 @@\n-        private Emission emission = Emission.IDLE;\n@@ -247,0 +246,12 @@\n+        \/**\n+         * {@code true} when an emission is currently in progress. When\n+         * an emission is in progress, nested changes must be queued.\n+         *\/\n+        private boolean locked;\n+\n+        \/**\n+         * When not {@code null}, contains nested changes that will be\n+         * emitted in order once the current emission finishes.\n+         *\/\n+        private Deque<NestedChange<T>> nestedChanges;\n+\n@@ -276,1 +287,1 @@\n-                if (emission != Emission.IDLE) {\n+                if (locked) {\n@@ -307,1 +318,1 @@\n-                            if (emission != Emission.IDLE) {\n+                            if (locked) {\n@@ -315,1 +326,1 @@\n-                            if (emission == Emission.IDLE) {\n+                            if (!locked) {\n@@ -333,1 +344,1 @@\n-                if (emission != Emission.IDLE) {\n+                if (locked) {\n@@ -367,1 +378,1 @@\n-                            if (emission != Emission.IDLE) {\n+                            if (locked) {\n@@ -375,1 +386,1 @@\n-                            if (emission == Emission.IDLE) {\n+                            if (!locked) {\n@@ -386,0 +397,18 @@\n+        private void addNotifyValue() {\n+            if (nestedChanges == null) {\n+                nestedChanges = new ArrayDeque<>();\n+            }\n+\n+            nestedChanges.add(new NestedChange<>(observable.getValue()));\n+        }\n+\n+        private T nextNotifyValue() {\n+            T value = nestedChanges == null ? observable.getValue() : nestedChanges.removeFirst().value;\n+\n+            if (nestedChanges != null && nestedChanges.isEmpty()) {\n+                nestedChanges = null;\n+            }\n+\n+            return value;\n+        }\n+\n@@ -388,3 +417,4 @@\n-            boolean idle = emission == Emission.IDLE;\n-\n-            emission = Emission.REQUESTED;\n+            if (locked) {\n+                if (changeSize > 0) {\n+                    addNotifyValue();\n+                }\n@@ -392,1 +422,0 @@\n-            if (!idle) {\n@@ -396,0 +425,2 @@\n+            locked = true;\n+\n@@ -401,1 +432,1 @@\n-            try {\n+            do {\n@@ -404,9 +435,5 @@\n-                while (emission == Emission.REQUESTED) {\n-                    emission = Emission.RUNNING;\n-\n-                    for (int i = 0; i < curInvalidationSize; i++) {\n-                        try {\n-                            curInvalidationList[i].invalidated(observable);\n-                        } catch (Exception e) {\n-                            Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n-                        }\n+                for (int i = 0; i < curInvalidationSize; i++) {\n+                    try {\n+                        curInvalidationList[i].invalidated(observable);\n+                    } catch (Exception e) {\n+                        forwardToUncaughtExceptionHandler(e);\n@@ -414,13 +441,12 @@\n-                    if (curChangeSize > 0) {\n-                        currentValue = observable.getValue();\n-\n-                        T newValue = currentValue;\n-                        boolean changed = (newValue == null) ? (oldValue != null) : !newValue.equals(oldValue);\n-\n-                        if (changed) {\n-                            for (int i = 0; i < curChangeSize; i++) {\n-                                try {\n-                                    curChangeList[i].changed(observable, oldValue, newValue);\n-                                } catch (Exception e) {\n-                                    Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n-                                }\n+                }\n+                if (curChangeSize > 0) {\n+                    currentValue = nextNotifyValue();\n+\n+                    boolean changed = (currentValue == null) ? (oldValue != null) : !currentValue.equals(oldValue);\n+\n+                    if (changed) {\n+                        for (int i = 0; i < curChangeSize; i++) {\n+                            try {\n+                                curChangeList[i].changed(observable, oldValue, currentValue);\n+                            } catch (Exception e) {\n+                                forwardToUncaughtExceptionHandler(e);\n@@ -429,2 +455,0 @@\n-\n-                        oldValue = newValue;\n@@ -433,3 +457,3 @@\n-            } finally {\n-                emission = Emission.IDLE;\n-            }\n+            } while(nestedChanges != null);\n+\n+            locked = false;\n@@ -439,0 +463,20 @@\n+    private static void forwardToUncaughtExceptionHandler(Exception e) {\n+        try {\n+            Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n+        }\n+        catch (Exception ignored) {\n+\n+            \/*\n+             * Very bad practice to throw an exception from the uncaught exception handler.\n+             * When the JVM calls it, the exception is ignored, however when called directly\n+             * this is not the case. To ensure that this class performs its logic correctly,\n+             * and doesn't send out partial emissions or gets into an undefined state,\n+             * this exception is only logged.\n+             *\/\n+\n+            System.err.println(\n+                \"The uncaught exception handler: \" + Thread.currentThread().getUncaughtExceptionHandler()\n+                    + \" threw an exception: \" + ignored + \" while handling the exception: \" + e\n+            );\n+        }\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ExpressionHelper.java","additions":137,"deletions":93,"binary":false,"changes":230,"status":"modified"}]}