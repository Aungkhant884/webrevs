{"files":[{"patch":"@@ -216,0 +216,2 @@\n+    private static final double EPSILON = 1e-14;\n+\n@@ -297,0 +299,10 @@\n+    \/**\n+     * The value is floored for a given scale using Math.floor.\n+     * This method guarantees that:\n+     *\n+     * scaledFloor(scaledFloor(value, scale), scale) == scaledFloor(value, scale)\n+     *\n+     * @param value The value that needs to be floored\n+     * @param scale The scale that will be used\n+     * @return value floored with scale\n+     *\/\n@@ -298,1 +310,1 @@\n-        return Math.floor(value * scale) \/ scale;\n+        return Math.floor(value * scale + EPSILON) \/ scale;\n@@ -301,0 +313,10 @@\n+    \/**\n+     * The value is ceiled with a given scale using Math.ceil.\n+     * This method guarantees that:\n+     *\n+     * scaledCeil(scaledCeil(value, scale), scale) == scaledCeil(value, scale)\n+     *\n+     * @param value The value that needs to be ceiled\n+     * @param scale The scale that will be used\n+     * @return value ceiled with scale\n+     *\/\n@@ -302,1 +324,1 @@\n-        return Math.ceil(value * scale) \/ scale;\n+        return Math.ceil(value * scale - EPSILON) \/ scale;\n@@ -366,0 +388,10 @@\n+    \/**\n+     * If snapToPixel is true, then the value is either floored (positive values) or\n+     * ceiled (negative values) with a scale. This method guarantees that:\n+     *\n+     * snapPortionX(snapPortionX(value, snapToPixel), snapToPixel) == snapPortionX(value, snapToPixel)\n+     *\n+     * @param value The value that needs to be snapped\n+     * @param snapToPixel Whether to snap to pixel\n+     * @return value either as passed, or floored or ceiled with scale, based on snapToPixel\n+     *\/\n@@ -371,1 +403,1 @@\n-            value = Math.max(1, Math.floor(value));\n+            value = Math.max(1, Math.floor(value + EPSILON));\n@@ -373,1 +405,1 @@\n-            value = Math.min(-1, Math.ceil(value));\n+            value = Math.min(-1, Math.ceil(value - EPSILON));\n@@ -377,0 +409,11 @@\n+\n+    \/**\n+     * If snapToPixel is true, then the value is either floored (positive values) or\n+     * ceiled (negative values) with a scale. This method guarantees that:\n+     *\n+     * snapPortionY(snapPortionY(value, snapToPixel), snapToPixel) == snapPortionY(value, snapToPixel)\n+     *\n+     * @param value The value that needs to be snapped\n+     * @param snapToPixel Whether to snap to pixel\n+     * @return value either as passed, or floored or ceiled with scale, based on snapToPixel\n+     *\/\n@@ -382,1 +425,1 @@\n-            value = Math.max(1, Math.floor(value));\n+            value = Math.max(1, Math.floor(value + EPSILON));\n@@ -384,1 +427,1 @@\n-            value = Math.min(-1, Math.ceil(value));\n+            value = Math.min(-1, Math.ceil(value - EPSILON));\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Region.java","additions":49,"deletions":6,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -153,0 +153,8 @@\n+    public static double snapPortionX(Region r, double value) {\n+        return r.snapPortionX(value);\n+    }\n+\n+    public static double snapPortionY(Region r, double value) {\n+        return r.snapPortionY(value);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/shims\/java\/javafx\/scene\/layout\/RegionShim.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import javafx.scene.Scene;\n@@ -42,0 +43,2 @@\n+import javafx.stage.Stage;\n+import java.util.Random;\n@@ -1251,0 +1254,54 @@\n+\n+    \/\/ Test for JDK-8255415\n+    @Test public void snappingASnappedValueGivesTheSameValueTest() {\n+        Stage stage = new Stage();\n+        Region region = new Region();\n+        Scene scene = new Scene(region);\n+        stage.setScene(scene);\n+\n+        double[] scales = new double[] {1.0, 1.25, 1.5, 1.75, 2.0, 1.374562997};\n+\n+        \/\/ test snapSizeX\/snapSizeY methods\n+\n+        for (double scale : scales) {\n+            stage.setRenderScaleX(scale);\n+            for (int j = 0; j < 1000; j++) {\n+                double value = new Random().nextDouble() * 100 - 50;\n+                double snappedValue = region.snapSizeX(value);\n+                double snapOfSnappedValue = region.snapSizeX(snappedValue);\n+                assertEquals(snappedValue, snapOfSnappedValue, 1.0e-14);\n+            }\n+        }\n+\n+        for (double scale : scales) {\n+            stage.setRenderScaleY(scale);\n+            for (int j = 0; j < 1000; j++) {\n+                double value = new Random().nextDouble() * 100 - 50;\n+                double snappedValue = region.snapSizeY(value);\n+                double snapOfSnappedValue = region.snapSizeY(snappedValue);\n+                assertEquals(snappedValue, snapOfSnappedValue, 1.0e-14);\n+            }\n+        }\n+\n+        \/\/ test snapPortionX\/snapPortionY methods\n+\n+        for (double scale : scales) {\n+            stage.setRenderScaleX(scale);\n+            for (int j = 0; j < 1000; j++) {\n+                double value = new Random().nextDouble() * 100 - 50;\n+                double snappedValue = RegionShim.snapPortionX(region, value);\n+                double snapOfSnappedValue = RegionShim.snapPortionX(region, snappedValue);\n+                assertEquals(snappedValue, snapOfSnappedValue, 1.0e-14);\n+            }\n+        }\n+\n+        for (double scale : scales) {\n+            stage.setRenderScaleY(scale);\n+            for (int j = 0; j < 1000; j++) {\n+                double value = new Random().nextDouble() * 100 - 50;\n+                double snappedValue = RegionShim.snapPortionY(region, value);\n+                double snapOfSnappedValue = RegionShim.snapPortionY(region, snappedValue);\n+                assertEquals(snappedValue, snapOfSnappedValue, 1.0e-14);\n+            }\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/RegionTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"}]}