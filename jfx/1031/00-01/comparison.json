{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -309,3 +309,3 @@\n-     * Indicates whether or not a nested event loop can be started\n-     * from the current thread in the current state. Note that a nested\n-     * event loop is not allowed outside of an event handler.\n+     * Indicates whether a nested event loop can be started from the current thread in the current state.\n+     * Note that a nested event loop is not allowed outside an event handler.\n+     * This method must be called on the JavaFX Application thread.\n@@ -313,1 +313,4 @@\n-     * @return flag indicating whether a nested event loop can be started.\n+     * @return true if a nested event loop can be started, and false otherwise.\n+     *\n+     * @throws IllegalStateException if this method is called on a thread\n+     * other than the JavaFX Application Thread.\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/Toolkit.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -624,0 +624,2 @@\n+        checkFxUserThread();\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/QuantumToolkit.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -397,0 +397,1 @@\n+     * This method must be called on the JavaFX Application thread.\n@@ -400,0 +401,3 @@\n+     * @throws IllegalStateException if this method is called on a thread\n+     * other than the JavaFX Application Thread.\n+     *\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/application\/Platform.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.application;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import test.util.Util;\n+\n+import javafx.animation.KeyFrame;\n+import javafx.animation.Timeline;\n+import javafx.util.Duration;\n+import javafx.application.Platform;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class PlatformTest {\n+\n+    @BeforeAll\n+    public static void initFXOnce() {\n+        CountDownLatch startupLatch = new CountDownLatch(1);\n+        Platform.setImplicitExit(false);\n+\n+        Util.startup(startupLatch, startupLatch::countDown);\n+    }\n+\n+    @AfterAll\n+    public static void teardownOnce() {\n+        Util.shutdown();\n+    }\n+\n+    @Test\n+    public void testNestedEventLoopChecks() {\n+        \/\/ Check on FX Thread.\n+        Util.runAndWait(() -> {\n+            assertFalse(Platform.isNestedLoopRunning());\n+            assertTrue(Platform.canStartNestedEventLoop());\n+        });\n+    }\n+\n+    @Test\n+    public void testEnterExitNestedEventLoop() {\n+        final String key = \"key\";\n+        final String value = \"value\";\n+        final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();\n+\n+        Util.runAndWait(() -> {\n+            \/\/ Exit nested event loop after it was started.\n+            Platform.runLater(() -> {\n+                try {\n+                    assertTrue(Platform.isNestedLoopRunning());\n+                    assertTrue(Platform.canStartNestedEventLoop());\n+                    Platform.exitNestedEventLoop(key, value);\n+                } catch (Throwable e) {\n+                    exceptionRef.set(e);\n+                }\n+            });\n+\n+            Object returnValue = Platform.enterNestedEventLoop(key);\n+            assertEquals(value, returnValue);\n+        });\n+\n+        \/\/ We do not expect any exception.\n+        assertNull(exceptionRef.get(), exceptionRef::toString);\n+    }\n+\n+    @Test\n+    public void testNestedEventLoopChecksNotOnFxThread() {\n+        assertThrows(IllegalStateException.class, () -> Platform.isNestedLoopRunning());\n+        assertThrows(IllegalStateException.class, () -> Platform.canStartNestedEventLoop());\n+    }\n+\n+    @Test\n+    public void testEnterExitNestedEventLoopNotOnFxThread() {\n+        assertThrows(IllegalStateException.class, () -> Platform.enterNestedEventLoop(null));\n+        assertThrows(IllegalStateException.class, () -> Platform.exitNestedEventLoop(null, null));\n+    }\n+\n+    @Test\n+    public void testCanNotStartNestedEventLoopInTimeline() {\n+        final CountDownLatch timelineDone = new CountDownLatch(1);\n+        final AtomicReference<Throwable> exceptionRef = new AtomicReference<>();\n+\n+        Timeline timeline = new Timeline(new KeyFrame(Duration.millis(50), event -> {\n+            try {\n+                assertFalse(Platform.canStartNestedEventLoop());\n+            } catch (Throwable e) {\n+                exceptionRef.set(e);\n+            } finally {\n+                timelineDone.countDown();\n+            }\n+        }));\n+        timeline.play();\n+\n+        Util.await(timelineDone);\n+\n+        \/\/ We do not expect any exception.\n+        assertNull(exceptionRef.get(), exceptionRef::toString);\n+    }\n+\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/application\/PlatformTest.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"}]}