{"files":[{"patch":"@@ -0,0 +1,67 @@\n+package com.sun.javafx.binding;\n+\n+import java.util.Objects;\n+\n+import javafx.beans.value.ObservableValue;\n+\n+public class ConditionalBinding<T> extends LazyObjectBinding<T> {\n+\n+    private final ObservableValue<T> source;\n+    private final ObservableValue<Boolean> nonNullCondition;\n+\n+    private Subscription subscription;\n+\n+    public ConditionalBinding(ObservableValue<T> source, ObservableValue<Boolean> condition) {\n+        this.source = Objects.requireNonNull(source, \"source\");\n+        this.nonNullCondition = Objects.requireNonNull(condition, \"condition\").orElse(false);\n+\n+        \/\/ condition is always observed and never unsubscribed\n+        Subscription.subscribe(nonNullCondition, current -> {\n+            invalidate();\n+\n+            if (!current) {\n+                getValue();\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * This binding is valid whenever it is observed, or it is currently inactive.\n+     * When inactive, the binding has the value of its source at the time it became\n+     * inactive.\n+     *\/\n+    @Override\n+    protected boolean allowValidation() {\n+        return super.allowValidation() || !isActive();\n+    }\n+\n+    @Override\n+    protected T computeValue() {\n+        if (isObserved() && isActive()) {\n+            if(subscription == null) {\n+                subscription = Subscription.subscribeInvalidations(source, this::invalidate);\n+            }\n+        }\n+        else {\n+            unsubscribe();\n+        }\n+\n+        return source.getValue();\n+    }\n+\n+    @Override\n+    protected Subscription observeSources() {\n+        return this::unsubscribe;\n+    }\n+\n+    private boolean isActive() {\n+        return nonNullCondition.getValue();\n+    }\n+\n+    private void unsubscribe() {\n+        if (subscription != null) {\n+            subscription.unsubscribe();\n+            subscription = null;\n+        }\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ConditionalBinding.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -183,1 +183,9 @@\n-            value = null;  \/\/ clear cached value to avoid hard reference to stale data\n+\n+            \/*\n+             * Cached value should be cleared to avoid a strong reference to stale data,\n+             * but only if this binding didn't become valid after firing the event:\n+             *\/\n+\n+            if (!valid) {\n+                value = null;\n+            }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/binding\/ObjectBinding.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import com.sun.javafx.binding.ConditionalBinding;\n@@ -254,0 +255,59 @@\n+\n+    \/**\n+     * Returns an {@code ObservableValue} that holds this value whenever the given\n+     * condition evaluates to {@code true}, otherwise holds the last value when\n+     * {@code condition} became {@code false}. The value is updated whenever this\n+     * {@code ObservableValue} changes, unless the condition currently evaluates\n+     * to {@code false}.\n+     * <p>\n+     * The returned {@code ObservableValue} only observes this value when the given\n+     * {@code condition} evaluates to {@code true}. This allows this {@code ObservableValue}\n+     * and the conditional {@code ObservableValue} to be garbage collected if neither is\n+     * otherwise strongly referenced when {@code condition} becomes {@code false}.\n+     * <p>\n+     * A currently observed binding will observe its source, which means it will not be eligible\n+     * for garbage collection while source isn't. However, using {@code when} this {@code ObservableValue}\n+     * can still be eligible for garbage collection when the condition is {@code false} and the\n+     * conditional itself is also eligible for garbage collection.\n+     * <p>\n+     * Returning {@code null} from the given condition is treated the same as\n+     * returning {@code false}.\n+     * <p>\n+     * For example:\n+     * <pre>{@code\n+     * ObservableValue<Boolean> condition = new SimpleBooleanProperty(true);\n+     * ObservableValue<String> globalProperty = new SimpleStringProperty(\"A\");\n+     * ObservableValue<String> whenProperty = property.when(isShowing);\n+     *\n+     * \/\/ observe whenProperty, which will in turn observe globalProperty\n+     * whenProperty.addChangeListener((ov, old, current) -> System.out.println(current));\n+     *\n+     * globalProperty.setValue(\"B\");  \/\/ \"B\" is printed\n+     *\n+     * condition.setValue(false);\n+     *\n+     * \/\/ After condition becomes false, whenProperty stops observing globalProperty; condition\n+     * \/\/ and whenProperty may now be eligible for GC despite being observed by the ChangeListener\n+     *\n+     * globalProperty.setValue(\"C\");  \/\/ nothing is printed\n+     * globalProperty.setValue(\"D\");  \/\/ nothing is printed\n+     *\n+     * condition.setValue(true);  \/\/ globalProperty is observed again, and \"D\" is printed\n+     * }<\/pre>\n+     * Another example:\n+     * <pre>{@code\n+     * Label label = ... ;\n+     * ObservableValue<String> globalProperty = new SimpleStringProperty(\"A\");\n+     *\n+     * \/\/ bind label's text to a global property only when it is showing:\n+     * label.textProperty().bind(globalProperty.when(label::isShowingProperty));\n+     * }<\/pre>\n+     * @param condition a boolean {@code ObservableValue}, cannot be {@code null}\n+     * @return an {@code ObservableValue} that holds this value whenever the given\n+     *     condition evaluates to {@code true}, otherwise holds the last seen value;\n+     *     never returns {@code null}\n+     * @since 20\n+     *\/\n+    default ObservableValue<T> when(ObservableValue<Boolean> condition) {\n+        return new ConditionalBinding<>(this, condition);\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/ObservableValue.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -55,0 +55,18 @@\n+    @Test\n+    void invalidationWhichBecomesValidDuringCallbacksShouldReturnCorrectValue() {\n+        LazyObjectBindingStub<String> binding = new LazyObjectBindingStub<>() {\n+            @Override\n+            protected String computeValue() {\n+                return \"A\";\n+            }\n+        };\n+\n+        binding.addListener(obs -> {\n+            assertEquals(\"A\", binding.get());\n+        });\n+\n+        binding.invalidate();  \/\/ becomes valid again immediately\n+\n+        assertEquals(\"A\", binding.get());\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/LazyObjectBindingTest.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,0 +42,4 @@\n+import javafx.beans.property.BooleanProperty;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n@@ -50,1 +54,0 @@\n-    private final StringProperty property = new SimpleStringProperty(\"Initial\");\n@@ -55,0 +58,2 @@\n+    private StringProperty property = new SimpleStringProperty(\"Initial\");\n+\n@@ -881,0 +886,278 @@\n+    @Nested\n+    class When_when_Called {\n+\n+        @Nested\n+        class WithNull {\n+\n+            @Test\n+            void shouldThrowNullPointerException() {\n+                assertThrows(NullPointerException.class, () -> property.when(null));\n+            }\n+        }\n+\n+        @Nested\n+        class WithNotNullAndInitiallyFalseConditionReturns_ObservableValue_Which {\n+            private BooleanProperty condition = new SimpleBooleanProperty(false);\n+            private ObservableValue<String> observableValue = property.when(condition);\n+\n+            @Test\n+            void shouldNotBeNull() {\n+                assertNotNull(observableValue);\n+            }\n+\n+            @Test\n+            void shouldNotBeStronglyReferenced() {\n+                ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> {\n+                    observableValue = null;\n+                    condition = null;\n+                });\n+            }\n+\n+            @Nested\n+            class When_getValue_Called {\n+\n+                @Test\n+                void shouldReturnInitialValueAtTimeOfCreation() {\n+                    property.set(\"Not Initial\");\n+\n+                    assertEquals(\"Initial\", observableValue.getValue());\n+                }\n+            }\n+        }\n+\n+        @Nested\n+        class WithNotNullReturns_ObservableValue_Which {\n+            private ObjectProperty<Boolean> condition = new SimpleObjectProperty<Boolean>(true);  \/\/ using object property here so it can be set to null for testing\n+            private ObservableValue<String> observableValue = property.when(condition);\n+\n+            @Test\n+            void shouldNotBeNull() {\n+                assertNotNull(observableValue);\n+            }\n+\n+            @Test\n+            void shouldNotBeStronglyReferenced() {\n+                ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> {\n+                    observableValue = null;\n+                    condition = null;\n+                });\n+            }\n+\n+            @Nested\n+            class When_getValue_Called {\n+\n+                @Test\n+                void shouldReturnCurrentPropertyValuesWhileConditionIsTrue() {\n+                    assertEquals(\"Initial\", observableValue.getValue());\n+\n+                    property.set(null);\n+\n+                    assertNull(observableValue.getValue());\n+\n+                    property.set(\"Left\");\n+\n+                    assertEquals(\"Left\", observableValue.getValue());\n+\n+                    condition.set(false);\n+\n+                    property.set(\"Right\");\n+\n+                    assertEquals(\"Left\", observableValue.getValue());\n+\n+                    property.set(\"Middle\");\n+\n+                    assertEquals(\"Left\", observableValue.getValue());\n+\n+                    condition.set(true);\n+\n+                    assertEquals(\"Middle\", observableValue.getValue());\n+                }\n+            }\n+\n+            @Nested\n+            class WhenObservedForInvalidations {\n+                {\n+                    startObservingInvalidations(observableValue);\n+                }\n+\n+                @Test\n+                void shouldOnlyInvalidateOnce() {\n+                    assertNotInvalidated();\n+\n+                    property.set(\"Left\");\n+\n+                    assertInvalidated();\n+\n+                    property.set(\"Right\");\n+\n+                    assertNotInvalidated();\n+                }\n+\n+                @Test\n+                void shouldOnlyInvalidateWhileConditionIsTrue() {\n+                    assertNotInvalidated();\n+\n+                    property.set(\"Left\");  \/\/ trigger invalidation\n+\n+                    assertInvalidated();\n+\n+                    condition.set(false);\n+\n+                    assertNotInvalidated();  \/\/ already invalid, changing condition won't change that\n+\n+                    observableValue.getValue();  \/\/ this would normally make the property valid, but not when condition is false\n+\n+                    property.set(\"Right\");  \/\/ trigger invalidation\n+\n+                    assertNotInvalidated();  \/\/ nothing happened\n+\n+                    condition.setValue(null);  \/\/ null is false as well, should not change result\n+\n+                    assertNotInvalidated();  \/\/ nothing happened\n+\n+                    condition.set(true);\n+\n+                    assertInvalidated();\n+\n+                    observableValue.getValue();  \/\/ make property valid\n+\n+                    assertNotInvalidated();\n+\n+                    property.set(\"Middle\");  \/\/ trigger invalidation\n+\n+                    assertInvalidated();\n+                }\n+\n+                @Test\n+                void shouldBeStronglyReferenced() {\n+                    ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> {\n+                        observableValue = null;\n+                        condition = null;\n+                    });\n+                }\n+\n+                @Test\n+                void shouldNotBeStronglyReferencedWhenConditionIsFalse() {\n+                    condition.set(false);\n+\n+                    ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> {\n+                        observableValue = null;\n+                        condition = null;\n+                    });\n+                }\n+\n+                @Nested\n+                class AndWhenUnobserved {\n+                    {\n+                        stopObservingInvalidations(observableValue);\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeCalled() {\n+                        assertNotInvalidated();\n+\n+                        property.set(\"Left\");\n+                        property.set(\"Right\");\n+\n+                        assertNotInvalidated();\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeStronglyReferenced() {\n+                        ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> {\n+                            observableValue = null;\n+                            condition = null;\n+                        });\n+                    }\n+                }\n+            }\n+\n+            @Nested\n+            class WhenObservedForChanges {\n+                {\n+                    startObservingChanges(observableValue);\n+                }\n+\n+                @Test\n+                void shouldReceiveCurrentPropertyValues() {\n+                    assertNothingIsObserved();\n+\n+                    property.set(\"Right\");\n+\n+                    assertObserved(\"Right\");\n+                }\n+\n+                @Test\n+                void shouldOnlyReceiveCurrentPropertyValuesWhileConditionIsTrue() {\n+                    assertNothingIsObserved();\n+\n+                    property.set(\"Right\");\n+\n+                    assertObserved(\"Right\");\n+\n+                    condition.set(false);\n+\n+                    assertNothingIsObserved();\n+\n+                    property.set(\"Left\");\n+\n+                    assertNothingIsObserved();\n+\n+                    property.set(\"Middle\");\n+\n+                    assertNothingIsObserved();\n+\n+                    condition.setValue(null);  \/\/ null is false as well, should not change result\n+\n+                    assertNothingIsObserved();\n+\n+                    condition.set(true);\n+\n+                    assertObserved(\"Middle\");\n+                }\n+\n+                @Test\n+                void shouldBeStronglyReferenced() {\n+                    ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> {\n+                        observableValue = null;\n+                        condition = null;\n+                    });\n+                }\n+\n+                @Test\n+                void shouldNotBeStronglyReferencedWhenConditionIsFalse() {\n+                    condition.set(false);\n+\n+                    ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> {\n+                        observableValue = null;\n+                        condition = null;\n+                    });\n+                }\n+\n+                @Nested\n+                class AndWhenUnobserved {\n+                    {\n+                        stopObservingChanges(observableValue);\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeCalled() {\n+                        assertNothingIsObserved();\n+\n+                        property.set(\"Right\");\n+\n+                        assertNothingIsObserved();\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeStronglyReferenced() {\n+                        ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> {\n+                            observableValue = null;\n+                            condition = null;\n+                        });\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -894,1 +1177,1 @@\n-        assertEquals(values, Arrays.asList(expectedValues));\n+        assertEquals(Arrays.asList(expectedValues), values);\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/ObservableValueFluentBindingsTest.java","additions":285,"deletions":2,"binary":false,"changes":287,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import javafx.beans.value.ObservableValue;\n@@ -1400,0 +1401,81 @@\n+    \/**\n+     * Whether or not this {@code Node} is showing (that is, it is part of an\n+     * open Window on the user's system). The Window might be \"showing\", yet the user might not\n+     * be able to see it due to the Window being rendered behind another Window\n+     * or due to the Window being positioned off the monitor.\n+     *\n+     * <p>Note that the {@code Node} does not need to be visible for this property\n+     * to be {@code true}.\n+     *\n+     * @defaultValue false\n+     * @since 20\n+     *\/\n+    private ReadOnlyBooleanProperty showing;\n+\n+    public final boolean isShowing() {\n+        Scene s = getScene();\n+        if (s == null) return false;\n+        Window w = s.getWindow();\n+        return w != null && w.isShowing();\n+    }\n+\n+    public final ReadOnlyBooleanProperty showingProperty() {\n+        if (showing == null) {\n+            ObservableValue<Boolean> ov = sceneProperty()\n+                .flatMap(Scene::windowProperty)\n+                .flatMap(Window::showingProperty);\n+\n+            showing = new ReadOnlyBooleanDelegate(Node.this, \"showing\", ov);\n+        }\n+\n+        return showing;\n+    }\n+\n+    \/\/ Candidate to make publicly available or to add as a convience method to ObservableValue\n+    private static class ReadOnlyBooleanDelegate extends ReadOnlyBooleanProperty {\n+        private final ObservableValue<Boolean> delegate;\n+        private final Object bean;\n+        private final String name;\n+\n+        ReadOnlyBooleanDelegate(Object bean, String name, ObservableValue<Boolean> delegate) {\n+            this.bean = bean;\n+            this.name = name;\n+            this.delegate = delegate.orElse(false);\n+        }\n+\n+        @Override\n+        public Object getBean() {\n+            return bean;\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return name;\n+        }\n+\n+        @Override\n+        public void addListener(ChangeListener<? super Boolean> listener) {\n+            delegate.addListener(listener);\n+        }\n+\n+        @Override\n+        public void removeListener(ChangeListener<? super Boolean> listener) {\n+            delegate.removeListener(listener);\n+        }\n+\n+        @Override\n+        public void addListener(InvalidationListener listener) {\n+            delegate.addListener(listener);\n+        }\n+\n+        @Override\n+        public void removeListener(InvalidationListener listener) {\n+            delegate.removeListener(listener);\n+        }\n+\n+        @Override\n+        public boolean get() {\n+            return delegate.getValue();  \/\/ orElse guarantees this is never null\n+        }\n+    }\n+\n@@ -8390,7 +8472,0 @@\n-    private boolean isWindowShowing() {\n-        Scene s = getScene();\n-        if (s == null) return false;\n-        Window w = s.getWindow();\n-        return w != null && w.isShowing();\n-    }\n-\n@@ -8398,1 +8473,1 @@\n-        return isTreeVisible() && isWindowShowing();\n+        return isTreeVisible() && isShowing();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Node.java","additions":83,"deletions":8,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -1258,0 +1258,57 @@\n+    @Test\n+    public void testIsShowingProperty() {\n+        final Group g = new Group();\n+        final Circle c = new CircleTest.StubCircle(50);\n+\n+        ParentShim.getChildren(g).add(c);\n+\n+        Scene s = new Scene(g);\n+        Stage st = new Stage();\n+\n+        assertFalse(g.isShowing());\n+        assertFalse(c.isShowing());\n+        assertFalse(g.showingProperty().get());\n+        assertFalse(c.showingProperty().get());\n+\n+        st.show();\n+        st.setScene(s);\n+        SceneShim.scenePulseListener_pulse(s);\n+\n+        assertTrue(g.isShowing());\n+        assertTrue(c.isShowing());\n+        assertTrue(g.showingProperty().get());\n+        assertTrue(c.showingProperty().get());\n+\n+        g.setVisible(false);  \/\/ irrelevant change for isShowing\n+        SceneShim.scenePulseListener_pulse(s);\n+\n+        assertTrue(g.isShowing());\n+        assertTrue(c.isShowing());\n+        assertTrue(g.showingProperty().get());\n+        assertTrue(c.showingProperty().get());\n+\n+        s.setRoot(new Group());\n+        SceneShim.scenePulseListener_pulse(s);\n+\n+        assertFalse(g.isShowing());\n+        assertFalse(c.isShowing());\n+        assertFalse(g.showingProperty().get());\n+        assertFalse(c.showingProperty().get());\n+\n+        s.setRoot(g);\n+        SceneShim.scenePulseListener_pulse(s);\n+\n+        assertTrue(g.isShowing());\n+        assertTrue(c.isShowing());\n+        assertTrue(g.showingProperty().get());\n+        assertTrue(c.showingProperty().get());\n+\n+        st.hide();\n+        SceneShim.scenePulseListener_pulse(s);\n+\n+        assertFalse(g.isShowing());\n+        assertFalse(c.isShowing());\n+        assertFalse(g.showingProperty().get());\n+        assertFalse(c.showingProperty().get());\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/NodeTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"}]}