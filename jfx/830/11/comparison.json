{"files":[{"patch":"@@ -0,0 +1,67 @@\n+package com.sun.javafx.binding;\n+\n+import java.util.Objects;\n+\n+import javafx.beans.value.ObservableValue;\n+\n+public class ConditionalBinding<T> extends LazyObjectBinding<T> {\n+\n+    private final ObservableValue<T> source;\n+    private final ObservableValue<Boolean> nonNullCondition;\n+\n+    private Subscription subscription;\n+\n+    public ConditionalBinding(ObservableValue<T> source, ObservableValue<Boolean> condition) {\n+        this.source = Objects.requireNonNull(source, \"source cannot be null\");\n+        this.nonNullCondition = Objects.requireNonNull(condition, \"condition cannot be null\").orElse(false);\n+\n+        \/\/ condition is always observed and never unsubscribed\n+        Subscription.subscribe(nonNullCondition, current -> {\n+            invalidate();\n+\n+            if (!current) {\n+                getValue();\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * This binding is valid whenever it is observed, or it is currently inactive.\n+     * When inactive, the binding has the value of its source at the time it became\n+     * inactive.\n+     *\/\n+    @Override\n+    protected boolean allowValidation() {\n+        return super.allowValidation() || !isActive();\n+    }\n+\n+    @Override\n+    protected T computeValue() {\n+        if (isObserved() && isActive()) {\n+            if (subscription == null) {\n+                subscription = Subscription.subscribeInvalidations(source, this::invalidate);\n+            }\n+        }\n+        else {\n+            unsubscribe();\n+        }\n+\n+        return source.getValue();\n+    }\n+\n+    @Override\n+    protected Subscription observeSources() {\n+        return this::unsubscribe;\n+    }\n+\n+    private boolean isActive() {\n+        return nonNullCondition.getValue();\n+    }\n+\n+    private void unsubscribe() {\n+        if (subscription != null) {\n+            subscription.unsubscribe();\n+            subscription = null;\n+        }\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ConditionalBinding.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import com.sun.javafx.binding.ConditionalBinding;\n@@ -254,0 +255,45 @@\n+\n+    \/**\n+     * Returns an {@code ObservableValue} that holds this value and is updated only\n+     * when {@code condition} holds {@code true}.\n+     * <p>\n+     * The returned {@code ObservableValue} only observes this value when\n+     * {@code condition} holds {@code true}. This allows this {@code ObservableValue}\n+     * and the conditional {@code ObservableValue} to be garbage collected if neither is\n+     * otherwise strongly referenced when {@code condition} holds {@code false}.\n+     * This is in contrast to the general behavior of bindings, where the binding is\n+     * only eligible for garbage collection when not observed itself.\n+     * <p>\n+     * A {@code condition} holding {@code null} is treated as holding {@code false}.\n+     * <p>\n+     * For example:\n+     * <pre>{@code\n+     * ObservableValue<Boolean> condition = new SimpleBooleanProperty(true);\n+     * ObservableValue<String> longLivedProperty = new SimpleStringProperty(\"A\");\n+     * ObservableValue<String> whenProperty = longLivedProperty.when(condition);\n+     *\n+     * \/\/ observe whenProperty, which will in turn observe longLivedProperty\n+     * whenProperty.addListener((ov, old, current) -> System.out.println(current));\n+     *\n+     * longLivedProperty.setValue(\"B\");  \/\/ \"B\" is printed\n+     *\n+     * condition.setValue(false);\n+     *\n+     * \/\/ After condition becomes false, whenProperty stops observing longLivedProperty; condition\n+     * \/\/ and whenProperty may now be eligible for GC despite being observed by the ChangeListener\n+     *\n+     * longLivedProperty.setValue(\"C\");  \/\/ nothing is printed\n+     * longLivedProperty.setValue(\"D\");  \/\/ nothing is printed\n+     *\n+     * condition.setValue(true);  \/\/ longLivedProperty is observed again, and \"D\" is printed\n+     * }<\/pre>\n+     *\n+     * @param condition a boolean {@code ObservableValue}, cannot be {@code null}\n+     * @return an {@code ObservableValue} that holds this value whenever the given\n+     *     condition evaluates to {@code true}, otherwise holds the last seen value;\n+     *     never returns {@code null}\n+     * @since 20\n+     *\/\n+    default ObservableValue<T> when(ObservableValue<Boolean> condition) {\n+        return new ConditionalBinding<>(this, condition);\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/ObservableValue.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -42,0 +42,4 @@\n+import javafx.beans.property.BooleanProperty;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n@@ -48,0 +52,1 @@\n+\n@@ -50,1 +55,0 @@\n-    private final StringProperty property = new SimpleStringProperty(\"Initial\");\n@@ -55,0 +59,2 @@\n+    private StringProperty property = new SimpleStringProperty(\"Initial\");\n+\n@@ -881,0 +887,278 @@\n+    @Nested\n+    class When_when_Called {\n+\n+        @Nested\n+        class WithNull {\n+\n+            @Test\n+            void shouldThrowNullPointerException() {\n+                assertThrows(NullPointerException.class, () -> property.when(null));\n+            }\n+        }\n+\n+        @Nested\n+        class WithNotNullAndInitiallyFalseConditionReturns_ObservableValue_Which {\n+            private BooleanProperty condition = new SimpleBooleanProperty(false);\n+            private ObservableValue<String> observableValue = property.when(condition);\n+\n+            @Test\n+            void shouldNotBeNull() {\n+                assertNotNull(observableValue);\n+            }\n+\n+            @Test\n+            void shouldNotBeStronglyReferenced() {\n+                ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> {\n+                    observableValue = null;\n+                    condition = null;\n+                });\n+            }\n+\n+            @Nested\n+            class When_getValue_Called {\n+\n+                @Test\n+                void shouldReturnInitialValueAtTimeOfCreation() {\n+                    property.set(\"Not Initial\");\n+\n+                    assertEquals(\"Initial\", observableValue.getValue());\n+                }\n+            }\n+        }\n+\n+        @Nested\n+        class WithNotNullReturns_ObservableValue_Which {\n+            private ObjectProperty<Boolean> condition = new SimpleObjectProperty<Boolean>(true);  \/\/ using object property here so it can be set to null for testing\n+            private ObservableValue<String> observableValue = property.when(condition);\n+\n+            @Test\n+            void shouldNotBeNull() {\n+                assertNotNull(observableValue);\n+            }\n+\n+            @Test\n+            void shouldNotBeStronglyReferenced() {\n+                ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> {\n+                    observableValue = null;\n+                    condition = null;\n+                });\n+            }\n+\n+            @Nested\n+            class When_getValue_Called {\n+\n+                @Test\n+                void shouldReturnCurrentPropertyValuesWhileConditionIsTrue() {\n+                    assertEquals(\"Initial\", observableValue.getValue());\n+\n+                    property.set(null);\n+\n+                    assertNull(observableValue.getValue());\n+\n+                    property.set(\"Left\");\n+\n+                    assertEquals(\"Left\", observableValue.getValue());\n+\n+                    condition.set(false);\n+\n+                    property.set(\"Right\");\n+\n+                    assertEquals(\"Left\", observableValue.getValue());\n+\n+                    property.set(\"Middle\");\n+\n+                    assertEquals(\"Left\", observableValue.getValue());\n+\n+                    condition.set(true);\n+\n+                    assertEquals(\"Middle\", observableValue.getValue());\n+                }\n+            }\n+\n+            @Nested\n+            class WhenObservedForInvalidations {\n+                {\n+                    startObservingInvalidations(observableValue);\n+                }\n+\n+                @Test\n+                void shouldOnlyInvalidateOnce() {\n+                    assertNotInvalidated();\n+\n+                    property.set(\"Left\");\n+\n+                    assertInvalidated();\n+\n+                    property.set(\"Right\");\n+\n+                    assertNotInvalidated();\n+                }\n+\n+                @Test\n+                void shouldOnlyInvalidateWhileConditionIsTrue() {\n+                    assertNotInvalidated();\n+\n+                    property.set(\"Left\");  \/\/ trigger invalidation\n+\n+                    assertInvalidated();\n+\n+                    condition.set(false);\n+\n+                    assertNotInvalidated();  \/\/ already invalid, changing condition won't change that\n+\n+                    observableValue.getValue();  \/\/ this would normally make the property valid, but not when condition is false\n+\n+                    property.set(\"Right\");  \/\/ trigger invalidation\n+\n+                    assertNotInvalidated();  \/\/ nothing happened\n+\n+                    condition.setValue(null);  \/\/ null is false as well, should not change result\n+\n+                    assertNotInvalidated();  \/\/ nothing happened\n+\n+                    condition.set(true);\n+\n+                    assertInvalidated();\n+\n+                    observableValue.getValue();  \/\/ make property valid\n+\n+                    assertNotInvalidated();\n+\n+                    property.set(\"Middle\");  \/\/ trigger invalidation\n+\n+                    assertInvalidated();\n+                }\n+\n+                @Test\n+                void shouldBeStronglyReferenced() {\n+                    ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> {\n+                        observableValue = null;\n+                        condition = null;\n+                    });\n+                }\n+\n+                @Test\n+                void shouldNotBeStronglyReferencedWhenConditionIsFalse() {\n+                    condition.set(false);\n+\n+                    ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> {\n+                        observableValue = null;\n+                        condition = null;\n+                    });\n+                }\n+\n+                @Nested\n+                class AndWhenUnobserved {\n+                    {\n+                        stopObservingInvalidations(observableValue);\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeCalled() {\n+                        assertNotInvalidated();\n+\n+                        property.set(\"Left\");\n+                        property.set(\"Right\");\n+\n+                        assertNotInvalidated();\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeStronglyReferenced() {\n+                        ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> {\n+                            observableValue = null;\n+                            condition = null;\n+                        });\n+                    }\n+                }\n+            }\n+\n+            @Nested\n+            class WhenObservedForChanges {\n+                {\n+                    startObservingChanges(observableValue);\n+                }\n+\n+                @Test\n+                void shouldReceiveCurrentPropertyValues() {\n+                    assertNothingIsObserved();\n+\n+                    property.set(\"Right\");\n+\n+                    assertObserved(\"Right\");\n+                }\n+\n+                @Test\n+                void shouldOnlyReceiveCurrentPropertyValuesWhileConditionIsTrue() {\n+                    assertNothingIsObserved();\n+\n+                    property.set(\"Right\");\n+\n+                    assertObserved(\"Right\");\n+\n+                    condition.set(false);\n+\n+                    assertNothingIsObserved();\n+\n+                    property.set(\"Left\");\n+\n+                    assertNothingIsObserved();\n+\n+                    property.set(\"Middle\");\n+\n+                    assertNothingIsObserved();\n+\n+                    condition.setValue(null);  \/\/ null is false as well, should not change result\n+\n+                    assertNothingIsObserved();\n+\n+                    condition.set(true);\n+\n+                    assertObserved(\"Middle\");\n+                }\n+\n+                @Test\n+                void shouldBeStronglyReferenced() {\n+                    ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> {\n+                        observableValue = null;\n+                        condition = null;\n+                    });\n+                }\n+\n+                @Test\n+                void shouldNotBeStronglyReferencedWhenConditionIsFalse() {\n+                    condition.set(false);\n+\n+                    ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> {\n+                        observableValue = null;\n+                        condition = null;\n+                    });\n+                }\n+\n+                @Nested\n+                class AndWhenUnobserved {\n+                    {\n+                        stopObservingChanges(observableValue);\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeCalled() {\n+                        assertNothingIsObserved();\n+\n+                        property.set(\"Right\");\n+\n+                        assertNothingIsObserved();\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeStronglyReferenced() {\n+                        ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> {\n+                            observableValue = null;\n+                            condition = null;\n+                        });\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -894,1 +1178,1 @@\n-        assertEquals(values, Arrays.asList(expectedValues));\n+        assertEquals(Arrays.asList(expectedValues), values);\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/ObservableValueFluentBindingsTest.java","additions":286,"deletions":2,"binary":false,"changes":288,"status":"modified"}]}