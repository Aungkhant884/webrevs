{"files":[{"patch":"@@ -59,0 +59,4 @@\n+\n+    boolean isPointLight() {\n+        return falloff == 0 && outerAngle == 180;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/ES2Light.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -215,7 +215,0 @@\n-        float length = 1, cosOuter = 0, cosInner = 1;\n-        if (light.falloff != 0) {\n-            \/\/ preparing for: I = pow((cosAngle - cosOuter) \/ (cosInner - cosOuter), falloff);\n-            length = (float) Math.sqrt(light.dirX * light.dirX + light.dirY * light.dirY + light.dirZ * light.dirZ);\n-            cosOuter = (float) Math.cos(Math.toRadians(light.outerAngle));\n-            cosInner = (float) Math.cos(Math.toRadians(light.innerAngle));\n-        }\n@@ -226,4 +219,18 @@\n-        shader.setConstant(\"lights[\" + i + \"].normDir\", light.dirX \/ length, light.dirY \/ length, light.dirZ \/ length);\n-        shader.setConstant(\"lights[\" + i + \"].cosOuter\", cosOuter);\n-        shader.setConstant(\"lights[\" + i + \"].denom\", cosInner - cosOuter);\n-        shader.setConstant(\"lights[\" + i + \"].falloff\", light.falloff);\n+        if (light.isPointLight()) {\n+            shader.setConstant(\"lights[\" + i + \"].lightDir\", 0f, 0f, 1f);\n+            shader.setConstant(\"lights[\" + i + \"].cosOuter\", -1f); \/\/ cos(180)\n+            shader.setConstant(\"lights[\" + i + \"].denom\", 2f);     \/\/ cos(0) - cos(180)\n+            shader.setConstant(\"lights[\" + i + \"].falloff\", 0f);\n+        } else {\n+            float dirX = light.dirX;\n+            float dirY = light.dirY;\n+            float dirZ = light.dirZ;\n+            float length = (float) Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);\n+            shader.setConstant(\"lights[\" + i + \"].dir\", dirX \/ length, dirY \/ length, dirZ \/ length);\n+            \/\/ preparing for: I = pow((cosAngle - cosOuter) \/ (cosInner - cosOuter), falloff);\n+            float cosOuter = (float) Math.cos(Math.toRadians(light.outerAngle));\n+            float cosInner = (float) Math.cos(Math.toRadians(light.innerAngle));\n+            shader.setConstant(\"lights[\" + i + \"].cosOuter\", cosOuter);\n+            shader.setConstant(\"lights[\" + i + \"].denom\", cosInner - cosOuter);\n+            shader.setConstant(\"lights[\" + i + \"].falloff\", light.falloff);\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/ES2PhongShader.java","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    vec3 normDir;\n+    vec3 dir;\n@@ -105,1 +105,1 @@\n-    vec3 D = lights[0].normDir.xyz;\n+    vec3 D = lights[0].dir.xyz;\n@@ -108,1 +108,1 @@\n-    D = lights[1].normDir.xyz;\n+    D = lights[1].dir.xyz;\n@@ -111,1 +111,1 @@\n-    D = lights[2].normDir.xyz;\n+    D = lights[2].dir.xyz;\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/prism\/es2\/glsl\/main.vert","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    vec3 normDir;\n+    vec3 dir;\n@@ -76,5 +76,13 @@\n-void main()\n-{\n-    vec4 diffuse = apply_diffuse();\n-\n-    if (diffuse.a == 0.0) discard;\n+\/\/ Because pow(0, 0) is undefined (https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/direct3dhlsl\/dx-graphics-hlsl-pow),\n+\/\/ we need special treatment for falloff == 0 cases\n+float computeSpotlightFactor(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    if (falloff == 0 && cosOuter == -1) { \/\/ point light optimization (cosOuter == -1 is outerAngle == 180)\n+        return 1;\n+    }\n+    float cosAngle = dot(normalize(lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    if (falloff != 0) {\n+        return pow(clamp(cutoff \/ denom, 0, 1), falloff);\n+    }\n+    return cutoff >= 0 ? 1 : 0;\n+}\n@@ -82,2 +90,13 @@\n-    vec3 d = vec3(0.0);\n-    vec3 s = vec3(0.0);\n+float computeSpotlightFactor2(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    if (falloff != 0) {\n+        float cosAngle = dot(normalize(lightDir), l);\n+        float cutoff = cosAngle - cosOuter;\n+        return pow(clamp(cutoff \/ denom, 0, 1), falloff);\n+    }\n+    if (cosOuter == -1) {  \/\/ point light optimization (cosOuter == -1 is outerAngle == 180)\n+        return 1;\n+    }\n+    float cosAngle = dot(normalize(lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    return cutoff >= 0 ? 1 : 0;\n+}\n@@ -85,1 +104,8 @@\n-    vec4 specular = apply_specular();\n+float computeSpotlightFactor3(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    float cosAngle = dot(normalize(lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    if (falloff != 0) {\n+        return pow(clamp(cutoff \/ denom, 0, 1), falloff);\n+    }\n+    return cutoff >= 0 ? 1 : 0;\n+}\n@@ -87,4 +113,5 @@\n-    float maxRange = lights[0].range;\n-    float dist = length(lightTangentSpacePositions[0].xyz);\n-    if (dist > maxRange) {\n-        gl_FragColor = vec4(0, 0, 0, 1);\n+void computeLight(int i, vec3 n, vec3 refl, float specPower, out vec3 d, out vec3 s) {\n+    Light light = lights[i];\n+    vec3 pos = lightTangentSpacePositions[i].xyz;\n+    float dist = length(pos);\n+    if (dist > light.range) {\n@@ -93,0 +120,17 @@\n+    vec3 l = normalize(pos);\n+\n+    vec3 lightDir = lightTangentSpaceDirections[i].xyz;\n+    float spotlightFactor = computeSpotlightFactor3(l, lightDir, light.cosOuter, light.denom, light.falloff);\n+\n+    float invAttnFactor = light.attn.x + light.attn.y * dist + light.attn.z * dist * dist;\n+\n+    vec3 attenuatedColor = light.color.rgb * spotlightFactor \/ invAttnFactor;\n+    d += clamp(dot(n,l), 0.0, 1.0) * attenuatedColor;\n+    s += pow(clamp(dot(-refl, l), 0.0, 1.0), specPower) * attenuatedColor;\n+}\n+\n+void main()\n+{\n+    vec4 diffuse = apply_diffuse();\n+\n+    if (diffuse.a == 0.0) discard;\n@@ -96,1 +140,0 @@\n-    vec3 l = normalize(lightTangentSpacePositions[0].xyz);\n@@ -98,6 +141,2 @@\n-    float spotlightFactor = 1;\n-    if (lights[0].falloff != 0) {  \/\/ possible optimization\n-        float cosAngle = dot(lightTangentSpaceDirections[0].xyz, l);\n-        float base = (cosAngle - lights[0].cosOuter) \/ lights[0].denom;\n-        spotlightFactor = pow(clamp(base, 0.0, 1.0), lights[0].falloff);\n-    }\n+    vec3 d = vec3(0.0);\n+    vec3 s = vec3(0.0);\n@@ -105,0 +144,1 @@\n+    vec4 specular = apply_specular();\n@@ -106,4 +146,2 @@\n-    float invAttnFactor = lights[0].attn.x + lights[0].attn.y * dist + lights[0].attn.z * dist * dist;\n-    vec3 attenuatedColor = lights[0].color.rgb * spotlightFactor \/ invAttnFactor;\n-    d = clamp(dot(n, l), 0.0, 1.0) * attenuatedColor;\n-    s = pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;\n+\n+    computeLight(0, n, refl, power, d, s);\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/prism\/es2\/glsl\/main1Light.frag","additions":62,"deletions":24,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    vec3 normDir;\n+    vec3 dir;\n@@ -76,1 +76,38 @@\n-void addContribution(int i, out vec3 d, out vec3 s, float power, vec3 n, vec3 refl) {\n+\/\/ Because pow(0, 0) is undefined (https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/direct3dhlsl\/dx-graphics-hlsl-pow),\n+\/\/ we need special treatment for falloff == 0 cases\n+float computeSpotlightFactor(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    if (falloff == 0 && cosOuter == -1) { \/\/ point light optimization (cosOuter == -1 is outerAngle == 180)\n+        return 1;\n+    }\n+    float cosAngle = dot(normalize(lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    if (falloff != 0) {\n+        return pow(clamp(cutoff \/ denom, 0, 1), falloff);\n+    }\n+    return cutoff >= 0 ? 1 : 0;\n+}\n+\n+float computeSpotlightFactor2(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    if (falloff != 0) {\n+        float cosAngle = dot(normalize(lightDir), l);\n+        float cutoff = cosAngle - cosOuter;\n+        return pow(clamp(cutoff \/ denom, 0, 1), falloff);\n+    }\n+    if (cosOuter == -1) {  \/\/ point light optimization (cosOuter == -1 is outerAngle == 180)\n+        return 1;\n+    }\n+    float cosAngle = dot(normalize(lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    return cutoff >= 0 ? 1 : 0;\n+}\n+\n+float computeSpotlightFactor3(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    float cosAngle = dot(normalize(lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    if (falloff != 0) {\n+        return pow(clamp(cutoff \/ denom, 0, 1), falloff);\n+    }\n+    return cutoff >= 0 ? 1 : 0;\n+}\n+\n+void computeLight(int i, vec3 n, vec3 refl, float specPower, out vec3 d, out vec3 s) {\n@@ -84,8 +121,4 @@\n-    float spotlightFactor = 1;\n-    float falloff = light.falloff;\n-    if (falloff != 0) {  \/\/ possible optimization\n-        vec3 dir = lightTangentSpaceDirections[i].xyz;\n-        float cosAngle = dot(dir, l);\n-        float base = (cosAngle - light.cosOuter) \/ light.denom;\n-        spotlightFactor = pow(clamp(base, 0.0, 1.0), falloff);\n-    }\n+\n+    vec3 lightDir = lightTangentSpaceDirections[i].xyz;\n+    float spotlightFactor = computeSpotlightFactor3(l, lightDir, light.cosOuter, light.denom, light.falloff);\n+\n@@ -93,0 +126,1 @@\n+\n@@ -95,1 +129,1 @@\n-    s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;\n+    s += pow(clamp(dot(-refl, l), 0.0, 1.0), specPower) * attenuatedColor;\n@@ -113,2 +147,2 @@\n-    addContribution(0, d, s, power, n, refl);\n-    addContribution(1, d, s, power, n, refl);\n+    computeLight(0, n, refl, power, d, s);\n+    computeLight(1, n, refl, power, d, s);\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/prism\/es2\/glsl\/main2Lights.frag","additions":47,"deletions":13,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    vec3 normDir;\n+    vec3 dir;\n@@ -76,1 +76,38 @@\n-void addContribution(int i, out vec3 d, out vec3 s, float power, vec3 n, vec3 refl) {\n+\/\/ Because pow(0, 0) is undefined (https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/direct3dhlsl\/dx-graphics-hlsl-pow),\n+\/\/ we need special treatment for falloff == 0 cases\n+float computeSpotlightFactor(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    if (falloff == 0 && cosOuter == -1) { \/\/ point light optimization (cosOuter == -1 is outerAngle == 180)\n+        return 1;\n+    }\n+    float cosAngle = dot(normalize(lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    if (falloff != 0) {\n+        return pow(clamp(cutoff \/ denom, 0, 1), falloff);\n+    }\n+    return cutoff >= 0 ? 1 : 0;\n+}\n+\n+float computeSpotlightFactor2(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    if (falloff != 0) {\n+        float cosAngle = dot(normalize(lightDir), l);\n+        float cutoff = cosAngle - cosOuter;\n+        return pow(clamp(cutoff \/ denom, 0, 1), falloff);\n+    }\n+    if (cosOuter == -1) {  \/\/ point light optimization (cosOuter == -1 is outerAngle == 180)\n+        return 1;\n+    }\n+    float cosAngle = dot(normalize(lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    return cutoff >= 0 ? 1 : 0;\n+}\n+\n+float computeSpotlightFactor3(vec3 l, vec3 lightDir, float cosOuter, float denom, float falloff) {\n+    float cosAngle = dot(normalize(lightDir), l);\n+    float cutoff = cosAngle - cosOuter;\n+    if (falloff != 0) {\n+        return pow(clamp(cutoff \/ denom, 0, 1), falloff);\n+    }\n+    return cutoff >= 0 ? 1 : 0;\n+}\n+\n+void computeLight(int i, vec3 n, vec3 refl, float specPower, out vec3 d, out vec3 s) {\n@@ -84,8 +121,4 @@\n-    float spotlightFactor = 1;\n-    float falloff = light.falloff;\n-    if (falloff != 0) {  \/\/ possible optimization\n-        vec3 dir = lightTangentSpaceDirections[i].xyz;\n-        float cosAngle = dot(dir, l);\n-        float base = (cosAngle - light.cosOuter) \/ light.denom;\n-        spotlightFactor = pow(clamp(base, 0.0, 1.0), falloff);\n-    }\n+\n+    vec3 lightDir = lightTangentSpaceDirections[i].xyz;\n+    float spotlightFactor = computeSpotlightFactor3(l, lightDir, light.cosOuter, light.denom, light.falloff);\n+\n@@ -93,0 +126,1 @@\n+\n@@ -95,1 +129,1 @@\n-    s += pow(clamp(dot(-refl, l), 0.0, 1.0), power) * attenuatedColor;\n+    s += pow(clamp(dot(-refl, l), 0.0, 1.0), specPower) * attenuatedColor;\n@@ -113,3 +147,3 @@\n-    addContribution(0, d, s, power, n, refl);\n-    addContribution(1, d, s, power, n, refl);\n-    addContribution(2, d, s, power, n, refl);\n+    computeLight(0, n, refl, power, d, s);\n+    computeLight(1, n, refl, power, d, s);\n+    computeLight(2, n, refl, power, d, s);\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/prism\/es2\/glsl\/main3Lights.frag","additions":48,"deletions":14,"binary":false,"changes":62,"status":"modified"}]}