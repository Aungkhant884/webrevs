{"files":[{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.lighting3D;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assume.assumeTrue;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import javafx.application.Application;\n+import javafx.application.ConditionalFeature;\n+import javafx.application.Platform;\n+import javafx.scene.Group;\n+import javafx.scene.Scene;\n+import javafx.scene.SpotLight;\n+import javafx.scene.paint.Color;\n+import javafx.scene.shape.Box;\n+import javafx.stage.Stage;\n+import javafx.stage.WindowEvent;\n+import test.util.Util;\n+\n+\/\/ Since there appears to be a bug in snapshot with subscene, we are taking a snapshot of the scene and not\n+\/\/ the box, so the center of the box will be at the top left, (0, 0), of the image, and the light is\n+\/\/ straight in front. Without attenuation, at (0, 0) it will give its full color.\n+\/\/\n+\/\/       x\n+\/\/  -----------\n+\/\/  |         \/\n+\/\/  |        \/     d - the distance of the light from the object\n+\/\/  |       \/      x - the horizontal distance of the sample point on the object\n+\/\/  |      \/       a - the angle to the sample point\n+\/\/ d|     \/\n+\/\/  |    \/         tan(a) = x\/d\n+\/\/  |   \/          cos(a) = cos(atan(x\/d)) = 1 \/ sqrt((x\/d)^2 + 1)\n+\/\/  |a \/\n+\/\/  | \/\n+\/\/  |\/\n+\/\/\n+public class LightingTest {\n+\n+    \/\/ 1d\/255 is the smallest color resolution, but we use 10d\/255 to avoid precision problems\n+    private static final double DELTA = 10d\/255;\n+\n+    private static final String FAIL_MESSAGE = \"Wrong color value\";\n+\n+    private static final int LIGTH_DIST = 60;\n+\n+    \/\/ X coordinates for the point used in Lambert tests\n+    private static final int[] LAMBERT_SAMPLE_DISTS = new int[] {0, 30, 60};\n+\n+    \/\/ X coordinate for the point used in attenuation tests\n+    private static final int ATTN_SAMPLE_DIST = LIGTH_DIST;\n+\n+    \/\/ Angles for points used in spotlight factor tests\n+    private static final double INNER_ANGLE = 20;\n+    private static final double OUTER_ANGLE = 40;\n+    private static final int INSIDE_ANGLE_SAMPLE = 18;\n+    private static final int MIDDLE_ANGLE_SAMPLE = 30;\n+    private static final int OUTSIDE_ANGLE_SAMPLE = 42;\n+\n+    private static final SpotLight LIGHT = new SpotLight(Color.BLUE);\n+    private static final Box BOX = new Box(150, 150, 1);\n+\n+    private static CountDownLatch startupLatch;\n+    private static Stage stage;\n+\n+    public static void main(String[] args) throws Exception {\n+        initFX();\n+    }\n+\n+    @BeforeClass\n+    public static void initFX() throws Exception {\n+        startupLatch = new CountDownLatch(1);\n+        new Thread(() -> Application.launch(TestApp.class, (String[])null)).start();\n+        assertTrue(\"Timeout waiting for FX runtime to start\", startupLatch.await(15, TimeUnit.SECONDS));\n+    }\n+\n+    public static class TestApp extends Application {\n+\n+        @Override\n+        public void start(Stage mainStage) {\n+            stage = mainStage;\n+            LIGHT.setTranslateZ(-LIGTH_DIST);\n+            var root = new Group(LIGHT, BOX);\n+            var scene = new Scene(root);\n+            stage.setScene(scene);\n+            stage.addEventHandler(WindowEvent.WINDOW_SHOWN, e -> Platform.runLater(startupLatch::countDown));\n+            stage.show();\n+        }\n+    }\n+\n+    @Before\n+    public void setupEach() {\n+        assumeTrue(Platform.isSupported(ConditionalFeature.SCENE3D));\n+        LIGHT.setInnerAngle(0);\n+        LIGHT.setOuterAngle(30);\n+        LIGHT.setFalloff(1);\n+        LIGHT.setConstantAttenuation(1);\n+        LIGHT.setLinearAttenuation(0);\n+        LIGHT.setQuadraticAttenuation(0);\n+        LIGHT.setMaxRange(Double.POSITIVE_INFINITY);\n+    }\n+\n+    \/\/ The Lambert term is dot(N,L) = cos(a)\n+    @Test\n+    public void testLambert() {\n+        Util.runAndWait(() -> {\n+            \/\/ eliminating the spotlight factor contribution\n+            LIGHT.setFalloff(0);\n+            LIGHT.setOuterAngle(180);\n+\n+            var snapshot = BOX.getScene().snapshot(null);\n+            for (int x : LAMBERT_SAMPLE_DISTS) {\n+                double sampledBlue = snapshot.getPixelReader().getColor(x, 0).getBlue();\n+                assertEquals(FAIL_MESSAGE, calculateLambertTerm(x), sampledBlue, DELTA);\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testAttenuation() {\n+        Util.runAndWait(() -> {\n+            \/\/ eliminating the spotlight factor contribution\n+            LIGHT.setFalloff(0);\n+            LIGHT.setOuterAngle(180);\n+\n+            double diagDist = Math.sqrt(LIGTH_DIST * LIGTH_DIST + ATTN_SAMPLE_DIST * ATTN_SAMPLE_DIST);\n+            double lambertCenter = calculateLambertTerm(0);\n+            double lambertSample = calculateLambertTerm(ATTN_SAMPLE_DIST);\n+\n+            LIGHT.setLinearAttenuation(0.01);\n+            var snapshot = BOX.getScene().snapshot(null);\n+\n+            double attn = calculateAttenuationFactor(LIGTH_DIST);\n+            double sampledBlue = snapshot.getPixelReader().getColor(0, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE, lambertCenter * attn, sampledBlue, DELTA);\n+\n+            attn = calculateAttenuationFactor(diagDist);\n+            sampledBlue = snapshot.getPixelReader().getColor(ATTN_SAMPLE_DIST, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE, lambertSample * attn, sampledBlue, DELTA);\n+\n+            LIGHT.setLinearAttenuation(0);\n+            LIGHT.setQuadraticAttenuation(0.01);\n+            snapshot = BOX.getScene().snapshot(null);\n+\n+            attn = calculateAttenuationFactor(LIGTH_DIST);\n+            sampledBlue = snapshot.getPixelReader().getColor(0, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE, lambertCenter * attn, sampledBlue, DELTA);\n+\n+            attn = calculateAttenuationFactor(diagDist);\n+            sampledBlue = snapshot.getPixelReader().getColor(ATTN_SAMPLE_DIST, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE, lambertSample * attn, sampledBlue, DELTA);\n+        });\n+    }\n+\n+    @Test\n+    public void testRange() {\n+        Util.runAndWait(() -> {\n+            \/\/ eliminating the spotlight factor contribution\n+            LIGHT.setFalloff(0);\n+            LIGHT.setOuterAngle(180);\n+\n+            double diagDist = Math.sqrt(LIGTH_DIST * LIGTH_DIST + ATTN_SAMPLE_DIST * ATTN_SAMPLE_DIST);\n+            LIGHT.setMaxRange((LIGTH_DIST + diagDist) \/ 2);\n+            var snapshot = BOX.getScene().snapshot(null);\n+\n+            double sampledBlue = snapshot.getPixelReader().getColor(0, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE + \", should be in range\", 1, sampledBlue, DELTA);\n+\n+            sampledBlue = snapshot.getPixelReader().getColor(ATTN_SAMPLE_DIST, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE + \", should be out of range\", 0, sampledBlue, DELTA);\n+        });\n+    }\n+\n+    @Test\n+    public void testSpotlightAttenuation() {\n+        Util.runAndWait(() -> {\n+            LIGHT.setInnerAngle(INNER_ANGLE);\n+            LIGHT.setOuterAngle(OUTER_ANGLE);\n+            var snapshot = BOX.getScene().snapshot(null);\n+\n+            int innerX = angleToHorizontalDistance(INSIDE_ANGLE_SAMPLE);\n+            double spotFactor = 1;\n+            double sampledBlue = snapshot.getPixelReader().getColor(innerX, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE, calculateLambertTerm(innerX) * spotFactor, sampledBlue, DELTA);\n+\n+            int middleX = angleToHorizontalDistance(MIDDLE_ANGLE_SAMPLE);\n+            spotFactor = calculateSpotlightFactor(MIDDLE_ANGLE_SAMPLE);\n+            sampledBlue = snapshot.getPixelReader().getColor(middleX, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE, calculateLambertTerm(middleX) * spotFactor, sampledBlue, DELTA);\n+\n+            int outerX = angleToHorizontalDistance(OUTSIDE_ANGLE_SAMPLE);\n+            spotFactor = 0;\n+            sampledBlue = snapshot.getPixelReader().getColor(outerX, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE, calculateLambertTerm(outerX) * spotFactor, sampledBlue, DELTA);\n+        });\n+    }\n+\n+    private static double calculateLambertTerm(double x) {\n+        return Math.cos(Math.atan(x\/LIGTH_DIST));\n+    }\n+\n+    private static double calculateAttenuationFactor(double dist) {\n+        return 1 \/ (LIGHT.getConstantAttenuation() + LIGHT.getLinearAttenuation() * dist\n+                      + LIGHT.getQuadraticAttenuation() * dist * dist);\n+    }\n+\n+    \/\/ I = pow((cosAngle - cosOuter) \/ (cosInner - cosOuter), falloff)\n+    private static double calculateSpotlightFactor(double degrees) {\n+        double numerator = degCos(degrees) - degCos(LIGHT.getOuterAngle());\n+        double denom = degCos(LIGHT.getInnerAngle()) - degCos(LIGHT.getOuterAngle());\n+        return Math.pow(numerator \/ denom, LIGHT.getFalloff());\n+    }\n+\n+    private static double degCos(double degrees) {\n+        return Math.cos(Math.toRadians(degrees));\n+    }\n+\n+    private static int angleToHorizontalDistance(double degrees) {\n+        return (int) (LIGTH_DIST * Math.tan(Math.toRadians(degrees)));\n+    }\n+\n+\n+    @AfterClass\n+    public static void teardown() {\n+        Platform.runLater(() -> {\n+            stage.hide();\n+            Platform.exit();\n+        });\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/lighting3D\/LightingTest.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package test.javafx.scene.lighting3D;\n-\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assume.assumeTrue;\n-import static org.junit.Assert.assertEquals;\n-\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-\n-import org.junit.AfterClass;\n-import org.junit.Before;\n-import org.junit.BeforeClass;\n-import org.junit.Test;\n-\n-import javafx.application.Application;\n-import javafx.application.ConditionalFeature;\n-import javafx.application.Platform;\n-import javafx.scene.Group;\n-import javafx.scene.PointLight;\n-import javafx.scene.Scene;\n-import javafx.scene.paint.Color;\n-import javafx.scene.shape.Box;\n-import javafx.stage.Stage;\n-import javafx.stage.WindowEvent;\n-import test.util.Util;\n-\n-public class PointLightAttenuationTest {\n-\n-    \/\/ 1d\/255 is the smallest color resolution, but we use 10d\/255 to avoid precision problems\n-    private static final double DELTA = 10d\/255;\n-    private static final int LIGTH_DIST = 60;\n-    private static final int SAMPLE_DIST = 60;\n-\n-    private static CountDownLatch startupLatch;\n-    private static Stage stage;\n-    private static PointLight light = new PointLight(Color.BLUE);\n-    private static Box box = new Box(150, 150, 1);\n-\n-    public static void main(String[] args) throws Exception {\n-        initFX();\n-    }\n-\n-    @BeforeClass\n-    public static void initFX() throws Exception {\n-        startupLatch = new CountDownLatch(1);\n-        new Thread(() -> Application.launch(TestApp.class, (String[])null)).start();\n-        assertTrue(\"Timeout waiting for FX runtime to start\", startupLatch.await(15, TimeUnit.SECONDS));\n-    }\n-\n-    @Before\n-    public void setupEach() {\n-        assumeTrue(Platform.isSupported(ConditionalFeature.SCENE3D));\n-    }\n-\n-    public static class TestApp extends Application {\n-\n-        @Override\n-        public void start(Stage mainStage) {\n-            stage = mainStage;\n-            light.setTranslateZ(-LIGTH_DIST);\n-            var root = new Group(light, box);\n-            var scene = new Scene(root);\n-            stage.setScene(scene);\n-            stage.addEventHandler(WindowEvent.WINDOW_SHOWN, e -> Platform.runLater(startupLatch::countDown));\n-            stage.show();\n-        }\n-    }\n-\n-    @Test\n-    public void testAttenuation() {\n-        Util.runAndWait(() -> {\n-            \/\/ Since there appears to be a bug in snapshot with subscene, we are taking a snapshot of the scene and not\n-            \/\/ the box, so the center of the box will be at the top left, (0, 0), of the image, and the light is\n-            \/\/ straight in front. Without attenuation, at (0, 0) it will give its full color. At (SAMPLE_DIST, 0) and\n-            \/\/ LIGTH_DIST == SAMPLE_DIST, it will give cos(45) = 1\/sqrt(2) of its color.\n-            var snapshot = box.getScene().snapshot(null);\n-            double nonAttenBlueCenter = snapshot.getPixelReader().getColor(0, 0).getBlue();\n-            double nonAttenBlueDiag = snapshot.getPixelReader().getColor(SAMPLE_DIST, 0).getBlue();\n-            assertEquals(\"Wrong color value\", 1, nonAttenBlueCenter, DELTA);\n-            assertEquals(\"Wrong color value\", 1\/Math.sqrt(2), nonAttenBlueDiag, DELTA);\n-\n-            double diagDist = Math.sqrt(LIGTH_DIST * LIGTH_DIST + SAMPLE_DIST * SAMPLE_DIST);\n-\n-            light.setLinearAttenuation(0.01);\n-            double attnCenter = 1 \/ (1 + 0.01 * LIGTH_DIST);\n-            double attnDiag = 1 \/ (1 + 0.01 * diagDist);\n-            snapshot = box.getScene().snapshot(null);\n-            double attenBlueCenter = snapshot.getPixelReader().getColor(0, 0).getBlue();\n-            double attenBlueDiag = snapshot.getPixelReader().getColor(SAMPLE_DIST, 0).getBlue();\n-            assertEquals(\"Wrong color value\", nonAttenBlueCenter * attnCenter, attenBlueCenter, DELTA);\n-            assertEquals(\"Wrong color value\", nonAttenBlueDiag * attnDiag, attenBlueDiag, DELTA);\n-\n-            light.setLinearAttenuation(0);\n-            light.setQuadraticAttenuation(0.01);\n-            attnCenter = 1 \/ (1 + 0.01 * LIGTH_DIST * LIGTH_DIST);\n-            attnDiag = 1 \/ (1 + 0.01 * diagDist * diagDist);\n-            snapshot = box.getScene().snapshot(null);\n-            attenBlueCenter = snapshot.getPixelReader().getColor(0, 0).getBlue();\n-            attenBlueDiag = snapshot.getPixelReader().getColor(SAMPLE_DIST, 0).getBlue();\n-            assertEquals(\"Wrong color value\", nonAttenBlueCenter * attnCenter, attenBlueCenter, DELTA);\n-            assertEquals(\"Wrong color value\", nonAttenBlueDiag * attnDiag, attenBlueDiag, DELTA);\n-\n-            light.setQuadraticAttenuation(0);\n-            light.setMaxRange((LIGTH_DIST + diagDist) \/ 2);\n-            snapshot = box.getScene().snapshot(null);\n-            nonAttenBlueCenter = snapshot.getPixelReader().getColor(0, 0).getBlue();\n-            nonAttenBlueDiag = snapshot.getPixelReader().getColor(SAMPLE_DIST, 0).getBlue();\n-            assertEquals(\"Wrong color value, should be in range\", 1, nonAttenBlueCenter, DELTA);\n-            assertEquals(\"Wrong color value, should be out of range\", 0, nonAttenBlueDiag, DELTA);\n-        });\n-    }\n-\n-    @AfterClass\n-    public static void teardown() {\n-        Platform.runLater(() -> {\n-            stage.hide();\n-            Platform.exit();\n-        });\n-    }\n-}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/lighting3D\/PointLightAttenuationTest.java","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"}]}