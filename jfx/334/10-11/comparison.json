{"files":[{"patch":"@@ -28,4 +28,0 @@\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.Assume.assumeTrue;\n-\n@@ -33,1 +29,0 @@\n-import java.util.concurrent.TimeUnit;\n@@ -36,3 +31,0 @@\n-import org.junit.Before;\n-import org.junit.BeforeClass;\n-import org.junit.Test;\n@@ -41,1 +33,0 @@\n-import javafx.application.ConditionalFeature;\n@@ -44,0 +35,1 @@\n+import javafx.scene.LightBase;\n@@ -45,2 +37,1 @@\n-import javafx.scene.SpotLight;\n-import javafx.scene.paint.Color;\n+import javafx.scene.image.WritableImage;\n@@ -50,1 +41,0 @@\n-import test.util.Util;\n@@ -72,5 +62,2 @@\n-    private static final double DELTA = 10d\/255;\n-\n-    private static final String FAIL_MESSAGE = \"Wrong color value\";\n-\n-    private static final int LIGTH_DIST = 60;\n+    protected static final double DELTA = 10d\/255;\n+    protected static final String FAIL_MESSAGE = \"Wrong color value\";\n@@ -78,2 +65,1 @@\n-    \/\/ X coordinates for the point used in Lambert tests\n-    private static final int[] LAMBERT_SAMPLE_DISTS = new int[] {0, 30, 60};\n+    protected static final int LIGTH_DIST = 60;\n@@ -81,2 +67,1 @@\n-    \/\/ X coordinate for the point used in attenuation tests\n-    private static final int ATTN_SAMPLE_DIST = LIGTH_DIST;\n+    protected static LightBase light;\n@@ -84,8 +69,0 @@\n-    \/\/ Angles for points used in spotlight factor tests\n-    private static final double INNER_ANGLE = 20;\n-    private static final double OUTER_ANGLE = 40;\n-    private static final int INSIDE_ANGLE_SAMPLE = 18;\n-    private static final int MIDDLE_ANGLE_SAMPLE = 30;\n-    private static final int OUTSIDE_ANGLE_SAMPLE = 42;\n-\n-    private static final SpotLight LIGHT = new SpotLight(Color.BLUE);\n@@ -94,1 +71,1 @@\n-    private static CountDownLatch startupLatch;\n+    protected static CountDownLatch startupLatch;\n@@ -97,11 +74,0 @@\n-    public static void main(String[] args) throws Exception {\n-        initFX();\n-    }\n-\n-    @BeforeClass\n-    public static void initFX() throws Exception {\n-        startupLatch = new CountDownLatch(1);\n-        new Thread(() -> Application.launch(TestApp.class, (String[])null)).start();\n-        assertTrue(\"Timeout waiting for FX runtime to start\", startupLatch.await(15, TimeUnit.SECONDS));\n-    }\n-\n@@ -113,4 +79,2 @@\n-            LIGHT.setTranslateZ(-LIGTH_DIST);\n-            var root = new Group(LIGHT, BOX);\n-            var scene = new Scene(root);\n-            stage.setScene(scene);\n+            light.setTranslateZ(-LIGTH_DIST);\n+            stage.setScene(new Scene(new Group(light, BOX)));\n@@ -122,62 +86,2 @@\n-    @Before\n-    public void setupEach() {\n-        assumeTrue(Platform.isSupported(ConditionalFeature.SCENE3D));\n-        LIGHT.setInnerAngle(0);\n-        LIGHT.setOuterAngle(30);\n-        LIGHT.setFalloff(1);\n-        LIGHT.setConstantAttenuation(1);\n-        LIGHT.setLinearAttenuation(0);\n-        LIGHT.setQuadraticAttenuation(0);\n-        LIGHT.setMaxRange(Double.POSITIVE_INFINITY);\n-    }\n-\n-    \/\/ The Lambert term is dot(N,L) = cos(a)\n-    @Test\n-    public void testLambert() {\n-        Util.runAndWait(() -> {\n-            \/\/ eliminating the spotlight factor contribution\n-            LIGHT.setFalloff(0);\n-            LIGHT.setOuterAngle(180);\n-\n-            var snapshot = BOX.getScene().snapshot(null);\n-            for (int x : LAMBERT_SAMPLE_DISTS) {\n-                double sampledBlue = snapshot.getPixelReader().getColor(x, 0).getBlue();\n-                assertEquals(FAIL_MESSAGE, calculateLambertTerm(x), sampledBlue, DELTA);\n-            }\n-        });\n-    }\n-\n-    @Test\n-    public void testAttenuation() {\n-        Util.runAndWait(() -> {\n-            \/\/ eliminating the spotlight factor contribution\n-            LIGHT.setFalloff(0);\n-            LIGHT.setOuterAngle(180);\n-\n-            double diagDist = Math.sqrt(LIGTH_DIST * LIGTH_DIST + ATTN_SAMPLE_DIST * ATTN_SAMPLE_DIST);\n-            double lambertCenter = calculateLambertTerm(0);\n-            double lambertSample = calculateLambertTerm(ATTN_SAMPLE_DIST);\n-\n-            LIGHT.setLinearAttenuation(0.01);\n-            var snapshot = BOX.getScene().snapshot(null);\n-\n-            double attn = calculateAttenuationFactor(LIGTH_DIST);\n-            double sampledBlue = snapshot.getPixelReader().getColor(0, 0).getBlue();\n-            assertEquals(FAIL_MESSAGE, lambertCenter * attn, sampledBlue, DELTA);\n-\n-            attn = calculateAttenuationFactor(diagDist);\n-            sampledBlue = snapshot.getPixelReader().getColor(ATTN_SAMPLE_DIST, 0).getBlue();\n-            assertEquals(FAIL_MESSAGE, lambertSample * attn, sampledBlue, DELTA);\n-\n-            LIGHT.setLinearAttenuation(0);\n-            LIGHT.setQuadraticAttenuation(0.01);\n-            snapshot = BOX.getScene().snapshot(null);\n-\n-            attn = calculateAttenuationFactor(LIGTH_DIST);\n-            sampledBlue = snapshot.getPixelReader().getColor(0, 0).getBlue();\n-            assertEquals(FAIL_MESSAGE, lambertCenter * attn, sampledBlue, DELTA);\n-\n-            attn = calculateAttenuationFactor(diagDist);\n-            sampledBlue = snapshot.getPixelReader().getColor(ATTN_SAMPLE_DIST, 0).getBlue();\n-            assertEquals(FAIL_MESSAGE, lambertSample * attn, sampledBlue, DELTA);\n-        });\n+    protected WritableImage snapshot() {\n+        return BOX.getScene().snapshot(null);\n@@ -186,44 +90,1 @@\n-    @Test\n-    public void testRange() {\n-        Util.runAndWait(() -> {\n-            \/\/ eliminating the spotlight factor contribution\n-            LIGHT.setFalloff(0);\n-            LIGHT.setOuterAngle(180);\n-\n-            double diagDist = Math.sqrt(LIGTH_DIST * LIGTH_DIST + ATTN_SAMPLE_DIST * ATTN_SAMPLE_DIST);\n-            LIGHT.setMaxRange((LIGTH_DIST + diagDist) \/ 2);\n-            var snapshot = BOX.getScene().snapshot(null);\n-\n-            double sampledBlue = snapshot.getPixelReader().getColor(0, 0).getBlue();\n-            assertEquals(FAIL_MESSAGE + \", should be in range\", 1, sampledBlue, DELTA);\n-\n-            sampledBlue = snapshot.getPixelReader().getColor(ATTN_SAMPLE_DIST, 0).getBlue();\n-            assertEquals(FAIL_MESSAGE + \", should be out of range\", 0, sampledBlue, DELTA);\n-        });\n-    }\n-\n-    @Test\n-    public void testSpotlightAttenuation() {\n-        Util.runAndWait(() -> {\n-            LIGHT.setInnerAngle(INNER_ANGLE);\n-            LIGHT.setOuterAngle(OUTER_ANGLE);\n-            var snapshot = BOX.getScene().snapshot(null);\n-\n-            int innerX = angleToHorizontalDistance(INSIDE_ANGLE_SAMPLE);\n-            double spotFactor = 1;\n-            double sampledBlue = snapshot.getPixelReader().getColor(innerX, 0).getBlue();\n-            assertEquals(FAIL_MESSAGE, calculateLambertTerm(innerX) * spotFactor, sampledBlue, DELTA);\n-\n-            int middleX = angleToHorizontalDistance(MIDDLE_ANGLE_SAMPLE);\n-            spotFactor = calculateSpotlightFactor(MIDDLE_ANGLE_SAMPLE);\n-            sampledBlue = snapshot.getPixelReader().getColor(middleX, 0).getBlue();\n-            assertEquals(FAIL_MESSAGE, calculateLambertTerm(middleX) * spotFactor, sampledBlue, DELTA);\n-\n-            int outerX = angleToHorizontalDistance(OUTSIDE_ANGLE_SAMPLE);\n-            spotFactor = 0;\n-            sampledBlue = snapshot.getPixelReader().getColor(outerX, 0).getBlue();\n-            assertEquals(FAIL_MESSAGE, calculateLambertTerm(outerX) * spotFactor, sampledBlue, DELTA);\n-        });\n-    }\n-\n-    private static double calculateLambertTerm(double x) {\n+    protected double calculateLambertTerm(double x) {\n@@ -233,21 +94,0 @@\n-    private static double calculateAttenuationFactor(double dist) {\n-        return 1 \/ (LIGHT.getConstantAttenuation() + LIGHT.getLinearAttenuation() * dist\n-                      + LIGHT.getQuadraticAttenuation() * dist * dist);\n-    }\n-\n-    \/\/ I = pow((cosAngle - cosOuter) \/ (cosInner - cosOuter), falloff)\n-    private static double calculateSpotlightFactor(double degrees) {\n-        double numerator = degCos(degrees) - degCos(LIGHT.getOuterAngle());\n-        double denom = degCos(LIGHT.getInnerAngle()) - degCos(LIGHT.getOuterAngle());\n-        return Math.pow(numerator \/ denom, LIGHT.getFalloff());\n-    }\n-\n-    private static double degCos(double degrees) {\n-        return Math.cos(Math.toRadians(degrees));\n-    }\n-\n-    private static int angleToHorizontalDistance(double degrees) {\n-        return (int) (LIGTH_DIST * Math.tan(Math.toRadians(degrees)));\n-    }\n-\n-\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/lighting3D\/LightingTest.java","additions":12,"deletions":172,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.lighting3D;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assume.assumeTrue;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import javafx.application.Application;\n+import javafx.application.ConditionalFeature;\n+import javafx.application.Platform;\n+import javafx.scene.PointLight;\n+import javafx.scene.paint.Color;\n+import test.util.Util;\n+\n+public class PointLightAttenuationTest extends LightingTest {\n+\n+    \/\/ X coordinates for the point used in Lambert tests\n+    private static final int[] LAMBERT_SAMPLE_DISTS = new int[] {0, 30, 60};\n+\n+    \/\/ X coordinate for the point used in attenuation tests\n+    private static final int ATTN_SAMPLE_DIST = LIGTH_DIST;\n+\n+    private static final PointLight LIGHT = new PointLight(Color.BLUE);\n+\n+    public static void main(String[] args) throws Exception {\n+        initFX();\n+    }\n+\n+    @BeforeClass\n+    public static void initFX() throws Exception {\n+        startupLatch = new CountDownLatch(1);\n+        LightingTest.light = LIGHT;\n+        new Thread(() -> Application.launch(TestApp.class, (String[]) null)).start();\n+        assertTrue(\"Timeout waiting for FX runtime to start\", startupLatch.await(5, TimeUnit.SECONDS));\n+    }\n+\n+    @Before\n+    public void setupEach() {\n+        assumeTrue(Platform.isSupported(ConditionalFeature.SCENE3D));\n+        LIGHT.setLinearAttenuation(0);\n+        LIGHT.setQuadraticAttenuation(0);\n+        LIGHT.setMaxRange(Double.POSITIVE_INFINITY);\n+    }\n+\n+    \/\/ The Lambert term is dot(N,L) = cos(a)\n+    @Test\n+    public void testLambert() {\n+        Util.runAndWait(() -> {\n+            var snapshot = snapshot();\n+            for (int x : LAMBERT_SAMPLE_DISTS) {\n+                double sampledBlue = snapshot.getPixelReader().getColor(x, 0).getBlue();\n+                assertEquals(FAIL_MESSAGE + \" for \" + x, calculateLambertTerm(x), sampledBlue, DELTA);\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void testAttenuation() {\n+        Util.runAndWait(() -> {\n+            double diagDist = Math.sqrt(LIGTH_DIST * LIGTH_DIST + ATTN_SAMPLE_DIST * ATTN_SAMPLE_DIST);\n+            double lambertCenter = calculateLambertTerm(0);\n+            double lambertSample = calculateLambertTerm(ATTN_SAMPLE_DIST);\n+\n+            LIGHT.setLinearAttenuation(0.01);\n+            var snapshot = snapshot();\n+\n+            double attn = calculateAttenuationFactor(LIGTH_DIST);\n+            double sampledBlue = snapshot.getPixelReader().getColor(0, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE, lambertCenter * attn, sampledBlue, DELTA);\n+\n+            attn = calculateAttenuationFactor(diagDist);\n+            sampledBlue = snapshot.getPixelReader().getColor(ATTN_SAMPLE_DIST, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE, lambertSample * attn, sampledBlue, DELTA);\n+\n+\n+            LIGHT.setLinearAttenuation(0);\n+            LIGHT.setQuadraticAttenuation(0.01);\n+            snapshot = snapshot();\n+\n+            attn = calculateAttenuationFactor(LIGTH_DIST);\n+            sampledBlue = snapshot.getPixelReader().getColor(0, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE, lambertCenter * attn, sampledBlue, DELTA);\n+\n+            attn = calculateAttenuationFactor(diagDist);\n+            sampledBlue = snapshot.getPixelReader().getColor(ATTN_SAMPLE_DIST, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE, lambertSample * attn, sampledBlue, DELTA);\n+        });\n+    }\n+\n+    @Test\n+    public void testRange() {\n+        Util.runAndWait(() -> {\n+            double diagDist = Math.sqrt(LIGTH_DIST * LIGTH_DIST + ATTN_SAMPLE_DIST * ATTN_SAMPLE_DIST);\n+            LIGHT.setMaxRange((LIGTH_DIST + diagDist) \/ 2);\n+            var snapshot = snapshot();\n+\n+            double sampledBlue = snapshot.getPixelReader().getColor(0, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE + \", should be in range\", 1, sampledBlue, DELTA);\n+\n+            sampledBlue = snapshot.getPixelReader().getColor(ATTN_SAMPLE_DIST, 0).getBlue();\n+            assertEquals(FAIL_MESSAGE + \", should be out of range\", 0, sampledBlue, DELTA);\n+        });\n+    }\n+\n+    private double calculateAttenuationFactor(double dist) {\n+        return 1 \/ (LIGHT.getConstantAttenuation() + LIGHT.getLinearAttenuation() * dist\n+                      + LIGHT.getQuadraticAttenuation() * dist * dist);\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/lighting3D\/PointLightAttenuationTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.lighting3D;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assume.assumeTrue;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import javafx.application.Application;\n+import javafx.application.ConditionalFeature;\n+import javafx.application.Platform;\n+import javafx.scene.SpotLight;\n+import javafx.scene.paint.Color;\n+import test.util.Util;\n+\n+public class SpotLightAttenuationTest extends LightingTest {\n+\n+    \/\/ Angles for points used in spotlight factor tests\n+    private static final double INNER_ANGLE = 20;\n+    private static final double OUTER_ANGLE = 40;\n+    private static final int INSIDE_ANGLE_SAMPLE = 18;\n+    private static final int MIDDLE_ANGLE_SAMPLE = 30;\n+    private static final int OUTSIDE_ANGLE_SAMPLE = 42;\n+\n+    private static final double[] FALLOFF_FACTORS = new double[] {0.5, 1, 1};\n+\n+    private static final SpotLight LIGHT = new SpotLight(Color.BLUE);\n+\n+    public static void main(String[] args) throws Exception {\n+        initFX();\n+    }\n+\n+    @BeforeClass\n+    public static void initFX() throws Exception {\n+        startupLatch = new CountDownLatch(1);\n+        LightingTest.light = LIGHT;\n+        new Thread(() -> Application.launch(TestApp.class, (String[]) null)).start();\n+        assertTrue(\"Timeout waiting for FX runtime to start\", startupLatch.await(5, TimeUnit.SECONDS));\n+    }\n+\n+    @Before\n+    public void setupEach() {\n+        assumeTrue(Platform.isSupported(ConditionalFeature.SCENE3D));\n+    }\n+\n+    @Test\n+    public void testSpotlightAttenuation() {\n+        Util.runAndWait(() -> {\n+            LIGHT.setInnerAngle(INNER_ANGLE);\n+            LIGHT.setOuterAngle(OUTER_ANGLE);\n+            for (double falloff : FALLOFF_FACTORS) {\n+                LIGHT.setFalloff(falloff);\n+                var snapshot = snapshot();\n+\n+                int innerX = angleToDist(INSIDE_ANGLE_SAMPLE);\n+                double spotFactor = 1;\n+                double sampledBlue = snapshot.getPixelReader().getColor(innerX, 0).getBlue();\n+                assertEquals(FAIL_MESSAGE, calculateLambertTerm(innerX) * spotFactor, sampledBlue, DELTA);\n+\n+                int middleX = angleToDist(MIDDLE_ANGLE_SAMPLE);\n+                spotFactor = calculateSpotlightFactor(MIDDLE_ANGLE_SAMPLE);\n+                sampledBlue = snapshot.getPixelReader().getColor(middleX, 0).getBlue();\n+                assertEquals(FAIL_MESSAGE, calculateLambertTerm(middleX) * spotFactor, sampledBlue, DELTA);\n+\n+                int outerX = angleToDist(OUTSIDE_ANGLE_SAMPLE);\n+                spotFactor = 0;\n+                sampledBlue = snapshot.getPixelReader().getColor(outerX, 0).getBlue();\n+                assertEquals(FAIL_MESSAGE, calculateLambertTerm(outerX) * spotFactor, sampledBlue, DELTA);\n+            }\n+        });\n+    }\n+\n+    \/\/ I = pow((cosAngle - cosOuter) \/ (cosInner - cosOuter), falloff)\n+    private double calculateSpotlightFactor(double degrees) {\n+        double numerator = degCos(degrees) - degCos(LIGHT.getOuterAngle());\n+        double denom = degCos(LIGHT.getInnerAngle()) - degCos(LIGHT.getOuterAngle());\n+        return Math.pow(numerator \/ denom, LIGHT.getFalloff());\n+    }\n+\n+    private double degCos(double degrees) {\n+        return Math.cos(Math.toRadians(degrees));\n+    }\n+\n+    private int angleToDist(double degrees) {\n+        return (int) (LIGTH_DIST * Math.tan(Math.toRadians(degrees)));\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/lighting3D\/SpotLightAttenuationTest.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"}]}