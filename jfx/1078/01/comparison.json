{"files":[{"patch":"@@ -37,1 +37,1 @@\n- * change event notification.\n+ * change event notification.<p>\n@@ -40,1 +40,1 @@\n- * observers are being notified, but it is not thread-safe.\n+ * observers are being notified, but it is not thread-safe.<p>\n@@ -42,0 +42,5 @@\n+ * This class keeps track of the latest value it has seen to determine if change\n+ * listeners should be called when next {@link #fireValueChangedEvent()} is called.\n+ * So while this value is usually the current value of the involved observable,\n+ * it becomes the \"old\" value as soon as the observable is changed, until such time\n+ * it is updated again (by calling {@link #fireValueChangedEvent()}).<p>\n@@ -43,0 +48,6 @@\n+ * During this brief period, listeners may be added or removed causing the ExpressionHelper\n+ * to perhaps switch to a different variant of itself. These different variants must be\n+ * made aware of the currently stored latest value, as obtaining this value from the\n+ * {@link ObservableValue} would (during that brief period) be a different value. Using\n+ * the incorrect latest value would result in change listeners not being fired as they\n+ * perform an equality check.\n@@ -68,1 +79,1 @@\n-        return (helper == null)? new SingleChange<>(observable, listener) : helper.addListener(listener);\n+        return (helper == null)? new SingleChange<>(observable, observable.getValue(), listener) : helper.addListener(listener);\n@@ -125,1 +136,1 @@\n-            return new Generic<>(observable, this.listener, listener);\n+            return new Generic<>(observable, observable.getValue(), this.listener, listener);\n@@ -148,1 +159,1 @@\n-        private SingleChange(ObservableValue<T> observable, ChangeListener<? super T> listener) {\n+        private SingleChange(ObservableValue<T> observable, T currentValue, ChangeListener<? super T> listener) {\n@@ -151,1 +162,1 @@\n-            this.currentValue = observable.getValue();\n+            this.currentValue = currentValue;\n@@ -156,1 +167,1 @@\n-            return new Generic<>(observable, listener, this.listener);\n+            return new Generic<>(observable, currentValue, listener, this.listener);\n@@ -166,1 +177,1 @@\n-            return new Generic<>(observable, this.listener, listener);\n+            return new Generic<>(observable, currentValue, this.listener, listener);\n@@ -204,1 +215,1 @@\n-        private Generic(ObservableValue<T> observable, ChangeListener<? super T> listener0, ChangeListener<? super T> listener1) {\n+        private Generic(ObservableValue<T> observable, T currentValue, ChangeListener<? super T> listener0, ChangeListener<? super T> listener1) {\n@@ -208,1 +219,1 @@\n-            this.currentValue = observable.getValue();\n+            this.currentValue = currentValue;\n@@ -211,1 +222,1 @@\n-        private Generic(ObservableValue<T> observable, InvalidationListener invalidationListener, ChangeListener<? super T> changeListener) {\n+        private Generic(ObservableValue<T> observable, T currentValue, InvalidationListener invalidationListener, ChangeListener<? super T> changeListener) {\n@@ -217,1 +228,1 @@\n-            this.currentValue = observable.getValue();\n+            this.currentValue = currentValue;\n@@ -249,1 +260,1 @@\n-                                return new SingleChange<>(observable, changeListeners[0]);\n+                                return new SingleChange<>(observable, currentValue, changeListeners[0]);\n@@ -313,0 +324,1 @@\n+                            currentValue = null;  \/\/ clear current value to avoid stale reference\n@@ -314,1 +326,1 @@\n-                            return new SingleChange<>(observable, changeListeners[1-index]);\n+                            return new SingleChange<>(observable, currentValue, changeListeners[1-index]);\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ExpressionHelper.java","additions":26,"deletions":14,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -28,0 +28,13 @@\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.util.BitSet;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n@@ -30,0 +43,1 @@\n+\n@@ -31,1 +45,0 @@\n-import test.javafx.beans.InvalidationListenerMock;\n@@ -33,1 +46,4 @@\n-import test.javafx.beans.WeakInvalidationListenerMock;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.beans.property.StringProperty;\n@@ -35,1 +51,0 @@\n-import test.javafx.beans.value.ChangeListenerMock;\n@@ -38,0 +53,3 @@\n+import test.javafx.beans.InvalidationListenerMock;\n+import test.javafx.beans.WeakInvalidationListenerMock;\n+import test.javafx.beans.value.ChangeListenerMock;\n@@ -39,9 +57,1 @@\n-import org.junit.Before;\n-import org.junit.Test;\n-\n-import java.util.BitSet;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n+import test.util.memory.JMemoryBuddy;\n@@ -648,0 +658,69 @@\n+    @Test\n+    public void shouldNotForgetCurrentValueWhenMovingFromSingleChangeToGenericImplementation() {\n+        AtomicBoolean invalidated = new AtomicBoolean();\n+        AtomicReference<String> currentValue = new AtomicReference<>();\n+        StringProperty p = new SimpleStringProperty(\"a\") {\n+            @Override\n+            protected void invalidated() {\n+                addListener(obs -> invalidated.set(true));\n+            }\n+        };\n+\n+        p.addListener((obs, old, current) -> currentValue.set(current));\n+\n+        p.set(\"b\");\n+\n+        assertTrue(invalidated.get());  \/\/ true because the invalidation listener was added before called\n+        assertEquals(\"b\", currentValue.get());\n+    }\n+\n+    @Test\n+    public void shouldNotForgetCurrentValueWhenMovingFromGenericToSingleChangeImplementation() {\n+        AtomicBoolean invalidated = new AtomicBoolean();\n+        AtomicReference<String> currentValue = new AtomicReference<>();\n+        InvalidationListener invalidationListener = obs -> invalidated.set(true);\n+        StringProperty p = new SimpleStringProperty(\"a\") {\n+            @Override\n+            protected void invalidated() {\n+                removeListener(invalidationListener);\n+            }\n+        };\n+\n+        p.addListener(invalidationListener);\n+        p.addListener((obs, old, current) -> currentValue.set(current));\n+\n+        p.set(\"b\");\n+\n+        assertFalse(invalidated.get());  \/\/ false because the invalidation listener was removed before called\n+        assertEquals(\"b\", currentValue.get());\n+    }\n+\n+    @Test\n+    public void shouldNotReferToAnOldValueWhenAllChangeListenersRemoved() {\n+        AtomicInteger invalidations = new AtomicInteger();\n+        ObjectProperty<List<String>> p = new SimpleObjectProperty<>(List.of(\"a\"));\n+\n+        \/\/ add two invalidation listeners so Generic implementation is used:\n+        p.addListener(obs -> invalidations.addAndGet(1));\n+        p.addListener(obs -> invalidations.addAndGet(1));\n+\n+        \/\/ add a change listener:\n+        ChangeListener<? super List<String>> listener = (obs, old, current) -> {};\n+\n+        p.addListener(listener);\n+\n+        JMemoryBuddy.memoryTest(api -> {\n+            \/\/ trigger a change to a value that should be collectable:\n+            List<String> collectable = List.of(\"b\");\n+\n+            p.set(collectable);\n+\n+            \/\/ remove the last change listener:\n+            p.removeListener(listener);\n+\n+            \/\/ change value to something else, it should not be referenced anymore anywhere:\n+            p.set(List.of(\"c\"));\n+\n+            api.assertCollectable(collectable);\n+        });\n+    }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ExpressionHelperTest.java","additions":91,"deletions":12,"binary":false,"changes":103,"status":"modified"}]}