{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.util.function.Consumer;\n@@ -75,0 +76,1 @@\n+     * @param latestValueTracker a {@link Consumer} for the latest value, can be {@code null}\n@@ -78,1 +80,1 @@\n-    public <T> boolean notifyListeners(ObservableValue<? extends T> observableValue, T oldValue) {\n+    public <T> boolean notifyListeners(ObservableValue<? extends T> observableValue, T oldValue, Consumer<T> latestValueTracker) {\n@@ -119,0 +121,4 @@\n+                if (latestValueTracker != null) {\n+                    latestValueTracker.accept(newValue);\n+                }\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ListenerList.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-        boolean modified = list.notifyListeners(instance, oldValue);\n+        boolean modified = list.notifyListeners(instance, oldValue, null);\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ListenerManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.util.Objects;\n+import java.util.function.Consumer;\n@@ -30,2 +30,0 @@\n-import javafx.beans.InvalidationListener;\n-import javafx.beans.value.ChangeListener;\n@@ -35,1 +33,1 @@\n- * Extension of {@link ListenerListBase} which given an {@link ObservableValue}\n+ * Extension of {@link ListenerList} which given an {@link ObservableValue}\n@@ -45,2 +43,2 @@\n-public class OldValueCachingListenerList<T> extends ListenerListBase {\n-    private T latestValue;\n+public class OldValueCachingListenerList<T> extends ListenerList {\n+    private final Consumer<T> latestValueTracker = this::putLatestValue;\n@@ -48,16 +46,1 @@\n-    \/**\n-     * This field is only used during notifications, and only relevant\n-     * when nested notifications occur. It is used for communicating\n-     * information between the different nesting levels. To deeper\n-     * nesting levels it contains the number of listeners that have\n-     * been notified in higher level loops, while deeper nesting levels\n-     * communicate to higher level loops whether a nested notification\n-     * actually occurred.<p>\n-     *\n-     * When its value is zero or positive, it indicates the number of\n-     * listeners notified in a higher level loop (minus one), while\n-     * when its negative (-1) it indicates to a higher level loop that\n-     * a nested notification occurred, requiring, for example, a refresh\n-     * of the current value and a new equals check.\n-     *\/\n-    private int progress;\n+    private T latestValue;\n@@ -102,60 +85,1 @@\n-        boolean wasLocked = isLocked();\n-\n-        if (!wasLocked) {\n-            lock();\n-        }\n-\n-        T oldValue = getLatestValue();  \/\/ save this value here already as even invalidation listeners can influence it\n-        int initialProgress = progress;  \/\/ save as it will be modified soon\n-        int invalidationListenersSize = invalidationListenersSize();\n-        int maxInvalidations = wasLocked ? Math.min(initialProgress + 1, invalidationListenersSize) : invalidationListenersSize;\n-\n-        for (int i = 0; i < maxInvalidations; i++) {\n-            InvalidationListener listener = getInvalidationListener(i);\n-\n-            if (listener == null) {\n-                continue;\n-            }\n-\n-            \/\/ communicate to a lower level loop (if triggered) how many listeners were notified so far:\n-            progress = i;\n-\n-            \/\/ call invalidation listener (and perhaps a nested notification):\n-            callInvalidationListener(observableValue, listener);\n-        }\n-\n-        int changeListenersSize = changeListenersSize();\n-        int maxChanges = wasLocked ? Math.min(initialProgress + 1 - invalidationListenersSize, changeListenersSize) : changeListenersSize;\n-\n-        T newValue = null;\n-\n-        for (int i = 0; i < maxChanges; i++) {\n-            ChangeListener<T> listener = getChangeListener(i);\n-\n-            if (listener == null) {\n-                continue;\n-            }\n-\n-            \/\/ only get the latest value if this is the first loop or a nested notification occurred:\n-            if (progress < 0 || i == 0) {\n-                newValue = observableValue.getValue();\n-\n-                \/\/ Latest value should even be stored if it was \"equals\", as it may be a different reference\n-                putLatestValue(newValue);\n-\n-                if (Objects.equals(newValue, oldValue)) {\n-                    break;\n-                }\n-            }\n-\n-            \/\/ communicate to a lower level loop (if triggered) how many listeners were notified so far:\n-            progress = i + invalidationListenersSize;\n-\n-            \/\/ call change listener (and perhaps a nested notification):\n-            callChangeListener(observableValue, listener, oldValue, newValue);\n-        }\n-\n-        \/\/ communicate to a higher level loop that a nested notification occurred:\n-        progress = -1;\n-\n-        return wasLocked ? false : unlock();\n+        return notifyListeners(observableValue, getLatestValue(), latestValueTracker);\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/OldValueCachingListenerList.java","additions":6,"deletions":82,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        list.notifyListeners(property, oldValue);\n+        list.notifyListeners(property, oldValue, null);\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ListenerListTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}