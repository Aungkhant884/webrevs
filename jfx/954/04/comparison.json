{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.security.InvalidParameterException;\n@@ -40,0 +41,2 @@\n+\n+import org.junit.AfterClass;\n@@ -41,0 +44,1 @@\n+import org.junit.BeforeClass;\n@@ -51,2 +55,3 @@\n-    private static final DateTimeFormatter aFormatter = DateTimeFormatter.ofPattern(\"dd MM yyyy\");\n-    private static final DateTimeFormatter aParser = DateTimeFormatter.ofPattern(\"yyyy MM dd\");\n+    private static Locale oldLocale = null;\n+    private static DateTimeFormatter aFormatter = null;\n+    private static DateTimeFormatter aParser = null;\n@@ -54,0 +59,10 @@\n+    \/\/ We can only create LocalDateStringConverter object after Locale is set.\n+    \/\/ Unfortunately, due to unpredictability of @Parameterized.Parameters methods\n+    \/\/ in JUnit, we have to allocate it after @BeforeClass sets up Locale and\n+    \/\/ necessary static fields. Otherwise, the test may collide with other\n+    \/\/ Local*StringConverter tests and cause unpredictable results.\n+    private enum LocalDateStringConverterVariant {\n+        NO_PARAM,\n+        WITH_FORMATTER_PARSER,\n+        WITH_FORMAT_STYLES,\n+    };\n@@ -57,3 +72,2 @@\n-            { new LocalDateStringConverter(),\n-              Locale.getDefault(Locale.Category.FORMAT), FormatStyle.SHORT,\n-              VALID_DATE, null, null },\n+            { LocalDateStringConverterVariant.NO_PARAM,\n+              FormatStyle.SHORT, VALID_DATE },\n@@ -61,3 +75,2 @@\n-            { new LocalDateStringConverter(aFormatter, aParser),\n-              Locale.getDefault(Locale.Category.FORMAT), null,\n-              VALID_DATE, aFormatter, aParser },\n+            { LocalDateStringConverterVariant.WITH_FORMATTER_PARSER,\n+              null, VALID_DATE },\n@@ -65,3 +78,2 @@\n-            { new LocalDateStringConverter(FormatStyle.SHORT, Locale.UK, IsoChronology.INSTANCE),\n-              Locale.UK, FormatStyle.SHORT,\n-              VALID_DATE, null, null },\n+            { LocalDateStringConverterVariant.WITH_FORMAT_STYLES,\n+              FormatStyle.SHORT, VALID_DATE },\n@@ -71,0 +83,4 @@\n+    private LocalDateStringConverterVariant converterVariant;\n+    private FormatStyle dateStyle;\n+    private LocalDate validDate;\n+\n@@ -73,1 +89,0 @@\n-    private FormatStyle dateStyle;\n@@ -75,1 +90,0 @@\n-    private LocalDate validDate;\n@@ -77,3 +91,2 @@\n-    public LocalDateStringConverterTest(LocalDateStringConverter converter, Locale locale, FormatStyle dateStyle, LocalDate validDate, DateTimeFormatter formatter, DateTimeFormatter parser) {\n-        this.converter = converter;\n-        this.locale = locale;\n+    public LocalDateStringConverterTest(LocalDateStringConverterVariant converterVariant, FormatStyle dateStyle, LocalDate validDate) {\n+        this.converterVariant = converterVariant;\n@@ -82,2 +95,23 @@\n-        this.formatter = formatter;\n-        this.parser = parser;\n+\n+        \/\/ initialized after Locale is established\n+        this.converter = null;\n+        this.locale = null;\n+        this.formatter = null;\n+        this.parser = null;\n+    }\n+\n+    @BeforeClass\n+    public static void setupBeforeAll() {\n+        \/\/ Tests require that default locale is en_US\n+        oldLocale = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n+\n+        \/\/ DateTimeFormatter uses default locale, so we can init this after updating locale\n+        aFormatter = DateTimeFormatter.ofPattern(\"dd MM yyyy\");\n+        aParser = DateTimeFormatter.ofPattern(\"yyyy MM dd\");\n+    }\n+\n+    @AfterClass\n+    public static void teardownAfterAll() {\n+        \/\/ Restore VM's old locale\n+        Locale.setDefault(oldLocale);\n@@ -86,1 +120,25 @@\n-    @Before public void setup() {\n+    @Before\n+    public void setup() {\n+        \/\/ Locale is established now, so we can allocate objects depending on it\n+        switch (this.converterVariant) {\n+        case NO_PARAM:\n+            this.converter = new LocalDateStringConverter();\n+            this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+            this.formatter = null;\n+            this.parser = null;\n+            break;\n+        case WITH_FORMATTER_PARSER:\n+            this.converter = new LocalDateStringConverter(aFormatter, aParser);\n+            this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+            this.formatter = aFormatter;\n+            this.parser = aParser;\n+            break;\n+        case WITH_FORMAT_STYLES:\n+            this.converter = new LocalDateStringConverter(FormatStyle.SHORT, Locale.UK, IsoChronology.INSTANCE);\n+            this.locale = Locale.UK;\n+            this.formatter = null;\n+            this.parser = null;\n+            break;\n+        default:\n+            fail(\"Invalid converter variant: \" + this.converterVariant.toString());\n+        }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/LocalDateStringConverterTest.java","additions":77,"deletions":19,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.security.InvalidParameterException;\n@@ -43,0 +44,3 @@\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n@@ -56,2 +60,14 @@\n-    private static final DateTimeFormatter aFormatter = DateTimeFormatter.ofPattern(\"dd MM yyyy HH mm ss\");\n-    private static final DateTimeFormatter aParser = DateTimeFormatter.ofPattern(\"yyyy MM dd hh mm ss a\");\n+    private static DateTimeFormatter aFormatter;\n+    private static DateTimeFormatter aParser;\n+    private static Locale oldLocale;\n+\n+    \/\/ We can only create LocalDateTimeStringConverter object after Locale is set.\n+    \/\/ Unfortunately, due to unpredictability of @Parameterized.Parameters methods\n+    \/\/ in JUnit, we have to allocate it after @BeforeClass sets up Locale and\n+    \/\/ necessary static fields. Otherwise, the test may collide with other\n+    \/\/ Local*StringConverter tests and cause unpredictable results.\n+    private enum LocalDateTimeStringConverterVariant {\n+        NO_PARAM,\n+        WITH_FORMATTER_PARSER,\n+        WITH_FORMAT_STYLES,\n+    };\n@@ -60,3 +76,0 @@\n-        \/\/ Tests require that default locale is en_US\n-        Locale.setDefault(Locale.US);\n-\n@@ -64,3 +77,2 @@\n-            { new LocalDateTimeStringConverter(),\n-              Locale.getDefault(Locale.Category.FORMAT), FormatStyle.SHORT, FormatStyle.SHORT,\n-              VALID_LDT_WITHOUT_SECONDS, null, null },\n+            { LocalDateTimeStringConverterVariant.NO_PARAM,\n+              FormatStyle.SHORT, FormatStyle.SHORT, VALID_LDT_WITHOUT_SECONDS},\n@@ -68,3 +80,2 @@\n-            { new LocalDateTimeStringConverter(aFormatter, aParser),\n-              Locale.getDefault(Locale.Category.FORMAT), null, null,\n-              VALID_LDT_WITH_SECONDS, aFormatter, aParser },\n+            { LocalDateTimeStringConverterVariant.WITH_FORMATTER_PARSER,\n+              null, null, VALID_LDT_WITH_SECONDS},\n@@ -72,3 +83,2 @@\n-            { new LocalDateTimeStringConverter(FormatStyle.SHORT, FormatStyle.SHORT, Locale.UK, IsoChronology.INSTANCE),\n-              Locale.UK, FormatStyle.SHORT, FormatStyle.SHORT,\n-              VALID_LDT_WITHOUT_SECONDS, null, null },\n+            { LocalDateTimeStringConverterVariant.WITH_FORMAT_STYLES,\n+              FormatStyle.SHORT, FormatStyle.SHORT, VALID_LDT_WITHOUT_SECONDS},\n@@ -78,2 +88,1 @@\n-    private LocalDateTimeStringConverter converter;\n-    private Locale locale;\n+    private LocalDateTimeStringConverterVariant converterVariant;\n@@ -82,0 +91,4 @@\n+    private LocalDateTime validDateTime;\n+\n+    private LocalDateTimeStringConverter converter;\n+    private Locale locale;\n@@ -84,1 +97,0 @@\n-    private LocalDateTime validDateTime;\n@@ -86,3 +98,2 @@\n-    public LocalDateTimeStringConverterTest(LocalDateTimeStringConverter converter, Locale locale, FormatStyle dateStyle, FormatStyle timeStyle, LocalDateTime validDateTime, DateTimeFormatter formatter, DateTimeFormatter parser) {\n-        this.converter = converter;\n-        this.locale = locale;\n+    public LocalDateTimeStringConverterTest(LocalDateTimeStringConverterVariant converterVariant, FormatStyle dateStyle, FormatStyle timeStyle, LocalDateTime validDateTime) {\n+        this.converterVariant = converterVariant;\n@@ -92,2 +103,49 @@\n-        this.formatter = formatter;\n-        this.parser = parser;\n+\n+        this.converter = null;\n+        this.locale = null;\n+        this.formatter = null;\n+        this.parser = null;\n+    }\n+\n+    @BeforeClass\n+    public static void setupBeforeAll() {\n+        \/\/ Tests require that default locale is en_US\n+        oldLocale = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n+\n+        \/\/ DateTimeFormatter uses default locale, so we can init this after updating locale\n+        aFormatter = DateTimeFormatter.ofPattern(\"dd MM yyyy HH mm ss\");\n+        aParser = DateTimeFormatter.ofPattern(\"yyyy MM dd hh mm ss a\");\n+    }\n+\n+    @AfterClass\n+    public static void teardownAfterAll() {\n+        \/\/ Restore VM's old locale\n+        Locale.setDefault(oldLocale);\n+    }\n+\n+    @Before\n+    public void setup() {\n+        \/\/ Locale is established now, so we can allocate objects depending on it\n+        switch (this.converterVariant) {\n+        case NO_PARAM:\n+            this.converter = new LocalDateTimeStringConverter();\n+            this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+            this.formatter = null;\n+            this.parser = null;\n+            break;\n+        case WITH_FORMATTER_PARSER:\n+            this.converter = new LocalDateTimeStringConverter(aFormatter, aParser);\n+            this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+            this.formatter = aFormatter;\n+            this.parser = aParser;\n+            break;\n+        case WITH_FORMAT_STYLES:\n+            this.converter = new LocalDateTimeStringConverter(FormatStyle.SHORT, FormatStyle.SHORT, Locale.UK, IsoChronology.INSTANCE);\n+            this.locale = Locale.UK;\n+            this.formatter = null;\n+            this.parser = null;\n+            break;\n+        default:\n+            fail(\"Invalid converter variant: \" + this.converterVariant.toString());\n+        }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/LocalDateTimeStringConverterTest.java","additions":80,"deletions":22,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.security.InvalidParameterException;\n@@ -39,0 +40,1 @@\n+import org.junit.AfterClass;\n@@ -40,0 +42,1 @@\n+import org.junit.BeforeClass;\n@@ -56,3 +59,14 @@\n-    private static final DateTimeFormatter aFormatter = DateTimeFormatter.ofPattern(\"HH mm ss\");\n-    private static final DateTimeFormatter aParser = DateTimeFormatter.ofPattern(\"hh mm ss a\");\n-\n+    private static Locale oldLocale = null;\n+    private static DateTimeFormatter aFormatter = null;\n+    private static DateTimeFormatter aParser = null;\n+\n+    \/\/ We can only create LocalTimeStringConverter object after Locale is set.\n+    \/\/ Unfortunately, due to unpredictability of @Parameterized.Parameters methods\n+    \/\/ in JUnit, we have to allocate it after @BeforeClass sets up Locale and\n+    \/\/ necessary static fields. Otherwise, the test may collide with other\n+    \/\/ Local*StringConverter tests and cause unpredictable results.\n+    private enum LocalTimeStringConverterVariant {\n+        NO_PARAM,\n+        WITH_FORMATTER_PARSER,\n+        WITH_FORMAT_STYLES,\n+    };\n@@ -62,3 +76,2 @@\n-            { new LocalTimeStringConverter(),\n-              Locale.getDefault(Locale.Category.FORMAT), FormatStyle.SHORT,\n-              VALID_TIME_WITHOUT_SECONDS, null, null },\n+            { LocalTimeStringConverterVariant.NO_PARAM,\n+              FormatStyle.SHORT, VALID_TIME_WITHOUT_SECONDS },\n@@ -66,3 +79,2 @@\n-            { new LocalTimeStringConverter(aFormatter, aParser),\n-              Locale.getDefault(Locale.Category.FORMAT), null,\n-              VALID_TIME_WITH_SECONDS, aFormatter, aParser },\n+            { LocalTimeStringConverterVariant.WITH_FORMATTER_PARSER,\n+              null, VALID_TIME_WITH_SECONDS },\n@@ -70,3 +82,2 @@\n-            { new LocalTimeStringConverter(FormatStyle.SHORT, Locale.UK),\n-              Locale.UK, FormatStyle.SHORT,\n-              VALID_TIME_WITHOUT_SECONDS, null, null },\n+            { LocalTimeStringConverterVariant.WITH_FORMAT_STYLES,\n+              FormatStyle.SHORT, VALID_TIME_WITHOUT_SECONDS },\n@@ -76,0 +87,4 @@\n+    private LocalTimeStringConverterVariant converterVariant;\n+    private FormatStyle timeStyle;\n+    private LocalTime validTime;\n+\n@@ -78,1 +93,0 @@\n-    private FormatStyle timeStyle;\n@@ -80,1 +94,0 @@\n-    private LocalTime validTime;\n@@ -82,3 +95,2 @@\n-    public LocalTimeStringConverterTest(LocalTimeStringConverter converter, Locale locale, FormatStyle timeStyle, LocalTime validTime, DateTimeFormatter formatter, DateTimeFormatter parser) {\n-        this.converter = converter;\n-        this.locale = locale;\n+    public LocalTimeStringConverterTest(LocalTimeStringConverterVariant converterVariant, FormatStyle timeStyle, LocalTime validTime) {\n+        this.converterVariant = converterVariant;\n@@ -87,2 +99,21 @@\n-        this.formatter = formatter;\n-        this.parser = parser;\n+\n+        this.locale = null;\n+        this.formatter = null;\n+        this.parser = null;\n+    }\n+\n+    @BeforeClass\n+    public static void setupBeforeAll() {\n+        \/\/ Tests require that default locale is en_US\n+        oldLocale = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n+\n+        \/\/ DateTimeFormatter uses default locale, so we can init this after updating locale\n+        aFormatter = DateTimeFormatter.ofPattern(\"HH mm ss\");\n+        aParser = DateTimeFormatter.ofPattern(\"hh mm ss a\");\n+    }\n+\n+    @AfterClass\n+    public static void teardownAfterAll() {\n+        \/\/ Restore VM's old locale\n+        Locale.setDefault(oldLocale);\n@@ -91,1 +122,25 @@\n-    @Before public void setup() {\n+    @Before\n+    public void setup() {\n+        \/\/ Locale is established now, so we can allocate objects depending on it\n+        switch (this.converterVariant) {\n+        case NO_PARAM:\n+            this.converter = new LocalTimeStringConverter();\n+            this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+            this.formatter = null;\n+            this.parser = null;\n+            break;\n+        case WITH_FORMATTER_PARSER:\n+            this.converter = new LocalTimeStringConverter(aFormatter, aParser);\n+            this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+            this.formatter = aFormatter;\n+            this.parser = aParser;\n+            break;\n+        case WITH_FORMAT_STYLES:\n+            this.converter = new LocalTimeStringConverter(FormatStyle.SHORT, Locale.UK);\n+            this.locale = Locale.UK;\n+            this.formatter = null;\n+            this.parser = null;\n+            break;\n+        default:\n+            fail(\"Invalid converter variant: \" + this.converterVariant.toString());\n+        }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/LocalTimeStringConverterTest.java","additions":75,"deletions":20,"binary":false,"changes":95,"status":"modified"}]}