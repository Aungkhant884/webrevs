{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.security.InvalidParameterException;\n@@ -40,0 +41,3 @@\n+\n+import org.junit.After;\n+import org.junit.AfterClass;\n@@ -41,0 +45,1 @@\n+import org.junit.BeforeClass;\n@@ -51,2 +56,3 @@\n-    private static final DateTimeFormatter aFormatter = DateTimeFormatter.ofPattern(\"dd MM yyyy\");\n-    private static final DateTimeFormatter aParser = DateTimeFormatter.ofPattern(\"yyyy MM dd\");\n+    private static Locale oldLocale = null;\n+    private static DateTimeFormatter aFormatter = null;\n+    private static DateTimeFormatter aParser = null;\n@@ -54,0 +60,10 @@\n+    \/\/ We can only create LocalDateStringConverter object after Locale is set.\n+    \/\/ Unfortunately, due to unpredictability of @Parameterized.Parameters methods\n+    \/\/ in JUnit, we have to allocate it after @BeforeClass sets up Locale and\n+    \/\/ necessary static fields. Otherwise, the test may collide with other\n+    \/\/ Local*StringConverter tests and cause unpredictable results.\n+    private enum LocalDateStringConverterVariant {\n+        NO_PARAM,\n+        WITH_FORMATTER_PARSER,\n+        WITH_FORMAT_STYLES,\n+    };\n@@ -57,3 +73,2 @@\n-            { new LocalDateStringConverter(),\n-              Locale.getDefault(Locale.Category.FORMAT), FormatStyle.SHORT,\n-              VALID_DATE, null, null },\n+            { LocalDateStringConverterVariant.NO_PARAM,\n+              FormatStyle.SHORT, VALID_DATE },\n@@ -61,3 +76,2 @@\n-            { new LocalDateStringConverter(aFormatter, aParser),\n-              Locale.getDefault(Locale.Category.FORMAT), null,\n-              VALID_DATE, aFormatter, aParser },\n+            { LocalDateStringConverterVariant.WITH_FORMATTER_PARSER,\n+              null, VALID_DATE },\n@@ -65,3 +79,2 @@\n-            { new LocalDateStringConverter(FormatStyle.SHORT, Locale.UK, IsoChronology.INSTANCE),\n-              Locale.UK, FormatStyle.SHORT,\n-              VALID_DATE, null, null },\n+            { LocalDateStringConverterVariant.WITH_FORMAT_STYLES,\n+              FormatStyle.SHORT, VALID_DATE },\n@@ -71,0 +84,4 @@\n+    private LocalDateStringConverterVariant converterVariant;\n+    private FormatStyle dateStyle;\n+    private LocalDate validDate;\n+    \n@@ -73,1 +90,0 @@\n-    private FormatStyle dateStyle;\n@@ -75,1 +91,0 @@\n-    private LocalDate validDate;\n@@ -77,3 +92,2 @@\n-    public LocalDateStringConverterTest(LocalDateStringConverter converter, Locale locale, FormatStyle dateStyle, LocalDate validDate, DateTimeFormatter formatter, DateTimeFormatter parser) {\n-        this.converter = converter;\n-        this.locale = locale;\n+    public LocalDateStringConverterTest(LocalDateStringConverterVariant converterVariant, FormatStyle dateStyle, LocalDate validDate) {\n+        this.converterVariant = converterVariant;\n@@ -82,2 +96,50 @@\n-        this.formatter = formatter;\n-        this.parser = parser;\n+\n+        \/\/ initialized after Locale is established\n+        this.converter = null;\n+        this.locale = null;\n+        this.formatter = null;\n+        this.parser = null;\n+    }\n+\n+    @BeforeClass\n+    public static void setupBeforeAll() {\n+        \/\/ Tests require that default locale is en_US\n+        oldLocale = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n+\n+        \/\/ DateTimeFormatter uses default locale, so we can init this after updating locale\n+        aFormatter = DateTimeFormatter.ofPattern(\"dd MM yyyy\");\n+        aParser = DateTimeFormatter.ofPattern(\"yyyy MM dd\");\n+    }\n+\n+    @AfterClass\n+    public static void teardownAfterAll() {\n+        \/\/ Restore VM's old locale\n+        Locale.setDefault(oldLocale);\n+    }\n+\n+    @Before\n+    public void setup() {\n+        if (this.converter == null) {\n+            \/\/ Locale is established now, so we can allocate objects depending on it\n+            switch (this.converterVariant) {\n+            case NO_PARAM:\n+                this.converter = new LocalDateStringConverter();\n+                this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+                \/\/ this.formatter and this.parser remain null\n+                break;\n+            case WITH_FORMATTER_PARSER:\n+                this.converter = new LocalDateStringConverter(aFormatter, aParser);\n+                this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+                this.formatter = aFormatter;\n+                this.parser = aParser;\n+                break;\n+            case WITH_FORMAT_STYLES:\n+                this.converter = new LocalDateStringConverter(FormatStyle.SHORT, Locale.UK, IsoChronology.INSTANCE);\n+                this.locale = Locale.UK;\n+                \/\/ this.formatter and this.parser remain null\n+                break;\n+            default:\n+                throw new InvalidParameterException(\"Invalid converter variant: \" + this.converterVariant.toString());\n+            }\n+        }\n@@ -86,1 +148,2 @@\n-    @Before public void setup() {\n+    @After\n+    public void teardown() {\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/LocalDateStringConverterTest.java","additions":82,"deletions":19,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.security.InvalidParameterException;\n@@ -43,0 +44,4 @@\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n@@ -56,2 +61,14 @@\n-    private static final DateTimeFormatter aFormatter = DateTimeFormatter.ofPattern(\"dd MM yyyy HH mm ss\");\n-    private static final DateTimeFormatter aParser = DateTimeFormatter.ofPattern(\"yyyy MM dd hh mm ss a\");\n+    private static DateTimeFormatter aFormatter;\n+    private static DateTimeFormatter aParser;\n+    private static Locale oldLocale;\n+\n+    \/\/ We can only create LocalDateTimeStringConverter object after Locale is set.\n+    \/\/ Unfortunately, due to unpredictability of @Parameterized.Parameters methods\n+    \/\/ in JUnit, we have to allocate it after @BeforeClass sets up Locale and\n+    \/\/ necessary static fields. Otherwise, the test may collide with other\n+    \/\/ Local*StringConverter tests and cause unpredictable results.\n+    private enum LocalDateTimeStringConverterVariant {\n+        NO_PARAM,\n+        WITH_FORMATTER_PARSER,\n+        WITH_FORMAT_STYLES,\n+    };\n@@ -60,3 +77,0 @@\n-        \/\/ Tests require that default locale is en_US\n-        Locale.setDefault(Locale.US);\n-\n@@ -64,3 +78,2 @@\n-            { new LocalDateTimeStringConverter(),\n-              Locale.getDefault(Locale.Category.FORMAT), FormatStyle.SHORT, FormatStyle.SHORT,\n-              VALID_LDT_WITHOUT_SECONDS, null, null },\n+            { LocalDateTimeStringConverterVariant.NO_PARAM,\n+              FormatStyle.SHORT, FormatStyle.SHORT, VALID_LDT_WITHOUT_SECONDS},\n@@ -68,3 +81,2 @@\n-            { new LocalDateTimeStringConverter(aFormatter, aParser),\n-              Locale.getDefault(Locale.Category.FORMAT), null, null,\n-              VALID_LDT_WITH_SECONDS, aFormatter, aParser },\n+            { LocalDateTimeStringConverterVariant.WITH_FORMATTER_PARSER,\n+              null, null, VALID_LDT_WITH_SECONDS},\n@@ -72,3 +84,2 @@\n-            { new LocalDateTimeStringConverter(FormatStyle.SHORT, FormatStyle.SHORT, Locale.UK, IsoChronology.INSTANCE),\n-              Locale.UK, FormatStyle.SHORT, FormatStyle.SHORT,\n-              VALID_LDT_WITHOUT_SECONDS, null, null },\n+            { LocalDateTimeStringConverterVariant.WITH_FORMAT_STYLES,\n+              FormatStyle.SHORT, FormatStyle.SHORT, VALID_LDT_WITHOUT_SECONDS},\n@@ -78,2 +89,1 @@\n-    private LocalDateTimeStringConverter converter;\n-    private Locale locale;\n+    private LocalDateTimeStringConverterVariant converterVariant;\n@@ -82,0 +92,4 @@\n+    private LocalDateTime validDateTime;\n+    \n+    private LocalDateTimeStringConverter converter;\n+    private Locale locale;\n@@ -84,1 +98,0 @@\n-    private LocalDateTime validDateTime;\n@@ -86,3 +99,2 @@\n-    public LocalDateTimeStringConverterTest(LocalDateTimeStringConverter converter, Locale locale, FormatStyle dateStyle, FormatStyle timeStyle, LocalDateTime validDateTime, DateTimeFormatter formatter, DateTimeFormatter parser) {\n-        this.converter = converter;\n-        this.locale = locale;\n+    public LocalDateTimeStringConverterTest(LocalDateTimeStringConverterVariant converterVariant, FormatStyle dateStyle, FormatStyle timeStyle, LocalDateTime validDateTime) {\n+        this.converterVariant = converterVariant;\n@@ -92,2 +104,53 @@\n-        this.formatter = formatter;\n-        this.parser = parser;\n+\n+        this.converter = null;\n+        this.locale = null;\n+        this.formatter = null;\n+        this.parser = null;\n+    }\n+\n+    @BeforeClass\n+    public static void setupBeforeAll() {\n+        \/\/ Tests require that default locale is en_US\n+        oldLocale = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n+\n+        \/\/ DateTimeFormatter uses default locale, so we can init this after updating locale\n+        aFormatter = DateTimeFormatter.ofPattern(\"dd MM yyyy HH mm ss\");\n+        aParser = DateTimeFormatter.ofPattern(\"yyyy MM dd hh mm ss a\");\n+    }\n+\n+    @AfterClass\n+    public static void teardownAfterAll() {\n+        \/\/ Restore VM's old locale\n+        Locale.setDefault(oldLocale);\n+    }\n+\n+    @Before\n+    public void setup() {\n+        if (this.converter == null) {\n+            \/\/ Locale is established now, so we can allocate objects depending on it\n+            switch (this.converterVariant) {\n+            case NO_PARAM:\n+                this.converter = new LocalDateTimeStringConverter();\n+                this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+                \/\/ this.formatter and this.parser remain null\n+                break;\n+            case WITH_FORMATTER_PARSER:\n+                this.converter = new LocalDateTimeStringConverter(aFormatter, aParser);\n+                this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+                this.formatter = aFormatter;\n+                this.parser = aParser;\n+                break;\n+            case WITH_FORMAT_STYLES:\n+                this.converter = new LocalDateTimeStringConverter(FormatStyle.SHORT, FormatStyle.SHORT, Locale.UK, IsoChronology.INSTANCE);\n+                this.locale = Locale.UK;\n+                \/\/ this.formatter and this.parser remain null\n+                break;\n+            default:\n+                throw new InvalidParameterException(\"Invalid converter variant: \" + this.converterVariant.toString());\n+            }\n+        }\n+    }\n+\n+    @After\n+    public void teardown() {\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/LocalDateTimeStringConverterTest.java","additions":85,"deletions":22,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.security.InvalidParameterException;\n@@ -39,0 +40,2 @@\n+import org.junit.After;\n+import org.junit.AfterClass;\n@@ -40,0 +43,1 @@\n+import org.junit.BeforeClass;\n@@ -56,3 +60,14 @@\n-    private static final DateTimeFormatter aFormatter = DateTimeFormatter.ofPattern(\"HH mm ss\");\n-    private static final DateTimeFormatter aParser = DateTimeFormatter.ofPattern(\"hh mm ss a\");\n-\n+    private static Locale oldLocale = null;\n+    private static DateTimeFormatter aFormatter = null;\n+    private static DateTimeFormatter aParser = null;\n+\n+    \/\/ We can only create LocalTimeStringConverter object after Locale is set.\n+    \/\/ Unfortunately, due to unpredictability of @Parameterized.Parameters methods\n+    \/\/ in JUnit, we have to allocate it after @BeforeClass sets up Locale and\n+    \/\/ necessary static fields. Otherwise, the test may collide with other\n+    \/\/ Local*StringConverter tests and cause unpredictable results.\n+    private enum LocalTimeStringConverterVariant {\n+        NO_PARAM,\n+        WITH_FORMATTER_PARSER,\n+        WITH_FORMAT_STYLES,\n+    };\n@@ -62,3 +77,2 @@\n-            { new LocalTimeStringConverter(),\n-              Locale.getDefault(Locale.Category.FORMAT), FormatStyle.SHORT,\n-              VALID_TIME_WITHOUT_SECONDS, null, null },\n+            { LocalTimeStringConverterVariant.NO_PARAM,\n+              FormatStyle.SHORT, VALID_TIME_WITHOUT_SECONDS },\n@@ -66,3 +80,2 @@\n-            { new LocalTimeStringConverter(aFormatter, aParser),\n-              Locale.getDefault(Locale.Category.FORMAT), null,\n-              VALID_TIME_WITH_SECONDS, aFormatter, aParser },\n+            { LocalTimeStringConverterVariant.WITH_FORMATTER_PARSER,\n+              null, VALID_TIME_WITH_SECONDS },\n@@ -70,3 +83,2 @@\n-            { new LocalTimeStringConverter(FormatStyle.SHORT, Locale.UK),\n-              Locale.UK, FormatStyle.SHORT,\n-              VALID_TIME_WITHOUT_SECONDS, null, null },\n+            { LocalTimeStringConverterVariant.WITH_FORMAT_STYLES,\n+              FormatStyle.SHORT, VALID_TIME_WITHOUT_SECONDS },\n@@ -76,0 +88,4 @@\n+    private LocalTimeStringConverterVariant converterVariant;\n+    private FormatStyle timeStyle;\n+    private LocalTime validTime;\n+    \n@@ -78,1 +94,0 @@\n-    private FormatStyle timeStyle;\n@@ -80,1 +95,0 @@\n-    private LocalTime validTime;\n@@ -82,3 +96,2 @@\n-    public LocalTimeStringConverterTest(LocalTimeStringConverter converter, Locale locale, FormatStyle timeStyle, LocalTime validTime, DateTimeFormatter formatter, DateTimeFormatter parser) {\n-        this.converter = converter;\n-        this.locale = locale;\n+    public LocalTimeStringConverterTest(LocalTimeStringConverterVariant converterVariant, FormatStyle timeStyle, LocalTime validTime) {\n+        this.converterVariant = converterVariant;\n@@ -87,2 +100,48 @@\n-        this.formatter = formatter;\n-        this.parser = parser;\n+\n+        this.locale = null;\n+        this.formatter = null;\n+        this.parser = null;\n+    }\n+\n+    @BeforeClass\n+    public static void setupBeforeAll() {\n+        \/\/ Tests require that default locale is en_US\n+        oldLocale = Locale.getDefault();\n+        Locale.setDefault(Locale.US);\n+\n+        \/\/ DateTimeFormatter uses default locale, so we can init this after updating locale\n+        aFormatter = DateTimeFormatter.ofPattern(\"HH mm ss\");\n+        aParser = DateTimeFormatter.ofPattern(\"hh mm ss a\");\n+    }\n+\n+    @AfterClass\n+    public static void teardownAfterAll() {\n+        \/\/ Restore VM's old locale\n+        Locale.setDefault(oldLocale);\n+    }\n+\n+    @Before\n+    public void setup() {\n+        if (this.converter == null) {\n+            \/\/ Locale is established now, so we can allocate objects depending on it\n+            switch (this.converterVariant) {\n+            case NO_PARAM:\n+                this.converter = new LocalTimeStringConverter();\n+                this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+                \/\/ this.formatter and this.parser remain null\n+                break;\n+            case WITH_FORMATTER_PARSER:\n+                this.converter = new LocalTimeStringConverter(aFormatter, aParser);\n+                this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+                this.formatter = aFormatter;\n+                this.parser = aParser;\n+                break;\n+            case WITH_FORMAT_STYLES:\n+                this.converter = new LocalTimeStringConverter(FormatStyle.SHORT, Locale.UK);\n+                this.locale = Locale.UK;\n+                \/\/ this.formatter and this.parser remain null\n+                break;\n+            default:\n+                throw new InvalidParameterException(\"Invalid converter variant: \" + this.converterVariant.toString());\n+            }\n+        }\n@@ -91,1 +150,2 @@\n-    @Before public void setup() {\n+    @After\n+    public void teardown() {\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/LocalTimeStringConverterTest.java","additions":80,"deletions":20,"binary":false,"changes":100,"status":"modified"}]}