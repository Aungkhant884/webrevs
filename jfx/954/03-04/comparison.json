{"files":[{"patch":"@@ -42,1 +42,0 @@\n-import org.junit.After;\n@@ -123,22 +122,22 @@\n-        if (this.converter == null) {\n-            \/\/ Locale is established now, so we can allocate objects depending on it\n-            switch (this.converterVariant) {\n-            case NO_PARAM:\n-                this.converter = new LocalDateStringConverter();\n-                this.locale = Locale.getDefault(Locale.Category.FORMAT);\n-                \/\/ this.formatter and this.parser remain null\n-                break;\n-            case WITH_FORMATTER_PARSER:\n-                this.converter = new LocalDateStringConverter(aFormatter, aParser);\n-                this.locale = Locale.getDefault(Locale.Category.FORMAT);\n-                this.formatter = aFormatter;\n-                this.parser = aParser;\n-                break;\n-            case WITH_FORMAT_STYLES:\n-                this.converter = new LocalDateStringConverter(FormatStyle.SHORT, Locale.UK, IsoChronology.INSTANCE);\n-                this.locale = Locale.UK;\n-                \/\/ this.formatter and this.parser remain null\n-                break;\n-            default:\n-                throw new InvalidParameterException(\"Invalid converter variant: \" + this.converterVariant.toString());\n-            }\n+        \/\/ Locale is established now, so we can allocate objects depending on it\n+        switch (this.converterVariant) {\n+        case NO_PARAM:\n+            this.converter = new LocalDateStringConverter();\n+            this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+            this.formatter = null;\n+            this.parser = null;\n+            break;\n+        case WITH_FORMATTER_PARSER:\n+            this.converter = new LocalDateStringConverter(aFormatter, aParser);\n+            this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+            this.formatter = aFormatter;\n+            this.parser = aParser;\n+            break;\n+        case WITH_FORMAT_STYLES:\n+            this.converter = new LocalDateStringConverter(FormatStyle.SHORT, Locale.UK, IsoChronology.INSTANCE);\n+            this.locale = Locale.UK;\n+            this.formatter = null;\n+            this.parser = null;\n+            break;\n+        default:\n+            fail(\"Invalid converter variant: \" + this.converterVariant.toString());\n@@ -148,4 +147,0 @@\n-    @After\n-    public void teardown() {\n-    }\n-\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/LocalDateStringConverterTest.java","additions":22,"deletions":27,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import org.junit.After;\n@@ -130,22 +129,22 @@\n-        if (this.converter == null) {\n-            \/\/ Locale is established now, so we can allocate objects depending on it\n-            switch (this.converterVariant) {\n-            case NO_PARAM:\n-                this.converter = new LocalDateTimeStringConverter();\n-                this.locale = Locale.getDefault(Locale.Category.FORMAT);\n-                \/\/ this.formatter and this.parser remain null\n-                break;\n-            case WITH_FORMATTER_PARSER:\n-                this.converter = new LocalDateTimeStringConverter(aFormatter, aParser);\n-                this.locale = Locale.getDefault(Locale.Category.FORMAT);\n-                this.formatter = aFormatter;\n-                this.parser = aParser;\n-                break;\n-            case WITH_FORMAT_STYLES:\n-                this.converter = new LocalDateTimeStringConverter(FormatStyle.SHORT, FormatStyle.SHORT, Locale.UK, IsoChronology.INSTANCE);\n-                this.locale = Locale.UK;\n-                \/\/ this.formatter and this.parser remain null\n-                break;\n-            default:\n-                throw new InvalidParameterException(\"Invalid converter variant: \" + this.converterVariant.toString());\n-            }\n+        \/\/ Locale is established now, so we can allocate objects depending on it\n+        switch (this.converterVariant) {\n+        case NO_PARAM:\n+            this.converter = new LocalDateTimeStringConverter();\n+            this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+            this.formatter = null;\n+            this.parser = null;\n+            break;\n+        case WITH_FORMATTER_PARSER:\n+            this.converter = new LocalDateTimeStringConverter(aFormatter, aParser);\n+            this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+            this.formatter = aFormatter;\n+            this.parser = aParser;\n+            break;\n+        case WITH_FORMAT_STYLES:\n+            this.converter = new LocalDateTimeStringConverter(FormatStyle.SHORT, FormatStyle.SHORT, Locale.UK, IsoChronology.INSTANCE);\n+            this.locale = Locale.UK;\n+            this.formatter = null;\n+            this.parser = null;\n+            break;\n+        default:\n+            fail(\"Invalid converter variant: \" + this.converterVariant.toString());\n@@ -155,4 +154,0 @@\n-    @After\n-    public void teardown() {\n-    }\n-\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/LocalDateTimeStringConverterTest.java","additions":22,"deletions":27,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import org.junit.After;\n@@ -125,22 +124,22 @@\n-        if (this.converter == null) {\n-            \/\/ Locale is established now, so we can allocate objects depending on it\n-            switch (this.converterVariant) {\n-            case NO_PARAM:\n-                this.converter = new LocalTimeStringConverter();\n-                this.locale = Locale.getDefault(Locale.Category.FORMAT);\n-                \/\/ this.formatter and this.parser remain null\n-                break;\n-            case WITH_FORMATTER_PARSER:\n-                this.converter = new LocalTimeStringConverter(aFormatter, aParser);\n-                this.locale = Locale.getDefault(Locale.Category.FORMAT);\n-                this.formatter = aFormatter;\n-                this.parser = aParser;\n-                break;\n-            case WITH_FORMAT_STYLES:\n-                this.converter = new LocalTimeStringConverter(FormatStyle.SHORT, Locale.UK);\n-                this.locale = Locale.UK;\n-                \/\/ this.formatter and this.parser remain null\n-                break;\n-            default:\n-                throw new InvalidParameterException(\"Invalid converter variant: \" + this.converterVariant.toString());\n-            }\n+        \/\/ Locale is established now, so we can allocate objects depending on it\n+        switch (this.converterVariant) {\n+        case NO_PARAM:\n+            this.converter = new LocalTimeStringConverter();\n+            this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+            this.formatter = null;\n+            this.parser = null;\n+            break;\n+        case WITH_FORMATTER_PARSER:\n+            this.converter = new LocalTimeStringConverter(aFormatter, aParser);\n+            this.locale = Locale.getDefault(Locale.Category.FORMAT);\n+            this.formatter = aFormatter;\n+            this.parser = aParser;\n+            break;\n+        case WITH_FORMAT_STYLES:\n+            this.converter = new LocalTimeStringConverter(FormatStyle.SHORT, Locale.UK);\n+            this.locale = Locale.UK;\n+            this.formatter = null;\n+            this.parser = null;\n+            break;\n+        default:\n+            fail(\"Invalid converter variant: \" + this.converterVariant.toString());\n@@ -150,4 +149,0 @@\n-    @After\n-    public void teardown() {\n-    }\n-\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/converter\/LocalTimeStringConverterTest.java","additions":22,"deletions":27,"binary":false,"changes":49,"status":"modified"}]}