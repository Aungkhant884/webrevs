{"files":[{"patch":"@@ -29,1 +29,1 @@\n-import com.sun.javafx.scene.TreeShowingExpression;\n+import com.sun.javafx.scene.TreeShowingProperty;\n@@ -108,1 +108,1 @@\n-    private TreeShowingExpression treeShowingExpression;\n+    private TreeShowingProperty treeShowingProperty;\n@@ -130,1 +130,1 @@\n-        this.treeShowingExpression = new TreeShowingExpression(control);\n+        this.treeShowingProperty = new TreeShowingProperty(control);\n@@ -136,1 +136,1 @@\n-        registerChangeListener(treeShowingExpression, e -> updateAnimation());\n+        registerChangeListener(treeShowingProperty, e -> updateAnimation());\n@@ -238,1 +238,1 @@\n-        treeShowingExpression.dispose();\n+        treeShowingProperty.dispose();\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/ProgressIndicatorSkin.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import javafx.beans.InvalidationListener;\n-import javafx.beans.binding.BooleanExpression;\n@@ -44,1 +42,1 @@\n-public class TreeShowingExpression extends ReadOnlyBooleanPropertyBase {\n+public class TreeShowingProperty extends ReadOnlyBooleanPropertyBase {\n@@ -59,1 +57,1 @@\n-    public TreeShowingExpression(Node node) {\n+    public TreeShowingProperty(Node node) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/TreeShowingProperty.java","additions":2,"deletions":4,"binary":false,"changes":6,"previous_filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/TreeShowingExpression.java","status":"renamed"},{"patch":"@@ -8553,1 +8553,1 @@\n-    private TreeVisiblePropertyReadOnly treeVisibleRO;\n+    private TreeVisibleProperty treeVisibleProperty;\n@@ -8566,1 +8566,3 @@\n-            ((TreeVisiblePropertyReadOnly) treeVisibleProperty()).invalidate();\n+            if (treeVisibleProperty != null) {\n+                treeVisibleProperty.invalidate();\n+            }\n@@ -8586,3 +8588,3 @@\n-    final BooleanExpression treeVisibleProperty() {\n-        if (treeVisibleRO == null) {\n-            treeVisibleRO = new TreeVisiblePropertyReadOnly();\n+    final ReadOnlyBooleanProperty treeVisibleProperty() {\n+        if (treeVisibleProperty == null) {\n+            treeVisibleProperty = new TreeVisibleProperty();\n@@ -8590,1 +8592,1 @@\n-        return treeVisibleRO;\n+        return treeVisibleProperty;\n@@ -8593,1 +8595,1 @@\n-    class TreeVisiblePropertyReadOnly extends ReadOnlyBooleanPropertyBase {\n+    class TreeVisibleProperty extends ReadOnlyBooleanPropertyBase {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Node.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import com.sun.javafx.scene.TreeShowingExpression;\n+import com.sun.javafx.scene.TreeShowingProperty;\n@@ -153,1 +153,1 @@\n-    private TreeShowingExpression treeShowingExpression;\n+    private TreeShowingProperty treeShowingProperty;\n@@ -418,2 +418,2 @@\n-            treeShowingExpression = new TreeShowingExpression(ownerNode);\n-            treeShowingExpression.addListener(weakOwnerNodeListener);\n+            treeShowingProperty = new TreeShowingProperty(ownerNode);\n+            treeShowingProperty.addListener(weakOwnerNodeListener);\n@@ -496,4 +496,4 @@\n-        if (treeShowingExpression != null) {\n-            treeShowingExpression.removeListener(weakOwnerNodeListener);\n-            treeShowingExpression.dispose();\n-            treeShowingExpression = null;\n+        if (treeShowingProperty != null) {\n+            treeShowingProperty.removeListener(weakOwnerNodeListener);\n+            treeShowingProperty.dispose();\n+            treeShowingProperty = null;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/PopupWindow.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,318 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.javafx.scene;\n-\n-import com.sun.javafx.scene.TreeShowingExpression;\n-import javafx.beans.InvalidationListener;\n-import javafx.beans.value.ChangeListener;\n-import javafx.scene.Node;\n-import javafx.scene.Parent;\n-import javafx.scene.Scene;\n-import javafx.scene.SubScene;\n-import javafx.scene.layout.StackPane;\n-import javafx.stage.Stage;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameters;\n-\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Supplier;\n-\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-\n-@RunWith(Parameterized.class)\n-public class TreeShowingExpressionTest {\n-    private final Parent root;\n-    private final Node node;\n-    private final TreeShowingExpression expression;\n-\n-    @Parameters\n-    public static Collection<Object[]> parameters() {\n-        Supplier<RootAndNodeToTest> supplier1 = () -> {\n-            Node node = new StackPane();\n-            return new RootAndNodeToTest(new StackPane(node), node);\n-        };\n-\n-        Supplier<RootAndNodeToTest> supplier2 = () -> {\n-            StackPane node = new StackPane();\n-            return new RootAndNodeToTest(new StackPane(new SubScene(node, 100.0, 100.0)), node);\n-        };\n-\n-        return Arrays.asList(new Object[][] { { supplier1 }, { supplier2 } });\n-    }\n-\n-    static class RootAndNodeToTest {\n-        RootAndNodeToTest(Parent root, Node nodeToTest) {\n-            this.root = root;\n-            this.nodeToTest = nodeToTest;\n-        }\n-\n-        Parent root;\n-        Node nodeToTest;\n-    }\n-\n-    public TreeShowingExpressionTest(Supplier<RootAndNodeToTest> nodeSupplier) {\n-        RootAndNodeToTest nodes = nodeSupplier.get();\n-\n-        this.root = nodes.root;\n-        this.node = nodes.nodeToTest;\n-        this.expression = new TreeShowingExpression(this.node);\n-    }\n-\n-    @Test\n-    public void nodeNotAttachedToSceneShouldNotBeShowing() {\n-        assertFalse(expression.get());\n-    }\n-\n-    @Test\n-    public void getShouldTrackChangesInShowingStateForGivenNode() {\n-        assertFalse(expression.get());  \/\/ not showing initially as not attached to a Scene\n-\n-        Scene scene = new Scene(root);\n-\n-        assertFalse(expression.get());  \/\/ not showing because Scene is not attached to a Window\n-\n-        Stage stage = new Stage();\n-        stage.setScene(scene);\n-\n-        assertFalse(expression.get());  \/\/ not showing as Window is not shown\n-\n-        stage.show();\n-\n-        assertTrue(expression.get());  \/\/ showing as Window is shown\n-\n-        stage.hide();\n-\n-        assertFalse(expression.get());  \/\/ not showing again as Window is hidden\n-    }\n-\n-    @Test\n-    public void changeListenerShouldRegisterAndUnregisterCorrectly() {\n-        AtomicReference<Boolean> state = new AtomicReference<>();\n-        ChangeListener<Boolean> listener = (obs, old, current) -> state.set(current);\n-\n-        expression.addListener(listener);\n-\n-        assertNull(state.getAndSet(null));  \/\/ no change fired so far\n-\n-        Stage stage = new Stage();\n-        stage.setScene(new Scene(root));\n-        stage.show();\n-\n-        assertTrue(state.getAndSet(null));  \/\/ expect a change indicating the node is showing now\n-\n-        expression.removeListener(listener);\n-\n-        stage.hide();\n-\n-        assertNull(state.getAndSet(null));  \/\/ no change fired as listener was unregistered\n-    }\n-\n-    @Test\n-    public void invalidationListenerShouldRegisterAndUnregisterCorrectly() {\n-        AtomicReference<Boolean> state = new AtomicReference<>();\n-        InvalidationListener listener = obs -> state.set(true);\n-\n-        expression.addListener(listener);\n-\n-        assertNull(state.getAndSet(null));  \/\/ no invalidation fired so far\n-\n-        Stage stage = new Stage();\n-        stage.setScene(new Scene(root));\n-        stage.show();\n-\n-        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as node is showing now\n-\n-        expression.get();  \/\/ make valid again\n-        expression.removeListener(listener);\n-\n-        stage.hide();\n-\n-        assertNull(state.getAndSet(null));  \/\/ expect no invalidation as listener was unregistered\n-    }\n-\n-    @Test\n-    public void changeListenerShouldTrackShowingState() {\n-        AtomicReference<Boolean> state = new AtomicReference<>();\n-\n-        expression.addListener((obs, old, current) -> state.set(current));\n-\n-        assertNull(state.getAndSet(null));  \/\/ no change fired so far\n-\n-        Scene scene = new Scene(root);\n-\n-        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no change\n-\n-        Stage stage = new Stage();\n-        stage.setWidth(100);\n-        stage.setHeight(100);\n-        stage.setScene(scene);\n-\n-        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no change\n-\n-        stage.show();\n-\n-        assertTrue(state.getAndSet(null));  \/\/ expect a change indicating the node is showing now\n-\n-        stage.setScene(null);\n-\n-        assertFalse(state.getAndSet(null));  \/\/ detaching stage from scene should fire not showing change\n-\n-        stage.setScene(scene);\n-\n-        assertTrue(state.getAndSet(null));  \/\/ reattaching stage should fire showing change\n-\n-        stage.hide();\n-\n-        assertFalse(state.getAndSet(null));  \/\/ expect a change indicating the node is no longer showing\n-\n-        Stage stage2 = new Stage();\n-        stage2.setWidth(100);\n-        stage2.setHeight(100);\n-        stage2.show();\n-        stage2.setScene(scene);\n-\n-        assertTrue(state.getAndSet(null));  \/\/ switching between invisible\/visible Scene should trigger showing change\n-\n-        stage2.hide();\n-\n-        assertFalse(state.getAndSet(null));  \/\/ hiding attached window should trigger not showing change\n-\n-        stage.show();\n-\n-        assertNull(state.getAndSet(null));  \/\/ changing visibility of unattached stage should not do anything\n-\n-        scene.setRoot(new StackPane());\n-        Scene scene2 = new Scene(root);\n-        stage.setScene(scene2);\n-\n-        assertTrue(state.getAndSet(null));  \/\/ making root part of a different visible scene should trigger showing change\n-    }\n-\n-    @Test\n-    public void invalidationListenerShouldNotifyOfChangesInShowingState() {\n-        AtomicReference<Boolean> state = new AtomicReference<>();\n-\n-        expression.addListener(obs -> state.set(true));\n-\n-        assertNull(state.getAndSet(null));  \/\/ no invalidation fired so far\n-\n-        Scene scene = new Scene(root);\n-\n-        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no invalidation\n-\n-        Stage stage = new Stage();\n-        stage.setWidth(100);\n-        stage.setHeight(100);\n-        stage.setScene(scene);\n-\n-        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no invalidation\n-\n-        stage.show();\n-\n-        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as the node is showing now\n-\n-        expression.get();  \/\/ make valid\n-        stage.setScene(null);\n-\n-        assertTrue(state.getAndSet(null));  \/\/ detaching stage from scene should fire invalidation\n-\n-        expression.get();  \/\/ make valid\n-        stage.setScene(scene);\n-\n-        assertTrue(state.getAndSet(null));  \/\/ reattaching stage should fire invalidation\n-\n-        \/\/ didn't make valid here\n-        stage.hide();\n-\n-        assertNull(state.getAndSet(null));  \/\/ expect nothing as expression still invalid\n-\n-        stage.show();\n-        expression.get();  \/\/ make valid\n-        stage.hide();\n-\n-        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as the node is no longer showing now\n-\n-        Stage stage2 = new Stage();\n-        stage2.setWidth(100);\n-        stage2.setHeight(100);\n-        stage2.show();\n-        expression.get();  \/\/ make valid\n-        stage2.setScene(scene);\n-\n-        assertTrue(state.getAndSet(null));  \/\/ switching between invisible\/visible Scene should trigger invalidation\n-\n-        expression.get();  \/\/ make valid\n-        stage2.hide();\n-\n-        assertTrue(state.getAndSet(null));  \/\/ hiding attached window should trigger invalidation\n-\n-        expression.get();  \/\/ make valid\n-        stage.show();\n-\n-        assertNull(state.getAndSet(null));  \/\/ changing visibility of unattached stage should not do anything\n-\n-        scene.setRoot(new StackPane());\n-        Scene scene2 = new Scene(root);\n-        expression.get();  \/\/ make valid\n-        stage.setScene(scene2);\n-\n-        assertTrue(state.getAndSet(null));  \/\/ making root part of a different visible scene should trigger invalidation\n-    }\n-\n-    @Test\n-    public void disposeShouldUnregisterListenersOnGivenNode() {\n-        AtomicReference<Boolean> state = new AtomicReference<>();\n-\n-        expression.addListener((obs, old, current) -> state.set(current));\n-\n-        \/\/ verify change listener works:\n-        Stage stage = new Stage();\n-        Scene scene = new Scene(root);\n-        stage.setScene(scene);\n-        stage.show();\n-        assertTrue(state.getAndSet(null));\n-\n-        expression.dispose();\n-\n-        \/\/ verify change listener no longer responds:\n-        stage.hide();\n-        assertNull(state.getAndSet(null));\n-\n-        \/\/ another check:\n-        Stage stage2 = new Stage();\n-        stage2.setWidth(100);\n-        stage2.setHeight(100);\n-        stage2.show();\n-        scene.setRoot(new StackPane());\n-        stage2.setScene(new Scene(root));\n-        assertNull(state.getAndSet(null));\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/TreeShowingExpressionTest.java","additions":0,"deletions":318,"binary":false,"changes":318,"status":"deleted"},{"patch":"@@ -0,0 +1,318 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.scene;\n+\n+import com.sun.javafx.scene.TreeShowingProperty;\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.value.ChangeListener;\n+import javafx.scene.Node;\n+import javafx.scene.Parent;\n+import javafx.scene.Scene;\n+import javafx.scene.SubScene;\n+import javafx.scene.layout.StackPane;\n+import javafx.stage.Stage;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class TreeShowingPropertyTest {\n+    private final Parent root;\n+    private final Node node;\n+    private final TreeShowingProperty property;\n+\n+    @Parameters\n+    public static Collection<Object[]> parameters() {\n+        Supplier<RootAndNodeToTest> supplier1 = () -> {\n+            Node node = new StackPane();\n+            return new RootAndNodeToTest(new StackPane(node), node);\n+        };\n+\n+        Supplier<RootAndNodeToTest> supplier2 = () -> {\n+            StackPane node = new StackPane();\n+            return new RootAndNodeToTest(new StackPane(new SubScene(node, 100.0, 100.0)), node);\n+        };\n+\n+        return Arrays.asList(new Object[][] { { supplier1 }, { supplier2 } });\n+    }\n+\n+    static class RootAndNodeToTest {\n+        RootAndNodeToTest(Parent root, Node nodeToTest) {\n+            this.root = root;\n+            this.nodeToTest = nodeToTest;\n+        }\n+\n+        Parent root;\n+        Node nodeToTest;\n+    }\n+\n+    public TreeShowingPropertyTest(Supplier<RootAndNodeToTest> nodeSupplier) {\n+        RootAndNodeToTest nodes = nodeSupplier.get();\n+\n+        this.root = nodes.root;\n+        this.node = nodes.nodeToTest;\n+        this.property = new TreeShowingProperty(this.node);\n+    }\n+\n+    @Test\n+    public void nodeNotAttachedToSceneShouldNotBeShowing() {\n+        assertFalse(property.get());\n+    }\n+\n+    @Test\n+    public void getShouldTrackChangesInShowingStateForGivenNode() {\n+        assertFalse(property.get());  \/\/ not showing initially as not attached to a Scene\n+\n+        Scene scene = new Scene(root);\n+\n+        assertFalse(property.get());  \/\/ not showing because Scene is not attached to a Window\n+\n+        Stage stage = new Stage();\n+        stage.setScene(scene);\n+\n+        assertFalse(property.get());  \/\/ not showing as Window is not shown\n+\n+        stage.show();\n+\n+        assertTrue(property.get());  \/\/ showing as Window is shown\n+\n+        stage.hide();\n+\n+        assertFalse(property.get());  \/\/ not showing again as Window is hidden\n+    }\n+\n+    @Test\n+    public void changeListenerShouldRegisterAndUnregisterCorrectly() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+        ChangeListener<Boolean> listener = (obs, old, current) -> state.set(current);\n+\n+        property.addListener(listener);\n+\n+        assertNull(state.getAndSet(null));  \/\/ no change fired so far\n+\n+        Stage stage = new Stage();\n+        stage.setScene(new Scene(root));\n+        stage.show();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect a change indicating the node is showing now\n+\n+        property.removeListener(listener);\n+\n+        stage.hide();\n+\n+        assertNull(state.getAndSet(null));  \/\/ no change fired as listener was unregistered\n+    }\n+\n+    @Test\n+    public void invalidationListenerShouldRegisterAndUnregisterCorrectly() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+        InvalidationListener listener = obs -> state.set(true);\n+\n+        property.addListener(listener);\n+\n+        assertNull(state.getAndSet(null));  \/\/ no invalidation fired so far\n+\n+        Stage stage = new Stage();\n+        stage.setScene(new Scene(root));\n+        stage.show();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as node is showing now\n+\n+        property.get();  \/\/ make valid again\n+        property.removeListener(listener);\n+\n+        stage.hide();\n+\n+        assertNull(state.getAndSet(null));  \/\/ expect no invalidation as listener was unregistered\n+    }\n+\n+    @Test\n+    public void changeListenerShouldTrackShowingState() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+\n+        property.addListener((obs, old, current) -> state.set(current));\n+\n+        assertNull(state.getAndSet(null));  \/\/ no change fired so far\n+\n+        Scene scene = new Scene(root);\n+\n+        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no change\n+\n+        Stage stage = new Stage();\n+        stage.setWidth(100);\n+        stage.setHeight(100);\n+        stage.setScene(scene);\n+\n+        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no change\n+\n+        stage.show();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect a change indicating the node is showing now\n+\n+        stage.setScene(null);\n+\n+        assertFalse(state.getAndSet(null));  \/\/ detaching stage from scene should fire not showing change\n+\n+        stage.setScene(scene);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ reattaching stage should fire showing change\n+\n+        stage.hide();\n+\n+        assertFalse(state.getAndSet(null));  \/\/ expect a change indicating the node is no longer showing\n+\n+        Stage stage2 = new Stage();\n+        stage2.setWidth(100);\n+        stage2.setHeight(100);\n+        stage2.show();\n+        stage2.setScene(scene);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ switching between invisible\/visible Scene should trigger showing change\n+\n+        stage2.hide();\n+\n+        assertFalse(state.getAndSet(null));  \/\/ hiding attached window should trigger not showing change\n+\n+        stage.show();\n+\n+        assertNull(state.getAndSet(null));  \/\/ changing visibility of unattached stage should not do anything\n+\n+        scene.setRoot(new StackPane());\n+        Scene scene2 = new Scene(root);\n+        stage.setScene(scene2);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ making root part of a different visible scene should trigger showing change\n+    }\n+\n+    @Test\n+    public void invalidationListenerShouldNotifyOfChangesInShowingState() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+\n+        property.addListener(obs -> state.set(true));\n+\n+        assertNull(state.getAndSet(null));  \/\/ no invalidation fired so far\n+\n+        Scene scene = new Scene(root);\n+\n+        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no invalidation\n+\n+        Stage stage = new Stage();\n+        stage.setWidth(100);\n+        stage.setHeight(100);\n+        stage.setScene(scene);\n+\n+        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no invalidation\n+\n+        stage.show();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as the node is showing now\n+\n+        property.get();  \/\/ make valid\n+        stage.setScene(null);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ detaching stage from scene should fire invalidation\n+\n+        property.get();  \/\/ make valid\n+        stage.setScene(scene);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ reattaching stage should fire invalidation\n+\n+        \/\/ didn't make valid here\n+        stage.hide();\n+\n+        assertNull(state.getAndSet(null));  \/\/ expect nothing as expression still invalid\n+\n+        stage.show();\n+        property.get();  \/\/ make valid\n+        stage.hide();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as the node is no longer showing now\n+\n+        Stage stage2 = new Stage();\n+        stage2.setWidth(100);\n+        stage2.setHeight(100);\n+        stage2.show();\n+        property.get();  \/\/ make valid\n+        stage2.setScene(scene);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ switching between invisible\/visible Scene should trigger invalidation\n+\n+        property.get();  \/\/ make valid\n+        stage2.hide();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ hiding attached window should trigger invalidation\n+\n+        property.get();  \/\/ make valid\n+        stage.show();\n+\n+        assertNull(state.getAndSet(null));  \/\/ changing visibility of unattached stage should not do anything\n+\n+        scene.setRoot(new StackPane());\n+        Scene scene2 = new Scene(root);\n+        property.get();  \/\/ make valid\n+        stage.setScene(scene2);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ making root part of a different visible scene should trigger invalidation\n+    }\n+\n+    @Test\n+    public void disposeShouldUnregisterListenersOnGivenNode() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+\n+        property.addListener((obs, old, current) -> state.set(current));\n+\n+        \/\/ verify change listener works:\n+        Stage stage = new Stage();\n+        Scene scene = new Scene(root);\n+        stage.setScene(scene);\n+        stage.show();\n+        assertTrue(state.getAndSet(null));\n+\n+        property.dispose();\n+\n+        \/\/ verify change listener no longer responds:\n+        stage.hide();\n+        assertNull(state.getAndSet(null));\n+\n+        \/\/ another check:\n+        Stage stage2 = new Stage();\n+        stage2.setWidth(100);\n+        stage2.setHeight(100);\n+        stage2.show();\n+        scene.setRoot(new StackPane());\n+        stage2.setScene(new Scene(root));\n+        assertNull(state.getAndSet(null));\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/TreeShowingPropertyTest.java","additions":318,"deletions":0,"binary":false,"changes":318,"status":"added"}]}