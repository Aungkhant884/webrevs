{"files":[{"patch":"@@ -39,1 +39,0 @@\n-import javafx.beans.value.ChangeListener;\n@@ -48,1 +47,0 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n@@ -87,3 +85,4 @@\n-    private static final class TextAreaContent implements Content {\n-        private ExpressionHelper<String> helper = null;\n-        private ArrayList<StringBuilder> paragraphs = new ArrayList<>();\n+    private static final class TextAreaContent extends ContentBase {\n+        private final List<StringBuilder> paragraphs = new ArrayList<>();\n+        private final ParagraphList paragraphList = new ParagraphList();\n+\n@@ -91,2 +90,0 @@\n-        private ParagraphList paragraphList = new ParagraphList();\n-        private ListListenerHelper<CharSequence> listenerHelper;\n@@ -217,1 +214,1 @@\n-                    ExpressionHelper.fireValueChangedEvent(helper);\n+                    fireValueChangedEvent();\n@@ -300,1 +297,1 @@\n-                    ExpressionHelper.fireValueChangedEvent(helper);\n+                    fireValueChangedEvent();\n@@ -313,8 +310,0 @@\n-        @Override public void addListener(ChangeListener<? super String> changeListener) {\n-            helper = ExpressionHelper.addListener(helper, this, changeListener);\n-        }\n-\n-        @Override public void removeListener(ChangeListener<? super String> changeListener) {\n-            helper = ExpressionHelper.removeListener(helper, changeListener);\n-        }\n-\n@@ -325,8 +314,0 @@\n-        @Override public void addListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n-        }\n-\n-        @Override public void removeListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n-        }\n-\n@@ -335,1 +316,1 @@\n-            ListListenerHelper.fireValueChangedEvent(listenerHelper, change);\n+            ListListenerHelper.fireValueChangedEvent(paragraphList.listenerHelper, change);\n@@ -344,0 +325,1 @@\n+        private ListListenerHelper<CharSequence> listenerHelper;\n@@ -377,1 +359,1 @@\n-            content.listenerHelper = ListListenerHelper.addListener(content.listenerHelper, listener);\n+            listenerHelper = ListListenerHelper.addListener(listenerHelper, listener);\n@@ -382,1 +364,1 @@\n-            content.listenerHelper = ListListenerHelper.removeListener(content.listenerHelper, listener);\n+            listenerHelper = ListListenerHelper.removeListener(listenerHelper, listener);\n@@ -402,1 +384,1 @@\n-            content.listenerHelper = ListListenerHelper.addListener(content.listenerHelper, listener);\n+            listenerHelper = ListListenerHelper.addListener(listenerHelper, listener);\n@@ -407,1 +389,1 @@\n-            content.listenerHelper = ListListenerHelper.removeListener(content.listenerHelper, listener);\n+            listenerHelper = ListListenerHelper.removeListener(listenerHelper, listener);\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TextArea.java","additions":12,"deletions":30,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javafx.beans.InvalidationListener;\n@@ -36,1 +35,0 @@\n-import javafx.beans.value.ChangeListener;\n@@ -47,1 +45,0 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n@@ -77,0 +74,1 @@\n+\n@@ -78,2 +76,1 @@\n-    private static final class TextFieldContent implements Content {\n-        private ExpressionHelper<String> helper = null;\n+    private static final class TextFieldContent extends ContentBase {\n@@ -91,1 +88,1 @@\n-                    ExpressionHelper.fireValueChangedEvent(helper);\n+                    fireValueChangedEvent();\n@@ -100,1 +97,1 @@\n-                    ExpressionHelper.fireValueChangedEvent(helper);\n+                    fireValueChangedEvent();\n@@ -113,8 +110,0 @@\n-        @Override public void addListener(ChangeListener<? super String> changeListener) {\n-            helper = ExpressionHelper.addListener(helper, this, changeListener);\n-        }\n-\n-        @Override public void removeListener(ChangeListener<? super String> changeListener) {\n-            helper = ExpressionHelper.removeListener(helper, changeListener);\n-        }\n-\n@@ -124,8 +113,0 @@\n-\n-        @Override public void addListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n-        }\n-\n-        @Override public void removeListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n-        }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TextField.java","additions":4,"deletions":23,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -122,0 +122,31 @@\n+    \/**\n+     * Package private base implementation of Content.\n+     *\/\n+    abstract static class ContentBase implements Content {\n+        private ExpressionHelper<String> helper;\n+\n+        @Override\n+        public void addListener(ChangeListener<? super String> changeListener) {\n+            helper = ExpressionHelper.addListener(helper, this, changeListener);\n+        }\n+\n+        @Override\n+        public void removeListener(ChangeListener<? super String> changeListener) {\n+            helper = ExpressionHelper.removeListener(helper, changeListener);\n+        }\n+\n+        @Override\n+        public void addListener(InvalidationListener listener) {\n+            helper = ExpressionHelper.addListener(helper, this, listener);\n+        }\n+\n+        @Override\n+        public void removeListener(InvalidationListener listener) {\n+            helper = ExpressionHelper.removeListener(helper, listener);\n+        }\n+\n+        protected final void fireValueChangedEvent() {\n+            ExpressionHelper.fireValueChangedEvent(helper);\n+        }\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TextInputControl.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import com.sun.javafx.scene.TreeShowingExpression;\n+import com.sun.javafx.scene.TreeShowingProperty;\n@@ -108,1 +108,1 @@\n-    private TreeShowingExpression treeShowingExpression;\n+    private TreeShowingProperty treeShowingProperty;\n@@ -130,1 +130,1 @@\n-        this.treeShowingExpression = new TreeShowingExpression(control);\n+        this.treeShowingProperty = new TreeShowingProperty(control);\n@@ -136,1 +136,1 @@\n-        registerChangeListener(treeShowingExpression, e -> updateAnimation());\n+        registerChangeListener(treeShowingProperty, e -> updateAnimation());\n@@ -238,1 +238,1 @@\n-        treeShowingExpression.dispose();\n+        treeShowingProperty.dispose();\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/ProgressIndicatorSkin.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.scene;\n-\n-import com.sun.javafx.binding.ExpressionHelper;\n-import javafx.beans.InvalidationListener;\n-import javafx.beans.binding.BooleanExpression;\n-import javafx.beans.value.ChangeListener;\n-import javafx.scene.Node;\n-import javafx.scene.Scene;\n-import javafx.stage.Window;\n-\n-\/**\n- * Used to observe changes in tree showing status for a {@link Node}.  For a Node's tree to be showing\n- * it must be visible, its ancestors must be visible, the node must be part of a {@link Scene} and\n- * the scene must have a {@link Window} which is currently showing.<p>\n- *\n- * This class provides the exact same functionality as {@link NodeHelper#isTreeShowing(Node)} in\n- * an observable form.\n- *\/\n-public class TreeShowingExpression extends BooleanExpression {\n-    private final ChangeListener<Boolean> windowShowingChangedListener = (obs, old, current) -> updateTreeShowing();\n-    private final ChangeListener<Window> sceneWindowChangedListener = (obs, old, current) -> windowChanged(old, current);\n-    private final ChangeListener<Scene> nodeSceneChangedListener = (obs, old, current) -> sceneChanged(old, current);\n-\n-    private final Node node;\n-\n-    private ExpressionHelper<Boolean> helper;\n-    private boolean valid;\n-    private boolean treeShowing;\n-\n-    \/**\n-     * Constructs a new instance.\n-     *\n-     * @param node a {@link Node} for which the tree showing status should be observed, cannot be null\n-     *\/\n-    public TreeShowingExpression(Node node) {\n-        this.node = node;\n-        this.node.sceneProperty().addListener(nodeSceneChangedListener);\n-\n-        NodeHelper.treeVisibleProperty(node).addListener(windowShowingChangedListener);\n-\n-        sceneChanged(null, node.getScene());\n-    }\n-\n-    \/**\n-     * Cleans up any listeners that this class may have registered on the {@link Node}\n-     * that was supplied at construction.\n-     *\/\n-    public void dispose() {\n-        node.sceneProperty().removeListener(nodeSceneChangedListener);\n-\n-        NodeHelper.treeVisibleProperty(node).removeListener(windowShowingChangedListener);\n-\n-        valid = false;  \/\/ prevents unregistration from triggering an invalidation notification\n-        sceneChanged(node.getScene(), null);\n-    }\n-\n-    @Override\n-    public void addListener(InvalidationListener listener) {\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n-    }\n-\n-    @Override\n-    public void removeListener(InvalidationListener listener) {\n-        helper = ExpressionHelper.removeListener(helper, listener);\n-    }\n-\n-    @Override\n-    public void addListener(ChangeListener<? super Boolean> listener) {\n-        helper = ExpressionHelper.addListener(helper, this, listener);\n-    }\n-\n-    @Override\n-    public void removeListener(ChangeListener<? super Boolean> listener) {\n-        helper = ExpressionHelper.removeListener(helper, listener);\n-    }\n-\n-    protected void invalidate() {\n-        if (valid) {\n-            valid = false;\n-            ExpressionHelper.fireValueChangedEvent(helper);\n-        }\n-    }\n-\n-    @Override\n-    public boolean get() {\n-        if (!valid) {\n-            updateTreeShowing();\n-            valid = true;\n-        }\n-\n-        return treeShowing;\n-    }\n-\n-    private void sceneChanged(Scene oldScene, Scene newScene) {\n-        if (oldScene != null) {\n-            oldScene.windowProperty().removeListener(sceneWindowChangedListener);\n-        }\n-        if (newScene != null) {\n-            newScene.windowProperty().addListener(sceneWindowChangedListener);\n-        }\n-\n-        windowChanged(\n-            oldScene == null ? null : oldScene.getWindow(),\n-            newScene == null ? null : newScene.getWindow()\n-        );\n-    }\n-\n-    private void windowChanged(Window oldWindow, Window newWindow) {\n-        if (oldWindow != null) {\n-            oldWindow.showingProperty().removeListener(windowShowingChangedListener);\n-        }\n-        if (newWindow != null) {\n-            newWindow.showingProperty().addListener(windowShowingChangedListener);\n-        }\n-\n-        updateTreeShowing();\n-    }\n-\n-    private void updateTreeShowing() {\n-        boolean newValue = NodeHelper.isTreeShowing(node);\n-\n-        if (newValue != treeShowing) {\n-            treeShowing = newValue;\n-            invalidate();\n-        }\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/TreeShowingExpression.java","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene;\n+\n+import javafx.beans.property.ReadOnlyBooleanPropertyBase;\n+import javafx.beans.value.ChangeListener;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.stage.Window;\n+\n+\/**\n+ * Used to observe changes in tree showing status for a {@link Node}.  For a Node's tree to be showing\n+ * it must be visible, its ancestors must be visible, the node must be part of a {@link Scene} and\n+ * the scene must have a {@link Window} which is currently showing.<p>\n+ *\n+ * This class provides the exact same functionality as {@link NodeHelper#isTreeShowing(Node)} in\n+ * an observable form.\n+ *\/\n+public class TreeShowingProperty extends ReadOnlyBooleanPropertyBase {\n+    private final ChangeListener<Boolean> windowShowingChangedListener = (obs, old, current) -> updateTreeShowing();\n+    private final ChangeListener<Window> sceneWindowChangedListener = (obs, old, current) -> windowChanged(old, current);\n+    private final ChangeListener<Scene> nodeSceneChangedListener = (obs, old, current) -> sceneChanged(old, current);\n+\n+    private final Node node;\n+\n+    private boolean valid;\n+    private boolean treeShowing;\n+\n+    \/**\n+     * Constructs a new instance.\n+     *\n+     * @param node a {@link Node} for which the tree showing status should be observed, cannot be null\n+     *\/\n+    public TreeShowingProperty(Node node) {\n+        this.node = node;\n+        this.node.sceneProperty().addListener(nodeSceneChangedListener);\n+\n+        NodeHelper.treeVisibleProperty(node).addListener(windowShowingChangedListener);\n+\n+        sceneChanged(null, node.getScene());\n+    }\n+\n+    @Override\n+    public Object getBean() {\n+        return node;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"treeShowing\";\n+    }\n+\n+    \/**\n+     * Cleans up any listeners that this class may have registered on the {@link Node}\n+     * that was supplied at construction.\n+     *\/\n+    public void dispose() {\n+        node.sceneProperty().removeListener(nodeSceneChangedListener);\n+\n+        NodeHelper.treeVisibleProperty(node).removeListener(windowShowingChangedListener);\n+\n+        valid = false;  \/\/ prevents unregistration from triggering an invalidation notification\n+        sceneChanged(node.getScene(), null);\n+    }\n+\n+    protected void invalidate() {\n+        if (valid) {\n+            valid = false;\n+            fireValueChangedEvent();\n+        }\n+    }\n+\n+    @Override\n+    public boolean get() {\n+        if (!valid) {\n+            updateTreeShowing();\n+            valid = true;\n+        }\n+\n+        return treeShowing;\n+    }\n+\n+    private void sceneChanged(Scene oldScene, Scene newScene) {\n+        if (oldScene != null) {\n+            oldScene.windowProperty().removeListener(sceneWindowChangedListener);\n+        }\n+        if (newScene != null) {\n+            newScene.windowProperty().addListener(sceneWindowChangedListener);\n+        }\n+\n+        windowChanged(\n+            oldScene == null ? null : oldScene.getWindow(),\n+            newScene == null ? null : newScene.getWindow()\n+        );\n+    }\n+\n+    private void windowChanged(Window oldWindow, Window newWindow) {\n+        if (oldWindow != null) {\n+            oldWindow.showingProperty().removeListener(windowShowingChangedListener);\n+        }\n+        if (newWindow != null) {\n+            newWindow.showingProperty().addListener(windowShowingChangedListener);\n+        }\n+\n+        updateTreeShowing();\n+    }\n+\n+    private void updateTreeShowing() {\n+        boolean newValue = NodeHelper.isTreeShowing(node);\n+\n+        if (newValue != treeShowing) {\n+            treeShowing = newValue;\n+            invalidate();\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/TreeShowingProperty.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -122,1 +122,0 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n@@ -8554,1 +8553,1 @@\n-    private TreeVisiblePropertyReadOnly treeVisibleRO;\n+    private TreeVisibleProperty treeVisibleProperty;\n@@ -8567,1 +8566,3 @@\n-            ((TreeVisiblePropertyReadOnly) treeVisibleProperty()).invalidate();\n+            if (treeVisibleProperty != null) {\n+                treeVisibleProperty.invalidate();\n+            }\n@@ -8587,3 +8588,3 @@\n-    final BooleanExpression treeVisibleProperty() {\n-        if (treeVisibleRO == null) {\n-            treeVisibleRO = new TreeVisiblePropertyReadOnly();\n+    final ReadOnlyBooleanProperty treeVisibleProperty() {\n+        if (treeVisibleProperty == null) {\n+            treeVisibleProperty = new TreeVisibleProperty();\n@@ -8591,1 +8592,1 @@\n-        return treeVisibleRO;\n+        return treeVisibleProperty;\n@@ -8594,1 +8595,1 @@\n-    class TreeVisiblePropertyReadOnly extends BooleanExpression {\n+    class TreeVisibleProperty extends ReadOnlyBooleanPropertyBase {\n@@ -8596,1 +8597,0 @@\n-        private ExpressionHelper<Boolean> helper;\n@@ -8600,12 +8600,2 @@\n-        public void addListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n-        }\n-\n-        @Override\n-        public void removeListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n-        }\n-\n-        @Override\n-        public void addListener(ChangeListener<? super Boolean> listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n+        public Object getBean() {\n+            return Node.this;\n@@ -8615,2 +8605,2 @@\n-        public void removeListener(ChangeListener<? super Boolean> listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n+        public String getName() {\n+            return \"treeVisible\";\n@@ -8622,1 +8612,1 @@\n-                ExpressionHelper.fireValueChangedEvent(helper);\n+                fireValueChangedEvent();\n@@ -9754,1 +9744,1 @@\n-            extends ReadOnlyObjectProperty<Transform> {\n+            extends ReadOnlyObjectPropertyBase<Transform> {\n@@ -9761,2 +9751,0 @@\n-        private ExpressionHelper<Transform> helper;\n-\n@@ -9766,20 +9754,0 @@\n-        @Override\n-        public void addListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n-        }\n-\n-        @Override\n-        public void removeListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n-        }\n-\n-        @Override\n-        public void addListener(ChangeListener<? super Transform> listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n-        }\n-\n-        @Override\n-        public void removeListener(ChangeListener<? super Transform> listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n-        }\n-\n@@ -9813,1 +9781,1 @@\n-                ExpressionHelper.fireValueChangedEvent(helper);\n+                fireValueChangedEvent();\n@@ -9823,2 +9791,1 @@\n-            extends ReadOnlyObjectProperty<Bounds> {\n-        private ExpressionHelper<Bounds> helper;\n+            extends ReadOnlyObjectPropertyBase<Bounds> {\n@@ -9829,20 +9796,0 @@\n-        @Override\n-        public void addListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n-        }\n-\n-        @Override\n-        public void removeListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n-        }\n-\n-        @Override\n-        public void addListener(ChangeListener<? super Bounds> listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n-        }\n-\n-        @Override\n-        public void removeListener(ChangeListener<? super Bounds> listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n-        }\n-\n@@ -9862,1 +9809,1 @@\n-                ExpressionHelper.fireValueChangedEvent(helper);\n+                fireValueChangedEvent();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Node.java","additions":18,"deletions":71,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import javafx.beans.value.ChangeListener;\n@@ -64,1 +63,0 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n@@ -916,1 +914,1 @@\n-    private final class InsetsProperty extends ReadOnlyObjectProperty<Insets> {\n+    private final class InsetsProperty extends ReadOnlyObjectPropertyBase<Insets> {\n@@ -918,1 +916,0 @@\n-        private ExpressionHelper<Insets> helper = null;\n@@ -923,16 +920,0 @@\n-        @Override public void addListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n-        }\n-\n-        @Override public void removeListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n-        }\n-\n-        @Override public void addListener(ChangeListener<? super Insets> listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n-        }\n-\n-        @Override public void removeListener(ChangeListener<? super Insets> listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n-        }\n-\n@@ -943,1 +924,1 @@\n-            ExpressionHelper.fireValueChangedEvent(helper);\n+            fireValueChangedEvent();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Region.java","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n@@ -36,0 +35,1 @@\n+import javafx.beans.property.ReadOnlyDoublePropertyBase;\n@@ -49,2 +49,0 @@\n-import javafx.beans.InvalidationListener;\n-import javafx.beans.value.ChangeListener;\n@@ -1204,1 +1202,1 @@\n-    private abstract class TileSizeProperty extends ReadOnlyDoubleProperty {\n+    private abstract class TileSizeProperty extends ReadOnlyDoublePropertyBase {\n@@ -1206,1 +1204,1 @@\n-        private ExpressionHelper<Number> helper;\n+\n@@ -1227,20 +1225,0 @@\n-        @Override\n-        public void addListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n-        }\n-\n-        @Override\n-        public void removeListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n-        }\n-\n-        @Override\n-        public void addListener(ChangeListener<? super Number> listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n-        }\n-\n-        @Override\n-        public void removeListener(ChangeListener<? super Number> listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n-        }\n-\n@@ -1260,1 +1238,1 @@\n-                ExpressionHelper.fireValueChangedEvent(helper);\n+                fireValueChangedEvent();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/TilePane.java","additions":4,"deletions":26,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n@@ -44,1 +43,0 @@\n-import javafx.beans.InvalidationListener;\n@@ -47,0 +45,1 @@\n+import javafx.beans.property.ReadOnlyBooleanPropertyBase;\n@@ -48,1 +47,0 @@\n-import javafx.beans.value.ChangeListener;\n@@ -676,2 +674,1 @@\n-    private static abstract class LazyBooleanProperty\n-            extends ReadOnlyBooleanProperty {\n+    private static abstract class LazyBooleanProperty extends ReadOnlyBooleanPropertyBase {\n@@ -679,1 +676,0 @@\n-        private ExpressionHelper<Boolean> helper;\n@@ -683,20 +679,0 @@\n-        @Override\n-        public void addListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n-        }\n-\n-        @Override\n-        public void removeListener(InvalidationListener listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n-        }\n-\n-        @Override\n-        public void addListener(ChangeListener<? super Boolean> listener) {\n-            helper = ExpressionHelper.addListener(helper, this, listener);\n-        }\n-\n-        @Override\n-        public void removeListener(ChangeListener<? super Boolean> listener) {\n-            helper = ExpressionHelper.removeListener(helper, listener);\n-        }\n-\n@@ -716,1 +692,1 @@\n-                ExpressionHelper.fireValueChangedEvent(helper);\n+                fireValueChangedEvent();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/transform\/Transform.java","additions":3,"deletions":27,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import com.sun.javafx.scene.TreeShowingExpression;\n+import com.sun.javafx.scene.TreeShowingProperty;\n@@ -153,1 +153,1 @@\n-    private TreeShowingExpression treeShowingExpression;\n+    private TreeShowingProperty treeShowingProperty;\n@@ -418,2 +418,2 @@\n-            treeShowingExpression = new TreeShowingExpression(ownerNode);\n-            treeShowingExpression.addListener(weakOwnerNodeListener);\n+            treeShowingProperty = new TreeShowingProperty(ownerNode);\n+            treeShowingProperty.addListener(weakOwnerNodeListener);\n@@ -496,4 +496,4 @@\n-        if (treeShowingExpression != null) {\n-            treeShowingExpression.removeListener(weakOwnerNodeListener);\n-            treeShowingExpression.dispose();\n-            treeShowingExpression = null;\n+        if (treeShowingProperty != null) {\n+            treeShowingProperty.removeListener(weakOwnerNodeListener);\n+            treeShowingProperty.dispose();\n+            treeShowingProperty = null;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/PopupWindow.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,318 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.javafx.scene;\n-\n-import com.sun.javafx.scene.TreeShowingExpression;\n-import javafx.beans.InvalidationListener;\n-import javafx.beans.value.ChangeListener;\n-import javafx.scene.Node;\n-import javafx.scene.Parent;\n-import javafx.scene.Scene;\n-import javafx.scene.SubScene;\n-import javafx.scene.layout.StackPane;\n-import javafx.stage.Stage;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-import org.junit.runners.Parameterized.Parameters;\n-\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Supplier;\n-\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-\n-@RunWith(Parameterized.class)\n-public class TreeShowingExpressionTest {\n-    private final Parent root;\n-    private final Node node;\n-    private final TreeShowingExpression expression;\n-\n-    @Parameters\n-    public static Collection<Object[]> parameters() {\n-        Supplier<RootAndNodeToTest> supplier1 = () -> {\n-            Node node = new StackPane();\n-            return new RootAndNodeToTest(new StackPane(node), node);\n-        };\n-\n-        Supplier<RootAndNodeToTest> supplier2 = () -> {\n-            StackPane node = new StackPane();\n-            return new RootAndNodeToTest(new StackPane(new SubScene(node, 100.0, 100.0)), node);\n-        };\n-\n-        return Arrays.asList(new Object[][] { { supplier1 }, { supplier2 } });\n-    }\n-\n-    static class RootAndNodeToTest {\n-        RootAndNodeToTest(Parent root, Node nodeToTest) {\n-            this.root = root;\n-            this.nodeToTest = nodeToTest;\n-        }\n-\n-        Parent root;\n-        Node nodeToTest;\n-    }\n-\n-    public TreeShowingExpressionTest(Supplier<RootAndNodeToTest> nodeSupplier) {\n-        RootAndNodeToTest nodes = nodeSupplier.get();\n-\n-        this.root = nodes.root;\n-        this.node = nodes.nodeToTest;\n-        this.expression = new TreeShowingExpression(this.node);\n-    }\n-\n-    @Test\n-    public void nodeNotAttachedToSceneShouldNotBeShowing() {\n-        assertFalse(expression.get());\n-    }\n-\n-    @Test\n-    public void getShouldTrackChangesInShowingStateForGivenNode() {\n-        assertFalse(expression.get());  \/\/ not showing initially as not attached to a Scene\n-\n-        Scene scene = new Scene(root);\n-\n-        assertFalse(expression.get());  \/\/ not showing because Scene is not attached to a Window\n-\n-        Stage stage = new Stage();\n-        stage.setScene(scene);\n-\n-        assertFalse(expression.get());  \/\/ not showing as Window is not shown\n-\n-        stage.show();\n-\n-        assertTrue(expression.get());  \/\/ showing as Window is shown\n-\n-        stage.hide();\n-\n-        assertFalse(expression.get());  \/\/ not showing again as Window is hidden\n-    }\n-\n-    @Test\n-    public void changeListenerShouldRegisterAndUnregisterCorrectly() {\n-        AtomicReference<Boolean> state = new AtomicReference<>();\n-        ChangeListener<Boolean> listener = (obs, old, current) -> state.set(current);\n-\n-        expression.addListener(listener);\n-\n-        assertNull(state.getAndSet(null));  \/\/ no change fired so far\n-\n-        Stage stage = new Stage();\n-        stage.setScene(new Scene(root));\n-        stage.show();\n-\n-        assertTrue(state.getAndSet(null));  \/\/ expect a change indicating the node is showing now\n-\n-        expression.removeListener(listener);\n-\n-        stage.hide();\n-\n-        assertNull(state.getAndSet(null));  \/\/ no change fired as listener was unregistered\n-    }\n-\n-    @Test\n-    public void invalidationListenerShouldRegisterAndUnregisterCorrectly() {\n-        AtomicReference<Boolean> state = new AtomicReference<>();\n-        InvalidationListener listener = obs -> state.set(true);\n-\n-        expression.addListener(listener);\n-\n-        assertNull(state.getAndSet(null));  \/\/ no invalidation fired so far\n-\n-        Stage stage = new Stage();\n-        stage.setScene(new Scene(root));\n-        stage.show();\n-\n-        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as node is showing now\n-\n-        expression.get();  \/\/ make valid again\n-        expression.removeListener(listener);\n-\n-        stage.hide();\n-\n-        assertNull(state.getAndSet(null));  \/\/ expect no invalidation as listener was unregistered\n-    }\n-\n-    @Test\n-    public void changeListenerShouldTrackShowingState() {\n-        AtomicReference<Boolean> state = new AtomicReference<>();\n-\n-        expression.addListener((obs, old, current) -> state.set(current));\n-\n-        assertNull(state.getAndSet(null));  \/\/ no change fired so far\n-\n-        Scene scene = new Scene(root);\n-\n-        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no change\n-\n-        Stage stage = new Stage();\n-        stage.setWidth(100);\n-        stage.setHeight(100);\n-        stage.setScene(scene);\n-\n-        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no change\n-\n-        stage.show();\n-\n-        assertTrue(state.getAndSet(null));  \/\/ expect a change indicating the node is showing now\n-\n-        stage.setScene(null);\n-\n-        assertFalse(state.getAndSet(null));  \/\/ detaching stage from scene should fire not showing change\n-\n-        stage.setScene(scene);\n-\n-        assertTrue(state.getAndSet(null));  \/\/ reattaching stage should fire showing change\n-\n-        stage.hide();\n-\n-        assertFalse(state.getAndSet(null));  \/\/ expect a change indicating the node is no longer showing\n-\n-        Stage stage2 = new Stage();\n-        stage2.setWidth(100);\n-        stage2.setHeight(100);\n-        stage2.show();\n-        stage2.setScene(scene);\n-\n-        assertTrue(state.getAndSet(null));  \/\/ switching between invisible\/visible Scene should trigger showing change\n-\n-        stage2.hide();\n-\n-        assertFalse(state.getAndSet(null));  \/\/ hiding attached window should trigger not showing change\n-\n-        stage.show();\n-\n-        assertNull(state.getAndSet(null));  \/\/ changing visibility of unattached stage should not do anything\n-\n-        scene.setRoot(new StackPane());\n-        Scene scene2 = new Scene(root);\n-        stage.setScene(scene2);\n-\n-        assertTrue(state.getAndSet(null));  \/\/ making root part of a different visible scene should trigger showing change\n-    }\n-\n-    @Test\n-    public void invalidationListenerShouldNotifyOfChangesInShowingState() {\n-        AtomicReference<Boolean> state = new AtomicReference<>();\n-\n-        expression.addListener(obs -> state.set(true));\n-\n-        assertNull(state.getAndSet(null));  \/\/ no invalidation fired so far\n-\n-        Scene scene = new Scene(root);\n-\n-        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no invalidation\n-\n-        Stage stage = new Stage();\n-        stage.setWidth(100);\n-        stage.setHeight(100);\n-        stage.setScene(scene);\n-\n-        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no invalidation\n-\n-        stage.show();\n-\n-        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as the node is showing now\n-\n-        expression.get();  \/\/ make valid\n-        stage.setScene(null);\n-\n-        assertTrue(state.getAndSet(null));  \/\/ detaching stage from scene should fire invalidation\n-\n-        expression.get();  \/\/ make valid\n-        stage.setScene(scene);\n-\n-        assertTrue(state.getAndSet(null));  \/\/ reattaching stage should fire invalidation\n-\n-        \/\/ didn't make valid here\n-        stage.hide();\n-\n-        assertNull(state.getAndSet(null));  \/\/ expect nothing as expression still invalid\n-\n-        stage.show();\n-        expression.get();  \/\/ make valid\n-        stage.hide();\n-\n-        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as the node is no longer showing now\n-\n-        Stage stage2 = new Stage();\n-        stage2.setWidth(100);\n-        stage2.setHeight(100);\n-        stage2.show();\n-        expression.get();  \/\/ make valid\n-        stage2.setScene(scene);\n-\n-        assertTrue(state.getAndSet(null));  \/\/ switching between invisible\/visible Scene should trigger invalidation\n-\n-        expression.get();  \/\/ make valid\n-        stage2.hide();\n-\n-        assertTrue(state.getAndSet(null));  \/\/ hiding attached window should trigger invalidation\n-\n-        expression.get();  \/\/ make valid\n-        stage.show();\n-\n-        assertNull(state.getAndSet(null));  \/\/ changing visibility of unattached stage should not do anything\n-\n-        scene.setRoot(new StackPane());\n-        Scene scene2 = new Scene(root);\n-        expression.get();  \/\/ make valid\n-        stage.setScene(scene2);\n-\n-        assertTrue(state.getAndSet(null));  \/\/ making root part of a different visible scene should trigger invalidation\n-    }\n-\n-    @Test\n-    public void disposeShouldUnregisterListenersOnGivenNode() {\n-        AtomicReference<Boolean> state = new AtomicReference<>();\n-\n-        expression.addListener((obs, old, current) -> state.set(current));\n-\n-        \/\/ verify change listener works:\n-        Stage stage = new Stage();\n-        Scene scene = new Scene(root);\n-        stage.setScene(scene);\n-        stage.show();\n-        assertTrue(state.getAndSet(null));\n-\n-        expression.dispose();\n-\n-        \/\/ verify change listener no longer responds:\n-        stage.hide();\n-        assertNull(state.getAndSet(null));\n-\n-        \/\/ another check:\n-        Stage stage2 = new Stage();\n-        stage2.setWidth(100);\n-        stage2.setHeight(100);\n-        stage2.show();\n-        scene.setRoot(new StackPane());\n-        stage2.setScene(new Scene(root));\n-        assertNull(state.getAndSet(null));\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/TreeShowingExpressionTest.java","additions":0,"deletions":318,"binary":false,"changes":318,"status":"deleted"},{"patch":"@@ -0,0 +1,318 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.scene;\n+\n+import com.sun.javafx.scene.TreeShowingProperty;\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.value.ChangeListener;\n+import javafx.scene.Node;\n+import javafx.scene.Parent;\n+import javafx.scene.Scene;\n+import javafx.scene.SubScene;\n+import javafx.scene.layout.StackPane;\n+import javafx.stage.Stage;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(Parameterized.class)\n+public class TreeShowingPropertyTest {\n+    private final Parent root;\n+    private final Node node;\n+    private final TreeShowingProperty property;\n+\n+    @Parameters\n+    public static Collection<Object[]> parameters() {\n+        Supplier<RootAndNodeToTest> supplier1 = () -> {\n+            Node node = new StackPane();\n+            return new RootAndNodeToTest(new StackPane(node), node);\n+        };\n+\n+        Supplier<RootAndNodeToTest> supplier2 = () -> {\n+            StackPane node = new StackPane();\n+            return new RootAndNodeToTest(new StackPane(new SubScene(node, 100.0, 100.0)), node);\n+        };\n+\n+        return Arrays.asList(new Object[][] { { supplier1 }, { supplier2 } });\n+    }\n+\n+    static class RootAndNodeToTest {\n+        RootAndNodeToTest(Parent root, Node nodeToTest) {\n+            this.root = root;\n+            this.nodeToTest = nodeToTest;\n+        }\n+\n+        Parent root;\n+        Node nodeToTest;\n+    }\n+\n+    public TreeShowingPropertyTest(Supplier<RootAndNodeToTest> nodeSupplier) {\n+        RootAndNodeToTest nodes = nodeSupplier.get();\n+\n+        this.root = nodes.root;\n+        this.node = nodes.nodeToTest;\n+        this.property = new TreeShowingProperty(this.node);\n+    }\n+\n+    @Test\n+    public void nodeNotAttachedToSceneShouldNotBeShowing() {\n+        assertFalse(property.get());\n+    }\n+\n+    @Test\n+    public void getShouldTrackChangesInShowingStateForGivenNode() {\n+        assertFalse(property.get());  \/\/ not showing initially as not attached to a Scene\n+\n+        Scene scene = new Scene(root);\n+\n+        assertFalse(property.get());  \/\/ not showing because Scene is not attached to a Window\n+\n+        Stage stage = new Stage();\n+        stage.setScene(scene);\n+\n+        assertFalse(property.get());  \/\/ not showing as Window is not shown\n+\n+        stage.show();\n+\n+        assertTrue(property.get());  \/\/ showing as Window is shown\n+\n+        stage.hide();\n+\n+        assertFalse(property.get());  \/\/ not showing again as Window is hidden\n+    }\n+\n+    @Test\n+    public void changeListenerShouldRegisterAndUnregisterCorrectly() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+        ChangeListener<Boolean> listener = (obs, old, current) -> state.set(current);\n+\n+        property.addListener(listener);\n+\n+        assertNull(state.getAndSet(null));  \/\/ no change fired so far\n+\n+        Stage stage = new Stage();\n+        stage.setScene(new Scene(root));\n+        stage.show();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect a change indicating the node is showing now\n+\n+        property.removeListener(listener);\n+\n+        stage.hide();\n+\n+        assertNull(state.getAndSet(null));  \/\/ no change fired as listener was unregistered\n+    }\n+\n+    @Test\n+    public void invalidationListenerShouldRegisterAndUnregisterCorrectly() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+        InvalidationListener listener = obs -> state.set(true);\n+\n+        property.addListener(listener);\n+\n+        assertNull(state.getAndSet(null));  \/\/ no invalidation fired so far\n+\n+        Stage stage = new Stage();\n+        stage.setScene(new Scene(root));\n+        stage.show();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as node is showing now\n+\n+        property.get();  \/\/ make valid again\n+        property.removeListener(listener);\n+\n+        stage.hide();\n+\n+        assertNull(state.getAndSet(null));  \/\/ expect no invalidation as listener was unregistered\n+    }\n+\n+    @Test\n+    public void changeListenerShouldTrackShowingState() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+\n+        property.addListener((obs, old, current) -> state.set(current));\n+\n+        assertNull(state.getAndSet(null));  \/\/ no change fired so far\n+\n+        Scene scene = new Scene(root);\n+\n+        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no change\n+\n+        Stage stage = new Stage();\n+        stage.setWidth(100);\n+        stage.setHeight(100);\n+        stage.setScene(scene);\n+\n+        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no change\n+\n+        stage.show();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect a change indicating the node is showing now\n+\n+        stage.setScene(null);\n+\n+        assertFalse(state.getAndSet(null));  \/\/ detaching stage from scene should fire not showing change\n+\n+        stage.setScene(scene);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ reattaching stage should fire showing change\n+\n+        stage.hide();\n+\n+        assertFalse(state.getAndSet(null));  \/\/ expect a change indicating the node is no longer showing\n+\n+        Stage stage2 = new Stage();\n+        stage2.setWidth(100);\n+        stage2.setHeight(100);\n+        stage2.show();\n+        stage2.setScene(scene);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ switching between invisible\/visible Scene should trigger showing change\n+\n+        stage2.hide();\n+\n+        assertFalse(state.getAndSet(null));  \/\/ hiding attached window should trigger not showing change\n+\n+        stage.show();\n+\n+        assertNull(state.getAndSet(null));  \/\/ changing visibility of unattached stage should not do anything\n+\n+        scene.setRoot(new StackPane());\n+        Scene scene2 = new Scene(root);\n+        stage.setScene(scene2);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ making root part of a different visible scene should trigger showing change\n+    }\n+\n+    @Test\n+    public void invalidationListenerShouldNotifyOfChangesInShowingState() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+\n+        property.addListener(obs -> state.set(true));\n+\n+        assertNull(state.getAndSet(null));  \/\/ no invalidation fired so far\n+\n+        Scene scene = new Scene(root);\n+\n+        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no invalidation\n+\n+        Stage stage = new Stage();\n+        stage.setWidth(100);\n+        stage.setHeight(100);\n+        stage.setScene(scene);\n+\n+        assertNull(state.getAndSet(null));  \/\/ attaching to an invisible Scene fires no invalidation\n+\n+        stage.show();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as the node is showing now\n+\n+        property.get();  \/\/ make valid\n+        stage.setScene(null);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ detaching stage from scene should fire invalidation\n+\n+        property.get();  \/\/ make valid\n+        stage.setScene(scene);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ reattaching stage should fire invalidation\n+\n+        \/\/ didn't make valid here\n+        stage.hide();\n+\n+        assertNull(state.getAndSet(null));  \/\/ expect nothing as expression still invalid\n+\n+        stage.show();\n+        property.get();  \/\/ make valid\n+        stage.hide();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ expect an invalidation as the node is no longer showing now\n+\n+        Stage stage2 = new Stage();\n+        stage2.setWidth(100);\n+        stage2.setHeight(100);\n+        stage2.show();\n+        property.get();  \/\/ make valid\n+        stage2.setScene(scene);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ switching between invisible\/visible Scene should trigger invalidation\n+\n+        property.get();  \/\/ make valid\n+        stage2.hide();\n+\n+        assertTrue(state.getAndSet(null));  \/\/ hiding attached window should trigger invalidation\n+\n+        property.get();  \/\/ make valid\n+        stage.show();\n+\n+        assertNull(state.getAndSet(null));  \/\/ changing visibility of unattached stage should not do anything\n+\n+        scene.setRoot(new StackPane());\n+        Scene scene2 = new Scene(root);\n+        property.get();  \/\/ make valid\n+        stage.setScene(scene2);\n+\n+        assertTrue(state.getAndSet(null));  \/\/ making root part of a different visible scene should trigger invalidation\n+    }\n+\n+    @Test\n+    public void disposeShouldUnregisterListenersOnGivenNode() {\n+        AtomicReference<Boolean> state = new AtomicReference<>();\n+\n+        property.addListener((obs, old, current) -> state.set(current));\n+\n+        \/\/ verify change listener works:\n+        Stage stage = new Stage();\n+        Scene scene = new Scene(root);\n+        stage.setScene(scene);\n+        stage.show();\n+        assertTrue(state.getAndSet(null));\n+\n+        property.dispose();\n+\n+        \/\/ verify change listener no longer responds:\n+        stage.hide();\n+        assertNull(state.getAndSet(null));\n+\n+        \/\/ another check:\n+        Stage stage2 = new Stage();\n+        stage2.setWidth(100);\n+        stage2.setHeight(100);\n+        stage2.show();\n+        scene.setRoot(new StackPane());\n+        stage2.setScene(new Scene(root));\n+        assertNull(state.getAndSet(null));\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/TreeShowingPropertyTest.java","additions":318,"deletions":0,"binary":false,"changes":318,"status":"added"}]}