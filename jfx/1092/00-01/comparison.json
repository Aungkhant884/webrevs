{"files":[{"patch":"@@ -47,1 +47,0 @@\n-import javafx.beans.property.StringPropertyBase;\n@@ -174,0 +173,3 @@\n+            if (content.length() > 0) {\n+                text.textIsNull = false;\n+            }\n@@ -1400,21 +1402,22 @@\n-    \/**\n-     * A slightly modified standard String property for holding the text.\n-     * It is kept in sync with the Content instance when it is not bound.\n-     * A flag prevents a change from propagating more than once; for example,\n-     * when the Content instance is changed, it updates the property but\n-     * then doesn't again update itself, and vice versa, when the property\n-     * is changed, it updates the Content instance, but not again itself.\n-     *\n-     * This handles null values set programmatically correctly without extra\n-     * effort.\n-     *\n-     * The property allows unidirectional and bidirectional bindings. When\n-     * a unidirectional binding is present, the Content instance\n-     * can't be changed and the control effectively becomes read only.\n-     *\/\n-    private class TextProperty extends StringPropertyBase {\n-        private boolean propagate = true;\n-\n-        @Override\n-        public Object getBean() {\n-            return TextInputControl.this;\n+    \/\/ It can be bound, in which case we will force it to be an eager\n+    \/\/ binding so that we update the content eagerly\n+    \/\/ It can be bidirectionally bound, which basically will just work\n+    \/\/ If somebody changes the content directly, it will be notified and\n+    \/\/ send an invalidation event.\n+    private class TextProperty extends StringProperty {\n+        \/\/ This is used only when the property is bound\n+        private ObservableValue<? extends String> observable = null;\n+        \/\/ Added to the observable when bound\n+        private InvalidationListener listener = null;\n+        \/\/ Used for event handling\n+        private ExpressionHelper<String> helper = null;\n+        \/\/ The developer my set the Text property to null. Although\n+        \/\/ the Content must be given an empty String, we must still\n+        \/\/ treat the value as though it were null, so that a subsequent\n+        \/\/ getText() will return null.\n+        private boolean textIsNull = false;\n+\n+        @Override public String get() {\n+            \/\/ Since we force eager binding and content is always up to date,\n+            \/\/ we just need to get it from content and not through the binding\n+            return textIsNull ? null : content.get();\n@@ -1423,27 +1426,3 @@\n-        @Override\n-        public String getName() {\n-            return \"text\";\n-        }\n-\n-        @Override\n-        protected void invalidated() {\n-\n-            \/*\n-             * If this property is invalidated, and the value wasn't supplied by\n-             * the Content instance (propagate = true), then update the Content\n-             * instance with the property's current value.\n-             *\n-             * This keeps the Content instance always in sync with this property.\n-             *\/\n-\n-            if (propagate) {\n-                String value = get();\n-\n-                propagate = false;\n-\n-                try {\n-                    doSet(value);\n-                }\n-                finally {\n-                    propagate = true;\n-                }\n+        @Override public void set(String value) {\n+            if (isBound()) {\n+                throw new java.lang.RuntimeException(\"A bound value cannot be set.\");\n@@ -1451,0 +1430,2 @@\n+            doSet(value);\n+            markInvalid();\n@@ -1458,2 +1439,3 @@\n-            if (!isBound() && propagate) {\n-                propagate = false;\n+            markInvalid();\n+            notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);\n+        }\n@@ -1461,6 +1443,9 @@\n-                try {\n-                    set(content.get());\n-                    notifyAccessibleAttributeChanged(AccessibleAttribute.TEXT);\n-                }\n-                finally {\n-                    propagate = true;\n+        @Override public void bind(ObservableValue<? extends String> observable) {\n+            if (observable == null) {\n+                throw new NullPointerException(\"Cannot bind to null\");\n+            }\n+            if (!observable.equals(this.observable)) {\n+                unbind();\n+                this.observable = observable;\n+                if (listener == null) {\n+                    listener = new Listener();\n@@ -1468,0 +1453,11 @@\n+                this.observable.addListener(listener);\n+                markInvalid();\n+                doSet(observable.getValue());\n+            }\n+        }\n+\n+        @Override public void unbind() {\n+            if (observable != null) {\n+                doSet(observable.getValue());\n+                observable.removeListener(listener);\n+                observable = null;\n@@ -1471,0 +1467,36 @@\n+        @Override public boolean isBound() {\n+            return observable != null;\n+        }\n+\n+        @Override public void addListener(InvalidationListener listener) {\n+            helper = ExpressionHelper.addListener(helper, this, listener);\n+        }\n+\n+        @Override public void removeListener(InvalidationListener listener) {\n+            helper = ExpressionHelper.removeListener(helper, listener);\n+        }\n+\n+        @Override public void addListener(ChangeListener<? super String> listener) {\n+            helper = ExpressionHelper.addListener(helper, this, listener);\n+        }\n+\n+        @Override public void removeListener(ChangeListener<? super String> listener) {\n+            helper = ExpressionHelper.removeListener(helper, listener);\n+        }\n+\n+        @Override public Object getBean() {\n+            return TextInputControl.this;\n+        }\n+\n+        @Override public String getName() {\n+            return \"text\";\n+        }\n+\n+        private void fireValueChangedEvent() {\n+            ExpressionHelper.fireValueChangedEvent(helper);\n+        }\n+\n+        private void markInvalid() {\n+            fireValueChangedEvent();\n+        }\n+\n@@ -1480,2 +1512,4 @@\n-        private void doSet(String currentValue) {\n-            String value = currentValue == null ? \"\" : currentValue;\n+        private void doSet(String value) {\n+            \/\/ Guard against the null value.\n+            textIsNull = value == null;\n+            if (value == null) value = \"\";\n@@ -1483,3 +1517,1 @@\n-            if (!filterAndSet(value)) {\n-                return;\n-            }\n+            if (!filterAndSet(value)) return;\n@@ -1499,0 +1531,12 @@\n+\n+        private class Listener implements InvalidationListener {\n+            @Override\n+            public void invalidated(Observable valueModel) {\n+                \/\/ We now need to force it to be eagerly recomputed\n+                \/\/ because we need to push these changes to the\n+                \/\/ content model. Because changing the model ends\n+                \/\/ up calling invalidate and markInvalid, the\n+                \/\/ listeners will all be notified.\n+                doSet(observable.getValue());\n+            }\n+        }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TextInputControl.java","additions":106,"deletions":62,"binary":false,"changes":168,"status":"modified"}]}