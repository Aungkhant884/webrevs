{"files":[{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.javafx.scene.control;\n+\n+\/**\n+ * A functional interface that provides a {@link #disconnect()} method.\n+ * <p>\n+ * Original code is re-licensed to Oracle by the author.\n+ * https:\/\/github.com\/andy-goryachev\/FxTextEditor\/blob\/master\/src\/goryachev\/common\/util\/Disconnectable.java\n+ * Copyright © 2021-2022 Andy Goryachev <andy@goryachev.com>\n+ *\/\n+@FunctionalInterface\n+public interface IDisconnectable {\n+    \/**\n+     * Disconnects what has been connected. May be called multiple times, only the\n+     * first invocation actually disconnects.\n+     *\/\n+    public void disconnect();\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/IDisconnectable.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,1 @@\n+@Deprecated \/\/ TODO use ListenerHelper instead\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/LambdaMultiplePropertyChangeListenerHandler.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,383 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.javafx.scene.control;\n+\n+import java.util.ArrayList;\n+import java.util.function.Consumer;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.Observable;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+import javafx.concurrent.Task;\n+import javafx.event.Event;\n+import javafx.event.EventHandler;\n+import javafx.event.EventType;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.TableColumnBase;\n+import javafx.scene.control.TreeItem;\n+import javafx.scene.transform.Transform;\n+import javafx.stage.Window;\n+\n+\/**\n+ * This class provides convenience methods for adding various listeners, both strong and weak,\n+ * as well as a single {@link #disconnect()} method to remove all listeners.\n+ * <p>\n+ * There are two usage patterns:\n+ * <ul>\n+ * <li>Client code registers a number of listeners and removes them all at once via {@link #disconnect()} call.\n+ * <li>Client code registers a number of listeners and removes one via its {@link IDisconnectable} instance.\n+ * <\/ul>\n+ * <p>\n+ * Original code is re-licensed to Oracle by the author.\n+ * https:\/\/github.com\/andy-goryachev\/FxTextEditor\/blob\/master\/src\/goryachev\/fx\/FxDisconnector.java\n+ * Copyright © 2021-2022 Andy Goryachev <andy@goryachev.com>\n+ *\/\n+public class ListenerHelper implements IDisconnectable {\n+    private final ArrayList<IDisconnectable> items = new ArrayList<>(4);\n+    private static final Object KEY = new Object();\n+\n+    public ListenerHelper() {\n+    }\n+\n+    public static ListenerHelper get(Node n) {\n+        Object x = n.getProperties().get(KEY);\n+        if (x instanceof ListenerHelper h) {\n+            return h;\n+        }\n+        ListenerHelper d = new ListenerHelper();\n+        n.getProperties().put(KEY, d);\n+        return d;\n+    }\n+\n+    public static void disconnect(Node n) {\n+        Object x = n.getProperties().remove(KEY);\n+        if (x instanceof ListenerHelper h) {\n+            h.disconnect();\n+        }\n+    }\n+\n+    public IDisconnectable addDisconnectable(Runnable r) {\n+        IDisconnectable d = new IDisconnectable() {\n+            @Override\n+            public void disconnect() {\n+                items.remove(this);\n+                r.run();\n+            }\n+        };\n+        items.add(d);\n+        return d;\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        for (int i = items.size() - 1; i >= 0; i--) {\n+            IDisconnectable d = items.remove(i);\n+            d.disconnect();\n+        }\n+    }\n+\n+    \/\/ change listeners\n+\n+    public IDisconnectable addChangeListener(Runnable callback, ObservableValue<?>... props) {\n+        return addChangeListener(callback, false, props);\n+    }\n+\n+    public IDisconnectable addChangeListener(Runnable onChange, boolean fireImmediately, ObservableValue<?>... props) {\n+        if (onChange == null) {\n+            throw new NullPointerException(\"onChange must not be null.\");\n+        }\n+\n+        ChLi li = new ChLi() {\n+            @Override\n+            public void disconnect() {\n+                for (ObservableValue p : props) {\n+                    p.removeListener(this);\n+                }\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void changed(ObservableValue p, Object oldValue, Object newValue) {\n+                onChange.run();\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        for (ObservableValue p : props) {\n+            p.addListener(li);\n+        }\n+\n+        if (fireImmediately) {\n+            onChange.run();\n+        }\n+\n+        return li;\n+    }\n+\n+    public <T> IDisconnectable addChangeListener(ObservableValue<T> prop, ChangeListener<T> listener) {\n+        return addChangeListener(prop, false, listener);\n+    }\n+\n+    public <T> IDisconnectable addChangeListener(ObservableValue<T> prop, boolean fireImmediately, ChangeListener<T> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        IDisconnectable d = new IDisconnectable() {\n+            @Override\n+            public void disconnect() {\n+                prop.removeListener(listener);\n+                items.remove(this);\n+            }\n+        };\n+\n+        items.add(d);\n+        prop.addListener(listener);\n+\n+        if (fireImmediately) {\n+            T v = prop.getValue();\n+            listener.changed(prop, null, v);\n+        }\n+\n+        return d;\n+    }\n+\n+    public <T> IDisconnectable addChangeListener(ObservableValue<T> prop, Consumer<T> callback) {\n+        return addChangeListener(prop, false, callback);\n+    }\n+\n+    public <T> IDisconnectable addChangeListener(ObservableValue<T> prop, boolean fireImmediately, Consumer<T> callback) {\n+        if (callback == null) {\n+            throw new NullPointerException(\"Callback must be specified.\");\n+        }\n+\n+        ChLi<T> d = new ChLi<T>() {\n+            @Override\n+            public void disconnect() {\n+                prop.removeListener(this);\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void changed(ObservableValue<? extends T> observable, T oldValue, T newValue) {\n+                callback.accept(newValue);\n+            }\n+        };\n+\n+        items.add(d);\n+        prop.addListener(d);\n+\n+        if (fireImmediately) {\n+            T v = prop.getValue();\n+            callback.accept(v);\n+        }\n+\n+        return d;\n+    }\n+\n+    \/\/ invalidation listeners\n+\n+    public IDisconnectable addInvalidationListener(Runnable callback, ObservableValue<?>... props) {\n+        return addInvalidationListener(callback, false, props);\n+    }\n+\n+    public IDisconnectable addInvalidationListener(Runnable callback, boolean fireImmediately, ObservableValue<?>... props) {\n+        if (callback == null) {\n+            throw new NullPointerException(\"Callback must be specified.\");\n+        }\n+\n+        InLi li = new InLi() {\n+            @Override\n+            public void disconnect() {\n+                for (ObservableValue p : props) {\n+                    p.removeListener(this);\n+                }\n+                items.remove(this);\n+            }\n+\n+            @Override\n+            public void invalidated(Observable p) {\n+                callback.run();\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        for (ObservableValue p : props) {\n+            p.addListener(li);\n+        }\n+\n+        if (fireImmediately) {\n+            callback.run();\n+        }\n+\n+        return li;\n+    }\n+\n+    public <T> IDisconnectable addInvalidationListener(ObservableValue<T> prop, InvalidationListener listener) {\n+        return addInvalidationListener(prop, false, listener);\n+    }\n+\n+    public <T> IDisconnectable addInvalidationListener(ObservableValue<T> prop, boolean fireImmediately, InvalidationListener listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        IDisconnectable d = new IDisconnectable() {\n+            @Override\n+            public void disconnect() {\n+                prop.removeListener(listener);\n+                items.remove(this);\n+            }\n+        };\n+\n+        items.add(d);\n+        prop.addListener(listener);\n+\n+        if (fireImmediately) {\n+            listener.invalidated(prop);\n+        }\n+\n+        return d;\n+    }\n+\n+    \/\/ list change listeners\n+\n+    public <T> IDisconnectable addListChangeListener(ObservableList<T> list, ListChangeListener<T> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        IDisconnectable d = new IDisconnectable() {\n+            @Override\n+            public void disconnect() {\n+                list.removeListener(listener);\n+                items.remove(this);\n+            }\n+        };\n+\n+        items.add(d);\n+        list.addListener(listener);\n+\n+        return d;\n+    }\n+\n+    \/\/ event handlers\n+\n+    public <T extends Event> IDisconnectable addEventHandler(Object x, EventType<T> t, EventHandler<T> h) {\n+\n+        \/\/ we really need an interface here ... \"HasEventHandlers\"\n+        IDisconnectable d = addDisconnectable(() -> {\n+            if (x instanceof Node n) {\n+                n.removeEventHandler(t, h);\n+            } else if (x instanceof Window y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof Scene y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof MenuItem y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof TreeItem y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof TableColumnBase y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof Transform y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof Task y) {\n+                y.removeEventHandler(t, h);\n+            }\n+        });\n+\n+        if (x instanceof Node y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof Window y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof Scene y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof MenuItem y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof TreeItem y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof TableColumnBase y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof Transform y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof Task y) {\n+            y.addEventHandler(t, h);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot add event handler to \" + x);\n+        }\n+\n+        return d;\n+    }\n+\n+    \/\/ event filters\n+\n+    public <T extends Event> IDisconnectable addEventFilter(Object x, EventType<T> t, EventHandler<T> h) {\n+        \/\/ we really need an interface here ... \"HasEventFilters\"\n+        IDisconnectable d = addDisconnectable(() -> {\n+            if (x instanceof Node n) {\n+                n.removeEventFilter(t, h);\n+            } else if (x instanceof Window y) {\n+                y.removeEventFilter(t, h);\n+            } else if (x instanceof Scene y) {\n+                y.removeEventFilter(t, h);\n+            } else if (x instanceof Transform y) {\n+                y.removeEventFilter(t, h);\n+            } else if (x instanceof Task y) {\n+                y.removeEventFilter(t, h);\n+            }\n+        });\n+\n+        if (x instanceof Node y) {\n+            y.addEventFilter(t, h);\n+        } else if (x instanceof Window y) {\n+            y.addEventFilter(t, h);\n+        } else if (x instanceof Scene y) {\n+            y.addEventFilter(t, h);\n+        } else if (x instanceof Transform y) {\n+            y.addEventFilter(t, h);\n+        } else if (x instanceof Task y) {\n+            y.addEventFilter(t, h);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot add event filter to \" + x);\n+        }\n+\n+        return d;\n+    }\n+\n+    \/\/\n+\n+    protected static abstract class ChLi<T> implements IDisconnectable, ChangeListener<T> { }\n+\n+    protected static abstract class InLi implements IDisconnectable, InvalidationListener { }\n+\n+    protected static abstract class LiChLi<T> implements IDisconnectable, ListChangeListener<T> { }\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/ListenerHelper.java","additions":383,"deletions":0,"binary":false,"changes":383,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -829,0 +829,1 @@\n+    @Deprecated \/\/ WARNING: creates a memory leak\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/skin\/Utils.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;\n-\n@@ -51,0 +49,3 @@\n+import com.sun.javafx.scene.control.LambdaMultiplePropertyChangeListenerHandler;\n+import com.sun.javafx.scene.control.ListenerHelper;\n+\n@@ -85,0 +86,1 @@\n+    @Deprecated \/\/ replace with listenerHelper\n@@ -87,0 +89,1 @@\n+    private ListenerHelper listenerHelper;\n@@ -161,0 +164,4 @@\n+        if (listenerHelper != null) {\n+            listenerHelper.disconnect();\n+        }\n+\n@@ -210,0 +217,11 @@\n+    \/**\n+     * Returns the skin's instance of {@link ListenerHelper}, creating it if necessary.\n+     *\n+     * @since 20\n+     *\/\n+    protected ListenerHelper listenerHelper() {\n+        if (listenerHelper == null) {\n+            listenerHelper = new ListenerHelper();\n+        }\n+        return listenerHelper;\n+    }\n@@ -222,0 +240,1 @@\n+    \/\/ TODO I would like to deprecate and remove these methods, and replace them by listenerHelper().add**()\n@@ -283,1 +302,0 @@\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/SkinBase.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,1 +28,13 @@\n-import static com.sun.javafx.FXPermissions.ACCESS_WINDOW_LIST_PERMISSION;\n+import java.lang.ref.Reference;\n+import java.lang.ref.WeakReference;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.WeakHashMap;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n@@ -30,6 +42,0 @@\n-import com.sun.javafx.scene.traversal.Direction;\n-import javafx.css.converter.EnumConverter;\n-import javafx.css.converter.SizeConverter;\n-import com.sun.javafx.scene.control.MenuBarButton;\n-import com.sun.javafx.scene.control.skin.Utils;\n-import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n@@ -51,0 +57,2 @@\n+import javafx.css.converter.EnumConverter;\n+import javafx.css.converter.SizeConverter;\n@@ -53,1 +61,0 @@\n-import javafx.event.WeakEventHandler;\n@@ -69,0 +76,1 @@\n+import javafx.scene.input.KeyCode;\n@@ -74,0 +82,2 @@\n+import javafx.stage.Window;\n+import javafx.util.Pair;\n@@ -75,12 +85,1 @@\n-import static javafx.scene.input.KeyCode.*;\n-\n-import java.lang.ref.Reference;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.WeakHashMap;\n-\n+import com.sun.javafx.FXPermissions;\n@@ -91,0 +90,5 @@\n+import com.sun.javafx.scene.control.IDisconnectable;\n+import com.sun.javafx.scene.control.ListenerHelper;\n+import com.sun.javafx.scene.control.MenuBarButton;\n+import com.sun.javafx.scene.traversal.Direction;\n+import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n@@ -92,8 +96,0 @@\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-\n-import javafx.stage.Window;\n-import javafx.util.Pair;\n-\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -119,1 +115,1 @@\n-            ACCESS_WINDOW_LIST_PERMISSION);\n+            FXPermissions.ACCESS_WINDOW_LIST_PERMISSION);\n@@ -145,8 +141,0 @@\n-    private WeakEventHandler<KeyEvent> weakSceneKeyEventHandler;\n-    private WeakEventHandler<MouseEvent> weakSceneMouseEventHandler;\n-    private WeakEventHandler<KeyEvent> weakSceneAltKeyEventHandler;\n-    private WeakChangeListener<Boolean> weakWindowFocusListener;\n-    private WeakChangeListener<Window> weakWindowSceneListener;\n-    private EventHandler<KeyEvent> keyEventHandler;\n-    private EventHandler<KeyEvent> altKeyEventHandler;\n-    private EventHandler<MouseEvent> mouseEventHandler;\n@@ -154,0 +142,1 @@\n+    private WeakChangeListener<Boolean> weakMenuBarFocusedPropertyListener;\n@@ -156,0 +145,3 @@\n+    private WeakChangeListener<Boolean> weakMenuVisibilityChangeListener;\n+    private ListenerHelper sceneListenerHelper;\n+    private IDisconnectable windowFocusHelper;\n@@ -158,1 +150,0 @@\n-\n@@ -215,1 +206,0 @@\n-\n@@ -236,69 +226,0 @@\n-        \/\/ Key navigation\n-        keyEventHandler = event -> {\n-            \/\/ process right left and may be tab key events\n-            if (focusedMenu != null) {\n-                switch (event.getCode()) {\n-                    case LEFT: {\n-                        boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;\n-                        if (control.getScene().getWindow().isFocused()) {\n-                            if (openMenu != null && !openMenu.isShowing()) {\n-                                if (isRTL) {\n-                                    moveToMenu(Direction.NEXT, false); \/\/ just move the selection bar\n-                                } else {\n-                                    moveToMenu(Direction.PREVIOUS, false); \/\/ just move the selection bar\n-                                }\n-                                event.consume();\n-                                return;\n-                            }\n-                            if (isRTL) {\n-                                moveToMenu(Direction.NEXT, true);\n-                            } else {\n-                                moveToMenu(Direction.PREVIOUS, true);\n-                            }\n-                        }\n-                        event.consume();\n-                        break;\n-                    }\n-                    case RIGHT:\n-                    {\n-                        boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;\n-                        if (control.getScene().getWindow().isFocused()) {\n-                            if (openMenu != null && !openMenu.isShowing()) {\n-                                if (isRTL) {\n-                                    moveToMenu(Direction.PREVIOUS, false); \/\/ just move the selection bar\n-                                } else {\n-                                    moveToMenu(Direction.NEXT, false); \/\/ just move the selection bar\n-                                }\n-                                event.consume();\n-                                return;\n-                            }\n-                            if (isRTL) {\n-                                moveToMenu(Direction.PREVIOUS, true);\n-                            } else {\n-                                moveToMenu(Direction.NEXT, true);\n-                            }\n-                        }\n-                        event.consume();\n-                        break;\n-                    }\n-                    case DOWN:\n-                    \/\/case SPACE:\n-                    \/\/case ENTER:\n-                        \/\/ RT-18859: Doing nothing for space and enter\n-                        if (control.getScene().getWindow().isFocused()) {\n-                            if (focusedMenuIndex != -1) {\n-                                Menu menuToOpen = getSkinnable().getMenus().get(focusedMenuIndex);\n-                                showMenu(menuToOpen, true);\n-                                event.consume();\n-                            }\n-                        }\n-                        break;\n-                    case ESCAPE:\n-                        unSelectMenus();\n-                        event.consume();\n-                        break;\n-                default:\n-                    break;\n-                }\n-            }\n-        };\n@@ -315,12 +236,0 @@\n-         };\n-        weakSceneKeyEventHandler = new WeakEventHandler<KeyEvent>(keyEventHandler);\n-        Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n-            scene.addEventFilter(KeyEvent.KEY_PRESSED, weakSceneKeyEventHandler);\n-        });\n-\n-        \/\/ When we click else where in the scene - menu selection should be cleared.\n-        mouseEventHandler = t -> {\n-            Bounds containerScreenBounds = container.localToScreen(container.getLayoutBounds());\n-            if (containerScreenBounds == null || !containerScreenBounds.contains(t.getScreenX(), t.getScreenY())) {\n-                unSelectMenus();\n-            }\n@@ -328,25 +237,1 @@\n-        weakSceneMouseEventHandler = new WeakEventHandler<MouseEvent>(mouseEventHandler);\n-        Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n-            scene.addEventFilter(MouseEvent.MOUSE_CLICKED, weakSceneMouseEventHandler);\n-        });\n-\n-        weakWindowFocusListener = new WeakChangeListener<Boolean>((ov, t, t1) -> {\n-            if (!t1) {\n-              unSelectMenus();\n-            }\n-        });\n-        \/\/ When the parent window looses focus - menu selection should be cleared\n-        Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n-            if (scene.getWindow() != null) {\n-                scene.getWindow().focusedProperty().addListener(weakWindowFocusListener);\n-            } else {\n-                ChangeListener<Window> sceneWindowListener = (observable, oldValue, newValue) -> {\n-                    if (oldValue != null)\n-                        oldValue.focusedProperty().removeListener(weakWindowFocusListener);\n-                    if (newValue != null)\n-                        newValue.focusedProperty().addListener(weakWindowFocusListener);\n-                };\n-                weakWindowSceneListener = new WeakChangeListener<>(sceneWindowListener);\n-                scene.windowProperty().addListener(weakWindowSceneListener);\n-            }\n-        });\n+        weakMenuBarFocusedPropertyListener = new WeakChangeListener(menuBarFocusedPropertyListener);\n@@ -357,0 +242,1 @@\n+        weakMenuVisibilityChangeListener = new WeakChangeListener(menuVisibilityChangeListener);\n@@ -359,1 +245,1 @@\n-        control.getMenus().addListener((ListChangeListener<Menu>) c -> {\n+        listenerHelper().addListChangeListener(control.getMenus(), (v) -> {\n@@ -364,1 +250,1 @@\n-            control.useSystemMenuBarProperty().addListener(valueModel -> {\n+            listenerHelper().addInvalidationListener(control.useSystemMenuBarProperty(), (v) -> {\n@@ -391,26 +277,0 @@\n-        altKeyEventHandler = e -> {\n-            if (e.getEventType() == KeyEvent.KEY_PRESSED) {\n-                \/\/ Clear menu selection when ALT is pressed by itself\n-                altKeyPressed = false;\n-                if (e.getCode() == ALT && !e.isConsumed()) {\n-                    if (focusedMenuIndex == -1) {\n-                        altKeyPressed = true;\n-                    }\n-                    unSelectMenus();\n-                }\n-            } else if (e.getEventType() == KeyEvent.KEY_RELEASED) {\n-                \/\/ Put focus on the first menu when ALT is released\n-                \/\/ directly after being pressed by itself\n-                if (altKeyPressed && e.getCode() == ALT && !e.isConsumed()) {\n-                    firstMenuRunnable.run();\n-                }\n-                altKeyPressed = false;\n-            }\n-        };\n-        weakSceneAltKeyEventHandler = new WeakEventHandler<>(altKeyEventHandler);\n-\n-        Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n-            scene.getAccelerators().put(acceleratorKeyCombo, firstMenuRunnable);\n-            scene.addEventHandler(KeyEvent.ANY, weakSceneAltKeyEventHandler);\n-        });\n-\n@@ -424,12 +284,4 @@\n-        control.sceneProperty().addListener((ov, t, t1) -> {\n-            \/\/ remove event handlers \/ filters from the old scene (t)\n-            if (t != null) {\n-                if (weakSceneKeyEventHandler != null) {\n-                    t.removeEventFilter(KeyEvent.KEY_PRESSED, weakSceneKeyEventHandler);\n-                }\n-                if (weakSceneMouseEventHandler != null) {\n-                    t.removeEventFilter(MouseEvent.MOUSE_CLICKED, weakSceneMouseEventHandler);\n-                }\n-                if (weakSceneAltKeyEventHandler != null) {\n-                    t.removeEventHandler(KeyEvent.ANY, weakSceneAltKeyEventHandler);\n-                }\n+        listenerHelper().addChangeListener(control.sceneProperty(), true, (scene) -> {\n+            if (sceneListenerHelper != null) {\n+                sceneListenerHelper.disconnect();\n+                sceneListenerHelper = null;\n@@ -438,9 +290,122 @@\n-            \/**\n-             * remove the f10 accelerator from the old scene\n-             * add it to the new scene\n-             *\/\n-            if (t != null) {\n-                t.getAccelerators().remove(acceleratorKeyCombo);\n-            }\n-            if (t1 != null ) {\n-                t1.getAccelerators().put(acceleratorKeyCombo, firstMenuRunnable);\n+            if (scene != null ) {\n+                sceneListenerHelper = new ListenerHelper();\n+\n+                \/\/ Key navigation\n+                sceneListenerHelper.addEventFilter(scene, KeyEvent.KEY_PRESSED, (ev) -> {\n+                    \/\/ process right left and may be tab key events\n+                    if (focusedMenu != null) {\n+                        switch (ev.getCode()) {\n+                            case LEFT: {\n+                                boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;\n+                                if (control.getScene().getWindow().isFocused()) {\n+                                    if (openMenu != null && !openMenu.isShowing()) {\n+                                        if (isRTL) {\n+                                            moveToMenu(Direction.NEXT, false); \/\/ just move the selection bar\n+                                        } else {\n+                                            moveToMenu(Direction.PREVIOUS, false); \/\/ just move the selection bar\n+                                        }\n+                                        ev.consume();\n+                                        return;\n+                                    }\n+                                    if (isRTL) {\n+                                        moveToMenu(Direction.NEXT, true);\n+                                    } else {\n+                                        moveToMenu(Direction.PREVIOUS, true);\n+                                    }\n+                                }\n+                                ev.consume();\n+                                break;\n+                            }\n+                            case RIGHT:\n+                            {\n+                                boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;\n+                                if (control.getScene().getWindow().isFocused()) {\n+                                    if (openMenu != null && !openMenu.isShowing()) {\n+                                        if (isRTL) {\n+                                            moveToMenu(Direction.PREVIOUS, false); \/\/ just move the selection bar\n+                                        } else {\n+                                            moveToMenu(Direction.NEXT, false); \/\/ just move the selection bar\n+                                        }\n+                                        ev.consume();\n+                                        return;\n+                                    }\n+                                    if (isRTL) {\n+                                        moveToMenu(Direction.PREVIOUS, true);\n+                                    } else {\n+                                        moveToMenu(Direction.NEXT, true);\n+                                    }\n+                                }\n+                                ev.consume();\n+                                break;\n+                            }\n+                            case DOWN:\n+                            \/\/case SPACE:\n+                            \/\/case ENTER:\n+                                \/\/ RT-18859: Doing nothing for space and enter\n+                                if (control.getScene().getWindow().isFocused()) {\n+                                    if (focusedMenuIndex != -1) {\n+                                        Menu menuToOpen = getSkinnable().getMenus().get(focusedMenuIndex);\n+                                        showMenu(menuToOpen, true);\n+                                        ev.consume();\n+                                    }\n+                                }\n+                                break;\n+                            case ESCAPE:\n+                                unSelectMenus();\n+                                ev.consume();\n+                                break;\n+                        default:\n+                            break;\n+                        }\n+                    }\n+                });\n+\n+                \/\/ When we click else where in the scene - menu selection should be cleared.\n+                sceneListenerHelper.addEventFilter(scene, MouseEvent.MOUSE_CLICKED, (ev) -> {\n+                    Bounds containerScreenBounds = container.localToScreen(container.getLayoutBounds());\n+                    if ((containerScreenBounds == null) || !containerScreenBounds.contains(ev.getScreenX(), ev.getScreenY())) {\n+                        unSelectMenus();\n+                    }\n+                });\n+\n+                \/\/ When the parent window looses focus - menu selection should be cleared\n+                sceneListenerHelper.addChangeListener(scene.windowProperty(), true, (sr, oldw, w) -> {\n+                    if (windowFocusHelper != null) {\n+                        windowFocusHelper.disconnect();\n+                        windowFocusHelper = null;\n+                    }\n+\n+                    if (w != null) {\n+                        windowFocusHelper = sceneListenerHelper.addChangeListener(w.focusedProperty(), true, (s, p, focused) -> {\n+                            if (!focused) {\n+                                unSelectMenus();\n+                            }\n+                        });\n+                    }\n+                });\n+\n+                sceneListenerHelper.addEventFilter(scene, KeyEvent.ANY, (ev) -> {\n+                    \/\/ Clear menu selection when ALT is pressed by itself\n+                    if (ev.getEventType() == KeyEvent.KEY_PRESSED) {\n+                        altKeyPressed = false;\n+                        if (ev.getCode() == KeyCode.ALT && !ev.isConsumed()) {\n+                            if (focusedMenuIndex == -1) {\n+                                altKeyPressed = true;\n+                            }\n+                            unSelectMenus();\n+                        }\n+                    } else if (ev.getEventType() == KeyEvent.KEY_RELEASED) {\n+                        \/\/ Put focus on the first menu when ALT is released\n+                        \/\/ directly after being pressed by itself\n+                        if (altKeyPressed && ev.getCode() == KeyCode.ALT && !ev.isConsumed()) {\n+                            firstMenuRunnable.run();\n+                        }\n+                        altKeyPressed = false;\n+                    }\n+                });\n+\n+                \/\/ F10 accelerator\n+                scene.getAccelerators().put(acceleratorKeyCombo, firstMenuRunnable);\n+                sceneListenerHelper.addDisconnectable(() -> {\n+                    scene.getAccelerators().remove(acceleratorKeyCombo);\n+                });\n@@ -686,1 +651,12 @@\n-    @Override public void dispose() {\n+    @Override\n+    public void dispose() {\n+        if (getSkinnable() == null) {\n+            return;\n+        }\n+\n+        if (sceneListenerHelper != null) {\n+            sceneListenerHelper.disconnect();\n+            sceneListenerHelper = null;\n+        }\n+\n+        cleanUpListeners();\n@@ -688,0 +664,2 @@\n+        getChildren().remove(container);\n+\n@@ -824,2 +802,3 @@\n-    private void rebuildUI() {\n-        getSkinnable().focusedProperty().removeListener(menuBarFocusedPropertyListener);\n+    private void cleanUpListeners() {\n+        getSkinnable().focusedProperty().removeListener(weakMenuBarFocusedPropertyListener);\n+\n@@ -830,1 +809,1 @@\n-            m.visibleProperty().removeListener(menuVisibilityChangeListener);\n+            m.visibleProperty().removeListener(weakMenuVisibilityChangeListener);\n@@ -832,0 +811,1 @@\n+\n@@ -852,0 +832,1 @@\n+\n@@ -853,0 +834,4 @@\n+    }\n+\n+    private void rebuildUI() {\n+        cleanUpListeners();\n@@ -930,1 +915,2 @@\n-        getSkinnable().focusedProperty().addListener(menuBarFocusedPropertyListener);\n+        getSkinnable().focusedProperty().addListener(weakMenuBarFocusedPropertyListener);\n+\n@@ -933,1 +919,1 @@\n-            menu.visibleProperty().addListener(menuVisibilityChangeListener);\n+            menu.visibleProperty().addListener(weakMenuVisibilityChangeListener);\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/MenuBarSkin.java","additions":186,"deletions":200,"binary":false,"changes":386,"status":"modified"},{"patch":"@@ -0,0 +1,408 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.scene.control;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+import javafx.concurrent.Task;\n+import javafx.event.EventTarget;\n+import javafx.scene.Group;\n+import javafx.scene.Scene;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TreeItem;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.layout.Region;\n+import javafx.scene.transform.Scale;\n+import javafx.stage.Stage;\n+\n+import org.junit.Test;\n+\n+import com.sun.javafx.event.EventUtil;\n+import com.sun.javafx.scene.control.ListenerHelper;\n+\n+import test.com.sun.javafx.scene.control.infrastructure.MouseEventGenerator;\n+\n+\/**\n+ * Tests ListenerHelper utility class.\n+ *\/\n+public class TestListenerHelper {\n+    @Test\n+    public void testStaticDisconnect() {\n+        AtomicInteger ct = new AtomicInteger();\n+        Group node = new Group();\n+        ListenerHelper h = ListenerHelper.get(node);\n+        assertNotNull(h);\n+\n+        h.addDisconnectable(() -> {\n+            ct.incrementAndGet();\n+        });\n+\n+        ListenerHelper.disconnect(node);\n+        assertEquals(1, ct.get());\n+    }\n+\n+    \/\/ change listeners\n+\n+    @Test\n+    public void testChangeListener_MultipleProperties() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p1 = new SimpleStringProperty();\n+        SimpleStringProperty p2 = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addChangeListener(() -> ct.incrementAndGet(), p1, p2);\n+\n+        p1.set(\"1\");\n+        p2.set(\"2\");\n+        assertEquals(2, ct.get());\n+\n+        h.disconnect();\n+\n+        p1.set(\"3\");\n+        p2.set(\"4\");\n+        assertEquals(2, ct.get());\n+    }\n+\n+    @Test\n+    public void testChangeListener_MultipleProperties_FireImmediately() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p1 = new SimpleStringProperty();\n+        SimpleStringProperty p2 = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addChangeListener(() -> ct.incrementAndGet(), true, p1, p2);\n+\n+        p1.set(\"1\");\n+        p2.set(\"2\");\n+        assertEquals(3, ct.get());\n+\n+        h.disconnect();\n+\n+        p1.set(\"3\");\n+        p2.set(\"4\");\n+        assertEquals(3, ct.get());\n+    }\n+\n+    @Test\n+    public void testChangeListener_Plain() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addChangeListener(p, (s, old, cur) -> ct.incrementAndGet());\n+\n+        p.set(\"1\");\n+        assertEquals(1, ct.get());\n+\n+        h.disconnect();\n+\n+        p.set(\"2\");\n+        assertEquals(1, ct.get());\n+    }\n+\n+    @Test\n+    public void testChangeListener_Plain_FireImmediately() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addChangeListener(p, true, (s, old, cur) -> ct.incrementAndGet());\n+\n+        p.set(\"1\");\n+        assertEquals(2, ct.get());\n+\n+        h.disconnect();\n+\n+        p.set(\"2\");\n+        assertEquals(2, ct.get());\n+    }\n+\n+    @Test\n+    public void testChangeListener_Callback() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addChangeListener(p, (cur) -> ct.incrementAndGet());\n+\n+        p.set(\"1\");\n+        assertEquals(1, ct.get());\n+\n+        h.disconnect();\n+\n+        p.set(\"2\");\n+        assertEquals(1, ct.get());\n+    }\n+\n+    @Test\n+    public void testChangeListener_Callback_FireImmediately() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addChangeListener(p, true, (cur) -> ct.incrementAndGet());\n+\n+        p.set(\"1\");\n+        assertEquals(2, ct.get());\n+\n+        h.disconnect();\n+\n+        p.set(\"2\");\n+        assertEquals(2, ct.get());\n+    }\n+\n+    \/\/ invalidation listeners\n+\n+    @Test\n+    public void testInvalidationListener_MultipleProperties() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p1 = new SimpleStringProperty();\n+        SimpleStringProperty p2 = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addInvalidationListener(() -> ct.incrementAndGet(), p1, p2);\n+\n+        p1.set(\"1\");\n+        p2.set(\"2\");\n+        assertEquals(2, ct.get());\n+\n+        h.disconnect();\n+\n+        p1.set(\"3\");\n+        p2.set(\"4\");\n+        assertEquals(2, ct.get());\n+    }\n+\n+    @Test\n+    public void testInvalidationListener_MultipleProperties_FireImmediately() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p1 = new SimpleStringProperty();\n+        SimpleStringProperty p2 = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addInvalidationListener(() -> ct.incrementAndGet(), true, p1, p2);\n+\n+        p1.set(\"1\");\n+        p2.set(\"2\");\n+        assertEquals(3, ct.get());\n+\n+        h.disconnect();\n+\n+        p1.set(\"3\");\n+        p2.set(\"4\");\n+        assertEquals(3, ct.get());\n+    }\n+\n+    @Test\n+    public void testInvalidationListener_Plain() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addInvalidationListener(p, (x) -> ct.incrementAndGet());\n+\n+        p.set(\"1\");\n+        assertEquals(1, ct.get());\n+\n+        h.disconnect();\n+\n+        p.set(\"2\");\n+        assertEquals(1, ct.get());\n+    }\n+\n+    @Test\n+    public void testInvalidationListener_Plain_FireImmediately() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addInvalidationListener(p, true, (x) -> ct.incrementAndGet());\n+\n+        p.set(\"1\");\n+        assertEquals(2, ct.get());\n+\n+        h.disconnect();\n+\n+        p.set(\"2\");\n+        assertEquals(2, ct.get());\n+    }\n+\n+    @Test\n+    public void testInvalidationListener_Callback() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addInvalidationListener(p, (cur) -> ct.incrementAndGet());\n+\n+        p.set(\"1\");\n+        assertEquals(1, ct.get());\n+\n+        h.disconnect();\n+\n+        p.set(\"2\");\n+        assertEquals(1, ct.get());\n+    }\n+\n+    @Test\n+    public void testInvalidationListener_Callback_FireImmediately() {\n+        ListenerHelper h = new ListenerHelper();\n+        SimpleStringProperty p = new SimpleStringProperty();\n+        AtomicInteger ct = new AtomicInteger();\n+\n+        h.addInvalidationListener(p, true, (cur) -> ct.incrementAndGet());\n+\n+        p.set(\"1\");\n+        assertEquals(2, ct.get());\n+\n+        h.disconnect();\n+\n+        p.set(\"2\");\n+        assertEquals(2, ct.get());\n+    }\n+\n+    \/\/ list change listeners\n+\n+    @Test\n+    public void testListChangeListener() {\n+        ListenerHelper h = new ListenerHelper();\n+        ObservableList<String> list = FXCollections.observableArrayList();\n+        AtomicInteger ct = new AtomicInteger();\n+        ListChangeListener<String> li = (ch) -> ct.incrementAndGet();\n+\n+        h.addListChangeListener(list, li);\n+\n+        list.add(\"1\");\n+        assertEquals(1, ct.get());\n+\n+        h.disconnect();\n+\n+        list.add(\"2\");\n+        assertEquals(1, ct.get());\n+    }\n+\n+    \/\/ event handlers\n+\n+    @Test\n+    public void testEventHandler() {\n+        EventTarget[] items = eventHandlerTargets();\n+\n+        for (EventTarget item : items) {\n+            ListenerHelper h = new ListenerHelper();\n+            AtomicInteger ct = new AtomicInteger();\n+\n+            h.addEventHandler(item, MouseEvent.ANY, (ev) -> ct.incrementAndGet());\n+\n+            MouseEvent ev = MouseEventGenerator.generateMouseEvent(MouseEvent.MOUSE_CLICKED, 0, 0);\n+            EventUtil.fireEvent(ev, item);\n+\n+            assertEquals(1, ct.get());\n+\n+            h.disconnect();\n+\n+            EventUtil.fireEvent(ev, item);\n+            assertEquals(1, ct.get());\n+        }\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testEventHandlerCheck() {\n+        ListenerHelper h = new ListenerHelper();\n+        h.addEventHandler(new Object(), MouseEvent.ANY, (ev) -> { throw new Error(); });\n+    }\n+\n+    \/\/ event filters\n+\n+    @Test\n+    public void testEventFilter() {\n+        EventTarget[] items = eventHandlerFilters();\n+\n+        for (EventTarget item : items) {\n+            ListenerHelper h = new ListenerHelper();\n+            AtomicInteger ct = new AtomicInteger();\n+\n+            h.addEventFilter(item, MouseEvent.ANY, (ev) -> ct.incrementAndGet());\n+\n+            MouseEvent ev = MouseEventGenerator.generateMouseEvent(MouseEvent.MOUSE_CLICKED, 0, 0);\n+            EventUtil.fireEvent(ev, item);\n+\n+            assertEquals(1, ct.get());\n+\n+            h.disconnect();\n+\n+            EventUtil.fireEvent(ev, item);\n+            assertEquals(1, ct.get());\n+        }\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testEventFilterCheck() {\n+        ListenerHelper h = new ListenerHelper();\n+        h.addEventFilter(new Object(), MouseEvent.ANY, (ev) -> { throw new Error(); });\n+    }\n+\n+    \/\/\n+\n+    protected EventTarget[] eventHandlerTargets() {\n+        return new EventTarget[] {\n+            new Region(),\n+            new Stage(),\n+            new Scene(new Group()),\n+            new MenuItem(),\n+            new TreeItem(),\n+            new TableColumn(),\n+            new Scale(),\n+            new Task() {\n+                @Override\n+                protected Object call() throws Exception {\n+                    return null;\n+                }\n+            }\n+        };\n+    }\n+\n+    protected EventTarget[] eventHandlerFilters() {\n+        return new EventTarget[] {\n+            new Region(),\n+            new Stage(),\n+            new Scene(new Group()),\n+            new Scale(),\n+            new Task() {\n+                @Override\n+                protected Object call() throws Exception {\n+                    return null;\n+                }\n+            }\n+        };\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TestListenerHelper.java","additions":408,"deletions":0,"binary":false,"changes":408,"status":"added"},{"patch":"@@ -28,0 +28,13 @@\n+import static javafx.scene.control.ControlShim.installDefaultSkin;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.asArrays;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.attemptGC;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.createControl;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.getControlClasses;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.replaceSkin;\n+\n@@ -32,12 +45,0 @@\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-\n-import com.sun.javafx.tk.Toolkit;\n-\n-import static javafx.scene.control.ControlShim.*;\n-import static org.junit.Assert.*;\n-import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.*;\n-\n@@ -51,1 +52,0 @@\n-import javafx.scene.control.MenuBar;\n@@ -67,0 +67,8 @@\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.sun.javafx.tk.Toolkit;\n+\n@@ -87,0 +95,2 @@\n+        WeakReference<?> weakRef = new WeakReference<>(skin);\n+\n@@ -89,0 +99,16 @@\n+        skin = null;\n+        Toolkit.getToolkit().firePulse();\n+\n+        attemptGC(weakRef);\n+        assertNull(\"Unused Skin must be gc'ed\", weakRef.get());\n+    }\n+\n+    \/**\n+     * default skin -> set another instance of default skin,\n+     * with scene property set.\n+     *\/\n+    @Test\n+    public void testMemoryLeakSameSkinClassWithScene() {\n+        showControl(control, true);\n+        installDefaultSkin(control);\n+        Skin<?> skin = control.getSkin();\n@@ -90,0 +116,3 @@\n+\n+        installDefaultSkin(control);\n+\n@@ -91,0 +120,2 @@\n+        Toolkit.getToolkit().firePulse();\n+\n@@ -120,2 +151,2 @@\n-        \/\/ FIXME: JDK-8265406 - fragile test pattern\n-        WeakReference<?> weakRef = new WeakReference<>(replaceSkin(control));\n+        Skin<?> replacedSkin = replaceSkin(control);\n+        WeakReference<?> weakRef = new WeakReference<>(replacedSkin);\n@@ -123,0 +154,25 @@\n+\n+        \/\/ beware: this is important - we might get false reds without!\n+        replacedSkin = null;\n+        Toolkit.getToolkit().firePulse();\n+\n+        attemptGC(weakRef);\n+        assertEquals(\"Skin must be gc'ed\", null, weakRef.get());\n+    }\n+\n+    \/**\n+     * default skin -> set alternative,\n+     * with scene property set\n+     *\/\n+    @Test\n+    public void testMemoryLeakAlternativeSkinWithScene() {\n+        showControl(control, true);\n+        installDefaultSkin(control);\n+        Skin<?> replacedSkin = replaceSkin(control);\n+        WeakReference<?> weakRef = new WeakReference<>(replacedSkin);\n+        assertNotNull(weakRef.get());\n+\n+        \/\/ beware: this is important - we might get false reds without!\n+        replacedSkin = null;\n+        Toolkit.getToolkit().firePulse();\n+\n@@ -136,0 +192,1 @@\n+\n@@ -137,1 +194,0 @@\n-        Toolkit.getToolkit().firePulse();\n@@ -139,0 +195,2 @@\n+        Toolkit.getToolkit().firePulse();\n+\n@@ -169,1 +227,0 @@\n-                MenuBar.class,\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/SkinMemoryLeakTest.java","additions":74,"deletions":17,"binary":false,"changes":91,"status":"modified"}]}