{"files":[{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.javafx.scene.control;\n+\n+\/**\n+ * A functional interface that provides a {@link #disconnect()} method.\n+ * <p>\n+ * Original code is re-licensed to Oracle by the author.\n+ * https:\/\/github.com\/andy-goryachev\/FxTextEditor\/blob\/master\/src\/goryachev\/common\/util\/Disconnectable.java\n+ * Copyright © 2021-2022 Andy Goryachev <andy@goryachev.com>\n+ *\/\n+@FunctionalInterface\n+public interface IDisconnectable {\n+    \/**\n+     * Disconnects what has been connected. May be called multiple times, only the\n+     * first invocation actually disconnects.\n+     *\/\n+    public void disconnect();\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/IDisconnectable.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,1 @@\n+@Deprecated \/\/ TODO use ListenerHelper instead\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/LambdaMultiplePropertyChangeListenerHandler.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,635 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.javafx.scene.control;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.Observable;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+import javafx.concurrent.Task;\n+import javafx.event.Event;\n+import javafx.event.EventHandler;\n+import javafx.event.EventType;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.TableColumnBase;\n+import javafx.scene.control.TreeItem;\n+import javafx.scene.transform.Transform;\n+import javafx.stage.Window;\n+\n+\/**\n+ * This class provides convenience methods for adding various listeners, both strong and weak,\n+ * as well as a single {@link #disconnect()} method to remove all listeners.\n+ * <p>\n+ * There are two usage patterns:\n+ * <ul>\n+ * <li>Client code registers a number of listeners and removes them all at once via {@link #disconnect()} call.\n+ * <li>Client code registers a number of listeners and removes one via its {@link IDisconnectable} instance.\n+ * <\/ul>\n+ * <p>\n+ * Original code is re-licensed to Oracle by the author.\n+ * https:\/\/github.com\/andy-goryachev\/FxTextEditor\/blob\/master\/src\/goryachev\/fx\/FxDisconnector.java\n+ * Copyright © 2021-2022 Andy Goryachev <andy@goryachev.com>\n+ *\/\n+public class ListenerHelper implements IDisconnectable {\n+    private final ArrayList<IDisconnectable> items = new ArrayList<>(4);\n+    private static final Object KEY = new Object();\n+\n+    public ListenerHelper() {\n+    }\n+\n+    public static ListenerHelper get(Node n) {\n+        Object x = n.getProperties().get(KEY);\n+        if (x instanceof ListenerHelper h) {\n+            return h;\n+        }\n+        ListenerHelper d = new ListenerHelper();\n+        n.getProperties().put(KEY, d);\n+        return d;\n+    }\n+\n+    public static void disconnect(Node n) {\n+        Object x = n.getProperties().remove(KEY);\n+        if (x instanceof ListenerHelper h) {\n+            h.disconnect();\n+        }\n+    }\n+\n+    public IDisconnectable addDisconnectable(IDisconnectable d) {\n+        items.add(d);\n+        return d;\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        for (int i = items.size() - 1; i >= 0; i--) {\n+            IDisconnectable d = items.remove(i);\n+            d.disconnect();\n+        }\n+    }\n+\n+    \/\/ change listeners\n+\n+    public IDisconnectable addChangeListener(Runnable callback, ObservableValue<?>... props) {\n+        return addChangeListener(callback, false, props);\n+    }\n+\n+    public IDisconnectable addChangeListener(Runnable onChange, boolean fireImmediately, ObservableValue<?>... props) {\n+        if (onChange == null) {\n+            throw new NullPointerException(\"onChange must not be null.\");\n+        }\n+\n+        ChLi li = new ChLi() {\n+            @Override\n+            public void disconnect() {\n+                for (ObservableValue p : props) {\n+                    p.removeListener(this);\n+                }\n+            }\n+\n+            @Override\n+            public void changed(ObservableValue p, Object oldValue, Object newValue) {\n+                onChange.run();\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        for (ObservableValue p : props) {\n+            p.addListener(li);\n+        }\n+\n+        if (fireImmediately) {\n+            onChange.run();\n+        }\n+\n+        return li;\n+    }\n+\n+    public <T> IDisconnectable addChangeListener(ObservableValue<T> prop, ChangeListener<T> listener) {\n+        return addChangeListener(prop, false, listener);\n+    }\n+\n+    public <T> IDisconnectable addChangeListener(ObservableValue<T> prop, boolean fireImmediately, ChangeListener<T> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        IDisconnectable d = new IDisconnectable() {\n+            @Override\n+            public void disconnect() {\n+                prop.removeListener(listener);\n+            }\n+        };\n+\n+        items.add(d);\n+        prop.addListener(listener);\n+\n+        if (fireImmediately) {\n+            T v = prop.getValue();\n+            listener.changed(prop, null, v);\n+        }\n+\n+        return d;\n+    }\n+\n+    public IDisconnectable addWeakChangeListener(Runnable onChange, ObservableValue<?>... props) {\n+        return addWeakChangeListener(onChange, false, props);\n+    }\n+\n+    public IDisconnectable addWeakChangeListener(Runnable onChange, boolean fireImmediately, ObservableValue<?>... props) {\n+        if (onChange == null) {\n+            throw new NullPointerException(\"onChange must not be null.\");\n+        }\n+\n+        ChLi li = new ChLi() {\n+            WeakReference<Runnable> ref = new WeakReference(onChange);\n+\n+            @Override\n+            public void disconnect() {\n+                for (ObservableValue p : props) {\n+                    p.removeListener(this);\n+                }\n+            }\n+\n+            @Override\n+            public void changed(ObservableValue p, Object oldValue, Object newValue) {\n+                Runnable r = ref.get();\n+                if (r == null) {\n+                    disconnect();\n+                } else {\n+                    r.run();\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        for (ObservableValue p : props) {\n+            p.addListener(li);\n+        }\n+\n+        if (fireImmediately) {\n+            onChange.run();\n+        }\n+\n+        return li;\n+    }\n+\n+    public <T> IDisconnectable addWeakChangeListener(ObservableValue<T> prop, ChangeListener<T> listener) {\n+        return addChangeListener(prop, false, listener);\n+    }\n+\n+    public <T> IDisconnectable addWeakChangeListener(ObservableValue<T> prop, boolean fireImmediately, ChangeListener<T> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        ChLi<T> d = new ChLi<T>() {\n+            WeakReference<ChangeListener<T>> ref = new WeakReference<>(listener);\n+\n+            @Override\n+            public void disconnect() {\n+                prop.removeListener(this);\n+            }\n+\n+            @Override\n+            public void changed(ObservableValue<? extends T> p, T oldValue, T newValue) {\n+                ChangeListener<T> li = ref.get();\n+                if (li == null) {\n+                    disconnect();\n+                } else {\n+                    li.changed(p, oldValue, newValue);\n+                }\n+            }\n+        };\n+\n+        items.add(d);\n+        prop.addListener(d);\n+\n+        if (fireImmediately) {\n+            T v = prop.getValue();\n+            listener.changed(prop, null, v);\n+        }\n+\n+        return d;\n+    }\n+\n+    \/\/ invalidation listeners\n+\n+    public IDisconnectable addInvalidationListener(Runnable callback, ObservableValue<?>... props) {\n+        return addInvalidationListener(callback, false, props);\n+    }\n+\n+    public IDisconnectable addInvalidationListener(Runnable callback, boolean fireImmediately, ObservableValue<?>... props) {\n+        if (callback == null) {\n+            throw new NullPointerException(\"Callback must be specified.\");\n+        }\n+\n+        InLi li = new InLi() {\n+            @Override\n+            public void disconnect() {\n+                for (ObservableValue p : props) {\n+                    p.removeListener(this);\n+                }\n+            }\n+\n+            @Override\n+            public void invalidated(Observable p) {\n+                callback.run();\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        for (ObservableValue p : props) {\n+            p.addListener(li);\n+        }\n+\n+        if (fireImmediately) {\n+            callback.run();\n+        }\n+\n+        return li;\n+    }\n+\n+    public <T> IDisconnectable addInvalidationListener(ObservableValue<T> prop, InvalidationListener listener) {\n+        return addInvalidationListener(prop, false, listener);\n+    }\n+\n+    public <T> IDisconnectable addInvalidationListener(ObservableValue<T> prop, boolean fireImmediately, InvalidationListener listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        IDisconnectable d = new IDisconnectable() {\n+            @Override\n+            public void disconnect() {\n+                prop.removeListener(listener);\n+            }\n+        };\n+\n+        items.add(d);\n+        prop.addListener(listener);\n+\n+        if (fireImmediately) {\n+            listener.invalidated(prop);\n+        }\n+\n+        return d;\n+    }\n+\n+    public IDisconnectable addWeakInvalidationListener(Runnable onChange, ObservableValue<?>... props) {\n+        return addWeakInvalidationListener(onChange, false, props);\n+    }\n+\n+    public IDisconnectable addWeakInvalidationListener(Runnable onChange, boolean fireImmediately, ObservableValue<?>... props) {\n+        if (onChange == null) {\n+            throw new NullPointerException(\"onChange must not be null.\");\n+        }\n+\n+        InLi li = new InLi() {\n+            WeakReference<Runnable> ref = new WeakReference(onChange);\n+\n+            @Override\n+            public void disconnect() {\n+                for (ObservableValue p : props) {\n+                    p.removeListener(this);\n+                }\n+            }\n+\n+            @Override\n+            public void invalidated(Observable p) {\n+                Runnable r = ref.get();\n+                if (r == null) {\n+                    disconnect();\n+                } else {\n+                    r.run();\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        for (ObservableValue p : props) {\n+            p.addListener(li);\n+        }\n+\n+        if (fireImmediately) {\n+            onChange.run();\n+        }\n+\n+        return li;\n+    }\n+\n+    public IDisconnectable addWeakInvalidationListener(ObservableValue<?> prop, InvalidationListener listener) {\n+        return addWeakInvalidationListener(prop, false, listener);\n+    }\n+\n+    public IDisconnectable addWeakInvalidationListener(ObservableValue<?> prop, boolean fireImmediately, InvalidationListener listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        InLi d = new InLi() {\n+            WeakReference<InvalidationListener> ref = new WeakReference<>(listener);\n+\n+            @Override\n+            public void disconnect() {\n+                prop.removeListener(this);\n+            }\n+\n+            @Override\n+            public void invalidated(Observable p) {\n+                InvalidationListener li = ref.get();\n+                if (li == null) {\n+                    disconnect();\n+                } else {\n+                    li.invalidated(p);\n+                }\n+            }\n+        };\n+\n+        items.add(d);\n+        prop.addListener(d);\n+\n+        if (fireImmediately) {\n+            listener.invalidated(prop);\n+        }\n+\n+        return d;\n+    }\n+\n+    \/\/ list change listeners\n+\n+    public <T> IDisconnectable addListChangeListener(ObservableList<T> list, ListChangeListener<T> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        IDisconnectable d = new IDisconnectable() {\n+            @Override\n+            public void disconnect() {\n+                list.removeListener(listener);\n+            }\n+        };\n+\n+        items.add(d);\n+        list.addListener(listener);\n+\n+        return d;\n+    }\n+\n+    public <T> IDisconnectable addWeakListChangeListener(ObservableList<T> list, ListChangeListener<T> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        LiChLi<T> li = new LiChLi<T>() {\n+            WeakReference<ListChangeListener<T>> ref = new WeakReference<>(listener);\n+\n+            @Override\n+            public void disconnect() {\n+                list.removeListener(this);\n+            }\n+\n+            @Override\n+            public void onChanged(Change<? extends T> ch) {\n+                ListChangeListener<T> li = ref.get();\n+                if (li == null) {\n+                    disconnect();\n+                } else {\n+                    li.onChanged(ch);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+        list.addListener(li);\n+\n+        return li;\n+    }\n+\n+    \/\/ event handlers\n+\n+    public <T extends Event> IDisconnectable addEventHandler(Object x, EventType<T> t, EventHandler<T> h) {\n+\n+        \/\/ we really need an interface here ... \"HasEventHandlers\"\n+        IDisconnectable d = addDisconnectable(() -> {\n+            if (x instanceof Node n) {\n+                n.removeEventHandler(t, h);\n+            } else if (x instanceof Window y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof Scene y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof MenuItem y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof TreeItem y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof TableColumnBase y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof Transform y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof Task y) {\n+                y.removeEventHandler(t, h);\n+            }\n+        });\n+\n+        if (x instanceof Node y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof Window y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof Scene y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof MenuItem y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof TreeItem y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof TableColumnBase y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof Transform y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof Task y) {\n+            y.addEventHandler(t, h);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot add event handler to \" + x);\n+        }\n+\n+        return d;\n+    }\n+\n+    public <T extends Event> IDisconnectable addWeakEventHandler(Object x, EventType<T> t, EventHandler<T> h) {\n+        WeHa<T> li = new WeHa<T>(h) {\n+            @Override\n+            public void disconnect() {\n+                if (x instanceof Node n) {\n+                    n.removeEventHandler(t, this);\n+                } else if (x instanceof Window y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof Scene y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof MenuItem y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof TreeItem y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof TableColumnBase y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof Transform y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof Task y) {\n+                    y.removeEventHandler(t, this);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        if (x instanceof Node y) {\n+            y.addEventHandler(t, li);\n+        } else if (x instanceof Window y) {\n+            y.addEventHandler(t, li);\n+        } else if (x instanceof Scene y) {\n+            y.addEventHandler(t, li);\n+        } else if (x instanceof MenuItem y) {\n+            y.addEventHandler(t, li);\n+        } else if (x instanceof TreeItem y) {\n+            y.addEventHandler(t, li);\n+        } else if (x instanceof TableColumnBase y) {\n+            y.addEventHandler(t, li);\n+        } else if (x instanceof Transform y) {\n+            y.addEventHandler(t, li);\n+        } else if (x instanceof Task y) {\n+            y.addEventHandler(t, li);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot add weak event handler to \" + x);\n+        }\n+\n+        return li;\n+    }\n+\n+    \/\/ event filters\n+\n+    public <T extends Event> IDisconnectable addEventFilter(Object x, EventType<T> t, EventHandler<T> h) {\n+        \/\/ we really need an interface here ... \"HasEventFilters\"\n+        IDisconnectable d = addDisconnectable(() -> {\n+            if (x instanceof Node n) {\n+                n.removeEventFilter(t, h);\n+            } else if (x instanceof Window y) {\n+                y.removeEventFilter(t, h);\n+            } else if (x instanceof Scene y) {\n+                y.removeEventFilter(t, h);\n+            } else if (x instanceof Transform y) {\n+                y.removeEventFilter(t, h);\n+            } else if (x instanceof Task y) {\n+                y.removeEventFilter(t, h);\n+            }\n+        });\n+\n+        if (x instanceof Node y) {\n+            y.addEventFilter(t, h);\n+        } else if (x instanceof Window y) {\n+            y.addEventFilter(t, h);\n+        } else if (x instanceof Scene y) {\n+            y.addEventFilter(t, h);\n+        } else if (x instanceof Transform y) {\n+            y.addEventFilter(t, h);\n+        } else if (x instanceof Task y) {\n+            y.addEventFilter(t, h);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot add event filter to \" + x);\n+        }\n+\n+        return d;\n+    }\n+\n+    public <T extends Event> IDisconnectable addWeakEventFilter(Object x, EventType<T> t, EventHandler<? super T> h) {\n+        WeHa<T> li = new WeHa<T>(h) {\n+            @Override\n+            public void disconnect() {\n+                if (x instanceof Node n) {\n+                    n.removeEventFilter(t, this);\n+                } else if (x instanceof Window y) {\n+                    y.removeEventFilter(t, this);\n+                } else if (x instanceof Scene y) {\n+                    y.removeEventFilter(t, this);\n+                } else if (x instanceof Transform y) {\n+                    y.removeEventFilter(t, this);\n+                } else if (x instanceof Task y) {\n+                    y.removeEventFilter(t, this);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        if (x instanceof Node y) {\n+            y.addEventFilter(t, li);\n+        } else if (x instanceof Window y) {\n+            y.addEventFilter(t, li);\n+        } else if (x instanceof Scene y) {\n+            y.addEventFilter(t, li);\n+        } else if (x instanceof Transform y) {\n+            y.addEventFilter(t, li);\n+        } else if (x instanceof Task y) {\n+            y.addEventFilter(t, li);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot add weak event filter to \" + x);\n+        }\n+\n+        return li;\n+    }\n+\n+    \/\/\n+\n+    protected static abstract class ChLi<T> implements IDisconnectable, ChangeListener<T> { }\n+\n+    protected static abstract class InLi implements IDisconnectable, InvalidationListener { }\n+\n+    protected static abstract class LiChLi<T> implements IDisconnectable, ListChangeListener<T> { }\n+\n+    protected static abstract class WeHa<T extends Event> implements IDisconnectable, EventHandler<T> {\n+        private final WeakReference<EventHandler<? super T>> ref;\n+\n+        public WeHa(EventHandler<? super T> h) {\n+            ref = new WeakReference<>(h);\n+        }\n+\n+        @Override\n+        public void handle(T ev) {\n+            EventHandler<? super T> h = ref.get();\n+            if (h == null) {\n+                disconnect();\n+            } else {\n+                h.handle(ev);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/ListenerHelper.java","additions":635,"deletions":0,"binary":false,"changes":635,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -829,0 +829,1 @@\n+    @Deprecated \/\/ WARNING: creates a memory leak\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/skin\/Utils.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -283,1 +283,0 @@\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/SkinBase.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,13 @@\n-import static com.sun.javafx.FXPermissions.ACCESS_WINDOW_LIST_PERMISSION;\n+import java.lang.ref.Reference;\n+import java.lang.ref.WeakReference;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.WeakHashMap;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n@@ -30,6 +42,0 @@\n-import com.sun.javafx.scene.traversal.Direction;\n-import javafx.css.converter.EnumConverter;\n-import javafx.css.converter.SizeConverter;\n-import com.sun.javafx.scene.control.MenuBarButton;\n-import com.sun.javafx.scene.control.skin.Utils;\n-import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n@@ -51,0 +57,2 @@\n+import javafx.css.converter.EnumConverter;\n+import javafx.css.converter.SizeConverter;\n@@ -53,1 +61,0 @@\n-import javafx.event.WeakEventHandler;\n@@ -69,0 +76,1 @@\n+import javafx.scene.input.KeyCode;\n@@ -74,0 +82,2 @@\n+import javafx.stage.Window;\n+import javafx.util.Pair;\n@@ -75,12 +85,1 @@\n-import static javafx.scene.input.KeyCode.*;\n-\n-import java.lang.ref.Reference;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.WeakHashMap;\n-\n+import com.sun.javafx.FXPermissions;\n@@ -91,0 +90,5 @@\n+import com.sun.javafx.scene.control.IDisconnectable;\n+import com.sun.javafx.scene.control.ListenerHelper;\n+import com.sun.javafx.scene.control.MenuBarButton;\n+import com.sun.javafx.scene.traversal.Direction;\n+import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n@@ -92,8 +96,0 @@\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-\n-import javafx.stage.Window;\n-import javafx.util.Pair;\n-\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -119,1 +115,1 @@\n-            ACCESS_WINDOW_LIST_PERMISSION);\n+            FXPermissions.ACCESS_WINDOW_LIST_PERMISSION);\n@@ -145,8 +141,0 @@\n-    private WeakEventHandler<KeyEvent> weakSceneKeyEventHandler;\n-    private WeakEventHandler<MouseEvent> weakSceneMouseEventHandler;\n-    private WeakEventHandler<KeyEvent> weakSceneAltKeyEventHandler;\n-    private WeakChangeListener<Boolean> weakWindowFocusListener;\n-    private WeakChangeListener<Window> weakWindowSceneListener;\n-    private EventHandler<KeyEvent> keyEventHandler;\n-    private EventHandler<KeyEvent> altKeyEventHandler;\n-    private EventHandler<MouseEvent> mouseEventHandler;\n@@ -154,0 +142,1 @@\n+    private WeakChangeListener<Boolean> weakMenuBarFocusedPropertyListener;\n@@ -156,0 +145,4 @@\n+    private WeakChangeListener<Boolean> weakMenuVisibilityChangeListener;\n+    private ListenerHelper listenerHelper = new ListenerHelper();\n+    private ListenerHelper sceneListenerHelper;\n+    private IDisconnectable windowFocusHelper;\n@@ -158,1 +151,0 @@\n-\n@@ -215,1 +207,0 @@\n-\n@@ -236,69 +227,0 @@\n-        \/\/ Key navigation\n-        keyEventHandler = event -> {\n-            \/\/ process right left and may be tab key events\n-            if (focusedMenu != null) {\n-                switch (event.getCode()) {\n-                    case LEFT: {\n-                        boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;\n-                        if (control.getScene().getWindow().isFocused()) {\n-                            if (openMenu != null && !openMenu.isShowing()) {\n-                                if (isRTL) {\n-                                    moveToMenu(Direction.NEXT, false); \/\/ just move the selection bar\n-                                } else {\n-                                    moveToMenu(Direction.PREVIOUS, false); \/\/ just move the selection bar\n-                                }\n-                                event.consume();\n-                                return;\n-                            }\n-                            if (isRTL) {\n-                                moveToMenu(Direction.NEXT, true);\n-                            } else {\n-                                moveToMenu(Direction.PREVIOUS, true);\n-                            }\n-                        }\n-                        event.consume();\n-                        break;\n-                    }\n-                    case RIGHT:\n-                    {\n-                        boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;\n-                        if (control.getScene().getWindow().isFocused()) {\n-                            if (openMenu != null && !openMenu.isShowing()) {\n-                                if (isRTL) {\n-                                    moveToMenu(Direction.PREVIOUS, false); \/\/ just move the selection bar\n-                                } else {\n-                                    moveToMenu(Direction.NEXT, false); \/\/ just move the selection bar\n-                                }\n-                                event.consume();\n-                                return;\n-                            }\n-                            if (isRTL) {\n-                                moveToMenu(Direction.PREVIOUS, true);\n-                            } else {\n-                                moveToMenu(Direction.NEXT, true);\n-                            }\n-                        }\n-                        event.consume();\n-                        break;\n-                    }\n-                    case DOWN:\n-                    \/\/case SPACE:\n-                    \/\/case ENTER:\n-                        \/\/ RT-18859: Doing nothing for space and enter\n-                        if (control.getScene().getWindow().isFocused()) {\n-                            if (focusedMenuIndex != -1) {\n-                                Menu menuToOpen = getSkinnable().getMenus().get(focusedMenuIndex);\n-                                showMenu(menuToOpen, true);\n-                                event.consume();\n-                            }\n-                        }\n-                        break;\n-                    case ESCAPE:\n-                        unSelectMenus();\n-                        event.consume();\n-                        break;\n-                default:\n-                    break;\n-                }\n-            }\n-        };\n@@ -315,12 +237,0 @@\n-         };\n-        weakSceneKeyEventHandler = new WeakEventHandler<KeyEvent>(keyEventHandler);\n-        Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n-            scene.addEventFilter(KeyEvent.KEY_PRESSED, weakSceneKeyEventHandler);\n-        });\n-\n-        \/\/ When we click else where in the scene - menu selection should be cleared.\n-        mouseEventHandler = t -> {\n-            Bounds containerScreenBounds = container.localToScreen(container.getLayoutBounds());\n-            if (containerScreenBounds == null || !containerScreenBounds.contains(t.getScreenX(), t.getScreenY())) {\n-                unSelectMenus();\n-            }\n@@ -328,25 +238,1 @@\n-        weakSceneMouseEventHandler = new WeakEventHandler<MouseEvent>(mouseEventHandler);\n-        Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n-            scene.addEventFilter(MouseEvent.MOUSE_CLICKED, weakSceneMouseEventHandler);\n-        });\n-\n-        weakWindowFocusListener = new WeakChangeListener<Boolean>((ov, t, t1) -> {\n-            if (!t1) {\n-              unSelectMenus();\n-            }\n-        });\n-        \/\/ When the parent window looses focus - menu selection should be cleared\n-        Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n-            if (scene.getWindow() != null) {\n-                scene.getWindow().focusedProperty().addListener(weakWindowFocusListener);\n-            } else {\n-                ChangeListener<Window> sceneWindowListener = (observable, oldValue, newValue) -> {\n-                    if (oldValue != null)\n-                        oldValue.focusedProperty().removeListener(weakWindowFocusListener);\n-                    if (newValue != null)\n-                        newValue.focusedProperty().addListener(weakWindowFocusListener);\n-                };\n-                weakWindowSceneListener = new WeakChangeListener<>(sceneWindowListener);\n-                scene.windowProperty().addListener(weakWindowSceneListener);\n-            }\n-        });\n+        weakMenuBarFocusedPropertyListener = new WeakChangeListener(menuBarFocusedPropertyListener);\n@@ -357,0 +243,1 @@\n+        weakMenuVisibilityChangeListener = new WeakChangeListener(menuVisibilityChangeListener);\n@@ -359,1 +246,1 @@\n-        control.getMenus().addListener((ListChangeListener<Menu>) c -> {\n+        registerListChangeListener(control.getMenus(), (ch) -> {\n@@ -364,1 +251,1 @@\n-            control.useSystemMenuBarProperty().addListener(valueModel -> {\n+            registerInvalidationListener(control.useSystemMenuBarProperty(), (p) -> {\n@@ -391,26 +278,0 @@\n-        altKeyEventHandler = e -> {\n-            if (e.getEventType() == KeyEvent.KEY_PRESSED) {\n-                \/\/ Clear menu selection when ALT is pressed by itself\n-                altKeyPressed = false;\n-                if (e.getCode() == ALT && !e.isConsumed()) {\n-                    if (focusedMenuIndex == -1) {\n-                        altKeyPressed = true;\n-                    }\n-                    unSelectMenus();\n-                }\n-            } else if (e.getEventType() == KeyEvent.KEY_RELEASED) {\n-                \/\/ Put focus on the first menu when ALT is released\n-                \/\/ directly after being pressed by itself\n-                if (altKeyPressed && e.getCode() == ALT && !e.isConsumed()) {\n-                    firstMenuRunnable.run();\n-                }\n-                altKeyPressed = false;\n-            }\n-        };\n-        weakSceneAltKeyEventHandler = new WeakEventHandler<>(altKeyEventHandler);\n-\n-        Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n-            scene.getAccelerators().put(acceleratorKeyCombo, firstMenuRunnable);\n-            scene.addEventHandler(KeyEvent.ANY, weakSceneAltKeyEventHandler);\n-        });\n-\n@@ -424,12 +285,4 @@\n-        control.sceneProperty().addListener((ov, t, t1) -> {\n-            \/\/ remove event handlers \/ filters from the old scene (t)\n-            if (t != null) {\n-                if (weakSceneKeyEventHandler != null) {\n-                    t.removeEventFilter(KeyEvent.KEY_PRESSED, weakSceneKeyEventHandler);\n-                }\n-                if (weakSceneMouseEventHandler != null) {\n-                    t.removeEventFilter(MouseEvent.MOUSE_CLICKED, weakSceneMouseEventHandler);\n-                }\n-                if (weakSceneAltKeyEventHandler != null) {\n-                    t.removeEventHandler(KeyEvent.ANY, weakSceneAltKeyEventHandler);\n-                }\n+        listenerHelper.addChangeListener(control.sceneProperty(), true, (src,old,scene) -> {\n+            if (sceneListenerHelper != null) {\n+                sceneListenerHelper.disconnect();\n+                sceneListenerHelper = null;\n@@ -438,9 +291,122 @@\n-            \/**\n-             * remove the f10 accelerator from the old scene\n-             * add it to the new scene\n-             *\/\n-            if (t != null) {\n-                t.getAccelerators().remove(acceleratorKeyCombo);\n-            }\n-            if (t1 != null ) {\n-                t1.getAccelerators().put(acceleratorKeyCombo, firstMenuRunnable);\n+            if (scene != null ) {\n+                sceneListenerHelper = new ListenerHelper();\n+\n+                \/\/ Key navigation\n+                sceneListenerHelper.addWeakEventFilter(scene, KeyEvent.KEY_PRESSED, (ev) -> {\n+                    \/\/ process right left and may be tab key events\n+                    if (focusedMenu != null) {\n+                        switch (ev.getCode()) {\n+                            case LEFT: {\n+                                boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;\n+                                if (control.getScene().getWindow().isFocused()) {\n+                                    if (openMenu != null && !openMenu.isShowing()) {\n+                                        if (isRTL) {\n+                                            moveToMenu(Direction.NEXT, false); \/\/ just move the selection bar\n+                                        } else {\n+                                            moveToMenu(Direction.PREVIOUS, false); \/\/ just move the selection bar\n+                                        }\n+                                        ev.consume();\n+                                        return;\n+                                    }\n+                                    if (isRTL) {\n+                                        moveToMenu(Direction.NEXT, true);\n+                                    } else {\n+                                        moveToMenu(Direction.PREVIOUS, true);\n+                                    }\n+                                }\n+                                ev.consume();\n+                                break;\n+                            }\n+                            case RIGHT:\n+                            {\n+                                boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;\n+                                if (control.getScene().getWindow().isFocused()) {\n+                                    if (openMenu != null && !openMenu.isShowing()) {\n+                                        if (isRTL) {\n+                                            moveToMenu(Direction.PREVIOUS, false); \/\/ just move the selection bar\n+                                        } else {\n+                                            moveToMenu(Direction.NEXT, false); \/\/ just move the selection bar\n+                                        }\n+                                        ev.consume();\n+                                        return;\n+                                    }\n+                                    if (isRTL) {\n+                                        moveToMenu(Direction.PREVIOUS, true);\n+                                    } else {\n+                                        moveToMenu(Direction.NEXT, true);\n+                                    }\n+                                }\n+                                ev.consume();\n+                                break;\n+                            }\n+                            case DOWN:\n+                            \/\/case SPACE:\n+                            \/\/case ENTER:\n+                                \/\/ RT-18859: Doing nothing for space and enter\n+                                if (control.getScene().getWindow().isFocused()) {\n+                                    if (focusedMenuIndex != -1) {\n+                                        Menu menuToOpen = getSkinnable().getMenus().get(focusedMenuIndex);\n+                                        showMenu(menuToOpen, true);\n+                                        ev.consume();\n+                                    }\n+                                }\n+                                break;\n+                            case ESCAPE:\n+                                unSelectMenus();\n+                                ev.consume();\n+                                break;\n+                        default:\n+                            break;\n+                        }\n+                    }\n+                });\n+\n+                \/\/ When we click else where in the scene - menu selection should be cleared.\n+                sceneListenerHelper.addWeakEventFilter(scene, MouseEvent.MOUSE_CLICKED, (ev) -> {\n+                    Bounds containerScreenBounds = container.localToScreen(container.getLayoutBounds());\n+                    if ((containerScreenBounds == null) || !containerScreenBounds.contains(ev.getScreenX(), ev.getScreenY())) {\n+                        unSelectMenus();\n+                    }\n+                });\n+\n+                \/\/ When the parent window looses focus - menu selection should be cleared\n+                sceneListenerHelper.addWeakChangeListener(scene.windowProperty(), true, (sr, oldw, w) -> {\n+                    if (windowFocusHelper != null) {\n+                        windowFocusHelper.disconnect();\n+                        windowFocusHelper = null;\n+                    }\n+\n+                    if (w != null) {\n+                        windowFocusHelper = sceneListenerHelper.addWeakChangeListener(w.focusedProperty(), true, (s, p, focused) -> {\n+                            if (!focused) {\n+                                unSelectMenus();\n+                            }\n+                        });\n+                    }\n+                });\n+\n+                sceneListenerHelper.addWeakEventFilter(scene, KeyEvent.ANY, (ev) -> {\n+                    \/\/ Clear menu selection when ALT is pressed by itself\n+                    if (ev.getEventType() == KeyEvent.KEY_PRESSED) {\n+                        altKeyPressed = false;\n+                        if (ev.getCode() == KeyCode.ALT && !ev.isConsumed()) {\n+                            if (focusedMenuIndex == -1) {\n+                                altKeyPressed = true;\n+                            }\n+                            unSelectMenus();\n+                        }\n+                    } else if (ev.getEventType() == KeyEvent.KEY_RELEASED) {\n+                        \/\/ Put focus on the first menu when ALT is released\n+                        \/\/ directly after being pressed by itself\n+                        if (altKeyPressed && ev.getCode() == KeyCode.ALT && !ev.isConsumed()) {\n+                            firstMenuRunnable.run();\n+                        }\n+                        altKeyPressed = false;\n+                    }\n+                });\n+\n+                \/\/ F10 accelerator\n+                scene.getAccelerators().put(acceleratorKeyCombo, firstMenuRunnable);\n+                sceneListenerHelper.addDisconnectable(() -> {\n+                    scene.getAccelerators().remove(acceleratorKeyCombo);\n+                });\n@@ -686,1 +652,15 @@\n-    @Override public void dispose() {\n+    @Override\n+    public void dispose() {\n+        if (getSkinnable() == null) {\n+            return;\n+        }\n+\n+        listenerHelper.disconnect();\n+        listenerHelper = null;\n+\n+        if (sceneListenerHelper != null) {\n+            sceneListenerHelper.disconnect();\n+            sceneListenerHelper = null;\n+        }\n+\n+        cleanUpListeners();\n@@ -688,0 +668,2 @@\n+        getChildren().remove(container);\n+\n@@ -824,2 +806,3 @@\n-    private void rebuildUI() {\n-        getSkinnable().focusedProperty().removeListener(menuBarFocusedPropertyListener);\n+    private void cleanUpListeners() {\n+        getSkinnable().focusedProperty().removeListener(weakMenuBarFocusedPropertyListener);\n+\n@@ -830,1 +813,1 @@\n-            m.visibleProperty().removeListener(menuVisibilityChangeListener);\n+            m.visibleProperty().removeListener(weakMenuVisibilityChangeListener);\n@@ -832,0 +815,1 @@\n+\n@@ -852,0 +836,1 @@\n+\n@@ -853,0 +838,4 @@\n+    }\n+\n+    private void rebuildUI() {\n+        cleanUpListeners();\n@@ -930,1 +919,2 @@\n-        getSkinnable().focusedProperty().addListener(menuBarFocusedPropertyListener);\n+        getSkinnable().focusedProperty().addListener(weakMenuBarFocusedPropertyListener);\n+\n@@ -933,1 +923,1 @@\n-            menu.visibleProperty().addListener(menuVisibilityChangeListener);\n+            menu.visibleProperty().addListener(weakMenuVisibilityChangeListener);\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/MenuBarSkin.java","additions":190,"deletions":200,"binary":false,"changes":390,"status":"modified"},{"patch":"@@ -28,0 +28,13 @@\n+import static javafx.scene.control.ControlShim.installDefaultSkin;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.asArrays;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.attemptGC;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.createControl;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.getControlClasses;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.replaceSkin;\n+\n@@ -32,12 +45,0 @@\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-\n-import com.sun.javafx.tk.Toolkit;\n-\n-import static javafx.scene.control.ControlShim.*;\n-import static org.junit.Assert.*;\n-import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.*;\n-\n@@ -51,1 +52,0 @@\n-import javafx.scene.control.MenuBar;\n@@ -67,0 +67,8 @@\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.sun.javafx.tk.Toolkit;\n+\n@@ -87,0 +95,2 @@\n+        WeakReference<?> weakRef = new WeakReference<>(skin);\n+\n@@ -89,0 +99,16 @@\n+        skin = null;\n+        Toolkit.getToolkit().firePulse();\n+\n+        attemptGC(weakRef);\n+        assertNull(\"Unused Skin must be gc'ed\", weakRef.get());\n+    }\n+\n+    \/**\n+     * default skin -> set another instance of default skin,\n+     * with scene property set.\n+     *\/\n+    @Test\n+    public void testMemoryLeakSameSkinClassWithScene() {\n+        showControl(control, true);\n+        installDefaultSkin(control);\n+        Skin<?> skin = control.getSkin();\n@@ -90,0 +116,3 @@\n+\n+        installDefaultSkin(control);\n+\n@@ -91,0 +120,2 @@\n+        Toolkit.getToolkit().firePulse();\n+\n@@ -120,2 +151,2 @@\n-        \/\/ FIXME: JDK-8265406 - fragile test pattern\n-        WeakReference<?> weakRef = new WeakReference<>(replaceSkin(control));\n+        Skin<?> replacedSkin = replaceSkin(control);\n+        WeakReference<?> weakRef = new WeakReference<>(replacedSkin);\n@@ -123,0 +154,25 @@\n+\n+        \/\/ beware: this is important - we might get false reds without!\n+        replacedSkin = null;\n+        Toolkit.getToolkit().firePulse();\n+\n+        attemptGC(weakRef);\n+        assertEquals(\"Skin must be gc'ed\", null, weakRef.get());\n+    }\n+\n+    \/**\n+     * default skin -> set alternative,\n+     * with scene property set\n+     *\/\n+    @Test\n+    public void testMemoryLeakAlternativeSkinWithScene() {\n+        showControl(control, true);\n+        installDefaultSkin(control);\n+        Skin<?> replacedSkin = replaceSkin(control);\n+        WeakReference<?> weakRef = new WeakReference<>(replacedSkin);\n+        assertNotNull(weakRef.get());\n+\n+        \/\/ beware: this is important - we might get false reds without!\n+        replacedSkin = null;\n+        Toolkit.getToolkit().firePulse();\n+\n@@ -136,0 +192,1 @@\n+\n@@ -137,1 +194,0 @@\n-        Toolkit.getToolkit().firePulse();\n@@ -139,0 +195,2 @@\n+        Toolkit.getToolkit().firePulse();\n+\n@@ -169,1 +227,0 @@\n-                MenuBar.class,\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/SkinMemoryLeakTest.java","additions":74,"deletions":17,"binary":false,"changes":91,"status":"modified"}]}