{"files":[{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.javafx.scene.control;\n+\n+\/**\n+ * A functional interface that provides a {@link #disconnect()} method.\n+ * <p>\n+ * Original code is re-licensed to Oracle by the author.\n+ * https:\/\/github.com\/andy-goryachev\/FxTextEditor\/blob\/master\/src\/goryachev\/common\/util\/Disconnectable.java\n+ * Copyright © 2021-2022 Andy Goryachev <andy@goryachev.com>\n+ *\/\n+@FunctionalInterface\n+public interface IDisconnectable {\n+    \/**\n+     * Disconnects what has been connected. May be called multiple times, only the\n+     * first invocation actually disconnects.\n+     *\/\n+    public void disconnect();\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/IDisconnectable.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -61,0 +61,1 @@\n+@Deprecated \/\/ TODO use ListenerHelper instead\n@@ -161,26 +162,0 @@\n-    \/**\n-     * Executes a lambda if the property value is not null, otherwise adds a listener to the ObservableValue {@code p}\n-     * to wait until it is set and calls the lambda then, followed by removing the said listener.\n-     *\n-     * @param p Observable value\n-     * @param consumer lambda to invoke when the property value is not null\n-     *\/\n-    public <T> void executeOnceWhenPropertyIsNonNull(ObservableValue<T> p, Consumer<T> consumer) {\n-        if (p == null) {\n-            return;\n-        }\n-\n-        T value = p.getValue();\n-        if (value != null) {\n-            consumer.accept(value);\n-        } else {\n-            registerInvalidationListener(p, (x) -> {\n-                T v = p.getValue();\n-                if (v != null) {\n-                    unregisterInvalidationListeners(p);\n-                    consumer.accept(v);\n-                }\n-            });\n-        }\n-    }\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/LambdaMultiplePropertyChangeListenerHandler.java","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,635 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.javafx.scene.control;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.Observable;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.ObservableList;\n+import javafx.concurrent.Task;\n+import javafx.event.Event;\n+import javafx.event.EventHandler;\n+import javafx.event.EventType;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.TableColumnBase;\n+import javafx.scene.control.TreeItem;\n+import javafx.scene.transform.Transform;\n+import javafx.stage.Window;\n+\n+\/**\n+ * This class provides convenience methods for adding various listeners, both strong and weak,\n+ * as well as a single {@link #disconnect()} method to remove all listeners.\n+ * <p>\n+ * There are two usage patterns:\n+ * <ul>\n+ * <li>Client code registers a number of listeners and removes them all at once via {@link #disconnect()} call.\n+ * <li>Client code registers a number of listeners and removes one via its {@link IDisconnectable} instance.\n+ * <\/ul>\n+ * <p>\n+ * Original code is re-licensed to Oracle by the author.\n+ * https:\/\/github.com\/andy-goryachev\/FxTextEditor\/blob\/master\/src\/goryachev\/fx\/FxDisconnector.java\n+ * Copyright © 2021-2022 Andy Goryachev <andy@goryachev.com>\n+ *\/\n+public class ListenerHelper implements IDisconnectable {\n+    private final ArrayList<IDisconnectable> items = new ArrayList<>(4);\n+    private static final Object KEY = new Object();\n+\n+    public ListenerHelper() {\n+    }\n+\n+    public static ListenerHelper get(Node n) {\n+        Object x = n.getProperties().get(KEY);\n+        if (x instanceof ListenerHelper h) {\n+            return h;\n+        }\n+        ListenerHelper d = new ListenerHelper();\n+        n.getProperties().put(KEY, d);\n+        return d;\n+    }\n+\n+    public static void disconnect(Node n) {\n+        Object x = n.getProperties().remove(KEY);\n+        if (x instanceof ListenerHelper h) {\n+            h.disconnect();\n+        }\n+    }\n+\n+    public IDisconnectable addDisconnectable(IDisconnectable d) {\n+        items.add(d);\n+        return d;\n+    }\n+\n+    @Override\n+    public void disconnect() {\n+        for (int i = items.size() - 1; i >= 0; i--) {\n+            IDisconnectable d = items.remove(i);\n+            d.disconnect();\n+        }\n+    }\n+\n+    \/\/ change listeners\n+\n+    public IDisconnectable addChangeListener(Runnable callback, ObservableValue<?>... props) {\n+        return addChangeListener(callback, false, props);\n+    }\n+\n+    public IDisconnectable addChangeListener(Runnable onChange, boolean fireImmediately, ObservableValue<?>... props) {\n+        if (onChange == null) {\n+            throw new NullPointerException(\"onChange must not be null.\");\n+        }\n+\n+        ChLi li = new ChLi() {\n+            @Override\n+            public void disconnect() {\n+                for (ObservableValue p : props) {\n+                    p.removeListener(this);\n+                }\n+            }\n+\n+            @Override\n+            public void changed(ObservableValue p, Object oldValue, Object newValue) {\n+                onChange.run();\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        for (ObservableValue p : props) {\n+            p.addListener(li);\n+        }\n+\n+        if (fireImmediately) {\n+            onChange.run();\n+        }\n+\n+        return li;\n+    }\n+\n+    public <T> IDisconnectable addChangeListener(ObservableValue<T> prop, ChangeListener<T> listener) {\n+        return addChangeListener(prop, false, listener);\n+    }\n+\n+    public <T> IDisconnectable addChangeListener(ObservableValue<T> prop, boolean fireImmediately, ChangeListener<T> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        IDisconnectable d = new IDisconnectable() {\n+            @Override\n+            public void disconnect() {\n+                prop.removeListener(listener);\n+            }\n+        };\n+\n+        items.add(d);\n+        prop.addListener(listener);\n+\n+        if (fireImmediately) {\n+            T v = prop.getValue();\n+            listener.changed(prop, null, v);\n+        }\n+\n+        return d;\n+    }\n+\n+    public IDisconnectable addWeakChangeListener(Runnable onChange, ObservableValue<?>... props) {\n+        return addWeakChangeListener(onChange, false, props);\n+    }\n+\n+    public IDisconnectable addWeakChangeListener(Runnable onChange, boolean fireImmediately, ObservableValue<?>... props) {\n+        if (onChange == null) {\n+            throw new NullPointerException(\"onChange must not be null.\");\n+        }\n+\n+        ChLi li = new ChLi() {\n+            WeakReference<Runnable> ref = new WeakReference(onChange);\n+\n+            @Override\n+            public void disconnect() {\n+                for (ObservableValue p : props) {\n+                    p.removeListener(this);\n+                }\n+            }\n+\n+            @Override\n+            public void changed(ObservableValue p, Object oldValue, Object newValue) {\n+                Runnable r = ref.get();\n+                if (r == null) {\n+                    disconnect();\n+                } else {\n+                    r.run();\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        for (ObservableValue p : props) {\n+            p.addListener(li);\n+        }\n+\n+        if (fireImmediately) {\n+            onChange.run();\n+        }\n+\n+        return li;\n+    }\n+\n+    public <T> IDisconnectable addWeakChangeListener(ObservableValue<T> prop, ChangeListener<T> listener) {\n+        return addChangeListener(prop, false, listener);\n+    }\n+\n+    public <T> IDisconnectable addWeakChangeListener(ObservableValue<T> prop, boolean fireImmediately, ChangeListener<T> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        ChLi<T> d = new ChLi<T>() {\n+            WeakReference<ChangeListener<T>> ref = new WeakReference<>(listener);\n+\n+            @Override\n+            public void disconnect() {\n+                prop.removeListener(this);\n+            }\n+\n+            @Override\n+            public void changed(ObservableValue<? extends T> p, T oldValue, T newValue) {\n+                ChangeListener<T> li = ref.get();\n+                if (li == null) {\n+                    disconnect();\n+                } else {\n+                    li.changed(p, oldValue, newValue);\n+                }\n+            }\n+        };\n+\n+        items.add(d);\n+        prop.addListener(d);\n+\n+        if (fireImmediately) {\n+            T v = prop.getValue();\n+            listener.changed(prop, null, v);\n+        }\n+\n+        return d;\n+    }\n+\n+    \/\/ invalidation listeners\n+\n+    public IDisconnectable addInvalidationListener(Runnable callback, ObservableValue<?>... props) {\n+        return addInvalidationListener(callback, false, props);\n+    }\n+\n+    public IDisconnectable addInvalidationListener(Runnable callback, boolean fireImmediately, ObservableValue<?>... props) {\n+        if (callback == null) {\n+            throw new NullPointerException(\"Callback must be specified.\");\n+        }\n+\n+        InLi li = new InLi() {\n+            @Override\n+            public void disconnect() {\n+                for (ObservableValue p : props) {\n+                    p.removeListener(this);\n+                }\n+            }\n+\n+            @Override\n+            public void invalidated(Observable p) {\n+                callback.run();\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        for (ObservableValue p : props) {\n+            p.addListener(li);\n+        }\n+\n+        if (fireImmediately) {\n+            callback.run();\n+        }\n+\n+        return li;\n+    }\n+\n+    public <T> IDisconnectable addInvalidationListener(ObservableValue<T> prop, InvalidationListener listener) {\n+        return addInvalidationListener(prop, false, listener);\n+    }\n+\n+    public <T> IDisconnectable addInvalidationListener(ObservableValue<T> prop, boolean fireImmediately, InvalidationListener listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        IDisconnectable d = new IDisconnectable() {\n+            @Override\n+            public void disconnect() {\n+                prop.removeListener(listener);\n+            }\n+        };\n+\n+        items.add(d);\n+        prop.addListener(listener);\n+\n+        if (fireImmediately) {\n+            listener.invalidated(prop);\n+        }\n+\n+        return d;\n+    }\n+\n+    public IDisconnectable addWeakInvalidationListener(Runnable onChange, ObservableValue<?>... props) {\n+        return addWeakInvalidationListener(onChange, false, props);\n+    }\n+\n+    public IDisconnectable addWeakInvalidationListener(Runnable onChange, boolean fireImmediately, ObservableValue<?>... props) {\n+        if (onChange == null) {\n+            throw new NullPointerException(\"onChange must not be null.\");\n+        }\n+\n+        InLi li = new InLi() {\n+            WeakReference<Runnable> ref = new WeakReference(onChange);\n+\n+            @Override\n+            public void disconnect() {\n+                for (ObservableValue p : props) {\n+                    p.removeListener(this);\n+                }\n+            }\n+\n+            @Override\n+            public void invalidated(Observable p) {\n+                Runnable r = ref.get();\n+                if (r == null) {\n+                    disconnect();\n+                } else {\n+                    r.run();\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        for (ObservableValue p : props) {\n+            p.addListener(li);\n+        }\n+\n+        if (fireImmediately) {\n+            onChange.run();\n+        }\n+\n+        return li;\n+    }\n+\n+    public IDisconnectable addWeakInvalidationListener(ObservableValue<?> prop, InvalidationListener listener) {\n+        return addWeakInvalidationListener(prop, false, listener);\n+    }\n+\n+    public IDisconnectable addWeakInvalidationListener(ObservableValue<?> prop, boolean fireImmediately, InvalidationListener listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        InLi d = new InLi() {\n+            WeakReference<InvalidationListener> ref = new WeakReference<>(listener);\n+\n+            @Override\n+            public void disconnect() {\n+                prop.removeListener(this);\n+            }\n+\n+            @Override\n+            public void invalidated(Observable p) {\n+                InvalidationListener li = ref.get();\n+                if (li == null) {\n+                    disconnect();\n+                } else {\n+                    li.invalidated(p);\n+                }\n+            }\n+        };\n+\n+        items.add(d);\n+        prop.addListener(d);\n+\n+        if (fireImmediately) {\n+            listener.invalidated(prop);\n+        }\n+\n+        return d;\n+    }\n+\n+    \/\/ list change listeners\n+\n+    public <T> IDisconnectable addListChangeListener(ObservableList<T> list, ListChangeListener<T> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        IDisconnectable d = new IDisconnectable() {\n+            @Override\n+            public void disconnect() {\n+                list.removeListener(listener);\n+            }\n+        };\n+\n+        items.add(d);\n+        list.addListener(listener);\n+\n+        return d;\n+    }\n+\n+    public <T> IDisconnectable addWeakListChangeListener(ObservableList<T> list, ListChangeListener<T> listener) {\n+        if (listener == null) {\n+            throw new NullPointerException(\"Listener must be specified.\");\n+        }\n+\n+        LiChLi<T> li = new LiChLi<T>() {\n+            WeakReference<ListChangeListener<T>> ref = new WeakReference<>(listener);\n+\n+            @Override\n+            public void disconnect() {\n+                list.removeListener(this);\n+            }\n+\n+            @Override\n+            public void onChanged(Change<? extends T> ch) {\n+                ListChangeListener<T> li = ref.get();\n+                if (li == null) {\n+                    disconnect();\n+                } else {\n+                    li.onChanged(ch);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+        list.addListener(li);\n+\n+        return li;\n+    }\n+\n+    \/\/ event handlers\n+\n+    public <T extends Event> IDisconnectable addEventHandler(Object x, EventType<T> t, EventHandler<T> h) {\n+\n+        \/\/ we really need an interface here ... \"HasEventHandlers\"\n+        IDisconnectable d = addDisconnectable(() -> {\n+            if (x instanceof Node n) {\n+                n.removeEventHandler(t, h);\n+            } else if (x instanceof Window y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof Scene y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof MenuItem y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof TreeItem y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof TableColumnBase y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof Transform y) {\n+                y.removeEventHandler(t, h);\n+            } else if (x instanceof Task y) {\n+                y.removeEventHandler(t, h);\n+            }\n+        });\n+\n+        if (x instanceof Node y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof Window y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof Scene y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof MenuItem y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof TreeItem y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof TableColumnBase y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof Transform y) {\n+            y.addEventHandler(t, h);\n+        } else if (x instanceof Task y) {\n+            y.addEventHandler(t, h);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot add event handler to \" + x);\n+        }\n+\n+        return d;\n+    }\n+\n+    public <T extends Event> IDisconnectable addWeakEventHandler(Object x, EventType<T> t, EventHandler<T> h) {\n+        WeHa<T> li = new WeHa<T>(h) {\n+            @Override\n+            public void disconnect() {\n+                if (x instanceof Node n) {\n+                    n.removeEventHandler(t, this);\n+                } else if (x instanceof Window y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof Scene y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof MenuItem y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof TreeItem y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof TableColumnBase y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof Transform y) {\n+                    y.removeEventHandler(t, this);\n+                } else if (x instanceof Task y) {\n+                    y.removeEventHandler(t, this);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        if (x instanceof Node y) {\n+            y.addEventHandler(t, li);\n+        } else if (x instanceof Window y) {\n+            y.addEventHandler(t, li);\n+        } else if (x instanceof Scene y) {\n+            y.addEventHandler(t, li);\n+        } else if (x instanceof MenuItem y) {\n+            y.addEventHandler(t, li);\n+        } else if (x instanceof TreeItem y) {\n+            y.addEventHandler(t, li);\n+        } else if (x instanceof TableColumnBase y) {\n+            y.addEventHandler(t, li);\n+        } else if (x instanceof Transform y) {\n+            y.addEventHandler(t, li);\n+        } else if (x instanceof Task y) {\n+            y.addEventHandler(t, li);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot add weak event handler to \" + x);\n+        }\n+\n+        return li;\n+    }\n+\n+    \/\/ event filters\n+\n+    public <T extends Event> IDisconnectable addEventFilter(Object x, EventType<T> t, EventHandler<T> h) {\n+        \/\/ we really need an interface here ... \"HasEventFilters\"\n+        IDisconnectable d = addDisconnectable(() -> {\n+            if (x instanceof Node n) {\n+                n.removeEventFilter(t, h);\n+            } else if (x instanceof Window y) {\n+                y.removeEventFilter(t, h);\n+            } else if (x instanceof Scene y) {\n+                y.removeEventFilter(t, h);\n+            } else if (x instanceof Transform y) {\n+                y.removeEventFilter(t, h);\n+            } else if (x instanceof Task y) {\n+                y.removeEventFilter(t, h);\n+            }\n+        });\n+\n+        if (x instanceof Node y) {\n+            y.addEventFilter(t, h);\n+        } else if (x instanceof Window y) {\n+            y.addEventFilter(t, h);\n+        } else if (x instanceof Scene y) {\n+            y.addEventFilter(t, h);\n+        } else if (x instanceof Transform y) {\n+            y.addEventFilter(t, h);\n+        } else if (x instanceof Task y) {\n+            y.addEventFilter(t, h);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot add event filter to \" + x);\n+        }\n+\n+        return d;\n+    }\n+\n+    public <T extends Event> IDisconnectable addWeakEventFilter(Object x, EventType<T> t, EventHandler<? super T> h) {\n+        WeHa<T> li = new WeHa<T>(h) {\n+            @Override\n+            public void disconnect() {\n+                if (x instanceof Node n) {\n+                    n.removeEventFilter(t, this);\n+                } else if (x instanceof Window y) {\n+                    y.removeEventFilter(t, this);\n+                } else if (x instanceof Scene y) {\n+                    y.removeEventFilter(t, this);\n+                } else if (x instanceof Transform y) {\n+                    y.removeEventFilter(t, this);\n+                } else if (x instanceof Task y) {\n+                    y.removeEventFilter(t, this);\n+                }\n+            }\n+        };\n+\n+        items.add(li);\n+\n+        if (x instanceof Node y) {\n+            y.addEventFilter(t, li);\n+        } else if (x instanceof Window y) {\n+            y.addEventFilter(t, li);\n+        } else if (x instanceof Scene y) {\n+            y.addEventFilter(t, li);\n+        } else if (x instanceof Transform y) {\n+            y.addEventFilter(t, li);\n+        } else if (x instanceof Task y) {\n+            y.addEventFilter(t, li);\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot add weak event filter to \" + x);\n+        }\n+\n+        return li;\n+    }\n+\n+    \/\/\n+\n+    protected static abstract class ChLi<T> implements IDisconnectable, ChangeListener<T> { }\n+\n+    protected static abstract class InLi implements IDisconnectable, InvalidationListener { }\n+\n+    protected static abstract class LiChLi<T> implements IDisconnectable, ListChangeListener<T> { }\n+    \n+    protected static abstract class WeHa<T extends Event> implements IDisconnectable, EventHandler<T> {\n+        private final WeakReference<EventHandler<? super T>> ref;\n+\n+        public WeHa(EventHandler<? super T> h) {\n+            ref = new WeakReference<>(h);\n+        }\n+\n+        @Override\n+        public void handle(T ev) {\n+            EventHandler<? super T> h = ref.get();\n+            if (h == null) {\n+                disconnect();\n+            } else {\n+                h.handle(ev);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/ListenerHelper.java","additions":635,"deletions":0,"binary":false,"changes":635,"status":"added"},{"patch":"@@ -283,14 +283,0 @@\n-    \/**\n-     * Executes a lambda if the property value is not null, otherwise adds a listener to the ObservableValue {@code p}\n-     * to wait until it is set and calls the lambda then, followed by removing the said listener.\n-     *\n-     * @param p Observable value\n-     * @param consumer lambda to invoke when the property value is not null\n-     *\/\n-    protected final <T> void executeOnceWhenPropertyIsNonNull(ObservableValue<T> p, Consumer<T> consumer) {\n-        if (lambdaChangeListenerHandler == null) {\n-            lambdaChangeListenerHandler = new LambdaMultiplePropertyChangeListenerHandler();\n-        }\n-        lambdaChangeListenerHandler.executeOnceWhenPropertyIsNonNull(p, consumer);\n-    }\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/SkinBase.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import static com.sun.javafx.FXPermissions.ACCESS_WINDOW_LIST_PERMISSION;\n-import static javafx.scene.input.KeyCode.ALT;\n-\n@@ -64,1 +61,0 @@\n-import javafx.event.WeakEventHandler;\n@@ -80,0 +76,1 @@\n+import javafx.scene.input.KeyCode;\n@@ -88,0 +85,1 @@\n+import com.sun.javafx.FXPermissions;\n@@ -92,0 +90,2 @@\n+import com.sun.javafx.scene.control.IDisconnectable;\n+import com.sun.javafx.scene.control.ListenerHelper;\n@@ -115,1 +115,1 @@\n-            ACCESS_WINDOW_LIST_PERMISSION);\n+            FXPermissions.ACCESS_WINDOW_LIST_PERMISSION);\n@@ -141,8 +141,0 @@\n-    private final WeakEventHandler<KeyEvent> weakSceneKeyEventHandler;\n-    private final WeakEventHandler<MouseEvent> weakSceneMouseEventHandler;\n-    private final WeakEventHandler<KeyEvent> weakSceneAltKeyEventHandler;\n-    private WeakChangeListener<Boolean> weakWindowFocusListener;\n-    private WeakChangeListener<Window> weakWindowSceneListener;\n-    private EventHandler<KeyEvent> keyEventHandler;\n-    private EventHandler<KeyEvent> altKeyEventHandler;\n-    private EventHandler<MouseEvent> mouseEventHandler;\n@@ -154,2 +146,3 @@\n-    private ChangeListener<Scene> sceneChangeListener2;\n-    private WeakChangeListener<Scene> weakSceneChangeListener2;\n+    private ListenerHelper listenerHelper = new ListenerHelper();\n+    private ListenerHelper sceneListenerHelper;\n+    private IDisconnectable windowFocusHelper;\n@@ -172,3 +165,1 @@\n-            if (!cmi.isHideOnClick()) {\n-                return;\n-            }\n+            if (!cmi.isHideOnClick()) return;\n@@ -216,1 +207,0 @@\n-\n@@ -237,70 +227,0 @@\n-        \/\/ Key navigation\n-        keyEventHandler = event -> {\n-            \/\/ process right left and may be tab key events\n-            if (focusedMenu != null) {\n-                switch (event.getCode()) {\n-                    case LEFT: {\n-                        boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;\n-                        if (control.getScene().getWindow().isFocused()) {\n-                            if (openMenu != null && !openMenu.isShowing()) {\n-                                if (isRTL) {\n-                                    moveToMenu(Direction.NEXT, false); \/\/ just move the selection bar\n-                                } else {\n-                                    moveToMenu(Direction.PREVIOUS, false); \/\/ just move the selection bar\n-                                }\n-                                event.consume();\n-                                return;\n-                            }\n-                            if (isRTL) {\n-                                moveToMenu(Direction.NEXT, true);\n-                            } else {\n-                                moveToMenu(Direction.PREVIOUS, true);\n-                            }\n-                        }\n-                        event.consume();\n-                        break;\n-                    }\n-                    case RIGHT:\n-                    {\n-                        boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;\n-                        if (control.getScene().getWindow().isFocused()) {\n-                            if (openMenu != null && !openMenu.isShowing()) {\n-                                if (isRTL) {\n-                                    moveToMenu(Direction.PREVIOUS, false); \/\/ just move the selection bar\n-                                } else {\n-                                    moveToMenu(Direction.NEXT, false); \/\/ just move the selection bar\n-                                }\n-                                event.consume();\n-                                return;\n-                            }\n-                            if (isRTL) {\n-                                moveToMenu(Direction.PREVIOUS, true);\n-                            } else {\n-                                moveToMenu(Direction.NEXT, true);\n-                            }\n-                        }\n-                        event.consume();\n-                        break;\n-                    }\n-                    case DOWN:\n-                    \/\/case SPACE:\n-                    \/\/case ENTER:\n-                        \/\/ RT-18859: Doing nothing for space and enter\n-                        if (control.getScene().getWindow().isFocused()) {\n-                            if (focusedMenuIndex != -1) {\n-                                Menu menuToOpen = getSkinnable().getMenus().get(focusedMenuIndex);\n-                                showMenu(menuToOpen, true);\n-                                event.consume();\n-                            }\n-                        }\n-                        break;\n-                    case ESCAPE:\n-                        unSelectMenus();\n-                        event.consume();\n-                        break;\n-                default:\n-                    break;\n-                }\n-            }\n-        };\n-\n@@ -320,38 +240,0 @@\n-        weakSceneKeyEventHandler = new WeakEventHandler<KeyEvent>(keyEventHandler);\n-        executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n-            scene.addEventFilter(KeyEvent.KEY_PRESSED, weakSceneKeyEventHandler);\n-        });\n-\n-        \/\/ When we click else where in the scene - menu selection should be cleared.\n-        mouseEventHandler = t -> {\n-            Bounds containerScreenBounds = container.localToScreen(container.getLayoutBounds());\n-            if (containerScreenBounds == null || !containerScreenBounds.contains(t.getScreenX(), t.getScreenY())) {\n-                unSelectMenus();\n-            }\n-        };\n-        weakSceneMouseEventHandler = new WeakEventHandler<MouseEvent>(mouseEventHandler);\n-        executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n-            scene.addEventFilter(MouseEvent.MOUSE_CLICKED, weakSceneMouseEventHandler);\n-        });\n-\n-        weakWindowFocusListener = new WeakChangeListener<Boolean>((ov, t, t1) -> {\n-            if (!t1) {\n-                unSelectMenus();\n-            }\n-        });\n-        \/\/ When the parent window looses focus - menu selection should be cleared\n-        executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n-            if (scene.getWindow() != null) {\n-                scene.getWindow().focusedProperty().addListener(weakWindowFocusListener);\n-            } else {\n-                ChangeListener<Window> sceneWindowListener = (observable, oldValue, newValue) -> {\n-                    if (oldValue != null)\n-                        oldValue.focusedProperty().removeListener(weakWindowFocusListener);\n-                    if (newValue != null)\n-                        newValue.focusedProperty().addListener(weakWindowFocusListener);\n-                };\n-                weakWindowSceneListener = new WeakChangeListener<>(sceneWindowListener);\n-                scene.windowProperty().addListener(weakWindowSceneListener);\n-            }\n-        });\n-\n@@ -396,26 +278,0 @@\n-        altKeyEventHandler = e -> {\n-            if (e.getEventType() == KeyEvent.KEY_PRESSED) {\n-                \/\/ Clear menu selection when ALT is pressed by itself\n-                altKeyPressed = false;\n-                if (e.getCode() == ALT && !e.isConsumed()) {\n-                    if (focusedMenuIndex == -1) {\n-                        altKeyPressed = true;\n-                    }\n-                    unSelectMenus();\n-                }\n-            } else if (e.getEventType() == KeyEvent.KEY_RELEASED) {\n-                \/\/ Put focus on the first menu when ALT is released\n-                \/\/ directly after being pressed by itself\n-                if (altKeyPressed && e.getCode() == ALT && !e.isConsumed()) {\n-                    firstMenuRunnable.run();\n-                }\n-                altKeyPressed = false;\n-            }\n-        };\n-        weakSceneAltKeyEventHandler = new WeakEventHandler<>(altKeyEventHandler);\n-\n-        executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n-            scene.getAccelerators().put(acceleratorKeyCombo, firstMenuRunnable);\n-            scene.addEventHandler(KeyEvent.ANY, weakSceneAltKeyEventHandler);\n-        });\n-\n@@ -429,6 +285,4 @@\n-        sceneChangeListener2 = (ov, t, t1) -> {\n-            \/\/ remove event handlers \/ filters from the old scene (t)\n-            if (t != null) {\n-                t.removeEventFilter(KeyEvent.KEY_PRESSED, weakSceneKeyEventHandler);\n-                t.removeEventFilter(MouseEvent.MOUSE_CLICKED, weakSceneMouseEventHandler);\n-                t.removeEventHandler(KeyEvent.ANY, weakSceneAltKeyEventHandler);\n+        listenerHelper.addChangeListener(control.sceneProperty(), true, (src,old,scene) -> {\n+            if (sceneListenerHelper != null) {\n+                sceneListenerHelper.disconnect();\n+                sceneListenerHelper = null;\n@@ -437,9 +291,122 @@\n-            \/**\n-             * remove the f10 accelerator from the old scene\n-             * add it to the new scene\n-             *\/\n-            if (t != null) {\n-                t.getAccelerators().remove(acceleratorKeyCombo);\n-            }\n-            if (t1 != null ) {\n-                t1.getAccelerators().put(acceleratorKeyCombo, firstMenuRunnable);\n+            if (scene != null ) {\n+                sceneListenerHelper = new ListenerHelper();\n+\n+                \/\/ Key navigation\n+                sceneListenerHelper.addWeakEventFilter(scene, KeyEvent.KEY_PRESSED, (ev) -> {\n+                    \/\/ process right left and may be tab key events\n+                    if (focusedMenu != null) {\n+                        switch (ev.getCode()) {\n+                            case LEFT: {\n+                                boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;\n+                                if (control.getScene().getWindow().isFocused()) {\n+                                    if (openMenu != null && !openMenu.isShowing()) {\n+                                        if (isRTL) {\n+                                            moveToMenu(Direction.NEXT, false); \/\/ just move the selection bar\n+                                        } else {\n+                                            moveToMenu(Direction.PREVIOUS, false); \/\/ just move the selection bar\n+                                        }\n+                                        ev.consume();\n+                                        return;\n+                                    }\n+                                    if (isRTL) {\n+                                        moveToMenu(Direction.NEXT, true);\n+                                    } else {\n+                                        moveToMenu(Direction.PREVIOUS, true);\n+                                    }\n+                                }\n+                                ev.consume();\n+                                break;\n+                            }\n+                            case RIGHT:\n+                            {\n+                                boolean isRTL = control.getEffectiveNodeOrientation() == NodeOrientation.RIGHT_TO_LEFT;\n+                                if (control.getScene().getWindow().isFocused()) {\n+                                    if (openMenu != null && !openMenu.isShowing()) {\n+                                        if (isRTL) {\n+                                            moveToMenu(Direction.PREVIOUS, false); \/\/ just move the selection bar\n+                                        } else {\n+                                            moveToMenu(Direction.NEXT, false); \/\/ just move the selection bar\n+                                        }\n+                                        ev.consume();\n+                                        return;\n+                                    }\n+                                    if (isRTL) {\n+                                        moveToMenu(Direction.PREVIOUS, true);\n+                                    } else {\n+                                        moveToMenu(Direction.NEXT, true);\n+                                    }\n+                                }\n+                                ev.consume();\n+                                break;\n+                            }\n+                            case DOWN:\n+                            \/\/case SPACE:\n+                            \/\/case ENTER:\n+                                \/\/ RT-18859: Doing nothing for space and enter\n+                                if (control.getScene().getWindow().isFocused()) {\n+                                    if (focusedMenuIndex != -1) {\n+                                        Menu menuToOpen = getSkinnable().getMenus().get(focusedMenuIndex);\n+                                        showMenu(menuToOpen, true);\n+                                        ev.consume();\n+                                    }\n+                                }\n+                                break;\n+                            case ESCAPE:\n+                                unSelectMenus();\n+                                ev.consume();\n+                                break;\n+                        default:\n+                            break;\n+                        }\n+                    }\n+                });\n+\n+                \/\/ When we click else where in the scene - menu selection should be cleared.\n+                sceneListenerHelper.addWeakEventFilter(scene, MouseEvent.MOUSE_CLICKED, (ev) -> {\n+                    Bounds containerScreenBounds = container.localToScreen(container.getLayoutBounds());\n+                    if ((containerScreenBounds == null) || !containerScreenBounds.contains(ev.getScreenX(), ev.getScreenY())) {\n+                        unSelectMenus();\n+                    }\n+                });\n+\n+                \/\/ When the parent window looses focus - menu selection should be cleared\n+                sceneListenerHelper.addWeakChangeListener(scene.windowProperty(), true, (sr,oldw,w) -> {\n+                    if(windowFocusHelper != null) {\n+                        windowFocusHelper.disconnect();\n+                        windowFocusHelper = null;\n+                    }\n+                    \n+                    if(w != null) {\n+                        windowFocusHelper = sceneListenerHelper.addWeakChangeListener(w.focusedProperty(), true, (sr2, oldf, focused) -> {\n+                            if (!focused) {\n+                                unSelectMenus();\n+                            }\n+                        });\n+                    }\n+                });\n+\n+                sceneListenerHelper.addWeakEventFilter(scene, KeyEvent.ANY, (ev) -> {\n+                        \/\/ Clear menu selection when ALT is pressed by itself\n+                    if (ev.getEventType() == KeyEvent.KEY_PRESSED) {\n+                        altKeyPressed = false;\n+                        if (ev.getCode() == KeyCode.ALT && !ev.isConsumed()) {\n+                            if (focusedMenuIndex == -1) {\n+                                altKeyPressed = true;\n+                            }\n+                            unSelectMenus();\n+                        }\n+                    } else if (ev.getEventType() == KeyEvent.KEY_RELEASED) {\n+                        \/\/ Put focus on the first menu when ALT is released\n+                        \/\/ directly after being pressed by itself\n+                        if (altKeyPressed && ev.getCode() == KeyCode.ALT && !ev.isConsumed()) {\n+                            firstMenuRunnable.run();\n+                        }\n+                        altKeyPressed = false;\n+                    }\n+                });\n+                \n+                \/\/ F10 accelerator\n+                scene.getAccelerators().put(acceleratorKeyCombo, firstMenuRunnable);\n+                sceneListenerHelper.addDisconnectable(() -> {\n+                    scene.getAccelerators().remove(acceleratorKeyCombo);\n+                });\n@@ -447,3 +414,1 @@\n-        };\n-        weakSceneChangeListener2 = new WeakChangeListener(sceneChangeListener2);\n-        control.sceneProperty().addListener(weakSceneChangeListener2);\n+        });\n@@ -693,0 +658,8 @@\n+        listenerHelper.disconnect();\n+        listenerHelper = null;\n+\n+        if (sceneListenerHelper != null) {\n+            sceneListenerHelper.disconnect();\n+            sceneListenerHelper = null;\n+        }\n+\n@@ -696,0 +669,1 @@\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/MenuBarSkin.java","additions":145,"deletions":171,"binary":false,"changes":316,"status":"modified"}]}