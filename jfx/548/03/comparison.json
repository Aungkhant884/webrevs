{"files":[{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene;\n+\n+import com.sun.javafx.sg.prism.NGNode;\n+import com.sun.javafx.util.Utils;\n+\n+import javafx.scene.DirectionalLight;\n+import javafx.scene.Node;\n+\n+\/**\n+ * Used to access internal methods of DirectionalLight.\n+ *\/\n+public class DirectionalLightHelper extends LightBaseHelper {\n+\n+    private static final DirectionalLightHelper theInstance;\n+    private static DirectionalLightAccessor directionalLightAccessor;\n+\n+    static {\n+        theInstance = new DirectionalLightHelper();\n+        Utils.forceInit(DirectionalLight.class);\n+    }\n+\n+    private static DirectionalLightHelper getInstance() {\n+        return theInstance;\n+    }\n+\n+    public static void initHelper(DirectionalLight directionalLight) {\n+        setHelper(directionalLight, getInstance());\n+    }\n+\n+    @Override\n+    protected NGNode createPeerImpl(Node node) {\n+        return directionalLightAccessor.doCreatePeer(node);\n+    }\n+\n+    @Override\n+    protected void updatePeerImpl(Node node) {\n+        super.updatePeerImpl(node);\n+        directionalLightAccessor.doUpdatePeer(node);\n+    }\n+\n+    public static void setDirectionalLightAccessor(final DirectionalLightAccessor newAccessor) {\n+        if (directionalLightAccessor != null) {\n+            throw new IllegalStateException(\"Accessor already exists\");\n+        }\n+\n+        directionalLightAccessor = newAccessor;\n+    }\n+\n+    public interface DirectionalLightAccessor {\n+        NGNode doCreatePeer(Node node);\n+        void doUpdatePeer(Node node);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/DirectionalLightHelper.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.sg.prism;\n+\n+import com.sun.javafx.geom.Vec3d;\n+\n+import javafx.geometry.Point3D;\n+\n+\/**\n+ * The peer of the {@code DirectionalLight} class. Holds the default values of {@code DirectionalLight}'s\n+ * properties and updates the visuals via {@link NGNode#visualsChanged} when one of the current\n+ * values changes. The peer receives its changes by {@link javafx.scene.DirectionalLight#doUpdatePeer} calls.\n+ *\/\n+public class NGDirectionalLight extends NGLightBase {\n+\n+    \/** Direction default value *\/\n+    private static final Point3D DEFAULT_DIRECTION = new Point3D(0, 0, 1);\n+\n+    public NGDirectionalLight() {\n+    }\n+\n+    public static Point3D getDefaultDirection() {\n+        return DEFAULT_DIRECTION;\n+    }\n+\n+    private Point3D direction = DEFAULT_DIRECTION;\n+    private final Vec3d effectiveDir = new Vec3d();\n+\n+    public Point3D getDirection() {\n+        var dir = new Vec3d(direction.getX(), direction.getY(), direction.getZ());\n+        getWorldTransform().deltaTransform(dir, effectiveDir);\n+        return new Point3D(effectiveDir.x, effectiveDir.y, effectiveDir.z);\n+    }\n+\n+    public void setDirection(Point3D direction) {\n+        if (!this.direction.equals(direction)) {\n+            this.direction = direction;\n+            visualsChanged();\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/sg\/prism\/NGDirectionalLight.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -28,4 +28,0 @@\n-import javafx.application.ConditionalFeature;\n-import javafx.application.Platform;\n-import javafx.scene.shape.CullFace;\n-import javafx.scene.shape.DrawMode;\n@@ -33,0 +29,1 @@\n+import com.sun.javafx.geom.Vec3f;\n@@ -40,0 +37,6 @@\n+import javafx.application.ConditionalFeature;\n+import javafx.application.Platform;\n+import javafx.geometry.Point3D;\n+import javafx.scene.shape.CullFace;\n+import javafx.scene.shape.DrawMode;\n+\n@@ -133,0 +136,1 @@\n+                    1,\n@@ -189,0 +193,1 @@\n+                            1,\n@@ -196,0 +201,12 @@\n+                } else if (lightBase instanceof NGDirectionalLight) {\n+                    var light = (NGDirectionalLight) lightBase;\n+                    meshView.setLight(lightIndex++,\n+                            0, 0, 0,                 \/\/ position is irrelevant\n+                            rL, gL, bL, 1.0f,\n+                            1, 0, 0,                 \/\/ attenuation is irrelevant\n+                            0,\n+                            Float.POSITIVE_INFINITY, \/\/ range is irrelevant\n+                            (float) light.getDirection().getX(),\n+                            (float) light.getDirection().getY(),\n+                            (float) light.getDirection().getZ(),\n+                            0, 0, 0);                \/\/ spotlight factors are irrelevant\n@@ -214,2 +231,2 @@\n-                    1, 0, 0, 0, \/\/ ca la qa maxRange\n-                    0, 0, 0,    \/\/ dirX Y Z\n+                    1, 0, 0, 1, 0, \/\/ ca la qa isAttenuated maxRange\n+                    0, 0, 1,    \/\/ dirX Y Z\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/sg\/prism\/NGShape3D.java","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-            float ca, float la, float qa, float maxRange, float dirX, float dirY, float dirZ,\n+            float ca, float la, float qa, float isAttenuated, float maxRange, float dirX, float dirY, float dirZ,\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/MeshView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -478,1 +478,2 @@\n-            float maxRange, float dirX, float dirY, float dirZ, float innerAngle, float outerAngle, float falloff);\n+            float isAttenuated, float maxRange, float dirX, float dirY, float dirZ, float innerAngle, float outerAngle,\n+            float falloff);\n@@ -614,1 +615,1 @@\n-            float ca, float la, float qa, float maxRange, float dirX, float dirY, float dirZ,\n+            float ca, float la, float qa, float isAttenuated, float maxRange, float dirX, float dirY, float dirZ,\n@@ -616,1 +617,1 @@\n-        nSetLight(pContext, nativeMeshView, index, x, y, z, r, g, b, w,  ca, la, qa, maxRange,\n+        nSetLight(pContext, nativeMeshView, index, x, y, z, r, g, b, w,  ca, la, qa, isAttenuated, maxRange,\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/d3d\/D3DContext.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-            float ca, float la, float qa, float maxRange, float dirX, float dirY, float dirZ,\n+            float ca, float la, float qa, float isAttenuated, float maxRange, float dirX, float dirY, float dirZ,\n@@ -90,1 +90,1 @@\n-            context.setLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, maxRange,\n+            context.setLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, isAttenuated, maxRange,\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/d3d\/D3DMeshView.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -453,1 +453,1 @@\n-            float ca, float la, float qa, float maxRange, float dirX, float dirY, float dirZ,\n+            float ca, float la, float qa, float isAttenuated, float maxRange, float dirX, float dirY, float dirZ,\n@@ -455,2 +455,2 @@\n-        glContext.setLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, maxRange, dirX, dirY, dirZ,\n-                innerAngle, outerAngle, falloff);\n+        glContext.setLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, isAttenuated,\n+                maxRange, dirX, dirY, dirZ, innerAngle, outerAngle, falloff);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/ES2Context.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-    float ca, la, qa, maxRange;\n+    float ca, la, qa, isAttenuated;\n+    float maxRange;\n@@ -40,1 +41,2 @@\n-            float maxRange, float dirX, float dirY, float dirZ, float innerAngle, float outerAngle, float falloff) {\n+            float isAttenuated, float maxRange, float dirX, float dirY, float dirZ,\n+            float innerAngle, float outerAngle, float falloff) {\n@@ -51,0 +53,1 @@\n+        this.isAttenuated = isAttenuated;\n@@ -61,1 +64,5 @@\n-        return falloff == 0 && outerAngle == 180;\n+        return falloff == 0 && outerAngle == 180 && isAttenuated > 0.5;\n+    }\n+\n+    boolean isDirectionalLight() {\n+        return isAttenuated < 0.5;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/ES2Light.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-            float ca, float la, float qa, float maxRange, float dirX, float dirY, float dirZ,\n+            float ca, float la, float qa, float isAttenuated, float maxRange, float dirX, float dirY, float dirZ,\n@@ -109,4 +109,4 @@\n-            lights[index] = new ES2Light(x, y, z, r, g, b, w, ca, la, qa, maxRange, dirX, dirY, dirZ, innerAngle,\n-                        outerAngle, falloff);\n-            context.setLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, maxRange, dirX, dirY, dirZ,\n-                    innerAngle, outerAngle, falloff);\n+            lights[index] = new ES2Light(x, y, z, r, g, b, w, ca, la, qa, isAttenuated,\n+                    maxRange, dirX, dirY, dirZ, innerAngle, outerAngle, falloff);\n+            context.setLight(nativeHandle, index, x, y, z, r, g, b, w, ca, la, qa, isAttenuated,\n+                    maxRange, dirX, dirY, dirZ, innerAngle, outerAngle, falloff);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/ES2MeshView.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -217,1 +217,1 @@\n-        shader.setConstant(\"lights[\" + i + \"].attn\", light.ca, light.la, light.qa);\n+        shader.setConstant(\"lights[\" + i + \"].attn\", light.ca, light.la, light.qa, light.isAttenuated);\n@@ -221,3 +221,0 @@\n-            shader.setConstant(\"lights[\" + i + \"].cosOuter\", -1f); \/\/ cos(180)\n-            shader.setConstant(\"lights[\" + i + \"].denom\", 2f);     \/\/ cos(0) - cos(180)\n-            shader.setConstant(\"lights[\" + i + \"].falloff\", 0f);\n@@ -230,0 +227,6 @@\n+        }\n+        if (light.isPointLight() || light.isDirectionalLight()) {\n+            shader.setConstant(\"lights[\" + i + \"].cosOuter\", -1f); \/\/ cos(180)\n+            shader.setConstant(\"lights[\" + i + \"].denom\", 2f);     \/\/ cos(0) - cos(180)\n+            shader.setConstant(\"lights[\" + i + \"].falloff\", 0f);\n+        } else {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/ES2PhongShader.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -256,1 +256,2 @@\n-            float maxRange, float dirX, float dirY, float dirZ, float innerAngle, float outerAngle, float falloff);\n+            float isAttenuated, float maxRange, float dirX, float dirY, float dirZ,\n+            float innerAngle, float outerAngle, float falloff);\n@@ -813,1 +814,1 @@\n-            float ca, float la, float qa, float maxRange, float dirX, float dirY, float dirZ,\n+            float ca, float la, float qa, float isAttenuated, float maxRange, float dirX, float dirY, float dirZ,\n@@ -815,2 +816,2 @@\n-        nSetLight(nativeCtxInfo, nativeMeshViewInfo, index, x, y, z, r, g, b, w, ca, la, qa, maxRange,\n-                dirX, dirY, dirZ, innerAngle, outerAngle, falloff);\n+        nSetLight(nativeCtxInfo, nativeMeshViewInfo, index, x, y, z, r, g, b, w, ca, la, qa, isAttenuated,\n+                maxRange, dirX, dirY, dirZ, innerAngle, outerAngle, falloff);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/es2\/GLContext.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.scene;\n+\n+import com.sun.javafx.scene.DirectionalLightHelper;\n+import com.sun.javafx.scene.DirtyBits;\n+import com.sun.javafx.scene.NodeHelper;\n+import com.sun.javafx.sg.prism.NGDirectionalLight;\n+import com.sun.javafx.sg.prism.NGNode;\n+\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.geometry.Point3D;\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.PhongMaterial;\n+\n+\/**\n+ * A light that illuminates an object from a specific direction.\n+ * The direction is defined by the {@link #directionProperty() direction} vector property of the light. The direction\n+ * can be rotated by setting a rotation transform on the {@code DirectionalLight}. For example, if the direction vector\n+ * is {@code (1, 1, 1)} and the light is not rotated, it will point in the {@code (1, 1, 1)} direction, and if the light\n+ * is rotated 90 degrees on the y axis, it will point in the {@code (1, 1, -1)} direction.\n+ * <p>\n+ * {@code DirectionalLight}s can represent strong light sources that are far enough from the objects they illuminate\n+ * that their light rays appear to be parallel. Because these light sources are considered to be infinitely far, they\n+ * cannot be attenuated. A decrease in intensity can be achieved by using a darker color. The sun is a common light\n+ * source that can be simulated with this light type.\n+ *\n+ * @since 18\n+ * @see PhongMaterial\n+ *\/\n+public class DirectionalLight extends LightBase {\n+    static {\n+        DirectionalLightHelper.setDirectionalLightAccessor(new DirectionalLightHelper.DirectionalLightAccessor() {\n+            @Override\n+            public NGNode doCreatePeer(Node node) {\n+                return ((DirectionalLight) node).doCreatePeer();\n+            }\n+\n+            @Override\n+            public void doUpdatePeer(Node node) {\n+                ((DirectionalLight) node).doUpdatePeer();\n+            }\n+        });\n+    }\n+\n+    {\n+        \/\/ To initialize the class helper at the beginning of each constructor of this class\n+        DirectionalLightHelper.initHelper(this);\n+    }\n+\n+    \/**\n+     * Creates a new {@code DirectionalLight} with a default {@code Color.WHITE} color.\n+     *\/\n+    public DirectionalLight() {\n+    }\n+\n+    \/**\n+     * Creates a new {@code DirectionalLight} with the specified color.\n+     *\n+     * @param color the color of the light source\n+     *\/\n+    public DirectionalLight(Color color) {\n+        super(color);\n+    }\n+\n+\n+    \/**\n+     * The direction vector of the directional light. It can be rotated by setting a rotation transform on the\n+     * {@code DirectionalLight}. The vector need not be normalized.\n+     *\n+     * @defaultValue {@code Point3D(0, 0, 1)}\n+     *\/\n+    private ObjectProperty<Point3D> direction;\n+\n+    public final void setDirection(Point3D value) {\n+        directionProperty().set(value);\n+    }\n+\n+    private static final Point3D DEFAULT_DIRECTION = NGDirectionalLight.getDefaultDirection();\n+\n+    public final Point3D getDirection() {\n+        return direction == null ? DEFAULT_DIRECTION : direction.get();\n+    }\n+\n+    public final ObjectProperty<Point3D> directionProperty() {\n+        if (direction == null) {\n+            direction = new SimpleObjectProperty<>(this, \"direction\", DEFAULT_DIRECTION) {\n+                @Override\n+                protected void invalidated() {\n+                    NodeHelper.markDirty(DirectionalLight.this, DirtyBits.NODE_LIGHT);\n+                }\n+            };\n+        }\n+        return direction;\n+    }\n+\n+\n+    \/*\n+     * Note: This method MUST only be called via its accessor method.\n+     *\/\n+    private NGNode doCreatePeer() {\n+        return new NGDirectionalLight();\n+    }\n+\n+    private void doUpdatePeer() {\n+        if (isDirty(DirtyBits.NODE_LIGHT)) {\n+            NGDirectionalLight peer = getPeer();\n+            peer.setDirection(getDirection());\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/DirectionalLight.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -515,1 +515,1 @@\n- * Signature: (JJIFFFFFFFFFFFFFFFFF)V\n+ * Signature: (JJIFFFFFFFFFFFFFFFFFF)V\n@@ -520,1 +520,1 @@\n-        jfloat ca, jfloat la, jfloat qa, jfloat range,\n+        jfloat ca, jfloat la, jfloat qa, jfloat isAttenuated, jfloat range,\n@@ -526,1 +526,2 @@\n-    meshView->setLight(index, x, y, z, r, g, b, w, ca, la, qa, range, dirX, dirY, dirZ, innerAngle, outerAngle, falloff);\n+    meshView->setLight(index, x, y, z, r, g, b, w, ca, la, qa, isAttenuated, range, dirX, dirY, dirZ,\n+            innerAngle, outerAngle, falloff);\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DContext.cc","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -50,1 +50,5 @@\n-    return falloff == 0 && outerAngle == 180;\n+    return falloff == 0 && outerAngle == 180 && attenuation[3] > 0.5;\n+}\n+\n+bool D3DLight::isDirectionalLight() {\n+    return attenuation[3] < 0.5;\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DLight.cc","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+    bool isDirectionalLight();\n@@ -44,1 +45,1 @@\n-    float attenuation[3]; \/\/ ca, la, qa\n+    float attenuation[4]; \/\/ ca, la, qa, isAttenuated\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DLight.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-        float ca, float la, float qa, float maxRange,\n+        float ca, float la, float qa, float isAttenuated, float maxRange,\n@@ -92,0 +92,1 @@\n+        light.attenuation[3] = isAttenuated;\n@@ -196,1 +197,1 @@\n-    float lightsAttenuation[MAX_NUM_LIGHTS * 4];  \/\/ 3 lights x (3 attenuation factors + 1 padding)\n+    float lightsAttenuation[MAX_NUM_LIGHTS * 4];  \/\/ 3 lights x (3 attenuation factors + 1 isAttenuated)\n@@ -209,1 +210,1 @@\n-        lightsAttenuation[a++] = 0;\n+        lightsAttenuation[a++] = lights[i].attenuation[3];\n@@ -216,1 +217,1 @@\n-        if (lights[i].isPointLight()) {\n+        if (lights[i].isPointLight() || lights[i].isDirectionalLight()) {\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DMeshView.cc","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-        float ca, float la, float qa, float maxRange,\n+        float ca, float la, float qa, float isAttenuated, float maxRange,\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/D3DMeshView.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-float4 gLightAttenuation[numMaxLights] : register(c9);\n+float4 gLightAttenuation[numMaxLights] : register(c9);  \/\/ {constant, linear, quadratic, on == 1 \/ off == 0}\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/psConstants.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,0 +106,5 @@\n+    if (gLightAttenuation[i].w < 0.5) {\n+        d += saturate(dot(n, -lightDir)) * gLightColor[i].xyz;\n+        s += pow(saturate(dot(-refl, -lightDir)), specPower) * gLightColor[i].xyz;\n+        return;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-d3d\/hlsl\/psMath.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2128,0 +2128,1 @@\n+    meshViewInfo->lightAttenuation[3] = 1;\n@@ -2274,1 +2275,1 @@\n- * Signature: (JJIFFFFFFFFFFFFFFFFF)V\n+ * Signature: (JJIFFFFFFFFFFFFFFFFFF)V\n@@ -2279,1 +2280,1 @@\n-        jfloat ca, jfloat la, jfloat qa, jfloat maxRange, jfloat dirX, jfloat dirY, jfloat dirZ,\n+        jfloat ca, jfloat la, jfloat qa, jfloat isAttenuated, jfloat maxRange, jfloat dirX, jfloat dirY, jfloat dirZ,\n@@ -2299,0 +2300,1 @@\n+    meshViewInfo->lightAttenuation[3] = isAttenuated;\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-es2\/GLContext.c","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-    GLfloat lightAttenuation[3];\n+    GLfloat lightAttenuation[4];\n","filename":"modules\/javafx.graphics\/src\/main\/native-prism-es2\/PrismES2Defs.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    vec3 attn;\n+    vec4 attn;\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/prism\/es2\/glsl\/main.vert","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    vec3 attn;\n+    vec4 attn;\n@@ -121,0 +121,7 @@\n+    vec3 lightDir = lightTangentSpaceDirections[i].xyz;\n+    if (light.attn.w < 0.5) {\n+        d += clamp(dot(n, -lightDir), 0.0, 1.0) * light.color.rgb;\n+        s += pow(clamp(dot(-refl, -lightDir), 0.0, 1.0), specPower) * light.color.rgb;\n+        return;\n+    }\n+\n@@ -128,1 +135,0 @@\n-    vec3 lightDir = lightTangentSpaceDirections[i].xyz;\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/prism\/es2\/glsl\/main1Light.frag","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    vec3 attn;\n+    vec4 attn;\n@@ -121,0 +121,7 @@\n+    vec3 lightDir = lightTangentSpaceDirections[i].xyz;\n+    if (light.attn.w < 0.5) {\n+        d += clamp(dot(n, -lightDir), 0.0, 1.0) * light.color.rgb;\n+        s += pow(clamp(dot(-refl, -lightDir), 0.0, 1.0), specPower) * light.color.rgb;\n+        return;\n+    }\n+\n@@ -128,1 +135,0 @@\n-    vec3 lightDir = lightTangentSpaceDirections[i].xyz;\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/prism\/es2\/glsl\/main2Lights.frag","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    vec3 attn;\n+    vec4 attn;\n@@ -121,0 +121,7 @@\n+    vec3 lightDir = lightTangentSpaceDirections[i].xyz;\n+    if (light.attn.w < 0.5) {\n+        d += clamp(dot(n, -lightDir), 0.0, 1.0) * light.color.rgb;\n+        s += pow(clamp(dot(-refl, -lightDir), 0.0, 1.0), specPower) * light.color.rgb;\n+        return;\n+    }\n+\n@@ -128,1 +135,0 @@\n-    vec3 lightDir = lightTangentSpaceDirections[i].xyz;\n","filename":"modules\/javafx.graphics\/src\/main\/resources\/com\/sun\/prism\/es2\/glsl\/main3Lights.frag","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.List;\n+\n@@ -30,0 +32,2 @@\n+import javafx.beans.property.ObjectProperty;\n+import javafx.collections.ObservableList;\n@@ -31,0 +35,2 @@\n+import javafx.scene.DirectionalLight;\n+import javafx.scene.Node;\n@@ -39,0 +45,1 @@\n+import javafx.scene.transform.Transform;\n@@ -63,0 +70,14 @@\n+        vbox.getChildren().addAll(ia, oa, fo);\n+\n+        List<Node> directionControls = createDirectionControls(light.getTransforms(), light.directionProperty());\n+        vbox.getChildren().addAll(directionControls);\n+        return vbox;\n+    }\n+\n+    @Override\n+    protected VBox addDirectionalLightControls(DirectionalLight light) {\n+        var vbox = super.addLightControls(light);\n+        List<Node> directionControls = createDirectionControls(light.getTransforms(), light.directionProperty());\n+        vbox.getChildren().addAll(directionControls);\n+        return vbox;\n+    }\n@@ -64,0 +85,1 @@\n+    private List<Node> createDirectionControls(ObservableList<Transform> transforms, ObjectProperty<Point3D> directionProperty) {\n@@ -67,1 +89,1 @@\n-        light.getTransforms().addAll(transX, transY, transZ);\n+        transforms.addAll(transX, transY, transZ);\n@@ -72,4 +94,4 @@\n-        var sliderX = createSlider(-5, 5, light.getDirection().getX());\n-        var sliderY = createSlider(-5, 5, light.getDirection().getY());\n-        var sliderZ = createSlider(-5, 5, light.getDirection().getZ());\n-        light.directionProperty().bind(Bindings.createObjectBinding(() ->\n+        var sliderX = createSlider(-5, 5, directionProperty.get().getX());\n+        var sliderY = createSlider(-5, 5, directionProperty.get().getY());\n+        var sliderZ = createSlider(-5, 5, directionProperty.get().getZ());\n+        directionProperty.bind(Bindings.createObjectBinding(() ->\n@@ -82,2 +104,1 @@\n-        vbox.getChildren().addAll(ia, oa, fo, rotX, rotY, rotZ, dirX, dirY, dirZ);\n-        return vbox;\n+        return List.of(rotX, rotY, rotZ, dirX, dirY, dirZ);\n","filename":"tests\/performance\/3DLighting\/attenuation\/AttenLightingSample.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import javafx.scene.DirectionalLight;\n@@ -50,0 +51,3 @@\n+    private final DirectionalLight directionalLight1 = new DirectionalLight(Color.RED);\n+    private final DirectionalLight directionalLight2 = new DirectionalLight(Color.BLUE);\n+    private final DirectionalLight directionalLight3 = new DirectionalLight(Color.MAGENTA);\n@@ -56,1 +60,2 @@\n-    final LightBase[] lights = {pointLight1, pointLight2, pointLight3, spotLight1, spotLight2, spotLight3};\n+    final LightBase[] lights = {directionalLight1, directionalLight2, directionalLight3,\n+            pointLight1, pointLight2, pointLight3, spotLight1, spotLight2, spotLight3};\n@@ -81,0 +86,6 @@\n+        directionalLight1.setDirection(new Point3D(-LIGHT_X_DIST, 0, LIGHT_Z_DIST));\n+        directionalLight2.setDirection(new Point3D(LIGHT_X_DIST, 0, LIGHT_Z_DIST));\n+\n+        directionalLight1.setUserData(\"RED\");\n+        directionalLight2.setUserData(\"BLUE\");\n+        directionalLight3.setUserData(\"MAGENTA\");\n","filename":"tests\/performance\/3DLighting\/attenuation\/Environment.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import javafx.scene.DirectionalLight;\n@@ -87,0 +88,2 @@\n+            } else if (light instanceof DirectionalLight) {\n+                vBox = addDirectionalLightControls((DirectionalLight) light);\n@@ -88,1 +91,3 @@\n-            controls.getChildren().add(new TitledPane(light.getUserData() + \" \" + light.getClass().getSimpleName(), vBox));\n+            var titlePane = new TitledPane(light.getUserData() + \" \" + light.getClass().getSimpleName(), vBox);\n+            titlePane.setExpanded(false);\n+            controls.getChildren().add(titlePane);\n@@ -158,0 +163,4 @@\n+    protected VBox addDirectionalLightControls(DirectionalLight light) {\n+        return addLightControls(light);\n+    }\n+\n","filename":"tests\/performance\/3DLighting\/attenuation\/LightingSample.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.lighting3D;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assume.assumeTrue;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import javafx.application.Application;\n+import javafx.application.ConditionalFeature;\n+import javafx.application.Platform;\n+import javafx.geometry.Point3D;\n+import javafx.scene.DirectionalLight;\n+import javafx.scene.paint.Color;\n+import test.util.Util;\n+\n+public class DirectionalLightTest extends LightingTest {\n+\n+    private static final Point3D[] DIRECTIONS = { new Point3D(0, 0, 1), new Point3D(0, 1, 1), new Point3D(0, 0, -1) };\n+\n+    private static final DirectionalLight LIGHT = new DirectionalLight(Color.BLUE);\n+\n+    public static void main(String[] args) throws Exception {\n+        initFX();\n+    }\n+\n+    @BeforeClass\n+    public static void initFX() throws Exception {\n+        startupLatch = new CountDownLatch(1);\n+        LightingTest.light = LIGHT;\n+        new Thread(() -> Application.launch(TestApp.class, (String[]) null)).start();\n+        assertTrue(\"Timeout waiting for FX runtime to start\", startupLatch.await(15, TimeUnit.SECONDS));\n+    }\n+\n+    @Before\n+    public void setupEach() {\n+        assumeTrue(Platform.isSupported(ConditionalFeature.SCENE3D));\n+    }\n+\n+    @Test\n+    public void testDirectionalLight() {\n+        Util.runAndWait(() -> {\n+            for (Point3D direction : DIRECTIONS) {\n+                LIGHT.setDirection(direction);\n+                double sampledBlue = snapshot().getPixelReader().getColor(0, 0).getBlue();\n+                assertEquals(FAIL_MESSAGE, dotProduct(direction), sampledBlue, DELTA);\n+            }\n+        });\n+    }\n+\n+    private double dotProduct(Point3D direction) {\n+        double value = -direction.normalize().dotProduct(0, 0, -1); \/\/ the normal of the front of the box is (0, 0, -1)\n+        return value < 0 ? 0 : value;\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/lighting3D\/DirectionalLightTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}