{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Objects;\n@@ -67,1 +68,6 @@\n-    private String MNEMONIC_SYMBOL = \"_\";\n+    private final char MNEMONIC_SYMBOL = '_';\n+\n+    \/**\n+     * The source text before mnemonic markup has been removed.\n+     *\/\n+    private String sourceText = null;\n@@ -156,1 +162,12 @@\n-        parseAndSplit(s);\n+        update(s);\n+    }\n+\n+    public void update(String s) {\n+        if (!Objects.equals(sourceText, s)) {\n+            sourceText = s;\n+            mnemonic = null;\n+            mnemonicKeyCombination = null;\n+            mnemonicIndex = -1;\n+            extendedMnemonicText = null;\n+            parseAndSplit(s);\n+        }\n@@ -168,20 +185,15 @@\n-        \/\/ We will use temp as a working copy of the string and will pull\n-        \/\/ mnemonic and accelerator text out of it as we find those things.\n-        \/\/\n-        StringBuffer temp = new StringBuffer(s);\n-\n-        \/\/ Find the mnemonic if it exists.\n-        \/\/\n-        int index = temp.indexOf(MNEMONIC_SYMBOL);\n-        while (index >= 0 && index < (temp.length() - 1)) {\n-            \/\/ Skip two _'s in a row\n-            if (MNEMONIC_SYMBOL.equals(temp.substring(index + 1, index + 2))) {\n-                temp.delete(index, index + 1); \/\/ delete the extra MNEMONIC_SYMBOL\n-            } else if (temp.charAt(index + 1) != '('\n-                       || index == temp.length() - 2) {\n-                mnemonic = temp.substring(index + 1, index + 2);\n-                if (mnemonic != null) {\n-                    mnemonicIndex = index;\n-                }\n-                temp.delete(index, index + 1);\n-                break;\n+        StringBuilder builder = new StringBuilder(s.length());\n+\n+        for (int i = 0, length = s.length(); i < length; ++i) {\n+            if (isEscapedMnemonicSymbol(s, i)) {\n+                builder.append(s.charAt(i++));\n+            } else if (isSimpleMnemonic(s, i)) {\n+                char c = s.charAt(i + 1);\n+                builder.append(c);\n+                mnemonic = String.valueOf(c);\n+                mnemonicIndex = i;\n+                i += 1;\n+            } else if (isExtendedMnemonic(s, i)) {\n+                mnemonic = String.valueOf(s.charAt(i + 2));\n+                extendedMnemonicText = s.substring(i + 1, i + 4);\n+                i += 3;\n@@ -189,14 +201,1 @@\n-                int endIndex = temp.indexOf(\")\", index + 3);\n-                if (endIndex == -1) { \/\/ \"(\" is actually the mnemonic\n-                    mnemonic = temp.substring(index + 1, index + 2);\n-                    if (mnemonic != null) {\n-                        mnemonicIndex = index;\n-                    }\n-                    temp.delete(index, index + 1);\n-                    break;\n-                } else if (endIndex == index + 3) {\n-                    mnemonic = temp.substring(index + 2, index + 3);\n-                    extendedMnemonicText = temp.substring(index + 1, index + 4);\n-                    temp.delete(index, endIndex + 3);\n-                    break;\n-                }\n+                builder.append(s.charAt(i));\n@@ -204,1 +203,0 @@\n-            index = temp.indexOf(MNEMONIC_SYMBOL, index + 1);\n@@ -206,1 +204,31 @@\n-        text = temp.toString();\n+\n+        text = builder.toString();\n+    }\n+\n+    \/**\n+     * Determines whether the string contains an escaped mnemonic symbol at the specified position.\n+     *\/\n+    private boolean isEscapedMnemonicSymbol(String s, int position) {\n+        return s.length() > position + 1\n+            && s.charAt(position) == MNEMONIC_SYMBOL\n+            && s.charAt(position + 1) == MNEMONIC_SYMBOL;\n+    }\n+\n+    \/**\n+     * Determines whether the string contains a simple mnemonic at the specified position.\n+     *\/\n+    private boolean isSimpleMnemonic(String s, int position) {\n+        return s.length() > position + 1\n+            && s.charAt(position) == MNEMONIC_SYMBOL\n+            && Character.isAlphabetic(s.charAt(position + 1));\n+    }\n+\n+    \/**\n+     * Determines whether the string contains an extended mnemonic at the specified position.\n+     *\/\n+    private boolean isExtendedMnemonic(String s, int position) {\n+        return s.length() > position + 3\n+            && s.charAt(position) == MNEMONIC_SYMBOL\n+            && s.charAt(position + 1) == '('\n+            && Character.isAlphabetic(s.charAt(position + 2))\n+            && s.charAt(position + 3) == ')';\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TextBinding.java","additions":67,"deletions":39,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n-import javafx.scene.control.Accordion;\n@@ -320,2 +319,2 @@\n-        String string = labeled.getText();\n-        boolean emptyText = string == null || string.isEmpty();\n+        String cleanText = getCleanText();\n+        boolean emptyText = cleanText == null || cleanText.isEmpty();\n@@ -330,6 +329,1 @@\n-            if (labeled.isMnemonicParsing()) {\n-                if (string.contains(\"_\") && (string.indexOf(\"_\") != string.length()-1)) {\n-                    string = string.replaceFirst(\"_\", \"\");\n-                }\n-            }\n-            textWidth = Utils.computeTextWidth(font, string, 0);\n+            textWidth = Utils.computeTextWidth(font, cleanText, 0);\n@@ -368,2 +362,2 @@\n-        String str = labeled.getText();\n-        if (str != null && str.endsWith(\"\\n\")) {\n+        String cleanText = getCleanText();\n+        if (cleanText != null && cleanText.endsWith(\"\\n\")) {\n@@ -371,1 +365,1 @@\n-            str = str.substring(0, str.length() - 1);\n+            cleanText = cleanText.substring(0, cleanText.length() - 1);\n@@ -381,1 +375,1 @@\n-        final double textHeight = Utils.computeTextHeight(font, str,\n+        final double textHeight = Utils.computeTextHeight(font, cleanText,\n@@ -742,4 +736,4 @@\n-                \/* Use the text in the binding if available to handle mnemonics *\/\n-                if (bindings != null) {\n-                    String text = bindings.getText();\n-                    if (text != null && !text.isEmpty()) return text;\n+                \/* Use the clean text, in which mnemonic symbols have been removed. *\/\n+                String cleanText = getCleanText();\n+                if (cleanText != null && !cleanText.isEmpty()) {\n+                    return cleanText;\n@@ -747,5 +741,0 @@\n-                \/* Avoid the content in text.getText() as it can contain ellipses\n-                 * for clipping\n-                 *\/\n-                String text = labeled.getText();\n-                if (text != null && !text.isEmpty()) return text;\n@@ -793,2 +782,2 @@\n-        final String string = labeled.getText();\n-        final boolean emptyText = string == null || string.isEmpty();\n+        final String cleanText = getCleanText();\n+        final boolean emptyText = cleanText == null || cleanText.isEmpty();\n@@ -801,1 +790,1 @@\n-                    textWidth = Utils.computeTextWidth(font, string.substring(0, 1), 0);\n+                    textWidth = Utils.computeTextWidth(font, cleanText.substring(0, 1), 0);\n@@ -806,1 +795,1 @@\n-                    textWidth = Utils.computeTextWidth(font, string, 0);\n+                    textWidth = Utils.computeTextWidth(font, cleanText, 0);\n@@ -841,3 +830,3 @@\n-        String str = labeled.getText();\n-        if (str != null && str.length() > 0) {\n-            int newlineIndex = str.indexOf('\\n');\n+        String cleanText = getCleanText();\n+        if (cleanText != null && cleanText.length() > 0) {\n+            int newlineIndex = cleanText.indexOf('\\n');\n@@ -845,1 +834,1 @@\n-                str = str.substring(0, newlineIndex);\n+                cleanText = cleanText.substring(0, newlineIndex);\n@@ -852,1 +841,1 @@\n-        final double textHeight = Utils.computeTextHeight(font, str, 0, s, text.getBoundsType());\n+        final double textHeight = Utils.computeTextHeight(font, cleanText, 0, s, text.getBoundsType());\n@@ -907,1 +896,1 @@\n-        if (containsMnemonic == true) {\n+        if (containsMnemonic) {\n@@ -958,2 +947,1 @@\n-            String s = labeled.getText();\n-\n+            String cleanText = getCleanText();\n@@ -962,18 +950,15 @@\n-            \/*\n-            ** if there's a valid string then parse it\n-            *\/\n-            if (s != null && s.length() > 0) {\n-                bindings = new TextBinding(s);\n-\n-                if (!com.sun.javafx.PlatformUtil.isMac() && getSkinnable().isMnemonicParsing() == true) {\n-                    \/*\n-                    ** the Labeled has a MnemonicParsing property,\n-                    ** if set true, then auto-parsing will check for\n-                    ** a mnemonic\n-                    *\/\n-                    if (labeled instanceof Label) {\n-                        \/\/ buttons etc\n-                        labeledNode = ((Label)labeled).getLabelFor();\n-                    } else {\n-                        labeledNode = labeled;\n-                    }\n+            if (cleanText != null && cleanText.length() > 0\n+                    && bindings != null\n+                    && !com.sun.javafx.PlatformUtil.isMac()\n+                    && getSkinnable().isMnemonicParsing()) {\n+                \/*\n+                ** the Labeled has a MnemonicParsing property,\n+                ** if set true, then auto-parsing will check for\n+                ** a mnemonic\n+                *\/\n+                if (labeled instanceof Label) {\n+                    \/\/ buttons etc\n+                    labeledNode = ((Label)labeled).getLabelFor();\n+                } else {\n+                    labeledNode = labeled;\n+                }\n@@ -981,4 +966,2 @@\n-                    if (labeledNode == null) {\n-                        labeledNode = labeled;\n-                    }\n-                    mnemonicIndex = bindings.getMnemonicIndex() ;\n+                if (labeledNode == null) {\n+                    labeledNode = labeled;\n@@ -986,0 +969,1 @@\n+                mnemonicIndex = bindings.getMnemonicIndex() ;\n@@ -1014,6 +998,5 @@\n-            if (s != null && s.length() > 0) {\n-                if (mnemonicIndex >= 0 && containsMnemonic == false) {\n-                    containsMnemonic = true;\n-                    mnemonicCode = bindings.getMnemonicKeyCombination();\n-                    addMnemonic();\n-                }\n+            if (cleanText != null && cleanText.length() > 0\n+                    && mnemonicIndex >= 0 && !containsMnemonic) {\n+                containsMnemonic = true;\n+                mnemonicCode = bindings.getMnemonicKeyCombination();\n+                addMnemonic();\n@@ -1022,2 +1005,1 @@\n-            if (containsMnemonic == true) {\n-                s = bindings.getText();\n+            if (containsMnemonic) {\n@@ -1035,18 +1017,5 @@\n-            } else {\n-                \/*\n-                ** we don't need a mnemonic....\n-                *\/\n-                if (getSkinnable().isMnemonicParsing() == true && com.sun.javafx.PlatformUtil.isMac() && bindings != null) {\n-                    s = bindings.getText();\n-                }\n-                else {\n-                    s = labeled.getText();\n-                }\n-                if (mnemonic_underscore != null) {\n-                    if (getChildren().contains(mnemonic_underscore)) {\n-                        Platform.runLater(() -> {\n-                              getChildren().remove(mnemonic_underscore);\n-                              mnemonic_underscore = null;\n-                        });\n-                    }\n-                }\n+            } else if (mnemonic_underscore != null && getChildren().contains(mnemonic_underscore)) {\n+                Platform.runLater(() -> {\n+                      getChildren().remove(mnemonic_underscore);\n+                      mnemonic_underscore = null;\n+                });\n@@ -1055,1 +1024,1 @@\n-            int len = s != null ? s.length() : 0;\n+            int len = cleanText != null ? cleanText.length() : 0;\n@@ -1058,2 +1027,2 @@\n-            if (s != null && len > 0) {\n-                int i = s.indexOf('\\n');\n+            if (cleanText != null && len > 0) {\n+                int i = cleanText.indexOf('\\n');\n@@ -1121,1 +1090,1 @@\n-                result = Utils.computeClippedWrappedText(font, s, wrapWidth, wrapHeight, labeled.getLineSpacing(), truncationStyle, ellipsisString, text.getBoundsType());\n+                result = Utils.computeClippedWrappedText(font, cleanText, wrapWidth, wrapHeight, labeled.getLineSpacing(), truncationStyle, ellipsisString, text.getBoundsType());\n@@ -1125,1 +1094,1 @@\n-                String[] splits = s.split(\"\\n\");\n+                String[] splits = cleanText.split(\"\\n\");\n@@ -1153,1 +1122,1 @@\n-                result = Utils.computeClippedText(font, s, wrapWidth, truncationStyle, ellipsisString);\n+                result = Utils.computeClippedText(font, cleanText, wrapWidth, truncationStyle, ellipsisString);\n@@ -1167,0 +1136,20 @@\n+    \/**\n+     * Gets the clean text, which is the source text after mnemonic symbols have been removed.\n+     *\/\n+    private String getCleanText() {\n+        Labeled labeled = getSkinnable();\n+        String sourceText = labeled.getText();\n+\n+        if (sourceText != null && labeled.isMnemonicParsing()) {\n+            if (bindings == null) {\n+                bindings = new TextBinding(sourceText);\n+            } else {\n+                bindings.update(sourceText);\n+            }\n+\n+            return bindings.getText();\n+        }\n+\n+        return sourceText;\n+    }\n+\n@@ -1218,1 +1207,1 @@\n-        final String txt = labeled.getText();\n+        final String txt = getCleanText();\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/LabeledSkinBase.java","additions":79,"deletions":90,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import javafx.scene.control.skin.LabelSkinBaseShim;\n@@ -2065,1 +2066,26 @@\n-    \/\/ tests for updateDisplayedText (not even sure how to test it exactly yet)\n+    @Test\n+    public void mnemonicSymbolIsRemovedFromDisplayedText() {\n+        label.setMnemonicParsing(true);\n+        label.setText(\"foo _bar\");\n+        label.autosize();\n+        skin.updateDisplayedText();\n+        assertEquals(\"foo bar\", LabelSkinBaseShim.getText(label).getText());\n+    }\n+\n+    @Test\n+    public void extendedMnemonicIsRemovedFromDisplayedText() {\n+        label.setMnemonicParsing(true);\n+        label.setText(\"foo _(x)bar\");\n+        label.autosize();\n+        skin.updateDisplayedText();\n+        assertEquals(\"foo bar\", LabelSkinBaseShim.getText(label).getText());\n+    }\n+\n+    @Test\n+    public void escapedMnemonicSymbolIsRetainedInDisplayedText() {\n+        label.setMnemonicParsing(true);\n+        label.setText(\"foo __bar\");\n+        label.autosize();\n+        skin.updateDisplayedText();\n+        assertEquals(\"foo _bar\", LabelSkinBaseShim.getText(label).getText());\n+    }\n@@ -2067,0 +2093,26 @@\n+    @Test\n+    public void escapedMnemonicSymbolIsNotProcessedWhenMnemonicParsingIsDisabled() {\n+        label.setMnemonicParsing(false);\n+        label.setText(\"foo __bar\");\n+        label.autosize();\n+        skin.updateDisplayedText();\n+        assertEquals(\"foo __bar\", LabelSkinBaseShim.getText(label).getText());\n+    }\n+\n+    @Test\n+    public void underscoreNotFollowedByAlphabeticCharIsNotAMnemonic() {\n+        label.setMnemonicParsing(true);\n+        label.setText(\"foo_ bar\");\n+        label.autosize();\n+        skin.updateDisplayedText();\n+        assertEquals(\"foo_ bar\", LabelSkinBaseShim.getText(label).getText());\n+    }\n+\n+    @Test\n+    public void underscoreAtEndOfTextIsNotAMnemonic() {\n+        label.setMnemonicParsing(true);\n+        label.setText(\"foo_\");\n+        label.autosize();\n+        skin.updateDisplayedText();\n+        assertEquals(\"foo_\", LabelSkinBaseShim.getText(label).getText());\n+    }\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/LabelSkinTest.java","additions":54,"deletions":2,"binary":false,"changes":56,"status":"modified"}]}