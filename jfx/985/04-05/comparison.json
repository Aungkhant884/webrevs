{"files":[{"patch":"@@ -0,0 +1,3396 @@\n+\/*\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.scene.control.skin;\n+\n+import com.sun.javafx.scene.ParentHelper;\n+import com.sun.javafx.scene.control.Logging;\n+import com.sun.javafx.scene.control.Properties;\n+import com.sun.javafx.scene.control.VirtualScrollBar;\n+import com.sun.javafx.scene.control.skin.Utils;\n+import com.sun.javafx.scene.traversal.Algorithm;\n+import com.sun.javafx.scene.traversal.Direction;\n+import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n+import com.sun.javafx.scene.traversal.TraversalContext;\n+import javafx.animation.KeyFrame;\n+import javafx.animation.Timeline;\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.Observable;\n+import javafx.beans.property.BooleanProperty;\n+import javafx.beans.property.BooleanPropertyBase;\n+import javafx.beans.property.DoubleProperty;\n+import javafx.beans.property.IntegerProperty;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.beans.property.SimpleDoubleProperty;\n+import javafx.beans.property.SimpleIntegerProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.beans.value.ChangeListener;\n+import javafx.collections.ObservableList;\n+import javafx.event.EventDispatcher;\n+import javafx.event.EventHandler;\n+import javafx.geometry.Orientation;\n+import javafx.scene.AccessibleRole;\n+import javafx.scene.Group;\n+import javafx.scene.Node;\n+import javafx.scene.Parent;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Cell;\n+import javafx.scene.control.IndexedCell;\n+import javafx.scene.control.ScrollBar;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.input.ScrollEvent;\n+import javafx.scene.layout.Region;\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.shape.Rectangle;\n+import javafx.util.Callback;\n+import javafx.util.Duration;\n+import com.sun.javafx.logging.PlatformLogger;\n+\n+import java.util.AbstractList;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.List;\n+\n+\/**\n+ * Implementation of a virtualized container using a cell based mechanism. This\n+ * is used by the skin implementations for UI controls such as\n+ * {@link javafx.scene.control.ListView}, {@link javafx.scene.control.TreeView},\n+ * {@link javafx.scene.control.TableView}, and {@link javafx.scene.control.TreeTableView}.\n+ *\n+ * @since 9\n+ *\/\n+public class VirtualFlow<T extends IndexedCell> extends Region {\n+\n+    \/* *************************************************************************\n+     *                                                                         *\n+     * Static fields                                                           *\n+     *                                                                         *\n+     **************************************************************************\/\n+\n+    \/**\n+     * Scroll events may request to scroll about a number of \"lines\". We first\n+     * decide how big one \"line\" is - for fixed cell size it's clear,\n+     * for variable cell size we settle on a single number so that the scrolling\n+     * speed is consistent. Now if the line is so big that\n+     * MIN_SCROLLING_LINES_PER_PAGE of them don't fit into one page, we make\n+     * them smaller to prevent the scrolling step to be too big (perhaps\n+     * even more than one page).\n+     *\/\n+    private static final int MIN_SCROLLING_LINES_PER_PAGE = 8;\n+\n+    \/**\n+     * Indicates that this is a newly created cell and we need call processCSS for it.\n+     *\n+     * See RT-23616 for more details.\n+     *\/\n+    private static final String NEW_CELL = \"newcell\";\n+\n+    private static final double GOLDEN_RATIO_MULTIPLIER = 0.618033987;\n+\n+    \/**\n+     * The default improvement for the estimation of the total size. A value\n+     * of x means that every time we need to estimate the size, we will add\n+     * x new cells that are not yet available into the calculations\n+     *\/\n+    private static final int DEFAULT_IMPROVEMENT = 2;\n+\n+\n+\n+    \/* *************************************************************************\n+     *                                                                         *\n+     * Private fields                                                          *\n+     *                                                                         *\n+     **************************************************************************\/\n+\n+    private boolean touchDetected = false;\n+    private boolean mouseDown = false;\n+\n+    \/**\n+     * The width of the VirtualFlow the last time it was laid out. We\n+     * use this information for several fast paths during the layout pass.\n+     *\/\n+    double lastWidth = -1;\n+\n+    \/**\n+     * The height of the VirtualFlow the last time it was laid out. We\n+     * use this information for several fast paths during the layout pass.\n+     *\/\n+    double lastHeight = -1;\n+\n+    \/**\n+     * The number of \"virtual\" cells in the flow the last time it was laid out.\n+     * For example, there may have been 1000 virtual cells, but only 20 actual\n+     * cells created and in use. In that case, lastCellCount would be 1000.\n+     *\/\n+    int lastCellCount = 0;\n+\n+    \/**\n+     * We remember the last value for vertical the last time we laid out the\n+     * flow. If vertical has changed, we will want to change the max & value\n+     * for the different scroll bars. Since we do all the scroll bar update\n+     * work in the layoutChildren function, we need to know what the old value for\n+     * vertical was.\n+     *\/\n+    boolean lastVertical;\n+\n+    \/**\n+     * The position last time we laid out. If none of the lastXXX vars have\n+     * changed respective to their values in layoutChildren, then we can just punt\n+     * out of the method (I hope...)\n+     *\/\n+    double lastPosition;\n+\n+    \/**\n+     * The breadth of the first visible cell last time we laid out.\n+     *\/\n+    double lastCellBreadth = -1;\n+\n+    \/**\n+     * The length of the first visible cell last time we laid out.\n+     *\/\n+    double lastCellLength = -1;\n+\n+    \/**\n+     * The list of cells representing those cells which actually make up the\n+     * current view. The cells are ordered such that the first cell in this\n+     * list is the first in the view, and the last cell is the last in the\n+     * view. When pixel scrolling, the list is simply shifted and items drop\n+     * off the beginning or the end, depending on the order of scrolling.\n+     * <p>\n+     * This is package private ONLY FOR TESTING\n+     *\/\n+    final ArrayLinkedList<T> cells = new ArrayLinkedList<>();\n+\n+    \/**\n+     * A structure containing cells that can be reused later. These are cells\n+     * that at one time were needed to populate the view, but now are no longer\n+     * needed. We keep them here until they are needed again.\n+     * <p>\n+     * This is package private ONLY FOR TESTING\n+     *\/\n+    final ArrayLinkedList<T> pile = new ArrayLinkedList<>();\n+\n+    \/**\n+     * A special cell used to accumulate bounds, such that we reduce object\n+     * churn. This cell must be recreated whenever the cell factory function\n+     * changes. This has package access ONLY for testing.\n+     *\/\n+    T accumCell;\n+\n+    \/**\n+     * This group is used for holding the 'accumCell'. 'accumCell' must\n+     * be added to the skin for it to be styled. Otherwise, it doesn't\n+     * report the correct width\/height leading to issues when scrolling\n+     * the flow\n+     *\/\n+    Group accumCellParent;\n+\n+    \/**\n+     * The group which holds the cells.\n+     *\/\n+    final Group sheet;\n+\n+    final ObservableList<Node> sheetChildren;\n+\n+    \/**\n+     * The scroll bar used for scrolling horizontally. This has package access\n+     * ONLY for testing.\n+     *\/\n+    private VirtualScrollBar hbar = new VirtualScrollBar(this);\n+\n+    \/**\n+     * The scroll bar used to scrolling vertically. This has package access\n+     * ONLY for testing.\n+     *\/\n+    private VirtualScrollBar vbar = new VirtualScrollBar(this);\n+\n+    \/**\n+     * Control in which the cell's sheet is placed and forms the viewport. The\n+     * viewportBreadth and viewportLength are simply the dimensions of the\n+     * clipView. This has package access ONLY for testing.\n+     *\/\n+    ClippedContainer clipView;\n+\n+    \/**\n+     * When both the horizontal and vertical scroll bars are visible,\n+     * we have to 'fill in' the bottom right corner where the two scroll bars\n+     * meet. This is handled by this corner region. This has package access\n+     * ONLY for testing.\n+     *\/\n+    StackPane corner;\n+\n+    \/**\n+     * The offset in pixels between the top of the virtualFlow and the content it\n+     * shows. When manipulating the position of the content (e.g. by scrolling),\n+     * the absoluteOffset must be changed so that it always returns the number of\n+     * pixels that, when applied to a translateY (for vertical) or translateX\n+     * (for horizontal) operation on each cell, the first cell aligns with the\n+     * node.\n+     * The following relation should always be true:\n+     * 0 <= absoluteOffset <= (estimatedSize - viewportLength)\n+     * Based on this relation, the position p is defined as\n+     * 0 <= absoluteOffset\/(estimatedSize - viewportLength) <= 1\n+     * As a consequence, whenever p, estimatedSize, or viewportLength\n+     * changes, the absoluteOffset needs to change as well.\n+     * The method <code>adjustAbsoluteOffset()<\/code> can be used to calculate the\n+     * value of <code>absoluteOffset<\/code> based on the value of the other 3\n+     * variables.\n+     * Vice versa, if we change the <code>absoluteOffset<\/code>, we need to make\n+     * sure that the <code>position<\/code> is changed in a consistent way. This\n+     * can be done by calling <code>adjustPosition()<\/code>\n+     *\/\n+    double absoluteOffset = 0d;\n+\n+    \/**\n+     * An estimation of the total size (height for vertical, width for horizontal).\n+     * A value of -1 means that this value is unusable and should not be trusted.\n+     * This might happen before any calculations take place, or when a method\n+     * invocation is guaranteed to invalidate the current estimation.\n+     *\/\n+    double estimatedSize = -1d;\n+\n+    \/**\n+     * A list containing the cached version of the calculated size (height for\n+     * vertical, width for horizontal) for a (fictive or real) cell for\n+     * each element of the backing data.\n+     * This list is used to calculate the estimatedSize.\n+     * The list is not expected to be complete, but it is always up to date.\n+     * When the size of the items in the backing list changes, this list is\n+     * cleared.\n+     *\/\n+    private ArrayList<Double> itemSizeCache = new ArrayList<>();\n+\n+    \/\/ used for panning the virtual flow\n+    private double lastX;\n+    private double lastY;\n+    private boolean isPanning = false;\n+\n+    private boolean fixedCellSizeEnabled = false;\n+\n+    private boolean needsReconfigureCells = false; \/\/ when cell contents are the same\n+    private boolean needsRecreateCells = false; \/\/ when cell factory changed\n+    private boolean needsRebuildCells = false; \/\/ when cell contents have changed\n+    private boolean needsCellsLayout = false;\n+    private boolean sizeChanged = false;\n+    private final BitSet dirtyCells = new BitSet();\n+\n+    Timeline sbTouchTimeline;\n+    KeyFrame sbTouchKF1;\n+    KeyFrame sbTouchKF2;\n+\n+    private boolean needBreadthBar;\n+    private boolean needLengthBar;\n+    private boolean tempVisibility = false;\n+    private boolean suppressBreadthBar;\n+\n+\n+    \/* *************************************************************************\n+     *                                                                         *\n+     * Constructors                                                            *\n+     *                                                                         *\n+     **************************************************************************\/\n+\n+    \/**\n+     * Creates a new VirtualFlow instance.\n+     *\/\n+    public VirtualFlow() {\n+        getStyleClass().add(\"virtual-flow\");\n+        setId(\"virtual-flow\");\n+\n+        \/\/ initContent\n+        \/\/ --- sheet\n+        sheet = new Group();\n+        sheet.getStyleClass().add(\"sheet\");\n+        sheet.setAutoSizeChildren(false);\n+\n+        sheetChildren = sheet.getChildren();\n+\n+        \/\/ --- clipView\n+        clipView = new ClippedContainer(this);\n+        clipView.setNode(sheet);\n+        getChildren().add(clipView);\n+\n+        \/\/ --- accumCellParent\n+        accumCellParent = new Group();\n+        accumCellParent.setVisible(false);\n+        getChildren().add(accumCellParent);\n+\n+\n+        \/*\n+        ** don't allow the ScrollBar to handle the ScrollEvent,\n+        ** In a VirtualFlow a vertical scroll should scroll on the vertical only,\n+        ** whereas in a horizontal ScrollBar it can scroll horizontally.\n+        *\/\n+        \/\/ block the event from being passed down to children\n+        final EventDispatcher blockEventDispatcher = (event, tail) -> event;\n+        \/\/ block ScrollEvent from being passed down to scrollbar's skin\n+        final EventDispatcher oldHsbEventDispatcher = hbar.getEventDispatcher();\n+        hbar.setEventDispatcher((event, tail) -> {\n+            if (event.getEventType() == ScrollEvent.SCROLL &&\n+                    !((ScrollEvent)event).isDirect()) {\n+                tail = tail.prepend(blockEventDispatcher);\n+                tail = tail.prepend(oldHsbEventDispatcher);\n+                return tail.dispatchEvent(event);\n+            }\n+            return oldHsbEventDispatcher.dispatchEvent(event, tail);\n+        });\n+        \/\/ block ScrollEvent from being passed down to scrollbar's skin\n+        final EventDispatcher oldVsbEventDispatcher = vbar.getEventDispatcher();\n+        vbar.setEventDispatcher((event, tail) -> {\n+            if (event.getEventType() == ScrollEvent.SCROLL &&\n+                    !((ScrollEvent)event).isDirect()) {\n+                tail = tail.prepend(blockEventDispatcher);\n+                tail = tail.prepend(oldVsbEventDispatcher);\n+                return tail.dispatchEvent(event);\n+            }\n+            return oldVsbEventDispatcher.dispatchEvent(event, tail);\n+        });\n+        \/*\n+        ** listen for ScrollEvents over the whole of the VirtualFlow\n+        ** area, the above dispatcher having removed the ScrollBars\n+        ** scroll event handling.\n+        *\/\n+        setOnScroll(new EventHandler<ScrollEvent>() {\n+            @Override public void handle(ScrollEvent event) {\n+                if (Properties.IS_TOUCH_SUPPORTED) {\n+                    if (touchDetected == false &&  mouseDown == false ) {\n+                        startSBReleasedAnimation();\n+                    }\n+                }\n+                \/*\n+                ** calculate the delta in the direction of the flow.\n+                *\/\n+                double virtualDelta = 0.0;\n+                if (isVertical()) {\n+                    switch(event.getTextDeltaYUnits()) {\n+                        case PAGES:\n+                            virtualDelta = event.getTextDeltaY() * lastHeight;\n+                            break;\n+                        case LINES:\n+                            double lineSize;\n+                            if (fixedCellSizeEnabled) {\n+                                lineSize = getFixedCellSize();\n+                            } else {\n+                                \/\/ For the scrolling to be reasonably consistent\n+                                \/\/ we set the lineSize to the average size\n+                                \/\/ of all currently loaded lines.\n+                                T lastCell = cells.getLast();\n+                                lineSize =\n+                                        (getCellPosition(lastCell)\n+                                            + getCellLength(lastCell)\n+                                            - getCellPosition(cells.getFirst()))\n+                                        \/ cells.size();\n+                            }\n+\n+                            if (lastHeight \/ lineSize < MIN_SCROLLING_LINES_PER_PAGE) {\n+                                lineSize = lastHeight \/ MIN_SCROLLING_LINES_PER_PAGE;\n+                            }\n+\n+                            virtualDelta = event.getTextDeltaY() * lineSize;\n+                            break;\n+                        case NONE:\n+                            virtualDelta = event.getDeltaY();\n+                    }\n+                } else { \/\/ horizontal\n+                    switch(event.getTextDeltaXUnits()) {\n+                        case CHARACTERS:\n+                            \/\/ can we get character size here?\n+                            \/\/ for now, fall through to pixel values\n+                        case NONE:\n+                            double dx = event.getDeltaX();\n+                            double dy = event.getDeltaY();\n+\n+                            virtualDelta = (Math.abs(dx) > Math.abs(dy) ? dx : dy);\n+                    }\n+                }\n+\n+                if (virtualDelta != 0.0) {\n+                    \/*\n+                    ** only consume it if we use it\n+                    *\/\n+                    double result = scrollPixels(-virtualDelta);\n+                    if (result != 0.0) {\n+                        event.consume();\n+                    }\n+                }\n+\n+                ScrollBar nonVirtualBar = isVertical() ? hbar : vbar;\n+                if (needBreadthBar) {\n+                    double nonVirtualDelta = isVertical() ? event.getDeltaX() : event.getDeltaY();\n+                    if (nonVirtualDelta != 0.0) {\n+                        double newValue = nonVirtualBar.getValue() - nonVirtualDelta;\n+                        if (newValue < nonVirtualBar.getMin()) {\n+                            nonVirtualBar.setValue(nonVirtualBar.getMin());\n+                        } else if (newValue > nonVirtualBar.getMax()) {\n+                            nonVirtualBar.setValue(nonVirtualBar.getMax());\n+                        } else {\n+                            nonVirtualBar.setValue(newValue);\n+                        }\n+                        event.consume();\n+                    }\n+                }\n+            }\n+        });\n+\n+\n+        addEventFilter(MouseEvent.MOUSE_PRESSED, new EventHandler<MouseEvent>() {\n+            @Override\n+            public void handle(MouseEvent e) {\n+                mouseDown = true;\n+                if (Properties.IS_TOUCH_SUPPORTED) {\n+                    scrollBarOn();\n+                }\n+                if (isFocusTraversable()) {\n+                    \/\/ We check here to see if the current focus owner is within\n+                    \/\/ this VirtualFlow, and if so we back-off from requesting\n+                    \/\/ focus back to the VirtualFlow itself. This is particularly\n+                    \/\/ relevant given the bug identified in RT-32869. In this\n+                    \/\/ particular case TextInputControl was clearing selection\n+                    \/\/ when the focus on the TextField changed, meaning that the\n+                    \/\/ right-click context menu was not showing the correct\n+                    \/\/ options as there was no selection in the TextField.\n+                    boolean doFocusRequest = true;\n+                    Node focusOwner = getScene().getFocusOwner();\n+                    if (focusOwner != null) {\n+                        Parent parent = focusOwner.getParent();\n+                        while (parent != null) {\n+                            if (parent.equals(VirtualFlow.this)) {\n+                                doFocusRequest = false;\n+                                break;\n+                            }\n+                            parent = parent.getParent();\n+                        }\n+                    }\n+\n+                    if (doFocusRequest) {\n+                        requestFocus();\n+                    }\n+                }\n+\n+                lastX = e.getX();\n+                lastY = e.getY();\n+\n+                \/\/ determine whether the user has push down on the virtual flow,\n+                \/\/ or whether it is the scrollbar. This is done to prevent\n+                \/\/ mouse events being 'doubled up' when dragging the scrollbar\n+                \/\/ thumb - it has the side-effect of also starting the panning\n+                \/\/ code, leading to flicker\n+                isPanning = ! (vbar.getBoundsInParent().contains(e.getX(), e.getY())\n+                        || hbar.getBoundsInParent().contains(e.getX(), e.getY()));\n+            }\n+        });\n+        addEventFilter(MouseEvent.MOUSE_RELEASED, e -> {\n+            mouseDown = false;\n+            if (Properties.IS_TOUCH_SUPPORTED) {\n+                startSBReleasedAnimation();\n+            }\n+        });\n+        addEventFilter(MouseEvent.MOUSE_DRAGGED, e -> {\n+            if (Properties.IS_TOUCH_SUPPORTED) {\n+                scrollBarOn();\n+            }\n+            if (! isPanning || ! isPannable()) return;\n+\n+            \/\/ With panning enabled, we support panning in both vertical\n+            \/\/ and horizontal directions, regardless of the fact that\n+            \/\/ VirtualFlow is virtual in only one direction.\n+            double xDelta = lastX - e.getX();\n+            double yDelta = lastY - e.getY();\n+\n+            \/\/ figure out the distance that the mouse moved in the virtual\n+            \/\/ direction, and then perform the movement along that axis\n+            \/\/ virtualDelta will contain the amount we actually did move\n+            double virtualDelta = isVertical() ? yDelta : xDelta;\n+            double actual = scrollPixels(virtualDelta);\n+            if (actual != 0) {\n+                \/\/ update last* here, as we know we've just adjusted the\n+                \/\/ scrollbar. This means we don't get the situation where a\n+                \/\/ user presses-and-drags a long way past the min or max\n+                \/\/ values, only to change directions and see the scrollbar\n+                \/\/ start moving immediately.\n+                if (isVertical()) lastY = e.getY();\n+                else lastX = e.getX();\n+            }\n+\n+            \/\/ similarly, we do the same in the non-virtual direction\n+            double nonVirtualDelta = isVertical() ? xDelta : yDelta;\n+            ScrollBar nonVirtualBar = isVertical() ? hbar : vbar;\n+            if (nonVirtualBar.isVisible()) {\n+                double newValue = nonVirtualBar.getValue() + nonVirtualDelta;\n+                if (newValue < nonVirtualBar.getMin()) {\n+                    nonVirtualBar.setValue(nonVirtualBar.getMin());\n+                } else if (newValue > nonVirtualBar.getMax()) {\n+                    nonVirtualBar.setValue(nonVirtualBar.getMax());\n+                } else {\n+                    nonVirtualBar.setValue(newValue);\n+\n+                    \/\/ same as the last* comment above\n+                    if (isVertical()) lastX = e.getX();\n+                    else lastY = e.getY();\n+                }\n+            }\n+        });\n+\n+        \/*\n+         * We place the scrollbars _above_ the rectangle, such that the drag\n+         * operations often used in conjunction with scrollbars aren't\n+         * misinterpreted as drag operations on the rectangle as well (which\n+         * would be the case if the scrollbars were underneath it as the\n+         * rectangle itself doesn't block the mouse.\n+         *\/\n+        \/\/ --- vbar\n+        vbar.setOrientation(Orientation.VERTICAL);\n+        vbar.addEventHandler(MouseEvent.ANY, event -> {\n+            event.consume();\n+        });\n+        getChildren().add(vbar);\n+\n+        \/\/ --- hbar\n+        hbar.setOrientation(Orientation.HORIZONTAL);\n+        hbar.addEventHandler(MouseEvent.ANY, event -> {\n+            event.consume();\n+        });\n+        getChildren().add(hbar);\n+\n+        \/\/ --- corner\n+        corner = new StackPane();\n+        corner.getStyleClass().setAll(\"corner\");\n+        getChildren().add(corner);\n+\n+\n+\n+        \/\/ initBinds\n+        \/\/ clipView binds\n+        InvalidationListener listenerX = valueModel -> {\n+            updateHbar();\n+        };\n+        verticalProperty().addListener(listenerX);\n+        hbar.valueProperty().addListener(listenerX);\n+        hbar.visibleProperty().addListener(listenerX);\n+        visibleProperty().addListener(listenerX);\n+        sceneProperty().addListener(listenerX);\n+\n+\/\/        ChangeListener listenerY = new ChangeListener() {\n+\/\/            @Override public void handle(Bean bean, PropertyReference property) {\n+\/\/                clipView.setClipY(isVertical() ? 0 : vbar.getValue());\n+\/\/            }\n+\/\/        };\n+\/\/        addChangedListener(VERTICAL, listenerY);\n+\/\/        vbar.addChangedListener(ScrollBar.VALUE, listenerY);\n+\n+        ChangeListener<Number> listenerY = (ov, t, t1) -> {\n+            clipView.setClipY(isVertical() ? 0 : vbar.getValue());\n+        };\n+        vbar.valueProperty().addListener(listenerY);\n+\n+        super.heightProperty().addListener((observable, oldHeight, newHeight) -> {\n+            \/\/ Fix for RT-8480, where the VirtualFlow does not show its content\n+            \/\/ after changing size to 0 and back.\n+            if (oldHeight.doubleValue() == 0 && newHeight.doubleValue() > 0) {\n+                recreateCells();\n+            }\n+        });\n+\n+\n+        \/*\n+        ** there are certain animations that need to know if the touch is\n+        ** happening.....\n+        *\/\n+        setOnTouchPressed(e -> {\n+            touchDetected = true;\n+            scrollBarOn();\n+        });\n+\n+        setOnTouchReleased(e -> {\n+            touchDetected = false;\n+            startSBReleasedAnimation();\n+        });\n+\n+        ParentHelper.setTraversalEngine(this, new ParentTraversalEngine(this, new Algorithm() {\n+\n+            Node selectNextAfterIndex(int index, TraversalContext context) {\n+                T nextCell;\n+                while ((nextCell = getVisibleCell(++index)) != null) {\n+                    if (nextCell.isFocusTraversable()) {\n+                        return nextCell;\n+                    }\n+                    Node n = context.selectFirstInParent(nextCell);\n+                    if (n != null) {\n+                        return n;\n+                    }\n+                }\n+                return null;\n+            }\n+\n+            Node selectPreviousBeforeIndex(int index, TraversalContext context) {\n+                T prevCell;\n+                while ((prevCell = getVisibleCell(--index)) != null) {\n+                    Node prev = context.selectLastInParent(prevCell);\n+                    if (prev != null) {\n+                        return prev;\n+                    }\n+                    if (prevCell.isFocusTraversable()) {\n+                        return prevCell;\n+                    }\n+                }\n+                return null;\n+            }\n+\n+            @Override\n+            public Node select(Node owner, Direction dir, TraversalContext context) {\n+                T cell;\n+                if (cells.isEmpty()) return null;\n+                if (cells.contains(owner)) {\n+                    cell = (T) owner;\n+                } else {\n+                    cell = findOwnerCell(owner);\n+                    Node next = context.selectInSubtree(cell, owner, dir);\n+                    if (next != null) {\n+                        return next;\n+                    }\n+                    if (dir == Direction.NEXT) dir = Direction.NEXT_IN_LINE;\n+                }\n+                int cellIndex = cell.getIndex();\n+                switch(dir) {\n+                    case PREVIOUS:\n+                        return selectPreviousBeforeIndex(cellIndex, context);\n+                    case NEXT:\n+                        Node n = context.selectFirstInParent(cell);\n+                        if (n != null) {\n+                            return n;\n+                        }\n+                        \/\/ Intentional fall-through\n+                    case NEXT_IN_LINE:\n+                        return selectNextAfterIndex(cellIndex, context);\n+                }\n+                return null;\n+            }\n+\n+            private T findOwnerCell(Node owner) {\n+                Parent p = owner.getParent();\n+                while (!cells.contains(p)) {\n+                    p = p.getParent();\n+                }\n+                return (T)p;\n+            }\n+\n+            @Override\n+            public Node selectFirst(TraversalContext context) {\n+                T firstCell = cells.getFirst();\n+                if (firstCell == null) return null;\n+                if (firstCell.isFocusTraversable()) return firstCell;\n+                Node n = context.selectFirstInParent(firstCell);\n+                if (n != null) {\n+                    return n;\n+                }\n+                return selectNextAfterIndex(firstCell.getIndex(), context);\n+            }\n+\n+            @Override\n+            public Node selectLast(TraversalContext context) {\n+                T lastCell = cells.getLast();\n+                if (lastCell == null) return null;\n+                Node p = context.selectLastInParent(lastCell);\n+                if (p != null) {\n+                    return p;\n+                }\n+                if (lastCell.isFocusTraversable()) return lastCell;\n+                return selectPreviousBeforeIndex(lastCell.getIndex(), context);\n+            }\n+        }));\n+    }\n+\n+\n+\n+    \/* *************************************************************************\n+     *                                                                         *\n+     * Properties                                                              *\n+     *                                                                         *\n+     **************************************************************************\/\n+\n+    \/**\n+     * There are two main complicating factors in the implementation of the\n+     * VirtualFlow, which are made even more complicated due to the performance\n+     * sensitive nature of this code. The first factor is the actual\n+     * virtualization mechanism, wired together with the PositionMapper.\n+     * The second complicating factor is the desire to do minimal layout\n+     * and minimal updates to CSS.\n+     *\n+     * Since the layout mechanism runs at most once per pulse, we want to hook\n+     * into this mechanism for minimal recomputation. Whenever a layout pass\n+     * is run we record the width\/height that the virtual flow was last laid\n+     * out to. In subsequent passes, if the width\/height has not changed then\n+     * we know we only have to rebuild the cells. If the width or height has\n+     * changed, then we can make appropriate decisions based on whether the\n+     * width \/ height has been reduced or expanded.\n+     *\n+     * In various places, if requestLayout is called it is generally just\n+     * used to indicate that some form of layout needs to happen (either the\n+     * entire thing has to be reconstructed, or just the cells need to be\n+     * reconstructed, generally).\n+     *\n+     * The accumCell is a special cell which is used in some computations\n+     * when an actual cell for that item isn't currently available. However,\n+     * the accumCell must be cleared whenever the cellFactory function is\n+     * changed because we need to use the cells that come from the new factory.\n+     *\n+     * In addition to storing the lastWidth and lastHeight, we also store the\n+     * number of cells that existed last time we performed a layout. In this\n+     * way if the number of cells change, we can request a layout and when it\n+     * occurs we can tell that the number of cells has changed and react\n+     * accordingly.\n+     *\n+     * Because the VirtualFlow can be laid out horizontally or vertically a\n+     * naming problem is present when trying to conceptualize and implement\n+     * the flow. In particular, the words \"width\" and \"height\" are not\n+     * precise when describing the unit of measure along the \"virtualized\"\n+     * axis and the \"orthogonal\" axis. For example, the height of a cell when\n+     * the flow is vertical is the magnitude along the \"virtualized axis\",\n+     * and the width is along the axis orthogonal to it.\n+     *\n+     * Since \"height\" and \"width\" are not reliable terms, we use the words\n+     * \"length\" and \"breadth\" to describe the magnitude of a cell along\n+     * the virtualized axis and orthogonal axis. For example, in a vertical\n+     * flow, the height=length and the width=breadth. In a horizontal axis,\n+     * the height=breadth and the width=length.\n+     *\n+     * These terms are somewhat arbitrary, but chosen so that when reading\n+     * most of the below code you can think in just one dimension, with\n+     * helper functions converting width\/height in to length\/breadth, while\n+     * also being different from width\/height so as not to get confused with\n+     * the actual width\/height of a cell.\n+     *\/\n+\n+    \/\/ --- vertical\n+    \/**\n+     * Indicates the primary direction of virtualization. If true, then the\n+     * primary direction of virtualization is vertical, meaning that cells will\n+     * stack vertically on top of each other. If false, then they will stack\n+     * horizontally next to each other.\n+     *\/\n+    private BooleanProperty vertical;\n+    public final void setVertical(boolean value) {\n+        verticalProperty().set(value);\n+    }\n+\n+    public final boolean isVertical() {\n+        return vertical == null ? true : vertical.get();\n+    }\n+\n+    public final BooleanProperty verticalProperty() {\n+        if (vertical == null) {\n+            vertical = new BooleanPropertyBase(true) {\n+                @Override protected void invalidated() {\n+                    pile.clear();\n+                    sheetChildren.clear();\n+                    cells.clear();\n+                    lastWidth = lastHeight = -1;\n+                    setMaxPrefBreadth(-1);\n+                    setViewportBreadth(0);\n+                    setViewportLength(0);\n+                    lastPosition = 0;\n+                    hbar.setValue(0);\n+                    vbar.setValue(0);\n+                    setPosition(0.0f);\n+                    setNeedsLayout(true);\n+                    requestLayout();\n+                }\n+\n+                @Override\n+                public Object getBean() {\n+                    return VirtualFlow.this;\n+                }\n+\n+                @Override\n+                public String getName() {\n+                    return \"vertical\";\n+                }\n+            };\n+        }\n+        return vertical;\n+    }\n+\n+    \/\/ --- pannable\n+    \/**\n+     * Indicates whether the VirtualFlow viewport is capable of being panned\n+     * by the user (either via the mouse or touch events).\n+     *\/\n+    private BooleanProperty pannable = new SimpleBooleanProperty(this, \"pannable\", true);\n+    public final boolean isPannable() { return pannable.get(); }\n+    public final void setPannable(boolean value) { pannable.set(value); }\n+    public final BooleanProperty pannableProperty() { return pannable; }\n+\n+    \/\/ --- cell count\n+    \/**\n+     * Indicates the number of cells that should be in the flow. The user of\n+     * the VirtualFlow must set this appropriately. When the cell count changes\n+     * the VirtualFlow responds by updating the visuals. If the items backing\n+     * the cells change, but the count has not changed, you must call the\n+     * reconfigureCells() function to update the visuals.\n+     *\/\n+    private IntegerProperty cellCount = new SimpleIntegerProperty(this, \"cellCount\", 0) {\n+        private int oldCount = 0;\n+\n+        @Override protected void invalidated() {\n+            int cellCount = get();\n+            resetSizeEstimates();\n+            recalculateEstimatedSize();\n+\n+            boolean countChanged = oldCount != cellCount;\n+            oldCount = cellCount;\n+\n+            \/\/ ensure that the virtual scrollbar adjusts in size based on the current\n+            \/\/ cell count.\n+            if (countChanged) {\n+                VirtualScrollBar lengthBar = isVertical() ? vbar : hbar;\n+                lengthBar.setMax(cellCount);\n+            }\n+\n+            \/\/ I decided *not* to reset maxPrefBreadth here for the following\n+            \/\/ situation. Suppose I have 30 cells and then I add 10 more. Just\n+            \/\/ because I added 10 more doesn't mean the max pref should be\n+            \/\/ reset. Suppose the first 3 cells were extra long, and I was\n+            \/\/ scrolled down such that they weren't visible. If I were to reset\n+            \/\/ maxPrefBreadth when subsequent cells were added or removed, then the\n+            \/\/ scroll bars would erroneously reset as well. So I do not reset\n+            \/\/ the maxPrefBreadth here.\n+\n+            \/\/ Fix for RT-12512, RT-14301 and RT-14864.\n+            \/\/ Without this, the VirtualFlow length-wise scrollbar would not change\n+            \/\/ as expected. This would leave items unable to be shown, as they\n+            \/\/ would exist outside of the visible area, even when the scrollbar\n+            \/\/ was at its maximum position.\n+            \/\/ FIXME this should be only executed on the pulse, so this will likely\n+            \/\/ lead to performance degradation until it is handled properly.\n+            if (countChanged) {\n+                layoutChildren();\n+\n+                Parent parent = getParent();\n+                if (parent != null) parent.requestLayout();\n+\n+                adjustAbsoluteOffset();\n+            }\n+            \/\/ TODO suppose I had 100 cells and I added 100 more. Further\n+            \/\/ suppose I was scrolled to the bottom when that happened. I\n+            \/\/ actually want to update the position of the mapper such that\n+            \/\/ the view remains \"stable\".\n+        }\n+    };\n+    public final int getCellCount() { return cellCount.get(); }\n+    public final void setCellCount(int value) {\n+        cellCount.set(value);\n+    }\n+    public final IntegerProperty cellCountProperty() { return cellCount; }\n+\n+\n+    \/\/ --- position\n+    \/**\n+     * The position of the VirtualFlow within its list of cells. This is a value\n+     * between 0 and 1.\n+     *\/\n+    private DoubleProperty position = new SimpleDoubleProperty(this, \"position\") {\n+        @Override public void setValue(Number v) {\n+            super.setValue(com.sun.javafx.util.Utils.clamp(0, get(), 1));\n+        }\n+\n+        @Override protected void invalidated() {\n+            super.invalidated();\n+            adjustAbsoluteOffset();\n+            requestLayout();\n+        }\n+    };\n+    public final double getPosition() { return position.get(); }\n+    public final void setPosition(double value) {\n+        position.set(value);\n+    }\n+    public final DoubleProperty positionProperty() { return position; }\n+\n+    \/\/ --- fixed cell size\n+    \/**\n+     * For optimisation purposes, some use cases can trade dynamic cell length\n+     * for speed - if fixedCellSize is greater than zero we'll use that rather\n+     * than determine it by querying the cell itself.\n+     *\/\n+    private DoubleProperty fixedCellSize = new SimpleDoubleProperty(this, \"fixedCellSize\") {\n+        @Override protected void invalidated() {\n+            fixedCellSizeEnabled = get() > 0;\n+            needsCellsLayout = true;\n+            layoutChildren();\n+        }\n+    };\n+    public final void setFixedCellSize(final double value) { fixedCellSize.set(value); }\n+    public final double getFixedCellSize() { return fixedCellSize.get(); }\n+    public final DoubleProperty fixedCellSizeProperty() { return fixedCellSize; }\n+\n+\n+    \/\/ --- Cell Factory\n+    private ObjectProperty<Callback<VirtualFlow<T>, T>> cellFactory;\n+\n+    \/**\n+     * Sets a new cell factory to use in the VirtualFlow. This forces all old\n+     * cells to be thrown away, and new cells to be created with\n+     * the new cell factory.\n+     * @param value the new cell factory\n+     *\/\n+    public final void setCellFactory(Callback<VirtualFlow<T>, T> value) {\n+        cellFactoryProperty().set(value);\n+    }\n+\n+    \/**\n+     * Returns the current cell factory.\n+     * @return the current cell factory\n+     *\/\n+    public final Callback<VirtualFlow<T>, T> getCellFactory() {\n+        return cellFactory == null ? null : cellFactory.get();\n+    }\n+\n+    \/**\n+     * <p>Setting a custom cell factory has the effect of deferring all cell\n+     * creation, allowing for total customization of the cell. Internally, the\n+     * VirtualFlow is responsible for reusing cells - all that is necessary\n+     * is for the custom cell factory to return from this function a cell\n+     * which might be usable for representing any item in the VirtualFlow.\n+     *\n+     * <p>Refer to the {@link Cell} class documentation for more detail.\n+     * @return  the cell factory property\n+     *\/\n+    public final ObjectProperty<Callback<VirtualFlow<T>, T>> cellFactoryProperty() {\n+        if (cellFactory == null) {\n+            cellFactory = new SimpleObjectProperty<>(this, \"cellFactory\") {\n+                @Override protected void invalidated() {\n+                    if (get() != null) {\n+                        setNeedsLayout(true);\n+                        recreateCells();\n+                        if (getParent() != null) getParent().requestLayout();\n+                    }\n+                    if (accumCellParent != null) {\n+                        accumCellParent.getChildren().clear();\n+                    }\n+                    accumCell = null;\n+                }\n+            };\n+        }\n+        return cellFactory;\n+    }\n+\n+\n+\n+    \/* *************************************************************************\n+     *                                                                         *\n+     * Public API                                                              *\n+     *                                                                         *\n+     **************************************************************************\/\n+\n+    \/**\n+     * Overridden to implement somewhat more efficient support for layout. The\n+     * VirtualFlow can generally be considered as being unmanaged, in that\n+     * whenever the position changes, or other such things change, we need\n+     * to perform a layout but there is no reason to notify the parent. However\n+     * when things change which may impact the preferred size (such as\n+     * vertical, createCell, and configCell) then we need to notify the\n+     * parent.\n+     *\/\n+    @Override public void requestLayout() {\n+\/\/ Note: This block is commented as it was relaying on a bad assumption on how\n+\/\/       layout request was handled in parent class that is now fixed.\n+\/\/\n+\/\/        \/\/ isNeedsLayout() is commented out due to RT-21417. This does not\n+\/\/        \/\/ appear to impact performance (indeed, it may help), and resolves the\n+\/\/        \/\/ issue identified in RT-21417.\n+\/\/        setNeedsLayout(true);\n+\n+        \/\/ The fix is to prograte this layout request to its parent class.\n+        \/\/ A better fix will be required if performance is negatively affected\n+        \/\/ by this fix.\n+        super.requestLayout();\n+    }\n+\n+    \/**\n+     * Keep the position constant and adjust the absoluteOffset to\n+     * match the (new) position.\n+     *\/\n+    void adjustAbsoluteOffset() {\n+        absoluteOffset = (estimatedSize - viewportLength) * getPosition();\n+    }\n+\n+    \/**\n+     * Keep the absoluteOffset constant and adjust the position to match\n+     * the (new) absoluteOffset.\n+     *\/\n+    void adjustPosition() {\n+        if (viewportLength >= estimatedSize) {\n+            setPosition(0.);\n+        } else {\n+            setPosition(absoluteOffset \/ (estimatedSize - viewportLength));\n+        }\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    @Override protected void layoutChildren() {\n+        \/\/ when we enter this method, the absoluteOffset and position are\n+        \/\/ already determined. In case this method invokes other methods\n+        \/\/ that may change either absoluteOffset or position, it is the\n+        \/\/ responsability of those methods to make sure both parameters are\n+        \/\/ changed in a consistent way.\n+        \/\/ For example, the recalculateEstimatedSize method also recalculates\n+        \/\/ the absoluteOffset and position.\n+\n+        if (needsRecreateCells) {\n+            lastWidth = -1;\n+            lastHeight = -1;\n+            releaseCell(accumCell);\n+            sheet.getChildren().clear();\n+            for (int i = 0, max = cells.size(); i < max; i++) {\n+                cells.get(i).updateIndex(-1);\n+            }\n+            cells.clear();\n+            pile.clear();\n+            releaseAllPrivateCells();\n+        } else if (needsRebuildCells) {\n+            lastWidth = -1;\n+            lastHeight = -1;\n+            releaseCell(accumCell);\n+            for (int i = 0, max = cells.size(); i < max; i++) {\n+                cells.get(i).updateIndex(-1);\n+            }\n+            addAllToPile();\n+            releaseAllPrivateCells();\n+        } else if (needsReconfigureCells) {\n+            setMaxPrefBreadth(-1);\n+            lastWidth = -1;\n+            lastHeight = -1;\n+        }\n+\n+        if (! dirtyCells.isEmpty()) {\n+            int index;\n+            final int cellsSize = cells.size();\n+            while ((index = dirtyCells.nextSetBit(0)) != -1 && index < cellsSize) {\n+                T cell = cells.get(index);\n+                \/\/ updateIndex(-1) works for TableView, but breaks ListView.\n+                \/\/ For now, the TableView just does not use the dirtyCells API\n+\/\/                cell.updateIndex(-1);\n+                if (cell != null) {\n+                    cell.requestLayout();\n+                }\n+                dirtyCells.clear(index);\n+            }\n+\n+            setMaxPrefBreadth(-1);\n+            lastWidth = -1;\n+            lastHeight = -1;\n+        }\n+\n+        final boolean hasSizeChange = sizeChanged;\n+        boolean recreatedOrRebuilt = needsRebuildCells || needsRecreateCells || sizeChanged;\n+\n+        needsRecreateCells = false;\n+        needsReconfigureCells = false;\n+        needsRebuildCells = false;\n+        sizeChanged = false;\n+\n+        if (needsCellsLayout) {\n+            for (int i = 0, max = cells.size(); i < max; i++) {\n+                Cell<?> cell = cells.get(i);\n+                if (cell != null) {\n+                    cell.requestLayout();\n+                }\n+            }\n+            needsCellsLayout = false;\n+            \/\/ yes, we return here - if needsCellsLayout was set to true, we\n+            \/\/ only did it to do the above - not rerun the entire layout.\n+            return;\n+        }\n+\n+        final double width = getWidth();\n+        final double height = getHeight();\n+        final boolean isVertical = isVertical();\n+        final double position = getPosition();\n+        \/\/ if the width and\/or height is 0, then there is no point doing\n+        \/\/ any of this work. In particular, this can happen during startup\n+        if (width <= 0 || height <= 0) {\n+            addAllToPile();\n+            lastWidth = width;\n+            lastHeight = height;\n+            hbar.setVisible(false);\n+            vbar.setVisible(false);\n+            corner.setVisible(false);\n+            return;\n+        }\n+\n+        \/\/ we check if any of the cells in the cells list need layout. This is a\n+        \/\/ sign that they are perhaps animating their sizes. Without this check,\n+        \/\/ we may not perform a layout here, meaning that the cell will likely\n+        \/\/ 'jump' (in height normally) when the user drags the virtual thumb as\n+        \/\/ that is the first time the layout would occur otherwise.\n+        boolean cellNeedsLayout = false;\n+        boolean thumbNeedsLayout = false;\n+\n+        if (Properties.IS_TOUCH_SUPPORTED) {\n+            if ((tempVisibility == true && (hbar.isVisible() == false || vbar.isVisible() == false)) ||\n+                (tempVisibility == false && (hbar.isVisible() == true || vbar.isVisible() == true))) {\n+                thumbNeedsLayout = true;\n+            }\n+        }\n+\n+        if (!cellNeedsLayout) {\n+            for (int i = 0; i < cells.size(); i++) {\n+                Cell<?> cell = cells.get(i);\n+                cellNeedsLayout = cell.isNeedsLayout();\n+                if (cellNeedsLayout) break;\n+            }\n+        }\n+\n+        final int cellCount = getCellCount();\n+        final T firstCell = getFirstVisibleCell();\n+\n+        \/\/ If no cells need layout, we check other criteria to see if this\n+        \/\/ layout call is even necessary. If it is found that no layout is\n+        \/\/ needed, we just punt.\n+        if (! cellNeedsLayout && !thumbNeedsLayout) {\n+            boolean cellSizeChanged = false;\n+            if (firstCell != null) {\n+                double breadth = getCellBreadth(firstCell);\n+                double length = getCellLength(firstCell);\n+                cellSizeChanged = (breadth != lastCellBreadth) || (length != lastCellLength);\n+                lastCellBreadth = breadth;\n+                lastCellLength = length;\n+            }\n+\n+            if (width == lastWidth &&\n+                height == lastHeight &&\n+                cellCount == lastCellCount &&\n+                isVertical == lastVertical &&\n+                position == lastPosition &&\n+                ! cellSizeChanged)\n+            {\n+                \/\/ TODO this happens to work around the problem tested by\n+                \/\/ testCellLayout_LayoutWithoutChangingThingsUsesCellsInSameOrderAsBefore\n+                \/\/ but isn't a proper solution. Really what we need to do is, when\n+                \/\/ laying out cells, we need to make sure that if a cell is pressed\n+                \/\/ AND we are doing a full rebuild then we need to make sure we\n+                \/\/ use that cell in the same physical location as before so that\n+                \/\/ it gets the mouse release event.\n+                return;\n+            }\n+        }\n+\n+        \/*\n+         * This function may get called under a variety of circumstances.\n+         * It will determine what has changed from the last time it was laid\n+         * out, and will then take one of several execution paths based on\n+         * what has changed so as to perform minimal layout work and also to\n+         * give the expected behavior. One or more of the following may have\n+         * happened:\n+         *\n+         *  1) width\/height has changed\n+         *      - If the width and\/or height has been reduced (but neither of\n+         *        them has been expanded), then we simply have to reposition and\n+         *        resize the scroll bars\n+         *      - If the width (in the vertical case) has expanded, then we\n+         *        need to resize the existing cells and reposition and resize\n+         *        the scroll bars\n+         *      - If the height (in the vertical case) has expanded, then we\n+         *        need to resize and reposition the scroll bars and add\n+         *        any trailing cells\n+         *\n+         *  2) cell count has changed\n+         *      - If the number of cells is bigger, or it is smaller but not\n+         *        so small as to move the position then we can just update the\n+         *        cells in place without performing layout and update the\n+         *        scroll bars.\n+         *      - If the number of cells has been reduced and it affects the\n+         *        position, then move the position and rebuild all the cells\n+         *        and update the scroll bars\n+         *\n+         *  3) size of the cell has changed\n+         *      - If the size changed in the virtual direction (ie: height\n+         *        in the case of vertical) then layout the cells, adding\n+         *        trailing cells as necessary and updating the scroll bars\n+         *      - If the size changed in the non virtual direction (ie: width\n+         *        in the case of vertical) then simply adjust the widths of\n+         *        the cells as appropriate and adjust the scroll bars\n+         *\n+         *  4) vertical changed, cells is empty, maxPrefBreadth == -1, etc\n+         *      - Full rebuild.\n+         *\n+         * Each of the conditions really resolves to several of a handful of\n+         * possible outcomes:\n+         *  a) reposition & rebuild scroll bars\n+         *  b) resize cells in non-virtual direction\n+         *  c) add trailing cells\n+         *  d) update cells\n+         *  e) resize cells in the virtual direction\n+         *  f) all of the above\n+         *\n+         * So this function first determines what outcomes need to occur, and\n+         * then will execute all the ones that really need to happen. Every code\n+         * path ends up touching the \"reposition & rebuild scroll bars\" outcome,\n+         * so that one will be executed every time.\n+         *\/\n+        boolean needTrailingCells = false;\n+        boolean rebuild = cellNeedsLayout  ||\n+                isVertical != lastVertical ||\n+                cells.isEmpty()            ||\n+                getMaxPrefBreadth() == -1  ||\n+                position != lastPosition   ||\n+                cellCount != lastCellCount ||\n+                hasSizeChange ||\n+                (isVertical && height < lastHeight) || (! isVertical && width < lastWidth);\n+\n+        if (!rebuild) {\n+            \/\/ Check if maxPrefBreadth didn't change\n+            double maxPrefBreadth = getMaxPrefBreadth();\n+            boolean foundMax = false;\n+            for (int i = 0; i < cells.size(); ++i) {\n+                double breadth = getCellBreadth(cells.get(i));\n+                if (maxPrefBreadth == breadth) {\n+                    foundMax = true;\n+                } else if (breadth > maxPrefBreadth) {\n+                    rebuild = true;\n+                    break;\n+                }\n+            }\n+            if (!foundMax) { \/\/ All values were lower\n+                rebuild = true;\n+            }\n+        }\n+\n+        if (! rebuild) {\n+            if ((isVertical && height > lastHeight) || (! isVertical && width > lastWidth)) {\n+                \/\/ resized in the virtual direction\n+                needTrailingCells = true;\n+            }\n+        }\n+        initViewport();\n+\n+        \/\/ Get the index of the \"current\" cell\n+        int currentIndex = computeCurrentIndex();\n+        if (lastCellCount != cellCount) {\n+            \/\/ The cell count has changed. We want to keep the viewport\n+            \/\/ stable if possible. If position was 0 or 1, we want to keep\n+            \/\/ the position in the same place. If the new cell count is >=\n+            \/\/ the currentIndex, then we will adjust the position to be 1.\n+            \/\/ Otherwise, our goal is to leave the index of the cell at the\n+            \/\/ top consistent, with the same translation etc.\n+            if (position != 0 && position != 1 && (currentIndex >= cellCount)) {\n+                setPosition(1.0f);\n+            }\n+\n+            \/\/ Update the current index\n+            currentIndex = computeCurrentIndex();\n+        }\n+        if (rebuild) {\n+            setMaxPrefBreadth(-1);\n+            \/\/ Start by dumping all the cells into the pile\n+            addAllToPile();\n+\n+            \/\/ The distance from the top of the viewport to the top of the\n+            \/\/ cell for the current index.\n+            double offset = -computeViewportOffset(getPosition());\n+\n+            \/\/ Add all the leading and trailing cells (the call to add leading\n+            \/\/ cells will add the current cell as well -- that is, the one that\n+            \/\/ represents the current position on the mapper).\n+            addLeadingCells(currentIndex, offset);\n+\n+            \/\/ Force filling of space with empty cells if necessary\n+            addTrailingCells(true);\n+        } else if (needTrailingCells) {\n+            addTrailingCells(true);\n+        }\n+        computeBarVisiblity();\n+\n+        recalculateAndImproveEstimatedSize(0);\n+        recreatedOrRebuilt = recreatedOrRebuilt || rebuild;\n+        updateScrollBarsAndCells(recreatedOrRebuilt);\n+\n+        lastWidth = getWidth();\n+        lastHeight = getHeight();\n+        lastCellCount = getCellCount();\n+        lastVertical = isVertical();\n+        lastPosition = getPosition();\n+        recalculateEstimatedSize();\n+        cleanPile();\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    @Override protected void setWidth(double value) {\n+        if (value != lastWidth) {\n+            super.setWidth(value);\n+            sizeChanged = true;\n+            setNeedsLayout(true);\n+            requestLayout();\n+        }\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    @Override protected void setHeight(double value) {\n+        if (value != lastHeight) {\n+            super.setHeight(value);\n+            sizeChanged = true;\n+            setNeedsLayout(true);\n+            requestLayout();\n+        }\n+    }\n+\n+    \/**\n+     * Get a cell which can be used in the layout. This function will reuse\n+     * cells from the pile where possible, and will create new cells when\n+     * necessary.\n+     * @param prefIndex the preferred index\n+     * @return the available cell\n+     *\/\n+    protected T getAvailableCell(int prefIndex) {\n+        T cell = null;\n+        \/\/ Fix for RT-12822. We try to retrieve the cell from the pile rather\n+        \/\/ than just grab a random cell from the pile (or create another cell).\n+        for (int i = 0, max = pile.size(); i < max; i++) {\n+            T _cell = pile.get(i);\n+            assert _cell != null;\n+            if (getCellIndex(_cell) == prefIndex) {\n+                cell = _cell;\n+                pile.remove(i);\n+                break;\n+            }\n+        }\n+\n+        if (cell == null && !pile.isEmpty()) {\n+            cell = pile.removeLast();\n+        }\n+\n+        if (cell == null) {\n+            cell = getCellFactory().call(this);\n+            cell.getProperties().put(NEW_CELL, null);\n+        }\n+\n+        if (cell.getParent() == null) {\n+            sheetChildren.add(cell);\n+        }\n+\n+        return cell;\n+    }\n+\n+    \/**\n+     * This method will remove all cells from the VirtualFlow and remove them,\n+     * adding them to the 'pile' (that is, a place from where cells can be used\n+     * at a later date). This method is protected to allow subclasses to clean up\n+     * appropriately.\n+     *\/\n+    protected void addAllToPile() {\n+        for (int i = 0, max = cells.size(); i < max; i++) {\n+            addToPile(cells.removeFirst());\n+        }\n+    }\n+\n+    \/**\n+     * Gets a cell for the given index if the cell has been created and laid out.\n+     * \"Visible\" is a bit of a misnomer, the cell might not be visible in the\n+     * viewport (it may be clipped), but does distinguish between cells that\n+     * have been created and are in use vs. those that are in the pile or\n+     * not created.\n+     * @param index the index\n+     * @return the visible cell\n+     *\/\n+    public T getVisibleCell(int index) {\n+        if (cells.isEmpty()) return null;\n+\n+        \/\/ check the last index\n+        T lastCell = cells.getLast();\n+        int lastIndex = getCellIndex(lastCell);\n+        if (index == lastIndex) return lastCell;\n+\n+        \/\/ check the first index\n+        T firstCell = cells.getFirst();\n+        int firstIndex = getCellIndex(firstCell);\n+        if (index == firstIndex) return firstCell;\n+\n+        \/\/ if index is > firstIndex and < lastIndex then we can get the index\n+        if (index > firstIndex && index < lastIndex) {\n+            T cell = cells.get(index - firstIndex);\n+            if (getCellIndex(cell) == index) return cell;\n+        }\n+\n+        \/\/ there is no visible cell for the specified index\n+        return null;\n+    }\n+\n+    \/**\n+     * Locates and returns the last non-empty IndexedCell that is currently\n+     * partially or completely visible. This function may return null if there\n+     * are no cells, or if the viewport length is 0.\n+     * @return the last visible cell\n+     *\/\n+    public T getLastVisibleCell() {\n+        if (cells.isEmpty() || getViewportLength() <= 0) return null;\n+\n+        T cell;\n+        for (int i = cells.size() - 1; i >= 0; i--) {\n+            cell = cells.get(i);\n+            if (! cell.isEmpty()) {\n+                return cell;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * Locates and returns the first non-empty IndexedCell that is partially or\n+     * completely visible. This really only ever returns null if there are no\n+     * cells or the viewport length is 0.\n+     * @return the first visible cell\n+     *\/\n+    public T getFirstVisibleCell() {\n+        if (cells.isEmpty() || getViewportLength() <= 0) return null;\n+        T cell = cells.getFirst();\n+        return cell.isEmpty() ? null : cell;\n+    }\n+\n+    \/**\n+     * Adjust the position of cells so that the specified cell\n+     * will be positioned at the start of the viewport. The given cell must\n+     * already be \"live\".\n+     * @param firstCell the first cell\n+     *\/\n+    public void scrollToTop(T firstCell) {\n+        if (firstCell != null) {\n+            scrollPixels(getCellPosition(firstCell));\n+        }\n+    }\n+\n+    \/**\n+     * Adjust the position of cells so that the specified cell\n+     * will be positioned at the end of the viewport. The given cell must\n+     * already be \"live\".\n+     * @param lastCell the last cell\n+     *\/\n+    public void scrollToBottom(T lastCell) {\n+        if (lastCell != null) {\n+            scrollPixels(getCellPosition(lastCell) + getCellLength(lastCell) - getViewportLength());\n+        }\n+    }\n+\n+    \/**\n+     * Adjusts the cells such that the selected cell will be fully visible in\n+     * the viewport (but only just).\n+     * @param cell the cell\n+     *\/\n+    public void scrollTo(T cell) {\n+        if (cell != null) {\n+            final double start = getCellPosition(cell);\n+            final double length = getCellLength(cell);\n+            final double end = start + length;\n+            final double viewportLength = getViewportLength();\n+\n+            if (start < 0) {\n+                scrollPixels(start);\n+            } else if (end > viewportLength) {\n+                scrollPixels(end - viewportLength);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Adjusts the cells such that the cell in the given index will be fully visible in\n+     * the viewport.\n+     * @param index the index\n+     *\/\n+    public void scrollTo(int index) {\n+        T cell = getVisibleCell(index);\n+        if (cell != null) {\n+            scrollTo(cell);\n+        } else {\n+            \/\/ see JDK-8197536\n+            if (tryScrollOneCell(index, true)) {\n+                return;\n+            } else if (tryScrollOneCell(index, false)) {\n+                return;\n+            }\n+\n+            adjustPositionToIndex(index);\n+            addAllToPile();\n+            requestLayout();\n+        }\n+    }\n+\n+    \/\/ will return true if scroll is successful\n+    private boolean tryScrollOneCell(int targetIndex, boolean downOrRight) {\n+        \/\/ if going down, cell diff is -1, because it will get the target cell index and check if previous\n+        \/\/ cell is visible to base the position\n+        int indexDiff = downOrRight ? -1 : 1;\n+\n+        T targetCell = getVisibleCell(targetIndex + indexDiff);\n+        if (targetCell != null) {\n+            T cell = getAvailableCell(targetIndex);\n+            setCellIndex(cell, targetIndex);\n+            resizeCell(cell);\n+            setMaxPrefBreadth(Math.max(getMaxPrefBreadth(), getCellBreadth(cell)));\n+            cell.setVisible(true);\n+            if (downOrRight) {\n+                cells.addLast(cell);\n+                scrollPixels(getCellLength(cell));\n+            } else {\n+                \/\/ up or left\n+                cells.addFirst(cell);\n+                scrollPixels(-getCellLength(cell));\n+            }\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * Adjusts the cells such that the cell in the given index will be fully visible in\n+     * the viewport, and positioned at the very top of the viewport.\n+     * @param index the index\n+     *\/\n+    public void scrollToTop(int index) {\n+        \/\/ make sure we have the real size of cells that are likely to be rendered\n+        getCellSizesInExpectedViewport(index);\n+        boolean posSet = false;\n+\n+        if (index > getCellCount() - 1) {\n+            setPosition(1);\n+            posSet = true;\n+        } else if (index < 0) {\n+            setPosition(0);\n+            posSet = true;\n+        }\n+\n+        if (! posSet) {\n+            adjustPositionToIndex(index);\n+        }\n+\n+        requestLayout();\n+    }\n+\n+\/\/    \/\/TODO We assume all the cell have the same length.  We will need to support\n+\/\/    \/\/ cells of different lengths.\n+\/\/    public void scrollToOffset(int offset) {\n+\/\/        scrollPixels(offset * getCellLength(0));\n+\/\/    }\n+\n+    \/**\n+     * Given a delta value representing a number of pixels, this method attempts\n+     * to move the VirtualFlow in the given direction (positive is down\/right,\n+     * negative is up\/left) the given number of pixels. It returns the number of\n+     * pixels actually moved.\n+     * @param delta the delta value\n+     * @return the number of pixels actually moved\n+     *\/\n+    public double scrollPixels(final double delta) {\n+        int oldIndex = computeCurrentIndex();\n+        \/\/ Short cut this method for cases where nothing should be done\n+        if (delta == 0) return 0;\n+\n+        final boolean isVertical = isVertical();\n+        if (((isVertical && (tempVisibility ? !needLengthBar : !vbar.isVisible())) ||\n+                (! isVertical && (tempVisibility ? !needLengthBar : !hbar.isVisible())))) return 0;\n+\n+        double pos = getPosition();\n+        if (pos == 0.0f && delta < 0) return 0;\n+        if (pos == 1.0f && delta > 0) return 0;\n+        getCellSizesInExpectedViewport(oldIndex);\n+        recalculateEstimatedSize();\n+        double answer = adjustByPixelAmount(delta);\n+        if (pos == getPosition()) {\n+            \/\/ The pos hasn't changed, there's nothing to do. This is likely\n+            \/\/ to occur when we hit either extremity\n+            return 0;\n+        }\n+\n+        \/\/ Now move stuff around. Translating by pixels fundamentally means\n+        \/\/ moving the cells by the delta. However, after having\n+        \/\/ done that, we need to go through the cells and see which cells,\n+        \/\/ after adding in the translation factor, now fall off the viewport.\n+        \/\/ Also, we need to add cells as appropriate to the end (or beginning,\n+        \/\/ depending on the direction of travel).\n+        \/\/\n+        \/\/ One simplifying assumption (that had better be true!) is that we\n+        \/\/ will only make it this far in the function if the virtual scroll\n+        \/\/ bar is visible. Otherwise, we never will pixel scroll. So as we go,\n+        \/\/ if we find that the maxPrefBreadth exceeds the viewportBreadth,\n+        \/\/ then we will be sure to show the breadthBar and update it\n+        \/\/ accordingly.\n+        if (cells.size() > 0) {\n+            for (int i = 0; i < cells.size(); i++) {\n+                T cell = cells.get(i);\n+                assert cell != null;\n+                positionCell(cell, getCellPosition(cell) - delta);\n+            }\n+\n+            \/\/ Fix for RT-32908\n+            T firstCell = cells.getFirst();\n+            double layoutY = firstCell == null ? 0 : getCellPosition(firstCell);\n+            for (int i = 0; i < cells.size(); i++) {\n+                T cell = cells.get(i);\n+                assert cell != null;\n+                double actualLayoutY = getCellPosition(cell);\n+                if (Math.abs(actualLayoutY - layoutY) > 0.001) {\n+                    \/\/ we need to shift the cell to layoutY\n+                    positionCell(cell, layoutY);\n+                }\n+\n+                layoutY += getCellLength(cell);\n+            }\n+            \/\/ end of fix for RT-32908\n+            cull();\n+            firstCell = cells.getFirst();\n+\n+            \/\/ Add any necessary leading cells\n+            if (firstCell != null) {\n+                int firstIndex = getCellIndex(firstCell);\n+                double prevIndexSize = getCellLength(firstIndex - 1);\n+                addLeadingCells(firstIndex - 1, getCellPosition(firstCell) - prevIndexSize);\n+            } else {\n+                int currentIndex = computeCurrentIndex();\n+\n+                \/\/ The distance from the top of the viewport to the top of the\n+                \/\/ cell for the current index.\n+                double offset = -computeViewportOffset(getPosition());\n+\n+                \/\/ Add all the leading and trailing cells (the call to add leading\n+                \/\/ cells will add the current cell as well -- that is, the one that\n+                \/\/ represents the current position on the mapper).\n+                addLeadingCells(currentIndex, offset);\n+            }\n+            \/\/ Starting at the tail of the list, loop adding cells until\n+            \/\/ all the space on the table is filled up. We want to make\n+            \/\/ sure that we DO NOT add empty trailing cells (since we are\n+            \/\/ in the full virtual case and so there are no trailing empty\n+            \/\/ cells).\n+            if (! addTrailingCells(false)) {\n+                \/\/ Reached the end, but not enough cells to fill up to\n+                \/\/ the end. So, remove the trailing empty space, and translate\n+                \/\/ the cells down\n+\n+                final T lastCell = getLastVisibleCell();\n+                final double lastCellSize = getCellLength(lastCell);\n+                final double cellEnd = getCellPosition(lastCell) + lastCellSize;\n+                final double viewportLength = getViewportLength();\n+\n+                if (cellEnd < viewportLength) {\n+                    \/\/ Reposition the nodes\n+                    double emptySize = viewportLength - cellEnd;\n+                    for (int i = 0; i < cells.size(); i++) {\n+                        T cell = cells.get(i);\n+                        positionCell(cell, getCellPosition(cell) + emptySize);\n+                    }\n+                    setPosition(1.0f);\n+                    \/\/ fill the leading empty space\n+                    firstCell = cells.getFirst();\n+                    int firstIndex = getCellIndex(firstCell);\n+                    double prevIndexSize = getCellLength(firstIndex - 1);\n+                    addLeadingCells(firstIndex - 1, getCellPosition(firstCell) - prevIndexSize);\n+                }\n+            }\n+        }\n+\n+        \/\/ Now throw away any cells that don't fit\n+        cull();\n+\n+        \/\/ Finally, update the scroll bars\n+        updateScrollBarsAndCells(false);\n+        lastPosition = getPosition();\n+\n+        \/\/ notify\n+        return answer;\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    @Override protected double computePrefWidth(double height) {\n+        double w = isVertical() ? getPrefBreadth(height) : getPrefLength();\n+        return w + vbar.prefWidth(-1);\n+    }\n+\n+    \/** {@inheritDoc} *\/\n+    @Override protected double computePrefHeight(double width) {\n+        double h = isVertical() ? getPrefLength() : getPrefBreadth(width);\n+        return h + hbar.prefHeight(-1);\n+    }\n+\n+    \/**\n+     * Return a cell for the given index. This may be called for any cell,\n+     * including beyond the range defined by cellCount, in which case an\n+     * empty cell will be returned. The returned value should not be stored for\n+     * any reason.\n+     * @param index the index\n+     * @return the cell\n+     *\/\n+    public T getCell(int index) {\n+        \/\/ If there are cells, then we will attempt to get an existing cell\n+        if (! cells.isEmpty()) {\n+            \/\/ First check the cells that have already been created and are\n+            \/\/ in use. If this call returns a value, then we can use it\n+            T cell = getVisibleCell(index);\n+            if (cell != null) return cell;\n+        }\n+\n+        \/\/ check the pile\n+        for (int i = 0; i < pile.size(); i++) {\n+            T cell = pile.get(i);\n+            if (getCellIndex(cell) == index) {\n+                \/\/ Note that we don't remove from the pile: if we do it leads\n+                \/\/ to a severe performance decrease. This seems to be OK, as\n+                \/\/ getCell() is only used for cell measurement purposes.\n+                \/\/ pile.remove(i);\n+                resizeCell(cell);\n+                return cell;\n+            }\n+        }\n+\n+        \/\/ We need to use the accumCell and return that\n+        if (accumCell == null) {\n+            Callback<VirtualFlow<T>,T> cellFactory = getCellFactory();\n+            if (cellFactory != null) {\n+                accumCell = cellFactory.call(this);\n+                accumCell.getProperties().put(NEW_CELL, null);\n+                accumCellParent.getChildren().setAll(accumCell);\n+\n+                \/\/ Note the screen reader will attempt to find all\n+                \/\/ the items inside the view to calculate the item count.\n+                \/\/ Having items under different parents (sheet and accumCellParent)\n+                \/\/ leads the screen reader to compute wrong values.\n+                \/\/ The regular scheme to provide items to the screen reader\n+                \/\/ uses getPrivateCell(), which places the item in the sheet.\n+                \/\/ The accumCell, and its children, should be ignored by the\n+                \/\/ screen reader.\n+                accumCell.setAccessibleRole(AccessibleRole.NODE);\n+                accumCell.getChildrenUnmodifiable().addListener((Observable c) -> {\n+                    for (Node n : accumCell.getChildrenUnmodifiable()) {\n+                        n.setAccessibleRole(AccessibleRole.NODE);\n+                    }\n+                });\n+            }\n+        }\n+        setCellIndex(accumCell, index);\n+        resizeCell(accumCell);\n+        return accumCell;\n+    }\n+\n+    \/**\n+     * The VirtualFlow uses this method to set a cells index (rather than calling\n+     * {@link IndexedCell#updateIndex(int)} directly), so it is a perfect place\n+     * for subclasses to override if this if of interest.\n+     *\n+     * @param cell The cell whose index will be updated.\n+     * @param index The new index for the cell.\n+     *\/\n+    protected void setCellIndex(T cell, int index) {\n+        assert cell != null;\n+\n+        cell.updateIndex(index);\n+\n+        \/\/ make sure the cell is sized correctly. This is important for both\n+        \/\/ general layout of cells in a VirtualFlow, but also in cases such as\n+        \/\/ RT-34333, where the sizes were being reported incorrectly to the\n+        \/\/ ComboBox popup.\n+        if ((cell.isNeedsLayout() && cell.getScene() != null) || cell.getProperties().containsKey(NEW_CELL)) {\n+            cell.applyCss();\n+            cell.getProperties().remove(NEW_CELL);\n+        }\n+    }\n+\n+    \/**\n+     * Return the index for a given cell. This allows subclasses to customise\n+     * how cell indices are retrieved.\n+     * @param cell the cell\n+     * @return the index\n+     *\/\n+    protected int getCellIndex(T cell){\n+        return cell.getIndex();\n+    }\n+\n+\n+\n+    \/* *************************************************************************\n+     *                                                                         *\n+     * Private implementation                                                  *\n+     *                                                                         *\n+     **************************************************************************\/\n+\n+    \/**\n+     * Returns the scroll bar used for scrolling horizontally. A developer who needs to be notified when a scroll is\n+     * happening could attach a listener to the {@link ScrollBar#valueProperty()}.\n+     *\n+     * @return the scroll bar used for scrolling horizontally\n+     * @since 12\n+     *\/\n+    protected final ScrollBar getHbar() {\n+        return hbar;\n+    }\n+\n+    \/**\n+     * Returns the scroll bar used for scrolling vertically. A developer who needs to be notified when a scroll is\n+     * happening could attach a listener to the {@link ScrollBar#valueProperty()}. The {@link ScrollBar#getWidth()} is\n+     * also useful when adding a component over the {@code TableView} in order to clip it so that it doesn't overlap the\n+     * {@code ScrollBar}.\n+     *\n+     * @return the scroll bar used for scrolling vertically\n+     * @since 12\n+     *\/\n+    protected final ScrollBar getVbar() {\n+        return vbar;\n+    }\n+\n+    \/**\n+     * The maximum preferred size in the non-virtual direction. For example,\n+     * if vertical, then this is the max pref width of all cells encountered.\n+     * <p>\n+     * In general, this is the largest preferred size in the non-virtual\n+     * direction that we have ever encountered. We don't reduce this size\n+     * unless instructed to do so, so as to reduce the amount of scroll bar\n+     * jitter. The access on this variable is package ONLY FOR TESTING.\n+     *\/\n+    private double maxPrefBreadth;\n+    private final void setMaxPrefBreadth(double value) {\n+        this.maxPrefBreadth = value;\n+    }\n+    final double getMaxPrefBreadth() {\n+        return maxPrefBreadth;\n+    }\n+\n+    \/**\n+     * The breadth of the viewport portion of the VirtualFlow as computed during\n+     * the layout pass. In a vertical flow this would be the same as the clip\n+     * view width. In a horizontal flow this is the clip view height.\n+     * The access on this variable is package ONLY FOR TESTING.\n+     *\/\n+    private double viewportBreadth;\n+    private final void setViewportBreadth(double value) {\n+        this.viewportBreadth = value;\n+    }\n+    private final double getViewportBreadth() {\n+        return viewportBreadth;\n+    }\n+\n+    \/**\n+     * The length of the viewport portion of the VirtualFlow as computed\n+     * during the layout pass. In a vertical flow this would be the same as the\n+     * clip view height. In a horizontal flow this is the clip view width.\n+     * The access on this variable is package ONLY FOR TESTING.\n+     *\/\n+    private double viewportLength;\n+    void setViewportLength(double value) {\n+        if (value == this.viewportLength) {\n+            return;\n+        }\n+        this.viewportLength = value;\n+        this.absoluteOffset = getPosition() * (estimatedSize - viewportLength);\n+        recalculateEstimatedSize();\n+    }\n+    double getViewportLength() {\n+        return viewportLength;\n+    }\n+\n+    \/**\n+     * Compute and return the length of the cell for the given index. This is\n+     * called both internally when adjusting by pixels, and also at times\n+     * by PositionMapper (see the getItemSize callback). When called by\n+     * PositionMapper, it is possible that it will be called for some index\n+     * which is not associated with any cell, so we have to do a bit of work\n+     * to use a cell as a helper for computing cell size in some cases.\n+     *\/\n+    double getCellLength(int index) {\n+        if (fixedCellSizeEnabled) return getFixedCellSize();\n+\n+        T cell = getCell(index);\n+        double length = getCellLength(cell);\n+\n+        releaseCell(cell);\n+        return length;\n+    }\n+\n+    \/**\n+     *\/\n+    double getCellBreadth(int index) {\n+        T cell = getCell(index);\n+        double b = getCellBreadth(cell);\n+        releaseCell(cell);\n+        return b;\n+    }\n+\n+    \/**\n+     * Gets the length of a specific cell\n+     *\/\n+    double getCellLength(T cell) {\n+        if (cell == null) return 0;\n+        if (fixedCellSizeEnabled) return getFixedCellSize();\n+        return isVertical() ?\n+                cell.getLayoutBounds().getHeight()\n+                : cell.getLayoutBounds().getWidth();\n+    }\n+\n+    \/**\n+     * Gets the breadth of a specific cell\n+     *\/\n+    double getCellBreadth(Cell cell) {\n+        return isVertical() ?\n+                cell.prefWidth(-1)\n+                : cell.prefHeight(-1);\n+    }\n+\n+    \/**\n+     * Gets the layout position of the cell along the length axis\n+     *\/\n+    double getCellPosition(T cell) {\n+        if (cell == null) return 0;\n+\n+        return isVertical() ?\n+                cell.getLayoutY()\n+                : cell.getLayoutX();\n+    }\n+\n+    private void positionCell(T cell, double position) {\n+        updateCellSize(cell);\n+        if (isVertical()) {\n+            cell.setLayoutX(0);\n+            cell.setLayoutY(snapSpaceY(position));\n+        } else {\n+            cell.setLayoutX(snapSpaceX(position));\n+            cell.setLayoutY(0);\n+        }\n+    }\n+\n+    \/**\n+     * Resizes the given cell. If {@link #isVertical()} is set to {@code true}, the cell width will be the maximum\n+     * between the viewport width and the sum of all the cells' {@code prefWidth}. The cell height will be computed by\n+     * the cell itself unless {@code fixedCellSizeEnabled} is set to {@code true}, then {@link #getFixedCellSize()} is\n+     * used. If {@link #isVertical()} is set to {@code false}, the width and height calculations are reversed.\n+     *\n+     * @param cell the cell to resize\n+     * @since 12\n+     *\/\n+    protected void resizeCell(T cell) {\n+        if (cell == null) return;\n+\n+        if (isVertical()) {\n+            double width = Math.max(getMaxPrefBreadth(), getViewportBreadth());\n+            cell.resize(width, fixedCellSizeEnabled ? getFixedCellSize() : Utils.boundedSize(cell.prefHeight(width), cell.minHeight(width), cell.maxHeight(width)));\n+        } else {\n+            double height = Math.max(getMaxPrefBreadth(), getViewportBreadth());\n+            cell.resize(fixedCellSizeEnabled ? getFixedCellSize() : Utils.boundedSize(cell.prefWidth(height), cell.minWidth(height), cell.maxWidth(height)), height);\n+        }\n+        \/\/ when a cell is resized, our estimate needs to be updated.\n+        recalculateAndImproveEstimatedSize(0);\n+    }\n+\n+    \/**\n+     * Returns the list of cells displayed in the current viewport.\n+     * <p>\n+     * The cells are ordered such that the first cell in this list is the first in the view, and the last cell is the\n+     * last in the view. When pixel scrolling, the list is simply shifted and items drop off the beginning or the end,\n+     * depending on the order of scrolling.\n+     *\n+     * @return the cells displayed in the current viewport\n+     * @since 12\n+     *\/\n+    protected List<T> getCells() {\n+        return cells;\n+    }\n+\n+    \/**\n+     * Returns the last visible cell whose bounds are entirely within the viewport. When manually inserting rows, one\n+     * may need to know which cell indices are visible in the viewport.\n+     *\n+     * @return last visible cell whose bounds are entirely within the viewport\n+     * @since 12\n+     *\/\n+    protected T getLastVisibleCellWithinViewport() {\n+        if (cells.isEmpty() || getViewportLength() <= 0) return null;\n+\n+        T cell;\n+        final double max = getViewportLength();\n+        for (int i = cells.size() - 1; i >= 0; i--) {\n+            cell = cells.get(i);\n+            if (cell.isEmpty()) continue;\n+\n+            final double cellStart = getCellPosition(cell);\n+            final double cellEnd = cellStart + getCellLength(cell);\n+\n+            \/\/ we use the magic +2 to allow for a little bit of fuzziness,\n+            \/\/ this is to help in situations such as RT-34407\n+            if (cellEnd <= (max + 2)) {\n+                return cell;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns the first visible cell whose bounds are entirely within the viewport. When manually inserting rows, one\n+     * may need to know which cell indices are visible in the viewport.\n+     *\n+     * @return first visible cell whose bounds are entirely within the viewport\n+     * @since 12\n+     *\/\n+    protected T getFirstVisibleCellWithinViewport() {\n+        if (cells.isEmpty() || getViewportLength() <= 0) return null;\n+\n+        T cell;\n+        for (int i = 0; i < cells.size(); i++) {\n+            cell = cells.get(i);\n+            if (cell.isEmpty()) continue;\n+\n+            final double cellStart = getCellPosition(cell);\n+            if (cellStart >= 0) {\n+                return cell;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * Adds all the cells prior to and including the given currentIndex, until\n+     * no more can be added without falling off the flow. The startOffset\n+     * indicates the distance from the leading edge (top) of the viewport to\n+     * the leading edge (top) of the currentIndex.\n+     *\/\n+    void addLeadingCells(int currentIndex, double startOffset) {\n+        \/\/ The offset will keep track of the distance from the top of the\n+        \/\/ viewport to the top of the current index. We will decrement it\n+        \/\/ as we lay out leading cells.\n+        double offset = startOffset;\n+        \/\/ The index is the absolute index of the cell being laid out\n+        int index = currentIndex;\n+\n+        \/\/ Offset should really be the bottom of the current index\n+        boolean first = true; \/\/ first time in, we just fudge the offset and let\n+        \/\/ it be the top of the current index then redefine\n+        \/\/ it as the bottom of the current index thereafter\n+        \/\/ while we have not yet laid out so many cells that they would fall\n+        \/\/ off the flow, we will continue to create and add cells. The\n+        \/\/ offset is our indication of whether we can lay out additional\n+        \/\/ cells. If the offset is ever < 0, except in the case of the very\n+        \/\/ first cell, then we must quit.\n+        T cell = null;\n+\n+        \/\/ special case for the position == 1.0, skip adding last invisible cell\n+        if (index == getCellCount() && offset == getViewportLength()) {\n+            index--;\n+            first = false;\n+        }\n+        while (index >= 0 && (offset > 0 || first)) {\n+\n+            cell = getAvailableCell(index);\n+            setCellIndex(cell, index);\n+            resizeCell(cell); \/\/ resize must be after config\n+            cells.addFirst(cell);\n+\n+            \/\/ A little gross but better than alternatives because it reduces\n+            \/\/ the number of times we have to update a cell or compute its\n+            \/\/ size. The first time into this loop \"offset\" is actually the\n+            \/\/ top of the current index. On all subsequent visits, it is the\n+            \/\/ bottom of the current index.\n+            if (first) {\n+                first = false;\n+            } else {\n+                offset -= getCellLength(cell);\n+            }\n+            \/\/ Position the cell, and update the maxPrefBreadth variable as we go.\n+            positionCell(cell, offset);\n+            setMaxPrefBreadth(Math.max(getMaxPrefBreadth(), getCellBreadth(cell)));\n+            cell.setVisible(true);\n+            --index;\n+        }\n+\n+        \/\/ There are times when after laying out the cells we discover that\n+        \/\/ the top of the first cell which represents index 0 is below the top\n+        \/\/ of the viewport. In these cases, we have to adjust the cells up\n+        \/\/ and reset the mapper position. This might happen when items got\n+        \/\/ removed at the top or when the viewport size increased.\n+        if (cells.size() > 0) {\n+            cell = cells.getFirst();\n+            int firstIndex = getCellIndex(cell);\n+            double firstCellPos = getCellPosition(cell);\n+            if (firstIndex == 0 && firstCellPos > 0) {\n+                setPosition(0.0f);\n+                offset = 0;\n+                for (int i = 0; i < cells.size(); i++) {\n+                    cell = cells.get(i);\n+                    positionCell(cell, offset);\n+                    offset += getCellLength(cell);\n+                }\n+            }\n+        } else {\n+            \/\/ reset scrollbar to top, so if the flow sees cells again it starts at the top\n+            vbar.setValue(0);\n+            hbar.setValue(0);\n+        }\n+    }\n+\n+    \/**\n+     * Adds all the trailing cells that come <em>after<\/em> the last index in\n+     * the cells ObservableList.\n+     *\/\n+    boolean addTrailingCells(boolean fillEmptyCells) {\n+        \/\/ If cells is empty then addLeadingCells bailed for some reason and\n+        \/\/ we're hosed, so just punt\n+        if (cells.isEmpty()) return false;\n+\n+        \/\/ While we have not yet laid out so many cells that they would fall\n+        \/\/ off the flow, so we will continue to create and add cells. When the\n+        \/\/ offset becomes greater than the width\/height of the flow, then we\n+        \/\/ know we cannot add any more cells.\n+        T startCell = cells.getLast();\n+        double offset = getCellPosition(startCell) + getCellLength(startCell);\n+        int index = getCellIndex(startCell) + 1;\n+        final int cellCount = getCellCount();\n+        boolean filledWithNonEmpty = index <= cellCount;\n+\n+        final double viewportLength = getViewportLength();\n+\n+        \/\/ Fix for RT-37421, which was a regression caused by RT-36556\n+        if (offset < 0 && !fillEmptyCells) {\n+            return false;\n+        }\n+\n+        \/\/\n+        \/\/ RT-36507: viewportLength gives the maximum number of\n+        \/\/ additional cells that should ever be able to fit in the viewport if\n+        \/\/ every cell had a height of 1. If index ever exceeds this count,\n+        \/\/ then offset is not incrementing fast enough, or at all, which means\n+        \/\/ there is something wrong with the cell size calculation.\n+        \/\/\n+        final double maxCellCount = viewportLength;\n+        while (offset < viewportLength) {\n+            if (index >= cellCount) {\n+                if (offset < viewportLength) filledWithNonEmpty = false;\n+                if (! fillEmptyCells) return filledWithNonEmpty;\n+                \/\/ RT-36507 - return if we've exceeded the maximum\n+                if (index > maxCellCount) {\n+                    final PlatformLogger logger = Logging.getControlsLogger();\n+                    if (logger.isLoggable(PlatformLogger.Level.INFO)) {\n+                        logger.info(\"index exceeds maxCellCount. Check size calculations for \" + startCell.getClass());\n+                    }\n+                    return filledWithNonEmpty;\n+                }\n+            }\n+            T cell = getAvailableCell(index);\n+            setCellIndex(cell, index);\n+            resizeCell(cell); \/\/ resize happens after config!\n+            cells.addLast(cell);\n+            \/\/ Position the cell and update the max pref\n+            positionCell(cell, offset);\n+            setMaxPrefBreadth(Math.max(getMaxPrefBreadth(), getCellBreadth(cell)));\n+\n+            offset += getCellLength(cell);\n+            cell.setVisible(true);\n+            ++index;\n+        }\n+\n+        \/\/ Discover whether the first cell coincides with index #0. If after\n+        \/\/ adding all the trailing cells we find that a) the first cell was\n+        \/\/ not index #0 and b) there are trailing cells, then we have a\n+        \/\/ problem. We need to shift all the cells down and add leading cells,\n+        \/\/ one at a time, until either the very last non-empty cells is aligned\n+        \/\/ with the bottom OR we have laid out cell index #0 at the first\n+        \/\/ position.\n+        T firstCell = cells.getFirst();\n+        index = getCellIndex(firstCell);\n+        T lastNonEmptyCell = getLastVisibleCell();\n+        double start = getCellPosition(firstCell);\n+        double end = getCellPosition(lastNonEmptyCell) + getCellLength(lastNonEmptyCell);\n+        if ((index != 0 || (index == 0 && start < 0)) && fillEmptyCells &&\n+                lastNonEmptyCell != null && getCellIndex(lastNonEmptyCell) == cellCount - 1 && end < viewportLength) {\n+\n+            double prospectiveEnd = end;\n+            double distance = viewportLength - end;\n+            while (prospectiveEnd < viewportLength && index != 0 && (-start) < distance) {\n+                index--;\n+                T cell = getAvailableCell(index);\n+                setCellIndex(cell, index);\n+                resizeCell(cell); \/\/ resize must be after config\n+                cells.addFirst(cell);\n+                double cellLength = getCellLength(cell);\n+                start -= cellLength;\n+                prospectiveEnd += cellLength;\n+                positionCell(cell, start);\n+                setMaxPrefBreadth(Math.max(getMaxPrefBreadth(), getCellBreadth(cell)));\n+                cell.setVisible(true);\n+            }\n+\n+            \/\/ The amount by which to translate the cells down\n+            firstCell = cells.getFirst();\n+            start = getCellPosition(firstCell);\n+            double delta = viewportLength - end;\n+            if (getCellIndex(firstCell) == 0 && delta > (-start)) {\n+                delta = (-start);\n+            }\n+            \/\/ Move things\n+            for (int i = 0; i < cells.size(); i++) {\n+                T cell = cells.get(i);\n+                positionCell(cell, getCellPosition(cell) + delta);\n+            }\n+\n+            \/\/ Check whether the first cell, subsequent to our adjustments, is\n+            \/\/ now index #0 and aligned with the top. If so, change the position\n+            \/\/ to be at 0 instead of 1.\n+            start = getCellPosition(firstCell);\n+            if (getCellIndex(firstCell) == 0 && start == 0) {\n+                setPosition(0);\n+            } else if (getPosition() != 1) {\n+                setPosition(1);\n+            }\n+        }\n+\n+        return filledWithNonEmpty;\n+    }\n+\n+    \/**\n+     * Informs the {@code VirtualFlow} that a layout pass should be done, and the cell contents have not changed. For\n+     * example, this might be called from a {@code TableView} or {@code ListView} when a layout is needed and no cells\n+     * have been added or removed.\n+     *\n+     * @since 12\n+     *\/\n+    protected void reconfigureCells() {\n+        needsReconfigureCells = true;\n+        requestLayout();\n+    }\n+\n+    \/**\n+     * Informs the {@code VirtualFlow} that a layout pass should be done, and that the cell factory has changed. All\n+     * cells in the viewport are recreated with the new cell factory.\n+     *\n+     * @since 12\n+     *\/\n+    protected void recreateCells() {\n+        needsRecreateCells = true;\n+        requestLayout();\n+    }\n+\n+    \/**\n+     * Informs the {@code VirtualFlow} that a layout pass should be done, and cell contents have changed. All cells are\n+     * removed and then added properly in the viewport.\n+     *\n+     * @since 12\n+     *\/\n+    protected void rebuildCells() {\n+        needsRebuildCells = true;\n+        requestLayout();\n+    }\n+\n+    \/**\n+     * Informs the {@code VirtualFlow} that a layout pass should be done and only the cell layout will be requested.\n+     *\n+     * @since 12\n+     *\/\n+    protected void requestCellLayout() {\n+        needsCellsLayout = true;\n+        requestLayout();\n+    }\n+\n+    void setCellDirty(int index) {\n+        dirtyCells.set(index);\n+        requestLayout();\n+    }\n+\n+    \/**\n+     * Make sure the sizes of the cells that are likely to be visible are known.\n+     * When updates to the cell size estimates are occurring, we don't want the current\n+     * visible content to be modified. The existing offset and index are respected.\n+     * @param index the index of the cell that should be positioned at the top of\n+     * the viewport in the next layout cycle.\n+     *\/\n+    void getCellSizesInExpectedViewport(int index) {\n+        double oldOffset = computeViewportOffset(getPosition());\n+        int oldIndex = computeCurrentIndex();\n+        double cellLength = getOrCreateCellSize(index);\n+        if (index > 0) {\n+            getOrCreateCellSize(index - 1);\n+        }\n+        if (index < getCellCount() - 1) {\n+            getOrCreateCellSize(index + 1);\n+        }\n+        double estlength = cellLength;\n+        int i = index;\n+        while ((estlength < viewportLength) && (++i < getCellCount())) {\n+            estlength = estlength + getOrCreateCellSize(i);\n+        }\n+        estlength = cellLength;\n+        if (estlength < viewportLength) {\n+            int j = index;\n+            while ((estlength < viewportLength) && (j-- > 0)) {\n+                estlength = estlength + getOrCreateCellSize(j);\n+            }\n+        }\n+        recalculateAndImproveEstimatedSize(0, oldIndex, oldOffset);\n+    }\n+\n+    private void startSBReleasedAnimation() {\n+        if (sbTouchTimeline == null) {\n+            \/*\n+            ** timeline to leave the scrollbars visible for a short\n+            ** while after a scroll\/drag\n+            *\/\n+            sbTouchTimeline = new Timeline();\n+            sbTouchKF1 = new KeyFrame(Duration.millis(0), event -> {\n+                tempVisibility = true;\n+                requestLayout();\n+            });\n+\n+            sbTouchKF2 = new KeyFrame(Duration.millis(1000), event -> {\n+                if (touchDetected == false && mouseDown == false) {\n+                    tempVisibility = false;\n+                    requestLayout();\n+                }\n+            });\n+            sbTouchTimeline.getKeyFrames().addAll(sbTouchKF1, sbTouchKF2);\n+        }\n+        sbTouchTimeline.playFromStart();\n+    }\n+\n+    private void scrollBarOn() {\n+        tempVisibility = true;\n+        requestLayout();\n+    }\n+\n+    void updateHbar() {\n+        if (! isVisible() || getScene() == null) return;\n+        \/\/ Bring the clipView.clipX back to 0 if control is vertical or\n+        \/\/ the hbar isn't visible (fix for RT-11666)\n+        if (isVertical()) {\n+            if (needBreadthBar) {\n+                clipView.setClipX(hbar.getValue());\n+            } else {\n+                \/\/ all cells are now less than the width of the flow,\n+                \/\/ so we should shift the hbar\/clip such that\n+                \/\/ everything is visible in the viewport.\n+                clipView.setClipX(0);\n+                hbar.setValue(0);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Suppresses the breadth bar from appearing.\n+     *\/\n+    void setSuppressBreadthBar(boolean suppress) {\n+        this.suppressBreadthBar = suppress;\n+    }\n+\n+    \/**\n+     * @return true if bar visibility changed\n+     *\/\n+    private boolean computeBarVisiblity() {\n+        if (cells.isEmpty()) {\n+            \/\/ In case no cells are set yet, we assume no bars are needed\n+            needLengthBar = false;\n+            needBreadthBar = false;\n+            return true;\n+        }\n+\n+        final boolean isVertical = isVertical();\n+        boolean barVisibilityChanged = false;\n+\n+        VirtualScrollBar breadthBar = isVertical ? hbar : vbar;\n+        VirtualScrollBar lengthBar = isVertical ? vbar : hbar;\n+\n+        final double viewportBreadth = getViewportBreadth();\n+\n+        final int cellsSize = cells.size();\n+        final int cellCount = getCellCount();\n+        for (int i = 0; i < 2; i++) {\n+            final boolean lengthBarVisible = getPosition() > 0\n+                    || cellCount > cellsSize\n+                    || (cellCount == cellsSize && (getCellPosition(cells.getLast()) + getCellLength(cells.getLast())) > getViewportLength())\n+                    || (cellCount == cellsSize - 1 && barVisibilityChanged && needBreadthBar);\n+\n+            if (lengthBarVisible ^ needLengthBar) {\n+                needLengthBar = lengthBarVisible;\n+                barVisibilityChanged = true;\n+            }\n+\n+            final boolean breadthBarVisible = !suppressBreadthBar && (maxPrefBreadth > viewportBreadth);\n+            if (breadthBarVisible ^ needBreadthBar) {\n+                needBreadthBar = breadthBarVisible;\n+                barVisibilityChanged = true;\n+            }\n+        }\n+\n+        \/\/ Start by optimistically deciding whether the length bar and\n+        \/\/ breadth bar are needed and adjust the viewport dimensions\n+        \/\/ accordingly. If during layout we find that one or the other of the\n+        \/\/ bars actually is needed, then we will perform a cleanup pass\n+\n+        if (!Properties.IS_TOUCH_SUPPORTED) {\n+            updateViewportDimensions();\n+            breadthBar.setVisible(needBreadthBar);\n+            lengthBar.setVisible(needLengthBar);\n+        } else {\n+            breadthBar.setVisible(needBreadthBar && tempVisibility);\n+            lengthBar.setVisible(needLengthBar && tempVisibility);\n+        }\n+        return barVisibilityChanged;\n+    }\n+\n+    private void updateViewportDimensions() {\n+        final boolean isVertical = isVertical();\n+        final double breadthBarLength = isVertical ? snapSizeY(hbar.prefHeight(-1)) : snapSizeX(vbar.prefWidth(-1));\n+        final double lengthBarBreadth = isVertical ? snapSizeX(vbar.prefWidth(-1)) : snapSizeY(hbar.prefHeight(-1));\n+\n+        if (!Properties.IS_TOUCH_SUPPORTED) {\n+            setViewportBreadth((isVertical ? getWidth() : getHeight()) - (needLengthBar ? lengthBarBreadth : 0));\n+            setViewportLength((isVertical ? getHeight() : getWidth()) - (needBreadthBar ? breadthBarLength : 0));\n+        } else {\n+            setViewportBreadth((isVertical ? getWidth() : getHeight()));\n+            setViewportLength((isVertical ? getHeight() : getWidth()));\n+        }\n+    }\n+\n+    private void initViewport() {\n+        \/\/ Initialize the viewportLength and viewportBreadth to match the\n+        \/\/ width\/height of the flow\n+        final boolean isVertical = isVertical();\n+\n+        updateViewportDimensions();\n+\n+        VirtualScrollBar breadthBar = isVertical ? hbar : vbar;\n+        VirtualScrollBar lengthBar = isVertical ? vbar : hbar;\n+\n+        \/\/ If there has been a switch between the virtualized bar, then we\n+        \/\/ will want to do some stuff TODO.\n+        breadthBar.setVirtual(false);\n+        lengthBar.setVirtual(true);\n+    }\n+\n+    \/**\n+     * In case we are not rendering the first cell\n+     * AND\n+     * there is empty room after the last cell,\n+     * the cells need to be shifted down to fill the empty area.\n+     *\/\n+    private void shiftDown() {\n+        T lastNonEmptyCell = getLastVisibleCell();\n+        T firstCell = cells.getFirst();\n+        int index = getCellIndex(firstCell);\n+        double end = getCellPosition(lastNonEmptyCell) + getCellLength(lastNonEmptyCell);\n+        double delta = viewportLength - end;\n+        if ((index > 0) && (delta > 0)) {\n+            for (int i = 0; i < cells.size(); i++) {\n+                T cell = cells.get(i);\n+                positionCell(cell, getCellPosition(cell) + delta);\n+            }\n+        }\n+    }\n+\n+    private void updateScrollBarsAndCells(boolean recreate) {\n+        \/\/ Assign the hbar and vbar to the breadthBar and lengthBar so as\n+        \/\/ to make some subsequent calculations easier.\n+        final boolean isVertical = isVertical();\n+        VirtualScrollBar breadthBar = isVertical ? hbar : vbar;\n+        VirtualScrollBar lengthBar = isVertical ? vbar : hbar;\n+\n+        \/\/ We may have adjusted the viewport length and breadth after the\n+        \/\/ layout due to scroll bars becoming visible. So we need to perform\n+        \/\/ a follow up pass and resize and shift all the cells to fit the\n+        \/\/ viewport. Note that the prospective viewport size is always >= the\n+        \/\/ final viewport size, so we don't have to worry about adding\n+        \/\/ cells during this cleanup phase.\n+        fitCells();\n+\n+        \/\/ Update cell positions.\n+        \/\/ When rebuilding the cells, we add the cells and along the way compute\n+        \/\/ the maxPrefBreadth. Based on the computed value, we may add\n+        \/\/ the breadth scrollbar which changes viewport length, so we need\n+        \/\/ to re-position the cells.\n+        if (!cells.isEmpty()) {\n+            final double currOffset = -computeViewportOffset(getPosition());\n+            final int currIndex = computeCurrentIndex() - cells.getFirst().getIndex();\n+            final int size = cells.size();\n+\n+            \/\/ position leading cells\n+            double offset = currOffset;\n+\n+            for (int i = currIndex - 1; i >= 0 && i < size; i--) {\n+                final T cell = cells.get(i);\n+\n+                offset -= getCellLength(cell);\n+\n+                positionCell(cell, offset);\n+            }\n+\n+            \/\/ position trailing cells\n+            offset = currOffset;\n+            for (int i = currIndex; i >= 0 && i < size; i++) {\n+                final T cell = cells.get(i);\n+                positionCell(cell, offset);\n+\n+                offset += getCellLength(cell);\n+            }\n+            shiftDown();\n+        }\n+\n+        \/\/ Toggle visibility on the corner\n+        corner.setVisible(breadthBar.isVisible() && lengthBar.isVisible());\n+\n+        double sumCellLength = 0;\n+        double flowLength = (isVertical ? getHeight() : getWidth()) -\n+                (breadthBar.isVisible() ? breadthBar.prefHeight(-1) : 0);\n+\n+        final double viewportBreadth = getViewportBreadth();\n+        final double viewportLength = getViewportLength();\n+\n+        \/\/ Now position and update the scroll bars\n+        if (breadthBar.isVisible()) {\n+            \/*\n+            ** Positioning the ScrollBar\n+            *\/\n+            if (!Properties.IS_TOUCH_SUPPORTED) {\n+                if (isVertical) {\n+                    hbar.resizeRelocate(0, viewportLength,\n+                            viewportBreadth, hbar.prefHeight(viewportBreadth));\n+                } else {\n+                    vbar.resizeRelocate(viewportLength, 0,\n+                            vbar.prefWidth(viewportBreadth), viewportBreadth);\n+                }\n+            }\n+            else {\n+                if (isVertical) {\n+                    double prefHeight = hbar.prefHeight(viewportBreadth);\n+                    hbar.resizeRelocate(0, viewportLength - prefHeight,\n+                            viewportBreadth, prefHeight);\n+                } else {\n+                    double prefWidth = vbar.prefWidth(viewportBreadth);\n+                    vbar.resizeRelocate(viewportLength - prefWidth, 0,\n+                            prefWidth, viewportBreadth);\n+                }\n+            }\n+\n+            if (getMaxPrefBreadth() != -1) {\n+                double newMax = Math.max(1, getMaxPrefBreadth() - viewportBreadth);\n+                if (newMax != breadthBar.getMax()) {\n+                    breadthBar.setMax(newMax);\n+\n+                    double breadthBarValue = breadthBar.getValue();\n+                    boolean maxed = breadthBarValue != 0 && newMax == breadthBarValue;\n+                    if (maxed || breadthBarValue > newMax) {\n+                        breadthBar.setValue(newMax);\n+                    }\n+\n+                    breadthBar.setVisibleAmount((viewportBreadth \/ getMaxPrefBreadth()) * newMax);\n+                }\n+            }\n+        }\n+\n+        \/\/ determine how many cells there are on screen so that the scrollbar\n+        \/\/ thumb can be appropriately sized\n+        if (recreate && (lengthBar.isVisible() || Properties.IS_TOUCH_SUPPORTED)) {\n+            final int cellCount = getCellCount();\n+            int numCellsVisibleOnScreen = 0;\n+            for (int i = 0, max = cells.size(); i < max; i++) {\n+                T cell = cells.get(i);\n+                if (cell != null && !cell.isEmpty()) {\n+                    sumCellLength += (isVertical ? cell.getHeight() : cell.getWidth());\n+                    if (sumCellLength > flowLength) {\n+                        break;\n+                    }\n+\n+                    numCellsVisibleOnScreen++;\n+                }\n+            }\n+\n+            lengthBar.setMax(1);\n+            if (numCellsVisibleOnScreen == 0 && cellCount == 1) {\n+                \/\/ special case to help resolve RT-17701 and the case where we have\n+                \/\/ only a single row and it is bigger than the viewport\n+                lengthBar.setVisibleAmount(flowLength \/ sumCellLength);\n+            } else {\n+                lengthBar.setVisibleAmount(viewportLength \/ estimatedSize);\n+            }\n+        }\n+\n+        if (lengthBar.isVisible()) {\n+            \/\/ Fix for RT-11873. If this isn't here, we can have a situation where\n+            \/\/ the scrollbar scrolls endlessly. This is possible when the cell\n+            \/\/ count grows as the user hits the maximal position on the scrollbar\n+            \/\/ (i.e. the list size dynamically grows as the user needs more).\n+            \/\/\n+            \/\/ This code was commented out to resolve RT-14477 after testing\n+            \/\/ whether RT-11873 can be recreated. It could not, and therefore\n+            \/\/ for now this code will remained uncommented until it is deleted\n+            \/\/ following further testing.\n+\/\/            if (lengthBar.getValue() == 1.0 && lastCellCount != cellCount) {\n+\/\/                lengthBar.setValue(0.99);\n+\/\/            }\n+\n+            \/*\n+            ** Positioning the ScrollBar\n+            *\/\n+            if (!Properties.IS_TOUCH_SUPPORTED) {\n+                if (isVertical) {\n+                    vbar.resizeRelocate(viewportBreadth, 0, vbar.prefWidth(viewportLength), viewportLength);\n+                } else {\n+                    hbar.resizeRelocate(0, viewportBreadth, viewportLength, hbar.prefHeight(-1));\n+                }\n+            }\n+            else {\n+                if (isVertical) {\n+                    double prefWidth = vbar.prefWidth(viewportLength);\n+                    vbar.resizeRelocate(viewportBreadth - prefWidth, 0, prefWidth, viewportLength);\n+                } else {\n+                    double prefHeight = hbar.prefHeight(-1);\n+                    hbar.resizeRelocate(0, viewportBreadth - prefHeight, viewportLength, prefHeight);\n+                }\n+            }\n+        }\n+\n+        if (corner.isVisible()) {\n+            if (!Properties.IS_TOUCH_SUPPORTED) {\n+                corner.resize(vbar.getWidth(), hbar.getHeight());\n+                corner.relocate(hbar.getLayoutX() + hbar.getWidth(), vbar.getLayoutY() + vbar.getHeight());\n+            }\n+            else {\n+                corner.resize(vbar.getWidth(), hbar.getHeight());\n+                corner.relocate(hbar.getLayoutX() + (hbar.getWidth()-vbar.getWidth()), vbar.getLayoutY() + (vbar.getHeight()-hbar.getHeight()));\n+                hbar.resize(hbar.getWidth()-vbar.getWidth(), hbar.getHeight());\n+                vbar.resize(vbar.getWidth(), vbar.getHeight()-hbar.getHeight());\n+            }\n+        }\n+\n+        clipView.resize(snapSizeX(isVertical ? viewportBreadth : viewportLength),\n+                        snapSizeY(isVertical ? viewportLength : viewportBreadth));\n+\n+        \/\/ If the viewportLength becomes large enough that all cells fit\n+        \/\/ within the viewport, then we want to update the value to match.\n+        if (getPosition() != lengthBar.getValue()) {\n+            lengthBar.setValue(getPosition());\n+        }\n+    }\n+\n+    \/**\n+     * Adjusts the cells location and size if necessary. The breadths of all\n+     * cells will be adjusted to fit the viewportWidth or maxPrefBreadth, and\n+     * the layout position will be updated if necessary based on index and\n+     * offset.\n+     *\/\n+    private void fitCells() {\n+        double size = Math.max(getMaxPrefBreadth(), getViewportBreadth());\n+        boolean isVertical = isVertical();\n+\n+        \/\/ Note: Do not optimise this loop by pre-calculating the cells size and\n+        \/\/ storing that into a int value - this can lead to RT-32828\n+        for (int i = 0; i < cells.size(); i++) {\n+            Cell<?> cell = cells.get(i);\n+            if (isVertical) {\n+                cell.resize(size, cell.prefHeight(size));\n+            } else {\n+                cell.resize(cell.prefWidth(size), size);\n+            }\n+        }\n+    }\n+\n+    private void cull() {\n+        final double viewportLength = getViewportLength();\n+        for (int i = cells.size() - 1; i >= 0; i--) {\n+            T cell = cells.get(i);\n+            double cellSize = getCellLength(cell);\n+            double cellStart = getCellPosition(cell);\n+            double cellEnd = cellStart + cellSize;\n+            if (cellStart >= viewportLength || cellEnd < 0) {\n+                addToPile(cells.remove(i));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * After using the accum cell, it needs to be released!\n+     *\/\n+    private void releaseCell(T cell) {\n+        if (accumCell != null && cell == accumCell) {\n+            accumCell.setVisible(false);\n+            accumCell.updateIndex(-1);\n+        }\n+    }\n+\n+\n+    \/**\n+     * Creates and returns a new cell for the given index.\n+     * <p>\n+     * If the requested index is not already an existing visible cell, it will create a cell for the given index and\n+     * insert it into the {@code VirtualFlow} container. If the index exists, simply returns the visible cell. From that\n+     * point on, it will be unmanaged, and is up to the caller of this method to manage it.\n+     * <p>\n+     * This is useful if a row that should not be visible must be accessed (a row that always stick to the top for\n+     * example). It can then be easily created, correctly initialized and inserted in the {@code VirtualFlow}\n+     * container.\n+     *\n+     * @param index the cell index\n+     * @return a cell for the given index inserted in the VirtualFlow container\n+     * @since 12\n+     *\/\n+    protected T getPrivateCell(int index)  {\n+        T cell = null;\n+\n+        \/\/ If there are cells, then we will attempt to get an existing cell\n+        if (! cells.isEmpty()) {\n+            \/\/ First check the cells that have already been created and are\n+            \/\/ in use. If this call returns a value, then we can use it\n+            cell = getVisibleCell(index);\n+            if (cell != null) {\n+                \/\/ Force the underlying text inside the cell to be updated\n+                \/\/ so that when the screen reader runs, it will match the\n+                \/\/ text in the cell (force updateDisplayedText())\n+                cell.layout();\n+                return cell;\n+            }\n+        }\n+\n+        \/\/ check the existing sheet children\n+        if (cell == null) {\n+            for (int i = 0; i < sheetChildren.size(); i++) {\n+                T _cell = (T) sheetChildren.get(i);\n+                if (getCellIndex(_cell) == index) {\n+                    return _cell;\n+                }\n+            }\n+        }\n+\n+        Callback<VirtualFlow<T>, T> cellFactory = getCellFactory();\n+        if (cellFactory != null) {\n+            cell = cellFactory.call(this);\n+        }\n+\n+        if (cell != null) {\n+            setCellIndex(cell, index);\n+            resizeCell(cell);\n+            cell.setVisible(false);\n+            sheetChildren.add(cell);\n+            privateCells.add(cell);\n+        }\n+\n+        return cell;\n+    }\n+\n+    private final List<T> privateCells = new ArrayList<>();\n+\n+    private void releaseAllPrivateCells() {\n+        sheetChildren.removeAll(privateCells);\n+        privateCells.clear();\n+    }\n+\n+    \/**\n+     * Puts the given cell onto the pile. This is called whenever a cell has\n+     * fallen off the flow's start.\n+     *\/\n+    private void addToPile(T cell) {\n+        assert cell != null;\n+        pile.addLast(cell);\n+    }\n+\n+    private void cleanPile() {\n+        boolean wasFocusOwner = false;\n+\n+        for (int i = 0, max = pile.size(); i < max; i++) {\n+            T cell = pile.get(i);\n+            wasFocusOwner = wasFocusOwner || doesCellContainFocus(cell);\n+            cell.setVisible(false);\n+        }\n+\n+        \/\/ Fix for RT-35876: Rather than have the cells do weird things with\n+        \/\/ focus (in particular, have focus jump between cells), we return focus\n+        \/\/ to the VirtualFlow itself.\n+        if (wasFocusOwner) {\n+            requestFocus();\n+        }\n+    }\n+\n+    private boolean doesCellContainFocus(Cell<?> c) {\n+        Scene scene = c.getScene();\n+        final Node focusOwner = scene == null ? null : scene.getFocusOwner();\n+\n+        if (focusOwner != null) {\n+            if (c.equals(focusOwner)) {\n+                return true;\n+            }\n+\n+            Parent p = focusOwner.getParent();\n+            while (p != null && ! (p instanceof VirtualFlow)) {\n+                if (c.equals(p)) {\n+                    return true;\n+                }\n+                p = p.getParent();\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    private double getPrefBreadth(double oppDimension) {\n+        double max = getMaxCellWidth(10);\n+\n+        \/\/ This primarily exists for the case where we do not want the breadth\n+        \/\/ to grow to ensure a golden ratio between width and height (for example,\n+        \/\/ when a ListView is used in a ComboBox - the width should not grow\n+        \/\/ just because items are being added to the ListView)\n+        if (oppDimension > -1) {\n+            double prefLength = getPrefLength();\n+            max = Math.max(max, prefLength * GOLDEN_RATIO_MULTIPLIER);\n+        }\n+\n+        return max;\n+    }\n+\n+    private double getPrefLength() {\n+        double sum = 0.0;\n+        int rows = Math.min(10, getCellCount());\n+        for (int i = 0; i < rows; i++) {\n+            sum += getCellLength(i);\n+        }\n+        return sum;\n+    }\n+\n+    double getMaxCellWidth(int rowsToCount) {\n+        double max = 0.0;\n+\n+        \/\/ we always measure at least one row\n+        int rows = Math.max(1, rowsToCount == -1 ? getCellCount() : rowsToCount);\n+        for (int i = 0; i < rows; i++) {\n+            max = Math.max(max, getCellBreadth(i));\n+        }\n+        return max;\n+    }\n+\n+    \/\/ Old PositionMapper\n+    \/**\n+     * Given a position value between 0 and 1, compute and return the viewport\n+     * offset from the \"current\" cell associated with that position value.\n+     * That is, if the return value of this function where used as a translation\n+     * factor for a sheet that contained all the items, then the current\n+     * item would end up positioned correctly.\n+     * We calculate the total size until the absoluteoffset is reached.\n+     * For this calculation, we use the cached sizes for each item, or an\n+     * educated guess in case we don't have a cached size yet. While we could\n+     * fill the cache with the size here, we do not do it as it will affect\n+     * performance.\n+     *\/\n+    private double computeViewportOffset(double position) {\n+        double p = com.sun.javafx.util.Utils.clamp(0, position, 1);\n+        double bound = 0d;\n+        double estSize = estimatedSize \/ getCellCount();\n+        double maxOff = estimatedSize - getViewportLength();\n+        if ((maxOff > 0) && (absoluteOffset > maxOff)) {\n+            return maxOff - absoluteOffset;\n+        }\n+\n+        for (int i = 0; i < getCellCount(); i++) {\n+            double h = getCellSize(i);\n+            if (h < 0) h = estSize;\n+            if (bound + h > absoluteOffset) {\n+                return absoluteOffset - bound;\n+            }\n+            bound += h;\n+        }\n+        return 0d;\n+    }\n+\n+    private void adjustPositionToIndex(int index) {\n+        if (index > 0) getOrCreateCellSize(index-1);\n+        getOrCreateCellSize(index);\n+        recalculateEstimatedSize();\n+        int cellCount = getCellCount();\n+        if (cellCount <= 0) {\n+            setPosition(0.0f);\n+        } else {\n+            double targetOffset = 0;\n+            double estSize = estimatedSize\/cellCount;\n+            for (int i = 0; i < index; i++) {\n+                double cz = getCellSize(i);\n+                if (cz < 0) cz = estSize;\n+                targetOffset = targetOffset+ cz;\n+            }\n+            this.absoluteOffset = (estimatedSize < viewportLength)  ? 0  : targetOffset;\n+            adjustPosition();\n+        }\n+\n+    }\n+\n+    \/**\n+     * Adjust the position based on a delta of pixels. If negative, then the\n+     * position will be adjusted negatively. If positive, then the position will\n+     * be adjusted positively. If the pixel amount is too great for the range of\n+     * the position, then it will be clamped such that position is always\n+     * strictly between 0 and 1\n+     * @return the actual number of pixels that have been applied\n+     *\/\n+    private double adjustByPixelAmount(double numPixels) {\n+        if (numPixels == 0) return 0;\n+        \/\/ When we're at the top already, we can't move back further, unless we\n+        \/\/ want to allow for gravity-alike effects.\n+        if ((absoluteOffset <= 0) && (numPixels < 0)) return 0;\n+\n+        \/\/ start with applying the requested modification\n+        double origAbsoluteOffset = this.absoluteOffset;\n+        this.absoluteOffset = Math.max(0.d, this.absoluteOffset + numPixels);\n+        double newPosition = Math.min(1.0d, absoluteOffset \/ (estimatedSize - viewportLength));\n+        \/\/ estimatedSize changes may result in opposite effect on position\n+        \/\/ in that case, modify current position 1% in the requested direction\n+        if ((numPixels > 0) && (newPosition < getPosition())) {\n+            newPosition = getPosition()*1.01;\n+        }\n+        if ((numPixels < 0) && (newPosition > getPosition())) {\n+            newPosition = getPosition()*.99;\n+        }\n+\n+        \/\/ once at 95% of the total estimated size, we want a correct size, not\n+        \/\/ an estimated size anymore.\n+        if (newPosition > .95) {\n+            int cci = computeCurrentIndex();\n+            while (cci < getCellCount()) {\n+                getOrCreateCellSize(cci); cci++;\n+            }\n+            recalculateEstimatedSize();\n+        }\n+\n+        \/\/ if we are at or beyond the edge, correct the absoluteOffset\n+        if (newPosition >= 1.d) {\n+            absoluteOffset = estimatedSize - viewportLength;\n+        }\n+\n+        setPosition(newPosition);\n+        return absoluteOffset - origAbsoluteOffset;\n+\n+    }\n+\n+    private int computeCurrentIndex() {\n+        double total = 0;\n+        int currentCellCount = getCellCount();\n+        double estSize = estimatedSize \/ currentCellCount;\n+        for (int i = 0; i < currentCellCount; i++) {\n+            double nextSize = getCellSize(i);\n+            if (nextSize < 0) nextSize = estSize;\n+            total = total + nextSize;\n+            if (total > absoluteOffset) {\n+                return i;\n+            }\n+        }\n+        return currentCellCount == 0 ? 0 : currentCellCount - 1;\n+    }\n+\n+    \/**\n+     * Given an item index, this function will compute and return the viewport\n+     * offset from the beginning of the specified item. Notice that because each\n+     * item has the same percentage of the position dedicated to it, and since\n+     * we are measuring from the start of each item, this is a very simple\n+     * calculation.\n+     *\/\n+    private double computeOffsetForCell(int itemIndex) {\n+        double cellCount = getCellCount();\n+        double p = com.sun.javafx.util.Utils.clamp(0, itemIndex, cellCount) \/ cellCount;\n+        return -(getViewportLength() * p);\n+    }\n+\n+    double getCellSize(int idx) {\n+        return getOrCreateCellSize(idx, false);\n+    }\n+\n+    \/**\n+     * Get the size of the considered element.\n+     * If the requested element has a size that is not yet in the cache,\n+     * it will be computed and cached now.\n+     * @return the size of the element; or 1 in case there are no cells yet\n+     *\/\n+    double getOrCreateCellSize(int idx) {\n+        return getOrCreateCellSize (idx, true);\n+    }\n+\n+    private double getOrCreateCellSize (int idx, boolean create) {\n+        if (idx < 0) return -1;\n+        \/\/ is the current cache long enough to contain idx?\n+        if (itemSizeCache.size() > idx) {\n+            \/\/ is there a non-null value stored in the cache?\n+            if (itemSizeCache.get(idx) != null) {\n+                return itemSizeCache.get(idx);\n+            }\n+        }\n+        if (!create) return -1;\n+        boolean doRelease = false;\n+\n+        \/\/ Make sure we have enough space in the cache to store this index\n+        while (idx >= itemSizeCache.size()) {\n+            itemSizeCache.add(itemSizeCache.size(), null);\n+        }\n+\n+        double answer = 1d;\n+        if (getFixedCellSize() > 0) {\n+            answer = getFixedCellSize();\n+            itemSizeCache.set(idx, answer);\n+        } else {\n+            \/\/ Do we have a visible cell for this index?\n+            T cell = getVisibleCell(idx);\n+            if (cell == null) { \/\/ we might get the accumcell here\n+                cell = getCell(idx);\n+                doRelease = true;\n+            }\n+\n+            \/\/ if we have a valid cell, we can populate the cache\n+            if (isVertical()) {\n+                answer = cell.getLayoutBounds().getHeight();\n+            } else {\n+                answer = cell.getLayoutBounds().getWidth();\n+            }\n+            itemSizeCache.set(idx, answer);\n+\n+            if (doRelease) { \/\/ we need to release the accumcell\n+                releaseCell(cell);\n+            }\n+        }\n+        return answer;\n+    }\n+\n+    \/**\n+     * Update the size of a specific cell.\n+     * If this cell was already in the cache, its old value is replaced by the\n+     * new size. The total size of the flow will be recalculated, respecting the\n+     * current index and offset.\n+     * If the specific cell is the \"current\" cell (which is the first cell that is\n+     * at least partially visible), the offset used for the viewport needs to be\n+     * recalculated in case the new size is different from the cached size. This way,\n+     * we keep the end of the current cell (and start of the cell at current + 1)\n+     * constant. An exception to this is when the current cell starts at offset 0,\n+     * in which case we keep the (0) offset as is.\n+     * @param cell the cell which size has to be calculated\n+     *\/\n+    void updateCellSize(T cell) {\n+        int cellIndex = cell.getIndex();\n+        int currentIndex = computeCurrentIndex();\n+        double oldOffset = computeViewportOffset(getPosition());\n+\n+\n+        if (itemSizeCache.size() > cellIndex) {\n+            Double oldSize = itemSizeCache.get(cellIndex);\n+            double newSize = isVertical() ? cell.getLayoutBounds().getHeight() : cell.getLayoutBounds().getWidth();\n+            itemSizeCache.set(cellIndex, newSize);\n+            if ((cellIndex == currentIndex) && (oldSize != null) && (oldOffset != 0)) {\n+                oldOffset = oldOffset + newSize - oldSize;\n+            }\n+        }\n+        recalculateAndImproveEstimatedSize(0, currentIndex, oldOffset);\n+    }\n+\n+    \/**\n+     * Recalculate the estimated size for this list based on what we have in the\n+     * cache.\n+     *\/\n+    private void recalculateEstimatedSize() {\n+        recalculateAndImproveEstimatedSize(DEFAULT_IMPROVEMENT);\n+    }\n+\n+    private boolean recalculating = false;\n+\n+    private void recalculateAndImproveEstimatedSize(int improve) {\n+        recalculateAndImproveEstimatedSize(improve, -1, computeViewportOffset(getPosition()));\n+    }\n+\n+    \/**\n+     * Recalculate the estimated size. If an oldIndex different from  -1 is supplied, that value will\n+     * be respected:\n+     * at the end of this calculation, we make sure that if the current index is calculated, it will\n+     * be the same as the old index. If the oldIndex is -1, there is no guarantee about the new index.\n+     *\/\n+    private void recalculateAndImproveEstimatedSize(int improve, int oldIndex, double oldOffset) {\n+        if (recalculating) return;\n+        recalculating = true;\n+        try {\n+            int itemCount = getCellCount();\n+            int cacheCount = itemSizeCache.size();\n+            boolean keepRatio = ((cacheCount > 0) && !Double.isInfinite(this.absoluteOffset));\n+\n+            if (oldIndex < 0) oldIndex = computeCurrentIndex();\n+            int added = 0;\n+            while ((itemCount > itemSizeCache.size()) && (added < improve)) {\n+                getOrCreateCellSize(itemSizeCache.size());\n+                added++;\n+            }\n+            cacheCount = itemSizeCache.size();\n+            int cnt = 0;\n+            double tot = 0d;\n+            for (int i = 0; (i < itemCount && i < cacheCount); i++) {\n+                Double il = itemSizeCache.get(i);\n+                if (il != null) {\n+                    tot = tot + il;\n+                    cnt++;\n+                }\n+            }\n+            this.estimatedSize = cnt == 0 ? 1d : tot * itemCount \/ cnt;\n+            double estSize = estimatedSize \/ itemCount;\n+\n+            if (keepRatio) {\n+                double newOffset = 0;\n+                for (int i = 0; i < oldIndex; i++) {\n+                    double h = getCellSize(i);\n+                    if (h < 0) {\n+                        h = estSize;\n+                    }\n+                    newOffset += h;\n+                }\n+                this.absoluteOffset = newOffset + oldOffset;\n+                adjustPosition();\n+            }\n+        } finally {\n+            recalculating = false;\n+        }\n+    }\n+\n+    private void resetSizeEstimates() {\n+        itemSizeCache.clear();\n+        this.estimatedSize = 1d;\n+    }\n+\n+\/\/    \/**\n+\/\/     * Adjust the position based on a chunk of pixels. The position is based\n+\/\/     * on the start of the scrollbar position.\n+\/\/     *\/\n+\/\/    private void adjustByPixelChunk(double numPixels) {\n+\/\/        setPosition(0);\n+\/\/        adjustByPixelAmount(numPixels);\n+\/\/    }\n+    \/\/ end of old PositionMapper code\n+\n+\n+\n+\n+    \/* *************************************************************************\n+     *                                                                         *\n+     * Support classes                                                         *\n+     *                                                                         *\n+     **************************************************************************\/\n+\n+    \/**\n+     * A simple extension to Region that ensures that anything wanting to flow\n+     * outside of the bounds of the Region is clipped.\n+     *\/\n+    static class ClippedContainer extends Region {\n+\n+        \/**\n+         * The Node which is embedded within this {@code ClipView}.\n+         *\/\n+        private Node node;\n+        public Node getNode() { return this.node; }\n+        public void setNode(Node n) {\n+            this.node = n;\n+\n+            getChildren().clear();\n+            getChildren().add(node);\n+        }\n+\n+        public void setClipX(double clipX) {\n+            setLayoutX(-clipX);\n+            clipRect.setLayoutX(clipX);\n+        }\n+\n+        public void setClipY(double clipY) {\n+            setLayoutY(-clipY);\n+            clipRect.setLayoutY(clipY);\n+        }\n+\n+        private final Rectangle clipRect;\n+\n+        public ClippedContainer(final VirtualFlow<?> flow) {\n+            if (flow == null) {\n+                throw new IllegalArgumentException(\"VirtualFlow can not be null\");\n+            }\n+\n+            getStyleClass().add(\"clipped-container\");\n+\n+            \/\/ clipping\n+            clipRect = new Rectangle();\n+            clipRect.setSmooth(false);\n+            setClip(clipRect);\n+            \/\/ --- clipping\n+\n+            super.widthProperty().addListener(valueModel -> {\n+                clipRect.setWidth(getWidth());\n+            });\n+            super.heightProperty().addListener(valueModel -> {\n+                clipRect.setHeight(getHeight());\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * A List-like implementation that is exceedingly efficient for the purposes\n+     * of the VirtualFlow. Typically there is not much variance in the number of\n+     * cells -- it is always some reasonably consistent number. Yet for efficiency\n+     * in code, we like to use a linked list implementation so as to append to\n+     * start or append to end. However, at times when we need to iterate, LinkedList\n+     * is expensive computationally as well as requiring the construction of\n+     * temporary iterators.\n+     * <p>\n+     * This linked list like implementation is done using an array. It begins by\n+     * putting the first item in the center of the allocated array, and then grows\n+     * outward (either towards the first or last of the array depending on whether\n+     * we are inserting at the head or tail). It maintains an index to the start\n+     * and end of the array, so that it can efficiently expose iteration.\n+     * <p>\n+     * This class is package private solely for the sake of testing.\n+     *\/\n+    static class ArrayLinkedList<T> extends AbstractList<T> {\n+        \/**\n+         * The array list backing this class. We default the size of the array\n+         * list to be fairly large so as not to require resizing during normal\n+         * use, and since that many ArrayLinkedLists won't be created it isn't\n+         * very painful to do so.\n+         *\/\n+        private final ArrayList<T> array;\n+\n+        private int firstIndex = -1;\n+        private int lastIndex = -1;\n+\n+        public ArrayLinkedList() {\n+            array = new ArrayList<>(50);\n+\n+            for (int i = 0; i < 50; i++) {\n+                array.add(null);\n+            }\n+        }\n+\n+        public T getFirst() {\n+            return firstIndex == -1 ? null : array.get(firstIndex);\n+        }\n+\n+        public T getLast() {\n+            return lastIndex == -1 ? null : array.get(lastIndex);\n+        }\n+\n+        public void addFirst(T cell) {\n+            \/\/ if firstIndex == -1 then that means this is the first item in the\n+            \/\/ list and we need to initialize firstIndex and lastIndex\n+            if (firstIndex == -1) {\n+                firstIndex = lastIndex = array.size() \/ 2;\n+                array.set(firstIndex, cell);\n+            } else if (firstIndex == 0) {\n+                \/\/ we're already at the head of the array, so insert at position\n+                \/\/ 0 and then increment the lastIndex to compensate\n+                array.add(0, cell);\n+                lastIndex++;\n+            } else {\n+                \/\/ we're not yet at the head of the array, so insert at the\n+                \/\/ firstIndex - 1 position and decrement first position\n+                array.set(--firstIndex, cell);\n+            }\n+        }\n+\n+        public void addLast(T cell) {\n+\n+            \/\/ if lastIndex == -1 then that means this is the first item in the\n+            \/\/ list and we need to initialize the firstIndex and lastIndex\n+            if (firstIndex == -1) {\n+                firstIndex = lastIndex = array.size() \/ 2;\n+                array.set(lastIndex, cell);\n+            } else if (lastIndex == array.size() - 1) {\n+                \/\/ we're at the end of the array so need to \"add\" so as to force\n+                \/\/ the array to be expanded in size\n+                array.add(++lastIndex, cell);\n+            } else {\n+                array.set(++lastIndex, cell);\n+            }\n+        }\n+\n+        @Override\n+        public int size() {\n+            return firstIndex == -1 ? 0 : lastIndex - firstIndex + 1;\n+        }\n+\n+        @Override\n+        public boolean isEmpty() {\n+            return firstIndex == -1;\n+        }\n+\n+        @Override\n+        public T get(int index) {\n+            if (index > (lastIndex - firstIndex) || index < 0) {\n+                \/\/ Commented out exception due to RT-29111\n+                \/\/ throw new java.lang.ArrayIndexOutOfBoundsException();\n+                return null;\n+            }\n+\n+            return array.get(firstIndex + index);\n+        }\n+\n+        @Override\n+        public void clear() {\n+            for (int i = 0; i < array.size(); i++) {\n+                array.set(i, null);\n+            }\n+\n+            firstIndex = lastIndex = -1;\n+        }\n+\n+        public T removeFirst() {\n+            if (isEmpty()) return null;\n+            return remove(0);\n+        }\n+\n+        public T removeLast() {\n+            if (isEmpty()) return null;\n+            return remove(lastIndex - firstIndex);\n+        }\n+\n+        @Override\n+        public T remove(int index) {\n+            if (index > lastIndex - firstIndex || index < 0) {\n+                throw new ArrayIndexOutOfBoundsException();\n+            }\n+\n+            \/\/ if the index == 0, then we're removing the first\n+            \/\/ item and can simply set it to null in the array and increment\n+            \/\/ the firstIndex unless there is only one item, in which case\n+            \/\/ we have to also set first & last index to -1.\n+            if (index == 0) {\n+                T cell = array.get(firstIndex);\n+                array.set(firstIndex, null);\n+                if (firstIndex == lastIndex) {\n+                    firstIndex = lastIndex = -1;\n+                } else {\n+                    firstIndex++;\n+                }\n+                return cell;\n+            } else if (index == lastIndex - firstIndex) {\n+                \/\/ if the index == lastIndex - firstIndex, then we're removing the\n+                \/\/ last item and can simply set it to null in the array and\n+                \/\/ decrement the lastIndex\n+                T cell = array.get(lastIndex);\n+                array.set(lastIndex--, null);\n+                return cell;\n+            } else {\n+                \/\/ if the index is somewhere in between, then we have to remove the\n+                \/\/ item and decrement the lastIndex\n+                T cell = array.get(firstIndex + index);\n+                array.set(firstIndex + index, null);\n+                for (int i = (firstIndex + index + 1); i <= lastIndex; i++) {\n+                    array.set(i - 1, array.get(i));\n+                }\n+                array.set(lastIndex--, null);\n+                return cell;\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/VirtualFlow.java","additions":3396,"deletions":0,"binary":false,"changes":3396,"status":"added"}]}