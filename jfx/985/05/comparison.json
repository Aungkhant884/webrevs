{"files":[{"patch":"@@ -132,0 +132,14 @@\n+            double newValue = ((getMax() - getMin()) * Utils.clamp(0, pos, 1)) + getMin();\n+            \/**\n+             * Scroll one cell further in the direction the user has clicked if only one cell is shown.\n+             * Otherwise, a click on the trough would have no effect when cell height > viewport height.\n+             *\/\n+            IndexedCell firstVisibleCell = flow.getFirstVisibleCell();\n+            IndexedCell lastVisibleCell = flow.getLastVisibleCell();\n+            if (firstVisibleCell == lastVisibleCell) {\n+                int index = firstVisibleCell.getIndex();\n+                if (newValue < oldValue) {\n+                    flow.scrollTo(index - 1);\n+                } else {\n+                    flow.scrollTo(index + 1);\n+                }\n@@ -133,9 +147,14 @@\n-            double newValue = ((getMax() - getMin()) * Utils.clamp(0, pos, 1))+getMin();\n-            if (newValue < oldValue) {\n-                IndexedCell cell = flow.getFirstVisibleCell();\n-                if (cell == null) return;\n-                flow.scrollToBottom(cell);\n-            } else if (newValue > oldValue) {\n-                IndexedCell cell = flow.getLastVisibleCell();\n-                if (cell == null) return;\n-                flow.scrollToTop(cell);\n+            } else {\n+                if (newValue < oldValue) {\n+                    IndexedCell cell = firstVisibleCell;\n+                    if (cell == null) {\n+                        return;\n+                    }\n+                    flow.scrollToBottom(cell);\n+                } else if (newValue > oldValue) {\n+                    IndexedCell cell = lastVisibleCell;\n+                    if (cell == null) {\n+                        return;\n+                    }\n+                    flow.scrollToTop(cell);\n+                }\n@@ -143,1 +162,0 @@\n-\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/VirtualScrollBar.java","additions":28,"deletions":10,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1606,0 +1606,1 @@\n+        int oldIndex = computeCurrentIndex();\n@@ -1616,0 +1617,1 @@\n+        getCellSizesInExpectedViewport(oldIndex);\n@@ -2316,1 +2318,1 @@\n-     * visible content to be modified.\n+     * visible content to be modified. The existing offset and index are respected.\n@@ -2321,1 +2323,10 @@\n-        double estlength = getOrCreateCellSize(index);\n+        double oldOffset = computeViewportOffset(getPosition());\n+        int oldIndex = computeCurrentIndex();\n+        double cellLength = getOrCreateCellSize(index);\n+        if (index > 0) {\n+            getOrCreateCellSize(index - 1);\n+        }\n+        if (index < getCellCount() - 1) {\n+            getOrCreateCellSize(index + 1);\n+        }\n+        double estlength = cellLength;\n@@ -2326,0 +2337,1 @@\n+        estlength = cellLength;\n@@ -2332,1 +2344,1 @@\n-        recalculateEstimatedSize();\n+        recalculateAndImproveEstimatedSize(0, oldIndex, oldOffset);\n@@ -2922,0 +2934,1 @@\n+\n@@ -3058,2 +3071,9 @@\n-     * new size.\n-     * @param cell\n+     * new size. The total size of the flow will be recalculated, respecting the\n+     * current index and offset.\n+     * If the specific cell is the \"current\" cell (which is the first cell that is\n+     * at least partially visible), the offset used for the viewport needs to be\n+     * recalculated in case the new size is different from the cached size. This way,\n+     * we keep the end of the current cell (and start of the cell at current + 1)\n+     * constant. An exception to this is when the current cell starts at offset 0,\n+     * in which case we keep the (0) offset as is.\n+     * @param cell the cell which size has to be calculated\n@@ -3063,0 +3083,4 @@\n+        int currentIndex = computeCurrentIndex();\n+        double oldOffset = computeViewportOffset(getPosition());\n+\n+\n@@ -3064,7 +3088,6 @@\n-        if (isVertical()) {\n-            double newh = cell.getLayoutBounds().getHeight();\n-            itemSizeCache.set(cellIndex, newh);\n-          } else {\n-            double newh = cell.getLayoutBounds().getWidth();\n-            itemSizeCache.set(cellIndex, newh);\n-          }\n+            Double oldSize = itemSizeCache.get(cellIndex);\n+            double newSize = isVertical() ? cell.getLayoutBounds().getHeight() : cell.getLayoutBounds().getWidth();\n+            itemSizeCache.set(cellIndex, newSize);\n+            if ((cellIndex == currentIndex) && (oldSize != null) && (oldOffset != 0)) {\n+                oldOffset = oldOffset + newSize - oldSize;\n+            }\n@@ -3072,0 +3095,1 @@\n+        recalculateAndImproveEstimatedSize(0, currentIndex, oldOffset);\n@@ -3085,0 +3109,10 @@\n+        recalculateAndImproveEstimatedSize(improve, -1, computeViewportOffset(getPosition()));\n+    }\n+\n+    \/**\n+     * Recalculate the estimated size. If an oldIndex different from  -1 is supplied, that value will\n+     * be respected:\n+     * at the end of this calculation, we make sure that if the current index is calculated, it will\n+     * be the same as the old index. If the oldIndex is -1, there is no guarantee about the new index.\n+     *\/\n+    private void recalculateAndImproveEstimatedSize(int improve, int oldIndex, double oldOffset) {\n@@ -3092,2 +3126,1 @@\n-            int oldIndex = computeCurrentIndex();\n-            double oldOffset = computeViewportOffset(getPosition());\n+            if (oldIndex < 0) oldIndex = computeCurrentIndex();\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/VirtualFlow.java","additions":47,"deletions":14,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.robot.javafx.scene.tableview;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.beans.property.StringProperty;\n+import javafx.geometry.Bounds;\n+import javafx.scene.Scene;\n+import javafx.scene.control.ScrollBar;\n+import javafx.scene.control.TableCell;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TableRow;\n+import javafx.scene.control.TableView;\n+import javafx.scene.control.cell.PropertyValueFactory;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.robot.Robot;\n+import javafx.scene.text.Font;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import javafx.stage.WindowEvent;\n+import javafx.util.Callback;\n+import test.util.Util;\n+\n+\/*\n+ * [openjdk\/jfx] 8173321: Click on trough has no effect when cell height > viewport (PR #985):\n+ * Test to verify\n+ * - click on trough moves the Scrollbar even if the table cell's height is greater than the table's height\n+ * - size of ScrollBar is greater than minimum size even if the table cell's height is greater than the table's height\n+ *\/\n+public class TableViewClickOnTroughTest {\n+\n+    static Robot robot;\n+    static volatile Stage stage;\n+    static volatile Scene scene;\n+    static final int SCENE_WIDTH = 800;\n+    static final int SCENE_HEIGHT = 250;\n+    static CountDownLatch startupLatch = new CountDownLatch(1);\n+\n+    private static TableView<TableEntry> table;\n+    public static TableRow<TableEntry> tableRow;\n+\n+    public static void main(String[] args) {\n+        TableViewClickOnTroughTest test = new TableViewClickOnTroughTest();\n+        test.moveTroughTest();\n+    }\n+\n+    @Test\n+    public void moveTroughTest() {\n+        ScrollBar verticalBar = (ScrollBar) table.lookup(\".scroll-bar:vertical\");\n+        StackPane thumb = (StackPane) verticalBar.getChildrenUnmodifiable().stream()\n+                .filter(c -> c.getStyleClass().contains(\"thumb\")).findFirst().orElse(null);\n+        Bounds verticalBarBoundsInScreen = verticalBar.localToScreen(verticalBar.getBoundsInLocal());\n+        Bounds thumbBoundsInScreen = thumb.localToScreen(thumb.getBoundsInLocal());\n+        double posX = verticalBarBoundsInScreen.getCenterX();\n+        \/\/ set posY to point into the middle of the area of the verticalBar under the\n+        \/\/ thumb.\n+        double posY = verticalBarBoundsInScreen.getMaxY()\n+                - ((verticalBarBoundsInScreen.getMaxY() - thumbBoundsInScreen.getMaxY()) \/ 2.0);\n+        double oldPosition = verticalBar.getValue();\n+\n+        Util.runAndWait(() -> {\n+            robot.mouseMove((int) posX, (int) posY);\n+            robot.mousePress(MouseButton.PRIMARY);\n+            robot.mouseRelease(MouseButton.PRIMARY);\n+        });\n+        Util.sleep(1000); \/\/ Delay for table moving Scrollbar\n+        double newPosition = verticalBar.getValue();\n+        Assert.assertTrue(\"moveTroughTest failed\", oldPosition != newPosition);\n+    }\n+\n+    @BeforeClass\n+    public static void initFX() {\n+        Util.launch(startupLatch, TestApp.class);\n+    }\n+\n+    @AfterClass\n+    public static void exit() {\n+        Util.shutdown(stage);\n+    }\n+\n+    public static class TestApp extends Application {\n+\n+        @Override\n+        public void start(Stage primaryStage) {\n+            robot = new Robot();\n+            stage = primaryStage;\n+\n+            primaryStage.setTitle(\"TableView Test\");\n+            TableColumn<TableEntry, String> col = new TableColumn<>(\"First Name\");\n+\n+            table = new TableView<TableEntry>();\n+            table.getColumns().addAll(col);\n+            table.getItems().addAll(new TableEntry(\"First\"), new TableEntry(\"Second\"), new TableEntry(\"Third\"));\n+            col.setCellValueFactory(new PropertyValueFactory<TableEntry, String>(\"name\"));\n+\n+            col.setCellFactory(MyCellFactory.forTableColumn());\n+\n+            StackPane root = new StackPane();\n+            root.getChildren().add(table);\n+            scene = new Scene(root, SCENE_WIDTH, SCENE_HEIGHT);\n+            stage.setScene(scene);\n+            stage.initStyle(StageStyle.UNDECORATED);\n+            stage.addEventHandler(WindowEvent.WINDOW_SHOWN, e -> Platform.runLater(startupLatch::countDown));\n+            stage.setAlwaysOnTop(true);\n+            stage.show();\n+        }\n+    }\n+\n+    public static class TableEntry {\n+        StringProperty name = new SimpleStringProperty();\n+\n+        public TableEntry(String name) {\n+            this.name.set(name);\n+        }\n+\n+        public String getName() {\n+            return name.get();\n+        }\n+\n+        public void setName(String name) {\n+            this.name.set(name);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"TableEntry [name=\" + name + \"]\";\n+        }\n+    }\n+\n+    public static class MyCellFactory extends TableCell<TableEntry, String> {\n+        public MyCellFactory() {\n+            setFont(new Font(\"Times New Roman\", 192));\n+        }\n+\n+        @Override\n+        protected void updateItem(String item, boolean empty) {\n+            super.updateItem(item, empty);\n+            if (empty || item == null) {\n+                setText(null);\n+                return;\n+            }\n+            setText(item);\n+            TableViewClickOnTroughTest.tableRow = this.getTableRow();\n+        }\n+\n+        public static Callback<TableColumn<TableEntry, String>, TableCell<TableEntry, String>> forTableColumn() {\n+            return e -> new MyCellFactory();\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/scene\/tableview\/TableViewClickOnTroughTest.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"}]}