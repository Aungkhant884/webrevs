{"files":[{"patch":"@@ -35,0 +35,4 @@\n+    default public int addSlotFont(FontResource font) {\n+        return -1;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/CompositeFontResource.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-                FontStrike[] tmp = new FontStrike[fontResource.getNumSlots()];\n+                FontStrike[] tmp = new FontStrike[slot+1];\n@@ -125,2 +125,4 @@\n-                strikeSlots[slot] = slotResource.getStrike(size, transform,\n-                                                           getAAMode());\n+                if (slotResource != null) {\n+                    strikeSlots[slot] = slotResource.getStrike(size, transform,\n+                                                               getAAMode());\n+                }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/CompositeStrike.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,3 +37,3 @@\n- * Create a singleton fallback resource per style to be shared across\n- * all physical fonts. \"Per style\" refers to the Bold and Italic styles,\n- * thus will (eventually) be 4 in all.\n+ * Fallback fonts may differ depending on the primary resource.\n+ * Additionally it may differ based on style even if it is otherwise\n+ * the same for multiple fonts.\n@@ -42,1 +42,1 @@\n-class FallbackResource implements CompositeFontResource {\n+public class FallbackResource implements CompositeFontResource {\n@@ -45,2 +45,3 @@\n-    private ArrayList<String> linkedFontFiles;\n-    private ArrayList<String> linkedFontNames;\n+    FontResource primaryResource;\n+    private String[] linkedFontFiles;\n+    private String[] linkedFontNames;\n@@ -61,0 +62,20 @@\n+    \/*\n+     * Initially this is used only on macOS where the cascading list for a\n+     * resource may include font variations and system fonts that cannot\n+     * be directly instantiated. So we need to install resources which already\n+     * wrap a native reference to these fonts as we won't be successful\n+     * in requesting them from native using name+file.\n+     * I hope we should still be able to share these in the global\n+     * name->font map so its not too wasteful.\n+     *\/\n+    FallbackResource(FontResource primary) {\n+        primaryResource = primary;\n+        aaMode = primaryResource.getDefaultAAMode();\n+        isBold = primaryResource.isBold();\n+        isItalic = primaryResource.isItalic();\n+    }\n+\n+    static FallbackResource getFallbackResource(FontResource primaryResource) {\n+        return new FallbackResource(primaryResource);\n+    }\n+\n@@ -181,2 +202,1 @@\n-    @Override\n-    public int getSlotForFont(String fontName) {\n+    private int getSlotForFontNoCreate(String fontName) {\n@@ -199,0 +219,2 @@\n+        return -1;\n+    }\n@@ -200,10 +222,5 @@\n-        if (i >= 0x7E) {\n-            \/* There are 8bits (0xFF) reserved in a glyph code to store the slot\n-             * number. The first bit cannot be set to avoid negative values\n-             * (leaving 0x7F). The extra -1 (leaving 0x7E) is to account for\n-             * the primary font resource in PrismCompositeFontResource.\n-             *\/\n-            if (PrismFontFactory.debugFonts) {\n-                System.err.println(\"\\tToo many font fallbacks!\");\n-            }\n-            return -1;\n+    @Override\n+    public int getSlotForFont(String fontName) {\n+      int slot = getSlotForFontNoCreate(fontName);\n+        if (slot >= 0) {\n+            return slot;\n@@ -211,0 +228,1 @@\n+\n@@ -213,0 +231,1 @@\n+\n@@ -219,0 +238,8 @@\n+        slot = getSlotForFontNoCreate(fr.getFullName());\n+        if (slot >= 0) {\n+            return slot;\n+        }\n+\n+        \/* Add the font to the list of native fallbacks *\/\n+        return addNativeFallback(fr);\n+    }\n@@ -220,0 +247,14 @@\n+\n+    private int addNativeFallback(FontResource fr) {\n+        int ns = getNumSlots();\n+        if (ns >= 0x7E) {\n+            \/* There are 8bits (0xFF) reserved in a glyph code to store the slot\n+             * number. The first bit cannot be set to avoid negative values\n+             * (leaving 0x7F). The extra -1 (leaving 0x7E) is to account for\n+             * the primary font resource in PrismCompositeFontResource.\n+             *\/\n+            if (PrismFontFactory.debugFonts) {\n+                System.err.println(\"\\tToo many font fallbacks!\");\n+            }\n+            return -1;\n+        }\n@@ -230,1 +271,11 @@\n-        return i;\n+\n+        return ns+1;\n+    }\n+\n+    public int addSlotFont(FontResource fr) {\n+        int slot = getSlotForFont(fr.getFullName());\n+        if (slot >= 0) {\n+            return slot;\n+        } else {\n+            return addNativeFallback(fr);\n+        }\n@@ -233,3 +284,0 @@\n-    \/* To start with we will use the exact same fall back list for\n-     * everything.\n-     *\/\n@@ -238,20 +286,5 @@\n-            if (PrismFontFactory.isLinux) {\n-                FontConfigManager.FcCompFont font =\n-                    FontConfigManager.getFontConfigFont(\"sans\",\n-                                                        isBold, isItalic);\n-                linkedFontFiles = FontConfigManager.getFileNames(font, false);\n-                linkedFontNames = FontConfigManager.getFontNames(font, false);\n-                fallbacks = new FontResource[linkedFontFiles.size()];\n-            } else {\n-                ArrayList<String>[] linkedFontInfo;\n-                if (PrismFontFactory.isMacOSX) {\n-                    linkedFontInfo =\n-                        PrismFontFactory.getLinkedFonts(\"Arial Unicode MS\", true);\n-                } else {\n-                    linkedFontInfo =\n-                        PrismFontFactory.getLinkedFonts(\"Tahoma\", true);\n-                }\n-                linkedFontFiles = linkedFontInfo[0];\n-                linkedFontNames = linkedFontInfo[1];\n-                fallbacks = new FontResource[linkedFontFiles.size()];\n-            }\n+            PrismFontFactory factory = PrismFontFactory.getFontFactory();\n+            FontFallbackInfo fallbackInfo = factory.getFallbacks(primaryResource);\n+            linkedFontNames = fallbackInfo.getFontNames();\n+            linkedFontFiles = fallbackInfo.getFontFiles();\n+            fallbacks       = fallbackInfo.getFonts();\n@@ -264,1 +297,1 @@\n-        int num = linkedFontFiles.size();\n+        int num = fallbacks.length;\n@@ -299,2 +332,2 @@\n-            String file = linkedFontFiles.get(slot);\n-            String name = linkedFontNames.get(slot);\n+            String file = linkedFontFiles[slot];\n+            String name = linkedFontNames[slot];\n@@ -335,0 +368,14 @@\n+\n+    public String toString() {\n+        int ns = getNumSlots();\n+        String s = \"Fallback resource:\\n\";\n+        for (int i=0; i<ns; i++) {\n+            if ((getSlotResource(i) == null)) {\n+                s += \"Slot \" + i + \"=null\\n\";\n+            } else {\n+                s += \"Slot \" + i + \"=\" + getSlotResource(i).getFullName()+\"\\n\";\n+            }\n+        }\n+        s+= \"\\n\";\n+        return s;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/FallbackResource.java","additions":92,"deletions":45,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-class FontConfigManager {\n+public class FontConfigManager {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/FontConfigManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.font;\n+\n+import java.util.ArrayList;\n+\n+public class FontFallbackInfo {\n+\n+   private ArrayList<String> linkedFontFiles;\n+   private ArrayList<String> linkedFontNames;\n+   private ArrayList<FontResource> linkedFonts;\n+\n+   public FontFallbackInfo() {\n+      linkedFontFiles = new ArrayList<String>();\n+      linkedFontNames = new ArrayList<String>();\n+      linkedFonts = new ArrayList<FontResource>();\n+   }\n+\n+   public void add(String name, String file, FontResource font) {\n+       linkedFontNames.add(name);\n+       linkedFontFiles.add(file);\n+       linkedFonts.add(font);\n+   }\n+\n+   public boolean containsName(String name) {\n+       return (name != null) && linkedFontNames.contains(name);\n+   }\n+\n+   public boolean containsFile(String file) {\n+       return (file != null) && linkedFontFiles.contains(file);\n+   }\n+\n+   public String[] getFontNames() {\n+      return linkedFontNames.toArray(new String[0]);\n+   }\n+\n+   public String[] getFontFiles() {\n+      return linkedFontFiles.toArray(new String[0]);\n+   }\n+\n+   public FontResource[] getFonts() {\n+      return linkedFonts.toArray(new FontResource[0]);\n+   }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/FontFallbackInfo.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -206,4 +206,4 @@\n-    private ArrayList<String> linkedFontFiles;\n-    private ArrayList<String> linkedFontNames;\n-    private FontResource[] fallbacks;\n-    private FontResource[] nativeFallbacks;\n+    volatile private String[] linkedFontNames;\n+    volatile private String[] linkedFontFiles;\n+    volatile private FontResource[] fallbacks;\n+    volatile private FontResource[] nativeFallbacks;\n@@ -213,13 +213,5 @@\n-            ArrayList<String>[] linkedFontInfo;\n-            if (PrismFontFactory.isLinux) {\n-                FontConfigManager.FcCompFont font =\n-                    FontConfigManager.getFontConfigFont(familyName,\n-                                                        isBold, isItalic);\n-                linkedFontFiles = FontConfigManager.getFileNames(font, true);\n-                linkedFontNames = FontConfigManager.getFontNames(font, true);\n-            } else {\n-                linkedFontInfo = PrismFontFactory.getLinkedFonts(\"Tahoma\", true);\n-                linkedFontFiles = linkedFontInfo[0];\n-                linkedFontNames = linkedFontInfo[1];\n-            }\n-            fallbacks = new FontResource[linkedFontFiles.size()];\n+            PrismFontFactory factory = PrismFontFactory.getFontFactory();\n+            FontFallbackInfo fallbackInfo = factory.getFallbacks(getSlot0Resource());\n+            linkedFontNames = fallbackInfo.getFontNames();\n+            linkedFontFiles = fallbackInfo.getFontFiles();\n+            fallbacks       = fallbackInfo.getFonts();\n@@ -232,1 +224,1 @@\n-        int num = linkedFontFiles.size();\n+        int num = fallbacks.length;\n@@ -239,2 +231,6 @@\n-    @Override\n-    public int getSlotForFont(String fontName) {\n+    private int getSlotForFontNoCreate(String fontName) {\n+\n+        if (fontName.equals(getSlot0Resource().getFullName())) {\n+            return 0;\n+        }\n+\n@@ -257,0 +253,2 @@\n+        return -1;\n+    }\n@@ -258,10 +256,5 @@\n-        if (i >= 0x7E) {\n-            \/* There are 8bits (0xFF) reserved in a glyph code to store the slot\n-             * number. The first bit cannot be set to avoid negative values\n-             * (leaving 0x7F). The extra -1 (leaving 0x7E) is to account for\n-             * the primary font resource in PrismCompositeFontResource.\n-             *\/\n-            if (PrismFontFactory.debugFonts) {\n-                System.err.println(\"\\tToo many font fallbacks!\");\n-            }\n-            return -1;\n+    @Override\n+    public int getSlotForFont(String fontName) {\n+        int slot = getSlotForFontNoCreate(fontName);\n+        if (slot >= 0) {\n+            return slot;\n@@ -269,0 +262,1 @@\n+\n@@ -277,0 +271,4 @@\n+        slot = getSlotForFontNoCreate(fr.getFullName());\n+        if (slot >= 0) {\n+            return slot;\n+        }\n@@ -278,0 +276,17 @@\n+        \/* Add the font to the list of native fallbacks *\/\n+        return addNativeFallback(fr);\n+    }\n+\n+    private int addNativeFallback(FontResource fr) {\n+        int ns = getNumSlots();\n+        if (ns >= 0x7E) {\n+            \/* There are 8bits (0xFF) reserved in a glyph code to store the slot\n+             * number. The first bit cannot be set to avoid negative values\n+             * (leaving 0x7F). The extra -1 (leaving 0x7E) is to account for\n+             * the primary font resource in PrismCompositeFontResource.\n+             *\/\n+            if (PrismFontFactory.debugFonts) {\n+                System.err.println(\"\\tToo many font fallbacks!\");\n+            }\n+            return -1;\n+        }\n@@ -289,1 +304,13 @@\n-        return i;\n+        return ns;\n+    }\n+\n+    public int addSlotFont(FontResource fr) {\n+        if (fr == null) {\n+            return -1;\n+        }\n+        int slot = getSlotForFont(fr.getFullName());\n+        if (slot >= 0) {\n+            return slot;\n+        } else {\n+            return addNativeFallback(fr);\n+        }\n@@ -307,2 +334,2 @@\n-                String file = linkedFontFiles.get(slot);\n-                String name = linkedFontNames.get(slot);\n+                String file = linkedFontFiles[slot];\n+                String name = linkedFontNames[slot];\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/LogicalFont.java","additions":60,"deletions":33,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-class MacFontFinder {\n+public class MacFontFinder {\n@@ -112,0 +112,3 @@\n+\n+    public native static String[] getCascadeList(long fontRef);\n+    public native static long[] getCascadeListRefs(long fontRef);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/MacFontFinder.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,5 +56,1 @@\n-        int aaMode = primaryResource.getDefaultAAMode();\n-        boolean bold = primaryResource.isBold();\n-        boolean italic = primaryResource.isItalic();\n-        fallbackResource =\n-              FallbackResource.getFallbackResource(bold, italic, aaMode);\n+        fallbackResource = FallbackResource.getFallbackResource(primaryResource);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/PrismCompositeFontResource.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -241,0 +241,7 @@\n+        \/*\n+         * macOS: we need to load unique fonts for regular and bold.\n+         * Probably this should be handled elsewhere\n+         *\/\n+        if (isMacOSX && name.startsWith(\"System \")) {\n+            key += name;\n+        }\n@@ -250,0 +257,9 @@\n+                \/\/ Although it looks tempting here to store the lookup name\n+                \/\/ as what we matched, it isn't safe to do so.\n+                \/\/ We may be iterating over fonts in a TTC, or (some day)\n+                \/\/ a TTF with font variations. So we don't want to just store the name\n+                \/\/ But there also times (ie \"System Font\" on macOS - that's a macOS name\n+                \/\/ not JavaFX System font) when the name in the font still does\n+                \/\/ not match what macOS told us but we need to register it anyway\n+                \/\/ That needs to be handled by the caller of that case - see\n+                \/\/ createFontResource() below.\n@@ -262,0 +278,28 @@\n+   \/*\n+    * Whether a ttf or ttc this will find the index of the named font.\n+    *\/\n+   public int findFontIndex(String targetName, String filename) {\n+\n+         try {\n+             PrismFontFile fr = createFontFile(null, filename, 0, false, false, false, false);\n+\n+             int cnt = fr.getFontCount();\n+             if (cnt == 1 || fr.getFullName().equalsIgnoreCase(targetName)) {\n+                 return 0;\n+             }\n+             int index = 1;\n+             do {\n+                 fr = createFontFile(null, filename, index, false, false, false, false);\n+                 String name = fr.getFullName();\n+                 if (name.equalsIgnoreCase(targetName)) {\n+                     return index;\n+                 }\n+             } while (++index < cnt);\n+         } catch (Exception e) {\n+             if (PrismFontFactory.debugFonts) {\n+                 e.printStackTrace();\n+             }\n+         }\n+         return -1;\n+   }\n+\n@@ -265,1 +309,1 @@\n-                                true, false, false, false, false);\n+                                true, false, false, false, true);\n@@ -269,1 +313,12 @@\n-           return pffArr[0];\n+           for (int i = 0; i < pffArr.length; i++) {\n+               if (pffArr[i].getFullName().equalsIgnoreCase(name)) {\n+                   return pffArr[i];\n+               }\n+           }\n+        }\n+        \/\/ No exact match - we don't want to repeat the look up so\n+        \/\/ log this, but store the specified name as the key to\n+        \/\/ match first font in this file\n+        storeInMap(name, pffArr[0]);\n+        if (PrismFontFactory.debugFonts) {\n+            System.err.println(\"No match for name \" + name + \" in \" + filename);\n@@ -271,0 +326,1 @@\n+        return pffArr[0];\n@@ -353,1 +409,1 @@\n-    private void storeInMap(String name, FontResource resource) {\n+    protected void storeInMap(String name, FontResource resource) {\n@@ -558,1 +614,1 @@\n-        if (familyName != null && !familyName.isEmpty()) {\n+        if (familyName != null && !familyName.isEmpty() && !isExcluded(familyName)) {\n@@ -578,1 +634,1 @@\n-        if (name != null && !name.isEmpty()) {\n+        if (name != null && !name.isEmpty() && !isExcluded(name)) {\n@@ -902,2 +958,0 @@\n-    private static native String regReadFontLink(String searchfont);\n-    private static native String getEUDCFontFile();\n@@ -922,100 +976,0 @@\n-    \/**\n-      * This will return an array of size 2, each element being an array\n-      * list of <code>String<\/code>. The first (zeroth) array holds file\n-      * names, and, the second array holds the corresponding fontnames.\n-      * If the file does not have a corresponding font name, its corresponding\n-      * name is assigned an empty string \"\".\n-      * As a further complication, Windows 7 frequently lists a font twice,\n-      * once with some scaling values, and again without. We don't use this\n-      * so find these and exclude duplicates.\n-      *\/\n-    static ArrayList<String> [] getLinkedFonts(String searchFont,\n-                                               boolean addSearchFont) {\n-\n-\n-        ArrayList<String> [] fontRegInfo = new ArrayList[2];\n-        \/\/ index 0 = file names, 1 = font name.\n-        \/\/ the name is only specified for TTC files.\n-        fontRegInfo[0] = new ArrayList<>();\n-        fontRegInfo[1] = new ArrayList<>();\n-\n-        if (isMacOSX) {\n-            \/\/ Hotkey implementation of fallback font on Mac\n-            fontRegInfo[0].add(\"\/Library\/Fonts\/Arial Unicode.ttf\");\n-            fontRegInfo[1].add(\"Arial Unicode MS\");\n-\n-            \/\/ Add Lucida Sans Regular to Mac OS X fallback list\n-            fontRegInfo[0].add(jreFontDir + jreDefaultFontFile);\n-            fontRegInfo[1].add(jreDefaultFont);\n-\n-            \/\/ Add Apple Symbols to Mac OS X fallback list\n-            fontRegInfo[0].add(\"\/System\/Library\/Fonts\/Apple Symbols.ttf\");\n-            fontRegInfo[1].add(\"Apple Symbols\");\n-\n-            \/\/ Add Apple Emoji Symbols to Mac OS X fallback list\n-            fontRegInfo[0].add(\"\/System\/Library\/Fonts\/Apple Color Emoji.ttc\");\n-            fontRegInfo[1].add(\"Apple Color Emoji\");\n-\n-            \/\/ Add CJK Ext B supplementary characters.\n-            fontRegInfo[0].add(\"\/System\/Library\/Fonts\/STHeiti Light.ttf\");\n-            fontRegInfo[1].add(\"Heiti SC Light\");\n-\n-            return fontRegInfo;\n-        }\n-        if (!isWindows) {\n-            return fontRegInfo;\n-        }\n-\n-        if (addSearchFont) {\n-            fontRegInfo[0].add(null);\n-            fontRegInfo[1].add(searchFont);\n-        }\n-\n-        String fontRegBuf = regReadFontLink(searchFont);\n-        if (fontRegBuf != null && fontRegBuf.length() > 0) {\n-            \/\/ split registry data into null terminated strings\n-            String[] fontRegList = fontRegBuf.split(\"\\u0000\");\n-            int linkListLen = fontRegList.length;\n-            for (int i=0; i < linkListLen; i++) {\n-                String[] splitFontData = fontRegList[i].split(\",\");\n-                int len = splitFontData.length;\n-                String file = getPathNameWindows(splitFontData[0]);\n-                String name = (len > 1) ? splitFontData[1] : null;\n-                if (name != null && fontRegInfo[1].contains(name)) {\n-                    continue;\n-                } else if (name == null && fontRegInfo[0].contains(file)) {\n-                    continue;\n-                }\n-                fontRegInfo[0].add(file);\n-                fontRegInfo[1].add(name);\n-            }\n-        }\n-\n-        String eudcFontFile = getEUDCFontFile();\n-        if (eudcFontFile != null) {\n-            fontRegInfo[0].add(eudcFontFile);\n-            fontRegInfo[1].add(null);\n-        }\n-\n-        \/\/ Add Lucida Sans Regular to Windows fallback list\n-        fontRegInfo[0].add(jreFontDir + jreDefaultFontFile);\n-        fontRegInfo[1].add(jreDefaultFont);\n-\n-        if (PlatformUtil.isWinVistaOrLater()) {\n-            \/\/ CJK Ext B Supplementary character fallbacks.\n-            fontRegInfo[0].add(getPathNameWindows(\"mingliub.ttc\"));\n-            fontRegInfo[1].add(\"MingLiU-ExtB\");\n-\n-            if (PlatformUtil.isWin7OrLater()) {\n-                \/\/ Add Segoe UI Symbol to Windows 7 or later fallback list\n-                fontRegInfo[0].add(getPathNameWindows(\"seguisym.ttf\"));\n-                fontRegInfo[1].add(\"Segoe UI Symbol\");\n-            } else {\n-                \/\/ Add Cambria Math to Windows Vista fallback list\n-                fontRegInfo[0].add(getPathNameWindows(\"cambria.ttc\"));\n-                fontRegInfo[1].add(\"Cambria Math\");\n-            }\n-        }\n-        return fontRegInfo;\n-    }\n-\n@@ -1199,1 +1153,1 @@\n-    static String getPathNameWindows(final String filename) {\n+    protected static String getPathNameWindows(final String filename) {\n@@ -1234,0 +1188,10 @@\n+    \/*\n+     * Do not return matching names via public API.\n+     * Some names may be needed for internal matching but\n+     * never exposed to application code.\n+     * Initially this only excludes certain names on macOS.\n+     *\/\n+    public boolean isExcluded(String name) {\n+        return false;\n+    }\n+\n@@ -1259,1 +1223,3 @@\n-                    familyNames.add(f);\n+                    if (!isExcluded(f)) {\n+                        familyNames.add(f);\n+                    }\n@@ -1289,1 +1255,3 @@\n-                    fontNames.add(s);\n+                    if (!isExcluded(s)) {\n+                        fontNames.add(s);\n+                    }\n@@ -1301,0 +1269,3 @@\n+        if (isExcluded(family)) {\n+            return STR_ARRAY;\n+        }\n@@ -1751,0 +1722,6 @@\n+                if (debugFonts) {\n+                    logFontInfo(\" *** MACOS LOCATED FONTS:\",\n+                                tmpFontToFileMap,\n+                                fontToFamilyNameMap,\n+                                familyToFontListMap);\n+                }\n@@ -1988,0 +1965,2 @@\n+\n+    public abstract FontFallbackInfo getFallbacks(FontResource primaryResource);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/PrismFontFactory.java","additions":89,"deletions":110,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    String fullName;             \/* Full font name (English)   *\/\n+    protected String fullName;   \/* Full font name (English)   *\/\n@@ -562,0 +562,3 @@\n+            if (headDE == null) {\n+                throw new Exception(\"No header table - font is invalid.\");\n+            }\n@@ -627,1 +630,1 @@\n-                throw new Exception(\"Font name not found.\");\n+                throw new Exception(\"Font name not found in \" + filename);\n@@ -767,0 +770,2 @@\n+    public static final int UNICODE_PLATFORM_ID = 0;\n+\n@@ -800,2 +805,3 @@\n-            if (platformID != MS_PLATFORM_ID &&\n-                platformID != MAC_PLATFORM_ID) {\n+            if ((platformID != UNICODE_PLATFORM_ID) &&\n+                (platformID != MS_PLATFORM_ID) &&\n+                (platformID != MAC_PLATFORM_ID)) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/PrismFontFile.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import java.util.ArrayList;\n+\n+import com.sun.javafx.font.FallbackResource;\n+import com.sun.javafx.font.FontFallbackInfo;\n+import com.sun.javafx.font.FontResource;\n@@ -41,0 +46,31 @@\n+    \/*\n+     * This is needed for fonts where the name starts with \".\"\n+     * It isn't just the \".SF\" \"System Font\", but related fallbacks which\n+     * layout returns and we need to add as a native fallback to a composite font.\n+     *\/\n+    CTFontFile createFontFile(String name, long fontRef) throws Exception {\n+        String filename = OS.CTFontCopyURLAttribute(fontRef);\n+        \/\/ macOS 13 Ventura reports \".ThonburiUI Regular Regular\" as the name\n+        \/\/ of font used for Thai. Per inspection of the font this is incorrect.\n+        \/\/ Need to do fix up here.\n+        if (name.endsWith(\" Regular Regular\")) {\n+            if (debugFonts) {\n+                System.err.println(\"Fix up double use of Regular in name : \" + name);\n+            }\n+            name = name.replaceFirst(\" Regular Regular\", \" Regular\");\n+        }\n+        int fIndex = findFontIndex(name, filename);\n+\n+        if (debugFonts) {\n+            System.err.println(\"createFontFile by ref name=\"+name + \" filename=\"+filename+\" index=\"+fIndex);\n+        }\n+        if (fIndex == -1) {\n+            return null;\n+        }\n+        CTFontFile font = new CTFontFile(name, filename, fIndex, fontRef);\n+        \/\/ Store the lookup name in the map.\n+        \/\/ This should prevent us needing to create new instances.\n+        storeInMap(name, font);\n+        return font;\n+    }\n+\n@@ -66,0 +102,62 @@\n+\n+    \/*\n+     * This should prevent enumeration of special fonts, but also should\n+     * be used to prevent public lookup of these even if not enumerated\n+     *\/\n+    @Override\n+    public boolean isExcluded(String name) {\n+         return name.startsWith(\".\") || name.startsWith(\"System Font\");\n+    }\n+\n+    public FontFallbackInfo getFallbacks(FontResource primaryResource) {\n+        FontFallbackInfo info = new FontFallbackInfo();\n+        ArrayList<String> names;\n+        ArrayList<String> files;\n+        ArrayList<String> fonts;\n+\n+        \/\/ First add cascading font list.\n+        if (primaryResource instanceof CTFontFile ctff) {\n+           ctff.getCascadingInfo(info);\n+        }\n+        \/\/ ELSE: REMIND we can get the default cascading list for this case.\n+        \/\/ Do this only if we find we end up here, which I think unlikely today.\n+\n+        String name = \"System Regular\"; \/\/ a default\n+        boolean bold = false;\n+        if (primaryResource != null) {\n+            name = primaryResource.getFullName();\n+            bold = primaryResource.isBold();\n+        }\n+\n+        \/\/ The \".\" fonts for Japanese, Korean, Simplified Chinese, HK Chinese, TW Chinese\n+        \/\/ do not report a file, so out of caution, let's add some known fallbacks used\n+        \/\/ by Arial and Arial Bold for these scripts.\n+        \/\/ Note: even if \".\" fonts do report a file, macOS does not like apps looking\n+        \/\/ them up that way.\n+        if (name.startsWith(\"System \")) {\n+           if (!bold) {\n+               info.add(\"Hiragino Sans W3\", \"\/System\/Library\/Fonts\/ヒラギノ角ゴシック W3.ttc\", null);\n+               info.add(\"Hiragino Sans GB W3\", \"\/System\/Library\/Fonts\/Hiragino Sans GB.ttc\", null);\n+               info.add(\"Apple SD Gothic Neo Regular\", \"\/System\/Library\/Fonts\/AppleSDGothicNeo.ttc\", null);\n+               info.add(\"PingFang SC Regular\", \"\/System\/Library\/Fonts\/PingFang.ttc\", null);\n+               info.add(\"PingFang TC Regular\", \"\/System\/Library\/Fonts\/PingFang.ttc\", null);\n+               info.add(\"PingFang HK Regular\", \"\/System\/Library\/Fonts\/PingFang.ttc\", null);\n+           } else {\n+               info.add(\"Hiragino Sans W6\", \"\/System\/Library\/Fonts\/ヒラギノ角ゴシック W6.ttc\", null);\n+               info.add(\"Hiragino Sans GB W6\", \"System\/Library\/Fonts\/Hiragino Sans GB.ttc\", null);\n+               info.add(\"Apple SD Gothic Neo Bold\", \"\/System\/Library\/Fonts\/AppleSDGothicNeo.ttc\", null);\n+               info.add(\"PingFang SC Semibold\", \"\/System\/Library\/Fonts\/PingFang.ttc\", null);\n+               info.add(\"PingFang TC Semibold\", \"\/System\/Library\/Fonts\/PingFang.ttc\", null);\n+               info.add(\"PingFang HK Semibold\", \"\/System\/Library\/Fonts\/PingFang.ttc\", null);\n+           }\n+        }\n+\n+        \/\/ Now add hardwired fall backs in case of problems with the above.\n+        info.add(\"Apple Symbols\", \"\/System\/Library\/Fonts\/Apple Symbols.ttf\", null);\n+        info.add(\"Apple Color Emoji\", \"\/System\/Library\/Fonts\/Apple Color Emoji.ttc\", null);\n+        info.add(\"Arial Unicode MS\", \"\/Library\/Fonts\/Arial Unicode.ttf\", null);\n+        \/\/ Add CJK Ext B supplementary characters.\n+        info.add(\"Heiti SC Light\", \"\/System\/Library\/Fonts\/STHeiti Light.ttc\", null);\n+\n+        return info;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/coretext\/CTFactory.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import com.sun.javafx.font.FontFallbackInfo;\n@@ -31,0 +32,2 @@\n+import com.sun.javafx.font.MacFontFinder;\n+import com.sun.javafx.font.PrismFontFactory;\n@@ -38,1 +41,1 @@\n-    private final long cgFontRef;\n+    private long cgFontRef = 0;\n@@ -47,1 +50,1 @@\n-        private long cgFontRef;\n+        private long fontRef;\n@@ -49,2 +52,2 @@\n-        SelfDisposerRecord(long cgFontRef) {\n-            this.cgFontRef = cgFontRef;\n+        SelfDisposerRecord(long fontRef) {\n+            this.fontRef = fontRef;\n@@ -55,3 +58,3 @@\n-            if (cgFontRef != 0) {\n-                OS.CFRelease(cgFontRef);\n-                cgFontRef = 0;\n+            if (fontRef != 0) {\n+                OS.CFRelease(fontRef);\n+                fontRef = 0;\n@@ -62,0 +65,11 @@\n+    private long ctFontRef = 0;\n+    CTFontFile(String name, String filename, int fIndex, long fontRef) throws Exception {\n+        super(name, filename, fIndex, false, false, false, false);\n+\n+        if (fontRef == 0) {\n+           throw new InternalError(\"Zero fontref\");\n+        }\n+        ctFontRef = fontRef;\n+        Disposer.addRecord(this, new SelfDisposerRecord(ctFontRef));\n+    }\n+\n@@ -66,0 +80,13 @@\n+        \/\/ The super-class code that opens and reads the font can't handle font variations,\n+        \/\/ as used by the macOS \"System Font\"\n+        \/\/ So when we see a font from this family, we need to use the original name\n+        \/\/ passed in here as the full name.\n+        \/\/ This isn't robust against Apple changing the name of the font\n+        \/\/ but I think it sufficient until we add support for font variations.\n+\n+        if (name != null) {\n+            String family = getFamilyName();\n+            if (family.equals(\"System Font\")) {\n+                fullName = name;\n+            }\n+        }\n@@ -74,0 +101,6 @@\n+    @Override\n+    public boolean isBold() {\n+        \/\/ Need to do this until we add font variation support into the super-class\n+        return fullName.equals(\"System Font Bold\") || super.isBold();\n+    }\n+\n@@ -100,1 +133,1 @@\n-                final long dataProvider = OS.CGDataProviderCreateWithURL(url);\n+                long dataProvider = OS.CGDataProviderCreateWithURL(url);\n@@ -205,0 +238,59 @@\n+    long getFontRef(float size, CGAffineTransform matrix) {\n+      long retRef = 0;\n+      if (isEmbeddedFont()) {\n+          if (cgFontRef != 0) {\n+             retRef = OS.CTFontCreateWithGraphicsFont(cgFontRef, size, matrix, 0);\n+          }\n+      } else if (ctFontRef != 0) {\n+           retRef = OS.CTFontCreateCopyWithAttributes(ctFontRef, size, matrix, 0);\n+      } else {\n+          String psName = getPSName();\n+          if (psName.startsWith(\".\")) {\n+               boolean bold = getFullName().indexOf(\"Bold\") > 0;\n+               retRef = OS.CTFontCreateUIFontForLanguage(size, matrix, bold);\n+          } else {\n+              final long psNameRef = OS.CFStringCreate(psName);\n+              if (psNameRef != 0) {\n+                  retRef = OS.CTFontCreateWithName(psNameRef, size, matrix);\n+                  OS.CFRelease(psNameRef);\n+              }\n+           }\n+       }\n+        return retRef;\n+    }\n+\n+    void getCascadingInfo(FontFallbackInfo info) {\n+        CTFactory factory = (CTFactory)PrismFontFactory.getFontFactory();\n+        long ref = getFontRef(0f, null);\n+        String[] stringInfo = MacFontFinder.getCascadeList(ref);\n+        \/\/ stringInfo is displayname and file.\n+        \/\/ if there's a null file, skip\n+        \/\/ if there's a non-null file but name starts with \".\",\n+        \/\/ we'd need a fontRef to use it since macOS won't let us create it.\n+        \/\/ So we need to skip that case too - unless\/until I find an answer to that\n+        \/\/ in which case we could use Factory.createFontFile(name, ref); and\n+        \/\/ pass a font instead of null.\n+        if (PrismFontFactory.debugFonts) {\n+            System.err.println(\"Cascading list for \" + getFullName());\n+        }\n+        for (int i=0; i<stringInfo.length;i+=2) {\n+            String name = stringInfo[i];\n+            String file = stringInfo[i+1];\n+            if (PrismFontFactory.debugFonts) {\n+                System.err.print(\"Entry : name=\" + name + \" file=\"+file);\n+            }\n+            if (file == null || name.startsWith(\".\")) {\n+                if (PrismFontFactory.debugFonts) {\n+                    System.err.println(\" - *** not using this entry (.font and\/or null file)\");\n+                }\n+                continue;\n+            }\n+            if (PrismFontFactory.debugFonts) {\n+                System.err.println();\n+            }\n+            info.add(name, file, null);\n+        }\n+        if (PrismFontFactory.debugFonts) {\n+             System.err.println(\"End cascading list\");\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/coretext\/CTFontFile.java","additions":100,"deletions":8,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -81,13 +81,1 @@\n-        if (fontResource.isEmbeddedFont()) {\n-            final long cgFontRef = fontResource.getCGFontRef();\n-            if (cgFontRef != 0) {\n-                fontRef = OS.CTFontCreateWithGraphicsFont(\n-                        cgFontRef, size, matrix, 0);\n-            }\n-        } else {\n-            final long psNameRef = OS.CFStringCreate(fontResource.getPSName());\n-            if (psNameRef != 0) {\n-                fontRef = OS.CTFontCreateWithName(psNameRef, size, matrix);\n-                OS.CFRelease(psNameRef);\n-            }\n-        }\n+        fontRef = fontResource.getFontRef(size, matrix);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/coretext\/CTFontStrike.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -83,0 +83,16 @@\n+            if (slot == -1) {\n+                 CTFontFile newFont = null;\n+                 try {\n+                     CTFactory factory = (CTFactory)PrismFontFactory.getFontFactory();\n+                     long newRef = OS.CTFontCreateCopyWithAttributes(actualFont, 0, null,0);\n+                      OS.CFRetain(newRef); \/\/ hope not needed ..\n+                     newFont = factory.createFontFile(fontName, newRef);\n+                     if (newFont != null) {\n+                         slot = fr.addSlotFont(newFont);\n+                     }\n+                 } catch (Exception e) {\n+                     if (PrismFontFactory.debugFonts) {\n+                         e.printStackTrace();\n+                     }\n+                 }\n+            }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/coretext\/CTGlyphLayout.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+    static final native String CTFontCopyURLAttribute(long font);\n@@ -88,0 +89,1 @@\n+    static final native void CFRetain(long cf);\n@@ -107,0 +109,1 @@\n+    static final native long CTFontCreateCopyWithAttributes(long cgFont, double size, CGAffineTransform matrix, long attributes);\n@@ -108,0 +111,1 @@\n+    static final native long CTFontCreateUIFontForLanguage(double size, CGAffineTransform matrix, boolean bold);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/coretext\/OS.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import com.sun.javafx.font.FontFallbackInfo;\n+import com.sun.javafx.font.FontResource;\n@@ -154,0 +156,41 @@\n+\n+    private static native String regReadFontLink(String searchfont);\n+    private static native String getEUDCFontFile();\n+\n+    \/*\n+     * Ignoring the primary on Windows - this should change some day.\n+     *\/\n+    public FontFallbackInfo getFallbacks(FontResource primaryResource) {\n+        FontFallbackInfo info = new FontFallbackInfo();\n+\n+        String fontRegBuf = regReadFontLink(\"Tahoma\");\n+        if (fontRegBuf != null && fontRegBuf.length() > 0) {\n+            \/\/ split registry data into null terminated strings\n+            String[] fontRegList = fontRegBuf.split(\"\\u0000\");\n+            int linkListLen = fontRegList.length;\n+            for (int i=0; i < linkListLen; i++) {\n+                String[] splitFontData = fontRegList[i].split(\",\");\n+                int len = splitFontData.length;\n+                String file = getPathNameWindows(splitFontData[0]);\n+                String name = (len > 1) ? splitFontData[1] : null;\n+                if (name != null && info.containsName(name)) {\n+                    continue;\n+                } else if (name == null && info.containsFile(file)) {\n+                    continue;\n+                }\n+                info.add(name, file, null);\n+            }\n+        }\n+\n+        String eudcFontFile = getEUDCFontFile();\n+        if (eudcFontFile != null) {\n+            info.add(null, eudcFontFile, null);\n+        }\n+\n+        \/\/ CJK Ext B Supplementary character fallbacks.\n+        info.add(\"MingLiU-ExtB\", getPathNameWindows(\"mingliub.ttc\"), null);\n+        info.add(\"Segoe UI Symbol\", getPathNameWindows(\"seguisym.ttf\"), null);\n+        \/\/ TBD add way more here.\n+\n+        return info;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/directwrite\/DWFactory.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import java.util.ArrayList;\n+\n+import com.sun.javafx.font.FontConfigManager;\n+import com.sun.javafx.font.FontFallbackInfo;\n+import com.sun.javafx.font.FontResource;\n@@ -125,0 +130,13 @@\n+    public FontFallbackInfo getFallbacks(FontResource primaryResource) {\n+        boolean isBold = primaryResource.isBold();\n+        boolean isItalic = primaryResource.isItalic();\n+        FontConfigManager.FcCompFont font =\n+            FontConfigManager.getFontConfigFont(\"sans\", isBold, isItalic);\n+        ArrayList<String> linkedFontFiles = FontConfigManager.getFileNames(font, false);\n+        ArrayList<String> linkedFontNames = FontConfigManager.getFontNames(font, false);\n+        FontFallbackInfo info = new FontFallbackInfo();\n+        for (int i=0; i<linkedFontNames.size(); i++)  {\n+            info.add(linkedFontNames.get(i), linkedFontFiles.get(i), null);\n+        }\n+        return info;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/freetype\/FTFactory.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-    private static final int MAX_LAYOUT_CHARCODE = 0x206F;\n+    private static final int MAX_LAYOUT_CHARCODE = 0x12550F;\n@@ -154,0 +154,12 @@\n+        else if (code < 0x13a0) {\n+            return false;\n+        }\n+        else if (code <= 0x13ff) { \/\/ U+13A0 - U+13FF Cherokee\n+            return true;\n+        }\n+        else if (code < 0x1c50) {\n+            return false;\n+        }\n+        else if (code <= 0x1c7f) { \/\/ U+1C50 - U+1C7F Ol Chiki \/ Santali\n+            return true;\n+        }\n@@ -172,0 +184,21 @@\n+        else if (code < 0xab70) {\n+            return false;\n+        }\n+        else if (code <= 0xabbf) { \/\/ U+AB70 - U+ABBF - Cherokee Supplement\n+            return true;\n+        }\n+        else if (code <= 0xabff) { \/\/ U+ABC0 - U+ABFF - Meeti Mayek\n+            return true;\n+        }\n+        else if (code < 0x11080) {\n+            return false;\n+        }\n+        else if (code <= 0x110cf) { \/\/ Kaithi\n+            return true;\n+        }\n+        else if (code < 0x12000) {\n+            return false;\n+        }\n+        else if (code >= 0x12000 && code <= 0x1254f) { \/\/ Cuneiform\n+            return true;\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/ScriptMapper.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+    if (stringRef == NULL) return NULL;\n@@ -82,1 +83,1 @@\n-                         kCTFontSystemFontType,\n+                         kCTFontUIFontSystem,\n@@ -178,1 +179,1 @@\n-    CTFontRef font = CTFontCreateUIFontForLanguage(kCTFontSystemFontType, 0, NULL);\n+    CTFontRef font = CTFontCreateUIFontForLanguage(kCTFontUIFontSystem, 0, NULL);\n@@ -186,0 +187,2 @@\n+     * NOTE: macOS is using font variations for the system font,\n+     * so System Font and System Font Bold are in the same .ttf.\n@@ -187,1 +190,1 @@\n-    font = CTFontCreateUIFontForLanguage(kCTFontEmphasizedSystemFontType, 0, NULL);\n+    font = CTFontCreateUIFontForLanguage(kCTFontUIFontEmphasizedSystem, 0, NULL);\n@@ -196,0 +199,68 @@\n+JNIEXPORT jobjectArray JNICALL\n+Java_com_sun_javafx_font_MacFontFinder_getCascadeList\n+(JNIEnv *env, jclass cls, jlong fontRef)\n+{\n+    CTFontRef ctFontRef = (CTFontRef)fontRef;\n+\n+    CFArrayRef codes = CFLocaleCopyISOLanguageCodes();\n+    CFArrayRef fds = CTFontCopyDefaultCascadeListForLanguages(ctFontRef, codes);\n+    CFRelease(codes);\n+\n+    CFIndex cnt = CFArrayGetCount(fds);\n+    jclass jStringClass = (*env)->FindClass(env, \"java\/lang\/String\");\n+    int SPE = 2;\n+    jobjectArray names = (*env)->NewObjectArray(env, cnt*SPE, jStringClass, NULL);\n+    if (names == NULL) {\n+        CFRelease(fds);\n+        return NULL;\n+    }\n+    for (CFIndex i=0; i<cnt; i++) {\n+        CTFontDescriptorRef ref = CFArrayGetValueAtIndex(fds, i);\n+        CFStringRef fontname = CTFontDescriptorCopyAttribute(ref, kCTFontNameAttribute);\n+        CFStringRef displayName = CTFontDescriptorCopyAttribute(ref, kCTFontDisplayNameAttribute);\n+        CFURLRef url = CTFontDescriptorCopyAttribute(ref, kCTFontURLAttribute);\n+        CFStringRef file = url ? CFURLCopyFileSystemPath(url, kCFURLPOSIXPathStyle) : NULL;\n+\n+        jstring jFontDisplayName = createJavaString(env, displayName);\n+        CFRelease(displayName);\n+        jstring jFile = createJavaString(env, file);\n+        if (file != NULL) CFRelease(file);\n+\n+        (*env)->SetObjectArrayElement(env, names, (i*SPE)+0, jFontDisplayName);\n+        (*env)->SetObjectArrayElement(env, names, (i*SPE)+1, jFile);\n+\n+        (*env)->DeleteLocalRef(env, jFontDisplayName);\n+        if (jFile != NULL) (*env)->DeleteLocalRef(env, jFile);\n+    }\n+    CFRelease(fds);\n+    return names;\n+}\n+\n+JNIEXPORT jlongArray JNICALL\n+Java_com_sun_javafx_font_MacFontFinder_getCascadeListRefs\n+(JNIEnv *env, jclass cls, jlong fontRef)\n+{\n+    CTFontRef ctFontRef = (CTFontRef)fontRef;\n+\n+    CFArrayRef codes = CFLocaleCopyISOLanguageCodes();\n+    CFArrayRef fds = CTFontCopyDefaultCascadeListForLanguages(ctFontRef, codes);\n+    CFRelease(codes);\n+\n+    CFIndex cnt = CFArrayGetCount(fds);\n+    jlongArray refs = (*env)->NewLongArray(env, cnt);\n+    if (refs == NULL) {\n+        CFRelease(fds);\n+        return NULL;\n+    }\n+    jlong *refArr = calloc(cnt, sizeof(jlong));\n+    for (CFIndex i=0; i<cnt; i++) {\n+        CTFontDescriptorRef descRef = CFArrayGetValueAtIndex(fds, i);\n+        CTFontRef ref = CTFontCreateWithFontDescriptor(descRef, 0.0, NULL);\n+        refArr[i] = (jlong)ref;\n+    }\n+    (*env)->SetLongArrayRegion(env, refs, 0, cnt, refArr);\n+    free(refArr);\n+    CFRelease(fds);\n+    return refs;\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-font\/MacFontFinder.c","additions":74,"deletions":3,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -373,0 +373,19 @@\n+JNIEXPORT void JNICALL OS_NATIVE(CFRetain)\n+    (JNIEnv *env, jclass that, jlong arg0)\n+{\n+    CFRetain((CFTypeRef)arg0);\n+}\n+\n+JNIEXPORT jlong JNICALL OS_NATIVE(CTFontCreateCopyWithAttributes)\n+    (JNIEnv *env, jclass that, jlong ctfont, jdouble size, jobject matrix, jlong attributes)\n+{\n+    CGAffineTransform transform;\n+    if (matrix) {\n+        getCGAffineTransformFields(env, matrix, &transform);\n+    } else {\n+        transform = CGAffineTransformIdentity;\n+    }\n+    return (jlong)CTFontCreateCopyWithAttributes((CTFontRef)ctfont, (CGFloat)size,\n+                                                 &transform, (CTFontDescriptorRef)attributes);\n+}\n+\n@@ -385,0 +404,17 @@\n+JNIEXPORT jlong JNICALL OS_NATIVE(CTFontCreateUIFontForLanguage)\n+    (JNIEnv *env, jclass that, jdouble size, jobject matrix, jboolean bold) {\n+\n+    CGAffineTransform _matrix, *lpmatrix=NULL;\n+    CTFontUIFontType fType = bold ? kCTFontUIFontEmphasizedSystem : kCTFontUIFontSystem;\n+    CTFontRef font = CTFontCreateUIFontForLanguage(fType, (CGFloat)size, NULL);\n+    if (matrix == NULL) {\n+        return (jlong)font;\n+    }\n+    if ((lpmatrix = getCGAffineTransformFields(env, matrix, &_matrix)) == NULL) {\n+         return (jlong)font;\n+    }\n+    jlong txfont = (jlong)CTFontCreateCopyWithAttributes(font, (CGFloat)size, (CGAffineTransform*)lpmatrix, NULL);\n+    CFRelease(font);\n+    return txfont;\n+}\n+\n@@ -759,0 +795,15 @@\n+JNIEXPORT jstring JNICALL OS_NATIVE(CTFontCopyURLAttribute)\n+    (JNIEnv *env, jclass that, jlong arg0)\n+{\n+    CFURLRef urlRef = CTFontCopyAttribute((CTFontRef)arg0, kCTFontURLAttribute);\n+    if (urlRef == NULL) return NULL;\n+    CFStringRef stringRef = CFURLCopyFileSystemPath(urlRef, kCFURLPOSIXPathStyle);\n+    CFRelease(urlRef);\n+    if (stringRef == NULL) return NULL;\n+    CFIndex length = CFStringGetLength(stringRef);\n+    UniChar buffer[length];\n+    CFStringGetCharacters(stringRef, CFRangeMake(0, length), buffer);\n+    CFRelease(stringRef);\n+    return (*env)->NewString(env, (jchar *)buffer, length);\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-font\/coretext.c","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -716,1 +716,1 @@\n-Java_com_sun_javafx_font_PrismFontFactory_regReadFontLink(JNIEnv *env, jclass obj, jstring lpFontName)\n+Java_com_sun_javafx_font_directwrite_DWFactory_regReadFontLink(JNIEnv *env, jclass obj, jstring lpFontName)\n@@ -783,1 +783,1 @@\n-Java_com_sun_javafx_font_PrismFontFactory_getEUDCFontFile(JNIEnv *env, jclass cl) {\n+Java_com_sun_javafx_font_directwrite_DWFactory_getEUDCFontFile(JNIEnv *env, jclass cl) {\n","filename":"modules\/javafx.graphics\/src\/main\/native-font\/fontpath.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}