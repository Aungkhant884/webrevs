{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import java.util.ArrayList;\n@@ -29,0 +30,1 @@\n+\n@@ -31,0 +33,1 @@\n+import javafx.scene.layout.Region;\n@@ -37,0 +40,2 @@\n+    private static final boolean LOG = true; \/\/ TODO remove once fully debugged\n+    private static final boolean CHECK = true; \/\/ TODO remove once fully debugged\n@@ -38,0 +43,1 @@\n+    private static final double EPSILON = 0.000001;\n@@ -39,1 +45,1 @@\n-    private final int target;\n+    private final double target;\n@@ -43,4 +49,4 @@\n-    private final int[] size;\n-    private final int[] min;\n-    private final int[] pref;\n-    private final int[] max;\n+    private final double[] size;\n+    private final double[] min;\n+    private final double[] pref;\n+    private final double[] max;\n@@ -48,0 +54,1 @@\n+    private final Region snap;\n@@ -54,1 +61,1 @@\n-        this.target = (int)target;\n+        this.snap = (rf.getTableControl().isSnapToPixel() ? rf.getTableControl() : null);\n@@ -57,1 +64,1 @@\n-\n+        this.target = snap(target); \/\/ snap target to avoid problems later\n@@ -59,4 +66,5 @@\n-        size = new int[count];\n-        min = new int[count];\n-        pref = new int[count];\n-        max = new int[count];\n+\n+        size = new double[count];\n+        min = new double[count];\n+        pref = new double[count];\n+        max = new double[count];\n@@ -67,1 +75,1 @@\n-            size[i] = (int)c.getWidth();\n+            size[i] = c.getWidth();\n@@ -70,2 +78,2 @@\n-                int cmin = (int)Math.ceil(c.getMinWidth());\n-                int cmax = (int)Math.floor(Math.min(c.getMaxWidth(), Integer.MAX_VALUE));\n+                double cmin = c.getMinWidth();\n+                double cmax = c.getMaxWidth();\n@@ -85,2 +93,2 @@\n-            int sumWidths = 0;\n-            int sumMins = 0;\n+            double sumWidths = 0.0;\n+            double sumMins = 0;\n@@ -96,2 +104,2 @@\n-            int delta = target - sumWidths;\n-            if (delta == 0) {\n+            double delta = target - snap(sumWidths);\n+            if (isZero(delta)) {\n@@ -102,1 +110,1 @@\n-            int total = 0;\n+            double total = 0;\n@@ -105,1 +113,1 @@\n-                    total += step1(i);\n+                    total += pref[i];\n@@ -109,1 +117,1 @@\n-            if (total == 0) {\n+            if (isZero(total)) {\n@@ -113,8 +121,0 @@\n-            if (Math.abs(delta) < SMALL_DELTA) {\n-                distributeSmallDelta(delta);\n-                return;\n-            }\n-\n-            int acc = 0; \/\/ accumulating widths of processed columns\n-            double rem = 0.0; \/\/ remainder from previous column\n-\n@@ -126,2 +126,1 @@\n-                double dw = rem + ((double)delta * step1(i) \/ total);\n-                int w = (int)Math.round(size[i] + dw);\n+                double w = size[i] + (delta * pref[i] \/ total);\n@@ -129,1 +128,0 @@\n-                    rem = (w - min[i]);\n@@ -134,1 +132,0 @@\n-                    rem = (w - max[i]);\n@@ -138,2 +135,0 @@\n-                } else {\n-                    rem = dw - (w - size[i]);\n@@ -142,1 +137,0 @@\n-                acc += w;\n@@ -153,5 +147,0 @@\n-    protected int step1(int ix) {\n-        \/\/ TODO inline\n-        return pref[ix];\n-    }\n-\n@@ -159,2 +148,4 @@\n-     * Applies computed column widths to the tree\/table columns.\n-     * @return true if sum of columns equals or greater than the target area\n+     * Applies computed column widths to the tree\/table columns,\n+     * snapping coordinates if required.\n+     *\n+     * @return true if sum of columns equals or greater than the target width\n@@ -163,1 +154,4 @@\n-        int w = 0;\n+        p(\"applySizes\", d());\n+        double pos = 0.0;\n+        double prev = 0.0;\n+\n@@ -167,2 +161,5 @@\n-                rf.setColumnWidth(c, size[i]);\n-                w += size[i];\n+                pos = snap(pos + size[i]);\n+                double w = (pos - prev);\n+                rf.setColumnWidth(c, w);\n+            } else {\n+                pos = pos + size[i];\n@@ -170,0 +167,1 @@\n+            prev = pos;\n@@ -172,1 +170,2 @@\n-        return (w > (target - 1));\n+        p(\"applySizes done\", d());\n+        return (pos > target);\n@@ -175,1 +174,1 @@\n-    protected static int clip(double v, int min, int max) {\n+    protected static double clip(double v, double min, double max) {\n@@ -181,1 +180,1 @@\n-        return (int)v;\n+        return v;\n@@ -187,2 +186,1 @@\n-        \/\/ column that we actually resize from. If this column is a leaf, then we\n-        \/\/ use it.\n+        \/\/ column that we actually resize from. If this column is a leaf, then we use it.\n@@ -200,2 +198,2 @@\n-        int allowedDelta = getAllowedDelta(ix, expanding);\n-        if (allowedDelta == 0) {\n+        double allowedDelta = getAllowedDelta(ix, expanding);\n+        if (isZero(allowedDelta)) {\n@@ -210,2 +208,2 @@\n-        int d = computeAllowedDelta(!expanding);\n-        if (d == 0) {\n+        double d = computeAllowedDelta(!expanding);\n+        if (isZero(d)) {\n@@ -215,1 +213,1 @@\n-        allowedDelta = (int)Math.floor(Math.min(Math.abs(delta), Math.min(allowedDelta, d)));\n+        allowedDelta = Math.min(Math.abs(delta), Math.min(allowedDelta, d));\n@@ -227,1 +225,1 @@\n-    protected boolean isCornerCase(int delta, int ix) {\n+    protected boolean isCornerCase(double delta, int ix) {\n@@ -243,1 +241,1 @@\n-    protected int getAllowedDelta(int ix, boolean expanding) {\n+    protected double getAllowedDelta(int ix, boolean expanding) {\n@@ -289,2 +287,2 @@\n-    protected int computeAllowedDelta(boolean expanding) {\n-        int delta = 0;\n+    protected double computeAllowedDelta(boolean expanding) {\n+        double delta = 0;\n@@ -310,1 +308,2 @@\n-    protected boolean distributeDelta(int ix, int delta) {\n+    protected boolean distributeDelta(int ix, double delta) {\n+        double w1; \/\/ remove\n@@ -321,1 +320,3 @@\n-            int w1 = sumSizes(); \/\/ FIX\n+            if (CHECK) {\n+                w1 = sumSizes();\n+            }\n@@ -323,1 +324,2 @@\n-            int adj;\n+            double adj;\n+\n@@ -337,7 +339,1 @@\n-                adj = 0;\n-\n-                int w2 = sumSizes(); \/\/ FIX remove once everyone reviews and tests the code\n-                if(w1 != w2) {\n-                    System.err.println(\"*** ERR sum sizes before=\"  + w1 + \" after=\" + w2 + \" adj=\" + adj + \" delta=\" + delta);\n-                }\n-\n+                adj = 0.0;\n@@ -346,0 +342,1 @@\n+\n@@ -347,0 +344,15 @@\n+\n+            if (CHECK) {\n+                double w2 = sumSizes();\n+                if (Math.abs(w1 - w2) > 0.1) {\n+                    \/\/ note: this might happen when snapping with a fractional scale\n+                    System.err.println(\n+                        \"*** ERR sum sizes before=\" + w1 +\n+                        \" after=\" + w2 +\n+                        \" diff=\" + Math.abs(w1 - w2) +\n+                        \" adj=\" + adj +\n+                        \" delta=\" + delta\n+                    );\n+                }\n+            }\n+\n@@ -351,1 +363,1 @@\n-    protected int distributeDeltaFlexHead(int delta) {\n+    protected double distributeDeltaFlexHead(double delta) {\n@@ -361,2 +373,1 @@\n-\n-                    if (delta == 0) {\n+                    if (isZero(delta)) {\n@@ -376,2 +387,1 @@\n-\n-                    if (delta == 0) {\n+                    if (isZero(delta)) {\n@@ -390,2 +400,1 @@\n-\n-            if (delta == 0) {\n+            if (isZero(delta)) {\n@@ -398,1 +407,1 @@\n-    protected int distributeDeltaFlexTail(int delta) {\n+    protected double distributeDeltaFlexTail(double delta) {\n@@ -408,2 +417,1 @@\n-\n-                    if (delta == 0) {\n+                    if (isZero(delta)) {\n@@ -423,2 +431,1 @@\n-\n-                    if (delta == 0) {\n+                    if (isZero(delta)) {\n@@ -437,2 +444,1 @@\n-\n-            if (delta == 0) {\n+            if (isZero(delta)) {\n@@ -445,2 +451,2 @@\n-    protected int resize(int ix, int delta) {\n-        int w = size[ix] + delta;\n+    protected double resize(int ix, double delta) {\n+        double w = size[ix] + delta;\n@@ -454,1 +460,1 @@\n-            delta = 0;\n+            delta = 0.0;\n@@ -461,1 +467,1 @@\n-    protected void distributeDeltaRemainingColumns(int delta) {\n+    protected void distributeDeltaRemainingColumns(double delta) {\n@@ -465,1 +471,1 @@\n-            int total = 0;\n+            double total = 0;\n@@ -472,1 +478,1 @@\n-            if (total == 0) {\n+            if (isZero(total)) {\n@@ -476,1 +482,0 @@\n-            double rem = 0.0; \/\/ remainder from the previous column\n@@ -484,2 +489,1 @@\n-                double dw = rem + ((double)delta * pref[i] \/ total);\n-                int w = (int)Math.round(size[i] + dw);\n+                double w = size[i] + (delta * pref[i] \/ total);\n@@ -487,1 +491,0 @@\n-                    rem = (w - min[i]);\n@@ -493,1 +496,0 @@\n-                    rem = (w - max[i]);\n@@ -498,2 +500,0 @@\n-                } else {\n-                    rem = dw - (w - size[i]);\n@@ -513,2 +513,2 @@\n-     * for small deltas, use a simpler algorithm to distribute space one pixel at the time,\n-     * first to columns further away from their preferred width.\n+     * for small deltas, we use a simpler, but more expensive algorithm to distribute space in small steps,\n+     * each time favoring a column that is further away from its preferred width.\n@@ -516,1 +516,6 @@\n-    protected void distributeSmallDelta(int delta) {\n+    protected void distributeSmallDelta(double delta) {\n+        p(\"delta\", delta, \"before\", asList(size));\n+        distributeSmallDelta2(delta);\n+        p(\"     after\", asList(size), d());\n+    }\n+    protected void distributeSmallDelta2(double delta) {\n@@ -518,3 +523,5 @@\n-            for(int i=-delta-1; i>=0; --i) {\n-                int ix = findShrinking();\n-                if(ix < 0) {\n+            while (delta < 0.0) {\n+                double d = Math.max(-1.0, delta);\n+                double rem = shrinkSmall(d);\n+                p(\"d\", d, \"rem\", rem);\n+                if (Double.isNaN(rem)) {\n@@ -523,1 +530,2 @@\n-                size[ix] -= 1;\n+\n+                delta -= (d - rem);\n@@ -526,3 +534,5 @@\n-            for(int i=delta-1; i>=0; --i) {\n-                int ix = findGrowing();\n-                if(ix < 0) {\n+            while (delta > 0.0) {\n+                double d = Math.min(1.0, delta);\n+                double rem = expandSmall(d);\n+                p(\"d\", d, \"rem\", rem);\n+                if (Double.isNaN(rem)) {\n@@ -531,1 +541,2 @@\n-                size[ix] += 1;\n+\n+                delta -= (d - rem);\n@@ -535,4 +546,8 @@\n-\n-    \/\/ less than pref, then smallest\n-    protected int findGrowing() {\n-        int dist = Integer.MIN_VALUE;\n+    \n+    \/** \n+     * Finds the best column to shrink, then reduces its width.\n+     * Adds the column to skip list if the column width hits a constraint after adjustement.\n+     * @return unused portion of delta, or Double.NaN if it did not find a good candidate\n+     *\/\n+    protected double shrinkSmall(double delta) {\n+        double dist = Double.NEGATIVE_INFINITY;\n@@ -542,7 +557,1 @@\n-                int w = size[i] + 1;\n-                if ((w < min[i]) || (w > max[i])) {\n-                    skip.set(i);\n-                    continue;\n-                }\n-\n-                int d = pref[i] - size[i];\n+                double d = size[i] - pref[i];\n@@ -555,1 +564,14 @@\n-        return ix;\n+        \n+        if(ix < 0) {\n+            return Double.NaN;\n+        }\n+        \n+        double rem = 0.0;\n+        double w = size[ix] + delta;\n+        if(w < min[ix]) {\n+            rem = (w - min[ix]); \/\/ TODO check sign\n+            w = min[ix];\n+            skip.set(ix);\n+        }\n+        size[ix] = w;\n+        return rem;\n@@ -557,4 +579,8 @@\n-\n-    \/\/ shrinking: more than pref, then largest\n-    protected int findShrinking() {\n-        int dist = Integer.MIN_VALUE;\n+    \n+    \/** \n+     * Finds the best column to shrink, then reduces its width.\n+     * Adds the column to skip list if the column width hits a constraint after adjustement.\n+     * @return unused portion of delta, or Double.NaN if it did not find a good candidate\n+     *\/\n+    protected double expandSmall(double delta) {\n+        double dist = Double.NEGATIVE_INFINITY;\n@@ -564,7 +590,1 @@\n-                int w = size[i] - 1;\n-                if ((w < min[i]) || (w > max[i])) {\n-                    skip.set(i);\n-                    continue;\n-                }\n-\n-                int d = size[i] - pref[i];\n+                double d = pref[i] - size[i];\n@@ -577,1 +597,14 @@\n-        return ix;\n+        \n+        if(ix < 0) {\n+            return Double.NaN;\n+        }\n+        \n+        double rem = 0.0;\n+        double w = size[ix] + delta;\n+        if(w > max[ix]) {\n+            rem = (w - max[ix]); \/\/ TODO check sign\n+            w = max[ix];\n+            skip.set(ix);\n+        }\n+        size[ix] = w;\n+        return rem;\n@@ -583,1 +616,1 @@\n-                size[i] = (int)columns.get(i).getWidth();\n+                size[i] = columns.get(i).getWidth();\n@@ -588,2 +621,2 @@\n-    protected int sumSizes() {\n-        int sum = 0;\n+    protected double sumSizes() {\n+        double sum = 0;\n@@ -595,0 +628,56 @@\n+\n+    protected static boolean isZero(double x) {\n+        return Math.abs(x) < EPSILON;\n+    }\n+\n+    protected double snap(double x) {\n+        if(snap == null) {\n+            return x;\n+        }\n+        return snap.snapSpaceX(x);\n+    }\n+\n+    @Deprecated \/\/ TODO remove\n+    protected static void p(Object... items) {\n+        if (LOG) {\n+            System.err.println(print(items));\n+        }\n+    }\n+\n+    @Deprecated \/\/ TODO remove\n+    protected static String print(Object... items) {\n+        if (LOG) {\n+            StringBuilder sb = new StringBuilder();\n+            for (Object x : items) {\n+                if (sb.length() > 0) {\n+                    sb.append(' ');\n+                }\n+                sb.append(x);\n+            }\n+            return sb.toString();\n+        } else {\n+            return \"\";\n+        }\n+    }\n+    \n+    @Deprecated \/\/ TODO remove\n+    protected List<Double> asList(double[] items) {\n+        ArrayList<Double> a = new ArrayList<>(items.length);\n+        for(int i=0; i<items.length; i++) {\n+            a.add(items[i]);\n+        }\n+        return a;\n+    }\n+    \n+    @Deprecated \/\/ TODO remove\n+    protected String d() {\n+        double sum = sumSizes();\n+        boolean diff = !isZero(sum - target);\n+        \n+        return print(\n+            diff ? (\"ERR(\" + (target - sum) + \")\") : \"\",\n+            \"target\", target,\n+            \"sum\", sum,\n+            \"sizes\", asList(size)\n+        );\n+    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/ResizeHelper.java","additions":224,"deletions":135,"binary":false,"changes":359,"status":"modified"},{"patch":"@@ -171,1 +171,0 @@\n-        stage.setTitle(\"TableView\/JTable Resize Tester \" + System.getProperty(\"java.version\"));\n@@ -173,3 +172,14 @@\n-\n-        demoSelector.getSelectionModel().select(Demo.FIXED_MIDDLE); \/\/ selectFirst();\n-        policySelector.getSelectionModel().select(Policy.AUTO_RESIZE_SUBSEQUENT_COLUMNS); \/\/ selectFirst();\n+        \n+        stage.renderScaleXProperty().addListener((s,p,c) -> updateTitle(stage));\n+        updateTitle(stage);\n+\n+        demoSelector.getSelectionModel().\n+            selectFirst();\n+            \/\/select(Demo.FIXED_MIDDLE);\n+        policySelector.getSelectionModel().\n+            selectFirst();\n+            \/\/select(Policy.AUTO_RESIZE_SUBSEQUENT_COLUMNS);\n+    }\n+    \n+    protected void updateTitle(Stage s) {\n+        s.setTitle(\"TableView\/JTable Resize Tester \" + System.getProperty(\"java.version\") + \" scaleX=\" + s.getRenderScaleX());\n","filename":"tests\/manual\/tester\/src\/com\/oracle\/javafx\/tester\/ATableViewResizeTester.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"}]}