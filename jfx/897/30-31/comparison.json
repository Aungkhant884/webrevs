{"files":[{"patch":"@@ -34,3 +34,1 @@\n- * Helper class for constrained column resize policies.\n- *\n- * https:\/\/bugs.openjdk.org\/browse\/JDK-8293119\n+ * Helper class for Tree\/TableView constrained column resize policies.\n@@ -310,1 +308,1 @@\n-        switch(ct) {\n+        switch (ct) {\n@@ -322,1 +320,1 @@\n-            switch(mode) {\n+            switch (mode) {\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/ResizeHelper.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,311 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package test.javafx.scene.control;\n-import static org.junit.Assert.assertTrue;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import java.util.ArrayList;\n-import java.util.List;\n-import org.junit.After;\n-import org.junit.Test;\n-import com.sun.javafx.scene.control.ResizeHelper;\n-import com.sun.javafx.tk.Toolkit;\n-import javafx.beans.property.SimpleStringProperty;\n-import javafx.scene.control.ConstrainedColumnResizeBase;\n-import javafx.scene.control.SelectionMode;\n-import javafx.scene.control.TableColumn;\n-import javafx.scene.control.TableColumnBase;\n-import javafx.scene.control.TableView;\n-import javafx.scene.layout.BorderPane;\n-import javafx.util.Callback;\n-import test.com.sun.javafx.scene.control.infrastructure.StageLoader;\n-\n-\/**\n- * Tests the new column resize policies with TableView.\n- *\n- * TODO rename\n- * TODO parallel class with TreeTableView, or as part of each test?\n- *\/\n-public class ResizeHelperTest {\n-\n-    public enum Cmd {\n-        ROWS,\n-        COL,\n-        MIN,\n-        PREF,\n-        MAX,\n-        COMBINE\n-    }\n-\n-    private StageLoader stageLoader;\n-\n-    @After\n-    public void after() {\n-        if (stageLoader != null) {\n-            stageLoader.dispose();\n-        }\n-    }\n-\n-    protected void checkInvariants(TableView<String> t) {\n-        List<TableColumn<String,?>> cols = t.getColumns();\n-        for (TableColumn<String,?> c: cols) {\n-            assertTrue(\"violated min constraint: w=\" + c.getWidth() + \" min=\" + c.getMinWidth(),\n-                       c.getWidth() >= c.getMinWidth());\n-            assertTrue(\"violated max constraint: w=\" + c.getWidth() + \" max=\" + c.getMaxWidth(),\n-                       c.getWidth() <= c.getMaxWidth());\n-        }\n-    }\n-\n-    protected static TableView<String> createTable(Object[] spec) {\n-        TableView<String> table = new TableView();\n-        table.getSelectionModel().setCellSelectionEnabled(true);\n-        table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);\n-\n-        TableColumn<String, String> lastColumn = null;\n-        int id = 1;\n-\n-        for (int i = 0; i < spec.length;) {\n-            Object x = spec[i++];\n-            if (x instanceof Cmd cmd) {\n-                switch (cmd) {\n-                case COL:\n-                    TableColumn<String, String> c = new TableColumn<>();\n-                    table.getColumns().add(c);\n-                    c.setText(\"C\" + table.getColumns().size());\n-                    c.setCellValueFactory((f) -> new SimpleStringProperty(\" \"));\n-                    lastColumn = c;\n-                    break;\n-                case MAX:\n-                    {\n-                        int w = (int)(spec[i++]);\n-                        lastColumn.setMaxWidth(w);\n-                    }\n-                    break;\n-                case MIN:\n-                    {\n-                        int w = (int)(spec[i++]);\n-                        lastColumn.setMinWidth(w);\n-                    }\n-                    break;\n-                case PREF:\n-                    {\n-                        int w = (int)(spec[i++]);\n-                        lastColumn.setPrefWidth(w);\n-                    }\n-                    break;\n-                case ROWS:\n-                    int n = (int)(spec[i++]);\n-                    for (int j = 0; j < n; j++) {\n-                        table.getItems().add(String.valueOf(n));\n-                    }\n-                    break;\n-                case COMBINE:\n-                    int ix = (int)(spec[i++]);\n-                    int ct = (int)(spec[i++]);\n-                    combineColumns(table, ix, ct, id++);\n-                    break;\n-                default:\n-                    throw new Error(\"?\" + cmd);\n-                }\n-            } else {\n-                throw new Error(\"?\" + x);\n-            }\n-        }\n-\n-        return table;\n-    }\n-\n-    protected static void combineColumns(TableView<String> t, int ix, int count, int name) {\n-        TableColumn<String,String> tc = new TableColumn<>();\n-        tc.setText(\"N\" + name);\n-\n-        for (int i = 0; i < count; i++) {\n-            TableColumn<String, String> c = (TableColumn<String, String>)t.getColumns().remove(ix);\n-            tc.getColumns().add(c);\n-        }\n-        t.getColumns().add(ix, tc);\n-    }\n-\n-    \/** verify that a custom constrained resize policy can indeed be implemented using public APIs *\/\n-    @Test\n-    public void testCanImplementCustomResizePolicy() {\n-        double WIDTH = 15.0;\n-\n-        \/\/ constrained resize policy that simply sets all column widths to WIDTH\n-        class UserPolicy\n-            extends ConstrainedColumnResizeBase\n-            implements Callback<TableView.ResizeFeatures, Boolean> {\n-\n-            @Override\n-            public Boolean call(TableView.ResizeFeatures rf) {\n-                List<? extends TableColumnBase<?, ?>> columns = rf.getTable().getVisibleLeafColumns();\n-                int sz = columns.size();\n-                \/\/ new public method getContentWidth() is visible\n-                double w = rf.getContentWidth();\n-                for (TableColumnBase<?, ?> c: columns) {\n-                    \/\/ using added public method setColumnWidth()\n-                    rf.setColumnWidth(c, WIDTH);\n-                }\n-                return false;\n-            }\n-        }\n-\n-        Object[] spec = {\n-            Cmd.ROWS, 3,\n-            Cmd.COL,\n-            Cmd.COL,\n-            Cmd.COL,\n-            Cmd.COL\n-        };\n-        TableView<String> table = createTable(spec);\n-\n-        UserPolicy policy = new UserPolicy();\n-        table.setColumnResizePolicy(policy);\n-        table.setPrefWidth(10);\n-\n-        \/\/ verify the policy is in effect\n-\n-        stageLoader = new StageLoader(new BorderPane(table));\n-        Toolkit.getToolkit().firePulse();\n-\n-        for (TableColumn<?, ?> c: table.getColumns()) {\n-            assertEquals(WIDTH, c.getWidth());\n-        }\n-\n-        \/\/ resize and check again\n-        table.setPrefWidth(10_000);\n-        Toolkit.getToolkit().firePulse();\n-\n-        for (TableColumn<?, ?> c: table.getColumns()) {\n-            assertEquals(WIDTH, c.getWidth());\n-        }\n-    }\n-\n-    \/**\n-     * Exhausive behavioral test.\n-     *\n-     * Goes through all the policies, all valid combinations of constraints,\n-     * and widths increasing to MAX_WIDTH and back,\n-     * checkint that the initial resize does not violate (min,max) constraints.\n-     *\/\n-    \/\/@Test \/\/ this test takes too much time!\n-    public void testWidthChange() {\n-        long start = System.currentTimeMillis();\n-        for (int numCols: COLUMNS) {\n-            SpecGen gen = new SpecGen(numCols);\n-            while (gen.hasNext()) {\n-                Object[] spec = gen.next();\n-                TableView<String> table = createTable(spec);\n-                stageLoader = new StageLoader(new BorderPane(table));\n-                try {\n-                    for (int ip = 0; ip < POLICIES.length; ip++) {\n-                        Callback<TableView.ResizeFeatures, Boolean> policy = createPolicy(ip);\n-                        table.setColumnResizePolicy(policy);\n-                        for (int width: WIDTHS) {\n-                            table.setPrefWidth(width);\n-                            Toolkit.getToolkit().firePulse();\n-                            checkInvariants(table);\n-                        }\n-                    }\n-                } finally {\n-                    stageLoader.dispose();\n-                }\n-            }\n-        }\n-\n-        System.out.println(\"elapsed time = \" + (System.currentTimeMillis() - start) \/ 60_000 + \" minutes.\");\n-    }\n-\n-    protected static final Object[] POLICIES = {\n-        TableView.CONSTRAINED_RESIZE_POLICY_FLEX_NEXT_COLUMN,\n-        TableView.CONSTRAINED_RESIZE_POLICY_FLEX_LAST_COLUMN,\n-        TableView.CONSTRAINED_RESIZE_POLICY_ALL_COLUMNS,\n-        TableView.CONSTRAINED_RESIZE_POLICY_LAST_COLUMN,\n-        TableView.CONSTRAINED_RESIZE_POLICY_NEXT_COLUMN,\n-        TableView.CONSTRAINED_RESIZE_POLICY_SUBSEQUENT_COLUMNS\n-    };\n-\n-    protected static Callback<TableView.ResizeFeatures, Boolean> createPolicy(int ix) {\n-        return (Callback<TableView.ResizeFeatures, Boolean>)POLICIES[ix];\n-    }\n-\n-    protected static final int[] WIDTHS = {\n-        0, 10, 100, 10_000, 200, 50\n-    };\n-\n-    protected static final int[] COLUMNS = {\n-        0, 1, 2, 5\n-    };\n-\n-    protected static class SpecGen {\n-        private static final int LAST = 8; \/\/ 2^3 min,pref,max + 1 fixed\n-        private final int[] phase;\n-\n-        public SpecGen(int numcols) {\n-            this.phase = new int[numcols];\n-        }\n-\n-        public boolean hasNext() {\n-            int terminal = LAST;\n-            for (int n: phase) {\n-                if (n != terminal) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        public Object[] next() {\n-            ArrayList<Object> rv = new ArrayList<>(phase.length);\n-            for (int i = 0; i < phase.length; i++) {\n-                rv.add(Cmd.COL);\n-\n-                int n = phase[i];\n-                if (n < 8) {\n-                    if ((n & 0x01) != 0) {\n-                        rv.add(Cmd.MIN);\n-                        rv.add(100);\n-                    }\n-\n-                    if ((n & 0x02) != 0) {\n-                        rv.add(Cmd.PREF);\n-                        rv.add(200 + 50 * i);\n-                    }\n-\n-                    if ((n & 0x04) != 0) {\n-                        rv.add(Cmd.MAX);\n-                        rv.add(200 + 100 * i);\n-                    }\n-                } else if (n == LAST) {\n-                    rv.add(Cmd.MIN);\n-                    rv.add(50);\n-                    rv.add(Cmd.MAX);\n-                    rv.add(50);\n-                }\n-            }\n-            return rv.toArray();\n-        }\n-    }\n-}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/ResizeHelperTest.java","additions":0,"deletions":311,"binary":false,"changes":311,"status":"deleted"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.control;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javafx.scene.control.TableColumnBase;\n+import org.junit.After;\n+import test.com.sun.javafx.scene.control.infrastructure.StageLoader;\n+\n+\/**\n+ * Base class for tests the new column resize policies.\n+ * The two descendants are TableViewResizeTest and TreeTableViewResizeTest.\n+ *\/\n+public abstract class ResizeHelperTestBase {\n+\n+    public enum Cmd {\n+        ROWS,\n+        COL,\n+        MIN,\n+        PREF,\n+        MAX,\n+        COMBINE\n+    }\n+\n+    protected static final double EPSILON = 0.000001;\n+    protected StageLoader stageLoader;\n+\n+    @After\n+    public void after() {\n+        if (stageLoader != null) {\n+            stageLoader.dispose();\n+        }\n+    }\n+\n+    protected void checkInvariants(List<? extends TableColumnBase<?,?>> cols) {\n+        for (TableColumnBase<?,?> c: cols) {\n+            assertTrue(\"violated min constraint: w=\" + c.getWidth() + \" min=\" + c.getMinWidth(),\n+                       c.getWidth() >= c.getMinWidth());\n+            assertTrue(\"violated max constraint: w=\" + c.getWidth() + \" max=\" + c.getMaxWidth(),\n+                       c.getWidth() <= c.getMaxWidth());\n+        }\n+    }\n+\n+    protected static class SpecGen {\n+        public static final int[] WIDTHS = {\n+            0, 10, 100, 10_000, 200, 50\n+        };\n+        private static final int LAST = 8; \/\/ 2^3 min,pref,max + 1 fixed\n+        private final int[] phase;\n+\n+        public SpecGen(int numcols) {\n+            this.phase = new int[numcols];\n+        }\n+\n+        public boolean hasNext() {\n+            int terminal = LAST;\n+            for (int n: phase) {\n+                if (n != terminal) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        public Object[] next() {\n+            ArrayList<Object> rv = new ArrayList<>(phase.length);\n+            for (int i = 0; i < phase.length; i++) {\n+                rv.add(Cmd.COL);\n+\n+                int n = phase[i];\n+                if (n < 8) {\n+                    if ((n & 0x01) != 0) {\n+                        rv.add(Cmd.MIN);\n+                        rv.add(100);\n+                    }\n+\n+                    if ((n & 0x02) != 0) {\n+                        rv.add(Cmd.PREF);\n+                        rv.add(200 + 50 * i);\n+                    }\n+\n+                    if ((n & 0x04) != 0) {\n+                        rv.add(Cmd.MAX);\n+                        rv.add(200 + 100 * i);\n+                    }\n+                } else if (n == LAST) {\n+                    rv.add(Cmd.MIN);\n+                    rv.add(50);\n+                    rv.add(Cmd.MAX);\n+                    rv.add(50);\n+                }\n+            }\n+            return rv.toArray();\n+        }\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/ResizeHelperTestBase.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.scene.control;\n+\n+import static org.junit.Assert.assertEquals;\n+import java.util.List;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.scene.control.ConstrainedColumnResizeBase;\n+import javafx.scene.control.SelectionMode;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TableColumnBase;\n+import javafx.scene.control.TableView;\n+import javafx.scene.layout.BorderPane;\n+import javafx.util.Callback;\n+import org.junit.Test;\n+import com.sun.javafx.tk.Toolkit;\n+import test.com.sun.javafx.scene.control.infrastructure.StageLoader;\n+\n+\/**\n+ * Tests TableView constrained resize policies.\n+ *\/\n+public class TableViewResizeTest extends ResizeHelperTestBase {\n+\n+    protected void checkInvariants(TableView<String> t) {\n+        List<TableColumn<String,?>> cols = t.getColumns();\n+        checkInvariants(cols);\n+    }\n+\n+    protected static TableView<String> createTable(Object[] spec) {\n+        TableView<String> table = new TableView();\n+        table.getSelectionModel().setCellSelectionEnabled(true);\n+        table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);\n+\n+        TableColumn<String, String> lastColumn = null;\n+        int id = 1;\n+\n+        for (int i = 0; i < spec.length;) {\n+            Object x = spec[i++];\n+            if (x instanceof Cmd cmd) {\n+                switch (cmd) {\n+                case COL:\n+                    TableColumn<String, String> c = new TableColumn<>();\n+                    table.getColumns().add(c);\n+                    c.setText(\"C\" + table.getColumns().size());\n+                    c.setCellValueFactory((f) -> new SimpleStringProperty(\" \"));\n+                    lastColumn = c;\n+                    break;\n+                case MAX:\n+                    {\n+                        int w = (int)(spec[i++]);\n+                        lastColumn.setMaxWidth(w);\n+                    }\n+                    break;\n+                case MIN:\n+                    {\n+                        int w = (int)(spec[i++]);\n+                        lastColumn.setMinWidth(w);\n+                    }\n+                    break;\n+                case PREF:\n+                    {\n+                        int w = (int)(spec[i++]);\n+                        lastColumn.setPrefWidth(w);\n+                    }\n+                    break;\n+                case ROWS:\n+                    int n = (int)(spec[i++]);\n+                    for (int j = 0; j < n; j++) {\n+                        table.getItems().add(String.valueOf(n));\n+                    }\n+                    break;\n+                case COMBINE:\n+                    int ix = (int)(spec[i++]);\n+                    int ct = (int)(spec[i++]);\n+                    combineColumns(table, ix, ct, id++);\n+                    break;\n+                default:\n+                    throw new Error(\"?\" + cmd);\n+                }\n+            } else {\n+                throw new Error(\"?\" + x);\n+            }\n+        }\n+\n+        return table;\n+    }\n+\n+    protected static void combineColumns(TableView<String> t, int ix, int count, int name) {\n+        TableColumn<String,String> tc = new TableColumn<>();\n+        tc.setText(\"N\" + name);\n+\n+        for (int i = 0; i < count; i++) {\n+            TableColumn<String, String> c = (TableColumn<String, String>)t.getColumns().remove(ix);\n+            tc.getColumns().add(c);\n+        }\n+        t.getColumns().add(ix, tc);\n+    }\n+\n+    \/** verify that a custom constrained resize policy can indeed be implemented using public APIs *\/\n+    @Test\n+    public void testCanImplementCustomResizePolicy() {\n+        double WIDTH = 15.0;\n+\n+        \/\/ constrained resize policy that simply sets all column widths to WIDTH\n+        class UserPolicy\n+            extends ConstrainedColumnResizeBase\n+            implements Callback<TableView.ResizeFeatures, Boolean> {\n+\n+            @Override\n+            public Boolean call(TableView.ResizeFeatures rf) {\n+                List<? extends TableColumnBase<?, ?>> columns = rf.getTable().getVisibleLeafColumns();\n+                int sz = columns.size();\n+                \/\/ new public method getContentWidth() is visible\n+                double w = rf.getContentWidth();\n+                for (TableColumnBase<?, ?> c: columns) {\n+                    \/\/ using added public method setColumnWidth()\n+                    rf.setColumnWidth(c, WIDTH);\n+                }\n+                return false;\n+            }\n+        }\n+\n+        Object[] spec = {\n+            Cmd.ROWS, 3,\n+            Cmd.COL,\n+            Cmd.COL,\n+            Cmd.COL,\n+            Cmd.COL\n+        };\n+        TableView<String> table = createTable(spec);\n+\n+        UserPolicy policy = new UserPolicy();\n+        table.setColumnResizePolicy(policy);\n+        table.setPrefWidth(10);\n+\n+        \/\/ verify the policy is in effect\n+        stageLoader = new StageLoader(new BorderPane(table));\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (TableColumn<?, ?> c: table.getColumns()) {\n+            assertEquals(WIDTH, c.getWidth(), EPSILON);\n+        }\n+\n+        \/\/ resize and check again\n+        table.setPrefWidth(10_000);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (TableColumn<?, ?> c: table.getColumns()) {\n+            assertEquals(WIDTH, c.getWidth(), EPSILON);\n+        }\n+    }\n+\n+    \/**\n+     * Exhausive behavioral test.\n+     *\n+     * Goes through all the policies, all valid combinations of constraints,\n+     * and widths increasing to MAX_WIDTH and back,\n+     * checkint that the initial resize does not violate (min,max) constraints.\n+     *\/\n+    \/\/@Test \/\/ this test takes too much time!\n+    public void testWidthChange() {\n+        int[] COLUMNS = {\n+            0, 1, 2, 5\n+        };\n+        long start = System.currentTimeMillis();\n+        for (int numCols: COLUMNS) {\n+            SpecGen gen = new SpecGen(numCols);\n+            while (gen.hasNext()) {\n+                Object[] spec = gen.next();\n+                TableView<String> table = createTable(spec);\n+                stageLoader = new StageLoader(new BorderPane(table));\n+                try {\n+                    for (int ip = 0; ip < POLICIES.length; ip++) {\n+                        Callback<TableView.ResizeFeatures, Boolean> policy = createPolicy(ip);\n+                        table.setColumnResizePolicy(policy);\n+                        for (int width: gen.WIDTHS) {\n+                            table.setPrefWidth(width);\n+                            Toolkit.getToolkit().firePulse();\n+                            checkInvariants(table);\n+                        }\n+                    }\n+                } finally {\n+                    stageLoader.dispose();\n+                }\n+            }\n+        }\n+\n+        System.out.println(\"elapsed time = \" + (System.currentTimeMillis() - start) \/ 60_000 + \" minutes.\");\n+    }\n+\n+    protected static final Object[] POLICIES = {\n+        TableView.CONSTRAINED_RESIZE_POLICY_FLEX_NEXT_COLUMN,\n+        TableView.CONSTRAINED_RESIZE_POLICY_FLEX_LAST_COLUMN,\n+        TableView.CONSTRAINED_RESIZE_POLICY_ALL_COLUMNS,\n+        TableView.CONSTRAINED_RESIZE_POLICY_LAST_COLUMN,\n+        TableView.CONSTRAINED_RESIZE_POLICY_NEXT_COLUMN,\n+        TableView.CONSTRAINED_RESIZE_POLICY_SUBSEQUENT_COLUMNS\n+    };\n+\n+    protected static Callback<TableView.ResizeFeatures, Boolean> createPolicy(int ix) {\n+        return (Callback<TableView.ResizeFeatures, Boolean>)POLICIES[ix];\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TableViewResizeTest.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.scene.control;\n+\n+import static org.junit.Assert.assertEquals;\n+import java.util.List;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.scene.control.ConstrainedColumnResizeBase;\n+import javafx.scene.control.SelectionMode;\n+import javafx.scene.control.TableColumnBase;\n+import javafx.scene.control.TreeItem;\n+import javafx.scene.control.TreeTableColumn;\n+import javafx.scene.control.TreeTableView;\n+import javafx.scene.layout.BorderPane;\n+import javafx.util.Callback;\n+import org.junit.Test;\n+import com.sun.javafx.tk.Toolkit;\n+import test.com.sun.javafx.scene.control.infrastructure.StageLoader;\n+\n+\/**\n+ * Tests TreeTableView constrained resize policies.\n+ *\/\n+public class TreeTableViewResizeTest extends ResizeHelperTestBase {\n+\n+    protected void checkInvariants(TreeTableView<String> t) {\n+        List<TreeTableColumn<String,?>> cols = t.getColumns();\n+        checkInvariants(cols);\n+    }\n+\n+    protected static TreeTableView<String> createTable(Object[] spec) {\n+        TreeTableView<String> table = new TreeTableView(new TreeItem<>(null));\n+        table.getSelectionModel().setCellSelectionEnabled(true);\n+        table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);\n+\n+        TreeTableColumn<String, String> lastColumn = null;\n+        int id = 1;\n+\n+        for (int i = 0; i < spec.length;) {\n+            Object x = spec[i++];\n+            if (x instanceof Cmd cmd) {\n+                switch (cmd) {\n+                case COL:\n+                    TreeTableColumn<String, String> c = new TreeTableColumn<>();\n+                    table.getColumns().add(c);\n+                    c.setText(\"C\" + table.getColumns().size());\n+                    c.setCellValueFactory((f) -> new SimpleStringProperty(\" \"));\n+                    lastColumn = c;\n+                    break;\n+                case MAX:\n+                    {\n+                        int w = (int)(spec[i++]);\n+                        lastColumn.setMaxWidth(w);\n+                    }\n+                    break;\n+                case MIN:\n+                    {\n+                        int w = (int)(spec[i++]);\n+                        lastColumn.setMinWidth(w);\n+                    }\n+                    break;\n+                case PREF:\n+                    {\n+                        int w = (int)(spec[i++]);\n+                        lastColumn.setPrefWidth(w);\n+                    }\n+                    break;\n+                case ROWS:\n+                    int n = (int)(spec[i++]);\n+                    for (int j = 0; j < n; j++) {\n+                        table.getRoot().getChildren().add(new TreeItem<>(String.valueOf(n)));\n+                    }\n+                    break;\n+                case COMBINE:\n+                    int ix = (int)(spec[i++]);\n+                    int ct = (int)(spec[i++]);\n+                    combineColumns(table, ix, ct, id++);\n+                    break;\n+                default:\n+                    throw new Error(\"?\" + cmd);\n+                }\n+            } else {\n+                throw new Error(\"?\" + x);\n+            }\n+        }\n+\n+        return table;\n+    }\n+\n+    protected static void combineColumns(TreeTableView<String> t, int ix, int count, int name) {\n+        TreeTableColumn<String,String> tc = new TreeTableColumn<>();\n+        tc.setText(\"N\" + name);\n+\n+        for (int i = 0; i < count; i++) {\n+            TreeTableColumn<String, String> c = (TreeTableColumn<String, String>)t.getColumns().remove(ix);\n+            tc.getColumns().add(c);\n+        }\n+        t.getColumns().add(ix, tc);\n+    }\n+\n+    \/** verify that a custom constrained resize policy can indeed be implemented using public APIs *\/\n+    @Test\n+    public void testCanImplementCustomResizePolicy() {\n+        double WIDTH = 15.0;\n+\n+        \/\/ constrained resize policy that simply sets all column widths to WIDTH\n+        class UserPolicy\n+            extends ConstrainedColumnResizeBase\n+            implements Callback<TreeTableView.ResizeFeatures, Boolean> {\n+\n+            @Override\n+            public Boolean call(TreeTableView.ResizeFeatures rf) {\n+                List<? extends TableColumnBase<?, ?>> columns = rf.getTable().getVisibleLeafColumns();\n+                int sz = columns.size();\n+                \/\/ new public method getContentWidth() is visible\n+                double w = rf.getContentWidth();\n+                for (TableColumnBase<?, ?> c: columns) {\n+                    \/\/ using added public method setColumnWidth()\n+                    rf.setColumnWidth(c, WIDTH);\n+                }\n+                return false;\n+            }\n+        }\n+\n+        Object[] spec = {\n+            Cmd.ROWS, 3,\n+            Cmd.COL,\n+            Cmd.COL,\n+            Cmd.COL,\n+            Cmd.COL\n+        };\n+        TreeTableView<String> table = createTable(spec);\n+\n+        UserPolicy policy = new UserPolicy();\n+        table.setColumnResizePolicy(policy);\n+        table.setPrefWidth(10);\n+\n+        \/\/ verify the policy is in effect\n+        stageLoader = new StageLoader(new BorderPane(table));\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (TreeTableColumn<?, ?> c: table.getColumns()) {\n+            assertEquals(WIDTH, c.getWidth(), EPSILON);\n+        }\n+\n+        \/\/ resize and check again\n+        table.setPrefWidth(10_000);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (TreeTableColumn<?, ?> c: table.getColumns()) {\n+            assertEquals(WIDTH, c.getWidth(), EPSILON);\n+        }\n+    }\n+\n+    \/**\n+     * Exhausive behavioral test.\n+     *\n+     * Goes through all the policies, all valid combinations of constraints,\n+     * and widths increasing to MAX_WIDTH and back,\n+     * checkint that the initial resize does not violate (min,max) constraints.\n+     *\/\n+    \/\/@Test \/\/ this test takes too much time!\n+    public void testWidthChange() {\n+        int[] COLUMNS = {\n+            0, 1, 2, 5\n+        };\n+        long start = System.currentTimeMillis();\n+        for (int numCols: COLUMNS) {\n+            SpecGen gen = new SpecGen(numCols);\n+            while (gen.hasNext()) {\n+                Object[] spec = gen.next();\n+                TreeTableView<String> table = createTable(spec);\n+                stageLoader = new StageLoader(new BorderPane(table));\n+                try {\n+                    for (int ip = 0; ip < POLICIES.length; ip++) {\n+                        Callback<TreeTableView.ResizeFeatures, Boolean> policy = createPolicy(ip);\n+                        table.setColumnResizePolicy(policy);\n+                        for (int width: gen.WIDTHS) {\n+                            table.setPrefWidth(width);\n+                            Toolkit.getToolkit().firePulse();\n+                            checkInvariants(table);\n+                        }\n+                    }\n+                } finally {\n+                    stageLoader.dispose();\n+                }\n+            }\n+        }\n+\n+        System.out.println(\"elapsed time = \" + (System.currentTimeMillis() - start) \/ 60_000 + \" minutes.\");\n+    }\n+\n+    protected static final Object[] POLICIES = {\n+        TreeTableView.CONSTRAINED_RESIZE_POLICY_FLEX_NEXT_COLUMN,\n+        TreeTableView.CONSTRAINED_RESIZE_POLICY_FLEX_LAST_COLUMN,\n+        TreeTableView.CONSTRAINED_RESIZE_POLICY_ALL_COLUMNS,\n+        TreeTableView.CONSTRAINED_RESIZE_POLICY_LAST_COLUMN,\n+        TreeTableView.CONSTRAINED_RESIZE_POLICY_NEXT_COLUMN,\n+        TreeTableView.CONSTRAINED_RESIZE_POLICY_SUBSEQUENT_COLUMNS\n+    };\n+\n+    protected static Callback<TreeTableView.ResizeFeatures, Boolean> createPolicy(int ix) {\n+        return (Callback<TreeTableView.ResizeFeatures, Boolean>)POLICIES[ix];\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeTableViewResizeTest.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"}]}