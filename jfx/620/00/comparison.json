{"files":[{"patch":"@@ -304,0 +304,4 @@\n+    \/\/ test-only\n+    TablePosition<S, T> getEditingCellAtStartEdit() {\n+        return editingCellAtStartEdit;\n+    }\n@@ -345,1 +349,1 @@\n-        if (! isEditing()) return;\n+        if (!isEditing()) return;\n@@ -348,3 +352,3 @@\n-        if (table != null) {\n-            \/\/ Inform the TableView of the edit being ready to be committed.\n-            CellEditEvent editEvent = new CellEditEvent(\n+        if (getTableColumn() != null) {\n+            \/\/ Inform the TableColumn of the edit being ready to be committed.\n+            CellEditEvent<S, T> editEvent = new CellEditEvent<>(\n@@ -352,1 +356,1 @@\n-                table.getEditingCell(),\n+                editingCellAtStartEdit,\n@@ -384,3 +388,1 @@\n-        if (! isEditing()) return;\n-\n-        final TableView<S> table = getTableView();\n+        if (!isEditing()) return;\n@@ -390,1 +392,1 @@\n-        \/\/ reset the editing index on the TableView\n+        final TableView<S> table = getTableView();\n@@ -392,0 +394,1 @@\n+            \/\/ reset the editing index on the TableView\n@@ -393,1 +396,0 @@\n-\n@@ -399,0 +401,1 @@\n+        }\n@@ -400,0 +403,1 @@\n+        if (getTableColumn() != null) {\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TableCell.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import javafx.scene.control.skin.TableViewSkinBase;\n@@ -786,3 +785,0 @@\n-            if (table == null) {\n-                throw new NullPointerException(\"TableView can not be null\");\n-            }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TableColumn.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -320,0 +320,4 @@\n+    \/\/ test-only\n+    TreeTablePosition<S, T> getEditingCellAtStartEdit() {\n+        return editingCellAtStartEdit;\n+    }\n@@ -349,1 +353,1 @@\n-            CellEditEvent editEvent = new CellEditEvent(\n+            CellEditEvent<S, T> editEvent = new CellEditEvent<>(\n@@ -362,1 +366,1 @@\n-        if (! isEditing()) return;\n+        if (!isEditing()) return;\n@@ -365,5 +369,2 @@\n-        if (table != null) {\n-            @SuppressWarnings(\"unchecked\")\n-            TreeTablePosition<S,T> editingCell = (TreeTablePosition<S,T>) table.getEditingCell();\n-\n-            \/\/ Inform the TableView of the edit being ready to be committed.\n+        if (getTableColumn() != null) {\n+            \/\/ Inform the TreeTableColumn of the edit being ready to be committed.\n@@ -372,1 +373,1 @@\n-                editingCell,\n+                editingCellAtStartEdit,\n@@ -404,3 +405,1 @@\n-        if (! isEditing()) return;\n-\n-        final TreeTableView<S> table = getTreeTableView();\n+        if (!isEditing()) return;\n@@ -410,1 +409,1 @@\n-        \/\/ reset the editing index on the TableView\n+        final TreeTableView<S> table = getTreeTableView();\n@@ -412,0 +411,1 @@\n+            \/\/ reset the editing index on the TableView\n@@ -413,1 +413,0 @@\n-\n@@ -419,0 +418,1 @@\n+        }\n@@ -420,0 +420,1 @@\n+        if (getTableColumn() != null) {\n@@ -421,5 +422,5 @@\n-                table,\n-                editingCellAtStartEdit,\n-                TreeTableColumn.<S,T>editCancelEvent(),\n-                null\n-            );\n+                    table,\n+                    editingCellAtStartEdit,\n+                    TreeTableColumn.<S,T>editCancelEvent(),\n+                    null\n+                    );\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeTableCell.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -765,3 +765,0 @@\n-            if (table == null) {\n-                throw new NullPointerException(\"TableView can not be null\");\n-            }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeTableColumn.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    public static void set_lockItemOnEdit(TableCell tc, boolean b) {\n+    public static <S, T> void set_lockItemOnEdit(TableCell<S, T> tc, boolean b) {\n@@ -38,0 +38,3 @@\n+    public static <S, T> TablePosition<S, T> getEditingCellAtStartEdit(TableCell<S, T> cell) {\n+        return cell.getEditingCellAtStartEdit();\n+    }\n","filename":"modules\/javafx.controls\/src\/shims\/java\/javafx\/scene\/control\/TableCellShim.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    public static void set_lockItemOnEdit(TreeTableCell tc, boolean b) {\n+    public static <S, T> void set_lockItemOnEdit(TreeTableCell<S, T> tc, boolean b) {\n@@ -38,0 +38,4 @@\n+    public static <S, T> TreeTablePosition<S, T> getEditingCellAtStartEdit(TreeTableCell<S, T> cell) {\n+        return cell.getEditingCellAtStartEdit();\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/shims\/java\/javafx\/scene\/control\/TreeTableCellShim.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import org.junit.Ignore;\n@@ -113,1 +112,0 @@\n-    @Ignore(\"JDK-8271474\")\n@@ -130,1 +128,0 @@\n-    @Ignore(\"JDK-8271474\")\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/CellEditEventOfTableColumnTest.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import org.junit.Ignore;\n@@ -116,1 +115,0 @@\n-    @Ignore(\"JDK-8271474\")\n@@ -133,1 +131,0 @@\n-    @Ignore(\"JDK-8271474\")\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/CellEditEventOfTreeTableColumnTest.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import javafx.scene.control.CellShim;\n@@ -579,0 +580,167 @@\n+\/\/------------- commitEdit\n+ \/\/ fix of JDK-8271474 changed the implementation of how the editing location is evaluated\n+\n+     @Test\n+     public void testEditCommitEvent() {\n+         setupForEditing();\n+         int editingIndex = 1;\n+         cell.updateIndex(editingIndex);\n+         \/\/ FIXME JDK-8187474\n+         \/\/ should use cell.startEdit for consistency with the following tests\n+         table.edit(editingIndex, editingColumn);\n+         TablePosition<?, ?> editingPosition = table.getEditingCell();\n+         List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+         editingColumn.setOnEditCommit(events::add);\n+         cell.commitEdit(\"edited\");\n+         assertEquals(\"column must have received editCommit\", 1, events.size());\n+         assertEquals(\"editing location of commit event must be same as table's editingCell\",\n+                 editingPosition, events.get(0).getTablePosition());\n+     }\n+\n+     @Test\n+     public void testEditCommitEditingCellAtStartEdit() {\n+         setupForEditing();\n+         int editingIndex = 1;\n+         cell.updateIndex(editingIndex);\n+         cell.startEdit();\n+         TablePosition<?, ?> editingCellAtStartEdit = TableCellShim.getEditingCellAtStartEdit(cell);\n+         List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+         editingColumn.setOnEditCommit(events::add);\n+         cell.commitEdit(\"edited\");\n+         assertEquals(\"column must have received editCommit\", 1, events.size());\n+         assertEquals(\"editing location of commit event  must be same as editingCellAtStartEdit\",\n+                 editingCellAtStartEdit, events.get(0).getTablePosition());\n+     }\n+\n+     @Test\n+     public void testEditCommitEventNullTable() {\n+         setupForcedEditing(null, editingColumn);\n+         cell.startEdit();\n+         TablePosition<?, ?> editingCellAtStartEdit = TableCellShim.getEditingCellAtStartEdit(cell);\n+         List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+         editingColumn.addEventHandler(TableColumn.editAnyEvent(), events::add);\n+         cell.commitEdit(\"edited\");\n+         assertEquals(\"column must have received editCommit\", 1, events.size());\n+         assertEquals(\"editing location of commit event must be same as editingCellAtStartEdit\",\n+                 editingCellAtStartEdit, events.get(0).getTablePosition());\n+     }\n+\n+\/\/ --- JDK-8271474: implement consistent event firing pattern\n+\/\/  test pattern:\n+\/\/        for every edit method\n+\/\/        for every combinations of null table and null column\n+\/\/           must not throw NPE\n+\/\/           expected event state (if applicable)\n+\n+     @Test\n+     public void testEditStartNullTable() {\n+         setupForcedEditing(null, editingColumn);\n+         List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+         editingColumn.addEventHandler(TableColumn.editAnyEvent(), events::add);\n+         cell.startEdit();\n+         assertEquals(1, events.size());\n+     }\n+\n+     @Test\n+     public void testEditCancelNullTable() {\n+         setupForcedEditing(null, editingColumn);\n+         cell.startEdit();\n+         List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+         editingColumn.addEventHandler(TableColumn.editAnyEvent(), events::add);\n+         cell.cancelEdit();\n+         assertEquals(1, events.size());\n+     }\n+\n+     @Test\n+     public void testEditCommitNullTable() {\n+         setupForcedEditing(null, editingColumn);\n+         cell.startEdit();\n+         List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+         editingColumn.addEventHandler(TableColumn.editAnyEvent(), events::add);\n+         cell.commitEdit(\"edited\");\n+         assertEquals(1, events.size());\n+     }\n+\n+     @Test\n+     public void testEditStartNullColumn() {\n+         setupForcedEditing(table, null);\n+         cell.startEdit();\n+     }\n+\n+     @Test\n+     public void testEditCancelNullColumn() {\n+         setupForcedEditing(table, null);\n+         cell.startEdit();\n+         cell.cancelEdit();\n+     }\n+\n+     @Test\n+     public void testEditCommitNullColumn() {\n+         setupForcedEditing(table, null);\n+         cell.startEdit();\n+         cell.commitEdit(\"edited\");\n+     }\n+\n+     @Test\n+     public void testEditStartNullTableNullColumn() {\n+         setupForcedEditing(null, null);\n+         cell.startEdit();\n+     }\n+\n+     @Test\n+     public void testEditCancelNullTableNullColumn() {\n+         setupForcedEditing(null, null);\n+         cell.startEdit();\n+         cell.cancelEdit();\n+     }\n+\n+     @Test\n+     public void testEditCommitNullTableNullColumn() {\n+         setupForcedEditing(null, null);\n+         cell.startEdit();\n+         cell.commitEdit(\"edited\");\n+     }\n+\n+ \/\/--------- test the test setup\n+\n+     @Test\n+     public void testCellStartEditNullTable() {\n+         setupForcedEditing(null, editingColumn);\n+         \/\/ must not be empty to be switched into editing\n+         assertFalse(cell.isEmpty());\n+         cell.startEdit();\n+         assertTrue(cell.isEditing());\n+     }\n+\n+     @Test\n+     public void testCellStartEditNullColumn() {\n+         setupForcedEditing(table, null);\n+         \/\/ must not be empty to be switched into editing\n+         assertFalse(cell.isEmpty());\n+         cell.startEdit();\n+         assertTrue(cell.isEditing());\n+     }\n+\n+     @Test\n+     public void testCellStartEditNullTableNullColumn() {\n+         setupForcedEditing(null, null);\n+         \/\/ must not be empty to be switched into editing\n+         assertFalse(cell.isEmpty());\n+         cell.startEdit();\n+         assertTrue(cell.isEditing());\n+     }\n+\n+     \/**\n+      * Configures the cell to be editable without table or column.\n+      *\/\n+     private void setupForcedEditing(TableView table, TableColumn editingColumn) {\n+         if (table != null) {\n+             table.setEditable(true);\n+             cell.updateTableView(table);\n+         }\n+         if (editingColumn != null ) cell.updateTableColumn(editingColumn);\n+         \/\/ force into editable state (not empty)\n+         TableCellShim.set_lockItemOnEdit(cell, true);\n+         CellShim.updateItem(cell, \"something\", false);\n+     }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TableCellTest.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -1047,1 +1047,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TableColumnTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import javafx.scene.control.CellShim;\n@@ -905,0 +906,167 @@\n+ \/\/------------- commitEdit\n+ \/\/ fix of JDK-8271474 changed the implementation of how the editing location is evaluated\n+\n+     @Test\n+     public void testEditCommitEvent() {\n+         setupForEditing();\n+         int editingIndex = 1;\n+         cell.updateIndex(editingIndex);\n+         \/\/ FIXME JDK-8187474\n+         \/\/ should use cell.startEdit for consistency with the following tests\n+         tree.edit(editingIndex, editingColumn);\n+         TreeTablePosition<?, ?> editingPosition = tree.getEditingCell();\n+         List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+         editingColumn.setOnEditCommit(events::add);\n+         cell.commitEdit(\"edited\");\n+         assertEquals(\"column must have received editCommit\", 1, events.size());\n+         assertEquals(\"editing location of commit event must be same as table's editingCell\",\n+                 editingPosition, events.get(0).getTreeTablePosition());\n+     }\n+\n+     @Test\n+     public void testEditCommitEditingCellAtStartEdit() {\n+         setupForEditing();\n+         int editingIndex = 1;\n+         cell.updateIndex(editingIndex);\n+         cell.startEdit();\n+         TreeTablePosition<?, ?> editingCellAtStartEdit = TreeTableCellShim.getEditingCellAtStartEdit(cell);\n+         List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+         editingColumn.setOnEditCommit(events::add);\n+         cell.commitEdit(\"edited\");\n+         assertEquals(\"column must have received editCommit\", 1, events.size());\n+         assertEquals(\"editing location of commit event must be same as editingCellAtStartEdit\",\n+                 editingCellAtStartEdit, events.get(0).getTreeTablePosition());\n+     }\n+\n+     @Test\n+     public void testEditCommitEventNullTable() {\n+         setupForcedEditing(null, editingColumn);\n+         cell.startEdit();\n+         TreeTablePosition<?, ?> editingCellAtStartEdit = TreeTableCellShim.getEditingCellAtStartEdit(cell);\n+         List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+         editingColumn.addEventHandler(TreeTableColumn.editAnyEvent(), events::add);\n+         cell.commitEdit(\"edited\");\n+         assertEquals(\"column must have received editCommit\", 1, events.size());\n+         assertEquals(\"editing location of commit event must be same as editingCellAtStartEdit\",\n+                 editingCellAtStartEdit, events.get(0).getTreeTablePosition());\n+     }\n+\n+\/\/ --- JDK-8271474: implement consistent event firing pattern\n+\/\/  test pattern:\n+\/\/        for every edit method\n+\/\/        for every combinations of null table and null column\n+\/\/           must not throw NPE\n+\/\/           expected event state (if applicable)\n+\n+     @Test\n+     public void testEditStartNullTable() {\n+         setupForcedEditing(null, editingColumn);\n+         List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+         editingColumn.addEventHandler(TreeTableColumn.editAnyEvent(), events::add);\n+         cell.startEdit();\n+         assertEquals(1, events.size());\n+     }\n+\n+     @Test\n+     public void testEditCancelNullTable() {\n+         setupForcedEditing(null, editingColumn);\n+         cell.startEdit();\n+         List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+         editingColumn.addEventHandler(TreeTableColumn.editAnyEvent(), events::add);\n+         cell.cancelEdit();\n+         assertEquals(1, events.size());\n+     }\n+\n+     @Test\n+     public void testEditCommitNullTable() {\n+         setupForcedEditing(null, editingColumn);\n+         cell.startEdit();\n+         List<CellEditEvent<?, ?>> events = new ArrayList<>();\n+         editingColumn.addEventHandler(TreeTableColumn.editAnyEvent(), events::add);\n+         cell.commitEdit(\"edited\");\n+         assertEquals(1, events.size());\n+     }\n+\n+     @Test\n+     public void testEditStartNullColumn() {\n+         setupForcedEditing(tree, null);\n+         cell.startEdit();\n+     }\n+\n+     @Test\n+     public void testEditCancelNullColumn() {\n+         setupForcedEditing(tree, null);\n+         cell.startEdit();\n+         cell.cancelEdit();\n+     }\n+\n+     @Test\n+     public void testEditCommitNullColumn() {\n+         setupForcedEditing(tree, null);\n+         cell.startEdit();\n+         cell.commitEdit(\"edited\");\n+     }\n+\n+     @Test\n+     public void testEditStartNullTableNullColumn() {\n+         setupForcedEditing(null, null);\n+         cell.startEdit();\n+     }\n+\n+     @Test\n+     public void testEditCancelNullTableNullColumn() {\n+         setupForcedEditing(null, null);\n+         cell.startEdit();\n+         cell.cancelEdit();\n+     }\n+\n+     @Test\n+     public void testEditCommitNullTableNullColumn() {\n+         setupForcedEditing(null, null);\n+         cell.startEdit();\n+         cell.commitEdit(\"edited\");\n+     }\n+\n+ \/\/--------- test the test setup\n+\n+     @Test\n+     public void testCellStartEditNullTable() {\n+         setupForcedEditing(null, editingColumn);\n+         \/\/ must not be empty to be switched into editing\n+         assertFalse(cell.isEmpty());\n+         cell.startEdit();\n+         assertTrue(cell.isEditing());\n+     }\n+\n+     @Test\n+     public void testCellStartEditNullColumn() {\n+         setupForcedEditing(tree, null);\n+         \/\/ must not be empty to be switched into editing\n+         assertFalse(cell.isEmpty());\n+         cell.startEdit();\n+         assertTrue(cell.isEditing());\n+     }\n+\n+     @Test\n+     public void testCellStartEditNullTableNullColumn() {\n+         setupForcedEditing(null, null);\n+         \/\/ must not be empty to be switched into editing\n+         assertFalse(cell.isEmpty());\n+         cell.startEdit();\n+         assertTrue(cell.isEditing());\n+     }\n+\n+     \/**\n+      * Configures the cell to be editable without table or column.\n+      *\/\n+     private void setupForcedEditing(TreeTableView table, TreeTableColumn editingColumn) {\n+         if (table != null) {\n+             table.setEditable(true);\n+             cell.updateTreeTableView(table);\n+         }\n+         if (editingColumn != null ) cell.updateTableColumn(editingColumn);\n+         \/\/ force into editable state (not empty)\n+         TreeTableCellShim.set_lockItemOnEdit(cell, true);\n+         CellShim.updateItem(cell, \"something\", false);\n+     }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeTableCellTest.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -1073,1 +1073,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -1076,0 +1076,1 @@\n+        \/\/ FIXME: this factory will throw if treeItem has null value - as is the case for root\n@@ -1077,1 +1078,1 @@\n-        TreeTablePosition<Person,String> pos = new TreeTablePosition<Person, String>(table, 0, column);\n+        TreeTablePosition<Person,String> pos = new TreeTablePosition<Person, String>(table, 1, column);\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeTableColumnTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}