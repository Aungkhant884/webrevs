{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -754,0 +754,26 @@\n+    \/**\n+     * The default implementation bridges to the existing getKeyCodeForChar call. Platform\n+     * instances are expected to override this call.\n+     *\/\n+    protected boolean _canKeyGenerateCharacter(int hardwareCode, int vkCode, char c) {\n+        if (vkCode != com.sun.glass.events.KeyEvent.VK_UNDEFINED) {\n+            return getKeyCodeForChar(c) == vkCode;\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns true if the key is capable of producing the given Unicode\n+     * character. The call will be provided enough information to identify the\n+     * key, either a vkCode that is not VK_UNDEFINED or a hardwareCode that is\n+     * non-negative or both.\n+     *\n+     * @param hardwareCode the platform-specific key identifier\n+     * @param vkCode the JavaFX key code\n+     * @param c the character\n+     * @return {@code true} if the key can generate the character\n+     *\/\n+    public final boolean canKeyGenerateCharacter(int hardwareCode, int vkCode, char c) {\n+        return _canKeyGenerateCharacter(hardwareCode, vkCode, c);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/Application.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,2 +68,5 @@\n-        public void handleKeyEvent(View view, long time, int action,\n-                int keyCode, char[] keyChars, int modifiers) {\n+        public boolean handleKeyEvent(View view, long time, int action,\n+                int keyCode, char[] keyChars, int modifiers, int hardwareCode)\n+        {\n+            \/* Event was not consumed *\/\n+            return false;\n@@ -539,2 +542,2 @@\n-    private void handleKeyEvent(long time, int action,\n-            int keyCode, char[] keyChars, int modifiers) {\n+    private boolean handleKeyEvent(long time, int action,\n+            int keyCode, char[] keyChars, int modifiers, int hardwareCode) {\n@@ -542,1 +545,2 @@\n-            this.eventHandler.handleKeyEvent(this, time, action, keyCode, keyChars, modifiers);\n+            return this.eventHandler.handleKeyEvent(this, time, action, keyCode,\n+                                                    keyChars, modifiers, hardwareCode);\n@@ -544,0 +548,1 @@\n+        return false;\n@@ -966,1 +971,6 @@\n-        handleKeyEvent(System.nanoTime(), type, keyCode, keyChars, modifiers);\n+        handleKeyEvent(System.nanoTime(), type, keyCode, keyChars, modifiers, -1);\n+    }\n+\n+    \/\/ Returns true iff event was consumed\n+    protected boolean notifyKeyEx(int type, int keyCode, char[] keyChars, int modifiers, int hardwareCode) {\n+        return handleKeyEvent(System.nanoTime(), type, keyCode, keyChars, modifiers, hardwareCode);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/View.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -379,1 +379,8 @@\n-    protected native int _getKeyCodeForChar(char c);\n+    protected int _getKeyCodeForChar(char c) {\n+        \/\/ This platform has migrated to canKeyGenerateCharacter\n+        \/\/ so getKeyCodeForChar will no longer be called.\n+        throw new UnsupportedOperationException(\"Windows uses canKeyGenerateCharacter\");\n+    }\n+\n+    @Override\n+    protected native boolean _canKeyGenerateCharacter(int hardwareCode, int vkCode, char c);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/win\/WinApplication.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,2 +56,2 @@\n-    public static void processKeyEvent(Scene scene, KeyEvent e) {\n-        sceneAccessor.processKeyEvent(scene, e);\n+    public static boolean processKeyEvent(Scene scene, KeyEvent e) {\n+        return sceneAccessor.processKeyEvent(scene, e);\n@@ -121,1 +121,1 @@\n-        void processKeyEvent(Scene scene, KeyEvent e);\n+        boolean processKeyEvent(Scene scene, KeyEvent e);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/SceneHelper.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene.input;\n+\n+import com.sun.javafx.util.Utils;\n+import javafx.scene.input.KeyEvent;\n+\n+\/**\n+ * Used to access internal methods of KeyEvent.\n+ *\/\n+public class KeyEventHelper {\n+\n+    private static KeyEventAccessor keyEventAccessor;\n+\n+    static {\n+        Utils.forceInit(KeyEvent.class);\n+    }\n+\n+    private KeyEventHelper() {\n+    }\n+\n+    public static void setHardwareCode(KeyEvent keyEvent, int hardwareCode) {\n+        keyEventAccessor.setHardwareCode(keyEvent, hardwareCode);\n+    }\n+\n+    public static int getHardwareCode(KeyEvent keyEvent) {\n+        return keyEventAccessor.getHardwareCode(keyEvent);\n+    }\n+\n+    public static void setKeyEventAccessor(final KeyEventAccessor newAccessor) {\n+        if (keyEventAccessor != null) {\n+            throw new IllegalStateException();\n+        }\n+\n+        keyEventAccessor = newAccessor;\n+    }\n+\n+    public interface KeyEventAccessor {\n+        void setHardwareCode(KeyEvent keyEvent, int hardwareCode);\n+        int getHardwareCode(KeyEvent keyEvent);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/input\/KeyEventHelper.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,3 @@\n+     *\n+     * @param keyEvent The key event\n+     * @return {@code true} if the event was consumed\n@@ -67,1 +70,1 @@\n-    public void keyEvent(KeyEvent keyEvent);\n+    public boolean keyEvent(KeyEvent keyEvent);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/TKSceneListener.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -706,0 +706,9 @@\n+    \/**\n+     * The default implementation bridges into the existing getKeyCodeForChar call.\n+     *\/\n+    public boolean canKeyGenerateCharacter(KeyEvent event, String character) {\n+        if (event.getCode() != KeyCode.UNDEFINED) {\n+            return getKeyCodeForChar(character) == event.getCode().getCode();\n+        }\n+        return false;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/Toolkit.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import com.sun.javafx.scene.input.KeyEventHelper;\n@@ -150,1 +151,1 @@\n-    private class KeyEventNotification implements PrivilegedAction<Void> {\n+    private class KeyEventNotification implements PrivilegedAction<Boolean> {\n@@ -157,0 +158,1 @@\n+        int hardwareCode;\n@@ -161,1 +163,1 @@\n-        public Void run() {\n+        public Boolean run() {\n@@ -166,0 +168,1 @@\n+\n@@ -180,0 +183,1 @@\n+                KeyEventHelper.setHardwareCode(keyEvent, hardwareCode);\n@@ -218,1 +222,2 @@\n-                            scene.sceneListener.keyEvent(keyEvent);\n+                            if (scene.sceneListener.keyEvent(keyEvent))\n+                                return Boolean.TRUE;\n@@ -234,1 +239,1 @@\n-            return null;\n+            return Boolean.FALSE;\n@@ -239,2 +244,2 @@\n-    @Override public void handleKeyEvent(View view, long time, int type, int key,\n-                                         char[] chars, int modifiers)\n+    @Override public boolean handleKeyEvent(View view, long time, int type, int key,\n+                                            char[] chars, int modifiers, int hardwareCode)\n@@ -248,0 +253,1 @@\n+        keyNotification.hardwareCode = hardwareCode;\n@@ -249,1 +255,1 @@\n-        QuantumToolkit.runWithoutRenderLock(() -> {\n+        return QuantumToolkit.runWithoutRenderLock(() -> {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/GlassViewEventHandler.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+import com.sun.javafx.scene.input.KeyEventHelper;\n@@ -1089,0 +1090,14 @@\n+    \/\/ The Quantum version of this call knows that we may have the hardware key code\n+    \/\/ available.\n+    @Override public boolean canKeyGenerateCharacter(KeyEvent keyEvent, String character) {\n+        int hardwareCode = KeyEventHelper.getHardwareCode(keyEvent);\n+        if (keyEvent.getCode() != KeyCode.UNDEFINED || hardwareCode != -1) {\n+            if (character.length() == 1)\n+                return Application.GetApplication().canKeyGenerateCharacter(\n+                    hardwareCode,\n+                    keyEvent.getCode().getCode(),\n+                    character.charAt(0));\n+        }\n+        return false;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/QuantumToolkit.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import com.sun.javafx.event.EventUtil;\n@@ -400,2 +401,2 @@\n-                        public void processKeyEvent(Scene scene, KeyEvent e) {\n-                            scene.processKeyEvent(e);\n+                        public boolean processKeyEvent(Scene scene, KeyEvent e) {\n+                            return scene.processKeyEvent(e);\n@@ -2181,1 +2182,4 @@\n-    void processKeyEvent(KeyEvent e) {\n+    \/**\n+     * @return {@code true} if the event was consumed\n+     *\/\n+    boolean processKeyEvent(KeyEvent e) {\n@@ -2194,1 +2198,1 @@\n-        Event.fireEvent(eventTarget, e);\n+        return EventUtil.fireEvent(eventTarget, e) == null;\n@@ -2713,1 +2717,1 @@\n-        public void keyEvent(KeyEvent keyEvent)\n+        public boolean keyEvent(KeyEvent keyEvent)\n@@ -2715,1 +2719,1 @@\n-            processKeyEvent(keyEvent);\n+            return processKeyEvent(keyEvent);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,6 +112,2 @@\n-        if (event.getCode() == KeyCode.UNDEFINED) {\n-            return false;\n-        }\n-        return (event.getCode().getCode()\n-                       == Toolkit.getToolkit().getKeyCodeForChar(getCharacter()))\n-                   && super.match(event);\n+        return (super.match(event) &&\n+                Toolkit.getToolkit().canKeyGenerateCharacter(event, getCharacter()));\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/input\/KeyCharacterCombination.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import com.sun.javafx.scene.input.KeyEventHelper;\n+\n@@ -137,0 +139,1 @@\n+        this.hardwareCode = -1;\n@@ -165,0 +168,1 @@\n+        this.hardwareCode = -1;\n@@ -381,0 +385,4 @@\n+    \/**\n+     * The hardware key code which is private to the implementation.\n+     *\/\n+    private int hardwareCode;\n@@ -382,0 +390,3 @@\n+    int getHardwareCode() {\n+        return hardwareCode;\n+    }\n@@ -383,0 +394,19 @@\n+    void setHardwareCode(int newCode) {\n+        hardwareCode = newCode;\n+    }\n+\n+    static {\n+        KeyEventHelper.setKeyEventAccessor(\n+            new KeyEventHelper.KeyEventAccessor() {\n+                @Override\n+                public void setHardwareCode(KeyEvent keyEvent, int hardwareCode) {\n+                    keyEvent.setHardwareCode(hardwareCode);\n+                }\n+\n+                @Override\n+                public int getHardwareCode(KeyEvent keyEvent) {\n+                    return keyEvent.getHardwareCode();\n+                }\n+            }\n+        );\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/input\/KeyEvent.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,2 +174,2 @@\n-     javaIDs.View.notifyKey = env->GetMethodID(cls, \"notifyKey\", \"(II[CI)V\");\n-     ASSERT(javaIDs.View.notifyKey);\n+     javaIDs.View.notifyKeyEx = env->GetMethodID(cls, \"notifyKeyEx\", \"(II[CII)Z\");\n+     ASSERT(javaIDs.View.notifyKeyEx);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/GlassView.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -346,3 +346,3 @@\n- * Class:     Java_com_sun_glass_ui_win_WinApplication\n- * Method:    _getKeyCodeForChar\n- * Signature: (C)I\n+ * Class:     com_sun_glass_ui_win_WinApplication\n+ * Method:    _canKeyGenerateCharacter\n+ * Signature: (IIC)Z\n@@ -350,2 +350,2 @@\n-JNIEXPORT jint JNICALL Java_com_sun_glass_ui_win_WinApplication__1getKeyCodeForChar\n-  (JNIEnv * env, jobject jApplication, jchar c)\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_win_WinApplication__1canKeyGenerateCharacter\n+  (JNIEnv *env, jobject jApplication, jint hardwareCode, jint vkCode, jchar character)\n@@ -353,2 +353,21 @@\n-    BYTE vkey = 0xFF & ::VkKeyScanEx((TCHAR)c,\n-            ::GetKeyboardLayout(GlassApplication::GetMainThreadId()));\n+    HKL layout = ::GetKeyboardLayout(GlassApplication::GetMainThreadId());\n+\n+    \/\/ Normally Windows doesn't generate a character for the Delete key but the\n+    \/\/ ViewContainer synthesizes one\n+    if (vkCode == com_sun_glass_events_KeyEvent_VK_DELETE) {\n+        return character == 0x7F;\n+    }\n+\n+    \/\/ This will match keys on the numeric keypad as well as characters on the\n+    \/\/ main keyboard that don't require modifiers\n+    if (hardwareCode >= 0) {\n+        UINT keyChar = ::MapVirtualKeyEx(UINT(hardwareCode), 2, layout);\n+        \/\/ Filter out dead keys\n+        BOOL isDead = (keyChar & 0x80000000) != 0;\n+        if (!isDead && keyChar == character) {\n+            return TRUE;\n+        }\n+    }\n+\n+    \/\/ Search for the character on the main keyboard\n+    BYTE vkey = 0xFF & ::VkKeyScanEx((TCHAR)character, layout);\n@@ -357,1 +376,6 @@\n-        return com_sun_glass_events_KeyEvent_VK_UNDEFINED;\n+        return FALSE;\n+    }\n+\n+    \/\/ Compare to the hardware code if present\n+    if (hardwareCode >= 0) {\n+        return hardwareCode == vkey;\n@@ -360,1 +384,2 @@\n-    return WindowsKeyToJavaKey(vkey);\n+    \/\/ Compare Java key codes\n+    return WindowsKeyToJavaKey(vkey) == vkCode;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/KeyTable.cpp","additions":34,"deletions":9,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -450,1 +450,1 @@\n-        jmethodID notifyKey;\n+        jmethodID notifyKeyEx;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/Utils.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -472,1 +472,1 @@\n-            env->CallVoidMethod(GetView(), javaIDs.View.notifyKey,\n+            env->CallBooleanMethod(GetView(), javaIDs.View.notifyKeyEx,\n@@ -474,1 +474,1 @@\n-                    jKeyCode, jKeyChars, jModifiers);\n+                    jKeyCode, jKeyChars, jModifiers, jint(wKey));\n@@ -479,1 +479,1 @@\n-            env->CallVoidMethod(GetView(), javaIDs.View.notifyKey,\n+            env->CallBooleanMethod(GetView(), javaIDs.View.notifyKeyEx,\n@@ -482,1 +482,1 @@\n-                    jKeyCode, jKeyChars, jModifiers);\n+                    jKeyCode, jKeyChars, jModifiers, jint(wKey));\n@@ -516,1 +516,1 @@\n-            env->CallVoidMethod(GetView(), javaIDs.View.notifyKey,\n+            env->CallBooleanMethod(GetView(), javaIDs.View.notifyKeyEx,\n@@ -519,1 +519,1 @@\n-                                GetModifiers());\n+                                GetModifiers(), -1);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/win\/ViewContainer.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -8,0 +8,5 @@\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/controls\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n","filename":"tests\/manual\/events\/.classpath","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,855 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.Locale;\n+import java.util.Optional;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.event.EventHandler;\n+import javafx.geometry.Insets;\n+import javafx.scene.Node;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.ChoiceBox;\n+import javafx.scene.control.TextArea;\n+import javafx.scene.input.KeyCharacterCombination;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.KeyEvent;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.Priority;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.robot.Robot;\n+import javafx.scene.Scene;\n+import javafx.stage.Stage;\n+\n+\/*\n+ * This application tests key event handling in JavaFX. Each test uses a Robot\n+ * to send platform key events and then verifies that the correct JavaFX\n+ * KeyEvents are generated.\n+ *\n+ * To provide thorough coverage a test has to be targeted at a specific layout.\n+ * Currently there are tests for U.S. (QWERTY), French (AZERTY), German (QWERTZ)\n+ * and Spanish (QWERTY) on Mac, Windows, and Linux. Since there's no way for\n+ * JavaFX to force the layout or verify which layout is currently active it is\n+ * up to the tester to configure the correct layout before running the test.\n+ *\n+ * Each language-specific test must be run against the default layout for that\n+ * language. For example, the German test is designed to work with the layout\n+ * labeled \"German\" on a Mac, not \"German - Standard\" or any other variant.\n+ *\n+ * There is also a generic test for Latin layouts which verifies that KeyCodes A\n+ * through Z are reachable and generate the letters 'a' through 'z'. An even\n+ * more generic test is available for non-Latin, non-IME layouts which verifies\n+ * that KeyCodes A through Z generate characters.\n+ *\n+ * None of these tests cover the top-row function keys or the Caps Lock key.\n+ * They also do not cover dead keys or keys which generate accented characters\n+ * (the latter don't have KeyCodes so the Robot cannot access them).\n+ *\n+ * These tests always check that the given KeyCode generates the expected\n+ * character (if any). They can optionally check that KeyCharacterCombinations\n+ * match for characters on that key. This option is disabled by default since\n+ * KeyCharacterCombinations don't work reliably on most platforms (for now).\n+ *\n+ * Mac users will need to grant permission for the Terminal application to use\n+ * accessibility features. Add Terminal to the list of applications in\n+ * System Settings > Privacy & Security > Accessibility.\n+ *\/\n+\n+public class KeyboardTest extends Application {\n+\n+    public static void main(String[] args) {\n+        Application.launch(args);\n+    }\n+\n+    private static final String os = System.getProperty(\"os.name\");\n+    private static final boolean onMac = os.startsWith(\"Mac\");\n+    private static final boolean onLinux = os.startsWith(\"Linux\");\n+    private static final boolean onWindows = os.startsWith(\"Windows\");\n+\n+    \/**\n+     * Data for testing one key including the code and expected character.\n+     *\/\n+    static private class KeyData {\n+        \/*\n+         * If character is null it means we don't expect a TYPED event. If\n+         * character is \"wild\" it means we'll accept anything (used for testing\n+         * non-Latin layouts).\n+         *\/\n+        public final KeyCode   code;\n+        public final String    character;\n+\n+        \/*\n+         * Optional characters on this key accessed using modifiers like Shift,\n+         * Option, or AltGr.\n+         *\/\n+        public String          comboChar;\n+        public String          comboChar2;\n+\n+        \/*\n+         * We also test a handful of KeyCodes which should not generate any\n+         * events, like UNDEFINED. For these we set the absent flag.\n+         *\/\n+        public boolean         absent;\n+\n+        public KeyData(KeyCode cd, String ch, String combo1, String combo2) {\n+            code = cd;\n+            character = ch;\n+            comboChar = combo1;\n+            comboChar2 = combo2;\n+            absent = false;\n+        }\n+    }\n+\n+    \/**\n+     * List of keys to test for one layout\n+     *\/\n+    @SuppressWarnings(\"serial\")\n+    static private class KeyList extends ArrayList<KeyData> {}\n+\n+    static private class KeyListBuilder {\n+\n+        private final KeyList list = new KeyList();\n+        public final KeyList getList() {\n+            return list;\n+        }\n+\n+        private static final String DOUBLE_QUOTE = \"\\\"\";\n+        private static final String QUOTE        = \"\\'\";\n+        private static final String BACK_SLASH   = \"\\\\\";\n+        private static final String A_GRAVE      = \"\\u00E0\";\n+        private static final String E_GRAVE      = \"\\u00E8\";\n+        private static final String E_ACUTE      = \"\\u00E9\";\n+        private static final String SECTION      = \"\\u00A7\";\n+        private static final String C_CEDILLA    = \"\\u00E7\";\n+        private static final String DEGREE_SIGN  = \"\\u00B0\";\n+        private static final String POUND_SIGN   = \"\\u00A3\";\n+        private static final String MIDDLE_DOT   = \"\\u00B7\";\n+        private static final String INV_EXCLAMATION_MARK = \"\\u00A1\";\n+        private static final String INV_QUESTION_MARK    = \"\\u00BF\";\n+\n+        \/* Add a key with unshifted and shifted characters *\/\n+        private void add(KeyCode cd, String base, String shifted) {\n+            list.add(new KeyData(cd, base, shifted, null));\n+        }\n+\n+        \/* Add a key with an unshifted character *\/\n+        private void add(KeyCode cd, String base) {\n+            list.add(new KeyData(cd, base, null, null));\n+        }\n+\n+        \/* Add a key that does not generate a TYPED event *\/\n+        private void add(KeyCode cd) {\n+            list.add(new KeyData(cd, null, null, null));\n+        }\n+\n+        \/* Add a key with unshifted, shifted, and AltGr\/Option characters *\/\n+        private void add(KeyCode cd, String base, String shifted, String altGr) {\n+            list.add(new KeyData(cd, base, shifted, altGr));\n+        }\n+\n+        \/* Add a key that should not generate any events *\/\n+        public void addAbsent(KeyCode cd) {\n+            KeyData missing = new KeyData(cd, null, null, null);\n+            missing.absent = true;\n+            list.add(missing);\n+        }\n+\n+        \/*\n+         * Add keys A through Z assuming they generate 'a' through 'z' unshifted\n+         * and 'A' to 'Z' shifted\n+         *\/\n+        private void addLetters() {\n+            for (Character c = 'A'; c <= 'Z'; ++c) {\n+                String s = String.valueOf(c);\n+                KeyCode code = KeyCode.valueOf(s);\n+                add(code, s.toLowerCase(Locale.ENGLISH), s);\n+            }\n+        }\n+\n+        private void addDigits() {\n+            add(KeyCode.DIGIT0, \"0\");\n+            add(KeyCode.DIGIT1, \"1\");\n+            add(KeyCode.DIGIT2, \"2\");\n+            add(KeyCode.DIGIT3, \"3\");\n+            add(KeyCode.DIGIT4, \"4\");\n+            add(KeyCode.DIGIT5, \"5\");\n+            add(KeyCode.DIGIT6, \"6\");\n+            add(KeyCode.DIGIT7, \"7\");\n+            add(KeyCode.DIGIT8, \"8\");\n+            add(KeyCode.DIGIT9, \"9\");\n+        }\n+\n+        private void addKeypad() {\n+            add(KeyCode.NUMPAD0,  \"0\");\n+            add(KeyCode.NUMPAD1,  \"1\");\n+            add(KeyCode.NUMPAD2,  \"2\");\n+            add(KeyCode.NUMPAD3,  \"3\");\n+            add(KeyCode.NUMPAD4,  \"4\");\n+            add(KeyCode.NUMPAD5,  \"5\");\n+            add(KeyCode.NUMPAD6,  \"6\");\n+            add(KeyCode.NUMPAD7,  \"7\");\n+            add(KeyCode.NUMPAD8,  \"8\");\n+            add(KeyCode.NUMPAD9,  \"9\");\n+            add(KeyCode.ADD,      \"+\");\n+            add(KeyCode.SUBTRACT, \"-\");\n+            add(KeyCode.MULTIPLY, \"*\");\n+            add(KeyCode.DIVIDE,   \"\/\");\n+            if (onMac) {\n+                add(KeyCode.CLEAR, \"\");\n+            }\n+            \/*\n+             * We do not add DECIMAL since the character it generates varies by\n+             * platform and language. It will be added later.\n+             *\/\n+        }\n+\n+        private void addNavigation() {\n+            add(KeyCode.HOME);\n+            add(KeyCode.END);\n+            add(KeyCode.PAGE_UP);\n+            add(KeyCode.PAGE_DOWN);\n+            add(KeyCode.UP);\n+            add(KeyCode.DOWN);\n+            add(KeyCode.LEFT);\n+            add(KeyCode.RIGHT);\n+        }\n+\n+        private void addMiscellaneous() {\n+            add(KeyCode.SHIFT);\n+            add(KeyCode.ALT);\n+            add(KeyCode.CONTROL);\n+\n+            add(KeyCode.SPACE, \" \");\n+            add(KeyCode.TAB,   \"\\t\");\n+\n+            \/*\n+             * ENTER is assigned to both Return and Enter which generate\n+             * different characters.\n+             *\/\n+            add(KeyCode.ENTER, \"wild\");\n+\n+            if (onMac) {\n+                add(KeyCode.COMMAND);\n+                add(KeyCode.BACK_SPACE, \"\");\n+                add(KeyCode.DELETE,     \"\");\n+                add(KeyCode.ESCAPE,     \"\");\n+            } else {\n+                add(KeyCode.BACK_SPACE, \"\\u0008\");\n+                add(KeyCode.DELETE,     \"\\u007F\");\n+                add(KeyCode.ESCAPE,     \"\\u001B\");\n+                add(KeyCode.INSERT);\n+\n+                \/\/ Sent twice to toggle off and back on\n+                add(KeyCode.NUM_LOCK);\n+                add(KeyCode.NUM_LOCK);\n+            }\n+\n+            \/*\n+             * We do not test CAPS. Every platform has special case code for\n+             * CAPS that generates multiple PRESSED and RELEASED events in\n+             * succession.\n+             *\/\n+\n+            \/*\n+             * Clearly this KeyCode should not generate any events.\n+             *\/\n+            addAbsent(KeyCode.UNDEFINED);\n+        }\n+\n+        \/*\n+         * Add all of the keys common to all layouts\n+         *\/\n+        private void addCommon() {\n+            addKeypad();\n+            addNavigation();\n+            addMiscellaneous();\n+        }\n+\n+        \/*\n+         * The U.S. English QWERTY layout. Same on all platforms.\n+         *\/\n+        public static KeyList usEnglishKeys() {\n+            KeyListBuilder builder = new KeyListBuilder();\n+            builder.addCommon();\n+            builder.addLetters();\n+\n+            builder.add(KeyCode.DIGIT0, \"0\", \")\");\n+            builder.add(KeyCode.DIGIT1, \"1\", \"!\");\n+            builder.add(KeyCode.DIGIT2, \"2\", \"@\");\n+            builder.add(KeyCode.DIGIT3, \"3\", \"#\");\n+            builder.add(KeyCode.DIGIT4, \"4\", \"$\");\n+            builder.add(KeyCode.DIGIT5, \"5\", \"%\");\n+            builder.add(KeyCode.DIGIT6, \"6\", \"^\");\n+            builder.add(KeyCode.DIGIT7, \"7\", \"&\");\n+            builder.add(KeyCode.DIGIT8, \"8\", \"*\");\n+            builder.add(KeyCode.DIGIT9, \"9\", \"(\");\n+\n+            builder.add(KeyCode.BACK_QUOTE,    \"`\",  \"~\");\n+            builder.add(KeyCode.MINUS,         \"-\",  \"_\");\n+            builder.add(KeyCode.EQUALS,        \"=\",  \"+\");\n+            builder.add(KeyCode.OPEN_BRACKET,  \"[\",  \"{\");\n+            builder.add(KeyCode.CLOSE_BRACKET, \"]\",  \"}\");\n+            builder.add(KeyCode.BACK_SLASH,    BACK_SLASH, \"|\");\n+            builder.add(KeyCode.SEMICOLON,     \";\",  \":\");\n+            builder.add(KeyCode.QUOTE,         QUOTE, DOUBLE_QUOTE);\n+            builder.add(KeyCode.COMMA,         \",\",  \"<\");\n+            builder.add(KeyCode.PERIOD,        \".\",  \">\");\n+            builder.add(KeyCode.SLASH,         \"\/\",  \"?\");\n+\n+            builder.add(KeyCode.DECIMAL,       \".\");\n+\n+            builder.addAbsent(KeyCode.PLUS);\n+\n+            return builder.getList();\n+        }\n+\n+        \/* The French AZERTY layout *\/\n+        public static KeyList frenchKeys() {\n+            KeyListBuilder builder = new KeyListBuilder();\n+            builder.addCommon();\n+            builder.addLetters();\n+\n+            \/* Include one combination that involves AltGr\/Option. *\/\n+            final String altGrFive = (onMac ? \"{\" : \"[\");\n+\n+            \/*\n+             * On a French layout the unshifted top-row keys (which generate\n+             * digits in most other languages) generate punctuation or accented\n+             * characters. Linux uses these characters to generate KeyCodes; Mac\n+             * and Windows still encode these keys as digits.\n+             *\/\n+            if (onLinux) {\n+                builder.add(KeyCode.AMPERSAND,        \"&\",          \"1\");\n+                builder.add(KeyCode.QUOTEDBL,         DOUBLE_QUOTE, \"3\");\n+                builder.add(KeyCode.QUOTE,            QUOTE,        \"4\");\n+                builder.add(KeyCode.LEFT_PARENTHESIS, \"(\",          \"5\", altGrFive);\n+                builder.add(KeyCode.MINUS,            \"-\",          \"6\");\n+                builder.add(KeyCode.UNDERSCORE,       \"_\",          \"8\");\n+            } else {\n+                builder.add(KeyCode.DIGIT0, A_GRAVE,      \"0\");\n+                builder.add(KeyCode.DIGIT1, \"&\",          \"1\");\n+                builder.add(KeyCode.DIGIT2, E_ACUTE,      \"2\");\n+                builder.add(KeyCode.DIGIT3, DOUBLE_QUOTE, \"3\");\n+                builder.add(KeyCode.DIGIT4, QUOTE,        \"4\");\n+                builder.add(KeyCode.DIGIT5, \"(\",          \"5\", altGrFive);\n+                \/* Six and eight require some tweaking, below *\/\n+                builder.add(KeyCode.DIGIT7, E_GRAVE,      \"7\");\n+                builder.add(KeyCode.DIGIT9, C_CEDILLA,    \"9\");\n+\n+                if (onMac) {\n+                    builder.add(KeyCode.DIGIT6, SECTION,  \"6\");\n+                    builder.add(KeyCode.DIGIT8, \"!\",      \"8\");\n+                } else {\n+                    builder.add(KeyCode.DIGIT6, \"-\",      \"6\");\n+                    builder.add(KeyCode.DIGIT8, \"_\",      \"8\");\n+                }\n+            }\n+\n+            builder.add(KeyCode.LESS,              \"<\", \">\");\n+            builder.add(KeyCode.RIGHT_PARENTHESIS, \")\", DEGREE_SIGN);\n+            builder.add(KeyCode.COMMA,             \",\", \"?\");\n+            builder.add(KeyCode.SEMICOLON,         \";\", \".\");\n+            builder.add(KeyCode.COLON,             \":\", \"\/\");\n+            builder.add(KeyCode.EQUALS,            \"=\", \"+\");\n+\n+            if (onMac) {\n+                builder.add(KeyCode.DOLLAR,        \"$\", \"*\");\n+                builder.add(KeyCode.MINUS,         \"-\", \"_\");\n+                builder.add(KeyCode.DECIMAL,       \",\");\n+            } else {\n+                builder.add(KeyCode.DOLLAR,           \"$\", POUND_SIGN);\n+                builder.add(KeyCode.EXCLAMATION_MARK, \"!\", SECTION);\n+                builder.add(KeyCode.DECIMAL,          \".\");\n+            }\n+\n+            builder.addAbsent(KeyCode.PLUS);\n+\n+            return builder.getList();\n+        }\n+\n+        \/* The German QWERTZ layout *\/\n+        public static KeyList germanKeys() {\n+            KeyListBuilder builder = new KeyListBuilder();\n+            builder.addCommon();\n+            builder.addLetters();\n+\n+            \/* Include one combination that involves Option\/AltGr *\/\n+            final String altGrSeven = (onMac ? \"|\" : \"{\");\n+            final String decimalCharacter = (onLinux ? \".\" : \",\");\n+\n+            builder.add(KeyCode.DIGIT0, \"0\", \"=\");\n+            builder.add(KeyCode.DIGIT1, \"1\", \"!\");\n+            builder.add(KeyCode.DIGIT2, \"2\", DOUBLE_QUOTE);\n+            builder.add(KeyCode.DIGIT3, \"3\", SECTION);\n+            builder.add(KeyCode.DIGIT4, \"4\", \"$\");\n+            builder.add(KeyCode.DIGIT5, \"5\", \"%\");\n+            builder.add(KeyCode.DIGIT6, \"6\", \"&\");\n+            builder.add(KeyCode.DIGIT7, \"7\", \"\/\", altGrSeven);\n+            builder.add(KeyCode.DIGIT8, \"8\", \"(\");\n+            builder.add(KeyCode.DIGIT9, \"9\", \")\");\n+\n+            builder.add(KeyCode.LESS,        \"<\", \">\");\n+            builder.add(KeyCode.PLUS,        \"+\", \"*\");\n+            builder.add(KeyCode.NUMBER_SIGN, \"#\", QUOTE);\n+            builder.add(KeyCode.COMMA,       \",\", \";\");\n+            builder.add(KeyCode.PERIOD,      \".\", \":\");\n+            builder.add(KeyCode.MINUS,       \"-\", \"_\");\n+\n+            builder.add(KeyCode.DECIMAL,     decimalCharacter);\n+\n+            builder.addAbsent(KeyCode.COLON);\n+\n+            return builder.getList();\n+        }\n+\n+        \/* Spanish QWERTY *\/\n+        public static KeyList spanishKeys() {\n+            KeyListBuilder builder = new KeyListBuilder();\n+            builder.addCommon();\n+            builder.addLetters();\n+\n+            final String decimalCharacter = (onMac ? \",\" : \".\");\n+\n+            builder.add(KeyCode.DIGIT0, \"0\", \"=\");\n+            builder.add(KeyCode.DIGIT1, \"1\", \"!\");\n+            builder.add(KeyCode.DIGIT2, \"2\", DOUBLE_QUOTE);\n+            builder.add(KeyCode.DIGIT3, \"3\", MIDDLE_DOT);\n+            builder.add(KeyCode.DIGIT4, \"4\", \"$\");\n+            builder.add(KeyCode.DIGIT5, \"5\", \"%\");\n+            builder.add(KeyCode.DIGIT6, \"6\", \"&\");\n+            builder.add(KeyCode.DIGIT7, \"7\", \"\/\");\n+            builder.add(KeyCode.DIGIT8, \"8\", \"(\");\n+            builder.add(KeyCode.DIGIT9, \"9\", \")\");\n+\n+            builder.add(KeyCode.QUOTE,        QUOTE, \"?\");\n+            builder.add(KeyCode.INVERTED_EXCLAMATION_MARK, INV_EXCLAMATION_MARK, INV_QUESTION_MARK);\n+            builder.add(KeyCode.PLUS,         \"+\", \"*\", \"]\");\n+            builder.add(KeyCode.LESS,         \"<\", \">\");\n+            builder.add(KeyCode.COMMA,        \",\", \";\");\n+            builder.add(KeyCode.PERIOD,       \".\", \":\");\n+            builder.add(KeyCode.MINUS,        \"-\", \"_\");\n+\n+            builder.add(KeyCode.DECIMAL,      decimalCharacter);\n+\n+            builder.addAbsent(KeyCode.EQUALS);\n+\n+            return builder.getList();\n+        }\n+\n+        \/*\n+         * A generic Latin layout. No digits since layouts derived from French\n+         * won't generate digit characters and may not even be encoded as digits\n+         * on Linux.\n+         *\/\n+        public static KeyList latinKeys() {\n+            KeyListBuilder builder = new KeyListBuilder();\n+            builder.addCommon();\n+            builder.addLetters();\n+            return builder.getList();\n+        }\n+\n+        \/*\n+         * For non-Latin layouts that do not use an IME (Greek, Cyrillic) we\n+         * should be able to access the letter KeyCodes though we have no idea\n+         * what characters they generate.\n+         *\/\n+        public static KeyList nonLatinKeys() {\n+            KeyListBuilder builder = new KeyListBuilder();\n+            builder.addCommon();\n+            builder.addDigits();\n+            for (Character c = 'A'; c <= 'Z'; ++c) {\n+                String s = String.valueOf(c);\n+                KeyCode code = KeyCode.valueOf(s);\n+                builder.add(code, \"wild\");\n+            }\n+            return builder.getList();\n+        }\n+    }\n+\n+    private enum Layout {\n+        US_ENGLISH(\"U.S. English\", KeyListBuilder.usEnglishKeys()),\n+        FRENCH(\"French\", KeyListBuilder.frenchKeys()),\n+        GERMAN(\"German\", KeyListBuilder.germanKeys()),\n+        SPANISH(\"Spanish\", KeyListBuilder.spanishKeys()),\n+        LATIN(\"Latin\", KeyListBuilder.latinKeys()),\n+        NON_LATIN(\"non-Latin\", KeyListBuilder.nonLatinKeys());\n+\n+        private final String label;\n+        private final KeyList keys;\n+\n+        private Layout(String l, KeyList k) {\n+            this.label = l;\n+            this.keys = k;\n+        }\n+\n+        public String toString() {\n+            return label;\n+        }\n+\n+        public KeyList getKeys() {\n+            return keys;\n+        }\n+    }\n+\n+    \/*\n+     * KeyCharacterCombinations should really work on the numeric keypad but\n+     * currently don't on Windows and Linux. The tests can exclude combinations\n+     * entirely, exclude just the numeric keypad, or cover both the main\n+     * keyboard and the keypad.\n+     *\/\n+    private enum CombinationScope {\n+        NONE(\"without combinations\"),\n+        NO_KEYPAD(\"without keypad combinations\"),\n+        ALL(\"with all combinations\");\n+\n+        private final String label;\n+\n+        private CombinationScope(String l) {\n+            this.label = l;\n+        }\n+\n+        public String toString() {\n+            return label;\n+        }\n+    }\n+\n+    private interface Logging {\n+        public void clear();\n+        public void addLine(String s);\n+    }\n+\n+    \/*\n+     * The class that walks through the key list sending Robot events and\n+     * verifies the expected KeyEvents come back.\n+     *\/\n+    private class TestRunner {\n+\n+        \/*\n+         * Configured during initialization\n+         *\/\n+        private final Layout layout;\n+        private final CombinationScope combinationScope;\n+        private final Node focusNode;\n+        private final Logging log;\n+        private final KeyList keys;\n+\n+        \/*\n+         * Our progress\n+         *\/\n+        private int currentIndex = -1;\n+        private int numSent = 0;\n+        private int numFailed = 0;\n+\n+        \/* The character in the last TYPED event *\/\n+        private String characterReceived = null;\n+\n+        private final Robot robot = new Robot();\n+        private Timer timer = null;\n+\n+        private final EventHandler<KeyEvent> pressedHandler = this::pressedEvent;\n+        private final EventHandler<KeyEvent> releasedHandler = this::releasedEvent;\n+        private final EventHandler<KeyEvent> typedHandler = this::typedEvent;\n+\n+        private Runnable runAtEnd = null;\n+\n+        public TestRunner(Layout layout, CombinationScope scope,\n+                          Node focusNode, Logging log) {\n+            this.layout = layout;\n+            this.combinationScope = scope;\n+            this.focusNode = focusNode;\n+            this.log = log;\n+            this.keys = layout.getKeys();\n+        }\n+\n+        private String toPrintable(String s) {\n+            if (s == null) {\n+                return \"null\";\n+            } else if (!s.isEmpty()) {\n+                char c = s.charAt(0);\n+                int codePoint = s.codePointAt(0);\n+                if (Character.isISOControl(c) || Character.isWhitespace(c)) {\n+                    return String.format(\"U+%04X\", codePoint);\n+                } else {\n+                    return s;\n+                }\n+            }\n+            return \"empty\";\n+        }\n+\n+        private void fail(String s) {\n+            numFailed += 1;\n+            log.addLine(\"Failed: \" + s);\n+        }\n+\n+        private void start(Runnable atEnd) {\n+            runAtEnd = atEnd;\n+\n+            log.clear();\n+\n+            Optional<Boolean> capsLockOn = Platform.isKeyLocked(KeyCode.CAPS);\n+            Optional<Boolean> numLockOn = Platform.isKeyLocked(KeyCode.NUM_LOCK);\n+            boolean proceed = true;\n+            if (capsLockOn.isPresent() && capsLockOn.get() == Boolean.TRUE) {\n+                log.addLine(\"Disable Caps Lock before running test.\");\n+                proceed = false;\n+            }\n+            if (numLockOn.isPresent() && numLockOn.get() == Boolean.FALSE) {\n+                log.addLine(\"Enable Num Lock before running test.\");\n+                proceed = false;\n+            }\n+            if (!proceed) {\n+                if (runAtEnd != null) {\n+                    runAtEnd.run();\n+                }\n+                return;\n+            }\n+\n+            String osName = \"unknown\";\n+            if (onWindows) {\n+                osName = \"Win\";\n+            } else if (onMac) {\n+                osName = \"Mac\";\n+            } else if (onLinux) {\n+                osName = \"Linux\";\n+            }\n+\n+            log.addLine(\"[\" + osName + \"] Testing \" + keys.size() + \" keys on \"\n+                    + layout + \" \" + combinationScope);\n+\n+            focusNode.addEventFilter(KeyEvent.KEY_PRESSED, pressedHandler);\n+            focusNode.addEventFilter(KeyEvent.KEY_RELEASED, releasedHandler);\n+            focusNode.addEventFilter(KeyEvent.KEY_TYPED, typedHandler);\n+            focusNode.requestFocus();\n+\n+            currentIndex = -1;\n+            advance();\n+        }\n+\n+        private void advance() {\n+            if (timer != null) {\n+                timer.cancel();\n+                timer = null;\n+            }\n+            currentIndex += 1;\n+            if (currentIndex >= keys.size()) {\n+                cleanup();\n+            } else {\n+                characterReceived = null;\n+                numSent += 1;\n+                KeyData data = keys.get(currentIndex);\n+                Platform.runLater(() -> sendCode(data.code));\n+            }\n+        }\n+\n+        private void sendCode(KeyCode code) {\n+            \/*\n+            * This timer is cleared when the RELEASED event calls advance().\n+            *\/\n+            TimerTask task = new TimerTask() {\n+                public void run() {\n+                    Platform.runLater(() -> keyTimedOut());\n+                }\n+            };\n+            timer = new Timer();\n+            timer.schedule(task, 100);\n+            robot.keyPress(code);\n+            robot.keyRelease(code);\n+        }\n+\n+        \/*\n+        * No RELEASED event arrived. Acceptable if the key was supposed to be\n+        * absent.\n+        *\/\n+        private void keyTimedOut() {\n+            KeyData key = keys.get(currentIndex);\n+            if (!key.absent) {\n+                fail(\"code \" + key.code.getName() + \" did not produce any events\");\n+            }\n+            advance();\n+        }\n+\n+        private static boolean isOnKeypad(KeyCode code) {\n+            switch (code) {\n+                case DIVIDE, MULTIPLY, SUBTRACT, ADD, DECIMAL:\n+                case NUMPAD0, NUMPAD1, NUMPAD2, NUMPAD3, NUMPAD4:\n+                case NUMPAD5, NUMPAD6, NUMPAD7, NUMPAD8, NUMPAD9:\n+                    return true;\n+            }\n+            return false;\n+        }\n+\n+        private void checkCombination(KeyEvent event, String comboString) {\n+            if (combinationScope == CombinationScope.NONE) {\n+                return;\n+            }\n+            if (comboString == null || comboString.isEmpty() || comboString.equals(\"wild\")) {\n+                return;\n+            }\n+            if (isOnKeypad(event.getCode()) && (combinationScope != CombinationScope.ALL)) {\n+                return;\n+            }\n+\n+            KeyCharacterCombination combo = new KeyCharacterCombination(comboString);\n+            if (!combo.match(event)) {\n+                fail(\"code \" + event.getCode().getName() + \" did not match combination \"\n+                    + toPrintable(combo.getCharacter()));\n+            }\n+        }\n+\n+        private void pressedEvent(KeyEvent e) {\n+            KeyData key = keys.get(currentIndex);\n+            KeyCode got = e.getCode();\n+            KeyCode expected = key.code;\n+            String preamble = \"code \" + key.code.getName() + \" \";\n+\n+            if (key.absent) {\n+                fail(preamble + \"produced an unexpected PRESSED event\");\n+            } else if (expected != got) {\n+                fail(preamble + \"was sent but code \" + got.getName() + \" was received\");\n+            } else {\n+                checkCombination(e, key.character);\n+                checkCombination(e, key.comboChar);\n+                checkCombination(e, key.comboChar2);\n+            }\n+            e.consume();\n+        }\n+\n+        private void typedEvent(KeyEvent e) {\n+            KeyData key = keys.get(currentIndex);\n+            String preamble = \"code \" + key.code.getName() + \" \";\n+            characterReceived = e.getCharacter();\n+\n+            if (key.character == null) {\n+                String printable = toPrintable(characterReceived);\n+                fail(preamble + \"produced an unexpected TYPED event (\" + printable + \")\");\n+            } else if (key.character.equals(\"wild\")) {\n+                if (characterReceived == null || characterReceived.isEmpty()) {\n+                    fail(preamble + \"produced a TYPED event with no character\");\n+                }\n+            } else if (!key.character.equals(characterReceived)) {\n+                fail(preamble + \"generated \" + toPrintable(characterReceived)\n+                    + \" instead of \" + toPrintable(key.character));\n+            }\n+            e.consume();\n+        }\n+\n+        private void releasedEvent(KeyEvent e) {\n+            KeyData key = keys.get(currentIndex);\n+            String preamble = \"code \" + key.code.getName() + \" \";\n+\n+            if (key.absent) {\n+                fail(preamble + \"produced an unexpected RELEASED event\");\n+            } else if ((key.character != null) && (characterReceived == null)) {\n+                fail(preamble + \"did not produce a TYPED event\");\n+            }\n+            e.consume();\n+            advance();\n+        }\n+\n+        \/*\n+         * Called after the list of keys is exhausted.\n+         *\/\n+        private void cleanup() {\n+            if (timer != null) {\n+                timer.cancel();\n+                timer = null;\n+            }\n+\n+            focusNode.removeEventFilter(KeyEvent.KEY_PRESSED, pressedHandler);\n+            focusNode.removeEventFilter(KeyEvent.KEY_RELEASED, releasedHandler);\n+            focusNode.removeEventFilter(KeyEvent.KEY_TYPED, typedHandler);\n+\n+            log.addLine(\"Tested \" + numSent + \" keys with \"\n+                    + (numFailed == 1 ? \"1 failure\" : numFailed + \" failures\"));\n+\n+            if (runAtEnd != null) {\n+                runAtEnd.run();\n+            }\n+        }\n+    }\n+\n+    private class TextLogging implements Logging {\n+        private final TextArea textArea;\n+        public TextLogging(TextArea ta) {\n+            textArea = ta;\n+        }\n+\n+        public void clear() {\n+            textArea.setText(\"\");\n+        }\n+\n+        public void addLine(String s) {\n+            textArea.appendText(s + \"\\n\");\n+        }\n+    }\n+\n+    @Override\n+    public void start(Stage stage) {\n+\n+        final TextArea logArea = new TextArea();\n+        logArea.setEditable(false);\n+        Logging logger = new TextLogging(logArea);\n+\n+        ChoiceBox<Layout> layoutChoice = new ChoiceBox<>();\n+        layoutChoice.getItems().setAll(Layout.values());\n+        layoutChoice.setValue(Layout.US_ENGLISH);\n+\n+        ChoiceBox<CombinationScope> combinationChoice = new ChoiceBox<>();\n+        combinationChoice.getItems().setAll(CombinationScope.values());\n+        combinationChoice.setValue(CombinationScope.NONE);\n+\n+        Button testButton = new Button(\"Run test\");\n+        testButton.setOnAction(b -> {\n+            testButton.setDisable(true);\n+            Layout layout = layoutChoice.getValue();\n+            CombinationScope comboScope = combinationChoice.getValue();\n+            TestRunner testRunner = new TestRunner(layout, comboScope, logArea, logger);\n+            testRunner.start(() -> {\n+                testButton.setDisable(false);\n+                testButton.requestFocus();\n+            });\n+        });\n+\n+        HBox testControls = new HBox();\n+        testControls.setSpacing(5);\n+        testControls.getChildren().addAll(testButton, layoutChoice, combinationChoice);\n+\n+        VBox root = new VBox();\n+        root.setPadding(new Insets(5));\n+        root.setSpacing(5);\n+        VBox.setVgrow(logArea, Priority.ALWAYS);\n+        root.getChildren().addAll(testControls, logArea);\n+\n+        Scene scene = new Scene(root, 640, 640);\n+        stage.setScene(scene);\n+        stage.setTitle(\"Keyboard Test\");\n+        stage.show();\n+\n+        Platform.runLater(testButton::requestFocus);\n+    }\n+}\n","filename":"tests\/manual\/events\/KeyboardTest.java","additions":855,"deletions":0,"binary":false,"changes":855,"status":"added"}]}