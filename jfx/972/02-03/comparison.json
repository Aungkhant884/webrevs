{"files":[{"patch":"@@ -33,1 +33,0 @@\n-import java.util.Objects;\n@@ -45,7 +44,0 @@\n-    \/**\n-     * Sorts the given list in its natural order.\n-     *\n-     * @param <T> the element type\n-     * @param list a list to sort, cannot be {@code null}\n-     * @return an array with the permutations performed, never {@code null}\n-     *\/\n@@ -53,1 +45,0 @@\n-        @SuppressWarnings(\"unchecked\")\n@@ -70,8 +61,0 @@\n-    \/**\n-     * Sorts the given list according to the given comparator.\n-     *\n-     * @param <T> the element type\n-     * @param list a list to sort, cannot be {@code null}\n-     * @param c a comparator to use, cannot be {@code null}\n-     * @return an array with the permutations performed, never {@code null}\n-     *\/\n@@ -79,4 +62,3 @@\n-        @SuppressWarnings(\"unchecked\")\n-        T[] a = (T[]) list.toArray();\n-        int[] result = sort(a, c);\n-        ListIterator<T> i = list.listIterator();\n+        Object[] a = list.toArray();\n+        int[] result = sort(a, (Comparator)c);\n+        ListIterator i = list.listIterator();\n@@ -90,14 +72,18 @@\n-    \/**\n-     * Sorts the given array according to the given comparator.\n-     *\n-     * @param <T> the element type\n-     * @param a an array, cannot be {@code null}\n-     * @param fromIndex index of first element to sort, cannot be negative or larger than {@code toIndex}\n-     * @param toIndex index of last element to sort (exclusive), cannot be larger than the length of the array\n-     * @param c a comparator to use, cannot be {@code null}\n-     * @return an array with the permutations performed, never {@code null}\n-     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n-     * @throws ArrayIndexOutOfBoundsException\n-     *     if {@code fromIndex < 0} or {@code toIndex > a.length}\n-     *\/\n-    public <T> int[] sort(T[] a, int fromIndex, int toIndex, Comparator<? super T> c) {\n+    public <T extends Comparable<? super T>> int[] sort(T[] a) {\n+        return sort(a, null);\n+    }\n+\n+    public <T> int[] sort(T[] a, Comparator<? super T> c) {\n+        T[] aux = a.clone();\n+        int[] result = initPermutation(a.length);\n+        if (c==null)\n+            mergeSort(aux, a, 0, a.length, 0);\n+        else\n+            mergeSort(aux, a, 0, a.length, 0, c);\n+        reversePermutation = null;\n+        permutation = null;\n+        return result;\n+    }\n+\n+    public <T> int[] sort(T[] a, int fromIndex, int toIndex,\n+                Comparator<? super T> c) {\n@@ -107,1 +93,4 @@\n-        mergeSort(aux, a, fromIndex, toIndex, -fromIndex, Objects.requireNonNull(c, \"c\"));\n+        if (c==null)\n+            mergeSort(aux, a, fromIndex, toIndex, -fromIndex);\n+        else\n+            mergeSort(aux, a, fromIndex, toIndex, -fromIndex, c);\n@@ -113,11 +102,0 @@\n-    \/**\n-     * Sorts the given integers.\n-     *\n-     * @param a an int array, cannot be {@code null}\n-     * @param fromIndex index of first element to sort, cannot be negative or larger than {@code toIndex}\n-     * @param toIndex index of last element to sort (exclusive), cannot be larger than the length of the array\n-     * @return an array with the permutations performed, never {@code null}\n-     * @throws IllegalArgumentException if {@code fromIndex > toIndex}\n-     * @throws ArrayIndexOutOfBoundsException\n-     *     if {@code fromIndex < 0} or {@code toIndex > a.length}\n-     *\/\n@@ -134,13 +112,0 @@\n-    private <T extends Comparable<? super T>> int[] sort(T[] a) {\n-        return sort(a, Comparator.naturalOrder());\n-    }\n-\n-    private <T> int[] sort(T[] a, Comparator<? super T> c) {\n-        T[] aux = a.clone();\n-        int[] result = initPermutation(a.length);\n-        mergeSort(aux, a, 0, a.length, 0, Objects.requireNonNull(c));\n-        reversePermutation = null;\n-        permutation = null;\n-        return result;\n-    }\n-\n@@ -176,2 +141,0 @@\n-\n-        @SuppressWarnings(\"unchecked\")\n@@ -198,2 +161,3 @@\n-            for (int i = low; i < high; i++)\n-                for (int j = i; j > low && Integer.compare(dest[j - 1], dest[j]) > 0; j--)\n+            for (int i=low; i<high; i++)\n+                for (int j=i; j>low &&\n+                     ((Comparable) dest[j-1]).compareTo(dest[j])>0; j--)\n@@ -215,1 +179,1 @@\n-        if (Integer.compare(src[mid - 1], src[mid]) <= 0) {\n+        if (((Comparable)src[mid-1]).compareTo(src[mid]) <= 0) {\n@@ -222,1 +186,1 @@\n-            if (q >= high || p < mid && Integer.compare(src[p], src[q]) <= 0) {\n+            if (q >= high || p < mid && ((Comparable)src[p]).compareTo(src[q])<=0) {\n@@ -239,4 +203,5 @@\n-    private <T> void mergeSort(T[] src,\n-                  T[] dest,\n-                  int low, int high, int off,\n-                  Comparator<? super T> c) {\n+    private void mergeSort(Object[] src,\n+                  Object[] dest,\n+                  int low,\n+                  int high,\n+                  int off) {\n@@ -248,1 +213,2 @@\n-                for (int j=i; j>low && c.compare(dest[j-1], dest[j])>0; j--)\n+                for (int j=i; j>low &&\n+                     ((Comparable) dest[j-1]).compareTo(dest[j])>0; j--)\n@@ -255,0 +221,46 @@\n+        int destHigh = high;\n+        low  += off;\n+        high += off;\n+        int mid = (low + high) >>> 1;\n+        mergeSort(dest, src, low, mid, -off);\n+        mergeSort(dest, src, mid, high, -off);\n+\n+        \/\/ If list is already sorted, just copy from src to dest.  This is an\n+        \/\/ optimization that results in faster sorts for nearly ordered lists.\n+        if (((Comparable)src[mid-1]).compareTo(src[mid]) <= 0) {\n+            System.arraycopy(src, low, dest, destLow, length);\n+            return;\n+        }\n+\n+        \/\/ Merge sorted halves (now in src) into dest\n+        for(int i = destLow, p = low, q = mid; i < destHigh; i++) {\n+            if (q >= high || p < mid && ((Comparable)src[p]).compareTo(src[q])<=0) {\n+                dest[i] = src[p];\n+                permutation[reversePermutation[p++]] = i;\n+            } else {\n+                dest[i] = src[q];\n+                permutation[reversePermutation[q++]] = i;\n+            }\n+        }\n+\n+        for (int i = destLow; i < destHigh; ++i) {\n+            reversePermutation[permutation[i]] = i;\n+        }\n+    }\n+\n+    private void mergeSort(Object[] src,\n+                  Object[] dest,\n+                  int low, int high, int off,\n+                  Comparator c) {\n+        int length = high - low;\n+\n+        \/\/ Insertion sort on smallest arrays\n+        if (length < INSERTIONSORT_THRESHOLD) {\n+            for (int i=low; i<high; i++)\n+            for (int j=i; j>low && c.compare(dest[j-1], dest[j])>0; j--)\n+                swap(dest, j, j-1);\n+            return;\n+        }\n+\n+        \/\/ Recursively sort halves of dest into src\n+        int destLow  = low;\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/SortHelper.java","additions":83,"deletions":71,"binary":false,"changes":154,"status":"modified"}]}