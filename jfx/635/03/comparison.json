{"files":[{"patch":"@@ -34,0 +34,2 @@\n+#include <map>\n+\n@@ -37,0 +39,15 @@\n+\/\/ As the user types we query each key to determine which characters\n+\/\/ it can generate and stash them in a map. This map is used by\n+\/\/ getKeyCodeForChar.\n+static std::map<guint32, jint> unicode_to_java_keycode;\n+\/\/ If the user changes their layout (group) the map becomes invalid.\n+static gint unicode_to_java_keycode_group = -1;\n+\/\/ If the user adds or removes layouts from the list of input sources\n+\/\/ we need to invalidate the map. The group number is an index into\n+\/\/ that list so it's now pointing at a different layout.\n+static void on_keys_changed(GdkKeymap* k, void* user_data) {\n+    (void)k;\n+    (void)user_data;\n+    unicode_to_java_keycode.clear();\n+}\n+\n@@ -212,0 +229,1 @@\n+    glass_g_hash_table_insert_int(keymap, GLASS_GDK_KEY_CONSTANT(KP_Equal), com_sun_glass_events_KeyEvent_VK_EQUALS);\n@@ -227,0 +245,7 @@\n+\n+    \/\/ This signal is sent when the user changes the list of available layouts. It is not sent when they\n+    \/\/ switch from one layout to another.\n+    \/\/ The documented signal sent by most versions of Gtk.\n+    g_signal_connect(gdk_keymap_get_default(), \"keys-changed\", G_CALLBACK(on_keys_changed), nullptr);\n+    \/\/ The actual signal sent by the X11 version.\n+    g_signal_connect(gdk_keymap_get_default(), \"keys_changed\", G_CALLBACK(on_keys_changed), nullptr);\n@@ -269,0 +294,43 @@\n+    \/\/ If the user changed layouts since the last keystroke invalidate\n+    \/\/ the map.\n+    if (e->group != unicode_to_java_keycode_group) {\n+        unicode_to_java_keycode.clear();\n+        unicode_to_java_keycode_group = e->group;\n+    }\n+\n+    \/\/ Record all the Unicode characters that this key can generate.\n+    if (key != com_sun_glass_events_KeyEvent_VK_UNDEFINED)\n+    {\n+        GdkKeymapKey* keys = nullptr;\n+        guint* keyvals = nullptr;\n+        gint count = 0;\n+        if (gdk_keymap_get_entries_for_keycode(gdk_keymap_get_default(),\n+                e->hardware_keycode, &keys, &keyvals, &count))\n+        {\n+            gint search_group = e->group;\n+            \/\/ For keys that don't vary by group (e.g. Space or the keypad)\n+            \/\/ this call might return results on group 0 even if that's not\n+            \/\/ the current group.\n+            if (search_group != 0) {\n+                bool all_are_zero = true;\n+                for (gint i = 0; i < count; ++i) {\n+                    if (keys[i].group != 0) {\n+                        all_are_zero = false;\n+                        break;\n+                    }\n+                }\n+                if (all_are_zero)\n+                    search_group = 0;\n+            }\n+            for (gint i = 0; i < count; ++i) {\n+                if (keys[i].group == search_group) {\n+                    guint32 unicode = gdk_keyval_to_unicode(keyvals[i]);\n+                    if (unicode != 0)\n+                        unicode_to_java_keycode[unicode] = key;\n+                }\n+            }\n+        }\n+        g_free(keyvals);\n+        g_free(keys);\n+    }\n+\n@@ -319,0 +387,36 @@\n+\n+\/*\n+ * Function to determine whether the Xkb extention is available. This is a\n+ * precaution against X protocol errors, although it should be available on all\n+ * Linux systems.\n+ *\/\n+\n+static Bool xkbInitialized = False;\n+static Bool xkbAvailable = False;\n+\n+static Bool isXkbAvailable(Display *display) {\n+    if (!xkbInitialized) {\n+        int xkbMajor = XkbMajorVersion;\n+        int xkbMinor = XkbMinorVersion;\n+        xkbAvailable = XkbQueryExtension(display, NULL, NULL, NULL, &xkbMajor, &xkbMinor);\n+        xkbInitialized = True;\n+    }\n+    return xkbAvailable;\n+}\n+\n+\/*\n+ * Determine which keyboard layout is active. This is the group\n+ * number in the Xkb state. There is no direct way to query this\n+ * in Gdk.\n+ *\/\n+static gint get_current_keyboard_group()\n+{\n+    Display* display = gdk_x11_display_get_xdisplay(gdk_display_get_default());\n+    if (isXkbAvailable(display)) {\n+        XkbStateRec xkbState;\n+        XkbGetState(display, XkbUseCoreKbd, &xkbState);\n+        return xkbState.group;\n+    }\n+    return -1;\n+}\n+\n@@ -332,0 +436,5 @@\n+    \/\/ Query what we learned as the user was typing.\n+    auto f = unicode_to_java_keycode.find(character);\n+    if (f != unicode_to_java_keycode.end())\n+        return f->second;\n+\n@@ -346,8 +455,53 @@\n-    return gdk_keyval_to_glass(keyval);\n-}\n-\n-\/*\n- * Function to determine whether the Xkb extention is available. This is a\n- * precaution against X protocol errors, although it should be available on all\n- * Linux systems.\n- *\/\n+    \/\/ This call must return the same JavaFX key code that would be generated\n+    \/\/ if the user typed the character. get_glass_key assigns keycodes based\n+    \/\/ on the unshifted character on the key. To match that behavior determine\n+    \/\/ which key the the user would press and then query for the unshifted\n+    \/\/ character.\n+    gint current_group = get_current_keyboard_group();\n+    if (current_group < 0)\n+        return gdk_keyval_to_glass(keyval);\n+\n+    GdkKeymap* keymap = gdk_keymap_get_default();\n+    GdkKeymapKey* keys;\n+    gint count;\n+    if (!gdk_keymap_get_entries_for_keyval(keymap, keyval, &keys, &count))\n+        return gdk_keyval_to_glass(keyval);\n+\n+    GdkKeymapKey unshifted = {};\n+    unshifted.group = current_group;\n+    unshifted.level = 0; \/\/ No modifiers\n+\n+    \/\/ For some keyvals that are common across all layout (like Space) we\n+    \/\/ will get one result from group 0 even if it is not the current group.\n+    if (count == 1) {\n+        unshifted.keycode = keys[0].keycode;\n+        unshifted.group = keys[0].group;\n+    }\n+    else {\n+        \/\/ A keyval may appear on more than one key. For example, on a\n+        \/\/ French layout there's a dedicated dollar key but dollar can\n+        \/\/ also be generated using the top row digit 4 key with modifiers.\n+        \/\/ We choose the likeliest one, the one on the lowest level.\n+        int current_level = -1;\n+        for (gint i = 0; i < count; ++i) {\n+            if (keys[i].group == current_group) {\n+                if (current_level < 0 || keys[i].level < current_level) {\n+                    current_level = keys[i].level;\n+                    unshifted.keycode = keys[i].keycode;\n+                }\n+            }\n+        }\n+    }\n+    g_free(keys);\n+\n+    keyval = gdk_keymap_lookup_key(keymap, &unshifted);\n+    jint jKeyCode = gdk_keyval_to_glass(keyval);\n+    if (jKeyCode == com_sun_glass_events_KeyEvent_VK_UNDEFINED && unshifted.group != 0)\n+    {\n+        \/\/ get_glass_key assumes that if it can't find a Java key code the keyval must\n+        \/\/ be non-Latin and falls back to probing keyboard layout 0 assuming it will\n+        \/\/ yield a Latin result.\n+        unshifted.group = 0;\n+        keyval = gdk_keymap_lookup_key(keymap, &unshifted);\n+        jKeyCode = gdk_keyval_to_glass(keyval);\n+    }\n@@ -355,2 +509,2 @@\n-static Bool xkbInitialized = False;\n-static Bool xkbAvailable = False;\n+    \/\/ Update the map, there's no point in going through this search again.\n+    unicode_to_java_keycode[character] = jKeyCode;\n@@ -358,8 +512,1 @@\n-static Bool isXkbAvailable(Display *display) {\n-    if (!xkbInitialized) {\n-        int xkbMajor = XkbMajorVersion;\n-        int xkbMinor = XkbMinorVersion;\n-        xkbAvailable = XkbQueryExtension(display, NULL, NULL, NULL, &xkbMajor, &xkbMinor);\n-        xkbInitialized = True;\n-    }\n-    return xkbAvailable;\n+    return jKeyCode;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_key.cpp","additions":165,"deletions":18,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.scene.control.TextArea;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.KeyCombination;\n+import javafx.scene.input.KeyCharacterCombination;\n+import javafx.scene.input.KeyEvent;\n+import javafx.scene.Scene;\n+import javafx.stage.Stage;\n+\n+public class KeyCharacterCombinationTest extends Application {\n+    private final TextArea typingArea = new TextArea(\"\");\n+    private KeyEvent lastPressed = null;\n+\n+    public static void main(String[] args) {\n+        Application.launch(args);\n+    }\n+\n+    @Override\n+    public void start(Stage stage) {\n+        typingArea.setEditable(false);\n+        typingArea.appendText(\"Press keys that generate printable characters.\\n\");\n+        typingArea.appendText(\"Shifted punctuation keys are most likely to fail.\\n\\n\");\n+\n+        typingArea.addEventFilter(KeyEvent.KEY_PRESSED, this::pressedEvent);\n+        typingArea.addEventFilter(KeyEvent.KEY_RELEASED, this::releasedEvent);\n+        typingArea.addEventFilter(KeyEvent.KEY_TYPED, this::typedEvent);\n+\n+        Scene scene = new Scene(typingArea, 640, 640);\n+        stage.setScene(scene);\n+        stage.setTitle(\"Key Character Combinations\");\n+        stage.show();\n+\n+        Platform.runLater(typingArea::requestFocus);\n+    }\n+\n+    \/\/ Helper Methods for Event Handling\n+    private void passed(String str) {\n+        typingArea.appendText(\"Passed: \" + str + \"\\n\");\n+    }\n+\n+    private void failed(String str) {\n+        typingArea.appendText(\"* Failed: \" + str + \"\\n\");\n+    }\n+\n+    private void ignored(String str) {\n+        typingArea.appendText(\"Ignored: \" + str + \"\\n\");\n+    }\n+\n+    private void pressedEvent(KeyEvent e) {\n+        lastPressed = e;\n+    }\n+\n+    private void releasedEvent(KeyEvent e) {\n+        lastPressed = null;\n+    }\n+\n+    private KeyCombination.ModifierValue toModifier(boolean down)\n+    {\n+        if (down)\n+            return KeyCombination.ModifierValue.DOWN;\n+        return KeyCombination.ModifierValue.UP;\n+    }\n+\n+    private void typedEvent(KeyEvent e) {\n+        if (lastPressed == null)\n+            return;\n+\n+        \/\/ KeyCharacterCombinations only deal with one char at a time.\n+        if (e.getCharacter().length() == 0) {\n+            ignored(\"no text\");\n+            return;\n+        }\n+        if (e.getCharacter().length() > 1) {\n+            ignored(\"text too long\");\n+            return;\n+        }\n+\n+        \/\/ Keys that only generate characters with diacritics are not\n+        \/\/ assigned key codes and will not match any combination.\n+        if (lastPressed.getCode() == KeyCode.UNDEFINED) {\n+            ignored(\"undefined key code for \" + e.getCharacter());\n+            return;\n+        }\n+\n+        String keyCodeName = lastPressed.getCode().getName();\n+\n+        \/\/ Keys that generate control codes (like Tab and Delete) don't\n+        \/\/ work on some platforms. There are existing bugs on this which\n+        \/\/ will probably never be fixed since these keys should be\n+        \/\/ handled using KeyCodeCombinations instead.\n+        if (Character.isISOControl(e.getCharacter().charAt(0))) {\n+            ignored(\"control key\");\n+            return;\n+        }\n+\n+        \/\/ Keys on the numeric keypad will not match on Windows or Linux.\n+        \/\/ There are existing bug reports for this.\n+        if (lastPressed.getCode().isKeypadKey() ||\n+            lastPressed.getCode() == KeyCode.DIVIDE ||\n+            lastPressed.getCode() == KeyCode.MULTIPLY ||\n+            lastPressed.getCode() == KeyCode.ADD ||\n+            lastPressed.getCode() == KeyCode.SUBTRACT ||\n+            lastPressed.getCode() == KeyCode.DECIMAL) {\n+            ignored(\"keypad code \");\n+            return;\n+        }\n+\n+        \/\/ Construct a KeyCharacterCombination with the same modifiers and verify that it\n+        \/\/ matches the key press event. This tests the internal routine\n+        \/\/ Toolkit::getKeyCodeForChar.\n+        KeyCombination.ModifierValue shiftModifier = toModifier(lastPressed.isShiftDown());\n+        KeyCombination.ModifierValue controlModifier = toModifier(lastPressed.isControlDown());\n+        KeyCombination.ModifierValue altModifier = toModifier(lastPressed.isAltDown());\n+        KeyCombination.ModifierValue metaModifier = toModifier(lastPressed.isMetaDown());\n+        KeyCombination.ModifierValue shortcutModifier = toModifier(lastPressed.isShortcutDown());\n+\n+        KeyCharacterCombination combination = new KeyCharacterCombination(e.getCharacter(),\n+            shiftModifier, controlModifier, altModifier, metaModifier, shortcutModifier);\n+\n+        String combinationDescription = combination.getDisplayText();\n+        if (lastPressed.getCode().isWhitespaceKey())\n+        {\n+            \/\/ Replace 'invisible' characters with their names.\n+            if (!combinationDescription.isEmpty())\n+                combinationDescription = combinationDescription.substring(0, combinationDescription.length() - 1);\n+            combinationDescription += lastPressed.getCode().getName();\n+        }\n+\n+        if (combination.match(lastPressed))\n+            passed(\"key code \" + keyCodeName + \" matched \" + combinationDescription);\n+        else\n+            failed(\"key code \" + keyCodeName + \" did not match \" + combinationDescription);\n+    }\n+}\n","filename":"tests\/manual\/events\/KeyCharacterCombinationTest.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"}]}