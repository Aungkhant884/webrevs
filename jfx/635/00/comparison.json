{"files":[{"patch":"@@ -319,0 +319,36 @@\n+\n+\/*\n+ * Function to determine whether the Xkb extention is available. This is a\n+ * precaution against X protocol errors, although it should be available on all\n+ * Linux systems.\n+ *\/\n+\n+static Bool xkbInitialized = False;\n+static Bool xkbAvailable = False;\n+\n+static Bool isXkbAvailable(Display *display) {\n+    if (!xkbInitialized) {\n+        int xkbMajor = XkbMajorVersion;\n+        int xkbMinor = XkbMinorVersion;\n+        xkbAvailable = XkbQueryExtension(display, NULL, NULL, NULL, &xkbMajor, &xkbMinor);\n+        xkbInitialized = True;\n+    }\n+    return xkbAvailable;\n+}\n+\n+\/*\n+ * Determine which keyboard layout is active. This is the group\n+ * number in the Xkb state. There is no direct way to query this\n+ * in Gdk.\n+ *\/\n+static gint get_current_keyboard_group()\n+{\n+    Display* display = gdk_x11_display_get_xdisplay(gdk_display_get_default());\n+    if (isXkbAvailable(display)) {\n+        XkbStateRec xkbState;\n+        XkbGetState(display, XkbUseCoreKbd, &xkbState);\n+        return xkbState.group;\n+    }\n+    return -1;\n+}\n+\n@@ -346,18 +382,24 @@\n-    return gdk_keyval_to_glass(keyval);\n-}\n-\n-\/*\n- * Function to determine whether the Xkb extention is available. This is a\n- * precaution against X protocol errors, although it should be available on all\n- * Linux systems.\n- *\/\n-\n-static Bool xkbInitialized = False;\n-static Bool xkbAvailable = False;\n-\n-static Bool isXkbAvailable(Display *display) {\n-    if (!xkbInitialized) {\n-        int xkbMajor = XkbMajorVersion;\n-        int xkbMinor = XkbMinorVersion;\n-        xkbAvailable = XkbQueryExtension(display, NULL, NULL, NULL, &xkbMajor, &xkbMinor);\n-        xkbInitialized = True;\n+    \/\/ This call must return the same JavaFX key code that would be generated\n+    \/\/ if the user typed the character. get_glass_key assigns keycodes based\n+    \/\/ on the unshifted character on the key. To match that behavior determine\n+    \/\/ which key the the user would press and then query for the unshifted\n+    \/\/ character.\n+    gint current_group = get_current_keyboard_group();\n+    if (current_group < 0)\n+        return gdk_keyval_to_glass(keyval);\n+\n+    GdkKeymap* keymap = gdk_keymap_get_default();\n+    GdkKeymapKey* keys;\n+    gint count;\n+    if (!gdk_keymap_get_entries_for_keyval(keymap, keyval, &keys, &count))\n+        return gdk_keyval_to_glass(keyval);\n+\n+    GdkKeymapKey unshifted = {};\n+    unshifted.group = current_group;\n+    unshifted.level = 0; \/\/ No modifiers\n+\n+    \/\/ For some keyvals that are common across all layout (like Space) we\n+    \/\/ will get one result from group 0 even if it is not the current group.\n+    if (count == 1) {\n+        unshifted.keycode = keys[0].keycode;\n+        unshifted.group = keys[0].group;\n@@ -365,1 +407,22 @@\n-    return xkbAvailable;\n+    else {\n+        for (gint i = 0; i < count; ++i) {\n+            if (keys[i].group == current_group) {\n+                unshifted.keycode = keys[i].keycode;\n+                break;\n+            }\n+        }\n+    }\n+    g_free(keys);\n+\n+    keyval = gdk_keymap_lookup_key(keymap, &unshifted);\n+    jint jKeyCode = gdk_keyval_to_glass(keyval);\n+    if (jKeyCode == com_sun_glass_events_KeyEvent_VK_UNDEFINED && unshifted.group != 0)\n+    {\n+        \/\/ get_glass_key assumes that if it can't find a Java key code the keyval must\n+        \/\/ be non-Latin and falls back to probing keyboard layout 0 assuming it will\n+        \/\/ yield a Latin result.\n+        unshifted.group = 0;\n+        keyval = gdk_keymap_lookup_key(keymap, &unshifted);\n+        jKeyCode = gdk_keyval_to_glass(keyval);\n+    }\n+    return jKeyCode;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_key.cpp","additions":82,"deletions":19,"binary":false,"changes":101,"status":"modified"}]}