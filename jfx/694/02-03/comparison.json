{"files":[{"patch":"@@ -759,2 +759,0 @@\n-        \/\/ Platform classes can override this. Default implementation bridges to\n-        \/\/ existing code.\n@@ -769,2 +767,3 @@\n-     * character. Either the vkCode will be something other than VK_UNDEFINED\n-     * or the hardwareCode will be a positive number.\n+     * character. The call will be provided enough information to identify the\n+     * key, either a vkCode that is not VK_UNDEFINED or a hardwareCode that is\n+     * non-negative or both.\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/Application.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+            \/* Event was not consumed *\/\n@@ -973,0 +974,1 @@\n+    \/\/ Returns true iff event was consumed\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/View.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -518,1 +518,5 @@\n-    protected native int _getKeyCodeForChar(char c);\n+    protected int _getKeyCodeForChar(char c) {\n+        \/\/ Linux has transitioned to getKeyCanGenerateCharacter so this\n+        \/\/ should never be called.\n+        return 0;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkApplication.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -66,0 +66,3 @@\n+     *\n+     * @param keyEvent The key event\n+     * @return true iff the event was consumed\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/TKSceneListener.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2178,0 +2178,3 @@\n+    \/**\n+     * @return true iff the event was consumed\n+     *\/\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -322,3 +322,2 @@\n- * Class:     com_sun_glass_ui_gtk_GtkApplication\n- * Method:    _getKeyCodeForChar\n- * Signature: (C)I\n+ * The original getKeyCodeForChar implementation. Superseded\n+ * by getCanKeyGenerateCharacter.\n@@ -326,1 +325,1 @@\n-static jint internalGetKeyCodeForChar(jchar character)\n+static jint getKeyCodeForChar(jchar character)\n@@ -345,6 +344,0 @@\n-JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkApplication__1getKeyCodeForChar\n-  (JNIEnv *env, jobject jApplication, jchar character)\n-{\n-    return internalGetKeyCodeForChar(character);\n-}\n-\n@@ -426,0 +419,25 @@\n+static bool vkCodeIsNumericKeypad(jint vkCode)\n+{\n+    switch (vkCode) {\n+        case com_sun_glass_events_KeyEvent_VK_NUMPAD0:\n+        case com_sun_glass_events_KeyEvent_VK_NUMPAD1:\n+        case com_sun_glass_events_KeyEvent_VK_NUMPAD2:\n+        case com_sun_glass_events_KeyEvent_VK_NUMPAD3:\n+        case com_sun_glass_events_KeyEvent_VK_NUMPAD4:\n+        case com_sun_glass_events_KeyEvent_VK_NUMPAD5:\n+        case com_sun_glass_events_KeyEvent_VK_NUMPAD6:\n+        case com_sun_glass_events_KeyEvent_VK_NUMPAD7:\n+        case com_sun_glass_events_KeyEvent_VK_NUMPAD8:\n+        case com_sun_glass_events_KeyEvent_VK_NUMPAD9:\n+        case com_sun_glass_events_KeyEvent_VK_DIVIDE:\n+        case com_sun_glass_events_KeyEvent_VK_MULTIPLY:\n+        case com_sun_glass_events_KeyEvent_VK_SUBTRACT:\n+        case com_sun_glass_events_KeyEvent_VK_ADD:\n+        case com_sun_glass_events_KeyEvent_VK_DECIMAL:\n+        case com_sun_glass_events_KeyEvent_VK_SEPARATOR:\n+            return true;\n+        default:\n+            return false;\n+    }\n+}\n+\n@@ -433,3 +451,8 @@\n-        if (vkCode != com_sun_glass_events_KeyEvent_VK_UNDEFINED)\n-            return vkCode == internalGetKeyCodeForChar(character);\n-        return false;\n+        \/*\n+         * This key event didn't originate from this platform code (someone\n+         * constructed a KeyEvent from whole cloth). Use the old code.\n+         *\/\n+        if (vkCode != com_sun_glass_events_KeyEvent_VK_UNDEFINED) {\n+            return vkCode == getKeyCodeForChar(character);\n+        }\n+        return FALSE;\n@@ -439,24 +462,31 @@\n-    if (currentGroup < 0)\n-        return false;\n-\n-    GdkKeymapKey* keys = nullptr;\n-    guint* keyvals = nullptr;\n-    gint count = 0;\n-    bool result = false;\n-\n-    if (gdk_keymap_get_entries_for_keycode(gdk_keymap_get_default(), hardwareCode,\n-                                           &keys, &keyvals, &count))\n-    {\n-        \/\/ For fixed-function keys (e.g Space or the keypad) we can get entries\n-        \/\/ for group 0 even if that's not the current group.\n-        gint searchGroup = currentGroup;\n-        if (searchGroup != 0) {\n-            bool allAreZero = true;\n-            for (gint i = 0; i < count; ++i) {\n-                if (keys[i].group != 0) {\n-                    allAreZero = false;\n-                    break;\n-                }\n-            }\n-            if (allAreZero)\n-                searchGroup = 0;\n+    if (currentGroup < 0) {\n+        return FALSE;\n+    }\n+\n+    \/*\n+     * Walk through modifier states looking for the character.\n+     *\/\n+    static const GdkModifierType standardModifiers[] = {\n+        (GdkModifierType) 0,\n+        GDK_SHIFT_MASK,\n+        GDK_MOD5_MASK, \/\/ AltGr\n+        (GdkModifierType) ((int) GDK_MOD5_MASK | (int) GDK_SHIFT_MASK)\n+    };\n+    static const GdkModifierType keypadModifiers[] = {\n+        GDK_MOD2_MASK\n+    };\n+\n+    int numModifiers = 4;\n+    const GdkModifierType* modifierArray = standardModifiers;\n+    if (vkCodeIsNumericKeypad(vkCode)) {\n+        numModifiers = 1;\n+        modifierArray = keypadModifiers;\n+    }\n+\n+    GdkKeymap* keymap = gdk_keymap_get_for_display(gdk_display_get_default());\n+    for (int i = 0; i < numModifiers; ++i) {\n+        guint keyValue = 0;\n+        if (!gdk_keymap_translate_keyboard_state(keymap, hardwareCode, modifierArray[i],\n+                                                 currentGroup, &keyValue, NULL, NULL, NULL)) {\n+            \/\/ Failure at this modifier level means we'll fail at higher levels.\n+            return FALSE;\n@@ -464,7 +494,4 @@\n-        for (gint i = 0; i < count; ++i) {\n-            if (keys[i].group == searchGroup) {\n-                guint32 unicode = gdk_keyval_to_unicode(keyvals[i]);\n-                if (unicode && unicode == character) {\n-                    result = true;\n-                    break;\n-                }\n+        if (keyValue != 0) {\n+            guint32 unicode = gdk_keyval_to_unicode(keyValue);\n+            if (unicode == character) {\n+                return TRUE;\n@@ -474,3 +501,2 @@\n-    g_free(keys);\n-    g_free(keyvals);\n-    return result;\n+\n+    return FALSE;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_key.cpp","additions":73,"deletions":47,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -104,7 +104,0 @@\n-        \/\/ Keys that only generate characters with diacritics are not\n-        \/\/ assigned key codes and will not match any combination.\n-        if (lastPressed.getCode() == KeyCode.UNDEFINED) {\n-            ignored(\"undefined key code for \" + e.getCharacter());\n-            return;\n-        }\n-\n@@ -122,12 +115,0 @@\n-        \/\/ Keys on the numeric keypad will not match on Windows or Linux.\n-        \/\/ There are existing bug reports for this.\n-        if (lastPressed.getCode().isKeypadKey() ||\n-            lastPressed.getCode() == KeyCode.DIVIDE ||\n-            lastPressed.getCode() == KeyCode.MULTIPLY ||\n-            lastPressed.getCode() == KeyCode.ADD ||\n-            lastPressed.getCode() == KeyCode.SUBTRACT ||\n-            lastPressed.getCode() == KeyCode.DECIMAL) {\n-            ignored(\"keypad code \");\n-            return;\n-        }\n-\n","filename":"tests\/manual\/events\/KeyCharacterCombinationTest.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"}]}