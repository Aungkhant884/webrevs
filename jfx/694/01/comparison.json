{"files":[{"patch":"@@ -753,0 +753,27 @@\n+    \/**\n+     * The default implementation bridges to the existing getKeyCodeForChar call. Platform\n+     * instances are expected to override this call.\n+     *\/\n+    protected boolean _getKeyCanGenerateCharacter(int hardwareCode, int vkCode, char c) {\n+        \/\/ Platform classes can override this. Default implementation bridges to\n+        \/\/ existing code.\n+        if (vkCode != com.sun.glass.events.KeyEvent.VK_UNDEFINED) {\n+            return getKeyCodeForChar(c) == vkCode;\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns true if the key is capable of producing the given Unicode\n+     * character. Either the vkCode will be something other than VK_UNDEFINED\n+     * or the hardwareCode will be a positive number.\n+     *\n+     * @param hardwareCode the platform-specific key identifier\n+     * @param vkCode the JavaFX key code\n+     * @param c the character\n+     * @return true if the key can generate the character\n+     *\/\n+    public final boolean getKeyCanGenerateCharacter(int hardwareCode, int vkCode, char c) {\n+        return _getKeyCanGenerateCharacter(hardwareCode, vkCode, c);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/Application.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -68,2 +68,4 @@\n-        public void handleKeyEvent(View view, long time, int action,\n-                int keyCode, char[] keyChars, int modifiers) {\n+        public boolean handleKeyEvent(View view, long time, int action,\n+                int keyCode, char[] keyChars, int modifiers, int hardwareCode)\n+        {\n+            return false;\n@@ -539,2 +541,2 @@\n-    private void handleKeyEvent(long time, int action,\n-            int keyCode, char[] keyChars, int modifiers) {\n+    private boolean handleKeyEvent(long time, int action,\n+            int keyCode, char[] keyChars, int modifiers, int hardwareCode) {\n@@ -542,1 +544,2 @@\n-            this.eventHandler.handleKeyEvent(this, time, action, keyCode, keyChars, modifiers);\n+            return this.eventHandler.handleKeyEvent(this, time, action, keyCode,\n+                                                    keyChars, modifiers, hardwareCode);\n@@ -544,0 +547,1 @@\n+        return false;\n@@ -966,1 +970,5 @@\n-        handleKeyEvent(System.nanoTime(), type, keyCode, keyChars, modifiers);\n+        handleKeyEvent(System.nanoTime(), type, keyCode, keyChars, modifiers, -1);\n+    }\n+\n+    protected boolean notifyKeyEx(int type, int keyCode, char[] keyChars, int modifiers, int hardwareCode) {\n+        return handleKeyEvent(System.nanoTime(), type, keyCode, keyChars, modifiers, hardwareCode);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/View.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -489,0 +489,3 @@\n+    @Override\n+    protected native boolean _getKeyCanGenerateCharacter(int hardwareCode, int vkCode, char c);\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkApplication.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,2 +57,2 @@\n-    public static void processKeyEvent(Scene scene, KeyEvent e) {\n-        sceneAccessor.processKeyEvent(scene, e);\n+    public static boolean processKeyEvent(Scene scene, KeyEvent e) {\n+        return sceneAccessor.processKeyEvent(scene, e);\n@@ -122,1 +122,1 @@\n-        void processKeyEvent(Scene scene, KeyEvent e);\n+        boolean processKeyEvent(Scene scene, KeyEvent e);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/SceneHelper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene.input;\n+\n+import com.sun.javafx.util.Utils;\n+import javafx.scene.input.KeyEvent;\n+\n+\/**\n+ * Used to access internal methods of KeyEvent.\n+ *\/\n+public class KeyEventHelper {\n+\n+    private static KeyEventAccessor keyEventAccessor;\n+\n+    static {\n+        Utils.forceInit(KeyEvent.class);\n+    }\n+\n+    private KeyEventHelper() {\n+    }\n+\n+    public static void setHardwareCode(KeyEvent keyEvent, int hardwareCode) {\n+        keyEventAccessor.setHardwareCode(keyEvent, hardwareCode);\n+    }\n+\n+    public static int getHardwareCode(KeyEvent keyEvent) {\n+        return keyEventAccessor.getHardwareCode(keyEvent);\n+    }\n+\n+    public static void setKeyEventAccessor(final KeyEventAccessor newAccessor) {\n+        if (keyEventAccessor != null) {\n+            throw new IllegalStateException();\n+        }\n+\n+        keyEventAccessor = newAccessor;\n+    }\n+\n+    public interface KeyEventAccessor {\n+        void setHardwareCode(KeyEvent keyEvent, int hardwareCode);\n+        int getHardwareCode(KeyEvent keyEvent);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/input\/KeyEventHelper.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -67,1 +67,1 @@\n-    public void keyEvent(KeyEvent keyEvent);\n+    public boolean keyEvent(KeyEvent keyEvent);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/TKSceneListener.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -710,0 +710,9 @@\n+    \/**\n+     * The default implementation bridges into the existing getKeyCodeForChar call.\n+     *\/\n+    public boolean getKeyCanGenerateCharacter(KeyEvent event, String character) {\n+        if (event.getCode() != KeyCode.UNDEFINED) {\n+            return getKeyCodeForChar(character) == event.getCode().getCode();\n+        }\n+        return false;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/Toolkit.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import com.sun.javafx.scene.input.KeyEventHelper;\n@@ -150,1 +151,1 @@\n-    private class KeyEventNotification implements PrivilegedAction<Void> {\n+    private class KeyEventNotification implements PrivilegedAction<Boolean> {\n@@ -157,0 +158,1 @@\n+        int hardwareCode;\n@@ -161,1 +163,1 @@\n-        public Void run() {\n+        public Boolean run() {\n@@ -166,0 +168,2 @@\n+            Boolean consumed = Boolean.FALSE;\n+\n@@ -180,0 +184,1 @@\n+                KeyEventHelper.setHardwareCode(keyEvent, hardwareCode);\n@@ -218,1 +223,2 @@\n-                            scene.sceneListener.keyEvent(keyEvent);\n+                            if (scene.sceneListener.keyEvent(keyEvent))\n+                                consumed = Boolean.TRUE;\n@@ -234,1 +240,1 @@\n-            return null;\n+            return consumed;\n@@ -239,2 +245,2 @@\n-    @Override public void handleKeyEvent(View view, long time, int type, int key,\n-                                         char[] chars, int modifiers)\n+    @Override public boolean handleKeyEvent(View view, long time, int type, int key,\n+                                            char[] chars, int modifiers, int hardwareCode)\n@@ -248,0 +254,1 @@\n+        keyNotification.hardwareCode = hardwareCode;\n@@ -249,1 +256,1 @@\n-        QuantumToolkit.runWithoutRenderLock(() -> {\n+        return QuantumToolkit.runWithoutRenderLock(() -> {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/GlassViewEventHandler.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+import com.sun.javafx.scene.input.KeyEventHelper;\n@@ -1070,0 +1071,14 @@\n+    \/\/ The Quantum version of this call knows that we may have the hardware key code\n+    \/\/ available.\n+    @Override public boolean getKeyCanGenerateCharacter(KeyEvent keyEvent, String character) {\n+        int hardwareCode = KeyEventHelper.getHardwareCode(keyEvent);\n+        if (keyEvent.getCode() != KeyCode.UNDEFINED || hardwareCode != -1) {\n+            if (character.length() == 1)\n+                return Application.GetApplication().getKeyCanGenerateCharacter(\n+                    hardwareCode,\n+                    keyEvent.getCode().getCode(),\n+                    character.charAt(0));\n+        }\n+        return false;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/QuantumToolkit.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import com.sun.javafx.event.EventUtil;\n@@ -385,2 +386,2 @@\n-                        public void processKeyEvent(Scene scene, KeyEvent e) {\n-                            scene.processKeyEvent(e);\n+                        public boolean processKeyEvent(Scene scene, KeyEvent e) {\n+                            return scene.processKeyEvent(e);\n@@ -2139,1 +2140,1 @@\n-    void processKeyEvent(KeyEvent e) {\n+    boolean processKeyEvent(KeyEvent e) {\n@@ -2146,1 +2147,1 @@\n-        getKeyHandler().process(e);\n+        return getKeyHandler().process(e);\n@@ -2612,1 +2613,1 @@\n-        public void keyEvent(KeyEvent keyEvent)\n+        public boolean keyEvent(KeyEvent keyEvent)\n@@ -2614,1 +2615,1 @@\n-            processKeyEvent(keyEvent);\n+            return processKeyEvent(keyEvent);\n@@ -4081,1 +4082,1 @@\n-        private void process(KeyEvent e) {\n+        private boolean process(KeyEvent e) {\n@@ -4089,1 +4090,1 @@\n-            Event.fireEvent(eventTarget, e);\n+            return EventUtil.fireEvent(eventTarget, e) == null;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -112,6 +112,2 @@\n-        if (event.getCode() == KeyCode.UNDEFINED) {\n-            return false;\n-        }\n-        return (event.getCode().getCode()\n-                       == Toolkit.getToolkit().getKeyCodeForChar(getCharacter()))\n-                   && super.match(event);\n+        return (super.match(event) &&\n+                Toolkit.getToolkit().getKeyCanGenerateCharacter(event, getCharacter()));\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/input\/KeyCharacterCombination.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import com.sun.javafx.scene.input.KeyEventHelper;\n+\n@@ -35,2 +37,0 @@\n-import javafx.scene.input.ScrollEvent.HorizontalTextScrollUnits;\n-import javafx.scene.input.ScrollEvent.VerticalTextScrollUnits;\n@@ -142,0 +142,1 @@\n+        this.hardwareCode = -1;\n@@ -170,0 +171,1 @@\n+        this.hardwareCode = -1;\n@@ -386,0 +388,4 @@\n+    \/**\n+     * The hardware key code which is private to the implementation.\n+     *\/\n+    private int hardwareCode;\n@@ -387,0 +393,3 @@\n+    int getHardwareCode() {\n+        return hardwareCode;\n+    }\n@@ -388,0 +397,19 @@\n+    void setHardwareCode(int newCode) {\n+        hardwareCode = newCode;\n+    }\n+\n+    static {\n+        KeyEventHelper.setKeyEventAccessor(\n+            new KeyEventHelper.KeyEventAccessor() {\n+                @Override\n+                public void setHardwareCode(KeyEvent keyEvent, int hardwareCode) {\n+                    keyEvent.setHardwareCode(hardwareCode);\n+                }\n+\n+                @Override\n+                public int getHardwareCode(KeyEvent keyEvent) {\n+                    return keyEvent.getHardwareCode();\n+                }\n+            }\n+        );\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/input\/KeyEvent.java","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-jmethodID jViewNotifyKey;\n+jmethodID jViewNotifyKeyEx;\n@@ -199,1 +199,1 @@\n-    jViewNotifyKey = env->GetMethodID(clazz, \"notifyKey\", \"(II[CI)V\");\n+    jViewNotifyKeyEx = env->GetMethodID(clazz, \"notifyKeyEx\", \"(II[CII)Z\");\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-    extern jmethodID jViewNotifyKey; \/\/ com.sun.glass.ui.View#notifyKey (II[CI)V\n+    extern jmethodID jViewNotifyKeyEx; \/\/ com.sun.glass.ui.View#notifyKeyEx (II[CII)Z\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -326,2 +326,1 @@\n-JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkApplication__1getKeyCodeForChar\n-  (JNIEnv *env, jobject jApplication, jchar character)\n+static jint internalGetKeyCodeForChar(jchar character)\n@@ -329,3 +328,0 @@\n-    (void)env;\n-    (void)jApplication;\n-\n@@ -349,0 +345,6 @@\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_GtkApplication__1getKeyCodeForChar\n+  (JNIEnv *env, jobject jApplication, jchar character)\n+{\n+    return internalGetKeyCodeForChar(character);\n+}\n+\n@@ -368,0 +370,16 @@\n+\/*\n+  * Determine which keyboard layout is active. This is the group\n+  * number in the Xkb state. There is no direct way to query this\n+  * in Gdk.\n+  *\/\n+ static gint get_current_keyboard_group()\n+ {\n+     Display* display = gdk_x11_display_get_xdisplay(gdk_display_get_default());\n+     if (isXkbAvailable(display)) {\n+         XkbStateRec xkbState;\n+         XkbGetState(display, XkbUseCoreKbd, &xkbState);\n+         return xkbState.group;\n+     }\n+     return -1;\n+ }\n+\n@@ -408,0 +426,53 @@\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkApplication__1getKeyCanGenerateCharacter\n+  (JNIEnv *env, jobject jApplication, jint hardwareCode, jint vkCode, jchar character)\n+{\n+    (void)env;\n+    (void)jApplication;\n+\n+    if (hardwareCode < 0) {\n+        if (vkCode != com_sun_glass_events_KeyEvent_VK_UNDEFINED)\n+            return vkCode == internalGetKeyCodeForChar(character);\n+        return false;\n+    }\n+\n+    gint currentGroup = get_current_keyboard_group();\n+    if (currentGroup < 0)\n+        return false;\n+\n+    GdkKeymapKey* keys = nullptr;\n+    guint* keyvals = nullptr;\n+    gint count = 0;\n+    bool result = false;\n+\n+    if (gdk_keymap_get_entries_for_keycode(gdk_keymap_get_default(), hardwareCode,\n+                                           &keys, &keyvals, &count))\n+    {\n+        \/\/ For fixed-function keys (e.g Space or the keypad) we can get entries\n+        \/\/ for group 0 even if that's not the current group.\n+        gint searchGroup = currentGroup;\n+        if (searchGroup != 0) {\n+            bool allAreZero = true;\n+            for (gint i = 0; i < count; ++i) {\n+                if (keys[i].group != 0) {\n+                    allAreZero = false;\n+                    break;\n+                }\n+            }\n+            if (allAreZero)\n+                searchGroup = 0;\n+        }\n+        for (gint i = 0; i < count; ++i) {\n+            if (keys[i].group == searchGroup) {\n+                guint32 unicode = gdk_keyval_to_unicode(keyvals[i]);\n+                if (unicode && unicode == character) {\n+                    result = true;\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    g_free(keys);\n+    g_free(keyvals);\n+    return result;\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_key.cpp","additions":76,"deletions":5,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -490,1 +490,1 @@\n-            mainEnv->CallVoidMethod(jview, jViewNotifyKey,\n+            mainEnv->CallBooleanMethod(jview, jViewNotifyKeyEx,\n@@ -494,1 +494,2 @@\n-                    glassModifier);\n+                    glassModifier,\n+                    event->hardware_keycode);\n@@ -498,1 +499,1 @@\n-                mainEnv->CallVoidMethod(jview, jViewNotifyKey,\n+                mainEnv->CallBooleanMethod(jview, jViewNotifyKeyEx,\n@@ -502,1 +503,2 @@\n-                        glassModifier);\n+                        glassModifier,\n+                        event->hardware_keycode);\n@@ -506,1 +508,1 @@\n-            mainEnv->CallVoidMethod(jview, jViewNotifyKey,\n+            mainEnv->CallVoidMethod(jview, jViewNotifyKeyEx,\n@@ -510,1 +512,2 @@\n-                    glassModifier);\n+                    glassModifier,\n+                    event->hardware_keycode);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.scene.control.TextArea;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.KeyCombination;\n+import javafx.scene.input.KeyCharacterCombination;\n+import javafx.scene.input.KeyEvent;\n+import javafx.scene.Scene;\n+import javafx.stage.Stage;\n+\n+public class KeyCharacterCombinationTest extends Application {\n+    private final TextArea typingArea = new TextArea(\"\");\n+    private KeyEvent lastPressed = null;\n+\n+    public static void main(String[] args) {\n+        Application.launch(args);\n+    }\n+\n+    @Override\n+    public void start(Stage stage) {\n+        typingArea.setEditable(false);\n+        typingArea.appendText(\"Press keys that generate printable characters.\\n\");\n+        typingArea.appendText(\"Shifted punctuation keys are most likely to fail.\\n\\n\");\n+\n+        typingArea.addEventFilter(KeyEvent.KEY_PRESSED, this::pressedEvent);\n+        typingArea.addEventFilter(KeyEvent.KEY_RELEASED, this::releasedEvent);\n+        typingArea.addEventFilter(KeyEvent.KEY_TYPED, this::typedEvent);\n+\n+        Scene scene = new Scene(typingArea, 640, 640);\n+        stage.setScene(scene);\n+        stage.setTitle(\"Key Character Combinations\");\n+        stage.show();\n+\n+        Platform.runLater(typingArea::requestFocus);\n+    }\n+\n+    \/\/ Helper Methods for Event Handling\n+    private void passed(String str) {\n+        typingArea.appendText(\"Passed: \" + str + \"\\n\");\n+    }\n+\n+    private void failed(String str) {\n+        typingArea.appendText(\"* Failed: \" + str + \"\\n\");\n+    }\n+\n+    private void ignored(String str) {\n+        typingArea.appendText(\"Ignored: \" + str + \"\\n\");\n+    }\n+\n+    private void pressedEvent(KeyEvent e) {\n+        lastPressed = e;\n+    }\n+\n+    private void releasedEvent(KeyEvent e) {\n+        lastPressed = null;\n+    }\n+\n+    private KeyCombination.ModifierValue toModifier(boolean down)\n+    {\n+        if (down)\n+            return KeyCombination.ModifierValue.DOWN;\n+        return KeyCombination.ModifierValue.UP;\n+    }\n+\n+    private void typedEvent(KeyEvent e) {\n+        if (lastPressed == null)\n+            return;\n+\n+        \/\/ KeyCharacterCombinations only deal with one char at a time.\n+        if (e.getCharacter().length() == 0) {\n+            ignored(\"no text\");\n+            return;\n+        }\n+        if (e.getCharacter().length() > 1) {\n+            ignored(\"text too long\");\n+            return;\n+        }\n+\n+        \/\/ Keys that only generate characters with diacritics are not\n+        \/\/ assigned key codes and will not match any combination.\n+        if (lastPressed.getCode() == KeyCode.UNDEFINED) {\n+            ignored(\"undefined key code for \" + e.getCharacter());\n+            return;\n+        }\n+\n+        String keyCodeName = lastPressed.getCode().getName();\n+\n+        \/\/ Keys that generate control codes (like Tab and Delete) don't\n+        \/\/ work on some platforms. There are existing bugs on this which\n+        \/\/ will probably never be fixed since these keys should be\n+        \/\/ handled using KeyCodeCombinations instead.\n+        if (Character.isISOControl(e.getCharacter().charAt(0))) {\n+            ignored(\"control key\");\n+            return;\n+        }\n+\n+        \/\/ Keys on the numeric keypad will not match on Windows or Linux.\n+        \/\/ There are existing bug reports for this.\n+        if (lastPressed.getCode().isKeypadKey() ||\n+            lastPressed.getCode() == KeyCode.DIVIDE ||\n+            lastPressed.getCode() == KeyCode.MULTIPLY ||\n+            lastPressed.getCode() == KeyCode.ADD ||\n+            lastPressed.getCode() == KeyCode.SUBTRACT ||\n+            lastPressed.getCode() == KeyCode.DECIMAL) {\n+            ignored(\"keypad code \");\n+            return;\n+        }\n+\n+        \/\/ Construct a KeyCharacterCombination with the same modifiers and verify that it\n+        \/\/ matches the key press event. This tests the internal routine\n+        \/\/ Toolkit::getKeyCodeForChar.\n+        KeyCombination.ModifierValue shiftModifier = toModifier(lastPressed.isShiftDown());\n+        KeyCombination.ModifierValue controlModifier = toModifier(lastPressed.isControlDown());\n+        KeyCombination.ModifierValue altModifier = toModifier(lastPressed.isAltDown());\n+        KeyCombination.ModifierValue metaModifier = toModifier(lastPressed.isMetaDown());\n+        KeyCombination.ModifierValue shortcutModifier = toModifier(lastPressed.isShortcutDown());\n+\n+        KeyCharacterCombination combination = new KeyCharacterCombination(e.getCharacter(),\n+            shiftModifier, controlModifier, altModifier, metaModifier, shortcutModifier);\n+\n+        String combinationDescription = combination.getDisplayText();\n+        if (lastPressed.getCode().isWhitespaceKey())\n+        {\n+            \/\/ Replace 'invisible' characters with their names.\n+            if (!combinationDescription.isEmpty())\n+                combinationDescription = combinationDescription.substring(0, combinationDescription.length() - 1);\n+            combinationDescription += lastPressed.getCode().getName();\n+        }\n+\n+        if (combination.match(lastPressed))\n+            passed(\"key code \" + keyCodeName + \" matched \" + combinationDescription);\n+        else\n+            failed(\"key code \" + keyCodeName + \" did not match \" + combinationDescription);\n+    }\n+}\n","filename":"tests\/manual\/events\/KeyCharacterCombinationTest.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"}]}