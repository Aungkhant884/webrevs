{"files":[{"patch":"@@ -150,0 +150,1 @@\n+        \"-framework\", \"Carbon\",\n","filename":"buildSrc\/mac.gradle","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#import <Carbon\/Carbon.h>\n+\n@@ -181,0 +183,140 @@\n+static BOOL macKeyCodeIsLayoutSensitive(unsigned int keyCode)\n+{\n+    \/\/ Mac key codes that generate different characters based on the keyboard layout\n+    \/\/ lie in two ranges with a few exceptions. For the purpose of Java key code\n+    \/\/ mapping we pretend that the top row of number keys always produce digits even\n+    \/\/ though that is not true on some keyboards e.g. French. This matches the behavior\n+    \/\/ of JavaFX on Windows and the historical behavior of JavaFX on Mac.\n+    switch (keyCode)\n+    {\n+        case 0x12: \/\/ 1\n+        case 0x13: \/\/ 2\n+        case 0x14: \/\/ 3\n+        case 0x15: \/\/ 4\n+        case 0x17: \/\/ 5\n+        case 0x16: \/\/ 6\n+        case 0x1A: \/\/ 7\n+        case 0x1C: \/\/ 8\n+        case 0x19: \/\/ 9\n+        case 0x1D: \/\/ 0\n+        case 0x24: \/\/ Enter\n+        case 0x30: \/\/ Tab\n+        case 0x31: \/\/ Space\n+            return NO;\n+    }\n+\n+    if (keyCode >= 0x00 && keyCode <= 0x32)\n+        return YES;\n+\n+    if (keyCode >= 0x5D && keyCode <= 0x5F)\n+        return YES;\n+\n+    return NO;\n+}\n+\n+static jint getJavaCodeForASCII(UniChar ascii)\n+{\n+    if (ascii >= L'0' && ascii <= L'9')\n+        return ascii;\n+    if (ascii >= L'a' && ascii <= L'z')\n+        return ascii + (L'A' - L'a');\n+    if (ascii >= L'A' && ascii <= L'Z')\n+        return ascii;\n+\n+    switch (ascii)\n+    {\n+        case L' ': return com_sun_glass_events_KeyEvent_VK_SPACE;\n+        case L'!': return com_sun_glass_events_KeyEvent_VK_EXCLAMATION;\n+        case L'\"': return com_sun_glass_events_KeyEvent_VK_DOUBLE_QUOTE;\n+        case L'#': return com_sun_glass_events_KeyEvent_VK_NUMBER_SIGN;\n+        case L'$': return com_sun_glass_events_KeyEvent_VK_DOLLAR;\n+        case L'&': return com_sun_glass_events_KeyEvent_VK_AMPERSAND;\n+        case L'\\'':return com_sun_glass_events_KeyEvent_VK_QUOTE;\n+        case L'(': return com_sun_glass_events_KeyEvent_VK_LEFT_PARENTHESIS;\n+        case L')': return com_sun_glass_events_KeyEvent_VK_RIGHT_PARENTHESIS;\n+        case L'*': return com_sun_glass_events_KeyEvent_VK_ASTERISK;\n+        case L'+': return com_sun_glass_events_KeyEvent_VK_PLUS;\n+        case L',': return com_sun_glass_events_KeyEvent_VK_COMMA;\n+        case L'-': return com_sun_glass_events_KeyEvent_VK_MINUS;\n+        case L'.': return com_sun_glass_events_KeyEvent_VK_PERIOD;\n+        case L'\/': return com_sun_glass_events_KeyEvent_VK_SLASH;\n+        case L':': return com_sun_glass_events_KeyEvent_VK_COLON;\n+        case L';': return com_sun_glass_events_KeyEvent_VK_SEMICOLON;\n+        case L'<': return com_sun_glass_events_KeyEvent_VK_LESS;\n+        case L'=': return com_sun_glass_events_KeyEvent_VK_EQUALS;\n+        case L'>': return com_sun_glass_events_KeyEvent_VK_GREATER;\n+        case L'@': return com_sun_glass_events_KeyEvent_VK_AT;\n+        case L'[': return com_sun_glass_events_KeyEvent_VK_OPEN_BRACKET;\n+        case L'\\\\':return com_sun_glass_events_KeyEvent_VK_BACK_SLASH;\n+        case L']': return com_sun_glass_events_KeyEvent_VK_CLOSE_BRACKET;\n+        case L'^': return com_sun_glass_events_KeyEvent_VK_CIRCUMFLEX;\n+        case L'_': return com_sun_glass_events_KeyEvent_VK_UNDERSCORE;\n+        case L'`': return com_sun_glass_events_KeyEvent_VK_BACK_QUOTE;\n+        case L'{': return com_sun_glass_events_KeyEvent_VK_BRACELEFT;\n+        case L'}': return com_sun_glass_events_KeyEvent_VK_BRACERIGHT;\n+    }\n+\n+    return com_sun_glass_events_KeyEvent_VK_UNDEFINED;\n+};\n+\n+static UniCharCount queryKeyboard(TISInputSourceRef keyboard, unsigned short keyCode,\n+                                  BOOL shifted, BOOL forAccelerator,\n+                                  UniChar* buffer, UniCharCount bufferSize)\n+{\n+    CFDataRef uchr = (CFDataRef)TISGetInputSourceProperty(keyboard,\n+                                                          kTISPropertyUnicodeKeyLayoutData);\n+    if (uchr == NULL)\n+        return 0;\n+    const UCKeyboardLayout *layout = (const UCKeyboardLayout*)CFDataGetBytePtr(uchr);\n+\n+    UInt32 modifierMask = 0;\n+    if (shifted)\n+        modifierMask |= (1 << (shiftKeyBit - 8));\n+\n+    \/\/ Java key codes are used in accelerator processing so we will try to match them\n+    \/\/ the same way Apple handles key equivalents e.g. by asking for the Cmd character.\n+    \/\/ This is necessary on non-ASCII layouts such as Cyrillic or Arabic to ensure the\n+    \/\/ translation produces an ASCII key. Exactly how this is done is specific to the\n+    \/\/ keyboard but for non-ASCII keyboards it generally generates some variant of\n+    \/\/ QWERTY.\n+    if (forAccelerator)\n+        modifierMask |= (1 << (cmdKeyBit - 8));\n+\n+    UInt32 deadKeyState = 0;\n+    UniCharCount actualLength = 0;\n+    OSStatus status = UCKeyTranslate(layout,\n+                                     keyCode, kUCKeyActionDown,\n+                                     modifierMask,\n+                                     LMGetKbdType(),\n+                                     kUCKeyTranslateNoDeadKeysMask, &deadKeyState,\n+                                     bufferSize, &actualLength,\n+                                     buffer);\n+    if (status != noErr)\n+        actualLength = 0;\n+\n+    return actualLength;\n+}\n+\n+static UniCharCount getCharsForMacKey(unsigned short keyCode, BOOL shifted, BOOL forAccelerator, UniChar* buffer, UniCharCount bufferSize)\n+{\n+    TISInputSourceRef keyboard = TISCopyCurrentKeyboardLayoutInputSource();\n+    if (keyboard == NULL)\n+        return 0;\n+\n+    UniCharCount length = queryKeyboard(keyboard, keyCode,\n+                                        shifted, forAccelerator,\n+                                        buffer, bufferSize);\n+    CFRelease(keyboard);\n+    return length;\n+}\n+\n+\/\/ This is only valid for keys in the area that is sensitive to layout changes.\n+static jint getJavaCodeForMacKey(unsigned short keyCode)\n+{\n+    UniChar unicode[8];\n+    UniCharCount length = getCharsForMacKey(keyCode, NO, YES, unicode, 8);\n+    if (length == 1)\n+        return getJavaCodeForASCII(unicode[0]);\n+    return 0;\n+}\n+\n@@ -237,0 +379,5 @@\n+    if (macKeyCodeIsLayoutSensitive(keyCode))\n+    {\n+        return getJavaCodeForMacKey(keyCode);\n+    }\n+\n@@ -284,0 +431,2 @@\n+    BOOL found = NO;\n+    \/\/ Find a key code based on the US QWERTY layout\n@@ -289,1 +438,23 @@\n-            return YES;\n+            found = YES;\n+            break;\n+        }\n+    }\n+\n+    if (!found)\n+        return NO;\n+\n+    if (!macKeyCodeIsLayoutSensitive(*outMacKeyCode))\n+        return YES;\n+\n+    \/\/ If the QWERTY key is in the layout sensitive area search the other keys in that\n+    \/\/ area. We may not find a key so returning NO is possible.\n+    for (unsigned short trialKey = 0x00; trialKey <= 0x7E; ++trialKey)\n+    {\n+        if (macKeyCodeIsLayoutSensitive(trialKey))\n+        {\n+            jint trialCode = getJavaCodeForMacKey(trialKey);\n+            if (trialCode == javaKeyCode)\n+            {\n+                *outMacKeyCode = trialKey;\n+                return YES;\n+            }\n@@ -293,1 +464,0 @@\n-    \/\/ ??? unknown VK\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassKey.m","additions":172,"deletions":2,"binary":false,"changes":174,"status":"modified"}]}