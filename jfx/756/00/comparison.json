{"files":[{"patch":"@@ -89,1 +89,0 @@\n-        linux\/MemoryPressureHandlerLinux.cpp\n@@ -91,0 +90,1 @@\n+        unix\/MemoryPressureHandlerUnix.cpp\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WTF\/wtf\/PlatformJava.cmake","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,140 +0,0 @@\n-\/*\n- * Copyright (C) 2011, 2012 Apple Inc. All Rights Reserved.\n- * Copyright (C) 2014 Raspberry Pi Foundation. All Rights Reserved.\n- * Copyright (C) 2018 Igalia S.L.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions\n- * are met:\n- * 1. Redistributions of source code must retain the above copyright\n- *    notice, this list of conditions and the following disclaimer.\n- * 2. Redistributions in binary form must reproduce the above copyright\n- *    notice, this list of conditions and the following disclaimer in the\n- *    documentation and\/or other materials provided with the distribution.\n- *\n- * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY\n- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n- * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n- * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n- * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n- * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n- * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n- * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-\n-#include \"config.h\"\n-#include <wtf\/MemoryPressureHandler.h>\n-\n-#include <malloc.h>\n-#include <unistd.h>\n-#include <wtf\/MainThread.h>\n-#include <wtf\/MemoryFootprint.h>\n-#include <wtf\/linux\/CurrentProcessMemoryStatus.h>\n-#include <wtf\/text\/WTFString.h>\n-#include <wtf\/Threading.h>\n-\n-#define LOG_CHANNEL_PREFIX Log\n-\n-namespace WTF {\n-\n-\/\/ Disable memory event reception for a minimum of s_minimumHoldOffTime\n-\/\/ seconds after receiving an event. Don't let events fire any sooner than\n-\/\/ s_holdOffMultiplier times the last cleanup processing time. Effectively\n-\/\/ this is 1 \/ s_holdOffMultiplier percent of the time.\n-\/\/ If after releasing the memory we don't free at least s_minimumBytesFreedToUseMinimumHoldOffTime,\n-\/\/ we wait longer to try again (s_maximumHoldOffTime).\n-\/\/ These value seems reasonable and testing verifies that it throttles frequent\n-\/\/ low memory events, greatly reducing CPU usage.\n-static const Seconds s_minimumHoldOffTime { 5_s };\n-static const Seconds s_maximumHoldOffTime { 30_s };\n-static const size_t s_minimumBytesFreedToUseMinimumHoldOffTime = 1 * MB;\n-static const unsigned s_holdOffMultiplier = 20;\n-\n-void MemoryPressureHandler::triggerMemoryPressureEvent(bool isCritical)\n-{\n-    if (!m_installed)\n-        return;\n-\n-    if (ReliefLogger::loggingEnabled())\n-        LOG(MemoryPressure, \"Got memory pressure notification (%s)\", isCritical ? \"critical\" : \"non-critical\");\n-\n-    setUnderMemoryPressure(true);\n-\n-    if (isMainThread())\n-        respondToMemoryPressure(isCritical ? Critical::Yes : Critical::No);\n-    else\n-        RunLoop::main().dispatch([this, isCritical] {\n-            respondToMemoryPressure(isCritical ? Critical::Yes : Critical::No);\n-        });\n-\n-    if (ReliefLogger::loggingEnabled() && isUnderMemoryPressure())\n-        LOG(MemoryPressure, \"System is no longer under memory pressure.\");\n-\n-    setUnderMemoryPressure(false);\n-}\n-\n-void MemoryPressureHandler::install()\n-{\n-    if (m_installed || m_holdOffTimer.isActive())\n-        return;\n-\n-    m_installed = true;\n-}\n-\n-void MemoryPressureHandler::uninstall()\n-{\n-    if (!m_installed)\n-        return;\n-\n-    m_holdOffTimer.stop();\n-\n-    m_installed = false;\n-}\n-\n-void MemoryPressureHandler::holdOffTimerFired()\n-{\n-    install();\n-}\n-\n-void MemoryPressureHandler::holdOff(Seconds seconds)\n-{\n-    m_holdOffTimer.startOneShot(seconds);\n-}\n-\n-static size_t processMemoryUsage()\n-{\n-    ProcessMemoryStatus memoryStatus;\n-    currentProcessMemoryStatus(memoryStatus);\n-    return (memoryStatus.resident - memoryStatus.shared);\n-}\n-\n-void MemoryPressureHandler::respondToMemoryPressure(Critical critical, Synchronous synchronous)\n-{\n-    uninstall();\n-\n-    MonotonicTime startTime = MonotonicTime::now();\n-    int64_t processMemory = processMemoryUsage();\n-    releaseMemory(critical, synchronous);\n-    int64_t bytesFreed = processMemory - processMemoryUsage();\n-    Seconds holdOffTime = s_maximumHoldOffTime;\n-    if (bytesFreed > 0 && static_cast<size_t>(bytesFreed) >= s_minimumBytesFreedToUseMinimumHoldOffTime)\n-        holdOffTime = (MonotonicTime::now() - startTime) * s_holdOffMultiplier;\n-    holdOff(std::max(holdOffTime, s_minimumHoldOffTime));\n-}\n-\n-void MemoryPressureHandler::platformReleaseMemory(Critical)\n-{\n-#if HAVE(MALLOC_TRIM)\n-    malloc_trim(0);\n-#endif\n-}\n-\n-std::optional<MemoryPressureHandler::ReliefLogger::MemoryUsage> MemoryPressureHandler::ReliefLogger::platformMemoryUsage()\n-{\n-    return MemoryUsage {processMemoryUsage(), memoryFootprint()};\n-}\n-\n-} \/\/ namespace WTF\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/WTF\/wtf\/linux\/MemoryPressureHandlerLinux.cpp","additions":0,"deletions":140,"binary":false,"changes":140,"status":"deleted"}]}