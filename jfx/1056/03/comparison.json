{"files":[{"patch":"@@ -44,1 +44,8 @@\n-        Subscription.subscribe(nonNullCondition, current -> {\n+        Subscription.subscribe(nonNullCondition, this::conditionChanged);\n+    }\n+\n+    private void conditionChanged(boolean active) {\n+        if (!active && !isValid()) {\n+            getValue();  \/\/ makes binding valid, which it should always be when inactive\n+        }\n+        else if (isValid() && source.getValue() != getValue()) {\n@@ -46,0 +53,1 @@\n+        }\n@@ -47,4 +55,1 @@\n-            if (!current) {\n-                getValue();\n-            }\n-        });\n+        updateSubscription();\n@@ -65,0 +70,6 @@\n+        updateSubscription();\n+\n+        return source.getValue();\n+    }\n+\n+    private void updateSubscription() {\n@@ -73,2 +84,0 @@\n-\n-        return source.getValue();\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ConditionalBinding.java","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -82,20 +82,0 @@\n-\n-            \/*\n-             * Although the act of registering a listener already attempts to make\n-             * this binding valid, allowValidation won't allow it as the binding is\n-             * not observed yet. This is because isObserved will not yet return true\n-             * when the process of registering the listener hasn't completed yet.\n-             *\n-             * As the binding must be valid after it becomes observed the first time\n-             * 'get' is called again.\n-             *\n-             * See com.sun.javafx.binding.ExpressionHelper (which is used\n-             * by ObjectBinding) where it will do a call to ObservableValue#getValue\n-             * BEFORE adding the actual listener. This results in ObjectBinding#get\n-             * to be called in which the #allowValidation call will block it from\n-             * becoming valid as the condition is \"isObserved()\"; this is technically\n-             * correct as the listener wasn't added yet, but means we must call\n-             * #get again to make this binding valid.\n-             *\/\n-\n-            get(); \/\/ make binding valid as source wasn't tracked until now\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/LazyObjectBinding.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+    private boolean observed;\n@@ -84,0 +85,1 @@\n+        observed = observed || listener != null;\n@@ -90,0 +92,1 @@\n+        observed = helper != null;\n@@ -94,0 +97,1 @@\n+        observed = observed || listener != null;\n@@ -100,0 +104,1 @@\n+        observed = helper != null;\n@@ -214,1 +219,1 @@\n-        return helper != null;\n+        return observed;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/binding\/ObjectBinding.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1033,0 +1033,23 @@\n+                @Test\n+                void shouldBeStronglyReferencedImmediatelyAfterConditionBecomesTrue() {\n+                    condition.set(false);\n+                    condition.set(true);\n+\n+                    ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> {\n+                        observableValue = null;\n+                        condition = null;\n+                    });\n+                }\n+\n+                @Test\n+                void shouldBeStronglyReferencedImmediatelyAfterConditionBecomesTrue_2() {\n+                    condition.set(false);\n+                    property.set(\"Middle\");\n+                    condition.set(true);\n+\n+                    ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> {\n+                        observableValue = null;\n+                        condition = null;\n+                    });\n+                }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/ObservableValueFluentBindingsTest.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,369 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.beans.value;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import javafx.beans.property.BooleanProperty;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.beans.property.StringProperty;\n+import javafx.beans.value.ObservableValue;\n+\n+public class ObservableValueWhenTest {\n+\n+    @Nested\n+    class WhenNotObserved {\n+\n+        \/*\n+         * For these cases, we don't expect a downstream function to be called\n+         * at all because when the complete binding is not observed, no listeners\n+         * will be registered on any of the upstream functions either.\n+         *\n+         * This test merely ensures that this is indeed the case, no matter what\n+         * state the when binding might be in initially or changed to.\n+         *\/\n+\n+        @Nested\n+        class AndConditionStartsFalse {\n+            BooleanProperty condition = new SimpleBooleanProperty(false);\n+\n+            @Test\n+            void shouldNeverCallDownstreamMapFunction() {\n+                StringProperty property = new SimpleStringProperty(\"a\");\n+                List<String> observedMappings = new ArrayList<>();\n+\n+                property.when(condition).map(observedMappings::add);\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                property.set(\"b\");\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                condition.set(true);\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                property.set(\"c\");\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                condition.set(false);\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                property.set(\"d\");\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                condition.set(true);\n+\n+                assertEquals(List.of(), observedMappings);\n+            }\n+        }\n+\n+        @Nested\n+        class AndConditionStartsTrue {\n+            BooleanProperty condition = new SimpleBooleanProperty(true);\n+\n+            @Test\n+            void shouldNeverCallDownstreamMapFunction() {\n+                StringProperty property = new SimpleStringProperty(\"a\");\n+                List<String> observedMappings = new ArrayList<>();\n+\n+                property.when(condition).map(observedMappings::add);\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                property.set(\"b\");\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                condition.set(false);\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                property.set(\"c\");\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                condition.set(true);\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                property.set(\"d\");\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                condition.set(false);\n+\n+                assertEquals(List.of(), observedMappings);\n+            }\n+        }\n+    }\n+\n+    @Nested\n+    class WhenObserved {\n+\n+        @Nested\n+        class AndConditionStartsFalse {\n+            BooleanProperty condition = new SimpleBooleanProperty(false);\n+\n+            @Test\n+            void shouldCallDownstreamMapFunctionOnlyWhenAbsolutelyNeeded() {\n+                StringProperty property = new SimpleStringProperty(\"a\");\n+                List<String> observedMappings = new ArrayList<>();\n+                List<String> observedChanges = new ArrayList<>();\n+\n+                property.when(condition)\n+                    .map(x -> { observedMappings.add(x); return x; })\n+                    .addListener((obs, old, current) -> observedChanges.add(old + \" -> \" + current));\n+\n+                assertEquals(List.of(\"a\"), observedMappings);\n+                assertEquals(List.of(), observedChanges);\n+\n+                property.set(\"b\");\n+\n+                assertEquals(List.of(\"a\"), observedMappings);\n+                assertEquals(List.of(), observedChanges);\n+\n+                condition.set(true);\n+\n+                assertEquals(List.of(\"a\", \"b\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\"), observedChanges);\n+\n+                property.set(\"c\");\n+\n+                assertEquals(List.of(\"a\", \"b\", \"c\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\", \"b -> c\"), observedChanges);\n+\n+                condition.set(false);\n+\n+                assertEquals(List.of(\"a\", \"b\", \"c\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\", \"b -> c\"), observedChanges);\n+\n+                property.set(\"d\");\n+\n+                assertEquals(List.of(\"a\", \"b\", \"c\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\", \"b -> c\"), observedChanges);\n+\n+                condition.set(true);\n+\n+                assertEquals(List.of(\"a\", \"b\", \"c\", \"d\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\", \"b -> c\", \"c -> d\"), observedChanges);\n+            }\n+        }\n+\n+        @Nested\n+        class AndConditionStartsTrue {\n+            BooleanProperty condition = new SimpleBooleanProperty(true);\n+\n+            @Test\n+            void shouldCallDownstreamMapFunctionOnlyWhenAbsolutelyNeeded() {\n+                StringProperty property = new SimpleStringProperty(\"a\");\n+                List<String> observedMappings = new ArrayList<>();\n+                List<String> observedChanges = new ArrayList<>();\n+\n+                property.when(condition)\n+                    .map(x -> { observedMappings.add(x); return x; })\n+                    .addListener((obs, old, current) -> observedChanges.add(old + \" -> \" + current));\n+\n+                assertEquals(List.of(\"a\"), observedMappings);\n+                assertEquals(List.of(), observedChanges);\n+\n+                property.set(\"b\");\n+\n+                assertEquals(List.of(\"a\", \"b\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\"), observedChanges);\n+\n+                condition.set(false);\n+\n+                assertEquals(List.of(\"a\", \"b\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\"), observedChanges);\n+\n+                property.set(\"c\");\n+\n+                assertEquals(List.of(\"a\", \"b\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\"), observedChanges);\n+\n+                condition.set(true);\n+\n+                assertEquals(List.of(\"a\", \"b\", \"c\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\", \"b -> c\"), observedChanges);\n+\n+                property.set(\"d\");\n+\n+                assertEquals(List.of(\"a\", \"b\", \"c\", \"d\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\", \"b -> c\", \"c -> d\"), observedChanges);\n+\n+                condition.set(false);\n+\n+                assertEquals(List.of(\"a\", \"b\", \"c\", \"d\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\", \"b -> c\", \"c -> d\"), observedChanges);\n+            }\n+        }\n+    }\n+\n+    @Nested\n+    class WhenObservedDirectlyForInvalidations {\n+\n+        @Nested\n+        class AndConditionStartsFalse {\n+            BooleanProperty condition = new SimpleBooleanProperty(false);\n+\n+            @Test\n+            void shouldOnlyInvalidateWhenAbsolutelyNeeded() {\n+                StringProperty property = new SimpleStringProperty(\"a\");\n+                AtomicInteger observedInvalidations = new AtomicInteger();\n+\n+                ObservableValue<String> when = property.when(condition);\n+\n+                when.addListener(obs -> observedInvalidations.addAndGet(1));\n+\n+                assertEquals(0, observedInvalidations.get());\n+\n+                property.set(\"b\");\n+\n+                assertEquals(0, observedInvalidations.get());\n+\n+                \/\/ would make no difference, inactive \"when\" bindings are always valid\n+                when.getValue();\n+\n+                property.set(\"b2\");\n+\n+                assertEquals(0, observedInvalidations.get());\n+\n+                \/\/ as inactive \"when\"'s are always valid, when it becomes active and the value has changed, it must invalidate\n+                condition.set(true);\n+\n+                assertEquals(1, observedInvalidations.get());\n+\n+                property.set(\"c\");\n+\n+                assertEquals(1, observedInvalidations.get());\n+\n+                \/\/ should not matter, as it is the observable resulting from \"when\" that isn't valid\n+                property.get();\n+                property.set(\"d\");\n+\n+                assertEquals(1, observedInvalidations.get());\n+\n+                \/\/ this will make the \"when\" valid, and so we can expect a new invalidation\n+                when.getValue();\n+                property.set(\"e\");\n+\n+                assertEquals(2, observedInvalidations.get());\n+\n+                \/\/ this will make the \"when\" valid (it is always valid when inactive), but it can't change now\n+                condition.set(false);\n+\n+                assertEquals(2, observedInvalidations.get());\n+\n+                property.set(\"d\");\n+\n+                assertEquals(2, observedInvalidations.get());\n+\n+                \/\/ when becoming active again, it was valid, and it has changed, so expect invalidation\n+                condition.set(true);\n+\n+                assertEquals(3, observedInvalidations.get());\n+            }\n+        }\n+\n+        @Nested\n+        class AndConditionStartsTrue {\n+            BooleanProperty condition = new SimpleBooleanProperty(true);\n+\n+            @Test\n+            void shouldOnlyInvalidateWhenAbsolutelyNeeded() {\n+                StringProperty property = new SimpleStringProperty(\"a\");\n+                AtomicInteger observedInvalidations = new AtomicInteger();\n+\n+                ObservableValue<String> when = property.when(condition);\n+\n+                when.addListener(obs -> observedInvalidations.addAndGet(1));\n+\n+                assertEquals(0, observedInvalidations.get());\n+\n+                property.set(\"b\");\n+\n+                assertEquals(1, observedInvalidations.get());\n+\n+                property.set(\"c\");\n+\n+                assertEquals(1, observedInvalidations.get());\n+\n+                \/\/ should not matter, as it is the observable resulting from \"when\" that isn't valid\n+                property.get();\n+                property.set(\"d\");\n+\n+                assertEquals(1, observedInvalidations.get());\n+\n+                \/\/ this will make the \"when\" valid, and so we can expect a new invalidation\n+                when.getValue();\n+                property.set(\"e\");\n+\n+                assertEquals(2, observedInvalidations.get());\n+\n+                \/\/ this will make the \"when\" valid (it is always valid when inactive), but it can't change now\n+                condition.set(false);\n+\n+                assertEquals(2, observedInvalidations.get());\n+\n+                property.set(\"f\");\n+\n+                assertEquals(2, observedInvalidations.get());\n+\n+                \/\/ would make no difference, inactive \"when\" bindings are always valid\n+                when.getValue();\n+                property.set(\"f2\");\n+\n+                assertEquals(2, observedInvalidations.get());\n+\n+                \/\/ when becoming active again, it was valid, and it has changed, so expect invalidation\n+                condition.set(true);\n+\n+                assertEquals(3, observedInvalidations.get());\n+\n+                property.set(\"g\");\n+\n+                assertEquals(3, observedInvalidations.get());\n+\n+                condition.set(false);\n+\n+                assertEquals(3, observedInvalidations.get());\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/ObservableValueWhenTest.java","additions":369,"deletions":0,"binary":false,"changes":369,"status":"added"}]}