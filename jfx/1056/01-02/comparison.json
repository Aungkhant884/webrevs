{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -40,0 +41,1 @@\n+import javafx.beans.value.ObservableValue;\n@@ -46,0 +48,9 @@\n+        \/*\n+         * For these cases, we don't expect a downstream function to be called\n+         * at all because when the complete binding is not observed, no listeners\n+         * will be registered on any of the upstream functions either.\n+         *\n+         * This test merely ensures that this is indeed the case, no matter what\n+         * state the when binding might be in initially or changed to.\n+         *\/\n+\n@@ -127,0 +138,1 @@\n+\n@@ -225,0 +237,120 @@\n+\n+    @Nested\n+    class WhenObservedDirectlyForInvalidations {\n+\n+        @Nested\n+        class AndConditionStartsFalse {\n+            BooleanProperty condition = new SimpleBooleanProperty(false);\n+\n+            @Test\n+            void shouldOnlyInvalidateWhenAbsolutelyNeeded() {\n+                StringProperty property = new SimpleStringProperty(\"a\");\n+                AtomicInteger observedInvalidations = new AtomicInteger();\n+\n+                ObservableValue<String> when = property.when(condition);\n+\n+                when.addListener(obs -> observedInvalidations.addAndGet(1));\n+\n+                assertEquals(0, observedInvalidations.get());\n+\n+                property.set(\"b\");\n+\n+                assertEquals(0, observedInvalidations.get());\n+\n+                when.getValue();  \/\/ would make no difference, inactive when bindings are always valid\n+                property.set(\"b2\");\n+\n+                assertEquals(0, observedInvalidations.get());\n+\n+                condition.set(true);  \/\/ as inactive when's are always valid, when it becomes active and the value has changed, it must invalidate\n+\n+                assertEquals(1, observedInvalidations.get());\n+\n+                property.set(\"c\");\n+\n+                assertEquals(1, observedInvalidations.get());\n+\n+                property.get();  \/\/ should not matter, as it is the observable resulting from when that isn't valid\n+                property.set(\"d\");\n+\n+                assertEquals(1, observedInvalidations.get());\n+\n+                when.getValue();  \/\/ this will make the when valid, and so we can expect a new invalidation\n+                property.set(\"e\");\n+\n+                assertEquals(2, observedInvalidations.get());\n+\n+                condition.set(false);  \/\/ this will make the when valid (it is always valid when inactive), but it can't change now\n+\n+                assertEquals(2, observedInvalidations.get());\n+\n+                property.set(\"d\");\n+\n+                assertEquals(2, observedInvalidations.get());\n+\n+                condition.set(true);  \/\/ when becoming active again, it was valid, and it has changed, so expect invalidation\n+\n+                assertEquals(3, observedInvalidations.get());\n+            }\n+        }\n+\n+        @Nested\n+        class AndConditionStartsTrue {\n+            BooleanProperty condition = new SimpleBooleanProperty(true);\n+\n+            @Test\n+            void shouldOnlyInvalidateWhenAbsolutelyNeeded() {\n+                StringProperty property = new SimpleStringProperty(\"a\");\n+                AtomicInteger observedInvalidations = new AtomicInteger();\n+\n+                ObservableValue<String> when = property.when(condition);\n+\n+                when.addListener(obs -> observedInvalidations.addAndGet(1));\n+\n+                assertEquals(0, observedInvalidations.get());\n+\n+                property.set(\"b\");\n+\n+                assertEquals(1, observedInvalidations.get());\n+\n+                property.set(\"c\");\n+\n+                assertEquals(1, observedInvalidations.get());\n+\n+                property.get();  \/\/ should not matter, as it is the observable resulting from when that isn't valid\n+                property.set(\"d\");\n+\n+                assertEquals(1, observedInvalidations.get());\n+\n+                when.getValue();  \/\/ this will make the when valid, and so we can expect a new invalidation\n+                property.set(\"e\");\n+\n+                assertEquals(2, observedInvalidations.get());\n+\n+                condition.set(false);  \/\/ this will make the when valid (it is always valid when inactive), but it can't change now\n+\n+                assertEquals(2, observedInvalidations.get());\n+\n+                property.set(\"f\");\n+\n+                assertEquals(2, observedInvalidations.get());\n+\n+                when.getValue();  \/\/ would make no difference, inactive when bindings are always valid\n+                property.set(\"f2\");\n+\n+                assertEquals(2, observedInvalidations.get());\n+\n+                condition.set(true);  \/\/ when becoming active again, it was valid, and it has changed, so expect invalidation\n+\n+                assertEquals(3, observedInvalidations.get());\n+\n+                property.set(\"g\");\n+\n+                assertEquals(3, observedInvalidations.get());\n+\n+                condition.set(false);\n+\n+                assertEquals(3, observedInvalidations.get());\n+            }\n+        }\n+    }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/ObservableValueWhenTest.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"modified"}]}