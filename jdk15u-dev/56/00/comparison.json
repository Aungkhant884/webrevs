{"files":[{"patch":"@@ -2630,1 +2630,1 @@\n-      if (vlen_in_bytes >= max_vlen_in_bytes && vlen > max_vlen) {\n+      if (vlen > max_vlen) {\n@@ -2632,0 +2632,2 @@\n+      }\n+      if (vlen_in_bytes > max_vlen_in_bytes) {\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8193518 8249608\n+ * @summary C2: Vector registers are sometimes corrupted at safepoint\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:+UseCountedLoopSafepoints -XX:LoopStripMiningIter=1000 TestVectorsNotSavedAtSafepoint test1\n+ * @run main\/othervm -XX:-BackgroundCompilation TestVectorsNotSavedAtSafepoint test2\n+ *\/\n+\n+import java.util.Arrays;\n+\n+public class TestVectorsNotSavedAtSafepoint {\n+\n+    static void test1(byte[] barray1, byte[] barray2, byte[] barray3, long[] larray, long v) {\n+        \/\/ Uses wide vectors, v in vector registers is live at the\n+        \/\/ safepoint of the outer strip mined loop\n+        for (int i = 0; i < larray.length; i++) {\n+            larray[i] = v;\n+        }\n+        \/\/ Runs for few iterations so limited unrolling and short\n+        \/\/ vectors\n+        for (int i = 0; i < barray3.length; i++) {\n+            barray3[i] = (byte)(barray1[i] + barray2[i]);\n+        }\n+    }\n+\n+    public static void test2(int[] iArr, long[] lArr) {\n+        \/\/ Loop with wide and non-wide vectors\n+        for (int i = 0; i < lArr.length; i++) {\n+            iArr[i] = 1;\n+            lArr[i] = 1;\n+        }\n+    }\n+\n+    static class GarbageProducerThread extends Thread {\n+        public void run() {\n+            for(;;) {\n+                Object[] arrays = new Object[1024];\n+                for (int i = 0; i < arrays.length; i++) {\n+                    arrays[i] = new int[1024];\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        Thread garbage_producer = new GarbageProducerThread();\n+        garbage_producer.setDaemon(true);\n+        garbage_producer.start();\n+\n+        if (args[0].equals(\"test1\")) {\n+            byte[] barray = new byte[10];\n+            long[] larray1 = new long[1000];\n+            long[] larray2 = new long[100_000_000];\n+            for (int i = 0; i < 20_000; i++) {\n+                test1(barray, barray, barray, larray1, -1);\n+            }\n+            for (int i = 0; i < 100; i++) {\n+                test1(barray, barray, barray, larray2, -1);\n+                if (larray2[larray2.length-1] != -1) {\n+                    System.out.println(\"Iter \" + i + \" Failed with \" + Long.toHexString(larray2[larray2.length-1]));\n+                    throw new RuntimeException(\"Test1 failed\");\n+                }\n+            }\n+        } else {\n+            int iArr[] = new int[100];\n+            long lArr[] = new long[100];\n+            for (int i = 0; i < 600_000; ++i) {\n+                test2(iArr, lArr);\n+                for (int j = 0; j < lArr.length; ++j) {\n+                    if (iArr[j] != 1 || lArr[j] != 1) {\n+                        throw new RuntimeException(\"Test2 failed at iteration \" + i + \": iArr[\" + j + \"] = \" + iArr[j] + \", lArr[\" + j + \"] = \" + lArr[j]);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestVectorsNotSavedAtSafepoint.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"}]}