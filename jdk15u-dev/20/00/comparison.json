{"files":[{"patch":"@@ -49,1 +49,1 @@\n-Node *PhaseIdealLoop::split_thru_phi( Node *n, Node *region, int policy ) {\n+Node* PhaseIdealLoop::split_thru_phi(Node* n, Node* region, int policy) {\n@@ -64,0 +64,15 @@\n+  \/\/ Bail out if 'n' is a Div or Mod node whose zero check was removed earlier (i.e. control is NULL) and its divisor is an induction variable\n+  \/\/ phi p of a trip-counted (integer) loop whose inputs could be zero (include zero in their type range). p could have a more precise type\n+  \/\/ range that does not necessarily include all values of its inputs. Since each of these inputs will be a divisor of the newly cloned nodes\n+  \/\/ of 'n', we need to bail out of one of these divisors could be zero (zero in its type range).\n+  if ((n->Opcode() == Op_DivI || n->Opcode() == Op_ModI) && n->in(0) == NULL\n+      && region->is_CountedLoop() && n->in(2) == region->as_CountedLoop()->phi()) {\n+    Node* phi = region->as_CountedLoop()->phi();\n+    for (uint i = 1; i < phi->req(); i++) {\n+      if (_igvn.type(phi->in(i))->filter_speculative(TypeInt::ZERO) != Type::TOP) {\n+        \/\/ Zero could be a possible value but we already removed the zero check. Bail out to avoid a possible division by zero at a later point.\n+        return NULL;\n+      }\n+    }\n+  }\n+\n@@ -69,2 +84,2 @@\n-  const TypeOopPtr *t_oop = _igvn.type(n)->isa_oopptr();\n-  Node *phi;\n+  const TypeOopPtr* t_oop = _igvn.type(n)->isa_oopptr();\n+  Node* phi;\n@@ -81,1 +96,1 @@\n-    Node *x;\n+    Node* x;\n@@ -92,1 +107,1 @@\n-        Node *in = n->in(j);\n+        Node* in = n->in(j);\n@@ -94,1 +109,1 @@\n-          x->set_req( j, in->in(i) ); \/\/ Use pre-Phi input for the clone\n+          x->set_req(j, in->in(i)); \/\/ Use pre-Phi input for the clone\n@@ -98,1 +113,1 @@\n-    const Type *t = x->Value(&_igvn);\n+    const Type* t = x->Value(&_igvn);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8248552\n+ * @summary A Division\/modulo node whose zero check was removed is split through an induction variable phi and executed before\n+ *          the loop limit check resulting in a SIGFPE because the divisor is zero.\n+ *\n+ * @run main\/othervm -XX:CompileCommand=dontinline,compiler.c2.loopopts.TestSplitThruPhiDivMod::test* compiler.c2.loopopts.TestSplitThruPhiDivMod\n+ *\/\n+package compiler.c2.loopopts;\n+\n+public class TestSplitThruPhiDivMod {\n+\n+    int x;\n+\n+    public int testMod() {\n+        int i1 = 2;\n+        for (int i = 5; i < 25; i++) {\n+            for (int j = 50; j > 1; j -= 2) {\n+                \/*\n+                 * Zero check is removed based on the type of the induction variable phi (variable j) since its always between 1 and 50.\n+                 * However, when splitting the modulo node through the phi, it can be executed right after the subtraction j-2 which can be\n+                 * 0 before evaluation the loop limit condition in the last iteration when j is 2: j-2 = 2-2 = 0. This results in a SIGFPE.\n+                 * The fix is to not split a division or modulo node 'n' through the induction variable phi if the zero check was removed\n+                 * earlier and the new inputs of the clones of 'n' after the split could be zero (i.e. the type of the clones of 'n' include 0).\n+                 *\/\n+                x = (20 % j); \/\/ Problematic division as part of modulo. Results in a SIGFPE, even though j is always non-zero.\n+                i1 = (i1 \/ i);\n+                for (int k = 3; k > 1; k--) {\n+                    switch ((i % 4) + 22) {\n+                    case 22:\n+                        switch (j % 10) {\n+                        case 83:\n+                            x += 5;\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return i1;\n+    }\n+\n+    public int testDiv() {\n+        int i1 = 2;\n+        for (int i = 5; i < 25; i++) {\n+            for (int j = 50; j > 1; j -= 2) {\n+                \/\/ Same issue as above but with a division node. See explanation above.\n+                x = (20 \/ j); \/\/ Problematic division. Results in a SIGFPE, even though j is always non-zero.\n+                i1 = (i1 \/ i);\n+                for (int k = 3; k > 1; k--) {\n+                    switch ((i % 4) + 22) {\n+                    case 22:\n+                        switch (j % 10) {\n+                        case 83:\n+                            x += 5;\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return i1;\n+    }\n+\n+    public static void main(String[] strArr) {\n+        TestSplitThruPhiDivMod t = new TestSplitThruPhiDivMod();\n+        for (int i = 0; i < 10000; i++) {\n+            t.testDiv();\n+            t.testMod();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestSplitThruPhiDivMod.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"}]}