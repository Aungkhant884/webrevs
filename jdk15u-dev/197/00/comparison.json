{"files":[{"patch":"@@ -140,0 +140,5 @@\n+\n+    @Override\n+    public String toString() {\n+        return \"Candidate{\" + value + \"}\";\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Candidate.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2002-2020, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.reader;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+public interface CompletionMatcher {\n+\n+    \/**\n+     * Compiles completion matcher functions\n+     *\n+     * @param options LineReader options\n+     * @param prefix invoked by complete-prefix or expand-or-complete-prefix widget\n+     * @param line The parsed line within which completion has been requested\n+     * @param caseInsensitive if completion is case insensitive or not\n+     * @param errors number of errors accepted in matching\n+     * @param originalGroupName value of JLineReader variable original-group-name\n+     *\/\n+    void compile(Map<LineReader.Option, Boolean> options, boolean prefix, CompletingParsedLine line\n+            , boolean caseInsensitive, int errors, String originalGroupName);\n+\n+    \/**\n+     *\n+     * @param candidates list of candidates\n+     * @return a map of candidates that completion matcher matches\n+     *\/\n+    List<Candidate> matches(List<Candidate> candidates);\n+\n+    \/**\n+     *\n+     * @return a candidate that have exact match, null if no exact match found\n+     *\/\n+    Candidate exactMatch();\n+\n+    \/**\n+     *\n+     * @return a common prefix of matched candidates\n+     *\/\n+    String getCommonPrefix();\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/CompletionMatcher.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2019, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.reader;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-\n-public class ConfigurationPath {\n-    private Path appConfig;\n-    private Path userConfig;\n-\n-    \/**\n-     * Configuration class constructor.\n-     * @param appConfig   Application configuration directory\n-     * @param userConfig  User private configuration directory\n-     *\/\n-    public ConfigurationPath(Path appConfig, Path userConfig) {\n-        this.appConfig = appConfig;\n-        this.userConfig = userConfig;\n-    }\n-\n-    \/**\n-     * Search configuration file first from userConfig and then appConfig directory. Returns null if file is not found.\n-     * @param  name    Configuration file name.\n-     * @return         Configuration file.\n-     *\n-     *\/\n-    public Path getConfig(String name) {\n-        Path out = null;\n-        if (userConfig != null && userConfig.resolve(name).toFile().exists()) {\n-            out = userConfig.resolve(name);\n-        } else if (appConfig != null && appConfig.resolve(name).toFile().exists()) {\n-            out = appConfig.resolve(name);\n-        }\n-        return out;\n-    }\n-\n-    \/**\n-     * Search configuration file from userConfig directory. Returns null if file is not found.\n-     * @param  name    Configuration file name.\n-     * @return         Configuration file.\n-     * @throws         IOException   When we do not have read access to the file or directory.\n-     *\n-     *\/\n-    public Path getUserConfig(String name) throws IOException {\n-        return getUserConfig(name, false);\n-    }\n-\n-    \/**\n-     * Search configuration file from userConfig directory. Returns null if file is not found.\n-     * @param  name    Configuration file name\n-     * @param  create  When true configuration file is created if not found.\n-     * @return         Configuration file.\n-     * @throws         IOException   When we do not have read\/write access to the file or directory.\n-     *\/\n-    public Path getUserConfig(String name, boolean create) throws IOException {\n-        Path out = null;\n-        if (userConfig != null) {\n-            if (!userConfig.resolve(name).toFile().exists() && create) {\n-                userConfig.resolve(name).toFile().createNewFile();\n-            }\n-            if (userConfig.resolve(name).toFile().exists()) {\n-                out = userConfig.resolve(name);\n-            }\n-        }\n-        return out;\n-    }\n-\n-}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/ConfigurationPath.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author or authors.\n@@ -18,0 +18,1 @@\n+    private String partialLine;\n@@ -37,0 +38,9 @@\n+\n+    public EndOfFileException partialLine(String partialLine) {\n+        this.partialLine = partialLine;\n+        return this;\n+    }\n+\n+    public String getPartialLine() {\n+        return partialLine;\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/EndOfFileException.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author or authors.\n@@ -297,0 +297,1 @@\n+    \/** tab completion: if candidates are more than list-max a question will be asked before displaying them *\/\n@@ -298,0 +299,5 @@\n+    \/**\n+     * tab completion: if candidates are less than menu-list-max\n+     * they are displayed in a list below the field to be completed\n+     *\/\n+    String MENU_LIST_MAX = \"menu-list-max\";\n@@ -306,0 +312,1 @@\n+    \/** Number of matching errors that are accepted by the completion matcher *\/\n@@ -313,0 +320,1 @@\n+    String COMPLETION_STYLE_LIST_GROUP = \"COMPLETION_STYLE_LIST_GROUP\";\n@@ -315,0 +323,1 @@\n+    String COMPLETION_STYLE_LIST_SELECTION = \"COMPLETION_STYLE_LIST_SELECTION\";\n@@ -317,0 +326,1 @@\n+    String COMPLETION_STYLE_LIST_DESCRIPTION = \"COMPLETION_STYLE_LIST_DESCRIPTION\";\n@@ -319,0 +329,4 @@\n+    String COMPLETION_STYLE_LIST_STARTING = \"COMPLETION_STYLE_LIST_STARTING\";\n+    \/** Completion style for displaying the list *\/\n+    String COMPLETION_STYLE_BACKGROUND = \"COMPLETION_STYLE_BACKGROUND\";\n+    String COMPLETION_STYLE_LIST_BACKGROUND = \"COMPLETION_STYLE_LIST_BACKGROUND\";\n@@ -373,0 +387,6 @@\n+    \/**\n+     * Min buffer size for tab auto-suggestions.\n+     * For shorter buffer sizes auto-suggestions are not resolved.\n+     *\/\n+    String SUGGESTIONS_MIN_BUFFER_SIZE = \"suggestions-min-buffer-size\";\n+\n@@ -377,0 +397,4 @@\n+        \/** use camel case completion matcher *\/\n+        COMPLETE_MATCHER_CAMELCASE,\n+        \/** use type completion matcher *\/\n+        COMPLETE_MATCHER_TYPO(true),\n@@ -389,0 +413,2 @@\n+        \/** list candidates below the field to be completed *\/\n+        AUTO_MENU_LIST,\n@@ -392,0 +418,2 @@\n+        \/** when double tab to select candidate keep candidates grouped (else loose grouping) *\/\n+        GROUP_PERSIST,\n@@ -417,1 +445,2 @@\n-        USE_FORWARD_SLASH(false),\n+        \/** FileNameCompleter: Use '\/' character as a file directory separator *\/\n+        USE_FORWARD_SLASH,\n@@ -453,0 +482,5 @@\n+        public final boolean isSet(Map<Option, Boolean> options) {\n+            Boolean b = options.get(this);\n+            return b != null ? b : this.isDef();\n+        }\n+\n@@ -492,2 +526,3 @@\n-     * @throws UserInterruptException If the call was interrupted by the user.\n-     * @throws EndOfFileException     If the end of the input stream was reached.\n+     * @throws UserInterruptException if readLine was interrupted (using Ctrl-C for example)\n+     * @throws EndOfFileException if an EOF has been found (using Ctrl-D for example)\n+     * @throws java.io.IOError in case of other i\/o errors\n@@ -505,2 +540,3 @@\n-     * @throws UserInterruptException If the call was interrupted by the user.\n-     * @throws EndOfFileException     If the end of the input stream was reached.\n+     * @throws UserInterruptException if readLine was interrupted (using Ctrl-C for example)\n+     * @throws EndOfFileException if an EOF has been found (using Ctrl-D for example)\n+     * @throws java.io.IOError in case of other i\/o errors\n@@ -518,2 +554,3 @@\n-     * @throws UserInterruptException If the call was interrupted by the user.\n-     * @throws EndOfFileException     If the end of the input stream was reached.\n+     * @throws UserInterruptException if readLine was interrupted (using Ctrl-C for example)\n+     * @throws EndOfFileException if an EOF has been found (using Ctrl-D for example)\n+     * @throws java.io.IOError in case of other i\/o errors\n@@ -532,2 +569,3 @@\n-     * @throws UserInterruptException If the call was interrupted by the user.\n-     * @throws EndOfFileException     If the end of the input stream was reached.\n+     * @throws UserInterruptException if readLine was interrupted (using Ctrl-C for example)\n+     * @throws EndOfFileException if an EOF has been found (using Ctrl-D for example)\n+     * @throws java.io.IOError in case of other i\/o errors\n@@ -549,2 +587,3 @@\n-     * @throws UserInterruptException If the call was interrupted by the user.\n-     * @throws EndOfFileException     If the end of the input stream was reached.\n+     * @throws UserInterruptException if readLine was interrupted (using Ctrl-C for example)\n+     * @throws EndOfFileException if an EOF has been found (using Ctrl-D for example)\n+     * @throws java.io.IOError in case of other i\/o errors\n@@ -571,2 +610,0 @@\n-     * @throws UserInterruptException If the call was interrupted by the user.\n-     * @throws EndOfFileException     If the end of the input stream was reached.\n@@ -593,2 +630,0 @@\n-     * @throws UserInterruptException If the call was interrupted by the user.\n-     * @throws EndOfFileException     If the end of the input stream was reached.\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/LineReader.java","additions":51,"deletions":16,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author or authors.\n@@ -39,0 +39,1 @@\n+    CompletionMatcher completionMatcher;\n@@ -106,0 +107,5 @@\n+    public LineReaderBuilder completionMatcher(CompletionMatcher completionMatcher) {\n+        this.completionMatcher = completionMatcher;\n+        return this;\n+    }\n+\n@@ -136,0 +142,3 @@\n+        if (completionMatcher != null) {\n+            reader.setCompletionMatcher(completionMatcher);\n+        }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/LineReaderBuilder.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        Pattern  patternCommand = Pattern.compile(\"^\\\\s*\" + REGEX_VARIABLE + \"=(\" + REGEX_COMMAND + \")(\\\\s+.*|$)\");\n+        Pattern  patternCommand = Pattern.compile(\"^\\\\s*\" + REGEX_VARIABLE + \"=(\" + REGEX_COMMAND + \")(\\\\s+|$)\");\n@@ -44,4 +44,0 @@\n-            int idx = out.indexOf(\"=\");\n-            if (idx > -1) {\n-                out = out.substring(idx + 1);\n-            }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/Parser.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2002-2021, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.reader;\n+\n+import java.io.StringWriter;\n+import java.io.Writer;\n+\n+\/**\n+ * Redirects a {@link Writer} to a {@link LineReader}'s {@link LineReader#printAbove(String)} method,\n+ * which draws output above the current prompt \/ input line.\n+ *\n+ * <p>Example:<\/p>\n+ * <pre>\n+ *     LineReader reader = LineReaderBuilder.builder().terminal(terminal).parser(parser).build();\n+ *     PrintAboveWriter printAbove = new PrintAboveWriter(reader);\n+ *     printAbove.write(new char[] { 'h', 'i', '!', '\\n'});\n+ * <\/pre>\n+ *\n+ *\/\n+public class PrintAboveWriter extends StringWriter {\n+    private final LineReader reader;\n+\n+    public PrintAboveWriter(LineReader reader) {\n+        this.reader = reader;\n+    }\n+\n+    @Override\n+    public void flush() {\n+        StringBuffer buffer = getBuffer();\n+        int lastNewline = buffer.lastIndexOf(\"\\n\");\n+        if (lastNewline >= 0) {\n+            reader.printAbove(buffer.substring(0, lastNewline + 1));\n+            buffer.delete(0, lastNewline + 1);\n+        }\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/PrintAboveWriter.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -1,153 +0,0 @@\n-\/*\n- * Copyright (c) 2002-2020, the original author or authors.\n- *\n- * This software is distributable under the BSD license. See the terms of the\n- * BSD license in the documentation provided with this software.\n- *\n- * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n- *\/\n-package jdk.internal.org.jline.reader;\n-\n-import java.io.File;\n-import java.nio.file.Path;\n-import java.util.*;\n-\n-\/**\n- * Manage scriptEngine variables, statements and script execution.\n- *\n- * @author <a href=\"mailto:matti.rintanikkola@gmail.com\">Matti Rinta-Nikkola<\/a>\n- *\/\n-public interface ScriptEngine {\n-\n-    \/**\n-     *\n-     * @return scriptEngine name\n-     *\/\n-    String getEngineName();\n-\n-    \/**\n-     *\n-     * @return script file name extensions\n-     *\/\n-    Collection<String> getExtensions();\n-\n-    \/**\n-     * Tests if console variable exists\n-     * @param name\n-     * @return true if variable exists\n-     *\/\n-    boolean hasVariable(String name);\n-\n-    \/**\n-     * Creates variable\n-     * @param name of the variable\n-     * @param value of the variable\n-     *\/\n-    void put(String name, Object value);\n-\n-    \/**\n-     * Gets variable value\n-     * @param name of the variable\n-     * @return value of the variable\n-     *\/\n-    Object get(String name);\n-\n-    \/**\n-     * Gets all variables with values\n-     * @return map of the variables\n-     *\/\n-    default Map<String,Object> find() {\n-        return find(null);\n-    }\n-\n-    \/**\n-     * Gets all the variables that match the name. Name can contain * wild cards.\n-     * @param name of the variable\n-     * @return map of the variables\n-     *\/\n-    Map<String,Object> find(String name);\n-\n-    \/**\n-     * Deletes variables. Variable name cab contain * wild cards.\n-     * @param vars\n-     *\/\n-    void del(String... vars);\n-\n-    \/**\n-     * Converts object to JSON string.\n-     * @param object object to convert to JSON\n-     * @return formatted JSON string\n-     *\/\n-    String toJson(Object object);\n-\n-    \/**\n-     * Converts object to string.\n-     * @param object object to convert to string\n-     * @return object string value\n-     *\/\n-    String toString(Object object);\n-\n-    \/**\n-     * Substitute variable reference with its value.\n-     * @param variable\n-     * @return Substituted variable\n-     * @throws Exception\n-     *\/\n-    default Object expandParameter(String variable) {\n-        return expandParameter(variable, \"\");\n-    }\n-\n-    \/**\n-     * Substitute variable reference with its value.\n-     * @param variable\n-     * @param format serialization format\n-     * @return Substituted variable\n-     * @throws Exception\n-     *\/\n-    Object expandParameter(String variable, String format);\n-\n-    \/**\n-     * Persists object value to file.\n-     * @param file\n-     * @param object\n-     *\/\n-    default void persist(Path file, Object object) {\n-        persist(file, object, \"JSON\");\n-    }\n-\n-    \/**\n-     * Persists object value to file.\n-     * @param file\n-     * @param object\n-     * @param format\n-     *\/\n-    void persist(Path file, Object object, String format);\n-\n-    \/**\n-     * Executes scriptEngine statement\n-     * @param statement\n-     * @return result\n-     * @throws Exception\n-     *\/\n-    Object execute(String statement) throws Exception;\n-\n-    \/**\n-     * Executes scriptEngine script\n-     * @param script\n-     * @return result\n-     * @throws Exception\n-     *\/\n-    default Object execute(File script) throws Exception {\n-        return execute(script, null);\n-    }\n-\n-    \/**\n-     * Executes scriptEngine script\n-     * @param script\n-     * @param args\n-     * @return\n-     * @throws Exception\n-     *\/\n-    Object execute(File script, Object[] args) throws Exception;\n-\n-}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/ScriptEngine.java","additions":0,"deletions":153,"binary":false,"changes":153,"status":"deleted"},{"patch":"@@ -0,0 +1,210 @@\n+\/*\n+ * Copyright (c) 2002-2021, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.reader.impl;\n+\n+import jdk.internal.org.jline.reader.Candidate;\n+import jdk.internal.org.jline.reader.CompletingParsedLine;\n+import jdk.internal.org.jline.reader.CompletionMatcher;\n+import jdk.internal.org.jline.reader.LineReader;\n+import jdk.internal.org.jline.utils.AttributedString;\n+\n+import java.util.*;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+public class CompletionMatcherImpl implements CompletionMatcher {\n+    protected Predicate<String> exact;\n+    protected List<Function<Map<String, List<Candidate>>, Map<String, List<Candidate>>>> matchers;\n+    private Map<String, List<Candidate>> matching;\n+    private boolean caseInsensitive;\n+\n+    public CompletionMatcherImpl() {\n+    }\n+\n+    protected void reset(boolean caseInsensitive) {\n+        this.caseInsensitive = caseInsensitive;\n+        exact = s -> false;\n+        matchers = new ArrayList<>();\n+        matching = null;\n+    }\n+\n+    @Override\n+    public void compile(Map<LineReader.Option, Boolean> options, boolean prefix, CompletingParsedLine line\n+            , boolean caseInsensitive, int errors, String originalGroupName) {\n+        reset(caseInsensitive);\n+        defaultMatchers(options, prefix, line, caseInsensitive, errors, originalGroupName);\n+    }\n+\n+    @Override\n+    public List<Candidate> matches(List<Candidate> candidates) {\n+        matching = Collections.emptyMap();\n+        Map<String, List<Candidate>> sortedCandidates = sort(candidates);\n+        for (Function<Map<String, List<Candidate>>,\n+                Map<String, List<Candidate>>> matcher : matchers) {\n+            matching = matcher.apply(sortedCandidates);\n+            if (!matching.isEmpty()) {\n+                break;\n+            }\n+        }\n+        return !matching.isEmpty() ? matching.entrySet().stream().flatMap(e -> e.getValue().stream()).collect(Collectors.toList())\n+                                   : new ArrayList<>();\n+    }\n+\n+    @Override\n+    public Candidate exactMatch() {\n+        if (matching == null) {\n+            throw new IllegalStateException();\n+        }\n+        return matching.values().stream().flatMap(Collection::stream)\n+                .filter(Candidate::complete)\n+                .filter(c -> exact.test(c.value()))\n+                .findFirst().orElse(null);\n+    }\n+\n+    @Override\n+    public String getCommonPrefix() {\n+        if (matching == null) {\n+            throw new IllegalStateException();\n+        }\n+        String commonPrefix = null;\n+        for (String key : matching.keySet()) {\n+            commonPrefix = commonPrefix == null ? key : getCommonStart(commonPrefix, key, caseInsensitive);\n+        }\n+        return commonPrefix;\n+    }\n+\n+    \/**\n+     * Default JLine matchers\n+     *\/\n+    protected void defaultMatchers(Map<LineReader.Option, Boolean> options, boolean prefix, CompletingParsedLine line\n+            , boolean caseInsensitive, int errors, String originalGroupName) {\n+        \/\/ Find matchers\n+        \/\/ TODO: glob completion\n+        String wd = line.word();\n+        String wdi = caseInsensitive ? wd.toLowerCase() : wd;\n+        String wp = wdi.substring(0, line.wordCursor());\n+        if (prefix) {\n+            matchers = new ArrayList<>(Arrays.asList(\n+                    simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).startsWith(wp)),\n+                    simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).contains(wp))\n+            ));\n+            if (LineReader.Option.COMPLETE_MATCHER_TYPO.isSet(options)) {\n+                matchers.add(typoMatcher(wp, errors, caseInsensitive, originalGroupName));\n+            }\n+            exact = s -> caseInsensitive ? s.equalsIgnoreCase(wp) : s.equals(wp);\n+        } else if (!LineReader.Option.EMPTY_WORD_OPTIONS.isSet(options) && wd.length() == 0) {\n+            matchers = new ArrayList<>(Collections.singletonList(simpleMatcher(s -> !s.startsWith(\"-\"))));\n+            exact = s -> caseInsensitive ? s.equalsIgnoreCase(wd) : s.equals(wd);\n+        } else {\n+            if (LineReader.Option.COMPLETE_IN_WORD.isSet(options)) {\n+                String ws = wdi.substring(line.wordCursor());\n+                Pattern p1 = Pattern.compile(Pattern.quote(wp) + \".*\" + Pattern.quote(ws) + \".*\");\n+                Pattern p2 = Pattern.compile(\".*\" + Pattern.quote(wp) + \".*\" + Pattern.quote(ws) + \".*\");\n+                matchers = new ArrayList<>(Arrays.asList(\n+                        simpleMatcher(s -> p1.matcher(caseInsensitive ? s.toLowerCase() : s).matches()),\n+                        simpleMatcher(s -> p2.matcher(caseInsensitive ? s.toLowerCase() : s).matches())\n+                ));\n+            } else {\n+                matchers = new ArrayList<>(Arrays.asList(\n+                        simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).startsWith(wdi)),\n+                        simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).contains(wdi))\n+                ));\n+            }\n+            if (LineReader.Option.COMPLETE_MATCHER_CAMELCASE.isSet(options)) {\n+                matchers.add(simpleMatcher(s -> camelMatch(wd, 0, s, 0)));\n+            }\n+            if (LineReader.Option.COMPLETE_MATCHER_TYPO.isSet(options)) {\n+                matchers.add(typoMatcher(wdi, errors, caseInsensitive, originalGroupName));\n+            }\n+            exact = s -> caseInsensitive ? s.equalsIgnoreCase(wd) : s.equals(wd);\n+        }\n+    }\n+\n+    protected Function<Map<String, List<Candidate>>,\n+            Map<String, List<Candidate>>> simpleMatcher(Predicate<String> predicate) {\n+        return m -> m.entrySet().stream()\n+                .filter(e -> predicate.test(e.getKey()))\n+                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    protected Function<Map<String, List<Candidate>>,\n+            Map<String, List<Candidate>>> typoMatcher(String word, int errors, boolean caseInsensitive, String originalGroupName) {\n+        return m -> {\n+            Map<String, List<Candidate>> map = m.entrySet().stream()\n+                    .filter(e -> ReaderUtils.distance(word, caseInsensitive ? e.getKey().toLowerCase() : e.getKey()) < errors)\n+                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+            if (map.size() > 1) {\n+                map.computeIfAbsent(word, w -> new ArrayList<>())\n+                        .add(new Candidate(word, word, originalGroupName, null, null, null, false));\n+            }\n+            return map;\n+        };\n+    }\n+\n+    protected boolean camelMatch(String word, int i, String candidate, int j) {\n+        if (word.length() <= i) {\n+            return true;\n+        } else if (candidate.length() <= j) {\n+            return false;\n+        } else {\n+            char c = word.charAt(i);\n+            if (c == candidate.charAt(j)) {\n+                return camelMatch(word, i + 1, candidate, j + 1);\n+            } else {\n+                for (int j1 = j; j1 < candidate.length(); j1++) {\n+                    if (Character.isUpperCase(candidate.charAt(j1))) {\n+                        if (Character.toUpperCase(c) == candidate.charAt(j1)) {\n+                            if (camelMatch(word, i + 1, candidate, j1 + 1)) {\n+                                return true;\n+                            }\n+                        }\n+                    }\n+                }\n+                return false;\n+            }\n+        }\n+    }\n+\n+    private Map<String, List<Candidate>> sort(List<Candidate> candidates) {\n+        \/\/ Build a list of sorted candidates\n+        Map<String, List<Candidate>> sortedCandidates = new HashMap<>();\n+        for (Candidate candidate : candidates) {\n+            sortedCandidates\n+                    .computeIfAbsent(AttributedString.fromAnsi(candidate.value()).toString(), s -> new ArrayList<>())\n+                    .add(candidate);\n+        }\n+        return sortedCandidates;\n+    }\n+\n+    private String getCommonStart(String str1, String str2, boolean caseInsensitive) {\n+        int[] s1 = str1.codePoints().toArray();\n+        int[] s2 = str2.codePoints().toArray();\n+        int len = 0;\n+        while (len < Math.min(s1.length, s2.length)) {\n+            int ch1 = s1[len];\n+            int ch2 = s2[len];\n+            if (ch1 != ch2 && caseInsensitive) {\n+                ch1 = Character.toUpperCase(ch1);\n+                ch2 = Character.toUpperCase(ch2);\n+                if (ch1 != ch2) {\n+                    ch1 = Character.toLowerCase(ch1);\n+                    ch2 = Character.toLowerCase(ch2);\n+                }\n+            }\n+            if (ch1 != ch2) {\n+                break;\n+            }\n+            len++;\n+        }\n+        return new String(s1, 0, len);\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/CompletionMatcherImpl.java","additions":210,"deletions":0,"binary":false,"changes":210,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author or authors.\n@@ -22,2 +22,2 @@\n-    private Pattern errorPattern;\n-    private int errorIndex = -1;\n+    protected Pattern errorPattern;\n+    protected int errorIndex = -1;\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/DefaultHighlighter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-        ANGLE;   \/\/ <>\n+        ANGLE    \/\/ <>\n@@ -42,2 +42,2 @@\n-    private String regexVariable = \"[a-zA-Z_]{1,}[a-zA-Z0-9_-]*((.|\\\\['|\\\\[\\\\\\\"|\\\\[)[a-zA-Z0-9_-]*(|'\\\\]|\\\\\\\"\\\\]|\\\\])){0,1}\";\n-    private String regexCommand = \"[:]{0,1}[a-zA-Z]{1,}[a-zA-Z0-9_-]*\";\n+    private String regexVariable = \"[a-zA-Z_]+[a-zA-Z0-9_-]*((\\\\.|\\\\['|\\\\[\\\"|\\\\[)[a-zA-Z0-9_-]*(|']|\\\"]|]))?\";\n+    private String regexCommand = \"[:]?[a-zA-Z]+[a-zA-Z0-9_-]*\";\n@@ -178,1 +178,1 @@\n-        return name != null && name.matches(regexVariable);\n+        return name != null && regexVariable != null && name.matches(regexVariable);\n@@ -185,9 +185,8 @@\n-        Pattern  patternCommand = Pattern.compile(\"^\\\\s*\" + regexVariable + \"=(\" + regexCommand + \")(\\\\s+.*|$)\");\n-        Matcher matcher = patternCommand.matcher(line);\n-        if (matcher.find()) {\n-            out = matcher.group(commandGroup);\n-        } else {\n-            out = line.trim().split(\"\\\\s+\")[0];\n-            int idx = out.indexOf(\"=\");\n-            if (idx > -1) {\n-                out = out.substring(idx + 1);\n+        boolean checkCommandOnly = regexVariable == null;\n+        if (!checkCommandOnly) {\n+            Pattern patternCommand = Pattern.compile(\"^\\\\s*\" + regexVariable + \"=(\" + regexCommand + \")(\\\\s+|$)\");\n+            Matcher matcher = patternCommand.matcher(line);\n+            if (matcher.find()) {\n+                out = matcher.group(commandGroup);\n+            } else {\n+                checkCommandOnly = true;\n@@ -195,0 +194,3 @@\n+        }\n+        if (checkCommandOnly) {\n+            out = line.trim().split(\"\\\\s+\")[0];\n@@ -205,4 +207,6 @@\n-        Pattern  patternCommand = Pattern.compile(\"^\\\\s*(\" + regexVariable + \")\\\\s*=[^=~].*\");\n-        Matcher matcher = patternCommand.matcher(line);\n-        if (matcher.find()) {\n-            out = matcher.group(1);\n+        if (regexVariable != null) {\n+            Pattern patternCommand = Pattern.compile(\"^\\\\s*(\" + regexVariable + \")\\\\s*=[^=~].*\");\n+            Matcher matcher = patternCommand.matcher(line);\n+            if (matcher.find()) {\n+                out = matcher.group(1);\n+            }\n@@ -292,1 +296,1 @@\n-        if (context != ParseContext.COMPLETE) {\n+        if (context != ParseContext.COMPLETE && context != ParseContext.SPLIT_LINE) {\n@@ -612,19 +616,22 @@\n-                \/\/ Completion is protected by an opening quote:\n-                \/\/ Delimiters (spaces) don't need to be escaped, nor do other quotes, but everything else does.\n-                \/\/ Also, close the quote at the end\n-                if (openingQuote != null) {\n-                    needToBeEscaped = i -> isRawEscapeChar(sb.charAt(i)) || String.valueOf(sb.charAt(i)).equals(openingQuote);\n-                }\n-                \/\/ Completion is protected by middle quotes:\n-                \/\/ Delimiters (spaces) don't need to be escaped, nor do quotes, but everything else does.\n-                else if (middleQuotes) {\n-                    needToBeEscaped = i -> isRawEscapeChar(sb.charAt(i));\n-                }\n-                \/\/ No quote protection, need to escape everything: delimiter chars (spaces), quote chars\n-                \/\/ and escapes themselves\n-                else {\n-                    needToBeEscaped = i -> isDelimiterChar(sb, i) || isRawEscapeChar(sb.charAt(i)) || isRawQuoteChar(sb.charAt(i));\n-                }\n-                for (int i = 0; i < sb.length(); i++) {\n-                    if (needToBeEscaped.test(i)) {\n-                        sb.insert(i++, escapeChars[0]);\n+                if (escapeChars.length > 0) {\n+                    \/\/ Completion is protected by an opening quote:\n+                    \/\/ Delimiters (spaces) don't need to be escaped, nor do other quotes, but everything else does.\n+                    \/\/ Also, close the quote at the end\n+                    if (openingQuote != null) {\n+                        needToBeEscaped = i -> isRawEscapeChar(sb.charAt(i)) || String.valueOf(sb.charAt(i)).equals(openingQuote);\n+                    }\n+                    \/\/ Completion is protected by middle quotes:\n+                    \/\/ Delimiters (spaces) don't need to be escaped, nor do quotes, but everything else does.\n+                    else if (middleQuotes) {\n+                        needToBeEscaped = i -> isRawEscapeChar(sb.charAt(i));\n+                    }\n+                    \/\/ No quote protection, need to escape everything: delimiter chars (spaces), quote chars\n+                    \/\/ and escapes themselves\n+                    else {\n+                        needToBeEscaped = i -> isDelimiterChar(sb, i) || isRawEscapeChar(sb.charAt(i))\n+                                || isRawQuoteChar(sb.charAt(i));\n+                    }\n+                    for (int i = 0; i < sb.length(); i++) {\n+                        if (needToBeEscaped.test(i)) {\n+                            sb.insert(i++, escapeChars[0]);\n+                        }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/DefaultParser.java","additions":44,"deletions":37,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -23,1 +23,0 @@\n-import java.util.Map.Entry;\n@@ -49,1 +48,0 @@\n-import jdk.internal.org.jline.utils.Levenshtein;\n@@ -52,0 +50,1 @@\n+import jdk.internal.org.jline.utils.StyleResolver;\n@@ -83,0 +82,1 @@\n+    public static final int    DEFAULT_MENU_LIST_MAX = Integer.MAX_VALUE;\n@@ -89,4 +89,10 @@\n-    public static final String DEFAULT_COMPLETION_STYLE_STARTING = \"36\";    \/\/ cyan\n-    public static final String DEFAULT_COMPLETION_STYLE_DESCRIPTION = \"90\"; \/\/ dark gray\n-    public static final String DEFAULT_COMPLETION_STYLE_GROUP = \"35;1\";     \/\/ magenta\n-    public static final String DEFAULT_COMPLETION_STYLE_SELECTION = \"7\";    \/\/ inverted\n+    public static final String DEFAULT_COMPLETION_STYLE_STARTING = \"fg:cyan\";\n+    public static final String DEFAULT_COMPLETION_STYLE_DESCRIPTION = \"fg:bright-black\";\n+    public static final String DEFAULT_COMPLETION_STYLE_GROUP = \"fg:bright-magenta,bold\";\n+    public static final String DEFAULT_COMPLETION_STYLE_SELECTION = \"inverse\";\n+    public static final String DEFAULT_COMPLETION_STYLE_BACKGROUND = \"bg:default\";\n+    public static final String DEFAULT_COMPLETION_STYLE_LIST_STARTING = DEFAULT_COMPLETION_STYLE_STARTING;\n+    public static final String DEFAULT_COMPLETION_STYLE_LIST_DESCRIPTION = DEFAULT_COMPLETION_STYLE_DESCRIPTION;\n+    public static final String DEFAULT_COMPLETION_STYLE_LIST_GROUP = \"fg:black,bold\";\n+    public static final String DEFAULT_COMPLETION_STYLE_LIST_SELECTION = DEFAULT_COMPLETION_STYLE_SELECTION;\n+    public static final String DEFAULT_COMPLETION_STYLE_LIST_BACKGROUND = \"bg:bright-magenta\";\n@@ -95,0 +101,1 @@\n+    public static final int    DEFAULT_SUGGESTIONS_MIN_BUFFER_SIZE = 1;\n@@ -165,0 +172,1 @@\n+    protected CompletionMatcher completionMatcher = new CompletionMatcherImpl();\n@@ -273,0 +281,2 @@\n+    int candidateStartPosition = 0;\n+\n@@ -422,0 +432,4 @@\n+    public void setCompletionMatcher(CompletionMatcher completionMatcher) {\n+        this.completionMatcher = completionMatcher;\n+    }\n+\n@@ -639,1 +653,1 @@\n-                    throw new EndOfFileException();\n+                    throw new EndOfFileException().partialLine(buf.length() > 0 ? buf.toString() : null);\n@@ -744,5 +758,1 @@\n-        if (size.getRows() == 0 || size.getColumns() == 0) {\n-            display.resize(1, Integer.MAX_VALUE);\n-        } else {\n-            display.resize(size.getRows(), size.getColumns());\n-        }\n+        display.resize(size.getRows(), size.getColumns());\n@@ -1052,2 +1062,1 @@\n-        Boolean b = options.get(option);\n-        return b != null ? b : option.isDef();\n+        return option.isSet(options);\n@@ -1073,0 +1082,3 @@\n+        if (isSet(Option.BRACKETED_PASTE)) {\n+            terminal.writer().write(BRACKETED_PASTE_OFF);\n+        }\n@@ -1076,1 +1088,1 @@\n-        editor.open(Arrays.asList(file.getName()));\n+        editor.open(Collections.singletonList(file.getName()));\n@@ -1347,1 +1359,1 @@\n-            return callNeg(this::backwardWord);\n+            return callNeg(this::viBackwardWord);\n@@ -1398,15 +1410,1 @@\n-        if (count < 0) {\n-            return callNeg(this::emacsBackwardWord);\n-        }\n-        while (count-- > 0) {\n-            while (buf.cursor() < buf.length() && !isWord(buf.currChar())) {\n-                buf.move(1);\n-            }\n-            if (isInViChangeOperation() && count == 0) {\n-                return true;\n-            }\n-            while (buf.cursor() < buf.length() && isWord(buf.currChar())) {\n-                buf.move(1);\n-            }\n-        }\n-        return true;\n+        return forwardWord();\n@@ -1484,1 +1482,1 @@\n-            return callNeg(this::backwardWord);\n+            return callNeg(this::viForwardWord);\n@@ -1587,18 +1585,1 @@\n-        if (count < 0) {\n-            return callNeg(this::emacsForwardWord);\n-        }\n-        while (count-- > 0) {\n-            while (buf.cursor() > 0) {\n-                buf.move(-1);\n-                if (isWord(buf.currChar())) {\n-                    break;\n-                }\n-            }\n-            while (buf.cursor() > 0) {\n-                buf.move(-1);\n-                if (!isWord(buf.currChar())) {\n-                    break;\n-                }\n-            }\n-        }\n-        return true;\n+        return backwardWord();\n@@ -2560,1 +2541,1 @@\n-            if (isSet(Option.BRACKETED_PASTE))\n+            if (isSet(Option.BRACKETED_PASTE) && !isTerminalDumb())\n@@ -2723,1 +2704,1 @@\n-   }\n+    }\n@@ -3911,1 +3892,1 @@\n-            int displaySize = size.getRows() - (status != null ? status.size() : 0);\n+            int displaySize = displayRows(status);\n@@ -3967,3 +3948,3 @@\n-        char prev = '0';\n-        for (char c: buffer.toCharArray()) {\n-            if ((c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}' || c == '^') && prev != '\\\\' ) {\n+        for (char c: buffer.replace(\"\\\\\", \"\\\\\\\\\").toCharArray()) {\n+            if (c == '(' || c == ')' || c == '[' || c == ']' || c == '{' || c == '}' || c == '^' || c == '*'\n+                     || c == '$' || c == '.' || c == '?' || c == '+') {\n@@ -3973,1 +3954,0 @@\n-            prev = c;\n@@ -4005,1 +3985,1 @@\n-        if (doAutosuggestion) {\n+        if (doAutosuggestion && !isTerminalDumb()) {\n@@ -4013,2 +3993,3 @@\n-                if (buf.length() > 0 && buf.length() == buf.cursor()\n-                    && (!lastBinding.equals(\"\\t\") || buf.prevChar() == ' ' || buf.prevChar() == '=')) {\n+                if (buf.length() >= getInt(SUGGESTIONS_MIN_BUFFER_SIZE, DEFAULT_SUGGESTIONS_MIN_BUFFER_SIZE)\n+                        && buf.length() == buf.cursor()\n+                        && (!lastBinding.equals(\"\\t\") || buf.prevChar() == ' ' || buf.prevChar() == '=')) {\n@@ -4187,0 +4168,3 @@\n+            if (width > size.getColumns() || prompt.contains('\\n')) {\n+                width = new TerminalLine(prompt.toString(), 0, size.getColumns()).getEndLine().length();\n+            }\n@@ -4401,0 +4385,3 @@\n+            if (Log.isDebugEnabled()) {\n+                e.printStackTrace();\n+            }\n@@ -4426,52 +4413,1 @@\n-        \/\/ Build a list of sorted candidates\n-        Map<String, List<Candidate>> sortedCandidates = new HashMap<>();\n-        for (Candidate cand : candidates) {\n-            sortedCandidates\n-                    .computeIfAbsent(AttributedString.fromAnsi(cand.value()).toString(), s -> new ArrayList<>())\n-                    .add(cand);\n-        }\n-\n-        \/\/ Find matchers\n-        \/\/ TODO: glob completion\n-        List<Function<Map<String, List<Candidate>>,\n-                      Map<String, List<Candidate>>>> matchers;\n-        Predicate<String> exact;\n-        if (prefix) {\n-            String wd = line.word();\n-            String wdi = caseInsensitive ? wd.toLowerCase() : wd;\n-            String wp = wdi.substring(0, line.wordCursor());\n-            matchers = Arrays.asList(\n-                    simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).startsWith(wp)),\n-                    simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).contains(wp)),\n-                    typoMatcher(wp, errors, caseInsensitive)\n-            );\n-            exact = s -> caseInsensitive ? s.equalsIgnoreCase(wp) : s.equals(wp);\n-        } else if (isSet(Option.COMPLETE_IN_WORD)) {\n-            String wd = line.word();\n-            String wdi = caseInsensitive ? wd.toLowerCase() : wd;\n-            String wp = wdi.substring(0, line.wordCursor());\n-            String ws = wdi.substring(line.wordCursor());\n-            Pattern p1 = Pattern.compile(Pattern.quote(wp) + \".*\" + Pattern.quote(ws) + \".*\");\n-            Pattern p2 = Pattern.compile(\".*\" + Pattern.quote(wp) + \".*\" + Pattern.quote(ws) + \".*\");\n-            matchers = Arrays.asList(\n-                    simpleMatcher(s -> p1.matcher(caseInsensitive ? s.toLowerCase() : s).matches()),\n-                    simpleMatcher(s -> p2.matcher(caseInsensitive ? s.toLowerCase() : s).matches()),\n-                    typoMatcher(wdi, errors, caseInsensitive)\n-            );\n-            exact = s -> caseInsensitive ? s.equalsIgnoreCase(wd) : s.equals(wd);\n-        } else {\n-            String wd = line.word();\n-            String wdi = caseInsensitive ? wd.toLowerCase() : wd;\n-            if (isSet(Option.EMPTY_WORD_OPTIONS) || wd.length() > 0) {\n-                matchers = Arrays.asList(\n-                        simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).startsWith(wdi)),\n-                        simpleMatcher(s -> (caseInsensitive ? s.toLowerCase() : s).contains(wdi)),\n-                        typoMatcher(wdi, errors, caseInsensitive)\n-                );\n-            } else {\n-                matchers = Arrays.asList(\n-                        simpleMatcher(s -> !s.startsWith(\"-\"))\n-                );\n-            }\n-            exact = s -> caseInsensitive ? s.equalsIgnoreCase(wd) : s.equals(wd);\n-        }\n+        completionMatcher.compile(options, prefix, line, caseInsensitive, errors, getOriginalGroupName());\n@@ -4479,9 +4415,1 @@\n-        Map<String, List<Candidate>> matching = Collections.emptyMap();\n-        for (Function<Map<String, List<Candidate>>,\n-                      Map<String, List<Candidate>>> matcher : matchers) {\n-            matching = matcher.apply(sortedCandidates);\n-            if (!matching.isEmpty()) {\n-                break;\n-            }\n-        }\n-\n+        List<Candidate> possible = completionMatcher.matches(candidates);\n@@ -4489,1 +4417,1 @@\n-        if (matching.isEmpty()) {\n+        if (possible.isEmpty()) {\n@@ -4496,3 +4424,0 @@\n-                List<Candidate> possible = matching.entrySet().stream()\n-                        .flatMap(e -> e.getValue().stream())\n-                        .collect(Collectors.toList());\n@@ -4506,3 +4431,2 @@\n-            if (matching.size() == 1) {\n-                completion = matching.values().stream().flatMap(Collection::stream)\n-                        .findFirst().orElse(null);\n+            if (possible.size() == 1) {\n+                completion = possible.get(0);\n@@ -4512,4 +4436,1 @@\n-                completion = matching.values().stream().flatMap(Collection::stream)\n-                        .filter(Candidate::complete)\n-                        .filter(c -> exact.test(c.value()))\n-                        .findFirst().orElse(null);\n+                completion = completionMatcher.exactMatch();\n@@ -4534,0 +4455,3 @@\n+                    if (autosuggestion == SuggestionType.COMPLETER) {\n+                        listChoices(true);\n+                    }\n@@ -4552,4 +4476,0 @@\n-            List<Candidate> possible = matching.entrySet().stream()\n-                    .flatMap(e -> e.getValue().stream())\n-                    .collect(Collectors.toList());\n-\n@@ -4573,4 +4493,1 @@\n-            String commonPrefix = null;\n-            for (String key : matching.keySet()) {\n-                commonPrefix = commonPrefix == null ? key : getCommonStart(commonPrefix, key, caseInsensitive);\n-            }\n+            String commonPrefix = completionMatcher.getCommonPrefix();\n@@ -4644,1 +4561,1 @@\n-        ToIntFunction<String> wordDistance = w -> distance(wdi, caseInsensitive ? w.toLowerCase() : w);\n+        ToIntFunction<String> wordDistance = w -> ReaderUtils.distance(wdi, caseInsensitive ? w.toLowerCase() : w);\n@@ -4691,31 +4608,0 @@\n-    private Function<Map<String, List<Candidate>>,\n-                     Map<String, List<Candidate>>> simpleMatcher(Predicate<String> pred) {\n-        return m -> m.entrySet().stream()\n-                .filter(e -> pred.test(e.getKey()))\n-                .collect(Collectors.toMap(Entry::getKey, Entry::getValue));\n-    }\n-\n-    private Function<Map<String, List<Candidate>>,\n-                     Map<String, List<Candidate>>> typoMatcher(String word, int errors, boolean caseInsensitive) {\n-        return m -> {\n-            Map<String, List<Candidate>> map = m.entrySet().stream()\n-                    .filter(e -> distance(word, caseInsensitive ? e.getKey() : e.getKey().toLowerCase()) < errors)\n-                    .collect(Collectors.toMap(Entry::getKey, Entry::getValue));\n-            if (map.size() > 1) {\n-                map.computeIfAbsent(word, w -> new ArrayList<>())\n-                        .add(new Candidate(word, word, getOriginalGroupName(), null, null, null, false));\n-            }\n-            return map;\n-        };\n-    }\n-\n-    private int distance(String word, String cand) {\n-        if (word.length() < cand.length()) {\n-            int d1 = Levenshtein.distance(word, cand.substring(0, Math.min(cand.length(), word.length())));\n-            int d2 = Levenshtein.distance(word, cand);\n-            return Math.min(d1, d2);\n-        } else {\n-            return Levenshtein.distance(word, cand);\n-        }\n-    }\n-\n@@ -4734,0 +4620,13 @@\n+    private int displayRows() {\n+        return displayRows(Status.getStatus(terminal, false));\n+    }\n+\n+    private int displayRows(Status status) {\n+        return size.getRows() - (status != null ? status.size() : 0);\n+    }\n+\n+    private int promptLines() {\n+        AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList<>());\n+        return text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();\n+    }\n+\n@@ -4853,4 +4752,1 @@\n-            AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList<>());\n-            int promptLines = text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();\n-            Status status = Status.getStatus(terminal, false);\n-            int displaySize = size.getRows() - (status != null ? status.size() : 0) - promptLines;\n+            int displaySize = displayRows() - promptLines();\n@@ -4905,1 +4801,7 @@\n-\n+        \/\/ candidate grouping is not supported by MenuSupport\n+        boolean defaultAutoGroup = isSet(Option.AUTO_GROUP);\n+        boolean defaultGroup = isSet(Option.GROUP);\n+        if (!isSet(Option.GROUP_PERSIST)) {\n+            option(Option.AUTO_GROUP, false);\n+            option(Option.GROUP, false);\n+        }\n@@ -4962,0 +4864,2 @@\n+                    option(Option.AUTO_GROUP, defaultAutoGroup);\n+                    option(Option.GROUP, defaultGroup);\n@@ -4968,0 +4872,2 @@\n+        option(Option.AUTO_GROUP, defaultAutoGroup);\n+        option(Option.GROUP, defaultGroup);\n@@ -4972,1 +4878,1 @@\n-        return doList(new ArrayList<Candidate>(), \"\", false, null, false);\n+        return doList(new ArrayList<>(), \"\", false, null, false);\n@@ -5012,0 +4918,1 @@\n+        candidateStartPosition = 0;\n@@ -5016,4 +4923,3 @@\n-                cands = possible.stream()\n-                        .filter(c -> caseInsensitive\n-                                    ? c.value().toLowerCase().startsWith(current.toLowerCase())\n-                                    : c.value().startsWith(current))\n+                completionMatcher.compile(options, false, new CompletingWord(current), caseInsensitive, 0\n+                        , null);\n+                cands = completionMatcher.matches(possible).stream()\n@@ -5027,0 +4933,3 @@\n+            if (isSet(Option.AUTO_MENU_LIST) && candidateStartPosition == 0) {\n+                candidateStartPosition = candidateStartPosition(cands);\n+            }\n@@ -5038,1 +4947,1 @@\n-                    List<AttributedString> ls = postResult.post.columnSplitLength(size.getColumns(), false, display.delayLineWrap());\n+                    List<AttributedString> ls = pr.post.columnSplitLength(size.getColumns(), false, display.delayLineWrap());\n@@ -5042,0 +4951,1 @@\n+                    println();\n@@ -5092,0 +5002,53 @@\n+    private static class CompletingWord implements CompletingParsedLine {\n+        private final String word;\n+\n+        public CompletingWord(String word) {\n+            this.word = word;\n+        }\n+\n+        @Override\n+        public CharSequence escape(CharSequence candidate, boolean complete) {\n+            return null;\n+        }\n+\n+        @Override\n+        public int rawWordCursor() {\n+            return word.length();\n+        }\n+\n+        @Override\n+        public int rawWordLength() {\n+            return word.length();\n+        }\n+\n+        @Override\n+        public String word() {\n+            return word;\n+        }\n+\n+        @Override\n+        public int wordCursor() {\n+            return word.length();\n+        }\n+\n+        @Override\n+        public int wordIndex() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public List<String> words() {\n+            return null;\n+        }\n+\n+        @Override\n+        public String line() {\n+            return word;\n+        }\n+\n+        @Override\n+        public int cursor() {\n+            return word.length();\n+        }\n+    }\n+\n@@ -5159,0 +5122,57 @@\n+    private static final int MENU_LIST_WIDTH = 25;\n+\n+    private static class TerminalLine {\n+        private String endLine;\n+        private int startPos;\n+\n+        public TerminalLine(String line, int startPos, int width) {\n+            this.startPos = startPos;\n+            endLine = line.substring(line.lastIndexOf('\\n') + 1);\n+            boolean first = true;\n+            while (endLine.length() + (first ? startPos : 0) > width) {\n+                if (first) {\n+                    endLine = endLine.substring(width - startPos);\n+                } else {\n+                    endLine = endLine.substring(width);\n+                }\n+                first = false;\n+            }\n+            if (!first) {\n+                this.startPos = 0;\n+            }\n+        }\n+\n+        public int getStartPos() {\n+            return startPos;\n+        }\n+\n+        public String getEndLine() {\n+            return endLine;\n+        }\n+    }\n+\n+    private int candidateStartPosition(List<Candidate> cands) {\n+        List<String> values = cands.stream().map(c -> AttributedString.stripAnsi(c.displ()))\n+                .filter(c -> !c.matches(\"\\\\w+\") && c.length() > 1).collect(Collectors.toList());\n+        Set<String> notDelimiters = new HashSet<>();\n+        values.forEach(v -> v.substring(0, v.length() - 1).chars()\n+                .filter(c -> !Character.isDigit(c) && !Character.isAlphabetic(c))\n+                .forEach(c -> notDelimiters.add(Character.toString((char)c))));\n+        int width = size.getColumns();\n+        int promptLength = prompt != null ? prompt.length() : 0;\n+        if (promptLength > 0) {\n+            TerminalLine tp = new TerminalLine(prompt.toString(), 0, width);\n+            promptLength = tp.getEndLine().length();\n+        }\n+        TerminalLine tl = new TerminalLine(buf.substring(0, buf.cursor()), promptLength, width);\n+        int out = tl.getStartPos();\n+        String buffer = tl.getEndLine();\n+        for (int i = buffer.length(); i > 0; i--) {\n+            if (buffer.substring(0, i).matches(\".*\\\\W\")\n+                    && !notDelimiters.contains(buffer.substring(i - 1, i))) {\n+                out += i;\n+                break;\n+            }\n+        }\n+        return out;\n+    }\n@@ -5166,0 +5186,1 @@\n+        int listSize = 0;\n@@ -5173,0 +5194,1 @@\n+                    listSize++;\n@@ -5186,2 +5208,27 @@\n-        for (Object list : items) {\n-            toColumns(list, width, maxWidth, sb, selection, completed, rowsFirst, out);\n+        if (listSize > 0) {\n+            if (isSet(Option.AUTO_MENU_LIST)\n+                    && listSize < Math.min(getInt(MENU_LIST_MAX, DEFAULT_MENU_LIST_MAX), displayRows() - promptLines())) {\n+                maxWidth = Math.max(maxWidth, MENU_LIST_WIDTH);\n+                sb.tabs(Math.max(Math.min(candidateStartPosition, width - maxWidth - 1), 1));\n+                width = maxWidth + 2;\n+                if (!isSet(Option.GROUP_PERSIST)) {\n+                    List<Candidate> list = new ArrayList<>();\n+                    for (Object o : items) {\n+                        if (o instanceof Collection) {\n+                            list.addAll((Collection<Candidate>) o);\n+                        }\n+                    }\n+                    list = list.stream()\n+                            .sorted(getCandidateComparator(isSet(Option.CASE_INSENSITIVE), \"\"))\n+                            .collect(Collectors.toList());\n+                    toColumns(list, width, maxWidth, sb, selection, completed, rowsFirst, true, out);\n+                } else {\n+                    for (Object list : items) {\n+                        toColumns(list, width, maxWidth, sb, selection, completed, rowsFirst, true, out);\n+                    }\n+                }\n+            } else {\n+                for (Object list : items) {\n+                    toColumns(list, width, maxWidth, sb, selection, completed, rowsFirst, false, out);\n+                }\n+            }\n@@ -5196,1 +5243,2 @@\n-    protected void toColumns(Object items, int width, int maxWidth, AttributedStringBuilder sb, Candidate selection, String completed, boolean rowsFirst, int[] out) {\n+    protected void toColumns(Object items, int width, int maxWidth, AttributedStringBuilder sb, Candidate selection, String completed\n+                           , boolean rowsFirst, boolean doMenuList, int[] out) {\n@@ -5202,1 +5250,6 @@\n-            sb.style(getCompletionStyleGroup())\n+            if (doMenuList) {\n+                sb.style(AttributedStyle.DEFAULT);\n+                sb.append('\\t');\n+            }\n+            AttributedStringBuilder asb = new AttributedStringBuilder();\n+            asb.style(getCompletionStyleGroup(doMenuList))\n@@ -5204,2 +5257,9 @@\n-                    .style(AttributedStyle.DEFAULT)\n-                    .append(\"\\n\");\n+                    .style(AttributedStyle.DEFAULT);\n+            if (doMenuList) {\n+                for (int k = ((String) items).length(); k < maxWidth + 1; k++) {\n+                    asb.append(' ');\n+                }\n+            }\n+            sb.style(getCompletionStyleBackground(doMenuList));\n+            sb.append(asb);\n+            sb.append(\"\\n\");\n@@ -5227,0 +5287,5 @@\n+                if (doMenuList) {\n+                    sb.style(AttributedStyle.DEFAULT);\n+                    sb.append('\\t');\n+                }\n+                AttributedStringBuilder asb = new AttributedStringBuilder();\n@@ -5251,1 +5316,1 @@\n-                            sb.style(getCompletionStyleSelection());\n+                            asb.style(getCompletionStyleSelection(doMenuList));\n@@ -5254,2 +5319,2 @@\n-                                sb.append(left.toString(), 0, completed.length());\n-                                sb.append(left.toString(), completed.length(), left.length());\n+                                asb.append(left.toString(), 0, completed.length());\n+                                asb.append(left.toString(), completed.length(), left.length());\n@@ -5257,1 +5322,1 @@\n-                                sb.append(left.toString());\n+                                asb.append(left.toString());\n@@ -5260,1 +5325,1 @@\n-                                sb.append(' ');\n+                                asb.append(' ');\n@@ -5263,1 +5328,1 @@\n-                                sb.append(right);\n+                                asb.append(right);\n@@ -5265,1 +5330,1 @@\n-                            sb.style(AttributedStyle.DEFAULT);\n+                            asb.style(AttributedStyle.DEFAULT);\n@@ -5269,4 +5334,4 @@\n-                                sb.style(getCompletionStyleStarting());\n-                                sb.append(left, 0, completed.length());\n-                                sb.style(AttributedStyle.DEFAULT);\n-                                sb.append(left, completed.length(), left.length());\n+                                asb.style(getCompletionStyleStarting(doMenuList));\n+                                asb.append(left, 0, completed.length());\n+                                asb.style(AttributedStyle.DEFAULT);\n+                                asb.append(left, completed.length(), left.length());\n@@ -5274,1 +5339,1 @@\n-                                sb.append(left);\n+                                asb.append(left);\n@@ -5278,1 +5343,1 @@\n-                                    sb.append(' ');\n+                                    asb.append(' ');\n@@ -5282,3 +5347,7 @@\n-                                sb.style(getCompletionStyleDescription());\n-                                sb.append(right);\n-                                sb.style(AttributedStyle.DEFAULT);\n+                                asb.style(getCompletionStyleDescription(doMenuList));\n+                                asb.append(right);\n+                                asb.style(AttributedStyle.DEFAULT);\n+                            } else if (doMenuList) {\n+                                for (int k = lw; k < maxWidth; k++) {\n+                                    asb.append(' ');\n+                                }\n@@ -5289,1 +5358,1 @@\n-                                sb.append(' ');\n+                                asb.append(' ');\n@@ -5292,0 +5361,3 @@\n+                        if (doMenuList) {\n+                            asb.append(' ');\n+                        }\n@@ -5294,0 +5366,2 @@\n+                sb.style(getCompletionStyleBackground(doMenuList));\n+                sb.append(asb);\n@@ -5300,1 +5374,21 @@\n-    private AttributedStyle getCompletionStyleStarting() {\n+    protected AttributedStyle getCompletionStyleStarting(boolean menuList) {\n+        return menuList ? getCompletionStyleListStarting() : getCompletionStyleStarting();\n+    }\n+\n+    protected AttributedStyle getCompletionStyleDescription(boolean menuList) {\n+        return menuList ? getCompletionStyleListDescription() : getCompletionStyleDescription();\n+    }\n+\n+    protected AttributedStyle getCompletionStyleGroup(boolean menuList) {\n+        return menuList ? getCompletionStyleListGroup() : getCompletionStyleGroup();\n+    }\n+\n+    protected AttributedStyle getCompletionStyleSelection(boolean menuList) {\n+        return menuList ? getCompletionStyleListSelection() : getCompletionStyleSelection();\n+    }\n+\n+    protected AttributedStyle getCompletionStyleBackground(boolean menuList) {\n+        return menuList ? getCompletionStyleListBackground() : getCompletionStyleBackground();\n+    }\n+\n+    protected AttributedStyle getCompletionStyleStarting() {\n@@ -5316,0 +5410,24 @@\n+    protected AttributedStyle getCompletionStyleBackground() {\n+        return getCompletionStyle(COMPLETION_STYLE_BACKGROUND, DEFAULT_COMPLETION_STYLE_BACKGROUND);\n+    }\n+\n+    protected AttributedStyle getCompletionStyleListStarting() {\n+        return getCompletionStyle(COMPLETION_STYLE_LIST_STARTING, DEFAULT_COMPLETION_STYLE_LIST_STARTING);\n+    }\n+\n+    protected AttributedStyle getCompletionStyleListDescription() {\n+        return getCompletionStyle(COMPLETION_STYLE_LIST_DESCRIPTION, DEFAULT_COMPLETION_STYLE_LIST_DESCRIPTION);\n+    }\n+\n+    protected AttributedStyle getCompletionStyleListGroup() {\n+        return getCompletionStyle(COMPLETION_STYLE_LIST_GROUP, DEFAULT_COMPLETION_STYLE_LIST_GROUP);\n+    }\n+\n+    protected AttributedStyle getCompletionStyleListSelection() {\n+        return getCompletionStyle(COMPLETION_STYLE_LIST_SELECTION, DEFAULT_COMPLETION_STYLE_LIST_SELECTION);\n+    }\n+\n+    protected AttributedStyle getCompletionStyleListBackground() {\n+        return getCompletionStyle(COMPLETION_STYLE_LIST_BACKGROUND, DEFAULT_COMPLETION_STYLE_LIST_BACKGROUND);\n+    }\n+\n@@ -5317,1 +5435,1 @@\n-        return buildStyle(getString(name, value));\n+        return new StyleResolver(s -> getString(s, null)).resolve(\".\" + name, value);\n@@ -5324,23 +5442,0 @@\n-    private String getCommonStart(String str1, String str2, boolean caseInsensitive) {\n-        int[] s1 = str1.codePoints().toArray();\n-        int[] s2 = str2.codePoints().toArray();\n-        int len = 0;\n-        while (len < Math.min(s1.length, s2.length)) {\n-            int ch1 = s1[len];\n-            int ch2 = s2[len];\n-            if (ch1 != ch2 && caseInsensitive) {\n-                ch1 = Character.toUpperCase(ch1);\n-                ch2 = Character.toUpperCase(ch2);\n-                if (ch1 != ch2) {\n-                    ch1 = Character.toLowerCase(ch1);\n-                    ch2 = Character.toLowerCase(ch2);\n-                }\n-            }\n-            if (ch1 != ch2) {\n-                break;\n-            }\n-            len++;\n-        }\n-        return new String(s1, 0, len);\n-    }\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/LineReaderImpl.java","additions":326,"deletions":231,"binary":false,"changes":557,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author or authors.\n@@ -12,0 +12,1 @@\n+import jdk.internal.org.jline.utils.Levenshtein;\n@@ -70,0 +71,10 @@\n+    public static int distance(String word, String cand) {\n+        if (word.length() < cand.length()) {\n+            int d1 = Levenshtein.distance(word, cand.substring(0, Math.min(cand.length(), word.length())));\n+            int d2 = Levenshtein.distance(word, cand);\n+            return Math.min(d1, d2);\n+        } else {\n+            return Levenshtein.distance(word, cand);\n+        }\n+    }\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/ReaderUtils.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -14,0 +14,1 @@\n+import java.util.Collections;\n@@ -31,1 +32,1 @@\n-    protected Collection<Candidate> candidates = new ArrayList<>();\n+    protected Collection<Candidate> candidates;\n@@ -35,0 +36,1 @@\n+        this(Collections.<Candidate>emptyList());\n@@ -49,0 +51,1 @@\n+        this.candidates = new ArrayList<>();\n@@ -60,1 +63,1 @@\n-        this.candidates.addAll(candidates);\n+        this.candidates = new ArrayList<>(candidates);\n@@ -63,0 +66,1 @@\n+    @Override\n@@ -75,0 +79,5 @@\n+    @Override\n+    public String toString() {\n+        String value = candidates != null ? candidates.toString() : \"{\" + stringsSupplier.toString() + \"}\";\n+        return \"StringsCompleter\" + value;\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/StringsCompleter.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2002-2020, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.reader.impl.completer;\n+\n+import java.util.*;\n+\n+import jdk.internal.org.jline.reader.Candidate;\n+import jdk.internal.org.jline.reader.Completer;\n+import jdk.internal.org.jline.reader.LineReader;\n+import jdk.internal.org.jline.reader.ParsedLine;\n+import jdk.internal.org.jline.utils.AttributedString;\n+\n+\/**\n+ * Completer which contains multiple completers and aggregates them together.\n+ *\n+ * @author <a href=\"mailto:matti.rintanikkola@gmail.com\">Matti Rinta-Nikkola<\/a>\n+ *\/\n+public class SystemCompleter implements Completer {\n+    private Map<String,List<Completer>> completers = new HashMap<>();\n+    private Map<String,String> aliasCommand = new HashMap<>();\n+    private StringsCompleter commands;\n+    private boolean compiled = false;\n+\n+    public SystemCompleter() {}\n+\n+    @Override\n+    public void complete(LineReader reader, ParsedLine commandLine, List<Candidate> candidates) {\n+        if (!compiled) {\n+            throw new IllegalStateException();\n+        }\n+        assert commandLine != null;\n+        assert candidates != null;\n+        if (commandLine.words().size() > 0) {\n+            if (commandLine.words().size() == 1) {\n+                String buffer = commandLine.words().get(0);\n+                int eq = buffer.indexOf('=');\n+                if (eq < 0) {\n+                    commands.complete(reader, commandLine, candidates);\n+                } else if (reader.getParser().validVariableName(buffer.substring(0, eq))) {\n+                    String curBuf = buffer.substring(0, eq + 1);\n+                    for (String c: completers.keySet()) {\n+                        candidates.add(new Candidate(AttributedString.stripAnsi(curBuf+c)\n+                                    , c, null, null, null, null, true));\n+                    }\n+                }\n+            } else {\n+                String cmd = reader.getParser().getCommand(commandLine.words().get(0));\n+                if (command(cmd) != null) {\n+                    completers.get(command(cmd)).get(0).complete(reader, commandLine, candidates);\n+                }\n+            }\n+        }\n+    }\n+\n+    public boolean isCompiled() {\n+        return compiled;\n+    }\n+\n+    private String command(String cmd) {\n+        String out = null;\n+        if (cmd != null) {\n+            if (completers.containsKey(cmd)) {\n+                out = cmd;\n+            } else if (aliasCommand.containsKey(cmd)) {\n+                out = aliasCommand.get(cmd);\n+            }\n+        }\n+        return out;\n+    }\n+\n+    public void add(String command, List<Completer> completers) {\n+        for (Completer c : completers) {\n+            add(command, c);\n+        }\n+    }\n+\n+    public void add(List<String> commands, Completer completer) {\n+        for (String c: commands) {\n+            add(c, completer);\n+        }\n+    }\n+\n+    public void add(String command, Completer completer) {\n+        Objects.requireNonNull(command);\n+        if (compiled) {\n+            throw new IllegalStateException();\n+        }\n+        if (!completers.containsKey(command)) {\n+            completers.put(command, new ArrayList<Completer>());\n+        }\n+        if (completer instanceof ArgumentCompleter) {\n+            ((ArgumentCompleter) completer).setStrictCommand(false);\n+        }\n+        completers.get(command).add(completer);\n+    }\n+\n+    public void add(SystemCompleter other) {\n+        if (other.isCompiled()) {\n+            throw new IllegalStateException();\n+        }\n+        for (Map.Entry<String, List<Completer>> entry: other.getCompleters().entrySet()) {\n+            for (Completer c: entry.getValue()) {\n+                add(entry.getKey(), c);\n+            }\n+        }\n+        addAliases(other.getAliases());\n+    }\n+\n+    public void addAliases(Map<String,String> aliasCommand) {\n+        if (compiled) {\n+            throw new IllegalStateException();\n+        }\n+        this.aliasCommand.putAll(aliasCommand);\n+    }\n+\n+    private Map<String,String> getAliases() {\n+        return aliasCommand;\n+    }\n+\n+    public void compile() {\n+        if (compiled) {\n+            return;\n+        }\n+        Map<String, List<Completer>> compiledCompleters = new HashMap<>();\n+        for (Map.Entry<String, List<Completer>> entry: completers.entrySet()) {\n+            if (entry.getValue().size() == 1) {\n+                compiledCompleters.put(entry.getKey(), entry.getValue());\n+            } else {\n+                compiledCompleters.put(entry.getKey(), new ArrayList<Completer>());\n+                compiledCompleters.get(entry.getKey()).add(new AggregateCompleter(entry.getValue()));\n+            }\n+        }\n+        completers = compiledCompleters;\n+        Set<String> cmds = new HashSet<>(completers.keySet());\n+        cmds.addAll(aliasCommand.keySet());\n+        commands = new StringsCompleter(cmds);\n+        compiled = true;\n+    }\n+\n+    public Map<String,List<Completer>> getCompleters() {\n+        return completers;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/completer\/SystemCompleter.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author or authors.\n@@ -87,1 +87,1 @@\n-                        setHistoryFileData(path, new HistoryFileData(items.size(), items.size()));\n+                        setHistoryFileData(path, new HistoryFileData(items.size(), offset + items.size()));\n@@ -108,1 +108,1 @@\n-                        setHistoryFileData(path, new HistoryFileData(items.size(), items.size()));\n+                        setHistoryFileData(path, new HistoryFileData(items.size(), offset + items.size()));\n@@ -139,5 +139,1 @@\n-            if (path != null) {\n-                return false;\n-            } else {\n-                return true;\n-            }\n+            return path == null;\n@@ -229,1 +225,4 @@\n-            Files.createDirectories(path.toAbsolutePath().getParent());\n+            Path parent = path.toAbsolutePath().getParent();\n+            if (!Files.exists(parent)) {\n+                Files.createDirectories(parent);\n+            }\n@@ -261,1 +260,1 @@\n-        doTrimHistory(allItems, max);\n+        List<Entry> trimmedItems = doTrimHistory(allItems, max);\n@@ -265,1 +264,1 @@\n-            for (Entry entry : allItems) {\n+            for (Entry entry : trimmedItems) {\n@@ -273,2 +272,2 @@\n-            offset = allItems.get(0).index();\n-            items.addAll(allItems);\n+            offset = trimmedItems.get(0).index();\n+            items.addAll(trimmedItems);\n@@ -300,1 +299,1 @@\n-    static void doTrimHistory(List<Entry> allItems, int max) {\n+    static List<Entry> doTrimHistory(List<Entry> allItems, int max) {\n@@ -317,0 +316,6 @@\n+        int index = allItems.get(allItems.size() - 1).index() - allItems.size() + 1;\n+        List<Entry> out = new ArrayList<>();\n+        for (Entry e : allItems) {\n+            out.add(new EntryImpl(index++, e.time(), e.line()));\n+        }\n+        return out;\n@@ -341,1 +346,1 @@\n-            return Long.toString(entry.time().toEpochMilli()) + \":\" + escape(entry.line()) + \"\\n\";\n+            return entry.time().toEpochMilli() + \":\" + escape(entry.line()) + \"\\n\";\n@@ -401,0 +406,2 @@\n+            } else {\n+                sb.append(ch);\n@@ -444,1 +451,1 @@\n-        index = index > items.size() ? items.size() : index;\n+        index = Math.min(index, items.size());\n@@ -625,1 +632,1 @@\n-    private class HistoryFileData {\n+    private static class HistoryFileData {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/reader\/impl\/history\/DefaultHistory.java","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -21,0 +21,1 @@\n+import jdk.internal.org.jline.utils.ColorPalette;\n@@ -331,0 +332,6 @@\n+\n+    \/**\n+     * Color support\n+     *\/\n+    ColorPalette getPalette();\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/Terminal.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author or authors.\n@@ -91,0 +91,1 @@\n+    private static final AtomicReference<Terminal> TERMINAL_OVERRIDE = new AtomicReference<>();\n@@ -103,0 +104,1 @@\n+    private Boolean color;\n@@ -106,0 +108,1 @@\n+    private Function<InputStream, InputStream> inputStreamWrapper = in -> in;\n@@ -108,1 +111,0 @@\n-    private Function<InputStream, InputStream> inputStreamWrapper = in -> in;\n@@ -154,0 +156,5 @@\n+    public TerminalBuilder color(boolean color) {\n+        this.color = color;\n+        return this;\n+    }\n+\n@@ -208,2 +215,2 @@\n-     * outut streams using the {@link #streams(InputStream, OutputStream)} method\n-     * or when {@link #system(boolean)} has been explicitely called with\n+     * output streams using the {@link #streams(InputStream, OutputStream)} method\n+     * or when {@link #system(boolean)} has been explicitly called with\n@@ -225,2 +232,2 @@\n-     * outut streams using the {@link #streams(InputStream, OutputStream)} method\n-     * or when {@link #system(boolean)} has been explicitely called with\n+     * output streams using the {@link #streams(InputStream, OutputStream)} method\n+     * or when {@link #system(boolean)} has been explicitly called with\n@@ -249,0 +256,5 @@\n+    public TerminalBuilder inputStreamWrapper(Function<InputStream, InputStream> wrapper) {\n+        this.inputStreamWrapper = wrapper;\n+        return this;\n+    }\n+\n@@ -264,5 +276,0 @@\n-    public TerminalBuilder inputStreamWrapper(Function<InputStream, InputStream> wrapper) {\n-        this.inputStreamWrapper = wrapper;\n-        return this;\n-    }\n-\n@@ -270,1 +277,5 @@\n-        Terminal terminal = doBuild();\n+        Terminal override = TERMINAL_OVERRIDE.get();\n+        Terminal terminal = override != null ? override : doBuild();\n+        if (override != null) {\n+            Log.debug(() -> \"Overriding terminal with global value set by TerminalBuilder.setTerminalOverride\");\n+        }\n@@ -321,2 +332,2 @@\n-            if (attributes != null || size != null) {\n-                Log.warn(\"Attributes and size fields are ignored when creating a system terminal\");\n+            if (system != null && ((in != null && !in.equals(System.in)) ||  (out != null && !out.equals(System.out)))) {\n+                throw new IllegalArgumentException(\"Cannot create a system terminal using non System streams\");\n@@ -324,1 +335,0 @@\n-            IllegalStateException exception = new IllegalStateException(\"Unable to create a system terminal\");\n@@ -326,13 +336,43 @@\n-            if (OSUtils.IS_WINDOWS) {\n-                boolean cygwinTerm = \"cygwin\".equals(System.getenv(\"TERM\"));\n-                boolean ansiPassThrough = OSUtils.IS_CONEMU;\n-                \/\/\n-                \/\/ Cygwin support\n-                \/\/\n-                if ((OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM) && exec && !cygwinTerm) {\n-                    try {\n-                        Pty pty = ExecPty.current();\n-                        \/\/ Cygwin defaults to XTERM, but actually supports 256 colors,\n-                        \/\/ so if the value comes from the environment, change it to xterm-256color\n-                        if (\"xterm\".equals(type) && this.type == null && System.getProperty(PROP_TYPE) == null) {\n-                            type = \"xterm-256color\";\n+            IllegalStateException exception = new IllegalStateException(\"Unable to create a system terminal\");\n+            TerminalBuilderSupport tbs = new TerminalBuilderSupport(jna, jansi);\n+            if (tbs.isConsoleInput() && tbs.isConsoleOutput()) {\n+                if (attributes != null || size != null) {\n+                    Log.warn(\"Attributes and size fields are ignored when creating a system terminal\");\n+                }\n+                if (OSUtils.IS_WINDOWS) {\n+                    if (!OSUtils.IS_CYGWIN && !OSUtils.IS_MSYSTEM) {\n+                        boolean ansiPassThrough = OSUtils.IS_CONEMU;\n+                        if (tbs.hasJnaSupport()) {\n+                            try {\n+                                terminal = tbs.getJnaSupport().winSysTerminal(name, type, ansiPassThrough, encoding, codepage\n+                                        , nativeSignals, signalHandler, paused, inputStreamWrapper);\n+                            } catch (Throwable t) {\n+                                Log.debug(\"Error creating JNA based terminal: \", t.getMessage(), t);\n+                                exception.addSuppressed(t);\n+                            }\n+                        }\n+                        if (terminal == null && tbs.hasJansiSupport()) {\n+                            try {\n+                                terminal = tbs.getJansiSupport().winSysTerminal(name, type, ansiPassThrough, encoding, codepage\n+                                        , nativeSignals, signalHandler, paused);\n+                            } catch (Throwable t) {\n+                                Log.debug(\"Error creating JANSI based terminal: \", t.getMessage(), t);\n+                                exception.addSuppressed(t);\n+                            }\n+                        }\n+                    } else if (exec) {\n+                        \/\/\n+                        \/\/ Cygwin support\n+                        \/\/\n+                        try {\n+                            \/\/ Cygwin defaults to XTERM, but actually supports 256 colors,\n+                            \/\/ so if the value comes from the environment, change it to xterm-256color\n+                            if (\"xterm\".equals(type) && this.type == null && System.getProperty(PROP_TYPE) == null) {\n+                                type = \"xterm-256color\";\n+                            }\n+                            Pty pty = tbs.getExecPty();\n+                            terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n+                        } catch (IOException e) {\n+                            \/\/ Ignore if not a tty\n+                            Log.debug(\"Error creating EXEC based terminal: \", e.getMessage(), e);\n+                            exception.addSuppressed(e);\n@@ -340,5 +380,0 @@\n-                        terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n-                    } catch (IOException e) {\n-                        \/\/ Ignore if not a tty\n-                        Log.debug(\"Error creating EXEC based terminal: \", e.getMessage(), e);\n-                        exception.addSuppressed(e);\n@@ -346,7 +381,3 @@\n-                }\n-                if (jna) {\n-                    try {\n-                        terminal = load(JnaSupport.class).winSysTerminal(name, type, ansiPassThrough, encoding, codepage, nativeSignals, signalHandler, paused, inputStreamWrapper);\n-                    } catch (Throwable t) {\n-                        Log.debug(\"Error creating JNA based terminal: \", t.getMessage(), t);\n-                        exception.addSuppressed(t);\n+                    if (terminal == null && !jna && !jansi && (dumb == null || !dumb)) {\n+                        throw new IllegalStateException(\"Unable to create a system terminal. On windows, either \"\n+                                + \"JNA or JANSI library is required.  Make sure to add one of those in the classpath.\");\n@@ -354,7 +385,10 @@\n-                }\n-                if (jansi) {\n-                    try {\n-                        terminal = load(JansiSupport.class).winSysTerminal(name, type, ansiPassThrough, encoding, codepage, nativeSignals, signalHandler, paused);\n-                    } catch (Throwable t) {\n-                        Log.debug(\"Error creating JANSI based terminal: \", t.getMessage(), t);\n-                        exception.addSuppressed(t);\n+                } else {\n+                    if (tbs.hasJnaSupport()) {\n+                        try {\n+                            Pty pty = tbs.getJnaSupport().current();\n+                            terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n+                        } catch (Throwable t) {\n+                            \/\/ ignore\n+                            Log.debug(\"Error creating JNA based terminal: \", t.getMessage(), t);\n+                            exception.addSuppressed(t);\n+                        }\n@@ -362,10 +396,8 @@\n-                }\n-            } else {\n-                if (jna) {\n-                    try {\n-                        Pty pty = load(JnaSupport.class).current();\n-                        terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n-                    } catch (Throwable t) {\n-                        \/\/ ignore\n-                        Log.debug(\"Error creating JNA based terminal: \", t.getMessage(), t);\n-                        exception.addSuppressed(t);\n+                    if (terminal == null && tbs.hasJansiSupport()) {\n+                        try {\n+                            Pty pty = tbs.getJansiSupport().current();\n+                            terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n+                        } catch (Throwable t) {\n+                            Log.debug(\"Error creating JANSI based terminal: \", t.getMessage(), t);\n+                            exception.addSuppressed(t);\n+                        }\n@@ -373,8 +405,9 @@\n-                }\n-                if (jansi) {\n-                    try {\n-                        Pty pty = load(JansiSupport.class).current();\n-                        terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n-                    } catch (Throwable t) {\n-                        Log.debug(\"Error creating JANSI based terminal: \", t.getMessage(), t);\n-                        exception.addSuppressed(t);\n+                    if (terminal == null && exec) {\n+                        try {\n+                            Pty pty = tbs.getExecPty();\n+                            terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n+                        } catch (Throwable t) {\n+                            \/\/ Ignore if not a tty\n+                            Log.debug(\"Error creating EXEC based terminal: \", t.getMessage(), t);\n+                            exception.addSuppressed(t);\n+                        }\n@@ -383,8 +416,10 @@\n-                if (exec) {\n-                    try {\n-                        Pty pty = ExecPty.current();\n-                        terminal = new PosixSysTerminal(name, type, pty, inputStreamWrapper.apply(pty.getSlaveInput()), pty.getSlaveOutput(), encoding, nativeSignals, signalHandler);\n-                    } catch (Throwable t) {\n-                        \/\/ Ignore if not a tty\n-                        Log.debug(\"Error creating EXEC based terminal: \", t.getMessage(), t);\n-                        exception.addSuppressed(t);\n+                if (terminal instanceof AbstractTerminal) {\n+                    AbstractTerminal t = (AbstractTerminal) terminal;\n+                    if (SYSTEM_TERMINAL.compareAndSet(null, t)) {\n+                        t.setOnClose(() -> SYSTEM_TERMINAL.compareAndSet(t, null));\n+                    } else {\n+                        exception.addSuppressed(new IllegalStateException(\"A system terminal is already running. \" +\n+                                \"Make sure to use the created system Terminal on the LineReaderBuilder if you're using one \" +\n+                                \"or that previously created system Terminals have been correctly closed.\"));\n+                        terminal.close();\n+                        terminal = null;\n@@ -394,17 +429,0 @@\n-            if (terminal instanceof AbstractTerminal) {\n-                AbstractTerminal t = (AbstractTerminal) terminal;\n-                if (SYSTEM_TERMINAL.compareAndSet(null, t)) {\n-                    t.setOnClose(new Runnable() {\n-                        @Override\n-                        public void run() {\n-                            SYSTEM_TERMINAL.compareAndSet(t, null);\n-                        }\n-                    });\n-                } else {\n-                    exception.addSuppressed(new IllegalStateException(\"A system terminal is already running. \" +\n-                            \"Make sure to use the created system Terminal on the LineReaderBuilder if you're using one \" +\n-                            \"or that previously created system Terminals have been correctly closed.\"));\n-                    terminal.close();\n-                    terminal = null;\n-                }\n-            }\n@@ -413,15 +431,23 @@\n-                boolean color = getBoolean(PROP_DUMB_COLOR, false);\n-                \/\/ detect emacs using the env variable\n-                if (!color) {\n-                    color = System.getenv(\"INSIDE_EMACS\") != null;\n-                }\n-                \/\/ detect Intellij Idea\n-                if (!color) {\n-                    String command = getParentProcessCommand();\n-                    color = command != null && command.contains(\"idea\");\n-                }\n-                if (!color && dumb == null) {\n-                    if (Log.isDebugEnabled()) {\n-                        Log.warn(\"Creating a dumb terminal\", exception);\n-                    } else {\n-                        Log.warn(\"Unable to create a system terminal, creating a dumb terminal (enable debug logging for more information)\");\n+                Boolean color = this.color;\n+                if (color == null) {\n+                    color = getBoolean(PROP_DUMB_COLOR, false);\n+                    \/\/ detect emacs using the env variable\n+                    if (!color) {\n+                        color = System.getenv(\"INSIDE_EMACS\") != null;\n+                    }\n+                    \/\/ detect Intellij Idea\n+                    if (!color) {\n+                        String command = getParentProcessCommand();\n+                        color = command != null && command.contains(\"idea\");\n+                    }\n+                    if (!color) {\n+                        color = tbs.isConsoleOutput() && System.getenv(\"TERM\") != null;\n+                    }\n+                    if (!color && dumb == null) {\n+                        if (Log.isDebugEnabled()) {\n+                            Log.warn(\"input is tty: {}\", tbs.isConsoleInput());\n+                            Log.warn(\"output is tty: {}\", tbs.isConsoleOutput());\n+                            Log.warn(\"Creating a dumb terminal\", exception);\n+                        } else {\n+                            Log.warn(\"Unable to create a system terminal, creating a dumb terminal (enable debug logging for more information)\");\n+                        }\n@@ -431,1 +457,1 @@\n-                        new FileInputStream(FileDescriptor.in),\n+                        inputStreamWrapper.apply(new FileInputStream(FileDescriptor.in)),\n@@ -443,1 +469,1 @@\n-                    return new PosixPtyTerminal(name, type, pty, in, out, encoding, signalHandler, paused);\n+                    return new PosixPtyTerminal(name, type, pty, inputStreamWrapper.apply(in), out, encoding, signalHandler, paused);\n@@ -451,1 +477,1 @@\n-                    return new PosixPtyTerminal(name, type, pty, in, out, encoding, signalHandler, paused);\n+                    return new PosixPtyTerminal(name, type, pty, inputStreamWrapper.apply(in), out, encoding, signalHandler, paused);\n@@ -456,1 +482,1 @@\n-            return new ExternalTerminal(name, type, in, out, encoding, signalHandler, paused, attributes, size);\n+            return new ExternalTerminal(name, type, inputStreamWrapper.apply(in), out, encoding, signalHandler, paused, attributes, size);\n@@ -485,1 +511,1 @@\n-    private <S> S load(Class<S> clazz) {\n+    private static <S> S load(Class<S> clazz) {\n@@ -488,0 +514,109 @@\n+\n+    \/**\n+     * Allows an application to override the result of {@link #build()}. The\n+     * intended use case is to allow a container or server application to control\n+     * an embedded application that uses a LineReader that uses Terminal\n+     * constructed with TerminalBuilder.build but provides no public api for setting\n+     * the <code>LineReader<\/code> of the {@link Terminal}. For example, the sbt\n+     * build tool uses a <code>LineReader<\/code> to implement an interactive shell.\n+     * One of its supported commands is <code>console<\/code> which invokes\n+     * the scala REPL. The scala REPL also uses a <code>LineReader<\/code> and it\n+     * is necessary to override the {@link Terminal} used by the the REPL to\n+     * share the same {@link Terminal} instance used by sbt.\n+     *\n+     * <p>\n+     * When this method is called with a non-null {@link Terminal}, all subsequent\n+     * calls to {@link #build()} will return the provided {@link Terminal} regardless\n+     * of how the {@link TerminalBuilder} was constructed. The default behavior\n+     * of {@link TerminalBuilder} can be restored by calling setTerminalOverride\n+     * with a null {@link Terminal}\n+     * <\/p>\n+     *\n+     * <p>\n+     * Usage of setTerminalOverride should be restricted to cases where it\n+     * isn't possible to update the api of the nested application to accept\n+     * a {@link Terminal instance}.\n+     * <\/p>\n+     *\n+     * @param terminal the {@link Terminal} to globally override\n+     *\/\n+    @Deprecated\n+    public static void setTerminalOverride(final Terminal terminal) {\n+        TERMINAL_OVERRIDE.set(terminal);\n+    }\n+\n+    private static class TerminalBuilderSupport {\n+        private JansiSupport jansiSupport = null;\n+        private JnaSupport jnaSupport = null;\n+        private Pty pty = null;\n+        private boolean consoleOutput;\n+\n+        TerminalBuilderSupport(boolean jna, boolean jansi) {\n+            if (jna) {\n+                try {\n+                    jnaSupport = load(JnaSupport.class);\n+                    consoleOutput = jnaSupport.isConsoleOutput();\n+                } catch (Throwable e) {\n+                    jnaSupport = null;\n+                    Log.debug(\"jnaSupport.isConsoleOutput(): \", e);\n+                }\n+            }\n+            if (jansi) {\n+                try {\n+                    jansiSupport = load(JansiSupport.class);\n+                    consoleOutput = jansiSupport.isConsoleOutput();\n+                } catch (Throwable e) {\n+                    jansiSupport = null;\n+                    Log.debug(\"jansiSupport.isConsoleOutput(): \", e);\n+                }\n+            }\n+            if (jnaSupport == null && jansiSupport == null) {\n+                try {\n+                    pty = ExecPty.current();\n+                    consoleOutput = true;\n+                } catch (Exception e) {\n+                    Log.debug(\"ExecPty.current(): \", e);\n+                }\n+            }\n+        }\n+\n+        public boolean isConsoleOutput() {\n+            return consoleOutput;\n+        }\n+\n+        public boolean isConsoleInput() {\n+            if (pty != null) {\n+                return true;\n+            } else if (hasJnaSupport()) {\n+                return jnaSupport.isConsoleInput();\n+            } else if (hasJansiSupport()) {\n+                return jansiSupport.isConsoleInput();\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        public boolean hasJnaSupport() {\n+            return jnaSupport != null;\n+        }\n+\n+        public boolean hasJansiSupport() {\n+            return jansiSupport != null;\n+        }\n+\n+        public JnaSupport getJnaSupport() {\n+            return jnaSupport;\n+        }\n+\n+        public JansiSupport getJansiSupport() {\n+            return jansiSupport;\n+        }\n+\n+        public Pty getExecPty() throws IOException {\n+            if (pty == null) {\n+                pty = ExecPty.current();\n+            }\n+            return pty;\n+        }\n+\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/TerminalBuilder.java","additions":245,"deletions":110,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author or authors.\n@@ -20,0 +20,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -30,0 +31,1 @@\n+import jdk.internal.org.jline.utils.ColorPalette;\n@@ -41,1 +43,1 @@\n-    protected final Map<Signal, SignalHandler> handlers = new HashMap<>();\n+    protected final Map<Signal, SignalHandler> handlers = new ConcurrentHashMap<>();\n@@ -45,0 +47,1 @@\n+    protected final ColorPalette palette = new ColorPalette(this);\n@@ -54,1 +57,1 @@\n-        this.type = type;\n+        this.type = type != null ? type : \"ansi\";\n@@ -200,6 +203,4 @@\n-        if (type != null) {\n-            try {\n-                capabilities = InfoCmp.getInfoCmp(type);\n-            } catch (Exception e) {\n-                Log.warn(\"Unable to retrieve infocmp for type \" + type, e);\n-            }\n+        try {\n+            capabilities = InfoCmp.getInfoCmp(type);\n+        } catch (Exception e) {\n+            Log.warn(\"Unable to retrieve infocmp for type \" + type, e);\n@@ -244,1 +245,1 @@\n-        return type != null && type.startsWith(\"xterm\");\n+        return type.startsWith(\"xterm\");\n@@ -286,0 +287,4 @@\n+    @Override\n+    public ColorPalette getPalette() {\n+        return palette;\n+    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractTerminal.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -524,2 +524,0 @@\n-    protected abstract int getConsoleOutputCP();\n-\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/AbstractWindowsTerminal.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author or authors.\n@@ -28,0 +28,5 @@\n+    boolean isWindowsConsole();\n+\n+    boolean isConsoleOutput();\n+\n+    boolean isConsoleInput();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/JansiSupport.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author or authors.\n@@ -32,0 +32,5 @@\n+    boolean isWindowsConsole();\n+\n+    boolean isConsoleOutput();\n+\n+    boolean isConsoleInput();\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/JnaSupport.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2019, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author or authors.\n@@ -23,0 +23,2 @@\n+import static jdk.internal.org.jline.utils.AttributedStyle.F_BACKGROUND_IND;\n+import static jdk.internal.org.jline.utils.AttributedStyle.F_BACKGROUND_RGB;\n@@ -29,0 +31,2 @@\n+import static jdk.internal.org.jline.utils.AttributedStyle.F_FOREGROUND_IND;\n+import static jdk.internal.org.jline.utils.AttributedStyle.F_FOREGROUND_RGB;\n@@ -38,0 +42,9 @@\n+    public static final int TRUE_COLORS = 0x1000000;\n+    private static final int HIGH_COLORS = 0x7FFF;\n+\n+    public enum ForceMode {\n+        None,\n+        Force256Colors,\n+        ForceTrueColors\n+    }\n+\n@@ -58,1 +71,2 @@\n-        boolean force256colors = false;\n+        ForceMode forceMode = ForceMode.None;\n+        ColorPalette palette = null;\n@@ -65,2 +79,5 @@\n-            force256colors = AbstractWindowsTerminal.TYPE_WINDOWS_256_COLOR.equals(terminal.getType())\n-                || AbstractWindowsTerminal.TYPE_WINDOWS_CONEMU.equals(terminal.getType());\n+            if (AbstractWindowsTerminal.TYPE_WINDOWS_256_COLOR.equals(terminal.getType())\n+                    || AbstractWindowsTerminal.TYPE_WINDOWS_CONEMU.equals(terminal.getType())) {\n+                forceMode = ForceMode.Force256Colors;\n+            }\n+            palette = terminal.getPalette();\n@@ -72,1 +89,1 @@\n-        return toAnsi(colors, force256colors, alternateIn, alternateOut);\n+        return toAnsi(colors, forceMode, palette, alternateIn, alternateOut);\n@@ -75,0 +92,1 @@\n+    @Deprecated\n@@ -79,0 +97,1 @@\n+    @Deprecated\n@@ -80,0 +99,12 @@\n+        return toAnsi(colors, force256colors ? ForceMode.Force256Colors : ForceMode.None, null, altIn, altOut);\n+    }\n+\n+    public String toAnsi(int colors, ForceMode force) {\n+        return toAnsi(colors, force, null, null, null);\n+    }\n+\n+    public String toAnsi(int colors, ForceMode force, ColorPalette palette) {\n+        return toAnsi(colors, force, palette, null, null);\n+    }\n+\n+    public String toAnsi(int colors, ForceMode force, ColorPalette palette, String altIn, String altOut) {\n@@ -81,3 +112,3 @@\n-        int style = 0;\n-        int foreground = -1;\n-        int background = -1;\n+        long style = 0;\n+        long foreground = 0;\n+        long background = 0;\n@@ -85,0 +116,3 @@\n+        if (palette == null) {\n+            palette = ColorPalette.DEFAULT;\n+        }\n@@ -108,1 +142,1 @@\n-            int  s = styleCodeAt(i) & ~F_HIDDEN; \/\/ The hidden flag does not change the ansi styles\n+            long  s = styleCodeAt(i) & ~F_HIDDEN; \/\/ The hidden flag does not change the ansi styles\n@@ -110,3 +144,3 @@\n-                int  d = (style ^ s) & MASK;\n-                int fg = (s & F_FOREGROUND) != 0 ? (s & FG_COLOR) >>> FG_COLOR_EXP : -1;\n-                int bg = (s & F_BACKGROUND) != 0 ? (s & BG_COLOR) >>> BG_COLOR_EXP : -1;\n+                long  d = (style ^ s) & MASK;\n+                long fg = (s & F_FOREGROUND) != 0 ? s & (FG_COLOR | F_FOREGROUND) : 0;\n+                long bg = (s & F_BACKGROUND) != 0 ? s & (BG_COLOR | F_BACKGROUND) : 0;\n@@ -115,1 +149,1 @@\n-                    foreground = background = -1;\n+                    foreground = background = 0;\n@@ -138,12 +172,32 @@\n-                        if (fg >= 0) {\n-                            int rounded = Colors.roundColor(fg, colors);\n-                            if (rounded < 8 && !force256colors) {\n-                                first = attr(sb, \"3\" + Integer.toString(rounded), first);\n-                                \/\/ small hack to force setting bold again after a foreground color change\n-                                d |= (s & F_BOLD);\n-                            } else if (rounded < 16 && !force256colors) {\n-                                first = attr(sb, \"9\" + Integer.toString(rounded - 8), first);\n-                                \/\/ small hack to force setting bold again after a foreground color change\n-                                d |= (s & F_BOLD);\n-                            } else {\n-                                first = attr(sb, \"38;5;\" + Integer.toString(rounded), first);\n+                        if (fg > 0) {\n+                            int rounded = -1;\n+                            if ((fg & F_FOREGROUND_RGB) != 0) {\n+                                int r = (int)(fg >> (FG_COLOR_EXP + 16)) & 0xFF;\n+                                int g = (int)(fg >> (FG_COLOR_EXP + 8)) & 0xFF;\n+                                int b = (int)(fg >> FG_COLOR_EXP) & 0xFF;\n+                                if (colors >= HIGH_COLORS) {\n+                                    first = attr(sb, \"38;2;\" + r + \";\" + g + \";\" + b, first);\n+                                } else {\n+                                    rounded = palette.round(r, g, b);\n+                                }\n+                            } else if ((fg & F_FOREGROUND_IND) != 0) {\n+                                rounded = palette.round((int)(fg >> FG_COLOR_EXP) & 0xFF);\n+                            }\n+                            if (rounded >= 0) {\n+                                if (colors >= HIGH_COLORS && force == ForceMode.ForceTrueColors) {\n+                                    int col = palette.getColor(rounded);\n+                                    int r = (col >> 16) & 0xFF;\n+                                    int g = (col >> 8) & 0xFF;\n+                                    int b = col & 0xFF;\n+                                    first = attr(sb, \"38;2;\" + r + \";\" + g + \";\" + b, first);\n+                                } else if (force == ForceMode.Force256Colors || rounded >= 16) {\n+                                    first = attr(sb, \"38;5;\" + rounded, first);\n+                                } else if (rounded >= 8) {\n+                                    first = attr(sb, \"9\" + (rounded - 8), first);\n+                                    \/\/ small hack to force setting bold again after a foreground color change\n+                                    d |= (s & F_BOLD);\n+                                } else {\n+                                    first = attr(sb, \"3\" + rounded, first);\n+                                    \/\/ small hack to force setting bold again after a foreground color change\n+                                    d |= (s & F_BOLD);\n+                                }\n@@ -157,8 +211,28 @@\n-                        if (bg >= 0) {\n-                            int rounded = Colors.roundColor(bg, colors);\n-                            if (rounded < 8 && !force256colors) {\n-                                first = attr(sb, \"4\" + Integer.toString(rounded), first);\n-                            } else if (rounded < 16 && !force256colors) {\n-                                first = attr(sb, \"10\" + Integer.toString(rounded - 8), first);\n-                            } else {\n-                                first = attr(sb, \"48;5;\" + Integer.toString(rounded), first);\n+                        if (bg > 0) {\n+                            int rounded = -1;\n+                            if ((bg & F_BACKGROUND_RGB) != 0) {\n+                                int r = (int)(bg >> (BG_COLOR_EXP + 16)) & 0xFF;\n+                                int g = (int)(bg >> (BG_COLOR_EXP + 8)) & 0xFF;\n+                                int b = (int)(bg >> BG_COLOR_EXP) & 0xFF;\n+                                if (colors >= HIGH_COLORS) {\n+                                    first = attr(sb, \"48;2;\" + r + \";\" + g + \";\" + b, first);\n+                                } else {\n+                                    rounded = palette.round(r, g, b);\n+                                }\n+                            } else if ((bg & F_BACKGROUND_IND) != 0) {\n+                                rounded = palette.round((int)(bg >> BG_COLOR_EXP) & 0xFF);\n+                            }\n+                            if (rounded >= 0) {\n+                                if (colors >= HIGH_COLORS && force == ForceMode.ForceTrueColors) {\n+                                    int col = palette.getColor(rounded);\n+                                    int r = (col >> 16) & 0xFF;\n+                                    int g = (col >> 8) & 0xFF;\n+                                    int b = col & 0xFF;\n+                                    first = attr(sb, \"48;2;\" + r + \";\" + g + \";\" + b, first);\n+                                } else if (force == ForceMode.Force256Colors || rounded >= 16) {\n+                                    first = attr(sb, \"48;5;\" + rounded, first);\n+                                } else if (rounded >= 8) {\n+                                    first = attr(sb, \"10\" + (rounded - 8), first);\n+                                } else {\n+                                    first = attr(sb, \"4\" + rounded, first);\n+                                }\n@@ -223,1 +297,1 @@\n-    int styleCodeAt(int index) {\n+    long styleCodeAt(int index) {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/AttributedCharSequence.java","additions":108,"deletions":34,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-    final int[] style;\n+    final long[] style;\n@@ -81,1 +81,1 @@\n-            style = new int[l];\n+            style = new long[l];\n@@ -90,1 +90,1 @@\n-    AttributedString(char[] buffer, int[] style, int start, int end) {\n+    AttributedString(char[] buffer, long[] style, int start, int end) {\n@@ -145,1 +145,1 @@\n-    int styleCodeAt(int index) {\n+    long styleCodeAt(int index) {\n@@ -158,1 +158,1 @@\n-            int[] newstyle = this.style.clone();\n+            long[] newstyle = this.style.clone();\n@@ -188,1 +188,1 @@\n-    private boolean arrEq(int[] a1, int[] a2, int s1, int s2, int l) {\n+    private boolean arrEq(long[] a1, long[] a2, int s1, int s2, int l) {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/AttributedString.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-    private int[] style;\n+    private long[] style;\n@@ -47,1 +47,1 @@\n-        style = new int[capacity];\n+        style = new long[capacity];\n@@ -67,1 +67,1 @@\n-    int styleCodeAt(int index) {\n+    long styleCodeAt(int index) {\n@@ -92,0 +92,3 @@\n+        if (csq == null) {\n+            csq = \"null\"; \/\/ Required by Appendable.append\n+        }\n@@ -97,0 +100,3 @@\n+        if (csq == null) {\n+            csq = \"null\"; \/\/ Required by Appendable.append\n+        }\n@@ -155,1 +161,1 @@\n-            int s = str.styleCodeAt(i) & ~current.getMask() | current.getStyle();\n+            long s = str.styleCodeAt(i) & ~current.getMask() | current.getStyle();\n@@ -289,2 +295,0 @@\n-                                            \/\/ convert to 256 colors\n-                                            int col = 16 + (r >> 3) * 36 + (g >> 3) * 6 + (b >> 3);\n@@ -292,1 +296,1 @@\n-                                                current = current.foreground(col);\n+                                                current = current.foreground(r, g, b);\n@@ -294,1 +298,1 @@\n-                                                current = current.background(col);\n+                                                current = current.background(r, g, b);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/AttributedStringBuilder.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2018, the original author or authors.\n+ * Copyright (c) 2002-2021, the original author or authors.\n@@ -29,18 +29,22 @@\n-    static final int F_BOLD         = 0x00000001;\n-    static final int F_FAINT        = 0x00000002;\n-    static final int F_ITALIC       = 0x00000004;\n-    static final int F_UNDERLINE    = 0x00000008;\n-    static final int F_BLINK        = 0x00000010;\n-    static final int F_INVERSE      = 0x00000020;\n-    static final int F_CONCEAL      = 0x00000040;\n-    static final int F_CROSSED_OUT  = 0x00000080;\n-    static final int F_FOREGROUND   = 0x00000100;\n-    static final int F_BACKGROUND   = 0x00000200;\n-    static final int F_HIDDEN       = 0x00000400;\n-\n-    static final int MASK           = 0x000007FF;\n-\n-    static final int FG_COLOR_EXP    = 16;\n-    static final int BG_COLOR_EXP    = 24;\n-    static final int FG_COLOR        = 0xFF << FG_COLOR_EXP;\n-    static final int BG_COLOR        = 0xFF << BG_COLOR_EXP;\n+    static final long F_BOLD            = 0x00000001;\n+    static final long F_FAINT           = 0x00000002;\n+    static final long F_ITALIC          = 0x00000004;\n+    static final long F_UNDERLINE       = 0x00000008;\n+    static final long F_BLINK           = 0x00000010;\n+    static final long F_INVERSE         = 0x00000020;\n+    static final long F_CONCEAL         = 0x00000040;\n+    static final long F_CROSSED_OUT     = 0x00000080;\n+    static final long F_FOREGROUND_IND  = 0x00000100;\n+    static final long F_FOREGROUND_RGB  = 0x00000200;\n+    static final long F_FOREGROUND      = F_FOREGROUND_IND | F_FOREGROUND_RGB;\n+    static final long F_BACKGROUND_IND  = 0x00000400;\n+    static final long F_BACKGROUND_RGB  = 0x00000800;\n+    static final long F_BACKGROUND      = F_BACKGROUND_IND | F_BACKGROUND_RGB;\n+    static final long F_HIDDEN          = 0x00001000;\n+\n+    static final long MASK           = 0x00001FFF;\n+\n+    static final int FG_COLOR_EXP    = 15;\n+    static final int BG_COLOR_EXP    = 39;\n+    static final long FG_COLOR        = 0xFFFFFFL << FG_COLOR_EXP;\n+    static final long BG_COLOR        = 0xFFFFFFL << BG_COLOR_EXP;\n@@ -56,2 +60,2 @@\n-    final int style;\n-    final int mask;\n+    final long style;\n+    final long mask;\n@@ -67,1 +71,1 @@\n-    public AttributedStyle(int style, int mask) {\n+    public AttributedStyle(long style, long mask) {\n@@ -138,1 +142,1 @@\n-        int s = (style & F_INVERSE) != 0 ? style & ~F_INVERSE : style | F_INVERSE;\n+        long s = (style & F_INVERSE) != 0 ? style & ~F_INVERSE : style | F_INVERSE;\n@@ -175,1 +179,9 @@\n-        return new AttributedStyle(style & ~FG_COLOR | F_FOREGROUND | ((color << FG_COLOR_EXP) & FG_COLOR), mask | F_FOREGROUND);\n+        return new AttributedStyle(style & ~FG_COLOR | F_FOREGROUND_IND | (((long) color << FG_COLOR_EXP) & FG_COLOR), mask | F_FOREGROUND_IND);\n+    }\n+\n+    public AttributedStyle foreground(int r, int g, int b) {\n+        return foregroundRgb(r << 16 | g << 8 | b);\n+    }\n+\n+    public AttributedStyle foregroundRgb(int color) {\n+        return new AttributedStyle(style & ~FG_COLOR | F_FOREGROUND_RGB | ((((long) color & 0xFFFFFF) << FG_COLOR_EXP) & FG_COLOR), mask | F_FOREGROUND_RGB);\n@@ -187,1 +199,9 @@\n-        return new AttributedStyle(style & ~BG_COLOR | F_BACKGROUND | ((color << BG_COLOR_EXP) & BG_COLOR), mask | F_BACKGROUND);\n+        return new AttributedStyle(style & ~BG_COLOR | F_BACKGROUND_IND | (((long) color << BG_COLOR_EXP) & BG_COLOR), mask | F_BACKGROUND_IND);\n+    }\n+\n+    public AttributedStyle background(int r, int g, int b) {\n+        return backgroundRgb(r << 16 | g << 8 | b);\n+    }\n+\n+    public AttributedStyle backgroundRgb(int color) {\n+        return new AttributedStyle(style & ~BG_COLOR | F_BACKGROUND_RGB | ((((long) color & 0xFFFFFF) << BG_COLOR_EXP) & BG_COLOR), mask | F_BACKGROUND_RGB);\n@@ -217,1 +237,1 @@\n-    public int getStyle() {\n+    public long getStyle() {\n@@ -221,1 +241,1 @@\n-    public int getMask() {\n+    public long getMask() {\n@@ -237,3 +257,17 @@\n-        int result = style;\n-        result = 31 * result + mask;\n-        return result;\n+        return 31 * Long.hashCode(style) + Long.hashCode(mask);\n+    }\n+\n+    public String toAnsi() {\n+        AttributedStringBuilder sb = new AttributedStringBuilder();\n+        sb.styled(this, \" \");\n+        String s = sb.toAnsi(AttributedCharSequence.TRUE_COLORS, AttributedCharSequence.ForceMode.None);\n+        return s.length() > 1 ? s.substring(2, s.indexOf('m')) : s;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"AttributedStyle{\" +\n+                \"style=\" + style +\n+                \", mask=\" + mask +\n+                \", ansi=\" + toAnsi() +\n+                '}';\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/AttributedStyle.java","additions":64,"deletions":30,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -0,0 +1,262 @@\n+\/*\n+ * Copyright (c) 2002-2020, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.utils;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.org.jline.terminal.Terminal;\n+\n+\/**\n+ * Color palette\n+ *\/\n+public class ColorPalette {\n+\n+    public static final String XTERM_INITC = \"\\\\E]4;%p1%d;rgb\\\\:%p2%{255}%*%{1000}%\/%2.2X\/%p3%{255}%*%{1000}%\/%2.2X\/%p4%{255}%*%{1000}%\/%2.2X\\\\E\\\\\\\\\";\n+\n+    public static final ColorPalette DEFAULT = new ColorPalette();\n+\n+    private final Terminal terminal;\n+    private String distanceName;\n+    private Colors.Distance distance;\n+    private boolean osc4;\n+    private int[] palette;\n+\n+    public ColorPalette() {\n+        this.terminal = null;\n+        this.distanceName = null;\n+        this.palette = Colors.DEFAULT_COLORS_256;\n+    }\n+\n+    public ColorPalette(Terminal terminal) throws IOException {\n+        this(terminal, null);\n+    }\n+\n+    public ColorPalette(Terminal terminal, String distance) throws IOException {\n+        this.terminal = terminal;\n+        this.distanceName = distance;\n+        loadPalette(false);\n+    }\n+\n+    \/**\n+     * Get the name of the distance to use for rounding colors.\n+     * @return the name of the color distance\n+     *\/\n+    public String getDistanceName() {\n+        return distanceName;\n+    }\n+\n+    \/**\n+     * Set the name of the color distance to use when rounding RGB colors to the palette.\n+     * @param name the name of the color distance\n+     *\/\n+    public void setDistance(String name) {\n+        this.distanceName = name;\n+    }\n+\n+    \/**\n+     * Check if the terminal has the capability to change colors.\n+     * @return <code>true<\/code> if the terminal can change colors\n+     *\/\n+    public boolean canChange() {\n+        return terminal != null && terminal.getBooleanCapability(InfoCmp.Capability.can_change);\n+    }\n+\n+    \/**\n+     * Load the palette from the terminal.\n+     * If the palette has already been loaded, subsequent calls will simply return <code>true<\/code>.\n+     *\n+     * @return <code>true<\/code> if the palette has been successfully loaded.\n+     * @throws IOException\n+     *\/\n+    public boolean loadPalette() throws IOException {\n+        if (!osc4) {\n+            loadPalette(true);\n+        }\n+        return osc4;\n+    }\n+\n+    protected void loadPalette(boolean doLoad) throws IOException {\n+        if (terminal != null) {\n+            int[] pal = doLoad ? doLoad(terminal) : null;\n+            if (pal != null) {\n+                this.palette = pal;\n+                this.osc4 = true;\n+            } else {\n+                Integer cols = terminal.getNumericCapability(InfoCmp.Capability.max_colors);\n+                if (cols != null) {\n+                    if (cols == Colors.DEFAULT_COLORS_88.length) {\n+                        this.palette = Colors.DEFAULT_COLORS_88;\n+                    } else {\n+                        this.palette = Arrays.copyOf(Colors.DEFAULT_COLORS_256, Math.min(cols, 256));\n+                    }\n+                } else {\n+                    this.palette = Arrays.copyOf(Colors.DEFAULT_COLORS_256, 256);\n+                }\n+                this.osc4 = false;\n+            }\n+        } else {\n+            this.palette = Colors.DEFAULT_COLORS_256;\n+            this.osc4 = false;\n+        }\n+    }\n+\n+    \/**\n+     * Get the palette length\n+     * @return the palette length\n+     *\/\n+    public int getLength() {\n+        return this.palette.length;\n+    }\n+\n+    \/**\n+     * Get a specific color in the palette\n+     * @param index the index of the color\n+     * @return the color at the given index\n+     *\/\n+    public int getColor(int index) {\n+        return palette[index];\n+    }\n+\n+    \/**\n+     * Change the color of the palette\n+     * @param index the index of the color\n+     * @param color the new color value\n+     *\/\n+    public void setColor(int index, int color) {\n+        palette[index] = color;\n+        if (canChange()) {\n+            String initc = terminal.getStringCapability(InfoCmp.Capability.initialize_color);\n+            if (initc != null || osc4) {\n+                \/\/ initc expects color in 0..1000 range\n+                int r = (((color >> 16) & 0xFF) * 1000) \/ 255 + 1;\n+                int g = (((color >> 8) & 0xFF) * 1000) \/ 255 + 1;\n+                int b = ((color & 0xFF) * 1000) \/ 255 + 1;\n+                if (initc == null) {\n+                    \/\/ This is the xterm version\n+                    initc = XTERM_INITC;\n+                }\n+                Curses.tputs(terminal.writer(), initc, index, r, g, b);\n+                terminal.writer().flush();\n+            }\n+        }\n+    }\n+\n+    public boolean isReal() {\n+        return osc4;\n+    }\n+\n+    public int round(int r, int g, int b) {\n+        return Colors.roundColor((r << 16) + (g << 8) + b, palette, palette.length, getDist());\n+    }\n+\n+    public int round(int col) {\n+        if (col >= palette.length) {\n+            col = Colors.roundColor(DEFAULT.getColor(col), palette, palette.length, getDist());\n+        }\n+        return col;\n+    }\n+\n+    protected Colors.Distance getDist() {\n+        if (distance == null) {\n+            distance = Colors.getDistance(distanceName);\n+        }\n+        return distance;\n+    }\n+\n+    private static int[] doLoad(Terminal terminal) throws IOException {\n+        PrintWriter writer = terminal.writer();\n+        NonBlockingReader reader = terminal.reader();\n+\n+        int[] palette = new int[256];\n+        for (int i = 0; i < 16; i++) {\n+            StringBuilder req = new StringBuilder(1024);\n+            req.append(\"\\033]4\");\n+            for (int j = 0; j < 16; j++) {\n+                req.append(';').append(i * 16 + j).append(\";?\");\n+            }\n+            req.append(\"\\033\\\\\");\n+            writer.write(req.toString());\n+            writer.flush();\n+\n+            boolean black = true;\n+            for (int j = 0; j < 16; j++) {\n+                if (reader.peek(50) < 0) {\n+                    break;\n+                }\n+                if (reader.read(10) != '\\033'\n+                        || reader.read(10) != ']'\n+                        || reader.read(10) != '4'\n+                        || reader.read(10) != ';') {\n+                    return null;\n+                }\n+                int idx = 0;\n+                int c;\n+                while (true) {\n+                    c = reader.read(10);\n+                    if (c >= '0' && c <= '9') {\n+                        idx = idx * 10 + (c - '0');\n+                    } else if (c == ';') {\n+                        break;\n+                    } else {\n+                        return null;\n+                    }\n+                }\n+                if (idx > 255) {\n+                    return null;\n+                }\n+                if (reader.read(10) != 'r'\n+                        || reader.read(10) != 'g'\n+                        || reader.read(10) != 'b'\n+                        || reader.read(10) != ':') {\n+                    return null;\n+                }\n+                StringBuilder sb = new StringBuilder(16);\n+                List<String> rgb = new ArrayList<>();\n+                while (true) {\n+                    c = reader.read(10);\n+                    if (c == '\\007') {\n+                        rgb.add(sb.toString());\n+                        break;\n+                    } else if (c == '\\033') {\n+                        c = reader.read(10);\n+                        if (c == '\\\\') {\n+                            rgb.add(sb.toString());\n+                            break;\n+                        } else {\n+                            return null;\n+                        }\n+                    } else if (c >= '0' && c <= '9' || c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n+                        sb.append((char) c);\n+                    } else if (c == '\/') {\n+                        rgb.add(sb.toString());\n+                        sb.setLength(0);\n+                    }\n+                }\n+                if (rgb.size() != 3) {\n+                    return null;\n+                }\n+                double r = Integer.parseInt(rgb.get(0), 16) \/ ((1 << (4 * rgb.get(0).length())) - 1.0);\n+                double g = Integer.parseInt(rgb.get(1), 16) \/ ((1 << (4 * rgb.get(1).length())) - 1.0);\n+                double b = Integer.parseInt(rgb.get(2), 16) \/ ((1 << (4 * rgb.get(2).length())) - 1.0);\n+                palette[idx] = (int)((Math.round(r * 255) << 16) + (Math.round(g * 255) << 8) + Math.round(b * 255));\n+                black &= palette[idx] == 0;\n+            }\n+            if (black) {\n+                break;\n+            }\n+        }\n+        int max = 256;\n+        while (max > 0 && palette[--max] == 0);\n+        return Arrays.copyOfRange(palette, 0, max + 1);\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/ColorPalette.java","additions":262,"deletions":0,"binary":false,"changes":262,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+            \/\/ 16 ansi\n@@ -31,28 +32,44 @@\n-            0x000000, 0x00005f, 0x000087, 0x0000af, 0x0000d7, 0x0000ff, 0x005f00, 0x005f5f,\n-            0x005f87, 0x005faf, 0x005fd7, 0x005fff, 0x008700, 0x00875f, 0x008787, 0x0087af,\n-            0x0087d7, 0x0087ff, 0x00af00, 0x00af5f, 0x00af87, 0x00afaf, 0x00afd7, 0x00afff,\n-            0x00d700, 0x00d75f, 0x00d787, 0x00d7af, 0x00d7d7, 0x00d7ff, 0x00ff00, 0x00ff5f,\n-            0x00ff87, 0x00ffaf, 0x00ffd7, 0x00ffff, 0x5f0000, 0x5f005f, 0x5f0087, 0x5f00af,\n-            0x5f00d7, 0x5f00ff, 0x5f5f00, 0x5f5f5f, 0x5f5f87, 0x5f5faf, 0x5f5fd7, 0x5f5fff,\n-            0x5f8700, 0x5f875f, 0x5f8787, 0x5f87af, 0x5f87d7, 0x5f87ff, 0x5faf00, 0x5faf5f,\n-            0x5faf87, 0x5fafaf, 0x5fafd7, 0x5fafff, 0x5fd700, 0x5fd75f, 0x5fd787, 0x5fd7af,\n-            0x5fd7d7, 0x5fd7ff, 0x5fff00, 0x5fff5f, 0x5fff87, 0x5fffaf, 0x5fffd7, 0x5fffff,\n-            0x870000, 0x87005f, 0x870087, 0x8700af, 0x8700d7, 0x8700ff, 0x875f00, 0x875f5f,\n-            0x875f87, 0x875faf, 0x875fd7, 0x875fff, 0x878700, 0x87875f, 0x878787, 0x8787af,\n-            0x8787d7, 0x8787ff, 0x87af00, 0x87af5f, 0x87af87, 0x87afaf, 0x87afd7, 0x87afff,\n-            0x87d700, 0x87d75f, 0x87d787, 0x87d7af, 0x87d7d7, 0x87d7ff, 0x87ff00, 0x87ff5f,\n-            0x87ff87, 0x87ffaf, 0x87ffd7, 0x87ffff, 0xaf0000, 0xaf005f, 0xaf0087, 0xaf00af,\n-            0xaf00d7, 0xaf00ff, 0xaf5f00, 0xaf5f5f, 0xaf5f87, 0xaf5faf, 0xaf5fd7, 0xaf5fff,\n-            0xaf8700, 0xaf875f, 0xaf8787, 0xaf87af, 0xaf87d7, 0xaf87ff, 0xafaf00, 0xafaf5f,\n-            0xafaf87, 0xafafaf, 0xafafd7, 0xafafff, 0xafd700, 0xafd75f, 0xafd787, 0xafd7af,\n-            0xafd7d7, 0xafd7ff, 0xafff00, 0xafff5f, 0xafff87, 0xafffaf, 0xafffd7, 0xafffff,\n-            0xd70000, 0xd7005f, 0xd70087, 0xd700af, 0xd700d7, 0xd700ff, 0xd75f00, 0xd75f5f,\n-            0xd75f87, 0xd75faf, 0xd75fd7, 0xd75fff, 0xd78700, 0xd7875f, 0xd78787, 0xd787af,\n-            0xd787d7, 0xd787ff, 0xd7af00, 0xd7af5f, 0xd7af87, 0xd7afaf, 0xd7afd7, 0xd7afff,\n-            0xd7d700, 0xd7d75f, 0xd7d787, 0xd7d7af, 0xd7d7d7, 0xd7d7ff, 0xd7ff00, 0xd7ff5f,\n-            0xd7ff87, 0xd7ffaf, 0xd7ffd7, 0xd7ffff, 0xff0000, 0xff005f, 0xff0087, 0xff00af,\n-            0xff00d7, 0xff00ff, 0xff5f00, 0xff5f5f, 0xff5f87, 0xff5faf, 0xff5fd7, 0xff5fff,\n-            0xff8700, 0xff875f, 0xff8787, 0xff87af, 0xff87d7, 0xff87ff, 0xffaf00, 0xffaf5f,\n-            0xffaf87, 0xffafaf, 0xffafd7, 0xffafff, 0xffd700, 0xffd75f, 0xffd787, 0xffd7af,\n-            0xffd7d7, 0xffd7ff, 0xffff00, 0xffff5f, 0xffff87, 0xffffaf, 0xffffd7, 0xffffff,\n-\n+            \/\/ 6x6x6 color cube\n+            0x000000, 0x00005f, 0x000087, 0x0000af, 0x0000d7, 0x0000ff,\n+            0x005f00, 0x005f5f, 0x005f87, 0x005faf, 0x005fd7, 0x005fff,\n+            0x008700, 0x00875f, 0x008787, 0x0087af, 0x0087d7, 0x0087ff,\n+            0x00af00, 0x00af5f, 0x00af87, 0x00afaf, 0x00afd7, 0x00afff,\n+            0x00d700, 0x00d75f, 0x00d787, 0x00d7af, 0x00d7d7, 0x00d7ff,\n+            0x00ff00, 0x00ff5f, 0x00ff87, 0x00ffaf, 0x00ffd7, 0x00ffff,\n+\n+            0x5f0000, 0x5f005f, 0x5f0087, 0x5f00af, 0x5f00d7, 0x5f00ff,\n+            0x5f5f00, 0x5f5f5f, 0x5f5f87, 0x5f5faf, 0x5f5fd7, 0x5f5fff,\n+            0x5f8700, 0x5f875f, 0x5f8787, 0x5f87af, 0x5f87d7, 0x5f87ff,\n+            0x5faf00, 0x5faf5f, 0x5faf87, 0x5fafaf, 0x5fafd7, 0x5fafff,\n+            0x5fd700, 0x5fd75f, 0x5fd787, 0x5fd7af, 0x5fd7d7, 0x5fd7ff,\n+            0x5fff00, 0x5fff5f, 0x5fff87, 0x5fffaf, 0x5fffd7, 0x5fffff,\n+\n+            0x870000, 0x87005f, 0x870087, 0x8700af, 0x8700d7, 0x8700ff,\n+            0x875f00, 0x875f5f, 0x875f87, 0x875faf, 0x875fd7, 0x875fff,\n+            0x878700, 0x87875f, 0x878787, 0x8787af, 0x8787d7, 0x8787ff,\n+            0x87af00, 0x87af5f, 0x87af87, 0x87afaf, 0x87afd7, 0x87afff,\n+            0x87d700, 0x87d75f, 0x87d787, 0x87d7af, 0x87d7d7, 0x87d7ff,\n+            0x87ff00, 0x87ff5f, 0x87ff87, 0x87ffaf, 0x87ffd7, 0x87ffff,\n+\n+            0xaf0000, 0xaf005f, 0xaf0087, 0xaf00af, 0xaf00d7, 0xaf00ff,\n+            0xaf5f00, 0xaf5f5f, 0xaf5f87, 0xaf5faf, 0xaf5fd7, 0xaf5fff,\n+            0xaf8700, 0xaf875f, 0xaf8787, 0xaf87af, 0xaf87d7, 0xaf87ff,\n+            0xafaf00, 0xafaf5f, 0xafaf87, 0xafafaf, 0xafafd7, 0xafafff,\n+            0xafd700, 0xafd75f, 0xafd787, 0xafd7af, 0xafd7d7, 0xafd7ff,\n+            0xafff00, 0xafff5f, 0xafff87, 0xafffaf, 0xafffd7, 0xafffff,\n+\n+            0xd70000, 0xd7005f, 0xd70087, 0xd700af, 0xd700d7, 0xd700ff,\n+            0xd75f00, 0xd75f5f, 0xd75f87, 0xd75faf, 0xd75fd7, 0xd75fff,\n+            0xd78700, 0xd7875f, 0xd78787, 0xd787af, 0xd787d7, 0xd787ff,\n+            0xd7af00, 0xd7af5f, 0xd7af87, 0xd7afaf, 0xd7afd7, 0xd7afff,\n+            0xd7d700, 0xd7d75f, 0xd7d787, 0xd7d7af, 0xd7d7d7, 0xd7d7ff,\n+            0xd7ff00, 0xd7ff5f, 0xd7ff87, 0xd7ffaf, 0xd7ffd7, 0xd7ffff,\n+\n+            0xff0000, 0xff005f, 0xff0087, 0xff00af, 0xff00d7, 0xff00ff,\n+            0xff5f00, 0xff5f5f, 0xff5f87, 0xff5faf, 0xff5fd7, 0xff5fff,\n+            0xff8700, 0xff875f, 0xff8787, 0xff87af, 0xff87d7, 0xff87ff,\n+            0xffaf00, 0xffaf5f, 0xffaf87, 0xffafaf, 0xffafd7, 0xffafff,\n+            0xffd700, 0xffd75f, 0xffd787, 0xffd7af, 0xffd7d7, 0xffd7ff,\n+            0xffff00, 0xffff5f, 0xffff87, 0xffffaf, 0xffffd7, 0xffffff,\n+\n+            \/\/ 24 grey ramp\n@@ -64,0 +81,33 @@\n+    \/**\n+     * Default 88 colors palette\n+     *\/\n+    public static final int[] DEFAULT_COLORS_88 = {\n+            \/\/ 16 ansi\n+            0x000000, 0x800000, 0x008000, 0x808000, 0x000080, 0x800080, 0x008080, 0xc0c0c0,\n+            0x808080, 0xff0000, 0x00ff00, 0xffff00, 0x0000ff, 0xff00ff, 0x00ffff, 0xffffff,\n+\n+            \/\/ 4x4x4 color cube\n+            0x000000, 0x00008b, 0x0000cd, 0x0000ff,\n+            0x008b00, 0x008b8b, 0x008bcd, 0x008bff,\n+            0x00cd00, 0x00cd8b, 0x00cdcd, 0x00cdff,\n+            0x00ff00, 0x00ff8b, 0x00ffcd, 0x00ffff,\n+\n+            0x8b0000, 0x8b008b, 0x8b00cd, 0x8b00ff,\n+            0x8b8b00, 0x8b8b8b, 0x8b8bcd, 0x8b8bff,\n+            0x8bcd00, 0x8bcd8b, 0x8bcdcd, 0x8bcdff,\n+            0x8bff00, 0x8bff8b, 0x8bffcd, 0x8bffff,\n+\n+            0xcd0000, 0xcd008b, 0xcd00cd, 0xcd00ff,\n+            0xcd8b00, 0xcd8b8b, 0xcd8bcd, 0xcd8bff,\n+            0xcdcd00, 0xcdcd8b, 0xcdcdcd, 0xcdcdff,\n+            0xcdff00, 0xcdff8b, 0xcdffcd, 0xcdffff,\n+\n+            0xff0000, 0xff008b, 0xff00cd, 0xff00ff,\n+            0xff8b00, 0xff8b8b, 0xff8bcd, 0xff8bff,\n+            0xffcd00, 0xffcd8b, 0xffcdcd, 0xffcdff,\n+            0xffff00, 0xffff8b, 0xffffcd, 0xffffff,\n+\n+            \/\/ 8 grey ramp\n+            0x2e2e2e, 0x5c5c5c, 0x737373, 0x8b8b8b, 0xa2a2a2, 0xb9b9b9, 0xd0d0d0, 0xe7e7e7,\n+    };\n+\n@@ -77,1 +127,1 @@\n-    public static final double[] sRGB_encoding_environment = vc(D50,  64.0,  64\/5, dimSurrounding);\n+    public static final double[] sRGB_encoding_environment = vc(D50,  64.0,  64.0\/5, dimSurrounding);\n@@ -79,1 +129,1 @@\n-    public static final double[] sRGB_typical_environment  = vc(D50, 200.0, 200\/5, averageSurrounding);\n+    public static final double[] sRGB_typical_environment  = vc(D50, 200.0, 200.0\/5, averageSurrounding);\n@@ -81,1 +131,1 @@\n-    public static final double[] AdobeRGB_environment      = vc(D65, 160.0, 160\/5, averageSurrounding);\n+    public static final double[] AdobeRGB_environment      = vc(D65, 160.0, 160.0\/5, averageSurrounding);\n@@ -133,1 +183,1 @@\n-    private static int roundColor(int color, int[] colors, int max, String dist) {\n+    static int roundColor(int color, int[] colors, int max, String dist) {\n@@ -137,1 +187,2 @@\n-    private interface Distance {\n+    @FunctionalInterface\n+    interface Distance {\n@@ -141,1 +192,1 @@\n-    private static int roundColor(int color, int[] colors, int max, Distance distance) {\n+    static int roundColor(int color, int[] colors, int max, Distance distance) {\n@@ -154,1 +205,1 @@\n-    private static Distance getDistance(String dist) {\n+    static Distance getDistance(String dist) {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Colors.java","additions":86,"deletions":35,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -355,1 +355,72 @@\n-                            throw new UnsupportedOperationException();\n+                            if (ch == ':') {\n+                                ch = str.charAt(index++);\n+                            }\n+                            boolean alternate = false;\n+                            boolean left = false;\n+                            boolean space = false;\n+                            boolean plus = false;\n+                            int width = 0;\n+                            int prec = -1;\n+                            int cnv;\n+                            while (\"-+# \".indexOf(ch) >= 0) {\n+                                switch (ch) {\n+                                    case '-': left = true; break;\n+                                    case '+': plus = true; break;\n+                                    case '#': alternate = true; break;\n+                                    case ' ': space = true; break;\n+                                }\n+                                ch = str.charAt(index++);\n+                            }\n+                            if (\"123456789\".indexOf(ch) >= 0) {\n+                                do {\n+                                    width = width * 10 + (ch - '0');\n+                                    ch = str.charAt(index++);\n+                                } while (\"0123456789\".indexOf(ch) >= 0);\n+                            }\n+                            if (ch == '.') {\n+                                prec = 0;\n+                                ch = str.charAt(index++);\n+                            }\n+                            if (\"0123456789\".indexOf(ch) >= 0) {\n+                                do {\n+                                    prec = prec * 10 + (ch - '0');\n+                                    ch = str.charAt(index++);\n+                                } while (\"0123456789\".indexOf(ch) >= 0);\n+                            }\n+                            if (\"cdoxXs\".indexOf(ch) < 0) {\n+                                throw new IllegalArgumentException();\n+                            }\n+                            cnv = ch;\n+                            if (exec) {\n+                                String res;\n+                                if (cnv == 's') {\n+                                    res = (String) stack.pop();\n+                                    if (prec >= 0) {\n+                                        res = res.substring(0, prec);\n+                                    }\n+                                } else {\n+                                    int p = toInteger(stack.pop());\n+                                    StringBuilder fmt = new StringBuilder(16);\n+                                    fmt.append('%');\n+                                    if (alternate) {\n+                                        fmt.append('#');\n+                                    }\n+                                    if (plus) {\n+                                        fmt.append('+');\n+                                    }\n+                                    if (space) {\n+                                        fmt.append(' ');\n+                                    }\n+                                    if (prec >= 0) {\n+                                        fmt.append('0');\n+                                        fmt.append(prec);\n+                                    }\n+                                    fmt.append((char) cnv);\n+                                    res = String.format(fmt.toString(), p);\n+                                }\n+                                if (width > res.length()) {\n+                                    res = String.format(\"%\" + (left ? \"-\" : \"\") + width + \"s\", res);\n+                                }\n+                                out.append(res);\n+                            }\n+                            break;\n@@ -359,1 +430,1 @@\n-                    if (str.charAt(index) == '<') {\n+                    if (index < length && str.charAt(index) == '<') {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Curses.java","additions":73,"deletions":2,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+        if (rows == 0 || columns == 0) {\n+            columns = Integer.MAX_VALUE - 1;\n+            rows = 1;\n+        }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Display.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -622,1 +622,1 @@\n-                \"screen\", \"screen-256color\")) {\n+                \"screen\", \"screen-256color\", \"rxvt-unicode\", \"rxvt-unicode-256color\", \"rxvt-basic\", \"rxvt\")) {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/InfoCmp.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author or authors.\n@@ -25,2 +25,3 @@\n-public final class Log\n-{\n+public final class Log {\n+\/\/    private static final Logger logger = Logger.getLogger(\"org.jline\");\n+\n@@ -113,1 +114,0 @@\n-\/\/        Logger logger = Logger.getLogger(\"org.jline\");\n@@ -123,1 +123,0 @@\n-\/\/        Logger logger = Logger.getLogger(\"org.jline\");\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Log.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -109,0 +109,14 @@\n+    @Override\n+    public synchronized int readBuffered(byte[] b) throws IOException {\n+        checkIoException();\n+        int res = wait(readBuffer, 0L);\n+        if (res >= 0) {\n+            res = 0;\n+            while (res < b.length && readBuffer.hasRemaining()) {\n+                b[res++] = (byte) (readBuffer.get() & 0x00FF);\n+            }\n+        }\n+        rewind(readBuffer, writeBuffer);\n+        return res;\n+    }\n+\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingPumpInputStream.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -77,1 +77,5 @@\n-                    notEmpty.await(timeout, TimeUnit.MILLISECONDS);\n+                    if (timeout > 0L) {\n+                        notEmpty.await(timeout, TimeUnit.MILLISECONDS);\n+                    } else {\n+                        notEmpty.await();\n+                    }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/NonBlockingPumpReader.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-    public int read(CharBuffer target) throws IOException {\n+    public synchronized int read(CharBuffer target) throws IOException {\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/PumpReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002-2016, the original author or authors.\n+ * Copyright (c) 2002-2020, the original author or authors.\n@@ -12,0 +12,1 @@\n+import java.lang.reflect.InvocationTargetException;\n@@ -94,2 +95,6 @@\n-        } catch (IllegalArgumentException e) {\n-            Log.trace(() -> \"Ignoring unsupported signal \" + name);\n+        } catch (InvocationTargetException e) {\n+            if (e.getCause() instanceof IllegalArgumentException) {\n+                Log.trace(() -> \"Ignoring unsupported signal \" + name);\n+            } else {\n+                Log.debug(\"Error registering handler for signal \", name, e);\n+            }\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Signals.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,32 @@\n+    \/**\n+     * Returns the RGB color for the given name.\n+     * <p>\n+     * Bright color can be specified with: {@code !<color>} or {@code bright-<color>}.\n+     * <p>\n+     * Full xterm256 color can be specified with: {@code ~<color>}.\n+     * RGB colors can be specified with: {@code x<rgb>} or {@code #<rgb>} where {@code rgb} is\n+     * a 24 bits hexadecimal color.\n+     *\n+     * @param name the name of the color\n+     * @return color code, or {@code null} if unable to determine.\n+     *\/\n+    private static Integer colorRgb(String name) {\n+        name = name.toLowerCase(Locale.US);\n+        \/\/ check hexadecimal color\n+        if (name.charAt(0) == 'x' || name.charAt(0) == '#') {\n+            try {\n+                return Integer.parseInt(name.substring(1), 16);\n+            } catch (NumberFormatException e) {\n+\/\/                log.warning(\"Invalid hexadecimal color: \" + name);\n+                return null;\n+            }\n+        } else {\n+           \/\/ load indexed color\n+           Integer color = color(name);\n+           if (color != null && color != -1) {\n+               color = Colors.DEFAULT_COLORS_256[color];\n+           }\n+           return color;\n+        }\n+    }\n+\n@@ -47,1 +79,0 @@\n-        name = name.toLowerCase(Locale.US);\n@@ -49,0 +80,3 @@\n+        if (name.equals(\"default\")) {\n+            return -1;\n+        }\n@@ -50,2 +84,2 @@\n-        if (name.charAt(0) == '!') {\n-            name = name.substring(1, name.length());\n+        else if (name.charAt(0) == '!') {\n+            name = name.substring(1);\n@@ -54,1 +88,1 @@\n-            name = name.substring(7, name.length());\n+            name = name.substring(7);\n@@ -57,0 +91,1 @@\n+            name = name.substring(1);\n@@ -58,4 +93,0 @@\n-                \/\/ TODO: if the palette is not the default one, should be\n-                \/\/ TODO: translate into 24-bits first and let the #toAnsi() call\n-                \/\/ TODO: round with the current palette ?\n-                name = name.substring(1, name.length());\n@@ -300,19 +331,45 @@\n-        Integer color = color(colorName);\n-        if (color == null) {\n-\/\/            log.warning(\"Invalid color-name: \" + colorName);\n-        } else {\n-            \/\/ resolve and apply color-mode\n-            switch (colorMode.toLowerCase(Locale.US)) {\n-                case \"foreground\":\n-                case \"fg\":\n-                case \"f\":\n-                    return style.foreground(color);\n-\n-                case \"background\":\n-                case \"bg\":\n-                case \"b\":\n-                    return style.background(color);\n-\n-                default:\n-\/\/                    log.warning(\"Invalid color-mode: \" + colorMode);\n-            }\n+        Integer color;\n+        \/\/ resolve and apply color-mode\n+        switch (colorMode.toLowerCase(Locale.US)) {\n+            case \"foreground\":\n+            case \"fg\":\n+            case \"f\":\n+                color = color(colorName);\n+                if (color == null) {\n+\/\/                    log.warning(\"Invalid color-name: \" + colorName);\n+                    break;\n+                }\n+                return color >= 0 ? style.foreground(color) : style.foregroundDefault();\n+\n+            case \"background\":\n+            case \"bg\":\n+            case \"b\":\n+                color = color(colorName);\n+                if (color == null) {\n+\/\/                    log.warning(\"Invalid color-name: \" + colorName);\n+                    break;\n+                }\n+                return color >= 0 ? style.background(color) : style.backgroundDefault();\n+\n+            case \"foreground-rgb\":\n+            case \"fg-rgb\":\n+            case \"f-rgb\":\n+                color = colorRgb(colorName);\n+                if (color == null) {\n+\/\/                    log.warning(\"Invalid color-name: \" + colorName);\n+                    break;\n+                }\n+                return color >= 0 ? style.foregroundRgb(color) : style.foregroundDefault();\n+\n+            case \"background-rgb\":\n+            case \"bg-rgb\":\n+            case \"b-rgb\":\n+                color = colorRgb(colorName);\n+                if (color == null) {\n+\/\/                    log.warning(\"Invalid color-name: \" + colorName);\n+                    break;\n+                }\n+                return color >= 0 ? style.backgroundRgb(color) : style.backgroundDefault();\n+\n+            default:\n+\/\/                log.warning(\"Invalid color-mode: \" + colorMode);\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/StyleResolver.java","additions":84,"deletions":27,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+#\tReconstructed via infocmp from file: \/lib\/terminfo\/r\/rxvt-basic\n+rxvt-basic|rxvt-m|rxvt terminal base (X Window System),\n+\tam, bce, eo, km, mir, msgr, xenl, xon,\n+\tcols#80, it#8, lines#24,\n+\tacsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,\n+\tbel=^G, blink=\\E[5m, bold=\\E[1m, civis=\\E[?25l,\n+\tclear=\\E[H\\E[2J, cnorm=\\E[?25h, cr=\\r,\n+\tcsr=\\E[%i%p1%d;%p2%dr, cub=\\E[%p1%dD, cub1=^H,\n+\tcud=\\E[%p1%dB, cud1=\\n, cuf=\\E[%p1%dC, cuf1=\\E[C,\n+\tcup=\\E[%i%p1%d;%p2%dH, cuu=\\E[%p1%dA, cuu1=\\E[A,\n+\tdl=\\E[%p1%dM, dl1=\\E[M, ed=\\E[J, el=\\E[K, el1=\\E[1K,\n+\tenacs=\\E(B\\E)0, flash=\\E[?5h\\E[?5l, home=\\E[H,\n+\thpa=\\E[%i%p1%dG, ht=^I, hts=\\EH, ich=\\E[%p1%d@, ich1=\\E[@,\n+\til=\\E[%p1%dL, il1=\\E[L, ind=\\n, is1=\\E[?47l\\E=\\E[?1l,\n+\tis2=\\E[r\\E[m\\E[2J\\E[H\\E[?7h\\E[?1;3;4;6l\\E[4l,\n+\tkDC=\\E[3$, kEND=\\E[8$, kHOM=\\E[7$, kLFT=\\E[d, kNXT=\\E[6$,\n+\tkPRV=\\E[5$, kRIT=\\E[c, ka1=\\EOw, ka3=\\EOy, kb2=\\EOu, kbs=^?,\n+\tkc1=\\EOq, kc3=\\EOs, kcbt=\\E[Z, kcub1=\\E[D, kcud1=\\E[B,\n+\tkcuf1=\\E[C, kcuu1=\\E[A, kdch1=\\E[3~, kel=\\E[8\\^,\n+\tkend=\\E[8~, kent=\\EOM, kf1=\\E[11~, kf10=\\E[21~,\n+\tkf11=\\E[23~, kf12=\\E[24~, kf13=\\E[25~, kf14=\\E[26~,\n+\tkf15=\\E[28~, kf16=\\E[29~, kf17=\\E[31~, kf18=\\E[32~,\n+\tkf19=\\E[33~, kf2=\\E[12~, kf20=\\E[34~, kf21=\\E[23$,\n+\tkf22=\\E[24$, kf23=\\E[11\\^, kf24=\\E[12\\^, kf25=\\E[13\\^,\n+\tkf26=\\E[14\\^, kf27=\\E[15\\^, kf28=\\E[17\\^, kf29=\\E[18\\^,\n+\tkf3=\\E[13~, kf30=\\E[19\\^, kf31=\\E[20\\^, kf32=\\E[21\\^,\n+\tkf33=\\E[23\\^, kf34=\\E[24\\^, kf35=\\E[25\\^, kf36=\\E[26\\^,\n+\tkf37=\\E[28\\^, kf38=\\E[29\\^, kf39=\\E[31\\^, kf4=\\E[14~,\n+\tkf40=\\E[32\\^, kf41=\\E[33\\^, kf42=\\E[34\\^, kf43=\\E[23@,\n+\tkf44=\\E[24@, kf5=\\E[15~, kf6=\\E[17~, kf7=\\E[18~,\n+\tkf8=\\E[19~, kf9=\\E[20~, kfnd=\\E[1~, khome=\\E[7~,\n+\tkich1=\\E[2~, kmous=\\E[M, knp=\\E[6~, kpp=\\E[5~, kslt=\\E[4~,\n+\trc=\\E8, rev=\\E[7m, ri=\\EM, rmacs=^O, rmcup=\\E[2J\\E[?47l\\E8,\n+\trmir=\\E[4l, rmkx=\\E>, rmso=\\E[27m, rmul=\\E[24m,\n+\trs1=\\E>\\E[1;3;4;5;6l\\E[?7h\\E[m\\E[r\\E[2J\\E[H,\n+\trs2=\\E[r\\E[m\\E[2J\\E[H\\E[?7h\\E[?1;3;4;6l\\E[4l\\E=\\E[?1000l\\E[?25h,\n+\ts0ds=\\E(B, s1ds=\\E(0, sc=\\E7,\n+\tsgr=\\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;m%?%p9%t\\016%e\\017%;,\n+\tsgr0=\\E[0m\\017, smacs=^N, smcup=\\E7\\E[?47h, smir=\\E[4h,\n+\tsmkx=\\E=, smso=\\E[7m, smul=\\E[4m, tbc=\\E[3g,\n+\tvpa=\\E[%i%p1%dd,\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/rxvt-basic.caps","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+#\tReconstructed via infocmp from file: \/lib\/terminfo\/r\/rxvt-unicode-256color\n+rxvt-unicode-256color|rxvt-unicode terminal with 256 colors (X Window System),\n+\tam, bce, bw, ccc, eo, hs, km, mc5i, mir, msgr, npc, xenl, xon,\n+\tbtns#5, colors#0x100, cols#80, it#8, lines#24, lm#0, ncv#0,\n+\tpairs#0x7fff,\n+\tacsc=+C\\,D-A.B0E``aaffgghFiGjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,\n+\tbel=^G, blink=\\E[5m, bold=\\E[1m, civis=\\E[?25l,\n+\tclear=\\E[H\\E[2J, cnorm=\\E[?12l\\E[?25h, cr=\\r,\n+\tcsr=\\E[%i%p1%d;%p2%dr, cub=\\E[%p1%dD, cub1=^H,\n+\tcud=\\E[%p1%dB, cud1=\\n, cuf=\\E[%p1%dC, cuf1=\\E[C,\n+\tcup=\\E[%i%p1%d;%p2%dH, cuu=\\E[%p1%dA, cuu1=\\E[A,\n+\tcvvis=\\E[?12;25h, dch=\\E[%p1%dP, dch1=\\E[P, dl=\\E[%p1%dM,\n+\tdl1=\\E[M, dsl=\\E]2;\\007, ech=\\E[%p1%dX, ed=\\E[J, el=\\E[K,\n+\tel1=\\E[1K, enacs=, flash=\\E[?5h$<20\/>\\E[?5l, fsl=^G,\n+\thome=\\E[H, hpa=\\E[%i%p1%dG, ht=^I, hts=\\EH, ich=\\E[%p1%d@,\n+\tich1=\\E[@, il=\\E[%p1%dL, il1=\\E[L, ind=\\n, indn=\\E[%p1%dS,\n+\tinitc=\\E]4;%p1%d;rgb\\:%p2%{65535}%*%{1000}%\/%4.4X\/%p3%{65535}%*%{1000}%\/%4.4X\/%p4%{65535}%*%{1000}%\/%4.4X\\E\\\\,\n+\tis1=\\E[!p,\n+\tis2=\\E[r\\E[m\\E[2J\\E[?7;25h\\E[?1;3;4;5;6;9;66;1000;1001;1049l\\E[4l,\n+\tkDC=\\E[3$, kEND=\\E[8$, kFND=\\E[1$, kHOM=\\E[7$, kIC=\\E[2$,\n+\tkLFT=\\E[d, kNXT=\\E[6$, kPRV=\\E[5$, kRIT=\\E[c, ka1=\\EOw,\n+\tka3=\\EOy, kb2=\\EOu, kbs=^?, kc1=\\EOq, kc3=\\EOs, kcbt=\\E[Z,\n+\tkcub1=\\E[D, kcud1=\\E[B, kcuf1=\\E[C, kcuu1=\\E[A,\n+\tkdch1=\\E[3~, kel=\\E[8\\^, kend=\\E[8~, kent=\\EOM, kf1=\\E[11~,\n+\tkf10=\\E[21~, kf11=\\E[23~, kf12=\\E[24~, kf13=\\E[25~,\n+\tkf14=\\E[26~, kf15=\\E[28~, kf16=\\E[29~, kf17=\\E[31~,\n+\tkf18=\\E[32~, kf19=\\E[33~, kf2=\\E[12~, kf20=\\E[34~,\n+\tkf3=\\E[13~, kf4=\\E[14~, kf5=\\E[15~, kf6=\\E[17~, kf7=\\E[18~,\n+\tkf8=\\E[19~, kf9=\\E[20~, kfnd=\\E[1~, khome=\\E[7~,\n+\tkich1=\\E[2~, kmous=\\E[M, knp=\\E[6~, kpp=\\E[5~, kslt=\\E[4~,\n+\tmc0=\\E[i, mc4=\\E[4i, mc5=\\E[5i, op=\\E[39;49m, rc=\\E8,\n+\trev=\\E[7m, ri=\\EM, rin=\\E[%p1%dT, ritm=\\E[23m, rmacs=\\E(B,\n+\trmam=\\E[?7l, rmcup=\\E[r\\E[?1049l, rmir=\\E[4l, rmkx=\\E>,\n+\trmso=\\E[27m, rmul=\\E[24m, rs1=\\Ec,\n+\trs2=\\E[r\\E[m\\E[?7;25h\\E[?1;3;4;5;6;9;66;1000;1001;1049l\\E[4l,\n+\ts0ds=\\E(B, s1ds=\\E(0, s2ds=\\E*B, s3ds=\\E+B, sc=\\E7,\n+\tsetab=\\E[48;5;%p1%dm, setaf=\\E[38;5;%p1%dm,\n+\tsetb=%?%p1%{7}%>%t\\E[48;5;%p1%dm%e\\E[4%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m%;,\n+\tsetf=%?%p1%{7}%>%t\\E[38;5;%p1%dm%e\\E[3%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m%;,\n+\tsgr=\\E[%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p7%t;8%;m%?%p9%t\\E(0%e\\E(B%;,\n+\tsgr0=\\E[m\\E(B, sitm=\\E[3m, smacs=\\E(0, smam=\\E[?7h,\n+\tsmcup=\\E[?1049h, smir=\\E[4h, smkx=\\E=, smso=\\E[7m,\n+\tsmul=\\E[4m, tbc=\\E[3g, tsl=\\E]2;, u6=\\E[%i%d;%dR, u7=\\E[6n,\n+\tu8=\\E[?1;2c, u9=\\E[c, vpa=\\E[%i%p1%dd,\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/rxvt-unicode-256color.caps","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+#\tReconstructed via infocmp from file: \/lib\/terminfo\/r\/rxvt-unicode\n+rxvt-unicode|rxvt-unicode terminal (X Window System),\n+\tam, bce, bw, ccc, eo, hs, km, mc5i, mir, msgr, npc, xenl, xon,\n+\tbtns#5, colors#88, cols#80, it#8, lines#24, lm#0, ncv#0,\n+\tpairs#7744,\n+\tacsc=+C\\,D-A.B0E``aaffgghFiGjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,\n+\tbel=^G, blink=\\E[5m, bold=\\E[1m, civis=\\E[?25l,\n+\tclear=\\E[H\\E[2J, cnorm=\\E[?12l\\E[?25h, cr=\\r,\n+\tcsr=\\E[%i%p1%d;%p2%dr, cub=\\E[%p1%dD, cub1=^H,\n+\tcud=\\E[%p1%dB, cud1=\\n, cuf=\\E[%p1%dC, cuf1=\\E[C,\n+\tcup=\\E[%i%p1%d;%p2%dH, cuu=\\E[%p1%dA, cuu1=\\E[A,\n+\tcvvis=\\E[?12;25h, dch=\\E[%p1%dP, dch1=\\E[P, dl=\\E[%p1%dM,\n+\tdl1=\\E[M, dsl=\\E]2;\\007, ech=\\E[%p1%dX, ed=\\E[J, el=\\E[K,\n+\tel1=\\E[1K, enacs=, flash=\\E[?5h$<20\/>\\E[?5l, fsl=^G,\n+\thome=\\E[H, hpa=\\E[%i%p1%dG, ht=^I, hts=\\EH, ich=\\E[%p1%d@,\n+\tich1=\\E[@, il=\\E[%p1%dL, il1=\\E[L, ind=\\n, indn=\\E[%p1%dS,\n+\tinitc=\\E]4;%p1%d;rgb\\:%p2%{65535}%*%{1000}%\/%4.4X\/%p3%{65535}%*%{1000}%\/%4.4X\/%p4%{65535}%*%{1000}%\/%4.4X\\E\\\\,\n+\tis1=\\E[!p,\n+\tis2=\\E[r\\E[m\\E[2J\\E[?7;25h\\E[?1;3;4;5;6;9;66;1000;1001;1049l\\E[4l,\n+\tkDC=\\E[3$, kEND=\\E[8$, kFND=\\E[1$, kHOM=\\E[7$, kIC=\\E[2$,\n+\tkLFT=\\E[d, kNXT=\\E[6$, kPRV=\\E[5$, kRIT=\\E[c, ka1=\\EOw,\n+\tka3=\\EOy, kb2=\\EOu, kbs=^?, kc1=\\EOq, kc3=\\EOs, kcbt=\\E[Z,\n+\tkcub1=\\E[D, kcud1=\\E[B, kcuf1=\\E[C, kcuu1=\\E[A,\n+\tkdch1=\\E[3~, kel=\\E[8\\^, kend=\\E[8~, kent=\\EOM, kf1=\\E[11~,\n+\tkf10=\\E[21~, kf11=\\E[23~, kf12=\\E[24~, kf13=\\E[25~,\n+\tkf14=\\E[26~, kf15=\\E[28~, kf16=\\E[29~, kf17=\\E[31~,\n+\tkf18=\\E[32~, kf19=\\E[33~, kf2=\\E[12~, kf20=\\E[34~,\n+\tkf3=\\E[13~, kf4=\\E[14~, kf5=\\E[15~, kf6=\\E[17~, kf7=\\E[18~,\n+\tkf8=\\E[19~, kf9=\\E[20~, kfnd=\\E[1~, khome=\\E[7~,\n+\tkich1=\\E[2~, kmous=\\E[M, knp=\\E[6~, kpp=\\E[5~, kslt=\\E[4~,\n+\tmc0=\\E[i, mc4=\\E[4i, mc5=\\E[5i, op=\\E[39;49m, rc=\\E8,\n+\trev=\\E[7m, ri=\\EM, rin=\\E[%p1%dT, ritm=\\E[23m, rmacs=\\E(B,\n+\trmam=\\E[?7l, rmcup=\\E[r\\E[?1049l, rmir=\\E[4l, rmkx=\\E>,\n+\trmso=\\E[27m, rmul=\\E[24m, rs1=\\Ec,\n+\trs2=\\E[r\\E[m\\E[?7;25h\\E[?1;3;4;5;6;9;66;1000;1001;1049l\\E[4l,\n+\ts0ds=\\E(B, s1ds=\\E(0, s2ds=\\E*B, s3ds=\\E+B, sc=\\E7,\n+\tsetab=\\E[48;5;%p1%dm, setaf=\\E[38;5;%p1%dm,\n+\tsetb=%?%p1%{7}%>%t\\E[48;5;%p1%dm%e\\E[4%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m%;,\n+\tsetf=%?%p1%{7}%>%t\\E[38;5;%p1%dm%e\\E[3%?%p1%{1}%=%t4%e%p1%{3}%=%t6%e%p1%{4}%=%t1%e%p1%{6}%=%t3%e%p1%d%;m%;,\n+\tsgr=\\E[%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p7%t;8%;m%?%p9%t\\E(0%e\\E(B%;,\n+\tsgr0=\\E[m\\E(B, sitm=\\E[3m, smacs=\\E(0, smam=\\E[?7h,\n+\tsmcup=\\E[?1049h, smir=\\E[4h, smkx=\\E=, smso=\\E[7m,\n+\tsmul=\\E[4m, tbc=\\E[3g, tsl=\\E]2;, u6=\\E[%i%d;%dR, u7=\\E[6n,\n+\tu8=\\E[?1;2c, u9=\\E[c, vpa=\\E[%i%p1%dd,\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/rxvt-unicode.caps","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+#\tReconstructed via infocmp from file: \/lib\/terminfo\/r\/rxvt\n+rxvt|rxvt terminal emulator (X Window System),\n+\tam, bce, eo, km, mir, msgr, xenl, xon,\n+\tcolors#8, cols#80, it#8, lines#24, ncv@, pairs#64,\n+\tacsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~,\n+\tbel=^G, blink=\\E[5m, bold=\\E[1m, civis=\\E[?25l,\n+\tclear=\\E[H\\E[2J, cnorm=\\E[?25h, cr=\\r,\n+\tcsr=\\E[%i%p1%d;%p2%dr, cub=\\E[%p1%dD, cub1=^H,\n+\tcud=\\E[%p1%dB, cud1=\\n, cuf=\\E[%p1%dC, cuf1=\\E[C,\n+\tcup=\\E[%i%p1%d;%p2%dH, cuu=\\E[%p1%dA, cuu1=\\E[A,\n+\tdl=\\E[%p1%dM, dl1=\\E[M, ed=\\E[J, el=\\E[K, el1=\\E[1K,\n+\tenacs=\\E(B\\E)0, flash=\\E[?5h\\E[?5l, home=\\E[H,\n+\thpa=\\E[%i%p1%dG, ht=^I, hts=\\EH, ich=\\E[%p1%d@, ich1=\\E[@,\n+\til=\\E[%p1%dL, il1=\\E[L, ind=\\n, is1=\\E[?47l\\E=\\E[?1l,\n+\tis2=\\E[r\\E[m\\E[2J\\E[H\\E[?7h\\E[?1;3;4;6l\\E[4l,\n+\tkDC=\\E[3$, kEND=\\E[8$, kHOM=\\E[7$, kLFT=\\E[d, kNXT=\\E[6$,\n+\tkPRV=\\E[5$, kRIT=\\E[c, ka1=\\EOw, ka3=\\EOy, kb2=\\EOu, kbs=^?,\n+\tkc1=\\EOq, kc3=\\EOs, kcbt=\\E[Z, kcub1=\\E[D, kcud1=\\E[B,\n+\tkcuf1=\\E[C, kcuu1=\\E[A, kdch1=\\E[3~, kel=\\E[8\\^,\n+\tkend=\\E[8~, kent=\\EOM, kf1=\\E[11~, kf10=\\E[21~,\n+\tkf11=\\E[23~, kf12=\\E[24~, kf13=\\E[25~, kf14=\\E[26~,\n+\tkf15=\\E[28~, kf16=\\E[29~, kf17=\\E[31~, kf18=\\E[32~,\n+\tkf19=\\E[33~, kf2=\\E[12~, kf20=\\E[34~, kf21=\\E[23$,\n+\tkf22=\\E[24$, kf23=\\E[11\\^, kf24=\\E[12\\^, kf25=\\E[13\\^,\n+\tkf26=\\E[14\\^, kf27=\\E[15\\^, kf28=\\E[17\\^, kf29=\\E[18\\^,\n+\tkf3=\\E[13~, kf30=\\E[19\\^, kf31=\\E[20\\^, kf32=\\E[21\\^,\n+\tkf33=\\E[23\\^, kf34=\\E[24\\^, kf35=\\E[25\\^, kf36=\\E[26\\^,\n+\tkf37=\\E[28\\^, kf38=\\E[29\\^, kf39=\\E[31\\^, kf4=\\E[14~,\n+\tkf40=\\E[32\\^, kf41=\\E[33\\^, kf42=\\E[34\\^, kf43=\\E[23@,\n+\tkf44=\\E[24@, kf5=\\E[15~, kf6=\\E[17~, kf7=\\E[18~,\n+\tkf8=\\E[19~, kf9=\\E[20~, kfnd=\\E[1~, khome=\\E[7~,\n+\tkich1=\\E[2~, kmous=\\E[M, knp=\\E[6~, kpp=\\E[5~, kslt=\\E[4~,\n+\top=\\E[39;49m, rc=\\E8, rev=\\E[7m, ri=\\EM, rmacs=^O,\n+\trmcup=\\E[2J\\E[?47l\\E8, rmir=\\E[4l, rmkx=\\E>, rmso=\\E[27m,\n+\trmul=\\E[24m,\n+\trs1=\\E>\\E[1;3;4;5;6l\\E[?7h\\E[m\\E[r\\E[2J\\E[H,\n+\trs2=\\E[r\\E[m\\E[2J\\E[H\\E[?7h\\E[?1;3;4;6l\\E[4l\\E=\\E[?1000l\\E[?25h,\n+\ts0ds=\\E(B, s1ds=\\E(0, sc=\\E7, setab=\\E[4%p1%dm,\n+\tsetaf=\\E[3%p1%dm,\n+\tsgr=\\E[0%?%p6%t;1%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;m%?%p9%t\\016%e\\017%;,\n+\tsgr0=\\E[m\\017, smacs=^N, smcup=\\E7\\E[?47h, smir=\\E[4h,\n+\tsmkx=\\E=, smso=\\E[7m, smul=\\E[4m, tbc=\\E[3g,\n+\tvpa=\\E[%i%p1%dd,\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/rxvt.caps","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-## JLine v3.14.0\n+## JLine v3.20.0\n","filename":"src\/jdk.internal.le\/share\/legal\/jline.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -17,0 +17,1 @@\n+import jdk.internal.org.jline.utils.OSUtils;\n@@ -50,0 +51,26 @@\n+\n+    @Override\n+    public boolean isWindowsConsole() {\n+        return JnaWinSysTerminal.isWindowsConsole();\n+    }\n+\n+    @Override\n+    public boolean isConsoleOutput() {\n+        if (OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM) {\n+            throw new UnsupportedOperationException();\n+        } else if (OSUtils.IS_WINDOWS) {\n+            return JnaWinSysTerminal.isConsoleOutput();\n+        }\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean isConsoleInput() {\n+        if (OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM) {\n+            throw new UnsupportedOperationException();\n+        } else if (OSUtils.IS_WINDOWS) {\n+            return JnaWinSysTerminal.isConsoleInput();\n+        }\n+        throw new UnsupportedOperationException();\n+    }\n+\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JnaSupportImpl.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -73,0 +73,31 @@\n+    public static boolean isWindowsConsole() {\n+        try {\n+            IntByReference mode = new IntByReference();\n+            Kernel32.INSTANCE.GetConsoleMode(consoleOut, mode);\n+            Kernel32.INSTANCE.GetConsoleMode(consoleIn, mode);\n+            return true;\n+        } catch (LastErrorException e) {\n+            return false;\n+        }\n+    }\n+\n+    public static boolean isConsoleOutput() {\n+        try {\n+            IntByReference mode = new IntByReference();\n+            Kernel32.INSTANCE.GetConsoleMode(consoleOut, mode);\n+            return true;\n+        } catch (LastErrorException e) {\n+            return false;\n+        }\n+    }\n+\n+    public static boolean isConsoleInput() {\n+        try {\n+            IntByReference mode = new IntByReference();\n+            Kernel32.INSTANCE.GetConsoleMode(consoleIn, mode);\n+            return true;\n+        } catch (LastErrorException e) {\n+            return false;\n+        }\n+    }\n+\n@@ -78,5 +109,0 @@\n-    @Override\n-    protected int getConsoleOutputCP() {\n-        return Kernel32.INSTANCE.GetConsoleOutputCP();\n-    }\n-\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/win\/JnaWinSysTerminal.java","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,5 +60,0 @@\n-            @Override\n-            protected int getConsoleOutputCP() {\n-                throw new UnsupportedOperationException(\"unexpected.\");\n-            }\n-\n","filename":"test\/jdk\/jdk\/internal\/jline\/AbstractWindowsTerminalTest.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import jdk.internal.org.jline.terminal.Terminal.SignalHandler;\n@@ -61,5 +62,1 @@\n-                                    0, true, null, in -> in) {\n-            @Override\n-            protected int getConsoleOutputCP() {\n-                throw new UnsupportedOperationException(\"Not supported yet.\");\n-            }\n+                                    0, true, SignalHandler.SIG_DFL, in -> in) {\n","filename":"test\/jdk\/jdk\/internal\/jline\/KeyConversionTest.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"}]}