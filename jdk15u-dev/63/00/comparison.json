{"files":[{"patch":"@@ -161,1 +161,1 @@\n-bool InstanceKlass::has_nest_member(InstanceKlass* k, TRAPS) const {\n+bool InstanceKlass::has_nest_member(JavaThread* current, InstanceKlass* k) const {\n@@ -165,1 +165,1 @@\n-      ResourceMark rm(THREAD);\n+      ResourceMark rm(current);\n@@ -173,1 +173,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -178,2 +178,2 @@\n-  \/\/ Check for a resolved cp entry , else fall back to a name check.\n-  \/\/ We don't want to resolve any class other than the one being checked.\n+  \/\/ Check for the named class in _nest_members.\n+  \/\/ We don't resolve, or load, any classes.\n@@ -182,33 +182,4 @@\n-    if (_constants->tag_at(cp_index).is_klass()) {\n-      Klass* k2 = _constants->klass_at(cp_index, THREAD);\n-      assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass()),\n-             \"Exceptions should not be possible here\");\n-      if (k2 == k) {\n-        log_trace(class, nestmates)(\"- class is listed at nest_members[%d] => cp[%d]\", i, cp_index);\n-        return true;\n-      }\n-    }\n-    else {\n-      Symbol* name = _constants->klass_name_at(cp_index);\n-      if (name == k->name()) {\n-        log_trace(class, nestmates)(\"- Found it at nest_members[%d] => cp[%d]\", i, cp_index);\n-\n-        \/\/ Names match so check actual klass. This may trigger class loading if\n-        \/\/ it doesn't match though that should be impossible as it means one classloader\n-        \/\/ has defined two different classes with the same name! A compiler thread won't be\n-        \/\/ able to perform that loading but we can't exclude the compiler threads from\n-        \/\/ executing this logic. But it should actually be impossible to trigger loading here.\n-        Klass* k2 = _constants->klass_at(cp_index, THREAD);\n-        assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass()),\n-               \"Exceptions should not be possible here\");\n-        if (k2 == k) {\n-          log_trace(class, nestmates)(\"- class is listed as a nest member\");\n-          return true;\n-        }\n-        else {\n-          \/\/ same name but different klass!\n-          log_trace(class, nestmates)(\" - klass comparison failed!\");\n-          \/\/ can't have two names the same, so we're done\n-          return false;\n-        }\n-      }\n+    Symbol* name = _constants->klass_name_at(cp_index);\n+    if (name == k->name()) {\n+      log_trace(class, nestmates)(\"- named class found at nest_members[%d] => cp[%d]\", i, cp_index);\n+      return true;\n@@ -296,1 +267,2 @@\n-    if (!THREAD->can_call_java() && !_constants->tag_at(_nest_host_index).is_klass()) {\n+    bool can_resolve = THREAD->can_call_java();\n+    if (!can_resolve && !_constants->tag_at(_nest_host_index).is_klass()) {\n@@ -334,5 +306,3 @@\n-          bool is_member = nest_host_k->has_nest_member(this, THREAD);\n-          \/\/ exception is rare, perhaps impossible\n-          if (!HAS_PENDING_EXCEPTION) {\n-            if (is_member) {\n-              _nest_host = nest_host_k; \/\/ save resolved nest-host value\n+          bool is_member = nest_host_k->has_nest_member((JavaThread*) THREAD, this);\n+          if (is_member) {\n+            _nest_host = nest_host_k; \/\/ save resolved nest-host value\n@@ -340,6 +310,3 @@\n-              log_trace(class, nestmates)(\"Resolved nest-host of %s to %s\",\n-                                          this->external_name(), k->external_name());\n-              return nest_host_k;\n-            } else {\n-              error = \"current type is not listed as a nest member\";\n-            }\n+            log_trace(class, nestmates)(\"Resolved nest-host of %s to %s\",\n+                                        this->external_name(), k->external_name());\n+            return nest_host_k;\n@@ -347,7 +314,1 @@\n-            if (PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass())) {\n-              return NULL; \/\/ propagate VMEs\n-            }\n-            stringStream ss;\n-            ss.print(\"exception on member check: \");\n-            java_lang_Throwable::print(PENDING_EXCEPTION, &ss);\n-            error = ss.as_string();\n+            error = \"current type is not listed as a nest member\";\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":18,"deletions":57,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -483,2 +483,3 @@\n-  \/\/ Called to verify that k is a member of this nest - does not look at k's nest-host\n-  bool has_nest_member(InstanceKlass* k, TRAPS) const;\n+  \/\/ Called to verify that k is a member of this nest - does not look at k's nest-host,\n+  \/\/ nor does it resolve any CP entries or load any classes.\n+  bool has_nest_member(JavaThread* current, InstanceKlass* k) const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Host and Host$Member will be loaded by a custom loader with different\n+\/\/ protection domains.\n+\n+public class Host {\n+\n+    private static int forNestmatesOnly = 1;\n+\n+    public static class Member {\n+        \/\/ We need our static initializer to ensure our CP reference\n+        \/\/ to Host is resolved by the main thread.\n+        static final Class<?> hostClass = Host.class;\n+\n+        int id;\n+\n+        \/\/ Executing, or JIT compiling, this method will result in\n+        \/\/ a nestmate access check.\n+        public Member() {\n+            id = forNestmatesOnly++;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Nestmates\/protectionDomain\/Host.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8261395\n+ * @summary Test the code paths when a nest-host and nest-member class are in\n+ *          different protection domains and the compiler thread needs to\n+ *          perform a nestmate access check.\n+ * @comment We use WB to force-compile a constructor to recreate the original\n+ *          failure scenario, so only run when we have \"normal\" compiler flags.\n+ * @requires vm.compMode==\"Xmixed\" &\n+ *           (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @library \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @compile Host.java\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                   -Xlog:class+nestmates=trace,protectiondomain=trace\n+ *                   -Djava.security.manager=allow\n+ *                   TestDifferentProtectionDomains\n+ *\/\n+\n+import java.lang.reflect.Constructor;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.nio.file.Path;\n+import java.security.ProtectionDomain;\n+\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import sun.hotspot.WhiteBox;\n+\n+public class TestDifferentProtectionDomains {\n+\n+    static final String TARGET = \"Host\";\n+\n+    \/\/ We need a custom classloader so that we can\n+    \/\/ use a different protection domain for our target classes.\n+\n+    static class CustomLoader extends ClassLoader {\n+\n+        CustomLoader(ClassLoader parent) {\n+            super(parent);\n+        }\n+\n+        @Override\n+        public Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n+            synchronized (getClassLoadingLock(name)) {\n+                \/\/ First, check if the class has already been loaded\n+                Class<?> clz = findLoadedClass(name);\n+                if (clz != null) {\n+                    return clz;\n+                }\n+\n+                \/\/ Check for target class\n+                if (name.startsWith(TARGET)) {\n+                    try {\n+                        String clzFile = name.replaceAll(\"\\\\.\", \"\/\") + \".class\";\n+                        byte[] buff = getResourceAsStream(clzFile).readAllBytes();\n+                        ProtectionDomain differentPD = new ProtectionDomain(null, null);\n+                        return defineClass(name, buff, 0, buff.length, differentPD);\n+                    } catch (Throwable t) {\n+                        throw new RuntimeException(\"Unexpected\", t);\n+                    }\n+                }\n+            }\n+            return super.loadClass(name, resolve);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+\n+        CustomLoader cl = new CustomLoader(TestDifferentProtectionDomains.class.getClassLoader());\n+        Class<?> host = cl.loadClass(\"Host\");\n+        Class<?> member = cl.loadClass(\"Host$Member\");\n+\n+        if (host.getProtectionDomain() == member.getProtectionDomain()) {\n+            throw new Error(\"ProtectionDomain instances were not different!\");\n+        }\n+\n+        Constructor cons = member.getDeclaredConstructor(new Class<?>[] {});\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+        \/\/ The code path for the original failure is now only followed when\n+        \/\/ there is a security manager set, so we set one. We do this here\n+        \/\/ as any earlier causes security exceptions running the test and we\n+        \/\/ don't want to have to set up a policy file etc.\n+        System.setSecurityManager(new SecurityManager());\n+\n+        \/\/ Force the constructor to compile, which then triggers the nestmate\n+        \/\/ access check in the compiler thread, which leads to the original bug.\n+        wb.enqueueMethodForCompilation(cons,  CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+        while (!wb.isMethodCompiled(cons)) {\n+            Thread.sleep(100);\n+        }\n+\n+        \/\/ Just for good measure call the compiled constructor.\n+        Object m = member.newInstance();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Nestmates\/protectionDomain\/TestDifferentProtectionDomains.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"}]}