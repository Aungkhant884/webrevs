{"files":[{"patch":"@@ -1024,0 +1024,5 @@\n+#ifdef __APPLE__\n+  \/\/ Is the CPU running emulated (for example macOS Rosetta running x86_64 code on M1 ARM (aarch64)\n+  static bool is_cpu_emulated();\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -602,1 +602,4 @@\n-          (info->si_code == FPE_INTDIV || info->si_code == FPE_FLTDIV)) {\n+          (info->si_code == FPE_INTDIV || info->si_code == FPE_FLTDIV\n+           \/\/ Workaround for macOS ARM incorrectly reporting FPE_FLTINV for \"div by 0\"\n+           \/\/ instead of the expected FPE_FLTDIV when running x86_64 binary under Rosetta emulation\n+           MACOS_ONLY(|| (VM_Version::is_cpu_emulated() && info->si_code == FPE_FLTINV)))) {\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,21 @@\n+\n+#ifdef __APPLE__\n+\n+#include <sys\/types.h>\n+#include <sys\/sysctl.h>\n+\n+bool VM_Version::is_cpu_emulated() {\n+  int ret = 0;\n+  size_t size = sizeof(ret);\n+  \/\/ Is this process being ran in Rosetta (i.e. emulation) mode on macOS?\n+  if (sysctlbyname(\"sysctl.proc_translated\", &ret, &size, NULL, 0) == -1) {\n+    \/\/ errno == ENOENT is a valid response, but anything else is a real error\n+    if (errno != ENOENT) {\n+      warning(\"unable to lookup sysctl.proc_translated\");\n+    }\n+  }\n+  return (ret==1);\n+}\n+\n+#endif\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/vm_version_bsd_x86.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}