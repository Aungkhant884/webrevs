{"files":[{"patch":"@@ -41,0 +41,1 @@\n+import java.util.function.Consumer;\n@@ -56,0 +57,1 @@\n+import org.openjdk.jmc.flightrecorder.internal.parser.ParserStats;\n@@ -60,1 +62,1 @@\n-class EventCollection implements IItemCollection {\n+class EventCollection implements IItemCollection, IParserStats {\n@@ -117,0 +119,1 @@\n+\tprivate final ParserStats parserStats;\n@@ -124,1 +127,1 @@\n-\t\treturn new EventCollection(items, events.getChunkTimeranges());\n+\t\treturn new EventCollection(items, events.getChunkTimeranges(), events.getParserStats());\n@@ -127,1 +130,2 @@\n-\tprivate EventCollection(ArrayList<EventTypeEntry> items, Set<IRange<IQuantity>> chunkRanges) {\n+\tprivate EventCollection(ArrayList<EventTypeEntry> items, Set<IRange<IQuantity>> chunkRanges,\n+\t\t\tParserStats parserStats) {\n@@ -130,0 +134,1 @@\n+\t\tthis.parserStats = parserStats;\n@@ -146,1 +151,1 @@\n-\t\treturn new EventCollection(newEntries, chunkRanges);\n+\t\treturn new EventCollection(newEntries, chunkRanges, parserStats);\n@@ -225,0 +230,35 @@\n+\n+\t@Override\n+\tpublic void forEachEventType(Consumer<IEventStats> consumer) {\n+\t\tparserStats.forEachEventType(consumer);\n+\t}\n+\n+\t@Override\n+\tpublic short getMajorVersion() {\n+\t\treturn parserStats.getMajorVersion();\n+\t}\n+\n+\t@Override\n+\tpublic short getMinorVersion() {\n+\t\treturn parserStats.getMinorVersion();\n+\t}\n+\n+\t@Override\n+\tpublic int getChunkCount() {\n+\t\treturn parserStats.getChunkCount();\n+\t}\n+\n+\t@Override\n+\tpublic long getSkippedEventCount() {\n+\t\treturn parserStats.getSkippedEventCount();\n+\t}\n+\n+\t@Override\n+\tpublic long getEventCountByType(String eventTypeName) {\n+\t\treturn parserStats.getCount(eventTypeName);\n+\t}\n+\n+\t@Override\n+\tpublic long getEventTotalSizeByType(String eventTypeName) {\n+\t\treturn parserStats.getTotalSize(eventTypeName);\n+\t}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/EventCollection.java","additions":44,"deletions":4,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder;\n+\n+import java.util.function.Consumer;\n+\n+public interface IParserStats {\n+\n+\tpublic interface IEventStats {\n+\t\tString getName();\n+\n+\t\tlong getCount();\n+\n+\t\tlong getTotalSize();\n+\t}\n+\n+\tvoid forEachEventType(Consumer<IEventStats> consumer);\n+\n+\tshort getMajorVersion();\n+\n+\tshort getMinorVersion();\n+\n+\tint getChunkCount();\n+\n+\tlong getSkippedEventCount();\n+\n+\tlong getEventCountByType(String eventTypeName);\n+\n+\tlong getEventTotalSizeByType(String eventTypeName);\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/IParserStats.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,2 @@\n+import java.util.Set;\n+import java.util.TreeSet;\n@@ -62,0 +64,1 @@\n+import org.openjdk.jmc.flightrecorder.IParserStats.IEventStats;\n@@ -91,0 +94,5 @@\n+\n+\t\/**\n+\t * Write only a summary of the recording\n+\t *\/\n+\tSUMMARY,\n@@ -144,0 +152,4 @@\n+\t\tif (verbosity == Verbosity.SUMMARY) {\n+\t\t\tprintSummary((IParserStats) events);\n+\t\t\treturn;\n+\t\t}\n@@ -156,0 +168,33 @@\n+\tprivate void printSummary(IParserStats parserStats) {\n+\t\tout.printf(\"Version: %d.%d\\n\", parserStats.getMajorVersion(), parserStats.getMinorVersion());\n+\t\tout.printf(\"Chunks: %d\\n\", parserStats.getChunkCount());\n+\t\t\/\/ Order descending by event count\n+\t\tSet<IEventStats> eventStatsSet = new TreeSet<>((o1, o2) -> Long.compare(o2.getCount(), o1.getCount()));\n+\t\tparserStats.forEachEventType((eventStats) -> {\n+\t\t\teventStatsSet.add(eventStats);\n+\t\t});\n+\t\tint minWidth = 0;\n+\t\tfor (IEventStats eventStats : eventStatsSet) {\n+\t\t\tminWidth = Math.max(minWidth, eventStats.getName().length());\n+\t\t}\n+\t\tout.println();\n+\t\tString header = \"      Count  Size (bytes) \";\n+\t\tString typeHeader = \" Event Type\";\n+\t\tminWidth = Math.max(minWidth, typeHeader.length());\n+\t\tout.println(typeHeader + pad(minWidth - typeHeader.length(), ' ') + header);\n+\t\tout.println(pad(minWidth + header.length(), '='));\n+\t\tfor (IEventStats eventStats : eventStatsSet) {\n+\t\t\tout.printf(\" %-\" + minWidth + \"s%10d  %12d\\n\", eventStats.getName(), eventStats.getCount(),\n+\t\t\t\t\teventStats.getTotalSize());\n+\t\t}\n+\t\tout.flush();\n+\t}\n+\n+\tprivate String pad(int count, char c) {\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\tfor (int i = 0; i < count; i++) {\n+\t\t\tsb.append(c);\n+\t\t}\n+\t\treturn sb.toString();\n+\t}\n+\n@@ -167,0 +212,2 @@\n+\t\t\t} else if (args[n].equals(\"-summary\")) {\n+\t\t\t\tverbosity = Verbosity.SUMMARY;\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/RecordingPrinter.java","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n@@ -7,0 +39,1 @@\n+import org.openjdk.jmc.flightrecorder.internal.parser.ParserStats;\n@@ -12,0 +45,1 @@\n+\tprivate final ParserStats parserStats;\n@@ -13,1 +47,1 @@\n-\tpublic EventArrays(EventArray[] arrays, Set<IRange<IQuantity>> ranges) {\n+\tpublic EventArrays(EventArray[] arrays, Set<IRange<IQuantity>> ranges, ParserStats parserStats) {\n@@ -16,0 +50,1 @@\n+\t\tthis.parserStats = parserStats;\n@@ -26,0 +61,4 @@\n+\tpublic ParserStats getParserStats() {\n+\t\treturn parserStats;\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/EventArrays.java","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -297,0 +297,1 @@\n+\t\t\t\tcontext.setVersion(chunk.getMajorVersion(), chunk.getMinorVersion());\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/FlightRecordingLoader.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import java.util.Map;\n@@ -67,0 +68,1 @@\n+\tprivate final ParserStats parserStats = new ParserStats();\n@@ -137,1 +139,1 @@\n-\t\treturn new EventArrays(eventArrays.toArray(new EventArray[eventArrays.size()]), chunkRanges);\n+\t\treturn new EventArrays(eventArrays.toArray(new EventArray[eventArrays.size()]), chunkRanges, parserStats);\n@@ -140,0 +142,19 @@\n+\tpublic void incChunkCount() {\n+\t\tparserStats.incChunkCount();\n+\t}\n+\n+\tpublic void updateEventStats(String eventTypeName, long size) {\n+\t\tparserStats.updateEventStats(eventTypeName, size);\n+\t}\n+\n+\tpublic ParserStats getParserStats() {\n+\t\treturn parserStats;\n+\t}\n+\n+\tpublic void setVersion(short majorVersion, short minorVersion) {\n+\t\tparserStats.setVersion(majorVersion, minorVersion);\n+\t}\n+\n+\tpublic void setSkippedEventCount(long skippedEventCount) {\n+\t\tparserStats.setSkippedEventCount(skippedEventCount);\n+\t}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/parser\/LoaderContext.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.internal.parser;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import javax.swing.text.html.MinimalHTMLWriter;\n+\n+import org.openjdk.jmc.flightrecorder.IParserStats.IEventStats;\n+\n+public class ParserStats {\n+\tprivate short majorVersion;\n+\tprivate short minorVersion;\n+\tprivate final AtomicInteger chunkCount = new AtomicInteger();\n+\tprivate final AtomicLong skippedEventCount = new AtomicLong();\n+\tprivate final ConcurrentHashMap<String, EventTypeStats> statsByType = new ConcurrentHashMap<>();\n+\n+\tpublic void setVersion(short majorVersion, short minorVersion) {\n+\t\tthis.majorVersion = majorVersion;\n+\t\tthis.minorVersion = minorVersion;\n+\t}\n+\n+\tpublic void incChunkCount() {\n+\t\tchunkCount.incrementAndGet();\n+\t}\n+\n+\tpublic void setSkippedEventCount(long skippedEventCount) {\n+\t\tthis.skippedEventCount.addAndGet(skippedEventCount);\n+\t}\n+\n+\tpublic void updateEventStats(String eventTypeName, long size) {\n+\t\tstatsByType.compute(eventTypeName, (key, stats) -> {\n+\t\t\tif (stats == null) {\n+\t\t\t\treturn new EventTypeStats(eventTypeName, size);\n+\t\t\t}\n+\t\t\tstats.add(size);\n+\t\t\treturn stats;\n+\t\t});\n+\t}\n+\n+\tpublic void forEachEventType(Consumer<IEventStats> consumer) {\n+\t\tfor (EventTypeStats eventStats : statsByType.values()) {\n+\t\t\tconsumer.accept(eventStats);\n+\t\t}\n+\t}\n+\n+\tpublic short getMajorVersion() {\n+\t\treturn majorVersion;\n+\t}\n+\n+\tpublic short getMinorVersion() {\n+\t\treturn minorVersion;\n+\t}\n+\n+\tpublic int getChunkCount() {\n+\t\treturn chunkCount.get();\n+\t}\n+\n+\tpublic long getSkippedEventCount() {\n+\t\treturn skippedEventCount.get();\n+\t}\n+\n+\tpublic long getCount(String eventTypeName) {\n+\t\tEventTypeStats stats = statsByType.get(eventTypeName);\n+\t\tif (stats == null) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\treturn stats.count;\n+\t}\n+\n+\tpublic long getTotalSize(String eventTypeName) {\n+\t\tEventTypeStats stats = statsByType.get(eventTypeName);\n+\t\tif (stats == null) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\treturn stats.totalSize;\n+\t}\n+\n+\tprivate static class EventTypeStats implements IEventStats {\n+\t\tprivate final String eventTypeName;\n+\t\tprivate long count;\n+\t\tprivate long totalSize;\n+\n+\t\tpublic EventTypeStats(String eventTypeName, long size) {\n+\t\t\tthis.eventTypeName = eventTypeName;\n+\t\t\tthis.count = 1;\n+\t\t\tthis.totalSize = size;\n+\t\t}\n+\n+\t\tpublic void add(long size) {\n+\t\t\tcount++;\n+\t\t\ttotalSize += size;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn eventTypeName;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic long getCount() {\n+\t\t\treturn count;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic long getTotalSize() {\n+\t\t\treturn totalSize;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"EventTypeStats [eventTypeName=\" + eventTypeName + \", count=\" + count + \", totalSize=\" + totalSize\n+\t\t\t\t\t+ \"]\";\n+\t\t}\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/parser\/ParserStats.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,1 @@\n+\t\tcontext.incChunkCount();\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/parser\/v0\/ChunkLoaderV0.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;\n@@ -55,0 +56,1 @@\n+import org.openjdk.jmc.flightrecorder.parser.synthetic.JdkTypeIDsPreJdk11;\n@@ -98,0 +100,1 @@\n+\t\t\t\tString typeId = JdkTypeIDsPreJdk11.translate(id);\n@@ -99,1 +102,1 @@\n-\t\t\t\t\t\tnew EventTypeEntry(sink, etd.hasStartTime(), eventSpec.getValueReaders()));\n+\t\t\t\t\t\tnew EventTypeEntry(typeId, sink, etd.hasStartTime(), eventSpec.getValueReaders()));\n@@ -110,0 +113,1 @@\n+\t\tlong size = offset.getEnd() - offset.get();\n@@ -120,0 +124,1 @@\n+\t\tcontext.updateEventStats(ep.typeId, size);\n@@ -130,1 +135,1 @@\n-\t\treturn new EventTypeEntry(sink, false, eventReader.getValueReaders());\n+\t\treturn new EventTypeEntry(JfrInternalConstants.BUFFER_LOST_TYPE_ID, sink, false, eventReader.getValueReaders());\n@@ -201,1 +206,1 @@\n-\n+\t\tprivate final String typeId;\n@@ -207,1 +212,2 @@\n-\t\tpublic EventTypeEntry(IEventSink sink, boolean hasStartTime, IValueReader[] valueParsers) {\n+\t\tpublic EventTypeEntry(String typeId, IEventSink sink, boolean hasStartTime, IValueReader[] valueParsers) {\n+\t\t\tthis.typeId = typeId;\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/parser\/v0\/EventParserManager.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-\n+\t\tcontext.incChunkCount();\n@@ -92,1 +92,1 @@\n-\t\t\t\tmanager.readEvent(type, input);\n+\t\t\t\tmanager.readEvent(type, input, size);\n@@ -96,0 +96,1 @@\n+\t\tcontext.setSkippedEventCount(manager.getSkippedEventCount());\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/parser\/v1\/ChunkLoaderV1.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -305,0 +305,1 @@\n+\t\tprivate LoaderContext context;\n@@ -327,0 +328,1 @@\n+\t\t\tthis.context = context;\n@@ -370,0 +372,4 @@\n+\n+\t\tvoid updateEventStats(long size) {\n+\t\t\tcontext.updateEventStats(element.typeIdentifier, size);\n+\t\t}\n@@ -377,0 +383,1 @@\n+\tprivate long skippedEventCount;\n@@ -400,1 +407,1 @@\n-\tvoid readEvent(long typeId, IDataInput input) throws InvalidJfrFileException, IOException {\n+\tvoid readEvent(long typeId, IDataInput input, long size) throws InvalidJfrFileException, IOException {\n@@ -406,0 +413,1 @@\n+\t\t\tskippedEventCount++;\n@@ -408,0 +416,1 @@\n+\t\t\tentry.updateEventStats(size);\n@@ -424,0 +433,4 @@\n+\tlong getSkippedEventCount() {\n+\t\treturn skippedEventCount;\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/parser\/v1\/TypeManager.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-final class JdkTypeIDsPreJdk11 {\n+public final class JdkTypeIDsPreJdk11 {\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/parser\/synthetic\/JdkTypeIDsPreJdk11.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.io.File;\n@@ -37,0 +38,2 @@\n+import java.util.Set;\n+import java.util.TreeSet;\n@@ -40,0 +43,1 @@\n+import org.junit.runners.parameterized.TestWithParameters;\n@@ -43,0 +47,3 @@\n+import org.openjdk.jmc.flightrecorder.IParserStats;\n+import org.openjdk.jmc.flightrecorder.JfrLoaderToolkit;\n+import org.openjdk.jmc.flightrecorder.IParserStats.IEventStats;\n@@ -75,0 +82,26 @@\n+\n+\t@Test\n+\tpublic void testParserStats() throws IOException, CouldNotLoadRecordingException {\n+\t\tfor (IOResourceSet resourceSet : PrintoutsToolkit.getTestResources()) {\n+\t\t\tIItemCollection items = RecordingToolkit.getFlightRecording(resourceSet);\n+\t\t\tIParserStats parserStats = (IParserStats) items;\n+\t\t\tSet<IEventStats> eventStatsSet = new TreeSet<>((o1, o2) -> Long.compare(o1.getCount(), o2.getCount()));\n+\t\t\tparserStats.forEachEventType((eventStats) -> {\n+\t\t\t\teventStatsSet.add(eventStats);\n+\t\t\t});\n+\t\t\tList<String> statsLine = null;\n+\t\t\ttry {\n+\t\t\t\tstatsLine = RecordingToolkit.getStats(resourceSet);\n+\t\t\t} catch (IOException ex) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tint i = 0;\n+\t\t\tfor (IEventStats eventStats : eventStatsSet) {\n+\t\t\t\tString[] cols = statsLine.get(i).split(\";\");\n+\t\t\t\tAssert.assertEquals(cols[0], eventStats.getName());\n+\t\t\t\tAssert.assertEquals(Long.parseLong(cols[1]), eventStats.getCount());\n+\t\t\t\tAssert.assertEquals(Long.parseLong(cols[2]), eventStats.getTotalSize());\n+\t\t\t\ti++;\n+\t\t\t}\n+\t\t}\n+\t}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/RecordingTest.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.io.BufferedReader;\n@@ -39,0 +40,1 @@\n+import java.io.InputStreamReader;\n@@ -40,0 +42,2 @@\n+import java.util.List;\n+import java.util.stream.Collectors;\n@@ -100,0 +104,10 @@\n+\tpublic static List<String> getStats(IOResourceSet resourceSet) throws IOException {\n+\t\tIOResource resource = resourceSet.getResource(0);\n+\t\tString recordingFileName = resource.getName();\n+\t\tString statsFileName = recordingFileName.replace(\".jfr\", \".txt\");\n+\t\tIOResource statsResource = TestToolkit.getNamedResource(RecordingToolkit.class, \"stats\", statsFileName);\n+\t\ttry (BufferedReader reader = new BufferedReader(new InputStreamReader(statsResource.open()))) {\n+\t\t\treturn reader.lines().collect(Collectors.toList());\n+\t\t}\n+\t}\n+\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/util\/RecordingToolkit.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,8 @@\n+jdk.CPUInformation;1;1678\n+jdk.PhysicalMemory;2;48\n+jdk.ObjectAllocationInNewTLAB;3;132\n+jdk.CPULoad;8;160\n+jdk.ClassLoadingStatistics;9;216\n+jdk.ThreadAllocationStatistics;44;880\n+jdk.ActiveSetting;77;9304\n+jdk.JavaMonitorWait;108;6156\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/test\/resources\/stats\/7u40.txt","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+jdk.CPUInformation;1;1782\n+jdk.PhysicalMemory;2;48\n+jdk.ObjectAllocationInNewTLAB;4;176\n+jdk.CPULoad;8;160\n+jdk.ClassLoadingStatistics;9;216\n+jdk.ThreadAllocationStatistics;45;900\n+jdk.ActiveSetting;77;9304\n+jdk.JavaMonitorWait;107;6099\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/test\/resources\/stats\/7u60.txt","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+jdk.CPUInformation;1;1782\n+jdk.PhysicalMemory;2;48\n+jdk.ObjectAllocationInNewTLAB;3;132\n+jdk.SocketRead;9;756\n+jdk.ClassLoadingStatistics;10;240\n+jdk.ThreadAllocationStatistics;44;880\n+jdk.ActiveSetting;77;9304\n+jdk.JavaMonitorWait;106;6042\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/test\/resources\/stats\/7u76.txt","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+jdk.CPUInformation;1;1782\n+jdk.PhysicalMemory;2;48\n+jdk.ObjectAllocationInNewTLAB;8;352\n+jdk.ClassLoadingStatistics;9;216\n+jdk.ThreadAllocationStatistics;46;920\n+jdk.ActiveSetting;72;8836\n+jdk.JavaMonitorWait;106;6042\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/test\/resources\/stats\/8u0.txt","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+jdk.CPUInformation;1;1782\n+jdk.PhysicalMemory;2;48\n+jdk.ObjectAllocationInNewTLAB;3;132\n+jdk.ExceptionStatistics;9;180\n+jdk.ClassLoadingStatistics;10;240\n+jdk.SocketRead;19;1596\n+jdk.ThreadAllocationStatistics;46;920\n+jdk.ActiveSetting;85;10428\n+jdk.JavaMonitorWait;108;6156\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/test\/resources\/stats\/8u20.txt","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,12 @@\n+jdk.CPUInformation;1;1782\n+jdk.ExecuteVMOperation;2;56\n+jdk.ExecutionSampling;6;144\n+jdk.SocketRead;9;756\n+jdk.CPULoad;10;200\n+jdk.ObjectAllocationOutsideTLAB;18;648\n+jdk.ExecutionSample;19;418\n+jdk.ThreadAllocationStatistics;49;980\n+jdk.ObjectAllocationInNewTLAB;51;2244\n+jdk.ActiveSetting;85;10428\n+jdk.JavaMonitorWait;142;8094\n+jdk.ThreadPark;165;8580\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/test\/resources\/stats\/8u40.txt","additions":12,"deletions":0,"binary":false,"changes":12,"status":"added"},{"patch":"@@ -0,0 +1,9 @@\n+jdk.CPUInformation;1;1782\n+jdk.PhysicalMemory;2;48\n+jdk.ObjectAllocationOutsideTLAB;6;216\n+jdk.ClassLoadingStatistics;8;192\n+jdk.SocketRead;10;840\n+jdk.ObjectAllocationInNewTLAB;24;1056\n+jdk.ThreadAllocationStatistics;48;960\n+jdk.JavaMonitorWait;65;3705\n+jdk.ActiveSetting;86;10588\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/test\/resources\/stats\/8u60.txt","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+com.oracle.jdk.OSInformation;1;139\n+com.oracle.jdk.SocketWrite;2;83\n+com.oracle.jdk.CPULoad;6;150\n+com.oracle.jdk.SocketRead;11;516\n+com.oracle.jdk.JavaMonitorWait;27;1004\n+com.oracle.jdk.ObjectAllocationOutsideTLAB;58;1160\n+com.oracle.jdk.ThreadAllocationStatistics;60;974\n+com.oracle.jdk.ActiveSetting;218;7579\n+com.oracle.jdk.ObjectAllocationInNewTLAB;270;5739\n+com.oracle.jdk.ClassLoaderStatistics;294;8890\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/test\/resources\/stats\/9u0.txt","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"}]}