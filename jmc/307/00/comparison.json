{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,0 +100,1 @@\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit;\n@@ -732,1 +733,17 @@\n-\t\t\treturn sel.stream().map(gc -> gc.gcItem);\n+\t\t\tList<GC> selCopy = new ArrayList<>(sel);\n+\t\t\tcorrelateSystemGCEvents(sel, selCopy);\n+\t\t\treturn selCopy.stream().map(gc -> gc.gcItem);\n+\t\t}\n+\t\t\n+\t\tprivate void correlateSystemGCEvents(List<GC> sourceGCList, List<GC> destinationGCList) {\n+\t\t\tIItemCollection systemGCEvents = getDataSource().getItems().apply(ItemFilters.type(JdkTypeIDs.GC_COLLECTOR_SYSTEM_GC));\n+\t\t\tfor (GC gc : sourceGCList) {\n+\t\t\t\tIItemFilter rangeFilter = RulesToolkit.createRangeFilter(gc.gcItem);\n+\t\t\t\tIItemCollection correlatedItems = systemGCEvents.apply(rangeFilter);\n+\t\t\t\tfor (IItemIterable types : correlatedItems) {\n+\t\t\t\t\tfor (IItem item : types) {\n+\t\t\t\t\t\tdestinationGCList.add(new GC(item, null));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/pages\/GarbageCollectionsPage.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-\t\t\tIQuantity endTime = RulesToolkit.getStartTime(o);\n+\t\t\tIQuantity endTime = RulesToolkit.getEndTime(o);\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/tree\/TimeRangeFilter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -163,0 +163,1 @@\n+\tpublic static final String GC_COLLECTOR_SYSTEM_GC = PREFIX + \"SystemGC\";\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkTypeIDs.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.rules;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.openjdk.jmc.common.IDescribable;\n+import org.openjdk.jmc.common.item.IAccessorKey;\n+import org.openjdk.jmc.common.item.IAttribute;\n+import org.openjdk.jmc.common.item.ICanonicalAccessorFactory;\n+import org.openjdk.jmc.common.item.IItem;\n+import org.openjdk.jmc.common.item.IItemFilter;\n+import org.openjdk.jmc.common.item.IMemberAccessor;\n+import org.openjdk.jmc.common.item.IType;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.UnitLookup;\n+import org.openjdk.jmc.common.util.MemberAccessorToolkit;\n+import org.openjdk.jmc.flightrecorder.JfrAttributes;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit;\n+\n+public class TimeRangeFilterTest {\n+\n+\t@Test\n+\tpublic void intersects() {\n+\t\tlong start1 = System.currentTimeMillis();\n+\t\tlong end1 = start1 + 1000;\n+\t\tMockEventItem item1 = new MockEventItem(UnitLookup.EPOCH_MS.quantity(start1),\n+\t\t\t\tUnitLookup.EPOCH_MS.quantity(end1));\n+\t\tIItemFilter timeRange = RulesToolkit.createRangeFilter(item1);\n+\t\tlong start2 = start1 - 100;\n+\t\tlong end2 = start2 + 1000;\n+\t\tMockEventItem item2 = new MockEventItem(UnitLookup.EPOCH_MS.quantity(start2),\n+\t\t\t\tUnitLookup.EPOCH_MS.quantity(end2));\n+\t\tAssert.assertTrue(timeRange.getPredicate(item2).test(item2));\n+\n+\t\tstart2 = start1 + 100;\n+\t\tend2 = start2 + 1000;\n+\t\titem2 = new MockEventItem(UnitLookup.EPOCH_MS.quantity(start2), UnitLookup.EPOCH_MS.quantity(end2));\n+\t\tAssert.assertTrue(timeRange.getPredicate(item2).test(item2));\n+\t}\n+\n+\tprivate static class MockEventItem implements IItem, IType<IItem> {\n+\t\tprivate IQuantity startTime;\n+\t\tprivate IQuantity endTime;\n+\n+\t\tpublic MockEventItem(IQuantity startTime, IQuantity endTime) {\n+\t\t\tthis.startTime = startTime;\n+\t\t\tthis.endTime = endTime;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic IType<IItem> getType() {\n+\t\t\treturn this;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getName() {\n+\t\t\treturn \"MockEventItem\";\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getDescription() {\n+\t\t\treturn \"MockEventItem\";\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic List<IAttribute<?>> getAttributes() {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Map<IAccessorKey<?>, ? extends IDescribable> getAccessorKeys() {\n+\t\t\treturn Collections.emptyMap();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean hasAttribute(ICanonicalAccessorFactory<?> attribute) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\t@Override\n+\t\tpublic <M> IMemberAccessor<M, IItem> getAccessor(IAccessorKey<M> attribute) {\n+\t\t\tif (attribute.getIdentifier().equals(JfrAttributes.START_TIME.getIdentifier())) {\n+\t\t\t\treturn (IMemberAccessor<M, IItem>) MemberAccessorToolkit\n+\t\t\t\t\t\t.<IItem, IQuantity, IQuantity> constant(startTime);\n+\t\t\t}\n+\t\t\tif (attribute.getIdentifier().equals(JfrAttributes.END_TIME.getIdentifier())) {\n+\t\t\t\treturn (IMemberAccessor<M, IItem>) MemberAccessorToolkit\n+\t\t\t\t\t\t.<IItem, IQuantity, IQuantity> constant(endTime);\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getIdentifier() {\n+\t\t\treturn null;\n+\t\t}\n+\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.test\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/TimeRangeFilterTest.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"}]}