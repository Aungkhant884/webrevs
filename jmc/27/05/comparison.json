{"files":[{"patch":"@@ -241,154 +241,154 @@\n-  \t\t\t<sash weights=\"1,5\" \/>\n-  \t\t\t<threadLane name=\"EJB\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/high\/wls\/EJB\/EJB_Database_Access\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/EJB\/EJB_Home_Remove\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/high\/wls\/EJB\/EJB_Timer_Manager\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/EJB\/EJB_Home_Create\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/high\/wls\/EJB\/EJB_Pool_Manager_Remove\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/high\/wls\/EJB\/EJB_Business_Method_Post_Invoke_Cleanup\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/EJB\/EJB_Pool_Manager_Create\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/high\/wls\/EJB\/EJB_Replicated_Session_Manager\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"EJB Business Method Invoke\" enabled=\"true\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/EJB\/EJB_Business_Method_Invoke\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"JDBC\" enabled=\"true\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/JDBC\/JDBC_Statement_Execute\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Data_Source_Get_Connection\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Driver_Connect\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Statement_Creation\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"JDBC Connection\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Reserve\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Create_Statement\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Commit\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Prepare\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Release\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/JDBC\/JDBC_Connection_Rollback\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-           <threadLane name=\"JDBC Connection Close\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Close\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"Servlet Request Run\" enabled=\"true\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Servlet\/Servlet_Request_Run\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Servlet\/Servlet_Request_Run_Begin\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"Web Application Load\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Servlet\/Web_Application_Load\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"Servlet Execute\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Execute\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-           <threadLane name=\"Servlet Context Execute\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Context_Execute\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"Servlet Invocation\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Servlet\/Servlet_Invocation\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"Servlet Filter\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Check_Access\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Filter\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"Servlet Request\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Request\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Request_Dispatch\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"Servlet Response Write Headers\/Stale Resource\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Response_Write_Headers\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Stale_Resource\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"Servlet Response Send\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Response_Send\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"JAX-RPC\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXRPC\/Webservices_JAXRPC_Client_Response\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXRPC\/Webservices_JAXRPC_Client_Request\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXRPC\/Webservices_JAXRPC_Request\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXRPC\/Webservices_JAXRPC_Response\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"WebServices\" enabled=\"true\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXRPC\/Webservices_JAXRPC_Dispatch\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXWS\/Webservices_JAXWS_Request\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXWS\/Webservices_JAXWS_Endpoint\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"DMS\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/dms-context\/dms\/ExecutionContext\/span\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/dms-anonymous-phase\/dms\/AnonymousPhase\/span\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"DMS execution context start\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/dms-context\/dms\/ExecutionContext\/start\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"DMS HTTP\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/dms-http\/dms\/HttpRequest\/span\"\/>\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/dms-http\/dms\/HttpRequest\/start\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"JavaFX Pulse\" enabled=\"true\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/technetwork\/java\/javafx\/index.html\/javafx\/pulse\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"JavaFX Input\" enabled=\"true\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/technetwork\/java\/javafx\/index.html\/javafx\/input\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"Java Latencies\" enabled=\"true\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"jdk.JavaMonitorEnter\"\/>\n-                    <filter kind=\"TYPE\" type=\"jdk.SocketRead\"\/>\n-                    <filter kind=\"TYPE\" type=\"jdk.Compilation\"\/>\n-                    <filter kind=\"TYPE\" type=\"jdk.ExecutionSampling\"\/>\n-                    <filter kind=\"TYPE\" type=\"jdk.SocketWrite\"\/>\n-                    <filter kind=\"TYPE\" type=\"jdk.ClassLoad\"\/>\n-                    <filter kind=\"TYPE\" type=\"jdk.ThreadPark\"\/>\n-                    <filter kind=\"TYPE\" type=\"jdk.FileWrite\"\/>\n-                    <filter kind=\"TYPE\" type=\"jdk.ThreadSleep\"\/>\n-                    <filter kind=\"TYPE\" type=\"jdk.JavaMonitorWait\"\/>\n-                    <filter kind=\"TYPE\" type=\"jdk.FileRead\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-            <threadLane name=\"JVM Compiler\">\n-                <filter kind=\"OR\">\n-                    <filter kind=\"TYPE\" type=\"jdk.SweepCodeCache\"\/>\n-                    <filter kind=\"TYPE\" type=\"jdk.CompilerPhase\"\/>\n-                <\/filter>\n-            <\/threadLane>\n-          <threadLane name=\"Other Types\" enabled=\"false\" editable=\"false\" isRestLane=\"true\"\/>\n+\t  \t\t\t<sash weights=\"1,5\" \/>\n+\t  \t\t\t<threadLane name=\"EJB\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/high\/wls\/EJB\/EJB_Database_Access\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/EJB\/EJB_Home_Remove\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/high\/wls\/EJB\/EJB_Timer_Manager\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/EJB\/EJB_Home_Create\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/high\/wls\/EJB\/EJB_Pool_Manager_Remove\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/high\/wls\/EJB\/EJB_Business_Method_Post_Invoke_Cleanup\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/EJB\/EJB_Pool_Manager_Create\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/high\/wls\/EJB\/EJB_Replicated_Session_Manager\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"EJB Business Method Invoke\" enabled=\"true\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/EJB\/EJB_Business_Method_Invoke\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"JDBC\" enabled=\"true\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/JDBC\/JDBC_Statement_Execute\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Data_Source_Get_Connection\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Driver_Connect\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Statement_Creation\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"JDBC Connection\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Reserve\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Create_Statement\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Commit\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Prepare\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Release\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/JDBC\/JDBC_Connection_Rollback\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t           <threadLane name=\"JDBC Connection Close\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Close\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"Servlet Request Run\" enabled=\"true\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Servlet\/Servlet_Request_Run\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Servlet\/Servlet_Request_Run_Begin\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"Web Application Load\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Servlet\/Web_Application_Load\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"Servlet Execute\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Execute\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t           <threadLane name=\"Servlet Context Execute\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Context_Execute\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"Servlet Invocation\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Servlet\/Servlet_Invocation\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"Servlet Filter\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Check_Access\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Filter\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"Servlet Request\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Request\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Request_Dispatch\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"Servlet Response Write Headers\/Stale Resource\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Response_Write_Headers\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Stale_Resource\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"Servlet Response Send\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Response_Send\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"JAX-RPC\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXRPC\/Webservices_JAXRPC_Client_Response\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXRPC\/Webservices_JAXRPC_Client_Request\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXRPC\/Webservices_JAXRPC_Request\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXRPC\/Webservices_JAXRPC_Response\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"WebServices\" enabled=\"true\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXRPC\/Webservices_JAXRPC_Dispatch\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXWS\/Webservices_JAXWS_Request\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXWS\/Webservices_JAXWS_Endpoint\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"DMS\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/dms-context\/dms\/ExecutionContext\/span\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/dms-anonymous-phase\/dms\/AnonymousPhase\/span\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"DMS execution context start\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/dms-context\/dms\/ExecutionContext\/start\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"DMS HTTP\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/dms-http\/dms\/HttpRequest\/span\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/dms-http\/dms\/HttpRequest\/start\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"JavaFX Pulse\" enabled=\"true\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/technetwork\/java\/javafx\/index.html\/javafx\/pulse\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"JavaFX Input\" enabled=\"true\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/technetwork\/java\/javafx\/index.html\/javafx\/input\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"Java Latencies\" enabled=\"true\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"jdk.JavaMonitorEnter\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"jdk.SocketRead\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"jdk.Compilation\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"jdk.ExecutionSampling\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"jdk.SocketWrite\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"jdk.ClassLoad\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"jdk.ThreadPark\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"jdk.FileWrite\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"jdk.ThreadSleep\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"jdk.JavaMonitorWait\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"jdk.FileRead\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"JVM Compiler\">\n+\t                <filter kind=\"OR\">\n+\t                    <filter kind=\"TYPE\" type=\"jdk.SweepCodeCache\"\/>\n+\t                    <filter kind=\"TYPE\" type=\"jdk.CompilerPhase\"\/>\n+\t                <\/filter>\n+\t            <\/threadLane>\n+\t            <threadLane name=\"Other Types\" enabled=\"false\" editable=\"false\" isRestLane=\"true\"\/>\n@@ -396,0 +396,136 @@\n+\t\t\t<!-- Legacy Threads Page -->\n+\t\t\t<page factory=\"org.openjdk.jmc.flightrecorder.ui.threadslegacy\" id=\"org.openjdk.jmc.flightrecorder.ui.threadslegacy\">\n+\t\t\t    <state>\n+\t\t\t        <sash weights=\"1,5\" \/>\n+\t\t\t        <threadLane name=\"EJB\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/high\/wls\/EJB\/EJB_Database_Access\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/EJB\/EJB_Home_Remove\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/high\/wls\/EJB\/EJB_Timer_Manager\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/EJB\/EJB_Home_Create\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/high\/wls\/EJB\/EJB_Pool_Manager_Remove\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/high\/wls\/EJB\/EJB_Business_Method_Post_Invoke_Cleanup\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/EJB\/EJB_Pool_Manager_Create\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/high\/wls\/EJB\/EJB_Replicated_Session_Manager\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"EJB Business Method Invoke\" enabled=\"true\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/EJB\/EJB_Business_Method_Invoke\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"JDBC\" enabled=\"true\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/JDBC\/JDBC_Statement_Execute\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Data_Source_Get_Connection\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Driver_Connect\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Statement_Creation\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"JDBC Connection\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Reserve\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Create_Statement\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Commit\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Prepare\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Release\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/JDBC\/JDBC_Connection_Rollback\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"JDBC Connection Close\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/JDBC\/JDBC_Connection_Close\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"Servlet Request Run\" enabled=\"true\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Servlet\/Servlet_Request_Run\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Servlet\/Servlet_Request_Run_Begin\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"Web Application Load\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Servlet\/Web_Application_Load\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"Servlet Execute\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Execute\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"Servlet Context Execute\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Context_Execute\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"Servlet Invocation\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Servlet\/Servlet_Invocation\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"Servlet Filter\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Check_Access\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Filter\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"Servlet Request\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Request\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Request_Dispatch\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"Servlet Response Write Headers\/Stale Resource\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Response_Write_Headers\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Stale_Resource\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"Servlet Response Send\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/medium\/wls\/Servlet\/Servlet_Response_Send\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"JAX-RPC\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXRPC\/Webservices_JAXRPC_Client_Response\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXRPC\/Webservices_JAXRPC_Client_Request\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXRPC\/Webservices_JAXRPC_Request\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXRPC\/Webservices_JAXRPC_Response\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"WebServices\" enabled=\"true\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXRPC\/Webservices_JAXRPC_Dispatch\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXWS\/Webservices_JAXWS_Request\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/wls\/flightrecorder\/low\/wls\/Webservices\/JAXWS\/Webservices_JAXWS_Endpoint\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"DMS\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/dms-context\/dms\/ExecutionContext\/span\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/dms-anonymous-phase\/dms\/AnonymousPhase\/span\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"DMS execution context start\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/dms-context\/dms\/ExecutionContext\/start\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"DMS HTTP\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/dms-http\/dms\/HttpRequest\/span\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/dms-http\/dms\/HttpRequest\/start\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"JavaFX Pulse\" enabled=\"true\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/technetwork\/java\/javafx\/index.html\/javafx\/pulse\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"JavaFX Input\" enabled=\"true\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"http:\/\/www.oracle.com\/technetwork\/java\/javafx\/index.html\/javafx\/input\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"Java Latencies\" enabled=\"true\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"jdk.JavaMonitorEnter\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"jdk.SocketRead\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"jdk.Compilation\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"jdk.ExecutionSampling\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"jdk.SocketWrite\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"jdk.ClassLoad\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"jdk.ThreadPark\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"jdk.FileWrite\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"jdk.ThreadSleep\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"jdk.JavaMonitorWait\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"jdk.FileRead\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"JVM Compiler\">\n+\t\t\t            <filter kind=\"OR\">\n+\t\t\t                <filter kind=\"TYPE\" type=\"jdk.SweepCodeCache\"\/>\n+\t\t\t                <filter kind=\"TYPE\" type=\"jdk.CompilerPhase\"\/><\/filter>\n+\t\t\t        <\/threadLane>\n+\t\t\t        <threadLane name=\"Other Types\" enabled=\"false\" editable=\"false\" isRestLane=\"true\"\/>\n+\t\t\t    <\/state>\n+\t\t\t<\/page>\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/defaultPages.xml","additions":290,"deletions":154,"binary":false,"changes":444,"status":"modified"},{"patch":"@@ -221,0 +221,4 @@\n+      <factory\n+      \t\tclass=\"org.openjdk.jmc.flightrecorder.ui.pages.ThreadsPageLegacy$ThreadsPageLegacyFactory\"\n+      \t\tid=\"org.openjdk.jmc.flightrecorder.ui.threadslegacy\">\n+      <\/factory>\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/plugin.xml","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,0 +158,1 @@\n+import org.openjdk.jmc.ui.misc.ChartTextCanvas;\n@@ -315,0 +316,4 @@\n+\tpublic static void setChart(ChartTextCanvas canvas, XYChart chart, Consumer<IItemCollection> selectionListener) {\n+\t\tsetChart(canvas, chart, selectionListener, null);\n+\t}\n+\n@@ -334,0 +339,31 @@\n+\t\tcanvas.setSelectionListener(() -> {\n+\t\t\tselectionListener.accept(ItemRow.getRangeSelection(chart, JfrAttributes.LIFETIME));\n+\t\t\tIQuantity start = chart.getSelectionStart();\n+\t\t\tIQuantity end = chart.getSelectionEnd();\n+\t\t\tif (selectRangeConsumer != null) {\n+\t\t\t\tselectRangeConsumer\n+\t\t\t\t\t\t.accept(start != null && end != null ? QuantityRange.createWithEnd(start, end) : null);\n+\t\t\t}\n+\t\t});\n+\t\tcanvas.setChart(chart);\n+\t}\n+\n+\tpublic static void setChart(\n+\t\tChartTextCanvas canvas, XYChart chart, Consumer<IItemCollection> selectionListener,\n+\t\tConsumer<IRange<IQuantity>> selectRangeConsumer) {\n+\t\tIMenuManager contextMenu = canvas.getContextMenu();\n+\t\tcontextMenu.removeAll();\n+\t\tcanvas.getContextMenu().add(new Action(Messages.CHART_ZOOM_TO_SELECTED_RANGE) {\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\tIQuantity selectionStart = chart.getSelectionStart();\n+\t\t\t\tIQuantity selectionEnd = chart.getSelectionEnd();\n+\t\t\t\tif (selectionStart == null || selectionEnd == null) {\n+\t\t\t\t\tchart.clearVisibleRange();\n+\t\t\t\t} else {\n+\t\t\t\t\tchart.setVisibleRange(selectionStart, selectionEnd);\n+\t\t\t\t}\n+\t\t\t\tcanvas.redrawChartText();\n+\t\t\t}\n+\t\t});\n+\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/common\/DataPageToolkit.java","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.ui.common;\n+\n+import org.eclipse.swt.SWT;\n+import org.eclipse.swt.events.ShellAdapter;\n+import org.eclipse.swt.events.ShellEvent;\n+import org.eclipse.swt.graphics.Point;\n+import org.eclipse.swt.graphics.Rectangle;\n+import org.eclipse.swt.layout.GridData;\n+import org.eclipse.swt.layout.GridLayout;\n+import org.eclipse.swt.widgets.Button;\n+import org.eclipse.swt.widgets.Composite;\n+import org.eclipse.swt.widgets.Display;\n+import org.eclipse.swt.widgets.Event;\n+import org.eclipse.swt.widgets.Listener;\n+import org.eclipse.swt.widgets.Shell;\n+\n+import org.openjdk.jmc.flightrecorder.ui.common.LaneEditor.EditLanesContainer;\n+import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;\n+import org.openjdk.jmc.ui.common.util.Environment;\n+import org.openjdk.jmc.ui.common.util.Environment.OSType;\n+import org.openjdk.jmc.ui.handlers.MCContextMenuManager;\n+\n+public class DropdownLaneFilter extends Composite {\n+\tprivate static final int EXTRA_SHELL_WIDTH = 300;\n+\tprivate static final int SHELL_HEIGHT = 500;\n+\tprivate Button dropdownButton;\n+\tprivate GridLayout layout;\n+\tprivate MCContextMenuManager[] mms;\n+\tprivate Shell shell;\n+\tprivate ThreadGraphLanes lanes;\n+\tprivate EditLanesContainer container;\n+\n+\tpublic DropdownLaneFilter(Composite parent, ThreadGraphLanes lanes, MCContextMenuManager[] mms) {\n+\t\tsuper(parent, SWT.NONE);\n+\t\tthis.lanes = lanes;\n+\t\tthis.mms = mms;\n+\t\tthis.layout = new GridLayout();\n+\t\tlayout.marginHeight = 0;\n+\t\tlayout.marginWidth = 0;\n+\t\tsetLayout(layout);\n+\t\tdropdownButton = new Button(this, SWT.TOGGLE);\n+\t\tdropdownButton.setLayoutData(new GridData(GridData.FILL_BOTH));\n+\t\tdropdownButton.setText(Messages.DropdownLaneFilter_THREAD_STATE_SELECTION);\n+\t\tdropdownButton.addListener(SWT.MouseUp, new Listener() {\n+\t\t\t@Override\n+\t\t\tpublic void handleEvent(Event e) {\n+\t\t\t\t\/*\n+\t\t\t\t * Windows: works IF the menu item that is toggled is also highlight. e.g, if the\n+\t\t\t\t * user wanted to toggle the Java Compiler lanes, then it's not enough to just click\n+\t\t\t\t * the checkbox - the Java Compiler menu item must be highlighted at the time of\n+\t\t\t\t * toggling\n+\t\t\t\t *\n+\t\t\t\t * MacOS: There are currently issues with paint timings with Mac OS at the moment\n+\t\t\t\t * where toggling an activity lane from the dropdown does not redraw the chart. This\n+\t\t\t\t * may be related to the Windows issue, and may be a SWT limitation.\n+\t\t\t\t *\/\n+\t\t\t\tif (Environment.getOSType() != OSType.LINUX) {\n+\t\t\t\t\tlanes.openEditLanesDialog(mms, false);\n+\t\t\t\t\tdropdownButton.setSelection(false);\n+\t\t\t\t} else {\n+\t\t\t\t\tif (dropdownButton.getSelection()) {\n+\t\t\t\t\t\tdisplayDropdown();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t\/**\n+\t * Creates a new shell which is positioned below the dropdown button. This new shell creates the\n+\t * appearance of a dropdown component, and it's contents will be the TypeFilterBuilder as found\n+\t * in the Edit Thread Lanes dialog.\n+\t *\/\n+\tprivate void displayDropdown() {\n+\t\tPoint p = dropdownButton.getParent().toDisplay(dropdownButton.getLocation());\n+\t\tPoint size = dropdownButton.getSize();\n+\t\tRectangle shellRect = new Rectangle(p.x, p.y + size.y, size.x, 0);\n+\n+\t\tshell = new Shell(DropdownLaneFilter.this.getShell(), SWT.BORDER);\n+\t\tshell.addShellListener(new ShellAdapter() {\n+\n+\t\t\tpublic void shellDeactivated(ShellEvent e) {\n+\t\t\t\tif (!isCursorOnTopOfButton()) {\n+\t\t\t\t\t\/\/ If the shell is closed without clicking the button (i.e., not forcing\n+\t\t\t\t\t\/\/ a toggle), then the button must be toggled programmatically.\n+\t\t\t\t\tdropdownButton.setSelection(false);\n+\t\t\t\t}\n+\t\t\t\tdisposeDropdown();\n+\t\t\t}\n+\t\t});\n+\n+\t\tshell.setLayout(this.layout);\n+\t\tshell.setSize(shellRect.width + EXTRA_SHELL_WIDTH, SHELL_HEIGHT);\n+\t\tshell.setLocation(shellRect.x, shellRect.y);\n+\n+\t\tcontainer = new EditLanesContainer(shell, lanes.getTypeTree(), lanes.getLaneDefinitions(), () -> updateChart());\n+\t\tcontainer.setLayoutData(new GridData(GridData.FILL_BOTH));\n+\t\tshell.open();\n+\t}\n+\n+\tprivate void disposeDropdown() {\n+\t\tif (shell != null && !shell.isDisposed()) {\n+\t\t\tshell.close();\n+\t\t}\n+\t}\n+\n+\t\/**\n+\t * Determine whether or not the mouse cursor is overlapping the dropdown button. An open\n+\t * dropdown shell should close when the user clicks the button. In Linux, the MouseListener on\n+\t * the button will fire. In Windows, the shell has priority and the MouseListener doesn't get\n+\t * activated. This function is to be used in the ShellAdapter to determine if the user closed\n+\t * the shell by trying to click the button, or by clicking away from the dropdown shell.\n+\t *\n+\t * @return true if the mouse cursor is on top of the button\n+\t *\/\n+\tprivate boolean isCursorOnTopOfButton() {\n+\t\tPoint cursor = Display.getCurrent().getCursorLocation();\n+\t\tPoint buttonLoc = dropdownButton.toDisplay(1, 1);\n+\t\tRectangle buttonRect = new Rectangle(buttonLoc.x, buttonLoc.y, dropdownButton.getSize().x,\n+\t\t\t\tdropdownButton.getSize().y);\n+\t\treturn buttonRect.contains(cursor);\n+\t}\n+\n+\tprivate void updateChart() {\n+\t\tlanes.buildChart();\n+\t\tlanes.updateContextMenus(mms, false);\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/common\/DropdownLaneFilter.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+import org.eclipse.swt.widgets.Event;\n@@ -69,0 +70,1 @@\n+import org.eclipse.swt.widgets.Listener;\n@@ -304,1 +306,0 @@\n-\n@@ -370,4 +371,3 @@\n-\t\tboolean enabled = true;\n-\t\tpageContainer.getSelectionStore().setCurrentActive(enabled);\n-\t\tselectionCombo.getCombo().setEnabled(enabled);\n-\t\tflavorCombo.getCombo().setEnabled(enabled);\n+\t\tpageContainer.getSelectionStore().setCurrentActive(true);\n+\t\tselectionCombo.getCombo().setEnabled(true);\n+\t\tflavorCombo.getCombo().setEnabled(true);\n@@ -387,1 +387,0 @@\n-\t\tIItemStreamFlavor flavor = null;\n@@ -392,1 +391,1 @@\n-\t\t\t\tflavor = (IItemStreamFlavor) obj;\n+\t\t\t\treturn (IItemStreamFlavor) obj;\n@@ -395,1 +394,1 @@\n-\t\treturn flavor;\n+\t\treturn null;\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/common\/FlavorSelector.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -105,1 +105,4 @@\n-\tprivate static class EditLanesWizardPage extends WizardPage implements IPerformFinishable {\n+\tstatic class EditLanesContainer extends Composite {\n+\n+\t\tfinal EventTypeFolderNode root;\n+\t\tfinal List<LaneDefinition> lanes;\n@@ -107,2 +110,0 @@\n-\t\tprivate final EventTypeFolderNode root;\n-\t\tprivate final List<LaneDefinition> lanes;\n@@ -113,0 +114,2 @@\n+\t\tprivate Runnable updateChart;\n+\t\tprivate boolean isDropdownFilter;\n@@ -114,2 +117,6 @@\n-\t\tprivate EditLanesWizardPage(EventTypeFolderNode root, Collection<LaneDefinition> lanesInput) {\n-\t\t\tsuper(\"EditFilterLanesPage\"); \/\/$NON-NLS-1$\n+\t\tEditLanesContainer(Composite parent, EventTypeFolderNode root, List<LaneDefinition> lanes) {\n+\t\t\tthis(parent, root, lanes, null);\n+\t\t}\n+\n+\t\tEditLanesContainer(Composite parent, EventTypeFolderNode root, List<LaneDefinition> lanes, Runnable action) {\n+\t\t\tsuper(parent, SWT.NONE);\n@@ -117,1 +124,2 @@\n-\t\t\tthis.lanes = new ArrayList<>(lanesInput);\n+\t\t\tthis.lanes = lanes;\n+\t\t\tthis.updateChart = action;\n@@ -119,0 +127,1 @@\n+\t\t\tinit();\n@@ -121,2 +130,5 @@\n-\t\t@Override\n-\t\tpublic void createControl(Composite parent) {\n+\t\tpublic List<LaneDefinition> getLanes() {\n+\t\t\treturn lanes;\n+\t\t}\n+\n+\t\tprivate void init() {\n@@ -124,2 +136,1 @@\n-\t\t\tComposite container = new Composite(parent, SWT.NONE);\n-\t\t\tcontainer.setLayout(GridLayoutFactory.swtDefaults().numColumns(2).create());\n+\t\t\tthis.setLayout(GridLayoutFactory.swtDefaults().numColumns(2).create());\n@@ -127,1 +138,1 @@\n-\t\t\tComposite laneHeaderContainer = new Composite(container, SWT.NONE);\n+\t\t\tComposite laneHeaderContainer = new Composite(this, SWT.NONE);\n@@ -147,1 +158,1 @@\n-\t\t\tLabel filterTitle = new Label(container, SWT.NONE);\n+\t\t\tLabel filterTitle = new Label(this, SWT.NONE);\n@@ -152,1 +163,1 @@\n-\t\t\tlanesViewer = CheckboxTableViewer.newCheckList(container, SWT.BORDER | SWT.V_SCROLL);\n+\t\t\tlanesViewer = CheckboxTableViewer.newCheckList(this, SWT.BORDER | SWT.V_SCROLL);\n@@ -273,1 +284,1 @@\n-\t\t\tfilterEditor = new TypeFilterBuilder(container, this::onTypeFilterChange);\n+\t\t\tfilterEditor = new TypeFilterBuilder(this, this::onTypeFilterChange);\n@@ -276,0 +287,1 @@\n+\t\t\tisDropdownFilter = updateChart != null ? true : false;\n@@ -282,2 +294,0 @@\n-\n-\t\t\tsetControl(container);\n@@ -306,0 +316,3 @@\n+\t\t\tif (isDropdownFilter) {\n+\t\t\t\tupdateChart();\n+\t\t\t}\n@@ -334,10 +347,32 @@\n-\t\t\tif (this.selected != newSelected) {\n-\t\t\t\tsaveFilter();\n-\t\t\t\tthis.selected = lanes.get(selectedIndex);\n-\t\t\t\tif (selected instanceof LaneDefinition) {\n-\t\t\t\t\tTypes typesFilter;\n-\t\t\t\t\tif (((LaneDefinition) selected).getFilter() instanceof Types) {\n-\t\t\t\t\t\ttypesFilter = ((Types) ((LaneDefinition) selected).getFilter());\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\ttypesFilter = (Types) ItemFilters.convertToTypes(((LaneDefinition) selected).getFilter(),\n-\t\t\t\t\t\t\t\tfilterEditor.getAllTypes());\n+\t\t\tif (selectedIndex == -1 && isDropdownFilter) {\n+\t\t\t\tselectedIndex = findLaneDefinitionIndexByName(selected);\n+\t\t\t}\n+\t\t\tsaveFilter();\n+\t\t\tthis.selected = lanes.get(selectedIndex);\n+\t\t\tif (selected instanceof LaneDefinition) {\n+\t\t\t\tTypes typesFilter;\n+\t\t\t\tif (((LaneDefinition) selected).getFilter() instanceof Types) {\n+\t\t\t\t\ttypesFilter = ((Types) ((LaneDefinition) selected).getFilter());\n+\t\t\t\t} else {\n+\t\t\t\t\ttypesFilter = (Types) ItemFilters.convertToTypes(((LaneDefinition) selected).getFilter(),\n+\t\t\t\t\t\t\tfilterEditor.getAllTypes());\n+\t\t\t\t}\n+\t\t\t\tfilterEditor.selectTypes(typesFilter.getTypes());\n+\t\t\t}\n+\t\t\tif (isDropdownFilter) {\n+\t\t\t\tupdateChart();\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate void updateChart() {\n+\t\t\tsaveFilter(); \/\/ updates the LaneDefinition with the new filter\n+\t\t\tupdateChart.run(); \/\/ repaints the chart and text canvases\n+\t\t}\n+\n+\t\tprivate int findLaneDefinitionIndexByName(Object selected) {\n+\t\t\tint index = -1;\n+\t\t\tif (selected != null) {\n+\t\t\t\tfor (int i = 0; i < lanes.size(); i++) {\n+\t\t\t\t\tif (lanes.get(i).getName().equals(((LaneDefinition) selected).getName())) {\n+\t\t\t\t\t\tindex = i;\n+\t\t\t\t\t\tbreak;\n@@ -345,1 +380,0 @@\n-\t\t\t\t\tfilterEditor.selectTypes(typesFilter.getTypes());\n@@ -348,0 +382,1 @@\n+\t\t\treturn index;\n@@ -352,0 +387,3 @@\n+\t\t\tif (selectedIndex == -1 && isDropdownFilter) {\n+\t\t\t\tselectedIndex = findLaneDefinitionIndexByName(selected);\n+\t\t\t}\n@@ -354,16 +392,14 @@\n-\t\t\t\tif (!ld.isRestLane()) {\n-\t\t\t\t\tIItemFilter newFilter = ItemFilters\n-\t\t\t\t\t\t\t.type(filterEditor.getCheckedTypeIds().collect(Collectors.toSet()));\n-\t\t\t\t\tLaneDefinition newLd = new LaneDefinition(ld.name, lanesViewer.getChecked(ld), newFilter,\n-\t\t\t\t\t\t\tld.isRestLane);\n-\t\t\t\t\tlanes.set(selectedIndex, newLd);\n-\t\t\t\t\tlanesViewer.replace(newLd, selectedIndex);\n-\t\t\t\t\tif (restLane != null) {\n-\t\t\t\t\t\tLaneDefinition newRest = new LaneDefinition(restLane.name, restLane.enabled,\n-\t\t\t\t\t\t\t\tgetRestFilter(lanes), true);\n-\t\t\t\t\t\tint restIndex = lanes.indexOf(restLane);\n-\t\t\t\t\t\tlanes.set(restIndex, newRest);\n-\t\t\t\t\t\tlanesViewer.replace(newRest, restIndex);\n-\t\t\t\t\t\trestLane = newRest;\n-\t\t\t\t\t}\n-\t\t\t\t\tlanesViewer.refresh();\n+\t\t\t\tIItemFilter newFilter = ItemFilters.type(filterEditor.getCheckedTypeIds().collect(Collectors.toSet()));\n+\t\t\t\tLaneDefinition newLd = new LaneDefinition(ld.name, lanesViewer.getChecked(ld), newFilter,\n+\t\t\t\t\t\tld.isRestLane);\n+\t\t\t\tlanes.set(selectedIndex, newLd);\n+\t\t\t\tlanesViewer.replace(newLd, selectedIndex);\n+\t\t\t\tif (ld.isRestLane()) {\n+\t\t\t\t\trestLane = newLd;\n+\t\t\t\t} else {\n+\t\t\t\t\tLaneDefinition newRest = new LaneDefinition(restLane.name, restLane.enabled, getRestFilter(lanes),\n+\t\t\t\t\t\t\ttrue);\n+\t\t\t\t\tint restIndex = findLaneDefinitionIndexByName(restLane);\n+\t\t\t\t\tlanes.set(restIndex, newRest);\n+\t\t\t\t\tlanesViewer.replace(newRest, restIndex);\n+\t\t\t\t\trestLane = newRest;\n@@ -371,0 +407,1 @@\n+\t\t\t\tlanesViewer.refresh();\n@@ -373,0 +410,23 @@\n+\t}\n+\n+\tprivate static class EditLanesWizardPage extends WizardPage implements IPerformFinishable {\n+\n+\t\tprivate EditLanesContainer container;\n+\t\tprotected EventTypeFolderNode root;\n+\t\tprivate List<LaneDefinition> lanes;\n+\n+\t\tprivate EditLanesWizardPage(EventTypeFolderNode root, Collection<LaneDefinition> lanesInput) {\n+\t\t\tsuper(\"EditFilterLanesPage\"); \/\/$NON-NLS-1$\n+\t\t\tthis.root = root;\n+\t\t\tthis.lanes = new ArrayList<>(lanesInput);\n+\t\t}\n+\n+\t\tpublic List<LaneDefinition> getLanes() {\n+\t\t\treturn lanes;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void createControl(Composite parent) {\n+\t\t\tcontainer = new EditLanesContainer(parent, root, lanes);\n+\t\t\tsetControl(container);\n+\t\t}\n@@ -376,1 +436,1 @@\n-\t\t\tsaveFilter();\n+\t\t\tcontainer.saveFilter();\n@@ -379,2 +439,3 @@\n-\t\t\t\tif (ld.isEnabled() != lanesViewer.getChecked(ld)) {\n-\t\t\t\t\tlanes.set(i, new LaneDefinition(ld.name, lanesViewer.getChecked(ld), ld.filter, ld.isRestLane));\n+\t\t\t\tif (ld.isEnabled() != container.lanesViewer.getChecked(ld)) {\n+\t\t\t\t\tlanes.set(i, new LaneDefinition(ld.name, container.lanesViewer.getChecked(ld), ld.filter,\n+\t\t\t\t\t\t\tld.isRestLane));\n@@ -436,0 +497,4 @@\n+\t\tpublic boolean isEnabledAndNotRestLane() {\n+\t\t\treturn enabled && !isRestLane;\n+\t\t}\n+\n@@ -475,1 +540,1 @@\n-\t\t\treturn page.lanes.stream().filter(LaneEditor::laneIncludesTypes).collect(Collectors.toList());\n+\t\t\treturn page.getLanes().stream().filter(LaneEditor::laneIncludesTypes).collect(Collectors.toList());\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/common\/LaneEditor.java","additions":112,"deletions":47,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * \n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *\n@@ -97,0 +97,1 @@\n+\tprivate EventTypeFolderNode typeTree;\n@@ -102,0 +103,6 @@\n+\t\tthis.typeTree = dataSourceSupplier.get().getTypeTree(ItemCollectionToolkit\n+\t\t\t\t.stream(dataSourceSupplier.get().getItems()).filter(this::typeWithThreadAndDuration));\n+\t}\n+\n+\tprotected EventTypeFolderNode getTypeTree() {\n+\t\treturn typeTree;\n@@ -106,1 +113,1 @@\n-\t\tEventTypeFolderNode typeTree = dataSourceSupplier.get().getTypeTree(ItemCollectionToolkit\n+\t\ttypeTree = dataSourceSupplier.get().getTypeTree(ItemCollectionToolkit\n@@ -115,0 +122,11 @@\n+\tpublic void openEditLanesDialog(MCContextMenuManager[] mms, boolean isLegendMenu) {\n+\t\t\/\/ FIXME: Might there be other interesting events that don't really have duration?\n+\t\ttypeTree = dataSourceSupplier.get().getTypeTree(ItemCollectionToolkit\n+\t\t\t\t.stream(dataSourceSupplier.get().getItems()).filter(this::typeWithThreadAndDuration));\n+\t\tlaneDefs = LaneEditor.openDialog(typeTree, laneDefs.stream().collect(Collectors.toList()),\n+\t\t\t\tMessages.JavaApplicationPage_EDIT_THREAD_LANES_DIALOG_TITLE,\n+\t\t\t\tMessages.JavaApplicationPage_EDIT_THREAD_LANES_DIALOG_MESSAGE);\n+\t\tupdateContextMenus(mms, isLegendMenu);\n+\t\tbuildChart.run();\n+\t}\n+\n@@ -142,0 +160,9 @@\n+\tpublic void buildChart() {\n+\t\tbuildChart.run();\n+\t}\n+\n+\tprivate void setLaneDefinitionEnablement(LaneDefinition oldLd, int laneIndex, boolean isEnabled) {\n+\t\tLaneDefinition newLd = new LaneDefinition(oldLd.getName(), isEnabled, oldLd.getFilter(), oldLd.isRestLane());\n+\t\tlaneDefs.set(laneIndex, newLd);\n+\t}\n+\n@@ -246,1 +273,30 @@\n-\tpublic void updateContextMenu(MCContextMenuManager mm, boolean isLegendMenu) {\n+\tpublic void updateContextMenus(MCContextMenuManager[] mms, boolean isLegendMenu) {\n+\t\tif (isLegendMenu) {\n+\t\t\tfor (String id : legendActionIdentifiers) {\n+\t\t\t\tfor (MCContextMenuManager mm : mms) {\n+\t\t\t\t\tmm.remove(id);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tlegendActionIdentifiers.clear();\n+\t\t} else {\n+\t\t\tfor (String id : chartActionIdentifiers) {\n+\t\t\t\tfor (MCContextMenuManager mm : mms) {\n+\t\t\t\t\tmm.remove(id);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tchartActionIdentifiers.clear();\n+\t\t}\n+\t\tif (mms[0].indexOf(EDIT_LANES) == -1) {\n+\t\t\tIAction action = ActionToolkit.action(() -> this.openEditLanesDialog(mms, isLegendMenu),\n+\t\t\t\t\tMessages.JavaApplicationPage_EDIT_THREAD_LANES_ACTION,\n+\t\t\t\t\tFlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_LANES_EDIT));\n+\t\t\taction.setId(EDIT_LANES);\n+\t\t\tfor (MCContextMenuManager mm : mms) {\n+\t\t\t\tmm.add(action);\n+\t\t\t\tmm.add(new Separator());\n+\t\t\t}\n+\t\t\tactions.add(action);\n+\t\t}\n+\t\tlaneDefs.stream().forEach(ld -> {\n+\t\t\tAction checkAction = new Action(ld.getName(), IAction.AS_CHECK_BOX) {\n+\t\t\t\tint laneIndex = laneDefs.indexOf(ld);\n@@ -248,0 +304,23 @@\n+\t\t\t\t@Override\n+\t\t\t\tpublic void run() {\n+\t\t\t\t\tsetLaneDefinitionEnablement(ld, laneIndex, isChecked());\n+\t\t\t\t\tbuildChart.run();\n+\t\t\t\t}\n+\t\t\t};\n+\t\t\tString identifier = ld.getName() + checkAction.hashCode();\n+\t\t\tcheckAction.setId(identifier);\n+\t\t\tif (isLegendMenu) {\n+\t\t\t\tlegendActionIdentifiers.add(identifier);\n+\t\t\t} else {\n+\t\t\t\tchartActionIdentifiers.add(identifier);\n+\t\t\t}\n+\t\t\tcheckAction.setChecked(ld.isEnabled());\n+\t\t\t\/\/ FIXME: Add a tooltip here\n+\t\t\tfor (MCContextMenuManager mm : mms) {\n+\t\t\t\tmm.add(checkAction);\n+\t\t\t}\n+\t\t\tactions.add(checkAction);\n+\t\t});\n+\t}\n+\n+\tpublic void updateContextMenu(MCContextMenuManager mm, boolean isLegendMenu) {\n@@ -274,3 +353,1 @@\n-\t\t\t\t\tLaneDefinition newLd = new LaneDefinition(ld.getName(), isChecked(), ld.getFilter(),\n-\t\t\t\t\t\t\tld.isRestLane());\n-\t\t\t\t\tlaneDefs.set(laneIndex, newLd);\n+\t\t\t\t\tsetLaneDefinitionEnablement(ld, laneIndex, isChecked());\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/common\/ThreadGraphLanes.java","additions":84,"deletions":7,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import org.openjdk.jmc.ui.misc.PatternFly.Palette;\n@@ -45,4 +46,12 @@\n-\t\tcase JdkTypeIDs.ERRORS_THROWN:\n-\t\t\treturn new Color(0xFF0000);\n-\t\tcase JdkTypeIDs.EXCEPTIONS_THROWN:\n-\t\t\treturn new Color(0xC80000);\n+\t\tcase JdkTypeIDs.RECORDINGS:\n+\t\t\treturn Palette.PF_CYAN_300.getAWTColor();\n+\t\tcase JdkTypeIDs.RECORDING_SETTING:\n+\t\t\treturn Palette.PF_GREEN_300.getAWTColor();\n+\t\tcase JdkTypeIDs.THROWABLES_STATISTICS:\n+\t\t\treturn Palette.PF_GOLD_500.getAWTColor();\n+\t\tcase JdkTypeIDs.BIASED_LOCK_CLASS_REVOCATION:\n+\t\t\treturn Palette.PF_PURPLE_400.getAWTColor();\n+\t\tcase JdkTypeIDs.BIASED_LOCK_REVOCATION:\n+\t\t\treturn Palette.PF_LIGHT_GREEN_300.getAWTColor();\n+\t\tcase JdkTypeIDs.BIASED_LOCK_SELF_REVOCATION:\n+\t\t\treturn Palette.PF_LIGHT_GREEN_400.getAWTColor();\n@@ -50,1 +59,1 @@\n-\t\t\treturn new Color(0xBE4422);\n+\t\t\treturn Palette.PF_ORANGE_300.getAWTColor();\n@@ -52,1 +61,5 @@\n-\t\t\treturn new Color(0x2C689E);\n+\t\t\treturn Palette.PF_CYAN_600.getAWTColor();\n+\t\tcase JdkTypeIDs.ERRORS_THROWN:\n+\t\t\treturn Palette.PF_RED_100.getAWTColor();\n+\t\tcase JdkTypeIDs.EXCEPTIONS_THROWN:\n+\t\t\treturn Palette.PF_RED_300.getAWTColor();\n@@ -54,1 +67,1 @@\n-\t\t\treturn new Color(0xFF6D64);\n+\t\t\treturn Palette.PF_ORANGE_200.getAWTColor();\n@@ -56,1 +69,35 @@\n-\t\t\treturn new Color(0xFFE75B);\n+\t\t\treturn Palette.PF_GOLD_200.getAWTColor();\n+\t\tcase JdkTypeIDs.THREAD_PARK:\n+\t\t\treturn Palette.PF_BLACK_500.getAWTColor();\n+\t\tcase JdkTypeIDs.THREAD_SLEEP:\n+\t\t\treturn Palette.PF_BLUE_500.getAWTColor();\n+\t\tcase JdkTypeIDs.OLD_OBJECT_SAMPLE:\n+\t\t\treturn Palette.PF_CYAN_200.getAWTColor();\n+\t\tcase JdkTypeIDs.SWEEP_CODE_CACHE:\n+\t\t\treturn Palette.PF_LIGHT_GREEN_500.getAWTColor();\n+\t\tcase JdkTypeIDs.SOCKET_READ:\n+\t\t\treturn new Color(0xC8321E);\n+\t\tcase JdkTypeIDs.SOCKET_WRITE:\n+\t\t\treturn Palette.PF_LIGHT_BLUE_500.getAWTColor();\n+\t\tcase JdkTypeIDs.CLASS_LOAD:\n+\t\t\treturn Palette.PF_PURPLE_100.getAWTColor();\n+\t\tcase JdkTypeIDs.COMPILATION:\n+\t\t\treturn Palette.PF_GOLD_300.getAWTColor();\n+\t\tcase JdkTypeIDs.GC_PAUSE:\n+\t\t\treturn new Color(0xDC3C00);\n+\t\tcase JdkTypeIDs.GC_PAUSE_L1:\n+\t\t\treturn new Color(0xE6CB45);\n+\t\tcase JdkTypeIDs.GC_PAUSE_L2:\n+\t\t\treturn new Color(0x458AE6);\n+\t\tcase JdkTypeIDs.GC_PAUSE_L3:\n+\t\t\treturn new Color(0xE645E2);\n+\t\tcase JdkTypeIDs.GC_PAUSE_L4:\n+\t\t\treturn new Color(0x85A115);\n+\t\tcase JdkTypeIDs.SAFEPOINT_BEGIN:\n+\t\t\treturn Palette.PF_PURPLE_200.getAWTColor();\n+\t\tcase JdkTypeIDs.SAFEPOINT_CLEANUP:\n+\t\t\treturn Palette.PF_PURPLE_500.getAWTColor();\n+\t\tcase JdkTypeIDs.SAFEPOINT_CLEANUP_TASK:\n+\t\t\treturn Palette.PF_BLUE_300.getAWTColor();\n+\t\tcase JdkTypeIDs.VM_OPERATIONS:\n+\t\t\treturn Palette.PF_ORANGE_500.getAWTColor();\n@@ -61,6 +108,0 @@\n-\t\tcase JdkTypeIDs.SOCKET_READ:\n-\t\t\treturn new Color(0xC8321E);\n-\t\tcase JdkTypeIDs.SOCKET_WRITE:\n-\t\t\treturn new Color(0x4678C8);\n-\t\tcase JdkTypeIDs.THREAD_PARK:\n-\t\t\treturn new Color(0x808080);\n@@ -71,2 +112,0 @@\n-\t\tcase JdkTypeIDs.CLASS_LOAD:\n-\t\t\treturn new Color(0x9B81DB);\n@@ -87,10 +126,0 @@\n-\t\tcase JdkTypeIDs.GC_PAUSE:\n-\t\t\treturn new Color(0xDC3C00);\n-\t\tcase JdkTypeIDs.GC_PAUSE_L1:\n-\t\t\treturn new Color(0xE6CB45);\n-\t\tcase JdkTypeIDs.GC_PAUSE_L2:\n-\t\t\treturn new Color(0x458AE6);\n-\t\tcase JdkTypeIDs.GC_PAUSE_L3:\n-\t\t\treturn new Color(0xE645E2);\n-\t\tcase JdkTypeIDs.GC_PAUSE_L4:\n-\t\t\treturn new Color(0x85A115);\n@@ -101,2 +130,0 @@\n-\t\tcase JdkTypeIDs.VM_OPERATIONS:\n-\t\t\treturn new Color(0xBA6F1F);\n@@ -105,2 +132,0 @@\n-\t\tcase JdkTypeIDs.COMPILATION:\n-\t\t\treturn new Color(0xF7EA2A);\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/common\/TypeLabelProvider.java","additions":56,"deletions":31,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+\tpublic static String DropdownLaneFilter_QUICK_FILTER;\n+\tpublic static String DropdownLaneFilter_THREAD_STATE_SELECTION;\n@@ -513,0 +515,2 @@\n+\tpublic static String ThreadsPage_FOLD_CHART_TOOLTIP;\n+\tpublic static String ThreadsPage_FOLD_TABLE_TOOLTIP;\n@@ -514,0 +518,1 @@\n+\tpublic static String ThreadsPage_LANE_FILTER_HEADER;\n@@ -516,0 +521,1 @@\n+\tpublic static String ThreadsPage_NAME_LEGACY;\n@@ -517,0 +523,5 @@\n+\tpublic static String ThreadsPage_SHOW_CHART_TOOLTIP;\n+\tpublic static String ThreadsPage_SHOW_TABLE_TOOLTIP;\n+\tpublic static String ThreadsPage_TABLE_POPUP_DESCRIPTION;\n+\tpublic static String ThreadsPage_TABLE_POPUP_TITLE;\n+\tpublic static String ThreadsPage_VIEW_THREAD_DETAILS;\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/messages\/internal\/Messages.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -87,2 +87,3 @@\n-\tprivate final IItemFilter pageFilter;\n-\tprivate final StreamModel model;\n+\tprivate static final int X_OFFSET = 180;\n+\tprivate IItemFilter pageFilter;\n+\tprotected StreamModel model;\n@@ -90,7 +91,7 @@\n-\tprotected final Form form;\n-\tprotected final Composite chartContainer;\n-\tprotected final ChartCanvas chartCanvas;\n-\tprotected final FilterComponent tableFilterComponent;\n-\tprotected final ItemHistogram table;\n-\tprotected final SashForm sash;\n-\tprivate final IPageContainer pageContainer;\n+\tprotected Form form;\n+\tprotected Composite chartContainer;\n+\tprotected ChartCanvas chartCanvas;\n+\tprotected FilterComponent tableFilterComponent;\n+\tprotected ItemHistogram table;\n+\tprotected SashForm sash;\n+\tprivate IPageContainer pageContainer;\n@@ -106,0 +107,8 @@\n+\t\tinit(pageFilter, model, parent, toolkit, pageContainer, state, sectionTitle, tableFilter, icon,\n+\t\t\t\tflavorSelectorState, classifier);\n+\t}\n+\n+\tprotected void init(\n+\t\tIItemFilter pageFilter, StreamModel model, Composite parent, FormToolkit toolkit, IPageContainer pageContainer,\n+\t\tIState state, String sectionTitle, IItemFilter tableFilter, Image icon, FlavorSelectorState flavorSelectorState,\n+\t\tIAttribute<?> classifier) {\n@@ -142,1 +151,1 @@\n-\t\tchart = new XYChart(pageContainer.getRecordingRange(), RendererToolkit.empty(), 180);\n+\t\tchart = new XYChart(pageContainer.getRecordingRange(), RendererToolkit.empty(), X_OFFSET);\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/pages\/ChartAndTableUI.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import org.eclipse.jface.action.GroupMarker;\n@@ -45,0 +46,1 @@\n+import org.eclipse.jface.action.IToolBarManager;\n@@ -47,0 +49,1 @@\n+import org.eclipse.jface.viewers.TableViewer;\n@@ -48,0 +51,1 @@\n+import org.eclipse.swt.layout.GridData;\n@@ -49,0 +53,3 @@\n+import org.eclipse.swt.widgets.Event;\n+import org.eclipse.swt.widgets.Item;\n+import org.eclipse.swt.widgets.Listener;\n@@ -79,0 +86,1 @@\n+import org.openjdk.jmc.flightrecorder.ui.common.DropdownLaneFilter;\n@@ -157,1 +165,1 @@\n-\tprivate class ThreadsPageUi extends ChartAndTableUI {\n+\tprivate class ThreadsPageUi extends ThreadsPageLayoutUI {\n@@ -159,0 +167,2 @@\n+\t\tprivate static final String FOLD_CHART_ACTION = \"foldChartAction\"; \/\/$NON-NLS-1$\n+\t\tprivate static final String FOLD_TABLE_ACTION = \"foldTableAction\"; \/\/$NON-NLS-1$\n@@ -161,0 +171,1 @@\n+\t\tpublic static final String TOOLBAR_FOLD_ACTIONS = \"foldActions\"; \/\/$NON-NLS-1$\n@@ -164,1 +175,4 @@\n-\t\tprivate IAction hideThreadAction;\n+\t\tprivate IAction foldChartAction;\n+\t\tprivate IAction foldTableAction;\n+\t\tprivate IAction hideThreadActionChart;\n+\t\tprivate IAction hideThreadActionText;\n@@ -166,0 +180,1 @@\n+\t\tprivate int[] weights;\n@@ -167,1 +182,3 @@\n-\t\tprivate MCContextMenuManager mm;\n+\t\tprivate MCContextMenuManager mmChart;\n+\t\tprivate MCContextMenuManager mmText;\n+\t\tprivate MCContextMenuManager[] mms;\n@@ -169,0 +186,1 @@\n+\t\tprivate DropdownLaneFilter laneFilter;\n@@ -173,3 +191,7 @@\n-\t\t\tmm = (MCContextMenuManager) chartCanvas.getContextMenu();\n-\t\t\tsash.setOrientation(SWT.HORIZONTAL);\n-\t\t\taddActionsToContextMenu(mm);\n+\t\t\tmmChart = (MCContextMenuManager) chartCanvas.getContextMenu();\n+\t\t\tmmText = (MCContextMenuManager) textCanvas.getContextMenu();\n+\t\t\tmms = new MCContextMenuManager[] {mmChart, mmText};\n+\t\t\tinitializeStoredSashWeights();\n+\t\t\tcanvasSash.setOrientation(SWT.HORIZONTAL);\n+\t\t\taddResizeListenerToTableAndChartComponents();\n+\t\t\taddActionsToContextMenu();\n@@ -177,7 +199,2 @@\n-\t\t\tlanes.updateContextMenu(mm, false);\n-\n-\t\t\tform.getToolBarManager()\n-\t\t\t\t\t.add(ActionToolkit.action(() -> lanes.openEditLanesDialog(mm, false),\n-\t\t\t\t\t\t\tMessages.ThreadsPage_EDIT_LANES,\n-\t\t\t\t\t\t\tFlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_LANES_EDIT)));\n-\t\t\tform.getToolBarManager().update(true);\n+\t\t\tlanes.updateContextMenus(mms, false);\n+\t\t\taddActionsToToolbar(form.getToolBarManager());\n@@ -185,1 +202,3 @@\n-\t\t\tbuildChart();\n+\t\t\tform.getToolBarManager().update(true);\n+\t\t\tsetupLaneFilter();\n+\t\t\tbuildChart(true);\n@@ -188,0 +207,3 @@\n+\t\t\tfor (Item columnWidget : ((TableViewer) table.getManager().getViewer()).getTable().getColumns()) {\n+\t\t\t\tcolumnWidget.addListener(SWT.Selection, e -> buildChart(false));\n+\t\t\t}\n@@ -192,0 +214,102 @@\n+\t\tprivate void addActionsToToolbar(IToolBarManager tb) {\n+\t\t\tfoldTableAction = ActionToolkit.checkAction(selected -> {\n+\t\t\t\tperformToolbarAction(FOLD_TABLE_ACTION, selected);\n+\t\t\t}, sash.getWeights()[0] == 0 ? Messages.ThreadsPage_SHOW_TABLE_TOOLTIP\n+\t\t\t\t\t: Messages.ThreadsPage_FOLD_TABLE_TOOLTIP,\n+\t\t\t\t\tFlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_TABLE));\n+\t\t\tfoldTableAction.setChecked(sash.getWeights()[0] == 0 ? false : true);\n+\n+\t\t\tfoldChartAction = ActionToolkit.checkAction(selected -> {\n+\t\t\t\tperformToolbarAction(FOLD_CHART_ACTION, selected);\n+\t\t\t}, sash.getWeights()[1] == 0 ? Messages.ThreadsPage_SHOW_CHART_TOOLTIP\n+\t\t\t\t\t: Messages.ThreadsPage_FOLD_CHART_TOOLTIP,\n+\t\t\t\t\tFlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_CHART_BAR));\n+\t\t\tfoldChartAction.setChecked(sash.getWeights()[1] == 0 ? false : true);\n+\n+\t\t\ttb.add(new GroupMarker(TOOLBAR_FOLD_ACTIONS));\n+\t\t\ttb.appendToGroup(TOOLBAR_FOLD_ACTIONS, foldTableAction);\n+\t\t\ttb.appendToGroup(TOOLBAR_FOLD_ACTIONS, foldChartAction);\n+\t\t\ttb.appendToGroup(TOOLBAR_FOLD_ACTIONS, new Separator());\n+\n+\t\t\ttb.add(ActionToolkit.action(() -> lanes.openEditLanesDialog(mms, false), Messages.ThreadsPage_EDIT_LANES,\n+\t\t\t\t\tFlightRecorderUI.getDefault().getMCImageDescriptor(ImageConstants.ICON_LANES_EDIT)));\n+\t\t}\n+\n+\t\tprivate void addResizeListenerToTableAndChartComponents() {\n+\t\t\ttableFilterComponent.getComponent().addListener(SWT.Resize, new Listener() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void handleEvent(Event event) {\n+\t\t\t\t\tif (!foldTableAction.isChecked() && tableFilterComponent.getComponent().getSize().y > 0) {\n+\t\t\t\t\t\tfoldTableAction.setChecked(true);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n+\n+\t\t\tcanvasSash.addListener(SWT.Resize, new Listener() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void handleEvent(Event event) {\n+\t\t\t\t\tif (!foldChartAction.isChecked() && chartCanvas.getSize().y > 0) {\n+\t\t\t\t\t\tfoldChartAction.setChecked(true);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\tprivate void performToolbarAction(String action, boolean selected) {\n+\t\t\tswitch (action) {\n+\t\t\tcase FOLD_TABLE_ACTION:\n+\t\t\t\tif (selected) {\n+\t\t\t\t\tsash.setWeights(this.getStoredSashWeights());\n+\t\t\t\t\tfoldTableAction.setToolTipText(Messages.ThreadsPage_FOLD_TABLE_TOOLTIP);\n+\t\t\t\t} else {\n+\t\t\t\t\t\/\/ if the chart is folded, don't fold the table\n+\t\t\t\t\tif (sash.getWeights()[1] == 0) {\n+\t\t\t\t\t\tthis.foldTableAction.setChecked(true);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthis.setStoredSashWeights(sash.getWeights());\n+\t\t\t\t\t\tsash.setWeights(new int[] {0, 2});\n+\t\t\t\t\t\tfoldTableAction.setToolTipText(Messages.ThreadsPage_SHOW_TABLE_TOOLTIP);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\tcase FOLD_CHART_ACTION:\n+\t\t\t\tif (selected) {\n+\t\t\t\t\tsash.setWeights(this.getStoredSashWeights());\n+\t\t\t\t\tfoldChartAction.setToolTipText(Messages.ThreadsPage_FOLD_CHART_TOOLTIP);\n+\t\t\t\t} else {\n+\t\t\t\t\t\/\/ if the table is folded, don't fold the chart\n+\t\t\t\t\tif (sash.getWeights()[0] == 0) {\n+\t\t\t\t\t\tthis.foldChartAction.setChecked(true);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthis.setStoredSashWeights(sash.getWeights());\n+\t\t\t\t\t\tsash.setWeights(new int[] {1, 0});\n+\t\t\t\t\t\tfoldChartAction.setToolTipText(Messages.ThreadsPage_SHOW_CHART_TOOLTIP);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate void initializeStoredSashWeights() {\n+\t\t\t\/\/ if either the chart or table are folded on init, store a default value of {1, 2}\n+\t\t\tif (sash.getWeights()[0] == 0 || sash.getWeights()[1] == 0) {\n+\t\t\t\tthis.setStoredSashWeights(new int[] {1, 2});\n+\t\t\t} else {\n+\t\t\t\tthis.setStoredSashWeights(sash.getWeights());\n+\t\t\t}\n+\t\t}\n+\n+\t\tprotected int[] getStoredSashWeights() {\n+\t\t\treturn this.weights;\n+\t\t}\n+\n+\t\tprotected void setStoredSashWeights(int[] weights) {\n+\t\t\tthis.weights = weights;\n+\t\t}\n+\n+\t\tprivate void setupLaneFilter() {\n+\t\t\tMCContextMenuManager[] mms = {mmChart, mmText};\n+\t\t\tlaneFilter = new DropdownLaneFilter(controlBar.getLaneFilterContainer(), lanes, mms);\n+\t\t\tlaneFilter.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false));\n+\t\t}\n+\n@@ -201,1 +325,1 @@\n-\t\t\t\t\tbuildChart();\n+\t\t\t\t\tbuildChart(false);\n@@ -234,2 +358,9 @@\n-\t\tprivate void addActionsToContextMenu(MCContextMenuManager mm) {\n-\t\t\tmm.add(new Separator());\n+\t\tprivate void addActionsToContextMenu() {\n+\t\t\tmmChart.add(new Separator());\n+\t\t\tmmText.add(new Separator());\n+\t\t\tIAction hideThreadActionChart = ActionToolkit.action(\n+\t\t\t\t\t() -> this.hideThread(chartCanvas.getHoveredItemData()), Messages.ThreadsPage_HIDE_THREAD_ACTION,\n+\t\t\t\t\tUIPlugin.getDefault().getMCImageDescriptor(UIPlugin.ICON_DELETE));\n+\t\t\thideThreadActionChart.setId(HIDE_THREAD);\n+\t\t\tthis.hideThreadActionChart = hideThreadActionChart;\n+\t\t\tmmChart.add(hideThreadActionChart);\n@@ -237,1 +368,1 @@\n-\t\t\tIAction hideThreadAction = ActionToolkit.action(() -> this.hideThread(chartCanvas.getHoveredItemData()),\n+\t\t\tIAction hideThreadActionText = ActionToolkit.action(() -> this.hideThread(textCanvas.getHoveredItemData()),\n@@ -240,3 +371,3 @@\n-\t\t\thideThreadAction.setId(HIDE_THREAD);\n-\t\t\tthis.hideThreadAction = hideThreadAction;\n-\t\t\tmm.add(hideThreadAction);\n+\t\t\thideThreadActionText.setId(HIDE_THREAD);\n+\t\t\tthis.hideThreadActionText = hideThreadActionText;\n+\t\t\tmmText.add(hideThreadActionText);\n@@ -250,1 +381,2 @@\n-\t\t\tmm.add(resetChartAction);\n+\t\t\tmmChart.add(resetChartAction);\n+\t\t\tmmText.add(resetChartAction);\n@@ -259,1 +391,1 @@\n-\t\t\tbuildChart();\n+\t\t\tbuildChart(false);\n@@ -266,1 +398,2 @@\n-\t\t\tthis.hideThreadAction.setEnabled(enabled);\n+\t\t\tthis.hideThreadActionChart.setEnabled(enabled);\n+\t\t\tthis.hideThreadActionText.setEnabled(enabled);\n@@ -282,1 +415,1 @@\n-\n+\t\t\tItemHistogram histogram = table;\n@@ -287,1 +420,1 @@\n-\t\t\t\tselection = table.getAllRows();\n+\t\t\t\tselection = histogram.getAllRows();\n@@ -298,0 +431,2 @@\n+\t\t\t\t\tchartCanvas.setNumItems(this.threadRows.size());\n+\t\t\t\t\ttextCanvas.setNumItems(this.threadRows.size());\n@@ -346,1 +481,1 @@\n-\t\t\tlanes = new ThreadGraphLanes(() -> getDataSource(), () -> buildChart());\n+\t\t\tlanes = new ThreadGraphLanes(() -> getDataSource(), () -> buildChart(false));\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/pages\/ThreadsPage.java","additions":162,"deletions":27,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -0,0 +1,349 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.ui.pages;\n+\n+import org.eclipse.jface.viewers.StructuredSelection;\n+import org.eclipse.osgi.util.NLS;\n+import org.eclipse.swt.SWT;\n+import org.eclipse.swt.custom.SashForm;\n+import org.eclipse.swt.custom.ScrolledComposite;\n+import org.eclipse.swt.graphics.Image;\n+import org.eclipse.swt.layout.FillLayout;\n+import org.eclipse.swt.layout.FormAttachment;\n+import org.eclipse.swt.layout.FormData;\n+import org.eclipse.swt.layout.FormLayout;\n+import org.eclipse.swt.layout.GridData;\n+import org.eclipse.swt.layout.GridLayout;\n+import org.eclipse.swt.widgets.Composite;\n+import org.eclipse.swt.widgets.Display;\n+import org.eclipse.swt.widgets.Event;\n+import org.eclipse.swt.widgets.Listener;\n+import org.eclipse.ui.forms.widgets.FormToolkit;\n+\n+import org.openjdk.jmc.common.IState;\n+import org.openjdk.jmc.common.IWritableState;\n+import org.openjdk.jmc.common.item.IAttribute;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.item.IItemFilter;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.IRange;\n+import org.openjdk.jmc.flightrecorder.JfrAttributes;\n+import org.openjdk.jmc.flightrecorder.ui.IPageContainer;\n+import org.openjdk.jmc.flightrecorder.ui.StreamModel;\n+import org.openjdk.jmc.flightrecorder.ui.common.DataPageToolkit;\n+import org.openjdk.jmc.flightrecorder.ui.common.FilterComponent;\n+import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector;\n+import org.openjdk.jmc.flightrecorder.ui.common.FlavorSelector.FlavorSelectorState;\n+import org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages;\n+import org.openjdk.jmc.flightrecorder.ui.selection.SelectionStoreActionToolkit;\n+import org.openjdk.jmc.ui.charts.IXDataRenderer;\n+import org.openjdk.jmc.ui.charts.RendererToolkit;\n+import org.openjdk.jmc.ui.charts.XYChart;\n+import org.openjdk.jmc.ui.column.ColumnMenusFactory;\n+import org.openjdk.jmc.ui.common.util.Environment;\n+import org.openjdk.jmc.ui.handlers.ActionToolkit;\n+import org.openjdk.jmc.ui.handlers.MCContextMenuManager;\n+import org.openjdk.jmc.ui.misc.ChartCanvas;\n+import org.openjdk.jmc.ui.misc.ChartControlBar;\n+import org.openjdk.jmc.ui.misc.ActionUiToolkit;\n+import org.openjdk.jmc.ui.misc.ChartButtonGroup;\n+import org.openjdk.jmc.ui.misc.ChartTextCanvas;\n+import org.openjdk.jmc.ui.misc.PersistableSashForm;\n+import org.openjdk.jmc.ui.misc.TimelineCanvas;\n+\n+abstract class ThreadsPageLayoutUI extends ChartAndTableUI {\n+\n+\tprivate static final double Y_SCALE = Display.getCurrent().getDPI().y \/ Environment.getNormalDPI();\n+\tprivate static final String TABLE = \"table\"; \/\/$NON-NLS-1$\n+\tprivate static final String CHART = \"chart\"; \/\/$NON-NLS-1$\n+\tprivate static final String CANVAS_SASH = \"canvasSash\"; \/\/$NON-NLS-1$\n+\tprivate static final String PAGE_SASH = \"pageSash\"; \/\/$NON-NLS-1$\n+\tprivate static final String SELECTED = \"selected\"; \/\/$NON-NLS-1$\n+\tprivate static final int TIMELINE_HEIGHT = 40;\n+\tprivate static final int X_OFFSET = 0;\n+\tprivate static final int Y_OFFSET = 0;\n+\tprotected ChartControlBar controlBar;\n+\tprotected ChartTextCanvas textCanvas;\n+\tprotected IPageContainer pageContainer;\n+\tprivate Composite zoomPanContainer;\n+\tprivate ChartButtonGroup buttonGroup;\n+\tprivate IItemCollection selectionItems;\n+\tprivate IItemFilter pageFilter;\n+\tprivate IRange<IQuantity> timeRange;\n+\tprotected SashForm canvasSash;\n+\tprivate TimelineCanvas timelineCanvas;\n+\n+\tThreadsPageLayoutUI(IItemFilter pageFilter, StreamModel model, Composite parent, FormToolkit toolkit,\n+\t\t\tIPageContainer pageContainer, IState state, String sectionTitle, IItemFilter tableFilter, Image icon,\n+\t\t\tFlavorSelectorState flavorSelectorState, IAttribute<?> classifier) {\n+\t\tsuper(pageFilter, model, parent, toolkit, pageContainer, state, sectionTitle, tableFilter, icon,\n+\t\t\t\tflavorSelectorState, classifier);\n+\t}\n+\n+\tprotected void init(\n+\t\tIItemFilter pageFilter, StreamModel model, Composite parent, FormToolkit toolkit, IPageContainer pageContainer,\n+\t\tIState state, String sectionTitle, IItemFilter tableFilter, Image icon, FlavorSelectorState flavorSelectorState,\n+\t\tIAttribute<?> classifier) {\n+\t\tthis.pageFilter = pageFilter;\n+\t\tthis.model = model;\n+\t\tthis.pageContainer = pageContainer;\n+\t\tform = DataPageToolkit.createForm(parent, toolkit, sectionTitle, icon);\n+\t\tsash = new SashForm(form.getBody(), SWT.VERTICAL);\n+\t\ttoolkit.adapt(sash);\n+\n+\t\tsetupTable(state, sectionTitle, tableFilter, classifier);\n+\t\tsetupChartContainers(toolkit);\n+\n+\t\tallChartSeriesActions = initializeChartConfiguration(state);\n+\t\tIState chartState = state.getChild(CHART);\n+\t\tActionToolkit.loadCheckState(chartState, allChartSeriesActions.stream());\n+\t\tchartLegend = ActionUiToolkit.buildCheckboxViewer(chartContainer, allChartSeriesActions.stream());\n+\t\tGridData gridData = new GridData(SWT.FILL, SWT.FILL, false, true);\n+\t\tgridData.widthHint = 180;\n+\t\tchartLegend.getControl().setLayoutData(gridData);\n+\t\tDataPageToolkit.createChartTimestampTooltip(chartCanvas);\n+\n+\t\tchart = new XYChart(pageContainer.getRecordingRange(), RendererToolkit.empty(), X_OFFSET, Y_OFFSET,\n+\t\t\t\ttimelineCanvas, controlBar, buttonGroup);\n+\t\tDataPageToolkit.setChart(chartCanvas, chart, pageContainer::showSelection);\n+\t\tDataPageToolkit.setChart(textCanvas, chart, pageContainer::showSelection);\n+\t\tSelectionStoreActionToolkit.addSelectionStoreRangeActions(pageContainer.getSelectionStore(), chart,\n+\t\t\t\tJfrAttributes.LIFETIME, NLS.bind(Messages.ChartAndTableUI_TIMELINE_SELECTION, form.getText()),\n+\t\t\t\tchartCanvas.getContextMenu());\n+\t\tSelectionStoreActionToolkit.addSelectionStoreRangeActions(pageContainer.getSelectionStore(), chart,\n+\t\t\t\tJfrAttributes.LIFETIME, NLS.bind(Messages.ChartAndTableUI_TIMELINE_SELECTION, form.getText()),\n+\t\t\t\ttextCanvas.getContextMenu());\n+\n+\t\tchartCanvas.setZoomOnClickListener(mouseDown -> buttonGroup.zoomOnClick(mouseDown));\n+\t\tchartCanvas.setZoomToSelectionListener(() -> buttonGroup.zoomToSelection());\n+\n+\t\t\/\/ Wire-up the chart & text canvases to the control bar and button group\n+\t\tchartCanvas.setTextCanvas(textCanvas);\n+\t\ttextCanvas.setChartCanvas(chartCanvas);\n+\t\tcontrolBar.setChart(chart);\n+\t\tcontrolBar.setChartCanvas(chartCanvas);\n+\t\tcontrolBar.setTextCanvas(textCanvas);\n+\t\tbuttonGroup.createZoomPan(zoomPanContainer);\n+\t\ttimelineCanvas.setChart(chart);\n+\n+\t\tif (chartState != null) {\n+\t\t\tfinal String legendSelection = chartState.getAttribute(SELECTED);\n+\n+\t\t\tif (legendSelection != null) {\n+\t\t\t\tallChartSeriesActions.stream().filter(ia -> legendSelection.equals(ia.getId())).findFirst()\n+\t\t\t\t\t\t.ifPresent(a -> chartLegend.setSelection(new StructuredSelection(a)));\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (state.getChild(PAGE_SASH) == null) {\n+\t\t\tsash.setWeights(new int[] {0, 3});\n+\t\t} else {\n+\t\t\tPersistableSashForm.loadState(sash, state.getChild(PAGE_SASH));\n+\t\t}\n+\n+\t\tif (state.getChild(CANVAS_SASH) == null) {\n+\t\t\tcanvasSash.setWeights(new int[] {1, 4});\n+\t\t} else {\n+\t\t\tPersistableSashForm.loadState(canvasSash, state.getChild(CANVAS_SASH));\n+\t\t}\n+\n+\t\tflavorSelector = FlavorSelector.itemsWithTimerange(form, pageFilter, model.getItems(), pageContainer,\n+\t\t\t\tthis::onFlavorSelected, this::onSetRange, flavorSelectorState);\n+\t}\n+\n+\tprivate void setupTable(IState state, String sectionTitle, IItemFilter tableFilter, IAttribute<?> classifier) {\n+\t\t\/\/ Setup the table\n+\t\ttable = buildHistogram(sash, state.getChild(TABLE), classifier);\n+\t\tMCContextMenuManager mm = MCContextMenuManager.create(table.getManager().getViewer().getControl());\n+\t\tColumnMenusFactory.addDefaultMenus(table.getManager(), mm);\n+\t\ttable.getManager().getViewer().addSelectionChangedListener(e -> buildChart(true));\n+\t\ttable.getManager().getViewer()\n+\t\t\t\t.addSelectionChangedListener(e -> pageContainer.showSelection(table.getSelection().getItems()));\n+\t\tSelectionStoreActionToolkit.addSelectionStoreActions(pageContainer.getSelectionStore(), table,\n+\t\t\t\tNLS.bind(Messages.ChartAndTableUI_HISTOGRAM_SELECTION, sectionTitle), mm);\n+\t\ttableFilterComponent = FilterComponent.createFilterComponent(table.getManager().getViewer().getControl(),\n+\t\t\t\ttable.getManager(), tableFilter, model.getItems().apply(pageFilter),\n+\t\t\t\tpageContainer.getSelectionStore()::getSelections, this::onFilterChange);\n+\t\tmm.add(tableFilterComponent.getShowFilterAction());\n+\t\tmm.add(tableFilterComponent.getShowSearchAction());\n+\t}\n+\n+\tprivate void setupChartContainers(FormToolkit toolkit) {\n+\t\t\/\/ Scrolled Composite containing all of the chart-related components\n+\t\tScrolledComposite scChartContainer = new ScrolledComposite(sash, SWT.H_SCROLL | SWT.V_SCROLL);\n+\t\tscChartContainer.setAlwaysShowScrollBars(false);\n+\t\tscChartContainer.setExpandHorizontal(true);\n+\t\tscChartContainer.setExpandVertical(true);\n+\t\tscChartContainer.addListener(SWT.Resize, new Listener() {\n+\t\t\t@Override\n+\t\t\tpublic void handleEvent(Event event) {\n+\t\t\t\tint width = controlBar.computeSize(SWT.DEFAULT, SWT.DEFAULT).x;\n+\t\t\t\tint height = controlBar.computeSize(SWT.DEFAULT, SWT.DEFAULT).y\n+\t\t\t\t\t\t+ buttonGroup.computeSize(SWT.DEFAULT, SWT.DEFAULT).y;\n+\t\t\t\tif (width > 0 && height > 0) {\n+\t\t\t\t\tscChartContainer.setMinSize(scChartContainer.computeSize(width, height));\n+\t\t\t\t\tscChartContainer.removeListener(SWT.Resize, this);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\n+\t\t\/\/ chartContainer to layout all of the chart components\n+\t\tchartContainer = toolkit.createComposite(scChartContainer);\n+\t\tchartContainer.setLayout(new GridLayout());\n+\t\tchartContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));\n+\t\tscChartContainer.setContent(chartContainer);\n+\n+\t\t\/\/ Chart Control Toolbar\n+\t\tListener resetListener = new Listener() {\n+\t\t\t@Override\n+\t\t\tpublic void handleEvent(Event event) {\n+\t\t\t\tonSetRange(false);\n+\t\t\t\ttable.getManager().getViewer().setSelection(null);\n+\t\t\t}\n+\t\t};\n+\t\tcontrolBar = new ChartControlBar(chartContainer, resetListener, pageContainer.getRecordingRange());\n+\t\tcontrolBar.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, false));\n+\t\tbuttonGroup = controlBar.getButtonGroup();\n+\n+\t\t\/\/ Container to hold the chartContainer and a zoom-pan overlay\n+\t\tComposite zoomPanAndChartContainer = toolkit.createComposite(chartContainer);\n+\t\tzoomPanAndChartContainer.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));\n+\t\tzoomPanAndChartContainer.setLayout(new FormLayout());\n+\n+\t\t\/\/ Container to hold fixed zoom-pan display\n+\t\tzoomPanContainer = toolkit.createComposite(zoomPanAndChartContainer);\n+\t\tzoomPanContainer.setLayout(new FillLayout());\n+\t\tFormData fd = new FormData();\n+\t\tfd.height = 80;\n+\t\tfd.width = 150;\n+\t\tfd.bottom = new FormAttachment(100, -12);\n+\t\tfd.right = new FormAttachment(100, -12);\n+\t\tzoomPanContainer.setLayoutData(fd);\n+\n+\t\t\/\/ SashForm to hold the two canvas components: chart text canvas on the left, chart canvas on the right\n+\t\tcanvasSash = new SashForm(zoomPanAndChartContainer, SWT.HORIZONTAL);\n+\t\tfd = new FormData();\n+\t\tfd.right = new FormAttachment(100, -1);\n+\t\tfd.top = new FormAttachment(0, 1);\n+\t\tfd.left = new FormAttachment(0, 1);\n+\t\tfd.bottom = new FormAttachment(100, -1);\n+\t\tcanvasSash.setLayoutData(fd);\n+\t\ttoolkit.adapt(canvasSash);\n+\n+\t\tScrolledComposite scText = new ScrolledComposite(canvasSash, SWT.BORDER | SWT.V_SCROLL);\n+\t\tGridData scTextGd = new GridData(SWT.FILL, SWT.FILL, false, true);\n+\t\ttextCanvas = new ChartTextCanvas(scText);\n+\t\ttextCanvas.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, true));\n+\t\tscTextGd.widthHint = 180;\n+\t\tscText.setLayoutData(scTextGd);\n+\t\tscText.setContent(textCanvas);\n+\t\tscText.setAlwaysShowScrollBars(false);\n+\t\tscText.setExpandHorizontal(true);\n+\t\tscText.setExpandVertical(true);\n+\n+\t\tScrolledComposite scChart = new ScrolledComposite(canvasSash, SWT.BORDER | SWT.V_SCROLL);\n+\t\tchartCanvas = new ChartCanvas(scChart);\n+\t\tchartCanvas.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));\n+\t\tscChart.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));\n+\t\tscChart.setContent(chartCanvas);\n+\t\tscChart.setAlwaysShowScrollBars(true);\n+\t\tscChart.setExpandHorizontal(true);\n+\t\tscChart.setExpandVertical(true);\n+\n+\t\ttimelineCanvas = new TimelineCanvas(chartContainer, chartCanvas, canvasSash, Y_SCALE);\n+\t\tGridData gridData = new GridData(SWT.FILL, SWT.DEFAULT, true, false);\n+\t\tgridData.heightHint = (int) (TIMELINE_HEIGHT * Y_SCALE);\n+\t\ttimelineCanvas.setLayoutData(gridData);\n+\t}\n+\n+\tprotected void onFilterChange(IItemFilter filter) {\n+\t\tIItemCollection items = getItems();\n+\t\tif (tableFilterComponent.isVisible()) {\n+\t\t\ttable.show(items.apply(filter));\n+\t\t\ttableFilterComponent.setColor(table.getAllRows().getRowCount());\n+\t\t} else if (table != null) {\n+\t\t\ttable.show(items);\n+\t\t}\n+\t}\n+\n+\tprivate void onSetRange(Boolean useRange) {\n+\t\tIRange<IQuantity> range = useRange ? timeRange : pageContainer.getRecordingRange();\n+\t\tchart.setVisibleRange(range.getStart(), range.getEnd());\n+\t\tchart.resetZoomFactor();\n+\t\tif (table != null) {\n+\t\t\ttable.getManager().getViewer().setSelection(null);\n+\t\t}\n+\t\tchartCanvas.resetLaneHeight();\n+\t\tbuildChart(true);\n+\t}\n+\n+\t@Override\n+\tpublic void saveTo(IWritableState writableState) {\n+\t\tsuper.saveTo(writableState);\n+\t\tPersistableSashForm.saveState(sash, writableState.createChild(PAGE_SASH));\n+\t\tPersistableSashForm.saveState(canvasSash, writableState.createChild(CANVAS_SASH));\n+\t}\n+\n+\tprivate void onFlavorSelected(IItemCollection items, IRange<IQuantity> timeRange) {\n+\t\tthis.selectionItems = items;\n+\t\tthis.timeRange = timeRange;\n+\t\ttable.show(getItems());\n+\n+\t\tif (selectionItems != null) {\n+\t\t\tObject[] tableInput = (Object[]) table.getManager().getViewer().getInput();\n+\t\t\tif (tableInput != null) {\n+\t\t\t\ttable.getManager().getViewer().setSelection(new StructuredSelection(tableInput));\n+\t\t\t} else {\n+\t\t\t\ttable.getManager().getViewer().setSelection(null);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected void buildChart(boolean resetLaneHeightControls) {\n+\t\tIXDataRenderer rendererRoot = getChartRenderer(getItems(), table.getSelection());\n+\t\tif (resetLaneHeightControls) {\n+\t\t\tcontrolBar.resetLaneHeightToMinimum();\n+\t\t}\n+\t\tchartCanvas.replaceRenderer(rendererRoot);\n+\t\ttextCanvas.replaceRenderer(rendererRoot);\n+\t}\n+\n+\tprivate IItemCollection getItems() {\n+\t\treturn selectionItems != null ? selectionItems.apply(pageFilter) : model.getItems().apply(pageFilter);\n+\t}\n+\n+\tpublic void setTimeRange(IRange<IQuantity> range) {\n+\t\tthis.timeRange = range;\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/pages\/ThreadsPageLayoutUI.java","additions":349,"deletions":0,"binary":false,"changes":349,"status":"added"},{"patch":"@@ -90,1 +90,1 @@\n-public class ThreadsPage extends AbstractDataPage {\n+public class ThreadsPageLegacy extends AbstractDataPage {\n@@ -92,1 +92,1 @@\n-\tpublic static class ThreadsPageFactory implements IDataPageFactory {\n+\tpublic static class ThreadsPageLegacyFactory implements IDataPageFactory {\n@@ -96,1 +96,1 @@\n-\t\t\treturn Messages.ThreadsPage_NAME;\n+\t\t\treturn Messages.ThreadsPage_NAME_LEGACY;\n@@ -111,1 +111,1 @@\n-\t\t\treturn new ThreadsPage(definition, items, editor);\n+\t\t\treturn new ThreadsPageLegacy(definition, items, editor);\n@@ -356,1 +356,1 @@\n-\tpublic ThreadsPage(IPageDefinition definition, StreamModel model, IPageContainer editor) {\n+\tpublic ThreadsPageLegacy(IPageDefinition definition, StreamModel model, IPageContainer editor) {\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/pages\/ThreadsPageLegacy.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/pages\/ThreadsPage.java","status":"copied"},{"patch":"@@ -107,0 +107,3 @@\n+DropdownLaneFilter_QUICK_FILTER=Quick Filter\n+DropdownLaneFilter_THREAD_STATE_SELECTION=Thread State Selection\n+\n@@ -496,0 +499,2 @@\n+ThreadsPage_FOLD_CHART_TOOLTIP=Fold Chart\n+ThreadsPage_FOLD_TABLE_TOOLTIP=Fold Table\n@@ -497,0 +502,1 @@\n+ThreadsPage_LANE_FILTER_HEADER=THREAD STATE SELECTION\n@@ -500,0 +506,1 @@\n+ThreadsPage_NAME_LEGACY = (Legacy) Threads\n@@ -501,0 +508,6 @@\n+ThreadsPage_SHOW_CHART_TOOLTIP=Show Chart\n+ThreadsPage_SHOW_TABLE_TOOLTIP=Show Table\n+ThreadsPage_VIEW_THREAD_DETAILS=View Thread Details\n+ThreadsPage_TABLE_POPUP_DESCRIPTION=Store a thread selection to make a new filter\n+ThreadsPage_TABLE_POPUP_TITLE=Thread Details\n+\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/ui\/messages\/internal\/messages.properties","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"filename":"application\/org.openjdk.jmc.ui\/icons\/fa-minus-16.png","binary":true,"status":"added"},{"filename":"application\/org.openjdk.jmc.ui\/icons\/fa-plus-16.png","binary":true,"status":"added"},{"filename":"application\/org.openjdk.jmc.ui\/icons\/fa-scale-to-fit-16.png","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+<svg id=\"Layer_1\" data-name=\"Layer 1\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\" viewBox=\"0 0 14 14\"><title>Scale-to-fit_option2<\/title><path d=\"M10,10.77a.74.74,0,0,1,.21-.53.73.73,0,0,1,.54-.22h3.87a.4.4,0,0,1,.27.11.37.37,0,0,1,.11.27v1.25a.36.36,0,0,1-.11.26.4.4,0,0,1-.27.11H12v2.63a.36.36,0,0,1-.11.26.4.4,0,0,1-.27.11H10.37a.36.36,0,0,1-.26-.11.33.33,0,0,1-.11-.26ZM15,22.4a.37.37,0,0,0-.11-.27.4.4,0,0,0-.27-.11H12V19.4a.37.37,0,0,0-.11-.27.4.4,0,0,0-.27-.11H10.37a.36.36,0,0,0-.26.11.33.33,0,0,0-.11.27v3.87a.72.72,0,0,0,.21.53.73.73,0,0,0,.54.22h3.87a.4.4,0,0,0,.27-.11.36.36,0,0,0,.11-.26Zm4-10.75a.33.33,0,0,0,.11.26.36.36,0,0,0,.26.11H22v2.63a.33.33,0,0,0,.11.26.36.36,0,0,0,.26.11h1.25a.4.4,0,0,0,.27-.11.36.36,0,0,0,.11-.26V10.77a.75.75,0,0,0-.22-.53.73.73,0,0,0-.53-.22H19.37a.36.36,0,0,0-.26.11.33.33,0,0,0-.11.27ZM22.37,19a.36.36,0,0,0-.26.11.33.33,0,0,0-.11.27V22H19.37a.36.36,0,0,0-.26.11.33.33,0,0,0-.11.27v1.25a.33.33,0,0,0,.11.26.36.36,0,0,0,.26.11h3.88a.75.75,0,0,0,.75-.75V19.4a.37.37,0,0,0-.11-.27.4.4,0,0,0-.27-.11Z\" transform=\"translate(-10 -10.02)\"\/><\/svg>\n\\ No newline at end of file\n","filename":"application\/org.openjdk.jmc.ui\/icons\/fa-scale-to-fit.svg","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<!-- Generator: Adobe Illustrator 23.0.4, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n+<svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\" xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\" x=\"0px\" y=\"0px\"\n+\t viewBox=\"0 0 10.1 16.2\" style=\"enable-background:new 0 0 10.1 16.2;\" xml:space=\"preserve\">\n+<style type=\"text\/css\">\n+\t.st0{enable-background:new    ;}\n+<\/style>\n+<title>Select<\/title>\n+<g class=\"st0\">\n+\t<path d=\"M6.1,10.5l1.8,4.2C8,14.8,8,15,7.9,15.1s-0.2,0.2-0.3,0.3L6,16.1c-0.1,0.1-0.3,0.1-0.4,0s-0.2-0.2-0.3-0.3l-1.7-4l-2.7,2.8\n+\t\tc-0.2,0.2-0.4,0.2-0.6,0.1S0,14.4,0,14.2V0.7c0-0.3,0.1-0.4,0.3-0.5s0.4-0.1,0.6,0.1l8.9,9.2C10,9.7,10,9.9,9.9,10.1\n+\t\ts-0.3,0.4-0.5,0.4H6.1z\"\/>\n+<\/g>\n+<\/svg>\n","filename":"application\/org.openjdk.jmc.ui\/icons\/fa-select.svg","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"filename":"application\/org.openjdk.jmc.ui\/icons\/fa-selection-16.png","binary":true,"status":"added"},{"filename":"application\/org.openjdk.jmc.ui\/icons\/fa-zoom-in-16.png","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<!-- Generator: Adobe Illustrator 23.0.4, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n+<svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\" xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\" x=\"0px\" y=\"0px\"\n+\t viewBox=\"0 0 16.7 16.2\" style=\"enable-background:new 0 0 16.7 16.2;\" xml:space=\"preserve\">\n+<style type=\"text\/css\">\n+\t.st0{enable-background:new    ;}\n+<\/style>\n+<title>Zoom-in<\/title>\n+<g class=\"st0\">\n+\t<path d=\"M14.9,15.9c-0.1,0.1-0.3,0.2-0.5,0.2S14,16,13.9,15.9l-3.1-3.1c-0.1-0.1-0.2-0.3-0.2-0.5v-0.5c-1.2,0.9-2.5,1.4-4,1.4\n+\t\tc-1.2,0-2.3-0.3-3.3-0.9s-1.8-1.4-2.4-2.4S0,7.8,0,6.6s0.3-2.3,0.9-3.3S2.2,1.5,3.2,1s2.1-0.9,3.3-0.9S8.8,0.4,9.8,1\n+\t\ts1.8,1.4,2.4,2.4s0.8,2,0.8,3.2c0,1.5-0.5,2.8-1.4,4h0.5c0.2,0,0.4,0.1,0.5,0.2l3.1,3.1c0.1,0.1,0.2,0.3,0.2,0.5s-0.1,0.4-0.2,0.5\n+\t\tL14.9,15.9z M10.2,4.5C9.8,3.8,9.3,3.3,8.6,2.9S7.3,2.3,6.5,2.3S5,2.5,4.4,2.9S3.2,3.8,2.8,4.5S2.2,5.8,2.2,6.6s0.2,1.5,0.6,2.1\n+\t\ts0.9,1.2,1.5,1.5s1.4,0.6,2.1,0.6s1.5-0.2,2.1-0.6S9.7,9.3,10,8.7s0.6-1.4,0.6-2.1S10.6,5.1,10.2,4.5z M9.5,7.1\n+\t\tc0,0.1,0,0.2-0.1,0.3C9.3,7.5,9.2,7.5,9.1,7.5H7.4v1.8c0,0.1,0,0.2-0.1,0.3s-0.2,0-0.3,0H6c-0.1,0-0.2,0-0.3-0.1S5.6,9.3,5.6,9.2\n+\t\tV7.5H3.9c-0.1,0-0.2,0-0.3-0.1S3.5,7.2,3.5,7.1v-1c0-0.1,0-0.2,0.1-0.3s0.2-0.1,0.3-0.1h1.8V4c0-0.1,0-0.2,0.1-0.3S5.9,3.6,6,3.6h1\n+\t\tc0.1,0,0.2,0,0.3,0.1S7.4,3.9,7.4,4v1.8h1.8c0.1,0,0.2,0,0.3,0.1s0.1,0.2,0.1,0.3v0.9H9.5z\"\/>\n+<\/g>\n+<\/svg>\n","filename":"application\/org.openjdk.jmc.ui\/icons\/fa-zoom-in.svg","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"filename":"application\/org.openjdk.jmc.ui\/icons\/fa-zoom-out-16.png","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<!-- Generator: Adobe Illustrator 23.0.4, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n+<svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\" xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\" x=\"0px\" y=\"0px\"\n+\t viewBox=\"0 0 16.3 16.1\" style=\"enable-background:new 0 0 16.3 16.1;\" xml:space=\"preserve\">\n+<style type=\"text\/css\">\n+\t.st0{enable-background:new    ;}\n+<\/style>\n+<title>Zoom-out<\/title>\n+<g class=\"st0\">\n+\t<path d=\"M14.9,15.9c-0.1,0.1-0.3,0.2-0.5,0.2S14,16,13.9,15.9l-3.1-3.1c-0.1-0.1-0.2-0.3-0.2-0.5v-0.5c-1.2,0.9-2.5,1.4-4,1.4\n+\t\tc-1.2,0-2.3-0.3-3.3-0.9s-1.8-1.4-2.4-2.4S0,7.8,0,6.6s0.3-2.3,0.9-3.3S2.2,1.5,3.2,1s2.1-0.9,3.3-0.9S8.8,0.4,9.8,1\n+\t\ts1.8,1.4,2.4,2.4s0.8,2,0.8,3.2c0,1.5-0.5,2.8-1.4,4h0.5c0.2,0,0.4,0.1,0.5,0.2l3.1,3.1c0.1,0.1,0.2,0.3,0.2,0.5s-0.1,0.4-0.2,0.5\n+\t\tL14.9,15.9z M10.2,4.5C9.8,3.8,9.3,3.3,8.6,2.9S7.3,2.3,6.5,2.3S5,2.5,4.4,2.9S3.2,3.8,2.8,4.5S2.2,5.8,2.2,6.6s0.2,1.5,0.6,2.1\n+\t\ts0.9,1.2,1.5,1.5s1.4,0.6,2.1,0.6s1.5-0.2,2.1-0.6S9.7,9.3,10,8.7s0.6-1.4,0.6-2.1S10.6,5.1,10.2,4.5z M9.5,7.1\n+\t\tc0,0.1,0,0.2-0.1,0.3C9.3,7.5,9.2,7.5,9.1,7.5H3.9c-0.1,0-0.2,0-0.3-0.1S3.5,7.2,3.5,7.1v-1c0-0.1,0-0.2,0.1-0.3s0.2-0.1,0.3-0.1\n+\t\th5.2c0.1,0,0.2,0,0.3,0.1S9.5,6,9.5,6.1V7.1z\"\/>\n+<\/g>\n+<\/svg>\n","filename":"application\/org.openjdk.jmc.ui\/icons\/fa-zoom-out.svg","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"filename":"application\/org.openjdk.jmc.ui\/icons\/fa-zoom-pan-16.png","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<!-- Generator: Adobe Illustrator 23.0.4, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->\n+<svg version=\"1.1\" id=\"Layer_1\" xmlns=\"http:\/\/www.w3.org\/2000\/svg\" xmlns:xlink=\"http:\/\/www.w3.org\/1999\/xlink\" x=\"0px\" y=\"0px\"\n+\t viewBox=\"0 0 16.4 16.2\" style=\"enable-background:new 0 0 16.4 16.2;\" xml:space=\"preserve\">\n+<style type=\"text\/css\">\n+\t.st0{enable-background:new    ;}\n+<\/style>\n+<title>Zoom-pan<\/title>\n+<g class=\"st0\">\n+\t<path d=\"M8.5,15.9C8.4,16,8.2,16.1,8,16.1S7.6,16,7.5,15.9L5,13.4c-0.1-0.2-0.2-0.3-0.2-0.5s0.1-0.4,0.2-0.6s0.3-0.2,0.5-0.2h1.6V9\n+\t\tH4v1.5c0,0.2-0.1,0.4-0.2,0.5s-0.3,0.2-0.5,0.2S2.9,11.1,2.8,11L0.2,8.6C0.1,8.5,0,8.3,0,8.1s0.1-0.4,0.2-0.6L2.7,5\n+\t\tC2.9,4.9,3,4.8,3.2,4.8S3.6,4.9,3.7,5S4,5.4,4,5.6v1.6h3.2V4H5.5C5.3,4,5.1,4,5,3.8S4.8,3.5,4.8,3.3s0-0.4,0.2-0.5l2.5-2.5\n+\t\tC7.6,0.2,7.8,0.1,8,0.1s0.4,0.1,0.5,0.2L11,2.8c0.1,0.2,0.2,0.3,0.2,0.5S11.1,3.7,11,3.8S10.7,4,10.5,4H8.9v3.2H12V5.6\n+\t\tc0-0.2,0.1-0.4,0.2-0.5s0.3-0.2,0.5-0.2s0.4,0.1,0.5,0.2l2.6,2.4C15.9,7.7,16,7.9,16,8.1s-0.1,0.4-0.2,0.5l-2.5,2.5\n+\t\tc-0.2,0.2-0.3,0.2-0.5,0.2s-0.4-0.1-0.5-0.2S12,10.8,12,10.5V9H8.9v3.2h1.6c0.2,0,0.4,0.1,0.5,0.2s0.2,0.3,0.2,0.5\n+\t\ts-0.1,0.4-0.2,0.5L8.5,15.9z\"\/>\n+<\/g>\n+<\/svg>\n","filename":"application\/org.openjdk.jmc.ui\/icons\/fa-zoom-pan.svg","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,0 +129,9 @@\n+\t\/\/ font awesome\n+\tpublic static final String ICON_FA_SCALE_TO_FIT = \"fa-scale-to-fit-16.png\";\n+\tpublic static final String ICON_FA_SELECTION = \"fa-selection-16.png\";\n+\tpublic static final String ICON_FA_ZOOM_IN = \"fa-zoom-in-16.png\";\n+\tpublic static final String ICON_FA_ZOOM_OUT = \"fa-zoom-out-16.png\";\n+\tpublic static final String ICON_FA_ZOOM_PAN = \"fa-zoom-pan-16.png\";\n+\tpublic static final String ICON_FA_PLUS = \"fa-plus-16.png\";\n+\tpublic static final String ICON_FA_MINUS = \"fa-minus-16.png\";\n+\n@@ -275,0 +284,9 @@\n+\t\t\/\/ font awesome\n+\t\tregisterImage(registry, ICON_FA_SCALE_TO_FIT, ICON_FA_SCALE_TO_FIT);\n+\t\tregisterImage(registry, ICON_FA_SELECTION, ICON_FA_SELECTION);\n+\t\tregisterImage(registry, ICON_FA_ZOOM_IN, ICON_FA_ZOOM_IN);\n+\t\tregisterImage(registry, ICON_FA_ZOOM_OUT, ICON_FA_ZOOM_OUT);\n+\t\tregisterImage(registry, ICON_FA_ZOOM_PAN, ICON_FA_ZOOM_PAN);\n+\t\tregisterImage(registry, ICON_FA_PLUS, ICON_FA_PLUS);\n+\t\tregisterImage(registry, ICON_FA_MINUS, ICON_FA_MINUS);\n+\n","filename":"application\/org.openjdk.jmc.ui\/src\/main\/java\/org\/openjdk\/jmc\/ui\/UIPlugin.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -296,0 +296,6 @@\n+\t\tdrawAxis(ctx, range, axisPos, labelAhead, labelLimit, vertical, 0);\n+\t}\n+\n+\tpublic static void drawAxis(\n+\t\tGraphics2D ctx, SubdividedQuantityRange range, int axisPos, boolean labelAhead, int labelLimit,\n+\t\tboolean vertical, int xOffset) {\n@@ -308,1 +314,1 @@\n-\t\t\tctx.drawLine(0, axisPos, axisSize - 1, axisPos);\n+\t\t\tctx.drawLine(0 + xOffset, axisPos, axisSize + xOffset, axisPos);\n@@ -357,1 +363,1 @@\n-\t\t\t\t\tctx.drawLine(tickPos, axisPos - TICK_LINE, tickPos, axisPos + TICK_LINE);\n+\t\t\t\t\tctx.drawLine(tickPos + xOffset, axisPos - TICK_LINE, tickPos + xOffset, axisPos + TICK_LINE);\n@@ -364,1 +370,1 @@\n-\t\t\t\t\t\tctx.drawString(label, tickPos - textXadjust, labelYPos);\n+\t\t\t\t\t\tctx.drawString(label, tickPos - textXadjust + xOffset, labelYPos);\n","filename":"application\/org.openjdk.jmc.ui\/src\/main\/java\/org\/openjdk\/jmc\/ui\/charts\/AWTChartToolkit.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import java.util.Stack;\n@@ -51,0 +52,1 @@\n+import org.openjdk.jmc.common.unit.UnitLookup;\n@@ -52,0 +54,4 @@\n+import org.openjdk.jmc.ui.misc.ChartButtonGroup;\n+import org.openjdk.jmc.ui.misc.ChartControlBar;\n+import org.openjdk.jmc.ui.misc.TimelineCanvas;\n+import org.openjdk.jmc.ui.misc.PatternFly.Palette;\n@@ -57,2 +63,2 @@\n-\tprivate static final int Y_OFFSET = 35;\n-\tprivate static final int RANGE_INDICATOR_HEIGHT = 4;\n+\tprivate static final int BASE_ZOOM_LEVEL = 100;\n+\tprivate static final int RANGE_INDICATOR_HEIGHT = 7;\n@@ -61,0 +67,1 @@\n+\tprivate IQuantity rangeDuration;\n@@ -64,0 +71,1 @@\n+\tprivate int yOffset = 35;\n@@ -72,0 +80,2 @@\n+\tprivate int axisWidth;\n+\tprivate int rowColorCounter;\n@@ -76,1 +86,12 @@\n-\tprivate int axisWidth;\n+\n+\t\/\/ JFR Threads Page\n+\tprivate static final double ZOOM_PAN_FACTOR = 0.05;\n+\tprivate static final int ZOOM_PAN_MODIFIER = 2;\n+\tprivate double zoomPanPower = ZOOM_PAN_FACTOR \/ ZOOM_PAN_MODIFIER;\n+\tprivate double currentZoom;\n+\tprivate int zoomSteps;\n+\tprivate ChartButtonGroup buttonGroup;\n+\tprivate ChartControlBar controlBar;\n+\tprivate Stack<Integer> modifiedSteps;\n+\tprivate TimelineCanvas timelineCanvas;\n+\tprivate int longestCharWidth = 0;\n@@ -86,0 +107,13 @@\n+\t\/\/ JFR Threads Page\n+\tpublic XYChart(IRange<IQuantity> range, IXDataRenderer rendererRoot, int xOffset, Integer yOffset,\n+\t\t\tTimelineCanvas timelineCanvas, ChartControlBar controlBar, ChartButtonGroup buttonGroup) {\n+\t\tthis(range.getStart(), range.getEnd(), rendererRoot, xOffset);\n+\t\tthis.yOffset = yOffset;\n+\t\tthis.timelineCanvas = timelineCanvas;\n+\t\tthis.controlBar = controlBar;\n+\t\tthis.buttonGroup = buttonGroup;\n+\t\tthis.rangeDuration = range.getExtent();\n+\t\tthis.currentZoom = BASE_ZOOM_LEVEL;\n+\t\tthis.isZoomCalculated = false;\n+\t}\n+\n@@ -102,1 +136,1 @@\n-\t\tcurrentStart = start;\n+\t\tthis.currentStart = start;\n@@ -104,1 +138,1 @@\n-\t\tcurrentEnd = end;\n+\t\tthis.currentEnd = end;\n@@ -113,0 +147,1 @@\n+\t\tlongestCharWidth = 0;\n@@ -136,2 +171,2 @@\n-\tpublic void render(Graphics2D context, int width, int height) {\n-\t\tif (width > xOffset && height > Y_OFFSET) {\n+\tpublic void renderChart(Graphics2D context, int width, int height) {\n+\t\tif (width > xOffset && height > yOffset) {\n@@ -145,1 +180,1 @@\n-\t\t\tdoRender(context, height - Y_OFFSET);\n+\t\t\tdoRenderChart(context, height - yOffset);\n@@ -150,0 +185,17 @@\n+\tpublic void renderTextCanvasText(Graphics2D context, int width, int height) {\n+\t\tAffineTransform oldTransform = context.getTransform();\n+\t\taxisWidth = width - xOffset;\n+\t\tdoRenderTextCanvasText(context, height);\n+\t\tcontext.setTransform(oldTransform);\n+\t}\n+\n+\tpublic void renderText(Graphics2D context, int width, int height) {\n+\t\tif (width > xOffset && height > yOffset) {\n+\t\t\taxisWidth = xOffset;\n+\t\t\tAffineTransform oldTransform = context.getTransform();\n+\t\t\tdoRenderText(context);\n+\t\t\tcontext.setTransform(oldTransform);\n+\t\t\taxisWidth = width - xOffset;\n+\t\t}\n+\t}\n+\n@@ -155,1 +207,5 @@\n-\t\tif (x1 > 0 || x2 < axisWidth) {\n+\n+\t\tif (timelineCanvas != null) {\n+\t\t\ttimelineCanvas.renderRangeIndicator(x1, x2);\n+\t\t\tupdateZoomPanIndicator();\n+\t\t} else {\n@@ -163,1 +219,19 @@\n-\tprivate void doRender(Graphics2D context, int axisHeight) {\n+\tpublic void updateZoomPanIndicator() {\n+\t\tif (buttonGroup != null) {\n+\t\t\tbuttonGroup.updateZoomPanIndicator();\n+\t\t}\n+\t}\n+\n+\tprivate IRenderedRow getRendererResult(Graphics2D context, int axisHeight) {\n+\t\tif (xBucketRange == null) {\n+\t\t\txBucketRange = getXBucketRange();\n+\t\t}\n+\t\treturn rendererRoot.render(context, xBucketRange, axisHeight);\n+\t}\n+\n+\tprivate SubdividedQuantityRange getXBucketRange() {\n+\t\treturn new SubdividedQuantityRange(currentStart, currentEnd, axisWidth, bucketWidth);\n+\t}\n+\n+\tprivate void doRenderChart(Graphics2D context, int axisHeight) {\n+\t\trowColorCounter = 0;\n@@ -168,1 +242,5 @@\n-\t\tAWTChartToolkit.drawAxis(context, xTickRange, axisHeight - 1, false, 1 - xOffset, false);\n+\t\tif (timelineCanvas != null) {\n+\t\t\ttimelineCanvas.setXTickRange(xTickRange);\n+\t\t} else {\n+\t\t\tAWTChartToolkit.drawAxis(context, xTickRange, axisHeight - 1, false, 1 - xOffset, false);\n+\t\t}\n@@ -170,1 +248,1 @@\n-\t\trendererResult = rendererRoot.render(context, xBucketRange, axisHeight);\n+\t\trendererResult = getRendererResult(context, axisHeight);\n@@ -172,1 +250,1 @@\n-\t\trenderText(context, rendererResult);\n+\n@@ -175,1 +253,1 @@\n-\t\t\trenderSelection(context, rendererResult);\n+\t\t\trenderSelectionChart(context, rendererResult);\n@@ -184,1 +262,45 @@\n-\tprivate void renderSelection(Graphics2D context, IRenderedRow row) {\n+\tprivate void doRenderText(Graphics2D context) {\n+\t\tAffineTransform oldTransform = context.getTransform();\n+\t\trowColorCounter = -1;\n+\t\trenderText(context, rendererResult);\n+\t\tcontext.setTransform(oldTransform);\n+\t}\n+\n+\tprivate void doRenderTextCanvasText(Graphics2D context, int height) {\n+\t\tif (rendererResult == null) {\n+\t\t\trendererResult = getRendererResult(context, height - yOffset);\n+\t\t}\n+\t\tAffineTransform oldTransform = context.getTransform();\n+\t\trowColorCounter = 0;\n+\t\trenderText(context, rendererResult);\n+\t\tcontext.setTransform(oldTransform);\n+\t\tif (!selectedRows.isEmpty()) {\n+\t\t\trenderSelectionText(context, rendererResult);\n+\t\t\tcontext.setTransform(oldTransform);\n+\t\t}\n+\t}\n+\n+\tprivate void renderSelectionText(Graphics2D context, IRenderedRow row) {\n+\t\tif (selectedRows.contains(row.getPayload())) {\n+\t\t\tif (row.getHeight() != rendererResult.getHeight()) {\n+\t\t\t\tColor highlight = new Color(0, 206, 209, 20);\n+\t\t\t\tcontext.setColor(highlight);\n+\t\t\t\tcontext.fillRect(0, 0, axisWidth, row.getHeight());\n+\t\t\t} else {\n+\t\t\t\tselectedRows.clear();\n+\t\t\t}\n+\t\t} else {\n+\t\t\tList<IRenderedRow> subdivision = row.getNestedRows();\n+\t\t\tif (subdivision.isEmpty()) {\n+\t\t\t\tdimRect(context, 0, axisWidth, row.getHeight());\n+\t\t\t} else {\n+\t\t\t\tfor (IRenderedRow nestedRow : row.getNestedRows()) {\n+\t\t\t\t\trenderSelectionText(context, nestedRow);\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tcontext.translate(0, row.getHeight());\n+\t}\n+\n+\tprivate void renderSelectionChart(Graphics2D context, IRenderedRow row) {\n@@ -193,1 +315,1 @@\n-\t\t\t\t\trenderSelection(context, nestedRow);\n+\t\t\t\t\trenderSelectionChart(context, nestedRow);\n@@ -201,0 +323,14 @@\n+\t\/\/ Paint the background of every-other row in a slightly different shade\n+\t\/\/ to better differentiate the thread lanes from one another\n+\tprivate void paintRowBackground(Graphics2D context, int height) {\n+\t\tif (rowColorCounter >= 0) {\n+\t\t\tif (rowColorCounter % 2 == 0) {\n+\t\t\t\tcontext.setColor(Palette.PF_BLACK_100.getAWTColor());\n+\t\t\t} else {\n+\t\t\t\tcontext.setColor(Palette.PF_BLACK_200.getAWTColor());\n+\t\t\t}\n+\t\t\tcontext.fillRect(0, 0, axisWidth, height);\n+\t\t\trowColorCounter++;\n+\t\t}\n+\t}\n+\n@@ -206,0 +342,1 @@\n+\t\t\t\tpaintRowBackground(context, row.getHeight());\n@@ -207,8 +344,2 @@\n-\t\t\t\tint y;\n-\t\t\t\tif (height > 40) {\n-\t\t\t\t\tcontext.drawLine(-xOffset, height - 1, -15, height - 1);\n-\t\t\t\t\ty = height - context.getFontMetrics().getHeight() \/ 2;\n-\t\t\t\t} else {\n-\t\t\t\t\t\/\/ draw the string in the middle of the row\n-\t\t\t\t\ty = ((height - context.getFontMetrics().getHeight()) \/ 2) + context.getFontMetrics().getAscent();\n-\t\t\t\t}\n+\t\t\t\tcontext.drawLine(0, height - 1, axisWidth - 15, height - 1);\n+\t\t\t\tint y = ((height - context.getFontMetrics().getHeight()) \/ 2) + context.getFontMetrics().getAscent();\n@@ -216,1 +347,4 @@\n-\t\t\t\tif (charsWidth > xOffset) {\n+\t\t\t\tif (charsWidth > longestCharWidth) {\n+\t\t\t\t\tlongestCharWidth = charsWidth;\n+\t\t\t\t}\n+\t\t\t\tif (xOffset > 0 && charsWidth > xOffset) {\n@@ -221,1 +355,1 @@\n-\t\t\t\tcontext.drawString(text, -xOffset + 2, y);\n+\t\t\t\tcontext.drawString(text, 2, y);\n@@ -235,0 +369,9 @@\n+\t\/**\n+\t * Get the longest character width of a thread name to be rendered\n+\t * \n+\t * @return the character width of longest thread name\n+\t *\/\n+\tpublic int getLongestCharWidth() {\n+\t\treturn longestCharWidth;\n+\t}\n+\n@@ -242,0 +385,3 @@\n+\t\tif (rangeDuration != null) {\n+\t\t\treturn panRange(Integer.signum(rightPercent));\n+\t\t}\n@@ -262,0 +408,36 @@\n+\t\/**\n+\t * Pan the view at a rate relative the current zoom level.\n+\t * \n+\t * @param panDirection\n+\t *            -1 to pan left, 1 to pan right\n+\t * @return true if the chart needs to be redrawn\n+\t *\/\n+\tpublic boolean panRange(int panDirection) {\n+\t\tif (zoomSteps == 0 || panDirection == 0 || (currentStart.compareTo(start) == 0 && panDirection == -1)\n+\t\t\t\t|| (currentEnd.compareTo(end) == 0 && panDirection == 1)) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tIQuantity panDiff = rangeDuration.multiply(panDirection * zoomPanPower);\n+\t\tIQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).add(panDiff);\n+\t\tIQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).add(panDiff);\n+\n+\t\t\/\/ if panning would flow over the recording range start or end time,\n+\t\t\/\/ calculate the difference and add it so the other side.\n+\t\tif (newStart.compareTo(start) < 0) {\n+\t\t\tIQuantity diff = start.subtract(newStart);\n+\t\t\tnewStart = start;\n+\t\t\tnewEnd = newEnd.add(diff);\n+\t\t} else if (newEnd.compareTo(end) > 0) {\n+\t\t\tIQuantity diff = newEnd.subtract(end);\n+\t\t\tnewStart = newStart.add(diff);\n+\t\t\tnewEnd = end;\n+\t\t}\n+\t\tcurrentStart = newStart;\n+\t\tcurrentEnd = newEnd;\n+\t\tcontrolBar.setStartTime(currentStart);\n+\t\tcontrolBar.setEndTime(currentEnd);\n+\t\tisZoomCalculated = true;\n+\t\treturn true;\n+\t}\n+\n@@ -269,0 +451,3 @@\n+\t\tif (rangeDuration != null) {\n+\t\t\treturn zoomRange(zoomInSteps);\n+\t\t}\n@@ -283,0 +468,1 @@\n+\t\/\/ Default zoom mechanics\n@@ -302,0 +488,173 @@\n+\t\/**\n+\t * Zoom to a specific step count\n+\t * \n+\t * @param zoomToStep\n+\t *            the desired end zoom step amount\n+\t * @return true if a redraw is required as a result of a successful zoom\n+\t *\/\n+\tpublic boolean zoomToStep(int zoomToStep) {\n+\t\tif (zoomToStep == 0) {\n+\t\t\tresetTimeline();\n+\t\t\treturn true;\n+\t\t} else {\n+\t\t\treturn zoomRange(zoomToStep - zoomSteps);\n+\t\t}\n+\t}\n+\n+\t\/**\n+\t * Zoom based on a percentage of the recording range\n+\t * \n+\t * @param zoomInSteps\n+\t *            the amount of desired steps to take\n+\t * @return true if a redraw is required as a result of a successful zoom\n+\t *\/\n+\tprivate boolean zoomRange(int steps) {\n+\t\tif (steps == 0) {\n+\t\t\treturn false;\n+\t\t} else if (steps > 0) {\n+\t\t\tzoomIn(steps);\n+\t\t} else {\n+\t\t\tzoomOut(steps);\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\t\/**\n+\t * Zoom into the chart at a rate of 5% of the overall recording range at each step. If the chart\n+\t * is zoomed in far enough such that one more step at 5% is not possible, the zoom power is\n+\t * halved and the zoom will proceed. <br>\n+\t * Every time the zoom power is halved, the instigating step value is pushed onto the\n+\t * modifiedSteps stack. This stack is consulted on zoom out events in order to ensure the chart\n+\t * zooms out the same way it was zoomed in.\n+\t *\/\n+\tprivate void zoomIn(int steps) {\n+\t\tdo {\n+\t\t\tIQuantity zoomDiff = rangeDuration.multiply(zoomPanPower);\n+\t\t\tIQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).add(zoomDiff);\n+\t\t\tIQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);\n+\t\t\tif (newStart.compareTo(newEnd) >= 0) { \/\/ adjust the zoom factor\n+\t\t\t\tif (modifiedSteps == null) {\n+\t\t\t\t\tmodifiedSteps = new Stack<Integer>();\n+\t\t\t\t}\n+\t\t\t\tmodifiedSteps.push(zoomSteps);\n+\t\t\t\tzoomPanPower = zoomPanPower \/ ZOOM_PAN_MODIFIER;\n+\t\t\t\tzoomDiff = rangeDuration.multiply(zoomPanPower);\n+\t\t\t\tnewStart = currentStart.in(UnitLookup.EPOCH_NS).add(zoomDiff);\n+\t\t\t\tnewEnd = currentEnd.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);\n+\t\t\t}\n+\t\t\tcurrentZoom = currentZoom + (zoomPanPower * ZOOM_PAN_MODIFIER * 100);\n+\t\t\tisZoomCalculated = true;\n+\t\t\tzoomSteps++;\n+\t\t\tsetVisibleRange(newStart, newEnd);\n+\t\t\tsteps--;\n+\t\t} while (steps > 0);\n+\t}\n+\n+\t\/**\n+\t * Zoom out of the chart at a rate equal to the how the chart was zoomed in.\n+\t *\/\n+\tprivate void zoomOut(int steps) {\n+\t\tdo {\n+\t\t\tif (modifiedSteps != null && modifiedSteps.size() > 0 && modifiedSteps.peek() == zoomSteps) {\n+\t\t\t\tmodifiedSteps.pop();\n+\t\t\t\tzoomPanPower = zoomPanPower * ZOOM_PAN_MODIFIER;\n+\t\t\t}\n+\t\t\tIQuantity zoomDiff = rangeDuration.multiply(zoomPanPower);\n+\t\t\tIQuantity newStart = currentStart.in(UnitLookup.EPOCH_NS).subtract(zoomDiff);\n+\t\t\tIQuantity newEnd = currentEnd.in(UnitLookup.EPOCH_NS).add(zoomDiff);\n+\n+\t\t\t\/\/ if zooming out would flow over the recording range start or end time,\n+\t\t\t\/\/ calculate the difference and add it to the other side.\n+\t\t\tif (newStart.compareTo(start) < 0) {\n+\t\t\t\tIQuantity diff = start.subtract(newStart);\n+\t\t\t\tnewStart = start;\n+\t\t\t\tnewEnd = newEnd.add(diff);\n+\t\t\t} else if (newEnd.compareTo(end) > 0) {\n+\t\t\t\tIQuantity diff = newEnd.subtract(end);\n+\t\t\t\tnewStart = newStart.subtract(diff);\n+\t\t\t\tnewEnd = end;\n+\t\t\t}\n+\t\t\tcurrentZoom = currentZoom - (zoomPanPower * ZOOM_PAN_MODIFIER * 100);\n+\t\t\tif (currentZoom < BASE_ZOOM_LEVEL) {\n+\t\t\t\tcurrentZoom = BASE_ZOOM_LEVEL;\n+\t\t\t}\n+\t\t\tisZoomCalculated = true;\n+\t\t\tzoomSteps--;\n+\t\t\tsetVisibleRange(newStart, newEnd);\n+\t\t\tsteps++;\n+\t\t} while (steps < 0);\n+\t}\n+\n+\t\/\/ need to check from ChartAndPopupTableUI if not using the OG start\/end position,\n+\t\/\/ will have to calculate the new zoom level\n+\tpublic void resetZoomFactor() {\n+\t\tzoomSteps = 0;\n+\t\tzoomPanPower = ZOOM_PAN_FACTOR \/ ZOOM_PAN_MODIFIER;\n+\t\tcurrentZoom = BASE_ZOOM_LEVEL;\n+\t\tmodifiedSteps = new Stack<Integer>();\n+\t}\n+\n+\t\/**\n+\t * Reset the visible range to be the recording range, and reset the zoom-related objects\n+\t *\/\n+\tpublic void resetTimeline() {\n+\t\tresetZoomFactor();\n+\t\tsetVisibleRange(start, end);\n+\t}\n+\n+\tprivate void selectionZoom(IQuantity newStart, IQuantity newEnd) {\n+\t\tdouble percentage = calculateZoom(newStart, newEnd);\n+\t\tzoomSteps = calculateZoomSteps(percentage);\n+\t\tcurrentZoom = BASE_ZOOM_LEVEL + (percentage * 100);\n+\t}\n+\n+\t\/**\n+\t * When a drag-select zoom occurs, use the new range value to determine how many steps have been\n+\t * taken, and adjust zoomSteps and zoomPower accordingly\n+\t *\/\n+\tprivate double calculateZoom(IQuantity newStart, IQuantity newEnd) {\n+\t\t\/\/ calculate the new visible range, and it's percentage of the total range\n+\t\tIQuantity newRange = newEnd.in(UnitLookup.EPOCH_NS).subtract(newStart.in(UnitLookup.EPOCH_NS));\n+\t\treturn 1 - (newRange.longValue() \/ (double) rangeDuration.in(UnitLookup.NANOSECOND).longValue());\n+\t}\n+\n+\t\/**\n+\t * Calculate the number of steps required to achieve the passed zoom percentage\n+\t *\/\n+\tprivate int calculateZoomSteps(double percentage) {\n+\t\tint steps = (int) Math.floor(percentage \/ ZOOM_PAN_FACTOR);\n+\t\tdouble tempPercent = steps * ZOOM_PAN_FACTOR;\n+\n+\t\tif (tempPercent < percentage) {\n+\t\t\tif (percentage > 1 - ZOOM_PAN_FACTOR) {\n+\t\t\t\tdouble factor = ZOOM_PAN_FACTOR;\n+\t\t\t\tdo {\n+\t\t\t\t\tfactor = factor \/ ZOOM_PAN_MODIFIER;\n+\t\t\t\t\ttempPercent = tempPercent + factor;\n+\t\t\t\t\tif (modifiedSteps == null) {\n+\t\t\t\t\t\tmodifiedSteps = new Stack<Integer>();\n+\t\t\t\t\t}\n+\t\t\t\t\tif (modifiedSteps.size() == 0 || modifiedSteps.peek() < steps) {\n+\t\t\t\t\t\tmodifiedSteps.push(steps);\n+\t\t\t\t\t}\n+\t\t\t\t\tsteps++;\n+\t\t\t\t} while (tempPercent <= percentage);\n+\t\t\t\tzoomPanPower = factor \/ ZOOM_PAN_MODIFIER;\n+\t\t\t} else {\n+\t\t\t\tsteps++;\n+\t\t\t}\n+\t\t}\n+\t\treturn steps;\n+\t}\n+\n+\tprivate boolean isZoomCalculated;\n+\tprivate boolean isZoomPanDrag;\n+\n+\tpublic void setIsZoomPanDrag(boolean isZoomPanDrag) {\n+\t\tthis.isZoomPanDrag = isZoomPanDrag;\n+\t}\n+\n+\tprivate boolean getIsZoomPanDrag() {\n+\t\treturn isZoomPanDrag;\n+\t}\n+\n@@ -303,0 +662,4 @@\n+\t\tif (rangeDuration != null && !isZoomCalculated && !getIsZoomPanDrag()) {\n+\t\t\tselectionZoom(rangeStart, rangeEnd);\n+\t\t}\n+\t\tisZoomCalculated = false;\n@@ -315,0 +678,4 @@\n+\t\t\tif (controlBar != null) {\n+\t\t\t\tcontrolBar.setStartTime(currentStart);\n+\t\t\t\tcontrolBar.setEndTime(currentEnd);\n+\t\t\t}\n@@ -335,3 +702,3 @@\n-\tpublic boolean select(int x1, int x2, int y1, int y2) {\n-\t\tint xStart = Math.min(x1, x2) - xOffset;\n-\t\tint xEnd = Math.max(x1, x2) - xOffset;\n+\tpublic boolean select(int x1, int x2, int y1, int y2, boolean clear) {\n+\t\tint xStart = Math.min(x1, x2);\n+\t\tint xEnd = Math.max(x1, x2);\n@@ -339,3 +706,3 @@\n-\t\tif (xBucketRange != null && (xEnd >= 0)) {\n-\t\t\treturn select(xBucketRange.getQuantityAtPixel(Math.max(0, xStart)), xBucketRange.getQuantityAtPixel(xEnd),\n-\t\t\t\t\ty1, y2);\n+\t\tif (xBucketRange != null && (xEnd != xStart) && xEnd - xOffset >= 0) {\n+\t\t\treturn select(xBucketRange.getQuantityAtPixel(Math.max(0, xStart - xOffset)),\n+\t\t\t\t\txBucketRange.getQuantityAtPixel(xEnd - xOffset), y1, y2, clear);\n@@ -343,1 +710,1 @@\n-\t\t\treturn select(null, null, y1, y2);\n+\t\t\treturn select(null, null, y1, y2, clear);\n@@ -347,1 +714,1 @@\n-\tpublic boolean select(IQuantity xStart, IQuantity xEnd, int y1, int y2) {\n+\tpublic boolean select(IQuantity xStart, IQuantity xEnd, int y1, int y2, boolean clear) {\n@@ -358,1 +725,3 @@\n-\t\tselectedRows.clear();\n+\t\tif (clear) {\n+\t\t\tselectedRows.clear();\n+\t\t}\n@@ -396,1 +765,5 @@\n-\t\t\tselectedRows.add(payload);\n+\t\t\tif (selectedRows.contains(payload)) { \/\/ ctrl+click deselection\n+\t\t\t\tselectedRows.remove(payload);\n+\t\t\t} else {\n+\t\t\t\tselectedRows.add(payload);\n+\t\t\t}\n","filename":"application\/org.openjdk.jmc.ui\/src\/main\/java\/org\/openjdk\/jmc\/ui\/charts\/XYChart.java","additions":410,"deletions":37,"binary":false,"changes":447,"status":"modified"},{"patch":"@@ -0,0 +1,531 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.ui.misc;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.eclipse.swt.SWT;\n+import org.eclipse.swt.custom.ScrolledComposite;\n+import org.eclipse.swt.events.MouseAdapter;\n+import org.eclipse.swt.events.MouseEvent;\n+import org.eclipse.swt.events.MouseMoveListener;\n+import org.eclipse.swt.events.MouseWheelListener;\n+import org.eclipse.swt.events.PaintEvent;\n+import org.eclipse.swt.events.PaintListener;\n+import org.eclipse.swt.graphics.Cursor;\n+import org.eclipse.swt.graphics.GC;\n+import org.eclipse.swt.graphics.Point;\n+import org.eclipse.swt.graphics.Rectangle;\n+import org.eclipse.swt.layout.GridData;\n+import org.eclipse.swt.layout.GridLayout;\n+import org.eclipse.swt.widgets.Button;\n+import org.eclipse.swt.widgets.Canvas;\n+import org.eclipse.swt.widgets.Composite;\n+import org.eclipse.swt.widgets.Event;\n+import org.eclipse.swt.widgets.Listener;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.IRange;\n+import org.openjdk.jmc.ui.UIPlugin;\n+import org.openjdk.jmc.ui.charts.SubdividedQuantityRange;\n+import org.openjdk.jmc.ui.charts.XYChart;\n+import org.openjdk.jmc.ui.misc.PatternFly.Palette;\n+\n+public class ChartButtonGroup extends Composite {\n+\tprivate static final String DEFAULT_CURSOR = \"defaultCursor\";\n+\tprivate static final String HAND_CURSOR = \"handCursor\";\n+\tprivate static final String ZOOM_IN_CURSOR = \"zoomInCursor\";\n+\tprivate static final String ZOOM_OUT_CURSOR = \"zoomOutCursor\";\n+\tprivate static final int ZOOM_INCREMENT = 1;\n+\tprivate List<Button> buttonGroup;\n+\tprivate Map<String, Cursor> cursors;\n+\tprivate Button scaleToFitBtn;\n+\tprivate Button selectionBtn;\n+\tprivate Button zoomInBtn;\n+\tprivate Button zoomOutBtn;\n+\tprivate Button zoomPanBtn;\n+\tprivate ChartCanvas chartCanvas;\n+\tprivate ChartTextCanvas textCanvas;\n+\tprivate Runnable resetLaneHeightAction;\n+\tprivate XYChart chart;\n+\tprivate ZoomPan zoomPan;\n+\n+\tpublic ChartButtonGroup(Composite parent) {\n+\t\tsuper(parent, SWT.NONE);\n+\t\tGridLayout gl = new GridLayout(5, true);\n+\t\tgl.horizontalSpacing = 0;\n+\t\tgl.marginWidth = 0;\n+\t\tthis.setLayout(gl);\n+\t\tthis.setLayoutData(new GridData(SWT.FILL, SWT.FILL, false, false));\n+\n+\t\tcursors = new HashMap<>();\n+\t\tinitCursorMap();\n+\n+\t\tbuttonGroup = new ArrayList<>();\n+\t\tinitSelectionButton();\n+\t\tinitZoomInButton();\n+\t\tinitZoomOutButton();\n+\t\tinitZoomPanButton();\n+\t\tinitScaleToFitButton();\n+\t}\n+\n+\tprivate void initCursorMap() {\n+\t\tcursors.put(DEFAULT_CURSOR, getDisplay().getSystemCursor(SWT.CURSOR_ARROW));\n+\t\tcursors.put(HAND_CURSOR, getDisplay().getSystemCursor(SWT.CURSOR_HAND));\n+\t\tcursors.put(ZOOM_IN_CURSOR, new Cursor(getDisplay(),\n+\t\t\t\tUIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_IN).getImageData(), 0, 0));\n+\t\tcursors.put(ZOOM_OUT_CURSOR, new Cursor(getDisplay(),\n+\t\t\t\tUIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_OUT).getImageData(), 0, 0));\n+\t}\n+\n+\tprivate void initSelectionButton() {\n+\t\tselectionBtn = new Button(this, SWT.TOGGLE);\n+\t\tselectionBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));\n+\t\tselectionBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_SELECTION));\n+\t\tselectionBtn.setSelection(true);\n+\t\tselectionBtn.setToolTipText(Messages.ChartDisplayControlBar_SELECTION_TOOL_TOOLTIP);\n+\t\tselectionBtn.addListener(SWT.Selection, new Listener() {\n+\t\t\t@Override\n+\t\t\tpublic void handleEvent(Event event) {\n+\t\t\t\tsetButtonSelectionStates(selectionBtn, null);\n+\t\t\t\tchangeCursor(DEFAULT_CURSOR);\n+\t\t\t};\n+\t\t});\n+\t\tbuttonGroup.add(selectionBtn);\n+\t}\n+\n+\tprivate void initZoomInButton() {\n+\t\tzoomInBtn = new Button(this, SWT.TOGGLE);\n+\t\tzoomInBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));\n+\t\tzoomInBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_IN));\n+\t\tzoomInBtn.setSelection(false);\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\tsb.append(Messages.ChartDisplayControlBar_ZOOM_IN_CLICK_TOOLTIP);\n+\t\tsb.append(System.getProperty(\"line.separator\"));\n+\t\tsb.append(Messages.ChartDisplayControlBar_ZOOM_IN_HOLD_TOOLTIP);\n+\t\tzoomInBtn.setToolTipText(sb.toString());\n+\t\tzoomInBtn.addListener(SWT.Selection, new Listener() {\n+\t\t\t@Override\n+\t\t\tpublic void handleEvent(Event event) {\n+\t\t\t\tsetButtonSelectionStates(zoomInBtn, zoomPanBtn);\n+\t\t\t\tchangeCursor(ZOOM_IN_CURSOR);\n+\t\t\t}\n+\t\t});\n+\t\tzoomInBtn.addMouseListener(new LongPressListener(ZOOM_INCREMENT));\n+\t\tbuttonGroup.add(zoomInBtn);\n+\t}\n+\n+\tprivate void initZoomOutButton() {\n+\t\tzoomOutBtn = new Button(this, SWT.TOGGLE);\n+\t\tzoomOutBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));\n+\t\tzoomOutBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_OUT));\n+\t\tzoomOutBtn.setSelection(false);\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\tsb.append(Messages.ChartDisplayControlBar_ZOOM_OUT_CLICK_TOOLTIP);\n+\t\tsb.append(System.getProperty(\"line.separator\"));\n+\t\tsb.append(Messages.ChartDisplayControlBar_ZOOM_OUT_HOLD_TOOLTIP);\n+\t\tzoomOutBtn.setToolTipText(sb.toString());\n+\t\tzoomOutBtn.addListener(SWT.Selection, new Listener() {\n+\t\t\t@Override\n+\t\t\tpublic void handleEvent(Event e) {\n+\t\t\t\tsetButtonSelectionStates(zoomOutBtn, zoomPanBtn);\n+\t\t\t\tchangeCursor(ZOOM_OUT_CURSOR);\n+\t\t\t}\n+\t\t});\n+\t\tzoomOutBtn.addMouseListener(new LongPressListener(-ZOOM_INCREMENT));\n+\t\tbuttonGroup.add(zoomOutBtn);\n+\t}\n+\n+\tprivate void initZoomPanButton() {\n+\t\tzoomPanBtn = new Button(this, SWT.TOGGLE);\n+\t\tzoomPanBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));\n+\t\tzoomPanBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_PAN));\n+\t\tzoomPanBtn.setSelection(false);\n+\t\tzoomPanBtn.setToolTipText(Messages.ChartDisplayControlBar_ZOOM_PAN_TOOLTIP);\n+\t\tzoomPanBtn.addListener(SWT.Selection, new Listener() {\n+\t\t\t@Override\n+\t\t\tpublic void handleEvent(Event event) {\n+\t\t\t\tshowZoomPanDisplay(zoomPanBtn.getSelection());\n+\t\t\t}\n+\t\t});\n+\t\tbuttonGroup.add(zoomPanBtn);\n+\t}\n+\n+\tprivate void initScaleToFitButton() {\n+\t\tscaleToFitBtn = new Button(this, SWT.PUSH);\n+\t\tscaleToFitBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));\n+\t\tscaleToFitBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_SCALE_TO_FIT));\n+\t\tscaleToFitBtn.setSelection(false);\n+\t\tscaleToFitBtn.setToolTipText(Messages.ChartDisplayControlBar_SCALE_TO_FIT_TOOLTIP);\n+\t\tscaleToFitBtn.addListener(SWT.Selection, new Listener() {\n+\t\t\t@Override\n+\t\t\tpublic void handleEvent(Event event) {\n+\t\t\t\tchart.resetTimeline();\n+\t\t\t\tchartCanvas.redrawChart();\n+\t\t\t\tgetDisplay().syncExec(resetLaneHeightAction);\n+\t\t\t}\n+\t\t});\n+\t\tbuttonGroup.add(scaleToFitBtn);\n+\t}\n+\n+\tvoid setChart(XYChart chart) {\n+\t\tthis.chart = chart;\n+\t}\n+\n+\tvoid setResetLaneHeightAction(Runnable resetLaneHeightAction) {\n+\t\tthis.resetLaneHeightAction = resetLaneHeightAction;\n+\t}\n+\n+\tvoid setChartCanvas(ChartCanvas chartCanvas) {\n+\t\tthis.chartCanvas = chartCanvas;\n+\t}\n+\n+\tvoid setTextCanvas(ChartTextCanvas textCanvas) {\n+\t\tthis.textCanvas = textCanvas;\n+\t}\n+\n+\tpublic void updateZoomPanIndicator() {\n+\t\tzoomPan.redraw();\n+\t}\n+\n+\tpublic void zoomOnClick(Boolean mouseDown) {\n+\t\tboolean shouldZoom = zoomInBtn.getSelection() || zoomOutBtn.getSelection();\n+\t\tif (shouldZoom) {\n+\t\t\tif (mouseDown) {\n+\t\t\t\tchart.clearSelection();\n+\t\t\t} else {\n+\t\t\t\tint zoomAmount = zoomInBtn.getSelection() ? ZOOM_INCREMENT : -ZOOM_INCREMENT;\n+\t\t\t\tzoom(zoomAmount);\n+\t\t\t\tif (textCanvas != null) {\n+\t\t\t\t\ttextCanvas.redrawChartText();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic void zoomToSelection() {\n+\t\tif (zoomInBtn.getSelection()) {\n+\t\t\tIQuantity selectionStart = chart.getSelectionStart();\n+\t\t\tIQuantity selectionEnd = chart.getSelectionEnd();\n+\t\t\tif (selectionStart == null || selectionEnd == null) {\n+\t\t\t\tchart.clearVisibleRange();\n+\t\t\t} else {\n+\t\t\t\tchart.setVisibleRange(selectionStart, selectionEnd);\n+\t\t\t\tchartCanvas.redrawChart();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void changeCursor(String cursorName) {\n+\t\tchartCanvas.changeCursor(cursors.get(cursorName));\n+\t}\n+\n+\tprivate void setButtonSelectionStates(Button buttonSelected, Button dependentButton) {\n+\t\tfor (Button button : buttonGroup) {\n+\t\t\tif ((button.getStyle() & SWT.TOGGLE) != 0) {\n+\t\t\t\tif (button.equals(buttonSelected)) {\n+\t\t\t\t\tbutton.setSelection(true);\n+\t\t\t\t} else if (dependentButton != null) {\n+\t\t\t\t\tif (button.equals(dependentButton)) {\n+\t\t\t\t\t\tbutton.setSelection(true);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tbutton.setSelection(false);\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tbutton.setSelection(false);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tshowZoomPanDisplay(zoomPanBtn.getSelection());\n+\t\t}\n+\t}\n+\n+\tprivate class LongPressListener extends MouseAdapter {\n+\n+\t\tprivate static final long LONG_PRESS_TIME = 500;\n+\t\tprivate Timer timer;\n+\t\tprivate int zoomAmount;\n+\n+\t\tLongPressListener(int zoomAmount) {\n+\t\t\tthis.zoomAmount = zoomAmount;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void mouseDown(MouseEvent e) {\n+\t\t\tif (e.button == 1) {\n+\t\t\t\ttimer = new Timer();\n+\t\t\t\ttimer.schedule(new LongPress(), LONG_PRESS_TIME, (long) (LONG_PRESS_TIME * 1.5));\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void mouseUp(MouseEvent e) {\n+\t\t\ttimer.cancel();\n+\t\t}\n+\n+\t\tpublic class LongPress extends TimerTask {\n+\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\tdoZoomInOut(zoomAmount);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate void doZoomInOut(int zoomAmount) {\n+\t\t\tDisplayToolkit.inDisplayThread().execute(() -> zoom(zoomAmount));\n+\t\t}\n+\t}\n+\n+\tprivate void zoom(int zoomAmount) {\n+\t\tchart.zoom(zoomAmount);\n+\t\tchartCanvas.redrawChart();\n+\t}\n+\n+\tpublic void createZoomPan(Composite parent) {\n+\t\tzoomPan = new ZoomPan(parent);\n+\t\tparent.setVisible(false);\n+\t}\n+\n+\tprivate void showZoomPanDisplay(boolean show) {\n+\t\tif (show) {\n+\t\t\tzoomPan.getParent().setVisible(true);\n+\t\t\tzoomPan.redrawZoomPan();\n+\t\t} else {\n+\t\t\tzoomPan.getParent().setVisible(false);\n+\t\t}\n+\t}\n+\n+\tprivate class ZoomPan extends Canvas {\n+\t\tprivate static final int BORDER_PADDING = 2;\n+\t\tprivate static final double MIN_HEIGHT_PERCENT = 0.15;\n+\t\tprivate static final double MIN_WIDTH_PERCENT = 0.08;\n+\t\tprivate IRange<IQuantity> chartRange;\n+\t\tprivate IRange<IQuantity> lastChartZoomedRange;\n+\t\tprivate Rectangle zoomRect;\n+\n+\t\tpublic ZoomPan(Composite parent) {\n+\t\t\tsuper(parent, SWT.NO_BACKGROUND);\n+\t\t\taddPaintListener(new Painter());\n+\t\t\tPanDetector panDetector = new PanDetector();\n+\t\t\taddMouseListener(panDetector);\n+\t\t\taddMouseMoveListener(panDetector);\n+\t\t\taddMouseWheelListener(panDetector);\n+\t\t\tchartRange = chart.getVisibleRange();\n+\t\t}\n+\n+\t\tpublic void redrawZoomPan() {\n+\t\t\tredraw();\n+\t\t}\n+\n+\t\tprivate class PanDetector extends MouseAdapter implements MouseMoveListener, MouseWheelListener {\n+\t\t\tPoint currentSelection;\n+\t\t\tPoint lastSelection;\n+\t\t\tboolean isPan = false;\n+\n+\t\t\t@Override\n+\t\t\tpublic void mouseDown(MouseEvent e) {\n+\t\t\t\tif (e.button == 1 && inBounds(e)) {\n+\t\t\t\t\tisPan = true;\n+\t\t\t\t\tchart.setIsZoomPanDrag(isPan);\n+\t\t\t\t\tcurrentSelection = chartCanvas.translateDisplayToImageCoordinates(e.x, e.y);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tprivate boolean inBounds(MouseEvent e) {\n+\t\t\t\tPoint zoomCanvasBounds = getParent().getSize();\n+\t\t\t\tif (zoomRect.height < MIN_HEIGHT_PERCENT * zoomCanvasBounds.y\n+\t\t\t\t\t\t|| zoomRect.width < MIN_WIDTH_PERCENT * zoomCanvasBounds.x) {\n+\t\t\t\t\treturn zoomCanvasBounds.x >= e.x && zoomCanvasBounds.y >= e.y;\n+\t\t\t\t} else {\n+\t\t\t\t\treturn zoomRect.contains(e.x, e.y);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void mouseUp(MouseEvent e) {\n+\t\t\t\tisPan = false;\n+\t\t\t\tchart.setIsZoomPanDrag(isPan);\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void mouseMove(MouseEvent e) {\n+\t\t\t\tzoomPan.setCursor(cursors.get(HAND_CURSOR));\n+\t\t\t\tif (isPan && getParent().getSize().x >= e.x && getParent().getSize().y >= e.y) {\n+\t\t\t\t\tlastSelection = currentSelection;\n+\t\t\t\t\tcurrentSelection = chartCanvas.translateDisplayToImageCoordinates(e.x, e.y);\n+\t\t\t\t\tint xdiff = currentSelection.x - lastSelection.x;\n+\t\t\t\t\tint ydiff = currentSelection.y - lastSelection.y;\n+\t\t\t\t\tupdateZoomRectFromPan(xdiff, ydiff);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void mouseScrolled(MouseEvent e) {\n+\t\t\t\tupdateZoomRectFromPan(0, -e.count);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate void updateZoomRectFromPan(int xdiff, int ydiff) {\n+\t\t\tPoint bounds = getParent().getSize();\n+\t\t\tboolean xModified = false;\n+\t\t\tboolean yModified = false;\n+\n+\t\t\tint xOld = zoomRect.x;\n+\t\t\tzoomRect.x += xdiff;\n+\t\t\tif (zoomRect.x > (bounds.x - zoomRect.width - BORDER_PADDING - 1)) {\n+\t\t\t\tzoomRect.x = bounds.x - zoomRect.width - BORDER_PADDING - 1;\n+\t\t\t} else if (zoomRect.x < BORDER_PADDING) {\n+\t\t\t\tzoomRect.x = BORDER_PADDING;\n+\t\t\t}\n+\t\t\txModified = xOld != zoomRect.x;\n+\n+\t\t\tint yOld = zoomRect.y;\n+\t\t\tzoomRect.y += ydiff;\n+\t\t\tif (zoomRect.y < BORDER_PADDING) {\n+\t\t\t\tzoomRect.y = BORDER_PADDING;\n+\t\t\t} else if (zoomRect.y > (bounds.y - zoomRect.height - BORDER_PADDING - 1)) {\n+\t\t\t\tzoomRect.y = bounds.y - zoomRect.height - BORDER_PADDING - 1;\n+\t\t\t}\n+\t\t\tyModified = yOld != zoomRect.y;\n+\n+\t\t\tif (xModified || yModified) {\n+\t\t\t\tupdateChartFromZoomRect(xModified, yModified);\n+\t\t\t\tchartCanvas.redrawChart();\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate void updateChartFromZoomRect(boolean updateXRange, boolean updateYRange) {\n+\t\t\tRectangle zoomCanvasBounds = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);\n+\t\t\tRectangle totalBounds = chartCanvas.getBounds();\n+\n+\t\t\tif (updateXRange) {\n+\t\t\t\tdouble ratio = getVisibilityRatio(zoomRect.x - BORDER_PADDING, zoomCanvasBounds.x,\n+\t\t\t\t\t\tzoomCanvasBounds.width - BORDER_PADDING);\n+\t\t\t\tint start = getPixelLocation(ratio, totalBounds.width, 0);\n+\n+\t\t\t\tratio = getVisibilityRatio(zoomRect.x + zoomRect.width + BORDER_PADDING + 1, zoomCanvasBounds.width,\n+\t\t\t\t\t\tzoomCanvasBounds.width - BORDER_PADDING);\n+\t\t\t\tint end = getPixelLocation(ratio, totalBounds.width, totalBounds.width);\n+\n+\t\t\t\tSubdividedQuantityRange xAxis = new SubdividedQuantityRange(chartRange.getStart(), chartRange.getEnd(),\n+\t\t\t\t\t\ttotalBounds.width, 1);\n+\t\t\t\tchart.setVisibleRange(xAxis.getQuantityAtPixel(start), xAxis.getQuantityAtPixel(end));\n+\t\t\t\tlastChartZoomedRange = chart.getVisibleRange();\n+\t\t\t}\n+\t\t\tif (updateYRange) {\n+\t\t\t\tdouble ratio = getVisibilityRatio(zoomRect.y - BORDER_PADDING, 0,\n+\t\t\t\t\t\tzoomCanvasBounds.height - BORDER_PADDING);\n+\t\t\t\tint top = getPixelLocation(ratio, totalBounds.height, 0);\n+\n+\t\t\t\tPoint p = ((ScrolledComposite) chartCanvas.getParent()).getOrigin();\n+\t\t\t\tp.y = top;\n+\n+\t\t\t\tif (textCanvas != null) {\n+\t\t\t\t\ttextCanvas.syncScroll(p);\n+\t\t\t\t}\n+\t\t\t\tchartCanvas.syncScroll(p);\n+\t\t\t}\n+\t\t}\n+\n+\t\tclass Painter implements PaintListener {\n+\t\t\t@Override\n+\t\t\tpublic void paintControl(PaintEvent e) {\n+\n+\t\t\t\tRectangle backgroundRect = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);\n+\t\t\t\tGC gc = e.gc;\n+\n+\t\t\t\tgc.setBackground(Palette.PF_BLACK_400.getSWTColor());\n+\t\t\t\tgc.fillRectangle(backgroundRect);\n+\t\t\t\tgc.setForeground(Palette.PF_BLACK_900.getSWTColor());\n+\t\t\t\tgc.drawRectangle(0, 0, backgroundRect.width - 1, backgroundRect.height - 1);\n+\n+\t\t\t\tupdateZoomRectFromChart();\n+\n+\t\t\t\tgc.setBackground(Palette.PF_BLACK_100.getSWTColor());\n+\t\t\t\tgc.fillRectangle(zoomRect);\n+\t\t\t\tgc.setForeground(Palette.PF_BLACK_900.getSWTColor());\n+\t\t\t\tgc.drawRectangle(zoomRect);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate void updateZoomRectFromChart() {\n+\t\t\tRectangle zoomCanvasBounds = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);\n+\t\t\tIRange<IQuantity> zoomedRange = chart.getVisibleRange();\n+\t\t\tIQuantity visibleWidth = chartRange.getExtent();\n+\t\t\tdouble visibleHeight = chartCanvas.getParent().getBounds().height;\n+\t\t\tRectangle totalBounds = chartCanvas.getBounds();\n+\n+\t\t\tif (zoomRect == null) {\n+\t\t\t\tzoomRect = new Rectangle(0, 0, 0, 0);\n+\t\t\t}\n+\t\t\tif (!chart.getVisibleRange().equals(lastChartZoomedRange)) {\n+\t\t\t\tdouble ratio = getVisibilityRatio(zoomedRange.getStart(), chartRange.getStart(), visibleWidth);\n+\t\t\t\tint start = getPixelLocation(ratio, zoomCanvasBounds.width, 0);\n+\n+\t\t\t\tratio = getVisibilityRatio(zoomedRange.getEnd(), chartRange.getEnd(), visibleWidth);\n+\t\t\t\tint end = getPixelLocation(ratio, zoomCanvasBounds.width, zoomCanvasBounds.width);\n+\n+\t\t\t\tzoomRect.x = start + BORDER_PADDING;\n+\t\t\t\tzoomRect.width = end - start - 2 * BORDER_PADDING - 1;\n+\t\t\t\tlastChartZoomedRange = chart.getVisibleRange();\n+\t\t\t}\n+\t\t\tdouble ratio = getVisibilityRatio(0, totalBounds.y, totalBounds.height);\n+\t\t\tint top = getPixelLocation(ratio, zoomCanvasBounds.height, 0);\n+\n+\t\t\tratio = getVisibilityRatio(visibleHeight, totalBounds.height + totalBounds.y, totalBounds.height);\n+\t\t\tint bottom = getPixelLocation(ratio, zoomCanvasBounds.height, zoomCanvasBounds.height);\n+\n+\t\t\tzoomRect.y = top + BORDER_PADDING;\n+\t\t\tzoomRect.height = bottom - top - 2 * BORDER_PADDING - 1;\n+\n+\t\t}\n+\n+\t\tprivate double getVisibilityRatio(double visibleBound, double borderBound, double totalLength) {\n+\t\t\tdouble diff = visibleBound - borderBound;\n+\t\t\treturn diff \/ totalLength;\n+\t\t}\n+\n+\t\tprivate double getVisibilityRatio(IQuantity visibleBound, IQuantity borderBound, IQuantity totalLength) {\n+\t\t\tIQuantity diff = visibleBound.subtract(borderBound);\n+\t\t\treturn diff.ratioTo(totalLength);\n+\t\t}\n+\n+\t\tprivate int getPixelLocation(double visiblityRatio, int totalLength, int offset) {\n+\t\t\treturn offset + (int) (visiblityRatio * totalLength);\n+\t\t}\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.ui\/src\/main\/java\/org\/openjdk\/jmc\/ui\/misc\/ChartButtonGroup.java","additions":531,"deletions":0,"binary":false,"changes":531,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.awt.Color;\n@@ -41,0 +40,1 @@\n+import java.util.function.Consumer;\n@@ -46,0 +46,1 @@\n+import org.eclipse.swt.custom.ScrolledComposite;\n@@ -56,0 +57,1 @@\n+import org.eclipse.swt.graphics.Cursor;\n@@ -75,0 +77,1 @@\n+import org.openjdk.jmc.ui.misc.PatternFly.Palette;\n@@ -77,0 +80,5 @@\n+\tprivate int laneHeight;\n+\tprivate int minLaneHeight = -1;\n+\tprivate int minReadableLaneHeight;\n+\tprivate int savedLaneHeight;\n+\tprivate int numItems = 0;\n@@ -86,0 +94,3 @@\n+\t\tPoint highlightSelectionStart;\n+\t\tPoint highlightSelectionEnd;\n+\t\tPoint lastSelection;\n@@ -106,1 +117,2 @@\n-\t\t\tif ((e.button == 1) && ((e.stateMask & SWT.MOD4) == 0)) {\n+\t\t\tif ((e.button == 1) && ((e.stateMask & SWT.MOD4) == 0) && ((e.stateMask & SWT.CTRL) == 0)\n+\t\t\t\t\t&& ((e.stateMask & SWT.SHIFT) == 0)) {\n@@ -109,0 +121,2 @@\n+\t\t\t\thighlightSelectionEnd = new Point(-1, -1);\n+\t\t\t\tlastSelection = new Point(-1, -1);\n@@ -111,0 +125,34 @@\n+\t\t\t} else if (((e.stateMask & SWT.CTRL) != 0) && (e.button == 1)) {\n+\t\t\t\tselect(e.x, e.x, e.y, e.y, false);\n+\t\t\t\tif (selectionListener != null) {\n+\t\t\t\t\tselectionListener.run();\n+\t\t\t\t}\n+\t\t\t} else if (((e.stateMask & SWT.SHIFT) != 0) && (e.button == 1)) {\n+\t\t\t\tif (highlightSelectionEnd.y == -1) {\n+\t\t\t\t\thighlightSelectionEnd = new Point(e.x, e.y);\n+\t\t\t\t\tlastSelection = highlightSelectionEnd;\n+\t\t\t\t\tif (highlightSelectionStart.y > highlightSelectionEnd.y) {\n+\t\t\t\t\t\tPoint temp = highlightSelectionStart;\n+\t\t\t\t\t\thighlightSelectionStart = highlightSelectionEnd;\n+\t\t\t\t\t\thighlightSelectionEnd = temp;\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tif (e.y > highlightSelectionStart.y && e.y < highlightSelectionEnd.y) {\n+\t\t\t\t\t\tif (e.y < lastSelection.y) {\n+\t\t\t\t\t\t\thighlightSelectionEnd = new Point(e.x, e.y);\n+\t\t\t\t\t\t} else if (e.y > lastSelection.y) {\n+\t\t\t\t\t\t\thighlightSelectionStart = new Point(e.x, e.y);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (e.y < highlightSelectionStart.y) {\n+\t\t\t\t\t\thighlightSelectionStart = new Point(e.x, e.y);\n+\t\t\t\t\t\tlastSelection = highlightSelectionStart;\n+\t\t\t\t\t} else if (e.y > highlightSelectionEnd.y) {\n+\t\t\t\t\t\thighlightSelectionEnd = new Point(e.x, e.y);\n+\t\t\t\t\t\tlastSelection = highlightSelectionEnd;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tselect(highlightSelectionStart.x, highlightSelectionEnd.x, highlightSelectionStart.y,\n+\t\t\t\t\t\thighlightSelectionEnd.y, true);\n+\t\t\t\tif (selectionListener != null) {\n+\t\t\t\t\tselectionListener.run();\n+\t\t\t\t}\n@@ -134,1 +182,1 @@\n-\t\t\t\t\t\t(int) (y \/ yScale));\n+\t\t\t\t\t\t(int) (y \/ yScale), true);\n@@ -142,0 +190,1 @@\n+\t\t\t\thighlightSelectionStart = new Point(selectionStartX, selectionStartY);\n@@ -144,0 +193,3 @@\n+\t\t\t\tif (selectionIsClick) {\n+\t\t\t\t\tnotifyZoomOnClickListener(e.button);\n+\t\t\t\t}\n@@ -146,0 +198,3 @@\n+\t\t\t\t\tif (zoomToSelectionListener != null && !selectionIsClick) {\n+\t\t\t\t\t\tzoomToSelectionListener.run();\n+\t\t\t\t\t}\n@@ -171,1 +226,13 @@\n-\t\t\tRectangle rect = getClientArea();\n+\t\t\tRectangle rect = new Rectangle(0, 0, getParent().getSize().x, getParent().getSize().y);\n+\t\t\tif (minLaneHeight == -1) {\n+\t\t\t\tminLaneHeight = calculateMinLaneHeight(rect);\n+\t\t\t\tlaneHeight = minLaneHeight;\n+\t\t\t}\n+\t\t\tif (getNumItems() == 0) {\n+\t\t\t\trect = getClientArea();\n+\t\t\t} else if (getNumItems() == 1 || (laneHeight * getNumItems() < rect.height)) {\n+\t\t\t\t\/\/ it fills the height\n+\t\t\t} else {\n+\t\t\t\trect.height = laneHeight * getNumItems();\n+\t\t\t}\n+\n@@ -174,2 +241,0 @@\n-\t\t\t\tg2d.setColor(Color.WHITE);\n-\t\t\t\tg2d.fillRect(0, 0, rect.width, rect.height);\n@@ -177,0 +242,2 @@\n+\t\t\t\tg2d.setColor(Palette.PF_BLACK_100.getAWTColor());\n+\t\t\t\tg2d.fillRect(0, 0, adjusted.x, adjusted.y);\n@@ -178,2 +245,4 @@\n-\t\t\t\tif (highlightRects != null) {\n-\t\t\t\t\tupdateHighlightRects();\n+\t\t\t\tif (isScrollableChart()) {\n+\t\t\t\t\tminReadableLaneHeight = (int) (g2d.getFontMetrics().getHeight() * xScale);\n+\t\t\t\t\tminLaneHeight = initMinLaneHeight();\n+\t\t\t\t\t((ScrolledComposite) getParent()).setMinSize(rect.width, rect.height);\n@@ -203,0 +272,1 @@\n+\t\t\t\tupdateHighlightRects();\n@@ -207,0 +277,62 @@\n+\tpublic void setNumItems(int numItems) {\n+\t\tthis.numItems = numItems;\n+\t}\n+\n+\tprivate int getNumItems() {\n+\t\treturn numItems;\n+\t}\n+\n+\tprivate boolean isScrollableChart() {\n+\t\treturn getParent() instanceof ScrolledComposite;\n+\t}\n+\n+\tprotected int initMinLaneHeight() {\n+\t\t\/\/ if the min readable lane height * the number of items exceeds the screen, then use min readable height\n+\t\tif (minReadableLaneHeight * getNumItems() > getParent().getSize().y) {\n+\t\t\treturn minReadableLaneHeight;\n+\t\t} else { \/\/ if the minimum readable lane height * the number of items leaves extra space, then the min height is the height \/ number of items\n+\t\t\treturn getParent().getSize().y \/ getNumItems();\n+\t\t}\n+\t}\n+\n+\tprotected int calculateMinLaneHeight(Rectangle rect) {\n+\t\treturn (int) (awtCanvas.getGraphics(rect.width, rect.height).getFontMetrics().getHeight() * xScale);\n+\t}\n+\n+\tpublic boolean isLaneHeightMinimumSize() {\n+\t\treturn laneHeight == minLaneHeight;\n+\t}\n+\n+\tvoid setOverviewLaneHeight() {\n+\t\tthis.savedLaneHeight = laneHeight;\n+\t\tsetLaneHeight(-1);\n+\t\tzoomer = new Zoomer();\n+\t\taddListener(SWT.MouseVerticalWheel, zoomer);\n+\t}\n+\n+\tvoid adjustLaneHeight(int amount) {\n+\t\tif (laneHeight == -1) {\n+\t\t\trestoreLaneHeight();\n+\t\t}\n+\t\tlaneHeight = Math.max(minLaneHeight, laneHeight + amount);\n+\t}\n+\n+\tvoid setLaneHeight(int height) {\n+\t\tthis.laneHeight = height;\n+\t}\n+\n+\tvoid restoreLaneHeight() {\n+\t\tlaneHeight = savedLaneHeight;\n+\t\tremoveListener(SWT.MouseVerticalWheel, zoomer);\n+\t}\n+\n+\tpublic void resetLaneHeight() {\n+\t\tif (minLaneHeight != -1) {\n+\t\t\tif (laneHeight == -1) {\n+\t\t\t\tremoveListener(SWT.MouseVerticalWheel, zoomer);\n+\t\t\t}\n+\t\t\tminLaneHeight = initMinLaneHeight();\n+\t\t\tlaneHeight = minLaneHeight;\n+\t\t}\n+\t}\n+\n@@ -290,0 +422,8 @@\n+\t\t\t\tcase SWT.ESC:\n+\t\t\t\t\tawtChart.clearSelection();\n+\t\t\t\t\tif (selectionListener != null) {\n+\t\t\t\t\t\tselectionListener.run();\n+\t\t\t\t\t}\n+\t\t\t\t\tredrawChart();\n+\t\t\t\t\tredrawChartText();\n+\t\t\t\t\tbreak;\n@@ -336,0 +476,2 @@\n+\tprivate Runnable zoomToSelectionListener;\n+\tprivate Consumer<Boolean> zoomOnClickListener;\n@@ -339,0 +481,2 @@\n+\tprivate ChartTextCanvas textCanvas;\n+\tprivate Listener zoomer;\n@@ -346,1 +490,0 @@\n-\t\taddMouseTrackListener(selector);\n@@ -348,1 +491,0 @@\n-\t\taddListener(SWT.MouseVerticalWheel, new Zoomer());\n@@ -356,0 +498,14 @@\n+\t\tif (isScrollableChart()) { \/\/ JFR Threads Page\n+\t\t\t((ScrolledComposite) getParent()).getVerticalBar().addListener(SWT.Selection, e -> vBarScroll());\n+\t\t} else {\n+\t\t\taddMouseTrackListener(selector);\n+\t\t\taddListener(SWT.MouseVerticalWheel, new Zoomer());\n+\t\t}\n+\t}\n+\n+\tprivate void vBarScroll() {\n+\t\tif (textCanvas != null) {\n+\t\t\tPoint location = ((ScrolledComposite) getParent()).getOrigin();\n+\t\t\ttextCanvas.syncScroll(location);\n+\t\t\tawtChart.updateZoomPanIndicator();\n+\t\t}\n@@ -368,1 +524,5 @@\n-\t\t\tawtChart.render(context, width, height);\n+\t\t\tawtChart.renderChart(context, width, height);\n+\t\t\tif (textCanvas == null) {\n+\t\t\t\tawtChart.renderText(context, width, height);\n+\t\t\t}\n+\t\t\tawtChart.updateZoomPanIndicator();\n@@ -381,1 +541,1 @@\n-\tprivate Point translateDisplayToImageCoordinates(int x, int y) {\n+\tprotected Point translateDisplayToImageCoordinates(int x, int y) {\n@@ -394,1 +554,1 @@\n-\tprivate int translateDisplayToImageXCoordinates(int x) {\n+\tprotected int translateDisplayToImageXCoordinates(int x) {\n@@ -398,0 +558,11 @@\n+\t\/**\n+\t * Translates a display x coordinate into an image x coordinate for the chart.\n+\t *\n+\t * @param x\n+\t *            the provided display x coordinate\n+\t * @return the x coordinate in the chart's coordinate space\n+\t *\/\n+\tprotected int translateDisplayToImageYCoordinates(int y) {\n+\t\treturn (int) Math.round(y \/ yScale);\n+\t}\n+\n@@ -410,0 +581,5 @@\n+\tpublic void syncHighlightedRectangles(List<Rectangle2D> newRects) {\n+\t\thighlightRects = newRects;\n+\t\tredraw();\n+\t}\n+\n@@ -450,0 +626,3 @@\n+\t\t\tif (textCanvas != null) {\n+\t\t\t\ttextCanvas.syncHighlightedRectangles(highlightRects);\n+\t\t\t}\n@@ -488,2 +667,4 @@\n-\tprivate void select(int x1, int x2, int y1, int y2) {\n-\t\tif ((awtChart != null) && awtChart.select(x1, x2, y1, y2)) {\n+\tprivate void select(int x1, int x2, int y1, int y2, boolean clear) {\n+\t\tPoint p1 = translateDisplayToImageCoordinates(x1, y1);\n+\t\tPoint p2 = translateDisplayToImageCoordinates(x2, y2);\n+\t\tif ((awtChart != null) && awtChart.select(p1.x, p2.x, p1.y, p2.y, clear)) {\n@@ -491,0 +672,1 @@\n+\t\t\tredrawChartText();\n@@ -518,1 +700,1 @@\n-\t\t\t\tif (!awtChart.select(range[0], range[1], p.y, p.y)) {\n+\t\t\t\tif (!awtChart.select(range[0], range[1], p.y, p.y, true)) {\n@@ -522,1 +704,1 @@\n-\t\t\t\tif (!awtChart.select(p.x, p.x, p.y, p.y)) {\n+\t\t\t\tif (!awtChart.select(p.x, p.x, p.y, p.y, true)) {\n@@ -526,0 +708,1 @@\n+\t\t\tnotifyZoomOnClickListener(SWT.MouseDown);\n@@ -527,0 +710,1 @@\n+\t\t\tredrawChartText();\n@@ -533,1 +717,8 @@\n-\t\tredrawChart();\n+\t}\n+\n+\tpublic void setTextCanvas(ChartTextCanvas textCanvas) {\n+\t\tthis.textCanvas = textCanvas;\n+\t}\n+\n+\tpublic void syncScroll(Point scrollPoint) {\n+\t\t((ScrolledComposite) getParent()).setOrigin(scrollPoint);\n@@ -547,0 +738,14 @@\n+\tpublic void setZoomToSelectionListener(Runnable zoomListener) {\n+\t\tthis.zoomToSelectionListener = zoomListener;\n+\t}\n+\n+\tpublic void setZoomOnClickListener(Consumer<Boolean> clickListener) {\n+\t\tthis.zoomOnClickListener = clickListener;\n+\t}\n+\n+\tprivate void notifyZoomOnClickListener(Integer button) {\n+\t\tif (zoomOnClickListener != null) {\n+\t\t\tzoomOnClickListener.accept(button == SWT.MouseDown);\n+\t\t}\n+\t}\n+\n@@ -553,0 +758,4 @@\n+\tpublic void changeCursor(Cursor cursor) {\n+\t\tsetCursor(cursor);\n+\t}\n+\n@@ -565,1 +774,7 @@\n-\t\tredraw();\n+\t\tgetDisplay().asyncExec(new Runnable() {\n+\t\t\tpublic void run() {\n+\t\t\t\tif (!isDisposed()) {\n+\t\t\t\t\tredraw();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n@@ -567,0 +782,7 @@\n+\n+\tprivate void redrawChartText() {\n+\t\tif (textCanvas != null) {\n+\t\t\ttextCanvas.redrawChartText();\n+\t\t}\n+\t}\n+\n","filename":"application\/org.openjdk.jmc.ui\/src\/main\/java\/org\/openjdk\/jmc\/ui\/misc\/ChartCanvas.java","additions":242,"deletions":20,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.ui.misc;\n+\n+import org.eclipse.swt.SWT;\n+import org.eclipse.swt.layout.GridData;\n+import org.eclipse.swt.layout.GridLayout;\n+import org.eclipse.swt.widgets.Composite;\n+import org.eclipse.swt.widgets.Listener;\n+\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.IRange;\n+import org.openjdk.jmc.ui.charts.XYChart;\n+\n+public class ChartControlBar extends Composite {\n+\n+\tprivate ChartButtonGroup buttonGroup;\n+\tprivate ChartLaneHeightControls laneHeightControls;\n+\tprivate Composite laneFilterContainer;\n+\tprivate TimeFilter timeFilter;\n+\n+\tpublic ChartControlBar(Composite parent, Listener resetListener, IRange<IQuantity> recordingRange) {\n+\t\tsuper(parent, SWT.NONE);\n+\t\tthis.setLayout(new GridLayout(4, false));\n+\n+\t\ttimeFilter = new TimeFilter(this, recordingRange, resetListener);\n+\t\ttimeFilter.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false));\n+\n+\t\tlaneFilterContainer = new Composite(this, SWT.NONE);\n+\t\tlaneFilterContainer.setLayout(new GridLayout());\n+\n+\t\tComposite buttonGroupContainer = new Composite(this, SWT.NONE);\n+\t\tbuttonGroupContainer.setLayout(new GridLayout(3, false));\n+\t\tbuttonGroupContainer.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, true, false));\n+\t\tbuttonGroup = new ChartButtonGroup(buttonGroupContainer);\n+\t\tlaneHeightControls = new ChartLaneHeightControls(buttonGroupContainer);\n+\t\tbuttonGroup.setResetLaneHeightAction(() -> resetLaneHeightToMinimum());\n+\t}\n+\n+\tpublic Composite getLaneFilterContainer() {\n+\t\treturn laneFilterContainer;\n+\t}\n+\n+\tpublic ChartButtonGroup getButtonGroup() {\n+\t\treturn buttonGroup;\n+\t}\n+\n+\tpublic void resetLaneHeightToMinimum() {\n+\t\tlaneHeightControls.resetLaneHeightToMinimum();\n+\t}\n+\n+\tpublic void setChart(XYChart chart) {\n+\t\tbuttonGroup.setChart(chart);\n+\t\ttimeFilter.setChart(chart);\n+\t}\n+\n+\tpublic void setChartCanvas(ChartCanvas canvas) {\n+\t\tbuttonGroup.setChartCanvas(canvas);\n+\t\tlaneHeightControls.setChartCanvas(canvas);\n+\t\ttimeFilter.setChartCanvas(canvas);\n+\t}\n+\n+\tpublic void setTextCanvas(ChartTextCanvas textCanvas) {\n+\t\tbuttonGroup.setTextCanvas(textCanvas);\n+\t\tlaneHeightControls.setTextCanvas(textCanvas);\n+\t}\n+\n+\tpublic void setStartTime(IQuantity startTime) {\n+\t\ttimeFilter.setStartTime(startTime);\n+\t}\n+\n+\tpublic void setEndTime(IQuantity endTime) {\n+\t\ttimeFilter.setEndTime(endTime);\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.ui\/src\/main\/java\/org\/openjdk\/jmc\/ui\/misc\/ChartControlBar.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.ui.misc;\n+\n+import org.eclipse.swt.SWT;\n+import org.eclipse.swt.layout.GridData;\n+import org.eclipse.swt.layout.GridLayout;\n+import org.eclipse.swt.widgets.Button;\n+import org.eclipse.swt.widgets.Composite;\n+import org.eclipse.swt.widgets.Event;\n+import org.eclipse.swt.widgets.Listener;\n+import org.openjdk.jmc.ui.UIPlugin;\n+\n+public class ChartLaneHeightControls extends Composite {\n+\tprivate Button decHeightBtn;\n+\tprivate Button incHeightBtn;\n+\tprivate Button overviewBtn;\n+\tprivate ChartCanvas chartCanvas;\n+\tprivate ChartTextCanvas textCanvas;\n+\tprivate static final int ADJUST_AMOUNT = 3;\n+\n+\tpublic ChartLaneHeightControls(Composite parent) {\n+\t\tsuper(parent, SWT.NONE);\n+\t\tGridLayout gl = new GridLayout(3, true);\n+\t\tgl.horizontalSpacing = 0;\n+\t\tgl.marginWidth = 0;\n+\t\tthis.setLayout(gl);\n+\n+\t\tinitDecreaseHeightButton();\n+\t\tinitIncreaseHeightButton();\n+\t\tinitOverviewButton();\n+\t}\n+\n+\tprivate void initDecreaseHeightButton() {\n+\t\tdecHeightBtn = new Button(this, SWT.PUSH);\n+\t\tdecHeightBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));\n+\t\tdecHeightBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_MINUS));\n+\t\tdecHeightBtn.setToolTipText(Messages.ChartLaneHeightControls_LANE_HEIGHT_DECREASE_TOOLTIP);\n+\t\tdecHeightBtn.addListener(SWT.Selection, new Listener() {\n+\t\t\t@Override\n+\t\t\tpublic void handleEvent(Event event) {\n+\t\t\t\tadjustLaneHeight(-ADJUST_AMOUNT);\n+\t\t\t}\n+\t\t});\n+\t\tdecHeightBtn.setEnabled(false);\n+\t}\n+\n+\tprivate void initIncreaseHeightButton() {\n+\t\tincHeightBtn = new Button(this, SWT.PUSH);\n+\t\tincHeightBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));\n+\t\tincHeightBtn.setToolTipText(Messages.ChartLaneHeightControls_LANE_HEIGHT_INCREASE_TOOLTIP);\n+\t\tincHeightBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_PLUS));\n+\t\tincHeightBtn.addListener(SWT.Selection, new Listener() {\n+\t\t\t@Override\n+\t\t\tpublic void handleEvent(Event event) {\n+\t\t\t\tadjustLaneHeight(ADJUST_AMOUNT);\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\tprivate void initOverviewButton() {\n+\t\toverviewBtn = new Button(this, SWT.TOGGLE);\n+\t\toverviewBtn.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));\n+\t\toverviewBtn.setToolTipText(Messages.ChartLaneHeightControls_OVERVIEW_BUTTON_TOOLTIP);\n+\t\toverviewBtn.setImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_ADRESS));\n+\t\toverviewBtn.addListener(SWT.Selection, new Listener() {\n+\t\t\t@Override\n+\t\t\tpublic void handleEvent(Event event) {\n+\t\t\t\tif (!overviewBtn.getSelection()) {\n+\t\t\t\t\tchartCanvas.restoreLaneHeight();\n+\t\t\t\t\tchartCanvas.redrawChart();\n+\t\t\t\t\tif (textCanvas != null) {\n+\t\t\t\t\t\ttextCanvas.restoreLaneHeight();\n+\t\t\t\t\t\ttextCanvas.redrawChartText();\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tchartCanvas.setOverviewLaneHeight();\n+\t\t\t\t\tchartCanvas.redrawChart();\n+\t\t\t\t\tif (textCanvas != null) {\n+\t\t\t\t\t\ttextCanvas.setOverviewLaneHeight();\n+\t\t\t\t\t\ttextCanvas.redrawChartText();\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\tprivate void adjustLaneHeight(int amount) {\n+\t\tchartCanvas.adjustLaneHeight(amount);\n+\t\tchartCanvas.redrawChart();\n+\t\tif (textCanvas != null) {\n+\t\t\ttextCanvas.adjustLaneHeight(amount);\n+\t\t\ttextCanvas.redrawChartText();\n+\t\t}\n+\t\tif (chartCanvas.isLaneHeightMinimumSize()) {\n+\t\t\tdecHeightBtn.setEnabled(false);\n+\t\t} else {\n+\t\t\tdecHeightBtn.setEnabled(true);\n+\t\t}\n+\t\tif (overviewBtn.getSelection()) {\n+\t\t\toverviewBtn.setSelection(false);\n+\t\t}\n+\t}\n+\n+\tvoid resetLaneHeightToMinimum() {\n+\t\tchartCanvas.resetLaneHeight();\n+\t\tif (textCanvas != null) {\n+\t\t\ttextCanvas.resetLaneHeight();\n+\t\t}\n+\t\tdecHeightBtn.setEnabled(false);\n+\t\toverviewBtn.setSelection(false);\n+\t}\n+\n+\tvoid setChartCanvas(ChartCanvas chartCanvas) {\n+\t\tthis.chartCanvas = chartCanvas;\n+\t}\n+\n+\tvoid setTextCanvas(ChartTextCanvas textCanvas) {\n+\t\tthis.textCanvas = textCanvas;\n+\t}\n+\n+}\n","filename":"application\/org.openjdk.jmc.ui\/src\/main\/java\/org\/openjdk\/jmc\/ui\/misc\/ChartLaneHeightControls.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,483 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.ui.misc;\n+\n+import java.awt.Graphics2D;\n+import java.awt.geom.Rectangle2D;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.eclipse.jface.action.IMenuManager;\n+import org.eclipse.jface.util.IPropertyChangeListener;\n+import org.eclipse.jface.util.PropertyChangeEvent;\n+import org.eclipse.swt.SWT;\n+import org.eclipse.swt.custom.ScrolledComposite;\n+import org.eclipse.swt.events.KeyEvent;\n+import org.eclipse.swt.events.KeyListener;\n+import org.eclipse.swt.events.MouseAdapter;\n+import org.eclipse.swt.events.MouseEvent;\n+import org.eclipse.swt.events.MouseMoveListener;\n+import org.eclipse.swt.events.MouseTrackListener;\n+import org.eclipse.swt.events.PaintEvent;\n+import org.eclipse.swt.events.PaintListener;\n+import org.eclipse.swt.graphics.Point;\n+import org.eclipse.swt.graphics.Rectangle;\n+import org.eclipse.swt.widgets.Canvas;\n+import org.eclipse.swt.widgets.Composite;\n+import org.eclipse.swt.widgets.Display;\n+import org.openjdk.jmc.ui.UIPlugin;\n+import org.openjdk.jmc.ui.accessibility.FocusTracker;\n+import org.openjdk.jmc.ui.charts.IChartInfoVisitor;\n+import org.openjdk.jmc.ui.charts.IXDataRenderer;\n+import org.openjdk.jmc.ui.charts.XYChart;\n+import org.openjdk.jmc.ui.common.util.Environment;\n+import org.openjdk.jmc.ui.handlers.MCContextMenuManager;\n+import org.openjdk.jmc.ui.misc.PatternFly.Palette;\n+\n+public class ChartTextCanvas extends Canvas {\n+\tprivate int laneHeight;\n+\tprivate int savedLaneHeight;\n+\tprivate int minLaneHeight = -1;\n+\tprivate int numItems = 0;\n+\tprivate int lastMouseX = -1;\n+\tprivate int lastMouseY = -1;\n+\tprivate List<Rectangle2D> highlightRects;\n+\n+\tprivate class Selector extends MouseAdapter implements MouseMoveListener, MouseTrackListener {\n+\n+\t\tint selectionStartX = -1;\n+\t\tint selectionStartY = -1;\n+\t\tPoint highlightSelectionStart;\n+\t\tPoint highlightSelectionEnd;\n+\t\tPoint lastSelection;\n+\t\tboolean selectionIsClick = false;\n+\t\tSet<Point> highlightPoints;\n+\n+\t\t@Override\n+\t\tpublic void mouseDown(MouseEvent e) {\n+\t\t\t\/*\n+\t\t\t * On Mac OS X, CTRL + left mouse button can be used to trigger a context menu. (This is\n+\t\t\t * for historical reasons when the primary input device on Macs were a mouse with a\n+\t\t\t * single physical button. All modern Macs have other means to bring up the context\n+\t\t\t * menu, typically a two finger tap.)\n+\t\t\t * \n+\t\t\t * Although I think it would be best to check that this MouseEvent does not cause a\n+\t\t\t * platform specific popup trigger, like java.awt.event.MouseEvent.isPopupTrigger() for\n+\t\t\t * AWT, SWT doesn't seem to have something as simple. It has the MenuDetectEvent, but\n+\t\t\t * the order in relation to this MouseEvent is unspecified.\n+\t\t\t * \n+\t\t\t * The code below instead relies on ignoring mouse down events when SWT.MOD4 is\n+\t\t\t * depressed. Since MOD4 is CTRL on OS X and 0 on all other current platforms, this\n+\t\t\t * suffices. Except for an additional platform check, this approach is also used in\n+\t\t\t * org.eclipse.swt.custom.StyledText.handleMouseDown(Event).\n+\t\t\t *\/\n+\t\t\tif ((e.button == 1) && ((e.stateMask & SWT.MOD4) == 0) && ((e.stateMask & SWT.CTRL) == 0)\n+\t\t\t\t\t&& ((e.stateMask & SWT.SHIFT) == 0)) {\n+\t\t\t\thighlightPoints = new HashSet<>();\n+\t\t\t\thighlightPoints.add(new Point(e.x, e.y));\n+\t\t\t\tselectionStartX = e.x;\n+\t\t\t\tselectionStartY = e.y;\n+\t\t\t\thighlightSelectionEnd = new Point(-1, -1);\n+\t\t\t\tlastSelection = new Point(-1, -1);\n+\t\t\t\tselectionIsClick = true;\n+\t\t\t\ttoggleSelect(selectionStartX, selectionStartY);\n+\t\t\t} else if (((e.stateMask & SWT.CTRL) != 0) && (e.button == 1)) {\n+\t\t\t\thighlightPoints.add(new Point(e.x, e.y));\n+\t\t\t\tselect(e.x, e.x, e.y, e.y, false);\n+\t\t\t\tif (selectionListener != null) {\n+\t\t\t\t\tselectionListener.run();\n+\t\t\t\t}\n+\t\t\t} else if (((e.stateMask & SWT.SHIFT) != 0) && (e.button == 1)) {\n+\t\t\t\tif (highlightSelectionEnd.y == -1) {\n+\t\t\t\t\thighlightSelectionEnd = new Point(e.x, e.y);\n+\t\t\t\t\tlastSelection = highlightSelectionEnd;\n+\t\t\t\t\tif (highlightSelectionStart.y > highlightSelectionEnd.y) {\n+\t\t\t\t\t\tPoint temp = highlightSelectionStart;\n+\t\t\t\t\t\thighlightSelectionStart = highlightSelectionEnd;\n+\t\t\t\t\t\thighlightSelectionEnd = temp;\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tif (e.y > highlightSelectionStart.y && e.y < highlightSelectionEnd.y) {\n+\t\t\t\t\t\tif (e.y < lastSelection.y) {\n+\t\t\t\t\t\t\thighlightSelectionEnd = new Point(e.x, e.y);\n+\t\t\t\t\t\t} else if (e.y > lastSelection.y) {\n+\t\t\t\t\t\t\thighlightSelectionStart = new Point(e.x, e.y);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else if (e.y < highlightSelectionStart.y) {\n+\t\t\t\t\t\thighlightSelectionStart = new Point(e.x, e.y);\n+\t\t\t\t\t\tlastSelection = highlightSelectionStart;\n+\t\t\t\t\t} else if (e.y > highlightSelectionEnd.y) {\n+\t\t\t\t\t\thighlightSelectionEnd = new Point(e.x, e.y);\n+\t\t\t\t\t\tlastSelection = highlightSelectionEnd;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tselect(highlightSelectionStart.x, highlightSelectionStart.x, highlightSelectionStart.y,\n+\t\t\t\t\t\thighlightSelectionEnd.y, true);\n+\t\t\t\tif (selectionListener != null) {\n+\t\t\t\t\tselectionListener.run();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void mouseMove(MouseEvent e) {\n+\t\t\tif (selectionStartX >= 0) {\n+\t\t\t\thighlightRects = null;\n+\t\t\t\tupdateSelectionState(e);\n+\t\t\t} else {\n+\t\t\t\tlastMouseX = e.x;\n+\t\t\t\tlastMouseY = e.y;\n+\t\t\t\tupdateHighlightRects();\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate void updateSelectionState(MouseEvent e) {\n+\t\t\tint x = e.x;\n+\t\t\tint y = e.y;\n+\t\t\tif (selectionIsClick && ((Math.abs(x - selectionStartX) > 3) || (Math.abs(y - selectionStartY) > 3))) {\n+\t\t\t\tselectionIsClick = false;\n+\t\t\t}\n+\t\t\tif (!selectionIsClick) {\n+\t\t\t\tselect((int) (selectionStartX \/ xScale), (int) (selectionStartX \/ xScale),\n+\t\t\t\t\t\t(int) (selectionStartY \/ yScale), (int) (y \/ yScale), true);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void mouseUp(MouseEvent e) {\n+\t\t\tif (selectionStartX >= 0 && (e.button == 1)) {\n+\t\t\t\tupdateSelectionState(e);\n+\t\t\t\thighlightSelectionStart = new Point(selectionStartX, selectionStartY);\n+\t\t\t\tselectionStartX = -1;\n+\t\t\t\tselectionStartY = -1;\n+\t\t\t\tif (selectionListener != null) {\n+\t\t\t\t\tselectionListener.run();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void mouseEnter(MouseEvent e) {\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void mouseExit(MouseEvent e) {\n+\t\t\tif (!getClientArea().contains(e.x, e.y)) {\n+\t\t\t\tresetHoveredItemData();\n+\t\t\t}\n+\t\t\tclearHighlightRects();\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void mouseHover(MouseEvent e) {\n+\t\t}\n+\t}\n+\n+\tclass Painter implements PaintListener {\n+\n+\t\t@Override\n+\t\tpublic void paintControl(PaintEvent e) {\n+\t\t\tint minScrollWidth = (int) ((awtChart.getLongestCharWidth() + 10) * xScale);\n+\t\t\tint rectWidth = Math.max(minScrollWidth, getParent().getSize().x);\n+\t\t\tRectangle rect = new Rectangle(0, 0, rectWidth, getParent().getSize().y);\n+\t\t\tif (getNumItems() > 0) {\n+\t\t\t\tif (minLaneHeight == -1) {\n+\t\t\t\t\tminLaneHeight = chartCanvas.calculateMinLaneHeight(rect);\n+\t\t\t\t\tlaneHeight = minLaneHeight;\n+\t\t\t\t}\n+\t\t\t\tif (getNumItems() != 1 && !(laneHeight * getNumItems() < rect.height)) {\n+\t\t\t\t\trect.height = laneHeight * getNumItems();\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (awtNeedsRedraw || !awtCanvas.hasImage(rect.width, rect.height)) {\n+\t\t\t\tGraphics2D g2d = awtCanvas.getGraphics(rect.width, rect.height);\n+\t\t\t\tminLaneHeight = (int) (g2d.getFontMetrics().getHeight() * xScale);\n+\t\t\t\tPoint adjusted = chartCanvas.translateDisplayToImageCoordinates(rect.width, rect.height);\n+\t\t\t\tg2d.setColor(Palette.PF_BLACK_100.getAWTColor());\n+\t\t\t\tg2d.fillRect(0, 0, adjusted.x, adjusted.y);\n+\t\t\t\trender(g2d, adjusted.x, adjusted.y);\n+\t\t\t\t((ScrolledComposite) getParent()).setMinSize(rect.width, rect.height);\n+\t\t\t\tif (highlightRects != null) {\n+\t\t\t\t\tupdateHighlightRects();\n+\t\t\t\t}\n+\t\t\t\tawtNeedsRedraw = false;\n+\t\t\t}\n+\t\t\tawtCanvas.paint(e, 0, 0);\n+\t\t}\n+\t}\n+\n+\tpublic void setNumItems(int numItems) {\n+\t\tthis.numItems = numItems;\n+\t}\n+\n+\tprivate int getNumItems() {\n+\t\treturn numItems;\n+\t}\n+\n+\tvoid setOverviewLaneHeight() {\n+\t\tthis.savedLaneHeight = laneHeight;\n+\t\tsetLaneHeight(-1);\n+\t}\n+\n+\tvoid adjustLaneHeight(int amount) {\n+\t\tif (laneHeight == -1) {\n+\t\t\trestoreLaneHeight();\n+\t\t}\n+\t\tlaneHeight = Math.max(minLaneHeight, laneHeight + amount);\n+\t}\n+\n+\tvoid setLaneHeight(int height) {\n+\t\tthis.laneHeight = height;\n+\t}\n+\n+\tvoid restoreLaneHeight() {\n+\t\tlaneHeight = savedLaneHeight;\n+\t}\n+\n+\tvoid resetLaneHeight() {\n+\t\tif (minLaneHeight != -1) {\n+\t\t\tminLaneHeight = chartCanvas.initMinLaneHeight();\n+\t\t\tlaneHeight = minLaneHeight;\n+\t\t}\n+\t}\n+\n+\tclass KeyNavigator implements KeyListener {\n+\n+\t\t@Override\n+\t\tpublic void keyPressed(KeyEvent event) {\n+\t\t\tswitch (event.character) {\n+\t\t\tdefault:\n+\t\t\t\tswitch (event.keyCode) {\n+\t\t\t\tcase SWT.ESC:\n+\t\t\t\t\tawtChart.clearSelection();\n+\t\t\t\t\tif (selectionListener != null) {\n+\t\t\t\t\t\tselectionListener.run();\n+\t\t\t\t\t}\n+\t\t\t\t\tredrawChart();\n+\t\t\t\t\tredrawChartText();\n+\t\t\t\t\tbreak;\n+\t\t\t\tdefault:\n+\t\t\t\t\t\/\/ Ignore\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void keyReleased(KeyEvent event) {\n+\t\t\t\/\/ Ignore\n+\t\t}\n+\n+\t}\n+\n+\tprivate class AntiAliasingListener implements IPropertyChangeListener {\n+\n+\t\t@Override\n+\t\tpublic void propertyChange(PropertyChangeEvent event) {\n+\t\t\tredrawChartText();\n+\t\t}\n+\n+\t}\n+\n+\t\/**\n+\t * This gets the \"normal\" DPI value for the system (72 on MacOS and 96 on Windows\/Linux. It's\n+\t * used to determine how much larger the current DPI is so that we can draw the charts based on\n+\t * how large that area would be given the \"normal\" DPI value. Every draw on this smaller chart\n+\t * is then scaled up by the Graphics2D objects DefaultTransform.\n+\t *\/\n+\tprivate final double xScale = Display.getDefault().getDPI().x \/ Environment.getNormalDPI();\n+\tprivate final double yScale = Display.getDefault().getDPI().y \/ Environment.getNormalDPI();\n+\n+\tpublic final AwtCanvas awtCanvas = new AwtCanvas();\n+\tprivate boolean awtNeedsRedraw;\n+\tprivate Runnable selectionListener;\n+\tprivate IPropertyChangeListener aaListener;\n+\tprivate XYChart awtChart;\n+\tprivate ChartCanvas chartCanvas;\n+\tprivate MCContextMenuManager chartMenu;\n+\tprivate Object hoveredItemData;\n+\n+\tpublic ChartTextCanvas(Composite parent) {\n+\t\tsuper(parent, SWT.NO_BACKGROUND);\n+\t\tnumItems = 0;\n+\t\taddPaintListener(new Painter());\n+\t\tSelector selector = new Selector();\n+\t\taddMouseListener(selector);\n+\t\taddMouseMoveListener(selector);\n+\t\tFocusTracker.enableFocusTracking(this);\n+\t\taddKeyListener(new KeyNavigator());\n+\t\taaListener = new AntiAliasingListener();\n+\t\tUIPlugin.getDefault().getPreferenceStore().addPropertyChangeListener(aaListener);\n+\t\taddDisposeListener(e -> UIPlugin.getDefault().getPreferenceStore().removePropertyChangeListener(aaListener));\n+\t\t((ScrolledComposite) getParent()).getVerticalBar().addListener(SWT.Selection, e -> vBarScroll());\n+\t}\n+\n+\tprivate void vBarScroll() {\n+\t\tif (chartCanvas != null) {\n+\t\t\tPoint location = ((ScrolledComposite) getParent()).getOrigin();\n+\t\t\tchartCanvas.syncScroll(location);\n+\t\t}\n+\t}\n+\n+\tpublic IMenuManager getContextMenu() {\n+\t\tif (chartMenu == null) {\n+\t\t\tchartMenu = MCContextMenuManager.create(this);\n+\t\t\tchartMenu.addMenuListener(manager -> clearHighlightRects());\n+\t\t}\n+\t\treturn chartMenu;\n+\t}\n+\n+\tprivate void render(Graphics2D context, int width, int height) {\n+\t\tif (awtChart != null) {\n+\t\t\tawtChart.renderTextCanvasText(context, width, height);\n+\t\t}\n+\t}\n+\n+\tpublic Object getHoveredItemData() {\n+\t\treturn this.hoveredItemData;\n+\t}\n+\n+\tpublic void setHoveredItemData(Object data) {\n+\t\tthis.hoveredItemData = data;\n+\t}\n+\n+\tvoid resetHoveredItemData() {\n+\t\tthis.hoveredItemData = null;\n+\t}\n+\n+\tpublic void syncHighlightedRectangles(List<Rectangle2D> newRects) {\n+\t\thighlightRects = newRects;\n+\t\tredraw();\n+\t}\n+\n+\tprivate void updateHighlightRects() {\n+\t\tinfoAt(new IChartInfoVisitor.Adapter() {\n+\t\t\t@Override\n+\t\t\tpublic void hover(Object data) {\n+\t\t\t\tif (data != null) {\n+\t\t\t\t\tsetHoveredItemData(data);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}, lastMouseX, lastMouseY);\n+\t\tredraw();\n+\t\tif (chartCanvas != null) {\n+\t\t\tchartCanvas.syncHighlightedRectangles(highlightRects);\n+\t\t}\n+\t}\n+\n+\tprivate void clearHighlightRects() {\n+\t\tif (highlightRects != null) {\n+\t\t\thighlightRects = null;\n+\t\t\tredraw();\n+\t\t}\n+\t}\n+\n+\tpublic void select(int x1, int x2, int y1, int y2, boolean clear) {\n+\t\tPoint p1 = chartCanvas.translateDisplayToImageCoordinates(x1, y1);\n+\t\tPoint p2 = chartCanvas.translateDisplayToImageCoordinates(x2, y2);\n+\t\tif ((awtChart != null) && awtChart.select(p1.x, p2.x, p1.y, p2.y, clear)) {\n+\t\t\tredrawChartText();\n+\t\t\tredrawChart();\n+\t\t}\n+\t}\n+\n+\tprivate void toggleSelect(int x, int y) {\n+\t\tPoint p = chartCanvas.translateDisplayToImageCoordinates(x, y);\n+\t\tif (awtChart != null) {\n+\t\t\tif (!awtChart.select(p.x, p.x, p.y, p.y, true)) {\n+\t\t\t\tawtChart.clearSelection();\n+\t\t\t}\n+\t\t\tredrawChartText();\n+\t\t\tredrawChart();\n+\t\t}\n+\t}\n+\n+\tpublic void setChart(XYChart awtChart) {\n+\t\tthis.awtChart = awtChart;\n+\t\tnotifyListener();\n+\t}\n+\n+\tpublic void setChartCanvas(ChartCanvas chartCanvas) {\n+\t\tthis.chartCanvas = chartCanvas;\n+\t}\n+\n+\tpublic void syncScroll(Point scrollPoint) {\n+\t\t((ScrolledComposite) getParent()).setOrigin(scrollPoint);\n+\t}\n+\n+\tpublic void replaceRenderer(IXDataRenderer rendererRoot) {\n+\t\tassert awtChart != null;\n+\t\tawtChart.setRendererRoot(rendererRoot);\n+\t\tnotifyListener();\n+\t\tredrawChartText();\n+\t}\n+\n+\tpublic void setSelectionListener(Runnable selectionListener) {\n+\t\tthis.selectionListener = selectionListener;\n+\t}\n+\n+\tprivate void notifyListener() {\n+\t\tif (selectionListener != null) {\n+\t\t\tselectionListener.run();\n+\t\t}\n+\t}\n+\n+\tpublic void infoAt(IChartInfoVisitor visitor, int x, int y) {\n+\t\tPoint p = chartCanvas.translateDisplayToImageCoordinates(x, y);\n+\t\tif (awtChart != null) {\n+\t\t\tawtChart.infoAt(visitor, p.x, p.y);\n+\t\t}\n+\t}\n+\n+\t\/**\n+\t * Mark both the (AWT) chart and the SWT control as needing a redraw.\n+\t *\/\n+\tpublic void redrawChartText() {\n+\t\tawtNeedsRedraw = true;\n+\t\tgetDisplay().asyncExec(new Runnable() {\n+\t\t\tpublic void run() {\n+\t\t\t\tif (!isDisposed()) {\n+\t\t\t\t\tredraw();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\tprivate void redrawChart() {\n+\t\tif (chartCanvas != null) {\n+\t\t\tchartCanvas.redrawChart();\n+\t\t}\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.ui\/src\/main\/java\/org\/openjdk\/jmc\/ui\/misc\/ChartTextCanvas.java","additions":483,"deletions":0,"binary":false,"changes":483,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,10 @@\n+\tpublic static String ChartDisplayControlBar_SCALE_TO_FIT_TOOLTIP;\n+\tpublic static String ChartDisplayControlBar_SELECTION_TOOL_TOOLTIP;\n+\tpublic static String ChartDisplayControlBar_ZOOM_IN_CLICK_TOOLTIP;\n+\tpublic static String ChartDisplayControlBar_ZOOM_IN_HOLD_TOOLTIP;\n+\tpublic static String ChartDisplayControlBar_ZOOM_PAN_TOOLTIP;\n+\tpublic static String ChartDisplayControlBar_ZOOM_OUT_CLICK_TOOLTIP;\n+\tpublic static String ChartDisplayControlBar_ZOOM_OUT_HOLD_TOOLTIP;\n+\tpublic static String ChartLaneHeightControls_LANE_HEIGHT_DECREASE_TOOLTIP;\n+\tpublic static String ChartLaneHeightControls_LANE_HEIGHT_INCREASE_TOOLTIP;\n+\tpublic static String ChartLaneHeightControls_OVERVIEW_BUTTON_TOOLTIP;\n@@ -97,0 +107,10 @@\n+\tpublic static String TimeFilter_END_TIME_EXCEEDS_ERROR;\n+\tpublic static String TimeFilter_ERROR;\n+\tpublic static String TimeFilter_FILTER;\n+\tpublic static String TimeFilter_FILTER_EVENTS;\n+\tpublic static String TimeFilter_FROM;\n+\tpublic static String TimeFilter_INVALID_FORMAT_ERROR;\n+\tpublic static String TimeFilter_RESET;\n+\tpublic static String TimeFilter_START_TIME_LONGER_THAN_END_ERROR;\n+\tpublic static String TimeFilter_START_TIME_PRECEEDS_ERROR;\n+\tpublic static String TimeFilter_TO;\n","filename":"application\/org.openjdk.jmc.ui\/src\/main\/java\/org\/openjdk\/jmc\/ui\/misc\/Messages.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.ui.misc;\n+\n+import org.eclipse.swt.graphics.Color;\n+import org.eclipse.swt.widgets.Display;\n+\n+public class PatternFly {\n+\n+\tprivate static final String AWT = \"AWT\";\n+\tprivate static final String SWT = \"SWT\";\n+\n+\t\/**\n+\t * The following color Palette is based on the PatternFly palette for reinforcing application\n+\t * content and workflows. https:\/\/www.patternfly.org\/v3\/styles\/color-palette\/\n+\t *\/\n+\tpublic enum Palette {\n+\t\t\/**\n+\t\t * Primary Colors: Black & Blue\n+\t\t *\/\n+\t\tPF_BLACK(\"#030303\"),\n+\t\tPF_BLACK_100(\"#fafafa\"),\n+\t\tPF_BLACK_150(\"#f5f5f5\"),\n+\t\tPF_BLACK_200(\"#ededed\"),\n+\t\tPF_BLACK_300(\"#d1d1d1\"),\n+\t\tPF_BLACK_400(\"#bbbbbb\"),\n+\t\tPF_BLACK_500(\"#8b8d8f\"),\n+\t\tPF_BLACK_600(\"#72767b\"),\n+\t\tPF_BLACK_700(\"#4d5258\"),\n+\t\tPF_BLACK_800(\"#393f44\"),\n+\t\tPF_BLACK_900(\"#292e34\"),\n+\n+\t\tPF_BLUE(\"#0088ce\"),\n+\t\tPF_BLUE_50(\"#def3ff\"),\n+\t\tPF_BLUE_100(\"#bee1f4\"),\n+\t\tPF_BLUE_200(\"#7dc3e8\"),\n+\t\tPF_BLUE_300(\"#39a5dc\"),\n+\t\tPF_BLUE_400(\"#0088ce\"),\n+\t\tPF_BLUE_500(\"#00659c\"),\n+\t\tPF_BLUE_600(\"#004368\"),\n+\t\tPF_BLUE_700(\"#002235\"),\n+\n+\t\t\/**\n+\t\t * Secondary Colors: Red, Orange, Gold, Light Green, Green, Light Blue, Purple\n+\t\t *\/\n+\t\tPF_RED(\"#8b0000\"),\n+\t\tPF_RED_100(\"#cc0000\"),\n+\t\tPF_RED_200(\"#a30000\"),\n+\t\tPF_RED_300(\"#8b0000\"),\n+\t\tPF_RED_400(\"#470000\"),\n+\t\tPF_RED_500(\"#2c0000\"),\n+\n+\t\tPF_ORANGE(\"#ec7a08\"),\n+\t\tPF_ORANGE_100(\"#fbdebf\"),\n+\t\tPF_ORANGE_200(\"#f7bd7f\"),\n+\t\tPF_ORANGE_300(\"#f39d3c\"),\n+\t\tPF_ORANGE_400(\"#ec7a08\"),\n+\t\tPF_ORANGE_500(\"#b35c00\"),\n+\t\tPF_ORANGE_600(\"#773d00\"),\n+\t\tPF_ORANGE_700(\"#3b1f00\"),\n+\n+\t\tPF_GOLD(\"#f0ab00\"),\n+\t\tPF_GOLD_100(\"#fbeabc\"),\n+\t\tPF_GOLD_200(\"#f9d67a\"),\n+\t\tPF_GOLD_300(\"#f5c12e\"),\n+\t\tPF_GOLD_400(\"#f0ab00\"),\n+\t\tPF_GOLD_500(\"#b58100\"),\n+\t\tPF_GOLD_600(\"#795600\"),\n+\t\tPF_GOLD_700(\"#3d2c00\"),\n+\n+\t\tPF_LIGHT_GREEN(\"#92d400\"),\n+\t\tPF_LIGHT_GREEN_100(\"#e4f5bc\"),\n+\t\tPF_LIGHT_GREEN_200(\"#c8eb79\"),\n+\t\tPF_LIGHT_GREEN_300(\"#ace12e\"),\n+\t\tPF_LIGHT_GREEN_400(\"#92d400\"),\n+\t\tPF_LIGHT_GREEN_500(\"#6ca100\"),\n+\t\tPF_LIGHT_GREEN_600(\"#486b00\"),\n+\t\tPF_LIGHT_GREEN_700(\"#253600\"),\n+\n+\t\tPF_GREEN(\"#3f9c35\"),\n+\t\tPF_GREEN_100(\"#cfe7cd\"),\n+\t\tPF_GREEN_200(\"#9ecf99\"),\n+\t\tPF_GREEN_300(\"#6ec664\"),\n+\t\tPF_GREEN_400(\"#3f9c35\"),\n+\t\tPF_GREEN_500(\"#2d7623\"),\n+\t\tPF_GREEN_600(\"#1e4f18\"),\n+\t\tPF_GREEN_700(\"#0f280d\"),\n+\n+\t\tPF_CYAN(\"#007a87\"),\n+\t\tPF_CYAN_100(\"#bedee1\"),\n+\t\tPF_CYAN_200(\"#7dbdc3\"),\n+\t\tPF_CYAN_300(\"#3a9ca6\"),\n+\t\tPF_CYAN_400(\"#007a87\"),\n+\t\tPF_CYAN_500(\"#005c66\"),\n+\t\tPF_CYAN_600(\"#003d44\"),\n+\t\tPF_CYAN_700(\"#001f22\"),\n+\n+\t\tPF_LIGHT_BLUE(\"#00b9e4\"),\n+\t\tPF_LIGHT_BLUE_100(\"#beedf9\"),\n+\t\tPF_LIGHT_BLUE_200(\"#7cdbf3\"),\n+\t\tPF_LIGHT_BLUE_300(\"#35caed\"),\n+\t\tPF_LIGHT_BLUE_400(\"#00b9e4\"),\n+\t\tPF_LIGHT_BLUE_500(\"#008bad\"),\n+\t\tPF_LIGHT_BLUE_600(\"#005c73\"),\n+\t\tPF_LIGHT_BLUE_700(\"#002d39\"),\n+\n+\t\tPF_PURPLE(\"#703fec\"),\n+\t\tPF_PURPLE_100(\"#c7bfff\"),\n+\t\tPF_PURPLE_200(\"#a18fff\"),\n+\t\tPF_PURPLE_300(\"#8461f7\"),\n+\t\tPF_PURPLE_400(\"#703fec\"),\n+\t\tPF_PURPLE_500(\"#582fc0\"),\n+\t\tPF_PURPLE_600(\"#40199a\"),\n+\t\tPF_PURPLE_700(\"#1f0066\");\n+\n+\t\tprivate final String color;\n+\n+\t\tPalette(String color) {\n+\t\t\tthis.color = color;\n+\t\t}\n+\n+\t\t\/**\n+\t\t * Return a color object of the type corresponding to the constant passed into the method.\n+\t\t * This function first converts the PatternFly color hex value to an AWT Color object. Next,\n+\t\t * it either returns the AWT Color object if the constant type is AWT, or uses the RGB\n+\t\t * values to generate an SWT Color object.\n+\t\t *\n+\t\t * @param type\n+\t\t *            String constant: AWT or SWT\n+\t\t * @return a RGB color (as a regular Object to be casted later)\n+\t\t *\/\n+\t\tprivate Object parseRGB(String type) {\n+\t\t\tjava.awt.Color awtColor = new java.awt.Color(java.awt.Color.decode(this.color).getRGB());\n+\t\t\tswitch (type) {\n+\t\t\tcase (AWT):\n+\t\t\t\treturn awtColor;\n+\t\t\tcase (SWT):\n+\t\t\t\treturn new org.eclipse.swt.graphics.Color(Display.getCurrent(), awtColor.getRed(), awtColor.getGreen(),\n+\t\t\t\t\t\tawtColor.getBlue());\n+\t\t\tdefault:\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t}\n+\n+\t\t\/**\n+\t\t * Converts the PatternFly hex color value to an AWT Color object\n+\t\t * \n+\t\t * @return AWT Color of the selected PatternFly color\n+\t\t *\/\n+\t\tpublic java.awt.Color getAWTColor() {\n+\t\t\treturn (java.awt.Color) parseRGB(AWT);\n+\t\t}\n+\n+\t\t\/**\n+\t\t * Converts the PatternFly hex color value to an SWT Color object\n+\t\t * \n+\t\t * @return SWT Color of the selected PatternFly color\n+\t\t *\/\n+\t\tpublic org.eclipse.swt.graphics.Color getSWTColor() {\n+\t\t\treturn (org.eclipse.swt.graphics.Color) parseRGB(SWT);\n+\t\t}\n+\n+\t\t\/**\n+\t\t * Page & Component Specific Colors\n+\t\t *\/\n+\t\tpublic static Color getThreadsPageBackgroundColor() {\n+\t\t\treturn PF_BLACK_200.getSWTColor();\n+\t\t}\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.ui\/src\/main\/java\/org\/openjdk\/jmc\/ui\/misc\/PatternFly.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"},{"patch":"@@ -0,0 +1,318 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.ui.misc;\n+\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+import org.eclipse.jface.resource.JFaceResources;\n+import org.eclipse.swt.SWT;\n+import org.eclipse.swt.events.ModifyEvent;\n+import org.eclipse.swt.events.ModifyListener;\n+import org.eclipse.swt.layout.GridData;\n+import org.eclipse.swt.layout.GridLayout;\n+import org.eclipse.swt.widgets.Button;\n+import org.eclipse.swt.widgets.Composite;\n+import org.eclipse.swt.widgets.Label;\n+import org.eclipse.swt.widgets.Listener;\n+import org.eclipse.swt.widgets.Text;\n+\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.IRange;\n+import org.openjdk.jmc.common.unit.UnitLookup;\n+import org.openjdk.jmc.ui.charts.XYChart;\n+import org.openjdk.jmc.ui.misc.PatternFly.Palette;\n+\n+public class TimeFilter extends Composite {\n+\n+\tprivate enum FilterType {\n+\t\tSTART, END\n+\t};\n+\n+\tprivate static final String dateFormat = \"yyyy-MM-dd \";\n+\tprivate static final String timeFormat = \"HH:mm:ss:SSS\";\n+\tprivate boolean isMultiDayRecording = false;\n+\tpublic Calendar calendar;\n+\tprivate ChartCanvas chartCanvas;\n+\tprivate XYChart chart;\n+\tprivate SimpleDateFormat sdf;\n+\tprivate SimpleDateFormat dateFormatter = new SimpleDateFormat(dateFormat);\n+\tprivate TimeDisplay startDisplay;\n+\tprivate TimeDisplay endDisplay;\n+\n+\tpublic TimeFilter(Composite parent, IRange<IQuantity> recordingRange, Listener resetListener) {\n+\t\tsuper(parent, SWT.NONE);\n+\t\tthis.setLayout(new GridLayout(7, false));\n+\n+\t\tinspectRecordingRange(recordingRange);\n+\n+\t\tLabel eventsLabel = new Label(this, SWT.LEFT);\n+\t\teventsLabel.setText(Messages.TimeFilter_FILTER_EVENTS);\n+\t\teventsLabel.setFont(JFaceResources.getFontRegistry().get(JFaceResources.BANNER_FONT));\n+\n+\t\tLabel fromLabel = new Label(this, SWT.CENTER);\n+\t\tfromLabel.setText(Messages.TimeFilter_FROM);\n+\n+\t\tstartDisplay = new TimeDisplay(this, FilterType.START, recordingRange.getStart());\n+\n+\t\tLabel toLabel = new Label(this, SWT.CENTER);\n+\t\ttoLabel.setText(Messages.TimeFilter_TO);\n+\n+\t\tendDisplay = new TimeDisplay(this, FilterType.END, recordingRange.getEnd());\n+\n+\t\tButton resetBtn = new Button(this, SWT.PUSH);\n+\t\tresetBtn.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false));\n+\t\tresetBtn.setText(Messages.TimeFilter_RESET);\n+\t\tresetBtn.addListener(SWT.Selection, resetListener);\n+\t}\n+\n+\t\/**\n+\t * Determines whether or not the time range of the recording spans multiple days, and if not,\n+\t * sets up a Calendar object to hold the date of the recording.\n+\t * \n+\t * @param recordingRange\n+\t *\/\n+\tprivate void inspectRecordingRange(IRange<IQuantity> recordingRange) {\n+\t\tlong firstDateEpoch = recordingRange.getStart().in(UnitLookup.EPOCH_MS).longValue();\n+\t\tlong secondDateEpoch = recordingRange.getEnd().in(UnitLookup.EPOCH_MS).longValue();\n+\t\tisMultiDayRecording = !dateFormatter.format(firstDateEpoch).equals(dateFormatter.format(secondDateEpoch));\n+\t\tif (!isMultiDayRecording) {\n+\t\t\tcalendar = Calendar.getInstance();\n+\t\t\tcalendar.setTimeInMillis(firstDateEpoch);\n+\t\t\tcalendar.set(Calendar.HOUR_OF_DAY, 0);\n+\t\t\tcalendar.set(Calendar.MINUTE, 0);\n+\t\t\tcalendar.set(Calendar.SECOND, 0);\n+\t\t\tcalendar.set(Calendar.MILLISECOND, 0);\n+\t\t\tcalendar.add(Calendar.MILLISECOND, calendar.getTimeZone().getRawOffset());\n+\t\t}\n+\t}\n+\n+\tprotected void updateRange() {\n+\t\tchart.setVisibleRange(startDisplay.getCurrentTime(), endDisplay.getCurrentTime());\n+\t\tchartCanvas.redrawChart();\n+\t}\n+\n+\tpublic void setChart(XYChart chart) {\n+\t\tthis.chart = chart;\n+\t}\n+\n+\tpublic void setChartCanvas(ChartCanvas canvas) {\n+\t\tthis.chartCanvas = canvas;\n+\t}\n+\n+\tpublic void setStartTime(IQuantity time) {\n+\t\tstartDisplay.setTime(time);\n+\t}\n+\n+\tpublic void setEndTime(IQuantity time) {\n+\t\tendDisplay.setTime(time);\n+\t}\n+\n+\tprivate class TimeDisplay extends Composite {\n+\n+\t\tprivate boolean bypassModifyListener;\n+\t\tprivate FilterType type;\n+\t\tprivate int lastEventTime;\n+\t\tprivate IQuantity defaultTime;\n+\t\tprivate IQuantity currentTime;\n+\t\tprivate Text timeText;\n+\n+\t\tpublic TimeDisplay(TimeFilter parent, FilterType type, IQuantity defaultTime) {\n+\t\t\tsuper(parent, SWT.NONE);\n+\t\t\tthis.type = type;\n+\t\t\tthis.defaultTime = defaultTime;\n+\t\t\tthis.setLayout(new GridLayout());\n+\t\t\ttimeText = new Text(this, SWT.SEARCH | SWT.SINGLE);\n+\t\t\t\/\/ if the recording spans multiple days, include the date in the time display\n+\t\t\tif (!isMultiDayRecording) {\n+\t\t\t\ttimeText.setTextLimit(12);\n+\t\t\t\tsdf = new SimpleDateFormat(timeFormat);\n+\t\t\t} else {\n+\t\t\t\ttimeText.setTextLimit(23);\n+\t\t\t\tsdf = new SimpleDateFormat(dateFormat + timeFormat);\n+\t\t\t}\n+\t\t\ttimeText.addModifyListener(new ModifyListener() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void modifyText(ModifyEvent e) {\n+\t\t\t\t\tif (getBypassModifyListener()) {\n+\t\t\t\t\t\tsetBypassModifyListener(false);\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t\/**\n+\t\t\t\t\t * If the user edits a Text by highlighting a character and overwrites it with a\n+\t\t\t\t\t * new one, the ModifyListener will fire twice. To prevent validation (and\n+\t\t\t\t\t * potential error dialogs) from occurring twice, compare the time of the\n+\t\t\t\t\t * current ModifyEvent to the last seen ModifyEvent.\n+\t\t\t\t\t *\/\n+\t\t\t\t\tif (e.time == lastEventTime) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tlastEventTime = e.time;\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tString newTimestring = timeText.getText();\n+\t\t\t\t\tif (!isValidSyntax(newTimestring)) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t\tIQuantity newTime = convertStringToIQuantity(newTimestring);\n+\t\t\t\t\tif (currentTime == null || newTime == null) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t\tif (isWithinRange(newTime)) {\n+\t\t\t\t\t\ttimeText.setForeground(Palette.PF_BLACK.getSWTColor());\n+\t\t\t\t\t\tcurrentTime = newTime;\n+\t\t\t\t\t\tparent.updateRange();\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\ttimeText.setForeground(Palette.PF_RED_100.getSWTColor());\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t});\n+\t\t}\n+\n+\t\t\/**\n+\t\t * Converts the IQuantity time to a string and displays it in the Text\n+\t\t * \n+\t\t * @param time\n+\t\t *            IQuantity\n+\t\t *\/\n+\t\tpublic void setTime(IQuantity time) {\n+\t\t\tsetBypassModifyListener(true);\n+\t\t\tString timestring = sdf.format(new Date(time.in(UnitLookup.EPOCH_MS).longValue()));\n+\t\t\tthis.currentTime = time;\n+\t\t\ttimeText.setText(timestring);\n+\t\t\ttimeText.setForeground(Palette.PF_BLACK.getSWTColor());\n+\t\t\tsetBypassModifyListener(false);\n+\t\t}\n+\n+\t\t\/**\n+\t\t * Converts a formatted time string into an IQuantity. If the recording range is within a\n+\t\t * single day, the SimpleDateFormat format will be HH:mm:ss:SSS and need to be added to the\n+\t\t * base date (calendar) in order to calculate the epoch milliseconds.\n+\t\t *\n+\t\t * @param timestring\n+\t\t *            String\n+\t\t * @return IQuantity\n+\t\t *\/\n+\t\tprivate IQuantity convertStringToIQuantity(String timestring) {\n+\t\t\ttry {\n+\t\t\t\tlong parsedTime = sdf.parse(timestring).getTime();\n+\t\t\t\tif (!isMultiDayRecording) {\n+\t\t\t\t\tparsedTime += calendar.getTimeInMillis();\n+\t\t\t\t}\n+\t\t\t\treturn UnitLookup.EPOCH_MS.quantity(parsedTime);\n+\t\t\t} catch (ParseException e) {\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t\/**\n+\t\t * Verify that the passed time is within the recording range\n+\t\t * \n+\t\t * @param time\n+\t\t *            IQuantity\n+\t\t * @return true if the specified time is within the time range of the recording\n+\t\t *\/\n+\t\tprivate boolean isWithinRange(IQuantity time) {\n+\t\t\tif (time == null) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tlong timeMillis = time.in(UnitLookup.EPOCH_MS).longValue();\n+\t\t\tif (type == FilterType.START) {\n+\t\t\t\tif (timeMillis < defaultTime.in(UnitLookup.EPOCH_MS).longValue()) {\n+\t\t\t\t\tDialogToolkit.showWarning(getDisplay().getActiveShell(), Messages.TimeFilter_ERROR,\n+\t\t\t\t\t\t\tMessages.TimeFilter_START_TIME_PRECEEDS_ERROR);\n+\t\t\t\t\treturn false;\n+\t\t\t\t} else if (timeMillis > endDisplay.getDefaultTime().in(UnitLookup.EPOCH_MS).longValue()\n+\t\t\t\t\t\t|| timeMillis > endDisplay.getCurrentTime().in(UnitLookup.EPOCH_MS).longValue()) {\n+\t\t\t\t\tDialogToolkit.showWarning(getDisplay().getActiveShell(), Messages.TimeFilter_ERROR,\n+\t\t\t\t\t\t\tMessages.TimeFilter_START_TIME_LONGER_THAN_END_ERROR);\n+\t\t\t\t\tendDisplay.getDefaultTime().in(UnitLookup.EPOCH_MS).longValue();\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tif (timeMillis > defaultTime.in(UnitLookup.EPOCH_MS).longValue()) {\n+\t\t\t\t\tDialogToolkit.showWarning(getDisplay().getActiveShell(), Messages.TimeFilter_ERROR,\n+\t\t\t\t\t\t\tMessages.TimeFilter_END_TIME_EXCEEDS_ERROR);\n+\t\t\t\t\treturn false;\n+\t\t\t\t} else if (timeMillis < startDisplay.getDefaultTime().in(UnitLookup.EPOCH_MS).longValue()\n+\t\t\t\t\t\t|| timeMillis < startDisplay.getCurrentTime().in(UnitLookup.EPOCH_MS).longValue()) {\n+\t\t\t\t\tDialogToolkit.showWarning(getDisplay().getActiveShell(), Messages.TimeFilter_ERROR,\n+\t\t\t\t\t\t\tMessages.TimeFilter_START_TIME_LONGER_THAN_END_ERROR);\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t\/**\n+\t\t * Verify that the passed time string matches the expected time format\n+\t\t * \n+\t\t * @param formattedTimestring\n+\t\t *            String\n+\t\t * @return true if the text corresponds to the current SimpleDateFormat format\n+\t\t *\/\n+\t\tprivate boolean isValidSyntax(String formattedTimestring) {\n+\t\t\tif (formattedTimestring.length() != timeText.getTextLimit()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\tsdf.parse(formattedTimestring);\n+\t\t\t} catch (ParseException e) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tprivate IQuantity getDefaultTime() {\n+\t\t\treturn defaultTime;\n+\t\t}\n+\n+\t\tprivate IQuantity getCurrentTime() {\n+\t\t\treturn currentTime;\n+\t\t}\n+\n+\t\t\/\/ When programmatically changing the Text (e.g., this.setTime()), use\n+\t\t\/\/ a boolean to prevent the ModifyListener from firing\n+\t\tprivate boolean getBypassModifyListener() {\n+\t\t\treturn this.bypassModifyListener;\n+\t\t}\n+\n+\t\tprivate void setBypassModifyListener(boolean bypassModifyListener) {\n+\t\t\tthis.bypassModifyListener = bypassModifyListener;\n+\t\t}\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.ui\/src\/main\/java\/org\/openjdk\/jmc\/ui\/misc\/TimeFilter.java","additions":318,"deletions":0,"binary":false,"changes":318,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.ui.misc;\n+\n+import java.awt.Graphics2D;\n+\n+import org.eclipse.swt.SWT;\n+import org.eclipse.swt.custom.SashForm;\n+import org.eclipse.swt.events.MouseAdapter;\n+import org.eclipse.swt.events.MouseEvent;\n+import org.eclipse.swt.events.MouseMoveListener;\n+import org.eclipse.swt.events.PaintEvent;\n+import org.eclipse.swt.events.PaintListener;\n+import org.eclipse.swt.graphics.Point;\n+import org.eclipse.swt.graphics.Rectangle;\n+import org.eclipse.swt.widgets.Canvas;\n+import org.eclipse.swt.widgets.Composite;\n+\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.IRange;\n+import org.openjdk.jmc.ui.charts.AWTChartToolkit;\n+import org.openjdk.jmc.ui.charts.SubdividedQuantityRange;\n+import org.openjdk.jmc.ui.charts.XYChart;\n+import org.openjdk.jmc.ui.misc.PatternFly.Palette;\n+\n+public class TimelineCanvas extends Canvas {\n+\tprivate static final int BASE_RANGE_INDICATOR_HEIGHT = 10;\n+\tprivate static final int BASE_RANGE_INDICATOR_Y_OFFSET = 25;\n+\tprivate int rangeIndicatorHeight;\n+\tprivate int rangeIndicatorYOffset;\n+\tprivate int x1;\n+\tprivate int x2;\n+\tprivate int xOffset;\n+\tprivate AwtCanvas awtCanvas;\n+\tprivate ChartCanvas chartCanvas;\n+\tprivate Graphics2D g2d;\n+\tprivate IRange<IQuantity> chartRange;\n+\tprivate Rectangle dragRect;\n+\tprivate Rectangle indicatorRect;\n+\tprivate Rectangle timelineRect;\n+\tprivate SashForm sashForm;\n+\tprivate SubdividedQuantityRange xTickRange;\n+\tprivate XYChart chart;\n+\n+\tpublic TimelineCanvas(Composite parent, ChartCanvas chartCanvas, SashForm sashForm, double yScale) {\n+\t\tsuper(parent, SWT.NONE);\n+\t\tthis.chartCanvas = chartCanvas;\n+\t\tthis.sashForm = sashForm;\n+\t\tawtCanvas = new AwtCanvas();\n+\t\taddPaintListener(new TimelineCanvasPainter());\n+\t\tDragDetector dragDetector = new DragDetector();\n+\t\taddMouseListener(dragDetector);\n+\t\taddMouseMoveListener(dragDetector);\n+\t\trangeIndicatorHeight = (int) (BASE_RANGE_INDICATOR_HEIGHT * yScale);\n+\t\trangeIndicatorYOffset = (int) (BASE_RANGE_INDICATOR_Y_OFFSET * yScale);\n+\t}\n+\n+\tprivate int calculateXOffset() {\n+\t\treturn sashForm.getChildren()[0].getSize().x + sashForm.getSashWidth();\n+\t}\n+\n+\tpublic void renderRangeIndicator(int x1, int x2) {\n+\t\tthis.x1 = x1;\n+\t\tthis.x2 = x2;\n+\t\tthis.redraw();\n+\t}\n+\n+\tpublic void setXTickRange(SubdividedQuantityRange xTickRange) {\n+\t\tthis.xTickRange = xTickRange;\n+\t}\n+\n+\tpublic void setChart(XYChart chart) {\n+\t\tthis.chart = chart;\n+\t\tchartRange = chart.getVisibleRange();\n+\t}\n+\n+\tprivate class TimelineCanvasPainter implements PaintListener {\n+\n+\t\t@Override\n+\t\tpublic void paintControl(PaintEvent e) {\n+\t\t\txOffset = chartCanvas.translateDisplayToImageXCoordinates(calculateXOffset());\n+\n+\t\t\tRectangle rect = getClientArea();\n+\t\t\tg2d = awtCanvas.getGraphics(rect.width, rect.height);\n+\n+\t\t\t\/\/ Draw the background\n+\t\t\tPoint adjusted = chartCanvas.translateDisplayToImageCoordinates(rect.width, rect.height);\n+\t\t\tg2d.setColor(Palette.PF_BLACK_100.getAWTColor());\n+\t\t\tg2d.fillRect(0, 0, adjusted.x, adjusted.y);\n+\n+\t\t\t\/\/ Draw the horizontal axis\n+\t\t\tif (xTickRange != null) {\n+\t\t\t\tg2d.setColor(Palette.PF_BLACK.getAWTColor());\n+\t\t\t\tAWTChartToolkit.drawAxis(g2d, xTickRange, 0, false, 1, false, xOffset);\n+\t\t\t}\n+\n+\t\t\t\/\/ Draw the range indicator\n+\t\t\tindicatorRect = dragRect != null ? dragRect\n+\t\t\t\t\t: new Rectangle(x1 + xOffset,\n+\t\t\t\t\t\t\tchartCanvas.translateDisplayToImageYCoordinates(rangeIndicatorYOffset), x2 - x1,\n+\t\t\t\t\t\t\tchartCanvas.translateDisplayToImageYCoordinates(rangeIndicatorHeight));\n+\t\t\tdragRect = null;\n+\t\t\tg2d.setPaint(Palette.PF_ORANGE_400.getAWTColor());\n+\t\t\tg2d.fillRect(indicatorRect.x, indicatorRect.y, indicatorRect.width, indicatorRect.height);\n+\n+\t\t\tPoint totalSize = sashForm.getChildren()[1].getSize();\n+\t\t\tadjusted = chartCanvas.translateDisplayToImageCoordinates(totalSize.x, totalSize.y);\n+\t\t\ttimelineRect = new Rectangle(xOffset,\n+\t\t\t\t\tchartCanvas.translateDisplayToImageYCoordinates(rangeIndicatorYOffset), adjusted.x,\n+\t\t\t\t\tchartCanvas.translateDisplayToImageYCoordinates(rangeIndicatorHeight));\n+\t\t\tg2d.setPaint(Palette.PF_BLACK_600.getAWTColor());\n+\t\t\tg2d.drawRect(timelineRect.x, timelineRect.y, timelineRect.width, timelineRect.height);\n+\n+\t\t\tawtCanvas.paint(e, 0, 0);\n+\t\t}\n+\t}\n+\n+\tprivate class DragDetector extends MouseAdapter implements MouseMoveListener {\n+\n+\t\tboolean isDrag = false;\n+\t\tPoint currentSelection;\n+\t\tPoint lastSelection;\n+\n+\t\t@Override\n+\t\tpublic void mouseDown(MouseEvent e) {\n+\t\t\te.x = chartCanvas.translateDisplayToImageXCoordinates(e.x);\n+\t\t\te.y = chartCanvas.translateDisplayToImageYCoordinates(e.y);\n+\t\t\tif (isDrag || e.button == 1 && timelineRect.contains(e.x, e.y)) {\n+\t\t\t\tisDrag = true;\n+\t\t\t\tcurrentSelection = new Point(e.x, e.y);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void mouseUp(MouseEvent e) {\n+\t\t\tisDrag = false;\n+\t\t\tchart.setIsZoomPanDrag(false);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void mouseMove(MouseEvent e) {\n+\t\t\te.x = chartCanvas.translateDisplayToImageXCoordinates(e.x);\n+\t\t\te.y = chartCanvas.translateDisplayToImageYCoordinates(e.y);\n+\t\t\tif (timelineRect.contains(e.x, e.y)) {\n+\t\t\t\tsetCursor(getDisplay().getSystemCursor(SWT.CURSOR_HAND));\n+\t\t\t} else {\n+\t\t\t\tsetCursor(getDisplay().getSystemCursor(SWT.CURSOR_ARROW));\n+\t\t\t}\n+\t\t\tif (isDrag) {\n+\t\t\t\tlastSelection = currentSelection;\n+\t\t\t\tchart.setIsZoomPanDrag(true);\n+\t\t\t\tcurrentSelection = new Point(e.x, e.y);\n+\t\t\t\tint xdiff = currentSelection.x - lastSelection.x;\n+\t\t\t\tupdateTimelineIndicatorFromDrag(xdiff);\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate void updateTimelineIndicatorFromDrag(int xdiff) {\n+\t\t\tif (xdiff != 0 && (indicatorRect.x + xdiff) >= timelineRect.x\n+\t\t\t\t\t&& (indicatorRect.x + xdiff + indicatorRect.width) <= timelineRect.x + timelineRect.width) {\n+\t\t\t\tindicatorRect.x = indicatorRect.x + xdiff;\n+\t\t\t\tSubdividedQuantityRange xAxis = new SubdividedQuantityRange(chartRange.getStart(), chartRange.getEnd(),\n+\t\t\t\t\t\ttimelineRect.width, 1);\n+\t\t\t\tchart.setVisibleRange(xAxis.getQuantityAtPixel(indicatorRect.x - xOffset),\n+\t\t\t\t\t\txAxis.getQuantityAtPixel(indicatorRect.x - xOffset + indicatorRect.width));\n+\t\t\t\tdragRect = indicatorRect;\n+\t\t\t\tchartCanvas.redrawChart();\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.ui\/src\/main\/java\/org\/openjdk\/jmc\/ui\/misc\/TimelineCanvas.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,0 +153,8 @@\n+\n+\tpublic static int openAndHideCancelButton(IWizardPage wp, int width, int height) {\n+\t\tOnePageWizardDialog d = new OnePageWizardDialog(Display.getCurrent().getActiveShell(), wp);\n+\t\td.setHideCancelButton(true);\n+\t\td.setWidthConstraint(width, width);\n+\t\td.setHeightConstraint(height, height);\n+\t\treturn d.open();\n+\t}\n","filename":"application\/org.openjdk.jmc.ui\/src\/main\/java\/org\/openjdk\/jmc\/ui\/wizards\/OnePageWizardDialog.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-#  Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,10 @@\n+ChartDisplayControlBar_SCALE_TO_FIT_TOOLTIP=Scale-to-Fit\n+ChartDisplayControlBar_SELECTION_TOOL_TOOLTIP=Selection Tool\n+ChartDisplayControlBar_ZOOM_IN_CLICK_TOOLTIP=Click: Toggle Click-to-Zoom-In mode\n+ChartDisplayControlBar_ZOOM_IN_HOLD_TOOLTIP=Hold: Continuous Zoom-In\n+ChartDisplayControlBar_ZOOM_PAN_TOOLTIP=Toggle Zoom-Pan Display\n+ChartDisplayControlBar_ZOOM_OUT_CLICK_TOOLTIP=Click: Toggle Click-to-Zoom-Out mode\n+ChartDisplayControlBar_ZOOM_OUT_HOLD_TOOLTIP=Hold: Continuous Zoom-Out\n+ChartLaneHeightControls_LANE_HEIGHT_DECREASE_TOOLTIP=Decrease thread lane height\n+ChartLaneHeightControls_LANE_HEIGHT_INCREASE_TOOLTIP=Increase thread lane height\n+ChartLaneHeightControls_OVERVIEW_BUTTON_TOOLTIP=Toggle Overview Mode\n@@ -98,0 +108,10 @@\n+TimeFilter_END_TIME_EXCEEDS_ERROR=The selected end time exceeds the range of the recording.\n+TimeFilter_ERROR=Time Filter Error\n+TimeFilter_FILTER=Filter\n+TimeFilter_FILTER_EVENTS=Filter Events\n+TimeFilter_FROM=From\n+TimeFilter_INVALID_FORMAT_ERROR=Invalid time format\n+TimeFilter_RESET=Reset\n+TimeFilter_START_TIME_LONGER_THAN_END_ERROR=The selected start time exceeds the specified end time.\n+TimeFilter_START_TIME_PRECEEDS_ERROR=The selected start time precedes the range of the recording.\n+TimeFilter_TO=to\n","filename":"application\/org.openjdk.jmc.ui\/src\/main\/resources\/org\/openjdk\/jmc\/ui\/misc\/messages.properties","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-public class JfrThreadsPageTest extends MCJemmyTestBase {\n+public class JfrThreadsPageLegacyTest extends MCJemmyTestBase {\n@@ -61,2 +61,2 @@\n-\t\t\tJfrUi.openJfr(materialize(\"jfr\", PLAIN_JFR, JfrThreadsPageTest.class));\n-\t\t\tJfrNavigator.selectTab(JfrUi.Tabs.THREADS);\n+\t\t\tJfrUi.openJfr(materialize(\"jfr\", PLAIN_JFR, JfrThreadsPageLegacyTest.class));\n+\t\t\tJfrNavigator.selectTab(JfrUi.Tabs.THREADS_LEGACY);\n","filename":"application\/uitests\/org.openjdk.jmc.flightrecorder.uitest\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/uitest\/JfrThreadsPageLegacyTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"application\/uitests\/org.openjdk.jmc.flightrecorder.uitest\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/uitest\/JfrThreadsPageTest.java","status":"copied"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Red Hat Inc. All rights reserved.\n@@ -36,0 +36,7 @@\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Supplier;\n+\n@@ -44,0 +51,1 @@\n+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCButton;\n@@ -45,0 +53,1 @@\n+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCSashForm;\n@@ -46,0 +55,4 @@\n+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCText;\n+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCTextCanvas;\n+import org.openjdk.jmc.test.jemmy.misc.wrappers.MCToolBar;\n+import org.openjdk.jmc.ui.UIPlugin;\n@@ -51,0 +64,8 @@\n+\tprivate static final String OK_BUTTON = \"OK\";\n+\tprivate static final String RESET_BUTTON = \"Reset\";\n+\tprivate static final String START_TIME = \"08:06:19:489\";\n+\tprivate static final String NEW_START_TIME = \"08:06:19:500\";\n+\tprivate static final String INVALID_START_TIME = \"08:06:19:480\";\n+\tprivate static final String INVALID_END_TIME = \"08:07:19:733\";\n+\tprivate static final String FOLD_CHART = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_FOLD_CHART_TOOLTIP;\n+\tprivate static final String FOLD_TABLE = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_FOLD_TABLE_TOOLTIP;\n@@ -53,0 +74,3 @@\n+\tprivate static final String SHOW_CHART = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_SHOW_CHART_TOOLTIP;\n+\tprivate static final String SHOW_TABLE = org.openjdk.jmc.flightrecorder.ui.messages.internal.Messages.ThreadsPage_SHOW_TABLE_TOOLTIP;\n+\tprivate static final String TIME_FILTER_ERROR = org.openjdk.jmc.ui.misc.Messages.TimeFilter_ERROR;\n@@ -55,0 +79,2 @@\n+\tprivate static MCSashForm sashForm;\n+\tprivate static MCTextCanvas textCanvas;\n@@ -56,0 +82,2 @@\n+\tprivate static MCToolBar toolbar;\n+\tprivate boolean selected;\n@@ -63,1 +91,2 @@\n-\t\t\tthreadsTable = MCTable.getByColumnHeader(TABLE_COLUMN_HEADER);\n+\t\t\ttoolbar = MCToolBar.getByToolTip(SHOW_TABLE);\n+\t\t\ttoolbar.clickToolItem(SHOW_TABLE);\n@@ -65,0 +94,4 @@\n+\t\t\ttextCanvas = MCTextCanvas.getTextCanvas();\n+\t\t\tselected = false;\n+\t\t\tsashForm = MCSashForm.getMCSashForm();\n+\t\t\tthreadsTable = MCTable.getByColumnHeader(TABLE_COLUMN_HEADER);\n@@ -69,0 +102,2 @@\n+\t\t\tselected = false;\n+\t\t\ttoolbar.clickToolItem(FOLD_TABLE);\n@@ -73,0 +108,88 @@\n+\t@Test\n+\tpublic void testTextCanvasSelection() throws InterruptedException, ExecutionException, TimeoutException {\n+\t\tthreadsTable.selectItems(0, 0);\n+\t\tAssert.assertEquals(1, threadsTable.getSelectionCount());\n+\n+\t\tCompletableFuture<Void> future = new CompletableFuture<>();\n+\t\tCompletableFuture.supplyAsync(new Supplier<Void>() {\n+\n+\t\t\t@Override\n+\t\t\tpublic Void get() {\n+\t\t\t\ttextCanvas.setSelectionListener(() -> {\n+\t\t\t\t\tselected = !selected;\n+\t\t\t\t\tfuture.complete(null);\n+\t\t\t\t});\n+\t\t\t\ttextCanvas.clickTextCanvas();\n+\t\t\t\treturn future.join();\n+\t\t\t}\n+\n+\t\t}).get(10, TimeUnit.SECONDS);\n+\n+\t\tAssert.assertTrue(selected);\n+\t}\n+\n+\t@Test\n+\tpublic void testZoom() {\n+\t\tMCText startTimeField = MCText.getByText(START_TIME);\n+\t\tMCButton zoomInBtn = MCButton.getByImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_IN));\n+\t\tMCButton zoomOutBtn = MCButton.getByImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_ZOOM_OUT));\n+\n+\t\t\/\/ zoom with display bar\n+\t\tAssert.assertEquals(START_TIME, startTimeField.getText());\n+\t\tzoomInBtn.click();\n+\t\tchartCanvas.clickChart();\n+\t\tAssert.assertNotEquals(START_TIME, startTimeField.getText());\n+\n+\t\tzoomOutBtn.click();\n+\t\tchartCanvas.clickChart();\n+\t\tAssert.assertEquals(START_TIME, startTimeField.getText());\n+\n+\t\t\/\/ zoom with controls\n+\t\tchartCanvas.clickChart();\n+\t\tchartCanvas.keyboardZoomIn();\n+\t\tAssert.assertNotEquals(START_TIME, startTimeField.getText());\n+\n+\t\tchartCanvas.keyboardZoomOut();\n+\t\tAssert.assertEquals(START_TIME, startTimeField.getText());\n+\t}\n+\n+\t@Test\n+\tpublic void testResetButtons() {\n+\t\tMCText StartTimeField = MCText.getByText(START_TIME);\n+\t\tMCButton resetBtn = MCButton.getByLabel(RESET_BUTTON);\n+\t\tMCButton scaleToFitBtn = MCButton.getByImage(UIPlugin.getDefault().getImage(UIPlugin.ICON_FA_SCALE_TO_FIT));\n+\n+\t\tStartTimeField.setText(NEW_START_TIME);\n+\t\tAssert.assertNotEquals(START_TIME, StartTimeField.getText());\n+\n+\t\tresetBtn.click();\n+\t\tAssert.assertEquals(START_TIME, StartTimeField.getText());\n+\n+\t\tStartTimeField.setText(NEW_START_TIME);\n+\t\tAssert.assertNotEquals(START_TIME, StartTimeField.getText());\n+\n+\t\tscaleToFitBtn.click();\n+\t\tAssert.assertEquals(START_TIME, StartTimeField.getText());\n+\t}\n+\n+\t@Test\n+\tpublic void testTimeFilterInvalid() {\n+\t\tMCText startTimeField = MCText.getByText(START_TIME);\n+\t\tMCText endTimeField = MCText.getByText(START_TIME);\n+\t\tMCButton resetBtn = MCButton.getByLabel(RESET_BUTTON);\n+\n+\t\tstartTimeField.setText(INVALID_START_TIME);\n+\t\tMCButton okButton = MCButton.getByLabel(TIME_FILTER_ERROR, OK_BUTTON);\n+\t\tAssert.assertNotNull(okButton);\n+\t\tokButton.click();\n+\n+\t\tMCButton.focusMc();\n+\t\tresetBtn.click();\n+\t\tAssert.assertEquals(START_TIME, startTimeField.getText());\n+\n+\t\tendTimeField.setText(INVALID_END_TIME);\n+\t\tokButton = MCButton.getByLabel(TIME_FILTER_ERROR, OK_BUTTON);\n+\t\tAssert.assertNotNull(okButton);\n+\t\tokButton.click();\n+\t}\n+\n@@ -76,0 +199,1 @@\n+\n@@ -88,0 +212,1 @@\n+\t\tchartCanvas = MCChartCanvas.getChartCanvas();\n@@ -95,0 +220,1 @@\n+\n@@ -96,0 +222,1 @@\n+\n@@ -115,0 +242,1 @@\n+\t\tchartCanvas = MCChartCanvas.getChartCanvas();\n@@ -118,0 +246,66 @@\n+\n+\t@Test\n+\tpublic void testFoldingChart() {\n+\t\t\/\/ Sash weights should both be non-zero to display the chart and table\n+\t\tAssert.assertTrue(sashForm.getWeights()[0] != 0 && sashForm.getWeights()[1] != 0);\n+\n+\t\t\/\/ Sash weight corresponding to the chart should be zero when folded\n+\t\ttoolbar.clickToolItem(FOLD_CHART);\n+\t\tAssert.assertTrue(sashForm.getWeights()[0] != 0 && sashForm.getWeights()[1] == 0);\n+\n+\t\t\/\/ When unfolded, the sash weights should be non-zero\n+\t\ttoolbar.clickToolItem(SHOW_CHART);\n+\t\tAssert.assertTrue(sashForm.getWeights()[0] != 0 && sashForm.getWeights()[1] != 0);\n+\t}\n+\n+\t@Test\n+\tpublic void testFoldingTable() {\n+\t\t\/\/ Sash weights should both be non-zero to display the chart and table\n+\t\tAssert.assertTrue(sashForm.getWeights()[0] != 0 && sashForm.getWeights()[1] != 0);\n+\n+\t\t\/\/ Sash weight corresponding to the table should be zero when folded\n+\t\ttoolbar.clickToolItem(FOLD_TABLE);\n+\t\tAssert.assertTrue(sashForm.getWeights()[0] == 0 && sashForm.getWeights()[1] != 0);\n+\n+\t\t\/\/ When unfolded, the sash weights should be non-zero\n+\t\ttoolbar.clickToolItem(SHOW_TABLE);\n+\t\tAssert.assertTrue(sashForm.getWeights()[0] != 0 && sashForm.getWeights()[1] != 0);\n+\t}\n+\n+\t@Test\n+\tpublic void testInvalidFoldingActions() {\n+\t\ttoolbar.clickToolItem(FOLD_TABLE);\n+\t\tint[] weights = sashForm.getWeights();\n+\t\ttoolbar.clickToolItem(FOLD_CHART);\n+\t\t\/\/ If the table is already folded, the fold chart action shouldn't work\n+\t\tAssert.assertTrue(Arrays.equals(weights, sashForm.getWeights()));\n+\t\ttoolbar.clickToolItem(SHOW_TABLE);\n+\n+\t\ttoolbar.clickToolItem(FOLD_CHART);\n+\t\tweights = sashForm.getWeights();\n+\t\ttoolbar.clickToolItem(FOLD_TABLE);\n+\t\t\/\/ If the chart is already folded, the fold table action shouldn't work\n+\t\tAssert.assertTrue(Arrays.equals(weights, sashForm.getWeights()));\n+\n+\t\t\/\/ Bring back the chart before retiring\n+\t\ttoolbar.clickToolItem(SHOW_CHART);\n+\t}\n+\n+\t@Test\n+\tpublic void testPersistingSashWeights() {\n+\t\t\/\/ Fold the table away\n+\t\ttoolbar.clickToolItem(FOLD_TABLE);\n+\t\tint[] weights = sashForm.getWeights();\n+\t\tAssert.assertTrue(sashForm.getWeights()[0] == 0 && sashForm.getWeights()[1] != 0);\n+\t\tMCMenu.closeActiveEditor();\n+\n+\t\t\/\/ Re-open the JFR file & verify the table is still folded\n+\t\tJfrUi.openJfr(materialize(\"jfr\", PLAIN_JFR, JfrThreadsPageTest.class));\n+\t\tJfrNavigator.selectTab(JfrUi.Tabs.THREADS);\n+\t\tsashForm = MCSashForm.getMCSashForm();\n+\t\tAssert.assertTrue(Arrays.equals(weights, sashForm.getWeights()));\n+\n+\t\t\/\/ Bring back the table before retiring\n+\t\ttoolbar = MCToolBar.getByToolTip(SHOW_TABLE);\n+\t\ttoolbar.clickToolItem(SHOW_TABLE);\n+\t}\n","filename":"application\/uitests\/org.openjdk.jmc.flightrecorder.uitest\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/uitest\/JfrThreadsPageTest.java","additions":197,"deletions":3,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -216,0 +216,11 @@\n+\t\/**\n+\t * Gets a shell by text\n+\t *\n+\t * @param text\n+\t *            the text string to lookup the shell with\n+\t * @return the associated shell\n+\t *\/\n+\tprotected static Wrap<? extends Shell> getShellByText(String text) {\n+\t\treturn Shells.SHELLS.lookup(Shell.class, new ByTextShell<>(text)).wrap();\n+\t}\n+\n","filename":"application\/uitests\/org.openjdk.jmc.test.jemmy\/src\/test\/java\/org\/openjdk\/jmc\/test\/jemmy\/misc\/base\/wrappers\/MCJemmyBase.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+\t\tTHREADS_LEGACY,\n@@ -110,0 +111,3 @@\n+\t\t\tcase THREADS_LEGACY:\n+\t\t\t\ttabText = new String[] {\"Java Application\", \"Threads\", \"(Legacy) Threads\"};\n+\t\t\t\tbreak;\n","filename":"application\/uitests\/org.openjdk.jmc.test.jemmy\/src\/test\/java\/org\/openjdk\/jmc\/test\/jemmy\/misc\/wrappers\/JfrUi.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import org.eclipse.swt.graphics.Image;\n@@ -63,0 +64,39 @@\n+\t\/**\n+\t * Finds a button in the supplied shell by image and returns it.\n+\t *\n+\t * @param shell\n+\t *            the shell where to search for the button\n+\t * @param image\n+\t *            the image to look up the button with\n+\t * @return a {@link MCButton} (possibly null)\n+\t *\/\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic static MCButton getByImage(Wrap<? extends Shell> shell, Image image) {\n+\t\tList<Wrap<? extends Button>> allVisibleButtonWraps = getVisible(\n+\t\t\t\tshell.as(Parent.class, Button.class).lookup(Button.class));\n+\t\tfor (final Wrap<? extends Button> buttonWrap : allVisibleButtonWraps) {\n+\t\t\tFetcher<Image> fetcher = new Fetcher<Image>() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic void run() {\n+\t\t\t\t\tsetOutput(buttonWrap.getControl().getImage());\n+\t\t\t\t}\n+\t\t\t};\n+\t\t\tDisplay.getDefault().syncExec(fetcher);\n+\t\t\tif (image.equals(fetcher.getOutput())) {\n+\t\t\t\treturn new MCButton(buttonWrap);\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t\/**\n+\t * Finds a button in the default Mission Control shell and returns it.\n+\t *\n+\t * @param image\n+\t *            the image of the button\n+\t * @return a {@link MCButton} in the default shell matching the image.\n+\t *\/\n+\tpublic static MCButton getByImage(Image image) {\n+\t\treturn getByImage(getShell(), image);\n+\t}\n+\n@@ -98,0 +138,13 @@\n+\t\/**\n+\t * Finds a button in a shell with the given text and returns it.\n+\t *\n+\t * @param label\n+\t *            the label string of the button\n+\t * @param shellText\n+\t *            the text to look up the shell that the button is contained in\n+\t * @return a {@link MCButton} in the shell matching the label\n+\t *\/\n+\tpublic static MCButton getByLabel(String shellText, String label) {\n+\t\treturn getByLabel(getShellByText(shellText), label);\n+\t}\n+\n","filename":"application\/uitests\/org.openjdk.jmc.test.jemmy\/src\/test\/java\/org\/openjdk\/jmc\/test\/jemmy\/misc\/wrappers\/MCButton.java","additions":54,"deletions":1,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Red Hat Inc. All rights reserved.\n@@ -47,0 +47,2 @@\n+import org.jemmy.interfaces.Keyboard.KeyboardButtons;\n+import org.jemmy.interfaces.Mouse.MouseButtons;\n@@ -112,0 +114,25 @@\n+\t\/**\n+\t * Click the center of the chart in the ChartCanvas\n+\t *\/\n+\tpublic void clickChart() {\n+\t\tDisplay.getDefault().syncExec(() -> {\n+\t\t\tcontrol.mouse().click(1, getRelativeClickPoint(), MouseButtons.BUTTON1);\n+\t\t});\n+\t}\n+\n+\t\/**\n+\t * Zoom in the chart with keyboard controls\n+\t *\/\n+\tpublic void keyboardZoomIn() {\n+\t\tcontrol.keyboard().pushKey(KeyboardButtons.UP);\n+\t\twaitForIdle();\n+\t}\n+\n+\t\/**\n+\t * Zoom out the chart with keyboard controls\n+\t *\/\n+\tpublic void keyboardZoomOut() {\n+\t\tcontrol.keyboard().pushKey(KeyboardButtons.DOWN);\n+\t\twaitForIdle();\n+\t}\n+\n@@ -132,1 +159,2 @@\n-\t\t\t\tsetOutput(new Point(control.getScreenBounds().x \/ 2, control.getScreenBounds().y \/ 2));\n+\t\t\t\tsetOutput(new Point(control.getControl().getParent().getSize().x \/ 2,\n+\t\t\t\t\t\tcontrol.getControl().getParent().getSize().y \/ 2));\n","filename":"application\/uitests\/org.openjdk.jmc.test.jemmy\/src\/test\/java\/org\/openjdk\/jmc\/test\/jemmy\/misc\/wrappers\/MCChartCanvas.java","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.test.jemmy.misc.wrappers;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.swt.custom.SashForm;\n+import org.eclipse.swt.widgets.Display;\n+import org.eclipse.swt.widgets.Shell;\n+import org.jemmy.control.Wrap;\n+import org.jemmy.interfaces.Parent;\n+import org.openjdk.jmc.test.jemmy.misc.base.wrappers.MCJemmyBase;\n+import org.openjdk.jmc.test.jemmy.misc.fetchers.Fetcher;\n+\n+\/**\n+ * The Jemmy wrapper for the Mission Control SashForm.\n+ *\/\n+public class MCSashForm extends MCJemmyBase {\n+\n+\tprivate MCSashForm(Wrap<? extends SashForm> formWrap) {\n+\t\tthis.control = formWrap;\n+\t}\n+\n+\t\/**\n+\t * Returns all visible {@link MCSashForm} objects underneath the supplied shell\n+\t *\n+\t * @param shell\n+\t *            the shell from where to start the search for the SashForm object\n+\t * @return a {@link List} of {@link MCSashForm} objects\n+\t *\/\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic static List<MCSashForm> getAll(Wrap<? extends Shell> shell) {\n+\t\tList<Wrap<? extends SashForm>> list = getVisible(shell.as(Parent.class, SashForm.class).lookup(SashForm.class));\n+\t\tList<MCSashForm> sashForms = new ArrayList<MCSashForm>();\n+\t\tfor (int i = 0; i < list.size(); i++) {\n+\t\t\tsashForms.add(new MCSashForm(list.get(i)));\n+\t\t}\n+\t\treturn sashForms;\n+\t}\n+\n+\t\/**\n+\t * Returns the first visible {@link MCSashForm} object underneath the supplied shell\n+\t *\n+\t * @param shell\n+\t *            the shell from where to start the search for the SashForm object\n+\t * @return a {@link MCSashForm} object\n+\t *\/\n+\tpublic static MCSashForm getFirst(Wrap<? extends Shell> shell) {\n+\t\treturn getAll(shell).get(0);\n+\t}\n+\n+\t\/**\n+\t * Returns the first visible {@link MCSashForm} object underneath the Mission Control main shell\n+\t *\n+\t * @return a {@link MCSashForm} object\n+\t *\/\n+\tpublic static MCSashForm getMCSashForm() {\n+\t\treturn getFirst(getShell());\n+\t}\n+\n+\t\/**\n+\t * Returns the current weights of the SashForm\n+\t *\n+\t * @return the Sash Weights\n+\t *\/\n+\tpublic int[] getWeights() {\n+\t\tFetcher<int[]> fetcher = new Fetcher<int[]>() {\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\tsetOutput(((SashForm) control.getControl()).getWeights());\n+\t\t\t}\n+\t\t};\n+\t\tDisplay.getDefault().syncExec(fetcher);\n+\t\treturn fetcher.getOutput();\n+\t}\n+}\n","filename":"application\/uitests\/org.openjdk.jmc.test.jemmy\/src\/test\/java\/org\/openjdk\/jmc\/test\/jemmy\/misc\/wrappers\/MCSashForm.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -281,0 +281,13 @@\n+\t\/**\n+\t * Finds tables by column header (first match only)\n+\t *\n+\t * @param shellText\n+\t *            text to look up the shell that contains the table\n+\t * @param headerName\n+\t *            the name of the column header\n+\t * @return a {@link MCTable}\n+\t *\/\n+\tpublic static MCTable getByColumnHeader(String shellText, String headerName) {\n+\t\treturn getByColumnHeader(getShellByText(shellText), headerName);\n+\t}\n+\n@@ -518,0 +531,18 @@\n+\t\/**\n+\t * Gets the number of items selected in the table\n+\t *\n+\t * @return the number of items selected in the table\n+\t *\/\n+\tpublic int getSelectionCount() {\n+\t\tfinal Table table = getWrap().getControl();\n+\t\tFetcher<Integer> fetcher = new Fetcher<Integer>() {\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\tint count = table.getSelectionCount();\n+\t\t\t\tsetOutput(count);\n+\t\t\t}\n+\t\t};\n+\t\tDisplay.getDefault().syncExec(fetcher);\n+\t\treturn fetcher.getOutput().intValue();\n+\t}\n+\n","filename":"application\/uitests\/org.openjdk.jmc.test.jemmy\/src\/test\/java\/org\/openjdk\/jmc\/test\/jemmy\/misc\/wrappers\/MCTable.java","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.test.jemmy.misc.wrappers;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.swt.graphics.Rectangle;\n+import org.eclipse.swt.widgets.Display;\n+import org.eclipse.swt.widgets.Shell;\n+import org.openjdk.jmc.test.jemmy.misc.base.wrappers.MCJemmyBase;\n+import org.openjdk.jmc.test.jemmy.misc.fetchers.Fetcher;\n+import org.openjdk.jmc.ui.misc.ChartTextCanvas;\n+import org.jemmy.Point;\n+import org.jemmy.control.Wrap;\n+import org.jemmy.interfaces.Mouse.MouseButtons;\n+import org.jemmy.interfaces.Parent;\n+\n+\/**\n+ * The Jemmy wrapper for the Mission Control Text Canvas.\n+ *\/\n+public class MCTextCanvas extends MCJemmyBase {\n+\tprivate MCTextCanvas(Wrap<? extends ChartTextCanvas> textCanvasWrap) {\n+\t\tthis.control = textCanvasWrap;\n+\t}\n+\n+\t\/**\n+\t * Returns all visible {@link MCtextCanvas} objects underneath the supplied shell\n+\t *\n+\t * @param shell\n+\t *            the shell from where to start the search for the ChartTextCanvas object\n+\t * @return a {@link List} of {@link MCtextCanvas} objects\n+\t *\/\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic static List<MCTextCanvas> getAll(Wrap<? extends Shell> shell) {\n+\t\tList<Wrap<? extends ChartTextCanvas>> list = getVisible(\n+\t\t\t\tshell.as(Parent.class, ChartTextCanvas.class).lookup(ChartTextCanvas.class));\n+\t\tList<MCTextCanvas> canvases = new ArrayList<>();\n+\t\tfor (int i = 0; i < list.size(); i++) {\n+\t\t\tcanvases.add(new MCTextCanvas(list.get(i)));\n+\t\t}\n+\t\treturn canvases;\n+\t}\n+\n+\t\/**\n+\t * Returns the first visible {@link MCtextCanvas} object underneath the supplied shell\n+\t *\n+\t * @param shell\n+\t *            the shell from where to start the search for the ChartTextCanvas object\n+\t * @return a {@link MCtextCanvas} object\n+\t *\/\n+\tpublic static MCTextCanvas getFirst(Wrap<? extends Shell> shell) {\n+\t\treturn getAll(shell).get(0);\n+\t}\n+\n+\t\/**\n+\t * Returns the first visible {@link MCTextCanvas} object underneath the Mission Control main\n+\t * shell\n+\t *\n+\t * @return a {@link MCTextCanvas} object\n+\t *\/\n+\tpublic static MCTextCanvas getTextCanvas() {\n+\t\treturn getFirst(getShell());\n+\t}\n+\n+\t\/**\n+\t * Sets a selection listener for the Text Canvas\n+\t *\n+\t * @param listener\n+\t *            the selection listener to be set\n+\t *\/\n+\tpublic void setSelectionListener(Runnable listener) {\n+\t\tChartTextCanvas.class.cast(control.getControl()).setSelectionListener(listener);\n+\t}\n+\n+\t\/**\n+\t * Click the middle thread listed in the Text Canvas\n+\t *\/\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic void clickTextCanvas() {\n+\t\tDisplay.getDefault().syncExec(() -> {\n+\t\t\tcontrol.mouse().click(1, getRelativeClickPoint(), MouseButtons.BUTTON1);\n+\t\t});\n+\t}\n+\n+\t\/**\n+\t * Calculates the click point of the Text Canvas\n+\t *\n+\t * @return the Point of the Text Canvas\n+\t *\/\n+\tprivate Point getRelativeClickPoint() {\n+\t\tFetcher<Point> fetcher = new Fetcher<Point>() {\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\tRectangle clientArea = ChartTextCanvas.class.cast(control.getControl()).getClientArea();\n+\t\t\t\tsetOutput(new Point(clientArea.width \/ 2, clientArea.height \/ 2));\n+\t\t\t}\n+\t\t};\n+\t\tDisplay.getDefault().syncExec(fetcher);\n+\t\treturn fetcher.getOutput();\n+\t}\n+\n+}\n","filename":"application\/uitests\/org.openjdk.jmc.test.jemmy\/src\/test\/java\/org\/openjdk\/jmc\/test\/jemmy\/misc\/wrappers\/MCTextCanvas.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -2042,0 +2042,63 @@\n+\n+%% The following notice is provided with respect to FontAwesome,\n+which may be included with this product in the form of icons.\n+\n+Font Awesome Free License\n+-------------------------\n+\n+Font Awesome Free is free, open source, and GPL friendly. You can use it for\n+commercial projects, open source projects, or really almost whatever you want.\n+Full Font Awesome Free license: https:\/\/fontawesome.com\/license\/free.\n+\n+# Icons: CC BY 4.0 License (https:\/\/creativecommons.org\/licenses\/by\/4.0\/)\n+In the Font Awesome Free download, the CC BY 4.0 license applies to all icons\n+packaged as SVG and JS file types.\n+\n+# Fonts: SIL OFL 1.1 License (https:\/\/scripts.sil.org\/OFL)\n+In the Font Awesome Free download, the SIL OFL license applies to all icons\n+packaged as web and desktop font files.\n+\n+# Code: MIT License (https:\/\/opensource.org\/licenses\/MIT)\n+In the Font Awesome Free download, the MIT license applies to all non-font and\n+non-icon files.\n+\n+# Attribution\n+Attribution is required by MIT, SIL OFL, and CC BY licenses. Downloaded Font\n+Awesome Free files already contain embedded comments with sufficient\n+attribution, so you shouldn't need to do anything additional when using these\n+files normally.\n+\n+We've kept attribution comments terse, so we ask that you do not actively work\n+to remove them from files, especially code. They're a great way for folks to\n+learn about Font Awesome.\n+\n+# Brand Icons\n+All brand icons are trademarks of their respective owners. The use of these\n+trademarks does not indicate endorsement of the trademark holder by Font\n+Awesome, nor vice versa. **Please do not use brand logos for any purpose except\n+to represent the company, product, or service to which they refer.**\n+\n+%% The following notice is provided with respect to PatternFly,\n+whose color palette may be included with this product.\n+\n+MIT License\n+\n+Copyright (c) 2019 Red Hat, Inc.\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE.\n","filename":"license\/THIRDPARTYREADME.txt","additions":63,"deletions":0,"binary":false,"changes":63,"status":"modified"}]}