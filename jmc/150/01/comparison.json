{"files":[{"patch":"@@ -245,0 +245,9 @@\n+\tpublic static IRange<IQuantity> union(IRange<IQuantity> a, IRange<IQuantity> b) {\n+\t\tIQuantity minStart = a.getStart().compareTo(b.getStart()) < 0 ? a.getStart() : b.getStart();\n+\t\tIQuantity maxEnd = a.getEnd().compareTo(b.getEnd()) < 0 ? b.getEnd() : a.getEnd();\n+\t\tif (intersection(a, b) == null) { \/\/ if disjoint, no union\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn createWithEnd(minStart, maxEnd);\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/unit\/QuantityRange.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.common.test.unit;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.IRange;\n+import org.openjdk.jmc.common.unit.QuantityRange;\n+import org.openjdk.jmc.common.unit.UnitLookup;\n+\n+public class QuantityRangeTest {\n+\n+\t@Test\n+\tpublic void intersection_overlap() {\n+\t\tIRange<IQuantity> r1 = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(0),\n+\t\t\t\tUnitLookup.SECOND.quantity(10));\n+\t\tIRange<IQuantity> r2 = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(5),\n+\t\t\t\tUnitLookup.SECOND.quantity(15));\n+\t\tIRange<IQuantity> intersection = QuantityRange.intersection(r1, r2);\n+\t\tIRange<IQuantity> expected = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(5),\n+\t\t\t\tUnitLookup.SECOND.quantity(10));\n+\t\tAssert.assertEquals(expected, intersection);\n+\t}\n+\n+\t@Test\n+\tpublic void intersection_full_overlap() {\n+\t\tIRange<IQuantity> r1 = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(0),\n+\t\t\t\tUnitLookup.SECOND.quantity(10));\n+\t\tIRange<IQuantity> r2 = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(0),\n+\t\t\t\tUnitLookup.SECOND.quantity(10));\n+\t\tIRange<IQuantity> intersection = QuantityRange.intersection(r1, r2);\n+\t\tIRange<IQuantity> expected = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(0),\n+\t\t\t\tUnitLookup.SECOND.quantity(10));\n+\t\tAssert.assertEquals(expected, intersection);\n+\t}\n+\n+\t@Test\n+\tpublic void intersection_limit() {\n+\t\tIRange<IQuantity> r1 = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(0),\n+\t\t\t\tUnitLookup.SECOND.quantity(10));\n+\t\tIRange<IQuantity> r2 = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(10),\n+\t\t\t\tUnitLookup.SECOND.quantity(20));\n+\t\tIRange<IQuantity> intersection = QuantityRange.intersection(r1, r2);\n+\t\tIRange<IQuantity> expected = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(10),\n+\t\t\t\tUnitLookup.SECOND.quantity(10));\n+\t\tAssert.assertEquals(expected, intersection);\n+\t}\n+\n+\t@Test\n+\tpublic void intersection_disjoint() {\n+\t\tIRange<IQuantity> r1 = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(0),\n+\t\t\t\tUnitLookup.SECOND.quantity(5));\n+\t\tIRange<IQuantity> r2 = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(10),\n+\t\t\t\tUnitLookup.SECOND.quantity(15));\n+\t\tIRange<IQuantity> intersection = QuantityRange.intersection(r1, r2);\n+\t\tAssert.assertNull(intersection);\n+\t}\n+\n+\t@Test\n+\tpublic void union_overlap() {\n+\t\tIRange<IQuantity> r1 = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(0),\n+\t\t\t\tUnitLookup.SECOND.quantity(10));\n+\t\tIRange<IQuantity> r2 = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(5),\n+\t\t\t\tUnitLookup.SECOND.quantity(15));\n+\t\tIRange<IQuantity> union = QuantityRange.union(r1, r2);\n+\t\tIRange<IQuantity> expected = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(0),\n+\t\t\t\tUnitLookup.SECOND.quantity(15));\n+\t\tAssert.assertEquals(expected, union);\n+\t}\n+\n+\t@Test\n+\tpublic void union_full_overlap() {\n+\t\tIRange<IQuantity> r1 = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(0),\n+\t\t\t\tUnitLookup.SECOND.quantity(10));\n+\t\tIRange<IQuantity> r2 = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(0),\n+\t\t\t\tUnitLookup.SECOND.quantity(10));\n+\t\tIRange<IQuantity> union = QuantityRange.union(r1, r2);\n+\t\tIRange<IQuantity> expected = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(0),\n+\t\t\t\tUnitLookup.SECOND.quantity(10));\n+\t\tAssert.assertEquals(expected, union);\n+\t}\n+\n+\t@Test\n+\tpublic void union_limit() {\n+\t\tIRange<IQuantity> r1 = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(0),\n+\t\t\t\tUnitLookup.SECOND.quantity(10));\n+\t\tIRange<IQuantity> r2 = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(10),\n+\t\t\t\tUnitLookup.SECOND.quantity(20));\n+\t\tIRange<IQuantity> union = QuantityRange.union(r1, r2);\n+\t\tIRange<IQuantity> expected = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(0),\n+\t\t\t\tUnitLookup.SECOND.quantity(20));\n+\t\tAssert.assertEquals(expected, union);\n+\t}\n+\n+\t@Test\n+\tpublic void union_disjoint() {\n+\t\tIRange<IQuantity> r1 = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(0),\n+\t\t\t\tUnitLookup.SECOND.quantity(5));\n+\t\tIRange<IQuantity> r2 = QuantityRange.createWithEnd(UnitLookup.SECOND.quantity(10),\n+\t\t\t\tUnitLookup.SECOND.quantity(15));\n+\t\tIRange<IQuantity> union = QuantityRange.union(r1, r2);\n+\t\tAssert.assertNull(union);\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.common.test\/src\/test\/java\/org\/openjdk\/jmc\/common\/test\/unit\/QuantityRangeTest.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"}]}