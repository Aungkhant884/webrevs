{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-\tpublic static final String Result_SHORT_RECORDING = \"Result_SHORT_RECORDING\";; \/\/$NON-NLS-1$\n+\tpublic static final String Result_SHORT_RECORDING = \"Result_SHORT_RECORDING\"; \/\/$NON-NLS-1$\n@@ -49,0 +49,1 @@\n+\tpublic static final String RulesToolkit_EVALUATION_ERROR_DESCRIPTION = \"RulesToolkit_EVALUATION_ERROR_DESCRIPTION\"; \/\/$NON-NLS-1$\n@@ -50,0 +51,1 @@\n+\tpublic static final String RulesToolkit_RULE_IGNORED = \"RulesToolkit_RULE_IGNORED\"; \/\/$NON-NLS-1$\n@@ -60,0 +62,1 @@\n+\tpublic static final String RulesToolkit_RULE_RESULT_RETRIEVAL_ERROR = \"RulesToolkit_RULE_RESULT_RETRIEVAL_ERROR\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/messages\/internal\/Messages.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+import java.util.concurrent.CompletableFuture;\n@@ -55,0 +56,2 @@\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n@@ -83,0 +86,1 @@\n+import org.openjdk.jmc.common.util.Pair;\n@@ -91,0 +95,1 @@\n+import org.openjdk.jmc.flightrecorder.rules.DependsOn;\n@@ -95,0 +100,1 @@\n+import org.openjdk.jmc.flightrecorder.rules.ResultProvider;\n@@ -1211,0 +1217,1 @@\n+\t\tResultProvider resultProvider = new ResultProvider();\n@@ -1213,0 +1220,3 @@\n+\t\t\/\/ Map using the rule name as a key, and a Pair containing the rule (left) and it's dependency (right)\n+\t\tMap<String, Pair<IRule, IRule>> rulesWithDependencies = new HashMap<>();\n+\t\tMap<IRule, IResult> computedResults = new HashMap<>();\n@@ -1214,3 +1224,46 @@\n-\t\t\tRunnableFuture<IResult> resultFuture = rule.createEvaluation(items, preferences, null);\n-\t\t\tresultFutures.put(rule, resultFuture);\n-\t\t\tfutureQueue.add(resultFuture);\n+\t\t\tif (matchesEventAvailabilityMap(items, rule.getRequiredEvents())) {\n+\t\t\t\tif (hasDependency(rule)) {\n+\t\t\t\t\tIRule depRule = rules.stream().filter(r -> r.getId().equals(getRuleDependencyName(rule)))\n+\t\t\t\t\t\t\t.findFirst().orElse(null);\n+\t\t\t\t\trulesWithDependencies.put(rule.getId(), new Pair<>(rule, depRule));\n+\t\t\t\t} else {\n+\t\t\t\t\tRunnableFuture<IResult> resultFuture = rule.createEvaluation(items, preferences, resultProvider);\n+\t\t\t\t\tresultFutures.put(rule, resultFuture);\n+\t\t\t\t\tfutureQueue.add(resultFuture);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tresultFutures.put(rule, CompletableFuture.completedFuture(getNotApplicableResult(rule, preferences,\n+\t\t\t\t\t\tMessages.getString(Messages.RulesToolkit_RULE_IGNORED))));\n+\t\t\t}\n+\t\t}\n+\t\tfor (String ruleName : rulesWithDependencies.keySet()) {\n+\t\t\tIRule rule = rulesWithDependencies.get(ruleName).left;\n+\t\t\tIRule depRule = rulesWithDependencies.get(ruleName).right;\n+\t\t\tFuture<IResult> depResultFuture = resultFutures.get(depRule);\n+\t\t\tif (depResultFuture == null) {\n+\t\t\t\tresultFutures.put(rule, CompletableFuture.completedFuture(getNotApplicableResult(rule, preferences,\n+\t\t\t\t\t\tMessages.getString(Messages.RulesToolkit_EVALUATION_ERROR_DESCRIPTION))));\n+\t\t\t} else {\n+\t\t\t\tIResult depResult = null;\n+\t\t\t\tif (!depResultFuture.isDone()) {\n+\t\t\t\t\t((Runnable) depResultFuture).run();\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tdepResult = depResultFuture.get();\n+\t\t\t\t\t\tresultProvider.addResults(depResult);\n+\t\t\t\t\t\tcomputedResults.put(depRule, depResult);\n+\t\t\t\t\t} catch (InterruptedException | ExecutionException e) {\n+\t\t\t\t\t\tLogger.getLogger(RulesToolkit.class.getName()).log(Level.WARNING, MessageFormat\n+\t\t\t\t\t\t\t\t.format(Messages.getString(Messages.RulesToolkit_RULE_RESULT_RETRIEVAL_ERROR), e));\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tdepResult = computedResults.get(depRule);\n+\t\t\t\t}\n+\t\t\t\tif (depResult != null && shouldEvaluate(rule, depResult)) {\n+\t\t\t\t\tRunnableFuture<IResult> resultFuture = rule.createEvaluation(items, preferences, resultProvider);\n+\t\t\t\t\tresultFutures.put(rule, resultFuture);\n+\t\t\t\t\tfutureQueue.add(resultFuture);\n+\t\t\t\t} else {\n+\t\t\t\t\tresultFutures.put(rule, CompletableFuture.completedFuture(getNotApplicableResult(rule, preferences,\n+\t\t\t\t\t\t\tMessages.getString(Messages.RulesToolkit_RULE_IGNORED))));\n+\t\t\t\t}\n+\t\t\t}\n@@ -1226,0 +1279,32 @@\n+\tprivate static boolean hasDependency(IRule rule) {\n+\t\tDependsOn dependency = rule.getClass().getAnnotation(DependsOn.class);\n+\t\treturn dependency != null;\n+\t}\n+\n+\tprivate static String getRuleDependencyName(IRule rule) {\n+\t\tDependsOn dependency = rule.getClass().getAnnotation(DependsOn.class);\n+\t\tClass<? extends IRule> dependencyType = dependency.value();\n+\t\treturn dependencyType.getSimpleName();\n+\t}\n+\n+\t\/**\n+\t * Checks to see if a rule should be evaluated based on the severity value of its dependency's\n+\t * result severity value.\n+\t * \n+\t * @param rule\n+\t *            rule to check severity value against its dependency's severity\n+\t * @param depResult\n+\t *            result from the rule's dependency\n+\t * @return true if the dependency rule result satisfies the severity requirement for the passed\n+\t *         rule\n+\t *\/\n+\tprivate static boolean shouldEvaluate(IRule rule, IResult depResult) {\n+\t\tDependsOn dependency = rule.getClass().getAnnotation(DependsOn.class);\n+\t\tif (dependency != null) {\n+\t\t\tif (depResult.getSeverity().compareTo(dependency.severity()) < 0) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/util\/RulesToolkit.java","additions":89,"deletions":4,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-#  Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+RulesToolkit_EVALUATION_ERROR_DESCRIPTION=Could not evaluate this rule\n@@ -38,0 +39,1 @@\n+RulesToolkit_RULE_IGNORED=Ignored\n@@ -58,0 +60,1 @@\n+RulesToolkit_RULE_RESULT_RETRIEVAL_ERROR=Unexpected problem retrieving rule result.\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/messages\/internal\/messages.properties","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -12,1 +12,2 @@\n- org.openjdk.jmc.flightrecorder.rules\n+ org.openjdk.jmc.flightrecorder.test,\n+ org.openjdk.jmc.flightrecorder.rules,\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.test\/META-INF\/MANIFEST.MF","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-   Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+   Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,5 @@\n+                   <artifactId>flightrecorder.test<\/artifactId>\n+                   <version>${project.version}<\/version>\n+           <\/dependency>\n+           <dependency>\n+                   <groupId>org.openjdk.jmc<\/groupId>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.test\/pom.xml","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n@@ -42,0 +45,2 @@\n+import org.openjdk.jmc.flightrecorder.CouldNotLoadRecordingException;\n+import org.openjdk.jmc.flightrecorder.rules.report.html.JfrHtmlRulesReport;\n@@ -43,0 +48,1 @@\n+import org.openjdk.jmc.flightrecorder.test.util.RecordingToolkit;\n@@ -83,0 +89,11 @@\n+\n+\t@Test\n+\tpublic void testJfrHtmlRulesReportGeneration() {\n+\t\tString report = \"\";\n+\t\ttry {\n+\t\t\treport = JfrHtmlRulesReport.createReport(RecordingToolkit.getNamedRecording(\"8u60.jfr\"));\n+\t\t} catch (IOException | CouldNotLoadRecordingException e) {\n+\t\t\tfail();\n+\t\t}\n+\t\tassert (!report.isEmpty());\n+\t}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.test\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/RulesToolkitTest.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"}]}