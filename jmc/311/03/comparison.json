{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+\tpublic static final String RulesToolkit_EVALUATION_ERROR_DESCRIPTION = \"RulesToolkit_EVALUATION_ERROR_DESCRIPTION\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/messages\/internal\/Messages.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+import java.util.concurrent.CompletableFuture;\n@@ -55,0 +56,2 @@\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n@@ -91,0 +94,1 @@\n+import org.openjdk.jmc.flightrecorder.rules.DependsOn;\n@@ -95,0 +99,1 @@\n+import org.openjdk.jmc.flightrecorder.rules.ResultProvider;\n@@ -1211,0 +1216,1 @@\n+\t\tResultProvider resultProvider = new ResultProvider();\n@@ -1213,0 +1219,2 @@\n+\t\tList<IRule> unavailableRules = new ArrayList<>();\n+\t\tList<IRule> rulesWithDependencies = new ArrayList<>();\n@@ -1214,3 +1222,45 @@\n-\t\t\tRunnableFuture<IResult> resultFuture = rule.createEvaluation(items, preferences, null);\n-\t\t\tresultFutures.put(rule, resultFuture);\n-\t\t\tfutureQueue.add(resultFuture);\n+\t\t\tif (matchesEventAvailabilityMap(items, rule.getRequiredEvents())) {\n+\t\t\t\tif (hasDependency(rule)) {\n+\t\t\t\t\trulesWithDependencies.add(rule);\n+\t\t\t\t} else {\n+\t\t\t\t\tRunnableFuture<IResult> resultFuture = rule.createEvaluation(items, preferences, resultProvider);\n+\t\t\t\t\tresultFutures.put(rule, resultFuture);\n+\t\t\t\t\tfutureQueue.add(resultFuture);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tunavailableRules.add(rule);\n+\t\t\t\tresultFutures.put(rule, evaluationErrorResult(rule, preferences));\n+\t\t\t}\n+\t\t}\n+\t\tfor (IRule rule : rulesWithDependencies) {\n+\t\t\tString dependencyName = getRuleDependencyName(rule);\n+\t\t\tboolean shouldEvaluate = true;\n+\t\t\tfor (IRule unavailableRule : unavailableRules) {\n+\t\t\t\tif (dependencyName.equals(unavailableRule.getId())) {\n+\t\t\t\t\tshouldEvaluate = false;\n+\t\t\t\t\tresultFutures.put(rule, evaluationErrorResult(rule, preferences));\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (shouldEvaluate) {\n+\t\t\t\tIRule depRule = rules.stream().filter(r -> r.getId().equals(dependencyName)).findFirst().orElse(null);\n+\t\t\t\tFuture<IResult> depResultFuture = resultFutures.get(depRule);\n+\t\t\t\tif (depResultFuture != null) {\n+\t\t\t\t\tif (!depResultFuture.isDone()) {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\t((Runnable) depResultFuture).run();\n+\t\t\t\t\t\t\tIResult result = depResultFuture.get();\n+\t\t\t\t\t\t\tresultProvider.addResults(result);\n+\t\t\t\t\t\t} catch (InterruptedException | ExecutionException e) {\n+\t\t\t\t\t\t\tLogger.getLogger(RulesToolkit.class.getName()).log(Level.WARNING,\n+\t\t\t\t\t\t\t\t\t\"Unexpected problem evaluating rule dependency.\", e); \/\/$NON-NLS-1$\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (depResultFuture.isDone()) {\n+\t\t\t\t\t\tRunnableFuture<IResult> resultFuture = rule.createEvaluation(items, preferences,\n+\t\t\t\t\t\t\t\tresultProvider);\n+\t\t\t\t\t\tresultFutures.put(rule, resultFuture);\n+\t\t\t\t\t\tfutureQueue.add(resultFuture);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n@@ -1226,0 +1276,28 @@\n+\t\/**\n+\t * For rules that are not evaluated (due to event availability map mismatch, or missing\n+\t * dependencies), create and return a completed future IResult that can be used for the rules\n+\t * report.\n+\t * \n+\t * @param rule\n+\t *            rule to create an evaluation error result for\n+\t * @param preferences\n+\t *            provider of configuration values used by the ResultBuilder\n+\t * @return a completed future containing an evaluation error result\n+\t *\/\n+\tprivate static Future<IResult> evaluationErrorResult(IRule rule, IPreferenceValueProvider preferences) {\n+\t\tIResult result = ResultBuilder.createFor(rule, preferences).setSeverity(Severity.NA)\n+\t\t\t\t.setSummary(Messages.getString(Messages.RulesToolkit_EVALUATION_ERROR_DESCRIPTION)).build();\n+\t\treturn CompletableFuture.completedFuture(result);\n+\t}\n+\n+\tprivate static boolean hasDependency(IRule rule) {\n+\t\tDependsOn dependency = rule.getClass().getAnnotation(DependsOn.class);\n+\t\treturn dependency != null ? true : false;\n+\t}\n+\n+\tprivate static String getRuleDependencyName(IRule rule) {\n+\t\tDependsOn dependency = rule.getClass().getAnnotation(DependsOn.class);\n+\t\tClass<? extends IRule> dependencyType = dependency.value();\n+\t\treturn dependencyType.getSimpleName();\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/util\/RulesToolkit.java","additions":82,"deletions":4,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-#  Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+RulesToolkit_EVALUATION_ERROR_DESCRIPTION=Could not evaluate this rule\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/messages\/internal\/messages.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -12,1 +12,2 @@\n- org.openjdk.jmc.flightrecorder.rules\n+ org.openjdk.jmc.flightrecorder.test,\n+ org.openjdk.jmc.flightrecorder.rules,\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.test\/META-INF\/MANIFEST.MF","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-   Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+   Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,5 @@\n+                   <artifactId>flightrecorder.test<\/artifactId>\n+                   <version>${project.version}<\/version>\n+           <\/dependency>\n+           <dependency>\n+                   <groupId>org.openjdk.jmc<\/groupId>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.test\/pom.xml","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,3 @@\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n@@ -42,0 +45,2 @@\n+import org.openjdk.jmc.flightrecorder.CouldNotLoadRecordingException;\n+import org.openjdk.jmc.flightrecorder.rules.report.html.JfrHtmlRulesReport;\n@@ -43,0 +48,1 @@\n+import org.openjdk.jmc.flightrecorder.test.util.RecordingToolkit;\n@@ -83,0 +89,11 @@\n+\n+\t@Test\n+\tpublic void testJfrHtmlRulesReportGeneration() {\n+\t\tString report = \"\";\n+\t\ttry {\n+\t\t\treport = JfrHtmlRulesReport.createReport(RecordingToolkit.getNamedRecording(\"8u60.jfr\"));\n+\t\t} catch (IOException | CouldNotLoadRecordingException e) {\n+\t\t\tfail();\n+\t\t}\n+\t\tassert (!report.isEmpty());\n+\t}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.test\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/RulesToolkitTest.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"}]}