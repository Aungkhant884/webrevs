{"files":[{"patch":"@@ -46,1 +46,1 @@\n-\tpublic static final String Result_SHORT_RECORDING = \"Result_SHORT_RECORDING\";; \/\/$NON-NLS-1$\n+\tpublic static final String Result_SHORT_RECORDING = \"Result_SHORT_RECORDING\"; \/\/$NON-NLS-1$\n@@ -51,0 +51,1 @@\n+\tpublic static final String RulesToolkit_RULE_IGNORED = \"RulesToolkit_RULE_IGNORED\"; \/\/$NON-NLS-1$\n@@ -61,0 +62,1 @@\n+\tpublic static final String RulesToolkit_RULE_RESULT_RETRIEVAL_ERROR = \"RulesToolkit_RULE_RESULT_RETRIEVAL_ERROR\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/messages\/internal\/Messages.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+import org.openjdk.jmc.common.util.Pair;\n@@ -1219,2 +1220,3 @@\n-\t\tList<IRule> unavailableRules = new ArrayList<>();\n-\t\tList<IRule> rulesWithDependencies = new ArrayList<>();\n+\t\t\/\/ Map using the rule name as a key, and a Pair containing the rule (left) and it's dependency (right)\n+\t\tMap<String, Pair<IRule, IRule>> rulesWithDependencies = new HashMap<>();\n+\t\tMap<IRule, IResult> computedResults = new HashMap<>();\n@@ -1224,1 +1226,3 @@\n-\t\t\t\t\trulesWithDependencies.add(rule);\n+\t\t\t\t\tIRule depRule = rules.stream().filter(r -> r.getId().equals(getRuleDependencyName(rule)))\n+\t\t\t\t\t\t\t.findFirst().orElse(null);\n+\t\t\t\t\trulesWithDependencies.put(rule.getId(), new Pair<>(rule, depRule));\n@@ -1231,2 +1235,2 @@\n-\t\t\t\tunavailableRules.add(rule);\n-\t\t\t\tresultFutures.put(rule, evaluationErrorResult(rule, preferences));\n+\t\t\t\tresultFutures.put(rule, CompletableFuture.completedFuture(getNotApplicableResult(rule, preferences,\n+\t\t\t\t\t\tMessages.getString(Messages.RulesToolkit_RULE_IGNORED))));\n@@ -1235,29 +1239,18 @@\n-\t\tfor (IRule rule : rulesWithDependencies) {\n-\t\t\tString dependencyName = getRuleDependencyName(rule);\n-\t\t\tboolean shouldEvaluate = true;\n-\t\t\tfor (IRule unavailableRule : unavailableRules) {\n-\t\t\t\tif (dependencyName.equals(unavailableRule.getId())) {\n-\t\t\t\t\tshouldEvaluate = false;\n-\t\t\t\t\tresultFutures.put(rule, evaluationErrorResult(rule, preferences));\n-\t\t\t\t\tbreak;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (shouldEvaluate) {\n-\t\t\t\tIRule depRule = rules.stream().filter(r -> r.getId().equals(dependencyName)).findFirst().orElse(null);\n-\t\t\t\tFuture<IResult> depResultFuture = resultFutures.get(depRule);\n-\t\t\t\tif (depResultFuture != null) {\n-\t\t\t\t\tif (!depResultFuture.isDone()) {\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\t((Runnable) depResultFuture).run();\n-\t\t\t\t\t\t\tIResult result = depResultFuture.get();\n-\t\t\t\t\t\t\tresultProvider.addResults(result);\n-\t\t\t\t\t\t} catch (InterruptedException | ExecutionException e) {\n-\t\t\t\t\t\t\tLogger.getLogger(RulesToolkit.class.getName()).log(Level.WARNING,\n-\t\t\t\t\t\t\t\t\t\"Unexpected problem evaluating rule dependency.\", e); \/\/$NON-NLS-1$\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tif (depResultFuture.isDone()) {\n-\t\t\t\t\t\tRunnableFuture<IResult> resultFuture = rule.createEvaluation(items, preferences,\n-\t\t\t\t\t\t\t\tresultProvider);\n-\t\t\t\t\t\tresultFutures.put(rule, resultFuture);\n-\t\t\t\t\t\tfutureQueue.add(resultFuture);\n+\t\tfor (String ruleName : rulesWithDependencies.keySet()) {\n+\t\t\tIRule rule = rulesWithDependencies.get(ruleName).left;\n+\t\t\tIRule depRule = rulesWithDependencies.get(ruleName).right;\n+\t\t\tFuture<IResult> depResultFuture = resultFutures.get(depRule);\n+\t\t\tif (depResultFuture == null) {\n+\t\t\t\tresultFutures.put(rule, CompletableFuture.completedFuture(getNotApplicableResult(rule, preferences,\n+\t\t\t\t\t\tMessages.getString(Messages.RulesToolkit_EVALUATION_ERROR_DESCRIPTION))));\n+\t\t\t} else {\n+\t\t\t\tIResult depResult = null;\n+\t\t\t\tif (!depResultFuture.isDone()) {\n+\t\t\t\t\t((Runnable) depResultFuture).run();\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tdepResult = depResultFuture.get();\n+\t\t\t\t\t\tresultProvider.addResults(depResult);\n+\t\t\t\t\t\tcomputedResults.put(depRule, depResult);\n+\t\t\t\t\t} catch (InterruptedException | ExecutionException e) {\n+\t\t\t\t\t\tLogger.getLogger(RulesToolkit.class.getName()).log(Level.WARNING, MessageFormat\n+\t\t\t\t\t\t\t\t.format(Messages.getString(Messages.RulesToolkit_RULE_RESULT_RETRIEVAL_ERROR), e));\n@@ -1265,0 +1258,10 @@\n+\t\t\t\t} else {\n+\t\t\t\t\tdepResult = computedResults.get(depRule);\n+\t\t\t\t}\n+\t\t\t\tif (depResult != null && shouldEvaluate(rule, depResult)) {\n+\t\t\t\t\tRunnableFuture<IResult> resultFuture = rule.createEvaluation(items, preferences, resultProvider);\n+\t\t\t\t\tresultFutures.put(rule, resultFuture);\n+\t\t\t\t\tfutureQueue.add(resultFuture);\n+\t\t\t\t} else {\n+\t\t\t\t\tresultFutures.put(rule, CompletableFuture.completedFuture(getNotApplicableResult(rule, preferences,\n+\t\t\t\t\t\t\tMessages.getString(Messages.RulesToolkit_RULE_IGNORED))));\n@@ -1276,17 +1279,0 @@\n-\t\/**\n-\t * For rules that are not evaluated (due to event availability map mismatch, or missing\n-\t * dependencies), create and return a completed future IResult that can be used for the rules\n-\t * report.\n-\t * \n-\t * @param rule\n-\t *            rule to create an evaluation error result for\n-\t * @param preferences\n-\t *            provider of configuration values used by the ResultBuilder\n-\t * @return a completed future containing an evaluation error result\n-\t *\/\n-\tprivate static Future<IResult> evaluationErrorResult(IRule rule, IPreferenceValueProvider preferences) {\n-\t\tIResult result = ResultBuilder.createFor(rule, preferences).setSeverity(Severity.NA)\n-\t\t\t\t.setSummary(Messages.getString(Messages.RulesToolkit_EVALUATION_ERROR_DESCRIPTION)).build();\n-\t\treturn CompletableFuture.completedFuture(result);\n-\t}\n-\n@@ -1295,1 +1281,1 @@\n-\t\treturn dependency != null ? true : false;\n+\t\treturn dependency != null;\n@@ -1304,0 +1290,21 @@\n+\t\/**\n+\t * Checks to see if a rule should be evaluated based on the severity value of its dependency's\n+\t * result severity value.\n+\t * \n+\t * @param rule\n+\t *            rule to check severity value against its dependency's severity\n+\t * @param depResult\n+\t *            result from the rule's dependency\n+\t * @return true if the dependency rule result satisfies the severity requirement for the passed\n+\t *         rule\n+\t *\/\n+\tprivate static boolean shouldEvaluate(IRule rule, IResult depResult) {\n+\t\tDependsOn dependency = rule.getClass().getAnnotation(DependsOn.class);\n+\t\tif (dependency != null) {\n+\t\t\tif (depResult.getSeverity().compareTo(dependency.severity()) < 0) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/util\/RulesToolkit.java","additions":59,"deletions":52,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+RulesToolkit_RULE_IGNORED=Ignored\n@@ -59,0 +60,1 @@\n+RulesToolkit_RULE_RESULT_RETRIEVAL_ERROR=Unexpected problem retrieving rule result.\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/messages\/internal\/messages.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}