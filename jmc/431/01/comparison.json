{"files":[{"patch":"@@ -61,2 +61,1 @@\n-\tprivate final int pageSize;\n-\tprivate Object[][] pages;\n+\tprivate Page[] pages;\n@@ -66,1 +65,1 @@\n-\t * Constructs a map with O(1) access up to index 5000.\n+\t * Constructs a map with O(1) access up to approximately index 5000.\n@@ -69,1 +68,14 @@\n-\t\tthis(100, 50);\n+\t\tthis(5000);\n+\t}\n+\n+\t\/**\n+\t * Constructs a map with O(1) access up to index {@code expectedSize}.\n+\t *\n+\t * @param expectedSize\n+\t *            - the maximum number of elements expected to be inserted into the map before\n+\t *            overflowing to slower storage.\n+\t *\/\n+\tpublic FastAccessNumberMap(int expectedSize) {\n+\t\t\/\/ round up to the next multiple of Page.SIZE\n+\t\tthis.pagesUpperLimit = (expectedSize + Page.SIZE - 1) & -Page.SIZE;\n+\t\tthis.pages = new Page[1];\n@@ -81,3 +93,1 @@\n-\t\tthis.pagesUpperLimit = pageSize * maxPageCount;\n-\t\tthis.pageSize = pageSize;\n-\t\tthis.pages = new Object[1][];\n+\t\tthis(pageSize * maxPageCount);\n@@ -86,1 +96,1 @@\n-\tprivate Object[] getPage(int pageIndex) {\n+\tprivate Page getPage(int pageIndex) {\n@@ -90,1 +100,1 @@\n-\t\tObject[] page = pages[pageIndex];\n+\t\tPage page = pages[pageIndex];\n@@ -92,1 +102,1 @@\n-\t\t\tpage = new Object[pageSize];\n+\t\t\tpage = new Page();\n@@ -100,1 +110,2 @@\n-\t\tObject value = getPage(index \/ pageSize)[index % pageSize];\n+\t\t\/\/ masking by Page.SIZE - 1 is equivalent to % Page.SIZE\n+\t\tObject value = getPage(index \/ Page.SIZE).get(index & (Page.SIZE - 1));\n@@ -107,1 +118,2 @@\n-\t\tgetPage(index \/ pageSize)[index % pageSize] = object;\n+\t\t\/\/ masking by Page.SIZE - 1 is equivalent to % Page.SIZE\n+\t\tgetPage(index \/ Page.SIZE).set(index & (Page.SIZE - 1), object);\n@@ -152,2 +164,2 @@\n-\t\t\tIterator<Object[]> pageIterator = IteratorToolkit.of(pages);\n-\t\t\tIterator<Object> elementIterator;\n+\t\t\tIterator<Page> pageIterator = IteratorToolkit.of(pages);\n+\t\t\tPageIteratorFlyweight elementIterator = new PageIteratorFlyweight();\n@@ -160,1 +172,1 @@\n-\t\t\t\t\tif (elementIterator == null || !elementIterator.hasNext()) {\n+\t\t\t\t\tif (!elementIterator.hasNext()) {\n@@ -162,1 +174,1 @@\n-\t\t\t\t\t\t\tObject[] nextPage = pageIterator.next();\n+\t\t\t\t\t\t\tPage nextPage = pageIterator.next();\n@@ -164,1 +176,1 @@\n-\t\t\t\t\t\t\t\telementIterator = IteratorToolkit.of(nextPage);\n+\t\t\t\t\t\t\t\telementIterator.wrap(nextPage);\n@@ -196,1 +208,51 @@\n-}\n+\n+\tprivate static final class Page {\n+\t\t\/\/ choose a fixed power of 2 so that divisions and mods can be replaced by shifts and masks\n+\t\tpublic static final int SIZE = 64;\n+\t\tprivate long mask;\n+\t\tprivate final Object[] values;\n+\n+\t\tPage() {\n+\t\t\tthis.values = new Object[SIZE];\n+\t\t}\n+\n+\t\tpublic Object get(int index) {\n+\t\t\treturn values[index];\n+\t\t}\n+\n+\t\tpublic void set(int index, Object value) {\n+\t\t\tvalues[index] = value;\n+\t\t\t\/\/ mark presence of the element so iteration can skip nulls quickly\n+\t\t\tmask |= (1L << index);\n+\t\t}\n+\t}\n+\n+\tprivate static final class PageIteratorFlyweight implements Iterator<Object> {\n+\t\tprivate long mask;\n+\t\tprivate Object[] values;\n+\n+\t\tpublic void wrap(Page page) {\n+\t\t\tthis.mask = page.mask;\n+\t\t\tthis.values = page.values;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean hasNext() {\n+\t\t\t\/\/ when there are no bits left, the page has been iterated entirely\n+\t\t\treturn mask != 0;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Object next() {\n+\t\t\t\/\/ get the index of the lowest bit, then switch it off\n+\t\t\tint index = Long.numberOfTrailingZeros(mask);\n+\t\t\tmask &= (mask - 1);\n+\t\t\treturn values[index];\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void remove() {\n+\t\t\tthrow new UnsupportedOperationException();\n+\t\t}\n+\t}\n+}\n\\ No newline at end of file\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/collection\/FastAccessNumberMap.java","additions":80,"deletions":18,"binary":false,"changes":98,"status":"modified"}]}