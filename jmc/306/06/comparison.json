{"files":[{"patch":"@@ -2,3 +2,3 @@\n-<!--   \n-   Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n-   \n+<!--\n+   Copyright (c) 2018, 2021 Oracle and\/or its affiliates. All rights reserved.\n+\n@@ -6,2 +6,2 @@\n-   \n-   The contents of this file are subject to the terms of either the Universal Permissive License \n+\n+   The contents of this file are subject to the terms of either the Universal Permissive License\n@@ -9,1 +9,1 @@\n-   \n+\n@@ -11,1 +11,1 @@\n-   \n+\n@@ -14,1 +14,1 @@\n-   \n+\n@@ -17,1 +17,1 @@\n-   \n+\n@@ -21,1 +21,1 @@\n-   \n+\n@@ -24,1 +24,1 @@\n-   \n+\n@@ -117,1 +117,1 @@\n-         \n+\n@@ -153,0 +153,35 @@\n+   <plugin\n+         id=\"org.apache.aries.spifly.dynamic.bundle\"\n+         download-size=\"0\"\n+         install-size=\"0\"\n+         version=\"0.0.0\"\n+         unpack=\"false\"\/>\n+\n+   <plugin\n+         id=\"org.eclipse.jetty.websocket.api\"\n+         download-size=\"0\"\n+         install-size=\"0\"\n+         version=\"0.0.0\"\n+         unpack=\"false\"\/>\n+\n+   <plugin\n+         id=\"org.eclipse.jetty.websocket.servlet\"\n+         download-size=\"0\"\n+         install-size=\"0\"\n+         version=\"0.0.0\"\n+         unpack=\"false\"\/>\n+\n+   <plugin\n+         id=\"org.eclipse.jetty.websocket.server\"\n+         download-size=\"0\"\n+         install-size=\"0\"\n+         version=\"0.0.0\"\n+         unpack=\"false\"\/>\n+\n+   <plugin\n+         id=\"org.eclipse.jetty.websocket.javax.server\"\n+         download-size=\"0\"\n+         install-size=\"0\"\n+         version=\"0.0.0\"\n+         unpack=\"false\"\/>\n+\n","filename":"application\/org.openjdk.jmc.feature.flightrecorder\/feature.xml","additions":47,"deletions":12,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -10,0 +10,2 @@\n+ org.apache.aries.spifly.dynamic.bundle,\n+ org.openjdk.jmc.common,\n@@ -12,0 +14,1 @@\n+ org.openjdk.jmc.flightrecorder.serializers,\n@@ -17,1 +20,9 @@\n- org.hdrhistogram.HdrHistogram\n+ org.hdrhistogram.HdrHistogram,\n+ org.eclipse.jetty.io,\n+ org.eclipse.jetty.server,\n+ org.eclipse.jetty.servlet,\n+ org.eclipse.jetty.servlet-api,\n+ org.eclipse.jetty.websocket.api,\n+ org.eclipse.jetty.websocket.server,\n+ org.eclipse.jetty.websocket.servlet,\n+ org.eclipse.jetty.util\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/META-INF\/MANIFEST.MF","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * \n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n@@ -13,1 +13,1 @@\n- * \n+ *\n@@ -16,1 +16,1 @@\n- * \n+ *\n@@ -20,1 +20,1 @@\n- * \n+ *\n@@ -23,1 +23,1 @@\n- * \n+ *\n@@ -146,0 +146,17 @@\n+\tpublic static int parseWebsocketPort(String port) {\n+\t\ttry {\n+\t\t\treturn Integer.parseInt(port);\n+\t\t} catch (NumberFormatException e) {\n+\t\t\treturn PreferenceKeys.DEFAULT_WEBSOCKET_PORT;\n+\t\t}\n+\t}\n+\n+\tpublic int getWebsocketPort() {\n+\t\treturn parseWebsocketPort(getPreferenceStore().getString(PreferenceKeys.PROPERTY_WEBSOCKET_SERVER_PORT));\n+\t}\n+\n+\tpublic boolean isWebsocketServerEnabled() {\n+\t\tint port = getWebsocketPort();\n+\t\treturn port > 0 && port < 65535;\n+\t}\n+\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/FlightRecorderUI.java","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * \n+ *\n@@ -13,1 +13,1 @@\n- * \n+ *\n@@ -16,1 +16,1 @@\n- * \n+ *\n@@ -20,1 +20,1 @@\n- * \n+ *\n@@ -23,1 +23,1 @@\n- * \n+ *\n@@ -86,0 +86,1 @@\n+import org.openjdk.jmc.flightrecorder.ui.websocket.WebsocketServer;\n@@ -115,0 +116,2 @@\n+\tprivate IPropertyChangeListener websocketServerEnabledListener;\n+\tprivate WebsocketServer websocketServer;\n@@ -126,0 +129,21 @@\n+\t\tif (FlightRecorderUI.getDefault().isWebsocketServerEnabled()) {\n+\t\t\tint websocketServerPort = FlightRecorderUI.getDefault().getWebsocketPort();\n+\t\t\twebsocketServer = new WebsocketServer(websocketServerPort);\n+\t\t}\n+\t\twebsocketServerEnabledListener = e -> {\n+\t\t\tif (e.getProperty().equals(PreferenceKeys.PROPERTY_WEBSOCKET_SERVER_PORT)) {\n+\t\t\t\tint newWebsocketServerPort = FlightRecorderUI.parseWebsocketPort((String) e.getNewValue());\n+\t\t\t\tif (newWebsocketServerPort > 0) {\n+\t\t\t\t\tif (websocketServer != null) {\n+\t\t\t\t\t\twebsocketServer.shutdown();\n+\t\t\t\t\t\twebsocketServer = null;\n+\t\t\t\t\t}\n+\t\t\t\t\twebsocketServer = new WebsocketServer(newWebsocketServerPort);\n+\t\t\t\t} else {\n+\t\t\t\t\tif (websocketServer != null) {\n+\t\t\t\t\t\twebsocketServer.shutdown();\n+\t\t\t\t\t\twebsocketServer = null;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n@@ -127,0 +151,1 @@\n+\t\tFlightRecorderUI.getDefault().getPreferenceStore().addPropertyChangeListener(websocketServerEnabledListener);\n@@ -188,0 +213,3 @@\n+\t\tif (websocketServer != null) {\n+\t\t\twebsocketServer.notifyAll(selectionItems);\n+\t\t}\n@@ -400,0 +428,1 @@\n+\t\tFlightRecorderUI.getDefault().getPreferenceStore().removePropertyChangeListener(websocketServerEnabledListener);\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/JfrEditor.java","additions":34,"deletions":5,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * \n+ *\n@@ -13,1 +13,1 @@\n- * \n+ *\n@@ -16,1 +16,1 @@\n- * \n+ *\n@@ -20,1 +20,1 @@\n- * \n+ *\n@@ -23,1 +23,1 @@\n- * \n+ *\n@@ -421,0 +421,3 @@\n+\tpublic static String PREFERENCES_WEBSOCKET_SERVER_PORT_INVALID;\n+\tpublic static String PREFERENCES_WEBSOCKET_SERVER_PORT_TEXT;\n+\tpublic static String PREFERENCES_WEBSOCKET_SERVER_PORT_TOOLTIP;\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/messages\/internal\/Messages.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * \n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n@@ -13,1 +13,1 @@\n- * \n+ *\n@@ -16,1 +16,1 @@\n- * \n+ *\n@@ -20,1 +20,1 @@\n- * \n+ *\n@@ -23,1 +23,1 @@\n- * \n+ *\n@@ -96,0 +96,1 @@\n+\tprivate Text websocketPortValue;\n@@ -172,0 +173,8 @@\n+\t\tLabel websocketPortLabel = new Label(defaultTimespanContainer, SWT.NONE);\n+\t\twebsocketPortLabel.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, false, false));\n+\t\twebsocketPortLabel.setText(Messages.PREFERENCES_WEBSOCKET_SERVER_PORT_TEXT);\n+\t\twebsocketPortLabel.setToolTipText(Messages.PREFERENCES_WEBSOCKET_SERVER_PORT_TOOLTIP);\n+\t\twebsocketPortValue = new Text(defaultTimespanContainer, SWT.BORDER);\n+\t\twebsocketPortValue.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, true, false));\n+\t\tQuantityKindProposal.install(websocketPortValue, UnitLookup.NUMBER);\n+\n@@ -178,0 +187,1 @@\n+\t\tloadWebsocketPortFromPrefStore(false);\n@@ -208,0 +218,6 @@\n+\t\twebsocketPortValue.addModifyListener(new ModifyListener() {\n+\t\t\t@Override\n+\t\t\tpublic void modifyText(ModifyEvent e) {\n+\t\t\t\tvalidatePage();\n+\t\t\t}\n+\t\t});\n@@ -228,1 +244,17 @@\n-\t\tsetValid(error == null && error2 == null && error3 == null && error4 == null);\n+\t\tString error5 = validateWebsocketPort(websocketPortValue.getText());\n+\t\tif (error == null && error2 == null && error3 == null) {\n+\t\t\tsetErrorMessage(error5);\n+\t\t}\n+\t\tsetValid(error == null && error2 == null && error3 == null && error4 == null && error5 == null);\n+\t}\n+\n+\tpublic static String validateWebsocketPort(String text) {\n+\t\ttry {\n+\t\t\tint port = Integer.parseInt(text);\n+\t\t\tif (port < 0 || port > 65535) {\n+\t\t\t\treturn Messages.PREFERENCES_WEBSOCKET_SERVER_PORT_INVALID;\n+\t\t\t}\n+\t\t} catch (NumberFormatException e) {\n+\t\t\treturn Messages.PREFERENCES_WEBSOCKET_SERVER_PORT_INVALID;\n+\t\t}\n+\t\treturn null;\n@@ -308,0 +340,6 @@\n+\tprivate void loadWebsocketPortFromPrefStore(boolean loadDefault) {\n+\t\tString port = loadDefault ? getPreferenceStore().getDefaultString(PreferenceKeys.PROPERTY_WEBSOCKET_SERVER_PORT)\n+\t\t\t\t: getPreferenceStore().getString(PreferenceKeys.PROPERTY_WEBSOCKET_SERVER_PORT);\n+\t\twebsocketPortValue.setText(Integer.toString(FlightRecorderUI.parseWebsocketPort(port)));\n+\t}\n+\n@@ -440,0 +478,8 @@\n+\t\ttry {\n+\t\t\tint port = Integer.parseInt(websocketPortValue.getText());\n+\t\t\tgetPreferenceStore().setValue(PreferenceKeys.PROPERTY_WEBSOCKET_SERVER_PORT, Integer.toString(port));\n+\t\t} catch (NumberFormatException e) {\n+\t\t\tsetErrorMessage(Messages.PREFERENCES_WEBSOCKET_SERVER_PORT_INVALID);\n+\t\t\treturn false;\n+\t\t}\n+\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/preferences\/GeneralPage.java","additions":53,"deletions":7,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * \n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n@@ -13,1 +13,1 @@\n- * \n+ *\n@@ -16,1 +16,1 @@\n- * \n+ *\n@@ -20,1 +20,1 @@\n- * \n+ *\n@@ -23,1 +23,1 @@\n- * \n+ *\n@@ -48,0 +48,2 @@\n+\tpublic static final int DEFAULT_WEBSOCKET_PORT = 0;\n+\tpublic static final String PROPERTY_WEBSOCKET_SERVER_PORT = \"flightrecorder.controlpanel.websocket.server.port\"; \/\/$NON-NLS-1$\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/preferences\/PreferenceKeys.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.ui.websocket;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+import java.util.logging.Level;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.servlet.ServletContextHandler;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.WebSocketAdapter;\n+import org.eclipse.jetty.websocket.server.config.JettyWebSocketServletContainerInitializer;\n+import org.eclipse.jetty.websocket.servlet.WebSocketUpgradeFilter;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.flightrecorder.serializers.dot.DotSerializer;\n+import org.openjdk.jmc.flightrecorder.serializers.json.FlameGraphJsonSerializer;\n+import org.openjdk.jmc.flightrecorder.serializers.json.IItemCollectionJsonSerializer;\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator.FrameCategorization;\n+import org.openjdk.jmc.flightrecorder.stacktrace.graph.StacktraceGraphModel;\n+import org.openjdk.jmc.flightrecorder.stacktrace.tree.StacktraceTreeModel;\n+import org.openjdk.jmc.flightrecorder.ui.FlightRecorderUI;\n+\n+public class WebsocketServer {\n+\n+\tprivate static int MAX_MESSAGE_SIZE = 1024 * 1024 * 1024;\n+\tprivate static int IDLE_TIMEOUT_MINUTES = 5;\n+\n+\tprivate final int port;\n+\tprivate Server server;\n+\tprivate List<WebsocketConnectionHandler> handlers = new CopyOnWriteArrayList<>();\n+\tprivate List<WebsocketConnectionHandler> treeHandlers = new CopyOnWriteArrayList<>();\n+\tprivate List<WebsocketConnectionHandler> graphHandlers = new CopyOnWriteArrayList<>();\n+\tprivate final ExecutorService executorService = Executors.newSingleThreadExecutor();\n+\tprivate IItemCollection currentSelection = null;\n+\n+\tpublic WebsocketServer(int port) {\n+\t\tthis.port = port;\n+\t\texecutorService.execute(() -> startServer());\n+\t}\n+\n+\tpublic int getPort() {\n+\t\treturn port;\n+\t}\n+\n+\tprivate void startServer() {\n+\t\tserver = new Server();\n+\t\tServerConnector connector = new ServerConnector(server);\n+\t\tconnector.setHost(\"127.0.0.1\");\n+\t\tconnector.setPort(port);\n+\t\tserver.addConnector(connector);\n+\n+\t\tServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\n+\t\tcontext.setContextPath(\"\/\");\n+\t\tserver.setHandler(context);\n+\n+\t\tJettyWebSocketServletContainerInitializer.configure(context, (servletContext, container) -> {\n+\t\t\tcontainer.setMaxBinaryMessageSize(MAX_MESSAGE_SIZE);\n+\t\t\tcontainer.setIdleTimeout(Duration.ofMinutes(IDLE_TIMEOUT_MINUTES));\n+\t\t\tcontainer.addMapping(\"\/events\/*\", (req, resp) -> {\n+\t\t\t\t\/\/ try to send the current selection when the client connects\n+\t\t\t\t\/\/ for simplicity, we serialise for every new connection\n+\t\t\t\tString eventsJson = WebsocketServer.toEventsJsonString(currentSelection);\n+\t\t\t\tWebsocketConnectionHandler handler = new WebsocketConnectionHandler(eventsJson);\n+\t\t\t\thandlers.add(handler);\n+\t\t\t\treturn handler;\n+\t\t\t});\n+\t\t\tcontainer.addMapping(\"\/tree\/*\", (req, resp) -> {\n+\t\t\t\tString treeJson = WebsocketServer.toTreeModelJsonString(currentSelection);\n+\t\t\t\tWebsocketConnectionHandler handler = new WebsocketConnectionHandler(treeJson);\n+\t\t\t\ttreeHandlers.add(handler);\n+\t\t\t\treturn handler;\n+\t\t\t});\n+\t\t\tcontainer.addMapping(\"\/graph\/*\", (req, resp) -> {\n+\t\t\t\tString dot = WebsocketServer.toGraphModelDotString(currentSelection);\n+\t\t\t\tWebsocketConnectionHandler handler = new WebsocketConnectionHandler(dot);\n+\t\t\t\tgraphHandlers.add(handler);\n+\t\t\t\treturn handler;\n+\t\t\t});\n+\t\t});\n+\n+\t\ttry {\n+\t\t\tWebSocketUpgradeFilter.ensureFilter(context.getServletContext());\n+\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.INFO,\n+\t\t\t\t\t\"Starting websocket server listening on port \" + port);\n+\t\t\tserver.start();\n+\t\t\tserver.join();\n+\t\t} catch (Exception e) {\n+\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.SEVERE, \"Failed to start websocket server\", e);\n+\t\t}\n+\t}\n+\n+\tpublic void notifyAll(IItemCollection events) {\n+\t\tcurrentSelection = events;\n+\t\tnotifyAllEventHandlers(events);\n+\t\tnotifyAllGraphHandlers(events);\n+\t\tnotifyAllTreeHandlers(events);\n+\t}\n+\n+\tprivate void notifyAllEventHandlers(IItemCollection events) {\n+\t\thandlers = notifyAllHandlers(events, handlers, WebsocketServer::toEventsJsonString);\n+\t}\n+\n+\tprivate void notifyAllGraphHandlers(IItemCollection events) {\n+\t\tgraphHandlers = notifyAllHandlers(events, graphHandlers, WebsocketServer::toGraphModelDotString);\n+\t}\n+\n+\tprivate void notifyAllTreeHandlers(IItemCollection events) {\n+\t\ttreeHandlers = notifyAllHandlers(events, treeHandlers, WebsocketServer::toTreeModelJsonString);\n+\t}\n+\n+\tprivate static String toEventsJsonString(IItemCollection items) {\n+\t\tif (items == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn IItemCollectionJsonSerializer.toJsonString(items);\n+\t}\n+\n+\tprivate static String toGraphModelDotString(IItemCollection items) {\n+\t\tif (items == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tFrameSeparator frameSeparator = new FrameSeparator(FrameCategorization.METHOD, false);\n+\t\tStacktraceGraphModel model = new StacktraceGraphModel(frameSeparator, items, null);\n+\t\treturn DotSerializer.toDot(model, 10_000, new HashMap<>());\n+\t}\n+\n+\tprivate static String toTreeModelJsonString(IItemCollection items) {\n+\t\tif (items == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tStacktraceTreeModel model = new StacktraceTreeModel(items);\n+\t\treturn FlameGraphJsonSerializer.toJson(model);\n+\t}\n+\n+\tprivate List<WebsocketConnectionHandler> notifyAllHandlers(\n+\t\tIItemCollection events, List<WebsocketConnectionHandler> handlers,\n+\t\tFunction<IItemCollection, String> jsonSerializer) {\n+\t\thandlers = handlers.stream().filter(h -> h.isConnected()).collect(Collectors.toList());\n+\t\tif (handlers.size() == 0 || events == null) {\n+\t\t\t\/\/ do nothing if no handlers are registered\n+\t\t\treturn handlers;\n+\t\t}\n+\t\tString json = jsonSerializer.apply(events);\n+\t\thandlers.forEach(handler -> handler.sendMessage(json));\n+\t\treturn handlers;\n+\t}\n+\n+\tpublic void shutdown() {\n+\t\ttry {\n+\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.INFO,\n+\t\t\t\t\t\"Stopping websocket server listening on port \" + port);\n+\t\t\tserver.stop();\n+\t\t\t\/\/ TODO: see if we need to cleanup executor service and thread\n+\t\t} catch (Exception e) {\n+\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.SEVERE, \"Failed to stop websocket server\", e);\n+\t\t}\n+\t}\n+\n+\tprivate static class WebsocketConnectionHandler extends WebSocketAdapter {\n+\t\tprivate String firstMessage;\n+\n+\t\tWebsocketConnectionHandler(String firstMessage) {\n+\t\t\tthis.firstMessage = firstMessage;\n+\t\t}\n+\n+\t\tpublic void sendMessage(String message) {\n+\t\t\tif (getSession() != null && isConnected()) {\n+\t\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.INFO,\n+\t\t\t\t\t\t\"Sending message to \" + getSession().getRemoteAddress().toString());\n+\t\t\t\ttry {\n+\t\t\t\t\tgetSession().getRemote().sendString(message);\n+\t\t\t\t} catch (IOException e) {\n+\t\t\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.SEVERE, \"Failed to send websocket message\", e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onWebSocketConnect(Session sess) {\n+\t\t\tsuper.onWebSocketConnect(sess);\n+\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.INFO,\n+\t\t\t\t\t\"Socket connected to \" + sess.getRemoteAddress().toString());\n+\t\t\ttry {\n+\t\t\t\tif (firstMessage != null) {\n+\t\t\t\t\tgetSession().getRemote().sendString(firstMessage);\n+\t\t\t\t\tfirstMessage = null;\n+\t\t\t\t}\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.SEVERE, \"Failed to show outline view\", e);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onWebSocketText(String message) {\n+\t\t\tsuper.onWebSocketText(message);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onWebSocketClose(int statusCode, String reason) {\n+\t\t\tsuper.onWebSocketClose(statusCode, reason);\n+\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.INFO, \"Socket closed: [\" + statusCode + \"] \" + reason);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void onWebSocketError(Throwable cause) {\n+\t\t\tsuper.onWebSocketError(cause);\n+\t\t\tif (cause.getCause() instanceof TimeoutException) {\n+\t\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.INFO, \"Websocket timed out\");\n+\t\t\t} else {\n+\t\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.SEVERE, \"Websocket error\", cause);\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/websocket\/WebsocketServer.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -6,1 +6,1 @@\n-#  The contents of this file are subject to the terms of either the Universal Permissive License \n+#  The contents of this file are subject to the terms of either the Universal Permissive License\n@@ -8,1 +8,1 @@\n-#   \n+#\n@@ -10,1 +10,1 @@\n-#   \n+#\n@@ -13,1 +13,1 @@\n-#   \n+#\n@@ -16,1 +16,1 @@\n-#   \n+#\n@@ -20,1 +20,1 @@\n-#   \n+#\n@@ -350,0 +350,2 @@\n+PREFERENCES_WEBSOCKET_SERVER_PORT_TEXT=Websocket server port (0 - disabled)\n+PREFERENCES_WEBSOCKET_SERVER_PORT_TOOLTIP=Start a websocket server bound to 127.0.0.1 and the selected port. The server pushes updates whenever the selection changes in the UI.\n@@ -359,0 +361,1 @@\n+PREFERENCES_WEBSOCKET_SERVER_PORT_INVALID=Websocket server port must a number be between 0 and 65535\n@@ -662,1 +665,1 @@\n-MethodProfilingPage_PREDECESSORS_DESCRIPTION=Predecessors\n\\ No newline at end of file\n+MethodProfilingPage_PREDECESSORS_DESCRIPTION=Predecessors\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/ui\/messages\/internal\/messages.properties","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+websocket\n","filename":"configuration\/ide\/eclipse\/dictionary\/dictionary.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,2 +3,2 @@\n-   Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n-   Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+   Copyright (c) 2020, 2021 Oracle and\/or its affiliates. All rights reserved.\n+   Copyright (c) 2020, 2021 Datadog, Inc. All rights reserved.\n@@ -49,0 +49,6 @@\n+            <unit id=\"org.eclipse.jetty.servlet-api\" version=\"4.0.6\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.api\" version=\"10.0.5\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.server\" version=\"10.0.5\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.servlet\" version=\"10.0.5\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.javax.server\" version=\"10.0.5\"\/>\n+            <unit id=\"org.apache.aries.spifly.dynamic.bundle\" version=\"1.3.4\"\/>\n","filename":"releng\/platform-definitions\/platform-definition-2020-06\/platform-definition-2020-06.target","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,0 +49,6 @@\n+            <unit id=\"org.eclipse.jetty.servlet-api\" version=\"4.0.6\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.api\" version=\"10.0.5\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.server\" version=\"10.0.5\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.servlet\" version=\"10.0.5\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.javax.server\" version=\"10.0.5\"\/>\n+            <unit id=\"org.apache.aries.spifly.dynamic.bundle\" version=\"1.3.4\"\/>\n","filename":"releng\/platform-definitions\/platform-definition-2020-09\/platform-definition-2020-09.target","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,0 +49,6 @@\n+            <unit id=\"org.eclipse.jetty.servlet-api\" version=\"4.0.6\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.api\" version=\"10.0.5\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.server\" version=\"10.0.5\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.servlet\" version=\"10.0.5\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.javax.server\" version=\"10.0.5\"\/>\n+            <unit id=\"org.apache.aries.spifly.dynamic.bundle\" version=\"1.3.4\"\/>\n","filename":"releng\/platform-definitions\/platform-definition-2020-12\/platform-definition-2020-12.target","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,0 +49,6 @@\n+            <unit id=\"org.eclipse.jetty.servlet-api\" version=\"4.0.6\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.api\" version=\"10.0.5\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.server\" version=\"10.0.5\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.servlet\" version=\"10.0.5\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.javax.server\" version=\"10.0.5\"\/>\n+            <unit id=\"org.apache.aries.spifly.dynamic.bundle\" version=\"1.3.4\"\/>\n","filename":"releng\/platform-definitions\/platform-definition-2021-03\/platform-definition-2021-03.target","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,0 +49,6 @@\n+            <unit id=\"org.eclipse.jetty.servlet-api\" version=\"4.0.6\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.api\" version=\"10.0.5\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.server\" version=\"10.0.5\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.servlet\" version=\"10.0.5\"\/>\n+            <unit id=\"org.eclipse.jetty.websocket.javax.server\" version=\"10.0.5\"\/>\n+            <unit id=\"org.apache.aries.spifly.dynamic.bundle\" version=\"1.3.4\"\/>\n","filename":"releng\/platform-definitions\/platform-definition-2021-06\/platform-definition-2021-06.target","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-   Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+   Copyright (c) 2018, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,2 @@\n+\t\t<javax.websocket.version>1.1<\/javax.websocket.version>\n+\t\t<jetty.version>10.0.5<\/jetty.version>\n@@ -49,1 +51,1 @@\n-\t\t<jetty-maven-plugin.version>9.4.33.v20201020<\/jetty-maven-plugin.version>\n+\t\t<jetty-maven-plugin.version>9.4.43.v20210629<\/jetty-maven-plugin.version>\n@@ -54,0 +56,1 @@\n+\t\t<spifly.version>1.3.4<\/spifly.version>\n@@ -112,0 +115,12 @@\n+\t\t\t\t\t\t\t\t<artifact>\n+\t\t\t\t\t\t\t\t\t<id>org.eclipse.jetty.websocket:websocket-jetty-server:${jetty.version}<\/id>\n+\t\t\t\t\t\t\t\t<\/artifact>\n+\t\t\t\t\t\t\t\t<artifact>\n+\t\t\t\t\t\t\t\t\t<id>org.eclipse.jetty.websocket:websocket-javax-server:${jetty.version}<\/id>\n+\t\t\t\t\t\t\t\t<\/artifact>\n+\t\t\t\t\t\t\t\t<artifact>\n+\t\t\t\t\t\t\t\t\t<id>org.eclipse.jetty.websocket:websocket-jetty-api:${jetty.version}<\/id>\n+\t\t\t\t\t\t\t\t<\/artifact>\n+\t\t\t\t\t\t\t\t<artifact>\n+\t\t\t\t\t\t\t\t\t<id>org.apache.aries.spifly:org.apache.aries.spifly.dynamic.bundle:${spifly.version}<\/id>\n+\t\t\t\t\t\t\t\t<\/artifact>\n","filename":"releng\/third-party\/pom.xml","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"}]}