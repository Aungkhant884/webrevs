{"files":[{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.rules.jdk.memory;\n+\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+\n+import org.openjdk.jmc.common.item.Aggregators;\n+import org.openjdk.jmc.common.item.IItem;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.item.IItemIterable;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.UnitLookup;\n+import org.openjdk.jmc.common.util.IPreferenceValueProvider;\n+import org.openjdk.jmc.common.util.TypedPreference;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkAggregators;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkAttributes;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkFilters;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;\n+import org.openjdk.jmc.flightrecorder.rules.IResult;\n+import org.openjdk.jmc.flightrecorder.rules.IResultValueProvider;\n+import org.openjdk.jmc.flightrecorder.rules.IRule;\n+import org.openjdk.jmc.flightrecorder.rules.ResultBuilder;\n+import org.openjdk.jmc.flightrecorder.rules.Severity;\n+import org.openjdk.jmc.flightrecorder.rules.TypedResult;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.messages.internal.Messages;\n+import org.openjdk.jmc.flightrecorder.rules.util.JfrRuleTopics;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.EventAvailability;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.RequiredEventsBuilder;\n+\n+\/**\n+ * Rule that checks for \"Inverted Parallelism\", as described by the Garbagecat GC log analysis tool.\n+ * Checks if the parallel collection performance is less than serial (single-threaded). See:\n+ * https:\/\/github.com\/mgm3746\/garbagecat\/blob\/main\/src\/main\/java\/org\/eclipselabs\/garbagecat\/util\/jdk\/JdkMath.java#L365\n+ *\/\n+public class GcInvertedParallelismRule implements IRule {\n+\tprivate static final String INVERTED_PARALLELISM_RESULT_ID = \"GcInvertedParallelism\"; \/\/$NON-NLS-1$\n+\t\/\/ Requires the jdk.GCCPUTime event introduced in JDK 20\n+\t\/\/ See: JDK-8291753\n+\tprivate static final Map<String, EventAvailability> REQUIRED_EVENTS = RequiredEventsBuilder.create()\n+\t\t\t.addEventType(JdkTypeIDs.GC_CPU_TIME, EventAvailability.AVAILABLE).build();\n+\n+\tpublic static final TypedResult<IQuantity> GC_CPU_TIME_EVENT_COUNT = new TypedResult<>(\"gcCpuTimeEventCount\", \/\/$NON-NLS-1$\n+\t\t\t\"GCCPUTime Event Count\", \"The number of recorded jdk.GCCPUTime events.\", UnitLookup.NUMBER,\n+\t\t\tIQuantity.class);\n+\n+\tpublic static final TypedResult<Long> INVERTED_PARALLELISM_COUNT = new TypedResult<>(\"invertedParallelismCount\", \/\/$NON-NLS-1$\n+\t\t\t\"Inverted Parallelism Count\", \"The number of detected instances of Inverted Parallelism.\",\n+\t\t\tUnitLookup.RAW_LONG, Long.class);\n+\n+\tprivate static final Collection<TypedResult<?>> RESULT_ATTRIBUTES = Arrays\n+\t\t\t.<TypedResult<?>> asList(GC_CPU_TIME_EVENT_COUNT, INVERTED_PARALLELISM_COUNT);\n+\n+\t@Override\n+\tpublic RunnableFuture<IResult> createEvaluation(\n+\t\tfinal IItemCollection items, final IPreferenceValueProvider valueProvider,\n+\t\tfinal IResultValueProvider resultProvider) {\n+\t\treturn new FutureTask<>(new Callable<IResult>() {\n+\t\t\t@Override\n+\t\t\tpublic IResult call() throws Exception {\n+\t\t\t\tif (items.getAggregate(JdkAggregators.OLD_COLLECTOR)\n+\t\t\t\t\t\t.equals(CollectorType.SERIAL_OLD.getCollectorName())) {\n+\t\t\t\t\treturn ResultBuilder.createFor(GcInvertedParallelismRule.this, valueProvider)\n+\t\t\t\t\t\t\t.setSeverity(Severity.IGNORE).build();\n+\t\t\t\t}\n+\t\t\t\tIItemCollection gcCpuTimeItems = items.apply(JdkFilters.GC_CPU_TIME);\n+\t\t\t\tlong invertedParallelismCount = 0;\n+\t\t\t\tfor (IItemIterable item : gcCpuTimeItems) {\n+\t\t\t\t\tfor (IItem event : item) {\n+\t\t\t\t\t\tlong timeUser = RulesToolkit.getValue(event, JdkAttributes.GC_TIME_USER)\n+\t\t\t\t\t\t\t\t.longValueIn(UnitLookup.NANOSECOND);\n+\t\t\t\t\t\tlong timeSystem = RulesToolkit.getValue(event, JdkAttributes.GC_TIME_SYSTEM)\n+\t\t\t\t\t\t\t\t.longValueIn(UnitLookup.NANOSECOND);\n+\t\t\t\t\t\tlong timeReal = RulesToolkit.getValue(event, JdkAttributes.GC_TIME_REAL)\n+\t\t\t\t\t\t\t\t.longValueIn(UnitLookup.NANOSECOND);\n+\t\t\t\t\t\tif (isInvertedParallelism(calcParallelism(timeUser, timeSystem, timeReal))) {\n+\t\t\t\t\t\t\tinvertedParallelismCount++;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (invertedParallelismCount == 0) {\n+\t\t\t\t\treturn ResultBuilder.createFor(GcInvertedParallelismRule.this, valueProvider)\n+\t\t\t\t\t\t\t.setSeverity(Severity.OK).setSummary(\"OK\").build();\n+\t\t\t\t} else {\n+\t\t\t\t\treturn ResultBuilder.createFor(GcInvertedParallelismRule.this, valueProvider)\n+\t\t\t\t\t\t\t.addResult(INVERTED_PARALLELISM_COUNT, invertedParallelismCount)\n+\t\t\t\t\t\t\t.addResult(GC_CPU_TIME_EVENT_COUNT, gcCpuTimeItems.getAggregate(Aggregators.count()))\n+\t\t\t\t\t\t\t.setSeverity(Severity.WARNING)\n+\t\t\t\t\t\t\t.setSummary(Messages.getString(Messages.GcInvertedParallelism_TEXT_WARN_SHORT))\n+\t\t\t\t\t\t\t.setExplanation(Messages.getString(Messages.GcInvertedParallelism_TEXT_WARN_LONG)).build();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t\/**\n+\t * Calculate parallelism, the ratio of user + sys to wall (real) time.\n+\t * \n+\t * @param timeUser\n+\t *            The user (non-kernel) time.\n+\t * @param timeSys\n+\t *            The sys (kernel) time.\n+\t * @param timeReal\n+\t *            The wall (clock) time.\n+\t * @return Percent user:real time rounded up the the nearest whole number.\n+\t *\/\n+\tpublic static int calcParallelism(final long timeUser, final long timeSys, final long timeReal) {\n+\t\tif (timeReal == 0) {\n+\t\t\tif (timeUser == 0 && timeUser == 0) {\n+\t\t\t\treturn 100;\n+\t\t\t}\n+\t\t\treturn Integer.MAX_VALUE;\n+\t\t} else {\n+\t\t\tBigDecimal parallelism = new BigDecimal(timeUser);\n+\t\t\tparallelism = parallelism.add(new BigDecimal(timeSys));\n+\t\t\tBigDecimal hundred = new BigDecimal(\"100\");\n+\t\t\tparallelism = parallelism.multiply(hundred);\n+\t\t\tparallelism = parallelism.divide(new BigDecimal(timeReal), 0, RoundingMode.CEILING);\n+\t\t\treturn parallelism.intValue();\n+\t\t}\n+\t}\n+\n+\t\/**\n+\t * @param parallelism\n+\t *            The parallelism percent (ratio or user to wall (real time).\n+\t * @return True if the parallelism is \"inverted\", false otherwise. Inverted parallelism is less\n+\t *         than 100. In other words, the parallel collection performance is less than serial\n+\t *         (single-threaded).\n+\t *\/\n+\tpublic static boolean isInvertedParallelism(int parallelism) {\n+\t\treturn (parallelism < 100);\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TypedPreference<?>> getConfigurationAttributes() {\n+\t\treturn Collections.emptyList();\n+\t}\n+\n+\t@Override\n+\tpublic String getId() {\n+\t\treturn INVERTED_PARALLELISM_RESULT_ID;\n+\t}\n+\n+\t@Override\n+\tpublic String getName() {\n+\t\treturn Messages.getString(Messages.GcInvertedParallelism_RULE_NAME);\n+\t}\n+\n+\t@Override\n+\tpublic String getTopic() {\n+\t\treturn JfrRuleTopics.GARBAGE_COLLECTION;\n+\t}\n+\n+\t@Override\n+\tpublic Map<String, EventAvailability> getRequiredEvents() {\n+\t\treturn REQUIRED_EVENTS;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TypedResult<?>> getResults() {\n+\t\treturn RESULT_ATTRIBUTES;\n+\t}\n+\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/memory\/GcInvertedParallelismRule.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -309,0 +309,3 @@\n+\tpublic static final String GcInvertedParallelism_RULE_NAME = \"GcInvertedParallelism_RULE_NAME\"; \/\/$NON-NLS-1$\n+\tpublic static final String GcInvertedParallelism_TEXT_WARN_SHORT = \"GcInvertedParallelism_TEXT_WARN_SHORT\"; \/\/$NON-NLS-1$\n+\tpublic static final String GcInvertedParallelism_TEXT_WARN_LONG = \"GcInvertedParallelism_TEXT_WARN_LONG\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/Messages.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+org.openjdk.jmc.flightrecorder.rules.jdk.memory.GcInvertedParallelismRule\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/META-INF\/services\/org.openjdk.jmc.flightrecorder.rules.IRule","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -333,0 +333,3 @@\n+GcInvertedParallelism_RULE_NAME=Inverted Parallelism\n+GcInvertedParallelism_TEXT_WARN_SHORT=Inverted Parallelism detected {invertedParallelismCount} times out of {gcCpuTimeEventCount} recorded events.\n+GcInvertedParallelism_TEXT_WARN_LONG=There is evidence of inverted parallelism. With parallel (multi-threaded) collector events, the \"user\" + \"sys\" time should be approximately equal to the \"real\" (wall) time multiplied by the # of GC threads. For example, if there are 3 GC threads we would expect a parallel collection that takes 1 second of \"real\" time to take approximately 3 seconds of \"user\" + \"sys\" time. The parallelism is 3x. If the parallelism is 1x (\"user\" + \"sys\" = \"real\"), the parallel collection is not offering any efficiency over a serial (single-threaded) collection. When \"user\" + \"sys\" < \"real\", the parallelism is inverted. Inverted parallelism can be a sign of high i\/o (e.g. disk or network access) or not enough CPU (e.g. GC threads competing with each other or other processes). Check for swapping and if the number of GC threads (-XX:ParallelGCThreads=<n>) is appropriate for the number of cpu\/cores and any processes sharing cpu.\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/messages.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -720,0 +720,6 @@\n+\tpublic static final IAttribute<IQuantity> GC_TIME_REAL = attr(\"realTime\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_GC_TIME_REAL), TIMESPAN);\n+\tpublic static final IAttribute<IQuantity> GC_TIME_SYSTEM = attr(\"systemTime\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_GC_TIME_SYSTEM), TIMESPAN);\n+\tpublic static final IAttribute<IQuantity> GC_TIME_USER = attr(\"userTime\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_GC_TIME_USER), TIMESPAN);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkAttributes.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+\tpublic static final IItemFilter GC_CPU_TIME = ItemFilters.type(JdkTypeIDs.GC_CPU_TIME);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkFilters.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -164,0 +164,1 @@\n+\tpublic static final String GC_CPU_TIME = PREFIX + \"GCCPUTime\";\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkTypeIDs.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -343,0 +343,3 @@\n+\tpublic static final String ATTR_GC_TIME_REAL = \"ATTR_GC_TIME_REAL\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_GC_TIME_SYSTEM = \"ATTR_GC_TIME_SYSTEM\"; \/\/$NON-NLS-1$\n+\tpublic static final String ATTR_GC_TIME_USER = \"ATTR_GC_TIME_USER\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/messages\/internal\/Messages.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -282,0 +282,3 @@\n+ATTR_GC_TIME_REAL=Real Time\n+ATTR_GC_TIME_SYSTEM=System Time\n+ATTR_GC_TIME_USER=User Time\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/jdk\/messages\/internal\/messages.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.test.rules.jdk;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.memory.GcInvertedParallelismRule;\n+\n+public class ParallelismTest {\n+\n+\t@Test\n+\tpublic void testCalcParallelism() {\n+\t\tint timeUser = 90;\n+\t\tint timeSys = 10;\n+\t\tint timeReal = 10;\n+\t\tAssert.assertEquals(1000, GcInvertedParallelismRule.calcParallelism(timeUser, timeSys, timeReal));\n+\t}\n+\n+\t@Test\n+\tpublic void testCalcParallelismRounded() {\n+\t\tint timeUser = 90;\n+\t\tint timeSys = 10;\n+\t\tint timeReal = 1000;\n+\t\tAssert.assertEquals(10, GcInvertedParallelismRule.calcParallelism(timeUser, timeSys, timeReal));\n+\t}\n+\n+\t@Test\n+\tpublic void testCalcParallelismRoundedUp() {\n+\t\tint timeUser = 90;\n+\t\tint timeSys = 10;\n+\t\tint timeReal = 199;\n+\t\tAssert.assertEquals(51, GcInvertedParallelismRule.calcParallelism(timeUser, timeSys, timeReal));\n+\t}\n+\n+\t@Test\n+\tpublic void testCalcParallelismUserZero() {\n+\t\tint timeUser = 0;\n+\t\tint timeSys = 0;\n+\t\tint timeReal = 100;\n+\t\tAssert.assertEquals(0, GcInvertedParallelismRule.calcParallelism(timeUser, timeSys, timeReal));\n+\t}\n+\n+\t@Test\n+\tpublic void testCalcParallelismRealZero() {\n+\t\tint timeUser = 100;\n+\t\tint timeSys = 0;\n+\t\tint timeReal = 0;\n+\t\tAssert.assertEquals(Integer.MAX_VALUE, GcInvertedParallelismRule.calcParallelism(timeUser, timeSys, timeReal));\n+\t}\n+\n+\t@Test\n+\tpublic void testCalcParallelismUserZeroRealZero() {\n+\t\tint timeUser = 0;\n+\t\tint timeSys = 0;\n+\t\tint timeReal = 0;\n+\t\tAssert.assertEquals(100, GcInvertedParallelismRule.calcParallelism(timeUser, timeSys, timeReal));\n+\t}\n+\n+\t@Test\n+\tpublic void testParallelism() {\n+\t\tAssert.assertTrue(GcInvertedParallelismRule.isInvertedParallelism(0));\n+\t\tAssert.assertTrue(GcInvertedParallelismRule.isInvertedParallelism(99));\n+\t\tAssert.assertFalse(GcInvertedParallelismRule.isInvertedParallelism(100));\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/rules\/jdk\/ParallelismTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -143,0 +143,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -447,0 +451,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -718,0 +726,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -992,0 +1004,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1251,0 +1267,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1516,0 +1536,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1781,0 +1805,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2073,0 +2101,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2371,0 +2403,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2656,0 +2692,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2975,0 +3015,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -3292,0 +3336,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -3498,0 +3546,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -3747,0 +3799,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -4017,0 +4073,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -4306,0 +4366,4 @@\n+        <rule>\n+            <id>GcInvertedParallelism<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/baseline\/JfrRuleBaseline.xml","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"}]}