{"files":[{"patch":"@@ -41,1 +41,0 @@\n-import java.util.Arrays;\n@@ -43,3 +42,2 @@\n-import java.util.HashSet;\n-import java.util.Set;\n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -63,1 +61,0 @@\n-import org.junit.AfterClass;\n@@ -73,0 +70,1 @@\n+import org.openjdk.jmc.ui.common.jvm.JVMType;\n@@ -81,3 +79,3 @@\n- * I test that JMX connections done with JmcKubernetesJmxConnectionProvider are functional.\n- * In order to be able to test this in a contained environment, the kubernetes API is mocked\n- * with wiremock. \n+ * I test that JMX connections done with JmcKubernetesJmxConnectionProvider are\n+ * functional. In order to be able to test this in a contained environment, the\n+ * kubernetes API is mocked with wiremock.\n@@ -87,4 +85,0 @@\n-\t\n-\t@ClassRule\n-\tpublic static WireMockRule wiremock=new WireMockRule(WireMockConfiguration.options()\n-\t\t    .extensions(new ResponseTemplateTransformer(false)).port(0));\n@@ -92,1 +86,3 @@\n-\tstatic final String jolokiaUrl=\"service:jmx:kubernetes:\/\/\/ns1\/pod-abcdef\/jolokia\";\n+\t@ClassRule\n+\tpublic static WireMockRule wiremock = new WireMockRule(\n+\t\t\tWireMockConfiguration.options().extensions(new ResponseTemplateTransformer(false)).port(0));\n@@ -94,1 +90,1 @@\n-\tprivate static KubernetesDiscoveryListener discoveryListener;\n+\tstatic final String jolokiaUrl = \"service:jmx:kubernetes:\/\/\/ns1\/pod-abcdef\/jolokia\";\n@@ -100,1 +96,2 @@\n-\t\tCloseableHttpResponse configResponse = HttpClients.createDefault().execute(new HttpGet(wiremock.baseUrl()+\"\/mock-kube-config.yml\"));\n+\t\tCloseableHttpResponse configResponse = HttpClients.createDefault()\n+\t\t\t\t.execute(new HttpGet(wiremock.baseUrl() + \"\/mock-kube-config.yml\"));\n@@ -104,1 +101,1 @@\n-\t\t\/\/we set this so the KubernetesDiscoveryListener will work\n+\t\t\/\/ we set this so the KubernetesDiscoveryListener will work\n@@ -107,1 +104,0 @@\n-\t\tdiscoveryListener=new KubernetesDiscoveryListener();\n@@ -127,2 +123,2 @@\n-\t\tJMXConnector connector = new JmcKubernetesJmxConnectionProvider().newJMXConnector(\n-\t\t\t\tnew JMXServiceURL(jolokiaUrl), Collections.emptyMap());\n+\t\tJMXConnector connector = new JmcKubernetesJmxConnectionProvider().newJMXConnector(new JMXServiceURL(jolokiaUrl),\n+\t\t\t\tCollections.emptyMap());\n@@ -137,1 +133,3 @@\n-\t\tfinal AtomicInteger foundVms = new AtomicInteger(0);\n+\t\t\/\/ Set config so that scanning takes place\n+\t\tInstanceScope.INSTANCE.getNode(JmcKubernetesPlugin.PLUGIN_ID).put(PreferenceConstants.P_SCAN_FOR_INSTANCES,\n+\t\t\t\t\"true\");\n@@ -139,3 +137,2 @@\n-\t\t\/\/Set config so that scanning takes place\n-\t\t\/\/new JmcKubernetesPlugin();\/\/instantiate singleton\n-\t\tInstanceScope.INSTANCE.getNode(JmcKubernetesPlugin.PLUGIN_ID).put(PreferenceConstants.P_SCAN_FOR_INSTANCES, \"true\");\n+\t\ttestThatJVMIsFound();\n+\t}\n@@ -143,5 +140,6 @@\n-\t\tdiscoveryListener.addDescriptorListener(new IDescriptorListener() {\n-\t\t\tpublic void onDescriptorDetected(\n-\t\t\t\tIServerDescriptor serverDescriptor, String path, JMXServiceURL url,\n-\t\t\t\tIConnectionDescriptor connectionDescriptor, IDescribable provider) {\n-\t\t\t\tfoundVms.getAndIncrement();\n+\tprivate void testThatJVMIsFound() {\n+\t\tfinal Map<String, IServerDescriptor> foundVms = new HashMap<>();\n+\t\tIDescriptorListener descriptorListener = new IDescriptorListener() {\n+\t\t\tpublic void onDescriptorDetected(IServerDescriptor serverDescriptor, String path, JMXServiceURL url,\n+\t\t\t\t\tIConnectionDescriptor connectionDescriptor, IDescribable provider) {\n+\t\t\t\tfoundVms.put(serverDescriptor.getGUID(), serverDescriptor);\n@@ -151,1 +149,1 @@\n-\t\t\t\tfoundVms.getAndDecrement();\n+\t\t\t\tfoundVms.remove(descriptorId);\n@@ -153,4 +151,16 @@\n-\n-\t\t});\n-\t\t\/\/ Test that at least one VM (the one running the test was discovered)\n-\t\tAwaitility.await().atMost(Duration.ofSeconds(5)).until(() -> foundVms.get() > 0);\n+\t\t};\n+\t\tKubernetesDiscoveryListener discoveryListener = new KubernetesDiscoveryListener();\n+\t\tdiscoveryListener.addDescriptorListener(descriptorListener);\n+\t\ttry {\n+\t\t\t\/\/ Test that at least one VM (the one running the test was discovered)\n+\t\t\tAwaitility.await().atMost(Duration.ofSeconds(5)).until(() -> !foundVms.isEmpty());\n+\t\t\tIServerDescriptor descriptor = foundVms.get(\"pod-abcdef\");\n+\t\t\tAssert.assertNotNull(descriptor);\n+\t\t\tAssert.assertEquals(\n+\t\t\t\t\t\"[JVMDescriptor] Java command: \/Users\/marska\/Downloads\/hawtio-app-2.9.1.jar --port 9090 PID: 88774\",\n+\t\t\t\t\tdescriptor.getJvmInfo().toString());\n+\t\t\tAssert.assertEquals(JVMType.HOTSPOT, descriptor.getJvmInfo().getJvmType());\n+\t\t\tAssert.assertEquals(\"18.0.1\", descriptor.getJvmInfo().getJavaVersion());\n+\t\t} finally {\n+\t\t\tdiscoveryListener.removeDescriptorListener(descriptorListener);\n+\t\t}\n@@ -158,6 +168,0 @@\n-\n-\t@AfterClass\n-\tpublic static void stopServer() throws Exception {\n-\t\tdiscoveryListener.shutdown();\n-\t}\n-\n","filename":"application\/tests\/org.openjdk.jmc.kubernetes.test\/src\/test\/java\/org\/openjdk\/jmc\/kubernetes\/JmcKubernetesTest.java","additions":43,"deletions":39,"binary":false,"changes":82,"status":"modified"}]}