{"files":[{"patch":"@@ -45,2 +45,4 @@\n- * I cache a list if identified JVMs that can be refreshed in the background by some means of\n- * discovering JVMs and notify changes of any changes\n+ * \n+ * The {@code AbstractCachedDescriptorProvider} keeps a list of identified JVMs that can be refreshed in the background by some means of\n+ * discovering JVMs. \n+ * Listeners will be notified of any changes.\n","filename":"application\/org.openjdk.jmc.jolokia\/src\/main\/java\/org\/openjdk\/jmc\/jolokia\/AbstractCachedDescriptorProvider.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Optional;\n@@ -58,2 +59,3 @@\n- * Make JMC specific adjustments to Jolokia JMX connection May consider to create a decorator\n- * pattern if differences are big but begin with a subclass\n+ * Make JMC specific adjustments to Jolokia JMX connection. \n+ * May consider to use the decorator pattern if differences are big,\n+ * but for now subclass\n@@ -88,7 +90,1 @@\n-\t\t\tMBeanInfo localInfo = null;\n-\t\t\t\/\/ try to \"steal\" descriptors from this VM\n-\t\t\ttry {\n-\t\t\t\tlocalInfo = ManagementFactory.getPlatformMBeanServer().getMBeanInfo(name);\n-\t\t\t} catch (Exception ignore) {\n-\t\t\t\tlocalInfo = null;\n-\t\t\t}\n+\n@@ -98,1 +94,1 @@\n-\t\t\t\tmodifiedOperations[i] = stealOrBuildOperationInfo(mBeanInfo.getOperations()[i], localInfo);\n+\t\t\t\tmodifiedOperations[i] = stealOrBuildOperationInfo(mBeanInfo.getOperations()[i], checkForLocalOperationInfo(name));\n@@ -110,0 +106,10 @@\n+\tprivate Optional<MBeanInfo> checkForLocalOperationInfo(ObjectName name) {\n+\t\tMBeanInfo localInfo;\n+\t\ttry {\n+\t\t\tlocalInfo = ManagementFactory.getPlatformMBeanServer().getMBeanInfo(name);\n+\t\t} catch (Exception ignore) {\n+\t\t\tlocalInfo = null;\n+\t\t}\n+\t\treturn Optional.ofNullable(localInfo);\n+\t}\n+\n@@ -128,2 +134,3 @@\n-\t * build \/ reverse engineer MBeanOperationInfo by using the local one if it is a match or try to\n-\t * reverse engineer otherwise\n+\t * Build MBeanOperationInfo by taking information from the corresponding \n+\t * MBean in the local JVM for a more precise signature. \n+\t * If it is not available locally, attempt to construct it from the metadata from Jolokia.\n@@ -131,1 +138,1 @@\n-\t * @param original\n+\t * @param original MBeanInfo from Jolokia list.\n@@ -133,1 +140,1 @@\n-\t *            MBeanInfo from this JVM to use for getting descriptor\n+\t *            MBeanInfo from this JVM to use for getting descriptor.\n@@ -136,15 +143,5 @@\n-\tprivate MBeanOperationInfo stealOrBuildOperationInfo(MBeanOperationInfo original, MBeanInfo localInfo) {\n-\t\t\/\/ first attempt to get descriptor from local copy\n-\t\tif (localInfo != null) {\n-\n-\t\t\tfor (MBeanOperationInfo localOperation : localInfo.getOperations()) {\n-\t\t\t\tif (localOperation.getName().equals(original.getName())) {\n-\t\t\t\t\tif (localOperation.getSignature().length == original.getSignature().length) {\n-\t\t\t\t\t\tfor (int i = 0; i < original.getSignature().length; i++) {\n-\t\t\t\t\t\t\tMBeanParameterInfo param = original.getSignature()[i];\n-\t\t\t\t\t\t\tif (!param.getType().equals(localOperation.getSignature()[i].getType())) {\n-\t\t\t\t\t\t\t\tbreak;\n-\t\t\t\t\t\t\t} else if (i == original.getSignature().length - 1) {\n-\t\t\t\t\t\t\t\t\/\/ whole signature matches, use as replacement\n-\t\t\t\t\t\t\t\treturn localOperation;\n-\t\t\t\t\t\t\t}\n+\tprivate MBeanOperationInfo stealOrBuildOperationInfo(MBeanOperationInfo original, Optional<MBeanInfo> localInfo) {\t\t\t\n+\t\treturn localInfo\n+\t\t\t\t.map(info -> checkForMatchingLocalOperation(original, info))\/\/ first attempt to get descriptor from local copy\n+\t\t\t\t.orElseGet(()->reverseEngineerOperationInfo(original));\/\/ if not, reverse engineer descriptor from operation info\n+\t}\n@@ -152,0 +149,11 @@\n+\tprivate MBeanOperationInfo checkForMatchingLocalOperation(MBeanOperationInfo original, MBeanInfo info) {\n+\t\tfor (MBeanOperationInfo localOperation : info.getOperations()) {\n+\t\t\tif (localOperation.getName().equals(original.getName())) {\n+\t\t\t\tif (localOperation.getSignature().length == original.getSignature().length) {\n+\t\t\t\t\tfor (int i = 0; i < original.getSignature().length; i++) {\n+\t\t\t\t\t\tMBeanParameterInfo param = original.getSignature()[i];\n+\t\t\t\t\t\tif (!param.getType().equals(localOperation.getSignature()[i].getType())) {\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t} else if (i == original.getSignature().length - 1) {\n+\t\t\t\t\t\t\t\/\/ whole signature matches, use as replacement\n+\t\t\t\t\t\t\treturn localOperation;\n@@ -157,1 +165,4 @@\n-\t\t\/\/ if not reverse engineer descriptor from operation info\n+\t\treturn null;\n+\t}\n+\n+\tprivate MBeanOperationInfo reverseEngineerOperationInfo(MBeanOperationInfo original) {\n","filename":"application\/org.openjdk.jmc.jolokia\/src\/main\/java\/org\/openjdk\/jmc\/jolokia\/JmcJolokiaJmxConnection.java","additions":41,"deletions":30,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -59,1 +59,3 @@\n-\n+\/**\n+ * Provide data about JVMs accessed over Jolokia for the JVM browser\n+ *\/\n@@ -98,2 +100,2 @@\n-\t * Best effort to extract JVM information from a connection if everything works. Can be adjusted\n-\t * to support different flavors of JVM\n+\t * Best effort to extract JVM information from a connection if everything works. \n+\t * Can be adjusted to support different flavors of JVM.\n","filename":"application\/org.openjdk.jmc.jolokia\/src\/main\/java\/org\/openjdk\/jmc\/jolokia\/JolokiaAgentDescriptor.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -49,1 +49,3 @@\n-\n+\/**\n+ * Jolokia based MBeanServerConnector tailored for JMC needs\n+ *\/\n","filename":"application\/org.openjdk.jmc.kubernetes\/src\/main\/java\/org\/openjdk\/jmc\/kubernetes\/JmcKubernetesJmxConnection.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,3 @@\n-\n+\/**\n+ * This {@code JMXConnectionProvider} handles the \"kubernetes\" protocol.\n+ *\/\n","filename":"application\/org.openjdk.jmc.kubernetes\/src\/main\/java\/org\/openjdk\/jmc\/kubernetes\/JmcKubernetesJmxConnectionProvider.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,1 +80,4 @@\n-\n+\/**\n+ * This class attempts to connect to JVMs in pods running in kubernetes in a background thread.\n+ * Enablement and parameters for the scanning is given by user preferences.\n+ *\/\n","filename":"application\/org.openjdk.jmc.kubernetes\/src\/main\/java\/org\/openjdk\/jmc\/kubernetes\/KubernetesDiscoveryListener.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-\n","filename":"application\/org.openjdk.jmc.kubernetes\/src\/main\/java\/org\/openjdk\/jmc\/kubernetes\/preferences\/JmcKubernetesPreferenceForm.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}