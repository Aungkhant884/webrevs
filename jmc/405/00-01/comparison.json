{"files":[{"patch":"","filename":"application\/org.openjdk.jmc.flightrecorder.hierarchical-edge\/icons\/flameflip.png","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"application\/org.openjdk.jmc.flightrecorder.flameview\/icons\/flameflip.png","status":"copied"},{"patch":"","filename":"application\/org.openjdk.jmc.flightrecorder.hierarchical-edge\/icons\/flameflip@2x.png","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"application\/org.openjdk.jmc.flightrecorder.flameview\/icons\/flameflip@2x.png","status":"copied"},{"patch":"","filename":"application\/org.openjdk.jmc.flightrecorder.hierarchical-edge\/icons\/icicleflip.png","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"application\/org.openjdk.jmc.flightrecorder.flameview\/icons\/icicleflip.png","status":"copied"},{"patch":"","filename":"application\/org.openjdk.jmc.flightrecorder.hierarchical-edge\/icons\/icicleflip@2x.png","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"application\/org.openjdk.jmc.flightrecorder.flameview\/icons\/icicleflip@2x.png","status":"copied"},{"patch":"@@ -41,1 +41,0 @@\n-import java.util.Arrays;\n@@ -57,0 +56,3 @@\n+import org.eclipse.jface.action.Separator;\n+import org.eclipse.jface.resource.ImageDescriptor;\n+import org.eclipse.jface.resource.ResourceLocator;\n@@ -86,0 +88,2 @@\n+\tprivate static final String DIR_ICONS = \"icons\/\"; \/\/$NON-NLS-1$\n+\tprivate static final String PLUGIN_ID = \"org.openjdk.jmc.flightrecorder.flameview\"; \/\/$NON-NLS-1$\n@@ -89,2 +93,8 @@\n-\t\tHTML_PAGE = String.format(loadStringFromFile(\"page.template\"), loadLibraries(jsD3V6),\n-\t\t\t\tloadStringFromFile(\"hierarchical-edge.js\"));\n+\t\tHTML_PAGE = String.format(\n+\t\t\t\tloadStringFromFile(\"page.template\"),\n+\t\t\t\tloadLibraries(jsD3V6),\n+\t\t\t\tloadStringFromFile(\"main.js\"),\n+\t\t\t\tloadStringFromFile(\"utils.js\"),\n+\t\t\t\tloadStringFromFile(\"hierarchical-edge.js\"),\n+\t\t\t\tloadStringFromFile(\"chord.js\"));\n+\t\tSystem.out.println(HTML_PAGE);\n@@ -129,0 +139,40 @@\n+\tprivate enum DependencyChartType {\n+\t\tEDGE_BUNDLING(\"\", IAction.AS_RADIO_BUTTON, hierarchicalEdgeImageDescriptor(\"flameflip.png\")),\n+\t\tCHORD(\"\", IAction.AS_RADIO_BUTTON, hierarchicalEdgeImageDescriptor(\"icicleflip.png\"));\n+\n+\t\tprivate final String message;\n+\t\tprivate final int action;\n+\t\tprivate final ImageDescriptor imageDescriptor;\n+\n+\t\tprivate DependencyChartType(String message, int action, ImageDescriptor imageDescriptor) {\n+\t\t\tthis.message = message;\n+\t\t\tthis.action = action;\n+\t\t\tthis.imageDescriptor = imageDescriptor;\n+\t\t}\n+\t}\n+\n+\tprivate class ChangeChartTypeAction extends Action {\n+\t\tprivate final DependencyChartType type;\n+\n+\t\tChangeChartTypeAction(DependencyChartType type) {\n+\t\t\tsuper(type.message, type.action);\n+\t\t\tthis.type = type;\n+\t\t\tsetToolTipText(type.message);\n+\t\t\tsetImageDescriptor(type.imageDescriptor);\n+\t\t\tsetChecked(DependencyChartType.EDGE_BUNDLING.equals(type));\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void run() {\n+\t\t\tif (this.isChecked()) {\n+\t\t\t\tchartType = type;\n+\t\t\t\tString eventsJson = IItemCollectionJsonSerializer.toJsonString(currentItems);\n+\t\t\t\tbrowser.execute(String.format(\"updateGraph(`%s`, %d, `%s`);\", eventsJson, packageDepth, chartType.name()));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static ImageDescriptor hierarchicalEdgeImageDescriptor(String iconName) {\n+\t\treturn ResourceLocator.imageDescriptorFromBundle(PLUGIN_ID, DIR_ICONS + iconName).orElse(null); \/\/$NON-NLS-1$\n+\t}\n+\n@@ -148,0 +198,1 @@\n+\tprivate DependencyChartType chartType = DependencyChartType.EDGE_BUNDLING;\n@@ -153,0 +204,6 @@\n+\t\tChangeChartTypeAction[] chartTypeActions = new ChangeChartTypeAction[] {\n+\t\t\t\tnew ChangeChartTypeAction(DependencyChartType.EDGE_BUNDLING),\n+\t\t\t\tnew ChangeChartTypeAction(DependencyChartType.CHORD)\n+\t\t};\n+\t\tStream.of(chartTypeActions).forEach(toolBar::add);\n+\t\ttoolBar.add(new Separator());\n@@ -154,1 +211,0 @@\n-\n@@ -203,1 +259,1 @@\n-\t\t\n+\n@@ -280,0 +336,3 @@\n+\t\tbrowser.addListener(SWT.Resize, event -> {\n+\t\t\tbrowser.execute(String.format(\"updateGraph(`%s`, %d, `%s`);\", eventsJson, packageDepth, chartType.name()));\n+\t\t});\n@@ -294,1 +353,1 @@\n-\t\t\t\tbrowser.execute(String.format(\"updateGraph(`%s`, %d);\", eventsJson, packageDepth));\n+\t\t\t\tbrowser.execute(String.format(\"updateGraph(`%s`, %d, `%s`);\", eventsJson, packageDepth, chartType.name()));\n","filename":"application\/org.openjdk.jmc.flightrecorder.hierarchical-edge\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/hierarchical\/views\/HierarchicalEdgeView.java","additions":65,"deletions":6,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+function renderChordDiagram(data) {\n+  const svg = d3\n+    .select(\"#hierarchical\")\n+    .append(\"svg\")\n+    .attr(\"viewBox\", [-width \/ 2, -height \/ 2, width, height]);\n+\n+  const innerRadius = Math.max(Math.min(width, height) * 0.5 - 90, 100);\n+  const outerRadius = innerRadius + 10;\n+\n+  const names = Array.from(\n+    new Set(data.flatMap((d) => [d.source, d.target]))\n+  ).sort(d3.ascending);\n+  const color = d3.scaleOrdinal(\n+    names,\n+    d3.quantize(d3.interpolateRainbow, names.length)\n+  );\n+\n+  const chord = d3\n+    .chordDirected()\n+    .padAngle(10 \/ innerRadius)\n+    .sortSubgroups(d3.descending)\n+    .sortChords(d3.descending);\n+\n+  const arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);\n+\n+  const ribbon = d3\n+    .ribbonArrow()\n+    .radius(innerRadius - 1)\n+    .padAngle(1 \/ innerRadius);\n+\n+  const matrix = buildMatrix(data, names);\n+  const chords = chord(matrix);\n+\n+  const group = svg\n+    .append(\"g\")\n+    .attr(\"font-size\", 10)\n+    .attr(\"font-family\", \"sans-serif\")\n+    .selectAll(\"g\")\n+    .data(chords.groups)\n+    .join(\"g\");\n+\n+  group\n+    .append(\"path\")\n+    .attr(\"fill\", (d) => color(names[d.index]))\n+    .attr(\"d\", arc);\n+\n+  group\n+    .append(\"text\")\n+    .each((d) => (d.angle = (d.startAngle + d.endAngle) \/ 2))\n+    .attr(\"dy\", \"0.35em\")\n+    .attr(\n+      \"transform\",\n+      (d) => `\n+        rotate(${(d.angle * 180) \/ Math.PI - 90})\n+        translate(${outerRadius + 5})\n+        ${d.angle > Math.PI ? \"rotate(180)\" : \"\"}\n+      `\n+    )\n+    .attr(\"text-anchor\", (d) => (d.angle > Math.PI ? \"end\" : null))\n+    .text((d) => names[d.index]);\n+\n+  group.append(\"title\").text(\n+    (d) => `${names[d.index]}\n+${d3.sum(\n+  chords,\n+  (c) => (c.source.index === d.index) * c.source.value\n+)} outgoing →\n+${d3.sum(\n+  chords,\n+  (c) => (c.target.index === d.index) * c.source.value\n+)} incoming ←`\n+  );\n+\n+  svg\n+    .append(\"g\")\n+    .attr(\"fill-opacity\", 0.75)\n+    .selectAll(\"path\")\n+    .data(chords)\n+    .join(\"path\")\n+    .style(\"mix-blend-mode\", \"multiply\")\n+    .attr(\"fill\", (d) => color(names[d.target.index]))\n+    .attr(\"d\", ribbon)\n+    .append(\"title\")\n+    .text(\n+      (d) =>\n+        `${names[d.source.index]} → ${names[d.target.index]} ${d.source.value}`\n+    );\n+\n+  return svg.node();\n+}\n+\n+function buildMatrix(data, names) {\n+  const index = new Map(names.map((name, i) => [name, i]));\n+  const matrix = Array.from(index, () => new Array(names.length).fill(0));\n+  for (const { source, target, value } of data)\n+    matrix[index.get(source)][index.get(target)] += value;\n+  return matrix;\n+}\n","filename":"application\/org.openjdk.jmc.flightrecorder.hierarchical-edge\/src\/main\/resources\/chord.js","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -1,47 +1,1 @@\n-function updateGraph(eventsJson) {\n-\tconst data = JSON.parse(eventsJson);\n-\tclear();\n-    debug(`Loaded ${data.events.length} events`);\n-    try {\n-\t\tdebug(JSON.stringify(data.events[0]));\n-\t\trender(data);\n-\t} catch (e) {\n-\t\tdebug(e.message);\n-\t\tdebug(`<pre>${e.stack}<\/pre>`);\n-\t}\n-}\n-\n-const marginLeft = 0;\n-const marginRight = 0;\n-const marginTop = 0;\n-const marginBottom = 0;\n-\n-const width = window.innerWidth - (marginLeft + marginRight);\n-const height = window.innerHeight - (marginTop + marginBottom);\n-\n-var levels = 2;\n-\n-function updateGraph(eventsJson, packageLevels) {\n-  const data = JSON.parse(eventsJson);\n-  clear();\n-  debug(`Loaded ${data.events.length} events`);\n-  try {\n-    levels = packageLevels\n-    render(data);\n-  } catch (e) {\n-    debug(e.message);\n-    debug(`<pre>${e.stack}<\/pre>`);\n-  }\n-}\n-\n-\n-function debug(msg) {\n-  const displayEl = document.getElementById(\"debug\");\n-  displayEl.innerHTML += \"<br \/>\" + msg;\n-}\n-\n-function clear() {\n-  document.getElementById(\"debug\").innerHTML = \"\";\n-}\n-\n-function render(data) {\n+function renderHierarchicalEdgeBundling(graph) {\n@@ -53,1 +7,0 @@\n-  const graph = buildGraph(data);\n@@ -61,1 +14,1 @@\n-  const treeClustering = d3.cluster().size([2 * Math.PI, width \/ 2 - 100])\n+  const treeClustering = d3.cluster().size([2 * Math.PI, width \/ 2 - 100]);\n@@ -69,1 +22,0 @@\n-    \/\/ .data(root.descendants().filter(d => d.data.leaf))\n@@ -152,133 +104,0 @@\n-\n-class Graph {\n-  constructor() {\n-    this.root = new Node(\"root\");\n-    this.nodesByName = { root: this.root };\n-  }\n-\n-  createAllNodes(frame) {\n-    const nodeNames = frame.package.subpackages(levels);\n-    \/\/ .concat([\n-    \/\/   frame.package.name + \".\" + frame.clazz\n-    \/\/ ]);\n-    let node = this.root;\n-    for (let nodeName of nodeNames) {\n-      const child = this.ensureNode(nodeName);\n-      const exists = node.children.find((c) => c.name === child.name);\n-      if (!exists) {\n-        node.children.push(child);\n-      }\n-      node = child;\n-    }\n-    return node;\n-  }\n-\n-  ensureNode(name) {\n-    let node = this.nodesByName[name];\n-    if (!node) {\n-      node = new Node(name);\n-      this.nodesByName[name] = node;\n-    }\n-    return node;\n-  }\n-}\n-\n-class Node {\n-  constructor(name, fullName) {\n-    this.name = name;\n-    this.fullName = fullName;\n-    this.children = [];\n-    this.outgoing = new Set();\n-    this.incoming = new Set();\n-  }\n-\n-  addChild(node) {\n-    this.children.push(node);\n-    return this;\n-  }\n-\n-  addOutgoing(node) {\n-    this.outgoing.add(node);\n-  }\n-\n-  addIncoming(node) {\n-    this.incoming.add(node);\n-  }\n-}\n-\n-class StackTrace {\n-  constructor(stackTraceData) {\n-    const frames = (stackTraceData && stackTraceData.frames) || [];\n-    this.frames = frames.map(frame => new StackFrame(frame));\n-  }\n-}\n-\n-class StackFrame {\n-  constructor({ name }) {\n-    this.id = name;\n-    const [fqcn, method] = name.split(\"#\");\n-    const lastDelimiterIdx = fqcn.lastIndexOf(\".\");\n-    this.package = new Package(fqcn.slice(0, lastDelimiterIdx));\n-    this.clazz = fqcn.slice(lastDelimiterIdx + 1);\n-    this.method = method.split(\"(\")[0];\n-  }\n-}\n-\n-class Package {\n-  constructor(name) {\n-    this.name = name;\n-  }\n-\n-  subpackages(maxDepth) {\n-    const parts = this.name.split(\".\");\n-    const subpackages = parts.reduce((acc, current, idx) => {\n-      if (maxDepth - 1 >= 0 && maxDepth - 1 < idx) {\n-        return acc;\n-      }\n-      const parent = acc[acc.length - 1];\n-      acc.push(parent ? `${parent}.${current}` : current);\n-      return acc;\n-    }, []);\n-    \/\/ subpackages.push(\"\/\" + parts.join(\".\"));\n-    return subpackages;\n-  }\n-}\n-\n-class Event {\n-  constructor({ type, attributes }) {\n-    this.type = type;\n-    if (!attributes) {\n-      return;\n-    }\n-    \/\/ TODO: support more time attributes\n-    this.time = attributes[\"(endTime)\"];\n-    this.eventThread = attributes.eventThread;\n-    this.stackTrace = new StackTrace(attributes.stackTrace);\n-    this.state = attributes.state;\n-  }\n-}\n-\n-function intersection(incoming, outgoing) {\n-  return incoming.filter((i) => outgoing.find((o) => o[1] == i[0]));\n-}\n-\n-function subtract(first, second, itemFn) {\n-  return first.filter((pair) => !second.find((i) => i[0] === itemFn(pair)));\n-}\n-\n-function formatTooltip(d) {\n-  let tooltip = d.data.name;\n-  const both = intersection(d.incoming, d.outgoing);\n-  const incoming = subtract(d.incoming, both, (p) => p[0]);\n-  const outgoing = subtract(d.outgoing, both, (p) => p[1]);\n-  const getName = (d) => d.data.name;\n-  const displayLink = (prefix, d) => `${prefix} ${getName(d)}`;\n-  const displayLinks = (prefix, ds, getItem) =>\n-    ds.map((d) => displayLink(prefix, getItem(d))).join(\"\\n\");\n-  tooltip += \"\\n\" + displayLinks(\"←\", incoming, (p) => p[0]);\n-  tooltip += \"\\n\" + displayLinks(\"↔\", both, (p) => p[0]);\n-  tooltip += \"\\n\" + displayLinks(\"→\", outgoing, (p) => p[1]);\n-  return tooltip;\n-}\n-\n-\n@@ -286,2 +105,0 @@\n-  \/\/ .leaves() returns only top level nodes, we need intermediaries too\n-  \/\/ const leaves = root.descendants().filter(node => node.data.leaf);\n@@ -289,1 +106,1 @@\n-  const map = new Map(leaves.map(d => [d.data.name, d]));\n+  const map = new Map(leaves.map((d) => [d.data.name, d]));\n@@ -293,1 +110,1 @@\n-      .map(i => {\n+      .map((i) => {\n@@ -296,1 +113,1 @@\n-      .filter(o => o[1]);\n+      .filter((o) => o[1]);\n@@ -307,45 +124,0 @@\n-\n-function buildGraph(data) {\n-  const graph = new Graph();\n-  data.events\n-    .map((d) => new Event(d))\n-    .forEach((event) => {\n-      const stackTrace = event.stackTrace;\n-      if (stackTrace) {\n-        const frames = stackTrace.frames.reverse();\n-        for (let idx = 0; idx < frames.length; idx++) {\n-          const currentFrame = frames[idx];\n-          const parentFrame = frames[idx - 1];\n-          const current = graph.createAllNodes(currentFrame);\n-          if (parentFrame) {\n-            const parent = graph.createAllNodes(parentFrame);\n-            if (parent != current) {\n-              parent.addIncoming(current);\n-              current.addOutgoing(parent);\n-            }\n-          }\n-          if (idx === frames.length - 1) {\n-            current.leaf = true;\n-          }\n-        }\n-      }\n-    });\n-  \/\/ _.forOwn(graph.nodesByName, (node, name) => {\n-  \/\/   if (node.leaf && node.children.length) {\n-  \/\/     console.log(node.name);\n-  \/\/   }\n-  \/\/ });\n-  return graph;\n-}\n-\n-function getColors() {\n-  const scheme = d3.schemeCategory10;\n-  return {\n-    outgoing: scheme[2],\n-    incoming: scheme[1],\n-    hover: scheme[0],\n-    both: scheme[3],\n-    default: \"#eee\",\n-    link: \"#ccc\"\n-  };\n-}\n\\ No newline at end of file\n","filename":"application\/org.openjdk.jmc.flightrecorder.hierarchical-edge\/src\/main\/resources\/hierarchical-edge.js","additions":5,"deletions":233,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+const marginLeft = 0;\n+const marginRight = 0;\n+const marginTop = 0;\n+const marginBottom = 0;\n+\n+let width = window.innerWidth - (marginLeft + marginRight);\n+let height = window.innerHeight - (marginTop + marginBottom);\n+\n+let levels = 2;\n+\n+function updateGraph(eventsJson, packageLevels, chartType) {\n+  const data = JSON.parse(eventsJson);\n+  debug(`${chartType} displaying ${data.events.length} events`);\n+  try {\n+    levels = packageLevels;\n+    width = window.innerWidth;\n+    height = window.innerHeight;\n+    d3.select(\"#hierarchical\").selectAll(\"*\").remove();\n+    if (chartType === \"EDGE_BUNDLING\") {\n+      const edgeBundlingData = transformEdgeBundlingData(data);\n+      renderHierarchicalEdgeBundling(edgeBundlingData);\n+    } else if (chartType === \"CHORD\") {\n+      const chordData = transformChordData(data);\n+      renderChordDiagram(chordData);\n+    }\n+  } catch (e) {\n+    debug(e.message);\n+    debug(`<pre>${e.stack}<\/pre>`);\n+  }\n+}\n","filename":"application\/org.openjdk.jmc.flightrecorder.hierarchical-edge\/src\/main\/resources\/main.js","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -10,1 +10,1 @@\n-    <div id=\"debug\" width=\"100%%\" style=\"text-align: left\">debug<\/div>\n+    <div id=\"debug\" width=\"100%%\" style=\"text-align: left; display:none;\"><\/div>\n@@ -15,0 +15,9 @@\n+    <script type=\"text\/javascript\">\n+      %3$s\n+    <\/script>\n+    <script type=\"text\/javascript\">\n+      %4$s\n+    <\/script>\n+    <script type=\"text\/javascript\">\n+      %5$s\n+    <\/script>\n@@ -16,1 +25,1 @@\n-<\/html>\n\\ No newline at end of file\n+<\/html>\n","filename":"application\/org.openjdk.jmc.flightrecorder.hierarchical-edge\/src\/main\/resources\/page.template","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,207 @@\n+class StackTrace {\n+  constructor(stackTraceData) {\n+    const frames = (stackTraceData && stackTraceData.frames) || [];\n+    this.frames = frames.map((frame) => new StackFrame(frame));\n+  }\n+}\n+\n+class StackFrame {\n+  constructor({ name }) {\n+    this.id = name;\n+    const [fqcn, method] = name.split(\"#\");\n+    const lastDelimiterIdx = fqcn.lastIndexOf(\".\");\n+    this.package = new Package(fqcn.slice(0, lastDelimiterIdx));\n+    this.clazz = fqcn.slice(lastDelimiterIdx + 1);\n+    this.method = method.split(\"(\")[0];\n+  }\n+}\n+\n+class Package {\n+  constructor(name) {\n+    this.name = name;\n+  }\n+\n+  subpackages(maxDepth) {\n+    const parts = this.name.split(\".\");\n+    const subpackages = parts.reduce((acc, current, idx) => {\n+      if (maxDepth - 1 >= 0 && maxDepth - 1 < idx) {\n+        return acc;\n+      }\n+      const parent = acc[acc.length - 1];\n+      acc.push(parent ? `${parent}.${current}` : current);\n+      return acc;\n+    }, []);\n+    \/\/ subpackages.push(\"\/\" + parts.join(\".\"));\n+    return subpackages;\n+  }\n+}\n+\n+class Event {\n+  constructor({ type, attributes }) {\n+    this.type = type;\n+    if (!attributes) {\n+      return;\n+    }\n+    \/\/ TODO: support more time attributes\n+    this.time = attributes[\"(endTime)\"];\n+    this.eventThread = attributes.eventThread;\n+    this.stackTrace = new StackTrace(attributes.stackTrace);\n+    this.state = attributes.state;\n+  }\n+}\n+\n+function debug(msg) {\n+  const displayEl = document.getElementById(\"debug\");\n+  displayEl.innerHTML += \"<br \/>\" + msg;\n+}\n+\n+function clear() {\n+  document.getElementById(\"debug\").innerHTML = \"\";\n+}\n+\n+\/\/ data manipulation for chord diagram\n+const maxPackages = 500;\n+\n+function truncatePackage(name, level) {\n+  return name.split(\".\").slice(0, level).join(\".\");\n+}\n+\n+function transformChordData(json) {\n+  const events = json.events.map((e) => new Event(e));\n+  let calls = {};\n+  events.forEach((e) => {\n+    const frames = e.stackTrace.frames;\n+    const len = frames.length;\n+    for (let i = len - 1; i > 0; i--) {\n+      const source = truncatePackage(frames[i].package.name, levels);\n+      const target = truncatePackage(frames[i - 1].package.name, levels);\n+      const id = `${source} ${target}`;\n+      calls[id] = (calls[id] || 0) + 1;\n+    }\n+  });\n+  calls = Object.entries(calls)\n+    .sort(([, a], [, b]) => b - a)\n+    .slice(0, maxPackages)\n+    .reduce((r, [k, v]) => ({ ...r, [k]: v }), {});\n+  return Object.keys(calls).map((id) => {\n+    const [source, target] = id.split(\" \");\n+    return { source, target, value: calls[id] };\n+  });\n+}\n+\n+\/\/ data manipulation for hierarchical edge bundling diagram\n+function transformEdgeBundlingData(data) {\n+  const graph = new Graph();\n+  data.events\n+    .map((d) => new Event(d))\n+    .forEach((event) => {\n+      const stackTrace = event.stackTrace;\n+      if (stackTrace) {\n+        const frames = stackTrace.frames.reverse();\n+        for (let idx = 0; idx < frames.length; idx++) {\n+          const currentFrame = frames[idx];\n+          const parentFrame = frames[idx - 1];\n+          const current = graph.createAllNodes(currentFrame);\n+          if (parentFrame) {\n+            const parent = graph.createAllNodes(parentFrame);\n+            if (parent != current) {\n+              parent.addIncoming(current);\n+              current.addOutgoing(parent);\n+            }\n+          }\n+          if (idx === frames.length - 1) {\n+            current.leaf = true;\n+          }\n+        }\n+      }\n+    });\n+  return graph;\n+}\n+\n+function getColors() {\n+  const scheme = d3.schemeCategory10;\n+  return {\n+    outgoing: scheme[2],\n+    incoming: scheme[1],\n+    hover: scheme[0],\n+    both: scheme[3],\n+    default: \"#eee\",\n+    link: \"#ccc\",\n+  };\n+}\n+\n+class Graph {\n+  constructor() {\n+    this.root = new Node(\"root\");\n+    this.nodesByName = { root: this.root };\n+  }\n+\n+  createAllNodes(frame) {\n+    const nodeNames = frame.package.subpackages(levels);\n+    let node = this.root;\n+    for (let nodeName of nodeNames) {\n+      const child = this.ensureNode(nodeName);\n+      const exists = node.children.find((c) => c.name === child.name);\n+      if (!exists) {\n+        node.children.push(child);\n+      }\n+      node = child;\n+    }\n+    return node;\n+  }\n+\n+  ensureNode(name) {\n+    let node = this.nodesByName[name];\n+    if (!node) {\n+      node = new Node(name);\n+      this.nodesByName[name] = node;\n+    }\n+    return node;\n+  }\n+}\n+\n+class Node {\n+  constructor(name, fullName) {\n+    this.name = name;\n+    this.fullName = fullName;\n+    this.children = [];\n+    this.outgoing = new Set();\n+    this.incoming = new Set();\n+  }\n+\n+  addChild(node) {\n+    this.children.push(node);\n+    return this;\n+  }\n+\n+  addOutgoing(node) {\n+    this.outgoing.add(node);\n+  }\n+\n+  addIncoming(node) {\n+    this.incoming.add(node);\n+  }\n+}\n+\n+function intersection(incoming, outgoing) {\n+  return incoming.filter((i) => outgoing.find((o) => o[1] == i[0]));\n+}\n+\n+function subtract(first, second, itemFn) {\n+  return first.filter((pair) => !second.find((i) => i[0] === itemFn(pair)));\n+}\n+\n+function formatTooltip(d) {\n+  let tooltip = d.data.name;\n+  const both = intersection(d.incoming, d.outgoing);\n+  const incoming = subtract(d.incoming, both, (p) => p[0]);\n+  const outgoing = subtract(d.outgoing, both, (p) => p[1]);\n+  const getName = (d) => d.data.name;\n+  const displayLink = (prefix, d) => `${prefix} ${getName(d)}`;\n+  const displayLinks = (prefix, ds, getItem) =>\n+    ds.map((d) => displayLink(prefix, getItem(d))).join(\"\\n\");\n+  tooltip += \"\\n\" + displayLinks(\"←\", incoming, (p) => p[0]);\n+  tooltip += \"\\n\" + displayLinks(\"↔\", both, (p) => p[0]);\n+  tooltip += \"\\n\" + displayLinks(\"→\", outgoing, (p) => p[1]);\n+  return tooltip;\n+}\n","filename":"application\/org.openjdk.jmc.flightrecorder.hierarchical-edge\/src\/main\/resources\/utils.js","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"}]}