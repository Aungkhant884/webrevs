{"files":[{"patch":"@@ -2,4 +2,4 @@\n-  const svg = d3\n-    .select(\"#hierarchical\")\n-    .append(\"svg\")\n-    .attr(\"viewBox\", [-width \/ 2, -height \/ 2, width, height]);\n+\tconst svg = d3\n+\t\t.select(\"#hierarchical\")\n+\t\t.append(\"svg\")\n+\t\t.attr(\"viewBox\", [-width \/ 2, -height \/ 2, width, height]);\n@@ -7,2 +7,2 @@\n-  const innerRadius = Math.max(Math.min(width, height) * 0.5 - 90, 100);\n-  const outerRadius = innerRadius + 10;\n+\tconst innerRadius = Math.max(Math.min(width, height) * 0.5 - 90, 100);\n+\tconst outerRadius = innerRadius + 10;\n@@ -10,7 +10,7 @@\n-  const names = Array.from(\n-    new Set(data.flatMap((d) => [d.source, d.target]))\n-  ).sort(d3.ascending);\n-  const color = d3.scaleOrdinal(\n-    names,\n-    d3.quantize(d3.interpolateRainbow, names.length)\n-  );\n+\tconst names = Array.from(\n+\t\tnew Set(data.flatMap((d) => [d.source, d.target]))\n+\t).sort(d3.ascending);\n+\tconst color = d3.scaleOrdinal(\n+\t\tnames,\n+\t\td3.quantize(d3.interpolateRainbow, names.length)\n+\t);\n@@ -18,5 +18,5 @@\n-  const chord = d3\n-    .chordDirected()\n-    .padAngle(10 \/ innerRadius)\n-    .sortSubgroups(d3.descending)\n-    .sortChords(d3.descending);\n+\tconst chord = d3\n+\t\t.chordDirected()\n+\t\t.padAngle(10 \/ innerRadius)\n+\t\t.sortSubgroups(d3.descending)\n+\t\t.sortChords(d3.descending);\n@@ -24,1 +24,1 @@\n-  const arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);\n+\tconst arc = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius);\n@@ -26,4 +26,4 @@\n-  const ribbon = d3\n-    .ribbonArrow()\n-    .radius(innerRadius - 1)\n-    .padAngle(1 \/ innerRadius);\n+\tconst ribbon = d3\n+\t\t.ribbonArrow()\n+\t\t.radius(innerRadius - 1)\n+\t\t.padAngle(1 \/ innerRadius);\n@@ -31,2 +31,2 @@\n-  const matrix = buildMatrix(data, names);\n-  const chords = chord(matrix);\n+\tconst matrix = buildMatrix(data, names);\n+\tconst chords = chord(matrix);\n@@ -34,7 +34,7 @@\n-  const group = svg\n-    .append(\"g\")\n-    .attr(\"font-size\", 10)\n-    .attr(\"font-family\", \"sans-serif\")\n-    .selectAll(\"g\")\n-    .data(chords.groups)\n-    .join(\"g\");\n+\tconst group = svg\n+\t\t.append(\"g\")\n+\t\t.attr(\"font-size\", 10)\n+\t\t.attr(\"font-family\", \"sans-serif\")\n+\t\t.selectAll(\"g\")\n+\t\t.data(chords.groups)\n+\t\t.join(\"g\");\n@@ -42,4 +42,4 @@\n-  group\n-    .append(\"path\")\n-    .attr(\"fill\", (d) => color(names[d.index]))\n-    .attr(\"d\", arc);\n+\tgroup\n+\t\t.append(\"path\")\n+\t\t.attr(\"fill\", (d) => color(names[d.index]))\n+\t\t.attr(\"d\", arc);\n@@ -47,14 +47,14 @@\n-  group\n-    .append(\"text\")\n-    .each((d) => (d.angle = (d.startAngle + d.endAngle) \/ 2))\n-    .attr(\"dy\", \"0.35em\")\n-    .attr(\n-      \"transform\",\n-      (d) => `\n-        rotate(${(d.angle * 180) \/ Math.PI - 90})\n-        translate(${outerRadius + 5})\n-        ${d.angle > Math.PI ? \"rotate(180)\" : \"\"}\n-      `\n-    )\n-    .attr(\"text-anchor\", (d) => (d.angle > Math.PI ? \"end\" : null))\n-    .text((d) => names[d.index]);\n+\tgroup\n+\t\t.append(\"text\")\n+\t\t.each((d) => (d.angle = (d.startAngle + d.endAngle) \/ 2))\n+\t\t.attr(\"dy\", \"0.35em\")\n+\t\t.attr(\n+\t\t\t\"transform\",\n+\t\t\t(d) => `\n+\t\t\t\trotate(${(d.angle * 180) \/ Math.PI - 90})\n+\t\t\t\ttranslate(${outerRadius + 5})\n+\t\t\t\t${d.angle > Math.PI ? \"rotate(180)\" : \"\"}\n+\t\t\t`\n+\t\t)\n+\t\t.attr(\"text-anchor\", (d) => (d.angle > Math.PI ? \"end\" : null))\n+\t\t.text((d) => names[d.index]);\n@@ -62,2 +62,2 @@\n-  group.append(\"title\").text(\n-    (d) => `${names[d.index]}\n+\tgroup.append(\"title\").text(\n+\t\t(d) => `${names[d.index]}\n@@ -65,2 +65,2 @@\n-  chords,\n-  (c) => (c.source.index === d.index) * c.source.value\n+\tchords,\n+\t(c) => (c.source.index === d.index) * c.source.value\n@@ -69,2 +69,2 @@\n-  chords,\n-  (c) => (c.target.index === d.index) * c.source.value\n+\tchords,\n+\t(c) => (c.target.index === d.index) * c.source.value\n@@ -72,1 +72,1 @@\n-  );\n+\t);\n@@ -74,14 +74,14 @@\n-  svg\n-    .append(\"g\")\n-    .attr(\"fill-opacity\", 0.75)\n-    .selectAll(\"path\")\n-    .data(chords)\n-    .join(\"path\")\n-    .style(\"mix-blend-mode\", \"multiply\")\n-    .attr(\"fill\", (d) => color(names[d.target.index]))\n-    .attr(\"d\", ribbon)\n-    .append(\"title\")\n-    .text(\n-      (d) =>\n-        `${names[d.source.index]} → ${names[d.target.index]} ${d.source.value}`\n-    );\n+\tsvg\n+\t\t.append(\"g\")\n+\t\t.attr(\"fill-opacity\", 0.75)\n+\t\t.selectAll(\"path\")\n+\t\t.data(chords)\n+\t\t.join(\"path\")\n+\t\t.style(\"mix-blend-mode\", \"multiply\")\n+\t\t.attr(\"fill\", (d) => color(names[d.target.index]))\n+\t\t.attr(\"d\", ribbon)\n+\t\t.append(\"title\")\n+\t\t.text(\n+\t\t\t(d) =>\n+\t\t\t\t`${names[d.source.index]} → ${names[d.target.index]} ${d.source.value}`\n+\t\t);\n@@ -89,1 +89,1 @@\n-  return svg.node();\n+\treturn svg.node();\n@@ -93,5 +93,5 @@\n-  const index = new Map(names.map((name, i) => [name, i]));\n-  const matrix = Array.from(index, () => new Array(names.length).fill(0));\n-  for (const { source, target, value } of data)\n-    matrix[index.get(source)][index.get(target)] += value;\n-  return matrix;\n+\tconst index = new Map(names.map((name, i) => [name, i]));\n+\tconst matrix = Array.from(index, () => new Array(names.length).fill(0));\n+\tfor (const { source, target, value } of data)\n+\t\tmatrix[index.get(source)][index.get(target)] += value;\n+\treturn matrix;\n","filename":"application\/org.openjdk.jmc.flightrecorder.hierarchical-edge\/src\/main\/resources\/chord.js","additions":77,"deletions":77,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -2,59 +2,59 @@\n-  \/\/ compute package hierarchy\n-  const svg = d3\n-    .select(\"#hierarchical\")\n-    .append(\"svg\")\n-    .attr(\"viewBox\", [-width \/ 2, -height \/ 2, width, height]);\n-  const d3Hierarchy = d3\n-    .hierarchy(graph.root)\n-    .sort(\n-      (a, b) =>\n-        d3.ascending(a.height, b.height) ||\n-        d3.ascending(a.data.name, b.data.name)\n-    );\n-  \/\/ we use the same formula as for the outerRadius in the chord diagram\n-  const radius = Math.max(Math.min(width, height) * 0.5 - 90, 100) + 10;\n-  const treeClustering = d3.cluster().size([2 * Math.PI, radius]);\n-  const root = treeClustering(bilink(d3Hierarchy));\n-  const colors = getColors();\n-  const node = svg\n-    .append(\"g\")\n-    .attr(\"font-family\", \"sans-serif\")\n-    .attr(\"font-size\", 10)\n-    .selectAll(\"g\")\n-    .data(root.leaves())\n-    .join(\"g\")\n-    .attr(\n-      \"transform\",\n-      (d) => `rotate(${(d.x * 180) \/ Math.PI - 90}) translate(${d.y},0)`\n-    )\n-    .append(\"text\")\n-    .attr(\"dy\", \"0.31em\")\n-    .attr(\"x\", (d) => (d.x < Math.PI ? 6 : -6))\n-    .attr(\"text-anchor\", (d) => (d.x < Math.PI ? \"start\" : \"end\"))\n-    .attr(\"transform\", (d) => (d.x >= Math.PI ? \"rotate(180)\" : null))\n-    .text((d) => d.data.name)\n-    .each(function (d) {\n-      d.text = this;\n-    })\n-    .on(\"mouseover\", overed)\n-    .on(\"mouseout\", outed)\n-    .call((text) =>\n-      text.attr(\"fill\", colors.default).append(\"title\").text(formatTooltip)\n-    );\n-  const line = d3\n-    .lineRadial()\n-    .curve(d3.curveBundle.beta(0.85))\n-    .radius((d) => d.y)\n-    .angle((d) => d.x);\n-  const link = svg\n-    .append(\"g\")\n-    .attr(\"stroke\", colors.link)\n-    .attr(\"fill\", \"none\")\n-    .selectAll(\"path\")\n-    .data(root.leaves().flatMap((leaf) => leaf.outgoing))\n-    .join(\"path\")\n-    .style(\"mix-blend-mode\", \"multiply\")\n-    .attr(\"d\", ([i, o]) => line(i.path(o)))\n-    .each(function (d) {\n-      d.path = this;\n-    });\n+\t\/\/ compute package hierarchy\n+\tconst svg = d3\n+\t\t.select(\"#hierarchical\")\n+\t\t.append(\"svg\")\n+\t\t.attr(\"viewBox\", [-width \/ 2, -height \/ 2, width, height]);\n+\tconst d3Hierarchy = d3\n+\t\t.hierarchy(graph.root)\n+\t\t.sort(\n+\t\t\t(a, b) =>\n+\t\t\t\td3.ascending(a.height, b.height) ||\n+\t\t\t\td3.ascending(a.data.name, b.data.name)\n+\t\t);\n+\t\/\/ we use the same formula as for the outerRadius in the chord diagram\n+\tconst radius = Math.max(Math.min(width, height) * 0.5 - 90, 100) + 10;\n+\tconst treeClustering = d3.cluster().size([2 * Math.PI, radius]);\n+\tconst root = treeClustering(bilink(d3Hierarchy));\n+\tconst colors = getColors();\n+\tconst node = svg\n+\t\t.append(\"g\")\n+\t\t.attr(\"font-family\", \"sans-serif\")\n+\t\t.attr(\"font-size\", 10)\n+\t\t.selectAll(\"g\")\n+\t\t.data(root.leaves())\n+\t\t.join(\"g\")\n+\t\t.attr(\n+\t\t\t\"transform\",\n+\t\t\t(d) => `rotate(${(d.x * 180) \/ Math.PI - 90}) translate(${d.y},0)`\n+\t\t)\n+\t\t.append(\"text\")\n+\t\t.attr(\"dy\", \"0.31em\")\n+\t\t.attr(\"x\", (d) => (d.x < Math.PI ? 6 : -6))\n+\t\t.attr(\"text-anchor\", (d) => (d.x < Math.PI ? \"start\" : \"end\"))\n+\t\t.attr(\"transform\", (d) => (d.x >= Math.PI ? \"rotate(180)\" : null))\n+\t\t.text((d) => d.data.name)\n+\t\t.each(function (d) {\n+\t\t\td.text = this;\n+\t\t})\n+\t\t.on(\"mouseover\", overed)\n+\t\t.on(\"mouseout\", outed)\n+\t\t.call((text) =>\n+\t\t\ttext.attr(\"fill\", colors.default).append(\"title\").text(formatTooltip)\n+\t\t);\n+\tconst line = d3\n+\t\t.lineRadial()\n+\t\t.curve(d3.curveBundle.beta(0.85))\n+\t\t.radius((d) => d.y)\n+\t\t.angle((d) => d.x);\n+\tconst link = svg\n+\t\t.append(\"g\")\n+\t\t.attr(\"stroke\", colors.link)\n+\t\t.attr(\"fill\", \"none\")\n+\t\t.selectAll(\"path\")\n+\t\t.data(root.leaves().flatMap((leaf) => leaf.outgoing))\n+\t\t.join(\"path\")\n+\t\t.style(\"mix-blend-mode\", \"multiply\")\n+\t\t.attr(\"d\", ([i, o]) => line(i.path(o)))\n+\t\t.each(function (d) {\n+\t\t\td.path = this;\n+\t\t});\n@@ -62,18 +62,18 @@\n-  function overed(event, d) {\n-    link.style(\"mix-blend-mode\", null);\n-    d3.select(this)\n-      .attr(\"font-weight\", \"bold\")\n-      .attr(\"fill\", colors.hover)\n-      .style(\"cursor\", \"default\");\n-    d3.selectAll(d.incoming.map((d) => d.path))\n-      .attr(\"stroke\", colors.incoming)\n-      .raise();\n-    d3.selectAll(d.incoming.map(([d]) => d.text))\n-      .attr(\"fill\", colors.incoming)\n-      .attr(\"font-weight\", \"bold\");\n-    d3.selectAll(d.outgoing.map((d) => d.path))\n-      .attr(\"stroke\", colors.outgoing)\n-      .raise();\n-    d3.selectAll(d.outgoing.map(([, d]) => d.text))\n-      .attr(\"fill\", colors.outgoing)\n-      .attr(\"font-weight\", \"bold\");\n+\tfunction overed(event, d) {\n+\t\tlink.style(\"mix-blend-mode\", null);\n+\t\td3.select(this)\n+\t\t\t.attr(\"font-weight\", \"bold\")\n+\t\t\t.attr(\"fill\", colors.hover)\n+\t\t\t.style(\"cursor\", \"default\");\n+\t\td3.selectAll(d.incoming.map((d) => d.path))\n+\t\t\t.attr(\"stroke\", colors.incoming)\n+\t\t\t.raise();\n+\t\td3.selectAll(d.incoming.map(([d]) => d.text))\n+\t\t\t.attr(\"fill\", colors.incoming)\n+\t\t\t.attr(\"font-weight\", \"bold\");\n+\t\td3.selectAll(d.outgoing.map((d) => d.path))\n+\t\t\t.attr(\"stroke\", colors.outgoing)\n+\t\t\t.raise();\n+\t\td3.selectAll(d.outgoing.map(([, d]) => d.text))\n+\t\t\t.attr(\"fill\", colors.outgoing)\n+\t\t\t.attr(\"font-weight\", \"bold\");\n@@ -81,8 +81,8 @@\n-    const both = intersection(d.incoming, d.outgoing);\n-    d3.selectAll(both.map((d) => d.path))\n-      .attr(\"stroke\", colors.both)\n-      .raise();\n-    d3.selectAll(both.map(([d]) => d.text))\n-      .attr(\"fill\", colors.both)\n-      .attr(\"font-weight\", \"bold\");\n-  }\n+\t\tconst both = intersection(d.incoming, d.outgoing);\n+\t\td3.selectAll(both.map((d) => d.path))\n+\t\t\t.attr(\"stroke\", colors.both)\n+\t\t\t.raise();\n+\t\td3.selectAll(both.map(([d]) => d.text))\n+\t\t\t.attr(\"fill\", colors.both)\n+\t\t\t.attr(\"font-weight\", \"bold\");\n+\t}\n@@ -90,12 +90,12 @@\n-  function outed(event, d) {\n-    link.style(\"mix-blend-mode\", \"multiply\");\n-    d3.select(this).attr(\"font-weight\", null).attr(\"fill\", colors.default);\n-    d3.selectAll(d.incoming.map((d) => d.path)).attr(\"stroke\", null);\n-    d3.selectAll(d.incoming.map(([d]) => d.text))\n-      .attr(\"fill\", colors.default)\n-      .attr(\"font-weight\", null);\n-    d3.selectAll(d.outgoing.map((d) => d.path)).attr(\"stroke\", null);\n-    d3.selectAll(d.outgoing.map(([, d]) => d.text))\n-      .attr(\"fill\", colors.default)\n-      .attr(\"font-weight\", null);\n-  }\n+\tfunction outed(event, d) {\n+\t\tlink.style(\"mix-blend-mode\", \"multiply\");\n+\t\td3.select(this).attr(\"font-weight\", null).attr(\"fill\", colors.default);\n+\t\td3.selectAll(d.incoming.map((d) => d.path)).attr(\"stroke\", null);\n+\t\td3.selectAll(d.incoming.map(([d]) => d.text))\n+\t\t\t.attr(\"fill\", colors.default)\n+\t\t\t.attr(\"font-weight\", null);\n+\t\td3.selectAll(d.outgoing.map((d) => d.path)).attr(\"stroke\", null);\n+\t\td3.selectAll(d.outgoing.map(([, d]) => d.text))\n+\t\t\t.attr(\"fill\", colors.default)\n+\t\t\t.attr(\"font-weight\", null);\n+\t}\n@@ -103,1 +103,1 @@\n-  return svg.node();\n+\treturn svg.node();\n@@ -107,10 +107,10 @@\n-  const leaves = root.leaves();\n-  const map = new Map(leaves.map((d) => [d.data.name, d]));\n-  for (const d of leaves) {\n-    d.incoming = [];\n-    d.outgoing = [...d.data.outgoing]\n-      .map((i) => {\n-        return [d, map.get(i.name)];\n-      })\n-      .filter((o) => o[1]);\n-  }\n+\tconst leaves = root.leaves();\n+\tconst map = new Map(leaves.map((d) => [d.data.name, d]));\n+\tfor (const d of leaves) {\n+\t\td.incoming = [];\n+\t\td.outgoing = [...d.data.outgoing]\n+\t\t\t.map((i) => {\n+\t\t\t\treturn [d, map.get(i.name)];\n+\t\t\t})\n+\t\t\t.filter((o) => o[1]);\n+\t}\n@@ -118,5 +118,5 @@\n-  for (const d of leaves) {\n-    for (const o of d.outgoing) {\n-      o[1].incoming.push(o);\n-    }\n-  }\n+\tfor (const d of leaves) {\n+\t\tfor (const o of d.outgoing) {\n+\t\t\to[1].incoming.push(o);\n+\t\t}\n+\t}\n@@ -124,1 +124,1 @@\n-  return root;\n+\treturn root;\n","filename":"application\/org.openjdk.jmc.flightrecorder.hierarchical-edge\/src\/main\/resources\/hierarchical-edge.js","additions":114,"deletions":114,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -7,18 +7,18 @@\n-  const data = JSON.parse(eventsJson);\n-  debug(`${chartType} displaying ${data.events.length} events`);\n-  try {\n-    levels = packageLevels;\n-    width = window.innerWidth;\n-    height = window.innerHeight;\n-    d3.select(\"#hierarchical\").selectAll(\"*\").remove();\n-    if (chartType === \"EDGE_BUNDLING\") {\n-      const edgeBundlingData = transformEdgeBundlingData(data);\n-      renderHierarchicalEdgeBundling(edgeBundlingData);\n-    } else if (chartType === \"CHORD\") {\n-      const chordData = transformChordData(data);\n-      renderChordDiagram(chordData);\n-    }\n-  } catch (e) {\n-    debug(e.message);\n-    debug(`<pre>${e.stack}<\/pre>`);\n-  }\n+\tconst data = JSON.parse(eventsJson);\n+\tdebug(`${chartType} displaying ${data.events.length} events`);\n+\ttry {\n+\t\tlevels = packageLevels;\n+\t\twidth = window.innerWidth;\n+\t\theight = window.innerHeight;\n+\t\td3.select(\"#hierarchical\").selectAll(\"*\").remove();\n+\t\tif (chartType === \"EDGE_BUNDLING\") {\n+\t\t\tconst edgeBundlingData = transformEdgeBundlingData(data);\n+\t\t\trenderHierarchicalEdgeBundling(edgeBundlingData);\n+\t\t} else if (chartType === \"CHORD\") {\n+\t\t\tconst chordData = transformChordData(data);\n+\t\t\trenderChordDiagram(chordData);\n+\t\t}\n+\t} catch (e) {\n+\t\tdebug(e.message);\n+\t\tdebug(`<pre>${e.stack}<\/pre>`);\n+\t}\n","filename":"application\/org.openjdk.jmc.flightrecorder.hierarchical-edge\/src\/main\/resources\/main.js","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -3,22 +3,22 @@\n-  <head>\n-    <meta http-equiv=\"content-type\" content=\"text\/html; charset=utf-8\" \/>\n-    <script>\n-      %1$s\n-    <\/script>\n-  <\/head>\n-  <body>\n-    <div id=\"debug\" width=\"100%%\" style=\"text-align: left; display:none;\"><\/div>\n-    <div id=\"hierarchical\" width=\"100%%\" style=\"text-align: center\"><\/div>\n-    <script type=\"text\/javascript\">\n-      %2$s\n-    <\/script>\n-    <script type=\"text\/javascript\">\n-      %3$s\n-    <\/script>\n-    <script type=\"text\/javascript\">\n-      %4$s\n-    <\/script>\n-    <script type=\"text\/javascript\">\n-      %5$s\n-    <\/script>\n-  <\/body>\n+\t<head>\n+\t\t<meta http-equiv=\"content-type\" content=\"text\/html; charset=utf-8\" \/>\n+\t\t<script>\n+\t\t\t%1$s\n+\t\t<\/script>\n+\t<\/head>\n+\t<body>\n+\t\t<div id=\"debug\" width=\"100%%\" style=\"text-align: left; display:none;\"><\/div>\n+\t\t<div id=\"hierarchical\" width=\"100%%\" style=\"text-align: center\"><\/div>\n+\t\t<script type=\"text\/javascript\">\n+\t\t\t%2$s\n+\t\t<\/script>\n+\t\t<script type=\"text\/javascript\">\n+\t\t\t%3$s\n+\t\t<\/script>\n+\t\t<script type=\"text\/javascript\">\n+\t\t\t%4$s\n+\t\t<\/script>\n+\t\t<script type=\"text\/javascript\">\n+\t\t\t%5$s\n+\t\t<\/script>\n+\t<\/body>\n","filename":"application\/org.openjdk.jmc.flightrecorder.hierarchical-edge\/src\/main\/resources\/page.template","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,4 +2,4 @@\n-  constructor(stackTraceData) {\n-    const frames = (stackTraceData && stackTraceData.frames) || [];\n-    this.frames = frames.map((frame) => new StackFrame(frame));\n-  }\n+\tconstructor(stackTraceData) {\n+\t\tconst frames = (stackTraceData && stackTraceData.frames) || [];\n+\t\tthis.frames = frames.map((frame) => new StackFrame(frame));\n+\t}\n@@ -9,8 +9,8 @@\n-  constructor({ name }) {\n-    this.id = name;\n-    const [fqcn, method] = name.split(\"#\");\n-    const lastDelimiterIdx = fqcn.lastIndexOf(\".\");\n-    this.package = new Package(fqcn.slice(0, lastDelimiterIdx));\n-    this.clazz = fqcn.slice(lastDelimiterIdx + 1);\n-    this.method = method.split(\"(\")[0];\n-  }\n+\tconstructor({ name }) {\n+\t\tthis.id = name;\n+\t\tconst [fqcn, method] = name.split(\"#\");\n+\t\tconst lastDelimiterIdx = fqcn.lastIndexOf(\".\");\n+\t\tthis.package = new Package(fqcn.slice(0, lastDelimiterIdx));\n+\t\tthis.clazz = fqcn.slice(lastDelimiterIdx + 1);\n+\t\tthis.method = method.split(\"(\")[0];\n+\t}\n@@ -20,17 +20,17 @@\n-  constructor(name) {\n-    this.name = name;\n-  }\n-\n-  subpackages(maxDepth) {\n-    const parts = this.name.split(\".\");\n-    const subpackages = parts.reduce((acc, current, idx) => {\n-      if (maxDepth - 1 >= 0 && maxDepth - 1 < idx) {\n-        return acc;\n-      }\n-      const parent = acc[acc.length - 1];\n-      acc.push(parent ? `${parent}.${current}` : current);\n-      return acc;\n-    }, []);\n-    \/\/ subpackages.push(\"\/\" + parts.join(\".\"));\n-    return subpackages;\n-  }\n+\tconstructor(name) {\n+\t\tthis.name = name;\n+\t}\n+\n+\tsubpackages(maxDepth) {\n+\t\tconst parts = this.name.split(\".\");\n+\t\tconst subpackages = parts.reduce((acc, current, idx) => {\n+\t\t\tif (maxDepth - 1 >= 0 && maxDepth - 1 < idx) {\n+\t\t\t\treturn acc;\n+\t\t\t}\n+\t\t\tconst parent = acc[acc.length - 1];\n+\t\t\tacc.push(parent ? `${parent}.${current}` : current);\n+\t\t\treturn acc;\n+\t\t}, []);\n+\t\t\/\/ subpackages.push(\"\/\" + parts.join(\".\"));\n+\t\treturn subpackages;\n+\t}\n@@ -40,11 +40,11 @@\n-  constructor({ type, attributes }) {\n-    this.type = type;\n-    if (!attributes) {\n-      return;\n-    }\n-    \/\/ TODO: support more time attributes\n-    this.time = attributes[\"(endTime)\"];\n-    this.eventThread = attributes.eventThread;\n-    this.stackTrace = new StackTrace(attributes.stackTrace);\n-    this.state = attributes.state;\n-  }\n+\tconstructor({ type, attributes }) {\n+\t\tthis.type = type;\n+\t\tif (!attributes) {\n+\t\t\treturn;\n+\t\t}\n+\t\t\/\/ TODO: support more time attributes\n+\t\tthis.time = attributes[\"(endTime)\"];\n+\t\tthis.eventThread = attributes.eventThread;\n+\t\tthis.stackTrace = new StackTrace(attributes.stackTrace);\n+\t\tthis.state = attributes.state;\n+\t}\n@@ -54,2 +54,2 @@\n-  const displayEl = document.getElementById(\"debug\");\n-  displayEl.innerHTML += \"<br \/>\" + msg;\n+\tconst displayEl = document.getElementById(\"debug\");\n+\tdisplayEl.innerHTML += \"<br \/>\" + msg;\n@@ -59,1 +59,1 @@\n-  document.getElementById(\"debug\").innerHTML = \"\";\n+\tdocument.getElementById(\"debug\").innerHTML = \"\";\n@@ -66,1 +66,1 @@\n-  return name.split(\".\").slice(0, level).join(\".\");\n+\treturn name.split(\".\").slice(0, level).join(\".\");\n@@ -70,20 +70,20 @@\n-  const events = json.events.map((e) => new Event(e));\n-  let calls = {};\n-  events.forEach((e) => {\n-    const frames = e.stackTrace.frames;\n-    const len = frames.length;\n-    for (let i = len - 1; i > 0; i--) {\n-      const source = truncatePackage(frames[i].package.name, levels);\n-      const target = truncatePackage(frames[i - 1].package.name, levels);\n-      const id = `${source} ${target}`;\n-      calls[id] = (calls[id] || 0) + 1;\n-    }\n-  });\n-  calls = Object.entries(calls)\n-    .sort(([, a], [, b]) => b - a)\n-    .slice(0, maxPackages)\n-    .reduce((r, [k, v]) => ({ ...r, [k]: v }), {});\n-  return Object.keys(calls).map((id) => {\n-    const [source, target] = id.split(\" \");\n-    return { source, target, value: calls[id] };\n-  });\n+\tconst events = json.events.map((e) => new Event(e));\n+\tlet calls = {};\n+\tevents.forEach((e) => {\n+\t\tconst frames = e.stackTrace.frames;\n+\t\tconst len = frames.length;\n+\t\tfor (let i = len - 1; i > 0; i--) {\n+\t\t\tconst source = truncatePackage(frames[i].package.name, levels);\n+\t\t\tconst target = truncatePackage(frames[i - 1].package.name, levels);\n+\t\t\tconst id = `${source} ${target}`;\n+\t\t\tcalls[id] = (calls[id] || 0) + 1;\n+\t\t}\n+\t});\n+\tcalls = Object.entries(calls)\n+\t\t.sort(([, a], [, b]) => b - a)\n+\t\t.slice(0, maxPackages)\n+\t\t.reduce((r, [k, v]) => ({ ...r, [k]: v }), {});\n+\treturn Object.keys(calls).map((id) => {\n+\t\tconst [source, target] = id.split(\" \");\n+\t\treturn { source, target, value: calls[id] };\n+\t});\n@@ -94,25 +94,25 @@\n-  const graph = new Graph();\n-  data.events\n-    .map((d) => new Event(d))\n-    .forEach((event) => {\n-      const stackTrace = event.stackTrace;\n-      if (stackTrace) {\n-        const frames = stackTrace.frames.reverse();\n-        for (let idx = 0; idx < frames.length; idx++) {\n-          const currentFrame = frames[idx];\n-          const parentFrame = frames[idx - 1];\n-          const current = graph.createAllNodes(currentFrame);\n-          if (parentFrame) {\n-            const parent = graph.createAllNodes(parentFrame);\n-            if (parent != current) {\n-              parent.addIncoming(current);\n-              current.addOutgoing(parent);\n-            }\n-          }\n-          if (idx === frames.length - 1) {\n-            current.leaf = true;\n-          }\n-        }\n-      }\n-    });\n-  return graph;\n+\tconst graph = new Graph();\n+\tdata.events\n+\t\t.map((d) => new Event(d))\n+\t\t.forEach((event) => {\n+\t\t\tconst stackTrace = event.stackTrace;\n+\t\t\tif (stackTrace) {\n+\t\t\t\tconst frames = stackTrace.frames.reverse();\n+\t\t\t\tfor (let idx = 0; idx < frames.length; idx++) {\n+\t\t\t\t\tconst currentFrame = frames[idx];\n+\t\t\t\t\tconst parentFrame = frames[idx - 1];\n+\t\t\t\t\tconst current = graph.createAllNodes(currentFrame);\n+\t\t\t\t\tif (parentFrame) {\n+\t\t\t\t\t\tconst parent = graph.createAllNodes(parentFrame);\n+\t\t\t\t\t\tif (parent != current) {\n+\t\t\t\t\t\t\tparent.addIncoming(current);\n+\t\t\t\t\t\t\tcurrent.addOutgoing(parent);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (idx === frames.length - 1) {\n+\t\t\t\t\t\tcurrent.leaf = true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\treturn graph;\n@@ -122,9 +122,9 @@\n-  const scheme = d3.schemeCategory10;\n-  return {\n-    outgoing: scheme[2],\n-    incoming: scheme[1],\n-    hover: scheme[0],\n-    both: scheme[3],\n-    default: \"#eee\",\n-    link: \"#ccc\",\n-  };\n+\tconst scheme = d3.schemeCategory10;\n+\treturn {\n+\t\toutgoing: scheme[2],\n+\t\tincoming: scheme[1],\n+\t\thover: scheme[0],\n+\t\tboth: scheme[3],\n+\t\tdefault: \"#eee\",\n+\t\tlink: \"#ccc\",\n+\t};\n@@ -134,27 +134,27 @@\n-  constructor() {\n-    this.root = new Node(\"root\");\n-    this.nodesByName = { root: this.root };\n-  }\n-\n-  createAllNodes(frame) {\n-    const nodeNames = frame.package.subpackages(levels);\n-    let node = this.root;\n-    for (let nodeName of nodeNames) {\n-      const child = this.ensureNode(nodeName);\n-      const exists = node.children.find((c) => c.name === child.name);\n-      if (!exists) {\n-        node.children.push(child);\n-      }\n-      node = child;\n-    }\n-    return node;\n-  }\n-\n-  ensureNode(name) {\n-    let node = this.nodesByName[name];\n-    if (!node) {\n-      node = new Node(name);\n-      this.nodesByName[name] = node;\n-    }\n-    return node;\n-  }\n+\tconstructor() {\n+\t\tthis.root = new Node(\"root\");\n+\t\tthis.nodesByName = { root: this.root };\n+\t}\n+\n+\tcreateAllNodes(frame) {\n+\t\tconst nodeNames = frame.package.subpackages(levels);\n+\t\tlet node = this.root;\n+\t\tfor (let nodeName of nodeNames) {\n+\t\t\tconst child = this.ensureNode(nodeName);\n+\t\t\tconst exists = node.children.find((c) => c.name === child.name);\n+\t\t\tif (!exists) {\n+\t\t\t\tnode.children.push(child);\n+\t\t\t}\n+\t\t\tnode = child;\n+\t\t}\n+\t\treturn node;\n+\t}\n+\n+\tensureNode(name) {\n+\t\tlet node = this.nodesByName[name];\n+\t\tif (!node) {\n+\t\t\tnode = new Node(name);\n+\t\t\tthis.nodesByName[name] = node;\n+\t\t}\n+\t\treturn node;\n+\t}\n@@ -164,20 +164,20 @@\n-  constructor(name, fullName) {\n-    this.name = name;\n-    this.fullName = fullName;\n-    this.children = [];\n-    this.outgoing = new Set();\n-    this.incoming = new Set();\n-  }\n-\n-  addChild(node) {\n-    this.children.push(node);\n-    return this;\n-  }\n-\n-  addOutgoing(node) {\n-    this.outgoing.add(node);\n-  }\n-\n-  addIncoming(node) {\n-    this.incoming.add(node);\n-  }\n+\tconstructor(name, fullName) {\n+\t\tthis.name = name;\n+\t\tthis.fullName = fullName;\n+\t\tthis.children = [];\n+\t\tthis.outgoing = new Set();\n+\t\tthis.incoming = new Set();\n+\t}\n+\n+\taddChild(node) {\n+\t\tthis.children.push(node);\n+\t\treturn this;\n+\t}\n+\n+\taddOutgoing(node) {\n+\t\tthis.outgoing.add(node);\n+\t}\n+\n+\taddIncoming(node) {\n+\t\tthis.incoming.add(node);\n+\t}\n@@ -187,1 +187,1 @@\n-  return incoming.filter((i) => outgoing.find((o) => o[1] == i[0]));\n+\treturn incoming.filter((i) => outgoing.find((o) => o[1] == i[0]));\n@@ -191,1 +191,1 @@\n-  return first.filter((pair) => !second.find((i) => i[0] === itemFn(pair)));\n+\treturn first.filter((pair) => !second.find((i) => i[0] === itemFn(pair)));\n@@ -195,12 +195,12 @@\n-  let tooltip = d.data.name;\n-  const both = intersection(d.incoming, d.outgoing);\n-  const incoming = subtract(d.incoming, both, (p) => p[0]);\n-  const outgoing = subtract(d.outgoing, both, (p) => p[1]);\n-  const getName = (d) => d.data.name;\n-  const displayLink = (prefix, d) => `${prefix} ${getName(d)}`;\n-  const displayLinks = (prefix, ds, getItem) =>\n-    ds.map((d) => displayLink(prefix, getItem(d))).join(\"\\n\");\n-  tooltip += \"\\n\" + displayLinks(\"←\", incoming, (p) => p[0]);\n-  tooltip += \"\\n\" + displayLinks(\"↔\", both, (p) => p[0]);\n-  tooltip += \"\\n\" + displayLinks(\"→\", outgoing, (p) => p[1]);\n-  return tooltip;\n+\tlet tooltip = d.data.name;\n+\tconst both = intersection(d.incoming, d.outgoing);\n+\tconst incoming = subtract(d.incoming, both, (p) => p[0]);\n+\tconst outgoing = subtract(d.outgoing, both, (p) => p[1]);\n+\tconst getName = (d) => d.data.name;\n+\tconst displayLink = (prefix, d) => `${prefix} ${getName(d)}`;\n+\tconst displayLinks = (prefix, ds, getItem) =>\n+\t\tds.map((d) => displayLink(prefix, getItem(d))).join(\"\\n\");\n+\ttooltip += \"\\n\" + displayLinks(\"←\", incoming, (p) => p[0]);\n+\ttooltip += \"\\n\" + displayLinks(\"↔\", both, (p) => p[0]);\n+\ttooltip += \"\\n\" + displayLinks(\"→\", outgoing, (p) => p[1]);\n+\treturn tooltip;\n","filename":"application\/org.openjdk.jmc.flightrecorder.hierarchical-edge\/src\/main\/resources\/utils.js","additions":159,"deletions":159,"binary":false,"changes":318,"status":"modified"}]}