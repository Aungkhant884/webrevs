{"files":[{"patch":"@@ -101,0 +101,1 @@\n+\tprivate final long duration;\n@@ -103,2 +104,4 @@\n-\t\tthis.startTicks = settings.getStartTimestamp();\n-\t\tthis.startNanos = settings.getStartTimestamp();\n+\t\tthis.startTicks = settings.getStartTicks() != -1 ? settings.getStartTicks() : System.nanoTime();\n+\t\tthis.startNanos = settings.getStartTimestamp() != -1 ? settings.getStartTimestamp()\n+\t\t\t\t: System.currentTimeMillis() * 1_000_000L;\n+\t\tthis.duration = settings.getDuration();\n@@ -282,1 +285,1 @@\n-\t\tlong duration = System.nanoTime() - startTicks;\n+\t\tlong recDuration = duration > 0 ? duration : System.nanoTime() - startTicks;\n@@ -290,1 +293,1 @@\n-\t\tglobalWriter.writeLongRaw(DURATION_NANOS_OFFSET, duration);\n+\t\tglobalWriter.writeLongRaw(DURATION_NANOS_OFFSET, recDuration);\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/RecordingImpl.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n@@ -8,0 +41,3 @@\n+\tprivate long startTicks = -1;\n+\n+\tprivate long duration = -1;\n@@ -16,0 +52,12 @@\n+\t@Override\n+\tpublic RecordingSettingsBuilder withStartTicks(long ticks) {\n+\t\tthis.startTicks = ticks;\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic RecordingSettingsBuilder withDuration(long ticks) {\n+\t\tthis.duration = duration;\n+\t\treturn this;\n+\t}\n+\n@@ -25,1 +73,1 @@\n-\t\t\t\tinitializeJdkTypes);\n+\t\t\t\tstartTicks > 0 ? startTicks : System.nanoTime(), duration, initializeJdkTypes);\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/RecordingSettingsBuilderImpl.java","additions":49,"deletions":1,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n@@ -8,0 +41,3 @@\n+\tprivate final long startTicks;\n+\n+\tprivate final long duration;\n@@ -13,0 +49,6 @@\n+\t *            or -1 to use {@linkplain System#currentTimeMillis()} * 1_000_000\n+\t * @param startTicks\n+\t *            the recording start timestamp in ticks or -1 to use {@linkplain System#nanoTime()}\n+\t * @param duration\n+\t *            the recording duration in ticks or -1 to use the current\n+\t *            {@linkplain System#nanoTime()} to compute the diff from {@linkplain #startTicks}\n@@ -17,1 +59,1 @@\n-\tpublic RecordingSettings(long startTimestamp, boolean initializeJDKTypes) {\n+\tpublic RecordingSettings(long startTimestamp, long startTicks, long duration, boolean initializeJDKTypes) {\n@@ -19,0 +61,2 @@\n+\t\tthis.startTicks = startTicks;\n+\t\tthis.duration = duration;\n@@ -22,0 +66,11 @@\n+\t\/**\n+\t * @param startTimestamp\n+\t *            the recording start timestamp in epoch nanoseconds (nanoseconds since 1970-01-01)\n+\t * @param initializeJDKTypes\n+\t *            should the {@linkplain org.openjdk.jmc.flightrecorder.writer.api.Types.JDK} types\n+\t *            be initialized\n+\t *\/\n+\tpublic RecordingSettings(long startTimestamp, boolean initializeJDKTypes) {\n+\t\tthis(startTimestamp, -1, -1, initializeJDKTypes);\n+\t}\n+\n@@ -30,1 +85,1 @@\n-\t\tthis(-1, initializeJDKTypes);\n+\t\tthis(-1, -1, -1, initializeJDKTypes);\n@@ -41,1 +96,1 @@\n-\t\tthis(startTimestamp, true);\n+\t\tthis(startTimestamp, -1, -1, true);\n@@ -49,1 +104,1 @@\n-\t\tthis(-1, true);\n+\t\tthis(-1, -1, -1, true);\n@@ -59,0 +114,15 @@\n+\t\/**\n+\t * @return recording timestamp in ticks or -1 to use the current value of\n+\t *         {@linkplain System#nanoTime()}\n+\t *\/\n+\tpublic long getStartTicks() {\n+\t\treturn startTicks;\n+\t}\n+\n+\t\/**\n+\t * @return recording duration in ticks or -1 to derive it from {@linkplain System#nanoTime()}\n+\t *\/\n+\tpublic long getDuration() {\n+\t\treturn duration;\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/RecordingSettings.java","additions":74,"deletions":4,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n@@ -16,0 +49,24 @@\n+\t\/**\n+\t * Set the recording starting timestamp in ticks.\n+\t *\n+\t * @param ticks\n+\t *            a tick represent a monotonic increase in time\n+\t * @return this instance for chaining\n+\t * @since 8.3.0\n+\t *\/\n+\tdefault RecordingSettingsBuilder withStartTicks(long ticks) {\n+\t\treturn this;\n+\t}\n+\n+\t\/**\n+\t * Set the recording duration in ticks.\n+\t *\n+\t * @param ticks\n+\t *            a tick represent a monotonic increase in time\n+\t * @return this instance for chaining\n+\t * @since 8.3.0\n+\t *\/\n+\tdefault RecordingSettingsBuilder withDuration(long ticks) {\n+\t\treturn this;\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/RecordingSettingsBuilder.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -86,0 +86,19 @@\n+\t\t<dependency>\n+\t\t\t<groupId>org.mockito<\/groupId>\n+\t\t\t<artifactId>mockito-junit-jupiter<\/artifactId>\n+\t\t<\/dependency>\n+\t\t<dependency>\n+\t\t\t<groupId>org.jctools<\/groupId>\n+\t\t\t<artifactId>jctools-core<\/artifactId>\n+\t\t\t<version>3.3.0<\/version>\n+\t\t<\/dependency>\n+\t\t<dependency>\n+\t\t\t<groupId>org.slf4j<\/groupId>\n+\t\t\t<artifactId>slf4j-api<\/artifactId>\n+\t\t\t<version>1.7.36<\/version>\n+\t\t<\/dependency>\n+\t\t<dependency>\n+\t\t\t<groupId>org.slf4j<\/groupId>\n+\t\t\t<artifactId>slf4j-simple<\/artifactId>\n+\t\t\t<version>1.7.32<\/version>\n+\t\t<\/dependency>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/pom.xml","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.testutils.parser;\n+\n+import java.io.IOException;\n+\n+\/** A chunk header data object *\/\n+public final class ChunkHeader {\n+\tpublic static final byte[] MAGIC = new byte[] {'F', 'L', 'R', '\\0'};\n+\tpublic final short major;\n+\tpublic final short minor;\n+\tpublic final long size;\n+\tpublic final long cpOffset;\n+\tpublic final long metaOffset;\n+\tpublic final long startNanos;\n+\tpublic final long duration;\n+\tpublic final long startTicks;\n+\tpublic final long frequency;\n+\tpublic final boolean compressed;\n+\n+\tChunkHeader(RecordingStream recording) throws IOException {\n+\t\tbyte[] buffer = new byte[MAGIC.length];\n+\t\trecording.read(buffer, 0, MAGIC.length);\n+\t\tfor (int i = 0; i < MAGIC.length; i++) {\n+\t\t\tif (buffer[i] != MAGIC[i]) {\n+\t\t\t\tthrow new IOException(\"Invalid JFR Magic Number: \" + bytesToString(buffer, 0, MAGIC.length));\n+\t\t\t}\n+\t\t}\n+\t\tmajor = recording.readShort();\n+\t\tminor = recording.readShort();\n+\t\tsize = recording.readLong();\n+\t\tcpOffset = recording.readLong();\n+\t\tmetaOffset = recording.readLong();\n+\t\tstartNanos = recording.readLong();\n+\t\tduration = recording.readLong();\n+\t\tstartTicks = recording.readLong();\n+\t\tfrequency = recording.readLong();\n+\t\tcompressed = recording.readInt() != 0;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"ChunkHeader{\" + \"major=\" + major + \", minor=\" + minor + \", size=\" + size + \", cpOffset=\" + cpOffset\n+\t\t\t\t+ \", metaOffset=\" + metaOffset + \", startNanos=\" + startNanos + \", duration=\" + duration\n+\t\t\t\t+ \", startTicks=\" + startTicks + \", frequency=\" + frequency + \", compressed=\" + compressed + '}';\n+\t}\n+\n+\tprivate static String bytesToString(byte[] array, int offset, int len) {\n+\t\tStringBuilder sb = new StringBuilder(\"[\");\n+\t\tboolean comma = false;\n+\t\tfor (int i = 0; i < len; i++) {\n+\t\t\tif (comma) {\n+\t\t\t\tsb.append(\", \");\n+\t\t\t} else {\n+\t\t\t\tcomma = true;\n+\t\t\t}\n+\t\t\tsb.append(array[i + offset]);\n+\t\t}\n+\t\tsb.append(']');\n+\t\treturn sb.toString();\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/testutils\/parser\/ChunkHeader.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.testutils.parser;\n+\n+import java.nio.file.Path;\n+\n+\/**\n+ * A callback to be provided to {@linkplain StreamingChunkParser#parse(Path, ChunkParserListener)}\n+ *\/\n+public interface ChunkParserListener {\n+\t\/** Called when the recording starts to be processed *\/\n+\tdefault void onRecordingStart() {\n+\t}\n+\n+\t\/**\n+\t * Called for each discovered chunk\n+\t *\n+\t * @param chunkIndex\n+\t *            the chunk index (1-based)\n+\t * @param header\n+\t *            the parsed chunk header\n+\t * @return {@literal false} if the chunk should be skipped\n+\t *\/\n+\tdefault boolean onChunkStart(int chunkIndex, ChunkHeader header) {\n+\t\treturn true;\n+\t}\n+\n+\t\/**\n+\t * Called for the chunk metadata event\n+\t *\n+\t * @param metadata\n+\t *            the chunk metadata event\n+\t * @return {@literal false} if the remainder of the chunk should be skipped\n+\t *\/\n+\tdefault boolean onMetadata(MetadataEvent metadata) {\n+\t\treturn true;\n+\t}\n+\n+\t\/**\n+\t * Called for each parsed event\n+\t *\n+\t * @param typeId\n+\t *            event type id\n+\t * @param stream\n+\t *            {@linkplain RecordingStream} positioned at the event payload start\n+\t * @param payloadSize\n+\t *            the size of the payload in bytes\n+\t * @return {@literal false} if the remainder of the chunk should be skipped\n+\t *\/\n+\tdefault boolean onEvent(long typeId, RecordingStream stream, long payloadSize) {\n+\t\treturn true;\n+\t}\n+\n+\t\/**\n+\t * Called when a chunk is fully processed or skipped\n+\t *\n+\t * @param chunkIndex\n+\t *            the chunk index (1-based)\n+\t * @param skipped\n+\t *            {@literal true} if the chunk was skipped\n+\t * @return {@literal false} if the remaining chunks in the recording should be skipped\n+\t *\/\n+\tdefault boolean onChunkEnd(int chunkIndex, boolean skipped) {\n+\t\treturn true;\n+\t}\n+\n+\t\/** Called when the recording was fully processed *\/\n+\tdefault void onRecordingEnd() {\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/testutils\/parser\/ChunkParserListener.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.testutils.parser;\n+\n+\/** Data structure mapping a long value to the type instance *\/\n+public interface LongMapping<T> {\n+\tT getType(long value);\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/testutils\/parser\/LongMapping.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+package org.openjdk.jmc.flightrecorder.testutils.parser;\n+\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+import org.jctools.maps.NonBlockingHashMapLong;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+\n+\/**\n+ * JFR Chunk metadata\n+ * <p>\n+ * It contains the chunk specific type specifications\n+ *\/\n+public final class MetadataEvent {\n+\tprivate static final byte[] COMMON_BUFFER = new byte[4096]; \/\/ reusable byte buffer\n+\n+\tpublic final int size;\n+\tpublic final long startTime;\n+\tpublic final long duration;\n+\tpublic final long metadataId;\n+\n+\tprivate final NonBlockingHashMapLong<String> eventTypeNameMapBacking = new NonBlockingHashMapLong<>(256);\n+\tprivate final LongMapping<String> eventTypeMap;\n+\n+\tMetadataEvent(RecordingStream stream) throws IOException {\n+\t\tsize = (int) stream.readVarint();\n+\t\tlong typeId = stream.readVarint();\n+\t\tif (typeId != 0) {\n+\t\t\tthrow new IOException(\"Unexpected event type: \" + typeId + \" (should be 0)\");\n+\t\t}\n+\t\tstartTime = stream.readVarint();\n+\t\tduration = stream.readVarint();\n+\t\tmetadataId = stream.readVarint();\n+\t\treadElements(stream, readStringTable(stream));\n+\t\teventTypeMap = eventTypeNameMapBacking::get;\n+\t}\n+\n+\t\/**\n+\t * Lazily compute and return the mappings of event type ids to event type names\n+\t *\n+\t * @return mappings of event type ids to event type names\n+\t *\/\n+\tpublic LongMapping<String> getEventTypeNameMap() {\n+\t\treturn eventTypeMap;\n+\t}\n+\n+\tprivate String[] readStringTable(RecordingStream stream) throws IOException {\n+\t\tint stringCnt = (int) stream.readVarint();\n+\t\tString[] stringConstants = new String[stringCnt];\n+\t\tfor (int stringIdx = 0; stringIdx < stringCnt; stringIdx++) {\n+\t\t\tstringConstants[stringIdx] = readUTF8(stream);\n+\t\t}\n+\t\treturn stringConstants;\n+\t}\n+\n+\tprivate void readElements(RecordingStream stream, String[] stringConstants) throws IOException {\n+\t\t\/\/ get the element name\n+\t\tint stringPtr = (int) stream.readVarint();\n+\t\tboolean isClassElement = \"class\".equals(stringConstants[stringPtr]);\n+\n+\t\t\/\/ process the attributes\n+\t\tint attrCount = (int) stream.readVarint();\n+\t\tString superType = null;\n+\t\tString name = null;\n+\t\tString id = null;\n+\t\tfor (int i = 0; i < attrCount; i++) {\n+\t\t\tint keyPtr = (int) stream.readVarint();\n+\t\t\tint valPtr = (int) stream.readVarint();\n+\t\t\t\/\/ ignore anything but 'class' elements\n+\t\t\tif (isClassElement) {\n+\t\t\t\tif (\"superType\".equals(stringConstants[keyPtr])) {\n+\t\t\t\t\tsuperType = stringConstants[valPtr];\n+\t\t\t\t} else if (\"name\".equals(stringConstants[keyPtr])) {\n+\t\t\t\t\tname = stringConstants[valPtr];\n+\t\t\t\t} else if (\"id\".equals(stringConstants[keyPtr])) {\n+\t\t\t\t\tid = stringConstants[valPtr];\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t\/\/ only event types are currently collected\n+\t\tif (name != null && id != null && \"jdk.jfr.Event\".equals(superType)) {\n+\t\t\teventTypeNameMapBacking.put(Long.parseLong(id), name);\n+\t\t}\n+\t\t\/\/ now inspect all the enclosed elements\n+\t\tint elemCount = (int) stream.readVarint();\n+\t\tfor (int i = 0; i < elemCount; i++) {\n+\t\t\treadElements(stream, stringConstants);\n+\t\t}\n+\t}\n+\n+\tprivate String readUTF8(RecordingStream stream) throws IOException {\n+\t\tbyte id = stream.read();\n+\t\tif (id == 0) {\n+\t\t\treturn null;\n+\t\t} else if (id == 1) {\n+\t\t\treturn \"\";\n+\t\t} else if (id == 3) {\n+\t\t\tint size = (int) stream.readVarint();\n+\t\t\tbyte[] content = size <= COMMON_BUFFER.length ? COMMON_BUFFER : new byte[size];\n+\t\t\tstream.read(content, 0, size);\n+\t\t\treturn new String(content, 0, size, StandardCharsets.UTF_8);\n+\t\t} else if (id == 4) {\n+\t\t\tint size = (int) stream.readVarint();\n+\t\t\tchar[] chars = new char[size];\n+\t\t\tfor (int i = 0; i < size; i++) {\n+\t\t\t\tchars[i] = (char) stream.readVarint();\n+\t\t\t}\n+\t\t\treturn new String(chars);\n+\t\t} else {\n+\t\t\tthrow new IOException(\"Unexpected string constant id: \" + id);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"Metadata{\" + \"size=\" + size + \", startTime=\" + startTime + \", duration=\" + duration + \", metadataId=\"\n+\t\t\t\t+ metadataId + '}';\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/testutils\/parser\/MetadataEvent.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.testutils.parser;\n+\n+import java.io.BufferedInputStream;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+public final class RecordingStream implements AutoCloseable {\n+\tprivate final DataInputStream delegate;\n+\tprivate long position = 0;\n+\n+\tRecordingStream(InputStream is) {\n+\t\tBufferedInputStream bis = (is instanceof BufferedInputStream) ? (BufferedInputStream) is\n+\t\t\t\t: new BufferedInputStream(is);\n+\t\tdelegate = new DataInputStream(bis);\n+\t}\n+\n+\tlong position() {\n+\t\treturn position;\n+\t}\n+\n+\tvoid read(byte[] buffer, int offset, int length) throws IOException {\n+\t\twhile (length > 0) {\n+\t\t\tint read = delegate.read(buffer, offset, length);\n+\t\t\tif (read == -1) {\n+\t\t\t\tthrow new IOException(\"Unexpected EOF\");\n+\t\t\t}\n+\t\t\toffset += read;\n+\t\t\tlength -= read;\n+\t\t\tposition += read;\n+\t\t}\n+\t}\n+\n+\tbyte read() throws IOException {\n+\t\tposition += 1;\n+\t\treturn delegate.readByte();\n+\t}\n+\n+\tshort readShort() throws IOException {\n+\t\tposition += 2;\n+\t\treturn delegate.readShort();\n+\t}\n+\n+\tint readInt() throws IOException {\n+\t\tposition += 4;\n+\t\treturn delegate.readInt();\n+\t}\n+\n+\tlong readLong() throws IOException {\n+\t\tposition += 8;\n+\t\treturn delegate.readLong();\n+\t}\n+\n+\tlong readVarint() throws IOException {\n+\t\tlong value = 0;\n+\t\tint readValue = 0;\n+\t\tint i = 0;\n+\t\tdo {\n+\t\t\treadValue = delegate.read();\n+\t\t\tvalue |= (long) (readValue & 0x7F) << (7 * i);\n+\t\t\ti++;\n+\t\t} while ((readValue & 0x80) != 0\n+\t\t\t\t\/\/ In fact a fully LEB128 encoded 64bit number could take up to 10 bytes\n+\t\t\t\t\/\/ (in order to store 64 bit original value using 7bit slots we need at most 10 of them).\n+\t\t\t\t\/\/ However, eg. JMC parser will stop at 9 bytes, assuming that the compressed number is\n+\t\t\t\t\/\/ a Java unsigned long (therefore having only 63 bits and they all fit in 9 bytes).\n+\t\t\t\t&& i < 9);\n+\t\tposition += i;\n+\t\treturn value;\n+\t}\n+\n+\tint available() throws IOException {\n+\t\treturn delegate.available();\n+\t}\n+\n+\tvoid skip(long bytes) throws IOException {\n+\t\tlong toSkip = bytes;\n+\t\twhile (toSkip > 0) {\n+\t\t\ttoSkip -= delegate.skip(toSkip);\n+\t\t}\n+\t\tposition += bytes;\n+\t}\n+\n+\tpublic void mark(int readlimit) {\n+\t\tdelegate.mark(readlimit);\n+\t}\n+\n+\tpublic void reset() throws IOException {\n+\t\tdelegate.reset();\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws IOException {\n+\t\tdelegate.close();\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/testutils\/parser\/RecordingStream.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.testutils.parser;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+\/**\n+ * Streaming, almost zero-allocation, JFR chunk parser implementation. <br>\n+ * This is an MVP of a chunk parser allowing to stream the JFR events efficiently. The parser\n+ * notifies its listeners as the data becomes available. Because of this it is possible for the\n+ * metadata events to come 'out-of-band' (although not very probable) and it is up to the caller to\n+ * deal with that eventuality. <br>\n+ * This class is not thread-safe and is intended to be used from a single thread only.\n+ *\/\n+public final class StreamingChunkParser {\n+\tprivate static final Logger log = LoggerFactory.getLogger(StreamingChunkParser.class);\n+\n+\t\/**\n+\t * Parse the given JFR recording stream.<br>\n+\t * The parser will process the recording stream and call the provided listener in this order:\n+\t * <ol>\n+\t * <li>listener.onRecordingStart()\n+\t * <li>listener.onChunkStart()\n+\t * <li>listener.onEvent() | listener.onMetadata()\n+\t * <li>listener.onChunkEnd()\n+\t * <li>listener.onRecordingEnd()\n+\t * <\/ol>\n+\t *\n+\t * @param inputStream\n+\t *            the JFR recording stream it will be closed when the parsing is over\n+\t * @param listener\n+\t *            the parser listener\n+\t * @throws IOException\n+\t *\/\n+\tpublic void parse(InputStream inputStream, ChunkParserListener listener) throws IOException {\n+\t\ttry (RecordingStream stream = new RecordingStream(inputStream)) {\n+\t\t\tparse(stream, listener);\n+\t\t}\n+\t}\n+\n+\tprivate void parse(RecordingStream stream, ChunkParserListener listener) throws IOException {\n+\t\tif (stream.available() == 0) {\n+\t\t\treturn;\n+\t\t}\n+\t\ttry {\n+\t\t\tlistener.onRecordingStart();\n+\t\t\tint chunkCounter = 1;\n+\t\t\twhile (stream.available() > 0) {\n+\t\t\t\tlong chunkStartPos = stream.position();\n+\t\t\t\tChunkHeader header = new ChunkHeader(stream);\n+\t\t\t\tif (!listener.onChunkStart(chunkCounter, header)) {\n+\t\t\t\t\tlog.debug(\"'onChunkStart' returned false. Skipping metadata and events for chunk {}\", chunkCounter);\n+\t\t\t\t\tstream.skip(header.size - (stream.position() - chunkStartPos));\n+\t\t\t\t\tlistener.onChunkEnd(chunkCounter, true);\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tlong chunkEndPos = chunkStartPos + (int) header.size;\n+\t\t\t\twhile (stream.position() < chunkEndPos) {\n+\t\t\t\t\tlong eventStartPos = stream.position();\n+\t\t\t\t\tstream.mark(20); \/\/ max 2 varints ahead\n+\t\t\t\t\tint eventSize = (int) stream.readVarint();\n+\t\t\t\t\tif (eventSize > 0) {\n+\t\t\t\t\t\tlong eventType = stream.readVarint();\n+\t\t\t\t\t\tif (eventType == 0) {\n+\t\t\t\t\t\t\t\/\/ metadata\n+\t\t\t\t\t\t\tstream.reset(); \/\/ roll-back the stream to the event start\n+\t\t\t\t\t\t\tMetadataEvent m = new MetadataEvent(stream);\n+\t\t\t\t\t\t\tif (!listener.onMetadata(m)) {\n+\t\t\t\t\t\t\t\tlog.debug(\"'onMetadata' returned false. Skipping events for chunk {}\", chunkCounter);\n+\t\t\t\t\t\t\t\tstream.skip(header.size - (stream.position() - chunkStartPos));\n+\t\t\t\t\t\t\t\tlistener.onChunkEnd(chunkCounter, true);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else if (eventType == 1) {\n+\t\t\t\t\t\t\t\/\/ checkpoint event; skip for now\n+\t\t\t\t\t\t\tstream.skip(eventSize - (stream.position() - eventStartPos));\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tlong currentPos = stream.position();\n+\t\t\t\t\t\t\tif (!listener.onEvent(eventType, stream, eventSize - (currentPos - eventStartPos))) {\n+\t\t\t\t\t\t\t\tlog.debug(\"'onEvent({}, stream)' returned false. Skipping the rest of the chunk {}\",\n+\t\t\t\t\t\t\t\t\t\teventType, chunkCounter);\n+\t\t\t\t\t\t\t\t\/\/ skip the rest of the chunk\n+\t\t\t\t\t\t\t\tstream.skip(header.size - (stream.position() - chunkStartPos));\n+\t\t\t\t\t\t\t\tlistener.onChunkEnd(chunkCounter, true);\n+\t\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\/\/ always skip any unconsumed event data to get the stream into consistent state\n+\t\t\t\t\t\t\tstream.skip(eventSize - (stream.position() - eventStartPos));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (!listener.onChunkEnd(chunkCounter, false)) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tchunkCounter++;\n+\t\t\t}\n+\t\t} finally {\n+\t\t\tlistener.onRecordingEnd();\n+\t\t}\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/testutils\/parser\/StreamingChunkParser.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+\/**\n+ * A simple, non feature-complete JFR parser. Useful to inspect chunk headers or metadata. It is\n+ * possible extending it to a full-fledged JFR streaming parser if found useful.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.testutils.parser;\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/testutils\/parser\/package-info.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,215 @@\n+package org.openjdk.jmc.flightrecorder.testutils.parser.test;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.internal.verification.VerificationModeFactory;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.openjdk.jmc.flightrecorder.testutils.parser.ChunkHeader;\n+import org.openjdk.jmc.flightrecorder.testutils.parser.ChunkParserListener;\n+import org.openjdk.jmc.flightrecorder.testutils.parser.MetadataEvent;\n+import org.openjdk.jmc.flightrecorder.testutils.parser.RecordingStream;\n+import org.openjdk.jmc.flightrecorder.testutils.parser.StreamingChunkParser;\n+import org.openjdk.jmc.flightrecorder.writer.api.Recording;\n+import org.openjdk.jmc.flightrecorder.writer.api.Recordings;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+@ExtendWith(MockitoExtension.class)\n+class StreamingChunkParserTest {\n+\tprivate StreamingChunkParser instance;\n+\t@Mock\n+\tprivate ChunkParserListener listener;\n+\n+\t@BeforeEach\n+\tvoid setup() throws Exception {\n+\t\tinstance = new StreamingChunkParser();\n+\t}\n+\n+\t@Test\n+\tvoid testNoChunk() throws Exception {\n+\t\tbyte[] data = new byte[0];\n+\t\tInputStream is = new ByteArrayInputStream(data);\n+\n+\t\tinstance.parse(is, listener);\n+\n+\t\tChunkParserListener noInteractions = Mockito.verify(listener, VerificationModeFactory.times(0));\n+\t\tnoInteractions.onRecordingStart();\n+\t\tnoInteractions.onChunkStart(Mockito.anyInt(), Mockito.any(ChunkHeader.class));\n+\t\tnoInteractions.onMetadata(Mockito.any(MetadataEvent.class));\n+\t\tnoInteractions.onEvent(Mockito.anyLong(), Mockito.any(RecordingStream.class), Mockito.anyInt());\n+\t\tnoInteractions.onChunkEnd(Mockito.anyInt(), Mockito.anyBoolean());\n+\t\tnoInteractions.onRecordingEnd();\n+\t}\n+\n+\t@Test\n+\tvoid testNoMagic() throws Exception {\n+\t\tbyte[] data = new byte[100];\n+\t\tfor (int i = 0; i < 100; i++) {\n+\t\t\tdata[i] = (byte) i;\n+\t\t}\n+\n+\t\tInputStream is = new ByteArrayInputStream(data);\n+\n+\t\tAssertions.assertThrows(IOException.class, () -> instance.parse(is, listener));\n+\n+\t\tMockito.verify(listener, VerificationModeFactory.times(1)).onRecordingStart();\n+\t\tMockito.verify(listener, VerificationModeFactory.times(1)).onRecordingEnd();\n+\t\tMockito.verify(listener, VerificationModeFactory.times(0)).onChunkStart(Mockito.anyInt(),\n+\t\t\t\tMockito.any(ChunkHeader.class));\n+\t\tMockito.verify(listener, VerificationModeFactory.times(0)).onChunkEnd(Mockito.anyInt(), Mockito.anyBoolean());\n+\t\tMockito.verify(listener, VerificationModeFactory.times(0)).onMetadata(Mockito.any(MetadataEvent.class));\n+\t\tMockito.verify(listener, VerificationModeFactory.times(0)).onEvent(Mockito.anyLong(),\n+\t\t\t\tMockito.any(RecordingStream.class), Mockito.anyLong());\n+\t}\n+\n+\t@Test\n+\tvoid testOnlyMagic() throws Exception {\n+\t\tInputStream is = new ByteArrayInputStream(ChunkHeader.MAGIC);\n+\n+\t\tAssertions.assertThrows(IOException.class, () -> instance.parse(is, listener));\n+\n+\t\tMockito.verify(listener, VerificationModeFactory.times(1)).onRecordingStart();\n+\t\tMockito.verify(listener, VerificationModeFactory.times(1)).onRecordingEnd();\n+\t\tMockito.verify(listener, VerificationModeFactory.times(0)).onChunkStart(Mockito.anyInt(),\n+\t\t\t\tMockito.any(ChunkHeader.class));\n+\t\tMockito.verify(listener, VerificationModeFactory.times(0)).onChunkEnd(Mockito.anyInt(), Mockito.anyBoolean());\n+\t\tMockito.verify(listener, VerificationModeFactory.times(0)).onMetadata(Mockito.any(MetadataEvent.class));\n+\t\tMockito.verify(listener, VerificationModeFactory.times(0)).onEvent(Mockito.anyLong(),\n+\t\t\t\tMockito.any(RecordingStream.class), Mockito.anyLong());\n+\t}\n+\n+\t@Test\n+\tvoid testSingleChunkRecording() throws Exception {\n+\t\tByteArrayOutputStream recordingStream = new ByteArrayOutputStream();\n+\t\tlong eventTypeId = -1;\n+\t\ttry (Recording recording = Recordings.newRecording(recordingStream)) {\n+\t\t\tType type = recording.registerEventType(\"datadog.TestEvent\", t -> {\n+\t\t\t\tt.addField(\"value\", Types.Builtin.INT);\n+\t\t\t});\n+\t\t\teventTypeId = type.getId();\n+\t\t\trecording.writeEvent(type.asValue(b -> {\n+\t\t\t\tb.putField(\"startTime\", 10L).putField(\"eventThread\", recording.getType(Types.JDK.THREAD).nullValue())\n+\t\t\t\t\t\t.putField(\"stackTrace\", recording.getType(Types.JDK.STACK_TRACE).nullValue())\n+\t\t\t\t\t\t.putField(\"value\", 10);\n+\t\t\t}));\n+\t\t}\n+\n+\t\tassertNotEquals(-1, eventTypeId);\n+\n+\t\tMockito.when(listener.onChunkStart(Mockito.anyInt(), Mockito.any(ChunkHeader.class))).thenReturn(true);\n+\t\tMockito.when(listener.onMetadata(Mockito.any(MetadataEvent.class))).thenReturn(true);\n+\t\tMockito.when(listener.onEvent(Mockito.anyLong(), Mockito.any(RecordingStream.class), Mockito.anyLong()))\n+\t\t\t\t.thenReturn(true);\n+\t\tMockito.when(listener.onChunkEnd(Mockito.anyInt(), Mockito.anyBoolean())).thenReturn(true);\n+\n+\t\tInputStream is = new ByteArrayInputStream(recordingStream.toByteArray());\n+\t\tinstance.parse(is, listener);\n+\n+\t\tMockito.verify(listener, VerificationModeFactory.times(1)).onRecordingStart();\n+\t\tMockito.verify(listener, VerificationModeFactory.times(1)).onRecordingEnd();\n+\t\tMockito.verify(listener, VerificationModeFactory.times(1)).onChunkStart(Mockito.eq(1), Mockito.notNull());\n+\t\tMockito.verify(listener, VerificationModeFactory.times(1)).onChunkEnd(Mockito.eq(1), Mockito.eq(false));\n+\t\tMockito.verify(listener, VerificationModeFactory.times(1)).onMetadata(Mockito.notNull());\n+\t\tArgumentCaptor<Long> capturedSize = ArgumentCaptor.forClass(Long.class);\n+\n+\t\tMockito.verify(listener, VerificationModeFactory.times(1)).onEvent(Mockito.eq(eventTypeId), Mockito.notNull(),\n+\t\t\t\tcapturedSize.capture());\n+\n+\t\tassertNotNull(capturedSize.getValue());\n+\t\tassertTrue(capturedSize.getValue() > 0);\n+\t}\n+\n+\t@ParameterizedTest\n+\t@MethodSource(\"cancelledParserVerification\")\n+\tvoid testCancellation(\n+\t\tString cancelAt, int numRecStart, int numChunkStart, int numEvent, int numMetadata, int numChunkEnd,\n+\t\tint numRecEnd) throws Exception {\n+\t\tlong eventTypeId1 = -1;\n+\t\tlong eventTypeId2 = -1;\n+\t\tByteArrayOutputStream recordingStream = new ByteArrayOutputStream();\n+\t\ttry (Recording recording = Recordings.newRecording(recordingStream)) {\n+\t\t\tType type = recording.registerEventType(\"datadog.TestEvent\", t -> {\n+\t\t\t\tt.addField(\"value\", Types.Builtin.INT);\n+\t\t\t});\n+\t\t\teventTypeId1 = type.getId();\n+\t\t\trecording.writeEvent(type.asValue(b -> {\n+\t\t\t\tb.putField(\"startTime\", 10L).putField(\"eventThread\", recording.getType(Types.JDK.THREAD).nullValue())\n+\t\t\t\t\t\t.putField(\"stackTrace\", recording.getType(Types.JDK.STACK_TRACE).nullValue())\n+\t\t\t\t\t\t.putField(\"value\", 10);\n+\t\t\t}));\n+\t\t\trecording.writeEvent(type.asValue(b -> {\n+\t\t\t\tb.putField(\"startTime\", 20L).putField(\"eventThread\", recording.getType(Types.JDK.THREAD).nullValue())\n+\t\t\t\t\t\t.putField(\"stackTrace\", recording.getType(Types.JDK.STACK_TRACE).nullValue())\n+\t\t\t\t\t\t.putField(\"value\", 20);\n+\t\t\t}));\n+\t\t}\n+\t\ttry (Recording recording = Recordings.newRecording(recordingStream)) {\n+\t\t\tType type = recording.registerEventType(\"datadog.TestEvent\", t -> {\n+\t\t\t\tt.addField(\"value\", Types.Builtin.INT);\n+\t\t\t});\n+\t\t\teventTypeId2 = type.getId();\n+\t\t\trecording.writeEvent(type.asValue(b -> {\n+\t\t\t\tb.putField(\"startTime\", 30L).putField(\"eventThread\", recording.getType(Types.JDK.THREAD).nullValue())\n+\t\t\t\t\t\t.putField(\"stackTrace\", recording.getType(Types.JDK.STACK_TRACE).nullValue())\n+\t\t\t\t\t\t.putField(\"value\", 30);\n+\t\t\t}));\n+\t\t\trecording.writeEvent(type.asValue(b -> {\n+\t\t\t\tb.putField(\"startTime\", 40L).putField(\"eventThread\", recording.getType(Types.JDK.THREAD).nullValue())\n+\t\t\t\t\t\t.putField(\"stackTrace\", recording.getType(Types.JDK.STACK_TRACE).nullValue())\n+\t\t\t\t\t\t.putField(\"value\", 40);\n+\t\t\t}));\n+\t\t}\n+\n+\t\tassertNotEquals(-1, eventTypeId1);\n+\t\tassertNotEquals(-1, eventTypeId2);\n+\n+\t\tMockito.lenient().when(listener.onChunkStart(Mockito.anyInt(), Mockito.any(ChunkHeader.class)))\n+\t\t\t\t.thenReturn(!\"chunkStart\".equals(cancelAt));\n+\t\tMockito.lenient().when(listener.onMetadata(Mockito.any(MetadataEvent.class)))\n+\t\t\t\t.thenReturn(!\"metadata\".equals(cancelAt));\n+\t\tMockito.lenient()\n+\t\t\t\t.when(listener.onEvent(Mockito.anyLong(), Mockito.any(RecordingStream.class), Mockito.anyLong()))\n+\t\t\t\t.thenReturn(!\"event\".equals(cancelAt));\n+\t\tMockito.lenient().when(listener.onChunkEnd(Mockito.anyInt(), Mockito.anyBoolean()))\n+\t\t\t\t.thenReturn(!\"chunkEnd\".equals(cancelAt));\n+\n+\t\tInputStream is = new ByteArrayInputStream(recordingStream.toByteArray());\n+\t\tinstance.parse(is, listener);\n+\n+\t\tboolean interruptedChunk = !\"chunkEnd\".equals(cancelAt);\n+\t\tMockito.verify(listener, VerificationModeFactory.times(numRecStart)).onRecordingStart();\n+\t\tMockito.verify(listener, VerificationModeFactory.times(numRecEnd)).onRecordingEnd();\n+\t\tMockito.verify(listener, VerificationModeFactory.times(numChunkStart)).onChunkStart(Mockito.anyInt(),\n+\t\t\t\tMockito.notNull());\n+\t\tMockito.verify(listener, VerificationModeFactory.times(numChunkEnd)).onChunkEnd(Mockito.anyInt(),\n+\t\t\t\tMockito.eq(interruptedChunk));\n+\t\tMockito.verify(listener, VerificationModeFactory.times(numMetadata)).onMetadata(Mockito.notNull());\n+\t\tMockito.verify(listener, VerificationModeFactory.times(numEvent)).onEvent(Mockito.eq(eventTypeId1),\n+\t\t\t\tMockito.notNull(), Mockito.anyLong());\n+\t}\n+\n+\tprivate static Stream<Arguments> cancelledParserVerification() {\n+\t\treturn Stream.of(\n+\t\t\t\t\/\/                   cancelAt     rec     chunk   events  meta  endchunk  endrec\n+\t\t\t\tArguments.arguments(\"chunkStart\", 1, 2, 0, 0, 2, 1), Arguments.arguments(\"metadata\", 1, 2, 4, 2, 2, 1),\n+\t\t\t\tArguments.arguments(\"event\", 1, 2, 2, 0, 2, 1), Arguments.arguments(\"chunkEnd\", 1, 1, 2, 1, 1, 1));\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/testutils\/parser\/test\/StreamingChunkParserTest.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+import java.io.ByteArrayInputStream;\n@@ -43,0 +44,2 @@\n+import java.io.IOException;\n+import java.util.stream.Stream;\n@@ -48,0 +51,1 @@\n+import org.junit.jupiter.params.provider.Arguments;\n@@ -49,0 +53,4 @@\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.openjdk.jmc.flightrecorder.testutils.parser.ChunkHeader;\n+import org.openjdk.jmc.flightrecorder.testutils.parser.ChunkParserListener;\n+import org.openjdk.jmc.flightrecorder.testutils.parser.StreamingChunkParser;\n@@ -68,0 +76,29 @@\n+\t@ParameterizedTest\n+\t@MethodSource(\"recordingSettings\")\n+\tvoid testChunkHeaderTimestamps(RecordingSettings settings) throws IOException {\n+\t\tStreamingChunkParser parser = new StreamingChunkParser();\n+\t\tByteArrayOutputStream bos1 = new ByteArrayOutputStream();\n+\t\tRecordingImpl recording1 = new RecordingImpl(bos1, settings);\n+\t\trecording1.close();\n+\n+\t\tparser.parse(new ByteArrayInputStream(bos1.toByteArray()), new ChunkParserListener() {\n+\t\t\t@Override\n+\t\t\tpublic boolean onChunkStart(int chunkIndex, ChunkHeader header) {\n+\t\t\t\tassertTrue(header.startNanos > -1);\n+\t\t\t\tassertTrue(header.startTicks > -1);\n+\t\t\t\tassertTrue(header.duration > -1);\n+\n+\t\t\t\tassertTrue(settings.getStartTimestamp() == -1 || settings.getStartTimestamp() == header.startNanos);\n+\t\t\t\tassertTrue(settings.getStartTicks() == -1 || settings.getStartTicks() == header.startTicks);\n+\t\t\t\tassertTrue(settings.getDuration() == -1 || settings.getDuration() == header.duration);\n+\t\t\t\t\/\/ skip the rest\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\tprivate static Stream<Arguments> recordingSettings() {\n+\t\treturn Stream.of(Arguments.of(new RecordingSettings()),\n+\t\t\t\tArguments.of(new RecordingSettings(0, 0, 500_000_000L, true)));\n+\t}\n+\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.writer.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/RecordingImplTest.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -62,2 +62,3 @@\n-\t\t<mockito.core.version>3.12.4<\/mockito.core.version>\n-\t\t<mockito.inline.version>3.12.4<\/mockito.inline.version>\n+\t\t<mockito.core.version>4.6.1<\/mockito.core.version>\n+\t\t<mockito.inline.version>4.6.1<\/mockito.inline.version>\n+\t\t<mockito.jupiter.version>4.6.1<\/mockito.jupiter.version>\n@@ -174,0 +175,5 @@\n+\t\t\t<dependency>\n+\t\t\t\t<groupId>org.mockito<\/groupId>\n+\t\t\t\t<artifactId>mockito-junit-jupiter<\/artifactId>\n+\t\t\t\t<version>${mockito.jupiter.version}<\/version>\n+\t\t\t<\/dependency>\n","filename":"core\/tests\/pom.xml","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"}]}