{"files":[{"patch":"@@ -3,1 +3,1 @@\n-   Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+   Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"application\/org.openjdk.jmc.feature.flightrecorder\/feature.xml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n-#  Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n-#  Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+#  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2021, Datadog, Inc. All rights reserved.\n","filename":"application\/org.openjdk.jmc.flightrecorder.heatmap\/plugin.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,2 +3,2 @@\n-   Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n-   Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+   Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+   Copyright (c) 2021, Datadog, Inc. All rights reserved.\n","filename":"application\/org.openjdk.jmc.flightrecorder.heatmap\/pom.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n","filename":"application\/org.openjdk.jmc.flightrecorder.heatmap\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/heatmap\/views\/HeatmapView.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,3 +1,5 @@\n-const chart = {\n-  data: []\n-};\n+class Logger {\n+  constructor() {\n+    this.domElement = document.createElement(\"pre\");\n+    window.document.body.appendChild(this.domElement);\n+  }\n@@ -5,7 +7,3 @@\n-function updateHeatmap(jsonStr) {\n-  const rawData = JSON.parse(jsonStr);\n-  const eventTimes = getEventTimes(rawData);\n-  const binnedData = getBinnedData(eventTimes);\n-  chart.data = binnedData;\n-  renderHeatmap(chart.data);\n-}\n+  log(msg) {\n+    this.domElement.innerHTML += msg + \"\\n\";\n+  }\n@@ -13,2 +11,3 @@\n-function resizeSVG() {\n-  renderHeatmap(chart.data);\n+  clear() {\n+    this.domElement.innerHTML = \"\";\n+  }\n@@ -16,1 +15,3 @@\n-d3.select(window).on(\"resize\", resizeSVG);\n+const chart = {\n+  data: [],\n+};\n@@ -18,0 +19,1 @@\n+window.logger = new Logger();\n@@ -19,4 +21,7 @@\n-function range(from, to) {\n-  const result = [];\n-  for (let i = from; i < to; i++) {\n-    result.push(i);\n+try {\n+  function updateHeatmap(jsonStr) {\n+    const rawData = JSON.parse(jsonStr);\n+    const eventTimes = getEventTimes(rawData);\n+    const binnedData = getBinnedData(eventTimes);\n+    chart.data = binnedData;\n+    renderHeatmap(chart.data);\n@@ -24,2 +29,0 @@\n-  return result;\n-}\n@@ -27,6 +30,4 @@\n-function getEventTimes(rawData) {\n-  return rawData.events\n-    .filter((event) => event.attributes)\n-    .map((event) => event.attributes.startTime || event.attributes.endTime || event.attributes[\"(endTime)\"])\n-    .map((time) => new Date(time \/ 10e5));\n-}\n+  function resizeSVG() {\n+    renderHeatmap(chart.data);\n+  }\n+  d3.select(window).on(\"resize\", resizeSVG);\n@@ -34,9 +35,7 @@\n-function getBinnedData(eventTimes) {\n-  const scale = d3.scaleTime().domain(d3.extent(eventTimes)).nice(); \/\/ ♥️♥️♥️\n-  const timeRangeMs = scale.domain()[1] - scale.domain()[0];\n-  const binFn = d3\n-    .bin()\n-    .domain(scale.domain())\n-    .thresholds(timeRangeMs \/ 100);\n-  return binFn(eventTimes);\n-}\n+  function range(from, to) {\n+    const result = [];\n+    for (let i = from; i < to; i++) {\n+      result.push(i);\n+    }\n+    return result;\n+  }\n@@ -44,32 +43,11 @@\n-function getChartConfig(binnedData) {\n-  \/\/ numCells and maxEvents depend on the data\n-  const numCells = binnedData.length;\n-  const maxEvents = d3.max(binnedData, (d) => d.length);\n-\n-  \/\/ margins are fixed\n-  const marginLeft = 50;\n-  const marginTop = 20;\n-  const marginBottom = 50;\n-\n-  \/\/ width and height are fixed from the window\n-  const width = window.innerWidth - marginLeft;\n-  const height = window.innerHeight - (marginTop + marginBottom);\n-\n-  \/\/ cellSize is derived from width, height and numCells\n-  const cellSize = Math.floor(Math.sqrt(width * height \/ numCells));\n-  const numCols = Math.floor(width \/ cellSize) - 3;\n-  const numRows = Math.ceil(numCells \/ numCols);\n-\n-  return {\n-    numCols,\n-    numRows,\n-    numCells,\n-    cellSize,\n-    maxEvents,\n-    marginLeft,\n-    marginTop,\n-    marginBottom,\n-    width,\n-    height,\n-  };\n-}\n+  function getEventTimes(rawData) {\n+    return rawData.events\n+      .filter((event) => event.attributes)\n+      .map(\n+        (event) =>\n+          event.attributes.startTime ||\n+          event.attributes.endTime ||\n+          event.attributes[\"(endTime)\"]\n+      )\n+      .map((time) => new Date(time \/ 10e5));\n+  }\n@@ -77,6 +55,9 @@\n-function getColorScale(chartConfig) {\n-  const { maxEvents } = chartConfig;\n-  return d3\n-    .scaleSequentialSqrt(d3.interpolateOrRd)\n-    .domain([0, maxEvents]);\n-}\n+  function getBinnedData(eventTimes) {\n+    const scale = d3.scaleTime().domain(d3.extent(eventTimes)).nice(); \/\/ ♥️♥️♥️\n+    const timeRangeMs = scale.domain()[1] - scale.domain()[0];\n+    const binFn = d3\n+      .bin()\n+      .domain(scale.domain())\n+      .thresholds(timeRangeMs \/ 100);\n+    return binFn(eventTimes);\n+  }\n@@ -84,4 +65,39 @@\n-function renderHeatmap(binnedData) {\n-  if (!binnedData || binnedData.length < 2) {\n-    \/\/ FIXME: currently this is not visible to the user\n-    return \"No data in current selection.\";\n+  function getChartConfig(binnedData) {\n+    \/\/ numCells and maxEvents depend on the data\n+    const numCells = binnedData.length;\n+    const maxEvents = d3.max(binnedData, (d) => d.length);\n+\n+    \/\/ margins are fixed\n+    const marginLeft = 50;\n+    const marginRight = 20;\n+    const marginTop = 20;\n+    const marginBottom = 100;\n+\n+    \/\/ width and height are fixed from the window\n+    const width = window.innerWidth - (marginLeft + marginRight);\n+    const height = window.innerHeight - (marginTop + marginBottom);\n+\n+    \/\/ cellSize is derived from width, height and numCells\n+    \/\/ anything below 4px is invisible\n+    const cellSize = Math.max(\n+      4,\n+      Math.floor(Math.sqrt((width * height) \/ numCells))\n+    );\n+    const numCols = Math.floor(width \/ cellSize);\n+    const numRows = Math.ceil(numCells \/ numCols);\n+\n+    const config = {\n+      numCols,\n+      numRows,\n+      numCells,\n+      cellSize,\n+      maxEvents,\n+      marginLeft,\n+      marginTop,\n+      marginBottom,\n+      width,\n+      height,\n+    };\n+    logger.clear();\n+    logger.log(JSON.stringify(config, null, 2));\n+    return config;\n@@ -89,37 +105,4 @@\n-  const chartConfig = getChartConfig(binnedData);\n-  const {\n-    numCols,\n-    numRows,\n-    numCells,\n-    cellSize,\n-    maxEvents,\n-    marginLeft,\n-    marginTop,\n-    marginBottom,\n-    width,\n-    height,\n-  } = chartConfig;\n-  const colorScale = getColorScale(chartConfig);\n-  const xDomain = range(0, numCols).map((val) => (val * 100) \/ 1000);\n-  const yDomain = [\n-    d3.min(binnedData, (d) => d.x0),\n-    d3.max(binnedData, (d) => d.x1),\n-  ].map((val) => new Date(val));\n-\n-  const xScale = d3\n-    .scaleBand()\n-    .domain(xDomain)\n-    .range([marginLeft, numCols * cellSize + marginLeft]);\n-  const yScale = d3\n-    .scaleLinear()\n-    .domain(yDomain)\n-    .range([marginTop, marginTop + numRows * cellSize]);\n-\n-  const xTickFilter = (x, idx) => {\n-    if (cellSize > 15) {\n-      return true;\n-    } else if (cellSize > 5) {\n-      return idx % 5 === 0;\n-    } else {\n-      return idx % 10 === 0;\n-    }\n+\n+  function getColorScale(chartConfig) {\n+    const { maxEvents } = chartConfig;\n+    return d3.scaleSequentialSqrt(d3.interpolateOrRd).domain([0, maxEvents]);\n@@ -127,54 +110,124 @@\n-  const xAxis = (g) =>\n-    g\n-      .call(\n-        d3\n-          .axisBottom(xScale)\n-          .tickValues(xDomain.filter(xTickFilter))\n-          .tickFormat((d) => `${d3.format(\".1f\")(d)} s`)\n-      )\n-      .selectAll(\"text\")\n-      .attr(\"y\", 0)\n-      .attr(\"x\", -9)\n-      .attr(\"dy\", \".35em\")\n-      .attr(\"transform\", \"rotate(270)\")\n-      .style(\"text-anchor\", \"end\")\n-      .style(\"fill\", \"#777\");\n-\n-  const yAxis = (g) =>\n-    g\n-      .call(\n-        d3\n-          .axisLeft(yScale)\n-          .tickSize(3)\n-          .tickPadding(4)\n-          .tickFormat(d3.timeFormat(\"%H:%M:%S\"))\n-      )\n-      .selectAll(\"text\")\n-      .style(\"fill\", \"#777\");\n-\n-  const makeCells = (g) =>\n-    g\n-      .selectAll(\"rect\")\n-      .data(binnedData)\n-      .enter()\n-      .append(\"rect\")\n-      .attr(\"fill\", (d) => colorScale(d.length))\n-      .attr(\"stroke\", \"white\")\n-      .attr(\"x\", (d, i) => {\n-        return (i % numCols) * cellSize;\n-      })\n-      .attr(\"y\", (d, i) => {\n-        return Math.floor(i \/ numCols) * cellSize;\n-      })\n-      .attr(\"height\", cellSize)\n-      .attr(\"width\", cellSize)\n-      .style(\"cursor\", \"pointer\")\n-      .on(\"mouseover\", function () {\n-        const target = d3.select(this);\n-        target.attr(\"fill\", \"gold\");\n-      })\n-      .on(\"mouseout\", function () {\n-        const target = d3.select(this);\n-        target.attr(\"fill\", (d) => colorScale(d.length));\n-      })\n-      .append(\"title\")\n+\n+  function renderHeatmap(binnedData) {\n+    if (!binnedData || binnedData.length < 2) {\n+      d3.select(\"#heatmap\").append(\"p\").text(\"No data in current selection.\");\n+      return;\n+    }\n+    const chartConfig = getChartConfig(binnedData);\n+    const {\n+      numCols,\n+      numRows,\n+      numCells,\n+      cellSize,\n+      maxEvents,\n+      marginLeft,\n+      marginTop,\n+      marginBottom,\n+      width,\n+      height,\n+    } = chartConfig;\n+    const colorScale = getColorScale(chartConfig);\n+    const xDomain = range(0, numCols).map((val) => (val * 100) \/ 1000);\n+    const yDomain = [\n+      d3.min(binnedData, (d) => d.x0),\n+      d3.max(binnedData, (d) => d.x1),\n+    ].map((val) => new Date(val));\n+\n+    const xScale = d3\n+      .scaleBand()\n+      .domain(xDomain)\n+      .range([marginLeft, numCols * cellSize + marginLeft]);\n+    const yScale = d3\n+      .scaleLinear()\n+      .domain(yDomain)\n+      .range([marginTop, marginTop + numRows * cellSize]);\n+\n+    const xTickFilter = (x, idx) => {\n+      if (cellSize > 15) {\n+        return true;\n+      } else if (cellSize > 5) {\n+        return idx % 5 === 0;\n+      } else {\n+        return idx % 10 === 0;\n+      }\n+    };\n+    const xAxis = (g) =>\n+      g\n+        .call(\n+          d3\n+            .axisBottom(xScale)\n+            .tickValues(xDomain.filter(xTickFilter))\n+            .tickFormat((d) => `${d3.format(\".1f\")(d)} s`)\n+        )\n+        .selectAll(\"text\")\n+        .attr(\"y\", 0)\n+        .attr(\"x\", -9)\n+        .attr(\"dy\", \".35em\")\n+        .attr(\"transform\", \"rotate(270)\")\n+        .style(\"text-anchor\", \"end\")\n+        .style(\"fill\", \"#777\");\n+\n+    const yAxis = (g) =>\n+      g\n+        .call(\n+          d3\n+            .axisLeft(yScale)\n+            .tickSize(3)\n+            .tickPadding(4)\n+            .tickFormat(d3.timeFormat(\"%H:%M:%S\"))\n+        )\n+        .selectAll(\"text\")\n+        .style(\"fill\", \"#777\");\n+\n+    const makeCells = (g) =>\n+      g\n+        .selectAll(\"rect\")\n+        .data(binnedData)\n+        .enter()\n+        .append(\"rect\")\n+        .attr(\"fill\", (d) => colorScale(d.length))\n+        .attr(\"stroke\", \"white\")\n+        .attr(\"x\", (d, i) => {\n+          return (i % numCols) * cellSize;\n+        })\n+        .attr(\"y\", (d, i) => {\n+          return Math.floor(i \/ numCols) * cellSize;\n+        })\n+        .attr(\"height\", cellSize)\n+        .attr(\"width\", cellSize)\n+        .style(\"cursor\", \"pointer\")\n+        .on(\"mouseover\", function () {\n+          const target = d3.select(this);\n+          target.attr(\"fill\", \"gold\");\n+        })\n+        .on(\"mouseout\", function () {\n+          const target = d3.select(this);\n+          target.attr(\"fill\", (d) => colorScale(d.length));\n+        })\n+        .append(\"title\")\n+        .text(\n+          (d) => `${d3.timeFormat(\"%H:%M:%S.%L\")(d.x0)} ${d.length} events`\n+        );\n+\n+    d3.select(\"#heatmap\").selectAll(\"*\").remove();\n+\n+    const svg = d3\n+      .select(\"#heatmap\")\n+      .append(\"svg\")\n+      .style(\"width\", window.innerWidth + \"px\")\n+      .style(\"height\", window.innerHeight + \"px\");\n+    svg\n+      .append(\"g\")\n+      .call(makeCells)\n+      .attr(\"transform\", (d) => `translate(${marginLeft},${marginTop})`);\n+\n+    svg\n+      .append(\"g\")\n+      .call(xAxis)\n+      .attr(\"transform\", `translate(0, ${numRows * cellSize + marginTop})`);\n+\n+    const eventCount = d3.sum(binnedData, (d) => d.length);\n+    const formatDate = (d) => d.toLocaleString(\"en-GB\", { timeZone: \"UTC\" });\n+    svg\n+      .append(\"g\")\n+      .append(\"text\")\n@@ -182,26 +235,12 @@\n-        (d) =>\n-          `${d3.timeFormat(\"%H:%M:%S.%L\")(d.x0)} ${d.length} events`\n-      );\n-\n-  d3\n-    .select(\"#heatmap\")\n-    .selectAll(\"*\").remove()\n-\n-  const svg = d3\n-    .select(\"#heatmap\")\n-    .style(\"width\", window.innerWidth + \"px\")\n-    .style(\"height\", window.innerHeight + \"px\");\n-  svg\n-    .append(\"g\")\n-    .call(makeCells)\n-    .attr(\"transform\", (d) => `translate(${marginLeft},${marginTop})`);\n-\n-  svg\n-    .append(\"g\")\n-    .call(xAxis)\n-    .attr(\"transform\", `translate(0, ${numRows * cellSize + marginTop})`);\n-\n-  svg\n-    .append(\"g\")\n-    .call(yAxis)\n-    .attr(\"transform\", `translate(${marginLeft},0)`);\n+        `This is a heatmap of ${eventCount} events recorded\n+        between ${formatDate(yDomain[0])} and ${formatDate(yDomain[1])}.`\n+      )\n+      .attr(\"transform\", `translate(${width \/ 2},${height + 75})`)\n+      .attr(\"fill\", \"#777\")\n+      .attr(\"text-anchor\", \"middle\");\n+\n+    svg.append(\"g\").call(yAxis).attr(\"transform\", `translate(${marginLeft},0)`);\n+  }\n+} catch (e) {\n+  logger.log(e.name + \":\" + e.message);\n+  logger.log(e.stack);\n","filename":"application\/org.openjdk.jmc.flightrecorder.heatmap\/src\/main\/resources\/heatmap.js","additions":232,"deletions":193,"binary":false,"changes":425,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-    <svg id=\"heatmap\" width=\"100%%\" style=\"text-align: center\"><\/svg>\n+    <div id=\"heatmap\" width=\"100%%\" style=\"text-align: center\"><\/div>\n","filename":"application\/org.openjdk.jmc.flightrecorder.heatmap\/src\/main\/resources\/page.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}