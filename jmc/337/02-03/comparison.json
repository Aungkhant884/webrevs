{"files":[{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+\n+ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+ The contents of this file are subject to the terms of either the Universal Permissive License\n+ v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+\n+ or the following license:\n+\n+ Redistribution and use in source and binary forms, with or without modification, are permitted\n+ provided that the following conditions are met:\n+\n+ 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ and the following disclaimer.\n+\n+ 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ the distribution.\n+\n+ 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ endorse or promote products derived from this software without specific prior written permission.\n+\n+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n@@ -2,12 +35,12 @@\n-  constructor() {\n-    this.domElement = document.createElement(\"pre\");\n-    window.document.body.appendChild(this.domElement);\n-  }\n-\n-  log(msg) {\n-    this.domElement.innerHTML += msg + \"\\n\";\n-  }\n-\n-  clear() {\n-    this.domElement.innerHTML = \"\";\n-  }\n+\tconstructor() {\n+\t\tthis.domElement = document.createElement(\"pre\");\n+\t\twindow.document.body.appendChild(this.domElement);\n+\t}\n+\n+\tlog(msg) {\n+\t\tthis.domElement.innerHTML += msg + \"\\n\";\n+\t}\n+\n+\tclear() {\n+\t\tthis.domElement.innerHTML = \"\";\n+\t}\n@@ -16,1 +49,1 @@\n-  data: [],\n+\tdata: [],\n@@ -22,214 +55,214 @@\n-  function updateHeatmap(jsonStr) {\n-    const rawData = JSON.parse(jsonStr);\n-    const eventTimes = getEventTimes(rawData);\n-    const binnedData = getBinnedData(eventTimes);\n-    chart.data = binnedData;\n-    renderHeatmap(chart.data);\n-  }\n-\n-  function resizeSVG() {\n-    renderHeatmap(chart.data);\n-  }\n-  d3.select(window).on(\"resize\", resizeSVG);\n-\n-  function range(from, to) {\n-    const result = [];\n-    for (let i = from; i < to; i++) {\n-      result.push(i);\n-    }\n-    return result;\n-  }\n-\n-  function getEventTimes(rawData) {\n-    return rawData.events\n-      .filter((event) => event.attributes)\n-      .map(\n-        (event) =>\n-          event.attributes.startTime ||\n-          event.attributes.endTime ||\n-          event.attributes[\"(endTime)\"]\n-      )\n-      .map((time) => new Date(time \/ 10e5));\n-  }\n-\n-  function getBinnedData(eventTimes) {\n-    const scale = d3.scaleTime().domain(d3.extent(eventTimes)).nice(); \/\/ ♥️♥️♥️\n-    const timeRangeMs = scale.domain()[1] - scale.domain()[0];\n-    const binFn = d3\n-      .bin()\n-      .domain(scale.domain())\n-      .thresholds(timeRangeMs \/ 100);\n-    return binFn(eventTimes);\n-  }\n-\n-  function getChartConfig(binnedData) {\n-    \/\/ numCells and maxEvents depend on the data\n-    const numCells = binnedData.length;\n-\n-    \/\/ margins are fixed\n-    const marginLeft = 50;\n-    const marginRight = 20;\n-    const marginTop = 20;\n-    const marginBottom = 100;\n-\n-    \/\/ width and height are fixed from the window\n-    const width = window.innerWidth - (marginLeft + marginRight);\n-    const height = window.innerHeight - (marginTop + marginBottom);\n-\n-    \/\/ cellSize is derived from width, height and numCells\n-    \/\/ anything below 4px is invisible\n-    const cellSize = Math.max(\n-      4,\n-      Math.floor(Math.sqrt((width * height) \/ numCells))\n-    );\n-    const numCols = Math.floor(width \/ cellSize);\n-    const numRows = Math.ceil(numCells \/ numCols);\n-\n-    return {\n-      numCols,\n-      numRows,\n-      cellSize,\n-      marginLeft,\n-      marginTop,\n-      width,\n-      height,\n-    };\n-  }\n-\n-  function getColorScale(binnedData) {\n-    const maxEvents = d3.max(binnedData, (d) => d.length);\n-    return d3.scaleSequentialSqrt(d3.interpolateOrRd).domain([0, maxEvents]);\n-  }\n-\n-  function renderHeatmap(binnedData) {\n-    if (!binnedData || binnedData.length < 2) {\n-      d3.select(\"#heatmap\").append(\"p\").text(\"No data in current selection.\");\n-      return;\n-    }\n-    const chartConfig = getChartConfig(binnedData);\n-    const {\n-      numCols,\n-      numRows,\n-      cellSize,\n-      marginLeft,\n-      marginTop,\n-      width,\n-      height,\n-    } = chartConfig;\n-    const colorScale = getColorScale(binnedData);\n-    const xDomain = range(0, numCols).map((val) => (val * 100) \/ 1000);\n-    const yDomain = [\n-      d3.min(binnedData, (d) => d.x0),\n-      d3.max(binnedData, (d) => d.x1),\n-    ].map((val) => new Date(val));\n-\n-    const xScale = d3\n-      .scaleBand()\n-      .domain(xDomain)\n-      .range([marginLeft, numCols * cellSize + marginLeft]);\n-    const yScale = d3\n-      .scaleLinear()\n-      .domain(yDomain)\n-      .range([marginTop, marginTop + numRows * cellSize]);\n-\n-    const xTickFilter = (x, idx) => {\n-      if (cellSize > 15) {\n-        return true;\n-      } else if (cellSize > 5) {\n-        return idx % 5 === 0;\n-      } else {\n-        return idx % 10 === 0;\n-      }\n-    };\n-    const xAxis = (g) =>\n-      g\n-        .call(\n-          d3\n-            .axisBottom(xScale)\n-            .tickValues(xDomain.filter(xTickFilter))\n-            .tickFormat((d) => `${d3.format(\".1f\")(d)} s`)\n-        )\n-        .selectAll(\"text\")\n-        .attr(\"y\", 0)\n-        .attr(\"x\", -9)\n-        .attr(\"dy\", \".35em\")\n-        .attr(\"transform\", \"rotate(270)\")\n-        .style(\"text-anchor\", \"end\")\n-        .style(\"fill\", \"#777\");\n-\n-    const yAxis = (g) =>\n-      g\n-        .call(\n-          d3\n-            .axisLeft(yScale)\n-            .tickSize(3)\n-            .tickPadding(4)\n-            .tickFormat(d3.timeFormat(\"%H:%M:%S\"))\n-        )\n-        .selectAll(\"text\")\n-        .style(\"fill\", \"#777\");\n-\n-    const makeCells = (g) =>\n-      g\n-        .selectAll(\"rect\")\n-        .data(binnedData)\n-        .enter()\n-        .append(\"rect\")\n-        \/\/ we could potentially emphasize 0 by setting the cell color to white:\n-        \/\/ .attr(\"fill\", (d) => d.length ? colorScale(d.length) : \"white\")\n-        .attr(\"fill\", (d) => colorScale(d.length))\n-        .attr(\"stroke\", \"white\")\n-        .attr(\"x\", (d, i) => {\n-          return (i % numCols) * cellSize;\n-        })\n-        .attr(\"y\", (d, i) => {\n-          return Math.floor(i \/ numCols) * cellSize;\n-        })\n-        .attr(\"height\", cellSize)\n-        .attr(\"width\", cellSize)\n-        .style(\"cursor\", \"pointer\")\n-        .on(\"mouseover\", function () {\n-          const target = d3.select(this);\n-          target.attr(\"fill\", \"gold\");\n-        })\n-        .on(\"mouseout\", function () {\n-          const target = d3.select(this);\n-          target.attr(\"fill\", (d) => colorScale(d.length));\n-        })\n-        .append(\"title\")\n-        .text(\n-          (d) => `${d3.timeFormat(\"%H:%M:%S.%L\")(d.x0)} ${d.length} events`\n-        );\n-\n-    d3.select(\"#heatmap\").selectAll(\"*\").remove();\n-\n-    const svg = d3\n-      .select(\"#heatmap\")\n-      .append(\"svg\")\n-      .style(\"width\", window.innerWidth + \"px\")\n-      .style(\"height\", window.innerHeight + \"px\");\n-    svg\n-      .append(\"g\")\n-      .call(makeCells)\n-      .attr(\"transform\", (d) => `translate(${marginLeft},${marginTop})`);\n-\n-    svg\n-      .append(\"g\")\n-      .call(xAxis)\n-      .attr(\"transform\", `translate(0, ${numRows * cellSize + marginTop})`);\n-\n-    const eventCount = d3.sum(binnedData, (d) => d.length);\n-    const formatDate = (d) => d.toLocaleString(\"en-GB\", { timeZone: \"UTC\" });\n-    svg\n-      .append(\"g\")\n-      .append(\"text\")\n-      .text(\n-        `This is a heatmap of ${eventCount} events recorded\n-        between ${formatDate(yDomain[0])} and ${formatDate(yDomain[1])}.`\n-      )\n-      .attr(\"transform\", `translate(${width \/ 2},${height + 75})`)\n-      .attr(\"fill\", \"#777\")\n-      .attr(\"text-anchor\", \"middle\");\n-\n-    svg.append(\"g\").call(yAxis).attr(\"transform\", `translate(${marginLeft},0)`);\n-  }\n+\tfunction updateHeatmap(jsonStr) {\n+\t\tconst rawData = JSON.parse(jsonStr);\n+\t\tconst eventTimes = getEventTimes(rawData);\n+\t\tconst binnedData = getBinnedData(eventTimes);\n+\t\tchart.data = binnedData;\n+\t\trenderHeatmap(chart.data);\n+\t}\n+\n+\tfunction resizeSVG() {\n+\t\trenderHeatmap(chart.data);\n+\t}\n+\td3.select(window).on(\"resize\", resizeSVG);\n+\n+\tfunction range(from, to) {\n+\t\tconst result = [];\n+\t\tfor (let i = from; i < to; i++) {\n+\t\t\tresult.push(i);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\tfunction getEventTimes(rawData) {\n+\t\treturn rawData.events\n+\t\t\t.filter((event) => event.attributes)\n+\t\t\t.map(\n+\t\t\t\t(event) =>\n+\t\t\t\t\tevent.attributes.startTime ||\n+\t\t\t\t\tevent.attributes.endTime ||\n+\t\t\t\t\tevent.attributes[\"(endTime)\"]\n+\t\t\t)\n+\t\t\t.map((time) => new Date(time \/ 10e5));\n+\t}\n+\n+\tfunction getBinnedData(eventTimes) {\n+\t\tconst scale = d3.scaleTime().domain(d3.extent(eventTimes)).nice(); \/\/ ♥️♥️♥️\n+\t\tconst timeRangeMs = scale.domain()[1] - scale.domain()[0];\n+\t\tconst binFn = d3\n+\t\t\t.bin()\n+\t\t\t.domain(scale.domain())\n+\t\t\t.thresholds(timeRangeMs \/ 100);\n+\t\treturn binFn(eventTimes);\n+\t}\n+\n+\tfunction getChartConfig(binnedData) {\n+\t\t\/\/ numCells and maxEvents depend on the data\n+\t\tconst numCells = binnedData.length;\n+\n+\t\t\/\/ margins are fixed\n+\t\tconst marginLeft = 50;\n+\t\tconst marginRight = 20;\n+\t\tconst marginTop = 20;\n+\t\tconst marginBottom = 100;\n+\n+\t\t\/\/ width and height are fixed from the window\n+\t\tconst width = window.innerWidth - (marginLeft + marginRight);\n+\t\tconst height = window.innerHeight - (marginTop + marginBottom);\n+\n+\t\t\/\/ cellSize is derived from width, height and numCells\n+\t\t\/\/ anything below 4px is invisible\n+\t\tconst cellSize = Math.max(\n+\t\t\t4,\n+\t\t\tMath.floor(Math.sqrt((width * height) \/ numCells))\n+\t\t);\n+\t\tconst numCols = Math.floor(width \/ cellSize);\n+\t\tconst numRows = Math.ceil(numCells \/ numCols);\n+\n+\t\treturn {\n+\t\t\tnumCols,\n+\t\t\tnumRows,\n+\t\t\tcellSize,\n+\t\t\tmarginLeft,\n+\t\t\tmarginTop,\n+\t\t\twidth,\n+\t\t\theight,\n+\t\t};\n+\t}\n+\n+\tfunction getColorScale(binnedData) {\n+\t\tconst maxEvents = d3.max(binnedData, (d) => d.length);\n+\t\treturn d3.scaleSequentialSqrt(d3.interpolateOrRd).domain([0, maxEvents]);\n+\t}\n+\n+\tfunction renderHeatmap(binnedData) {\n+\t\tif (!binnedData || binnedData.length < 2) {\n+\t\t\td3.select(\"#heatmap\").append(\"p\").text(\"No data in current selection.\");\n+\t\t\treturn;\n+\t\t}\n+\t\tconst chartConfig = getChartConfig(binnedData);\n+\t\tconst {\n+\t\t\tnumCols,\n+\t\t\tnumRows,\n+\t\t\tcellSize,\n+\t\t\tmarginLeft,\n+\t\t\tmarginTop,\n+\t\t\twidth,\n+\t\t\theight,\n+\t\t} = chartConfig;\n+\t\tconst colorScale = getColorScale(binnedData);\n+\t\tconst xDomain = range(0, numCols).map((val) => (val * 100) \/ 1000);\n+\t\tconst yDomain = [\n+\t\t\td3.min(binnedData, (d) => d.x0),\n+\t\t\td3.max(binnedData, (d) => d.x1),\n+\t\t].map((val) => new Date(val));\n+\n+\t\tconst xScale = d3\n+\t\t\t.scaleBand()\n+\t\t\t.domain(xDomain)\n+\t\t\t.range([marginLeft, numCols * cellSize + marginLeft]);\n+\t\tconst yScale = d3\n+\t\t\t.scaleLinear()\n+\t\t\t.domain(yDomain)\n+\t\t\t.range([marginTop, marginTop + numRows * cellSize]);\n+\n+\t\tconst xTickFilter = (x, idx) => {\n+\t\t\tif (cellSize > 15) {\n+\t\t\t\treturn true;\n+\t\t\t} else if (cellSize > 5) {\n+\t\t\t\treturn idx % 5 === 0;\n+\t\t\t} else {\n+\t\t\t\treturn idx % 10 === 0;\n+\t\t\t}\n+\t\t};\n+\t\tconst xAxis = (g) =>\n+\t\t\tg\n+\t\t\t\t.call(\n+\t\t\t\t\td3\n+\t\t\t\t\t\t.axisBottom(xScale)\n+\t\t\t\t\t\t.tickValues(xDomain.filter(xTickFilter))\n+\t\t\t\t\t\t.tickFormat((d) => `${d3.format(\".1f\")(d)} s`)\n+\t\t\t\t)\n+\t\t\t\t.selectAll(\"text\")\n+\t\t\t\t.attr(\"y\", 0)\n+\t\t\t\t.attr(\"x\", -9)\n+\t\t\t\t.attr(\"dy\", \".35em\")\n+\t\t\t\t.attr(\"transform\", \"rotate(270)\")\n+\t\t\t\t.style(\"text-anchor\", \"end\")\n+\t\t\t\t.style(\"fill\", \"#777\");\n+\n+\t\tconst yAxis = (g) =>\n+\t\t\tg\n+\t\t\t\t.call(\n+\t\t\t\t\td3\n+\t\t\t\t\t\t.axisLeft(yScale)\n+\t\t\t\t\t\t.tickSize(3)\n+\t\t\t\t\t\t.tickPadding(4)\n+\t\t\t\t\t\t.tickFormat(d3.timeFormat(\"%H:%M:%S\"))\n+\t\t\t\t)\n+\t\t\t\t.selectAll(\"text\")\n+\t\t\t\t.style(\"fill\", \"#777\");\n+\n+\t\tconst makeCells = (g) =>\n+\t\t\tg\n+\t\t\t\t.selectAll(\"rect\")\n+\t\t\t\t.data(binnedData)\n+\t\t\t\t.enter()\n+\t\t\t\t.append(\"rect\")\n+\t\t\t\t\/\/ we could potentially emphasize 0 by setting the cell color to white:\n+\t\t\t\t\/\/ .attr(\"fill\", (d) => d.length ? colorScale(d.length) : \"white\")\n+\t\t\t\t.attr(\"fill\", (d) => colorScale(d.length))\n+\t\t\t\t.attr(\"stroke\", \"white\")\n+\t\t\t\t.attr(\"x\", (d, i) => {\n+\t\t\t\t\treturn (i % numCols) * cellSize;\n+\t\t\t\t})\n+\t\t\t\t.attr(\"y\", (d, i) => {\n+\t\t\t\t\treturn Math.floor(i \/ numCols) * cellSize;\n+\t\t\t\t})\n+\t\t\t\t.attr(\"height\", cellSize)\n+\t\t\t\t.attr(\"width\", cellSize)\n+\t\t\t\t.style(\"cursor\", \"pointer\")\n+\t\t\t\t.on(\"mouseover\", function () {\n+\t\t\t\t\tconst target = d3.select(this);\n+\t\t\t\t\ttarget.attr(\"fill\", \"gold\");\n+\t\t\t\t})\n+\t\t\t\t.on(\"mouseout\", function () {\n+\t\t\t\t\tconst target = d3.select(this);\n+\t\t\t\t\ttarget.attr(\"fill\", (d) => colorScale(d.length));\n+\t\t\t\t})\n+\t\t\t\t.append(\"title\")\n+\t\t\t\t.text(\n+\t\t\t\t\t(d) => `${d3.timeFormat(\"%H:%M:%S.%L\")(d.x0)} ${d.length} events`\n+\t\t\t\t);\n+\n+\t\td3.select(\"#heatmap\").selectAll(\"*\").remove();\n+\n+\t\tconst svg = d3\n+\t\t\t.select(\"#heatmap\")\n+\t\t\t.append(\"svg\")\n+\t\t\t.style(\"width\", window.innerWidth + \"px\")\n+\t\t\t.style(\"height\", window.innerHeight + \"px\");\n+\t\tsvg\n+\t\t\t.append(\"g\")\n+\t\t\t.call(makeCells)\n+\t\t\t.attr(\"transform\", (d) => `translate(${marginLeft},${marginTop})`);\n+\n+\t\tsvg\n+\t\t\t.append(\"g\")\n+\t\t\t.call(xAxis)\n+\t\t\t.attr(\"transform\", `translate(0, ${numRows * cellSize + marginTop})`);\n+\n+\t\tconst eventCount = d3.sum(binnedData, (d) => d.length);\n+\t\tconst formatDate = (d) => d.toLocaleString(\"en-GB\", { timeZone: \"UTC\" });\n+\t\tsvg\n+\t\t\t.append(\"g\")\n+\t\t\t.append(\"text\")\n+\t\t\t.text(\n+\t\t\t\t`This is a heatmap of ${eventCount} events recorded\n+\t\t\t\tbetween ${formatDate(yDomain[0])} and ${formatDate(yDomain[1])}.`\n+\t\t\t)\n+\t\t\t.attr(\"transform\", `translate(${width \/ 2},${height + 75})`)\n+\t\t\t.attr(\"fill\", \"#777\")\n+\t\t\t.attr(\"text-anchor\", \"middle\");\n+\n+\t\tsvg.append(\"g\").call(yAxis).attr(\"transform\", `translate(${marginLeft},0)`);\n+\t}\n@@ -237,2 +270,2 @@\n-  logger.log(e.name + \":\" + e.message);\n-  logger.log(e.stack);\n+\tlogger.log(e.name + \":\" + e.message);\n+\tlogger.log(e.stack);\n","filename":"application\/org.openjdk.jmc.flightrecorder.heatmap\/src\/main\/resources\/heatmap.js","additions":262,"deletions":229,"binary":false,"changes":491,"status":"modified"}]}