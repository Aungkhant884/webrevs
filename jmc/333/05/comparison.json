{"files":[{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Map;\n@@ -58,0 +59,1 @@\n+import org.openjdk.jmc.flightrecorder.parser.IConstantPoolExtension;\n@@ -275,0 +277,5 @@\n+\n+\t@Override\n+\tpublic Map<String, IConstantPoolExtension> getConstantPoolExtensions() {\n+\t\treturn parserStats.getConstantPoolExtensions();\n+\t}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/EventCollection.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import java.util.Collections;\n+import java.util.Map;\n@@ -39,0 +41,1 @@\n+import org.openjdk.jmc.flightrecorder.parser.IConstantPoolExtension;\n@@ -67,0 +70,4 @@\n+\n+\tdefault Map<String, IConstantPoolExtension> getConstantPoolExtensions() {\n+\t\treturn Collections.emptyMap();\n+\t}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/IParserStats.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.Map;\n@@ -41,0 +42,1 @@\n+import org.openjdk.jmc.flightrecorder.parser.IConstantPoolExtension;\n@@ -73,0 +75,4 @@\n+\n+\tpublic Map<String, IConstantPoolExtension> getConstantPoolExtensions() {\n+\t\treturn parserStats.getConstantPoolExtensions();\n+\t}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/EventArrays.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.Map;\n@@ -42,0 +43,1 @@\n+import java.util.concurrent.CopyOnWriteArrayList;\n@@ -54,0 +56,1 @@\n+import org.openjdk.jmc.flightrecorder.parser.IConstantPoolExtension;\n@@ -67,0 +70,1 @@\n+\tprivate final List<IConstantPoolExtension> constPoolExtensions = new CopyOnWriteArrayList<>();\n@@ -78,0 +82,6 @@\n+\t\tfor (IParserExtension extension : extensions) {\n+\t\t\tIConstantPoolExtension constantPoolExtension = extension.createConstantPoolExtension();\n+\t\t\tif (constantPoolExtension != null) {\n+\t\t\t\tconstPoolExtensions.add(constantPoolExtension);\n+\t\t\t}\n+\t\t}\n@@ -102,0 +112,30 @@\n+\tpublic Object constantRead(long constantIndex, Object constant, String eventTypeId) {\n+\t\tObject newConstant = constant;\n+\t\tfor (IConstantPoolExtension m : constPoolExtensions) {\n+\t\t\tnewConstant = m.constantRead(constantIndex, newConstant, eventTypeId);\n+\t\t}\n+\t\treturn newConstant;\n+\t}\n+\n+\tpublic Object constantReferenced(Object constant, String poolName, String eventTypeId) {\n+\t\tObject newConstant = constant;\n+\t\tfor (IConstantPoolExtension m : constPoolExtensions) {\n+\t\t\tnewConstant = m.constantReferenced(newConstant, poolName, eventTypeId);\n+\t\t}\n+\t\treturn newConstant;\n+\t}\n+\n+\tpublic Object constantResolved(Object constant, String poolName, String eventTypeId) {\n+\t\tObject newConstant = constant;\n+\t\tfor (IConstantPoolExtension m : constPoolExtensions) {\n+\t\t\tnewConstant = m.constantResolved(newConstant, poolName, eventTypeId);\n+\t\t}\n+\t\treturn newConstant;\n+\t}\n+\n+\tpublic void allConstantPoolsResolved(Map<String, FastAccessNumberMap<Object>> constantPools) {\n+\t\tfor (IConstantPoolExtension m : constPoolExtensions) {\n+\t\t\tm.allConstantPoolsResolved(constantPools);\n+\t\t}\n+\t}\n+\n@@ -169,0 +209,7 @@\n+\n+\tpublic void addConstantPoolExtensions() {\n+\t\tfor (IConstantPoolExtension ext : constPoolExtensions) {\n+\t\t\text.eventsLoaded();\n+\t\t\tparserStats.addConstantPoolExtension(ext);\n+\t\t}\n+\t}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/parser\/LoaderContext.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-import org.openjdk.jmc.common.unit.StructContentType;\n@@ -65,0 +64,1 @@\n+import org.openjdk.jmc.flightrecorder.parser.IConstantPoolExtension;\n@@ -75,1 +75,1 @@\n-\tprivate final ConcurrentLinkedDeque<ConstantPoolInfo> constantPoolInfoList = new ConcurrentLinkedDeque<ConstantPoolInfo>();\n+\tprivate final ConcurrentLinkedDeque<ConstantPoolInfo> constantPoolInfoList = new ConcurrentLinkedDeque<>();\n@@ -79,0 +79,1 @@\n+\tprivate Map<String, IConstantPoolExtension> constantPoolExtensions = new ConcurrentHashMap<>();\n@@ -116,0 +117,4 @@\n+\tpublic void addConstantPoolExtension(IConstantPoolExtension extension) {\n+\t\tconstantPoolExtensions.put(extension.getId(), extension);\n+\t}\n+\n@@ -179,0 +184,4 @@\n+\tpublic Map<String, IConstantPoolExtension> getConstantPoolExtensions() {\n+\t\treturn constantPoolExtensions;\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/parser\/ParserStats.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+\t\tcontext.addConstantPoolExtensions();\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/parser\/v1\/ChunkLoaderV1.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -172,1 +172,1 @@\n-\t\t\t\t\t\treader = createFieldReader(element.fields.get(0), null);\n+\t\t\t\t\t\treader = createFieldReader(element.fields.get(0), null, context, element.typeIdentifier);\n@@ -190,1 +190,1 @@\n-\t\t\t\t\t\tIValueReader reader = createFieldReader(fe, null);\n+\t\t\t\t\t\tIValueReader reader = createFieldReader(fe, null, context, element.typeIdentifier);\n@@ -295,0 +295,1 @@\n+\t\t\t\tvalue = context.constantRead(constantIndex, value, element.typeIdentifier);\n@@ -342,1 +343,1 @@\n-\t\t\t\t\tIValueReader reader = createFieldReader(fe, valueType);\n+\t\t\t\t\tIValueReader reader = createFieldReader(fe, valueType, context, element.typeIdentifier);\n@@ -354,1 +355,2 @@\n-\t\t\t\t\t\t\tIValueReader nestedReader = createFieldReader(nestedField, nestedValueType);\n+\t\t\t\t\t\t\tIValueReader nestedReader = createFieldReader(nestedField, nestedValueType, context,\n+\t\t\t\t\t\t\t\t\telement.typeIdentifier);\n@@ -387,0 +389,1 @@\n+\tprivate final LoaderContext context;\n@@ -392,0 +395,1 @@\n+\t\tthis.context = context;\n@@ -433,0 +437,1 @@\n+\t\tMap<String, FastAccessNumberMap<Object>> pools = new HashMap<>();\n@@ -435,0 +440,1 @@\n+\t\t\tpools.put(classEntry.element.typeIdentifier, classEntry.constants);\n@@ -436,0 +442,1 @@\n+\t\tcontext.allConstantPoolsResolved(pools);\n@@ -459,1 +466,2 @@\n-\tprivate IValueReader createFieldReader(FieldElement f, String valueType) throws InvalidJfrFileException {\n+\tprivate IValueReader createFieldReader(FieldElement f, String valueType, LoaderContext context, String eventTypeId)\n+\t\t\tthrows InvalidJfrFileException {\n@@ -490,1 +498,1 @@\n-\t\t\treader = new PoolReader(fieldType.constants, reader.getContentType());\n+\t\t\treader = new PoolReader(fieldType.constants, reader.getContentType(), context, typeIdentifier, eventTypeId);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/parser\/v1\/TypeManager.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import org.openjdk.jmc.flightrecorder.internal.parser.LoaderContext;\n@@ -84,0 +85,3 @@\n+\t\tprivate final LoaderContext context;\n+\t\tprivate final String poolName;\n+\t\tprivate final String eventTypeId;\n@@ -85,1 +89,2 @@\n-\t\tPoolReader(FastAccessNumberMap<Object> pool, ContentType<?> contentType) {\n+\t\tPoolReader(FastAccessNumberMap<Object> pool, ContentType<?> contentType, LoaderContext context, String poolName,\n+\t\t\t\tString eventTypeId) {\n@@ -88,0 +93,3 @@\n+\t\t\tthis.context = context;\n+\t\t\tthis.poolName = poolName;\n+\t\t\tthis.eventTypeId = eventTypeId;\n@@ -95,0 +103,1 @@\n+\t\t\tconstant = context.constantReferenced(constant, poolName, eventTypeId);\n@@ -106,1 +115,3 @@\n-\t\t\t\treturn constantPool.get(((ConstantReference) value).key);\n+\t\t\t\tObject newValue = constantPool.get(((ConstantReference) value).key);\n+\t\t\t\tnewValue = context.constantResolved(newValue, poolName, eventTypeId);\n+\t\t\t\treturn newValue;\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/parser\/v1\/ValueReaders.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.parser;\n+\n+import java.util.Map;\n+\n+import org.openjdk.jmc.common.collection.FastAccessNumberMap;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.flightrecorder.IParserStats;\n+\n+\/**\n+ * Interface for Flight Recorder constant pool extensions. Implementation are created by\n+ * {@link IParserExtension#createConstantPoolExtension()} each time a recording is starting to be\n+ * parsed Provides callbacks for constant pools reads, referencing, simple resolution, full\n+ * resolution and parsing is finished\n+ *\/\n+public interface IConstantPoolExtension {\n+\n+\t\/**\n+\t * @return id of the extension, by default the simple class name. This id will be exposed in the\n+\t *         Map returned by {@link IParserStats#getConstantPoolExtensions()}\n+\t *\/\n+\tdefault String getId() {\n+\t\treturn getClass().getSimpleName();\n+\t}\n+\n+\t\/**\n+\t * Called when a constant is read from the Metadata to put into the constant pool.\n+\t * \n+\t * @param constantIndex\n+\t *            index inside the metadata that is used to reference from other places inside the\n+\t *            recording.\n+\t * @param constant\n+\t *            actual value of the constant.\n+\t * @param eventTypeId\n+\t *            type id of the constant pool.\n+\t * @return actual value of the constant. Could be a new value to be replaced by.\n+\t *\/\n+\tdefault Object constantRead(long constantIndex, Object constant, String eventTypeId) {\n+\t\treturn constant;\n+\t}\n+\n+\t\/**\n+\t * Called when a referenced constant is read from another constant pool or actual recording\n+\t * events.\n+\t * \n+\t * @param constant\n+\t *            actual constant value.\n+\t * @param poolName\n+\t *            name of the constant pool.\n+\t * @param eventTypeId\n+\t *            type id if the event referencing the constant.\n+\t * @return actual value of the constant. Could be a new value to be replaced by.\n+\t *\/\n+\tdefault Object constantReferenced(Object constant, String poolName, String eventTypeId) {\n+\t\treturn constant;\n+\t}\n+\n+\t\/**\n+\t * Called when a referenced constant is resolved from another pool or actual recording events.\n+\t * \n+\t * @param constant\n+\t *            actual constant value.\n+\t * @param poolName\n+\t *            name of the constant pool.\n+\t * @param eventTypeId\n+\t *            type id if the event referencing the constant.\n+\t * @return actual value of the constant. Could be a new value to be replaced by.\n+\t *\/\n+\tdefault Object constantResolved(Object constant, String poolName, String eventTypeId) {\n+\t\treturn constant;\n+\t}\n+\n+\t\/**\n+\t * Called when all constant pools are resolved.\n+\t * \n+\t * @param constantPools\n+\t *            map of all constant pools by name.\n+\t *\/\n+\tdefault void allConstantPoolsResolved(Map<String, FastAccessNumberMap<Object>> constantPools) {\n+\n+\t}\n+\n+\t\/**\n+\t * Called when all events are loaded (end of parsing)\n+\t *\/\n+\tdefault void eventsLoaded() {\n+\n+\t}\n+\n+\t\/**\n+\t * @return collection of items built by the extension\n+\t *\/\n+\tdefault IItemCollection getItemCollection() {\n+\t\treturn null;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/parser\/IConstantPoolExtension.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,3 @@\n-\tString getValueInterpretation(String eventTypeId, String fieldId);\n+\tdefault String getValueInterpretation(String eventTypeId, String fieldId) {\n+\t\treturn null;\n+\t}\n@@ -71,1 +73,12 @@\n-\tIEventSinkFactory getEventSinkFactory(IEventSinkFactory subFactory);\n+\tdefault IEventSinkFactory getEventSinkFactory(IEventSinkFactory subFactory) {\n+\t\treturn subFactory;\n+\t}\n+\n+\t\/**\n+\t * creates an instance of IConstantPoolExtension at the beginning of the load of a recording\n+\t * \n+\t * @return an instance implementing IConstantPoolExtension\n+\t *\/\n+\tdefault IConstantPoolExtension createConstantPoolExtension() {\n+\t\treturn null;\n+\t}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/parser\/IParserExtension.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,2 +53,7 @@\n-\t\tServiceLoader<IParserExtension> loader = ServiceLoader.load(IParserExtension.class,\n-\t\t\t\tIParserExtension.class.getClassLoader());\n+\t\tClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n+\t\tServiceLoader<IParserExtension> loader;\n+\t\tif (contextClassLoader == null) {\n+\t\t\tloader = ServiceLoader.load(IParserExtension.class, IParserExtension.class.getClassLoader());\n+\t\t} else {\n+\t\t\tloader = ServiceLoader.load(IParserExtension.class, contextClassLoader);\n+\t\t}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/parser\/ParserExtensionRegistry.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.test;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.openjdk.jmc.common.collection.FastAccessNumberMap;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.flightrecorder.CouldNotLoadRecordingException;\n+import org.openjdk.jmc.flightrecorder.IParserStats;\n+import org.openjdk.jmc.flightrecorder.JfrLoaderToolkit;\n+import org.openjdk.jmc.flightrecorder.parser.IConstantPoolExtension;\n+import org.openjdk.jmc.flightrecorder.parser.IParserExtension;\n+import org.openjdk.jmc.flightrecorder.parser.ParserExtensionRegistry;\n+\n+public class ConstantPoolExtensionTest {\n+\n+\tprivate static final String[] POOL_NAMES = new String[] {\"boolean\", \"byte\", \"char\", \"double\", \"float\", \"int\",\n+\t\t\t\"java.lang.Class\", \"java.lang.String\", \"java.lang.Thread\", \"jdk.jfr.BooleanFlag\", \"jdk.jfr.Category\",\n+\t\t\t\"jdk.jfr.ContentType\", \"jdk.jfr.DataAmount\", \"jdk.jfr.Description\", \"jdk.jfr.Enabled\",\n+\t\t\t\"jdk.jfr.Experimental\", \"jdk.jfr.internal.Cutoff\", \"jdk.jfr.Label\", \"jdk.jfr.MemoryAddress\", \"jdk.jfr.Name\",\n+\t\t\t\"jdk.jfr.Percentage\", \"jdk.jfr.Period\", \"jdk.jfr.Relational\", \"jdk.jfr.StackTrace\", \"jdk.jfr.Threshold\",\n+\t\t\t\"jdk.jfr.Timespan\", \"jdk.jfr.Timestamp\", \"jdk.jfr.TransitionFrom\", \"jdk.jfr.Unsigned\",\n+\t\t\t\"jdk.settings.Cutoff\", \"jdk.settings.Enabled\", \"jdk.settings.Period\", \"jdk.settings.StackTrace\",\n+\t\t\t\"jdk.settings.Threshold\", \"jdk.types.CalleeMethod\", \"jdk.types.ClassLoader\", \"jdk.types.CodeBlobType\",\n+\t\t\t\"jdk.types.CompileId\", \"jdk.types.CompilerPhaseType\", \"jdk.types.CopyFailed\", \"jdk.types.FlagValueOrigin\",\n+\t\t\t\"jdk.types.FrameType\", \"jdk.types.G1EvacuationStatistics\", \"jdk.types.G1HeapRegionType\",\n+\t\t\t\"jdk.types.G1YCType\", \"jdk.types.GCCause\", \"jdk.types.GcId\", \"jdk.types.GCName\",\n+\t\t\t\"jdk.types.GCThresholdUpdater\", \"jdk.types.GCWhen\", \"jdk.types.InflateCause\",\n+\t\t\t\"jdk.types.JavaMonitorAddress\", \"jdk.types.MetadataType\", \"jdk.types.MetaspaceObjectType\",\n+\t\t\t\"jdk.types.MetaspaceSizes\", \"jdk.types.Method\", \"jdk.types.Module\", \"jdk.types.NarrowOopMode\",\n+\t\t\t\"jdk.types.NetworkInterfaceName\", \"jdk.types.ObjectSpace\", \"jdk.types.OldObject\",\n+\t\t\t\"jdk.types.OldObjectArray\", \"jdk.types.OldObjectField\", \"jdk.types.OldObjectGcRoot\",\n+\t\t\t\"jdk.types.OldObjectRootSystem\", \"jdk.types.OldObjectRootType\", \"jdk.types.Package\", \"jdk.types.Reference\",\n+\t\t\t\"jdk.types.ReferenceType\", \"jdk.types.SafepointId\", \"jdk.types.StackFrame\", \"jdk.types.StackTrace\",\n+\t\t\t\"jdk.types.SweepId\", \"jdk.types.Symbol\", \"jdk.types.ThreadGroup\", \"jdk.types.ThreadState\",\n+\t\t\t\"jdk.types.VirtualSpace\", \"jdk.types.VMOperationType\", \"jdk.types.ZStatisticsCounterType\",\n+\t\t\t\"jdk.types.ZStatisticsSamplerType\", \"long\", \"short\"};\n+\tprivate static final int[] POOL_SIZES = new int[] {0, 0, 0, 0, 0, 0, 504, 0, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t\t\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 126, 5, 0, 29, 0, 8, 4, 0, 8, 4, 32, 0, 12, 2, 2, 7, 0, 2, 14, 0,\n+\t\t\t1280, 65, 4, 4, 0, 1, 0, 0, 0, 12, 5, 656, 0, 6, 0, 0, 211, 0, 3485, 5, 9, 0, 76, 0, 0, 0, 0};\n+\tprivate static final String[] READ_EVENT_TYPES = new String[] {\"java.lang.Class\", \"java.lang.Thread\",\n+\t\t\t\"jdk.types.ClassLoader\", \"jdk.types.CodeBlobType\", \"jdk.types.CompilerPhaseType\",\n+\t\t\t\"jdk.types.FlagValueOrigin\", \"jdk.types.FrameType\", \"jdk.types.G1HeapRegionType\", \"jdk.types.G1YCType\",\n+\t\t\t\"jdk.types.GCCause\", \"jdk.types.GCName\", \"jdk.types.GCThresholdUpdater\", \"jdk.types.GCWhen\",\n+\t\t\t\"jdk.types.InflateCause\", \"jdk.types.MetadataType\", \"jdk.types.MetaspaceObjectType\", \"jdk.types.Method\",\n+\t\t\t\"jdk.types.Module\", \"jdk.types.NarrowOopMode\", \"jdk.types.NetworkInterfaceName\", \"jdk.types.OldObject\",\n+\t\t\t\"jdk.types.OldObjectRootSystem\", \"jdk.types.OldObjectRootType\", \"jdk.types.Package\",\n+\t\t\t\"jdk.types.ReferenceType\", \"jdk.types.StackTrace\", \"jdk.types.Symbol\", \"jdk.types.ThreadGroup\",\n+\t\t\t\"jdk.types.ThreadState\", \"jdk.types.VMOperationType\"\n+\n+\t};\n+\tprivate final static String[] REF_EVENT_TYPES = new String[] {\"java.lang.Class\", \"java.lang.Thread\",\n+\t\t\t\"jdk.ActiveRecording\", \"jdk.ActiveSetting\", \"jdk.BiasedLockRevocation\", \"jdk.BiasedLockSelfRevocation\",\n+\t\t\t\"jdk.BooleanFlag\", \"jdk.ClassDefine\", \"jdk.ClassLoad\", \"jdk.ClassLoaderStatistics\",\n+\t\t\t\"jdk.CodeCacheStatistics\", \"jdk.Compilation\", \"jdk.CompilerInlining\", \"jdk.DoubleFlag\",\n+\t\t\t\"jdk.ExceptionStatistics\", \"jdk.ExecuteVMOperation\", \"jdk.ExecutionSample\", \"jdk.Flush\",\n+\t\t\t\"jdk.G1GarbageCollection\", \"jdk.G1HeapSummary\", \"jdk.GarbageCollection\", \"jdk.GCConfiguration\",\n+\t\t\t\"jdk.GCHeapConfiguration\", \"jdk.GCHeapSummary\", \"jdk.GCPhaseParallel\", \"jdk.GCPhasePause\",\n+\t\t\t\"jdk.GCPhasePauseLevel1\", \"jdk.GCPhasePauseLevel2\", \"jdk.GCReferenceStatistics\", \"jdk.IntFlag\",\n+\t\t\t\"jdk.JavaMonitorWait\", \"jdk.LongFlag\", \"jdk.MetaspaceChunkFreeListSummary\", \"jdk.MetaspaceSummary\",\n+\t\t\t\"jdk.ModuleExport\", \"jdk.ModuleRequire\", \"jdk.NativeMethodSample\", \"jdk.NetworkUtilization\",\n+\t\t\t\"jdk.ObjectAllocationInNewTLAB\", \"jdk.ObjectAllocationOutsideTLAB\", \"jdk.OldObjectSample\",\n+\t\t\t\"jdk.PromoteObjectInNewPLAB\", \"jdk.PromoteObjectOutsidePLAB\", \"jdk.SafepointBegin\", \"jdk.SocketRead\",\n+\t\t\t\"jdk.StringFlag\", \"jdk.ThreadAllocationStatistics\", \"jdk.ThreadCPULoad\", \"jdk.ThreadEnd\", \"jdk.ThreadStart\",\n+\t\t\t\"jdk.types.ClassLoader\", \"jdk.types.Method\", \"jdk.types.Module\", \"jdk.types.OldObject\", \"jdk.types.Package\",\n+\t\t\t\"jdk.types.StackFrame\", \"jdk.types.ThreadGroup\", \"jdk.UnsignedIntFlag\", \"jdk.UnsignedLongFlag\",\n+\t\t\t\"WorkEvent\"};\n+\tprivate static final String[] RESOLVED_EVENT_TYPES = new String[] {\"jdk.types.Method\", \"jdk.types.Module\",\n+\t\t\t\"java.lang.Thread\", \"jdk.types.StackFrame\", \"jdk.types.ClassLoader\", \"jdk.types.ThreadGroup\",\n+\t\t\t\"java.lang.Class\", \"jdk.types.Package\", \"jdk.types.OldObject\",};\n+\n+\t@Test\n+\tpublic void constantResolution() throws IOException, CouldNotLoadRecordingException {\n+\t\tList<IParserExtension> extensions = new ArrayList<>(ParserExtensionRegistry.getParserExtensions());\n+\t\textensions.add(new MyParserExtension());\n+\t\tFile recordingFile = new File(\n+\t\t\t\tConstantPoolExtensionTest.class.getClassLoader().getResource(\"recordings\/metadata_new.jfr\").getFile());\n+\t\tIItemCollection items = JfrLoaderToolkit.loadEvents(Arrays.asList(recordingFile), extensions);\n+\t\tAssert.assertTrue(items.hasItems());\n+\t\tIConstantPoolExtension ext = ((IParserStats) items).getConstantPoolExtensions()\n+\t\t\t\t.get(MyConstantPoolExtension.class.getSimpleName());\n+\t\tAssert.assertNotNull(ext);\n+\t\tMyConstantPoolExtension extension = (MyConstantPoolExtension) ext;\n+\t\tfor (String eventType : READ_EVENT_TYPES) {\n+\t\t\tAssert.assertTrue(extension.readEventTypes.contains(eventType));\n+\t\t}\n+\t\tfor (String eventType : REF_EVENT_TYPES) {\n+\t\t\tAssert.assertTrue(extension.referencedEventTypes.contains(eventType));\n+\t\t}\n+\t\tfor (String eventType : RESOLVED_EVENT_TYPES) {\n+\t\t\tAssert.assertTrue(extension.resolvedEventTypes.contains(eventType));\n+\t\t}\n+\n+\t}\n+\n+\tprivate class MyParserExtension implements IParserExtension {\n+\t\t@Override\n+\t\tpublic IConstantPoolExtension createConstantPoolExtension() {\n+\t\t\treturn new MyConstantPoolExtension();\n+\t\t}\n+\t}\n+\n+\tprivate static class MyConstantPoolExtension implements IConstantPoolExtension {\n+\t\tSet<String> readEventTypes = new HashSet<>();\n+\t\tSet<String> referencedEventTypes = new HashSet<>();\n+\n+\t\t@Override\n+\t\tpublic Object constantRead(long constantIndex, Object constant, String eventTypeId) {\n+\t\t\treadEventTypes.add(eventTypeId);\n+\t\t\treturn constant;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Object constantReferenced(Object constant, String poolName, String eventTypeId) {\n+\t\t\treferencedEventTypes.add(eventTypeId);\n+\t\t\treturn constant;\n+\t\t}\n+\n+\t\tSet<String> resolvedEventTypes = new HashSet<>();\n+\t\tprivate FastAccessNumberMap<Object> constantPool;\n+\n+\t\t@Override\n+\t\tpublic Object constantResolved(Object constant, String poolName, String eventTypeId) {\n+\t\t\tresolvedEventTypes.add(eventTypeId);\n+\t\t\treturn constant;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void allConstantPoolsResolved(Map<String, FastAccessNumberMap<Object>> constantPools) {\n+\t\t\tfor (int i = 0; i < POOL_NAMES.length; i++) {\n+\t\t\t\tconstantPool = constantPools.get(POOL_NAMES[i]);\n+\t\t\t\tAssert.assertNotNull(constantPool);\n+\t\t\t\tint count = 0;\n+\t\t\t\tIterator<Object> it = constantPool.iterator();\n+\t\t\t\twhile (it.hasNext()) {\n+\t\t\t\t\tit.next();\n+\t\t\t\t\tcount++;\n+\t\t\t\t}\n+\t\t\t\tAssert.assertEquals(POOL_SIZES[i], count);\n+\t\t\t}\n+\t\t}\n+\n+\t}\n+\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/ConstantPoolExtensionTest.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.Arrays;\n@@ -52,0 +53,2 @@\n+import org.openjdk.jmc.flightrecorder.parser.IParserExtension;\n+import org.openjdk.jmc.flightrecorder.parser.ParserExtensionRegistry;\n@@ -91,0 +94,5 @@\n+\t\treturn getFlightRecording(resource, ParserExtensionRegistry.getParserExtensions());\n+\t}\n+\n+\tpublic static IItemCollection getFlightRecording(IOResource resource, List<IParserExtension> extensions)\n+\t\t\tthrows IOException, CouldNotLoadRecordingException {\n@@ -101,1 +109,1 @@\n-\t\treturn JfrLoaderToolkit.loadEvents(tmpRecording);\n+\t\treturn JfrLoaderToolkit.loadEvents(Arrays.asList(tmpRecording), extensions);\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/util\/RecordingToolkit.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"}]}