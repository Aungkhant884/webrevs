{"files":[{"patch":"@@ -3,1 +3,1 @@\n-   Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+   Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,11 @@\n+\n+    <build>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins<\/groupId>\n+                <artifactId>maven-surefire-plugin<\/artifactId>\n+                <version>3.0.0-M3<\/version>\n+            <\/plugin>\n+        <\/plugins>\n+    <\/build>\n+\n@@ -54,0 +65,6 @@\n+        <dependency>\n+            <groupId>junit<\/groupId>\n+            <artifactId>junit<\/artifactId>\n+            <version>4.13.1<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n@@ -58,0 +75,1 @@\n+            <scope>test<\/scope>\n@@ -63,0 +81,7 @@\n+            <scope>test<\/scope>\n+        <\/dependency>\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-engine<\/artifactId>\n+            <version>5.5.2<\/version>\n+            <scope>test<\/scope>\n@@ -67,1 +92,8 @@\n-            <version>3.1.0<\/version>\n+            <version>3.7.7<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+        <dependency>\n+            <groupId>org.mockito<\/groupId>\n+            <artifactId>mockito-inline<\/artifactId>\n+            <version>3.7.7<\/version>\n+            <scope>test<\/scope>\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/pom.xml","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedField;\n@@ -96,1 +97,1 @@\n-\tvoid writeValueType(LEB128Writer writer, TypedValueImpl typedValue, boolean useCp) {\n+\tvoid writeValueType(LEB128Writer writer, TypedValueImpl typedValue, boolean useConstantPoolReferences) {\n@@ -102,1 +103,1 @@\n-\t\t\twriteBuiltinType(writer, typedValue, useCp);\n+\t\t\twriteBuiltinType(writer, typedValue, useConstantPoolReferences);\n@@ -107,1 +108,2 @@\n-\t\t\t\tif (useCp) { \/\/ (assumption) all custom types have constant pool\n+\t\t\t\tif (type.hasConstantPool()) {\n+\t\t\t\t\t\/\/ only if cp-refs are allowed\n@@ -111,1 +113,2 @@\n-\t\t\t\t\t\tif (fieldValue.getField().isArray()) {\n+\t\t\t\t\t\tTypedField field = fieldValue.getField();\n+\t\t\t\t\t\tif (field.isArray()) {\n@@ -114,1 +117,1 @@\n-\t\t\t\t\t\t\t\twriteValueType(writer, t, true);\n+\t\t\t\t\t\t\t\twriteValueType(writer, t, t.getType().hasConstantPool());\n@@ -117,1 +120,1 @@\n-\t\t\t\t\t\t\twriteValueType(writer, fieldValue.getValue(), true);\n+\t\t\t\t\t\t\twriteValueType(writer, fieldValue.getValue(), field.getType().hasConstantPool());\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/ConstantPool.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -121,1 +121,2 @@\n-\t * Register a {@linkplain Type} instance\n+\t * Register a {@linkplain org.openjdk.jmc.flightrecorder.writer.api.Type} instance with values\n+\t * stored in an associated constant pool.\n@@ -132,1 +133,1 @@\n-\t\treturn registerType(typeName, supertype,\n+\t\treturn registerType(typeName, supertype, true,\n@@ -136,0 +137,32 @@\n+\t\/**\n+\t * Register a {@linkplain org.openjdk.jmc.flightrecorder.writer.api.Type} instance\n+\t *\n+\t * @param typeName\n+\t *            the type name\n+\t * @param supertype\n+\t *            super type; may be {@literal null}\n+\t * @param withConstantPool\n+\t *            store the values in an associated constant pool\n+\t * @param typeStructureProvider\n+\t *            type structure provider to be called lazily when a new type is created\n+\t * @return registered type - either a new type or or a previously registered with the same name\n+\t *\/\n+\tTypeImpl registerType(\n+\t\tString typeName, String supertype, boolean withConstantPool,\n+\t\tSupplier<TypeStructureImpl> typeStructureProvider) {\n+\t\treturn registerType(typeName, supertype, withConstantPool,\n+\t\t\t\ttypeStructureProvider != null ? typeStructureProvider.get() : TypeStructureImpl.EMPTY);\n+\t}\n+\n+\t\/**\n+\t * Register a {@linkplain org.openjdk.jmc.flightrecorder.writer.api.Type} instance with values\n+\t * stored in an associated constant pool.\n+\t *\n+\t * @param typeName\n+\t *            the type name\n+\t * @param supertype\n+\t *            super type; may be {@literal null}\n+\t * @param compositeType\n+\t *            the composite type structure description\n+\t * @return registered type - either a new type or or a previously registered with the same name\n+\t *\/\n@@ -137,0 +170,18 @@\n+\t\treturn registerType(typeName, supertype, true, compositeType);\n+\t}\n+\n+\t\/**\n+\t * Register a {@linkplain org.openjdk.jmc.flightrecorder.writer.api.Type} instance\n+\t *\n+\t * @param typeName\n+\t *            the type name\n+\t * @param supertype\n+\t *            super type; may be {@literal null}\n+\t * @param withConstantPool\n+\t *            store the values in an associated constant pool\n+\t * @param compositeType\n+\t *            the composite type structure description\n+\t * @return registered type - either a new type or or a previously registered with the same name\n+\t *\/\n+\tTypeImpl registerType(\n+\t\tString typeName, String supertype, boolean withConstantPool, TypeStructureImpl compositeType) {\n@@ -138,1 +189,1 @@\n-\t\t\tTypeImpl t = createCustomType(name, supertype, compositeType);\n+\t\t\tTypeImpl t = createCustomType(name, supertype, compositeType, withConstantPool);\n@@ -197,1 +248,1 @@\n-\tTypeImpl createCustomType(String name, String supertype, TypeStructureImpl structure) {\n+\tTypeImpl createCustomType(String name, String supertype, TypeStructureImpl structure, boolean withConstantPool) {\n@@ -203,1 +254,1 @@\n-\t\t\t\t!\"jdk.jfr.Event\".equals(supertype) ? constantPools : null, types);\n+\t\t\t\twithConstantPool && !\"jdk.jfr.Event\".equals(supertype) ? constantPools : null, types);\n@@ -214,2 +265,3 @@\n-\t * @return the specified {@linkplain Type} instance or {@linkplain null} if that type is not in\n-\t *         the metadata storage yet and 'asResolvable' was {@literal false}\n+\t * @return the specified {@linkplain org.openjdk.jmc.flightrecorder.writer.api.Type} instance or\n+\t *         {@linkplain null} if that type is not in the metadata storage yet and 'asResolvable'\n+\t *         was {@literal false}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/MetadataImpl.java","additions":59,"deletions":7,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-\t\treturn getOrAdd(type.getTypeName(), builderCallback);\n+\t\treturn getOrAdd(type.getTypeName(), true, builderCallback);\n@@ -155,2 +155,2 @@\n-\tpublic TypeImpl getOrAdd(String name, Consumer<TypeStructureBuilder> builderCallback) {\n-\t\treturn getOrAdd(name, null, builderCallback);\n+\tpublic TypeImpl getOrAdd(String name, boolean withConstantPool, Consumer<TypeStructureBuilder> builderCallback) {\n+\t\treturn getOrAdd(name, null, withConstantPool, builderCallback);\n@@ -161,1 +161,1 @@\n-\t\treturn getOrAdd(type.getTypeName(), supertype, builderCallback);\n+\t\treturn getOrAdd(type.getTypeName(), supertype, true, builderCallback);\n@@ -165,2 +165,3 @@\n-\tpublic TypeImpl getOrAdd(String name, String supertype, Consumer<TypeStructureBuilder> builderCallback) {\n-\t\treturn metadata.registerType(name, supertype, () -> {\n+\tpublic TypeImpl getOrAdd(\n+\t\tString name, String supertype, boolean withConstantPool, Consumer<TypeStructureBuilder> builderCallback) {\n+\t\treturn metadata.registerType(name, supertype, withConstantPool, () -> {\n@@ -173,0 +174,15 @@\n+\t@Override\n+\tpublic TypeImpl getOrAdd(String name, String supertype, boolean withConstantPool, TypeStructure typeStructure) {\n+\t\treturn metadata.registerType(name, supertype, withConstantPool, (TypeStructureImpl) typeStructure);\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl getOrAdd(String name, Consumer<TypeStructureBuilder> builderCallback) {\n+\t\treturn getOrAdd(name, true, builderCallback);\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl getOrAdd(String name, String supertype, Consumer<TypeStructureBuilder> builderCallback) {\n+\t\treturn getOrAdd(name, supertype, true, builderCallback);\n+\t}\n+\n@@ -175,1 +191,1 @@\n-\t\treturn metadata.registerType(name, supertype, (TypeStructureImpl) typeStructure);\n+\t\treturn getOrAdd(name, supertype, true, typeStructure);\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypesImpl.java","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.io.BufferedOutputStream;\n@@ -41,0 +42,1 @@\n+import java.io.OutputStream;\n@@ -59,0 +61,4 @@\n+\n+\tpublic static Recording newRecording(OutputStream recordingStream) {\n+\t\treturn new RecordingImpl(new BufferedOutputStream(recordingStream));\n+\t}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/Recordings.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-\t * @return\n+\t * @return built {@linkplain TypeStructure}\n@@ -145,0 +145,9 @@\n+\t\/**\n+\t * A shortcut to build-and-register functionality\n+\t * \n+\t * @param name\n+\t *            the type name\n+\t * @param supertype\n+\t *            the supertype name\n+\t * @return a new {@linkplain Type} instance\n+\t *\/\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/TypeStructureBuilder.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -44,1 +44,2 @@\n-\t * Retrieve the given type or create it a-new if it hasn't been added yet.\n+\t * Retrieve the given type or create it a-new if it hasn't been added yet. The type values will\n+\t * be stored in an associated constant pool.\n@@ -65,0 +66,14 @@\n+\t\/**\n+\t * Retrieve the given type or create it a-new if it hasn't been added yet.\n+\t *\n+\t * @param name\n+\t *            the name of the type to retrieve\n+\t * @param withConstantPool\n+\t *            should the type values use an associated constant pool\n+\t * @param builderCallback\n+\t *            will be called lazily when the type is about to be initialized\n+\t * @return the corresponding {@link Type type} instance\n+\t *\/\n+\tpublic abstract Type getOrAdd(\n+\t\tString name, boolean withConstantPool, Consumer<TypeStructureBuilder> builderCallback);\n+\n@@ -79,1 +94,2 @@\n-\t * Retrieve the given type or create it a-new if it hasn't been added yet.\n+\t * Retrieve the given type or create it a-new if it hasn't been added yet. The type values will\n+\t * be stored in an associated constant pool.\n@@ -91,0 +107,28 @@\n+\t\/**\n+\t * Retrieve the given type or create it a-new if it hasn't been added yet.\n+\t *\n+\t * @param name\n+\t *            the name of the type to retrieve\n+\t * @param supertype\n+\t *            the super type name\n+\t * @param withConstantPool\n+\t *            should the type values use an associated constant pool\n+\t * @param builderCallback\n+\t *            will be called lazily when the type is about to be initialized\n+\t * @return the corresponding {@link Type type} instance\n+\t *\/\n+\tpublic abstract Type getOrAdd(\n+\t\tString name, String supertype, boolean withConstantPool, Consumer<TypeStructureBuilder> builderCallback);\n+\n+\t\/**\n+\t * Retrieve the given type or create it a-new if it hasn't been added yet. The type values will\n+\t * be stored in an associated constant pool.\n+\t *\n+\t * @param name\n+\t *            the name of the type to retrieve\n+\t * @param supertype\n+\t *            the super type name\n+\t * @param typeStructure\n+\t *            the type structure definition\n+\t * @return the corresponding {@link Type type} instance\n+\t *\/\n@@ -93,0 +137,15 @@\n+\t\/**\n+\t * Retrieve the given type or create it a-new if it hasn't been added yet.\n+\t *\n+\t * @param name\n+\t *            the name of the type to retrieve\n+\t * @param supertype\n+\t *            the super type name\n+\t * @param withConstantPool\n+\t *            should the type values use an associated constant pool\n+\t * @param typeStructure\n+\t *            the type structure definition\n+\t * @return the corresponding {@link Type type} instance\n+\t *\/\n+\tpublic abstract Type getOrAdd(String name, String supertype, boolean withConstantPool, TypeStructure typeStructure);\n+\n@@ -126,0 +185,6 @@\n+\t\/**\n+\t * A convenience accessor to {@linkplain TypeStructureBuilder} instance outside of the type\n+\t * configuration callback\n+\t * \n+\t * @return a new {@linkplain TypeStructureBuilder} instance\n+\t *\/\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/Types.java","additions":67,"deletions":2,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.nio.file.Files;\n@@ -42,1 +43,0 @@\n-import java.nio.file.Paths;\n@@ -67,1 +67,1 @@\n-\tprivate final Path jfrPath = Paths.get(\"\/tmp\", \"test.jfr\");\n+\tprivate Path jfrPath;\n@@ -74,0 +74,1 @@\n+\t\tjfrPath = Files.createTempFile(\"jfr-writer-test-\", \".jfr\");\n@@ -80,0 +81,1 @@\n+\t\tFiles.deleteIfExists(jfrPath);\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/ChunkComplexTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-\t\t\t\t() -> instance.createCustomType(typeName, null, TypeStructureImpl.EMPTY));\n+\t\t\t\t() -> instance.createCustomType(typeName, null, TypeStructureImpl.EMPTY, true));\n@@ -153,1 +153,1 @@\n-\t\tTypeImpl type = instance.createCustomType(typeName, null, null);\n+\t\tTypeImpl type = instance.createCustomType(typeName, null, null, true);\n@@ -165,7 +165,10 @@\n-\t\tTypeImpl type = instance.createCustomType(typeName, superName, TypeStructureImpl.EMPTY);\n-\t\tassertNotNull(type);\n-\t\tassertFalse(type.isBuiltin());\n-\t\tassertEquals(typeName, type.getTypeName());\n-\t\tassertNotNull(type.getFields());\n-\t\tassertNotNull(type.getAnnotations());\n-\t\tassertEquals(superName, type.getSupertype());\n+\t\tfor (boolean withCp : new boolean[] {true, false}) {\n+\t\t\tTypeImpl type = instance.createCustomType(typeName, superName, TypeStructureImpl.EMPTY, withCp);\n+\t\t\tassertNotNull(type);\n+\t\t\tassertFalse(type.isBuiltin());\n+\t\t\tassertEquals(typeName, type.getTypeName());\n+\t\t\tassertNotNull(type.getFields());\n+\t\t\tassertNotNull(type.getAnnotations());\n+\t\t\tassertEquals(superName, type.getSupertype());\n+\t\t\tassertEquals(withCp, type.hasConstantPool());\n+\t\t}\n@@ -179,1 +182,1 @@\n-\t\tTypeImpl type1 = instance.createCustomType(typeName, superName, TypeStructureImpl.EMPTY);\n+\t\tTypeImpl type1 = instance.createCustomType(typeName, superName, TypeStructureImpl.EMPTY, true);\n@@ -183,1 +186,1 @@\n-\t\tTypeImpl type2 = instance.createCustomType(typeName, superName, TypeStructureImpl.EMPTY);\n+\t\tTypeImpl type2 = instance.createCustomType(typeName, superName, TypeStructureImpl.EMPTY, true);\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/MetadataImplTest.java","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n@@ -39,0 +40,1 @@\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -48,0 +50,1 @@\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n@@ -85,0 +88,1 @@\n+\t\tassertFalse(eventType.hasConstantPool());\n@@ -94,0 +98,1 @@\n+\t\tassertFalse(eventType.hasConstantPool());\n@@ -128,0 +133,1 @@\n+\t\tassertTrue(annotationType.hasConstantPool());\n@@ -137,0 +143,1 @@\n+\t\tassertTrue(annotationType.hasConstantPool());\n@@ -170,0 +177,10 @@\n+\t\tassertTrue(type.hasConstantPool());\n+\t}\n+\n+\t@ParameterizedTest\n+\t@EnumSource(Types.Builtin.class)\n+\tvoid getBuiltinType(Types.Builtin target) {\n+\t\tTypeImpl type = recording.getType(target.getTypeName());\n+\t\tassertNotNull(type);\n+\t\t\/\/ only String 'primitive' values have constant pool associated with them\n+\t\tassertEquals(target.isSame(Types.Builtin.STRING), type.hasConstantPool());\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/RecordingImplTest.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}