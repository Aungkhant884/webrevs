{"files":[{"patch":"@@ -1362,0 +1362,2 @@\n+\tprivate static final IAggregator<IQuantity, ?> EARLIEST_START_TIME = Aggregators.min(JfrAttributes.START_TIME);\n+\n@@ -1371,12 +1373,11 @@\n-\t\tIQuantity earliestStartTime = null;\n-\t\tfor (IItemIterable iItemIterable : items) {\n-\t\t\tIMemberAccessor<IQuantity, IItem> startTimeAccessor = JfrAttributes.START_TIME\n-\t\t\t\t\t.getAccessor(iItemIterable.getType());\n-\t\t\tif (iItemIterable.iterator().hasNext()) {\n-\t\t\t\tIItem next = iItemIterable.iterator().next();\n-\t\t\t\tif (next != null && startTimeAccessor != null) {\n-\t\t\t\t\tIQuantity startTime = startTimeAccessor.getMember(next);\n-\t\t\t\t\tif (earliestStartTime == null) {\n-\t\t\t\t\t\tearliestStartTime = startTime;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif (earliestStartTime.compareTo(startTime) >= 0) {\n+\t\t\/\/ JMC-7088: We use this check to disable the optimisation for IItemCollection implementations that don't contain sorted event lanes.\n+\t\tif (items.getClass().getName().equals(\"EventCollection\")) { \/\/$NON-NLS-1$\n+\t\t\tIQuantity earliestStartTime = null;\n+\t\t\tfor (IItemIterable iItemIterable : items) {\n+\t\t\t\tIMemberAccessor<IQuantity, IItem> startTimeAccessor = JfrAttributes.START_TIME\n+\t\t\t\t\t\t.getAccessor(iItemIterable.getType());\n+\t\t\t\tif (iItemIterable.iterator().hasNext()) {\n+\t\t\t\t\tIItem next = iItemIterable.iterator().next();\n+\t\t\t\t\tif (next != null && startTimeAccessor != null) {\n+\t\t\t\t\t\tIQuantity startTime = startTimeAccessor.getMember(next);\n+\t\t\t\t\t\tif (earliestStartTime == null) {\n@@ -1384,0 +1385,4 @@\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (earliestStartTime.compareTo(startTime) >= 0) {\n+\t\t\t\t\t\t\t\tearliestStartTime = startTime;\n+\t\t\t\t\t\t\t}\n@@ -1388,0 +1393,3 @@\n+\t\t\treturn earliestStartTime;\n+\t\t} else {\n+\t\t\treturn items.getAggregate(EARLIEST_START_TIME);\n@@ -1389,1 +1397,0 @@\n-\t\treturn earliestStartTime;\n@@ -1392,0 +1399,2 @@\n+\tprivate static final IAggregator<IQuantity, ?> EARLIEST_END_TIME = Aggregators.min(JfrAttributes.END_TIME);\n+\n@@ -1401,12 +1410,11 @@\n-\t\tIQuantity earliestEndTime = null;\n-\t\tfor (IItemIterable iItemIterable : items) {\n-\t\t\tIMemberAccessor<IQuantity, IItem> endTimeAccessor = JfrAttributes.END_TIME\n-\t\t\t\t\t.getAccessor(iItemIterable.getType());\n-\t\t\tif (iItemIterable.iterator().hasNext()) {\n-\t\t\t\tIItem next = iItemIterable.iterator().next();\n-\t\t\t\tif (next != null && endTimeAccessor != null) {\n-\t\t\t\t\tIQuantity endTime = endTimeAccessor.getMember(next);\n-\t\t\t\t\tif (earliestEndTime == null) {\n-\t\t\t\t\t\tearliestEndTime = endTime;\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tif (earliestEndTime.compareTo(endTime) >= 0) {\n+\t\t\/\/ JMC-7088: We use this check to disable the optimisation for IItemCollection implementations that don't contain sorted event lanes.\n+\t\tif (items.getClass().getName().equals(\"EventCollection\")) { \/\/$NON-NLS-1$\n+\t\t\tIQuantity earliestEndTime = null;\n+\t\t\tfor (IItemIterable iItemIterable : items) {\n+\t\t\t\tIMemberAccessor<IQuantity, IItem> endTimeAccessor = JfrAttributes.END_TIME\n+\t\t\t\t\t\t.getAccessor(iItemIterable.getType());\n+\t\t\t\tif (iItemIterable.iterator().hasNext()) {\n+\t\t\t\t\tIItem next = iItemIterable.iterator().next();\n+\t\t\t\t\tif (next != null && endTimeAccessor != null) {\n+\t\t\t\t\t\tIQuantity endTime = endTimeAccessor.getMember(next);\n+\t\t\t\t\t\tif (earliestEndTime == null) {\n@@ -1414,0 +1422,4 @@\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tif (earliestEndTime.compareTo(endTime) >= 0) {\n+\t\t\t\t\t\t\t\tearliestEndTime = endTime;\n+\t\t\t\t\t\t\t}\n@@ -1418,0 +1430,3 @@\n+\t\t\treturn earliestEndTime;\n+\t\t} else {\n+\t\t\treturn items.getAggregate(EARLIEST_END_TIME);\n@@ -1419,1 +1434,0 @@\n-\t\treturn earliestEndTime;\n@@ -1422,0 +1436,2 @@\n+\tprivate static final IAggregator<IQuantity, ?> LATEST_END_TIME = Aggregators.max(JfrAttributes.END_TIME);\n+\n@@ -1431,16 +1447,19 @@\n-\t\tIQuantity latestEndTime = null;\n-\t\tfor (IItemIterable iItemIterable : items) {\n-\t\t\tIMemberAccessor<IQuantity, IItem> endTimeAccessor = JfrAttributes.END_TIME\n-\t\t\t\t\t.getAccessor(iItemIterable.getType());\n-\t\t\tIterator<IItem> iterator = iItemIterable.iterator();\n-\t\t\tIItem next = null;\n-\t\t\twhile (iterator.hasNext()) {\n-\t\t\t\tnext = iterator.next();\n-\t\t\t}\n-\t\t\tif (next != null && endTimeAccessor != null) {\n-\t\t\t\tIQuantity startTime = endTimeAccessor.getMember(next);\n-\t\t\t\tif (latestEndTime == null) {\n-\t\t\t\t\tlatestEndTime = startTime;\n-\t\t\t\t} else {\n-\t\t\t\t\tif (latestEndTime.compareTo(startTime) <= 0) {\n-\t\t\t\t\t\tlatestEndTime = startTime;\n+\t\t\/\/ JMC-7088: We use this check to disable the optimisation for IItemCollection implementations that don't contain sorted event lanes.\n+\t\tif (items.getClass().getName().equals(\"EventCollection\")) { \/\/$NON-NLS-1$\n+\t\t\tIQuantity latestEndTime = null;\n+\t\t\tfor (IItemIterable iItemIterable : items) {\n+\t\t\t\tIMemberAccessor<IQuantity, IItem> endTimeAccessor = JfrAttributes.END_TIME\n+\t\t\t\t\t\t.getAccessor(iItemIterable.getType());\n+\t\t\t\tIterator<IItem> iterator = iItemIterable.iterator();\n+\t\t\t\tIItem next = null;\n+\t\t\t\twhile (iterator.hasNext()) {\n+\t\t\t\t\tnext = iterator.next();\n+\t\t\t\t}\n+\t\t\t\tif (next != null && endTimeAccessor != null) {\n+\t\t\t\t\tIQuantity endTime = endTimeAccessor.getMember(next);\n+\t\t\t\t\tif (latestEndTime == null) {\n+\t\t\t\t\t\tlatestEndTime = endTime;\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (latestEndTime.compareTo(endTime) <= 0) {\n+\t\t\t\t\t\t\tlatestEndTime = endTime;\n+\t\t\t\t\t\t}\n@@ -1450,0 +1469,3 @@\n+\t\t\treturn latestEndTime;\n+\t\t} else {\n+\t\t\treturn items.getAggregate(LATEST_END_TIME);\n@@ -1451,1 +1473,1 @@\n-\t\treturn latestEndTime;\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/util\/RulesToolkit.java","additions":65,"deletions":43,"binary":false,"changes":108,"status":"modified"}]}