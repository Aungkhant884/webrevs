{"files":[{"patch":"@@ -46,0 +46,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -95,1 +96,1 @@\n-\tpublic final static String KEY_SOCKET_FACTORY = \"com.sun.jndi.rmi.factory.socket\"; \/\/$NON-NLS-1$\n+\tpublic static final String KEY_SOCKET_FACTORY = \"com.sun.jndi.rmi.factory.socket\"; \/\/$NON-NLS-1$\n@@ -108,0 +109,1 @@\n+\tprivate static final AtomicInteger CONNECTION_COUNTER = new AtomicInteger(0);\n@@ -111,1 +113,0 @@\n-\n@@ -113,0 +114,1 @@\n+\tprivate final int m_connectionId = CONNECTION_COUNTER.getAndIncrement();\n@@ -219,3 +221,1 @@\n-\t\t\t\tm_server.dispose();\n-\t\t\t\ttryRemovingListener();\n-\t\t\t\tclearCollections();\n+\t\t\t\tMCMBeanServerConnection tmpServer = m_server;\n@@ -223,0 +223,3 @@\n+\t\t\t\ttryRemovingListener(tmpServer);\n+\t\t\t\ttmpServer.dispose();\n+\t\t\t\tclearCollections();\n@@ -244,1 +247,1 @@\n-\tprivate void tryRemovingListener() {\n+\tprivate void tryRemovingListener(MCMBeanServerConnection tmpServer) {\n@@ -246,1 +249,3 @@\n-\t\t\tensureConnected().removeNotificationListener(MBeanServerDelegate.DELEGATE_NAME, m_registrationListener);\n+\t\t\tif (tmpServer != null) {\n+\t\t\t\ttmpServer.removeNotificationListener(MBeanServerDelegate.DELEGATE_NAME, m_registrationListener);\n+\t\t\t}\n@@ -273,0 +278,153 @@\n+\t@Override\n+\tpublic HashMap<ObjectName, MBeanInfo> getMBeanInfos() throws IOException {\n+\t\tsynchronized (m_cachedInfos) {\n+\t\t\tinitializeMBeanInfos();\n+\t\t\treturn new HashMap<>(m_cachedInfos);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic MBeanInfo getMBeanInfo(ObjectName mbean)\n+\t\t\tthrows InstanceNotFoundException, IntrospectionException, ReflectionException, IOException {\n+\t\tsynchronized (m_cachedInfos) {\n+\t\t\tMBeanInfo mbeanInfo = m_cachedInfos.get(mbean);\n+\t\t\tif (mbeanInfo == null) {\n+\t\t\t\tMBeanServerConnection server = ensureConnected();\n+\t\t\t\tmbeanInfo = server.getMBeanInfo(mbean);\n+\t\t\t\tif (mbeanInfo != null) {\n+\t\t\t\t\tm_cachedInfos.put(mbean, mbeanInfo);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn mbeanInfo;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic Object getAttributeValue(MRI attribute) throws AttributeNotFoundException, MBeanException, IOException,\n+\t\t\tInstanceNotFoundException, ReflectionException {\n+\t\ttry {\n+\t\t\tMBeanServerConnection server = ensureConnected();\n+\t\t\treturn AttributeValueToolkit.getAttribute(server, attribute);\n+\t\t} catch (JMRuntimeException e) {\n+\t\t\tthrow new MBeanException(e, e.getMessage());\n+\t\t}\n+\t}\n+\n+\tpublic boolean connect() throws ConnectionException {\n+\t\tJVMDescriptor jvmInfo = getServerDescriptor().getJvmInfo();\n+\t\tif (jvmInfo != null && jvmInfo.getJavaVersion() != null\n+\t\t\t\t&& !new JavaVersion(jvmInfo.getJavaVersion()).isGreaterOrEqualThan(JavaVersionSupport.JDK_6)) {\n+\t\t\tthrow new ConnectionException(\"Too low JDK Version. JDK 1.6 or higher is supported.\"); \/\/$NON-NLS-1$\n+\t\t}\n+\t\tsynchronized (connectionStateLock) {\n+\t\t\tif (isConnected()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tJMXServiceURL url;\n+\t\t\ttry {\n+\t\t\t\turl = m_connectionDescriptor.createJMXServiceURL();\n+\t\t\t} catch (IOException e1) {\n+\t\t\t\tthrow new WrappedConnectionException(m_serverDescriptor.getDisplayName(), null, e1);\n+\t\t\t}\n+\n+\t\t\ttry {\n+\t\t\t\t\/\/ Use same convention as Sun. localhost:0 means \"VM, monitor thyself!\"\n+\t\t\t\tString hostName = ConnectionToolkit.getHostName(url);\n+\t\t\t\tif (hostName != null && (hostName.equals(\"localhost\")) \/\/$NON-NLS-1$\n+\t\t\t\t\t\t&& ConnectionToolkit.getPort(url) == 0) {\n+\t\t\t\t\tm_server = new MCMBeanServerConnection(ManagementFactory.getPlatformMBeanServer());\n+\t\t\t\t} else {\n+\t\t\t\t\testablishConnection(url, m_connectionDescriptor.getEnvironment());\n+\t\t\t\t}\n+\t\t\t\ttryToAddMBeanNotificationListener();\n+\t\t\t\tm_remoteStartTime = fetchServerStartTime();\n+\t\t\t\treturn true;\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tm_server = null;\n+\t\t\t\tthrow new WrappedConnectionException(m_serverDescriptor.getDisplayName(), url, e);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic long getApproximateServerTime(long localTime) {\n+\t\tlong startTime = System.currentTimeMillis();\n+\t\tif ((startTime - m_lastRecalibration) > VALUE_RECALIBRATION_INTERVAL\n+\t\t\t\t&& m_remoteStartTime != REMOTE_START_TIME_UNDEFINED) {\n+\t\t\ttry {\n+\t\t\t\t\/*\n+\t\t\t\t * FIXME: JMC-4270 - Server time approximation is not reliable. Since JDK-6523160,\n+\t\t\t\t * getUptime can no longer be used to derive the current server time. Find some\n+\t\t\t\t * other way to do this.\n+\t\t\t\t *\/\n+\t\t\t\tlong uptime = ConnectionToolkit.getRuntimeBean(ensureConnected()).getUptime();\n+\t\t\t\tlong returnTime = System.currentTimeMillis();\n+\t\t\t\tlong localTimeEstimate = (startTime + returnTime) \/ 2;\n+\t\t\t\tm_serverOffset = m_remoteStartTime + uptime - localTimeEstimate;\n+\t\t\t\tm_lastRecalibration = returnTime;\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tRJMXPlugin.getDefault().getLogger().log(Level.SEVERE, \"Could not recalibrate server offset\", e); \/\/$NON-NLS-1$\n+\t\t\t}\n+\t\t}\n+\t\treturn localTime + m_serverOffset;\n+\t}\n+\n+\tpublic void clearCache() {\n+\t\tsynchronized (m_cachedInfos) {\n+\t\t\tm_cachedInfos.clear();\n+\t\t\tm_cachedMBeanNames.clear();\n+\t\t\tm_hasInitializedAllMBeans = false;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"RJMX Connection \" + m_connectionId + \": \" + m_serverDescriptor.getDisplayName(); \/\/$NON-NLS-1$\n+\t}\n+\n+\t@Override\n+\tpublic void removeMBeanServerChangeListener(IMBeanServerChangeListener listener) {\n+\t\tm_mbeanListeners.remove(listener);\n+\t}\n+\n+\t@Override\n+\tpublic void addMBeanServerChangeListener(IMBeanServerChangeListener listener) {\n+\t\tm_mbeanListeners.add(listener);\n+\t}\n+\n+\t@Override\n+\tpublic Map<MRI, Map<String, Object>> getMBeanMetadata(ObjectName mbean) {\n+\t\treturn m_mbeanDataProvider.getMBeanData(mbean);\n+\t}\n+\n+\t\/**\n+\t * Returns the IOperations available for the specified MBean.\n+\t *\n+\t * @param mbean\n+\t *            the MBean for which to return the information.\n+\t * @return the operations that can be invoked on this mbean.\n+\t * @throws Exception\n+\t *             if the connection failed or some other problem occurred when trying create\n+\t *             operations.\n+\t *\/\n+\tpublic Collection<IOperation> getOperations(ObjectName mbean) throws Exception {\n+\t\tMBeanServerConnection connection = ensureConnected();\n+\t\treturn MBeanOperationWrapper.createOperations(connection, mbean,\n+\t\t\t\tconnection.getMBeanInfo(mbean).getOperations());\n+\t}\n+\n+\tIMRIService getMRIService() {\n+\t\treturn m_mbeanDataProvider;\n+\t}\n+\n+\t\/**\n+\t * Returns the MBeanServerConnection. Yes, this breaks abstraction a bit, and should only be\n+\t * used by the MBeanBrowser. Everybody else should be using subscriptions anyway.\n+\t *\n+\t * @return the MBeanServerConnection currently in use by this connection. May be null if none is\n+\t *         currently in use.\n+\t *\/\n+\tMBeanServerConnection getMBeanServer() {\n+\t\treturn m_server;\n+\t}\n+\n@@ -375,71 +533,0 @@\n-\t@Override\n-\tpublic HashMap<ObjectName, MBeanInfo> getMBeanInfos() throws IOException {\n-\t\tsynchronized (m_cachedInfos) {\n-\t\t\tinitializeMBeanInfos();\n-\t\t\treturn new HashMap<>(m_cachedInfos);\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic MBeanInfo getMBeanInfo(ObjectName mbean)\n-\t\t\tthrows InstanceNotFoundException, IntrospectionException, ReflectionException, IOException {\n-\t\tsynchronized (m_cachedInfos) {\n-\t\t\tMBeanInfo mbeanInfo = m_cachedInfos.get(mbean);\n-\t\t\tif (mbeanInfo == null) {\n-\t\t\t\tMBeanServerConnection server = ensureConnected();\n-\t\t\t\tmbeanInfo = server.getMBeanInfo(mbean);\n-\t\t\t\tif (mbeanInfo != null) {\n-\t\t\t\t\tm_cachedInfos.put(mbean, mbeanInfo);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\treturn mbeanInfo;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic Object getAttributeValue(MRI attribute) throws AttributeNotFoundException, MBeanException, IOException,\n-\t\t\tInstanceNotFoundException, ReflectionException {\n-\t\ttry {\n-\t\t\tMBeanServerConnection server = ensureConnected();\n-\t\t\treturn AttributeValueToolkit.getAttribute(server, attribute);\n-\t\t} catch (JMRuntimeException e) {\n-\t\t\tthrow new MBeanException(e, e.getMessage());\n-\t\t}\n-\t}\n-\n-\tpublic boolean connect() throws ConnectionException {\n-\t\tJVMDescriptor jvmInfo = getServerDescriptor().getJvmInfo();\n-\t\tif (jvmInfo != null && jvmInfo.getJavaVersion() != null\n-\t\t\t\t&& !new JavaVersion(jvmInfo.getJavaVersion()).isGreaterOrEqualThan(JavaVersionSupport.JDK_6)) {\n-\t\t\tthrow new ConnectionException(\"Too low JDK Version. JDK 1.6 or higher is supported.\"); \/\/$NON-NLS-1$\n-\t\t}\n-\t\tsynchronized (connectionStateLock) {\n-\t\t\tif (isConnected()) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tJMXServiceURL url;\n-\t\t\ttry {\n-\t\t\t\turl = m_connectionDescriptor.createJMXServiceURL();\n-\t\t\t} catch (IOException e1) {\n-\t\t\t\tthrow new WrappedConnectionException(m_serverDescriptor.getDisplayName(), null, e1);\n-\t\t\t}\n-\n-\t\t\ttry {\n-\t\t\t\t\/\/ Use same convention as Sun. localhost:0 means \"VM, monitor thyself!\"\n-\t\t\t\tString hostName = ConnectionToolkit.getHostName(url);\n-\t\t\t\tif (hostName != null && (hostName.equals(\"localhost\")) \/\/$NON-NLS-1$\n-\t\t\t\t\t\t&& ConnectionToolkit.getPort(url) == 0) {\n-\t\t\t\t\tm_server = new MCMBeanServerConnection(ManagementFactory.getPlatformMBeanServer());\n-\t\t\t\t} else {\n-\t\t\t\t\testablishConnection(url, m_connectionDescriptor.getEnvironment());\n-\t\t\t\t}\n-\t\t\t\ttryToAddMBeanNotificationListener();\n-\t\t\t\tm_remoteStartTime = fetchServerStartTime();\n-\t\t\t\treturn true;\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tm_server = null;\n-\t\t\t\tthrow new WrappedConnectionException(m_serverDescriptor.getDisplayName(), url, e);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n@@ -490,34 +577,0 @@\n-\t@Override\n-\tpublic long getApproximateServerTime(long localTime) {\n-\t\tlong startTime = System.currentTimeMillis();\n-\t\tif ((startTime - m_lastRecalibration) > VALUE_RECALIBRATION_INTERVAL\n-\t\t\t\t&& m_remoteStartTime != REMOTE_START_TIME_UNDEFINED) {\n-\t\t\ttry {\n-\t\t\t\t\/*\n-\t\t\t\t * FIXME: JMC-4270 - Server time approximation is not reliable. Since JDK-6523160,\n-\t\t\t\t * getUptime can no longer be used to derive the current server time. Find some\n-\t\t\t\t * other way to do this.\n-\t\t\t\t *\/\n-\t\t\t\tlong uptime = ConnectionToolkit.getRuntimeBean(ensureConnected()).getUptime();\n-\t\t\t\tlong returnTime = System.currentTimeMillis();\n-\t\t\t\tlong localTimeEstimate = (startTime + returnTime) \/ 2;\n-\t\t\t\tm_serverOffset = m_remoteStartTime + uptime - localTimeEstimate;\n-\t\t\t\tm_lastRecalibration = returnTime;\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tRJMXPlugin.getDefault().getLogger().log(Level.SEVERE, \"Could not recalibrate server offset\", e); \/\/$NON-NLS-1$\n-\t\t\t}\n-\t\t}\n-\t\treturn localTime + m_serverOffset;\n-\t}\n-\n-\t\/**\n-\t * Returns the MBeanServerConnection. Yes, this breaks abstraction a bit, and should only be\n-\t * used by the MBeanBrowser. Everybody else should be using subscriptions anyway.\n-\t *\n-\t * @return the MBeanServerConnection currently in use by this connection. May be null if none is\n-\t *         currently in use.\n-\t *\/\n-\tMBeanServerConnection getMBeanServer() {\n-\t\treturn m_server;\n-\t}\n-\n@@ -540,48 +593,0 @@\n-\tpublic void clearCache() {\n-\t\tsynchronized (m_cachedInfos) {\n-\t\t\tm_cachedInfos.clear();\n-\t\t\tm_cachedMBeanNames.clear();\n-\t\t\tm_hasInitializedAllMBeans = false;\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tpublic String toString() {\n-\t\treturn \"RJMX Connection: \" + m_serverDescriptor.getDisplayName(); \/\/$NON-NLS-1$\n-\t}\n-\n-\t@Override\n-\tpublic void removeMBeanServerChangeListener(IMBeanServerChangeListener listener) {\n-\t\tm_mbeanListeners.remove(listener);\n-\t}\n-\n-\t@Override\n-\tpublic void addMBeanServerChangeListener(IMBeanServerChangeListener listener) {\n-\t\tm_mbeanListeners.add(listener);\n-\t}\n-\n-\t@Override\n-\tpublic Map<MRI, Map<String, Object>> getMBeanMetadata(ObjectName mbean) {\n-\t\treturn m_mbeanDataProvider.getMBeanData(mbean);\n-\t}\n-\n-\t\/**\n-\t * Returns the IOperations available for the specified MBean.\n-\t *\n-\t * @param mbean\n-\t *            the MBean for which to return the information.\n-\t * @return the operations that can be invoked on this mbean.\n-\t * @throws Exception\n-\t *             if the connection failed or some other problem occurred when trying create\n-\t *             operations.\n-\t *\/\n-\tpublic Collection<IOperation> getOperations(ObjectName mbean) throws Exception {\n-\t\tMBeanServerConnection connection = ensureConnected();\n-\t\treturn MBeanOperationWrapper.createOperations(connection, mbean,\n-\t\t\t\tconnection.getMBeanInfo(mbean).getOperations());\n-\t}\n-\n-\tIMRIService getMRIService() {\n-\t\treturn m_mbeanDataProvider;\n-\t}\n-\n","filename":"application\/org.openjdk.jmc.rjmx\/src\/main\/java\/org\/openjdk\/jmc\/rjmx\/internal\/RJMXConnection.java","additions":165,"deletions":160,"binary":false,"changes":325,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import javax.security.auth.login.FailedLoginException;\n@@ -49,0 +48,1 @@\n+import org.openjdk.jmc.common.io.IOToolkit;\n@@ -100,0 +100,1 @@\n+\tprotected RJMXConnection m_connection;\n@@ -190,0 +191,2 @@\n+\t\t} finally {\n+\t\t\tIOToolkit.closeSilently(rjmxConnection);\n@@ -196,0 +199,2 @@\n+\t\tIConnectionHandle handle = null;\n+\t\tRJMXConnection connection = null;\n@@ -198,1 +203,3 @@\n-\t\t\tIConnectionHandle handle = createConnectionHandle(descriptor);\n+\t\t\tconnection = new RJMXConnection(descriptor, createDefaultServerDesciptor(descriptor), null);\n+\t\t\tconnection.connect();\n+\t\t\thandle = new DefaultConnectionHandle(connection, \"Test\", null);\n@@ -209,0 +216,2 @@\n+\t\t\tIOToolkit.closeSilently(handle);\n+\t\t\tIOToolkit.closeSilently(connection);\n@@ -262,1 +271,2 @@\n-\t\tIConnectionHandle connectionHandle = createConnectionHandle(connDesc);\n+\t\tRJMXConnection connection = new RJMXConnection(connDesc, createDefaultServerDesciptor(connDesc), null);\n+\t\tIConnectionHandle connectionHandle =  new DefaultConnectionHandle(connection, \"Get Properties\", null);\n@@ -265,1 +275,2 @@\n-\t\tconnectionHandle.close();\n+\t\tIOToolkit.closeSilently(connectionHandle);\n+\t\tIOToolkit.closeSilently(connection);\n@@ -275,1 +286,3 @@\n-\t\tm_connectionHandle = createConnectionHandle(m_connectionDescriptor);\n+\t\tm_connection = new RJMXConnection(m_connectionDescriptor, createDefaultServerDesciptor(m_connectionDescriptor), null);\n+\t\tm_connection.connect();\n+\t\tm_connectionHandle = new DefaultConnectionHandle(m_connection, \"Test\", null);\n@@ -279,15 +292,0 @@\n-\t\/**\n-\t * Quick'n'Dirty way to create a {@link IConnectionHandle}. Will have a server descriptor\n-\t * matching the connection.\n-\t *\n-\t * @return an {@link IConnectionHandle}\n-\t * @throws FailedLoginException\n-\t * @throws ConnectionException\n-\t *\/\n-\tprivate static IConnectionHandle createConnectionHandle(IConnectionDescriptor descriptor)\n-\t\t\tthrows IOException, FailedLoginException, ConnectionException {\n-\t\tRJMXConnection connection = new RJMXConnection(descriptor, createDefaultServerDesciptor(descriptor), null);\n-\t\tconnection.connect();\n-\t\treturn new DefaultConnectionHandle(connection, \"Test\", null);\n-\t}\n-\n@@ -302,0 +300,4 @@\n+\t\t\tif (m_connection != null) {\n+\t\t\t\tm_connection.close();\n+\t\t\t\tm_connection = null;\n+\t\t\t}\n","filename":"application\/tests\/org.openjdk.jmc.rjmx.test\/src\/test\/java\/org\/openjdk\/jmc\/rjmx\/test\/RjmxTestCase.java","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -35,2 +35,5 @@\n-import java.util.Timer;\n-import java.util.TimerTask;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -45,1 +48,8 @@\n-\tprivate Timer timer;\n+\tprivate final static AtomicInteger THREAD_ID_PROVIDER = new AtomicInteger(0);\n+\tprivate final int notificationId = THREAD_ID_PROVIDER.getAndIncrement();\n+\tprivate final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {\n+\t\t@Override\n+\t\tpublic Thread newThread(Runnable r) {\n+\t\t\treturn new Thread(r, \"TestNotification Executor \" + notificationId);\n+\t\t}\n+\t});\n@@ -56,2 +66,1 @@\n-\t\ttimer = new Timer(getMessage(), true);\n-\t\ttimer.schedule(new TimerTask() {\n+\t\texecutor.scheduleAtFixedRate(new Runnable() {\n@@ -62,1 +71,1 @@\n-\t\t}, 0, 1000);\n+\t\t}, 5, 100, TimeUnit.MILLISECONDS);\n@@ -67,1 +76,1 @@\n-\t\ttimer.cancel();\n+\t\texecutor.shutdownNow();\n@@ -79,0 +88,5 @@\n+\t\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"TestNotification \" + notificationId + \" - \" + getMessage();\n+\t}\n","filename":"application\/tests\/org.openjdk.jmc.rjmx.test\/src\/test\/java\/org\/openjdk\/jmc\/rjmx\/test\/synthetic\/TestNotification.java","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"}]}