{"files":[{"patch":"@@ -133,2 +133,1 @@\n-\t\treturn registerType(typeName, supertype, true,\n-\t\t\t\ttypeStructureProvider != null ? typeStructureProvider.get() : TypeStructureImpl.EMPTY);\n+\t\treturn registerType(typeName, supertype, true, typeStructureProvider);\n@@ -153,2 +152,27 @@\n-\t\treturn registerType(typeName, supertype, withConstantPool,\n-\t\t\t\ttypeStructureProvider != null ? typeStructureProvider.get() : TypeStructureImpl.EMPTY);\n+\t\t\/*\n+\t\t * This needs to be slightly more involved than just calling 'computeIfAbsent' because the\n+\t\t * actual computation may (and will) call 'registerType' recursively which will make the\n+\t\t * next call to 'computeIfAbsent' to fail.\n+\t\t *\n+\t\t * The solution is a multi-step registration while still maintaining the atomicity of the\n+\t\t * updates.\n+\t\t * @formatter:off\n+\t\t * 1. Put atomically an unresolved resolvable instance as a placeholder if the map doesn't\n+\t\t * contain the resolved type yet\n+\t\t * 2. Build the type structure (which might involve calling registerType recursively)\n+\t\t * 3. Materialize the type\n+\t\t * 4. Replace the resolvable placeholder with the actual type in the type metadata map\n+\t\t * 5. Resolve the resolvable type so any other types linking to it will have access to the real type\n+\t\t * @formatter:on\n+\t\t *\/\n+\t\tTypeImpl registered = metadata.computeIfAbsent(typeName, k -> new ResolvableType(k, this));\n+\t\tif (!registered.isResolved()) {\n+\t\t\tTypeStructureImpl structure = typeStructureProvider != null ? typeStructureProvider.get()\n+\t\t\t\t\t: TypeStructureImpl.EMPTY;\n+\t\t\tTypeImpl concreteType = createCustomType(typeName, supertype, structure, withConstantPool);\n+\t\t\tstoreTypeStrings(concreteType);\n+\t\t\tmetadata.replace(typeName, registered, concreteType);\n+\t\t\t((ResolvableType) registered).resolve();\n+\t\t\tregistered = concreteType;\n+\t\t}\n+\t\treturn registered;\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/MetadataImpl.java","additions":28,"deletions":4,"binary":false,"changes":32,"status":"modified"}]}