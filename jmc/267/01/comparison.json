{"files":[{"patch":"@@ -58,0 +58,1 @@\n+import org.openjdk.jmc.common.IMCFrame;\n@@ -220,5 +221,4 @@\n-\t\t\tList<IColumn> columns = new ArrayList<>();\n-\t\t\tIMemberAccessor<?, Object> keyAccessor = AggregationGrid::getKey;\n-\t\t\tColumnLabelProvider keyLp = null;\n-\t\t\tif (UnitLookup.METHOD.getIdentifier().equals(keyType.getIdentifier())) {\n-\t\t\t\tkeyLp = new DelegatingLabelProvider(new MethodLabelProvider(), keyAccessor);\n+\t\t\tColumnLabelProvider lp = null;\n+\t\t\tif (UnitLookup.METHOD.getIdentifier().equals(keyType.getIdentifier())\n+\t\t\t\t\t|| UnitLookup.STACKTRACE_FRAME.getIdentifier().equals(keyType.getIdentifier())) {\n+\t\t\t\tlp = new MethodLabelProvider();\n@@ -226,1 +226,1 @@\n-\t\t\t\tkeyLp = new DelegatingLabelProvider(new KeyLabelProvider(keyType), keyAccessor);\n+\t\t\t\tlp = new KeyLabelProvider(keyType);\n@@ -228,0 +228,9 @@\n+\t\t\treturn build(container, colLabel, keyType, classifier, tableSettings, border, lp);\n+\t\t}\n+\n+\t\tpublic <T> ItemHistogram build(\n+\t\t\tComposite container, String colLabel, ContentType<? super T> keyType, IAccessorFactory<T> classifier,\n+\t\t\tTableSettings tableSettings, int border, ColumnLabelProvider labelProvider) {\n+\t\t\tList<IColumn> columns = new ArrayList<>();\n+\t\t\tIMemberAccessor<?, Object> keyAccessor = AggregationGrid::getKey;\n+\t\t\tColumnLabelProvider keyLp = new DelegatingLabelProvider(labelProvider, keyAccessor);\n@@ -246,0 +255,12 @@\n+\t\tpublic <T> ItemHistogram buildWithoutBorder(\n+\t\t\tComposite container, String colLabel, ContentType<? super T> keyType, IAccessorFactory<T> classifier,\n+\t\t\tTableSettings tableSettings, ColumnLabelProvider labelProvider) {\n+\t\t\treturn build(container, colLabel, keyType, classifier, tableSettings, SWT.NONE, labelProvider);\n+\t\t}\n+\n+\t\tpublic <T> ItemHistogram buildWithoutBorder(\n+\t\t\tComposite container, IAttribute<T> classifier, TableSettings tableSettings,\n+\t\t\tColumnLabelProvider labelProvider) {\n+\t\t\treturn build(container, classifier.getName(), classifier.getContentType(), classifier, tableSettings,\n+\t\t\t\t\tSWT.NONE, labelProvider);\n+\t\t}\n@@ -382,0 +403,1 @@\n+\t\t\tIMCMethod method = null;\n@@ -383,1 +405,5 @@\n-\t\t\t\tIMCMethod method = (IMCMethod) key;\n+\t\t\t\tmethod = (IMCMethod) key;\n+\t\t\t} else if (key instanceof IMCFrame) {\n+\t\t\t\tmethod = ((IMCFrame) key).getMethod();\n+\t\t\t}\n+\t\t\tif (method != null) {\n@@ -398,0 +424,3 @@\n+\t\t\tif (key instanceof IMCFrame) {\n+\t\t\t\tkey = ((IMCFrame) key).getMethod();\n+\t\t\t}\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/common\/ItemHistogram.java","additions":36,"deletions":7,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -360,0 +360,3 @@\n+\tpublic static String MethodProfilingPage_METHOD_CONTENT_TYPE_DESCRIPTION;\n+\tpublic static String MethodProfilingPage_METHOD_DESCRIPTION;\n+\tpublic static String MethodProfilingPage_METHOD_TITLE;\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/messages\/internal\/Messages.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+import org.openjdk.jmc.common.item.Attribute;\n+import org.openjdk.jmc.common.item.IAttribute;\n@@ -74,0 +76,1 @@\n+import org.openjdk.jmc.common.item.IType;\n@@ -76,0 +79,1 @@\n+import org.openjdk.jmc.common.unit.ContentType;\n@@ -111,0 +115,2 @@\n+import org.openjdk.jmc.flightrecorder.ui.pages.internal.MethodWithFrameType;\n+import org.openjdk.jmc.flightrecorder.ui.pages.internal.MethodWithFrameTypeLabelProvider;\n@@ -131,0 +137,17 @@\n+\t\/\/ Same as STACK_TRACE_TOP_METHOD but includes information about the frame type for the sample (and will distinguish methods on this)\n+\tprivate static final IAttribute<MethodWithFrameType> STACK_TRACE_TOP_METHOD_WITH_FRAME_TYPE = new Attribute<MethodWithFrameType>(\n+\t\t\t\"(stackTrace).topMethodOptimization\", Messages.MethodProfilingPage_METHOD_TITLE, \/\/$NON-NLS-1$\n+\t\t\tMessages.MethodProfilingPage_METHOD_DESCRIPTION, new ContentType<MethodWithFrameType>(\"methodwithframetype\", \/\/$NON-NLS-1$\n+\t\t\t\t\tMessages.MethodProfilingPage_METHOD_CONTENT_TYPE_DESCRIPTION)) {\n+\t\t@Override\n+\t\tpublic <U> IMemberAccessor<MethodWithFrameType, U> customAccessor(IType<U> type) {\n+\t\t\tfinal IMemberAccessor<IMCFrame, U> accessor = JdkAttributes.STACK_TRACE_TOP_FRAME.getAccessor(type);\n+\t\t\treturn accessor == null ? null : new IMemberAccessor<MethodWithFrameType, U>() {\n+\t\t\t\t@Override\n+\t\t\t\tpublic MethodWithFrameType getMember(U i) {\n+\t\t\t\t\tIMCFrame frame = accessor.getMember(i);\n+\t\t\t\t\treturn frame == null ? null : new MethodWithFrameType(frame.getMethod(), frame.getType());\n+\t\t\t\t}\n+\t\t\t};\n+\t\t}\n+\t};\n@@ -231,2 +254,2 @@\n-\t\t\ttable = HOT_METHODS_HISTOGRAM.buildWithoutBorder(sash, JdkAttributes.STACK_TRACE_TOP_METHOD,\n-\t\t\t\t\tgetTableSettings(state.getChild(TABLE_ELEMENT)));\n+\t\t\ttable = HOT_METHODS_HISTOGRAM.buildWithoutBorder(sash, STACK_TRACE_TOP_METHOD_WITH_FRAME_TYPE,\n+\t\t\t\t\tgetTableSettings(state.getChild(TABLE_ELEMENT)), new MethodWithFrameTypeLabelProvider());\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/pages\/MethodProfilingPage.java","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.ui.pages.internal;\n+\n+import org.openjdk.jmc.common.IMCFrame;\n+import org.openjdk.jmc.common.IMCMethod;\n+\n+\/**\n+ * Simple wrapper type that captures an {@link IMCMethod} and the {@link Type} it had for the\n+ * sample.\n+ *\/\n+public class MethodWithFrameType {\n+\tprivate final IMCMethod method;\n+\tprivate final IMCFrame.Type frameType;\n+\n+\tpublic MethodWithFrameType(IMCMethod method, IMCFrame.Type frameType) {\n+\t\tthis.method = method;\n+\t\tthis.frameType = frameType;\n+\t}\n+\n+\tpublic IMCMethod getMethod() {\n+\t\treturn method;\n+\t}\n+\n+\tpublic IMCFrame.Type getFrameType() {\n+\t\treturn frameType;\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tfinal int prime = 31;\n+\t\tint result = 1;\n+\t\tresult = prime * result + ((frameType == null) ? 0 : frameType.hashCode());\n+\t\tresult = prime * result + ((method == null) ? 0 : method.hashCode());\n+\t\treturn result;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tMethodWithFrameType other = (MethodWithFrameType) obj;\n+\t\tif (frameType != other.frameType)\n+\t\t\treturn false;\n+\t\tif (method == null) {\n+\t\t\tif (other.method != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!method.equals(other.method))\n+\t\t\treturn false;\n+\t\treturn true;\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/pages\/internal\/MethodWithFrameType.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.ui.pages.internal;\n+\n+import java.lang.reflect.Modifier;\n+\n+import org.eclipse.jface.resource.JFaceResources;\n+import org.eclipse.jface.viewers.ColumnLabelProvider;\n+import org.eclipse.swt.graphics.Font;\n+import org.eclipse.swt.graphics.Image;\n+import org.openjdk.jmc.common.IDisplayable;\n+import org.openjdk.jmc.common.IMCFrame;\n+import org.openjdk.jmc.common.IMCFrame.Type;\n+import org.openjdk.jmc.common.IMCMethod;\n+import org.openjdk.jmc.common.util.FormatToolkit;\n+import org.openjdk.jmc.common.util.TypeHandling;\n+import org.openjdk.jmc.flightrecorder.ui.common.ItemHistogram;\n+import org.openjdk.jmc.ui.CoreImages;\n+import org.openjdk.jmc.ui.misc.OverlayImageDescriptor;\n+\n+\/**\n+ * This label provider will render {@link MethodWithFrameType} objects. It can also be used for\n+ * {@link IMCMethod} and {@link IMCFrame}. It is similar to how {@link IMCMethod}'s will be rendered\n+ * by default in {@link ItemHistogram}, but with an additional overlay version of the images. The\n+ * overlay (a little flash) will be used if the method {@link IMCFrame.Type} is not\n+ * {@link Type#INTERPRETED}.\n+ *\/\n+public class MethodWithFrameTypeLabelProvider extends ColumnLabelProvider {\n+\t\/\/ The default fallback image\n+\tprivate final Image nonoptimizedMethodImage;\n+\n+\t\/\/ Images for various modifiers\n+\tprivate final Image defaultMethodImage;\n+\tprivate final Image publicMethodImage;\n+\tprivate final Image protectedMethodImage;\n+\tprivate final Image privateMethodImage;\n+\n+\t\/\/ Non-interpreted frame type versions\n+\tprivate final Image defaultJitMethodImage;\n+\tprivate final Image publicJitMethodImage;\n+\tprivate final Image protectedJitMethodImage;\n+\tprivate final Image privateJitMethodImage;\n+\n+\tpublic MethodWithFrameTypeLabelProvider() {\n+\t\tnonoptimizedMethodImage = CoreImages.METHOD_NON_OPTIMIZED.createImage();\n+\n+\t\tdefaultMethodImage = CoreImages.METHOD_DEFAULT.createImage();\n+\t\tpublicMethodImage = CoreImages.METHOD_PUBLIC.createImage();\n+\t\tprotectedMethodImage = CoreImages.METHOD_PROTECTED.createImage();\n+\t\tprivateMethodImage = CoreImages.METHOD_PRIVATE.createImage();\n+\n+\t\t\/\/ Construct the versions of the images for the \"non-interpreted\" methods (normally JITed)\n+\t\tdefaultJitMethodImage = new OverlayImageDescriptor(CoreImages.METHOD_DEFAULT, false,\n+\t\t\t\tCoreImages.METHOD_JITOVERLAY).createImage();\n+\t\tpublicJitMethodImage = new OverlayImageDescriptor(CoreImages.METHOD_PUBLIC, false, CoreImages.METHOD_JITOVERLAY)\n+\t\t\t\t.createImage();\n+\t\tprotectedJitMethodImage = new OverlayImageDescriptor(CoreImages.METHOD_PROTECTED, false,\n+\t\t\t\tCoreImages.METHOD_JITOVERLAY).createImage();\n+\t\tprivateJitMethodImage = new OverlayImageDescriptor(CoreImages.METHOD_PRIVATE, false,\n+\t\t\t\tCoreImages.METHOD_JITOVERLAY).createImage();\n+\t}\n+\n+\t@Override\n+\tpublic Font getFont(Object key) {\n+\t\treturn JFaceResources.getFontRegistry().getBold(JFaceResources.DEFAULT_FONT);\n+\t}\n+\n+\t@Override\n+\tpublic Image getImage(Object key) {\n+\t\tif (key instanceof MethodWithFrameType) {\n+\t\t\tMethodWithFrameType mwft = (MethodWithFrameType) key;\n+\t\t\tIMCMethod method = mwft.getMethod();\n+\t\t\tif (key instanceof IMCMethod) {\n+\t\t\t\tmethod = (IMCMethod) key;\n+\t\t\t} else if (key instanceof IMCFrame) {\n+\t\t\t\tmethod = ((IMCFrame) key).getMethod();\n+\t\t\t}\n+\t\t\tif (method != null) {\n+\t\t\t\tif ((method.getModifier() & Modifier.PUBLIC) != 0) {\n+\t\t\t\t\treturn mwft.getFrameType() != Type.INTERPRETED ? publicJitMethodImage : publicMethodImage;\n+\t\t\t\t} else if ((method.getModifier() & Modifier.PROTECTED) != 0) {\n+\t\t\t\t\treturn mwft.getFrameType() != Type.INTERPRETED ? protectedJitMethodImage : protectedMethodImage;\n+\t\t\t\t} else if ((method.getModifier() & Modifier.PRIVATE) != 0) {\n+\t\t\t\t\treturn mwft.getFrameType() != Type.INTERPRETED ? privateJitMethodImage : privateMethodImage;\n+\t\t\t\t}\n+\t\t\t\treturn mwft.getFrameType() != Type.INTERPRETED ? defaultJitMethodImage : defaultMethodImage;\n+\t\t\t}\n+\t\t\treturn nonoptimizedMethodImage;\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic String getText(Object key) {\n+\t\tif (key instanceof MethodWithFrameType) {\n+\t\t\tMethodWithFrameType mwft = (MethodWithFrameType) key;\n+\t\t\tkey = mwft.getMethod();\n+\t\t} else if (key instanceof IMCFrame) {\n+\t\t\tkey = ((IMCFrame) key).getMethod();\n+\t\t}\n+\t\tif (key instanceof IDisplayable) {\n+\t\t\treturn ((IDisplayable) key).displayUsing(IDisplayable.EXACT);\n+\t\t}\n+\t\t\/\/ IMCMethod falling through to TypeHandling\n+\t\treturn TypeHandling.getValueString(key);\n+\t};\n+\n+\t@Override\n+\tpublic String getToolTipText(Object key) {\n+\t\tif (key == null) {\n+\t\t\treturn \"null\";\n+\t\t}\n+\t\tIMCMethod method = null;\n+\t\tIMCFrame.Type frameType = null;\n+\t\tif (key instanceof MethodWithFrameType) {\n+\t\t\tMethodWithFrameType mwft = (MethodWithFrameType) key;\n+\t\t\tmethod = mwft.getMethod();\n+\t\t\tframeType = mwft.getFrameType();\n+\t\t} else if (key instanceof IMCFrame) {\n+\t\t\tIMCFrame frame = (IMCFrame) key;\n+\t\t\tmethod = ((IMCFrame) key).getMethod();\n+\t\t\tframeType = frame.getType();\n+\t\t} else if (key instanceof IMCMethod) {\n+\t\t\tmethod = (IMCMethod) key;\n+\t\t}\n+\t\tif (method != null) {\n+\t\t\treturn FormatToolkit.getHumanReadable(method, true, false, true, true, true, false, true)\n+\t\t\t\t\t+ ((frameType != null) ? (\" [\" + frameType + \"]\") : \"\");\n+\t\t}\n+\t\tif (key instanceof IDisplayable) {\n+\t\t\treturn ((IDisplayable) key).displayUsing(IDisplayable.VERBOSE);\n+\t\t}\n+\t\treturn TypeHandling.getValueString(key);\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ui\/pages\/internal\/MethodWithFrameTypeLabelProvider.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -642,1 +642,1 @@\n-# {0} is a string describing the live object, it's customisable by the user but looks like a java type, {1} is a number\n+# {0} is a string describing the live object, it's customizable by the user but looks like a java type, {1} is a number\n@@ -645,0 +645,3 @@\n+MethodProfilingPage_METHOD_CONTENT_TYPE_DESCRIPTION=Method with frame type\n+MethodProfilingPage_METHOD_DESCRIPTION=Method (taking frame type into account, e.g. if the method is interpreted or not)\n+MethodProfilingPage_METHOD_TITLE=Method\n","filename":"application\/org.openjdk.jmc.flightrecorder.ui\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/ui\/messages\/internal\/messages.properties","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"filename":"application\/org.openjdk.jmc.ui\/icons\/method-jitoverlay.png","binary":true,"previous_filename":"application\/org.openjdk.jmc.ui\/icons\/method-public.png","status":"copied"},{"filename":"application\/org.openjdk.jmc.ui\/icons\/method-jitoverlay@2x.png","binary":true,"status":"added"},{"patch":"@@ -116,0 +116,1 @@\n+\tpublic static final ImageDescriptor METHOD_JITOVERLAY = icon(UIPlugin.ICON_METHOD_JITOVERLAY);\n","filename":"application\/org.openjdk.jmc.ui\/src\/main\/java\/org\/openjdk\/jmc\/ui\/CoreImages.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+\tpublic static final String ICON_METHOD_JITOVERLAY = \"method-jitoverlay.png\"; \/\/$NON-NLS-1$\n","filename":"application\/org.openjdk.jmc.ui\/src\/main\/java\/org\/openjdk\/jmc\/ui\/UIPlugin.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import java.lang.reflect.Modifier;\n+\n@@ -116,0 +118,52 @@\n+\t\/**\n+\t * Get a human readable string representing a method.\n+\t *\n+\t * @param method\n+\t *            the method to get a string for\n+\t * @param showReturnValue\n+\t *            {@code true} if the return value type should be included\n+\t * @param showReturnValuePackage\n+\t *            {@code true} if the package name of the return value type should be included. Only\n+\t *            relevant if {@code showReturnValue} is {@code true}.\n+\t * @param showClassName\n+\t *            {@code true} if the class name for the method should be included\n+\t * @param showClassPackageName\n+\t *            {@code true} if the package name of the class for the method should be included.\n+\t *            Only relevant if {@code showClassName} is {@code true}.\n+\t * @param showArguments\n+\t *            {@code true} if the class names for the method arguments should be included\n+\t * @param showArgumentsPackage\n+\t *            {@code true} if the package names of the classes for the method arguments should\n+\t *            be included. Only relevant if {@code showArguments} is {@code true}.\n+\t * @param showModifiers\n+\t *            {@code true} if the modifiers for the method should be included. Only relevant if\n+\t *            {@code showModifiers} is {@code true}.\n+\t * @return a human readable string representing the method\n+\t *\/\n+\tpublic static String getHumanReadable(\n+\t\tIMCMethod method, boolean showReturnValue, boolean showReturnValuePackage, boolean showClassName,\n+\t\tboolean showClassPackageName, boolean showArguments, boolean showArgumentsPackage, boolean showModifiers) {\n+\t\tString humanReadable = \"\";\n+\t\ttry {\n+\t\t\tif (showModifiers) {\n+\t\t\t\thumanReadable += getModifiers(method) + ' ';\n+\t\t\t}\n+\t\t\thumanReadable += getHumanReadable(method, showReturnValue, showReturnValuePackage, showClassName,\n+\t\t\t\t\tshowClassPackageName, showArguments, showArgumentsPackage);\n+\t\t} catch (Exception e) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn humanReadable;\n+\t}\n+\n+\t\/**\n+\t * Returns the modifiers for a method, as a human readable string.\n+\t *\n+\t * @param method\n+\t *            the methods to get the modifiers for.\n+\t * @return the modifiers for a method, as a human readable string.\n+\t *\/\n+\tprivate static String getModifiers(IMCMethod method) {\n+\t\treturn Modifier.toString(method.getModifier());\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/util\/FormatToolkit.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -139,1 +139,0 @@\n-\n@@ -156,1 +155,0 @@\n-\n@@ -173,1 +171,0 @@\n-\n@@ -189,1 +186,0 @@\n-\n@@ -250,1 +246,0 @@\n-\n@@ -271,1 +266,0 @@\n-\n@@ -304,1 +298,0 @@\n-\n@@ -321,1 +314,0 @@\n-\n@@ -325,1 +317,0 @@\n-\n@@ -412,1 +403,0 @@\n-\n@@ -612,1 +602,0 @@\n-\n@@ -615,1 +604,0 @@\n-\n@@ -640,1 +628,0 @@\n-\n@@ -673,1 +660,0 @@\n-\n@@ -680,1 +666,0 @@\n-\n@@ -693,1 +678,0 @@\n-\n@@ -700,1 +684,0 @@\n-\n@@ -731,1 +714,0 @@\n-\n@@ -735,1 +717,0 @@\n-\n@@ -742,1 +723,0 @@\n-\n@@ -765,1 +745,0 @@\n-\n@@ -785,1 +764,0 @@\n-\n@@ -792,1 +770,0 @@\n-\n@@ -923,1 +900,0 @@\n-\n@@ -939,1 +915,0 @@\n-\n@@ -960,1 +935,0 @@\n-\n@@ -996,1 +970,0 @@\n-\n@@ -1300,1 +1273,0 @@\n-\n@@ -1303,1 +1275,0 @@\n-\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkAttributes.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"}]}