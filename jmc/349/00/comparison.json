{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Datadog, Inc. All rights reserved.\n@@ -81,0 +81,1 @@\n+import org.openjdk.jmc.flightrecorder.stacktrace.graph.Pruning;\n@@ -137,0 +138,3 @@\n+\n+\t\t\tmodel = Pruning.prune(model, maxNodesRendered, false);\n+\t\t\tint currentNodeCount = model.getNodes().size();\n@@ -142,1 +146,4 @@\n-\t\t\t\tDisplayToolkit.inDisplayThread().execute(() -> view.setModel(items, dotString));\n+\t\t\t\tDisplayToolkit.inDisplayThread().execute(() -> {\n+\t\t\t\t\tview.setModel(items, dotString);\n+\t\t\t\t\tview.nodeThresholdSelection.setText(String.valueOf(currentNodeCount));\n+\t\t\t\t});\n@@ -167,0 +174,1 @@\n+\tprivate NodeThresholdSelection nodeThresholdSelection;\n@@ -174,1 +182,2 @@\n-\t\ttoolBar.add(new NodeThresholdSelection());\n+\t\tnodeThresholdSelection = new NodeThresholdSelection();\n+\t\ttoolBar.add(nodeThresholdSelection);\n@@ -187,2 +196,3 @@\n-\t\tprivate final List<Pair<String, Integer>> items = Arrays.asList(new Pair<>(\"100\", 100), new Pair<>(\"500\", 500),\n-\t\t\t\tnew Pair<>(\"1000\", 1000));\n+\t\tprivate final List<Pair<String, Integer>> items = Arrays.asList(new Pair<>(\"10\", 10), new Pair<>(\"20\", 20),\n+\t\t\t\tnew Pair<>(\"30\", 30), new Pair<>(\"40\", 40), new Pair<>(\"50\", 50), new Pair<>(\"100\", 100),\n+\t\t\t\tnew Pair<>(\"500\", 500), new Pair<>(\"1000\", 1000));\n","filename":"application\/org.openjdk.jmc.flightrecorder.graphview\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/graphview\/views\/GraphView.java","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, 2021, Datadog, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Datadog, Inc. All rights reserved.\n@@ -53,1 +53,1 @@\n-\tpublic Edge(Node from, Node to) {\n+\tpublic Edge(Node from, Node to, double value) {\n@@ -59,0 +59,1 @@\n+\t\tthis.value = value;\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/graph\/Edge.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, 2021, Datadog, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Datadog, Inc. All rights reserved.\n@@ -36,0 +36,3 @@\n+import java.util.HashMap;\n+import java.util.Map;\n+\n@@ -50,0 +53,36 @@\n+\tstatic class NodeWrapper {\n+\t\tint nodeId;\n+\t\tNode node;\n+\n+\t\tNodeWrapper(int nodeId, Node node) {\n+\t\t\tthis.nodeId = nodeId;\n+\t\t\tthis.node = node;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + nodeId;\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tNodeWrapper other = (NodeWrapper) obj;\n+\t\t\tif (nodeId != other.nodeId)\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t}\n+\n+\tprivate final Map<NodeWrapper, Edge> in = new HashMap<>();\n+\tprivate final Map<NodeWrapper, Edge> out = new HashMap<>();\n+\n@@ -134,0 +173,8 @@\n+\n+\tMap<NodeWrapper, Edge> getIn() {\n+\t\treturn in;\n+\t}\n+\n+\tMap<NodeWrapper, Edge> getOut() {\n+\t\treturn out;\n+\t}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/graph\/Node.java","additions":49,"deletions":2,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.stacktrace.graph;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.openjdk.jmc.flightrecorder.stacktrace.graph.Node.NodeWrapper;\n+\n+\/\/ implementation based on https:\/\/github.com\/google\/pprof\/blob\/83db2b799d1f74c40857232cb5eb4c60379fe6c2\/internal\/report\/report.go#L124\n+public class Pruning {\n+\tpublic static StacktraceGraphModel prune(StacktraceGraphModel model, int maxNodeCount, boolean trimLowFrequency) {\n+\t\t\/\/ first phase: cutoff\n+\t\tlong totalValue = model.getNodes().stream().mapToLong(node -> node.count).sum();\n+\t\tif (trimLowFrequency) {\n+\t\t\tdouble nodeFraction = 0.005;\n+\t\t\tlong nodeCutoff = Math.round(totalValue * nodeFraction);\n+\t\t\tif (nodeCutoff > 0) {\n+\t\t\t\tmodel = discardLowFrequencyNodes(model, nodeCutoff);\n+\t\t\t}\n+\t\t}\n+\t\t\/\/ second phase: entropy\n+\t\tMap<Integer, Long> nodeScores = new HashMap<>();\n+\t\tfor (Node node : model.getNodes()) {\n+\t\t\tlong score = entropyScore(node);\n+\t\t\tnodeScores.put(node.getNodeId(), score);\n+\t\t}\n+\t\t\/\/ sort\n+\t\tList<Node> sortedNodes = new ArrayList<Node>(model.getNodes());\n+\t\tsortedNodes.sort((n1, n2) -> {\n+\t\t\tlong score1 = nodeScores.get(n1.getNodeId());\n+\t\t\tlong score2 = nodeScores.get(n2.getNodeId());\n+\t\t\treturn -Long.compare(score1, score2);\n+\t\t});\n+\t\tif (trimLowFrequency) {\n+\t\t\tdouble edgeFraction = 0.001;\n+\t\t\tlong edgeCutoff = Math.round(totalValue * edgeFraction);\n+\t\t\ttrimLowFrequencyEdges(sortedNodes, edgeCutoff);\n+\t\t}\n+\t\t\/\/ selectTopNodes\n+\t\treturn selectTopNode(model, sortedNodes, maxNodeCount);\n+\t}\n+\n+\tprivate static StacktraceGraphModel discardLowFrequencyNodes(StacktraceGraphModel model, long nodeCutoff) {\n+\t\tSet<AggregatableFrame> cutNodes = new HashSet<>(model.getNodes().size());\n+\t\tfor (Node node : model.getNodes()) {\n+\t\t\tif (node.cumulativeWeight < nodeCutoff) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tcutNodes.add(node.getFrame());\n+\t\t}\n+\t\treturn new StacktraceGraphModel(model, cutNodes);\n+\t}\n+\n+\tprivate static StacktraceGraphModel selectTopNode(\n+\t\tStacktraceGraphModel model, Collection<Node> sortedNodes, int maxCount) {\n+\t\tSet<AggregatableFrame> cutNodes = new HashSet<>(model.getNodes().size());\n+\t\tint count = 0;\n+\t\tfor (Node node : sortedNodes) {\n+\t\t\tcutNodes.add(node.getFrame());\n+\t\t\tcount++;\n+\t\t\tif (count >= maxCount) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\treturn new StacktraceGraphModel(model, cutNodes);\n+\t}\n+\n+\tprivate static int trimLowFrequencyEdges(Collection<Node> sortedNode, long edgeCutoff) {\n+\t\tint droppedEdges = 0;\n+\t\tfor (Node node : sortedNode) {\n+\n+\t\t\tfor (Map.Entry<NodeWrapper, Edge> entry : new HashSet<>(node.getIn().entrySet())) {\n+\t\t\t\tif (entry.getValue().value < edgeCutoff) {\n+\t\t\t\t\tnode.getIn().remove(entry.getKey());\n+\t\t\t\t\tentry.getKey().node.getOut().remove(new NodeWrapper(node.getNodeId(), node));\n+\t\t\t\t\tdroppedEdges++;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn droppedEdges;\n+\t}\n+\n+\tprivate static long entropyScore(Node node) {\n+\t\tdouble score = 0;\n+\t\tif (node.getIn().isEmpty()) {\n+\t\t\tscore++;\n+\t\t} else {\n+\t\t\tscore += edgeEntropyScore(node, node.getIn().values(), 0);\n+\t\t}\n+\t\tif (node.getOut().isEmpty()) {\n+\t\t\tscore++;\n+\t\t} else {\n+\t\t\tscore += edgeEntropyScore(node, node.getOut().values(), node.weight);\n+\t\t}\n+\t\treturn Math.round(score * node.cumulativeWeight + node.weight);\n+\t}\n+\n+\tprivate static double edgeEntropyScore(Node node, Collection<Edge> edges, double self) {\n+\t\tdouble score = 0;\n+\t\tdouble total = self;\n+\t\tfor (Edge edge : edges) {\n+\t\t\tif (edge.getValue() > 0) {\n+\t\t\t\ttotal += Math.abs(edge.getValue());\n+\t\t\t}\n+\t\t}\n+\t\tif (total > 0) {\n+\t\t\tfor (Edge edge : edges) {\n+\t\t\t\tdouble frac = Math.abs(edge.getValue()) \/ total;\n+\t\t\t\tscore += -frac * Math.log(frac);\n+\t\t\t}\n+\t\t\tif (self > 0) {\n+\t\t\t\tdouble frac = Math.abs(self) \/ total;\n+\t\t\t\tscore += -frac * Math.log(frac);\n+\t\t\t}\n+\t\t}\n+\t\treturn score;\n+\t}\n+\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/graph\/Pruning.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, 2021, Datadog, Inc. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Datadog, Inc. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.util.Collections;\n@@ -61,0 +62,1 @@\n+import org.openjdk.jmc.flightrecorder.stacktrace.graph.Node.NodeWrapper;\n@@ -113,1 +115,8 @@\n-\t\tbuildModel();\n+\t\tbuildModel(Collections.emptySet());\n+\t}\n+\n+\tStacktraceGraphModel(StacktraceGraphModel model, Set<AggregatableFrame> keptNodes) {\n+\t\tthis.frameSeparator = model.frameSeparator;\n+\t\tthis.items = model.items;\n+\t\tthis.attribute = model.attribute;\n+\t\tbuildModel(keptNodes);\n@@ -261,1 +270,1 @@\n-\tprivate void buildModel() {\n+\tprivate void buildModel(Set<AggregatableFrame> keptNodes) {\n@@ -267,1 +276,1 @@\n-\t\t\titerable.forEach((item) -> addItem(item, stacktraceAccessor, getAccessor(iterable, attribute)));\n+\t\t\titerable.forEach((item) -> addItem(item, stacktraceAccessor, getAccessor(iterable, attribute), keptNodes));\n@@ -277,1 +286,1 @@\n-\t\tIMemberAccessor<IQuantity, IItem> quantityAccessor) {\n+\t\tIMemberAccessor<IQuantity, IItem> quantityAccessor, Set<AggregatableFrame> keptNodes) {\n@@ -287,1 +296,1 @@\n-\t\tdouble value = 0;\n+\t\tdouble value = 1;\n@@ -296,22 +305,27 @@\n-\t\tIMCFrame firstFrame = frames.get(0);\n-\t\tNode n = getOrCreateNode(firstFrame);\n-\t\ttotalTraceCount++;\n-\t\tn.count++;\n-\t\tn.weight += value;\n-\n-\t\t\/\/ Next go through all frames from the thread root, and up the cumulative counts\n-\t\tfor (int i = frames.size() - 1; i > 0; i--) {\n-\t\t\t\/\/ Process two frames sliding window, from and to\n-\t\t\tIMCFrame currentFrame = frames.get(i);\n-\t\t\tIMCFrame nextFrame = frames.get(i - 1);\n-\n-\t\t\tNode currentNode = getOrCreateNode(currentFrame);\n-\t\t\tNode nextNode = getOrCreateNode(nextFrame);\n-\n-\t\t\tcurrentNode.cumulativeCount++;\n-\t\t\tnextNode.cumulativeCount++;\n-\t\t\tcurrentNode.cumulativeWeight += value;\n-\t\t\tnextNode.cumulativeWeight += value;\n-\t\t\tEdge e = getOrCreateLink(currentNode, nextNode);\n-\t\t\te.count++;\n-\t\t\ttotalEdgeCount++;\n+\t\tAggregatableFrame firstFrame = new AggregatableFrame(frameSeparator, frames.get(0));\n+\t\tif (keepFrame(keptNodes, firstFrame)) {\n+\t\t\tNode n = getOrCreateNode(firstFrame);\n+\t\t\ttotalTraceCount++;\n+\t\t\tn.count++;\n+\t\t\tn.weight += value;\n+\n+\t\t\t\/\/ Next go through all frames from the thread root, and up the cumulative counts\n+\t\t\tfor (int i = frames.size() - 1; i > 0; i--) {\n+\t\t\t\t\/\/ Process two frames sliding window, from and to\n+\t\t\t\tAggregatableFrame currentFrame = new AggregatableFrame(frameSeparator, frames.get(i));\n+\t\t\t\tAggregatableFrame nextFrame = new AggregatableFrame(frameSeparator, frames.get(i - 1));\n+\n+\t\t\t\tif (keepFrame(keptNodes, currentFrame)) {\n+\t\t\t\t\tNode currentNode = getOrCreateNode(currentFrame);\n+\t\t\t\t\tcurrentNode.cumulativeCount++;\n+\t\t\t\t\tcurrentNode.cumulativeWeight += value;\n+\t\t\t\t\tif (keepFrame(keptNodes, nextFrame)) {\n+\t\t\t\t\t\tNode nextNode = getOrCreateNode(nextFrame);\n+\t\t\t\t\t\tnextNode.cumulativeCount++;\n+\t\t\t\t\t\tnextNode.cumulativeWeight += value;\n+\t\t\t\t\t\tEdge e = getOrCreateLink(currentNode, nextNode, value);\n+\t\t\t\t\t\te.count++;\n+\t\t\t\t\t\ttotalEdgeCount++;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n@@ -321,0 +335,4 @@\n+\tprivate boolean keepFrame(Set<AggregatableFrame> keptNodes, AggregatableFrame frame) {\n+\t\treturn keptNodes.isEmpty() || keptNodes.contains(frame);\n+\t}\n+\n@@ -323,1 +341,5 @@\n-\t\tNode n = nodes.get(aframe);\n+\t\treturn getOrCreateNode(aframe);\n+\t}\n+\n+\tprivate Node getOrCreateNode(AggregatableFrame frame) {\n+\t\tNode n = nodes.get(frame);\n@@ -325,2 +347,2 @@\n-\t\t\tn = new Node(Integer.valueOf(nodeCounter++), aframe);\n-\t\t\tnodes.put(aframe, n);\n+\t\t\tn = new Node(Integer.valueOf(nodeCounter++), frame);\n+\t\t\tnodes.put(frame, n);\n@@ -331,1 +353,1 @@\n-\tprivate Edge getOrCreateLink(Node fromNode, Node toNode) {\n+\tprivate Edge getOrCreateLink(Node fromNode, Node toNode, double value) {\n@@ -333,1 +355,1 @@\n-\t\t\tEdge edge = new Edge(fromNode, toNode);\n+\t\t\tEdge edge = new Edge(fromNode, toNode, value);\n@@ -337,0 +359,1 @@\n+\t\t\tupdateNodeEdges(fromNode, toNode, edge, value);\n@@ -347,1 +370,1 @@\n-\t\tEdge edge = new Edge(fromNode, toNode);\n+\t\tEdge edge = new Edge(fromNode, toNode, value);\n@@ -349,0 +372,1 @@\n+\t\tupdateNodeEdges(fromNode, toNode, edge, value);\n@@ -352,0 +376,9 @@\n+\tprivate void updateNodeEdges(Node fromNode, Node toNode, Edge edge, double value) {\n+\t\tEdge outEdge = fromNode.getOut().get(new NodeWrapper(toNode.getNodeId(), toNode));\n+\t\tif (outEdge != null) {\n+\t\t\toutEdge.value += value;\n+\t\t}\n+\t\tfromNode.getOut().put(new NodeWrapper(toNode.getNodeId(), toNode), edge);\n+\t\ttoNode.getIn().put(new NodeWrapper(fromNode.getNodeId(), fromNode), edge);\n+\t}\n+\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/graph\/StacktraceGraphModel.java","additions":68,"deletions":35,"binary":false,"changes":103,"status":"modified"}]}