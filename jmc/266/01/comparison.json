{"files":[{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.internal.parser.v1;\n+\n+import org.openjdk.jmc.common.unit.ContentType;\n+import org.openjdk.jmc.flightrecorder.internal.InvalidJfrFileException;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.util.logging.Logger;\n+\n+public class SpecificReaders {\n+\tprivate static Logger LOG = Logger.getLogger(SpecificReaders.class.getName());\n+\n+\tstatic class StackFrame2Reader extends ValueReaders.ReflectiveReader {\n+\t\tboolean fallback;\n+\t\tint methodIdx;\n+\t\tint lineNumberIdx;\n+\t\tint bytecodeIndexIdx;\n+\t\tint typeIdx;\n+\n+\t\t<T> StackFrame2Reader(Class<T> klass, int fieldCount, ContentType<? super T> ct) {\n+\t\t\tsuper(klass, fieldCount, ct);\n+\t\t}\n+\n+\t\t@Override\n+\t\tvoid addField(String identifier, String name, String description, ValueReaders.IValueReader reader)\n+\t\t\t\tthrows InvalidJfrFileException {\n+\t\t\tsuper.addField(identifier, name, description, reader);\n+\t\t\tint currentIdx = valueReaders.size() - 1;\n+\t\t\tswitch (identifier) {\n+\t\t\tcase \"method\":\n+\t\t\t\tmethodIdx = currentIdx;\n+\t\t\t\tbreak;\n+\t\t\tcase \"lineNumber\":\n+\t\t\t\tlineNumberIdx = currentIdx;\n+\t\t\t\tbreak;\n+\t\t\tcase \"bytecodeIndex\":\n+\t\t\t\tbytecodeIndexIdx = currentIdx;\n+\t\t\t\tbreak;\n+\t\t\tcase \"type\":\n+\t\t\t\ttypeIdx = currentIdx;\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tfallback = true; \/\/ invalid expected format, falling back to ReflectiveReader\n+\t\t\t\tLOG.warning(\"unexpected fields for StackFrame2Reader: \" + identifier);\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Object read(IDataInput in, boolean allowUnresolvedReference)\n+\t\t\t\tthrows IOException, InvalidJfrFileException {\n+\t\t\tif (fallback) {\n+\t\t\t\treturn super.read(in, allowUnresolvedReference);\n+\t\t\t}\n+\t\t\tStructTypes.JfrFrame jfrFrame = new StructTypes.JfrFrame();\n+\t\t\tjfrFrame.method = valueReaders.get(methodIdx).read(in, allowUnresolvedReference);\n+\t\t\tjfrFrame.lineNumber = valueReaders.get(lineNumberIdx).read(in, allowUnresolvedReference);\n+\t\t\tjfrFrame.bytecodeIndex = valueReaders.get(bytecodeIndexIdx).read(in, allowUnresolvedReference);\n+\t\t\tjfrFrame.type = valueReaders.get(typeIdx).read(in, allowUnresolvedReference);\n+\t\t\treturn jfrFrame;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Object resolve(Object value) throws InvalidJfrFileException {\n+\t\t\tif (!(value instanceof StructTypes.JfrFrame))\n+\t\t\t\tthrow new RuntimeException(\"Invalid object type, expected JfrFrame\");\n+\t\t\tStructTypes.JfrFrame jfrFrame = (StructTypes.JfrFrame) value;\n+\t\t\tjfrFrame.method = valueReaders.get(0).resolve(jfrFrame.method);\n+\t\t\tjfrFrame.lineNumber = valueReaders.get(1).resolve(jfrFrame.lineNumber);\n+\t\t\tjfrFrame.bytecodeIndex = valueReaders.get(2).resolve(jfrFrame.bytecodeIndex);\n+\t\t\tjfrFrame.type = valueReaders.get(3).resolve(jfrFrame.type);\n+\t\t\treturn value;\n+\t\t}\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/parser\/v1\/SpecificReaders.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -217,1 +217,1 @@\n-\t\t\t\treturn new ReflectiveReader(JfrFrame.class, fieldCount, UnitLookup.STACKTRACE_FRAME);\n+\t\t\t\treturn new SpecificReaders.StackFrame2Reader(JfrFrame.class, fieldCount, UnitLookup.STACKTRACE_FRAME);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/parser\/v1\/TypeManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}