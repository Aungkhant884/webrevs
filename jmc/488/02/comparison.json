{"files":[{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.rules.jdk.memory;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+\n+import org.openjdk.jmc.common.item.Aggregators;\n+import org.openjdk.jmc.common.item.IAggregator;\n+import org.openjdk.jmc.common.item.IItemFilter;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.item.ItemFilters;\n+import org.openjdk.jmc.common.item.PersistableItemFilter.Kind;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.UnitLookup;\n+import org.openjdk.jmc.common.util.IPreferenceValueProvider;\n+import org.openjdk.jmc.common.util.TypedPreference;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkAttributes;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkFilters;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkTypeIDs;\n+import org.openjdk.jmc.flightrecorder.rules.IResult;\n+import org.openjdk.jmc.flightrecorder.rules.IResultValueProvider;\n+import org.openjdk.jmc.flightrecorder.rules.IRule;\n+import org.openjdk.jmc.flightrecorder.rules.ResultBuilder;\n+import org.openjdk.jmc.flightrecorder.rules.Severity;\n+import org.openjdk.jmc.flightrecorder.rules.TypedResult;\n+import org.openjdk.jmc.flightrecorder.rules.jdk.messages.internal.Messages;\n+import org.openjdk.jmc.flightrecorder.rules.util.JfrRuleTopics;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.EventAvailability;\n+import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit.RequiredEventsBuilder;\n+\n+\/**\n+ * Rule that looks at the G1 GC time and compares it to the max pause time.\n+ *\/\n+public class GcPauseTargetRule implements IRule {\n+\n+\tprivate static final String GC_PAUSE_TARGET_RESULT_ID = \"GcPauseTargetRule\"; \/\/$NON-NLS-1$\n+\n+\tprivate static final Map<String, EventAvailability> REQUIRED_EVENTS = RequiredEventsBuilder.create()\n+\t\t\t.addEventType(JdkTypeIDs.GC_G1MMU, EventAvailability.AVAILABLE).build();\n+\n+\tpublic static final TypedResult<IQuantity> EXCEEDED_PERCENT = new TypedResult<>(\"gcExceededPercent\", \/\/$NON-NLS-1$\n+\t\t\t\"Pause target exceeded percent\",\n+\t\t\t\"The percentage of G1MMU events where the gcTime exceeded the pauseTarget.\", UnitLookup.PERCENTAGE,\n+\t\t\tIQuantity.class);\n+\n+\tpublic static final TypedResult<IQuantity> G1MMU_TOTAL = new TypedResult<>(\"g1mmuTotal\", \"Total G1MMU Events\", \/\/$NON-NLS-1$\n+\t\t\t\"The number of G1MMU events that occured during the recording.\", UnitLookup.NUMBER, IQuantity.class);\n+\n+\tpublic static final TypedResult<IQuantity> G1MMU_EXCEEDED = new TypedResult<>(\"g1mmuExceeded\", \/\/$NON-NLS-1$\n+\t\t\t\"Exceeded pause targets\", \"The number of G1MMU events where the gcTime exceeded the pauseTarget.\",\n+\t\t\tUnitLookup.NUMBER, IQuantity.class);\n+\n+\tpublic static final TypedResult<IQuantity> PAUSE_TARGET = new TypedResult<>(\"pauseTarget\", \"Pause target\", \/\/$NON-NLS-1$\n+\t\t\t\"Max time allowed to be spent on GC during last time slice.\", UnitLookup.NUMBER, IQuantity.class);\n+\n+\tpublic final Collection<TypedResult<?>> RESULT_ATTRIBUTES = Arrays.<TypedResult<?>> asList(EXCEEDED_PERCENT,\n+\t\t\tG1MMU_TOTAL, G1MMU_EXCEEDED, PAUSE_TARGET);\n+\n+\t@Override\n+\tpublic RunnableFuture<IResult> createEvaluation(\n+\t\tfinal IItemCollection items, final IPreferenceValueProvider preferenceValueProvider,\n+\t\tfinal IResultValueProvider dependencyResults) {\n+\t\tFutureTask<IResult> evaluationTask = new FutureTask<>(new Callable<IResult>() {\n+\t\t\t@Override\n+\t\t\tpublic IResult call() throws Exception {\n+\t\t\t\tIQuantity pauseTarget = items\n+\t\t\t\t\t\t.getAggregate((IAggregator<IQuantity, ?>) Aggregators.max(JdkAttributes.GC_PAUSE_TARGET));\n+\t\t\t\tIQuantity maxGcTime = items\n+\t\t\t\t\t\t.getAggregate((IAggregator<IQuantity, ?>) Aggregators.max(JdkAttributes.GC_TIME));\n+\t\t\t\tif (maxGcTime.compareTo(pauseTarget) < 1) {\n+\t\t\t\t\treturn ResultBuilder.createFor(GcPauseTargetRule.this, preferenceValueProvider)\n+\t\t\t\t\t\t\t.setSeverity(Severity.OK).setSummary(Messages.getString(Messages.GcPauseTargetRule_TEXT_OK))\n+\t\t\t\t\t\t\t.addResult(PAUSE_TARGET, pauseTarget).build();\n+\t\t\t\t} else {\n+\t\t\t\t\tIItemCollection g1mmuItems = items.apply(JdkFilters.GC_G1MMU);\n+\t\t\t\t\tIItemFilter filter = ItemFilters.buildComparisonFilter(Kind.MORE, JdkAttributes.GC_TIME,\n+\t\t\t\t\t\t\tpauseTarget);\n+\t\t\t\t\tIQuantity g1mmuTotal = g1mmuItems.getAggregate(Aggregators.count());\n+\t\t\t\t\tIQuantity g1mmuExceeded = g1mmuItems.apply(filter).getAggregate(Aggregators.count());\n+\t\t\t\t\tIQuantity exceededPercent = RulesToolkit.toRatioPercent(g1mmuExceeded, g1mmuTotal);\n+\t\t\t\t\treturn ResultBuilder.createFor(GcPauseTargetRule.this, preferenceValueProvider)\n+\t\t\t\t\t\t\t.setSeverity(Severity.WARNING)\n+\t\t\t\t\t\t\t.setSummary(Messages.getString(Messages.GcPauseTargetRule_TEXT_WARN_SHORT))\n+\t\t\t\t\t\t\t.setExplanation(Messages.getString(Messages.GcPauseTargetRule_TEXT_WARN_LONG))\n+\t\t\t\t\t\t\t.addResult(PAUSE_TARGET, pauseTarget).addResult(EXCEEDED_PERCENT, exceededPercent)\n+\t\t\t\t\t\t\t.addResult(G1MMU_TOTAL, g1mmuTotal).addResult(G1MMU_EXCEEDED, g1mmuExceeded).build();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t});\n+\t\treturn evaluationTask;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TypedPreference<?>> getConfigurationAttributes() {\n+\t\treturn Collections.emptyList();\n+\t}\n+\n+\t@Override\n+\tpublic String getId() {\n+\t\treturn GC_PAUSE_TARGET_RESULT_ID;\n+\t}\n+\n+\t@Override\n+\tpublic String getName() {\n+\t\treturn Messages.getString(Messages.GcPauseTargetRule_RULE_NAME);\n+\t}\n+\n+\t@Override\n+\tpublic String getTopic() {\n+\t\treturn JfrRuleTopics.GARBAGE_COLLECTION;\n+\t}\n+\n+\t@Override\n+\tpublic Map<String, EventAvailability> getRequiredEvents() {\n+\t\treturn REQUIRED_EVENTS;\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TypedResult<?>> getResults() {\n+\t\treturn RESULT_ATTRIBUTES;\n+\t}\n+\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/memory\/GcPauseTargetRule.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -327,0 +327,4 @@\n+\tpublic static final String GcPauseTargetRule_RULE_NAME = \"GcPauseTargetRule_RULE_NAME\"; \/\/$NON-NLS-1$\n+\tpublic static final String GcPauseTargetRule_TEXT_OK = \"GcPauseTargetRule_TEXT_OK\"; \/\/$NON-NLS-1$\n+\tpublic static final String GcPauseTargetRule_TEXT_WARN_SHORT = \"GcPauseTargetRule_TEXT_WARN_SHORT\"; \/\/$NON-NLS-1$\n+\tpublic static final String GcPauseTargetRule_TEXT_WARN_LONG = \"GcPauseTargetRule_TEXT_WARN_LONG\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/Messages.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-#  Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,1 @@\n+org.openjdk.jmc.flightrecorder.rules.jdk.memory.GcPauseTargetRule\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/META-INF\/services\/org.openjdk.jmc.flightrecorder.rules.IRule","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -345,0 +345,4 @@\n+GcPauseTargetRule_RULE_NAME=G1 MMU Information\n+GcPauseTargetRule_TEXT_OK=All GCs completed before the GC pause target time of {pauseTarget}.\n+GcPauseTargetRule_TEXT_WARN_SHORT=Not all GCs completed before the GC pause target time.\n+GcPauseTargetRule_TEXT_WARN_LONG=The G1 Garbage Collector is configured with a target maximum pause time of {pauseTarget}. {gcExceededPercent} of the recorded g1mmu events ({g1mmuExceeded} of {g1mmuTotal}) exceeded the pause target.\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/messages.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -625,0 +625,2 @@\n+\tpublic static final IAttribute<IQuantity> GC_TIME = attr(\"gcTime\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_GC_TIME), TIMESPAN);\n@@ -716,0 +718,2 @@\n+\tpublic static final IAttribute<IQuantity> GC_PAUSE_TARGET = attr(\"pauseTarget\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ATTR_GC_PAUSE_TARGET), TIMESPAN);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkAttributes.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,0 +112,1 @@\n+\tpublic static final IItemFilter GC_G1MMU = ItemFilters.type(JdkTypeIDs.GC_G1MMU);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkFilters.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,1 +173,0 @@\n-\tpublic static final String GC_G1MMU = PREFIX + \"G1MMU\";\n@@ -179,0 +178,1 @@\n+\tpublic static final String GC_G1MMU = PREFIX + \"G1MMU\";\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/JdkTypeIDs.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -334,0 +334,1 @@\n+\tpublic static final String ATTR_GC_PAUSE_TARGET = \"ATTR_GC_PAUSE_TARGET\"; \/\/$NON-NLS-1$\n@@ -341,0 +342,1 @@\n+\tpublic static final String ATTR_GC_TIME = \"ATTR_GC_TIME\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/jdk\/messages\/internal\/Messages.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-#  Copyright (c) 2018, 2021 Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2018, 2023 Oracle and\/or its affiliates. All rights reserved.\n@@ -204,0 +204,2 @@\n+ATTR_GC_PAUSE_TARGET=Max time allowed to be spent on GC during last time slice\n+ATTR_GC_TIME=Time stopped because of GC during last time slice\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/jdk\/messages\/internal\/messages.properties","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -160,0 +160,5 @@\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>OK<\/severity>\n+            <summary>All GCs completed before the GC pause target time of 200 ms.<\/summary>\n+        <\/rule>\n@@ -454,0 +459,4 @@\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -721,0 +730,4 @@\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -988,0 +1001,4 @@\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1247,0 +1264,4 @@\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1508,0 +1529,4 @@\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -1769,0 +1794,4 @@\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2057,0 +2086,4 @@\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2351,0 +2384,4 @@\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -2636,0 +2673,5 @@\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>OK<\/severity>\n+            <summary>All GCs completed before the GC pause target time of 200 ms.<\/summary>\n+        <\/rule>\n@@ -2950,0 +2992,4 @@\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -3255,0 +3301,4 @@\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -3436,0 +3486,4 @@\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -3681,0 +3735,4 @@\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n@@ -3945,0 +4003,5 @@\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>OK<\/severity>\n+            <summary>All GCs completed before the GC pause target time of 200 ms.<\/summary>\n+        <\/rule>\n@@ -4230,0 +4293,4 @@\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseTargetRule<\/id>\n+            <severity>Not Applicable<\/severity>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/baseline\/JfrRuleBaseline.xml","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"}]}