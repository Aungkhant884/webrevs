{"files":[{"patch":"@@ -60,1 +60,1 @@\n-\tpublic final static String VERSION = \"0.1.0\"; \/\/$NON-NLS-1$\n+\tpublic static final String VERSION = \"0.9.0\"; \/\/$NON-NLS-1$\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/Agent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-\t\treturn getConverterClassName() != null;\n+\t\treturn getConverterDefinition() != null;\n@@ -52,1 +52,1 @@\n-\tString getConverterClassName();\n+\tString getConverterDefinition();\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/Convertable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-\tprivate final String converterClassName;\n+\tprivate final String converterDefinition;\n@@ -41,2 +41,2 @@\n-\tpublic AbstractConvertable(String converterClassName) {\n-\t\tthis.converterClassName = converterClassName;\n+\tpublic AbstractConvertable(String converterDefinition) {\n+\t\tthis.converterDefinition = converterDefinition;\n@@ -46,2 +46,2 @@\n-\tpublic String getConverterClassName() {\n-\t\treturn converterClassName;\n+\tpublic String getConverterDefinition() {\n+\t\treturn converterDefinition;\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/impl\/AbstractConvertable.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent.impl;\n+\n+public final class MalformedConverterException extends Exception {\n+\tprivate static final long serialVersionUID = 1L;\n+\n+\tpublic MalformedConverterException(String message) {\n+\t\tsuper(message);\n+\t}\n+\n+\tpublic MalformedConverterException(Throwable t) {\n+\t\tsuper(t);\n+\t}\n+\n+\tpublic MalformedConverterException(String message, Throwable t) {\n+\t\tsuper(message, t);\n+\t}\n+}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/impl\/MalformedConverterException.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -37,0 +37,2 @@\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Parameter;\n@@ -38,1 +40,1 @@\n-import org.openjdk.jmc.agent.Agent;\n+import org.objectweb.asm.Type;\n@@ -41,2 +43,2 @@\n-public class ResolvedConvertable extends AbstractConvertable implements Convertable {\n-\tprivate final static String CONVERTER_METHOD = \"convert\";\n+public final class ResolvedConvertable extends AbstractConvertable implements Convertable {\n+\tpublic static final String DEFAULT_CONVERTER_METHOD = \"convert\";\n@@ -46,2 +48,6 @@\n-\tpublic ResolvedConvertable(String converterClassName) {\n-\t\tsuper(converterClassName);\n+\tpublic ResolvedConvertable(String converterDefinition, Class<?> typeToConvert) throws MalformedConverterException {\n+\t\tsuper(converterDefinition);\n+\t\tif (typeToConvert == null) {\n+\t\t\tthrow new MalformedConverterException(\"Type to convert cannot be null!\");\n+\t\t}\n+\t\tString className = resolveClassName(converterDefinition);\n@@ -50,2 +56,2 @@\n-\t\t\tif (converterClassName != null) {\n-\t\t\t\ttmpClass = Class.forName(converterClassName);\n+\t\t\tif (converterDefinition != null) {\n+\t\t\t\ttmpClass = Class.forName(className);\n@@ -54,2 +60,1 @@\n-\t\t\tAgent.getLogger().severe(\"Failed to load specified converter class \" + converterClassName\n-\t\t\t\t\t+ \" - will not use that converter!\");\n+\t\t\tthrow new MalformedConverterException(\"Converter must convert to an existing class!\", e);\n@@ -58,1 +63,5 @@\n-\t\tthis.converterMethod = getConvertMethod(tmpClass);\n+\t\tthis.converterMethod = getConvertMethod(tmpClass, converterDefinition, typeToConvert);\n+\t}\n+\n+\tpublic ResolvedConvertable(String converterDefinition, Type type) throws MalformedConverterException {\n+\t\tthis(converterDefinition, getClassFromType(type));\n@@ -69,1 +78,4 @@\n-\tprivate static Method getConvertMethod(Class<?> converterClass) {\n+\tprivate static Method getConvertMethod(Class<?> converterClass, String converterDefinition, Class<?> originalType)\n+\t\t\tthrows MalformedConverterException {\n+\t\tString methodName = resolveMethodName(converterDefinition);\n+\n@@ -74,2 +86,7 @@\n-\t\t\tif (CONVERTER_METHOD.equals(m.getName())) {\n-\t\t\t\treturn m;\n+\t\t\tif (methodName.equals(m.getName())) {\n+\t\t\t\tif ((!Modifier.isStatic(m.getModifiers())) || m.getParameterCount() != 1) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tif (parameterIsAssignableType(m.getParameters()[0], originalType)) {\n+\t\t\t\t\treturn m;\n+\t\t\t\t}\n@@ -78,1 +95,46 @@\n-\t\treturn null;\n+\t\tthrow new MalformedConverterException(\"Could not find the convert method to use in \" + converterDefinition\n+\t\t\t\t+ \" to convert \" + originalType.getName());\n+\t}\n+\n+\tprivate static boolean parameterIsAssignableType(Parameter p, Class<?> originalType) {\n+\t\tif (p.getType().isAssignableFrom(originalType)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprivate static String resolveClassName(String converterDefinition) throws MalformedConverterException {\n+\t\tif (!converterDefinition.contains(\"(\")) {\n+\t\t\treturn converterDefinition;\n+\t\t}\n+\t\tint lastDotIndex = converterDefinition.lastIndexOf('.');\n+\t\tif (lastDotIndex == -1) {\n+\t\t\tthrow new MalformedConverterException(\n+\t\t\t\t\t\"Converter with method declaration must contain method: \" + converterDefinition);\n+\t\t}\n+\t\treturn converterDefinition.substring(0, lastDotIndex);\n+\t}\n+\n+\tprivate static String resolveMethodName(String converterDefinition) throws MalformedConverterException {\n+\t\t\/\/ org.openjdk.jmc.agent.converters.test.GurkConverterInt.customConvert(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)I\n+\t\tif (!converterDefinition.contains(\"(\")) {\n+\t\t\treturn DEFAULT_CONVERTER_METHOD;\n+\t\t}\n+\t\tint lastDotIndex = converterDefinition.lastIndexOf('.');\n+\t\tif (lastDotIndex == -1) {\n+\t\t\tthrow new MalformedConverterException(\n+\t\t\t\t\t\"Converter with method declaration must contain method: \" + converterDefinition);\n+\t\t}\n+\t\tint firstParenIndex = converterDefinition.lastIndexOf('(');\n+\t\tif (firstParenIndex < lastDotIndex) {\n+\t\t\tthrow new MalformedConverterException(\"No dots in the formal descriptor allowed: \" + converterDefinition);\n+\t\t}\n+\t\treturn converterDefinition.substring(lastDotIndex + 1, firstParenIndex);\n+\t}\n+\n+\tprivate static Class<?> getClassFromType(Type type) throws MalformedConverterException {\n+\t\ttry {\n+\t\t\treturn Class.forName(type.getClassName());\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\tthrow new MalformedConverterException(\"The type to transform could not be found\", e);\n+\t\t}\n@@ -83,1 +145,1 @@\n-\t\treturn \"Resolved \" + getConverterClassName() + \":\\nClass: \" + converterClass.getCanonicalName() + \"\\nMethod: \"\n+\t\treturn \"Resolved \" + getConverterDefinition() + \":\\nClass: \" + converterClass.getCanonicalName() + \"\\nMethod: \"\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/impl\/ResolvedConvertable.java","additions":77,"deletions":15,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -55,5 +55,5 @@\n-\tprivate final static String ATTRIBUTE_EVENT_NAME = \"name\"; \/\/$NON-NLS-1$\n-\tprivate final static String ATTRIBUTE_JFR_EVENT_DESCRIPTION = \"description\"; \/\/$NON-NLS-1$\n-\tprivate final static String ATTRIBUTE_JFR_EVENT_PATH = \"path\"; \/\/$NON-NLS-1$\n-\tprivate final static String ATTRIBUTE_STACK_TRACE = \"stacktrace\"; \/\/$NON-NLS-1$\n-\tprivate final static String ATTRIBUTE_RETHROW = \"rethrow\"; \/\/$NON-NLS-1$\n+\tprivate static final String ATTRIBUTE_EVENT_NAME = \"name\"; \/\/$NON-NLS-1$\n+\tprivate static final String ATTRIBUTE_JFR_EVENT_DESCRIPTION = \"description\"; \/\/$NON-NLS-1$\n+\tprivate static final String ATTRIBUTE_JFR_EVENT_PATH = \"path\"; \/\/$NON-NLS-1$\n+\tprivate static final String ATTRIBUTE_STACK_TRACE = \"stacktrace\"; \/\/$NON-NLS-1$\n+\tprivate static final String ATTRIBUTE_RETHROW = \"rethrow\"; \/\/$NON-NLS-1$\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfr\/JFRTransformDescriptor.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-\tprivate final static JFRVersion availableJFRVersion;\n+\tprivate static final JFRVersion availableJFRVersion;\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfr\/VersionResolver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.logging.Level;\n@@ -49,0 +50,1 @@\n+import org.openjdk.jmc.agent.impl.MalformedConverterException;\n@@ -102,2 +104,12 @@\n-\t\t\tResolvedConvertable resolved = new ResolvedConvertable(attribute.getConverterClassName());\n-\t\t\tfieldType = getFieldType(Type.getType(resolved.getConverterMethod().getReturnType()));\n+\t\t\tResolvedConvertable resolved;\n+\t\t\ttry {\n+\t\t\t\tresolved = new ResolvedConvertable(attribute.getConverterDefinition(), type);\n+\t\t\t\tfieldType = getFieldType(Type.getType(resolved.getConverterMethod().getReturnType()));\n+\t\t\t} catch (MalformedConverterException e) {\n+\t\t\t\tAgent.getLogger()\n+\t\t\t\t\t\t.log(Level.SEVERE,\n+\t\t\t\t\t\t\t\t\"Failed to load specified converter class \" + attribute.getConverterDefinition()\n+\t\t\t\t\t\t\t\t\t\t+ \" - will not use that converter! Skipped generating field in event class.\",\n+\t\t\t\t\t\t\t\te);\n+\t\t\t\treturn;\n+\t\t\t}\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfr\/impl\/JFREventClassGenerator.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import org.openjdk.jmc.agent.impl.MalformedConverterException;\n@@ -127,1 +128,1 @@\n-\t\t} catch (IllegalSyntaxException e) {\n+\t\t} catch (Exception e) {\n@@ -132,1 +133,1 @@\n-\tprivate void createEvent() throws IllegalSyntaxException {\n+\tprivate void createEvent() throws IllegalSyntaxException, MalformedConverterException {\n@@ -144,1 +145,1 @@\n-\t\t\t\t\targumentType = convertify(mv, param);\n+\t\t\t\t\targumentType = convertify(mv, param, argumentType);\n@@ -249,2 +250,2 @@\n-\tprivate Type convertify(MethodVisitor mv, Attribute convertable) {\n-\t\tResolvedConvertable resolvedConvertable = new ResolvedConvertable(convertable.getConverterClassName());\n+\tprivate Type convertify(MethodVisitor mv, Attribute convertable, Type type) throws MalformedConverterException {\n+\t\tResolvedConvertable resolvedConvertable = new ResolvedConvertable(convertable.getConverterDefinition(), type);\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfr\/impl\/JFRMethodAdvisor.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -49,3 +49,3 @@\n-\tpublic final static String INAME = Type.getInternalName(JFRUtils.class);\n-\tpublic final static Object PRODUCER;\n-\tpublic final static Method REGISTER_METHOD;\n+\tpublic static final String INAME = Type.getInternalName(JFRUtils.class);\n+\tpublic static final Object PRODUCER;\n+\tpublic static final Method REGISTER_METHOD;\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/jfrlegacy\/impl\/JFRUtils.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,2 +65,2 @@\n-\tprivate final static String UNSAFE_JDK_7_CLASS = \"sun.misc.Unsafe\"; \/\/$NON-NLS-1$\n-\tprivate final static String UNSAFE_JDK_11_CLASS = \"jdk.internal.misc.Unsafe\"; \/\/$NON-NLS-1$\n+\tprivate static final String UNSAFE_JDK_7_CLASS = \"sun.misc.Unsafe\"; \/\/$NON-NLS-1$\n+\tprivate static final String UNSAFE_JDK_11_CLASS = \"jdk.internal.misc.Unsafe\"; \/\/$NON-NLS-1$\n","filename":"agent\/src\/main\/java\/org\/openjdk\/jmc\/agent\/util\/TypeUtils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import org.openjdk.jmc.agent.test.Gurka;\n-\n@@ -39,1 +37,1 @@\n- * Converts a {@link Gurka} to an int, by taking the ID.\n+ * Converts a {@link Number} to long.\n@@ -41,3 +39,3 @@\n-public class GurkConverterInt {\n-\tpublic static int convert(Gurka gurka) {\n-\t\treturn gurka.getID();\n+public class ConverterNumber {\n+\tpublic static long convert(Number number) {\n+\t\treturn number.longValue();\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/ConverterNumber.java","additions":4,"deletions":6,"binary":false,"changes":10,"previous_filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/GurkConverterInt.java","status":"copied"},{"patch":"@@ -39,1 +39,1 @@\n- * Converts a {@link Gurka} to long, by taking the ID and casting it to a double.\n+ * Converts a {@link Gurka} to double by taking the ID and casting it.\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/GurkConverterDouble.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * Converts a {@link Gurka} to long, by taking the ID and casting it to a double.\n+ * Converts a {@link Gurka} to float by taking the ID and casting it.\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/GurkConverterFloat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * Converts a {@link Gurka} to an int, by taking the ID.\n+ * Converts a {@link Gurka} to an int by taking the ID and casting it.\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/GurkConverterInt.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * Converts a {@link Gurka} to long, by taking the ID and casting it to a long.\n+ * Converts a {@link Gurka} to long by taking the ID and casting it.\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/GurkConverterLong.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,2 @@\n- * Converts a {@link Gurka} to long, by taking the ID and casting it to a double.\n+ * Converts a {@link Gurka} to int by taking the ID and casting it, using a non standard method\n+ * name.\n@@ -41,3 +42,3 @@\n-public class GurkConverterDouble {\n-\tpublic static double convert(Gurka gurka) {\n-\t\treturn (double) gurka.getID();\n+public class GurkCustomConverterInt {\n+\tpublic static int convertCustom(Gurka gurka) {\n+\t\treturn (int) gurka.getID();\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/GurkCustomConverterInt.java","additions":5,"deletions":4,"binary":false,"changes":9,"previous_filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/GurkConverterDouble.java","status":"copied"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent.converters.test;\n+\n+import org.openjdk.jmc.agent.test.Gurka;\n+\n+\/**\n+ * Converts a {@link Gurka} to various different types.\n+ *\/\n+public class GurkMultiCustomConverter {\n+\tpublic static int convertCustomInt(Gurka gurka) {\n+\t\treturn (int) gurka.getID();\n+\t}\n+\n+\tpublic static double convertCustomDouble(Gurka gurka) {\n+\t\treturn (double) gurka.getID();\n+\t}\n+\n+\tpublic static String convertCustomString(Gurka gurka) {\n+\t\treturn \"StringGurka \" + gurka.getID();\n+\t}\n+}\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/GurkMultiCustomConverter.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent.converters.test;\n+\n+import org.openjdk.jmc.agent.test.Gurka;\n+\n+\/**\n+ * Converts a {@link Gurka} to various different types.\n+ *\/\n+public class GurkMultiDefaultConverter {\n+\tpublic static int convert(Gurka gurka) {\n+\t\treturn (int) gurka.getID();\n+\t}\n+\n+\tpublic static int convert(String string) {\n+\t\treturn (int) Integer.valueOf(string);\n+\t}\n+\n+\tpublic static String convert(Exception exception) {\n+\t\treturn exception.getMessage();\n+\t}\n+\n+\tpublic static int convert(Double value) {\n+\t\treturn value.intValue();\n+\t}\n+\n+\tpublic static int convert(Integer value) {\n+\t\treturn value.intValue();\n+\t}\n+\n+\tpublic static int convert(Long value) {\n+\t\treturn value.intValue();\n+\t}\n+}\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/GurkMultiDefaultConverter.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -55,1 +55,1 @@\n-\tprivate final static class Runner implements Runnable {\n+\tprivate static final class Runner implements Runnable {\n@@ -66,0 +66,5 @@\n+\t\t\t\t\tprintNumber(TestToolkit.randomLong());\n+\t\t\t\t\tprintIntMultiCustom(Gurka.createGurka());\n+\t\t\t\t\tprintDoubleMultiCustom(Gurka.createGurka());\n+\t\t\t\t\tprintLongMultiDefault(TestToolkit.randomLong());\n+\t\t\t\t\tprintDoubleMultiDefault(TestToolkit.randomLong() \/ 2.0d);\n@@ -107,0 +112,25 @@\n+\n+\tpublic static void printNumber(Number number) throws InterruptedException {\n+\t\tSystem.out.println(\"C Number: \" + number.doubleValue());\n+\t\tThread.sleep(1000);\n+\t}\n+\n+\tprivate static void printIntMultiCustom(Gurka gurka) throws InterruptedException {\n+\t\tSystem.out.println(\"C int MC: \" + gurka);\n+\t\tThread.sleep(1000);\n+\t}\n+\n+\tpublic static void printDoubleMultiCustom(Gurka gurka) throws InterruptedException {\n+\t\tSystem.out.println(\"C Long MC: \" + gurka);\n+\t\tThread.sleep(1000);\n+\t}\n+\n+\tpublic static void printLongMultiDefault(Long value) throws InterruptedException {\n+\t\tSystem.out.println(\"C Long MD: \" + value.longValue());\n+\t\tThread.sleep(1000);\n+\t}\n+\n+\tpublic static void printDoubleMultiDefault(Double value) throws InterruptedException {\n+\t\tSystem.out.println(\"C Long MD: \" + value.doubleValue());\n+\t\tThread.sleep(1000);\n+\t}\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/InstrumentMeConverter.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,242 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * \n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ * \n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ * \n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ * \n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ * \n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.agent.converters.test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.junit.Test;\n+import org.openjdk.jmc.agent.impl.MalformedConverterException;\n+import org.openjdk.jmc.agent.impl.ResolvedConvertable;\n+import org.openjdk.jmc.agent.test.Gurka;\n+\n+public class TestResolver {\n+\tprivate static final String CLASS_GURK_INT = GurkConverterInt.class.getName();\n+\tprivate static final String CLASS_NUMBER_CONVERTER = ConverterNumber.class.getName();\n+\tprivate static final String CLASS_MALFORMED = \"notavalidtransformer\";\n+\tprivate static final String CLASS_CUSTOM_INT = GurkCustomConverterInt.class.getName();\n+\tprivate static final String CLASS_MULTI_CUSTOM = GurkMultiCustomConverter.class.getName();\n+\tprivate static final String CLASS_MULTI_DEFAULT = GurkMultiDefaultConverter.class.getName();\n+\n+\tprivate static final String DEFINITION_GURK_INT_DEFAULT_METHOD = CLASS_GURK_INT\n+\t\t\t+ \".convert(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)I\";\n+\tprivate static final String DEFINITION_CUSTOM_INT = CLASS_CUSTOM_INT\n+\t\t\t+ \".convertCustom(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)I\";\n+\tprivate static final String DEFINITION_MULTI_CUSTOM_INT = CLASS_MULTI_CUSTOM\n+\t\t\t+ \".convertCustomInt(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)I\";\n+\tprivate static final String DEFINITION_MULTI_CUSTOM_DOUBLE = CLASS_MULTI_CUSTOM\n+\t\t\t+ \".convertCustomDouble(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)D\";\n+\tprivate static final String DEFINITION_MULTI_CUSTOM_STRING = CLASS_MULTI_CUSTOM\n+\t\t\t+ \".convertCustomString(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)Ljava\/lang\/String;\";\n+\tprivate static final String DEFINITION_MULTI_DEFAULT_GURKA = CLASS_MULTI_DEFAULT\n+\t\t\t+ \".convert(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)I\";\n+\tprivate static final String DEFINITION_MULTI_DEFAULT_STRING = CLASS_MULTI_DEFAULT + \".convert(Ljava\/lang\/String;)I\";\n+\tprivate static final String DEFINITION_MULTI_DEFAULT_DOUBLE = CLASS_MULTI_DEFAULT + \".convert(Ljava\/lang\/Double;)I\";\n+\tprivate static final String DEFINITION_MULTI_DEFAULT_INTEGER = CLASS_MULTI_DEFAULT\n+\t\t\t+ \".convert(Ljava\/lang\/Integer;)I\";\n+\tprivate static final String DEFINITION_MULTI_DEFAULT_EXCEPTION = CLASS_MULTI_DEFAULT\n+\t\t\t+ \".convert(java\/lang\/Exception;)I\";\n+\n+\tpublic static int convert(Gurka gurka) {\n+\t\treturn (int) gurka.getID();\n+\t}\n+\n+\tpublic static int convert(String string) {\n+\t\treturn (int) Integer.valueOf(string);\n+\t}\n+\n+\tpublic static String convert(Exception exception) {\n+\t\treturn exception.getMessage();\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveDefault() throws MalformedConverterException {\n+\t\tResolvedConvertable convertable = new ResolvedConvertable(CLASS_GURK_INT, Gurka.class);\n+\t\tassertEquals(CLASS_GURK_INT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveDefaultSpecified() throws MalformedConverterException {\n+\t\tResolvedConvertable convertable = new ResolvedConvertable(DEFINITION_GURK_INT_DEFAULT_METHOD, Gurka.class);\n+\t\tassertEquals(CLASS_GURK_INT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveCustom() throws MalformedConverterException {\n+\t\tResolvedConvertable convertable = new ResolvedConvertable(DEFINITION_CUSTOM_INT, Gurka.class);\n+\t\tassertEquals(CLASS_CUSTOM_INT, convertable.getConverterClass().getName());\n+\t\tassertEquals(\"convertCustom\", convertable.getConverterMethod().getName());\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveMulti() throws MalformedConverterException {\n+\t\tResolvedConvertable convertable = new ResolvedConvertable(DEFINITION_MULTI_CUSTOM_INT, Gurka.class);\n+\t\tassertEquals(CLASS_MULTI_CUSTOM, convertable.getConverterClass().getName());\n+\t\tassertEquals(\"convertCustomInt\", convertable.getConverterMethod().getName());\n+\n+\t\tconvertable = new ResolvedConvertable(DEFINITION_MULTI_CUSTOM_DOUBLE, Gurka.class);\n+\t\tassertEquals(CLASS_MULTI_CUSTOM, convertable.getConverterClass().getName());\n+\t\tassertEquals(\"convertCustomDouble\", convertable.getConverterMethod().getName());\n+\n+\t\tconvertable = new ResolvedConvertable(DEFINITION_MULTI_CUSTOM_STRING, Gurka.class);\n+\t\tassertEquals(CLASS_MULTI_CUSTOM, convertable.getConverterClass().getName());\n+\t\tassertEquals(\"convertCustomString\", convertable.getConverterMethod().getName());\n+\n+\t\ttry {\n+\t\t\tnew ResolvedConvertable(CLASS_MULTI_CUSTOM, Gurka.class);\n+\t\t\tassertTrue(\"Should have reached an exception\", false);\n+\t\t} catch (MalformedConverterException e) {\n+\t\t}\n+\t}\n+\n+\t\/*\n+\t * public static int convert(Gurka gurka) { return (int) gurka.getID(); }\n+\t * \n+\t * public static int convert(String string) { return (int) Integer.valueOf(string); }\n+\t * \n+\t * public static String convert(Exception exception) { return exception.getMessage(); }\n+\t * \n+\t * public static int convert(Double value) { return value.intValue(); }\n+\t * \n+\t * public static int convert(Integer value) { return value.intValue(); } }\n+\t *\/\n+\t@Test\n+\tpublic void testResolveMultiDefaults() throws MalformedConverterException {\n+\t\tResolvedConvertable convertable = new ResolvedConvertable(DEFINITION_MULTI_DEFAULT_GURKA, Gurka.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(int.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(CLASS_MULTI_DEFAULT, Gurka.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(int.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(DEFINITION_MULTI_DEFAULT_STRING, String.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(int.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(CLASS_MULTI_DEFAULT, String.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(int.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(DEFINITION_MULTI_DEFAULT_EXCEPTION, Exception.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(String.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(CLASS_MULTI_DEFAULT, Exception.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(String.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(DEFINITION_MULTI_DEFAULT_INTEGER, Integer.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(int.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(CLASS_MULTI_DEFAULT, Integer.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(int.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(DEFINITION_MULTI_DEFAULT_DOUBLE, Double.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(int.class, convertable.getConverterMethod().getReturnType());\n+\n+\t\tconvertable = new ResolvedConvertable(CLASS_MULTI_DEFAULT, Double.class);\n+\t\tassertEquals(CLASS_MULTI_DEFAULT, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(int.class, convertable.getConverterMethod().getReturnType());\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveMultiDefaultsWrongReturnType() throws MalformedConverterException {\n+\t\ttry {\n+\t\t\tnew ResolvedConvertable(DEFINITION_MULTI_DEFAULT_EXCEPTION, Class.class);\n+\t\t\tassertTrue(\"Should have reached an exception\", false);\n+\t\t} catch (MalformedConverterException e) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveSubclass() throws MalformedConverterException {\n+\t\tResolvedConvertable convertable = new ResolvedConvertable(CLASS_NUMBER_CONVERTER, Double.class);\n+\t\tassertEquals(CLASS_NUMBER_CONVERTER, convertable.getConverterClass().getName());\n+\t\tassertEquals(ResolvedConvertable.DEFAULT_CONVERTER_METHOD, convertable.getConverterMethod().getName());\n+\t\tassertEquals(long.class, convertable.getConverterMethod().getReturnType());\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveCustomWithoutMethodSpecified() throws MalformedConverterException {\n+\t\ttry {\n+\t\t\tnew ResolvedConvertable(CLASS_CUSTOM_INT, Gurka.class);\n+\t\t\tassertTrue(\"Should have reached an exception\", false);\n+\t\t} catch (MalformedConverterException e) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveDefaultWrongArgumentType() throws MalformedConverterException {\n+\t\ttry {\n+\t\t\tnew ResolvedConvertable(CLASS_GURK_INT, Double.class);\n+\t\t\tassertTrue(\"Should have reached an exception\", false);\n+\t\t} catch (MalformedConverterException e) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveNoType() throws MalformedConverterException {\n+\t\ttry {\n+\t\t\tnew ResolvedConvertable(CLASS_GURK_INT, (Class<?>) null);\n+\t\t\tassertTrue(\"Should have reached an exception\", false);\n+\t\t} catch (MalformedConverterException e) {\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testResolveMalformed() throws MalformedConverterException {\n+\t\ttry {\n+\t\t\tnew ResolvedConvertable(CLASS_MALFORMED, int.class);\n+\t\t\tassertTrue(\"Should have reached an exception\", false);\n+\t\t} catch (MalformedConverterException e) {\n+\t\t}\n+\t}\n+\n+}\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/converters\/test\/TestResolver.java","additions":242,"deletions":0,"binary":false,"changes":242,"status":"added"},{"patch":"@@ -52,1 +52,1 @@\n-\tpublic final static Gurka createGurka() {\n+\tpublic static final Gurka createGurka() {\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/test\/Gurka.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-\tprivate final static class Runner implements Runnable {\n+\tprivate static final class Runner implements Runnable {\n","filename":"agent\/src\/test\/java\/org\/openjdk\/jmc\/agent\/test\/InstrumentMe.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -228,0 +228,119 @@\n+\t\t<event id=\"demo.jfr.convertertest.URI\">\n+\t\t\t<name>ConverterEventNumber<\/name>\n+\t\t\t<description>Defined in the xml file and added by the agent. Should\n+\t\t\t\ttransform the Number parameter to a\n+\t\t\t\tdouble.\n+\t\t\t<\/description>\n+\t\t\t<path>demo\/converterevents<\/path>\n+\t\t\t<stacktrace>true<\/stacktrace>\n+\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter\n+\t\t\t<\/class>\n+\t\t\t<method>\n+\t\t\t\t<name>printNumber<\/name>\n+\t\t\t\t<descriptor>(Ljava\/lang\/Number;)V<\/descriptor>\n+\t\t\t\t<parameters>\n+\t\t\t\t\t<parameter index=\"0\">\n+\t\t\t\t\t\t<name>Number<\/name>\n+\t\t\t\t\t\t<description>The converted Number-parameter<\/description>\n+\t\t\t\t\t\t<contenttype>None<\/contenttype>\n+\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.ConverterNumber\n+\t\t\t\t\t\t<\/converter>\n+\t\t\t\t\t<\/parameter>\n+\t\t\t\t<\/parameters>\n+\t\t\t<\/method>\n+\t\t\t<location>WRAP<\/location>\n+\t\t<\/event>\n+\n+\t\t<!-- Multi and custom converters -->\n+\t\t<event id=\"demo.jfr.convertertest.URI\">\n+\t\t\t<name>ConverterEventMultiCustomInt<\/name>\n+\t\t\t<description>Testing picking the right method.\n+\t\t\t<\/description>\n+\t\t\t<path>demo\/converterevents<\/path>\n+\t\t\t<stacktrace>true<\/stacktrace>\n+\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter\n+\t\t\t<\/class>\n+\t\t\t<method>\n+\t\t\t\t<name>printIntMultiCustom<\/name>\n+\t\t\t\t<descriptor>(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)V<\/descriptor>\n+\t\t\t\t<parameters>\n+\t\t\t\t\t<parameter index=\"0\">\n+\t\t\t\t\t\t<name>Number as Int<\/name>\n+\t\t\t\t\t\t<description>The converted Gurk-parameter<\/description>\n+\t\t\t\t\t\t<contenttype>None<\/contenttype>\n+\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkMultiCustomConverter.convertCustomInt(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)I\n+\t\t\t\t\t\t<\/converter>\n+\t\t\t\t\t<\/parameter>\n+\t\t\t\t<\/parameters>\n+\t\t\t<\/method>\n+\t\t\t<location>WRAP<\/location>\n+\t\t<\/event>\n+\t\t<event id=\"demo.jfr.convertertest.URI\">\n+\t\t\t<name>ConverterEventMultiCustomDouble<\/name>\n+\t\t\t<description>Testing picking the right method.\n+\t\t\t<\/description>\n+\t\t\t<path>demo\/converterevents<\/path>\n+\t\t\t<stacktrace>true<\/stacktrace>\n+\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter\n+\t\t\t<\/class>\n+\t\t\t<method>\n+\t\t\t\t<name>printDoubleMultiCustom<\/name>\n+\t\t\t\t<descriptor>(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)V<\/descriptor>\n+\t\t\t\t<parameters>\n+\t\t\t\t\t<parameter index=\"0\">\n+\t\t\t\t\t\t<name>Number as Double<\/name>\n+\t\t\t\t\t\t<description>The converted Gurk-parameter<\/description>\n+\t\t\t\t\t\t<contenttype>None<\/contenttype>\n+\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkMultiCustomConverter.convertCustomDouble(Lorg\/openjdk\/jmc\/agent\/test\/Gurka;)D\n+\t\t\t\t\t\t<\/converter>\n+\t\t\t\t\t<\/parameter>\n+\t\t\t\t<\/parameters>\n+\t\t\t<\/method>\n+\t\t\t<location>WRAP<\/location>\n+\t\t<\/event>\n+\t\t<event id=\"demo.jfr.convertertest.URI\">\n+\t\t\t<name>ConverterEventMultiDefaultLong<\/name>\n+\t\t\t<description>Testing picking the right method.\n+\t\t\t<\/description>\n+\t\t\t<path>demo\/converterevents<\/path>\n+\t\t\t<stacktrace>true<\/stacktrace>\n+\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter\n+\t\t\t<\/class>\n+\t\t\t<method>\n+\t\t\t\t<name>printLongMultiDefault<\/name>\n+\t\t\t\t<descriptor>(Ljava\/lang\/Long;)V<\/descriptor>\n+\t\t\t\t<parameters>\n+\t\t\t\t\t<parameter index=\"0\">\n+\t\t\t\t\t\t<name>Long as int<\/name>\n+\t\t\t\t\t\t<description>The converted Long-parameter<\/description>\n+\t\t\t\t\t\t<contenttype>None<\/contenttype>\n+\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkMultiDefaultConverter\n+\t\t\t\t\t\t<\/converter>\n+\t\t\t\t\t<\/parameter>\n+\t\t\t\t<\/parameters>\n+\t\t\t<\/method>\n+\t\t\t<location>WRAP<\/location>\n+\t\t<\/event>\n+\t\t<event id=\"demo.jfr.convertertest.URI\">\n+\t\t\t<name>ConverterEventMultiDefaultDouble<\/name>\n+\t\t\t<description>Testing picking the right method.\n+\t\t\t<\/description>\n+\t\t\t<path>demo\/converterevents<\/path>\n+\t\t\t<stacktrace>true<\/stacktrace>\n+\t\t\t<class>org.openjdk.jmc.agent.converters.test.InstrumentMeConverter\n+\t\t\t<\/class>\n+\t\t\t<method>\n+\t\t\t\t<name>printDoubleMultiDefault<\/name>\n+\t\t\t\t<descriptor>(Ljava\/lang\/Double;)V<\/descriptor>\n+\t\t\t\t<parameters>\n+\t\t\t\t\t<parameter index=\"0\">\n+\t\t\t\t\t\t<name>Double as Int<\/name>\n+\t\t\t\t\t\t<description>The converted Double-parameter<\/description>\n+\t\t\t\t\t\t<contenttype>None<\/contenttype>\n+\t\t\t\t\t\t<converter>org.openjdk.jmc.agent.converters.test.GurkMultiDefaultConverter\n+\t\t\t\t\t\t<\/converter>\n+\t\t\t\t\t<\/parameter>\n+\t\t\t\t<\/parameters>\n+\t\t\t<\/method>\n+\t\t\t<location>WRAP<\/location>\n+\t\t<\/event>\n@@ -229,1 +348,1 @@\n-<\/jfragent>\n\\ No newline at end of file\n+<\/jfragent>\n","filename":"agent\/src\/test\/resources\/org\/openjdk\/jmc\/agent\/converters\/test\/jfrprobes_template.xml","additions":120,"deletions":1,"binary":false,"changes":121,"status":"modified"}]}