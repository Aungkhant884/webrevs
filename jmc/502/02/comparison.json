{"files":[{"patch":"@@ -36,12 +36,0 @@\n-import io.github.bric3.fireplace.core.ui.Colors;\n-import io.github.bric3.fireplace.flamegraph.ColorMapper;\n-import io.github.bric3.fireplace.flamegraph.DimmingFrameColorProvider;\n-import io.github.bric3.fireplace.flamegraph.FlamegraphImage;\n-import io.github.bric3.fireplace.flamegraph.FlamegraphView;\n-import io.github.bric3.fireplace.flamegraph.FrameBox;\n-import io.github.bric3.fireplace.flamegraph.FrameFontProvider;\n-import io.github.bric3.fireplace.flamegraph.FrameModel;\n-import io.github.bric3.fireplace.flamegraph.FrameTextsProvider;\n-import io.github.bric3.fireplace.flamegraph.animation.ZoomAnimation;\n-import io.github.bric3.fireplace.swt_awt.EmbeddingComposite;\n-import io.github.bric3.fireplace.swt_awt.SWT_AWTBridge;\n@@ -57,0 +45,1 @@\n+import java.time.Duration;\n@@ -78,0 +67,1 @@\n+\n@@ -85,0 +75,1 @@\n+\n@@ -128,0 +119,13 @@\n+import io.github.bric3.fireplace.core.ui.Colors;\n+import io.github.bric3.fireplace.flamegraph.ColorMapper;\n+import io.github.bric3.fireplace.flamegraph.DimmingFrameColorProvider;\n+import io.github.bric3.fireplace.flamegraph.FlamegraphImage;\n+import io.github.bric3.fireplace.flamegraph.FlamegraphView;\n+import io.github.bric3.fireplace.flamegraph.FrameBox;\n+import io.github.bric3.fireplace.flamegraph.FrameFontProvider;\n+import io.github.bric3.fireplace.flamegraph.FrameModel;\n+import io.github.bric3.fireplace.flamegraph.FrameTextsProvider;\n+import io.github.bric3.fireplace.flamegraph.animation.ZoomAnimation;\n+import io.github.bric3.fireplace.swt_awt.EmbeddingComposite;\n+import io.github.bric3.fireplace.swt_awt.SWT_AWTBridge;\n+\n@@ -332,23 +336,30 @@\n-\t\t\tview.modelState = ModelState.STARTED;\n-\t\t\tif (isInvalid) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tvar filteredItems = items;\n-\t\t\tif (attribute != null) {\n-\t\t\t\tfilteredItems = filteredItems.apply(ItemFilters.hasAttribute(attribute));\n-\t\t\t}\n-\t\t\tvar treeModel = new StacktraceTreeModel(filteredItems, view.frameSeparator, !view.threadRootAtTop,\n-\t\t\t\t\tattribute);\n-\t\t\tif (isInvalid) {\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\tvar rootFrameDescription = createRootNodeDescription(items);\n-\t\t\tvar frameBoxList = convert(treeModel);\n-\t\t\tif (!isInvalid) {\n-\t\t\t\tview.modelState = ModelState.FINISHED;\n-\t\t\t\tview.setModel(items, frameBoxList, rootFrameDescription);\n-\t\t\t\tDisplayToolkit.inDisplayThread().execute(() -> {\n-\t\t\t\t\tvar attributeList = AttributeSelection.extractAttributes(items);\n-\t\t\t\t\tString attrName = attribute != null ? attribute.getName() : null;\n-\t\t\t\t\tview.createAttributeSelection(attrName, attributeList);\n-\t\t\t\t});\n+\t\t\tfinal var start = System.currentTimeMillis();\n+\t\t\ttry {\n+\t\t\t\tview.modelState = ModelState.STARTED;\n+\t\t\t\tif (isInvalid) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tvar filteredItems = items;\n+\t\t\t\tif (attribute != null) {\n+\t\t\t\t\tfilteredItems = filteredItems.apply(ItemFilters.hasAttribute(attribute));\n+\t\t\t\t}\n+\t\t\t\tvar treeModel = new StacktraceTreeModel(filteredItems, view.frameSeparator, !view.threadRootAtTop,\n+\t\t\t\t\t\tattribute, () -> isInvalid);\n+\t\t\t\tif (isInvalid) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tvar rootFrameDescription = createRootNodeDescription(items);\n+\t\t\t\tvar frameBoxList = convert(treeModel);\n+\t\t\t\tif (!isInvalid) {\n+\t\t\t\t\tview.modelState = ModelState.FINISHED;\n+\t\t\t\t\tview.setModel(items, frameBoxList, rootFrameDescription);\n+\t\t\t\t\tDisplayToolkit.inDisplayThread().execute(() -> {\n+\t\t\t\t\t\tvar attributeList = AttributeSelection.extractAttributes(items);\n+\t\t\t\t\t\tString attrName = attribute != null ? attribute.getName() : null;\n+\t\t\t\t\t\tview.createAttributeSelection(attrName, attributeList);\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\t\t\t} finally {\n+\t\t\t\tfinal var duration = Duration.ofMillis(System.currentTimeMillis() - start);\n+\t\t\t\tFlightRecorderUI.getDefault().getLogger()\n+\t\t\t\t\t\t.info(\"model rebuild with isInvalid:\" + isInvalid + \" in \" + duration);\n@@ -670,5 +681,3 @@\n-\t\t\tfd.setFilterNames(new String[]{\n-\t\t\t\t\tgetFlamegraphMessage(FLAMEVIEW_PNG_IMAGE),\n-\t\t\t\t\tgetFlamegraphMessage(FLAMEVIEW_JPEG_IMAGE)\n-\t\t\t});\n-\t\t\tfd.setFilterExtensions(new String[]{\"*.png\", \"*.jpg\"}); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n+\t\t\tfd.setFilterNames(new String[] {getFlamegraphMessage(FLAMEVIEW_PNG_IMAGE),\n+\t\t\t\t\tgetFlamegraphMessage(FLAMEVIEW_JPEG_IMAGE)});\n+\t\t\tfd.setFilterExtensions(new String[] {\"*.png\", \"*.jpg\"}); \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n@@ -697,1 +706,1 @@\n-\t\t\t\t\t\t\t\t\tfalse, false, false, true, false),\n+\t\t\t\t\t\t\t\t\t\t\tfalse, false, false, true, false),\n@@ -707,55 +716,42 @@\n-\t\tOptional.of(future)\n-\t\t\t\t.map(f -> {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\treturn f.get();\n-\t\t\t\t\t} catch (CancellationException e) {\n-\t\t\t\t\t\t\/\/ noop : model calculation is canceled when is still running\n-\t\t\t\t\t} catch (InterruptedException | ExecutionException e) {\n-\t\t\t\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.SEVERE, \"Failed to save flame graph\", e); \/\/$NON-NLS-1$\n-\t\t\t\t\t}\n-\t\t\t\t\treturn null;\n-\t\t\t\t})\n-\t\t\t\t.ifPresent(destinationPath -> {\n-\t\t\t\t\t\/\/ make spotbugs happy about NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\n-\t\t\t\t\tvar type = Optional.ofNullable(destinationPath.getFileName())\n-\t\t\t\t\t\t\t.map(p -> p.toString().toLowerCase())\n-\t\t\t\t\t\t\t.map(f ->\n-\t\t\t\t\t\t\t\t\tswitch (f.substring(f.lastIndexOf('.') + 1)) { \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\t\t\t\tcase \"jpeg\", \"jpg\" -> \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n-\t\t\t\t\t\t\t\t\t\t\t\t\"jpg\"; \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\t\t\t\tcase \"png\" -> \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\t\t\t\t\t\t\"png\"; \/\/$NON-NLS-1$\n-\t\t\t\t\t\t\t\t\t\tdefault -> null;\n-\t\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t).orElseThrow(() -> new IllegalStateException(\"Unhandled type for \" + destinationPath));\n-\n-\t\t\t\t\ttry (var os = new BufferedOutputStream(Files.newOutputStream(destinationPath))) {\n-\t\t\t\t\t\tvar renderImg = generator.get();\n-\n-\t\t\t\t\t\tvar img = switch (type) {\n-\t\t\t\t\t\t\tcase \"png\" -> renderImg;\n-\t\t\t\t\t\t\tcase \"jpg\" -> {\n-\t\t\t\t\t\t\t\t\/\/ JPG does not have an alpha channel, and ImageIO.write will simply write a 0 byte file\n-\t\t\t\t\t\t\t\t\/\/ to workaround this it is required to copy the image to a BufferedImage without alpha channel\n-\t\t\t\t\t\t\t\tvar newBufferedImage = new BufferedImage(\n-\t\t\t\t\t\t\t\t\t\trenderImg.getWidth(),\n-\t\t\t\t\t\t\t\t\t\trenderImg.getHeight(),\n-\t\t\t\t\t\t\t\t\t\tBufferedImage.TYPE_INT_RGB\n-\t\t\t\t\t\t\t\t);\n-\t\t\t\t\t\t\t\trenderImg.copyData(newBufferedImage.getRaster());\n-\n-\t\t\t\t\t\t\t\tyield newBufferedImage;\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tdefault -> throw new IllegalStateException(\"Type is checked above\");\n-\t\t\t\t\t\t};\n-\n-\n-\t\t\t\t\t\tImageIO.write(\n-\t\t\t\t\t\t\t\timg,\n-\t\t\t\t\t\t\t\ttype,\n-\t\t\t\t\t\t\t\tos\n-\t\t\t\t\t\t);\n-\t\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.SEVERE, \"Failed to save flame graph\", e); \/\/$NON-NLS-1$\n-\t\t\t\t\t}\n-\t\t\t\t});\n+\t\tOptional.of(future).map(f -> {\n+\t\t\ttry {\n+\t\t\t\treturn f.get();\n+\t\t\t} catch (CancellationException e) {\n+\t\t\t\t\/\/ noop : model calculation is canceled when is still running\n+\t\t\t} catch (InterruptedException | ExecutionException e) {\n+\t\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.SEVERE, \"Failed to save flame graph\", e); \/\/$NON-NLS-1$\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}).ifPresent(destinationPath -> {\n+\t\t\t\/\/ make spotbugs happy about NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\n+\t\t\tvar type = Optional.ofNullable(destinationPath.getFileName()).map(p -> p.toString().toLowerCase())\n+\t\t\t\t\t.map(f -> switch (f.substring(f.lastIndexOf('.') + 1)) { \/\/$NON-NLS-1$\n+\t\t\t\t\tcase \"jpeg\", \"jpg\" -> \/\/$NON-NLS-1$ \/\/$NON-NLS-2$\n+\t\t\t\t\t\t\t\"jpg\"; \/\/$NON-NLS-1$\n+\t\t\t\t\tcase \"png\" -> \/\/$NON-NLS-1$\n+\t\t\t\t\t\t\t\"png\"; \/\/$NON-NLS-1$\n+\t\t\t\t\tdefault -> null;\n+\t\t\t\t\t}).orElseThrow(() -> new IllegalStateException(\"Unhandled type for \" + destinationPath));\n+\n+\t\t\ttry (var os = new BufferedOutputStream(Files.newOutputStream(destinationPath))) {\n+\t\t\t\tvar renderImg = generator.get();\n+\n+\t\t\t\tvar img = switch (type) {\n+\t\t\t\tcase \"png\" -> renderImg;\n+\t\t\t\tcase \"jpg\" -> {\n+\t\t\t\t\t\/\/ JPG does not have an alpha channel, and ImageIO.write will simply write a 0 byte file\n+\t\t\t\t\t\/\/ to workaround this it is required to copy the image to a BufferedImage without alpha channel\n+\t\t\t\t\tvar newBufferedImage = new BufferedImage(renderImg.getWidth(), renderImg.getHeight(),\n+\t\t\t\t\t\t\tBufferedImage.TYPE_INT_RGB);\n+\t\t\t\t\trenderImg.copyData(newBufferedImage.getRaster());\n+\n+\t\t\t\t\tyield newBufferedImage;\n+\t\t\t\t}\n+\t\t\t\tdefault -> throw new IllegalStateException(\"Type is checked above\");\n+\t\t\t\t};\n+\n+\t\t\t\tImageIO.write(img, type, os);\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.SEVERE, \"Failed to save flame graph\", e); \/\/$NON-NLS-1$\n+\t\t\t}\n+\t\t});\n","filename":"application\/org.openjdk.jmc.flightrecorder.flamegraph\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/flamegraph\/views\/FlamegraphSwingView.java","additions":92,"deletions":96,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -8,0 +8,5 @@\n+\t\t<buildCommand>\n+\t\t\t<name>org.eclipse.pde.FeatureBuilder<\/name>\n+\t\t\t<arguments>\n+\t\t\t<\/arguments>\n+\t\t<\/buildCommand>\n@@ -15,0 +20,1 @@\n+\t\t<nature>org.eclipse.pde.FeatureNature<\/nature>\n","filename":"application\/org.openjdk.jmc.rcp.product.feature\/.project","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n-\t<classpathentry kind=\"src\" output=\"target\/classes\" path=\"src\/main\/java\"\/>\n@@ -6,0 +5,1 @@\n+\t<classpathentry kind=\"src\" path=\"src\/main\/java\/\"\/>\n","filename":"application\/org.openjdk.jmc.rjmx.ext\/.classpath","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,2 +3,0 @@\n-\t<classpathentry kind=\"src\" output=\"target\/classes\" path=\"src\/main\/java\"\/>\n-\t<classpathentry kind=\"src\" output=\"target\/classes\" path=\"src\/main\/resources\"\/>\n@@ -7,0 +5,2 @@\n+\t<classpathentry kind=\"src\" path=\"src\/main\/java\/\"\/>\n+\t<classpathentry kind=\"src\" path=\"src\/main\/resources\/\"\/>\n","filename":"application\/org.openjdk.jmc.rjmx.services.jfr\/.classpath","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,2 +3,0 @@\n-\t<classpathentry kind=\"src\" output=\"target\/classes\" path=\"src\/main\/java\"\/>\n-\t<classpathentry kind=\"src\" output=\"target\/classes\" path=\"src\/main\/resources\"\/>\n@@ -7,0 +5,2 @@\n+\t<classpathentry kind=\"src\" path=\"src\/main\/java\/\"\/>\n+\t<classpathentry kind=\"src\" path=\"src\/main\/resources\/\"\/>\n","filename":"application\/org.openjdk.jmc.rjmx.ui\/.classpath","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,2 +3,0 @@\n-\t<classpathentry kind=\"src\" output=\"target\/classes\" path=\"src\/main\/java\"\/>\n-\t<classpathentry kind=\"src\" output=\"target\/classes\" path=\"src\/main\/resources\"\/>\n@@ -7,0 +5,2 @@\n+\t<classpathentry kind=\"src\" path=\"src\/main\/java\/\"\/>\n+\t<classpathentry kind=\"src\" path=\"src\/main\/resources\/\"\/>\n","filename":"application\/org.openjdk.jmc.ui.common\/.classpath","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,6 @@\n-\t\tCLASS(Messages.getString(Messages.STACKTRACE_CLASS)),\n+\t\tCLASS(Messages.getString(Messages.STACKTRACE_CLASS)) {\n+\t\t\t@Override\n+\t\t\tprotected Object getCategory(IMCFrame frame) {\n+\t\t\t\treturn frame.getMethod().getType();\n+\t\t\t}\n+\t\t},\n@@ -70,1 +75,6 @@\n-\t\tPACKAGE(Messages.getString(Messages.STACKTRACE_PACKAGE));\n+\t\tPACKAGE(Messages.getString(Messages.STACKTRACE_PACKAGE)) {\n+\t\t\t@Override\n+\t\t\tprotected Object getCategory(IMCFrame frame) {\n+\t\t\t\treturn frame.getMethod().getType().getPackage();\n+\t\t\t}\n+\t\t};\n@@ -81,0 +91,4 @@\n+\n+\t\tprotected Object getCategory(IMCFrame frame) {\n+\t\t\treturn frame.getMethod();\n+\t\t}\n@@ -118,8 +132,1 @@\n-\t\tswitch (categorization) {\n-\t\tcase PACKAGE:\n-\t\t\treturn frame.getMethod().getType().getPackage();\n-\t\tcase CLASS:\n-\t\t\treturn frame.getMethod().getType();\n-\t\tdefault:\n-\t\t\treturn frame.getMethod();\n-\t\t}\n+\t\treturn categorization.getCategory(frame);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/FrameSeparator.java","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -45,4 +45,0 @@\n-\t\/**\n-\t * Integer uniquely identifying this node within our data structure.\n-\t *\/\n-\tprivate final Integer nodeId;\n@@ -80,1 +76,0 @@\n-\t\tthis.nodeId = computeNodeId(parent, frame);\n@@ -88,11 +83,0 @@\n-\tprivate static Integer computeNodeId(Node parent, AggregatableFrame frame) {\n-\t\treturn Objects.hash(parent != null ? parent.getNodeId() : null, frame.hashCode());\n-\t}\n-\n-\t\/**\n-\t * @return the unique identifier associated with this node.\n-\t *\/\n-\tpublic Integer getNodeId() {\n-\t\treturn nodeId;\n-\t}\n-\n@@ -158,1 +142,1 @@\n-\t\treturn Objects.equals(nodeId, other.nodeId) && Objects.equals(frame, other.frame) && weight == other.weight\n+\t\treturn Objects.equals(parent, other.parent) && Objects.equals(frame, other.frame) && weight == other.weight\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/tree\/Node.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import static org.openjdk.jmc.flightrecorder.JfrAttributes.EVENT_STACKTRACE;\n-\n@@ -39,0 +37,1 @@\n+import java.util.function.BooleanSupplier;\n@@ -53,0 +52,2 @@\n+import static org.openjdk.jmc.flightrecorder.JfrAttributes.EVENT_STACKTRACE;\n+\n@@ -135,0 +136,25 @@\n+\t\tthis(items, frameSeparator, invertedStacks, attribute, () -> false);\n+\t}\n+\n+\t\/**\n+\t * Builds a StacktraceTreeModel from a given collection of events. Given that creating this\n+\t * object can be very time consuming, this constructor supports early termination using the stop\n+\t * flag. If the constructor was terminated using the stop flag the object is in an invalid state\n+\t * and should not be used.\n+\t *\n+\t * @param items\n+\t *            the data we want to represent.\n+\t * @param frameSeparator\n+\t *            defines what represents a node in the tree. Defaults to METHOD.\n+\t * @param invertedStacks\n+\t *            defines how the stacks are aggregated. Defaults to false (i.e. bottom-up,\n+\t *            Thread.run() at the root of the tree).\n+\t * @param attribute\n+\t *            defines what we use as node weights. If null, the weight is the number of\n+\t *            occurrences for the frame.\n+\t * @param stopFlag\n+\t *            enables concurrent interruption. The stop flag is polled and if it every returns\n+\t *            true the constructor will return early.\n+\t *\/\n+\tpublic StacktraceTreeModel(IItemCollection items, FrameSeparator frameSeparator, boolean invertedStacks,\n+\t\t\tIAttribute<IQuantity> attribute, BooleanSupplier stopFlag) {\n@@ -143,0 +169,3 @@\n+\t\t\tif (stopFlag.getAsBoolean()) {\n+\t\t\t\treturn;\n+\t\t\t}\n@@ -148,1 +177,6 @@\n-\t\t\titerable.forEach((item) -> addItem(item, stacktraceAccessor, quantityAccessor));\n+\t\t\tfor (final var item : iterable) {\n+\t\t\t\tif (stopFlag.getAsBoolean()) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\taddItem(item, stacktraceAccessor, quantityAccessor);\n+\t\t\t}\n@@ -223,7 +257,13 @@\n-\t\treturn parent.children.stream()\n-\t\t\t\t\/\/ TODO: consider a map lookup instead of linear search\n-\t\t\t\t.filter(child -> child.getFrame().equals(frame)).findAny().orElseGet(() -> {\n-\t\t\t\t\tNode result = new Node(parent, frame);\n-\t\t\t\t\tparent.children.add(result);\n-\t\t\t\t\treturn result;\n-\t\t\t\t});\n+\t\tNode result = null;\n+\t\t\/\/ TODO: consider a map lookup instead of linear search\n+\t\tfor (final var child : parent.children) {\n+\t\t\tif (child.getFrame().equals(frame)) {\n+\t\t\t\tresult = child;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\tif (result == null) {\n+\t\t\tresult = new Node(parent, frame);\n+\t\t\tparent.children.add(result);\n+\t\t}\n+\t\treturn result;\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/tree\/StacktraceTreeModel.java","additions":50,"deletions":10,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -92,0 +92,19 @@\n+\t@Test\n+\tpublic void testTreeModelStopFlag() {\n+\t\t\/\/ when the stop flag is always set from the start the nodes should not be populated past the root\n+\t\t{\n+\t\t\tfinal var model = new StacktraceTreeModel(testRecording, separator, false, JdkAttributes.ALLOCATION_SIZE,\n+\t\t\t\t\t() -> true);\n+\t\t\tfinal var root = model.getRoot();\n+\t\t\tassertEquals(0, root.getChildren().size());\n+\t\t}\n+\t\t\/\/ sanity check that when the stop flag is never set the root node contains at least something\n+\t\t\/\/ the rest of the expected content of the nodes is checked in other tests\n+\t\t{\n+\t\t\tfinal var model = new StacktraceTreeModel(testRecording, separator, false, JdkAttributes.ALLOCATION_SIZE,\n+\t\t\t\t\t() -> false);\n+\t\t\tfinal var root = model.getRoot();\n+\t\t\tassertEquals(3, root.getChildren().size());\n+\t\t}\n+\t}\n+\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/StacktraceTreeModelTest.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"}]}