{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+import static org.openjdk.jmc.common.unit.UnitLookup.MINUTE;\n+import static org.openjdk.jmc.common.unit.UnitLookup.TIMESPAN;\n@@ -104,0 +106,5 @@\n+\tpublic static final TypedPreference<IQuantity> ClassLeakingRule_MAX_TIMEOUT = new TypedPreference<>(\n+\t\t\t\"classLeaking.calculation.timeout\", \/\/$NON-NLS-1$\n+\t\t\tMessages.getString(Messages.ClassLeakingRule_CONFIG_CALCULATION_TIMEOUT),\n+\t\t\tMessages.getString(Messages.ClassLeakingRule_CONFIG_CALCULATION_TIMEOUT_LONG), TIMESPAN,\n+\t\t\tMINUTE.quantity(5));\n@@ -105,1 +112,1 @@\n-\t\t\tMAX_NUMBER_OF_CLASSES_TO_REPORT);\n+\t\t\tMAX_NUMBER_OF_CLASSES_TO_REPORT, ClassLeakingRule_MAX_TIMEOUT);\n@@ -148,1 +155,2 @@\n-\t\tIItemCollection items, IPreferenceValueProvider valueProvider, IResultValueProvider dependencyResults) {\n+\t\tIItemCollection items, IPreferenceValueProvider valueProvider, IResultValueProvider dependencyResults,\n+\t\tint timeout) {\n@@ -150,0 +158,2 @@\n+\t\tint configuredTimeout = (int) valueProvider.getPreferenceValue(ClassLeakingRule_MAX_TIMEOUT)\n+\t\t\t\t.clampedLongValueIn(UnitLookup.MINUTE);\n@@ -155,1 +165,1 @@\n-\t\tMap<String, ClassEntry> entriesLoad = extractClassEntriesFromQuery(items, queryLoad.build());\n+\t\tMap<String, ClassEntry> entriesLoad = extractClassEntriesFromQuery(items, queryLoad.build(), configuredTimeout);\n@@ -162,1 +172,2 @@\n-\t\tMap<String, ClassEntry> entriesUnload = extractClassEntriesFromQuery(items, queryUnload.build());\n+\t\tMap<String, ClassEntry> entriesUnload = extractClassEntriesFromQuery(items, queryUnload.build(),\n+\t\t\t\tconfiguredTimeout);\n@@ -173,2 +184,4 @@\n-\t\t\tfor (int i = 0; i < classLimit; i++) {\n-\t\t\t\tClassEntry entry = entries.get(i);\n+\n+\t\t\tint totalEntries = entries.size() - 1;\n+\t\t\tfor (int i = 0, j = totalEntries; i < classLimit; i++, j--) {\n+\t\t\t\tClassEntry entry = entries.get(j);\n@@ -179,1 +192,1 @@\n-\t\t\tClassEntry worst = entries.get(0);\n+\t\t\tClassEntry worst = entries.get(totalEntries);\n@@ -218,1 +231,2 @@\n-\tprivate Map<String, ClassEntry> extractClassEntriesFromQuery(IItemCollection items, IItemQuery query) {\n+\tprivate Map<String, ClassEntry> extractClassEntriesFromQuery(\n+\t\tIItemCollection items, IItemQuery query, int configuredTimeout) {\n@@ -220,1 +234,1 @@\n-\t\tIItemResultSet resultSet = new ItemResultSetFactory().createResultSet(items, query);\n+\t\tIItemResultSet resultSet = new ItemResultSetFactory().createResultSet(items, query, configuredTimeout);\n@@ -250,1 +264,3 @@\n-\t\t\t\treturn getResult(items, preferenceValueProvider, dependencyResults);\n+\t\t\t\tint timeout = (int) preferenceValueProvider.getPreferenceValue(ClassLeakingRule_MAX_TIMEOUT)\n+\t\t\t\t\t\t.longValue();\n+\t\t\t\treturn getResult(items, preferenceValueProvider, dependencyResults, timeout);\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/general\/ClassLeakingRule.java","additions":27,"deletions":11,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,0 +103,2 @@\n+\tpublic static final String ClassLeakingRule_CONFIG_CALCULATION_TIMEOUT = \"ClassLeakingRule_CONFIG_CALCULATION_TIMEOUT\"; \/\/$NON-NLS-1$\n+\tpublic static final String ClassLeakingRule_CONFIG_CALCULATION_TIMEOUT_LONG = \"ClassLeakingRule_CONFIG_CALCULATION_TIMEOUT_LONG\"; \/\/$NON-NLS-1$\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/Messages.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,7 @@\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n@@ -61,0 +68,1 @@\n+\tprivate final ConcurrentLinkedQueue<Object[]> processingQueue = new ConcurrentLinkedQueue<Object[]>();\n@@ -62,0 +70,1 @@\n+\tprivate final ExecutorService exec;\n@@ -63,1 +72,1 @@\n-\tDefaultIItemResultSet(IItemCollection items, IItemQuery query) {\n+\tDefaultIItemResultSet(IItemCollection items, IItemQuery query, int configuredTimeout) {\n@@ -68,0 +77,1 @@\n+\t\texec = Executors.newWorkStealingPool();\n@@ -69,1 +79,5 @@\n-\t\tcalculateData(items);\n+\t\ttry {\n+\t\t\tcalculateData(items, configuredTimeout);\n+\t\t} catch (InterruptedException e) {\n+\t\t\tThread.currentThread().interrupt();\n+\t\t}\n@@ -73,1 +87,2 @@\n-\tprivate void calculateData(IItemCollection input) {\n+\tprivate void calculateData(IItemCollection input, int configuredTimeout) throws InterruptedException {\n+\t\tList<Future> futures = new ArrayList<>();\n@@ -92,1 +107,1 @@\n-\t\t\t\t\tdata.add(row);\n+\t\t\t\t\tprocessingQueue.add(row);\n@@ -97,0 +112,2 @@\n+\t\t\tFuture future = null;\n+\t\t\tfinal IItemCollection newInput = input;\n@@ -99,8 +116,22 @@\n-\t\t\t\tfor (Object o : aggregate) {\n-\t\t\t\t\tIItemCollection rowCollection = input.apply(ItemFilters.equals((IAttribute) query.getGroupBy(), o));\n-\t\t\t\t\tObject[] row = newRow();\n-\t\t\t\t\tint column = 0;\n-\t\t\t\t\tfor (; column < attributes.size(); column++) {\n-\t\t\t\t\t\t\/\/ Optimization - it is too expensive to do aggregation for these. You simply\n-\t\t\t\t\t\t\/\/ get first non-null matching attribute - we're only using this for the group by today.\n-\t\t\t\t\t\trow[column] = getFirstNonNull(rowCollection, attributes.get(column));\n+\t\t\t\ttry {\n+\t\t\t\t\tfor (final Object o : aggregate) {\n+\t\t\t\t\t\tfuture = exec.submit(new Runnable() {\n+\t\t\t\t\t\t\t@Override\n+\t\t\t\t\t\t\tpublic void run() {\n+\t\t\t\t\t\t\t\tIItemCollection rowCollection = newInput\n+\t\t\t\t\t\t\t\t\t\t.apply(ItemFilters.equals((IAttribute) query.getGroupBy(), o));\n+\t\t\t\t\t\t\t\tObject[] row = newRow();\n+\t\t\t\t\t\t\t\tint column = 0;\n+\t\t\t\t\t\t\t\tfor (; column < attributes.size(); column++) {\n+\t\t\t\t\t\t\t\t\t\/\/ Optimization - it is too expensive to do aggregation for these. You simply\n+\t\t\t\t\t\t\t\t\t\/\/ get first non-null matching attribute - we're only using this for the group by today.\n+\t\t\t\t\t\t\t\t\trow[column] = getFirstNonNull(rowCollection, attributes.get(column));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tfor (int j = 0; j < aggregators.size(); j++) {\n+\t\t\t\t\t\t\t\t\trow[column + j] = rowCollection.getAggregate(aggregators.get(j));\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tprocessingQueue.add(row);\n+\t\t\t\t\t\t\t}\n+\n+\t\t\t\t\t\t});\n+\t\t\t\t\t\tfutures.add(future);\n@@ -108,2 +139,12 @@\n-\t\t\t\t\tfor (int j = 0; j < aggregators.size(); j++) {\n-\t\t\t\t\t\trow[column + j] = rowCollection.getAggregate(aggregators.get(j));\n+\t\t\t\t} finally {\n+\t\t\t\t\texec.shutdown();\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tif (!exec.awaitTermination(configuredTimeout, TimeUnit.MINUTES)) {\n+\t\t\t\t\t\t\tcheckStatusOfAllTasks(futures);\n+\n+\t\t\t\t\t\t\texec.shutdownNow();\n+\t\t\t\t\t\t\t\/\/ Await time for termination is not required as we have already given enough time before force shutdown. \n+\t\t\t\t\t\t}\n+\t\t\t\t\t} catch (InterruptedException ie) {\n+\t\t\t\t\t\texec.shutdownNow();\n+\t\t\t\t\t\tThread.currentThread().interrupt();\n@@ -111,1 +152,0 @@\n-\t\t\t\t\tdata.add(row);\n@@ -115,0 +155,16 @@\n+\t\tdata.addAll(processingQueue);\n+\t}\n+\n+\tprivate void checkStatusOfAllTasks(List<Future> totalAssignedTasks) {\n+\t\tint completedTask = 0;\n+\t\tfor (Future future : totalAssignedTasks) {\n+\t\t\tif (future.isDone())\n+\t\t\t\tcompletedTask++;\n+\t\t}\n+\n+\t\tif (completedTask < totalAssignedTasks.size()) {\n+\t\t\tLogger.getLogger(getClass().getName()).log(Level.WARNING,\n+\t\t\t\t\t\"The results may be inaccurate as JMC is unable to process all\"\n+\t\t\t\t\t\t\t+ \" the class entries to determine the class leak results.\"\n+\t\t\t\t\t\t\t+ \" Please increase the configured timeout in preferences to see the accurate results.\");\n+\t\t}\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/util\/DefaultIItemResultSet.java","additions":72,"deletions":16,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,5 @@\n-\t\treturn new DefaultIItemResultSet(items, query);\n+\t\treturn new DefaultIItemResultSet(items, query, 1440); \/\/Setting a default timeout value of 1 Day\n+\t}\n+\n+\tpublic IItemResultSet createResultSet(IItemCollection items, IItemQuery query, int configuredTimeout) {\n+\t\treturn new DefaultIItemResultSet(items, query, configuredTimeout);\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/util\/ItemResultSetFactory.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-#  Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,0 +107,2 @@\n+ClassLeakingRule_CONFIG_CALCULATION_TIMEOUT=Calculation Timeout (in minutes)\n+ClassLeakingRule_CONFIG_CALCULATION_TIMEOUT_LONG=Maximum amount of time to calculate Class Leak Rule (in minutes).\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/resources\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/messages\/internal\/messages.properties","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2816,3 +2816,3 @@\n-            <severity>OK<\/severity>\n-            <summary>com.oracle.medrec.model.User was loaded -1 time(s) without being unloaded<\/summary>\n-            <explanation>Some classes have been loaded multiple times, and the difference between the number of times a class have been loaded and the number of times it has been unloaded has exceeded the user specified limit. This in itself need not be a problem, but check to see if you expect these classes to be loaded multiple times to make sure that you do not have a class loader leak. The following classes were detected as potential problems: &lt;ul&gt;&lt;li&gt;com.oracle.medrec.model.User (-1)&lt;\/li&gt;&lt;li&gt;com.oracle.medrec.service.PatientService (-1)&lt;\/li&gt;&lt;li&gt;com.oracle.medrec.service.PhysicianService (-1)&lt;\/li&gt;&lt;li&gt;com.oracle.medrec.facade.PatientFacade (-1)&lt;\/li&gt;&lt;li&gt;com.oracle.medrec.common.messaging.MessageClient (-1)&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n+            <severity>Information<\/severity>\n+            <summary>java.lang.Object was loaded 258 time(s) without being unloaded<\/summary>\n+            <explanation>Some classes have been loaded multiple times, and the difference between the number of times a class have been loaded and the number of times it has been unloaded has exceeded the user specified limit. This in itself need not be a problem, but check to see if you expect these classes to be loaded multiple times to make sure that you do not have a class loader leak. The following classes were detected as potential problems: &lt;ul&gt;&lt;li&gt;java.lang.Object (258)&lt;\/li&gt;&lt;li&gt;java.lang.String (95)&lt;\/li&gt;&lt;li&gt;java.lang.Class (81)&lt;\/li&gt;&lt;li&gt;java.lang.Integer (52)&lt;\/li&gt;&lt;li&gt;oracle.jrockit.jfr.VMJFR (46)&lt;\/li&gt;&lt;\/ul&gt;<\/explanation>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/main\/resources\/baseline\/JfrRuleBaseline.xml","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}