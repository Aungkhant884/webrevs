{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,4 +68,0 @@\n-\t\t\tif (size >= array.length) {\n-\t\t\t\tint newCapacity = array.length < 100 ? array.length * 4 : (array.length * 3) \/ 2 + 1;\n-\t\t\t\tarray = Arrays.copyOf(array, newCapacity);\n-\t\t\t}\n@@ -73,2 +69,1 @@\n-\t\t\t\tarray[size++] = e;\n-\t\t\t\tthis.end = end;\n+\t\t\t\textend(e, end);\n@@ -80,0 +75,9 @@\n+\t\tvoid extend(T e, IQuantity end) {\n+\t\t\tif (size >= array.length) {\n+\t\t\t\tint newCapacity = array.length < 100 ? array.length * 4 : (array.length * 3) \/ 2 + 1;\n+\t\t\t\tarray = Arrays.copyOf(array, newCapacity);\n+\t\t\t}\n+\t\t\tarray[size++] = e;\n+\t\t\tthis.end = end;\n+\t\t}\n+\n@@ -121,2 +125,1 @@\n-\t\t\tint changedLane = addToOtherLane(e, start, end);\n-\t\t\tsortLanes(changedLane);\n+\t\t\taddToOtherLane(e, start, end);\n@@ -126,7 +129,13 @@\n-\tprivate void sortLanes(int fromIndex) {\n-\t\t\/\/ Sorting the lanes by descending end time\n-\t\tfor (int i = fromIndex; i > 0; i--) {\n-\t\t\tif (lanes[i].end.compareTo(lanes[i - 1].end) > 0) {\n-\t\t\t\tDisjointArray<T> tmp = lanes[i - 1];\n-\t\t\t\tlanes[i - 1] = lanes[i];\n-\t\t\t\tlanes[i] = tmp;\n+\tprivate int indexOf(IQuantity point, int from, int to) {\n+\t\tint low = from;\n+\t\tint high = to - 1;\n+\t\twhile (low <= high) {\n+\t\t\tint mid = (low + high) >>> 1;\n+\t\t\tDisjointArray<T> lane = lanes[mid];\n+\t\t\tint comparison = point.compareTo(lane.end);\n+\t\t\tif (comparison < 0) {\n+\t\t\t\tlow = mid + 1;\n+\t\t\t} else if (comparison > 0) {\n+\t\t\t\thigh = mid - 1;\n+\t\t\t} else {\n+\t\t\t\tbreak;\n@@ -135,0 +144,1 @@\n+\t\treturn low;\n@@ -137,5 +147,15 @@\n-\tprivate int addToOtherLane(T e, IQuantity start, IQuantity end) {\n-\t\t\/\/ Try with the other existing lanes\n-\t\tfor (int i = 1; i < noLanes; i++) {\n-\t\t\tif (lanes[i].accept(e, start, end)) {\n-\t\t\t\treturn i;\n+\tprivate void addToOtherLane(T e, IQuantity start, IQuantity end) {\n+\t\tint modificationIndex = indexOf(start, 1, noLanes);\n+\t\tif (modificationIndex < noLanes) {\n+\t\t\tDisjointArray<T> lane = lanes[modificationIndex];\n+\t\t\tif (modificationIndex > 0 && lanes[modificationIndex - 1].end.compareTo(end) < 0) {\n+\t\t\t\trelocateLane(modificationIndex, end, lane);\n+\t\t\t}\n+\t\t\tlane.extend(e, end);\n+\t\t} else {\n+\t\t\tresizeIfNecessary();\n+\t\t\tDisjointArray<T> lane = new DisjointArray<>(e, start, end);\n+\t\t\tif (lanes[modificationIndex - 1].end.compareTo(end) < 0) {\n+\t\t\t\trelocateLane(modificationIndex, end, lane);\n+\t\t\t} else {\n+\t\t\t\tlanes[modificationIndex] = lane;\n@@ -143,0 +163,8 @@\n+\t\t\tnoLanes++;\n+\t\t}\n+\t}\n+\n+\tprivate void relocateLane(int modificationIndex, IQuantity end, DisjointArray<T> lane) {\n+\t\tint relocationIndex = indexOf(end, 0, noLanes);\n+\t\tfor (int i = modificationIndex; i > relocationIndex; i--) {\n+\t\t\tlanes[i] = lanes[i - 1];\n@@ -144,1 +172,1 @@\n-\t\treturn addToNewLane(e, start, end);\n+\t\tlanes[relocationIndex] = lane;\n@@ -148,0 +176,6 @@\n+\t\tresizeIfNecessary();\n+\t\tlanes[noLanes] = new DisjointArray<>(e, start, end);\n+\t\treturn noLanes++;\n+\t}\n+\n+\tprivate void resizeIfNecessary() {\n@@ -151,2 +185,0 @@\n-\t\tlanes[noLanes] = new DisjointArray<>(e, start, end);\n-\t\treturn noLanes++;\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/util\/DisjointBuilder.java","additions":56,"deletions":24,"binary":false,"changes":80,"status":"modified"}]}