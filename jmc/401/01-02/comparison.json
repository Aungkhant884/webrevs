{"files":[{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2018, 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Datadog, Inc. All rights reserved.\n@@ -35,2 +36,2 @@\n-import org.openjdk.jmc.common.messages.internal.Messages;\n-\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -39,0 +40,2 @@\n+import org.openjdk.jmc.common.messages.internal.Messages;\n+\n@@ -55,19 +58,0 @@\n-\t\tprivate static final String MSG_PREFIX = \"IMCFrame_Type_\";\n-\n-\t\tprivate final String id;\n-\t\tprivate final String name;\n-\t\tprivate final boolean isUnknown;\n-\n-\t\tpublic Type(String id) {\n-\t\t\tthis.id = id.toUpperCase();\n-\n-\t\t\tString key = MSG_PREFIX + this.id;\n-\t\t\tif (Messages.hasString(key)) {\n-\t\t\t\tthis.name = Messages.getString(key);\n-\t\t\t\tthis.isUnknown = false;\n-\t\t\t} else {\n-\t\t\t\tthis.name = this.id;\n-\t\t\t\tthis.isUnknown = true;\n-\t\t\t}\n-\t\t}\n-\n@@ -78,0 +62,1 @@\n+\n@@ -82,0 +67,1 @@\n+\n@@ -86,0 +72,1 @@\n+\n@@ -90,0 +77,1 @@\n+\n@@ -94,0 +82,1 @@\n+\n@@ -98,0 +87,1 @@\n+\n@@ -103,0 +93,30 @@\n+\t\tprivate static final String MSG_PREFIX = \"IMCFrame_Type_\";\n+\n+\t\t\/*\n+\t\t * A helper cache for the unrecognized frame types to reduce the amount of allocated\n+\t\t * instances. The expectation is that the number of unrecognized frame types will be very\n+\t\t * small, usually zero, so the memory overhead of the cache stays negligible.\n+\t\t *\/\n+\t\tprivate static final Map<String, Type> TYPE_CACHE = new HashMap<>();\n+\n+\t\tprivate final String id;\n+\t\tprivate final String name;\n+\t\tprivate final boolean isUnknown;\n+\n+\t\tprivate Type(String id) {\n+\t\t\tthis.id = id.toUpperCase();\n+\n+\t\t\tString key = MSG_PREFIX + this.id;\n+\t\t\tif (Messages.hasString(key)) {\n+\t\t\t\tname = Messages.getString(key);\n+\t\t\t\tisUnknown = false;\n+\t\t\t} else {\n+\t\t\t\tname = this.id;\n+\t\t\t\tisUnknown = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic static Type cachedType(String type) {\n+\t\t\treturn TYPE_CACHE.computeIfAbsent(type, IMCFrame.Type::new);\n+\t\t}\n+\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/IMCFrame.java","additions":42,"deletions":22,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Datadog, Inc. All rights reserved.\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/messages\/internal\/Messages.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2018, 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Datadog, Inc. All rights reserved.\n@@ -35,2 +36,0 @@\n-import java.util.HashMap;\n-import java.util.Map;\n@@ -84,7 +83,0 @@\n-\t\/*\n-\t * A helper cache for the unrecognized frame types to reduce the amount of allocated instances.\n-\t * The expectation is that the number of unrecognized frame types will be very small, usually\n-\t * zero, so the memory overhead of the cache stays negligible.\n-\t *\/\n-\tprivate static final Map<String, IMCFrame.Type> TYPE_CACHE = new HashMap<>();\n-\n@@ -113,1 +105,1 @@\n-\t\treturn TYPE_CACHE.computeIfAbsent(type, IMCFrame.Type::new);\n+\t\treturn IMCFrame.Type.cachedType(type);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/util\/ParserToolkit.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.test.internal.util;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.openjdk.jmc.common.IMCFrame;\n+import org.openjdk.jmc.flightrecorder.internal.util.ParserToolkit;\n+\n+public class ParserToolkitTest {\n+\t@Test\n+\tpublic void testParseBuiltinFrameType() {\n+\t\tAssert.assertTrue(IMCFrame.Type.INTERPRETED == ParserToolkit.parseFrameType(ParserToolkit.INTERPRETED_TYPE_ID));\n+\t\tAssert.assertTrue(\n+\t\t\t\tIMCFrame.Type.JIT_COMPILED == ParserToolkit.parseFrameType(ParserToolkit.JIT_COMPILED_TYPE_ID));\n+\t\tAssert.assertTrue(IMCFrame.Type.INLINED == ParserToolkit.parseFrameType(ParserToolkit.INLINED_TYPE_ID));\n+\t\tAssert.assertTrue(IMCFrame.Type.NATIVE == ParserToolkit.parseFrameType(ParserToolkit.NATIVE_TYPE_ID));\n+\t\tAssert.assertTrue(IMCFrame.Type.CPP == ParserToolkit.parseFrameType(ParserToolkit.CPP_TYPE_ID));\n+\t\tAssert.assertTrue(IMCFrame.Type.KERNEL == ParserToolkit.parseFrameType(ParserToolkit.KERNEL_TYPE_ID));\n+\t\tAssert.assertTrue(IMCFrame.Type.UNKNOWN == ParserToolkit.parseFrameType(ParserToolkit.UNKNOWN_TYPE_ID));\n+\t}\n+\n+\t@Test\n+\tpublic void testCachedFrameType() {\n+\t\tString typeId = \"custom type\";\n+\t\tAssert.assertTrue(ParserToolkit.parseFrameType(typeId) == ParserToolkit.parseFrameType(typeId));\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/internal\/util\/ParserToolkitTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -1,26 +0,0 @@\n-package org.openjdk.jmc.flightrecorder.test.internal.util;\n-\n-import org.junit.Assert;\n-import org.junit.Test;\n-import org.openjdk.jmc.common.IMCFrame;\n-import org.openjdk.jmc.flightrecorder.internal.util.ParserToolkit;\n-\n-public class ParserToolkitTest {\n-\t@Test\n-\tpublic void testParseBuiltinFrameType() {\n-\t\tAssert.assertTrue(IMCFrame.Type.INTERPRETED == ParserToolkit.parseFrameType(ParserToolkit.INTERPRETED_TYPE_ID));\n-\t\tAssert.assertTrue(\n-\t\t\t\tIMCFrame.Type.JIT_COMPILED == ParserToolkit.parseFrameType(ParserToolkit.JIT_COMPILED_TYPE_ID));\n-\t\tAssert.assertTrue(IMCFrame.Type.INLINED == ParserToolkit.parseFrameType(ParserToolkit.INLINED_TYPE_ID));\n-\t\tAssert.assertTrue(IMCFrame.Type.NATIVE == ParserToolkit.parseFrameType(ParserToolkit.NATIVE_TYPE_ID));\n-\t\tAssert.assertTrue(IMCFrame.Type.CPP == ParserToolkit.parseFrameType(ParserToolkit.CPP_TYPE_ID));\n-\t\tAssert.assertTrue(IMCFrame.Type.KERNEL == ParserToolkit.parseFrameType(ParserToolkit.KERNEL_TYPE_ID));\n-\t\tAssert.assertTrue(IMCFrame.Type.UNKNOWN == ParserToolkit.parseFrameType(ParserToolkit.UNKNOWN_TYPE_ID));\n-\t}\n-\n-\t@Test\n-\tpublic void testCachedFrameType() {\n-\t\tString typeId = \"custom type\";\n-\t\tAssert.assertTrue(ParserToolkit.parseFrameType(typeId) == ParserToolkit.parseFrameType(typeId));\n-\t}\n-}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/internal\/util\/ParserToolkitTest.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"}]}