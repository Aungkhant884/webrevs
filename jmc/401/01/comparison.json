{"files":[{"patch":"@@ -37,0 +37,2 @@\n+import java.util.Objects;\n+\n@@ -41,1 +43,1 @@\n- * implement {@link IMCMethod}. This allow classes in higher layers to treat a frame just like a\n+ * implement {@link IMCMethod}. This allows classes in higher layers to treat a frame just like a\n@@ -52,29 +54,6 @@\n-\tpublic enum Type {\n-\t\/**\n-\t * The frame was executed as native code compiled by the Java JIT compiler.\n-\t *\/\n-\tJIT_COMPILED,\n-\t\/**\n-\t * The frame was executed as interpreted Java byte code.\n-\t *\/\n-\tINTERPRETED,\n-\t\/**\n-\t * The frame was executed as code that was inlined by the Java JIT compiler.\n-\t *\/\n-\tINLINED,\n-\t\/**\n-\t * The frame was executed as native code, most probably a C function.\n-\t *\/\n-\tNATIVE,\n-\t\/**\n-\t * The frame was executed as native code compiled from C++.\n-\t *\/\n-\tCPP,\n-\t\/**\n-\t * The frame was executed as kernel native code.\n-\t *\/\n-\tKERNEL,\n-\t\/**\n-\t * The frame compilation type is unknown.\n-\t *\/\n-\tUNKNOWN;\n+\tfinal class Type {\n+\t\tprivate static final String MSG_PREFIX = \"IMCFrame_Type_\";\n+\n+\t\tprivate final String id;\n+\t\tprivate final String name;\n+\t\tprivate final boolean isUnknown;\n@@ -82,1 +61,2 @@\n-\t\tprivate String name;\n+\t\tpublic Type(String id) {\n+\t\t\tthis.id = id.toUpperCase();\n@@ -84,2 +64,8 @@\n-\t\tprivate Type() {\n-\t\t\tname = Messages.getString(\"IMCFrame_Type_\" + toString()); \/\/$NON-NLS-1$\n+\t\t\tString key = MSG_PREFIX + this.id;\n+\t\t\tif (Messages.hasString(key)) {\n+\t\t\t\tthis.name = Messages.getString(key);\n+\t\t\t\tthis.isUnknown = false;\n+\t\t\t} else {\n+\t\t\t\tthis.name = this.id;\n+\t\t\t\tthis.isUnknown = true;\n+\t\t\t}\n@@ -88,0 +74,29 @@\n+\t\t\/**\n+\t\t * The frame was executed as native code compiled by the Java JIT compiler.\n+\t\t *\/\n+\t\tpublic static final Type JIT_COMPILED = new Type(\"JIT_COMPILED\"); \/\/$NON-NLS-1$\n+\t\t\/**\n+\t\t * The frame was executed as interpreted Java byte code.\n+\t\t *\/\n+\t\tpublic static final Type INTERPRETED = new Type(\"INTERPRETED\"); \/\/$NON-NLS-1$\n+\t\t\/**\n+\t\t * The frame was executed as code that was inlined by the Java JIT compiler.\n+\t\t *\/\n+\t\tpublic static final Type INLINED = new Type(\"INLINED\"); \/\/$NON-NLS-1$\n+\t\t\/**\n+\t\t * The frame was executed as native code, most probably a C function\n+\t\t *\/\n+\t\tpublic static final Type NATIVE = new Type(\"NATIVE\"); \/\/$NON-NLS-1$\n+\t\t\/**\n+\t\t * The frame was executed as native code compiled from C++\n+\t\t *\/\n+\t\tpublic static final Type CPP = new Type(\"CPP\"); \/\/$NON-NLS-1$\n+\t\t\/**\n+\t\t * The frame was executed as kernel native code\n+\t\t *\/\n+\t\tpublic static final Type KERNEL = new Type(\"KERNEL\"); \/\/$NON-NLS-1$\n+\t\t\/**\n+\t\t * The frame compilation type is unknown.\n+\t\t *\/\n+\t\tpublic static final Type UNKNOWN = new Type(\"UNKNONW\"); \/\/$NON-NLS-1$\n+\n@@ -91,0 +106,24 @@\n+\n+\t\tpublic boolean isUnknown() {\n+\t\t\treturn isUnknown;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object o) {\n+\t\t\tif (this == o)\n+\t\t\t\treturn true;\n+\t\t\tif (o == null || getClass() != o.getClass())\n+\t\t\t\treturn false;\n+\t\t\tType type = (Type) o;\n+\t\t\treturn id.equals(type.id);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\treturn Objects.hash(id);\n+\t\t}\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/IMCFrame.java","additions":72,"deletions":33,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -95,0 +95,4 @@\n+\n+\tpublic static boolean hasString(String key) {\n+\t\treturn RESOURCE_BUNDLE.containsKey(key);\n+\t}\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/messages\/internal\/Messages.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -41,0 +43,9 @@\n+\t\/\/ The following type IDs are public only for the sakes of testing\n+\tpublic static final String INTERPRETED_TYPE_ID = \"Interpreted\"; \/\/$NON-NLS-1$\n+\tpublic static final String JIT_COMPILED_TYPE_ID = \"JIT compiled\"; \/\/$NON-NLS-1$\n+\tpublic static final String INLINED_TYPE_ID = \"Inlined\"; \/\/$NON-NLS-1$\n+\tpublic static final String NATIVE_TYPE_ID = \"Native\"; \/\/$NON-NLS-1$\n+\tpublic static final String CPP_TYPE_ID = \"C++\"; \/\/$NON-NLS-1$\n+\tpublic static final String KERNEL_TYPE_ID = \"Kernel\"; \/\/$NON-NLS-1$\n+\tpublic static final String UNKNOWN_TYPE_ID = \"Unknown\"; \/\/$NON-NLS-1$\n+\n@@ -73,0 +84,7 @@\n+\t\/*\n+\t * A helper cache for the unrecognized frame types to reduce the amount of allocated instances.\n+\t * The expectation is that the number of unrecognized frame types will be very small, usually\n+\t * zero, so the memory overhead of the cache stays negligible.\n+\t *\/\n+\tprivate static final Map<String, IMCFrame.Type> TYPE_CACHE = new HashMap<>();\n+\n@@ -74,1 +92,1 @@\n-\t\tif (\"Interpreted\".equals(type)) { \/\/$NON-NLS-1$\n+\t\tif (INTERPRETED_TYPE_ID.equals(type)) {\n@@ -77,1 +95,1 @@\n-\t\tif (\"JIT compiled\".equals(type)) { \/\/$NON-NLS-1$\n+\t\tif (JIT_COMPILED_TYPE_ID.equals(type)) {\n@@ -80,1 +98,1 @@\n-\t\tif (\"Inlined\".equals(type)) { \/\/$NON-NLS-1$\n+\t\tif (INLINED_TYPE_ID.equals(type)) {\n@@ -83,1 +101,1 @@\n-\t\tif (\"Native\".equals(type)) { \/\/$NON-NLS-1$\n+\t\tif (NATIVE_TYPE_ID.equals(type)) {\n@@ -86,1 +104,1 @@\n-\t\tif (\"C++\".equals(type)) { \/\/$NON-NLS-1$\n+\t\tif (CPP_TYPE_ID.equals(type)) {\n@@ -89,1 +107,1 @@\n-\t\tif (\"Kernel\".equals(type)) { \/\/$NON-NLS-1$\n+\t\tif (KERNEL_TYPE_ID.equals(type)) {\n@@ -92,1 +110,4 @@\n-\t\treturn IMCFrame.Type.UNKNOWN;\n+\t\tif (UNKNOWN_TYPE_ID.equals(type)) {\n+\t\t\treturn IMCFrame.Type.UNKNOWN;\n+\t\t}\n+\t\treturn TYPE_CACHE.computeIfAbsent(type, IMCFrame.Type::new);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/util\/ParserToolkit.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,26 @@\n+package org.openjdk.jmc.flightrecorder.test.internal.util;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.openjdk.jmc.common.IMCFrame;\n+import org.openjdk.jmc.flightrecorder.internal.util.ParserToolkit;\n+\n+public class ParserToolkitTest {\n+\t@Test\n+\tpublic void testParseBuiltinFrameType() {\n+\t\tAssert.assertTrue(IMCFrame.Type.INTERPRETED == ParserToolkit.parseFrameType(ParserToolkit.INTERPRETED_TYPE_ID));\n+\t\tAssert.assertTrue(\n+\t\t\t\tIMCFrame.Type.JIT_COMPILED == ParserToolkit.parseFrameType(ParserToolkit.JIT_COMPILED_TYPE_ID));\n+\t\tAssert.assertTrue(IMCFrame.Type.INLINED == ParserToolkit.parseFrameType(ParserToolkit.INLINED_TYPE_ID));\n+\t\tAssert.assertTrue(IMCFrame.Type.NATIVE == ParserToolkit.parseFrameType(ParserToolkit.NATIVE_TYPE_ID));\n+\t\tAssert.assertTrue(IMCFrame.Type.CPP == ParserToolkit.parseFrameType(ParserToolkit.CPP_TYPE_ID));\n+\t\tAssert.assertTrue(IMCFrame.Type.KERNEL == ParserToolkit.parseFrameType(ParserToolkit.KERNEL_TYPE_ID));\n+\t\tAssert.assertTrue(IMCFrame.Type.UNKNOWN == ParserToolkit.parseFrameType(ParserToolkit.UNKNOWN_TYPE_ID));\n+\t}\n+\n+\t@Test\n+\tpublic void testCachedFrameType() {\n+\t\tString typeId = \"custom type\";\n+\t\tAssert.assertTrue(ParserToolkit.parseFrameType(typeId) == ParserToolkit.parseFrameType(typeId));\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/internal\/util\/ParserToolkitTest.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"}]}