{"files":[{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2018, 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Datadog, Inc. All rights reserved.\n@@ -35,0 +36,4 @@\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n@@ -41,1 +46,1 @@\n- * implement {@link IMCMethod}. This allow classes in higher layers to treat a frame just like a\n+ * implement {@link IMCMethod}. This allows classes in higher layers to treat a frame just like a\n@@ -52,29 +57,20 @@\n-\tpublic enum Type {\n-\t\/**\n-\t * The frame was executed as native code compiled by the Java JIT compiler.\n-\t *\/\n-\tJIT_COMPILED,\n-\t\/**\n-\t * The frame was executed as interpreted Java byte code.\n-\t *\/\n-\tINTERPRETED,\n-\t\/**\n-\t * The frame was executed as code that was inlined by the Java JIT compiler.\n-\t *\/\n-\tINLINED,\n-\t\/**\n-\t * The frame was executed as native code, most probably a C function.\n-\t *\/\n-\tNATIVE,\n-\t\/**\n-\t * The frame was executed as native code compiled from C++.\n-\t *\/\n-\tCPP,\n-\t\/**\n-\t * The frame was executed as kernel native code.\n-\t *\/\n-\tKERNEL,\n-\t\/**\n-\t * The frame compilation type is unknown.\n-\t *\/\n-\tUNKNOWN;\n+\tfinal class Type {\n+\t\t\/**\n+\t\t * The frame was executed as native code compiled by the Java JIT compiler.\n+\t\t *\/\n+\t\tpublic static final Type JIT_COMPILED = new Type(\"JIT_COMPILED\"); \/\/$NON-NLS-1$\n+\n+\t\t\/**\n+\t\t * The frame was executed as interpreted Java byte code.\n+\t\t *\/\n+\t\tpublic static final Type INTERPRETED = new Type(\"INTERPRETED\"); \/\/$NON-NLS-1$\n+\n+\t\t\/**\n+\t\t * The frame was executed as code that was inlined by the Java JIT compiler.\n+\t\t *\/\n+\t\tpublic static final Type INLINED = new Type(\"INLINED\"); \/\/$NON-NLS-1$\n+\n+\t\t\/**\n+\t\t * The frame was executed as native code, most probably a C function\n+\t\t *\/\n+\t\tpublic static final Type NATIVE = new Type(\"NATIVE\"); \/\/$NON-NLS-1$\n@@ -82,1 +78,4 @@\n-\t\tprivate String name;\n+\t\t\/**\n+\t\t * The frame was executed as native code compiled from C++\n+\t\t *\/\n+\t\tpublic static final Type CPP = new Type(\"CPP\"); \/\/$NON-NLS-1$\n@@ -84,2 +83,52 @@\n-\t\tprivate Type() {\n-\t\t\tname = Messages.getString(\"IMCFrame_Type_\" + toString()); \/\/$NON-NLS-1$\n+\t\t\/**\n+\t\t * The frame was executed as kernel native code\n+\t\t *\/\n+\t\tpublic static final Type KERNEL = new Type(\"KERNEL\"); \/\/$NON-NLS-1$\n+\n+\t\t\/**\n+\t\t * The frame compilation type is unknown.\n+\t\t *\/\n+\t\tpublic static final Type UNKNOWN = new Type(\"UNKNONW\"); \/\/$NON-NLS-1$\n+\n+\t\tprivate static final String MSG_PREFIX = \"IMCFrame_Type_\";\n+\n+\t\t\/*\n+\t\t * Maximum number of items the TYPE_CACHE will hold. The assumption is that the number of\n+\t\t * 'dynamic' frame types will be small, typically in ones rather than tens and as such 100\n+\t\t * items in the type cache should cover the vast majority of use cases.\n+\t\t *\/\n+\t\tprivate static final int TYPE_CACHE_MAX_SIZE = 100;\n+\n+\t\t\/*\n+\t\t * A helper cache for the unrecognized frame types to reduce the amount of allocated\n+\t\t * instances. The expectation is that the number of unrecognized frame types will be very\n+\t\t * small, usually zero, so the memory overhead of the cache stays negligible.\n+\t\t *\/\n+\t\tprivate static final Map<String, Type> TYPE_CACHE = new LinkedHashMap<String, Type>() {\n+\t\t\tprivate static final long serialVersionUID = 6330800425284157773L;\n+\n+\t\t\t@Override\n+\t\t\tprotected boolean removeEldestEntry(Map.Entry<String, Type> eldest) {\n+\t\t\t\treturn size() > TYPE_CACHE_MAX_SIZE;\n+\t\t\t}\n+\t\t};\n+\n+\t\tprivate final String id;\n+\t\tprivate final String name;\n+\t\tprivate final boolean isUnknown;\n+\n+\t\tprivate Type(String id) {\n+\t\t\tthis.id = id.toUpperCase();\n+\n+\t\t\tString key = MSG_PREFIX + this.id;\n+\t\t\tif (Messages.hasString(key)) {\n+\t\t\t\tname = Messages.getString(key);\n+\t\t\t\tisUnknown = false;\n+\t\t\t} else {\n+\t\t\t\tname = this.id;\n+\t\t\t\tisUnknown = true;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic static Type cachedType(String type) {\n+\t\t\treturn TYPE_CACHE.computeIfAbsent(type, IMCFrame.Type::new);\n@@ -91,0 +140,24 @@\n+\n+\t\tpublic boolean isUnknown() {\n+\t\t\treturn isUnknown;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object o) {\n+\t\t\tif (this == o)\n+\t\t\t\treturn true;\n+\t\t\tif (o == null || getClass() != o.getClass())\n+\t\t\t\treturn false;\n+\t\t\tType type = (Type) o;\n+\t\t\treturn id.equals(type.id);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\treturn Objects.hash(id);\n+\t\t}\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/IMCFrame.java","additions":107,"deletions":34,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Datadog, Inc. All rights reserved.\n@@ -95,0 +96,4 @@\n+\n+\tpublic static boolean hasString(String key) {\n+\t\treturn RESOURCE_BUNDLE.containsKey(key);\n+\t}\n","filename":"core\/org.openjdk.jmc.common\/src\/main\/java\/org\/openjdk\/jmc\/common\/messages\/internal\/Messages.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2018, 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Datadog, Inc. All rights reserved.\n@@ -41,0 +42,9 @@\n+\t\/\/ The following type IDs are public only for the sakes of testing\n+\tpublic static final String INTERPRETED_TYPE_ID = \"Interpreted\"; \/\/$NON-NLS-1$\n+\tpublic static final String JIT_COMPILED_TYPE_ID = \"JIT compiled\"; \/\/$NON-NLS-1$\n+\tpublic static final String INLINED_TYPE_ID = \"Inlined\"; \/\/$NON-NLS-1$\n+\tpublic static final String NATIVE_TYPE_ID = \"Native\"; \/\/$NON-NLS-1$\n+\tpublic static final String CPP_TYPE_ID = \"C++\"; \/\/$NON-NLS-1$\n+\tpublic static final String KERNEL_TYPE_ID = \"Kernel\"; \/\/$NON-NLS-1$\n+\tpublic static final String UNKNOWN_TYPE_ID = \"Unknown\"; \/\/$NON-NLS-1$\n+\n@@ -74,1 +84,1 @@\n-\t\tif (\"Interpreted\".equals(type)) { \/\/$NON-NLS-1$\n+\t\tif (INTERPRETED_TYPE_ID.equals(type)) {\n@@ -77,1 +87,1 @@\n-\t\tif (\"JIT compiled\".equals(type)) { \/\/$NON-NLS-1$\n+\t\tif (JIT_COMPILED_TYPE_ID.equals(type)) {\n@@ -80,1 +90,1 @@\n-\t\tif (\"Inlined\".equals(type)) { \/\/$NON-NLS-1$\n+\t\tif (INLINED_TYPE_ID.equals(type)) {\n@@ -83,1 +93,1 @@\n-\t\tif (\"Native\".equals(type)) { \/\/$NON-NLS-1$\n+\t\tif (NATIVE_TYPE_ID.equals(type)) {\n@@ -86,1 +96,1 @@\n-\t\tif (\"C++\".equals(type)) { \/\/$NON-NLS-1$\n+\t\tif (CPP_TYPE_ID.equals(type)) {\n@@ -89,1 +99,1 @@\n-\t\tif (\"Kernel\".equals(type)) { \/\/$NON-NLS-1$\n+\t\tif (KERNEL_TYPE_ID.equals(type)) {\n@@ -92,1 +102,4 @@\n-\t\treturn IMCFrame.Type.UNKNOWN;\n+\t\tif (UNKNOWN_TYPE_ID.equals(type)) {\n+\t\t\treturn IMCFrame.Type.UNKNOWN;\n+\t\t}\n+\t\treturn IMCFrame.Type.cachedType(type);\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/internal\/util\/ParserToolkit.java","additions":21,"deletions":8,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.test.internal.util;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.openjdk.jmc.common.IMCFrame;\n+import org.openjdk.jmc.flightrecorder.internal.util.ParserToolkit;\n+\n+public class ParserToolkitTest {\n+\t@Test\n+\tpublic void testParseBuiltinFrameType() {\n+\t\tAssert.assertTrue(IMCFrame.Type.INTERPRETED == ParserToolkit.parseFrameType(ParserToolkit.INTERPRETED_TYPE_ID));\n+\t\tAssert.assertTrue(IMCFrame.Type.JIT_COMPILED == ParserToolkit.parseFrameType(ParserToolkit.JIT_COMPILED_TYPE_ID));\n+\t\tAssert.assertTrue(IMCFrame.Type.INLINED == ParserToolkit.parseFrameType(ParserToolkit.INLINED_TYPE_ID));\n+\t\tAssert.assertTrue(IMCFrame.Type.NATIVE == ParserToolkit.parseFrameType(ParserToolkit.NATIVE_TYPE_ID));\n+\t\tAssert.assertTrue(IMCFrame.Type.CPP == ParserToolkit.parseFrameType(ParserToolkit.CPP_TYPE_ID));\n+\t\tAssert.assertTrue(IMCFrame.Type.KERNEL == ParserToolkit.parseFrameType(ParserToolkit.KERNEL_TYPE_ID));\n+\t\tAssert.assertTrue(IMCFrame.Type.UNKNOWN == ParserToolkit.parseFrameType(ParserToolkit.UNKNOWN_TYPE_ID));\n+\t}\n+\n+\t@Test\n+\tpublic void testCachedFrameType() {\n+\t\tString typeId = \"custom type\";\n+\t\tAssert.assertTrue(ParserToolkit.parseFrameType(typeId) == ParserToolkit.parseFrameType(typeId));\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/internal\/util\/ParserToolkitTest.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"}]}