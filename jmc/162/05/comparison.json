{"files":[{"patch":"@@ -42,0 +42,1 @@\n+application\/org.openjdk.jmc.flightrecorder.graphview\/src\/main\/resources\/jslibs\/\n","filename":".gitignore","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-   Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+   Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,1 +145,1 @@\n-         \n+\n@@ -153,0 +153,6 @@\n+   <plugin\n+         id=\"org.openjdk.jmc.flightrecorder.graphview\"\n+         download-size=\"0\"\n+         install-size=\"0\"\n+         version=\"0.0.0\"\n+         unpack=\"false\"\/>\n","filename":"application\/org.openjdk.jmc.feature.flightrecorder\/feature.xml","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-\tprivate ModelState modelState = ModelState.NONE;\n+\tprivate volatile ModelState modelState = ModelState.NONE;\n","filename":"application\/org.openjdk.jmc.flightrecorder.flameview\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/flameview\/views\/FlameGraphView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<classpath>\n+\t<classpathentry kind=\"src\" path=\"src\/main\/java\"\/>\n+\t<classpathentry kind=\"src\" path=\"src\/main\/resources\"\/>\n+\t<classpathentry kind=\"src\" path=\"src\/test\/java\"\/>\n+\t<classpathentry kind=\"con\" path=\"org.eclipse.pde.core.requiredPlugins\"\/>\n+\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.junit.JUNIT_CONTAINER\/5\"\/>\n+\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER\"\/>\n+\t<classpathentry kind=\"output\" path=\"target\/classes\"\/>\n+<\/classpath>\n","filename":"application\/org.openjdk.jmc.flightrecorder.graphview\/.classpath","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+\/bin\/\n","filename":"application\/org.openjdk.jmc.flightrecorder.graphview\/.gitignore","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n-\t<name>org.openjdk.jmc.browser.attach.ja<\/name>\n+\t<name>org.openjdk.jmc.flightrecorder.graphview<\/name>\n@@ -31,1 +31,0 @@\n-\t\t<nature>org.eclipse.pde.PluginNature<\/nature>\n@@ -33,0 +32,1 @@\n+\t\t<nature>org.eclipse.pde.PluginNature<\/nature>\n","filename":"application\/org.openjdk.jmc.flightrecorder.graphview\/.project","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"application\/l10n\/org.openjdk.jmc.browser.attach.ja\/.project","status":"copied"},{"patch":"@@ -0,0 +1,24 @@\n+Manifest-Version: 1.0\n+Bundle-ManifestVersion: 2\n+Bundle-Name: GraphView\n+Bundle-SymbolicName: org.openjdk.jmc.flightrecorder.graphview;singleton:=true\n+Bundle-Version: 8.0.0.qualifier\n+Require-Bundle: org.openjdk.jmc.flightrecorder;bundle-version=\"8.0.0\",\n+ org.openjdk.jmc.flightrecorder.ui;bundle-version=\"8.0.0\",\n+ org.junit,\n+ org.junit.jupiter.api,\n+ org.junit.jupiter.engine,\n+ org.junit.jupiter.migrationsupport,\n+ org.junit.jupiter.params,\n+ org.junit.platform.commons,\n+ org.junit.platform.engine,\n+ org.junit.platform.launcher,\n+ org.junit.platform.runner,\n+ org.junit.platform.suite.api,\n+ org.junit.vintage.engine,\n+ org.hamcrest.core,\n+ org.opentest4j,\n+ org.apiguardian\n+Bundle-RequiredExecutionEnvironment: JavaSE-1.8\n+Automatic-Module-Name: org.openjdk.jmc.flightrecorder.graphview\n+Bundle-Vendor: Oracle Corporation\n","filename":"application\/org.openjdk.jmc.flightrecorder.graphview\/META-INF\/MANIFEST.MF","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+source.. = src\/main\/java\/,\\\n+           src\/main\/resources\/,\\\n+           src\/test\/java\/\n+output.. = target\/classes\/\n+bin.includes = META-INF\/,\\\n+               .,\\\n+               plugin.xml,\\\n+               plugin.properties,\\\n+               icons\/\n+pde.match.rule.bundle=compatible\n","filename":"application\/org.openjdk.jmc.flightrecorder.graphview\/build.properties","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"filename":"application\/org.openjdk.jmc.flightrecorder.graphview\/icons\/graph.png","binary":true,"previous_filename":"application\/org.openjdk.jmc.joverflow.ui\/icons\/joverflow.png","status":"copied"},{"filename":"application\/org.openjdk.jmc.flightrecorder.graphview\/icons\/graph@2x.png","binary":true,"status":"added"},{"patch":"@@ -2,1 +2,2 @@\n-#  Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n@@ -33,4 +34,1 @@\n-# NLS_MESSAGEFORMAT_NONE\n-# NLS_ENCODING=UTF-8\n-name=JDK Mission Control \\u5E2E\\u52A9\n-providerName=DITA\n+GRAPH_VIEW=Graph View\n","filename":"application\/org.openjdk.jmc.flightrecorder.graphview\/plugin.properties","additions":3,"deletions":5,"binary":false,"changes":8,"previous_filename":"application\/l10n\/org.openjdk.jmc.docs.zh_CN\/plugin_zh_CN.properties","status":"copied"},{"patch":"@@ -0,0 +1,15 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<?eclipse version=\"3.2\"?>\n+<plugin>\n+\t<extension point=\"org.eclipse.ui.views\">\n+\t\t<view\n+          allowMultiple=\"false\"\n+          category=\"org.openjdk.jmc.ui.main\"\n+          class=\"org.openjdk.jmc.flightrecorder.graphview.views.GraphView\"\n+          icon=\"icons\/graph.png\"\n+          id=\"org.openjdk.jmc.flightrecorder.graphview\"\n+          name=\"Graph View\"\n+          restorable=\"true\">\n+\t\t<\/view>\n+\t<\/extension>\n+<\/plugin>\n","filename":"application\/org.openjdk.jmc.flightrecorder.graphview\/plugin.xml","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+   Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+   Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+\n+   DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+   The contents of this file are subject to the terms of either the Universal Permissive License\n+   v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+\n+   or the following license:\n+\n+   Redistribution and use in source and binary forms, with or without modification, are permitted\n+   provided that the following conditions are met:\n+\n+   1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+   and the following disclaimer.\n+\n+   2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+   conditions and the following disclaimer in the documentation and\/or other materials provided with\n+   the distribution.\n+\n+   3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+   endorse or promote products derived from this software without specific prior written permission.\n+\n+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+   FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+   WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+-->\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\"\n+\txsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+\t<modelVersion>4.0.0<\/modelVersion>\n+\t<parent>\n+\t\t<groupId>org.openjdk.jmc<\/groupId>\n+\t\t<artifactId>missioncontrol.application<\/artifactId>\n+\t\t<version>8.0.0-SNAPSHOT<\/version>\n+\t<\/parent>\n+\t<artifactId>org.openjdk.jmc.flightrecorder.graphview<\/artifactId>\n+\t<packaging>eclipse-plugin<\/packaging>\n+\n+\t<properties>\n+\t\t<download.maven.plugin.version>1.4.2<\/download.maven.plugin.version>\n+\t\t<download-maven-plugin.phase>process-resources<\/download-maven-plugin.phase>\n+\t\t<download-maven-plugin.output>${project.basedir}\/src\/main\/resources\/jslibs<\/download-maven-plugin.output>\n+\t\t<spotless.config.path>${basedir}\/..\/..\/configuration\/ide\/eclipse\/formatting\/formatting.xml<\/spotless.config.path>\n+\t\t<spotless.config.path.js>${basedir}\/..\/..\/configuration\/ide\/eclipse\/formatting\/formattingjs.xml<\/spotless.config.path.js>\n+\t<\/properties>\n+\n+\t<build>\n+\t\t<plugins>\n+\t\t\t<plugin>\n+\t\t\t\t<groupId>com.googlecode.maven-download-plugin<\/groupId>\n+\t\t\t\t<artifactId>download-maven-plugin<\/artifactId>\n+\t\t\t\t<version>${download.maven.plugin.version}<\/version>\n+\t\t\t\t<executions>\n+\t\t\t\t\t<execution>\n+\t\t\t\t\t\t<id>d3-v5-js<\/id>\n+\t\t\t\t\t\t<phase>${download-maven-plugin.phase}<\/phase>\n+\t\t\t\t\t\t<goals>\n+\t\t\t\t\t\t\t<goal>wget<\/goal>\n+\t\t\t\t\t\t<\/goals>\n+\t\t\t\t\t\t<configuration>\n+\t\t\t\t\t\t\t<url>https:\/\/d3js.org\/d3.v5.min.js<\/url>\n+\t\t\t\t\t\t\t<unpack>false<\/unpack>\n+\t\t\t\t\t\t\t<outputDirectory>${download-maven-plugin.output}<\/outputDirectory>\n+\t\t\t\t\t\t<\/configuration>\n+\t\t\t\t\t<\/execution>\n+\t\t\t\t\t<execution>\n+\t\t\t\t\t\t<id>wasm<\/id>\n+\t\t\t\t\t\t<phase>${download-maven-plugin.phase}<\/phase>\n+\t\t\t\t\t\t<goals>\n+\t\t\t\t\t\t\t<goal>wget<\/goal>\n+\t\t\t\t\t\t<\/goals>\n+\t\t\t\t\t\t<configuration>\n+\t\t\t\t\t\t\t<url>https:\/\/unpkg.com\/@hpcc-js\/wasm@0.3.11\/dist\/index.js<\/url>\n+\t\t\t\t\t\t\t<unpack>false<\/unpack>\n+\t\t\t\t\t\t\t<outputDirectory>${download-maven-plugin.output}<\/outputDirectory>\n+\t\t\t\t\t\t<\/configuration>\n+\t\t\t\t\t<\/execution>\n+\t\t\t\t\t<execution>\n+\t\t\t\t\t\t<id>d3-graphviz-js<\/id>\n+\t\t\t\t\t\t<phase>${download-maven-plugin.phase}<\/phase>\n+\t\t\t\t\t\t<goals>\n+\t\t\t\t\t\t\t<goal>wget<\/goal>\n+\t\t\t\t\t\t<\/goals>\n+\t\t\t\t\t\t<configuration>\n+\t\t\t\t\t\t\t<url>https:\/\/unpkg.com\/d3-graphviz@3.1.0\/build\/d3-graphviz.js<\/url>\n+\t\t\t\t\t\t\t<unpack>false<\/unpack>\n+\t\t\t\t\t\t\t<outputDirectory>${download-maven-plugin.output}<\/outputDirectory>\n+\t\t\t\t\t\t<\/configuration>\n+\t\t\t\t\t<\/execution>\n+\t\t\t\t\t<execution>\n+\t\t\t\t\t\t<id>graphvizlib-wasm<\/id>\n+\t\t\t\t\t\t<phase>${download-maven-plugin.phase}<\/phase>\n+\t\t\t\t\t\t<goals>\n+\t\t\t\t\t\t\t<goal>wget<\/goal>\n+\t\t\t\t\t\t<\/goals>\n+\t\t\t\t\t\t<configuration>\n+\t\t\t\t\t\t\t<url>https:\/\/unpkg.com\/@hpcc-js\/wasm@0.3.14\/dist\/graphvizlib.wasm<\/url>\n+\t\t\t\t\t\t\t<unpack>false<\/unpack>\n+\t\t\t\t\t\t\t<outputDirectory>${download-maven-plugin.output}<\/outputDirectory>\n+\t\t\t\t\t\t<\/configuration>\n+\t\t\t\t\t<\/execution>\n+\t\t\t\t<\/executions>\n+\t\t\t<\/plugin>\n+\t\t<\/plugins>\n+\t<\/build>\n+<\/project>\n","filename":"application\/org.openjdk.jmc.flightrecorder.graphview\/pom.xml","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,424 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.ext.graphview.graph;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.flightrecorder.CouldNotLoadRecordingException;\n+import org.openjdk.jmc.flightrecorder.JfrLoaderToolkit;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkFilters;\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator.FrameCategorization;\n+import org.openjdk.jmc.flightrecorder.stacktrace.graph.Edge;\n+import org.openjdk.jmc.flightrecorder.stacktrace.graph.GraphModelUtils;\n+import org.openjdk.jmc.flightrecorder.stacktrace.graph.Node;\n+import org.openjdk.jmc.flightrecorder.stacktrace.graph.StacktraceGraphModel;\n+\n+\/**\n+ * Converts a {@link StacktraceGraphModel} to DOT format text. This format can, for example, be used\n+ * by d3-graphviz, to visualize the graphs.\n+ *\/\n+public final class DotGenerator {\n+\tprivate static final String DEFAULT_NAME = \"Unnamed\";\n+\tprivate static final String DEFAULT_SHAPE = \"box\";\n+\tprivate static final String DEFAULT_STYLE = \"filled\";\n+\tprivate static final String DEFAULT_FILL_COLOR = \"#f8f8f8\";\n+\tprivate static final String DEFAULT_TITLE_FONT_SIZE = \"16\";\n+\tprivate static final String DEFAULT_FONT_NAME = \"helvetica\";\n+\tprivate static final String DEFAULT_NODE_FILL_COLOR = \"#e1e1e1\";\n+\tprivate static final String DEFAULT_EDGE_STYLE = \"solid\";\n+\tprivate static final String DEFAULT_MIN_EDGE_WEIGHT = \"2\";\n+\tprivate static final String DEFAULT_MAX_EDGE_WEIGHT = \"40\";\n+\tprivate static final String DEFAULT_NODE_SIZE_ATTRIBUTE = \"count\";\n+\tprivate static final String DEFAULT_MIN_NODE_FONT_SIZE = \"8\";\n+\tprivate static final String DEFAULT_MAX_NODE_FONT_SIZE = \"32\";\n+\n+\tpublic enum ConfigurationKey {\n+\t\t\/**\n+\t\t * The name of the graph.\n+\t\t *\/\n+\t\tName,\n+\t\t\/**\n+\t\t * The style, e.g. filled.\n+\t\t *\/\n+\t\tStyle,\n+\t\t\/**\n+\t\t * The fill color, e.g. #f8f8f8.\n+\t\t *\/\n+\t\tFillcolor,\n+\t\t\/**\n+\t\t * The name of the font to use, e.g. helvetica, or helvetica:italics.\n+\t\t *\/\n+\t\tFontname,\n+\t\t\/**\n+\t\t * Have title area, true or false.\n+\t\t *\/\n+\t\tTitleArea,\n+\t\t\/**\n+\t\t * Font size of the title area, e.g. 16. Need to be parseable to a number.\n+\t\t *\/\n+\t\tTitleFontSize,\n+\t\t\/**\n+\t\t * Shape of the title area, e.g. box.\n+\t\t *\/\n+\t\tTitleShape,\n+\t\t\/**\n+\t\t * Shape of the nodes, e.g. box.\n+\t\t *\/\n+\t\tNodeShape,\n+\t\t\/**\n+\t\t * The color of the node, e.g. #b22b00.\n+\t\t *\/\n+\t\tNodeColor,\n+\t\t\/**\n+\t\t * The fill color of the node, e.g. #eddbd5.\n+\t\t *\/\n+\t\tNodeFillColor,\n+\t\t\/**\n+\t\t * Font size for the biggest node. This will be the font size used for the node with the\n+\t\t * biggest count or weight.\n+\t\t *\/\n+\t\tMaxNodeFontSize,\n+\t\t\/**\n+\t\t * Font size for the biggest node. This will be the font size used for the node with the\n+\t\t * smallest count or weight.\n+\t\t *\/\n+\t\tMinNodeFontSize,\n+\t\t\/**\n+\t\t * The attribute to use for node font size. [count|weight]\n+\t\t *\/\n+\t\tNodeSizeAttribute,\n+\t\t\/**\n+\t\t * The attribute to use for the edge weights. [count|weight]\n+\t\t *\/\n+\t\tEdgeWeightAttribute,\n+\t\t\/**\n+\t\t * The style for the edges. [solid|dotted|dashed|bold]\n+\t\t *\/\n+\t\tEdgeStyle,\n+\t\t\/**\n+\t\t * The max edge weight to use for the most traveled path.\n+\t\t *\/\n+\t\tMaxEdgeWeight,\n+\t\t\/**\n+\t\t * The min edge weight to use for the least traveled path.\n+\t\t *\/\n+\t\tMinEdgeWeight\n+\t}\n+\n+\tprivate final static class NodeConfigurator {\n+\t\tprivate static final String COUNT = DEFAULT_NODE_SIZE_ATTRIBUTE;\n+\t\tprivate final String shape;\n+\t\tprivate final boolean useCount;\n+\t\tprivate final double minCount;\n+\t\tprivate final double maxCount;\n+\t\tprivate final double minRange;\n+\t\tprivate final double maxRange;\n+\t\tprivate final int minFontSize;\n+\t\tprivate final int maxFontSize;\n+\t\tprivate final String color;\n+\t\tprivate final String fillColor;\n+\n+\t\tpublic NodeConfigurator(StacktraceGraphModel model, Map<ConfigurationKey, String> configuration) {\n+\t\t\tuseCount = getConf(configuration, ConfigurationKey.NodeSizeAttribute, COUNT).equals(COUNT);\n+\t\t\tminCount = model.findNodeMinCount();\n+\t\t\tmaxCount = model.findNodeMaxCount();\n+\n+\t\t\tif (useCount) {\n+\t\t\t\tmaxRange = maxCount;\n+\t\t\t\tminRange = minCount;\n+\t\t\t} else {\n+\t\t\t\tmaxRange = model.findNodeMaxWeight();\n+\t\t\t\tminRange = model.findNodeMinWeight();\n+\t\t\t}\n+\t\t\tmaxFontSize = Integer\n+\t\t\t\t\t.parseInt(getConf(configuration, ConfigurationKey.MaxNodeFontSize, DEFAULT_MAX_NODE_FONT_SIZE));\n+\t\t\tminFontSize = Integer\n+\t\t\t\t\t.parseInt(getConf(configuration, ConfigurationKey.MinNodeFontSize, DEFAULT_MIN_NODE_FONT_SIZE));\n+\t\t\tshape = getConf(configuration, ConfigurationKey.NodeShape, DEFAULT_SHAPE);\n+\t\t\tcolor = getConf(configuration, ConfigurationKey.NodeColor, \"#b22b00\");\n+\t\t\tfillColor = getConf(configuration, ConfigurationKey.NodeFillColor, \"#eddbd5\");\n+\t\t}\n+\n+\t\tpublic int getFontSize(Node node) {\n+\t\t\tdouble value = useCount ? node.getCount() : node.getWeight();\n+\t\t\tdouble fraction = (value - minRange) \/ (maxRange - minRange);\n+\t\t\treturn (int) Math.round((maxFontSize - minFontSize) * fraction + minFontSize);\n+\t\t}\n+\t}\n+\n+\tprivate final static class EdgeConfigurator {\n+\t\tprivate final boolean useCount;\n+\t\tprivate final double minWeight;\n+\t\tprivate final double maxWeight;\n+\t\tprivate final int minCount;\n+\t\tprivate final int maxCount;\n+\t\tprivate final double minRange;\n+\t\tprivate final double maxRange;\n+\t\tprivate final String style;\n+\n+\t\tpublic EdgeConfigurator(StacktraceGraphModel model, Map<ConfigurationKey, String> configuration) {\n+\t\t\tuseCount = getConf(configuration, ConfigurationKey.NodeSizeAttribute, DEFAULT_NODE_SIZE_ATTRIBUTE)\n+\t\t\t\t\t.equals(DEFAULT_NODE_SIZE_ATTRIBUTE);\n+\t\t\tminCount = model.findEdgeMinCount();\n+\t\t\tmaxCount = model.findEdgeMaxCount();\n+\n+\t\t\tif (useCount) {\n+\t\t\t\tminRange = minCount;\n+\t\t\t\tmaxRange = maxCount;\n+\t\t\t} else {\n+\t\t\t\tminRange = model.findEdgeMinValue();\n+\t\t\t\tmaxRange = model.findEdgeMaxValue();\n+\t\t\t}\n+\n+\t\t\tminWeight = Integer\n+\t\t\t\t\t.parseInt(getConf(configuration, ConfigurationKey.MinEdgeWeight, DEFAULT_MIN_EDGE_WEIGHT));\n+\t\t\tmaxWeight = Integer\n+\t\t\t\t\t.parseInt(getConf(configuration, ConfigurationKey.MaxEdgeWeight, DEFAULT_MAX_EDGE_WEIGHT));\n+\t\t\tstyle = getConf(configuration, ConfigurationKey.EdgeStyle, DEFAULT_EDGE_STYLE);\n+\t\t}\n+\n+\t\tpublic String generateTooltip(Edge e) {\n+\t\t\treturn e.getFrom().getFrame().getHumanReadableSeparatorSensitiveString() + \" -> \"\n+\t\t\t\t\t+ e.getTo().getFrame().getHumanReadableSeparatorSensitiveString() + \" (\" + getPercentage(e) + \" %)\";\n+\t\t}\n+\n+\t\tprivate String getPercentage(Edge e) {\n+\t\t\tdouble val = 0;\n+\t\t\tif (useCount) {\n+\t\t\t\tval = ((double) e.getCount()) \/ maxCount;\n+\t\t\t} else {\n+\t\t\t\tval = e.getValue() \/ maxRange;\n+\t\t\t}\n+\t\t\treturn String.format(\"%.3f\", val);\n+\t\t}\n+\n+\t\t\/**\n+\t\t * This is the weight for the edge, not the edge value.\n+\t\t *\/\n+\t\tpublic int getWeight(Edge edge) {\n+\t\t\tdouble value = useCount ? edge.getCount() : edge.getValue();\n+\t\t\tdouble fraction = (value - minRange) \/ (maxRange - minRange);\n+\t\t\treturn (int) Math.round((maxWeight - minWeight) * fraction + minWeight);\n+\t\t}\n+\n+\t\tpublic boolean isMax(Edge edge) {\n+\t\t\tif (useCount) {\n+\t\t\t\treturn edge.getCount() == maxCount;\n+\t\t\t} else {\n+\t\t\t\treturn edge.getValue() == maxRange;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic String getColor(Edge edge) {\n+\t\t\t\/\/ if weight == 0, then have as gray as possible,\n+\t\t\t\/\/ if weight == MAX_WEIGHT, keep it red.\n+\t\t\t\/\/ TODO Auto-generated method stub\n+\t\t\tint color = 0xb2 << 16;\n+\t\t\tdouble value = useCount ? edge.getCount() : edge.getValue();\n+\t\t\tdouble fraction = (value - minRange) \/ (maxRange - minRange);\n+\t\t\tint colorval = (int) ((1 - fraction) * 0xb2);\n+\t\t\tcolor = color | (colorval << 8) | colorval;\n+\t\t\treturn \"#\" + Integer.toHexString(color);\n+\t\t}\n+\t}\n+\n+\t\/**\n+\t * Renders a {@link StacktraceGraphModel} in DOT format.\n+\t *\/\n+\tpublic static String toDot(StacktraceGraphModel model, Map<ConfigurationKey, String> configuration) {\n+\t\tStringBuilder builder = new StringBuilder(2048);\n+\t\tString graphName = getConf(configuration, ConfigurationKey.Name, DEFAULT_NAME);\n+\t\tbuilder.append(String.format(\"digraph \\\"%s\\\" {%n\", graphName));\n+\n+\t\tcreateDefaultNodeSettingsEntry(builder, configuration);\n+\t\tif (Boolean.valueOf(getConf(configuration, ConfigurationKey.TitleArea, \"false\"))) {\n+\t\t\tcreateSubgraphNode(builder, graphName, configuration, model);\n+\t\t}\n+\n+\t\t\/\/ Convert Nodes\n+\t\tNodeConfigurator nodeConfigurator = new NodeConfigurator(model, configuration);\n+\t\tmodel.getNodes().forEach((node) -> emitNode(builder, model, nodeConfigurator, node));\n+\n+\t\t\/\/ Convert Edges\n+\t\tEdgeConfigurator edgeConfigurator = new EdgeConfigurator(model, configuration);\n+\t\tmodel.getEdges().forEach((edge) -> emitEdge(builder, model, edgeConfigurator, edge));\n+\n+\t\tbuilder.append(\"}\");\n+\t\treturn builder.toString();\n+\t}\n+\n+\tprivate static void createDefaultNodeSettingsEntry(\n+\t\tStringBuilder builder, Map<ConfigurationKey, String> configuration) {\n+\t\tbuilder.append(\"node [style=\");\n+\t\tbuilder.append(getConf(configuration, ConfigurationKey.Style, DEFAULT_STYLE));\n+\t\tbuilder.append(\" fillcolor=\\\"\");\n+\t\tbuilder.append(getConf(configuration, ConfigurationKey.Fillcolor, DEFAULT_FILL_COLOR));\n+\t\tbuilder.append(\"\\\" fontname=\\\"\");\n+\t\tbuilder.append(getConf(configuration, ConfigurationKey.Fontname, DEFAULT_FONT_NAME));\n+\t\tbuilder.append(\"\\\"]\\n\");\n+\t}\n+\n+\tprivate static void emitEdge(\n+\t\tStringBuilder builder, StacktraceGraphModel model, EdgeConfigurator edgeConfigurator, Edge edge) {\n+\t\tbuilder.append(\"N\");\n+\t\tbuilder.append(edge.getFrom().getNodeId());\n+\t\tbuilder.append(\" -> N\");\n+\t\tbuilder.append(edge.getTo().getNodeId());\n+\t\tbuilder.append(\" [label=\\\"\");\n+\t\tif (edgeConfigurator.useCount) {\n+\t\t\tbuilder.append(edge.getCount());\n+\t\t} else {\n+\t\t\tbuilder.append(edge.getValue());\n+\t\t}\n+\t\tbuilder.append(\"\\\"\");\n+\t\tint weight = edgeConfigurator.getWeight(edge);\n+\t\tif (weight >= 2) {\n+\t\t\tbuilder.append(\" weight=\");\n+\t\t\tbuilder.append(weight);\n+\t\t}\n+\t\tbuilder.append(edgeConfigurator.isMax(edge) ? \" penwidth=2 \" : \" \");\n+\t\tbuilder.append(\"color=\\\"\");\n+\t\tbuilder.append(edgeConfigurator.getColor(edge));\n+\t\tbuilder.append(\"\\\" tooltip=\\\"\");\n+\t\tString tooltip = edgeConfigurator.generateTooltip(edge);\n+\t\tbuilder.append(tooltip);\n+\t\tbuilder.append(\"\\\" labeltooltip=\\\"\");\n+\t\tbuilder.append(tooltip);\n+\t\tbuilder.append(\"\\\" style=\\\"\");\n+\t\tbuilder.append(edgeConfigurator.style);\n+\t\tbuilder.append(\"\\\"]\\n\");\n+\t}\n+\n+\tprivate static void emitNode(\n+\t\tStringBuilder builder, StacktraceGraphModel model, NodeConfigurator configurator, Node node) {\n+\t\tString percentOfSamples = String.format(\"%.3f %%\", node.getCount() * 100.0 \/ model.getTotalTraceCount());\n+\t\tbuilder.append(\"N\");\n+\t\tbuilder.append(node.getNodeId());\n+\t\tbuilder.append(\" [label=\\\"\");\n+\t\tbuilder.append(node.getFrame().getHumanReadableSeparatorSensitiveString());\n+\t\tbuilder.append(\"\\\\nSamples: \");\n+\t\tbuilder.append(node.getCount());\n+\t\tbuilder.append(\" (\");\n+\t\tbuilder.append(percentOfSamples);\n+\t\tbuilder.append(\")\\\" id=\\\"node\");\n+\t\tbuilder.append(node.getNodeId());\n+\t\tbuilder.append(\"\\\" fontsize=\");\n+\t\tbuilder.append(configurator.getFontSize(node));\n+\t\tbuilder.append(\" shape=\");\n+\t\tbuilder.append(configurator.shape);\n+\t\tbuilder.append(\" tooltip=\\\"\");\n+\t\tbuilder.append(node.getFrame().getHumanReadableSeparatorSensitiveString());\n+\t\tbuilder.append(\" (\");\n+\t\tbuilder.append(percentOfSamples);\n+\t\tbuilder.append(\" %)\\\" color=\\\"\");\n+\t\tbuilder.append(configurator.color);\n+\t\tbuilder.append(\"\\\" fillcolor=\\\"\");\n+\t\tbuilder.append(configurator.fillColor);\n+\t\tbuilder.append(\"\\\"]\\n\");\n+\t}\n+\n+\tprivate static void createSubgraphNode(\n+\t\tStringBuilder builder, String graphName, Map<ConfigurationKey, String> configuration,\n+\t\tStacktraceGraphModel model) {\n+\t\tbuilder.append(\"subgraph cluster_L { \");\n+\t\tbuilder.append(\"\\\"\");\n+\t\tbuilder.append(graphName);\n+\t\tbuilder.append(\"\\\" [shape=\");\n+\t\tbuilder.append(getConf(configuration, ConfigurationKey.TitleShape, DEFAULT_SHAPE));\n+\t\tbuilder.append(\" fontsize=\");\n+\t\tbuilder.append(getConf(configuration, ConfigurationKey.TitleFontSize, DEFAULT_TITLE_FONT_SIZE));\n+\t\tbuilder.append(\" label=\\\"\");\n+\t\tbuilder.append(graphName);\n+\t\tbuilder.append(\"\\\\nTypes: \");\n+\t\tbuilder.append(GraphModelUtils.getTypeNames(model.getItems()));\n+\t\tbuilder.append(\"\\\\lTotal samples = \");\n+\t\tbuilder.append(model.getTotalTraceCount());\n+\t\tbuilder.append(\"\\\\lTotal edge count = \");\n+\t\tbuilder.append(model.getTotalEdgeCount());\n+\t\tbuilder.append(\"\\\\l\\\" tooltip=\\\"\");\n+\t\tbuilder.append(graphName);\n+\t\tbuilder.append(\"\\\"] }\\n\");\n+\t}\n+\n+\t\/**\n+\t * @return an example configuration for the dot files, using the defaults.\n+\t *\/\n+\tpublic static Map<ConfigurationKey, String> getDefaultConfiguration() {\n+\t\tMap<ConfigurationKey, String> configuration = new HashMap<>();\n+\t\tconfiguration.put(ConfigurationKey.Name, DEFAULT_NAME);\n+\t\tconfiguration.put(ConfigurationKey.Fillcolor, DEFAULT_FILL_COLOR);\n+\t\tconfiguration.put(ConfigurationKey.NodeFillColor, DEFAULT_NODE_FILL_COLOR);\n+\t\tconfiguration.put(ConfigurationKey.Style, DEFAULT_STYLE);\n+\t\tconfiguration.put(ConfigurationKey.TitleShape, DEFAULT_SHAPE);\n+\t\tconfiguration.put(ConfigurationKey.TitleFontSize, DEFAULT_TITLE_FONT_SIZE);\n+\t\tconfiguration.put(ConfigurationKey.NodeShape, DEFAULT_SHAPE);\n+\t\tconfiguration.put(ConfigurationKey.NodeSizeAttribute, DEFAULT_NODE_SIZE_ATTRIBUTE);\n+\t\tconfiguration.put(ConfigurationKey.MaxNodeFontSize, DEFAULT_MAX_NODE_FONT_SIZE);\n+\t\tconfiguration.put(ConfigurationKey.MinNodeFontSize, DEFAULT_MIN_NODE_FONT_SIZE);\n+\t\tconfiguration.put(ConfigurationKey.MaxEdgeWeight, DEFAULT_MAX_EDGE_WEIGHT);\n+\t\tconfiguration.put(ConfigurationKey.MinEdgeWeight, DEFAULT_MIN_EDGE_WEIGHT);\n+\t\tconfiguration.put(ConfigurationKey.EdgeStyle, DEFAULT_EDGE_STYLE);\n+\t\tconfiguration.put(ConfigurationKey.Fontname, DEFAULT_FONT_NAME);\n+\t\treturn configuration;\n+\t}\n+\n+\tprivate static String getConf(\n+\t\tMap<ConfigurationKey, String> configuration, ConfigurationKey key, String defaultValue) {\n+\t\tString value = configuration.get(key);\n+\t\treturn value == null ? defaultValue : value;\n+\t}\n+\n+\t\/**\n+\t * Generates a dot file for the CPU profiling events available in the recording.\n+\t * \n+\t * @param args\n+\t * @throws IOException\n+\t * @throws CouldNotLoadRecordingException\n+\t *\/\n+\tpublic static void main(String[] args) throws IOException, CouldNotLoadRecordingException {\n+\t\tFile jfrFile = new File(args[0]);\n+\t\tIItemCollection items = JfrLoaderToolkit.loadEvents(jfrFile);\n+\t\tIItemCollection filteredItems = items.apply(JdkFilters.EXECUTION_SAMPLE);\n+\t\tFrameSeparator frameSeparator = new FrameSeparator(FrameCategorization.METHOD, false);\n+\t\tStacktraceGraphModel model = new StacktraceGraphModel(frameSeparator, filteredItems, null);\n+\t\tMap<ConfigurationKey, String> configuration = getDefaultConfiguration();\n+\t\tconfiguration.put(ConfigurationKey.Name, jfrFile.getName());\n+\t\tSystem.out.println(toDot(model, configuration));\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.flightrecorder.graphview\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/ext\/graphview\/graph\/DotGenerator.java","additions":424,"deletions":0,"binary":false,"changes":424,"status":"added"},{"patch":"@@ -0,0 +1,304 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.graphview.views;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.text.MessageFormat;\n+import java.util.Base64;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.logging.Level;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jface.viewers.ISelection;\n+import org.eclipse.jface.viewers.IStructuredSelection;\n+import org.eclipse.swt.SWT;\n+import org.eclipse.swt.browser.Browser;\n+import org.eclipse.swt.browser.ProgressAdapter;\n+import org.eclipse.swt.browser.ProgressEvent;\n+import org.eclipse.swt.custom.SashForm;\n+import org.eclipse.swt.events.MenuDetectEvent;\n+import org.eclipse.swt.events.MenuDetectListener;\n+import org.eclipse.swt.widgets.Composite;\n+import org.eclipse.ui.IMemento;\n+import org.eclipse.ui.ISelectionListener;\n+import org.eclipse.ui.IViewSite;\n+import org.eclipse.ui.IWorkbenchPart;\n+import org.eclipse.ui.PartInitException;\n+import org.eclipse.ui.part.ViewPart;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.util.StringToolkit;\n+import org.openjdk.jmc.flightrecorder.ext.graphview.graph.DotGenerator;\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator.FrameCategorization;\n+import org.openjdk.jmc.flightrecorder.stacktrace.graph.StacktraceGraphModel;\n+import org.openjdk.jmc.flightrecorder.ui.FlightRecorderUI;\n+import org.openjdk.jmc.flightrecorder.ui.ItemCollectionToolkit;\n+import org.openjdk.jmc.ui.common.util.AdapterUtil;\n+import org.openjdk.jmc.ui.misc.DisplayToolkit;\n+\n+public class GraphView extends ViewPart implements ISelectionListener {\n+\tprivate static final String HTML_PAGE;\n+\tstatic {\n+\t\tString jsD3V5 = \"jslibs\/d3.v5.min.js\";\n+\t\tString jsGraphviz = \"jslibs\/index.js\";\n+\t\tString wasmGraphviz = \"jslibs\/graphvizlib.wasm\";\n+\t\tString jsGraphizD3 = \"jslibs\/d3-graphviz.js\";\n+\n+\t\tString wasmBase64 = loadBase64FromFile(wasmGraphviz);\n+\n+\t\tHTML_PAGE = String.format(loadStringFromFile(\"page.template\"), loadLibraries(jsD3V5),\n+\t\t\t\t\/\/ we inline base64 wasm in the library code to avoid fetching it at runtime\n+\t\t\t\tloadStringFromFile(jsGraphviz, \"wasmBinaryFile=\\\"graphvizlib.wasm\\\";\",\n+\t\t\t\t\t\t\"wasmBinaryFile=dataURIPrefix + '\" + wasmBase64 + \"';\"),\n+\t\t\t\tloadLibraries(jsGraphizD3));\n+\t}\n+\n+\tprivate enum ModelState {\n+\t\tNOT_STARTED, STARTED, FINISHED, NONE;\n+\t}\n+\n+\tprivate static class ModelRebuildRunnable implements Runnable {\n+\t\tprivate final GraphView view;\n+\t\tprivate final FrameSeparator separator;\n+\t\tprivate IItemCollection items;\n+\t\tprivate volatile boolean isInvalid;\n+\n+\t\tprivate ModelRebuildRunnable(GraphView view, FrameSeparator separator, IItemCollection items) {\n+\t\t\tthis.view = view;\n+\t\t\tthis.items = items;\n+\t\t\tthis.separator = separator;\n+\t\t}\n+\n+\t\tprivate void setInvalid() {\n+\t\t\tthis.isInvalid = true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void run() {\n+\t\t\tview.modelState = ModelState.STARTED;\n+\t\t\tif (isInvalid) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\t\/\/ Add support for selected attribute later...\n+\t\t\tStacktraceGraphModel model = new StacktraceGraphModel(separator, items, null);\n+\t\t\tif (isInvalid) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString json = GraphView.toDot(model);\n+\t\t\tif (isInvalid) {\n+\t\t\t\treturn;\n+\t\t\t} else {\n+\t\t\t\tview.modelState = ModelState.FINISHED;\n+\t\t\t\tDisplayToolkit.inDisplayThread().execute(() -> view.setModel(items, json));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static final int MODEL_EXECUTOR_THREADS_NUMBER = 3;\n+\tprivate static final ExecutorService MODEL_EXECUTOR = Executors.newFixedThreadPool(MODEL_EXECUTOR_THREADS_NUMBER,\n+\t\t\tnew ThreadFactory() {\n+\t\t\t\tprivate ThreadGroup group = new ThreadGroup(\"GraphModelCalculationGroup\");\n+\t\t\t\tprivate AtomicInteger counter = new AtomicInteger();\n+\n+\t\t\t\t@Override\n+\t\t\t\tpublic Thread newThread(Runnable r) {\n+\t\t\t\t\tThread t = new Thread(group, r, \"GraphModelCalculation-\" + counter.getAndIncrement());\n+\t\t\t\t\tt.setDaemon(true);\n+\t\t\t\t\treturn t;\n+\t\t\t\t}\n+\t\t\t});\n+\tprivate FrameSeparator frameSeparator;\n+\tprivate Browser browser;\n+\tprivate SashForm container;\n+\tprivate IItemCollection currentItems;\n+\tprivate volatile ModelState modelState = ModelState.NONE;\n+\tprivate ModelRebuildRunnable modelRebuildRunnable;\n+\n+\t@Override\n+\tpublic void init(IViewSite site, IMemento memento) throws PartInitException {\n+\t\tsuper.init(site, memento);\n+\t\tframeSeparator = new FrameSeparator(FrameCategorization.METHOD, false);\n+\t\tgetSite().getPage().addSelectionListener(this);\n+\t}\n+\n+\t@Override\n+\tpublic void dispose() {\n+\t\tgetSite().getPage().removeSelectionListener(this);\n+\t\tsuper.dispose();\n+\t}\n+\n+\t@Override\n+\tpublic void createPartControl(Composite parent) {\n+\t\tcontainer = new SashForm(parent, SWT.HORIZONTAL);\n+\t\tbrowser = new Browser(container, SWT.NONE);\n+\t\tcontainer.setMaximizedControl(browser);\n+\t\tbrowser.addMenuDetectListener(new MenuDetectListener() {\n+\t\t\t@Override\n+\t\t\tpublic void menuDetected(MenuDetectEvent e) {\n+\t\t\t\te.doit = false;\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t@Override\n+\tpublic void setFocus() {\n+\t\tbrowser.setFocus();\n+\t}\n+\n+\t@Override\n+\tpublic void saveState(IMemento memento) {\n+\t}\n+\n+\t@Override\n+\tpublic void selectionChanged(IWorkbenchPart part, ISelection selection) {\n+\t\tif (selection instanceof IStructuredSelection) {\n+\t\t\tObject first = ((IStructuredSelection) selection).getFirstElement();\n+\t\t\tIItemCollection items = AdapterUtil.getAdapter(first, IItemCollection.class);\n+\t\t\tif (items == null) {\n+\t\t\t\ttriggerRebuildTask(ItemCollectionToolkit.build(Stream.empty()));\n+\t\t\t} else if (!items.equals(currentItems)) {\n+\t\t\t\ttriggerRebuildTask(items);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void triggerRebuildTask(IItemCollection items) {\n+\t\t\/\/ Release old model calculation before building a new\n+\t\tif (modelRebuildRunnable != null) {\n+\t\t\tmodelRebuildRunnable.setInvalid();\n+\t\t}\n+\n+\t\tcurrentItems = items;\n+\t\tmodelState = ModelState.NOT_STARTED;\n+\t\tmodelRebuildRunnable = new ModelRebuildRunnable(this, frameSeparator, items);\n+\t\tif (!modelRebuildRunnable.isInvalid) {\n+\t\t\tMODEL_EXECUTOR.execute(modelRebuildRunnable);\n+\t\t}\n+\t}\n+\n+\tprivate void setModel(final IItemCollection items, final String dotString) {\n+\t\tif (ModelState.FINISHED.equals(modelState) && items.equals(currentItems) && !browser.isDisposed()) {\n+\t\t\tsetViewerInput(dotString);\n+\t\t}\n+\t}\n+\n+\tprivate void setViewerInput(String model) {\n+\t\tbrowser.setText(HTML_PAGE);\n+\n+\t\tbrowser.addProgressListener(new ProgressAdapter() {\n+\t\t\tprivate boolean loaded = false;\n+\n+\t\t\t@Override\n+\t\t\tpublic void changed(ProgressEvent event) {\n+\t\t\t\tif (loaded) {\n+\t\t\t\t\tbrowser.removeProgressListener(this);\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic void completed(ProgressEvent event) {\n+\t\t\t\tbrowser.removeProgressListener(this);\n+\t\t\t\tbrowser.execute(String.format(\"processGraph(`%s`);\", model));\n+\t\t\t\tloaded = true;\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\tprivate static String toDot(StacktraceGraphModel model) {\n+\t\tif (model == null) {\n+\t\t\treturn \"\\\"\\\"\";\n+\t\t}\n+\t\treturn render(model);\n+\t}\n+\n+\tprivate static String render(StacktraceGraphModel model) {\n+\t\treturn DotGenerator.toDot(model, DotGenerator.getDefaultConfiguration());\n+\t}\n+\n+\tprivate static String loadLibraries(String ... libs) {\n+\t\tif (libs == null || libs.length == 0) {\n+\t\t\treturn \"\";\n+\t\t} else {\n+\t\t\tStringBuilder builder = new StringBuilder(2048);\n+\t\t\tfor (String lib : libs) {\n+\t\t\t\tbuilder.append(loadStringFromFile(lib));\n+\t\t\t\tbuilder.append(\"\\n\");\n+\t\t\t}\n+\t\t\treturn builder.toString();\n+\t\t}\n+\t}\n+\n+\tprivate static String loadStringFromFile(String fileName) {\n+\t\ttry {\n+\t\t\treturn StringToolkit.readString(GraphView.class.getClassLoader().getResourceAsStream(fileName));\n+\t\t} catch (IOException e) {\n+\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.WARNING,\n+\t\t\t\t\tMessageFormat.format(\"Could not load script \\\"{0}\\\",\\\"{1}\\\"\", fileName, e.getMessage())); \/\/$NON-NLS-1$\n+\t\t\treturn \"\";\n+\t\t}\n+\t}\n+\n+\tprivate static String loadStringFromFile(String fileName, String substr, String newSubstr) {\n+\t\tString content = loadStringFromFile(fileName);\n+\t\treturn content.replaceAll(substr, newSubstr);\n+\t}\n+\n+\tprivate static String loadBase64FromFile(String fileName) {\n+\t\ttry {\n+\t\t\tbyte[] fileBytes = readBytes(GraphView.class.getClassLoader().getResourceAsStream(fileName));\n+\t\t\treturn Base64.getEncoder().encodeToString(fileBytes);\n+\t\t} catch (IOException e) {\n+\t\t\tFlightRecorderUI.getDefault().getLogger().log(Level.WARNING,\n+\t\t\t\t\tMessageFormat.format(\"Could not load resource \\\"{0}\\\",\\\"{1}\\\"\", fileName, e.getMessage())); \/\/$NON-NLS-1$\n+\t\t\treturn \"\";\n+\t\t}\n+\t}\n+\n+\tpublic static byte[] readBytes(InputStream in) throws IOException {\n+\t\tBufferedInputStream bis = new BufferedInputStream(in);\n+\t\tByteArrayOutputStream buf = new ByteArrayOutputStream();\n+\t\tint result = bis.read();\n+\t\twhile (result != -1) {\n+\t\t\tbuf.write((byte) result);\n+\t\t\tresult = bis.read();\n+\t\t}\n+\t\treturn buf.toByteArray();\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.flightrecorder.graphview\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/graphview\/views\/GraphView.java","additions":304,"deletions":0,"binary":false,"changes":304,"status":"added"},{"patch":"","filename":"application\/org.openjdk.jmc.flightrecorder.graphview\/src\/main\/resources\/graph.css","additions":0,"deletions":0,"binary":false,"changes":0,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+<!DOCTYPE html \"-\/\/W3C\/\/DTD XHTML 1.0 Strict\/\/EN\" \"http:\/\/www.w3.org\/TR\/xhtml1\/DTD\/xhtml1-strict.dtd\">\n+<html xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\">\n+\n+<head>\n+\t<meta http-equiv=\"content-type\" content=\"text\/html; charset=utf-8\" \/>\n+\t<script>%1$s<\/script>\n+\t<script>%2$s<\/script>\n+\t<script>%3$s<\/script>\n+<\/head>\n+\n+<body>\n+\t<div id=\"graph\" style=\"text-align: center;\"><\/div>\n+\t<script type=\"text\/javascript\">\n+\t\t\n+\tvar graphviz;\n+\tvar margin = 20; \/\/ to avoid scrollbars\n+\n+\tvar currentDot;\t\t\n+\t\t\n+\tgraphviz = d3.select(\"#graph\").graphviz()\n+\t\t.zoomScaleExtent([.5, 100])\n+    \t.attributer(attributer)\n+    \t.renderDot(currentDot);\n+\n+\tfunction attributer(datum, index, nodes) {\n+\t    var selection = d3.select(this);\n+\t    if (datum.tag == \"svg\") {\n+\t        var width = window.innerWidth;\n+\t        var height = window.innerHeight;\n+\t        selection\n+\t            .attr(\"width\", width)\n+\t            .attr(\"height\", height)\n+\t        datum.attributes.width = width - margin;\n+\t        datum.attributes.height = height - margin;\n+\t    }\n+\t}\n+\n+\tfunction resetZoom() {\n+\t    graphviz\n+\t        .resetZoom(d3.transition().duration(1000));\n+\t}\n+\n+\tfunction resizeSVG() {\n+\t    console.log('Resize');\n+\t    var width = window.innerWidth;\n+\t    var height = window.innerHeight;\n+\t    d3.select(\"#graph\").selectWithoutDataPropagation(\"svg\")\n+\t        .transition()\n+\t        .duration(700)\n+\t        .attr(\"width\", width - margin)\n+\t        .attr(\"height\", height - margin);\n+\t};\n+\n+\td3.select(window).on(\"resize\", resizeSVG);\n+\td3.select(window).on(\"click\", resetZoom);\n+\t\n+\tfunction processGraph(dotString) {\n+\t\tcurrentDot = dotString;\t\t\t\n+\t\tgraphviz.renderDot(dotString);\n+\t\tresetZoom();\n+\t};\n+\t<\/script>\n+<\/body>\n+<\/html>\n\\ No newline at end of file\n","filename":"application\/org.openjdk.jmc.flightrecorder.graphview\/src\/main\/resources\/page.template","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.ext.graphview.graph;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+\n+import org.junit.jupiter.api.Test;\n+import org.openjdk.jmc.common.item.Aggregators;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.flightrecorder.CouldNotLoadRecordingException;\n+import org.openjdk.jmc.flightrecorder.JfrLoaderToolkit;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkFilters;\n+import org.openjdk.jmc.flightrecorder.stacktrace.graph.GraphModelUtils;\n+import org.openjdk.jmc.flightrecorder.stacktrace.graph.StacktraceGraphModel;\n+\n+final class GraphModelTest {\n+\n+\t@Test\n+\tvoid testBuildGraph() throws IOException, CouldNotLoadRecordingException {\n+\t\tIItemCollection events = JfrLoaderToolkit\n+\t\t\t\t.loadEvents(GraphModelTest.class.getResourceAsStream(\"hotmethods.jfr\"));\n+\t\tassertTrue(events.hasItems());\n+\t\tIItemCollection executionSamples = events.apply(JdkFilters.EXECUTION_SAMPLE);\n+\t\tassertTrue(executionSamples.hasItems());\n+\t\tassertEquals(executionSamples.getAggregate(Aggregators.count()).longValue(), 24526);\n+\t\tStacktraceGraphModel model = new StacktraceGraphModel(GraphModelUtils.DEFAULT_FRAME_SEPARATOR, executionSamples,\n+\t\t\t\tnull);\n+\t\tassertFalse(\"No nodes!\", model.getNodes().isEmpty());\n+\t\tassertFalse(\"No edges!\", model.getEdges().isEmpty());\n+\t}\n+\n+\tpublic static void main(String[] args) throws IOException, CouldNotLoadRecordingException {\n+\t\tnew GraphModelTest().testBuildGraph();\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.flightrecorder.graphview\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/ext\/graphview\/graph\/GraphModelTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"filename":"application\/org.openjdk.jmc.flightrecorder.graphview\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/ext\/graphview\/graph\/hotmethods.jfr","binary":true,"status":"added"},{"patch":"@@ -89,0 +89,1 @@\n+\t\t<module>org.openjdk.jmc.flightrecorder.graphview<\/module>\n","filename":"application\/pom.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error\n@@ -5,0 +6,1 @@\n+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules\/.settings\/org.eclipse.jdt.core.prefs","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-<\/classpath>\r\n+<\/classpath>\n\\ No newline at end of file\n","filename":"core\/org.openjdk.jmc.flightrecorder\/.classpath","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,4 @@\n-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7\n-org.eclipse.jdt.core.compiler.compliance=1.7\n+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled\n+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8\n+org.eclipse.jdt.core.compiler.compliance=1.8\n+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error\n@@ -5,0 +7,1 @@\n+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error\n@@ -8,1 +11,1 @@\n-org.eclipse.jdt.core.compiler.source=1.7\n+org.eclipse.jdt.core.compiler.source=1.8\n","filename":"core\/org.openjdk.jmc.flightrecorder\/.settings\/org.eclipse.jdt.core.prefs","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -16,0 +16,1 @@\n+ org.openjdk.jmc.flightrecorder.stacktrace.graph,\n","filename":"core\/org.openjdk.jmc.flightrecorder\/META-INF\/MANIFEST.MF","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.stacktrace.graph;\n+\n+import org.openjdk.jmc.common.IMCFrame;\n+import org.openjdk.jmc.common.IMCMethod;\n+import org.openjdk.jmc.common.util.FormatToolkit;\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;\n+\n+\/**\n+ * Frame wrapper taking into account a frame separator for hash code and equals.\n+ *\/\n+public final class AggregatableFrame implements IMCFrame {\n+\tprivate final FrameSeparator separator;\n+\tprivate final IMCFrame frame;\n+\n+\t\/**\n+\t * Constructor.\n+\t * \n+\t * @param separator\n+\t *            can't be null.\n+\t * @param frame\n+\t *            can't be null.\n+\t *\/\n+\tpublic AggregatableFrame(FrameSeparator separator, IMCFrame frame) {\n+\t\tif (separator == null) {\n+\t\t\tthrow new NullPointerException(\"Separator must not be null\");\n+\t\t} else if (frame == null) {\n+\t\t\tthrow new NullPointerException(\"Frame must not be null\");\n+\t\t}\n+\t\tthis.separator = separator;\n+\t\tthis.frame = frame;\n+\t}\n+\n+\t@Override\n+\tpublic Integer getFrameLineNumber() {\n+\t\treturn frame.getFrameLineNumber();\n+\t}\n+\n+\t@Override\n+\tpublic Integer getBCI() {\n+\t\treturn frame.getBCI();\n+\t}\n+\n+\t@Override\n+\tpublic IMCMethod getMethod() {\n+\t\treturn frame.getMethod();\n+\t}\n+\n+\t@Override\n+\tpublic Type getType() {\n+\t\treturn frame.getType();\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tswitch (separator.getCategorization()) {\n+\t\tcase LINE:\n+\t\t\treturn frame.getMethod().hashCode() + 31 * frame.getFrameLineNumber();\n+\t\tcase METHOD:\n+\t\t\treturn frame.getMethod().hashCode();\n+\t\tcase CLASS:\n+\t\t\treturn frame.getMethod().getType().hashCode();\n+\t\tcase PACKAGE:\n+\t\t\treturn frame.getMethod().getType().getPackage().hashCode();\n+\t\tcase BCI:\n+\t\t}\n+\t\treturn frame.hashCode();\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tAggregatableFrame other = (AggregatableFrame) obj;\n+\t\treturn !separator.isSeparate(this.frame, other.frame);\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn FormatToolkit.getHumanReadable(getMethod()) + \":\" + separator.getCategorization();\n+\t}\n+\n+\tpublic String getHumanReadableSeparatorSensitiveString() {\n+\t\tswitch (separator.getCategorization()) {\n+\t\tcase LINE:\n+\t\t\treturn FormatToolkit.getHumanReadable(getMethod()) + \":\" + frame.getFrameLineNumber();\n+\t\tcase METHOD:\n+\t\t\treturn FormatToolkit.getHumanReadable(getMethod());\n+\t\tcase CLASS:\n+\t\t\treturn frame.getMethod().getType().getFullName();\n+\t\tcase PACKAGE:\n+\t\t\treturn frame.getMethod().getType().getPackage().getName();\n+\t\tdefault:\n+\t\t\treturn FormatToolkit.getHumanReadable(getMethod()) + \":\" + frame.getFrameLineNumber() + \"(\" + getBCI()\n+\t\t\t\t\t+ \")\";\n+\t\t}\n+\t}\n+\n+\tpublic String getHumanReadableShortString() {\n+\t\treturn FormatToolkit.getHumanReadable(getMethod(), false, false, true, false, true, false);\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/graph\/AggregatableFrame.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.stacktrace.graph;\n+\n+\/**\n+ * An edge in the graph of aggregated stack traces.\n+ *\/\n+public final class Edge {\n+\tprivate final Node from;\n+\tprivate final Node to;\n+\tint count;\n+\tdouble value;\n+\n+\t\/**\n+\t * Constructor.\n+\t * \n+\t * @param from\n+\t *            non null from node.\n+\t * @param to\n+\t *            non null to node.\n+\t *\/\n+\tpublic Edge(Node from, Node to) {\n+\t\tif (from == null || to == null) {\n+\t\t\tthrow new NullPointerException(\"Nodes must not be null\");\n+\t\t}\n+\t\tthis.from = from;\n+\t\tthis.to = to;\n+\t}\n+\n+\tpublic Node getFrom() {\n+\t\treturn from;\n+\t}\n+\n+\tpublic Node getTo() {\n+\t\treturn to;\n+\t}\n+\n+\tpublic int getCount() {\n+\t\treturn count;\n+\t}\n+\n+\tpublic double getValue() {\n+\t\treturn value;\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tfinal int prime = 31;\n+\t\tint result = 1;\n+\t\tresult = prime * result + from.hashCode();\n+\t\tresult = prime * result + to.hashCode();\n+\t\treturn result;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (obj == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tEdge other = (Edge) obj;\n+\t\tif (!from.equals(other.from)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (!to.equals(other.to)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn getFrom().toString() + \" -> \" + getTo().toString() + \", count = \" + count;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/graph\/Edge.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.stacktrace.graph;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator.FrameCategorization;\n+\n+public final class GraphModelUtils {\n+\tpublic final static FrameSeparator DEFAULT_FRAME_SEPARATOR = new FrameSeparator(FrameCategorization.METHOD, false);\n+\n+\tpublic static String printGraph(StacktraceGraphModel model) {\n+\t\tStringBuilder builder = new StringBuilder();\n+\t\tbuilder.append(\"=== Graph Printout ===\\n\");\n+\t\tprintNodes(builder, model.getNodes());\n+\t\tprintLinks(builder, model.getEdges());\n+\t\treturn builder.toString();\n+\t}\n+\n+\tpublic static String getTypeNames(IItemCollection items) {\n+\t\tList<String> typeNames = new LinkedList<>();\n+\t\titems.forEach((iterable) -> typeNames.add(iterable.getType().getName()));\n+\t\treturn String.join(\", \", typeNames);\n+\n+\t}\n+\n+\tprivate static void printLinks(StringBuilder builder, Collection<Edge> edges) {\n+\t\tbuilder.append(\"Number of edges:\");\n+\t\tbuilder.append(edges.size());\n+\t\tbuilder.append(\"\\n\");\n+\t}\n+\n+\tprivate static void printNodes(StringBuilder builder, Collection<Node> nodes) {\n+\t\tbuilder.append(\"Number of nodes:\");\n+\t\tbuilder.append(nodes.size());\n+\t\tbuilder.append(\"\\n\");\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/graph\/GraphModelUtils.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.stacktrace.graph;\n+\n+\/**\n+ * A node in the graph of aggregated stack traces.\n+ *\/\n+public final class Node {\n+\t\/**\n+\t * Integer uniquely identifying this node within the graph instance.\n+\t *\/\n+\tprivate final Integer nodeId;\n+\n+\t\/**\n+\t * The frame associated with this node.\n+\t *\/\n+\tprivate final AggregatableFrame frame;\n+\n+\t\/**\n+\t * The number of times being the top frame.\n+\t *\/\n+\tint count;\n+\n+\t\/**\n+\t * The number of times found in any stack-trace.\n+\t *\/\n+\tint cumulativeCount;\n+\n+\t\/**\n+\t * The weight when being the top frame.\n+\t *\/\n+\tdouble weight;\n+\n+\t\/**\n+\t * The cumulative weight for all contributions.\n+\t *\/\n+\tdouble cumulativeWeight;\n+\n+\tpublic Node(Integer nodeId, AggregatableFrame frame) {\n+\t\tthis.nodeId = nodeId;\n+\t\tthis.frame = frame;\n+\t\tif (frame == null) {\n+\t\t\tthrow new NullPointerException(\"Frame cannot be null!\");\n+\t\t}\n+\t}\n+\n+\t\/**\n+\t * @return the number of times this node was on the top of the stack.\n+\t *\/\n+\tpublic int getCount() {\n+\t\treturn count;\n+\t}\n+\n+\t\/**\n+\t * @return the weight of this node.\n+\t *\/\n+\tpublic double getWeight() {\n+\t\treturn weight;\n+\t}\n+\n+\t\/**\n+\t * @return the number of times this node was passed through.\n+\t *\/\n+\tpublic int getCumulativeCount() {\n+\t\treturn cumulativeCount;\n+\t}\n+\n+\tpublic AggregatableFrame getFrame() {\n+\t\treturn frame;\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\t\/\/ This will get a few extra collisions.\n+\t\treturn frame.getMethod().hashCode();\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tNode other = (Node) obj;\n+\t\tif (frame == null) {\n+\t\t\tif (other.frame != null)\n+\t\t\t\treturn false;\n+\t\t}\n+\t\treturn frame.equals(other.frame);\n+\t}\n+\n+\tpublic Integer getNodeId() {\n+\t\treturn nodeId;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn String.format(\"%s counts:%d(%d),weights:%.2f(%.2f)\", frame.toString(), count, cumulativeCount, weight,\n+\t\t\t\tcumulativeWeight);\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/graph\/Node.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,364 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.stacktrace.graph;\n+\n+import static org.openjdk.jmc.common.item.ItemToolkit.accessor;\n+import static org.openjdk.jmc.flightrecorder.JfrAttributes.EVENT_STACKTRACE;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openjdk.jmc.common.IMCFrame;\n+import org.openjdk.jmc.common.IMCStackTrace;\n+import org.openjdk.jmc.common.item.IAttribute;\n+import org.openjdk.jmc.common.item.IItem;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.item.IItemIterable;\n+import org.openjdk.jmc.common.item.IMemberAccessor;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.flightrecorder.CouldNotLoadRecordingException;\n+import org.openjdk.jmc.flightrecorder.JfrLoaderToolkit;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkFilters;\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator.FrameCategorization;\n+\n+\/**\n+ * A model for holding multiple stack traces and their relations to each other as a directed graph.\n+ * <p>\n+ * The model is state-less. The model is created and built once, and read only.\n+ * <p>\n+ * Instances of this class are thread safe.\n+ * <p>\n+ * The typical way of using this class is to first decide on the {@link FrameSeparator} and then\n+ * create the model.\n+ * <p>\n+ * Opening a Java flight Recording and setting up the stack trace model can be done like this:\n+ *\n+ * <pre>\n+ * IItemCollection items = JfrLoaderToolkit.loadEvents(file);\n+ * IItemCollection filteredItems = items.apply(JdkFilters.EXECUTION_SAMPLE);\n+ * FrameSeparator frameSeparator = new FrameSeparator(FrameCategorization.METHOD, false);\n+ * StacktraceGraphModel model = new StacktraceGraphModel(frameSeparator, filteredItems);\n+ * <\/pre>\n+ *\/\n+public final class StacktraceGraphModel {\n+\t@SuppressWarnings(\"deprecation\")\n+\tprivate final static IMemberAccessor<IMCStackTrace, IItem> ACCESSOR_STACKTRACE = accessor(EVENT_STACKTRACE);\n+\tprivate final FrameSeparator frameSeparator;\n+\tprivate final IItemCollection items;\n+\tprivate final IAttribute<IQuantity> attribute;\n+\tprivate int totalTraceCount;\n+\tprivate int totalEdgeCount;\n+\tprivate int nodeCounter;\n+\n+\t\/**\n+\t * From node id -> Edge\n+\t *\/\n+\tprivate final Map<Integer, Set<Edge>> edges = new HashMap<>(1024);\n+\n+\t\/**\n+\t * Frame -> Node\n+\t *\/\n+\tprivate final Map<AggregatableFrame, Node> nodes = new HashMap<>(1024);\n+\n+\t\/**\n+\t * Constructor.\n+\t * \n+\t * @param frameSeparator\n+\t *            how to aggregate frames.\n+\t * @param items\n+\t *            the items to graph.\n+\t * @param attribute\n+\t *            the (optional) attribute to use for calculating the values.\n+\t *\/\n+\tpublic StacktraceGraphModel(FrameSeparator frameSeparator, IItemCollection items, IAttribute<IQuantity> attribute) {\n+\t\tthis.frameSeparator = frameSeparator;\n+\t\tthis.items = items;\n+\t\tthis.attribute = attribute;\n+\t\tbuildModel();\n+\t}\n+\n+\tpublic Collection<Edge> getEdges() {\n+\t\treturn edges.values().stream().flatMap((c) -> c.stream()).collect(Collectors.toSet());\n+\t}\n+\n+\tpublic Collection<Node> getNodes() {\n+\t\treturn nodes.values();\n+\t}\n+\n+\tpublic IAttribute<IQuantity> getAttribute() {\n+\t\treturn attribute;\n+\t}\n+\n+\tpublic boolean isEmpty() {\n+\t\treturn nodes.isEmpty();\n+\t}\n+\n+\tpublic IItemCollection getItems() {\n+\t\treturn items;\n+\t}\n+\n+\t\/**\n+\t * @return the total edge count, i.e. the total sum of counts for all edges.\n+\t *\/\n+\tpublic int getTotalEdgeCount() {\n+\t\treturn totalEdgeCount;\n+\t}\n+\n+\t\/**\n+\t * @return the total amount of stack traces use to build this model.\n+\t *\/\n+\tpublic int getTotalTraceCount() {\n+\t\treturn totalTraceCount;\n+\t}\n+\n+\t\/**\n+\t * Searches the nodes for the min count.\n+\t * \n+\t * @return the min count.\n+\t *\/\n+\tpublic int findNodeMinCount() {\n+\t\tint minCount = Integer.MAX_VALUE;\n+\t\tfor (Node n : getNodes()) {\n+\t\t\tminCount = Math.min(n.getCount(), minCount);\n+\t\t}\n+\t\treturn minCount;\n+\t}\n+\n+\t\/**\n+\t * Searches the nodes for the max count.\n+\t * \n+\t * @return the max count.\n+\t *\/\n+\tpublic int findNodeMaxCount() {\n+\t\tint maxCount = 0;\n+\t\tfor (Node n : getNodes()) {\n+\t\t\tmaxCount = Math.max(n.getCount(), maxCount);\n+\t\t}\n+\t\treturn maxCount;\n+\t}\n+\n+\t\/**\n+\t * Searches the nodes for the min weight.\n+\t * \n+\t * @return the min weight.\n+\t *\/\n+\tpublic double findNodeMinWeight() {\n+\t\tdouble minWeight = Double.MAX_VALUE;\n+\t\tfor (Node n : getNodes()) {\n+\t\t\tminWeight = Math.min(n.getWeight(), minWeight);\n+\t\t}\n+\t\treturn minWeight;\n+\t}\n+\n+\t\/**\n+\t * Searches the nodes for the max weight.\n+\t * \n+\t * @return the max weight.\n+\t *\/\n+\tpublic double findNodeMaxWeight() {\n+\t\tdouble maxWeight = 0.0d;\n+\t\tfor (Node n : getNodes()) {\n+\t\t\tmaxWeight = Math.max(n.getWeight(), maxWeight);\n+\t\t}\n+\t\treturn maxWeight;\n+\t}\n+\n+\t\/**\n+\t * Searches the edges for the min value.\n+\t * \n+\t * @return the min value.\n+\t *\/\n+\tpublic double findEdgeMinValue() {\n+\t\tdouble minValue = Double.MAX_VALUE;\n+\t\tfor (Edge e : getEdges()) {\n+\t\t\tminValue = Math.min(e.getValue(), minValue);\n+\t\t}\n+\t\treturn minValue;\n+\t}\n+\n+\t\/**\n+\t * Searches the edges for the max value.\n+\t * \n+\t * @return the max value.\n+\t *\/\n+\tpublic double findEdgeMaxValue() {\n+\t\tdouble maxValue = 0.0d;\n+\t\tfor (Edge e : getEdges()) {\n+\t\t\tmaxValue = Math.max(e.getValue(), maxValue);\n+\t\t}\n+\t\treturn maxValue;\n+\t}\n+\n+\t\/**\n+\t * Searches the edges for the min count.\n+\t * \n+\t * @return the min count.\n+\t *\/\n+\tpublic int findEdgeMinCount() {\n+\t\tint minValue = Integer.MAX_VALUE;\n+\t\tfor (Edge e : getEdges()) {\n+\t\t\tminValue = Math.min(e.getCount(), minValue);\n+\t\t}\n+\t\treturn minValue;\n+\t}\n+\n+\t\/**\n+\t * Searches the edges for the max count.\n+\t * \n+\t * @return the max count.\n+\t *\/\n+\tpublic int findEdgeMaxCount() {\n+\t\tint maxValue = 0;\n+\t\tfor (Edge e : getEdges()) {\n+\t\t\tmaxValue = Math.max(e.getCount(), maxValue);\n+\t\t}\n+\t\treturn maxValue;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn String.format(\n+\t\t\t\t\"=== StackTraceModel ===\\nNode Count:%d\\nEdge Count:%d\\nNodes: %s\\nEdges: %s\\n========================\",\n+\t\t\t\tnodes.size(), edges.size(), nodes.toString(), edges.toString());\n+\t}\n+\n+\tprivate void buildModel() {\n+\t\tfor (IItemIterable iterable : items) {\n+\t\t\titerable.forEach((item) -> addItem(item, getAccessor(iterable, attribute)));\n+\t\t}\n+\t}\n+\n+\tprivate static IMemberAccessor<IQuantity, IItem> getAccessor(IItemIterable iterable, IAttribute<IQuantity> attr) {\n+\t\tIMemberAccessor<IQuantity, IItem> accessor = null;\n+\t\tif (attr != null) {\n+\t\t\taccessor = iterable.getType().getAccessor(attr.getKey());\n+\t\t}\n+\t\treturn accessor;\n+\t}\n+\n+\tprivate void addItem(IItem item, IMemberAccessor<IQuantity, IItem> accessor) {\n+\t\tIMCStackTrace stackTrace = getStackTrace(item);\n+\t\tif (stackTrace == null) {\n+\t\t\treturn;\n+\t\t}\n+\t\tList<? extends IMCFrame> frames = getStackTrace(item).getFrames();\n+\t\tif (frames.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tdouble value = 0;\n+\t\tif (accessor != null) {\n+\t\t\tvalue = accessor.getMember(item).doubleValue();\n+\t\t}\n+\n+\t\t\/\/ First frame is the frame where things are actually happening, i.e. the method\n+\t\t\/\/ actually responsible for whatever is being tracked (e.g. the method being on\n+\t\t\/\/ CPU, the method triggering the allocation etc) - it is for this node we\n+\t\t\/\/ increment the count...\n+\t\tIMCFrame firstFrame = frames.get(0);\n+\t\tNode n = getOrCreateNode(firstFrame);\n+\t\ttotalTraceCount++;\n+\t\tn.count++;\n+\t\tn.weight += value;\n+\n+\t\t\/\/ Next go through all frames from the thread root, and up the cumulative counts\n+\t\tfor (int i = frames.size() - 1; i > 0; i--) {\n+\t\t\t\/\/ Process two frames sliding window, from and to\n+\t\t\tIMCFrame currentFrame = frames.get(i);\n+\t\t\tIMCFrame nextFrame = frames.get(i - 1);\n+\n+\t\t\tNode currentNode = getOrCreateNode(currentFrame);\n+\t\t\tNode nextNode = getOrCreateNode(nextFrame);\n+\n+\t\t\tcurrentNode.cumulativeCount++;\n+\t\t\tnextNode.cumulativeCount++;\n+\t\t\tcurrentNode.cumulativeWeight += value;\n+\t\t\tnextNode.cumulativeWeight += value;\n+\t\t\tEdge e = getOrCreateLink(currentNode, nextNode);\n+\t\t\te.count++;\n+\t\t\ttotalEdgeCount++;\n+\t\t}\n+\t}\n+\n+\tprivate Node getOrCreateNode(IMCFrame frame) {\n+\t\tAggregatableFrame aframe = new AggregatableFrame(frameSeparator, frame);\n+\t\tNode n = nodes.get(aframe);\n+\t\tif (n == null) {\n+\t\t\tn = new Node(Integer.valueOf(nodeCounter++), aframe);\n+\t\t\tnodes.put(aframe, n);\n+\t\t}\n+\t\treturn n;\n+\t}\n+\n+\tprivate Edge getOrCreateLink(Node fromNode, Node toNode) {\n+\t\tif (!edges.containsKey(fromNode.getNodeId())) {\n+\t\t\tEdge edge = new Edge(fromNode, toNode);\n+\t\t\tSet<Edge> newEdgeSet = new HashSet<>();\n+\t\t\tnewEdgeSet.add(edge);\n+\t\t\tedges.put(fromNode.getNodeId(), newEdgeSet);\n+\t\t\treturn edge;\n+\t\t}\n+\t\tSet<Edge> toSet = edges.get(fromNode.getNodeId());\n+\t\t\/\/ We assume that we have a reasonable amount of edges from a node - so linear\n+\t\t\/\/ search is ok\n+\t\tfor (Edge edge : toSet) {\n+\t\t\tif (edge.getTo().equals(toNode)) {\n+\t\t\t\treturn edge;\n+\t\t\t}\n+\t\t}\n+\t\tEdge edge = new Edge(fromNode, toNode);\n+\t\ttoSet.add(edge);\n+\t\treturn edge;\n+\t}\n+\n+\tprivate IMCStackTrace getStackTrace(IItem item) {\n+\t\treturn ACCESSOR_STACKTRACE.getMember(item);\n+\t}\n+\n+\tpublic static void main(String[] args) throws IOException, CouldNotLoadRecordingException {\n+\t\tIItemCollection items = JfrLoaderToolkit.loadEvents(new File(args[0]));\n+\t\tIItemCollection filteredItems = items.apply(JdkFilters.EXECUTION_SAMPLE);\n+\t\tFrameSeparator frameSeparator = new FrameSeparator(FrameCategorization.METHOD, false);\n+\t\tStacktraceGraphModel model = new StacktraceGraphModel(frameSeparator, filteredItems, null);\n+\t\tSystem.out.println(GraphModelUtils.printGraph(model));\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/graph\/StacktraceGraphModel.java","additions":364,"deletions":0,"binary":false,"changes":364,"status":"added"}]}