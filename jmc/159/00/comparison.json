{"files":[{"patch":"@@ -14,0 +14,3 @@\n+Export-Package: org.openjdk.jmc.flightrecorder.flameview,\n+ org.openjdk.jmc.flightrecorder.flameview.tree,\n+ org.openjdk.jmc.flightrecorder.flameview.views\n","filename":"application\/org.openjdk.jmc.flightrecorder.flameview\/META-INF\/MANIFEST.MF","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.flameview;\n+\n+import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_HTML_MORE;\n+import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_HTML_TABLE_EVENT_PATTERN;\n+import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_HTML_TABLE_EVENT_REST_PATTERN;\n+import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_ROOT_NODE;\n+import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_ROOT_NODE_EVENT;\n+import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_ROOT_NODE_EVENTS;\n+import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_ROOT_NODE_TYPE;\n+import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_ROOT_NODE_TYPES;\n+import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_TITLE_EVENT_MORE_DELIMITER;\n+import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_TITLE_EVENT_PATTERN;\n+import static org.openjdk.jmc.flightrecorder.flameview.MessagesUtils.getFlameviewMessage;\n+import static org.openjdk.jmc.flightrecorder.flameview.MessagesUtils.getStacktraceMessage;\n+import static org.openjdk.jmc.flightrecorder.stacktrace.Messages.STACKTRACE_UNCLASSIFIABLE_FRAME;\n+import static org.openjdk.jmc.flightrecorder.stacktrace.Messages.STACKTRACE_UNCLASSIFIABLE_FRAME_DESC;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.openjdk.jmc.common.IMCFrame;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.item.IItemIterable;\n+import org.openjdk.jmc.common.util.FormatToolkit;\n+import org.openjdk.jmc.flightrecorder.stacktrace.tree.AggregatableFrame;\n+import org.openjdk.jmc.flightrecorder.stacktrace.tree.Node;\n+import org.openjdk.jmc.flightrecorder.stacktrace.tree.StacktraceTreeModel;\n+\n+public class FlameGraphJSONMarshaller {\n+\n+\tprivate static final String UNCLASSIFIABLE_FRAME = getStacktraceMessage(STACKTRACE_UNCLASSIFIABLE_FRAME);\n+\tprivate static final String UNCLASSIFIABLE_FRAME_DESC = getStacktraceMessage(STACKTRACE_UNCLASSIFIABLE_FRAME_DESC);\n+\tprivate final static int MAX_TYPES_IN_ROOT_TITLE = 2;\n+\tprivate final static int MAX_TYPES_IN_ROOT_DESCRIPTION = 10;\n+\n+\tpublic static String toJSON(StacktraceTreeModel model) {\n+\t\treturn toJSON(model, model.getRoot());\n+\t}\n+\n+\tprivate static String toJSON(StacktraceTreeModel model, Node node) {\n+\t\tMap<Integer, Set<Integer>> childrenLookup = model.getChildrenLookup();\n+\t\tMap<Integer, Node> nodes = model.getNodes();\n+\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\tsb.append(\"{\");\n+\t\tif (node.equals(model.getRoot())) {\n+\t\t\tsb.append(createRootNodeJSON(model.getItems()));\n+\t\t} else {\n+\t\t\tsb.append(JSONProps(node.getFrame(), node.getCumulativeWeight()));\n+\t\t}\n+\n+\t\tSet<Integer> childIds = childrenLookup.get(node.getNodeId());\n+\t\tsb.append(\", \").append(addQuotes(\"c\")).append(\": [ \");\n+\t\tboolean first = true;\n+\t\tfor (int childId : childIds) {\n+\t\t\tif (!first) {\n+\t\t\t\tsb.append(\",\");\n+\t\t\t}\n+\t\t\tsb.append(toJSON(model, nodes.get(childId)));\n+\t\t\tfirst = false;\n+\t\t}\n+\t\tsb.append(\"]\").append(\"}\");\n+\t\treturn sb.toString();\n+\t}\n+\n+\tprivate static String JSONProps(AggregatableFrame frame, double value) {\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\tif (frame.getType().equals(IMCFrame.Type.UNKNOWN)) {\n+\t\t\t\/\/ TODO: this is untested\n+\t\t\tsb.append(addQuotes(\"n\")).append(\": \").append(addQuotes(UNCLASSIFIABLE_FRAME));\n+\t\t\tsb.append(\",\");\n+\t\t\tsb.append(addQuotes(\"d\")).append(\": \").append(addQuotes(UNCLASSIFIABLE_FRAME_DESC));\n+\t\t\tsb.append(\",\");\n+\t\t\tsb.append(addQuotes(\"p\")).append(\": \").append(addQuotes(\"\"));\n+\t\t\tsb.append(\",\");\n+\t\t} else {\n+\t\t\tsb.append(addQuotes(\"n\")).append(\": \").append(addQuotes(frame.getHumanReadableShortString()));\n+\t\t\tsb.append(\",\");\n+\t\t\tsb.append(addQuotes(\"p\")).append(\": \")\n+\t\t\t\t\t.append(addQuotes(FormatToolkit.getPackage(frame.getMethod().getType().getPackage())));\n+\t\t\tsb.append(\",\");\n+\t\t}\n+\t\tsb.append(addQuotes(\"v\")).append(\": \").append(addQuotes(String.valueOf((int) value)));\n+\t\treturn sb.toString();\n+\t}\n+\n+\tprivate static String JSONProps(String frameName, String description) {\n+\t\tStringBuilder sb = new StringBuilder();\n+\t\tsb.append(addQuotes(\"n\")).append(\": \").append(addQuotes(frameName));\n+\t\tsb.append(\",\");\n+\t\tsb.append(addQuotes(\"p\")).append(\": \").append(addQuotes(\"\"));\n+\t\tsb.append(\",\");\n+\t\tsb.append(addQuotes(\"d\")).append(\": \").append(addQuotes(description));\n+\t\treturn sb.toString();\n+\t}\n+\n+\tprivate static String addQuotes(String str) {\n+\t\treturn String.format(\"\\\"%s\\\"\", str);\n+\t}\n+\n+\tpublic static Map<String, Long> countEventsByType(IItemCollection items) {\n+\t\tfinal HashMap<String, Long> eventCountByType = new HashMap<>();\n+\t\tfor (IItemIterable eventIterable : items) {\n+\t\t\tif (eventIterable.getItemCount() == 0) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tString typeName = eventIterable.getType().getName();\n+\t\t\tlong newValue = eventCountByType.getOrDefault(typeName, 0L) + eventIterable.getItemCount();\n+\t\t\teventCountByType.put(typeName, newValue);\n+\t\t}\n+\t\t\/\/ sort the map in ascending order of values\n+\t\treturn eventCountByType.entrySet().stream().sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))\n+\t\t\t\t.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (e1, e2) -> e1, LinkedHashMap::new));\n+\t}\n+\n+\tprivate static String createRootNodeJSON(IItemCollection events) {\n+\t\tMap<String, Long> eventCountsByType = countEventsByType(events);\n+\t\tString rootTitle = createRootNodeTitle(eventCountsByType);\n+\t\tString rootDescription = createRootNodeDescription(eventCountsByType);\n+\t\treturn JSONProps(rootTitle, rootDescription);\n+\t}\n+\n+\tprivate static String createRootNodeTitle(Map<String, Long> eventCountsByType) {\n+\t\tint eventsInTitle = Math.min(eventCountsByType.size(), MAX_TYPES_IN_ROOT_TITLE);\n+\t\tlong totalEvents = eventCountsByType.values().stream().mapToLong(Long::longValue).sum();\n+\t\tStringBuilder title = new StringBuilder(createRootNodeTitlePrefix(totalEvents, eventCountsByType.size()));\n+\t\tint i = 0;\n+\t\tfor (Map.Entry<String, Long> entry : eventCountsByType.entrySet()) {\n+\t\t\tString eventType = getFlameviewMessage(FLAMEVIEW_SELECT_TITLE_EVENT_PATTERN, entry.getKey(),\n+\t\t\t\t\tString.valueOf(entry.getValue()));\n+\t\t\ttitle.append(eventType);\n+\t\t\tif (i < eventsInTitle) {\n+\t\t\t\ttitle.append(getFlameviewMessage(FLAMEVIEW_SELECT_TITLE_EVENT_MORE_DELIMITER));\n+\t\t\t} else {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\ti++;\n+\t\t}\n+\t\tif (eventCountsByType.size() > MAX_TYPES_IN_ROOT_TITLE) {\n+\t\t\ttitle.append(getFlameviewMessage(FLAMEVIEW_SELECT_HTML_MORE)); \/\/ $NON-NLS-1$\n+\t\t}\n+\t\treturn title.toString();\n+\t}\n+\n+\tprivate static String createRootNodeTitlePrefix(long events, int types) {\n+\t\tString eventText = getFlameviewMessage(\n+\t\t\t\tevents > 1 ? FLAMEVIEW_SELECT_ROOT_NODE_EVENTS : FLAMEVIEW_SELECT_ROOT_NODE_EVENT);\n+\t\tString typeText = getFlameviewMessage(\n+\t\t\t\ttypes > 1 ? FLAMEVIEW_SELECT_ROOT_NODE_TYPES : FLAMEVIEW_SELECT_ROOT_NODE_TYPE);\n+\t\treturn getFlameviewMessage(FLAMEVIEW_SELECT_ROOT_NODE, String.valueOf(events), eventText, String.valueOf(types),\n+\t\t\t\ttypeText);\n+\t}\n+\n+\tprivate static String createRootNodeDescription(Map<String, Long> eventCountsByType) {\n+\t\tStringBuilder description = new StringBuilder();\n+\t\tint i = 0;\n+\t\tlong remainingEvents = 0;\n+\t\tfor (Map.Entry<String, Long> entry : eventCountsByType.entrySet()) {\n+\t\t\tif (i < MAX_TYPES_IN_ROOT_DESCRIPTION) {\n+\t\t\t\tdescription.append(getFlameviewMessage(FLAMEVIEW_SELECT_HTML_TABLE_EVENT_PATTERN,\n+\t\t\t\t\t\tString.valueOf(entry.getValue()), entry.getKey()));\n+\t\t\t} else {\n+\t\t\t\tremainingEvents = Long.sum(remainingEvents, entry.getValue());\n+\t\t\t}\n+\t\t\ti++;\n+\t\t}\n+\n+\t\tif (remainingEvents > 0) {\n+\t\t\tint remainingTypes = eventCountsByType.size() - MAX_TYPES_IN_ROOT_DESCRIPTION;\n+\t\t\tdescription.append(getFlameviewMessage(FLAMEVIEW_SELECT_HTML_TABLE_EVENT_REST_PATTERN,\n+\t\t\t\t\tString.valueOf(remainingEvents), String.valueOf(remainingTypes)));\n+\t\t}\n+\t\treturn description.toString();\n+\t}\n+}\n","filename":"application\/org.openjdk.jmc.flightrecorder.flameview\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/flameview\/FlameGraphJSONMarshaller.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n- *\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * The contents of this file are subject to the terms of either the Universal Permissive License\n- * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n- *\n- * or the following license:\n- *\n- * Redistribution and use in source and binary forms, with or without modification, are permitted\n- * provided that the following conditions are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n- * and the following disclaimer.\n- *\n- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n- * conditions and the following disclaimer in the documentation and\/or other materials provided with\n- * the distribution.\n- *\n- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n- * endorse or promote products derived from this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-package org.openjdk.jmc.flightrecorder.flameview.tree;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-public class TraceNode {\n-\tprivate final int value;\n-\tprivate final String name;\n-\tprivate final String packageName;\n-\tprivate final List<TraceNode> children = new ArrayList<>();\n-\n-\tpublic TraceNode(String name, int value, String packageName) {\n-\t\tthis.name = name;\n-\t\tthis.value = value;\n-\t\tthis.packageName = packageName;\n-\t}\n-\n-\tpublic int getValue() {\n-\t\treturn value;\n-\t}\n-\n-\tpublic String getName() {\n-\t\treturn name;\n-\t}\n-\n-\tpublic String getPackageName() {\n-\t\treturn packageName;\n-\t}\n-\n-\tpublic List<TraceNode> getChildren() {\n-\t\treturn children;\n-\t}\n-\n-\tpublic void addChild(TraceNode child) {\n-\t\tchildren.add(child);\n-\t}\n-\n-\t@Override\n-\tpublic int hashCode() {\n-\t\tfinal int prime = 31;\n-\t\tint result = 1;\n-\t\tresult = prime * result + ((children == null) ? 0 : children.hashCode());\n-\t\tresult = prime * result + ((name == null) ? 0 : name.hashCode());\n-\t\tresult = prime * result + ((packageName == null) ? 0 : packageName.hashCode());\n-\t\tresult = prime * result + value;\n-\t\treturn result;\n-\t}\n-\n-\t@Override\n-\tpublic boolean equals(Object obj) {\n-\t\tif (this == obj)\n-\t\t\treturn true;\n-\t\tif (obj == null)\n-\t\t\treturn false;\n-\t\tif (getClass() != obj.getClass())\n-\t\t\treturn false;\n-\t\tTraceNode other = (TraceNode) obj;\n-\t\tif (children == null) {\n-\t\t\tif (other.children != null)\n-\t\t\t\treturn false;\n-\t\t} else if (!children.equals(other.children))\n-\t\t\treturn false;\n-\t\tif (name == null) {\n-\t\t\tif (other.name != null)\n-\t\t\t\treturn false;\n-\t\t} else if (!name.equals(other.name))\n-\t\t\treturn false;\n-\t\tif (packageName == null) {\n-\t\t\tif (other.packageName != null) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t} else if (!packageName.equals(other.packageName))\n-\t\t\treturn false;\n-\t\tif (value != other.value)\n-\t\t\treturn false;\n-\t\treturn true;\n-\t}\n-\n-\tpublic String toString() {\n-\t\treturn \"TraceNode [name: \" + name + \", value: \" + value + \", packageName: \" + packageName + \", children: \"\n-\t\t\t\t+ children.size() + \"]\";\n-\t}\n-}\n","filename":"application\/org.openjdk.jmc.flightrecorder.flameview\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/flameview\/tree\/TraceNode.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -1,268 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n- *\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * The contents of this file are subject to the terms of either the Universal Permissive License\n- * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n- *\n- * or the following license:\n- *\n- * Redistribution and use in source and binary forms, with or without modification, are permitted\n- * provided that the following conditions are met:\n- *\n- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n- * and the following disclaimer.\n- *\n- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n- * conditions and the following disclaimer in the documentation and\/or other materials provided with\n- * the distribution.\n- *\n- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n- * endorse or promote products derived from this software without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n- * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n- * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n- * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n- * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n- *\/\n-package org.openjdk.jmc.flightrecorder.flameview.tree;\n-\n-import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_HTML_MORE;\n-import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_HTML_TABLE_EVENT_PATTERN;\n-import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_HTML_TABLE_EVENT_REST_PATTERN;\n-import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_ROOT_NODE;\n-import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_ROOT_NODE_EVENT;\n-import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_ROOT_NODE_EVENTS;\n-import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_ROOT_NODE_TYPE;\n-import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_ROOT_NODE_TYPES;\n-import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_STACKTRACE_NOT_AVAILABLE;\n-import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_TITLE_EVENT_MORE_DELIMITER;\n-import static org.openjdk.jmc.flightrecorder.flameview.Messages.FLAMEVIEW_SELECT_TITLE_EVENT_PATTERN;\n-import static org.openjdk.jmc.flightrecorder.flameview.MessagesUtils.getFlameviewMessage;\n-import static org.openjdk.jmc.flightrecorder.flameview.MessagesUtils.getStacktraceMessage;\n-import static org.openjdk.jmc.flightrecorder.stacktrace.Messages.STACKTRACE_UNCLASSIFIABLE_FRAME;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import org.openjdk.jmc.common.IMCFrame;\n-import org.openjdk.jmc.common.IMCMethod;\n-import org.openjdk.jmc.common.item.Aggregators;\n-import org.openjdk.jmc.common.item.Aggregators.CountConsumer;\n-import org.openjdk.jmc.common.item.GroupingAggregator;\n-import org.openjdk.jmc.common.item.GroupingAggregator.GroupEntry;\n-import org.openjdk.jmc.common.item.IAggregator;\n-import org.openjdk.jmc.common.item.IItemCollection;\n-import org.openjdk.jmc.common.item.IType;\n-import org.openjdk.jmc.common.unit.IQuantity;\n-import org.openjdk.jmc.common.unit.UnitLookup;\n-import org.openjdk.jmc.common.util.FormatToolkit;\n-import org.openjdk.jmc.flightrecorder.JfrAttributes;\n-import org.openjdk.jmc.flightrecorder.rules.util.RulesToolkit;\n-import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;\n-import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator.FrameCategorization;\n-import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceFrame;\n-import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel;\n-import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel.Branch;\n-import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel.Fork;\n-\n-public final class TraceTreeUtils {\n-\n-\tpublic final static String EMPTY_STRING = \"\"; \/\/$NON-NLS-1$\n-\tpublic final static int DEFAULT_ROOT_TITLE_MAX_EVENTS = 2;\n-\tpublic final static int DEFAULT_ROOT_EVENT_MAX = 10;\n-\tpublic final static String SELECT_EVENT_DELIMITER = getFlameviewMessage(\n-\t\t\tFLAMEVIEW_SELECT_TITLE_EVENT_MORE_DELIMITER);\n-\tpublic final static FrameSeparator DEFAULT_FRAME_SEPARATOR = new FrameSeparator(FrameCategorization.METHOD, false);\n-\n-\t\/**\n-\t * Traces a TraceTree from a {@link StacktraceModel}.\n-\t * \n-\t * @param root\n-\t *            the root with description\n-\t * @param model\n-\t *            the model to trace the tree from\n-\t * @return the root\n-\t *\/\n-\tpublic static TraceNode createTree(TraceNode root, StacktraceModel model) {\n-\t\tFork rootFork = model.getRootFork();\n-\t\tfor (Branch branch : rootFork.getBranches()) {\n-\t\t\taddBranch(root, branch);\n-\t\t}\n-\t\treturn root;\n-\t}\n-\n-\t\/**\n-\t * Root of Traces from the selection {@link IItemCollection}\n-\t * \n-\t * @param items\n-\t *            the items from the selection\n-\t * @param branchCount\n-\t *            branch count from {@link StacktraceModel} model\n-\t * @return root\n-\t *\/\n-\tpublic static TraceNode createRootWithDescription(IItemCollection items, int branchCount) {\n-\n-\t\tStringBuilder titleSb = new StringBuilder();\n-\t\tStringBuilder descSb = new StringBuilder();\n-\t\tAtomicInteger totalItemsSum = new AtomicInteger(0);\n-\n-\t\tif (branchCount == 0) {\n-\t\t\ttitleSb.append(getFlameviewMessage(FLAMEVIEW_SELECT_STACKTRACE_NOT_AVAILABLE));\n-\t\t} else {\n-\t\t\tMap<String, Integer> orderedEventTypeNameWithCount = eventTypeNameWithCountSorted(items, totalItemsSum);\n-\t\t\tString selectionText = createSelectionText(totalItemsSum.get(), orderedEventTypeNameWithCount.size());\n-\t\t\ttitleSb.append(selectionText);\n-\t\t\tcreateNodeTitleAndDescription(titleSb, descSb, orderedEventTypeNameWithCount);\n-\t\t}\n-\n-\t\treturn new TraceNode(titleSb.toString(), 0, descSb.toString());\n-\t}\n-\n-\t\/**\n-\t * Print the tree by the trace node\n-\t * \n-\t * @param node\n-\t *            trace node\n-\t * @return tree\n-\t *\/\n-\tpublic static String printTree(TraceNode node) {\n-\t\tStringBuilder builder = new StringBuilder();\n-\t\tbuilder.append(\"=== Tree Printout ===\");\n-\t\tbuilder.append(System.lineSeparator());\n-\t\tprintTree(builder, 0, node);\n-\t\treturn builder.toString();\n-\t}\n-\n-\tprivate static String createSelectionText(int events, int types) {\n-\t\tString eventText = events > 1 ? getFlameviewMessage(FLAMEVIEW_SELECT_ROOT_NODE_EVENTS)\n-\t\t\t\t: getFlameviewMessage(FLAMEVIEW_SELECT_ROOT_NODE_EVENT);\n-\t\tString typeText = types > 1 ? getFlameviewMessage(FLAMEVIEW_SELECT_ROOT_NODE_TYPES)\n-\t\t\t\t: getFlameviewMessage(FLAMEVIEW_SELECT_ROOT_NODE_TYPE);\n-\t\treturn getFlameviewMessage(FLAMEVIEW_SELECT_ROOT_NODE, String.valueOf(events), eventText, String.valueOf(types),\n-\t\t\t\ttypeText);\n-\t}\n-\n-\tprivate static void addBranch(TraceNode root, Branch branch) {\n-\t\tStacktraceFrame firstFrame = branch.getFirstFrame();\n-\t\tTraceNode currentNode = getTraceNodeByStacktraceFrame(firstFrame);\n-\t\troot.addChild(currentNode);\n-\t\tfor (StacktraceFrame frame : branch.getTailFrames()) {\n-\t\t\tTraceNode newNode = getTraceNodeByStacktraceFrame(frame);\n-\t\t\tcurrentNode.addChild(newNode);\n-\t\t\tcurrentNode = newNode;\n-\t\t}\n-\t\taddFork(currentNode, branch.getEndFork());\n-\t}\n-\n-\tprivate static void addFork(TraceNode node, Fork fork) {\n-\t\tfor (Branch branch : fork.getBranches()) {\n-\t\t\taddBranch(node, branch);\n-\t\t}\n-\t}\n-\n-\tprivate static void printTree(StringBuilder builder, int indentation, TraceNode node) {\n-\t\tbuilder.append(String.format(\"%s%s - %d%n\", indent(indentation), node.getName(), node.getValue()));\n-\t\tfor (TraceNode child : node.getChildren()) {\n-\t\t\tprintTree(builder, indentation + 1, child);\n-\t\t}\n-\t}\n-\n-\tprivate static String indent(int indentation) {\n-\t\tStringBuilder builder = new StringBuilder();\n-\t\tfor (int i = 0; i < indentation; i++) {\n-\t\t\tbuilder.append(\"   \");\n-\t\t}\n-\t\treturn builder.toString();\n-\t}\n-\n-\tprivate static Map<String, Integer> eventTypeNameWithCountSorted(\n-\t\tIItemCollection items, AtomicInteger totalEventTypeSum) {\n-\t\tfinal HashMap<String, Integer> map = new HashMap<>();\n-\t\tIAggregator<IQuantity, ?> build = GroupingAggregator.build(EMPTY_STRING, EMPTY_STRING, JfrAttributes.EVENT_TYPE,\n-\t\t\t\tAggregators.count(), new GroupingAggregator.IGroupsFinisher<IQuantity, IType<?>, CountConsumer>() {\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic IType<IQuantity> getValueType() {\n-\t\t\t\t\t\treturn UnitLookup.NUMBER;\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic IQuantity getValue(Iterable<? extends GroupEntry<IType<?>, CountConsumer>> groups) {\n-\t\t\t\t\t\tfor (GroupEntry<IType<?>, CountConsumer> groupEntry : groups) {\n-\t\t\t\t\t\t\tCountConsumer consumer = groupEntry.getConsumer();\n-\t\t\t\t\t\t\tIType<?> key = groupEntry.getKey();\n-\t\t\t\t\t\t\ttotalEventTypeSum.addAndGet(consumer.getCount());\n-\t\t\t\t\t\t\tmap.put(key.getName(), consumer.getCount());\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\treturn null;\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\titems.getAggregate(build);\n-\t\treturn RulesToolkit.sortMap(map, false);\n-\t}\n-\n-\tprivate static void createNodeTitleAndDescription(\n-\t\tStringBuilder titleSb, StringBuilder descSb, Map<String, Integer> orderedItemCountByType) {\n-\n-\t\tint i = 0;\n-\t\tlong restEventCount = 0;\n-\t\tboolean writeTitle = true;\n-\t\tint maxEventsInTile = orderedItemCountByType.size() > DEFAULT_ROOT_TITLE_MAX_EVENTS\n-\t\t\t\t? DEFAULT_ROOT_TITLE_MAX_EVENTS : orderedItemCountByType.size() - 1;\n-\n-\t\tfor (Map.Entry<String, Integer> e : orderedItemCountByType.entrySet()) {\n-\t\t\tif (writeTitle) {\n-\t\t\t\tString eventType = getFlameviewMessage(FLAMEVIEW_SELECT_TITLE_EVENT_PATTERN, e.getKey(),\n-\t\t\t\t\t\tString.valueOf(e.getValue()));\n-\t\t\t\ttitleSb.append(eventType);\n-\t\t\t\tif (i < maxEventsInTile) {\n-\t\t\t\t\ttitleSb.append(SELECT_EVENT_DELIMITER);\n-\t\t\t\t} else {\n-\t\t\t\t\twriteTitle = false;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif (i < DEFAULT_ROOT_EVENT_MAX) {\n-\t\t\t\tString tableEvent = getFlameviewMessage(FLAMEVIEW_SELECT_HTML_TABLE_EVENT_PATTERN,\n-\t\t\t\t\t\tString.valueOf(e.getValue()), e.getKey());\n-\t\t\t\tdescSb.append(tableEvent);\n-\t\t\t} else {\n-\t\t\t\trestEventCount = Long.sum(restEventCount, e.getValue());\n-\t\t\t}\n-\t\t\ti++;\n-\t\t}\n-\n-\t\tif (restEventCount > 0) {\n-\t\t\tString restEventCountText = String.valueOf(restEventCount);\n-\t\t\tString restItemCountText = String.valueOf(orderedItemCountByType.size() - DEFAULT_ROOT_EVENT_MAX);\n-\t\t\tString tableEventRest = getFlameviewMessage(FLAMEVIEW_SELECT_HTML_TABLE_EVENT_REST_PATTERN,\n-\t\t\t\t\trestEventCountText, restItemCountText);\n-\t\t\tdescSb.append(tableEventRest);\n-\t\t}\n-\n-\t\tif (maxEventsInTile < orderedItemCountByType.size() - 1) {\n-\t\t\ttitleSb.append(getFlameviewMessage(FLAMEVIEW_SELECT_HTML_MORE)); \/\/ $NON-NLS-1$\n-\t\t}\n-\t}\n-\n-\tprivate static TraceNode getTraceNodeByStacktraceFrame(StacktraceFrame sFrame) {\n-\t\tIMCFrame frame = sFrame.getFrame();\n-\t\tIMCMethod method = frame.getMethod();\n-\t\tString packageName = FormatToolkit.getPackage(method.getType().getPackage());\n-\t\tif (frame == StacktraceModel.UNKNOWN_FRAME) {\n-\t\t\treturn new TraceNode(getStacktraceMessage(STACKTRACE_UNCLASSIFIABLE_FRAME), sFrame.getItemCount(),\n-\t\t\t\t\tpackageName);\n-\t\t} else {\n-\t\t\tString name = FormatToolkit.getHumanReadable(method, false, false, true, false, true, false);\n-\t\t\treturn new TraceNode(name, sFrame.getItemCount(), packageName);\n-\t\t}\n-\t}\n-\n-}\n","filename":"application\/org.openjdk.jmc.flightrecorder.flameview\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/flameview\/tree\/TraceTreeUtils.java","additions":0,"deletions":268,"binary":false,"changes":268,"status":"deleted"},{"patch":"@@ -49,3 +49,0 @@\n-import static org.openjdk.jmc.flightrecorder.flameview.MessagesUtils.getStacktraceMessage;\n-import static org.openjdk.jmc.flightrecorder.stacktrace.Messages.STACKTRACE_UNCLASSIFIABLE_FRAME;\n-import static org.openjdk.jmc.flightrecorder.stacktrace.Messages.STACKTRACE_UNCLASSIFIABLE_FRAME_DESC;\n@@ -102,0 +99,1 @@\n+import org.openjdk.jmc.flightrecorder.flameview.FlameGraphJSONMarshaller;\n@@ -103,2 +101,0 @@\n-import org.openjdk.jmc.flightrecorder.flameview.tree.TraceNode;\n-import org.openjdk.jmc.flightrecorder.flameview.tree.TraceTreeUtils;\n@@ -107,1 +103,1 @@\n-import org.openjdk.jmc.flightrecorder.stacktrace.StacktraceModel;\n+import org.openjdk.jmc.flightrecorder.stacktrace.tree.StacktraceTreeModel;\n@@ -120,2 +116,0 @@\n-\tprivate static final String UNCLASSIFIABLE_FRAME = getStacktraceMessage(STACKTRACE_UNCLASSIFIABLE_FRAME);\n-\tprivate static final String UNCLASSIFIABLE_FRAME_DESC = getStacktraceMessage(STACKTRACE_UNCLASSIFIABLE_FRAME_DESC);\n@@ -310,2 +304,0 @@\n-\t\t\tStacktraceModel model = new StacktraceModel(view.threadRootAtTop, view.frameSeparator, items);\n-\t\t\tTraceNode root = TraceTreeUtils.createRootWithDescription(items, model.getRootFork().getBranchCount());\n@@ -315,1 +307,1 @@\n-\t\t\tTraceNode traceNode = TraceTreeUtils.createTree(root, model);\n+\t\t\tStacktraceTreeModel treeModel = new StacktraceTreeModel(items, view.frameSeparator, view.threadRootAtTop);\n@@ -319,1 +311,1 @@\n-\t\t\tString jsonModel = view.toJSonModel(traceNode, this).toString();\n+\t\t\tString flameGraphJSON = FlameGraphJSONMarshaller.toJSON(treeModel);\n@@ -324,1 +316,1 @@\n-\t\t\t\tDisplayToolkit.inDisplayThread().execute(() -> view.setModel(items, jsonModel));\n+\t\t\t\tDisplayToolkit.inDisplayThread().execute(() -> view.setModel(items, flameGraphJSON));\n@@ -507,48 +499,0 @@\n-\tprivate StringBuilder toJSonModel(TraceNode root, ModelRebuildRunnable rebuildCallable) {\n-\t\tStringBuilder builder = new StringBuilder();\n-\t\tString rootNodeStart = createJsonRootTraceNode(root);\n-\t\tbuilder.append(rootNodeStart);\n-\t\trenderChildren(builder, root, rebuildCallable);\n-\t\tbuilder.append(\"]}\");\n-\t\treturn builder;\n-\t}\n-\n-\tprivate static void render(StringBuilder builder, TraceNode node, ModelRebuildRunnable rebuildCallable) {\n-\t\tString start = UNCLASSIFIABLE_FRAME.equals(node.getName()) ? createJsonDescTraceNode(node)\n-\t\t\t\t: createJsonTraceNode(node);\n-\t\tbuilder.append(start);\n-\t\trenderChildren(builder, node, rebuildCallable);\n-\t\tbuilder.append(\"]}\");\n-\t}\n-\n-\tprivate static void renderChildren(StringBuilder builder, TraceNode node, ModelRebuildRunnable rebuildCallable) {\n-\t\tint i = 0;\n-\t\twhile (i < node.getChildren().size() && !rebuildCallable.isInvalid) {\n-\t\t\trender(builder, node.getChildren().get(i), rebuildCallable);\n-\t\t\tif (i < node.getChildren().size() - 1) {\n-\t\t\t\tbuilder.append(\",\");\n-\t\t\t}\n-\t\t\ti++;\n-\t\t}\n-\t}\n-\n-\tprivate static String createJsonRootTraceNode(TraceNode rootNode) {\n-\t\treturn String.format(\"{%s,%s,%s, \\\"c\\\": [ \", toJSonKeyValue(\"n\", rootNode.getName()), toJSonKeyValue(\"p\", \"\"),\n-\t\t\t\ttoJSonKeyValue(\"d\", rootNode.getPackageName()));\n-\t}\n-\n-\tprivate static String createJsonTraceNode(TraceNode node) {\n-\t\treturn String.format(\"{%s,%s,%s, \\\"c\\\": [ \", toJSonKeyValue(\"n\", node.getName()),\n-\t\t\t\ttoJSonKeyValue(\"p\", node.getPackageName()), toJSonKeyValue(\"v\", String.valueOf(node.getValue())));\n-\t}\n-\n-\tprivate static String createJsonDescTraceNode(TraceNode node) {\n-\t\treturn String.format(\"{%s,%s,%s,%s, \\\"c\\\": [ \", toJSonKeyValue(\"n\", node.getName()),\n-\t\t\t\ttoJSonKeyValue(\"p\", node.getPackageName()), toJSonKeyValue(\"d\", UNCLASSIFIABLE_FRAME_DESC),\n-\t\t\t\ttoJSonKeyValue(\"v\", String.valueOf(node.getValue())));\n-\t}\n-\n-\tprivate static String toJSonKeyValue(String key, String value) {\n-\t\treturn \"\\\"\" + key + \"\\\": \" + \"\\\"\" + value + \"\\\"\";\n-\t}\n-\n","filename":"application\/org.openjdk.jmc.flightrecorder.flameview\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/flameview\/views\/FlameGraphView.java","additions":5,"deletions":61,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -173,0 +173,5 @@\n+\t\t<dependency>\n+\t\t\t<groupId>org.openjdk.jmc<\/groupId>\n+\t\t\t<artifactId>flightrecorder.test<\/artifactId>\n+\t\t\t<version>8.0.0-SNAPSHOT<\/version>\n+\t\t<\/dependency>\n@@ -191,1 +196,1 @@\n-<\/project>\n\\ No newline at end of file\n+<\/project>\n","filename":"application\/pom.xml","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"","filename":"application\/tests\/org.openjdk.jmc.flightrecorder.flameview.test\/.classpath","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"application\/tests\/org.openjdk.jmc.flightrecorder.controlpanel.ui.test\/.classpath","status":"copied"},{"patch":"@@ -3,1 +3,1 @@\n-\t<name>org.openjdk.jmc.browser.attach.ja<\/name>\n+\t<name>org.openjdk.jmc.flightrecorder.flameview.test<\/name>\n","filename":"application\/tests\/org.openjdk.jmc.flightrecorder.flameview.test\/.project","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"application\/l10n\/org.openjdk.jmc.browser.attach.ja\/.project","status":"copied"},{"patch":"@@ -0,0 +1,23 @@\n+Manifest-Version: 1.0\n+Bundle-Version: 8.0.0.qualifier\n+Bundle-Name: Flameview Tests\n+Bundle-ManifestVersion: 2\n+Bundle-SymbolicName: org.openjdk.jmc.flightrecorder.flameview.test;singleton:=true\n+Bundle-Vendor: Oracle Corporation\n+Require-Bundle: org.junit,\n+ org.openjdk.jmc.flightrecorder,\n+ org.openjdk.jmc.flightrecorder.flameview,\n+ org.openjdk.jmc.common.test,\n+ org.openjdk.jmc.flightrecorder.test\n+Bundle-RequiredExecutionEnvironment: JavaSE-1.8\n+Bundle-ActivationPolicy: lazy\n+Automatic-Module-Name: org.openjdk.jmc.flightrecorder.flameview.test\n+Import-Package: org.openjdk.jmc.common,\n+ org.openjdk.jmc.common.item,\n+ org.openjdk.jmc.common.unit,\n+ org.openjdk.jmc.common.util,\n+ org.openjdk.jmc.flightrecorder,\n+ org.openjdk.jmc.flightrecorder.jdk,\n+ org.openjdk.jmc.flightrecorder.stacktrace,\n+ org.openjdk.jmc.flightrecorder.test.util\n+ \n","filename":"application\/tests\/org.openjdk.jmc.flightrecorder.flameview.test\/META-INF\/MANIFEST.MF","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-#  Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2020, Datadog, Inc. All rights reserved.\n","filename":"application\/tests\/org.openjdk.jmc.flightrecorder.flameview.test\/build.properties","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"application\/tests\/org.openjdk.jmc.flightrecorder.ext.jfx.test\/build.properties","status":"copied"},{"patch":"@@ -3,1 +3,1 @@\n-   Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+   Copyright (c) 2020 Datadog, Inc. All rights reserved.\n@@ -41,1 +41,1 @@\n-\t<artifactId>org.openjdk.jmc.ui.test<\/artifactId>\n+\t<artifactId>org.openjdk.jmc.flightrecorder.flameview.test<\/artifactId>\n","filename":"application\/tests\/org.openjdk.jmc.flightrecorder.flameview.test\/pom.xml","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"application\/tests\/org.openjdk.jmc.ui.test\/pom.xml","status":"copied"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.flameview.test;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.test.io.IOResourceSet;\n+import org.openjdk.jmc.common.util.StringToolkit;\n+import org.openjdk.jmc.flightrecorder.CouldNotLoadRecordingException;\n+import org.openjdk.jmc.flightrecorder.flameview.FlameGraphJSONMarshaller;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkAttributes;\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;\n+import org.openjdk.jmc.flightrecorder.stacktrace.tree.StacktraceTreeModel;\n+import org.openjdk.jmc.flightrecorder.test.util.RecordingToolkit;\n+import org.openjdk.jmc.flightrecorder.test.util.StacktraceTestToolkit;\n+\n+public class FlameGraphJSONMarshallerTest {\n+\n+\tprivate static IItemCollection testRecording;\n+\n+\t@BeforeClass\n+\tpublic static void beforeAll() throws IOException, CouldNotLoadRecordingException {\n+\t\tIOResourceSet[] testResources = StacktraceTestToolkit.getTestResources();\n+\t\tIOResourceSet resourceSet = testResources[0];\n+\t\ttestRecording = RecordingToolkit.getFlightRecording(resourceSet);\n+\t}\n+\n+\tprivate static final FrameSeparator separator = new FrameSeparator(FrameSeparator.FrameCategorization.METHOD,\n+\t\t\tfalse);\n+\n+\t@Test\n+\tpublic void testRenderedJSONWithAttribute() throws Exception {\n+\t\tStacktraceTreeModel model = new StacktraceTreeModel(testRecording, separator, true,\n+\t\t\t\tJdkAttributes.ALLOCATION_SIZE);\n+\t\tString flameGraphJSON = FlameGraphJSONMarshaller.toJSON(model);\n+\n+\t\tString expectedJSON = readResource(\"\/flamegraph-attribute.json\");\n+\t\tassertEquals(expectedJSON, flameGraphJSON);\n+\t}\n+\n+\t@Test\n+\tpublic void testRenderedJSONWithCounts() throws Exception {\n+\t\tStacktraceTreeModel model = new StacktraceTreeModel(testRecording, separator);\n+\t\tString flameGraphJSON = FlameGraphJSONMarshaller.toJSON(model);\n+\n+\t\tString expectedJSON = readResource(\"\/flamegraph-counts.json\");\n+\t\tassertEquals(expectedJSON, flameGraphJSON);\n+\t}\n+\n+\tprivate String readResource(String resourcePath) throws IOException {\n+\t\ttry (InputStream is = FlameGraphJSONMarshallerTest.class.getResourceAsStream(resourcePath)) {\n+\t\t\tif (is == null) {\n+\t\t\t\tthrow new IllegalArgumentException(resourcePath + \" not found\");\n+\t\t\t}\n+\t\t\treturn StringToolkit.readString(is);\n+\t\t}\n+\t}\n+\n+}\n","filename":"application\/tests\/org.openjdk.jmc.flightrecorder.flameview.test\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/flameview\/test\/FlameGraphJSONMarshallerTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+{\"n\": \"468 events of 21 types: Recording Setting[255], Java Monitor Wait[108], Thread Allocation Statistics[44]...\",\"p\": \"\",\"d\": \"255:Recording Setting|108:Java Monitor Wait|44:Thread Allocation Statistics|9:Socket Read|9:Class Loading Statistics|9:Exception Statistics|9:Java Thread Statistics|8:CPU Load|3:Allocation in new TLAB|2:Method Profiling Sample|12:Others... (11 types)|\", \"c\": [ {\"n\": \"JFRImpl.onNewChunk()\",\"p\": \"oracle.jrockit.jfr\",\"v\": \"24\", \"c\": [ {\"n\": \"MetaProducer.onNewChunk()\",\"p\": \"oracle.jrockit.jfr\",\"v\": \"24\", \"c\": [ {\"n\": \"JFRImpl.getRecordings()\",\"p\": \"oracle.jrockit.jfr\",\"v\": \"24\", \"c\": [ {\"n\": \"ArrayList.<init>(Collection)\",\"p\": \"java.util\",\"v\": \"24\", \"c\": [ {\"n\": \"AbstractCollection.toArray()\",\"p\": \"java.util\",\"v\": \"24\", \"c\": [ ]}]}]}]}]},{\"n\": \"Thread.run()\",\"p\": \"java.lang\",\"v\": \"104\", \"c\": [ {\"n\": \"ThreadPoolExecutor$Worker.run()\",\"p\": \"java.util.concurrent\",\"v\": \"104\", \"c\": [ {\"n\": \"ThreadPoolExecutor.runWorker(ThreadPoolExecutor$Worker)\",\"p\": \"java.util.concurrent\",\"v\": \"104\", \"c\": [ {\"n\": \"TCPTransport$ConnectionHandler.run()\",\"p\": \"sun.rmi.transport.tcp\",\"v\": \"104\", \"c\": [ {\"n\": \"TCPTransport$ConnectionHandler.run0()\",\"p\": \"sun.rmi.transport.tcp\",\"v\": \"104\", \"c\": [ {\"n\": \"TCPTransport.handleMessages(Connection, boolean)\",\"p\": \"sun.rmi.transport.tcp\",\"v\": \"104\", \"c\": [ {\"n\": \"Transport.serviceCall(RemoteCall)\",\"p\": \"sun.rmi.transport\",\"v\": \"104\", \"c\": [ {\"n\": \"AccessController.doPrivileged(PrivilegedExceptionAction, AccessControlContext)\",\"p\": \"java.security\",\"v\": \"104\", \"c\": [ {\"n\": \"Transport$1.run()\",\"p\": \"sun.rmi.transport\",\"v\": \"104\", \"c\": [ {\"n\": \"Transport$1.run()\",\"p\": \"sun.rmi.transport\",\"v\": \"104\", \"c\": [ {\"n\": \"UnicastServerRef.dispatch(Remote, RemoteCall)\",\"p\": \"sun.rmi.server\",\"v\": \"104\", \"c\": [ {\"n\": \"UnicastRef.unmarshalValue(Class, ObjectInput)\",\"p\": \"sun.rmi.server\",\"v\": \"104\", \"c\": [ {\"n\": \"ObjectInputStream.readObject()\",\"p\": \"java.io\",\"v\": \"104\", \"c\": [ {\"n\": \"ObjectInputStream.readObject0(boolean)\",\"p\": \"java.io\",\"v\": \"104\", \"c\": [ {\"n\": \"ObjectInputStream.readOrdinaryObject(boolean)\",\"p\": \"java.io\",\"v\": \"104\", \"c\": [ {\"n\": \"ObjectInputStream.readSerialData(Object, ObjectStreamClass)\",\"p\": \"java.io\",\"v\": \"104\", \"c\": [ {\"n\": \"ObjectStreamClass.invokeReadObject(Object, ObjectInputStream)\",\"p\": \"java.io\",\"v\": \"104\", \"c\": [ {\"n\": \"Method.invoke(Object, Object[])\",\"p\": \"java.lang.reflect\",\"v\": \"104\", \"c\": [ {\"n\": \"DelegatingMethodAccessorImpl.invoke(Object, Object[])\",\"p\": \"sun.reflect\",\"v\": \"104\", \"c\": [ {\"n\": \"GeneratedMethodAccessor3.invoke(Object, Object[])\",\"p\": \"sun.reflect\",\"v\": \"104\", \"c\": [ {\"n\": \"ObjectName.readObject(ObjectInputStream)\",\"p\": \"javax.management\",\"v\": \"104\", \"c\": [ {\"n\": \"ObjectInputStream.readObject()\",\"p\": \"java.io\",\"v\": \"104\", \"c\": [ {\"n\": \"ObjectInputStream.readObject0(boolean)\",\"p\": \"java.io\",\"v\": \"104\", \"c\": [ {\"n\": \"ObjectInputStream.readString(boolean)\",\"p\": \"java.io\",\"v\": \"104\", \"c\": [ {\"n\": \"ObjectInputStream$BlockDataInputStream.readUTF()\",\"p\": \"java.io\",\"v\": \"104\", \"c\": [ {\"n\": \"ObjectInputStream$BlockDataInputStream.readUTFBody(long)\",\"p\": \"java.io\",\"v\": \"104\", \"c\": [ {\"n\": \"StringBuilder.toString()\",\"p\": \"java.lang\",\"v\": \"104\", \"c\": [ {\"n\": \"String.<init>(char[], int, int)\",\"p\": \"java.lang\",\"v\": \"104\", \"c\": [ {\"n\": \"Arrays.copyOfRange(char[], int, int)\",\"p\": \"java.util\",\"v\": \"104\", \"c\": [ ]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]},{\"n\": \"TimerThread.run()\",\"p\": \"java.util\",\"v\": \"112\", \"c\": [ {\"n\": \"TimerThread.mainLoop()\",\"p\": \"java.util\",\"v\": \"112\", \"c\": [ ]}]}]}\n\\ No newline at end of file\n","filename":"application\/tests\/org.openjdk.jmc.flightrecorder.flameview.test\/src\/test\/resources\/flamegraph-attribute.json","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+{\"n\": \"468 events of 21 types: Recording Setting[255], Java Monitor Wait[108], Thread Allocation Statistics[44]...\",\"p\": \"\",\"d\": \"255:Recording Setting|108:Java Monitor Wait|44:Thread Allocation Statistics|9:Socket Read|9:Class Loading Statistics|9:Exception Statistics|9:Java Thread Statistics|8:CPU Load|3:Allocation in new TLAB|2:Method Profiling Sample|12:Others... (11 types)|\", \"c\": [ {\"n\": \"JFRImpl.onNewChunk()\",\"p\": \"oracle.jrockit.jfr\",\"v\": \"1\", \"c\": [ {\"n\": \"MetaProducer.onNewChunk()\",\"p\": \"oracle.jrockit.jfr\",\"v\": \"1\", \"c\": [ {\"n\": \"JFRImpl.getRecordings()\",\"p\": \"oracle.jrockit.jfr\",\"v\": \"1\", \"c\": [ {\"n\": \"ArrayList.<init>(Collection)\",\"p\": \"java.util\",\"v\": \"1\", \"c\": [ {\"n\": \"AbstractCollection.toArray()\",\"p\": \"java.util\",\"v\": \"1\", \"c\": [ ]}]}]}]}]},{\"n\": \"Thread.run()\",\"p\": \"java.lang\",\"v\": \"10\", \"c\": [ {\"n\": \"ThreadPoolExecutor$Worker.run()\",\"p\": \"java.util.concurrent\",\"v\": \"10\", \"c\": [ {\"n\": \"ThreadPoolExecutor.runWorker(ThreadPoolExecutor$Worker)\",\"p\": \"java.util.concurrent\",\"v\": \"10\", \"c\": [ {\"n\": \"TCPTransport$ConnectionHandler.run()\",\"p\": \"sun.rmi.transport.tcp\",\"v\": \"10\", \"c\": [ {\"n\": \"TCPTransport$ConnectionHandler.run0()\",\"p\": \"sun.rmi.transport.tcp\",\"v\": \"10\", \"c\": [ {\"n\": \"TCPTransport.handleMessages(Connection, boolean)\",\"p\": \"sun.rmi.transport.tcp\",\"v\": \"10\", \"c\": [ {\"n\": \"FilterInputStream.read()\",\"p\": \"java.io\",\"v\": \"9\", \"c\": [ {\"n\": \"BufferedInputStream.read()\",\"p\": \"java.io\",\"v\": \"9\", \"c\": [ {\"n\": \"BufferedInputStream.fill()\",\"p\": \"java.io\",\"v\": \"9\", \"c\": [ {\"n\": \"SocketInputStream.read(byte[], int, int)\",\"p\": \"java.net\",\"v\": \"9\", \"c\": [ {\"n\": \"SocketInputStream.read(byte[], int, int, int)\",\"p\": \"java.net\",\"v\": \"9\", \"c\": [ ]}]}]}]}]},{\"n\": \"Transport.serviceCall(RemoteCall)\",\"p\": \"sun.rmi.transport\",\"v\": \"1\", \"c\": [ {\"n\": \"AccessController.doPrivileged(PrivilegedExceptionAction, AccessControlContext)\",\"p\": \"java.security\",\"v\": \"1\", \"c\": [ {\"n\": \"Transport$1.run()\",\"p\": \"sun.rmi.transport\",\"v\": \"1\", \"c\": [ {\"n\": \"Transport$1.run()\",\"p\": \"sun.rmi.transport\",\"v\": \"1\", \"c\": [ {\"n\": \"UnicastServerRef.dispatch(Remote, RemoteCall)\",\"p\": \"sun.rmi.server\",\"v\": \"1\", \"c\": [ {\"n\": \"UnicastRef.unmarshalValue(Class, ObjectInput)\",\"p\": \"sun.rmi.server\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectInputStream.readObject()\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectInputStream.readObject0(boolean)\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectInputStream.readOrdinaryObject(boolean)\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectInputStream.readSerialData(Object, ObjectStreamClass)\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectStreamClass.invokeReadObject(Object, ObjectInputStream)\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ {\"n\": \"Method.invoke(Object, Object[])\",\"p\": \"java.lang.reflect\",\"v\": \"1\", \"c\": [ {\"n\": \"DelegatingMethodAccessorImpl.invoke(Object, Object[])\",\"p\": \"sun.reflect\",\"v\": \"1\", \"c\": [ {\"n\": \"GeneratedMethodAccessor3.invoke(Object, Object[])\",\"p\": \"sun.reflect\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectName.readObject(ObjectInputStream)\",\"p\": \"javax.management\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectInputStream.readObject()\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectInputStream.readObject0(boolean)\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectInputStream.readString(boolean)\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectInputStream$BlockDataInputStream.readUTF()\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectInputStream$BlockDataInputStream.readUTFBody(long)\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ {\"n\": \"StringBuilder.toString()\",\"p\": \"java.lang\",\"v\": \"1\", \"c\": [ {\"n\": \"String.<init>(char[], int, int)\",\"p\": \"java.lang\",\"v\": \"1\", \"c\": [ {\"n\": \"Arrays.copyOfRange(char[], int, int)\",\"p\": \"java.util\",\"v\": \"1\", \"c\": [ ]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]}]},{\"n\": \"InstantEvent.commit()\",\"p\": \"com.oracle.jrockit.jfr\",\"v\": \"1\", \"c\": [ {\"n\": \"InstantEvent.write()\",\"p\": \"com.oracle.jrockit.jfr\",\"v\": \"1\", \"c\": [ {\"n\": \"VMJFR.releaseThreadBuffer(ByteBuffer, boolean)\",\"p\": \"oracle.jrockit.jfr\",\"v\": \"1\", \"c\": [ {\"n\": \"VMJFR$ThreadBuffer.finish(ByteBuffer, boolean)\",\"p\": \"oracle.jrockit.jfr\",\"v\": \"1\", \"c\": [ {\"n\": \"VMJFR$ThreadBuffer.release()\",\"p\": \"oracle.jrockit.jfr\",\"v\": \"1\", \"c\": [ {\"n\": \"DirectByteBuffer.put(int, byte)\",\"p\": \"java.nio\",\"v\": \"1\", \"c\": [ {\"n\": \"Buffer.checkIndex(int)\",\"p\": \"java.nio\",\"v\": \"1\", \"c\": [ ]}]}]}]}]}]}]},{\"n\": \"ArrayList.writeObject(ObjectOutputStream)\",\"p\": \"java.util\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectOutputStream.writeObject(Object)\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectOutputStream.writeObject0(Object, boolean)\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectOutputStream.writeOrdinaryObject(Object, ObjectStreamClass, boolean)\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectOutputStream.writeClassDesc(ObjectStreamClass, boolean)\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectOutputStream.writeNonProxyDesc(ObjectStreamClass, boolean)\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectStreamClass.writeNonProxy(ObjectOutputStream)\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectOutputStream.writeUTF(String)\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ {\"n\": \"ObjectOutputStream$BlockDataOutputStream.writeUTF(String)\",\"p\": \"java.io\",\"v\": \"1\", \"c\": [ ]}]}]}]}]}]}]}]}]},{\"n\": \"TimerThread.run()\",\"p\": \"java.util\",\"v\": \"11\", \"c\": [ {\"n\": \"TimerThread.mainLoop()\",\"p\": \"java.util\",\"v\": \"11\", \"c\": [ {\"n\": \"Object.wait(long)\",\"p\": \"java.lang\",\"v\": \"10\", \"c\": [ ]}]}]},{\"n\": \"OGLRenderQueue$QueueFlusher.run()\",\"p\": \"sun.java2d.opengl\",\"v\": \"98\", \"c\": [ {\"n\": \"Object.wait(long)\",\"p\": \"java.lang\",\"v\": \"98\", \"c\": [ ]}]}]}\n\\ No newline at end of file\n","filename":"application\/tests\/org.openjdk.jmc.flightrecorder.flameview.test\/src\/test\/resources\/flamegraph-counts.json","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -48,0 +48,1 @@\n+\t\t<module>org.openjdk.jmc.flightrecorder.flameview.test<\/module>\n","filename":"application\/tests\/pom.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,2 +2,8 @@\n-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.7\n-org.eclipse.jdt.core.compiler.compliance=1.7\n+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled\n+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8\n+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve\n+org.eclipse.jdt.core.compiler.compliance=1.8\n+org.eclipse.jdt.core.compiler.debug.lineNumber=generate\n+org.eclipse.jdt.core.compiler.debug.localVariable=generate\n+org.eclipse.jdt.core.compiler.debug.sourceFile=generate\n+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error\n@@ -5,0 +11,1 @@\n+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error\n@@ -8,1 +15,1 @@\n-org.eclipse.jdt.core.compiler.source=1.7\n+org.eclipse.jdt.core.compiler.source=1.8\n","filename":"core\/org.openjdk.jmc.flightrecorder\/.settings\/org.eclipse.jdt.core.prefs","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -16,0 +16,1 @@\n+ org.openjdk.jmc.flightrecorder.stacktrace.tree,\n","filename":"core\/org.openjdk.jmc.flightrecorder\/META-INF\/MANIFEST.MF","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.stacktrace.tree;\n+\n+import org.openjdk.jmc.common.IMCFrame;\n+import org.openjdk.jmc.common.IMCMethod;\n+import org.openjdk.jmc.common.util.FormatToolkit;\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;\n+\n+\/**\n+ * Frame wrapper taking into account a frame separator for hash code and equals.\n+ *\/\n+public final class AggregatableFrame implements IMCFrame {\n+\tprivate final FrameSeparator separator;\n+\tprivate final IMCFrame frame;\n+\n+\t\/**\n+\t * Constructor.\n+\t * \n+\t * @param separator\n+\t *            can't be null.\n+\t * @param frame\n+\t *            can't be null.\n+\t *\/\n+\tpublic AggregatableFrame(FrameSeparator separator, IMCFrame frame) {\n+\t\tif (separator == null) {\n+\t\t\tthrow new NullPointerException(\"Separator must not be null\");\n+\t\t} else if (frame == null) {\n+\t\t\tthrow new NullPointerException(\"Frame must not be null\");\n+\t\t}\n+\t\tthis.separator = separator;\n+\t\tthis.frame = frame;\n+\t}\n+\n+\t@Override\n+\tpublic Integer getFrameLineNumber() {\n+\t\treturn frame.getFrameLineNumber();\n+\t}\n+\n+\t@Override\n+\tpublic Integer getBCI() {\n+\t\treturn frame.getBCI();\n+\t}\n+\n+\t@Override\n+\tpublic IMCMethod getMethod() {\n+\t\treturn frame.getMethod();\n+\t}\n+\n+\t@Override\n+\tpublic Type getType() {\n+\t\treturn frame.getType();\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tswitch (separator.getCategorization()) {\n+\t\tcase LINE:\n+\t\t\treturn frame.getMethod().hashCode() + 31 * frame.getFrameLineNumber();\n+\t\tcase METHOD:\n+\t\t\treturn frame.getMethod().hashCode();\n+\t\tcase CLASS:\n+\t\t\treturn frame.getMethod().getType().hashCode();\n+\t\tcase PACKAGE:\n+\t\t\treturn frame.getMethod().getType().getPackage().hashCode();\n+\t\tcase BCI:\n+\t\t}\n+\t\treturn frame.hashCode();\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tAggregatableFrame other = (AggregatableFrame) obj;\n+\t\treturn !separator.isSeparate(this.frame, other.frame);\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn FormatToolkit.getHumanReadable(getMethod()) + \":\" + separator.getCategorization();\n+\t}\n+\n+\tpublic String getHumanReadableSeparatorSensitiveString() {\n+\t\tswitch (separator.getCategorization()) {\n+\t\tcase LINE:\n+\t\t\treturn FormatToolkit.getHumanReadable(getMethod()) + \":\" + frame.getFrameLineNumber();\n+\t\tcase METHOD:\n+\t\t\treturn FormatToolkit.getHumanReadable(getMethod());\n+\t\tcase CLASS:\n+\t\t\treturn frame.getMethod().getType().getFullName();\n+\t\tcase PACKAGE:\n+\t\t\treturn frame.getMethod().getType().getPackage().getName();\n+\t\tdefault:\n+\t\t\treturn FormatToolkit.getHumanReadable(getMethod()) + \":\" + frame.getFrameLineNumber() + \"(\" + getBCI()\n+\t\t\t\t\t+ \")\";\n+\t\t}\n+\t}\n+\n+\tpublic String getHumanReadableShortString() {\n+\t\treturn FormatToolkit.getHumanReadable(getMethod(), false, false, true, false, true, false);\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/tree\/AggregatableFrame.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.stacktrace.tree;\n+\n+import java.util.Objects;\n+\n+\/**\n+ * A node in the graph of aggregated stack traces.\n+ *\/\n+public final class Node {\n+\t\/**\n+\t * Integer uniquely identifying this node within our data structure.\n+\t *\/\n+\tprivate final Integer nodeId;\n+\n+\t\/**\n+\t * The frame associated with this node.\n+\t *\/\n+\tprivate final AggregatableFrame frame;\n+\n+\t\/**\n+\t * The weight when being the top frame.\n+\t *\/\n+\tdouble weight;\n+\n+\t\/**\n+\t * The cumulative weight for all contributions.\n+\t *\/\n+\tdouble cumulativeWeight;\n+\n+\tpublic Node(Integer nodeId, AggregatableFrame frame) {\n+\t\tthis.nodeId = nodeId;\n+\t\tthis.frame = frame;\n+\t\tif (frame == null) {\n+\t\t\tthrow new NullPointerException(\"Frame cannot be null!\");\n+\t\t}\n+\t}\n+\n+\t\/**\n+\t * @return the unique identifier associated with this node.\n+\t *\/\n+\tpublic Integer getNodeId() {\n+\t\treturn nodeId;\n+\t}\n+\n+\t\/**\n+\t * @return the weight of this node.\n+\t *\/\n+\tpublic double getWeight() {\n+\t\treturn weight;\n+\t}\n+\n+\t\/**\n+\t * @return the cumulative weight of this node.\n+\t *\/\n+\tpublic double getCumulativeWeight() {\n+\t\treturn cumulativeWeight;\n+\t}\n+\n+\t\/**\n+\t * @return the frame corresponding to this node.\n+\t *\/\n+\tpublic AggregatableFrame getFrame() {\n+\t\treturn frame;\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\t\/\/ This will get a few extra collisions.\n+\t\treturn frame.getMethod().hashCode();\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tNode other = (Node) obj;\n+\n+\t\treturn Objects.equals(nodeId, other.nodeId) && Objects.equals(frame, other.frame) && weight == other.weight\n+\t\t\t\t&& cumulativeWeight == other.cumulativeWeight;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn String.format(\"%s %.2f (%.2f)\", frame.getHumanReadableShortString(), weight, cumulativeWeight);\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/tree\/Node.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,266 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.stacktrace.tree;\n+\n+import static org.openjdk.jmc.common.item.ItemToolkit.accessor;\n+import static org.openjdk.jmc.flightrecorder.JfrAttributes.EVENT_STACKTRACE;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import org.openjdk.jmc.common.IMCFrame;\n+import org.openjdk.jmc.common.IMCStackTrace;\n+import org.openjdk.jmc.common.item.IAttribute;\n+import org.openjdk.jmc.common.item.IItem;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.item.IItemIterable;\n+import org.openjdk.jmc.common.item.IMemberAccessor;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.util.MCFrame;\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator.FrameCategorization;\n+\n+public class StacktraceTreeModel {\n+\t@SuppressWarnings(\"deprecation\")\n+\tprivate static final IMemberAccessor<IMCStackTrace, IItem> ACCESSOR_STACKTRACE = accessor(EVENT_STACKTRACE);\n+\tprivate static final FrameSeparator DEFAULT_FRAME_SEPARATOR = new FrameSeparator(FrameCategorization.METHOD, false);\n+\n+\t\/**\n+\t * A special marker object that indicates a frame that cannot be determined.\n+\t * <p>\n+\t * A typical case is when a stacktrace is truncated due to to Flight Recorder settings. We know\n+\t * that there is a frame because of a truncation flag, but there is no information about it.\n+\t *\/\n+\tprivate static final IMCFrame UNKNOWN_FRAME = new MCFrame(null, null, null, IMCFrame.Type.UNKNOWN);\n+\n+\t\/**\n+\t * A special marker object that indicates a hand-crafted frame at the root of the tree.\n+\t * <p>\n+\t * We need to create this frame as a parent to all branches of the tree we want to represent.\n+\t *\/\n+\tprivate static final IMCFrame ROOT_FRAME = new MCFrame(null, null, null, IMCFrame.Type.UNKNOWN);\n+\n+\tprivate final Map<Integer, Node> nodes = new HashMap<>(1024);\n+\tprivate final Map<Integer, Set<Integer>> childrenLookup = new HashMap<>(1024);\n+\tprivate final Integer rootId;\n+\n+\tprivate final IItemCollection items;\n+\tprivate final FrameSeparator frameSeparator;\n+\tprivate final IAttribute<IQuantity> attribute;\n+\tprivate final boolean threadRootAtTop;\n+\n+\t\/**\n+\t * Builds a StacktraceTreeModel from a given collection of events with defaults: frame separator\n+\t * METHOD, the thread root at the top and no value attribute (uses counts).\n+\t *\n+\t * @param items\n+\t *            the data we want to represent.\n+\t *\/\n+\tpublic StacktraceTreeModel(IItemCollection items) {\n+\t\tthis(items, DEFAULT_FRAME_SEPARATOR, true, null);\n+\t}\n+\n+\t\/**\n+\t * Builds a StacktraceTreeModel from a given collection of events with defaults: the thread root\n+\t * at the top and no value attribute (uses counts).\n+\t *\n+\t * @param items\n+\t *            the data we want to represent.\n+\t * @param frameSeparator\n+\t *            defines what represents a node in the tree. Defaults to METHOD.\n+\t *\/\n+\tpublic StacktraceTreeModel(IItemCollection items, FrameSeparator frameSeparator) {\n+\t\tthis(items, frameSeparator, true, null);\n+\t}\n+\n+\t\/**\n+\t * Builds a StacktraceTreeModel from a given collection of events with no attribute specified\n+\t * (uses occurrences to determine node weight).\n+\t *\n+\t * @param items\n+\t *            the data we want to represent.\n+\t * @param frameSeparator\n+\t *            defines what represents a node in the tree. Defaults to METHOD.\n+\t * @param threadRootAtTop\n+\t *            defines how the stacks are aggregated. Defaults to true (i.e. bottom-up,\n+\t *            Thread.run() at the root of the tree).\n+\t *\/\n+\tpublic StacktraceTreeModel(IItemCollection items, FrameSeparator frameSeparator, boolean threadRootAtTop) {\n+\t\tthis(items, frameSeparator, threadRootAtTop, null);\n+\t}\n+\n+\t\/**\n+\t * Builds a StacktraceTreeModel from a given collection of events.\n+\t *\n+\t * @param items\n+\t *            the data we want to represent.\n+\t * @param frameSeparator\n+\t *            defines what represents a node in the tree. Defaults to METHOD.\n+\t * @param threadRootAtTop\n+\t *            defines how the stacks are aggregated. Defaults to true (i.e. bottom-up,\n+\t *            Thread.run() at the root of the tree).\n+\t * @param attribute\n+\t *            defines what we use as node weights. If null, the weight is the number of\n+\t *            occurrences for the frame.\n+\t *\/\n+\tpublic StacktraceTreeModel(IItemCollection items, FrameSeparator frameSeparator, boolean threadRootAtTop,\n+\t\t\tIAttribute<IQuantity> attribute) {\n+\t\tthis.items = items;\n+\t\tthis.frameSeparator = frameSeparator;\n+\t\tthis.attribute = attribute;\n+\t\tthis.threadRootAtTop = threadRootAtTop;\n+\n+\t\tAggregatableFrame rootFrame = new AggregatableFrame(frameSeparator, ROOT_FRAME);\n+\t\tthis.rootId = newNodeId(null, rootFrame);\n+\t\tnodes.put(rootId, new Node(rootId, rootFrame));\n+\t\tchildrenLookup.put(rootId, new TreeSet<>());\n+\n+\t\tfor (IItemIterable iterable : items) {\n+\t\t\tIMemberAccessor<IQuantity, IItem> accessor = getAccessor(iterable, attribute);\n+\t\t\titerable.forEach((item) -> addItem(item, accessor));\n+\t\t}\n+\t}\n+\n+\t\/**\n+\t * @return the root node of the tree.\n+\t *\/\n+\tpublic Node getRoot() {\n+\t\treturn nodes.get(rootId);\n+\t}\n+\n+\t\/**\n+\t * @return an unmodifiable view over the child lookup map.\n+\t *\/\n+\tpublic Map<Integer, Set<Integer>> getChildrenLookup() {\n+\t\treturn Collections.unmodifiableMap(childrenLookup);\n+\t}\n+\n+\t\/**\n+\t * @return an unmodifiable view over the node lookup map.\n+\t *\/\n+\tpublic Map<Integer, Node> getNodes() {\n+\t\treturn Collections.unmodifiableMap(nodes);\n+\t}\n+\n+\t\/**\n+\t * @return the source data set.\n+\t *\/\n+\tpublic IItemCollection getItems() {\n+\t\treturn items;\n+\t}\n+\n+\tprivate void addItem(IItem item, IMemberAccessor<IQuantity, IItem> accessor) {\n+\t\tIMCStackTrace stacktrace = getStackTrace(item);\n+\t\tif (stacktrace == null) {\n+\t\t\treturn;\n+\t\t}\n+\t\tList<? extends IMCFrame> frames = getStackTrace(item).getFrames();\n+\t\tif (frames == null || frames.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t\/\/ if we want a specific attribute but its accessor is not available we skip\n+\t\tif (attribute != null && accessor == null) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t\/\/ if we don't request a specific attribute, we simply count occurrences\n+\t\tdouble value = (accessor != null) ? accessor.getMember(item).doubleValue() : 1.0;\n+\n+\t\t\/\/ if the stack is zero valued for the requested attribute we prune it\n+\t\tif (attribute != null && value == 0.0) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tInteger parentId = rootId;\n+\t\tint processedFrames = 0;\n+\t\twhile (processedFrames < frames.size()) {\n+\t\t\tint idx = threadRootAtTop ? frames.size() - 1 - processedFrames : processedFrames;\n+\n+\t\t\tAggregatableFrame frame;\n+\t\t\tif (stacktrace.getTruncationState().isTruncated() && threadRootAtTop && processedFrames == 0) {\n+\t\t\t\t\/\/ we have a truncated stacktrace so we can't assume anything about the bottom frame\n+\t\t\t\tframe = new AggregatableFrame(frameSeparator, UNKNOWN_FRAME);\n+\t\t\t} else {\n+\t\t\t\tframe = new AggregatableFrame(frameSeparator, frames.get(idx));\n+\t\t\t}\n+\n+\t\t\tint nodeId = newNodeId(parentId, frame);\n+\t\t\tNode current = getOrCreateNode(nodeId, frame);\n+\t\t\tcurrent.cumulativeWeight += value;\n+\t\t\tif (processedFrames == frames.size() - 1) {\n+\t\t\t\tcurrent.weight += value;\n+\t\t\t}\n+\n+\t\t\tchildrenLookup.get(parentId).add(current.getNodeId());\n+\t\t\tif (childrenLookup.get(current.getNodeId()) == null) {\n+\t\t\t\tchildrenLookup.put(current.getNodeId(), new HashSet<>());\n+\t\t\t}\n+\t\t\tparentId = current.getNodeId();\n+\t\t\tprocessedFrames++;\n+\t\t}\n+\t}\n+\n+\tprivate Node getOrCreateNode(Integer nodeId, AggregatableFrame frame) {\n+\t\tNode n = nodes.get(nodeId);\n+\t\tif (n == null) {\n+\t\t\tn = new Node(nodeId, frame);\n+\t\t\tnodes.put(nodeId, n);\n+\t\t}\n+\t\treturn n;\n+\t}\n+\n+\tprivate Integer newNodeId(Integer parentId, AggregatableFrame aframe) {\n+\t\t\/\/ this is a naive implementation of content-addressable stacks\n+\t\t\/\/ given the same ancestors and the same frame, the node will have the same id\n+\t\tif (parentId == null) {\n+\t\t\treturn aframe.hashCode();\n+\t\t}\n+\t\treturn Objects.hash(parentId, aframe.hashCode());\n+\t}\n+\n+\tprivate IMCStackTrace getStackTrace(IItem item) {\n+\t\treturn ACCESSOR_STACKTRACE.getMember(item);\n+\t}\n+\n+\tprivate static IMemberAccessor<IQuantity, IItem> getAccessor(IItemIterable iterable, IAttribute<IQuantity> attr) {\n+\t\treturn (attr != null) ? iterable.getType().getAccessor(attr.getKey()) : null;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/stacktrace\/tree\/StacktraceTreeModel.java","additions":266,"deletions":0,"binary":false,"changes":266,"status":"added"},{"patch":"@@ -6,0 +6,1 @@\n+org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled\r\n@@ -7,0 +8,3 @@\n+org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning\r\n+org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=ignore\r\n+org.eclipse.jdt.core.compiler.release=disabled\r\n","filename":"core\/org.openjdk.jmc.jdp\/.settings\/org.eclipse.jdt.core.prefs","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -14,0 +14,1 @@\n+Export-Package: org.openjdk.jmc.flightrecorder.test.util\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/META-INF\/MANIFEST.MF","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.test;\n+\n+import static java.util.Arrays.asList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.test.io.IOResourceSet;\n+import org.openjdk.jmc.flightrecorder.CouldNotLoadRecordingException;\n+import org.openjdk.jmc.flightrecorder.jdk.JdkAttributes;\n+import org.openjdk.jmc.flightrecorder.stacktrace.FrameSeparator;\n+import org.openjdk.jmc.flightrecorder.stacktrace.tree.Node;\n+import org.openjdk.jmc.flightrecorder.stacktrace.tree.StacktraceTreeModel;\n+import org.openjdk.jmc.flightrecorder.test.util.RecordingToolkit;\n+import org.openjdk.jmc.flightrecorder.test.util.StacktraceTestToolkit;\n+\n+public class StacktraceTreeModelTest {\n+\n+\tprivate static IItemCollection testRecording;\n+\n+\t@BeforeClass\n+\tpublic static void beforeAll() throws IOException, CouldNotLoadRecordingException {\n+\t\tIOResourceSet[] testResources = StacktraceTestToolkit.getTestResources();\n+\t\tIOResourceSet resourceSet = testResources[0];\n+\t\ttestRecording = RecordingToolkit.getFlightRecording(resourceSet);\n+\t}\n+\n+\tprivate static final FrameSeparator separator = new FrameSeparator(FrameSeparator.FrameCategorization.METHOD,\n+\t\t\tfalse);\n+\n+\t@Test\n+\tpublic void testTreeModelWithAttributeThreadRootAtTop() {\n+\t\tStacktraceTreeModel treeModel = new StacktraceTreeModel(testRecording, separator, true,\n+\t\t\t\tJdkAttributes.ALLOCATION_SIZE);\n+\n+\t\t\/\/ check number of branches from root\n+\t\tInteger rootId = treeModel.getRoot().getNodeId();\n+\t\tSet<Integer> rootNodeChildIds = treeModel.getChildrenLookup().get(rootId);\n+\t\tassertNotNull(rootNodeChildIds);\n+\t\tassertEquals(3, rootNodeChildIds.size());\n+\n+\t\t\/\/ get leaf nodes\n+\t\tMap<String, List<Double>> leafValues = getLeafNodeValues(treeModel);\n+\n+\t\tassertEquals(leafValues.size(), 3);\n+\t\tMap<String, List<Double>> expected = new HashMap<>();\n+\t\texpected.put(\"Arrays.copyOfRange(char[], int, int)\", asList(104.00));\n+\t\texpected.put(\"TimerThread.mainLoop()\", asList(112.00));\n+\t\texpected.put(\"AbstractCollection.toArray()\", asList(24.00));\n+\t\tassertEquals(expected, leafValues);\n+\t}\n+\n+\t@Test\n+\tpublic void testTreeModelWithAttributeThreadRootAtBottom() {\n+\t\tStacktraceTreeModel treeModel = new StacktraceTreeModel(testRecording, separator, false,\n+\t\t\t\tJdkAttributes.ALLOCATION_SIZE);\n+\n+\t\t\/\/ check number of branches from root\n+\t\tInteger rootId = treeModel.getRoot().getNodeId();\n+\t\tSet<Integer> rootNodeChildIds = treeModel.getChildrenLookup().get(rootId);\n+\t\tassertNotNull(rootNodeChildIds);\n+\t\tassertEquals(3, rootNodeChildIds.size());\n+\n+\t\t\/\/ get leaf nodes\n+\t\tMap<String, List<Double>> leafValues = getLeafNodeValues(treeModel);\n+\n+\t\tassertEquals(leafValues.size(), 3);\n+\t\tMap<String, List<Double>> expected = new HashMap<>();\n+\t\texpected.put(\"JFRImpl.onNewChunk()\", asList(24.0));\n+\t\texpected.put(\"TimerThread.run()\", asList(112.00));\n+\t\texpected.put(\"Thread.run()\", asList(104.0));\n+\t\tassertEquals(expected, leafValues);\n+\t}\n+\n+\t@Test\n+\tpublic void testTreeModelWithoutAttributeThreadRootAtTop() {\n+\t\tStacktraceTreeModel treeModel = new StacktraceTreeModel(testRecording, separator);\n+\n+\t\t\/\/ check number of branches from root\n+\t\tInteger rootId = treeModel.getRoot().getNodeId();\n+\t\tSet<Integer> rootNodeChildIds = treeModel.getChildrenLookup().get(rootId);\n+\t\tassertNotNull(rootNodeChildIds);\n+\t\tassertEquals(6, rootNodeChildIds.size());\n+\n+\t\t\/\/ get leaf nodes\n+\t\tMap<String, List<Double>> leafValues = getLeafNodeValues(treeModel);\n+\n+\t\tMap<String, List<Double>> expected = new HashMap<>();\n+\t\texpected.put(\"AbstractCollection.toArray()\", asList(1.0));\n+\t\texpected.put(\"Buffer.checkIndex(int)\", asList(1.0));\n+\t\texpected.put(\"Object.wait(long)\", asList(10.0, 98.0));\n+\t\texpected.put(\"ObjectOutputStream$BlockDataOutputStream.writeUTF(String)\", asList(1.0));\n+\t\texpected.put(\"SocketInputStream.read(byte[], int, int, int)\", asList(9.0));\n+\t\texpected.put(\"Arrays.copyOfRange(char[], int, int)\", asList(1.0));\n+\t\tassertEquals(expected, leafValues);\n+\t}\n+\n+\t@Test\n+\tpublic void testTreeModelWithoutAttributeThreadRootAtBottom() {\n+\t\tStacktraceTreeModel treeModel = new StacktraceTreeModel(testRecording, separator, false);\n+\n+\t\t\/\/ check number of branches from root\n+\t\tInteger rootId = treeModel.getRoot().getNodeId();\n+\t\tSet<Integer> rootNodeChildIds = treeModel.getChildrenLookup().get(rootId);\n+\t\tassertNotNull(rootNodeChildIds);\n+\t\tassertEquals(7, rootNodeChildIds.size());\n+\n+\t\t\/\/ get leaf nodes\n+\t\tMap<String, List<Double>> leafValues = getLeafNodeValues(treeModel);\n+\n+\t\tMap<String, List<Double>> expected = new HashMap<>();\n+\t\texpected.put(\"TimerThread.run()\", asList(1.0, 10.0));\n+\t\texpected.put(\"JFRImpl.onNewChunk()\", asList(1.0));\n+\t\texpected.put(\"OGLRenderQueue$QueueFlusher.run()\", asList(98.0));\n+\t\texpected.put(\"InstantEvent.commit()\", asList(1.0));\n+\t\texpected.put(\"Thread.run()\", asList(1.0, 9.0));\n+\t\texpected.put(\"ArrayList.writeObject(ObjectOutputStream)\", asList(1.0));\n+\t\tassertEquals(expected, leafValues);\n+\t}\n+\n+\tpublic Map<String, List<Double>> getLeafNodeValues(StacktraceTreeModel treeModel) {\n+\t\tMap<Integer, Node> nodesById = treeModel.getNodes();\n+\t\tMap<Integer, Set<Integer>> childrenLookup = treeModel.getChildrenLookup();\n+\t\tMap<String, List<Double>> leafValues = new HashMap<>();\n+\t\t\/\/ we get the leaves by checking the lookup and selecting nodes with no children\n+\t\tfor (Integer nodeId : childrenLookup.keySet()) {\n+\t\t\tif (childrenLookup.get(nodeId).isEmpty()) {\n+\t\t\t\tNode node = nodesById.get(nodeId);\n+\t\t\t\tString key = node.getFrame().getHumanReadableShortString();\n+\t\t\t\tleafValues.computeIfAbsent(key, k -> new ArrayList<>());\n+\t\t\t\tleafValues.get(key).add(node.getWeight());\n+\t\t\t\tleafValues.get(key).sort(Comparator.naturalOrder());\n+\t\t\t}\n+\t\t}\n+\t\treturn leafValues;\n+\t}\n+}\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.test\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/test\/StacktraceTreeModelTest.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"}]}