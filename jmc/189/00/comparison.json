{"files":[{"patch":"@@ -95,20 +95,24 @@\n-\n-\t\tdouble balance = RulesToolkit.calculateBalanceScore(entries);\n-\t\tIntEntry<IMCType> mostSignificant = entries.get(entries.size() - 1);\n-\t\t\/\/ FIXME: Configuration attribute instead of hard coded 1000 tlabs => relevance 50\n-\t\tdouble relevance = RulesToolkit.mapExp100Y(mostSignificant.getValue(), 1000, 50);\n-\t\tdouble score = balance * relevance * 0.74; \/\/ ceiling at 74;\n-\n-\t\tIItemFilter significantFilter = ItemFilters.and(JdkFilters.ALLOC_ALL,\n-\t\t\t\tItemFilters.equals(JdkAttributes.ALLOCATION_CLASS, mostSignificant.getKey()));\n-\t\tStacktraceModel stacktraceModel = new StacktraceModel(false,\n-\t\t\t\tnew FrameSeparator(FrameCategorization.METHOD, false), items.apply(significantFilter));\n-\t\tFork rootFork = stacktraceModel.getRootFork();\n-\t\tList<IMCMethod> relevantFramesList = StacktraceDataProvider.getRelevantTraceList(rootFork.getBranch(0),\n-\t\t\t\trootFork.getItemsInFork());\n-\t\treturn ResultBuilder.createFor(this, valueProvider).setSeverity(Severity.get(score))\n-\t\t\t\t.setSummary(Messages.getString(Messages.AllocationByClassRule_TEXT_MESSAGE))\n-\t\t\t\t.setExplanation(Messages.getString(Messages.AllocationRuleFactory_TEXT_CLASS_INFO_LONG))\n-\t\t\t\t.addResult(TypedResult.SCORE, UnitLookup.NUMBER_UNITY.quantity(score))\n-\t\t\t\t.addResult(ALLOCATION_FRAMES, relevantFramesList)\n-\t\t\t\t.addResult(MOST_ALLOCATED_TYPE, mostSignificant.getKey()).build();\n+\t\tif (entries.size() > 1) {\n+\t\t\tdouble balance = RulesToolkit.calculateBalanceScore(entries);\n+\t\t\tIntEntry<IMCType> mostSignificant = entries.get(entries.size() - 1);\n+\t\t\t\/\/ FIXME: Configuration attribute instead of hard coded 1000 tlabs => relevance 50\n+\t\t\tdouble relevance = RulesToolkit.mapExp100Y(mostSignificant.getValue(), 1000, 50);\n+\t\t\tdouble score = balance * relevance * 0.74; \/\/ ceiling at 74;\n+\t\n+\t\t\tIItemFilter significantFilter = ItemFilters.and(JdkFilters.ALLOC_ALL,\n+\t\t\t\t\tItemFilters.equals(JdkAttributes.ALLOCATION_CLASS, mostSignificant.getKey()));\n+\t\t\tStacktraceModel stacktraceModel = new StacktraceModel(false,\n+\t\t\t\t\tnew FrameSeparator(FrameCategorization.METHOD, false), items.apply(significantFilter));\n+\t\t\tFork rootFork = stacktraceModel.getRootFork();\n+\t\t\tif (rootFork.getBranchCount() > 0) {\n+\t\t\t\tList<IMCMethod> relevantFramesList = StacktraceDataProvider.getRelevantTraceList(rootFork.getBranch(0),\n+\t\t\t\t\t\trootFork.getItemsInFork());\n+\t\t\t\treturn ResultBuilder.createFor(this, valueProvider).setSeverity(Severity.get(score))\n+\t\t\t\t\t\t.setSummary(Messages.getString(Messages.AllocationByClassRule_TEXT_MESSAGE))\n+\t\t\t\t\t\t.setExplanation(Messages.getString(Messages.AllocationRuleFactory_TEXT_CLASS_INFO_LONG))\n+\t\t\t\t\t\t.addResult(TypedResult.SCORE, UnitLookup.NUMBER_UNITY.quantity(score))\n+\t\t\t\t\t\t.addResult(ALLOCATION_FRAMES, relevantFramesList)\n+\t\t\t\t\t\t.addResult(MOST_ALLOCATED_TYPE, mostSignificant.getKey()).build();\n+\t\t\t}\n+\t\t}\n+\t\treturn ResultBuilder.createFor(this, valueProvider).setSeverity(Severity.NA).build();\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/memory\/AllocationByClassRule.java","additions":24,"deletions":20,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -107,8 +107,10 @@\n-\t\t\tList<IMCMethod> mostRelevantFrames = StacktraceDataProvider.getRelevantTraceList(rootFork.getBranch(0),\n-\t\t\t\t\trootFork.getItemsInFork());\n-\t\t\treturn ResultBuilder.createFor(this, valueProvider).setSeverity(Severity.get(score))\n-\t\t\t\t\t.setSummary(Messages.getString(Messages.AllocationByThreadRule_TEXT_MESSAGE))\n-\t\t\t\t\t.setExplanation(Messages.getString(Messages.AllocationRuleFactory_TEXT_THREAD_INFO_LONG))\n-\t\t\t\t\t.addResult(TypedResult.SCORE, UnitLookup.NUMBER_UNITY.quantity(score))\n-\t\t\t\t\t.addResult(MOST_ALLOCATING_THREAD, mostSignificant.getKey())\n-\t\t\t\t\t.addResult(ALLOCATION_FRAMES, mostRelevantFrames).build();\n+\t\t\tif (rootFork.getBranchCount() > 0) {\n+\t\t\t\tList<IMCMethod> mostRelevantFrames = StacktraceDataProvider.getRelevantTraceList(rootFork.getBranch(0),\n+\t\t\t\t\t\trootFork.getItemsInFork());\n+\t\t\t\treturn ResultBuilder.createFor(this, valueProvider).setSeverity(Severity.get(score))\n+\t\t\t\t\t\t.setSummary(Messages.getString(Messages.AllocationByThreadRule_TEXT_MESSAGE))\n+\t\t\t\t\t\t.setExplanation(Messages.getString(Messages.AllocationRuleFactory_TEXT_THREAD_INFO_LONG))\n+\t\t\t\t\t\t.addResult(TypedResult.SCORE, UnitLookup.NUMBER_UNITY.quantity(score))\n+\t\t\t\t\t\t.addResult(MOST_ALLOCATING_THREAD, mostSignificant.getKey())\n+\t\t\t\t\t\t.addResult(ALLOCATION_FRAMES, mostRelevantFrames).build();\n+\t\t\t}\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/memory\/AllocationByThreadRule.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"}]}