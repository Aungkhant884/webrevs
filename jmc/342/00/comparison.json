{"files":[{"patch":"@@ -0,0 +1,285 @@\n+@file:DependsOn(\"org.junit.jupiter:junit-jupiter:5.7.0\")\n+@file:DependsOn(\"org.eclipse.jgit:org.eclipse.jgit:6.0.0.202111291000-r\")\n+\n+import org.eclipse.jgit.api.Git\n+import org.eclipse.jgit.diff.DiffEntry.ChangeType.*\n+import org.eclipse.jgit.lib.AbbreviatedObjectId\n+import org.eclipse.jgit.lib.Constants\n+import org.eclipse.jgit.lib.ObjectReader\n+import org.eclipse.jgit.lib.Repository\n+import org.eclipse.jgit.revwalk.RevCommit\n+import org.eclipse.jgit.revwalk.RevWalk\n+import org.eclipse.jgit.revwalk.filter.RevFilter\n+import org.eclipse.jgit.treewalk.CanonicalTreeParser\n+import java.io.File\n+import java.time.Instant\n+import java.time.ZoneId\n+import kotlin.system.exitProcess\n+\n+fun run() {\n+    \/\/ the script needs to run in the directory where jmc is checked out:\n+    \/\/ kotlinc -script scripts\/copyrightchecker.main.kts\n+    val git = GitClient(\".\")\n+    CopyrightChecker.validateChanges(git.getCommitYear(), git.getChanges())\n+}\n+\n+run()\n+\n+class GitClient(jmcRepoPath: String) {\n+    private val git: Git\n+    private val repo: Repository\n+    private val head: RevCommit\n+    private val base: RevCommit\n+    init {\n+        val gitDir = File(jmcRepoPath)\n+        git = Git.open(gitDir)\n+        \/\/ TODO: fail if not in JMC repo\n+        repo = git.repository!!\n+        head = getHeadCommit()\n+        base = getBaseCommit()\n+        println(\"Checked out at: ${head.name} (base: ${base.name})\")\n+        \/\/ TODO: maybe fail if there are unstashed changes?\n+        \/\/ TODO: exit with success if head commit is on master\n+    }\n+\n+    private fun getHeadCommit(): RevCommit =\n+        RevWalk(repo).parseCommit(repo.resolve(Constants.HEAD))\n+\n+    private fun getBaseCommit(): RevCommit {\n+        val walk = RevWalk(repo)\n+        val master = walk.parseCommit(repo.resolve(\"master\"))\n+        walk.apply {\n+            revFilter = RevFilter.MERGE_BASE\n+            markStart(head)\n+            markStart(master)\n+        }\n+        return walk.next()\n+    }\n+\n+    private fun getBytes(reader: ObjectReader, shortId: AbbreviatedObjectId): ByteArray {\n+        val objId = reader.resolve(shortId).single()\n+        return reader.open(objId).bytes\n+    }\n+\n+    fun getChanges(): List<Change> {\n+        val headTree = repo.resolve(\"HEAD^{tree}\")\n+        val baseTree = repo.resolve(\"${base.name}^{tree}\")\n+        val reader: ObjectReader = repo.newObjectReader()\n+        val baseIter = CanonicalTreeParser().apply { reset(reader, baseTree) }\n+        val headIter = CanonicalTreeParser().apply { reset(reader, headTree) }\n+        return git.diff()\n+            .setNewTree(headIter)\n+            .setOldTree(baseIter)\n+            .call()\n+            .filterNot { it.changeType == DELETE }\n+            .map { diff ->\n+                when (diff.changeType) {\n+                    MODIFY, RENAME, COPY -> {\n+                        Change(\n+                            newPath = diff.newPath,\n+                            headBytes = getBytes(reader, diff.newId),\n+                            baseBytes = getBytes(reader, diff.oldId)\n+                        )\n+                    }\n+                    ADD -> Change(newPath = diff.newPath, headBytes = getBytes(reader, diff.newId))\n+                    else -> throw IllegalArgumentException(\"Unsupported: ${diff.changeType}\")\n+                }\n+            }\n+    }\n+\n+    fun getCommitYear(): Int =\n+        Instant.ofEpochSecond(head.commitTime.toLong()).atZone(ZoneId.of(\"Etc\/UTC\")).year\n+}\n+\n+class Change(val newPath: String, val headBytes: ByteArray, val baseBytes: ByteArray? = null)\n+\n+data class Range(val start: Int, val end: Int? = null) {\n+    companion object {\n+        fun update(range: Range, year: Int): Range =\n+            if (range.start >= year) {\n+                range\n+            } else {\n+                Range(range.start, year)\n+            }\n+    }\n+    override fun toString(): String =\n+        if (end != null) {\n+            \"$start, $end\"\n+        } else {\n+            \"$start\"\n+        }\n+}\n+\n+data class CopyrightString(private val range: Range, private val holder: CopyrightHolders) {\n+    companion object {\n+        fun parse(line: String): CopyrightString? {\n+            if (!line.contains(\"Copyright\")) return null\n+            return try {\n+                val parts: List<String> = line\n+                    .split(\".\").first()\n+                    .split(\"(c)\")[1]\n+                    .split(\",\")\n+                    .map { part -> part.trim() }\n+                when (parts.size) {\n+                    2 -> CopyrightString(Range(parts[0].toInt()), CopyrightHolders.fromString(parts[1]))\n+                    3 -> CopyrightString(Range(parts[0].toInt(), parts[1].toInt()), CopyrightHolders.fromString(parts[2]))\n+                    else -> throw IllegalArgumentException()\n+                }\n+            } catch (e: Exception) {\n+                throw IllegalArgumentException(\"üü° Failed to parse: $line\", e)\n+            }\n+        }\n+\n+        fun update(original: CopyrightString, endYear: Int): CopyrightString {\n+            return original.copy(range = Range.update(original.range, endYear))\n+        }\n+    }\n+    override fun toString() = \"Copyright (c) $range, ${holder.displayName}. All rights reserved.\"\n+}\n+\n+class CopyrightHeader(val holders: List<CopyrightString>) {\n+    companion object {\n+        fun parse(file: String): CopyrightHeader {\n+            val holders = file.split(\"\\n\").mapNotNull { CopyrightString.parse(it) }\n+            return CopyrightHeader(holders)\n+        }\n+\n+        fun update(original: CopyrightHeader, endYear: Int): CopyrightHeader =\n+            CopyrightHeader(original.holders.map { CopyrightString.update(it, endYear) })\n+    }\n+    fun format(fileType: FileTypes): String {\n+        val prefix: String\n+        val before: List<String>\n+        val after: List<String>\n+        when (fileType) {\n+            FileTypes.JAVA -> {\n+                prefix = \" * \"\n+                before = listOf(\"\/*\")\n+                after = listOf(\" *\", \" * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\")\n+            }\n+            FileTypes.JAVASCRIPT -> {\n+                prefix = \" \"\n+                before = listOf(\"\/*\")\n+                after = listOf(\"\", \" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\")\n+            }\n+            FileTypes.XML -> {\n+                prefix = \"\\t\"\n+                before = listOf(\"\"\"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\"\"\", \"<!--\")\n+                after = listOf(\"\", \"\\tDO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\")\n+            }\n+            FileTypes.UNSUPPORTED -> throw IllegalArgumentException(fileType.toString())\n+        }\n+        val headerLines = before + holders.map { \"$prefix$it\" } + after\n+        return headerLines.joinToString(\"\\n\")\n+    }\n+}\n+\n+class CopyrightChecker {\n+    companion object {\n+        fun validateChanges(commitYear: Int, changes: List<Change>) {\n+            if (changes.map { validateChange(it, commitYear) }.filterNot { it }.isNotEmpty()) {\n+                println()\n+                println(\"‚ùå Validation failed\")\n+                exitProcess(1)\n+            } else {\n+                println(\"‚úÖ Validation succeeded\")\n+                exitProcess(0)\n+            }\n+        }\n+\n+        private fun validateChange(change: Change, year: Int): Boolean {\n+            val fileType = FileTypes.fromPath(change.newPath)\n+            if (fileType == FileTypes.UNSUPPORTED) {\n+                println(\"‚ö™Ô∏è ${change.newPath}\")\n+                return true\n+            }\n+            val header = if (change.baseBytes != null) {\n+                val baseContent = String(change.baseBytes, Charsets.UTF_8)\n+                try {\n+                    CopyrightHeader.update(CopyrightHeader.parse(baseContent), year)\n+                } catch (e: Exception) {\n+                    println(\"üî¥ ${change.newPath}\")\n+                    println(e.message)\n+                    return false\n+                }\n+            } else {\n+                CopyrightHeader(\n+                    listOf(\n+                        CopyrightString(Range(year), CopyrightHolders.ORACLE),\n+                        CopyrightString(Range(year), CopyrightHolders.DATADOG)\n+                    )\n+                )\n+            }\n+            val headContent = String(change.headBytes, Charsets.UTF_8)\n+            val expected = header.format(fileType)\n+            return if (headContent.startsWith(expected)) {\n+                println(\"üü¢ ${change.newPath}\")\n+                true\n+            } else {\n+                println(\"üî¥ ${change.newPath}\")\n+                println(\"Expected:\")\n+                println(expected)\n+                println(\"Actual:\")\n+                println(headContent.substring(0, expected.length + 1))\n+                println(\"(check whitespace if strings seem to match)\")\n+                false\n+            }\n+        }\n+    }\n+}\n+\n+enum class FileTypes {\n+    JAVA, JAVASCRIPT, XML, UNSUPPORTED;\n+    companion object {\n+        fun fromPath(path: String): FileTypes =\n+            if (isExcluded(path)) {\n+                UNSUPPORTED\n+            } else if (path.endsWith(\".java\")) {\n+                JAVA\n+            } else if (path.endsWith(\".js\")) {\n+                JAVASCRIPT\n+            } else if (path.endsWith(\".xml\")) {\n+                XML\n+            } else {\n+                UNSUPPORTED\n+            }\n+\n+        private fun isExcluded(path: String): Boolean =\n+            path.endsWith(\"plugin.xml\")\n+    }\n+}\n+\n+enum class CopyrightHolders(val displayName: String) {\n+    ORACLE(\"Oracle and\/or its affiliates\"), DATADOG(\"Datadog, Inc\");\n+    companion object {\n+        fun fromString(str: String) =\n+            values().find { it.displayName == str } ?: throw IllegalArgumentException(str)\n+    }\n+}\n+\n+\/\/ We could use something similar to validate all copyright notices in the repo:\n+\/\/\n+\/\/ fun treeWalk() {\n+\/\/    val revWalk = RevWalk(repo)\n+\/\/    val lastCommitId = repo.resolve(Constants.HEAD)!!\n+\/\/    val commit: RevCommit = revWalk.parseCommit(lastCommitId)\n+\/\/\n+\/\/    val tree: RevTree = commit.tree\n+\/\/    val treeWalk = TreeWalk(repo)\n+\/\/    treeWalk.addTree(tree)\n+\/\/    treeWalk.isRecursive = true\n+\/\/\n+\/\/    println(\"starting tree walk\")\n+\/\/    treeWalk.filter = PathSuffixFilter.create(\".java\")\n+\/\/    val javaFiles = mutableListOf<Pair<String, Instant>>()\n+\/\/    while (treeWalk.next()) {\n+\/\/        git.log().addPath(treeWalk.pathString).setMaxCount(1).call().forEach {\n+\/\/            javaFiles.add(Pair(treeWalk.pathString, Instant.ofEpochSecond(it.commitTime.toLong())))\n+\/\/        }\n+\/\/        if (javaFiles.size % 10 == 0) {\n+\/\/            println(javaFiles.size)\n+\/\/            break\n+\/\/        }\n+\/\/    }\n+\/\/    println(javaFiles)\n+\/\/ }\n","filename":"scripts\/copyrightchecker.main.kts","additions":285,"deletions":0,"binary":false,"changes":285,"status":"added"}]}