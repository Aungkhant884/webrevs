{"files":[{"patch":"@@ -47,0 +47,3 @@\n+# Ignore IntelliJ\n+*.iml\n+*.idea\n","filename":".gitignore","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,10 @@\n+Manifest-Version: 1.0\n+Bundle-ManifestVersion: 2\n+Bundle-Name: Mission Control Flight Recorder Writer\n+Bundle-SymbolicName: org.openjdk.jmc.flightrecorder.writer;singleton:=true\n+Bundle-Version: 8.0.0.qualifier\n+Bundle-Vendor: Oracle Corporation\n+Bundle-RequiredExecutionEnvironment: JavaSE-1.8\n+Export-Package: org.openjdk.jmc.flightrecorder.writer.api\n+Require-Bundle: org.openjdk.jmc.common;visibility:=reexport\n+Automatic-Module-Name: org.openjdk.jmc.flightrecorder.writer\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/META-INF\/MANIFEST.MF","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+#\n+#  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+#  Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+#\n+#  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+#  The contents of this file are subject to the terms of either the Universal Permissive License \n+#  v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+#   \n+#  or the following license:\n+#   \n+#  Redistribution and use in source and binary forms, with or without modification, are permitted\n+#  provided that the following conditions are met:\n+#   \n+#  1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+#  and the following disclaimer.\n+#   \n+#  2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+#  conditions and the following disclaimer in the documentation and\/or other materials provided with\n+#  the distribution.\n+#   \n+#  3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+#  endorse or promote products derived from this software without specific prior written permission.\n+#\n+#  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+#  FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+#  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+#  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+#  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+#  WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+#\n+source.. = src\/main\/java\/,\\\n+           src\/main\/resources\/\n+output.. = target\/classes\/\n+bin.includes = META-INF\/,\\\n+               .\n+pde.match.rule.bundle=compatible\n+jre.compilation.profile = JavaSE-1.8\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/build.properties","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+   Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+   Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+\n+   DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\n+   The contents of this file are subject to the terms of either the Universal Permissive License\n+   v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+\n+   or the following license:\n+\n+   Redistribution and use in source and binary forms, with or without modification, are permitted\n+   provided that the following conditions are met:\n+\n+   1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+   and the following disclaimer.\n+\n+   2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+   conditions and the following disclaimer in the documentation and\/or other materials provided with\n+   the distribution.\n+\n+   3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+   endorse or promote products derived from this software without specific prior written permission.\n+\n+   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+   FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+   WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+-->\n+<project xmlns=\"http:\/\/maven.apache.org\/POM\/4.0.0\" xmlns:xsi=\"http:\/\/www.w3.org\/2001\/XMLSchema-instance\" xsi:schemaLocation=\"http:\/\/maven.apache.org\/POM\/4.0.0 http:\/\/maven.apache.org\/xsd\/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0<\/modelVersion>\n+    <parent>\n+        <groupId>org.openjdk.jmc<\/groupId>\n+        <artifactId>missioncontrol.core<\/artifactId>\n+        <version>8.0.0-SNAPSHOT<\/version>\n+    <\/parent>\n+    <artifactId>flightrecorder.writer<\/artifactId>\n+    <properties>\n+        <spotless.config.path>${basedir}\/..\/..\/configuration\/ide\/eclipse\/formatting\/formatting.xml<\/spotless.config.path>\n+        <maven.compiler.target>8<\/maven.compiler.target>\n+        <maven.compiler.source>8<\/maven.compiler.source>\n+    <\/properties>\n+    <dependencies>\n+        <dependency>\n+            <groupId>org.openjdk.jmc<\/groupId>\n+            <artifactId>common<\/artifactId>\n+            <version>${project.version}<\/version>\n+        <\/dependency>\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-api<\/artifactId>\n+            <version>5.5.2<\/version>\n+        <\/dependency>\n+        <dependency>\n+            <groupId>org.junit.jupiter<\/groupId>\n+            <artifactId>junit-jupiter-params<\/artifactId>\n+            <version>5.5.2<\/version>\n+        <\/dependency>\n+        <dependency>\n+            <groupId>org.mockito<\/groupId>\n+            <artifactId>mockito-core<\/artifactId>\n+            <version>3.1.0<\/version>\n+        <\/dependency>\n+        <dependency>\n+            <groupId>org.projectlombok<\/groupId>\n+            <artifactId>lombok<\/artifactId>\n+            <version>1.18.12<\/version>\n+            <scope>provided<\/scope>\n+        <\/dependency>\n+\n+        <dependency>\n+            <groupId>org.openjdk.jmc<\/groupId>\n+            <artifactId>flightrecorder<\/artifactId>\n+            <version>${project.version}<\/version>\n+            <scope>test<\/scope>\n+        <\/dependency>\n+    <\/dependencies>\n+<\/project>\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/pom.xml","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+abstract class AbstractLEB128Writer implements LEB128Writer {\n+\t@Override\n+\tpublic final LEB128Writer writeChar(char data) {\n+\t\twriteChar(position(), data);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic final long writeChar(long offset, char data) {\n+\t\treturn writeLong(offset, data & 0x000000000000ffffL);\n+\t}\n+\n+\t@Override\n+\tpublic final LEB128Writer writeShort(short data) {\n+\t\twriteShort(position(), data);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic final long writeShort(long offset, short data) {\n+\t\treturn writeLong(offset, data & 0x000000000000ffffL);\n+\t}\n+\n+\t@Override\n+\tpublic final LEB128Writer writeInt(int data) {\n+\t\twriteInt(position(), data);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic final long writeInt(long offset, int data) {\n+\t\treturn writeLong(offset, data & 0x00000000ffffffffL);\n+\t}\n+\n+\t@Override\n+\tpublic final LEB128Writer writeLong(long data) {\n+\t\twriteLong(position(), data);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic final long writeLong(long offset, long data) {\n+\t\tif ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+\t\t\treturn writeByte(offset, (byte) (data & 0xff));\n+\t\t}\n+\t\toffset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+\t\tdata >>= 7;\n+\t\tif ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+\t\t\treturn writeByte(offset, (byte) data);\n+\t\t}\n+\t\toffset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+\t\tdata >>= 7;\n+\t\tif ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+\t\t\treturn writeByte(offset, (byte) data);\n+\t\t}\n+\t\toffset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+\t\tdata >>= 7;\n+\t\tif ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+\t\t\treturn writeByte(offset, (byte) data);\n+\t\t}\n+\t\toffset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+\t\tdata >>= 7;\n+\t\tif ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+\t\t\treturn writeByte(offset, (byte) data);\n+\t\t}\n+\t\toffset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+\t\tdata >>= 7;\n+\t\tif ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+\t\t\treturn writeByte(offset, (byte) data);\n+\t\t}\n+\t\toffset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+\t\tdata >>= 7;\n+\t\tif ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+\t\t\treturn writeByte(offset, (byte) data);\n+\t\t}\n+\t\toffset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+\t\tdata >>= 7;\n+\t\tif ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+\t\t\treturn writeByte(offset, (byte) data);\n+\t\t}\n+\t\toffset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+\t\treturn writeByte(offset, (byte) (data >> 7));\n+\t}\n+\n+\t@Override\n+\tpublic final LEB128Writer writeFloat(float data) {\n+\t\twriteFloat(position(), data);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic final LEB128Writer writeDouble(double data) {\n+\t\twriteDouble(position(), data);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic final LEB128Writer writeBoolean(boolean data) {\n+\t\twriteBoolean(position(), data);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic final long writeBoolean(long offset, boolean data) {\n+\t\treturn writeByte(offset, data ? (byte) 1 : (byte) 0);\n+\t}\n+\n+\t@Override\n+\tpublic final LEB128Writer writeByte(byte data) {\n+\t\twriteByte(position(), data);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic final LEB128Writer writeBytes(byte ... data) {\n+\t\twriteBytes(position(), data);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic final LEB128Writer writeUTF(String data) {\n+\t\twriteUTF(position(), data);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic final LEB128Writer writeUTF(byte[] data) {\n+\t\twriteUTF(position(), data);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic final long writeUTF(long offset, String data) {\n+\t\treturn writeUTF(offset, data == null ? null : data.getBytes(StandardCharsets.UTF_8));\n+\t}\n+\n+\t@Override\n+\tpublic final long writeUTF(long offset, byte[] data) {\n+\t\tint len = data == null ? 0 : data.length;\n+\t\tlong pos = writeInt(offset, len);\n+\t\tif (len > 0) {\n+\t\t\tpos = writeBytes(pos, data);\n+\t\t}\n+\t\treturn pos;\n+\t}\n+\n+\t@Override\n+\tpublic final LEB128Writer writeCompactUTF(byte[] data) {\n+\t\twriteCompactUTF(position(), data);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic final LEB128Writer writeCompactUTF(String data) {\n+\t\twriteCompactUTF(position(), data);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic final long writeCompactUTF(long offset, byte[] data) {\n+\t\tif (data == null) {\n+\t\t\treturn writeByte(offset, (byte) 0); \/\/ special NULL encoding\n+\t\t}\n+\t\tif (data.length == 0) {\n+\t\t\treturn writeByte(offset, (byte) 1); \/\/ special empty string encoding\n+\t\t}\n+\t\tlong pos = writeByte(offset, (byte) 3); \/\/ UTF-8 string\n+\t\tpos = writeInt(pos, data.length);\n+\t\tpos = writeBytes(pos, data);\n+\t\treturn pos;\n+\t}\n+\n+\t@Override\n+\tpublic final long writeCompactUTF(long offset, String data) {\n+\t\treturn writeCompactUTF(offset, data != null ? data.getBytes(StandardCharsets.UTF_8) : null);\n+\t}\n+\n+\t@Override\n+\tpublic final LEB128Writer writeShortRaw(short data) {\n+\t\twriteShortRaw(position(), data);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic final LEB128Writer writeIntRaw(int data) {\n+\t\twriteIntRaw(position(), data);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic final LEB128Writer writeLongRaw(long data) {\n+\t\twriteLongRaw(position(), data);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic final int length() {\n+\t\treturn adjustLength(position());\n+\t}\n+\n+\tstatic int adjustLength(int length) {\n+\t\tint extraLen = 0;\n+\t\tdo {\n+\t\t\textraLen = getPackedIntLen(length + extraLen);\n+\t\t} while (getPackedIntLen(length + extraLen) != extraLen);\n+\t\treturn length + extraLen;\n+\t}\n+\n+\tstatic int getPackedIntLen(long data) {\n+\t\tif ((data & COMPRESSED_INT_MASK) == 0) {\n+\t\t\treturn 1;\n+\t\t}\n+\t\tdata >>= 7;\n+\t\tif ((data & COMPRESSED_INT_MASK) == 0) {\n+\t\t\treturn 2;\n+\t\t}\n+\t\tdata >>= 7;\n+\t\tif ((data & COMPRESSED_INT_MASK) == 0) {\n+\t\t\treturn 3;\n+\t\t}\n+\t\tdata >>= 7;\n+\t\tif ((data & COMPRESSED_INT_MASK) == 0) {\n+\t\t\treturn 4;\n+\t\t}\n+\t\tdata >>= 7;\n+\t\tif ((data & COMPRESSED_INT_MASK) == 0) {\n+\t\t\treturn 5;\n+\t\t}\n+\t\tdata >>= 7;\n+\t\tif ((data & COMPRESSED_INT_MASK) == 0) {\n+\t\t\treturn 6;\n+\t\t}\n+\t\tdata >>= 7;\n+\t\tif ((data & COMPRESSED_INT_MASK) == 0) {\n+\t\t\treturn 7;\n+\t\t}\n+\t\tdata >>= 7;\n+\t\tif ((data & COMPRESSED_INT_MASK) == 0) {\n+\t\t\treturn 8;\n+\t\t}\n+\t\treturn 9;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/AbstractLEB128Writer.java","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import lombok.ToString;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValueBuilder;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedFieldBuilder;\n+import org.openjdk.jmc.flightrecorder.writer.util.NonZeroHashCode;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * Common JFR type super-class\n+ *\/\n+@ToString(of = {\"id\", \"name\", \"supertype\"})\n+abstract class BaseType implements TypeImpl {\n+\tint hashcode = 0;\n+\n+\tprivate final long id;\n+\tprivate final String name;\n+\tprivate final String supertype;\n+\tprivate final ConstantPools constantPools;\n+\tprivate final TypesImpl types;\n+\tprivate final AtomicReference<TypedValueImpl> nullValue = new AtomicReference<>();\n+\n+\tBaseType(long id, String name, String supertype, ConstantPools constantPools, TypesImpl types) {\n+\t\tthis.id = id;\n+\t\tthis.name = name;\n+\t\tthis.supertype = supertype;\n+\t\tthis.constantPools = constantPools;\n+\t\tthis.types = types;\n+\t}\n+\n+\tBaseType(long id, String name, ConstantPools constantPools, TypesImpl types) {\n+\t\tthis(id, name, null, constantPools, types);\n+\t}\n+\n+\t@Override\n+\tpublic long getId() {\n+\t\treturn id;\n+\t}\n+\n+\t@Override\n+\tpublic TypesImpl getTypes() {\n+\t\treturn types;\n+\t}\n+\n+\t@Override\n+\tpublic final boolean isSimple() {\n+\t\tList<TypedFieldImpl> fields = getFields();\n+\t\tif (fields.size() == 1) {\n+\t\t\tTypedFieldImpl field = fields.get(0);\n+\t\t\treturn field.getType().isBuiltin() && !field.isArray();\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isResolved() {\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tpublic final String getTypeName() {\n+\t\treturn name;\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasConstantPool() {\n+\t\treturn constantPools != null;\n+\t}\n+\n+\t@Override\n+\tpublic final String getSupertype() {\n+\t\treturn supertype;\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(String value) {\n+\t\tif (hasConstantPool()) {\n+\t\t\treturn constantPools.forType(this).addOrGet(value);\n+\t\t}\n+\t\treturn new TypedValueImpl(this, value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(byte value) {\n+\t\tif (hasConstantPool()) {\n+\t\t\treturn constantPools.forType(this).addOrGet(value);\n+\t\t}\n+\t\treturn new TypedValueImpl(this, value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(char value) {\n+\t\tif (hasConstantPool()) {\n+\t\t\treturn constantPools.forType(this).addOrGet(value);\n+\t\t}\n+\t\treturn new TypedValueImpl(this, value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(short value) {\n+\t\tif (hasConstantPool()) {\n+\t\t\treturn constantPools.forType(this).addOrGet(value);\n+\t\t}\n+\t\treturn new TypedValueImpl(this, value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(int value) {\n+\t\tif (hasConstantPool()) {\n+\t\t\treturn constantPools.forType(this).addOrGet(value);\n+\t\t}\n+\t\treturn new TypedValueImpl(this, value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(long value) {\n+\t\tif (hasConstantPool()) {\n+\t\t\treturn constantPools.forType(this).addOrGet(value);\n+\t\t}\n+\t\treturn new TypedValueImpl(this, value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(float value) {\n+\t\tif (hasConstantPool()) {\n+\t\t\treturn constantPools.forType(this).addOrGet(value);\n+\t\t}\n+\t\treturn new TypedValueImpl(this, value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(double value) {\n+\t\tif (hasConstantPool()) {\n+\t\t\treturn constantPools.forType(this).addOrGet(value);\n+\t\t}\n+\t\treturn new TypedValueImpl(this, value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(boolean value) {\n+\t\tif (hasConstantPool()) {\n+\t\t\treturn constantPools.forType(this).addOrGet(value);\n+\t\t}\n+\t\treturn new TypedValueImpl(this, value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(Consumer<TypedValueBuilder> builderCallback) {\n+\t\tif (isBuiltin()) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\tTypedValueImpl checkValue = new TypedValueImpl(this, builderCallback);\n+\t\tif (hasConstantPool()) {\n+\t\t\treturn constantPools.forType(this).addOrGet(checkValue);\n+\t\t}\n+\t\treturn checkValue;\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(Object value) {\n+\t\tif (hasConstantPool()) {\n+\t\t\treturn constantPools.forType(this).addOrGet(value);\n+\t\t}\n+\t\treturn new TypedValueImpl(this, value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl nullValue() {\n+\t\treturn nullValue.updateAndGet(v -> (v == null ? TypedValueImpl.ofNull(this) : v));\n+\t}\n+\n+\t@Override\n+\tpublic boolean isUsedBy(Type other) {\n+\t\tif (other == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn isUsedBy(this, (TypeImpl) other, new HashSet<>());\n+\t}\n+\n+\tprivate static boolean isUsedBy(TypeImpl type1, TypeImpl type2, HashSet<TypeImpl> track) {\n+\t\tif (!track.add(type2)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tfor (TypedFieldImpl typedField : type2.getFields()) {\n+\t\t\tif (typedField.getType().equals(type1)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tif (isUsedBy(type1, typedField.getType(), track)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tBaseType baseType = (BaseType) o;\n+\t\treturn id == baseType.id && name.equals(baseType.name) && Objects.equals(supertype, baseType.supertype);\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tif (hashcode == 0) {\n+\t\t\thashcode = NonZeroHashCode.hash(id, name, supertype);\n+\t\t}\n+\t\treturn hashcode;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/BaseType.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import lombok.ToString;\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n+import org.openjdk.jmc.flightrecorder.writer.util.NonZeroHashCode;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+\/** A built-in type. Corresponds to a Java primitive type or {@link String String} *\/\n+@ToString(of = \"builtin\")\n+final class BuiltinType extends BaseType {\n+\tprivate int hashcode = 0;\n+\n+\tprivate final Types.Builtin builtin;\n+\n+\tBuiltinType(long id, Types.Builtin type, ConstantPools constantPools, TypesImpl types) {\n+\t\tsuper(id, type.getTypeName(), constantPools, types);\n+\t\tthis.builtin = type;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isBuiltin() {\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tpublic List<TypedFieldImpl> getFields() {\n+\t\treturn Collections.emptyList();\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldImpl getField(String name) {\n+\t\tthrow new IllegalArgumentException();\n+\t}\n+\n+\t@Override\n+\tpublic List<Annotation> getAnnotations() {\n+\t\treturn Collections.emptyList();\n+\t}\n+\n+\t@Override\n+\tpublic boolean canAccept(Object value) {\n+\t\tif (value == null) {\n+\t\t\t\/\/ non-initialized built-ins will get the default value and String will be properly handled\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tif (value instanceof TypedValueImpl) {\n+\t\t\treturn this == ((TypedValueImpl) value).getType();\n+\t\t}\n+\t\tswitch (builtin) {\n+\t\tcase STRING: {\n+\t\t\treturn (value instanceof String);\n+\t\t}\n+\t\tcase BYTE: {\n+\t\t\treturn value instanceof Byte;\n+\t\t}\n+\t\tcase CHAR: {\n+\t\t\treturn value instanceof Character;\n+\t\t}\n+\t\tcase SHORT: {\n+\t\t\treturn value instanceof Short;\n+\t\t}\n+\t\tcase INT: {\n+\t\t\treturn value instanceof Integer;\n+\t\t}\n+\t\tcase LONG: {\n+\t\t\treturn value instanceof Long;\n+\t\t}\n+\t\tcase FLOAT: {\n+\t\t\treturn value instanceof Float;\n+\t\t}\n+\t\tcase DOUBLE: {\n+\t\t\treturn value instanceof Double;\n+\t\t}\n+\t\tcase BOOLEAN: {\n+\t\t\treturn value instanceof Boolean;\n+\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (!super.equals(o)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tBuiltinType that = (BuiltinType) o;\n+\t\treturn builtin == that.builtin;\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tif (hashcode == 0) {\n+\t\t\thashcode = NonZeroHashCode.hash(super.hashCode(), builtin);\n+\t\t}\n+\t\treturn hashcode;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/BuiltinType.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import lombok.ToString;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedFieldValue;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValue;\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n+\n+import java.util.function.Consumer;\n+\n+\/** A representation of JFR chunk - self contained set of JFR data. *\/\n+@ToString\n+final class Chunk {\n+\tprivate final LEB128Writer writer = LEB128Writer.getInstance();\n+\tprivate final long startTicks;\n+\tprivate final long startNanos;\n+\n+\tChunk() {\n+\t\tthis.startTicks = System.nanoTime();\n+\t\tthis.startNanos = System.currentTimeMillis() * 1_000_000L;\n+\t}\n+\n+\t\/**\n+\t * Finalize the chunk. The chunk should not be used after it has been finished.\n+\t *\/\n+\tvoid finish(Consumer<LEB128Writer> completer) {\n+\t\tcompleter.accept(writer);\n+\t}\n+\n+\tvoid writeTypedValue(LEB128Writer writer, TypedValueImpl value) {\n+\t\tif (value == null) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\n+\t\tTypeImpl t = value.getType();\n+\t\tif (t.isBuiltin()) {\n+\t\t\twriteBuiltinType(writer, value);\n+\t\t} else {\n+\t\t\tif (value.getType().hasConstantPool()) {\n+\t\t\t\twriter.writeLong(value.getConstantPoolIndex());\n+\t\t\t} else {\n+\t\t\t\twriteFields(writer, value);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void writeFields(LEB128Writer writer, TypedValueImpl value) {\n+\t\tfor (TypedFieldValueImpl fieldValue : value.getFieldValues()) {\n+\t\t\tif (fieldValue.getField().isArray()) {\n+\t\t\t\twriter.writeInt(fieldValue.getValues().length); \/\/ array size\n+\t\t\t\tfor (TypedValueImpl tValue : fieldValue.getValues()) {\n+\t\t\t\t\twriteTypedValue(writer, tValue);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\twriteTypedValue(writer, fieldValue.getValue());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void writeBuiltinType(LEB128Writer writer, TypedValueImpl typedValue) {\n+\t\tTypeImpl type = typedValue.getType();\n+\t\tObject value = typedValue.getValue();\n+\t\tTypesImpl.Builtin builtin = Types.Builtin.ofType(type);\n+\t\tif (builtin == null) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\n+\t\tif (value == null && builtin != TypesImpl.Builtin.STRING) {\n+\t\t\t\/\/ skip the non-string built-in values\n+\t\t\treturn;\n+\t\t}\n+\t\tswitch (builtin) {\n+\t\tcase STRING: {\n+\t\t\tif (value == null) {\n+\t\t\t\twriter.writeByte((byte) 0);\n+\t\t\t} else if (((String) value).isEmpty()) {\n+\t\t\t\twriter.writeByte((byte) 1);\n+\t\t\t} else {\n+\t\t\t\tlong idx = typedValue.getConstantPoolIndex();\n+\t\t\t\tif (idx > Long.MIN_VALUE) {\n+\t\t\t\t\twriter.writeByte((byte) 2).writeLong(idx);\n+\t\t\t\t} else {\n+\t\t\t\t\twriter.writeCompactUTF((String) value);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase BYTE: {\n+\t\t\twriter.writeByte((byte) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase CHAR: {\n+\t\t\twriter.writeChar((char) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase SHORT: {\n+\t\t\twriter.writeShort((short) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase INT: {\n+\t\t\twriter.writeInt((int) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase LONG: {\n+\t\t\twriter.writeLong((long) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase FLOAT: {\n+\t\t\twriter.writeFloat((float) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase DOUBLE: {\n+\t\t\twriter.writeDouble((double) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase BOOLEAN: {\n+\t\t\twriter.writeBoolean((boolean) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tdefault: {\n+\t\t\tthrow new IllegalArgumentException(\"Unsupported built-in type \" + type.getTypeName());\n+\t\t}\n+\t\t}\n+\t}\n+\n+\tvoid writeEvent(TypedValueImpl event) {\n+\t\tif (!\"jdk.jfr.Event\".equals(event.getType().getSupertype())) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\n+\t\tLEB128Writer eventWriter = LEB128Writer.getInstance();\n+\t\teventWriter.writeLong(event.getType().getId());\n+\t\tfor (TypedFieldValueImpl fieldValue : event.getFieldValues()) {\n+\t\t\twriteTypedValue(eventWriter, fieldValue.getValue());\n+\t\t}\n+\n+\t\twriter.writeInt(eventWriter.length()) \/\/ write event size\n+\t\t\t\t.writeBytes(eventWriter.export());\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/Chunk.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+import org.openjdk.jmc.flightrecorder.writer.util.NonZeroHashCode;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+\/** A composite JFR type *\/\n+final class CompositeTypeImpl extends BaseType {\n+\tprivate int hashCode = 0;\n+\n+\tprivate final Map<String, TypedFieldImpl> fieldMap;\n+\tprivate final List<TypedFieldImpl> fields;\n+\tprivate final List<Annotation> annotations;\n+\n+\tCompositeTypeImpl(long id, String name, String supertype, TypeStructureImpl typeStructure,\n+\t\t\tConstantPools constantPools, TypesImpl types) {\n+\t\tsuper(id, name, supertype, constantPools, types);\n+\t\tthis.fields = collectFields(typeStructure);\n+\t\tthis.annotations = typeStructure == null ? Collections.emptyList()\n+\t\t\t\t: Collections.unmodifiableList(typeStructure.getAnnotations());\n+\t\tthis.fieldMap = fields.stream().collect(Collectors.toMap(TypedFieldImpl::getName, f -> f));\n+\t}\n+\n+\tprivate List<TypedFieldImpl> collectFields(TypeStructureImpl typeStructure) {\n+\t\tif (typeStructure == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tList<TypedFieldImpl> fields = new ArrayList<>();\n+\t\tfor (TypedFieldImpl field : typeStructure.fields) {\n+\t\t\tif (field.getType() == SelfType.INSTANCE) {\n+\t\t\t\tfields.add(new TypedFieldImpl(this, field.getName(), field.isArray()));\n+\t\t\t} else {\n+\t\t\t\tfields.add(field);\n+\t\t\t}\n+\t\t}\n+\t\treturn fields;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isBuiltin() {\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tpublic List<TypedFieldImpl> getFields() {\n+\t\treturn fields;\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldImpl getField(String name) {\n+\t\treturn fieldMap.get(name);\n+\t}\n+\n+\t@Override\n+\tpublic List<Annotation> getAnnotations() {\n+\t\treturn annotations;\n+\t}\n+\n+\t@Override\n+\tpublic boolean canAccept(Object value) {\n+\t\tif (value == null) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (value instanceof TypedValueImpl) {\n+\t\t\treturn ((TypedValueImpl) value).getType().equals(this);\n+\t\t}\n+\t\treturn value instanceof Map;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (!super.equals(o)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tCompositeTypeImpl that = (CompositeTypeImpl) o;\n+\t\treturn fields.equals(that.fields) && annotations.equals(that.annotations);\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tif (hashCode == 0) {\n+\t\t\tList<TypedFieldImpl> nonRecursiveFields = new ArrayList<>(fields.size());\n+\t\t\tfor (TypedFieldImpl typedField : fields) {\n+\t\t\t\tif (typedField.getType() != this) {\n+\t\t\t\t\tnonRecursiveFields.add(typedField);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\thashCode = NonZeroHashCode.hash(super.hashCode(), nonRecursiveFields, annotations);\n+\t\t}\n+\t\treturn hashCode;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"CompositeType(\" + getTypeName() + \")\";\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/CompositeTypeImpl.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import lombok.EqualsAndHashCode;\n+import lombok.ToString;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValue;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/** An in-memory map of distinct values of a certain {@linkplain Type} *\/\n+@ToString(of = \"type\")\n+@EqualsAndHashCode\n+final class ConstantPool {\n+\tprivate final TypeImpl type;\n+\tprivate final Map<Object, TypedValueImpl> constantMap = new HashMap<>();\n+\tprivate final Map<Long, TypedValueImpl> reverseMap = new HashMap<>();\n+\n+\tConstantPool(TypeImpl type) {\n+\t\tthis.type = type;\n+\t}\n+\n+\t\/**\n+\t * Tries to add a new value\n+\t *\n+\t * @param value\n+\t *            the value\n+\t * @return the typed value representation - either created a-new or retrieved from the pool\n+\t *\/\n+\tTypedValueImpl addOrGet(Object value) {\n+\t\tif (value == null) {\n+\t\t\treturn type.nullValue();\n+\t\t}\n+\t\treturn constantMap.computeIfAbsent(value, v -> {\n+\t\t\tlong index = constantMap.size() + 1; \/\/ index 0 is reserved for NULL encoding\n+\t\t\tTypedValueImpl tValue;\n+\t\t\tif (v instanceof TypedValue) {\n+\t\t\t\ttValue = new TypedValueImpl((TypedValueImpl) v, index);\n+\t\t\t} else {\n+\t\t\t\ttValue = new TypedValueImpl(type, v, index);\n+\t\t\t}\n+\t\t\treverseMap.put(index, tValue);\n+\t\t\treturn tValue;\n+\t\t});\n+\t}\n+\n+\t\/**\n+\t * Get the value at the given index\n+\t *\n+\t * @param index\n+\t *            the value index\n+\t * @return the value or {@literal null}\n+\t *\/\n+\tTypedValueImpl get(long index) {\n+\t\treturn reverseMap.get(index);\n+\t}\n+\n+\tvoid writeTo(LEB128Writer writer) {\n+\t\twriter.writeLong(type.getId()); \/\/ CP type ID\n+\t\twriter.writeInt(constantMap.size()); \/\/ number of constants\n+\t\treverseMap.forEach((k, v) -> {\n+\t\t\twriter.writeLong(k); \/\/ constant index\n+\t\t\twriteValueType(writer, v, false);\n+\t\t});\n+\t}\n+\n+\tvoid writeValueType(LEB128Writer writer, TypedValueImpl typedValue, boolean useCp) {\n+\t\tif (typedValue == null) {\n+\t\t\tthrow new NullPointerException();\n+\t\t}\n+\t\tTypeImpl type = typedValue.getType();\n+\t\tif (type.isBuiltin()) {\n+\t\t\twriteBuiltinType(writer, typedValue, useCp);\n+\t\t} else {\n+\t\t\tif (typedValue.isNull()) {\n+\t\t\t\twriter.writeLong(0); \/\/ null value encoding\n+\t\t\t} else {\n+\t\t\t\tif (useCp) { \/\/ (assumption) all custom types have constant pool\n+\t\t\t\t\twriter.writeLong(typedValue.getConstantPoolIndex());\n+\t\t\t\t} else {\n+\t\t\t\t\tfor (TypedFieldValueImpl fieldValue : typedValue.getFieldValues()) {\n+\t\t\t\t\t\tif (fieldValue.getField().isArray()) {\n+\t\t\t\t\t\t\twriter.writeInt(fieldValue.getValues().length); \/\/ array length\n+\t\t\t\t\t\t\tfor (TypedValueImpl t : fieldValue.getValues()) {\n+\t\t\t\t\t\t\t\twriteValueType(writer, t, true);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\twriteValueType(writer, fieldValue.getValue(), true);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tvoid writeBuiltinType(LEB128Writer writer, TypedValueImpl typedValue, boolean useCp) {\n+\t\tif (typedValue == null) {\n+\t\t\tthrow new NullPointerException();\n+\t\t}\n+\n+\t\tif (!typedValue.getType().isBuiltin()) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\n+\t\tTypeImpl type = typedValue.getType();\n+\t\tObject value = typedValue.getValue();\n+\t\tTypesImpl.Builtin builtin = TypesImpl.Builtin.ofType(type);\n+\n+\t\tif (value == null && builtin != TypesImpl.Builtin.STRING) {\n+\t\t\t\/\/ skip the non-string built-in values but use CP index '0' if CP is requested\n+\t\t\tif (useCp) {\n+\t\t\t\twriter.writeLong(0L);\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\t\tswitch (builtin) {\n+\t\tcase STRING: {\n+\t\t\tif (useCp) {\n+\t\t\t\tif (typedValue.isNull()) {\n+\t\t\t\t\twriter.writeByte((byte) 0); \/\/ skip CP for NULL\n+\t\t\t\t} else if (((String) typedValue.getValue()).isEmpty()) {\n+\t\t\t\t\twriter.writeByte((byte) 1); \/\/ skip CP for empty string\n+\t\t\t\t} else {\n+\t\t\t\t\twriter.writeByte((byte) 2) \/\/ set constant-pool encoding\n+\t\t\t\t\t\t\t.writeLong(typedValue.getConstantPoolIndex());\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\twriter.writeCompactUTF((String) value);\n+\t\t\t}\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase BYTE: {\n+\t\t\twriter.writeBytes((byte) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase CHAR: {\n+\t\t\twriter.writeChar((char) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase SHORT: {\n+\t\t\twriter.writeShort((short) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase INT: {\n+\t\t\twriter.writeInt((int) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase LONG: {\n+\t\t\twriter.writeLong((long) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase FLOAT: {\n+\t\t\twriter.writeFloat((float) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase DOUBLE: {\n+\t\t\twriter.writeDouble((double) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase BOOLEAN: {\n+\t\t\twriter.writeBoolean((boolean) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tdefault: {\n+\t\t\tthrow new IllegalArgumentException(\"Unsupported built-in type \" + type.getTypeName());\n+\t\t}\n+\t\t}\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/ConstantPool.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import lombok.EqualsAndHashCode;\n+import lombok.ToString;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.util.TypeByUsageComparator;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Spliterator;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/** A per-type map of {@linkplain ConstantPool} instances *\/\n+@ToString\n+@EqualsAndHashCode\n+public final class ConstantPools implements Iterable<ConstantPool> {\n+\tprivate final Map<TypeImpl, ConstantPool> constantPoolMap = new ConcurrentHashMap<>();\n+\n+\t\/**\n+\t * Get the {@linkplain ConstantPool} instance associated with the given type\n+\t *\n+\t * @param type\n+\t *            the type to get the constant pool for\n+\t * @return the associated {@linkplain ConstantPool} instance\n+\t * @throws IllegalArgumentException\n+\t *             if the type does not support constant pools\n+\t *\/\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic ConstantPool forType(TypeImpl type) {\n+\t\tif (!type.hasConstantPool()) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\treturn constantPoolMap.computeIfAbsent(type, this::newConstantPool);\n+\t}\n+\n+\tpublic int size() {\n+\t\treturn constantPoolMap.size();\n+\t}\n+\n+\t@Override\n+\tpublic Iterator<ConstantPool> iterator() {\n+\t\treturn getOrderedPools().iterator();\n+\t}\n+\n+\t@Override\n+\tpublic void forEach(Consumer<? super ConstantPool> action) {\n+\t\tgetOrderedPoolsStream().forEach(action);\n+\t}\n+\n+\t@Override\n+\tpublic Spliterator<ConstantPool> spliterator() {\n+\t\treturn getOrderedPools().spliterator();\n+\t}\n+\n+\t\/**\n+\t * The pool instances need to be sorted in a way that if a value from pool P1 is using value(s)\n+\t * from pool P2 then P2 must come before P1.\n+\t *\n+\t * @return sorted pool instances\n+\t *\/\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate Stream<ConstantPool> getOrderedPoolsStream() {\n+\t\treturn constantPoolMap.entrySet().stream()\n+\t\t\t\t.sorted((e1, e2) -> TypeByUsageComparator.INSTANCE.compare(e1.getKey(), e2.getKey()))\n+\t\t\t\t.map(Map.Entry::getValue);\n+\t}\n+\n+\tprivate List<ConstantPool> getOrderedPools() {\n+\t\treturn getOrderedPoolsStream().collect(Collectors.toList());\n+\t}\n+\n+\tprivate ConstantPool newConstantPool(TypeImpl type) {\n+\t\treturn new ConstantPool(type);\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/ConstantPools.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import lombok.Getter;\n+import lombok.NonNull;\n+import org.openjdk.jmc.flightrecorder.writer.util.NonZeroHashCode;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+\n+final class ImmutableMapEntry<K, V> implements Map.Entry<K, V> {\n+\tprivate int hashCode = 0;\n+\n+\t@Getter\n+\tprivate final K key;\n+\t@Getter\n+\tprivate final V value;\n+\n+\tImmutableMapEntry(@NonNull K key, V value) {\n+\t\tthis.key = key;\n+\t\tthis.value = value;\n+\t}\n+\n+\t@Override\n+\tpublic V setValue(V v) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tImmutableMapEntry<?, ?> that = (ImmutableMapEntry<?, ?>) o;\n+\t\treturn key.equals(that.key) && Objects.equals(value, that.value);\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tif (hashCode == 0) {\n+\t\t\thashCode = NonZeroHashCode.hash(key, value);\n+\t\t}\n+\t\treturn hashCode;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/ImmutableMapEntry.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.function.Consumer;\n+\n+\/** Byte-array writer with default support for LEB128 encoded integer types *\/\n+final class LEB128ByteArrayWriter extends AbstractLEB128Writer {\n+\tprivate byte[] array;\n+\tprivate int pointer = 0;\n+\n+\tLEB128ByteArrayWriter(int intialCapacity) {\n+\t\tarray = new byte[intialCapacity];\n+\t}\n+\n+\t@Override\n+\tpublic void reset() {\n+\t\tArrays.fill(array, (byte) 0);\n+\t\tpointer = 0;\n+\t}\n+\n+\t@Override\n+\tpublic long writeFloat(long offset, float data) {\n+\t\treturn writeIntRaw(offset, Float.floatToIntBits(data));\n+\t}\n+\n+\t@Override\n+\tpublic long writeDouble(long offset, double data) {\n+\t\treturn writeLongRaw(offset, Double.doubleToLongBits(data));\n+\t}\n+\n+\t@Override\n+\tpublic long writeByte(long offset, byte data) {\n+\t\tint newOffset = (int) (offset + 1);\n+\t\tif (newOffset >= array.length) {\n+\t\t\tarray = Arrays.copyOf(array, newOffset * 2);\n+\t\t}\n+\t\tarray[(int) offset] = data;\n+\t\tpointer = Math.max(newOffset, pointer);\n+\t\treturn newOffset;\n+\t}\n+\n+\t@Override\n+\tpublic long writeBytes(long offset, byte ... data) {\n+\t\tif (data == null) {\n+\t\t\treturn offset;\n+\t\t}\n+\t\tint newOffset = (int) (offset + data.length);\n+\t\tif (newOffset >= array.length) {\n+\t\t\tarray = Arrays.copyOf(array, newOffset * 2);\n+\t\t}\n+\t\tSystem.arraycopy(data, 0, array, (int) offset, data.length);\n+\t\tpointer = Math.max(newOffset, pointer);\n+\t\treturn newOffset;\n+\t}\n+\n+\t@Override\n+\tpublic long writeShortRaw(long offset, short data) {\n+\t\treturn writeBytes(offset, (byte) ((data >> 8) & 0xff), (byte) (data & 0xff));\n+\t}\n+\n+\t@Override\n+\tpublic long writeIntRaw(long offset, int data) {\n+\t\treturn writeBytes(offset, (byte) ((data >> 24) & 0xff), (byte) ((data >> 16) & 0xff),\n+\t\t\t\t(byte) ((data >> 8) & 0xff), (byte) (data & 0xff));\n+\t}\n+\n+\t@Override\n+\tpublic long writeLongRaw(long offset, long data) {\n+\t\treturn writeBytes(offset, (byte) ((data >> 56) & 0xff), (byte) ((data >> 48) & 0xff),\n+\t\t\t\t(byte) ((data >> 40) & 0xff), (byte) ((data >> 32) & 0xff), (byte) ((data >> 24) & 0xff),\n+\t\t\t\t(byte) ((data >> 16) & 0xff), (byte) ((data >> 8) & 0xff), (byte) (data & 0xff));\n+\t}\n+\n+\t@Override\n+\tpublic void export(Consumer<ByteBuffer> consumer) {\n+\t\tByteBuffer bb = ByteBuffer.wrap(array, 0, pointer);\n+\t\tbb.position(pointer);\n+\t\tconsumer.accept(bb);\n+\t}\n+\n+\t@Override\n+\tpublic int position() {\n+\t\treturn pointer;\n+\t}\n+\n+\t@Override\n+\tpublic int capacity() {\n+\t\treturn array.length;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/LEB128ByteArrayWriter.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,436 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import java.nio.ByteBuffer;\n+import java.util.function.Consumer;\n+\n+public interface LEB128Writer {\n+\tint EXT_BIT = 0x80;\n+\tlong COMPRESSED_INT_MASK = -EXT_BIT;\n+\n+\t\/**\n+\t * Get a default {@linkplain LEB128Writer} instance\n+\t *\n+\t * @return a new instance of {@linkplain LEB128Writer}\n+\t *\/\n+\tstatic LEB128Writer getInstance() {\n+\t\treturn new LEB128ByteArrayWriter(32767);\n+\t}\n+\n+\t\/** Reset the writer. Discard any collected data and set position to 0. *\/\n+\tvoid reset();\n+\n+\t\/**\n+\t * Write {@linkplain Character} data in LEB128 encoding\n+\t *\n+\t * @param data\n+\t *            the data\n+\t * @return the writer instance for chaining\n+\t *\/\n+\tLEB128Writer writeChar(char data);\n+\n+\t\/**\n+\t * Write {@linkplain Character} data in LEB128 encoding at the given offset\n+\t *\n+\t * @param offset\n+\t *            the offset from which to start writing the data\n+\t * @param data\n+\t *            the data\n+\t * @return the writer position after the data has been written\n+\t *\/\n+\tlong writeChar(long offset, char data);\n+\n+\t\/**\n+\t * Write {@linkplain Short} data in LEB128 encoding\n+\t *\n+\t * @param data\n+\t *            the data\n+\t * @return the writer instance for chaining\n+\t *\/\n+\tLEB128Writer writeShort(short data);\n+\n+\t\/**\n+\t * Write {@linkplain Short} data in LEB128 encoding at the given offset\n+\t *\n+\t * @param offset\n+\t *            the offset from which to start writing the data\n+\t * @param data\n+\t *            the data\n+\t * @return the writer position after the data has been written\n+\t *\/\n+\tlong writeShort(long offset, short data);\n+\n+\t\/**\n+\t * Write {@linkplain Integer} data in LEB128 encoding\n+\t *\n+\t * @param data\n+\t *            the data\n+\t * @return the writer instance for chaining\n+\t *\/\n+\tLEB128Writer writeInt(int data);\n+\n+\t\/**\n+\t * Write {@linkplain Integer} data in LEB128 encoding at the given offset\n+\t *\n+\t * @param offset\n+\t *            the offset from which to start writing the data\n+\t * @param data\n+\t *            the data\n+\t * @return the writer position after the data has been written\n+\t *\/\n+\tlong writeInt(long offset, int data);\n+\n+\t\/**\n+\t * Write {@linkplain Long} data in LEB128 encoding\n+\t *\n+\t * @param data\n+\t *            the data\n+\t * @return the writer instance for chaining\n+\t *\/\n+\tLEB128Writer writeLong(long data);\n+\n+\t\/**\n+\t * Write {@linkplain Long} data in LEB128 encoding at the given offset\n+\t *\n+\t * @param offset\n+\t *            the offset from which to start writing the data\n+\t * @param data\n+\t *            the data\n+\t * @return the writer position after the data has been written\n+\t *\/\n+\tlong writeLong(long offset, long data);\n+\n+\t\/**\n+\t * Write {@linkplain Float} data in default Java encoding\n+\t *\n+\t * @param data\n+\t *            the data\n+\t * @return the writer instance for chaining\n+\t *\/\n+\tLEB128Writer writeFloat(float data);\n+\n+\t\/**\n+\t * Write {@linkplain Float} data in default Java encoding at the given offset\n+\t *\n+\t * @param offset\n+\t *            the offset from which to start writing the data\n+\t * @param data\n+\t *            the data\n+\t * @return the writer position after the data has been written\n+\t *\/\n+\tlong writeFloat(long offset, float data);\n+\n+\t\/**\n+\t * Write {@linkplain Double} data in default Java encoding\n+\t *\n+\t * @param data\n+\t *            the data\n+\t * @return the writer instance for chaining\n+\t *\/\n+\tLEB128Writer writeDouble(double data);\n+\n+\t\/**\n+\t * Write {@linkplain Double} data in default Java encoding at the given offset\n+\t *\n+\t * @param offset\n+\t *            the offset from which to start writing the data\n+\t * @param data\n+\t *            the data\n+\t * @return the writer position after the data has been written\n+\t *\/\n+\tlong writeDouble(long offset, double data);\n+\n+\t\/**\n+\t * Write {@linkplain Boolean} data in default Java encoding\n+\t *\n+\t * @param data\n+\t *            the data\n+\t * @return the writer instance for chaining\n+\t *\/\n+\tLEB128Writer writeBoolean(boolean data);\n+\n+\t\/**\n+\t * Write {@linkplain Boolean} data in default Java encoding at the given offset\n+\t *\n+\t * @param offset\n+\t *            the offset from which to start writing the data\n+\t * @param data\n+\t *            the data\n+\t * @return the writer position after the data has been written\n+\t *\/\n+\tlong writeBoolean(long offset, boolean data);\n+\n+\t\/**\n+\t * Write {@linkplain Byte} data\n+\t *\n+\t * @param data\n+\t *            the data\n+\t * @return the writer instance for chaining\n+\t *\/\n+\tLEB128Writer writeByte(byte data);\n+\n+\t\/**\n+\t * Write {@linkplain Byte} data at the given offset\n+\t *\n+\t * @param offset\n+\t *            the offset from which to start writing the data\n+\t * @param data\n+\t *            the data\n+\t * @return the writer position after the data has been written\n+\t *\/\n+\tlong writeByte(long offset, byte data);\n+\n+\t\/**\n+\t * Write an array of {@linkplain Byte} elements\n+\t *\n+\t * @param data\n+\t *            the data\n+\t * @return the writer instance for chaining\n+\t *\/\n+\tLEB128Writer writeBytes(byte ... data);\n+\n+\t\/**\n+\t * Write an array of {@linkplain Byte} elements at the given offset\n+\t *\n+\t * @param offset\n+\t *            the offset from which to start writing the data\n+\t * @param data\n+\t *            the data\n+\t * @return the writer position after the data has been written\n+\t *\/\n+\tlong writeBytes(long offset, byte ... data);\n+\n+\t\/**\n+\t * Write {@linkplain String} as a sequence of bytes representing UTF8 encoded string. The\n+\t * sequence starts with LEB128 encoded int for the length of the sequence followed by the\n+\t * sequence bytes.\n+\t *\n+\t * @param data\n+\t *            the data\n+\t * @return the writer instance for chaining\n+\t *\/\n+\tLEB128Writer writeUTF(String data);\n+\n+\t\/**\n+\t * Write {@linkplain String} byte array data as a sequence of bytes representing UTF8 encoded\n+\t * string. The sequence starts with LEB128 encoded int for the length of the sequence followed\n+\t * by the sequence bytes.\n+\t *\n+\t * @param utf8Data\n+\t *            the byte array representation of an UTF8 string\n+\t * @return the writer instance for chaining\n+\t *\/\n+\tLEB128Writer writeUTF(byte[] utf8Data);\n+\n+\t\/**\n+\t * Write {@linkplain String} as a sequence of bytes representing UTF8 encoded string at the\n+\t * given offset. The sequence starts with LEB128 encoded int for the length of the sequence\n+\t * followed by the sequence bytes.\n+\t *\n+\t * @param offset\n+\t *            the offset from which to start writing the data\n+\t * @param data\n+\t *            the data\n+\t * @return the writer position after the data has been written\n+\t *\/\n+\tlong writeUTF(long offset, String data);\n+\n+\t\/**\n+\t * Write {@linkplain String} byte array data at the given offset. The sequence starts with\n+\t * LEB128 encoded int for the length of the sequence followed by the sequence bytes.\n+\t *\n+\t * @param offset\n+\t *            the offset from which to start writing the data\n+\t * @param utf8Data\n+\t *            the byte array representation of an UTF8 string\n+\t * @return the writer position after the data has been written\n+\t *\/\n+\tlong writeUTF(long offset, byte[] utf8Data);\n+\n+\t\/**\n+\t * Write {@linkplain String} byte array data in special encoding. The string will translate to\n+\t * (byte)0 for {@literal null} value, (byte)1 for empty string and (byte)3 for the sequence of\n+\t * bytes representing UTF8 encoded string. The sequence starts with LEB128 encoded int for the\n+\t * length of the sequence followed by the sequence bytes.\n+\t *\n+\t * @param utf8Data\n+\t *            the byte array representation of an UTF8 string\n+\t * @return the writer instance for chaining\n+\t *\/\n+\tLEB128Writer writeCompactUTF(byte[] utf8Data);\n+\n+\t\/**\n+\t * Write {@linkplain String} as a sequence of bytes representing UTF8 encoded string at the\n+\t * given offset. The sequence starts with LEB128 encoded int for the length of the sequence\n+\t * followed by the sequence bytes.\n+\t *\n+\t * @param offset\n+\t *            the offset from which to start writing the data\n+\t * @param utf8Data\n+\t *            the byte array representation of an UTF8 string\n+\t * @return the writer position after the data has been written\n+\t *\/\n+\tlong writeCompactUTF(long offset, byte[] utf8Data);\n+\n+\t\/**\n+\t * Write {@linkplain String} in special encoding. The string will translate to (byte)0 for\n+\t * {@literal null} value, (byte)1 for empty string and (byte)3 for the sequence of bytes\n+\t * representing UTF8 encoded string. The sequence starts with LEB128 encoded int for the length\n+\t * of the sequence followed by the sequence bytes.\n+\t *\n+\t * @param data\n+\t *            the data\n+\t * @return the writer instance for chaining\n+\t *\/\n+\tLEB128Writer writeCompactUTF(String data);\n+\n+\t\/**\n+\t * Write {@linkplain String} byte array data in special encoding at the given offset. The string\n+\t * will translate to (byte)0 for {@literal null} value, (byte)1 for empty string and (byte)3 for\n+\t * the sequence of bytes representing UTF8 encoded string. The sequence starts with LEB128\n+\t * encoded int for the length of the sequence followed by the sequence bytes.\n+\t *\n+\t * @param offset\n+\t *            the offset from which to start writing the data\n+\t * @param data\n+\t *            the data\n+\t * @return the writer position after the data has been written\n+\t *\/\n+\tlong writeCompactUTF(long offset, String data);\n+\n+\t\/**\n+\t * Write {@linkplain Short} data in default Java encoding\n+\t *\n+\t * @param data\n+\t *            the data\n+\t * @return the writer instance for chaining\n+\t *\/\n+\tLEB128Writer writeShortRaw(short data);\n+\n+\t\/**\n+\t * Write {@linkplain Short} data in default Java encoding at the given offset\n+\t *\n+\t * @param offset\n+\t *            the offset from which to start writing the data\n+\t * @param data\n+\t *            the data\n+\t * @return the writer position after the data has been written\n+\t *\/\n+\tlong writeShortRaw(long offset, short data);\n+\n+\t\/**\n+\t * Write {@linkplain Integer} data in default Java encoding\n+\t *\n+\t * @param data\n+\t *            the data\n+\t * @return the writer instance for chaining\n+\t *\/\n+\tLEB128Writer writeIntRaw(int data);\n+\n+\t\/**\n+\t * Write {@linkplain Integer} data in default Java encoding at the given offset\n+\t *\n+\t * @param offset\n+\t *            the offset from which to start writing the data\n+\t * @param data\n+\t *            the data\n+\t * @return the writer position after the data has been written\n+\t *\/\n+\tlong writeIntRaw(long offset, int data);\n+\n+\t\/**\n+\t * Write {@linkplain Long} data in default Java encoding\n+\t *\n+\t * @param data\n+\t *            the data\n+\t * @return the writer instance for chaining\n+\t *\/\n+\tLEB128Writer writeLongRaw(long data);\n+\n+\t\/**\n+\t * Write {@linkplain Long} data in default Java encoding at the given offset\n+\t *\n+\t * @param offset\n+\t *            the offset from which to start writing the data\n+\t * @param data\n+\t *            the data\n+\t * @return the writer position after the data has been written\n+\t *\/\n+\tlong writeLongRaw(long offset, long data);\n+\n+\t\/**\n+\t * Transfer the written data to a byte array\n+\t *\n+\t * @return byte array containing the written data\n+\t *\/\n+\tdefault byte[] export() {\n+\t\tfinal byte[][] dataRef = new byte[1][];\n+\t\texport(buffer -> {\n+\t\t\tint limit = buffer.limit();\n+\t\t\tbuffer.flip();\n+\t\t\tint len = buffer.remaining();\n+\t\t\tif (buffer.hasArray()) {\n+\t\t\t\tdataRef[0] = new byte[len];\n+\t\t\t\tSystem.arraycopy(buffer.array(), buffer.arrayOffset() + buffer.position(), dataRef[0], 0, len);\n+\t\t\t\tbuffer.position(buffer.limit());\n+\t\t\t} else {\n+\t\t\t\tdataRef[0] = new byte[len];\n+\t\t\t\tbuffer.get(dataRef[0]);\n+\t\t\t}\n+\t\t\tbuffer.limit(limit);\n+\t\t});\n+\t\treturn dataRef[0];\n+\t}\n+\n+\t\/**\n+\t * Transfer the written data as a {@linkplain ByteBuffer}\n+\t *\n+\t * @param consumer\n+\t *            a {@linkplain ByteBuffer} callback\n+\t *\/\n+\tvoid export(Consumer<ByteBuffer> consumer);\n+\n+\t\/** @return current writer position *\/\n+\tint position();\n+\n+\t\/**\n+\t * @return number of bytes written adjusted by the number of bytes necessary to encode the\n+\t *         length itself\n+\t *\/\n+\tint length();\n+\n+\t\/** @return the maximum number of bytes the writer can process *\/\n+\tint capacity();\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/LEB128Writer.java","additions":436,"deletions":0,"binary":false,"changes":436,"status":"added"},{"patch":"@@ -0,0 +1,395 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import lombok.EqualsAndHashCode;\n+import lombok.NonNull;\n+import lombok.ToString;\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+import org.openjdk.jmc.flightrecorder.writer.api.NamedType;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+\/** JFR type repository class. *\/\n+@ToString\n+@EqualsAndHashCode\n+final class MetadataImpl {\n+\tprivate static final String CLASS_KEY = \"class\";\n+\tprivate static final String FIELD_KEY = \"field\";\n+\tprivate static final String NAME_KEY = \"name\";\n+\tprivate static final String ID_KEY = \"id\";\n+\tprivate static final String VALUE_KEY = \"value\";\n+\tprivate static final String SUPER_TYPE_KEY = \"superType\";\n+\tprivate static final String CONSTANT_POOL_KEY = \"constantPool\";\n+\tprivate static final String SIMPLE_TYPE_KEY = \"simpleType\";\n+\tprivate static final String ROOT_KEY = \"root\";\n+\tprivate static final String METADATA_KEY = \"metadata\";\n+\tprivate static final String TRUE_VALUE = \"true\";\n+\tprivate static final String REGION_KEY = \"region\";\n+\tprivate static final String DIMENSION_KEY = \"dimension\";\n+\tprivate static final String ANNOTATION_KEY = \"annotation\";\n+\tprivate static final String VAL_1_VALUE = \"1\";\n+\n+\tprivate final AtomicLong typeCounter = new AtomicLong(1);\n+\tprivate final ConstantPools constantPools;\n+\tprivate final Map<String, TypeImpl> metadata = new ConcurrentHashMap<>();\n+\tprivate final Map<String, Integer> stringTable = new ConcurrentHashMap<>();\n+\tprivate final Map<Integer, String> reverseStringTable = new ConcurrentSkipListMap<>();\n+\tprivate final Set<ResolvableType> unresolvedTypes = new CopyOnWriteArraySet<>();\n+\n+\tprivate volatile TypesImpl types = null;\n+\n+\tMetadataImpl(ConstantPools constantPools) {\n+\t\tthis.constantPools = constantPools;\n+\t\tfillStrings();\n+\t}\n+\n+\tvoid setTypes(TypesImpl types) {\n+\t\tthis.types = types;\n+\t}\n+\n+\tConstantPools getConstantPools() {\n+\t\treturn constantPools;\n+\t}\n+\n+\t\/** Pre-fill the string constant pool with all used constant strings *\/\n+\tprivate void fillStrings() {\n+\t\tstoreString(VAL_1_VALUE);\n+\t\tstoreString(CLASS_KEY);\n+\t\tstoreString(FIELD_KEY);\n+\t\tstoreString(NAME_KEY);\n+\t\tstoreString(ID_KEY);\n+\t\tstoreString(VALUE_KEY);\n+\t\tstoreString(SUPER_TYPE_KEY);\n+\t\tstoreString(CONSTANT_POOL_KEY);\n+\t\tstoreString(SIMPLE_TYPE_KEY);\n+\t\tstoreString(ROOT_KEY);\n+\t\tstoreString(METADATA_KEY);\n+\t\tstoreString(TRUE_VALUE);\n+\t\tstoreString(REGION_KEY);\n+\t\tstoreString(DIMENSION_KEY);\n+\t\tstoreString(ANNOTATION_KEY);\n+\t}\n+\n+\t\/**\n+\t * Register a built-in type\n+\t *\n+\t * @param typeDef\n+\t *            a {@link org.openjdk.jmc.flightrecorder.writer.api.Types.Builtin built-in} type\n+\t *\/\n+\tpublic void registerBuiltin(Types.Builtin typeDef) {\n+\t\tTypeImpl type = metadata.computeIfAbsent(typeDef.getTypeName(), this::createBuiltinType);\n+\t\tstoreTypeStrings(type);\n+\t}\n+\n+\t\/**\n+\t * Register a {@linkplain Type} instance\n+\t *\n+\t * @param typeName\n+\t *            the type name\n+\t * @param supertype\n+\t *            super type; may be {@literal null}\n+\t * @param typeStructureProvider\n+\t *            type structure provider to be called lazily when a new type is created\n+\t * @return registered type - either a new type or or a previously registered with the same name\n+\t *\/\n+\tTypeImpl registerType(String typeName, String supertype, Supplier<TypeStructureImpl> typeStructureProvider) {\n+\t\treturn registerType(typeName, supertype,\n+\t\t\t\ttypeStructureProvider != null ? typeStructureProvider.get() : TypeStructureImpl.EMPTY);\n+\t}\n+\n+\tTypeImpl registerType(String typeName, String supertype, TypeStructureImpl compositeType) {\n+\t\treturn metadata.computeIfAbsent(typeName, name -> {\n+\t\t\tTypeImpl t = createCustomType(name, supertype, compositeType);\n+\t\t\tstoreTypeStrings(t);\n+\t\t\treturn t;\n+\t\t});\n+\t}\n+\n+\t\/**\n+\t * Retrieve a type with the given name.\n+\t *\n+\t * @param name\n+\t *            the type name\n+\t * @param asResolvable\n+\t *            if the type is not found to be registered should a {@link ResolvableType\n+\t *            resolvable} wrapper be returned instead?\n+\t * @return the type of the given name\n+\t *\/\n+\tTypeImpl getType(String name, boolean asResolvable) {\n+\t\tTypeImpl found = metadata.get(name);\n+\t\tif (found == null) {\n+\t\t\tif (asResolvable) {\n+\t\t\t\tfound = new ResolvableType(name, this);\n+\t\t\t}\n+\t\t}\n+\t\treturn found;\n+\t}\n+\n+\t\/**\n+\t * Create a new built-in type of the given name. !Package visibility only because of unit\n+\t * testing!\n+\t *\n+\t * @param name\n+\t *            the type name\n+\t * @return new built-in type\n+\t * @throws IllegalArgumentException\n+\t *             if a the type name is not representing a built-in\n+\t *\/\n+\tTypeImpl createBuiltinType(String name) {\n+\t\tif (!Types.Builtin.hasType(name)) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\tTypes.Builtin type = Types.Builtin.ofName(name);\n+\t\treturn new BuiltinType(typeCounter.getAndIncrement(), type, type == Types.Builtin.STRING ? constantPools : null,\n+\t\t\t\ttypes);\n+\t}\n+\n+\t\/**\n+\t * Create a new custom type of the given name and structure. !Package visibility only because of\n+\t * unit testing!\n+\t *\n+\t * @param name\n+\t *            the type name\n+\t * @param supertype\n+\t *            the super type name - may be {@literal null}\n+\t * @param structure\n+\t *            the type structure - fields, annotations\n+\t * @return new custom type\n+\t * @throws IllegalArgumentException\n+\t *             if the name belongs to one of the built-in types\n+\t *\/\n+\tTypeImpl createCustomType(String name, String supertype, TypeStructureImpl structure) {\n+\t\tif (Types.Builtin.hasType(name)) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\treturn new CompositeTypeImpl(typeCounter.getAndIncrement(), name, supertype, structure,\n+\t\t\t\t\/\/ TODO hack for event types not to go to constant pool\n+\t\t\t\t!\"jdk.jfr.Event\".equals(supertype) ? constantPools : null, types);\n+\t}\n+\n+\t\/**\n+\t * Retrieve a type from the metadata storage\n+\t *\n+\t * @param type\n+\t *            the (enumerated) type to retrieve from the metadata storage\n+\t * @param asResolvable\n+\t *            should a {@linkplain ResolvableType} wrapper be returned if the requested type is\n+\t *            not present in the metadata storage yet?\n+\t * @return the specified {@linkplain Type} instance or {@linkplain null} if that type is not in\n+\t *         the metadata storage yet and 'asResolvable' was {@literal false}\n+\t *\/\n+\tTypeImpl getType(NamedType type, boolean asResolvable) {\n+\t\treturn getType(type.getTypeName(), asResolvable);\n+\t}\n+\n+\t\/**\n+\t * Add a new unresolved {@linkplain ResolvableType} instance.\n+\t *\n+\t * @param type\n+\t *            unresolved type\n+\t *\/\n+\tvoid addUnresolved(ResolvableType type) {\n+\t\tunresolvedTypes.add(type);\n+\t}\n+\n+\t\/**\n+\t * Resolve all dangling unresolved {@link ResolvableType resolvable types}. This needs to be\n+\t * done if some of the type definitions are using forward references to not yet registered\n+\t * types.\n+\t *\/\n+\tvoid resolveTypes() {\n+\t\tunresolvedTypes.removeIf(ResolvableType::resolve);\n+\t}\n+\n+\tprivate void storeTypeStrings(TypeImpl type) {\n+\t\tstoreString(type.getTypeName());\n+\t\tif (type.getSupertype() != null) {\n+\t\t\tstoreString(type.getSupertype());\n+\t\t}\n+\t\tstoreString(String.valueOf(type.getId()));\n+\t\tfor (TypedFieldImpl field : type.getFields()) {\n+\t\t\tstoreString(field.getName());\n+\t\t\tstoreAnnotationStrings(field.getAnnotations());\n+\t\t}\n+\t\tstoreAnnotationStrings(type.getAnnotations());\n+\t}\n+\n+\tprivate void storeAnnotationStrings(List<Annotation> annotations) {\n+\t\tfor (Annotation annotation : annotations) {\n+\t\t\tif (annotation.getValue() != null) {\n+\t\t\t\tstoreString(annotation.getValue());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void storeString(String value) {\n+\t\tstringTable.computeIfAbsent(value, k -> {\n+\t\t\tint pointer = stringTable.size();\n+\t\t\treverseStringTable.put(pointer, k);\n+\t\t\treturn pointer;\n+\t\t});\n+\t}\n+\n+\tint stringIndex(@NonNull String value) {\n+\t\treturn stringTable.get(value);\n+\t}\n+\n+\tvoid writeMetaEvent(LEB128Writer writer, long startTs, long duration) {\n+\t\tLEB128Writer metaWriter = LEB128Writer.getInstance();\n+\t\twriteMetadataHeader(startTs, duration, metaWriter);\n+\n+\t\twriteStringConstants(metaWriter);\n+\t\twriteTypes(metaWriter);\n+\t\twriteRegion(metaWriter);\n+\n+\t\twriteMetaEventWithSize(metaWriter, writer);\n+\t}\n+\n+\tprivate void writeMetaEventWithSize(LEB128Writer metaWriter, LEB128Writer writer) {\n+\t\tint len = metaWriter.length();\n+\t\twriter.writeInt(len);\n+\t\twriter.writeBytes(metaWriter.export());\n+\t}\n+\n+\tprivate void writeRegion(LEB128Writer metaWriter) {\n+\t\tmetaWriter.writeInt(stringIndex(REGION_KEY)).writeInt(0) \/\/ 0 attributes\n+\t\t\t\t.writeInt(0); \/\/ 0 elements\n+\t}\n+\n+\tprivate void writeTypes(LEB128Writer metaWriter) {\n+\t\tmetaWriter.writeInt(stringIndex(ROOT_KEY)).writeInt(0) \/\/ 0 attributes\n+\t\t\t\t.writeInt(2) \/\/ 1 element\n+\t\t\t\t.writeInt(stringIndex(METADATA_KEY)).writeInt(0) \/\/ 0 attributes\n+\t\t\t\t.writeInt(metadata.size()); \/\/ metadata.size() elements\n+\t\tfor (TypeImpl type : metadata.values()) {\n+\t\t\twriteType(metaWriter, type);\n+\t\t}\n+\t}\n+\n+\tprivate void writeStringConstants(LEB128Writer metaWriter) {\n+\t\tfor (String text : reverseStringTable.values()) {\n+\t\t\tmetaWriter.writeCompactUTF(text);\n+\t\t}\n+\t}\n+\n+\tprivate void writeMetadataHeader(long startTs, long duration, LEB128Writer metaWriter) {\n+\t\tmetaWriter.writeLong(0L) \/\/ metadata event id\n+\t\t\t\t.writeLong(startTs).writeLong(duration).writeLong(0L).writeInt(stringTable.size());\n+\t}\n+\n+\tprivate void writeType(LEB128Writer writer, TypeImpl type) {\n+\t\tint attributes = 2;\n+\t\tif (type.getSupertype() != null) {\n+\t\t\tattributes++;\n+\t\t}\n+\t\tif (type.isSimple()) {\n+\t\t\tattributes++;\n+\t\t}\n+\t\twriter.writeInt(stringIndex(CLASS_KEY)).writeInt(attributes).writeInt(stringIndex(NAME_KEY))\n+\t\t\t\t.writeInt(stringIndex(type.getTypeName())).writeInt(stringIndex(ID_KEY))\n+\t\t\t\t.writeInt(stringIndex(String.valueOf(type.getId())));\n+\t\tif (type.getSupertype() != null) {\n+\t\t\twriter.writeInt(stringIndex(SUPER_TYPE_KEY)).writeInt(stringIndex(type.getSupertype()));\n+\t\t}\n+\t\tif (type.isSimple()) {\n+\t\t\twriter.writeInt(stringIndex(SIMPLE_TYPE_KEY)).writeInt(stringIndex(TRUE_VALUE));\n+\t\t}\n+\t\twriter.writeInt(type.getFields().size() + type.getAnnotations().size());\n+\t\twriteTypeFields(writer, type);\n+\t\twriteTypeAnnotations(writer, type);\n+\t}\n+\n+\tprivate void writeTypeFields(LEB128Writer writer, TypeImpl type) {\n+\t\tfor (TypedFieldImpl field : type.getFields()) {\n+\t\t\twriteField(writer, field);\n+\t\t}\n+\t}\n+\n+\tprivate void writeTypeAnnotations(LEB128Writer writer, TypeImpl type) {\n+\t\tfor (Annotation annotation : type.getAnnotations()) {\n+\t\t\twriteAnnotation(writer, annotation);\n+\t\t}\n+\t}\n+\n+\tprivate void writeField(LEB128Writer writer, TypedFieldImpl field) {\n+\t\twriter.writeInt(stringIndex(FIELD_KEY));\n+\t\tint attrCount = 2;\n+\n+\t\t\/\/ java.lang.String is special - it is using constant pool but is not marked as such\n+\t\tboolean withConstantPool = !field.getType().isSame(Types.Builtin.STRING) && field.getType().hasConstantPool();\n+\t\tif (withConstantPool) {\n+\t\t\tattrCount++;\n+\t\t}\n+\t\tif (field.isArray()) {\n+\t\t\tattrCount++;\n+\t\t}\n+\t\twriter.writeInt(attrCount).writeInt(stringIndex(NAME_KEY)).writeInt(stringIndex(field.getName()))\n+\t\t\t\t.writeInt(stringIndex(CLASS_KEY)).writeInt(stringIndex(String.valueOf(field.getType().getId())));\n+\t\tif (field.isArray()) {\n+\t\t\twriter.writeInt(stringIndex(DIMENSION_KEY)).writeInt(stringIndex(VAL_1_VALUE));\n+\t\t}\n+\t\tif (withConstantPool) {\n+\t\t\twriter.writeInt(stringIndex(CONSTANT_POOL_KEY)).writeInt(stringIndex(TRUE_VALUE));\n+\t\t}\n+\t\twriteFieldAnnotations(writer, field);\n+\t}\n+\n+\tprivate void writeFieldAnnotations(LEB128Writer writer, TypedFieldImpl field) {\n+\t\twriter.writeInt(field.getAnnotations().size()); \/\/ annotations are the only sub-elements\n+\t\tfor (Annotation annotation : field.getAnnotations()) {\n+\t\t\twriteAnnotation(writer, annotation);\n+\t\t}\n+\t}\n+\n+\tprivate void writeAnnotation(LEB128Writer writer, Annotation annotation) {\n+\t\twriter.writeInt(stringIndex(ANNOTATION_KEY));\n+\n+\t\twriter.writeInt(annotation.getValue() != null ? 2 : 1) \/\/ number of attributes\n+\t\t\t\t.writeInt(stringIndex(CLASS_KEY)).writeInt(stringIndex(String.valueOf(annotation.getType().getId())));\n+\t\tif (annotation.getValue() != null) {\n+\t\t\twriter.writeInt(stringIndex(VALUE_KEY)).writeInt(stringIndex(annotation.getValue()));\n+\t\t}\n+\t\twriter.writeInt(0); \/\/ no sub-elements\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/MetadataImpl.java","additions":395,"deletions":0,"binary":false,"changes":395,"status":"added"},{"patch":"@@ -0,0 +1,302 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypeStructure;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypeStructureBuilder;\n+import org.openjdk.jmc.flightrecorder.writer.api.Recording;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValue;\n+\n+import java.io.OutputStream;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.BlockingDeque;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingDeque;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * The main entry point to JFR recording functionality. Allows to define custom types and initiate\n+ * {@link Chunk chunks} for writing user events.\n+ *\/\n+public final class RecordingImpl extends Recording {\n+\tprivate static final byte[] MAGIC = new byte[] {'F', 'L', 'R', '\\0'};\n+\tprivate static final short MAJOR_VERSION = 2;\n+\tprivate static final short MINOR_VERSION = 0;\n+\n+\tprivate static final long SIZE_OFFSET = 8;\n+\tprivate static final long CONSTANT_OFFSET_OFFSET = 16;\n+\tprivate static final long METADATA_OFFSET_OFFSET = 24;\n+\tprivate static final long DURATION_NANOS_OFFSET = 40;\n+\n+\tprivate final Set<Chunk> activeChunks = new CopyOnWriteArraySet<>();\n+\tprivate final LEB128Writer globalWriter = LEB128Writer.getInstance();\n+\tprivate final InheritableThreadLocal<WeakReference<Chunk>> threadChunk = new InheritableThreadLocal<WeakReference<Chunk>>() {\n+\t\t@Override\n+\t\tprotected WeakReference<Chunk> initialValue() {\n+\t\t\tChunk chunk = new Chunk();\n+\t\t\tactiveChunks.add(chunk);\n+\t\t\t\/*\n+\t\t\t * Use weak reference to minimize the damage caused by thread-local leaks. The chunk\n+\t\t\t * value is strongly held by activeChunks set and as such will not be released until it\n+\t\t\t * is removed from that set eg. in the close() method.\n+\t\t\t *\/\n+\t\t\treturn new WeakReference<>(chunk);\n+\t\t}\n+\t};\n+\n+\tprivate final long startTicks;\n+\tprivate final long startNanos;\n+\n+\tprivate final OutputStream outputStream;\n+\n+\tprivate final AtomicBoolean closed = new AtomicBoolean(false);\n+\n+\tprivate final BlockingDeque<LEB128Writer> chunkDataQueue = new LinkedBlockingDeque<>();\n+\tprivate final ExecutorService chunkDataMergingService = Executors.newSingleThreadExecutor();\n+\n+\tprivate final ConstantPools constantPools = new ConstantPools();\n+\tprivate final MetadataImpl metadata = new MetadataImpl(constantPools);\n+\tprivate final TypesImpl types = new TypesImpl(metadata);\n+\n+\tpublic RecordingImpl(OutputStream output) {\n+\t\tthis.startTicks = System.nanoTime();\n+\t\tthis.startNanos = System.currentTimeMillis() * 1_000_000L;\n+\t\tthis.outputStream = output;\n+\t\twriteFileHeader();\n+\n+\t\tchunkDataMergingService.submit(() -> {\n+\t\t\ttry {\n+\t\t\t\twhile (!chunkDataMergingService.isShutdown()) {\n+\t\t\t\t\tLEB128Writer writer = chunkDataQueue.poll(500, TimeUnit.MILLISECONDS);\n+\t\t\t\t\tif (writer != null) {\n+\t\t\t\t\t\tList<LEB128Writer> writers = new ArrayList<>();\n+\t\t\t\t\t\twriters.add(writer);\n+\t\t\t\t\t\tchunkDataQueue.drainTo(writers);\n+\n+\t\t\t\t\t\tfor (LEB128Writer w : writers) {\n+\t\t\t\t\t\t\tglobalWriter.writeBytes(w.export());\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t} catch (InterruptedException e) {\n+\t\t\t\tThread.currentThread().interrupt();\n+\t\t\t}\n+\t\t});\n+\t}\n+\n+\t@Override\n+\tpublic RecordingImpl rotateChunk() {\n+\t\tChunk chunk = getChunk();\n+\t\tactiveChunks.remove(chunk);\n+\t\tthreadChunk.remove();\n+\n+\t\tchunk.finish(writer -> {\n+\t\t\ttry {\n+\t\t\t\tchunkDataQueue.put(writer);\n+\t\t\t} catch (InterruptedException ignored) {\n+\t\t\t\tThread.currentThread().interrupt();\n+\t\t\t}\n+\t\t});\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic void close() throws Exception {\n+\t\tif (closed.compareAndSet(false, true)) {\n+\t\t\ttry {\n+\t\t\t\t\/*\n+\t\t\t\t * All active chunks are stable here - no new data will be added there so we can get\n+\t\t\t\t * away with slightly racy code ....\n+\t\t\t\t *\/\n+\t\t\t\tfor (Chunk chunk : activeChunks) {\n+\t\t\t\t\tchunk.finish(writer -> {\n+\t\t\t\t\t\ttry {\n+\t\t\t\t\t\t\tchunkDataQueue.put(writer);\n+\t\t\t\t\t\t} catch (InterruptedException ignored) {\n+\t\t\t\t\t\t\tThread.currentThread().interrupt();\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});\n+\t\t\t\t}\n+\t\t\t\tactiveChunks.clear();\n+\n+\t\t\t\tchunkDataMergingService.shutdown();\n+\t\t\t\tif (!chunkDataMergingService.awaitTermination(5, TimeUnit.SECONDS)) {\n+\t\t\t\t\tthrow new RuntimeException(\"Unable to flush dangling JFR chunks\");\n+\t\t\t\t}\n+\t\t\t\tfinalizeRecording();\n+\n+\t\t\t\toutputStream.write(globalWriter.export());\n+\t\t\t} finally {\n+\t\t\t\toutputStream.close();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate Chunk getChunk() {\n+\t\tif (closed.get()) {\n+\t\t\tthrow new IllegalStateException(\"Recording is already closed. Can not add more data.\");\n+\t\t}\n+\t\treturn threadChunk.get().get();\n+\t}\n+\n+\t@Override\n+\tpublic RecordingImpl writeEvent(TypedValue event) {\n+\t\tgetChunk().writeEvent((TypedValueImpl) event);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl registerEventType(String name) {\n+\t\treturn registerEventType(name, builder -> {\n+\t\t});\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl registerEventType(String name, Consumer<TypeStructureBuilder> builderCallback) {\n+\t\tif (name == null || builderCallback == null) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\treturn registerType(name, \"jdk.jfr.Event\", builder -> {\n+\t\t\tbuilder.addField(\"stackTrace\", TypesImpl.JDK.STACK_TRACE).addField(\"eventThread\", TypesImpl.JDK.THREAD)\n+\t\t\t\t\t.addField(\"startTime\", TypesImpl.Builtin.LONG,\n+\t\t\t\t\t\t\tfield -> field.addAnnotation(TypesImpl.JDK.ANNOTATION_TIMESTAMP, \"TICKS\"));\n+\t\t\tbuilderCallback.accept(builder);\n+\t\t});\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl registerAnnotationType(String name) {\n+\t\treturn registerAnnotationType(name, builder -> {\n+\t\t});\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl registerAnnotationType(String name, Consumer<TypeStructureBuilder> builderCallback) {\n+\t\treturn registerType(name, Annotation.ANNOTATION_SUPER_TYPE_NAME, builderCallback);\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl registerType(String name, Consumer<TypeStructureBuilder> builderCallback) {\n+\t\treturn registerType(name, null, builderCallback);\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl registerType(String name, String supertype, Consumer<TypeStructureBuilder> builderCallback) {\n+\t\tif (builderCallback == null || name == null) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\treturn types.getOrAdd(name, supertype, builderCallback);\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl getType(TypesImpl.JDK type) {\n+\t\tif (type == null) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\treturn getType(type.getTypeName());\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl getType(String typeName) {\n+\t\tif (typeName == null) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\tTypeImpl type = types.getType(typeName);\n+\t\tif (type == null) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\treturn type;\n+\t}\n+\n+\t@Override\n+\tpublic TypesImpl getTypes() {\n+\t\treturn types;\n+\t}\n+\n+\tprivate void writeFileHeader() {\n+\t\tglobalWriter.writeBytes(MAGIC).writeShortRaw(MAJOR_VERSION).writeShortRaw(MINOR_VERSION).writeLongRaw(0L) \/\/ size placeholder\n+\t\t\t\t.writeLongRaw(0L) \/\/ CP event offset\n+\t\t\t\t.writeLongRaw(0L) \/\/ meta event offset\n+\t\t\t\t.writeLongRaw(startNanos) \/\/ start timestamp\n+\t\t\t\t.writeLongRaw(0L) \/\/ duration placeholder\n+\t\t\t\t.writeLongRaw(startTicks).writeLongRaw(1_000_000_000L) \/\/ 1 tick = 1 ns\n+\t\t\t\t.writeIntRaw(1); \/\/ use compressed integers\n+\t}\n+\n+\tprivate void finalizeRecording() {\n+\t\tlong duration = System.nanoTime() - startTicks;\n+\t\ttypes.resolveAll();\n+\n+\t\tlong checkpointOffset = globalWriter.position();\n+\t\twriteCheckpointEvent();\n+\t\tlong metadataOffset = globalWriter.position();\n+\t\twriteMetadataEvent(duration);\n+\n+\t\tglobalWriter.writeLongRaw(DURATION_NANOS_OFFSET, duration);\n+\t\tglobalWriter.writeLongRaw(SIZE_OFFSET, globalWriter.position());\n+\t\tglobalWriter.writeLongRaw(CONSTANT_OFFSET_OFFSET, checkpointOffset);\n+\t\tglobalWriter.writeLongRaw(METADATA_OFFSET_OFFSET, metadataOffset);\n+\t}\n+\n+\tprivate void writeCheckpointEvent() {\n+\t\tLEB128Writer cpWriter = LEB128Writer.getInstance();\n+\n+\t\tcpWriter.writeLong(1L) \/\/ checkpoint event ID\n+\t\t\t\t.writeLong(startNanos) \/\/ start timestamp\n+\t\t\t\t.writeLong(System.nanoTime() - startTicks) \/\/ duration till now\n+\t\t\t\t.writeLong(0L) \/\/ fake delta-to-next\n+\t\t\t\t.writeInt(1) \/\/ all checkpoints are flush for now\n+\t\t\t\t.writeInt(metadata.getConstantPools().size()); \/\/ start writing constant pools array\n+\n+\t\tfor (ConstantPool cp : metadata.getConstantPools()) {\n+\t\t\tcp.writeTo(cpWriter);\n+\t\t}\n+\n+\t\tglobalWriter.writeInt(cpWriter.length()); \/\/ write event size\n+\t\tglobalWriter.writeBytes(cpWriter.export());\n+\t}\n+\n+\tprivate void writeMetadataEvent(long duration) {\n+\t\tmetadata.writeMetaEvent(globalWriter, startTicks, duration);\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/RecordingImpl.java","additions":302,"deletions":0,"binary":false,"changes":302,"status":"added"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import lombok.ToString;\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+import org.openjdk.jmc.flightrecorder.writer.api.NamedType;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValueBuilder;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedFieldBuilder;\n+import org.openjdk.jmc.flightrecorder.writer.util.NonZeroHashCode;\n+\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+@ToString\n+public final class ResolvableType implements TypeImpl {\n+\tprivate final String typeName;\n+\tprivate final MetadataImpl metadata;\n+\n+\tprivate volatile TypeImpl delegate;\n+\n+\tResolvableType(String typeName, MetadataImpl metadata) {\n+\t\tthis.typeName = typeName;\n+\t\tthis.metadata = metadata;\n+\t\t\/\/ self-register in metadata as 'unresolved'\n+\t\tthis.metadata.addUnresolved(this);\n+\t}\n+\n+\t@Override\n+\tpublic boolean isResolved() {\n+\t\treturn delegate != null;\n+\t}\n+\n+\tprivate void checkResolved() {\n+\t\tif (delegate == null) {\n+\t\t\tthrow new IllegalStateException();\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic long getId() {\n+\t\tcheckResolved();\n+\t\treturn delegate.getId();\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasConstantPool() {\n+\t\tcheckResolved();\n+\t\treturn delegate.hasConstantPool();\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(String value) {\n+\t\tcheckResolved();\n+\t\treturn delegate.asValue(value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(byte value) {\n+\t\tcheckResolved();\n+\t\treturn delegate.asValue(value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(char value) {\n+\t\tcheckResolved();\n+\t\treturn delegate.asValue(value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(short value) {\n+\t\tcheckResolved();\n+\t\treturn delegate.asValue(value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(int value) {\n+\t\tcheckResolved();\n+\t\treturn delegate.asValue(value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(long value) {\n+\t\tcheckResolved();\n+\t\treturn delegate.asValue(value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(float value) {\n+\t\tcheckResolved();\n+\t\treturn delegate.asValue(value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(double value) {\n+\t\tcheckResolved();\n+\t\treturn delegate.asValue(value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(boolean value) {\n+\t\tcheckResolved();\n+\t\treturn delegate.asValue(value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(Consumer<TypedValueBuilder> builderCallback) {\n+\t\tcheckResolved();\n+\t\treturn delegate.asValue(builderCallback);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(Object value) {\n+\t\tcheckResolved();\n+\t\treturn delegate.asValue(value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl nullValue() {\n+\t\tcheckResolved();\n+\t\treturn delegate.nullValue();\n+\t}\n+\n+\t@Override\n+\tpublic boolean isBuiltin() {\n+\t\tcheckResolved();\n+\t\treturn delegate.isBuiltin();\n+\t}\n+\n+\t@Override\n+\tpublic boolean isSimple() {\n+\t\tcheckResolved();\n+\t\treturn delegate.isSimple();\n+\t}\n+\n+\t@Override\n+\tpublic String getSupertype() {\n+\t\tcheckResolved();\n+\t\treturn delegate.getSupertype();\n+\t}\n+\n+\t@Override\n+\tpublic List<TypedFieldImpl> getFields() {\n+\t\tcheckResolved();\n+\t\treturn delegate.getFields();\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldImpl getField(String name) {\n+\t\tcheckResolved();\n+\t\treturn delegate.getField(name);\n+\t}\n+\n+\t@Override\n+\tpublic List<Annotation> getAnnotations() {\n+\t\tcheckResolved();\n+\t\treturn delegate.getAnnotations();\n+\t}\n+\n+\t@Override\n+\tpublic boolean canAccept(Object value) {\n+\t\tcheckResolved();\n+\t\treturn delegate.canAccept(value);\n+\t}\n+\n+\t@Override\n+\tpublic String getTypeName() {\n+\t\treturn typeName;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isSame(NamedType other) {\n+\t\tcheckResolved();\n+\t\treturn delegate.isSame(other);\n+\t}\n+\n+\t@Override\n+\tpublic boolean isUsedBy(Type other) {\n+\t\tcheckResolved();\n+\t\treturn delegate.isUsedBy(other);\n+\t}\n+\n+\t@Override\n+\tpublic TypesImpl getTypes() {\n+\t\treturn null;\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilderImpl valueBuilder() {\n+\t\tcheckResolved();\n+\t\treturn delegate.valueBuilder();\n+\t}\n+\n+\tboolean resolve() {\n+\t\tTypeImpl resolved = metadata.getType(typeName, false);\n+\t\tif (resolved instanceof BaseType) {\n+\t\t\tdelegate = resolved;\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tResolvableType that = (ResolvableType) o;\n+\t\treturn typeName.equals(that.typeName);\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\treturn NonZeroHashCode.hash(typeName);\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/ResolvableType.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+\n+import java.util.List;\n+\n+\/**\n+ * A place-holder for fields of the same type as they are defined in. Keeping the default values\n+ * intentionally 'wrong' in order for things to break soon if this type is not replaced by the\n+ * concrete type counterpart correctly.\n+ *\/\n+final class SelfType extends BaseType {\n+\tstatic final SelfType INSTANCE = new SelfType();\n+\n+\tprivate SelfType() {\n+\t\tsuper(Long.MIN_VALUE, \"\", null, null);\n+\t}\n+\n+\t@Override\n+\tpublic boolean isBuiltin() {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic List<TypedFieldImpl> getFields() {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldImpl getField(String name) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic List<Annotation> getAnnotations() {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic boolean canAccept(Object value) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/SelfType.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import lombok.NonNull;\n+import lombok.ToString;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedFieldValue;\n+import org.openjdk.jmc.flightrecorder.writer.util.NonZeroHashCode;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+\n+final class SingleFieldMap implements Map<String, TypedFieldValue> {\n+\tprivate int hashCode = 0;\n+\tprivate final ImmutableMapEntry<String, TypedFieldValue> entry;\n+\n+\tSingleFieldMap(@NonNull String name, @NonNull TypedFieldValue value) {\n+\t\tthis.entry = new ImmutableMapEntry<>(name, value);\n+\t}\n+\n+\t@Override\n+\tpublic int size() {\n+\t\treturn 1;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isEmpty() {\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tpublic boolean containsKey(Object o) {\n+\t\treturn entry.getKey().equals(o);\n+\t}\n+\n+\t@Override\n+\tpublic boolean containsValue(Object o) {\n+\t\treturn entry.getValue().equals(o);\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldValue get(Object o) {\n+\t\treturn entry.getKey().equals(o) ? entry.getValue() : null;\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldValue put(String s, TypedFieldValue typedFieldValue) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldValue remove(Object o) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic void putAll(Map<? extends String, ? extends TypedFieldValue> map) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic void clear() {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic Set<String> keySet() {\n+\t\treturn Collections.singleton(entry.getKey());\n+\t}\n+\n+\t@Override\n+\tpublic Collection<TypedFieldValue> values() {\n+\t\treturn Collections.singleton(entry.getValue());\n+\t}\n+\n+\t@Override\n+\tpublic Set<Entry<String, TypedFieldValue>> entrySet() {\n+\t\treturn Collections.singleton(entry);\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tSingleFieldMap that = (SingleFieldMap) o;\n+\t\treturn entry.equals(that.entry);\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tif (hashCode == 0) {\n+\t\t\thashCode = NonZeroHashCode.hash(entry);\n+\t\t}\n+\t\treturn hashCode;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"SingleFieldMap{\" + entry.getKey() + \"=\" + entry.getValue() + '}';\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/SingleFieldMap.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValueBuilder;\n+\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+public interface TypeImpl extends Type {\n+\t@Override\n+\tList<TypedFieldImpl> getFields();\n+\n+\t@Override\n+\tTypedFieldImpl getField(String name);\n+\n+\tTypesImpl getTypes();\n+\n+\tTypedValueImpl nullValue();\n+\n+\t@Override\n+\tTypedValueImpl asValue(String value);\n+\n+\t@Override\n+\tTypedValueImpl asValue(byte value);\n+\n+\t@Override\n+\tTypedValueImpl asValue(char value);\n+\n+\t@Override\n+\tTypedValueImpl asValue(short value);\n+\n+\t@Override\n+\tTypedValueImpl asValue(int value);\n+\n+\t@Override\n+\tTypedValueImpl asValue(long value);\n+\n+\t@Override\n+\tTypedValueImpl asValue(float value);\n+\n+\t@Override\n+\tTypedValueImpl asValue(double value);\n+\n+\t@Override\n+\tTypedValueImpl asValue(boolean value);\n+\n+\t@Override\n+\tTypedValueImpl asValue(Consumer<TypedValueBuilder> builderCallback);\n+\n+\t@Override\n+\tTypedValueImpl asValue(Object value);\n+\n+\tdefault TypedValueBuilderImpl valueBuilder() {\n+\t\treturn new TypedValueBuilderImpl(this);\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypeImpl.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypeStructure;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypeStructureBuilder;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedField;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedFieldBuilder;\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+final class TypeStructureBuilderImpl implements TypeStructureBuilder {\n+\tprivate final TypesImpl types;\n+\tprivate final List<TypedFieldImpl> fieldList = new ArrayList<>();\n+\tprivate final List<Annotation> annotations = new ArrayList<>();\n+\n+\tTypeStructureBuilderImpl(TypesImpl types) {\n+\t\tthis.types = types;\n+\t}\n+\n+\t@Override\n+\tpublic TypeStructureBuilderImpl addField(String name, TypesImpl.Predefined type) {\n+\t\treturn addField(name, type, null);\n+\t}\n+\n+\t@Override\n+\tpublic TypeStructureBuilderImpl addField(\n+\t\tString name, Types.Predefined type, Consumer<TypedFieldBuilder> fieldCallback) {\n+\t\treturn addField(name, types.getType(type), fieldCallback);\n+\t}\n+\n+\t@Override\n+\tpublic TypeStructureBuilderImpl addField(String name, Type type) {\n+\t\treturn addField(name, type, null);\n+\t}\n+\n+\t@Override\n+\tpublic TypeStructureBuilderImpl addField(String name, Type type, Consumer<TypedFieldBuilder> fieldCallback) {\n+\t\tTypedFieldBuilderImpl annotationsBuilder = new TypedFieldBuilderImpl(name, (TypeImpl) type, types);\n+\t\tif (fieldCallback != null) {\n+\t\t\tfieldCallback.accept(annotationsBuilder);\n+\t\t}\n+\t\tfieldList.add(annotationsBuilder.build());\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypeStructureBuilder addField(TypedField field) {\n+\t\tfieldList.add((TypedFieldImpl) field);\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypeStructureBuilder addFields(TypedField field1, TypedField field2, TypedField ... fields) {\n+\t\tfieldList.add((TypedFieldImpl) field1);\n+\t\tfieldList.add((TypedFieldImpl) field2);\n+\t\tfor (TypedField field : fields) {\n+\t\t\tfieldList.add((TypedFieldImpl) field);\n+\t\t}\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypeStructureBuilderImpl addAnnotation(Type type) {\n+\t\treturn addAnnotation(type, null);\n+\t}\n+\n+\t@Override\n+\tpublic TypeStructureBuilderImpl addAnnotation(Type type, String value) {\n+\t\tannotations.add(new Annotation(type, value));\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic Type selfType() {\n+\t\treturn SelfType.INSTANCE;\n+\t}\n+\n+\t@Override\n+\tpublic TypeStructure build() {\n+\t\treturn new TypeStructureImpl(fieldList, annotations);\n+\t}\n+\n+\tpublic Type registerAs(String name, String supertype) {\n+\t\treturn types.getOrAdd(name, supertype, build());\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypeStructureBuilderImpl.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypeStructure;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedField;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+\/** A structure-like holder class for the type's fields and annotations *\/\n+final class TypeStructureImpl implements TypeStructure {\n+\tstatic final TypeStructureImpl EMPTY = new TypeStructureImpl(Collections.emptyList(), Collections.emptyList());\n+\n+\tfinal List<TypedFieldImpl> fields;\n+\tfinal List<Annotation> annotations;\n+\n+\tTypeStructureImpl(List<TypedFieldImpl> fields, List<Annotation> annotations) {\n+\t\tthis.fields = fields;\n+\t\tthis.annotations = annotations;\n+\t}\n+\n+\t@Override\n+\tpublic List<? extends TypedField> getFields() {\n+\t\treturn fields;\n+\t}\n+\n+\t@Override\n+\tpublic List<Annotation> getAnnotations() {\n+\t\treturn annotations;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypeStructureImpl.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedFieldBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+final class TypedFieldBuilderImpl implements TypedFieldBuilder {\n+\tprivate final TypesImpl types;\n+\tprivate final List<Annotation> annotations = new ArrayList<>();\n+\tprivate final TypeImpl type;\n+\tprivate final String name;\n+\tprivate boolean asArray;\n+\n+\tTypedFieldBuilderImpl(String name, TypeImpl type, TypesImpl types) {\n+\t\tthis.type = type;\n+\t\tthis.name = name;\n+\t\tthis.types = types;\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldBuilderImpl addAnnotation(Type type) {\n+\t\treturn addAnnotation(type, null);\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldBuilderImpl addAnnotation(Type type, String value) {\n+\t\tannotations.add(new Annotation(type, value));\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldBuilderImpl addAnnotation(TypesImpl.Predefined type) {\n+\t\treturn addAnnotation(types.getType(type));\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldBuilderImpl addAnnotation(TypesImpl.Predefined type, String value) {\n+\t\treturn addAnnotation(types.getType(type), value);\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldBuilderImpl asArray() {\n+\t\tasArray = true;\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldImpl build() {\n+\t\treturn new TypedFieldImpl(type, name, asArray, annotations);\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypedFieldBuilderImpl.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import lombok.ToString;\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+import org.openjdk.jmc.flightrecorder.writer.util.NonZeroHashCode;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+\/** A representation of a typed field with a name *\/\n+@ToString\n+public final class TypedFieldImpl implements org.openjdk.jmc.flightrecorder.writer.api.TypedField {\n+\tprivate int hashCode = 0;\n+\n+\tprivate final String name;\n+\tprivate final TypeImpl type;\n+\tprivate final boolean isArray;\n+\tprivate final List<Annotation> annotations;\n+\n+\tTypedFieldImpl(TypeImpl type, String name) {\n+\t\tthis(type, name, false, Collections.emptyList());\n+\t}\n+\n+\tTypedFieldImpl(TypeImpl type, String name, boolean isArray) {\n+\t\tthis(type, name, isArray, Collections.emptyList());\n+\t}\n+\n+\tTypedFieldImpl(TypeImpl type, String name, boolean isArray, List<Annotation> annotations) {\n+\t\tObjects.requireNonNull(type);\n+\t\tObjects.requireNonNull(name);\n+\t\tObjects.requireNonNull(annotations);\n+\n+\t\tthis.name = name;\n+\t\tthis.type = type;\n+\t\tthis.isArray = isArray;\n+\t\tthis.annotations = Collections.unmodifiableList(annotations);\n+\t}\n+\n+\t@Override\n+\tpublic String getName() {\n+\t\treturn name;\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl getType() {\n+\t\treturn type;\n+\t}\n+\n+\t@Override\n+\tpublic boolean isArray() {\n+\t\treturn isArray;\n+\t}\n+\n+\t@Override\n+\tpublic List<Annotation> getAnnotations() {\n+\t\treturn annotations;\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTypedFieldImpl that = (TypedFieldImpl) o;\n+\t\treturn isArray == that.isArray && name.equals(that.name) && type.equals(that.type)\n+\t\t\t\t&& annotations.equals(that.annotations);\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tif (hashCode == 0) {\n+\t\t\thashCode = NonZeroHashCode.hash(name, type, isArray, annotations);\n+\t\t}\n+\t\treturn hashCode;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypedFieldImpl.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedFieldValue;\n+import org.openjdk.jmc.flightrecorder.writer.util.NonZeroHashCode;\n+\n+import java.util.Arrays;\n+\n+public final class TypedFieldValueImpl implements TypedFieldValue {\n+\tprivate int hashCode = 0;\n+\n+\tprivate final TypedFieldImpl field;\n+\tprivate final TypedValueImpl[] values;\n+\n+\tpublic TypedFieldValueImpl(TypedFieldImpl field, TypedValueImpl value) {\n+\t\tthis(field, new TypedValueImpl[] {value});\n+\t}\n+\n+\tpublic TypedFieldValueImpl(TypedFieldImpl field, TypedValueImpl[] values) {\n+\t\tif (values == null) {\n+\t\t\tvalues = new TypedValueImpl[0];\n+\t\t}\n+\t\tif (!field.isArray() && values.length > 1) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\tthis.field = field;\n+\t\tthis.values = values;\n+\t}\n+\n+\t\/** @return the corresponding {@linkplain TypedFieldImpl} *\/\n+\tpublic TypedFieldImpl getField() {\n+\t\treturn field;\n+\t}\n+\n+\t\/**\n+\t * @return the associated value\n+\t * @throws IllegalArgumentException\n+\t *             if the field is an array\n+\t *\/\n+\tpublic TypedValueImpl getValue() {\n+\t\tif (field.isArray()) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\treturn values[0];\n+\t}\n+\n+\t\/**\n+\t * @return the associated values\n+\t * @throws IllegalArgumentException\n+\t *             if the field is not an array\n+\t *\/\n+\tpublic TypedValueImpl[] getValues() {\n+\t\tif (!field.isArray()) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\treturn Arrays.copyOf(values, values.length);\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tTypedFieldValueImpl that = (TypedFieldValueImpl) o;\n+\t\treturn field.equals(that.field) && Arrays.equals(values, that.values);\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tif (hashCode == 0) {\n+\t\t\tObject[] objValues = new Object[values.length + 1];\n+\t\t\tSystem.arraycopy(values, 0, objValues, 1, values.length);\n+\t\t\tobjValues[0] = field;\n+\t\t\thashCode = NonZeroHashCode.hash(objValues);\n+\t\t}\n+\t\treturn hashCode;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"TypedFieldValueImpl{\" + \"field=\" + field + \", values=\" + Arrays.toString(values) + '}';\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypedFieldValueImpl.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,363 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValueBuilder;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValue;\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+public final class TypedValueBuilderImpl implements TypedValueBuilder {\n+\tprivate final Type type;\n+\tprivate final TypesImpl types;\n+\tprivate final Map<String, TypedFieldImpl> fieldMap;\n+\tprivate final Map<String, TypedFieldValueImpl> fieldValueMap;\n+\n+\tpublic TypedValueBuilderImpl(TypeImpl type) {\n+\t\tthis.type = type;\n+\t\tthis.types = type.getTypes();\n+\t\tfieldMap = type.getFields().stream().collect(Collectors.toMap(TypedFieldImpl::getName, typeField -> typeField));\n+\t\tfieldValueMap = new HashMap<>();\n+\t}\n+\n+\t@Override\n+\tpublic Type getType() {\n+\t\treturn type;\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, byte value) {\n+\t\treturn putField(name, types.getType(Types.Builtin.BYTE).asValue(value));\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, byte[] values) {\n+\t\tputArrayField(name, () -> {\n+\t\t\tTypeImpl type = types.getType(TypesImpl.Builtin.BYTE);\n+\t\t\tTypedValueImpl[] typedValues = new TypedValueImpl[values.length];\n+\t\t\tfor (int i = 0; i < values.length; i++) {\n+\t\t\t\ttypedValues[i] = type.asValue(values[i]);\n+\t\t\t}\n+\t\t\treturn typedValues;\n+\t\t});\n+\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, char value) {\n+\t\treturn putField(name, types.getType(Types.Builtin.CHAR).asValue(value));\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, char[] values) {\n+\t\tputArrayField(name, () -> {\n+\t\t\tTypeImpl type = types.getType(TypesImpl.Builtin.CHAR);\n+\t\t\tTypedValueImpl[] typedValues = new TypedValueImpl[values.length];\n+\t\t\tfor (int i = 0; i < values.length; i++) {\n+\t\t\t\ttypedValues[i] = type.asValue(values[i]);\n+\t\t\t}\n+\t\t\treturn typedValues;\n+\t\t});\n+\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, short value) {\n+\t\treturn putField(name, types.getType(TypesImpl.Builtin.SHORT).asValue(value));\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, short[] values) {\n+\t\tputArrayField(name, () -> {\n+\t\t\tTypeImpl type = types.getType(TypesImpl.Builtin.SHORT);\n+\t\t\tTypedValueImpl[] typedValues = new TypedValueImpl[values.length];\n+\t\t\tfor (int i = 0; i < values.length; i++) {\n+\t\t\t\ttypedValues[i] = type.asValue(values[i]);\n+\t\t\t}\n+\t\t\treturn typedValues;\n+\t\t});\n+\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, int value) {\n+\t\treturn putField(name, types.getType(TypesImpl.Builtin.INT).asValue(value));\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, int[] values) {\n+\t\tputArrayField(name, () -> {\n+\t\t\tTypeImpl type = types.getType(TypesImpl.Builtin.INT);\n+\t\t\tTypedValueImpl[] typedValues = new TypedValueImpl[values.length];\n+\t\t\tfor (int i = 0; i < values.length; i++) {\n+\t\t\t\ttypedValues[i] = type.asValue(values[i]);\n+\t\t\t}\n+\t\t\treturn typedValues;\n+\t\t});\n+\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, long value) {\n+\t\treturn putField(name, types.getType(TypesImpl.Builtin.LONG).asValue(value));\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, long[] values) {\n+\t\tputArrayField(name, () -> {\n+\t\t\tTypeImpl type = types.getType(TypesImpl.Builtin.LONG);\n+\t\t\tTypedValueImpl[] typedValues = new TypedValueImpl[values.length];\n+\t\t\tfor (int i = 0; i < values.length; i++) {\n+\t\t\t\ttypedValues[i] = type.asValue(values[i]);\n+\t\t\t}\n+\t\t\treturn typedValues;\n+\t\t});\n+\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, float value) {\n+\t\treturn putField(name, types.getType(TypesImpl.Builtin.FLOAT).asValue(value));\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, float[] values) {\n+\t\tputArrayField(name, () -> {\n+\t\t\tTypeImpl type = types.getType(TypesImpl.Builtin.FLOAT);\n+\t\t\tTypedValueImpl[] typedValues = new TypedValueImpl[values.length];\n+\t\t\tfor (int i = 0; i < values.length; i++) {\n+\t\t\t\ttypedValues[i] = type.asValue(values[i]);\n+\t\t\t}\n+\t\t\treturn typedValues;\n+\t\t});\n+\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, double value) {\n+\t\treturn putField(name, types.getType(TypesImpl.Builtin.DOUBLE).asValue(value));\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, double[] values) {\n+\t\tputArrayField(name, () -> {\n+\t\t\tTypeImpl type = types.getType(TypesImpl.Builtin.DOUBLE);\n+\t\t\tTypedValueImpl[] typedValues = new TypedValueImpl[values.length];\n+\t\t\tfor (int i = 0; i < values.length; i++) {\n+\t\t\t\ttypedValues[i] = type.asValue(values[i]);\n+\t\t\t}\n+\t\t\treturn typedValues;\n+\t\t});\n+\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, boolean value) {\n+\t\treturn putField(name, types.getType(TypesImpl.Builtin.BOOLEAN).asValue(value));\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilderImpl putField(String name, boolean[] values) {\n+\t\tputArrayField(name, () -> {\n+\t\t\tTypeImpl type = types.getType(TypesImpl.Builtin.BOOLEAN);\n+\t\t\tTypedValueImpl[] typedValues = new TypedValueImpl[values.length];\n+\t\t\tfor (int i = 0; i < values.length; i++) {\n+\t\t\t\ttypedValues[i] = type.asValue(values[i]);\n+\t\t\t}\n+\t\t\treturn typedValues;\n+\t\t});\n+\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, String value) {\n+\t\treturn putField(name, types.getType(TypesImpl.Builtin.STRING).asValue(value));\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, String[] values) {\n+\t\tputArrayField(name, () -> {\n+\t\t\tTypeImpl type = types.getType(TypesImpl.Builtin.STRING);\n+\t\t\tTypedValueImpl[] typedValues = new TypedValueImpl[values.length];\n+\t\t\tfor (int i = 0; i < values.length; i++) {\n+\t\t\t\ttypedValues[i] = type.asValue(values[i]);\n+\t\t\t}\n+\t\t\treturn typedValues;\n+\t\t});\n+\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, TypedValueBuilder valueBuilder) {\n+\t\treturn putField(name, new TypedValueImpl(valueBuilder));\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, TypedValue ... values) {\n+\t\tif (values.length > 0) {\n+\t\t\tTypedValueImpl[] typedValues = new TypedValueImpl[values.length];\n+\t\t\tSystem.arraycopy(values, 0, typedValues, 0, values.length);\n+\t\t\tputArrayField(name, typedValues);\n+\t\t}\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, TypedValue value) {\n+\t\tTypedFieldImpl field = fieldMap.get(name);\n+\t\tTypedValueImpl typedValue = (TypedValueImpl) value;\n+\t\tif (field != null) {\n+\t\t\tTypeImpl type = field.getType();\n+\t\t\tif (type.isSimple()) {\n+\t\t\t\ttypedValue = wrapSimpleValue(type, typedValue);\n+\t\t\t}\n+\t\t\tif (field.getType().canAccept(typedValue)) {\n+\t\t\t\tfieldValueMap.put(name, new TypedFieldValueImpl(field, typedValue));\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalArgumentException();\n+\t\t\t}\n+\t\t}\n+\t\treturn this;\n+\t}\n+\n+\tprivate TypedValueImpl wrapSimpleValue(TypeImpl targetType, TypedValueImpl value) {\n+\t\tTypedFieldImpl valueField = targetType.getFields().get(0);\n+\t\tTypeImpl fieldType = valueField.getType();\n+\t\tif (fieldType.canAccept(value)) {\n+\t\t\tvalue = targetType\n+\t\t\t\t\t.asValue(new SingleFieldMap(valueField.getName(), new TypedFieldValueImpl(valueField, value)));\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\treturn value;\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueBuilder putField(String name, Consumer<TypedValueBuilder> fieldValueCallback) {\n+\t\tTypedFieldImpl field = fieldMap.get(name);\n+\t\tif (field != null) {\n+\t\t\tfieldValueMap.put(name, new TypedFieldValueImpl(field, field.getType().asValue(fieldValueCallback)));\n+\t\t}\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic TypedValueBuilder putFields(\n+\t\tString name, Consumer<TypedValueBuilder> callback1, Consumer<TypedValueBuilder> callback2,\n+\t\tConsumer<TypedValueBuilder> ... otherCallbacks) {\n+\t\tbuildArrayField(name, () -> {\n+\t\t\tList<Consumer<TypedValueBuilder>> callbacks = new ArrayList<>(2 + otherCallbacks.length);\n+\t\t\tcallbacks.add(callback1);\n+\t\t\tcallbacks.add(callback2);\n+\t\t\tcallbacks.addAll(Arrays.asList(otherCallbacks));\n+\t\t\treturn callbacks.toArray(new Consumer[0]);\n+\t\t});\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic Map<String, TypedFieldValueImpl> build() {\n+\t\treturn Collections.unmodifiableMap(fieldValueMap);\n+\t}\n+\n+\tprivate void putArrayField(String name, TypedValueImpl[] values) {\n+\t\tTypedFieldImpl field = fieldMap.get(name);\n+\t\tif (field != null) {\n+\t\t\tputArrayField(field, values);\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t}\n+\n+\tprivate void putArrayField(TypedFieldImpl field, TypedValueImpl[] values) {\n+\t\tTypeImpl fieldType = field.getType();\n+\t\tfor (TypedValueImpl value : values) {\n+\t\t\tif (!fieldType.canAccept(value)) {\n+\t\t\t\tthrow new IllegalArgumentException();\n+\t\t\t}\n+\t\t}\n+\t\tfieldValueMap.put(field.getName(), new TypedFieldValueImpl(field, values));\n+\t}\n+\n+\tprivate void putArrayField(String name, Supplier<TypedValueImpl[]> valueSupplier) {\n+\t\tTypedFieldImpl field = fieldMap.get(name);\n+\t\tif (field != null) {\n+\t\t\tif (!field.isArray()) {\n+\t\t\t\tthrow new IllegalArgumentException();\n+\t\t\t}\n+\t\t\tputArrayField(field, valueSupplier.get());\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t}\n+\n+\tprivate void buildArrayField(String name, Supplier<Consumer<TypedValueBuilder>[]> builderSupplier) {\n+\t\tTypedFieldImpl field = fieldMap.get(name);\n+\t\tif (field != null) {\n+\t\t\tif (field.isArray()) {\n+\t\t\t\tConsumer<TypedValueBuilder>[] builders = builderSupplier.get();\n+\t\t\t\tTypedValueImpl[] values = new TypedValueImpl[builders.length];\n+\t\t\t\tTypeImpl fieldType = field.getType();\n+\t\t\t\tfor (int i = 0; i < builders.length; i++) {\n+\t\t\t\t\tvalues[i] = fieldType.asValue(builders[i]);\n+\t\t\t\t}\n+\t\t\t\tfieldValueMap.put(field.getName(), new TypedFieldValueImpl(field, values));\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalArgumentException();\n+\t\t\t}\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypedValueBuilderImpl.java","additions":363,"deletions":0,"binary":false,"changes":363,"status":"added"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import lombok.NonNull;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValueBuilder;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValue;\n+import org.openjdk.jmc.flightrecorder.writer.util.NonZeroHashCode;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+final class TypedValueImpl implements TypedValue {\n+\tprivate int hashcode = 0;\n+\n+\tprivate final TypeImpl type;\n+\tprivate final Object value;\n+\tprivate final Map<String, TypedFieldValueImpl> fields;\n+\tprivate final boolean isNull;\n+\tprivate final long cpIndex;\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tTypedValueImpl(TypeImpl type, Object value, long cpIndex) {\n+\t\tif (!type.canAccept(value)) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\tthis.type = type;\n+\t\tthis.value = value instanceof Map ? null : value;\n+\t\tthis.fields = value instanceof Map ? (Map<String, TypedFieldValueImpl>) value : Collections.emptyMap();\n+\t\tthis.isNull = value == null;\n+\t\tthis.cpIndex = cpIndex;\n+\t}\n+\n+\tTypedValueImpl(@NonNull TypeImpl type, @NonNull Consumer<TypedValueBuilder> builderCallback) {\n+\t\tthis(type, getFieldValues(type, builderCallback));\n+\t}\n+\n+\tTypedValueImpl(TypedValueBuilder builder) {\n+\t\tthis((TypeImpl) builder.getType(), builder.build());\n+\t}\n+\n+\tprivate static Map<String, TypedFieldValueImpl> getFieldValues(\n+\t\tTypeImpl type, Consumer<TypedValueBuilder> builderCallback) {\n+\t\tTypedValueBuilderImpl access = new TypedValueBuilderImpl(type);\n+\t\tbuilderCallback.accept(access);\n+\t\treturn access.build();\n+\t}\n+\n+\tpublic TypedValueImpl(TypeImpl type, Object value) {\n+\t\tthis(type, value, Long.MIN_VALUE);\n+\t}\n+\n+\tprotected TypedValueImpl(TypedValueImpl other, long cpIndex) {\n+\t\tif (other.getType().isBuiltin()) {\n+\t\t\tthrow new IllegalArgumentException(\"Value of built-in types can not reside in constant pool\");\n+\t\t}\n+\t\tthis.type = other.type;\n+\t\tthis.value = other.value;\n+\t\tthis.fields = Collections.unmodifiableMap(other.fields);\n+\t\tthis.isNull = other.isNull;\n+\t\tthis.hashcode = other.hashcode;\n+\t\tthis.cpIndex = cpIndex;\n+\t}\n+\n+\t\/**\n+\t * A factory method for properly creating an instance of {@linkplain TypedValue} holding\n+\t * {@literal\n+\t * null} value\n+\t *\n+\t * @param type\n+\t *            the value type\n+\t * @return a null {@linkplain TypedValue} instance\n+\t *\/\n+\tstatic TypedValueImpl ofNull(TypeImpl type) {\n+\t\tif (!type.canAccept(null)) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\treturn new TypedValueImpl(type, (Object) null);\n+\t}\n+\n+\t\/** @return the type *\/\n+\tpublic TypeImpl getType() {\n+\t\treturn type;\n+\t}\n+\n+\t\/** @return the wrapped value *\/\n+\tpublic Object getValue() {\n+\t\treturn type.isSimple() ? getFieldValues().get(0).getValue().getValue() : value;\n+\t}\n+\n+\t\/** @return {@literal true} if this holds {@literal null} value *\/\n+\tpublic boolean isNull() {\n+\t\treturn isNull;\n+\t}\n+\n+\t\/** @return the field values structure *\/\n+\tpublic List<TypedFieldValueImpl> getFieldValues() {\n+\t\tif (isNull) {\n+\t\t\tthrow new NullPointerException();\n+\t\t}\n+\n+\t\tList<TypedFieldValueImpl> values = new ArrayList<>(fields.size());\n+\t\tfor (TypedFieldImpl field : type.getFields()) {\n+\t\t\tTypedFieldValueImpl value = fields.get(field.getName());\n+\t\t\tif (value == null) {\n+\t\t\t\tvalue = new TypedFieldValueImpl(field, field.getType().nullValue());\n+\t\t\t}\n+\t\t\tvalues.add(value);\n+\t\t}\n+\t\treturn values;\n+\t}\n+\n+\tlong getConstantPoolIndex() {\n+\t\treturn cpIndex;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o)\n+\t\t\treturn true;\n+\t\tif (o == null || getClass() != o.getClass())\n+\t\t\treturn false;\n+\t\tTypedValueImpl that = (TypedValueImpl) o;\n+\t\treturn isNull == that.isNull && type.equals(that.type) && Objects.equals(value, that.value)\n+\t\t\t\t&& fields.equals(that.fields);\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tif (hashcode == 0) {\n+\t\t\thashcode = NonZeroHashCode.hash(type, value, fields, isNull);\n+\t\t}\n+\t\treturn hashcode;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"TypedValueImpl{\" + \"type=\" + type + \", value=\" + value + \", fields=\" + fields + \", isNull=\" + isNull\n+\t\t\t\t+ \", cpIndex=\" + cpIndex + '}';\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypedValueImpl.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.TypeStructure;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypeStructureBuilder;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedFieldBuilder;\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n+\n+import java.util.function.Consumer;\n+\n+import static org.openjdk.jmc.flightrecorder.writer.api.Annotation.ANNOTATION_SUPER_TYPE_NAME;\n+import static org.openjdk.jmc.flightrecorder.writer.api.Types.Builtin.*;\n+\n+\/** An access class for various {@linkplain Type} related operations *\/\n+public final class TypesImpl extends Types {\n+\tprivate final MetadataImpl metadata;\n+\n+\tTypesImpl(MetadataImpl metadata) {\n+\t\tmetadata.setTypes(this);\n+\t\tthis.metadata = metadata;\n+\n+\t\tregisterBuiltins();\n+\t\tregisterJdkTypes();\n+\t\tthis.metadata.resolveTypes(); \/\/ resolve all back-referenced types\n+\t}\n+\n+\tprivate void registerBuiltins() {\n+\t\tmetadata.registerBuiltin(BYTE);\n+\t\tmetadata.registerBuiltin(CHAR);\n+\t\tmetadata.registerBuiltin(SHORT);\n+\t\tmetadata.registerBuiltin(INT);\n+\t\tmetadata.registerBuiltin(LONG);\n+\t\tmetadata.registerBuiltin(FLOAT);\n+\t\tmetadata.registerBuiltin(DOUBLE);\n+\t\tmetadata.registerBuiltin(BOOLEAN);\n+\t\tmetadata.registerBuiltin(STRING);\n+\t}\n+\n+\tprivate void registerJdkTypes() {\n+\t\tTypeImpl annotationNameType = getOrAdd(JDK.ANNOTATION_NAME, ANNOTATION_SUPER_TYPE_NAME, builder -> {\n+\t\t\tbuilder.addField(\"value\", Builtin.STRING);\n+\t\t});\n+\t\tTypeImpl annotationLabelType = getOrAdd(JDK.ANNOTATION_LABEL, ANNOTATION_SUPER_TYPE_NAME, builder -> {\n+\t\t\tbuilder.addField(\"value\", Builtin.STRING);\n+\t\t});\n+\t\tTypeImpl annotationDescriptionType = getOrAdd(JDK.ANNOTATION_DESCRIPTION, ANNOTATION_SUPER_TYPE_NAME,\n+\t\t\t\tbuilder -> {\n+\t\t\t\t\tbuilder.addField(\"value\", Builtin.STRING);\n+\t\t\t\t});\n+\t\tTypeImpl annotationContentTypeType = getOrAdd(JDK.ANNOTATION_CONTENT_TYPE, ANNOTATION_SUPER_TYPE_NAME,\n+\t\t\t\tbuilder -> {\n+\t\t\t\t});\n+\t\tgetOrAdd(JDK.ANNOTATION_TIMESTAMP, ANNOTATION_SUPER_TYPE_NAME, builder -> {\n+\t\t\tbuilder.addField(\"value\", Builtin.STRING).addAnnotation(annotationNameType, \"jdk.jfr.Timestamp\")\n+\t\t\t\t\t.addAnnotation(annotationContentTypeType, null).addAnnotation(annotationLabelType, \"Timestamp\")\n+\t\t\t\t\t.addAnnotation(annotationDescriptionType, \"A point in time\");\n+\t\t});\n+\t\tgetOrAdd(JDK.ANNOTATION_TIMESPAN, ANNOTATION_SUPER_TYPE_NAME, builder -> {\n+\t\t\tbuilder.addField(\"value\", Builtin.STRING).addAnnotation(annotationNameType, \"jdk.jfr.Timespan\")\n+\t\t\t\t\t.addAnnotation(annotationContentTypeType, null).addAnnotation(annotationLabelType, \"Timespan\")\n+\t\t\t\t\t.addAnnotation(annotationDescriptionType, \"A duration, measured in nanoseconds by default\");\n+\t\t});\n+\t\tgetOrAdd(JDK.ANNOTATION_UNSIGNED, ANNOTATION_SUPER_TYPE_NAME, builder -> {\n+\t\t\tbuilder.addField(\"value\", Builtin.STRING).addAnnotation(annotationNameType, \"jdk.jfr.Unsigned\")\n+\t\t\t\t\t.addAnnotation(annotationContentTypeType, null).addAnnotation(annotationLabelType, \"Unsigned value\")\n+\t\t\t\t\t.addAnnotation(annotationDescriptionType, \"Value should be interpreted as unsigned data type\");\n+\t\t});\n+\n+\t\tgetOrAdd(JDK.TICKSPAN, builder -> {\n+\t\t\tbuilder.addField(\"tickSpan\", Builtin.LONG);\n+\t\t});\n+\t\tgetOrAdd(JDK.TICKS, builder -> {\n+\t\t\tbuilder.addField(\"ticks\", Builtin.LONG);\n+\t\t});\n+\t\tTypeImpl threadGroupType = getOrAdd(JDK.THREAD_GROUP, tgBuilder -> {\n+\t\t\ttgBuilder.addField(\"parent\", tgBuilder.selfType()).addField(\"name\", getType(Builtin.STRING));\n+\t\t});\n+\t\tgetOrAdd(JDK.THREAD, typeBuilder -> {\n+\t\t\ttypeBuilder.addField(\"osName\", getType(Builtin.STRING)).addField(\"osThreadId\", getType(Builtin.LONG))\n+\t\t\t\t\t.addField(\"javaName\", getType(Builtin.STRING)).addField(\"group\", threadGroupType);\n+\t\t});\n+\t\tTypeImpl symbol = getOrAdd(JDK.SYMBOL, builder -> {\n+\t\t\tbuilder.addField(\"string\", Builtin.STRING);\n+\t\t});\n+\t\tTypeImpl classLoader = getOrAdd(JDK.CLASS_LOADER, builder -> {\n+\t\t\tbuilder.addField(\"type\", JDK.CLASS).addField(\"name\", symbol);\n+\t\t});\n+\t\tTypeImpl moduleType = getOrAdd(JDK.MODULE, builder -> {\n+\t\t\tbuilder.addField(\"name\", symbol).addField(\"version\", symbol).addField(\"location\", symbol)\n+\t\t\t\t\t.addField(\"classLoader\", classLoader);\n+\t\t});\n+\t\tTypeImpl packageType = getOrAdd(JDK.PACKAGE, builder -> {\n+\t\t\tbuilder.addField(\"name\", symbol).addField(\"module\", moduleType).addField(\"exported\", Builtin.BOOLEAN);\n+\t\t});\n+\t\tTypeImpl classType = getOrAdd(JDK.CLASS, builder -> {\n+\t\t\tbuilder.addField(\"classLoader\", classLoader).addField(\"name\", symbol).addField(\"package\", packageType)\n+\t\t\t\t\t.addField(\"modifiers\", Builtin.INT).addField(\"hidden\", Builtin.BOOLEAN);\n+\t\t});\n+\t\tTypeImpl methodType = getOrAdd(JDK.METHOD, builder -> {\n+\t\t\tbuilder.addField(\"type\", classType).addField(\"name\", symbol).addField(\"descriptor\", symbol)\n+\t\t\t\t\t.addField(\"modifiers\", Builtin.INT).addField(\"hidden\", Builtin.BOOLEAN);\n+\t\t});\n+\t\tgetOrAdd(JDK.FRAME_TYPE, builder -> {\n+\t\t\tbuilder.addField(\"description\", Builtin.STRING);\n+\t\t});\n+\t\tgetOrAdd(JDK.STACK_FRAME, builder -> {\n+\t\t\tbuilder.addField(\"method\", methodType).addField(\"lineNumber\", Builtin.INT)\n+\t\t\t\t\t.addField(\"bytecodeIndex\", Builtin.INT).addField(\"type\", JDK.FRAME_TYPE);\n+\t\t});\n+\t\tgetOrAdd(JDK.STACK_TRACE, builder -> {\n+\t\t\tbuilder.addField(\"truncated\", Builtin.BOOLEAN).addField(\"frames\", JDK.STACK_FRAME,\n+\t\t\t\t\tTypedFieldBuilder::asArray);\n+\t\t});\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl getOrAdd(Predefined type, Consumer<TypeStructureBuilder> builderCallback) {\n+\t\treturn getOrAdd(type.getTypeName(), builderCallback);\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl getOrAdd(String name, Consumer<TypeStructureBuilder> builderCallback) {\n+\t\treturn getOrAdd(name, null, builderCallback);\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl getOrAdd(Predefined type, String supertype, Consumer<TypeStructureBuilder> builderCallback) {\n+\t\treturn getOrAdd(type.getTypeName(), supertype, builderCallback);\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl getOrAdd(String name, String supertype, Consumer<TypeStructureBuilder> builderCallback) {\n+\t\treturn metadata.registerType(name, supertype, () -> {\n+\t\t\tTypeStructureBuilderImpl builder = new TypeStructureBuilderImpl(this);\n+\t\t\tbuilderCallback.accept(builder);\n+\t\t\treturn (TypeStructureImpl) builder.build();\n+\t\t});\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl getOrAdd(String name, String supertype, TypeStructure typeStructure) {\n+\t\treturn metadata.registerType(name, supertype, (TypeStructureImpl) typeStructure);\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl getType(String name) {\n+\t\treturn getType(name, false);\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl getType(String name, boolean asResolvable) {\n+\t\treturn metadata.getType(name, asResolvable);\n+\t}\n+\n+\t@Override\n+\tpublic TypeImpl getType(Predefined type) {\n+\t\treturn getType(type.getTypeName(), true);\n+\t}\n+\n+\t@Override\n+\tpublic TypeStructureBuilder typeStructureBuilder() {\n+\t\treturn new TypeStructureBuilderImpl(this);\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldBuilder fieldBuilder(String fieldName, Type fieldType) {\n+\t\treturn new TypedFieldBuilderImpl(fieldName, (TypeImpl) fieldType, this);\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldBuilder fieldBuilder(String fieldName, Builtin fieldType) {\n+\t\treturn new TypedFieldBuilderImpl(fieldName, getType(fieldType), this);\n+\t}\n+\n+\t\/**\n+\t * Resolve all unresolved types. After this method had been called all calls to\n+\t * {@linkplain ResolvableType#isResolved()} will return {@literal true} if the target type was\n+\t * properly registered\n+\t *\/\n+\tpublic void resolveAll() {\n+\t\tmetadata.resolveTypes();\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypesImpl.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.api;\n+\n+import lombok.Getter;\n+import lombok.ToString;\n+import org.openjdk.jmc.flightrecorder.writer.util.NonZeroHashCode;\n+\n+import java.util.Objects;\n+\n+\/** A struct-like representation of a JFR annotation *\/\n+@ToString\n+public final class Annotation {\n+\tpublic static final String ANNOTATION_SUPER_TYPE_NAME = \"java.lang.annotation.Annotation\";\n+\tprivate int hashCode = 0;\n+\n+\t@Getter\n+\tprivate final Type type;\n+\t@Getter\n+\tprivate final String value;\n+\n+\t\/**\n+\t * Create a new {@linkplain Annotation} instance\n+\t *\n+\t * @param type\n+\t *            the annotation type (must have the value of\n+\t *            {@linkplain Annotation#ANNOTATION_SUPER_TYPE_NAME} as its super type)\n+\t * @param value\n+\t *            the annotation value or {@literal null}\n+\t * @throws IllegalArgumentException\n+\t *             if the annotation type is not having the value of\n+\t *             {@linkplain Annotation#ANNOTATION_SUPER_TYPE_NAME} as its super type\n+\t *\/\n+\tpublic Annotation(Type type, String value) {\n+\t\tif (!isAnnotationType(type)) {\n+\t\t\tthrow new IllegalArgumentException();\n+\t\t}\n+\t\tthis.type = type;\n+\t\tthis.value = value;\n+\t}\n+\n+\tpublic static boolean isAnnotationType(Type type) {\n+\t\treturn ANNOTATION_SUPER_TYPE_NAME.equals(type.getSupertype());\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (o == null || getClass() != o.getClass()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tAnnotation that = (Annotation) o;\n+\t\treturn type.equals(that.type) && Objects.equals(value, that.value);\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tif (hashCode == 0) {\n+\t\t\thashCode = NonZeroHashCode.hash(type, value);\n+\t\t}\n+\t\treturn hashCode;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/Annotation.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.api;\n+\n+\/** A generic 'named' type *\/\n+public interface NamedType {\n+\t\/** @return the type name *\/\n+\tString getTypeName();\n+\n+\t\/**\n+\t * @param other\n+\t *            other type\n+\t * @return {@literal true} if the two types are the same (have the same name)\n+\t *\/\n+\tdefault boolean isSame(NamedType other) {\n+\t\treturn getTypeName().equals(other.getTypeName());\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/NamedType.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.api;\n+\n+import org.openjdk.jmc.flightrecorder.writer.RecordingImpl;\n+import org.openjdk.jmc.flightrecorder.writer.TypesImpl;\n+\n+import java.util.function.Consumer;\n+\n+public abstract class Recording implements AutoCloseable {\n+\tpublic abstract RecordingImpl rotateChunk();\n+\n+\t\/**\n+\t * Write a custom event\n+\t *\n+\t * @param event\n+\t *            the event value\n+\t * @return {@literal this} for chaining\n+\t * @throws IllegalArgumentException\n+\t *             if the event type has not got 'jdk.jfr.Event' as its super type\n+\t *\/\n+\tpublic abstract RecordingImpl writeEvent(TypedValue event);\n+\n+\t\/**\n+\t * Try registering a user event type with no additional attributes. If a same-named event\n+\t * already exists it will be returned.\n+\t *\n+\t * @param name\n+\t *            the event name\n+\t * @return a user event type of the given name\n+\t *\/\n+\tpublic abstract Type registerEventType(String name);\n+\n+\t\/**\n+\t * Try registering a user event type. If a same-named event already exists it will be returned.\n+\t *\n+\t * @param name\n+\t *            the event name\n+\t * @param builderCallback\n+\t *            will be called with the active {@linkplain TypeStructureBuilder} when the event is\n+\t *            newly registered\n+\t * @return a user event type of the given name\n+\t * @throws IllegalArgumentException\n+\t *             if 'name' or 'builderCallback' is {@literal null}\n+\t *\/\n+\tpublic abstract Type registerEventType(String name, Consumer<TypeStructureBuilder> builderCallback);\n+\n+\t\/**\n+\t * Try registering a user annotation type. If a same-named annotation already exists it will be\n+\t * returned.\n+\t *\n+\t * @param name\n+\t *            the annotation name\n+\t * @return a user annotation type of the given name\n+\t * @throws IllegalArgumentException\n+\t *             if 'name' is {@literal null}\n+\t *\/\n+\tpublic abstract Type registerAnnotationType(String name);\n+\n+\t\/**\n+\t * Try registering a user annotation type. If a same-named annotation already exists it will be\n+\t * returned.\n+\t *\n+\t * @param name\n+\t *            the annotation name\n+\t * @param builderCallback\n+\t *            will be called with the active {@linkplain TypeStructureBuilder} when the\n+\t *            annotation is newly registered\n+\t * @return a user annotation type of the given name\n+\t * @throws IllegalArgumentException\n+\t *             if 'name' or 'builderCallback' is {@literal null}\n+\t *\/\n+\tpublic abstract Type registerAnnotationType(String name, Consumer<TypeStructureBuilder> builderCallback);\n+\n+\t\/**\n+\t * Try registering a custom type. If a same-named type already exists it will be returned.\n+\t *\n+\t * @param name\n+\t *            the type name\n+\t * @param builderCallback\n+\t *            will be called with the active {@linkplain TypeStructureBuilder} when the type is\n+\t *            newly registered\n+\t * @return a custom type of the given name\n+\t * @throws IllegalArgumentException\n+\t *             if 'name' or 'builderCallback' is {@literal null}\n+\t *\/\n+\tpublic abstract Type registerType(String name, Consumer<TypeStructureBuilder> builderCallback);\n+\n+\t\/**\n+\t * Try registering a custom type. If a same-named type already exists it will be returned.\n+\t *\n+\t * @param name\n+\t *            the type name\n+\t * @param supertype\n+\t *            the super type name\n+\t * @param builderCallback\n+\t *            will be called with the active {@linkplain TypeStructureBuilder} when the type is\n+\t *            newly registered\n+\t * @return a custom type of the given name\n+\t * @throws IllegalArgumentException\n+\t *             if 'name' or 'builderCallback' is {@literal null}\n+\t *\/\n+\tpublic abstract Type registerType(String name, String supertype, Consumer<TypeStructureBuilder> builderCallback);\n+\n+\t\/**\n+\t * A convenience method to easily get to JDK registered custom types in type-safe manner.\n+\t *\n+\t * @param type\n+\t *            the type\n+\t * @return the previously registered JDK type\n+\t * @throws IllegalArgumentException\n+\t *             if 'type' is {@literal null} or an attempt to retrieve non-registered JDK type is\n+\t *             made\n+\t *\/\n+\tpublic abstract Type getType(TypesImpl.JDK type);\n+\n+\t\/**\n+\t * Try retrieving a previously registered custom type.\n+\t *\n+\t * @param typeName\n+\t *            the type name\n+\t * @return the previously registered custom type\n+\t * @throws IllegalArgumentException\n+\t *             if 'typeName' is {@literal null} or an attempt to retrieve non-registered custom\n+\t *             type is made\n+\t *\/\n+\tpublic abstract Type getType(String typeName);\n+\n+\t\/**\n+\t * @return the associated {@linkplain Types} instance\n+\t *\/\n+\tpublic abstract Types getTypes();\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/Recording.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.api;\n+\n+import org.openjdk.jmc.flightrecorder.writer.RecordingImpl;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+\/**\n+ * A factory class to create new {@linkplain Recording} instances\n+ *\/\n+public final class Recordings {\n+\tpublic static Recording newRecording(String path) throws IOException {\n+\t\treturn newRecording(Paths.get(path));\n+\t}\n+\n+\tpublic static Recording newRecording(Path path) throws IOException {\n+\t\treturn newRecording(path.toFile());\n+\t}\n+\n+\tpublic static Recording newRecording(File path) throws IOException {\n+\t\treturn new RecordingImpl(new FileOutputStream(path));\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/Recordings.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.api;\n+\n+import org.openjdk.jmc.flightrecorder.writer.TypedFieldImpl;\n+\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+\/** A JFR type *\/\n+public interface Type extends NamedType {\n+\t\/** @return unique type ID *\/\n+\tlong getId();\n+\n+\t\/** @return is the type built-in or a custom type *\/\n+\tboolean isBuiltin();\n+\n+\t\/**\n+\t * A simple type has only one field which is of a built-in type\n+\t *\n+\t * @return {@literal true} if the type is 'simple'\n+\t *\/\n+\tboolean isSimple();\n+\n+\t\/**\n+\t * @return {@literal true} if the type is fully resolved\n+\t *\/\n+\tboolean isResolved();\n+\n+\t\/** @return is the type using constant pool *\/\n+\tboolean hasConstantPool();\n+\n+\t\/** @return the super type - may be {@literal null} *\/\n+\tString getSupertype();\n+\n+\t\/** @return the type field structure *\/\n+\tList<? extends TypedField> getFields();\n+\n+\t\/**\n+\t * @param name\n+\t *            field name\n+\t * @return the {@link TypedFieldImpl field} instance\n+\t *\/\n+\tTypedFieldImpl getField(String name);\n+\n+\t\/**\n+\t * @return attached annotations\n+\t *\/\n+\tList<Annotation> getAnnotations();\n+\n+\t\/**\n+\t * Checks whether the type can accept the given value\n+\t *\n+\t * @param value\n+\t *            the value to check\n+\t * @return {@literal true} only if the type can safely hold the value\n+\t * @throws IllegalArgumentException\n+\t *             if the type can not accept the given value\n+\t *\/\n+\tboolean canAccept(Object value);\n+\n+\t\/**\n+\t * Shortcut for wrapping the given value instance as a {@linkplain TypedValue} object\n+\t *\n+\t * @param value\n+\t *            the value to wrap\n+\t * @return a {@linkplain TypedValue} object representing the typed value\n+\t * @throws IllegalArgumentException\n+\t *             if the type can not accept the given value\n+\t *\/\n+\tTypedValue asValue(String value);\n+\n+\t\/**\n+\t * Shortcut for wrapping the given value instance as a {@linkplain TypedValue} object\n+\t *\n+\t * @param value\n+\t *            the value to wrap\n+\t * @return a {@linkplain TypedValue} object representing the typed value\n+\t * @throws IllegalArgumentException\n+\t *             if the type can not accept the given value\n+\t *\/\n+\tTypedValue asValue(byte value);\n+\n+\t\/**\n+\t * Shortcut for wrapping the given value instance as a {@linkplain TypedValue} object\n+\t *\n+\t * @param value\n+\t *            the value to wrap\n+\t * @return a {@linkplain TypedValue} object representing the typed value\n+\t * @throws IllegalArgumentException\n+\t *             if the type can not accept the given value\n+\t *\/\n+\tTypedValue asValue(char value);\n+\n+\t\/**\n+\t * Shortcut for wrapping the given value instance as a {@linkplain TypedValue} object\n+\t *\n+\t * @param value\n+\t *            the value to wrap\n+\t * @return a {@linkplain TypedValue} object representing the typed value\n+\t * @throws IllegalArgumentException\n+\t *             if the type can not accept the given value\n+\t *\/\n+\tTypedValue asValue(short value);\n+\n+\t\/**\n+\t * Shortcut for wrapping the given value instance as a {@linkplain TypedValue} object\n+\t *\n+\t * @param value\n+\t *            the value to wrap\n+\t * @return a {@linkplain TypedValue} object representing the typed value\n+\t * @throws IllegalArgumentException\n+\t *             if the type can not accept the given value\n+\t *\/\n+\tTypedValue asValue(int value);\n+\n+\t\/**\n+\t * Shortcut for wrapping the given value instance as a {@linkplain TypedValue} object\n+\t *\n+\t * @param value\n+\t *            the value to wrap\n+\t * @return a {@linkplain TypedValue} object representing the typed value\n+\t * @throws IllegalArgumentException\n+\t *             if the type can not accept the given value\n+\t *\/\n+\tTypedValue asValue(long value);\n+\n+\t\/**\n+\t * Shortcut for wrapping the given value instance as a {@linkplain TypedValue} object\n+\t *\n+\t * @param value\n+\t *            the value to wrap\n+\t * @return a {@linkplain TypedValue} object representing the typed value\n+\t * @throws IllegalArgumentException\n+\t *             if the type can not accept the given value\n+\t *\/\n+\tTypedValue asValue(float value);\n+\n+\t\/**\n+\t * Shortcut for wrapping the given value instance as a {@linkplain TypedValue} object\n+\t *\n+\t * @param value\n+\t *            the value to wrap\n+\t * @return a {@linkplain TypedValue} object representing the typed value\n+\t * @throws IllegalArgumentException\n+\t *             if the type can not accept the given value\n+\t *\/\n+\tTypedValue asValue(double value);\n+\n+\t\/**\n+\t * Shortcut for wrapping the given value instance as a {@linkplain TypedValue} object\n+\t *\n+\t * @param value\n+\t *            the value to wrap\n+\t * @return a {@linkplain TypedValue} object representing the typed value\n+\t * @throws IllegalArgumentException\n+\t *             if the type can not accept the given value\n+\t *\/\n+\tTypedValue asValue(boolean value);\n+\n+\t\/**\n+\t * Shortcut for creating a new {@linkplain TypedValue} object for this type\n+\t *\n+\t * @param builderCallback\n+\t *            will be called when the new {@linkplain TypedValue} is being initialized\n+\t * @return a {@linkplain TypedValue} object representing the typed value\n+\t * @throws IllegalArgumentException\n+\t *             if the type can not be used with builder callback\n+\t *\/\n+\tTypedValue asValue(Consumer<TypedValueBuilder> builderCallback);\n+\n+\tTypedValue asValue(Object value);\n+\n+\t\/**\n+\t * @return a specific {@linkplain TypedValue} instance designated as the {@literal null} value\n+\t *         for this type\n+\t *\/\n+\tTypedValue nullValue();\n+\n+\t\/**\n+\t * @return a new {@linkplain TypedValueBuilder} instance for a value of this particular type\n+\t *\/\n+\tTypedValueBuilder valueBuilder();\n+\n+\t\/**\n+\t * Checks whether this particular type is used as a field type in the other type.\n+\t * \n+\t * @param other\n+\t *            the other type\n+\t * @return {@literal true} if any of the fields in 'other' type are of this particular type\n+\t *\/\n+\tboolean isUsedBy(Type other);\n+\n+\t\/**\n+\t * @return the associated {@linkplain Types} helper class instance\n+\t *\/\n+\tTypes getTypes();\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/Type.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.api;\n+\n+import java.util.List;\n+\n+public interface TypeStructure {\n+\tList<? extends TypedField> getFields();\n+\n+\tList<Annotation> getAnnotations();\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/TypeStructure.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.api;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Types.Predefined;\n+\n+import java.util.function.Consumer;\n+\n+\/** A fluent API for building composite types lazily. *\/\n+public interface TypeStructureBuilder {\n+\t\/**\n+\t * Add a field of the given name and (predefined) type\n+\t *\n+\t * @param name\n+\t *            the field name\n+\t * @param type\n+\t *            the field type\n+\t * @return a {@linkplain TypeStructureBuilder} instance for invocation chaining\n+\t *\/\n+\tTypeStructureBuilder addField(String name, Predefined type);\n+\n+\t\/**\n+\t * Add a field of the given name and (predefined) type and with a customization callback\n+\t *\n+\t * @param name\n+\t *            the field name\n+\t * @param type\n+\t *            the field type\n+\t * @param fieldCallback\n+\t *            the field customization callback\n+\t * @return a {@linkplain TypeStructureBuilder} instance for invocation chaining\n+\t *\/\n+\tTypeStructureBuilder addField(String name, Predefined type, Consumer<TypedFieldBuilder> fieldCallback);\n+\n+\t\/**\n+\t * Add a field of the given name and type\n+\t *\n+\t * @param name\n+\t *            the field name\n+\t * @param type\n+\t *            the field type\n+\t * @return a {@linkplain TypeStructureBuilder} instance for invocation chaining\n+\t *\/\n+\tTypeStructureBuilder addField(String name, Type type);\n+\n+\t\/**\n+\t * Add a field of the given name and type and with a customization callback\n+\t *\n+\t * @param name\n+\t *            the field name\n+\t * @param type\n+\t *            the field type\n+\t * @param fieldCallback\n+\t *            the field customization callback\n+\t * @return a {@linkplain TypeStructureBuilder} instance for invocation chaining\n+\t *\/\n+\tTypeStructureBuilder addField(String name, Type type, Consumer<TypedFieldBuilder> fieldCallback);\n+\n+\t\/**\n+\t * Add a specific field.\n+\t *\n+\t * @param field\n+\t *            field\n+\t * @return a {@linkplain TypeStructureBuilder} instance for invocation chaining\n+\t *\/\n+\tTypeStructureBuilder addField(TypedField field);\n+\n+\t\/**\n+\t * Add specific fields.\n+\t *\n+\t * @param field1\n+\t *            first field\n+\t * @param field2\n+\t *            second field\n+\t * @param fields\n+\t *            other fields (if any)\n+\t * @return a {@linkplain TypeStructureBuilder} instance for invocation chaining\n+\t *\/\n+\tTypeStructureBuilder addFields(TypedField field1, TypedField field2, TypedField ... fields);\n+\n+\t\/**\n+\t * Add an annotation of the given type\n+\t *\n+\t * @param type\n+\t *            the annotation type\n+\t * @return a {@linkplain TypeStructureBuilder} instance for invocation chaining\n+\t *\/\n+\tTypeStructureBuilder addAnnotation(Type type);\n+\n+\t\/**\n+\t * Add an annotation of the given type and with the given value\n+\t *\n+\t * @param type\n+\t *            the annotation type\n+\t * @param value\n+\t *            the annotation value\n+\t * @return a {@linkplain TypeStructureBuilder} instance for invocation chaining\n+\t *\/\n+\tTypeStructureBuilder addAnnotation(Type type, String value);\n+\n+\t\/**\n+\t * A special placeholder type to refer to the type being currently built (otherwise impossible\n+\t * because the type is not yet ready).\n+\t *\n+\t * @return a special {@linkplain Type} denoting 'self' reflecting type\n+\t *\/\n+\tType selfType();\n+\n+\t\/**\n+\t * @return\n+\t *\/\n+\tTypeStructure build();\n+\n+\tType registerAs(String name, String supertype);\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/TypeStructureBuilder.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.api;\n+\n+import java.util.List;\n+\n+public interface TypedField {\n+\t\/** @return field name *\/\n+\tString getName();\n+\n+\t\/** @return field type *\/\n+\tType getType();\n+\n+\t\/** @return is the field content an array *\/\n+\tboolean isArray();\n+\n+\t\/**\n+\t * @return the associate {@link Annotation annotations}\n+\t *\/\n+\tList<Annotation> getAnnotations();\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/TypedField.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.api;\n+\n+import org.openjdk.jmc.flightrecorder.writer.TypedFieldImpl;\n+\n+\/** A fluent API for building typed fields lazily. *\/\n+public interface TypedFieldBuilder {\n+\t\/**\n+\t * Add an annotation\n+\t *\n+\t * @param type\n+\t *            annotation type\n+\t * @return a {@linkplain TypedFieldBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedFieldBuilder addAnnotation(Type type);\n+\n+\t\/**\n+\t * Add an annotation with a value\n+\t *\n+\t * @param type\n+\t *            annotation type\n+\t * @param value\n+\t *            annotation value\n+\t * @return a {@linkplain TypedFieldBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedFieldBuilder addAnnotation(Type type, String value);\n+\n+\t\/**\n+\t * Add a predefined annotation\n+\t *\n+\t * @param type\n+\t *            predefined annotation type\n+\t * @return a {@linkplain TypedFieldBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedFieldBuilder addAnnotation(Types.Predefined type);\n+\n+\t\/**\n+\t * Add a predefined annotation with a value\n+\t *\n+\t * @param type\n+\t *            predefined annotation type\n+\t * @param value\n+\t *            annotation value\n+\t * @return a {@linkplain TypedFieldBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedFieldBuilder addAnnotation(Types.Predefined type, String value);\n+\n+\t\/**\n+\t * Mark the field as holding an array value\n+\t *\n+\t * @return a {@linkplain TypedFieldBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedFieldBuilder asArray();\n+\n+\tTypedFieldImpl build();\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/TypedFieldBuilder.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.api;\n+\n+import org.openjdk.jmc.flightrecorder.writer.TypedFieldImpl;\n+\n+\/**\n+ * The composite of {@linkplain TypedFieldImpl} and corresponding {@link TypedValue TypedValue(s)}\n+ *\/\n+public interface TypedFieldValue {\n+\t\/** @return the corresponding {@linkplain TypedFieldImpl} *\/\n+\tTypedFieldImpl getField();\n+\n+\t\/**\n+\t * @return the associated value\n+\t * @throws IllegalArgumentException\n+\t *             if the field is an array\n+\t *\/\n+\tTypedValue getValue();\n+\n+\t\/**\n+\t * @return the associated values\n+\t * @throws IllegalArgumentException\n+\t *             if the field is not an array\n+\t *\/\n+\tTypedValue[] getValues();\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/TypedFieldValue.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.api;\n+\n+import java.util.List;\n+\n+public interface TypedValue {\n+\t\/** @return the type *\/\n+\tType getType();\n+\n+\t\/** @return the wrapped value *\/\n+\tObject getValue();\n+\n+\t\/** @return {@literal true} if this holds {@literal null} value *\/\n+\tboolean isNull();\n+\n+\t\/** @return the field values structure *\/\n+\tList<? extends TypedFieldValue> getFieldValues();\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/TypedValue.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.api;\n+\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+\/** A fluent API for lazy initialization of a composite type value *\/\n+public interface TypedValueBuilder {\n+\tType getType();\n+\n+\t\/**\n+\t * Put a named field value\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param value\n+\t *            field value\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, byte value);\n+\n+\t\/**\n+\t * Put a named field array of values\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param values\n+\t *            field values\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, byte[] values);\n+\n+\t\/**\n+\t * Put a named field value\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param value\n+\t *            field value\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, char value);\n+\n+\t\/**\n+\t * Put a named field array of values\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param values\n+\t *            field values\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, char[] values);\n+\n+\t\/**\n+\t * Put a named field value\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param value\n+\t *            field value\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, short value);\n+\n+\t\/**\n+\t * Put a named field array of values\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param values\n+\t *            field values\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, short[] values);\n+\n+\t\/**\n+\t * Put a named field value\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param value\n+\t *            field value\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, int value);\n+\n+\t\/**\n+\t * Put a named field array of values\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param values\n+\t *            field values\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, int[] values);\n+\n+\t\/**\n+\t * Put a named field value\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param value\n+\t *            field value\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, long value);\n+\n+\t\/**\n+\t * Put a named field array of values\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param values\n+\t *            field values\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, long[] values);\n+\n+\t\/**\n+\t * Put a named field value\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param value\n+\t *            field value\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, float value);\n+\n+\t\/**\n+\t * Put a named field array of values\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param values\n+\t *            field values\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, float[] values);\n+\n+\t\/**\n+\t * Put a named field value\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param value\n+\t *            field value\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, double value);\n+\n+\t\/**\n+\t * Put a named field array of values\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param values\n+\t *            field values\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, double[] values);\n+\n+\t\/**\n+\t * Put a named field value\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param value\n+\t *            field value\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, boolean value);\n+\n+\t\/**\n+\t * Put a named field array of values\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param values\n+\t *            field values\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, boolean[] values);\n+\n+\t\/**\n+\t * Put a named field value\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param value\n+\t *            field value\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, String value);\n+\n+\t\/**\n+\t * Put a named field array of values\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param values\n+\t *            field values\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, String[] values);\n+\n+\t\/**\n+\t * Put a named field value\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param valueBuilder\n+\t *            field value builder\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, TypedValueBuilder valueBuilder);\n+\n+\t\/**\n+\t * Put a named field value\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param value\n+\t *            field value\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, TypedValue value);\n+\n+\t\/**\n+\t * Put a named field array of values\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param values\n+\t *            field values\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, TypedValue ... values);\n+\n+\t\/**\n+\t * Put a named field lazily evaluated value\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param fieldValueCallback\n+\t *            field value builder\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putField(String name, Consumer<TypedValueBuilder> fieldValueCallback);\n+\n+\t\/**\n+\t * Put a named field array of lazily evaluated values\n+\t *\n+\t * @param name\n+\t *            field name\n+\t * @param callback1\n+\t *            first field value builder callback\n+\t * @param callback2\n+\t *            second field value builder callback\n+\t * @param otherCallbacks\n+\t *            other field value builder callbacks field value builders\n+\t * @return a {@linkplain TypedValueBuilder} instance for invocation chaining\n+\t *\/\n+\tTypedValueBuilder putFields(\n+\t\tString name, Consumer<TypedValueBuilder> callback1, Consumer<TypedValueBuilder> callback2,\n+\t\tConsumer<TypedValueBuilder> ... otherCallbacks);\n+\n+\tMap<String, ? extends TypedFieldValue> build();\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/TypedValueBuilder.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.api;\n+\n+import org.openjdk.jmc.flightrecorder.writer.ResolvableType;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+\n+public abstract class Types {\n+\t\/**\n+\t * Retrieve the given type or create it a-new if it hasn't been added yet.\n+\t *\n+\t * @param type\n+\t *            the type to retrieve\n+\t * @param builderCallback\n+\t *            will be called lazily when the type is about to be initialized\n+\t * @return the corresponding {@link Type type} instance\n+\t *\/\n+\tpublic abstract Type getOrAdd(Predefined type, Consumer<TypeStructureBuilder> builderCallback);\n+\n+\t\/**\n+\t * Retrieve the given type or create it a-new if it hasn't been added yet.\n+\t *\n+\t * @param name\n+\t *            the name of the type to retrieve\n+\t * @param builderCallback\n+\t *            will be called lazily when the type is about to be initialized\n+\t * @return the corresponding {@link Type type} instance\n+\t *\/\n+\tpublic abstract Type getOrAdd(String name, Consumer<TypeStructureBuilder> builderCallback);\n+\n+\t\/**\n+\t * Retrieve the given type or create it a-new if it hasn't been added yet.\n+\t *\n+\t * @param type\n+\t *            the type to retrieve\n+\t * @param supertype\n+\t *            the super type name\n+\t * @param builderCallback\n+\t *            will be called lazily when the type is about to be initialized\n+\t * @return the corresponding {@link Type type} instance\n+\t *\/\n+\tpublic abstract Type getOrAdd(Predefined type, String supertype, Consumer<TypeStructureBuilder> builderCallback);\n+\n+\t\/**\n+\t * Retrieve the given type or create it a-new if it hasn't been added yet.\n+\t *\n+\t * @param name\n+\t *            the name of the type to retrieve\n+\t * @param supertype\n+\t *            the super type name\n+\t * @param builderCallback\n+\t *            will be called lazily when the type is about to be initialized\n+\t * @return the corresponding {@link Type type} instance\n+\t *\/\n+\tpublic abstract Type getOrAdd(String name, String supertype, Consumer<TypeStructureBuilder> builderCallback);\n+\n+\tpublic abstract Type getOrAdd(String name, String supertype, TypeStructure typeStructure);\n+\n+\t\/**\n+\t * Retrieve the type by its name.\n+\t *\n+\t * @param name\n+\t *            the type name\n+\t * @return the registered {@link Type type} or {@literal null}\n+\t *\/\n+\tpublic abstract Type getType(String name);\n+\n+\t\/**\n+\t * Retrieve the type by its name. If the type hasn't been added yet a\n+\t * {@linkplain ResolvableType} wrapper may be returned.\n+\t *\n+\t * @param name\n+\t *            the type name\n+\t * @param asResolvable\n+\t *            if {@literal true} a {@linkplain ResolvableType} wrapper will be returned instead\n+\t *            of {@literal null} for non-existent type\n+\t * @return an existing {@link Type} type, {@literal null} or a {@linkplain ResolvableType}\n+\t *         wrapper\n+\t *\/\n+\tpublic abstract Type getType(String name, boolean asResolvable);\n+\n+\t\/**\n+\t * A convenience shortcut to get a {@linkplain Type} instance corresponding to the\n+\t * {@linkplain Predefined} type\n+\t *\n+\t * @param type\n+\t *            the predefined\/enum type\n+\t * @return the registered {@linkplain Type} instance or a {@linkplain ResolvableType} wrapper\n+\t *\/\n+\tpublic abstract Type getType(Predefined type);\n+\n+\tpublic abstract TypeStructureBuilder typeStructureBuilder();\n+\n+\t\/**\n+\t * @param fieldName\n+\t *            field name\n+\t * @param fieldType\n+\t *            field type\n+\t * @return a new {@linkplain TypedFieldBuilder} instance for a named field of the given type\n+\t *\/\n+\tpublic abstract TypedFieldBuilder fieldBuilder(String fieldName, Type fieldType);\n+\n+\t\/**\n+\t * @param fieldName\n+\t *            field name\n+\t * @param fieldType\n+\t *            field type\n+\t * @return a new {@linkplain TypedFieldBuilder} instance for a named field of the given type\n+\t *\/\n+\tpublic abstract TypedFieldBuilder fieldBuilder(String fieldName, Builtin fieldType);\n+\n+\t\/** A {@link Type type} predefined by the writer *\/\n+\tpublic interface Predefined extends NamedType {\n+\t}\n+\n+\t\/** Built-in types *\/\n+\tpublic enum Builtin implements Predefined {\n+\t\tBYTE(\"byte\", byte.class),\n+\t\tCHAR(\"char\", char.class),\n+\t\tSHORT(\"short\", short.class),\n+\t\tINT(\"int\", int.class),\n+\t\tLONG(\"long\", long.class),\n+\t\tFLOAT(\"float\", float.class),\n+\t\tDOUBLE(\"double\", double.class),\n+\t\tBOOLEAN(\"boolean\", boolean.class),\n+\t\tSTRING(\"java.lang.String\", String.class);\n+\n+\t\tprivate static Map<String, Builtin> NAME_MAP;\n+\t\tprivate final String typeName;\n+\t\tprivate final Class<?> type;\n+\n+\t\tBuiltin(String name, Class<?> type) {\n+\t\t\taddName(name);\n+\t\t\tthis.typeName = name;\n+\t\t\tthis.type = type;\n+\t\t}\n+\n+\t\tprivate static Map<String, Builtin> getNameMap() {\n+\t\t\tif (NAME_MAP == null) {\n+\t\t\t\tNAME_MAP = new HashMap<>();\n+\t\t\t}\n+\t\t\treturn NAME_MAP;\n+\t\t}\n+\n+\t\tprivate void addName(String name) {\n+\t\t\tgetNameMap().put(name, this);\n+\t\t}\n+\n+\t\tpublic static boolean hasType(String name) {\n+\t\t\treturn getNameMap().containsKey(name);\n+\t\t}\n+\n+\t\tpublic static Builtin ofName(String name) {\n+\t\t\treturn getNameMap().get(name);\n+\t\t}\n+\n+\t\tpublic static Builtin ofType(Type type) {\n+\t\t\treturn ofName(type.getTypeName());\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getTypeName() {\n+\t\t\treturn typeName;\n+\t\t}\n+\n+\t\tpublic Class<?> getTypeClass() {\n+\t\t\treturn type;\n+\t\t}\n+\t}\n+\n+\t\/** Types (subset of) defined by the JFR JVM implementation *\/\n+\tpublic enum JDK implements Predefined {\n+\t\tTICKSPAN(\"jdk.type.Tickspan\"),\n+\t\tTICKS(\"jdk.type.Ticks\"),\n+\t\tTHREAD_GROUP(\"jdk.types.ThreadGroup\"),\n+\t\tTHREAD(\"java.lang.Thread\"),\n+\t\tSTACK_TRACE(\"jdk.types.StackTrace\"),\n+\t\tSTACK_FRAME(\"jdk.types.StackFrame\"),\n+\t\tMETHOD(\"jdk.types.Method\"),\n+\t\tFRAME_TYPE(\"jdk.types.FrameType\"),\n+\t\tCLASS(\"java.lang.Class\"),\n+\t\tSYMBOL(\"jdk.types.Symbol\"),\n+\t\tCLASS_LOADER(\"jdk.type.ClassLoader\"),\n+\t\tPACKAGE(\"jdk.types.Package\"),\n+\t\tMODULE(\"jdk.types.Module\"),\n+\t\tANNOTATION_LABEL(\"jdk.jfr.Label\"),\n+\t\tANNOTATION_CONTENT_TYPE(\"jdk.jfr.ContentType\"),\n+\t\tANNOTATION_NAME(\"jdk.jfr.Name\"),\n+\t\tANNOTATION_DESCRIPTION(\"jdk.jfr.Description\"),\n+\t\tANNOTATION_TIMESTAMP(\"jdk.jfr.Timestamp\"),\n+\t\tANNOTATION_TIMESPAN(\"jdk.jfr.Timespan\"),\n+\t\tANNOTATION_UNSIGNED(\"jdk.jfr.Unsigned\");\n+\n+\t\tprivate final String typeName;\n+\n+\t\tJDK(String name) {\n+\t\t\tthis.typeName = name;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String getTypeName() {\n+\t\t\treturn typeName;\n+\t\t}\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/api\/Types.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.util;\n+\n+import java.util.Objects;\n+\n+\/** Compute hash code which will never be 0 *\/\n+public final class NonZeroHashCode {\n+\tpublic static int hash(Object ... values) {\n+\t\tint code = Objects.hash(values);\n+\t\treturn code == 0 ? 1 : code; \/\/ if the computed hash is 0 bump it up to 1\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/util\/NonZeroHashCode.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer.util;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+\n+import java.util.Comparator;\n+\n+\/**\n+ * A {@linkplain Type} comparator based on the 'is-used' relationship.\n+ * <ol>\n+ * <li>Given two types T1 and T2, T1 will be considered 'less-than' T2 if T1 is used by T2\n+ * transitively.\n+ * <li>Type T1 is considered to be 'used' by type T2 if any field of T2 is of type T1 or T1 is used\n+ * by any T2 field type TF.\n+ * <\/ol>\n+ *\/\n+public final class TypeByUsageComparator implements Comparator<Type> {\n+\tpublic static final TypeByUsageComparator INSTANCE = new TypeByUsageComparator();\n+\n+\t@Override\n+\tpublic int compare(Type t1, Type t2) {\n+\t\tif (t1 == t2) {\n+\t\t\treturn 0;\n+\t\t}\n+\t\tif (t1 == null) {\n+\t\t\treturn -1;\n+\t\t}\n+\t\tif (t2 == null) {\n+\t\t\treturn 1;\n+\t\t}\n+\t\treturn t1.isUsedBy(t2) ? -1 : 1;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/util\/TypeByUsageComparator.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+\n+class AnnotationTest {\n+\tprivate TypesImpl types;\n+\n+\t@BeforeEach\n+\tvoid setup() {\n+\t\tConstantPools constantPools = new ConstantPools();\n+\t\tMetadataImpl metadata = new MetadataImpl(constantPools);\n+\t\ttypes = new TypesImpl(metadata);\n+\t}\n+\n+\t@Test\n+\tvoid validAnnotationTypeNullValue() {\n+\t\tTypeImpl type = types.getType(TypesImpl.JDK.ANNOTATION_LABEL);\n+\t\tAnnotation annotation = new Annotation(type, null);\n+\t\tassertNotNull(annotation);\n+\t\tassertNull(annotation.getValue());\n+\t\tassertEquals(type, annotation.getType());\n+\t}\n+\n+\t@Test\n+\tvoid validAnnotationTypeWithValue() {\n+\t\tString value = \"value\";\n+\t\tTypeImpl type = types.getType(TypesImpl.JDK.ANNOTATION_LABEL);\n+\t\tAnnotation annotation = new Annotation(type, value);\n+\t\tassertNotNull(annotation);\n+\t\tassertEquals(value, annotation.getValue());\n+\t\tassertEquals(type, annotation.getType());\n+\t}\n+\n+\t@Test\n+\tvoid invalidAnnotationType() {\n+\t\tTypeImpl type = types.getType(TypesImpl.Builtin.STRING);\n+\t\tassertThrows(IllegalArgumentException.class, () -> new Annotation(type, null));\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/AnnotationTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mockito;\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n+\n+class BuiltinTypeTest {\n+\tprivate static final long TYPE_ID = 1L;\n+\tprivate BuiltinType instance;\n+\tprivate TypesImpl types;\n+\n+\t@BeforeEach\n+\tvoid setUp() {\n+\t\tMetadataImpl metadata = Mockito.mock(MetadataImpl.class);\n+\t\ttypes = new TypesImpl(metadata);\n+\t\tinstance = new BuiltinType(TYPE_ID, TypesImpl.Builtin.INT, Mockito.mock(ConstantPools.class), types);\n+\t}\n+\n+\t@Test\n+\tvoid isBuiltin() {\n+\t\tassertTrue(instance.isBuiltin());\n+\t}\n+\n+\t@Test\n+\tvoid isResolved() {\n+\t\tassertTrue(instance.isResolved());\n+\t}\n+\n+\t@Test\n+\tvoid nullValue() {\n+\t\tTypedValueImpl value = instance.nullValue();\n+\t\tassertNotNull(value);\n+\t\tassertTrue(value.isNull());\n+\t\tassertEquals(value, instance.nullValue());\n+\t}\n+\n+\t@Test\n+\tvoid getFields() {\n+\t\tassertTrue(instance.getFields().isEmpty());\n+\t}\n+\n+\t@Test\n+\tvoid getField() {\n+\t\tassertThrows(IllegalArgumentException.class, () -> instance.getField(\"field\"));\n+\t}\n+\n+\t@Test\n+\tvoid getAnnotations() {\n+\t\tassertTrue(instance.getAnnotations().isEmpty());\n+\t}\n+\n+\t@Test\n+\tvoid getId() {\n+\t\tassertEquals(TYPE_ID, instance.getId());\n+\t}\n+\n+\t@Test\n+\tvoid getTypeName() {\n+\t\tassertEquals(TypesImpl.Builtin.INT.getTypeName(), instance.getTypeName());\n+\t}\n+\n+\t@Test\n+\tvoid getSupertype() {\n+\t\tassertNull(instance.getSupertype());\n+\t}\n+\n+\t@Test\n+\tvoid isUsedBy() {\n+\t\tTypeImpl other = new BuiltinType(TYPE_ID, TypesImpl.Builtin.STRING, Mockito.mock(ConstantPools.class), types);\n+\n+\t\tassertFalse(instance.isUsedBy(null));\n+\t\tassertFalse(instance.isUsedBy(instance));\n+\t\tassertFalse(instance.isUsedBy(other));\n+\t}\n+\n+\t@ParameterizedTest\n+\t@EnumSource(TypesImpl.Builtin.class)\n+\tvoid canAccept(TypesImpl.Builtin target) {\n+\t\tBaseType type = new BuiltinType(1, target, Mockito.mock(ConstantPools.class), types);\n+\t\tfor (TypesImpl.Builtin builtin : TypesImpl.Builtin.values()) {\n+\t\t\tfor (Object value : TypeUtils.getBuiltinValues(builtin)) {\n+\t\t\t\tassertEquals(target == builtin || value == null, type.canAccept(value)); \/\/ null is generally accepted\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@ParameterizedTest\n+\t@EnumSource(TypesImpl.Builtin.class)\n+\tvoid equality(TypesImpl.Builtin target) {\n+\t\tBaseType type1 = new BuiltinType(1, target, Mockito.mock(ConstantPools.class), types);\n+\t\tfor (TypesImpl.Builtin builtin : TypesImpl.Builtin.values()) {\n+\t\t\tBaseType type2 = new BuiltinType(1, builtin, Mockito.mock(ConstantPools.class), types);\n+\n+\t\t\tassertFalse(type1.equals(null));\n+\t\t\tassertTrue(type1.equals(type1));\n+\t\t\tassertEquals(target == builtin, type1.equals(type2));\n+\t\t\tassertEquals(target == builtin, type2.equals(type1));\n+\t\t}\n+\t}\n+\n+\t@ParameterizedTest\n+\t@EnumSource(TypesImpl.Builtin.class)\n+\tvoid asValue(TypesImpl.Builtin target) throws Exception {\n+\t\t\/\/ STRING builtin needs a constant pool; other builtins must not have a constant pool\n+\t\tConstantPools constantPools = Mockito.mock(ConstantPools.class);\n+\t\tMockito.when(constantPools.forType(ArgumentMatchers.any(TypeImpl.class)))\n+\t\t\t\t.thenAnswer(i -> new ConstantPool(i.getArgument(0)));\n+\n+\t\tBaseType type = new BuiltinType(1, target, target == TypesImpl.Builtin.STRING ? constantPools : null, types);\n+\t\tfor (TypesImpl.Builtin builtin : TypesImpl.Builtin.values()) {\n+\t\t\tfor (Object fromValue : TypeUtils.getBuiltinValues(builtin)) {\n+\t\t\t\tMethod asValueMethod = getAsValueMethod(builtin);\n+\n+\t\t\t\tif (target == builtin) {\n+\t\t\t\t\tTypedValueImpl typedValue = (TypedValueImpl) asValueMethod.invoke(type, fromValue);\n+\n+\t\t\t\t\tassertNotNull(typedValue);\n+\t\t\t\t\tassertEquals(fromValue, typedValue.getValue());\n+\t\t\t\t} else {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tasValueMethod.invoke(type, fromValue);\n+\t\t\t\t\t\t\/\/ for 'null' values there is no extra type info so really can't assert anything\n+\t\t\t\t\t\tif (fromValue != null) {\n+\t\t\t\t\t\t\tfail(\"Attempted conversion of a value of type '\" + builtin.getTypeClass() + \"' to '\"\n+\t\t\t\t\t\t\t\t\t+ target.getTypeClass() + \"'\");\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} catch (InvocationTargetException e) {\n+\t\t\t\t\t\tif (!(e.getCause() instanceof IllegalArgumentException)) {\n+\t\t\t\t\t\t\tfail(e);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tassertThrows(IllegalArgumentException.class, () -> type.asValue(v -> {\n+\t\t\tv.putField(\"f1\", \"no value\");\n+\t\t}));\n+\t}\n+\n+\tprivate static Method getAsValueMethod(TypesImpl.Builtin type) throws Exception {\n+\t\treturn BaseType.class.getMethod(\"asValue\", type.getTypeClass());\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/BuiltinTypeTest.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.lang.reflect.Modifier;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.openjdk.jmc.common.IMCStackTrace;\n+import org.openjdk.jmc.common.IMCThread;\n+import org.openjdk.jmc.common.item.Attribute;\n+import org.openjdk.jmc.common.item.IAttribute;\n+import org.openjdk.jmc.common.item.IItem;\n+import org.openjdk.jmc.common.item.IItemCollection;\n+import org.openjdk.jmc.common.item.IMemberAccessor;\n+import org.openjdk.jmc.common.unit.IQuantity;\n+import org.openjdk.jmc.common.unit.UnitLookup;\n+import org.openjdk.jmc.flightrecorder.JfrAttributes;\n+import org.openjdk.jmc.flightrecorder.JfrLoaderToolkit;\n+import org.openjdk.jmc.flightrecorder.writer.api.Recording;\n+import org.openjdk.jmc.flightrecorder.writer.api.Recordings;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedField;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValue;\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n+\n+class ChunkComplexTest {\n+\tprivate Recording recording;\n+\tprivate final Path jfrPath = Paths.get(\"\/tmp\", \"test.jfr\");\n+\n+\tpublic static final String EVENT_NAME = \"sample event\";\n+\tpublic static final String EVENT_MSG = \"Hello world\";\n+\n+\t@BeforeEach\n+\tvoid setup() throws Exception {\n+\t\trecording = Recordings.newRecording(jfrPath);\n+\t}\n+\n+\t@AfterEach\n+\tvoid teardown() throws Exception {\n+\t\trecording.close();\n+\t}\n+\n+\t@Test\n+\tvoid writeEvent() throws Exception {\n+\t\tTypes types = recording.getTypes();\n+\n+\t\tTypedField nameField = types.fieldBuilder(\"name\", Types.Builtin.STRING).build();\n+\n+\t\tType customSimpleType = recording.registerType(\"com.datadog.types.Simple\", b -> {\n+\t\t\tb.addField(\"message\", TypesImpl.Builtin.STRING);\n+\t\t});\n+\n+\t\tTypedField messageField = types.fieldBuilder(\"message\", customSimpleType).build();\n+\n+\t\tType eventType = recording.registerEventType(\"dd.SampleEvent\", eventTypeBuilder -> {\n+\t\t\teventTypeBuilder.addFields(nameField, messageField);\n+\t\t});\n+\n+\t\tTypedValue eventValue = eventType.asValue(access -> {\n+\t\t\taccess.putField(\"startTime\", System.nanoTime()).putField(\"name\", EVENT_NAME).putField(\"message\", EVENT_MSG)\n+\t\t\t\t\t.putField(\"eventThread\", threadAccess -> {\n+\t\t\t\t\t\tthreadAccess.putField(\"osName\", \"Java AWT-0\").putField(\"osThreadId\", 41953L)\n+\t\t\t\t\t\t\t\t.putField(\"javaName\", \"AWT-0\").putField(\"javaThreadId\", 11L)\n+\t\t\t\t\t\t\t\t.putField(\"group\", groupAcess -> {\n+\t\t\t\t\t\t\t\t\tgroupAcess.putField(\"name\", \"Main AWT Group\");\n+\t\t\t\t\t\t\t\t});\n+\t\t\t\t\t}).putField(\"stackTrace\", builder -> {\n+\t\t\t\t\t\t\/\/noinspection unchecked\n+\t\t\t\t\t\tbuilder.putField(\"truncated\", false).putFields(\"frames\", frame1 -> {\n+\t\t\t\t\t\t\tframe1.putField(\"type\", \"Interpreted\").putField(\"method\", method -> {\n+\t\t\t\t\t\t\t\tmethod.putField(\"type\", classType -> {\n+\t\t\t\t\t\t\t\t\tclassType.putField(\"name\", \"com.datadoghq.test.Main\").putField(\"package\", pkg -> {\n+\t\t\t\t\t\t\t\t\t\tpkg.putField(\"name\", \"com.datadoghq.test\");\n+\t\t\t\t\t\t\t\t\t}).putField(\"modifiers\", Modifier.PUBLIC | Modifier.FINAL);\n+\t\t\t\t\t\t\t\t}).putField(\"name\", \"main\").putField(\"descriptor\", \"([Ljava\/lang\/String;)V\")\n+\t\t\t\t\t\t\t\t\t\t.putField(\"modifiers\", Modifier.PUBLIC | Modifier.STATIC | Modifier.FINAL);\n+\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t}, frame2 -> {\n+\t\t\t\t\t\t\tframe2.putField(\"type\", \"JIT compiled\").putField(\"method\", method -> {\n+\t\t\t\t\t\t\t\tmethod.putField(\"type\", classType -> {\n+\t\t\t\t\t\t\t\t\tclassType.putField(\"name\", \"com.datadoghq.test.Main\").putField(\"package\", pkg -> {\n+\t\t\t\t\t\t\t\t\t\tpkg.putField(\"name\", \"com.datadoghq.test\");\n+\t\t\t\t\t\t\t\t\t}).putField(\"modifiers\", Modifier.PUBLIC | Modifier.FINAL);\n+\t\t\t\t\t\t\t\t}).putField(\"name\", \"doit\").putField(\"descriptor\", \"(Ljava\/lang\/String;)V\")\n+\t\t\t\t\t\t\t\t\t\t.putField(\"modifiers\", Modifier.PRIVATE | Modifier.STATIC | Modifier.FINAL);\n+\t\t\t\t\t\t\t});\n+\t\t\t\t\t\t});\n+\t\t\t\t\t});\n+\t\t});\n+\n+\t\trecording.writeEvent(eventValue).rotateChunk().writeEvent(eventValue).close();\n+\n+\t\t\/\/ sanity check to make sure the recording is loaded\n+\t\tIItemCollection events = JfrLoaderToolkit.loadEvents(jfrPath.toFile());\n+\n+\t\tIAttribute<String> nameAttr = Attribute.attr(\"name\", \"name\", UnitLookup.PLAIN_TEXT);\n+\t\tIAttribute<String> msgAttr = Attribute.attr(\"message\", \"message\", UnitLookup.PLAIN_TEXT);\n+\t\tassertTrue(events.hasItems());\n+\t\tint[] eventCount = new int[] {0};\n+\t\tevents.forEach(iitem -> {\n+\t\t\tIMemberAccessor<IMCStackTrace, IItem> stackTraceAccessor = JfrAttributes.EVENT_STACKTRACE\n+\t\t\t\t\t.getAccessor(iitem.getType());\n+\t\t\tIMemberAccessor<String, IItem> nameAcessor = nameAttr.getAccessor(iitem.getType());\n+\t\t\tIMemberAccessor<String, IItem> msgAcessor = msgAttr.getAccessor(iitem.getType());\n+\t\t\tIMemberAccessor<IMCThread, IItem> eventThreadAccessor = JfrAttributes.EVENT_THREAD\n+\t\t\t\t\t.getAccessor(iitem.getType());\n+\t\t\tIMemberAccessor<IQuantity, IItem> startTimeAccessor = JfrAttributes.START_TIME.getAccessor(iitem.getType());\n+\t\t\tiitem.forEach(item -> {\n+\t\t\t\teventCount[0]++;\n+\t\t\t\tassertEquals(EVENT_NAME, nameAcessor.getMember(item));\n+\t\t\t\tassertEquals(EVENT_MSG, msgAcessor.getMember(item));\n+\t\t\t\tassertNotNull(eventThreadAccessor.getMember(item));\n+\t\t\t\tIMCStackTrace stackTrace = stackTraceAccessor.getMember(item);\n+\t\t\t\tassertEquals(2, stackTrace.getFrames().size());\n+\n+\t\t\t\tSystem.out.println(startTimeAccessor.getMember(item).interactiveFormat());\n+\t\t\t});\n+\t\t});\n+\t\tassertEquals(2, eventCount[0]);\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/ChunkComplexTest.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mockito;\n+\n+class ChunkTest {\n+\tprivate Chunk instance;\n+\tprivate LEB128Writer writer;\n+\tprivate TypesImpl types;\n+\tprivate MetadataImpl metadata;\n+\n+\t@BeforeEach\n+\tvoid setup() {\n+\t\twriter = LEB128Writer.getInstance();\n+\t\tinstance = new Chunk();\n+\t\tmetadata = new MetadataImpl(new ConstantPools());\n+\t\ttypes = new TypesImpl(metadata);\n+\t}\n+\n+\t@Test\n+\tvoid writeEventWrongType() {\n+\t\tassertThrows(IllegalArgumentException.class,\n+\t\t\t\t() -> instance.writeEvent(types.getType(TypesImpl.Builtin.STRING).asValue(\"value\")));\n+\t}\n+\n+\t@Test\n+\tvoid writeNullValue() {\n+\t\tassertThrows(IllegalArgumentException.class, () -> instance.writeTypedValue(writer, null));\n+\t}\n+\n+\t@ParameterizedTest\n+\t@EnumSource(TypesImpl.Builtin.class)\n+\tvoid writeBuiltinValue(TypesImpl.Builtin target) {\n+\t\tfor (Object value : TypeUtils.getBuiltinValues(target)) {\n+\t\t\tTypeImpl type = types.getType(target);\n+\t\t\tTypedValueImpl tv = new TypedValueImpl(type, value, 1);\n+\t\t\tinstance.writeTypedValue(writer, tv);\n+\t\t\tinstance.writeTypedValue(writer, type.nullValue());\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid writeUnknownBuiltin() {\n+\t\tTypeImpl type = Mockito.mock(BaseType.class,\n+\t\t\t\tMockito.withSettings().useConstructor(1L, \"unknown.Builtin\", null, types));\n+\t\tMockito.when(type.isBuiltin()).thenReturn(true);\n+\t\tMockito.when(type.canAccept(ArgumentMatchers.any())).thenReturn(true);\n+\n+\t\tassertThrows(IllegalArgumentException.class,\n+\t\t\t\t() -> instance.writeTypedValue(writer, new TypedValueImpl(type, \"hello\", 10)));\n+\t}\n+\n+\t@Test\n+\tvoid writeCustomNoCP() {\n+\t\tTypeImpl stringType = types.getType(TypesImpl.Builtin.STRING);\n+\t\tList<TypedFieldImpl> fields = Arrays.asList(new TypedFieldImpl(stringType, \"string\", false),\n+\t\t\t\tnew TypedFieldImpl(stringType, \"strings\", true));\n+\t\tTypeStructureImpl structure = new TypeStructureImpl(fields, Collections.emptyList());\n+\n+\t\tTypeImpl type = new CompositeTypeImpl(1000, \"custom.Type\", null, structure, null, types);\n+\n+\t\tinstance.writeTypedValue(writer, type.asValue(v -> {\n+\t\t\tv.putField(\"string\", \"value1\").putField(\"strings\", new String[] {\"value2\", \"value4\"});\n+\t\t}));\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/ChunkTest.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+\n+class CompositeTypeImplTest {\n+\tprivate static final String TYPE_NAME = \"test.Type\";\n+\tprivate static final String FIELD_NAME = \"field1\";\n+\tprivate static final String PARENT_FIELD_NAME = \"parent\";\n+\tprivate static final String FIELD_VALUE = \"hello\";\n+\tpublic static final int TYPE_ID = 1;\n+\tprivate CompositeTypeImpl instance;\n+\tprivate TypesImpl types;\n+\n+\t@BeforeEach\n+\tvoid setUp() {\n+\t\tConstantPools constantPools = new ConstantPools();\n+\t\tMetadataImpl metadata = new MetadataImpl(constantPools);\n+\t\ttypes = new TypesImpl(metadata);\n+\n+\t\tList<TypedFieldImpl> fields = new ArrayList<>();\n+\t\tList<Annotation> annotations = new ArrayList<>();\n+\n+\t\tfields.add(new TypedFieldImpl(types.getType(TypesImpl.Builtin.STRING), FIELD_NAME));\n+\t\tfields.add(new TypedFieldImpl(SelfType.INSTANCE, PARENT_FIELD_NAME));\n+\t\tannotations.add(new Annotation(types.getType(TypesImpl.JDK.ANNOTATION_NAME), \"test.Type\"));\n+\n+\t\tTypeStructureImpl structure = new TypeStructureImpl(fields, annotations);\n+\t\tinstance = new CompositeTypeImpl(TYPE_ID, TYPE_NAME, null, structure, constantPools, types);\n+\t}\n+\n+\t@Test\n+\tvoid typeSelfReferenceResolved() {\n+\t\tfor (TypedFieldImpl field : instance.getFields()) {\n+\t\t\tif (field.getName().equals(\"parent\")) {\n+\t\t\t\tassertNotEquals(SelfType.INSTANCE, field.getType());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid isBuiltin() {\n+\t\tassertFalse(instance.isBuiltin());\n+\t}\n+\n+\t@Test\n+\tvoid getFields() {\n+\t\tassertEquals(2, instance.getFields().size());\n+\t}\n+\n+\t@Test\n+\tvoid getField() {\n+\t\tassertNotNull(instance.getField(FIELD_NAME));\n+\t\tassertNotNull(instance.getField(PARENT_FIELD_NAME));\n+\t}\n+\n+\t@Test\n+\tvoid isResolved() {\n+\t\tassertTrue(instance.isResolved());\n+\t}\n+\n+\t@Test\n+\tvoid nullValue() {\n+\t\tTypedValueImpl value = instance.nullValue();\n+\t\tassertNotNull(value);\n+\t\tassertTrue(value.isNull());\n+\t\tassertEquals(value, instance.nullValue());\n+\t}\n+\n+\t@Test\n+\tvoid getAnnotations() {\n+\t\tassertEquals(1, instance.getAnnotations().size());\n+\t}\n+\n+\t@Test\n+\tvoid canAccept() {\n+\t\tfor (TypesImpl.Builtin builtin : TypesImpl.Builtin.values()) {\n+\t\t\tfor (Object builtinVal : TypeUtils.getBuiltinValues(builtin)) {\n+\t\t\t\t\/\/ null is generally accepted\n+\t\t\t\tassertEquals(builtinVal == null, instance.canAccept(builtinVal));\n+\t\t\t}\n+\t\t}\n+\t\tTypedValueImpl value = instance.asValue(builder -> {\n+\t\t\tbuilder.putField(FIELD_NAME, FIELD_VALUE);\n+\t\t});\n+\t\tassertTrue(instance.canAccept(value));\n+\t}\n+\n+\t@Test\n+\tvoid getId() {\n+\t\tassertEquals(TYPE_ID, instance.getId());\n+\t}\n+\n+\t@Test\n+\tvoid getTypeName() {\n+\t\tassertEquals(TYPE_NAME, instance.getTypeName());\n+\t}\n+\n+\t@Test\n+\tvoid getSupertype() {\n+\t\tassertNull(instance.getSupertype());\n+\t}\n+\n+\t@Test\n+\tvoid isUsedBySimple() {\n+\t\tTypeImpl other = types.getType(TypesImpl.Builtin.STRING);\n+\n+\t\t\/\/ has a self-referenced field\n+\t\tassertTrue(instance.isUsedBy(instance));\n+\t\tassertFalse(instance.isUsedBy(other));\n+\t\tassertTrue(other.isUsedBy(instance));\n+\t}\n+\n+\t@Test\n+\tvoid isUsedByComplex() {\n+\t\tTypeImpl target = types.getType(TypesImpl.Builtin.INT);\n+\n+\t\tTypeImpl main = types.getOrAdd(\"custom.Main\", type -> {\n+\t\t\ttype.addField(\"parent\", type.selfType()).addField(\"field\", TypesImpl.Builtin.STRING).addField(\"other\",\n+\t\t\t\t\ttypes.getType(\"custom.Other\", true));\n+\t\t});\n+\n+\t\tTypeImpl other = types.getOrAdd(\"custom.Other\", type -> {\n+\t\t\ttype.addField(\"loopback\", main).addField(\"field\", TypesImpl.Builtin.INT);\n+\t\t});\n+\t\ttypes.resolveAll();\n+\n+\t\tassertFalse(instance.isUsedBy(null));\n+\t\t\/\/ has a self-referenced field\n+\t\tassertTrue(main.isUsedBy(main));\n+\t\tassertTrue(main.isUsedBy(other));\n+\t\tassertTrue(target.isUsedBy(main));\n+\t}\n+\n+\t@Test\n+\tvoid testEquality() {\n+\t\tTypeImpl type1 = types.getType(TypesImpl.Builtin.STRING);\n+\t\tTypeImpl type2 = types.getType(TypesImpl.Builtin.INT);\n+\t\tTypeImpl type3 = types.getOrAdd(\"type.Custom\", t -> {\n+\t\t\tt.addField(\"field1\", types.getType(TypesImpl.Builtin.STRING)).addField(\"field2\",\n+\t\t\t\t\ttypes.getType(TypesImpl.Builtin.STRING));\n+\t\t});\n+\n+\t\tassertEquals(type1, type1);\n+\t\tassertEquals(type2, type2);\n+\t\tassertEquals(type3, type3);\n+\t\tassertNotEquals(type1, type2);\n+\t\tassertNotEquals(type1, type3);\n+\t\tassertNotEquals(type2, type1);\n+\t\tassertNotEquals(type2, type3);\n+\t\tassertNotEquals(type3, type1);\n+\t\tassertNotEquals(type3, type2);\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/CompositeTypeImplTest.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mockito;\n+\n+class ConstantPoolTest {\n+\tprivate ConstantPool instance;\n+\n+\t@BeforeEach\n+\tvoid setUp() {\n+\t\tTypeImpl type = Mockito.mock(TypeImpl.class);\n+\t\tMockito.when(type.canAccept(ArgumentMatchers.any())).thenReturn(true);\n+\n+\t\tTypedValueImpl nullValue = new TypedValueImpl(type, null, 0);\n+\n+\t\tMockito.when(type.nullValue()).thenReturn(nullValue);\n+\n+\t\tinstance = new ConstantPool(type);\n+\t}\n+\n+\t@Test\n+\tvoid addOrGetNull() {\n+\t\tTypedValueImpl value = instance.addOrGet(null);\n+\t\tassertNotNull(value);\n+\t\tassertTrue(value.isNull());\n+\t}\n+\n+\t@Test\n+\tvoid addOrGetNonNull() {\n+\t\tObject objectValue = \"hello\";\n+\t\tTypedValueImpl value = instance.addOrGet(objectValue);\n+\t\tassertNotNull(value);\n+\t\tassertFalse(value.isNull());\n+\t\tassertEquals(objectValue, value.getValue());\n+\t}\n+\n+\t@Test\n+\tvoid getNegativeIndex() {\n+\t\tassertNull(instance.get(-1));\n+\t}\n+\n+\t@Test\n+\tvoid getNonExistent() {\n+\t\tassertNull(instance.get(100));\n+\t}\n+\n+\t@Test\n+\tvoid get() {\n+\t\tObject objectValue = \"hello\";\n+\t\tTypedValueImpl value = instance.addOrGet(objectValue);\n+\n+\t\tassertEquals(value, instance.get(value.getConstantPoolIndex()));\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/ConstantPoolTest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+class ConstantPoolWriterTest {\n+\tprivate ConstantPools constantPools;\n+\tprivate TypesImpl types;\n+\tprivate LEB128Writer writer;\n+\tprivate TypeImpl customType;\n+\tprivate ConstantPool instance;\n+\n+\t@BeforeEach\n+\tvoid setup() {\n+\t\tconstantPools = new ConstantPools();\n+\t\tMetadataImpl metadata = new MetadataImpl(constantPools);\n+\t\ttypes = new TypesImpl(metadata);\n+\n+\t\twriter = LEB128Writer.getInstance();\n+\n+\t\tcustomType = types.getOrAdd(\"custom.Type\", t -> {\n+\t\t\tt.addField(\"field\", TypesImpl.Builtin.STRING);\n+\t\t});\n+\n+\t\tinstance = new ConstantPool(customType);\n+\t}\n+\n+\t@Test\n+\tvoid writeNull() {\n+\t\tfor (boolean useCpFlag : new boolean[] {true, false}) {\n+\t\t\tassertThrows(NullPointerException.class, () -> instance.writeValueType(writer, null, useCpFlag));\n+\t\t\tassertThrows(NullPointerException.class, () -> instance.writeBuiltinType(writer, null, useCpFlag));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid writeNullValue() {\n+\t\tfor (boolean useCpFlag : new boolean[] {true, false}) {\n+\t\t\tinstance.writeValueType(writer, (TypedValueImpl) customType.nullValue(), useCpFlag);\n+\t\t\tfor (TypesImpl.Builtin builtin : TypesImpl.Builtin.values()) {\n+\t\t\t\tinstance.writeBuiltinType(writer, types.getType(builtin).nullValue(), useCpFlag);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid writeBuiltinByte() {\n+\t\tfor (boolean useCpFlag : new boolean[] {true, false}) {\n+\t\t\tinstance.writeBuiltinType(writer, types.getType(TypesImpl.Builtin.BYTE).asValue((byte) 1), useCpFlag);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid writeBuiltinChar() {\n+\t\tfor (boolean useCpFlag : new boolean[] {true, false}) {\n+\t\t\tinstance.writeBuiltinType(writer, types.getType(TypesImpl.Builtin.CHAR).asValue((char) 1), useCpFlag);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid writeBuiltinShort() {\n+\t\tfor (boolean useCpFlag : new boolean[] {true, false}) {\n+\t\t\tinstance.writeBuiltinType(writer, types.getType(TypesImpl.Builtin.SHORT).asValue((short) 1), useCpFlag);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid writeBuiltinInt() {\n+\t\tfor (boolean useCpFlag : new boolean[] {true, false}) {\n+\t\t\tinstance.writeBuiltinType(writer, types.getType(TypesImpl.Builtin.INT).asValue((int) 1), useCpFlag);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid writeBuiltinLong() {\n+\t\tfor (boolean useCpFlag : new boolean[] {true, false}) {\n+\t\t\tinstance.writeBuiltinType(writer, types.getType(TypesImpl.Builtin.LONG).asValue((long) 1), useCpFlag);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid writeBuiltinFloat() {\n+\t\tfor (boolean useCpFlag : new boolean[] {true, false}) {\n+\t\t\tinstance.writeBuiltinType(writer, types.getType(TypesImpl.Builtin.FLOAT).asValue((float) 1), useCpFlag);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid writeBuiltinDouble() {\n+\t\tfor (boolean useCpFlag : new boolean[] {true, false}) {\n+\t\t\tinstance.writeBuiltinType(writer, types.getType(TypesImpl.Builtin.DOUBLE).asValue((double) 1), useCpFlag);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid writeBuiltinBoolean() {\n+\t\tfor (boolean useCpFlag : new boolean[] {true, false}) {\n+\t\t\tinstance.writeBuiltinType(writer, types.getType(TypesImpl.Builtin.BOOLEAN).asValue(true), useCpFlag);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid writeBuiltinString() {\n+\t\tfor (boolean useCpFlag : new boolean[] {true, false}) {\n+\t\t\tinstance.writeBuiltinType(writer, types.getType(TypesImpl.Builtin.STRING).asValue(\"1\"), useCpFlag);\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid writeCustomAsBuiltin() {\n+\t\tTypedValueImpl value = customType.asValue(v -> v.putField(\"field\", \"value\"));\n+\n+\t\tfor (boolean useCpFlag : new boolean[] {true, false}) {\n+\t\t\tassertThrows(IllegalArgumentException.class, () -> instance.writeBuiltinType(writer, value, useCpFlag));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid writeString() {\n+\t\tTypeImpl type = types.getType(TypesImpl.Builtin.STRING);\n+\t\tfor (boolean useCpFlag : new boolean[] {true, false}) {\n+\t\t\tfor (String strVal : new String[] {null, \"\", \"value\"}) {\n+\t\t\t\tinstance.writeBuiltinType(writer, type.asValue(strVal), useCpFlag);\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/ConstantPoolWriterTest.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import java.util.Iterator;\n+import java.util.Spliterator;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+\n+class ConstantPoolsTest {\n+\tprivate ConstantPools instance;\n+\tprivate TypeImpl type1;\n+\tprivate TypeImpl type2;\n+\n+\t@BeforeEach\n+\tvoid setUp() {\n+\t\tinstance = new ConstantPools();\n+\t\ttype1 = Mockito.mock(TypeImpl.class);\n+\t\ttype2 = Mockito.mock(TypeImpl.class);\n+\t}\n+\n+\t@Test\n+\tvoid forTypeWithCP() {\n+\t\tMockito.when(type1.hasConstantPool()).thenReturn(true);\n+\t\tassertNotNull(instance.forType(type1));\n+\t}\n+\n+\t@Test\n+\tvoid forTypeWithoutCP() {\n+\t\tMockito.when(type1.hasConstantPool()).thenReturn(false);\n+\t\tassertThrows(IllegalArgumentException.class, () -> instance.forType(type1));\n+\t}\n+\n+\t@Test\n+\tvoid size() {\n+\t\tassertEquals(0, instance.size());\n+\t\taddConstantPool();\n+\t\tassertEquals(2, instance.size());\n+\t}\n+\n+\t@Test\n+\tvoid iteratorEmpty() {\n+\t\tIterator<ConstantPool> iterator = instance.iterator();\n+\t\tassertNotNull(iterator);\n+\t\tassertFalse(iterator.hasNext());\n+\t}\n+\n+\t@Test\n+\tvoid iterator() {\n+\t\taddConstantPool();\n+\t\tIterator<ConstantPool> iterator = instance.iterator();\n+\t\tassertNotNull(iterator);\n+\t\tassertTrue(iterator.hasNext());\n+\t\tassertNotNull(iterator.next());\n+\t}\n+\n+\t@Test\n+\tvoid spliteratorEmpty() {\n+\t\tSpliterator<ConstantPool> iterator = instance.spliterator();\n+\t\tassertNotNull(iterator);\n+\t\tAtomicReference<ConstantPool> pool = new AtomicReference<>();\n+\t\tassertFalse(iterator.tryAdvance(pool::set));\n+\t\tassertNull(pool.get());\n+\t}\n+\n+\t@Test\n+\tvoid spliterator() {\n+\t\taddConstantPool();\n+\t\tSpliterator<ConstantPool> iterator = instance.spliterator();\n+\t\tassertNotNull(iterator);\n+\t\tAtomicReference<ConstantPool> pool = new AtomicReference<>();\n+\t\tassertTrue(iterator.tryAdvance(pool::set));\n+\t\tassertNotNull(pool.get());\n+\t}\n+\n+\t@Test\n+\tvoid forEachEmpty() {\n+\t\tAtomicInteger cntr = new AtomicInteger();\n+\t\tinstance.forEach(cp -> cntr.incrementAndGet());\n+\t\tassertEquals(0, cntr.get());\n+\t}\n+\n+\t@Test\n+\tvoid forEach() {\n+\t\taddConstantPool();\n+\t\tAtomicInteger cntr = new AtomicInteger();\n+\t\tinstance.forEach(cp -> cntr.incrementAndGet());\n+\t\tassertNotEquals(0, cntr.get());\n+\t}\n+\n+\tprivate void addConstantPool() {\n+\t\tMockito.when(type1.hasConstantPool()).thenReturn(true);\n+\t\tMockito.when(type2.hasConstantPool()).thenReturn(true);\n+\t\tinstance.forType(type1);\n+\t\tinstance.forType(type2);\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/ConstantPoolsTest.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+import org.openjdk.jmc.flightrecorder.writer.api.NamedType;\n+import org.openjdk.jmc.flightrecorder.writer.api.Type;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValueBuilder;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedFieldBuilder;\n+\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+final class InvalidType implements TypeImpl {\n+\t@Override\n+\tpublic long getId() {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic boolean isBuiltin() {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic boolean isSimple() {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic boolean isResolved() {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasConstantPool() {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic String getSupertype() {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic List<TypedFieldImpl> getFields() {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldImpl getField(String name) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic List<Annotation> getAnnotations() {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic boolean canAccept(Object value) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(String value) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(byte value) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(char value) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(short value) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(int value) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(long value) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(float value) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(double value) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(boolean value) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(Consumer<TypedValueBuilder> builderCallback) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl asValue(Object value) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic TypedValueImpl nullValue() {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic boolean isUsedBy(Type other) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic String getTypeName() {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic boolean isSame(NamedType other) {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tpublic TypesImpl getTypes() {\n+\t\treturn null;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/InvalidType.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.Collections;\n+import java.util.function.Supplier;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+public class MetadataImplTest {\n+\tprivate static final String TYPE_NAME = \"dummy.Type\";\n+\n+\tprivate MetadataImpl instance;\n+\n+\t@BeforeEach\n+\tpublic void setup() throws Exception {\n+\t\tinstance = new MetadataImpl(new ConstantPools());\n+\t}\n+\n+\t@Test\n+\tpublic void registerBuiltinNull() {\n+\t\tassertThrows(NullPointerException.class, () -> instance.registerBuiltin(null));\n+\t}\n+\n+\t@Test\n+\tpublic void registerBuiltin() {\n+\t\tfor (TypesImpl.Builtin builtin : TypesImpl.Builtin.values()) {\n+\t\t\tinstance.registerBuiltin(builtin);\n+\t\t\t\/\/ the builtin must be immediately available\n+\t\t\tassertNotNull(instance.getType(builtin.getTypeName(), false));\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void resolveTypes() {\n+\t\t\/\/ try to get a non-existing type\n+\t\tTypeImpl resolvable = instance.getType(TYPE_NAME, true);\n+\t\tassertFalse(resolvable.isResolved());\n+\t\tassertEquals(TYPE_NAME, resolvable.getTypeName());\n+\n+\t\t\/\/ register the type in metadata\n+\t\tinstance.registerType(TYPE_NAME, null,\n+\t\t\t\t() -> new TypeStructureImpl(Collections.emptyList(), Collections.emptyList()));\n+\t\t\/\/ and resolve the resolvable wrapper\n+\t\tinstance.resolveTypes();\n+\n+\t\tassertTrue(resolvable.isResolved());\n+\t\tassertEquals(TYPE_NAME, resolvable.getTypeName());\n+\t}\n+\n+\t@Test\n+\tpublic void registerTypeNullStructureProvider() {\n+\t\tassertNotNull(instance.registerType(TYPE_NAME, \"type.Super\", (Supplier<TypeStructureImpl>) null));\n+\t}\n+\n+\t@Test\n+\tpublic void registerType() {\n+\t\tTypeImpl type = instance.registerType(TYPE_NAME, \"type.Super\", () -> TypeStructureImpl.EMPTY);\n+\t\tassertNotNull(type);\n+\t\tassertNotNull(type.getFields());\n+\t\tassertNotNull(type.getAnnotations());\n+\t}\n+\n+\t@Test\n+\tpublic void getTypeEmptyMetadata() {\n+\t\tassertNull(instance.getType(\"dummy.Type\", false));\n+\t}\n+\n+\t@Test\n+\tpublic void getResolvableTypeEmptyMetadata() {\n+\t\tassertNotNull(instance.getType(\"dummy.Type\", true));\n+\t}\n+\n+\t@Test\n+\tvoid createInvalidBuiltinType() {\n+\t\tString typeName = \"invalid\";\n+\t\tassertThrows(IllegalArgumentException.class, () -> instance.createBuiltinType(typeName));\n+\t}\n+\n+\t@Test\n+\tvoid createValidBuiltinType() {\n+\t\tString typeName = TypesImpl.Builtin.BYTE.getTypeName();\n+\t\tTypeImpl type = instance.createBuiltinType(typeName);\n+\t\tassertNotNull(type);\n+\t\tassertTrue(type.isBuiltin());\n+\t\tassertEquals(typeName, type.getTypeName());\n+\t}\n+\n+\t@Test\n+\tvoid createDuplicateBuiltinType() {\n+\t\tString typeName = TypesImpl.Builtin.BYTE.getTypeName();\n+\t\tTypeImpl type1 = instance.createBuiltinType(typeName);\n+\t\tassertNotNull(type1);\n+\t\tassertTrue(type1.isBuiltin());\n+\n+\t\tTypeImpl type2 = instance.createBuiltinType(typeName);\n+\t\tassertNotNull(type2);\n+\t\tassertTrue(type2.isBuiltin());\n+\t\tassertEquals(type1.getTypeName(), type2.getTypeName());\n+\t\tassertNotEquals(type1, type2);\n+\t}\n+\n+\t@Test\n+\tvoid createCustomTypeForBuiltin() {\n+\t\tString typeName = TypesImpl.Builtin.BYTE.getTypeName();\n+\t\tassertThrows(IllegalArgumentException.class,\n+\t\t\t\t() -> instance.createCustomType(typeName, null, TypeStructureImpl.EMPTY));\n+\t}\n+\n+\t@Test\n+\tvoid createCustomTypeNullStructure() {\n+\t\tString typeName = \"dummy.Test\";\n+\t\tTypeImpl type = instance.createCustomType(typeName, null, null);\n+\t\tassertNotNull(type);\n+\t\tassertFalse(type.isBuiltin());\n+\t\tassertEquals(typeName, type.getTypeName());\n+\t\tassertNotNull(type.getFields());\n+\t\tassertNotNull(type.getAnnotations());\n+\t}\n+\n+\t@Test\n+\tvoid createCustomType() {\n+\t\tString typeName = \"dummy.Test\";\n+\t\tString superName = \"super.Type\";\n+\t\tTypeImpl type = instance.createCustomType(typeName, superName, TypeStructureImpl.EMPTY);\n+\t\tassertNotNull(type);\n+\t\tassertFalse(type.isBuiltin());\n+\t\tassertEquals(typeName, type.getTypeName());\n+\t\tassertNotNull(type.getFields());\n+\t\tassertNotNull(type.getAnnotations());\n+\t\tassertEquals(superName, type.getSupertype());\n+\t}\n+\n+\t@Test\n+\tvoid createDuplicateCustomType() {\n+\t\tString typeName = \"dummy.Test\";\n+\t\tString superName = \"super.Type\";\n+\n+\t\tTypeImpl type1 = instance.createCustomType(typeName, superName, TypeStructureImpl.EMPTY);\n+\t\tassertNotNull(type1);\n+\t\tassertFalse(type1.isBuiltin());\n+\n+\t\tTypeImpl type2 = instance.createCustomType(typeName, superName, TypeStructureImpl.EMPTY);\n+\t\tassertNotNull(type2);\n+\t\tassertFalse(type2.isBuiltin());\n+\t\tassertEquals(type1.getTypeName(), type2.getTypeName());\n+\t\tassertNotEquals(type1, type2);\n+\t}\n+\n+\t@Test\n+\tvoid stringIndexNull() {\n+\t\tassertThrows(NullPointerException.class, () -> instance.stringIndex(null));\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/MetadataImplTest.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+\n+import java.io.ByteArrayOutputStream;\n+\n+class RecordingImplTest {\n+\tprivate RecordingImpl recording;\n+\tprivate ByteArrayOutputStream bos;\n+\n+\t@BeforeEach\n+\tvoid setUp() {\n+\t\tbos = new ByteArrayOutputStream();\n+\t\trecording = new RecordingImpl(bos);\n+\t}\n+\n+\t@AfterEach\n+\tvoid tearDown() throws Exception {\n+\t\trecording.close();\n+\t}\n+\n+\t@Test\n+\tvoid registerEventTypeNullName() {\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.registerEventType(null));\n+\t}\n+\n+\t@Test\n+\tvoid registerEventTypeNullCallback() {\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.registerEventType(\"name\", null));\n+\t}\n+\n+\t@Test\n+\tvoid registerEventCallaback() {\n+\t\tString name = \"custom.Event\";\n+\t\tString fieldName = \"field\";\n+\t\tTypeImpl eventType = recording.registerEventType(name, t -> {\n+\t\t\tt.addField(fieldName, TypesImpl.Builtin.STRING);\n+\t\t});\n+\t\tassertNotNull(eventType);\n+\t\tassertEquals(name, eventType.getTypeName());\n+\t\tassertEquals(\"jdk.jfr.Event\", eventType.getSupertype());\n+\t\tassertNotNull(eventType.getField(fieldName));\n+\t}\n+\n+\t@Test\n+\tvoid registerEventTypeNew() {\n+\t\tString name = \"custom.Event\";\n+\t\tTypeImpl eventType = recording.registerEventType(name);\n+\t\tassertNotNull(eventType);\n+\t\tassertEquals(name, eventType.getTypeName());\n+\t\tassertEquals(\"jdk.jfr.Event\", eventType.getSupertype());\n+\t}\n+\n+\t@Test\n+\tvoid registerEventTypeExisting() {\n+\t\tString name = \"custom.Event\";\n+\t\tTypeImpl eventType = recording.registerEventType(name);\n+\n+\t\tTypeImpl eventType1 = recording.registerEventType(name);\n+\n+\t\tassertEquals(eventType, eventType1);\n+\t}\n+\n+\t@Test\n+\tvoid registerAnnotationTypeNullName() {\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.registerAnnotationType(null));\n+\t}\n+\n+\t@Test\n+\tvoid registerAnnotationTypeNullCallback() {\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.registerAnnotationType(\"name\", null));\n+\t}\n+\n+\t@Test\n+\tvoid registerAnnotationTypeWithCallback() {\n+\t\tString name = \"custom.Annotation\";\n+\t\tString fieldName = \"field\";\n+\t\tTypeImpl annotationType = recording.registerAnnotationType(name, t -> {\n+\t\t\tt.addField(fieldName, TypesImpl.Builtin.STRING);\n+\t\t});\n+\t\tassertNotNull(annotationType);\n+\t\tassertEquals(name, annotationType.getTypeName());\n+\t\tassertEquals(Annotation.ANNOTATION_SUPER_TYPE_NAME, annotationType.getSupertype());\n+\t\tassertEquals(1, annotationType.getFields().size());\n+\t\tassertNotNull(annotationType.getField(fieldName));\n+\t}\n+\n+\t@Test\n+\tvoid registerAnnotationTypeNew() {\n+\t\tString name = \"custom.Annotation\";\n+\t\tTypeImpl annotationType = recording.registerAnnotationType(name);\n+\t\tassertNotNull(annotationType);\n+\t\tassertEquals(name, annotationType.getTypeName());\n+\t\tassertEquals(Annotation.ANNOTATION_SUPER_TYPE_NAME, annotationType.getSupertype());\n+\t}\n+\n+\t@Test\n+\tvoid registerAnnotationTypeExisting() {\n+\t\tString name = \"custom.Annotation\";\n+\t\tTypeImpl annotationType = recording.registerAnnotationType(name);\n+\n+\t\tTypeImpl annotationType1 = recording.registerAnnotationType(name);\n+\n+\t\tassertEquals(annotationType, annotationType1);\n+\t}\n+\n+\t@Test\n+\tvoid registerTypeNulls() {\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.registerType(null, builder -> {\n+\t\t}));\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.registerType(\"name\", null));\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.registerType(null, null));\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.registerType(null, \"super\", builder -> {\n+\t\t}));\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.registerType(\"name\", \"super\", null));\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.registerType(null, \"super\", null));\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.registerType(null, null, builder -> {\n+\t\t}));\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.registerType(\"name\", null, null));\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.registerType(null, null, null));\n+\t}\n+\n+\t@ParameterizedTest\n+\t@EnumSource(TypesImpl.JDK.class)\n+\tvoid getBuiltinJDKType(TypesImpl.JDK target) {\n+\t\tTypeImpl type = recording.getType(target);\n+\t\tassertNotNull(type);\n+\t}\n+\n+\t@Test\n+\tvoid getNullType() {\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.getType((TypesImpl.JDK) null));\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.getType((String) null));\n+\t}\n+\n+\t@Test\n+\tvoid getInvalidType() {\n+\t\tassertThrows(IllegalArgumentException.class, () -> recording.getType(\"Invalid type\"));\n+\t}\n+\n+\t@Test\n+\tvoid getRegisteredType() {\n+\t\tString typeName = \"custom.Type\";\n+\t\tTypeImpl type = recording.registerType(typeName, builder -> {\n+\t\t});\n+\n+\t\tTypeImpl type1 = recording.getType(typeName);\n+\t\tassertNotNull(type1);\n+\t\tassertEquals(type, type1);\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/RecordingImplTest.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mockito;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedValue;\n+\n+class ResolvableTypeTest {\n+\tprivate static final String FIELD_NAME = \"field\";\n+\n+\tprivate ResolvableType resolvableType;\n+\tprivate final String targetTypeName = \"custom.Type\";\n+\tprivate MetadataImpl metadata;\n+\tprivate TypesImpl types;\n+\tprivate TypeImpl targetType;\n+\n+\t@BeforeEach\n+\tvoid setUp() {\n+\t\tConstantPools constantPools = new ConstantPools();\n+\t\tmetadata = new MetadataImpl(constantPools);\n+\t\ttypes = new TypesImpl(metadata);\n+\t\tresolvableType = new ResolvableType(targetTypeName, metadata);\n+\t}\n+\n+\t@Test\n+\tvoid isResolved() {\n+\t\tassertFalse(resolvableType.isResolved());\n+\t\tresolve();\n+\t\tassertTrue(resolvableType.isResolved());\n+\t}\n+\n+\t@Test\n+\tvoid getId() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.getId());\n+\t\tresolve();\n+\t\tassertEquals(targetType.getId(), resolvableType.getId());\n+\t}\n+\n+\t@Test\n+\tvoid hasConstantPool() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.hasConstantPool());\n+\t\tresolve();\n+\t\tassertEquals(targetType.hasConstantPool(), resolvableType.hasConstantPool());\n+\t}\n+\n+\t@Test\n+\tvoid asValueByte() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.asValue((byte) 1));\n+\t\tresolve();\n+\t\t\/\/ a resolvable type is always a complex\/custom type so `asValue(byte)` will always fail\n+\t\tassertThrows(IllegalArgumentException.class, () -> resolvableType.asValue((byte) 1));\n+\t}\n+\n+\t@Test\n+\tvoid asValueChar() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.asValue((char) 1));\n+\t\tresolve();\n+\t\t\/\/ a resolvable type is always a complex\/custom type so `asValue(char)` will always fail\n+\t\tassertThrows(IllegalArgumentException.class, () -> resolvableType.asValue((char) 1));\n+\t}\n+\n+\t@Test\n+\tvoid asValueShort() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.asValue((short) 1));\n+\t\tresolve();\n+\t\t\/\/ a resolvable type is always a complex\/custom type so `asValue(short)` will always fail\n+\t\tassertThrows(IllegalArgumentException.class, () -> resolvableType.asValue((short) 1));\n+\t}\n+\n+\t@Test\n+\tvoid asValueInt() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.asValue((int) 1));\n+\t\tresolve();\n+\t\t\/\/ a resolvable type is always a complex\/custom type so `asValue(int)` will always fail\n+\t\tassertThrows(IllegalArgumentException.class, () -> resolvableType.asValue((int) 1));\n+\t}\n+\n+\t@Test\n+\tvoid asValueLong() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.asValue((long) 1));\n+\t\tresolve();\n+\t\t\/\/ a resolvable type is always a complex\/custom type so `asValue(long)` will always fail\n+\t\tassertThrows(IllegalArgumentException.class, () -> resolvableType.asValue((long) 1));\n+\t}\n+\n+\t@Test\n+\tvoid asValueFloat() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.asValue((float) 1));\n+\t\tresolve();\n+\t\t\/\/ a resolvable type is always a complex\/custom type so `asValue(float)` will always fail\n+\t\tassertThrows(IllegalArgumentException.class, () -> resolvableType.asValue((float) 1));\n+\t}\n+\n+\t@Test\n+\tvoid asValueDouble() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.asValue((double) 1));\n+\t\tresolve();\n+\t\t\/\/ a resolvable type is always a complex\/custom type so `asValue(double)` will always fail\n+\t\tassertThrows(IllegalArgumentException.class, () -> resolvableType.asValue((double) 1));\n+\t}\n+\n+\t@Test\n+\tvoid asValueBoolean() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.asValue(true));\n+\t\tresolve();\n+\t\t\/\/ a resolvable type is always a complex\/custom type so `asValue(boolean)` will always fail\n+\t\tassertThrows(IllegalArgumentException.class, () -> resolvableType.asValue(true));\n+\t}\n+\n+\t@Test\n+\tvoid asValueString() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.asValue(\"1\"));\n+\t\tresolve();\n+\t\t\/\/ a resolvable type is always a complex\/custom type so `asValue(String)` will always fail\n+\t\tassertThrows(IllegalArgumentException.class, () -> resolvableType.asValue(\"1\"));\n+\t}\n+\n+\t@Test\n+\tvoid asValueCustom() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.asValue(v -> {\n+\t\t}));\n+\t\tresolve();\n+\t\tTypedValue value1 = targetType.asValue(v -> {\n+\t\t});\n+\t\tTypedValue value2 = resolvableType.asValue(v -> {\n+\t\t});\n+\t\tassertEquals(value1, value2);\n+\t}\n+\n+\t@Test\n+\tvoid nullValue() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.nullValue());\n+\t\tresolve();\n+\t\tassertEquals(targetType.nullValue(), resolvableType.nullValue());\n+\t}\n+\n+\t@Test\n+\tvoid isBuiltin() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.isBuiltin());\n+\t\tresolve();\n+\t\tassertEquals(targetType.isBuiltin(), resolvableType.isBuiltin());\n+\t}\n+\n+\t@Test\n+\tvoid isSimple() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.isSimple());\n+\t\tresolve();\n+\t\tassertEquals(targetType.isSimple(), resolvableType.isSimple());\n+\t}\n+\n+\t@Test\n+\tvoid getSupertype() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.getSupertype());\n+\t\tresolve();\n+\t\tassertEquals(targetType.getSupertype(), resolvableType.getSupertype());\n+\t}\n+\n+\t@Test\n+\tvoid getFields() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.getFields());\n+\t\tresolve();\n+\t\tassertEquals(targetType.getFields(), resolvableType.getFields());\n+\t}\n+\n+\t@Test\n+\tvoid getField() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.getField(FIELD_NAME));\n+\t\tresolve();\n+\t\tassertEquals(targetType.getField(FIELD_NAME), resolvableType.getField(FIELD_NAME));\n+\t}\n+\n+\t@Test\n+\tvoid getAnnotations() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.getAnnotations());\n+\t\tresolve();\n+\t\tassertEquals(targetType.getAnnotations(), resolvableType.getAnnotations());\n+\t}\n+\n+\t@Test\n+\tvoid canAccept() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.canAccept(\"value\"));\n+\t\tresolve();\n+\t\tassertEquals(targetType.canAccept(\"value\"), resolvableType.canAccept(\"value\"));\n+\t}\n+\n+\t@Test\n+\tvoid getTypeName() {\n+\t\tassertEquals(targetTypeName, resolvableType.getTypeName());\n+\t\tresolve();\n+\t\tassertEquals(targetType.getFields(), resolvableType.getFields());\n+\t}\n+\n+\t@Test\n+\tvoid isSame() {\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.isSame(TypesImpl.JDK.CLASS_LOADER));\n+\t\tresolve();\n+\t\tassertEquals(targetType.isSame(TypesImpl.JDK.CLASS_LOADER), resolvableType.isSame(TypesImpl.JDK.CLASS_LOADER));\n+\t}\n+\n+\t@Test\n+\tvoid isUsedBy() {\n+\t\tTypeImpl otherType = types.getType(TypesImpl.JDK.CLASS_LOADER);\n+\t\tassertThrows(IllegalStateException.class, () -> resolvableType.isUsedBy(otherType));\n+\t\tresolve();\n+\t\tassertEquals(targetType.isUsedBy(otherType), resolvableType.isUsedBy(otherType));\n+\t}\n+\n+\t\/**\n+\t * Resolvable type is supposed to work with {@linkplain BaseType} subclasses only. This test\n+\t * asserts that a resolvable will not be resolved to anything that is not a\n+\t * {@linkplain BaseType} subclass.\n+\t *\/\n+\t@Test\n+\tvoid wrongTypeResolve() {\n+\t\tMetadataImpl mockedMetadata = Mockito.mock(MetadataImpl.class);\n+\t\tMockito.when(mockedMetadata.getType(ArgumentMatchers.anyString(), ArgumentMatchers.anyBoolean()))\n+\t\t\t\t.thenReturn(new InvalidType());\n+\n+\t\tassertFalse(resolvableType.resolve());\n+\t}\n+\n+\tprivate void resolve() {\n+\t\tList<TypedFieldImpl> fields = Collections\n+\t\t\t\t.singletonList(new TypedFieldImpl(types.getType(TypesImpl.Builtin.STRING), FIELD_NAME));\n+\n+\t\ttargetType = metadata.registerType(targetTypeName, null,\n+\t\t\t\t() -> new TypeStructureImpl(fields, Collections.emptyList()));\n+\t\tmetadata.resolveTypes();\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/ResolvableTypeTest.java","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.Test;\n+\n+class SelfTypeTest {\n+\t@Test\n+\tvoid isBuiltin() {\n+\t\tassertThrows(UnsupportedOperationException.class, () -> SelfType.INSTANCE.isBuiltin());\n+\t}\n+\n+\t@Test\n+\tvoid getFields() {\n+\t\tassertThrows(UnsupportedOperationException.class, () -> SelfType.INSTANCE.getFields());\n+\t}\n+\n+\t@Test\n+\tvoid getField() {\n+\t\tassertThrows(UnsupportedOperationException.class, () -> SelfType.INSTANCE.getField(\"field\"));\n+\t}\n+\n+\t@Test\n+\tvoid getAnnotations() {\n+\t\tassertThrows(UnsupportedOperationException.class, () -> SelfType.INSTANCE.getAnnotations());\n+\t}\n+\n+\t@Test\n+\tvoid canAccept() {\n+\t\tassertThrows(UnsupportedOperationException.class, () -> SelfType.INSTANCE.canAccept(\"value\"));\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/SelfTypeTest.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+\n+import java.util.List;\n+\n+abstract class TestType extends BaseType {\n+\tpublic TestType(long id, String name, String supertype, ConstantPools constantPools, TypesImpl types) {\n+\t\tsuper(id, name, supertype, constantPools, types);\n+\t}\n+\n+\t@Override\n+\tpublic boolean isBuiltin() {\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tpublic List<TypedFieldImpl> getFields() {\n+\t\tthrow new IllegalArgumentException();\n+\t}\n+\n+\t@Override\n+\tpublic TypedFieldImpl getField(String name) {\n+\t\tthrow new IllegalArgumentException();\n+\t}\n+\n+\t@Override\n+\tpublic List<Annotation> getAnnotations() {\n+\t\tthrow new IllegalArgumentException();\n+\t}\n+\n+\t@Override\n+\tpublic boolean canAccept(Object value) {\n+\t\treturn false;\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TestType.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+class TypeByUsageComparatorTest {\n+\tprivate TypesImpl types;\n+\tprivate org.openjdk.jmc.flightrecorder.writer.util.TypeByUsageComparator instance;\n+\n+\t@BeforeEach\n+\tvoid setup() {\n+\t\tConstantPools constantPools = new ConstantPools();\n+\t\tMetadataImpl metadata = new MetadataImpl(constantPools);\n+\t\ttypes = new TypesImpl(metadata);\n+\n+\t\tinstance = new org.openjdk.jmc.flightrecorder.writer.util.TypeByUsageComparator();\n+\t}\n+\n+\t@Test\n+\tvoid compare() {\n+\t\tTypeImpl type1 = types.getType(TypesImpl.Builtin.STRING);\n+\t\tTypeImpl type2 = types.getType(TypesImpl.JDK.CLASS);\n+\n+\t\tassertEquals(0, instance.compare(type1, type1));\n+\t\tassertEquals(0, instance.compare(type2, type2));\n+\t\tassertEquals(0, instance.compare(null, null));\n+\t\tassertEquals(1, instance.compare(type1, null));\n+\t\tassertEquals(-1, instance.compare(null, type1));\n+\t\tassertEquals(-1, instance.compare(type1, type2));\n+\t\tassertEquals(1, instance.compare(type2, type1));\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypeByUsageComparatorTest.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mockito;\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypeStructure;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedField;\n+\n+class TypeStructureBuilderImplTest {\n+\tprivate static final String FIELD_NAME = \"field\";\n+\tprivate static final String CUSTOM_TYPE_NAME = \"test.Type\";\n+\tprivate static final String ANNOTATION_TYPE_NAME = \"jdk.jfr.Label\";\n+\tprivate static final String ANNOTATION_LABEL = \"test.Label\";\n+\n+\tprivate TypeStructureBuilderImpl instance;\n+\tprivate TypeImpl stringType;\n+\tprivate TypeImpl customType;\n+\tprivate TypeImpl annotationType;\n+\n+\t@BeforeEach\n+\tvoid setUp() {\n+\t\tConstantPools constantPools = Mockito.mock(ConstantPools.class);\n+\t\tTypesImpl types = Mockito.mock(TypesImpl.class);\n+\n+\t\tstringType = new BuiltinType(1, TypesImpl.Builtin.STRING, constantPools, types);\n+\n+\t\tList<TypedFieldImpl> customTypeFields = Collections.singletonList(new TypedFieldImpl(stringType, \"item\"));\n+\t\tcustomType = new CompositeTypeImpl(2, CUSTOM_TYPE_NAME, null,\n+\t\t\t\tnew TypeStructureImpl(customTypeFields, Collections.emptyList()), constantPools, types);\n+\n+\t\tannotationType = new CompositeTypeImpl(3, ANNOTATION_TYPE_NAME, Annotation.ANNOTATION_SUPER_TYPE_NAME,\n+\t\t\t\tnew TypeStructureImpl(Collections.singletonList(new TypedFieldImpl(stringType, \"value\")),\n+\t\t\t\t\t\tCollections.emptyList()),\n+\t\t\t\tconstantPools, types);\n+\n+\t\tMockito.when(types.getType(ArgumentMatchers.any(TypesImpl.Predefined.class))).thenReturn(stringType);\n+\t\tMockito.when(types.getType(ArgumentMatchers.matches(CUSTOM_TYPE_NAME.replace(\".\", \"\\\\.\"))))\n+\t\t\t\t.thenReturn(customType);\n+\t\tMockito.when(types.getType(ArgumentMatchers.matches(ANNOTATION_TYPE_NAME.replace(\".\", \"\\\\.\"))))\n+\t\t\t\t.thenReturn(annotationType);\n+\n+\t\tinstance = new TypeStructureBuilderImpl(types);\n+\t}\n+\n+\t@Test\n+\tvoid addFieldPredefined() {\n+\t\tTypeStructure structure = instance.addField(FIELD_NAME, TypesImpl.Builtin.STRING).build();\n+\t\tassertEquals(1, structure.getFields().size());\n+\t\tassertEquals(0, structure.getAnnotations().size());\n+\n+\t\tTypedField field = structure.getFields().get(0);\n+\t\tassertEquals(FIELD_NAME, field.getName());\n+\t\tassertEquals(stringType, field.getType());\n+\t}\n+\n+\t@Test\n+\tvoid testAddFieldCustom() {\n+\t\tTypeStructure structure = instance.addField(FIELD_NAME, customType).build();\n+\t\tassertEquals(1, structure.getFields().size());\n+\n+\t\tTypedField field = structure.getFields().get(0);\n+\t\tassertEquals(FIELD_NAME, field.getName());\n+\t\tassertEquals(customType, field.getType());\n+\t}\n+\n+\t@Test\n+\tvoid addFieldNullName() {\n+\t\tassertThrows(NullPointerException.class, () -> instance.addField(null, TypesImpl.Builtin.STRING));\n+\t}\n+\n+\t@Test\n+\tvoid addFieldNullType() {\n+\t\tassertThrows(NullPointerException.class, () -> instance.addField(FIELD_NAME, (TypesImpl.Predefined) null));\n+\t\tassertThrows(NullPointerException.class, () -> instance.addField(FIELD_NAME, (TypeImpl) null));\n+\t}\n+\n+\t@Test\n+\tvoid addAnnotation() {\n+\t\tTypeStructure structure = instance.addAnnotation(annotationType, ANNOTATION_LABEL).build();\n+\t\tassertEquals(0, structure.getFields().size());\n+\t\tassertEquals(1, structure.getAnnotations().size());\n+\n+\t\tAnnotation annotation = structure.getAnnotations().get(0);\n+\t\tassertEquals(annotationType, annotation.getType());\n+\t\tassertEquals(ANNOTATION_LABEL, annotation.getValue());\n+\t}\n+\n+\t@Test\n+\tvoid addAnnotationNullValue() {\n+\t\tTypeStructure structure = instance.addAnnotation(annotationType).build();\n+\t\tassertEquals(0, structure.getFields().size());\n+\t\tassertEquals(1, structure.getAnnotations().size());\n+\n+\t\tAnnotation annotation = structure.getAnnotations().get(0);\n+\t\tassertEquals(annotationType, annotation.getType());\n+\t\tassertNull(annotation.getValue());\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypeStructureBuilderImplTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import org.openjdk.jmc.flightrecorder.writer.api.Types;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class TypeUtils {\n+\tprivate static final Map<Types.Builtin, List<Object>> BUILTIN_VALUES_MAP;\n+\n+\tstatic {\n+\t\tBUILTIN_VALUES_MAP = new HashMap<>();\n+\t\tBUILTIN_VALUES_MAP.put(Types.Builtin.BOOLEAN, Arrays.asList(true, false));\n+\t\tBUILTIN_VALUES_MAP.put(Types.Builtin.BYTE, Collections.singletonList((byte) 0x12));\n+\t\tBUILTIN_VALUES_MAP.put(Types.Builtin.CHAR, Collections.singletonList('h'));\n+\t\tBUILTIN_VALUES_MAP.put(Types.Builtin.SHORT, Collections.singletonList((short) 4));\n+\t\tBUILTIN_VALUES_MAP.put(Types.Builtin.INT, Collections.singletonList(7));\n+\t\tBUILTIN_VALUES_MAP.put(Types.Builtin.LONG, Collections.singletonList(1256L));\n+\t\tBUILTIN_VALUES_MAP.put(Types.Builtin.FLOAT, Collections.singletonList(3.14f));\n+\t\tBUILTIN_VALUES_MAP.put(Types.Builtin.DOUBLE, Collections.singletonList(Math.sqrt(2d)));\n+\t\tBUILTIN_VALUES_MAP.put(Types.Builtin.STRING, Arrays.asList(null, \"\", \"hello\"));\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic static <T> List<T> getBuiltinValues(Types.Builtin target) {\n+\t\treturn (List<T>) BUILTIN_VALUES_MAP.get(target);\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypeUtils.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mockito;\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+\n+class TypedFieldBuilderImplTest {\n+\tprivate static final String FIELD_NAME = \"field\";\n+\tprivate static final String CUSTOM_TYPE_NAME = \"test.Type\";\n+\tprivate static final String ANNOTATION_TYPE_NAME = \"jdk.jfr.Label\";\n+\tprivate static final String ANNOTATION_LABEL = \"test.Label\";\n+\n+\tprivate TypedFieldBuilderImpl instance;\n+\tprivate TypeImpl stringType;\n+\tprivate TypeImpl customType;\n+\tprivate TypeImpl annotationType;\n+\n+\t@BeforeEach\n+\tvoid setUp() {\n+\t\tTypesImpl types = Mockito.mock(TypesImpl.class);\n+\t\tConstantPools constantPools = Mockito.mock(ConstantPools.class);\n+\n+\t\tstringType = new BuiltinType(1, TypesImpl.Builtin.STRING, constantPools, types);\n+\n+\t\tList<TypedFieldImpl> customTypeFields = Collections.singletonList(new TypedFieldImpl(stringType, \"item\"));\n+\t\tcustomType = new CompositeTypeImpl(2, CUSTOM_TYPE_NAME, null,\n+\t\t\t\tnew TypeStructureImpl(customTypeFields, Collections.emptyList()), constantPools, types);\n+\n+\t\tannotationType = new CompositeTypeImpl(3, ANNOTATION_TYPE_NAME, Annotation.ANNOTATION_SUPER_TYPE_NAME,\n+\t\t\t\tnew TypeStructureImpl(Collections.singletonList(new TypedFieldImpl(stringType, \"value\")),\n+\t\t\t\t\t\tCollections.emptyList()),\n+\t\t\t\tconstantPools, types);\n+\n+\t\tMockito.when(types.getType(ArgumentMatchers.any(TypesImpl.Predefined.class)))\n+\t\t\t\t.thenAnswer(i -> ((TypesImpl.Predefined) i.getArgument(0)).getTypeName().equals(ANNOTATION_TYPE_NAME)\n+\t\t\t\t\t\t? annotationType : stringType);\n+\t\tMockito.when(types.getType(ArgumentMatchers.matches(CUSTOM_TYPE_NAME.replace(\".\", \"\\\\.\"))))\n+\t\t\t\t.thenReturn(customType);\n+\t\tMockito.when(types.getType(ArgumentMatchers.matches(ANNOTATION_TYPE_NAME.replace(\".\", \"\\\\.\"))))\n+\t\t\t\t.thenReturn(annotationType);\n+\n+\t\tinstance = new TypedFieldBuilderImpl(FIELD_NAME, customType, types);\n+\t}\n+\n+\t@Test\n+\tvoid addAnnotationNullValue() {\n+\t\tTypedFieldImpl field = instance.addAnnotation(annotationType).build();\n+\n+\t\tassertNotNull(field);\n+\t\tassertEquals(FIELD_NAME, field.getName());\n+\t\tassertEquals(customType, field.getType());\n+\n+\t\tassertEquals(1, field.getAnnotations().size());\n+\t\tAnnotation annotation = field.getAnnotations().get(0);\n+\t\tassertEquals(annotationType, annotation.getType());\n+\t\tassertNull(annotation.getValue());\n+\t}\n+\n+\t@Test\n+\tvoid addPredefinedAnnotationNullValue() {\n+\t\tTypedFieldImpl field = instance.addAnnotation(TypesImpl.JDK.ANNOTATION_LABEL).build();\n+\n+\t\tassertNotNull(field);\n+\t\tassertEquals(FIELD_NAME, field.getName());\n+\t\tassertEquals(customType, field.getType());\n+\n+\t\tassertEquals(1, field.getAnnotations().size());\n+\t\tAnnotation annotation = field.getAnnotations().get(0);\n+\t\tassertEquals(annotationType, annotation.getType());\n+\t\tassertNull(annotation.getValue());\n+\t}\n+\n+\t@Test\n+\tvoid addAnnotationValue() {\n+\t\tTypedFieldImpl field = instance.addAnnotation(annotationType, ANNOTATION_LABEL).build();\n+\n+\t\tassertNotNull(field);\n+\t\tassertEquals(FIELD_NAME, field.getName());\n+\t\tassertEquals(customType, field.getType());\n+\n+\t\tassertEquals(1, field.getAnnotations().size());\n+\t\tAnnotation annotation = field.getAnnotations().get(0);\n+\t\tassertEquals(annotationType, annotation.getType());\n+\t\tassertEquals(ANNOTATION_LABEL, annotation.getValue());\n+\t}\n+\n+\t@Test\n+\tvoid addPredefinedAnnotationValue() {\n+\t\tTypedFieldImpl field = instance.addAnnotation(TypesImpl.JDK.ANNOTATION_LABEL, ANNOTATION_LABEL).build();\n+\n+\t\tassertNotNull(field);\n+\t\tassertEquals(FIELD_NAME, field.getName());\n+\t\tassertEquals(customType, field.getType());\n+\n+\t\tassertEquals(1, field.getAnnotations().size());\n+\t\tAnnotation annotation = field.getAnnotations().get(0);\n+\t\tassertEquals(annotationType, annotation.getType());\n+\t\tassertEquals(ANNOTATION_LABEL, annotation.getValue());\n+\t}\n+\n+\t@Test\n+\tvoid asArray() {\n+\t\tTypedFieldImpl field = instance.asArray().build();\n+\n+\t\tassertNotNull(field);\n+\t\tassertTrue(field.isArray());\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypedFieldBuilderImplTest.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.openjdk.jmc.flightrecorder.writer.api.Annotation;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+class TypedFieldImplTest {\n+\tprivate static final String FIELD_NAME = \"instance\";\n+\n+\tprivate TypesImpl types;\n+\n+\t@BeforeEach\n+\tvoid setUp() {\n+\t\tConstantPools constantPools = new ConstantPools();\n+\t\tMetadataImpl metadata = new MetadataImpl(constantPools);\n+\t\ttypes = new TypesImpl(metadata);\n+\t}\n+\n+\t@Test\n+\tvoid getCustomTypeNoAnnotations() {\n+\t\tTypeImpl type = types.getOrAdd(\"custom.Type\", t -> {\n+\t\t\tt.addField(\"field\", TypesImpl.Builtin.STRING).addAnnotation(types.getType(TypesImpl.JDK.ANNOTATION_LABEL),\n+\t\t\t\t\t\"custom.Type\");\n+\t\t});\n+\t\tTypedFieldImpl instance = new TypedFieldImpl(type, FIELD_NAME);\n+\n+\t\tassertEquals(FIELD_NAME, instance.getName());\n+\t\tassertEquals(type, instance.getType());\n+\t\tassertEquals(0, instance.getAnnotations().size());\n+\t\tassertFalse(instance.isArray());\n+\t}\n+\n+\t@Test\n+\tvoid getCustomTypeAnnotations() {\n+\t\tTypeImpl type = types.getOrAdd(\"custom.Type\", t -> {\n+\t\t\tt.addField(\"field\", TypesImpl.Builtin.STRING).addAnnotation(types.getType(TypesImpl.JDK.ANNOTATION_LABEL),\n+\t\t\t\t\t\"custom.Type\");\n+\t\t});\n+\t\tTypedFieldImpl instance = new TypedFieldImpl(type, FIELD_NAME, false,\n+\t\t\t\tCollections.singletonList(new Annotation(types.getType(TypesImpl.JDK.ANNOTATION_LABEL), \"field\")));\n+\n+\t\tassertEquals(FIELD_NAME, instance.getName());\n+\t\tassertEquals(type, instance.getType());\n+\t\tassertEquals(1, instance.getAnnotations().size());\n+\t\tassertFalse(instance.isArray());\n+\t}\n+\n+\t@Test\n+\tvoid getCustomTypeArrayNoAnnotations() {\n+\t\tTypeImpl type = types.getOrAdd(\"custom.Type\", t -> {\n+\t\t\tt.addField(\"field\", TypesImpl.Builtin.STRING).addAnnotation(types.getType(TypesImpl.JDK.ANNOTATION_LABEL),\n+\t\t\t\t\t\"custom.Type\");\n+\t\t});\n+\t\tTypedFieldImpl instance = new TypedFieldImpl(type, FIELD_NAME, true);\n+\n+\t\tassertEquals(FIELD_NAME, instance.getName());\n+\t\tassertEquals(type, instance.getType());\n+\t\tassertEquals(0, instance.getAnnotations().size());\n+\t\tassertTrue(instance.isArray());\n+\t}\n+\n+\t@Test\n+\tvoid getCustomTypeArrayAnnotations() {\n+\t\tTypeImpl type = types.getOrAdd(\"custom.Type\", t -> {\n+\t\t\tt.addField(\"field\", TypesImpl.Builtin.STRING).addAnnotation(types.getType(TypesImpl.JDK.ANNOTATION_LABEL),\n+\t\t\t\t\t\"custom.Type\");\n+\t\t});\n+\t\tTypedFieldImpl instance = new TypedFieldImpl(type, FIELD_NAME, true,\n+\t\t\t\tCollections.singletonList(new Annotation(types.getType(TypesImpl.JDK.ANNOTATION_LABEL), \"field\")));\n+\n+\t\tassertEquals(FIELD_NAME, instance.getName());\n+\t\tassertEquals(type, instance.getType());\n+\t\tassertEquals(1, instance.getAnnotations().size());\n+\t\tassertTrue(instance.isArray());\n+\t}\n+\n+\t@Test\n+\tvoid equality() {\n+\t\tTypeImpl[] fieldTypes = new TypeImpl[] {types.getOrAdd(\"custom.Type\", t -> {\n+\t\t\tt.addField(\"field\", TypesImpl.Builtin.STRING).addAnnotation(types.getType(TypesImpl.JDK.ANNOTATION_LABEL),\n+\t\t\t\t\t\"custom.Type\");\n+\t\t}), types.getType(TypesImpl.Builtin.STRING)};\n+\n+\t\tString[] fieldNames = new String[] {\"field1\", \"field2\"};\n+\t\tboolean[] arrayFlags = new boolean[] {true, false};\n+\t\tList<List<Annotation>> annotations = Arrays.asList(Collections.emptyList(),\n+\t\t\t\tCollections.singletonList(new Annotation(types.getType(TypesImpl.JDK.ANNOTATION_LABEL), \"field\")));\n+\n+\t\tList<TypedFieldImpl> fields = new ArrayList<>();\n+\t\tfor (TypeImpl fieldType : fieldTypes) {\n+\t\t\tfor (String fieldName : fieldNames) {\n+\t\t\t\tfor (boolean arrayFlag : arrayFlags) {\n+\t\t\t\t\tfor (List<Annotation> annotationList : annotations) {\n+\t\t\t\t\t\tfields.add(new TypedFieldImpl(fieldType, fieldName, arrayFlag, annotationList));\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tfor (TypedFieldImpl field1 : fields) {\n+\t\t\t\/\/ make the code coverage check happy\n+\t\t\tassertFalse(field1.equals(10));\n+\n+\t\t\tassertFalse(field1.equals(null));\n+\t\t\tfor (TypedFieldImpl field2 : fields) {\n+\t\t\t\tassertEquals(field1 == field2, field1.equals(field2));\n+\n+\t\t\t\t\/\/ keep the hashCode-equals contract\n+\t\t\t\tassertTrue(field1.hashCode() != field2.hashCode() || field1.equals(field2));\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypedFieldImplTest.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+class TypedFieldValueTest {\n+\tprivate TypesImpl types;\n+\n+\t@BeforeEach\n+\tvoid setup() {\n+\t\ttypes = new TypesImpl(new MetadataImpl(new ConstantPools()));\n+\t}\n+\n+\t@Test\n+\tvoid testArrayForScalarField() {\n+\t\tTypeImpl type = types.getType(TypesImpl.Builtin.STRING);\n+\t\tTypedFieldImpl field = new TypedFieldImpl(type, \"field\");\n+\t\tTypedValueImpl value = type.asValue(\"hello\");\n+\n+\t\tassertThrows(IllegalArgumentException.class,\n+\t\t\t\t() -> new TypedFieldValueImpl(field, new TypedValueImpl[] {value, value}));\n+\t}\n+\n+\t@Test\n+\tvoid testScalarValue() {\n+\t\tTypeImpl type = types.getType(TypesImpl.Builtin.STRING);\n+\t\tTypedFieldImpl field = new TypedFieldImpl(type, \"field\");\n+\t\tTypedValueImpl value = type.asValue(\"hello\");\n+\n+\t\tTypedFieldValueImpl instance = new TypedFieldValueImpl(field, value);\n+\n+\t\tassertNotNull(instance.getValue());\n+\t\tassertEquals(field, instance.getField());\n+\t\tassertEquals(value, instance.getValue());\n+\t\tassertThrows(IllegalArgumentException.class, instance::getValues);\n+\t}\n+\n+\t@Test\n+\tvoid testArrayValue() {\n+\t\tTypeImpl type = types.getType(TypesImpl.Builtin.STRING);\n+\t\tTypedFieldImpl field = new TypedFieldImpl(type, \"field\", true);\n+\t\tTypedValueImpl value1 = type.asValue(\"hello\");\n+\t\tTypedValueImpl value2 = type.asValue(\"world\");\n+\n+\t\tTypedFieldValueImpl instance = new TypedFieldValueImpl(field, new TypedValueImpl[] {value1, value2});\n+\n+\t\tassertNotNull(instance.getValues());\n+\t\tassertEquals(field, instance.getField());\n+\t\tassertArrayEquals(new TypedValueImpl[] {value1, value2}, instance.getValues());\n+\t\tassertThrows(IllegalArgumentException.class, instance::getValue);\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypedFieldValueTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,341 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import java.lang.reflect.Array;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedFieldBuilder;\n+import org.openjdk.jmc.flightrecorder.writer.api.TypedFieldValue;\n+\n+@SuppressWarnings(\"unchecked\")\n+class TypedValueBuilderImplTest {\n+\tprivate static final String CUSTOM_FIELD_NAME = \"custom_field\";\n+\tprivate static final String CUSTOM_FIELD_ARRAY_NAME = \"custom_field_arr\";\n+\tprivate static final String SIMPLE_FIELD_VALUE = \"hello\";\n+\tprivate static final String SIMPLE_FIELD_NAME = \"field\";\n+\tprivate static Map<TypesImpl.Builtin, String> typeToFieldMap;\n+\tprivate TypedValueBuilderImpl instance;\n+\tprivate TypeImpl simpleType;\n+\tprivate TypeImpl customType;\n+\tprivate TypeImpl stringType;\n+\n+\t@BeforeAll\n+\tstatic void init() {\n+\t\ttypeToFieldMap = new HashMap<>(TypesImpl.Builtin.values().length);\n+\t\tfor (TypesImpl.Builtin builtin : TypesImpl.Builtin.values()) {\n+\t\t\ttypeToFieldMap.put(builtin, builtin.name().toLowerCase() + \"_field\");\n+\t\t}\n+\t}\n+\n+\t@BeforeEach\n+\tvoid setUp() {\n+\t\t\/\/ not mocking here since we will need quite a number of predefined types anyway\n+\t\tTypesImpl types = new TypesImpl(new MetadataImpl(new ConstantPools()));\n+\n+\t\tstringType = types.getType(TypesImpl.Builtin.STRING);\n+\n+\t\tsimpleType = types.getOrAdd(\"custom.Simple\", builder -> {\n+\t\t\tbuilder.addField(SIMPLE_FIELD_NAME, TypesImpl.Builtin.STRING);\n+\t\t});\n+\n+\t\tcustomType = types.getOrAdd(\"custom.Type\", builder -> {\n+\t\t\tfor (TypesImpl.Builtin builtin : TypesImpl.Builtin.values()) {\n+\t\t\t\tbuilder = builder.addField(getFieldName(builtin), builtin).addField(getArrayFieldName(builtin), builtin,\n+\t\t\t\t\t\tTypedFieldBuilder::asArray);\n+\t\t\t}\n+\t\t\tbuilder.addField(CUSTOM_FIELD_NAME, simpleType).addField(CUSTOM_FIELD_ARRAY_NAME, simpleType,\n+\t\t\t\t\tTypedFieldBuilder::asArray);\n+\t\t});\n+\n+\t\tinstance = new TypedValueBuilderImpl(customType);\n+\t}\n+\n+\t@ParameterizedTest\n+\t@EnumSource(TypesImpl.Builtin.class)\n+\tvoid putFieldBuiltin(TypesImpl.Builtin target) {\n+\t\tfor (TypesImpl.Builtin type : TypesImpl.Builtin.values()) {\n+\t\t\tif (type == target) {\n+\t\t\t\tassertCorrectFieldValueBuiltinType(target, type, 1, false);\n+\t\t\t} else {\n+\t\t\t\tassertWrongFieldValueBuiltinType(target, type, 0);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@ParameterizedTest\n+\t@EnumSource(TypesImpl.Builtin.class)\n+\tvoid putFieldBuiltinArray(TypesImpl.Builtin target) {\n+\t\tfor (TypesImpl.Builtin type : TypesImpl.Builtin.values()) {\n+\t\t\tif (type == target) {\n+\t\t\t\tassertCorrectFieldValueBuiltinType(target, type, 1, true);\n+\t\t\t} else {\n+\t\t\t\tassertWrongFieldValueBuiltinType(target, type, 0);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@ParameterizedTest\n+\t@EnumSource(TypesImpl.Builtin.class)\n+\tvoid putFieldBuiltinArrayNonExistent(TypesImpl.Builtin target) {\n+\t\tassertThrows(IllegalArgumentException.class, () -> testPutBuiltinFieldArray(target, \"not a field name\", 1));\n+\t}\n+\n+\t@Test\n+\tvoid putFieldCustom() {\n+\t\tinstance.putField(CUSTOM_FIELD_NAME, SIMPLE_FIELD_VALUE);\n+\n+\t\tTypedFieldValueImpl fieldValue = instance.build().get(CUSTOM_FIELD_NAME);\n+\t\tassertNotNull(fieldValue);\n+\t\tassertEquals(CUSTOM_FIELD_NAME, fieldValue.getField().getName());\n+\t\tassertEquals(SIMPLE_FIELD_VALUE, fieldValue.getValue().getValue());\n+\t}\n+\n+\t@Test\n+\tvoid putFieldCustomBuilder() {\n+\t\tinstance.putField(CUSTOM_FIELD_NAME, v -> {\n+\t\t\tv.putField(SIMPLE_FIELD_NAME, SIMPLE_FIELD_VALUE);\n+\t\t});\n+\n+\t\tTypedFieldValueImpl fieldValue = instance.build().get(CUSTOM_FIELD_NAME);\n+\t\tassertNotNull(fieldValue);\n+\t\tassertEquals(CUSTOM_FIELD_NAME, fieldValue.getField().getName());\n+\t\tassertEquals(SIMPLE_FIELD_VALUE, fieldValue.getValue().getValue());\n+\t}\n+\n+\t@Test\n+\tvoid putFieldCustomArray() {\n+\t\tinstance.putField(CUSTOM_FIELD_ARRAY_NAME, simpleType.asValue(v -> v.putField(SIMPLE_FIELD_NAME, \"value1\")),\n+\t\t\t\tsimpleType.asValue(v -> v.putField(SIMPLE_FIELD_NAME, \"value2\")));\n+\n+\t\tTypedFieldValueImpl fieldValue = instance.build().get(CUSTOM_FIELD_ARRAY_NAME);\n+\t\tassertNotNull(fieldValue);\n+\t\tassertEquals(CUSTOM_FIELD_ARRAY_NAME, fieldValue.getField().getName());\n+\t}\n+\n+\t@Test\n+\tvoid putFieldCustomArrayNonArrayField() {\n+\t\tassertThrows(IllegalArgumentException.class,\n+\t\t\t\t() -> instance.putField(CUSTOM_FIELD_NAME,\n+\t\t\t\t\t\tsimpleType.asValue(v -> v.putField(SIMPLE_FIELD_NAME, \"value1\")),\n+\t\t\t\t\t\tsimpleType.asValue(v -> v.putField(SIMPLE_FIELD_NAME, \"value2\"))));\n+\t}\n+\n+\t@Test\n+\tvoid putFieldCustomArrayNonExistingField() {\n+\t\tassertThrows(IllegalArgumentException.class,\n+\t\t\t\t() -> instance.putField(\"not a field name\",\n+\t\t\t\t\t\tsimpleType.asValue(v -> v.putField(SIMPLE_FIELD_NAME, \"value1\")),\n+\t\t\t\t\t\tsimpleType.asValue(v -> v.putField(SIMPLE_FIELD_NAME, \"value2\"))));\n+\t}\n+\n+\t@Test\n+\tvoid putFieldCustomArrayInvalidValues() {\n+\t\tassertThrows(IllegalArgumentException.class, () -> instance.putField(CUSTOM_FIELD_ARRAY_NAME,\n+\t\t\t\tstringType.asValue(\"value1\"), stringType.asValue(\"value2\")));\n+\t}\n+\n+\t@Test\n+\tvoid putFieldCustomInvalid() {\n+\t\tassertThrows(IllegalArgumentException.class, () -> instance.putField(CUSTOM_FIELD_NAME, 0L));\n+\t}\n+\n+\t@Test\n+\tpublic void putFieldCustomBuilderArray() {\n+\t\tTypedFieldValue value = instance.putFields(CUSTOM_FIELD_ARRAY_NAME, fld1 -> {\n+\t\t\tfld1.putField(SIMPLE_FIELD_NAME, SIMPLE_FIELD_VALUE);\n+\t\t}, fld2 -> {\n+\t\t\tfld2.putField(SIMPLE_FIELD_NAME, SIMPLE_FIELD_VALUE);\n+\t\t}).build().get(CUSTOM_FIELD_ARRAY_NAME);\n+\n+\t\tassertEquals(CUSTOM_FIELD_ARRAY_NAME, value.getField().getName());\n+\t\tassertNotNull(value);\n+\t}\n+\n+\t@Test\n+\tpublic void putFieldCustomBuilderArrayNonArrayField() {\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tinstance.putFields(CUSTOM_FIELD_NAME, fld1 -> {\n+\t\t\t\tfld1.putField(SIMPLE_FIELD_NAME, SIMPLE_FIELD_VALUE);\n+\t\t\t}, fld2 -> {\n+\t\t\t\tfld2.putField(SIMPLE_FIELD_NAME, SIMPLE_FIELD_VALUE);\n+\t\t\t}).build().get(CUSTOM_FIELD_ARRAY_NAME);\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void putFieldCustomBuilderArrayNonExistingField() {\n+\t\tassertThrows(IllegalArgumentException.class, () -> {\n+\t\t\tinstance.putFields(\"not a field name\", fld1 -> {\n+\t\t\t\tfld1.putField(SIMPLE_FIELD_NAME, SIMPLE_FIELD_VALUE);\n+\t\t\t}, fld2 -> {\n+\t\t\t\tfld2.putField(SIMPLE_FIELD_NAME, SIMPLE_FIELD_VALUE);\n+\t\t\t}).build().get(CUSTOM_FIELD_ARRAY_NAME);\n+\t\t});\n+\t}\n+\n+\tprivate void assertCorrectFieldValueBuiltinType(\n+\t\tTypesImpl.Builtin target, TypesImpl.Builtin type, int value, boolean asArray) {\n+\t\tif (asArray) {\n+\t\t\ttestPutBuiltinFieldArray(target, getArrayFieldName(type), value);\n+\t\t} else {\n+\t\t\ttestPutBuiltinField(target, getFieldName(type), value);\n+\t\t}\n+\n+\t\tString fieldName = asArray ? getArrayFieldName(type) : getFieldName(type);\n+\t\tTypedFieldValueImpl fieldValue = instance.build().get(fieldName);\n+\t\tassertNotNull(fieldValue);\n+\t\tassertEquals(fieldName, fieldValue.getField().getName());\n+\n+\t\tObject targetValue = null;\n+\t\tif (asArray) {\n+\t\t\tObject targetValues = fieldValue.getValues();\n+\t\t\tassertNotNull(targetValues);\n+\t\t\tassertTrue(targetValues.getClass().isArray());\n+\t\t\ttargetValue = Array.get(targetValues, 0);\n+\t\t} else {\n+\t\t\ttargetValue = fieldValue.getValue().getValue();\n+\t\t}\n+\t\tassertNotNull(targetValue);\n+\t\tif (targetValue instanceof Number) {\n+\t\t\tassertEquals(value, ((Number) targetValue).intValue());\n+\t\t} else if (targetValue instanceof String) {\n+\t\t\tassertEquals(String.valueOf(value), targetValue);\n+\t\t} else if (targetValue instanceof Boolean) {\n+\t\t\tassertEquals(value > 0, targetValue);\n+\t\t}\n+\t}\n+\n+\tprivate void assertWrongFieldValueBuiltinType(TypesImpl.Builtin target, TypesImpl.Builtin type, int value) {\n+\t\tassertThrows(IllegalArgumentException.class, () -> testPutBuiltinField(target, getArrayFieldName(type), value));\n+\t\tassertThrows(IllegalArgumentException.class, () -> testPutBuiltinFieldArray(target, getFieldName(type), value));\n+\t}\n+\n+\tprivate void testPutBuiltinField(TypesImpl.Builtin target, String fieldName, int value) {\n+\t\tswitch (target) {\n+\t\tcase BYTE: {\n+\t\t\tinstance.putField(fieldName, (byte) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase CHAR: {\n+\t\t\tinstance.putField(fieldName, (char) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase SHORT: {\n+\t\t\tinstance.putField(fieldName, (short) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase INT: {\n+\t\t\tinstance.putField(fieldName, (int) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase LONG: {\n+\t\t\tinstance.putField(fieldName, (long) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase FLOAT: {\n+\t\t\tinstance.putField(fieldName, (float) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase DOUBLE: {\n+\t\t\tinstance.putField(fieldName, (double) value);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase BOOLEAN: {\n+\t\t\tinstance.putField(fieldName, (int) (value) > 0);\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase STRING: {\n+\t\t\tinstance.putField(fieldName, String.valueOf(value));\n+\t\t\tbreak;\n+\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void testPutBuiltinFieldArray(TypesImpl.Builtin target, String fieldName, int value) {\n+\t\tswitch (target) {\n+\t\tcase BYTE: {\n+\t\t\tinstance.putField(fieldName, new byte[] {(byte) value});\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase CHAR: {\n+\t\t\tinstance.putField(fieldName, new char[] {(char) value});\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase SHORT: {\n+\t\t\tinstance.putField(fieldName, new short[] {(short) value});\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase INT: {\n+\t\t\tinstance.putField(fieldName, new int[] {(int) value});\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase LONG: {\n+\t\t\tinstance.putField(fieldName, new long[] {(long) value});\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase FLOAT: {\n+\t\t\tinstance.putField(fieldName, new float[] {(float) value});\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase DOUBLE: {\n+\t\t\tinstance.putField(fieldName, new double[] {(double) value});\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase BOOLEAN: {\n+\t\t\tinstance.putField(fieldName, new boolean[] {(int) (value) > 0});\n+\t\t\tbreak;\n+\t\t}\n+\t\tcase STRING: {\n+\t\t\tinstance.putField(fieldName, new String[] {String.valueOf(value)});\n+\t\t\tbreak;\n+\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static String getFieldName(TypesImpl.Builtin type) {\n+\t\treturn typeToFieldMap.get(type);\n+\t}\n+\n+\tprivate static String getArrayFieldName(TypesImpl.Builtin type) {\n+\t\treturn getFieldName(type) + \"_arr\";\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypedValueBuilderImplTest.java","additions":341,"deletions":0,"binary":false,"changes":341,"status":"added"},{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * The contents of this file are subject to the terms of either the Universal Permissive License\n+ * v 1.0 as shown at http:\/\/oss.oracle.com\/licenses\/upl\n+ *\n+ * or the following license:\n+ *\n+ * Redistribution and use in source and binary forms, with or without modification, are permitted\n+ * provided that the following conditions are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright notice, this list of conditions\n+ * and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright notice, this list of\n+ * conditions and the following disclaimer in the documentation and\/or other materials provided with\n+ * the distribution.\n+ *\n+ * 3. Neither the name of the copyright holder nor the names of its contributors may be used to\n+ * endorse or promote products derived from this software without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n+ * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmc.flightrecorder.writer;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+\n+class TypedValueImplTest {\n+\tprivate ConstantPools constantPools;\n+\tprivate MetadataImpl metadata;\n+\tprivate TypesImpl types;\n+\n+\t@BeforeEach\n+\tvoid setup() {\n+\t\tconstantPools = new ConstantPools();\n+\t\tmetadata = new MetadataImpl(constantPools);\n+\t\ttypes = new TypesImpl(metadata);\n+\t}\n+\n+\t@Test\n+\tvoid invalidValue() {\n+\t\tassertThrows(IllegalArgumentException.class, () -> types.getType(TypesImpl.Builtin.STRING).asValue(1));\n+\t}\n+\n+\t@Test\n+\tvoid ofBuiltinNonCp() {\n+\t\tTypeImpl type = types.getType(TypesImpl.Builtin.INT);\n+\t\tTypedValueImpl value = type.asValue(1);\n+\t\tassertNotNull(value);\n+\t\tassertEquals(type, value.getType());\n+\t\tassertEquals(1, value.getValue());\n+\t\tassertEquals(Long.MIN_VALUE, value.getConstantPoolIndex());\n+\t}\n+\n+\t@Test\n+\tvoid ofBuiltinCp() {\n+\t\tTypeImpl type = types.getType(TypesImpl.Builtin.STRING);\n+\t\tString targetValue = \"hello\";\n+\t\tTypedValueImpl value = type.asValue(targetValue);\n+\t\tassertNotNull(value);\n+\t\tassertFalse(value.isNull());\n+\t\tassertEquals(type, value.getType());\n+\t\tassertEquals(targetValue, value.getValue());\n+\t\tassertNotEquals(Long.MIN_VALUE, value.getConstantPoolIndex());\n+\t}\n+\n+\t@Test\n+\tvoid ofCustom() {\n+\t\tString targetValue = \"hello\";\n+\t\tTypeImpl type = types.getOrAdd(\"type.Custom\", t -> {\n+\t\t\tt.addField(\"field\", types.getType(TypesImpl.Builtin.STRING));\n+\t\t});\n+\n+\t\tTypedValueImpl value = type.asValue(v -> {\n+\t\t\tv.putField(\"field\", targetValue);\n+\t\t});\n+\t\tassertNotNull(value);\n+\t\tassertFalse(value.isNull());\n+\t\tassertEquals(type, value.getType());\n+\t\tassertEquals(targetValue, value.getValue());\n+\t\tassertNotEquals(Long.MIN_VALUE, value.getConstantPoolIndex());\n+\t}\n+\n+\t@Test\n+\tvoid ofCustomNoCP() {\n+\t\tTypeStructureImpl structure = new TypeStructureImpl(\n+\t\t\t\tCollections.singletonList(new TypedFieldImpl(types.getType(TypesImpl.Builtin.STRING), \"field\")),\n+\t\t\t\tCollections.emptyList());\n+\t\tCompositeTypeImpl nonCpType = new CompositeTypeImpl(1234, \"test.Type\", null, structure, null, types);\n+\n+\t\tTypedValueImpl typedValue = nonCpType.asValue(t -> {\n+\t\t\tt.putField(\"field\", \"Ho!\");\n+\t\t});\n+\t\tassertNotNull(typedValue);\n+\t}\n+\n+\t@ParameterizedTest\n+\t@EnumSource(TypesImpl.Builtin.class)\n+\tvoid ofNull(TypesImpl.Builtin type) {\n+\t\tTypedValueImpl nullValue = TypedValueImpl.ofNull(types.getType(type));\n+\t\tassertNotNull(nullValue);\n+\t\tassertTrue(nullValue.isNull());\n+\t\tassertThrows(NullPointerException.class, nullValue::getFieldValues);\n+\t}\n+\n+\t@Test\n+\tvoid ofNullInvalid() {\n+\t\tTestType type1 = new TestType(1234, \"test.Type\", null, constantPools, types) {\n+\t\t\t@Override\n+\t\t\tpublic boolean canAccept(Object value) {\n+\t\t\t\t\/\/ disallow null values\n+\t\t\t\treturn value != null;\n+\t\t\t}\n+\t\t};\n+\t\tassertThrows(IllegalArgumentException.class, () -> TypedValueImpl.ofNull(type1));\n+\t}\n+\n+\t@Test\n+\tvoid ofNullCustom() {\n+\t\tTypeImpl type = types.getOrAdd(\"type.Custom\", t -> {\n+\t\t\tt.addField(\"field\", types.getType(TypesImpl.Builtin.STRING));\n+\t\t});\n+\t\tassertNotNull(TypedValueImpl.ofNull(type));\n+\t}\n+\n+\t@Test\n+\tvoid copyBuiltinWithCp() {\n+\t\tint newCpIndex = 10;\n+\t\tTypeImpl type = types.getType(TypesImpl.Builtin.STRING);\n+\t\tString targetValue = \"hello\";\n+\t\tTypedValueImpl value = new TypedValueImpl(type, targetValue, -1);\n+\n+\t\tassertEquals(-1, value.getConstantPoolIndex());\n+\t\tassertThrows(IllegalArgumentException.class, () -> new TypedValueImpl(value, newCpIndex));\n+\t}\n+\n+\t@Test\n+\tvoid copyCustomWithCp() {\n+\t\tint newCpIndex = 10;\n+\t\tString targetValue = \"hello\";\n+\n+\t\tTypeImpl type = types.getOrAdd(\"type.Custom\", t -> {\n+\t\t\tt.addField(\"field\", types.getType(TypesImpl.Builtin.STRING));\n+\t\t});\n+\n+\t\tTypedValueImpl value = new TypedValueImpl(type, Collections.singletonMap(\"field\",\n+\t\t\t\tnew TypedFieldValueImpl(type.getField(\"field\"), type.getField(\"field\").getType().asValue(targetValue))),\n+\t\t\t\t-1);\n+\n+\t\tassertEquals(-1, value.getConstantPoolIndex());\n+\t\tassertEquals(newCpIndex, new TypedValueImpl(value, newCpIndex).getConstantPoolIndex());\n+\t}\n+\n+\t@Test\n+\tvoid getFieldValues() {\n+\t\tTypeImpl type = types.getOrAdd(\"type.Custom\", t -> {\n+\t\t\tt.addField(\"field1\", types.getType(TypesImpl.Builtin.STRING)).addField(\"field2\",\n+\t\t\t\t\ttypes.getType(TypesImpl.Builtin.STRING));\n+\t\t});\n+\n+\t\tTypedValueImpl typedValue = type.asValue(v -> {\n+\t\t\tv.putField(\"field1\", \"value1\");\n+\t\t});\n+\n+\t\tList<TypedFieldValueImpl> fields = typedValue.getFieldValues();\n+\t\tassertEquals(2, fields.size());\n+\t\tfor (TypedFieldValueImpl tValue : fields) {\n+\t\t\tassertNotNull(tValue);\n+\t\t\tif (tValue.getValue().isNull()) {\n+\t\t\t\tassertNull(tValue.getValue().getValue());\n+\t\t\t} else {\n+\t\t\t\tassertEquals(\"value1\", tValue.getValue().getValue());\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tvoid testEquality() {\n+\t\tTypeImpl type1 = types.getType(TypesImpl.Builtin.STRING);\n+\t\tTypeImpl type2 = types.getOrAdd(\"type.Custom\", t -> {\n+\t\t\tt.addField(\"field1\", types.getType(TypesImpl.Builtin.STRING)).addField(\"field2\",\n+\t\t\t\t\ttypes.getType(TypesImpl.Builtin.STRING));\n+\t\t});\n+\n+\t\tTypedValueImpl value1_1 = type1.asValue(\"hello\");\n+\t\tTypedValueImpl value1_2 = type1.asValue(\"world\");\n+\t\tTypedValueImpl value2_1 = type2.asValue(v -> {\n+\t\t\tv.putField(\"field1\", \"hello\");\n+\t\t});\n+\t\tTypedValueImpl value2_2 = type2.asValue(v -> {\n+\t\t\tv.putField(\"field2\", \"world\");\n+\t\t});\n+\n+\t\tassertEquals(value1_1, value1_1);\n+\t\tassertEquals(value1_2, value1_2);\n+\t\tassertEquals(value2_1, value2_1);\n+\t\tassertEquals(value2_2, value2_2);\n+\n+\t\tassertNotEquals(null, value1_1);\n+\t\tassertNotEquals(null, value1_2);\n+\t\tassertNotEquals(null, value2_1);\n+\t\tassertNotEquals(null, value2_2);\n+\n+\t\tassertNotEquals(value1_1, null);\n+\t\tassertNotEquals(value1_2, null);\n+\t\tassertNotEquals(value2_1, null);\n+\t\tassertNotEquals(value2_2, null);\n+\n+\t\tassertNotEquals(1, value1_1);\n+\t\tassertNotEquals(1, value1_2);\n+\t\tassertNotEquals(1, value2_1);\n+\t\tassertNotEquals(1, value2_2);\n+\n+\t\tassertNotEquals(value1_1, 1);\n+\t\tassertNotEquals(value1_2, 1);\n+\t\tassertNotEquals(value2_1, 1);\n+\t\tassertNotEquals(value2_2, 1);\n+\n+\t\tassertNotEquals(value1_1, value1_2);\n+\t\tassertNotEquals(value1_1, value2_1);\n+\t\tassertNotEquals(value1_1, value2_2);\n+\t\tassertNotEquals(value1_2, value1_1);\n+\t\tassertNotEquals(value1_2, value2_1);\n+\t\tassertNotEquals(value1_2, value2_2);\n+\t\tassertNotEquals(value2_1, value1_1);\n+\t\tassertNotEquals(value2_1, value1_2);\n+\t\tassertNotEquals(value2_1, value2_2);\n+\t\tassertNotEquals(value2_2, value1_1);\n+\t\tassertNotEquals(value2_2, value1_2);\n+\t\tassertNotEquals(value2_2, value2_1);\n+\t}\n+}\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/java\/org\/openjdk\/jmc\/flightrecorder\/writer\/TypedValueImplTest.java","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+mock-maker-inline\n","filename":"core\/org.openjdk.jmc.flightrecorder.writer\/src\/test\/resources\/mockito-extensions\/org.mockito.plugins.MockMaker","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -44,0 +44,2 @@\n+\t\t<maven.compiler.target>8<\/maven.compiler.target>\n+\t\t<maven.compiler.source>8<\/maven.compiler.source>\n","filename":"core\/org.openjdk.jmc.flightrecorder\/pom.xml","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+\t\t<module>org.openjdk.jmc.flightrecorder.writer<\/module>\n","filename":"core\/pom.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}