{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,14 +84,16 @@\n-\t\t\/\/ FIXME: Configuration attribute for warning limit and maybe safe usage\n-\t\tdouble safeUsage = 0.85;\n-\t\tdouble warningLimit = 0.95;\n-\t\tdouble usage = used.ratioTo(total);\n-\t\t\/\/ FIXME: Check that calculation gives a reasonable value\n-\t\t\/\/ double unsafeUse = (used - (total * safeUsage)) \/ (total * (1 - safeUsage));\n-\t\tdouble score = RulesToolkit.mapExp100(usage - safeUsage, 0, warningLimit - safeUsage);\n-\t\tif (score > 0) {\n-\t\t\treturn ResultBuilder.createFor(this, valueProvider).setSeverity(Severity.get(score))\n-\t\t\t\t\t.setSummary(Messages.getString(Messages.LowOnPhysicalMemoryFactory_TEXT_INFO))\n-\t\t\t\t\t.setExplanation(Messages.getString(Messages.LowOnPhysicalMemoryFactory_TEXT_INFO_LONG))\n-\t\t\t\t\t.addResult(TypedResult.SCORE, UnitLookup.NUMBER_UNITY.quantity(score))\n-\t\t\t\t\t.addResult(USED_MEMORY_RATIO, UnitLookup.PERCENT_UNITY.quantity(usage))\n-\t\t\t\t\t.addResult(TOTAL_MEMORY, total).addResult(MAX_USED_MEMORY, used).build();\n+\t\tif (used != null) {\n+\t\t\t\/\/ FIXME: Configuration attribute for warning limit and maybe safe usage\n+\t\t\tdouble safeUsage = 0.85;\n+\t\t\tdouble warningLimit = 0.95;\n+\t\t\tdouble usage = used.ratioTo(total);\n+\t\t\t\/\/ FIXME: Check that calculation gives a reasonable value\n+\t\t\t\/\/ double unsafeUse = (used - (total * safeUsage)) \/ (total * (1 - safeUsage));\n+\t\t\tdouble score = RulesToolkit.mapExp100(usage - safeUsage, 0, warningLimit - safeUsage);\n+\t\t\tif (score > 0) {\n+\t\t\t\treturn ResultBuilder.createFor(this, valueProvider).setSeverity(Severity.get(score))\n+\t\t\t\t\t\t.setSummary(Messages.getString(Messages.LowOnPhysicalMemoryFactory_TEXT_INFO))\n+\t\t\t\t\t\t.setExplanation(Messages.getString(Messages.LowOnPhysicalMemoryFactory_TEXT_INFO_LONG))\n+\t\t\t\t\t\t.addResult(TypedResult.SCORE, UnitLookup.NUMBER_UNITY.quantity(score))\n+\t\t\t\t\t\t.addResult(USED_MEMORY_RATIO, UnitLookup.PERCENT_UNITY.quantity(usage))\n+\t\t\t\t\t\t.addResult(TOTAL_MEMORY, total).addResult(MAX_USED_MEMORY, used).build();\n+\t\t\t}\n","filename":"core\/org.openjdk.jmc.flightrecorder.rules.jdk\/src\/main\/java\/org\/openjdk\/jmc\/flightrecorder\/rules\/jdk\/memory\/LowOnPhysicalMemoryRule.java","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3806,0 +3806,294 @@\n+    <report>\n+        <file>flight_recording_17eaMonitoredVM10440_3.jfr<\/file>\n+         <rule>\n+            <id>biasedLockingRevocationPause<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No revocation of biased locks found.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>SystemGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No garbage collections were caused by System.gc().<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>VMOperations<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No excessively long VM operations were found in this recording (the longest was 54.343 ms).<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>TlabAllocationRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The program allocated 3.08 % of the memory outside of TLABs.<\/summary>\n+            <solution>Allocating objects outside of Thread Local Allocation Buffers (TLABs) is more expensive than allocating inside TLABs. This may be acceptable if the individual allocations are intended to be larger than a reasonable TLAB. It may be possible to avoid this by decreasing the size of the individual allocations. There are some TLAB related JVM flags that you can experiment with, but it is usually better to let the JVM manage TLAB sizes automatically.<\/solution>\n+        <\/rule>\n+        <rule>\n+            <id>StackdepthSetting<\/id>\n+            <severity>Warning<\/severity>\n+            <summary>Some stack traces were truncated in this recording.<\/summary>\n+            <explanation>The Flight Recorder is configured with a maximum captured stack depth of 64. 10.5&#xA0;% of all traces were larger than this option, and were therefore truncated. If more detailed traces are required, increase the &#x27;&#x27;-XX:FlightRecorderOptions=stackdepth=&#x3C;value&#x3E;&#x27;&#x27; value.\n+Events of the following types have truncated stack traces: &#x3C;ul&#x3E;&#x3C;li&#x3E;Allocation in new TLAB (2.41&#xA0;% truncated traces)&#x3C;\/li&#x3E;&#x3C;li&#x3E;Allocation outside TLAB (1.45&#xA0;% truncated traces)&#x3C;\/li&#x3E;&#x3C;li&#x3E;Object Allocation Sample (3.06&#xA0;% truncated traces)&#x3C;\/li&#x3E;&#x3C;li&#x3E;Old Object Sample (44.4&#xA0;% truncated traces)&#x3C;\/li&#x3E;&#x3C;li&#x3E;Socket Write (48.1&#xA0;% truncated traces)&#x3C;\/li&#x3E;&#x3C;\/ul&#x3E;<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInSystemProperties<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInEnvironment<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>OverAggressiveRecordingSetting<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManyRunningProcesses<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ManagementAgent<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>LowOnPhysicalMemory<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The system did not run low on physical memory during this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingMetaSpaceLiveSet<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The class data does not seem to increase during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>IncreasingLiveSet<\/id>\n+            <severity>Not Applicable<\/severity>\n+            <summary>Too few events to calculate the result.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>HighJvmCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>HighGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The JVM was paused for 100 % during 7\/13\/2021 6:23:56.617.000 AM – .630<\/summary>\n+            <explanation>The time spent performing garbage collection may be reduced by increasing the heap size or by trying to reduce allocation.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>GcPauseRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by GC pauses.<\/summary>\n+            <explanation>The highest ratio between garbage collection pauses and execution time was 0.0311 % during 7\/13\/2021 6:23:54.000 AM – 6:24:54 AM. The garbage collection pause ratio of the entire recording was 0.00178 %.<\/explanation>\n+            <solution>Pause times may be reduced by increasing the heap size or by trying to reduce allocation.<\/solution>\n+        <\/rule>\n+        <rule>\n+            <id>GcOptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>GcFreedRatio<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Only 6 heap summary events were found, this rule requires at least 10 events to be able to calculate a relevant result. This likely means that only a few garbage collections occurred during the recording. Having few garbage collections is generally a good sign.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GarbageCollectionInfoRule<\/id>\n+            <severity>OK<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FullGc<\/id>\n+            <severity>Not Applicable<\/severity>\n+            <summary>This rule is only valid for CMS and G1 Garbage Collectors, neither of which were detected for this JVM.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>FlightRecordingSupport<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FileWrite<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No long file write pauses were found in this recording (the longest was 22.875 μs).<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>FileRead<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>FewSampledThreads<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Exceptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DiscouragedVmOptions<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompressedOops<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CompareCpu<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ApplicationHalts<\/id>\n+            <severity>OK<\/severity>\n+            <summary>Application efficiency was not highly affected by halts.<\/summary>\n+            <explanation>The highest ratio of application halts to execution time was 0.123 % during 7\/13\/2021 6:23:54.000 AM – 6:24:54 AM. 74.7 % of the halts were for reasons other than GC. The halts ratio for the entire recording was 0.00705 %. 74.7 % of the total halts were for reasons other than GC.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>Allocations.thread<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The most allocations were likely done by thread &#x27;&#x27;RMI TCP Connection(19)-192.168.29.191&#x27;&#x27; at: &#x3C;ul&#x3E;&#x3C;li&#x3E;void java.io.ObjectOutputStream$HandleTable.growEntries()&#x3C;\/li&#x3E;&#x3C;li&#x3E;int java.io.ObjectOutputStream$HandleTable.assign(Object)&#x3C;\/li&#x3E;&#x3C;\/ul&#x3E;<\/summary>\n+            <explanation>Many allocations performed by the same thread might indicate a problem in a multi-threaded program. Look at the stack traces for the thread with the highest allocation rate. See if the allocation rate can be brought down, or balanced among the active threads.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>Allocations.class<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The most allocated type is likely &#x27;&#x27;java.lang.Object[]&#x27;&#x27;, most commonly allocated by: &#x3C;ul&#x3E;&#x3C;li&#x3E;void java.io.ObjectOutputStream$HandleTable.growEntries()&#x3C;\/li&#x3E;&#x3C;li&#x3E;int java.io.ObjectOutputStream$HandleTable.assign(Object)&#x3C;\/li&#x3E;&#x3C;\/ul&#x3E;<\/summary>\n+            <explanation>Frequently allocated types are good places to start when trying to reduce garbage collections. Look at where the most common types are being allocated to see if many instances are created along the same call path. Try to reduce the number of instances created by invoking the most commonly taken paths less.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>StringDeduplication<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>SocketWrite<\/id>\n+            <severity>OK<\/severity>\n+            <summary>There are no socket write events in this recording.<\/summary>\n+            <explanation>Note that there are some socket write patterns with high duration writes that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>SocketRead<\/id>\n+            <severity>OK<\/severity>\n+            <summary>SocketReadRuleFactory_TEXT_NO_EVENTS<\/summary>\n+            <explanation>Note that there are some socket read patterns with high duration reads that we consider to be normal and are therefore excluded. Such patterns include JMX RMI communication and MQ series.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>ProcessStarted<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>PrimitiveToObjectConversion<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No allocation was caused by conversion from primitive types to the corresponding object types.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>PasswordsInArguments<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Options<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>MethodProfiling<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No methods where optimization would be particularly efficient could be detected.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>MetaspaceOom<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The metaspace was not exhausted during this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>LongGcPause<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The longest GC pause was 13.480 ms.<\/summary>\n+            <explanation\/>\n+        <\/rule>\n+        <rule>\n+            <id>JfrPeriodicEventsFix<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>JavaBlocking<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No excessive problems with lock contention found.<\/summary>\n+            <explanation>The following regular expression was used to exclude threads from this rule: ''(.*weblogic\\.socket\\.Muxer.*)''<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>HeapDump<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No heap dump performed.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>HeapContent<\/id>\n+            <severity>Warning<\/severity>\n+            <summary>Most of the heap was used by only a few classes.<\/summary>\n+            <explanation>If the heap usage needs to be reduced, then this would be a good place to start.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>Fatal Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>Errors<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DuplicateFlags<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DumpReason<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DebugNonSafepoints<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>DMSIncident<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ContextSwitch<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>CodeCache<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLoading<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No significant time was spent loading new classes during this recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>ClassLeak<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No classes with identical names have been loaded more times than the limit.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>BytecodeVerification<\/id>\n+            <severity>Not Applicable<\/severity>\n+        <\/rule>\n+        <rule>\n+            <id>BufferLost<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No Flight Recorder buffers were lost during the recording.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>HeapInspectionGc<\/id>\n+            <severity>OK<\/severity>\n+            <summary>The JVM did not perform any heap inspection GCs.<\/summary>\n+            <explanation>This is good since they usually take a lot of time.<\/explanation>\n+        <\/rule>\n+        <rule>\n+            <id>GcStall<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No indications that the garbage collector could not keep up with the workload were detected.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>GcLocker<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No GCs were affected by the GC Locker.<\/summary>\n+        <\/rule>\n+        <rule>\n+            <id>biasedLockingRevocation<\/id>\n+            <severity>OK<\/severity>\n+            <summary>No revocation of biased locks found.<\/summary>\n+        <\/rule>\n+    <\/report>\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/test\/resources\/baseline\/JfrRuleBaseline.xml","additions":294,"deletions":0,"binary":false,"changes":294,"status":"modified"},{"filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/test\/resources\/jfr\/flight_recording_17eaMonitoredVM10440_3.jfr","binary":true,"status":"added"},{"patch":"@@ -15,0 +15,1 @@\n+flight_recording_17eaMonitoredVM10440_3.jfr\n","filename":"core\/tests\/org.openjdk.jmc.flightrecorder.rules.jdk.test\/src\/test\/resources\/jfr\/index.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}