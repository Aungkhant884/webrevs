{"files":[{"patch":"@@ -0,0 +1,112 @@\n+#\n+# Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+ifeq (,$(_MAKEBASE_GMK))\n+  $(error You must include MakeBase.gmk prior to including CopyFiles.gmk)\n+endif\n+\n+################################################################################\n+#\n+# Code for handling the SetupCopyFiles macro.\n+#\n+################################################################################\n+\n+define AddFileToCopy\n+  # Helper macro for SetupCopyFiles\n+  # 1 : Source file\n+  # 2 : Dest file\n+  # 3 : Variable to add targets to\n+  # 4 : Macro to call for copy operation\n+  # 5 : Action text to log\n+  $2: $1\n+\t$$(call LogInfo, $(strip $5) $$(patsubst $(OUTPUTDIR)\/%,%,$$(call DecodeSpace, $$@)))\n+\t$$($$(strip $4))\n+\n+  $3 += $2\n+  $3_SOURCES += $1\n+endef\n+\n+# Returns the value of the first argument\n+identity = \\\n+    $(strip $1)\n+\n+# Setup make rules for copying files, with an option to do more complex\n+# processing instead of copying.\n+#\n+# Parameter 1 is the name of the rule. This name is used as variable prefix,\n+# and the targets generated are listed in a variable by that name.\n+#\n+# The list of all source files is returned in $1_SOURCES.\n+#\n+# Remaining parameters are named arguments. These include:\n+#   SRC     : Source root dir (defaults to dir of first file)\n+#   DEST    : Dest root dir\n+#   FILES   : List of files to copy with absolute paths, or path relative to SRC.\n+#             Must be in SRC.\n+#   FLATTEN : Set to flatten the directory structure in the DEST dir.\n+#   MACRO   : Optionally override the default macro used for making the copy.\n+#             Default is 'install-file'\n+#   NAME_MACRO : Optionally supply a macro that rewrites the target file name\n+#                based on the source file name\n+#   LOG_ACTION : Optionally specify a different action text for log messages\n+SetupCopyFiles = $(NamedParamsMacroTemplate)\n+define SetupCopyFilesBody\n+\n+  ifeq ($$($1_MACRO), )\n+    $1_MACRO := install-file\n+  endif\n+\n+  # Default SRC to the dir of the first file.\n+  ifeq ($$($1_SRC), )\n+    $1_SRC := $$(dir $$(firstword $$($1_FILES)))\n+  endif\n+\n+  ifeq ($$($1_NAME_MACRO), )\n+    $1_NAME_MACRO := identity\n+  endif\n+\n+  ifeq ($$($1_LOG_ACTION), )\n+    $1_LOG_ACTION := Copying\n+  endif\n+\n+  # Remove any trailing slash from SRC and DEST\n+  $1_SRC := $$(patsubst %\/,%,$$($1_SRC))\n+  $1_DEST := $$(patsubst %\/,%,$$($1_DEST))\n+\n+  # Need to wrap arguments in DoubleDollar because of the eval nested inside an\n+  # eval macro body.\n+  $$(foreach f, $$(patsubst $$($1_SRC)\/%,%,$$($1_FILES)), \\\n+    $$(eval $$(call AddFileToCopy, \\\n+        $$(call DoubleDollar, $$($1_SRC)\/$$f), \\\n+        $$(call DoubleDollar, \\\n+            $$($1_DEST)\/$$(call $$(strip $$($1_NAME_MACRO)),$$(if $$($1_FLATTEN),$$(notdir $$f),$$f)) \\\n+        ), \\\n+        $1, \\\n+        $$($1_MACRO), \\\n+        $$($1_LOG_ACTION) \\\n+    )) \\\n+  )\n+\n+endef\n","filename":"make\/common\/CopyFiles.gmk","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,3 +78,0 @@\n-##############################\n-# Functions\n-##############################\n@@ -82,1 +79,2 @@\n-### Debug functions\n+# For convenience, MakeBase.gmk continues to include these separate files, at\n+# least for now.\n@@ -84,3 +82,3 @@\n-# Prints the name and value of a variable\n-PrintVar = \\\n-    $(info $(strip $1) >$($(strip $1))<)\n+include $(TOPDIR)\/make\/common\/Utils.gmk\n+include $(TOPDIR)\/make\/common\/MakeIO.gmk\n+include $(TOPDIR)\/make\/common\/CopyFiles.gmk\n@@ -88,1 +86,3 @@\n-### Functions for timers\n+################################################################################\n+# Functions for timers\n+################################################################################\n@@ -124,221 +124,0 @@\n-################################################################################\n-# This macro translates $ into \\$ to protect the $ from expansion in the shell.\n-# To make this macro resilient against already escaped strings, first remove\n-# any present escapes before escaping so that no double escapes are added.\n-EscapeDollar = $(subst $$,\\$$,$(subst \\$$,$$,$(strip $1)))\n-\n-################################################################################\n-# This macro works just like EscapeDollar above, but for #.\n-EscapeHash = $(subst \\#,\\\\\\#,$(subst \\\\\\#,\\#,$(strip $1)))\n-\n-################################################################################\n-# This macro translates $ into $$ to protect the string from make itself.\n-DoubleDollar = $(subst $$,$$$$,$(strip $1))\n-\n-################################################################################\n-# ListPathsSafely can be used to print command parameters to a file. This is\n-# typically done if the command line lenght risk being too long for the\n-# OS\/shell. In later make versions, the file function can be used for this\n-# purpose. For earlier versions, a more complex implementation is provided.\n-#\n-# The function ListPathsSafely can be called either directly or, more commonly\n-# from a recipe line. If called from a recipe, it will be executed in the\n-# evaluation phase of that recipe, which means that it will write to the file\n-# before any other line in the recipe has been run.\n-ifeq ($(HAS_FILE_FUNCTION), true)\n-  # Param 1 - Name of variable containing paths\/arguments to output\n-  # Param 2 - File to print to\n-  # Param 3 - Set to true to append to file instead of overwriting\n-  define ListPathsSafely\n-    $$(call MakeDir, $$(dir $$(strip $2)))\n-    $$(file $$(if $$(filter true, $$(strip $3)),>>,>) \\\n-        $$(strip $2),$$(subst $$(SPACE),$$(NEWLINE),$$(strip $$($$(strip $1)))))\n-  endef\n-\n-else # HAS_FILE_FUNCTION = false\n-\n-  $(eval compress_paths = \\\n-      $(strip $(shell $(CAT) $(TOPDIR)\/make\/common\/support\/ListPathsSafely-pre-compress.incl)))\n-  compress_paths += \\\n-      $(subst $(TOPDIR),X97, \\\n-      $(subst $(OUTPUTDIR),X98, \\\n-      $(subst X,X00, \\\n-      $(subst $(SPACE),\\n,$(strip $1)))))\n-  $(eval compress_paths += \\\n-      $(strip $(shell $(CAT) $(TOPDIR)\/make\/common\/support\/ListPathsSafely-post-compress.incl)))\n-\n-  decompress_paths=$(SED) -f $(TOPDIR)\/make\/common\/support\/ListPathsSafely-uncompress.sed \\\n-      -e 's|X99|\\\\n|g' \\\n-      -e 's|X98|$(OUTPUTDIR)|g' -e 's|X97|$(TOPDIR)|g' \\\n-      -e 's|X00|X|g'\n-\n-  ListPathsSafely_IfPrintf = \\\n-      $(if $(word $3,$($(strip $1))), \\\n-          $(shell $(PRINTF) -- \"$(strip $(call EscapeDollar, \\\n-              $(call compress_paths, $(wordlist $3,$4,$($(strip $1))))))\\n\" \\\n-              | $(decompress_paths) >> $2))\n-\n-  # Param 1 - Name of variable containing paths\/arguments to output\n-  # Param 2 - File to print to\n-  # Param 3 - Set to true to append to file instead of overwriting\n-  define ListPathsSafely\n-    ifneq (,$$(word 30001,$$($$(strip $1))))\n-      $$(error Cannot list safely more than 30000 paths. $1 has $$(words $$($$(strip $1))) paths!)\n-    endif\n-    $$(call MakeDir, $$(dir $2))\n-    ifneq ($$(strip $3), true)\n-      $$(shell $(RM) $$(strip $2))\n-    endif\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,1,250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,251,500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,501,750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,751,1000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,1001,1250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,1251,1500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,1501,1750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,1751,2000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,2001,2250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,2251,2500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,2501,2750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,2751,3000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,3001,3250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,3251,3500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,3501,3750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,3751,4000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,4001,4250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,4251,4500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,4501,4750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,4751,5000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,5001,5250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,5251,5500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,5501,5750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,5751,6000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,6001,6250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,6251,6500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,6501,6750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,6751,7000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,7001,7250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,7251,7500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,7501,7750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,7751,8000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,8001,8250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,8251,8500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,8501,8750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,8751,9000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,9001,9250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,9251,9500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,9501,9750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,9751,10000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,10001,10250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,10251,10500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,10501,10750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,10751,11000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,11001,11250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,11251,11500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,11501,11750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,11751,12000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,12001,12250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,12251,12500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,12501,12750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,12751,13000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,13001,13250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,13251,13500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,13501,13750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,13751,14000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,14001,14250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,14251,14500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,14501,14750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,14751,15000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,15001,15250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,15251,15500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,15501,15750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,15751,16000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,16001,16250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,16251,16500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,16501,16750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,16751,17000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,17001,17250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,17251,17500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,17501,17750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,17751,18000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,18001,18250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,18251,18500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,18501,18750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,18751,19000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,19001,19250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,19251,19500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,19501,19750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,19751,20000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,20001,20250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,20251,20500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,20501,20750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,20751,21000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,21001,21250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,21251,21500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,21501,21750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,21751,22000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,22001,22250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,22251,22500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,22501,22750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,22751,23000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,23001,23250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,23251,23500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,23501,23750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,23751,24000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,24001,24250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,24251,24500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,24501,24750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,24751,25000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,25001,25250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,25251,25500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,25501,25750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,25751,26000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,26001,26250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,26251,26500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,26501,26750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,26751,27000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,27001,27250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,27251,27500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,27501,27750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,27751,28000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,28001,28250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,28251,28500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,28501,28750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,28751,29000)\n-\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,29001,29250)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,29251,29500)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,29501,29750)\n-    $$(call ListPathsSafely_IfPrintf,$1,$2,29751,30000)\n-  endef\n-endif # HAS_FILE_FUNCTION\n-\n@@ -416,15 +195,0 @@\n-################################################################################\n-# Creates a sequence of increasing numbers (inclusive).\n-# Param 1 - starting number\n-# Param 2 - ending number\n-sequence = \\\n-    $(wordlist $1, $2, $(strip \\\n-        $(eval SEQUENCE_COUNT :=) \\\n-        $(call _sequence-do,$(strip $2))))\n-\n-_sequence-do = \\\n-    $(if $(word $1, $(SEQUENCE_COUNT)),, \\\n-      $(eval SEQUENCE_COUNT += .) \\\n-      $(words $(SEQUENCE_COUNT)) \\\n-      $(call _sequence-do,$1))\n-\n@@ -472,10 +236,0 @@\n-################################################################################\n-# Replace question marks with space in string. This macro needs to be called on\n-# files from FindFiles in case any of them contains space in their file name,\n-# since FindFiles replaces space with ?.\n-# Param 1 - String to replace in\n-DecodeSpace = \\\n-    $(subst ?,$(SPACE),$(strip $1))\n-EncodeSpace = \\\n-    $(subst $(SPACE),?,$(strip $1))\n-\n@@ -509,7 +263,0 @@\n-################################################################################\n-# Assign a variable only if it is empty\n-# Param 1 - Variable to assign\n-# Param 2 - Value to assign\n-SetIfEmpty = \\\n-    $(if $($(strip $1)),,$(eval $(strip $1) := $2))\n-\n@@ -583,41 +330,0 @@\n-################################################################################\n-# Take two paths and return the path of the last common directory.\n-# Ex: \/foo\/bar\/baz, \/foo\/bar\/banan -> \/foo\/bar\n-#     foo\/bar\/baz, \/foo\/bar -> <empty>\n-#\n-# The x prefix is used to preserve the presence of the initial slash\n-#\n-# $1 - Path to compare\n-# $2 - Other path to compare\n-FindCommonPathPrefix = \\\n-    $(patsubst x%,%,$(subst $(SPACE),\/,$(strip \\\n-        $(call FindCommonPathPrefixHelper, \\\n-            $(subst \/,$(SPACE),x$(strip $1)), $(subst \/,$(SPACE),x$(strip $2))) \\\n-    )))\n-\n-FindCommonPathPrefixHelper = \\\n-    $(if $(call equals, $(firstword $1), $(firstword $2)), \\\n-      $(firstword $1) \\\n-      $(call FindCommonPathPrefixHelper, \\\n-          $(wordlist 2, $(words $1), $1), $(wordlist 2, $(words $2), $2) \\\n-      ) \\\n-    )\n-\n-# Convert a partial path into as many directory levels of ..\/, removing\n-# leading and following \/.\n-# Ex: foo\/bar\/baz\/ -> ..\/..\/..\n-#     foo\/bar -> ..\/..\n-#     \/foo -> ..\n-DirToDotDot = \\\n-    $(subst $(SPACE),\/,$(foreach d, $(subst \/,$(SPACE),$1),..))\n-\n-# Computes the relative path from a directory to a file\n-# $1 - File to compute the relative path to\n-# $2 - Directory to compute the relative path from\n-RelativePath = \\\n-    $(eval $1_prefix := $(call FindCommonPathPrefix, $1, $2)) \\\n-    $(eval $1_dotdots := $(call DirToDotDot, $(patsubst $($(strip $1)_prefix)%, %, $2))) \\\n-    $(eval $1_dotdots := $(if $($(strip $1)_dotdots),$($(strip $1)_dotdots),.)) \\\n-    $(eval $1_suffix := $(patsubst $($(strip $1)_prefix)\/%, %, $1)) \\\n-    $($(strip $1)_dotdots)\/$($(strip $1)_suffix)\n-\n@@ -660,51 +366,0 @@\n-################################################################################\n-# Filter out duplicate sub strings while preserving order. Keeps the first occurance.\n-uniq = \\\n-    $(strip $(if $1,$(firstword $1) $(call uniq,$(filter-out $(firstword $1),$1))))\n-\n-# Returns all whitespace-separated words in $2 where at least one of the\n-# whitespace-separated words in $1 is a substring.\n-containing = \\\n-    $(strip \\\n-        $(foreach v,$(strip $2),\\\n-          $(call uniq,$(foreach p,$(strip $1),$(if $(findstring $p,$v),$v)))))\n-\n-# Returns all whitespace-separated words in $2 where none of the\n-# whitespace-separated words in $1 is a substring.\n-not-containing = \\\n-    $(strip $(filter-out $(call containing,$1,$2),$2))\n-\n-# Return a list of all string elements that are duplicated in $1.\n-dups = \\\n-    $(strip $(foreach v, $(sort $1), $(if $(filter-out 1, \\\n-        $(words $(filter $v, $1))), $v)))\n-\n-# String equals\n-equals = \\\n-    $(and $(findstring $(strip $1),$(strip $2)),\\\n-        $(findstring $(strip $2),$(strip $1)))\n-\n-# Remove a whole list of prefixes\n-# $1 - List of prefixes\n-# $2 - List of elements to process\n-remove-prefixes = \\\n-    $(strip $(if $1,$(patsubst $(firstword $1)%,%,\\\n-      $(call remove-prefixes,$(filter-out $(firstword $1),$1),$2)),$2))\n-\n-# Convert the string given to upper case, without any $(shell)\n-# Inspired by http:\/\/lists.gnu.org\/archive\/html\/help-make\/2013-09\/msg00009.html\n-uppercase_table := a,A b,B c,C d,D e,E f,F g,G h,H i,I j,J k,K l,L m,M n,N o,O \\\n-    p,P q,Q r,R s,S t,T u,U v,V w,W x,X y,Y z,Z\n-\n-uppercase_internal = \\\n-  $(if $(strip $1), $$(subst $(firstword $1), $(call uppercase_internal, \\\n-      $(wordlist 2, $(words $1), $1), $2)), $2)\n-\n-# Convert a string to upper case. Works only on a-z.\n-# $1 - The string to convert\n-uppercase = \\\n-  $(strip \\\n-    $(eval uppercase_result := $(call uppercase_internal, $(uppercase_table), $1)) \\\n-    $(uppercase_result) \\\n-  )\n-\n@@ -825,138 +480,0 @@\n-################################################################################\n-\n-define AddFileToCopy\n-  # Helper macro for SetupCopyFiles\n-  # 1 : Source file\n-  # 2 : Dest file\n-  # 3 : Variable to add targets to\n-  # 4 : Macro to call for copy operation\n-  # 5 : Action text to log\n-  $2: $1\n-\t$$(call LogInfo, $(strip $5) $$(patsubst $(OUTPUTDIR)\/%,%,$$(call DecodeSpace, $$@)))\n-\t$$($$(strip $4))\n-\n-  $3 += $2\n-  $3_SOURCES += $1\n-endef\n-\n-# Returns the value of the first argument\n-identity = \\\n-    $(strip $1)\n-\n-# Setup make rules for copying files, with an option to do more complex\n-# processing instead of copying.\n-#\n-# Parameter 1 is the name of the rule. This name is used as variable prefix,\n-# and the targets generated are listed in a variable by that name.\n-#\n-# The list of all source files is returned in $1_SOURCES.\n-#\n-# Remaining parameters are named arguments. These include:\n-#   SRC     : Source root dir (defaults to dir of first file)\n-#   DEST    : Dest root dir\n-#   FILES   : List of files to copy with absolute paths, or path relative to SRC.\n-#             Must be in SRC.\n-#   FLATTEN : Set to flatten the directory structure in the DEST dir.\n-#   MACRO   : Optionally override the default macro used for making the copy.\n-#             Default is 'install-file'\n-#   NAME_MACRO : Optionally supply a macro that rewrites the target file name\n-#                based on the source file name\n-#   LOG_ACTION : Optionally specify a different action text for log messages\n-SetupCopyFiles = $(NamedParamsMacroTemplate)\n-define SetupCopyFilesBody\n-\n-  ifeq ($$($1_MACRO), )\n-    $1_MACRO := install-file\n-  endif\n-\n-  # Default SRC to the dir of the first file.\n-  ifeq ($$($1_SRC), )\n-    $1_SRC := $$(dir $$(firstword $$($1_FILES)))\n-  endif\n-\n-  ifeq ($$($1_NAME_MACRO), )\n-    $1_NAME_MACRO := identity\n-  endif\n-\n-  ifeq ($$($1_LOG_ACTION), )\n-    $1_LOG_ACTION := Copying\n-  endif\n-\n-  # Remove any trailing slash from SRC and DEST\n-  $1_SRC := $$(patsubst %\/,%,$$($1_SRC))\n-  $1_DEST := $$(patsubst %\/,%,$$($1_DEST))\n-\n-  # Need to wrap arguments in DoubleDollar because of the eval nested inside an\n-  # eval macro body.\n-  $$(foreach f, $$(patsubst $$($1_SRC)\/%,%,$$($1_FILES)), \\\n-    $$(eval $$(call AddFileToCopy, \\\n-        $$(call DoubleDollar, $$($1_SRC)\/$$f), \\\n-        $$(call DoubleDollar, \\\n-            $$($1_DEST)\/$$(call $$(strip $$($1_NAME_MACRO)),$$(if $$($1_FLATTEN),$$(notdir $$f),$$f)) \\\n-        ), \\\n-        $1, \\\n-        $$($1_MACRO), \\\n-        $$($1_LOG_ACTION) \\\n-    )) \\\n-  )\n-\n-endef\n-\n-################################################################################\n-# Parse a multiple-keyword variable, like FOO=\"KEYWORD1=val1;KEYWORD2=val2;...\"\n-# These will be converted into a series of variables like FOO_KEYWORD1=val1,\n-# FOO_KEYWORD2=val2, etc. Unknown keywords will cause an error.\n-#\n-# Parameter 1 is the name of the rule, and is also the name of the variable.\n-#\n-# Remaining parameters are named arguments. These include:\n-#   SINGLE_KEYWORDS   A list of valid keywords with single string values\n-#   STRING_KEYWORDS   A list of valid keywords, processed as string. This means\n-#       that '%20' will be replaced by ' ' to allow for multi-word strings.\n-#\n-ParseKeywordVariable = $(NamedParamsMacroTemplate)\n-define ParseKeywordVariableBody\n-  ifneq ($$($1), )\n-    # To preserve spaces, substitute them with a hopefully unique pattern\n-    # before splitting and then re-substitute spaces back.\n-    $1_MANGLED := $$(subst $$(SPACE),||||,$$($1))\n-    $$(foreach mangled_part, $$(subst ;, , $$($1_MANGLED)), \\\n-      $$(eval mangled_part_eval := $$(call DoubleDollar, $$(mangled_part))) \\\n-      $$(eval part := $$$$(subst ||||,$$$$(SPACE),$$$$(mangled_part_eval))) \\\n-      $$(eval $1_NO_MATCH := true) \\\n-      $$(foreach keyword, $$($1_SINGLE_KEYWORDS), \\\n-        $$(eval keyword_eval := $$(call DoubleDollar, $$(keyword))) \\\n-        $$(if $$(filter $$(keyword)=%, $$(part)), \\\n-          $$(eval $(strip $1)_$$$$(keyword_eval) := $$$$(strip $$$$(patsubst $$$$(keyword_eval)=%, %, $$$$(part)))) \\\n-          $$(eval $1_NO_MATCH := ) \\\n-        ) \\\n-      ) \\\n-      $$(foreach keyword, $$($1_STRING_KEYWORDS), \\\n-        $$(eval keyword_eval := $$(call DoubleDollar, $$(keyword))) \\\n-        $$(if $$(filter $$(keyword)=%, $$(part)), \\\n-          $$(eval $(strip $1)_$$$$(keyword_eval) := $$$$(strip $$$$(subst %20, , $$$$(patsubst $$$$(keyword_eval)=%, %, $$$$(part))))) \\\n-          $$(eval $1_NO_MATCH := ) \\\n-        ) \\\n-      ) \\\n-      $$(if $$($1_NO_MATCH), \\\n-        $$(if $$(filter $$(part), $$($1_SINGLE_KEYWORDS) $$($1_STRING_KEYWORDS)), \\\n-          $$(info Keyword $$(part) for $1 needs to be assigned a value.) \\\n-        , \\\n-          $$(info $$(part) is not a valid keyword for $1.) \\\n-          $$(info Valid keywords: $$($1_SINGLE_KEYWORDS) $$($1_STRING_KEYWORDS).) \\\n-        ) \\\n-        $$(error Cannot continue) \\\n-      ) \\\n-    )\n-  endif\n-endef\n-\n-################################################################################\n-# ShellQuote\n-#\n-# Quotes a string with single quotes and replaces single quotes with '\\'' so\n-# that the contents survives being given to the shell.\n-\n-ShellQuote = \\\n-    $(SQUOTE)$(subst $(SQUOTE),$(SQUOTE)\\$(SQUOTE)$(SQUOTE),$(strip $1))$(SQUOTE)\n-\n@@ -981,29 +498,0 @@\n-################################################################################\n-# Write to and read from file\n-\n-# Param 1 - File to read\n-ReadFile = \\\n-    $(shell $(CAT) $1)\n-\n-# Param 1 - Text to write\n-# Param 2 - File to write to\n-ifeq ($(HAS_FILE_FUNCTION), true)\n-  WriteFile = \\\n-      $(file >$2,$(strip $1))\n-else\n-  # Use printf to get consistent behavior on all platforms.\n-  WriteFile = \\\n-      $(shell $(PRINTF) \"%s\" $(call ShellQuote, $1) > $2)\n-endif\n-\n-# Param 1 - Text to write\n-# Param 2 - File to write to\n-ifeq ($(HAS_FILE_FUNCTION), true)\n-  AppendFile = \\\n-      $(file >>$2,$(strip $1))\n-else\n-  # Use printf to get consistent behavior on all platforms.\n-  AppendFile = \\\n-      $(shell $(PRINTF) \"%s\" $(call ShellQuote, $1) >> $2)\n-endif\n-\n@@ -1096,69 +584,0 @@\n-################################################################################\n-# Find lib dir for module\n-# Param 1 - module name\n-FindLibDirForModule = \\\n-    $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(strip $1)\n-\n-################################################################################\n-# Find executable dir for module\n-# Param 1 - module name\n-FindExecutableDirForModule = \\\n-    $(SUPPORT_OUTPUTDIR)\/modules_cmds\/$(strip $1)\n-\n-################################################################################\n-# Return a string suitable for use after a -classpath or --module-path option. It\n-# will be correct and safe to use on all platforms. Arguments are given as space\n-# separate classpath entries. Safe for multiple nested calls.\n-# param 1 : A space separated list of classpath entries\n-# The surrounding strip is needed to keep additional whitespace out\n-PathList = \\\n-  \"$(subst $(SPACE),:,$(strip $(subst $(DQUOTE),,$1)))\"\n-\n-################################################################################\n-# Check if a specified hotspot variant is being built, or at least one of a\n-# list of variants. Will return 'true' or 'false'.\n-# $1 - the variant to test for\n-check-jvm-variant = \\\n-  $(strip \\\n-    $(if $(filter-out $(VALID_JVM_VARIANTS), $1), \\\n-      $(error Internal error: Invalid variant tested: $1)) \\\n-    $(if $(filter $1, $(JVM_VARIANTS)), true, false))\n-\n-################################################################################\n-# Converts a space separated list to a comma separated list.\n-#\n-# Replacing double-comma with a single comma is to workaround the issue with\n-# some version of make on windows that doesn't substitute spaces with one comma\n-# properly.\n-CommaList = \\\n-  $(strip \\\n-      $(subst $(COMMA)$(COMMA),$(COMMA),$(subst $(SPACE),$(COMMA),$(strip $1))) \\\n-  )\n-\n-################################################################################\n-# Converts a space separated list to a colon separated list.\n-#\n-# Replacing double-colon with a single colon is to workaround the issue with\n-# some version of make on windows that doesn't substitute spaces with one colon\n-# properly.\n-ColonList = \\\n-  $(strip \\\n-      $(subst ::,:,$(subst $(SPACE),:,$(strip $1))) \\\n-  )\n-\n-################################################################################\n-# Given a list of files, filters out locale specific files for translations\n-# that should be excluded from this build.\n-# $1 - The list of files to filter\n-# $2 - The suffix of the files that should be considered (.java or .properties)\n-FilterExcludedTranslations = \\\n-  $(strip $(if $(EXCLUDE_TRANSLATIONS), \\\n-    $(filter-out \\\n-        $(foreach suffix, $2, \\\n-          $(addprefix %_, $(addsuffix $(suffix), $(EXCLUDE_TRANSLATIONS))) \\\n-        ), \\\n-        $1 \\\n-    ), \\\n-    $1 \\\n-  ))\n-\n","filename":"make\/common\/MakeBase.gmk","additions":9,"deletions":590,"binary":false,"changes":599,"status":"modified"},{"patch":"@@ -0,0 +1,272 @@\n+#\n+# Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+ifeq (,$(_MAKEBASE_GMK))\n+  $(error You must include MakeBase.gmk prior to including MakeIO.gmk)\n+endif\n+\n+################################################################################\n+#\n+# Functions for dealing with reading and writing from makefiles. Prior to GNU\n+# Make 4.0, this was tricky business.\n+#\n+################################################################################\n+\n+\n+################################################################################\n+# ListPathsSafely can be used to print command parameters to a file. This is\n+# typically done if the command line lenght risk being too long for the\n+# OS\/shell. In later make versions, the file function can be used for this\n+# purpose. For earlier versions, a more complex implementation is provided.\n+#\n+# The function ListPathsSafely can be called either directly or, more commonly\n+# from a recipe line. If called from a recipe, it will be executed in the\n+# evaluation phase of that recipe, which means that it will write to the file\n+# before any other line in the recipe has been run.\n+ifeq ($(HAS_FILE_FUNCTION), true)\n+  # Param 1 - Name of variable containing paths\/arguments to output\n+  # Param 2 - File to print to\n+  # Param 3 - Set to true to append to file instead of overwriting\n+  define ListPathsSafely\n+    $$(call MakeDir, $$(dir $$(strip $2)))\n+    $$(file $$(if $$(filter true, $$(strip $3)),>>,>) \\\n+        $$(strip $2),$$(subst $$(SPACE),$$(NEWLINE),$$(strip $$($$(strip $1)))))\n+  endef\n+\n+else # HAS_FILE_FUNCTION = false\n+\n+  $(eval compress_paths = \\\n+      $(strip $(shell $(CAT) $(TOPDIR)\/make\/common\/support\/ListPathsSafely-pre-compress.incl)))\n+  compress_paths += \\\n+      $(subst $(TOPDIR),X97, \\\n+      $(subst $(OUTPUTDIR),X98, \\\n+      $(subst X,X00, \\\n+      $(subst $(SPACE),\\n,$(strip $1)))))\n+  $(eval compress_paths += \\\n+      $(strip $(shell $(CAT) $(TOPDIR)\/make\/common\/support\/ListPathsSafely-post-compress.incl)))\n+\n+  decompress_paths=$(SED) -f $(TOPDIR)\/make\/common\/support\/ListPathsSafely-uncompress.sed \\\n+      -e 's|X99|\\\\n|g' \\\n+      -e 's|X98|$(OUTPUTDIR)|g' -e 's|X97|$(TOPDIR)|g' \\\n+      -e 's|X00|X|g'\n+\n+  ListPathsSafely_IfPrintf = \\\n+      $(if $(word $3,$($(strip $1))), \\\n+          $(shell $(PRINTF) -- \"$(strip $(call EscapeDollar, \\\n+              $(call compress_paths, $(wordlist $3,$4,$($(strip $1))))))\\n\" \\\n+              | $(decompress_paths) >> $2))\n+\n+  # Param 1 - Name of variable containing paths\/arguments to output\n+  # Param 2 - File to print to\n+  # Param 3 - Set to true to append to file instead of overwriting\n+  define ListPathsSafely\n+    ifneq (,$$(word 30001,$$($$(strip $1))))\n+      $$(error Cannot list safely more than 30000 paths. $1 has $$(words $$($$(strip $1))) paths!)\n+    endif\n+    $$(call MakeDir, $$(dir $2))\n+    ifneq ($$(strip $3), true)\n+      $$(shell $(RM) $$(strip $2))\n+    endif\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,1,250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,251,500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,501,750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,751,1000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,1001,1250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,1251,1500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,1501,1750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,1751,2000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,2001,2250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,2251,2500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,2501,2750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,2751,3000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,3001,3250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,3251,3500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,3501,3750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,3751,4000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,4001,4250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,4251,4500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,4501,4750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,4751,5000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,5001,5250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,5251,5500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,5501,5750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,5751,6000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,6001,6250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,6251,6500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,6501,6750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,6751,7000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,7001,7250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,7251,7500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,7501,7750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,7751,8000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,8001,8250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,8251,8500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,8501,8750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,8751,9000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,9001,9250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,9251,9500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,9501,9750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,9751,10000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,10001,10250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,10251,10500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,10501,10750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,10751,11000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,11001,11250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,11251,11500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,11501,11750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,11751,12000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,12001,12250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,12251,12500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,12501,12750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,12751,13000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,13001,13250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,13251,13500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,13501,13750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,13751,14000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,14001,14250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,14251,14500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,14501,14750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,14751,15000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,15001,15250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,15251,15500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,15501,15750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,15751,16000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,16001,16250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,16251,16500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,16501,16750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,16751,17000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,17001,17250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,17251,17500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,17501,17750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,17751,18000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,18001,18250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,18251,18500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,18501,18750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,18751,19000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,19001,19250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,19251,19500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,19501,19750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,19751,20000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,20001,20250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,20251,20500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,20501,20750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,20751,21000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,21001,21250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,21251,21500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,21501,21750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,21751,22000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,22001,22250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,22251,22500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,22501,22750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,22751,23000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,23001,23250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,23251,23500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,23501,23750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,23751,24000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,24001,24250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,24251,24500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,24501,24750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,24751,25000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,25001,25250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,25251,25500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,25501,25750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,25751,26000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,26001,26250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,26251,26500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,26501,26750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,26751,27000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,27001,27250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,27251,27500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,27501,27750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,27751,28000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,28001,28250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,28251,28500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,28501,28750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,28751,29000)\n+\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,29001,29250)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,29251,29500)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,29501,29750)\n+    $$(call ListPathsSafely_IfPrintf,$1,$2,29751,30000)\n+  endef\n+endif # HAS_FILE_FUNCTION\n+\n+################################################################################\n+# Write to and read from file\n+\n+# Param 1 - File to read\n+ReadFile = \\\n+    $(shell $(CAT) $1)\n+\n+# Param 1 - Text to write\n+# Param 2 - File to write to\n+ifeq ($(HAS_FILE_FUNCTION), true)\n+  WriteFile = \\\n+      $(file >$2,$(strip $1))\n+else\n+  # Use printf to get consistent behavior on all platforms.\n+  WriteFile = \\\n+      $(shell $(PRINTF) \"%s\" $(call ShellQuote, $1) > $2)\n+endif\n+\n+# Param 1 - Text to write\n+# Param 2 - File to write to\n+ifeq ($(HAS_FILE_FUNCTION), true)\n+  AppendFile = \\\n+      $(file >>$2,$(strip $1))\n+else\n+  # Use printf to get consistent behavior on all platforms.\n+  AppendFile = \\\n+      $(shell $(PRINTF) \"%s\" $(call ShellQuote, $1) >> $2)\n+endif\n","filename":"make\/common\/MakeIO.gmk","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -0,0 +1,304 @@\n+#\n+# Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+ifeq (,$(_MAKEBASE_GMK))\n+  $(error You must include MakeBase.gmk prior to including Utils.gmk)\n+endif\n+\n+################################################################################\n+#\n+# Common utility functions\n+#\n+################################################################################\n+\n+### Debug functions\n+\n+# Prints the name and value of a variable\n+PrintVar = \\\n+    $(info $(strip $1) >$($(strip $1))<)\n+\n+################################################################################\n+# This macro translates $ into \\$ to protect the $ from expansion in the shell.\n+# To make this macro resilient against already escaped strings, first remove\n+# any present escapes before escaping so that no double escapes are added.\n+EscapeDollar = $(subst $$,\\$$,$(subst \\$$,$$,$(strip $1)))\n+\n+################################################################################\n+# This macro works just like EscapeDollar above, but for #.\n+EscapeHash = $(subst \\#,\\\\\\#,$(subst \\\\\\#,\\#,$(strip $1)))\n+\n+################################################################################\n+# This macro translates $ into $$ to protect the string from make itself.\n+DoubleDollar = $(subst $$,$$$$,$(strip $1))\n+\n+################################################################################\n+# Creates a sequence of increasing numbers (inclusive).\n+# Param 1 - starting number\n+# Param 2 - ending number\n+sequence = \\\n+    $(wordlist $1, $2, $(strip \\\n+        $(eval SEQUENCE_COUNT :=) \\\n+        $(call _sequence-do,$(strip $2))))\n+\n+_sequence-do = \\\n+    $(if $(word $1, $(SEQUENCE_COUNT)),, \\\n+      $(eval SEQUENCE_COUNT += .) \\\n+      $(words $(SEQUENCE_COUNT)) \\\n+      $(call _sequence-do,$1))\n+\n+################################################################################\n+# Replace question marks with space in string. This macro needs to be called on\n+# files from FindFiles in case any of them contains space in their file name,\n+# since FindFiles replaces space with ?.\n+# Param 1 - String to replace in\n+DecodeSpace = \\\n+    $(subst ?,$(SPACE),$(strip $1))\n+EncodeSpace = \\\n+    $(subst $(SPACE),?,$(strip $1))\n+\n+################################################################################\n+# Assign a variable only if it is empty\n+# Param 1 - Variable to assign\n+# Param 2 - Value to assign\n+SetIfEmpty = \\\n+    $(if $($(strip $1)),,$(eval $(strip $1) := $2))\n+\n+################################################################################\n+# Take two paths and return the path of the last common directory.\n+# Ex: \/foo\/bar\/baz, \/foo\/bar\/banan -> \/foo\/bar\n+#     foo\/bar\/baz, \/foo\/bar -> <empty>\n+#\n+# The x prefix is used to preserve the presence of the initial slash\n+#\n+# $1 - Path to compare\n+# $2 - Other path to compare\n+FindCommonPathPrefix = \\\n+    $(patsubst x%,%,$(subst $(SPACE),\/,$(strip \\\n+        $(call FindCommonPathPrefixHelper, \\\n+            $(subst \/,$(SPACE),x$(strip $1)), $(subst \/,$(SPACE),x$(strip $2))) \\\n+    )))\n+\n+FindCommonPathPrefixHelper = \\\n+    $(if $(call equals, $(firstword $1), $(firstword $2)), \\\n+      $(firstword $1) \\\n+      $(call FindCommonPathPrefixHelper, \\\n+          $(wordlist 2, $(words $1), $1), $(wordlist 2, $(words $2), $2) \\\n+      ) \\\n+    )\n+\n+# Convert a partial path into as many directory levels of ..\/, removing\n+# leading and following \/.\n+# Ex: foo\/bar\/baz\/ -> ..\/..\/..\n+#     foo\/bar -> ..\/..\n+#     \/foo -> ..\n+DirToDotDot = \\\n+    $(subst $(SPACE),\/,$(foreach d, $(subst \/,$(SPACE),$1),..))\n+\n+# Computes the relative path from a directory to a file\n+# $1 - File to compute the relative path to\n+# $2 - Directory to compute the relative path from\n+RelativePath = \\\n+    $(eval $1_prefix := $(call FindCommonPathPrefix, $1, $2)) \\\n+    $(eval $1_dotdots := $(call DirToDotDot, $(patsubst $($(strip $1)_prefix)%, %, $2))) \\\n+    $(eval $1_dotdots := $(if $($(strip $1)_dotdots),$($(strip $1)_dotdots),.)) \\\n+    $(eval $1_suffix := $(patsubst $($(strip $1)_prefix)\/%, %, $1)) \\\n+    $($(strip $1)_dotdots)\/$($(strip $1)_suffix)\n+\n+################################################################################\n+# Filter out duplicate sub strings while preserving order. Keeps the first occurance.\n+uniq = \\\n+    $(strip $(if $1,$(firstword $1) $(call uniq,$(filter-out $(firstword $1),$1))))\n+\n+# Returns all whitespace-separated words in $2 where at least one of the\n+# whitespace-separated words in $1 is a substring.\n+containing = \\\n+    $(strip \\\n+        $(foreach v,$(strip $2),\\\n+          $(call uniq,$(foreach p,$(strip $1),$(if $(findstring $p,$v),$v)))))\n+\n+# Returns all whitespace-separated words in $2 where none of the\n+# whitespace-separated words in $1 is a substring.\n+not-containing = \\\n+    $(strip $(filter-out $(call containing,$1,$2),$2))\n+\n+# Return a list of all string elements that are duplicated in $1.\n+dups = \\\n+    $(strip $(foreach v, $(sort $1), $(if $(filter-out 1, \\\n+        $(words $(filter $v, $1))), $v)))\n+\n+# String equals\n+equals = \\\n+    $(and $(findstring $(strip $1),$(strip $2)),\\\n+        $(findstring $(strip $2),$(strip $1)))\n+\n+# Remove a whole list of prefixes\n+# $1 - List of prefixes\n+# $2 - List of elements to process\n+remove-prefixes = \\\n+    $(strip $(if $1,$(patsubst $(firstword $1)%,%,\\\n+      $(call remove-prefixes,$(filter-out $(firstword $1),$1),$2)),$2))\n+\n+# Convert the string given to upper case, without any $(shell)\n+# Inspired by http:\/\/lists.gnu.org\/archive\/html\/help-make\/2013-09\/msg00009.html\n+uppercase_table := a,A b,B c,C d,D e,E f,F g,G h,H i,I j,J k,K l,L m,M n,N o,O \\\n+    p,P q,Q r,R s,S t,T u,U v,V w,W x,X y,Y z,Z\n+\n+uppercase_internal = \\\n+  $(if $(strip $1), $$(subst $(firstword $1), $(call uppercase_internal, \\\n+      $(wordlist 2, $(words $1), $1), $2)), $2)\n+\n+# Convert a string to upper case. Works only on a-z.\n+# $1 - The string to convert\n+uppercase = \\\n+  $(strip \\\n+    $(eval uppercase_result := $(call uppercase_internal, $(uppercase_table), $1)) \\\n+    $(uppercase_result) \\\n+  )\n+\n+################################################################################\n+# Parse a multiple-keyword variable, like FOO=\"KEYWORD1=val1;KEYWORD2=val2;...\"\n+# These will be converted into a series of variables like FOO_KEYWORD1=val1,\n+# FOO_KEYWORD2=val2, etc. Unknown keywords will cause an error.\n+#\n+# Parameter 1 is the name of the rule, and is also the name of the variable.\n+#\n+# Remaining parameters are named arguments. These include:\n+#   SINGLE_KEYWORDS   A list of valid keywords with single string values\n+#   STRING_KEYWORDS   A list of valid keywords, processed as string. This means\n+#       that '%20' will be replaced by ' ' to allow for multi-word strings.\n+#\n+ParseKeywordVariable = $(NamedParamsMacroTemplate)\n+define ParseKeywordVariableBody\n+  ifneq ($$($1), )\n+    # To preserve spaces, substitute them with a hopefully unique pattern\n+    # before splitting and then re-substitute spaces back.\n+    $1_MANGLED := $$(subst $$(SPACE),||||,$$($1))\n+    $$(foreach mangled_part, $$(subst ;, , $$($1_MANGLED)), \\\n+      $$(eval mangled_part_eval := $$(call DoubleDollar, $$(mangled_part))) \\\n+      $$(eval part := $$$$(subst ||||,$$$$(SPACE),$$$$(mangled_part_eval))) \\\n+      $$(eval $1_NO_MATCH := true) \\\n+      $$(foreach keyword, $$($1_SINGLE_KEYWORDS), \\\n+        $$(eval keyword_eval := $$(call DoubleDollar, $$(keyword))) \\\n+        $$(if $$(filter $$(keyword)=%, $$(part)), \\\n+          $$(eval $(strip $1)_$$$$(keyword_eval) := $$$$(strip $$$$(patsubst $$$$(keyword_eval)=%, %, $$$$(part)))) \\\n+          $$(eval $1_NO_MATCH := ) \\\n+        ) \\\n+      ) \\\n+      $$(foreach keyword, $$($1_STRING_KEYWORDS), \\\n+        $$(eval keyword_eval := $$(call DoubleDollar, $$(keyword))) \\\n+        $$(if $$(filter $$(keyword)=%, $$(part)), \\\n+          $$(eval $(strip $1)_$$$$(keyword_eval) := $$$$(strip $$$$(subst %20, , $$$$(patsubst $$$$(keyword_eval)=%, %, $$$$(part))))) \\\n+          $$(eval $1_NO_MATCH := ) \\\n+        ) \\\n+      ) \\\n+      $$(if $$($1_NO_MATCH), \\\n+        $$(if $$(filter $$(part), $$($1_SINGLE_KEYWORDS) $$($1_STRING_KEYWORDS)), \\\n+          $$(info Keyword $$(part) for $1 needs to be assigned a value.) \\\n+        , \\\n+          $$(info $$(part) is not a valid keyword for $1.) \\\n+          $$(info Valid keywords: $$($1_SINGLE_KEYWORDS) $$($1_STRING_KEYWORDS).) \\\n+        ) \\\n+        $$(error Cannot continue) \\\n+      ) \\\n+    )\n+  endif\n+endef\n+\n+################################################################################\n+# ShellQuote\n+#\n+# Quotes a string with single quotes and replaces single quotes with '\\'' so\n+# that the contents survives being given to the shell.\n+ShellQuote = \\\n+    $(SQUOTE)$(subst $(SQUOTE),$(SQUOTE)\\$(SQUOTE)$(SQUOTE),$(strip $1))$(SQUOTE)\n+\n+################################################################################\n+# Find lib dir for module\n+# Param 1 - module name\n+FindLibDirForModule = \\\n+    $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(strip $1)\n+\n+################################################################################\n+# Find executable dir for module\n+# Param 1 - module name\n+FindExecutableDirForModule = \\\n+    $(SUPPORT_OUTPUTDIR)\/modules_cmds\/$(strip $1)\n+\n+################################################################################\n+# Return a string suitable for use after a -classpath or --module-path option. It\n+# will be correct and safe to use on all platforms. Arguments are given as space\n+# separate classpath entries. Safe for multiple nested calls.\n+# param 1 : A space separated list of classpath entries\n+# The surrounding strip is needed to keep additional whitespace out\n+PathList = \\\n+  \"$(subst $(SPACE),:,$(strip $(subst $(DQUOTE),,$1)))\"\n+\n+################################################################################\n+# Check if a specified hotspot variant is being built, or at least one of a\n+# list of variants. Will return 'true' or 'false'.\n+# $1 - the variant to test for\n+check-jvm-variant = \\\n+  $(strip \\\n+    $(if $(filter-out $(VALID_JVM_VARIANTS), $1), \\\n+      $(error Internal error: Invalid variant tested: $1)) \\\n+    $(if $(filter $1, $(JVM_VARIANTS)), true, false))\n+\n+################################################################################\n+# Converts a space separated list to a comma separated list.\n+#\n+# Replacing double-comma with a single comma is to workaround the issue with\n+# some version of make on windows that doesn't substitute spaces with one comma\n+# properly.\n+CommaList = \\\n+  $(strip \\\n+      $(subst $(COMMA)$(COMMA),$(COMMA),$(subst $(SPACE),$(COMMA),$(strip $1))) \\\n+  )\n+\n+################################################################################\n+# Converts a space separated list to a colon separated list.\n+#\n+# Replacing double-colon with a single colon is to workaround the issue with\n+# some version of make on windows that doesn't substitute spaces with one colon\n+# properly.\n+ColonList = \\\n+  $(strip \\\n+      $(subst ::,:,$(subst $(SPACE),:,$(strip $1))) \\\n+  )\n+\n+################################################################################\n+# Given a list of files, filters out locale specific files for translations\n+# that should be excluded from this build.\n+# $1 - The list of files to filter\n+# $2 - The suffix of the files that should be considered (.java or .properties)\n+FilterExcludedTranslations = \\\n+  $(strip $(if $(EXCLUDE_TRANSLATIONS), \\\n+    $(filter-out \\\n+        $(foreach suffix, $2, \\\n+          $(addprefix %_, $(addsuffix $(suffix), $(EXCLUDE_TRANSLATIONS))) \\\n+        ), \\\n+        $1 \\\n+    ), \\\n+    $1 \\\n+  ))\n","filename":"make\/common\/Utils.gmk","additions":304,"deletions":0,"binary":false,"changes":304,"status":"added"}]}