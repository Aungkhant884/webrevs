{"files":[{"patch":"@@ -70,3 +70,0 @@\n-  \/\/ Runs the given AbstractGangTask with the current active workers.\n-  \/\/ No workGang for CmsHeap, work serially with thread 0\n-  virtual void run_task(AbstractGangTask* task) { task->work(0); }\n","filename":"src\/hotspot\/share\/gc\/cms\/cmsHeap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -139,4 +139,0 @@\n-  \/\/ Runs the given AbstractGangTask with the current active workers\n-  \/\/ No workGang for EpsilonHeap, work serially with thread 0\n-  virtual void run_task(AbstractGangTask* task) { task->work(0); }\n-\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -156,4 +156,0 @@\n-void G1CollectedHeap::run_task(AbstractGangTask* task) {\n-   workers()->run_task(task, workers()->active_workers());\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -531,3 +531,0 @@\n-  \/\/ Runs the given AbstractGangTask with the current active workers.\n-  virtual void run_task(AbstractGangTask* task);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -607,6 +607,0 @@\n-void ParallelScavengeHeap::run_task(AbstractGangTask* task) {\n-  WorkGang workers(\"GC Threads\", ParallelGCThreads, true, false);\n-  workers.initialize_workers();\n-  workers.run_task(task);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -234,2 +234,0 @@\n-  \/\/ Runs the given AbstractGangTask with the current active workers.\n-  virtual void run_task(AbstractGangTask* task);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,3 +85,0 @@\n-  \/\/ Runs the given AbstractGangTask with the current active workers.\n-  \/\/ No workGang for SerialHeap, work serially with thread 0.\n-  virtual void run_task(AbstractGangTask* task) { task->work(0); }\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -531,3 +531,0 @@\n-  \/\/ Run given task. Possibly in parallel if the GC supports it.\n-  virtual void run_task(AbstractGangTask* task) = 0;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -202,0 +202,21 @@\n+\/\/ Temporarily try to set the number of active workers.\n+\/\/ It's not guaranteed that it succeeds, and users need to\n+\/\/ query the number of active workers.\n+class WithUpdatedActiveWorkers : public StackObj {\n+private:\n+  AbstractWorkGang* const _gang;\n+  const uint              _old_active_workers;\n+\n+public:\n+  WithUpdatedActiveWorkers(AbstractWorkGang* gang, uint requested_num_workers) :\n+      _gang(gang),\n+      _old_active_workers(gang->active_workers()) {\n+    uint capped_num_workers = MIN2(requested_num_workers, gang->total_workers());\n+    gang->update_active_workers(capped_num_workers);\n+  }\n+\n+  ~WithUpdatedActiveWorkers() {\n+    _gang->update_active_workers(_old_active_workers);\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/workgroup.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -209,4 +209,0 @@\n-  \/\/ Runs the given AbstractGangTask with the current active workers\n-  \/\/ No workGang for shenandoahHeap, work serially with thread 0\n-  virtual void run_task(AbstractGangTask* task) { task->work(0); }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,4 +106,0 @@\n-  \/\/ Runs the given AbstractGangTask with the current active workers.\n-  \/\/ No workGang for zHeap, work serially with thread 0\n-  virtual void run_task(AbstractGangTask* task) { task->work(0); }\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -783,7 +783,19 @@\n-    ParallelObjectIterator* poi = Universe::heap()->parallel_object_iterator(parallel_thread_num);\n-    if (poi != NULL) {\n-      ParHeapInspectTask task(poi, cit, filter);\n-      Universe::heap()->run_task(&task);\n-      delete poi;\n-      if (task.success()) {\n-        return task.missed_count();\n+    WorkGang* gang = Universe::heap()->get_safepoint_workers();\n+    if (gang != NULL) {\n+      \/\/ The GC provided a WorkGang to be used during a safepoint.\n+\n+      \/\/ Can't run with more threads than provided by the WorkGang.\n+      WithUpdatedActiveWorkers update_and_restore(gang, parallel_thread_num);\n+\n+      ParallelObjectIterator* poi = Universe::heap()->parallel_object_iterator(gang->active_workers());\n+      if (poi != NULL) {\n+        \/\/ The GC supports parallel object iteration.\n+\n+        ParHeapInspectTask task(poi, cit, filter);\n+        \/\/ Run task with the active workers.\n+        gang->run_task(&task);\n+\n+        delete poi;\n+        if (task.success()) {\n+          return task.missed_count();\n+        }\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"}]}