{"files":[{"patch":"@@ -50,1 +50,1 @@\n- * Implementation of an non-blocking SSLEngine.\n+ * Implementation of a non-blocking SSLEngine.\n@@ -253,1 +253,1 @@\n-                \/\/ Even the outboud is open, no futher data could be wrapped as:\n+                \/\/ Even the outbound is open, no further data could be wrapped as:\n@@ -727,5 +727,0 @@\n-        \/\/ Is it ready to close inbound?\n-        \/\/\n-        \/\/ No need to throw exception if the initial handshake is not started.\n-        if (!conContext.isInputCloseNotified &&\n-            (conContext.isNegotiated || conContext.handshakeContext != null)) {\n@@ -733,2 +728,11 @@\n-            throw conContext.fatal(Alert.INTERNAL_ERROR,\n-                    \"closing inbound before receiving peer's close_notify\");\n+        try {\n+            \/\/ Is it ready to close inbound?\n+            \/\/\n+            \/\/ No need to throw exception if the initial handshake is not started.\n+            if (!conContext.isInputCloseNotified &&\n+                (conContext.isNegotiated || conContext.handshakeContext != null)) {\n+                throw new SSLException(\n+                        \"closing inbound before receiving peer's close_notify\");\n+            }\n+        } finally {\n+            conContext.closeInbound();\n@@ -736,2 +740,0 @@\n-\n-        conContext.closeInbound();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineImpl.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -842,3 +842,4 @@\n-                (conContext.isNegotiated || conContext.handshakeContext != null)) {\n-            throw new SSLException(\n-                    \"closing inbound before receiving peer's close_notify\");\n+                    (conContext.isNegotiated ||\n+                            conContext.handshakeContext != null)) {\n+                throw new SSLException(\n+                        \"closing inbound before receiving peer's close_notify\");\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,491 @@\n+\/*\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\/\/\n+\n+\/*\n+ * @test\n+ * @bug 8273553 8253368\n+ * @summary sun.security.ssl.SSLEngineImpl.closeInbound also has similar error\n+ *          of JDK-8253368\n+ * @run main\/othervm SSLSocketSSLEngineCloseInbound TLSv1.3\n+ * @run main\/othervm SSLSocketSSLEngineCloseInbound TLSv1.2\n+ * @run main\/othervm SSLSocketSSLEngineCloseInbound TLSv1.1\n+ * @run main\/othervm SSLSocketSSLEngineCloseInbound TLSv1\n+ * @run main\/othervm SSLSocketSSLEngineCloseInbound TLS\n+ *\/\n+\n+\/**\n+ * A SSLSocket\/SSLEngine interop test case.  This is not the way to\n+ * code SSLEngine-based servers, but works for what we need to do here,\n+ * which is to make sure that SSLEngine\/SSLSockets can talk to each other.\n+ * SSLEngines can use direct or indirect buffers, and different code\n+ * is used to get at the buffer contents internally, so we test that here.\n+ *\n+ * The test creates one SSLSocket (client) and one SSLEngine (server).\n+ * The SSLSocket talks to a raw ServerSocket, and the server code\n+ * does the translation between byte [] and ByteBuffers that the SSLEngine\n+ * can use.  The \"transport\" layer consists of a Socket Input\/OutputStream\n+ * and two byte buffers for the SSLEngines:  think of them\n+ * as directly connected pipes.\n+ *\n+ * Again, this is a *very* simple example: real code will be much more\n+ * involved.  For example, different threading and I\/O models could be\n+ * used, transport mechanisms could close unexpectedly, and so on.\n+ *\n+ * When this application runs, notice that several messages\n+ * (wrap\/unwrap) pass before any application data is consumed or\n+ * produced.  (For more information, please see the SSL\/TLS\n+ * specifications.)  There may several steps for a successful handshake,\n+ * so it's typical to see the following series of operations:\n+ *\n+ *      client          server          message\n+ *      ======          ======          =======\n+ *      write()         ...             ClientHello\n+ *      ...             unwrap()        ClientHello\n+ *      ...             wrap()          ServerHello\/Certificate\n+ *      read()          ...             ServerHello\/Certificate\n+ *      write()         ...             ClientKeyExchange\n+ *      write()         ...             ChangeCipherSpec\n+ *      write()         ...             Finished\n+ *      ...             unwrap()        ClientKeyExchange\n+ *      ...             unwrap()        ChangeCipherSpec\n+ *      ...             unwrap()        Finished\n+ *      ...             wrap()          ChangeCipherSpec\n+ *      ...             wrap()          Finished\n+ *      read()          ...             ChangeCipherSpec\n+ *      read()          ...             Finished\n+ *\/\n+import javax.net.ssl.*;\n+import javax.net.ssl.SSLEngineResult.*;\n+import java.io.*;\n+import java.net.*;\n+import java.security.*;\n+import java.nio.*;\n+\n+public class SSLSocketSSLEngineCloseInbound {\n+\n+    \/*\n+     * Enables logging of the SSL\/TLS operations.\n+     *\/\n+    private static final boolean logging = true;\n+\n+    \/*\n+     * Enables the JSSE system debugging system property:\n+     *\n+     *     -Djavax.net.debug=all\n+     *\n+     * This gives a lot of low-level information about operations underway,\n+     * including specific handshake messages, and might be best examined\n+     * after gaining some familiarity with this application.\n+     *\/\n+    private static final boolean debug = false;\n+    private final SSLContext sslc;\n+    private SSLEngine serverEngine;     \/\/ server-side SSLEngine\n+    private SSLSocket clientSocket;\n+\n+    private final byte[] serverMsg =\n+        \"Hi there Client, I'm a Server.\".getBytes();\n+    private final byte[] clientMsg =\n+        \"Hello Server, I'm a Client! Pleased to meet you!\".getBytes();\n+\n+    private ByteBuffer serverOut;       \/\/ write side of serverEngine\n+    private ByteBuffer serverIn;        \/\/ read side of serverEngine\n+\n+    private volatile Exception clientException;\n+    private volatile Exception serverException;\n+\n+    \/*\n+     * For data transport, this example uses local ByteBuffers.\n+     *\/\n+    private ByteBuffer cTOs;            \/\/ \"reliable\" transport client->server\n+    private ByteBuffer sTOc;            \/\/ \"reliable\" transport server->client\n+\n+    \/*\n+     * The following is to set up the keystores\/trust material.\n+     *\/\n+    private static final String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n+    private static final String keyStoreFile = \"keystore\";\n+    private static final String trustStoreFile = \"truststore\";\n+    private static final String keyFilename =\n+            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores\n+            + \"\/\" + keyStoreFile;\n+    private static final String trustFilename =\n+            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores\n+            + \"\/\" + trustStoreFile;\n+\n+    \/*\n+     * Main entry point for this test.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        String protocol = args[0];\n+\n+        \/\/ reset security properties to make sure that the algorithms\n+        \/\/ and keys used in this test are not disabled.\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+        Security.setProperty(\"jdk.certpath.disabledAlgorithms\", \"\");\n+\n+        if (debug) {\n+            System.setProperty(\"javax.net.debug\", \"all\");\n+        }\n+\n+        \/*\n+         * Run the tests with direct and indirect buffers.\n+         *\/\n+        SSLSocketSSLEngineCloseInbound test =\n+            new SSLSocketSSLEngineCloseInbound(protocol);\n+        log(\"-------------------------------------\");\n+        log(\"Testing \" + protocol + \" for direct buffers ...\");\n+        test.runTest(true);\n+\n+        log(\"---------------------------------------\");\n+        log(\"Testing \" + protocol + \" for indirect buffers ...\");\n+        test.runTest(false);\n+\n+        log(\"Test Passed.\");\n+    }\n+\n+    \/*\n+     * Create an initialized SSLContext to use for these tests.\n+     *\/\n+    public SSLSocketSSLEngineCloseInbound(String protocol) throws Exception {\n+\n+        KeyStore ks = KeyStore.getInstance(\"JKS\");\n+        KeyStore ts = KeyStore.getInstance(\"JKS\");\n+\n+        char[] passphrase = \"passphrase\".toCharArray();\n+\n+        try (FileInputStream keyFile = new FileInputStream(keyFilename);\n+                FileInputStream trustFile = new FileInputStream(trustFilename)) {\n+            ks.load(keyFile, passphrase);\n+            ts.load(trustFile, passphrase);\n+        }\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passphrase);\n+\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+        tmf.init(ts);\n+\n+        SSLContext sslCtx = SSLContext.getInstance(protocol);\n+\n+        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        sslc = sslCtx;\n+    }\n+\n+    \/*\n+     * Run the test.\n+     *\n+     * Sit in a tight loop, with the server engine calling wrap\/unwrap\n+     * regardless of whether data is available or not.  We do this until\n+     * we get the application data.  Then we shutdown and go to the next one.\n+     *\n+     * The main loop handles all the I\/O phases of the SSLEngine's\n+     * lifetime:\n+     *\n+     *     initial handshaking\n+     *     application data transfer\n+     *     engine closing\n+     *\n+     * One could easily separate these phases into separate\n+     * sections of code.\n+     *\/\n+    private void runTest(boolean direct) throws Exception {\n+        clientSocket = null;\n+\n+        \/\/ generates the server-side Socket\n+        try (ServerSocket serverSocket = new ServerSocket()) {\n+            serverSocket.setReuseAddress(false);\n+            serverSocket.bind(null);\n+            int port = serverSocket.getLocalPort();\n+            log(\"Port: \" + port);\n+            Thread thread = createClientThread(port);\n+\n+            createSSLEngine();\n+            createBuffers(direct);\n+\n+            \/\/ server-side socket that will read\n+            try (Socket socket = serverSocket.accept()) {\n+                socket.setSoTimeout(500);\n+\n+                InputStream is = socket.getInputStream();\n+                OutputStream os = socket.getOutputStream();\n+\n+                SSLEngineResult serverResult;   \/\/ results from last operation\n+\n+                \/*\n+                 * Examining the SSLEngineResults could be much more involved,\n+                 * and may alter the overall flow of the application.\n+                 *\n+                 * For example, if we received a BUFFER_OVERFLOW when trying\n+                 * to write to the output pipe, we could reallocate a larger\n+                 * pipe, but instead we wait for the peer to drain it.\n+                 *\/\n+                byte[] inbound = new byte[8192];\n+                byte[] outbound = new byte[8192];\n+\n+                while (!isEngineClosed(serverEngine)) {\n+                    int len;\n+\n+                    \/\/ Inbound data\n+                    log(\"================\");\n+\n+                    \/\/ Try reading Client side, even if it's already closed.\n+                    try {\n+                        len = is.read(inbound);\n+                        if (len > 0) {\n+                            cTOs.put(inbound, 0, len);\n+                        }\n+                    } catch (IOException e) {\n+                        \/*\n+                         * swallow IO\/SocketTimeoutExceptions.  We'll do\n+                         * the testing\/exit after the unwraps.\n+                         *\/\n+                    }\n+\n+                    cTOs.flip();\n+\n+                    serverResult = serverEngine.unwrap(cTOs, serverIn);\n+                    log(\"server unwrap: \", serverResult);\n+                    runDelegatedTasks(serverResult, serverEngine);\n+                    cTOs.compact();\n+\n+                    \/\/ Outbound data\n+                    log(\"----\");\n+\n+                    \/\/ After we've received  our app bytes, close input side\n+                    \/\/ and see what happens.  Exit the test at the end.\n+                    if (serverIn.position() != 0) {\n+                        try {\n+                            serverEngine.closeInbound();\n+                            throw new Exception(\n+                                    \"No error shutting down client's input\");\n+                        } catch (SSLException e) {\n+                            System.out.println(\n+                                    \"Server caught the right Exception\");\n+                        }\n+\n+                        if (serverEngine.getSession().isValid()) {\n+                            System.out.println(\"Server session is still valid\");\n+                        } else {\n+                            throw new Exception(\"Server session is not valid\");\n+                        }\n+\n+                        return;\n+                    }\n+\n+                    serverResult = serverEngine.wrap(serverOut, sTOc);\n+                    log(\"server wrap: \", serverResult);\n+                    runDelegatedTasks(serverResult, serverEngine);\n+\n+                    sTOc.flip();\n+\n+                    if ((len = sTOc.remaining()) != 0) {\n+                        sTOc.get(outbound, 0, len);\n+                        os.write(outbound, 0, len);\n+                        \/\/ Give the other side a chance to process\n+                    }\n+\n+                    sTOc.compact();\n+                }\n+            } catch (Exception e) {\n+                serverException = e;\n+            } finally {\n+                \/\/ Wait for the client to join up with us.\n+                if (thread != null) {\n+                    thread.join();\n+                }\n+            }\n+        } finally {\n+            if (serverException != null) {\n+                if (clientException != null) {\n+                    serverException.initCause(clientException);\n+                }\n+                throw serverException;\n+            }\n+            if (clientException != null) {\n+                if (serverException != null) {\n+                    clientException.initCause(serverException);\n+                }\n+                throw clientException;\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Create a client thread which does simple SSLSocket operations.\n+     * We'll write and read one data packet.\n+     *\/\n+    private Thread createClientThread(final int port) {\n+\n+        Thread t = new Thread(\"ClientThread\") {\n+\n+            @Override\n+            public void run() {\n+                \/\/ client-side socket\n+                try (SSLSocket sslSocket = (SSLSocket)sslc.getSocketFactory().\n+                            createSocket(\"localhost\", port)) {\n+                    clientSocket = sslSocket;\n+\n+                    OutputStream os = sslSocket.getOutputStream();\n+\n+                    \/\/ write(byte[]) goes in one shot.\n+                    os.write(clientMsg);\n+                    os.flush();\n+\n+                    try {\n+                        sslSocket.shutdownInput();\n+                        throw new Exception(\n+                                \"No error shutting down client's input\");\n+                    } catch (SSLException e) {\n+                        System.out.println(\"Client caught the right Exception\");\n+                    }\n+\n+                    if (sslSocket.getSession().isValid()) {\n+                        System.out.println(\"Client session is still valid\");\n+                    } else {\n+                        throw new Exception(\"Client's session is not valid\");\n+                    }\n+\n+                    \/\/ Give server a chance to read before we shutdown via\n+                    \/\/ the try-with-resources block.\n+                    Thread.sleep(2000);\n+                } catch (Exception e) {\n+                    clientException = e;\n+                }\n+            }\n+        };\n+        t.start();\n+        return t;\n+    }\n+\n+    \/*\n+     * Using the SSLContext created during object creation,\n+     * create\/configure the SSLEngines we'll use for this test.\n+     *\/\n+    private void createSSLEngine() {\n+        \/*\n+         * Configure the serverEngine to act as a server in the SSL\/TLS\n+         * handshake.\n+         *\/\n+        serverEngine = sslc.createSSLEngine();\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.getNeedClientAuth();\n+    }\n+\n+    \/*\n+     * Create and size the buffers appropriately.\n+     *\/\n+    private void createBuffers(boolean direct) {\n+\n+        SSLSession session = serverEngine.getSession();\n+        int appBufferMax = session.getApplicationBufferSize();\n+        int netBufferMax = session.getPacketBufferSize();\n+\n+        \/*\n+         * We'll make the input buffers a bit bigger than the max needed\n+         * size, so that unwrap()s following a successful data transfer\n+         * won't generate BUFFER_OVERFLOWS.\n+         *\n+         * We'll use a mix of direct and indirect ByteBuffers for\n+         * tutorial purposes only.  In reality, only use direct\n+         * ByteBuffers when they give a clear performance enhancement.\n+         *\/\n+        if (direct) {\n+            serverIn = ByteBuffer.allocateDirect(appBufferMax + 50);\n+            cTOs = ByteBuffer.allocateDirect(netBufferMax);\n+            sTOc = ByteBuffer.allocateDirect(netBufferMax);\n+        } else {\n+            serverIn = ByteBuffer.allocate(appBufferMax + 50);\n+            cTOs = ByteBuffer.allocate(netBufferMax);\n+            sTOc = ByteBuffer.allocate(netBufferMax);\n+        }\n+\n+        serverOut = ByteBuffer.wrap(serverMsg);\n+    }\n+\n+    \/*\n+     * If the result indicates that we have outstanding tasks to do,\n+     * go ahead and run them in this thread.\n+     *\/\n+    private static void runDelegatedTasks(SSLEngineResult result,\n+            SSLEngine engine) throws Exception {\n+\n+        if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                log(\"\\trunning delegated task...\");\n+                runnable.run();\n+            }\n+            HandshakeStatus hsStatus = engine.getHandshakeStatus();\n+            if (hsStatus == HandshakeStatus.NEED_TASK) {\n+                throw new Exception(\n+                        \"handshake shouldn't need additional tasks\");\n+            }\n+            log(\"\\tnew HandshakeStatus: \" + hsStatus);\n+        }\n+    }\n+\n+    private static boolean isEngineClosed(SSLEngine engine) {\n+        return (engine.isOutboundDone() && engine.isInboundDone());\n+    }\n+\n+    \/*\n+     * Logging code\n+     *\/\n+    private static boolean resultOnce = true;\n+\n+    private static void log(String str, SSLEngineResult result) {\n+        if (!logging) {\n+            return;\n+        }\n+        if (resultOnce) {\n+            resultOnce = false;\n+            log(\"The format of the SSLEngineResult is: \\n\"\n+                    + \"\\t\\\"getStatus() \/ getHandshakeStatus()\\\" +\\n\"\n+                    + \"\\t\\\"bytesConsumed() \/ bytesProduced()\\\"\\n\");\n+        }\n+        HandshakeStatus hsStatus = result.getHandshakeStatus();\n+        log(str\n+                + result.getStatus() + \"\/\" + hsStatus + \", \"\n+                + result.bytesConsumed() + \"\/\" + result.bytesProduced()\n+                + \" bytes\");\n+        if (hsStatus == HandshakeStatus.FINISHED) {\n+            log(\"\\t...ready for application data\");\n+        }\n+    }\n+\n+    private static void log(String str) {\n+        if (logging) {\n+            if (debug) {\n+                System.err.println(str);\n+            } else {\n+                System.out.println(str);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SSLSocketSSLEngineCloseInbound.java","additions":491,"deletions":0,"binary":false,"changes":491,"status":"added"}]}