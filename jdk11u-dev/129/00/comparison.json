{"files":[{"patch":"@@ -326,2 +326,3 @@\n-  \/\/ If 'eq' then OK for recursive fast locking: store 0 into a lock record.\n-  str(tmp2, Address(disp_hdr, mark_offset), eq);\n+  \/\/ If still 'eq' then recursive locking OK\n+  \/\/ set to zero if recursive lock, set to non zero otherwise (see discussion in JDK-8267042)\n+  str(tmp2, Address(disp_hdr, mark_offset));\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1625,2 +1625,3 @@\n-    \/\/ If still 'eq' then recursive locking OK: set displaced header to 0\n-    __ str(Rtemp, Address(disp_hdr, BasicLock::displaced_header_offset_in_bytes()), eq);\n+    \/\/ If still 'eq' then recursive locking OK\n+    \/\/ set to zero if recursive lock, set to non zero otherwise (see discussion in JDK-8267042)\n+    __ str(Rtemp, Address(disp_hdr, BasicLock::displaced_header_offset_in_bytes()));\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c1;\n+\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+\n+\/*\n+ * @test\n+ * @author Chris Cole\n+ * @bug 8267042\n+ * @summary missing displaced_header initialization causes hangup\n+ * @run main\/othervm -XX:+TieredCompilation -XX:TieredStopAtLevel=1\n+ *                   -XX:-BackgroundCompilation -XX:CompileThreshold=1\n+ *                   -XX:CompileOnly=compiler.c1.Test8267042::write\n+ *                   compiler.c1.Test8267042\n+ *\/\n+public class Test8267042 {\n+\n+    private static int DATA_SIZE = 4;\n+\n+    private char buffer;\n+    private boolean empty = true;\n+\n+    public static void main(String[] args) {\n+        Test8267042 test = new Test8267042();\n+        test.run();\n+    }\n+\n+    private void run() {\n+        System.out.println(\"Starting test\");\n+\n+        Thread writeThread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                char data[] = new char[DATA_SIZE];\n+                try {\n+                    write(data, 0, data.length);\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        });\n+        writeThread.setDaemon(true);\n+        writeThread.start();\n+\n+        Thread readThread = new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                try {\n+                    for (int i = 0; i < DATA_SIZE; i++) {\n+                        read();\n+                    }\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        });\n+        readThread.setDaemon(true);\n+        readThread.start();\n+\n+        try {\n+            writeThread.join(5000);\n+            if (writeThread.isAlive()) {\n+                throw new InternalError(\"write thread deadlocked\");\n+            }\n+            readThread.join(5000);\n+            if (readThread.isAlive()) {\n+                throw new InternalError(\"read thread deadlocked\");\n+            }\n+        } catch (InterruptedException e) {\n+            throw new InternalError(\"unexpected InterrruptedException while waiting to join threads\", e);\n+        }\n+        System.out.println(\"Test passed\");\n+    }\n+\n+    synchronized void write(char data[], int offset, int length) throws IOException {\n+        while (--length >= 0) {\n+            getZeroOnStack(offset);\n+            write(data[offset++]);\n+        }\n+    }\n+\n+    synchronized void write(int c) throws IOException {\n+        while (!empty) {\n+            try {\n+                wait(1000);\n+            } catch (InterruptedException e) {\n+                throw new InterruptedIOException();\n+            }\n+        }\n+        buffer = (char) c;\n+        empty = false;\n+        notifyAll();\n+    }\n+\n+    public synchronized int read() throws IOException {\n+        while (empty) {\n+            try {\n+                System.out.println(\"read() before wait\");\n+                wait(1000);\n+                System.out.println(\"read() after wait\");\n+            } catch (InterruptedException e) {\n+                throw new InterruptedIOException();\n+            }\n+        }\n+        int value = buffer;\n+        empty = true;\n+        notifyAll();\n+        return value;\n+    }\n+\n+    private void getZeroOnStack(int offset) {\n+        int l1;\n+        int l2;\n+        int l3;\n+        int l4;\n+        int l5;\n+        int l6;\n+        int l7;\n+        int l8;\n+        int l9;\n+        int l10;\n+        int l11;\n+        int l12;\n+        int l13;\n+        int l14;\n+        int l15;\n+        int l16;\n+\n+        l1 = 0;\n+        l2 = 0;\n+        l3 = 0;\n+        l4 = 0;\n+        l5 = 0;\n+        l6 = 0;\n+        l7 = 0;\n+        l8 = 0;\n+        l9 = 0;\n+        l10 = 0;\n+        l11 = 0;\n+        l12 = 0;\n+        l13 = 0;\n+        l14 = 0;\n+        l15 = 0;\n+        l16 = 0;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/Test8267042.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"}]}