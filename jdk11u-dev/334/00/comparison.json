{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @library \/javax\/net\/ssl\/templates\n@@ -34,2 +35,3 @@\n-import java.io.*;\n-import javax.net.ssl.*;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.SSLSocket;\n+import java.util.concurrent.CountDownLatch;\n@@ -37,1 +39,1 @@\n-public class LegacyDHEKeyExchange {\n+public class LegacyDHEKeyExchange extends SSLSocketTemplate{\n@@ -39,5 +41,1 @@\n-    \/*\n-     * =============================================================\n-     * Set the various variables needed for the tests, then\n-     * specify what tests to run on each side.\n-     *\/\n+    private final CountDownLatch connDoneLatch = new CountDownLatch(2);\n@@ -45,6 +43,1 @@\n-    \/*\n-     * Should we run the client or server in a separate thread?\n-     * Both sides can throw exceptions, but do you have a preference\n-     * as to which side should be the main thread.\n-     *\/\n-    static boolean separateServerThread = false;\n+    private static final int LINGER_TIMEOUT = 30; \/\/ in seconds\n@@ -52,56 +45,5 @@\n-    \/*\n-     * Where do we find the keystores?\n-     *\/\n-    static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n-    static String keyStoreFile = \"keystore\";\n-    static String trustStoreFile = \"truststore\";\n-    static String passwd = \"passphrase\";\n-\n-    \/*\n-     * Is the server ready to serve?\n-     *\/\n-    volatile static boolean serverReady = false;\n-\n-    \/*\n-     * Turn on SSL debugging?\n-     *\/\n-    static boolean debug = false;\n-\n-    \/*\n-     * If the client or server is doing some kind of object creation\n-     * that the other side depends on, and that thread prematurely\n-     * exits, you may experience a hang.  The test harness will\n-     * terminate all hung threads after its timeout has expired,\n-     * currently 3 minutes by default, but you might try to be\n-     * smart about it....\n-     *\/\n-\n-    \/*\n-     * Define the server side of the test.\n-     *\n-     * If the server prematurely exits, serverReady will be set to true\n-     * to avoid infinite hangs.\n-     *\/\n-    void doServerSide() throws Exception {\n-        SSLServerSocketFactory sslssf =\n-            (SSLServerSocketFactory) SSLServerSocketFactory.getDefault();\n-        SSLServerSocket sslServerSocket =\n-            (SSLServerSocket) sslssf.createServerSocket(serverPort);\n-\n-        serverPort = sslServerSocket.getLocalPort();\n-\n-        \/*\n-         * Signal Client, we're ready for his connect.\n-         *\/\n-        serverReady = true;\n-\n-        try (SSLSocket sslSocket = (SSLSocket)sslServerSocket.accept()) {\n-            InputStream sslIS = sslSocket.getInputStream();\n-            OutputStream sslOS = sslSocket.getOutputStream();\n-\n-            sslIS.read();\n-            sslOS.write(85);\n-            sslOS.flush();\n-\n-            throw new Exception(\n-                \"Leagcy DH keys (< 1024) should be restricted\");\n+    @Override\n+    protected void runServerApplication(SSLSocket socket) throws Exception {\n+        try {\n+            super.runServerApplication(socket);\n+            throw new Exception(\"Legacy DH keys (< 1024) should be restricted\");\n@@ -109,1 +51,5 @@\n-            \/\/ ignore, client should terminate the connection\n+            String expectedExMsg = \"Received fatal alert: insufficient_security\";\n+            if (!expectedExMsg.equals(she.getMessage())) {\n+                throw she;\n+            }\n+            System.out.println(\"Expected exception thrown in server\");\n@@ -111,1 +57,2 @@\n-            sslServerSocket.close();\n+            connDoneLatch.countDown();\n+            connDoneLatch.await();\n@@ -115,20 +62,2 @@\n-    \/*\n-     * Define the client side of the test.\n-     *\n-     * If the server prematurely exits, serverReady will be set to true\n-     * to avoid infinite hangs.\n-     *\/\n-    void doClientSide() throws Exception {\n-\n-        \/*\n-         * Wait for server to get started.\n-         *\/\n-        while (!serverReady) {\n-            Thread.sleep(50);\n-        }\n-\n-        SSLSocketFactory sslsf =\n-            (SSLSocketFactory) SSLSocketFactory.getDefault();\n-        SSLSocket sslSocket = (SSLSocket)\n-            sslsf.createSocket(\"localhost\", serverPort);\n-\n+    @Override\n+    protected void runClientApplication(SSLSocket socket) throws Exception {\n@@ -136,1 +65,2 @@\n-        sslSocket.setEnabledCipherSuites(suites);\n+        socket.setEnabledCipherSuites(suites);\n+        socket.setSoLinger(true, LINGER_TIMEOUT);\n@@ -139,8 +69,2 @@\n-            InputStream sslIS = sslSocket.getInputStream();\n-            OutputStream sslOS = sslSocket.getOutputStream();\n-\n-            sslOS.write(280);\n-            sslOS.flush();\n-            sslIS.read();\n-\n-            throw new Exception(\"Leagcy DH keys (< 1024) should be restricted\");\n+            super.runClientApplication(socket);\n+            throw new Exception(\"Legacy DH keys (< 1024) should be restricted\");\n@@ -148,1 +72,6 @@\n-            \/\/ ignore, should be caused by algorithm constraints\n+            String expectedExMsg = \"DH ServerKeyExchange does not comply to\" +\n+                    \" algorithm constraints\";\n+            if (!expectedExMsg.equals(she.getMessage())) {\n+                throw she;\n+            }\n+            System.out.println(\"Expected exception thrown in client\");\n@@ -150,1 +79,2 @@\n-            sslSocket.close();\n+            connDoneLatch.countDown();\n+            connDoneLatch.await();\n@@ -154,11 +84,0 @@\n-    \/*\n-     * =============================================================\n-     * The remainder is just support stuff\n-     *\/\n-\n-    \/\/ use any free port by default\n-    volatile int serverPort = 0;\n-\n-    volatile Exception serverException = null;\n-    volatile Exception clientException = null;\n-\n@@ -166,158 +85,1 @@\n-        String keyFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-        String trustFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n-        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n-        System.setProperty(\"javax.net.ssl.keyStorePassword\", passwd);\n-        System.setProperty(\"javax.net.ssl.trustStore\", trustFilename);\n-        System.setProperty(\"javax.net.ssl.trustStorePassword\", passwd);\n-\n-        if (debug) {\n-            System.setProperty(\"javax.net.debug\", \"all\");\n-        }\n-\n-        \/*\n-         * Start the tests.\n-         *\/\n-        new LegacyDHEKeyExchange();\n-    }\n-\n-    Thread clientThread = null;\n-    Thread serverThread = null;\n-\n-    \/*\n-     * Primary constructor, used to drive remainder of the test.\n-     *\n-     * Fork off the other side, then do your work.\n-     *\/\n-    LegacyDHEKeyExchange() throws Exception {\n-        Exception startException = null;\n-        try {\n-            if (separateServerThread) {\n-                startServer(true);\n-                startClient(false);\n-            } else {\n-                startClient(true);\n-                startServer(false);\n-            }\n-        } catch (Exception e) {\n-            startException = e;\n-        }\n-\n-        \/*\n-         * Wait for other side to close down.\n-         *\/\n-        if (separateServerThread) {\n-            if (serverThread != null) {\n-                serverThread.join();\n-            }\n-        } else {\n-            if (clientThread != null) {\n-                clientThread.join();\n-            }\n-        }\n-\n-        \/*\n-         * When we get here, the test is pretty much over.\n-         * Which side threw the error?\n-         *\/\n-        Exception local;\n-        Exception remote;\n-\n-        if (separateServerThread) {\n-            remote = serverException;\n-            local = clientException;\n-        } else {\n-            remote = clientException;\n-            local = serverException;\n-        }\n-\n-        Exception exception = null;\n-\n-        \/*\n-         * Check various exception conditions.\n-         *\/\n-        if ((local != null) && (remote != null)) {\n-            \/\/ If both failed, return the curthread's exception.\n-            local.initCause(remote);\n-            exception = local;\n-        } else if (local != null) {\n-            exception = local;\n-        } else if (remote != null) {\n-            exception = remote;\n-        } else if (startException != null) {\n-            exception = startException;\n-        }\n-\n-        \/*\n-         * If there was an exception *AND* a startException,\n-         * output it.\n-         *\/\n-        if (exception != null) {\n-            if (exception != startException && startException != null) {\n-                exception.addSuppressed(startException);\n-            }\n-            throw exception;\n-        }\n-\n-        \/\/ Fall-through: no exception to throw!\n-    }\n-\n-    void startServer(boolean newThread) throws Exception {\n-        if (newThread) {\n-            serverThread = new Thread() {\n-                @Override\n-                public void run() {\n-                    try {\n-                        doServerSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our server thread just died.\n-                         *\n-                         * Release the client, if not active already...\n-                         *\/\n-                        System.err.println(\"Server died...\");\n-                        serverReady = true;\n-                        serverException = e;\n-                    }\n-                }\n-            };\n-            serverThread.start();\n-        } else {\n-            try {\n-                doServerSide();\n-            } catch (Exception e) {\n-                serverException = e;\n-            } finally {\n-                serverReady = true;\n-            }\n-        }\n-    }\n-\n-    void startClient(boolean newThread) throws Exception {\n-        if (newThread) {\n-            clientThread = new Thread() {\n-                @Override\n-                public void run() {\n-                    try {\n-                        doClientSide();\n-                    } catch (Exception e) {\n-                        \/*\n-                         * Our client thread just died.\n-                         *\/\n-                        System.err.println(\"Client died...\");\n-                        clientException = e;\n-                    }\n-                }\n-            };\n-            clientThread.start();\n-        } else {\n-            try {\n-                doClientSide();\n-            } catch (Exception e) {\n-                clientException = e;\n-            }\n-        }\n+        new LegacyDHEKeyExchange().run();\n","filename":"test\/jdk\/sun\/security\/ssl\/DHKeyExchange\/LegacyDHEKeyExchange.java","additions":35,"deletions":273,"binary":false,"changes":308,"status":"modified"}]}