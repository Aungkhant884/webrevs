{"files":[{"patch":"@@ -381,1 +381,3 @@\n-    io_buffer_size  = 8*M\n+    io_buffer_max_size = 8*M,\n+    io_buffer_min_size = 64*K,\n+    dump_segment_header_size = 9\n@@ -391,1 +393,4 @@\n-  jlong _dump_start;\n+  bool _in_dump_segment; \/\/ Are we currently in a dump segment?\n+  bool _is_huge_sub_record; \/\/ Are we writing a sub-record larger than the buffer size?\n+  DEBUG_ONLY(size_t _sub_record_left;) \/\/ The bytes not written for the current sub-record.\n+  DEBUG_ONLY(bool _sub_record_ended;) \/\/ True if we have called the end_sub_record().\n@@ -398,0 +403,3 @@\n+  bool is_open() const                          { return file_descriptor() >= 0; }\n+  void flush();\n+\n@@ -413,6 +421,0 @@\n-  bool is_open() const                  { return file_descriptor() >= 0; }\n-  void flush();\n-\n-  jlong dump_start() const                      { return _dump_start; }\n-  void set_dump_start(jlong pos);\n-  julong current_record_length();\n@@ -423,7 +425,0 @@\n-  \/\/ adjust the number of bytes written to disk (used to keep the count\n-  \/\/ of the number of bytes written in case of rewrites)\n-  void adjust_bytes_written(jlong n)    { _bytes_written += n; }\n-\n-  \/\/ number of (buffered) bytes as yet unwritten to the dump file\n-  size_t bytes_unwritten() const        { return position(); }\n-\n@@ -432,3 +427,0 @@\n-  jlong current_offset();\n-  void seek_to_offset(jlong pos);\n-\n@@ -445,0 +437,7 @@\n+\n+  \/\/ Start a new sub-record. Starts a new heap dump segment if needed.\n+  void start_sub_record(u1 tag, u4 len);\n+  \/\/ Ends the current sub-record.\n+  void end_sub_record();\n+  \/\/ Finishes the current dump segment if not already finished.\n+  void finish_dump_segment();\n@@ -447,1 +446,2 @@\n-DumpWriter::DumpWriter(const char* path, bool overwrite) {\n+DumpWriter::DumpWriter(const char* path, bool overwrite) : _fd(-1), _bytes_written(0), _pos(0),\n+                                                           _in_dump_segment(false), _error(NULL) {\n@@ -450,1 +450,1 @@\n-  _size = io_buffer_size;\n+  _size = io_buffer_max_size;\n@@ -456,11 +456,11 @@\n-  } while (_buffer == NULL && _size > 0);\n-  assert((_size > 0 && _buffer != NULL) || (_size == 0 && _buffer == NULL), \"sanity check\");\n-  _pos = 0;\n-  _error = NULL;\n-  _bytes_written = 0L;\n-  _dump_start = (jlong)-1;\n-  _fd = os::create_binary_file(path, overwrite);\n-\n-  \/\/ if the open failed we record the error\n-  if (_fd < 0) {\n-    _error = (char*)os::strdup(os::strerror(errno));\n+  } while (_buffer == NULL && _size >= io_buffer_min_size);\n+\n+  if (_buffer == NULL) {\n+    set_error(\"Could not allocate buffer memory for heap dump\");\n+  } else {\n+    _fd = os::create_binary_file(path, overwrite);    \/\/ don't replace existing file\n+\n+    \/\/ if the open failed we record the error\n+    if (_fd < 0) {\n+      set_error(os::strerror(errno));\n+    }\n@@ -471,6 +471,3 @@\n-  \/\/ flush and close dump file\n-  if (is_open()) {\n-    close();\n-  }\n-  if (_buffer != NULL) os::free(_buffer);\n-  if (_error != NULL) os::free(_error);\n+  close();\n+  os::free(_buffer);\n+  os::free(_error);\n@@ -489,16 +486,0 @@\n-\/\/ sets the dump starting position\n-void DumpWriter::set_dump_start(jlong pos) {\n-  _dump_start = pos;\n-}\n-\n-julong DumpWriter::current_record_length() {\n-  if (is_open()) {\n-    \/\/ calculate the size of the dump record\n-    julong dump_end = bytes_written() + bytes_unwritten();\n-    assert(dump_end == (size_t)current_offset(), \"checking\");\n-    julong dump_len = dump_end - dump_start() - 4;\n-    return dump_len;\n-  }\n-  return 0;\n-}\n-\n@@ -511,1 +492,1 @@\n-      uint tmp = (uint)MIN2(len, (size_t)UINT_MAX);\n+      uint tmp = (uint)MIN2(len, (size_t)INT_MAX);\n@@ -531,5 +512,7 @@\n-  if (is_open()) {\n-    \/\/ flush buffer to make room\n-    if ((position() + len) >= buffer_size()) {\n-      flush();\n-    }\n+  assert(!_in_dump_segment || (_sub_record_left >= len), \"sub-record too large\");\n+  debug_only(_sub_record_left -= len);\n+\n+  \/\/ flush buffer to make room\n+  if (len > buffer_size() - position()) {\n+    assert(!_in_dump_segment || _is_huge_sub_record, \"Cannot overflow in non-huge sub-record.\");\n+    flush();\n@@ -537,2 +520,2 @@\n-    \/\/ buffer not available or too big to buffer it\n-    if ((buffer() == NULL) || (len >= buffer_size())) {\n+    \/\/ If larger than the buffer, just write it directly.\n+    if (len > buffer_size()) {\n@@ -540,4 +523,2 @@\n-    } else {\n-      \/\/ Should optimize this for u1\/u2\/u4\/u8 sizes.\n-      memcpy(buffer() + position(), s, len);\n-      set_position(position() + len);\n+\n+      return;\n@@ -546,0 +527,3 @@\n+\n+  memcpy(buffer() + position(), s, len);\n+  set_position(position() + len);\n@@ -550,28 +534,2 @@\n-  if (is_open() && position() > 0) {\n-    write_internal(buffer(), position());\n-    set_position(0);\n-  }\n-}\n-\n-jlong DumpWriter::current_offset() {\n-  if (is_open()) {\n-    \/\/ the offset is the file offset plus whatever we have buffered\n-    jlong offset = os::current_file_offset(file_descriptor());\n-    assert(offset >= 0, \"lseek failed\");\n-    return offset + position();\n-  } else {\n-    return (jlong)-1;\n-  }\n-}\n-\n-void DumpWriter::seek_to_offset(jlong off) {\n-  assert(off >= 0, \"bad offset\");\n-\n-  \/\/ need to flush before seeking\n-  flush();\n-\n-  \/\/ may be closed due to I\/O error\n-  if (is_open()) {\n-    jlong n = os::seek_to_file_offset(file_descriptor(), off);\n-    assert(n >= 0, \"lseek failed\");\n-  }\n+  write_internal(buffer(), position());\n+  set_position(0);\n@@ -629,0 +587,23 @@\n+void DumpWriter::finish_dump_segment() {\n+  if (_in_dump_segment) {\n+    assert(_sub_record_left == 0, \"Last sub-record not written completely\");\n+    assert(_sub_record_ended, \"sub-record must have ended\");\n+\n+    \/\/ Fix up the dump segment length if we haven't written a huge sub-record last\n+    \/\/ (in which case the segment length was already set to the correct value initially).\n+    if (!_is_huge_sub_record) {\n+      assert(position() > dump_segment_header_size, \"Dump segment should have some content\");\n+      Bytes::put_Java_u4((address) (buffer() + 5), (u4) (position() - dump_segment_header_size));\n+    }\n+\n+    flush();\n+    _in_dump_segment = false;\n+  }\n+}\n+\n+void DumpWriter::start_sub_record(u1 tag, u4 len) {\n+  if (!_in_dump_segment) {\n+    if (position() > 0) {\n+      flush();\n+      assert(position() == 0, \"Must be at the start\");\n+    }\n@@ -630,0 +611,28 @@\n+    write_u1(HPROF_HEAP_DUMP_SEGMENT);\n+    write_u4(0); \/\/ timestamp\n+    \/\/ Will be fixed up later if we add more sub-records.  If this is a huge sub-record,\n+    \/\/ this is already the correct length, since we don't add more sub-records.\n+    write_u4(len);\n+    _in_dump_segment = true;\n+    _is_huge_sub_record = len > buffer_size() - dump_segment_header_size;\n+  } else if (_is_huge_sub_record || (len > buffer_size() - position())) {\n+    \/\/ This object will not fit in completely or the last sub-record was huge.\n+    \/\/ Finish the current segement and try again.\n+    finish_dump_segment();\n+    start_sub_record(tag, len);\n+\n+    return;\n+  }\n+\n+  debug_only(_sub_record_left = len);\n+  debug_only(_sub_record_ended = false);\n+\n+  write_u1(tag);\n+}\n+\n+void DumpWriter::end_sub_record() {\n+  assert(_in_dump_segment, \"must be in dump segment\");\n+  assert(_sub_record_left == 0, \"sub-record not written completely\");\n+  assert(!_sub_record_ended, \"Must not have ended yet\");\n+  debug_only(_sub_record_ended = true);\n+}\n@@ -643,0 +652,2 @@\n+  \/\/ Returns the size of the data to write.\n+  static u4 sig2size(Symbol* sig);\n@@ -653,0 +664,2 @@\n+  \/\/ returns the size of the static fields; also counts the static fields\n+  static u4 get_static_fields_size(InstanceKlass* ik, u2& field_count);\n@@ -657,0 +670,2 @@\n+  \/\/ get the count of the instance fields for a given class\n+  static u2 get_instance_fields_count(InstanceKlass* ik);\n@@ -678,6 +693,0 @@\n-  \/\/ writes a HPROF_HEAP_DUMP_SEGMENT record\n-  static void write_dump_header(DumpWriter* writer);\n-\n-  \/\/ fixes up the length of the current dump record\n-  static void write_current_dump_record_length(DumpWriter* writer);\n-\n@@ -726,0 +735,16 @@\n+u4 DumperSupport::sig2size(Symbol* sig) {\n+  switch (sig->byte_at(0)) {\n+    case JVM_SIGNATURE_CLASS:\n+    case JVM_SIGNATURE_ARRAY: return sizeof(address);\n+    case JVM_SIGNATURE_BOOLEAN:\n+    case JVM_SIGNATURE_BYTE: return 1;\n+    case JVM_SIGNATURE_SHORT:\n+    case JVM_SIGNATURE_CHAR: return 2;\n+    case JVM_SIGNATURE_INT:\n+    case JVM_SIGNATURE_FLOAT: return 4;\n+    case JVM_SIGNATURE_LONG:\n+    case JVM_SIGNATURE_DOUBLE: return 8;\n+    default: ShouldNotReachHere(); \/* to shut up compiler *\/ return 0;\n+  }\n+}\n+\n@@ -821,19 +846,1 @@\n-      Symbol* sig = fld.signature();\n-      switch (sig->byte_at(0)) {\n-        case JVM_SIGNATURE_CLASS   :\n-        case JVM_SIGNATURE_ARRAY   : size += oopSize; break;\n-\n-        case JVM_SIGNATURE_BYTE    :\n-        case JVM_SIGNATURE_BOOLEAN : size += 1; break;\n-\n-        case JVM_SIGNATURE_CHAR    :\n-        case JVM_SIGNATURE_SHORT   : size += 2; break;\n-\n-        case JVM_SIGNATURE_INT     :\n-        case JVM_SIGNATURE_FLOAT   : size += 4; break;\n-\n-        case JVM_SIGNATURE_LONG    :\n-        case JVM_SIGNATURE_DOUBLE  : size += 8; break;\n-\n-        default : ShouldNotReachHere();\n-      }\n+      size += sig2size(fld.signature());\n@@ -845,2 +852,1 @@\n-\/\/ dumps static fields of the given class\n-void DumperSupport::dump_static_fields(DumpWriter* writer, Klass* k) {\n+u4 DumperSupport::get_static_fields_size(InstanceKlass* ik, u2& field_count) {\n@@ -848,1 +854,2 @@\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n+  field_count = 0;\n+  u4 size = 0;\n@@ -850,2 +857,0 @@\n-  \/\/ pass 1 - count the static fields\n-  u2 field_count = 0;\n@@ -853,1 +858,4 @@\n-    if (fldc.access_flags().is_static()) field_count++;\n+    if (fldc.access_flags().is_static()) {\n+      field_count++;\n+      size += sig2size(fldc.signature());\n+    }\n@@ -862,0 +870,1 @@\n+    size += sizeof(address);\n@@ -868,0 +877,1 @@\n+      size += sizeof(address);\n@@ -877,0 +887,1 @@\n+    size += sizeof(address);\n@@ -879,1 +890,3 @@\n-  writer->write_u2(field_count);\n+  \/\/ We write the value itself plus a name and a one byte type tag per field.\n+  return size + field_count * (sizeof(address) + 1);\n+}\n@@ -881,1 +894,6 @@\n-  \/\/ pass 2 - dump the field descriptors and raw values\n+\/\/ dumps static fields of the given class\n+void DumperSupport::dump_static_fields(DumpWriter* writer, Klass* k) {\n+  HandleMark hm;\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n+\n+  \/\/ dump the field descriptors and raw values\n@@ -895,0 +913,1 @@\n+  oop resolved_references = ik->constants()->resolved_references_or_null();\n@@ -911,0 +930,1 @@\n+  oop init_lock = ik->init_lock();\n@@ -932,1 +952,1 @@\n-void DumperSupport::dump_instance_field_descriptors(DumpWriter* writer, Klass* k) {\n+u2 DumperSupport::get_instance_fields_count(InstanceKlass* ik) {\n@@ -934,3 +954,0 @@\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-\n-  \/\/ pass 1 - count the instance fields\n@@ -938,0 +955,1 @@\n+\n@@ -942,1 +960,7 @@\n-  writer->write_u2(field_count);\n+  return field_count;\n+}\n+\n+\/\/ dumps the definition of the instance fields for a given class\n+void DumperSupport::dump_instance_field_descriptors(DumpWriter* writer, Klass* k) {\n+  HandleMark hm;\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n@@ -944,1 +968,1 @@\n-  \/\/ pass 2 - dump the field descriptors\n+  \/\/ dump the field descriptors\n@@ -964,1 +988,5 @@\n-  writer->write_u1(HPROF_GC_INSTANCE_DUMP);\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n+  u4 is = instance_size(ik);\n+  u4 size = 1 + sizeof(address) + 4 + sizeof(address) + 4 + is;\n+\n+  writer->start_sub_record(HPROF_GC_INSTANCE_DUMP, size);\n@@ -969,1 +997,1 @@\n-  writer->write_classID(k);\n+  writer->write_classID(ik);\n@@ -972,1 +1000,1 @@\n-  writer->write_u4(instance_size(k) );\n+  writer->write_u4(is);\n@@ -976,0 +1004,2 @@\n+\n+  writer->end_sub_record();\n@@ -990,1 +1020,7 @@\n-  writer->write_u1(HPROF_GC_CLASS_DUMP);\n+  u2 static_fields_count = 0;\n+  u4 static_size = get_static_fields_size(ik, static_fields_count);\n+  u2 instance_fields_count = get_instance_fields_count(ik);\n+  u4 instance_fields_size = instance_fields_count * (sizeof(address) + 1);\n+  u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + static_size + 2 + instance_fields_size;\n+\n+  writer->start_sub_record(HPROF_GC_CLASS_DUMP, size);\n@@ -1013,1 +1049,1 @@\n-  writer->write_u4(DumperSupport::instance_size(k));\n+  writer->write_u4(DumperSupport::instance_size(ik));\n@@ -1018,2 +1054,3 @@\n-  \/\/ number of static fields\n-  dump_static_fields(writer, k);\n+  \/\/ static fields\n+  writer->write_u2(static_fields_count);\n+  dump_static_fields(writer, ik);\n@@ -1022,1 +1059,4 @@\n-  dump_instance_field_descriptors(writer, k);\n+  writer->write_u2(instance_fields_count);\n+  dump_instance_field_descriptors(writer, ik);\n+\n+  writer->end_sub_record();\n@@ -1025,1 +1065,1 @@\n-  k = k->array_klass_or_null();\n+  k = ik->array_klass_or_null();\n@@ -1027,2 +1067,1 @@\n-    Klass* klass = k;\n-    assert(klass->is_objArray_klass(), \"not an ObjArrayKlass\");\n+    assert(k->is_objArray_klass(), \"not an ObjArrayKlass\");\n@@ -1030,2 +1069,3 @@\n-    writer->write_u1(HPROF_GC_CLASS_DUMP);\n-    writer->write_classID(klass);\n+    u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + 2;\n+    writer->start_sub_record(HPROF_GC_CLASS_DUMP, size);\n+    writer->write_classID(k);\n@@ -1035,1 +1075,1 @@\n-    java_super = klass->java_super();\n+    java_super = k->java_super();\n@@ -1050,0 +1090,2 @@\n+    writer->end_sub_record();\n+\n@@ -1051,1 +1093,1 @@\n-    k = klass->array_klass_or_null();\n+    k = k->array_klass_or_null();\n@@ -1062,1 +1104,2 @@\n-    writer->write_u1(HPROF_GC_CLASS_DUMP);\n+    u4 size = 1 + sizeof(address) + 4 + 6 * sizeof(address) + 4 + 2 + 2 + 2;\n+    writer->start_sub_record(HPROF_GC_CLASS_DUMP, size);\n@@ -1082,0 +1125,2 @@\n+    writer->end_sub_record();\n+\n@@ -1103,0 +1148,1 @@\n+  uint max_bytes = max_juint - header_size;\n@@ -1104,16 +1150,0 @@\n-  \/\/ Create a new record if the current record is non-empty and the array can't fit.\n-  julong current_record_length = writer->current_record_length();\n-  if (current_record_length > 0 &&\n-      (current_record_length + header_size + length_in_bytes) > max_juint) {\n-    write_current_dump_record_length(writer);\n-    write_dump_header(writer);\n-\n-    \/\/ We now have an empty record.\n-    current_record_length = 0;\n-  }\n-\n-  \/\/ Calculate max bytes we can use.\n-  uint max_bytes = max_juint - (header_size + current_record_length);\n-\n-  \/\/ Array too long for the record?\n-  \/\/ Calculate max length and return it.\n@@ -1134,1 +1164,0 @@\n-\n@@ -1136,0 +1165,1 @@\n+  u4 size = header_size + length * sizeof(address);\n@@ -1137,1 +1167,1 @@\n-  writer->write_u1(HPROF_GC_OBJ_ARRAY_DUMP);\n+  writer->start_sub_record(HPROF_GC_OBJ_ARRAY_DUMP, size);\n@@ -1150,0 +1180,2 @@\n+\n+  writer->end_sub_record();\n@@ -1165,0 +1197,1 @@\n+  u4 size = header_size + length_in_bytes;\n@@ -1166,1 +1199,1 @@\n-  writer->write_u1(HPROF_GC_PRIM_ARRAY_DUMP);\n+  writer->start_sub_record(HPROF_GC_PRIM_ARRAY_DUMP, size);\n@@ -1174,0 +1207,1 @@\n+    writer->end_sub_record();\n@@ -1243,0 +1277,2 @@\n+\n+  writer->end_sub_record();\n@@ -1318,1 +1354,2 @@\n-    writer()->write_u1(HPROF_GC_ROOT_JNI_LOCAL);\n+    u4 size = 1 + sizeof(address) + 4 + 4;\n+    writer()->start_sub_record(HPROF_GC_ROOT_JNI_LOCAL, size);\n@@ -1322,0 +1359,1 @@\n+    writer()->end_sub_record();\n@@ -1349,1 +1387,2 @@\n-    writer()->write_u1(HPROF_GC_ROOT_JNI_GLOBAL);\n+    u4 size = 1 + 2 * sizeof(address);\n+    writer()->start_sub_record(HPROF_GC_ROOT_JNI_GLOBAL, size);\n@@ -1352,0 +1391,1 @@\n+    writer()->end_sub_record();\n@@ -1367,1 +1407,2 @@\n-    writer()->write_u1(HPROF_GC_ROOT_MONITOR_USED);\n+    u4 size = 1 + sizeof(address);\n+    writer()->start_sub_record(HPROF_GC_ROOT_MONITOR_USED, size);\n@@ -1369,0 +1410,1 @@\n+    writer()->end_sub_record();\n@@ -1387,3 +1429,4 @@\n-        writer()->write_u1(HPROF_GC_ROOT_STICKY_CLASS);\n-        writer()->write_classID(ik);\n-      }\n+      u4 size = 1 + sizeof(address);\n+      writer()->start_sub_record(HPROF_GC_ROOT_STICKY_CLASS, size);\n+      writer()->write_classID(ik);\n+      writer()->end_sub_record();\n@@ -1391,0 +1434,1 @@\n+  }\n@@ -1406,3 +1450,0 @@\n-  \/\/ used to indicate that a record has been writen\n-  void mark_end_of_record();\n-\n@@ -1430,1 +1471,0 @@\n-    mark_end_of_record();\n@@ -1434,1 +1474,0 @@\n-    mark_end_of_record();\n@@ -1438,1 +1477,0 @@\n-    mark_end_of_record();\n@@ -1528,2 +1566,0 @@\n-  \/\/ used to mark sub-record boundary\n-  void check_segment_length();\n@@ -1540,52 +1576,0 @@\n- \/\/ writes a HPROF_HEAP_DUMP_SEGMENT record\n-void DumperSupport::write_dump_header(DumpWriter* writer) {\n-  if (writer->is_open()) {\n-    writer->write_u1(HPROF_HEAP_DUMP_SEGMENT);\n-    writer->write_u4(0); \/\/ current ticks\n-\n-    \/\/ record the starting position for the dump (its length will be fixed up later)\n-    writer->set_dump_start(writer->current_offset());\n-    writer->write_u4(0);\n-  }\n-}\n-\n-\/\/ fixes up the length of the current dump record\n-void DumperSupport::write_current_dump_record_length(DumpWriter* writer) {\n-  if (writer->is_open()) {\n-    julong dump_end = writer->bytes_written() + writer->bytes_unwritten();\n-    julong dump_len = writer->current_record_length();\n-\n-    \/\/ record length must fit in a u4\n-    if (dump_len > max_juint) {\n-      warning(\"record is too large\");\n-    }\n-\n-    \/\/ seek to the dump start and fix-up the length\n-    assert(writer->dump_start() >= 0, \"no dump start recorded\");\n-    writer->seek_to_offset(writer->dump_start());\n-    writer->write_u4((u4)dump_len);\n-\n-    \/\/ adjust the total size written to keep the bytes written correct.\n-    writer->adjust_bytes_written(-((jlong) sizeof(u4)));\n-\n-    \/\/ seek to dump end so we can continue\n-    writer->seek_to_offset(dump_end);\n-\n-    \/\/ no current dump record\n-    writer->set_dump_start((jlong)-1);\n-  }\n-}\n-\n-\/\/ used on a sub-record boundary to check if we need to start a\n-\/\/ new segment.\n-void VM_HeapDumper::check_segment_length() {\n-  if (writer()->is_open()) {\n-    julong dump_len = writer()->current_record_length();\n-\n-    if (dump_len > 2UL*G) {\n-      DumperSupport::write_current_dump_record_length(writer());\n-      DumperSupport::write_dump_header(writer());\n-    }\n-  }\n-}\n-\n@@ -1594,2 +1578,1 @@\n-  if (writer->is_open()) {\n-    write_current_dump_record_length(writer);\n+  writer->finish_dump_segment();\n@@ -1597,9 +1580,3 @@\n-    writer->write_u1(HPROF_HEAP_DUMP_END);\n-    writer->write_u4(0);\n-    writer->write_u4(0);\n-  }\n-}\n-\n-\/\/ marks sub-record boundary\n-void HeapObjectDumper::mark_end_of_record() {\n-  dumper()->check_segment_length();\n+  writer->write_u1(HPROF_HEAP_DUMP_END);\n+  writer->write_u4(0);\n+  writer->write_u4(0);\n@@ -1695,1 +1672,2 @@\n-                writer()->write_u1(HPROF_GC_ROOT_JAVA_FRAME);\n+                u4 size = 1 + sizeof(address) + 4 + 4;\n+                writer()->start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);\n@@ -1699,0 +1677,1 @@\n+                writer()->end_sub_record();\n@@ -1707,1 +1686,2 @@\n-                 writer()->write_u1(HPROF_GC_ROOT_JAVA_FRAME);\n+                 u4 size = 1 + sizeof(address) + 4 + 4;\n+                 writer()->start_sub_record(HPROF_GC_ROOT_JAVA_FRAME, size);\n@@ -1711,0 +1691,1 @@\n+                 writer()->end_sub_record();\n@@ -1758,1 +1739,2 @@\n-    writer()->write_u1(HPROF_GC_ROOT_THREAD_OBJ);\n+    u4 size = 1 + sizeof(address) + 4 + 4;\n+    writer()->start_sub_record(HPROF_GC_ROOT_THREAD_OBJ, size);\n@@ -1762,0 +1744,1 @@\n+    writer()->end_sub_record();\n@@ -1836,3 +1819,0 @@\n-  \/\/ write HPROF_HEAP_DUMP_SEGMENT\n-  DumperSupport::write_dump_header(writer());\n-\n@@ -1842,1 +1822,0 @@\n-  check_segment_length();\n@@ -1855,1 +1834,0 @@\n-  check_segment_length();\n@@ -1860,1 +1838,0 @@\n-  check_segment_length();\n@@ -1867,1 +1844,0 @@\n-  check_segment_length();\n@@ -1875,1 +1851,1 @@\n-  \/\/ fixes up the length of the dump record and writes the HPROF_HEAP_DUMP_END record.\n+  \/\/ Writes the HPROF_HEAP_DUMP_END record.\n@@ -1949,1 +1925,1 @@\n-  if (!writer.is_open()) {\n+  if (writer.error() != NULL) {\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":232,"deletions":256,"binary":false,"changes":488,"status":"modified"}]}