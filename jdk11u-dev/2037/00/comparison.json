{"files":[{"patch":"@@ -39,0 +39,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -49,0 +50,1 @@\n+    static final AtomicInteger rogueCount = new AtomicInteger();\n@@ -155,0 +157,20 @@\n+    \/* basic smoke test: verify that server drops plain connections *\/\n+    static void testPlainText(String authority) throws Exception {\n+        URL url = new URL(\"http:\/\/\" + authority + \"\/Donauschiffsgesellschaftskapitaenskajuete\");\n+        System.out.println(\"client opening connection to: \" + url);\n+        HttpURLConnection urlc = (HttpURLConnection)url.openConnection(Proxy.NO_PROXY);\n+        int rogue = rogueCount.get();\n+        try {\n+            int code  = urlc.getResponseCode();\n+            System.out.println(\"Unexpected response: \" + code);\n+            throw new AssertionError(\"Unexpected response: \" + code);\n+        } catch (SocketException x) {\n+            \/\/ we expect that the server will drop the connection and\n+            \/\/ close the accepted socket, so we should get a SocketException\n+            \/\/ on the client side, and confirm that this::dropPlainTextConnections\n+            \/\/ has ben called.\n+            if (rogueCount.get() == rogue) throw x;\n+            System.out.println(\"Got expected exception: \" + x);\n+        }\n+    }\n+\n@@ -303,0 +325,1 @@\n+                testPlainText(server.getAuthority());\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/ChunkedOutputStream.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,11 @@\n+\n+    \/**\n+     * Tells whether the server should simply close the\n+     * connection and ignore the request when the first\n+     * byte received by the server looks like a plain\n+     * text connection.\n+     * @return true if the request should be ignored.\n+     **\/\n+    default boolean dropPlainTextConnections() {\n+        return false;\n+    }\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpCallback.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -289,0 +289,1 @@\n+        boolean handshakeStarted;\n@@ -337,0 +338,19 @@\n+                        if (!handshakeStarted && bytes > 0) {\n+                            handshakeStarted = true;\n+                            int byte0 = inNetBB.get(0);\n+                            if (byte0 != 0x16) {\n+                                \/\/ first byte of a TLS connection is supposed to be\n+                                \/\/ 0x16. If not it may be a plain text connection.\n+                                \/\/\n+                                \/\/ Sometime a rogue client may try to open a plain\n+                                \/\/ connection with our server. Calling this method\n+                                \/\/ gives a chance to the test logic to ignore such\n+                                \/\/ rogue connections.\n+                                \/\/\n+                                if (cb.dropPlainTextConnections()) {\n+                                    try { schan.close(); } catch (IOException x) { };\n+                                    return;\n+                                }\n+                                \/\/ else sslEng.unwrap will throw later on...\n+                            }\n+                        }\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/TestHttpsServer.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}