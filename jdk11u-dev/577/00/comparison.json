{"files":[{"patch":"@@ -1760,1 +1760,1 @@\n-    p_sig_msem = (msemaphore*)os::reserve_memory(sizeof(msemaphore), NULL);\n+    p_sig_msem = (msemaphore*)os::reserve_memory(sizeof(msemaphore));\n@@ -2376,13 +2376,1 @@\n-\/\/ Will assert if a wish address is given and could not be obtained.\n-char* os::pd_reserve_memory(size_t bytes, char* requested_addr, size_t alignment_hint) {\n-\n-  \/\/ All other Unices do a mmap(MAP_FIXED) if the addr is given,\n-  \/\/ thereby clobbering old mappings at that place. That is probably\n-  \/\/ not intended, never used and almost certainly an error were it\n-  \/\/ ever be used this way (to try attaching at a specified address\n-  \/\/ without clobbering old mappings an alternate API exists,\n-  \/\/ os::attempt_reserve_memory_at()).\n-  \/\/ Instead of mimicking the dangerous coding of the other platforms, here I\n-  \/\/ just ignore the request address (release) or assert(debug).\n-  assert0(requested_addr == NULL);\n-\n+char* os::pd_reserve_memory(size_t bytes, size_t alignment_hint) {\n@@ -2397,1 +2385,1 @@\n-    return reserve_mmaped_memory(bytes, requested_addr, alignment_hint);\n+    return reserve_mmaped_memory(bytes, NULL \/* requested_addr *\/, alignment_hint);\n@@ -2400,1 +2388,1 @@\n-      return reserve_shmated_memory(bytes, requested_addr, alignment_hint);\n+      return reserve_shmated_memory(bytes, NULL \/* requested_addr *\/, alignment_hint);\n@@ -2402,1 +2390,1 @@\n-      return reserve_mmaped_memory(bytes, requested_addr, alignment_hint);\n+      return reserve_mmaped_memory(bytes, NULL \/* requested_addr *\/, alignment_hint);\n@@ -2577,1 +2565,1 @@\n-char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {\n+char* os::pd_attempt_map_memory_to_file_at(size_t bytes, char* requested_addr, int file_desc) {\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":6,"deletions":18,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2114,3 +2114,0 @@\n-\/\/ If 'fixed' is true, anon_mmap() will attempt to reserve anonymous memory\n-\/\/ at 'requested_addr'. If there are existing memory mappings at the same\n-\/\/ location, however, they will be overwritten. If 'fixed' is false,\n@@ -2120,9 +2117,3 @@\n-static char* anon_mmap(char* requested_addr, size_t bytes, bool fixed) {\n-  char * addr;\n-  int flags;\n-\n-  flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;\n-  if (fixed) {\n-    assert((uintptr_t)requested_addr % os::Bsd::page_size() == 0, \"unaligned address\");\n-    flags |= MAP_FIXED;\n-  }\n+static char* anon_mmap(char* requested_addr, size_t bytes) {\n+  \/\/ MAP_FIXED is intentionally left out, to leave existing mappings intact.\n+  const int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;\n@@ -2133,2 +2124,1 @@\n-  addr = (char*)::mmap(requested_addr, bytes, PROT_NONE,\n-                       flags, -1, 0);\n+  char* addr = (char*)::mmap(requested_addr, bytes, PROT_NONE, flags, -1, 0);\n@@ -2143,3 +2133,3 @@\n-char* os::pd_reserve_memory(size_t bytes, char* requested_addr,\n-                            size_t alignment_hint) {\n-  return anon_mmap(requested_addr, bytes, (requested_addr != NULL));\n+char* os::pd_reserve_memory(size_t bytes, size_t alignment_hint) {\n+  \/\/ Ignores alignment hint\n+  return anon_mmap(NULL \/* addr *\/, bytes);\n@@ -2296,1 +2286,1 @@\n-char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {\n+char* os::pd_attempt_map_memory_to_file_at(size_t bytes, char* requested_addr, int file_desc) {\n@@ -2328,1 +2318,1 @@\n-  char * addr = anon_mmap(requested_addr, bytes, false);\n+  char * addr = anon_mmap(requested_addr, bytes);\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -3569,3 +3569,0 @@\n-\/\/ If 'fixed' is true, anon_mmap() will attempt to reserve anonymous memory\n-\/\/ at 'requested_addr'. If there are existing memory mappings at the same\n-\/\/ location, however, they will be overwritten. If 'fixed' is false,\n@@ -3575,9 +3572,3 @@\n-static char* anon_mmap(char* requested_addr, size_t bytes, bool fixed) {\n-  char * addr;\n-  int flags;\n-\n-  flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;\n-  if (fixed) {\n-    assert((uintptr_t)requested_addr % os::Linux::page_size() == 0, \"unaligned address\");\n-    flags |= MAP_FIXED;\n-  }\n+static char* anon_mmap(char* requested_addr, size_t bytes) {\n+  \/\/ MAP_FIXED is intentionally left out, to leave existing mappings intact.\n+  const int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;\n@@ -3588,2 +3579,1 @@\n-  addr = (char*)::mmap(requested_addr, bytes, PROT_NONE,\n-                       flags, -1, 0);\n+  char* addr = (char*)::mmap(requested_addr, bytes, PROT_NONE, flags, -1, 0);\n@@ -3602,2 +3592,1 @@\n-static char* anon_mmap_aligned(size_t bytes, size_t alignment, char* req_addr) {\n-\n+static char* anon_mmap_aligned(char* req_addr, size_t bytes, size_t alignment) {\n@@ -3609,6 +3598,2 @@\n-  char* start = (char*) ::mmap(req_addr, extra_size, PROT_NONE,\n-    MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE,\n-    -1, 0);\n-  if (start == MAP_FAILED) {\n-    start = NULL;\n-  } else {\n+  char* start = anon_mmap(req_addr, bytes);\n+  if (start != NULL) {\n@@ -3640,3 +3625,3 @@\n-char* os::pd_reserve_memory(size_t bytes, char* requested_addr,\n-                            size_t alignment_hint) {\n-  return anon_mmap(requested_addr, bytes, (requested_addr != NULL));\n+char* os::pd_reserve_memory(size_t bytes, size_t alignment_hint) {\n+  \/\/ Ignores alignment hint\n+  return anon_mmap(NULL, bytes);\n@@ -3950,1 +3935,1 @@\n-  char* pre_reserved_addr = anon_mmap_aligned(bytes, alignment, NULL);\n+  char* pre_reserved_addr = anon_mmap_aligned(NULL \/* req_addr *\/, bytes, alignment);\n@@ -4116,1 +4101,1 @@\n-  char* const start = anon_mmap_aligned(bytes, alignment, req_addr);\n+  char* const start = anon_mmap_aligned(req_addr, bytes, alignment);\n@@ -4285,1 +4270,1 @@\n-char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {\n+char* os::pd_attempt_map_memory_to_file_at(size_t bytes, char* requested_addr, int file_desc) {\n@@ -4317,1 +4302,1 @@\n-  char * addr = anon_mmap(requested_addr, bytes, false);\n+  char * addr = anon_mmap(requested_addr, bytes);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":14,"deletions":29,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -284,4 +284,1 @@\n-\/\/ Multiple threads can race in this code, and can remap over each other with MAP_FIXED,\n-\/\/ so on posix, unmap the section at the start and at the end of the chunk that we mapped\n-\/\/ rather than unmapping and remapping the whole chunk to get requested alignment.\n-char* os::reserve_memory_aligned(size_t size, size_t alignment, int file_desc) {\n+static size_t calculate_aligned_extra_size(size_t size, size_t alignment) {\n@@ -294,0 +291,2 @@\n+  return extra_size;\n+}\n@@ -295,19 +294,2 @@\n-  char* extra_base;\n-  if (file_desc != -1) {\n-    \/\/ For file mapping, we do not call os:reserve_memory(extra_size, NULL, alignment, file_desc) because\n-    \/\/ we need to deal with shrinking of the file space later when we release extra memory after alignment.\n-    \/\/ We also cannot called os:reserve_memory() with file_desc set to -1 because on aix we might get SHM memory.\n-    \/\/ So here to call a helper function while reserve memory for us. After we have a aligned base,\n-    \/\/ we will replace anonymous mapping with file mapping.\n-    extra_base = reserve_mmapped_memory(extra_size, NULL);\n-    if (extra_base != NULL) {\n-      MemTracker::record_virtual_memory_reserve((address)extra_base, extra_size, CALLER_PC);\n-    }\n-  } else {\n-    extra_base = os::reserve_memory(extra_size, NULL, alignment);\n-  }\n-\n-  if (extra_base == NULL) {\n-    return NULL;\n-  }\n-\n+\/\/ After a bigger chunk was mapped, unmaps start and end parts to get the requested alignment.\n+static char* chop_extra_memory(size_t size, size_t alignment, char* extra_base, size_t extra_size) {\n@@ -335,6 +317,31 @@\n-  if (file_desc != -1) {\n-    \/\/ After we have an aligned address, we can replace anonymous mapping with file mapping\n-    if (replace_existing_mapping_with_file_mapping(aligned_base, size, file_desc) == NULL) {\n-      vm_exit_during_initialization(err_msg(\"Error in mapping Java heap at the given filesystem directory\"));\n-    }\n-    MemTracker::record_virtual_memory_commit((address)aligned_base, size, CALLER_PC);\n+  return aligned_base;\n+}\n+\n+\/\/ Multiple threads can race in this code, and can remap over each other with MAP_FIXED,\n+\/\/ so on posix, unmap the section at the start and at the end of the chunk that we mapped\n+\/\/ rather than unmapping and remapping the whole chunk to get requested alignment.\n+char* os::reserve_memory_aligned(size_t size, size_t alignment) {\n+  size_t extra_size = calculate_aligned_extra_size(size, alignment);\n+  char* extra_base = os::reserve_memory(extra_size, alignment);\n+  if (extra_base == NULL) {\n+    return NULL;\n+  }\n+  return chop_extra_memory(size, alignment, extra_base, extra_size);\n+}\n+\n+char* os::map_memory_to_file_aligned(size_t size, size_t alignment, int file_desc) {\n+  size_t extra_size = calculate_aligned_extra_size(size, alignment);\n+  \/\/ For file mapping, we do not call os:map_memory_to_file(size,fd) since:\n+  \/\/ - we later chop away parts of the mapping using os::release_memory and that could fail if the\n+  \/\/   original mmap call had been tied to an fd.\n+  \/\/ - The memory API os::reserve_memory uses is an implementation detail. It may (and usually is)\n+  \/\/   mmap but it also may System V shared memory which cannot be uncommitted as a whole, so\n+  \/\/   chopping off and unmapping excess bits back and front (see below) would not work.\n+  char* extra_base = reserve_mmapped_memory(extra_size, NULL);\n+  if (extra_base == NULL) {\n+    return NULL;\n+  }\n+  char* aligned_base = chop_extra_memory(size, alignment, extra_base, extra_size);\n+  \/\/ After we have an aligned address, we can replace anonymous mapping with file mapping\n+  if (replace_existing_mapping_with_file_mapping(aligned_base, size, file_desc) == NULL) {\n+    vm_exit_during_initialization(err_msg(\"Error in mapping Java heap at the given filesystem directory\"));\n@@ -342,0 +349,1 @@\n+  MemTracker::record_virtual_memory_commit((address)aligned_base, size, CALLER_PC);\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":37,"deletions":29,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2554,1 +2554,2 @@\n-                             size_t alignment_hint, bool fixed) {\n+                             size_t alignment_hint) {\n+  \/\/ MAP_FIXED is intentionally left out, to leave existing mappings intact.\n@@ -2558,6 +2559,1 @@\n-  assert(!(fixed && (alignment_hint > 0)),\n-         \"alignment hint meaningless with fixed mmap\");\n-\n-  if (fixed) {\n-    flags |= MAP_FIXED;\n-  } else if (alignment_hint > (size_t) vm_page_size()) {\n+  if (alignment_hint > (size_t) vm_page_size()) {\n@@ -2574,4 +2570,2 @@\n-char* os::pd_reserve_memory(size_t bytes, char* requested_addr,\n-                            size_t alignment_hint) {\n-  char* addr = Solaris::anon_mmap(requested_addr, bytes, alignment_hint,\n-                                  (requested_addr != NULL));\n+char* os::pd_reserve_memory(size_t bytes, size_t alignment_hint) {\n+  char* addr = Solaris::anon_mmap(NULL \/* addr *\/, bytes, alignment_hint);\n@@ -2579,2 +2573,0 @@\n-  guarantee(requested_addr == NULL || requested_addr == addr,\n-            \"OS failed to return requested mmap address.\");\n@@ -2584,1 +2576,1 @@\n-char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {\n+char* os::pd_attempt_map_memory_to_file_at(size_t bytes, char* requested_addr, int file_desc) {\n@@ -2619,1 +2611,1 @@\n-  char* addr = Solaris::anon_mmap(requested_addr, bytes, 0, false);\n+  char* addr = Solaris::anon_mmap(requested_addr, bytes, 0);\n","filename":"src\/hotspot\/os\/solaris\/os_solaris.cpp","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  static char* anon_mmap(char* requested_addr, size_t bytes, size_t alignment_hint, bool fixed);\n+  static char* anon_mmap(char* requested_addr, size_t bytes, size_t alignment_hint);\n","filename":"src\/hotspot\/os\/solaris\/os_solaris.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3058,1 +3058,1 @@\n-      reserve_memory(split, base);\n+      attempt_reserve_memory_at(split, base);\n@@ -3061,1 +3061,1 @@\n-      reserve_memory(size - split, base + split);\n+      attempt_reserve_memory_at(size - split, base + split);\n@@ -3069,1 +3069,1 @@\n-char* os::reserve_memory_aligned(size_t size, size_t alignment, int file_desc) {\n+static char* map_or_reserve_memory_aligned(size_t size, size_t alignment, int file_desc) {\n@@ -3081,1 +3081,3 @@\n-    char* extra_base = os::reserve_memory(extra_size, NULL, alignment, file_desc);\n+    char* extra_base = file_desc != -1 ?\n+      os::map_memory_to_file(extra_size, file_desc) :\n+      os::reserve_memory(extra_size, alignment);\n@@ -3099,1 +3101,3 @@\n-    aligned_base = os::reserve_memory(size, aligned_base, 0, file_desc);\n+    aligned_base = file_desc != -1 ?\n+      os::attempt_map_memory_to_file_at(size, aligned_base, file_desc) :\n+      os::attempt_reserve_memory_at(size, aligned_base);\n@@ -3108,1 +3112,16 @@\n-char* os::pd_reserve_memory(size_t bytes, char* addr, size_t alignment_hint) {\n+char* os::reserve_memory_aligned(size_t size, size_t alignment) {\n+  return map_or_reserve_memory_aligned(size, alignment, -1 \/* file_desc *\/);\n+}\n+\n+char* os::map_memory_to_file_aligned(size_t size, size_t alignment, int fd) {\n+  return map_or_reserve_memory_aligned(size, alignment, fd);\n+}\n+\n+char* os::pd_reserve_memory(size_t bytes, size_t alignment_hint) {\n+  \/\/ Ignores alignment hint\n+  return pd_attempt_reserve_memory_at(bytes, NULL \/* addr *\/);\n+}\n+\n+\/\/ Reserve memory at an arbitrary address, only if that area is\n+\/\/ available (and not reserved for something else).\n+char* os::pd_attempt_reserve_memory_at(size_t bytes, char* addr) {\n@@ -3139,9 +3158,1 @@\n-\/\/ Reserve memory at an arbitrary address, only if that area is\n-\/\/ available (and not reserved for something else).\n-char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {\n-  \/\/ Windows os::reserve_memory() fails of the requested address range is\n-  \/\/ not avilable.\n-  return reserve_memory(bytes, requested_addr);\n-}\n-\n-char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {\n+char* os::pd_attempt_map_memory_to_file_at(size_t bytes, char* requested_addr, int file_desc) {\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":26,"deletions":15,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -825,1 +825,1 @@\n-  char* addr = reserve_memory(bytes, NULL);\n+  char* addr = reserve_memory(bytes);\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -267,1 +267,1 @@\n-  char* addr = reserve_memory(bytes, NULL);\n+  char* addr = reserve_memory(bytes);\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/os_bsd_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -699,1 +699,1 @@\n-  char* addr = reserve_memory(bytes, NULL);\n+  char* addr = reserve_memory(bytes);\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-  char* addr = reserve_memory(bytes, NULL);\n+  char* addr = reserve_memory(bytes);\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  char* addr = os::reserve_memory(size, NULL, alignment, flags);\n+  char* addr = os::reserve_memory(size, alignment, flags);\n@@ -81,1 +81,1 @@\n-  char* addr = os::reserve_memory(size, NULL, alignment, flags);\n+  char* addr = os::reserve_memory(size, alignment, flags);\n","filename":"src\/hotspot\/share\/memory\/allocation.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,0 +85,24 @@\n+\/\/ Helper method\n+static char* attempt_map_or_reserve_memory_at(size_t size, char* base, int fd) {\n+  if (fd != -1) {\n+    return os::attempt_map_memory_to_file_at(size, base, fd);\n+  }\n+  return os::attempt_reserve_memory_at(size, base);\n+}\n+\n+\/\/ Helper method\n+static char* map_or_reserve_memory(size_t size, int fd) {\n+  if (fd != -1) {\n+    return os::map_memory_to_file(size, fd);\n+  }\n+  return os::reserve_memory(size);\n+}\n+\n+\/\/ Helper method\n+static char* map_or_reserve_memory_aligned(size_t size, size_t alignment, int fd) {\n+  if (fd != -1) {\n+    return os::map_memory_to_file_aligned(size, alignment, fd);\n+  }\n+  return os::reserve_memory_aligned(size, alignment);\n+}\n+\n@@ -193,1 +217,1 @@\n-      base = os::attempt_reserve_memory_at(size, requested_address, _fd_for_heap);\n+      base = attempt_map_or_reserve_memory_at(size, requested_address, _fd_for_heap);\n@@ -199,1 +223,1 @@\n-      base = os::reserve_memory(size, NULL, alignment, _fd_for_heap);\n+      base = map_or_reserve_memory(size, _fd_for_heap);\n@@ -211,1 +235,1 @@\n-      base = os::reserve_memory_aligned(size, alignment, _fd_for_heap);\n+      base = map_or_reserve_memory_aligned(size, alignment, _fd_for_heap);\n@@ -391,1 +415,1 @@\n-      base = os::attempt_reserve_memory_at(size, requested_address, _fd_for_heap);\n+      base = attempt_map_or_reserve_memory_at(size, requested_address, _fd_for_heap);\n@@ -393,1 +417,1 @@\n-      base = os::reserve_memory(size, NULL, alignment, _fd_for_heap);\n+      base = map_or_reserve_memory(size, _fd_for_heap);\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":29,"deletions":5,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1324,1 +1324,1 @@\n-  p = os::reserve_memory(os::vm_allocation_granularity(), NULL, 0);\n+  p = os::reserve_memory(os::vm_allocation_granularity());\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1740,14 +1740,6 @@\n-char* os::reserve_memory(size_t bytes, char* addr, size_t alignment_hint, int file_desc) {\n-  char* result = NULL;\n-\n-  if (file_desc != -1) {\n-    \/\/ Could have called pd_reserve_memory() followed by replace_existing_mapping_with_file_mapping(),\n-    \/\/ but AIX may use SHM in which case its more trouble to detach the segment and remap memory to the file.\n-    result = os::map_memory_to_file(addr, bytes, file_desc);\n-    if (result != NULL) {\n-      MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC);\n-    }\n-  } else {\n-    result = pd_reserve_memory(bytes, addr, alignment_hint);\n-    if (result != NULL) {\n-      MemTracker::record_virtual_memory_reserve((address)result, bytes, CALLER_PC);\n+char* os::reserve_memory(size_t bytes, size_t alignment_hint, MEMFLAGS flags) {\n+  char* result = pd_reserve_memory(bytes, alignment_hint);\n+  if (result != NULL) {\n+    MemTracker::record_virtual_memory_reserve(result, bytes, CALLER_PC);\n+    if (flags != mtOther) {\n+      MemTracker::record_virtual_memory_type(result, flags);\n@@ -1760,3 +1752,3 @@\n-char* os::reserve_memory(size_t bytes, char* addr, size_t alignment_hint,\n-   MEMFLAGS flags) {\n-  char* result = pd_reserve_memory(bytes, addr, alignment_hint);\n+\n+char* os::attempt_reserve_memory_at(size_t bytes, char* addr) {\n+  char* result = pd_attempt_reserve_memory_at(bytes, addr);\n@@ -1765,18 +1757,0 @@\n-    MemTracker::record_virtual_memory_type((address)result, flags);\n-  }\n-\n-  return result;\n-}\n-\n-char* os::attempt_reserve_memory_at(size_t bytes, char* addr, int file_desc) {\n-  char* result = NULL;\n-  if (file_desc != -1) {\n-    result = pd_attempt_reserve_memory_at(bytes, addr, file_desc);\n-    if (result != NULL) {\n-      MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC);\n-    }\n-  } else {\n-    result = pd_attempt_reserve_memory_at(bytes, addr);\n-    if (result != NULL) {\n-      MemTracker::record_virtual_memory_reserve((address)result, bytes, CALLER_PC);\n-    }\n@@ -1855,0 +1829,19 @@\n+char* os::map_memory_to_file(size_t bytes, int file_desc) {\n+  \/\/ Could have called pd_reserve_memory() followed by replace_existing_mapping_with_file_mapping(),\n+  \/\/ but AIX may use SHM in which case its more trouble to detach the segment and remap memory to the file.\n+  \/\/ On all current implementations NULL is interpreted as any available address.\n+  char* result = os::map_memory_to_file(NULL \/* addr *\/, bytes, file_desc);\n+  if (result != NULL) {\n+    MemTracker::record_virtual_memory_reserve_and_commit(result, bytes, CALLER_PC);\n+  }\n+  return result;\n+}\n+\n+char* os::attempt_map_memory_to_file_at(size_t bytes, char* addr, int file_desc) {\n+  char* result = pd_attempt_map_memory_to_file_at(bytes, addr, file_desc);\n+  if (result != NULL) {\n+    MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC);\n+  }\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":28,"deletions":35,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -114,2 +114,2 @@\n-  static char*  pd_reserve_memory(size_t bytes, char* addr = 0,\n-                                  size_t alignment_hint = 0);\n+  static char*  pd_reserve_memory(size_t bytes, size_t alignment_hint);\n+\n@@ -117,1 +117,1 @@\n-  static char*  pd_attempt_reserve_memory_at(size_t bytes, char* addr, int file_desc);\n+\n@@ -133,0 +133,2 @@\n+  static char*  pd_attempt_map_memory_to_file_at(size_t bytes, char* addr, int file_desc);\n+\n@@ -328,6 +330,12 @@\n-  static char*  reserve_memory(size_t bytes, char* addr = 0,\n-                               size_t alignment_hint = 0, int file_desc = -1);\n-  static char*  reserve_memory(size_t bytes, char* addr,\n-                               size_t alignment_hint, MEMFLAGS flags);\n-  static char*  reserve_memory_aligned(size_t size, size_t alignment, int file_desc = -1);\n-  static char*  attempt_reserve_memory_at(size_t bytes, char* addr, int file_desc = -1);\n+\n+  \/\/ Reserves virtual memory.\n+  \/\/ alignment_hint - currently only used by AIX\n+  static char*  reserve_memory(size_t bytes, size_t alignment_hint = 0, MEMFLAGS flags = mtOther);\n+\n+  \/\/ Reserves virtual memory that starts at an address that is aligned to 'alignment'.\n+  static char*  reserve_memory_aligned(size_t size, size_t alignment);\n+\n+  \/\/ Attempts to reserve the virtual memory at [addr, addr + bytes).\n+  \/\/ Does not overwrite existing mappings.\n+  static char*  attempt_reserve_memory_at(size_t bytes, char* addr);\n+\n@@ -369,0 +377,2 @@\n+  static char* map_memory_to_file(size_t size, int fd);\n+  static char* map_memory_to_file_aligned(size_t size, size_t alignment, int fd);\n@@ -370,0 +380,1 @@\n+  static char* attempt_map_memory_to_file_at(size_t size, char* base, int fd);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-      char* polling_page = os::reserve_memory(allocation_size, NULL, page_size);\n+      char* polling_page = os::reserve_memory(allocation_size, page_size);\n@@ -76,1 +76,1 @@\n-    char* polling_page = os::reserve_memory(page_size, NULL, page_size);\n+    char* polling_page = os::reserve_memory(page_size, page_size);\n@@ -103,1 +103,1 @@\n-    char* serialize_page = os::reserve_memory(page_size, NULL, page_size);\n+    char* serialize_page = os::reserve_memory(page_size, page_size);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-    char* base = os::reserve_memory(size, NULL, page_sz, mtThreadStack);\n+    char* base = os::reserve_memory(size, page_sz, mtThreadStack);\n@@ -172,1 +172,1 @@\n-    char* base = os::reserve_memory(size, NULL, page_sz, mtTest);\n+    char* base = os::reserve_memory(size, page_sz, mtTest);\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}