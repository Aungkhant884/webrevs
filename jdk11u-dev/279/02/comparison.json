{"files":[{"patch":"@@ -412,0 +412,108 @@\n+class ArgumentPusher : public SignatureIterator {\n+ protected:\n+  JavaCallArguments*  _jca;\n+  jlong _argument;\n+  bool _pushed;\n+\n+  jlong next_arg() {\n+    guarantee(!_pushed, \"one argument\");\n+    _pushed = true;\n+    return _argument;\n+  }\n+\n+  float next_float() {\n+    guarantee(!_pushed, \"one argument\");\n+    _pushed = true;\n+    jvalue v;\n+    v.i = (jint) _argument;\n+    return v.f;\n+  }\n+\n+  double next_double() {\n+    guarantee(!_pushed, \"one argument\");\n+    _pushed = true;\n+    jvalue v;\n+    v.j = _argument;\n+    return v.d;\n+  }\n+\n+  Handle next_object() {\n+    guarantee(!_pushed, \"one argument\");\n+    _pushed = true;\n+    return Handle(Thread::current(), (oop) (address) _argument);\n+  }\n+\n+ public:\n+  ArgumentPusher(Symbol* signature, JavaCallArguments*  jca, jlong argument) : SignatureIterator(signature) {\n+    this->_return_type = T_ILLEGAL;\n+    _jca = jca;\n+    _argument = argument;\n+    _pushed = false;\n+    iterate();\n+  }\n+\n+  inline void do_object() { _jca->push_oop(next_object()); }\n+\n+  inline void do_bool()   { if (!is_return_type()) _jca->push_int((jboolean) next_arg()); }\n+  inline void do_char()   { if (!is_return_type()) _jca->push_int((jchar) next_arg()); }\n+  inline void do_short()  { if (!is_return_type()) _jca->push_int((jint)  next_arg()); }\n+  inline void do_byte()   { if (!is_return_type()) _jca->push_int((jbyte) next_arg()); }\n+  inline void do_int()    { if (!is_return_type()) _jca->push_int((jint)  next_arg()); }\n+\n+  inline void do_long()   { if (!is_return_type()) _jca->push_long((jlong) next_arg()); }\n+  inline void do_float()  { if (!is_return_type()) _jca->push_float(next_float()); }\n+  inline void do_double() { if (!is_return_type()) _jca->push_double(next_double()); }\n+\n+  inline void do_object(int begin, int end) { if (!is_return_type()) do_object(); }\n+  inline void do_array(int begin, int end)  { if (!is_return_type()) do_object(); }\n+\n+  inline void do_void() { }\n+};\n+\n+\n+JRT_ENTRY(jlong, JVMCIRuntime::invoke_static_method_one_arg(JavaThread* thread, Method* method, jlong argument))\n+  ResourceMark rm;\n+  HandleMark hm;\n+\n+  methodHandle mh(thread, method);\n+  if (mh->size_of_parameters() > 1 && !mh->is_static()) {\n+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"Invoked method must be static and take at most one argument\");\n+  }\n+\n+  Symbol* signature = mh->signature();\n+  JavaCallArguments jca(mh->size_of_parameters());\n+  ArgumentPusher jap(signature, &jca, argument);\n+  BasicType return_type = jap.get_ret_type();\n+  JavaValue result(return_type);\n+  JavaCalls::call(&result, mh, &jca, CHECK_0);\n+\n+  if (return_type == T_VOID) {\n+    return 0;\n+  } else if (return_type == T_OBJECT || return_type == T_ARRAY) {\n+    thread->set_vm_result((oop) result.get_jobject());\n+    return 0;\n+  } else {\n+    jvalue *value = (jvalue *) result.get_value_addr();\n+    \/\/ Narrow the value down if required (Important on big endian machines)\n+    switch (return_type) {\n+      case T_BOOLEAN:\n+        return (jboolean) value->i;\n+      case T_BYTE:\n+        return (jbyte) value->i;\n+      case T_CHAR:\n+        return (jchar) value->i;\n+      case T_SHORT:\n+        return (jshort) value->i;\n+      case T_INT:\n+      case T_FLOAT:\n+        return value->i;\n+      case T_LONG:\n+      case T_DOUBLE:\n+        return value->j;\n+      default:\n+        fatal(\"Unexpected type %s\", type2name(return_type));\n+        return 0;\n+    }\n+  }\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":108,"deletions":0,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -163,0 +163,5 @@\n+  \/\/ A helper to allow invocation of an arbitrary Java method.  For simplicity the method is\n+  \/\/ restricted to a static method that takes at most one argument.  For calling convention\n+  \/\/ simplicty all types are passed by being converted into a jlong\n+  static jlong invoke_static_method_one_arg(JavaThread* thread, Method* method, jlong argument);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -635,0 +635,2 @@\n+  declare_function(JVMCIRuntime::invoke_static_method_one_arg) \\\n+  \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}