{"files":[{"patch":"@@ -349,2 +349,5 @@\n-  Node *test = loop->tail();\n-  int body_size = loop->_body.size();\n+\n+  \/\/ If nodes are depleted, some transform has miscalculated its needs.\n+  assert(!phase->exceeding_node_budget(), \"sanity\");\n+\n+  uint body_size = loop->_body.size();\n@@ -352,3 +355,6 @@\n-  if (body_size > 255 \/* Prevent overflow for large body_size *\/\n-      || (body_size * body_size + phase->C->live_nodes()) > phase->C->max_node_limit()) {\n-    return false;           \/\/ too large to safely clone\n+  if (body_size > 255) {\n+    return false;   \/\/ Prevent overflow for large body size\n+  }\n+  uint estimate = body_size * body_size;\n+  if (phase->exceeding_node_budget(estimate)) {\n+    return false;   \/\/ Too large to safely clone\n@@ -365,0 +371,2 @@\n+  Node* test = loop->tail();\n+\n@@ -378,1 +386,2 @@\n-        return true;            \/\/ Found reason to peel!\n+        \/\/ Found reason to peel!\n+        return phase->may_require_nodes(estimate);\n@@ -676,0 +685,3 @@\n+  \/\/ If nodes are depleted, some transform has miscalculated its needs.\n+  assert(!phase->exceeding_node_budget(), \"sanity\");\n+\n@@ -686,6 +698,0 @@\n-  \/\/ Fully unroll a loop with few iterations regardless next\n-  \/\/ conditions since following loop optimizations will split\n-  \/\/ such loop anyway (pre-main-post).\n-  if (trip_count <= 3)\n-    return true;\n-\n@@ -694,3 +700,3 @@\n-  uint new_body_size = EMPTY_LOOP_SIZE + (body_size - EMPTY_LOOP_SIZE) * trip_count;\n-  uint tst_body_size = (new_body_size - EMPTY_LOOP_SIZE) \/ trip_count + EMPTY_LOOP_SIZE;\n-  if (body_size != tst_body_size) \/\/ Check for int overflow\n+  uint new_body_size = est_loop_clone_sz(trip_count, body_size - EMPTY_LOOP_SIZE);\n+\n+  if (new_body_size == UINT_MAX) { \/\/ Check for bad estimate (overflow).\n@@ -698,0 +704,8 @@\n+  }\n+\n+  \/\/ Fully unroll a loop with few iterations regardless next conditions since\n+  \/\/ following loop optimizations will split such loop anyway (pre-main-post).\n+  if (trip_count <= 3) {\n+    return phase->may_require_nodes(new_body_size);\n+  }\n+\n@@ -700,1 +714,1 @@\n-      new_body_size >= phase->C->max_node_limit() - phase->C->live_nodes()) {\n+      phase->exceeding_node_budget(new_body_size)) {\n@@ -730,1 +744,1 @@\n-  return true; \/\/ Do maximally unroll\n+  return phase->may_require_nodes(new_body_size);\n@@ -735,2 +749,2 @@\n-\/\/ Return TRUE or FALSE if the loop should be unrolled or not.  Unroll if\n-\/\/ the loop is a CountedLoop and the body is small enough.\n+\/\/ Return TRUE or FALSE if the loop should be unrolled or not.  Unroll if the\n+\/\/ loop is a CountedLoop and the body is small enough.\n@@ -742,1 +756,1 @@\n-  if (!cl->is_valid_counted_loop())\n+  if (!cl->is_valid_counted_loop()) {\n@@ -744,0 +758,4 @@\n+  }\n+\n+  \/\/ If nodes are depleted, some transform has miscalculated its needs.\n+  assert(!phase->exceeding_node_budget(), \"sanity\");\n@@ -747,3 +765,4 @@\n-  if (cl->trip_count() <= (uint)(cl->is_normal_loop() ? 2 : 1)) return false;\n-\n-  _local_loop_unroll_limit = LoopUnrollLimit;\n+  if (cl->trip_count() <= (cl->is_normal_loop() ? 2u : 1u)) {\n+    return false;\n+  }\n+  _local_loop_unroll_limit  = LoopUnrollLimit;\n@@ -874,0 +893,3 @@\n+\n+  uint estimate = est_loop_clone_sz(2, body_size);\n+\n@@ -875,3 +897,4 @@\n-    if (slp_max_unroll_factor >= future_unroll_cnt) return true;\n-    \/\/ Normal case: loop too big\n-    return false;\n+    if (slp_max_unroll_factor >= future_unroll_cnt) {\n+      return phase->may_require_nodes(estimate);\n+    }\n+    return false; \/\/ Loop too big.\n@@ -882,2 +905,2 @@\n-    if ((cl->is_subword_loop() || xors_in_loop >= 4) && body_size < (uint)LoopUnrollLimit * 4) {\n-      return true;\n+    if ((cl->is_subword_loop() || xors_in_loop >= 4) && body_size < 4u * LoopUnrollLimit) {\n+      return phase->may_require_nodes(estimate);\n@@ -885,2 +908,1 @@\n-    \/\/ Normal case: loop too big\n-    return false;\n+    return false; \/\/ Loop too big.\n@@ -891,1 +913,2 @@\n-      tty->print_cr(\"policy_unroll passed vector loop(vlen=%d,factor = %d)\\n\", slp_max_unroll_factor, future_unroll_cnt);\n+      tty->print_cr(\"policy_unroll passed vector loop(vlen=%d, factor=%d)\\n\",\n+                    slp_max_unroll_factor, future_unroll_cnt);\n@@ -896,1 +919,1 @@\n-  return true;\n+  return phase->may_require_nodes(estimate);\n@@ -900,0 +923,4 @@\n+\n+  \/\/ If nodes are depleted, some transform has miscalculated its needs.\n+  assert(!phase->exceeding_node_budget(), \"sanity\");\n+\n@@ -943,0 +970,3 @@\n+  \/\/ If nodes are depleted, some transform has miscalculated its needs.\n+  assert(!phase->exceeding_node_budget(), \"sanity\");\n+\n@@ -993,3 +1023,3 @@\n-      \/\/ Yeah!  Found a test like 'trip+off vs limit'\n-      \/\/ Test is an IfNode, has 2 projections.  If BOTH are in the loop\n-      \/\/ we need loop unswitching instead of iteration splitting.\n+      \/\/ Found a test like 'trip+off vs  limit'.  Test is an IfNode, has two\n+      \/\/ (2) projections.  If BOTH are in  the loop we need loop unswitching\n+      \/\/ instead of iteration splitting.\n@@ -997,1 +1027,3 @@\n-        return true;            \/\/ Found reason to split iterations\n+        \/\/ Found valid reason to split iterations (if there is room).\n+        \/\/ NOTE: Usually a gross overestimate.\n+        return phase->may_require_nodes(est_loop_clone_sz(2, _body.size()));\n@@ -1009,0 +1041,4 @@\n+\n+  \/\/ If nodes are depleted, some transform has miscalculated its needs.\n+  assert(!phase->exceeding_node_budget(), \"sanity\");\n+\n@@ -1576,0 +1612,3 @@\n+  if (!may_require_nodes(est_loop_clone_sz(2, loop->_body.size()))) {\n+    return;\n+  }\n@@ -1917,1 +1956,2 @@\n-        stride_con < 0 && ((limit_type->_lo - stride_con) > limit_type->_lo), \"sanity\");\n+           stride_con < 0 && ((limit_type->_lo - stride_con) > limit_type->_lo),\n+           \"sanity\");\n@@ -1986,0 +2026,1 @@\n+\n@@ -2097,1 +2138,0 @@\n-\n@@ -3219,1 +3259,0 @@\n-  bool should_peel = policy_peeling(phase); \/\/ Should we peel?\n@@ -3221,0 +3260,3 @@\n+  AutoNodeBudget node_budget(phase);\n+\n+  bool should_peel     = policy_peeling(phase);\n@@ -3256,1 +3298,1 @@\n-    bool should_maximally_unroll =  policy_maximally_unroll(phase);\n+    bool should_maximally_unroll = policy_maximally_unroll(phase);\n@@ -3260,1 +3302,1 @@\n-      phase->do_maximally_unroll(this,old_new);\n+      phase->do_maximally_unroll(this, old_new);\n@@ -3265,7 +3307,0 @@\n-  \/\/ Skip next optimizations if running low on nodes. Note that\n-  \/\/ policy_unswitching and policy_maximally_unroll have this check.\n-  int nodes_left = phase->C->max_node_limit() - phase->C->live_nodes();\n-  if ((int)(2 * _body.size()) > nodes_left) {\n-    return true;\n-  }\n-\n@@ -3285,0 +3320,3 @@\n+  bool should_rce    = policy_range_check(phase);\n+  \/\/ TODO: Remove align -- not used.\n+  bool should_align  = policy_align(phase);\n@@ -3286,7 +3324,3 @@\n-  bool should_rce = policy_range_check(phase);\n-\n-  bool should_align = policy_align(phase);\n-\n-  \/\/ If not RCE'ing (iteration splitting) or Aligning, then we do not\n-  \/\/ need a pre-loop.  We may still need to peel an initial iteration but\n-  \/\/ we will not be needing an unknown number of pre-iterations.\n+  \/\/ If not RCE'ing  (iteration splitting) or Aligning, then we  do not need a\n+  \/\/ pre-loop.  We may still need to peel an initial iteration but we will not\n+  \/\/ be needing an unknown number of pre-iterations.\n@@ -3294,2 +3328,2 @@\n-  \/\/ Basically, if may_rce_align reports FALSE first time through,\n-  \/\/ we will not be able to later do RCE or Aligning on this loop.\n+  \/\/ Basically, if may_rce_align reports FALSE first time through, we will not\n+  \/\/ be able to later do RCE or Aligning on this loop.\n@@ -3302,1 +3336,4 @@\n-    if (cl->is_normal_loop())  \/\/ Convert to 'pre\/main\/post' loops\n+    if (cl->is_normal_loop()) { \/\/ Convert to 'pre\/main\/post' loops\n+      if (!phase->may_require_nodes(est_loop_clone_sz(3, _body.size()))) {\n+        return false;\n+      }\n@@ -3304,1 +3341,1 @@\n-\n+    }\n@@ -3371,3 +3408,6 @@\n-    } else if (policy_unswitching(phase)) {\n-      phase->do_unswitching(this, old_new);\n-      return false; \/\/ need to recalculate idom data\n+    } else {\n+      AutoNodeBudget node_budget(phase);\n+      if (policy_unswitching(phase)) {\n+        phase->do_unswitching(this, old_new);\n+        return false; \/\/ need to recalculate idom data\n+      }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":102,"deletions":62,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  if( !LoopUnswitching ) {\n+  if (!LoopUnswitching) {\n@@ -65,0 +65,3 @@\n+  \/\/ If nodes are depleted, some transform has miscalculated its needs.\n+  assert(!phase->exceeding_node_budget(), \"sanity\");\n+\n@@ -70,4 +73,0 @@\n-  int nodes_left = phase->C->max_node_limit() - phase->C->live_nodes();\n-  if ((int)(2 * _body.size()) > nodes_left) {\n-    return false; \/\/ Too speculative if running low on nodes.\n-  }\n@@ -78,1 +77,6 @@\n-  return phase->find_unswitching_candidate(this) != NULL;\n+  if (phase->find_unswitching_candidate(this) == NULL) {\n+    return false;\n+  }\n+\n+  \/\/ Too speculative if running low on nodes.\n+  return phase->may_require_nodes(est_loop_clone_sz(3, _body.size()));\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3005,0 +3005,1 @@\n+    AutoNodeBudget node_budget(this, AutoNodeBudget::NO_BUDGET_CHECK);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -484,3 +484,3 @@\n-  \/\/ If tail is NULL then this loop has multiple backedges as part of the\n-  \/\/ same loop.  During cleanup I'll peel off the multiple backedges; merge\n-  \/\/ them at the loop bottom and flow 1 real backedge into the loop.\n+  \/\/ If a loop has multiple backedges, this is addressed during cleanup where\n+  \/\/ we peel off the multiple backedges,  merging all edges at the bottom and\n+  \/\/ ensuring that one proper backedge flow into the loop.\n@@ -516,1 +516,4 @@\n-  { }\n+  {\n+    precond(_head != NULL);\n+    precond(_tail != NULL);\n+  }\n@@ -667,0 +670,1 @@\n+  friend class AutoNodeBudget;\n@@ -964,0 +968,1 @@\n+    _nodes_required(UINT_MAX),\n@@ -984,0 +989,1 @@\n+    _nodes_required(UINT_MAX),\n@@ -994,0 +1000,1 @@\n+    _nodes_required(UINT_MAX),\n@@ -1343,0 +1350,43 @@\n+  \/\/ A simplistic node request tracking mechanism, where\n+  \/\/   = UINT_MAX   Request not valid or made final.\n+  \/\/   < UINT_MAX   Nodes currently requested (estimate).\n+  uint _nodes_required;\n+\n+  bool exceeding_node_budget(uint required = 0) {\n+    assert(C->live_nodes() < C->max_node_limit(), \"sanity\");\n+    uint available = C->max_node_limit() - C->live_nodes();\n+    return available < required + _nodes_required;\n+  }\n+\n+  uint require_nodes(uint require) {\n+    precond(require > 0);\n+    _nodes_required += MAX2(100u, require); \/\/ Keep requests at minimum 100.\n+    return _nodes_required;\n+  }\n+\n+  bool may_require_nodes(uint require) {\n+    return !exceeding_node_budget(require) && require_nodes(require) > 0;\n+  }\n+\n+  void require_nodes_begin() {\n+    assert(_nodes_required == UINT_MAX, \"Bad state (begin).\");\n+    _nodes_required = 0;\n+  }\n+\n+  \/\/ Final check  that the requested nodes  did not exceed the  limit and that\n+  \/\/ the request  was reasonably  correct with  respect to  the number  of new\n+  \/\/ nodes introduced by any transform since the last 'begin'.\n+  void require_nodes_final_check(uint live_at_begin) {\n+    uint required = _nodes_required;\n+    require_nodes_final();\n+    uint delta = C->live_nodes() - live_at_begin;\n+    assert(delta <= 2 * required, \"Bad node estimate (actual: %d, request: %d)\",\n+           delta, required);\n+  }\n+\n+  void require_nodes_final() {\n+    assert(_nodes_required < UINT_MAX, \"Bad state (final).\");\n+    assert(!exceeding_node_budget(), \"Too many NODES required!\");\n+    _nodes_required = UINT_MAX;\n+  }\n+\n@@ -1350,0 +1400,2 @@\n+  uint nodes_required() const { return _nodes_required; }\n+\n@@ -1381,0 +1433,56 @@\n+\n+class AutoNodeBudget : public StackObj\n+{\n+public:\n+  enum budget_check_t { BUDGET_CHECK, NO_BUDGET_CHECK };\n+\n+  AutoNodeBudget(PhaseIdealLoop* phase, budget_check_t chk = BUDGET_CHECK)\n+    : _phase(phase),\n+      _check_at_final(chk == BUDGET_CHECK),\n+      _nodes_at_begin(0)\n+  {\n+    precond(_phase != NULL);\n+\n+    _nodes_at_begin = _phase->C->live_nodes();\n+    _phase->require_nodes_begin();\n+  }\n+\n+  ~AutoNodeBudget() {\n+    if (_check_at_final) {\n+#ifndef PRODUCT\n+      if (TraceLoopOpts) {\n+        uint request = _phase->nodes_required();\n+\n+        if (request > 0) {\n+          uint delta = _phase->C->live_nodes() - _nodes_at_begin;\n+\n+          if (request < delta) {\n+            tty->print_cr(\"Exceeding node budget: %d < %d\", request, delta);\n+          }\n+        }\n+      }\n+#endif\n+      _phase->require_nodes_final_check(_nodes_at_begin);\n+    } else {\n+      _phase->require_nodes_final();\n+    }\n+  }\n+\n+private:\n+  PhaseIdealLoop* _phase;\n+  bool _check_at_final;\n+  uint _nodes_at_begin;\n+};\n+\n+\/\/ The Estimated Loop Clone Size: CloneFactor * (BodySize + BC) + CC, where BC\n+\/\/ and CC are totally ad-hoc\/magic \"body\" and \"clone\" constants, respectively,\n+\/\/ used to ensure that node usage estimates made are on the safe side, for the\n+\/\/ most part.\n+static inline uint est_loop_clone_sz(uint fact, uint size) {\n+  uint const bc = 31;\n+  uint const cc = 41;\n+  uint estimate = fact * (size + bc) + cc;\n+  return (estimate - cc) \/ fact == size + bc ? estimate : UINT_MAX;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":112,"deletions":4,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2718,1 +2718,1 @@\n-#if !defined(PRODUCT)\n+#ifndef PRODUCT\n@@ -2756,1 +2756,1 @@\n-#if !defined(PRODUCT)\n+#ifndef PRODUCT\n@@ -3102,1 +3102,1 @@\n-#if !defined(PRODUCT)\n+#ifndef PRODUCT\n@@ -3158,1 +3158,1 @@\n-#if !defined(PRODUCT)\n+#ifndef PRODUCT\n@@ -3187,0 +3187,4 @@\n+  if (!may_require_nodes(est_loop_clone_sz(2, loop->_body.size()))) {\n+    return false;\n+  }\n+\n@@ -3235,1 +3239,1 @@\n-#if !defined(PRODUCT)\n+#ifndef PRODUCT\n@@ -3246,1 +3250,1 @@\n-#if !defined(PRODUCT)\n+#ifndef PRODUCT\n@@ -3268,1 +3272,1 @@\n-#if !defined(PRODUCT)\n+#ifndef PRODUCT\n@@ -3287,1 +3291,1 @@\n-#if !defined(PRODUCT)\n+#ifndef PRODUCT\n@@ -3445,1 +3449,1 @@\n-#if !defined(PRODUCT)\n+#ifndef PRODUCT\n@@ -3485,4 +3489,4 @@\n-  \/\/ Check for the special case of folks using the pre-incremented\n-  \/\/ trip-counter on the fall-out path (forces the pre-incremented\n-  \/\/ and post-incremented trip counter to be live at the same time).\n-  \/\/ Fix this by adjusting to use the post-increment trip counter.\n+  \/\/ Check for the special case when using the pre-incremented trip-counter on\n+  \/\/ the fall-out  path (forces the pre-incremented  and post-incremented trip\n+  \/\/ counter to be live  at the same time).  Fix this by  adjusting to use the\n+  \/\/ post-increment trip counter.\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"}]}