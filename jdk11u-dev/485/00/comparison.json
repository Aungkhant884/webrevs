{"files":[{"patch":"@@ -2327,42 +2327,1 @@\n-              Node* head = in->in(0);\n-              assert(head->is_Region(), \"unexpected infinite loop graph shape\");\n-\n-              Node* phi_mem = NULL;\n-              for (DUIterator_Fast jmax, j = head->fast_outs(jmax); j < jmax; j++) {\n-                Node* u = head->fast_out(j);\n-                if (u->is_Phi() && u->bottom_type() == Type::MEMORY) {\n-                  if (_phase->C->get_alias_index(u->adr_type()) == _alias) {\n-                    assert(phi_mem == NULL || phi_mem->adr_type() == TypePtr::BOTTOM, \"\");\n-                    phi_mem = u;\n-                  } else if (u->adr_type() == TypePtr::BOTTOM) {\n-                    assert(phi_mem == NULL || _phase->C->get_alias_index(phi_mem->adr_type()) == _alias, \"\");\n-                    if (phi_mem == NULL) {\n-                      phi_mem = u;\n-                    }\n-                  }\n-                }\n-              }\n-              if (phi_mem == NULL) {\n-                for (uint j = 1; j < head->req(); j++) {\n-                  Node* tail = head->in(j);\n-                  if (!_phase->is_dominator(head, tail)) {\n-                    continue;\n-                  }\n-                  Node* c = tail;\n-                  while (c != head) {\n-                    if (c->is_SafePoint() && !c->is_CallLeaf()) {\n-                      Node* m =c->in(TypeFunc::Memory);\n-                      if (m->is_MergeMem()) {\n-                        m = m->as_MergeMem()->memory_at(_alias);\n-                      }\n-                      assert(mem == NULL || mem == m, \"several memory states\");\n-                      mem = m;\n-                    }\n-                    c = _phase->idom(c);\n-                  }\n-                  assert(mem != NULL, \"should have found safepoint\");\n-                }\n-                assert(mem != NULL, \"should have found safepoint\");\n-              } else {\n-                mem = phi_mem;\n-              }\n+              mem = collect_memory_for_infinite_loop(in);\n@@ -2586,0 +2545,61 @@\n+Node* MemoryGraphFixer::collect_memory_for_infinite_loop(const Node* in) {\n+  Node* mem = NULL;\n+  Node* head = in->in(0);\n+  assert(head->is_Region(), \"unexpected infinite loop graph shape\");\n+\n+  Node* phi_mem = NULL;\n+  for (DUIterator_Fast jmax, j = head->fast_outs(jmax); j < jmax; j++) {\n+    Node* u = head->fast_out(j);\n+    if (u->is_Phi() && u->bottom_type() == Type::MEMORY) {\n+      if (_phase->C->get_alias_index(u->adr_type()) == _alias) {\n+        assert(phi_mem == NULL || phi_mem->adr_type() == TypePtr::BOTTOM, \"\");\n+        phi_mem = u;\n+      } else if (u->adr_type() == TypePtr::BOTTOM) {\n+        assert(phi_mem == NULL || _phase->C->get_alias_index(phi_mem->adr_type()) == _alias, \"\");\n+        if (phi_mem == NULL) {\n+          phi_mem = u;\n+        }\n+      }\n+    }\n+  }\n+  if (phi_mem == NULL) {\n+    ResourceMark rm;\n+    Node_Stack stack(0);\n+    stack.push(head, 1);\n+    do {\n+      Node* n = stack.node();\n+      uint i = stack.index();\n+      if (i >= n->req()) {\n+        stack.pop();\n+      } else {\n+        stack.set_index(i + 1);\n+        Node* c = n->in(i);\n+        assert(c != head, \"should have found a safepoint on the way\");\n+        if (stack.size() != 1 || _phase->is_dominator(head, c)) {\n+          for (;;) {\n+            if (c->is_Region()) {\n+              stack.push(c, 1);\n+              break;\n+            } else if (c->is_SafePoint() && !c->is_CallLeaf()) {\n+              Node* m = c->in(TypeFunc::Memory);\n+              if (m->is_MergeMem()) {\n+                m = m->as_MergeMem()->memory_at(_alias);\n+              }\n+              assert(mem == NULL || mem == m, \"several memory states\");\n+              mem = m;\n+              break;\n+            } else {\n+              assert(c != c->in(0), \"\");\n+              c = c->in(0);\n+            }\n+          }\n+        }\n+      }\n+    } while (stack.size() > 0);\n+    assert(mem != NULL, \"should have found safepoint\");\n+  } else {\n+    mem = phi_mem;\n+  }\n+  return mem;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":62,"deletions":42,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -134,0 +134,2 @@\n+\n+  Node* collect_memory_for_infinite_loop(const Node* in);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2404,1 +2404,1 @@\n-  if (can_reshape && !in(0)->is_Loop()) {\n+  if (can_reshape && !in(0)->is_Region()) {\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8271340\n+ * @summary Crash PhaseIdealLoop::clone_outer_loop\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm TestInfiniteLoopCCP\n+ *\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+\n+public class TestInfiniteLoopCCP {\n+\n+    public boolean m3 (long a_lo0, short a_sh1){\n+        long loa6[][] = new long[560][1792];\n+\n+        loa6[-128][0] = 1345348328L;\n+\n+        return false;\n+    }\n+\n+    public void mainTest (String[] args){\n+        short sh16 = (short)-32;\n+        for (int i17 = 0; i17 < 29; i17++) {\n+            if (i17 == 8) {\n+                i17 = 129;\n+                for (int i18 = 0; i18 < 27; i18++) {\n+                    i18 = 16;\n+                }\n+            }\n+        }\n+\n+        try {\n+            m3(4130511410L, (short)(sh16 % sh16));\n+        } catch (ArithmeticException a_e) {}\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception{\n+        Thread thread = new Thread() {\n+                public void run() {\n+                    TestInfiniteLoopCCP instance = new TestInfiniteLoopCCP();\n+                    for (int i = 0; i < 100; ++i) {\n+                        instance.mainTest(args);\n+                    }\n+                }\n+            };\n+        \/\/ Give thread some time to trigger compilation\n+        thread.setDaemon(true);\n+        thread.start();\n+        Thread.sleep(Utils.adjustTimeout(4000));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestInfiniteLoopCCP.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"}]}