{"files":[{"patch":"@@ -1304,2 +1304,1 @@\n-                           bool participants_hide_witnesses);\n-  bool witnessed_reabstraction_in_supers(Klass* k);\n+                         bool participants_hide_witnesses);\n@@ -1307,0 +1306,1 @@\n+  bool witnessed_reabstraction_in_supers(Klass* k);\n@@ -1417,9 +1417,2 @@\n-  if (is_witness(new_type)) {\n-    if (!ignore_witness(new_type)) {\n-      return new_type;\n-    }\n-  } else if (!doing_subtype_search()) {\n-    \/\/ No witness found, but is_witness() doesn't detect method re-abstraction in case of spot-checking.\n-    if (witnessed_reabstraction_in_supers(new_type)) {\n-      return new_type;\n-    }\n+  if (is_witness(new_type) && !ignore_witness(new_type)) {\n+    return new_type;\n@@ -1807,0 +1800,35 @@\n+\n+\/\/ Try to determine whether root method in some context is concrete or not based on the information about the unique method\n+\/\/ in that context. It exploits the fact that concrete root method is always inherited into the context when there's a unique method.\n+\/\/ Hence, unique method holder is always a supertype of the context class when root method is concrete.\n+\/\/ Examples for concrete_root_method\n+\/\/      C (C.m uniqm)\n+\/\/      |\n+\/\/      CX (ctxk) uniqm is inherited into context.\n+\/\/\n+\/\/      CX (ctxk) (CX.m uniqm) here uniqm is defined in ctxk.\n+\/\/ Examples for !concrete_root_method\n+\/\/      CX (ctxk)\n+\/\/      |\n+\/\/      C (C.m uniqm) uniqm is in subtype of ctxk.\n+bool Dependencies::is_concrete_root_method(Method* uniqm, Klass* ctxk) {\n+  if (uniqm == NULL) {\n+    return false; \/\/ match Dependencies::is_concrete_method() behavior\n+  }\n+  \/\/ Theoretically, the \"direction\" of subtype check matters here.\n+  \/\/ On one hand, in case of interface context with a single implementor, uniqm can be in a superclass of the implementor which\n+  \/\/ is not related to context class.\n+  \/\/ On another hand, uniqm could come from an interface unrelated to the context class, but right now it is not possible:\n+  \/\/ it is required that uniqm->method_holder() is the participant (uniqm->method_holder() <: ctxk), hence a default method\n+  \/\/ can't be used as unique.\n+  if (ctxk->is_interface()) {\n+    Klass* implementor = InstanceKlass::cast(ctxk)->implementor();\n+    assert(implementor != ctxk, \"single implementor only\"); \/\/ should have been invalidated earlier\n+    ctxk = implementor;\n+  }\n+  InstanceKlass* holder = uniqm->method_holder();\n+  assert(!holder->is_interface(), \"no default methods allowed\");\n+  assert(ctxk->is_subclass_of(holder) || holder->is_subclass_of(ctxk), \"not related\");\n+  return ctxk->is_subclass_of(holder);\n+}\n+\n@@ -1809,6 +1837,3 @@\n-Klass* Dependencies::check_unique_concrete_method(Klass* ctxk, Method* uniqm,\n-                                                    KlassDepChange* changes) {\n-  \/\/ Here is a missing optimization:  If uniqm->is_final(),\n-  \/\/ we don't really need to search beneath it for overrides.\n-  \/\/ This is probably not important, since we don't use dependencies\n-  \/\/ to track final methods.  (They can't be \"definalized\".)\n+Klass* Dependencies::check_unique_concrete_method(Klass* ctxk,\n+                                                  Method* uniqm,\n+                                                  KlassDepChange* changes) {\n@@ -1816,1 +1841,12 @@\n-  return wf.find_witness_definer(ctxk, changes);\n+  Klass* witness = wf.find_witness_definer(ctxk, changes);\n+  if (witness != NULL) {\n+    return witness;\n+  }\n+  if (!Dependencies::is_concrete_root_method(uniqm, ctxk) || changes != NULL) {\n+    Klass* conck = find_witness_AME(ctxk, uniqm, changes);\n+    if (conck != NULL) {\n+      \/\/ Found a concrete subtype 'conck' which does not override abstract root method.\n+      return conck;\n+    }\n+  }\n+  return NULL;\n@@ -1819,0 +1855,30 @@\n+\/\/ Search for AME.\n+\/\/ There are two version of checks.\n+\/\/   1) Spot checking version(Classload time). Newly added class is checked for AME.\n+\/\/      Checks whether abstract\/overpass method is inherited into\/declared in newly added concrete class.\n+\/\/   2) Compile time analysis for abstract\/overpass(abstract klass) root_m. The non uniqm subtrees are checked for concrete classes.\n+Klass* Dependencies::find_witness_AME(Klass* ctxk, Method* m, KlassDepChange* changes) {\n+  if (m != NULL) {\n+    if (changes != NULL) {\n+      \/\/ Spot checking version.\n+      ClassHierarchyWalker wf(m);\n+      Klass* new_type = changes->new_type();\n+      if (wf.witnessed_reabstraction_in_supers(new_type)) {\n+        return new_type;\n+      }\n+    } else {\n+      \/\/ Note: It is required that uniqm->method_holder() is the participant (see ClassHierarchyWalker::found_method()).\n+      ClassHierarchyWalker wf(m->method_holder());\n+      Klass* conck = wf.find_witness_subtype(ctxk);\n+      if (conck != NULL) {\n+        Method* cm = InstanceKlass::cast(conck)->find_instance_method(m->name(), m->signature(), Klass::skip_private);\n+        if (!Dependencies::is_concrete_method(cm, conck)) {\n+          return conck;\n+        }\n+      }\n+    }\n+  }\n+  return NULL;\n+}\n+\n+\n@@ -1843,0 +1909,3 @@\n+  } else if (Dependencies::find_witness_AME(ctxk, fm) != NULL) {\n+    \/\/ Found a concrete subtype which does not override abstract root method.\n+    return NULL;\n@@ -1844,0 +1913,1 @@\n+  assert(Dependencies::is_concrete_root_method(fm, ctxk) == Dependencies::is_concrete_method(m, ctxk), \"mismatch\");\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":88,"deletions":18,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -370,3 +370,0 @@\n-  if (method->is_abstract()) {\n-    return NULL;\n-  }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}