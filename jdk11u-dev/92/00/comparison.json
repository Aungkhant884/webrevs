{"files":[{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8184328 8253368\n+ * @bug 8184328 8253368 8260923\n@@ -28,2 +28,6 @@\n- * @run main\/othervm SSLSocketCloseHang\n- * @run main\/othervm SSLSocketCloseHang shutdownInputTest\n+ * @run main\/othervm SSLSocketCloseHang TLSv1.2\n+ * @run main\/othervm SSLSocketCloseHang TLSv1.2 shutdownInput\n+ * @run main\/othervm SSLSocketCloseHang TLSv1.2 shutdownOutput\n+ * @run main\/othervm SSLSocketCloseHang TLSv1.3\n+ * @run main\/othervm SSLSocketCloseHang TLSv1.3 shutdownInput\n+ * @run main\/othervm SSLSocketCloseHang TLSv1.3 shutdownOutput\n@@ -32,0 +36,1 @@\n+\n@@ -39,1 +44,0 @@\n-\n@@ -76,1 +80,1 @@\n-    static boolean shutdownInputTest = false;\n+    static String socketCloseType;\n@@ -151,13 +155,1 @@\n-        if (shutdownInputTest) {\n-            try {\n-                sslSocket.shutdownInput();\n-            } catch (SSLException e) {\n-                if (!e.getMessage().contains\n-                        (\"closing inbound before receiving peer's close_notify\")) {\n-                    throw new RuntimeException(\"expected different exception message. \" +\n-                        e.getMessage());\n-                }\n-            }\n-            if (!sslSocket.getSession().isValid()) {\n-                throw new RuntimeException(\"expected session to remain valid\");\n-            }\n+        closeConnection(sslSocket);\n@@ -165,0 +157,19 @@\n+        clientClosed = true;\n+        System.err.println(\"Client closed: \" + System.nanoTime());\n+    }\n+\n+    private void closeConnection(SSLSocket sslSocket) throws IOException {\n+        if (\"shutdownInput\".equals(socketCloseType)) {\n+            shutdownInput(sslSocket);\n+            \/\/ second call to shutdownInput() should just return,\n+            \/\/ shouldn't throw any exception\n+            sslSocket.shutdownInput();\n+            \/\/ invoking shutdownOutput() just after shutdownInput()\n+            sslSocket.shutdownOutput();\n+        } else if (\"shutdownOutput\".equals(socketCloseType)) {\n+            sslSocket.shutdownOutput();\n+            \/\/ second call to shutdownInput() should just return,\n+            \/\/ shouldn't throw any exception\n+            sslSocket.shutdownOutput();\n+            \/\/ invoking shutdownInput() just after shutdownOutput()\n+            shutdownInput(sslSocket);\n@@ -168,0 +179,1 @@\n+    }\n@@ -169,4 +181,13 @@\n-\n-\n-        clientClosed = true;\n-        System.err.println(\"Client closed: \" + System.nanoTime());\n+    private void shutdownInput(SSLSocket sslSocket) throws IOException {\n+        try {\n+            sslSocket.shutdownInput();\n+        } catch (SSLException e) {\n+            if (!e.getMessage().contains\n+                    (\"closing inbound before receiving peer's close_notify\")) {\n+                throw new RuntimeException(\"expected different exception \"\n+                        + \"message. \" + e.getMessage());\n+            }\n+        }\n+        if (!sslSocket.getSession().isValid()) {\n+            throw new RuntimeException(\"expected session to remain valid\");\n+        }\n@@ -200,0 +221,1 @@\n+        System.setProperty(\"jdk.tls.client.protocols\", args[0]);\n@@ -204,1 +226,2 @@\n-        shutdownInputTest = args.length > 0 ? true : false;\n+        socketCloseType = args.length > 1 ? args[1] : \"\";\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/SSLSocketCloseHang.java","additions":46,"deletions":23,"binary":false,"changes":69,"status":"modified"}]}