{"files":[{"patch":"@@ -1,308 +0,0 @@\n-#\n-# Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-AC_DEFUN([UTIL_REWRITE_AS_UNIX_PATH],\n-[\n-  windows_path=\"[$]$1\"\n-  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n-    unix_path=`$CYGPATH -u \"$windows_path\"`\n-    $1=\"$unix_path\"\n-  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n-    unix_path=`$ECHO \"$windows_path\" | $SED -e 's,^\\\\(.\\\\):,\/\\\\1,g' -e 's,\\\\\\\\,\/,g'`\n-    $1=\"$unix_path\"\n-  fi\n-])\n-\n-AC_DEFUN([UTIL_REWRITE_AS_WINDOWS_MIXED_PATH],\n-[\n-  unix_path=\"[$]$1\"\n-  if test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.cygwin\"; then\n-    windows_path=`$CYGPATH -m \"$unix_path\"`\n-    $1=\"$windows_path\"\n-  elif test \"x$OPENJDK_BUILD_OS_ENV\" = \"xwindows.msys\"; then\n-    windows_path=`cmd \/\/c echo $unix_path`\n-    $1=\"$windows_path\"\n-  fi\n-])\n-\n-# Helper function which possibly converts a path using DOS-style short mode.\n-# If so, the updated path is stored in $new_path.\n-# $1: The path to check\n-AC_DEFUN([UTIL_MAKE_WINDOWS_SPACE_SAFE_CYGWIN],\n-[\n-  input_path=\"$1\"\n-  # Check if we need to convert this using DOS-style short mode. If the path\n-  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n-  # take no chances and rewrite it.\n-  # Note: m4 eats our [], so we need to use @<:@ and @:>@ instead.\n-  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP @<:@^-._\/a-zA-Z0-9@:>@`\n-  if test \"x$has_forbidden_chars\" != x; then\n-    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n-    shortmode_path=`$CYGPATH -s -m -a \"$input_path\"`\n-    path_after_shortmode=`$CYGPATH -u \"$shortmode_path\"`\n-    if test \"x$path_after_shortmode\" != \"x$input_to_shortpath\"; then\n-      # Going to short mode and back again did indeed matter. Since short mode is\n-      # case insensitive, let's make it lowercase to improve readability.\n-      shortmode_path=`$ECHO \"$shortmode_path\" | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n-      # Now convert it back to Unix-style (cygpath)\n-      input_path=`$CYGPATH -u \"$shortmode_path\"`\n-      new_path=\"$input_path\"\n-    fi\n-  fi\n-\n-  test_cygdrive_prefix=`$ECHO $input_path | $GREP ^\/cygdrive\/`\n-  if test \"x$test_cygdrive_prefix\" = x; then\n-    # As a simple fix, exclude \/usr\/bin since it's not a real path.\n-    if test \"x`$ECHO $1 | $GREP ^\/usr\/bin\/`\" = x; then\n-      # The path is in a Cygwin special directory (e.g. \/home). We need this converted to\n-      # a path prefixed by \/cygdrive for fixpath to work.\n-      new_path=\"$CYGWIN_ROOT_PATH$input_path\"\n-    fi\n-  fi\n-])\n-\n-# Helper function which possibly converts a path using DOS-style short mode.\n-# If so, the updated path is stored in $new_path.\n-# $1: The path to check\n-AC_DEFUN([UTIL_MAKE_WINDOWS_SPACE_SAFE_MSYS],\n-[\n-  input_path=\"$1\"\n-  # Check if we need to convert this using DOS-style short mode. If the path\n-  # contains just simple characters, use it. Otherwise (spaces, weird characters),\n-  # take no chances and rewrite it.\n-  # Note: m4 eats our [], so we need to use @<:@ and @:>@ instead.\n-  has_forbidden_chars=`$ECHO \"$input_path\" | $GREP @<:@^-_\/:a-zA-Z0-9@:>@`\n-  if test \"x$has_forbidden_chars\" != x; then\n-    # Now convert it to mixed DOS-style, short mode (no spaces, and \/ instead of \\)\n-    new_path=`cmd \/c \"for %A in (\\\"$input_path\\\") do @echo %~sA\"|$TR \\\\\\\\\\\\\\\\ \/ | $TR 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`\n-  fi\n-])\n-\n-# FIXME: The UTIL_FIXUP_*_CYGWIN\/MSYS is most likely too convoluted\n-# and could probably be heavily simplified. However, all changes in this\n-# area tend to need lot of testing in different scenarios, and in lack of\n-# proper unit testing, cleaning this up has not been deemed worth the effort\n-# at the moment.\n-\n-AC_DEFUN([UTIL_FIXUP_PATH_CYGWIN],\n-[\n-  # Input might be given as Windows format, start by converting to\n-  # unix format.\n-  path=\"[$]$1\"\n-  new_path=`$CYGPATH -u \"$path\"`\n-\n-  UTIL_ABSOLUTE_PATH(new_path)\n-\n-  # Cygwin tries to hide some aspects of the Windows file system, such that binaries are\n-  # named .exe but called without that suffix. Therefore, \"foo\" and \"foo.exe\" are considered\n-  # the same file, most of the time (as in \"test -f\"). But not when running cygpath -s, then\n-  # \"foo.exe\" is OK but \"foo\" is an error.\n-  #\n-  # This test is therefore slightly more accurate than \"test -f\" to check for file precense.\n-  # It is also a way to make sure we got the proper file name for the real test later on.\n-  test_shortpath=`$CYGPATH -s -m \"$new_path\" 2> \/dev\/null`\n-  if test \"x$test_shortpath\" = x; then\n-    AC_MSG_NOTICE([The path of $1, which resolves as \"$path\", is invalid.])\n-    AC_MSG_ERROR([Cannot locate the the path of $1])\n-  fi\n-\n-  # Call helper function which possibly converts this using DOS-style short mode.\n-  # If so, the updated path is stored in $new_path.\n-  UTIL_MAKE_WINDOWS_SPACE_SAFE_CYGWIN([$new_path])\n-\n-  if test \"x$path\" != \"x$new_path\"; then\n-    $1=\"$new_path\"\n-    AC_MSG_NOTICE([Rewriting $1 to \"$new_path\"])\n-  fi\n-])\n-\n-AC_DEFUN([UTIL_FIXUP_PATH_MSYS],\n-[\n-  path=\"[$]$1\"\n-  has_colon=`$ECHO $path | $GREP ^.:`\n-  new_path=\"$path\"\n-  if test \"x$has_colon\" = x; then\n-    # Not in mixed or Windows style, start by that.\n-    new_path=`cmd \/\/c echo $path`\n-  fi\n-\n-  UTIL_MAKE_WINDOWS_SPACE_SAFE_MSYS([$new_path])\n-  UTIL_REWRITE_AS_UNIX_PATH(new_path)\n-  if test \"x$path\" != \"x$new_path\"; then\n-    $1=\"$new_path\"\n-    AC_MSG_NOTICE([Rewriting $1 to \"$new_path\"])\n-  fi\n-\n-  # Save the first 10 bytes of this path to the storage, so fixpath can work.\n-  all_fixpath_prefixes=(\"${all_fixpath_prefixes@<:@@@:>@}\" \"${new_path:0:10}\")\n-])\n-\n-AC_DEFUN([UTIL_FIXUP_EXECUTABLE_CYGWIN],\n-[\n-  # First separate the path from the arguments. This will split at the first\n-  # space.\n-  complete=\"[$]$1\"\n-  path=\"${complete%% *}\"\n-  tmp=\"$complete EOL\"\n-  arguments=\"${tmp#* }\"\n-\n-  # Input might be given as Windows format, start by converting to\n-  # unix format.\n-  new_path=`$CYGPATH -u \"$path\"`\n-\n-  # Now try to locate executable using which\n-  new_path=`$WHICH \"$new_path\" 2> \/dev\/null`\n-  # bat and cmd files are not always considered executable in cygwin causing which\n-  # to not find them\n-  if test \"x$new_path\" = x \\\n-      && test \"x`$ECHO \\\"$path\\\" | $GREP -i -e \\\"\\\\.bat$\\\" -e \\\"\\\\.cmd$\\\"`\" != x \\\n-      && test \"x`$LS \\\"$path\\\" 2>\/dev\/null`\" != x; then\n-    new_path=`$CYGPATH -u \"$path\"`\n-  fi\n-  if test \"x$new_path\" = x; then\n-    # Oops. Which didn't find the executable.\n-    # The splitting of arguments from the executable at a space might have been incorrect,\n-    # since paths with space are more likely in Windows. Give it another try with the whole\n-    # argument.\n-    path=\"$complete\"\n-    arguments=\"EOL\"\n-    new_path=`$CYGPATH -u \"$path\"`\n-    new_path=`$WHICH \"$new_path\" 2> \/dev\/null`\n-    # bat and cmd files are not always considered executable in cygwin causing which\n-    # to not find them\n-    if test \"x$new_path\" = x \\\n-        && test \"x`$ECHO \\\"$path\\\" | $GREP -i -e \\\"\\\\.bat$\\\" -e \\\"\\\\.cmd$\\\"`\" != x \\\n-        && test \"x`$LS \\\"$path\\\" 2>\/dev\/null`\" != x; then\n-      new_path=`$CYGPATH -u \"$path\"`\n-    fi\n-    if test \"x$new_path\" = x; then\n-      # It's still not found. Now this is an unrecoverable error.\n-      AC_MSG_NOTICE([The path of $1, which resolves as \"$complete\", is not found.])\n-      has_space=`$ECHO \"$complete\" | $GREP \" \"`\n-      if test \"x$has_space\" != x; then\n-        AC_MSG_NOTICE([You might be mixing spaces in the path and extra arguments, which is not allowed.])\n-      fi\n-      AC_MSG_ERROR([Cannot locate the the path of $1])\n-    fi\n-  fi\n-\n-  # Cygwin tries to hide some aspects of the Windows file system, such that binaries are\n-  # named .exe but called without that suffix. Therefore, \"foo\" and \"foo.exe\" are considered\n-  # the same file, most of the time (as in \"test -f\"). But not when running cygpath -s, then\n-  # \"foo.exe\" is OK but \"foo\" is an error.\n-  #\n-  # This test is therefore slightly more accurate than \"test -f\" to check for file presence.\n-  # It is also a way to make sure we got the proper file name for the real test later on.\n-  test_shortpath=`$CYGPATH -s -m \"$new_path\" 2> \/dev\/null`\n-  if test \"x$test_shortpath\" = x; then\n-    # Short path failed, file does not exist as specified.\n-    # Try adding .exe or .cmd\n-    if test -f \"${new_path}.exe\"; then\n-      input_to_shortpath=\"${new_path}.exe\"\n-    elif test -f \"${new_path}.cmd\"; then\n-      input_to_shortpath=\"${new_path}.cmd\"\n-    else\n-      AC_MSG_NOTICE([The path of $1, which resolves as \"$new_path\", is invalid.])\n-      AC_MSG_NOTICE([Neither \"$new_path\" nor \"$new_path.exe\/cmd\" can be found])\n-      AC_MSG_ERROR([Cannot locate the the path of $1])\n-    fi\n-  else\n-    input_to_shortpath=\"$new_path\"\n-  fi\n-\n-  # Call helper function which possibly converts this using DOS-style short mode.\n-  # If so, the updated path is stored in $new_path.\n-  new_path=\"$input_to_shortpath\"\n-  UTIL_MAKE_WINDOWS_SPACE_SAFE_CYGWIN([$input_to_shortpath])\n-  # remove trailing .exe if any\n-  new_path=\"${new_path\/%.exe\/}\"\n-])\n-\n-AC_DEFUN([UTIL_FIXUP_EXECUTABLE_MSYS],\n-[\n-  # First separate the path from the arguments. This will split at the first\n-  # space.\n-  complete=\"[$]$1\"\n-  path=\"${complete%% *}\"\n-  tmp=\"$complete EOL\"\n-  arguments=\"${tmp#* }\"\n-\n-  # Input might be given as Windows format, start by converting to\n-  # unix format.\n-  new_path=\"$path\"\n-  UTIL_REWRITE_AS_UNIX_PATH(new_path)\n-\n-  # Now try to locate executable using which\n-  new_path=`$WHICH \"$new_path\" 2> \/dev\/null`\n-\n-  if test \"x$new_path\" = x; then\n-    # Oops. Which didn't find the executable.\n-    # The splitting of arguments from the executable at a space might have been incorrect,\n-    # since paths with space are more likely in Windows. Give it another try with the whole\n-    # argument.\n-    path=\"$complete\"\n-    arguments=\"EOL\"\n-    new_path=\"$path\"\n-    UTIL_REWRITE_AS_UNIX_PATH(new_path)\n-\n-    new_path=`$WHICH \"$new_path\" 2> \/dev\/null`\n-    # bat and cmd files are not always considered executable in MSYS causing which\n-    # to not find them\n-    if test \"x$new_path\" = x \\\n-        && test \"x`$ECHO \\\"$path\\\" | $GREP -i -e \\\"\\\\.bat$\\\" -e \\\"\\\\.cmd$\\\"`\" != x \\\n-        && test \"x`$LS \\\"$path\\\" 2>\/dev\/null`\" != x; then\n-      new_path=\"$path\"\n-      UTIL_REWRITE_AS_UNIX_PATH(new_path)\n-    fi\n-\n-    if test \"x$new_path\" = x; then\n-      # It's still not found. Now this is an unrecoverable error.\n-      AC_MSG_NOTICE([The path of $1, which resolves as \"$complete\", is not found.])\n-      has_space=`$ECHO \"$complete\" | $GREP \" \"`\n-      if test \"x$has_space\" != x; then\n-        AC_MSG_NOTICE([You might be mixing spaces in the path and extra arguments, which is not allowed.])\n-      fi\n-      AC_MSG_ERROR([Cannot locate the the path of $1])\n-    fi\n-  fi\n-\n-  # Now new_path has a complete unix path to the binary\n-  if test \"x`$ECHO $new_path | $GREP ^\/bin\/`\" != x; then\n-    # Keep paths in \/bin as-is, but remove trailing .exe if any\n-    new_path=\"${new_path\/%.exe\/}\"\n-    # Do not save \/bin paths to all_fixpath_prefixes!\n-  else\n-    # Not in mixed or Windows style, start by that.\n-    new_path=`cmd \/\/c echo $new_path`\n-    UTIL_MAKE_WINDOWS_SPACE_SAFE_MSYS([$new_path])\n-    # Output is in $new_path\n-    UTIL_REWRITE_AS_UNIX_PATH(new_path)\n-    # remove trailing .exe if any\n-    new_path=\"${new_path\/%.exe\/}\"\n-\n-    # Save the first 10 bytes of this path to the storage, so fixpath can work.\n-    all_fixpath_prefixes=(\"${all_fixpath_prefixes@<:@@@:>@}\" \"${new_path:0:10}\")\n-  fi\n-])\n","filename":"make\/autoconf\/util_windows.m4","additions":0,"deletions":308,"binary":false,"changes":308,"status":"deleted"}]}