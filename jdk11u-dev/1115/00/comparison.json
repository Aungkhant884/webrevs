{"files":[{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2022, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8240903\n+ * @summary Test consistency of moduleHashes attribute between builds\n+ * @library \/test\/lib\n+ * @run testng HashesOrderTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Collectors;\n+\n+import jdk.test.lib.compiler.ModuleInfoMaker;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class HashesOrderTest {\n+    private ToolProvider JMOD_TOOL = ToolProvider.findFirst(\"jmod\")\n+        .orElseThrow(() ->\n+            new RuntimeException(\"jmod tool not found\")\n+        );\n+\n+    \/\/ buffer size used for reading and writing\n+    private static final int BUFFER_SIZE = 8192;\n+\n+    private int NUM_MODULES = 64;\n+    private Path mods;\n+    private Path lib1;\n+    private Path lib2;\n+    private ModuleInfoMaker builder;\n+\n+    @Test\n+    public void test() throws Exception {\n+        mods = Path.of(\"mods\");\n+        lib1 = Path.of(\"lib1\");\n+        lib2 = Path.of(\"lib2\");\n+        builder = new ModuleInfoMaker(Path.of(\"src\"));\n+\n+        Files.createDirectories(mods);\n+        Files.createDirectories(lib1);\n+        Files.createDirectories(lib2);\n+\n+        makeModule(\"ma\");\n+        String moduleName;\n+        for (int i = 0; i < NUM_MODULES; i++) {\n+            moduleName = \"m\" + i + \"b\";\n+            makeModule(moduleName, \"ma\");\n+            makeJmod(moduleName, lib1);\n+            makeJmod(moduleName, lib2);\n+        }\n+        makeJmod(\"ma\", lib1, \"--module-path\", lib1.toString(),\n+                \"--hash-modules\", \".*\");\n+        Path jmod1 = lib1.resolve(\"ma.jmod\");\n+\n+        makeJmod(\"ma\", lib2, \"--module-path\", lib2.toString(),\n+                \"--hash-modules\", \".*\");\n+        Path jmod2 = lib2.resolve(\"ma.jmod\");\n+\n+        assertEquals(mismatch(jmod1, jmod2), -1);\n+    }\n+\n+    private void makeModule(String mn, String... deps)\n+        throws IOException\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"module \")\n+          .append(mn)\n+          .append(\" {\")\n+          .append(\"\\n\");\n+        Arrays.stream(deps)\n+              .forEach(req -> {\n+                  sb.append(\"    requires \");\n+                  sb.append(req)\n+                    .append(\";\\n\");\n+              });\n+        sb.append(\"}\\n\");\n+        builder.writeJavaFiles(mn, sb.toString());\n+        builder.compile(mn, mods);\n+    }\n+\n+    private void makeJmod(String moduleName, Path libName, String... options) {\n+        Path mclasses = mods.resolve(moduleName);\n+        Path outfile = libName.resolve(moduleName + \".jmod\");\n+        List<String> args = new ArrayList<>();\n+        args.add(\"create\");\n+        Collections.addAll(args, options);\n+        Collections.addAll(args, \"--class-path\", mclasses.toString(),\n+                           outfile.toString());\n+\n+        runJmod(args);\n+    }\n+\n+    private void runJmod(List<String> args) {\n+        runJmod(args.toArray(new String[args.size()]));\n+    }\n+\n+    private void runJmod(String... args) {\n+        int rc = JMOD_TOOL.run(System.out, System.out, args);\n+        System.out.println(\"jmod \" + Arrays.stream(args).collect(Collectors.joining(\" \")));\n+        if (rc != 0) {\n+            throw new AssertionError(\"jmod failed: rc = \" + rc);\n+        }\n+    }\n+\n+    private long mismatch(Path path, Path path2) throws IOException {\n+        if (Files.isSameFile(path, path2)) {\n+            return -1;\n+        }\n+        byte[] buffer1 = new byte[BUFFER_SIZE];\n+        byte[] buffer2 = new byte[BUFFER_SIZE];\n+        try (InputStream in1 = Files.newInputStream(path);\n+             InputStream in2 = Files.newInputStream(path2);) {\n+            long totalRead = 0;\n+            while (true) {\n+                int nRead1 = in1.readNBytes(buffer1, 0, BUFFER_SIZE);\n+                int nRead2 = in2.readNBytes(buffer2, 0, BUFFER_SIZE);\n+\n+                int i = Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);\n+                if (i > -1) {\n+                    return totalRead + i;\n+                }\n+                if (nRead1 < BUFFER_SIZE) {\n+                    \/\/ we've reached the end of the files, but found no mismatch\n+                    return -1;\n+                }\n+                totalRead += nRead1;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jmod\/hashes\/HashesOrderTest.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"}]}