{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/*\n+\/**\n@@ -26,1 +26,1 @@\n- * @bug 4327164\n+ * @bug 4327164 8229338\n@@ -28,0 +28,1 @@\n+ * @run testng Basic\n@@ -30,8 +31,9 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Random;\n-import java.util.RandomAccess;\n-import java.util.Vector;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+import java.util.*;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n@@ -40,47 +42,0 @@\n-    public static void main(String[] args) throws Exception {\n-        List a0 = Arrays.asList(new String[] { \"a\", \"b\", \"c\" });\n-        List a[] = { a0, new ArrayList(a0), new LinkedList(a0),\n-                new Vector(a0) };\n-\n-        if (!(a[0] instanceof RandomAccess))\n-            throw new Exception(\"Arrays.asList doesn't implement RandomAccess\");\n-        if (!(a[1] instanceof RandomAccess))\n-            throw new Exception(\"ArrayList doesn't implement RandomAccess\");\n-        if (a[2] instanceof RandomAccess)\n-            throw new Exception(\"LinkedList implements RandomAccess\");\n-        if (!(a[3] instanceof RandomAccess))\n-            throw new Exception(\"Vector doesn't implement RandomAccess\");\n-\n-        for (int i = 0; i < a.length; i++) {\n-            List t = a[i];\n-            List ut = Collections.unmodifiableList(t);\n-            List st = Collections.synchronizedList(t);\n-\n-            boolean random = t instanceof RandomAccess;\n-            if ((ut instanceof RandomAccess) != random)\n-                throw new Exception(\n-                        \"Unmodifiable fails to preserve RandomAccess: \" + i);\n-            if ((st instanceof RandomAccess) != random)\n-                throw new Exception(\n-                        \"Synchronized fails to preserve RandomAccess: \" + i);\n-\n-            while (t.size() > 0) {\n-                t = t.subList(0, t.size() - 1);\n-                if ((t instanceof RandomAccess) != random)\n-                    throw new Exception(\n-                            \"SubList fails to preserve RandomAccess: \" + i\n-                                    + \", \" + t.size());\n-\n-                ut = ut.subList(0, ut.size() - 1);\n-                if ((ut instanceof RandomAccess) != random)\n-                    throw new Exception(\n-                            \"SubList(unmodifiable) fails to preserve RandomAccess: \"\n-                                    + i + \", \" + ut.size());\n-\n-                st = st.subList(0, st.size() - 1);\n-                if ((st instanceof RandomAccess) != random)\n-                    throw new Exception(\n-                            \"SubList(synchronized) fails to preserve RandomAccess: \"\n-                                    + i + \", \" + st.size());\n-            }\n-        }\n@@ -88,6 +43,8 @@\n-        \/\/ Test that shuffle works the same on random and sequential access\n-        List al = new ArrayList();\n-        for (int j = 0; j < 100; j++)\n-            al.add(Integer.valueOf(2 * j));\n-        List ll = new LinkedList(al);\n-        Random r1 = new Random(666), r2 = new Random(666);\n+    \/*\n+     * Lists which implement Random Access interface\n+     *\/\n+    @DataProvider(name = \"testLists\")\n+    public Object[][] testData() {\n+        var intArray = new Integer[100];\n+        var stack = new Stack<>();\n+        var random = new Random();\n@@ -95,4 +52,42 @@\n-            Collections.shuffle(al, r1);\n-            Collections.shuffle(ll, r2);\n-            if (!al.equals(ll))\n-                throw new Exception(\"Shuffle failed: \" + i);\n+            var r = random.nextInt(100);\n+            stack.push(r);\n+            intArray[i] = r;\n+        }\n+        List<Integer> list = Arrays.asList(intArray);\n+        return new Object[][]{\n+                {list, true, \"Arrays.asList\"},\n+                {stack, true, \"Stack\"},\n+                {new ArrayList<>(list), true, \"ArrayList\"},\n+                {new LinkedList<>(list), false, \"LinkedList\"},\n+                {new Vector<>(list), true, \"Vector\"},\n+                {new CopyOnWriteArrayList<>(list), true, \"CopyOnWriteArrayList\"}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"testLists\")\n+    public void testRandomAccess(List<Integer> list, boolean expectedRA, String failMsg) {\n+\n+        var actualRA = list instanceof RandomAccess;\n+        assertEquals(actualRA, expectedRA, failMsg);\n+\n+        List<Integer> unmodList = Collections.unmodifiableList(list);\n+        List<Integer> syncList = Collections.synchronizedList(list);\n+        assertEquals((unmodList instanceof RandomAccess), actualRA,\n+                \"Unmodifiable fails to preserve RandomAccess\");\n+        assertEquals((syncList instanceof RandomAccess), actualRA,\n+                \"Synchronized fails to preserve RandomAccess\");\n+\n+        while (list.size() > 0) {\n+            list = list.subList(0, list.size() - 1);\n+            assertEquals((list instanceof RandomAccess), actualRA,\n+                    \"SubList fails to preserve RandomAccess: \" + list.size());\n+\n+            unmodList = unmodList.subList(0, unmodList.size() - 1);\n+            assertEquals((unmodList instanceof RandomAccess), actualRA,\n+                    \"SubList(unmodifiable) fails to preserve RandomAccess: \"\n+                            + unmodList.size());\n+\n+            syncList = syncList.subList(0, syncList.size() - 1);\n+            assertEquals((syncList instanceof RandomAccess), actualRA,\n+                    \"SubList(synchronized) fails to preserve RandomAccess: \"\n+                            + syncList.size());\n@@ -100,0 +95,1 @@\n+    }\n@@ -101,8 +97,7 @@\n-        \/\/ Test that fill works on random & sequential access\n-        List gumbyParade = Collections.nCopies(100, \"gumby\");\n-        Collections.fill(al, \"gumby\");\n-        if (!al.equals(gumbyParade))\n-            throw new Exception(\"ArrayList fill failed\");\n-        Collections.fill(ll, \"gumby\");\n-        if (!ll.equals(gumbyParade))\n-            throw new Exception(\"LinkedList fill failed\");\n+    @Test(dataProvider = \"testLists\")\n+    public void testListCopy(List<Integer> list, boolean expectedRA, String failMsg) {\n+        ArrayList testCollection = new ArrayList<>(Collections.nCopies(100, 0));\n+        \/\/ Test that copy works on random & sequential access\n+        Collections.copy(list, testCollection);\n+        assertEquals(list, testCollection, \"Copy failed: \" + failMsg);\n+    }\n@@ -110,0 +105,3 @@\n+    @Test(dataProvider = \"testLists\")\n+    public void testListFill(List<Integer> list, boolean expectedRA, String failMsg) {\n+        ArrayList testCollection = new ArrayList<>(Collections.nCopies(100, 0));\n@@ -111,13 +109,53 @@\n-        List pokeyParade = Collections.nCopies(100, \"pokey\");\n-        Collections.copy(al, pokeyParade);\n-        if (!al.equals(pokeyParade))\n-            throw new Exception(\"ArrayList copy failed\");\n-        Collections.copy(ll, pokeyParade);\n-        if (!ll.equals(pokeyParade))\n-            throw new Exception(\"LinkedList copy failed\");\n-\n-        \/\/ Test that binarySearch works the same on random & sequential access\n-        al = new ArrayList();\n-        for (int i = 0; i < 10000; i++)\n-            al.add(Integer.valueOf(2 * i));\n-        ll = new LinkedList(al);\n+        Collections.fill(list, 0);\n+        assertEquals(list, testCollection, \"Fill failed: \" + failMsg);\n+    }\n+\n+    \/*\n+     * Test that shuffle and binarySearch work the same on random and sequential access lists.\n+     *\/\n+    @DataProvider(name = \"testFactoryLists\")\n+    public Object[][] testDataFactory() {\n+        return new Object[][]{\n+                {\"ArrayList -> LinkedList\", supplier(ArrayList::new), copyCtor(LinkedList::new)},\n+                {\"CopyOnWriteArrayList -> Stack\", supplier(CopyOnWriteArrayList::new),\n+                        copyCtor((list) -> { var s = new Stack();s.addAll(list);return s; })}\n+        };\n+    }\n+\n+    private Supplier<List<Integer>> supplier(Supplier<List<Integer>> supplier) {\n+        return supplier;\n+    }\n+\n+    private Function<List<Integer>, List<Integer>> copyCtor(Function<List<Integer>, List<Integer>> ctor) {\n+        return ctor;\n+    }\n+\n+    @Test(dataProvider = \"testFactoryLists\")\n+    public void testListShuffle(String description, Supplier<List<Integer>> randomAccessListSupplier,\n+                                Function<List<Integer>, List<Integer>> otherListFactory) {\n+\n+        \/\/e.g: ArrayList<Integer> al = new ArrayList<>();\n+        List<Integer> l1 = randomAccessListSupplier.get();\n+        for (int j = 0; j < 100; j++) {\n+            l1.add(Integer.valueOf(2 * j));\n+        }\n+        \/\/ e.g: List<Integer> ll = new LinkedList<>(al);\n+        List<Integer> l2 = otherListFactory.apply(l1);\n+        for (int i = 0; i < 100; i++) {\n+            Collections.shuffle(l1, new Random(666));\n+            Collections.shuffle(l2, new Random(666));\n+            assertEquals(l1, l2, \"Shuffle failed: \" + description);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"testFactoryLists\")\n+    public void testListBinarySearch(String description, Supplier<List<Integer>> randomAccessListSupplier,\n+                                     Function<List<Integer>, List<Integer>> otherListFactory) {\n+\n+        \/\/e.g: ArrayList<Integer> al = new ArrayList<>();\n+        List<Integer> l1 = randomAccessListSupplier.get();\n+        for (int i = 0; i < 10000; i++) {\n+            l1.add(Integer.valueOf(2 * i));\n+        }\n+        \/\/ e.g: List<Integer> ll = new LinkedList<>(al);\n+        List<Integer> l2 = otherListFactory.apply(l1);\n@@ -125,4 +163,3 @@\n-            Integer key = Integer.valueOf(r1.nextInt(20000));\n-            if (Collections.binarySearch(al, key) != Collections\n-                    .binarySearch(ll, key))\n-                throw new Exception(\"Binary search failed: \" + i);\n+            Integer key = Integer.valueOf(new Random(666).nextInt(20000));\n+            assertEquals(Collections.binarySearch(l1, key), Collections\n+                    .binarySearch(l2, key), \"Binary search failed: \" + description);\n","filename":"test\/jdk\/java\/util\/RandomAccess\/Basic.java","additions":130,"deletions":93,"binary":false,"changes":223,"status":"modified"}]}