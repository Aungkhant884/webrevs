{"files":[{"patch":"@@ -49,0 +49,1 @@\n+  friend class PrepareExtraDataClosure;\n@@ -191,0 +192,4 @@\n+  ciMetadata* cached_metadata(Metadata* o) {\n+    return _factory->cached_metadata(o);\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,1 +56,51 @@\n-void ciMethodData::load_extra_data() {\n+\/\/ Check for entries that reference an unloaded method\n+class PrepareExtraDataClosure : public CleanExtraDataClosure {\n+  MethodData*            _mdo;\n+  int                    _safepoint_counter; \/\/ Needs to be uint64_t after JDK-8212108!\n+  GrowableArray<Method*> _uncached_methods;\n+\n+public:\n+  PrepareExtraDataClosure(MethodData* mdo)\n+    : _mdo(mdo),\n+      _safepoint_counter(SafepointSynchronize::safepoint_counter()),\n+      _uncached_methods()\n+  { }\n+\n+  bool is_live(Method* m) {\n+    if (!m->method_holder()->is_loader_alive()) {\n+      return false;\n+    }\n+    if (CURRENT_ENV->cached_metadata(m) == NULL) {\n+      \/\/ Uncached entries need to be pre-populated.\n+      _uncached_methods.append(m);\n+    }\n+    return true;\n+  }\n+\n+  bool has_safepointed() {\n+    return SafepointSynchronize::safepoint_counter() != _safepoint_counter;\n+  }\n+\n+  bool finish() {\n+    if (_uncached_methods.length() == 0) {\n+      \/\/ Preparation finished iff all Methods* were already cached.\n+      return true;\n+    }\n+    \/\/ Holding locks through safepoints is bad practice.\n+    MutexUnlocker mu(_mdo->extra_data_lock());\n+    for (int i = 0; i < _uncached_methods.length(); ++i) {\n+      if (has_safepointed()) {\n+        \/\/ The metadata in the growable array might contain stale\n+        \/\/ entries after a safepoint.\n+        return false;\n+      }\n+      Method* method = _uncached_methods.at(i);\n+      \/\/ Populating ciEnv caches may cause safepoints due\n+      \/\/ to taking the Compile_lock with safepoint checks.\n+      (void)CURRENT_ENV->get_method(method);\n+    }\n+    return false;\n+  }\n+};\n+\n+void ciMethodData::prepare_metadata() {\n@@ -59,0 +109,16 @@\n+  for (;;) {\n+    ResourceMark rm;\n+    PrepareExtraDataClosure cl(mdo);\n+    mdo->clean_extra_data(&cl);\n+    if (cl.finish()) {\n+      \/\/ When encountering uncached metadata, the Compile_lock might be\n+      \/\/ acquired when creating ciMetadata handles, causing safepoints\n+      \/\/ which requires a new round of preparation to clean out potentially\n+      \/\/ new unloading metadata.\n+      return;\n+    }\n+  }\n+}\n+\n+void ciMethodData::load_remaining_extra_data() {\n+  MethodData* mdo = get_MethodData();\n@@ -60,0 +126,13 @@\n+  \/\/ Deferred metadata cleaning due to concurrent class unloading.\n+  prepare_metadata();\n+  \/\/ After metadata preparation, there is no stale metadata,\n+  \/\/ and no safepoints can introduce more stale metadata.\n+  NoSafepointVerifier no_safepoint;\n+\n+  assert((mdo->data_size() == _data_size) && (mdo->extra_data_size() == _extra_data_size), \"sanity, unchanged\");\n+  assert(extra_data_base() == (DataLayout*)((address) _data + _data_size), \"sanity\");\n+\n+  \/\/ Copy the extra data once it is prepared (i.e. cache populated, no release of extra data lock anymore)\n+  Copy::disjoint_words_atomic((HeapWord*) mdo->extra_data_base(),\n+                              (HeapWord*)((address) _data + _data_size),\n+                              (_extra_data_size - mdo->parameters_size_in_bytes()) \/ HeapWordSize);\n@@ -69,5 +148,0 @@\n-    \/\/ New traps in the MDO may have been added since we copied the\n-    \/\/ data (concurrent deoptimizations before we acquired\n-    \/\/ extra_data_lock above) or can be removed (a safepoint may occur\n-    \/\/ in the translate_from call below) as we translate the copy:\n-    \/\/ update the copy as we go.\n@@ -75,7 +149,0 @@\n-    size_t entry_size = DataLayout::header_size_in_bytes();\n-    if (tag != DataLayout::no_tag) {\n-      ProfileData* src_data = dp_src->data_in();\n-      entry_size = src_data->size_in_bytes();\n-    }\n-    memcpy(dp_dst, dp_src, entry_size);\n-\n@@ -86,5 +153,1 @@\n-\n-      { \/\/ During translation a safepoint can happen or VM lock can be taken (e.g., Compile_lock).\n-        MutexUnlocker ml(mdo->extra_data_lock());\n-        data_dst.translate_from(&data_src);\n-      }\n+      data_dst.translate_from(&data_src);\n@@ -116,3 +179,25 @@\n-  \/\/ Snapshot the data -- actually, take an approximate snapshot of\n-  \/\/ the data.  Any concurrently executing threads may be changing the\n-  \/\/ data as we copy it.\n+  \/\/ Snapshot the data and extra parameter data first without the extra trap and arg info data.\n+  \/\/ Those are copied in a second step. Actually, an approximate snapshot of the data is taken.\n+  \/\/ Any concurrently executing threads may be changing the data as we copy it.\n+  \/\/\n+  \/\/ The first snapshot step requires two copies (data entries and parameter data entries) since\n+  \/\/ the MDO is laid out as follows:\n+  \/\/\n+  \/\/  data_base:        ---------------------------\n+  \/\/                    |       data entries      |\n+  \/\/                    |           ...           |\n+  \/\/  extra_data_base:  ---------------------------\n+  \/\/                    |    trap data entries    |\n+  \/\/                    |           ...           |\n+  \/\/                    | one arg info data entry |\n+  \/\/                    |    data for each arg    |\n+  \/\/                    |           ...           |\n+  \/\/  args_data_limit:  ---------------------------\n+  \/\/                    |  parameter data entries |\n+  \/\/                    |           ...           |\n+  \/\/  extra_data_limit: ---------------------------\n+  \/\/\n+  \/\/ _data_size = extra_data_base - data_base\n+  \/\/ _extra_data_size = extra_data_limit - extra_data_base\n+  \/\/ total_size = _data_size + _extra_data_size\n+  \/\/ args_data_limit = data_base + total_size - parameter_data_size\n@@ -130,1 +215,1 @@\n-                              total_size \/ HeapWordSize);\n+                              _data_size \/ HeapWordSize);\n@@ -132,0 +217,7 @@\n+  int parameters_data_size = mdo->parameters_size_in_bytes();\n+  if (parameters_data_size > 0) {\n+    \/\/ Snapshot the parameter data\n+    Copy::disjoint_words_atomic((HeapWord*) mdo->args_data_limit(),\n+                                (HeapWord*) ((address)_data + total_size - parameters_data_size),\n+                                parameters_data_size \/ HeapWordSize);\n+  }\n@@ -148,1 +240,3 @@\n-  load_extra_data();\n+  assert((DataLayout*) ((address)_data + total_size - parameters_data_size) == args_data_limit(),\n+      \"sanity - parameter data starts after the argument data of the single ArgInfoData entry\");\n+  load_remaining_extra_data();\n@@ -260,1 +354,1 @@\n-      return NULL; \/\/ ArgInfoData is at the end of extra data section.\n+      return NULL; \/\/ ArgInfoData is after the trap data right before the parameter data.\n@@ -671,1 +765,1 @@\n-      dp = end; \/\/ ArgInfoData is at the end of extra data section.\n+      dp = end; \/\/ ArgInfoData is after the trap data right before the parameter data.\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":119,"deletions":25,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -476,1 +476,2 @@\n-  void load_extra_data();\n+  void prepare_metadata();\n+  void load_remaining_extra_data();\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -268,0 +268,18 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciObjectFactory::cached_metadata\n+\/\/\n+\/\/ Get the ciMetadata corresponding to some Metadata. If the ciMetadata has\n+\/\/ already been created, it is returned. Otherwise, null is returned.\n+ciMetadata* ciObjectFactory::cached_metadata(Metadata* key) {\n+  ASSERT_IN_VM;\n+\n+  bool found = false;\n+  int index = _ci_metadata->find_sorted<Metadata*, ciObjectFactory::metadata_compare>(key, found);\n+\n+  if (!found) {\n+    return NULL;\n+  }\n+  return _ci_metadata->at(index)->as_metadata();\n+}\n+\n+\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+  ciMetadata* cached_metadata(Metadata* key);\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2167,0 +2167,1 @@\n+      MutexLockerEx ml(SafepointSynchronize::is_at_safepoint() ? NULL : mdo->extra_data_lock());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1653,5 +1653,0 @@\n-class CleanExtraDataClosure : public StackObj {\n-public:\n-  virtual bool is_live(Method* m) = 0;\n-};\n-\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1947,1 +1947,5 @@\n-class CleanExtraDataClosure;\n+class CleanExtraDataClosure : public StackObj {\n+public:\n+  virtual bool is_live(Method* m) = 0;\n+};\n+\n@@ -2107,4 +2111,0 @@\n-  int parameters_size_in_bytes() const {\n-    ParametersTypeData* param = parameters_type_data();\n-    return param == NULL ? 0 : param->size_in_bytes();\n-  }\n@@ -2187,1 +2187,0 @@\n-  void clean_extra_data(CleanExtraDataClosure* cl);\n@@ -2192,0 +2191,2 @@\n+  void clean_extra_data(CleanExtraDataClosure* cl);\n+\n@@ -2320,0 +2321,5 @@\n+  int parameters_size_in_bytes() const {\n+    ParametersTypeData* param = parameters_type_data();\n+    return param == NULL ? 0 : param->size_in_bytes();\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"}]}