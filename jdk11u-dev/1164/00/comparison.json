{"files":[{"patch":"@@ -2572,1 +2572,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);\n@@ -2580,1 +2580,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);\n@@ -2588,1 +2588,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);\n@@ -2596,1 +2596,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);\n@@ -2604,1 +2604,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);\n@@ -2612,1 +2612,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);\n@@ -2620,1 +2620,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);\n@@ -2628,1 +2628,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -39,0 +39,11 @@\n+define(LOADL,`\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+  enc_class aarch64_enc_$2($1 dst, memory mem) %{\n+    $3Register dst_reg = as_$3Register($dst$$reg);\n+    loadStore(MacroAssembler(&cbuf), &MacroAssembler::$2, dst_reg, $mem->opcode(),\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, $4);\n+  %}')dnl\n+dnl\n+dnl\n+dnl\n@@ -109,8 +120,8 @@\n-LOAD(iRegI,ldrshw)\n-LOAD(iRegI,ldrsh)\n-LOAD(iRegI,ldrh)\n-LOAD(iRegL,ldrh)\n-LOAD(iRegI,ldrw)\n-LOAD(iRegL,ldrw)\n-LOAD(iRegL,ldrsw)\n-LOAD(iRegL,ldr)\n+LOADL(iRegI,ldrshw,,2)\n+LOADL(iRegI,ldrsh,,2)\n+LOADL(iRegI,ldrh,,2)\n+LOADL(iRegL,ldrh,,2)\n+LOADL(iRegI,ldrw,,4)\n+LOADL(iRegL,ldrw,,4)\n+LOADL(iRegL,ldrsw,,4)\n+LOADL(iRegL,ldr,,8)\n","filename":"src\/hotspot\/cpu\/aarch64\/ad_encode.m4","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,546 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import sun.misc.Unsafe;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import static java.lang.Math.abs;\n+import static java.lang.Math.pow;\n+import static java.lang.Math.round;\n+import static java.math.BigInteger.TEN;\n+import java.lang.reflect.Field;\n+import java.math.BigInteger;\n+import java.nio.ByteOrder;\n+import static java.lang.String.format;\n+import static java.lang.System.arraycopy;\n+\n+\/* @test\n+ * @bug 8235385 8287508\n+ * @summary Verifies non-volatile memory access with long offset\n+ * @requires os.arch == \"aarch64\"\n+ *\/\n+public class NonVolatileMemoryAccessWithLongOffset {\n+    private static final Unsafe unsafe;\n+    static Random random = new Random();\n+\n+    static {\n+        Field f = null;\n+        try {\n+            f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n+            f.setAccessible(true);\n+            unsafe = (Unsafe) f.get(null);\n+        } catch (ReflectiveOperationException e) {\n+            throw new Error(e);\n+        }\n+    }\n+    private static final int MAX_LENGTH = 10000;\n+\n+    private static byte[] input0 = new byte[MAX_LENGTH];\n+    private static byte[] input1 = new byte[MAX_LENGTH];\n+    private static final int MAX_VALUE_LENGTH = random.nextInt(200) + 20;\n+    private static final byte[] maxValue = new byte[MAX_VALUE_LENGTH];\n+    private static final byte[] minValue = new byte[MAX_VALUE_LENGTH];\n+    private static final int DECIMAL_MAX_VALUE_LENGTH = MAX_VALUE_LENGTH - 15;\n+    private static byte[] byteArray;\n+\n+    private static final    int valueType = random.nextInt(100);\n+    private static final    int numNulls = random.nextInt(100);\n+    private static final    int numRows = random.nextInt(100);\n+    private static final    int countDistinct = random.nextInt(100);\n+    private static final    long rawDataSize = (long)random.nextInt(100);\n+    private static final    long sum = (long)random.nextInt(1000);\n+    private static final    int version = random.nextInt(100);\n+\n+\n+    private static final    int dictOffset = random.nextInt(100);\n+    private static final    int dictLength = random.nextInt(100);\n+    private static final    int histOffset = random.nextInt(100);\n+    private static final    int histLength = random.nextInt(100);\n+    private static final    int dpnOffset = random.nextInt(100);\n+    private static final    int dpnCount = random.nextInt(100);\n+\n+    private static final    long maxRowCount = (long)random.nextInt(1000);\n+    private static final    long minRowCount = (long)random.nextInt(1000);\n+    private static final    long totalRowCount = (long)random.nextInt(100);\n+    private static final    long maxMemSize = (long)random.nextInt(1000);\n+    private static final    long minMemSize = (long)random.nextInt(100);\n+    private static final    long totalMemSize = (long)random.nextInt(1000);\n+\n+    private static final    long toastOffset = (long)random.nextInt(1000);\n+    private static final    boolean hasToast = random.nextInt(100) > 50;\n+\n+\n+    private static final int MAX_STRING_LENGTH = random.nextInt(300) + 20;\n+    private static final byte[] maxString = new byte[MAX_STRING_LENGTH];\n+    private static final byte[] minString = new byte[MAX_STRING_LENGTH];\n+    private static int maxStringLength = random.nextInt(100);\n+    private static int minStringLength = random.nextInt(100);\n+    private static final boolean maxStringIsNull = random.nextInt(100) > 20;\n+    private static final boolean minStringIsNull = random.nextInt(100) > 60;\n+\n+    private static final short precision = (short)random.nextInt(100);\n+    private static final short scale = (short)random.nextInt(100);\n+    private static final boolean useShortCompressFloat = random.nextInt(100) > 60;\n+    private static final int SHORT_SIZE = 2;\n+    private static final int CHAR_SIZE = 2;\n+    private static final int INT_SIZE = 4;\n+    private static final int LONG_SIZE = 8;\n+    private static final int FLOAT_SIZE = 4;\n+    private static final int DOUBLE_SIZE = 8;\n+    private static final int BOOLEAN_SIZE = 1;\n+\n+    private static void premitiveAssert(boolean flag) {\n+        if (flag == false) {\n+            throw new RuntimeException(\"overflow!\");\n+        }\n+    }\n+\n+    private static long BYTE_ARRAY_OFFSET = unsafe.ARRAY_BYTE_BASE_OFFSET;\n+\n+    private static final void toBytes(short obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         SHORT_SIZE));\n+        unsafe.putShort(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    private static final short bytes2short(byte[] rawBytes, int start){\n+        premitiveAssert(rawBytes.length >= (start + SHORT_SIZE));\n+        return unsafe.getShort(rawBytes, (long) BYTE_ARRAY_OFFSET + start);\n+    }\n+\n+    private static final void toBytes(int obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         INT_SIZE));\n+        unsafe.putInt(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    private static final int bytes2int(byte[] rawBytes, int start){\n+        premitiveAssert(rawBytes.length >= (start + INT_SIZE));\n+        return unsafe.getInt(rawBytes, (long) BYTE_ARRAY_OFFSET + start);\n+    }\n+\n+    private static final void toBytes(long obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         LONG_SIZE));\n+        unsafe.putLong(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    private static final long bytes2long(byte[] rawBytes, int start){\n+        premitiveAssert(rawBytes.length >= (start + LONG_SIZE));\n+        return unsafe.getLong(rawBytes, (long) BYTE_ARRAY_OFFSET + start);\n+    }\n+\n+    private static final void toBytes(boolean obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         1));\n+        unsafe.putBoolean(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    private static final boolean bytes2boolen(byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start + 1));\n+        return unsafe.getBoolean(rawBytes, (long) BYTE_ARRAY_OFFSET + start);\n+    }\n+\n+    private static final byte[] toBytesDup() {\n+        byte[] rawBytes = input1;\n+\n+        int offset = 0;\n+\n+        toBytes(valueType, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(numNulls, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(numRows, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(countDistinct, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(rawDataSize, rawBytes, offset);\n+        offset +=         LONG_SIZE;\n+\n+        toBytes(sum, rawBytes, offset);\n+        offset +=         LONG_SIZE;\n+        if (version > 50) {\n+            System.arraycopy(maxValue, 0, rawBytes, offset, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+\n+            System.arraycopy(minValue, 0, rawBytes, offset, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+        } else {\n+            System.arraycopy(maxValue, 0, rawBytes, offset, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+\n+            System.arraycopy(minValue, 0, rawBytes, offset, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+        }\n+\n+        toBytes(dictOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dictLength, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(histOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(histLength, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dpnOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dpnCount, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+        if (version >= 60) {\n+            toBytes(maxRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(minRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(totalRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(maxMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(minMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(totalMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+        }\n+\n+       if (version >= 65) {\n+           toBytes(toastOffset, rawBytes, offset);\n+           offset +=         LONG_SIZE;\n+           toBytes(hasToast, rawBytes, offset);\n+           offset +=         BOOLEAN_SIZE;\n+       }\n+       if (version >= 70) {\n+          System.arraycopy(maxString, 0, rawBytes, offset, MAX_STRING_LENGTH);\n+          offset += MAX_STRING_LENGTH;\n+\n+          System.arraycopy(minString, 0, rawBytes, offset, MAX_STRING_LENGTH);\n+          offset += MAX_STRING_LENGTH;\n+\n+          toBytes(maxStringLength, rawBytes, offset);\n+          offset +=         INT_SIZE;\n+\n+          toBytes(minStringLength, rawBytes, offset);\n+          offset +=         INT_SIZE;\n+\n+          toBytes(maxStringIsNull, rawBytes, offset);\n+          offset +=         BOOLEAN_SIZE;\n+\n+          toBytes(minStringIsNull, rawBytes, offset);\n+          offset +=         BOOLEAN_SIZE;\n+       }\n+\n+       if (version >= 75) {\n+           toBytes(precision, rawBytes, offset);\n+           offset +=         SHORT_SIZE;\n+\n+           toBytes(scale, rawBytes, offset);\n+           offset +=         SHORT_SIZE;\n+       }\n+\n+       if (version >= 80) {\n+           toBytes(useShortCompressFloat, rawBytes, offset);\n+           offset +=         BOOLEAN_SIZE;\n+       }\n+        return rawBytes;\n+    }\n+\n+\n+    private static final byte[] toBytes() {\n+        byte[] rawBytes = input0;\n+\n+        int offset = 0;\n+\n+        toBytes(valueType, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(numNulls, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(numRows, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(countDistinct, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(rawDataSize, rawBytes, offset);\n+        offset +=         LONG_SIZE;\n+\n+        toBytes(sum, rawBytes, offset);\n+        offset +=         LONG_SIZE;\n+\n+        if (version > 50) {\n+            System.arraycopy(maxValue, 0, rawBytes, offset, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+\n+            System.arraycopy(minValue, 0, rawBytes, offset, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+        } else {\n+            System.arraycopy(maxValue, 0, rawBytes, offset, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+\n+            System.arraycopy(minValue, 0, rawBytes, offset, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+        }\n+\n+        toBytes(dictOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dictLength, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(histOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(histLength, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dpnOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dpnCount, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        if (version >= 60) {\n+            toBytes(maxRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(minRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(totalRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(maxMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(minMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(totalMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+        }\n+\n+       if (version >= 65) {\n+           toBytes(toastOffset, rawBytes, offset);\n+           offset +=         LONG_SIZE;\n+           toBytes(hasToast, rawBytes, offset);\n+           offset +=         BOOLEAN_SIZE;\n+       }\n+\n+       if (version >= 70) {\n+          System.arraycopy(maxString, 0, rawBytes, offset, MAX_STRING_LENGTH);\n+          offset += MAX_STRING_LENGTH;\n+\n+          System.arraycopy(minString, 0, rawBytes, offset, MAX_STRING_LENGTH);\n+          offset += MAX_STRING_LENGTH;\n+\n+          toBytes(maxStringLength, rawBytes, offset);\n+          offset +=         INT_SIZE;\n+\n+          toBytes(minStringLength, rawBytes, offset);\n+          offset +=         INT_SIZE;\n+\n+          toBytes(maxStringIsNull, rawBytes, offset);\n+          offset +=         BOOLEAN_SIZE;\n+\n+          toBytes(minStringIsNull, rawBytes, offset);\n+          offset +=         BOOLEAN_SIZE;\n+       }\n+\n+       if (version >= 75) {\n+           toBytes(precision, rawBytes, offset);\n+           offset +=         SHORT_SIZE;\n+\n+           toBytes(scale, rawBytes, offset);\n+           offset +=         SHORT_SIZE;\n+       }\n+\n+       if (version >= 80) {\n+           toBytes(useShortCompressFloat, rawBytes, offset);\n+           offset +=         BOOLEAN_SIZE;\n+       }\n+        return rawBytes;\n+    }\n+\n+    private static final void fromBytes(byte[] rawBytes) throws Throwable {\n+        int offset = 0;\n+\n+        if (valueType != bytes2int(rawBytes, offset)) throw new RuntimeException(\"valueType does not match\");\n+        offset += INT_SIZE;\n+\n+        if (numNulls != bytes2int(rawBytes, offset)) throw new RuntimeException(\"numNulls does not match\");\n+        offset += INT_SIZE;\n+\n+        if (numRows != bytes2int(rawBytes, offset)) throw new RuntimeException(\"numRows does not match\");\n+        offset += INT_SIZE;\n+\n+        if (countDistinct != bytes2int(rawBytes, offset)) throw new RuntimeException(\"countDistinct does not match\");\n+        offset += INT_SIZE;\n+\n+        if (rawDataSize != bytes2long(rawBytes, offset)) throw new RuntimeException(\"rawDataSize does not match\");\n+        offset += LONG_SIZE;\n+\n+        if (sum != bytes2long(rawBytes, offset)) throw new RuntimeException(\"sum does not match\");\n+        offset += LONG_SIZE;\n+\n+        byte[] maxValue_ = new byte[MAX_VALUE_LENGTH];\n+        byte[] minValue_ = new byte[MAX_VALUE_LENGTH];\n+        if (version > 50) {\n+            System.arraycopy(rawBytes, offset, maxValue_, 0, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+            if (!Arrays.equals(maxValue, maxValue_)) throw new RuntimeException(\"maxValue does not match\");\n+\n+            System.arraycopy(rawBytes, offset, minValue_, 0, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+            if (!Arrays.equals(minValue, minValue_)) throw new RuntimeException(\"minValue does not match\");\n+        } else {\n+            System.arraycopy(rawBytes, offset, maxValue_, 0, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+            if (!Arrays.equals(maxValue, maxValue_)) throw new RuntimeException(\"maxValue does not match\");\n+\n+            System.arraycopy(rawBytes, offset, minValue_, 0, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+            if (!Arrays.equals(minValue, minValue_)) throw new RuntimeException(\"minValue does not match\");\n+        }\n+\n+        if (dictOffset != bytes2int(rawBytes, offset)) throw new RuntimeException(\"dictOffset does not match\");\n+        offset += INT_SIZE;\n+\n+        if (dictLength != bytes2int(rawBytes, offset)) throw new RuntimeException(\"dictLength does not match\");\n+        offset += INT_SIZE;\n+\n+        if (histOffset != bytes2int(rawBytes, offset)) throw new RuntimeException(\"histOffset does not match\");\n+        offset += INT_SIZE;\n+\n+        if (histLength != bytes2int(rawBytes, offset)) throw new RuntimeException(\"histLength does not match\");\n+        offset += INT_SIZE;\n+\n+        if (dpnOffset != bytes2int(rawBytes, offset)) throw new RuntimeException(\"dpnOffset does not match\");\n+        offset += INT_SIZE;\n+\n+        if (dpnCount != bytes2int(rawBytes, offset)) throw new RuntimeException(\"dpnCount does not match\");\n+        offset +=         INT_SIZE;\n+\n+        if (version >= 60) {\n+            if (maxRowCount != bytes2long(rawBytes, offset)) throw new RuntimeException(\"maxRowCount does not match\");\n+            offset += LONG_SIZE;\n+\n+            if (minRowCount != bytes2long(rawBytes, offset)) throw new RuntimeException(\"minRowCount does not match\");\n+            offset += LONG_SIZE;\n+\n+            if (totalRowCount != bytes2long(rawBytes, offset)) throw new RuntimeException(\"totalRowCount does not match\");\n+            offset += LONG_SIZE;\n+\n+            if (maxMemSize != bytes2long(rawBytes, offset)) throw new RuntimeException(\"maxMemSize does not match\");\n+            offset += LONG_SIZE;\n+\n+            if (minMemSize != bytes2long(rawBytes, offset)) throw new RuntimeException(\"minMemSize does not match\");\n+            offset += LONG_SIZE;\n+\n+            if (totalMemSize != bytes2long(rawBytes, offset)) throw new RuntimeException(\"totalMemSize does not match\");\n+            offset += LONG_SIZE;\n+        }\n+\n+        if (version >= 65) {\n+            if (toastOffset != bytes2long(rawBytes, offset)) throw new RuntimeException(\"toastOffset does not match\");\n+            offset += LONG_SIZE;\n+\n+            if (hasToast != bytes2boolen(rawBytes, offset)) throw new RuntimeException(\"hasToast does not match\");\n+            offset += BOOLEAN_SIZE;\n+        }\n+\n+        if (version >= 70) {\n+            byte[] maxString_ = new byte[MAX_STRING_LENGTH];\n+            System.arraycopy(rawBytes, offset, maxString_, 0, MAX_STRING_LENGTH);\n+            offset += MAX_STRING_LENGTH;\n+            if (!Arrays.equals(maxString, maxString_)) throw new RuntimeException(\"maxString does not match\");\n+\n+            byte[] minString_ = new byte[MAX_STRING_LENGTH];\n+            System.arraycopy(rawBytes, offset, minString_, 0, MAX_STRING_LENGTH);\n+            offset += MAX_STRING_LENGTH;\n+            if (!Arrays.equals(minString, minString_)) throw new RuntimeException(\"minString does not match\");\n+\n+            if (maxStringLength != bytes2int(rawBytes, offset)) throw new RuntimeException(\"maxStringLength does not match\");\n+            offset += INT_SIZE;\n+\n+            if (minStringLength != bytes2int(rawBytes, offset)) throw new RuntimeException(\"minStringLength does not match\");\n+            offset += INT_SIZE;\n+\n+            if (maxStringIsNull != bytes2boolen(rawBytes, offset)) throw new RuntimeException(\"maxStringIsNull does not match\");\n+            offset += BOOLEAN_SIZE;\n+\n+            if (minStringIsNull != bytes2boolen(rawBytes, offset)) throw new RuntimeException(\"minStringIsNull does not match\");\n+            offset += BOOLEAN_SIZE;\n+        }\n+\n+        if (version >= 75) {\n+            if (precision != bytes2short(rawBytes, offset)) throw new RuntimeException(\"precision does not match\");\n+            offset += SHORT_SIZE;\n+\n+            if (scale != bytes2short(rawBytes, offset)) throw new RuntimeException(\"scale does not match\");\n+            offset += SHORT_SIZE;\n+        }\n+\n+        if (version >= 80) {\n+            if (useShortCompressFloat != bytes2boolen(rawBytes, offset)) throw new RuntimeException(\"useShortCompressFloat does not match\");\n+            offset += BOOLEAN_SIZE;\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        long s = 0, s1 = 0;\n+        for (int i = 0; i < input0.length; i++) {\n+            input0[i] = 0;\n+            input1[i] = 0;\n+        }\n+        for (int i = 0; i < 100000; i++) {\n+            s += toBytes()[0];\n+            s1 += toBytesDup()[0];\n+            for (int j = 0; j < input0.length; j++) {\n+                if (input0[j] != input1[j]) {\n+                    throw new RuntimeException(\"not match!\");\n+                }\n+            }\n+            fromBytes(input0);\n+            fromBytes(input1);\n+        }\n+    }\n+}\n+\n+\n+\n+\n+\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/NonVolatileMemoryAccessWithLongOffset.java","additions":546,"deletions":0,"binary":false,"changes":546,"status":"added"}]}