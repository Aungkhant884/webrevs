{"files":[{"patch":"@@ -53,1 +53,1 @@\n- * gets the List of geduggee's threads calling VM.allThreads(),\n+ * gets the List of debuggee's threads calling VM.allThreads(),\n@@ -55,1 +55,1 @@\n- * gets another List of geduggee's threads.\n+ * gets another List of debuggee's threads.\n@@ -66,0 +66,7 @@\n+ * - The debugger informs the debuggee when it completes\n+ *   each test case, so it will wait before hitting\n+ *   communication breakpoints.\n+ *   This prevents the breakpoint SUSPEND_ALL policy\n+ *   disrupting the first test case check for\n+ *   SUSPEND_NONE, if the debuggee gets ahead of\n+ *   the debugger processing.\n@@ -236,0 +243,1 @@\n+                informDebuggeeTestCase(i);\n@@ -264,1 +272,18 @@\n-\n+    \/**\n+     * Inform debuggee which thread test the debugger has completed.\n+     * Used for synchronization, so the debuggee does not move too quickly.\n+     * @param testCase index of just completed test\n+     *\/\n+    void informDebuggeeTestCase(int testCase) {\n+        try {\n+            ((ClassType)debuggeeClass)\n+                .setValue(debuggeeClass.fieldByName(\"testCase\"),\n+                          vm.mirrorOf(testCase));\n+        } catch (InvalidTypeException ite) {\n+            throw new Failure(\"** FAILURE setting testCase  **\");\n+        } catch (ClassNotLoadedException cnle) {\n+            throw new Failure(\"** FAILURE notifying debuggee  **\");\n+        } catch (VMDisconnectedException e) {\n+            throw new Failure(\"** FAILURE debuggee connection **\");\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume001.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    \/\/----------------------------------------------------- templete section\n+    \/\/----------------------------------------------------- template section\n@@ -60,0 +60,1 @@\n+    static int testCase    = -1;\n@@ -103,0 +104,4 @@\n+                \/\/ Wait for debugger to complete the first test case\n+                \/\/ before advancing to the first breakpoint\n+                waitForTestCase(0);\n+\n@@ -122,0 +127,10 @@\n+    \/\/ Synchronize with debugger progression.\n+    static void waitForTestCase(int t) {\n+        while (testCase < t) {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                \/\/ ignored\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume001a.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * gets the List of geduggee's threads calling VM.allThreads(), <BR>\n+ * gets the List of debuggee's threads calling VM.allThreads(), <BR>\n@@ -53,1 +53,1 @@\n- * gets another List of geduggee's threads.                     <BR>\n+ * gets another List of debuggee's threads.                     <BR>\n@@ -90,1 +90,1 @@\n-    \/\/----------------------------------------------------- templete section\n+    \/\/----------------------------------------------------- template section\n@@ -95,1 +95,1 @@\n-    \/\/----------------------------------------------------- templete parameters\n+    \/\/----------------------------------------------------- template parameters\n@@ -506,0 +506,1 @@\n+            informDebuggeeTestCase(i);\n@@ -645,1 +646,18 @@\n-\n+    \/**\n+     * Inform debuggee which thread test the debugger has completed.\n+     * Used for synchronization, so the debuggee does not move too quickly.\n+     * @param testCase index of just completed test\n+     *\/\n+    void informDebuggeeTestCase(int testCase) {\n+        try {\n+            ((ClassType)debuggeeClass)\n+                .setValue(debuggeeClass.fieldByName(\"testCase\"),\n+                          vm.mirrorOf(testCase));\n+        } catch (InvalidTypeException ite) {\n+            throw new Failure(\"** FAILURE setting testCase  **\");\n+        } catch (ClassNotLoadedException cnle) {\n+            throw new Failure(\"** FAILURE notifying debuggee  **\");\n+        } catch (VMDisconnectedException e) {\n+            throw new Failure(\"** FAILURE debuggee connection **\");\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume002.java","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    \/\/----------------------------------------------------- templete section\n+    \/\/----------------------------------------------------- template section\n@@ -44,0 +44,1 @@\n+    static int testCase    = -1;\n@@ -101,2 +102,6 @@\n-                    case 0: resume002aTestClass.method();\n-                            break;\n+                    case 0:\n+                        resume002aTestClass.method();\n+                        \/\/ Wait for debugger to complete the first test case\n+                        \/\/ before advancing to the first breakpoint\n+                        waitForTestCase(0);\n+                        break;\n@@ -121,0 +126,11 @@\n+    \/\/ Synchronize with debugger progression.\n+    static void waitForTestCase(int t) {\n+        while (testCase < t) {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                \/\/ ignored\n+            }\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume002a.java","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * gets the List of geduggee's threads calling VM.allThreads(), <BR>\n+ * gets the List of debuggee's threads calling VM.allThreads(), <BR>\n@@ -53,1 +53,1 @@\n- * gets another List of geduggee's threads.                     <BR>\n+ * gets another List of debuggee's threads.                     <BR>\n@@ -90,1 +90,1 @@\n-    \/\/----------------------------------------------------- templete section\n+    \/\/----------------------------------------------------- template section\n@@ -95,1 +95,1 @@\n-    \/\/----------------------------------------------------- templete parameters\n+    \/\/----------------------------------------------------- template parameters\n@@ -506,0 +506,2 @@\n+            informDebuggeeTestCase(i);\n+\n@@ -645,1 +647,18 @@\n-\n+    \/**\n+     * Inform debuggee which thread test the debugger has completed.\n+     * Used for synchronization, so the debuggee does not move too quickly.\n+     * @param testCase index of just completed test\n+     *\/\n+    void informDebuggeeTestCase(int testCase) {\n+        try {\n+            ((ClassType)debuggeeClass)\n+                .setValue(debuggeeClass.fieldByName(\"testCase\"),\n+                          vm.mirrorOf(testCase));\n+        } catch (InvalidTypeException ite) {\n+            throw new Failure(\"** FAILURE setting testCase  **\");\n+        } catch (ClassNotLoadedException cnle) {\n+            throw new Failure(\"** FAILURE notifying debuggee  **\");\n+        } catch (VMDisconnectedException e) {\n+            throw new Failure(\"** FAILURE debuggee connection **\");\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume003.java","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-    \/\/----------------------------------------------------- templete section\n+    \/\/----------------------------------------------------- template section\n+    static int testCase    = -1;\n@@ -101,2 +102,6 @@\n-                    case 0: resume003aTestClass.method();\n-                            break;\n+                    case 0:\n+                        resume003aTestClass.method();\n+                        \/\/ Wait for debugger to complete the first test case\n+                        \/\/ before advancing to the first breakpoint\n+                        waitForTestCase(0);\n+                        break;\n@@ -121,0 +126,10 @@\n+    \/\/ Synchronize with debugger progression.\n+    static void waitForTestCase(int t) {\n+        while (testCase < t) {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                \/\/ ignored\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume003a.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * gets the List of geduggee's threads calling VM.allThreads(), <BR>\n+ * gets the List of debuggee's threads calling VM.allThreads(), <BR>\n@@ -53,1 +53,1 @@\n- * gets another List of geduggee's threads.                     <BR>\n+ * gets another List of debuggee's threads.                     <BR>\n@@ -90,1 +90,1 @@\n-    \/\/----------------------------------------------------- templete section\n+    \/\/----------------------------------------------------- template section\n@@ -95,1 +95,1 @@\n-    \/\/----------------------------------------------------- templete parameters\n+    \/\/----------------------------------------------------- template parameters\n@@ -496,0 +496,1 @@\n+                informDebuggeeTestCase(i);\n@@ -641,1 +642,18 @@\n-\n+    \/**\n+     * Inform debuggee which thread test the debugger has completed.\n+     * Used for synchronization, so the debuggee does not move too quickly.\n+     * @param testCase index of just completed test\n+     *\/\n+    void informDebuggeeTestCase(int testCase) {\n+        try {\n+            ((ClassType)debuggeeClass)\n+                .setValue(debuggeeClass.fieldByName(\"testCase\"),\n+                          vm.mirrorOf(testCase));\n+        } catch (InvalidTypeException ite) {\n+            throw new Failure(\"** FAILURE setting testCase  **\");\n+        } catch (ClassNotLoadedException cnle) {\n+            throw new Failure(\"** FAILURE notifying debuggee  **\");\n+        } catch (VMDisconnectedException e) {\n+            throw new Failure(\"** FAILURE debuggee connection **\");\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume004.java","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-    \/\/----------------------------------------------------- templete section\n+    \/\/----------------------------------------------------- template section\n+    static int testCase    = -1;\n@@ -101,2 +102,4 @@\n-                    case 0: resume004aTestClass.method();\n-                            break;\n+                    case 0:\n+                        resume004aTestClass.method();\n+                        waitForTestCase(0);\n+                        break;\n@@ -121,0 +124,10 @@\n+    \/\/ Synchronize with debugger progression.\n+    static void waitForTestCase(int t) {\n+        while (testCase < t) {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                \/\/ ignored\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume004a.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * gets the List of geduggee's threads calling VM.allThreads(), <BR>\n+ * gets the List of debuggee's threads calling VM.allThreads(), <BR>\n@@ -53,1 +53,1 @@\n- * gets another List of geduggee's threads.                     <BR>\n+ * gets another List of debuggee's threads.                     <BR>\n@@ -90,1 +90,1 @@\n-    \/\/----------------------------------------------------- templete section\n+    \/\/----------------------------------------------------- template section\n@@ -95,1 +95,1 @@\n-    \/\/----------------------------------------------------- templete parameters\n+    \/\/----------------------------------------------------- template parameters\n@@ -496,0 +496,1 @@\n+                informDebuggeeTestCase(i);\n@@ -637,1 +638,18 @@\n-\n+    \/**\n+     * Inform debuggee which thread test the debugger has completed.\n+     * Used for synchronization, so the debuggee does not move too quickly.\n+     * @param testCase index of just completed test\n+     *\/\n+    void informDebuggeeTestCase(int testCase) {\n+        try {\n+            ((ClassType)debuggeeClass)\n+                .setValue(debuggeeClass.fieldByName(\"testCase\"),\n+                          vm.mirrorOf(testCase));\n+        } catch (InvalidTypeException ite) {\n+            throw new Failure(\"** FAILURE setting testCase  **\");\n+        } catch (ClassNotLoadedException cnle) {\n+            throw new Failure(\"** FAILURE notifying debuggee  **\");\n+        } catch (VMDisconnectedException e) {\n+            throw new Failure(\"** FAILURE debuggee connection **\");\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume005.java","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-    \/\/----------------------------------------------------- templete section\n+    \/\/----------------------------------------------------- template section\n+    static int testCase    = -1;\n@@ -101,2 +102,4 @@\n-                    case 0: resume005aTestClass.method();\n-                            break;\n+                    case 0:\n+                        resume005aTestClass.method();\n+                        waitForTestCase(0);\n+                        break;\n@@ -125,1 +128,10 @@\n-\n+    \/\/ Synchronize with debugger progression.\n+    static void waitForTestCase(int t) {\n+        while (testCase < t) {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                \/\/ ignored\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume005a.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * gets the List of geduggee's threads calling VM.allThreads(), <BR>\n+ * gets the List of debuggee's threads calling VM.allThreads(), <BR>\n@@ -53,1 +53,1 @@\n- * gets another List of geduggee's threads.                     <BR>\n+ * gets another List of debuggee's threads.                     <BR>\n@@ -90,1 +90,1 @@\n-    \/\/----------------------------------------------------- templete section\n+    \/\/----------------------------------------------------- template section\n@@ -95,1 +95,1 @@\n-    \/\/----------------------------------------------------- templete parameters\n+    \/\/----------------------------------------------------- template parameters\n@@ -498,0 +498,1 @@\n+            informDebuggeeTestCase(i);\n@@ -635,1 +636,18 @@\n-\n+    \/**\n+     * Inform debuggee which thread test the debugger has completed.\n+     * Used for synchronization, so the debuggee does not move too quickly.\n+     * @param testCase index of just completed test\n+     *\/\n+    void informDebuggeeTestCase(int testCase) {\n+        try {\n+            ((ClassType)debuggeeClass)\n+                .setValue(debuggeeClass.fieldByName(\"testCase\"),\n+                          vm.mirrorOf(testCase));\n+        } catch (InvalidTypeException ite) {\n+            throw new Failure(\"** FAILURE setting testCase  **\");\n+        } catch (ClassNotLoadedException cnle) {\n+            throw new Failure(\"** FAILURE notifying debuggee  **\");\n+        } catch (VMDisconnectedException e) {\n+            throw new Failure(\"** FAILURE debuggee connection **\");\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume006.java","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    \/\/----------------------------------------------------- templete section\n+    \/\/----------------------------------------------------- template section\n@@ -44,0 +44,1 @@\n+    static int testCase    = -1;\n@@ -101,2 +102,6 @@\n-                    case 0: resume006aTestClass.method();\n-                            break;\n+                    case 0:\n+                        resume006aTestClass.method();\n+                        \/\/ Wait for debugger to complete the first test case\n+                        \/\/ before advancing to the next breakpoint\n+                        waitForTestCase(0);\n+                        break;\n@@ -121,1 +126,10 @@\n-\n+    \/\/ Synchronize with debugger progression.\n+    static void waitForTestCase(int t) {\n+        while (testCase < t) {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                \/\/ ignored\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume006a.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * gets the List of geduggee's threads calling VM.allThreads(), <BR>\n+ * gets the List of debuggee's threads calling VM.allThreads(), <BR>\n@@ -53,1 +53,1 @@\n- * gets another List of geduggee's threads.                     <BR>\n+ * gets another List of debuggee's threads.                     <BR>\n@@ -90,1 +90,1 @@\n-    \/\/----------------------------------------------------- templete section\n+    \/\/----------------------------------------------------- template section\n@@ -95,1 +95,1 @@\n-    \/\/----------------------------------------------------- templete parameters\n+    \/\/----------------------------------------------------- template parameters\n@@ -493,0 +493,1 @@\n+                informDebuggeeTestCase(i);\n@@ -634,1 +635,18 @@\n-\n+    \/**\n+     * Inform debuggee which thread test the debugger has completed.\n+     * Used for synchronization, so the debuggee does not move too quickly.\n+     * @param testCase index of just completed test\n+     *\/\n+    void informDebuggeeTestCase(int testCase) {\n+        try {\n+            ((ClassType)debuggeeClass)\n+                .setValue(debuggeeClass.fieldByName(\"testCase\"),\n+                          vm.mirrorOf(testCase));\n+        } catch (InvalidTypeException ite) {\n+            throw new Failure(\"** FAILURE setting testCase  **\");\n+        } catch (ClassNotLoadedException cnle) {\n+            throw new Failure(\"** FAILURE notifying debuggee  **\");\n+        } catch (VMDisconnectedException e) {\n+            throw new Failure(\"** FAILURE debuggee connection **\");\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume007.java","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-    \/\/----------------------------------------------------- templete section\n+    \/\/----------------------------------------------------- template section\n+    static int testCase    = -1;\n@@ -101,2 +102,4 @@\n-                    case 0: resume007aTestClass.method();\n-                            break;\n+                    case 0:\n+                        resume007aTestClass.method();\n+                        waitForTestCase(0);\n+                        break;\n@@ -121,1 +124,10 @@\n-\n+    \/\/ Synchronize with debugger progression.\n+    static void waitForTestCase(int t) {\n+        while (testCase < t) {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                \/\/ ignored\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume007a.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * gets the List of geduggee's threads calling VM.allThreads(),\n+ * gets the List of debuggee's threads calling VM.allThreads(),\n@@ -55,1 +55,1 @@\n- * gets another List of geduggee's threads.\n+ * gets another List of debuggee's threads.\n@@ -66,0 +66,7 @@\n+ * - The debugger informs the debuggee when it completes\n+ *   each test case, so it will wait before hitting\n+ *   communication breakpoints.\n+ *   This prevents the breakpoint SUSPEND_ALL policy\n+ *   disrupting the first test case check for\n+ *   SUSPEND_NONE, if the debuggee gets ahead of\n+ *   the debugger processing.\n@@ -127,1 +134,3 @@\n-            EventSet eventSet = eventHandler.waitForRequestedEventSet(new EventRequest[]{eventRequest}, waitTime, true);\n+            EventSet eventSet = eventHandler\n+                .waitForRequestedEventSet(new EventRequest[]{eventRequest},\n+                                          waitTime, true);\n@@ -137,1 +146,2 @@\n-                display(\"       got new ThreadStartEvent with propety 'number' == \" + property);\n+                display(\"       got new ThreadStartEvent with propety 'number' == \"\n+                        + property);\n@@ -147,1 +157,2 @@\n-                    suspendsCounts1.put(threadReference.name(), threadReference.suspendCount());\n+                    suspendsCounts1.put(threadReference.name(),\n+                                        threadReference.suspendCount());\n@@ -157,1 +168,2 @@\n-                    suspendsCounts2.put(threadReference.name(), threadReference.suspendCount());\n+                    suspendsCounts2.put(threadReference.name(),\n+                                        threadReference.suspendCount());\n@@ -166,66 +178,9 @@\n-                  case SUSPEND_NONE   :\n-                       display(\"        case SUSPEND_NONE\");\n-                       for (String threadName : suspendsCounts1.keySet()) {\n-                           display(\"        checking \" + threadName);\n-                           if (!suspendsCounts2.containsKey(threadName)) {\n-                               complain(\"ERROR: couldn't get ThreadReference for \" + threadName);\n-                               testExitCode = TEST_FAILED;\n-                               break;\n-                           }\n-                           int count1 = suspendsCounts1.get(threadName);\n-                           int count2 = suspendsCounts2.get(threadName);\n-                           if (count1 != count2) {\n-                               complain(\"ERROR: suspendCounts don't match for : \" + threadName);\n-                               complain(\"before resuming : \" + count1);\n-                               complain(\"after  resuming : \" + count2);\n-                               testExitCode = TEST_FAILED;\n-                               break;\n-                           }\n-                       }\n-                       break;\n-\n-                  case SUSPEND_THREAD :\n-                       display(\"        case SUSPEND_THREAD\");\n-                       for (String threadName : suspendsCounts1.keySet()) {\n-                           display(\"checking \" + threadName);\n-                           if (!suspendsCounts2.containsKey(threadName)) {\n-                               complain(\"ERROR: couldn't get ThreadReference for \" + threadName);\n-                               testExitCode = TEST_FAILED;\n-                               break;\n-                           }\n-                           int count1 = suspendsCounts1.get(threadName);\n-                           int count2 = suspendsCounts2.get(threadName);\n-                           String eventThreadName = ((ThreadStartEvent)newEvent).thread().name();\n-                           int expectedValue = count2 + (eventThreadName.equals(threadName) ? 1 : 0);\n-                           if (count1 != expectedValue) {\n-                               complain(\"ERROR: suspendCounts don't match for : \" + threadName);\n-                               complain(\"before resuming : \" + count1);\n-                               complain(\"after  resuming : \" + count2);\n-                               testExitCode = TEST_FAILED;\n-                               break;\n-                           }\n-                       }\n-                       break;\n-\n-                    case SUSPEND_ALL    :\n-\n-                        display(\"        case SUSPEND_ALL\");\n-                        for (String threadName : suspendsCounts1.keySet()) {\n-                            display(\"checking \" + threadName);\n-\n-                            if (!newEvent.request().equals(eventRequest))\n-                                break;\n-                            if (!suspendsCounts2.containsKey(threadName)) {\n-                                complain(\"ERROR: couldn't get ThreadReference for \" + threadName);\n-                                testExitCode = TEST_FAILED;\n-                                break;\n-                            }\n-                            int count1 = suspendsCounts1.get(threadName);\n-                            int count2 = suspendsCounts2.get(threadName);\n-                            if (count1 != count2 + 1) {\n-                                complain(\"ERROR: suspendCounts don't match for : \" + threadName);\n-                                complain(\"before resuming : \" + count1);\n-                                complain(\"after  resuming : \" + count2);\n-                                testExitCode = TEST_FAILED;\n-                                break;\n-                            }\n+                case SUSPEND_NONE   :\n+                    display(\"        case SUSPEND_NONE\");\n+                    for (String threadName : suspendsCounts1.keySet()) {\n+                        display(\"        checking \" + threadName);\n+                        if (!suspendsCounts2.containsKey(threadName)) {\n+                            complain(\"ERROR: couldn't get ThreadReference for \"\n+                                     + threadName);\n+                            testExitCode = TEST_FAILED;\n+                            break;\n@@ -233,3 +188,65 @@\n-                        break;\n-\n-                     default: throw new Failure(\"** default case 1 **\");\n+                        int count1 = suspendsCounts1.get(threadName);\n+                        int count2 = suspendsCounts2.get(threadName);\n+                        if (count1 != count2) {\n+                            complain(\"ERROR: suspendCounts don't match for : \"\n+                                     + threadName);\n+                            complain(\"before resuming : \" + count1);\n+                            complain(\"after  resuming : \" + count2);\n+                            testExitCode = TEST_FAILED;\n+                            break;\n+                        }\n+                    }\n+                    break;\n+\n+                case SUSPEND_THREAD :\n+                    display(\"        case SUSPEND_THREAD\");\n+                    for (String threadName : suspendsCounts1.keySet()) {\n+                        display(\"checking \" + threadName);\n+                        if (!suspendsCounts2.containsKey(threadName)) {\n+                            complain(\"ERROR: couldn't get ThreadReference for \"\n+                                     + threadName);\n+                            testExitCode = TEST_FAILED;\n+                            break;\n+                        }\n+                        int count1 = suspendsCounts1.get(threadName);\n+                        int count2 = suspendsCounts2.get(threadName);\n+                        String eventThreadName = ((ThreadStartEvent)newEvent)\n+                            .thread().name();\n+                        int expectedValue = count2 +\n+                            (eventThreadName.equals(threadName) ? 1 : 0);\n+                        if (count1 != expectedValue) {\n+                            complain(\"ERROR: suspendCounts don't match for : \"\n+                                     + threadName);\n+                            complain(\"before resuming : \" + count1);\n+                            complain(\"after  resuming : \" + count2);\n+                            testExitCode = TEST_FAILED;\n+                            break;\n+                        }\n+                    }\n+                    break;\n+\n+                case SUSPEND_ALL    :\n+                    display(\"        case SUSPEND_ALL\");\n+                    for (String threadName : suspendsCounts1.keySet()) {\n+                        display(\"checking \" + threadName);\n+                        if (!newEvent.request().equals(eventRequest))\n+                            break;\n+                        if (!suspendsCounts2.containsKey(threadName)) {\n+                            complain(\"ERROR: couldn't get ThreadReference for \"\n+                                     + threadName);\n+                            testExitCode = TEST_FAILED;\n+                            break;\n+                        }\n+                        int count1 = suspendsCounts1.get(threadName);\n+                        int count2 = suspendsCounts2.get(threadName);\n+                        if (count1 != count2 + 1) {\n+                            complain(\"ERROR: suspendCounts don't match for : \"\n+                                     + threadName);\n+                            complain(\"before resuming : \" + count1);\n+                            complain(\"after  resuming : \" + count2);\n+                            testExitCode = TEST_FAILED;\n+                            break;\n+                        }\n+                    }\n+                    break;\n+                default: throw new Failure(\"** default case 1 **\");\n@@ -237,1 +254,1 @@\n-            }\n+                informDebuggeeTestCase(i);\n@@ -239,0 +256,1 @@\n+            }\n@@ -244,1 +262,0 @@\n-\n@@ -257,1 +274,18 @@\n-\n+    \/**\n+     * Inform debuggee which thread test the debugger has completed.\n+     * Used for synchronization, so the debuggee does not move too quickly.\n+     * @param testCase index of just completed test\n+     *\/\n+    void informDebuggeeTestCase(int testCase) {\n+        try {\n+            ((ClassType)debuggeeClass)\n+                .setValue(debuggeeClass.fieldByName(\"testCase\"),\n+                          vm.mirrorOf(testCase));\n+        } catch (InvalidTypeException ite) {\n+            throw new Failure(\"** FAILURE setting testCase  **\");\n+        } catch (ClassNotLoadedException cnle) {\n+            throw new Failure(\"** FAILURE notifying debuggee  **\");\n+        } catch (VMDisconnectedException e) {\n+            throw new Failure(\"** FAILURE debuggee connection **\");\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume008.java","additions":112,"deletions":78,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    \/\/----------------------------------------------------- templete section\n+    \/\/----------------------------------------------------- template section\n@@ -65,0 +65,1 @@\n+    static int testCase    = -1;\n@@ -73,0 +74,1 @@\n+    \/\/ Debugger sets a breakpoint here to track debuggee\n@@ -88,10 +90,7 @@\n-            for (int i = 0; ; i++) {\n-\n-                if (instruction > maxInstr) {\n-                    logErr(\"ERROR: unexpected instruction: \" + instruction);\n-                    exitCode = FAILED;\n-                    break ;\n-                }\n-\n-                switch (i) {\n-\n+        for (int i = 0; ; i++) {\n+            if (instruction > maxInstr) {\n+                logErr(\"ERROR: unexpected instruction: \" + instruction);\n+                exitCode = FAILED;\n+                break ;\n+            }\n+            switch (i) {\n@@ -99,28 +98,22 @@\n-\n-                    case 0:\n-                            thread0 = new Threadresume008a(\"thread0\");\n-                            methodForCommunication();\n-\n-                            threadStart(thread0);\n-\n-                            thread1 = new Threadresume008a(\"thread1\");\n-                            methodForCommunication();\n-                            break;\n-\n-                    case 1:\n-                            threadStart(thread1);\n-\n-                            thread2 = new Threadresume008a(\"thread2\");\n-                            methodForCommunication();\n-                            break;\n-\n-                    case 2:\n-                            threadStart(thread2);\n-\n-    \/\/-------------------------------------------------    standard end section\n-\n-                    default:\n-                                instruction = end;\n-                                methodForCommunication();\n-                                break label0;\n-                }\n+            case 0:\n+                thread0 = new Threadresume008a(\"thread0\");\n+                methodForCommunication();\n+                threadStart(thread0);\n+                thread1 = new Threadresume008a(\"thread1\");\n+                \/\/ Wait for debugger to complete the first test case\n+                \/\/ before advancing to the first breakpoint\n+                waitForTestCase(0);\n+                methodForCommunication();\n+                break;\n+            case 1:\n+                threadStart(thread1);\n+                thread2 = new Threadresume008a(\"thread2\");\n+                methodForCommunication();\n+                break;\n+            case 2:\n+                threadStart(thread2);\n+            \/\/-------------------------------------------------    standard end section\n+            default:\n+                instruction = end;\n+                methodForCommunication();\n+                break label0;\n@@ -128,1 +121,1 @@\n-\n+        }\n@@ -148,1 +141,10 @@\n-\n+    \/\/ Synchronize with debugger progression.\n+    static void waitForTestCase(int t) {\n+        while (testCase < t) {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                \/\/ ignored\n+            }\n+        }\n+    }\n@@ -150,1 +152,0 @@\n-\n@@ -152,1 +153,0 @@\n-\n@@ -157,1 +157,0 @@\n-\n@@ -161,1 +160,1 @@\n-                    waitnotifyObj.notify();\n+                waitnotifyObj.notify();\n@@ -167,1 +166,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume008a.java","additions":44,"deletions":46,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n- * gets the List of geduggee's threads calling VM.allThreads(),\n+ * gets the List of debuggee's threads calling VM.allThreads(),\n@@ -55,1 +55,1 @@\n- * gets another List of geduggee's threads.\n+ * gets another List of debuggee's threads.\n@@ -66,0 +66,7 @@\n+ * - The debugger informs the debuggee when it completes\n+ *   each test case, so it will wait before hitting\n+ *   communication breakpoints.\n+ *   This prevents the breakpoint SUSPEND_ALL policy\n+ *   disrupting the first test case check for\n+ *   SUSPEND_NONE, if the debuggee gets ahead of\n+ *   the debugger processing.\n@@ -236,0 +243,1 @@\n+                informDebuggeeTestCase(i);\n@@ -256,1 +264,18 @@\n-\n+    \/**\n+     * Inform debuggee which thread test the debugger has completed.\n+     * Used for synchronization, so the debuggee does not move too quickly.\n+     * @param testCase index of just completed test\n+     *\/\n+    void informDebuggeeTestCase(int testCase) {\n+        try {\n+            ((ClassType)debuggeeClass)\n+                .setValue(debuggeeClass.fieldByName(\"testCase\"),\n+                          vm.mirrorOf(testCase));\n+        } catch (InvalidTypeException ite) {\n+            throw new Failure(\"** FAILURE setting testCase  **\");\n+        } catch (ClassNotLoadedException cnle) {\n+            throw new Failure(\"** FAILURE notifying debuggee  **\");\n+        } catch (VMDisconnectedException e) {\n+            throw new Failure(\"** FAILURE debuggee connection **\");\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume009.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    \/\/----------------------------------------------------- templete section\n+    \/\/----------------------------------------------------- template section\n@@ -65,0 +65,1 @@\n+    static int testCase    = -1;\n@@ -107,0 +108,3 @@\n+                            \/\/ Wait for debugger to complete the first test case\n+                            \/\/ before advancing to the first breakpoint\n+                            waitForTestCase(0);\n@@ -155,0 +159,10 @@\n+    \/\/ Synchronize with debugger progression.\n+    static void waitForTestCase(int t) {\n+        while (testCase < t) {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                \/\/ ignored\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume009a.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * gets the List of geduggee's threads calling VM.allThreads(), <BR>\n+ * gets the List of debuggee's threads calling VM.allThreads(), <BR>\n@@ -53,1 +53,1 @@\n- * gets another List of geduggee's threads.                     <BR>\n+ * gets another List of debuggee's threads.                     <BR>\n@@ -90,1 +90,1 @@\n-    \/\/----------------------------------------------------- templete section\n+    \/\/----------------------------------------------------- template section\n@@ -95,1 +95,1 @@\n-    \/\/----------------------------------------------------- templete parameters\n+    \/\/----------------------------------------------------- template parameters\n@@ -491,0 +491,1 @@\n+                informDebuggeeTestCase(i);\n@@ -630,1 +631,18 @@\n-\n+    \/**\n+     * Inform debuggee which thread test the debugger has completed.\n+     * Used for synchronization, so the debuggee does not move too quickly.\n+     * @param testCase index of just completed test\n+     *\/\n+    void informDebuggeeTestCase(int testCase) {\n+        try {\n+            ((ClassType)debuggeeClass)\n+                .setValue(debuggeeClass.fieldByName(\"testCase\"),\n+                          vm.mirrorOf(testCase));\n+        } catch (InvalidTypeException ite) {\n+            throw new Failure(\"** FAILURE setting testCase  **\");\n+        } catch (ClassNotLoadedException cnle) {\n+            throw new Failure(\"** FAILURE notifying debuggee  **\");\n+        } catch (VMDisconnectedException e) {\n+            throw new Failure(\"** FAILURE debuggee connection **\");\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume010.java","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    \/\/----------------------------------------------------- templete section\n+    \/\/----------------------------------------------------- template section\n@@ -63,0 +63,1 @@\n+    static int testCase    = -1;\n@@ -101,2 +102,6 @@\n-                    case 0: resume010aTestClass.method();\n-                            break;\n+                    case 0:\n+                        resume010aTestClass.method();\n+                        \/\/ Wait for debugger to complete the first test case\n+                        \/\/ before advancing to the first breakpoint\n+                        waitForTestCase(0);\n+                        break;\n@@ -120,1 +125,10 @@\n-\n+    \/\/ Synchronize with debugger progression.\n+    static void waitForTestCase(int t) {\n+        while (testCase < t) {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                \/\/ ignored\n+            }\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventSet\/resume\/resume010a.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"}]}