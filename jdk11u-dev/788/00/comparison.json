{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.io.InputStream;\n@@ -33,0 +32,1 @@\n+import java.net.URLEncoder;\n@@ -40,1 +40,1 @@\n-import java.util.Arrays;\n+import java.util.Base64;\n@@ -48,0 +48,1 @@\n+import sun.security.util.IOUtils;\n@@ -57,0 +58,2 @@\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n@@ -226,0 +229,1 @@\n+        String responder = responderURI.toString();\n@@ -227,3 +231,3 @@\n-        InputStream in = null;\n-        OutputStream out = null;\n-        byte[] response = null;\n+        if (debug != null) {\n+            debug.println(\"connecting to OCSP service at: \" + responder);\n+        }\n@@ -231,0 +235,2 @@\n+        URL url;\n+        HttpURLConnection con = null;\n@@ -232,3 +238,28 @@\n-            URL url = responderURI.toURL();\n-            if (debug != null) {\n-                debug.println(\"connecting to OCSP service at: \" + url);\n+            StringBuilder encodedGetReq = new StringBuilder(responder);\n+            if (!responder.endsWith(\"\/\")) {\n+                encodedGetReq.append(\"\/\");\n+            }\n+            encodedGetReq.append(URLEncoder.encode(\n+                    Base64.getEncoder().encodeToString(bytes), UTF_8));\n+\n+            if (encodedGetReq.length() <= 255) {\n+                url = new URL(encodedGetReq.toString());\n+                con = (HttpURLConnection)url.openConnection();\n+                con.setDoOutput(true);\n+                con.setDoInput(true);\n+                con.setRequestMethod(\"GET\");\n+            } else {\n+                url = responderURI.toURL();\n+                con = (HttpURLConnection)url.openConnection();\n+                con.setConnectTimeout(CONNECT_TIMEOUT);\n+                con.setReadTimeout(CONNECT_TIMEOUT);\n+                con.setDoOutput(true);\n+                con.setDoInput(true);\n+                con.setRequestMethod(\"POST\");\n+                con.setRequestProperty\n+                    (\"Content-type\", \"application\/ocsp-request\");\n+                con.setRequestProperty\n+                    (\"Content-length\", String.valueOf(bytes.length));\n+                OutputStream out = con.getOutputStream();\n+                out.write(bytes);\n+                out.flush();\n@@ -236,13 +267,1 @@\n-            HttpURLConnection con = (HttpURLConnection)url.openConnection();\n-            con.setConnectTimeout(CONNECT_TIMEOUT);\n-            con.setReadTimeout(CONNECT_TIMEOUT);\n-            con.setDoOutput(true);\n-            con.setDoInput(true);\n-            con.setRequestMethod(\"POST\");\n-            con.setRequestProperty\n-                (\"Content-type\", \"application\/ocsp-request\");\n-            con.setRequestProperty\n-                (\"Content-length\", String.valueOf(bytes.length));\n-            out = con.getOutputStream();\n-            out.write(bytes);\n-            out.flush();\n+\n@@ -255,1 +274,1 @@\n-            in = con.getInputStream();\n+\n@@ -260,6 +279,0 @@\n-            response = new byte[contentLength > 2048 ? 2048 : contentLength];\n-            int total = 0;\n-            while (total < contentLength) {\n-                int count = in.read(response, total, response.length - total);\n-                if (count < 0)\n-                    break;\n@@ -267,6 +280,2 @@\n-                total += count;\n-                if (total >= response.length && total < contentLength) {\n-                    response = Arrays.copyOf(response, total * 2);\n-                }\n-            }\n-            response = Arrays.copyOf(response, total);\n+            return IOUtils.readExactlyNBytes(con.getInputStream(),\n+                    contentLength);\n@@ -274,13 +283,2 @@\n-            if (in != null) {\n-                try {\n-                    in.close();\n-                } catch (IOException ioe) {\n-                    throw ioe;\n-                }\n-            }\n-            if (out != null) {\n-                try {\n-                    out.close();\n-                } catch (IOException ioe) {\n-                    throw ioe;\n-                }\n+            if (con != null) {\n+                con.disconnect();\n@@ -289,1 +287,0 @@\n-        return response;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/OCSP.java","additions":46,"deletions":49,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -643,1 +643,4 @@\n-            respSignature.initVerify(cert.getPublicKey());\n+            SignatureUtil.initVerifyWithParam(respSignature,\n+                    cert.getPublicKey(),\n+                    SignatureUtil.getParamSpec(sigAlgId.getName(),\n+                            sigAlgId.getEncodedParams()));\n@@ -659,2 +662,2 @@\n-        } catch (InvalidKeyException | NoSuchAlgorithmException |\n-                 SignatureException e)\n+        } catch (InvalidAlgorithmParameterException | InvalidKeyException\n+                | NoSuchAlgorithmException | SignatureException e)\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/OCSPResponse.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import sun.security.x509.AlgorithmId;\n@@ -148,2 +149,1 @@\n-            throws ProviderException, InvalidAlgorithmParameterException,\n-            InvalidKeyException {\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n@@ -158,2 +158,1 @@\n-            throws ProviderException, InvalidAlgorithmParameterException,\n-            InvalidKeyException {\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n@@ -167,2 +166,1 @@\n-            throws ProviderException, InvalidAlgorithmParameterException,\n-            InvalidKeyException {\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n@@ -171,0 +169,76 @@\n+\n+    \/**\n+     * Create a Signature that has been initialized with proper key and params.\n+     *\n+     * @param sigAlg signature algorithms\n+     * @param key private key\n+     * @param provider (optional) provider\n+     *\/\n+    public static Signature fromKey(String sigAlg, PrivateKey key, String provider)\n+        throws NoSuchAlgorithmException, NoSuchProviderException,\n+        InvalidKeyException{\n+        Signature sigEngine = (provider == null || provider.isEmpty())\n+            ? Signature.getInstance(sigAlg)\n+            : Signature.getInstance(sigAlg, provider);\n+        return autoInitInternal(sigAlg, key, sigEngine);\n+    }\n+\n+    \/**\n+     * Create a Signature that has been initialized with proper key and params.\n+     *\n+     * @param sigAlg signature algorithms\n+     * @param key private key\n+     * @param provider (optional) provider\n+     *\/\n+    public static Signature fromKey(String sigAlg, PrivateKey key, Provider provider)\n+            throws NoSuchAlgorithmException, InvalidKeyException{\n+        Signature sigEngine = (provider == null)\n+                ? Signature.getInstance(sigAlg)\n+                : Signature.getInstance(sigAlg, provider);\n+        return autoInitInternal(sigAlg, key, sigEngine);\n+    }\n+\n+    private static Signature autoInitInternal(String alg, PrivateKey key, Signature s)\n+        throws InvalidKeyException {\n+        AlgorithmParameterSpec params = AlgorithmId\n+                .getDefaultAlgorithmParameterSpec(alg, key);\n+        try {\n+            SignatureUtil.initSignWithParam(s, key, params, null);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new AssertionError(\"Should not happen\", e);\n+        }\n+        return s;\n+    }\n+\n+    \/**\n+     * Derives AlgorithmId from a signature object and a key.\n+     * @param sigEngine the signature object\n+     * @param key the private key\n+     * @return the AlgorithmId, not null\n+     * @throws SignatureException if cannot find one\n+     *\/\n+    public static AlgorithmId fromSignature(Signature sigEngine, PrivateKey key)\n+        throws SignatureException {\n+        try {\n+            AlgorithmParameters params = null;\n+            try {\n+                params = sigEngine.getParameters();\n+            } catch (UnsupportedOperationException e) {\n+                \/\/ some provider does not support it\n+            }\n+            if (params != null) {\n+                return AlgorithmId.get(sigEngine.getParameters());\n+            } else {\n+                String sigAlg = sigEngine.getAlgorithm();\n+                if (sigAlg.equalsIgnoreCase(\"EdDSA\")) {\n+                    \/\/ Hopefully key knows if it's Ed25519 or Ed448\n+                    sigAlg = key.getAlgorithm();\n+                }\n+                return AlgorithmId.get(sigAlg);\n+            }\n+        } catch (NoSuchAlgorithmException e) {\n+            \/\/ This could happen if both sig alg and key alg is EdDSA,\n+            \/\/ we don't know which provider does this.\n+            throw new SignatureException(\"Cannot derive AlgorithmIdentifier\", e);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureUtil.java","additions":81,"deletions":7,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-    public byte[] getEncodedParams() throws IOException {\n+    public byte[] getEncodedParams() {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -842,7 +842,1 @@\n-        if (sigAlgId == null)\n-            return null;\n-        try {\n-            return sigAlgId.getEncodedParams();\n-        } catch (IOException e) {\n-            return null;\n-        }\n+        return sigAlgId == null ? null : sigAlgId.getEncodedParams();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CRLImpl.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1087,7 +1087,1 @@\n-        if (algId == null)\n-            return null;\n-        try {\n-            return algId.getEncodedParams();\n-        } catch (IOException e) {\n-            return null;\n-        }\n+        return algId == null ? null : algId.getEncodedParams();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CertImpl.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,264 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8179503\n+ * @summary Java should support GET OCSP calls\n+ * @library \/javax\/net\/ssl\/templates \/java\/security\/testlibrary\n+ * @build SimpleOCSPServer\n+ * @modules java.base\/sun.security.util\n+ *          java.base\/sun.security.provider.certpath\n+ *          java.base\/sun.security.x509\n+ * @run main\/othervm GetAndPostTests\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyFactory;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.SecureRandom;\n+import java.security.cert.CertPath;\n+import java.security.cert.CertPathValidator;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.Extension;\n+import java.security.cert.PKIXCertPathChecker;\n+import java.security.cert.PKIXParameters;\n+import java.security.cert.PKIXRevocationChecker;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import sun.security.testlibrary.SimpleOCSPServer;\n+import sun.security.testlibrary.SimpleOCSPServer;\n+import sun.security.testlibrary.SimpleOCSPServer;\n+import sun.security.util.DerOutputStream;\n+import sun.security.util.DerValue;\n+import sun.security.util.ObjectIdentifier;\n+import sun.security.testlibrary.SimpleOCSPServer;\n+\n+public class GetAndPostTests {\n+    private static final String PASS = \"passphrase\";\n+    private static CertificateFactory certFac;\n+\n+    public static void main(String args[]) throws Exception {\n+        SimpleOCSPServer ocspResponder = null;\n+\n+        try {\n+            certFac = CertificateFactory.getInstance(\"X.509\");\n+\n+            \/\/ Read in the certificates and keys needed for this test and\n+            \/\/ create the keystore for the SimpleOCSPServer.  For the purposes\n+            \/\/ of this test, the CA certificate will also be the OCSP responder\n+            \/\/ signing certificate.\n+            SSLSocketTemplate.Cert certAuth =\n+                    SSLSocketTemplate.Cert.CA_ECDSA_SECP256R1;\n+            X509Certificate caCert = pem2Cert(certAuth.certStr);\n+            PrivateKey caKey = pem2Key(certAuth.privKeyStr, certAuth.keyAlgo);\n+            X509Certificate endEntCert =\n+                    pem2Cert(SSLSocketTemplate.Cert.EE_ECDSA_SECP256R1.certStr);\n+\n+            KeyStore.Builder keyStoreBuilder =\n+                    KeyStore.Builder.newInstance(\"PKCS12\", null,\n+                        new KeyStore.PasswordProtection(PASS.toCharArray()));\n+            KeyStore ocspStore = keyStoreBuilder.getKeyStore();\n+            Certificate[] ocspChain = {caCert};\n+            ocspStore.setKeyEntry(\"ocspsigner\", caKey, PASS.toCharArray(),\n+                    ocspChain);\n+\n+            \/\/ Create the certificate path we'll use for cert path validation.\n+            CertPath path = certFac.generateCertPath(List.of(endEntCert));\n+\n+            \/\/ Next, create and start the OCSP responder.  Obtain the socket\n+            \/\/ address so we can set that in the PKIXRevocationChecker since\n+            \/\/ these certificates do not have AIA extensions on them.\n+            ocspResponder = new SimpleOCSPServer(ocspStore, PASS,\n+                    \"ocspsigner\", null);\n+            ocspResponder.setSignatureAlgorithm(\"SHA256WithECDSA\");\n+            ocspResponder.enableLog(true);\n+            ocspResponder.setNextUpdateInterval(3600);\n+            ocspResponder.updateStatusDb(Map.of(\n+                    endEntCert.getSerialNumber(),\n+                    new SimpleOCSPServer.CertStatusInfo(\n+                            SimpleOCSPServer.CertStatus.CERT_STATUS_GOOD)));\n+            ocspResponder.start();\n+            \/\/ Wait 5 seconds for server ready\n+            for (int i = 0; (i < 100 && !ocspResponder.isServerReady()); i++) {\n+                Thread.sleep(50);\n+            }\n+            if (!ocspResponder.isServerReady()) {\n+                throw new RuntimeException(\"Server not ready yet\");\n+            }\n+\n+            int ocspPort = ocspResponder.getPort();\n+            URI ocspURI = new URI(\"http:\/\/localhost:\" + ocspPort);\n+            System.out.println(\"Configured CPV to connect to \" + ocspURI);\n+\n+            \/\/ Create the PKIXParameters needed for path validation and\n+            \/\/ configure any necessary OCSP parameters to control the OCSP\n+            \/\/ request size.\n+            Set<TrustAnchor> anchors = Set.of(new TrustAnchor(caCert, null));\n+\n+            CertPathValidator validator = CertPathValidator.getInstance(\"PKIX\");\n+            PKIXRevocationChecker revChkr =\n+                    (PKIXRevocationChecker)validator.getRevocationChecker();\n+            revChkr.setOcspResponder(ocspURI);\n+            revChkr.setOptions(Set.of(\n+                    PKIXRevocationChecker.Option.ONLY_END_ENTITY,\n+                    PKIXRevocationChecker.Option.NO_FALLBACK));\n+\n+            PKIXParameters params = new PKIXParameters(anchors);\n+            params.setRevocationEnabled(true);\n+            params.setDate(new Date(1590926400000L)); \/\/ 05\/31\/2020 @ 12:00:00Z\n+            params.addCertPathChecker(revChkr);\n+\n+            System.out.println(\"Test 1: Request < 255 bytes, HTTP GET\");\n+            validator.validate(path, params);\n+\n+            System.out.println(\"Test 2: Request > 255 bytes, HTTP POST\");\n+            \/\/ Modify the PKIXRevocationChecker to include a bogus non-critical\n+            \/\/ request extension that makes the request large enough to be\n+            \/\/ issued as an HTTP POST.\n+            List<PKIXCertPathChecker> chkrList = params.getCertPathCheckers();\n+            for (PKIXCertPathChecker chkr : chkrList) {\n+                if (chkr instanceof PKIXRevocationChecker) {\n+                    ((PKIXRevocationChecker)chkr).setOcspExtensions(\n+                            List.of(new BogusExtension(\"1.2.3.4.5.6.7.8.9\",\n+                                    false, 256)));\n+                }\n+            }\n+            params.setCertPathCheckers(chkrList);\n+            validator.validate(path, params);\n+\n+        } finally {\n+            if (ocspResponder != null) {\n+                ocspResponder.stop();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Create an X509Certificate object from its PEM encoding\n+     *\n+     * @param pemCert the base64 encoded certificate\n+     *\n+     * @return the corresponding X509Certificate object from the PEM encoding.\n+     *\n+     * @throws IOException if any InputStream or Base64 decoding failures occur.\n+     * @throws CertificateException if any certificate parsing errors occur.\n+     *\/\n+    private static X509Certificate pem2Cert(String pemCert)\n+            throws IOException, CertificateException {\n+        return (X509Certificate)certFac.generateCertificate(\n+                new ByteArrayInputStream(pemCert.getBytes()));\n+    }\n+\n+    \/**\n+     * Create a private key from its PEM-encoded PKCS#8 representation.\n+     *\n+     * @param pemKey the private key in PEM-encoded PKCS#8 unencrypted format\n+     * @param algorithm the private key algorithm\n+     *\n+     * @return the PrivateKey extracted from the PKCS#8 encoding.\n+     *\n+     * @throws GeneralSecurityException if any errors take place during\n+     * decoding or parsing.\n+     *\/\n+    private static PrivateKey pem2Key(String pemKey, String algorithm)\n+            throws GeneralSecurityException {\n+        byte[] p8Der = Base64.getMimeDecoder().decode(pemKey);\n+        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(p8Der, algorithm);\n+        KeyFactory kf = KeyFactory.getInstance(algorithm);\n+        return kf.generatePrivate(spec);\n+    }\n+\n+    \/**\n+     * The BogusOcspExtension is an extension with random data in the\n+     * extension value field.  It is used in this test to expand the size\n+     * of the OCSP request so it crosses the boundary that forces an HTTP\n+     * POST operation instead of a GET.\n+     *\/\n+    private static class BogusExtension implements Extension {\n+        private final ObjectIdentifier oid;\n+        private final boolean critical;\n+        private final byte[] data;\n+\n+        public BogusExtension(String oidStr, boolean isCrit, int size)\n+                throws IOException {\n+            \/\/ For this test we don't need anything larger than 10K\n+            if (size > 0 && size <= 10240) {\n+                data = new byte[size];\n+            } else {\n+                throw new IllegalArgumentException(\n+                        \"Size must be 0 < X <= 10240\");\n+            }\n+            oid = new ObjectIdentifier(oidStr);\n+            SecureRandom sr = new SecureRandom();\n+            sr.nextBytes(data);\n+            critical = isCrit;\n+        }\n+\n+        @Override\n+        public String getId() {\n+            return oid.toString();\n+        }\n+\n+        @Override\n+        public boolean isCritical() {\n+            return critical;\n+        }\n+\n+        @Override\n+        public byte[] getValue() {\n+            return data.clone();\n+        }\n+\n+        @Override\n+        public void encode(OutputStream out) throws IOException {\n+            Objects.requireNonNull(out, \"Non-null OutputStream required\");\n+\n+            DerOutputStream dos1 = new DerOutputStream();\n+            DerOutputStream dos2 = new DerOutputStream();\n+\n+            dos1.putOID(oid);\n+            if (critical) {\n+                dos1.putBoolean(critical);\n+            }\n+            dos1.putOctetString(data);\n+\n+            dos2.write(DerValue.tag_Sequence, dos1);\n+            out.write(dos2.toByteArray());\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/OCSP\/GetAndPostTests.java","additions":264,"deletions":0,"binary":false,"changes":264,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import sun.security.util.SignatureUtil;\n@@ -367,2 +368,1 @@\n-        AlgorithmId signAlg = AlgorithmId.get(algName);\n-        byte[] encodedCert = encodeTopLevel(issuerCert, issuerKey, signAlg);\n+        byte[] encodedCert = encodeTopLevel(issuerCert, issuerKey, algName);\n@@ -395,2 +395,3 @@\n-            PrivateKey issuerKey, AlgorithmId signAlg)\n-            throws CertificateException, IOException {\n+            PrivateKey issuerKey, String algName)\n+            throws CertificateException, IOException, NoSuchAlgorithmException {\n+        AlgorithmId signAlg = AlgorithmId.get(algName);\n@@ -400,2 +401,0 @@\n-        tbsCertBytes = encodeTbsCert(issuerCert, signAlg);\n-        topLevelItems.write(tbsCertBytes);\n@@ -403,1 +402,6 @@\n-            signatureBytes = signCert(issuerKey, signAlg);\n+            Signature sig = SignatureUtil.fromKey(signAlg.getName(), issuerKey, (Provider)null);\n+            \/\/ Rewrite signAlg, RSASSA-PSS needs some parameters.\n+            signAlg = SignatureUtil.fromSignature(sig, issuerKey);\n+            tbsCertBytes = encodeTbsCert(issuerCert, signAlg);\n+            sig.update(tbsCertBytes);\n+            signatureBytes = sig.sign();\n@@ -407,0 +411,1 @@\n+        topLevelItems.write(tbsCertBytes);\n@@ -520,20 +525,1 @@\n-\n-    \/**\n-     * Digitally sign the X.509 certificate.\n-     *\n-     * @param issuerKey The private key of the issuing authority\n-     * @param signAlg The signature algorithm object\n-     *\n-     * @return The digital signature bytes.\n-     *\n-     * @throws GeneralSecurityException If any errors occur during the\n-     * digital signature process.\n-     *\/\n-    private byte[] signCert(PrivateKey issuerKey, AlgorithmId signAlg)\n-            throws GeneralSecurityException {\n-        Signature sig = Signature.getInstance(signAlg.getName());\n-        sig.initSign(issuerKey);\n-        sig.update(tbsCertBytes);\n-        return sig.sign();\n-    }\n- }\n+}\n","filename":"test\/jdk\/java\/security\/testlibrary\/CertificateBuilder.java","additions":14,"deletions":28,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-\n+import sun.security.util.SignatureUtil;\n@@ -181,2 +181,1 @@\n-\n-        sigAlgId = AlgorithmId.get(\"Sha256withRSA\");\n+        sigAlgId = AlgorithmId.get(AlgorithmId.getDefaultSigAlgForKey(signerKey));\n@@ -710,1 +709,0 @@\n-                log(\"Received incoming connection from \" + peerSockAddr);\n@@ -717,0 +715,2 @@\n+                        log(\"Received incoming HTTP \" + headerTokens[0] +\n+                                \" from \" + peerSockAddr);\n@@ -719,1 +719,1 @@\n-                                    ocspReq = parseHttpOcspPost(in);\n+                                ocspReq = parseHttpOcspPost(in);\n@@ -722,3 +722,2 @@\n-                                \/\/ req = parseHttpOcspGet(in);\n-                                \/\/ TODO implement the GET parsing\n-                                throw new IOException(\"GET method unsupported\");\n+                                ocspReq = parseHttpOcspGet(headerTokens);\n+                                break;\n@@ -846,0 +845,24 @@\n+        \/**\n+         * Parse the incoming HTTP GET of an OCSP Request.\n+         *\n+         * @param headerTokens the individual String tokens from the first\n+         * line of the HTTP GET.\n+         *\n+         * @return the OCSP Request as a {@code LocalOcspRequest}\n+         *\n+         * @throws IOException if there are network related issues or problems\n+         * occur during parsing of the OCSP request.\n+         * @throws CertificateException if one or more of the certificates in\n+         * the OCSP request cannot be read\/parsed.\n+         *\/\n+        private LocalOcspRequest parseHttpOcspGet(String[] headerTokens)\n+                throws IOException, CertificateException {\n+            \/\/ We have already established headerTokens[0] to be \"GET\".\n+            \/\/ We should have the URL-encoded base64 representation of the\n+            \/\/ OCSP request in headerTokens[1].  We need to strip any leading\n+            \/\/ \"\/\" off before decoding.\n+            return new LocalOcspRequest(Base64.getMimeDecoder().decode(\n+                    URLDecoder.decode(headerTokens[1].replaceAll(\"\/\", \"\"),\n+                            \"UTF-8\")));\n+        }\n+\n@@ -1331,2 +1354,0 @@\n-                sigAlgId.derEncode(basicORItemStream);\n-\n@@ -1334,2 +1355,2 @@\n-                Signature sig = Signature.getInstance(sigAlgId.getName());\n-                sig.initSign(signerKey);\n+                Signature sig = SignatureUtil.fromKey(\n+                        sigAlgId.getName(), signerKey, (Provider)null);\n@@ -1338,0 +1359,3 @@\n+                \/\/ Rewrite signAlg, RSASSA-PSS needs some parameters.\n+                sigAlgId = SignatureUtil.fromSignature(sig, signerKey);\n+                sigAlgId.derEncode(basicORItemStream);\n","filename":"test\/jdk\/java\/security\/testlibrary\/SimpleOCSPServer.java","additions":37,"deletions":13,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n- * @run main\/othervm HttpsUrlConnClient\n+ * @run main\/othervm HttpsUrlConnClient RSA SHA256withRSA\n+ * @run main\/othervm HttpsUrlConnClient RSASSA-PSS RSASSA-PSS\n@@ -63,1 +64,0 @@\n-import sun.security.validator.ValidatorException;\n@@ -76,0 +76,3 @@\n+    static String SIGALG;\n+    static String KEYALG;\n+\n@@ -140,0 +143,3 @@\n+        KEYALG = args[0];\n+        SIGALG = args[1];\n+\n@@ -517,1 +523,1 @@\n-        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n+        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(KEYALG);\n@@ -543,1 +549,1 @@\n-                \"SHA256withRSA\");\n+                SIGALG);\n@@ -585,1 +591,1 @@\n-                \"SHA256withRSA\");\n+                SIGALG);\n@@ -647,1 +653,1 @@\n-                \"SHA256withRSA\");\n+                SIGALG);\n","filename":"test\/jdk\/javax\/net\/ssl\/Stapling\/HttpsUrlConnClient.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"}]}