{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,2 +211,2 @@\n-lib_info* add_lib_info(struct ps_prochandle* ph, const char* libname, uintptr_t base) {\n-  return add_lib_info_fd(ph, libname, -1, base);\n+lib_info* add_lib_info(struct ps_prochandle* ph, const char* libname, uintptr_t base, size_t memsz) {\n+  return add_lib_info_fd(ph, libname, -1, base, memsz);\n@@ -215,1 +215,1 @@\n-lib_info* add_lib_info_fd(struct ps_prochandle* ph, const char* libname, int fd, uintptr_t base) {\n+lib_info* add_lib_info_fd(struct ps_prochandle* ph, const char* libname, int fd, uintptr_t base, size_t memsz) {\n@@ -232,0 +232,1 @@\n+  newlib->memsz = memsz;\n@@ -265,1 +266,1 @@\n-    print_debug(\"built symbol table for %s\\n\", newlib->name);\n+    print_debug(\"built symbol table for 0x%lx %s\\n\", newlib, newlib->name);\n@@ -308,0 +309,1 @@\n+  print_debug(\"symbol_for_pc: addr 0x%lx\\n\", addr);\n@@ -309,1 +311,4 @@\n-    if (lib->symtab && addr >= lib->base) {\n+    print_debug(\"symbol_for_pc: checking lib 0x%lx 0x%lx %s\\n\", lib->base, lib->memsz, lib->name);\n+    if (lib->symtab && addr >= lib->base && addr < lib->base + lib->memsz) {\n+      print_debug(\"symbol_for_pc: address=0x%lx offset=0x%lx found inside lib base=0x%lx memsz=0x%lx %s\\n\",\n+                  addr, addr - lib->base, lib->base, lib->memsz, lib->name);\n","filename":"src\/jdk.hotspot.agent\/macosx\/native\/libsaproc\/libproc_impl.c","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+  size_t           memsz;\n@@ -165,2 +166,2 @@\n-   off_t            offset;   \/\/ file offset of this mapping\n-   uintptr_t        vaddr;    \/\/ starting virtual address\n+   uint64_t         offset;   \/\/ file offset of this mapping\n+   uint64_t         vaddr;    \/\/ starting virtual address\n@@ -227,1 +228,1 @@\n-lib_info* add_lib_info(struct ps_prochandle* ph, const char* libname, uintptr_t base);\n+lib_info* add_lib_info(struct ps_prochandle* ph, const char* libname, uintptr_t base, size_t memsz);\n@@ -231,1 +232,1 @@\n-                          uintptr_t base);\n+                          uintptr_t base, size_t memsz);\n","filename":"src\/jdk.hotspot.agent\/macosx\/native\/libsaproc\/libproc_impl.h","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -618,0 +618,1 @@\n+    \/\/print_debug(\"LC: 0x%x\\n\", lcmd.cmd);\n@@ -628,2 +629,3 @@\n-      print_debug(\"segment added: %\" PRIu64 \" 0x%\" PRIx64 \" %d\\n\",\n-                   segcmd.fileoff, segcmd.vmaddr, segcmd.vmsize);\n+      print_debug(\"LC_SEGMENT_64 added: nsects=%d fileoff=0x%llx vmaddr=0x%llx vmsize=0x%llx filesize=0x%llx %s\\n\",\n+                  segcmd.nsects, segcmd.fileoff, segcmd.vmaddr, segcmd.vmsize,\n+                  segcmd.filesize, &segcmd.segname[0]);\n@@ -901,1 +903,1 @@\n-    print_debug(\"map_info %d: vmaddr = 0x%016\" PRIx64 \"  fileoff = %\" PRIu64 \"  vmsize = %\" PRIu64 \"\\n\",\n+    print_debug(\"map_info %d: vmaddr = 0x%016llx fileoff = 0x%llx vmsize = 0x%lx\\n\",\n@@ -925,1 +927,1 @@\n-      \/\/ this is the file begining to core file.\n+      \/\/ This is the begining of the mach-o file in the segment.\n@@ -958,1 +960,1 @@\n-          print_debug(\"%s\\n\", name);\n+          print_debug(\"%d %s\\n\", lcmd.cmd, name);\n@@ -963,0 +965,2 @@\n+          } else {\n+            break; \/\/ Ignore non-relative paths, which are system libs. See JDK-8249779.\n@@ -964,1 +968,1 @@\n-          add_lib_info(ph, name, iter->vaddr);\n+          add_lib_info(ph, name, iter->vaddr, iter->memsz);\n@@ -969,0 +973,3 @@\n+#if 0\n+      \/\/ This line is disabled due to JDK-8249779. Instead we break out of the loop\n+      \/\/ and don't attempt to find any more mach-o files in this segment.\n@@ -970,0 +977,3 @@\n+#else\n+      break;\n+#endif\n","filename":"src\/jdk.hotspot.agent\/macosx\/native\/libsaproc\/ps_core.c","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include <stddef.h>\n@@ -60,0 +61,1 @@\n+  print_debug(\"build_search_table\\n\");\n@@ -66,0 +68,1 @@\n+    \/\/print_debug(\"build_search_table: %d 0x%x %s\\n\", i, symtab->symbols[i].offset, symtab->symbols[i].name);\n@@ -95,1 +98,1 @@\n-  int i;\n+  int i, j;\n@@ -99,0 +102,1 @@\n+  print_debug(\"build_symtab\\n\");\n@@ -154,0 +158,1 @@\n+  \/\/ allocate the symtab\n@@ -161,9 +166,0 @@\n-  lseek(fd, image_start + symtabcmd.symoff, SEEK_SET);\n-  for (i = 0; i < symtab->num_symbols; i++) {\n-    if (read(fd, (void *)&lentry, sizeof(nlist_64)) != sizeof(nlist_64)) {\n-      print_debug(\"read nlist_64 failed at %i\\n\", i);\n-      goto quit;\n-    }\n-    symtab->symbols[i].offset = lentry.n_value;\n-    symtab->symbols[i].size  = lentry.n_un.n_strx;        \/\/ index\n-  }\n@@ -171,1 +167,1 @@\n-  \/\/ string table\n+  \/\/ read in the string table\n@@ -179,6 +175,11 @@\n-  for (i = 0; i < symtab->num_symbols; i++) {\n-    symtab->symbols[i].name = symtab->strs + symtab->symbols[i].size;\n-    if (i > 0) {\n-      \/\/ fix size\n-      symtab->symbols[i - 1].size = symtab->symbols[i].size - symtab->symbols[i - 1].size;\n-      print_debug(\"%s size = %d\\n\", symtab->symbols[i - 1].name, symtab->symbols[i - 1].size);\n+  \/\/ read in each nlist_64 from the symbol table and use to fill in symtab->symbols\n+  lseek(fd, image_start + symtabcmd.symoff, SEEK_SET);\n+  i = 0;\n+  for (j = 0; j < symtab->num_symbols; j++) {\n+    if (read(fd, (void *)&lentry, sizeof(nlist_64)) != sizeof(nlist_64)) {\n+      print_debug(\"read nlist_64 failed at %j\\n\", j);\n+      goto quit;\n+    }\n+\n+    uintptr_t offset = lentry.n_value;     \/\/ offset of the symbol code\/data in the file\n+    uintptr_t stridx = lentry.n_un.n_strx; \/\/ offset of symbol string in the symtabcmd.symoff section\n@@ -186,0 +187,2 @@\n+    if (stridx == 0 || offset == 0) {\n+      continue; \/\/ Skip this entry. It's not a reference to code or data\n@@ -187,0 +190,3 @@\n+    symtab->symbols[i].offset = offset;\n+    symtab->symbols[i].name = symtab->strs + stridx;\n+    symtab->symbols[i].size = strlen(symtab->symbols[i].name);\n@@ -188,5 +194,2 @@\n-    if (i == symtab->num_symbols - 1) {\n-      \/\/ last index\n-      symtab->symbols[i].size =\n-            symtabcmd.strsize - symtab->symbols[i].size;\n-      print_debug(\"%s size = %d\\n\", symtab->symbols[i].name, symtab->symbols[i].size);\n+    if (symtab->symbols[i].size == 0) {\n+      continue; \/\/ Skip this entry. It points to an empty string.\n@@ -194,0 +197,14 @@\n+\n+    print_debug(\"symbol read: %d %d n_type=0x%x n_sect=0x%x n_desc=0x%x n_strx=0x%lx offset=0x%lx %s\\n\",\n+                j, i, lentry.n_type, lentry.n_sect, lentry.n_desc, stridx, offset, symtab->symbols[i].name);\n+    i++;\n+  }\n+\n+  \/\/ Update symtab->num_symbols to be the actual number of symbols we added. Since the symbols\n+  \/\/ array was allocated larger, reallocate it to the proper size.\n+  print_debug(\"build_symtab: included %d of %d entries.\\n\", i, symtab->num_symbols);\n+  symtab->num_symbols = i;\n+  symtab->symbols = (symtab_symbol *)realloc(symtab->symbols, sizeof(symtab_symbol) * symtab->num_symbols);\n+  if (symtab->symbols == NULL) {\n+     print_debug(\"out of memory: reallocating symtab.symbol\\n\");\n+     goto quit;\n@@ -392,0 +409,2 @@\n+  char* result = NULL;\n+  ptrdiff_t lowest_offset_from_sym = -1;\n@@ -393,0 +412,9 @@\n+  \/\/ Search the symbol table for the symbol that is closest to the specified offset, but is not under.\n+  \/\/\n+  \/\/ Note we can't just use the first symbol that is >= the offset because the symbols may not be\n+  \/\/ sorted by offset.\n+  \/\/\n+  \/\/ Note this is a rather slow search that is O(n\/2), and libjvm has as many as 250k symbols.\n+  \/\/ Probably would be good to sort the array and do a binary search, or use a hash table like\n+  \/\/ we do for name -> address lookups. However, this functionality is not used often and\n+  \/\/ generally just involves one lookup, such as with the clhsdb \"findpc\" command.\n@@ -395,4 +423,10 @@\n-    if (sym->name != NULL &&\n-      offset >= sym->offset && offset < sym->offset + sym->size) {\n-      if (poffset) *poffset = (offset - sym->offset);\n-      return sym->name;\n+    if (sym->size != 0 && offset >= sym->offset) {\n+      ptrdiff_t offset_from_sym = offset - sym->offset;\n+      if (offset_from_sym >= 0) { \/\/ ignore symbols that come after \"offset\"\n+        if (lowest_offset_from_sym == -1 || offset_from_sym < lowest_offset_from_sym) {\n+          lowest_offset_from_sym = offset_from_sym;\n+          result = sym->name;\n+          \/\/print_debug(\"nearest_symbol: found %d %s 0x%x 0x%x 0x%x\\n\",\n+          \/\/            n, sym->name, offset, sym->offset, lowest_offset_from_sym);\n+        }\n+      }\n@@ -401,1 +435,7 @@\n-  return NULL;\n+  print_debug(\"nearest_symbol: found symbol %d file_offset=0x%lx sym_offset=0x%lx %s\\n\",\n+              n, offset, lowest_offset_from_sym, result);\n+  \/\/ Save the offset from the symbol if requested.\n+  if (result != NULL && poffset) {\n+    *poffset = lowest_offset_from_sym;\n+  }\n+  return result;\n","filename":"src\/jdk.hotspot.agent\/macosx\/native\/libsaproc\/symtab.c","additions":68,"deletions":28,"binary":false,"changes":96,"status":"modified"}]}