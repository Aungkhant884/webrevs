{"files":[{"patch":"@@ -1212,1 +1212,3 @@\n-                            separateAnnotationsKinds(param.vartype, param.sym.type, param.sym, pos);\n+                            if (!param.declaredUsingVar()) {\n+                                separateAnnotationsKinds(param.vartype, param.sym.type, param.sym, pos);\n+                            }\n@@ -1250,1 +1252,1 @@\n-                if (!tree.isImplicitlyTyped()) {\n+                if (!tree.declaredUsingVar()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3057,0 +3057,1 @@\n+        boolean declaredUsingVar = false;\n@@ -3076,0 +3077,1 @@\n+                    declaredUsingVar = true;\n@@ -3085,1 +3087,1 @@\n-            toP(F.at(pos).VarDef(mods, name, type, init));\n+            toP(F.at(pos).VarDef(mods, name, type, init, declaredUsingVar));\n@@ -3165,1 +3167,2 @@\n-        return toP(F.at(pos).VarDef(mods, name, type, null));\n+        return toP(F.at(pos).VarDef(mods, name, type, null,\n+                type != null && type.hasTag(IDENT) && ((JCIdent)type).name == names.var));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -925,0 +925,2 @@\n+        \/** declared using `var` *\/\n+        private boolean declaredUsingVar;\n@@ -931,0 +933,9 @@\n+            this(mods, name, vartype, init, sym, false);\n+        }\n+\n+        protected JCVariableDecl(JCModifiers mods,\n+                                 Name name,\n+                                 JCExpression vartype,\n+                                 JCExpression init,\n+                                 VarSymbol sym,\n+                                 boolean declaredUsingVar) {\n@@ -936,0 +947,1 @@\n+            this.declaredUsingVar = declaredUsingVar;\n@@ -941,1 +953,1 @@\n-            this(mods, null, vartype, null, null);\n+            this(mods, null, vartype, null, null, false);\n@@ -955,0 +967,4 @@\n+        public boolean declaredUsingVar() {\n+            return declaredUsingVar;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -218,0 +218,6 @@\n+    public JCVariableDecl VarDef(JCModifiers mods, Name name, JCExpression vartype, JCExpression init, boolean declaredUsingVar) {\n+        JCVariableDecl tree = new JCVariableDecl(mods, name, vartype, init, null, declaredUsingVar);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8261205\n+ * @summary check that potentially applicable type annotations are skip if the variable or parameter was declared with var\n+ * @library \/tools\/lib\n+ * @modules\n+ *      jdk.jdeps\/com.sun.tools.classfile\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ *      jdk.compiler\/com.sun.tools.javac.code\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main VariablesDeclaredWithVarTest\n+ *\/\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import java.io.File;\n+import java.nio.file.Paths;\n+\n+import java.lang.annotation.*;\n+import java.util.Arrays;\n+\n+import com.sun.tools.classfile.*;\n+import com.sun.tools.javac.util.Assert;\n+\n+import toolbox.JavacTask;\n+import toolbox.ToolBox;\n+\n+public class VariablesDeclaredWithVarTest {\n+    ToolBox tb = new ToolBox();\n+\n+    final String src =\n+            \"import java.util.function.*;\\n\" +\n+            \"import java.lang.annotation.ElementType;\\n\" +\n+            \"import java.lang.annotation.Target;\\n\" +\n+            \"\\n\" +\n+            \"@Target({ElementType.TYPE_USE, ElementType.PARAMETER, ElementType.LOCAL_VARIABLE})\\n\" +\n+            \"@interface A {}\\n\" +\n+            \"\\n\" +\n+            \"class Test {\\n\" +\n+            \"    void kaa() {\\n\" +\n+            \"        @A var c = g(1, 1L);\\n\" +\n+            \"    }\\n\" +\n+            \"\\n\" +\n+            \"    <X> X g(X a, X b) {\\n\" +\n+            \"        return a;\\n\" +\n+            \"    }\\n\" +\n+            \"\\n\" +\n+            \"    void foo() {\\n\" +\n+            \"        bar((@A var s) -> s);\\n\" +\n+            \"    }\\n\" +\n+            \"\\n\" +\n+            \"    void bar(Function<String, String> f) {}\\n\" +\n+            \"}\\n\";\n+\n+    public static void main(String... args) throws Exception {\n+        new VariablesDeclaredWithVarTest().run();\n+    }\n+\n+    void run() throws Exception {\n+        compileTestClass();\n+        checkClassFile(new File(Paths.get(System.getProperty(\"user.dir\"),\n+                \"Test.class\").toUri()), 0);\n+    }\n+\n+    void compileTestClass() throws Exception {\n+        new JavacTask(tb)\n+                .sources(src)\n+                .run();\n+    }\n+\n+    void checkClassFile(final File cfile, int... taPositions) throws Exception {\n+        ClassFile classFile = ClassFile.read(cfile);\n+        List<TypeAnnotation> annos = new ArrayList<>();\n+        for (Method method : classFile.methods) {\n+            findAnnotations(classFile, method, annos);\n+            String methodName = method.getName(classFile.constant_pool);\n+            Assert.check(annos.size() == 0, \"there shouldn't be any type annotations in any method, found \" + annos.size() +\n+                    \" type annotations at method \" + methodName);\n+        }\n+    }\n+\n+    void findAnnotations(ClassFile cf, Method m, List<TypeAnnotation> annos) {\n+        findAnnotations(cf, m, Attribute.RuntimeVisibleTypeAnnotations, annos);\n+        findAnnotations(cf, m, Attribute.RuntimeInvisibleTypeAnnotations, annos);\n+    }\n+\n+    void findAnnotations(ClassFile cf, Method m, String name, List<TypeAnnotation> annos) {\n+        int index = m.attributes.getIndex(cf.constant_pool, name);\n+        if (index != -1) {\n+            Attribute attr = m.attributes.get(index);\n+            assert attr instanceof RuntimeTypeAnnotations_attribute;\n+            RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n+            annos.addAll(Arrays.asList(tAttr.annotations));\n+        }\n+\n+        int cindex = m.attributes.getIndex(cf.constant_pool, Attribute.Code);\n+        if (cindex != -1) {\n+            Attribute cattr = m.attributes.get(cindex);\n+            assert cattr instanceof Code_attribute;\n+            Code_attribute cAttr = (Code_attribute)cattr;\n+            index = cAttr.attributes.getIndex(cf.constant_pool, name);\n+            if (index != -1) {\n+                Attribute attr = cAttr.attributes.get(index);\n+                assert attr instanceof RuntimeTypeAnnotations_attribute;\n+                RuntimeTypeAnnotations_attribute tAttr = (RuntimeTypeAnnotations_attribute)attr;\n+                annos.addAll(Arrays.asList(tAttr.annotations));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/VariablesDeclaredWithVarTest.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"}]}