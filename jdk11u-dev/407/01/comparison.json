{"files":[{"patch":"@@ -3,1 +3,1 @@\n-JSZip v3.6.0 - A JavaScript class for generating and reading zip files\n+JSZip v3.7.1 - A JavaScript class for generating and reading zip files\n@@ -14,2 +14,5 @@\n-(function (global){\n-\/*!\n+'use strict';\n+var utils = require('.\/utils');\n+var support = require('.\/support');\n+\/\/ private property\n+var _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/=\";\n@@ -17,2 +20,0 @@\n-JSZip v3.5.0 - A JavaScript class for generating and reading zip files\n-<http:\/\/stuartk.com\/jszip>\n@@ -20,2 +21,5 @@\n-(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>\n-Dual licenced under the MIT license or GPLv3. See https:\/\/raw.github.com\/Stuk\/jszip\/master\/LICENSE.markdown.\n+\/\/ public method for encoding\n+exports.encode = function(input) {\n+    var output = [];\n+    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n+    var i = 0, len = input.length, remainingBytes = len;\n@@ -23,2 +27,1218 @@\n-JSZip uses the library pako released under the MIT license :\n-https:\/\/github.com\/nodeca\/pako\/blob\/master\/LICENSE\n+    var isArray = utils.getTypeOf(input) !== \"string\";\n+    while (i < input.length) {\n+        remainingBytes = len - i;\n+\n+        if (!isArray) {\n+            chr1 = input.charCodeAt(i++);\n+            chr2 = i < len ? input.charCodeAt(i++) : 0;\n+            chr3 = i < len ? input.charCodeAt(i++) : 0;\n+        } else {\n+            chr1 = input[i++];\n+            chr2 = i < len ? input[i++] : 0;\n+            chr3 = i < len ? input[i++] : 0;\n+        }\n+\n+        enc1 = chr1 >> 2;\n+        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n+        enc3 = remainingBytes > 1 ? (((chr2 & 15) << 2) | (chr3 >> 6)) : 64;\n+        enc4 = remainingBytes > 2 ? (chr3 & 63) : 64;\n+\n+        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));\n+\n+    }\n+\n+    return output.join(\"\");\n+};\n+\n+\/\/ public method for decoding\n+exports.decode = function(input) {\n+    var chr1, chr2, chr3;\n+    var enc1, enc2, enc3, enc4;\n+    var i = 0, resultIndex = 0;\n+\n+    var dataUrlPrefix = \"data:\";\n+\n+    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {\n+        \/\/ This is a common error: people give a data url\n+        \/\/ (data:image\/png;base64,iVBOR...) with a {base64: true} and\n+        \/\/ wonders why things don't work.\n+        \/\/ We can detect that the string input looks like a data url but we\n+        \/\/ *can't* be sure it is one: removing everything up to the comma would\n+        \/\/ be too dangerous.\n+        throw new Error(\"Invalid base64 input, it looks like a data url.\");\n+    }\n+\n+    input = input.replace(\/[^A-Za-z0-9\\+\\\/\\=]\/g, \"\");\n+\n+    var totalLength = input.length * 3 \/ 4;\n+    if(input.charAt(input.length - 1) === _keyStr.charAt(64)) {\n+        totalLength--;\n+    }\n+    if(input.charAt(input.length - 2) === _keyStr.charAt(64)) {\n+        totalLength--;\n+    }\n+    if (totalLength % 1 !== 0) {\n+        \/\/ totalLength is not an integer, the length does not match a valid\n+        \/\/ base64 content. That can happen if:\n+        \/\/ - the input is not a base64 content\n+        \/\/ - the input is *almost* a base64 content, with a extra chars at the\n+        \/\/   beginning or at the end\n+        \/\/ - the input uses a base64 variant (base64url for example)\n+        throw new Error(\"Invalid base64 input, bad content length.\");\n+    }\n+    var output;\n+    if (support.uint8array) {\n+        output = new Uint8Array(totalLength|0);\n+    } else {\n+        output = new Array(totalLength|0);\n+    }\n+\n+    while (i < input.length) {\n+\n+        enc1 = _keyStr.indexOf(input.charAt(i++));\n+        enc2 = _keyStr.indexOf(input.charAt(i++));\n+        enc3 = _keyStr.indexOf(input.charAt(i++));\n+        enc4 = _keyStr.indexOf(input.charAt(i++));\n+\n+        chr1 = (enc1 << 2) | (enc2 >> 4);\n+        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n+        chr3 = ((enc3 & 3) << 6) | enc4;\n+\n+        output[resultIndex++] = chr1;\n+\n+        if (enc3 !== 64) {\n+            output[resultIndex++] = chr2;\n+        }\n+        if (enc4 !== 64) {\n+            output[resultIndex++] = chr3;\n+        }\n+\n+    }\n+\n+    return output;\n+};\n+\n+},{\".\/support\":30,\".\/utils\":32}],2:[function(require,module,exports){\n+'use strict';\n+\n+var external = require(\".\/external\");\n+var DataWorker = require('.\/stream\/DataWorker');\n+var Crc32Probe = require('.\/stream\/Crc32Probe');\n+var DataLengthProbe = require('.\/stream\/DataLengthProbe');\n+\n+\/**\n+ * Represent a compressed object, with everything needed to decompress it.\n+ * @constructor\n+ * @param {number} compressedSize the size of the data compressed.\n+ * @param {number} uncompressedSize the size of the data after decompression.\n+ * @param {number} crc32 the crc32 of the decompressed file.\n+ * @param {object} compression the type of compression, see lib\/compressions.js.\n+ * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.\n+ *\/\n+function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {\n+    this.compressedSize = compressedSize;\n+    this.uncompressedSize = uncompressedSize;\n+    this.crc32 = crc32;\n+    this.compression = compression;\n+    this.compressedContent = data;\n+}\n+\n+CompressedObject.prototype = {\n+    \/**\n+     * Create a worker to get the uncompressed content.\n+     * @return {GenericWorker} the worker.\n+     *\/\n+    getContentWorker: function () {\n+        var worker = new DataWorker(external.Promise.resolve(this.compressedContent))\n+            .pipe(this.compression.uncompressWorker())\n+            .pipe(new DataLengthProbe(\"data_length\"));\n+\n+        var that = this;\n+        worker.on(\"end\", function () {\n+            if (this.streamInfo['data_length'] !== that.uncompressedSize) {\n+                throw new Error(\"Bug : uncompressed data size mismatch\");\n+            }\n+        });\n+        return worker;\n+    },\n+    \/**\n+     * Create a worker to get the compressed content.\n+     * @return {GenericWorker} the worker.\n+     *\/\n+    getCompressedWorker: function () {\n+        return new DataWorker(external.Promise.resolve(this.compressedContent))\n+            .withStreamInfo(\"compressedSize\", this.compressedSize)\n+            .withStreamInfo(\"uncompressedSize\", this.uncompressedSize)\n+            .withStreamInfo(\"crc32\", this.crc32)\n+            .withStreamInfo(\"compression\", this.compression)\n+            ;\n+    }\n+};\n+\n+\/**\n+ * Chain the given worker with other workers to compress the content with the\n+ * given compression.\n+ * @param {GenericWorker} uncompressedWorker the worker to pipe.\n+ * @param {Object} compression the compression object.\n+ * @param {Object} compressionOptions the options to use when compressing.\n+ * @return {GenericWorker} the new worker compressing the content.\n+ *\/\n+CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {\n+    return uncompressedWorker\n+        .pipe(new Crc32Probe())\n+        .pipe(new DataLengthProbe(\"uncompressedSize\"))\n+        .pipe(compression.compressWorker(compressionOptions))\n+        .pipe(new DataLengthProbe(\"compressedSize\"))\n+        .withStreamInfo(\"compression\", compression);\n+};\n+\n+module.exports = CompressedObject;\n+\n+},{\".\/external\":6,\".\/stream\/Crc32Probe\":25,\".\/stream\/DataLengthProbe\":26,\".\/stream\/DataWorker\":27}],3:[function(require,module,exports){\n+'use strict';\n+\n+var GenericWorker = require(\".\/stream\/GenericWorker\");\n+\n+exports.STORE = {\n+    magic: \"\\x00\\x00\",\n+    compressWorker : function (compressionOptions) {\n+        return new GenericWorker(\"STORE compression\");\n+    },\n+    uncompressWorker : function () {\n+        return new GenericWorker(\"STORE decompression\");\n+    }\n+};\n+exports.DEFLATE = require('.\/flate');\n+\n+},{\".\/flate\":7,\".\/stream\/GenericWorker\":28}],4:[function(require,module,exports){\n+'use strict';\n+\n+var utils = require('.\/utils');\n+\n+\/**\n+ * The following functions come from pako, from pako\/lib\/zlib\/crc32.js\n+ * released under the MIT license, see pako https:\/\/github.com\/nodeca\/pako\/\n+ *\/\n+\n+\/\/ Use ordinary array, since untyped makes no boost here\n+function makeTable() {\n+    var c, table = [];\n+\n+    for(var n =0; n < 256; n++){\n+        c = n;\n+        for(var k =0; k < 8; k++){\n+            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n+        }\n+        table[n] = c;\n+    }\n+\n+    return table;\n+}\n+\n+\/\/ Create table on load. Just 255 signed longs. Not a problem.\n+var crcTable = makeTable();\n+\n+\n+function crc32(crc, buf, len, pos) {\n+    var t = crcTable, end = pos + len;\n+\n+    crc = crc ^ (-1);\n+\n+    for (var i = pos; i < end; i++ ) {\n+        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n+    }\n+\n+    return (crc ^ (-1)); \/\/ >>> 0;\n+}\n+\n+\/\/ That's all for the pako functions.\n+\n+\/**\n+ * Compute the crc32 of a string.\n+ * This is almost the same as the function crc32, but for strings. Using the\n+ * same function for the two use cases leads to horrible performances.\n+ * @param {Number} crc the starting value of the crc.\n+ * @param {String} str the string to use.\n+ * @param {Number} len the length of the string.\n+ * @param {Number} pos the starting position for the crc32 computation.\n+ * @return {Number} the computed crc32.\n+ *\/\n+function crc32str(crc, str, len, pos) {\n+    var t = crcTable, end = pos + len;\n+\n+    crc = crc ^ (-1);\n+\n+    for (var i = pos; i < end; i++ ) {\n+        crc = (crc >>> 8) ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];\n+    }\n+\n+    return (crc ^ (-1)); \/\/ >>> 0;\n+}\n+\n+module.exports = function crc32wrapper(input, crc) {\n+    if (typeof input === \"undefined\" || !input.length) {\n+        return 0;\n+    }\n+\n+    var isArray = utils.getTypeOf(input) !== \"string\";\n+\n+    if(isArray) {\n+        return crc32(crc|0, input, input.length, 0);\n+    } else {\n+        return crc32str(crc|0, input, input.length, 0);\n+    }\n+};\n+\n+},{\".\/utils\":32}],5:[function(require,module,exports){\n+'use strict';\n+exports.base64 = false;\n+exports.binary = false;\n+exports.dir = false;\n+exports.createFolders = true;\n+exports.date = null;\n+exports.compression = null;\n+exports.compressionOptions = null;\n+exports.comment = null;\n+exports.unixPermissions = null;\n+exports.dosPermissions = null;\n+\n+},{}],6:[function(require,module,exports){\n+\/* global Promise *\/\n+'use strict';\n+\n+\/\/ load the global object first:\n+\/\/ - it should be better integrated in the system (unhandledRejection in node)\n+\/\/ - the environment may have a custom Promise implementation (see zone.js)\n+var ES6Promise = null;\n+if (typeof Promise !== \"undefined\") {\n+    ES6Promise = Promise;\n+} else {\n+    ES6Promise = require(\"lie\");\n+}\n+\n+\/**\n+ * Let the user use\/change some implementations.\n+ *\/\n+module.exports = {\n+    Promise: ES6Promise\n+};\n+\n+},{\"lie\":37}],7:[function(require,module,exports){\n+'use strict';\n+var USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');\n+\n+var pako = require(\"pako\");\n+var utils = require(\".\/utils\");\n+var GenericWorker = require(\".\/stream\/GenericWorker\");\n+\n+var ARRAY_TYPE = USE_TYPEDARRAY ? \"uint8array\" : \"array\";\n+\n+exports.magic = \"\\x08\\x00\";\n+\n+\/**\n+ * Create a worker that uses pako to inflate\/deflate.\n+ * @constructor\n+ * @param {String} action the name of the pako function to call : either \"Deflate\" or \"Inflate\".\n+ * @param {Object} options the options to use when (de)compressing.\n+ *\/\n+function FlateWorker(action, options) {\n+    GenericWorker.call(this, \"FlateWorker\/\" + action);\n+\n+    this._pako = null;\n+    this._pakoAction = action;\n+    this._pakoOptions = options;\n+    \/\/ the `meta` object from the last chunk received\n+    \/\/ this allow this worker to pass around metadata\n+    this.meta = {};\n+}\n+\n+utils.inherits(FlateWorker, GenericWorker);\n+\n+\/**\n+ * @see GenericWorker.processChunk\n+ *\/\n+FlateWorker.prototype.processChunk = function (chunk) {\n+    this.meta = chunk.meta;\n+    if (this._pako === null) {\n+        this._createPako();\n+    }\n+    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);\n+};\n+\n+\/**\n+ * @see GenericWorker.flush\n+ *\/\n+FlateWorker.prototype.flush = function () {\n+    GenericWorker.prototype.flush.call(this);\n+    if (this._pako === null) {\n+        this._createPako();\n+    }\n+    this._pako.push([], true);\n+};\n+\/**\n+ * @see GenericWorker.cleanUp\n+ *\/\n+FlateWorker.prototype.cleanUp = function () {\n+    GenericWorker.prototype.cleanUp.call(this);\n+    this._pako = null;\n+};\n+\n+\/**\n+ * Create the _pako object.\n+ * TODO: lazy-loading this object isn't the best solution but it's the\n+ * quickest. The best solution is to lazy-load the worker list. See also the\n+ * issue #446.\n+ *\/\n+FlateWorker.prototype._createPako = function () {\n+    this._pako = new pako[this._pakoAction]({\n+        raw: true,\n+        level: this._pakoOptions.level || -1 \/\/ default compression\n+    });\n+    var self = this;\n+    this._pako.onData = function(data) {\n+        self.push({\n+            data : data,\n+            meta : self.meta\n+        });\n+    };\n+};\n+\n+exports.compressWorker = function (compressionOptions) {\n+    return new FlateWorker(\"Deflate\", compressionOptions);\n+};\n+exports.uncompressWorker = function () {\n+    return new FlateWorker(\"Inflate\", {});\n+};\n+\n+},{\".\/stream\/GenericWorker\":28,\".\/utils\":32,\"pako\":38}],8:[function(require,module,exports){\n+'use strict';\n+\n+var utils = require('..\/utils');\n+var GenericWorker = require('..\/stream\/GenericWorker');\n+var utf8 = require('..\/utf8');\n+var crc32 = require('..\/crc32');\n+var signature = require('..\/signature');\n+\n+\/**\n+ * Transform an integer into a string in hexadecimal.\n+ * @private\n+ * @param {number} dec the number to convert.\n+ * @param {number} bytes the number of bytes to generate.\n+ * @returns {string} the result.\n+ *\/\n+var decToHex = function(dec, bytes) {\n+    var hex = \"\", i;\n+    for (i = 0; i < bytes; i++) {\n+        hex += String.fromCharCode(dec & 0xff);\n+        dec = dec >>> 8;\n+    }\n+    return hex;\n+};\n+\n+\/**\n+ * Generate the UNIX part of the external file attributes.\n+ * @param {Object} unixPermissions the unix permissions or null.\n+ * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n+ * @return {Number} a 32 bit integer.\n+ *\n+ * adapted from http:\/\/unix.stackexchange.com\/questions\/14705\/the-zip-formats-external-file-attribute :\n+ *\n+ * TTTTsstrwxrwxrwx0000000000ADVSHR\n+ * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n+ *     ^^^_________________________ setuid, setgid, sticky\n+ *        ^^^^^^^^^________________ permissions\n+ *                 ^^^^^^^^^^______ not used ?\n+ *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n+ *\/\n+var generateUnixExternalFileAttr = function (unixPermissions, isDir) {\n+\n+    var result = unixPermissions;\n+    if (!unixPermissions) {\n+        \/\/ I can't use octal values in strict mode, hence the hexa.\n+        \/\/  040775 => 0x41fd\n+        \/\/ 0100664 => 0x81b4\n+        result = isDir ? 0x41fd : 0x81b4;\n+    }\n+    return (result & 0xFFFF) << 16;\n+};\n+\n+\/**\n+ * Generate the DOS part of the external file attributes.\n+ * @param {Object} dosPermissions the dos permissions or null.\n+ * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n+ * @return {Number} a 32 bit integer.\n+ *\n+ * Bit 0     Read-Only\n+ * Bit 1     Hidden\n+ * Bit 2     System\n+ * Bit 3     Volume Label\n+ * Bit 4     Directory\n+ * Bit 5     Archive\n+ *\/\n+var generateDosExternalFileAttr = function (dosPermissions, isDir) {\n+\n+    \/\/ the dir flag is already set for compatibility\n+    return (dosPermissions || 0)  & 0x3F;\n+};\n+\n+\/**\n+ * Generate the various parts used in the construction of the final zip file.\n+ * @param {Object} streamInfo the hash with information about the compressed file.\n+ * @param {Boolean} streamedContent is the content streamed ?\n+ * @param {Boolean} streamingEnded is the stream finished ?\n+ * @param {number} offset the current offset from the start of the zip file.\n+ * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n+ * @param {Function} encodeFileName the function to encode the file name \/ comment.\n+ * @return {Object} the zip parts.\n+ *\/\n+var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {\n+    var file = streamInfo['file'],\n+    compression = streamInfo['compression'],\n+    useCustomEncoding = encodeFileName !== utf8.utf8encode,\n+    encodedFileName = utils.transformTo(\"string\", encodeFileName(file.name)),\n+    utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)),\n+    comment = file.comment,\n+    encodedComment = utils.transformTo(\"string\", encodeFileName(comment)),\n+    utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)),\n+    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n+    useUTF8ForComment = utfEncodedComment.length !== comment.length,\n+    dosTime,\n+    dosDate,\n+    extraFields = \"\",\n+    unicodePathExtraField = \"\",\n+    unicodeCommentExtraField = \"\",\n+    dir = file.dir,\n+    date = file.date;\n+\n+\n+    var dataInfo = {\n+        crc32 : 0,\n+        compressedSize : 0,\n+        uncompressedSize : 0\n+    };\n+\n+    \/\/ if the content is streamed, the sizes\/crc32 are only available AFTER\n+    \/\/ the end of the stream.\n+    if (!streamedContent || streamingEnded) {\n+        dataInfo.crc32 = streamInfo['crc32'];\n+        dataInfo.compressedSize = streamInfo['compressedSize'];\n+        dataInfo.uncompressedSize = streamInfo['uncompressedSize'];\n+    }\n+\n+    var bitflag = 0;\n+    if (streamedContent) {\n+        \/\/ Bit 3: the sizes\/crc32 are set to zero in the local header.\n+        \/\/ The correct values are put in the data descriptor immediately\n+        \/\/ following the compressed data.\n+        bitflag |= 0x0008;\n+    }\n+    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {\n+        \/\/ Bit 11: Language encoding flag (EFS).\n+        bitflag |= 0x0800;\n+    }\n+\n+\n+    var extFileAttr = 0;\n+    var versionMadeBy = 0;\n+    if (dir) {\n+        \/\/ dos or unix, we set the dos dir flag\n+        extFileAttr |= 0x00010;\n+    }\n+    if(platform === \"UNIX\") {\n+        versionMadeBy = 0x031E; \/\/ UNIX, version 3.0\n+        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n+    } else { \/\/ DOS or other, fallback to DOS\n+        versionMadeBy = 0x0014; \/\/ DOS, version 2.0\n+        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n+    }\n+\n+    \/\/ date\n+    \/\/ @see http:\/\/www.delorie.com\/djgpp\/doc\/rbinter\/it\/52\/13.html\n+    \/\/ @see http:\/\/www.delorie.com\/djgpp\/doc\/rbinter\/it\/65\/16.html\n+    \/\/ @see http:\/\/www.delorie.com\/djgpp\/doc\/rbinter\/it\/66\/16.html\n+\n+    dosTime = date.getUTCHours();\n+    dosTime = dosTime << 6;\n+    dosTime = dosTime | date.getUTCMinutes();\n+    dosTime = dosTime << 5;\n+    dosTime = dosTime | date.getUTCSeconds() \/ 2;\n+\n+    dosDate = date.getUTCFullYear() - 1980;\n+    dosDate = dosDate << 4;\n+    dosDate = dosDate | (date.getUTCMonth() + 1);\n+    dosDate = dosDate << 5;\n+    dosDate = dosDate | date.getUTCDate();\n+\n+    if (useUTF8ForFileName) {\n+        \/\/ set the unicode path extra field. unzip needs at least one extra\n+        \/\/ field to correctly handle unicode path, so using the path is as good\n+        \/\/ as any other information. This could improve the situation with\n+        \/\/ other archive managers too.\n+        \/\/ This field is usually used without the utf8 flag, with a non\n+        \/\/ unicode path in the header (winrar, winzip). This helps (a bit)\n+        \/\/ with the messy Windows' default compressed folders feature but\n+        \/\/ breaks on p7zip which doesn't seek the unicode path extra field.\n+        \/\/ So for now, UTF-8 everywhere !\n+        unicodePathExtraField =\n+            \/\/ Version\n+            decToHex(1, 1) +\n+            \/\/ NameCRC32\n+            decToHex(crc32(encodedFileName), 4) +\n+            \/\/ UnicodeName\n+            utfEncodedFileName;\n+\n+        extraFields +=\n+            \/\/ Info-ZIP Unicode Path Extra Field\n+            \"\\x75\\x70\" +\n+            \/\/ size\n+            decToHex(unicodePathExtraField.length, 2) +\n+            \/\/ content\n+            unicodePathExtraField;\n+    }\n+\n+    if(useUTF8ForComment) {\n+\n+        unicodeCommentExtraField =\n+            \/\/ Version\n+            decToHex(1, 1) +\n+            \/\/ CommentCRC32\n+            decToHex(crc32(encodedComment), 4) +\n+            \/\/ UnicodeName\n+            utfEncodedComment;\n+\n+        extraFields +=\n+            \/\/ Info-ZIP Unicode Path Extra Field\n+            \"\\x75\\x63\" +\n+            \/\/ size\n+            decToHex(unicodeCommentExtraField.length, 2) +\n+            \/\/ content\n+            unicodeCommentExtraField;\n+    }\n+\n+    var header = \"\";\n+\n+    \/\/ version needed to extract\n+    header += \"\\x0A\\x00\";\n+    \/\/ general purpose bit flag\n+    header += decToHex(bitflag, 2);\n+    \/\/ compression method\n+    header += compression.magic;\n+    \/\/ last mod file time\n+    header += decToHex(dosTime, 2);\n+    \/\/ last mod file date\n+    header += decToHex(dosDate, 2);\n+    \/\/ crc-32\n+    header += decToHex(dataInfo.crc32, 4);\n+    \/\/ compressed size\n+    header += decToHex(dataInfo.compressedSize, 4);\n+    \/\/ uncompressed size\n+    header += decToHex(dataInfo.uncompressedSize, 4);\n+    \/\/ file name length\n+    header += decToHex(encodedFileName.length, 2);\n+    \/\/ extra field length\n+    header += decToHex(extraFields.length, 2);\n+\n+\n+    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n+\n+    var dirRecord = signature.CENTRAL_FILE_HEADER +\n+        \/\/ version made by (00: DOS)\n+        decToHex(versionMadeBy, 2) +\n+        \/\/ file header (common to file and central directory)\n+        header +\n+        \/\/ file comment length\n+        decToHex(encodedComment.length, 2) +\n+        \/\/ disk number start\n+        \"\\x00\\x00\" +\n+        \/\/ internal file attributes TODO\n+        \"\\x00\\x00\" +\n+        \/\/ external file attributes\n+        decToHex(extFileAttr, 4) +\n+        \/\/ relative offset of local header\n+        decToHex(offset, 4) +\n+        \/\/ file name\n+        encodedFileName +\n+        \/\/ extra field\n+        extraFields +\n+        \/\/ file comment\n+        encodedComment;\n+\n+    return {\n+        fileRecord: fileRecord,\n+        dirRecord: dirRecord\n+    };\n+};\n+\n+\/**\n+ * Generate the EOCD record.\n+ * @param {Number} entriesCount the number of entries in the zip file.\n+ * @param {Number} centralDirLength the length (in bytes) of the central dir.\n+ * @param {Number} localDirLength the length (in bytes) of the local dir.\n+ * @param {String} comment the zip file comment as a binary string.\n+ * @param {Function} encodeFileName the function to encode the comment.\n+ * @return {String} the EOCD record.\n+ *\/\n+var generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {\n+    var dirEnd = \"\";\n+    var encodedComment = utils.transformTo(\"string\", encodeFileName(comment));\n+\n+    \/\/ end of central dir signature\n+    dirEnd = signature.CENTRAL_DIRECTORY_END +\n+        \/\/ number of this disk\n+        \"\\x00\\x00\" +\n+        \/\/ number of the disk with the start of the central directory\n+        \"\\x00\\x00\" +\n+        \/\/ total number of entries in the central directory on this disk\n+        decToHex(entriesCount, 2) +\n+        \/\/ total number of entries in the central directory\n+        decToHex(entriesCount, 2) +\n+        \/\/ size of the central directory   4 bytes\n+        decToHex(centralDirLength, 4) +\n+        \/\/ offset of start of central directory with respect to the starting disk number\n+        decToHex(localDirLength, 4) +\n+        \/\/ .ZIP file comment length\n+        decToHex(encodedComment.length, 2) +\n+        \/\/ .ZIP file comment\n+        encodedComment;\n+\n+    return dirEnd;\n+};\n+\n+\/**\n+ * Generate data descriptors for a file entry.\n+ * @param {Object} streamInfo the hash generated by a worker, containing information\n+ * on the file entry.\n+ * @return {String} the data descriptors.\n+ *\/\n+var generateDataDescriptors = function (streamInfo) {\n+    var descriptor = \"\";\n+    descriptor = signature.DATA_DESCRIPTOR +\n+        \/\/ crc-32                          4 bytes\n+        decToHex(streamInfo['crc32'], 4) +\n+        \/\/ compressed size                 4 bytes\n+        decToHex(streamInfo['compressedSize'], 4) +\n+        \/\/ uncompressed size               4 bytes\n+        decToHex(streamInfo['uncompressedSize'], 4);\n+\n+    return descriptor;\n+};\n+\n+\n+\/**\n+ * A worker to concatenate other workers to create a zip file.\n+ * @param {Boolean} streamFiles `true` to stream the content of the files,\n+ * `false` to accumulate it.\n+ * @param {String} comment the comment to use.\n+ * @param {String} platform the platform to use, \"UNIX\" or \"DOS\".\n+ * @param {Function} encodeFileName the function to encode file names and comments.\n+ *\/\n+function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {\n+    GenericWorker.call(this, \"ZipFileWorker\");\n+    \/\/ The number of bytes written so far. This doesn't count accumulated chunks.\n+    this.bytesWritten = 0;\n+    \/\/ The comment of the zip file\n+    this.zipComment = comment;\n+    \/\/ The platform \"generating\" the zip file.\n+    this.zipPlatform = platform;\n+    \/\/ the function to encode file names and comments.\n+    this.encodeFileName = encodeFileName;\n+    \/\/ Should we stream the content of the files ?\n+    this.streamFiles = streamFiles;\n+    \/\/ If `streamFiles` is false, we will need to accumulate the content of the\n+    \/\/ files to calculate sizes \/ crc32 (and write them *before* the content).\n+    \/\/ This boolean indicates if we are accumulating chunks (it will change a lot\n+    \/\/ during the lifetime of this worker).\n+    this.accumulate = false;\n+    \/\/ The buffer receiving chunks when accumulating content.\n+    this.contentBuffer = [];\n+    \/\/ The list of generated directory records.\n+    this.dirRecords = [];\n+    \/\/ The offset (in bytes) from the beginning of the zip file for the current source.\n+    this.currentSourceOffset = 0;\n+    \/\/ The total number of entries in this zip file.\n+    this.entriesCount = 0;\n+    \/\/ the name of the file currently being added, null when handling the end of the zip file.\n+    \/\/ Used for the emitted metadata.\n+    this.currentFile = null;\n+\n+\n+\n+    this._sources = [];\n+}\n+utils.inherits(ZipFileWorker, GenericWorker);\n+\n+\/**\n+ * @see GenericWorker.push\n+ *\/\n+ZipFileWorker.prototype.push = function (chunk) {\n+\n+    var currentFilePercent = chunk.meta.percent || 0;\n+    var entriesCount = this.entriesCount;\n+    var remainingFiles = this._sources.length;\n+\n+    if(this.accumulate) {\n+        this.contentBuffer.push(chunk);\n+    } else {\n+        this.bytesWritten += chunk.data.length;\n+\n+        GenericWorker.prototype.push.call(this, {\n+            data : chunk.data,\n+            meta : {\n+                currentFile : this.currentFile,\n+                percent : entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) \/ entriesCount : 100\n+            }\n+        });\n+    }\n+};\n+\n+\/**\n+ * The worker started a new source (an other worker).\n+ * @param {Object} streamInfo the streamInfo object from the new source.\n+ *\/\n+ZipFileWorker.prototype.openedSource = function (streamInfo) {\n+    this.currentSourceOffset = this.bytesWritten;\n+    this.currentFile = streamInfo['file'].name;\n+\n+    var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n+\n+    \/\/ don't stream folders (because they don't have any content)\n+    if(streamedContent) {\n+        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n+        this.push({\n+            data : record.fileRecord,\n+            meta : {percent:0}\n+        });\n+    } else {\n+        \/\/ we need to wait for the whole file before pushing anything\n+        this.accumulate = true;\n+    }\n+};\n+\n+\/**\n+ * The worker finished a source (an other worker).\n+ * @param {Object} streamInfo the streamInfo object from the finished source.\n+ *\/\n+ZipFileWorker.prototype.closedSource = function (streamInfo) {\n+    this.accumulate = false;\n+    var streamedContent = this.streamFiles && !streamInfo['file'].dir;\n+    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);\n+\n+    this.dirRecords.push(record.dirRecord);\n+    if(streamedContent) {\n+        \/\/ after the streamed file, we put data descriptors\n+        this.push({\n+            data : generateDataDescriptors(streamInfo),\n+            meta : {percent:100}\n+        });\n+    } else {\n+        \/\/ the content wasn't streamed, we need to push everything now\n+        \/\/ first the file record, then the content\n+        this.push({\n+            data : record.fileRecord,\n+            meta : {percent:0}\n+        });\n+        while(this.contentBuffer.length) {\n+            this.push(this.contentBuffer.shift());\n+        }\n+    }\n+    this.currentFile = null;\n+};\n+\n+\/**\n+ * @see GenericWorker.flush\n+ *\/\n+ZipFileWorker.prototype.flush = function () {\n+\n+    var localDirLength = this.bytesWritten;\n+    for(var i = 0; i < this.dirRecords.length; i++) {\n+        this.push({\n+            data : this.dirRecords[i],\n+            meta : {percent:100}\n+        });\n+    }\n+    var centralDirLength = this.bytesWritten - localDirLength;\n+\n+    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);\n+\n+    this.push({\n+        data : dirEnd,\n+        meta : {percent:100}\n+    });\n+};\n+\n+\/**\n+ * Prepare the next source to be read.\n+ *\/\n+ZipFileWorker.prototype.prepareNextSource = function () {\n+    this.previous = this._sources.shift();\n+    this.openedSource(this.previous.streamInfo);\n+    if (this.isPaused) {\n+        this.previous.pause();\n+    } else {\n+        this.previous.resume();\n+    }\n+};\n+\n+\/**\n+ * @see GenericWorker.registerPrevious\n+ *\/\n+ZipFileWorker.prototype.registerPrevious = function (previous) {\n+    this._sources.push(previous);\n+    var self = this;\n+\n+    previous.on('data', function (chunk) {\n+        self.processChunk(chunk);\n+    });\n+    previous.on('end', function () {\n+        self.closedSource(self.previous.streamInfo);\n+        if(self._sources.length) {\n+            self.prepareNextSource();\n+        } else {\n+            self.end();\n+        }\n+    });\n+    previous.on('error', function (e) {\n+        self.error(e);\n+    });\n+    return this;\n+};\n+\n+\/**\n+ * @see GenericWorker.resume\n+ *\/\n+ZipFileWorker.prototype.resume = function () {\n+    if(!GenericWorker.prototype.resume.call(this)) {\n+        return false;\n+    }\n+\n+    if (!this.previous && this._sources.length) {\n+        this.prepareNextSource();\n+        return true;\n+    }\n+    if (!this.previous && !this._sources.length && !this.generatedError) {\n+        this.end();\n+        return true;\n+    }\n+};\n+\n+\/**\n+ * @see GenericWorker.error\n+ *\/\n+ZipFileWorker.prototype.error = function (e) {\n+    var sources = this._sources;\n+    if(!GenericWorker.prototype.error.call(this, e)) {\n+        return false;\n+    }\n+    for(var i = 0; i < sources.length; i++) {\n+        try {\n+            sources[i].error(e);\n+        } catch(e) {\n+            \/\/ the `error` exploded, nothing to do\n+        }\n+    }\n+    return true;\n+};\n+\n+\/**\n+ * @see GenericWorker.lock\n+ *\/\n+ZipFileWorker.prototype.lock = function () {\n+    GenericWorker.prototype.lock.call(this);\n+    var sources = this._sources;\n+    for(var i = 0; i < sources.length; i++) {\n+        sources[i].lock();\n+    }\n+};\n+\n+module.exports = ZipFileWorker;\n+\n+},{\"..\/crc32\":4,\"..\/signature\":23,\"..\/stream\/GenericWorker\":28,\"..\/utf8\":31,\"..\/utils\":32}],9:[function(require,module,exports){\n+'use strict';\n+\n+var compressions = require('..\/compressions');\n+var ZipFileWorker = require('.\/ZipFileWorker');\n+\n+\/**\n+ * Find the compression to use.\n+ * @param {String} fileCompression the compression defined at the file level, if any.\n+ * @param {String} zipCompression the compression defined at the load() level.\n+ * @return {Object} the compression object to use.\n+ *\/\n+var getCompression = function (fileCompression, zipCompression) {\n+\n+    var compressionName = fileCompression || zipCompression;\n+    var compression = compressions[compressionName];\n+    if (!compression) {\n+        throw new Error(compressionName + \" is not a valid compression method !\");\n+    }\n+    return compression;\n+};\n+\n+\/**\n+ * Create a worker to generate a zip file.\n+ * @param {JSZip} zip the JSZip instance at the right root level.\n+ * @param {Object} options to generate the zip file.\n+ * @param {String} comment the comment to use.\n+ *\/\n+exports.generateWorker = function (zip, options, comment) {\n+\n+    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);\n+    var entriesCount = 0;\n+    try {\n+\n+        zip.forEach(function (relativePath, file) {\n+            entriesCount++;\n+            var compression = getCompression(file.options.compression, options.compression);\n+            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n+            var dir = file.dir, date = file.date;\n+\n+            file._compressWorker(compression, compressionOptions)\n+            .withStreamInfo(\"file\", {\n+                name : relativePath,\n+                dir : dir,\n+                date : date,\n+                comment : file.comment || \"\",\n+                unixPermissions : file.unixPermissions,\n+                dosPermissions : file.dosPermissions\n+            })\n+            .pipe(zipFileWorker);\n+        });\n+        zipFileWorker.entriesCount = entriesCount;\n+    } catch (e) {\n+        zipFileWorker.error(e);\n+    }\n+\n+    return zipFileWorker;\n+};\n+\n+},{\"..\/compressions\":3,\".\/ZipFileWorker\":8}],10:[function(require,module,exports){\n+'use strict';\n+\n+\/**\n+ * Representation a of zip file in js\n+ * @constructor\n+ *\/\n+function JSZip() {\n+    \/\/ if this constructor is used without `new`, it adds `new` before itself:\n+    if(!(this instanceof JSZip)) {\n+        return new JSZip();\n+    }\n+\n+    if(arguments.length) {\n+        throw new Error(\"The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.\");\n+    }\n+\n+    \/\/ object containing the files :\n+    \/\/ {\n+    \/\/   \"folder\/\" : {...},\n+    \/\/   \"folder\/data.txt\" : {...}\n+    \/\/ }\n+    \/\/ NOTE: we use a null prototype because we do not\n+    \/\/ want filenames like \"toString\" coming from a zip file\n+    \/\/ to overwrite methods and attributes in a normal Object.\n+    this.files = Object.create(null);\n+\n+    this.comment = null;\n+\n+    \/\/ Where we are in the hierarchy\n+    this.root = \"\";\n+    this.clone = function() {\n+        var newObj = new JSZip();\n+        for (var i in this) {\n+            if (typeof this[i] !== \"function\") {\n+                newObj[i] = this[i];\n+            }\n+        }\n+        return newObj;\n+    };\n+}\n+JSZip.prototype = require('.\/object');\n+JSZip.prototype.loadAsync = require('.\/load');\n+JSZip.support = require('.\/support');\n+JSZip.defaults = require('.\/defaults');\n+\n+\/\/ TODO find a better way to handle this version,\n+\/\/ a require('package.json').version doesn't work with webpack, see #327\n+JSZip.version = \"3.7.1\";\n+\n+JSZip.loadAsync = function (content, options) {\n+    return new JSZip().loadAsync(content, options);\n+};\n+\n+JSZip.external = require(\".\/external\");\n+module.exports = JSZip;\n+\n+},{\".\/defaults\":5,\".\/external\":6,\".\/load\":11,\".\/object\":15,\".\/support\":30}],11:[function(require,module,exports){\n+'use strict';\n+var utils = require('.\/utils');\n+var external = require(\".\/external\");\n+var utf8 = require('.\/utf8');\n+var ZipEntries = require('.\/zipEntries');\n+var Crc32Probe = require('.\/stream\/Crc32Probe');\n+var nodejsUtils = require(\".\/nodejsUtils\");\n+\n+\/**\n+ * Check the CRC32 of an entry.\n+ * @param {ZipEntry} zipEntry the zip entry to check.\n+ * @return {Promise} the result.\n+ *\/\n+function checkEntryCRC32(zipEntry) {\n+    return new external.Promise(function (resolve, reject) {\n+        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());\n+        worker.on(\"error\", function (e) {\n+            reject(e);\n+        })\n+            .on(\"end\", function () {\n+                if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {\n+                    reject(new Error(\"Corrupted zip : CRC32 mismatch\"));\n+                } else {\n+                    resolve();\n+                }\n+            })\n+            .resume();\n+    });\n+}\n+\n+module.exports = function (data, options) {\n+    var zip = this;\n+    options = utils.extend(options || {}, {\n+        base64: false,\n+        checkCRC32: false,\n+        optimizedBinaryString: false,\n+        createFolders: false,\n+        decodeFileName: utf8.utf8decode\n+    });\n+\n+    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n+        return external.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\"));\n+    }\n+\n+    return utils.prepareContent(\"the loaded zip file\", data, true, options.optimizedBinaryString, options.base64)\n+        .then(function (data) {\n+            var zipEntries = new ZipEntries(options);\n+            zipEntries.load(data);\n+            return zipEntries;\n+        }).then(function checkCRC32(zipEntries) {\n+            var promises = [external.Promise.resolve(zipEntries)];\n+            var files = zipEntries.files;\n+            if (options.checkCRC32) {\n+                for (var i = 0; i < files.length; i++) {\n+                    promises.push(checkEntryCRC32(files[i]));\n+                }\n+            }\n+            return external.Promise.all(promises);\n+        }).then(function addFiles(results) {\n+            var zipEntries = results.shift();\n+            var files = zipEntries.files;\n+            for (var i = 0; i < files.length; i++) {\n+                var input = files[i];\n+                zip.file(input.fileNameStr, input.decompressed, {\n+                    binary: true,\n+                    optimizedBinaryString: true,\n+                    date: input.date,\n+                    dir: input.dir,\n+                    comment: input.fileCommentStr.length ? input.fileCommentStr : null,\n+                    unixPermissions: input.unixPermissions,\n+                    dosPermissions: input.dosPermissions,\n+                    createFolders: options.createFolders\n+                });\n+            }\n+            if (zipEntries.zipComment.length) {\n+                zip.comment = zipEntries.zipComment;\n+            }\n+\n+            return zip;\n+        });\n+};\n+\n+},{\".\/external\":6,\".\/nodejsUtils\":14,\".\/stream\/Crc32Probe\":25,\".\/utf8\":31,\".\/utils\":32,\".\/zipEntries\":33}],12:[function(require,module,exports){\n+\"use strict\";\n+\n+var utils = require('..\/utils');\n+var GenericWorker = require('..\/stream\/GenericWorker');\n+\n+\/**\n+ * A worker that use a nodejs stream as source.\n+ * @constructor\n+ * @param {String} filename the name of the file entry for this stream.\n+ * @param {Readable} stream the nodejs stream.\n+ *\/\n+function NodejsStreamInputAdapter(filename, stream) {\n+    GenericWorker.call(this, \"Nodejs stream input adapter for \" + filename);\n+    this._upstreamEnded = false;\n+    this._bindStream(stream);\n+}\n+\n+utils.inherits(NodejsStreamInputAdapter, GenericWorker);\n+\n+\/**\n+ * Prepare the stream and bind the callbacks on it.\n+ * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.\n+ * @param {Stream} stream the nodejs stream to use.\n+ *\/\n+NodejsStreamInputAdapter.prototype._bindStream = function (stream) {\n+    var self = this;\n+    this._stream = stream;\n+    stream.pause();\n+    stream\n+    .on(\"data\", function (chunk) {\n+        self.push({\n+            data: chunk,\n+            meta : {\n+                percent : 0\n+            }\n+        });\n+    })\n+    .on(\"error\", function (e) {\n+        if(self.isPaused) {\n+            this.generatedError = e;\n+        } else {\n+            self.error(e);\n+        }\n+    })\n+    .on(\"end\", function () {\n+        if(self.isPaused) {\n+            self._upstreamEnded = true;\n+        } else {\n+            self.end();\n+        }\n+    });\n+};\n+NodejsStreamInputAdapter.prototype.pause = function () {\n+    if(!GenericWorker.prototype.pause.call(this)) {\n+        return false;\n+    }\n+    this._stream.pause();\n+    return true;\n+};\n+NodejsStreamInputAdapter.prototype.resume = function () {\n+    if(!GenericWorker.prototype.resume.call(this)) {\n+        return false;\n+    }\n+\n+    if(this._upstreamEnded) {\n+        this.end();\n+    } else {\n+        this._stream.resume();\n+    }\n+\n+    return true;\n+};\n+\n+module.exports = NodejsStreamInputAdapter;\n+\n+},{\"..\/stream\/GenericWorker\":28,\"..\/utils\":32}],13:[function(require,module,exports){\n+'use strict';\n+\n+var Readable = require('readable-stream').Readable;\n+\n+var utils = require('..\/utils');\n+utils.inherits(NodejsStreamOutputAdapter, Readable);\n+\n+\/**\n+* A nodejs stream using a worker as source.\n+* @see the SourceWrapper in http:\/\/nodejs.org\/api\/stream.html\n+* @constructor\n+* @param {StreamHelper} helper the helper wrapping the worker\n+* @param {Object} options the nodejs stream options\n+* @param {Function} updateCb the update callback.\n@@ -26,0 +1246,3 @@\n+function NodejsStreamOutputAdapter(helper, options, updateCb) {\n+    Readable.call(this, options);\n+    this._helper = helper;\n@@ -27,3 +1250,10120 @@\n-!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{(\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:this).JSZip=e()}}(function(){return function s(a,o,u){function h(r,e){if(!o[r]){if(!a[r]){var t=\"function\"==typeof require&&require;if(!e&&t)return t(r,!0);if(f)return f(r,!0);var n=new Error(\"Cannot find module '\"+r+\"'\");throw n.code=\"MODULE_NOT_FOUND\",n}var i=o[r]={exports:{}};a[r][0].call(i.exports,function(e){var t=a[r][1][e];return h(t||e)},i,i.exports,s,a,o,u)}return o[r].exports}for(var f=\"function\"==typeof require&&require,e=0;e<u.length;e++)h(u[e]);return h}({1:[function(l,t,n){(function(r){!function(e){\"object\"==typeof n&&void 0!==t?t.exports=e():(\"undefined\"!=typeof window?window:void 0!==r?r:\"undefined\"!=typeof self?self:this).JSZip=e()}(function(){return function s(a,o,u){function h(t,e){if(!o[t]){if(!a[t]){var r=\"function\"==typeof l&&l;if(!e&&r)return r(t,!0);if(f)return f(t,!0);var n=new Error(\"Cannot find module '\"+t+\"'\");throw n.code=\"MODULE_NOT_FOUND\",n}var i=o[t]={exports:{}};a[t][0].call(i.exports,function(e){return h(a[t][1][e]||e)},i,i.exports,s,a,o,u)}return o[t].exports}for(var f=\"function\"==typeof l&&l,e=0;e<u.length;e++)h(u[e]);return h}({1:[function(l,t,n){(function(r){!function(e){\"object\"==typeof n&&void 0!==t?t.exports=e():(\"undefined\"!=typeof window?window:void 0!==r?r:\"undefined\"!=typeof self?self:this).JSZip=e()}(function(){return function s(a,o,u){function h(t,e){if(!o[t]){if(!a[t]){var r=\"function\"==typeof l&&l;if(!e&&r)return r(t,!0);if(f)return f(t,!0);var n=new Error(\"Cannot find module '\"+t+\"'\");throw n.code=\"MODULE_NOT_FOUND\",n}var i=o[t]={exports:{}};a[t][0].call(i.exports,function(e){return h(a[t][1][e]||e)},i,i.exports,s,a,o,u)}return o[t].exports}for(var f=\"function\"==typeof l&&l,e=0;e<u.length;e++)h(u[e]);return h}({1:[function(l,t,n){(function(r){!function(e){\"object\"==typeof n&&void 0!==t?t.exports=e():(\"undefined\"!=typeof window?window:void 0!==r?r:\"undefined\"!=typeof self?self:this).JSZip=e()}(function(){return function s(a,o,u){function h(t,e){if(!o[t]){if(!a[t]){var r=\"function\"==typeof l&&l;if(!e&&r)return r(t,!0);if(f)return f(t,!0);var n=new Error(\"Cannot find module '\"+t+\"'\");throw n.code=\"MODULE_NOT_FOUND\",n}var i=o[t]={exports:{}};a[t][0].call(i.exports,function(e){return h(a[t][1][e]||e)},i,i.exports,s,a,o,u)}return o[t].exports}for(var f=\"function\"==typeof l&&l,e=0;e<u.length;e++)h(u[e]);return h}({1:[function(l,t,n){(function(r){!function(e){\"object\"==typeof n&&void 0!==t?t.exports=e():(\"undefined\"!=typeof window?window:void 0!==r?r:\"undefined\"!=typeof self?self:this).JSZip=e()}(function(){return function s(a,o,u){function h(t,e){if(!o[t]){if(!a[t]){var r=\"function\"==typeof l&&l;if(!e&&r)return r(t,!0);if(f)return f(t,!0);var n=new Error(\"Cannot find module '\"+t+\"'\");throw n.code=\"MODULE_NOT_FOUND\",n}var i=o[t]={exports:{}};a[t][0].call(i.exports,function(e){return h(a[t][1][e]||e)},i,i.exports,s,a,o,u)}return o[t].exports}for(var f=\"function\"==typeof l&&l,e=0;e<u.length;e++)h(u[e]);return h}({1:[function(e,t,r){\"use strict\";var c=e(\".\/utils\"),l=e(\".\/support\"),p=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/=\";r.encode=function(e){for(var t,r,n,i,s,a,o,u=[],h=0,f=e.length,l=f,d=\"string\"!==c.getTypeOf(e);h<e.length;)l=f-h,n=d?(t=e[h++],r=h<f?e[h++]:0,h<f?e[h++]:0):(t=e.charCodeAt(h++),r=h<f?e.charCodeAt(h++):0,h<f?e.charCodeAt(h++):0),i=t>>2,s=(3&t)<<4|r>>4,a=1<l?(15&r)<<2|n>>6:64,o=2<l?63&n:64,u.push(p.charAt(i)+p.charAt(s)+p.charAt(a)+p.charAt(o));return u.join(\"\")},r.decode=function(e){var t,r,n,i,s,a,o=0,u=0;if(\"data:\"===e.substr(0,\"data:\".length))throw new Error(\"Invalid base64 input, it looks like a data url.\");var h,f=3*(e=e.replace(\/[^A-Za-z0-9\\+\\\/\\=]\/g,\"\")).length\/4;if(e.charAt(e.length-1)===p.charAt(64)&&f--,e.charAt(e.length-2)===p.charAt(64)&&f--,f%1!=0)throw new Error(\"Invalid base64 input, bad content length.\");for(h=l.uint8array?new Uint8Array(0|f):new Array(0|f);o<e.length;)t=p.indexOf(e.charAt(o++))<<2|(i=p.indexOf(e.charAt(o++)))>>4,r=(15&i)<<4|(s=p.indexOf(e.charAt(o++)))>>2,n=(3&s)<<6|(a=p.indexOf(e.charAt(o++))),h[u++]=t,64!==s&&(h[u++]=r),64!==a&&(h[u++]=n);return h}},{\".\/support\":30,\".\/utils\":32}],2:[function(e,t,r){\"use strict\";var n=e(\".\/external\"),i=e(\".\/stream\/DataWorker\"),s=e(\".\/stream\/Crc32Probe\"),a=e(\".\/stream\/DataLengthProbe\");function o(e,t,r,n,i){this.compressedSize=e,this.uncompressedSize=t,this.crc32=r,this.compression=n,this.compressedContent=i}o.prototype={getContentWorker:function(){var e=new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a(\"data_length\")),t=this;return e.on(\"end\",function(){if(this.streamInfo.data_length!==t.uncompressedSize)throw new Error(\"Bug : uncompressed data size mismatch\")}),e},getCompressedWorker:function(){return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo(\"compressedSize\",this.compressedSize).withStreamInfo(\"uncompressedSize\",this.uncompressedSize).withStreamInfo(\"crc32\",this.crc32).withStreamInfo(\"compression\",this.compression)}},o.createWorkerFrom=function(e,t,r){return e.pipe(new s).pipe(new a(\"uncompressedSize\")).pipe(t.compressWorker(r)).pipe(new a(\"compressedSize\")).withStreamInfo(\"compression\",t)},t.exports=o},{\".\/external\":6,\".\/stream\/Crc32Probe\":25,\".\/stream\/DataLengthProbe\":26,\".\/stream\/DataWorker\":27}],3:[function(e,t,r){\"use strict\";var n=e(\".\/stream\/GenericWorker\");r.STORE={magic:\"\\0\\0\",compressWorker:function(e){return new n(\"STORE compression\")},uncompressWorker:function(){return new n(\"STORE decompression\")}},r.DEFLATE=e(\".\/flate\")},{\".\/flate\":7,\".\/stream\/GenericWorker\":28}],4:[function(e,t,r){\"use strict\";var n=e(\".\/utils\"),a=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t}();t.exports=function(e,t){return void 0!==e&&e.length?\"string\"!==n.getTypeOf(e)?function(e,t,r){var n=a,i=0+r;e^=-1;for(var s=0;s<i;s++)e=e>>>8^n[255&(e^t[s])];return-1^e}(0|t,e,e.length):function(e,t,r){var n=a,i=0+r;e^=-1;for(var s=0;s<i;s++)e=e>>>8^n[255&(e^t.charCodeAt(s))];return-1^e}(0|t,e,e.length):0}},{\".\/utils\":32}],5:[function(e,t,r){\"use strict\";r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!0,r.date=null,r.compression=null,r.compressionOptions=null,r.comment=null,r.unixPermissions=null,r.dosPermissions=null},{}],6:[function(e,t,r){\"use strict\";var n;n=\"undefined\"!=typeof Promise?Promise:e(\"lie\"),t.exports={Promise:n}},{lie:37}],7:[function(e,t,r){\"use strict\";var n=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Uint32Array,i=e(\"pako\"),s=e(\".\/utils\"),a=e(\".\/stream\/GenericWorker\"),o=n?\"uint8array\":\"array\";function u(e,t){a.call(this,\"FlateWorker\/\"+e),this._pako=null,this._pakoAction=e,this._pakoOptions=t,this.meta={}}r.magic=\"\\b\\0\",s.inherits(u,a),u.prototype.processChunk=function(e){this.meta=e.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,e.data),!1)},u.prototype.flush=function(){a.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},u.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null},u.prototype._createPako=function(){this._pako=new i[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var t=this;this._pako.onData=function(e){t.push({data:e,meta:t.meta})}},r.compressWorker=function(e){return new u(\"Deflate\",e)},r.uncompressWorker=function(){return new u(\"Inflate\",{})}},{\".\/stream\/GenericWorker\":28,\".\/utils\":32,pako:38}],8:[function(e,t,r){\"use strict\";function I(e,t){var r,n=\"\";for(r=0;r<t;r++)n+=String.fromCharCode(255&e),e>>>=8;return n}function i(e,t,r,n,i,s){var a,o,u=e.file,h=e.compression,f=s!==B.utf8encode,l=O.transformTo(\"string\",s(u.name)),d=O.transformTo(\"string\",B.utf8encode(u.name)),c=u.comment,p=O.transformTo(\"string\",s(c)),m=O.transformTo(\"string\",B.utf8encode(c)),_=d.length!==u.name.length,g=m.length!==c.length,v=\"\",b=\"\",w=\"\",y=u.dir,k=u.date,x={crc32:0,compressedSize:0,uncompressedSize:0};t&&!r||(x.crc32=e.crc32,x.compressedSize=e.compressedSize,x.uncompressedSize=e.uncompressedSize);var S=0;t&&(S|=8),f||!_&&!g||(S|=2048);var z,C=0,E=0;y&&(C|=16),\"UNIX\"===i?(E=798,C|=((z=u.unixPermissions)||(z=y?16893:33204),(65535&z)<<16)):(E=20,C|=63&(u.dosPermissions||0)),a=k.getUTCHours(),a<<=6,a|=k.getUTCMinutes(),a<<=5,a|=k.getUTCSeconds()\/2,o=k.getUTCFullYear()-1980,o<<=4,o|=k.getUTCMonth()+1,o<<=5,o|=k.getUTCDate(),_&&(v+=\"up\"+I((b=I(1,1)+I(R(l),4)+d).length,2)+b),g&&(v+=\"uc\"+I((w=I(1,1)+I(R(p),4)+m).length,2)+w);var A=\"\";return A+=\"\\n\\0\",A+=I(S,2),A+=h.magic,A+=I(a,2),A+=I(o,2),A+=I(x.crc32,4),A+=I(x.compressedSize,4),A+=I(x.uncompressedSize,4),A+=I(l.length,2),A+=I(v.length,2),{fileRecord:T.LOCAL_FILE_HEADER+A+l+v,dirRecord:T.CENTRAL_FILE_HEADER+I(E,2)+A+I(p.length,2)+\"\\0\\0\\0\\0\"+I(C,4)+I(n,4)+l+v+p}}var O=e(\"..\/utils\"),s=e(\"..\/stream\/GenericWorker\"),B=e(\"..\/utf8\"),R=e(\"..\/crc32\"),T=e(\"..\/signature\");function n(e,t,r,n){s.call(this,\"ZipFileWorker\"),this.bytesWritten=0,this.zipComment=t,this.zipPlatform=r,this.encodeFileName=n,this.streamFiles=e,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}O.inherits(n,s),n.prototype.push=function(e){var t=e.meta.percent||0,r=this.entriesCount,n=this._sources.length;this.accumulate?this.contentBuffer.push(e):(this.bytesWritten+=e.data.length,s.prototype.push.call(this,{data:e.data,meta:{currentFile:this.currentFile,percent:r?(t+100*(r-n-1))\/r:100}}))},n.prototype.openedSource=function(e){this.currentSourceOffset=this.bytesWritten,this.currentFile=e.file.name;var t=this.streamFiles&&!e.file.dir;if(t){var r=i(e,t,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:r.fileRecord,meta:{percent:0}})}else this.accumulate=!0},n.prototype.closedSource=function(e){this.accumulate=!1;var t,r=this.streamFiles&&!e.file.dir,n=i(e,r,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(n.dirRecord),r)this.push({data:(t=e,T.DATA_DESCRIPTOR+I(t.crc32,4)+I(t.compressedSize,4)+I(t.uncompressedSize,4)),meta:{percent:100}});else for(this.push({data:n.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},n.prototype.flush=function(){for(var e=this.bytesWritten,t=0;t<this.dirRecords.length;t++)this.push({data:this.dirRecords[t],meta:{percent:100}});var r,n,i,s,a,o,u=this.bytesWritten-e,h=(r=this.dirRecords.length,n=u,i=e,s=this.zipComment,a=this.encodeFileName,o=O.transformTo(\"string\",a(s)),T.CENTRAL_DIRECTORY_END+\"\\0\\0\\0\\0\"+I(r,2)+I(r,2)+I(n,4)+I(i,4)+I(o.length,2)+o);this.push({data:h,meta:{percent:100}})},n.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},n.prototype.registerPrevious=function(e){this._sources.push(e);var t=this;return e.on(\"data\",function(e){t.processChunk(e)}),e.on(\"end\",function(){t.closedSource(t.previous.streamInfo),t._sources.length?t.prepareNextSource():t.end()}),e.on(\"error\",function(e){t.error(e)}),this},n.prototype.resume=function(){return!!s.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},n.prototype.error=function(e){var t=this._sources;if(!s.prototype.error.call(this,e))return!1;for(var r=0;r<t.length;r++)try{t[r].error(e)}catch(e){}return!0},n.prototype.lock=function(){s.prototype.lock.call(this);for(var e=this._sources,t=0;t<e.length;t++)e[t].lock()},t.exports=n},{\"..\/crc32\":4,\"..\/signature\":23,\"..\/stream\/GenericWorker\":28,\"..\/utf8\":31,\"..\/utils\":32}],9:[function(e,t,r){\"use strict\";var h=e(\"..\/compressions\"),n=e(\".\/ZipFileWorker\");r.generateWorker=function(e,a,t){var o=new n(a.streamFiles,t,a.platform,a.encodeFileName),u=0;try{e.forEach(function(e,t){u++;var r=function(e,t){var r=e||t,n=h[r];if(!n)throw new Error(r+\" is not a valid compression method !\");return n}(t.options.compression,a.compression),n=t.options.compressionOptions||a.compressionOptions||{},i=t.dir,s=t.date;t._compressWorker(r,n).withStreamInfo(\"file\",{name:e,dir:i,date:s,comment:t.comment||\"\",unixPermissions:t.unixPermissions,dosPermissions:t.dosPermissions}).pipe(o)}),o.entriesCount=u}catch(e){o.error(e)}return o}},{\"..\/compressions\":3,\".\/ZipFileWorker\":8}],10:[function(e,t,r){\"use strict\";function n(){if(!(this instanceof n))return new n;if(arguments.length)throw new Error(\"The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.\");this.files={},this.comment=null,this.root=\"\",this.clone=function(){var e=new n;for(var t in this)\"function\"!=typeof this[t]&&(e[t]=this[t]);return e}}(n.prototype=e(\".\/object\")).loadAsync=e(\".\/load\"),n.support=e(\".\/support\"),n.defaults=e(\".\/defaults\"),n.version=\"3.5.0\",n.loadAsync=function(e,t){return(new n).loadAsync(e,t)},n.external=e(\".\/external\"),t.exports=n},{\".\/defaults\":5,\".\/external\":6,\".\/load\":11,\".\/object\":15,\".\/support\":30}],11:[function(e,t,r){\"use strict\";var n=e(\".\/utils\"),i=e(\".\/external\"),o=e(\".\/utf8\"),u=e(\".\/zipEntries\"),s=e(\".\/stream\/Crc32Probe\"),h=e(\".\/nodejsUtils\");function f(n){return new i.Promise(function(e,t){var r=n.decompressed.getContentWorker().pipe(new s);r.on(\"error\",function(e){t(e)}).on(\"end\",function(){r.streamInfo.crc32!==n.decompressed.crc32?t(new Error(\"Corrupted zip : CRC32 mismatch\")):e()}).resume()})}t.exports=function(e,s){var a=this;return s=n.extend(s||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:o.utf8decode}),h.isNode&&h.isStream(e)?i.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\")):n.prepareContent(\"the loaded zip file\",e,!0,s.optimizedBinaryString,s.base64).then(function(e){var t=new u(s);return t.load(e),t}).then(function(e){var t=[i.Promise.resolve(e)],r=e.files;if(s.checkCRC32)for(var n=0;n<r.length;n++)t.push(f(r[n]));return i.Promise.all(t)}).then(function(e){for(var t=e.shift(),r=t.files,n=0;n<r.length;n++){var i=r[n];a.file(i.fileNameStr,i.decompressed,{binary:!0,optimizedBinaryString:!0,date:i.date,dir:i.dir,comment:i.fileCommentStr.length?i.fileCommentStr:null,unixPermissions:i.unixPermissions,dosPermissions:i.dosPermissions,createFolders:s.createFolders})}return t.zipComment.length&&(a.comment=t.zipComment),a})}},{\".\/external\":6,\".\/nodejsUtils\":14,\".\/stream\/Crc32Probe\":25,\".\/utf8\":31,\".\/utils\":32,\".\/zipEntries\":33}],12:[function(e,t,r){\"use strict\";var n=e(\"..\/utils\"),i=e(\"..\/stream\/GenericWorker\");function s(e,t){i.call(this,\"Nodejs stream input adapter for \"+e),this._upstreamEnded=!1,this._bindStream(t)}n.inherits(s,i),s.prototype._bindStream=function(e){var t=this;(this._stream=e).pause(),e.on(\"data\",function(e){t.push({data:e,meta:{percent:0}})}).on(\"error\",function(e){t.isPaused?this.generatedError=e:t.error(e)}).on(\"end\",function(){t.isPaused?t._upstreamEnded=!0:t.end()})},s.prototype.pause=function(){return!!i.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return!!i.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},t.exports=s},{\"..\/stream\/GenericWorker\":28,\"..\/utils\":32}],13:[function(e,t,r){\"use strict\";var i=e(\"readable-stream\").Readable;function n(e,t,r){i.call(this,t),this._helper=e;var n=this;e.on(\"data\",function(e,t){n.push(e)||n._helper.pause(),r&&r(t)}).on(\"error\",function(e){n.emit(\"error\",e)}).on(\"end\",function(){n.push(null)})}e(\"..\/utils\").inherits(n,i),n.prototype._read=function(){this._helper.resume()},t.exports=n},{\"..\/utils\":32,\"readable-stream\":16}],14:[function(e,t,r){\"use strict\";t.exports={isNode:\"undefined\"!=typeof Buffer,newBufferFrom:function(e,t){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(e,t);if(\"number\"==typeof e)throw new Error('The \"data\" argument must not be a number');return new Buffer(e,t)},allocBuffer:function(e){if(Buffer.alloc)return Buffer.alloc(e);var t=new Buffer(e);return t.fill(0),t},isBuffer:function(e){return Buffer.isBuffer(e)},isStream:function(e){return e&&\"function\"==typeof e.on&&\"function\"==typeof e.pause&&\"function\"==typeof e.resume}}},{}],15:[function(e,t,r){\"use strict\";function s(e,t,r){var n,i=f.getTypeOf(t),s=f.extend(r||{},d);s.date=s.date||new Date,null!==s.compression&&(s.compression=s.compression.toUpperCase()),\"string\"==typeof s.unixPermissions&&(s.unixPermissions=parseInt(s.unixPermissions,8)),s.unixPermissions&&16384&s.unixPermissions&&(s.dir=!0),s.dosPermissions&&16&s.dosPermissions&&(s.dir=!0),s.dir&&(e=h(e)),s.createFolders&&(n=function(e){\"\/\"===e.slice(-1)&&(e=e.substring(0,e.length-1));var t=e.lastIndexOf(\"\/\");return 0<t?e.substring(0,t):\"\"}(e))&&g.call(this,n,!0);var a,o=\"string\"===i&&!1===s.binary&&!1===s.base64;r&&void 0!==r.binary||(s.binary=!o),(t instanceof c&&0===t.uncompressedSize||s.dir||!t||0===t.length)&&(s.base64=!1,s.binary=!0,t=\"\",s.compression=\"STORE\",i=\"string\"),a=t instanceof c||t instanceof l?t:m.isNode&&m.isStream(t)?new _(e,t):f.prepareContent(e,t,s.binary,s.optimizedBinaryString,s.base64);var u=new p(e,a,s);this.files[e]=u}function h(e){return\"\/\"!==e.slice(-1)&&(e+=\"\/\"),e}var i=e(\".\/utf8\"),f=e(\".\/utils\"),l=e(\".\/stream\/GenericWorker\"),a=e(\".\/stream\/StreamHelper\"),d=e(\".\/defaults\"),c=e(\".\/compressedObject\"),p=e(\".\/zipObject\"),o=e(\".\/generate\"),m=e(\".\/nodejsUtils\"),_=e(\".\/nodejs\/NodejsStreamInputAdapter\"),g=function(e,t){return t=void 0!==t?t:d.createFolders,e=h(e),this.files[e]||s.call(this,e,null,{dir:!0,createFolders:t}),this.files[e]};function u(e){return\"[object RegExp]\"===Object.prototype.toString.call(e)}var n={load:function(){throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\")},forEach:function(e){var t,r,n;for(t in this.files)this.files.hasOwnProperty(t)&&(n=this.files[t],(r=t.slice(this.root.length,t.length))&&t.slice(0,this.root.length)===this.root&&e(r,n))},filter:function(r){var n=[];return this.forEach(function(e,t){r(e,t)&&n.push(t)}),n},file:function(e,t,r){if(1!==arguments.length)return e=this.root+e,s.call(this,e,t,r),this;if(u(e)){var n=e;return this.filter(function(e,t){return!t.dir&&n.test(e)})}var i=this.files[this.root+e];return i&&!i.dir?i:null},folder:function(r){if(!r)return this;if(u(r))return this.filter(function(e,t){return t.dir&&r.test(e)});var e=this.root+r,t=g.call(this,e),n=this.clone();return n.root=t.name,n},remove:function(r){r=this.root+r;var e=this.files[r];if(e||(\"\/\"!==r.slice(-1)&&(r+=\"\/\"),e=this.files[r]),e&&!e.dir)delete this.files[r];else for(var t=this.filter(function(e,t){return t.name.slice(0,r.length)===r}),n=0;n<t.length;n++)delete this.files[t[n].name];return this},generate:function(e){throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\")},generateInternalStream:function(e){var t,r={};try{if((r=f.extend(e||{},{streamFiles:!1,compression:\"STORE\",compressionOptions:null,type:\"\",platform:\"DOS\",comment:null,mimeType:\"application\/zip\",encodeFileName:i.utf8encode})).type=r.type.toLowerCase(),r.compression=r.compression.toUpperCase(),\"binarystring\"===r.type&&(r.type=\"string\"),!r.type)throw new Error(\"No output type specified.\");f.checkSupport(r.type),\"darwin\"!==r.platform&&\"freebsd\"!==r.platform&&\"linux\"!==r.platform&&\"sunos\"!==r.platform||(r.platform=\"UNIX\"),\"win32\"===r.platform&&(r.platform=\"DOS\");var n=r.comment||this.comment||\"\";t=o.generateWorker(this,r,n)}catch(e){(t=new l(\"error\")).error(e)}return new a(t,r.type||\"string\",r.mimeType)},generateAsync:function(e,t){return this.generateInternalStream(e).accumulate(t)},generateNodeStream:function(e,t){return(e=e||{}).type||(e.type=\"nodebuffer\"),this.generateInternalStream(e).toNodejsStream(t)}};t.exports=n},{\".\/compressedObject\":2,\".\/defaults\":5,\".\/generate\":9,\".\/nodejs\/NodejsStreamInputAdapter\":12,\".\/nodejsUtils\":14,\".\/stream\/GenericWorker\":28,\".\/stream\/StreamHelper\":29,\".\/utf8\":31,\".\/utils\":32,\".\/zipObject\":35}],16:[function(e,t,r){t.exports=e(\"stream\")},{stream:void 0}],17:[function(e,t,r){\"use strict\";var n=e(\".\/DataReader\");function i(e){n.call(this,e);for(var t=0;t<this.data.length;t++)e[t]=255&e[t]}e(\"..\/utils\").inherits(i,n),i.prototype.byteAt=function(e){return this.data[this.zero+e]},i.prototype.lastIndexOfSignature=function(e){for(var t=e.charCodeAt(0),r=e.charCodeAt(1),n=e.charCodeAt(2),i=e.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===t&&this.data[s+1]===r&&this.data[s+2]===n&&this.data[s+3]===i)return s-this.zero;return-1},i.prototype.readAndCheckSignature=function(e){var t=e.charCodeAt(0),r=e.charCodeAt(1),n=e.charCodeAt(2),i=e.charCodeAt(3),s=this.readData(4);return t===s[0]&&r===s[1]&&n===s[2]&&i===s[3]},i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return[];var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i},{\"..\/utils\":32,\".\/DataReader\":18}],18:[function(e,t,r){\"use strict\";var n=e(\"..\/utils\");function i(e){this.data=e,this.length=e.length,this.index=0,this.zero=0}i.prototype={checkOffset:function(e){this.checkIndex(this.index+e)},checkIndex:function(e){if(this.length<this.zero+e||e<0)throw new Error(\"End of data reached (data length = \"+this.length+\", asked index = \"+e+\"). Corrupted zip ?\")},setIndex:function(e){this.checkIndex(e),this.index=e},skip:function(e){this.setIndex(this.index+e)},byteAt:function(e){},readInt:function(e){var t,r=0;for(this.checkOffset(e),t=this.index+e-1;t>=this.index;t--)r=(r<<8)+this.byteAt(t);return this.index+=e,r},readString:function(e){return n.transformTo(\"string\",this.readData(e))},readData:function(e){},lastIndexOfSignature:function(e){},readAndCheckSignature:function(e){},readDate:function(){var e=this.readInt(4);return new Date(Date.UTC(1980+(e>>25&127),(e>>21&15)-1,e>>16&31,e>>11&31,e>>5&63,(31&e)<<1))}},t.exports=i},{\"..\/utils\":32}],19:[function(e,t,r){\"use strict\";var n=e(\".\/Uint8ArrayReader\");function i(e){n.call(this,e)}e(\"..\/utils\").inherits(i,n),i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i},{\"..\/utils\":32,\".\/Uint8ArrayReader\":21}],20:[function(e,t,r){\"use strict\";var n=e(\".\/DataReader\");function i(e){n.call(this,e)}e(\"..\/utils\").inherits(i,n),i.prototype.byteAt=function(e){return this.data.charCodeAt(this.zero+e)},i.prototype.lastIndexOfSignature=function(e){return this.data.lastIndexOf(e)-this.zero},i.prototype.readAndCheckSignature=function(e){return e===this.readData(4)},i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i},{\"..\/utils\":32,\".\/DataReader\":18}],21:[function(e,t,r){\"use strict\";var n=e(\".\/ArrayReader\");function i(e){n.call(this,e)}e(\"..\/utils\").inherits(i,n),i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return new Uint8Array(0);var t=this.data.subarray(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i},{\"..\/utils\":32,\".\/ArrayReader\":17}],22:[function(e,t,r){\"use strict\";var n=e(\"..\/utils\"),i=e(\"..\/support\"),s=e(\".\/ArrayReader\"),a=e(\".\/StringReader\"),o=e(\".\/NodeBufferReader\"),u=e(\".\/Uint8ArrayReader\");t.exports=function(e){var t=n.getTypeOf(e);return n.checkSupport(t),\"string\"!==t||i.uint8array?\"nodebuffer\"===t?new o(e):i.uint8array?new u(n.transformTo(\"uint8array\",e)):new s(n.transformTo(\"array\",e)):new a(e)}},{\"..\/support\":30,\"..\/utils\":32,\".\/ArrayReader\":17,\".\/NodeBufferReader\":19,\".\/StringReader\":20,\".\/Uint8ArrayReader\":21}],23:[function(e,t,r){\"use strict\";r.LOCAL_FILE_HEADER=\"PK\",r.CENTRAL_FILE_HEADER=\"PK\",r.CENTRAL_DIRECTORY_END=\"PK\",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR=\"PK\",r.ZIP64_CENTRAL_DIRECTORY_END=\"PK\",r.DATA_DESCRIPTOR=\"PK\\b\"},{}],24:[function(e,t,r){\"use strict\";var n=e(\".\/GenericWorker\"),i=e(\"..\/utils\");function s(e){n.call(this,\"ConvertWorker to \"+e),this.destType=e}i.inherits(s,n),s.prototype.processChunk=function(e){this.push({data:i.transformTo(this.destType,e.data),meta:e.meta})},t.exports=s},{\"..\/utils\":32,\".\/GenericWorker\":28}],25:[function(e,t,r){\"use strict\";var n=e(\".\/GenericWorker\"),i=e(\"..\/crc32\");function s(){n.call(this,\"Crc32Probe\"),this.withStreamInfo(\"crc32\",0)}e(\"..\/utils\").inherits(s,n),s.prototype.processChunk=function(e){this.streamInfo.crc32=i(e.data,this.streamInfo.crc32||0),this.push(e)},t.exports=s},{\"..\/crc32\":4,\"..\/utils\":32,\".\/GenericWorker\":28}],26:[function(e,t,r){\"use strict\";var n=e(\"..\/utils\"),i=e(\".\/GenericWorker\");function s(e){i.call(this,\"DataLengthProbe for \"+e),this.propName=e,this.withStreamInfo(e,0)}n.inherits(s,i),s.prototype.processChunk=function(e){if(e){var t=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=t+e.data.length}i.prototype.processChunk.call(this,e)},t.exports=s},{\"..\/utils\":32,\".\/GenericWorker\":28}],27:[function(e,t,r){\"use strict\";var n=e(\"..\/utils\"),i=e(\".\/GenericWorker\");function s(e){i.call(this,\"DataWorker\");var t=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type=\"\",this._tickScheduled=!1,e.then(function(e){t.dataIsReady=!0,t.data=e,t.max=e&&e.length||0,t.type=n.getTypeOf(e),t.isPaused||t._tickAndRepeat()},function(e){t.error(e)})}n.inherits(s,i),s.prototype.cleanUp=function(){i.prototype.cleanUp.call(this),this.data=null},s.prototype.resume=function(){return!!i.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,n.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(n.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var e=null,t=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case\"string\":e=this.data.substring(this.index,t);break;case\"uint8array\":e=this.data.subarray(this.index,t);break;case\"array\":case\"nodebuffer\":e=this.data.slice(this.index,t)}return this.index=t,this.push({data:e,meta:{percent:this.max?this.index\/this.max*100:0}})},t.exports=s},{\"..\/utils\":32,\".\/GenericWorker\":28}],28:[function(e,t,r){\"use strict\";function n(e){this.name=e||\"default\",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}n.prototype={push:function(e){this.emit(\"data\",e)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit(\"end\"),this.cleanUp(),this.isFinished=!0}catch(e){this.emit(\"error\",e)}return!0},error:function(e){return!this.isFinished&&(this.isPaused?this.generatedError=e:(this.isFinished=!0,this.emit(\"error\",e),this.previous&&this.previous.error(e),this.cleanUp()),!0)},on:function(e,t){return this._listeners[e].push(t),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(e,t){if(this._listeners[e])for(var r=0;r<this._listeners[e].length;r++)this._listeners[e][r].call(this,t)},pipe:function(e){return e.registerPrevious(this)},registerPrevious:function(e){if(this.isLocked)throw new Error(\"The stream '\"+this+\"' has already been used.\");this.streamInfo=e.streamInfo,this.mergeStreamInfo(),this.previous=e;var t=this;return e.on(\"data\",function(e){t.processChunk(e)}),e.on(\"end\",function(){t.end()}),e.on(\"error\",function(e){t.error(e)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var e=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),e=!0),this.previous&&this.previous.resume(),!e},flush:function(){},processChunk:function(e){this.push(e)},withStreamInfo:function(e,t){return this.extraStreamInfo[e]=t,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var e in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(e)&&(this.streamInfo[e]=this.extraStreamInfo[e])},lock:function(){if(this.isLocked)throw new Error(\"The stream '\"+this+\"' has already been used.\");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var e=\"Worker \"+this.name;return this.previous?this.previous+\" -> \"+e:e}},t.exports=n},{}],29:[function(e,t,r){\"use strict\";var h=e(\"..\/utils\"),i=e(\".\/ConvertWorker\"),s=e(\".\/GenericWorker\"),f=e(\"..\/base64\"),n=e(\"..\/support\"),a=e(\"..\/external\"),o=null;if(n.nodestream)try{o=e(\"..\/nodejs\/NodejsStreamOutputAdapter\")}catch(e){}function u(e,t,r){var n=t;switch(t){case\"blob\":case\"arraybuffer\":n=\"uint8array\";break;case\"base64\":n=\"string\"}try{this._internalType=n,this._outputType=t,this._mimeType=r,h.checkSupport(n),this._worker=e.pipe(new i(n)),e.lock()}catch(e){this._worker=new s(\"error\"),this._worker.error(e)}}u.prototype={accumulate:function(e){return o=this,u=e,new a.Promise(function(t,r){var n=[],i=o._internalType,s=o._outputType,a=o._mimeType;o.on(\"data\",function(e,t){n.push(e),u&&u(t)}).on(\"error\",function(e){n=[],r(e)}).on(\"end\",function(){try{var e=function(e,t,r){switch(e){case\"blob\":return h.newBlob(h.transformTo(\"arraybuffer\",t),r);case\"base64\":return f.encode(t);default:return h.transformTo(e,t)}}(s,function(e,t){var r,n=0,i=null,s=0;for(r=0;r<t.length;r++)s+=t[r].length;switch(e){case\"string\":return t.join(\"\");case\"array\":return Array.prototype.concat.apply([],t);case\"uint8array\":for(i=new Uint8Array(s),r=0;r<t.length;r++)i.set(t[r],n),n+=t[r].length;return i;case\"nodebuffer\":return Buffer.concat(t);default:throw new Error(\"concat : unsupported type '\"+e+\"'\")}}(i,n),a);t(e)}catch(e){r(e)}n=[]}).resume()});var o,u},on:function(e,t){var r=this;return\"data\"===e?this._worker.on(e,function(e){t.call(r,e.data,e.meta)}):this._worker.on(e,function(){h.delay(t,arguments,r)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(e){if(h.checkSupport(\"nodestream\"),\"nodebuffer\"!==this._outputType)throw new Error(this._outputType+\" is not supported by this method\");return new o(this,{objectMode:\"nodebuffer\"!==this._outputType},e)}},t.exports=u},{\"..\/base64\":1,\"..\/external\":6,\"..\/nodejs\/NodejsStreamOutputAdapter\":13,\"..\/support\":30,\"..\/utils\":32,\".\/ConvertWorker\":24,\".\/GenericWorker\":28}],30:[function(e,t,r){\"use strict\";if(r.base64=!0,r.array=!0,r.string=!0,r.arraybuffer=\"undefined\"!=typeof ArrayBuffer&&\"undefined\"!=typeof Uint8Array,r.nodebuffer=\"undefined\"!=typeof Buffer,r.uint8array=\"undefined\"!=typeof Uint8Array,\"undefined\"==typeof ArrayBuffer)r.blob=!1;else{var n=new ArrayBuffer(0);try{r.blob=0===new Blob([n],{type:\"application\/zip\"}).size}catch(e){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);i.append(n),r.blob=0===i.getBlob(\"application\/zip\").size}catch(e){r.blob=!1}}}try{r.nodestream=!!e(\"readable-stream\").Readable}catch(e){r.nodestream=!1}},{\"readable-stream\":16}],31:[function(e,t,s){\"use strict\";for(var o=e(\".\/utils\"),u=e(\".\/support\"),r=e(\".\/nodejsUtils\"),n=e(\".\/stream\/GenericWorker\"),h=new Array(256),i=0;i<256;i++)h[i]=252<=i?6:248<=i?5:240<=i?4:224<=i?3:192<=i?2:1;function a(){n.call(this,\"utf-8 decode\"),this.leftOver=null}function f(){n.call(this,\"utf-8 encode\")}h[254]=h[254]=1,s.utf8encode=function(e){return u.nodebuffer?r.newBufferFrom(e,\"utf-8\"):function(e){var t,r,n,i,s,a=e.length,o=0;for(i=0;i<a;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),o+=r<128?1:r<2048?2:r<65536?3:4;for(t=u.uint8array?new Uint8Array(o):new Array(o),i=s=0;s<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[s++]=r:(r<2048?t[s++]=192|r>>>6:(r<65536?t[s++]=224|r>>>12:(t[s++]=240|r>>>18,t[s++]=128|r>>>12&63),t[s++]=128|r>>>6&63),t[s++]=128|63&r);return t}(e)},s.utf8decode=function(e){return u.nodebuffer?o.transformTo(\"nodebuffer\",e).toString(\"utf-8\"):function(e){var t,r,n,i,s=e.length,a=new Array(2*s);for(t=r=0;t<s;)if((n=e[t++])<128)a[r++]=n;else if(4<(i=h[n]))a[r++]=65533,t+=i-1;else{for(n&=2===i?31:3===i?15:7;1<i&&t<s;)n=n<<6|63&e[t++],i--;1<i?a[r++]=65533:n<65536?a[r++]=n:(n-=65536,a[r++]=55296|n>>10&1023,a[r++]=56320|1023&n)}return a.length!==r&&(a.subarray?a=a.subarray(0,r):a.length=r),o.applyFromCharCode(a)}(e=o.transformTo(u.uint8array?\"uint8array\":\"array\",e))},o.inherits(a,n),a.prototype.processChunk=function(e){var t=o.transformTo(u.uint8array?\"uint8array\":\"array\",e.data);if(this.leftOver&&this.leftOver.length){if(u.uint8array){var r=t;(t=new Uint8Array(r.length+this.leftOver.length)).set(this.leftOver,0),t.set(r,this.leftOver.length)}else t=this.leftOver.concat(t);this.leftOver=null}var n=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;0<=r&&128==(192&e[r]);)r--;return r<0?t:0===r?t:r+h[e[r]]>t?r:t}(t),i=t;n!==t.length&&(u.uint8array?(i=t.subarray(0,n),this.leftOver=t.subarray(n,t.length)):(i=t.slice(0,n),this.leftOver=t.slice(n,t.length))),this.push({data:s.utf8decode(i),meta:e.meta})},a.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},s.Utf8DecodeWorker=a,o.inherits(f,n),f.prototype.processChunk=function(e){this.push({data:s.utf8encode(e.data),meta:e.meta})},s.Utf8EncodeWorker=f},{\".\/nodejsUtils\":14,\".\/stream\/GenericWorker\":28,\".\/support\":30,\".\/utils\":32}],32:[function(e,t,o){\"use strict\";var u=e(\".\/support\"),h=e(\".\/base64\"),r=e(\".\/nodejsUtils\"),n=e(\"set-immediate-shim\"),f=e(\".\/external\");function i(e){return e}function l(e,t){for(var r=0;r<e.length;++r)t[r]=255&e.charCodeAt(r);return t}o.newBlob=function(t,r){o.checkSupport(\"blob\");try{return new Blob([t],{type:r})}catch(e){try{var n=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return n.append(t),n.getBlob(r)}catch(e){throw new Error(\"Bug : can't construct the Blob.\")}}};var s={stringifyByChunk:function(e,t,r){var n=[],i=0,s=e.length;if(s<=r)return String.fromCharCode.apply(null,e);for(;i<s;)\"array\"===t||\"nodebuffer\"===t?n.push(String.fromCharCode.apply(null,e.slice(i,Math.min(i+r,s)))):n.push(String.fromCharCode.apply(null,e.subarray(i,Math.min(i+r,s)))),i+=r;return n.join(\"\")},stringifyByChar:function(e){for(var t=\"\",r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t},applyCanBeUsed:{uint8array:function(){try{return u.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(e){return!1}}(),nodebuffer:function(){try{return u.nodebuffer&&1===String.fromCharCode.apply(null,r.allocBuffer(1)).length}catch(e){return!1}}()}};function a(e){var t=65536,r=o.getTypeOf(e),n=!0;if(\"uint8array\"===r?n=s.applyCanBeUsed.uint8array:\"nodebuffer\"===r&&(n=s.applyCanBeUsed.nodebuffer),n)for(;1<t;)try{return s.stringifyByChunk(e,r,t)}catch(e){t=Math.floor(t\/2)}return s.stringifyByChar(e)}function d(e,t){for(var r=0;r<e.length;r++)t[r]=e[r];return t}o.applyFromCharCode=a;var c={};c.string={string:i,array:function(e){return l(e,new Array(e.length))},arraybuffer:function(e){return c.string.uint8array(e).buffer},uint8array:function(e){return l(e,new Uint8Array(e.length))},nodebuffer:function(e){return l(e,r.allocBuffer(e.length))}},c.array={string:a,array:i,arraybuffer:function(e){return new Uint8Array(e).buffer},uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return r.newBufferFrom(e)}},c.arraybuffer={string:function(e){return a(new Uint8Array(e))},array:function(e){return d(new Uint8Array(e),new Array(e.byteLength))},arraybuffer:i,uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return r.newBufferFrom(new Uint8Array(e))}},c.uint8array={string:a,array:function(e){return d(e,new Array(e.length))},arraybuffer:function(e){return e.buffer},uint8array:i,nodebuffer:function(e){return r.newBufferFrom(e)}},c.nodebuffer={string:a,array:function(e){return d(e,new Array(e.length))},arraybuffer:function(e){return c.nodebuffer.uint8array(e).buffer},uint8array:function(e){return d(e,new Uint8Array(e.length))},nodebuffer:i},o.transformTo=function(e,t){if(t=t||\"\",!e)return t;o.checkSupport(e);var r=o.getTypeOf(t);return c[r][e](t)},o.getTypeOf=function(e){return\"string\"==typeof e?\"string\":\"[object Array]\"===Object.prototype.toString.call(e)?\"array\":u.nodebuffer&&r.isBuffer(e)?\"nodebuffer\":u.uint8array&&e instanceof Uint8Array?\"uint8array\":u.arraybuffer&&e instanceof ArrayBuffer?\"arraybuffer\":void 0},o.checkSupport=function(e){if(!u[e.toLowerCase()])throw new Error(e+\" is not supported by this platform\")},o.MAX_VALUE_16BITS=65535,o.MAX_VALUE_32BITS=-1,o.pretty=function(e){var t,r,n=\"\";for(r=0;r<(e||\"\").length;r++)n+=\"\\\\x\"+((t=e.charCodeAt(r))<16?\"0\":\"\")+t.toString(16).toUpperCase();return n},o.delay=function(e,t,r){n(function(){e.apply(r||null,t||[])})},o.inherits=function(e,t){function r(){}r.prototype=t.prototype,e.prototype=new r},o.extend=function(){var e,t,r={};for(e=0;e<arguments.length;e++)for(t in arguments[e])arguments[e].hasOwnProperty(t)&&void 0===r[t]&&(r[t]=arguments[e][t]);return r},o.prepareContent=function(n,e,i,s,a){return f.Promise.resolve(e).then(function(n){return u.blob&&(n instanceof Blob||-1!==[\"[object File]\",\"[object Blob]\"].indexOf(Object.prototype.toString.call(n)))&&\"undefined\"!=typeof FileReader?new f.Promise(function(t,r){var e=new FileReader;e.onload=function(e){t(e.target.result)},e.onerror=function(e){r(e.target.error)},e.readAsArrayBuffer(n)}):n}).then(function(e){var t,r=o.getTypeOf(e);return r?(\"arraybuffer\"===r?e=o.transformTo(\"uint8array\",e):\"string\"===r&&(a?e=h.decode(e):i&&!0!==s&&(e=l(t=e,u.uint8array?new Uint8Array(t.length):new Array(t.length)))),e):f.Promise.reject(new Error(\"Can't read the data of '\"+n+\"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\"))})}},{\".\/base64\":1,\".\/external\":6,\".\/nodejsUtils\":14,\".\/support\":30,\"set-immediate-shim\":54}],33:[function(e,t,r){\"use strict\";var n=e(\".\/reader\/readerFor\"),i=e(\".\/utils\"),s=e(\".\/signature\"),a=e(\".\/zipEntry\"),o=(e(\".\/utf8\"),e(\".\/support\"));function u(e){this.files=[],this.loadOptions=e}u.prototype={checkSignature:function(e){if(!this.reader.readAndCheckSignature(e)){this.reader.index-=4;var t=this.reader.readString(4);throw new Error(\"Corrupted zip or bug: unexpected signature (\"+i.pretty(t)+\", expected \"+i.pretty(e)+\")\")}},isSignature:function(e,t){var r=this.reader.index;this.reader.setIndex(e);var n=this.reader.readString(4)===t;return this.reader.setIndex(r),n},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var e=this.reader.readData(this.zipCommentLength),t=o.uint8array?\"uint8array\":\"array\",r=i.transformTo(t,e);this.zipComment=this.loadOptions.decodeFileName(r)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var e,t,r,n=this.zip64EndOfCentralSize-44;0<n;)e=this.reader.readInt(2),t=this.reader.readInt(4),r=this.reader.readData(t),this.zip64ExtensibleData[e]={id:e,length:t,value:r}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error(\"Multi-volumes zip are not supported\")},readLocalFiles:function(){var e,t;for(e=0;e<this.files.length;e++)t=this.files[e],this.reader.setIndex(t.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),t.readLocalPart(this.reader),t.handleUTF8(),t.processAttributes()},readCentralDir:function(){var e;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(e=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(e);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error(\"Corrupted zip or bug: expected \"+this.centralDirRecords+\" records in central dir, got \"+this.files.length)},readEndOfCentral:function(){var e=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(e<0)throw this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error(\"Corrupted zip: can't find end of central directory\"):new Error(\"Can't find end of central directory : is this a zip file ? If it is, see https:\/\/stuk.github.io\/jszip\/documentation\/howto\/read_zip.html\");this.reader.setIndex(e);var t=e;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===i.MAX_VALUE_16BITS||this.diskWithCentralDirStart===i.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===i.MAX_VALUE_16BITS||this.centralDirRecords===i.MAX_VALUE_16BITS||this.centralDirSize===i.MAX_VALUE_32BITS||this.centralDirOffset===i.MAX_VALUE_32BITS){if(this.zip64=!0,(e=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory locator\");if(this.reader.setIndex(e),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory\");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var r=this.centralDirOffset+this.centralDirSize;this.zip64&&(r+=20,r+=12+this.zip64EndOfCentralSize);var n=t-r;if(0<n)this.isSignature(t,s.CENTRAL_FILE_HEADER)||(this.reader.zero=n);else if(n<0)throw new Error(\"Corrupted zip: missing \"+Math.abs(n)+\" bytes.\")},prepareReader:function(e){this.reader=n(e)},load:function(e){this.prepareReader(e),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},t.exports=u},{\".\/reader\/readerFor\":22,\".\/signature\":23,\".\/support\":30,\".\/utf8\":31,\".\/utils\":32,\".\/zipEntry\":34}],34:[function(e,t,r){\"use strict\";var n=e(\".\/reader\/readerFor\"),s=e(\".\/utils\"),i=e(\".\/compressedObject\"),a=e(\".\/crc32\"),o=e(\".\/utf8\"),u=e(\".\/compressions\"),h=e(\".\/support\");function f(e,t){this.options=e,this.loadOptions=t}f.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(e){var t,r;if(e.skip(22),this.fileNameLength=e.readInt(2),r=e.readInt(2),this.fileName=e.readData(this.fileNameLength),e.skip(r),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error(\"Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)\");if(null===(t=function(e){for(var t in u)if(u.hasOwnProperty(t)&&u[t].magic===e)return u[t];return null}(this.compressionMethod)))throw new Error(\"Corrupted zip : compression \"+s.pretty(this.compressionMethod)+\" unknown (inner file : \"+s.transformTo(\"string\",this.fileName)+\")\");this.decompressed=new i(this.compressedSize,this.uncompressedSize,this.crc32,t,e.readData(this.compressedSize))},readCentralPart:function(e){this.versionMadeBy=e.readInt(2),e.skip(2),this.bitFlag=e.readInt(2),this.compressionMethod=e.readString(2),this.date=e.readDate(),this.crc32=e.readInt(4),this.compressedSize=e.readInt(4),this.uncompressedSize=e.readInt(4);var t=e.readInt(2);if(this.extraFieldsLength=e.readInt(2),this.fileCommentLength=e.readInt(2),this.diskNumberStart=e.readInt(2),this.internalFileAttributes=e.readInt(2),this.externalFileAttributes=e.readInt(4),this.localHeaderOffset=e.readInt(4),this.isEncrypted())throw new Error(\"Encrypted zip are not supported\");e.skip(t),this.readExtraFields(e),this.parseZIP64ExtraField(e),this.fileComment=e.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var e=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==e&&(this.dosPermissions=63&this.externalFileAttributes),3==e&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||\"\/\"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(e){if(this.extraFields[1]){var t=n(this.extraFields[1].value);this.uncompressedSize===s.MAX_VALUE_32BITS&&(this.uncompressedSize=t.readInt(8)),this.compressedSize===s.MAX_VALUE_32BITS&&(this.compressedSize=t.readInt(8)),this.localHeaderOffset===s.MAX_VALUE_32BITS&&(this.localHeaderOffset=t.readInt(8)),this.diskNumberStart===s.MAX_VALUE_32BITS&&(this.diskNumberStart=t.readInt(4))}},readExtraFields:function(e){var t,r,n,i=e.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});e.index+4<i;)t=e.readInt(2),r=e.readInt(2),n=e.readData(r),this.extraFields[t]={id:t,length:r,value:n};e.setIndex(i)},handleUTF8:function(){var e=h.uint8array?\"uint8array\":\"array\";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else{var t=this.findExtraFieldUnicodePath();if(null!==t)this.fileNameStr=t;else{var r=s.transformTo(e,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(r)}var n=this.findExtraFieldUnicodeComment();if(null!==n)this.fileCommentStr=n;else{var i=s.transformTo(e,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(i)}}},findExtraFieldUnicodePath:function(){var e=this.extraFields[28789];if(e){var t=n(e.value);return 1!==t.readInt(1)?null:a(this.fileName)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null},findExtraFieldUnicodeComment:function(){var e=this.extraFields[25461];if(e){var t=n(e.value);return 1!==t.readInt(1)?null:a(this.fileComment)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null}},t.exports=f},{\".\/compressedObject\":2,\".\/compressions\":3,\".\/crc32\":4,\".\/reader\/readerFor\":22,\".\/support\":30,\".\/utf8\":31,\".\/utils\":32}],35:[function(e,t,r){\"use strict\";function n(e,t,r){this.name=e,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this.unixPermissions=r.unixPermissions,this.dosPermissions=r.dosPermissions,this._data=t,this._dataBinary=r.binary,this.options={compression:r.compression,compressionOptions:r.compressionOptions}}var s=e(\".\/stream\/StreamHelper\"),i=e(\".\/stream\/DataWorker\"),a=e(\".\/utf8\"),o=e(\".\/compressedObject\"),u=e(\".\/stream\/GenericWorker\");n.prototype={internalStream:function(e){var t=null,r=\"string\";try{if(!e)throw new Error(\"No output type specified.\");var n=\"string\"===(r=e.toLowerCase())||\"text\"===r;\"binarystring\"!==r&&\"text\"!==r||(r=\"string\"),t=this._decompressWorker();var i=!this._dataBinary;i&&!n&&(t=t.pipe(new a.Utf8EncodeWorker)),!i&&n&&(t=t.pipe(new a.Utf8DecodeWorker))}catch(e){(t=new u(\"error\")).error(e)}return new s(t,r,\"\")},async:function(e,t){return this.internalStream(e).accumulate(t)},nodeStream:function(e,t){return this.internalStream(e||\"nodebuffer\").toNodejsStream(t)},_compressWorker:function(e,t){if(this._data instanceof o&&this._data.compression.magic===e.magic)return this._data.getCompressedWorker();var r=this._decompressWorker();return this._dataBinary||(r=r.pipe(new a.Utf8EncodeWorker)),o.createWorkerFrom(r,e,t)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof u?this._data:new i(this._data)}};for(var h=[\"asText\",\"asBinary\",\"asNodeBuffer\",\"asUint8Array\",\"asArrayBuffer\"],f=function(){throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\")},l=0;l<h.length;l++)n.prototype[h[l]]=f;t.exports=n},{\".\/compressedObject\":2,\".\/stream\/DataWorker\":27,\".\/stream\/GenericWorker\":28,\".\/stream\/StreamHelper\":29,\".\/utf8\":31}],36:[function(e,f,t){(function(t){\"use strict\";var r,n,e=t.MutationObserver||t.WebKitMutationObserver;if(e){var i=0,s=new e(h),a=t.document.createTextNode(\"\");s.observe(a,{characterData:!0}),r=function(){a.data=i=++i%2}}else if(t.setImmediate||void 0===t.MessageChannel)r=\"document\"in t&&\"onreadystatechange\"in t.document.createElement(\"script\")?function(){var e=t.document.createElement(\"script\");e.onreadystatechange=function(){h(),e.onreadystatechange=null,e.parentNode.removeChild(e),e=null},t.document.documentElement.appendChild(e)}:function(){setTimeout(h,0)};else{var o=new t.MessageChannel;o.port1.onmessage=h,r=function(){o.port2.postMessage(0)}}var u=[];function h(){var e,t;n=!0;for(var r=u.length;r;){for(t=u,u=[],e=-1;++e<r;)t[e]();r=u.length}n=!1}f.exports=function(e){1!==u.push(e)||n||r()}}).call(this,void 0!==r?r:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}],37:[function(e,t,r){\"use strict\";var i=e(\"immediate\");function h(){}var f={},s=[\"REJECTED\"],a=[\"FULFILLED\"],n=[\"PENDING\"];function o(e){if(\"function\"!=typeof e)throw new TypeError(\"resolver must be a function\");this.state=n,this.queue=[],this.outcome=void 0,e!==h&&c(this,e)}function u(e,t,r){this.promise=e,\"function\"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),\"function\"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected)}function l(t,r,n){i(function(){var e;try{e=r(n)}catch(e){return f.reject(t,e)}e===t?f.reject(t,new TypeError(\"Cannot resolve promise with itself\")):f.resolve(t,e)})}function d(e){var t=e&&e.then;if(e&&(\"object\"==typeof e||\"function\"==typeof e)&&\"function\"==typeof t)return function(){t.apply(e,arguments)}}function c(t,e){var r=!1;function n(e){r||(r=!0,f.reject(t,e))}function i(e){r||(r=!0,f.resolve(t,e))}var s=p(function(){e(i,n)});\"error\"===s.status&&n(s.value)}function p(e,t){var r={};try{r.value=e(t),r.status=\"success\"}catch(e){r.status=\"error\",r.value=e}return r}(t.exports=o).prototype.finally=function(t){if(\"function\"!=typeof t)return this;var r=this.constructor;return this.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})})},o.prototype.catch=function(e){return this.then(null,e)},o.prototype.then=function(e,t){if(\"function\"!=typeof e&&this.state===a||\"function\"!=typeof t&&this.state===s)return this;var r=new this.constructor(h);return this.state!==n?l(r,this.state===a?e:t,this.outcome):this.queue.push(new u(r,e,t)),r},u.prototype.callFulfilled=function(e){f.resolve(this.promise,e)},u.prototype.otherCallFulfilled=function(e){l(this.promise,this.onFulfilled,e)},u.prototype.callRejected=function(e){f.reject(this.promise,e)},u.prototype.otherCallRejected=function(e){l(this.promise,this.onRejected,e)},f.resolve=function(e,t){var r=p(d,t);if(\"error\"===r.status)return f.reject(e,r.value);var n=r.value;if(n)c(e,n);else{e.state=a,e.outcome=t;for(var i=-1,s=e.queue.length;++i<s;)e.queue[i].callFulfilled(t)}return e},f.reject=function(e,t){e.state=s,e.outcome=t;for(var r=-1,n=e.queue.length;++r<n;)e.queue[r].callRejected(t);return e},o.resolve=function(e){return e instanceof this?e:f.resolve(new this(h),e)},o.reject=function(e){var t=new this(h);return f.reject(t,e)},o.all=function(e){var r=this;if(\"[object Array]\"!==Object.prototype.toString.call(e))return this.reject(new TypeError(\"must be an array\"));var n=e.length,i=!1;if(!n)return this.resolve([]);for(var s=new Array(n),a=0,t=-1,o=new this(h);++t<n;)u(e[t],t);return o;function u(e,t){r.resolve(e).then(function(e){s[t]=e,++a!==n||i||(i=!0,f.resolve(o,s))},function(e){i||(i=!0,f.reject(o,e))})}},o.race=function(e){if(\"[object Array]\"!==Object.prototype.toString.call(e))return this.reject(new TypeError(\"must be an array\"));var t=e.length,r=!1;if(!t)return this.resolve([]);for(var n,i=-1,s=new this(h);++i<t;)n=e[i],this.resolve(n).then(function(e){r||(r=!0,f.resolve(s,e))},function(e){r||(r=!0,f.reject(s,e))});return s}},{immediate:36}],38:[function(e,t,r){\"use strict\";var n={};(0,e(\".\/lib\/utils\/common\").assign)(n,e(\".\/lib\/deflate\"),e(\".\/lib\/inflate\"),e(\".\/lib\/zlib\/constants\")),t.exports=n},{\".\/lib\/deflate\":39,\".\/lib\/inflate\":40,\".\/lib\/utils\/common\":41,\".\/lib\/zlib\/constants\":44}],39:[function(e,t,r){\"use strict\";var a=e(\".\/zlib\/deflate\"),o=e(\".\/utils\/common\"),u=e(\".\/utils\/strings\"),i=e(\".\/zlib\/messages\"),s=e(\".\/zlib\/zstream\"),h=Object.prototype.toString,f=0,l=-1,d=0,c=8;function p(e){if(!(this instanceof p))return new p(e);this.options=o.assign({level:l,method:c,chunkSize:16384,windowBits:15,memLevel:8,strategy:d,to:\"\"},e||{});var t=this.options;t.raw&&0<t.windowBits?t.windowBits=-t.windowBits:t.gzip&&0<t.windowBits&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg=\"\",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(r!==f)throw new Error(i[r]);if(t.header&&a.deflateSetHeader(this.strm,t.header),t.dictionary){var n;if(n=\"string\"==typeof t.dictionary?u.string2buf(t.dictionary):\"[object ArrayBuffer]\"===h.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,(r=a.deflateSetDictionary(this.strm,n))!==f)throw new Error(i[r]);this._dict_set=!0}}function n(e,t){var r=new p(t);if(r.push(e,!0),r.err)throw r.msg||i[r.err];return r.result}p.prototype.push=function(e,t){var r,n,i=this.strm,s=this.options.chunkSize;if(this.ended)return!1;n=t===~~t?t:!0===t?4:0,\"string\"==typeof e?i.input=u.string2buf(e):\"[object ArrayBuffer]\"===h.call(e)?i.input=new Uint8Array(e):i.input=e,i.next_in=0,i.avail_in=i.input.length;do{if(0===i.avail_out&&(i.output=new o.Buf8(s),i.next_out=0,i.avail_out=s),1!==(r=a.deflate(i,n))&&r!==f)return this.onEnd(r),!(this.ended=!0);0!==i.avail_out&&(0!==i.avail_in||4!==n&&2!==n)||(\"string\"===this.options.to?this.onData(u.buf2binstring(o.shrinkBuf(i.output,i.next_out))):this.onData(o.shrinkBuf(i.output,i.next_out)))}while((0<i.avail_in||0===i.avail_out)&&1!==r);return 4===n?(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===f):2!==n||(this.onEnd(f),!(i.avail_out=0))},p.prototype.onData=function(e){this.chunks.push(e)},p.prototype.onEnd=function(e){e===f&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg},r.Deflate=p,r.deflate=n,r.deflateRaw=function(e,t){return(t=t||{}).raw=!0,n(e,t)},r.gzip=function(e,t){return(t=t||{}).gzip=!0,n(e,t)}},{\".\/utils\/common\":41,\".\/utils\/strings\":42,\".\/zlib\/deflate\":46,\".\/zlib\/messages\":51,\".\/zlib\/zstream\":53}],40:[function(e,t,r){\"use strict\";var d=e(\".\/zlib\/inflate\"),c=e(\".\/utils\/common\"),p=e(\".\/utils\/strings\"),m=e(\".\/zlib\/constants\"),n=e(\".\/zlib\/messages\"),i=e(\".\/zlib\/zstream\"),s=e(\".\/zlib\/gzheader\"),_=Object.prototype.toString;function a(e){if(!(this instanceof a))return new a(e);this.options=c.assign({chunkSize:16384,windowBits:0,to:\"\"},e||{});var t=this.options;t.raw&&0<=t.windowBits&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(0<=t.windowBits&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),15<t.windowBits&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg=\"\",this.ended=!1,this.chunks=[],this.strm=new i,this.strm.avail_out=0;var r=d.inflateInit2(this.strm,t.windowBits);if(r!==m.Z_OK)throw new Error(n[r]);this.header=new s,d.inflateGetHeader(this.strm,this.header)}function o(e,t){var r=new a(t);if(r.push(e,!0),r.err)throw r.msg||n[r.err];return r.result}a.prototype.push=function(e,t){var r,n,i,s,a,o,u=this.strm,h=this.options.chunkSize,f=this.options.dictionary,l=!1;if(this.ended)return!1;n=t===~~t?t:!0===t?m.Z_FINISH:m.Z_NO_FLUSH,\"string\"==typeof e?u.input=p.binstring2buf(e):\"[object ArrayBuffer]\"===_.call(e)?u.input=new Uint8Array(e):u.input=e,u.next_in=0,u.avail_in=u.input.length;do{if(0===u.avail_out&&(u.output=new c.Buf8(h),u.next_out=0,u.avail_out=h),(r=d.inflate(u,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&f&&(o=\"string\"==typeof f?p.string2buf(f):\"[object ArrayBuffer]\"===_.call(f)?new Uint8Array(f):f,r=d.inflateSetDictionary(this.strm,o)),r===m.Z_BUF_ERROR&&!0===l&&(r=m.Z_OK,l=!1),r!==m.Z_STREAM_END&&r!==m.Z_OK)return this.onEnd(r),!(this.ended=!0);u.next_out&&(0!==u.avail_out&&r!==m.Z_STREAM_END&&(0!==u.avail_in||n!==m.Z_FINISH&&n!==m.Z_SYNC_FLUSH)||(\"string\"===this.options.to?(i=p.utf8border(u.output,u.next_out),s=u.next_out-i,a=p.buf2string(u.output,i),u.next_out=s,u.avail_out=h-s,s&&c.arraySet(u.output,u.output,i,s,0),this.onData(a)):this.onData(c.shrinkBuf(u.output,u.next_out)))),0===u.avail_in&&0===u.avail_out&&(l=!0)}while((0<u.avail_in||0===u.avail_out)&&r!==m.Z_STREAM_END);return r===m.Z_STREAM_END&&(n=m.Z_FINISH),n===m.Z_FINISH?(r=d.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===m.Z_OK):n!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(u.avail_out=0))},a.prototype.onData=function(e){this.chunks.push(e)},a.prototype.onEnd=function(e){e===m.Z_OK&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=c.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg},r.Inflate=a,r.inflate=o,r.inflateRaw=function(e,t){return(t=t||{}).raw=!0,o(e,t)},r.ungzip=o},{\".\/utils\/common\":41,\".\/utils\/strings\":42,\".\/zlib\/constants\":44,\".\/zlib\/gzheader\":47,\".\/zlib\/inflate\":49,\".\/zlib\/messages\":51,\".\/zlib\/zstream\":53}],41:[function(e,t,r){\"use strict\";var n=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Int32Array;r.assign=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var r=t.shift();if(r){if(\"object\"!=typeof r)throw new TypeError(r+\"must be non-object\");for(var n in r)r.hasOwnProperty(n)&&(e[n]=r[n])}}return e},r.shrinkBuf=function(e,t){return e.length===t?e:e.subarray?e.subarray(0,t):(e.length=t,e)};var i={arraySet:function(e,t,r,n,i){if(t.subarray&&e.subarray)e.set(t.subarray(r,r+n),i);else for(var s=0;s<n;s++)e[i+s]=t[r+s]},flattenChunks:function(e){var t,r,n,i,s,a;for(t=n=0,r=e.length;t<r;t++)n+=e[t].length;for(a=new Uint8Array(n),t=i=0,r=e.length;t<r;t++)s=e[t],a.set(s,i),i+=s.length;return a}},s={arraySet:function(e,t,r,n,i){for(var s=0;s<n;s++)e[i+s]=t[r+s]},flattenChunks:function(e){return[].concat.apply([],e)}};r.setTyped=function(e){e?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,i)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,s))},r.setTyped(n)},{}],42:[function(e,t,r){\"use strict\";var u=e(\".\/common\"),i=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(e){i=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){s=!1}for(var h=new u.Buf8(256),n=0;n<256;n++)h[n]=252<=n?6:248<=n?5:240<=n?4:224<=n?3:192<=n?2:1;function f(e,t){if(t<65537&&(e.subarray&&s||!e.subarray&&i))return String.fromCharCode.apply(null,u.shrinkBuf(e,t));for(var r=\"\",n=0;n<t;n++)r+=String.fromCharCode(e[n]);return r}h[254]=h[254]=1,r.string2buf=function(e){var t,r,n,i,s,a=e.length,o=0;for(i=0;i<a;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),o+=r<128?1:r<2048?2:r<65536?3:4;for(t=new u.Buf8(o),i=s=0;s<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[s++]=r:(r<2048?t[s++]=192|r>>>6:(r<65536?t[s++]=224|r>>>12:(t[s++]=240|r>>>18,t[s++]=128|r>>>12&63),t[s++]=128|r>>>6&63),t[s++]=128|63&r);return t},r.buf2binstring=function(e){return f(e,e.length)},r.binstring2buf=function(e){for(var t=new u.Buf8(e.length),r=0,n=t.length;r<n;r++)t[r]=e.charCodeAt(r);return t},r.buf2string=function(e,t){var r,n,i,s,a=t||e.length,o=new Array(2*a);for(r=n=0;r<a;)if((i=e[r++])<128)o[n++]=i;else if(4<(s=h[i]))o[n++]=65533,r+=s-1;else{for(i&=2===s?31:3===s?15:7;1<s&&r<a;)i=i<<6|63&e[r++],s--;1<s?o[n++]=65533:i<65536?o[n++]=i:(i-=65536,o[n++]=55296|i>>10&1023,o[n++]=56320|1023&i)}return f(o,n)},r.utf8border=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;0<=r&&128==(192&e[r]);)r--;return r<0?t:0===r?t:r+h[e[r]]>t?r:t}},{\".\/common\":41}],43:[function(e,t,r){\"use strict\";t.exports=function(e,t,r,n){for(var i=65535&e|0,s=e>>>16&65535|0,a=0;0!==r;){for(r-=a=2e3<r?2e3:r;s=s+(i=i+t[n++]|0)|0,--a;);i%=65521,s%=65521}return i|s<<16|0}},{}],44:[function(e,t,r){\"use strict\";t.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(e,t,r){\"use strict\";var o=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t}();t.exports=function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t[a])];return-1^e}},{}],46:[function(e,t,r){\"use strict\";var u,d=e(\"..\/utils\/common\"),h=e(\".\/trees\"),c=e(\".\/adler32\"),p=e(\".\/crc32\"),n=e(\".\/messages\"),f=0,l=0,m=-2,i=2,_=8,s=286,a=30,o=19,g=2*s+1,v=15,b=3,w=258,y=w+b+1,k=42,x=113;function S(e,t){return e.msg=n[t],t}function z(e){return(e<<1)-(4<e?9:0)}function C(e){for(var t=e.length;0<=--t;)e[t]=0}function E(e){var t=e.state,r=t.pending;r>e.avail_out&&(r=e.avail_out),0!==r&&(d.arraySet(e.output,t.pending_buf,t.pending_out,r,e.next_out),e.next_out+=r,t.pending_out+=r,e.total_out+=r,e.avail_out-=r,t.pending-=r,0===t.pending&&(t.pending_out=0))}function A(e,t){h._tr_flush_block(e,0<=e.block_start?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,E(e.strm)}function I(e,t){e.pending_buf[e.pending++]=t}function O(e,t){e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t}function B(e,t){var r,n,i=e.max_chain_length,s=e.strstart,a=e.prev_length,o=e.nice_match,u=e.strstart>e.w_size-y?e.strstart-(e.w_size-y):0,h=e.window,f=e.w_mask,l=e.prev,d=e.strstart+w,c=h[s+a-1],p=h[s+a];e.prev_length>=e.good_match&&(i>>=2),o>e.lookahead&&(o=e.lookahead);do{if(h[(r=t)+a]===p&&h[r+a-1]===c&&h[r]===h[s]&&h[++r]===h[s+1]){s+=2,r++;do{}while(h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&s<d);if(n=w-(d-s),s=d-w,a<n){if(e.match_start=t,o<=(a=n))break;c=h[s+a-1],p=h[s+a]}}}while((t=l[t&f])>u&&0!=--i);return a<=e.lookahead?a:e.lookahead}function R(e){var t,r,n,i,s,a,o,u,h,f,l=e.w_size;do{if(i=e.window_size-e.lookahead-e.strstart,e.strstart>=l+(l-y)){for(d.arraySet(e.window,e.window,l,l,0),e.match_start-=l,e.strstart-=l,e.block_start-=l,t=r=e.hash_size;n=e.head[--t],e.head[t]=l<=n?n-l:0,--r;);for(t=r=l;n=e.prev[--t],e.prev[t]=l<=n?n-l:0,--r;);i+=l}if(0===e.strm.avail_in)break;if(a=e.strm,o=e.window,u=e.strstart+e.lookahead,f=void 0,(h=i)<(f=a.avail_in)&&(f=h),r=0===f?0:(a.avail_in-=f,d.arraySet(o,a.input,a.next_in,f,u),1===a.state.wrap?a.adler=c(a.adler,o,f,u):2===a.state.wrap&&(a.adler=p(a.adler,o,f,u)),a.next_in+=f,a.total_in+=f,f),e.lookahead+=r,e.lookahead+e.insert>=b)for(s=e.strstart-e.insert,e.ins_h=e.window[s],e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+1])&e.hash_mask;e.insert&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+b-1])&e.hash_mask,e.prev[s&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=s,s++,e.insert--,!(e.lookahead+e.insert<b)););}while(e.lookahead<y&&0!==e.strm.avail_in)}function T(e,t){for(var r,n;;){if(e.lookahead<y){if(R(e),e.lookahead<y&&t===f)return 1;if(0===e.lookahead)break}if(r=0,e.lookahead>=b&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+b-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==r&&e.strstart-r<=e.w_size-y&&(e.match_length=B(e,r)),e.match_length>=b)if(n=h._tr_tally(e,e.strstart-e.match_start,e.match_length-b),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=b){for(e.match_length--;e.strstart++,e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+b-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart,0!=--e.match_length;);e.strstart++}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+1])&e.hash_mask;else n=h._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(n&&(A(e,!1),0===e.strm.avail_out))return 1}return e.insert=e.strstart<b-1?e.strstart:b-1,4===t?(A(e,!0),0===e.strm.avail_out?3:4):e.last_lit&&(A(e,!1),0===e.strm.avail_out)?1:2}function D(e,t){for(var r,n,i;;){if(e.lookahead<y){if(R(e),e.lookahead<y&&t===f)return 1;if(0===e.lookahead)break}if(r=0,e.lookahead>=b&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+b-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=b-1,0!==r&&e.prev_length<e.max_lazy_match&&e.strstart-r<=e.w_size-y&&(e.match_length=B(e,r),e.match_length<=5&&(1===e.strategy||e.match_length===b&&4096<e.strstart-e.match_start)&&(e.match_length=b-1)),e.prev_length>=b&&e.match_length<=e.prev_length){for(i=e.strstart+e.lookahead-b,n=h._tr_tally(e,e.strstart-1-e.prev_match,e.prev_length-b),e.lookahead-=e.prev_length-1,e.prev_length-=2;++e.strstart<=i&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+b-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!=--e.prev_length;);if(e.match_available=0,e.match_length=b-1,e.strstart++,n&&(A(e,!1),0===e.strm.avail_out))return 1}else if(e.match_available){if((n=h._tr_tally(e,0,e.window[e.strstart-1]))&&A(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return 1}else e.match_available=1,e.strstart++,e.lookahead--}return e.match_available&&(n=h._tr_tally(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<b-1?e.strstart:b-1,4===t?(A(e,!0),0===e.strm.avail_out?3:4):e.last_lit&&(A(e,!1),0===e.strm.avail_out)?1:2}function F(e,t,r,n,i){this.good_length=e,this.max_lazy=t,this.nice_length=r,this.max_chain=n,this.func=i}function N(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=_,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new d.Buf16(2*g),this.dyn_dtree=new d.Buf16(2*(2*a+1)),this.bl_tree=new d.Buf16(2*(2*o+1)),C(this.dyn_ltree),C(this.dyn_dtree),C(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new d.Buf16(v+1),this.heap=new d.Buf16(2*s+1),C(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new d.Buf16(2*s+1),C(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function U(e){var t;return e&&e.state?(e.total_in=e.total_out=0,e.data_type=i,(t=e.state).pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap?k:x,e.adler=2===t.wrap?0:1,t.last_flush=f,h._tr_init(t),l):S(e,m)}function P(e){var t,r=U(e);return r===l&&((t=e.state).window_size=2*t.w_size,C(t.head),t.max_lazy_match=u[t.level].max_lazy,t.good_match=u[t.level].good_length,t.nice_match=u[t.level].nice_length,t.max_chain_length=u[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=b-1,t.match_available=0,t.ins_h=0),r}function L(e,t,r,n,i,s){if(!e)return m;var a=1;if(-1===t&&(t=6),n<0?(a=0,n=-n):15<n&&(a=2,n-=16),i<1||9<i||r!==_||n<8||15<n||t<0||9<t||s<0||4<s)return S(e,m);8===n&&(n=9);var o=new N;return(e.state=o).strm=e,o.wrap=a,o.gzhead=null,o.w_bits=n,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=i+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+b-1)\/b),o.window=new d.Buf8(2*o.w_size),o.head=new d.Buf16(o.hash_size),o.prev=new d.Buf16(o.w_size),o.lit_bufsize=1<<i+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new d.Buf8(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=t,o.strategy=s,o.method=r,P(e)}u=[new F(0,0,0,0,function(e,t){var r=65535;for(r>e.pending_buf_size-5&&(r=e.pending_buf_size-5);;){if(e.lookahead<=1){if(R(e),0===e.lookahead&&t===f)return 1;if(0===e.lookahead)break}e.strstart+=e.lookahead,e.lookahead=0;var n=e.block_start+r;if((0===e.strstart||e.strstart>=n)&&(e.lookahead=e.strstart-n,e.strstart=n,A(e,!1),0===e.strm.avail_out))return 1;if(e.strstart-e.block_start>=e.w_size-y&&(A(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,4===t?(A(e,!0),0===e.strm.avail_out?3:4):(e.strstart>e.block_start&&(A(e,!1),e.strm.avail_out),1)}),new F(4,4,8,4,T),new F(4,5,16,8,T),new F(4,6,32,32,T),new F(4,4,16,16,D),new F(8,16,32,32,D),new F(8,16,128,128,D),new F(8,32,128,256,D),new F(32,128,258,1024,D),new F(32,258,258,4096,D)],r.deflateInit=function(e,t){return L(e,t,_,15,8,0)},r.deflateInit2=L,r.deflateReset=P,r.deflateResetKeep=U,r.deflateSetHeader=function(e,t){return e&&e.state?2!==e.state.wrap?m:(e.state.gzhead=t,l):m},r.deflate=function(e,t){var r,n,i,s;if(!e||!e.state||5<t||t<0)return e?S(e,m):m;if(n=e.state,!e.output||!e.input&&0!==e.avail_in||666===n.status&&4!==t)return S(e,0===e.avail_out?-5:m);if(n.strm=e,r=n.last_flush,n.last_flush=t,n.status===k)if(2===n.wrap)e.adler=0,I(n,31),I(n,139),I(n,8),n.gzhead?(I(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),I(n,255&n.gzhead.time),I(n,n.gzhead.time>>8&255),I(n,n.gzhead.time>>16&255),I(n,n.gzhead.time>>24&255),I(n,9===n.level?2:2<=n.strategy||n.level<2?4:0),I(n,255&n.gzhead.os),n.gzhead.extra&&n.gzhead.extra.length&&(I(n,255&n.gzhead.extra.length),I(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(e.adler=p(e.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=69):(I(n,0),I(n,0),I(n,0),I(n,0),I(n,0),I(n,9===n.level?2:2<=n.strategy||n.level<2?4:0),I(n,3),n.status=x);else{var a=_+(n.w_bits-8<<4)<<8;a|=(2<=n.strategy||n.level<2?0:n.level<6?1:6===n.level?2:3)<<6,0!==n.strstart&&(a|=32),a+=31-a%31,n.status=x,O(n,a),0!==n.strstart&&(O(n,e.adler>>>16),O(n,65535&e.adler)),e.adler=1}if(69===n.status)if(n.gzhead.extra){for(i=n.pending;n.gzindex<(65535&n.gzhead.extra.length)&&(n.pending!==n.pending_buf_size||(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),E(e),i=n.pending,n.pending!==n.pending_buf_size));)I(n,255&n.gzhead.extra[n.gzindex]),n.gzindex++;n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),n.gzindex===n.gzhead.extra.length&&(n.gzindex=0,n.status=73)}else n.status=73;if(73===n.status)if(n.gzhead.name){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),E(e),i=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.name.length?255&n.gzhead.name.charCodeAt(n.gzindex++):0,I(n,s)}while(0!==s);n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),0===s&&(n.gzindex=0,n.status=91)}else n.status=91;if(91===n.status)if(n.gzhead.comment){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),E(e),i=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.comment.length?255&n.gzhead.comment.charCodeAt(n.gzindex++):0,I(n,s)}while(0!==s);n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),0===s&&(n.status=103)}else n.status=103;if(103===n.status&&(n.gzhead.hcrc?(n.pending+2>n.pending_buf_size&&E(e),n.pending+2<=n.pending_buf_size&&(I(n,255&e.adler),I(n,e.adler>>8&255),e.adler=0,n.status=x)):n.status=x),0!==n.pending){if(E(e),0===e.avail_out)return n.last_flush=-1,l}else if(0===e.avail_in&&z(t)<=z(r)&&4!==t)return S(e,-5);if(666===n.status&&0!==e.avail_in)return S(e,-5);if(0!==e.avail_in||0!==n.lookahead||t!==f&&666!==n.status){var o=2===n.strategy?function(e,t){for(var r;;){if(0===e.lookahead&&(R(e),0===e.lookahead)){if(t===f)return 1;break}if(e.match_length=0,r=h._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,r&&(A(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,4===t?(A(e,!0),0===e.strm.avail_out?3:4):e.last_lit&&(A(e,!1),0===e.strm.avail_out)?1:2}(n,t):3===n.strategy?function(e,t){for(var r,n,i,s,a=e.window;;){if(e.lookahead<=w){if(R(e),e.lookahead<=w&&t===f)return 1;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=b&&0<e.strstart&&(n=a[i=e.strstart-1])===a[++i]&&n===a[++i]&&n===a[++i]){s=e.strstart+w;do{}while(n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&i<s);e.match_length=w-(s-i),e.match_length>e.lookahead&&(e.match_length=e.lookahead)}if(e.match_length>=b?(r=h._tr_tally(e,1,e.match_length-b),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(r=h._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),r&&(A(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,4===t?(A(e,!0),0===e.strm.avail_out?3:4):e.last_lit&&(A(e,!1),0===e.strm.avail_out)?1:2}(n,t):u[n.level].func(n,t);if(3!==o&&4!==o||(n.status=666),1===o||3===o)return 0===e.avail_out&&(n.last_flush=-1),l;if(2===o&&(1===t?h._tr_align(n):5!==t&&(h._tr_stored_block(n,0,0,!1),3===t&&(C(n.head),0===n.lookahead&&(n.strstart=0,n.block_start=0,n.insert=0))),E(e),0===e.avail_out))return n.last_flush=-1,l}return 4!==t?l:n.wrap<=0?1:(2===n.wrap?(I(n,255&e.adler),I(n,e.adler>>8&255),I(n,e.adler>>16&255),I(n,e.adler>>24&255),I(n,255&e.total_in),I(n,e.total_in>>8&255),I(n,e.total_in>>16&255),I(n,e.total_in>>24&255)):(O(n,e.adler>>>16),O(n,65535&e.adler)),E(e),0<n.wrap&&(n.wrap=-n.wrap),0!==n.pending?l:1)},r.deflateEnd=function(e){var t;return e&&e.state?(t=e.state.status)!==k&&69!==t&&73!==t&&91!==t&&103!==t&&t!==x&&666!==t?S(e,m):(e.state=null,t===x?S(e,-3):l):m},r.deflateSetDictionary=function(e,t){var r,n,i,s,a,o,u,h,f=t.length;if(!e||!e.state)return m;if(2===(s=(r=e.state).wrap)||1===s&&r.status!==k||r.lookahead)return m;for(1===s&&(e.adler=c(e.adler,t,f,0)),r.wrap=0,f>=r.w_size&&(0===s&&(C(r.head),r.strstart=0,r.block_start=0,r.insert=0),h=new d.Buf8(r.w_size),d.arraySet(h,t,f-r.w_size,r.w_size,0),t=h,f=r.w_size),a=e.avail_in,o=e.next_in,u=e.input,e.avail_in=f,e.next_in=0,e.input=t,R(r);r.lookahead>=b;){for(n=r.strstart,i=r.lookahead-(b-1);r.ins_h=(r.ins_h<<r.hash_shift^r.window[n+b-1])&r.hash_mask,r.prev[n&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=n,n++,--i;);r.strstart=n,r.lookahead=b-1,R(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=b-1,r.match_available=0,e.next_in=o,e.input=u,e.avail_in=a,r.wrap=s,l},r.deflateInfo=\"pako deflate (from Nodeca project)\"},{\"..\/utils\/common\":41,\".\/adler32\":43,\".\/crc32\":45,\".\/messages\":51,\".\/trees\":52}],47:[function(e,t,r){\"use strict\";t.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name=\"\",this.comment=\"\",this.hcrc=0,this.done=!1}},{}],48:[function(e,t,r){\"use strict\";t.exports=function(e,t){var r,n,i,s,a,o,u,h,f,l,d,c,p,m,_,g,v,b,w,y,k,x,S,z,C;r=e.state,n=e.next_in,z=e.input,i=n+(e.avail_in-5),s=e.next_out,C=e.output,a=s-(t-e.avail_out),o=s+(e.avail_out-257),u=r.dmax,h=r.wsize,f=r.whave,l=r.wnext,d=r.window,c=r.hold,p=r.bits,m=r.lencode,_=r.distcode,g=(1<<r.lenbits)-1,v=(1<<r.distbits)-1;e:do{p<15&&(c+=z[n++]<<p,p+=8,c+=z[n++]<<p,p+=8),b=m[c&g];t:for(;;){if(c>>>=w=b>>>24,p-=w,0==(w=b>>>16&255))C[s++]=65535&b;else{if(!(16&w)){if(0==(64&w)){b=m[(65535&b)+(c&(1<<w)-1)];continue t}if(32&w){r.mode=12;break e}e.msg=\"invalid literal\/length code\",r.mode=30;break e}y=65535&b,(w&=15)&&(p<w&&(c+=z[n++]<<p,p+=8),y+=c&(1<<w)-1,c>>>=w,p-=w),p<15&&(c+=z[n++]<<p,p+=8,c+=z[n++]<<p,p+=8),b=_[c&v];r:for(;;){if(c>>>=w=b>>>24,p-=w,!(16&(w=b>>>16&255))){if(0==(64&w)){b=_[(65535&b)+(c&(1<<w)-1)];continue r}e.msg=\"invalid distance code\",r.mode=30;break e}if(k=65535&b,p<(w&=15)&&(c+=z[n++]<<p,(p+=8)<w&&(c+=z[n++]<<p,p+=8)),u<(k+=c&(1<<w)-1)){e.msg=\"invalid distance too far back\",r.mode=30;break e}if(c>>>=w,p-=w,(w=s-a)<k){if(f<(w=k-w)&&r.sane){e.msg=\"invalid distance too far back\",r.mode=30;break e}if(S=d,(x=0)===l){if(x+=h-w,w<y){for(y-=w;C[s++]=d[x++],--w;);x=s-k,S=C}}else if(l<w){if(x+=h+l-w,(w-=l)<y){for(y-=w;C[s++]=d[x++],--w;);if(x=0,l<y){for(y-=w=l;C[s++]=d[x++],--w;);x=s-k,S=C}}}else if(x+=l-w,w<y){for(y-=w;C[s++]=d[x++],--w;);x=s-k,S=C}for(;2<y;)C[s++]=S[x++],C[s++]=S[x++],C[s++]=S[x++],y-=3;y&&(C[s++]=S[x++],1<y&&(C[s++]=S[x++]))}else{for(x=s-k;C[s++]=C[x++],C[s++]=C[x++],C[s++]=C[x++],2<(y-=3););y&&(C[s++]=C[x++],1<y&&(C[s++]=C[x++]))}break}}break}}while(n<i&&s<o);n-=y=p>>3,c&=(1<<(p-=y<<3))-1,e.next_in=n,e.next_out=s,e.avail_in=n<i?i-n+5:5-(n-i),e.avail_out=s<o?o-s+257:257-(s-o),r.hold=c,r.bits=p}},{}],49:[function(e,t,r){\"use strict\";var I=e(\"..\/utils\/common\"),O=e(\".\/adler32\"),B=e(\".\/crc32\"),R=e(\".\/inffast\"),T=e(\".\/inftrees\"),D=1,F=2,N=0,U=-2,P=1,n=852,i=592;function L(e){return(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)}function s(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new I.Buf16(320),this.work=new I.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function a(e){var t;return e&&e.state?(t=e.state,e.total_in=e.total_out=t.total=0,e.msg=\"\",t.wrap&&(e.adler=1&t.wrap),t.mode=P,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new I.Buf32(n),t.distcode=t.distdyn=new I.Buf32(i),t.sane=1,t.back=-1,N):U}function o(e){var t;return e&&e.state?((t=e.state).wsize=0,t.whave=0,t.wnext=0,a(e)):U}function u(e,t){var r,n;return e&&e.state?(n=e.state,t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||15<t)?U:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,o(e))):U}function h(e,t){var r,n;return e?(n=new s,(e.state=n).window=null,(r=u(e,t))!==N&&(e.state=null),r):U}var f,l,d=!0;function j(e){if(d){var t;for(f=new I.Buf32(512),l=new I.Buf32(32),t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(T(D,e.lens,0,288,f,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;T(F,e.lens,0,32,l,0,e.work,{bits:5}),d=!1}e.lencode=f,e.lenbits=9,e.distcode=l,e.distbits=5}function Z(e,t,r,n){var i,s=e.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new I.Buf8(s.wsize)),n>=s.wsize?(I.arraySet(s.window,t,r-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(n<(i=s.wsize-s.wnext)&&(i=n),I.arraySet(s.window,t,r-n,i,s.wnext),(n-=i)?(I.arraySet(s.window,t,r-n,n,0),s.wnext=n,s.whave=s.wsize):(s.wnext+=i,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=i))),0}r.inflateReset=o,r.inflateReset2=u,r.inflateResetKeep=a,r.inflateInit=function(e){return h(e,15)},r.inflateInit2=h,r.inflate=function(e,t){var r,n,i,s,a,o,u,h,f,l,d,c,p,m,_,g,v,b,w,y,k,x,S,z,C=0,E=new I.Buf8(4),A=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return U;12===(r=e.state).mode&&(r.mode=13),a=e.next_out,i=e.output,u=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,h=r.hold,f=r.bits,l=o,d=u,x=N;e:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=13;break}for(;f<16;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(2&r.wrap&&35615===h){E[r.check=0]=255&h,E[1]=h>>>8&255,r.check=B(r.check,E,2,0),f=h=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&h)<<8)+(h>>8))%31){e.msg=\"incorrect header check\",r.mode=30;break}if(8!=(15&h)){e.msg=\"unknown compression method\",r.mode=30;break}if(f-=4,k=8+(15&(h>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){e.msg=\"invalid window size\",r.mode=30;break}r.dmax=1<<k,e.adler=r.check=1,r.mode=512&h?10:12,f=h=0;break;case 2:for(;f<16;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(r.flags=h,8!=(255&r.flags)){e.msg=\"unknown compression method\",r.mode=30;break}if(57344&r.flags){e.msg=\"unknown header flags set\",r.mode=30;break}r.head&&(r.head.text=h>>8&1),512&r.flags&&(E[0]=255&h,E[1]=h>>>8&255,r.check=B(r.check,E,2,0)),f=h=0,r.mode=3;case 3:for(;f<32;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}r.head&&(r.head.time=h),512&r.flags&&(E[0]=255&h,E[1]=h>>>8&255,E[2]=h>>>16&255,E[3]=h>>>24&255,r.check=B(r.check,E,4,0)),f=h=0,r.mode=4;case 4:for(;f<16;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}r.head&&(r.head.xflags=255&h,r.head.os=h>>8),512&r.flags&&(E[0]=255&h,E[1]=h>>>8&255,r.check=B(r.check,E,2,0)),f=h=0,r.mode=5;case 5:if(1024&r.flags){for(;f<16;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}r.length=h,r.head&&(r.head.extra_len=h),512&r.flags&&(E[0]=255&h,E[1]=h>>>8&255,r.check=B(r.check,E,2,0)),f=h=0}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&(o<(c=r.length)&&(c=o),c&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),I.arraySet(r.head.extra,n,s,c,k)),512&r.flags&&(r.check=B(r.check,n,c,s)),o-=c,s+=c,r.length-=c),r.length))break e;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===o)break e;for(c=0;k=n[s+c++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,n,c,s)),o-=c,s+=c,k)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===o)break e;for(c=0;k=n[s+c++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,n,c,s)),o-=c,s+=c,k)break e}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;f<16;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(h!==(65535&r.check)){e.msg=\"header crc mismatch\",r.mode=30;break}f=h=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=12;break;case 10:for(;f<32;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}e.adler=r.check=L(h),f=h=0,r.mode=11;case 11:if(0===r.havedict)return e.next_out=a,e.avail_out=u,e.next_in=s,e.avail_in=o,r.hold=h,r.bits=f,2;e.adler=r.check=1,r.mode=12;case 12:if(5===t||6===t)break e;case 13:if(r.last){h>>>=7&f,f-=7&f,r.mode=27;break}for(;f<3;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}switch(r.last=1&h,f-=1,3&(h>>>=1)){case 0:r.mode=14;break;case 1:if(j(r),r.mode=20,6!==t)break;h>>>=2,f-=2;break e;case 2:r.mode=17;break;case 3:e.msg=\"invalid block type\",r.mode=30}h>>>=2,f-=2;break;case 14:for(h>>>=7&f,f-=7&f;f<32;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if((65535&h)!=(h>>>16^65535)){e.msg=\"invalid stored block lengths\",r.mode=30;break}if(r.length=65535&h,f=h=0,r.mode=15,6===t)break e;case 15:r.mode=16;case 16:if(c=r.length){if(o<c&&(c=o),u<c&&(c=u),0===c)break e;I.arraySet(i,n,s,c,a),o-=c,s+=c,u-=c,a+=c,r.length-=c;break}r.mode=12;break;case 17:for(;f<14;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(r.nlen=257+(31&h),h>>>=5,f-=5,r.ndist=1+(31&h),h>>>=5,f-=5,r.ncode=4+(15&h),h>>>=4,f-=4,286<r.nlen||30<r.ndist){e.msg=\"too many length or distance symbols\",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;f<3;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}r.lens[A[r.have++]]=7&h,h>>>=3,f-=3}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},x=T(0,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,x){e.msg=\"invalid code lengths set\",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;g=(C=r.lencode[h&(1<<r.lenbits)-1])>>>16&255,v=65535&C,!((_=C>>>24)<=f);){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(v<16)h>>>=_,f-=_,r.lens[r.have++]=v;else{if(16===v){for(z=_+2;f<z;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(h>>>=_,f-=_,0===r.have){e.msg=\"invalid bit length repeat\",r.mode=30;break}k=r.lens[r.have-1],c=3+(3&h),h>>>=2,f-=2}else if(17===v){for(z=_+3;f<z;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}f-=_,k=0,c=3+(7&(h>>>=_)),h>>>=3,f-=3}else{for(z=_+7;f<z;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}f-=_,k=0,c=11+(127&(h>>>=_)),h>>>=7,f-=7}if(r.have+c>r.nlen+r.ndist){e.msg=\"invalid bit length repeat\",r.mode=30;break}for(;c--;)r.lens[r.have++]=k}}if(30===r.mode)break;if(0===r.lens[256]){e.msg=\"invalid code -- missing end-of-block\",r.mode=30;break}if(r.lenbits=9,S={bits:r.lenbits},x=T(D,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,x){e.msg=\"invalid literal\/lengths set\",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},x=T(F,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,x){e.msg=\"invalid distances set\",r.mode=30;break}if(r.mode=20,6===t)break e;case 20:r.mode=21;case 21:if(6<=o&&258<=u){e.next_out=a,e.avail_out=u,e.next_in=s,e.avail_in=o,r.hold=h,r.bits=f,R(e,d),a=e.next_out,i=e.output,u=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,h=r.hold,f=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;g=(C=r.lencode[h&(1<<r.lenbits)-1])>>>16&255,v=65535&C,!((_=C>>>24)<=f);){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(g&&0==(240&g)){for(b=_,w=g,y=v;g=(C=r.lencode[y+((h&(1<<b+w)-1)>>b)])>>>16&255,v=65535&C,!(b+(_=C>>>24)<=f);){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}h>>>=b,f-=b,r.back+=b}if(h>>>=_,f-=_,r.back+=_,r.length=v,0===g){r.mode=26;break}if(32&g){r.back=-1,r.mode=12;break}if(64&g){e.msg=\"invalid literal\/length code\",r.mode=30;break}r.extra=15&g,r.mode=22;case 22:if(r.extra){for(z=r.extra;f<z;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}r.length+=h&(1<<r.extra)-1,h>>>=r.extra,f-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=23;case 23:for(;g=(C=r.distcode[h&(1<<r.distbits)-1])>>>16&255,v=65535&C,!((_=C>>>24)<=f);){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(0==(240&g)){for(b=_,w=g,y=v;g=(C=r.distcode[y+((h&(1<<b+w)-1)>>b)])>>>16&255,v=65535&C,!(b+(_=C>>>24)<=f);){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}h>>>=b,f-=b,r.back+=b}if(h>>>=_,f-=_,r.back+=_,64&g){e.msg=\"invalid distance code\",r.mode=30;break}r.offset=v,r.extra=15&g,r.mode=24;case 24:if(r.extra){for(z=r.extra;f<z;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}r.offset+=h&(1<<r.extra)-1,h>>>=r.extra,f-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){e.msg=\"invalid distance too far back\",r.mode=30;break}r.mode=25;case 25:if(0===u)break e;if(c=d-u,r.offset>c){if((c=r.offset-c)>r.whave&&r.sane){e.msg=\"invalid distance too far back\",r.mode=30;break}p=c>r.wnext?(c-=r.wnext,r.wsize-c):r.wnext-c,c>r.length&&(c=r.length),m=r.window}else m=i,p=a-r.offset,c=r.length;for(u<c&&(c=u),u-=c,r.length-=c;i[a++]=m[p++],--c;);0===r.length&&(r.mode=21);break;case 26:if(0===u)break e;i[a++]=r.length,u--,r.mode=21;break;case 27:if(r.wrap){for(;f<32;){if(0===o)break e;o--,h|=n[s++]<<f,f+=8}if(d-=u,e.total_out+=d,r.total+=d,d&&(e.adler=r.check=r.flags?B(r.check,i,d,a-d):O(r.check,i,d,a-d)),d=u,(r.flags?h:L(h))!==r.check){e.msg=\"incorrect data check\",r.mode=30;break}f=h=0}r.mode=28;case 28:if(r.wrap&&r.flags){for(;f<32;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(h!==(4294967295&r.total)){e.msg=\"incorrect length check\",r.mode=30;break}f=h=0}r.mode=29;case 29:x=1;break e;case 30:x=-3;break e;case 31:return-4;case 32:default:return U}return e.next_out=a,e.avail_out=u,e.next_in=s,e.avail_in=o,r.hold=h,r.bits=f,(r.wsize||d!==e.avail_out&&r.mode<30&&(r.mode<27||4!==t))&&Z(e,e.output,e.next_out,d-e.avail_out)?(r.mode=31,-4):(l-=e.avail_in,d-=e.avail_out,e.total_in+=l,e.total_out+=d,r.total+=d,r.wrap&&d&&(e.adler=r.check=r.flags?B(r.check,i,d,e.next_out-d):O(r.check,i,d,e.next_out-d)),e.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0==l&&0===d||4===t)&&x===N&&(x=-5),x)},r.inflateEnd=function(e){if(!e||!e.state)return U;var t=e.state;return t.window&&(t.window=null),e.state=null,N},r.inflateGetHeader=function(e,t){var r;return e&&e.state?0==(2&(r=e.state).wrap)?U:((r.head=t).done=!1,N):U},r.inflateSetDictionary=function(e,t){var r,n=t.length;return e&&e.state?0!==(r=e.state).wrap&&11!==r.mode?U:11===r.mode&&O(1,t,n,0)!==r.check?-3:Z(e,t,n,n)?(r.mode=31,-4):(r.havedict=1,N):U},r.inflateInfo=\"pako inflate (from Nodeca project)\"},{\"..\/utils\/common\":41,\".\/adler32\":43,\".\/crc32\":45,\".\/inffast\":48,\".\/inftrees\":50}],50:[function(e,t,r){\"use strict\";var D=e(\"..\/utils\/common\"),F=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],N=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],U=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],P=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];t.exports=function(e,t,r,n,i,s,a,o){var u,h,f,l,d,c,p,m,_,g=o.bits,v=0,b=0,w=0,y=0,k=0,x=0,S=0,z=0,C=0,E=0,A=null,I=0,O=new D.Buf16(16),B=new D.Buf16(16),R=null,T=0;for(v=0;v<=15;v++)O[v]=0;for(b=0;b<n;b++)O[t[r+b]]++;for(k=g,y=15;1<=y&&0===O[y];y--);if(y<k&&(k=y),0===y)return i[s++]=20971520,i[s++]=20971520,o.bits=1,0;for(w=1;w<y&&0===O[w];w++);for(k<w&&(k=w),v=z=1;v<=15;v++)if(z<<=1,(z-=O[v])<0)return-1;if(0<z&&(0===e||1!==y))return-1;for(B[1]=0,v=1;v<15;v++)B[v+1]=B[v]+O[v];for(b=0;b<n;b++)0!==t[r+b]&&(a[B[t[r+b]]++]=b);if(c=0===e?(A=R=a,19):1===e?(A=F,I-=257,R=N,T-=257,256):(A=U,R=P,-1),v=w,d=s,S=b=E=0,f=-1,l=(C=1<<(x=k))-1,1===e&&852<C||2===e&&592<C)return 1;for(;;){for(p=v-S,_=a[b]<c?(m=0,a[b]):a[b]>c?(m=R[T+a[b]],A[I+a[b]]):(m=96,0),u=1<<v-S,w=h=1<<x;i[d+(E>>S)+(h-=u)]=p<<24|m<<16|_|0,0!==h;);for(u=1<<v-1;E&u;)u>>=1;if(0!==u?(E&=u-1,E+=u):E=0,b++,0==--O[v]){if(v===y)break;v=t[r+a[b]]}if(k<v&&(E&l)!==f){for(0===S&&(S=k),d+=w,z=1<<(x=v-S);x+S<y&&!((z-=O[x+S])<=0);)x++,z<<=1;if(C+=1<<x,1===e&&852<C||2===e&&592<C)return 1;i[f=E&l]=k<<24|x<<16|d-s|0}}return 0!==E&&(i[d+E]=v-S<<24|64<<16|0),o.bits=k,0}},{\"..\/utils\/common\":41}],51:[function(e,t,r){\"use strict\";t.exports={2:\"need dictionary\",1:\"stream end\",0:\"\",\"-1\":\"file error\",\"-2\":\"stream error\",\"-3\":\"data error\",\"-4\":\"insufficient memory\",\"-5\":\"buffer error\",\"-6\":\"incompatible version\"}},{}],52:[function(e,t,r){\"use strict\";var o=e(\"..\/utils\/common\");function n(e){for(var t=e.length;0<=--t;)e[t]=0}var _=15,i=16,u=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],h=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],f=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],l=new Array(576);n(l);var d=new Array(60);n(d);var c=new Array(512);n(c);var p=new Array(256);n(p);var m=new Array(29);n(m);var g,v,b,w=new Array(30);function y(e,t,r,n,i){this.static_tree=e,this.extra_bits=t,this.extra_base=r,this.elems=n,this.max_length=i,this.has_stree=e&&e.length}function s(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t}function k(e){return e<256?c[e]:c[256+(e>>>7)]}function x(e,t){e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255}function S(e,t,r){e.bi_valid>i-r?(e.bi_buf|=t<<e.bi_valid&65535,x(e,e.bi_buf),e.bi_buf=t>>i-e.bi_valid,e.bi_valid+=r-i):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=r)}function z(e,t,r){S(e,r[2*t],r[2*t+1])}function C(e,t){for(var r=0;r|=1&e,e>>>=1,r<<=1,0<--t;);return r>>>1}function E(e,t,r){var n,i,s=new Array(_+1),a=0;for(n=1;n<=_;n++)s[n]=a=a+r[n-1]<<1;for(i=0;i<=t;i++){var o=e[2*i+1];0!==o&&(e[2*i]=C(s[o]++,o))}}function A(e){var t;for(t=0;t<286;t++)e.dyn_ltree[2*t]=0;for(t=0;t<30;t++)e.dyn_dtree[2*t]=0;for(t=0;t<19;t++)e.bl_tree[2*t]=0;e.dyn_ltree[512]=1,e.opt_len=e.static_len=0,e.last_lit=e.matches=0}function I(e){8<e.bi_valid?x(e,e.bi_buf):0<e.bi_valid&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0}function O(e,t,r,n){var i=2*t,s=2*r;return e[i]<e[s]||e[i]===e[s]&&n[t]<=n[r]}function B(e,t,r){for(var n=e.heap[r],i=r<<1;i<=e.heap_len&&(i<e.heap_len&&O(t,e.heap[i+1],e.heap[i],e.depth)&&i++,!O(t,n,e.heap[i],e.depth));)e.heap[r]=e.heap[i],r=i,i<<=1;e.heap[r]=n}function R(e,t,r){var n,i,s,a,o=0;if(0!==e.last_lit)for(;n=e.pending_buf[e.d_buf+2*o]<<8|e.pending_buf[e.d_buf+2*o+1],i=e.pending_buf[e.l_buf+o],o++,0===n?z(e,i,t):(z(e,(s=p[i])+256+1,t),0!==(a=u[s])&&S(e,i-=m[s],a),z(e,s=k(--n),r),0!==(a=h[s])&&S(e,n-=w[s],a)),o<e.last_lit;);z(e,256,t)}function T(e,t){var r,n,i,s=t.dyn_tree,a=t.stat_desc.static_tree,o=t.stat_desc.has_stree,u=t.stat_desc.elems,h=-1;for(e.heap_len=0,e.heap_max=573,r=0;r<u;r++)0!==s[2*r]?(e.heap[++e.heap_len]=h=r,e.depth[r]=0):s[2*r+1]=0;for(;e.heap_len<2;)s[2*(i=e.heap[++e.heap_len]=h<2?++h:0)]=1,e.depth[i]=0,e.opt_len--,o&&(e.static_len-=a[2*i+1]);for(t.max_code=h,r=e.heap_len>>1;1<=r;r--)B(e,s,r);for(i=u;r=e.heap[1],e.heap[1]=e.heap[e.heap_len--],B(e,s,1),n=e.heap[1],e.heap[--e.heap_max]=r,e.heap[--e.heap_max]=n,s[2*i]=s[2*r]+s[2*n],e.depth[i]=(e.depth[r]>=e.depth[n]?e.depth[r]:e.depth[n])+1,s[2*r+1]=s[2*n+1]=i,e.heap[1]=i++,B(e,s,1),2<=e.heap_len;);e.heap[--e.heap_max]=e.heap[1],function(e,t){var r,n,i,s,a,o,u=t.dyn_tree,h=t.max_code,f=t.stat_desc.static_tree,l=t.stat_desc.has_stree,d=t.stat_desc.extra_bits,c=t.stat_desc.extra_base,p=t.stat_desc.max_length,m=0;for(s=0;s<=_;s++)e.bl_count[s]=0;for(u[2*e.heap[e.heap_max]+1]=0,r=e.heap_max+1;r<573;r++)p<(s=u[2*u[2*(n=e.heap[r])+1]+1]+1)&&(s=p,m++),u[2*n+1]=s,h<n||(e.bl_count[s]++,a=0,c<=n&&(a=d[n-c]),o=u[2*n],e.opt_len+=o*(s+a),l&&(e.static_len+=o*(f[2*n+1]+a)));if(0!==m){do{for(s=p-1;0===e.bl_count[s];)s--;e.bl_count[s]--,e.bl_count[s+1]+=2,e.bl_count[p]--,m-=2}while(0<m);for(s=p;0!==s;s--)for(n=e.bl_count[s];0!==n;)h<(i=e.heap[--r])||(u[2*i+1]!==s&&(e.opt_len+=(s-u[2*i+1])*u[2*i],u[2*i+1]=s),n--)}}(e,t),E(s,h,e.bl_count)}function D(e,t,r){var n,i,s=-1,a=t[1],o=0,u=7,h=4;for(0===a&&(u=138,h=3),t[2*(r+1)+1]=65535,n=0;n<=r;n++)i=a,a=t[2*(n+1)+1],++o<u&&i===a||(o<h?e.bl_tree[2*i]+=o:0!==i?(i!==s&&e.bl_tree[2*i]++,e.bl_tree[32]++):o<=10?e.bl_tree[34]++:e.bl_tree[36]++,s=i,h=(o=0)===a?(u=138,3):i===a?(u=6,3):(u=7,4))}function F(e,t,r){var n,i,s=-1,a=t[1],o=0,u=7,h=4;for(0===a&&(u=138,h=3),n=0;n<=r;n++)if(i=a,a=t[2*(n+1)+1],!(++o<u&&i===a)){if(o<h)for(;z(e,i,e.bl_tree),0!=--o;);else 0!==i?(i!==s&&(z(e,i,e.bl_tree),o--),z(e,16,e.bl_tree),S(e,o-3,2)):o<=10?(z(e,17,e.bl_tree),S(e,o-3,3)):(z(e,18,e.bl_tree),S(e,o-11,7));s=i,h=(o=0)===a?(u=138,3):i===a?(u=6,3):(u=7,4)}}n(w);var N=!1;function U(e,t,r,n){var i,s,a;S(e,0+(n?1:0),3),s=t,a=r,I(i=e),x(i,a),x(i,~a),o.arraySet(i.pending_buf,i.window,s,a,i.pending),i.pending+=a}r._tr_init=function(e){N||(function(){var e,t,r,n,i,s=new Array(_+1);for(n=r=0;n<28;n++)for(m[n]=r,e=0;e<1<<u[n];e++)p[r++]=n;for(p[r-1]=n,n=i=0;n<16;n++)for(w[n]=i,e=0;e<1<<h[n];e++)c[i++]=n;for(i>>=7;n<30;n++)for(w[n]=i<<7,e=0;e<1<<h[n]-7;e++)c[256+i++]=n;for(t=0;t<=_;t++)s[t]=0;for(e=0;e<=143;)l[2*e+1]=8,e++,s[8]++;for(;e<=255;)l[2*e+1]=9,e++,s[9]++;for(;e<=279;)l[2*e+1]=7,e++,s[7]++;for(;e<=287;)l[2*e+1]=8,e++,s[8]++;for(E(l,287,s),e=0;e<30;e++)d[2*e+1]=5,d[2*e]=C(e,5);g=new y(l,u,257,286,_),v=new y(d,h,0,30,_),b=new y(new Array(0),a,0,19,7)}(),N=!0),e.l_desc=new s(e.dyn_ltree,g),e.d_desc=new s(e.dyn_dtree,v),e.bl_desc=new s(e.bl_tree,b),e.bi_buf=0,e.bi_valid=0,A(e)},r._tr_stored_block=U,r._tr_flush_block=function(e,t,r,n){var i,s,a=0;0<e.level?(2===e.strm.data_type&&(e.strm.data_type=function(e){var t,r=4093624447;for(t=0;t<=31;t++,r>>>=1)if(1&r&&0!==e.dyn_ltree[2*t])return 0;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return 1;for(t=32;t<256;t++)if(0!==e.dyn_ltree[2*t])return 1;return 0}(e)),T(e,e.l_desc),T(e,e.d_desc),a=function(e){var t;for(D(e,e.dyn_ltree,e.l_desc.max_code),D(e,e.dyn_dtree,e.d_desc.max_code),T(e,e.bl_desc),t=18;3<=t&&0===e.bl_tree[2*f[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t}(e),i=e.opt_len+3+7>>>3,(s=e.static_len+3+7>>>3)<=i&&(i=s)):i=s=r+5,r+4<=i&&-1!==t?U(e,t,r,n):4===e.strategy||s===i?(S(e,2+(n?1:0),3),R(e,l,d)):(S(e,4+(n?1:0),3),function(e,t,r,n){var i;for(S(e,t-257,5),S(e,r-1,5),S(e,n-4,4),i=0;i<n;i++)S(e,e.bl_tree[2*f[i]+1],3);F(e,e.dyn_ltree,t-1),F(e,e.dyn_dtree,r-1)}(e,e.l_desc.max_code+1,e.d_desc.max_code+1,a+1),R(e,e.dyn_ltree,e.dyn_dtree)),A(e),n&&I(e)},r._tr_tally=function(e,t,r){return e.pending_buf[e.d_buf+2*e.last_lit]=t>>>8&255,e.pending_buf[e.d_buf+2*e.last_lit+1]=255&t,e.pending_buf[e.l_buf+e.last_lit]=255&r,e.last_lit++,0===t?e.dyn_ltree[2*r]++:(e.matches++,t--,e.dyn_ltree[2*(p[r]+256+1)]++,e.dyn_dtree[2*k(t)]++),e.last_lit===e.lit_bufsize-1},r._tr_align=function(e){var t;S(e,2,3),z(e,256,l),16===(t=e).bi_valid?(x(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):8<=t.bi_valid&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}},{\"..\/utils\/common\":41}],53:[function(e,t,r){\"use strict\";t.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=\"\",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(e,t,r){\"use strict\";t.exports=\"function\"==typeof setImmediate?setImmediate:function(){var e=[].slice.apply(arguments);e.splice(1,0,0),setTimeout.apply(null,e)}},{}]},{},[10])(10)})}).call(this,void 0!==r?r:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}]},{},[1])(1)})}).call(this,void 0!==r?r:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}]},{},[1])(1)})}).call(this,void 0!==r?r:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}]},{},[1])(1)})}).call(this,\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}]},{},[1])(1)});\n-}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n-},{}]},{},[1])(1)\n+    var self = this;\n+    helper.on(\"data\", function (data, meta) {\n+        if (!self.push(data)) {\n+            self._helper.pause();\n+        }\n+        if(updateCb) {\n+            updateCb(meta);\n+        }\n+    })\n+    .on(\"error\", function(e) {\n+        self.emit('error', e);\n+    })\n+    .on(\"end\", function () {\n+        self.push(null);\n+    });\n+}\n+\n+\n+NodejsStreamOutputAdapter.prototype._read = function() {\n+    this._helper.resume();\n+};\n+\n+module.exports = NodejsStreamOutputAdapter;\n+\n+},{\"..\/utils\":32,\"readable-stream\":16}],14:[function(require,module,exports){\n+'use strict';\n+\n+module.exports = {\n+    \/**\n+     * True if this is running in Nodejs, will be undefined in a browser.\n+     * In a browser, browserify won't include this file and the whole module\n+     * will be resolved an empty object.\n+     *\/\n+    isNode : typeof Buffer !== \"undefined\",\n+    \/**\n+     * Create a new nodejs Buffer from an existing content.\n+     * @param {Object} data the data to pass to the constructor.\n+     * @param {String} encoding the encoding to use.\n+     * @return {Buffer} a new Buffer.\n+     *\/\n+    newBufferFrom: function(data, encoding) {\n+        if (Buffer.from && Buffer.from !== Uint8Array.from) {\n+            return Buffer.from(data, encoding);\n+        } else {\n+            if (typeof data === \"number\") {\n+                \/\/ Safeguard for old Node.js versions. On newer versions,\n+                \/\/ Buffer.from(number) \/ Buffer(number, encoding) already throw.\n+                throw new Error(\"The \\\"data\\\" argument must not be a number\");\n+            }\n+            return new Buffer(data, encoding);\n+        }\n+    },\n+    \/**\n+     * Create a new nodejs Buffer with the specified size.\n+     * @param {Integer} size the size of the buffer.\n+     * @return {Buffer} a new Buffer.\n+     *\/\n+    allocBuffer: function (size) {\n+        if (Buffer.alloc) {\n+            return Buffer.alloc(size);\n+        } else {\n+            var buf = new Buffer(size);\n+            buf.fill(0);\n+            return buf;\n+        }\n+    },\n+    \/**\n+     * Find out if an object is a Buffer.\n+     * @param {Object} b the object to test.\n+     * @return {Boolean} true if the object is a Buffer, false otherwise.\n+     *\/\n+    isBuffer : function(b){\n+        return Buffer.isBuffer(b);\n+    },\n+\n+    isStream : function (obj) {\n+        return obj &&\n+            typeof obj.on === \"function\" &&\n+            typeof obj.pause === \"function\" &&\n+            typeof obj.resume === \"function\";\n+    }\n+};\n+\n+},{}],15:[function(require,module,exports){\n+'use strict';\n+var utf8 = require('.\/utf8');\n+var utils = require('.\/utils');\n+var GenericWorker = require('.\/stream\/GenericWorker');\n+var StreamHelper = require('.\/stream\/StreamHelper');\n+var defaults = require('.\/defaults');\n+var CompressedObject = require('.\/compressedObject');\n+var ZipObject = require('.\/zipObject');\n+var generate = require(\".\/generate\");\n+var nodejsUtils = require(\".\/nodejsUtils\");\n+var NodejsStreamInputAdapter = require(\".\/nodejs\/NodejsStreamInputAdapter\");\n+\n+\n+\/**\n+ * Add a file in the current folder.\n+ * @private\n+ * @param {string} name the name of the file\n+ * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n+ * @param {Object} originalOptions the options of the file\n+ * @return {Object} the new file.\n+ *\/\n+var fileAdd = function(name, data, originalOptions) {\n+    \/\/ be sure sub folders exist\n+    var dataType = utils.getTypeOf(data),\n+        parent;\n+\n+\n+    \/*\n+     * Correct options.\n+     *\/\n+\n+    var o = utils.extend(originalOptions || {}, defaults);\n+    o.date = o.date || new Date();\n+    if (o.compression !== null) {\n+        o.compression = o.compression.toUpperCase();\n+    }\n+\n+    if (typeof o.unixPermissions === \"string\") {\n+        o.unixPermissions = parseInt(o.unixPermissions, 8);\n+    }\n+\n+    \/\/ UNX_IFDIR  0040000 see zipinfo.c\n+    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {\n+        o.dir = true;\n+    }\n+    \/\/ Bit 4    Directory\n+    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {\n+        o.dir = true;\n+    }\n+\n+    if (o.dir) {\n+        name = forceTrailingSlash(name);\n+    }\n+    if (o.createFolders && (parent = parentFolder(name))) {\n+        folderAdd.call(this, parent, true);\n+    }\n+\n+    var isUnicodeString = dataType === \"string\" && o.binary === false && o.base64 === false;\n+    if (!originalOptions || typeof originalOptions.binary === \"undefined\") {\n+        o.binary = !isUnicodeString;\n+    }\n+\n+\n+    var isCompressedEmpty = (data instanceof CompressedObject) && data.uncompressedSize === 0;\n+\n+    if (isCompressedEmpty || o.dir || !data || data.length === 0) {\n+        o.base64 = false;\n+        o.binary = true;\n+        data = \"\";\n+        o.compression = \"STORE\";\n+        dataType = \"string\";\n+    }\n+\n+    \/*\n+     * Convert content to fit.\n+     *\/\n+\n+    var zipObjectContent = null;\n+    if (data instanceof CompressedObject || data instanceof GenericWorker) {\n+        zipObjectContent = data;\n+    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {\n+        zipObjectContent = new NodejsStreamInputAdapter(name, data);\n+    } else {\n+        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);\n+    }\n+\n+    var object = new ZipObject(name, zipObjectContent, o);\n+    this.files[name] = object;\n+    \/*\n+    TODO: we can't throw an exception because we have async promises\n+    (we can have a promise of a Date() for example) but returning a\n+    promise is useless because file(name, data) returns the JSZip\n+    object for chaining. Should we break that to allow the user\n+    to catch the error ?\n+\n+    return external.Promise.resolve(zipObjectContent)\n+    .then(function () {\n+        return object;\n+    });\n+    *\/\n+};\n+\n+\/**\n+ * Find the parent folder of the path.\n+ * @private\n+ * @param {string} path the path to use\n+ * @return {string} the parent folder, or \"\"\n+ *\/\n+var parentFolder = function (path) {\n+    if (path.slice(-1) === '\/') {\n+        path = path.substring(0, path.length - 1);\n+    }\n+    var lastSlash = path.lastIndexOf('\/');\n+    return (lastSlash > 0) ? path.substring(0, lastSlash) : \"\";\n+};\n+\n+\/**\n+ * Returns the path with a slash at the end.\n+ * @private\n+ * @param {String} path the path to check.\n+ * @return {String} the path with a trailing slash.\n+ *\/\n+var forceTrailingSlash = function(path) {\n+    \/\/ Check the name ends with a \/\n+    if (path.slice(-1) !== \"\/\") {\n+        path += \"\/\"; \/\/ IE doesn't like substr(-1)\n+    }\n+    return path;\n+};\n+\n+\/**\n+ * Add a (sub) folder in the current folder.\n+ * @private\n+ * @param {string} name the folder's name\n+ * @param {boolean=} [createFolders] If true, automatically create sub\n+ *  folders. Defaults to false.\n+ * @return {Object} the new folder.\n+ *\/\n+var folderAdd = function(name, createFolders) {\n+    createFolders = (typeof createFolders !== 'undefined') ? createFolders : defaults.createFolders;\n+\n+    name = forceTrailingSlash(name);\n+\n+    \/\/ Does this folder already exist?\n+    if (!this.files[name]) {\n+        fileAdd.call(this, name, null, {\n+            dir: true,\n+            createFolders: createFolders\n+        });\n+    }\n+    return this.files[name];\n+};\n+\n+\/**\n+* Cross-window, cross-Node-context regular expression detection\n+* @param  {Object}  object Anything\n+* @return {Boolean}        true if the object is a regular expression,\n+* false otherwise\n+*\/\n+function isRegExp(object) {\n+    return Object.prototype.toString.call(object) === \"[object RegExp]\";\n+}\n+\n+\/\/ return the actual prototype of JSZip\n+var out = {\n+    \/**\n+     * @see loadAsync\n+     *\/\n+    load: function() {\n+        throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n+    },\n+\n+\n+    \/**\n+     * Call a callback function for each entry at this folder level.\n+     * @param {Function} cb the callback function:\n+     * function (relativePath, file) {...}\n+     * It takes 2 arguments : the relative path and the file.\n+     *\/\n+    forEach: function(cb) {\n+        var filename, relativePath, file;\n+        \/* jshint ignore:start *\/\n+        \/\/ ignore warning about unwanted properties because this.files is a null prototype object\n+        for (filename in this.files) {\n+            file = this.files[filename];\n+            relativePath = filename.slice(this.root.length, filename.length);\n+            if (relativePath && filename.slice(0, this.root.length) === this.root) { \/\/ the file is in the current root\n+                cb(relativePath, file); \/\/ TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...\n+            }\n+        }\n+        \/* jshint ignore:end *\/\n+    },\n+\n+    \/**\n+     * Filter nested files\/folders with the specified function.\n+     * @param {Function} search the predicate to use :\n+     * function (relativePath, file) {...}\n+     * It takes 2 arguments : the relative path and the file.\n+     * @return {Array} An array of matching elements.\n+     *\/\n+    filter: function(search) {\n+        var result = [];\n+        this.forEach(function (relativePath, entry) {\n+            if (search(relativePath, entry)) { \/\/ the file matches the function\n+                result.push(entry);\n+            }\n+\n+        });\n+        return result;\n+    },\n+\n+    \/**\n+     * Add a file to the zip file, or search a file.\n+     * @param   {string|RegExp} name The name of the file to add (if data is defined),\n+     * the name of the file to find (if no data) or a regex to match files.\n+     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n+     * @param   {Object} o     File options\n+     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n+     * a file (when searching by string) or an array of files (when searching by regex).\n+     *\/\n+    file: function(name, data, o) {\n+        if (arguments.length === 1) {\n+            if (isRegExp(name)) {\n+                var regexp = name;\n+                return this.filter(function(relativePath, file) {\n+                    return !file.dir && regexp.test(relativePath);\n+                });\n+            }\n+            else { \/\/ text\n+                var obj = this.files[this.root + name];\n+                if (obj && !obj.dir) {\n+                    return obj;\n+                } else {\n+                    return null;\n+                }\n+            }\n+        }\n+        else { \/\/ more than one argument : we have data !\n+            name = this.root + name;\n+            fileAdd.call(this, name, data, o);\n+        }\n+        return this;\n+    },\n+\n+    \/**\n+     * Add a directory to the zip file, or search.\n+     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n+     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n+     *\/\n+    folder: function(arg) {\n+        if (!arg) {\n+            return this;\n+        }\n+\n+        if (isRegExp(arg)) {\n+            return this.filter(function(relativePath, file) {\n+                return file.dir && arg.test(relativePath);\n+            });\n+        }\n+\n+        \/\/ else, name is a new folder\n+        var name = this.root + arg;\n+        var newFolder = folderAdd.call(this, name);\n+\n+        \/\/ Allow chaining by returning a new object with this folder as the root\n+        var ret = this.clone();\n+        ret.root = newFolder.name;\n+        return ret;\n+    },\n+\n+    \/**\n+     * Delete a file, or a directory and all sub-files, from the zip\n+     * @param {string} name the name of the file to delete\n+     * @return {JSZip} this JSZip object\n+     *\/\n+    remove: function(name) {\n+        name = this.root + name;\n+        var file = this.files[name];\n+        if (!file) {\n+            \/\/ Look for any folders\n+            if (name.slice(-1) !== \"\/\") {\n+                name += \"\/\";\n+            }\n+            file = this.files[name];\n+        }\n+\n+        if (file && !file.dir) {\n+            \/\/ file\n+            delete this.files[name];\n+        } else {\n+            \/\/ maybe a folder, delete recursively\n+            var kids = this.filter(function(relativePath, file) {\n+                return file.name.slice(0, name.length) === name;\n+            });\n+            for (var i = 0; i < kids.length; i++) {\n+                delete this.files[kids[i].name];\n+            }\n+        }\n+\n+        return this;\n+    },\n+\n+    \/**\n+     * Generate the complete zip file\n+     * @param {Object} options the options to generate the zip file :\n+     * - compression, \"STORE\" by default.\n+     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n+     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file\n+     *\/\n+    generate: function(options) {\n+        throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n+    },\n+\n+    \/**\n+     * Generate the complete zip file as an internal stream.\n+     * @param {Object} options the options to generate the zip file :\n+     * - compression, \"STORE\" by default.\n+     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n+     * @return {StreamHelper} the streamed zip file.\n+     *\/\n+    generateInternalStream: function(options) {\n+      var worker, opts = {};\n+      try {\n+          opts = utils.extend(options || {}, {\n+              streamFiles: false,\n+              compression: \"STORE\",\n+              compressionOptions : null,\n+              type: \"\",\n+              platform: \"DOS\",\n+              comment: null,\n+              mimeType: 'application\/zip',\n+              encodeFileName: utf8.utf8encode\n+          });\n+\n+          opts.type = opts.type.toLowerCase();\n+          opts.compression = opts.compression.toUpperCase();\n+\n+          \/\/ \"binarystring\" is preferred but the internals use \"string\".\n+          if(opts.type === \"binarystring\") {\n+            opts.type = \"string\";\n+          }\n+\n+          if (!opts.type) {\n+            throw new Error(\"No output type specified.\");\n+          }\n+\n+          utils.checkSupport(opts.type);\n+\n+          \/\/ accept nodejs `process.platform`\n+          if(\n+              opts.platform === 'darwin' ||\n+              opts.platform === 'freebsd' ||\n+              opts.platform === 'linux' ||\n+              opts.platform === 'sunos'\n+          ) {\n+              opts.platform = \"UNIX\";\n+          }\n+          if (opts.platform === 'win32') {\n+              opts.platform = \"DOS\";\n+          }\n+\n+          var comment = opts.comment || this.comment || \"\";\n+          worker = generate.generateWorker(this, opts, comment);\n+      } catch (e) {\n+        worker = new GenericWorker(\"error\");\n+        worker.error(e);\n+      }\n+      return new StreamHelper(worker, opts.type || \"string\", opts.mimeType);\n+    },\n+    \/**\n+     * Generate the complete zip file asynchronously.\n+     * @see generateInternalStream\n+     *\/\n+    generateAsync: function(options, onUpdate) {\n+        return this.generateInternalStream(options).accumulate(onUpdate);\n+    },\n+    \/**\n+     * Generate the complete zip file asynchronously.\n+     * @see generateInternalStream\n+     *\/\n+    generateNodeStream: function(options, onUpdate) {\n+        options = options || {};\n+        if (!options.type) {\n+            options.type = \"nodebuffer\";\n+        }\n+        return this.generateInternalStream(options).toNodejsStream(onUpdate);\n+    }\n+};\n+module.exports = out;\n+\n+},{\".\/compressedObject\":2,\".\/defaults\":5,\".\/generate\":9,\".\/nodejs\/NodejsStreamInputAdapter\":12,\".\/nodejsUtils\":14,\".\/stream\/GenericWorker\":28,\".\/stream\/StreamHelper\":29,\".\/utf8\":31,\".\/utils\":32,\".\/zipObject\":35}],16:[function(require,module,exports){\n+\/*\n+ * This file is used by module bundlers (browserify\/webpack\/etc) when\n+ * including a stream implementation. We use \"readable-stream\" to get a\n+ * consistent behavior between nodejs versions but bundlers often have a shim\n+ * for \"stream\". Using this shim greatly improve the compatibility and greatly\n+ * reduce the final size of the bundle (only one stream implementation, not\n+ * two).\n+ *\/\n+module.exports = require(\"stream\");\n+\n+},{\"stream\":undefined}],17:[function(require,module,exports){\n+'use strict';\n+var DataReader = require('.\/DataReader');\n+var utils = require('..\/utils');\n+\n+function ArrayReader(data) {\n+    DataReader.call(this, data);\n+\tfor(var i = 0; i < this.data.length; i++) {\n+\t\tdata[i] = data[i] & 0xFF;\n+\t}\n+}\n+utils.inherits(ArrayReader, DataReader);\n+\/**\n+ * @see DataReader.byteAt\n+ *\/\n+ArrayReader.prototype.byteAt = function(i) {\n+    return this.data[this.zero + i];\n+};\n+\/**\n+ * @see DataReader.lastIndexOfSignature\n+ *\/\n+ArrayReader.prototype.lastIndexOfSignature = function(sig) {\n+    var sig0 = sig.charCodeAt(0),\n+        sig1 = sig.charCodeAt(1),\n+        sig2 = sig.charCodeAt(2),\n+        sig3 = sig.charCodeAt(3);\n+    for (var i = this.length - 4; i >= 0; --i) {\n+        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {\n+            return i - this.zero;\n+        }\n+    }\n+\n+    return -1;\n+};\n+\/**\n+ * @see DataReader.readAndCheckSignature\n+ *\/\n+ArrayReader.prototype.readAndCheckSignature = function (sig) {\n+    var sig0 = sig.charCodeAt(0),\n+        sig1 = sig.charCodeAt(1),\n+        sig2 = sig.charCodeAt(2),\n+        sig3 = sig.charCodeAt(3),\n+        data = this.readData(4);\n+    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];\n+};\n+\/**\n+ * @see DataReader.readData\n+ *\/\n+ArrayReader.prototype.readData = function(size) {\n+    this.checkOffset(size);\n+    if(size === 0) {\n+        return [];\n+    }\n+    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n+    this.index += size;\n+    return result;\n+};\n+module.exports = ArrayReader;\n+\n+},{\"..\/utils\":32,\".\/DataReader\":18}],18:[function(require,module,exports){\n+'use strict';\n+var utils = require('..\/utils');\n+\n+function DataReader(data) {\n+    this.data = data; \/\/ type : see implementation\n+    this.length = data.length;\n+    this.index = 0;\n+    this.zero = 0;\n+}\n+DataReader.prototype = {\n+    \/**\n+     * Check that the offset will not go too far.\n+     * @param {string} offset the additional offset to check.\n+     * @throws {Error} an Error if the offset is out of bounds.\n+     *\/\n+    checkOffset: function(offset) {\n+        this.checkIndex(this.index + offset);\n+    },\n+    \/**\n+     * Check that the specified index will not be too far.\n+     * @param {string} newIndex the index to check.\n+     * @throws {Error} an Error if the index is out of bounds.\n+     *\/\n+    checkIndex: function(newIndex) {\n+        if (this.length < this.zero + newIndex || newIndex < 0) {\n+            throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + (newIndex) + \"). Corrupted zip ?\");\n+        }\n+    },\n+    \/**\n+     * Change the index.\n+     * @param {number} newIndex The new index.\n+     * @throws {Error} if the new index is out of the data.\n+     *\/\n+    setIndex: function(newIndex) {\n+        this.checkIndex(newIndex);\n+        this.index = newIndex;\n+    },\n+    \/**\n+     * Skip the next n bytes.\n+     * @param {number} n the number of bytes to skip.\n+     * @throws {Error} if the new index is out of the data.\n+     *\/\n+    skip: function(n) {\n+        this.setIndex(this.index + n);\n+    },\n+    \/**\n+     * Get the byte at the specified index.\n+     * @param {number} i the index to use.\n+     * @return {number} a byte.\n+     *\/\n+    byteAt: function(i) {\n+        \/\/ see implementations\n+    },\n+    \/**\n+     * Get the next number with a given byte size.\n+     * @param {number} size the number of bytes to read.\n+     * @return {number} the corresponding number.\n+     *\/\n+    readInt: function(size) {\n+        var result = 0,\n+            i;\n+        this.checkOffset(size);\n+        for (i = this.index + size - 1; i >= this.index; i--) {\n+            result = (result << 8) + this.byteAt(i);\n+        }\n+        this.index += size;\n+        return result;\n+    },\n+    \/**\n+     * Get the next string with a given byte size.\n+     * @param {number} size the number of bytes to read.\n+     * @return {string} the corresponding string.\n+     *\/\n+    readString: function(size) {\n+        return utils.transformTo(\"string\", this.readData(size));\n+    },\n+    \/**\n+     * Get raw data without conversion, <size> bytes.\n+     * @param {number} size the number of bytes to read.\n+     * @return {Object} the raw data, implementation specific.\n+     *\/\n+    readData: function(size) {\n+        \/\/ see implementations\n+    },\n+    \/**\n+     * Find the last occurrence of a zip signature (4 bytes).\n+     * @param {string} sig the signature to find.\n+     * @return {number} the index of the last occurrence, -1 if not found.\n+     *\/\n+    lastIndexOfSignature: function(sig) {\n+        \/\/ see implementations\n+    },\n+    \/**\n+     * Read the signature (4 bytes) at the current position and compare it with sig.\n+     * @param {string} sig the expected signature\n+     * @return {boolean} true if the signature matches, false otherwise.\n+     *\/\n+    readAndCheckSignature: function(sig) {\n+        \/\/ see implementations\n+    },\n+    \/**\n+     * Get the next date.\n+     * @return {Date} the date.\n+     *\/\n+    readDate: function() {\n+        var dostime = this.readInt(4);\n+        return new Date(Date.UTC(\n+        ((dostime >> 25) & 0x7f) + 1980, \/\/ year\n+        ((dostime >> 21) & 0x0f) - 1, \/\/ month\n+        (dostime >> 16) & 0x1f, \/\/ day\n+        (dostime >> 11) & 0x1f, \/\/ hour\n+        (dostime >> 5) & 0x3f, \/\/ minute\n+        (dostime & 0x1f) << 1)); \/\/ second\n+    }\n+};\n+module.exports = DataReader;\n+\n+},{\"..\/utils\":32}],19:[function(require,module,exports){\n+'use strict';\n+var Uint8ArrayReader = require('.\/Uint8ArrayReader');\n+var utils = require('..\/utils');\n+\n+function NodeBufferReader(data) {\n+    Uint8ArrayReader.call(this, data);\n+}\n+utils.inherits(NodeBufferReader, Uint8ArrayReader);\n+\n+\/**\n+ * @see DataReader.readData\n+ *\/\n+NodeBufferReader.prototype.readData = function(size) {\n+    this.checkOffset(size);\n+    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n+    this.index += size;\n+    return result;\n+};\n+module.exports = NodeBufferReader;\n+\n+},{\"..\/utils\":32,\".\/Uint8ArrayReader\":21}],20:[function(require,module,exports){\n+'use strict';\n+var DataReader = require('.\/DataReader');\n+var utils = require('..\/utils');\n+\n+function StringReader(data) {\n+    DataReader.call(this, data);\n+}\n+utils.inherits(StringReader, DataReader);\n+\/**\n+ * @see DataReader.byteAt\n+ *\/\n+StringReader.prototype.byteAt = function(i) {\n+    return this.data.charCodeAt(this.zero + i);\n+};\n+\/**\n+ * @see DataReader.lastIndexOfSignature\n+ *\/\n+StringReader.prototype.lastIndexOfSignature = function(sig) {\n+    return this.data.lastIndexOf(sig) - this.zero;\n+};\n+\/**\n+ * @see DataReader.readAndCheckSignature\n+ *\/\n+StringReader.prototype.readAndCheckSignature = function (sig) {\n+    var data = this.readData(4);\n+    return sig === data;\n+};\n+\/**\n+ * @see DataReader.readData\n+ *\/\n+StringReader.prototype.readData = function(size) {\n+    this.checkOffset(size);\n+    \/\/ this will work because the constructor applied the \"& 0xff\" mask.\n+    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n+    this.index += size;\n+    return result;\n+};\n+module.exports = StringReader;\n+\n+},{\"..\/utils\":32,\".\/DataReader\":18}],21:[function(require,module,exports){\n+'use strict';\n+var ArrayReader = require('.\/ArrayReader');\n+var utils = require('..\/utils');\n+\n+function Uint8ArrayReader(data) {\n+    ArrayReader.call(this, data);\n+}\n+utils.inherits(Uint8ArrayReader, ArrayReader);\n+\/**\n+ * @see DataReader.readData\n+ *\/\n+Uint8ArrayReader.prototype.readData = function(size) {\n+    this.checkOffset(size);\n+    if(size === 0) {\n+        \/\/ in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].\n+        return new Uint8Array(0);\n+    }\n+    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);\n+    this.index += size;\n+    return result;\n+};\n+module.exports = Uint8ArrayReader;\n+\n+},{\"..\/utils\":32,\".\/ArrayReader\":17}],22:[function(require,module,exports){\n+'use strict';\n+\n+var utils = require('..\/utils');\n+var support = require('..\/support');\n+var ArrayReader = require('.\/ArrayReader');\n+var StringReader = require('.\/StringReader');\n+var NodeBufferReader = require('.\/NodeBufferReader');\n+var Uint8ArrayReader = require('.\/Uint8ArrayReader');\n+\n+\/**\n+ * Create a reader adapted to the data.\n+ * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.\n+ * @return {DataReader} the data reader.\n+ *\/\n+module.exports = function (data) {\n+    var type = utils.getTypeOf(data);\n+    utils.checkSupport(type);\n+    if (type === \"string\" && !support.uint8array) {\n+        return new StringReader(data);\n+    }\n+    if (type === \"nodebuffer\") {\n+        return new NodeBufferReader(data);\n+    }\n+    if (support.uint8array) {\n+        return new Uint8ArrayReader(utils.transformTo(\"uint8array\", data));\n+    }\n+    return new ArrayReader(utils.transformTo(\"array\", data));\n+};\n+\n+},{\"..\/support\":30,\"..\/utils\":32,\".\/ArrayReader\":17,\".\/NodeBufferReader\":19,\".\/StringReader\":20,\".\/Uint8ArrayReader\":21}],23:[function(require,module,exports){\n+'use strict';\n+exports.LOCAL_FILE_HEADER = \"PK\\x03\\x04\";\n+exports.CENTRAL_FILE_HEADER = \"PK\\x01\\x02\";\n+exports.CENTRAL_DIRECTORY_END = \"PK\\x05\\x06\";\n+exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = \"PK\\x06\\x07\";\n+exports.ZIP64_CENTRAL_DIRECTORY_END = \"PK\\x06\\x06\";\n+exports.DATA_DESCRIPTOR = \"PK\\x07\\x08\";\n+\n+},{}],24:[function(require,module,exports){\n+'use strict';\n+\n+var GenericWorker = require('.\/GenericWorker');\n+var utils = require('..\/utils');\n+\n+\/**\n+ * A worker which convert chunks to a specified type.\n+ * @constructor\n+ * @param {String} destType the destination type.\n+ *\/\n+function ConvertWorker(destType) {\n+    GenericWorker.call(this, \"ConvertWorker to \" + destType);\n+    this.destType = destType;\n+}\n+utils.inherits(ConvertWorker, GenericWorker);\n+\n+\/**\n+ * @see GenericWorker.processChunk\n+ *\/\n+ConvertWorker.prototype.processChunk = function (chunk) {\n+    this.push({\n+        data : utils.transformTo(this.destType, chunk.data),\n+        meta : chunk.meta\n+    });\n+};\n+module.exports = ConvertWorker;\n+\n+},{\"..\/utils\":32,\".\/GenericWorker\":28}],25:[function(require,module,exports){\n+'use strict';\n+\n+var GenericWorker = require('.\/GenericWorker');\n+var crc32 = require('..\/crc32');\n+var utils = require('..\/utils');\n+\n+\/**\n+ * A worker which calculate the crc32 of the data flowing through.\n+ * @constructor\n+ *\/\n+function Crc32Probe() {\n+    GenericWorker.call(this, \"Crc32Probe\");\n+    this.withStreamInfo(\"crc32\", 0);\n+}\n+utils.inherits(Crc32Probe, GenericWorker);\n+\n+\/**\n+ * @see GenericWorker.processChunk\n+ *\/\n+Crc32Probe.prototype.processChunk = function (chunk) {\n+    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);\n+    this.push(chunk);\n+};\n+module.exports = Crc32Probe;\n+\n+},{\"..\/crc32\":4,\"..\/utils\":32,\".\/GenericWorker\":28}],26:[function(require,module,exports){\n+'use strict';\n+\n+var utils = require('..\/utils');\n+var GenericWorker = require('.\/GenericWorker');\n+\n+\/**\n+ * A worker which calculate the total length of the data flowing through.\n+ * @constructor\n+ * @param {String} propName the name used to expose the length\n+ *\/\n+function DataLengthProbe(propName) {\n+    GenericWorker.call(this, \"DataLengthProbe for \" + propName);\n+    this.propName = propName;\n+    this.withStreamInfo(propName, 0);\n+}\n+utils.inherits(DataLengthProbe, GenericWorker);\n+\n+\/**\n+ * @see GenericWorker.processChunk\n+ *\/\n+DataLengthProbe.prototype.processChunk = function (chunk) {\n+    if(chunk) {\n+        var length = this.streamInfo[this.propName] || 0;\n+        this.streamInfo[this.propName] = length + chunk.data.length;\n+    }\n+    GenericWorker.prototype.processChunk.call(this, chunk);\n+};\n+module.exports = DataLengthProbe;\n+\n+\n+},{\"..\/utils\":32,\".\/GenericWorker\":28}],27:[function(require,module,exports){\n+'use strict';\n+\n+var utils = require('..\/utils');\n+var GenericWorker = require('.\/GenericWorker');\n+\n+\/\/ the size of the generated chunks\n+\/\/ TODO expose this as a public variable\n+var DEFAULT_BLOCK_SIZE = 16 * 1024;\n+\n+\/**\n+ * A worker that reads a content and emits chunks.\n+ * @constructor\n+ * @param {Promise} dataP the promise of the data to split\n+ *\/\n+function DataWorker(dataP) {\n+    GenericWorker.call(this, \"DataWorker\");\n+    var self = this;\n+    this.dataIsReady = false;\n+    this.index = 0;\n+    this.max = 0;\n+    this.data = null;\n+    this.type = \"\";\n+\n+    this._tickScheduled = false;\n+\n+    dataP.then(function (data) {\n+        self.dataIsReady = true;\n+        self.data = data;\n+        self.max = data && data.length || 0;\n+        self.type = utils.getTypeOf(data);\n+        if(!self.isPaused) {\n+            self._tickAndRepeat();\n+        }\n+    }, function (e) {\n+        self.error(e);\n+    });\n+}\n+\n+utils.inherits(DataWorker, GenericWorker);\n+\n+\/**\n+ * @see GenericWorker.cleanUp\n+ *\/\n+DataWorker.prototype.cleanUp = function () {\n+    GenericWorker.prototype.cleanUp.call(this);\n+    this.data = null;\n+};\n+\n+\/**\n+ * @see GenericWorker.resume\n+ *\/\n+DataWorker.prototype.resume = function () {\n+    if(!GenericWorker.prototype.resume.call(this)) {\n+        return false;\n+    }\n+\n+    if (!this._tickScheduled && this.dataIsReady) {\n+        this._tickScheduled = true;\n+        utils.delay(this._tickAndRepeat, [], this);\n+    }\n+    return true;\n+};\n+\n+\/**\n+ * Trigger a tick a schedule an other call to this function.\n+ *\/\n+DataWorker.prototype._tickAndRepeat = function() {\n+    this._tickScheduled = false;\n+    if(this.isPaused || this.isFinished) {\n+        return;\n+    }\n+    this._tick();\n+    if(!this.isFinished) {\n+        utils.delay(this._tickAndRepeat, [], this);\n+        this._tickScheduled = true;\n+    }\n+};\n+\n+\/**\n+ * Read and push a chunk.\n+ *\/\n+DataWorker.prototype._tick = function() {\n+\n+    if(this.isPaused || this.isFinished) {\n+        return false;\n+    }\n+\n+    var size = DEFAULT_BLOCK_SIZE;\n+    var data = null, nextIndex = Math.min(this.max, this.index + size);\n+    if (this.index >= this.max) {\n+        \/\/ EOF\n+        return this.end();\n+    } else {\n+        switch(this.type) {\n+            case \"string\":\n+                data = this.data.substring(this.index, nextIndex);\n+            break;\n+            case \"uint8array\":\n+                data = this.data.subarray(this.index, nextIndex);\n+            break;\n+            case \"array\":\n+            case \"nodebuffer\":\n+                data = this.data.slice(this.index, nextIndex);\n+            break;\n+        }\n+        this.index = nextIndex;\n+        return this.push({\n+            data : data,\n+            meta : {\n+                percent : this.max ? this.index \/ this.max * 100 : 0\n+            }\n+        });\n+    }\n+};\n+\n+module.exports = DataWorker;\n+\n+},{\"..\/utils\":32,\".\/GenericWorker\":28}],28:[function(require,module,exports){\n+'use strict';\n+\n+\/**\n+ * A worker that does nothing but passing chunks to the next one. This is like\n+ * a nodejs stream but with some differences. On the good side :\n+ * - it works on IE 6-9 without any issue \/ polyfill\n+ * - it weights less than the full dependencies bundled with browserify\n+ * - it forwards errors (no need to declare an error handler EVERYWHERE)\n+ *\n+ * A chunk is an object with 2 attributes : `meta` and `data`. The former is an\n+ * object containing anything (`percent` for example), see each worker for more\n+ * details. The latter is the real data (String, Uint8Array, etc).\n+ *\n+ * @constructor\n+ * @param {String} name the name of the stream (mainly used for debugging purposes)\n+ *\/\n+function GenericWorker(name) {\n+    \/\/ the name of the worker\n+    this.name = name || \"default\";\n+    \/\/ an object containing metadata about the workers chain\n+    this.streamInfo = {};\n+    \/\/ an error which happened when the worker was paused\n+    this.generatedError = null;\n+    \/\/ an object containing metadata to be merged by this worker into the general metadata\n+    this.extraStreamInfo = {};\n+    \/\/ true if the stream is paused (and should not do anything), false otherwise\n+    this.isPaused = true;\n+    \/\/ true if the stream is finished (and should not do anything), false otherwise\n+    this.isFinished = false;\n+    \/\/ true if the stream is locked to prevent further structure updates (pipe), false otherwise\n+    this.isLocked = false;\n+    \/\/ the event listeners\n+    this._listeners = {\n+        'data':[],\n+        'end':[],\n+        'error':[]\n+    };\n+    \/\/ the previous worker, if any\n+    this.previous = null;\n+}\n+\n+GenericWorker.prototype = {\n+    \/**\n+     * Push a chunk to the next workers.\n+     * @param {Object} chunk the chunk to push\n+     *\/\n+    push : function (chunk) {\n+        this.emit(\"data\", chunk);\n+    },\n+    \/**\n+     * End the stream.\n+     * @return {Boolean} true if this call ended the worker, false otherwise.\n+     *\/\n+    end : function () {\n+        if (this.isFinished) {\n+            return false;\n+        }\n+\n+        this.flush();\n+        try {\n+            this.emit(\"end\");\n+            this.cleanUp();\n+            this.isFinished = true;\n+        } catch (e) {\n+            this.emit(\"error\", e);\n+        }\n+        return true;\n+    },\n+    \/**\n+     * End the stream with an error.\n+     * @param {Error} e the error which caused the premature end.\n+     * @return {Boolean} true if this call ended the worker with an error, false otherwise.\n+     *\/\n+    error : function (e) {\n+        if (this.isFinished) {\n+            return false;\n+        }\n+\n+        if(this.isPaused) {\n+            this.generatedError = e;\n+        } else {\n+            this.isFinished = true;\n+\n+            this.emit(\"error\", e);\n+\n+            \/\/ in the workers chain exploded in the middle of the chain,\n+            \/\/ the error event will go downward but we also need to notify\n+            \/\/ workers upward that there has been an error.\n+            if(this.previous) {\n+                this.previous.error(e);\n+            }\n+\n+            this.cleanUp();\n+        }\n+        return true;\n+    },\n+    \/**\n+     * Add a callback on an event.\n+     * @param {String} name the name of the event (data, end, error)\n+     * @param {Function} listener the function to call when the event is triggered\n+     * @return {GenericWorker} the current object for chainability\n+     *\/\n+    on : function (name, listener) {\n+        this._listeners[name].push(listener);\n+        return this;\n+    },\n+    \/**\n+     * Clean any references when a worker is ending.\n+     *\/\n+    cleanUp : function () {\n+        this.streamInfo = this.generatedError = this.extraStreamInfo = null;\n+        this._listeners = [];\n+    },\n+    \/**\n+     * Trigger an event. This will call registered callback with the provided arg.\n+     * @param {String} name the name of the event (data, end, error)\n+     * @param {Object} arg the argument to call the callback with.\n+     *\/\n+    emit : function (name, arg) {\n+        if (this._listeners[name]) {\n+            for(var i = 0; i < this._listeners[name].length; i++) {\n+                this._listeners[name][i].call(this, arg);\n+            }\n+        }\n+    },\n+    \/**\n+     * Chain a worker with an other.\n+     * @param {Worker} next the worker receiving events from the current one.\n+     * @return {worker} the next worker for chainability\n+     *\/\n+    pipe : function (next) {\n+        return next.registerPrevious(this);\n+    },\n+    \/**\n+     * Same as `pipe` in the other direction.\n+     * Using an API with `pipe(next)` is very easy.\n+     * Implementing the API with the point of view of the next one registering\n+     * a source is easier, see the ZipFileWorker.\n+     * @param {Worker} previous the previous worker, sending events to this one\n+     * @return {Worker} the current worker for chainability\n+     *\/\n+    registerPrevious : function (previous) {\n+        if (this.isLocked) {\n+            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n+        }\n+\n+        \/\/ sharing the streamInfo...\n+        this.streamInfo = previous.streamInfo;\n+        \/\/ ... and adding our own bits\n+        this.mergeStreamInfo();\n+        this.previous =  previous;\n+        var self = this;\n+        previous.on('data', function (chunk) {\n+            self.processChunk(chunk);\n+        });\n+        previous.on('end', function () {\n+            self.end();\n+        });\n+        previous.on('error', function (e) {\n+            self.error(e);\n+        });\n+        return this;\n+    },\n+    \/**\n+     * Pause the stream so it doesn't send events anymore.\n+     * @return {Boolean} true if this call paused the worker, false otherwise.\n+     *\/\n+    pause : function () {\n+        if(this.isPaused || this.isFinished) {\n+            return false;\n+        }\n+        this.isPaused = true;\n+\n+        if(this.previous) {\n+            this.previous.pause();\n+        }\n+        return true;\n+    },\n+    \/**\n+     * Resume a paused stream.\n+     * @return {Boolean} true if this call resumed the worker, false otherwise.\n+     *\/\n+    resume : function () {\n+        if(!this.isPaused || this.isFinished) {\n+            return false;\n+        }\n+        this.isPaused = false;\n+\n+        \/\/ if true, the worker tried to resume but failed\n+        var withError = false;\n+        if(this.generatedError) {\n+            this.error(this.generatedError);\n+            withError = true;\n+        }\n+        if(this.previous) {\n+            this.previous.resume();\n+        }\n+\n+        return !withError;\n+    },\n+    \/**\n+     * Flush any remaining bytes as the stream is ending.\n+     *\/\n+    flush : function () {},\n+    \/**\n+     * Process a chunk. This is usually the method overridden.\n+     * @param {Object} chunk the chunk to process.\n+     *\/\n+    processChunk : function(chunk) {\n+        this.push(chunk);\n+    },\n+    \/**\n+     * Add a key\/value to be added in the workers chain streamInfo once activated.\n+     * @param {String} key the key to use\n+     * @param {Object} value the associated value\n+     * @return {Worker} the current worker for chainability\n+     *\/\n+    withStreamInfo : function (key, value) {\n+        this.extraStreamInfo[key] = value;\n+        this.mergeStreamInfo();\n+        return this;\n+    },\n+    \/**\n+     * Merge this worker's streamInfo into the chain's streamInfo.\n+     *\/\n+    mergeStreamInfo : function () {\n+        for(var key in this.extraStreamInfo) {\n+            if (!this.extraStreamInfo.hasOwnProperty(key)) {\n+                continue;\n+            }\n+            this.streamInfo[key] = this.extraStreamInfo[key];\n+        }\n+    },\n+\n+    \/**\n+     * Lock the stream to prevent further updates on the workers chain.\n+     * After calling this method, all calls to pipe will fail.\n+     *\/\n+    lock: function () {\n+        if (this.isLocked) {\n+            throw new Error(\"The stream '\" + this + \"' has already been used.\");\n+        }\n+        this.isLocked = true;\n+        if (this.previous) {\n+            this.previous.lock();\n+        }\n+    },\n+\n+    \/**\n+     *\n+     * Pretty print the workers chain.\n+     *\/\n+    toString : function () {\n+        var me = \"Worker \" + this.name;\n+        if (this.previous) {\n+            return this.previous + \" -> \" + me;\n+        } else {\n+            return me;\n+        }\n+    }\n+};\n+\n+module.exports = GenericWorker;\n+\n+},{}],29:[function(require,module,exports){\n+'use strict';\n+\n+var utils = require('..\/utils');\n+var ConvertWorker = require('.\/ConvertWorker');\n+var GenericWorker = require('.\/GenericWorker');\n+var base64 = require('..\/base64');\n+var support = require(\"..\/support\");\n+var external = require(\"..\/external\");\n+\n+var NodejsStreamOutputAdapter = null;\n+if (support.nodestream) {\n+    try {\n+        NodejsStreamOutputAdapter = require('..\/nodejs\/NodejsStreamOutputAdapter');\n+    } catch(e) {}\n+}\n+\n+\/**\n+ * Apply the final transformation of the data. If the user wants a Blob for\n+ * example, it's easier to work with an U8intArray and finally do the\n+ * ArrayBuffer\/Blob conversion.\n+ * @param {String} type the name of the final type\n+ * @param {String|Uint8Array|Buffer} content the content to transform\n+ * @param {String} mimeType the mime type of the content, if applicable.\n+ * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.\n+ *\/\n+function transformZipOutput(type, content, mimeType) {\n+    switch(type) {\n+        case \"blob\" :\n+            return utils.newBlob(utils.transformTo(\"arraybuffer\", content), mimeType);\n+        case \"base64\" :\n+            return base64.encode(content);\n+        default :\n+            return utils.transformTo(type, content);\n+    }\n+}\n+\n+\/**\n+ * Concatenate an array of data of the given type.\n+ * @param {String} type the type of the data in the given array.\n+ * @param {Array} dataArray the array containing the data chunks to concatenate\n+ * @return {String|Uint8Array|Buffer} the concatenated data\n+ * @throws Error if the asked type is unsupported\n+ *\/\n+function concat (type, dataArray) {\n+    var i, index = 0, res = null, totalLength = 0;\n+    for(i = 0; i < dataArray.length; i++) {\n+        totalLength += dataArray[i].length;\n+    }\n+    switch(type) {\n+        case \"string\":\n+            return dataArray.join(\"\");\n+          case \"array\":\n+            return Array.prototype.concat.apply([], dataArray);\n+        case \"uint8array\":\n+            res = new Uint8Array(totalLength);\n+            for(i = 0; i < dataArray.length; i++) {\n+                res.set(dataArray[i], index);\n+                index += dataArray[i].length;\n+            }\n+            return res;\n+        case \"nodebuffer\":\n+            return Buffer.concat(dataArray);\n+        default:\n+            throw new Error(\"concat : unsupported type '\"  + type + \"'\");\n+    }\n+}\n+\n+\/**\n+ * Listen a StreamHelper, accumulate its content and concatenate it into a\n+ * complete block.\n+ * @param {StreamHelper} helper the helper to use.\n+ * @param {Function} updateCallback a callback called on each update. Called\n+ * with one arg :\n+ * - the metadata linked to the update received.\n+ * @return Promise the promise for the accumulation.\n+ *\/\n+function accumulate(helper, updateCallback) {\n+    return new external.Promise(function (resolve, reject){\n+        var dataArray = [];\n+        var chunkType = helper._internalType,\n+            resultType = helper._outputType,\n+            mimeType = helper._mimeType;\n+        helper\n+        .on('data', function (data, meta) {\n+            dataArray.push(data);\n+            if(updateCallback) {\n+                updateCallback(meta);\n+            }\n+        })\n+        .on('error', function(err) {\n+            dataArray = [];\n+            reject(err);\n+        })\n+        .on('end', function (){\n+            try {\n+                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);\n+                resolve(result);\n+            } catch (e) {\n+                reject(e);\n+            }\n+            dataArray = [];\n+        })\n+        .resume();\n+    });\n+}\n+\n+\/**\n+ * An helper to easily use workers outside of JSZip.\n+ * @constructor\n+ * @param {Worker} worker the worker to wrap\n+ * @param {String} outputType the type of data expected by the use\n+ * @param {String} mimeType the mime type of the content, if applicable.\n+ *\/\n+function StreamHelper(worker, outputType, mimeType) {\n+    var internalType = outputType;\n+    switch(outputType) {\n+        case \"blob\":\n+        case \"arraybuffer\":\n+            internalType = \"uint8array\";\n+        break;\n+        case \"base64\":\n+            internalType = \"string\";\n+        break;\n+    }\n+\n+    try {\n+        \/\/ the type used internally\n+        this._internalType = internalType;\n+        \/\/ the type used to output results\n+        this._outputType = outputType;\n+        \/\/ the mime type\n+        this._mimeType = mimeType;\n+        utils.checkSupport(internalType);\n+        this._worker = worker.pipe(new ConvertWorker(internalType));\n+        \/\/ the last workers can be rewired without issues but we need to\n+        \/\/ prevent any updates on previous workers.\n+        worker.lock();\n+    } catch(e) {\n+        this._worker = new GenericWorker(\"error\");\n+        this._worker.error(e);\n+    }\n+}\n+\n+StreamHelper.prototype = {\n+    \/**\n+     * Listen a StreamHelper, accumulate its content and concatenate it into a\n+     * complete block.\n+     * @param {Function} updateCb the update callback.\n+     * @return Promise the promise for the accumulation.\n+     *\/\n+    accumulate : function (updateCb) {\n+        return accumulate(this, updateCb);\n+    },\n+    \/**\n+     * Add a listener on an event triggered on a stream.\n+     * @param {String} evt the name of the event\n+     * @param {Function} fn the listener\n+     * @return {StreamHelper} the current helper.\n+     *\/\n+    on : function (evt, fn) {\n+        var self = this;\n+\n+        if(evt === \"data\") {\n+            this._worker.on(evt, function (chunk) {\n+                fn.call(self, chunk.data, chunk.meta);\n+            });\n+        } else {\n+            this._worker.on(evt, function () {\n+                utils.delay(fn, arguments, self);\n+            });\n+        }\n+        return this;\n+    },\n+    \/**\n+     * Resume the flow of chunks.\n+     * @return {StreamHelper} the current helper.\n+     *\/\n+    resume : function () {\n+        utils.delay(this._worker.resume, [], this._worker);\n+        return this;\n+    },\n+    \/**\n+     * Pause the flow of chunks.\n+     * @return {StreamHelper} the current helper.\n+     *\/\n+    pause : function () {\n+        this._worker.pause();\n+        return this;\n+    },\n+    \/**\n+     * Return a nodejs stream for this helper.\n+     * @param {Function} updateCb the update callback.\n+     * @return {NodejsStreamOutputAdapter} the nodejs stream.\n+     *\/\n+    toNodejsStream : function (updateCb) {\n+        utils.checkSupport(\"nodestream\");\n+        if (this._outputType !== \"nodebuffer\") {\n+            \/\/ an object stream containing blob\/arraybuffer\/uint8array\/string\n+            \/\/ is strange and I don't know if it would be useful.\n+            \/\/ I you find this comment and have a good usecase, please open a\n+            \/\/ bug report !\n+            throw new Error(this._outputType + \" is not supported by this method\");\n+        }\n+\n+        return new NodejsStreamOutputAdapter(this, {\n+            objectMode : this._outputType !== \"nodebuffer\"\n+        }, updateCb);\n+    }\n+};\n+\n+\n+module.exports = StreamHelper;\n+\n+},{\"..\/base64\":1,\"..\/external\":6,\"..\/nodejs\/NodejsStreamOutputAdapter\":13,\"..\/support\":30,\"..\/utils\":32,\".\/ConvertWorker\":24,\".\/GenericWorker\":28}],30:[function(require,module,exports){\n+'use strict';\n+\n+exports.base64 = true;\n+exports.array = true;\n+exports.string = true;\n+exports.arraybuffer = typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\";\n+exports.nodebuffer = typeof Buffer !== \"undefined\";\n+\/\/ contains true if JSZip can read\/generate Uint8Array, false otherwise.\n+exports.uint8array = typeof Uint8Array !== \"undefined\";\n+\n+if (typeof ArrayBuffer === \"undefined\") {\n+    exports.blob = false;\n+}\n+else {\n+    var buffer = new ArrayBuffer(0);\n+    try {\n+        exports.blob = new Blob([buffer], {\n+            type: \"application\/zip\"\n+        }).size === 0;\n+    }\n+    catch (e) {\n+        try {\n+            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n+            var builder = new Builder();\n+            builder.append(buffer);\n+            exports.blob = builder.getBlob('application\/zip').size === 0;\n+        }\n+        catch (e) {\n+            exports.blob = false;\n+        }\n+    }\n+}\n+\n+try {\n+    exports.nodestream = !!require('readable-stream').Readable;\n+} catch(e) {\n+    exports.nodestream = false;\n+}\n+\n+},{\"readable-stream\":16}],31:[function(require,module,exports){\n+'use strict';\n+\n+var utils = require('.\/utils');\n+var support = require('.\/support');\n+var nodejsUtils = require('.\/nodejsUtils');\n+var GenericWorker = require('.\/stream\/GenericWorker');\n+\n+\/**\n+ * The following functions come from pako, from pako\/lib\/utils\/strings\n+ * released under the MIT license, see pako https:\/\/github.com\/nodeca\/pako\/\n+ *\/\n+\n+\/\/ Table with utf8 lengths (calculated by first byte of sequence)\n+\/\/ Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n+\/\/ because max possible codepoint is 0x10ffff\n+var _utf8len = new Array(256);\n+for (var i=0; i<256; i++) {\n+  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);\n+}\n+_utf8len[254]=_utf8len[254]=1; \/\/ Invalid sequence start\n+\n+\/\/ convert string to array (typed, when possible)\n+var string2buf = function (str) {\n+    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n+\n+    \/\/ count binary size\n+    for (m_pos = 0; m_pos < str_len; m_pos++) {\n+        c = str.charCodeAt(m_pos);\n+        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n+            c2 = str.charCodeAt(m_pos+1);\n+            if ((c2 & 0xfc00) === 0xdc00) {\n+                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n+                m_pos++;\n+            }\n+        }\n+        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n+    }\n+\n+    \/\/ allocate buffer\n+    if (support.uint8array) {\n+        buf = new Uint8Array(buf_len);\n+    } else {\n+        buf = new Array(buf_len);\n+    }\n+\n+    \/\/ convert\n+    for (i=0, m_pos = 0; i < buf_len; m_pos++) {\n+        c = str.charCodeAt(m_pos);\n+        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n+            c2 = str.charCodeAt(m_pos+1);\n+            if ((c2 & 0xfc00) === 0xdc00) {\n+                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n+                m_pos++;\n+            }\n+        }\n+        if (c < 0x80) {\n+            \/* one byte *\/\n+            buf[i++] = c;\n+        } else if (c < 0x800) {\n+            \/* two bytes *\/\n+            buf[i++] = 0xC0 | (c >>> 6);\n+            buf[i++] = 0x80 | (c & 0x3f);\n+        } else if (c < 0x10000) {\n+            \/* three bytes *\/\n+            buf[i++] = 0xE0 | (c >>> 12);\n+            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n+            buf[i++] = 0x80 | (c & 0x3f);\n+        } else {\n+            \/* four bytes *\/\n+            buf[i++] = 0xf0 | (c >>> 18);\n+            buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n+            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n+            buf[i++] = 0x80 | (c & 0x3f);\n+        }\n+    }\n+\n+    return buf;\n+};\n+\n+\/\/ Calculate max possible position in utf8 buffer,\n+\/\/ that will not break sequence. If that's not possible\n+\/\/ - (very small limits) return max size as is.\n+\/\/\n+\/\/ buf[] - utf8 bytes array\n+\/\/ max   - length limit (mandatory);\n+var utf8border = function(buf, max) {\n+    var pos;\n+\n+    max = max || buf.length;\n+    if (max > buf.length) { max = buf.length; }\n+\n+    \/\/ go back from last position, until start of sequence found\n+    pos = max-1;\n+    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n+\n+    \/\/ Fuckup - very small and broken sequence,\n+    \/\/ return max, because we should return something anyway.\n+    if (pos < 0) { return max; }\n+\n+    \/\/ If we came to start of buffer - that means vuffer is too small,\n+    \/\/ return max too.\n+    if (pos === 0) { return max; }\n+\n+    return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n+};\n+\n+\/\/ convert array to string\n+var buf2string = function (buf) {\n+    var str, i, out, c, c_len;\n+    var len = buf.length;\n+\n+    \/\/ Reserve max possible length (2 words per char)\n+    \/\/ NB: by unknown reasons, Array is significantly faster for\n+    \/\/     String.fromCharCode.apply than Uint16Array.\n+    var utf16buf = new Array(len*2);\n+\n+    for (out=0, i=0; i<len;) {\n+        c = buf[i++];\n+        \/\/ quick process ascii\n+        if (c < 0x80) { utf16buf[out++] = c; continue; }\n+\n+        c_len = _utf8len[c];\n+        \/\/ skip 5 & 6 byte codes\n+        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }\n+\n+        \/\/ apply mask on first byte\n+        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n+        \/\/ join the rest\n+        while (c_len > 1 && i < len) {\n+            c = (c << 6) | (buf[i++] & 0x3f);\n+            c_len--;\n+        }\n+\n+        \/\/ terminated by end of string?\n+        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n+\n+        if (c < 0x10000) {\n+            utf16buf[out++] = c;\n+        } else {\n+            c -= 0x10000;\n+            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n+            utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n+        }\n+    }\n+\n+    \/\/ shrinkBuf(utf16buf, out)\n+    if (utf16buf.length !== out) {\n+        if(utf16buf.subarray) {\n+            utf16buf = utf16buf.subarray(0, out);\n+        } else {\n+            utf16buf.length = out;\n+        }\n+    }\n+\n+    \/\/ return String.fromCharCode.apply(null, utf16buf);\n+    return utils.applyFromCharCode(utf16buf);\n+};\n+\n+\n+\/\/ That's all for the pako functions.\n+\n+\n+\/**\n+ * Transform a javascript string into an array (typed if possible) of bytes,\n+ * UTF-8 encoded.\n+ * @param {String} str the string to encode\n+ * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n+ *\/\n+exports.utf8encode = function utf8encode(str) {\n+    if (support.nodebuffer) {\n+        return nodejsUtils.newBufferFrom(str, \"utf-8\");\n+    }\n+\n+    return string2buf(str);\n+};\n+\n+\n+\/**\n+ * Transform a bytes array (or a representation) representing an UTF-8 encoded\n+ * string into a javascript string.\n+ * @param {Array|Uint8Array|Buffer} buf the data de decode\n+ * @return {String} the decoded string.\n+ *\/\n+exports.utf8decode = function utf8decode(buf) {\n+    if (support.nodebuffer) {\n+        return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n+    }\n+\n+    buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n+\n+    return buf2string(buf);\n+};\n+\n+\/**\n+ * A worker to decode utf8 encoded binary chunks into string chunks.\n+ * @constructor\n+ *\/\n+function Utf8DecodeWorker() {\n+    GenericWorker.call(this, \"utf-8 decode\");\n+    \/\/ the last bytes if a chunk didn't end with a complete codepoint.\n+    this.leftOver = null;\n+}\n+utils.inherits(Utf8DecodeWorker, GenericWorker);\n+\n+\/**\n+ * @see GenericWorker.processChunk\n+ *\/\n+Utf8DecodeWorker.prototype.processChunk = function (chunk) {\n+\n+    var data = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", chunk.data);\n+\n+    \/\/ 1st step, re-use what's left of the previous chunk\n+    if (this.leftOver && this.leftOver.length) {\n+        if(support.uint8array) {\n+            var previousData = data;\n+            data = new Uint8Array(previousData.length + this.leftOver.length);\n+            data.set(this.leftOver, 0);\n+            data.set(previousData, this.leftOver.length);\n+        } else {\n+            data = this.leftOver.concat(data);\n+        }\n+        this.leftOver = null;\n+    }\n+\n+    var nextBoundary = utf8border(data);\n+    var usableData = data;\n+    if (nextBoundary !== data.length) {\n+        if (support.uint8array) {\n+            usableData = data.subarray(0, nextBoundary);\n+            this.leftOver = data.subarray(nextBoundary, data.length);\n+        } else {\n+            usableData = data.slice(0, nextBoundary);\n+            this.leftOver = data.slice(nextBoundary, data.length);\n+        }\n+    }\n+\n+    this.push({\n+        data : exports.utf8decode(usableData),\n+        meta : chunk.meta\n+    });\n+};\n+\n+\/**\n+ * @see GenericWorker.flush\n+ *\/\n+Utf8DecodeWorker.prototype.flush = function () {\n+    if(this.leftOver && this.leftOver.length) {\n+        this.push({\n+            data : exports.utf8decode(this.leftOver),\n+            meta : {}\n+        });\n+        this.leftOver = null;\n+    }\n+};\n+exports.Utf8DecodeWorker = Utf8DecodeWorker;\n+\n+\/**\n+ * A worker to endcode string chunks into utf8 encoded binary chunks.\n+ * @constructor\n+ *\/\n+function Utf8EncodeWorker() {\n+    GenericWorker.call(this, \"utf-8 encode\");\n+}\n+utils.inherits(Utf8EncodeWorker, GenericWorker);\n+\n+\/**\n+ * @see GenericWorker.processChunk\n+ *\/\n+Utf8EncodeWorker.prototype.processChunk = function (chunk) {\n+    this.push({\n+        data : exports.utf8encode(chunk.data),\n+        meta : chunk.meta\n+    });\n+};\n+exports.Utf8EncodeWorker = Utf8EncodeWorker;\n+\n+},{\".\/nodejsUtils\":14,\".\/stream\/GenericWorker\":28,\".\/support\":30,\".\/utils\":32}],32:[function(require,module,exports){\n+'use strict';\n+\n+var support = require('.\/support');\n+var base64 = require('.\/base64');\n+var nodejsUtils = require('.\/nodejsUtils');\n+var setImmediate = require('set-immediate-shim');\n+var external = require(\".\/external\");\n+\n+\n+\/**\n+ * Convert a string that pass as a \"binary string\": it should represent a byte\n+ * array but may have > 255 char codes. Be sure to take only the first byte\n+ * and returns the byte array.\n+ * @param {String} str the string to transform.\n+ * @return {Array|Uint8Array} the string in a binary format.\n+ *\/\n+function string2binary(str) {\n+    var result = null;\n+    if (support.uint8array) {\n+      result = new Uint8Array(str.length);\n+    } else {\n+      result = new Array(str.length);\n+    }\n+    return stringToArrayLike(str, result);\n+}\n+\n+\/**\n+ * Create a new blob with the given content and the given type.\n+ * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use\n+ * an Uint8Array because the stock browser of android 4 won't accept it (it\n+ * will be silently converted to a string, \"[object Uint8Array]\").\n+ *\n+ * Use only ONE part to build the blob to avoid a memory leak in IE11 \/ Edge:\n+ * when a large amount of Array is used to create the Blob, the amount of\n+ * memory consumed is nearly 100 times the original data amount.\n+ *\n+ * @param {String} type the mime type of the blob.\n+ * @return {Blob} the created blob.\n+ *\/\n+exports.newBlob = function(part, type) {\n+    exports.checkSupport(\"blob\");\n+\n+    try {\n+        \/\/ Blob constructor\n+        return new Blob([part], {\n+            type: type\n+        });\n+    }\n+    catch (e) {\n+\n+        try {\n+            \/\/ deprecated, browser only, old way\n+            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;\n+            var builder = new Builder();\n+            builder.append(part);\n+            return builder.getBlob(type);\n+        }\n+        catch (e) {\n+\n+            \/\/ well, fuck ?!\n+            throw new Error(\"Bug : can't construct the Blob.\");\n+        }\n+    }\n+\n+\n+};\n+\/**\n+ * The identity function.\n+ * @param {Object} input the input.\n+ * @return {Object} the same input.\n+ *\/\n+function identity(input) {\n+    return input;\n+}\n+\n+\/**\n+ * Fill in an array with a string.\n+ * @param {String} str the string to use.\n+ * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n+ * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n+ *\/\n+function stringToArrayLike(str, array) {\n+    for (var i = 0; i < str.length; ++i) {\n+        array[i] = str.charCodeAt(i) & 0xFF;\n+    }\n+    return array;\n+}\n+\n+\/**\n+ * An helper for the function arrayLikeToString.\n+ * This contains static information and functions that\n+ * can be optimized by the browser JIT compiler.\n+ *\/\n+var arrayToStringHelper = {\n+    \/**\n+     * Transform an array of int into a string, chunk by chunk.\n+     * See the performances notes on arrayLikeToString.\n+     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n+     * @param {String} type the type of the array.\n+     * @param {Integer} chunk the chunk size.\n+     * @return {String} the resulting string.\n+     * @throws Error if the chunk is too big for the stack.\n+     *\/\n+    stringifyByChunk: function(array, type, chunk) {\n+        var result = [], k = 0, len = array.length;\n+        \/\/ shortcut\n+        if (len <= chunk) {\n+            return String.fromCharCode.apply(null, array);\n+        }\n+        while (k < len) {\n+            if (type === \"array\" || type === \"nodebuffer\") {\n+                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n+            }\n+            else {\n+                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n+            }\n+            k += chunk;\n+        }\n+        return result.join(\"\");\n+    },\n+    \/**\n+     * Call String.fromCharCode on every item in the array.\n+     * This is the naive implementation, which generate A LOT of intermediate string.\n+     * This should be used when everything else fail.\n+     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n+     * @return {String} the result.\n+     *\/\n+    stringifyByChar: function(array){\n+        var resultStr = \"\";\n+        for(var i = 0; i < array.length; i++) {\n+            resultStr += String.fromCharCode(array[i]);\n+        }\n+        return resultStr;\n+    },\n+    applyCanBeUsed : {\n+        \/**\n+         * true if the browser accepts to use String.fromCharCode on Uint8Array\n+         *\/\n+        uint8array : (function () {\n+            try {\n+                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;\n+            } catch (e) {\n+                return false;\n+            }\n+        })(),\n+        \/**\n+         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.\n+         *\/\n+        nodebuffer : (function () {\n+            try {\n+                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;\n+            } catch (e) {\n+                return false;\n+            }\n+        })()\n+    }\n+};\n+\n+\/**\n+ * Transform an array-like object to a string.\n+ * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n+ * @return {String} the result.\n+ *\/\n+function arrayLikeToString(array) {\n+    \/\/ Performances notes :\n+    \/\/ --------------------\n+    \/\/ String.fromCharCode.apply(null, array) is the fastest, see\n+    \/\/ see http:\/\/jsperf.com\/converting-a-uint8array-to-a-string\/2\n+    \/\/ but the stack is limited (and we can get huge arrays !).\n+    \/\/\n+    \/\/ result += String.fromCharCode(array[i]); generate too many strings !\n+    \/\/\n+    \/\/ This code is inspired by http:\/\/jsperf.com\/arraybuffer-to-string-apply-performance\/2\n+    \/\/ TODO : we now have workers that split the work. Do we still need that ?\n+    var chunk = 65536,\n+        type = exports.getTypeOf(array),\n+        canUseApply = true;\n+    if (type === \"uint8array\") {\n+        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;\n+    } else if (type === \"nodebuffer\") {\n+        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;\n+    }\n+\n+    if (canUseApply) {\n+        while (chunk > 1) {\n+            try {\n+                return arrayToStringHelper.stringifyByChunk(array, type, chunk);\n+            } catch (e) {\n+                chunk = Math.floor(chunk \/ 2);\n+            }\n+        }\n+    }\n+\n+    \/\/ no apply or chunk error : slow and painful algorithm\n+    \/\/ default browser on android 4.*\n+    return arrayToStringHelper.stringifyByChar(array);\n+}\n+\n+exports.applyFromCharCode = arrayLikeToString;\n+\n+\n+\/**\n+ * Copy the data from an array-like to an other array-like.\n+ * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n+ * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n+ * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n+ *\/\n+function arrayLikeToArrayLike(arrayFrom, arrayTo) {\n+    for (var i = 0; i < arrayFrom.length; i++) {\n+        arrayTo[i] = arrayFrom[i];\n+    }\n+    return arrayTo;\n+}\n+\n+\/\/ a matrix containing functions to transform everything into everything.\n+var transform = {};\n+\n+\/\/ string to ?\n+transform[\"string\"] = {\n+    \"string\": identity,\n+    \"array\": function(input) {\n+        return stringToArrayLike(input, new Array(input.length));\n+    },\n+    \"arraybuffer\": function(input) {\n+        return transform[\"string\"][\"uint8array\"](input).buffer;\n+    },\n+    \"uint8array\": function(input) {\n+        return stringToArrayLike(input, new Uint8Array(input.length));\n+    },\n+    \"nodebuffer\": function(input) {\n+        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));\n+    }\n+};\n+\n+\/\/ array to ?\n+transform[\"array\"] = {\n+    \"string\": arrayLikeToString,\n+    \"array\": identity,\n+    \"arraybuffer\": function(input) {\n+        return (new Uint8Array(input)).buffer;\n+    },\n+    \"uint8array\": function(input) {\n+        return new Uint8Array(input);\n+    },\n+    \"nodebuffer\": function(input) {\n+        return nodejsUtils.newBufferFrom(input);\n+    }\n+};\n+\n+\/\/ arraybuffer to ?\n+transform[\"arraybuffer\"] = {\n+    \"string\": function(input) {\n+        return arrayLikeToString(new Uint8Array(input));\n+    },\n+    \"array\": function(input) {\n+        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n+    },\n+    \"arraybuffer\": identity,\n+    \"uint8array\": function(input) {\n+        return new Uint8Array(input);\n+    },\n+    \"nodebuffer\": function(input) {\n+        return nodejsUtils.newBufferFrom(new Uint8Array(input));\n+    }\n+};\n+\n+\/\/ uint8array to ?\n+transform[\"uint8array\"] = {\n+    \"string\": arrayLikeToString,\n+    \"array\": function(input) {\n+        return arrayLikeToArrayLike(input, new Array(input.length));\n+    },\n+    \"arraybuffer\": function(input) {\n+        return input.buffer;\n+    },\n+    \"uint8array\": identity,\n+    \"nodebuffer\": function(input) {\n+        return nodejsUtils.newBufferFrom(input);\n+    }\n+};\n+\n+\/\/ nodebuffer to ?\n+transform[\"nodebuffer\"] = {\n+    \"string\": arrayLikeToString,\n+    \"array\": function(input) {\n+        return arrayLikeToArrayLike(input, new Array(input.length));\n+    },\n+    \"arraybuffer\": function(input) {\n+        return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n+    },\n+    \"uint8array\": function(input) {\n+        return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n+    },\n+    \"nodebuffer\": identity\n+};\n+\n+\/**\n+ * Transform an input into any type.\n+ * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n+ * If no output type is specified, the unmodified input will be returned.\n+ * @param {String} outputType the output type.\n+ * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n+ * @throws {Error} an Error if the browser doesn't support the requested output type.\n+ *\/\n+exports.transformTo = function(outputType, input) {\n+    if (!input) {\n+        \/\/ undefined, null, etc\n+        \/\/ an empty string won't harm.\n+        input = \"\";\n+    }\n+    if (!outputType) {\n+        return input;\n+    }\n+    exports.checkSupport(outputType);\n+    var inputType = exports.getTypeOf(input);\n+    var result = transform[inputType][outputType](input);\n+    return result;\n+};\n+\n+\/**\n+ * Return the type of the input.\n+ * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n+ * @param {Object} input the input to identify.\n+ * @return {String} the (lowercase) type of the input.\n+ *\/\n+exports.getTypeOf = function(input) {\n+    if (typeof input === \"string\") {\n+        return \"string\";\n+    }\n+    if (Object.prototype.toString.call(input) === \"[object Array]\") {\n+        return \"array\";\n+    }\n+    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {\n+        return \"nodebuffer\";\n+    }\n+    if (support.uint8array && input instanceof Uint8Array) {\n+        return \"uint8array\";\n+    }\n+    if (support.arraybuffer && input instanceof ArrayBuffer) {\n+        return \"arraybuffer\";\n+    }\n+};\n+\n+\/**\n+ * Throw an exception if the type is not supported.\n+ * @param {String} type the type to check.\n+ * @throws {Error} an Error if the browser doesn't support the requested type.\n+ *\/\n+exports.checkSupport = function(type) {\n+    var supported = support[type.toLowerCase()];\n+    if (!supported) {\n+        throw new Error(type + \" is not supported by this platform\");\n+    }\n+};\n+\n+exports.MAX_VALUE_16BITS = 65535;\n+exports.MAX_VALUE_32BITS = -1; \/\/ well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n+\n+\/**\n+ * Prettify a string read as binary.\n+ * @param {string} str the string to prettify.\n+ * @return {string} a pretty string.\n+ *\/\n+exports.pretty = function(str) {\n+    var res = '',\n+        code, i;\n+    for (i = 0; i < (str || \"\").length; i++) {\n+        code = str.charCodeAt(i);\n+        res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n+    }\n+    return res;\n+};\n+\n+\/**\n+ * Defer the call of a function.\n+ * @param {Function} callback the function to call asynchronously.\n+ * @param {Array} args the arguments to give to the callback.\n+ *\/\n+exports.delay = function(callback, args, self) {\n+    setImmediate(function () {\n+        callback.apply(self || null, args || []);\n+    });\n+};\n+\n+\/**\n+ * Extends a prototype with an other, without calling a constructor with\n+ * side effects. Inspired by nodejs' `utils.inherits`\n+ * @param {Function} ctor the constructor to augment\n+ * @param {Function} superCtor the parent constructor to use\n+ *\/\n+exports.inherits = function (ctor, superCtor) {\n+    var Obj = function() {};\n+    Obj.prototype = superCtor.prototype;\n+    ctor.prototype = new Obj();\n+};\n+\n+\/**\n+ * Merge the objects passed as parameters into a new one.\n+ * @private\n+ * @param {...Object} var_args All objects to merge.\n+ * @return {Object} a new object with the data of the others.\n+ *\/\n+exports.extend = function() {\n+    var result = {}, i, attr;\n+    for (i = 0; i < arguments.length; i++) { \/\/ arguments is not enumerable in some browsers\n+        for (attr in arguments[i]) {\n+            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\") {\n+                result[attr] = arguments[i][attr];\n+            }\n+        }\n+    }\n+    return result;\n+};\n+\n+\/**\n+ * Transform arbitrary content into a Promise.\n+ * @param {String} name a name for the content being processed.\n+ * @param {Object} inputData the content to process.\n+ * @param {Boolean} isBinary true if the content is not an unicode string\n+ * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.\n+ * @param {Boolean} isBase64 true if the string content is encoded with base64.\n+ * @return {Promise} a promise in a format usable by JSZip.\n+ *\/\n+exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {\n+\n+    \/\/ if inputData is already a promise, this flatten it.\n+    var promise = external.Promise.resolve(inputData).then(function(data) {\n+        \n+        \n+        var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);\n+\n+        if (isBlob && typeof FileReader !== \"undefined\") {\n+            return new external.Promise(function (resolve, reject) {\n+                var reader = new FileReader();\n+\n+                reader.onload = function(e) {\n+                    resolve(e.target.result);\n+                };\n+                reader.onerror = function(e) {\n+                    reject(e.target.error);\n+                };\n+                reader.readAsArrayBuffer(data);\n+            });\n+        } else {\n+            return data;\n+        }\n+    });\n+\n+    return promise.then(function(data) {\n+        var dataType = exports.getTypeOf(data);\n+\n+        if (!dataType) {\n+            return external.Promise.reject(\n+                new Error(\"Can't read the data of '\" + name + \"'. Is it \" +\n+                          \"in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\")\n+            );\n+        }\n+        \/\/ special case : it's way easier to work with Uint8Array than with ArrayBuffer\n+        if (dataType === \"arraybuffer\") {\n+            data = exports.transformTo(\"uint8array\", data);\n+        } else if (dataType === \"string\") {\n+            if (isBase64) {\n+                data = base64.decode(data);\n+            }\n+            else if (isBinary) {\n+                \/\/ optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask\n+                if (isOptimizedBinaryString !== true) {\n+                    \/\/ this is a string, not in a base64 format.\n+                    \/\/ Be sure that this is a correct \"binary string\"\n+                    data = string2binary(data);\n+                }\n+            }\n+        }\n+        return data;\n+    });\n+};\n+\n+},{\".\/base64\":1,\".\/external\":6,\".\/nodejsUtils\":14,\".\/support\":30,\"set-immediate-shim\":54}],33:[function(require,module,exports){\n+'use strict';\n+var readerFor = require('.\/reader\/readerFor');\n+var utils = require('.\/utils');\n+var sig = require('.\/signature');\n+var ZipEntry = require('.\/zipEntry');\n+var utf8 = require('.\/utf8');\n+var support = require('.\/support');\n+\/\/  class ZipEntries {{{\n+\/**\n+ * All the entries in the zip file.\n+ * @constructor\n+ * @param {Object} loadOptions Options for loading the stream.\n+ *\/\n+function ZipEntries(loadOptions) {\n+    this.files = [];\n+    this.loadOptions = loadOptions;\n+}\n+ZipEntries.prototype = {\n+    \/**\n+     * Check that the reader is on the specified signature.\n+     * @param {string} expectedSignature the expected signature.\n+     * @throws {Error} if it is an other signature.\n+     *\/\n+    checkSignature: function(expectedSignature) {\n+        if (!this.reader.readAndCheckSignature(expectedSignature)) {\n+            this.reader.index -= 4;\n+            var signature = this.reader.readString(4);\n+            throw new Error(\"Corrupted zip or bug: unexpected signature \" + \"(\" + utils.pretty(signature) + \", expected \" + utils.pretty(expectedSignature) + \")\");\n+        }\n+    },\n+    \/**\n+     * Check if the given signature is at the given index.\n+     * @param {number} askedIndex the index to check.\n+     * @param {string} expectedSignature the signature to expect.\n+     * @return {boolean} true if the signature is here, false otherwise.\n+     *\/\n+    isSignature: function(askedIndex, expectedSignature) {\n+        var currentIndex = this.reader.index;\n+        this.reader.setIndex(askedIndex);\n+        var signature = this.reader.readString(4);\n+        var result = signature === expectedSignature;\n+        this.reader.setIndex(currentIndex);\n+        return result;\n+    },\n+    \/**\n+     * Read the end of the central directory.\n+     *\/\n+    readBlockEndOfCentral: function() {\n+        this.diskNumber = this.reader.readInt(2);\n+        this.diskWithCentralDirStart = this.reader.readInt(2);\n+        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);\n+        this.centralDirRecords = this.reader.readInt(2);\n+        this.centralDirSize = this.reader.readInt(4);\n+        this.centralDirOffset = this.reader.readInt(4);\n+\n+        this.zipCommentLength = this.reader.readInt(2);\n+        \/\/ warning : the encoding depends of the system locale\n+        \/\/ On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.\n+        \/\/ On a windows machine, this field is encoded with the localized windows code page.\n+        var zipComment = this.reader.readData(this.zipCommentLength);\n+        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n+        \/\/ To get consistent behavior with the generation part, we will assume that\n+        \/\/ this is utf8 encoded unless specified otherwise.\n+        var decodeContent = utils.transformTo(decodeParamType, zipComment);\n+        this.zipComment = this.loadOptions.decodeFileName(decodeContent);\n+    },\n+    \/**\n+     * Read the end of the Zip 64 central directory.\n+     * Not merged with the method readEndOfCentral :\n+     * The end of central can coexist with its Zip64 brother,\n+     * I don't want to read the wrong number of bytes !\n+     *\/\n+    readBlockZip64EndOfCentral: function() {\n+        this.zip64EndOfCentralSize = this.reader.readInt(8);\n+        this.reader.skip(4);\n+        \/\/ this.versionMadeBy = this.reader.readString(2);\n+        \/\/ this.versionNeeded = this.reader.readInt(2);\n+        this.diskNumber = this.reader.readInt(4);\n+        this.diskWithCentralDirStart = this.reader.readInt(4);\n+        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);\n+        this.centralDirRecords = this.reader.readInt(8);\n+        this.centralDirSize = this.reader.readInt(8);\n+        this.centralDirOffset = this.reader.readInt(8);\n+\n+        this.zip64ExtensibleData = {};\n+        var extraDataSize = this.zip64EndOfCentralSize - 44,\n+            index = 0,\n+            extraFieldId,\n+            extraFieldLength,\n+            extraFieldValue;\n+        while (index < extraDataSize) {\n+            extraFieldId = this.reader.readInt(2);\n+            extraFieldLength = this.reader.readInt(4);\n+            extraFieldValue = this.reader.readData(extraFieldLength);\n+            this.zip64ExtensibleData[extraFieldId] = {\n+                id: extraFieldId,\n+                length: extraFieldLength,\n+                value: extraFieldValue\n+            };\n+        }\n+    },\n+    \/**\n+     * Read the end of the Zip 64 central directory locator.\n+     *\/\n+    readBlockZip64EndOfCentralLocator: function() {\n+        this.diskWithZip64CentralDirStart = this.reader.readInt(4);\n+        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);\n+        this.disksCount = this.reader.readInt(4);\n+        if (this.disksCount > 1) {\n+            throw new Error(\"Multi-volumes zip are not supported\");\n+        }\n+    },\n+    \/**\n+     * Read the local files, based on the offset read in the central part.\n+     *\/\n+    readLocalFiles: function() {\n+        var i, file;\n+        for (i = 0; i < this.files.length; i++) {\n+            file = this.files[i];\n+            this.reader.setIndex(file.localHeaderOffset);\n+            this.checkSignature(sig.LOCAL_FILE_HEADER);\n+            file.readLocalPart(this.reader);\n+            file.handleUTF8();\n+            file.processAttributes();\n+        }\n+    },\n+    \/**\n+     * Read the central directory.\n+     *\/\n+    readCentralDir: function() {\n+        var file;\n+\n+        this.reader.setIndex(this.centralDirOffset);\n+        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {\n+            file = new ZipEntry({\n+                zip64: this.zip64\n+            }, this.loadOptions);\n+            file.readCentralPart(this.reader);\n+            this.files.push(file);\n+        }\n+\n+        if (this.centralDirRecords !== this.files.length) {\n+            if (this.centralDirRecords !== 0 && this.files.length === 0) {\n+                \/\/ We expected some records but couldn't find ANY.\n+                \/\/ This is really suspicious, as if something went wrong.\n+                throw new Error(\"Corrupted zip or bug: expected \" + this.centralDirRecords + \" records in central dir, got \" + this.files.length);\n+            } else {\n+                \/\/ We found some records but not all.\n+                \/\/ Something is wrong but we got something for the user: no error here.\n+                \/\/ console.warn(\"expected\", this.centralDirRecords, \"records in central dir, got\", this.files.length);\n+            }\n+        }\n+    },\n+    \/**\n+     * Read the end of central directory.\n+     *\/\n+    readEndOfCentral: function() {\n+        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);\n+        if (offset < 0) {\n+            \/\/ Check if the content is a truncated zip or complete garbage.\n+            \/\/ A \"LOCAL_FILE_HEADER\" is not required at the beginning (auto\n+            \/\/ extractible zip for example) but it can give a good hint.\n+            \/\/ If an ajax request was used without responseType, we will also\n+            \/\/ get unreadable data.\n+            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);\n+\n+            if (isGarbage) {\n+                throw new Error(\"Can't find end of central directory : is this a zip file ? \" +\n+                                \"If it is, see https:\/\/stuk.github.io\/jszip\/documentation\/howto\/read_zip.html\");\n+            } else {\n+                throw new Error(\"Corrupted zip: can't find end of central directory\");\n+            }\n+\n+        }\n+        this.reader.setIndex(offset);\n+        var endOfCentralDirOffset = offset;\n+        this.checkSignature(sig.CENTRAL_DIRECTORY_END);\n+        this.readBlockEndOfCentral();\n+\n+\n+        \/* extract from the zip spec :\n+            4)  If one of the fields in the end of central directory\n+                record is too small to hold required data, the field\n+                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the\n+                ZIP64 format record should be created.\n+            5)  The end of central directory record and the\n+                Zip64 end of central directory locator record must\n+                reside on the same disk when splitting or spanning\n+                an archive.\n+         *\/\n+        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {\n+            this.zip64 = true;\n+\n+            \/*\n+            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from\n+            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents\n+            all numbers as 64-bit double precision IEEE 754 floating point numbers.\n+            So, we have 53bits for integers and bitwise operations treat everything as 32bits.\n+            see https:\/\/developer.mozilla.org\/en-US\/docs\/JavaScript\/Reference\/Operators\/Bitwise_Operators\n+            and http:\/\/www.ecma-international.org\/publications\/files\/ECMA-ST\/ECMA-262.pdf section 8.5\n+            *\/\n+\n+            \/\/ should look for a zip64 EOCD locator\n+            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n+            if (offset < 0) {\n+                throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory locator\");\n+            }\n+            this.reader.setIndex(offset);\n+            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n+            this.readBlockZip64EndOfCentralLocator();\n+\n+            \/\/ now the zip64 EOCD record\n+            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {\n+                \/\/ console.warn(\"ZIP64 end of central directory not where expected.\");\n+                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n+                if (this.relativeOffsetEndOfZip64CentralDir < 0) {\n+                    throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory\");\n+                }\n+            }\n+            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);\n+            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n+            this.readBlockZip64EndOfCentral();\n+        }\n+\n+        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;\n+        if (this.zip64) {\n+            expectedEndOfCentralDirOffset += 20; \/\/ end of central dir 64 locator\n+            expectedEndOfCentralDirOffset += 12 \/* should not include the leading 12 bytes *\/ + this.zip64EndOfCentralSize;\n+        }\n+\n+        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;\n+\n+        if (extraBytes > 0) {\n+            \/\/ console.warn(extraBytes, \"extra bytes at beginning or within zipfile\");\n+            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {\n+                \/\/ The offsets seem wrong, but we have something at the specified offset.\n+                \/\/ So… we keep it.\n+            } else {\n+                \/\/ the offset is wrong, update the \"zero\" of the reader\n+                \/\/ this happens if data has been prepended (crx files for example)\n+                this.reader.zero = extraBytes;\n+            }\n+        } else if (extraBytes < 0) {\n+            throw new Error(\"Corrupted zip: missing \" + Math.abs(extraBytes) + \" bytes.\");\n+        }\n+    },\n+    prepareReader: function(data) {\n+        this.reader = readerFor(data);\n+    },\n+    \/**\n+     * Read a zip file and create ZipEntries.\n+     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.\n+     *\/\n+    load: function(data) {\n+        this.prepareReader(data);\n+        this.readEndOfCentral();\n+        this.readCentralDir();\n+        this.readLocalFiles();\n+    }\n+};\n+\/\/ }}} end of ZipEntries\n+module.exports = ZipEntries;\n+\n+},{\".\/reader\/readerFor\":22,\".\/signature\":23,\".\/support\":30,\".\/utf8\":31,\".\/utils\":32,\".\/zipEntry\":34}],34:[function(require,module,exports){\n+'use strict';\n+var readerFor = require('.\/reader\/readerFor');\n+var utils = require('.\/utils');\n+var CompressedObject = require('.\/compressedObject');\n+var crc32fn = require('.\/crc32');\n+var utf8 = require('.\/utf8');\n+var compressions = require('.\/compressions');\n+var support = require('.\/support');\n+\n+var MADE_BY_DOS = 0x00;\n+var MADE_BY_UNIX = 0x03;\n+\n+\/**\n+ * Find a compression registered in JSZip.\n+ * @param {string} compressionMethod the method magic to find.\n+ * @return {Object|null} the JSZip compression object, null if none found.\n+ *\/\n+var findCompression = function(compressionMethod) {\n+    for (var method in compressions) {\n+        if (!compressions.hasOwnProperty(method)) {\n+            continue;\n+        }\n+        if (compressions[method].magic === compressionMethod) {\n+            return compressions[method];\n+        }\n+    }\n+    return null;\n+};\n+\n+\/\/ class ZipEntry {{{\n+\/**\n+ * An entry in the zip file.\n+ * @constructor\n+ * @param {Object} options Options of the current file.\n+ * @param {Object} loadOptions Options for loading the stream.\n+ *\/\n+function ZipEntry(options, loadOptions) {\n+    this.options = options;\n+    this.loadOptions = loadOptions;\n+}\n+ZipEntry.prototype = {\n+    \/**\n+     * say if the file is encrypted.\n+     * @return {boolean} true if the file is encrypted, false otherwise.\n+     *\/\n+    isEncrypted: function() {\n+        \/\/ bit 1 is set\n+        return (this.bitFlag & 0x0001) === 0x0001;\n+    },\n+    \/**\n+     * say if the file has utf-8 filename\/comment.\n+     * @return {boolean} true if the filename\/comment is in utf-8, false otherwise.\n+     *\/\n+    useUTF8: function() {\n+        \/\/ bit 11 is set\n+        return (this.bitFlag & 0x0800) === 0x0800;\n+    },\n+    \/**\n+     * Read the local part of a zip file and add the info in this object.\n+     * @param {DataReader} reader the reader to use.\n+     *\/\n+    readLocalPart: function(reader) {\n+        var compression, localExtraFieldsLength;\n+\n+        \/\/ we already know everything from the central dir !\n+        \/\/ If the central dir data are false, we are doomed.\n+        \/\/ On the bright side, the local part is scary  : zip64, data descriptors, both, etc.\n+        \/\/ The less data we get here, the more reliable this should be.\n+        \/\/ Let's skip the whole header and dash to the data !\n+        reader.skip(22);\n+        \/\/ in some zip created on windows, the filename stored in the central dir contains \\ instead of \/.\n+        \/\/ Strangely, the filename here is OK.\n+        \/\/ I would love to treat these zip files as corrupted (see http:\/\/www.info-zip.org\/FAQ.html#backslashes\n+        \/\/ or APPNOTE#4.4.17.1, \"All slashes MUST be forward slashes '\/'\") but there are a lot of bad zip generators...\n+        \/\/ Search \"unzip mismatching \"local\" filename continuing with \"central\" filename version\" on\n+        \/\/ the internet.\n+        \/\/\n+        \/\/ I think I see the logic here : the central directory is used to display\n+        \/\/ content and the local directory is used to extract the files. Mixing \/ and \\\n+        \/\/ may be used to display \\ to windows users and use \/ when extracting the files.\n+        \/\/ Unfortunately, this lead also to some issues : http:\/\/seclists.org\/fulldisclosure\/2009\/Sep\/394\n+        this.fileNameLength = reader.readInt(2);\n+        localExtraFieldsLength = reader.readInt(2); \/\/ can't be sure this will be the same as the central dir\n+        \/\/ the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.\n+        this.fileName = reader.readData(this.fileNameLength);\n+        reader.skip(localExtraFieldsLength);\n+\n+        if (this.compressedSize === -1 || this.uncompressedSize === -1) {\n+            throw new Error(\"Bug or corrupted zip : didn't get enough information from the central directory \" + \"(compressedSize === -1 || uncompressedSize === -1)\");\n+        }\n+\n+        compression = findCompression(this.compressionMethod);\n+        if (compression === null) { \/\/ no compression found\n+            throw new Error(\"Corrupted zip : compression \" + utils.pretty(this.compressionMethod) + \" unknown (inner file : \" + utils.transformTo(\"string\", this.fileName) + \")\");\n+        }\n+        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));\n+    },\n+\n+    \/**\n+     * Read the central part of a zip file and add the info in this object.\n+     * @param {DataReader} reader the reader to use.\n+     *\/\n+    readCentralPart: function(reader) {\n+        this.versionMadeBy = reader.readInt(2);\n+        reader.skip(2);\n+        \/\/ this.versionNeeded = reader.readInt(2);\n+        this.bitFlag = reader.readInt(2);\n+        this.compressionMethod = reader.readString(2);\n+        this.date = reader.readDate();\n+        this.crc32 = reader.readInt(4);\n+        this.compressedSize = reader.readInt(4);\n+        this.uncompressedSize = reader.readInt(4);\n+        var fileNameLength = reader.readInt(2);\n+        this.extraFieldsLength = reader.readInt(2);\n+        this.fileCommentLength = reader.readInt(2);\n+        this.diskNumberStart = reader.readInt(2);\n+        this.internalFileAttributes = reader.readInt(2);\n+        this.externalFileAttributes = reader.readInt(4);\n+        this.localHeaderOffset = reader.readInt(4);\n+\n+        if (this.isEncrypted()) {\n+            throw new Error(\"Encrypted zip are not supported\");\n+        }\n+\n+        \/\/ will be read in the local part, see the comments there\n+        reader.skip(fileNameLength);\n+        this.readExtraFields(reader);\n+        this.parseZIP64ExtraField(reader);\n+        this.fileComment = reader.readData(this.fileCommentLength);\n+    },\n+\n+    \/**\n+     * Parse the external file attributes and get the unix\/dos permissions.\n+     *\/\n+    processAttributes: function () {\n+        this.unixPermissions = null;\n+        this.dosPermissions = null;\n+        var madeBy = this.versionMadeBy >> 8;\n+\n+        \/\/ Check if we have the DOS directory flag set.\n+        \/\/ We look for it in the DOS and UNIX permissions\n+        \/\/ but some unknown platform could set it as a compatibility flag.\n+        this.dir = this.externalFileAttributes & 0x0010 ? true : false;\n+\n+        if(madeBy === MADE_BY_DOS) {\n+            \/\/ first 6 bits (0 to 5)\n+            this.dosPermissions = this.externalFileAttributes & 0x3F;\n+        }\n+\n+        if(madeBy === MADE_BY_UNIX) {\n+            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;\n+            \/\/ the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);\n+        }\n+\n+        \/\/ fail safe : if the name ends with a \/ it probably means a folder\n+        if (!this.dir && this.fileNameStr.slice(-1) === '\/') {\n+            this.dir = true;\n+        }\n+    },\n+\n+    \/**\n+     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.\n+     * @param {DataReader} reader the reader to use.\n+     *\/\n+    parseZIP64ExtraField: function(reader) {\n+\n+        if (!this.extraFields[0x0001]) {\n+            return;\n+        }\n+\n+        \/\/ should be something, preparing the extra reader\n+        var extraReader = readerFor(this.extraFields[0x0001].value);\n+\n+        \/\/ I really hope that these 64bits integer can fit in 32 bits integer, because js\n+        \/\/ won't let us have more.\n+        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {\n+            this.uncompressedSize = extraReader.readInt(8);\n+        }\n+        if (this.compressedSize === utils.MAX_VALUE_32BITS) {\n+            this.compressedSize = extraReader.readInt(8);\n+        }\n+        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {\n+            this.localHeaderOffset = extraReader.readInt(8);\n+        }\n+        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {\n+            this.diskNumberStart = extraReader.readInt(4);\n+        }\n+    },\n+    \/**\n+     * Read the central part of a zip file and add the info in this object.\n+     * @param {DataReader} reader the reader to use.\n+     *\/\n+    readExtraFields: function(reader) {\n+        var end = reader.index + this.extraFieldsLength,\n+            extraFieldId,\n+            extraFieldLength,\n+            extraFieldValue;\n+\n+        if (!this.extraFields) {\n+            this.extraFields = {};\n+        }\n+\n+        while (reader.index + 4 < end) {\n+            extraFieldId = reader.readInt(2);\n+            extraFieldLength = reader.readInt(2);\n+            extraFieldValue = reader.readData(extraFieldLength);\n+\n+            this.extraFields[extraFieldId] = {\n+                id: extraFieldId,\n+                length: extraFieldLength,\n+                value: extraFieldValue\n+            };\n+        }\n+\n+        reader.setIndex(end);\n+    },\n+    \/**\n+     * Apply an UTF8 transformation if needed.\n+     *\/\n+    handleUTF8: function() {\n+        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n+        if (this.useUTF8()) {\n+            this.fileNameStr = utf8.utf8decode(this.fileName);\n+            this.fileCommentStr = utf8.utf8decode(this.fileComment);\n+        } else {\n+            var upath = this.findExtraFieldUnicodePath();\n+            if (upath !== null) {\n+                this.fileNameStr = upath;\n+            } else {\n+                \/\/ ASCII text or unsupported code page\n+                var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);\n+                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);\n+            }\n+\n+            var ucomment = this.findExtraFieldUnicodeComment();\n+            if (ucomment !== null) {\n+                this.fileCommentStr = ucomment;\n+            } else {\n+                \/\/ ASCII text or unsupported code page\n+                var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);\n+                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);\n+            }\n+        }\n+    },\n+\n+    \/**\n+     * Find the unicode path declared in the extra field, if any.\n+     * @return {String} the unicode path, null otherwise.\n+     *\/\n+    findExtraFieldUnicodePath: function() {\n+        var upathField = this.extraFields[0x7075];\n+        if (upathField) {\n+            var extraReader = readerFor(upathField.value);\n+\n+            \/\/ wrong version\n+            if (extraReader.readInt(1) !== 1) {\n+                return null;\n+            }\n+\n+            \/\/ the crc of the filename changed, this field is out of date.\n+            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {\n+                return null;\n+            }\n+\n+            return utf8.utf8decode(extraReader.readData(upathField.length - 5));\n+        }\n+        return null;\n+    },\n+\n+    \/**\n+     * Find the unicode comment declared in the extra field, if any.\n+     * @return {String} the unicode comment, null otherwise.\n+     *\/\n+    findExtraFieldUnicodeComment: function() {\n+        var ucommentField = this.extraFields[0x6375];\n+        if (ucommentField) {\n+            var extraReader = readerFor(ucommentField.value);\n+\n+            \/\/ wrong version\n+            if (extraReader.readInt(1) !== 1) {\n+                return null;\n+            }\n+\n+            \/\/ the crc of the comment changed, this field is out of date.\n+            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {\n+                return null;\n+            }\n+\n+            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));\n+        }\n+        return null;\n+    }\n+};\n+module.exports = ZipEntry;\n+\n+},{\".\/compressedObject\":2,\".\/compressions\":3,\".\/crc32\":4,\".\/reader\/readerFor\":22,\".\/support\":30,\".\/utf8\":31,\".\/utils\":32}],35:[function(require,module,exports){\n+'use strict';\n+\n+var StreamHelper = require('.\/stream\/StreamHelper');\n+var DataWorker = require('.\/stream\/DataWorker');\n+var utf8 = require('.\/utf8');\n+var CompressedObject = require('.\/compressedObject');\n+var GenericWorker = require('.\/stream\/GenericWorker');\n+\n+\/**\n+ * A simple object representing a file in the zip file.\n+ * @constructor\n+ * @param {string} name the name of the file\n+ * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n+ * @param {Object} options the options of the file\n+ *\/\n+var ZipObject = function(name, data, options) {\n+    this.name = name;\n+    this.dir = options.dir;\n+    this.date = options.date;\n+    this.comment = options.comment;\n+    this.unixPermissions = options.unixPermissions;\n+    this.dosPermissions = options.dosPermissions;\n+\n+    this._data = data;\n+    this._dataBinary = options.binary;\n+    \/\/ keep only the compression\n+    this.options = {\n+        compression : options.compression,\n+        compressionOptions : options.compressionOptions\n+    };\n+};\n+\n+ZipObject.prototype = {\n+    \/**\n+     * Create an internal stream for the content of this object.\n+     * @param {String} type the type of each chunk.\n+     * @return StreamHelper the stream.\n+     *\/\n+    internalStream: function (type) {\n+        var result = null, outputType = \"string\";\n+        try {\n+            if (!type) {\n+                throw new Error(\"No output type specified.\");\n+            }\n+            outputType = type.toLowerCase();\n+            var askUnicodeString = outputType === \"string\" || outputType === \"text\";\n+            if (outputType === \"binarystring\" || outputType === \"text\") {\n+                outputType = \"string\";\n+            }\n+            result = this._decompressWorker();\n+\n+            var isUnicodeString = !this._dataBinary;\n+\n+            if (isUnicodeString && !askUnicodeString) {\n+                result = result.pipe(new utf8.Utf8EncodeWorker());\n+            }\n+            if (!isUnicodeString && askUnicodeString) {\n+                result = result.pipe(new utf8.Utf8DecodeWorker());\n+            }\n+        } catch (e) {\n+            result = new GenericWorker(\"error\");\n+            result.error(e);\n+        }\n+\n+        return new StreamHelper(result, outputType, \"\");\n+    },\n+\n+    \/**\n+     * Prepare the content in the asked type.\n+     * @param {String} type the type of the result.\n+     * @param {Function} onUpdate a function to call on each internal update.\n+     * @return Promise the promise of the result.\n+     *\/\n+    async: function (type, onUpdate) {\n+        return this.internalStream(type).accumulate(onUpdate);\n+    },\n+\n+    \/**\n+     * Prepare the content as a nodejs stream.\n+     * @param {String} type the type of each chunk.\n+     * @param {Function} onUpdate a function to call on each internal update.\n+     * @return Stream the stream.\n+     *\/\n+    nodeStream: function (type, onUpdate) {\n+        return this.internalStream(type || \"nodebuffer\").toNodejsStream(onUpdate);\n+    },\n+\n+    \/**\n+     * Return a worker for the compressed content.\n+     * @private\n+     * @param {Object} compression the compression object to use.\n+     * @param {Object} compressionOptions the options to use when compressing.\n+     * @return Worker the worker.\n+     *\/\n+    _compressWorker: function (compression, compressionOptions) {\n+        if (\n+            this._data instanceof CompressedObject &&\n+            this._data.compression.magic === compression.magic\n+        ) {\n+            return this._data.getCompressedWorker();\n+        } else {\n+            var result = this._decompressWorker();\n+            if(!this._dataBinary) {\n+                result = result.pipe(new utf8.Utf8EncodeWorker());\n+            }\n+            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);\n+        }\n+    },\n+    \/**\n+     * Return a worker for the decompressed content.\n+     * @private\n+     * @return Worker the worker.\n+     *\/\n+    _decompressWorker : function () {\n+        if (this._data instanceof CompressedObject) {\n+            return this._data.getContentWorker();\n+        } else if (this._data instanceof GenericWorker) {\n+            return this._data;\n+        } else {\n+            return new DataWorker(this._data);\n+        }\n+    }\n+};\n+\n+var removedMethods = [\"asText\", \"asBinary\", \"asNodeBuffer\", \"asUint8Array\", \"asArrayBuffer\"];\n+var removedFn = function () {\n+    throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\");\n+};\n+\n+for(var i = 0; i < removedMethods.length; i++) {\n+    ZipObject.prototype[removedMethods[i]] = removedFn;\n+}\n+module.exports = ZipObject;\n+\n+},{\".\/compressedObject\":2,\".\/stream\/DataWorker\":27,\".\/stream\/GenericWorker\":28,\".\/stream\/StreamHelper\":29,\".\/utf8\":31}],36:[function(require,module,exports){\n+(function (global){\n+'use strict';\n+var Mutation = global.MutationObserver || global.WebKitMutationObserver;\n+\n+var scheduleDrain;\n+\n+{\n+  if (Mutation) {\n+    var called = 0;\n+    var observer = new Mutation(nextTick);\n+    var element = global.document.createTextNode('');\n+    observer.observe(element, {\n+      characterData: true\n+    });\n+    scheduleDrain = function () {\n+      element.data = (called = ++called % 2);\n+    };\n+  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n+    var channel = new global.MessageChannel();\n+    channel.port1.onmessage = nextTick;\n+    scheduleDrain = function () {\n+      channel.port2.postMessage(0);\n+    };\n+  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n+    scheduleDrain = function () {\n+\n+      \/\/ Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n+      \/\/ into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n+      var scriptEl = global.document.createElement('script');\n+      scriptEl.onreadystatechange = function () {\n+        nextTick();\n+\n+        scriptEl.onreadystatechange = null;\n+        scriptEl.parentNode.removeChild(scriptEl);\n+        scriptEl = null;\n+      };\n+      global.document.documentElement.appendChild(scriptEl);\n+    };\n+  } else {\n+    scheduleDrain = function () {\n+      setTimeout(nextTick, 0);\n+    };\n+  }\n+}\n+\n+var draining;\n+var queue = [];\n+\/\/named nextTick for less confusing stack traces\n+function nextTick() {\n+  draining = true;\n+  var i, oldQueue;\n+  var len = queue.length;\n+  while (len) {\n+    oldQueue = queue;\n+    queue = [];\n+    i = -1;\n+    while (++i < len) {\n+      oldQueue[i]();\n+    }\n+    len = queue.length;\n+  }\n+  draining = false;\n+}\n+\n+module.exports = immediate;\n+function immediate(task) {\n+  if (queue.push(task) === 1 && !draining) {\n+    scheduleDrain();\n+  }\n+}\n+\n+}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n+},{}],37:[function(require,module,exports){\n+'use strict';\n+var immediate = require('immediate');\n+\n+\/* istanbul ignore next *\/\n+function INTERNAL() {}\n+\n+var handlers = {};\n+\n+var REJECTED = ['REJECTED'];\n+var FULFILLED = ['FULFILLED'];\n+var PENDING = ['PENDING'];\n+\n+module.exports = Promise;\n+\n+function Promise(resolver) {\n+  if (typeof resolver !== 'function') {\n+    throw new TypeError('resolver must be a function');\n+  }\n+  this.state = PENDING;\n+  this.queue = [];\n+  this.outcome = void 0;\n+  if (resolver !== INTERNAL) {\n+    safelyResolveThenable(this, resolver);\n+  }\n+}\n+\n+Promise.prototype[\"finally\"] = function (callback) {\n+  if (typeof callback !== 'function') {\n+    return this;\n+  }\n+  var p = this.constructor;\n+  return this.then(resolve, reject);\n+\n+  function resolve(value) {\n+    function yes () {\n+      return value;\n+    }\n+    return p.resolve(callback()).then(yes);\n+  }\n+  function reject(reason) {\n+    function no () {\n+      throw reason;\n+    }\n+    return p.resolve(callback()).then(no);\n+  }\n+};\n+Promise.prototype[\"catch\"] = function (onRejected) {\n+  return this.then(null, onRejected);\n+};\n+Promise.prototype.then = function (onFulfilled, onRejected) {\n+  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n+    typeof onRejected !== 'function' && this.state === REJECTED) {\n+    return this;\n+  }\n+  var promise = new this.constructor(INTERNAL);\n+  if (this.state !== PENDING) {\n+    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n+    unwrap(promise, resolver, this.outcome);\n+  } else {\n+    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n+  }\n+\n+  return promise;\n+};\n+function QueueItem(promise, onFulfilled, onRejected) {\n+  this.promise = promise;\n+  if (typeof onFulfilled === 'function') {\n+    this.onFulfilled = onFulfilled;\n+    this.callFulfilled = this.otherCallFulfilled;\n+  }\n+  if (typeof onRejected === 'function') {\n+    this.onRejected = onRejected;\n+    this.callRejected = this.otherCallRejected;\n+  }\n+}\n+QueueItem.prototype.callFulfilled = function (value) {\n+  handlers.resolve(this.promise, value);\n+};\n+QueueItem.prototype.otherCallFulfilled = function (value) {\n+  unwrap(this.promise, this.onFulfilled, value);\n+};\n+QueueItem.prototype.callRejected = function (value) {\n+  handlers.reject(this.promise, value);\n+};\n+QueueItem.prototype.otherCallRejected = function (value) {\n+  unwrap(this.promise, this.onRejected, value);\n+};\n+\n+function unwrap(promise, func, value) {\n+  immediate(function () {\n+    var returnValue;\n+    try {\n+      returnValue = func(value);\n+    } catch (e) {\n+      return handlers.reject(promise, e);\n+    }\n+    if (returnValue === promise) {\n+      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n+    } else {\n+      handlers.resolve(promise, returnValue);\n+    }\n+  });\n+}\n+\n+handlers.resolve = function (self, value) {\n+  var result = tryCatch(getThen, value);\n+  if (result.status === 'error') {\n+    return handlers.reject(self, result.value);\n+  }\n+  var thenable = result.value;\n+\n+  if (thenable) {\n+    safelyResolveThenable(self, thenable);\n+  } else {\n+    self.state = FULFILLED;\n+    self.outcome = value;\n+    var i = -1;\n+    var len = self.queue.length;\n+    while (++i < len) {\n+      self.queue[i].callFulfilled(value);\n+    }\n+  }\n+  return self;\n+};\n+handlers.reject = function (self, error) {\n+  self.state = REJECTED;\n+  self.outcome = error;\n+  var i = -1;\n+  var len = self.queue.length;\n+  while (++i < len) {\n+    self.queue[i].callRejected(error);\n+  }\n+  return self;\n+};\n+\n+function getThen(obj) {\n+  \/\/ Make sure we only access the accessor once as required by the spec\n+  var then = obj && obj.then;\n+  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n+    return function appyThen() {\n+      then.apply(obj, arguments);\n+    };\n+  }\n+}\n+\n+function safelyResolveThenable(self, thenable) {\n+  \/\/ Either fulfill, reject or reject with error\n+  var called = false;\n+  function onError(value) {\n+    if (called) {\n+      return;\n+    }\n+    called = true;\n+    handlers.reject(self, value);\n+  }\n+\n+  function onSuccess(value) {\n+    if (called) {\n+      return;\n+    }\n+    called = true;\n+    handlers.resolve(self, value);\n+  }\n+\n+  function tryToUnwrap() {\n+    thenable(onSuccess, onError);\n+  }\n+\n+  var result = tryCatch(tryToUnwrap);\n+  if (result.status === 'error') {\n+    onError(result.value);\n+  }\n+}\n+\n+function tryCatch(func, value) {\n+  var out = {};\n+  try {\n+    out.value = func(value);\n+    out.status = 'success';\n+  } catch (e) {\n+    out.status = 'error';\n+    out.value = e;\n+  }\n+  return out;\n+}\n+\n+Promise.resolve = resolve;\n+function resolve(value) {\n+  if (value instanceof this) {\n+    return value;\n+  }\n+  return handlers.resolve(new this(INTERNAL), value);\n+}\n+\n+Promise.reject = reject;\n+function reject(reason) {\n+  var promise = new this(INTERNAL);\n+  return handlers.reject(promise, reason);\n+}\n+\n+Promise.all = all;\n+function all(iterable) {\n+  var self = this;\n+  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n+    return this.reject(new TypeError('must be an array'));\n+  }\n+\n+  var len = iterable.length;\n+  var called = false;\n+  if (!len) {\n+    return this.resolve([]);\n+  }\n+\n+  var values = new Array(len);\n+  var resolved = 0;\n+  var i = -1;\n+  var promise = new this(INTERNAL);\n+\n+  while (++i < len) {\n+    allResolver(iterable[i], i);\n+  }\n+  return promise;\n+  function allResolver(value, i) {\n+    self.resolve(value).then(resolveFromAll, function (error) {\n+      if (!called) {\n+        called = true;\n+        handlers.reject(promise, error);\n+      }\n+    });\n+    function resolveFromAll(outValue) {\n+      values[i] = outValue;\n+      if (++resolved === len && !called) {\n+        called = true;\n+        handlers.resolve(promise, values);\n+      }\n+    }\n+  }\n+}\n+\n+Promise.race = race;\n+function race(iterable) {\n+  var self = this;\n+  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n+    return this.reject(new TypeError('must be an array'));\n+  }\n+\n+  var len = iterable.length;\n+  var called = false;\n+  if (!len) {\n+    return this.resolve([]);\n+  }\n+\n+  var i = -1;\n+  var promise = new this(INTERNAL);\n+\n+  while (++i < len) {\n+    resolver(iterable[i]);\n+  }\n+  return promise;\n+  function resolver(value) {\n+    self.resolve(value).then(function (response) {\n+      if (!called) {\n+        called = true;\n+        handlers.resolve(promise, response);\n+      }\n+    }, function (error) {\n+      if (!called) {\n+        called = true;\n+        handlers.reject(promise, error);\n+      }\n+    });\n+  }\n+}\n+\n+},{\"immediate\":36}],38:[function(require,module,exports){\n+\/\/ Top level file is just a mixin of submodules & constants\n+'use strict';\n+\n+var assign    = require('.\/lib\/utils\/common').assign;\n+\n+var deflate   = require('.\/lib\/deflate');\n+var inflate   = require('.\/lib\/inflate');\n+var constants = require('.\/lib\/zlib\/constants');\n+\n+var pako = {};\n+\n+assign(pako, deflate, inflate, constants);\n+\n+module.exports = pako;\n+\n+},{\".\/lib\/deflate\":39,\".\/lib\/inflate\":40,\".\/lib\/utils\/common\":41,\".\/lib\/zlib\/constants\":44}],39:[function(require,module,exports){\n+'use strict';\n+\n+\n+var zlib_deflate = require('.\/zlib\/deflate');\n+var utils        = require('.\/utils\/common');\n+var strings      = require('.\/utils\/strings');\n+var msg          = require('.\/zlib\/messages');\n+var ZStream      = require('.\/zlib\/zstream');\n+\n+var toString = Object.prototype.toString;\n+\n+\/* Public constants ==========================================================*\/\n+\/* ===========================================================================*\/\n+\n+var Z_NO_FLUSH      = 0;\n+var Z_FINISH        = 4;\n+\n+var Z_OK            = 0;\n+var Z_STREAM_END    = 1;\n+var Z_SYNC_FLUSH    = 2;\n+\n+var Z_DEFAULT_COMPRESSION = -1;\n+\n+var Z_DEFAULT_STRATEGY    = 0;\n+\n+var Z_DEFLATED  = 8;\n+\n+\/* ===========================================================================*\/\n+\n+\n+\/**\n+ * class Deflate\n+ *\n+ * Generic JS-style wrapper for zlib calls. If you don't need\n+ * streaming behaviour - use more simple functions: [[deflate]],\n+ * [[deflateRaw]] and [[gzip]].\n+ **\/\n+\n+\/* internal\n+ * Deflate.chunks -> Array\n+ *\n+ * Chunks of output data, if [[Deflate#onData]] not overriden.\n+ **\/\n+\n+\/**\n+ * Deflate.result -> Uint8Array|Array\n+ *\n+ * Compressed result, generated by default [[Deflate#onData]]\n+ * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n+ * (call [[Deflate#push]] with `Z_FINISH` \/ `true` param)  or if you\n+ * push a chunk with explicit flush (call [[Deflate#push]] with\n+ * `Z_SYNC_FLUSH` param).\n+ **\/\n+\n+\/**\n+ * Deflate.err -> Number\n+ *\n+ * Error code after deflate finished. 0 (Z_OK) on success.\n+ * You will not need it in real life, because deflate errors\n+ * are possible only on wrong options or bad `onData` \/ `onEnd`\n+ * custom handlers.\n+ **\/\n+\n+\/**\n+ * Deflate.msg -> String\n+ *\n+ * Error message, if [[Deflate.err]] != 0\n+ **\/\n+\n+\n+\/**\n+ * new Deflate(options)\n+ * - options (Object): zlib deflate options.\n+ *\n+ * Creates new deflator instance with specified params. Throws exception\n+ * on bad params. Supported options:\n+ *\n+ * - `level`\n+ * - `windowBits`\n+ * - `memLevel`\n+ * - `strategy`\n+ * - `dictionary`\n+ *\n+ * [http:\/\/zlib.net\/manual.html#Advanced](http:\/\/zlib.net\/manual.html#Advanced)\n+ * for more information on these.\n+ *\n+ * Additional options, for internal needs:\n+ *\n+ * - `chunkSize` - size of generated data chunks (16K by default)\n+ * - `raw` (Boolean) - do raw deflate\n+ * - `gzip` (Boolean) - create gzip wrapper\n+ * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n+ *    (each char code [0..255])\n+ * - `header` (Object) - custom header for gzip\n+ *   - `text` (Boolean) - true if compressed data believed to be text\n+ *   - `time` (Number) - modification time, unix timestamp\n+ *   - `os` (Number) - operation system code\n+ *   - `extra` (Array) - array of bytes with extra data (max 65536)\n+ *   - `name` (String) - file name (binary string)\n+ *   - `comment` (String) - comment (binary string)\n+ *   - `hcrc` (Boolean) - true if header crc should be added\n+ *\n+ * ##### Example:\n+ *\n+ * ```javascript\n+ * var pako = require('pako')\n+ *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n+ *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n+ *\n+ * var deflate = new pako.Deflate({ level: 3});\n+ *\n+ * deflate.push(chunk1, false);\n+ * deflate.push(chunk2, true);  \/\/ true -> last chunk\n+ *\n+ * if (deflate.err) { throw new Error(deflate.err); }\n+ *\n+ * console.log(deflate.result);\n+ * ```\n+ **\/\n+function Deflate(options) {\n+  if (!(this instanceof Deflate)) return new Deflate(options);\n+\n+  this.options = utils.assign({\n+    level: Z_DEFAULT_COMPRESSION,\n+    method: Z_DEFLATED,\n+    chunkSize: 16384,\n+    windowBits: 15,\n+    memLevel: 8,\n+    strategy: Z_DEFAULT_STRATEGY,\n+    to: ''\n+  }, options || {});\n+\n+  var opt = this.options;\n+\n+  if (opt.raw && (opt.windowBits > 0)) {\n+    opt.windowBits = -opt.windowBits;\n+  }\n+\n+  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n+    opt.windowBits += 16;\n+  }\n+\n+  this.err    = 0;      \/\/ error code, if happens (0 = Z_OK)\n+  this.msg    = '';     \/\/ error message\n+  this.ended  = false;  \/\/ used to avoid multiple onEnd() calls\n+  this.chunks = [];     \/\/ chunks of compressed data\n+\n+  this.strm = new ZStream();\n+  this.strm.avail_out = 0;\n+\n+  var status = zlib_deflate.deflateInit2(\n+    this.strm,\n+    opt.level,\n+    opt.method,\n+    opt.windowBits,\n+    opt.memLevel,\n+    opt.strategy\n+  );\n+\n+  if (status !== Z_OK) {\n+    throw new Error(msg[status]);\n+  }\n+\n+  if (opt.header) {\n+    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n+  }\n+\n+  if (opt.dictionary) {\n+    var dict;\n+    \/\/ Convert data if needed\n+    if (typeof opt.dictionary === 'string') {\n+      \/\/ If we need to compress text, change encoding to utf8.\n+      dict = strings.string2buf(opt.dictionary);\n+    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n+      dict = new Uint8Array(opt.dictionary);\n+    } else {\n+      dict = opt.dictionary;\n+    }\n+\n+    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n+\n+    if (status !== Z_OK) {\n+      throw new Error(msg[status]);\n+    }\n+\n+    this._dict_set = true;\n+  }\n+}\n+\n+\/**\n+ * Deflate#push(data[, mode]) -> Boolean\n+ * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n+ *   converted to utf8 byte sequence.\n+ * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n+ *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.\n+ *\n+ * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n+ * new compressed chunks. Returns `true` on success. The last data block must have\n+ * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n+ * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n+ * can use mode Z_SYNC_FLUSH, keeping the compression context.\n+ *\n+ * On fail call [[Deflate#onEnd]] with error code and return false.\n+ *\n+ * We strongly recommend to use `Uint8Array` on input for best speed (output\n+ * array format is detected automatically). Also, don't skip last param and always\n+ * use the same type in your code (boolean or number). That will improve JS speed.\n+ *\n+ * For regular `Array`-s make sure all elements are [0..255].\n+ *\n+ * ##### Example\n+ *\n+ * ```javascript\n+ * push(chunk, false); \/\/ push one of data chunks\n+ * ...\n+ * push(chunk, true);  \/\/ push last chunk\n+ * ```\n+ **\/\n+Deflate.prototype.push = function (data, mode) {\n+  var strm = this.strm;\n+  var chunkSize = this.options.chunkSize;\n+  var status, _mode;\n+\n+  if (this.ended) { return false; }\n+\n+  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n+\n+  \/\/ Convert data if needed\n+  if (typeof data === 'string') {\n+    \/\/ If we need to compress text, change encoding to utf8.\n+    strm.input = strings.string2buf(data);\n+  } else if (toString.call(data) === '[object ArrayBuffer]') {\n+    strm.input = new Uint8Array(data);\n+  } else {\n+    strm.input = data;\n+  }\n+\n+  strm.next_in = 0;\n+  strm.avail_in = strm.input.length;\n+\n+  do {\n+    if (strm.avail_out === 0) {\n+      strm.output = new utils.Buf8(chunkSize);\n+      strm.next_out = 0;\n+      strm.avail_out = chunkSize;\n+    }\n+    status = zlib_deflate.deflate(strm, _mode);    \/* no bad return value *\/\n+\n+    if (status !== Z_STREAM_END && status !== Z_OK) {\n+      this.onEnd(status);\n+      this.ended = true;\n+      return false;\n+    }\n+    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n+      if (this.options.to === 'string') {\n+        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n+      } else {\n+        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n+      }\n+    }\n+  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n+\n+  \/\/ Finalize on the last chunk.\n+  if (_mode === Z_FINISH) {\n+    status = zlib_deflate.deflateEnd(this.strm);\n+    this.onEnd(status);\n+    this.ended = true;\n+    return status === Z_OK;\n+  }\n+\n+  \/\/ callback interim results if Z_SYNC_FLUSH.\n+  if (_mode === Z_SYNC_FLUSH) {\n+    this.onEnd(Z_OK);\n+    strm.avail_out = 0;\n+    return true;\n+  }\n+\n+  return true;\n+};\n+\n+\n+\/**\n+ * Deflate#onData(chunk) -> Void\n+ * - chunk (Uint8Array|Array|String): ouput data. Type of array depends\n+ *   on js engine support. When string output requested, each chunk\n+ *   will be string.\n+ *\n+ * By default, stores data blocks in `chunks[]` property and glue\n+ * those in `onEnd`. Override this handler, if you need another behaviour.\n+ **\/\n+Deflate.prototype.onData = function (chunk) {\n+  this.chunks.push(chunk);\n+};\n+\n+\n+\/**\n+ * Deflate#onEnd(status) -> Void\n+ * - status (Number): deflate status. 0 (Z_OK) on success,\n+ *   other if not.\n+ *\n+ * Called once after you tell deflate that the input stream is\n+ * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n+ * or if an error happened. By default - join collected chunks,\n+ * free memory and fill `results` \/ `err` properties.\n+ **\/\n+Deflate.prototype.onEnd = function (status) {\n+  \/\/ On success - join\n+  if (status === Z_OK) {\n+    if (this.options.to === 'string') {\n+      this.result = this.chunks.join('');\n+    } else {\n+      this.result = utils.flattenChunks(this.chunks);\n+    }\n+  }\n+  this.chunks = [];\n+  this.err = status;\n+  this.msg = this.strm.msg;\n+};\n+\n+\n+\/**\n+ * deflate(data[, options]) -> Uint8Array|Array|String\n+ * - data (Uint8Array|Array|String): input data to compress.\n+ * - options (Object): zlib deflate options.\n+ *\n+ * Compress `data` with deflate algorithm and `options`.\n+ *\n+ * Supported options are:\n+ *\n+ * - level\n+ * - windowBits\n+ * - memLevel\n+ * - strategy\n+ * - dictionary\n+ *\n+ * [http:\/\/zlib.net\/manual.html#Advanced](http:\/\/zlib.net\/manual.html#Advanced)\n+ * for more information on these.\n+ *\n+ * Sugar (options):\n+ *\n+ * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n+ *   negative windowBits implicitly.\n+ * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n+ *    (each char code [0..255])\n+ *\n+ * ##### Example:\n+ *\n+ * ```javascript\n+ * var pako = require('pako')\n+ *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n+ *\n+ * console.log(pako.deflate(data));\n+ * ```\n+ **\/\n+function deflate(input, options) {\n+  var deflator = new Deflate(options);\n+\n+  deflator.push(input, true);\n+\n+  \/\/ That will never happens, if you don't cheat with options :)\n+  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n+\n+  return deflator.result;\n+}\n+\n+\n+\/**\n+ * deflateRaw(data[, options]) -> Uint8Array|Array|String\n+ * - data (Uint8Array|Array|String): input data to compress.\n+ * - options (Object): zlib deflate options.\n+ *\n+ * The same as [[deflate]], but creates raw data, without wrapper\n+ * (header and adler32 crc).\n+ **\/\n+function deflateRaw(input, options) {\n+  options = options || {};\n+  options.raw = true;\n+  return deflate(input, options);\n+}\n+\n+\n+\/**\n+ * gzip(data[, options]) -> Uint8Array|Array|String\n+ * - data (Uint8Array|Array|String): input data to compress.\n+ * - options (Object): zlib deflate options.\n+ *\n+ * The same as [[deflate]], but create gzip wrapper instead of\n+ * deflate one.\n+ **\/\n+function gzip(input, options) {\n+  options = options || {};\n+  options.gzip = true;\n+  return deflate(input, options);\n+}\n+\n+\n+exports.Deflate = Deflate;\n+exports.deflate = deflate;\n+exports.deflateRaw = deflateRaw;\n+exports.gzip = gzip;\n+\n+},{\".\/utils\/common\":41,\".\/utils\/strings\":42,\".\/zlib\/deflate\":46,\".\/zlib\/messages\":51,\".\/zlib\/zstream\":53}],40:[function(require,module,exports){\n+'use strict';\n+\n+\n+var zlib_inflate = require('.\/zlib\/inflate');\n+var utils        = require('.\/utils\/common');\n+var strings      = require('.\/utils\/strings');\n+var c            = require('.\/zlib\/constants');\n+var msg          = require('.\/zlib\/messages');\n+var ZStream      = require('.\/zlib\/zstream');\n+var GZheader     = require('.\/zlib\/gzheader');\n+\n+var toString = Object.prototype.toString;\n+\n+\/**\n+ * class Inflate\n+ *\n+ * Generic JS-style wrapper for zlib calls. If you don't need\n+ * streaming behaviour - use more simple functions: [[inflate]]\n+ * and [[inflateRaw]].\n+ **\/\n+\n+\/* internal\n+ * inflate.chunks -> Array\n+ *\n+ * Chunks of output data, if [[Inflate#onData]] not overriden.\n+ **\/\n+\n+\/**\n+ * Inflate.result -> Uint8Array|Array|String\n+ *\n+ * Uncompressed result, generated by default [[Inflate#onData]]\n+ * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n+ * (call [[Inflate#push]] with `Z_FINISH` \/ `true` param) or if you\n+ * push a chunk with explicit flush (call [[Inflate#push]] with\n+ * `Z_SYNC_FLUSH` param).\n+ **\/\n+\n+\/**\n+ * Inflate.err -> Number\n+ *\n+ * Error code after inflate finished. 0 (Z_OK) on success.\n+ * Should be checked if broken data possible.\n+ **\/\n+\n+\/**\n+ * Inflate.msg -> String\n+ *\n+ * Error message, if [[Inflate.err]] != 0\n+ **\/\n+\n+\n+\/**\n+ * new Inflate(options)\n+ * - options (Object): zlib inflate options.\n+ *\n+ * Creates new inflator instance with specified params. Throws exception\n+ * on bad params. Supported options:\n+ *\n+ * - `windowBits`\n+ * - `dictionary`\n+ *\n+ * [http:\/\/zlib.net\/manual.html#Advanced](http:\/\/zlib.net\/manual.html#Advanced)\n+ * for more information on these.\n+ *\n+ * Additional options, for internal needs:\n+ *\n+ * - `chunkSize` - size of generated data chunks (16K by default)\n+ * - `raw` (Boolean) - do raw inflate\n+ * - `to` (String) - if equal to 'string', then result will be converted\n+ *   from utf8 to utf16 (javascript) string. When string output requested,\n+ *   chunk length can differ from `chunkSize`, depending on content.\n+ *\n+ * By default, when no options set, autodetect deflate\/gzip data format via\n+ * wrapper header.\n+ *\n+ * ##### Example:\n+ *\n+ * ```javascript\n+ * var pako = require('pako')\n+ *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n+ *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n+ *\n+ * var inflate = new pako.Inflate({ level: 3});\n+ *\n+ * inflate.push(chunk1, false);\n+ * inflate.push(chunk2, true);  \/\/ true -> last chunk\n+ *\n+ * if (inflate.err) { throw new Error(inflate.err); }\n+ *\n+ * console.log(inflate.result);\n+ * ```\n+ **\/\n+function Inflate(options) {\n+  if (!(this instanceof Inflate)) return new Inflate(options);\n+\n+  this.options = utils.assign({\n+    chunkSize: 16384,\n+    windowBits: 0,\n+    to: ''\n+  }, options || {});\n+\n+  var opt = this.options;\n+\n+  \/\/ Force window size for `raw` data, if not set directly,\n+  \/\/ because we have no header for autodetect.\n+  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n+    opt.windowBits = -opt.windowBits;\n+    if (opt.windowBits === 0) { opt.windowBits = -15; }\n+  }\n+\n+  \/\/ If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip\/deflate\n+  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n+      !(options && options.windowBits)) {\n+    opt.windowBits += 32;\n+  }\n+\n+  \/\/ Gzip header has no info about windows size, we can do autodetect only\n+  \/\/ for deflate. So, if window size not set, force it to max when gzip possible\n+  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n+    \/\/ bit 3 (16) -> gzipped data\n+    \/\/ bit 4 (32) -> autodetect gzip\/deflate\n+    if ((opt.windowBits & 15) === 0) {\n+      opt.windowBits |= 15;\n+    }\n+  }\n+\n+  this.err    = 0;      \/\/ error code, if happens (0 = Z_OK)\n+  this.msg    = '';     \/\/ error message\n+  this.ended  = false;  \/\/ used to avoid multiple onEnd() calls\n+  this.chunks = [];     \/\/ chunks of compressed data\n+\n+  this.strm   = new ZStream();\n+  this.strm.avail_out = 0;\n+\n+  var status  = zlib_inflate.inflateInit2(\n+    this.strm,\n+    opt.windowBits\n+  );\n+\n+  if (status !== c.Z_OK) {\n+    throw new Error(msg[status]);\n+  }\n+\n+  this.header = new GZheader();\n+\n+  zlib_inflate.inflateGetHeader(this.strm, this.header);\n+}\n+\n+\/**\n+ * Inflate#push(data[, mode]) -> Boolean\n+ * - data (Uint8Array|Array|ArrayBuffer|String): input data\n+ * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n+ *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.\n+ *\n+ * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n+ * new output chunks. Returns `true` on success. The last data block must have\n+ * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n+ * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n+ * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n+ *\n+ * On fail call [[Inflate#onEnd]] with error code and return false.\n+ *\n+ * We strongly recommend to use `Uint8Array` on input for best speed (output\n+ * format is detected automatically). Also, don't skip last param and always\n+ * use the same type in your code (boolean or number). That will improve JS speed.\n+ *\n+ * For regular `Array`-s make sure all elements are [0..255].\n+ *\n+ * ##### Example\n+ *\n+ * ```javascript\n+ * push(chunk, false); \/\/ push one of data chunks\n+ * ...\n+ * push(chunk, true);  \/\/ push last chunk\n+ * ```\n+ **\/\n+Inflate.prototype.push = function (data, mode) {\n+  var strm = this.strm;\n+  var chunkSize = this.options.chunkSize;\n+  var dictionary = this.options.dictionary;\n+  var status, _mode;\n+  var next_out_utf8, tail, utf8str;\n+  var dict;\n+\n+  \/\/ Flag to properly process Z_BUF_ERROR on testing inflate call\n+  \/\/ when we check that all output data was flushed.\n+  var allowBufError = false;\n+\n+  if (this.ended) { return false; }\n+  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n+\n+  \/\/ Convert data if needed\n+  if (typeof data === 'string') {\n+    \/\/ Only binary strings can be decompressed on practice\n+    strm.input = strings.binstring2buf(data);\n+  } else if (toString.call(data) === '[object ArrayBuffer]') {\n+    strm.input = new Uint8Array(data);\n+  } else {\n+    strm.input = data;\n+  }\n+\n+  strm.next_in = 0;\n+  strm.avail_in = strm.input.length;\n+\n+  do {\n+    if (strm.avail_out === 0) {\n+      strm.output = new utils.Buf8(chunkSize);\n+      strm.next_out = 0;\n+      strm.avail_out = chunkSize;\n+    }\n+\n+    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    \/* no bad return value *\/\n+\n+    if (status === c.Z_NEED_DICT && dictionary) {\n+      \/\/ Convert data if needed\n+      if (typeof dictionary === 'string') {\n+        dict = strings.string2buf(dictionary);\n+      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {\n+        dict = new Uint8Array(dictionary);\n+      } else {\n+        dict = dictionary;\n+      }\n+\n+      status = zlib_inflate.inflateSetDictionary(this.strm, dict);\n+\n+    }\n+\n+    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n+      status = c.Z_OK;\n+      allowBufError = false;\n+    }\n+\n+    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n+      this.onEnd(status);\n+      this.ended = true;\n+      return false;\n+    }\n+\n+    if (strm.next_out) {\n+      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n+\n+        if (this.options.to === 'string') {\n+\n+          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n+\n+          tail = strm.next_out - next_out_utf8;\n+          utf8str = strings.buf2string(strm.output, next_out_utf8);\n+\n+          \/\/ move tail\n+          strm.next_out = tail;\n+          strm.avail_out = chunkSize - tail;\n+          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n+\n+          this.onData(utf8str);\n+\n+        } else {\n+          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n+        }\n+      }\n+    }\n+\n+    \/\/ When no more input data, we should check that internal inflate buffers\n+    \/\/ are flushed. The only way to do it when avail_out = 0 - run one more\n+    \/\/ inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n+    \/\/ Here we set flag to process this error properly.\n+    \/\/\n+    \/\/ NOTE. Deflate does not return error in this case and does not needs such\n+    \/\/ logic.\n+    if (strm.avail_in === 0 && strm.avail_out === 0) {\n+      allowBufError = true;\n+    }\n+\n+  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n+\n+  if (status === c.Z_STREAM_END) {\n+    _mode = c.Z_FINISH;\n+  }\n+\n+  \/\/ Finalize on the last chunk.\n+  if (_mode === c.Z_FINISH) {\n+    status = zlib_inflate.inflateEnd(this.strm);\n+    this.onEnd(status);\n+    this.ended = true;\n+    return status === c.Z_OK;\n+  }\n+\n+  \/\/ callback interim results if Z_SYNC_FLUSH.\n+  if (_mode === c.Z_SYNC_FLUSH) {\n+    this.onEnd(c.Z_OK);\n+    strm.avail_out = 0;\n+    return true;\n+  }\n+\n+  return true;\n+};\n+\n+\n+\/**\n+ * Inflate#onData(chunk) -> Void\n+ * - chunk (Uint8Array|Array|String): ouput data. Type of array depends\n+ *   on js engine support. When string output requested, each chunk\n+ *   will be string.\n+ *\n+ * By default, stores data blocks in `chunks[]` property and glue\n+ * those in `onEnd`. Override this handler, if you need another behaviour.\n+ **\/\n+Inflate.prototype.onData = function (chunk) {\n+  this.chunks.push(chunk);\n+};\n+\n+\n+\/**\n+ * Inflate#onEnd(status) -> Void\n+ * - status (Number): inflate status. 0 (Z_OK) on success,\n+ *   other if not.\n+ *\n+ * Called either after you tell inflate that the input stream is\n+ * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n+ * or if an error happened. By default - join collected chunks,\n+ * free memory and fill `results` \/ `err` properties.\n+ **\/\n+Inflate.prototype.onEnd = function (status) {\n+  \/\/ On success - join\n+  if (status === c.Z_OK) {\n+    if (this.options.to === 'string') {\n+      \/\/ Glue & convert here, until we teach pako to send\n+      \/\/ utf8 alligned strings to onData\n+      this.result = this.chunks.join('');\n+    } else {\n+      this.result = utils.flattenChunks(this.chunks);\n+    }\n+  }\n+  this.chunks = [];\n+  this.err = status;\n+  this.msg = this.strm.msg;\n+};\n+\n+\n+\/**\n+ * inflate(data[, options]) -> Uint8Array|Array|String\n+ * - data (Uint8Array|Array|String): input data to decompress.\n+ * - options (Object): zlib inflate options.\n+ *\n+ * Decompress `data` with inflate\/ungzip and `options`. Autodetect\n+ * format via wrapper header by default. That's why we don't provide\n+ * separate `ungzip` method.\n+ *\n+ * Supported options are:\n+ *\n+ * - windowBits\n+ *\n+ * [http:\/\/zlib.net\/manual.html#Advanced](http:\/\/zlib.net\/manual.html#Advanced)\n+ * for more information.\n+ *\n+ * Sugar (options):\n+ *\n+ * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n+ *   negative windowBits implicitly.\n+ * - `to` (String) - if equal to 'string', then result will be converted\n+ *   from utf8 to utf16 (javascript) string. When string output requested,\n+ *   chunk length can differ from `chunkSize`, depending on content.\n+ *\n+ *\n+ * ##### Example:\n+ *\n+ * ```javascript\n+ * var pako = require('pako')\n+ *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n+ *   , output;\n+ *\n+ * try {\n+ *   output = pako.inflate(input);\n+ * } catch (err)\n+ *   console.log(err);\n+ * }\n+ * ```\n+ **\/\n+function inflate(input, options) {\n+  var inflator = new Inflate(options);\n+\n+  inflator.push(input, true);\n+\n+  \/\/ That will never happens, if you don't cheat with options :)\n+  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n+\n+  return inflator.result;\n+}\n+\n+\n+\/**\n+ * inflateRaw(data[, options]) -> Uint8Array|Array|String\n+ * - data (Uint8Array|Array|String): input data to decompress.\n+ * - options (Object): zlib inflate options.\n+ *\n+ * The same as [[inflate]], but creates raw data, without wrapper\n+ * (header and adler32 crc).\n+ **\/\n+function inflateRaw(input, options) {\n+  options = options || {};\n+  options.raw = true;\n+  return inflate(input, options);\n+}\n+\n+\n+\/**\n+ * ungzip(data[, options]) -> Uint8Array|Array|String\n+ * - data (Uint8Array|Array|String): input data to decompress.\n+ * - options (Object): zlib inflate options.\n+ *\n+ * Just shortcut to [[inflate]], because it autodetects format\n+ * by header.content. Done for convenience.\n+ **\/\n+\n+\n+exports.Inflate = Inflate;\n+exports.inflate = inflate;\n+exports.inflateRaw = inflateRaw;\n+exports.ungzip  = inflate;\n+\n+},{\".\/utils\/common\":41,\".\/utils\/strings\":42,\".\/zlib\/constants\":44,\".\/zlib\/gzheader\":47,\".\/zlib\/inflate\":49,\".\/zlib\/messages\":51,\".\/zlib\/zstream\":53}],41:[function(require,module,exports){\n+'use strict';\n+\n+\n+var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n+                (typeof Uint16Array !== 'undefined') &&\n+                (typeof Int32Array !== 'undefined');\n+\n+\n+exports.assign = function (obj \/*from1, from2, from3, ...*\/) {\n+  var sources = Array.prototype.slice.call(arguments, 1);\n+  while (sources.length) {\n+    var source = sources.shift();\n+    if (!source) { continue; }\n+\n+    if (typeof source !== 'object') {\n+      throw new TypeError(source + 'must be non-object');\n+    }\n+\n+    for (var p in source) {\n+      if (source.hasOwnProperty(p)) {\n+        obj[p] = source[p];\n+      }\n+    }\n+  }\n+\n+  return obj;\n+};\n+\n+\n+\/\/ reduce buffer size, avoiding mem copy\n+exports.shrinkBuf = function (buf, size) {\n+  if (buf.length === size) { return buf; }\n+  if (buf.subarray) { return buf.subarray(0, size); }\n+  buf.length = size;\n+  return buf;\n+};\n+\n+\n+var fnTyped = {\n+  arraySet: function (dest, src, src_offs, len, dest_offs) {\n+    if (src.subarray && dest.subarray) {\n+      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n+      return;\n+    }\n+    \/\/ Fallback to ordinary array\n+    for (var i = 0; i < len; i++) {\n+      dest[dest_offs + i] = src[src_offs + i];\n+    }\n+  },\n+  \/\/ Join array of chunks to single array.\n+  flattenChunks: function (chunks) {\n+    var i, l, len, pos, chunk, result;\n+\n+    \/\/ calculate data length\n+    len = 0;\n+    for (i = 0, l = chunks.length; i < l; i++) {\n+      len += chunks[i].length;\n+    }\n+\n+    \/\/ join chunks\n+    result = new Uint8Array(len);\n+    pos = 0;\n+    for (i = 0, l = chunks.length; i < l; i++) {\n+      chunk = chunks[i];\n+      result.set(chunk, pos);\n+      pos += chunk.length;\n+    }\n+\n+    return result;\n+  }\n+};\n+\n+var fnUntyped = {\n+  arraySet: function (dest, src, src_offs, len, dest_offs) {\n+    for (var i = 0; i < len; i++) {\n+      dest[dest_offs + i] = src[src_offs + i];\n+    }\n+  },\n+  \/\/ Join array of chunks to single array.\n+  flattenChunks: function (chunks) {\n+    return [].concat.apply([], chunks);\n+  }\n+};\n+\n+\n+\/\/ Enable\/Disable typed arrays use, for testing\n+\/\/\n+exports.setTyped = function (on) {\n+  if (on) {\n+    exports.Buf8  = Uint8Array;\n+    exports.Buf16 = Uint16Array;\n+    exports.Buf32 = Int32Array;\n+    exports.assign(exports, fnTyped);\n+  } else {\n+    exports.Buf8  = Array;\n+    exports.Buf16 = Array;\n+    exports.Buf32 = Array;\n+    exports.assign(exports, fnUntyped);\n+  }\n+};\n+\n+exports.setTyped(TYPED_OK);\n+\n+},{}],42:[function(require,module,exports){\n+\/\/ String encode\/decode helpers\n+'use strict';\n+\n+\n+var utils = require('.\/common');\n+\n+\n+\/\/ Quick check if we can use fast array to bin string conversion\n+\/\/\n+\/\/ - apply(Array) can fail on Android 2.2\n+\/\/ - apply(Uint8Array) can fail on iOS 5.1 Safary\n+\/\/\n+var STR_APPLY_OK = true;\n+var STR_APPLY_UIA_OK = true;\n+\n+try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\n+try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n+\n+\n+\/\/ Table with utf8 lengths (calculated by first byte of sequence)\n+\/\/ Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n+\/\/ because max possible codepoint is 0x10ffff\n+var _utf8len = new utils.Buf8(256);\n+for (var q = 0; q < 256; q++) {\n+  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n+}\n+_utf8len[254] = _utf8len[254] = 1; \/\/ Invalid sequence start\n+\n+\n+\/\/ convert string to array (typed, when possible)\n+exports.string2buf = function (str) {\n+  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n+\n+  \/\/ count binary size\n+  for (m_pos = 0; m_pos < str_len; m_pos++) {\n+    c = str.charCodeAt(m_pos);\n+    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n+      c2 = str.charCodeAt(m_pos + 1);\n+      if ((c2 & 0xfc00) === 0xdc00) {\n+        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n+        m_pos++;\n+      }\n+    }\n+    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n+  }\n+\n+  \/\/ allocate buffer\n+  buf = new utils.Buf8(buf_len);\n+\n+  \/\/ convert\n+  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n+    c = str.charCodeAt(m_pos);\n+    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n+      c2 = str.charCodeAt(m_pos + 1);\n+      if ((c2 & 0xfc00) === 0xdc00) {\n+        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n+        m_pos++;\n+      }\n+    }\n+    if (c < 0x80) {\n+      \/* one byte *\/\n+      buf[i++] = c;\n+    } else if (c < 0x800) {\n+      \/* two bytes *\/\n+      buf[i++] = 0xC0 | (c >>> 6);\n+      buf[i++] = 0x80 | (c & 0x3f);\n+    } else if (c < 0x10000) {\n+      \/* three bytes *\/\n+      buf[i++] = 0xE0 | (c >>> 12);\n+      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n+      buf[i++] = 0x80 | (c & 0x3f);\n+    } else {\n+      \/* four bytes *\/\n+      buf[i++] = 0xf0 | (c >>> 18);\n+      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n+      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n+      buf[i++] = 0x80 | (c & 0x3f);\n+    }\n+  }\n+\n+  return buf;\n+};\n+\n+\/\/ Helper (used in 2 places)\n+function buf2binstring(buf, len) {\n+  \/\/ use fallback for big arrays to avoid stack overflow\n+  if (len < 65537) {\n+    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n+      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n+    }\n+  }\n+\n+  var result = '';\n+  for (var i = 0; i < len; i++) {\n+    result += String.fromCharCode(buf[i]);\n+  }\n+  return result;\n+}\n+\n+\n+\/\/ Convert byte array to binary string\n+exports.buf2binstring = function (buf) {\n+  return buf2binstring(buf, buf.length);\n+};\n+\n+\n+\/\/ Convert binary string (typed, when possible)\n+exports.binstring2buf = function (str) {\n+  var buf = new utils.Buf8(str.length);\n+  for (var i = 0, len = buf.length; i < len; i++) {\n+    buf[i] = str.charCodeAt(i);\n+  }\n+  return buf;\n+};\n+\n+\n+\/\/ convert array to string\n+exports.buf2string = function (buf, max) {\n+  var i, out, c, c_len;\n+  var len = max || buf.length;\n+\n+  \/\/ Reserve max possible length (2 words per char)\n+  \/\/ NB: by unknown reasons, Array is significantly faster for\n+  \/\/     String.fromCharCode.apply than Uint16Array.\n+  var utf16buf = new Array(len * 2);\n+\n+  for (out = 0, i = 0; i < len;) {\n+    c = buf[i++];\n+    \/\/ quick process ascii\n+    if (c < 0x80) { utf16buf[out++] = c; continue; }\n+\n+    c_len = _utf8len[c];\n+    \/\/ skip 5 & 6 byte codes\n+    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n+\n+    \/\/ apply mask on first byte\n+    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n+    \/\/ join the rest\n+    while (c_len > 1 && i < len) {\n+      c = (c << 6) | (buf[i++] & 0x3f);\n+      c_len--;\n+    }\n+\n+    \/\/ terminated by end of string?\n+    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n+\n+    if (c < 0x10000) {\n+      utf16buf[out++] = c;\n+    } else {\n+      c -= 0x10000;\n+      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n+      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n+    }\n+  }\n+\n+  return buf2binstring(utf16buf, out);\n+};\n+\n+\n+\/\/ Calculate max possible position in utf8 buffer,\n+\/\/ that will not break sequence. If that's not possible\n+\/\/ - (very small limits) return max size as is.\n+\/\/\n+\/\/ buf[] - utf8 bytes array\n+\/\/ max   - length limit (mandatory);\n+exports.utf8border = function (buf, max) {\n+  var pos;\n+\n+  max = max || buf.length;\n+  if (max > buf.length) { max = buf.length; }\n+\n+  \/\/ go back from last position, until start of sequence found\n+  pos = max - 1;\n+  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n+\n+  \/\/ Fuckup - very small and broken sequence,\n+  \/\/ return max, because we should return something anyway.\n+  if (pos < 0) { return max; }\n+\n+  \/\/ If we came to start of buffer - that means vuffer is too small,\n+  \/\/ return max too.\n+  if (pos === 0) { return max; }\n+\n+  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n+};\n+\n+},{\".\/common\":41}],43:[function(require,module,exports){\n+'use strict';\n+\n+\/\/ Note: adler32 takes 12% for level 0 and 2% for level 6.\n+\/\/ It doesn't worth to make additional optimizationa as in original.\n+\/\/ Small size is preferable.\n+\n+\/\/ (C) 1995-2013 Jean-loup Gailly and Mark Adler\n+\/\/ (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n+\/\/\n+\/\/ This software is provided 'as-is', without any express or implied\n+\/\/ warranty. In no event will the authors be held liable for any damages\n+\/\/ arising from the use of this software.\n+\/\/\n+\/\/ Permission is granted to anyone to use this software for any purpose,\n+\/\/ including commercial applications, and to alter it and redistribute it\n+\/\/ freely, subject to the following restrictions:\n+\/\/\n+\/\/ 1. The origin of this software must not be misrepresented; you must not\n+\/\/   claim that you wrote the original software. If you use this software\n+\/\/   in a product, an acknowledgment in the product documentation would be\n+\/\/   appreciated but is not required.\n+\/\/ 2. Altered source versions must be plainly marked as such, and must not be\n+\/\/   misrepresented as being the original software.\n+\/\/ 3. This notice may not be removed or altered from any source distribution.\n+\n+function adler32(adler, buf, len, pos) {\n+  var s1 = (adler & 0xffff) |0,\n+      s2 = ((adler >>> 16) & 0xffff) |0,\n+      n = 0;\n+\n+  while (len !== 0) {\n+    \/\/ Set limit ~ twice less than 5552, to keep\n+    \/\/ s2 in 31-bits, because we force signed ints.\n+    \/\/ in other case %= will fail.\n+    n = len > 2000 ? 2000 : len;\n+    len -= n;\n+\n+    do {\n+      s1 = (s1 + buf[pos++]) |0;\n+      s2 = (s2 + s1) |0;\n+    } while (--n);\n+\n+    s1 %= 65521;\n+    s2 %= 65521;\n+  }\n+\n+  return (s1 | (s2 << 16)) |0;\n+}\n+\n+\n+module.exports = adler32;\n+\n+},{}],44:[function(require,module,exports){\n+'use strict';\n+\n+\/\/ (C) 1995-2013 Jean-loup Gailly and Mark Adler\n+\/\/ (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n+\/\/\n+\/\/ This software is provided 'as-is', without any express or implied\n+\/\/ warranty. In no event will the authors be held liable for any damages\n+\/\/ arising from the use of this software.\n+\/\/\n+\/\/ Permission is granted to anyone to use this software for any purpose,\n+\/\/ including commercial applications, and to alter it and redistribute it\n+\/\/ freely, subject to the following restrictions:\n+\/\/\n+\/\/ 1. The origin of this software must not be misrepresented; you must not\n+\/\/   claim that you wrote the original software. If you use this software\n+\/\/   in a product, an acknowledgment in the product documentation would be\n+\/\/   appreciated but is not required.\n+\/\/ 2. Altered source versions must be plainly marked as such, and must not be\n+\/\/   misrepresented as being the original software.\n+\/\/ 3. This notice may not be removed or altered from any source distribution.\n+\n+module.exports = {\n+\n+  \/* Allowed flush values; see deflate() and inflate() below for details *\/\n+  Z_NO_FLUSH:         0,\n+  Z_PARTIAL_FLUSH:    1,\n+  Z_SYNC_FLUSH:       2,\n+  Z_FULL_FLUSH:       3,\n+  Z_FINISH:           4,\n+  Z_BLOCK:            5,\n+  Z_TREES:            6,\n+\n+  \/* Return codes for the compression\/decompression functions. Negative values\n+  * are errors, positive values are used for special but normal events.\n+  *\/\n+  Z_OK:               0,\n+  Z_STREAM_END:       1,\n+  Z_NEED_DICT:        2,\n+  Z_ERRNO:           -1,\n+  Z_STREAM_ERROR:    -2,\n+  Z_DATA_ERROR:      -3,\n+  \/\/Z_MEM_ERROR:     -4,\n+  Z_BUF_ERROR:       -5,\n+  \/\/Z_VERSION_ERROR: -6,\n+\n+  \/* compression levels *\/\n+  Z_NO_COMPRESSION:         0,\n+  Z_BEST_SPEED:             1,\n+  Z_BEST_COMPRESSION:       9,\n+  Z_DEFAULT_COMPRESSION:   -1,\n+\n+\n+  Z_FILTERED:               1,\n+  Z_HUFFMAN_ONLY:           2,\n+  Z_RLE:                    3,\n+  Z_FIXED:                  4,\n+  Z_DEFAULT_STRATEGY:       0,\n+\n+  \/* Possible values of the data_type field (though see inflate()) *\/\n+  Z_BINARY:                 0,\n+  Z_TEXT:                   1,\n+  \/\/Z_ASCII:                1, \/\/ = Z_TEXT (deprecated)\n+  Z_UNKNOWN:                2,\n+\n+  \/* The deflate compression method *\/\n+  Z_DEFLATED:               8\n+  \/\/Z_NULL:                 null \/\/ Use -1 or null inline, depending on var type\n+};\n+\n+},{}],45:[function(require,module,exports){\n+'use strict';\n+\n+\/\/ Note: we can't get significant speed boost here.\n+\/\/ So write code to minimize size - no pregenerated tables\n+\/\/ and array tools dependencies.\n+\n+\/\/ (C) 1995-2013 Jean-loup Gailly and Mark Adler\n+\/\/ (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n+\/\/\n+\/\/ This software is provided 'as-is', without any express or implied\n+\/\/ warranty. In no event will the authors be held liable for any damages\n+\/\/ arising from the use of this software.\n+\/\/\n+\/\/ Permission is granted to anyone to use this software for any purpose,\n+\/\/ including commercial applications, and to alter it and redistribute it\n+\/\/ freely, subject to the following restrictions:\n+\/\/\n+\/\/ 1. The origin of this software must not be misrepresented; you must not\n+\/\/   claim that you wrote the original software. If you use this software\n+\/\/   in a product, an acknowledgment in the product documentation would be\n+\/\/   appreciated but is not required.\n+\/\/ 2. Altered source versions must be plainly marked as such, and must not be\n+\/\/   misrepresented as being the original software.\n+\/\/ 3. This notice may not be removed or altered from any source distribution.\n+\n+\/\/ Use ordinary array, since untyped makes no boost here\n+function makeTable() {\n+  var c, table = [];\n+\n+  for (var n = 0; n < 256; n++) {\n+    c = n;\n+    for (var k = 0; k < 8; k++) {\n+      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n+    }\n+    table[n] = c;\n+  }\n+\n+  return table;\n+}\n+\n+\/\/ Create table on load. Just 255 signed longs. Not a problem.\n+var crcTable = makeTable();\n+\n+\n+function crc32(crc, buf, len, pos) {\n+  var t = crcTable,\n+      end = pos + len;\n+\n+  crc ^= -1;\n+\n+  for (var i = pos; i < end; i++) {\n+    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n+  }\n+\n+  return (crc ^ (-1)); \/\/ >>> 0;\n+}\n+\n+\n+module.exports = crc32;\n+\n+},{}],46:[function(require,module,exports){\n+'use strict';\n+\n+\/\/ (C) 1995-2013 Jean-loup Gailly and Mark Adler\n+\/\/ (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n+\/\/\n+\/\/ This software is provided 'as-is', without any express or implied\n+\/\/ warranty. In no event will the authors be held liable for any damages\n+\/\/ arising from the use of this software.\n+\/\/\n+\/\/ Permission is granted to anyone to use this software for any purpose,\n+\/\/ including commercial applications, and to alter it and redistribute it\n+\/\/ freely, subject to the following restrictions:\n+\/\/\n+\/\/ 1. The origin of this software must not be misrepresented; you must not\n+\/\/   claim that you wrote the original software. If you use this software\n+\/\/   in a product, an acknowledgment in the product documentation would be\n+\/\/   appreciated but is not required.\n+\/\/ 2. Altered source versions must be plainly marked as such, and must not be\n+\/\/   misrepresented as being the original software.\n+\/\/ 3. This notice may not be removed or altered from any source distribution.\n+\n+var utils   = require('..\/utils\/common');\n+var trees   = require('.\/trees');\n+var adler32 = require('.\/adler32');\n+var crc32   = require('.\/crc32');\n+var msg     = require('.\/messages');\n+\n+\/* Public constants ==========================================================*\/\n+\/* ===========================================================================*\/\n+\n+\n+\/* Allowed flush values; see deflate() and inflate() below for details *\/\n+var Z_NO_FLUSH      = 0;\n+var Z_PARTIAL_FLUSH = 1;\n+\/\/var Z_SYNC_FLUSH    = 2;\n+var Z_FULL_FLUSH    = 3;\n+var Z_FINISH        = 4;\n+var Z_BLOCK         = 5;\n+\/\/var Z_TREES         = 6;\n+\n+\n+\/* Return codes for the compression\/decompression functions. Negative values\n+ * are errors, positive values are used for special but normal events.\n+ *\/\n+var Z_OK            = 0;\n+var Z_STREAM_END    = 1;\n+\/\/var Z_NEED_DICT     = 2;\n+\/\/var Z_ERRNO         = -1;\n+var Z_STREAM_ERROR  = -2;\n+var Z_DATA_ERROR    = -3;\n+\/\/var Z_MEM_ERROR     = -4;\n+var Z_BUF_ERROR     = -5;\n+\/\/var Z_VERSION_ERROR = -6;\n+\n+\n+\/* compression levels *\/\n+\/\/var Z_NO_COMPRESSION      = 0;\n+\/\/var Z_BEST_SPEED          = 1;\n+\/\/var Z_BEST_COMPRESSION    = 9;\n+var Z_DEFAULT_COMPRESSION = -1;\n+\n+\n+var Z_FILTERED            = 1;\n+var Z_HUFFMAN_ONLY        = 2;\n+var Z_RLE                 = 3;\n+var Z_FIXED               = 4;\n+var Z_DEFAULT_STRATEGY    = 0;\n+\n+\/* Possible values of the data_type field (though see inflate()) *\/\n+\/\/var Z_BINARY              = 0;\n+\/\/var Z_TEXT                = 1;\n+\/\/var Z_ASCII               = 1; \/\/ = Z_TEXT\n+var Z_UNKNOWN             = 2;\n+\n+\n+\/* The deflate compression method *\/\n+var Z_DEFLATED  = 8;\n+\n+\/*============================================================================*\/\n+\n+\n+var MAX_MEM_LEVEL = 9;\n+\/* Maximum value for memLevel in deflateInit2 *\/\n+var MAX_WBITS = 15;\n+\/* 32K LZ77 window *\/\n+var DEF_MEM_LEVEL = 8;\n+\n+\n+var LENGTH_CODES  = 29;\n+\/* number of length codes, not counting the special END_BLOCK code *\/\n+var LITERALS      = 256;\n+\/* number of literal bytes 0..255 *\/\n+var L_CODES       = LITERALS + 1 + LENGTH_CODES;\n+\/* number of Literal or Length codes, including the END_BLOCK code *\/\n+var D_CODES       = 30;\n+\/* number of distance codes *\/\n+var BL_CODES      = 19;\n+\/* number of codes used to transfer the bit lengths *\/\n+var HEAP_SIZE     = 2 * L_CODES + 1;\n+\/* maximum heap size *\/\n+var MAX_BITS  = 15;\n+\/* All codes must not exceed MAX_BITS bits *\/\n+\n+var MIN_MATCH = 3;\n+var MAX_MATCH = 258;\n+var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n+\n+var PRESET_DICT = 0x20;\n+\n+var INIT_STATE = 42;\n+var EXTRA_STATE = 69;\n+var NAME_STATE = 73;\n+var COMMENT_STATE = 91;\n+var HCRC_STATE = 103;\n+var BUSY_STATE = 113;\n+var FINISH_STATE = 666;\n+\n+var BS_NEED_MORE      = 1; \/* block not completed, need more input or more output *\/\n+var BS_BLOCK_DONE     = 2; \/* block flush performed *\/\n+var BS_FINISH_STARTED = 3; \/* finish started, need only more output at next deflate *\/\n+var BS_FINISH_DONE    = 4; \/* finish done, accept no more input or output *\/\n+\n+var OS_CODE = 0x03; \/\/ Unix :) . Don't detect, use this default.\n+\n+function err(strm, errorCode) {\n+  strm.msg = msg[errorCode];\n+  return errorCode;\n+}\n+\n+function rank(f) {\n+  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n+}\n+\n+function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n+\n+\n+\/* =========================================================================\n+ * Flush as much pending output as possible. All deflate() output goes\n+ * through this function so some applications may wish to modify it\n+ * to avoid allocating a large strm->output buffer and copying into it.\n+ * (See also read_buf()).\n+ *\/\n+function flush_pending(strm) {\n+  var s = strm.state;\n+\n+  \/\/_tr_flush_bits(s);\n+  var len = s.pending;\n+  if (len > strm.avail_out) {\n+    len = strm.avail_out;\n+  }\n+  if (len === 0) { return; }\n+\n+  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n+  strm.next_out += len;\n+  s.pending_out += len;\n+  strm.total_out += len;\n+  strm.avail_out -= len;\n+  s.pending -= len;\n+  if (s.pending === 0) {\n+    s.pending_out = 0;\n+  }\n+}\n+\n+\n+function flush_block_only(s, last) {\n+  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n+  s.block_start = s.strstart;\n+  flush_pending(s.strm);\n+}\n+\n+\n+function put_byte(s, b) {\n+  s.pending_buf[s.pending++] = b;\n+}\n+\n+\n+\/* =========================================================================\n+ * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n+ * IN assertion: the stream state is correct and there is enough room in\n+ * pending_buf.\n+ *\/\n+function putShortMSB(s, b) {\n+\/\/  put_byte(s, (Byte)(b >> 8));\n+\/\/  put_byte(s, (Byte)(b & 0xff));\n+  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n+  s.pending_buf[s.pending++] = b & 0xff;\n+}\n+\n+\n+\/* ===========================================================================\n+ * Read a new buffer from the current input stream, update the adler32\n+ * and total number of bytes read.  All deflate() input goes through\n+ * this function so some applications may wish to modify it to avoid\n+ * allocating a large strm->input buffer and copying from it.\n+ * (See also flush_pending()).\n+ *\/\n+function read_buf(strm, buf, start, size) {\n+  var len = strm.avail_in;\n+\n+  if (len > size) { len = size; }\n+  if (len === 0) { return 0; }\n+\n+  strm.avail_in -= len;\n+\n+  \/\/ zmemcpy(buf, strm->next_in, len);\n+  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n+  if (strm.state.wrap === 1) {\n+    strm.adler = adler32(strm.adler, buf, len, start);\n+  }\n+\n+  else if (strm.state.wrap === 2) {\n+    strm.adler = crc32(strm.adler, buf, len, start);\n+  }\n+\n+  strm.next_in += len;\n+  strm.total_in += len;\n+\n+  return len;\n+}\n+\n+\n+\/* ===========================================================================\n+ * Set match_start to the longest match starting at the given string and\n+ * return its length. Matches shorter or equal to prev_length are discarded,\n+ * in which case the result is equal to prev_length and match_start is\n+ * garbage.\n+ * IN assertions: cur_match is the head of the hash chain for the current\n+ *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n+ * OUT assertion: the match length is not greater than s->lookahead.\n+ *\/\n+function longest_match(s, cur_match) {\n+  var chain_length = s.max_chain_length;      \/* max hash chain length *\/\n+  var scan = s.strstart; \/* current string *\/\n+  var match;                       \/* matched string *\/\n+  var len;                           \/* length of current match *\/\n+  var best_len = s.prev_length;              \/* best match length so far *\/\n+  var nice_match = s.nice_match;             \/* stop if match long enough *\/\n+  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n+      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0\/*NIL*\/;\n+\n+  var _win = s.window; \/\/ shortcut\n+\n+  var wmask = s.w_mask;\n+  var prev  = s.prev;\n+\n+  \/* Stop when cur_match becomes <= limit. To simplify the code,\n+   * we prevent matches with the string of window index 0.\n+   *\/\n+\n+  var strend = s.strstart + MAX_MATCH;\n+  var scan_end1  = _win[scan + best_len - 1];\n+  var scan_end   = _win[scan + best_len];\n+\n+  \/* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n+   * It is easy to get rid of this optimization if necessary.\n+   *\/\n+  \/\/ Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n+\n+  \/* Do not waste too much time if we already have a good match: *\/\n+  if (s.prev_length >= s.good_match) {\n+    chain_length >>= 2;\n+  }\n+  \/* Do not look for matches beyond the end of the input. This is necessary\n+   * to make deflate deterministic.\n+   *\/\n+  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n+\n+  \/\/ Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n+\n+  do {\n+    \/\/ Assert(cur_match < s->strstart, \"no future\");\n+    match = cur_match;\n+\n+    \/* Skip to next match if the match length cannot increase\n+     * or if the match length is less than 2.  Note that the checks below\n+     * for insufficient lookahead only occur occasionally for performance\n+     * reasons.  Therefore uninitialized memory will be accessed, and\n+     * conditional jumps will be made that depend on those values.\n+     * However the length of the match is limited to the lookahead, so\n+     * the output of deflate is not affected by the uninitialized values.\n+     *\/\n+\n+    if (_win[match + best_len]     !== scan_end  ||\n+        _win[match + best_len - 1] !== scan_end1 ||\n+        _win[match]                !== _win[scan] ||\n+        _win[++match]              !== _win[scan + 1]) {\n+      continue;\n+    }\n+\n+    \/* The check at best_len-1 can be removed because it will be made\n+     * again later. (This heuristic is not always a win.)\n+     * It is not necessary to compare scan[2] and match[2] since they\n+     * are always equal when the other bytes match, given that\n+     * the hash keys are equal and that HASH_BITS >= 8.\n+     *\/\n+    scan += 2;\n+    match++;\n+    \/\/ Assert(*scan == *match, \"match[2]?\");\n+\n+    \/* We check for insufficient lookahead only every 8th comparison;\n+     * the 256th check will be made at strstart+258.\n+     *\/\n+    do {\n+      \/*jshint noempty:false*\/\n+    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n+             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n+             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n+             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n+             scan < strend);\n+\n+    \/\/ Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n+\n+    len = MAX_MATCH - (strend - scan);\n+    scan = strend - MAX_MATCH;\n+\n+    if (len > best_len) {\n+      s.match_start = cur_match;\n+      best_len = len;\n+      if (len >= nice_match) {\n+        break;\n+      }\n+      scan_end1  = _win[scan + best_len - 1];\n+      scan_end   = _win[scan + best_len];\n+    }\n+  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n+\n+  if (best_len <= s.lookahead) {\n+    return best_len;\n+  }\n+  return s.lookahead;\n+}\n+\n+\n+\/* ===========================================================================\n+ * Fill the window when the lookahead becomes insufficient.\n+ * Updates strstart and lookahead.\n+ *\n+ * IN assertion: lookahead < MIN_LOOKAHEAD\n+ * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n+ *    At least one byte has been read, or avail_in == 0; reads are\n+ *    performed for at least two bytes (required for the zip translate_eol\n+ *    option -- not supported here).\n+ *\/\n+function fill_window(s) {\n+  var _w_size = s.w_size;\n+  var p, n, m, more, str;\n+\n+  \/\/Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n+\n+  do {\n+    more = s.window_size - s.lookahead - s.strstart;\n+\n+    \/\/ JS ints have 32 bit, block below not needed\n+    \/* Deal with !@#$% 64K limit: *\/\n+    \/\/if (sizeof(int) <= 2) {\n+    \/\/    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n+    \/\/        more = wsize;\n+    \/\/\n+    \/\/  } else if (more == (unsigned)(-1)) {\n+    \/\/        \/* Very unlikely, but possible on 16 bit machine if\n+    \/\/         * strstart == 0 && lookahead == 1 (input done a byte at time)\n+    \/\/         *\/\n+    \/\/        more--;\n+    \/\/    }\n+    \/\/}\n+\n+\n+    \/* If the window is almost full and there is insufficient lookahead,\n+     * move the upper half to the lower one to make room in the upper half.\n+     *\/\n+    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n+\n+      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n+      s.match_start -= _w_size;\n+      s.strstart -= _w_size;\n+      \/* we now have strstart >= MAX_DIST *\/\n+      s.block_start -= _w_size;\n+\n+      \/* Slide the hash table (could be avoided with 32 bit values\n+       at the expense of memory usage). We slide even when level == 0\n+       to keep the hash table consistent if we switch back to level > 0\n+       later. (Using level 0 permanently is not an optimal usage of\n+       zlib, so we don't care about this pathological case.)\n+       *\/\n+\n+      n = s.hash_size;\n+      p = n;\n+      do {\n+        m = s.head[--p];\n+        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n+      } while (--n);\n+\n+      n = _w_size;\n+      p = n;\n+      do {\n+        m = s.prev[--p];\n+        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n+        \/* If n is not on any hash chain, prev[n] is garbage but\n+         * its value will never be used.\n+         *\/\n+      } while (--n);\n+\n+      more += _w_size;\n+    }\n+    if (s.strm.avail_in === 0) {\n+      break;\n+    }\n+\n+    \/* If there was no sliding:\n+     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n+     *    more == window_size - lookahead - strstart\n+     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n+     * => more >= window_size - 2*WSIZE + 2\n+     * In the BIG_MEM or MMAP case (not yet supported),\n+     *   window_size == input_size + MIN_LOOKAHEAD  &&\n+     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n+     * Otherwise, window_size == 2*WSIZE so more >= 2.\n+     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n+     *\/\n+    \/\/Assert(more >= 2, \"more < 2\");\n+    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n+    s.lookahead += n;\n+\n+    \/* Initialize the hash value now that we have some input: *\/\n+    if (s.lookahead + s.insert >= MIN_MATCH) {\n+      str = s.strstart - s.insert;\n+      s.ins_h = s.window[str];\n+\n+      \/* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); *\/\n+      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n+\/\/#if MIN_MATCH != 3\n+\/\/        Call update_hash() MIN_MATCH-3 more times\n+\/\/#endif\n+      while (s.insert) {\n+        \/* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); *\/\n+        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n+\n+        s.prev[str & s.w_mask] = s.head[s.ins_h];\n+        s.head[s.ins_h] = str;\n+        str++;\n+        s.insert--;\n+        if (s.lookahead + s.insert < MIN_MATCH) {\n+          break;\n+        }\n+      }\n+    }\n+    \/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n+     * but this is not important since only literal bytes will be emitted.\n+     *\/\n+\n+  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n+\n+  \/* If the WIN_INIT bytes after the end of the current data have never been\n+   * written, then zero those bytes in order to avoid memory check reports of\n+   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n+   * the longest match routines.  Update the high water mark for the next\n+   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n+   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n+   *\/\n+\/\/  if (s.high_water < s.window_size) {\n+\/\/    var curr = s.strstart + s.lookahead;\n+\/\/    var init = 0;\n+\/\/\n+\/\/    if (s.high_water < curr) {\n+\/\/      \/* Previous high water mark below current data -- zero WIN_INIT\n+\/\/       * bytes or up to end of window, whichever is less.\n+\/\/       *\/\n+\/\/      init = s.window_size - curr;\n+\/\/      if (init > WIN_INIT)\n+\/\/        init = WIN_INIT;\n+\/\/      zmemzero(s->window + curr, (unsigned)init);\n+\/\/      s->high_water = curr + init;\n+\/\/    }\n+\/\/    else if (s->high_water < (ulg)curr + WIN_INIT) {\n+\/\/      \/* High water mark at or above current data, but below current data\n+\/\/       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n+\/\/       * to end of window, whichever is less.\n+\/\/       *\/\n+\/\/      init = (ulg)curr + WIN_INIT - s->high_water;\n+\/\/      if (init > s->window_size - s->high_water)\n+\/\/        init = s->window_size - s->high_water;\n+\/\/      zmemzero(s->window + s->high_water, (unsigned)init);\n+\/\/      s->high_water += init;\n+\/\/    }\n+\/\/  }\n+\/\/\n+\/\/  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n+\/\/    \"not enough room for search\");\n+}\n+\n+\/* ===========================================================================\n+ * Copy without compression as much as possible from the input stream, return\n+ * the current block state.\n+ * This function does not insert new strings in the dictionary since\n+ * uncompressible data is probably not useful. This function is used\n+ * only for the level=0 compression option.\n+ * NOTE: this function should be optimized to avoid extra copying from\n+ * window to pending_buf.\n+ *\/\n+function deflate_stored(s, flush) {\n+  \/* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n+   * to pending_buf_size, and each stored block has a 5 byte header:\n+   *\/\n+  var max_block_size = 0xffff;\n+\n+  if (max_block_size > s.pending_buf_size - 5) {\n+    max_block_size = s.pending_buf_size - 5;\n+  }\n+\n+  \/* Copy as much as possible from input to output: *\/\n+  for (;;) {\n+    \/* Fill the window as much as possible: *\/\n+    if (s.lookahead <= 1) {\n+\n+      \/\/Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n+      \/\/  s->block_start >= (long)s->w_size, \"slide too late\");\n+\/\/      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n+\/\/        s.block_start >= s.w_size)) {\n+\/\/        throw  new Error(\"slide too late\");\n+\/\/      }\n+\n+      fill_window(s);\n+      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n+        return BS_NEED_MORE;\n+      }\n+\n+      if (s.lookahead === 0) {\n+        break;\n+      }\n+      \/* flush the current block *\/\n+    }\n+    \/\/Assert(s->block_start >= 0L, \"block gone\");\n+\/\/    if (s.block_start < 0) throw new Error(\"block gone\");\n+\n+    s.strstart += s.lookahead;\n+    s.lookahead = 0;\n+\n+    \/* Emit a stored block if pending_buf will be full: *\/\n+    var max_start = s.block_start + max_block_size;\n+\n+    if (s.strstart === 0 || s.strstart >= max_start) {\n+      \/* strstart == 0 is possible when wraparound on 16-bit machine *\/\n+      s.lookahead = s.strstart - max_start;\n+      s.strstart = max_start;\n+      \/*** FLUSH_BLOCK(s, 0); ***\/\n+      flush_block_only(s, false);\n+      if (s.strm.avail_out === 0) {\n+        return BS_NEED_MORE;\n+      }\n+      \/***\/\n+\n+\n+    }\n+    \/* Flush if we may have to slide, otherwise block_start may become\n+     * negative and the data will be gone:\n+     *\/\n+    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n+      \/*** FLUSH_BLOCK(s, 0); ***\/\n+      flush_block_only(s, false);\n+      if (s.strm.avail_out === 0) {\n+        return BS_NEED_MORE;\n+      }\n+      \/***\/\n+    }\n+  }\n+\n+  s.insert = 0;\n+\n+  if (flush === Z_FINISH) {\n+    \/*** FLUSH_BLOCK(s, 1); ***\/\n+    flush_block_only(s, true);\n+    if (s.strm.avail_out === 0) {\n+      return BS_FINISH_STARTED;\n+    }\n+    \/***\/\n+    return BS_FINISH_DONE;\n+  }\n+\n+  if (s.strstart > s.block_start) {\n+    \/*** FLUSH_BLOCK(s, 0); ***\/\n+    flush_block_only(s, false);\n+    if (s.strm.avail_out === 0) {\n+      return BS_NEED_MORE;\n+    }\n+    \/***\/\n+  }\n+\n+  return BS_NEED_MORE;\n+}\n+\n+\/* ===========================================================================\n+ * Compress as much as possible from the input stream, return the current\n+ * block state.\n+ * This function does not perform lazy evaluation of matches and inserts\n+ * new strings in the dictionary only for unmatched strings or for short\n+ * matches. It is used only for the fast compression options.\n+ *\/\n+function deflate_fast(s, flush) {\n+  var hash_head;        \/* head of the hash chain *\/\n+  var bflush;           \/* set if current block must be flushed *\/\n+\n+  for (;;) {\n+    \/* Make sure that we always have enough lookahead, except\n+     * at the end of the input file. We need MAX_MATCH bytes\n+     * for the next match, plus MIN_MATCH bytes to insert the\n+     * string following the next match.\n+     *\/\n+    if (s.lookahead < MIN_LOOKAHEAD) {\n+      fill_window(s);\n+      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n+        return BS_NEED_MORE;\n+      }\n+      if (s.lookahead === 0) {\n+        break; \/* flush the current block *\/\n+      }\n+    }\n+\n+    \/* Insert the string window[strstart .. strstart+2] in the\n+     * dictionary, and set hash_head to the head of the hash chain:\n+     *\/\n+    hash_head = 0\/*NIL*\/;\n+    if (s.lookahead >= MIN_MATCH) {\n+      \/*** INSERT_STRING(s, s.strstart, hash_head); ***\/\n+      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n+      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n+      s.head[s.ins_h] = s.strstart;\n+      \/***\/\n+    }\n+\n+    \/* Find the longest match, discarding those <= prev_length.\n+     * At this point we have always match_length < MIN_MATCH\n+     *\/\n+    if (hash_head !== 0\/*NIL*\/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n+      \/* To simplify the code, we prevent matches with the string\n+       * of window index 0 (in particular we have to avoid a match\n+       * of the string with itself at the start of the input file).\n+       *\/\n+      s.match_length = longest_match(s, hash_head);\n+      \/* longest_match() sets match_start *\/\n+    }\n+    if (s.match_length >= MIN_MATCH) {\n+      \/\/ check_match(s, s.strstart, s.match_start, s.match_length); \/\/ for debug only\n+\n+      \/*** _tr_tally_dist(s, s.strstart - s.match_start,\n+                     s.match_length - MIN_MATCH, bflush); ***\/\n+      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n+\n+      s.lookahead -= s.match_length;\n+\n+      \/* Insert new strings in the hash table only if the match length\n+       * is not too large. This saves time but degrades compression.\n+       *\/\n+      if (s.match_length <= s.max_lazy_match\/*max_insert_length*\/ && s.lookahead >= MIN_MATCH) {\n+        s.match_length--; \/* string at strstart already in table *\/\n+        do {\n+          s.strstart++;\n+          \/*** INSERT_STRING(s, s.strstart, hash_head); ***\/\n+          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n+          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n+          s.head[s.ins_h] = s.strstart;\n+          \/***\/\n+          \/* strstart never exceeds WSIZE-MAX_MATCH, so there are\n+           * always MIN_MATCH bytes ahead.\n+           *\/\n+        } while (--s.match_length !== 0);\n+        s.strstart++;\n+      } else\n+      {\n+        s.strstart += s.match_length;\n+        s.match_length = 0;\n+        s.ins_h = s.window[s.strstart];\n+        \/* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); *\/\n+        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n+\n+\/\/#if MIN_MATCH != 3\n+\/\/                Call UPDATE_HASH() MIN_MATCH-3 more times\n+\/\/#endif\n+        \/* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n+         * matter since it will be recomputed at next deflate call.\n+         *\/\n+      }\n+    } else {\n+      \/* No match, output a literal byte *\/\n+      \/\/Tracevv((stderr,\"%c\", s.window[s.strstart]));\n+      \/*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***\/\n+      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n+\n+      s.lookahead--;\n+      s.strstart++;\n+    }\n+    if (bflush) {\n+      \/*** FLUSH_BLOCK(s, 0); ***\/\n+      flush_block_only(s, false);\n+      if (s.strm.avail_out === 0) {\n+        return BS_NEED_MORE;\n+      }\n+      \/***\/\n+    }\n+  }\n+  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n+  if (flush === Z_FINISH) {\n+    \/*** FLUSH_BLOCK(s, 1); ***\/\n+    flush_block_only(s, true);\n+    if (s.strm.avail_out === 0) {\n+      return BS_FINISH_STARTED;\n+    }\n+    \/***\/\n+    return BS_FINISH_DONE;\n+  }\n+  if (s.last_lit) {\n+    \/*** FLUSH_BLOCK(s, 0); ***\/\n+    flush_block_only(s, false);\n+    if (s.strm.avail_out === 0) {\n+      return BS_NEED_MORE;\n+    }\n+    \/***\/\n+  }\n+  return BS_BLOCK_DONE;\n+}\n+\n+\/* ===========================================================================\n+ * Same as above, but achieves better compression. We use a lazy\n+ * evaluation for matches: a match is finally adopted only if there is\n+ * no better match at the next window position.\n+ *\/\n+function deflate_slow(s, flush) {\n+  var hash_head;          \/* head of hash chain *\/\n+  var bflush;              \/* set if current block must be flushed *\/\n+\n+  var max_insert;\n+\n+  \/* Process the input block. *\/\n+  for (;;) {\n+    \/* Make sure that we always have enough lookahead, except\n+     * at the end of the input file. We need MAX_MATCH bytes\n+     * for the next match, plus MIN_MATCH bytes to insert the\n+     * string following the next match.\n+     *\/\n+    if (s.lookahead < MIN_LOOKAHEAD) {\n+      fill_window(s);\n+      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n+        return BS_NEED_MORE;\n+      }\n+      if (s.lookahead === 0) { break; } \/* flush the current block *\/\n+    }\n+\n+    \/* Insert the string window[strstart .. strstart+2] in the\n+     * dictionary, and set hash_head to the head of the hash chain:\n+     *\/\n+    hash_head = 0\/*NIL*\/;\n+    if (s.lookahead >= MIN_MATCH) {\n+      \/*** INSERT_STRING(s, s.strstart, hash_head); ***\/\n+      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n+      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n+      s.head[s.ins_h] = s.strstart;\n+      \/***\/\n+    }\n+\n+    \/* Find the longest match, discarding those <= prev_length.\n+     *\/\n+    s.prev_length = s.match_length;\n+    s.prev_match = s.match_start;\n+    s.match_length = MIN_MATCH - 1;\n+\n+    if (hash_head !== 0\/*NIL*\/ && s.prev_length < s.max_lazy_match &&\n+        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)\/*MAX_DIST(s)*\/) {\n+      \/* To simplify the code, we prevent matches with the string\n+       * of window index 0 (in particular we have to avoid a match\n+       * of the string with itself at the start of the input file).\n+       *\/\n+      s.match_length = longest_match(s, hash_head);\n+      \/* longest_match() sets match_start *\/\n+\n+      if (s.match_length <= 5 &&\n+         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096\/*TOO_FAR*\/))) {\n+\n+        \/* If prev_match is also MIN_MATCH, match_start is garbage\n+         * but we will ignore the current match anyway.\n+         *\/\n+        s.match_length = MIN_MATCH - 1;\n+      }\n+    }\n+    \/* If there was a match at the previous step and the current\n+     * match is not better, output the previous match:\n+     *\/\n+    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n+      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n+      \/* Do not insert strings in hash table beyond this. *\/\n+\n+      \/\/check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n+\n+      \/***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n+                     s.prev_length - MIN_MATCH, bflush);***\/\n+      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n+      \/* Insert in hash table all strings up to the end of the match.\n+       * strstart-1 and strstart are already inserted. If there is not\n+       * enough lookahead, the last two strings are not inserted in\n+       * the hash table.\n+       *\/\n+      s.lookahead -= s.prev_length - 1;\n+      s.prev_length -= 2;\n+      do {\n+        if (++s.strstart <= max_insert) {\n+          \/*** INSERT_STRING(s, s.strstart, hash_head); ***\/\n+          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n+          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n+          s.head[s.ins_h] = s.strstart;\n+          \/***\/\n+        }\n+      } while (--s.prev_length !== 0);\n+      s.match_available = 0;\n+      s.match_length = MIN_MATCH - 1;\n+      s.strstart++;\n+\n+      if (bflush) {\n+        \/*** FLUSH_BLOCK(s, 0); ***\/\n+        flush_block_only(s, false);\n+        if (s.strm.avail_out === 0) {\n+          return BS_NEED_MORE;\n+        }\n+        \/***\/\n+      }\n+\n+    } else if (s.match_available) {\n+      \/* If there was no match at the previous position, output a\n+       * single literal. If there was a match but the current match\n+       * is longer, truncate the previous match to a single literal.\n+       *\/\n+      \/\/Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n+      \/*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***\/\n+      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n+\n+      if (bflush) {\n+        \/*** FLUSH_BLOCK_ONLY(s, 0) ***\/\n+        flush_block_only(s, false);\n+        \/***\/\n+      }\n+      s.strstart++;\n+      s.lookahead--;\n+      if (s.strm.avail_out === 0) {\n+        return BS_NEED_MORE;\n+      }\n+    } else {\n+      \/* There is no previous match to compare with, wait for\n+       * the next step to decide.\n+       *\/\n+      s.match_available = 1;\n+      s.strstart++;\n+      s.lookahead--;\n+    }\n+  }\n+  \/\/Assert (flush != Z_NO_FLUSH, \"no flush?\");\n+  if (s.match_available) {\n+    \/\/Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n+    \/*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***\/\n+    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n+\n+    s.match_available = 0;\n+  }\n+  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n+  if (flush === Z_FINISH) {\n+    \/*** FLUSH_BLOCK(s, 1); ***\/\n+    flush_block_only(s, true);\n+    if (s.strm.avail_out === 0) {\n+      return BS_FINISH_STARTED;\n+    }\n+    \/***\/\n+    return BS_FINISH_DONE;\n+  }\n+  if (s.last_lit) {\n+    \/*** FLUSH_BLOCK(s, 0); ***\/\n+    flush_block_only(s, false);\n+    if (s.strm.avail_out === 0) {\n+      return BS_NEED_MORE;\n+    }\n+    \/***\/\n+  }\n+\n+  return BS_BLOCK_DONE;\n+}\n+\n+\n+\/* ===========================================================================\n+ * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n+ * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n+ * deflate switches away from Z_RLE.)\n+ *\/\n+function deflate_rle(s, flush) {\n+  var bflush;            \/* set if current block must be flushed *\/\n+  var prev;              \/* byte at distance one to match *\/\n+  var scan, strend;      \/* scan goes up to strend for length of run *\/\n+\n+  var _win = s.window;\n+\n+  for (;;) {\n+    \/* Make sure that we always have enough lookahead, except\n+     * at the end of the input file. We need MAX_MATCH bytes\n+     * for the longest run, plus one for the unrolled loop.\n+     *\/\n+    if (s.lookahead <= MAX_MATCH) {\n+      fill_window(s);\n+      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n+        return BS_NEED_MORE;\n+      }\n+      if (s.lookahead === 0) { break; } \/* flush the current block *\/\n+    }\n+\n+    \/* See how many times the previous byte repeats *\/\n+    s.match_length = 0;\n+    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n+      scan = s.strstart - 1;\n+      prev = _win[scan];\n+      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n+        strend = s.strstart + MAX_MATCH;\n+        do {\n+          \/*jshint noempty:false*\/\n+        } while (prev === _win[++scan] && prev === _win[++scan] &&\n+                 prev === _win[++scan] && prev === _win[++scan] &&\n+                 prev === _win[++scan] && prev === _win[++scan] &&\n+                 prev === _win[++scan] && prev === _win[++scan] &&\n+                 scan < strend);\n+        s.match_length = MAX_MATCH - (strend - scan);\n+        if (s.match_length > s.lookahead) {\n+          s.match_length = s.lookahead;\n+        }\n+      }\n+      \/\/Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n+    }\n+\n+    \/* Emit match if have run of MIN_MATCH or longer, else emit literal *\/\n+    if (s.match_length >= MIN_MATCH) {\n+      \/\/check_match(s, s.strstart, s.strstart - 1, s.match_length);\n+\n+      \/*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***\/\n+      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n+\n+      s.lookahead -= s.match_length;\n+      s.strstart += s.match_length;\n+      s.match_length = 0;\n+    } else {\n+      \/* No match, output a literal byte *\/\n+      \/\/Tracevv((stderr,\"%c\", s->window[s->strstart]));\n+      \/*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***\/\n+      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n+\n+      s.lookahead--;\n+      s.strstart++;\n+    }\n+    if (bflush) {\n+      \/*** FLUSH_BLOCK(s, 0); ***\/\n+      flush_block_only(s, false);\n+      if (s.strm.avail_out === 0) {\n+        return BS_NEED_MORE;\n+      }\n+      \/***\/\n+    }\n+  }\n+  s.insert = 0;\n+  if (flush === Z_FINISH) {\n+    \/*** FLUSH_BLOCK(s, 1); ***\/\n+    flush_block_only(s, true);\n+    if (s.strm.avail_out === 0) {\n+      return BS_FINISH_STARTED;\n+    }\n+    \/***\/\n+    return BS_FINISH_DONE;\n+  }\n+  if (s.last_lit) {\n+    \/*** FLUSH_BLOCK(s, 0); ***\/\n+    flush_block_only(s, false);\n+    if (s.strm.avail_out === 0) {\n+      return BS_NEED_MORE;\n+    }\n+    \/***\/\n+  }\n+  return BS_BLOCK_DONE;\n+}\n+\n+\/* ===========================================================================\n+ * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n+ * (It will be regenerated if this run of deflate switches away from Huffman.)\n+ *\/\n+function deflate_huff(s, flush) {\n+  var bflush;             \/* set if current block must be flushed *\/\n+\n+  for (;;) {\n+    \/* Make sure that we have a literal to write. *\/\n+    if (s.lookahead === 0) {\n+      fill_window(s);\n+      if (s.lookahead === 0) {\n+        if (flush === Z_NO_FLUSH) {\n+          return BS_NEED_MORE;\n+        }\n+        break;      \/* flush the current block *\/\n+      }\n+    }\n+\n+    \/* Output a literal byte *\/\n+    s.match_length = 0;\n+    \/\/Tracevv((stderr,\"%c\", s->window[s->strstart]));\n+    \/*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***\/\n+    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n+    s.lookahead--;\n+    s.strstart++;\n+    if (bflush) {\n+      \/*** FLUSH_BLOCK(s, 0); ***\/\n+      flush_block_only(s, false);\n+      if (s.strm.avail_out === 0) {\n+        return BS_NEED_MORE;\n+      }\n+      \/***\/\n+    }\n+  }\n+  s.insert = 0;\n+  if (flush === Z_FINISH) {\n+    \/*** FLUSH_BLOCK(s, 1); ***\/\n+    flush_block_only(s, true);\n+    if (s.strm.avail_out === 0) {\n+      return BS_FINISH_STARTED;\n+    }\n+    \/***\/\n+    return BS_FINISH_DONE;\n+  }\n+  if (s.last_lit) {\n+    \/*** FLUSH_BLOCK(s, 0); ***\/\n+    flush_block_only(s, false);\n+    if (s.strm.avail_out === 0) {\n+      return BS_NEED_MORE;\n+    }\n+    \/***\/\n+  }\n+  return BS_BLOCK_DONE;\n+}\n+\n+\/* Values for max_lazy_match, good_match and max_chain_length, depending on\n+ * the desired pack level (0..9). The values given below have been tuned to\n+ * exclude worst case performance for pathological files. Better values may be\n+ * found for specific files.\n+ *\/\n+function Config(good_length, max_lazy, nice_length, max_chain, func) {\n+  this.good_length = good_length;\n+  this.max_lazy = max_lazy;\n+  this.nice_length = nice_length;\n+  this.max_chain = max_chain;\n+  this.func = func;\n+}\n+\n+var configuration_table;\n+\n+configuration_table = [\n+  \/*      good lazy nice chain *\/\n+  new Config(0, 0, 0, 0, deflate_stored),          \/* 0 store only *\/\n+  new Config(4, 4, 8, 4, deflate_fast),            \/* 1 max speed, no lazy matches *\/\n+  new Config(4, 5, 16, 8, deflate_fast),           \/* 2 *\/\n+  new Config(4, 6, 32, 32, deflate_fast),          \/* 3 *\/\n+\n+  new Config(4, 4, 16, 16, deflate_slow),          \/* 4 lazy matches *\/\n+  new Config(8, 16, 32, 32, deflate_slow),         \/* 5 *\/\n+  new Config(8, 16, 128, 128, deflate_slow),       \/* 6 *\/\n+  new Config(8, 32, 128, 256, deflate_slow),       \/* 7 *\/\n+  new Config(32, 128, 258, 1024, deflate_slow),    \/* 8 *\/\n+  new Config(32, 258, 258, 4096, deflate_slow)     \/* 9 max compression *\/\n+];\n+\n+\n+\/* ===========================================================================\n+ * Initialize the \"longest match\" routines for a new zlib stream\n+ *\/\n+function lm_init(s) {\n+  s.window_size = 2 * s.w_size;\n+\n+  \/*** CLEAR_HASH(s); ***\/\n+  zero(s.head); \/\/ Fill with NIL (= 0);\n+\n+  \/* Set the default configuration parameters:\n+   *\/\n+  s.max_lazy_match = configuration_table[s.level].max_lazy;\n+  s.good_match = configuration_table[s.level].good_length;\n+  s.nice_match = configuration_table[s.level].nice_length;\n+  s.max_chain_length = configuration_table[s.level].max_chain;\n+\n+  s.strstart = 0;\n+  s.block_start = 0;\n+  s.lookahead = 0;\n+  s.insert = 0;\n+  s.match_length = s.prev_length = MIN_MATCH - 1;\n+  s.match_available = 0;\n+  s.ins_h = 0;\n+}\n+\n+\n+function DeflateState() {\n+  this.strm = null;            \/* pointer back to this zlib stream *\/\n+  this.status = 0;            \/* as the name implies *\/\n+  this.pending_buf = null;      \/* output still pending *\/\n+  this.pending_buf_size = 0;  \/* size of pending_buf *\/\n+  this.pending_out = 0;       \/* next pending byte to output to the stream *\/\n+  this.pending = 0;           \/* nb of bytes in the pending buffer *\/\n+  this.wrap = 0;              \/* bit 0 true for zlib, bit 1 true for gzip *\/\n+  this.gzhead = null;         \/* gzip header information to write *\/\n+  this.gzindex = 0;           \/* where in extra, name, or comment *\/\n+  this.method = Z_DEFLATED; \/* can only be DEFLATED *\/\n+  this.last_flush = -1;   \/* value of flush param for previous deflate call *\/\n+\n+  this.w_size = 0;  \/* LZ77 window size (32K by default) *\/\n+  this.w_bits = 0;  \/* log2(w_size)  (8..16) *\/\n+  this.w_mask = 0;  \/* w_size - 1 *\/\n+\n+  this.window = null;\n+  \/* Sliding window. Input bytes are read into the second half of the window,\n+   * and move to the first half later to keep a dictionary of at least wSize\n+   * bytes. With this organization, matches are limited to a distance of\n+   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n+   * performed with a length multiple of the block size.\n+   *\/\n+\n+  this.window_size = 0;\n+  \/* Actual size of window: 2*wSize, except when the user input buffer\n+   * is directly used as sliding window.\n+   *\/\n+\n+  this.prev = null;\n+  \/* Link to older string with same hash index. To limit the size of this\n+   * array to 64K, this link is maintained only for the last 32K strings.\n+   * An index in this array is thus a window index modulo 32K.\n+   *\/\n+\n+  this.head = null;   \/* Heads of the hash chains or NIL. *\/\n+\n+  this.ins_h = 0;       \/* hash index of string to be inserted *\/\n+  this.hash_size = 0;   \/* number of elements in hash table *\/\n+  this.hash_bits = 0;   \/* log2(hash_size) *\/\n+  this.hash_mask = 0;   \/* hash_size-1 *\/\n+\n+  this.hash_shift = 0;\n+  \/* Number of bits by which ins_h must be shifted at each input\n+   * step. It must be such that after MIN_MATCH steps, the oldest\n+   * byte no longer takes part in the hash key, that is:\n+   *   hash_shift * MIN_MATCH >= hash_bits\n+   *\/\n+\n+  this.block_start = 0;\n+  \/* Window position at the beginning of the current output block. Gets\n+   * negative when the window is moved backwards.\n+   *\/\n+\n+  this.match_length = 0;      \/* length of best match *\/\n+  this.prev_match = 0;        \/* previous match *\/\n+  this.match_available = 0;   \/* set if previous match exists *\/\n+  this.strstart = 0;          \/* start of string to insert *\/\n+  this.match_start = 0;       \/* start of matching string *\/\n+  this.lookahead = 0;         \/* number of valid bytes ahead in window *\/\n+\n+  this.prev_length = 0;\n+  \/* Length of the best match at previous step. Matches not greater than this\n+   * are discarded. This is used in the lazy match evaluation.\n+   *\/\n+\n+  this.max_chain_length = 0;\n+  \/* To speed up deflation, hash chains are never searched beyond this\n+   * length.  A higher limit improves compression ratio but degrades the\n+   * speed.\n+   *\/\n+\n+  this.max_lazy_match = 0;\n+  \/* Attempt to find a better match only when the current match is strictly\n+   * smaller than this value. This mechanism is used only for compression\n+   * levels >= 4.\n+   *\/\n+  \/\/ That's alias to max_lazy_match, don't use directly\n+  \/\/this.max_insert_length = 0;\n+  \/* Insert new strings in the hash table only if the match length is not\n+   * greater than this length. This saves time but degrades compression.\n+   * max_insert_length is used only for compression levels <= 3.\n+   *\/\n+\n+  this.level = 0;     \/* compression level (1..9) *\/\n+  this.strategy = 0;  \/* favor or force Huffman coding*\/\n+\n+  this.good_match = 0;\n+  \/* Use a faster search when the previous match is longer than this *\/\n+\n+  this.nice_match = 0; \/* Stop searching when current match exceeds this *\/\n+\n+              \/* used by trees.c: *\/\n+\n+  \/* Didn't use ct_data typedef below to suppress compiler warning *\/\n+\n+  \/\/ struct ct_data_s dyn_ltree[HEAP_SIZE];   \/* literal and length tree *\/\n+  \/\/ struct ct_data_s dyn_dtree[2*D_CODES+1]; \/* distance tree *\/\n+  \/\/ struct ct_data_s bl_tree[2*BL_CODES+1];  \/* Huffman tree for bit lengths *\/\n+\n+  \/\/ Use flat array of DOUBLE size, with interleaved fata,\n+  \/\/ because JS does not support effective\n+  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n+  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n+  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n+  zero(this.dyn_ltree);\n+  zero(this.dyn_dtree);\n+  zero(this.bl_tree);\n+\n+  this.l_desc   = null;         \/* desc. for literal tree *\/\n+  this.d_desc   = null;         \/* desc. for distance tree *\/\n+  this.bl_desc  = null;         \/* desc. for bit length tree *\/\n+\n+  \/\/ush bl_count[MAX_BITS+1];\n+  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n+  \/* number of codes at each bit length for an optimal tree *\/\n+\n+  \/\/int heap[2*L_CODES+1];      \/* heap used to build the Huffman trees *\/\n+  this.heap = new utils.Buf16(2 * L_CODES + 1);  \/* heap used to build the Huffman trees *\/\n+  zero(this.heap);\n+\n+  this.heap_len = 0;               \/* number of elements in the heap *\/\n+  this.heap_max = 0;               \/* element of largest frequency *\/\n+  \/* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n+   * The same heap array is used to build all trees.\n+   *\/\n+\n+  this.depth = new utils.Buf16(2 * L_CODES + 1); \/\/uch depth[2*L_CODES+1];\n+  zero(this.depth);\n+  \/* Depth of each subtree used as tie breaker for trees of equal frequency\n+   *\/\n+\n+  this.l_buf = 0;          \/* buffer index for literals or lengths *\/\n+\n+  this.lit_bufsize = 0;\n+  \/* Size of match buffer for literals\/lengths.  There are 4 reasons for\n+   * limiting lit_bufsize to 64K:\n+   *   - frequencies can be kept in 16 bit counters\n+   *   - if compression is not successful for the first block, all input\n+   *     data is still in the window so we can still emit a stored block even\n+   *     when input comes from standard input.  (This can also be done for\n+   *     all blocks if lit_bufsize is not greater than 32K.)\n+   *   - if compression is not successful for a file smaller than 64K, we can\n+   *     even emit a stored file instead of a stored block (saving 5 bytes).\n+   *     This is applicable only for zip (not gzip or zlib).\n+   *   - creating new Huffman trees less frequently may not provide fast\n+   *     adaptation to changes in the input data statistics. (Take for\n+   *     example a binary file with poorly compressible code followed by\n+   *     a highly compressible string table.) Smaller buffer sizes give\n+   *     fast adaptation but have of course the overhead of transmitting\n+   *     trees more frequently.\n+   *   - I can't count above 4\n+   *\/\n+\n+  this.last_lit = 0;      \/* running index in l_buf *\/\n+\n+  this.d_buf = 0;\n+  \/* Buffer index for distances. To simplify the code, d_buf and l_buf have\n+   * the same number of elements. To use different lengths, an extra flag\n+   * array would be necessary.\n+   *\/\n+\n+  this.opt_len = 0;       \/* bit length of current block with optimal trees *\/\n+  this.static_len = 0;    \/* bit length of current block with static trees *\/\n+  this.matches = 0;       \/* number of string matches in current block *\/\n+  this.insert = 0;        \/* bytes at end of window left to insert *\/\n+\n+\n+  this.bi_buf = 0;\n+  \/* Output buffer. bits are inserted starting at the bottom (least\n+   * significant bits).\n+   *\/\n+  this.bi_valid = 0;\n+  \/* Number of valid bits in bi_buf.  All bits above the last valid bit\n+   * are always zero.\n+   *\/\n+\n+  \/\/ Used for window memory init. We safely ignore it for JS. That makes\n+  \/\/ sense only for pointers and memory check tools.\n+  \/\/this.high_water = 0;\n+  \/* High water mark offset in window for initialized bytes -- bytes above\n+   * this are set to zero in order to avoid memory check warnings when\n+   * longest match routines access bytes past the input.  This is then\n+   * updated to the new high water mark.\n+   *\/\n+}\n+\n+\n+function deflateResetKeep(strm) {\n+  var s;\n+\n+  if (!strm || !strm.state) {\n+    return err(strm, Z_STREAM_ERROR);\n+  }\n+\n+  strm.total_in = strm.total_out = 0;\n+  strm.data_type = Z_UNKNOWN;\n+\n+  s = strm.state;\n+  s.pending = 0;\n+  s.pending_out = 0;\n+\n+  if (s.wrap < 0) {\n+    s.wrap = -s.wrap;\n+    \/* was made negative by deflate(..., Z_FINISH); *\/\n+  }\n+  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n+  strm.adler = (s.wrap === 2) ?\n+    0  \/\/ crc32(0, Z_NULL, 0)\n+  :\n+    1; \/\/ adler32(0, Z_NULL, 0)\n+  s.last_flush = Z_NO_FLUSH;\n+  trees._tr_init(s);\n+  return Z_OK;\n+}\n+\n+\n+function deflateReset(strm) {\n+  var ret = deflateResetKeep(strm);\n+  if (ret === Z_OK) {\n+    lm_init(strm.state);\n+  }\n+  return ret;\n+}\n+\n+\n+function deflateSetHeader(strm, head) {\n+  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n+  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n+  strm.state.gzhead = head;\n+  return Z_OK;\n+}\n+\n+\n+function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n+  if (!strm) { \/\/ === Z_NULL\n+    return Z_STREAM_ERROR;\n+  }\n+  var wrap = 1;\n+\n+  if (level === Z_DEFAULT_COMPRESSION) {\n+    level = 6;\n+  }\n+\n+  if (windowBits < 0) { \/* suppress zlib wrapper *\/\n+    wrap = 0;\n+    windowBits = -windowBits;\n+  }\n+\n+  else if (windowBits > 15) {\n+    wrap = 2;           \/* write gzip wrapper instead *\/\n+    windowBits -= 16;\n+  }\n+\n+\n+  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n+    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n+    strategy < 0 || strategy > Z_FIXED) {\n+    return err(strm, Z_STREAM_ERROR);\n+  }\n+\n+\n+  if (windowBits === 8) {\n+    windowBits = 9;\n+  }\n+  \/* until 256-byte window bug fixed *\/\n+\n+  var s = new DeflateState();\n+\n+  strm.state = s;\n+  s.strm = strm;\n+\n+  s.wrap = wrap;\n+  s.gzhead = null;\n+  s.w_bits = windowBits;\n+  s.w_size = 1 << s.w_bits;\n+  s.w_mask = s.w_size - 1;\n+\n+  s.hash_bits = memLevel + 7;\n+  s.hash_size = 1 << s.hash_bits;\n+  s.hash_mask = s.hash_size - 1;\n+  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) \/ MIN_MATCH);\n+\n+  s.window = new utils.Buf8(s.w_size * 2);\n+  s.head = new utils.Buf16(s.hash_size);\n+  s.prev = new utils.Buf16(s.w_size);\n+\n+  \/\/ Don't need mem init magic for JS.\n+  \/\/s.high_water = 0;  \/* nothing written to s->window yet *\/\n+\n+  s.lit_bufsize = 1 << (memLevel + 6); \/* 16K elements by default *\/\n+\n+  s.pending_buf_size = s.lit_bufsize * 4;\n+\n+  \/\/overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n+  \/\/s->pending_buf = (uchf *) overlay;\n+  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n+\n+  \/\/ It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n+  \/\/s->d_buf = overlay + s->lit_bufsize\/sizeof(ush);\n+  s.d_buf = 1 * s.lit_bufsize;\n+\n+  \/\/s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n+  s.l_buf = (1 + 2) * s.lit_bufsize;\n+\n+  s.level = level;\n+  s.strategy = strategy;\n+  s.method = method;\n+\n+  return deflateReset(strm);\n+}\n+\n+function deflateInit(strm, level) {\n+  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n+}\n+\n+\n+function deflate(strm, flush) {\n+  var old_flush, s;\n+  var beg, val; \/\/ for gzip header write only\n+\n+  if (!strm || !strm.state ||\n+    flush > Z_BLOCK || flush < 0) {\n+    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n+  }\n+\n+  s = strm.state;\n+\n+  if (!strm.output ||\n+      (!strm.input && strm.avail_in !== 0) ||\n+      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n+    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n+  }\n+\n+  s.strm = strm; \/* just in case *\/\n+  old_flush = s.last_flush;\n+  s.last_flush = flush;\n+\n+  \/* Write the header *\/\n+  if (s.status === INIT_STATE) {\n+\n+    if (s.wrap === 2) { \/\/ GZIP header\n+      strm.adler = 0;  \/\/crc32(0L, Z_NULL, 0);\n+      put_byte(s, 31);\n+      put_byte(s, 139);\n+      put_byte(s, 8);\n+      if (!s.gzhead) { \/\/ s->gzhead == Z_NULL\n+        put_byte(s, 0);\n+        put_byte(s, 0);\n+        put_byte(s, 0);\n+        put_byte(s, 0);\n+        put_byte(s, 0);\n+        put_byte(s, s.level === 9 ? 2 :\n+                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n+                     4 : 0));\n+        put_byte(s, OS_CODE);\n+        s.status = BUSY_STATE;\n+      }\n+      else {\n+        put_byte(s, (s.gzhead.text ? 1 : 0) +\n+                    (s.gzhead.hcrc ? 2 : 0) +\n+                    (!s.gzhead.extra ? 0 : 4) +\n+                    (!s.gzhead.name ? 0 : 8) +\n+                    (!s.gzhead.comment ? 0 : 16)\n+                );\n+        put_byte(s, s.gzhead.time & 0xff);\n+        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n+        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n+        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n+        put_byte(s, s.level === 9 ? 2 :\n+                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n+                     4 : 0));\n+        put_byte(s, s.gzhead.os & 0xff);\n+        if (s.gzhead.extra && s.gzhead.extra.length) {\n+          put_byte(s, s.gzhead.extra.length & 0xff);\n+          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n+        }\n+        if (s.gzhead.hcrc) {\n+          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n+        }\n+        s.gzindex = 0;\n+        s.status = EXTRA_STATE;\n+      }\n+    }\n+    else \/\/ DEFLATE header\n+    {\n+      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n+      var level_flags = -1;\n+\n+      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n+        level_flags = 0;\n+      } else if (s.level < 6) {\n+        level_flags = 1;\n+      } else if (s.level === 6) {\n+        level_flags = 2;\n+      } else {\n+        level_flags = 3;\n+      }\n+      header |= (level_flags << 6);\n+      if (s.strstart !== 0) { header |= PRESET_DICT; }\n+      header += 31 - (header % 31);\n+\n+      s.status = BUSY_STATE;\n+      putShortMSB(s, header);\n+\n+      \/* Save the adler32 of the preset dictionary: *\/\n+      if (s.strstart !== 0) {\n+        putShortMSB(s, strm.adler >>> 16);\n+        putShortMSB(s, strm.adler & 0xffff);\n+      }\n+      strm.adler = 1; \/\/ adler32(0L, Z_NULL, 0);\n+    }\n+  }\n+\n+\/\/#ifdef GZIP\n+  if (s.status === EXTRA_STATE) {\n+    if (s.gzhead.extra\/* != Z_NULL*\/) {\n+      beg = s.pending;  \/* start of bytes to update crc *\/\n+\n+      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n+        if (s.pending === s.pending_buf_size) {\n+          if (s.gzhead.hcrc && s.pending > beg) {\n+            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n+          }\n+          flush_pending(strm);\n+          beg = s.pending;\n+          if (s.pending === s.pending_buf_size) {\n+            break;\n+          }\n+        }\n+        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n+        s.gzindex++;\n+      }\n+      if (s.gzhead.hcrc && s.pending > beg) {\n+        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n+      }\n+      if (s.gzindex === s.gzhead.extra.length) {\n+        s.gzindex = 0;\n+        s.status = NAME_STATE;\n+      }\n+    }\n+    else {\n+      s.status = NAME_STATE;\n+    }\n+  }\n+  if (s.status === NAME_STATE) {\n+    if (s.gzhead.name\/* != Z_NULL*\/) {\n+      beg = s.pending;  \/* start of bytes to update crc *\/\n+      \/\/int val;\n+\n+      do {\n+        if (s.pending === s.pending_buf_size) {\n+          if (s.gzhead.hcrc && s.pending > beg) {\n+            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n+          }\n+          flush_pending(strm);\n+          beg = s.pending;\n+          if (s.pending === s.pending_buf_size) {\n+            val = 1;\n+            break;\n+          }\n+        }\n+        \/\/ JS specific: little magic to add zero terminator to end of string\n+        if (s.gzindex < s.gzhead.name.length) {\n+          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n+        } else {\n+          val = 0;\n+        }\n+        put_byte(s, val);\n+      } while (val !== 0);\n+\n+      if (s.gzhead.hcrc && s.pending > beg) {\n+        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n+      }\n+      if (val === 0) {\n+        s.gzindex = 0;\n+        s.status = COMMENT_STATE;\n+      }\n+    }\n+    else {\n+      s.status = COMMENT_STATE;\n+    }\n+  }\n+  if (s.status === COMMENT_STATE) {\n+    if (s.gzhead.comment\/* != Z_NULL*\/) {\n+      beg = s.pending;  \/* start of bytes to update crc *\/\n+      \/\/int val;\n+\n+      do {\n+        if (s.pending === s.pending_buf_size) {\n+          if (s.gzhead.hcrc && s.pending > beg) {\n+            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n+          }\n+          flush_pending(strm);\n+          beg = s.pending;\n+          if (s.pending === s.pending_buf_size) {\n+            val = 1;\n+            break;\n+          }\n+        }\n+        \/\/ JS specific: little magic to add zero terminator to end of string\n+        if (s.gzindex < s.gzhead.comment.length) {\n+          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n+        } else {\n+          val = 0;\n+        }\n+        put_byte(s, val);\n+      } while (val !== 0);\n+\n+      if (s.gzhead.hcrc && s.pending > beg) {\n+        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n+      }\n+      if (val === 0) {\n+        s.status = HCRC_STATE;\n+      }\n+    }\n+    else {\n+      s.status = HCRC_STATE;\n+    }\n+  }\n+  if (s.status === HCRC_STATE) {\n+    if (s.gzhead.hcrc) {\n+      if (s.pending + 2 > s.pending_buf_size) {\n+        flush_pending(strm);\n+      }\n+      if (s.pending + 2 <= s.pending_buf_size) {\n+        put_byte(s, strm.adler & 0xff);\n+        put_byte(s, (strm.adler >> 8) & 0xff);\n+        strm.adler = 0; \/\/crc32(0L, Z_NULL, 0);\n+        s.status = BUSY_STATE;\n+      }\n+    }\n+    else {\n+      s.status = BUSY_STATE;\n+    }\n+  }\n+\/\/#endif\n+\n+  \/* Flush as much pending output as possible *\/\n+  if (s.pending !== 0) {\n+    flush_pending(strm);\n+    if (strm.avail_out === 0) {\n+      \/* Since avail_out is 0, deflate will be called again with\n+       * more output space, but possibly with both pending and\n+       * avail_in equal to zero. There won't be anything to do,\n+       * but this is not an error situation so make sure we\n+       * return OK instead of BUF_ERROR at next call of deflate:\n+       *\/\n+      s.last_flush = -1;\n+      return Z_OK;\n+    }\n+\n+    \/* Make sure there is something to do and avoid duplicate consecutive\n+     * flushes. For repeated and useless calls with Z_FINISH, we keep\n+     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n+     *\/\n+  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n+    flush !== Z_FINISH) {\n+    return err(strm, Z_BUF_ERROR);\n+  }\n+\n+  \/* User must not provide more input after the first FINISH: *\/\n+  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n+    return err(strm, Z_BUF_ERROR);\n+  }\n+\n+  \/* Start a new block or continue the current one.\n+   *\/\n+  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n+    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n+    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n+      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n+        configuration_table[s.level].func(s, flush));\n+\n+    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n+      s.status = FINISH_STATE;\n+    }\n+    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n+      if (strm.avail_out === 0) {\n+        s.last_flush = -1;\n+        \/* avoid BUF_ERROR next call, see above *\/\n+      }\n+      return Z_OK;\n+      \/* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n+       * of deflate should use the same flush parameter to make sure\n+       * that the flush is complete. So we don't have to output an\n+       * empty block here, this will be done at next call. This also\n+       * ensures that for a very small output buffer, we emit at most\n+       * one empty block.\n+       *\/\n+    }\n+    if (bstate === BS_BLOCK_DONE) {\n+      if (flush === Z_PARTIAL_FLUSH) {\n+        trees._tr_align(s);\n+      }\n+      else if (flush !== Z_BLOCK) { \/* FULL_FLUSH or SYNC_FLUSH *\/\n+\n+        trees._tr_stored_block(s, 0, 0, false);\n+        \/* For a full flush, this empty block will be recognized\n+         * as a special marker by inflate_sync().\n+         *\/\n+        if (flush === Z_FULL_FLUSH) {\n+          \/*** CLEAR_HASH(s); ***\/             \/* forget history *\/\n+          zero(s.head); \/\/ Fill with NIL (= 0);\n+\n+          if (s.lookahead === 0) {\n+            s.strstart = 0;\n+            s.block_start = 0;\n+            s.insert = 0;\n+          }\n+        }\n+      }\n+      flush_pending(strm);\n+      if (strm.avail_out === 0) {\n+        s.last_flush = -1; \/* avoid BUF_ERROR at next call, see above *\/\n+        return Z_OK;\n+      }\n+    }\n+  }\n+  \/\/Assert(strm->avail_out > 0, \"bug2\");\n+  \/\/if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n+\n+  if (flush !== Z_FINISH) { return Z_OK; }\n+  if (s.wrap <= 0) { return Z_STREAM_END; }\n+\n+  \/* Write the trailer *\/\n+  if (s.wrap === 2) {\n+    put_byte(s, strm.adler & 0xff);\n+    put_byte(s, (strm.adler >> 8) & 0xff);\n+    put_byte(s, (strm.adler >> 16) & 0xff);\n+    put_byte(s, (strm.adler >> 24) & 0xff);\n+    put_byte(s, strm.total_in & 0xff);\n+    put_byte(s, (strm.total_in >> 8) & 0xff);\n+    put_byte(s, (strm.total_in >> 16) & 0xff);\n+    put_byte(s, (strm.total_in >> 24) & 0xff);\n+  }\n+  else\n+  {\n+    putShortMSB(s, strm.adler >>> 16);\n+    putShortMSB(s, strm.adler & 0xffff);\n+  }\n+\n+  flush_pending(strm);\n+  \/* If avail_out is zero, the application will call deflate again\n+   * to flush the rest.\n+   *\/\n+  if (s.wrap > 0) { s.wrap = -s.wrap; }\n+  \/* write the trailer only once! *\/\n+  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n+}\n+\n+function deflateEnd(strm) {\n+  var status;\n+\n+  if (!strm\/*== Z_NULL*\/ || !strm.state\/*== Z_NULL*\/) {\n+    return Z_STREAM_ERROR;\n+  }\n+\n+  status = strm.state.status;\n+  if (status !== INIT_STATE &&\n+    status !== EXTRA_STATE &&\n+    status !== NAME_STATE &&\n+    status !== COMMENT_STATE &&\n+    status !== HCRC_STATE &&\n+    status !== BUSY_STATE &&\n+    status !== FINISH_STATE\n+  ) {\n+    return err(strm, Z_STREAM_ERROR);\n+  }\n+\n+  strm.state = null;\n+\n+  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n+}\n+\n+\n+\/* =========================================================================\n+ * Initializes the compression dictionary from the given byte\n+ * sequence without producing any compressed output.\n+ *\/\n+function deflateSetDictionary(strm, dictionary) {\n+  var dictLength = dictionary.length;\n+\n+  var s;\n+  var str, n;\n+  var wrap;\n+  var avail;\n+  var next;\n+  var input;\n+  var tmpDict;\n+\n+  if (!strm\/*== Z_NULL*\/ || !strm.state\/*== Z_NULL*\/) {\n+    return Z_STREAM_ERROR;\n+  }\n+\n+  s = strm.state;\n+  wrap = s.wrap;\n+\n+  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n+    return Z_STREAM_ERROR;\n+  }\n+\n+  \/* when using zlib wrappers, compute Adler-32 for provided dictionary *\/\n+  if (wrap === 1) {\n+    \/* adler32(strm->adler, dictionary, dictLength); *\/\n+    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n+  }\n+\n+  s.wrap = 0;   \/* avoid computing Adler-32 in read_buf *\/\n+\n+  \/* if dictionary would fill window, just replace the history *\/\n+  if (dictLength >= s.w_size) {\n+    if (wrap === 0) {            \/* already empty otherwise *\/\n+      \/*** CLEAR_HASH(s); ***\/\n+      zero(s.head); \/\/ Fill with NIL (= 0);\n+      s.strstart = 0;\n+      s.block_start = 0;\n+      s.insert = 0;\n+    }\n+    \/* use the tail *\/\n+    \/\/ dictionary = dictionary.slice(dictLength - s.w_size);\n+    tmpDict = new utils.Buf8(s.w_size);\n+    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n+    dictionary = tmpDict;\n+    dictLength = s.w_size;\n+  }\n+  \/* insert dictionary into window and hash *\/\n+  avail = strm.avail_in;\n+  next = strm.next_in;\n+  input = strm.input;\n+  strm.avail_in = dictLength;\n+  strm.next_in = 0;\n+  strm.input = dictionary;\n+  fill_window(s);\n+  while (s.lookahead >= MIN_MATCH) {\n+    str = s.strstart;\n+    n = s.lookahead - (MIN_MATCH - 1);\n+    do {\n+      \/* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); *\/\n+      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n+\n+      s.prev[str & s.w_mask] = s.head[s.ins_h];\n+\n+      s.head[s.ins_h] = str;\n+      str++;\n+    } while (--n);\n+    s.strstart = str;\n+    s.lookahead = MIN_MATCH - 1;\n+    fill_window(s);\n+  }\n+  s.strstart += s.lookahead;\n+  s.block_start = s.strstart;\n+  s.insert = s.lookahead;\n+  s.lookahead = 0;\n+  s.match_length = s.prev_length = MIN_MATCH - 1;\n+  s.match_available = 0;\n+  strm.next_in = next;\n+  strm.input = input;\n+  strm.avail_in = avail;\n+  s.wrap = wrap;\n+  return Z_OK;\n+}\n+\n+\n+exports.deflateInit = deflateInit;\n+exports.deflateInit2 = deflateInit2;\n+exports.deflateReset = deflateReset;\n+exports.deflateResetKeep = deflateResetKeep;\n+exports.deflateSetHeader = deflateSetHeader;\n+exports.deflate = deflate;\n+exports.deflateEnd = deflateEnd;\n+exports.deflateSetDictionary = deflateSetDictionary;\n+exports.deflateInfo = 'pako deflate (from Nodeca project)';\n+\n+\/* Not implemented\n+exports.deflateBound = deflateBound;\n+exports.deflateCopy = deflateCopy;\n+exports.deflateParams = deflateParams;\n+exports.deflatePending = deflatePending;\n+exports.deflatePrime = deflatePrime;\n+exports.deflateTune = deflateTune;\n+*\/\n+\n+},{\"..\/utils\/common\":41,\".\/adler32\":43,\".\/crc32\":45,\".\/messages\":51,\".\/trees\":52}],47:[function(require,module,exports){\n+'use strict';\n+\n+\/\/ (C) 1995-2013 Jean-loup Gailly and Mark Adler\n+\/\/ (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n+\/\/\n+\/\/ This software is provided 'as-is', without any express or implied\n+\/\/ warranty. In no event will the authors be held liable for any damages\n+\/\/ arising from the use of this software.\n+\/\/\n+\/\/ Permission is granted to anyone to use this software for any purpose,\n+\/\/ including commercial applications, and to alter it and redistribute it\n+\/\/ freely, subject to the following restrictions:\n+\/\/\n+\/\/ 1. The origin of this software must not be misrepresented; you must not\n+\/\/   claim that you wrote the original software. If you use this software\n+\/\/   in a product, an acknowledgment in the product documentation would be\n+\/\/   appreciated but is not required.\n+\/\/ 2. Altered source versions must be plainly marked as such, and must not be\n+\/\/   misrepresented as being the original software.\n+\/\/ 3. This notice may not be removed or altered from any source distribution.\n+\n+function GZheader() {\n+  \/* true if compressed data believed to be text *\/\n+  this.text       = 0;\n+  \/* modification time *\/\n+  this.time       = 0;\n+  \/* extra flags (not used when writing a gzip file) *\/\n+  this.xflags     = 0;\n+  \/* operating system *\/\n+  this.os         = 0;\n+  \/* pointer to extra field or Z_NULL if none *\/\n+  this.extra      = null;\n+  \/* extra field length (valid if extra != Z_NULL) *\/\n+  this.extra_len  = 0; \/\/ Actually, we don't need it in JS,\n+                       \/\/ but leave for few code modifications\n+\n+  \/\/\n+  \/\/ Setup limits is not necessary because in js we should not preallocate memory\n+  \/\/ for inflate use constant limit in 65536 bytes\n+  \/\/\n+\n+  \/* space at extra (only when reading header) *\/\n+  \/\/ this.extra_max  = 0;\n+  \/* pointer to zero-terminated file name or Z_NULL *\/\n+  this.name       = '';\n+  \/* space at name (only when reading header) *\/\n+  \/\/ this.name_max   = 0;\n+  \/* pointer to zero-terminated comment or Z_NULL *\/\n+  this.comment    = '';\n+  \/* space at comment (only when reading header) *\/\n+  \/\/ this.comm_max   = 0;\n+  \/* true if there was or will be a header crc *\/\n+  this.hcrc       = 0;\n+  \/* true when done reading gzip header (not used when writing a gzip file) *\/\n+  this.done       = false;\n+}\n+\n+module.exports = GZheader;\n+\n+},{}],48:[function(require,module,exports){\n+'use strict';\n+\n+\/\/ (C) 1995-2013 Jean-loup Gailly and Mark Adler\n+\/\/ (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n+\/\/\n+\/\/ This software is provided 'as-is', without any express or implied\n+\/\/ warranty. In no event will the authors be held liable for any damages\n+\/\/ arising from the use of this software.\n+\/\/\n+\/\/ Permission is granted to anyone to use this software for any purpose,\n+\/\/ including commercial applications, and to alter it and redistribute it\n+\/\/ freely, subject to the following restrictions:\n+\/\/\n+\/\/ 1. The origin of this software must not be misrepresented; you must not\n+\/\/   claim that you wrote the original software. If you use this software\n+\/\/   in a product, an acknowledgment in the product documentation would be\n+\/\/   appreciated but is not required.\n+\/\/ 2. Altered source versions must be plainly marked as such, and must not be\n+\/\/   misrepresented as being the original software.\n+\/\/ 3. This notice may not be removed or altered from any source distribution.\n+\n+\/\/ See state defs from inflate.js\n+var BAD = 30;       \/* got a data error -- remain here until reset *\/\n+var TYPE = 12;      \/* i: waiting for type bits, including last-flag bit *\/\n+\n+\/*\n+   Decode literal, length, and distance codes and write out the resulting\n+   literal and match bytes until either not enough input or output is\n+   available, an end-of-block is encountered, or a data error is encountered.\n+   When large enough input and output buffers are supplied to inflate(), for\n+   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n+   inflate execution time is spent in this routine.\n+\n+   Entry assumptions:\n+\n+        state.mode === LEN\n+        strm.avail_in >= 6\n+        strm.avail_out >= 258\n+        start >= strm.avail_out\n+        state.bits < 8\n+\n+   On return, state.mode is one of:\n+\n+        LEN -- ran out of enough output space or enough available input\n+        TYPE -- reached end of block code, inflate() to interpret next block\n+        BAD -- error in block data\n+\n+   Notes:\n+\n+    - The maximum input bits used by a length\/distance pair is 15 bits for the\n+      length code, 5 bits for the length extra, 15 bits for the distance code,\n+      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n+      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n+      checking for available input while decoding.\n+\n+    - The maximum bytes that a single length\/distance pair can output is 258\n+      bytes, which is the maximum length that can be coded.  inflate_fast()\n+      requires strm.avail_out >= 258 for each loop to avoid checking for\n+      output space.\n+ *\/\n+module.exports = function inflate_fast(strm, start) {\n+  var state;\n+  var _in;                    \/* local strm.input *\/\n+  var last;                   \/* have enough input while in < last *\/\n+  var _out;                   \/* local strm.output *\/\n+  var beg;                    \/* inflate()'s initial strm.output *\/\n+  var end;                    \/* while out < end, enough space available *\/\n+\/\/#ifdef INFLATE_STRICT\n+  var dmax;                   \/* maximum distance from zlib header *\/\n+\/\/#endif\n+  var wsize;                  \/* window size or zero if not using window *\/\n+  var whave;                  \/* valid bytes in the window *\/\n+  var wnext;                  \/* window write index *\/\n+  \/\/ Use `s_window` instead `window`, avoid conflict with instrumentation tools\n+  var s_window;               \/* allocated sliding window, if wsize != 0 *\/\n+  var hold;                   \/* local strm.hold *\/\n+  var bits;                   \/* local strm.bits *\/\n+  var lcode;                  \/* local strm.lencode *\/\n+  var dcode;                  \/* local strm.distcode *\/\n+  var lmask;                  \/* mask for first level of length codes *\/\n+  var dmask;                  \/* mask for first level of distance codes *\/\n+  var here;                   \/* retrieved table entry *\/\n+  var op;                     \/* code bits, operation, extra bits, or *\/\n+                              \/*  window position, window bytes to copy *\/\n+  var len;                    \/* match length, unused bytes *\/\n+  var dist;                   \/* match distance *\/\n+  var from;                   \/* where to copy match from *\/\n+  var from_source;\n+\n+\n+  var input, output; \/\/ JS specific, because we have no pointers\n+\n+  \/* copy state to local variables *\/\n+  state = strm.state;\n+  \/\/here = state.here;\n+  _in = strm.next_in;\n+  input = strm.input;\n+  last = _in + (strm.avail_in - 5);\n+  _out = strm.next_out;\n+  output = strm.output;\n+  beg = _out - (start - strm.avail_out);\n+  end = _out + (strm.avail_out - 257);\n+\/\/#ifdef INFLATE_STRICT\n+  dmax = state.dmax;\n+\/\/#endif\n+  wsize = state.wsize;\n+  whave = state.whave;\n+  wnext = state.wnext;\n+  s_window = state.window;\n+  hold = state.hold;\n+  bits = state.bits;\n+  lcode = state.lencode;\n+  dcode = state.distcode;\n+  lmask = (1 << state.lenbits) - 1;\n+  dmask = (1 << state.distbits) - 1;\n+\n+\n+  \/* decode literals and length\/distances until end-of-block or not enough\n+     input data or output space *\/\n+\n+  top:\n+  do {\n+    if (bits < 15) {\n+      hold += input[_in++] << bits;\n+      bits += 8;\n+      hold += input[_in++] << bits;\n+      bits += 8;\n+    }\n+\n+    here = lcode[hold & lmask];\n+\n+    dolen:\n+    for (;;) { \/\/ Goto emulation\n+      op = here >>> 24\/*here.bits*\/;\n+      hold >>>= op;\n+      bits -= op;\n+      op = (here >>> 16) & 0xff\/*here.op*\/;\n+      if (op === 0) {                          \/* literal *\/\n+        \/\/Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n+        \/\/        \"inflate:         literal '%c'\\n\" :\n+        \/\/        \"inflate:         literal 0x%02x\\n\", here.val));\n+        output[_out++] = here & 0xffff\/*here.val*\/;\n+      }\n+      else if (op & 16) {                     \/* length base *\/\n+        len = here & 0xffff\/*here.val*\/;\n+        op &= 15;                           \/* number of extra bits *\/\n+        if (op) {\n+          if (bits < op) {\n+            hold += input[_in++] << bits;\n+            bits += 8;\n+          }\n+          len += hold & ((1 << op) - 1);\n+          hold >>>= op;\n+          bits -= op;\n+        }\n+        \/\/Tracevv((stderr, \"inflate:         length %u\\n\", len));\n+        if (bits < 15) {\n+          hold += input[_in++] << bits;\n+          bits += 8;\n+          hold += input[_in++] << bits;\n+          bits += 8;\n+        }\n+        here = dcode[hold & dmask];\n+\n+        dodist:\n+        for (;;) { \/\/ goto emulation\n+          op = here >>> 24\/*here.bits*\/;\n+          hold >>>= op;\n+          bits -= op;\n+          op = (here >>> 16) & 0xff\/*here.op*\/;\n+\n+          if (op & 16) {                      \/* distance base *\/\n+            dist = here & 0xffff\/*here.val*\/;\n+            op &= 15;                       \/* number of extra bits *\/\n+            if (bits < op) {\n+              hold += input[_in++] << bits;\n+              bits += 8;\n+              if (bits < op) {\n+                hold += input[_in++] << bits;\n+                bits += 8;\n+              }\n+            }\n+            dist += hold & ((1 << op) - 1);\n+\/\/#ifdef INFLATE_STRICT\n+            if (dist > dmax) {\n+              strm.msg = 'invalid distance too far back';\n+              state.mode = BAD;\n+              break top;\n+            }\n+\/\/#endif\n+            hold >>>= op;\n+            bits -= op;\n+            \/\/Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n+            op = _out - beg;                \/* max distance in output *\/\n+            if (dist > op) {                \/* see if copy from window *\/\n+              op = dist - op;               \/* distance back in window *\/\n+              if (op > whave) {\n+                if (state.sane) {\n+                  strm.msg = 'invalid distance too far back';\n+                  state.mode = BAD;\n+                  break top;\n+                }\n+\n+\/\/ (!) This block is disabled in zlib defailts,\n+\/\/ don't enable it for binary compatibility\n+\/\/#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n+\/\/                if (len <= op - whave) {\n+\/\/                  do {\n+\/\/                    output[_out++] = 0;\n+\/\/                  } while (--len);\n+\/\/                  continue top;\n+\/\/                }\n+\/\/                len -= op - whave;\n+\/\/                do {\n+\/\/                  output[_out++] = 0;\n+\/\/                } while (--op > whave);\n+\/\/                if (op === 0) {\n+\/\/                  from = _out - dist;\n+\/\/                  do {\n+\/\/                    output[_out++] = output[from++];\n+\/\/                  } while (--len);\n+\/\/                  continue top;\n+\/\/                }\n+\/\/#endif\n+              }\n+              from = 0; \/\/ window index\n+              from_source = s_window;\n+              if (wnext === 0) {           \/* very common case *\/\n+                from += wsize - op;\n+                if (op < len) {         \/* some from window *\/\n+                  len -= op;\n+                  do {\n+                    output[_out++] = s_window[from++];\n+                  } while (--op);\n+                  from = _out - dist;  \/* rest from output *\/\n+                  from_source = output;\n+                }\n+              }\n+              else if (wnext < op) {      \/* wrap around window *\/\n+                from += wsize + wnext - op;\n+                op -= wnext;\n+                if (op < len) {         \/* some from end of window *\/\n+                  len -= op;\n+                  do {\n+                    output[_out++] = s_window[from++];\n+                  } while (--op);\n+                  from = 0;\n+                  if (wnext < len) {  \/* some from start of window *\/\n+                    op = wnext;\n+                    len -= op;\n+                    do {\n+                      output[_out++] = s_window[from++];\n+                    } while (--op);\n+                    from = _out - dist;      \/* rest from output *\/\n+                    from_source = output;\n+                  }\n+                }\n+              }\n+              else {                      \/* contiguous in window *\/\n+                from += wnext - op;\n+                if (op < len) {         \/* some from window *\/\n+                  len -= op;\n+                  do {\n+                    output[_out++] = s_window[from++];\n+                  } while (--op);\n+                  from = _out - dist;  \/* rest from output *\/\n+                  from_source = output;\n+                }\n+              }\n+              while (len > 2) {\n+                output[_out++] = from_source[from++];\n+                output[_out++] = from_source[from++];\n+                output[_out++] = from_source[from++];\n+                len -= 3;\n+              }\n+              if (len) {\n+                output[_out++] = from_source[from++];\n+                if (len > 1) {\n+                  output[_out++] = from_source[from++];\n+                }\n+              }\n+            }\n+            else {\n+              from = _out - dist;          \/* copy direct from output *\/\n+              do {                        \/* minimum length is three *\/\n+                output[_out++] = output[from++];\n+                output[_out++] = output[from++];\n+                output[_out++] = output[from++];\n+                len -= 3;\n+              } while (len > 2);\n+              if (len) {\n+                output[_out++] = output[from++];\n+                if (len > 1) {\n+                  output[_out++] = output[from++];\n+                }\n+              }\n+            }\n+          }\n+          else if ((op & 64) === 0) {          \/* 2nd level distance code *\/\n+            here = dcode[(here & 0xffff)\/*here.val*\/ + (hold & ((1 << op) - 1))];\n+            continue dodist;\n+          }\n+          else {\n+            strm.msg = 'invalid distance code';\n+            state.mode = BAD;\n+            break top;\n+          }\n+\n+          break; \/\/ need to emulate goto via \"continue\"\n+        }\n+      }\n+      else if ((op & 64) === 0) {              \/* 2nd level length code *\/\n+        here = lcode[(here & 0xffff)\/*here.val*\/ + (hold & ((1 << op) - 1))];\n+        continue dolen;\n+      }\n+      else if (op & 32) {                     \/* end-of-block *\/\n+        \/\/Tracevv((stderr, \"inflate:         end of block\\n\"));\n+        state.mode = TYPE;\n+        break top;\n+      }\n+      else {\n+        strm.msg = 'invalid literal\/length code';\n+        state.mode = BAD;\n+        break top;\n+      }\n+\n+      break; \/\/ need to emulate goto via \"continue\"\n+    }\n+  } while (_in < last && _out < end);\n+\n+  \/* return unused bytes (on entry, bits < 8, so in won't go too far back) *\/\n+  len = bits >> 3;\n+  _in -= len;\n+  bits -= len << 3;\n+  hold &= (1 << bits) - 1;\n+\n+  \/* update state and return *\/\n+  strm.next_in = _in;\n+  strm.next_out = _out;\n+  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n+  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n+  state.hold = hold;\n+  state.bits = bits;\n+  return;\n+};\n+\n+},{}],49:[function(require,module,exports){\n+'use strict';\n+\n+\/\/ (C) 1995-2013 Jean-loup Gailly and Mark Adler\n+\/\/ (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n+\/\/\n+\/\/ This software is provided 'as-is', without any express or implied\n+\/\/ warranty. In no event will the authors be held liable for any damages\n+\/\/ arising from the use of this software.\n+\/\/\n+\/\/ Permission is granted to anyone to use this software for any purpose,\n+\/\/ including commercial applications, and to alter it and redistribute it\n+\/\/ freely, subject to the following restrictions:\n+\/\/\n+\/\/ 1. The origin of this software must not be misrepresented; you must not\n+\/\/   claim that you wrote the original software. If you use this software\n+\/\/   in a product, an acknowledgment in the product documentation would be\n+\/\/   appreciated but is not required.\n+\/\/ 2. Altered source versions must be plainly marked as such, and must not be\n+\/\/   misrepresented as being the original software.\n+\/\/ 3. This notice may not be removed or altered from any source distribution.\n+\n+var utils         = require('..\/utils\/common');\n+var adler32       = require('.\/adler32');\n+var crc32         = require('.\/crc32');\n+var inflate_fast  = require('.\/inffast');\n+var inflate_table = require('.\/inftrees');\n+\n+var CODES = 0;\n+var LENS = 1;\n+var DISTS = 2;\n+\n+\/* Public constants ==========================================================*\/\n+\/* ===========================================================================*\/\n+\n+\n+\/* Allowed flush values; see deflate() and inflate() below for details *\/\n+\/\/var Z_NO_FLUSH      = 0;\n+\/\/var Z_PARTIAL_FLUSH = 1;\n+\/\/var Z_SYNC_FLUSH    = 2;\n+\/\/var Z_FULL_FLUSH    = 3;\n+var Z_FINISH        = 4;\n+var Z_BLOCK         = 5;\n+var Z_TREES         = 6;\n+\n+\n+\/* Return codes for the compression\/decompression functions. Negative values\n+ * are errors, positive values are used for special but normal events.\n+ *\/\n+var Z_OK            = 0;\n+var Z_STREAM_END    = 1;\n+var Z_NEED_DICT     = 2;\n+\/\/var Z_ERRNO         = -1;\n+var Z_STREAM_ERROR  = -2;\n+var Z_DATA_ERROR    = -3;\n+var Z_MEM_ERROR     = -4;\n+var Z_BUF_ERROR     = -5;\n+\/\/var Z_VERSION_ERROR = -6;\n+\n+\/* The deflate compression method *\/\n+var Z_DEFLATED  = 8;\n+\n+\n+\/* STATES ====================================================================*\/\n+\/* ===========================================================================*\/\n+\n+\n+var    HEAD = 1;       \/* i: waiting for magic header *\/\n+var    FLAGS = 2;      \/* i: waiting for method and flags (gzip) *\/\n+var    TIME = 3;       \/* i: waiting for modification time (gzip) *\/\n+var    OS = 4;         \/* i: waiting for extra flags and operating system (gzip) *\/\n+var    EXLEN = 5;      \/* i: waiting for extra length (gzip) *\/\n+var    EXTRA = 6;      \/* i: waiting for extra bytes (gzip) *\/\n+var    NAME = 7;       \/* i: waiting for end of file name (gzip) *\/\n+var    COMMENT = 8;    \/* i: waiting for end of comment (gzip) *\/\n+var    HCRC = 9;       \/* i: waiting for header crc (gzip) *\/\n+var    DICTID = 10;    \/* i: waiting for dictionary check value *\/\n+var    DICT = 11;      \/* waiting for inflateSetDictionary() call *\/\n+var        TYPE = 12;      \/* i: waiting for type bits, including last-flag bit *\/\n+var        TYPEDO = 13;    \/* i: same, but skip check to exit inflate on new block *\/\n+var        STORED = 14;    \/* i: waiting for stored size (length and complement) *\/\n+var        COPY_ = 15;     \/* i\/o: same as COPY below, but only first time in *\/\n+var        COPY = 16;      \/* i\/o: waiting for input or output to copy stored block *\/\n+var        TABLE = 17;     \/* i: waiting for dynamic block table lengths *\/\n+var        LENLENS = 18;   \/* i: waiting for code length code lengths *\/\n+var        CODELENS = 19;  \/* i: waiting for length\/lit and distance code lengths *\/\n+var            LEN_ = 20;      \/* i: same as LEN below, but only first time in *\/\n+var            LEN = 21;       \/* i: waiting for length\/lit\/eob code *\/\n+var            LENEXT = 22;    \/* i: waiting for length extra bits *\/\n+var            DIST = 23;      \/* i: waiting for distance code *\/\n+var            DISTEXT = 24;   \/* i: waiting for distance extra bits *\/\n+var            MATCH = 25;     \/* o: waiting for output space to copy string *\/\n+var            LIT = 26;       \/* o: waiting for output space to write literal *\/\n+var    CHECK = 27;     \/* i: waiting for 32-bit check value *\/\n+var    LENGTH = 28;    \/* i: waiting for 32-bit length (gzip) *\/\n+var    DONE = 29;      \/* finished check, done -- remain here until reset *\/\n+var    BAD = 30;       \/* got a data error -- remain here until reset *\/\n+var    MEM = 31;       \/* got an inflate() memory error -- remain here until reset *\/\n+var    SYNC = 32;      \/* looking for synchronization bytes to restart inflate() *\/\n+\n+\/* ===========================================================================*\/\n+\n+\n+\n+var ENOUGH_LENS = 852;\n+var ENOUGH_DISTS = 592;\n+\/\/var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n+\n+var MAX_WBITS = 15;\n+\/* 32K LZ77 window *\/\n+var DEF_WBITS = MAX_WBITS;\n+\n+\n+function zswap32(q) {\n+  return  (((q >>> 24) & 0xff) +\n+          ((q >>> 8) & 0xff00) +\n+          ((q & 0xff00) << 8) +\n+          ((q & 0xff) << 24));\n+}\n+\n+\n+function InflateState() {\n+  this.mode = 0;             \/* current inflate mode *\/\n+  this.last = false;          \/* true if processing last block *\/\n+  this.wrap = 0;              \/* bit 0 true for zlib, bit 1 true for gzip *\/\n+  this.havedict = false;      \/* true if dictionary provided *\/\n+  this.flags = 0;             \/* gzip header method and flags (0 if zlib) *\/\n+  this.dmax = 0;              \/* zlib header max distance (INFLATE_STRICT) *\/\n+  this.check = 0;             \/* protected copy of check value *\/\n+  this.total = 0;             \/* protected copy of output count *\/\n+  \/\/ TODO: may be {}\n+  this.head = null;           \/* where to save gzip header information *\/\n+\n+  \/* sliding window *\/\n+  this.wbits = 0;             \/* log base 2 of requested window size *\/\n+  this.wsize = 0;             \/* window size or zero if not using window *\/\n+  this.whave = 0;             \/* valid bytes in the window *\/\n+  this.wnext = 0;             \/* window write index *\/\n+  this.window = null;         \/* allocated sliding window, if needed *\/\n+\n+  \/* bit accumulator *\/\n+  this.hold = 0;              \/* input bit accumulator *\/\n+  this.bits = 0;              \/* number of bits in \"in\" *\/\n+\n+  \/* for string and stored block copying *\/\n+  this.length = 0;            \/* literal or length of data to copy *\/\n+  this.offset = 0;            \/* distance back to copy string from *\/\n+\n+  \/* for table and code decoding *\/\n+  this.extra = 0;             \/* extra bits needed *\/\n+\n+  \/* fixed and dynamic code tables *\/\n+  this.lencode = null;          \/* starting table for length\/literal codes *\/\n+  this.distcode = null;         \/* starting table for distance codes *\/\n+  this.lenbits = 0;           \/* index bits for lencode *\/\n+  this.distbits = 0;          \/* index bits for distcode *\/\n+\n+  \/* dynamic table building *\/\n+  this.ncode = 0;             \/* number of code length code lengths *\/\n+  this.nlen = 0;              \/* number of length code lengths *\/\n+  this.ndist = 0;             \/* number of distance code lengths *\/\n+  this.have = 0;              \/* number of code lengths in lens[] *\/\n+  this.next = null;              \/* next available space in codes[] *\/\n+\n+  this.lens = new utils.Buf16(320); \/* temporary storage for code lengths *\/\n+  this.work = new utils.Buf16(288); \/* work area for code table building *\/\n+\n+  \/*\n+   because we don't have pointers in js, we use lencode and distcode directly\n+   as buffers so we don't need codes\n+  *\/\n+  \/\/this.codes = new utils.Buf32(ENOUGH);       \/* space for code tables *\/\n+  this.lendyn = null;              \/* dynamic table for length\/literal codes (JS specific) *\/\n+  this.distdyn = null;             \/* dynamic table for distance codes (JS specific) *\/\n+  this.sane = 0;                   \/* if false, allow invalid distance too far *\/\n+  this.back = 0;                   \/* bits back of last unprocessed length\/lit *\/\n+  this.was = 0;                    \/* initial length of match *\/\n+}\n+\n+function inflateResetKeep(strm) {\n+  var state;\n+\n+  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n+  state = strm.state;\n+  strm.total_in = strm.total_out = state.total = 0;\n+  strm.msg = ''; \/*Z_NULL*\/\n+  if (state.wrap) {       \/* to support ill-conceived Java test suite *\/\n+    strm.adler = state.wrap & 1;\n+  }\n+  state.mode = HEAD;\n+  state.last = 0;\n+  state.havedict = 0;\n+  state.dmax = 32768;\n+  state.head = null\/*Z_NULL*\/;\n+  state.hold = 0;\n+  state.bits = 0;\n+  \/\/state.lencode = state.distcode = state.next = state.codes;\n+  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n+  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n+\n+  state.sane = 1;\n+  state.back = -1;\n+  \/\/Tracev((stderr, \"inflate: reset\\n\"));\n+  return Z_OK;\n+}\n+\n+function inflateReset(strm) {\n+  var state;\n+\n+  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n+  state = strm.state;\n+  state.wsize = 0;\n+  state.whave = 0;\n+  state.wnext = 0;\n+  return inflateResetKeep(strm);\n+\n+}\n+\n+function inflateReset2(strm, windowBits) {\n+  var wrap;\n+  var state;\n+\n+  \/* get the state *\/\n+  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n+  state = strm.state;\n+\n+  \/* extract wrap request from windowBits parameter *\/\n+  if (windowBits < 0) {\n+    wrap = 0;\n+    windowBits = -windowBits;\n+  }\n+  else {\n+    wrap = (windowBits >> 4) + 1;\n+    if (windowBits < 48) {\n+      windowBits &= 15;\n+    }\n+  }\n+\n+  \/* set number of window bits, free window if different *\/\n+  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n+    return Z_STREAM_ERROR;\n+  }\n+  if (state.window !== null && state.wbits !== windowBits) {\n+    state.window = null;\n+  }\n+\n+  \/* update state and reset the rest of it *\/\n+  state.wrap = wrap;\n+  state.wbits = windowBits;\n+  return inflateReset(strm);\n+}\n+\n+function inflateInit2(strm, windowBits) {\n+  var ret;\n+  var state;\n+\n+  if (!strm) { return Z_STREAM_ERROR; }\n+  \/\/strm.msg = Z_NULL;                 \/* in case we return an error *\/\n+\n+  state = new InflateState();\n+\n+  \/\/if (state === Z_NULL) return Z_MEM_ERROR;\n+  \/\/Tracev((stderr, \"inflate: allocated\\n\"));\n+  strm.state = state;\n+  state.window = null\/*Z_NULL*\/;\n+  ret = inflateReset2(strm, windowBits);\n+  if (ret !== Z_OK) {\n+    strm.state = null\/*Z_NULL*\/;\n+  }\n+  return ret;\n+}\n+\n+function inflateInit(strm) {\n+  return inflateInit2(strm, DEF_WBITS);\n+}\n+\n+\n+\/*\n+ Return state with length and distance decoding tables and index sizes set to\n+ fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n+ If BUILDFIXED is defined, then instead this routine builds the tables the\n+ first time it's called, and returns those tables the first time and\n+ thereafter.  This reduces the size of the code by about 2K bytes, in\n+ exchange for a little execution time.  However, BUILDFIXED should not be\n+ used for threaded applications, since the rewriting of the tables and virgin\n+ may not be thread-safe.\n+ *\/\n+var virgin = true;\n+\n+var lenfix, distfix; \/\/ We have no pointers in JS, so keep tables separate\n+\n+function fixedtables(state) {\n+  \/* build fixed huffman tables if first call (may not be thread safe) *\/\n+  if (virgin) {\n+    var sym;\n+\n+    lenfix = new utils.Buf32(512);\n+    distfix = new utils.Buf32(32);\n+\n+    \/* literal\/length table *\/\n+    sym = 0;\n+    while (sym < 144) { state.lens[sym++] = 8; }\n+    while (sym < 256) { state.lens[sym++] = 9; }\n+    while (sym < 280) { state.lens[sym++] = 7; }\n+    while (sym < 288) { state.lens[sym++] = 8; }\n+\n+    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n+\n+    \/* distance table *\/\n+    sym = 0;\n+    while (sym < 32) { state.lens[sym++] = 5; }\n+\n+    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n+\n+    \/* do this just once *\/\n+    virgin = false;\n+  }\n+\n+  state.lencode = lenfix;\n+  state.lenbits = 9;\n+  state.distcode = distfix;\n+  state.distbits = 5;\n+}\n+\n+\n+\/*\n+ Update the window with the last wsize (normally 32K) bytes written before\n+ returning.  If window does not exist yet, create it.  This is only called\n+ when a window is already in use, or when output has been written during this\n+ inflate call, but the end of the deflate stream has not been reached yet.\n+ It is also called to create a window for dictionary data when a dictionary\n+ is loaded.\n+\n+ Providing output buffers larger than 32K to inflate() should provide a speed\n+ advantage, since only the last 32K of output is copied to the sliding window\n+ upon return from inflate(), and since all distances after the first 32K of\n+ output will fall in the output data, making match copies simpler and faster.\n+ The advantage may be dependent on the size of the processor's data caches.\n+ *\/\n+function updatewindow(strm, src, end, copy) {\n+  var dist;\n+  var state = strm.state;\n+\n+  \/* if it hasn't been done already, allocate space for the window *\/\n+  if (state.window === null) {\n+    state.wsize = 1 << state.wbits;\n+    state.wnext = 0;\n+    state.whave = 0;\n+\n+    state.window = new utils.Buf8(state.wsize);\n+  }\n+\n+  \/* copy state->wsize or less output bytes into the circular window *\/\n+  if (copy >= state.wsize) {\n+    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n+    state.wnext = 0;\n+    state.whave = state.wsize;\n+  }\n+  else {\n+    dist = state.wsize - state.wnext;\n+    if (dist > copy) {\n+      dist = copy;\n+    }\n+    \/\/zmemcpy(state->window + state->wnext, end - copy, dist);\n+    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n+    copy -= dist;\n+    if (copy) {\n+      \/\/zmemcpy(state->window, end - copy, copy);\n+      utils.arraySet(state.window, src, end - copy, copy, 0);\n+      state.wnext = copy;\n+      state.whave = state.wsize;\n+    }\n+    else {\n+      state.wnext += dist;\n+      if (state.wnext === state.wsize) { state.wnext = 0; }\n+      if (state.whave < state.wsize) { state.whave += dist; }\n+    }\n+  }\n+  return 0;\n+}\n+\n+function inflate(strm, flush) {\n+  var state;\n+  var input, output;          \/\/ input\/output buffers\n+  var next;                   \/* next input INDEX *\/\n+  var put;                    \/* next output INDEX *\/\n+  var have, left;             \/* available input and output *\/\n+  var hold;                   \/* bit buffer *\/\n+  var bits;                   \/* bits in bit buffer *\/\n+  var _in, _out;              \/* save starting available input and output *\/\n+  var copy;                   \/* number of stored or match bytes to copy *\/\n+  var from;                   \/* where to copy match bytes from *\/\n+  var from_source;\n+  var here = 0;               \/* current decoding table entry *\/\n+  var here_bits, here_op, here_val; \/\/ paked \"here\" denormalized (JS specific)\n+  \/\/var last;                   \/* parent table entry *\/\n+  var last_bits, last_op, last_val; \/\/ paked \"last\" denormalized (JS specific)\n+  var len;                    \/* length to copy for repeats, bits to drop *\/\n+  var ret;                    \/* return code *\/\n+  var hbuf = new utils.Buf8(4);    \/* buffer for gzip header crc calculation *\/\n+  var opts;\n+\n+  var n; \/\/ temporary var for NEED_BITS\n+\n+  var order = \/* permutation of code lengths *\/\n+    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n+\n+\n+  if (!strm || !strm.state || !strm.output ||\n+      (!strm.input && strm.avail_in !== 0)) {\n+    return Z_STREAM_ERROR;\n+  }\n+\n+  state = strm.state;\n+  if (state.mode === TYPE) { state.mode = TYPEDO; }    \/* skip check *\/\n+\n+\n+  \/\/--- LOAD() ---\n+  put = strm.next_out;\n+  output = strm.output;\n+  left = strm.avail_out;\n+  next = strm.next_in;\n+  input = strm.input;\n+  have = strm.avail_in;\n+  hold = state.hold;\n+  bits = state.bits;\n+  \/\/---\n+\n+  _in = have;\n+  _out = left;\n+  ret = Z_OK;\n+\n+  inf_leave: \/\/ goto emulation\n+  for (;;) {\n+    switch (state.mode) {\n+    case HEAD:\n+      if (state.wrap === 0) {\n+        state.mode = TYPEDO;\n+        break;\n+      }\n+      \/\/=== NEEDBITS(16);\n+      while (bits < 16) {\n+        if (have === 0) { break inf_leave; }\n+        have--;\n+        hold += input[next++] << bits;\n+        bits += 8;\n+      }\n+      \/\/===\/\/\n+      if ((state.wrap & 2) && hold === 0x8b1f) {  \/* gzip header *\/\n+        state.check = 0\/*crc32(0L, Z_NULL, 0)*\/;\n+        \/\/=== CRC2(state.check, hold);\n+        hbuf[0] = hold & 0xff;\n+        hbuf[1] = (hold >>> 8) & 0xff;\n+        state.check = crc32(state.check, hbuf, 2, 0);\n+        \/\/===\/\/\n+\n+        \/\/=== INITBITS();\n+        hold = 0;\n+        bits = 0;\n+        \/\/===\/\/\n+        state.mode = FLAGS;\n+        break;\n+      }\n+      state.flags = 0;           \/* expect zlib header *\/\n+      if (state.head) {\n+        state.head.done = false;\n+      }\n+      if (!(state.wrap & 1) ||   \/* check if zlib header allowed *\/\n+        (((hold & 0xff)\/*BITS(8)*\/ << 8) + (hold >> 8)) % 31) {\n+        strm.msg = 'incorrect header check';\n+        state.mode = BAD;\n+        break;\n+      }\n+      if ((hold & 0x0f)\/*BITS(4)*\/ !== Z_DEFLATED) {\n+        strm.msg = 'unknown compression method';\n+        state.mode = BAD;\n+        break;\n+      }\n+      \/\/--- DROPBITS(4) ---\/\/\n+      hold >>>= 4;\n+      bits -= 4;\n+      \/\/---\/\/\n+      len = (hold & 0x0f)\/*BITS(4)*\/ + 8;\n+      if (state.wbits === 0) {\n+        state.wbits = len;\n+      }\n+      else if (len > state.wbits) {\n+        strm.msg = 'invalid window size';\n+        state.mode = BAD;\n+        break;\n+      }\n+      state.dmax = 1 << len;\n+      \/\/Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n+      strm.adler = state.check = 1\/*adler32(0L, Z_NULL, 0)*\/;\n+      state.mode = hold & 0x200 ? DICTID : TYPE;\n+      \/\/=== INITBITS();\n+      hold = 0;\n+      bits = 0;\n+      \/\/===\/\/\n+      break;\n+    case FLAGS:\n+      \/\/=== NEEDBITS(16); *\/\n+      while (bits < 16) {\n+        if (have === 0) { break inf_leave; }\n+        have--;\n+        hold += input[next++] << bits;\n+        bits += 8;\n+      }\n+      \/\/===\/\/\n+      state.flags = hold;\n+      if ((state.flags & 0xff) !== Z_DEFLATED) {\n+        strm.msg = 'unknown compression method';\n+        state.mode = BAD;\n+        break;\n+      }\n+      if (state.flags & 0xe000) {\n+        strm.msg = 'unknown header flags set';\n+        state.mode = BAD;\n+        break;\n+      }\n+      if (state.head) {\n+        state.head.text = ((hold >> 8) & 1);\n+      }\n+      if (state.flags & 0x0200) {\n+        \/\/=== CRC2(state.check, hold);\n+        hbuf[0] = hold & 0xff;\n+        hbuf[1] = (hold >>> 8) & 0xff;\n+        state.check = crc32(state.check, hbuf, 2, 0);\n+        \/\/===\/\/\n+      }\n+      \/\/=== INITBITS();\n+      hold = 0;\n+      bits = 0;\n+      \/\/===\/\/\n+      state.mode = TIME;\n+      \/* falls through *\/\n+    case TIME:\n+      \/\/=== NEEDBITS(32); *\/\n+      while (bits < 32) {\n+        if (have === 0) { break inf_leave; }\n+        have--;\n+        hold += input[next++] << bits;\n+        bits += 8;\n+      }\n+      \/\/===\/\/\n+      if (state.head) {\n+        state.head.time = hold;\n+      }\n+      if (state.flags & 0x0200) {\n+        \/\/=== CRC4(state.check, hold)\n+        hbuf[0] = hold & 0xff;\n+        hbuf[1] = (hold >>> 8) & 0xff;\n+        hbuf[2] = (hold >>> 16) & 0xff;\n+        hbuf[3] = (hold >>> 24) & 0xff;\n+        state.check = crc32(state.check, hbuf, 4, 0);\n+        \/\/===\n+      }\n+      \/\/=== INITBITS();\n+      hold = 0;\n+      bits = 0;\n+      \/\/===\/\/\n+      state.mode = OS;\n+      \/* falls through *\/\n+    case OS:\n+      \/\/=== NEEDBITS(16); *\/\n+      while (bits < 16) {\n+        if (have === 0) { break inf_leave; }\n+        have--;\n+        hold += input[next++] << bits;\n+        bits += 8;\n+      }\n+      \/\/===\/\/\n+      if (state.head) {\n+        state.head.xflags = (hold & 0xff);\n+        state.head.os = (hold >> 8);\n+      }\n+      if (state.flags & 0x0200) {\n+        \/\/=== CRC2(state.check, hold);\n+        hbuf[0] = hold & 0xff;\n+        hbuf[1] = (hold >>> 8) & 0xff;\n+        state.check = crc32(state.check, hbuf, 2, 0);\n+        \/\/===\/\/\n+      }\n+      \/\/=== INITBITS();\n+      hold = 0;\n+      bits = 0;\n+      \/\/===\/\/\n+      state.mode = EXLEN;\n+      \/* falls through *\/\n+    case EXLEN:\n+      if (state.flags & 0x0400) {\n+        \/\/=== NEEDBITS(16); *\/\n+        while (bits < 16) {\n+          if (have === 0) { break inf_leave; }\n+          have--;\n+          hold += input[next++] << bits;\n+          bits += 8;\n+        }\n+        \/\/===\/\/\n+        state.length = hold;\n+        if (state.head) {\n+          state.head.extra_len = hold;\n+        }\n+        if (state.flags & 0x0200) {\n+          \/\/=== CRC2(state.check, hold);\n+          hbuf[0] = hold & 0xff;\n+          hbuf[1] = (hold >>> 8) & 0xff;\n+          state.check = crc32(state.check, hbuf, 2, 0);\n+          \/\/===\/\/\n+        }\n+        \/\/=== INITBITS();\n+        hold = 0;\n+        bits = 0;\n+        \/\/===\/\/\n+      }\n+      else if (state.head) {\n+        state.head.extra = null\/*Z_NULL*\/;\n+      }\n+      state.mode = EXTRA;\n+      \/* falls through *\/\n+    case EXTRA:\n+      if (state.flags & 0x0400) {\n+        copy = state.length;\n+        if (copy > have) { copy = have; }\n+        if (copy) {\n+          if (state.head) {\n+            len = state.head.extra_len - state.length;\n+            if (!state.head.extra) {\n+              \/\/ Use untyped array for more conveniend processing later\n+              state.head.extra = new Array(state.head.extra_len);\n+            }\n+            utils.arraySet(\n+              state.head.extra,\n+              input,\n+              next,\n+              \/\/ extra field is limited to 65536 bytes\n+              \/\/ - no need for additional size check\n+              copy,\n+              \/*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*\/\n+              len\n+            );\n+            \/\/zmemcpy(state.head.extra + len, next,\n+            \/\/        len + copy > state.head.extra_max ?\n+            \/\/        state.head.extra_max - len : copy);\n+          }\n+          if (state.flags & 0x0200) {\n+            state.check = crc32(state.check, input, copy, next);\n+          }\n+          have -= copy;\n+          next += copy;\n+          state.length -= copy;\n+        }\n+        if (state.length) { break inf_leave; }\n+      }\n+      state.length = 0;\n+      state.mode = NAME;\n+      \/* falls through *\/\n+    case NAME:\n+      if (state.flags & 0x0800) {\n+        if (have === 0) { break inf_leave; }\n+        copy = 0;\n+        do {\n+          \/\/ TODO: 2 or 1 bytes?\n+          len = input[next + copy++];\n+          \/* use constant limit because in js we should not preallocate memory *\/\n+          if (state.head && len &&\n+              (state.length < 65536 \/*state.head.name_max*\/)) {\n+            state.head.name += String.fromCharCode(len);\n+          }\n+        } while (len && copy < have);\n+\n+        if (state.flags & 0x0200) {\n+          state.check = crc32(state.check, input, copy, next);\n+        }\n+        have -= copy;\n+        next += copy;\n+        if (len) { break inf_leave; }\n+      }\n+      else if (state.head) {\n+        state.head.name = null;\n+      }\n+      state.length = 0;\n+      state.mode = COMMENT;\n+      \/* falls through *\/\n+    case COMMENT:\n+      if (state.flags & 0x1000) {\n+        if (have === 0) { break inf_leave; }\n+        copy = 0;\n+        do {\n+          len = input[next + copy++];\n+          \/* use constant limit because in js we should not preallocate memory *\/\n+          if (state.head && len &&\n+              (state.length < 65536 \/*state.head.comm_max*\/)) {\n+            state.head.comment += String.fromCharCode(len);\n+          }\n+        } while (len && copy < have);\n+        if (state.flags & 0x0200) {\n+          state.check = crc32(state.check, input, copy, next);\n+        }\n+        have -= copy;\n+        next += copy;\n+        if (len) { break inf_leave; }\n+      }\n+      else if (state.head) {\n+        state.head.comment = null;\n+      }\n+      state.mode = HCRC;\n+      \/* falls through *\/\n+    case HCRC:\n+      if (state.flags & 0x0200) {\n+        \/\/=== NEEDBITS(16); *\/\n+        while (bits < 16) {\n+          if (have === 0) { break inf_leave; }\n+          have--;\n+          hold += input[next++] << bits;\n+          bits += 8;\n+        }\n+        \/\/===\/\/\n+        if (hold !== (state.check & 0xffff)) {\n+          strm.msg = 'header crc mismatch';\n+          state.mode = BAD;\n+          break;\n+        }\n+        \/\/=== INITBITS();\n+        hold = 0;\n+        bits = 0;\n+        \/\/===\/\/\n+      }\n+      if (state.head) {\n+        state.head.hcrc = ((state.flags >> 9) & 1);\n+        state.head.done = true;\n+      }\n+      strm.adler = state.check = 0;\n+      state.mode = TYPE;\n+      break;\n+    case DICTID:\n+      \/\/=== NEEDBITS(32); *\/\n+      while (bits < 32) {\n+        if (have === 0) { break inf_leave; }\n+        have--;\n+        hold += input[next++] << bits;\n+        bits += 8;\n+      }\n+      \/\/===\/\/\n+      strm.adler = state.check = zswap32(hold);\n+      \/\/=== INITBITS();\n+      hold = 0;\n+      bits = 0;\n+      \/\/===\/\/\n+      state.mode = DICT;\n+      \/* falls through *\/\n+    case DICT:\n+      if (state.havedict === 0) {\n+        \/\/--- RESTORE() ---\n+        strm.next_out = put;\n+        strm.avail_out = left;\n+        strm.next_in = next;\n+        strm.avail_in = have;\n+        state.hold = hold;\n+        state.bits = bits;\n+        \/\/---\n+        return Z_NEED_DICT;\n+      }\n+      strm.adler = state.check = 1\/*adler32(0L, Z_NULL, 0)*\/;\n+      state.mode = TYPE;\n+      \/* falls through *\/\n+    case TYPE:\n+      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n+      \/* falls through *\/\n+    case TYPEDO:\n+      if (state.last) {\n+        \/\/--- BYTEBITS() ---\/\/\n+        hold >>>= bits & 7;\n+        bits -= bits & 7;\n+        \/\/---\/\/\n+        state.mode = CHECK;\n+        break;\n+      }\n+      \/\/=== NEEDBITS(3); *\/\n+      while (bits < 3) {\n+        if (have === 0) { break inf_leave; }\n+        have--;\n+        hold += input[next++] << bits;\n+        bits += 8;\n+      }\n+      \/\/===\/\/\n+      state.last = (hold & 0x01)\/*BITS(1)*\/;\n+      \/\/--- DROPBITS(1) ---\/\/\n+      hold >>>= 1;\n+      bits -= 1;\n+      \/\/---\/\/\n+\n+      switch ((hold & 0x03)\/*BITS(2)*\/) {\n+      case 0:                             \/* stored block *\/\n+        \/\/Tracev((stderr, \"inflate:     stored block%s\\n\",\n+        \/\/        state.last ? \" (last)\" : \"\"));\n+        state.mode = STORED;\n+        break;\n+      case 1:                             \/* fixed block *\/\n+        fixedtables(state);\n+        \/\/Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n+        \/\/        state.last ? \" (last)\" : \"\"));\n+        state.mode = LEN_;             \/* decode codes *\/\n+        if (flush === Z_TREES) {\n+          \/\/--- DROPBITS(2) ---\/\/\n+          hold >>>= 2;\n+          bits -= 2;\n+          \/\/---\/\/\n+          break inf_leave;\n+        }\n+        break;\n+      case 2:                             \/* dynamic block *\/\n+        \/\/Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n+        \/\/        state.last ? \" (last)\" : \"\"));\n+        state.mode = TABLE;\n+        break;\n+      case 3:\n+        strm.msg = 'invalid block type';\n+        state.mode = BAD;\n+      }\n+      \/\/--- DROPBITS(2) ---\/\/\n+      hold >>>= 2;\n+      bits -= 2;\n+      \/\/---\/\/\n+      break;\n+    case STORED:\n+      \/\/--- BYTEBITS() ---\/\/ \/* go to byte boundary *\/\n+      hold >>>= bits & 7;\n+      bits -= bits & 7;\n+      \/\/---\/\/\n+      \/\/=== NEEDBITS(32); *\/\n+      while (bits < 32) {\n+        if (have === 0) { break inf_leave; }\n+        have--;\n+        hold += input[next++] << bits;\n+        bits += 8;\n+      }\n+      \/\/===\/\/\n+      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n+        strm.msg = 'invalid stored block lengths';\n+        state.mode = BAD;\n+        break;\n+      }\n+      state.length = hold & 0xffff;\n+      \/\/Tracev((stderr, \"inflate:       stored length %u\\n\",\n+      \/\/        state.length));\n+      \/\/=== INITBITS();\n+      hold = 0;\n+      bits = 0;\n+      \/\/===\/\/\n+      state.mode = COPY_;\n+      if (flush === Z_TREES) { break inf_leave; }\n+      \/* falls through *\/\n+    case COPY_:\n+      state.mode = COPY;\n+      \/* falls through *\/\n+    case COPY:\n+      copy = state.length;\n+      if (copy) {\n+        if (copy > have) { copy = have; }\n+        if (copy > left) { copy = left; }\n+        if (copy === 0) { break inf_leave; }\n+        \/\/--- zmemcpy(put, next, copy); ---\n+        utils.arraySet(output, input, next, copy, put);\n+        \/\/---\/\/\n+        have -= copy;\n+        next += copy;\n+        left -= copy;\n+        put += copy;\n+        state.length -= copy;\n+        break;\n+      }\n+      \/\/Tracev((stderr, \"inflate:       stored end\\n\"));\n+      state.mode = TYPE;\n+      break;\n+    case TABLE:\n+      \/\/=== NEEDBITS(14); *\/\n+      while (bits < 14) {\n+        if (have === 0) { break inf_leave; }\n+        have--;\n+        hold += input[next++] << bits;\n+        bits += 8;\n+      }\n+      \/\/===\/\/\n+      state.nlen = (hold & 0x1f)\/*BITS(5)*\/ + 257;\n+      \/\/--- DROPBITS(5) ---\/\/\n+      hold >>>= 5;\n+      bits -= 5;\n+      \/\/---\/\/\n+      state.ndist = (hold & 0x1f)\/*BITS(5)*\/ + 1;\n+      \/\/--- DROPBITS(5) ---\/\/\n+      hold >>>= 5;\n+      bits -= 5;\n+      \/\/---\/\/\n+      state.ncode = (hold & 0x0f)\/*BITS(4)*\/ + 4;\n+      \/\/--- DROPBITS(4) ---\/\/\n+      hold >>>= 4;\n+      bits -= 4;\n+      \/\/---\/\/\n+\/\/#ifndef PKZIP_BUG_WORKAROUND\n+      if (state.nlen > 286 || state.ndist > 30) {\n+        strm.msg = 'too many length or distance symbols';\n+        state.mode = BAD;\n+        break;\n+      }\n+\/\/#endif\n+      \/\/Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n+      state.have = 0;\n+      state.mode = LENLENS;\n+      \/* falls through *\/\n+    case LENLENS:\n+      while (state.have < state.ncode) {\n+        \/\/=== NEEDBITS(3);\n+        while (bits < 3) {\n+          if (have === 0) { break inf_leave; }\n+          have--;\n+          hold += input[next++] << bits;\n+          bits += 8;\n+        }\n+        \/\/===\/\/\n+        state.lens[order[state.have++]] = (hold & 0x07);\/\/BITS(3);\n+        \/\/--- DROPBITS(3) ---\/\/\n+        hold >>>= 3;\n+        bits -= 3;\n+        \/\/---\/\/\n+      }\n+      while (state.have < 19) {\n+        state.lens[order[state.have++]] = 0;\n+      }\n+      \/\/ We have separate tables & no pointers. 2 commented lines below not needed.\n+      \/\/state.next = state.codes;\n+      \/\/state.lencode = state.next;\n+      \/\/ Switch to use dynamic table\n+      state.lencode = state.lendyn;\n+      state.lenbits = 7;\n+\n+      opts = { bits: state.lenbits };\n+      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n+      state.lenbits = opts.bits;\n+\n+      if (ret) {\n+        strm.msg = 'invalid code lengths set';\n+        state.mode = BAD;\n+        break;\n+      }\n+      \/\/Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n+      state.have = 0;\n+      state.mode = CODELENS;\n+      \/* falls through *\/\n+    case CODELENS:\n+      while (state.have < state.nlen + state.ndist) {\n+        for (;;) {\n+          here = state.lencode[hold & ((1 << state.lenbits) - 1)];\/*BITS(state.lenbits)*\/\n+          here_bits = here >>> 24;\n+          here_op = (here >>> 16) & 0xff;\n+          here_val = here & 0xffff;\n+\n+          if ((here_bits) <= bits) { break; }\n+          \/\/--- PULLBYTE() ---\/\/\n+          if (have === 0) { break inf_leave; }\n+          have--;\n+          hold += input[next++] << bits;\n+          bits += 8;\n+          \/\/---\/\/\n+        }\n+        if (here_val < 16) {\n+          \/\/--- DROPBITS(here.bits) ---\/\/\n+          hold >>>= here_bits;\n+          bits -= here_bits;\n+          \/\/---\/\/\n+          state.lens[state.have++] = here_val;\n+        }\n+        else {\n+          if (here_val === 16) {\n+            \/\/=== NEEDBITS(here.bits + 2);\n+            n = here_bits + 2;\n+            while (bits < n) {\n+              if (have === 0) { break inf_leave; }\n+              have--;\n+              hold += input[next++] << bits;\n+              bits += 8;\n+            }\n+            \/\/===\/\/\n+            \/\/--- DROPBITS(here.bits) ---\/\/\n+            hold >>>= here_bits;\n+            bits -= here_bits;\n+            \/\/---\/\/\n+            if (state.have === 0) {\n+              strm.msg = 'invalid bit length repeat';\n+              state.mode = BAD;\n+              break;\n+            }\n+            len = state.lens[state.have - 1];\n+            copy = 3 + (hold & 0x03);\/\/BITS(2);\n+            \/\/--- DROPBITS(2) ---\/\/\n+            hold >>>= 2;\n+            bits -= 2;\n+            \/\/---\/\/\n+          }\n+          else if (here_val === 17) {\n+            \/\/=== NEEDBITS(here.bits + 3);\n+            n = here_bits + 3;\n+            while (bits < n) {\n+              if (have === 0) { break inf_leave; }\n+              have--;\n+              hold += input[next++] << bits;\n+              bits += 8;\n+            }\n+            \/\/===\/\/\n+            \/\/--- DROPBITS(here.bits) ---\/\/\n+            hold >>>= here_bits;\n+            bits -= here_bits;\n+            \/\/---\/\/\n+            len = 0;\n+            copy = 3 + (hold & 0x07);\/\/BITS(3);\n+            \/\/--- DROPBITS(3) ---\/\/\n+            hold >>>= 3;\n+            bits -= 3;\n+            \/\/---\/\/\n+          }\n+          else {\n+            \/\/=== NEEDBITS(here.bits + 7);\n+            n = here_bits + 7;\n+            while (bits < n) {\n+              if (have === 0) { break inf_leave; }\n+              have--;\n+              hold += input[next++] << bits;\n+              bits += 8;\n+            }\n+            \/\/===\/\/\n+            \/\/--- DROPBITS(here.bits) ---\/\/\n+            hold >>>= here_bits;\n+            bits -= here_bits;\n+            \/\/---\/\/\n+            len = 0;\n+            copy = 11 + (hold & 0x7f);\/\/BITS(7);\n+            \/\/--- DROPBITS(7) ---\/\/\n+            hold >>>= 7;\n+            bits -= 7;\n+            \/\/---\/\/\n+          }\n+          if (state.have + copy > state.nlen + state.ndist) {\n+            strm.msg = 'invalid bit length repeat';\n+            state.mode = BAD;\n+            break;\n+          }\n+          while (copy--) {\n+            state.lens[state.have++] = len;\n+          }\n+        }\n+      }\n+\n+      \/* handle error breaks in while *\/\n+      if (state.mode === BAD) { break; }\n+\n+      \/* check for end-of-block code (better have one) *\/\n+      if (state.lens[256] === 0) {\n+        strm.msg = 'invalid code -- missing end-of-block';\n+        state.mode = BAD;\n+        break;\n+      }\n+\n+      \/* build code tables -- note: do not change the lenbits or distbits\n+         values here (9 and 6) without reading the comments in inftrees.h\n+         concerning the ENOUGH constants, which depend on those values *\/\n+      state.lenbits = 9;\n+\n+      opts = { bits: state.lenbits };\n+      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n+      \/\/ We have separate tables & no pointers. 2 commented lines below not needed.\n+      \/\/ state.next_index = opts.table_index;\n+      state.lenbits = opts.bits;\n+      \/\/ state.lencode = state.next;\n+\n+      if (ret) {\n+        strm.msg = 'invalid literal\/lengths set';\n+        state.mode = BAD;\n+        break;\n+      }\n+\n+      state.distbits = 6;\n+      \/\/state.distcode.copy(state.codes);\n+      \/\/ Switch to use dynamic table\n+      state.distcode = state.distdyn;\n+      opts = { bits: state.distbits };\n+      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n+      \/\/ We have separate tables & no pointers. 2 commented lines below not needed.\n+      \/\/ state.next_index = opts.table_index;\n+      state.distbits = opts.bits;\n+      \/\/ state.distcode = state.next;\n+\n+      if (ret) {\n+        strm.msg = 'invalid distances set';\n+        state.mode = BAD;\n+        break;\n+      }\n+      \/\/Tracev((stderr, 'inflate:       codes ok\\n'));\n+      state.mode = LEN_;\n+      if (flush === Z_TREES) { break inf_leave; }\n+      \/* falls through *\/\n+    case LEN_:\n+      state.mode = LEN;\n+      \/* falls through *\/\n+    case LEN:\n+      if (have >= 6 && left >= 258) {\n+        \/\/--- RESTORE() ---\n+        strm.next_out = put;\n+        strm.avail_out = left;\n+        strm.next_in = next;\n+        strm.avail_in = have;\n+        state.hold = hold;\n+        state.bits = bits;\n+        \/\/---\n+        inflate_fast(strm, _out);\n+        \/\/--- LOAD() ---\n+        put = strm.next_out;\n+        output = strm.output;\n+        left = strm.avail_out;\n+        next = strm.next_in;\n+        input = strm.input;\n+        have = strm.avail_in;\n+        hold = state.hold;\n+        bits = state.bits;\n+        \/\/---\n+\n+        if (state.mode === TYPE) {\n+          state.back = -1;\n+        }\n+        break;\n+      }\n+      state.back = 0;\n+      for (;;) {\n+        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  \/*BITS(state.lenbits)*\/\n+        here_bits = here >>> 24;\n+        here_op = (here >>> 16) & 0xff;\n+        here_val = here & 0xffff;\n+\n+        if (here_bits <= bits) { break; }\n+        \/\/--- PULLBYTE() ---\/\/\n+        if (have === 0) { break inf_leave; }\n+        have--;\n+        hold += input[next++] << bits;\n+        bits += 8;\n+        \/\/---\/\/\n+      }\n+      if (here_op && (here_op & 0xf0) === 0) {\n+        last_bits = here_bits;\n+        last_op = here_op;\n+        last_val = here_val;\n+        for (;;) {\n+          here = state.lencode[last_val +\n+                  ((hold & ((1 << (last_bits + last_op)) - 1))\/*BITS(last.bits + last.op)*\/ >> last_bits)];\n+          here_bits = here >>> 24;\n+          here_op = (here >>> 16) & 0xff;\n+          here_val = here & 0xffff;\n+\n+          if ((last_bits + here_bits) <= bits) { break; }\n+          \/\/--- PULLBYTE() ---\/\/\n+          if (have === 0) { break inf_leave; }\n+          have--;\n+          hold += input[next++] << bits;\n+          bits += 8;\n+          \/\/---\/\/\n+        }\n+        \/\/--- DROPBITS(last.bits) ---\/\/\n+        hold >>>= last_bits;\n+        bits -= last_bits;\n+        \/\/---\/\/\n+        state.back += last_bits;\n+      }\n+      \/\/--- DROPBITS(here.bits) ---\/\/\n+      hold >>>= here_bits;\n+      bits -= here_bits;\n+      \/\/---\/\/\n+      state.back += here_bits;\n+      state.length = here_val;\n+      if (here_op === 0) {\n+        \/\/Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n+        \/\/        \"inflate:         literal '%c'\\n\" :\n+        \/\/        \"inflate:         literal 0x%02x\\n\", here.val));\n+        state.mode = LIT;\n+        break;\n+      }\n+      if (here_op & 32) {\n+        \/\/Tracevv((stderr, \"inflate:         end of block\\n\"));\n+        state.back = -1;\n+        state.mode = TYPE;\n+        break;\n+      }\n+      if (here_op & 64) {\n+        strm.msg = 'invalid literal\/length code';\n+        state.mode = BAD;\n+        break;\n+      }\n+      state.extra = here_op & 15;\n+      state.mode = LENEXT;\n+      \/* falls through *\/\n+    case LENEXT:\n+      if (state.extra) {\n+        \/\/=== NEEDBITS(state.extra);\n+        n = state.extra;\n+        while (bits < n) {\n+          if (have === 0) { break inf_leave; }\n+          have--;\n+          hold += input[next++] << bits;\n+          bits += 8;\n+        }\n+        \/\/===\/\/\n+        state.length += hold & ((1 << state.extra) - 1)\/*BITS(state.extra)*\/;\n+        \/\/--- DROPBITS(state.extra) ---\/\/\n+        hold >>>= state.extra;\n+        bits -= state.extra;\n+        \/\/---\/\/\n+        state.back += state.extra;\n+      }\n+      \/\/Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n+      state.was = state.length;\n+      state.mode = DIST;\n+      \/* falls through *\/\n+    case DIST:\n+      for (;;) {\n+        here = state.distcode[hold & ((1 << state.distbits) - 1)];\/*BITS(state.distbits)*\/\n+        here_bits = here >>> 24;\n+        here_op = (here >>> 16) & 0xff;\n+        here_val = here & 0xffff;\n+\n+        if ((here_bits) <= bits) { break; }\n+        \/\/--- PULLBYTE() ---\/\/\n+        if (have === 0) { break inf_leave; }\n+        have--;\n+        hold += input[next++] << bits;\n+        bits += 8;\n+        \/\/---\/\/\n+      }\n+      if ((here_op & 0xf0) === 0) {\n+        last_bits = here_bits;\n+        last_op = here_op;\n+        last_val = here_val;\n+        for (;;) {\n+          here = state.distcode[last_val +\n+                  ((hold & ((1 << (last_bits + last_op)) - 1))\/*BITS(last.bits + last.op)*\/ >> last_bits)];\n+          here_bits = here >>> 24;\n+          here_op = (here >>> 16) & 0xff;\n+          here_val = here & 0xffff;\n+\n+          if ((last_bits + here_bits) <= bits) { break; }\n+          \/\/--- PULLBYTE() ---\/\/\n+          if (have === 0) { break inf_leave; }\n+          have--;\n+          hold += input[next++] << bits;\n+          bits += 8;\n+          \/\/---\/\/\n+        }\n+        \/\/--- DROPBITS(last.bits) ---\/\/\n+        hold >>>= last_bits;\n+        bits -= last_bits;\n+        \/\/---\/\/\n+        state.back += last_bits;\n+      }\n+      \/\/--- DROPBITS(here.bits) ---\/\/\n+      hold >>>= here_bits;\n+      bits -= here_bits;\n+      \/\/---\/\/\n+      state.back += here_bits;\n+      if (here_op & 64) {\n+        strm.msg = 'invalid distance code';\n+        state.mode = BAD;\n+        break;\n+      }\n+      state.offset = here_val;\n+      state.extra = (here_op) & 15;\n+      state.mode = DISTEXT;\n+      \/* falls through *\/\n+    case DISTEXT:\n+      if (state.extra) {\n+        \/\/=== NEEDBITS(state.extra);\n+        n = state.extra;\n+        while (bits < n) {\n+          if (have === 0) { break inf_leave; }\n+          have--;\n+          hold += input[next++] << bits;\n+          bits += 8;\n+        }\n+        \/\/===\/\/\n+        state.offset += hold & ((1 << state.extra) - 1)\/*BITS(state.extra)*\/;\n+        \/\/--- DROPBITS(state.extra) ---\/\/\n+        hold >>>= state.extra;\n+        bits -= state.extra;\n+        \/\/---\/\/\n+        state.back += state.extra;\n+      }\n+\/\/#ifdef INFLATE_STRICT\n+      if (state.offset > state.dmax) {\n+        strm.msg = 'invalid distance too far back';\n+        state.mode = BAD;\n+        break;\n+      }\n+\/\/#endif\n+      \/\/Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n+      state.mode = MATCH;\n+      \/* falls through *\/\n+    case MATCH:\n+      if (left === 0) { break inf_leave; }\n+      copy = _out - left;\n+      if (state.offset > copy) {         \/* copy from window *\/\n+        copy = state.offset - copy;\n+        if (copy > state.whave) {\n+          if (state.sane) {\n+            strm.msg = 'invalid distance too far back';\n+            state.mode = BAD;\n+            break;\n+          }\n+\/\/ (!) This block is disabled in zlib defailts,\n+\/\/ don't enable it for binary compatibility\n+\/\/#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n+\/\/          Trace((stderr, \"inflate.c too far\\n\"));\n+\/\/          copy -= state.whave;\n+\/\/          if (copy > state.length) { copy = state.length; }\n+\/\/          if (copy > left) { copy = left; }\n+\/\/          left -= copy;\n+\/\/          state.length -= copy;\n+\/\/          do {\n+\/\/            output[put++] = 0;\n+\/\/          } while (--copy);\n+\/\/          if (state.length === 0) { state.mode = LEN; }\n+\/\/          break;\n+\/\/#endif\n+        }\n+        if (copy > state.wnext) {\n+          copy -= state.wnext;\n+          from = state.wsize - copy;\n+        }\n+        else {\n+          from = state.wnext - copy;\n+        }\n+        if (copy > state.length) { copy = state.length; }\n+        from_source = state.window;\n+      }\n+      else {                              \/* copy from output *\/\n+        from_source = output;\n+        from = put - state.offset;\n+        copy = state.length;\n+      }\n+      if (copy > left) { copy = left; }\n+      left -= copy;\n+      state.length -= copy;\n+      do {\n+        output[put++] = from_source[from++];\n+      } while (--copy);\n+      if (state.length === 0) { state.mode = LEN; }\n+      break;\n+    case LIT:\n+      if (left === 0) { break inf_leave; }\n+      output[put++] = state.length;\n+      left--;\n+      state.mode = LEN;\n+      break;\n+    case CHECK:\n+      if (state.wrap) {\n+        \/\/=== NEEDBITS(32);\n+        while (bits < 32) {\n+          if (have === 0) { break inf_leave; }\n+          have--;\n+          \/\/ Use '|' insdead of '+' to make sure that result is signed\n+          hold |= input[next++] << bits;\n+          bits += 8;\n+        }\n+        \/\/===\/\/\n+        _out -= left;\n+        strm.total_out += _out;\n+        state.total += _out;\n+        if (_out) {\n+          strm.adler = state.check =\n+              \/*UPDATE(state.check, put - _out, _out);*\/\n+              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n+\n+        }\n+        _out = left;\n+        \/\/ NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n+        if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n+          strm.msg = 'incorrect data check';\n+          state.mode = BAD;\n+          break;\n+        }\n+        \/\/=== INITBITS();\n+        hold = 0;\n+        bits = 0;\n+        \/\/===\/\/\n+        \/\/Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n+      }\n+      state.mode = LENGTH;\n+      \/* falls through *\/\n+    case LENGTH:\n+      if (state.wrap && state.flags) {\n+        \/\/=== NEEDBITS(32);\n+        while (bits < 32) {\n+          if (have === 0) { break inf_leave; }\n+          have--;\n+          hold += input[next++] << bits;\n+          bits += 8;\n+        }\n+        \/\/===\/\/\n+        if (hold !== (state.total & 0xffffffff)) {\n+          strm.msg = 'incorrect length check';\n+          state.mode = BAD;\n+          break;\n+        }\n+        \/\/=== INITBITS();\n+        hold = 0;\n+        bits = 0;\n+        \/\/===\/\/\n+        \/\/Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n+      }\n+      state.mode = DONE;\n+      \/* falls through *\/\n+    case DONE:\n+      ret = Z_STREAM_END;\n+      break inf_leave;\n+    case BAD:\n+      ret = Z_DATA_ERROR;\n+      break inf_leave;\n+    case MEM:\n+      return Z_MEM_ERROR;\n+    case SYNC:\n+      \/* falls through *\/\n+    default:\n+      return Z_STREAM_ERROR;\n+    }\n+  }\n+\n+  \/\/ inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n+\n+  \/*\n+     Return from inflate(), updating the total counts and the check value.\n+     If there was no progress during the inflate() call, return a buffer\n+     error.  Call updatewindow() to create and\/or update the window state.\n+     Note: a memory error from inflate() is non-recoverable.\n+   *\/\n+\n+  \/\/--- RESTORE() ---\n+  strm.next_out = put;\n+  strm.avail_out = left;\n+  strm.next_in = next;\n+  strm.avail_in = have;\n+  state.hold = hold;\n+  state.bits = bits;\n+  \/\/---\n+\n+  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n+                      (state.mode < CHECK || flush !== Z_FINISH))) {\n+    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n+      state.mode = MEM;\n+      return Z_MEM_ERROR;\n+    }\n+  }\n+  _in -= strm.avail_in;\n+  _out -= strm.avail_out;\n+  strm.total_in += _in;\n+  strm.total_out += _out;\n+  state.total += _out;\n+  if (state.wrap && _out) {\n+    strm.adler = state.check = \/*UPDATE(state.check, strm.next_out - _out, _out);*\/\n+      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n+  }\n+  strm.data_type = state.bits + (state.last ? 64 : 0) +\n+                    (state.mode === TYPE ? 128 : 0) +\n+                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n+  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n+    ret = Z_BUF_ERROR;\n+  }\n+  return ret;\n+}\n+\n+function inflateEnd(strm) {\n+\n+  if (!strm || !strm.state \/*|| strm->zfree == (free_func)0*\/) {\n+    return Z_STREAM_ERROR;\n+  }\n+\n+  var state = strm.state;\n+  if (state.window) {\n+    state.window = null;\n+  }\n+  strm.state = null;\n+  return Z_OK;\n+}\n+\n+function inflateGetHeader(strm, head) {\n+  var state;\n+\n+  \/* check state *\/\n+  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n+  state = strm.state;\n+  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n+\n+  \/* save header structure *\/\n+  state.head = head;\n+  head.done = false;\n+  return Z_OK;\n+}\n+\n+function inflateSetDictionary(strm, dictionary) {\n+  var dictLength = dictionary.length;\n+\n+  var state;\n+  var dictid;\n+  var ret;\n+\n+  \/* check state *\/\n+  if (!strm \/* == Z_NULL *\/ || !strm.state \/* == Z_NULL *\/) { return Z_STREAM_ERROR; }\n+  state = strm.state;\n+\n+  if (state.wrap !== 0 && state.mode !== DICT) {\n+    return Z_STREAM_ERROR;\n+  }\n+\n+  \/* check for correct dictionary identifier *\/\n+  if (state.mode === DICT) {\n+    dictid = 1; \/* adler32(0, null, 0)*\/\n+    \/* dictid = adler32(dictid, dictionary, dictLength); *\/\n+    dictid = adler32(dictid, dictionary, dictLength, 0);\n+    if (dictid !== state.check) {\n+      return Z_DATA_ERROR;\n+    }\n+  }\n+  \/* copy dictionary to window using updatewindow(), which will amend the\n+   existing dictionary if appropriate *\/\n+  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n+  if (ret) {\n+    state.mode = MEM;\n+    return Z_MEM_ERROR;\n+  }\n+  state.havedict = 1;\n+  \/\/ Tracev((stderr, \"inflate:   dictionary set\\n\"));\n+  return Z_OK;\n+}\n+\n+exports.inflateReset = inflateReset;\n+exports.inflateReset2 = inflateReset2;\n+exports.inflateResetKeep = inflateResetKeep;\n+exports.inflateInit = inflateInit;\n+exports.inflateInit2 = inflateInit2;\n+exports.inflate = inflate;\n+exports.inflateEnd = inflateEnd;\n+exports.inflateGetHeader = inflateGetHeader;\n+exports.inflateSetDictionary = inflateSetDictionary;\n+exports.inflateInfo = 'pako inflate (from Nodeca project)';\n+\n+\/* Not implemented\n+exports.inflateCopy = inflateCopy;\n+exports.inflateGetDictionary = inflateGetDictionary;\n+exports.inflateMark = inflateMark;\n+exports.inflatePrime = inflatePrime;\n+exports.inflateSync = inflateSync;\n+exports.inflateSyncPoint = inflateSyncPoint;\n+exports.inflateUndermine = inflateUndermine;\n+*\/\n+\n+},{\"..\/utils\/common\":41,\".\/adler32\":43,\".\/crc32\":45,\".\/inffast\":48,\".\/inftrees\":50}],50:[function(require,module,exports){\n+'use strict';\n+\n+\/\/ (C) 1995-2013 Jean-loup Gailly and Mark Adler\n+\/\/ (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n+\/\/\n+\/\/ This software is provided 'as-is', without any express or implied\n+\/\/ warranty. In no event will the authors be held liable for any damages\n+\/\/ arising from the use of this software.\n+\/\/\n+\/\/ Permission is granted to anyone to use this software for any purpose,\n+\/\/ including commercial applications, and to alter it and redistribute it\n+\/\/ freely, subject to the following restrictions:\n+\/\/\n+\/\/ 1. The origin of this software must not be misrepresented; you must not\n+\/\/   claim that you wrote the original software. If you use this software\n+\/\/   in a product, an acknowledgment in the product documentation would be\n+\/\/   appreciated but is not required.\n+\/\/ 2. Altered source versions must be plainly marked as such, and must not be\n+\/\/   misrepresented as being the original software.\n+\/\/ 3. This notice may not be removed or altered from any source distribution.\n+\n+var utils = require('..\/utils\/common');\n+\n+var MAXBITS = 15;\n+var ENOUGH_LENS = 852;\n+var ENOUGH_DISTS = 592;\n+\/\/var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n+\n+var CODES = 0;\n+var LENS = 1;\n+var DISTS = 2;\n+\n+var lbase = [ \/* Length codes 257..285 base *\/\n+  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n+  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n+];\n+\n+var lext = [ \/* Length codes 257..285 extra *\/\n+  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n+  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n+];\n+\n+var dbase = [ \/* Distance codes 0..29 base *\/\n+  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n+  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n+  8193, 12289, 16385, 24577, 0, 0\n+];\n+\n+var dext = [ \/* Distance codes 0..29 extra *\/\n+  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n+  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n+  28, 28, 29, 29, 64, 64\n+];\n+\n+module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n+{\n+  var bits = opts.bits;\n+      \/\/here = opts.here; \/* table entry for duplication *\/\n+\n+  var len = 0;               \/* a code's length in bits *\/\n+  var sym = 0;               \/* index of code symbols *\/\n+  var min = 0, max = 0;          \/* minimum and maximum code lengths *\/\n+  var root = 0;              \/* number of index bits for root table *\/\n+  var curr = 0;              \/* number of index bits for current table *\/\n+  var drop = 0;              \/* code bits to drop for sub-table *\/\n+  var left = 0;                   \/* number of prefix codes available *\/\n+  var used = 0;              \/* code entries in table used *\/\n+  var huff = 0;              \/* Huffman code *\/\n+  var incr;              \/* for incrementing code, index *\/\n+  var fill;              \/* index for replicating entries *\/\n+  var low;               \/* low bits for current root entry *\/\n+  var mask;              \/* mask for low root bits *\/\n+  var next;             \/* next available space in table *\/\n+  var base = null;     \/* base value table to use *\/\n+  var base_index = 0;\n+\/\/  var shoextra;    \/* extra bits table to use *\/\n+  var end;                    \/* use base and extra for symbol > end *\/\n+  var count = new utils.Buf16(MAXBITS + 1); \/\/[MAXBITS+1];    \/* number of codes of each length *\/\n+  var offs = new utils.Buf16(MAXBITS + 1); \/\/[MAXBITS+1];     \/* offsets in table for each length *\/\n+  var extra = null;\n+  var extra_index = 0;\n+\n+  var here_bits, here_op, here_val;\n+\n+  \/*\n+   Process a set of code lengths to create a canonical Huffman code.  The\n+   code lengths are lens[0..codes-1].  Each length corresponds to the\n+   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n+   symbols by length from short to long, and retaining the symbol order\n+   for codes with equal lengths.  Then the code starts with all zero bits\n+   for the first code of the shortest length, and the codes are integer\n+   increments for the same length, and zeros are appended as the length\n+   increases.  For the deflate format, these bits are stored backwards\n+   from their more natural integer increment ordering, and so when the\n+   decoding tables are built in the large loop below, the integer codes\n+   are incremented backwards.\n+\n+   This routine assumes, but does not check, that all of the entries in\n+   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n+   1..MAXBITS is interpreted as that code length.  zero means that that\n+   symbol does not occur in this code.\n+\n+   The codes are sorted by computing a count of codes for each length,\n+   creating from that a table of starting indices for each length in the\n+   sorted table, and then entering the symbols in order in the sorted\n+   table.  The sorted table is work[], with that space being provided by\n+   the caller.\n+\n+   The length counts are used for other purposes as well, i.e. finding\n+   the minimum and maximum length codes, determining if there are any\n+   codes at all, checking for a valid set of lengths, and looking ahead\n+   at length counts to determine sub-table sizes when building the\n+   decoding tables.\n+   *\/\n+\n+  \/* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) *\/\n+  for (len = 0; len <= MAXBITS; len++) {\n+    count[len] = 0;\n+  }\n+  for (sym = 0; sym < codes; sym++) {\n+    count[lens[lens_index + sym]]++;\n+  }\n+\n+  \/* bound code lengths, force root to be within code lengths *\/\n+  root = bits;\n+  for (max = MAXBITS; max >= 1; max--) {\n+    if (count[max] !== 0) { break; }\n+  }\n+  if (root > max) {\n+    root = max;\n+  }\n+  if (max === 0) {                     \/* no symbols to code at all *\/\n+    \/\/table.op[opts.table_index] = 64;  \/\/here.op = (var char)64;    \/* invalid code marker *\/\n+    \/\/table.bits[opts.table_index] = 1;   \/\/here.bits = (var char)1;\n+    \/\/table.val[opts.table_index++] = 0;   \/\/here.val = (var short)0;\n+    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n+\n+\n+    \/\/table.op[opts.table_index] = 64;\n+    \/\/table.bits[opts.table_index] = 1;\n+    \/\/table.val[opts.table_index++] = 0;\n+    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n+\n+    opts.bits = 1;\n+    return 0;     \/* no symbols, but wait for decoding to report error *\/\n+  }\n+  for (min = 1; min < max; min++) {\n+    if (count[min] !== 0) { break; }\n+  }\n+  if (root < min) {\n+    root = min;\n+  }\n+\n+  \/* check for an over-subscribed or incomplete set of lengths *\/\n+  left = 1;\n+  for (len = 1; len <= MAXBITS; len++) {\n+    left <<= 1;\n+    left -= count[len];\n+    if (left < 0) {\n+      return -1;\n+    }        \/* over-subscribed *\/\n+  }\n+  if (left > 0 && (type === CODES || max !== 1)) {\n+    return -1;                      \/* incomplete set *\/\n+  }\n+\n+  \/* generate offsets into symbol table for each length for sorting *\/\n+  offs[1] = 0;\n+  for (len = 1; len < MAXBITS; len++) {\n+    offs[len + 1] = offs[len] + count[len];\n+  }\n+\n+  \/* sort symbols by length, by symbol order within each length *\/\n+  for (sym = 0; sym < codes; sym++) {\n+    if (lens[lens_index + sym] !== 0) {\n+      work[offs[lens[lens_index + sym]]++] = sym;\n+    }\n+  }\n+\n+  \/*\n+   Create and fill in decoding tables.  In this loop, the table being\n+   filled is at next and has curr index bits.  The code being used is huff\n+   with length len.  That code is converted to an index by dropping drop\n+   bits off of the bottom.  For codes where len is less than drop + curr,\n+   those top drop + curr - len bits are incremented through all values to\n+   fill the table with replicated entries.\n+\n+   root is the number of index bits for the root table.  When len exceeds\n+   root, sub-tables are created pointed to by the root entry with an index\n+   of the low root bits of huff.  This is saved in low to check for when a\n+   new sub-table should be started.  drop is zero when the root table is\n+   being filled, and drop is root when sub-tables are being filled.\n+\n+   When a new sub-table is needed, it is necessary to look ahead in the\n+   code lengths to determine what size sub-table is needed.  The length\n+   counts are used for this, and so count[] is decremented as codes are\n+   entered in the tables.\n+\n+   used keeps track of how many table entries have been allocated from the\n+   provided *table space.  It is checked for LENS and DIST tables against\n+   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n+   the initial root table size constants.  See the comments in inftrees.h\n+   for more information.\n+\n+   sym increments through all symbols, and the loop terminates when\n+   all codes of length max, i.e. all codes, have been processed.  This\n+   routine permits incomplete codes, so another loop after this one fills\n+   in the rest of the decoding tables with invalid code markers.\n+   *\/\n+\n+  \/* set up for code type *\/\n+  \/\/ poor man optimization - use if-else instead of switch,\n+  \/\/ to avoid deopts in old v8\n+  if (type === CODES) {\n+    base = extra = work;    \/* dummy value--not used *\/\n+    end = 19;\n+\n+  } else if (type === LENS) {\n+    base = lbase;\n+    base_index -= 257;\n+    extra = lext;\n+    extra_index -= 257;\n+    end = 256;\n+\n+  } else {                    \/* DISTS *\/\n+    base = dbase;\n+    extra = dext;\n+    end = -1;\n+  }\n+\n+  \/* initialize opts for loop *\/\n+  huff = 0;                   \/* starting code *\/\n+  sym = 0;                    \/* starting code symbol *\/\n+  len = min;                  \/* starting code length *\/\n+  next = table_index;              \/* current table to fill in *\/\n+  curr = root;                \/* current table index bits *\/\n+  drop = 0;                   \/* current bits to drop from code for index *\/\n+  low = -1;                   \/* trigger new sub-table when len > root *\/\n+  used = 1 << root;          \/* use root table entries *\/\n+  mask = used - 1;            \/* mask for comparing low *\/\n+\n+  \/* check available table space *\/\n+  if ((type === LENS && used > ENOUGH_LENS) ||\n+    (type === DISTS && used > ENOUGH_DISTS)) {\n+    return 1;\n+  }\n+\n+  \/* process all codes and make table entries *\/\n+  for (;;) {\n+    \/* create table entry *\/\n+    here_bits = len - drop;\n+    if (work[sym] < end) {\n+      here_op = 0;\n+      here_val = work[sym];\n+    }\n+    else if (work[sym] > end) {\n+      here_op = extra[extra_index + work[sym]];\n+      here_val = base[base_index + work[sym]];\n+    }\n+    else {\n+      here_op = 32 + 64;         \/* end of block *\/\n+      here_val = 0;\n+    }\n+\n+    \/* replicate for those indices with low len bits equal to huff *\/\n+    incr = 1 << (len - drop);\n+    fill = 1 << curr;\n+    min = fill;                 \/* save offset to next table *\/\n+    do {\n+      fill -= incr;\n+      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n+    } while (fill !== 0);\n+\n+    \/* backwards increment the len-bit code huff *\/\n+    incr = 1 << (len - 1);\n+    while (huff & incr) {\n+      incr >>= 1;\n+    }\n+    if (incr !== 0) {\n+      huff &= incr - 1;\n+      huff += incr;\n+    } else {\n+      huff = 0;\n+    }\n+\n+    \/* go to next symbol, update count, len *\/\n+    sym++;\n+    if (--count[len] === 0) {\n+      if (len === max) { break; }\n+      len = lens[lens_index + work[sym]];\n+    }\n+\n+    \/* create new sub-table if needed *\/\n+    if (len > root && (huff & mask) !== low) {\n+      \/* if first time, transition to sub-tables *\/\n+      if (drop === 0) {\n+        drop = root;\n+      }\n+\n+      \/* increment past last table *\/\n+      next += min;            \/* here min is 1 << curr *\/\n+\n+      \/* determine length of next table *\/\n+      curr = len - drop;\n+      left = 1 << curr;\n+      while (curr + drop < max) {\n+        left -= count[curr + drop];\n+        if (left <= 0) { break; }\n+        curr++;\n+        left <<= 1;\n+      }\n+\n+      \/* check for enough space *\/\n+      used += 1 << curr;\n+      if ((type === LENS && used > ENOUGH_LENS) ||\n+        (type === DISTS && used > ENOUGH_DISTS)) {\n+        return 1;\n+      }\n+\n+      \/* point entry in root table to sub-table *\/\n+      low = huff & mask;\n+      \/*table.op[low] = curr;\n+      table.bits[low] = root;\n+      table.val[low] = next - opts.table_index;*\/\n+      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n+    }\n+  }\n+\n+  \/* fill in remaining table entry if code is incomplete (guaranteed to have\n+   at most one remaining entry, since if the code is incomplete, the\n+   maximum code length that was allowed to get this far is one bit) *\/\n+  if (huff !== 0) {\n+    \/\/table.op[next + huff] = 64;            \/* invalid code marker *\/\n+    \/\/table.bits[next + huff] = len - drop;\n+    \/\/table.val[next + huff] = 0;\n+    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n+  }\n+\n+  \/* set return parameters *\/\n+  \/\/opts.table_index += used;\n+  opts.bits = root;\n+  return 0;\n+};\n+\n+},{\"..\/utils\/common\":41}],51:[function(require,module,exports){\n+'use strict';\n+\n+\/\/ (C) 1995-2013 Jean-loup Gailly and Mark Adler\n+\/\/ (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n+\/\/\n+\/\/ This software is provided 'as-is', without any express or implied\n+\/\/ warranty. In no event will the authors be held liable for any damages\n+\/\/ arising from the use of this software.\n+\/\/\n+\/\/ Permission is granted to anyone to use this software for any purpose,\n+\/\/ including commercial applications, and to alter it and redistribute it\n+\/\/ freely, subject to the following restrictions:\n+\/\/\n+\/\/ 1. The origin of this software must not be misrepresented; you must not\n+\/\/   claim that you wrote the original software. If you use this software\n+\/\/   in a product, an acknowledgment in the product documentation would be\n+\/\/   appreciated but is not required.\n+\/\/ 2. Altered source versions must be plainly marked as such, and must not be\n+\/\/   misrepresented as being the original software.\n+\/\/ 3. This notice may not be removed or altered from any source distribution.\n+\n+module.exports = {\n+  2:      'need dictionary',     \/* Z_NEED_DICT       2  *\/\n+  1:      'stream end',          \/* Z_STREAM_END      1  *\/\n+  0:      '',                    \/* Z_OK              0  *\/\n+  '-1':   'file error',          \/* Z_ERRNO         (-1) *\/\n+  '-2':   'stream error',        \/* Z_STREAM_ERROR  (-2) *\/\n+  '-3':   'data error',          \/* Z_DATA_ERROR    (-3) *\/\n+  '-4':   'insufficient memory', \/* Z_MEM_ERROR     (-4) *\/\n+  '-5':   'buffer error',        \/* Z_BUF_ERROR     (-5) *\/\n+  '-6':   'incompatible version' \/* Z_VERSION_ERROR (-6) *\/\n+};\n+\n+},{}],52:[function(require,module,exports){\n+'use strict';\n+\n+\/\/ (C) 1995-2013 Jean-loup Gailly and Mark Adler\n+\/\/ (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n+\/\/\n+\/\/ This software is provided 'as-is', without any express or implied\n+\/\/ warranty. In no event will the authors be held liable for any damages\n+\/\/ arising from the use of this software.\n+\/\/\n+\/\/ Permission is granted to anyone to use this software for any purpose,\n+\/\/ including commercial applications, and to alter it and redistribute it\n+\/\/ freely, subject to the following restrictions:\n+\/\/\n+\/\/ 1. The origin of this software must not be misrepresented; you must not\n+\/\/   claim that you wrote the original software. If you use this software\n+\/\/   in a product, an acknowledgment in the product documentation would be\n+\/\/   appreciated but is not required.\n+\/\/ 2. Altered source versions must be plainly marked as such, and must not be\n+\/\/   misrepresented as being the original software.\n+\/\/ 3. This notice may not be removed or altered from any source distribution.\n+\n+var utils = require('..\/utils\/common');\n+\n+\/* Public constants ==========================================================*\/\n+\/* ===========================================================================*\/\n+\n+\n+\/\/var Z_FILTERED          = 1;\n+\/\/var Z_HUFFMAN_ONLY      = 2;\n+\/\/var Z_RLE               = 3;\n+var Z_FIXED               = 4;\n+\/\/var Z_DEFAULT_STRATEGY  = 0;\n+\n+\/* Possible values of the data_type field (though see inflate()) *\/\n+var Z_BINARY              = 0;\n+var Z_TEXT                = 1;\n+\/\/var Z_ASCII             = 1; \/\/ = Z_TEXT\n+var Z_UNKNOWN             = 2;\n+\n+\/*============================================================================*\/\n+\n+\n+function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n+\n+\/\/ From zutil.h\n+\n+var STORED_BLOCK = 0;\n+var STATIC_TREES = 1;\n+var DYN_TREES    = 2;\n+\/* The three kinds of block type *\/\n+\n+var MIN_MATCH    = 3;\n+var MAX_MATCH    = 258;\n+\/* The minimum and maximum match lengths *\/\n+\n+\/\/ From deflate.h\n+\/* ===========================================================================\n+ * Internal compression state.\n+ *\/\n+\n+var LENGTH_CODES  = 29;\n+\/* number of length codes, not counting the special END_BLOCK code *\/\n+\n+var LITERALS      = 256;\n+\/* number of literal bytes 0..255 *\/\n+\n+var L_CODES       = LITERALS + 1 + LENGTH_CODES;\n+\/* number of Literal or Length codes, including the END_BLOCK code *\/\n+\n+var D_CODES       = 30;\n+\/* number of distance codes *\/\n+\n+var BL_CODES      = 19;\n+\/* number of codes used to transfer the bit lengths *\/\n+\n+var HEAP_SIZE     = 2 * L_CODES + 1;\n+\/* maximum heap size *\/\n+\n+var MAX_BITS      = 15;\n+\/* All codes must not exceed MAX_BITS bits *\/\n+\n+var Buf_size      = 16;\n+\/* size of bit buffer in bi_buf *\/\n+\n+\n+\/* ===========================================================================\n+ * Constants\n+ *\/\n+\n+var MAX_BL_BITS = 7;\n+\/* Bit length codes must not exceed MAX_BL_BITS bits *\/\n+\n+var END_BLOCK   = 256;\n+\/* end of block literal code *\/\n+\n+var REP_3_6     = 16;\n+\/* repeat previous bit length 3-6 times (2 bits of repeat count) *\/\n+\n+var REPZ_3_10   = 17;\n+\/* repeat a zero length 3-10 times  (3 bits of repeat count) *\/\n+\n+var REPZ_11_138 = 18;\n+\/* repeat a zero length 11-138 times  (7 bits of repeat count) *\/\n+\n+\/* eslint-disable comma-spacing,array-bracket-spacing *\/\n+var extra_lbits =   \/* extra bits for each length code *\/\n+  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n+\n+var extra_dbits =   \/* extra bits for each distance code *\/\n+  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n+\n+var extra_blbits =  \/* extra bits for each bit length code *\/\n+  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n+\n+var bl_order =\n+  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n+\/* eslint-enable comma-spacing,array-bracket-spacing *\/\n+\n+\/* The lengths of the bit length codes are sent in order of decreasing\n+ * probability, to avoid transmitting the lengths for unused bit length codes.\n+ *\/\n+\n+\/* ===========================================================================\n+ * Local data. These are initialized only once.\n+ *\/\n+\n+\/\/ We pre-fill arrays with 0 to avoid uninitialized gaps\n+\n+var DIST_CODE_LEN = 512; \/* see definition of array dist_code below *\/\n+\n+\/\/ !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1\n+var static_ltree  = new Array((L_CODES + 2) * 2);\n+zero(static_ltree);\n+\/* The static literal tree. Since the bit lengths are imposed, there is no\n+ * need for the L_CODES extra codes used during heap construction. However\n+ * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n+ * below).\n+ *\/\n+\n+var static_dtree  = new Array(D_CODES * 2);\n+zero(static_dtree);\n+\/* The static distance tree. (Actually a trivial tree since all codes use\n+ * 5 bits.)\n+ *\/\n+\n+var _dist_code    = new Array(DIST_CODE_LEN);\n+zero(_dist_code);\n+\/* Distance codes. The first 256 values correspond to the distances\n+ * 3 .. 258, the last 256 values correspond to the top 8 bits of\n+ * the 15 bit distances.\n+ *\/\n+\n+var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\n+zero(_length_code);\n+\/* length code for each normalized match length (0 == MIN_MATCH) *\/\n+\n+var base_length   = new Array(LENGTH_CODES);\n+zero(base_length);\n+\/* First normalized length for each code (0 = MIN_MATCH) *\/\n+\n+var base_dist     = new Array(D_CODES);\n+zero(base_dist);\n+\/* First normalized distance for each code (0 = distance of 1) *\/\n+\n+\n+function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n+\n+  this.static_tree  = static_tree;  \/* static tree or NULL *\/\n+  this.extra_bits   = extra_bits;   \/* extra bits for each code or NULL *\/\n+  this.extra_base   = extra_base;   \/* base index for extra_bits *\/\n+  this.elems        = elems;        \/* max number of elements in the tree *\/\n+  this.max_length   = max_length;   \/* max bit length for the codes *\/\n+\n+  \/\/ show if `static_tree` has data or dummy - needed for monomorphic objects\n+  this.has_stree    = static_tree && static_tree.length;\n+}\n+\n+\n+var static_l_desc;\n+var static_d_desc;\n+var static_bl_desc;\n+\n+\n+function TreeDesc(dyn_tree, stat_desc) {\n+  this.dyn_tree = dyn_tree;     \/* the dynamic tree *\/\n+  this.max_code = 0;            \/* largest code with non zero frequency *\/\n+  this.stat_desc = stat_desc;   \/* the corresponding static tree *\/\n+}\n+\n+\n+\n+function d_code(dist) {\n+  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n+}\n+\n+\n+\/* ===========================================================================\n+ * Output a short LSB first on the stream.\n+ * IN assertion: there is enough room in pendingBuf.\n+ *\/\n+function put_short(s, w) {\n+\/\/    put_byte(s, (uch)((w) & 0xff));\n+\/\/    put_byte(s, (uch)((ush)(w) >> 8));\n+  s.pending_buf[s.pending++] = (w) & 0xff;\n+  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n+}\n+\n+\n+\/* ===========================================================================\n+ * Send a value on a given number of bits.\n+ * IN assertion: length <= 16 and value fits in length bits.\n+ *\/\n+function send_bits(s, value, length) {\n+  if (s.bi_valid > (Buf_size - length)) {\n+    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n+    put_short(s, s.bi_buf);\n+    s.bi_buf = value >> (Buf_size - s.bi_valid);\n+    s.bi_valid += length - Buf_size;\n+  } else {\n+    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n+    s.bi_valid += length;\n+  }\n+}\n+\n+\n+function send_code(s, c, tree) {\n+  send_bits(s, tree[c * 2]\/*.Code*\/, tree[c * 2 + 1]\/*.Len*\/);\n+}\n+\n+\n+\/* ===========================================================================\n+ * Reverse the first len bits of a code, using straightforward code (a faster\n+ * method would use a table)\n+ * IN assertion: 1 <= len <= 15\n+ *\/\n+function bi_reverse(code, len) {\n+  var res = 0;\n+  do {\n+    res |= code & 1;\n+    code >>>= 1;\n+    res <<= 1;\n+  } while (--len > 0);\n+  return res >>> 1;\n+}\n+\n+\n+\/* ===========================================================================\n+ * Flush the bit buffer, keeping at most 7 bits in it.\n+ *\/\n+function bi_flush(s) {\n+  if (s.bi_valid === 16) {\n+    put_short(s, s.bi_buf);\n+    s.bi_buf = 0;\n+    s.bi_valid = 0;\n+\n+  } else if (s.bi_valid >= 8) {\n+    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n+    s.bi_buf >>= 8;\n+    s.bi_valid -= 8;\n+  }\n+}\n+\n+\n+\/* ===========================================================================\n+ * Compute the optimal bit lengths for a tree and update the total bit length\n+ * for the current block.\n+ * IN assertion: the fields freq and dad are set, heap[heap_max] and\n+ *    above are the tree nodes sorted by increasing frequency.\n+ * OUT assertions: the field len is set to the optimal bit length, the\n+ *     array bl_count contains the frequencies for each bit length.\n+ *     The length opt_len is updated; static_len is also updated if stree is\n+ *     not null.\n+ *\/\n+function gen_bitlen(s, desc)\n+\/\/    deflate_state *s;\n+\/\/    tree_desc *desc;    \/* the tree descriptor *\/\n+{\n+  var tree            = desc.dyn_tree;\n+  var max_code        = desc.max_code;\n+  var stree           = desc.stat_desc.static_tree;\n+  var has_stree       = desc.stat_desc.has_stree;\n+  var extra           = desc.stat_desc.extra_bits;\n+  var base            = desc.stat_desc.extra_base;\n+  var max_length      = desc.stat_desc.max_length;\n+  var h;              \/* heap index *\/\n+  var n, m;           \/* iterate over the tree elements *\/\n+  var bits;           \/* bit length *\/\n+  var xbits;          \/* extra bits *\/\n+  var f;              \/* frequency *\/\n+  var overflow = 0;   \/* number of elements with bit length too large *\/\n+\n+  for (bits = 0; bits <= MAX_BITS; bits++) {\n+    s.bl_count[bits] = 0;\n+  }\n+\n+  \/* In a first pass, compute the optimal bit lengths (which may\n+   * overflow in the case of the bit length tree).\n+   *\/\n+  tree[s.heap[s.heap_max] * 2 + 1]\/*.Len*\/ = 0; \/* root of the heap *\/\n+\n+  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n+    n = s.heap[h];\n+    bits = tree[tree[n * 2 + 1]\/*.Dad*\/ * 2 + 1]\/*.Len*\/ + 1;\n+    if (bits > max_length) {\n+      bits = max_length;\n+      overflow++;\n+    }\n+    tree[n * 2 + 1]\/*.Len*\/ = bits;\n+    \/* We overwrite tree[n].Dad which is no longer needed *\/\n+\n+    if (n > max_code) { continue; } \/* not a leaf node *\/\n+\n+    s.bl_count[bits]++;\n+    xbits = 0;\n+    if (n >= base) {\n+      xbits = extra[n - base];\n+    }\n+    f = tree[n * 2]\/*.Freq*\/;\n+    s.opt_len += f * (bits + xbits);\n+    if (has_stree) {\n+      s.static_len += f * (stree[n * 2 + 1]\/*.Len*\/ + xbits);\n+    }\n+  }\n+  if (overflow === 0) { return; }\n+\n+  \/\/ Trace((stderr,\"\\nbit length overflow\\n\"));\n+  \/* This happens for example on obj2 and pic of the Calgary corpus *\/\n+\n+  \/* Find the first bit length which could increase: *\/\n+  do {\n+    bits = max_length - 1;\n+    while (s.bl_count[bits] === 0) { bits--; }\n+    s.bl_count[bits]--;      \/* move one leaf down the tree *\/\n+    s.bl_count[bits + 1] += 2; \/* move one overflow item as its brother *\/\n+    s.bl_count[max_length]--;\n+    \/* The brother of the overflow item also moves one step up,\n+     * but this does not affect bl_count[max_length]\n+     *\/\n+    overflow -= 2;\n+  } while (overflow > 0);\n+\n+  \/* Now recompute all bit lengths, scanning in increasing frequency.\n+   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n+   * lengths instead of fixing only the wrong ones. This idea is taken\n+   * from 'ar' written by Haruhiko Okumura.)\n+   *\/\n+  for (bits = max_length; bits !== 0; bits--) {\n+    n = s.bl_count[bits];\n+    while (n !== 0) {\n+      m = s.heap[--h];\n+      if (m > max_code) { continue; }\n+      if (tree[m * 2 + 1]\/*.Len*\/ !== bits) {\n+        \/\/ Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n+        s.opt_len += (bits - tree[m * 2 + 1]\/*.Len*\/) * tree[m * 2]\/*.Freq*\/;\n+        tree[m * 2 + 1]\/*.Len*\/ = bits;\n+      }\n+      n--;\n+    }\n+  }\n+}\n+\n+\n+\/* ===========================================================================\n+ * Generate the codes for a given tree and bit counts (which need not be\n+ * optimal).\n+ * IN assertion: the array bl_count contains the bit length statistics for\n+ * the given tree and the field len is set for all tree elements.\n+ * OUT assertion: the field code is set for all tree elements of non\n+ *     zero code length.\n+ *\/\n+function gen_codes(tree, max_code, bl_count)\n+\/\/    ct_data *tree;             \/* the tree to decorate *\/\n+\/\/    int max_code;              \/* largest code with non zero frequency *\/\n+\/\/    ushf *bl_count;            \/* number of codes at each bit length *\/\n+{\n+  var next_code = new Array(MAX_BITS + 1); \/* next code value for each bit length *\/\n+  var code = 0;              \/* running code value *\/\n+  var bits;                  \/* bit index *\/\n+  var n;                     \/* code index *\/\n+\n+  \/* The distribution counts are first used to generate the code values\n+   * without bit reversal.\n+   *\/\n+  for (bits = 1; bits <= MAX_BITS; bits++) {\n+    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n+  }\n+  \/* Check that the bit counts in bl_count are consistent. The last code\n+   * must be all ones.\n+   *\/\n+  \/\/Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n+  \/\/        \"inconsistent bit counts\");\n+  \/\/Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n+\n+  for (n = 0;  n <= max_code; n++) {\n+    var len = tree[n * 2 + 1]\/*.Len*\/;\n+    if (len === 0) { continue; }\n+    \/* Now reverse the bits *\/\n+    tree[n * 2]\/*.Code*\/ = bi_reverse(next_code[len]++, len);\n+\n+    \/\/Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n+    \/\/     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n+  }\n+}\n+\n+\n+\/* ===========================================================================\n+ * Initialize the various 'constant' tables.\n+ *\/\n+function tr_static_init() {\n+  var n;        \/* iterates over tree elements *\/\n+  var bits;     \/* bit counter *\/\n+  var length;   \/* length value *\/\n+  var code;     \/* code value *\/\n+  var dist;     \/* distance index *\/\n+  var bl_count = new Array(MAX_BITS + 1);\n+  \/* number of codes at each bit length for an optimal tree *\/\n+\n+  \/\/ do check in _tr_init()\n+  \/\/if (static_init_done) return;\n+\n+  \/* For some embedded targets, global variables are not initialized: *\/\n+\/*#ifdef NO_INIT_GLOBAL_POINTERS\n+  static_l_desc.static_tree = static_ltree;\n+  static_l_desc.extra_bits = extra_lbits;\n+  static_d_desc.static_tree = static_dtree;\n+  static_d_desc.extra_bits = extra_dbits;\n+  static_bl_desc.extra_bits = extra_blbits;\n+#endif*\/\n+\n+  \/* Initialize the mapping length (0..255) -> length code (0..28) *\/\n+  length = 0;\n+  for (code = 0; code < LENGTH_CODES - 1; code++) {\n+    base_length[code] = length;\n+    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n+      _length_code[length++] = code;\n+    }\n+  }\n+  \/\/Assert (length == 256, \"tr_static_init: length != 256\");\n+  \/* Note that the length 255 (match length 258) can be represented\n+   * in two different ways: code 284 + 5 bits or code 285, so we\n+   * overwrite length_code[255] to use the best encoding:\n+   *\/\n+  _length_code[length - 1] = code;\n+\n+  \/* Initialize the mapping dist (0..32K) -> dist code (0..29) *\/\n+  dist = 0;\n+  for (code = 0; code < 16; code++) {\n+    base_dist[code] = dist;\n+    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n+      _dist_code[dist++] = code;\n+    }\n+  }\n+  \/\/Assert (dist == 256, \"tr_static_init: dist != 256\");\n+  dist >>= 7; \/* from now on, all distances are divided by 128 *\/\n+  for (; code < D_CODES; code++) {\n+    base_dist[code] = dist << 7;\n+    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n+      _dist_code[256 + dist++] = code;\n+    }\n+  }\n+  \/\/Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n+\n+  \/* Construct the codes of the static literal tree *\/\n+  for (bits = 0; bits <= MAX_BITS; bits++) {\n+    bl_count[bits] = 0;\n+  }\n+\n+  n = 0;\n+  while (n <= 143) {\n+    static_ltree[n * 2 + 1]\/*.Len*\/ = 8;\n+    n++;\n+    bl_count[8]++;\n+  }\n+  while (n <= 255) {\n+    static_ltree[n * 2 + 1]\/*.Len*\/ = 9;\n+    n++;\n+    bl_count[9]++;\n+  }\n+  while (n <= 279) {\n+    static_ltree[n * 2 + 1]\/*.Len*\/ = 7;\n+    n++;\n+    bl_count[7]++;\n+  }\n+  while (n <= 287) {\n+    static_ltree[n * 2 + 1]\/*.Len*\/ = 8;\n+    n++;\n+    bl_count[8]++;\n+  }\n+  \/* Codes 286 and 287 do not exist, but we must include them in the\n+   * tree construction to get a canonical Huffman tree (longest code\n+   * all ones)\n+   *\/\n+  gen_codes(static_ltree, L_CODES + 1, bl_count);\n+\n+  \/* The static distance tree is trivial: *\/\n+  for (n = 0; n < D_CODES; n++) {\n+    static_dtree[n * 2 + 1]\/*.Len*\/ = 5;\n+    static_dtree[n * 2]\/*.Code*\/ = bi_reverse(n, 5);\n+  }\n+\n+  \/\/ Now data ready and we can init static trees\n+  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n+  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n+  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n+\n+  \/\/static_init_done = true;\n+}\n+\n+\n+\/* ===========================================================================\n+ * Initialize a new block.\n+ *\/\n+function init_block(s) {\n+  var n; \/* iterates over tree elements *\/\n+\n+  \/* Initialize the trees. *\/\n+  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]\/*.Freq*\/ = 0; }\n+  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]\/*.Freq*\/ = 0; }\n+  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]\/*.Freq*\/ = 0; }\n+\n+  s.dyn_ltree[END_BLOCK * 2]\/*.Freq*\/ = 1;\n+  s.opt_len = s.static_len = 0;\n+  s.last_lit = s.matches = 0;\n+}\n+\n+\n+\/* ===========================================================================\n+ * Flush the bit buffer and align the output on a byte boundary\n+ *\/\n+function bi_windup(s)\n+{\n+  if (s.bi_valid > 8) {\n+    put_short(s, s.bi_buf);\n+  } else if (s.bi_valid > 0) {\n+    \/\/put_byte(s, (Byte)s->bi_buf);\n+    s.pending_buf[s.pending++] = s.bi_buf;\n+  }\n+  s.bi_buf = 0;\n+  s.bi_valid = 0;\n+}\n+\n+\/* ===========================================================================\n+ * Copy a stored block, storing first the length and its\n+ * one's complement if requested.\n+ *\/\n+function copy_block(s, buf, len, header)\n+\/\/DeflateState *s;\n+\/\/charf    *buf;    \/* the input data *\/\n+\/\/unsigned len;     \/* its length *\/\n+\/\/int      header;  \/* true if block header must be written *\/\n+{\n+  bi_windup(s);        \/* align on byte boundary *\/\n+\n+  if (header) {\n+    put_short(s, len);\n+    put_short(s, ~len);\n+  }\n+\/\/  while (len--) {\n+\/\/    put_byte(s, *buf++);\n+\/\/  }\n+  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n+  s.pending += len;\n+}\n+\n+\/* ===========================================================================\n+ * Compares to subtrees, using the tree depth as tie breaker when\n+ * the subtrees have equal frequency. This minimizes the worst case length.\n+ *\/\n+function smaller(tree, n, m, depth) {\n+  var _n2 = n * 2;\n+  var _m2 = m * 2;\n+  return (tree[_n2]\/*.Freq*\/ < tree[_m2]\/*.Freq*\/ ||\n+         (tree[_n2]\/*.Freq*\/ === tree[_m2]\/*.Freq*\/ && depth[n] <= depth[m]));\n+}\n+\n+\/* ===========================================================================\n+ * Restore the heap property by moving down the tree starting at node k,\n+ * exchanging a node with the smallest of its two sons if necessary, stopping\n+ * when the heap property is re-established (each father smaller than its\n+ * two sons).\n+ *\/\n+function pqdownheap(s, tree, k)\n+\/\/    deflate_state *s;\n+\/\/    ct_data *tree;  \/* the tree to restore *\/\n+\/\/    int k;               \/* node to move down *\/\n+{\n+  var v = s.heap[k];\n+  var j = k << 1;  \/* left son of k *\/\n+  while (j <= s.heap_len) {\n+    \/* Set j to the smallest of the two sons: *\/\n+    if (j < s.heap_len &&\n+      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n+      j++;\n+    }\n+    \/* Exit if v is smaller than both sons *\/\n+    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n+\n+    \/* Exchange v with the smallest son *\/\n+    s.heap[k] = s.heap[j];\n+    k = j;\n+\n+    \/* And continue down the tree, setting j to the left son of k *\/\n+    j <<= 1;\n+  }\n+  s.heap[k] = v;\n+}\n+\n+\n+\/\/ inlined manually\n+\/\/ var SMALLEST = 1;\n+\n+\/* ===========================================================================\n+ * Send the block data compressed using the given Huffman trees\n+ *\/\n+function compress_block(s, ltree, dtree)\n+\/\/    deflate_state *s;\n+\/\/    const ct_data *ltree; \/* literal tree *\/\n+\/\/    const ct_data *dtree; \/* distance tree *\/\n+{\n+  var dist;           \/* distance of matched string *\/\n+  var lc;             \/* match length or unmatched char (if dist == 0) *\/\n+  var lx = 0;         \/* running index in l_buf *\/\n+  var code;           \/* the code to send *\/\n+  var extra;          \/* number of extra bits to send *\/\n+\n+  if (s.last_lit !== 0) {\n+    do {\n+      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n+      lc = s.pending_buf[s.l_buf + lx];\n+      lx++;\n+\n+      if (dist === 0) {\n+        send_code(s, lc, ltree); \/* send a literal byte *\/\n+        \/\/Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n+      } else {\n+        \/* Here, lc is the match length - MIN_MATCH *\/\n+        code = _length_code[lc];\n+        send_code(s, code + LITERALS + 1, ltree); \/* send the length code *\/\n+        extra = extra_lbits[code];\n+        if (extra !== 0) {\n+          lc -= base_length[code];\n+          send_bits(s, lc, extra);       \/* send the extra length bits *\/\n+        }\n+        dist--; \/* dist is now the match distance - 1 *\/\n+        code = d_code(dist);\n+        \/\/Assert (code < D_CODES, \"bad d_code\");\n+\n+        send_code(s, code, dtree);       \/* send the distance code *\/\n+        extra = extra_dbits[code];\n+        if (extra !== 0) {\n+          dist -= base_dist[code];\n+          send_bits(s, dist, extra);   \/* send the extra distance bits *\/\n+        }\n+      } \/* literal or match pair ? *\/\n+\n+      \/* Check that the overlay between pending_buf and d_buf+l_buf is ok: *\/\n+      \/\/Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n+      \/\/       \"pendingBuf overflow\");\n+\n+    } while (lx < s.last_lit);\n+  }\n+\n+  send_code(s, END_BLOCK, ltree);\n+}\n+\n+\n+\/* ===========================================================================\n+ * Construct one Huffman tree and assigns the code bit strings and lengths.\n+ * Update the total bit length for the current block.\n+ * IN assertion: the field freq is set for all tree elements.\n+ * OUT assertions: the fields len and code are set to the optimal bit length\n+ *     and corresponding code. The length opt_len is updated; static_len is\n+ *     also updated if stree is not null. The field max_code is set.\n+ *\/\n+function build_tree(s, desc)\n+\/\/    deflate_state *s;\n+\/\/    tree_desc *desc; \/* the tree descriptor *\/\n+{\n+  var tree     = desc.dyn_tree;\n+  var stree    = desc.stat_desc.static_tree;\n+  var has_stree = desc.stat_desc.has_stree;\n+  var elems    = desc.stat_desc.elems;\n+  var n, m;          \/* iterate over heap elements *\/\n+  var max_code = -1; \/* largest code with non zero frequency *\/\n+  var node;          \/* new node being created *\/\n+\n+  \/* Construct the initial heap, with least frequent element in\n+   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n+   * heap[0] is not used.\n+   *\/\n+  s.heap_len = 0;\n+  s.heap_max = HEAP_SIZE;\n+\n+  for (n = 0; n < elems; n++) {\n+    if (tree[n * 2]\/*.Freq*\/ !== 0) {\n+      s.heap[++s.heap_len] = max_code = n;\n+      s.depth[n] = 0;\n+\n+    } else {\n+      tree[n * 2 + 1]\/*.Len*\/ = 0;\n+    }\n+  }\n+\n+  \/* The pkzip format requires that at least one distance code exists,\n+   * and that at least one bit should be sent even if there is only one\n+   * possible code. So to avoid special checks later on we force at least\n+   * two codes of non zero frequency.\n+   *\/\n+  while (s.heap_len < 2) {\n+    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n+    tree[node * 2]\/*.Freq*\/ = 1;\n+    s.depth[node] = 0;\n+    s.opt_len--;\n+\n+    if (has_stree) {\n+      s.static_len -= stree[node * 2 + 1]\/*.Len*\/;\n+    }\n+    \/* node is 0 or 1 so it does not have extra bits *\/\n+  }\n+  desc.max_code = max_code;\n+\n+  \/* The elements heap[heap_len\/2+1 .. heap_len] are leaves of the tree,\n+   * establish sub-heaps of increasing lengths:\n+   *\/\n+  for (n = (s.heap_len >> 1\/*int \/2*\/); n >= 1; n--) { pqdownheap(s, tree, n); }\n+\n+  \/* Construct the Huffman tree by repeatedly combining the least two\n+   * frequent nodes.\n+   *\/\n+  node = elems;              \/* next internal node of the tree *\/\n+  do {\n+    \/\/pqremove(s, tree, n);  \/* n = node of least frequency *\/\n+    \/*** pqremove ***\/\n+    n = s.heap[1\/*SMALLEST*\/];\n+    s.heap[1\/*SMALLEST*\/] = s.heap[s.heap_len--];\n+    pqdownheap(s, tree, 1\/*SMALLEST*\/);\n+    \/***\/\n+\n+    m = s.heap[1\/*SMALLEST*\/]; \/* m = node of next least frequency *\/\n+\n+    s.heap[--s.heap_max] = n; \/* keep the nodes sorted by frequency *\/\n+    s.heap[--s.heap_max] = m;\n+\n+    \/* Create a new node father of n and m *\/\n+    tree[node * 2]\/*.Freq*\/ = tree[n * 2]\/*.Freq*\/ + tree[m * 2]\/*.Freq*\/;\n+    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n+    tree[n * 2 + 1]\/*.Dad*\/ = tree[m * 2 + 1]\/*.Dad*\/ = node;\n+\n+    \/* and insert the new node in the heap *\/\n+    s.heap[1\/*SMALLEST*\/] = node++;\n+    pqdownheap(s, tree, 1\/*SMALLEST*\/);\n+\n+  } while (s.heap_len >= 2);\n+\n+  s.heap[--s.heap_max] = s.heap[1\/*SMALLEST*\/];\n+\n+  \/* At this point, the fields freq and dad are set. We can now\n+   * generate the bit lengths.\n+   *\/\n+  gen_bitlen(s, desc);\n+\n+  \/* The field len is now set, we can generate the bit codes *\/\n+  gen_codes(tree, max_code, s.bl_count);\n+}\n+\n+\n+\/* ===========================================================================\n+ * Scan a literal or distance tree to determine the frequencies of the codes\n+ * in the bit length tree.\n+ *\/\n+function scan_tree(s, tree, max_code)\n+\/\/    deflate_state *s;\n+\/\/    ct_data *tree;   \/* the tree to be scanned *\/\n+\/\/    int max_code;    \/* and its largest code of non zero frequency *\/\n+{\n+  var n;                     \/* iterates over all tree elements *\/\n+  var prevlen = -1;          \/* last emitted length *\/\n+  var curlen;                \/* length of current code *\/\n+\n+  var nextlen = tree[0 * 2 + 1]\/*.Len*\/; \/* length of next code *\/\n+\n+  var count = 0;             \/* repeat count of the current code *\/\n+  var max_count = 7;         \/* max repeat count *\/\n+  var min_count = 4;         \/* min repeat count *\/\n+\n+  if (nextlen === 0) {\n+    max_count = 138;\n+    min_count = 3;\n+  }\n+  tree[(max_code + 1) * 2 + 1]\/*.Len*\/ = 0xffff; \/* guard *\/\n+\n+  for (n = 0; n <= max_code; n++) {\n+    curlen = nextlen;\n+    nextlen = tree[(n + 1) * 2 + 1]\/*.Len*\/;\n+\n+    if (++count < max_count && curlen === nextlen) {\n+      continue;\n+\n+    } else if (count < min_count) {\n+      s.bl_tree[curlen * 2]\/*.Freq*\/ += count;\n+\n+    } else if (curlen !== 0) {\n+\n+      if (curlen !== prevlen) { s.bl_tree[curlen * 2]\/*.Freq*\/++; }\n+      s.bl_tree[REP_3_6 * 2]\/*.Freq*\/++;\n+\n+    } else if (count <= 10) {\n+      s.bl_tree[REPZ_3_10 * 2]\/*.Freq*\/++;\n+\n+    } else {\n+      s.bl_tree[REPZ_11_138 * 2]\/*.Freq*\/++;\n+    }\n+\n+    count = 0;\n+    prevlen = curlen;\n+\n+    if (nextlen === 0) {\n+      max_count = 138;\n+      min_count = 3;\n+\n+    } else if (curlen === nextlen) {\n+      max_count = 6;\n+      min_count = 3;\n+\n+    } else {\n+      max_count = 7;\n+      min_count = 4;\n+    }\n+  }\n+}\n+\n+\n+\/* ===========================================================================\n+ * Send a literal or distance tree in compressed form, using the codes in\n+ * bl_tree.\n+ *\/\n+function send_tree(s, tree, max_code)\n+\/\/    deflate_state *s;\n+\/\/    ct_data *tree; \/* the tree to be scanned *\/\n+\/\/    int max_code;       \/* and its largest code of non zero frequency *\/\n+{\n+  var n;                     \/* iterates over all tree elements *\/\n+  var prevlen = -1;          \/* last emitted length *\/\n+  var curlen;                \/* length of current code *\/\n+\n+  var nextlen = tree[0 * 2 + 1]\/*.Len*\/; \/* length of next code *\/\n+\n+  var count = 0;             \/* repeat count of the current code *\/\n+  var max_count = 7;         \/* max repeat count *\/\n+  var min_count = 4;         \/* min repeat count *\/\n+\n+  \/* tree[max_code+1].Len = -1; *\/  \/* guard already set *\/\n+  if (nextlen === 0) {\n+    max_count = 138;\n+    min_count = 3;\n+  }\n+\n+  for (n = 0; n <= max_code; n++) {\n+    curlen = nextlen;\n+    nextlen = tree[(n + 1) * 2 + 1]\/*.Len*\/;\n+\n+    if (++count < max_count && curlen === nextlen) {\n+      continue;\n+\n+    } else if (count < min_count) {\n+      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n+\n+    } else if (curlen !== 0) {\n+      if (curlen !== prevlen) {\n+        send_code(s, curlen, s.bl_tree);\n+        count--;\n+      }\n+      \/\/Assert(count >= 3 && count <= 6, \" 3_6?\");\n+      send_code(s, REP_3_6, s.bl_tree);\n+      send_bits(s, count - 3, 2);\n+\n+    } else if (count <= 10) {\n+      send_code(s, REPZ_3_10, s.bl_tree);\n+      send_bits(s, count - 3, 3);\n+\n+    } else {\n+      send_code(s, REPZ_11_138, s.bl_tree);\n+      send_bits(s, count - 11, 7);\n+    }\n+\n+    count = 0;\n+    prevlen = curlen;\n+    if (nextlen === 0) {\n+      max_count = 138;\n+      min_count = 3;\n+\n+    } else if (curlen === nextlen) {\n+      max_count = 6;\n+      min_count = 3;\n+\n+    } else {\n+      max_count = 7;\n+      min_count = 4;\n+    }\n+  }\n+}\n+\n+\n+\/* ===========================================================================\n+ * Construct the Huffman tree for the bit lengths and return the index in\n+ * bl_order of the last bit length code to send.\n+ *\/\n+function build_bl_tree(s) {\n+  var max_blindex;  \/* index of last bit length code of non zero freq *\/\n+\n+  \/* Determine the bit length frequencies for literal and distance trees *\/\n+  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n+  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n+\n+  \/* Build the bit length tree: *\/\n+  build_tree(s, s.bl_desc);\n+  \/* opt_len now includes the length of the tree representations, except\n+   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n+   *\/\n+\n+  \/* Determine the number of bit length codes to send. The pkzip format\n+   * requires that at least 4 bit length codes be sent. (appnote.txt says\n+   * 3 but the actual value used is 4.)\n+   *\/\n+  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n+    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]\/*.Len*\/ !== 0) {\n+      break;\n+    }\n+  }\n+  \/* Update opt_len to include the bit length tree and counts *\/\n+  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n+  \/\/Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n+  \/\/        s->opt_len, s->static_len));\n+\n+  return max_blindex;\n+}\n+\n+\n+\/* ===========================================================================\n+ * Send the header for a block using dynamic Huffman trees: the counts, the\n+ * lengths of the bit length codes, the literal tree and the distance tree.\n+ * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n+ *\/\n+function send_all_trees(s, lcodes, dcodes, blcodes)\n+\/\/    deflate_state *s;\n+\/\/    int lcodes, dcodes, blcodes; \/* number of codes for each tree *\/\n+{\n+  var rank;                    \/* index in bl_order *\/\n+\n+  \/\/Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n+  \/\/Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n+  \/\/        \"too many codes\");\n+  \/\/Tracev((stderr, \"\\nbl counts: \"));\n+  send_bits(s, lcodes - 257, 5); \/* not +255 as stated in appnote.txt *\/\n+  send_bits(s, dcodes - 1,   5);\n+  send_bits(s, blcodes - 4,  4); \/* not -3 as stated in appnote.txt *\/\n+  for (rank = 0; rank < blcodes; rank++) {\n+    \/\/Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n+    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]\/*.Len*\/, 3);\n+  }\n+  \/\/Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n+\n+  send_tree(s, s.dyn_ltree, lcodes - 1); \/* literal tree *\/\n+  \/\/Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n+\n+  send_tree(s, s.dyn_dtree, dcodes - 1); \/* distance tree *\/\n+  \/\/Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n+}\n+\n+\n+\/* ===========================================================================\n+ * Check if the data type is TEXT or BINARY, using the following algorithm:\n+ * - TEXT if the two conditions below are satisfied:\n+ *    a) There are no non-portable control characters belonging to the\n+ *       \"black list\" (0..6, 14..25, 28..31).\n+ *    b) There is at least one printable character belonging to the\n+ *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n+ * - BINARY otherwise.\n+ * - The following partially-portable control characters form a\n+ *   \"gray list\" that is ignored in this detection algorithm:\n+ *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n+ * IN assertion: the fields Freq of dyn_ltree are set.\n+ *\/\n+function detect_data_type(s) {\n+  \/* black_mask is the bit mask of black-listed bytes\n+   * set bits 0..6, 14..25, and 28..31\n+   * 0xf3ffc07f = binary 11110011111111111100000001111111\n+   *\/\n+  var black_mask = 0xf3ffc07f;\n+  var n;\n+\n+  \/* Check for non-textual (\"black-listed\") bytes. *\/\n+  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n+    if ((black_mask & 1) && (s.dyn_ltree[n * 2]\/*.Freq*\/ !== 0)) {\n+      return Z_BINARY;\n+    }\n+  }\n+\n+  \/* Check for textual (\"white-listed\") bytes. *\/\n+  if (s.dyn_ltree[9 * 2]\/*.Freq*\/ !== 0 || s.dyn_ltree[10 * 2]\/*.Freq*\/ !== 0 ||\n+      s.dyn_ltree[13 * 2]\/*.Freq*\/ !== 0) {\n+    return Z_TEXT;\n+  }\n+  for (n = 32; n < LITERALS; n++) {\n+    if (s.dyn_ltree[n * 2]\/*.Freq*\/ !== 0) {\n+      return Z_TEXT;\n+    }\n+  }\n+\n+  \/* There are no \"black-listed\" or \"white-listed\" bytes:\n+   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n+   *\/\n+  return Z_BINARY;\n+}\n+\n+\n+var static_init_done = false;\n+\n+\/* ===========================================================================\n+ * Initialize the tree data structures for a new zlib stream.\n+ *\/\n+function _tr_init(s)\n+{\n+\n+  if (!static_init_done) {\n+    tr_static_init();\n+    static_init_done = true;\n+  }\n+\n+  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n+  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n+  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n+\n+  s.bi_buf = 0;\n+  s.bi_valid = 0;\n+\n+  \/* Initialize the first block of the first file: *\/\n+  init_block(s);\n+}\n+\n+\n+\/* ===========================================================================\n+ * Send a stored block\n+ *\/\n+function _tr_stored_block(s, buf, stored_len, last)\n+\/\/DeflateState *s;\n+\/\/charf *buf;       \/* input block *\/\n+\/\/ulg stored_len;   \/* length of input block *\/\n+\/\/int last;         \/* one if this is the last block for a file *\/\n+{\n+  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    \/* send block type *\/\n+  copy_block(s, buf, stored_len, true); \/* with header *\/\n+}\n+\n+\n+\/* ===========================================================================\n+ * Send one empty static block to give enough lookahead for inflate.\n+ * This takes 10 bits, of which 7 may remain in the bit buffer.\n+ *\/\n+function _tr_align(s) {\n+  send_bits(s, STATIC_TREES << 1, 3);\n+  send_code(s, END_BLOCK, static_ltree);\n+  bi_flush(s);\n+}\n+\n+\n+\/* ===========================================================================\n+ * Determine the best encoding for the current block: dynamic trees, static\n+ * trees or store, and output the encoded block to the zip file.\n+ *\/\n+function _tr_flush_block(s, buf, stored_len, last)\n+\/\/DeflateState *s;\n+\/\/charf *buf;       \/* input block, or NULL if too old *\/\n+\/\/ulg stored_len;   \/* length of input block *\/\n+\/\/int last;         \/* one if this is the last block for a file *\/\n+{\n+  var opt_lenb, static_lenb;  \/* opt_len and static_len in bytes *\/\n+  var max_blindex = 0;        \/* index of last bit length code of non zero freq *\/\n+\n+  \/* Build the Huffman trees unless a stored block is forced *\/\n+  if (s.level > 0) {\n+\n+    \/* Check if the file is binary or text *\/\n+    if (s.strm.data_type === Z_UNKNOWN) {\n+      s.strm.data_type = detect_data_type(s);\n+    }\n+\n+    \/* Construct the literal and distance trees *\/\n+    build_tree(s, s.l_desc);\n+    \/\/ Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n+    \/\/        s->static_len));\n+\n+    build_tree(s, s.d_desc);\n+    \/\/ Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n+    \/\/        s->static_len));\n+    \/* At this point, opt_len and static_len are the total bit lengths of\n+     * the compressed block data, excluding the tree representations.\n+     *\/\n+\n+    \/* Build the bit length tree for the above two trees, and get the index\n+     * in bl_order of the last bit length code to send.\n+     *\/\n+    max_blindex = build_bl_tree(s);\n+\n+    \/* Determine the best encoding. Compute the block lengths in bytes. *\/\n+    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n+    static_lenb = (s.static_len + 3 + 7) >>> 3;\n+\n+    \/\/ Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n+    \/\/        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n+    \/\/        s->last_lit));\n+\n+    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n+\n+  } else {\n+    \/\/ Assert(buf != (char*)0, \"lost buf\");\n+    opt_lenb = static_lenb = stored_len + 5; \/* force a stored block *\/\n+  }\n+\n+  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n+    \/* 4: two words for the lengths *\/\n+\n+    \/* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n+     * Otherwise we can't have processed more than WSIZE input bytes since\n+     * the last block flush, because compression would have been\n+     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n+     * transform a block into a stored block.\n+     *\/\n+    _tr_stored_block(s, buf, stored_len, last);\n+\n+  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n+\n+    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n+    compress_block(s, static_ltree, static_dtree);\n+\n+  } else {\n+    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n+    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n+    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n+  }\n+  \/\/ Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n+  \/* The above check is made mod 2^32, for files larger than 512 MB\n+   * and uLong implemented on 32 bits.\n+   *\/\n+  init_block(s);\n+\n+  if (last) {\n+    bi_windup(s);\n+  }\n+  \/\/ Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n+  \/\/       s->compressed_len-7*last));\n+}\n+\n+\/* ===========================================================================\n+ * Save the match info and tally the frequency counts. Return true if\n+ * the current block must be flushed.\n+ *\/\n+function _tr_tally(s, dist, lc)\n+\/\/    deflate_state *s;\n+\/\/    unsigned dist;  \/* distance of matched string *\/\n+\/\/    unsigned lc;    \/* match length-MIN_MATCH or unmatched char (if dist==0) *\/\n+{\n+  \/\/var out_length, in_length, dcode;\n+\n+  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n+  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n+\n+  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n+  s.last_lit++;\n+\n+  if (dist === 0) {\n+    \/* lc is the unmatched char *\/\n+    s.dyn_ltree[lc * 2]\/*.Freq*\/++;\n+  } else {\n+    s.matches++;\n+    \/* Here, lc is the match length - MIN_MATCH *\/\n+    dist--;             \/* dist = match distance - 1 *\/\n+    \/\/Assert((ush)dist < (ush)MAX_DIST(s) &&\n+    \/\/       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n+    \/\/       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n+\n+    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]\/*.Freq*\/++;\n+    s.dyn_dtree[d_code(dist) * 2]\/*.Freq*\/++;\n+  }\n+\n+\/\/ (!) This block is disabled in zlib defailts,\n+\/\/ don't enable it for binary compatibility\n+\n+\/\/#ifdef TRUNCATE_BLOCK\n+\/\/  \/* Try to guess if it is profitable to stop the current block here *\/\n+\/\/  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n+\/\/    \/* Compute an upper bound for the compressed length *\/\n+\/\/    out_length = s.last_lit*8;\n+\/\/    in_length = s.strstart - s.block_start;\n+\/\/\n+\/\/    for (dcode = 0; dcode < D_CODES; dcode++) {\n+\/\/      out_length += s.dyn_dtree[dcode*2]\/*.Freq*\/ * (5 + extra_dbits[dcode]);\n+\/\/    }\n+\/\/    out_length >>>= 3;\n+\/\/    \/\/Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n+\/\/    \/\/       s->last_lit, in_length, out_length,\n+\/\/    \/\/       100L - out_length*100L\/in_length));\n+\/\/    if (s.matches < (s.last_lit>>1)\/*int \/2*\/ && out_length < (in_length>>1)\/*int \/2*\/) {\n+\/\/      return true;\n+\/\/    }\n+\/\/  }\n+\/\/#endif\n+\n+  return (s.last_lit === s.lit_bufsize - 1);\n+  \/* We avoid equality with lit_bufsize because of wraparound at 64K\n+   * on 16 bit machines and because stored blocks are restricted to\n+   * 64K-1 bytes.\n+   *\/\n+}\n+\n+exports._tr_init  = _tr_init;\n+exports._tr_stored_block = _tr_stored_block;\n+exports._tr_flush_block  = _tr_flush_block;\n+exports._tr_tally = _tr_tally;\n+exports._tr_align = _tr_align;\n+\n+},{\"..\/utils\/common\":41}],53:[function(require,module,exports){\n+'use strict';\n+\n+\/\/ (C) 1995-2013 Jean-loup Gailly and Mark Adler\n+\/\/ (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n+\/\/\n+\/\/ This software is provided 'as-is', without any express or implied\n+\/\/ warranty. In no event will the authors be held liable for any damages\n+\/\/ arising from the use of this software.\n+\/\/\n+\/\/ Permission is granted to anyone to use this software for any purpose,\n+\/\/ including commercial applications, and to alter it and redistribute it\n+\/\/ freely, subject to the following restrictions:\n+\/\/\n+\/\/ 1. The origin of this software must not be misrepresented; you must not\n+\/\/   claim that you wrote the original software. If you use this software\n+\/\/   in a product, an acknowledgment in the product documentation would be\n+\/\/   appreciated but is not required.\n+\/\/ 2. Altered source versions must be plainly marked as such, and must not be\n+\/\/   misrepresented as being the original software.\n+\/\/ 3. This notice may not be removed or altered from any source distribution.\n+\n+function ZStream() {\n+  \/* next input byte *\/\n+  this.input = null; \/\/ JS specific, because we have no pointers\n+  this.next_in = 0;\n+  \/* number of bytes available at input *\/\n+  this.avail_in = 0;\n+  \/* total number of input bytes read so far *\/\n+  this.total_in = 0;\n+  \/* next output byte should be put there *\/\n+  this.output = null; \/\/ JS specific, because we have no pointers\n+  this.next_out = 0;\n+  \/* remaining free space at output *\/\n+  this.avail_out = 0;\n+  \/* total number of bytes output so far *\/\n+  this.total_out = 0;\n+  \/* last error message, NULL if no error *\/\n+  this.msg = ''\/*Z_NULL*\/;\n+  \/* not visible by applications *\/\n+  this.state = null;\n+  \/* best guess about the data type: binary or text *\/\n+  this.data_type = 2\/*Z_UNKNOWN*\/;\n+  \/* adler32 value of the uncompressed data *\/\n+  this.adler = 0;\n+}\n+\n+module.exports = ZStream;\n+\n+},{}],54:[function(require,module,exports){\n+'use strict';\n+module.exports = typeof setImmediate === 'function' ? setImmediate :\n+\tfunction setImmediate() {\n+\t\tvar args = [].slice.apply(arguments);\n+\t\targs.splice(1, 0, 0);\n+\t\tsetTimeout.apply(null, args);\n+\t};\n+\n+},{}]},{},[10])(10)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/jquery\/jszip\/dist\/jszip.js","additions":11352,"deletions":12,"binary":false,"changes":11364,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-JSZip v3.6.0 - A JavaScript class for generating and reading zip files\n+JSZip v3.7.1 - A JavaScript class for generating and reading zip files\n@@ -13,1 +13,1 @@\n-!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{(\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:this).JSZip=e()}}(function(){return function s(a,o,u){function h(r,e){if(!o[r]){if(!a[r]){var t=\"function\"==typeof require&&require;if(!e&&t)return t(r,!0);if(f)return f(r,!0);var n=new Error(\"Cannot find module '\"+r+\"'\");throw n.code=\"MODULE_NOT_FOUND\",n}var i=o[r]={exports:{}};a[r][0].call(i.exports,function(e){var t=a[r][1][e];return h(t||e)},i,i.exports,s,a,o,u)}return o[r].exports}for(var f=\"function\"==typeof require&&require,e=0;e<u.length;e++)h(u[e]);return h}({1:[function(l,t,n){(function(r){!function(e){\"object\"==typeof n&&void 0!==t?t.exports=e():(\"undefined\"!=typeof window?window:void 0!==r?r:\"undefined\"!=typeof self?self:this).JSZip=e()}(function(){return function s(a,o,u){function h(t,e){if(!o[t]){if(!a[t]){var r=\"function\"==typeof l&&l;if(!e&&r)return r(t,!0);if(f)return f(t,!0);var n=new Error(\"Cannot find module '\"+t+\"'\");throw n.code=\"MODULE_NOT_FOUND\",n}var i=o[t]={exports:{}};a[t][0].call(i.exports,function(e){return h(a[t][1][e]||e)},i,i.exports,s,a,o,u)}return o[t].exports}for(var f=\"function\"==typeof l&&l,e=0;e<u.length;e++)h(u[e]);return h}({1:[function(l,t,n){(function(r){!function(e){\"object\"==typeof n&&void 0!==t?t.exports=e():(\"undefined\"!=typeof window?window:void 0!==r?r:\"undefined\"!=typeof self?self:this).JSZip=e()}(function(){return function s(a,o,u){function h(t,e){if(!o[t]){if(!a[t]){var r=\"function\"==typeof l&&l;if(!e&&r)return r(t,!0);if(f)return f(t,!0);var n=new Error(\"Cannot find module '\"+t+\"'\");throw n.code=\"MODULE_NOT_FOUND\",n}var i=o[t]={exports:{}};a[t][0].call(i.exports,function(e){return h(a[t][1][e]||e)},i,i.exports,s,a,o,u)}return o[t].exports}for(var f=\"function\"==typeof l&&l,e=0;e<u.length;e++)h(u[e]);return h}({1:[function(l,t,n){(function(r){!function(e){\"object\"==typeof n&&void 0!==t?t.exports=e():(\"undefined\"!=typeof window?window:void 0!==r?r:\"undefined\"!=typeof self?self:this).JSZip=e()}(function(){return function s(a,o,u){function h(t,e){if(!o[t]){if(!a[t]){var r=\"function\"==typeof l&&l;if(!e&&r)return r(t,!0);if(f)return f(t,!0);var n=new Error(\"Cannot find module '\"+t+\"'\");throw n.code=\"MODULE_NOT_FOUND\",n}var i=o[t]={exports:{}};a[t][0].call(i.exports,function(e){return h(a[t][1][e]||e)},i,i.exports,s,a,o,u)}return o[t].exports}for(var f=\"function\"==typeof l&&l,e=0;e<u.length;e++)h(u[e]);return h}({1:[function(l,t,n){(function(r){!function(e){\"object\"==typeof n&&void 0!==t?t.exports=e():(\"undefined\"!=typeof window?window:void 0!==r?r:\"undefined\"!=typeof self?self:this).JSZip=e()}(function(){return function s(a,o,u){function h(t,e){if(!o[t]){if(!a[t]){var r=\"function\"==typeof l&&l;if(!e&&r)return r(t,!0);if(f)return f(t,!0);var n=new Error(\"Cannot find module '\"+t+\"'\");throw n.code=\"MODULE_NOT_FOUND\",n}var i=o[t]={exports:{}};a[t][0].call(i.exports,function(e){return h(a[t][1][e]||e)},i,i.exports,s,a,o,u)}return o[t].exports}for(var f=\"function\"==typeof l&&l,e=0;e<u.length;e++)h(u[e]);return h}({1:[function(l,t,n){(function(r){!function(e){\"object\"==typeof n&&void 0!==t?t.exports=e():(\"undefined\"!=typeof window?window:void 0!==r?r:\"undefined\"!=typeof self?self:this).JSZip=e()}(function(){return function s(a,o,u){function h(t,e){if(!o[t]){if(!a[t]){var r=\"function\"==typeof l&&l;if(!e&&r)return r(t,!0);if(f)return f(t,!0);var n=new Error(\"Cannot find module '\"+t+\"'\");throw n.code=\"MODULE_NOT_FOUND\",n}var i=o[t]={exports:{}};a[t][0].call(i.exports,function(e){return h(a[t][1][e]||e)},i,i.exports,s,a,o,u)}return o[t].exports}for(var f=\"function\"==typeof l&&l,e=0;e<u.length;e++)h(u[e]);return h}({1:[function(e,t,r){\"use strict\";var c=e(\".\/utils\"),l=e(\".\/support\"),p=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/=\";r.encode=function(e){for(var t,r,n,i,s,a,o,u=[],h=0,f=e.length,l=f,d=\"string\"!==c.getTypeOf(e);h<e.length;)l=f-h,n=d?(t=e[h++],r=h<f?e[h++]:0,h<f?e[h++]:0):(t=e.charCodeAt(h++),r=h<f?e.charCodeAt(h++):0,h<f?e.charCodeAt(h++):0),i=t>>2,s=(3&t)<<4|r>>4,a=1<l?(15&r)<<2|n>>6:64,o=2<l?63&n:64,u.push(p.charAt(i)+p.charAt(s)+p.charAt(a)+p.charAt(o));return u.join(\"\")},r.decode=function(e){var t,r,n,i,s,a,o=0,u=0;if(\"data:\"===e.substr(0,\"data:\".length))throw new Error(\"Invalid base64 input, it looks like a data url.\");var h,f=3*(e=e.replace(\/[^A-Za-z0-9\\+\\\/\\=]\/g,\"\")).length\/4;if(e.charAt(e.length-1)===p.charAt(64)&&f--,e.charAt(e.length-2)===p.charAt(64)&&f--,f%1!=0)throw new Error(\"Invalid base64 input, bad content length.\");for(h=l.uint8array?new Uint8Array(0|f):new Array(0|f);o<e.length;)t=p.indexOf(e.charAt(o++))<<2|(i=p.indexOf(e.charAt(o++)))>>4,r=(15&i)<<4|(s=p.indexOf(e.charAt(o++)))>>2,n=(3&s)<<6|(a=p.indexOf(e.charAt(o++))),h[u++]=t,64!==s&&(h[u++]=r),64!==a&&(h[u++]=n);return h}},{\".\/support\":30,\".\/utils\":32}],2:[function(e,t,r){\"use strict\";var n=e(\".\/external\"),i=e(\".\/stream\/DataWorker\"),s=e(\".\/stream\/Crc32Probe\"),a=e(\".\/stream\/DataLengthProbe\");function o(e,t,r,n,i){this.compressedSize=e,this.uncompressedSize=t,this.crc32=r,this.compression=n,this.compressedContent=i}o.prototype={getContentWorker:function(){var e=new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a(\"data_length\")),t=this;return e.on(\"end\",function(){if(this.streamInfo.data_length!==t.uncompressedSize)throw new Error(\"Bug : uncompressed data size mismatch\")}),e},getCompressedWorker:function(){return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo(\"compressedSize\",this.compressedSize).withStreamInfo(\"uncompressedSize\",this.uncompressedSize).withStreamInfo(\"crc32\",this.crc32).withStreamInfo(\"compression\",this.compression)}},o.createWorkerFrom=function(e,t,r){return e.pipe(new s).pipe(new a(\"uncompressedSize\")).pipe(t.compressWorker(r)).pipe(new a(\"compressedSize\")).withStreamInfo(\"compression\",t)},t.exports=o},{\".\/external\":6,\".\/stream\/Crc32Probe\":25,\".\/stream\/DataLengthProbe\":26,\".\/stream\/DataWorker\":27}],3:[function(e,t,r){\"use strict\";var n=e(\".\/stream\/GenericWorker\");r.STORE={magic:\"\\0\\0\",compressWorker:function(e){return new n(\"STORE compression\")},uncompressWorker:function(){return new n(\"STORE decompression\")}},r.DEFLATE=e(\".\/flate\")},{\".\/flate\":7,\".\/stream\/GenericWorker\":28}],4:[function(e,t,r){\"use strict\";var n=e(\".\/utils\"),a=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t}();t.exports=function(e,t){return void 0!==e&&e.length?\"string\"!==n.getTypeOf(e)?function(e,t,r){var n=a,i=0+r;e^=-1;for(var s=0;s<i;s++)e=e>>>8^n[255&(e^t[s])];return-1^e}(0|t,e,e.length):function(e,t,r){var n=a,i=0+r;e^=-1;for(var s=0;s<i;s++)e=e>>>8^n[255&(e^t.charCodeAt(s))];return-1^e}(0|t,e,e.length):0}},{\".\/utils\":32}],5:[function(e,t,r){\"use strict\";r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!0,r.date=null,r.compression=null,r.compressionOptions=null,r.comment=null,r.unixPermissions=null,r.dosPermissions=null},{}],6:[function(e,t,r){\"use strict\";var n;n=\"undefined\"!=typeof Promise?Promise:e(\"lie\"),t.exports={Promise:n}},{lie:37}],7:[function(e,t,r){\"use strict\";var n=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Uint32Array,i=e(\"pako\"),s=e(\".\/utils\"),a=e(\".\/stream\/GenericWorker\"),o=n?\"uint8array\":\"array\";function u(e,t){a.call(this,\"FlateWorker\/\"+e),this._pako=null,this._pakoAction=e,this._pakoOptions=t,this.meta={}}r.magic=\"\\b\\0\",s.inherits(u,a),u.prototype.processChunk=function(e){this.meta=e.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,e.data),!1)},u.prototype.flush=function(){a.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},u.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null},u.prototype._createPako=function(){this._pako=new i[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var t=this;this._pako.onData=function(e){t.push({data:e,meta:t.meta})}},r.compressWorker=function(e){return new u(\"Deflate\",e)},r.uncompressWorker=function(){return new u(\"Inflate\",{})}},{\".\/stream\/GenericWorker\":28,\".\/utils\":32,pako:38}],8:[function(e,t,r){\"use strict\";function I(e,t){var r,n=\"\";for(r=0;r<t;r++)n+=String.fromCharCode(255&e),e>>>=8;return n}function i(e,t,r,n,i,s){var a,o,u=e.file,h=e.compression,f=s!==B.utf8encode,l=O.transformTo(\"string\",s(u.name)),d=O.transformTo(\"string\",B.utf8encode(u.name)),c=u.comment,p=O.transformTo(\"string\",s(c)),m=O.transformTo(\"string\",B.utf8encode(c)),_=d.length!==u.name.length,g=m.length!==c.length,v=\"\",b=\"\",w=\"\",y=u.dir,k=u.date,x={crc32:0,compressedSize:0,uncompressedSize:0};t&&!r||(x.crc32=e.crc32,x.compressedSize=e.compressedSize,x.uncompressedSize=e.uncompressedSize);var S=0;t&&(S|=8),f||!_&&!g||(S|=2048);var z,E=0,C=0;y&&(E|=16),\"UNIX\"===i?(C=798,E|=((z=u.unixPermissions)||(z=y?16893:33204),(65535&z)<<16)):(C=20,E|=63&(u.dosPermissions||0)),a=k.getUTCHours(),a<<=6,a|=k.getUTCMinutes(),a<<=5,a|=k.getUTCSeconds()\/2,o=k.getUTCFullYear()-1980,o<<=4,o|=k.getUTCMonth()+1,o<<=5,o|=k.getUTCDate(),_&&(v+=\"up\"+I((b=I(1,1)+I(T(l),4)+d).length,2)+b),g&&(v+=\"uc\"+I((w=I(1,1)+I(T(p),4)+m).length,2)+w);var A=\"\";return A+=\"\\n\\0\",A+=I(S,2),A+=h.magic,A+=I(a,2),A+=I(o,2),A+=I(x.crc32,4),A+=I(x.compressedSize,4),A+=I(x.uncompressedSize,4),A+=I(l.length,2),A+=I(v.length,2),{fileRecord:R.LOCAL_FILE_HEADER+A+l+v,dirRecord:R.CENTRAL_FILE_HEADER+I(C,2)+A+I(p.length,2)+\"\\0\\0\\0\\0\"+I(E,4)+I(n,4)+l+v+p}}var O=e(\"..\/utils\"),s=e(\"..\/stream\/GenericWorker\"),B=e(\"..\/utf8\"),T=e(\"..\/crc32\"),R=e(\"..\/signature\");function n(e,t,r,n){s.call(this,\"ZipFileWorker\"),this.bytesWritten=0,this.zipComment=t,this.zipPlatform=r,this.encodeFileName=n,this.streamFiles=e,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}O.inherits(n,s),n.prototype.push=function(e){var t=e.meta.percent||0,r=this.entriesCount,n=this._sources.length;this.accumulate?this.contentBuffer.push(e):(this.bytesWritten+=e.data.length,s.prototype.push.call(this,{data:e.data,meta:{currentFile:this.currentFile,percent:r?(t+100*(r-n-1))\/r:100}}))},n.prototype.openedSource=function(e){this.currentSourceOffset=this.bytesWritten,this.currentFile=e.file.name;var t=this.streamFiles&&!e.file.dir;if(t){var r=i(e,t,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:r.fileRecord,meta:{percent:0}})}else this.accumulate=!0},n.prototype.closedSource=function(e){this.accumulate=!1;var t,r=this.streamFiles&&!e.file.dir,n=i(e,r,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(n.dirRecord),r)this.push({data:(t=e,R.DATA_DESCRIPTOR+I(t.crc32,4)+I(t.compressedSize,4)+I(t.uncompressedSize,4)),meta:{percent:100}});else for(this.push({data:n.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},n.prototype.flush=function(){for(var e=this.bytesWritten,t=0;t<this.dirRecords.length;t++)this.push({data:this.dirRecords[t],meta:{percent:100}});var r,n,i,s,a,o,u=this.bytesWritten-e,h=(r=this.dirRecords.length,n=u,i=e,s=this.zipComment,a=this.encodeFileName,o=O.transformTo(\"string\",a(s)),R.CENTRAL_DIRECTORY_END+\"\\0\\0\\0\\0\"+I(r,2)+I(r,2)+I(n,4)+I(i,4)+I(o.length,2)+o);this.push({data:h,meta:{percent:100}})},n.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},n.prototype.registerPrevious=function(e){this._sources.push(e);var t=this;return e.on(\"data\",function(e){t.processChunk(e)}),e.on(\"end\",function(){t.closedSource(t.previous.streamInfo),t._sources.length?t.prepareNextSource():t.end()}),e.on(\"error\",function(e){t.error(e)}),this},n.prototype.resume=function(){return!!s.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},n.prototype.error=function(e){var t=this._sources;if(!s.prototype.error.call(this,e))return!1;for(var r=0;r<t.length;r++)try{t[r].error(e)}catch(e){}return!0},n.prototype.lock=function(){s.prototype.lock.call(this);for(var e=this._sources,t=0;t<e.length;t++)e[t].lock()},t.exports=n},{\"..\/crc32\":4,\"..\/signature\":23,\"..\/stream\/GenericWorker\":28,\"..\/utf8\":31,\"..\/utils\":32}],9:[function(e,t,r){\"use strict\";var h=e(\"..\/compressions\"),n=e(\".\/ZipFileWorker\");r.generateWorker=function(e,a,t){var o=new n(a.streamFiles,t,a.platform,a.encodeFileName),u=0;try{e.forEach(function(e,t){u++;var r=function(e,t){var r=e||t,n=h[r];if(!n)throw new Error(r+\" is not a valid compression method !\");return n}(t.options.compression,a.compression),n=t.options.compressionOptions||a.compressionOptions||{},i=t.dir,s=t.date;t._compressWorker(r,n).withStreamInfo(\"file\",{name:e,dir:i,date:s,comment:t.comment||\"\",unixPermissions:t.unixPermissions,dosPermissions:t.dosPermissions}).pipe(o)}),o.entriesCount=u}catch(e){o.error(e)}return o}},{\"..\/compressions\":3,\".\/ZipFileWorker\":8}],10:[function(e,t,r){\"use strict\";function n(){if(!(this instanceof n))return new n;if(arguments.length)throw new Error(\"The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.\");this.files={},this.comment=null,this.root=\"\",this.clone=function(){var e=new n;for(var t in this)\"function\"!=typeof this[t]&&(e[t]=this[t]);return e}}(n.prototype=e(\".\/object\")).loadAsync=e(\".\/load\"),n.support=e(\".\/support\"),n.defaults=e(\".\/defaults\"),n.version=\"3.5.0\",n.loadAsync=function(e,t){return(new n).loadAsync(e,t)},n.external=e(\".\/external\"),t.exports=n},{\".\/defaults\":5,\".\/external\":6,\".\/load\":11,\".\/object\":15,\".\/support\":30}],11:[function(e,t,r){\"use strict\";var n=e(\".\/utils\"),i=e(\".\/external\"),o=e(\".\/utf8\"),u=e(\".\/zipEntries\"),s=e(\".\/stream\/Crc32Probe\"),h=e(\".\/nodejsUtils\");function f(n){return new i.Promise(function(e,t){var r=n.decompressed.getContentWorker().pipe(new s);r.on(\"error\",function(e){t(e)}).on(\"end\",function(){r.streamInfo.crc32!==n.decompressed.crc32?t(new Error(\"Corrupted zip : CRC32 mismatch\")):e()}).resume()})}t.exports=function(e,s){var a=this;return s=n.extend(s||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:o.utf8decode}),h.isNode&&h.isStream(e)?i.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\")):n.prepareContent(\"the loaded zip file\",e,!0,s.optimizedBinaryString,s.base64).then(function(e){var t=new u(s);return t.load(e),t}).then(function(e){var t=[i.Promise.resolve(e)],r=e.files;if(s.checkCRC32)for(var n=0;n<r.length;n++)t.push(f(r[n]));return i.Promise.all(t)}).then(function(e){for(var t=e.shift(),r=t.files,n=0;n<r.length;n++){var i=r[n];a.file(i.fileNameStr,i.decompressed,{binary:!0,optimizedBinaryString:!0,date:i.date,dir:i.dir,comment:i.fileCommentStr.length?i.fileCommentStr:null,unixPermissions:i.unixPermissions,dosPermissions:i.dosPermissions,createFolders:s.createFolders})}return t.zipComment.length&&(a.comment=t.zipComment),a})}},{\".\/external\":6,\".\/nodejsUtils\":14,\".\/stream\/Crc32Probe\":25,\".\/utf8\":31,\".\/utils\":32,\".\/zipEntries\":33}],12:[function(e,t,r){\"use strict\";var n=e(\"..\/utils\"),i=e(\"..\/stream\/GenericWorker\");function s(e,t){i.call(this,\"Nodejs stream input adapter for \"+e),this._upstreamEnded=!1,this._bindStream(t)}n.inherits(s,i),s.prototype._bindStream=function(e){var t=this;(this._stream=e).pause(),e.on(\"data\",function(e){t.push({data:e,meta:{percent:0}})}).on(\"error\",function(e){t.isPaused?this.generatedError=e:t.error(e)}).on(\"end\",function(){t.isPaused?t._upstreamEnded=!0:t.end()})},s.prototype.pause=function(){return!!i.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return!!i.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},t.exports=s},{\"..\/stream\/GenericWorker\":28,\"..\/utils\":32}],13:[function(e,t,r){\"use strict\";var i=e(\"readable-stream\").Readable;function n(e,t,r){i.call(this,t),this._helper=e;var n=this;e.on(\"data\",function(e,t){n.push(e)||n._helper.pause(),r&&r(t)}).on(\"error\",function(e){n.emit(\"error\",e)}).on(\"end\",function(){n.push(null)})}e(\"..\/utils\").inherits(n,i),n.prototype._read=function(){this._helper.resume()},t.exports=n},{\"..\/utils\":32,\"readable-stream\":16}],14:[function(e,t,r){\"use strict\";t.exports={isNode:\"undefined\"!=typeof Buffer,newBufferFrom:function(e,t){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(e,t);if(\"number\"==typeof e)throw new Error('The \"data\" argument must not be a number');return new Buffer(e,t)},allocBuffer:function(e){if(Buffer.alloc)return Buffer.alloc(e);var t=new Buffer(e);return t.fill(0),t},isBuffer:function(e){return Buffer.isBuffer(e)},isStream:function(e){return e&&\"function\"==typeof e.on&&\"function\"==typeof e.pause&&\"function\"==typeof e.resume}}},{}],15:[function(e,t,r){\"use strict\";function s(e,t,r){var n,i=f.getTypeOf(t),s=f.extend(r||{},d);s.date=s.date||new Date,null!==s.compression&&(s.compression=s.compression.toUpperCase()),\"string\"==typeof s.unixPermissions&&(s.unixPermissions=parseInt(s.unixPermissions,8)),s.unixPermissions&&16384&s.unixPermissions&&(s.dir=!0),s.dosPermissions&&16&s.dosPermissions&&(s.dir=!0),s.dir&&(e=h(e)),s.createFolders&&(n=function(e){\"\/\"===e.slice(-1)&&(e=e.substring(0,e.length-1));var t=e.lastIndexOf(\"\/\");return 0<t?e.substring(0,t):\"\"}(e))&&g.call(this,n,!0);var a,o=\"string\"===i&&!1===s.binary&&!1===s.base64;r&&void 0!==r.binary||(s.binary=!o),(t instanceof c&&0===t.uncompressedSize||s.dir||!t||0===t.length)&&(s.base64=!1,s.binary=!0,t=\"\",s.compression=\"STORE\",i=\"string\"),a=t instanceof c||t instanceof l?t:m.isNode&&m.isStream(t)?new _(e,t):f.prepareContent(e,t,s.binary,s.optimizedBinaryString,s.base64);var u=new p(e,a,s);this.files[e]=u}function h(e){return\"\/\"!==e.slice(-1)&&(e+=\"\/\"),e}var i=e(\".\/utf8\"),f=e(\".\/utils\"),l=e(\".\/stream\/GenericWorker\"),a=e(\".\/stream\/StreamHelper\"),d=e(\".\/defaults\"),c=e(\".\/compressedObject\"),p=e(\".\/zipObject\"),o=e(\".\/generate\"),m=e(\".\/nodejsUtils\"),_=e(\".\/nodejs\/NodejsStreamInputAdapter\"),g=function(e,t){return t=void 0!==t?t:d.createFolders,e=h(e),this.files[e]||s.call(this,e,null,{dir:!0,createFolders:t}),this.files[e]};function u(e){return\"[object RegExp]\"===Object.prototype.toString.call(e)}var n={load:function(){throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\")},forEach:function(e){var t,r,n;for(t in this.files)this.files.hasOwnProperty(t)&&(n=this.files[t],(r=t.slice(this.root.length,t.length))&&t.slice(0,this.root.length)===this.root&&e(r,n))},filter:function(r){var n=[];return this.forEach(function(e,t){r(e,t)&&n.push(t)}),n},file:function(e,t,r){if(1!==arguments.length)return e=this.root+e,s.call(this,e,t,r),this;if(u(e)){var n=e;return this.filter(function(e,t){return!t.dir&&n.test(e)})}var i=this.files[this.root+e];return i&&!i.dir?i:null},folder:function(r){if(!r)return this;if(u(r))return this.filter(function(e,t){return t.dir&&r.test(e)});var e=this.root+r,t=g.call(this,e),n=this.clone();return n.root=t.name,n},remove:function(r){r=this.root+r;var e=this.files[r];if(e||(\"\/\"!==r.slice(-1)&&(r+=\"\/\"),e=this.files[r]),e&&!e.dir)delete this.files[r];else for(var t=this.filter(function(e,t){return t.name.slice(0,r.length)===r}),n=0;n<t.length;n++)delete this.files[t[n].name];return this},generate:function(e){throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\")},generateInternalStream:function(e){var t,r={};try{if((r=f.extend(e||{},{streamFiles:!1,compression:\"STORE\",compressionOptions:null,type:\"\",platform:\"DOS\",comment:null,mimeType:\"application\/zip\",encodeFileName:i.utf8encode})).type=r.type.toLowerCase(),r.compression=r.compression.toUpperCase(),\"binarystring\"===r.type&&(r.type=\"string\"),!r.type)throw new Error(\"No output type specified.\");f.checkSupport(r.type),\"darwin\"!==r.platform&&\"freebsd\"!==r.platform&&\"linux\"!==r.platform&&\"sunos\"!==r.platform||(r.platform=\"UNIX\"),\"win32\"===r.platform&&(r.platform=\"DOS\");var n=r.comment||this.comment||\"\";t=o.generateWorker(this,r,n)}catch(e){(t=new l(\"error\")).error(e)}return new a(t,r.type||\"string\",r.mimeType)},generateAsync:function(e,t){return this.generateInternalStream(e).accumulate(t)},generateNodeStream:function(e,t){return(e=e||{}).type||(e.type=\"nodebuffer\"),this.generateInternalStream(e).toNodejsStream(t)}};t.exports=n},{\".\/compressedObject\":2,\".\/defaults\":5,\".\/generate\":9,\".\/nodejs\/NodejsStreamInputAdapter\":12,\".\/nodejsUtils\":14,\".\/stream\/GenericWorker\":28,\".\/stream\/StreamHelper\":29,\".\/utf8\":31,\".\/utils\":32,\".\/zipObject\":35}],16:[function(e,t,r){t.exports=e(\"stream\")},{stream:void 0}],17:[function(e,t,r){\"use strict\";var n=e(\".\/DataReader\");function i(e){n.call(this,e);for(var t=0;t<this.data.length;t++)e[t]=255&e[t]}e(\"..\/utils\").inherits(i,n),i.prototype.byteAt=function(e){return this.data[this.zero+e]},i.prototype.lastIndexOfSignature=function(e){for(var t=e.charCodeAt(0),r=e.charCodeAt(1),n=e.charCodeAt(2),i=e.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===t&&this.data[s+1]===r&&this.data[s+2]===n&&this.data[s+3]===i)return s-this.zero;return-1},i.prototype.readAndCheckSignature=function(e){var t=e.charCodeAt(0),r=e.charCodeAt(1),n=e.charCodeAt(2),i=e.charCodeAt(3),s=this.readData(4);return t===s[0]&&r===s[1]&&n===s[2]&&i===s[3]},i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return[];var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i},{\"..\/utils\":32,\".\/DataReader\":18}],18:[function(e,t,r){\"use strict\";var n=e(\"..\/utils\");function i(e){this.data=e,this.length=e.length,this.index=0,this.zero=0}i.prototype={checkOffset:function(e){this.checkIndex(this.index+e)},checkIndex:function(e){if(this.length<this.zero+e||e<0)throw new Error(\"End of data reached (data length = \"+this.length+\", asked index = \"+e+\"). Corrupted zip ?\")},setIndex:function(e){this.checkIndex(e),this.index=e},skip:function(e){this.setIndex(this.index+e)},byteAt:function(e){},readInt:function(e){var t,r=0;for(this.checkOffset(e),t=this.index+e-1;t>=this.index;t--)r=(r<<8)+this.byteAt(t);return this.index+=e,r},readString:function(e){return n.transformTo(\"string\",this.readData(e))},readData:function(e){},lastIndexOfSignature:function(e){},readAndCheckSignature:function(e){},readDate:function(){var e=this.readInt(4);return new Date(Date.UTC(1980+(e>>25&127),(e>>21&15)-1,e>>16&31,e>>11&31,e>>5&63,(31&e)<<1))}},t.exports=i},{\"..\/utils\":32}],19:[function(e,t,r){\"use strict\";var n=e(\".\/Uint8ArrayReader\");function i(e){n.call(this,e)}e(\"..\/utils\").inherits(i,n),i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i},{\"..\/utils\":32,\".\/Uint8ArrayReader\":21}],20:[function(e,t,r){\"use strict\";var n=e(\".\/DataReader\");function i(e){n.call(this,e)}e(\"..\/utils\").inherits(i,n),i.prototype.byteAt=function(e){return this.data.charCodeAt(this.zero+e)},i.prototype.lastIndexOfSignature=function(e){return this.data.lastIndexOf(e)-this.zero},i.prototype.readAndCheckSignature=function(e){return e===this.readData(4)},i.prototype.readData=function(e){this.checkOffset(e);var t=this.data.slice(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i},{\"..\/utils\":32,\".\/DataReader\":18}],21:[function(e,t,r){\"use strict\";var n=e(\".\/ArrayReader\");function i(e){n.call(this,e)}e(\"..\/utils\").inherits(i,n),i.prototype.readData=function(e){if(this.checkOffset(e),0===e)return new Uint8Array(0);var t=this.data.subarray(this.zero+this.index,this.zero+this.index+e);return this.index+=e,t},t.exports=i},{\"..\/utils\":32,\".\/ArrayReader\":17}],22:[function(e,t,r){\"use strict\";var n=e(\"..\/utils\"),i=e(\"..\/support\"),s=e(\".\/ArrayReader\"),a=e(\".\/StringReader\"),o=e(\".\/NodeBufferReader\"),u=e(\".\/Uint8ArrayReader\");t.exports=function(e){var t=n.getTypeOf(e);return n.checkSupport(t),\"string\"!==t||i.uint8array?\"nodebuffer\"===t?new o(e):i.uint8array?new u(n.transformTo(\"uint8array\",e)):new s(n.transformTo(\"array\",e)):new a(e)}},{\"..\/support\":30,\"..\/utils\":32,\".\/ArrayReader\":17,\".\/NodeBufferReader\":19,\".\/StringReader\":20,\".\/Uint8ArrayReader\":21}],23:[function(e,t,r){\"use strict\";r.LOCAL_FILE_HEADER=\"PK\",r.CENTRAL_FILE_HEADER=\"PK\",r.CENTRAL_DIRECTORY_END=\"PK\",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR=\"PK\",r.ZIP64_CENTRAL_DIRECTORY_END=\"PK\",r.DATA_DESCRIPTOR=\"PK\\b\"},{}],24:[function(e,t,r){\"use strict\";var n=e(\".\/GenericWorker\"),i=e(\"..\/utils\");function s(e){n.call(this,\"ConvertWorker to \"+e),this.destType=e}i.inherits(s,n),s.prototype.processChunk=function(e){this.push({data:i.transformTo(this.destType,e.data),meta:e.meta})},t.exports=s},{\"..\/utils\":32,\".\/GenericWorker\":28}],25:[function(e,t,r){\"use strict\";var n=e(\".\/GenericWorker\"),i=e(\"..\/crc32\");function s(){n.call(this,\"Crc32Probe\"),this.withStreamInfo(\"crc32\",0)}e(\"..\/utils\").inherits(s,n),s.prototype.processChunk=function(e){this.streamInfo.crc32=i(e.data,this.streamInfo.crc32||0),this.push(e)},t.exports=s},{\"..\/crc32\":4,\"..\/utils\":32,\".\/GenericWorker\":28}],26:[function(e,t,r){\"use strict\";var n=e(\"..\/utils\"),i=e(\".\/GenericWorker\");function s(e){i.call(this,\"DataLengthProbe for \"+e),this.propName=e,this.withStreamInfo(e,0)}n.inherits(s,i),s.prototype.processChunk=function(e){if(e){var t=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=t+e.data.length}i.prototype.processChunk.call(this,e)},t.exports=s},{\"..\/utils\":32,\".\/GenericWorker\":28}],27:[function(e,t,r){\"use strict\";var n=e(\"..\/utils\"),i=e(\".\/GenericWorker\");function s(e){i.call(this,\"DataWorker\");var t=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type=\"\",this._tickScheduled=!1,e.then(function(e){t.dataIsReady=!0,t.data=e,t.max=e&&e.length||0,t.type=n.getTypeOf(e),t.isPaused||t._tickAndRepeat()},function(e){t.error(e)})}n.inherits(s,i),s.prototype.cleanUp=function(){i.prototype.cleanUp.call(this),this.data=null},s.prototype.resume=function(){return!!i.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,n.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(n.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var e=null,t=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case\"string\":e=this.data.substring(this.index,t);break;case\"uint8array\":e=this.data.subarray(this.index,t);break;case\"array\":case\"nodebuffer\":e=this.data.slice(this.index,t)}return this.index=t,this.push({data:e,meta:{percent:this.max?this.index\/this.max*100:0}})},t.exports=s},{\"..\/utils\":32,\".\/GenericWorker\":28}],28:[function(e,t,r){\"use strict\";function n(e){this.name=e||\"default\",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}n.prototype={push:function(e){this.emit(\"data\",e)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit(\"end\"),this.cleanUp(),this.isFinished=!0}catch(e){this.emit(\"error\",e)}return!0},error:function(e){return!this.isFinished&&(this.isPaused?this.generatedError=e:(this.isFinished=!0,this.emit(\"error\",e),this.previous&&this.previous.error(e),this.cleanUp()),!0)},on:function(e,t){return this._listeners[e].push(t),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(e,t){if(this._listeners[e])for(var r=0;r<this._listeners[e].length;r++)this._listeners[e][r].call(this,t)},pipe:function(e){return e.registerPrevious(this)},registerPrevious:function(e){if(this.isLocked)throw new Error(\"The stream '\"+this+\"' has already been used.\");this.streamInfo=e.streamInfo,this.mergeStreamInfo(),this.previous=e;var t=this;return e.on(\"data\",function(e){t.processChunk(e)}),e.on(\"end\",function(){t.end()}),e.on(\"error\",function(e){t.error(e)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var e=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),e=!0),this.previous&&this.previous.resume(),!e},flush:function(){},processChunk:function(e){this.push(e)},withStreamInfo:function(e,t){return this.extraStreamInfo[e]=t,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var e in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(e)&&(this.streamInfo[e]=this.extraStreamInfo[e])},lock:function(){if(this.isLocked)throw new Error(\"The stream '\"+this+\"' has already been used.\");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var e=\"Worker \"+this.name;return this.previous?this.previous+\" -> \"+e:e}},t.exports=n},{}],29:[function(e,t,r){\"use strict\";var h=e(\"..\/utils\"),i=e(\".\/ConvertWorker\"),s=e(\".\/GenericWorker\"),f=e(\"..\/base64\"),n=e(\"..\/support\"),a=e(\"..\/external\"),o=null;if(n.nodestream)try{o=e(\"..\/nodejs\/NodejsStreamOutputAdapter\")}catch(e){}function u(e,t,r){var n=t;switch(t){case\"blob\":case\"arraybuffer\":n=\"uint8array\";break;case\"base64\":n=\"string\"}try{this._internalType=n,this._outputType=t,this._mimeType=r,h.checkSupport(n),this._worker=e.pipe(new i(n)),e.lock()}catch(e){this._worker=new s(\"error\"),this._worker.error(e)}}u.prototype={accumulate:function(e){return o=this,u=e,new a.Promise(function(t,r){var n=[],i=o._internalType,s=o._outputType,a=o._mimeType;o.on(\"data\",function(e,t){n.push(e),u&&u(t)}).on(\"error\",function(e){n=[],r(e)}).on(\"end\",function(){try{var e=function(e,t,r){switch(e){case\"blob\":return h.newBlob(h.transformTo(\"arraybuffer\",t),r);case\"base64\":return f.encode(t);default:return h.transformTo(e,t)}}(s,function(e,t){var r,n=0,i=null,s=0;for(r=0;r<t.length;r++)s+=t[r].length;switch(e){case\"string\":return t.join(\"\");case\"array\":return Array.prototype.concat.apply([],t);case\"uint8array\":for(i=new Uint8Array(s),r=0;r<t.length;r++)i.set(t[r],n),n+=t[r].length;return i;case\"nodebuffer\":return Buffer.concat(t);default:throw new Error(\"concat : unsupported type '\"+e+\"'\")}}(i,n),a);t(e)}catch(e){r(e)}n=[]}).resume()});var o,u},on:function(e,t){var r=this;return\"data\"===e?this._worker.on(e,function(e){t.call(r,e.data,e.meta)}):this._worker.on(e,function(){h.delay(t,arguments,r)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(e){if(h.checkSupport(\"nodestream\"),\"nodebuffer\"!==this._outputType)throw new Error(this._outputType+\" is not supported by this method\");return new o(this,{objectMode:\"nodebuffer\"!==this._outputType},e)}},t.exports=u},{\"..\/base64\":1,\"..\/external\":6,\"..\/nodejs\/NodejsStreamOutputAdapter\":13,\"..\/support\":30,\"..\/utils\":32,\".\/ConvertWorker\":24,\".\/GenericWorker\":28}],30:[function(e,t,r){\"use strict\";if(r.base64=!0,r.array=!0,r.string=!0,r.arraybuffer=\"undefined\"!=typeof ArrayBuffer&&\"undefined\"!=typeof Uint8Array,r.nodebuffer=\"undefined\"!=typeof Buffer,r.uint8array=\"undefined\"!=typeof Uint8Array,\"undefined\"==typeof ArrayBuffer)r.blob=!1;else{var n=new ArrayBuffer(0);try{r.blob=0===new Blob([n],{type:\"application\/zip\"}).size}catch(e){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);i.append(n),r.blob=0===i.getBlob(\"application\/zip\").size}catch(e){r.blob=!1}}}try{r.nodestream=!!e(\"readable-stream\").Readable}catch(e){r.nodestream=!1}},{\"readable-stream\":16}],31:[function(e,t,s){\"use strict\";for(var o=e(\".\/utils\"),u=e(\".\/support\"),r=e(\".\/nodejsUtils\"),n=e(\".\/stream\/GenericWorker\"),h=new Array(256),i=0;i<256;i++)h[i]=252<=i?6:248<=i?5:240<=i?4:224<=i?3:192<=i?2:1;function a(){n.call(this,\"utf-8 decode\"),this.leftOver=null}function f(){n.call(this,\"utf-8 encode\")}h[254]=h[254]=1,s.utf8encode=function(e){return u.nodebuffer?r.newBufferFrom(e,\"utf-8\"):function(e){var t,r,n,i,s,a=e.length,o=0;for(i=0;i<a;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),o+=r<128?1:r<2048?2:r<65536?3:4;for(t=u.uint8array?new Uint8Array(o):new Array(o),i=s=0;s<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[s++]=r:(r<2048?t[s++]=192|r>>>6:(r<65536?t[s++]=224|r>>>12:(t[s++]=240|r>>>18,t[s++]=128|r>>>12&63),t[s++]=128|r>>>6&63),t[s++]=128|63&r);return t}(e)},s.utf8decode=function(e){return u.nodebuffer?o.transformTo(\"nodebuffer\",e).toString(\"utf-8\"):function(e){var t,r,n,i,s=e.length,a=new Array(2*s);for(t=r=0;t<s;)if((n=e[t++])<128)a[r++]=n;else if(4<(i=h[n]))a[r++]=65533,t+=i-1;else{for(n&=2===i?31:3===i?15:7;1<i&&t<s;)n=n<<6|63&e[t++],i--;1<i?a[r++]=65533:n<65536?a[r++]=n:(n-=65536,a[r++]=55296|n>>10&1023,a[r++]=56320|1023&n)}return a.length!==r&&(a.subarray?a=a.subarray(0,r):a.length=r),o.applyFromCharCode(a)}(e=o.transformTo(u.uint8array?\"uint8array\":\"array\",e))},o.inherits(a,n),a.prototype.processChunk=function(e){var t=o.transformTo(u.uint8array?\"uint8array\":\"array\",e.data);if(this.leftOver&&this.leftOver.length){if(u.uint8array){var r=t;(t=new Uint8Array(r.length+this.leftOver.length)).set(this.leftOver,0),t.set(r,this.leftOver.length)}else t=this.leftOver.concat(t);this.leftOver=null}var n=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;0<=r&&128==(192&e[r]);)r--;return r<0?t:0===r?t:r+h[e[r]]>t?r:t}(t),i=t;n!==t.length&&(u.uint8array?(i=t.subarray(0,n),this.leftOver=t.subarray(n,t.length)):(i=t.slice(0,n),this.leftOver=t.slice(n,t.length))),this.push({data:s.utf8decode(i),meta:e.meta})},a.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},s.Utf8DecodeWorker=a,o.inherits(f,n),f.prototype.processChunk=function(e){this.push({data:s.utf8encode(e.data),meta:e.meta})},s.Utf8EncodeWorker=f},{\".\/nodejsUtils\":14,\".\/stream\/GenericWorker\":28,\".\/support\":30,\".\/utils\":32}],32:[function(e,t,o){\"use strict\";var u=e(\".\/support\"),h=e(\".\/base64\"),r=e(\".\/nodejsUtils\"),n=e(\"set-immediate-shim\"),f=e(\".\/external\");function i(e){return e}function l(e,t){for(var r=0;r<e.length;++r)t[r]=255&e.charCodeAt(r);return t}o.newBlob=function(t,r){o.checkSupport(\"blob\");try{return new Blob([t],{type:r})}catch(e){try{var n=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return n.append(t),n.getBlob(r)}catch(e){throw new Error(\"Bug : can't construct the Blob.\")}}};var s={stringifyByChunk:function(e,t,r){var n=[],i=0,s=e.length;if(s<=r)return String.fromCharCode.apply(null,e);for(;i<s;)\"array\"===t||\"nodebuffer\"===t?n.push(String.fromCharCode.apply(null,e.slice(i,Math.min(i+r,s)))):n.push(String.fromCharCode.apply(null,e.subarray(i,Math.min(i+r,s)))),i+=r;return n.join(\"\")},stringifyByChar:function(e){for(var t=\"\",r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t},applyCanBeUsed:{uint8array:function(){try{return u.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(e){return!1}}(),nodebuffer:function(){try{return u.nodebuffer&&1===String.fromCharCode.apply(null,r.allocBuffer(1)).length}catch(e){return!1}}()}};function a(e){var t=65536,r=o.getTypeOf(e),n=!0;if(\"uint8array\"===r?n=s.applyCanBeUsed.uint8array:\"nodebuffer\"===r&&(n=s.applyCanBeUsed.nodebuffer),n)for(;1<t;)try{return s.stringifyByChunk(e,r,t)}catch(e){t=Math.floor(t\/2)}return s.stringifyByChar(e)}function d(e,t){for(var r=0;r<e.length;r++)t[r]=e[r];return t}o.applyFromCharCode=a;var c={};c.string={string:i,array:function(e){return l(e,new Array(e.length))},arraybuffer:function(e){return c.string.uint8array(e).buffer},uint8array:function(e){return l(e,new Uint8Array(e.length))},nodebuffer:function(e){return l(e,r.allocBuffer(e.length))}},c.array={string:a,array:i,arraybuffer:function(e){return new Uint8Array(e).buffer},uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return r.newBufferFrom(e)}},c.arraybuffer={string:function(e){return a(new Uint8Array(e))},array:function(e){return d(new Uint8Array(e),new Array(e.byteLength))},arraybuffer:i,uint8array:function(e){return new Uint8Array(e)},nodebuffer:function(e){return r.newBufferFrom(new Uint8Array(e))}},c.uint8array={string:a,array:function(e){return d(e,new Array(e.length))},arraybuffer:function(e){return e.buffer},uint8array:i,nodebuffer:function(e){return r.newBufferFrom(e)}},c.nodebuffer={string:a,array:function(e){return d(e,new Array(e.length))},arraybuffer:function(e){return c.nodebuffer.uint8array(e).buffer},uint8array:function(e){return d(e,new Uint8Array(e.length))},nodebuffer:i},o.transformTo=function(e,t){if(t=t||\"\",!e)return t;o.checkSupport(e);var r=o.getTypeOf(t);return c[r][e](t)},o.getTypeOf=function(e){return\"string\"==typeof e?\"string\":\"[object Array]\"===Object.prototype.toString.call(e)?\"array\":u.nodebuffer&&r.isBuffer(e)?\"nodebuffer\":u.uint8array&&e instanceof Uint8Array?\"uint8array\":u.arraybuffer&&e instanceof ArrayBuffer?\"arraybuffer\":void 0},o.checkSupport=function(e){if(!u[e.toLowerCase()])throw new Error(e+\" is not supported by this platform\")},o.MAX_VALUE_16BITS=65535,o.MAX_VALUE_32BITS=-1,o.pretty=function(e){var t,r,n=\"\";for(r=0;r<(e||\"\").length;r++)n+=\"\\\\x\"+((t=e.charCodeAt(r))<16?\"0\":\"\")+t.toString(16).toUpperCase();return n},o.delay=function(e,t,r){n(function(){e.apply(r||null,t||[])})},o.inherits=function(e,t){function r(){}r.prototype=t.prototype,e.prototype=new r},o.extend=function(){var e,t,r={};for(e=0;e<arguments.length;e++)for(t in arguments[e])arguments[e].hasOwnProperty(t)&&void 0===r[t]&&(r[t]=arguments[e][t]);return r},o.prepareContent=function(n,e,i,s,a){return f.Promise.resolve(e).then(function(n){return u.blob&&(n instanceof Blob||-1!==[\"[object File]\",\"[object Blob]\"].indexOf(Object.prototype.toString.call(n)))&&\"undefined\"!=typeof FileReader?new f.Promise(function(t,r){var e=new FileReader;e.onload=function(e){t(e.target.result)},e.onerror=function(e){r(e.target.error)},e.readAsArrayBuffer(n)}):n}).then(function(e){var t,r=o.getTypeOf(e);return r?(\"arraybuffer\"===r?e=o.transformTo(\"uint8array\",e):\"string\"===r&&(a?e=h.decode(e):i&&!0!==s&&(e=l(t=e,u.uint8array?new Uint8Array(t.length):new Array(t.length)))),e):f.Promise.reject(new Error(\"Can't read the data of '\"+n+\"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\"))})}},{\".\/base64\":1,\".\/external\":6,\".\/nodejsUtils\":14,\".\/support\":30,\"set-immediate-shim\":54}],33:[function(e,t,r){\"use strict\";var n=e(\".\/reader\/readerFor\"),i=e(\".\/utils\"),s=e(\".\/signature\"),a=e(\".\/zipEntry\"),o=(e(\".\/utf8\"),e(\".\/support\"));function u(e){this.files=[],this.loadOptions=e}u.prototype={checkSignature:function(e){if(!this.reader.readAndCheckSignature(e)){this.reader.index-=4;var t=this.reader.readString(4);throw new Error(\"Corrupted zip or bug: unexpected signature (\"+i.pretty(t)+\", expected \"+i.pretty(e)+\")\")}},isSignature:function(e,t){var r=this.reader.index;this.reader.setIndex(e);var n=this.reader.readString(4)===t;return this.reader.setIndex(r),n},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var e=this.reader.readData(this.zipCommentLength),t=o.uint8array?\"uint8array\":\"array\",r=i.transformTo(t,e);this.zipComment=this.loadOptions.decodeFileName(r)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var e,t,r,n=this.zip64EndOfCentralSize-44;0<n;)e=this.reader.readInt(2),t=this.reader.readInt(4),r=this.reader.readData(t),this.zip64ExtensibleData[e]={id:e,length:t,value:r}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error(\"Multi-volumes zip are not supported\")},readLocalFiles:function(){var e,t;for(e=0;e<this.files.length;e++)t=this.files[e],this.reader.setIndex(t.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),t.readLocalPart(this.reader),t.handleUTF8(),t.processAttributes()},readCentralDir:function(){var e;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(e=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(e);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error(\"Corrupted zip or bug: expected \"+this.centralDirRecords+\" records in central dir, got \"+this.files.length)},readEndOfCentral:function(){var e=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(e<0)throw this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error(\"Corrupted zip: can't find end of central directory\"):new Error(\"Can't find end of central directory : is this a zip file ? If it is, see https:\/\/stuk.github.io\/jszip\/documentation\/howto\/read_zip.html\");this.reader.setIndex(e);var t=e;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===i.MAX_VALUE_16BITS||this.diskWithCentralDirStart===i.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===i.MAX_VALUE_16BITS||this.centralDirRecords===i.MAX_VALUE_16BITS||this.centralDirSize===i.MAX_VALUE_32BITS||this.centralDirOffset===i.MAX_VALUE_32BITS){if(this.zip64=!0,(e=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory locator\");if(this.reader.setIndex(e),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory\");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var r=this.centralDirOffset+this.centralDirSize;this.zip64&&(r+=20,r+=12+this.zip64EndOfCentralSize);var n=t-r;if(0<n)this.isSignature(t,s.CENTRAL_FILE_HEADER)||(this.reader.zero=n);else if(n<0)throw new Error(\"Corrupted zip: missing \"+Math.abs(n)+\" bytes.\")},prepareReader:function(e){this.reader=n(e)},load:function(e){this.prepareReader(e),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},t.exports=u},{\".\/reader\/readerFor\":22,\".\/signature\":23,\".\/support\":30,\".\/utf8\":31,\".\/utils\":32,\".\/zipEntry\":34}],34:[function(e,t,r){\"use strict\";var n=e(\".\/reader\/readerFor\"),s=e(\".\/utils\"),i=e(\".\/compressedObject\"),a=e(\".\/crc32\"),o=e(\".\/utf8\"),u=e(\".\/compressions\"),h=e(\".\/support\");function f(e,t){this.options=e,this.loadOptions=t}f.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(e){var t,r;if(e.skip(22),this.fileNameLength=e.readInt(2),r=e.readInt(2),this.fileName=e.readData(this.fileNameLength),e.skip(r),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error(\"Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)\");if(null===(t=function(e){for(var t in u)if(u.hasOwnProperty(t)&&u[t].magic===e)return u[t];return null}(this.compressionMethod)))throw new Error(\"Corrupted zip : compression \"+s.pretty(this.compressionMethod)+\" unknown (inner file : \"+s.transformTo(\"string\",this.fileName)+\")\");this.decompressed=new i(this.compressedSize,this.uncompressedSize,this.crc32,t,e.readData(this.compressedSize))},readCentralPart:function(e){this.versionMadeBy=e.readInt(2),e.skip(2),this.bitFlag=e.readInt(2),this.compressionMethod=e.readString(2),this.date=e.readDate(),this.crc32=e.readInt(4),this.compressedSize=e.readInt(4),this.uncompressedSize=e.readInt(4);var t=e.readInt(2);if(this.extraFieldsLength=e.readInt(2),this.fileCommentLength=e.readInt(2),this.diskNumberStart=e.readInt(2),this.internalFileAttributes=e.readInt(2),this.externalFileAttributes=e.readInt(4),this.localHeaderOffset=e.readInt(4),this.isEncrypted())throw new Error(\"Encrypted zip are not supported\");e.skip(t),this.readExtraFields(e),this.parseZIP64ExtraField(e),this.fileComment=e.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var e=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==e&&(this.dosPermissions=63&this.externalFileAttributes),3==e&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||\"\/\"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(e){if(this.extraFields[1]){var t=n(this.extraFields[1].value);this.uncompressedSize===s.MAX_VALUE_32BITS&&(this.uncompressedSize=t.readInt(8)),this.compressedSize===s.MAX_VALUE_32BITS&&(this.compressedSize=t.readInt(8)),this.localHeaderOffset===s.MAX_VALUE_32BITS&&(this.localHeaderOffset=t.readInt(8)),this.diskNumberStart===s.MAX_VALUE_32BITS&&(this.diskNumberStart=t.readInt(4))}},readExtraFields:function(e){var t,r,n,i=e.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});e.index+4<i;)t=e.readInt(2),r=e.readInt(2),n=e.readData(r),this.extraFields[t]={id:t,length:r,value:n};e.setIndex(i)},handleUTF8:function(){var e=h.uint8array?\"uint8array\":\"array\";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else{var t=this.findExtraFieldUnicodePath();if(null!==t)this.fileNameStr=t;else{var r=s.transformTo(e,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(r)}var n=this.findExtraFieldUnicodeComment();if(null!==n)this.fileCommentStr=n;else{var i=s.transformTo(e,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(i)}}},findExtraFieldUnicodePath:function(){var e=this.extraFields[28789];if(e){var t=n(e.value);return 1!==t.readInt(1)?null:a(this.fileName)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null},findExtraFieldUnicodeComment:function(){var e=this.extraFields[25461];if(e){var t=n(e.value);return 1!==t.readInt(1)?null:a(this.fileComment)!==t.readInt(4)?null:o.utf8decode(t.readData(e.length-5))}return null}},t.exports=f},{\".\/compressedObject\":2,\".\/compressions\":3,\".\/crc32\":4,\".\/reader\/readerFor\":22,\".\/support\":30,\".\/utf8\":31,\".\/utils\":32}],35:[function(e,t,r){\"use strict\";function n(e,t,r){this.name=e,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this.unixPermissions=r.unixPermissions,this.dosPermissions=r.dosPermissions,this._data=t,this._dataBinary=r.binary,this.options={compression:r.compression,compressionOptions:r.compressionOptions}}var s=e(\".\/stream\/StreamHelper\"),i=e(\".\/stream\/DataWorker\"),a=e(\".\/utf8\"),o=e(\".\/compressedObject\"),u=e(\".\/stream\/GenericWorker\");n.prototype={internalStream:function(e){var t=null,r=\"string\";try{if(!e)throw new Error(\"No output type specified.\");var n=\"string\"===(r=e.toLowerCase())||\"text\"===r;\"binarystring\"!==r&&\"text\"!==r||(r=\"string\"),t=this._decompressWorker();var i=!this._dataBinary;i&&!n&&(t=t.pipe(new a.Utf8EncodeWorker)),!i&&n&&(t=t.pipe(new a.Utf8DecodeWorker))}catch(e){(t=new u(\"error\")).error(e)}return new s(t,r,\"\")},async:function(e,t){return this.internalStream(e).accumulate(t)},nodeStream:function(e,t){return this.internalStream(e||\"nodebuffer\").toNodejsStream(t)},_compressWorker:function(e,t){if(this._data instanceof o&&this._data.compression.magic===e.magic)return this._data.getCompressedWorker();var r=this._decompressWorker();return this._dataBinary||(r=r.pipe(new a.Utf8EncodeWorker)),o.createWorkerFrom(r,e,t)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof u?this._data:new i(this._data)}};for(var h=[\"asText\",\"asBinary\",\"asNodeBuffer\",\"asUint8Array\",\"asArrayBuffer\"],f=function(){throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\")},l=0;l<h.length;l++)n.prototype[h[l]]=f;t.exports=n},{\".\/compressedObject\":2,\".\/stream\/DataWorker\":27,\".\/stream\/GenericWorker\":28,\".\/stream\/StreamHelper\":29,\".\/utf8\":31}],36:[function(e,f,t){(function(t){\"use strict\";var r,n,e=t.MutationObserver||t.WebKitMutationObserver;if(e){var i=0,s=new e(h),a=t.document.createTextNode(\"\");s.observe(a,{characterData:!0}),r=function(){a.data=i=++i%2}}else if(t.setImmediate||void 0===t.MessageChannel)r=\"document\"in t&&\"onreadystatechange\"in t.document.createElement(\"script\")?function(){var e=t.document.createElement(\"script\");e.onreadystatechange=function(){h(),e.onreadystatechange=null,e.parentNode.removeChild(e),e=null},t.document.documentElement.appendChild(e)}:function(){setTimeout(h,0)};else{var o=new t.MessageChannel;o.port1.onmessage=h,r=function(){o.port2.postMessage(0)}}var u=[];function h(){var e,t;n=!0;for(var r=u.length;r;){for(t=u,u=[],e=-1;++e<r;)t[e]();r=u.length}n=!1}f.exports=function(e){1!==u.push(e)||n||r()}}).call(this,void 0!==r?r:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}],37:[function(e,t,r){\"use strict\";var i=e(\"immediate\");function h(){}var f={},s=[\"REJECTED\"],a=[\"FULFILLED\"],n=[\"PENDING\"];function o(e){if(\"function\"!=typeof e)throw new TypeError(\"resolver must be a function\");this.state=n,this.queue=[],this.outcome=void 0,e!==h&&c(this,e)}function u(e,t,r){this.promise=e,\"function\"==typeof t&&(this.onFulfilled=t,this.callFulfilled=this.otherCallFulfilled),\"function\"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected)}function l(t,r,n){i(function(){var e;try{e=r(n)}catch(e){return f.reject(t,e)}e===t?f.reject(t,new TypeError(\"Cannot resolve promise with itself\")):f.resolve(t,e)})}function d(e){var t=e&&e.then;if(e&&(\"object\"==typeof e||\"function\"==typeof e)&&\"function\"==typeof t)return function(){t.apply(e,arguments)}}function c(t,e){var r=!1;function n(e){r||(r=!0,f.reject(t,e))}function i(e){r||(r=!0,f.resolve(t,e))}var s=p(function(){e(i,n)});\"error\"===s.status&&n(s.value)}function p(e,t){var r={};try{r.value=e(t),r.status=\"success\"}catch(e){r.status=\"error\",r.value=e}return r}(t.exports=o).prototype.finally=function(t){if(\"function\"!=typeof t)return this;var r=this.constructor;return this.then(function(e){return r.resolve(t()).then(function(){return e})},function(e){return r.resolve(t()).then(function(){throw e})})},o.prototype.catch=function(e){return this.then(null,e)},o.prototype.then=function(e,t){if(\"function\"!=typeof e&&this.state===a||\"function\"!=typeof t&&this.state===s)return this;var r=new this.constructor(h);return this.state!==n?l(r,this.state===a?e:t,this.outcome):this.queue.push(new u(r,e,t)),r},u.prototype.callFulfilled=function(e){f.resolve(this.promise,e)},u.prototype.otherCallFulfilled=function(e){l(this.promise,this.onFulfilled,e)},u.prototype.callRejected=function(e){f.reject(this.promise,e)},u.prototype.otherCallRejected=function(e){l(this.promise,this.onRejected,e)},f.resolve=function(e,t){var r=p(d,t);if(\"error\"===r.status)return f.reject(e,r.value);var n=r.value;if(n)c(e,n);else{e.state=a,e.outcome=t;for(var i=-1,s=e.queue.length;++i<s;)e.queue[i].callFulfilled(t)}return e},f.reject=function(e,t){e.state=s,e.outcome=t;for(var r=-1,n=e.queue.length;++r<n;)e.queue[r].callRejected(t);return e},o.resolve=function(e){return e instanceof this?e:f.resolve(new this(h),e)},o.reject=function(e){var t=new this(h);return f.reject(t,e)},o.all=function(e){var r=this;if(\"[object Array]\"!==Object.prototype.toString.call(e))return this.reject(new TypeError(\"must be an array\"));var n=e.length,i=!1;if(!n)return this.resolve([]);for(var s=new Array(n),a=0,t=-1,o=new this(h);++t<n;)u(e[t],t);return o;function u(e,t){r.resolve(e).then(function(e){s[t]=e,++a!==n||i||(i=!0,f.resolve(o,s))},function(e){i||(i=!0,f.reject(o,e))})}},o.race=function(e){if(\"[object Array]\"!==Object.prototype.toString.call(e))return this.reject(new TypeError(\"must be an array\"));var t=e.length,r=!1;if(!t)return this.resolve([]);for(var n,i=-1,s=new this(h);++i<t;)n=e[i],this.resolve(n).then(function(e){r||(r=!0,f.resolve(s,e))},function(e){r||(r=!0,f.reject(s,e))});return s}},{immediate:36}],38:[function(e,t,r){\"use strict\";var n={};(0,e(\".\/lib\/utils\/common\").assign)(n,e(\".\/lib\/deflate\"),e(\".\/lib\/inflate\"),e(\".\/lib\/zlib\/constants\")),t.exports=n},{\".\/lib\/deflate\":39,\".\/lib\/inflate\":40,\".\/lib\/utils\/common\":41,\".\/lib\/zlib\/constants\":44}],39:[function(e,t,r){\"use strict\";var a=e(\".\/zlib\/deflate\"),o=e(\".\/utils\/common\"),u=e(\".\/utils\/strings\"),i=e(\".\/zlib\/messages\"),s=e(\".\/zlib\/zstream\"),h=Object.prototype.toString,f=0,l=-1,d=0,c=8;function p(e){if(!(this instanceof p))return new p(e);this.options=o.assign({level:l,method:c,chunkSize:16384,windowBits:15,memLevel:8,strategy:d,to:\"\"},e||{});var t=this.options;t.raw&&0<t.windowBits?t.windowBits=-t.windowBits:t.gzip&&0<t.windowBits&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg=\"\",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(r!==f)throw new Error(i[r]);if(t.header&&a.deflateSetHeader(this.strm,t.header),t.dictionary){var n;if(n=\"string\"==typeof t.dictionary?u.string2buf(t.dictionary):\"[object ArrayBuffer]\"===h.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,(r=a.deflateSetDictionary(this.strm,n))!==f)throw new Error(i[r]);this._dict_set=!0}}function n(e,t){var r=new p(t);if(r.push(e,!0),r.err)throw r.msg||i[r.err];return r.result}p.prototype.push=function(e,t){var r,n,i=this.strm,s=this.options.chunkSize;if(this.ended)return!1;n=t===~~t?t:!0===t?4:0,\"string\"==typeof e?i.input=u.string2buf(e):\"[object ArrayBuffer]\"===h.call(e)?i.input=new Uint8Array(e):i.input=e,i.next_in=0,i.avail_in=i.input.length;do{if(0===i.avail_out&&(i.output=new o.Buf8(s),i.next_out=0,i.avail_out=s),1!==(r=a.deflate(i,n))&&r!==f)return this.onEnd(r),!(this.ended=!0);0!==i.avail_out&&(0!==i.avail_in||4!==n&&2!==n)||(\"string\"===this.options.to?this.onData(u.buf2binstring(o.shrinkBuf(i.output,i.next_out))):this.onData(o.shrinkBuf(i.output,i.next_out)))}while((0<i.avail_in||0===i.avail_out)&&1!==r);return 4===n?(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===f):2!==n||(this.onEnd(f),!(i.avail_out=0))},p.prototype.onData=function(e){this.chunks.push(e)},p.prototype.onEnd=function(e){e===f&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg},r.Deflate=p,r.deflate=n,r.deflateRaw=function(e,t){return(t=t||{}).raw=!0,n(e,t)},r.gzip=function(e,t){return(t=t||{}).gzip=!0,n(e,t)}},{\".\/utils\/common\":41,\".\/utils\/strings\":42,\".\/zlib\/deflate\":46,\".\/zlib\/messages\":51,\".\/zlib\/zstream\":53}],40:[function(e,t,r){\"use strict\";var d=e(\".\/zlib\/inflate\"),c=e(\".\/utils\/common\"),p=e(\".\/utils\/strings\"),m=e(\".\/zlib\/constants\"),n=e(\".\/zlib\/messages\"),i=e(\".\/zlib\/zstream\"),s=e(\".\/zlib\/gzheader\"),_=Object.prototype.toString;function a(e){if(!(this instanceof a))return new a(e);this.options=c.assign({chunkSize:16384,windowBits:0,to:\"\"},e||{});var t=this.options;t.raw&&0<=t.windowBits&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(0<=t.windowBits&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),15<t.windowBits&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg=\"\",this.ended=!1,this.chunks=[],this.strm=new i,this.strm.avail_out=0;var r=d.inflateInit2(this.strm,t.windowBits);if(r!==m.Z_OK)throw new Error(n[r]);this.header=new s,d.inflateGetHeader(this.strm,this.header)}function o(e,t){var r=new a(t);if(r.push(e,!0),r.err)throw r.msg||n[r.err];return r.result}a.prototype.push=function(e,t){var r,n,i,s,a,o,u=this.strm,h=this.options.chunkSize,f=this.options.dictionary,l=!1;if(this.ended)return!1;n=t===~~t?t:!0===t?m.Z_FINISH:m.Z_NO_FLUSH,\"string\"==typeof e?u.input=p.binstring2buf(e):\"[object ArrayBuffer]\"===_.call(e)?u.input=new Uint8Array(e):u.input=e,u.next_in=0,u.avail_in=u.input.length;do{if(0===u.avail_out&&(u.output=new c.Buf8(h),u.next_out=0,u.avail_out=h),(r=d.inflate(u,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&f&&(o=\"string\"==typeof f?p.string2buf(f):\"[object ArrayBuffer]\"===_.call(f)?new Uint8Array(f):f,r=d.inflateSetDictionary(this.strm,o)),r===m.Z_BUF_ERROR&&!0===l&&(r=m.Z_OK,l=!1),r!==m.Z_STREAM_END&&r!==m.Z_OK)return this.onEnd(r),!(this.ended=!0);u.next_out&&(0!==u.avail_out&&r!==m.Z_STREAM_END&&(0!==u.avail_in||n!==m.Z_FINISH&&n!==m.Z_SYNC_FLUSH)||(\"string\"===this.options.to?(i=p.utf8border(u.output,u.next_out),s=u.next_out-i,a=p.buf2string(u.output,i),u.next_out=s,u.avail_out=h-s,s&&c.arraySet(u.output,u.output,i,s,0),this.onData(a)):this.onData(c.shrinkBuf(u.output,u.next_out)))),0===u.avail_in&&0===u.avail_out&&(l=!0)}while((0<u.avail_in||0===u.avail_out)&&r!==m.Z_STREAM_END);return r===m.Z_STREAM_END&&(n=m.Z_FINISH),n===m.Z_FINISH?(r=d.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===m.Z_OK):n!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(u.avail_out=0))},a.prototype.onData=function(e){this.chunks.push(e)},a.prototype.onEnd=function(e){e===m.Z_OK&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=c.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg},r.Inflate=a,r.inflate=o,r.inflateRaw=function(e,t){return(t=t||{}).raw=!0,o(e,t)},r.ungzip=o},{\".\/utils\/common\":41,\".\/utils\/strings\":42,\".\/zlib\/constants\":44,\".\/zlib\/gzheader\":47,\".\/zlib\/inflate\":49,\".\/zlib\/messages\":51,\".\/zlib\/zstream\":53}],41:[function(e,t,r){\"use strict\";var n=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Int32Array;r.assign=function(e){for(var t=Array.prototype.slice.call(arguments,1);t.length;){var r=t.shift();if(r){if(\"object\"!=typeof r)throw new TypeError(r+\"must be non-object\");for(var n in r)r.hasOwnProperty(n)&&(e[n]=r[n])}}return e},r.shrinkBuf=function(e,t){return e.length===t?e:e.subarray?e.subarray(0,t):(e.length=t,e)};var i={arraySet:function(e,t,r,n,i){if(t.subarray&&e.subarray)e.set(t.subarray(r,r+n),i);else for(var s=0;s<n;s++)e[i+s]=t[r+s]},flattenChunks:function(e){var t,r,n,i,s,a;for(t=n=0,r=e.length;t<r;t++)n+=e[t].length;for(a=new Uint8Array(n),t=i=0,r=e.length;t<r;t++)s=e[t],a.set(s,i),i+=s.length;return a}},s={arraySet:function(e,t,r,n,i){for(var s=0;s<n;s++)e[i+s]=t[r+s]},flattenChunks:function(e){return[].concat.apply([],e)}};r.setTyped=function(e){e?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,i)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,s))},r.setTyped(n)},{}],42:[function(e,t,r){\"use strict\";var u=e(\".\/common\"),i=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(e){i=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(e){s=!1}for(var h=new u.Buf8(256),n=0;n<256;n++)h[n]=252<=n?6:248<=n?5:240<=n?4:224<=n?3:192<=n?2:1;function f(e,t){if(t<65537&&(e.subarray&&s||!e.subarray&&i))return String.fromCharCode.apply(null,u.shrinkBuf(e,t));for(var r=\"\",n=0;n<t;n++)r+=String.fromCharCode(e[n]);return r}h[254]=h[254]=1,r.string2buf=function(e){var t,r,n,i,s,a=e.length,o=0;for(i=0;i<a;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),o+=r<128?1:r<2048?2:r<65536?3:4;for(t=new u.Buf8(o),i=s=0;s<o;i++)55296==(64512&(r=e.charCodeAt(i)))&&i+1<a&&56320==(64512&(n=e.charCodeAt(i+1)))&&(r=65536+(r-55296<<10)+(n-56320),i++),r<128?t[s++]=r:(r<2048?t[s++]=192|r>>>6:(r<65536?t[s++]=224|r>>>12:(t[s++]=240|r>>>18,t[s++]=128|r>>>12&63),t[s++]=128|r>>>6&63),t[s++]=128|63&r);return t},r.buf2binstring=function(e){return f(e,e.length)},r.binstring2buf=function(e){for(var t=new u.Buf8(e.length),r=0,n=t.length;r<n;r++)t[r]=e.charCodeAt(r);return t},r.buf2string=function(e,t){var r,n,i,s,a=t||e.length,o=new Array(2*a);for(r=n=0;r<a;)if((i=e[r++])<128)o[n++]=i;else if(4<(s=h[i]))o[n++]=65533,r+=s-1;else{for(i&=2===s?31:3===s?15:7;1<s&&r<a;)i=i<<6|63&e[r++],s--;1<s?o[n++]=65533:i<65536?o[n++]=i:(i-=65536,o[n++]=55296|i>>10&1023,o[n++]=56320|1023&i)}return f(o,n)},r.utf8border=function(e,t){var r;for((t=t||e.length)>e.length&&(t=e.length),r=t-1;0<=r&&128==(192&e[r]);)r--;return r<0?t:0===r?t:r+h[e[r]]>t?r:t}},{\".\/common\":41}],43:[function(e,t,r){\"use strict\";t.exports=function(e,t,r,n){for(var i=65535&e|0,s=e>>>16&65535|0,a=0;0!==r;){for(r-=a=2e3<r?2e3:r;s=s+(i=i+t[n++]|0)|0,--a;);i%=65521,s%=65521}return i|s<<16|0}},{}],44:[function(e,t,r){\"use strict\";t.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(e,t,r){\"use strict\";var o=function(){for(var e,t=[],r=0;r<256;r++){e=r;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[r]=e}return t}();t.exports=function(e,t,r,n){var i=o,s=n+r;e^=-1;for(var a=n;a<s;a++)e=e>>>8^i[255&(e^t[a])];return-1^e}},{}],46:[function(e,t,r){\"use strict\";var u,d=e(\"..\/utils\/common\"),h=e(\".\/trees\"),c=e(\".\/adler32\"),p=e(\".\/crc32\"),n=e(\".\/messages\"),f=0,l=0,m=-2,i=2,_=8,s=286,a=30,o=19,g=2*s+1,v=15,b=3,w=258,y=w+b+1,k=42,x=113;function S(e,t){return e.msg=n[t],t}function z(e){return(e<<1)-(4<e?9:0)}function E(e){for(var t=e.length;0<=--t;)e[t]=0}function C(e){var t=e.state,r=t.pending;r>e.avail_out&&(r=e.avail_out),0!==r&&(d.arraySet(e.output,t.pending_buf,t.pending_out,r,e.next_out),e.next_out+=r,t.pending_out+=r,e.total_out+=r,e.avail_out-=r,t.pending-=r,0===t.pending&&(t.pending_out=0))}function A(e,t){h._tr_flush_block(e,0<=e.block_start?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,C(e.strm)}function I(e,t){e.pending_buf[e.pending++]=t}function O(e,t){e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t}function B(e,t){var r,n,i=e.max_chain_length,s=e.strstart,a=e.prev_length,o=e.nice_match,u=e.strstart>e.w_size-y?e.strstart-(e.w_size-y):0,h=e.window,f=e.w_mask,l=e.prev,d=e.strstart+w,c=h[s+a-1],p=h[s+a];e.prev_length>=e.good_match&&(i>>=2),o>e.lookahead&&(o=e.lookahead);do{if(h[(r=t)+a]===p&&h[r+a-1]===c&&h[r]===h[s]&&h[++r]===h[s+1]){s+=2,r++;do{}while(h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&h[++s]===h[++r]&&s<d);if(n=w-(d-s),s=d-w,a<n){if(e.match_start=t,o<=(a=n))break;c=h[s+a-1],p=h[s+a]}}}while((t=l[t&f])>u&&0!=--i);return a<=e.lookahead?a:e.lookahead}function T(e){var t,r,n,i,s,a,o,u,h,f,l=e.w_size;do{if(i=e.window_size-e.lookahead-e.strstart,e.strstart>=l+(l-y)){for(d.arraySet(e.window,e.window,l,l,0),e.match_start-=l,e.strstart-=l,e.block_start-=l,t=r=e.hash_size;n=e.head[--t],e.head[t]=l<=n?n-l:0,--r;);for(t=r=l;n=e.prev[--t],e.prev[t]=l<=n?n-l:0,--r;);i+=l}if(0===e.strm.avail_in)break;if(a=e.strm,o=e.window,u=e.strstart+e.lookahead,f=void 0,(h=i)<(f=a.avail_in)&&(f=h),r=0===f?0:(a.avail_in-=f,d.arraySet(o,a.input,a.next_in,f,u),1===a.state.wrap?a.adler=c(a.adler,o,f,u):2===a.state.wrap&&(a.adler=p(a.adler,o,f,u)),a.next_in+=f,a.total_in+=f,f),e.lookahead+=r,e.lookahead+e.insert>=b)for(s=e.strstart-e.insert,e.ins_h=e.window[s],e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+1])&e.hash_mask;e.insert&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[s+b-1])&e.hash_mask,e.prev[s&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=s,s++,e.insert--,!(e.lookahead+e.insert<b)););}while(e.lookahead<y&&0!==e.strm.avail_in)}function R(e,t){for(var r,n;;){if(e.lookahead<y){if(T(e),e.lookahead<y&&t===f)return 1;if(0===e.lookahead)break}if(r=0,e.lookahead>=b&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+b-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==r&&e.strstart-r<=e.w_size-y&&(e.match_length=B(e,r)),e.match_length>=b)if(n=h._tr_tally(e,e.strstart-e.match_start,e.match_length-b),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=b){for(e.match_length--;e.strstart++,e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+b-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart,0!=--e.match_length;);e.strstart++}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+1])&e.hash_mask;else n=h._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(n&&(A(e,!1),0===e.strm.avail_out))return 1}return e.insert=e.strstart<b-1?e.strstart:b-1,4===t?(A(e,!0),0===e.strm.avail_out?3:4):e.last_lit&&(A(e,!1),0===e.strm.avail_out)?1:2}function D(e,t){for(var r,n,i;;){if(e.lookahead<y){if(T(e),e.lookahead<y&&t===f)return 1;if(0===e.lookahead)break}if(r=0,e.lookahead>=b&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+b-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=b-1,0!==r&&e.prev_length<e.max_lazy_match&&e.strstart-r<=e.w_size-y&&(e.match_length=B(e,r),e.match_length<=5&&(1===e.strategy||e.match_length===b&&4096<e.strstart-e.match_start)&&(e.match_length=b-1)),e.prev_length>=b&&e.match_length<=e.prev_length){for(i=e.strstart+e.lookahead-b,n=h._tr_tally(e,e.strstart-1-e.prev_match,e.prev_length-b),e.lookahead-=e.prev_length-1,e.prev_length-=2;++e.strstart<=i&&(e.ins_h=(e.ins_h<<e.hash_shift^e.window[e.strstart+b-1])&e.hash_mask,r=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!=--e.prev_length;);if(e.match_available=0,e.match_length=b-1,e.strstart++,n&&(A(e,!1),0===e.strm.avail_out))return 1}else if(e.match_available){if((n=h._tr_tally(e,0,e.window[e.strstart-1]))&&A(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return 1}else e.match_available=1,e.strstart++,e.lookahead--}return e.match_available&&(n=h._tr_tally(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<b-1?e.strstart:b-1,4===t?(A(e,!0),0===e.strm.avail_out?3:4):e.last_lit&&(A(e,!1),0===e.strm.avail_out)?1:2}function F(e,t,r,n,i){this.good_length=e,this.max_lazy=t,this.nice_length=r,this.max_chain=n,this.func=i}function N(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=_,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new d.Buf16(2*g),this.dyn_dtree=new d.Buf16(2*(2*a+1)),this.bl_tree=new d.Buf16(2*(2*o+1)),E(this.dyn_ltree),E(this.dyn_dtree),E(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new d.Buf16(v+1),this.heap=new d.Buf16(2*s+1),E(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new d.Buf16(2*s+1),E(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function U(e){var t;return e&&e.state?(e.total_in=e.total_out=0,e.data_type=i,(t=e.state).pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=t.wrap?k:x,e.adler=2===t.wrap?0:1,t.last_flush=f,h._tr_init(t),l):S(e,m)}function P(e){var t,r=U(e);return r===l&&((t=e.state).window_size=2*t.w_size,E(t.head),t.max_lazy_match=u[t.level].max_lazy,t.good_match=u[t.level].good_length,t.nice_match=u[t.level].nice_length,t.max_chain_length=u[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=b-1,t.match_available=0,t.ins_h=0),r}function L(e,t,r,n,i,s){if(!e)return m;var a=1;if(-1===t&&(t=6),n<0?(a=0,n=-n):15<n&&(a=2,n-=16),i<1||9<i||r!==_||n<8||15<n||t<0||9<t||s<0||4<s)return S(e,m);8===n&&(n=9);var o=new N;return(e.state=o).strm=e,o.wrap=a,o.gzhead=null,o.w_bits=n,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=i+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+b-1)\/b),o.window=new d.Buf8(2*o.w_size),o.head=new d.Buf16(o.hash_size),o.prev=new d.Buf16(o.w_size),o.lit_bufsize=1<<i+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new d.Buf8(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=t,o.strategy=s,o.method=r,P(e)}u=[new F(0,0,0,0,function(e,t){var r=65535;for(r>e.pending_buf_size-5&&(r=e.pending_buf_size-5);;){if(e.lookahead<=1){if(T(e),0===e.lookahead&&t===f)return 1;if(0===e.lookahead)break}e.strstart+=e.lookahead,e.lookahead=0;var n=e.block_start+r;if((0===e.strstart||e.strstart>=n)&&(e.lookahead=e.strstart-n,e.strstart=n,A(e,!1),0===e.strm.avail_out))return 1;if(e.strstart-e.block_start>=e.w_size-y&&(A(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,4===t?(A(e,!0),0===e.strm.avail_out?3:4):(e.strstart>e.block_start&&(A(e,!1),e.strm.avail_out),1)}),new F(4,4,8,4,R),new F(4,5,16,8,R),new F(4,6,32,32,R),new F(4,4,16,16,D),new F(8,16,32,32,D),new F(8,16,128,128,D),new F(8,32,128,256,D),new F(32,128,258,1024,D),new F(32,258,258,4096,D)],r.deflateInit=function(e,t){return L(e,t,_,15,8,0)},r.deflateInit2=L,r.deflateReset=P,r.deflateResetKeep=U,r.deflateSetHeader=function(e,t){return e&&e.state?2!==e.state.wrap?m:(e.state.gzhead=t,l):m},r.deflate=function(e,t){var r,n,i,s;if(!e||!e.state||5<t||t<0)return e?S(e,m):m;if(n=e.state,!e.output||!e.input&&0!==e.avail_in||666===n.status&&4!==t)return S(e,0===e.avail_out?-5:m);if(n.strm=e,r=n.last_flush,n.last_flush=t,n.status===k)if(2===n.wrap)e.adler=0,I(n,31),I(n,139),I(n,8),n.gzhead?(I(n,(n.gzhead.text?1:0)+(n.gzhead.hcrc?2:0)+(n.gzhead.extra?4:0)+(n.gzhead.name?8:0)+(n.gzhead.comment?16:0)),I(n,255&n.gzhead.time),I(n,n.gzhead.time>>8&255),I(n,n.gzhead.time>>16&255),I(n,n.gzhead.time>>24&255),I(n,9===n.level?2:2<=n.strategy||n.level<2?4:0),I(n,255&n.gzhead.os),n.gzhead.extra&&n.gzhead.extra.length&&(I(n,255&n.gzhead.extra.length),I(n,n.gzhead.extra.length>>8&255)),n.gzhead.hcrc&&(e.adler=p(e.adler,n.pending_buf,n.pending,0)),n.gzindex=0,n.status=69):(I(n,0),I(n,0),I(n,0),I(n,0),I(n,0),I(n,9===n.level?2:2<=n.strategy||n.level<2?4:0),I(n,3),n.status=x);else{var a=_+(n.w_bits-8<<4)<<8;a|=(2<=n.strategy||n.level<2?0:n.level<6?1:6===n.level?2:3)<<6,0!==n.strstart&&(a|=32),a+=31-a%31,n.status=x,O(n,a),0!==n.strstart&&(O(n,e.adler>>>16),O(n,65535&e.adler)),e.adler=1}if(69===n.status)if(n.gzhead.extra){for(i=n.pending;n.gzindex<(65535&n.gzhead.extra.length)&&(n.pending!==n.pending_buf_size||(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),C(e),i=n.pending,n.pending!==n.pending_buf_size));)I(n,255&n.gzhead.extra[n.gzindex]),n.gzindex++;n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),n.gzindex===n.gzhead.extra.length&&(n.gzindex=0,n.status=73)}else n.status=73;if(73===n.status)if(n.gzhead.name){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),C(e),i=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.name.length?255&n.gzhead.name.charCodeAt(n.gzindex++):0,I(n,s)}while(0!==s);n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),0===s&&(n.gzindex=0,n.status=91)}else n.status=91;if(91===n.status)if(n.gzhead.comment){i=n.pending;do{if(n.pending===n.pending_buf_size&&(n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),C(e),i=n.pending,n.pending===n.pending_buf_size)){s=1;break}s=n.gzindex<n.gzhead.comment.length?255&n.gzhead.comment.charCodeAt(n.gzindex++):0,I(n,s)}while(0!==s);n.gzhead.hcrc&&n.pending>i&&(e.adler=p(e.adler,n.pending_buf,n.pending-i,i)),0===s&&(n.status=103)}else n.status=103;if(103===n.status&&(n.gzhead.hcrc?(n.pending+2>n.pending_buf_size&&C(e),n.pending+2<=n.pending_buf_size&&(I(n,255&e.adler),I(n,e.adler>>8&255),e.adler=0,n.status=x)):n.status=x),0!==n.pending){if(C(e),0===e.avail_out)return n.last_flush=-1,l}else if(0===e.avail_in&&z(t)<=z(r)&&4!==t)return S(e,-5);if(666===n.status&&0!==e.avail_in)return S(e,-5);if(0!==e.avail_in||0!==n.lookahead||t!==f&&666!==n.status){var o=2===n.strategy?function(e,t){for(var r;;){if(0===e.lookahead&&(T(e),0===e.lookahead)){if(t===f)return 1;break}if(e.match_length=0,r=h._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,r&&(A(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,4===t?(A(e,!0),0===e.strm.avail_out?3:4):e.last_lit&&(A(e,!1),0===e.strm.avail_out)?1:2}(n,t):3===n.strategy?function(e,t){for(var r,n,i,s,a=e.window;;){if(e.lookahead<=w){if(T(e),e.lookahead<=w&&t===f)return 1;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=b&&0<e.strstart&&(n=a[i=e.strstart-1])===a[++i]&&n===a[++i]&&n===a[++i]){s=e.strstart+w;do{}while(n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&n===a[++i]&&i<s);e.match_length=w-(s-i),e.match_length>e.lookahead&&(e.match_length=e.lookahead)}if(e.match_length>=b?(r=h._tr_tally(e,1,e.match_length-b),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(r=h._tr_tally(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),r&&(A(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,4===t?(A(e,!0),0===e.strm.avail_out?3:4):e.last_lit&&(A(e,!1),0===e.strm.avail_out)?1:2}(n,t):u[n.level].func(n,t);if(3!==o&&4!==o||(n.status=666),1===o||3===o)return 0===e.avail_out&&(n.last_flush=-1),l;if(2===o&&(1===t?h._tr_align(n):5!==t&&(h._tr_stored_block(n,0,0,!1),3===t&&(E(n.head),0===n.lookahead&&(n.strstart=0,n.block_start=0,n.insert=0))),C(e),0===e.avail_out))return n.last_flush=-1,l}return 4!==t?l:n.wrap<=0?1:(2===n.wrap?(I(n,255&e.adler),I(n,e.adler>>8&255),I(n,e.adler>>16&255),I(n,e.adler>>24&255),I(n,255&e.total_in),I(n,e.total_in>>8&255),I(n,e.total_in>>16&255),I(n,e.total_in>>24&255)):(O(n,e.adler>>>16),O(n,65535&e.adler)),C(e),0<n.wrap&&(n.wrap=-n.wrap),0!==n.pending?l:1)},r.deflateEnd=function(e){var t;return e&&e.state?(t=e.state.status)!==k&&69!==t&&73!==t&&91!==t&&103!==t&&t!==x&&666!==t?S(e,m):(e.state=null,t===x?S(e,-3):l):m},r.deflateSetDictionary=function(e,t){var r,n,i,s,a,o,u,h,f=t.length;if(!e||!e.state)return m;if(2===(s=(r=e.state).wrap)||1===s&&r.status!==k||r.lookahead)return m;for(1===s&&(e.adler=c(e.adler,t,f,0)),r.wrap=0,f>=r.w_size&&(0===s&&(E(r.head),r.strstart=0,r.block_start=0,r.insert=0),h=new d.Buf8(r.w_size),d.arraySet(h,t,f-r.w_size,r.w_size,0),t=h,f=r.w_size),a=e.avail_in,o=e.next_in,u=e.input,e.avail_in=f,e.next_in=0,e.input=t,T(r);r.lookahead>=b;){for(n=r.strstart,i=r.lookahead-(b-1);r.ins_h=(r.ins_h<<r.hash_shift^r.window[n+b-1])&r.hash_mask,r.prev[n&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=n,n++,--i;);r.strstart=n,r.lookahead=b-1,T(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=b-1,r.match_available=0,e.next_in=o,e.input=u,e.avail_in=a,r.wrap=s,l},r.deflateInfo=\"pako deflate (from Nodeca project)\"},{\"..\/utils\/common\":41,\".\/adler32\":43,\".\/crc32\":45,\".\/messages\":51,\".\/trees\":52}],47:[function(e,t,r){\"use strict\";t.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name=\"\",this.comment=\"\",this.hcrc=0,this.done=!1}},{}],48:[function(e,t,r){\"use strict\";t.exports=function(e,t){var r,n,i,s,a,o,u,h,f,l,d,c,p,m,_,g,v,b,w,y,k,x,S,z,E;r=e.state,n=e.next_in,z=e.input,i=n+(e.avail_in-5),s=e.next_out,E=e.output,a=s-(t-e.avail_out),o=s+(e.avail_out-257),u=r.dmax,h=r.wsize,f=r.whave,l=r.wnext,d=r.window,c=r.hold,p=r.bits,m=r.lencode,_=r.distcode,g=(1<<r.lenbits)-1,v=(1<<r.distbits)-1;e:do{p<15&&(c+=z[n++]<<p,p+=8,c+=z[n++]<<p,p+=8),b=m[c&g];t:for(;;){if(c>>>=w=b>>>24,p-=w,0==(w=b>>>16&255))E[s++]=65535&b;else{if(!(16&w)){if(0==(64&w)){b=m[(65535&b)+(c&(1<<w)-1)];continue t}if(32&w){r.mode=12;break e}e.msg=\"invalid literal\/length code\",r.mode=30;break e}y=65535&b,(w&=15)&&(p<w&&(c+=z[n++]<<p,p+=8),y+=c&(1<<w)-1,c>>>=w,p-=w),p<15&&(c+=z[n++]<<p,p+=8,c+=z[n++]<<p,p+=8),b=_[c&v];r:for(;;){if(c>>>=w=b>>>24,p-=w,!(16&(w=b>>>16&255))){if(0==(64&w)){b=_[(65535&b)+(c&(1<<w)-1)];continue r}e.msg=\"invalid distance code\",r.mode=30;break e}if(k=65535&b,p<(w&=15)&&(c+=z[n++]<<p,(p+=8)<w&&(c+=z[n++]<<p,p+=8)),u<(k+=c&(1<<w)-1)){e.msg=\"invalid distance too far back\",r.mode=30;break e}if(c>>>=w,p-=w,(w=s-a)<k){if(f<(w=k-w)&&r.sane){e.msg=\"invalid distance too far back\",r.mode=30;break e}if(S=d,(x=0)===l){if(x+=h-w,w<y){for(y-=w;E[s++]=d[x++],--w;);x=s-k,S=E}}else if(l<w){if(x+=h+l-w,(w-=l)<y){for(y-=w;E[s++]=d[x++],--w;);if(x=0,l<y){for(y-=w=l;E[s++]=d[x++],--w;);x=s-k,S=E}}}else if(x+=l-w,w<y){for(y-=w;E[s++]=d[x++],--w;);x=s-k,S=E}for(;2<y;)E[s++]=S[x++],E[s++]=S[x++],E[s++]=S[x++],y-=3;y&&(E[s++]=S[x++],1<y&&(E[s++]=S[x++]))}else{for(x=s-k;E[s++]=E[x++],E[s++]=E[x++],E[s++]=E[x++],2<(y-=3););y&&(E[s++]=E[x++],1<y&&(E[s++]=E[x++]))}break}}break}}while(n<i&&s<o);n-=y=p>>3,c&=(1<<(p-=y<<3))-1,e.next_in=n,e.next_out=s,e.avail_in=n<i?i-n+5:5-(n-i),e.avail_out=s<o?o-s+257:257-(s-o),r.hold=c,r.bits=p}},{}],49:[function(e,t,r){\"use strict\";var I=e(\"..\/utils\/common\"),O=e(\".\/adler32\"),B=e(\".\/crc32\"),T=e(\".\/inffast\"),R=e(\".\/inftrees\"),D=1,F=2,N=0,U=-2,P=1,n=852,i=592;function L(e){return(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24)}function s(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new I.Buf16(320),this.work=new I.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function a(e){var t;return e&&e.state?(t=e.state,e.total_in=e.total_out=t.total=0,e.msg=\"\",t.wrap&&(e.adler=1&t.wrap),t.mode=P,t.last=0,t.havedict=0,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new I.Buf32(n),t.distcode=t.distdyn=new I.Buf32(i),t.sane=1,t.back=-1,N):U}function o(e){var t;return e&&e.state?((t=e.state).wsize=0,t.whave=0,t.wnext=0,a(e)):U}function u(e,t){var r,n;return e&&e.state?(n=e.state,t<0?(r=0,t=-t):(r=1+(t>>4),t<48&&(t&=15)),t&&(t<8||15<t)?U:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=r,n.wbits=t,o(e))):U}function h(e,t){var r,n;return e?(n=new s,(e.state=n).window=null,(r=u(e,t))!==N&&(e.state=null),r):U}var f,l,d=!0;function j(e){if(d){var t;for(f=new I.Buf32(512),l=new I.Buf32(32),t=0;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(R(D,e.lens,0,288,f,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;R(F,e.lens,0,32,l,0,e.work,{bits:5}),d=!1}e.lencode=f,e.lenbits=9,e.distcode=l,e.distbits=5}function Z(e,t,r,n){var i,s=e.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new I.Buf8(s.wsize)),n>=s.wsize?(I.arraySet(s.window,t,r-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(n<(i=s.wsize-s.wnext)&&(i=n),I.arraySet(s.window,t,r-n,i,s.wnext),(n-=i)?(I.arraySet(s.window,t,r-n,n,0),s.wnext=n,s.whave=s.wsize):(s.wnext+=i,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=i))),0}r.inflateReset=o,r.inflateReset2=u,r.inflateResetKeep=a,r.inflateInit=function(e){return h(e,15)},r.inflateInit2=h,r.inflate=function(e,t){var r,n,i,s,a,o,u,h,f,l,d,c,p,m,_,g,v,b,w,y,k,x,S,z,E=0,C=new I.Buf8(4),A=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!e||!e.state||!e.output||!e.input&&0!==e.avail_in)return U;12===(r=e.state).mode&&(r.mode=13),a=e.next_out,i=e.output,u=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,h=r.hold,f=r.bits,l=o,d=u,x=N;e:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=13;break}for(;f<16;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(2&r.wrap&&35615===h){C[r.check=0]=255&h,C[1]=h>>>8&255,r.check=B(r.check,C,2,0),f=h=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&h)<<8)+(h>>8))%31){e.msg=\"incorrect header check\",r.mode=30;break}if(8!=(15&h)){e.msg=\"unknown compression method\",r.mode=30;break}if(f-=4,k=8+(15&(h>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){e.msg=\"invalid window size\",r.mode=30;break}r.dmax=1<<k,e.adler=r.check=1,r.mode=512&h?10:12,f=h=0;break;case 2:for(;f<16;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(r.flags=h,8!=(255&r.flags)){e.msg=\"unknown compression method\",r.mode=30;break}if(57344&r.flags){e.msg=\"unknown header flags set\",r.mode=30;break}r.head&&(r.head.text=h>>8&1),512&r.flags&&(C[0]=255&h,C[1]=h>>>8&255,r.check=B(r.check,C,2,0)),f=h=0,r.mode=3;case 3:for(;f<32;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}r.head&&(r.head.time=h),512&r.flags&&(C[0]=255&h,C[1]=h>>>8&255,C[2]=h>>>16&255,C[3]=h>>>24&255,r.check=B(r.check,C,4,0)),f=h=0,r.mode=4;case 4:for(;f<16;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}r.head&&(r.head.xflags=255&h,r.head.os=h>>8),512&r.flags&&(C[0]=255&h,C[1]=h>>>8&255,r.check=B(r.check,C,2,0)),f=h=0,r.mode=5;case 5:if(1024&r.flags){for(;f<16;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}r.length=h,r.head&&(r.head.extra_len=h),512&r.flags&&(C[0]=255&h,C[1]=h>>>8&255,r.check=B(r.check,C,2,0)),f=h=0}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&(o<(c=r.length)&&(c=o),c&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),I.arraySet(r.head.extra,n,s,c,k)),512&r.flags&&(r.check=B(r.check,n,c,s)),o-=c,s+=c,r.length-=c),r.length))break e;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===o)break e;for(c=0;k=n[s+c++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,n,c,s)),o-=c,s+=c,k)break e}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===o)break e;for(c=0;k=n[s+c++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,n,c,s)),o-=c,s+=c,k)break e}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;f<16;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(h!==(65535&r.check)){e.msg=\"header crc mismatch\",r.mode=30;break}f=h=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),e.adler=r.check=0,r.mode=12;break;case 10:for(;f<32;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}e.adler=r.check=L(h),f=h=0,r.mode=11;case 11:if(0===r.havedict)return e.next_out=a,e.avail_out=u,e.next_in=s,e.avail_in=o,r.hold=h,r.bits=f,2;e.adler=r.check=1,r.mode=12;case 12:if(5===t||6===t)break e;case 13:if(r.last){h>>>=7&f,f-=7&f,r.mode=27;break}for(;f<3;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}switch(r.last=1&h,f-=1,3&(h>>>=1)){case 0:r.mode=14;break;case 1:if(j(r),r.mode=20,6!==t)break;h>>>=2,f-=2;break e;case 2:r.mode=17;break;case 3:e.msg=\"invalid block type\",r.mode=30}h>>>=2,f-=2;break;case 14:for(h>>>=7&f,f-=7&f;f<32;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if((65535&h)!=(h>>>16^65535)){e.msg=\"invalid stored block lengths\",r.mode=30;break}if(r.length=65535&h,f=h=0,r.mode=15,6===t)break e;case 15:r.mode=16;case 16:if(c=r.length){if(o<c&&(c=o),u<c&&(c=u),0===c)break e;I.arraySet(i,n,s,c,a),o-=c,s+=c,u-=c,a+=c,r.length-=c;break}r.mode=12;break;case 17:for(;f<14;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(r.nlen=257+(31&h),h>>>=5,f-=5,r.ndist=1+(31&h),h>>>=5,f-=5,r.ncode=4+(15&h),h>>>=4,f-=4,286<r.nlen||30<r.ndist){e.msg=\"too many length or distance symbols\",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;f<3;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}r.lens[A[r.have++]]=7&h,h>>>=3,f-=3}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},x=R(0,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,x){e.msg=\"invalid code lengths set\",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;g=(E=r.lencode[h&(1<<r.lenbits)-1])>>>16&255,v=65535&E,!((_=E>>>24)<=f);){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(v<16)h>>>=_,f-=_,r.lens[r.have++]=v;else{if(16===v){for(z=_+2;f<z;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(h>>>=_,f-=_,0===r.have){e.msg=\"invalid bit length repeat\",r.mode=30;break}k=r.lens[r.have-1],c=3+(3&h),h>>>=2,f-=2}else if(17===v){for(z=_+3;f<z;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}f-=_,k=0,c=3+(7&(h>>>=_)),h>>>=3,f-=3}else{for(z=_+7;f<z;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}f-=_,k=0,c=11+(127&(h>>>=_)),h>>>=7,f-=7}if(r.have+c>r.nlen+r.ndist){e.msg=\"invalid bit length repeat\",r.mode=30;break}for(;c--;)r.lens[r.have++]=k}}if(30===r.mode)break;if(0===r.lens[256]){e.msg=\"invalid code -- missing end-of-block\",r.mode=30;break}if(r.lenbits=9,S={bits:r.lenbits},x=R(D,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,x){e.msg=\"invalid literal\/lengths set\",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},x=R(F,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,x){e.msg=\"invalid distances set\",r.mode=30;break}if(r.mode=20,6===t)break e;case 20:r.mode=21;case 21:if(6<=o&&258<=u){e.next_out=a,e.avail_out=u,e.next_in=s,e.avail_in=o,r.hold=h,r.bits=f,T(e,d),a=e.next_out,i=e.output,u=e.avail_out,s=e.next_in,n=e.input,o=e.avail_in,h=r.hold,f=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;g=(E=r.lencode[h&(1<<r.lenbits)-1])>>>16&255,v=65535&E,!((_=E>>>24)<=f);){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(g&&0==(240&g)){for(b=_,w=g,y=v;g=(E=r.lencode[y+((h&(1<<b+w)-1)>>b)])>>>16&255,v=65535&E,!(b+(_=E>>>24)<=f);){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}h>>>=b,f-=b,r.back+=b}if(h>>>=_,f-=_,r.back+=_,r.length=v,0===g){r.mode=26;break}if(32&g){r.back=-1,r.mode=12;break}if(64&g){e.msg=\"invalid literal\/length code\",r.mode=30;break}r.extra=15&g,r.mode=22;case 22:if(r.extra){for(z=r.extra;f<z;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}r.length+=h&(1<<r.extra)-1,h>>>=r.extra,f-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=23;case 23:for(;g=(E=r.distcode[h&(1<<r.distbits)-1])>>>16&255,v=65535&E,!((_=E>>>24)<=f);){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(0==(240&g)){for(b=_,w=g,y=v;g=(E=r.distcode[y+((h&(1<<b+w)-1)>>b)])>>>16&255,v=65535&E,!(b+(_=E>>>24)<=f);){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}h>>>=b,f-=b,r.back+=b}if(h>>>=_,f-=_,r.back+=_,64&g){e.msg=\"invalid distance code\",r.mode=30;break}r.offset=v,r.extra=15&g,r.mode=24;case 24:if(r.extra){for(z=r.extra;f<z;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}r.offset+=h&(1<<r.extra)-1,h>>>=r.extra,f-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){e.msg=\"invalid distance too far back\",r.mode=30;break}r.mode=25;case 25:if(0===u)break e;if(c=d-u,r.offset>c){if((c=r.offset-c)>r.whave&&r.sane){e.msg=\"invalid distance too far back\",r.mode=30;break}p=c>r.wnext?(c-=r.wnext,r.wsize-c):r.wnext-c,c>r.length&&(c=r.length),m=r.window}else m=i,p=a-r.offset,c=r.length;for(u<c&&(c=u),u-=c,r.length-=c;i[a++]=m[p++],--c;);0===r.length&&(r.mode=21);break;case 26:if(0===u)break e;i[a++]=r.length,u--,r.mode=21;break;case 27:if(r.wrap){for(;f<32;){if(0===o)break e;o--,h|=n[s++]<<f,f+=8}if(d-=u,e.total_out+=d,r.total+=d,d&&(e.adler=r.check=r.flags?B(r.check,i,d,a-d):O(r.check,i,d,a-d)),d=u,(r.flags?h:L(h))!==r.check){e.msg=\"incorrect data check\",r.mode=30;break}f=h=0}r.mode=28;case 28:if(r.wrap&&r.flags){for(;f<32;){if(0===o)break e;o--,h+=n[s++]<<f,f+=8}if(h!==(4294967295&r.total)){e.msg=\"incorrect length check\",r.mode=30;break}f=h=0}r.mode=29;case 29:x=1;break e;case 30:x=-3;break e;case 31:return-4;case 32:default:return U}return e.next_out=a,e.avail_out=u,e.next_in=s,e.avail_in=o,r.hold=h,r.bits=f,(r.wsize||d!==e.avail_out&&r.mode<30&&(r.mode<27||4!==t))&&Z(e,e.output,e.next_out,d-e.avail_out)?(r.mode=31,-4):(l-=e.avail_in,d-=e.avail_out,e.total_in+=l,e.total_out+=d,r.total+=d,r.wrap&&d&&(e.adler=r.check=r.flags?B(r.check,i,d,e.next_out-d):O(r.check,i,d,e.next_out-d)),e.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0==l&&0===d||4===t)&&x===N&&(x=-5),x)},r.inflateEnd=function(e){if(!e||!e.state)return U;var t=e.state;return t.window&&(t.window=null),e.state=null,N},r.inflateGetHeader=function(e,t){var r;return e&&e.state?0==(2&(r=e.state).wrap)?U:((r.head=t).done=!1,N):U},r.inflateSetDictionary=function(e,t){var r,n=t.length;return e&&e.state?0!==(r=e.state).wrap&&11!==r.mode?U:11===r.mode&&O(1,t,n,0)!==r.check?-3:Z(e,t,n,n)?(r.mode=31,-4):(r.havedict=1,N):U},r.inflateInfo=\"pako inflate (from Nodeca project)\"},{\"..\/utils\/common\":41,\".\/adler32\":43,\".\/crc32\":45,\".\/inffast\":48,\".\/inftrees\":50}],50:[function(e,t,r){\"use strict\";var D=e(\"..\/utils\/common\"),F=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],N=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],U=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],P=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];t.exports=function(e,t,r,n,i,s,a,o){var u,h,f,l,d,c,p,m,_,g=o.bits,v=0,b=0,w=0,y=0,k=0,x=0,S=0,z=0,E=0,C=0,A=null,I=0,O=new D.Buf16(16),B=new D.Buf16(16),T=null,R=0;for(v=0;v<=15;v++)O[v]=0;for(b=0;b<n;b++)O[t[r+b]]++;for(k=g,y=15;1<=y&&0===O[y];y--);if(y<k&&(k=y),0===y)return i[s++]=20971520,i[s++]=20971520,o.bits=1,0;for(w=1;w<y&&0===O[w];w++);for(k<w&&(k=w),v=z=1;v<=15;v++)if(z<<=1,(z-=O[v])<0)return-1;if(0<z&&(0===e||1!==y))return-1;for(B[1]=0,v=1;v<15;v++)B[v+1]=B[v]+O[v];for(b=0;b<n;b++)0!==t[r+b]&&(a[B[t[r+b]]++]=b);if(c=0===e?(A=T=a,19):1===e?(A=F,I-=257,T=N,R-=257,256):(A=U,T=P,-1),v=w,d=s,S=b=C=0,f=-1,l=(E=1<<(x=k))-1,1===e&&852<E||2===e&&592<E)return 1;for(;;){for(p=v-S,_=a[b]<c?(m=0,a[b]):a[b]>c?(m=T[R+a[b]],A[I+a[b]]):(m=96,0),u=1<<v-S,w=h=1<<x;i[d+(C>>S)+(h-=u)]=p<<24|m<<16|_|0,0!==h;);for(u=1<<v-1;C&u;)u>>=1;if(0!==u?(C&=u-1,C+=u):C=0,b++,0==--O[v]){if(v===y)break;v=t[r+a[b]]}if(k<v&&(C&l)!==f){for(0===S&&(S=k),d+=w,z=1<<(x=v-S);x+S<y&&!((z-=O[x+S])<=0);)x++,z<<=1;if(E+=1<<x,1===e&&852<E||2===e&&592<E)return 1;i[f=C&l]=k<<24|x<<16|d-s|0}}return 0!==C&&(i[d+C]=v-S<<24|64<<16|0),o.bits=k,0}},{\"..\/utils\/common\":41}],51:[function(e,t,r){\"use strict\";t.exports={2:\"need dictionary\",1:\"stream end\",0:\"\",\"-1\":\"file error\",\"-2\":\"stream error\",\"-3\":\"data error\",\"-4\":\"insufficient memory\",\"-5\":\"buffer error\",\"-6\":\"incompatible version\"}},{}],52:[function(e,t,r){\"use strict\";var o=e(\"..\/utils\/common\");function n(e){for(var t=e.length;0<=--t;)e[t]=0}var _=15,i=16,u=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],h=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],f=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],l=new Array(576);n(l);var d=new Array(60);n(d);var c=new Array(512);n(c);var p=new Array(256);n(p);var m=new Array(29);n(m);var g,v,b,w=new Array(30);function y(e,t,r,n,i){this.static_tree=e,this.extra_bits=t,this.extra_base=r,this.elems=n,this.max_length=i,this.has_stree=e&&e.length}function s(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t}function k(e){return e<256?c[e]:c[256+(e>>>7)]}function x(e,t){e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255}function S(e,t,r){e.bi_valid>i-r?(e.bi_buf|=t<<e.bi_valid&65535,x(e,e.bi_buf),e.bi_buf=t>>i-e.bi_valid,e.bi_valid+=r-i):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=r)}function z(e,t,r){S(e,r[2*t],r[2*t+1])}function E(e,t){for(var r=0;r|=1&e,e>>>=1,r<<=1,0<--t;);return r>>>1}function C(e,t,r){var n,i,s=new Array(_+1),a=0;for(n=1;n<=_;n++)s[n]=a=a+r[n-1]<<1;for(i=0;i<=t;i++){var o=e[2*i+1];0!==o&&(e[2*i]=E(s[o]++,o))}}function A(e){var t;for(t=0;t<286;t++)e.dyn_ltree[2*t]=0;for(t=0;t<30;t++)e.dyn_dtree[2*t]=0;for(t=0;t<19;t++)e.bl_tree[2*t]=0;e.dyn_ltree[512]=1,e.opt_len=e.static_len=0,e.last_lit=e.matches=0}function I(e){8<e.bi_valid?x(e,e.bi_buf):0<e.bi_valid&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0}function O(e,t,r,n){var i=2*t,s=2*r;return e[i]<e[s]||e[i]===e[s]&&n[t]<=n[r]}function B(e,t,r){for(var n=e.heap[r],i=r<<1;i<=e.heap_len&&(i<e.heap_len&&O(t,e.heap[i+1],e.heap[i],e.depth)&&i++,!O(t,n,e.heap[i],e.depth));)e.heap[r]=e.heap[i],r=i,i<<=1;e.heap[r]=n}function T(e,t,r){var n,i,s,a,o=0;if(0!==e.last_lit)for(;n=e.pending_buf[e.d_buf+2*o]<<8|e.pending_buf[e.d_buf+2*o+1],i=e.pending_buf[e.l_buf+o],o++,0===n?z(e,i,t):(z(e,(s=p[i])+256+1,t),0!==(a=u[s])&&S(e,i-=m[s],a),z(e,s=k(--n),r),0!==(a=h[s])&&S(e,n-=w[s],a)),o<e.last_lit;);z(e,256,t)}function R(e,t){var r,n,i,s=t.dyn_tree,a=t.stat_desc.static_tree,o=t.stat_desc.has_stree,u=t.stat_desc.elems,h=-1;for(e.heap_len=0,e.heap_max=573,r=0;r<u;r++)0!==s[2*r]?(e.heap[++e.heap_len]=h=r,e.depth[r]=0):s[2*r+1]=0;for(;e.heap_len<2;)s[2*(i=e.heap[++e.heap_len]=h<2?++h:0)]=1,e.depth[i]=0,e.opt_len--,o&&(e.static_len-=a[2*i+1]);for(t.max_code=h,r=e.heap_len>>1;1<=r;r--)B(e,s,r);for(i=u;r=e.heap[1],e.heap[1]=e.heap[e.heap_len--],B(e,s,1),n=e.heap[1],e.heap[--e.heap_max]=r,e.heap[--e.heap_max]=n,s[2*i]=s[2*r]+s[2*n],e.depth[i]=(e.depth[r]>=e.depth[n]?e.depth[r]:e.depth[n])+1,s[2*r+1]=s[2*n+1]=i,e.heap[1]=i++,B(e,s,1),2<=e.heap_len;);e.heap[--e.heap_max]=e.heap[1],function(e,t){var r,n,i,s,a,o,u=t.dyn_tree,h=t.max_code,f=t.stat_desc.static_tree,l=t.stat_desc.has_stree,d=t.stat_desc.extra_bits,c=t.stat_desc.extra_base,p=t.stat_desc.max_length,m=0;for(s=0;s<=_;s++)e.bl_count[s]=0;for(u[2*e.heap[e.heap_max]+1]=0,r=e.heap_max+1;r<573;r++)p<(s=u[2*u[2*(n=e.heap[r])+1]+1]+1)&&(s=p,m++),u[2*n+1]=s,h<n||(e.bl_count[s]++,a=0,c<=n&&(a=d[n-c]),o=u[2*n],e.opt_len+=o*(s+a),l&&(e.static_len+=o*(f[2*n+1]+a)));if(0!==m){do{for(s=p-1;0===e.bl_count[s];)s--;e.bl_count[s]--,e.bl_count[s+1]+=2,e.bl_count[p]--,m-=2}while(0<m);for(s=p;0!==s;s--)for(n=e.bl_count[s];0!==n;)h<(i=e.heap[--r])||(u[2*i+1]!==s&&(e.opt_len+=(s-u[2*i+1])*u[2*i],u[2*i+1]=s),n--)}}(e,t),C(s,h,e.bl_count)}function D(e,t,r){var n,i,s=-1,a=t[1],o=0,u=7,h=4;for(0===a&&(u=138,h=3),t[2*(r+1)+1]=65535,n=0;n<=r;n++)i=a,a=t[2*(n+1)+1],++o<u&&i===a||(o<h?e.bl_tree[2*i]+=o:0!==i?(i!==s&&e.bl_tree[2*i]++,e.bl_tree[32]++):o<=10?e.bl_tree[34]++:e.bl_tree[36]++,s=i,h=(o=0)===a?(u=138,3):i===a?(u=6,3):(u=7,4))}function F(e,t,r){var n,i,s=-1,a=t[1],o=0,u=7,h=4;for(0===a&&(u=138,h=3),n=0;n<=r;n++)if(i=a,a=t[2*(n+1)+1],!(++o<u&&i===a)){if(o<h)for(;z(e,i,e.bl_tree),0!=--o;);else 0!==i?(i!==s&&(z(e,i,e.bl_tree),o--),z(e,16,e.bl_tree),S(e,o-3,2)):o<=10?(z(e,17,e.bl_tree),S(e,o-3,3)):(z(e,18,e.bl_tree),S(e,o-11,7));s=i,h=(o=0)===a?(u=138,3):i===a?(u=6,3):(u=7,4)}}n(w);var N=!1;function U(e,t,r,n){var i,s,a;S(e,0+(n?1:0),3),s=t,a=r,I(i=e),x(i,a),x(i,~a),o.arraySet(i.pending_buf,i.window,s,a,i.pending),i.pending+=a}r._tr_init=function(e){N||(function(){var e,t,r,n,i,s=new Array(_+1);for(n=r=0;n<28;n++)for(m[n]=r,e=0;e<1<<u[n];e++)p[r++]=n;for(p[r-1]=n,n=i=0;n<16;n++)for(w[n]=i,e=0;e<1<<h[n];e++)c[i++]=n;for(i>>=7;n<30;n++)for(w[n]=i<<7,e=0;e<1<<h[n]-7;e++)c[256+i++]=n;for(t=0;t<=_;t++)s[t]=0;for(e=0;e<=143;)l[2*e+1]=8,e++,s[8]++;for(;e<=255;)l[2*e+1]=9,e++,s[9]++;for(;e<=279;)l[2*e+1]=7,e++,s[7]++;for(;e<=287;)l[2*e+1]=8,e++,s[8]++;for(C(l,287,s),e=0;e<30;e++)d[2*e+1]=5,d[2*e]=E(e,5);g=new y(l,u,257,286,_),v=new y(d,h,0,30,_),b=new y(new Array(0),a,0,19,7)}(),N=!0),e.l_desc=new s(e.dyn_ltree,g),e.d_desc=new s(e.dyn_dtree,v),e.bl_desc=new s(e.bl_tree,b),e.bi_buf=0,e.bi_valid=0,A(e)},r._tr_stored_block=U,r._tr_flush_block=function(e,t,r,n){var i,s,a=0;0<e.level?(2===e.strm.data_type&&(e.strm.data_type=function(e){var t,r=4093624447;for(t=0;t<=31;t++,r>>>=1)if(1&r&&0!==e.dyn_ltree[2*t])return 0;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return 1;for(t=32;t<256;t++)if(0!==e.dyn_ltree[2*t])return 1;return 0}(e)),R(e,e.l_desc),R(e,e.d_desc),a=function(e){var t;for(D(e,e.dyn_ltree,e.l_desc.max_code),D(e,e.dyn_dtree,e.d_desc.max_code),R(e,e.bl_desc),t=18;3<=t&&0===e.bl_tree[2*f[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t}(e),i=e.opt_len+3+7>>>3,(s=e.static_len+3+7>>>3)<=i&&(i=s)):i=s=r+5,r+4<=i&&-1!==t?U(e,t,r,n):4===e.strategy||s===i?(S(e,2+(n?1:0),3),T(e,l,d)):(S(e,4+(n?1:0),3),function(e,t,r,n){var i;for(S(e,t-257,5),S(e,r-1,5),S(e,n-4,4),i=0;i<n;i++)S(e,e.bl_tree[2*f[i]+1],3);F(e,e.dyn_ltree,t-1),F(e,e.dyn_dtree,r-1)}(e,e.l_desc.max_code+1,e.d_desc.max_code+1,a+1),T(e,e.dyn_ltree,e.dyn_dtree)),A(e),n&&I(e)},r._tr_tally=function(e,t,r){return e.pending_buf[e.d_buf+2*e.last_lit]=t>>>8&255,e.pending_buf[e.d_buf+2*e.last_lit+1]=255&t,e.pending_buf[e.l_buf+e.last_lit]=255&r,e.last_lit++,0===t?e.dyn_ltree[2*r]++:(e.matches++,t--,e.dyn_ltree[2*(p[r]+256+1)]++,e.dyn_dtree[2*k(t)]++),e.last_lit===e.lit_bufsize-1},r._tr_align=function(e){var t;S(e,2,3),z(e,256,l),16===(t=e).bi_valid?(x(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):8<=t.bi_valid&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}},{\"..\/utils\/common\":41}],53:[function(e,t,r){\"use strict\";t.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=\"\",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(e,t,r){\"use strict\";t.exports=\"function\"==typeof setImmediate?setImmediate:function(){var e=[].slice.apply(arguments);e.splice(1,0,0),setTimeout.apply(null,e)}},{}]},{},[10])(10)})}).call(this,void 0!==r?r:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}]},{},[1])(1)})}).call(this,void 0!==r?r:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}]},{},[1])(1)})}).call(this,void 0!==r?r:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}]},{},[1])(1)})}).call(this,void 0!==r?r:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}]},{},[1])(1)})}).call(this,\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}]},{},[1])(1)});\n\\ No newline at end of file\n+!function(t){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=t();else if(\"function\"==typeof define&&define.amd)define([],t);else{(\"undefined\"!=typeof window?window:\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:this).JSZip=t()}}(function(){return function s(a,o,h){function u(r,t){if(!o[r]){if(!a[r]){var e=\"function\"==typeof require&&require;if(!t&&e)return e(r,!0);if(l)return l(r,!0);var i=new Error(\"Cannot find module '\"+r+\"'\");throw i.code=\"MODULE_NOT_FOUND\",i}var n=o[r]={exports:{}};a[r][0].call(n.exports,function(t){var e=a[r][1][t];return u(e||t)},n,n.exports,s,a,o,h)}return o[r].exports}for(var l=\"function\"==typeof require&&require,t=0;t<h.length;t++)u(h[t]);return u}({1:[function(t,e,r){\"use strict\";var c=t(\".\/utils\"),d=t(\".\/support\"),p=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+\/=\";r.encode=function(t){for(var e,r,i,n,s,a,o,h=[],u=0,l=t.length,f=l,d=\"string\"!==c.getTypeOf(t);u<t.length;)f=l-u,i=d?(e=t[u++],r=u<l?t[u++]:0,u<l?t[u++]:0):(e=t.charCodeAt(u++),r=u<l?t.charCodeAt(u++):0,u<l?t.charCodeAt(u++):0),n=e>>2,s=(3&e)<<4|r>>4,a=1<f?(15&r)<<2|i>>6:64,o=2<f?63&i:64,h.push(p.charAt(n)+p.charAt(s)+p.charAt(a)+p.charAt(o));return h.join(\"\")},r.decode=function(t){var e,r,i,n,s,a,o=0,h=0,u=\"data:\";if(t.substr(0,u.length)===u)throw new Error(\"Invalid base64 input, it looks like a data url.\");var l,f=3*(t=t.replace(\/[^A-Za-z0-9\\+\\\/\\=]\/g,\"\")).length\/4;if(t.charAt(t.length-1)===p.charAt(64)&&f--,t.charAt(t.length-2)===p.charAt(64)&&f--,f%1!=0)throw new Error(\"Invalid base64 input, bad content length.\");for(l=d.uint8array?new Uint8Array(0|f):new Array(0|f);o<t.length;)e=p.indexOf(t.charAt(o++))<<2|(n=p.indexOf(t.charAt(o++)))>>4,r=(15&n)<<4|(s=p.indexOf(t.charAt(o++)))>>2,i=(3&s)<<6|(a=p.indexOf(t.charAt(o++))),l[h++]=e,64!==s&&(l[h++]=r),64!==a&&(l[h++]=i);return l}},{\".\/support\":30,\".\/utils\":32}],2:[function(t,e,r){\"use strict\";var i=t(\".\/external\"),n=t(\".\/stream\/DataWorker\"),s=t(\".\/stream\/Crc32Probe\"),a=t(\".\/stream\/DataLengthProbe\");function o(t,e,r,i,n){this.compressedSize=t,this.uncompressedSize=e,this.crc32=r,this.compression=i,this.compressedContent=n}o.prototype={getContentWorker:function(){var t=new n(i.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a(\"data_length\")),e=this;return t.on(\"end\",function(){if(this.streamInfo.data_length!==e.uncompressedSize)throw new Error(\"Bug : uncompressed data size mismatch\")}),t},getCompressedWorker:function(){return new n(i.Promise.resolve(this.compressedContent)).withStreamInfo(\"compressedSize\",this.compressedSize).withStreamInfo(\"uncompressedSize\",this.uncompressedSize).withStreamInfo(\"crc32\",this.crc32).withStreamInfo(\"compression\",this.compression)}},o.createWorkerFrom=function(t,e,r){return t.pipe(new s).pipe(new a(\"uncompressedSize\")).pipe(e.compressWorker(r)).pipe(new a(\"compressedSize\")).withStreamInfo(\"compression\",e)},e.exports=o},{\".\/external\":6,\".\/stream\/Crc32Probe\":25,\".\/stream\/DataLengthProbe\":26,\".\/stream\/DataWorker\":27}],3:[function(t,e,r){\"use strict\";var i=t(\".\/stream\/GenericWorker\");r.STORE={magic:\"\\0\\0\",compressWorker:function(t){return new i(\"STORE compression\")},uncompressWorker:function(){return new i(\"STORE decompression\")}},r.DEFLATE=t(\".\/flate\")},{\".\/flate\":7,\".\/stream\/GenericWorker\":28}],4:[function(t,e,r){\"use strict\";var i=t(\".\/utils\");var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e){return void 0!==t&&t.length?\"string\"!==i.getTypeOf(t)?function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}(0|e,t,t.length,0):function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e.charCodeAt(a))];return-1^t}(0|e,t,t.length,0):0}},{\".\/utils\":32}],5:[function(t,e,r){\"use strict\";r.base64=!1,r.binary=!1,r.dir=!1,r.createFolders=!0,r.date=null,r.compression=null,r.compressionOptions=null,r.comment=null,r.unixPermissions=null,r.dosPermissions=null},{}],6:[function(t,e,r){\"use strict\";var i=null;i=\"undefined\"!=typeof Promise?Promise:t(\"lie\"),e.exports={Promise:i}},{lie:37}],7:[function(t,e,r){\"use strict\";var i=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Uint32Array,n=t(\"pako\"),s=t(\".\/utils\"),a=t(\".\/stream\/GenericWorker\"),o=i?\"uint8array\":\"array\";function h(t,e){a.call(this,\"FlateWorker\/\"+t),this._pako=null,this._pakoAction=t,this._pakoOptions=e,this.meta={}}r.magic=\"\\b\\0\",s.inherits(h,a),h.prototype.processChunk=function(t){this.meta=t.meta,null===this._pako&&this._createPako(),this._pako.push(s.transformTo(o,t.data),!1)},h.prototype.flush=function(){a.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},h.prototype.cleanUp=function(){a.prototype.cleanUp.call(this),this._pako=null},h.prototype._createPako=function(){this._pako=new n[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var e=this;this._pako.onData=function(t){e.push({data:t,meta:e.meta})}},r.compressWorker=function(t){return new h(\"Deflate\",t)},r.uncompressWorker=function(){return new h(\"Inflate\",{})}},{\".\/stream\/GenericWorker\":28,\".\/utils\":32,pako:38}],8:[function(t,e,r){\"use strict\";function A(t,e){var r,i=\"\";for(r=0;r<e;r++)i+=String.fromCharCode(255&t),t>>>=8;return i}function i(t,e,r,i,n,s){var a,o,h=t.file,u=t.compression,l=s!==O.utf8encode,f=I.transformTo(\"string\",s(h.name)),d=I.transformTo(\"string\",O.utf8encode(h.name)),c=h.comment,p=I.transformTo(\"string\",s(c)),m=I.transformTo(\"string\",O.utf8encode(c)),_=d.length!==h.name.length,g=m.length!==c.length,b=\"\",v=\"\",y=\"\",w=h.dir,k=h.date,x={crc32:0,compressedSize:0,uncompressedSize:0};e&&!r||(x.crc32=t.crc32,x.compressedSize=t.compressedSize,x.uncompressedSize=t.uncompressedSize);var S=0;e&&(S|=8),l||!_&&!g||(S|=2048);var z=0,C=0;w&&(z|=16),\"UNIX\"===n?(C=798,z|=function(t,e){var r=t;return t||(r=e?16893:33204),(65535&r)<<16}(h.unixPermissions,w)):(C=20,z|=function(t){return 63&(t||0)}(h.dosPermissions)),a=k.getUTCHours(),a<<=6,a|=k.getUTCMinutes(),a<<=5,a|=k.getUTCSeconds()\/2,o=k.getUTCFullYear()-1980,o<<=4,o|=k.getUTCMonth()+1,o<<=5,o|=k.getUTCDate(),_&&(v=A(1,1)+A(B(f),4)+d,b+=\"up\"+A(v.length,2)+v),g&&(y=A(1,1)+A(B(p),4)+m,b+=\"uc\"+A(y.length,2)+y);var E=\"\";return E+=\"\\n\\0\",E+=A(S,2),E+=u.magic,E+=A(a,2),E+=A(o,2),E+=A(x.crc32,4),E+=A(x.compressedSize,4),E+=A(x.uncompressedSize,4),E+=A(f.length,2),E+=A(b.length,2),{fileRecord:R.LOCAL_FILE_HEADER+E+f+b,dirRecord:R.CENTRAL_FILE_HEADER+A(C,2)+E+A(p.length,2)+\"\\0\\0\\0\\0\"+A(z,4)+A(i,4)+f+b+p}}var I=t(\"..\/utils\"),n=t(\"..\/stream\/GenericWorker\"),O=t(\"..\/utf8\"),B=t(\"..\/crc32\"),R=t(\"..\/signature\");function s(t,e,r,i){n.call(this,\"ZipFileWorker\"),this.bytesWritten=0,this.zipComment=e,this.zipPlatform=r,this.encodeFileName=i,this.streamFiles=t,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}I.inherits(s,n),s.prototype.push=function(t){var e=t.meta.percent||0,r=this.entriesCount,i=this._sources.length;this.accumulate?this.contentBuffer.push(t):(this.bytesWritten+=t.data.length,n.prototype.push.call(this,{data:t.data,meta:{currentFile:this.currentFile,percent:r?(e+100*(r-i-1))\/r:100}}))},s.prototype.openedSource=function(t){this.currentSourceOffset=this.bytesWritten,this.currentFile=t.file.name;var e=this.streamFiles&&!t.file.dir;if(e){var r=i(t,e,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:r.fileRecord,meta:{percent:0}})}else this.accumulate=!0},s.prototype.closedSource=function(t){this.accumulate=!1;var e=this.streamFiles&&!t.file.dir,r=i(t,e,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(r.dirRecord),e)this.push({data:function(t){return R.DATA_DESCRIPTOR+A(t.crc32,4)+A(t.compressedSize,4)+A(t.uncompressedSize,4)}(t),meta:{percent:100}});else for(this.push({data:r.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},s.prototype.flush=function(){for(var t=this.bytesWritten,e=0;e<this.dirRecords.length;e++)this.push({data:this.dirRecords[e],meta:{percent:100}});var r=this.bytesWritten-t,i=function(t,e,r,i,n){var s=I.transformTo(\"string\",n(i));return R.CENTRAL_DIRECTORY_END+\"\\0\\0\\0\\0\"+A(t,2)+A(t,2)+A(e,4)+A(r,4)+A(s.length,2)+s}(this.dirRecords.length,r,t,this.zipComment,this.encodeFileName);this.push({data:i,meta:{percent:100}})},s.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},s.prototype.registerPrevious=function(t){this._sources.push(t);var e=this;return t.on(\"data\",function(t){e.processChunk(t)}),t.on(\"end\",function(){e.closedSource(e.previous.streamInfo),e._sources.length?e.prepareNextSource():e.end()}),t.on(\"error\",function(t){e.error(t)}),this},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},s.prototype.error=function(t){var e=this._sources;if(!n.prototype.error.call(this,t))return!1;for(var r=0;r<e.length;r++)try{e[r].error(t)}catch(t){}return!0},s.prototype.lock=function(){n.prototype.lock.call(this);for(var t=this._sources,e=0;e<t.length;e++)t[e].lock()},e.exports=s},{\"..\/crc32\":4,\"..\/signature\":23,\"..\/stream\/GenericWorker\":28,\"..\/utf8\":31,\"..\/utils\":32}],9:[function(t,e,r){\"use strict\";var u=t(\"..\/compressions\"),i=t(\".\/ZipFileWorker\");r.generateWorker=function(t,a,e){var o=new i(a.streamFiles,e,a.platform,a.encodeFileName),h=0;try{t.forEach(function(t,e){h++;var r=function(t,e){var r=t||e,i=u[r];if(!i)throw new Error(r+\" is not a valid compression method !\");return i}(e.options.compression,a.compression),i=e.options.compressionOptions||a.compressionOptions||{},n=e.dir,s=e.date;e._compressWorker(r,i).withStreamInfo(\"file\",{name:t,dir:n,date:s,comment:e.comment||\"\",unixPermissions:e.unixPermissions,dosPermissions:e.dosPermissions}).pipe(o)}),o.entriesCount=h}catch(t){o.error(t)}return o}},{\"..\/compressions\":3,\".\/ZipFileWorker\":8}],10:[function(t,e,r){\"use strict\";function i(){if(!(this instanceof i))return new i;if(arguments.length)throw new Error(\"The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.\");this.files=Object.create(null),this.comment=null,this.root=\"\",this.clone=function(){var t=new i;for(var e in this)\"function\"!=typeof this[e]&&(t[e]=this[e]);return t}}(i.prototype=t(\".\/object\")).loadAsync=t(\".\/load\"),i.support=t(\".\/support\"),i.defaults=t(\".\/defaults\"),i.version=\"3.7.1\",i.loadAsync=function(t,e){return(new i).loadAsync(t,e)},i.external=t(\".\/external\"),e.exports=i},{\".\/defaults\":5,\".\/external\":6,\".\/load\":11,\".\/object\":15,\".\/support\":30}],11:[function(t,e,r){\"use strict\";var i=t(\".\/utils\"),n=t(\".\/external\"),o=t(\".\/utf8\"),h=t(\".\/zipEntries\"),s=t(\".\/stream\/Crc32Probe\"),u=t(\".\/nodejsUtils\");function l(i){return new n.Promise(function(t,e){var r=i.decompressed.getContentWorker().pipe(new s);r.on(\"error\",function(t){e(t)}).on(\"end\",function(){r.streamInfo.crc32!==i.decompressed.crc32?e(new Error(\"Corrupted zip : CRC32 mismatch\")):t()}).resume()})}e.exports=function(t,s){var a=this;return s=i.extend(s||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:o.utf8decode}),u.isNode&&u.isStream(t)?n.Promise.reject(new Error(\"JSZip can't accept a stream when loading a zip file.\")):i.prepareContent(\"the loaded zip file\",t,!0,s.optimizedBinaryString,s.base64).then(function(t){var e=new h(s);return e.load(t),e}).then(function(t){var e=[n.Promise.resolve(t)],r=t.files;if(s.checkCRC32)for(var i=0;i<r.length;i++)e.push(l(r[i]));return n.Promise.all(e)}).then(function(t){for(var e=t.shift(),r=e.files,i=0;i<r.length;i++){var n=r[i];a.file(n.fileNameStr,n.decompressed,{binary:!0,optimizedBinaryString:!0,date:n.date,dir:n.dir,comment:n.fileCommentStr.length?n.fileCommentStr:null,unixPermissions:n.unixPermissions,dosPermissions:n.dosPermissions,createFolders:s.createFolders})}return e.zipComment.length&&(a.comment=e.zipComment),a})}},{\".\/external\":6,\".\/nodejsUtils\":14,\".\/stream\/Crc32Probe\":25,\".\/utf8\":31,\".\/utils\":32,\".\/zipEntries\":33}],12:[function(t,e,r){\"use strict\";var i=t(\"..\/utils\"),n=t(\"..\/stream\/GenericWorker\");function s(t,e){n.call(this,\"Nodejs stream input adapter for \"+t),this._upstreamEnded=!1,this._bindStream(e)}i.inherits(s,n),s.prototype._bindStream=function(t){var e=this;(this._stream=t).pause(),t.on(\"data\",function(t){e.push({data:t,meta:{percent:0}})}).on(\"error\",function(t){e.isPaused?this.generatedError=t:e.error(t)}).on(\"end\",function(){e.isPaused?e._upstreamEnded=!0:e.end()})},s.prototype.pause=function(){return!!n.prototype.pause.call(this)&&(this._stream.pause(),!0)},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},e.exports=s},{\"..\/stream\/GenericWorker\":28,\"..\/utils\":32}],13:[function(t,e,r){\"use strict\";var n=t(\"readable-stream\").Readable;function i(t,e,r){n.call(this,e),this._helper=t;var i=this;t.on(\"data\",function(t,e){i.push(t)||i._helper.pause(),r&&r(e)}).on(\"error\",function(t){i.emit(\"error\",t)}).on(\"end\",function(){i.push(null)})}t(\"..\/utils\").inherits(i,n),i.prototype._read=function(){this._helper.resume()},e.exports=i},{\"..\/utils\":32,\"readable-stream\":16}],14:[function(t,e,r){\"use strict\";e.exports={isNode:\"undefined\"!=typeof Buffer,newBufferFrom:function(t,e){if(Buffer.from&&Buffer.from!==Uint8Array.from)return Buffer.from(t,e);if(\"number\"==typeof t)throw new Error('The \"data\" argument must not be a number');return new Buffer(t,e)},allocBuffer:function(t){if(Buffer.alloc)return Buffer.alloc(t);var e=new Buffer(t);return e.fill(0),e},isBuffer:function(t){return Buffer.isBuffer(t)},isStream:function(t){return t&&\"function\"==typeof t.on&&\"function\"==typeof t.pause&&\"function\"==typeof t.resume}}},{}],15:[function(t,e,r){\"use strict\";function s(t,e,r){var i,n=u.getTypeOf(e),s=u.extend(r||{},f);s.date=s.date||new Date,null!==s.compression&&(s.compression=s.compression.toUpperCase()),\"string\"==typeof s.unixPermissions&&(s.unixPermissions=parseInt(s.unixPermissions,8)),s.unixPermissions&&16384&s.unixPermissions&&(s.dir=!0),s.dosPermissions&&16&s.dosPermissions&&(s.dir=!0),s.dir&&(t=g(t)),s.createFolders&&(i=_(t))&&b.call(this,i,!0);var a=\"string\"===n&&!1===s.binary&&!1===s.base64;r&&void 0!==r.binary||(s.binary=!a),(e instanceof d&&0===e.uncompressedSize||s.dir||!e||0===e.length)&&(s.base64=!1,s.binary=!0,e=\"\",s.compression=\"STORE\",n=\"string\");var o=null;o=e instanceof d||e instanceof l?e:p.isNode&&p.isStream(e)?new m(t,e):u.prepareContent(t,e,s.binary,s.optimizedBinaryString,s.base64);var h=new c(t,o,s);this.files[t]=h}var n=t(\".\/utf8\"),u=t(\".\/utils\"),l=t(\".\/stream\/GenericWorker\"),a=t(\".\/stream\/StreamHelper\"),f=t(\".\/defaults\"),d=t(\".\/compressedObject\"),c=t(\".\/zipObject\"),o=t(\".\/generate\"),p=t(\".\/nodejsUtils\"),m=t(\".\/nodejs\/NodejsStreamInputAdapter\"),_=function(t){\"\/\"===t.slice(-1)&&(t=t.substring(0,t.length-1));var e=t.lastIndexOf(\"\/\");return 0<e?t.substring(0,e):\"\"},g=function(t){return\"\/\"!==t.slice(-1)&&(t+=\"\/\"),t},b=function(t,e){return e=void 0!==e?e:f.createFolders,t=g(t),this.files[t]||s.call(this,t,null,{dir:!0,createFolders:e}),this.files[t]};function h(t){return\"[object RegExp]\"===Object.prototype.toString.call(t)}var i={load:function(){throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\")},forEach:function(t){var e,r,i;for(e in this.files)i=this.files[e],(r=e.slice(this.root.length,e.length))&&e.slice(0,this.root.length)===this.root&&t(r,i)},filter:function(r){var i=[];return this.forEach(function(t,e){r(t,e)&&i.push(e)}),i},file:function(t,e,r){if(1!==arguments.length)return t=this.root+t,s.call(this,t,e,r),this;if(h(t)){var i=t;return this.filter(function(t,e){return!e.dir&&i.test(t)})}var n=this.files[this.root+t];return n&&!n.dir?n:null},folder:function(r){if(!r)return this;if(h(r))return this.filter(function(t,e){return e.dir&&r.test(t)});var t=this.root+r,e=b.call(this,t),i=this.clone();return i.root=e.name,i},remove:function(r){r=this.root+r;var t=this.files[r];if(t||(\"\/\"!==r.slice(-1)&&(r+=\"\/\"),t=this.files[r]),t&&!t.dir)delete this.files[r];else for(var e=this.filter(function(t,e){return e.name.slice(0,r.length)===r}),i=0;i<e.length;i++)delete this.files[e[i].name];return this},generate:function(t){throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\")},generateInternalStream:function(t){var e,r={};try{if((r=u.extend(t||{},{streamFiles:!1,compression:\"STORE\",compressionOptions:null,type:\"\",platform:\"DOS\",comment:null,mimeType:\"application\/zip\",encodeFileName:n.utf8encode})).type=r.type.toLowerCase(),r.compression=r.compression.toUpperCase(),\"binarystring\"===r.type&&(r.type=\"string\"),!r.type)throw new Error(\"No output type specified.\");u.checkSupport(r.type),\"darwin\"!==r.platform&&\"freebsd\"!==r.platform&&\"linux\"!==r.platform&&\"sunos\"!==r.platform||(r.platform=\"UNIX\"),\"win32\"===r.platform&&(r.platform=\"DOS\");var i=r.comment||this.comment||\"\";e=o.generateWorker(this,r,i)}catch(t){(e=new l(\"error\")).error(t)}return new a(e,r.type||\"string\",r.mimeType)},generateAsync:function(t,e){return this.generateInternalStream(t).accumulate(e)},generateNodeStream:function(t,e){return(t=t||{}).type||(t.type=\"nodebuffer\"),this.generateInternalStream(t).toNodejsStream(e)}};e.exports=i},{\".\/compressedObject\":2,\".\/defaults\":5,\".\/generate\":9,\".\/nodejs\/NodejsStreamInputAdapter\":12,\".\/nodejsUtils\":14,\".\/stream\/GenericWorker\":28,\".\/stream\/StreamHelper\":29,\".\/utf8\":31,\".\/utils\":32,\".\/zipObject\":35}],16:[function(t,e,r){e.exports=t(\"stream\")},{stream:void 0}],17:[function(t,e,r){\"use strict\";var i=t(\".\/DataReader\");function n(t){i.call(this,t);for(var e=0;e<this.data.length;e++)t[e]=255&t[e]}t(\"..\/utils\").inherits(n,i),n.prototype.byteAt=function(t){return this.data[this.zero+t]},n.prototype.lastIndexOfSignature=function(t){for(var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.length-4;0<=s;--s)if(this.data[s]===e&&this.data[s+1]===r&&this.data[s+2]===i&&this.data[s+3]===n)return s-this.zero;return-1},n.prototype.readAndCheckSignature=function(t){var e=t.charCodeAt(0),r=t.charCodeAt(1),i=t.charCodeAt(2),n=t.charCodeAt(3),s=this.readData(4);return e===s[0]&&r===s[1]&&i===s[2]&&n===s[3]},n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return[];var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{\"..\/utils\":32,\".\/DataReader\":18}],18:[function(t,e,r){\"use strict\";var i=t(\"..\/utils\");function n(t){this.data=t,this.length=t.length,this.index=0,this.zero=0}n.prototype={checkOffset:function(t){this.checkIndex(this.index+t)},checkIndex:function(t){if(this.length<this.zero+t||t<0)throw new Error(\"End of data reached (data length = \"+this.length+\", asked index = \"+t+\"). Corrupted zip ?\")},setIndex:function(t){this.checkIndex(t),this.index=t},skip:function(t){this.setIndex(this.index+t)},byteAt:function(t){},readInt:function(t){var e,r=0;for(this.checkOffset(t),e=this.index+t-1;e>=this.index;e--)r=(r<<8)+this.byteAt(e);return this.index+=t,r},readString:function(t){return i.transformTo(\"string\",this.readData(t))},readData:function(t){},lastIndexOfSignature:function(t){},readAndCheckSignature:function(t){},readDate:function(){var t=this.readInt(4);return new Date(Date.UTC(1980+(t>>25&127),(t>>21&15)-1,t>>16&31,t>>11&31,t>>5&63,(31&t)<<1))}},e.exports=n},{\"..\/utils\":32}],19:[function(t,e,r){\"use strict\";var i=t(\".\/Uint8ArrayReader\");function n(t){i.call(this,t)}t(\"..\/utils\").inherits(n,i),n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{\"..\/utils\":32,\".\/Uint8ArrayReader\":21}],20:[function(t,e,r){\"use strict\";var i=t(\".\/DataReader\");function n(t){i.call(this,t)}t(\"..\/utils\").inherits(n,i),n.prototype.byteAt=function(t){return this.data.charCodeAt(this.zero+t)},n.prototype.lastIndexOfSignature=function(t){return this.data.lastIndexOf(t)-this.zero},n.prototype.readAndCheckSignature=function(t){return t===this.readData(4)},n.prototype.readData=function(t){this.checkOffset(t);var e=this.data.slice(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{\"..\/utils\":32,\".\/DataReader\":18}],21:[function(t,e,r){\"use strict\";var i=t(\".\/ArrayReader\");function n(t){i.call(this,t)}t(\"..\/utils\").inherits(n,i),n.prototype.readData=function(t){if(this.checkOffset(t),0===t)return new Uint8Array(0);var e=this.data.subarray(this.zero+this.index,this.zero+this.index+t);return this.index+=t,e},e.exports=n},{\"..\/utils\":32,\".\/ArrayReader\":17}],22:[function(t,e,r){\"use strict\";var i=t(\"..\/utils\"),n=t(\"..\/support\"),s=t(\".\/ArrayReader\"),a=t(\".\/StringReader\"),o=t(\".\/NodeBufferReader\"),h=t(\".\/Uint8ArrayReader\");e.exports=function(t){var e=i.getTypeOf(t);return i.checkSupport(e),\"string\"!==e||n.uint8array?\"nodebuffer\"===e?new o(t):n.uint8array?new h(i.transformTo(\"uint8array\",t)):new s(i.transformTo(\"array\",t)):new a(t)}},{\"..\/support\":30,\"..\/utils\":32,\".\/ArrayReader\":17,\".\/NodeBufferReader\":19,\".\/StringReader\":20,\".\/Uint8ArrayReader\":21}],23:[function(t,e,r){\"use strict\";r.LOCAL_FILE_HEADER=\"PK\",r.CENTRAL_FILE_HEADER=\"PK\",r.CENTRAL_DIRECTORY_END=\"PK\",r.ZIP64_CENTRAL_DIRECTORY_LOCATOR=\"PK\",r.ZIP64_CENTRAL_DIRECTORY_END=\"PK\",r.DATA_DESCRIPTOR=\"PK\\b\"},{}],24:[function(t,e,r){\"use strict\";var i=t(\".\/GenericWorker\"),n=t(\"..\/utils\");function s(t){i.call(this,\"ConvertWorker to \"+t),this.destType=t}n.inherits(s,i),s.prototype.processChunk=function(t){this.push({data:n.transformTo(this.destType,t.data),meta:t.meta})},e.exports=s},{\"..\/utils\":32,\".\/GenericWorker\":28}],25:[function(t,e,r){\"use strict\";var i=t(\".\/GenericWorker\"),n=t(\"..\/crc32\");function s(){i.call(this,\"Crc32Probe\"),this.withStreamInfo(\"crc32\",0)}t(\"..\/utils\").inherits(s,i),s.prototype.processChunk=function(t){this.streamInfo.crc32=n(t.data,this.streamInfo.crc32||0),this.push(t)},e.exports=s},{\"..\/crc32\":4,\"..\/utils\":32,\".\/GenericWorker\":28}],26:[function(t,e,r){\"use strict\";var i=t(\"..\/utils\"),n=t(\".\/GenericWorker\");function s(t){n.call(this,\"DataLengthProbe for \"+t),this.propName=t,this.withStreamInfo(t,0)}i.inherits(s,n),s.prototype.processChunk=function(t){if(t){var e=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=e+t.data.length}n.prototype.processChunk.call(this,t)},e.exports=s},{\"..\/utils\":32,\".\/GenericWorker\":28}],27:[function(t,e,r){\"use strict\";var i=t(\"..\/utils\"),n=t(\".\/GenericWorker\");function s(t){n.call(this,\"DataWorker\");var e=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type=\"\",this._tickScheduled=!1,t.then(function(t){e.dataIsReady=!0,e.data=t,e.max=t&&t.length||0,e.type=i.getTypeOf(t),e.isPaused||e._tickAndRepeat()},function(t){e.error(t)})}i.inherits(s,n),s.prototype.cleanUp=function(){n.prototype.cleanUp.call(this),this.data=null},s.prototype.resume=function(){return!!n.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,i.delay(this._tickAndRepeat,[],this)),!0)},s.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(i.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},s.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var t=null,e=Math.min(this.max,this.index+16384);if(this.index>=this.max)return this.end();switch(this.type){case\"string\":t=this.data.substring(this.index,e);break;case\"uint8array\":t=this.data.subarray(this.index,e);break;case\"array\":case\"nodebuffer\":t=this.data.slice(this.index,e)}return this.index=e,this.push({data:t,meta:{percent:this.max?this.index\/this.max*100:0}})},e.exports=s},{\"..\/utils\":32,\".\/GenericWorker\":28}],28:[function(t,e,r){\"use strict\";function i(t){this.name=t||\"default\",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}i.prototype={push:function(t){this.emit(\"data\",t)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit(\"end\"),this.cleanUp(),this.isFinished=!0}catch(t){this.emit(\"error\",t)}return!0},error:function(t){return!this.isFinished&&(this.isPaused?this.generatedError=t:(this.isFinished=!0,this.emit(\"error\",t),this.previous&&this.previous.error(t),this.cleanUp()),!0)},on:function(t,e){return this._listeners[t].push(e),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(t,e){if(this._listeners[t])for(var r=0;r<this._listeners[t].length;r++)this._listeners[t][r].call(this,e)},pipe:function(t){return t.registerPrevious(this)},registerPrevious:function(t){if(this.isLocked)throw new Error(\"The stream '\"+this+\"' has already been used.\");this.streamInfo=t.streamInfo,this.mergeStreamInfo(),this.previous=t;var e=this;return t.on(\"data\",function(t){e.processChunk(t)}),t.on(\"end\",function(){e.end()}),t.on(\"error\",function(t){e.error(t)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;var t=this.isPaused=!1;return this.generatedError&&(this.error(this.generatedError),t=!0),this.previous&&this.previous.resume(),!t},flush:function(){},processChunk:function(t){this.push(t)},withStreamInfo:function(t,e){return this.extraStreamInfo[t]=e,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var t in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(t)&&(this.streamInfo[t]=this.extraStreamInfo[t])},lock:function(){if(this.isLocked)throw new Error(\"The stream '\"+this+\"' has already been used.\");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var t=\"Worker \"+this.name;return this.previous?this.previous+\" -> \"+t:t}},e.exports=i},{}],29:[function(t,e,r){\"use strict\";var h=t(\"..\/utils\"),n=t(\".\/ConvertWorker\"),s=t(\".\/GenericWorker\"),u=t(\"..\/base64\"),i=t(\"..\/support\"),a=t(\"..\/external\"),o=null;if(i.nodestream)try{o=t(\"..\/nodejs\/NodejsStreamOutputAdapter\")}catch(t){}function l(t,o){return new a.Promise(function(e,r){var i=[],n=t._internalType,s=t._outputType,a=t._mimeType;t.on(\"data\",function(t,e){i.push(t),o&&o(e)}).on(\"error\",function(t){i=[],r(t)}).on(\"end\",function(){try{var t=function(t,e,r){switch(t){case\"blob\":return h.newBlob(h.transformTo(\"arraybuffer\",e),r);case\"base64\":return u.encode(e);default:return h.transformTo(t,e)}}(s,function(t,e){var r,i=0,n=null,s=0;for(r=0;r<e.length;r++)s+=e[r].length;switch(t){case\"string\":return e.join(\"\");case\"array\":return Array.prototype.concat.apply([],e);case\"uint8array\":for(n=new Uint8Array(s),r=0;r<e.length;r++)n.set(e[r],i),i+=e[r].length;return n;case\"nodebuffer\":return Buffer.concat(e);default:throw new Error(\"concat : unsupported type '\"+t+\"'\")}}(n,i),a);e(t)}catch(t){r(t)}i=[]}).resume()})}function f(t,e,r){var i=e;switch(e){case\"blob\":case\"arraybuffer\":i=\"uint8array\";break;case\"base64\":i=\"string\"}try{this._internalType=i,this._outputType=e,this._mimeType=r,h.checkSupport(i),this._worker=t.pipe(new n(i)),t.lock()}catch(t){this._worker=new s(\"error\"),this._worker.error(t)}}f.prototype={accumulate:function(t){return l(this,t)},on:function(t,e){var r=this;return\"data\"===t?this._worker.on(t,function(t){e.call(r,t.data,t.meta)}):this._worker.on(t,function(){h.delay(e,arguments,r)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(t){if(h.checkSupport(\"nodestream\"),\"nodebuffer\"!==this._outputType)throw new Error(this._outputType+\" is not supported by this method\");return new o(this,{objectMode:\"nodebuffer\"!==this._outputType},t)}},e.exports=f},{\"..\/base64\":1,\"..\/external\":6,\"..\/nodejs\/NodejsStreamOutputAdapter\":13,\"..\/support\":30,\"..\/utils\":32,\".\/ConvertWorker\":24,\".\/GenericWorker\":28}],30:[function(t,e,r){\"use strict\";if(r.base64=!0,r.array=!0,r.string=!0,r.arraybuffer=\"undefined\"!=typeof ArrayBuffer&&\"undefined\"!=typeof Uint8Array,r.nodebuffer=\"undefined\"!=typeof Buffer,r.uint8array=\"undefined\"!=typeof Uint8Array,\"undefined\"==typeof ArrayBuffer)r.blob=!1;else{var i=new ArrayBuffer(0);try{r.blob=0===new Blob([i],{type:\"application\/zip\"}).size}catch(t){try{var n=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);n.append(i),r.blob=0===n.getBlob(\"application\/zip\").size}catch(t){r.blob=!1}}}try{r.nodestream=!!t(\"readable-stream\").Readable}catch(t){r.nodestream=!1}},{\"readable-stream\":16}],31:[function(t,e,s){\"use strict\";for(var o=t(\".\/utils\"),h=t(\".\/support\"),r=t(\".\/nodejsUtils\"),i=t(\".\/stream\/GenericWorker\"),u=new Array(256),n=0;n<256;n++)u[n]=252<=n?6:248<=n?5:240<=n?4:224<=n?3:192<=n?2:1;u[254]=u[254]=1;function a(){i.call(this,\"utf-8 decode\"),this.leftOver=null}function l(){i.call(this,\"utf-8 encode\")}s.utf8encode=function(t){return h.nodebuffer?r.newBufferFrom(t,\"utf-8\"):function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=h.uint8array?new Uint8Array(o):new Array(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e}(t)},s.utf8decode=function(t){return h.nodebuffer?o.transformTo(\"nodebuffer\",t).toString(\"utf-8\"):function(t){var e,r,i,n,s=t.length,a=new Array(2*s);for(e=r=0;e<s;)if((i=t[e++])<128)a[r++]=i;else if(4<(n=u[i]))a[r++]=65533,e+=n-1;else{for(i&=2===n?31:3===n?15:7;1<n&&e<s;)i=i<<6|63&t[e++],n--;1<n?a[r++]=65533:i<65536?a[r++]=i:(i-=65536,a[r++]=55296|i>>10&1023,a[r++]=56320|1023&i)}return a.length!==r&&(a.subarray?a=a.subarray(0,r):a.length=r),o.applyFromCharCode(a)}(t=o.transformTo(h.uint8array?\"uint8array\":\"array\",t))},o.inherits(a,i),a.prototype.processChunk=function(t){var e=o.transformTo(h.uint8array?\"uint8array\":\"array\",t.data);if(this.leftOver&&this.leftOver.length){if(h.uint8array){var r=e;(e=new Uint8Array(r.length+this.leftOver.length)).set(this.leftOver,0),e.set(r,this.leftOver.length)}else e=this.leftOver.concat(e);this.leftOver=null}var i=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}(e),n=e;i!==e.length&&(h.uint8array?(n=e.subarray(0,i),this.leftOver=e.subarray(i,e.length)):(n=e.slice(0,i),this.leftOver=e.slice(i,e.length))),this.push({data:s.utf8decode(n),meta:t.meta})},a.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:s.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},s.Utf8DecodeWorker=a,o.inherits(l,i),l.prototype.processChunk=function(t){this.push({data:s.utf8encode(t.data),meta:t.meta})},s.Utf8EncodeWorker=l},{\".\/nodejsUtils\":14,\".\/stream\/GenericWorker\":28,\".\/support\":30,\".\/utils\":32}],32:[function(t,e,a){\"use strict\";var o=t(\".\/support\"),h=t(\".\/base64\"),r=t(\".\/nodejsUtils\"),i=t(\"set-immediate-shim\"),u=t(\".\/external\");function n(t){return t}function l(t,e){for(var r=0;r<t.length;++r)e[r]=255&t.charCodeAt(r);return e}a.newBlob=function(e,r){a.checkSupport(\"blob\");try{return new Blob([e],{type:r})}catch(t){try{var i=new(self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder);return i.append(e),i.getBlob(r)}catch(t){throw new Error(\"Bug : can't construct the Blob.\")}}};var s={stringifyByChunk:function(t,e,r){var i=[],n=0,s=t.length;if(s<=r)return String.fromCharCode.apply(null,t);for(;n<s;)\"array\"===e||\"nodebuffer\"===e?i.push(String.fromCharCode.apply(null,t.slice(n,Math.min(n+r,s)))):i.push(String.fromCharCode.apply(null,t.subarray(n,Math.min(n+r,s)))),n+=r;return i.join(\"\")},stringifyByChar:function(t){for(var e=\"\",r=0;r<t.length;r++)e+=String.fromCharCode(t[r]);return e},applyCanBeUsed:{uint8array:function(){try{return o.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(t){return!1}}(),nodebuffer:function(){try{return o.nodebuffer&&1===String.fromCharCode.apply(null,r.allocBuffer(1)).length}catch(t){return!1}}()}};function f(t){var e=65536,r=a.getTypeOf(t),i=!0;if(\"uint8array\"===r?i=s.applyCanBeUsed.uint8array:\"nodebuffer\"===r&&(i=s.applyCanBeUsed.nodebuffer),i)for(;1<e;)try{return s.stringifyByChunk(t,r,e)}catch(t){e=Math.floor(e\/2)}return s.stringifyByChar(t)}function d(t,e){for(var r=0;r<t.length;r++)e[r]=t[r];return e}a.applyFromCharCode=f;var c={};c.string={string:n,array:function(t){return l(t,new Array(t.length))},arraybuffer:function(t){return c.string.uint8array(t).buffer},uint8array:function(t){return l(t,new Uint8Array(t.length))},nodebuffer:function(t){return l(t,r.allocBuffer(t.length))}},c.array={string:f,array:n,arraybuffer:function(t){return new Uint8Array(t).buffer},uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(t)}},c.arraybuffer={string:function(t){return f(new Uint8Array(t))},array:function(t){return d(new Uint8Array(t),new Array(t.byteLength))},arraybuffer:n,uint8array:function(t){return new Uint8Array(t)},nodebuffer:function(t){return r.newBufferFrom(new Uint8Array(t))}},c.uint8array={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return t.buffer},uint8array:n,nodebuffer:function(t){return r.newBufferFrom(t)}},c.nodebuffer={string:f,array:function(t){return d(t,new Array(t.length))},arraybuffer:function(t){return c.nodebuffer.uint8array(t).buffer},uint8array:function(t){return d(t,new Uint8Array(t.length))},nodebuffer:n},a.transformTo=function(t,e){if(e=e||\"\",!t)return e;a.checkSupport(t);var r=a.getTypeOf(e);return c[r][t](e)},a.getTypeOf=function(t){return\"string\"==typeof t?\"string\":\"[object Array]\"===Object.prototype.toString.call(t)?\"array\":o.nodebuffer&&r.isBuffer(t)?\"nodebuffer\":o.uint8array&&t instanceof Uint8Array?\"uint8array\":o.arraybuffer&&t instanceof ArrayBuffer?\"arraybuffer\":void 0},a.checkSupport=function(t){if(!o[t.toLowerCase()])throw new Error(t+\" is not supported by this platform\")},a.MAX_VALUE_16BITS=65535,a.MAX_VALUE_32BITS=-1,a.pretty=function(t){var e,r,i=\"\";for(r=0;r<(t||\"\").length;r++)i+=\"\\\\x\"+((e=t.charCodeAt(r))<16?\"0\":\"\")+e.toString(16).toUpperCase();return i},a.delay=function(t,e,r){i(function(){t.apply(r||null,e||[])})},a.inherits=function(t,e){function r(){}r.prototype=e.prototype,t.prototype=new r},a.extend=function(){var t,e,r={};for(t=0;t<arguments.length;t++)for(e in arguments[t])arguments[t].hasOwnProperty(e)&&void 0===r[e]&&(r[e]=arguments[t][e]);return r},a.prepareContent=function(r,t,i,n,s){return u.Promise.resolve(t).then(function(i){return o.blob&&(i instanceof Blob||-1!==[\"[object File]\",\"[object Blob]\"].indexOf(Object.prototype.toString.call(i)))&&\"undefined\"!=typeof FileReader?new u.Promise(function(e,r){var t=new FileReader;t.onload=function(t){e(t.target.result)},t.onerror=function(t){r(t.target.error)},t.readAsArrayBuffer(i)}):i}).then(function(t){var e=a.getTypeOf(t);return e?(\"arraybuffer\"===e?t=a.transformTo(\"uint8array\",t):\"string\"===e&&(s?t=h.decode(t):i&&!0!==n&&(t=function(t){return l(t,o.uint8array?new Uint8Array(t.length):new Array(t.length))}(t))),t):u.Promise.reject(new Error(\"Can't read the data of '\"+r+\"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?\"))})}},{\".\/base64\":1,\".\/external\":6,\".\/nodejsUtils\":14,\".\/support\":30,\"set-immediate-shim\":54}],33:[function(t,e,r){\"use strict\";var i=t(\".\/reader\/readerFor\"),n=t(\".\/utils\"),s=t(\".\/signature\"),a=t(\".\/zipEntry\"),o=(t(\".\/utf8\"),t(\".\/support\"));function h(t){this.files=[],this.loadOptions=t}h.prototype={checkSignature:function(t){if(!this.reader.readAndCheckSignature(t)){this.reader.index-=4;var e=this.reader.readString(4);throw new Error(\"Corrupted zip or bug: unexpected signature (\"+n.pretty(e)+\", expected \"+n.pretty(t)+\")\")}},isSignature:function(t,e){var r=this.reader.index;this.reader.setIndex(t);var i=this.reader.readString(4)===e;return this.reader.setIndex(r),i},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var t=this.reader.readData(this.zipCommentLength),e=o.uint8array?\"uint8array\":\"array\",r=n.transformTo(e,t);this.zipComment=this.loadOptions.decodeFileName(r)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var t,e,r,i=this.zip64EndOfCentralSize-44;0<i;)t=this.reader.readInt(2),e=this.reader.readInt(4),r=this.reader.readData(e),this.zip64ExtensibleData[t]={id:t,length:e,value:r}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),1<this.disksCount)throw new Error(\"Multi-volumes zip are not supported\")},readLocalFiles:function(){var t,e;for(t=0;t<this.files.length;t++)e=this.files[t],this.reader.setIndex(e.localHeaderOffset),this.checkSignature(s.LOCAL_FILE_HEADER),e.readLocalPart(this.reader),e.handleUTF8(),e.processAttributes()},readCentralDir:function(){var t;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER);)(t=new a({zip64:this.zip64},this.loadOptions)).readCentralPart(this.reader),this.files.push(t);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error(\"Corrupted zip or bug: expected \"+this.centralDirRecords+\" records in central dir, got \"+this.files.length)},readEndOfCentral:function(){var t=this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);if(t<0)throw!this.isSignature(0,s.LOCAL_FILE_HEADER)?new Error(\"Can't find end of central directory : is this a zip file ? If it is, see https:\/\/stuk.github.io\/jszip\/documentation\/howto\/read_zip.html\"):new Error(\"Corrupted zip: can't find end of central directory\");this.reader.setIndex(t);var e=t;if(this.checkSignature(s.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===n.MAX_VALUE_16BITS||this.diskWithCentralDirStart===n.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===n.MAX_VALUE_16BITS||this.centralDirRecords===n.MAX_VALUE_16BITS||this.centralDirSize===n.MAX_VALUE_32BITS||this.centralDirOffset===n.MAX_VALUE_32BITS){if(this.zip64=!0,(t=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR))<0)throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory locator\");if(this.reader.setIndex(t),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,s.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error(\"Corrupted zip: can't find the ZIP64 end of central directory\");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var r=this.centralDirOffset+this.centralDirSize;this.zip64&&(r+=20,r+=12+this.zip64EndOfCentralSize);var i=e-r;if(0<i)this.isSignature(e,s.CENTRAL_FILE_HEADER)||(this.reader.zero=i);else if(i<0)throw new Error(\"Corrupted zip: missing \"+Math.abs(i)+\" bytes.\")},prepareReader:function(t){this.reader=i(t)},load:function(t){this.prepareReader(t),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},e.exports=h},{\".\/reader\/readerFor\":22,\".\/signature\":23,\".\/support\":30,\".\/utf8\":31,\".\/utils\":32,\".\/zipEntry\":34}],34:[function(t,e,r){\"use strict\";var i=t(\".\/reader\/readerFor\"),s=t(\".\/utils\"),n=t(\".\/compressedObject\"),a=t(\".\/crc32\"),o=t(\".\/utf8\"),h=t(\".\/compressions\"),u=t(\".\/support\");function l(t,e){this.options=t,this.loadOptions=e}l.prototype={isEncrypted:function(){return 1==(1&this.bitFlag)},useUTF8:function(){return 2048==(2048&this.bitFlag)},readLocalPart:function(t){var e,r;if(t.skip(22),this.fileNameLength=t.readInt(2),r=t.readInt(2),this.fileName=t.readData(this.fileNameLength),t.skip(r),-1===this.compressedSize||-1===this.uncompressedSize)throw new Error(\"Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)\");if(null===(e=function(t){for(var e in h)if(h.hasOwnProperty(e)&&h[e].magic===t)return h[e];return null}(this.compressionMethod)))throw new Error(\"Corrupted zip : compression \"+s.pretty(this.compressionMethod)+\" unknown (inner file : \"+s.transformTo(\"string\",this.fileName)+\")\");this.decompressed=new n(this.compressedSize,this.uncompressedSize,this.crc32,e,t.readData(this.compressedSize))},readCentralPart:function(t){this.versionMadeBy=t.readInt(2),t.skip(2),this.bitFlag=t.readInt(2),this.compressionMethod=t.readString(2),this.date=t.readDate(),this.crc32=t.readInt(4),this.compressedSize=t.readInt(4),this.uncompressedSize=t.readInt(4);var e=t.readInt(2);if(this.extraFieldsLength=t.readInt(2),this.fileCommentLength=t.readInt(2),this.diskNumberStart=t.readInt(2),this.internalFileAttributes=t.readInt(2),this.externalFileAttributes=t.readInt(4),this.localHeaderOffset=t.readInt(4),this.isEncrypted())throw new Error(\"Encrypted zip are not supported\");t.skip(e),this.readExtraFields(t),this.parseZIP64ExtraField(t),this.fileComment=t.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var t=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),0==t&&(this.dosPermissions=63&this.externalFileAttributes),3==t&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||\"\/\"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(t){if(this.extraFields[1]){var e=i(this.extraFields[1].value);this.uncompressedSize===s.MAX_VALUE_32BITS&&(this.uncompressedSize=e.readInt(8)),this.compressedSize===s.MAX_VALUE_32BITS&&(this.compressedSize=e.readInt(8)),this.localHeaderOffset===s.MAX_VALUE_32BITS&&(this.localHeaderOffset=e.readInt(8)),this.diskNumberStart===s.MAX_VALUE_32BITS&&(this.diskNumberStart=e.readInt(4))}},readExtraFields:function(t){var e,r,i,n=t.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});t.index+4<n;)e=t.readInt(2),r=t.readInt(2),i=t.readData(r),this.extraFields[e]={id:e,length:r,value:i};t.setIndex(n)},handleUTF8:function(){var t=u.uint8array?\"uint8array\":\"array\";if(this.useUTF8())this.fileNameStr=o.utf8decode(this.fileName),this.fileCommentStr=o.utf8decode(this.fileComment);else{var e=this.findExtraFieldUnicodePath();if(null!==e)this.fileNameStr=e;else{var r=s.transformTo(t,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(r)}var i=this.findExtraFieldUnicodeComment();if(null!==i)this.fileCommentStr=i;else{var n=s.transformTo(t,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(n)}}},findExtraFieldUnicodePath:function(){var t=this.extraFields[28789];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileName)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null},findExtraFieldUnicodeComment:function(){var t=this.extraFields[25461];if(t){var e=i(t.value);return 1!==e.readInt(1)?null:a(this.fileComment)!==e.readInt(4)?null:o.utf8decode(e.readData(t.length-5))}return null}},e.exports=l},{\".\/compressedObject\":2,\".\/compressions\":3,\".\/crc32\":4,\".\/reader\/readerFor\":22,\".\/support\":30,\".\/utf8\":31,\".\/utils\":32}],35:[function(t,e,r){\"use strict\";function i(t,e,r){this.name=t,this.dir=r.dir,this.date=r.date,this.comment=r.comment,this.unixPermissions=r.unixPermissions,this.dosPermissions=r.dosPermissions,this._data=e,this._dataBinary=r.binary,this.options={compression:r.compression,compressionOptions:r.compressionOptions}}var s=t(\".\/stream\/StreamHelper\"),n=t(\".\/stream\/DataWorker\"),a=t(\".\/utf8\"),o=t(\".\/compressedObject\"),h=t(\".\/stream\/GenericWorker\");i.prototype={internalStream:function(t){var e=null,r=\"string\";try{if(!t)throw new Error(\"No output type specified.\");var i=\"string\"===(r=t.toLowerCase())||\"text\"===r;\"binarystring\"!==r&&\"text\"!==r||(r=\"string\"),e=this._decompressWorker();var n=!this._dataBinary;n&&!i&&(e=e.pipe(new a.Utf8EncodeWorker)),!n&&i&&(e=e.pipe(new a.Utf8DecodeWorker))}catch(t){(e=new h(\"error\")).error(t)}return new s(e,r,\"\")},async:function(t,e){return this.internalStream(t).accumulate(e)},nodeStream:function(t,e){return this.internalStream(t||\"nodebuffer\").toNodejsStream(e)},_compressWorker:function(t,e){if(this._data instanceof o&&this._data.compression.magic===t.magic)return this._data.getCompressedWorker();var r=this._decompressWorker();return this._dataBinary||(r=r.pipe(new a.Utf8EncodeWorker)),o.createWorkerFrom(r,t,e)},_decompressWorker:function(){return this._data instanceof o?this._data.getContentWorker():this._data instanceof h?this._data:new n(this._data)}};for(var u=[\"asText\",\"asBinary\",\"asNodeBuffer\",\"asUint8Array\",\"asArrayBuffer\"],l=function(){throw new Error(\"This method has been removed in JSZip 3.0, please check the upgrade guide.\")},f=0;f<u.length;f++)i.prototype[u[f]]=l;e.exports=i},{\".\/compressedObject\":2,\".\/stream\/DataWorker\":27,\".\/stream\/GenericWorker\":28,\".\/stream\/StreamHelper\":29,\".\/utf8\":31}],36:[function(t,l,e){(function(e){\"use strict\";var r,i,t=e.MutationObserver||e.WebKitMutationObserver;if(t){var n=0,s=new t(u),a=e.document.createTextNode(\"\");s.observe(a,{characterData:!0}),r=function(){a.data=n=++n%2}}else if(e.setImmediate||void 0===e.MessageChannel)r=\"document\"in e&&\"onreadystatechange\"in e.document.createElement(\"script\")?function(){var t=e.document.createElement(\"script\");t.onreadystatechange=function(){u(),t.onreadystatechange=null,t.parentNode.removeChild(t),t=null},e.document.documentElement.appendChild(t)}:function(){setTimeout(u,0)};else{var o=new e.MessageChannel;o.port1.onmessage=u,r=function(){o.port2.postMessage(0)}}var h=[];function u(){var t,e;i=!0;for(var r=h.length;r;){for(e=h,h=[],t=-1;++t<r;)e[t]();r=h.length}i=!1}l.exports=function(t){1!==h.push(t)||i||r()}}).call(this,\"undefined\"!=typeof global?global:\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:{})},{}],37:[function(t,e,r){\"use strict\";var n=t(\"immediate\");function u(){}var l={},s=[\"REJECTED\"],a=[\"FULFILLED\"],i=[\"PENDING\"];function o(t){if(\"function\"!=typeof t)throw new TypeError(\"resolver must be a function\");this.state=i,this.queue=[],this.outcome=void 0,t!==u&&c(this,t)}function h(t,e,r){this.promise=t,\"function\"==typeof e&&(this.onFulfilled=e,this.callFulfilled=this.otherCallFulfilled),\"function\"==typeof r&&(this.onRejected=r,this.callRejected=this.otherCallRejected)}function f(e,r,i){n(function(){var t;try{t=r(i)}catch(t){return l.reject(e,t)}t===e?l.reject(e,new TypeError(\"Cannot resolve promise with itself\")):l.resolve(e,t)})}function d(t){var e=t&&t.then;if(t&&(\"object\"==typeof t||\"function\"==typeof t)&&\"function\"==typeof e)return function(){e.apply(t,arguments)}}function c(e,t){var r=!1;function i(t){r||(r=!0,l.reject(e,t))}function n(t){r||(r=!0,l.resolve(e,t))}var s=p(function(){t(n,i)});\"error\"===s.status&&i(s.value)}function p(t,e){var r={};try{r.value=t(e),r.status=\"success\"}catch(t){r.status=\"error\",r.value=t}return r}(e.exports=o).prototype.finally=function(e){if(\"function\"!=typeof e)return this;var r=this.constructor;return this.then(function(t){return r.resolve(e()).then(function(){return t})},function(t){return r.resolve(e()).then(function(){throw t})})},o.prototype.catch=function(t){return this.then(null,t)},o.prototype.then=function(t,e){if(\"function\"!=typeof t&&this.state===a||\"function\"!=typeof e&&this.state===s)return this;var r=new this.constructor(u);this.state!==i?f(r,this.state===a?t:e,this.outcome):this.queue.push(new h(r,t,e));return r},h.prototype.callFulfilled=function(t){l.resolve(this.promise,t)},h.prototype.otherCallFulfilled=function(t){f(this.promise,this.onFulfilled,t)},h.prototype.callRejected=function(t){l.reject(this.promise,t)},h.prototype.otherCallRejected=function(t){f(this.promise,this.onRejected,t)},l.resolve=function(t,e){var r=p(d,e);if(\"error\"===r.status)return l.reject(t,r.value);var i=r.value;if(i)c(t,i);else{t.state=a,t.outcome=e;for(var n=-1,s=t.queue.length;++n<s;)t.queue[n].callFulfilled(e)}return t},l.reject=function(t,e){t.state=s,t.outcome=e;for(var r=-1,i=t.queue.length;++r<i;)t.queue[r].callRejected(e);return t},o.resolve=function(t){if(t instanceof this)return t;return l.resolve(new this(u),t)},o.reject=function(t){var e=new this(u);return l.reject(e,t)},o.all=function(t){var r=this;if(\"[object Array]\"!==Object.prototype.toString.call(t))return this.reject(new TypeError(\"must be an array\"));var i=t.length,n=!1;if(!i)return this.resolve([]);var s=new Array(i),a=0,e=-1,o=new this(u);for(;++e<i;)h(t[e],e);return o;function h(t,e){r.resolve(t).then(function(t){s[e]=t,++a!==i||n||(n=!0,l.resolve(o,s))},function(t){n||(n=!0,l.reject(o,t))})}},o.race=function(t){var e=this;if(\"[object Array]\"!==Object.prototype.toString.call(t))return this.reject(new TypeError(\"must be an array\"));var r=t.length,i=!1;if(!r)return this.resolve([]);var n=-1,s=new this(u);for(;++n<r;)a=t[n],e.resolve(a).then(function(t){i||(i=!0,l.resolve(s,t))},function(t){i||(i=!0,l.reject(s,t))});var a;return s}},{immediate:36}],38:[function(t,e,r){\"use strict\";var i={};(0,t(\".\/lib\/utils\/common\").assign)(i,t(\".\/lib\/deflate\"),t(\".\/lib\/inflate\"),t(\".\/lib\/zlib\/constants\")),e.exports=i},{\".\/lib\/deflate\":39,\".\/lib\/inflate\":40,\".\/lib\/utils\/common\":41,\".\/lib\/zlib\/constants\":44}],39:[function(t,e,r){\"use strict\";var a=t(\".\/zlib\/deflate\"),o=t(\".\/utils\/common\"),h=t(\".\/utils\/strings\"),n=t(\".\/zlib\/messages\"),s=t(\".\/zlib\/zstream\"),u=Object.prototype.toString,l=0,f=-1,d=0,c=8;function p(t){if(!(this instanceof p))return new p(t);this.options=o.assign({level:f,method:c,chunkSize:16384,windowBits:15,memLevel:8,strategy:d,to:\"\"},t||{});var e=this.options;e.raw&&0<e.windowBits?e.windowBits=-e.windowBits:e.gzip&&0<e.windowBits&&e.windowBits<16&&(e.windowBits+=16),this.err=0,this.msg=\"\",this.ended=!1,this.chunks=[],this.strm=new s,this.strm.avail_out=0;var r=a.deflateInit2(this.strm,e.level,e.method,e.windowBits,e.memLevel,e.strategy);if(r!==l)throw new Error(n[r]);if(e.header&&a.deflateSetHeader(this.strm,e.header),e.dictionary){var i;if(i=\"string\"==typeof e.dictionary?h.string2buf(e.dictionary):\"[object ArrayBuffer]\"===u.call(e.dictionary)?new Uint8Array(e.dictionary):e.dictionary,(r=a.deflateSetDictionary(this.strm,i))!==l)throw new Error(n[r]);this._dict_set=!0}}function i(t,e){var r=new p(e);if(r.push(t,!0),r.err)throw r.msg||n[r.err];return r.result}p.prototype.push=function(t,e){var r,i,n=this.strm,s=this.options.chunkSize;if(this.ended)return!1;i=e===~~e?e:!0===e?4:0,\"string\"==typeof t?n.input=h.string2buf(t):\"[object ArrayBuffer]\"===u.call(t)?n.input=new Uint8Array(t):n.input=t,n.next_in=0,n.avail_in=n.input.length;do{if(0===n.avail_out&&(n.output=new o.Buf8(s),n.next_out=0,n.avail_out=s),1!==(r=a.deflate(n,i))&&r!==l)return this.onEnd(r),!(this.ended=!0);0!==n.avail_out&&(0!==n.avail_in||4!==i&&2!==i)||(\"string\"===this.options.to?this.onData(h.buf2binstring(o.shrinkBuf(n.output,n.next_out))):this.onData(o.shrinkBuf(n.output,n.next_out)))}while((0<n.avail_in||0===n.avail_out)&&1!==r);return 4===i?(r=a.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===l):2!==i||(this.onEnd(l),!(n.avail_out=0))},p.prototype.onData=function(t){this.chunks.push(t)},p.prototype.onEnd=function(t){t===l&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=o.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Deflate=p,r.deflate=i,r.deflateRaw=function(t,e){return(e=e||{}).raw=!0,i(t,e)},r.gzip=function(t,e){return(e=e||{}).gzip=!0,i(t,e)}},{\".\/utils\/common\":41,\".\/utils\/strings\":42,\".\/zlib\/deflate\":46,\".\/zlib\/messages\":51,\".\/zlib\/zstream\":53}],40:[function(t,e,r){\"use strict\";var d=t(\".\/zlib\/inflate\"),c=t(\".\/utils\/common\"),p=t(\".\/utils\/strings\"),m=t(\".\/zlib\/constants\"),i=t(\".\/zlib\/messages\"),n=t(\".\/zlib\/zstream\"),s=t(\".\/zlib\/gzheader\"),_=Object.prototype.toString;function a(t){if(!(this instanceof a))return new a(t);this.options=c.assign({chunkSize:16384,windowBits:0,to:\"\"},t||{});var e=this.options;e.raw&&0<=e.windowBits&&e.windowBits<16&&(e.windowBits=-e.windowBits,0===e.windowBits&&(e.windowBits=-15)),!(0<=e.windowBits&&e.windowBits<16)||t&&t.windowBits||(e.windowBits+=32),15<e.windowBits&&e.windowBits<48&&0==(15&e.windowBits)&&(e.windowBits|=15),this.err=0,this.msg=\"\",this.ended=!1,this.chunks=[],this.strm=new n,this.strm.avail_out=0;var r=d.inflateInit2(this.strm,e.windowBits);if(r!==m.Z_OK)throw new Error(i[r]);this.header=new s,d.inflateGetHeader(this.strm,this.header)}function o(t,e){var r=new a(e);if(r.push(t,!0),r.err)throw r.msg||i[r.err];return r.result}a.prototype.push=function(t,e){var r,i,n,s,a,o,h=this.strm,u=this.options.chunkSize,l=this.options.dictionary,f=!1;if(this.ended)return!1;i=e===~~e?e:!0===e?m.Z_FINISH:m.Z_NO_FLUSH,\"string\"==typeof t?h.input=p.binstring2buf(t):\"[object ArrayBuffer]\"===_.call(t)?h.input=new Uint8Array(t):h.input=t,h.next_in=0,h.avail_in=h.input.length;do{if(0===h.avail_out&&(h.output=new c.Buf8(u),h.next_out=0,h.avail_out=u),(r=d.inflate(h,m.Z_NO_FLUSH))===m.Z_NEED_DICT&&l&&(o=\"string\"==typeof l?p.string2buf(l):\"[object ArrayBuffer]\"===_.call(l)?new Uint8Array(l):l,r=d.inflateSetDictionary(this.strm,o)),r===m.Z_BUF_ERROR&&!0===f&&(r=m.Z_OK,f=!1),r!==m.Z_STREAM_END&&r!==m.Z_OK)return this.onEnd(r),!(this.ended=!0);h.next_out&&(0!==h.avail_out&&r!==m.Z_STREAM_END&&(0!==h.avail_in||i!==m.Z_FINISH&&i!==m.Z_SYNC_FLUSH)||(\"string\"===this.options.to?(n=p.utf8border(h.output,h.next_out),s=h.next_out-n,a=p.buf2string(h.output,n),h.next_out=s,h.avail_out=u-s,s&&c.arraySet(h.output,h.output,n,s,0),this.onData(a)):this.onData(c.shrinkBuf(h.output,h.next_out)))),0===h.avail_in&&0===h.avail_out&&(f=!0)}while((0<h.avail_in||0===h.avail_out)&&r!==m.Z_STREAM_END);return r===m.Z_STREAM_END&&(i=m.Z_FINISH),i===m.Z_FINISH?(r=d.inflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===m.Z_OK):i!==m.Z_SYNC_FLUSH||(this.onEnd(m.Z_OK),!(h.avail_out=0))},a.prototype.onData=function(t){this.chunks.push(t)},a.prototype.onEnd=function(t){t===m.Z_OK&&(\"string\"===this.options.to?this.result=this.chunks.join(\"\"):this.result=c.flattenChunks(this.chunks)),this.chunks=[],this.err=t,this.msg=this.strm.msg},r.Inflate=a,r.inflate=o,r.inflateRaw=function(t,e){return(e=e||{}).raw=!0,o(t,e)},r.ungzip=o},{\".\/utils\/common\":41,\".\/utils\/strings\":42,\".\/zlib\/constants\":44,\".\/zlib\/gzheader\":47,\".\/zlib\/inflate\":49,\".\/zlib\/messages\":51,\".\/zlib\/zstream\":53}],41:[function(t,e,r){\"use strict\";var i=\"undefined\"!=typeof Uint8Array&&\"undefined\"!=typeof Uint16Array&&\"undefined\"!=typeof Int32Array;r.assign=function(t){for(var e=Array.prototype.slice.call(arguments,1);e.length;){var r=e.shift();if(r){if(\"object\"!=typeof r)throw new TypeError(r+\"must be non-object\");for(var i in r)r.hasOwnProperty(i)&&(t[i]=r[i])}}return t},r.shrinkBuf=function(t,e){return t.length===e?t:t.subarray?t.subarray(0,e):(t.length=e,t)};var n={arraySet:function(t,e,r,i,n){if(e.subarray&&t.subarray)t.set(e.subarray(r,r+i),n);else for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){var e,r,i,n,s,a;for(e=i=0,r=t.length;e<r;e++)i+=t[e].length;for(a=new Uint8Array(i),e=n=0,r=t.length;e<r;e++)s=t[e],a.set(s,n),n+=s.length;return a}},s={arraySet:function(t,e,r,i,n){for(var s=0;s<i;s++)t[n+s]=e[r+s]},flattenChunks:function(t){return[].concat.apply([],t)}};r.setTyped=function(t){t?(r.Buf8=Uint8Array,r.Buf16=Uint16Array,r.Buf32=Int32Array,r.assign(r,n)):(r.Buf8=Array,r.Buf16=Array,r.Buf32=Array,r.assign(r,s))},r.setTyped(i)},{}],42:[function(t,e,r){\"use strict\";var h=t(\".\/common\"),n=!0,s=!0;try{String.fromCharCode.apply(null,[0])}catch(t){n=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(t){s=!1}for(var u=new h.Buf8(256),i=0;i<256;i++)u[i]=252<=i?6:248<=i?5:240<=i?4:224<=i?3:192<=i?2:1;function l(t,e){if(e<65537&&(t.subarray&&s||!t.subarray&&n))return String.fromCharCode.apply(null,h.shrinkBuf(t,e));for(var r=\"\",i=0;i<e;i++)r+=String.fromCharCode(t[i]);return r}u[254]=u[254]=1,r.string2buf=function(t){var e,r,i,n,s,a=t.length,o=0;for(n=0;n<a;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),o+=r<128?1:r<2048?2:r<65536?3:4;for(e=new h.Buf8(o),n=s=0;s<o;n++)55296==(64512&(r=t.charCodeAt(n)))&&n+1<a&&56320==(64512&(i=t.charCodeAt(n+1)))&&(r=65536+(r-55296<<10)+(i-56320),n++),r<128?e[s++]=r:(r<2048?e[s++]=192|r>>>6:(r<65536?e[s++]=224|r>>>12:(e[s++]=240|r>>>18,e[s++]=128|r>>>12&63),e[s++]=128|r>>>6&63),e[s++]=128|63&r);return e},r.buf2binstring=function(t){return l(t,t.length)},r.binstring2buf=function(t){for(var e=new h.Buf8(t.length),r=0,i=e.length;r<i;r++)e[r]=t.charCodeAt(r);return e},r.buf2string=function(t,e){var r,i,n,s,a=e||t.length,o=new Array(2*a);for(r=i=0;r<a;)if((n=t[r++])<128)o[i++]=n;else if(4<(s=u[n]))o[i++]=65533,r+=s-1;else{for(n&=2===s?31:3===s?15:7;1<s&&r<a;)n=n<<6|63&t[r++],s--;1<s?o[i++]=65533:n<65536?o[i++]=n:(n-=65536,o[i++]=55296|n>>10&1023,o[i++]=56320|1023&n)}return l(o,i)},r.utf8border=function(t,e){var r;for((e=e||t.length)>t.length&&(e=t.length),r=e-1;0<=r&&128==(192&t[r]);)r--;return r<0?e:0===r?e:r+u[t[r]]>e?r:e}},{\".\/common\":41}],43:[function(t,e,r){\"use strict\";e.exports=function(t,e,r,i){for(var n=65535&t|0,s=t>>>16&65535|0,a=0;0!==r;){for(r-=a=2e3<r?2e3:r;s=s+(n=n+e[i++]|0)|0,--a;);n%=65521,s%=65521}return n|s<<16|0}},{}],44:[function(t,e,r){\"use strict\";e.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],45:[function(t,e,r){\"use strict\";var o=function(){for(var t,e=[],r=0;r<256;r++){t=r;for(var i=0;i<8;i++)t=1&t?3988292384^t>>>1:t>>>1;e[r]=t}return e}();e.exports=function(t,e,r,i){var n=o,s=i+r;t^=-1;for(var a=i;a<s;a++)t=t>>>8^n[255&(t^e[a])];return-1^t}},{}],46:[function(t,e,r){\"use strict\";var h,d=t(\"..\/utils\/common\"),u=t(\".\/trees\"),c=t(\".\/adler32\"),p=t(\".\/crc32\"),i=t(\".\/messages\"),l=0,f=4,m=0,_=-2,g=-1,b=4,n=2,v=8,y=9,s=286,a=30,o=19,w=2*s+1,k=15,x=3,S=258,z=S+x+1,C=42,E=113,A=1,I=2,O=3,B=4;function R(t,e){return t.msg=i[e],e}function T(t){return(t<<1)-(4<t?9:0)}function D(t){for(var e=t.length;0<=--e;)t[e]=0}function F(t){var e=t.state,r=e.pending;r>t.avail_out&&(r=t.avail_out),0!==r&&(d.arraySet(t.output,e.pending_buf,e.pending_out,r,t.next_out),t.next_out+=r,e.pending_out+=r,t.total_out+=r,t.avail_out-=r,e.pending-=r,0===e.pending&&(e.pending_out=0))}function N(t,e){u._tr_flush_block(t,0<=t.block_start?t.block_start:-1,t.strstart-t.block_start,e),t.block_start=t.strstart,F(t.strm)}function U(t,e){t.pending_buf[t.pending++]=e}function P(t,e){t.pending_buf[t.pending++]=e>>>8&255,t.pending_buf[t.pending++]=255&e}function L(t,e){var r,i,n=t.max_chain_length,s=t.strstart,a=t.prev_length,o=t.nice_match,h=t.strstart>t.w_size-z?t.strstart-(t.w_size-z):0,u=t.window,l=t.w_mask,f=t.prev,d=t.strstart+S,c=u[s+a-1],p=u[s+a];t.prev_length>=t.good_match&&(n>>=2),o>t.lookahead&&(o=t.lookahead);do{if(u[(r=e)+a]===p&&u[r+a-1]===c&&u[r]===u[s]&&u[++r]===u[s+1]){s+=2,r++;do{}while(u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&u[++s]===u[++r]&&s<d);if(i=S-(d-s),s=d-S,a<i){if(t.match_start=e,o<=(a=i))break;c=u[s+a-1],p=u[s+a]}}}while((e=f[e&l])>h&&0!=--n);return a<=t.lookahead?a:t.lookahead}function j(t){var e,r,i,n,s,a,o,h,u,l,f=t.w_size;do{if(n=t.window_size-t.lookahead-t.strstart,t.strstart>=f+(f-z)){for(d.arraySet(t.window,t.window,f,f,0),t.match_start-=f,t.strstart-=f,t.block_start-=f,e=r=t.hash_size;i=t.head[--e],t.head[e]=f<=i?i-f:0,--r;);for(e=r=f;i=t.prev[--e],t.prev[e]=f<=i?i-f:0,--r;);n+=f}if(0===t.strm.avail_in)break;if(a=t.strm,o=t.window,h=t.strstart+t.lookahead,u=n,l=void 0,l=a.avail_in,u<l&&(l=u),r=0===l?0:(a.avail_in-=l,d.arraySet(o,a.input,a.next_in,l,h),1===a.state.wrap?a.adler=c(a.adler,o,l,h):2===a.state.wrap&&(a.adler=p(a.adler,o,l,h)),a.next_in+=l,a.total_in+=l,l),t.lookahead+=r,t.lookahead+t.insert>=x)for(s=t.strstart-t.insert,t.ins_h=t.window[s],t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+1])&t.hash_mask;t.insert&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[s+x-1])&t.hash_mask,t.prev[s&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=s,s++,t.insert--,!(t.lookahead+t.insert<x)););}while(t.lookahead<z&&0!==t.strm.avail_in)}function Z(t,e){for(var r,i;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!==r&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r)),t.match_length>=x)if(i=u._tr_tally(t,t.strstart-t.match_start,t.match_length-x),t.lookahead-=t.match_length,t.match_length<=t.max_lazy_match&&t.lookahead>=x){for(t.match_length--;t.strstart++,t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart,0!=--t.match_length;);t.strstart++}else t.strstart+=t.match_length,t.match_length=0,t.ins_h=t.window[t.strstart],t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+1])&t.hash_mask;else i=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++;if(i&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function W(t,e){for(var r,i,n;;){if(t.lookahead<z){if(j(t),t.lookahead<z&&e===l)return A;if(0===t.lookahead)break}if(r=0,t.lookahead>=x&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),t.prev_length=t.match_length,t.prev_match=t.match_start,t.match_length=x-1,0!==r&&t.prev_length<t.max_lazy_match&&t.strstart-r<=t.w_size-z&&(t.match_length=L(t,r),t.match_length<=5&&(1===t.strategy||t.match_length===x&&4096<t.strstart-t.match_start)&&(t.match_length=x-1)),t.prev_length>=x&&t.match_length<=t.prev_length){for(n=t.strstart+t.lookahead-x,i=u._tr_tally(t,t.strstart-1-t.prev_match,t.prev_length-x),t.lookahead-=t.prev_length-1,t.prev_length-=2;++t.strstart<=n&&(t.ins_h=(t.ins_h<<t.hash_shift^t.window[t.strstart+x-1])&t.hash_mask,r=t.prev[t.strstart&t.w_mask]=t.head[t.ins_h],t.head[t.ins_h]=t.strstart),0!=--t.prev_length;);if(t.match_available=0,t.match_length=x-1,t.strstart++,i&&(N(t,!1),0===t.strm.avail_out))return A}else if(t.match_available){if((i=u._tr_tally(t,0,t.window[t.strstart-1]))&&N(t,!1),t.strstart++,t.lookahead--,0===t.strm.avail_out)return A}else t.match_available=1,t.strstart++,t.lookahead--}return t.match_available&&(i=u._tr_tally(t,0,t.window[t.strstart-1]),t.match_available=0),t.insert=t.strstart<x-1?t.strstart:x-1,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}function M(t,e,r,i,n){this.good_length=t,this.max_lazy=e,this.nice_length=r,this.max_chain=i,this.func=n}function H(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=v,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new d.Buf16(2*w),this.dyn_dtree=new d.Buf16(2*(2*a+1)),this.bl_tree=new d.Buf16(2*(2*o+1)),D(this.dyn_ltree),D(this.dyn_dtree),D(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new d.Buf16(k+1),this.heap=new d.Buf16(2*s+1),D(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new d.Buf16(2*s+1),D(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function G(t){var e;return t&&t.state?(t.total_in=t.total_out=0,t.data_type=n,(e=t.state).pending=0,e.pending_out=0,e.wrap<0&&(e.wrap=-e.wrap),e.status=e.wrap?C:E,t.adler=2===e.wrap?0:1,e.last_flush=l,u._tr_init(e),m):R(t,_)}function K(t){var e=G(t);return e===m&&function(t){t.window_size=2*t.w_size,D(t.head),t.max_lazy_match=h[t.level].max_lazy,t.good_match=h[t.level].good_length,t.nice_match=h[t.level].nice_length,t.max_chain_length=h[t.level].max_chain,t.strstart=0,t.block_start=0,t.lookahead=0,t.insert=0,t.match_length=t.prev_length=x-1,t.match_available=0,t.ins_h=0}(t.state),e}function Y(t,e,r,i,n,s){if(!t)return _;var a=1;if(e===g&&(e=6),i<0?(a=0,i=-i):15<i&&(a=2,i-=16),n<1||y<n||r!==v||i<8||15<i||e<0||9<e||s<0||b<s)return R(t,_);8===i&&(i=9);var o=new H;return(t.state=o).strm=t,o.wrap=a,o.gzhead=null,o.w_bits=i,o.w_size=1<<o.w_bits,o.w_mask=o.w_size-1,o.hash_bits=n+7,o.hash_size=1<<o.hash_bits,o.hash_mask=o.hash_size-1,o.hash_shift=~~((o.hash_bits+x-1)\/x),o.window=new d.Buf8(2*o.w_size),o.head=new d.Buf16(o.hash_size),o.prev=new d.Buf16(o.w_size),o.lit_bufsize=1<<n+6,o.pending_buf_size=4*o.lit_bufsize,o.pending_buf=new d.Buf8(o.pending_buf_size),o.d_buf=1*o.lit_bufsize,o.l_buf=3*o.lit_bufsize,o.level=e,o.strategy=s,o.method=r,K(t)}h=[new M(0,0,0,0,function(t,e){var r=65535;for(r>t.pending_buf_size-5&&(r=t.pending_buf_size-5);;){if(t.lookahead<=1){if(j(t),0===t.lookahead&&e===l)return A;if(0===t.lookahead)break}t.strstart+=t.lookahead,t.lookahead=0;var i=t.block_start+r;if((0===t.strstart||t.strstart>=i)&&(t.lookahead=t.strstart-i,t.strstart=i,N(t,!1),0===t.strm.avail_out))return A;if(t.strstart-t.block_start>=t.w_size-z&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):(t.strstart>t.block_start&&(N(t,!1),t.strm.avail_out),A)}),new M(4,4,8,4,Z),new M(4,5,16,8,Z),new M(4,6,32,32,Z),new M(4,4,16,16,W),new M(8,16,32,32,W),new M(8,16,128,128,W),new M(8,32,128,256,W),new M(32,128,258,1024,W),new M(32,258,258,4096,W)],r.deflateInit=function(t,e){return Y(t,e,v,15,8,0)},r.deflateInit2=Y,r.deflateReset=K,r.deflateResetKeep=G,r.deflateSetHeader=function(t,e){return t&&t.state?2!==t.state.wrap?_:(t.state.gzhead=e,m):_},r.deflate=function(t,e){var r,i,n,s;if(!t||!t.state||5<e||e<0)return t?R(t,_):_;if(i=t.state,!t.output||!t.input&&0!==t.avail_in||666===i.status&&e!==f)return R(t,0===t.avail_out?-5:_);if(i.strm=t,r=i.last_flush,i.last_flush=e,i.status===C)if(2===i.wrap)t.adler=0,U(i,31),U(i,139),U(i,8),i.gzhead?(U(i,(i.gzhead.text?1:0)+(i.gzhead.hcrc?2:0)+(i.gzhead.extra?4:0)+(i.gzhead.name?8:0)+(i.gzhead.comment?16:0)),U(i,255&i.gzhead.time),U(i,i.gzhead.time>>8&255),U(i,i.gzhead.time>>16&255),U(i,i.gzhead.time>>24&255),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,255&i.gzhead.os),i.gzhead.extra&&i.gzhead.extra.length&&(U(i,255&i.gzhead.extra.length),U(i,i.gzhead.extra.length>>8&255)),i.gzhead.hcrc&&(t.adler=p(t.adler,i.pending_buf,i.pending,0)),i.gzindex=0,i.status=69):(U(i,0),U(i,0),U(i,0),U(i,0),U(i,0),U(i,9===i.level?2:2<=i.strategy||i.level<2?4:0),U(i,3),i.status=E);else{var a=v+(i.w_bits-8<<4)<<8;a|=(2<=i.strategy||i.level<2?0:i.level<6?1:6===i.level?2:3)<<6,0!==i.strstart&&(a|=32),a+=31-a%31,i.status=E,P(i,a),0!==i.strstart&&(P(i,t.adler>>>16),P(i,65535&t.adler)),t.adler=1}if(69===i.status)if(i.gzhead.extra){for(n=i.pending;i.gzindex<(65535&i.gzhead.extra.length)&&(i.pending!==i.pending_buf_size||(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending!==i.pending_buf_size));)U(i,255&i.gzhead.extra[i.gzindex]),i.gzindex++;i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),i.gzindex===i.gzhead.extra.length&&(i.gzindex=0,i.status=73)}else i.status=73;if(73===i.status)if(i.gzhead.name){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.name.length?255&i.gzhead.name.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.gzindex=0,i.status=91)}else i.status=91;if(91===i.status)if(i.gzhead.comment){n=i.pending;do{if(i.pending===i.pending_buf_size&&(i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),F(t),n=i.pending,i.pending===i.pending_buf_size)){s=1;break}s=i.gzindex<i.gzhead.comment.length?255&i.gzhead.comment.charCodeAt(i.gzindex++):0,U(i,s)}while(0!==s);i.gzhead.hcrc&&i.pending>n&&(t.adler=p(t.adler,i.pending_buf,i.pending-n,n)),0===s&&(i.status=103)}else i.status=103;if(103===i.status&&(i.gzhead.hcrc?(i.pending+2>i.pending_buf_size&&F(t),i.pending+2<=i.pending_buf_size&&(U(i,255&t.adler),U(i,t.adler>>8&255),t.adler=0,i.status=E)):i.status=E),0!==i.pending){if(F(t),0===t.avail_out)return i.last_flush=-1,m}else if(0===t.avail_in&&T(e)<=T(r)&&e!==f)return R(t,-5);if(666===i.status&&0!==t.avail_in)return R(t,-5);if(0!==t.avail_in||0!==i.lookahead||e!==l&&666!==i.status){var o=2===i.strategy?function(t,e){for(var r;;){if(0===t.lookahead&&(j(t),0===t.lookahead)){if(e===l)return A;break}if(t.match_length=0,r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++,r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):3===i.strategy?function(t,e){for(var r,i,n,s,a=t.window;;){if(t.lookahead<=S){if(j(t),t.lookahead<=S&&e===l)return A;if(0===t.lookahead)break}if(t.match_length=0,t.lookahead>=x&&0<t.strstart&&(i=a[n=t.strstart-1])===a[++n]&&i===a[++n]&&i===a[++n]){s=t.strstart+S;do{}while(i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&i===a[++n]&&n<s);t.match_length=S-(s-n),t.match_length>t.lookahead&&(t.match_length=t.lookahead)}if(t.match_length>=x?(r=u._tr_tally(t,1,t.match_length-x),t.lookahead-=t.match_length,t.strstart+=t.match_length,t.match_length=0):(r=u._tr_tally(t,0,t.window[t.strstart]),t.lookahead--,t.strstart++),r&&(N(t,!1),0===t.strm.avail_out))return A}return t.insert=0,e===f?(N(t,!0),0===t.strm.avail_out?O:B):t.last_lit&&(N(t,!1),0===t.strm.avail_out)?A:I}(i,e):h[i.level].func(i,e);if(o!==O&&o!==B||(i.status=666),o===A||o===O)return 0===t.avail_out&&(i.last_flush=-1),m;if(o===I&&(1===e?u._tr_align(i):5!==e&&(u._tr_stored_block(i,0,0,!1),3===e&&(D(i.head),0===i.lookahead&&(i.strstart=0,i.block_start=0,i.insert=0))),F(t),0===t.avail_out))return i.last_flush=-1,m}return e!==f?m:i.wrap<=0?1:(2===i.wrap?(U(i,255&t.adler),U(i,t.adler>>8&255),U(i,t.adler>>16&255),U(i,t.adler>>24&255),U(i,255&t.total_in),U(i,t.total_in>>8&255),U(i,t.total_in>>16&255),U(i,t.total_in>>24&255)):(P(i,t.adler>>>16),P(i,65535&t.adler)),F(t),0<i.wrap&&(i.wrap=-i.wrap),0!==i.pending?m:1)},r.deflateEnd=function(t){var e;return t&&t.state?(e=t.state.status)!==C&&69!==e&&73!==e&&91!==e&&103!==e&&e!==E&&666!==e?R(t,_):(t.state=null,e===E?R(t,-3):m):_},r.deflateSetDictionary=function(t,e){var r,i,n,s,a,o,h,u,l=e.length;if(!t||!t.state)return _;if(2===(s=(r=t.state).wrap)||1===s&&r.status!==C||r.lookahead)return _;for(1===s&&(t.adler=c(t.adler,e,l,0)),r.wrap=0,l>=r.w_size&&(0===s&&(D(r.head),r.strstart=0,r.block_start=0,r.insert=0),u=new d.Buf8(r.w_size),d.arraySet(u,e,l-r.w_size,r.w_size,0),e=u,l=r.w_size),a=t.avail_in,o=t.next_in,h=t.input,t.avail_in=l,t.next_in=0,t.input=e,j(r);r.lookahead>=x;){for(i=r.strstart,n=r.lookahead-(x-1);r.ins_h=(r.ins_h<<r.hash_shift^r.window[i+x-1])&r.hash_mask,r.prev[i&r.w_mask]=r.head[r.ins_h],r.head[r.ins_h]=i,i++,--n;);r.strstart=i,r.lookahead=x-1,j(r)}return r.strstart+=r.lookahead,r.block_start=r.strstart,r.insert=r.lookahead,r.lookahead=0,r.match_length=r.prev_length=x-1,r.match_available=0,t.next_in=o,t.input=h,t.avail_in=a,r.wrap=s,m},r.deflateInfo=\"pako deflate (from Nodeca project)\"},{\"..\/utils\/common\":41,\".\/adler32\":43,\".\/crc32\":45,\".\/messages\":51,\".\/trees\":52}],47:[function(t,e,r){\"use strict\";e.exports=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name=\"\",this.comment=\"\",this.hcrc=0,this.done=!1}},{}],48:[function(t,e,r){\"use strict\";e.exports=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C;r=t.state,i=t.next_in,z=t.input,n=i+(t.avail_in-5),s=t.next_out,C=t.output,a=s-(e-t.avail_out),o=s+(t.avail_out-257),h=r.dmax,u=r.wsize,l=r.whave,f=r.wnext,d=r.window,c=r.hold,p=r.bits,m=r.lencode,_=r.distcode,g=(1<<r.lenbits)-1,b=(1<<r.distbits)-1;t:do{p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=m[c&g];e:for(;;){if(c>>>=y=v>>>24,p-=y,0===(y=v>>>16&255))C[s++]=65535&v;else{if(!(16&y)){if(0==(64&y)){v=m[(65535&v)+(c&(1<<y)-1)];continue e}if(32&y){r.mode=12;break t}t.msg=\"invalid literal\/length code\",r.mode=30;break t}w=65535&v,(y&=15)&&(p<y&&(c+=z[i++]<<p,p+=8),w+=c&(1<<y)-1,c>>>=y,p-=y),p<15&&(c+=z[i++]<<p,p+=8,c+=z[i++]<<p,p+=8),v=_[c&b];r:for(;;){if(c>>>=y=v>>>24,p-=y,!(16&(y=v>>>16&255))){if(0==(64&y)){v=_[(65535&v)+(c&(1<<y)-1)];continue r}t.msg=\"invalid distance code\",r.mode=30;break t}if(k=65535&v,p<(y&=15)&&(c+=z[i++]<<p,(p+=8)<y&&(c+=z[i++]<<p,p+=8)),h<(k+=c&(1<<y)-1)){t.msg=\"invalid distance too far back\",r.mode=30;break t}if(c>>>=y,p-=y,(y=s-a)<k){if(l<(y=k-y)&&r.sane){t.msg=\"invalid distance too far back\",r.mode=30;break t}if(S=d,(x=0)===f){if(x+=u-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}}else if(f<y){if(x+=u+f-y,(y-=f)<w){for(w-=y;C[s++]=d[x++],--y;);if(x=0,f<w){for(w-=y=f;C[s++]=d[x++],--y;);x=s-k,S=C}}}else if(x+=f-y,y<w){for(w-=y;C[s++]=d[x++],--y;);x=s-k,S=C}for(;2<w;)C[s++]=S[x++],C[s++]=S[x++],C[s++]=S[x++],w-=3;w&&(C[s++]=S[x++],1<w&&(C[s++]=S[x++]))}else{for(x=s-k;C[s++]=C[x++],C[s++]=C[x++],C[s++]=C[x++],2<(w-=3););w&&(C[s++]=C[x++],1<w&&(C[s++]=C[x++]))}break}}break}}while(i<n&&s<o);i-=w=p>>3,c&=(1<<(p-=w<<3))-1,t.next_in=i,t.next_out=s,t.avail_in=i<n?n-i+5:5-(i-n),t.avail_out=s<o?o-s+257:257-(s-o),r.hold=c,r.bits=p}},{}],49:[function(t,e,r){\"use strict\";var I=t(\"..\/utils\/common\"),O=t(\".\/adler32\"),B=t(\".\/crc32\"),R=t(\".\/inffast\"),T=t(\".\/inftrees\"),D=1,F=2,N=0,U=-2,P=1,i=852,n=592;function L(t){return(t>>>24&255)+(t>>>8&65280)+((65280&t)<<8)+((255&t)<<24)}function s(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new I.Buf16(320),this.work=new I.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function a(t){var e;return t&&t.state?(e=t.state,t.total_in=t.total_out=e.total=0,t.msg=\"\",e.wrap&&(t.adler=1&e.wrap),e.mode=P,e.last=0,e.havedict=0,e.dmax=32768,e.head=null,e.hold=0,e.bits=0,e.lencode=e.lendyn=new I.Buf32(i),e.distcode=e.distdyn=new I.Buf32(n),e.sane=1,e.back=-1,N):U}function o(t){var e;return t&&t.state?((e=t.state).wsize=0,e.whave=0,e.wnext=0,a(t)):U}function h(t,e){var r,i;return t&&t.state?(i=t.state,e<0?(r=0,e=-e):(r=1+(e>>4),e<48&&(e&=15)),e&&(e<8||15<e)?U:(null!==i.window&&i.wbits!==e&&(i.window=null),i.wrap=r,i.wbits=e,o(t))):U}function u(t,e){var r,i;return t?(i=new s,(t.state=i).window=null,(r=h(t,e))!==N&&(t.state=null),r):U}var l,f,d=!0;function j(t){if(d){var e;for(l=new I.Buf32(512),f=new I.Buf32(32),e=0;e<144;)t.lens[e++]=8;for(;e<256;)t.lens[e++]=9;for(;e<280;)t.lens[e++]=7;for(;e<288;)t.lens[e++]=8;for(T(D,t.lens,0,288,l,0,t.work,{bits:9}),e=0;e<32;)t.lens[e++]=5;T(F,t.lens,0,32,f,0,t.work,{bits:5}),d=!1}t.lencode=l,t.lenbits=9,t.distcode=f,t.distbits=5}function Z(t,e,r,i){var n,s=t.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new I.Buf8(s.wsize)),i>=s.wsize?(I.arraySet(s.window,e,r-s.wsize,s.wsize,0),s.wnext=0,s.whave=s.wsize):(i<(n=s.wsize-s.wnext)&&(n=i),I.arraySet(s.window,e,r-i,n,s.wnext),(i-=n)?(I.arraySet(s.window,e,r-i,i,0),s.wnext=i,s.whave=s.wsize):(s.wnext+=n,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=n))),0}r.inflateReset=o,r.inflateReset2=h,r.inflateResetKeep=a,r.inflateInit=function(t){return u(t,15)},r.inflateInit2=u,r.inflate=function(t,e){var r,i,n,s,a,o,h,u,l,f,d,c,p,m,_,g,b,v,y,w,k,x,S,z,C=0,E=new I.Buf8(4),A=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!t||!t.state||!t.output||!t.input&&0!==t.avail_in)return U;12===(r=t.state).mode&&(r.mode=13),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,f=o,d=h,x=N;t:for(;;)switch(r.mode){case P:if(0===r.wrap){r.mode=13;break}for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(2&r.wrap&&35615===u){E[r.check=0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0),l=u=0,r.mode=2;break}if(r.flags=0,r.head&&(r.head.done=!1),!(1&r.wrap)||(((255&u)<<8)+(u>>8))%31){t.msg=\"incorrect header check\",r.mode=30;break}if(8!=(15&u)){t.msg=\"unknown compression method\",r.mode=30;break}if(l-=4,k=8+(15&(u>>>=4)),0===r.wbits)r.wbits=k;else if(k>r.wbits){t.msg=\"invalid window size\",r.mode=30;break}r.dmax=1<<k,t.adler=r.check=1,r.mode=512&u?10:12,l=u=0;break;case 2:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.flags=u,8!=(255&r.flags)){t.msg=\"unknown compression method\",r.mode=30;break}if(57344&r.flags){t.msg=\"unknown header flags set\",r.mode=30;break}r.head&&(r.head.text=u>>8&1),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=3;case 3:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.time=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,E[2]=u>>>16&255,E[3]=u>>>24&255,r.check=B(r.check,E,4,0)),l=u=0,r.mode=4;case 4:for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.head&&(r.head.xflags=255&u,r.head.os=u>>8),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0,r.mode=5;case 5:if(1024&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length=u,r.head&&(r.head.extra_len=u),512&r.flags&&(E[0]=255&u,E[1]=u>>>8&255,r.check=B(r.check,E,2,0)),l=u=0}else r.head&&(r.head.extra=null);r.mode=6;case 6:if(1024&r.flags&&(o<(c=r.length)&&(c=o),c&&(r.head&&(k=r.head.extra_len-r.length,r.head.extra||(r.head.extra=new Array(r.head.extra_len)),I.arraySet(r.head.extra,i,s,c,k)),512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,r.length-=c),r.length))break t;r.length=0,r.mode=7;case 7:if(2048&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.name+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.name=null);r.length=0,r.mode=8;case 8:if(4096&r.flags){if(0===o)break t;for(c=0;k=i[s+c++],r.head&&k&&r.length<65536&&(r.head.comment+=String.fromCharCode(k)),k&&c<o;);if(512&r.flags&&(r.check=B(r.check,i,c,s)),o-=c,s+=c,k)break t}else r.head&&(r.head.comment=null);r.mode=9;case 9:if(512&r.flags){for(;l<16;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(65535&r.check)){t.msg=\"header crc mismatch\",r.mode=30;break}l=u=0}r.head&&(r.head.hcrc=r.flags>>9&1,r.head.done=!0),t.adler=r.check=0,r.mode=12;break;case 10:for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}t.adler=r.check=L(u),l=u=0,r.mode=11;case 11:if(0===r.havedict)return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,2;t.adler=r.check=1,r.mode=12;case 12:if(5===e||6===e)break t;case 13:if(r.last){u>>>=7&l,l-=7&l,r.mode=27;break}for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}switch(r.last=1&u,l-=1,3&(u>>>=1)){case 0:r.mode=14;break;case 1:if(j(r),r.mode=20,6!==e)break;u>>>=2,l-=2;break t;case 2:r.mode=17;break;case 3:t.msg=\"invalid block type\",r.mode=30}u>>>=2,l-=2;break;case 14:for(u>>>=7&l,l-=7&l;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if((65535&u)!=(u>>>16^65535)){t.msg=\"invalid stored block lengths\",r.mode=30;break}if(r.length=65535&u,l=u=0,r.mode=15,6===e)break t;case 15:r.mode=16;case 16:if(c=r.length){if(o<c&&(c=o),h<c&&(c=h),0===c)break t;I.arraySet(n,i,s,c,a),o-=c,s+=c,h-=c,a+=c,r.length-=c;break}r.mode=12;break;case 17:for(;l<14;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(r.nlen=257+(31&u),u>>>=5,l-=5,r.ndist=1+(31&u),u>>>=5,l-=5,r.ncode=4+(15&u),u>>>=4,l-=4,286<r.nlen||30<r.ndist){t.msg=\"too many length or distance symbols\",r.mode=30;break}r.have=0,r.mode=18;case 18:for(;r.have<r.ncode;){for(;l<3;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.lens[A[r.have++]]=7&u,u>>>=3,l-=3}for(;r.have<19;)r.lens[A[r.have++]]=0;if(r.lencode=r.lendyn,r.lenbits=7,S={bits:r.lenbits},x=T(0,r.lens,0,19,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg=\"invalid code lengths set\",r.mode=30;break}r.have=0,r.mode=19;case 19:for(;r.have<r.nlen+r.ndist;){for(;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(b<16)u>>>=_,l-=_,r.lens[r.have++]=b;else{if(16===b){for(z=_+2;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u>>>=_,l-=_,0===r.have){t.msg=\"invalid bit length repeat\",r.mode=30;break}k=r.lens[r.have-1],c=3+(3&u),u>>>=2,l-=2}else if(17===b){for(z=_+3;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=3+(7&(u>>>=_)),u>>>=3,l-=3}else{for(z=_+7;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}l-=_,k=0,c=11+(127&(u>>>=_)),u>>>=7,l-=7}if(r.have+c>r.nlen+r.ndist){t.msg=\"invalid bit length repeat\",r.mode=30;break}for(;c--;)r.lens[r.have++]=k}}if(30===r.mode)break;if(0===r.lens[256]){t.msg=\"invalid code -- missing end-of-block\",r.mode=30;break}if(r.lenbits=9,S={bits:r.lenbits},x=T(D,r.lens,0,r.nlen,r.lencode,0,r.work,S),r.lenbits=S.bits,x){t.msg=\"invalid literal\/lengths set\",r.mode=30;break}if(r.distbits=6,r.distcode=r.distdyn,S={bits:r.distbits},x=T(F,r.lens,r.nlen,r.ndist,r.distcode,0,r.work,S),r.distbits=S.bits,x){t.msg=\"invalid distances set\",r.mode=30;break}if(r.mode=20,6===e)break t;case 20:r.mode=21;case 21:if(6<=o&&258<=h){t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,R(t,d),a=t.next_out,n=t.output,h=t.avail_out,s=t.next_in,i=t.input,o=t.avail_in,u=r.hold,l=r.bits,12===r.mode&&(r.back=-1);break}for(r.back=0;g=(C=r.lencode[u&(1<<r.lenbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(g&&0==(240&g)){for(v=_,y=g,w=b;g=(C=r.lencode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,r.length=b,0===g){r.mode=26;break}if(32&g){r.back=-1,r.mode=12;break}if(64&g){t.msg=\"invalid literal\/length code\",r.mode=30;break}r.extra=15&g,r.mode=22;case 22:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.length+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}r.was=r.length,r.mode=23;case 23:for(;g=(C=r.distcode[u&(1<<r.distbits)-1])>>>16&255,b=65535&C,!((_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(0==(240&g)){for(v=_,y=g,w=b;g=(C=r.distcode[w+((u&(1<<v+y)-1)>>v)])>>>16&255,b=65535&C,!(v+(_=C>>>24)<=l);){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}u>>>=v,l-=v,r.back+=v}if(u>>>=_,l-=_,r.back+=_,64&g){t.msg=\"invalid distance code\",r.mode=30;break}r.offset=b,r.extra=15&g,r.mode=24;case 24:if(r.extra){for(z=r.extra;l<z;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}r.offset+=u&(1<<r.extra)-1,u>>>=r.extra,l-=r.extra,r.back+=r.extra}if(r.offset>r.dmax){t.msg=\"invalid distance too far back\",r.mode=30;break}r.mode=25;case 25:if(0===h)break t;if(c=d-h,r.offset>c){if((c=r.offset-c)>r.whave&&r.sane){t.msg=\"invalid distance too far back\",r.mode=30;break}p=c>r.wnext?(c-=r.wnext,r.wsize-c):r.wnext-c,c>r.length&&(c=r.length),m=r.window}else m=n,p=a-r.offset,c=r.length;for(h<c&&(c=h),h-=c,r.length-=c;n[a++]=m[p++],--c;);0===r.length&&(r.mode=21);break;case 26:if(0===h)break t;n[a++]=r.length,h--,r.mode=21;break;case 27:if(r.wrap){for(;l<32;){if(0===o)break t;o--,u|=i[s++]<<l,l+=8}if(d-=h,t.total_out+=d,r.total+=d,d&&(t.adler=r.check=r.flags?B(r.check,n,d,a-d):O(r.check,n,d,a-d)),d=h,(r.flags?u:L(u))!==r.check){t.msg=\"incorrect data check\",r.mode=30;break}l=u=0}r.mode=28;case 28:if(r.wrap&&r.flags){for(;l<32;){if(0===o)break t;o--,u+=i[s++]<<l,l+=8}if(u!==(4294967295&r.total)){t.msg=\"incorrect length check\",r.mode=30;break}l=u=0}r.mode=29;case 29:x=1;break t;case 30:x=-3;break t;case 31:return-4;case 32:default:return U}return t.next_out=a,t.avail_out=h,t.next_in=s,t.avail_in=o,r.hold=u,r.bits=l,(r.wsize||d!==t.avail_out&&r.mode<30&&(r.mode<27||4!==e))&&Z(t,t.output,t.next_out,d-t.avail_out)?(r.mode=31,-4):(f-=t.avail_in,d-=t.avail_out,t.total_in+=f,t.total_out+=d,r.total+=d,r.wrap&&d&&(t.adler=r.check=r.flags?B(r.check,n,d,t.next_out-d):O(r.check,n,d,t.next_out-d)),t.data_type=r.bits+(r.last?64:0)+(12===r.mode?128:0)+(20===r.mode||15===r.mode?256:0),(0==f&&0===d||4===e)&&x===N&&(x=-5),x)},r.inflateEnd=function(t){if(!t||!t.state)return U;var e=t.state;return e.window&&(e.window=null),t.state=null,N},r.inflateGetHeader=function(t,e){var r;return t&&t.state?0==(2&(r=t.state).wrap)?U:((r.head=e).done=!1,N):U},r.inflateSetDictionary=function(t,e){var r,i=e.length;return t&&t.state?0!==(r=t.state).wrap&&11!==r.mode?U:11===r.mode&&O(1,e,i,0)!==r.check?-3:Z(t,e,i,i)?(r.mode=31,-4):(r.havedict=1,N):U},r.inflateInfo=\"pako inflate (from Nodeca project)\"},{\"..\/utils\/common\":41,\".\/adler32\":43,\".\/crc32\":45,\".\/inffast\":48,\".\/inftrees\":50}],50:[function(t,e,r){\"use strict\";var D=t(\"..\/utils\/common\"),F=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],N=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],U=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],P=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];e.exports=function(t,e,r,i,n,s,a,o){var h,u,l,f,d,c,p,m,_,g=o.bits,b=0,v=0,y=0,w=0,k=0,x=0,S=0,z=0,C=0,E=0,A=null,I=0,O=new D.Buf16(16),B=new D.Buf16(16),R=null,T=0;for(b=0;b<=15;b++)O[b]=0;for(v=0;v<i;v++)O[e[r+v]]++;for(k=g,w=15;1<=w&&0===O[w];w--);if(w<k&&(k=w),0===w)return n[s++]=20971520,n[s++]=20971520,o.bits=1,0;for(y=1;y<w&&0===O[y];y++);for(k<y&&(k=y),b=z=1;b<=15;b++)if(z<<=1,(z-=O[b])<0)return-1;if(0<z&&(0===t||1!==w))return-1;for(B[1]=0,b=1;b<15;b++)B[b+1]=B[b]+O[b];for(v=0;v<i;v++)0!==e[r+v]&&(a[B[e[r+v]]++]=v);if(c=0===t?(A=R=a,19):1===t?(A=F,I-=257,R=N,T-=257,256):(A=U,R=P,-1),b=y,d=s,S=v=E=0,l=-1,f=(C=1<<(x=k))-1,1===t&&852<C||2===t&&592<C)return 1;for(;;){for(p=b-S,_=a[v]<c?(m=0,a[v]):a[v]>c?(m=R[T+a[v]],A[I+a[v]]):(m=96,0),h=1<<b-S,y=u=1<<x;n[d+(E>>S)+(u-=h)]=p<<24|m<<16|_|0,0!==u;);for(h=1<<b-1;E&h;)h>>=1;if(0!==h?(E&=h-1,E+=h):E=0,v++,0==--O[b]){if(b===w)break;b=e[r+a[v]]}if(k<b&&(E&f)!==l){for(0===S&&(S=k),d+=y,z=1<<(x=b-S);x+S<w&&!((z-=O[x+S])<=0);)x++,z<<=1;if(C+=1<<x,1===t&&852<C||2===t&&592<C)return 1;n[l=E&f]=k<<24|x<<16|d-s|0}}return 0!==E&&(n[d+E]=b-S<<24|64<<16|0),o.bits=k,0}},{\"..\/utils\/common\":41}],51:[function(t,e,r){\"use strict\";e.exports={2:\"need dictionary\",1:\"stream end\",0:\"\",\"-1\":\"file error\",\"-2\":\"stream error\",\"-3\":\"data error\",\"-4\":\"insufficient memory\",\"-5\":\"buffer error\",\"-6\":\"incompatible version\"}},{}],52:[function(t,e,r){\"use strict\";var n=t(\"..\/utils\/common\"),o=0,h=1;function i(t){for(var e=t.length;0<=--e;)t[e]=0}var s=0,a=29,u=256,l=u+1+a,f=30,d=19,_=2*l+1,g=15,c=16,p=7,m=256,b=16,v=17,y=18,w=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],k=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],x=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],S=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],z=new Array(2*(l+2));i(z);var C=new Array(2*f);i(C);var E=new Array(512);i(E);var A=new Array(256);i(A);var I=new Array(a);i(I);var O,B,R,T=new Array(f);function D(t,e,r,i,n){this.static_tree=t,this.extra_bits=e,this.extra_base=r,this.elems=i,this.max_length=n,this.has_stree=t&&t.length}function F(t,e){this.dyn_tree=t,this.max_code=0,this.stat_desc=e}function N(t){return t<256?E[t]:E[256+(t>>>7)]}function U(t,e){t.pending_buf[t.pending++]=255&e,t.pending_buf[t.pending++]=e>>>8&255}function P(t,e,r){t.bi_valid>c-r?(t.bi_buf|=e<<t.bi_valid&65535,U(t,t.bi_buf),t.bi_buf=e>>c-t.bi_valid,t.bi_valid+=r-c):(t.bi_buf|=e<<t.bi_valid&65535,t.bi_valid+=r)}function L(t,e,r){P(t,r[2*e],r[2*e+1])}function j(t,e){for(var r=0;r|=1&t,t>>>=1,r<<=1,0<--e;);return r>>>1}function Z(t,e,r){var i,n,s=new Array(g+1),a=0;for(i=1;i<=g;i++)s[i]=a=a+r[i-1]<<1;for(n=0;n<=e;n++){var o=t[2*n+1];0!==o&&(t[2*n]=j(s[o]++,o))}}function W(t){var e;for(e=0;e<l;e++)t.dyn_ltree[2*e]=0;for(e=0;e<f;e++)t.dyn_dtree[2*e]=0;for(e=0;e<d;e++)t.bl_tree[2*e]=0;t.dyn_ltree[2*m]=1,t.opt_len=t.static_len=0,t.last_lit=t.matches=0}function M(t){8<t.bi_valid?U(t,t.bi_buf):0<t.bi_valid&&(t.pending_buf[t.pending++]=t.bi_buf),t.bi_buf=0,t.bi_valid=0}function H(t,e,r,i){var n=2*e,s=2*r;return t[n]<t[s]||t[n]===t[s]&&i[e]<=i[r]}function G(t,e,r){for(var i=t.heap[r],n=r<<1;n<=t.heap_len&&(n<t.heap_len&&H(e,t.heap[n+1],t.heap[n],t.depth)&&n++,!H(e,i,t.heap[n],t.depth));)t.heap[r]=t.heap[n],r=n,n<<=1;t.heap[r]=i}function K(t,e,r){var i,n,s,a,o=0;if(0!==t.last_lit)for(;i=t.pending_buf[t.d_buf+2*o]<<8|t.pending_buf[t.d_buf+2*o+1],n=t.pending_buf[t.l_buf+o],o++,0===i?L(t,n,e):(L(t,(s=A[n])+u+1,e),0!==(a=w[s])&&P(t,n-=I[s],a),L(t,s=N(--i),r),0!==(a=k[s])&&P(t,i-=T[s],a)),o<t.last_lit;);L(t,m,e)}function Y(t,e){var r,i,n,s=e.dyn_tree,a=e.stat_desc.static_tree,o=e.stat_desc.has_stree,h=e.stat_desc.elems,u=-1;for(t.heap_len=0,t.heap_max=_,r=0;r<h;r++)0!==s[2*r]?(t.heap[++t.heap_len]=u=r,t.depth[r]=0):s[2*r+1]=0;for(;t.heap_len<2;)s[2*(n=t.heap[++t.heap_len]=u<2?++u:0)]=1,t.depth[n]=0,t.opt_len--,o&&(t.static_len-=a[2*n+1]);for(e.max_code=u,r=t.heap_len>>1;1<=r;r--)G(t,s,r);for(n=h;r=t.heap[1],t.heap[1]=t.heap[t.heap_len--],G(t,s,1),i=t.heap[1],t.heap[--t.heap_max]=r,t.heap[--t.heap_max]=i,s[2*n]=s[2*r]+s[2*i],t.depth[n]=(t.depth[r]>=t.depth[i]?t.depth[r]:t.depth[i])+1,s[2*r+1]=s[2*i+1]=n,t.heap[1]=n++,G(t,s,1),2<=t.heap_len;);t.heap[--t.heap_max]=t.heap[1],function(t,e){var r,i,n,s,a,o,h=e.dyn_tree,u=e.max_code,l=e.stat_desc.static_tree,f=e.stat_desc.has_stree,d=e.stat_desc.extra_bits,c=e.stat_desc.extra_base,p=e.stat_desc.max_length,m=0;for(s=0;s<=g;s++)t.bl_count[s]=0;for(h[2*t.heap[t.heap_max]+1]=0,r=t.heap_max+1;r<_;r++)p<(s=h[2*h[2*(i=t.heap[r])+1]+1]+1)&&(s=p,m++),h[2*i+1]=s,u<i||(t.bl_count[s]++,a=0,c<=i&&(a=d[i-c]),o=h[2*i],t.opt_len+=o*(s+a),f&&(t.static_len+=o*(l[2*i+1]+a)));if(0!==m){do{for(s=p-1;0===t.bl_count[s];)s--;t.bl_count[s]--,t.bl_count[s+1]+=2,t.bl_count[p]--,m-=2}while(0<m);for(s=p;0!==s;s--)for(i=t.bl_count[s];0!==i;)u<(n=t.heap[--r])||(h[2*n+1]!==s&&(t.opt_len+=(s-h[2*n+1])*h[2*n],h[2*n+1]=s),i--)}}(t,e),Z(s,u,t.bl_count)}function X(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),e[2*(r+1)+1]=65535,i=0;i<=r;i++)n=a,a=e[2*(i+1)+1],++o<h&&n===a||(o<u?t.bl_tree[2*n]+=o:0!==n?(n!==s&&t.bl_tree[2*n]++,t.bl_tree[2*b]++):o<=10?t.bl_tree[2*v]++:t.bl_tree[2*y]++,s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4))}function V(t,e,r){var i,n,s=-1,a=e[1],o=0,h=7,u=4;for(0===a&&(h=138,u=3),i=0;i<=r;i++)if(n=a,a=e[2*(i+1)+1],!(++o<h&&n===a)){if(o<u)for(;L(t,n,t.bl_tree),0!=--o;);else 0!==n?(n!==s&&(L(t,n,t.bl_tree),o--),L(t,b,t.bl_tree),P(t,o-3,2)):o<=10?(L(t,v,t.bl_tree),P(t,o-3,3)):(L(t,y,t.bl_tree),P(t,o-11,7));s=n,u=(o=0)===a?(h=138,3):n===a?(h=6,3):(h=7,4)}}i(T);var q=!1;function J(t,e,r,i){P(t,(s<<1)+(i?1:0),3),function(t,e,r,i){M(t),i&&(U(t,r),U(t,~r)),n.arraySet(t.pending_buf,t.window,e,r,t.pending),t.pending+=r}(t,e,r,!0)}r._tr_init=function(t){q||(function(){var t,e,r,i,n,s=new Array(g+1);for(i=r=0;i<a-1;i++)for(I[i]=r,t=0;t<1<<w[i];t++)A[r++]=i;for(A[r-1]=i,i=n=0;i<16;i++)for(T[i]=n,t=0;t<1<<k[i];t++)E[n++]=i;for(n>>=7;i<f;i++)for(T[i]=n<<7,t=0;t<1<<k[i]-7;t++)E[256+n++]=i;for(e=0;e<=g;e++)s[e]=0;for(t=0;t<=143;)z[2*t+1]=8,t++,s[8]++;for(;t<=255;)z[2*t+1]=9,t++,s[9]++;for(;t<=279;)z[2*t+1]=7,t++,s[7]++;for(;t<=287;)z[2*t+1]=8,t++,s[8]++;for(Z(z,l+1,s),t=0;t<f;t++)C[2*t+1]=5,C[2*t]=j(t,5);O=new D(z,w,u+1,l,g),B=new D(C,k,0,f,g),R=new D(new Array(0),x,0,d,p)}(),q=!0),t.l_desc=new F(t.dyn_ltree,O),t.d_desc=new F(t.dyn_dtree,B),t.bl_desc=new F(t.bl_tree,R),t.bi_buf=0,t.bi_valid=0,W(t)},r._tr_stored_block=J,r._tr_flush_block=function(t,e,r,i){var n,s,a=0;0<t.level?(2===t.strm.data_type&&(t.strm.data_type=function(t){var e,r=4093624447;for(e=0;e<=31;e++,r>>>=1)if(1&r&&0!==t.dyn_ltree[2*e])return o;if(0!==t.dyn_ltree[18]||0!==t.dyn_ltree[20]||0!==t.dyn_ltree[26])return h;for(e=32;e<u;e++)if(0!==t.dyn_ltree[2*e])return h;return o}(t)),Y(t,t.l_desc),Y(t,t.d_desc),a=function(t){var e;for(X(t,t.dyn_ltree,t.l_desc.max_code),X(t,t.dyn_dtree,t.d_desc.max_code),Y(t,t.bl_desc),e=d-1;3<=e&&0===t.bl_tree[2*S[e]+1];e--);return t.opt_len+=3*(e+1)+5+5+4,e}(t),n=t.opt_len+3+7>>>3,(s=t.static_len+3+7>>>3)<=n&&(n=s)):n=s=r+5,r+4<=n&&-1!==e?J(t,e,r,i):4===t.strategy||s===n?(P(t,2+(i?1:0),3),K(t,z,C)):(P(t,4+(i?1:0),3),function(t,e,r,i){var n;for(P(t,e-257,5),P(t,r-1,5),P(t,i-4,4),n=0;n<i;n++)P(t,t.bl_tree[2*S[n]+1],3);V(t,t.dyn_ltree,e-1),V(t,t.dyn_dtree,r-1)}(t,t.l_desc.max_code+1,t.d_desc.max_code+1,a+1),K(t,t.dyn_ltree,t.dyn_dtree)),W(t),i&&M(t)},r._tr_tally=function(t,e,r){return t.pending_buf[t.d_buf+2*t.last_lit]=e>>>8&255,t.pending_buf[t.d_buf+2*t.last_lit+1]=255&e,t.pending_buf[t.l_buf+t.last_lit]=255&r,t.last_lit++,0===e?t.dyn_ltree[2*r]++:(t.matches++,e--,t.dyn_ltree[2*(A[r]+u+1)]++,t.dyn_dtree[2*N(e)]++),t.last_lit===t.lit_bufsize-1},r._tr_align=function(t){P(t,2,3),L(t,m,z),function(t){16===t.bi_valid?(U(t,t.bi_buf),t.bi_buf=0,t.bi_valid=0):8<=t.bi_valid&&(t.pending_buf[t.pending++]=255&t.bi_buf,t.bi_buf>>=8,t.bi_valid-=8)}(t)}},{\"..\/utils\/common\":41}],53:[function(t,e,r){\"use strict\";e.exports=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg=\"\",this.state=null,this.data_type=2,this.adler=0}},{}],54:[function(t,e,r){\"use strict\";e.exports=\"function\"==typeof setImmediate?setImmediate:function(){var t=[].slice.apply(arguments);t.splice(1,0,0),setTimeout.apply(null,t)}},{}]},{},[10])(10)});\n\\ No newline at end of file\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/jquery\/jszip\/dist\/jszip.min.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## JSZip v3.6.0\n+## JSZip v3.7.1\n@@ -3,2 +3,2 @@\n-### MIT License\n-<pre>\n+JSZip is dual licensed. You may use it under the MIT license *or* the GPLv3\n+license.\n@@ -6,0 +6,2 @@\n+### The MIT License\n+```\n@@ -8,19 +10,644 @@\n-Permission is hereby granted, free of charge, to any person obtaining a\n-copy of this software and associated documentation files (the \"Software\"),\n-to deal in the Software without restriction, including without limitation\n-the rights to use, copy, modify, merge, publish, distribute, sublicense,\n-and\/or sell copies of the Software, and to permit persons to whom the\n-Software is furnished to do so, subject to the following conditions:\n-\n-The above copyright notice and this permission notice shall be included\n-in all copies or substantial portions of the Software.\n-\n-THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n-OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n-THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR\n-OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n-ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n-OTHER DEALINGS IN THE SOFTWARE.\n-\n-<\/pre>\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and\/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE.\n+```\n+\n+### GPL version 3\n+```\n+\n+                    GNU GENERAL PUBLIC LICENSE\n+                       Version 3, 29 June 2007\n+\n+ Copyright (C) 2007 Free Software Foundation, Inc. <http:\/\/fsf.org\/>\n+ Everyone is permitted to copy and distribute verbatim copies\n+ of this license document, but changing it is not allowed.\n+\n+                            Preamble\n+\n+  The GNU General Public License is a free, copyleft license for\n+software and other kinds of works.\n+\n+  The licenses for most software and other practical works are designed\n+to take away your freedom to share and change the works.  By contrast,\n+the GNU General Public License is intended to guarantee your freedom to\n+share and change all versions of a program--to make sure it remains free\n+software for all its users.  We, the Free Software Foundation, use the\n+GNU General Public License for most of our software; it applies also to\n+any other work released this way by its authors.  You can apply it to\n+your programs, too.\n+\n+  When we speak of free software, we are referring to freedom, not\n+price.  Our General Public Licenses are designed to make sure that you\n+have the freedom to distribute copies of free software (and charge for\n+them if you wish), that you receive source code or can get it if you\n+want it, that you can change the software or use pieces of it in new\n+free programs, and that you know you can do these things.\n+\n+  To protect your rights, we need to prevent others from denying you\n+these rights or asking you to surrender the rights.  Therefore, you have\n+certain responsibilities if you distribute copies of the software, or if\n+you modify it: responsibilities to respect the freedom of others.\n+\n+  For example, if you distribute copies of such a program, whether\n+gratis or for a fee, you must pass on to the recipients the same\n+freedoms that you received.  You must make sure that they, too, receive\n+or can get the source code.  And you must show them these terms so they\n+know their rights.\n+\n+  Developers that use the GNU GPL protect your rights with two steps:\n+(1) assert copyright on the software, and (2) offer you this License\n+giving you legal permission to copy, distribute and\/or modify it.\n+\n+  For the developers' and authors' protection, the GPL clearly explains\n+that there is no warranty for this free software.  For both users' and\n+authors' sake, the GPL requires that modified versions be marked as\n+changed, so that their problems will not be attributed erroneously to\n+authors of previous versions.\n+\n+  Some devices are designed to deny users access to install or run\n+modified versions of the software inside them, although the manufacturer\n+can do so.  This is fundamentally incompatible with the aim of\n+protecting users' freedom to change the software.  The systematic\n+pattern of such abuse occurs in the area of products for individuals to\n+use, which is precisely where it is most unacceptable.  Therefore, we\n+have designed this version of the GPL to prohibit the practice for those\n+products.  If such problems arise substantially in other domains, we\n+stand ready to extend this provision to those domains in future versions\n+of the GPL, as needed to protect the freedom of users.\n+\n+  Finally, every program is threatened constantly by software patents.\n+States should not allow patents to restrict development and use of\n+software on general-purpose computers, but in those that do, we wish to\n+avoid the special danger that patents applied to a free program could\n+make it effectively proprietary.  To prevent this, the GPL assures that\n+patents cannot be used to render the program non-free.\n+\n+  The precise terms and conditions for copying, distribution and\n+modification follow.\n+\n+                       TERMS AND CONDITIONS\n+\n+  0. Definitions.\n+\n+  \"This License\" refers to version 3 of the GNU General Public License.\n+\n+  \"Copyright\" also means copyright-like laws that apply to other kinds of\n+works, such as semiconductor masks.\n+\n+  \"The Program\" refers to any copyrightable work licensed under this\n+License.  Each licensee is addressed as \"you\".  \"Licensees\" and\n+\"recipients\" may be individuals or organizations.\n+\n+  To \"modify\" a work means to copy from or adapt all or part of the work\n+in a fashion requiring copyright permission, other than the making of an\n+exact copy.  The resulting work is called a \"modified version\" of the\n+earlier work or a work \"based on\" the earlier work.\n+\n+  A \"covered work\" means either the unmodified Program or a work based\n+on the Program.\n+\n+  To \"propagate\" a work means to do anything with it that, without\n+permission, would make you directly or secondarily liable for\n+infringement under applicable copyright law, except executing it on a\n+computer or modifying a private copy.  Propagation includes copying,\n+distribution (with or without modification), making available to the\n+public, and in some countries other activities as well.\n+\n+  To \"convey\" a work means any kind of propagation that enables other\n+parties to make or receive copies.  Mere interaction with a user through\n+a computer network, with no transfer of a copy, is not conveying.\n+\n+  An interactive user interface displays \"Appropriate Legal Notices\"\n+to the extent that it includes a convenient and prominently visible\n+feature that (1) displays an appropriate copyright notice, and (2)\n+tells the user that there is no warranty for the work (except to the\n+extent that warranties are provided), that licensees may convey the\n+work under this License, and how to view a copy of this License.  If\n+the interface presents a list of user commands or options, such as a\n+menu, a prominent item in the list meets this criterion.\n+\n+  1. Source Code.\n+\n+  The \"source code\" for a work means the preferred form of the work\n+for making modifications to it.  \"Object code\" means any non-source\n+form of a work.\n+\n+  A \"Standard Interface\" means an interface that either is an official\n+standard defined by a recognized standards body, or, in the case of\n+interfaces specified for a particular programming language, one that\n+is widely used among developers working in that language.\n+\n+  The \"System Libraries\" of an executable work include anything, other\n+than the work as a whole, that (a) is included in the normal form of\n+packaging a Major Component, but which is not part of that Major\n+Component, and (b) serves only to enable use of the work with that\n+Major Component, or to implement a Standard Interface for which an\n+implementation is available to the public in source code form.  A\n+\"Major Component\", in this context, means a major essential component\n+(kernel, window system, and so on) of the specific operating system\n+(if any) on which the executable work runs, or a compiler used to\n+produce the work, or an object code interpreter used to run it.\n+\n+  The \"Corresponding Source\" for a work in object code form means all\n+the source code needed to generate, install, and (for an executable\n+work) run the object code and to modify the work, including scripts to\n+control those activities.  However, it does not include the work's\n+System Libraries, or general-purpose tools or generally available free\n+programs which are used unmodified in performing those activities but\n+which are not part of the work.  For example, Corresponding Source\n+includes interface definition files associated with source files for\n+the work, and the source code for shared libraries and dynamically\n+linked subprograms that the work is specifically designed to require,\n+such as by intimate data communication or control flow between those\n+subprograms and other parts of the work.\n+\n+  The Corresponding Source need not include anything that users\n+can regenerate automatically from other parts of the Corresponding\n+Source.\n+\n+  The Corresponding Source for a work in source code form is that\n+same work.\n+\n+  2. Basic Permissions.\n+\n+  All rights granted under this License are granted for the term of\n+copyright on the Program, and are irrevocable provided the stated\n+conditions are met.  This License explicitly affirms your unlimited\n+permission to run the unmodified Program.  The output from running a\n+covered work is covered by this License only if the output, given its\n+content, constitutes a covered work.  This License acknowledges your\n+rights of fair use or other equivalent, as provided by copyright law.\n+\n+  You may make, run and propagate covered works that you do not\n+convey, without conditions so long as your license otherwise remains\n+in force.  You may convey covered works to others for the sole purpose\n+of having them make modifications exclusively for you, or provide you\n+with facilities for running those works, provided that you comply with\n+the terms of this License in conveying all material for which you do\n+not control copyright.  Those thus making or running the covered works\n+for you must do so exclusively on your behalf, under your direction\n+and control, on terms that prohibit them from making any copies of\n+your copyrighted material outside their relationship with you.\n+\n+  Conveying under any other circumstances is permitted solely under\n+the conditions stated below.  Sublicensing is not allowed; section 10\n+makes it unnecessary.\n+\n+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n+\n+  No covered work shall be deemed part of an effective technological\n+measure under any applicable law fulfilling obligations under article\n+11 of the WIPO copyright treaty adopted on 20 December 1996, or\n+similar laws prohibiting or restricting circumvention of such\n+measures.\n+\n+  When you convey a covered work, you waive any legal power to forbid\n+circumvention of technological measures to the extent such circumvention\n+is effected by exercising rights under this License with respect to\n+the covered work, and you disclaim any intention to limit operation or\n+modification of the work as a means of enforcing, against the work's\n+users, your or third parties' legal rights to forbid circumvention of\n+technological measures.\n+\n+  4. Conveying Verbatim Copies.\n+\n+  You may convey verbatim copies of the Program's source code as you\n+receive it, in any medium, provided that you conspicuously and\n+appropriately publish on each copy an appropriate copyright notice;\n+keep intact all notices stating that this License and any\n+non-permissive terms added in accord with section 7 apply to the code;\n+keep intact all notices of the absence of any warranty; and give all\n+recipients a copy of this License along with the Program.\n+\n+  You may charge any price or no price for each copy that you convey,\n+and you may offer support or warranty protection for a fee.\n+\n+  5. Conveying Modified Source Versions.\n+\n+  You may convey a work based on the Program, or the modifications to\n+produce it from the Program, in the form of source code under the\n+terms of section 4, provided that you also meet all of these conditions:\n+\n+    a) The work must carry prominent notices stating that you modified\n+    it, and giving a relevant date.\n+\n+    b) The work must carry prominent notices stating that it is\n+    released under this License and any conditions added under section\n+    7.  This requirement modifies the requirement in section 4 to\n+    \"keep intact all notices\".\n+\n+    c) You must license the entire work, as a whole, under this\n+    License to anyone who comes into possession of a copy.  This\n+    License will therefore apply, along with any applicable section 7\n+    additional terms, to the whole of the work, and all its parts,\n+    regardless of how they are packaged.  This License gives no\n+    permission to license the work in any other way, but it does not\n+    invalidate such permission if you have separately received it.\n+\n+    d) If the work has interactive user interfaces, each must display\n+    Appropriate Legal Notices; however, if the Program has interactive\n+    interfaces that do not display Appropriate Legal Notices, your\n+    work need not make them do so.\n+\n+  A compilation of a covered work with other separate and independent\n+works, which are not by their nature extensions of the covered work,\n+and which are not combined with it such as to form a larger program,\n+in or on a volume of a storage or distribution medium, is called an\n+\"aggregate\" if the compilation and its resulting copyright are not\n+used to limit the access or legal rights of the compilation's users\n+beyond what the individual works permit.  Inclusion of a covered work\n+in an aggregate does not cause this License to apply to the other\n+parts of the aggregate.\n+\n+  6. Conveying Non-Source Forms.\n+\n+  You may convey a covered work in object code form under the terms\n+of sections 4 and 5, provided that you also convey the\n+machine-readable Corresponding Source under the terms of this License,\n+in one of these ways:\n+\n+    a) Convey the object code in, or embodied in, a physical product\n+    (including a physical distribution medium), accompanied by the\n+    Corresponding Source fixed on a durable physical medium\n+    customarily used for software interchange.\n+\n+    b) Convey the object code in, or embodied in, a physical product\n+    (including a physical distribution medium), accompanied by a\n+    written offer, valid for at least three years and valid for as\n+    long as you offer spare parts or customer support for that product\n+    model, to give anyone who possesses the object code either (1) a\n+    copy of the Corresponding Source for all the software in the\n+    product that is covered by this License, on a durable physical\n+    medium customarily used for software interchange, for a price no\n+    more than your reasonable cost of physically performing this\n+    conveying of source, or (2) access to copy the\n+    Corresponding Source from a network server at no charge.\n+\n+    c) Convey individual copies of the object code with a copy of the\n+    written offer to provide the Corresponding Source.  This\n+    alternative is allowed only occasionally and noncommercially, and\n+    only if you received the object code with such an offer, in accord\n+    with subsection 6b.\n+\n+    d) Convey the object code by offering access from a designated\n+    place (gratis or for a charge), and offer equivalent access to the\n+    Corresponding Source in the same way through the same place at no\n+    further charge.  You need not require recipients to copy the\n+    Corresponding Source along with the object code.  If the place to\n+    copy the object code is a network server, the Corresponding Source\n+    may be on a different server (operated by you or a third party)\n+    that supports equivalent copying facilities, provided you maintain\n+    clear directions next to the object code saying where to find the\n+    Corresponding Source.  Regardless of what server hosts the\n+    Corresponding Source, you remain obligated to ensure that it is\n+    available for as long as needed to satisfy these requirements.\n+\n+    e) Convey the object code using peer-to-peer transmission, provided\n+    you inform other peers where the object code and Corresponding\n+    Source of the work are being offered to the general public at no\n+    charge under subsection 6d.\n+\n+  A separable portion of the object code, whose source code is excluded\n+from the Corresponding Source as a System Library, need not be\n+included in conveying the object code work.\n+\n+  A \"User Product\" is either (1) a \"consumer product\", which means any\n+tangible personal property which is normally used for personal, family,\n+or household purposes, or (2) anything designed or sold for incorporation\n+into a dwelling.  In determining whether a product is a consumer product,\n+doubtful cases shall be resolved in favor of coverage.  For a particular\n+product received by a particular user, \"normally used\" refers to a\n+typical or common use of that class of product, regardless of the status\n+of the particular user or of the way in which the particular user\n+actually uses, or expects or is expected to use, the product.  A product\n+is a consumer product regardless of whether the product has substantial\n+commercial, industrial or non-consumer uses, unless such uses represent\n+the only significant mode of use of the product.\n+\n+  \"Installation Information\" for a User Product means any methods,\n+procedures, authorization keys, or other information required to install\n+and execute modified versions of a covered work in that User Product from\n+a modified version of its Corresponding Source.  The information must\n+suffice to ensure that the continued functioning of the modified object\n+code is in no case prevented or interfered with solely because\n+modification has been made.\n+\n+  If you convey an object code work under this section in, or with, or\n+specifically for use in, a User Product, and the conveying occurs as\n+part of a transaction in which the right of possession and use of the\n+User Product is transferred to the recipient in perpetuity or for a\n+fixed term (regardless of how the transaction is characterized), the\n+Corresponding Source conveyed under this section must be accompanied\n+by the Installation Information.  But this requirement does not apply\n+if neither you nor any third party retains the ability to install\n+modified object code on the User Product (for example, the work has\n+been installed in ROM).\n+\n+  The requirement to provide Installation Information does not include a\n+requirement to continue to provide support service, warranty, or updates\n+for a work that has been modified or installed by the recipient, or for\n+the User Product in which it has been modified or installed.  Access to a\n+network may be denied when the modification itself materially and\n+adversely affects the operation of the network or violates the rules and\n+protocols for communication across the network.\n+\n+  Corresponding Source conveyed, and Installation Information provided,\n+in accord with this section must be in a format that is publicly\n+documented (and with an implementation available to the public in\n+source code form), and must require no special password or key for\n+unpacking, reading or copying.\n+\n+  7. Additional Terms.\n+\n+  \"Additional permissions\" are terms that supplement the terms of this\n+License by making exceptions from one or more of its conditions.\n+Additional permissions that are applicable to the entire Program shall\n+be treated as though they were included in this License, to the extent\n+that they are valid under applicable law.  If additional permissions\n+apply only to part of the Program, that part may be used separately\n+under those permissions, but the entire Program remains governed by\n+this License without regard to the additional permissions.\n+\n+  When you convey a copy of a covered work, you may at your option\n+remove any additional permissions from that copy, or from any part of\n+it.  (Additional permissions may be written to require their own\n+removal in certain cases when you modify the work.)  You may place\n+additional permissions on material, added by you to a covered work,\n+for which you have or can give appropriate copyright permission.\n+\n+  Notwithstanding any other provision of this License, for material you\n+add to a covered work, you may (if authorized by the copyright holders of\n+that material) supplement the terms of this License with terms:\n+\n+    a) Disclaiming warranty or limiting liability differently from the\n+    terms of sections 15 and 16 of this License; or\n+\n+    b) Requiring preservation of specified reasonable legal notices or\n+    author attributions in that material or in the Appropriate Legal\n+    Notices displayed by works containing it; or\n+\n+    c) Prohibiting misrepresentation of the origin of that material, or\n+    requiring that modified versions of such material be marked in\n+    reasonable ways as different from the original version; or\n+\n+    d) Limiting the use for publicity purposes of names of licensors or\n+    authors of the material; or\n+\n+    e) Declining to grant rights under trademark law for use of some\n+    trade names, trademarks, or service marks; or\n+\n+    f) Requiring indemnification of licensors and authors of that\n+    material by anyone who conveys the material (or modified versions of\n+    it) with contractual assumptions of liability to the recipient, for\n+    any liability that these contractual assumptions directly impose on\n+    those licensors and authors.\n+\n+  All other non-permissive additional terms are considered \"further\n+restrictions\" within the meaning of section 10.  If the Program as you\n+received it, or any part of it, contains a notice stating that it is\n+governed by this License along with a term that is a further\n+restriction, you may remove that term.  If a license document contains\n+a further restriction but permits relicensing or conveying under this\n+License, you may add to a covered work material governed by the terms\n+of that license document, provided that the further restriction does\n+not survive such relicensing or conveying.\n+\n+  If you add terms to a covered work in accord with this section, you\n+must place, in the relevant source files, a statement of the\n+additional terms that apply to those files, or a notice indicating\n+where to find the applicable terms.\n+\n+  Additional terms, permissive or non-permissive, may be stated in the\n+form of a separately written license, or stated as exceptions;\n+the above requirements apply either way.\n+\n+  8. Termination.\n+\n+  You may not propagate or modify a covered work except as expressly\n+provided under this License.  Any attempt otherwise to propagate or\n+modify it is void, and will automatically terminate your rights under\n+this License (including any patent licenses granted under the third\n+paragraph of section 11).\n+\n+  However, if you cease all violation of this License, then your\n+license from a particular copyright holder is reinstated (a)\n+provisionally, unless and until the copyright holder explicitly and\n+finally terminates your license, and (b) permanently, if the copyright\n+holder fails to notify you of the violation by some reasonable means\n+prior to 60 days after the cessation.\n+\n+  Moreover, your license from a particular copyright holder is\n+reinstated permanently if the copyright holder notifies you of the\n+violation by some reasonable means, this is the first time you have\n+received notice of violation of this License (for any work) from that\n+copyright holder, and you cure the violation prior to 30 days after\n+your receipt of the notice.\n+\n+  Termination of your rights under this section does not terminate the\n+licenses of parties who have received copies or rights from you under\n+this License.  If your rights have been terminated and not permanently\n+reinstated, you do not qualify to receive new licenses for the same\n+material under section 10.\n+\n+  9. Acceptance Not Required for Having Copies.\n+\n+  You are not required to accept this License in order to receive or\n+run a copy of the Program.  Ancillary propagation of a covered work\n+occurring solely as a consequence of using peer-to-peer transmission\n+to receive a copy likewise does not require acceptance.  However,\n+nothing other than this License grants you permission to propagate or\n+modify any covered work.  These actions infringe copyright if you do\n+not accept this License.  Therefore, by modifying or propagating a\n+covered work, you indicate your acceptance of this License to do so.\n+\n+  10. Automatic Licensing of Downstream Recipients.\n+\n+  Each time you convey a covered work, the recipient automatically\n+receives a license from the original licensors, to run, modify and\n+propagate that work, subject to this License.  You are not responsible\n+for enforcing compliance by third parties with this License.\n+\n+  An \"entity transaction\" is a transaction transferring control of an\n+organization, or substantially all assets of one, or subdividing an\n+organization, or merging organizations.  If propagation of a covered\n+work results from an entity transaction, each party to that\n+transaction who receives a copy of the work also receives whatever\n+licenses to the work the party's predecessor in interest had or could\n+give under the previous paragraph, plus a right to possession of the\n+Corresponding Source of the work from the predecessor in interest, if\n+the predecessor has it or can get it with reasonable efforts.\n+\n+  You may not impose any further restrictions on the exercise of the\n+rights granted or affirmed under this License.  For example, you may\n+not impose a license fee, royalty, or other charge for exercise of\n+rights granted under this License, and you may not initiate litigation\n+(including a cross-claim or counterclaim in a lawsuit) alleging that\n+any patent claim is infringed by making, using, selling, offering for\n+sale, or importing the Program or any portion of it.\n+\n+  11. Patents.\n+\n+  A \"contributor\" is a copyright holder who authorizes use under this\n+License of the Program or a work on which the Program is based.  The\n+work thus licensed is called the contributor's \"contributor version\".\n+\n+  A contributor's \"essential patent claims\" are all patent claims\n+owned or controlled by the contributor, whether already acquired or\n+hereafter acquired, that would be infringed by some manner, permitted\n+by this License, of making, using, or selling its contributor version,\n+but do not include claims that would be infringed only as a\n+consequence of further modification of the contributor version.  For\n+purposes of this definition, \"control\" includes the right to grant\n+patent sublicenses in a manner consistent with the requirements of\n+this License.\n+\n+  Each contributor grants you a non-exclusive, worldwide, royalty-free\n+patent license under the contributor's essential patent claims, to\n+make, use, sell, offer for sale, import and otherwise run, modify and\n+propagate the contents of its contributor version.\n+\n+  In the following three paragraphs, a \"patent license\" is any express\n+agreement or commitment, however denominated, not to enforce a patent\n+(such as an express permission to practice a patent or covenant not to\n+sue for patent infringement).  To \"grant\" such a patent license to a\n+party means to make such an agreement or commitment not to enforce a\n+patent against the party.\n+\n+  If you convey a covered work, knowingly relying on a patent license,\n+and the Corresponding Source of the work is not available for anyone\n+to copy, free of charge and under the terms of this License, through a\n+publicly available network server or other readily accessible means,\n+then you must either (1) cause the Corresponding Source to be so\n+available, or (2) arrange to deprive yourself of the benefit of the\n+patent license for this particular work, or (3) arrange, in a manner\n+consistent with the requirements of this License, to extend the patent\n+license to downstream recipients.  \"Knowingly relying\" means you have\n+actual knowledge that, but for the patent license, your conveying the\n+covered work in a country, or your recipient's use of the covered work\n+in a country, would infringe one or more identifiable patents in that\n+country that you have reason to believe are valid.\n+\n+  If, pursuant to or in connection with a single transaction or\n+arrangement, you convey, or propagate by procuring conveyance of, a\n+covered work, and grant a patent license to some of the parties\n+receiving the covered work authorizing them to use, propagate, modify\n+or convey a specific copy of the covered work, then the patent license\n+you grant is automatically extended to all recipients of the covered\n+work and works based on it.\n+\n+  A patent license is \"discriminatory\" if it does not include within\n+the scope of its coverage, prohibits the exercise of, or is\n+conditioned on the non-exercise of one or more of the rights that are\n+specifically granted under this License.  You may not convey a covered\n+work if you are a party to an arrangement with a third party that is\n+in the business of distributing software, under which you make payment\n+to the third party based on the extent of your activity of conveying\n+the work, and under which the third party grants, to any of the\n+parties who would receive the covered work from you, a discriminatory\n+patent license (a) in connection with copies of the covered work\n+conveyed by you (or copies made from those copies), or (b) primarily\n+for and in connection with specific products or compilations that\n+contain the covered work, unless you entered into that arrangement,\n+or that patent license was granted, prior to 28 March 2007.\n+\n+  Nothing in this License shall be construed as excluding or limiting\n+any implied license or other defenses to infringement that may\n+otherwise be available to you under applicable patent law.\n+\n+  12. No Surrender of Others' Freedom.\n+\n+  If conditions are imposed on you (whether by court order, agreement or\n+otherwise) that contradict the conditions of this License, they do not\n+excuse you from the conditions of this License.  If you cannot convey a\n+covered work so as to satisfy simultaneously your obligations under this\n+License and any other pertinent obligations, then as a consequence you may\n+not convey it at all.  For example, if you agree to terms that obligate you\n+to collect a royalty for further conveying from those to whom you convey\n+the Program, the only way you could satisfy both those terms and this\n+License would be to refrain entirely from conveying the Program.\n+\n+  13. Use with the GNU Affero General Public License.\n+\n+  Notwithstanding any other provision of this License, you have\n+permission to link or combine any covered work with a work licensed\n+under version 3 of the GNU Affero General Public License into a single\n+combined work, and to convey the resulting work.  The terms of this\n+License will continue to apply to the part which is the covered work,\n+but the special requirements of the GNU Affero General Public License,\n+section 13, concerning interaction through a network will apply to the\n+combination as such.\n+\n+  14. Revised Versions of this License.\n+\n+  The Free Software Foundation may publish revised and\/or new versions of\n+the GNU General Public License from time to time.  Such new versions will\n+be similar in spirit to the present version, but may differ in detail to\n+address new problems or concerns.\n+\n+  Each version is given a distinguishing version number.  If the\n+Program specifies that a certain numbered version of the GNU General\n+Public License \"or any later version\" applies to it, you have the\n+option of following the terms and conditions either of that numbered\n+version or of any later version published by the Free Software\n+Foundation.  If the Program does not specify a version number of the\n+GNU General Public License, you may choose any version ever published\n+by the Free Software Foundation.\n+\n+  If the Program specifies that a proxy can decide which future\n+versions of the GNU General Public License can be used, that proxy's\n+public statement of acceptance of a version permanently authorizes you\n+to choose that version for the Program.\n+\n+  Later license versions may give you additional or different\n+permissions.  However, no additional obligations are imposed on any\n+author or copyright holder as a result of your choosing to follow a\n+later version.\n+\n+  15. Disclaimer of Warranty.\n+\n+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\n+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\n+HOLDERS AND\/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\n+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\n+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\n+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\n+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n+\n+  16. Limitation of Liability.\n+\n+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\n+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND\/OR CONVEYS\n+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\n+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\n+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\n+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\n+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\n+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\n+SUCH DAMAGES.\n+\n+  17. Interpretation of Sections 15 and 16.\n+\n+  If the disclaimer of warranty and limitation of liability provided\n+above cannot be given local legal effect according to their terms,\n+reviewing courts shall apply local law that most closely approximates\n+an absolute waiver of all civil liability in connection with the\n+Program, unless a warranty or assumption of liability accompanies a\n+copy of the Program in return for a fee.\n+\n+                     END OF TERMS AND CONDITIONS\n+```\n","filename":"src\/jdk.javadoc\/share\/legal\/jszip.md","additions":649,"deletions":22,"binary":false,"changes":671,"status":"modified"}]}