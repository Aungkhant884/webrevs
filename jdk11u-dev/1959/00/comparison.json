{"files":[{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8022780\n- * @summary Test division of large values\n- * @run main\/othervm -Xshare:off DivisionOverflow\n- * @author Dmitry Nadezhin\n- *\/\n-import java.math.BigInteger;\n-\n-public class DivisionOverflow {\n-\n-    public static void main(String[] args) {\n-        try {\n-            BigInteger a = BigInteger.ONE.shiftLeft(2147483646);\n-            BigInteger b = BigInteger.ONE.shiftLeft(1568);\n-            BigInteger[] qr = a.divideAndRemainder(b);\n-            BigInteger q = qr[0];\n-            BigInteger r = qr[1];\n-            if (!r.equals(BigInteger.ZERO)) {\n-                throw new RuntimeException(\"Incorrect signum() of remainder \" + r.signum());\n-            }\n-            if (q.bitLength() != 2147482079) {\n-                throw new RuntimeException(\"Incorrect bitLength() of quotient \" + q.bitLength());\n-            }\n-            System.out.println(\"Division of large values passed without overflow.\");\n-        } catch (OutOfMemoryError e) {\n-            \/\/ possible\n-            System.err.println(\"DivisionOverflow skipped: OutOfMemoryError\");\n-            System.err.println(\"Run jtreg with -javaoption:-Xmx8g\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/math\/BigInteger\/DivisionOverflow.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8021204\n- * @summary Test constructor BigInteger(String val, int radix) on very long string\n- * @ignore This test has huge memory requirements\n- * @run main\/othervm -Xshare:off -Xmx8g StringConstructorOverflow\n- * @author Dmitry Nadezhin\n- *\/\n-import java.math.BigInteger;\n-\n-public class StringConstructorOverflow {\n-\n-    \/\/ String with hexadecimal value pow(2,pow(2,34))+1\n-    private static String makeLongHexString() {\n-        StringBuilder sb = new StringBuilder();\n-        sb.append('1');\n-        for (int i = 0; i < (1 << 30) - 1; i++) {\n-            sb.append('0');\n-        }\n-        sb.append('1');\n-        return sb.toString();\n-    }\n-\n-    public static void main(String[] args) {\n-        try {\n-            BigInteger bi = new BigInteger(makeLongHexString(), 16);\n-            if (bi.compareTo(BigInteger.ONE) <= 0) {\n-                throw new RuntimeException(\"Incorrect result \" + bi.toString());\n-            }\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-            System.out.println(\"Overflow is reported by ArithmeticException, as expected\");\n-        } catch (OutOfMemoryError e) {\n-            \/\/ possible\n-            System.err.println(\"StringConstructorOverflow skipped: OutOfMemoryError\");\n-            System.err.println(\"Run jtreg with -javaoption:-Xmx8g\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/math\/BigInteger\/StringConstructorOverflow.java","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,665 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @library \/test\/lib\n- * @ignore This test has huge memory requirements\n- * @run main\/timeout=180\/othervm -Xmx8g SymmetricRangeTests\n- * @bug 6910473 8021204 8021203 9005933 8074460 8078672\n- * @summary Test range of BigInteger values (use -Dseed=X to set PRNG seed)\n- * @author Dmitry Nadezhin\n- * @key randomness\n- *\/\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.util.Arrays;\n-import java.math.BigInteger;\n-import java.util.Random;\n-import jdk.test.lib.RandomFactory;\n-\n-public class SymmetricRangeTests {\n-\n-    private static final BigInteger MAX_VALUE = makeMaxValue();\n-    private static final BigInteger MIN_VALUE = MAX_VALUE.negate();\n-\n-    private static BigInteger makeMaxValue() {\n-        byte[] ba = new byte[1 << 28];\n-        Arrays.fill(ba, (byte) 0xFF);\n-        ba[0] = (byte) 0x7F;\n-        return new BigInteger(ba);\n-    }\n-\n-    private static void check(String msg, BigInteger actual, BigInteger expected) {\n-        if (!actual.equals(expected)) {\n-            throw new RuntimeException(msg + \".bitLength()=\" + actual.bitLength());\n-        }\n-    }\n-\n-    private static void check(String msg, double actual, double expected) {\n-        if (actual != expected) {\n-            throw new RuntimeException(msg + \"=\" + actual);\n-        }\n-    }\n-\n-    private static void check(String msg, float actual, float expected) {\n-        if (actual != expected) {\n-            throw new RuntimeException(msg + \"=\" + actual);\n-        }\n-    }\n-\n-    private static void check(String msg, long actual, long expected) {\n-        if (actual != expected) {\n-            throw new RuntimeException(msg + \"=\" + actual);\n-        }\n-    }\n-\n-    private static void check(String msg, int actual, int expected) {\n-        if (actual != expected) {\n-            throw new RuntimeException(msg + \"=\" + actual);\n-        }\n-    }\n-\n-    private static void testOverflowInMakePositive() {\n-        System.out.println(\"Testing overflow in BigInteger.makePositive\");\n-        byte[] ba = new byte[Integer.MAX_VALUE - 2];\n-        ba[0] = (byte) 0x80;\n-        try {\n-            BigInteger actual = new BigInteger(ba);\n-            throw new RuntimeException(\"new BigInteger(ba).bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-    }\n-\n-    private static void testBug8021204() {\n-        System.out.println(\"Testing Bug 8021204\");\n-        StringBuilder sb = new StringBuilder();\n-        sb.append('1');\n-        for (int i = 0; i < (1 << 30) - 1; i++) {\n-            sb.append('0');\n-        }\n-        sb.append('1');\n-        String s = sb.toString();\n-        sb = null;\n-        try {\n-            BigInteger actual = new BigInteger(s, 16);\n-            throw new RuntimeException(\"new BigInteger(\\\"1000...001\\\").bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-    }\n-\n-    private static void testOverflowInBitSieve() {\n-        System.out.println(\"Testing overflow in BitSieve.sieveSingle\");\n-        int bitLength = (5 << 27) - 1;\n-        try {\n-            Random random = RandomFactory.getRandom();\n-            BigInteger actual = new BigInteger(bitLength, 0, random);\n-            throw new RuntimeException(\"new BigInteger(bitLength, 0, null).bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-        try {\n-            BigInteger bi = BigInteger.ONE.shiftLeft(bitLength - 1).subtract(BigInteger.ONE);\n-            BigInteger actual = bi.nextProbablePrime();\n-            throw new RuntimeException(\"bi.nextActualPrime().bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-    }\n-\n-    private static void testAdd() {\n-        System.out.println(\"Testing BigInteger.add\");\n-        try {\n-            BigInteger actual = MAX_VALUE.add(BigInteger.ONE);\n-            throw new RuntimeException(\"BigInteger.MAX_VALUE.add(BigInteger.ONE).bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-    }\n-\n-    private static void testSubtract() {\n-        System.out.println(\"Testing BigInteger.subtract\");\n-        try {\n-            BigInteger actual = MIN_VALUE.subtract(BigInteger.ONE);\n-            throw new RuntimeException(\"BigInteger.MIN_VALUE.subtract(BigInteger.ONE).bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-    }\n-\n-    private static void testMultiply() {\n-        System.out.println(\"Testing BigInteger.multiply\");\n-        int py = 2000;\n-        int px = Integer.MAX_VALUE - py;\n-        BigInteger x = BigInteger.ONE.shiftLeft(px);\n-        BigInteger y = BigInteger.ONE.shiftLeft(py);\n-        try {\n-            BigInteger actual = x.multiply(y);\n-            throw new RuntimeException(\"(1 << \" + px + \" ) * (1 << \" + py + \").bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-    }\n-\n-    private static void testDivide() {\n-        System.out.println(\"Testing BigInteger.divide\");\n-        check(\"BigInteger.MIN_VALUE.divide(BigInteger.valueOf(-1))\",\n-                MIN_VALUE.divide(BigInteger.valueOf(-1)), MAX_VALUE);\n-        check(\"BigInteger.MIN_VALUE.divide(BigInteger.ONE)\",\n-                MIN_VALUE.divide(BigInteger.ONE), MIN_VALUE);\n-    }\n-\n-    private static void testDivideAndRemainder(String msg, BigInteger dividend, BigInteger divisor,\n-            BigInteger expectedQuotent, BigInteger expectedRemainder) {\n-        BigInteger[] qr = dividend.divideAndRemainder(divisor);\n-        check(msg + \"[0]\", qr[0], expectedQuotent);\n-        check(msg + \"[1]\", qr[1], expectedRemainder);\n-    }\n-\n-    private static void testDivideAndRemainder() {\n-        System.out.println(\"Testing BigInteger.divideAndRemainder\");\n-        testDivideAndRemainder(\"BigInteger.MIN_VALUE.divideAndRemainder(BigInteger.valueOf(-1))\",\n-                MIN_VALUE, BigInteger.valueOf(-1),\n-                MAX_VALUE,\n-                BigInteger.ZERO);\n-    }\n-\n-    private static void testBug9005933() {\n-        System.out.println(\"Testing Bug 9005933\");\n-        int dividendPow = 2147483646;\n-        int divisorPow = 1568;\n-        BigInteger dividend = BigInteger.ONE.shiftLeft(dividendPow);\n-        BigInteger divisor = BigInteger.ONE.shiftLeft(divisorPow);\n-        testDivideAndRemainder(\"(1 << \" + dividendPow + \").divideAndRemainder(1 << \" + divisorPow + \")\",\n-                dividend, divisor,\n-                BigInteger.ONE.shiftLeft(dividendPow - divisorPow),\n-                BigInteger.ZERO);\n-    }\n-\n-    private static void testRemainder() {\n-        System.out.println(\"Testing BigInteger.remainder\");\n-        check(\"BigInteger.MIN_VALUE.remainder(BigInteger.valueOf(-1))\",\n-                MIN_VALUE.remainder(BigInteger.valueOf(-1)), BigInteger.ZERO);\n-    }\n-\n-    private static void testPow() {\n-        System.out.println(\"Testing BigInteger.pow\");\n-        check(\"BigInteger.MIN_VALUE.pow(1)\",\n-                MIN_VALUE.pow(1), MIN_VALUE);\n-        try {\n-            BigInteger actual = BigInteger.valueOf(4).pow(Integer.MAX_VALUE);\n-            throw new RuntimeException(\"BigInteger.valueOf(4).pow(Integer.MAX_VALUE).bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-    }\n-\n-    private static void testGcd() {\n-        System.out.println(\"Testing BigInteger.gcd\");\n-        check(\"BigInteger.MIN_VALUE.gcd(BigInteger.MIN_VALUE)\",\n-                MIN_VALUE.gcd(MIN_VALUE), MAX_VALUE);\n-        check(\"BigInteger.MIN_VALUE.gcd(BigInteger.ZERO)\",\n-                MIN_VALUE.gcd(BigInteger.ZERO), MAX_VALUE);\n-        check(\"BigInteger.ZERO.gcd(MIN_VALUE)\",\n-                BigInteger.ZERO.gcd(MIN_VALUE), MAX_VALUE);\n-    }\n-\n-    private static void testAbs() {\n-        System.out.println(\"Testing BigInteger.abs\");\n-        check(\"BigInteger.MIN_VALUE.abs()\",\n-                MIN_VALUE.abs(), MAX_VALUE);\n-        check(\"BigInteger.MAX_VALUE.abs()\",\n-                MAX_VALUE.abs(), MAX_VALUE);\n-    }\n-\n-    private static void testNegate() {\n-        System.out.println(\"Testing BigInteger.negate\");\n-        check(\"BigInteger.MIN_VALUE.negate()\",\n-                MIN_VALUE.negate(), MAX_VALUE);\n-        check(\"BigInteger.MAX_VALUE.negate()\",\n-                MAX_VALUE.negate(), MIN_VALUE);\n-    }\n-\n-    private static void testMod() {\n-        System.out.println(\"Testing BigInteger.mod\");\n-        check(\"BigInteger.MIN_VALUE.mod(BigInteger.MAX_VALUE)\",\n-                MIN_VALUE.mod(MAX_VALUE), BigInteger.ZERO);\n-        check(\"BigInteger.MAX_VALUE.mod(BigInteger.MAX_VALUE)\",\n-                MIN_VALUE.mod(MAX_VALUE), BigInteger.ZERO);\n-    }\n-\n-    private static void testModPow() {\n-        System.out.println(\"Testing BigInteger.modPow\");\n-        BigInteger x = BigInteger.valueOf(3);\n-        BigInteger m = BigInteger.valueOf(-4).subtract(MIN_VALUE);\n-        check(\"BigInteger.valueOf(3).modPow(BigInteger.ONE, m)\",\n-                x.modPow(BigInteger.ONE, m), x);\n-    }\n-\n-    \/\/ slow test\n-    private static void testModInverse() {\n-        System.out.println(\"Testing BigInteger.modInverse\");\n-        check(\"BigInteger.MIN_VALUE.modInverse(BigInteger.MAX_VALUE)\",\n-                MIN_VALUE.modInverse(MAX_VALUE), MAX_VALUE.subtract(BigInteger.ONE));\n-    }\n-\n-    private static void testShiftLeft() {\n-        System.out.println(\"Testing BigInteger.shiftLeft\");\n-        try {\n-            BigInteger actual = MIN_VALUE.shiftLeft(1);\n-            throw new RuntimeException(\"BigInteger.MIN_VALUE.shiftLeft(1).bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-        try {\n-            BigInteger actual = MAX_VALUE.shiftLeft(1);\n-            throw new RuntimeException(\"BigInteger.MAX_VALUE.shiftLeft(1).bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-    }\n-\n-    private static void testShiftRight() {\n-        System.out.println(\"Testing BigInteger.shiftRight\");\n-        try {\n-            BigInteger actual = MIN_VALUE.shiftRight(-1);\n-            throw new RuntimeException(\"BigInteger.MIN_VALUE.shiftRight(-1).bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-        try {\n-            BigInteger actual = MAX_VALUE.shiftRight(-1);\n-            throw new RuntimeException(\"BigInteger.MAX_VALUE.shiftRight(-1).bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-    }\n-\n-    private static void testAnd() {\n-        System.out.println(\"Testing BigInteger.and\");\n-        check(\"BigInteger.MIN_VALUE.and(BigInteger.MIN_VALUE)\",\n-                MIN_VALUE.and(MIN_VALUE), MIN_VALUE);\n-        check(\"BigInteger.MAX_VALUE.and(BigInteger.MAX_VALUE)\",\n-                MAX_VALUE.and(MAX_VALUE), MAX_VALUE);\n-        check(\"BigInteger.MIN_VALUE.and(BigInteger.MAX_VALUE)\",\n-                MIN_VALUE.and(MAX_VALUE), BigInteger.ONE);\n-        try {\n-            BigInteger actual = MIN_VALUE.and(BigInteger.valueOf(-2));\n-            throw new RuntimeException(\"BigInteger.MIN_VALUE.and(-2)).bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-    }\n-\n-    private static void testOr() {\n-        System.out.println(\"Testing BigInteger.or\");\n-        check(\"BigInteger.MIN_VALUE.or(BigInteger.MIN_VALUE)\",\n-                MIN_VALUE.or(MIN_VALUE), MIN_VALUE);\n-        check(\"BigInteger.MAX_VALUE.or(BigInteger.MAX_VALUE)\",\n-                MAX_VALUE.or(MAX_VALUE), MAX_VALUE);\n-        check(\"BigInteger.MIN_VALUE.and(BigInteger.MAX_VALUE)\",\n-                MIN_VALUE.or(MAX_VALUE), BigInteger.valueOf(-1));\n-    }\n-\n-    private static void testXor() {\n-        System.out.println(\"Testing BigInteger.xor\");\n-        check(\"BigInteger.MIN_VALUE.xor(BigInteger.MIN_VALUE)\",\n-                MIN_VALUE.xor(MIN_VALUE), BigInteger.ZERO);\n-        check(\"BigInteger.MAX_VALUE.xor(BigInteger.MAX_VALUE)\",\n-                MAX_VALUE.xor(MAX_VALUE), BigInteger.ZERO);\n-        check(\"BigInteger.MIN_VALUE.xor(BigInteger.MAX_VALUE)\",\n-                MIN_VALUE.xor(MAX_VALUE), BigInteger.valueOf(-2));\n-        try {\n-            BigInteger actual = MIN_VALUE.xor(BigInteger.ONE);\n-            throw new RuntimeException(\"BigInteger.MIN_VALUE.xor(BigInteger.ONE)).bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-    }\n-\n-    private static void testNot() {\n-        System.out.println(\"Testing BigInteger.not\");\n-        check(\"BigInteger.MIN_VALUE.not()\",\n-                MIN_VALUE.not(), MAX_VALUE.subtract(BigInteger.ONE));\n-        try {\n-            BigInteger actual = MAX_VALUE.not();\n-            throw new RuntimeException(\"BigInteger.MAX_VALUE.not()).bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-    }\n-\n-    private static void testSetBit() {\n-        System.out.println(\"Testing BigInteger.setBit\");\n-        check(\"BigInteger.MIN_VALUE.setBit(\" + Integer.MAX_VALUE + \")\",\n-                MIN_VALUE.setBit(Integer.MAX_VALUE), MIN_VALUE);\n-        try {\n-            BigInteger actual = MAX_VALUE.setBit(Integer.MAX_VALUE);\n-            throw new RuntimeException(\"BigInteger.MAX_VALUE.setBit(\" + Integer.MAX_VALUE + \").bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-    }\n-\n-    private static void testClearBit() {\n-        System.out.println(\"Testing BigInteger.clearBit\");\n-        check(\"BigInteger.MAX_VALUE.clearBit(\" + Integer.MAX_VALUE + \")\",\n-                MAX_VALUE.clearBit(Integer.MAX_VALUE), MAX_VALUE);\n-        try {\n-            BigInteger actual = MIN_VALUE.clearBit(Integer.MAX_VALUE);\n-            throw new RuntimeException(\"BigInteger.MIN_VALUE.clearBit(\" + Integer.MAX_VALUE + \").bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-        try {\n-            BigInteger actual = MIN_VALUE.clearBit(0);\n-            throw new RuntimeException(\"BigInteger.MIN_VALUE.clearBit(0).bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-    }\n-\n-    private static void testFlipBit() {\n-        System.out.println(\"Testing BigInteger.flipBit\");\n-        try {\n-            BigInteger actual = MIN_VALUE.flipBit(Integer.MAX_VALUE);\n-            throw new RuntimeException(\"BigInteger.MIN_VALUE.flipBit(\" + Integer.MAX_VALUE + \").bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-        try {\n-            BigInteger actual = MIN_VALUE.flipBit(0);\n-            throw new RuntimeException(\"BigInteger.MIN_VALUE.flipBit(0).bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-        try {\n-            BigInteger actual = MAX_VALUE.flipBit(Integer.MAX_VALUE);\n-            throw new RuntimeException(\"BigInteger.MAX_VALUE.flipBit(\" + Integer.MAX_VALUE + \").bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-    }\n-\n-    private static void testGetLowestSetBit() {\n-        System.out.println(\"Testing BigInteger.getLowestSetBit\");\n-        check(\"BigInteger.MIN_VALUE.getLowestSetBit()\",\n-                MIN_VALUE.getLowestSetBit(), 0);\n-        check(\"BigInteger.MAX_VALUE.getLowestSetBit()\",\n-                MAX_VALUE.getLowestSetBit(), 0);\n-    }\n-\n-    private static void testBitLength() {\n-        System.out.println(\"Testing BigInteger.bitLength\");\n-        check(\"BigInteger.MIN_NEXT.bitLength()\",\n-                MIN_VALUE.bitLength(), Integer.MAX_VALUE);\n-        check(\"BigInteger.MAX_VALUE.bitLength()\",\n-                MAX_VALUE.bitLength(), Integer.MAX_VALUE);\n-    }\n-\n-    private static void testBitCount() {\n-        System.out.println(\"Testing BigInteger.bitCount\");\n-        check(\"BigInteger.MIN_VALUE.bitCount()\",\n-                MIN_VALUE.bitCount(), Integer.MAX_VALUE - 1);\n-        check(\"BigInteger.MAX_VALUE.bitCount()\",\n-                MAX_VALUE.bitCount(), Integer.MAX_VALUE);\n-    }\n-\n-    private static void testToString(String msg, int radix, BigInteger bi, int length, String startsWith, char c) {\n-        String s = bi.toString(radix);\n-        if (s.length() != length) {\n-            throw new RuntimeException(msg + \".length=\" + s.length());\n-        }\n-        if (!s.startsWith(startsWith)) {\n-            throw new RuntimeException(msg + \"[0]=\" + s.substring(0, startsWith.length()));\n-        }\n-        for (int i = startsWith.length(); i < s.length(); i++) {\n-            if (s.charAt(i) != c) {\n-                throw new RuntimeException(msg + \"[\" + i + \"]='\" + s.charAt(i) + \"'\");\n-            }\n-        }\n-    }\n-\n-    private static void testToString() {\n-        System.out.println(\"Testing BigInteger.toString\");\n-        testToString(\"BigInteger.MIN_VALUE.toString(16)=\", 16,\n-                BigInteger.valueOf(-1).shiftLeft(Integer.MAX_VALUE - 1),\n-                (1 << 29) + 1, \"-4\", '0');\n-    }\n-\n-    private static void testToByteArrayWithConstructor(String msg, BigInteger bi, int length, byte msb, byte b, byte lsb) {\n-        byte[] ba = bi.toByteArray();\n-        if (ba.length != length) {\n-            throw new RuntimeException(msg + \".length=\" + ba.length);\n-        }\n-        if (ba[0] != msb) {\n-            throw new RuntimeException(msg + \"[0]=\" + ba[0]);\n-        }\n-        for (int i = 1; i < ba.length - 1; i++) {\n-            if (ba[i] != b) {\n-                throw new RuntimeException(msg + \"[\" + i + \"]=\" + ba[i]);\n-            }\n-        }\n-        if (ba[ba.length - 1] != lsb) {\n-            throw new RuntimeException(msg + \"[\" + (ba.length - 1) + \"]=\" + ba[ba.length - 1]);\n-        }\n-        BigInteger actual = new BigInteger(ba);\n-        if (!actual.equals(bi)) {\n-            throw new RuntimeException(msg + \".bitLength()=\" + actual.bitLength());\n-        }\n-    }\n-\n-    private static void testToByteArrayWithConstructor() {\n-        System.out.println(\"Testing BigInteger.toByteArray with constructor\");\n-        testToByteArrayWithConstructor(\"BigInteger.MIN_VALUE.toByteArray()\",\n-                MIN_VALUE, (1 << 28), (byte) 0x80, (byte) 0x00, (byte) 0x01);\n-        testToByteArrayWithConstructor(\"BigInteger.MAX_VALUE.toByteArray()\",\n-                MAX_VALUE, (1 << 28), (byte) 0x7f, (byte) 0xff, (byte) 0xff);\n-\n-        byte[] ba = new byte[1 << 28];\n-        ba[0] = (byte) 0x80;\n-        try {\n-            BigInteger actual = new BigInteger(-1, ba);\n-            throw new RuntimeException(\"new BigInteger(-1, ba).bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-        try {\n-            BigInteger actual = new BigInteger(1, ba);\n-            throw new RuntimeException(\"new BigInteger(1, ba).bitLength()=\" + actual.bitLength());\n-        } catch (ArithmeticException e) {\n-            \/\/ expected\n-        }\n-    }\n-\n-    private static void testIntValue() {\n-        System.out.println(\"Testing BigInteger.intValue\");\n-        check(\"BigInteger.MIN_VALUE.intValue()\",\n-                MIN_VALUE.intValue(), 1);\n-        check(\"BigInteger.MAX_VALUE.floatValue()\",\n-                MAX_VALUE.intValue(), -1);\n-    }\n-\n-    private static void testLongValue() {\n-        System.out.println(\"Testing BigInteger.longValue\");\n-        check(\"BigInteger.MIN_VALUE.longValue()\",\n-                MIN_VALUE.longValue(), 1L);\n-        check(\"BigInteger.MAX_VALUE.longValue()\",\n-                MAX_VALUE.longValue(), -1L);\n-    }\n-\n-    private static void testFloatValue() {\n-        System.out.println(\"Testing BigInteger.floatValue, Bug 8021203\");\n-        check(\"BigInteger.MIN_VALUE_.floatValue()\",\n-                MIN_VALUE.floatValue(), Float.NEGATIVE_INFINITY);\n-        check(\"BigInteger.MAX_VALUE.floatValue()\",\n-                MAX_VALUE.floatValue(), Float.POSITIVE_INFINITY);\n-    }\n-\n-    private static void testDoubleValue() {\n-        System.out.println(\"Testing BigInteger.doubleValue, Bug 8021203\");\n-        check(\"BigInteger.MIN_VALUE.doubleValue()\",\n-                MIN_VALUE.doubleValue(), Double.NEGATIVE_INFINITY);\n-        check(\"BigInteger.MAX_VALUE.doubleValue()\",\n-                MAX_VALUE.doubleValue(), Double.POSITIVE_INFINITY);\n-    }\n-\n-    private static void testSerialization(String msg, BigInteger bi) {\n-        try {\n-            ByteArrayOutputStream baOut = new ByteArrayOutputStream((1 << 28) + 1000);\n-            ObjectOutputStream out = new ObjectOutputStream(baOut);\n-            out.writeObject(bi);\n-            out.close();\n-            out = null;\n-            byte[] ba = baOut.toByteArray();\n-            baOut = null;\n-            ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(ba));\n-            BigInteger actual = (BigInteger) in.readObject();\n-            if (!actual.equals(bi)) {\n-                throw new RuntimeException(msg + \".bitLength()=\" + actual.bitLength());\n-            }\n-        } catch (IOException | ClassNotFoundException e) {\n-            throw new RuntimeException(msg + \" raised exception \", e);\n-        }\n-    }\n-\n-    private static void testSerialization() {\n-        System.out.println(\"Testing BigInteger serialization\");\n-        testSerialization(\"BigInteger.MIN_VALUE.intValue()\",\n-                MIN_VALUE);\n-        testSerialization(\"BigInteger.MAX_VALUE.floatValue()\",\n-                MAX_VALUE);\n-    }\n-\n-    private static void testLongValueExact() {\n-        System.out.println(\"Testing BigInteger.longValueExact\");\n-        try {\n-            long actual = MIN_VALUE.longValueExact();\n-            throw new RuntimeException(\"BigInteger.MIN_VALUE.longValueExact()= \" + actual);\n-        } catch (ArithmeticException e) {\n-            \/\/ excpected\n-        }\n-        try {\n-            long actual = MAX_VALUE.longValueExact();\n-            throw new RuntimeException(\"BigInteger.MAX_VALUE.longValueExact()= \" + actual);\n-        } catch (ArithmeticException e) {\n-            \/\/ excpected\n-        }\n-    }\n-\n-    private static void testIntValueExact() {\n-        System.out.println(\"Testing BigInteger.intValueExact\");\n-        try {\n-            long actual = MIN_VALUE.intValueExact();\n-            throw new RuntimeException(\"BigInteger.MIN_VALUE.intValueExact()= \" + actual);\n-        } catch (ArithmeticException e) {\n-            \/\/ excpected\n-        }\n-        try {\n-            long actual = MAX_VALUE.intValueExact();\n-            throw new RuntimeException(\"BigInteger.MAX_VALUE.intValueExact()= \" + actual);\n-        } catch (ArithmeticException e) {\n-            \/\/ excpected\n-        }\n-    }\n-\n-    private static void testShortValueExact() {\n-        System.out.println(\"Testing BigInteger.shortValueExact\");\n-        try {\n-            long actual = MIN_VALUE.shortValueExact();\n-            throw new RuntimeException(\"BigInteger.MIN_VALUE.shortValueExact()= \" + actual);\n-        } catch (ArithmeticException e) {\n-            \/\/ excpected\n-        }\n-        try {\n-            long actual = MAX_VALUE.shortValueExact();\n-            throw new RuntimeException(\"BigInteger.MAX_VALUE.shortValueExact()= \" + actual);\n-        } catch (ArithmeticException e) {\n-            \/\/ excpected\n-        }\n-    }\n-\n-    private static void testByteValueExact() {\n-        System.out.println(\"Testing BigInteger.byteValueExact\");\n-        try {\n-            long actual = MIN_VALUE.byteValueExact();\n-            throw new RuntimeException(\"BigInteger.MIN_VALUE.byteValueExact()= \" + actual);\n-        } catch (ArithmeticException e) {\n-            \/\/ excpected\n-        }\n-        try {\n-            long actual = MAX_VALUE.byteValueExact();\n-            throw new RuntimeException(\"BigInteger.MAX_VALUE.byteValueExact()= \" + actual);\n-        } catch (ArithmeticException e) {\n-            \/\/ excpected\n-        }\n-    }\n-\n-    public static void main(String... args) {\n-        testOverflowInMakePositive();\n-        testBug8021204();\n-        testOverflowInBitSieve();\n-        testAdd();\n-        testSubtract();\n-        testMultiply();\n-        testDivide();\n-        testDivideAndRemainder();\n-        testBug9005933();\n-        testRemainder();\n-        testPow();\n-        testGcd();\n-        testAbs();\n-        testNegate();\n-        testMod();\n-        testModPow();\n-\/\/        testModInverse();\n-        testShiftLeft();\n-        testShiftRight();\n-        testAnd();\n-        testOr();\n-        testXor();\n-        testNot();\n-        testSetBit();\n-        testClearBit();\n-        testFlipBit();\n-        testGetLowestSetBit();\n-        testBitLength();\n-        testBitCount();\n-        testToString();\n-        testToByteArrayWithConstructor();\n-        testIntValue();\n-        testLongValue();\n-        testFloatValue();\n-        testDoubleValue();\n-        testSerialization();\n-        testLongValueExact();\n-        testIntValueExact();\n-        testShortValueExact();\n-        testByteValueExact();\n-    }\n-}\n","filename":"test\/jdk\/java\/math\/BigInteger\/SymmetricRangeTests.java","additions":0,"deletions":665,"binary":false,"changes":665,"status":"deleted"}]}