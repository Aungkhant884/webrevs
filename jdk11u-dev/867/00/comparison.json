{"files":[{"patch":"@@ -140,4 +140,4 @@\n-            if (e.getMessage().trim().toLowerCase().contains(\"metadata\")) {\n-                System.out.println(\"Got OOME in metaspace in PerformChecksHelper.callMethods(Class clazz). \" +\n-                                \"This happened because reflection generates a too many accessors. \" +\n-                                \"There is nothing we can do with it, so we are just suppressing.\");\n+            if (e.getMessage().trim().toLowerCase().contains(\"metaspace\")) {\n+                \/\/ avoid string concatenation, which may create more classes.\n+                System.out.println(\"Got OOME in metaspace in PerformChecksHelper.callMethods(Class clazz). \");\n+                System.out.println(\"This is possible with -triggerUnloadingByFillingMetaspace\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/common\/PerformChecksHelper.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-import nsk.share.test.timeoutwatchdog.TimeoutHandler;\n-import nsk.share.test.timeoutwatchdog.TimeoutWatchdog;\n@@ -50,1 +48,1 @@\n-abstract public class StressHierarchyBaseClass extends TestBase implements TimeoutHandler {\n+abstract public class StressHierarchyBaseClass extends TestBase {\n@@ -104,1 +102,0 @@\n-            TimeoutWatchdog.watch(stresser, this);\n@@ -131,6 +128,0 @@\n-    @Override\n-    public void handleTimeout() {\n-        System.out.println(\"Shutting down vm because of time expired.\");\n-        System.exit(95);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/common\/StressHierarchyBaseClass.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- *      -XX:MaxMetaspaceSize=450m\n+ *      -XX:MaxMetaspaceSize=250m\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy012\/TestDescription.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,2 +122,0 @@\n-                } catch (IOException e) {\n-                        throw new TestBug(e);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/classload\/GeneratingClassLoader.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package nsk.share.test.timeoutwatchdog;\n-\n-\/**\n- * TimeoutHandler - interface to define reaction on timeout.\n- * @see TimeoutWatchdoc\n- *\/\n-public interface TimeoutHandler {\n-\n-        \/**\n-         * Invoked when watchdog detects timeout. Subclasses must implement this method to define how timeout should be handled.\n-         *\/\n-        void handleTimeout();\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/test\/timeoutwatchdog\/TimeoutHandler.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package nsk.share.test.timeoutwatchdog;\n-\n-import nsk.share.test.ExecutionController;\n-\n-\/**\n- * This class watches for ExecutionControler and notifies TimeoutHander in case of timeout.\n- *\/\n-public class TimeoutWatchdog implements Runnable {\n-\n-        private ExecutionController executionController;\n-\n-        private TimeoutHandler handler;\n-\n-        private static long CHECK_PERIOD = 1000; \/\/ In milliseconds\n-\n-        private TimeoutWatchdog(ExecutionController executionController, TimeoutHandler handler) {\n-                this.executionController = executionController;\n-                this.handler = handler;\n-        }\n-\n-        \/**\n-         * Start watching for timeout.\n-         * This method runs a new daemon thread that checks periodically if the observable test is still running.\n-         * If timeout is detected <code>handler.handleTimeout()<\/code> will be called. If the test finishes normally the daemon\n-         * thread will silently die.\n-         * @param executionController - executionController used to monitor time left\n-         * @param handler - handler on which handleTimeout() will be called\n-         *\/\n-        public static void watch(ExecutionController executionController, TimeoutHandler handler) {\n-                Thread thread = new Thread(new TimeoutWatchdog(executionController, handler));\n-                thread.setName(\"TimeoutWatchdog_thread\");\n-                thread.setDaemon(true);\n-                thread.start();\n-        }\n-\n-        @Override\n-        public void run() {\n-                try {\n-                        while (true) {\n-                                Thread.sleep(CHECK_PERIOD);\n-                                if (!executionController.continueExecution()) {\n-                                        System.out.println(\"Time expired. TimeoutWatchdog is calling TimeoutHandler.handleTimeout.\");\n-                                        handler.handleTimeout();\n-                                }\n-                        }\n-                } catch (InterruptedException e) {\n-                        throw new RuntimeException(\"Somebody dared to interrupt TimeoutWatchdog thread.\");\n-                }\n-        }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/test\/timeoutwatchdog\/TimeoutWatchdog.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.gc;\n-\n-import java.lang.management.ManagementFactory;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Random;\n-\n-import nsk.share.TestFailure;\n-import nsk.share.test.ExecutionController;\n-\n-public class TriggerUnloadingByFillingHeap implements TriggerUnloadingHelper {\n-\n-    public void triggerUnloading(ExecutionController stresser) {\n-        List<String> jvmArgs = ManagementFactory.getRuntimeMXBean().getInputArguments();\n-        if (jvmArgs.contains(\"-XX:+ExplicitGCInvokesConcurrent\")) {\n-                throw new TestFailure(\"Test bug! Found -XX:+ExplicitGCInvokesConcurrent in jvm args. TriggerUnloadingByFillingHeap.triggerUnloading will not work!.\");\n-        }\n-\n-        System.out.println(\"collections invoked: \" + provokeGC(stresser));\n-        System.out.println(\"collections invoked: \" + provokeGC(stresser));\n-        System.out.println(\"collections invoked: \" + provokeGC(stresser));\n-    }\n-\n-    private static long getGCCounter() {\n-        return ManagementFactory.getGarbageCollectorMXBeans().get(1).getCollectionCount();\n-    }\n-\n-    private static Random random = new Random();\n-\n-    public static byte[] garbage; \/\/make it reference public to avoid compiler optimizations\n-\n-    private static long provokeGC(ExecutionController stresser) {\n-        long initCounter = getGCCounter();\n-        ArrayList<byte[]> list = new ArrayList<byte[]>();\n-        while (getGCCounter() == initCounter && stresser.continueExecution()) {\n-            list.add(new byte[1024]);\n-\n-            garbage = new byte[1024];\n-            if (random.nextInt(10) % 10 < 3 && !list.isEmpty()) {\n-                list.remove(0);\n-            }\n-            System.gc();\n-        }\n-        return getGCCounter() - initCounter;\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/gc\/TriggerUnloadingByFillingHeap.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -25,5 +25,1 @@\n-import java.util.ArrayList;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-\n+import nsk.share.test.ExecutionController;\n@@ -32,1 +28,0 @@\n-import nsk.share.test.ExecutionController;\n@@ -37,35 +32,12 @@\n-    private static final int NUMBER_OF_THREADS = 30;\n-\n-    private static class FillMetaspace {\n-        private volatile boolean gotOOME = false;\n-        private ExecutionController stresser;\n-        private final ThreadLocal<GeneratedClassProducer> generatedClassProducer =\n-            new ThreadLocal<GeneratedClassProducer>() {\n-              @Override\n-              protected GeneratedClassProducer initialValue() {\n-                return new GeneratedClassProducer(\"metaspace.stressHierarchy.common.HumongousClass\");\n-              }\n-            };\n-\n-        public FillMetaspace(ExecutionController stresser) { this.stresser = stresser; }\n-\n-        private class FillMetaspaceTask implements Callable<Object> {\n-            @Override\n-            public Object call() throws Exception {\n-                while (stresser.continueExecution() && ! gotOOME) {\n-                    try {\n-                        generatedClassProducer.get().create(-100500); \/\/argument is not used.\n-                    } catch (OutOfMemoryError oome) {\n-                        if (!isInMetaspace(oome)) {\n-                            throw new GotWrongOOMEException(\"Got OOME in heap while gaining OOME in metaspace. Test result can't be valid.\");\n-                        }\n-                        gotOOME = true;\n-                    }\n-                }\n-                return null;\n-            }\n-        }\n-    }\n-\n-    private static boolean isInMetaspace(OutOfMemoryError error) {\n-        return error.getMessage().trim().toLowerCase().contains(\"metadata\");\n+    private volatile boolean gotOOME = false;\n+    private ExecutionController stresser;\n+    private final ThreadLocal<GeneratedClassProducer> generatedClassProducer =\n+        new ThreadLocal<GeneratedClassProducer>() {\n+          @Override\n+          protected GeneratedClassProducer initialValue() {\n+            return new GeneratedClassProducer(\"metaspace.stressHierarchy.common.HumongousClass\");\n+          }\n+        };\n+\n+    private static boolean isInMetaspace(Throwable error) {\n+        return (error.getMessage().trim().toLowerCase().contains(\"metaspace\"));\n@@ -76,7 +48,1 @@\n-        try {\n-            FillMetaspace fillMetaspace = new FillMetaspace(stresser);\n-            ArrayList<Callable<Object>> tasks = new ArrayList<Callable<Object>>(NUMBER_OF_THREADS);\n-            for (int i = 0; i < NUMBER_OF_THREADS; i++) {\n-                tasks.add(fillMetaspace.new FillMetaspaceTask());\n-            }\n-            ExecutorService executorService = Executors.newCachedThreadPool();\n+        while (stresser.continueExecution() && !gotOOME) {\n@@ -84,8 +50,6 @@\n-                executorService.invokeAll(tasks);\n-            } catch (InterruptedException e) {\n-                System.out.println(\"Process of gaining OOME in metaspace was interrupted.\");\n-                e.printStackTrace();\n-            }\n-        } catch (OutOfMemoryError e) {\n-            if (!isInMetaspace(e)) {\n-                throw new GotWrongOOMEException(\"Got OOME in heap while gaining OOME in metaspace. Test result can't be valid.\");\n+                generatedClassProducer.get().create(-100500); \/\/argument is not used.\n+            } catch (Throwable oome) {\n+                if (!isInMetaspace(oome)) {\n+                    throw new GotWrongOOMEException(\"Got OOME in heap while triggering OOME in metaspace. Test result can't be valid.\");\n+                }\n+                gotOOME = true;\n@@ -93,1 +57,0 @@\n-            return;\n@@ -96,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/gc\/TriggerUnloadingByFillingMetaspace.java","additions":20,"deletions":58,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.vmstresser;\n-\n-public class CompileAndDeoptimize implements Runnable {\n-\n-    public static int v = 0;\n-\n-    private abstract static class A {\n-        public abstract void incv();\n-    }\n-\n-    private static class B extends A {\n-        public void incv() {\n-            v++;\n-        }\n-    }\n-\n-    public static class C extends A {\n-        public void incv() {\n-            v += (new int[1][1][1][1][1][1][1][1]).length;\n-        }\n-    }\n-\n-    private volatile boolean done = false;\n-    public volatile A a = new B();\n-\n-    private void incv() {\n-        a.incv();\n-    }\n-\n-    private void inc() {\n-        while ( ! done ) {\n-            incv();\n-        }\n-        \/\/while ( ! done ) {\n-        \/\/      incv();\n-        \/\/}\n-        \/\/while ( ! done ) {\n-        \/\/      incv();\n-        \/\/}\n-    }\n-\n-    public void run() {\n-        try {\n-            Thread t = new Thread(new Runnable() { @Override public void run() { inc(); } });\n-            t.start();\n-            Thread.sleep(100);\n-            a = (A) CompileAndDeoptimize.class.getClassLoader().loadClass(B.class.getName().replaceAll(\"B$\", \"C\")).getConstructors()[0].newInstance(new Object[0]);\n-            \/\/Thread.sleep(1000);\n-            \/\/done = true;\n-            \/\/t.join();\n-\n-        } catch ( Throwable t ) {\n-            t.printStackTrace();\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/vmstresser\/CompileAndDeoptimize.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -1,260 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.vmstresser;\n-\n-import java.util.*;\n-import java.util.concurrent.locks.*;\n-\n-import nsk.share.*;\n-import nsk.share.classload.*;\n-import nsk.share.test.*;\n-\n-\/**\n- * Stresser that load classes until OOME, then unload some of them and continue loading.\n- *\/\n-public class MetaspaceStresser extends Thread {\n-\n-    \/**\n-     * Capacity of class containers.\n-     * This amount of classes will be unloaded on reset call.\n-     *\/\n-    public static final int DEFAULT_BUCKET_SIZE = 4000;\n-\n-    public static final int DEFAULT_PAUSE_TIME = 0;\n-\n-    \/*\n-     * Loaded classes stored in ClassContainer instances.\n-     * Such instances organized in array-based stack as it is\n-     * one of the simplest way to minimize possibility\n-     * to get OOME and guarntee that after replacing\n-     * reference to class container by null there will be\n-     * no cached refereces and container will be reclaimed by\n-     * GC and classes will become unloadable.\n-     *\/\n-    \/\/ Maximum available amount of arrays with class containers.\n-    private static final int CONTAINERS_ARRAY_LENGTH = 1000;\n-    \/\/ Maximum length array with class containers.\n-    private static final int CONTAINER_ARRAYS_COUNT = 100;\n-\n-    private ClassContainersStack containersStack = new ClassContainersStack(CONTAINER_ARRAYS_COUNT * CONTAINERS_ARRAY_LENGTH,\n-            CONTAINERS_ARRAY_LENGTH);\n-    private ClassContainer newContainer = null;\n-\n-    private ExecutionController controller = null;\n-    private int bucketSize = DEFAULT_BUCKET_SIZE;\n-    private int pauseTime = DEFAULT_PAUSE_TIME;\n-\n-    private ReentrantLock lock = new ReentrantLock();\n-\n-    \/**\n-     * Construct MetaspaceStrresser with default bucket size\n-     * and pause time.\n-     * @param c controller to control execution time.\n-     *\/\n-    public MetaspaceStresser(ExecutionController c) {\n-        controller = c;\n-    }\n-\n-    \/**\n-     * Construct MetaspaceStrresser with custom bucket size\n-     * and pause time.\n-     * @param c controller to control execution time.\n-     * @param bucketSize classes to be unloaded on reset.\n-     * @param pauseTime pause after reset.\n-     *\/\n-    public MetaspaceStresser(ExecutionController c, int bucketSize, int pauseTime) {\n-        this(c);\n-        this.bucketSize = bucketSize;\n-        this.pauseTime = pauseTime;\n-    }\n-\n-    \/**\n-     *  Fill Metaspace with classes.\n-     *  Classes will be loaded until OOME, then some of them will be unloaded.\n-     *\/\n-    public synchronized void prepare() {\n-        while (controller.continueExecution()) {\n-            try {\n-                fillContainerStack();\n-            } catch (OutOfMemoryError oome) {\n-                unloadLastClassBucket();\n-                return;\n-            } catch (ClassNotFoundException cnfe) {\n-                throw new TestBug(\"Unexpected exception in stresser.\", cnfe);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Load new class to container, fill containerStack.\n-     * Classes will be loaded until OOME\n-     * @throws ClassNotFoundException\n-     *\/\n-    private void fillContainerStack() throws ClassNotFoundException {\n-        newContainer = new ClassContainer();\n-        while (newContainer.size() < bucketSize && controller.continueExecution()) {\n-            newContainer.loadClass();\n-        }\n-        containersStack.push(newContainer);\n-        newContainer = null;\n-    }\n-\n-    \/**\n-     * Run stresser.\n-     * Stresser will load classes until OOME, then bucketSize classes\n-     * will be unloaded and stresser will wait pauseTime millisiconds\n-     * before continuing class loading.\n-     *\/\n-    public void run() {\n-        try {\n-            while (controller.continueExecution()) {\n-                try {\n-                    fillContainerStack();\n-                } catch (OutOfMemoryError oome) {\n-                    unloadLastClassBucket();\n-                    try {\n-                        Thread.sleep(pauseTime);\n-                    } catch (InterruptedException ie) {\n-                    }\n-                }\n-            }\n-        } catch (Throwable e) {\n-            throw new TestBug(\"Unexpected exception in stresser.\", e);\n-        } finally {\n-            containersStack.free();\n-        }\n-    }\n-\n-    \/**\n-     * Unload most recently loaded bucket of classes.\n-     *\/\n-    public void unloadLastClassBucket() {\n-        while (controller.continueExecution()) {\n-            try {\n-                containersStack.pop();\n-                System.gc();\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                oome.printStackTrace();\n-                continue;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Array-based stack for ClassContainer's.\n-     *\/\n-    private class ClassContainersStack {\n-\n-        private int arrayLength = 0;\n-        private int arraysCount = 0;\n-        private int arrayIndex = 0;\n-        private int elemIndex = 0;\n-\n-        private ClassContainer data[][];\n-\n-        \/**\n-         * Create ClassContainersStack that will be able\n-         * to store size classes in arrays of segmentSize length.\n-         *\/\n-        public ClassContainersStack(int size, int segementSize) {\n-            arrayLength = segementSize;\n-            arraysCount = size \/ arrayLength;\n-            data = new ClassContainer[arraysCount][];\n-            data[0] = new ClassContainer[arrayLength];\n-        }\n-\n-        \/**\n-         * Push ClassContainer c into stack.\n-         *\/\n-        public synchronized void push(ClassContainer c) {\n-            data[arrayIndex][elemIndex] = c;\n-            elemIndex++;\n-            if (elemIndex == arrayLength) {\n-                if (arrayIndex == arraysCount) {\n-                    throw new TestBug(\"ClassContainersStack ran out of available slots\");\n-                }\n-                data[arrayIndex + 1] = new ClassContainer[arrayLength];\n-                arrayIndex++;\n-                elemIndex = 0;\n-            }\n-        }\n-\n-        \/**\n-         * Remove reference to top ClassContainer.\n-         *\/\n-        public synchronized void pop() {\n-            data[arrayIndex][elemIndex] = null;\n-            if (elemIndex > 0) {\n-                elemIndex--;\n-            } else if (arrayIndex > 0) {\n-                data[arrayIndex] = null;\n-                arrayIndex--;\n-                elemIndex = arrayLength - 1;\n-            }\n-        }\n-\n-        \/**\n-         * Remove all stored ClassContainers.\n-         *\/\n-        public synchronized void free() {\n-            data = null;\n-            System.gc();\n-            data = new ClassContainer[arraysCount][];\n-            data[0] = new ClassContainer[arrayLength];\n-            arrayIndex = 0;\n-            elemIndex = 0;\n-        }\n-\n-    }\n-\n-    \/\/\/ Variable used to create uniqe name for generated classes.\n-    private static long lastClass = 0;\n-\n-    \/**\n-     * Class container consists of classes and their ClassLoader, so\n-     * if there will be no references to container and classes inside it then\n-     * it could be easely collected by GC.\n-     *\/\n-    private class ClassContainer {\n-\n-        private List<Class> classes = new LinkedList<Class>();\n-        private GeneratingClassLoader loader = new GeneratingClassLoader();\n-        private String prefix = loader.getPrefix();\n-        private int length = loader.getNameLength();\n-\n-        public void loadClass() throws ClassNotFoundException {\n-            String newName = prefix + \"c\" + lastClass;\n-            lastClass++;\n-            while (newName.length() < length) {\n-                newName = newName + \"c\";\n-            }\n-            classes.add(loader.loadClass(newName));\n-        }\n-\n-        public int size() {\n-            return classes.size();\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/vmstresser\/MetaspaceStresser.java","additions":0,"deletions":260,"binary":false,"changes":260,"status":"deleted"}]}