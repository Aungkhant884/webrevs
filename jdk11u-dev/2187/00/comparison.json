{"files":[{"patch":"@@ -892,1 +892,1 @@\n-   \/**\n+    \/**\n@@ -912,1 +912,1 @@\n-        if (! (utils.isIncluded(element) || utils.isLinkable(typeElement))) {\n+        if (!utils.isLinkable(typeElement, element)) {\n@@ -914,1 +914,3 @@\n-        } else if (utils.isExecutableElement(element)) {\n+        }\n+\n+        if (utils.isExecutableElement(element)) {\n@@ -920,1 +922,3 @@\n-        } else if (utils.isVariableElement(element) || utils.isTypeElement(element)) {\n+        }\n+\n+        if (utils.isVariableElement(element) || utils.isTypeElement(element)) {\n@@ -925,2 +929,0 @@\n-        } else {\n-            return label;\n@@ -928,0 +930,2 @@\n+\n+        return label;\n@@ -981,1 +985,0 @@\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -276,5 +276,3 @@\n-        if (!seeTags.isEmpty()) {\n-            for (DocTree dt : seeTags) {\n-                appendSeparatorIfNotEmpty(body);\n-                body.addContent(htmlWriter.seeTagToContent(holder, dt));\n-            }\n+        for (DocTree dt : seeTags) {\n+            appendSeparatorIfNotEmpty(body);\n+            body.addContent(htmlWriter.seeTagToContent(holder, dt));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -226,1 +226,0 @@\n-doclet.Class=Class\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1019,3 +1019,3 @@\n-     * Return true if this class is linkable and false if we can't link to the\n-     * desired class.\n-     * <br>\n+     * Returns true if this class is linkable and false if we can't link to it.\n+     *\n+     * <p>\n@@ -1036,0 +1036,37 @@\n+    \/**\n+     * Returns true if an element is linkable in the context of a given type element.\n+     *\n+     * If the element is a type element, it delegates to {@link #isLinkable(TypeElement)}.\n+     * Otherwise, the element is linkable if any of the following are true:\n+     * <ul>\n+     * <li>it is \"included\" (see {@link jdk.javadoc.doclet})\n+     * <li>it is inherited from an undocumented supertype\n+     * <li>it is a public or protected member of an external API\n+     * <\/ul>\n+     *\n+     * @param typeElem the type element\n+     * @param elem the element\n+     * @return whether or not the element is linkable\n+     *\/\n+    public boolean isLinkable(TypeElement typeElem, Element elem) {\n+        if (isTypeElement(elem)) {\n+            return isLinkable((TypeElement) elem); \/\/ defer to existing behavior\n+        }\n+\n+        if (isIncluded(elem)) {\n+            return true;\n+        }\n+\n+        \/\/ Allow for the behavior that members of undocumented supertypes\n+        \/\/ may be included in documented types\n+        TypeElement enclElem = getEnclosingTypeElement(elem);\n+        if (typeElem != enclElem && isSubclassOf(typeElem, enclElem)) {\n+            return true;\n+        }\n+\n+        \/\/ Allow for external members\n+        return isLinkable(typeElem)\n+                    && configuration.extern.isExternal(typeElem)\n+                    && (isPublic(elem) || isProtected(elem));\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8207214\n+ * @summary Test serialized forms, with at-see to other members\n+ * @library \/tools\/lib ..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build JavadocTester toolbox.ToolBox\n+ * @run main TestSerializedFormWithSee\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import toolbox.ToolBox;\n+\n+\/**\n+ * Test the links generated in source files with combinations\n+ * of modules, Serializable, and @see for public and private methods.\n+ *\n+ * In the various test cases, in addition to the explicit call\n+ * to {@code checkExit}, the primary check is the implicit call\n+ * to {@code checkLinks}, to verify that there are no broken\n+ * links in the generated files.\n+ *\/\n+public class TestSerializedFormWithSee extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        TestSerializedFormWithSee tester = new TestSerializedFormWithSee();\n+        tester.runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    private final ToolBox tb;\n+\n+    TestSerializedFormWithSee() {\n+        tb = new ToolBox();\n+    }\n+\n+    @Test\n+    public void test_noModule_notSerializable(Path base) throws IOException {\n+        Path srcDir = generateSource(base, false, false);\n+\n+        Path outDir = base.resolve(\"out\");\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+    }\n+\n+    @Test\n+    public void test_noModule_serializable(Path base) throws IOException {\n+        Path srcDir = generateSource(base, false, true);\n+\n+        Path outDir = base.resolve(\"out\");\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"p\");\n+        checkExit(Exit.OK);\n+    }\n+\n+    @Test\n+    public void test_module_notSerializable(Path base) throws IOException {\n+        Path srcDir = generateSource(base, true, false);\n+\n+        Path outDir = base.resolve(\"out\");\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"m\/p\");\n+        checkExit(Exit.OK);\n+    }\n+\n+    @Test\n+    public void test_module_serializable(Path base) throws IOException {\n+        Path srcDir = generateSource(base, true, true);\n+\n+        Path outDir = base.resolve(\"out\");\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"m\/p\");\n+        checkExit(Exit.OK);\n+    }\n+\n+    Path generateSource(Path base, boolean module, boolean serializable) throws IOException {\n+        Path dir = base.resolve(\"src\");\n+        if (module) {\n+            tb.writeJavaFiles(dir, \"module m { }\");\n+        }\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"package p;\\n\");\n+        sb.append(\"public class C \" + (serializable ? \"implements java.io.Serializable \" : \"\") + \"{\\n\");\n+        for (String access : new String[] { \"public\", \"private\" }) {\n+            sb.append(\"    \/**\\n\");\n+            sb.append(\"     * This is a \" + access + \" \" + (serializable ? \"serializable \" : \"\") + \"field.\\n\");\n+            sb.append(\"     * More description.\\n\");\n+            sb.append(\"     * \" + (serializable ? \"@serial This is the serial description.\" : \"\") + \"\\n\");\n+            sb.append(\"     * @see #publicMethod()\\n\");\n+            sb.append(\"     * @see #privateMethod()\\n\");\n+            sb.append(\"     *\/\\n\");\n+            sb.append(\"    \" + access + \" int \" + access + \"Field;\\n\");\n+        }\n+        for (String access : new String[] { \"public\", \"private\" }) {\n+            sb.append(\"    \/**\\n\");\n+            sb.append(\"     * This is a \" + access + \" method.\\n\");\n+            sb.append(\"     * More description.\\n\");\n+            sb.append(\"     * @return zero.\\n\");\n+            sb.append(\"     *\/\\n\");\n+            sb.append(\"    \" + access + \" int \" + access + \"Method() { return 0; }\\n\");\n+        }\n+        sb.append(\"    }\\n\");\n+        tb.writeJavaFiles(dir, sb.toString());\n+        return dir;\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSerializedFormWithSee\/TestSerializedFormWithSee.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"}]}