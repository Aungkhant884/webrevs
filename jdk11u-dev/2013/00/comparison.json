{"files":[{"patch":"@@ -1,1 +1,1 @@\n-## Harfbuzz v7.0.1\n+## Harfbuzz v7.2.0\n@@ -5,1 +5,1 @@\n-https:\/\/github.com\/harfbuzz\/harfbuzz\/blob\/7.0.1\/COPYING\n+https:\/\/github.com\/harfbuzz\/harfbuzz\/blob\/7.2.0\/COPYING\n@@ -13,1 +13,1 @@\n-Copyright © 2010-2022  Google, Inc.\n+Copyright © 2010-2023  Google, Inc.\n","filename":"src\/java.desktop\/share\/legal\/harfbuzz.md","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-\n@@ -245,1 +244,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -248,1 +248,5 @@\n-    if (!value.subset (c)) return_trace (false);\n+    if (!value.subset (c, instancer, varIdxBase)) return_trace (false);\n+    if (c->plan->all_axes_pinned)\n+      return_trace (true);\n+\n+    \/\/TODO: update varIdxBase for partial-instancing\n@@ -299,1 +303,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -302,1 +307,1 @@\n-    return_trace (value.subset (c));\n+    return_trace (value.subset (c, instancer, varIdxBase));\n@@ -340,1 +345,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -345,0 +352,7 @@\n+\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->stopOffset.set_float (stopOffset.to_float(instancer (varIdxBase, 0)));\n+      out->alpha.set_float (alpha.to_float (instancer (varIdxBase, 1)));\n+    }\n+\n@@ -393,1 +407,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -405,1 +420,1 @@\n-      if (!stop.subset (c)) return_trace (false);\n+      if (!stop.subset (c, instancer)) return_trace (false);\n@@ -526,0 +541,19 @@\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->xx.set_float (xx.to_float(instancer (varIdxBase, 0)));\n+      out->yx.set_float (yx.to_float(instancer (varIdxBase, 1)));\n+      out->xy.set_float (xy.to_float(instancer (varIdxBase, 2)));\n+      out->yy.set_float (yy.to_float(instancer (varIdxBase, 3)));\n+      out->dx.set_float (dx.to_float(instancer (varIdxBase, 4)));\n+      out->dy.set_float (dy.to_float(instancer (varIdxBase, 5)));\n+    }\n+    return_trace (true);\n+  }\n+\n@@ -551,1 +585,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer HB_UNUSED) const\n@@ -582,1 +617,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -587,0 +624,7 @@\n+\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+      out->alpha.set_float (alpha.to_float (instancer (varIdxBase, 0)));\n+\n+    if (format == 3 && c->plan->all_axes_pinned)\n+        out->format = 2;\n+\n@@ -621,1 +665,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -627,1 +673,14 @@\n-    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->x0 = x0 + (int) roundf (instancer (varIdxBase, 0));\n+      out->y0 = y0 + (int) roundf (instancer (varIdxBase, 1));\n+      out->x1 = x1 + (int) roundf (instancer (varIdxBase, 2));\n+      out->y1 = y1 + (int) roundf (instancer (varIdxBase, 3));\n+      out->x2 = x2 + (int) roundf (instancer (varIdxBase, 4));\n+      out->y2 = y2 + (int) roundf (instancer (varIdxBase, 5));\n+    }\n+\n+    if (format == 5 && c->plan->all_axes_pinned)\n+        out->format = 4;\n+\n+    return_trace (out->colorLine.serialize_subset (c, colorLine, this, instancer));\n@@ -672,1 +731,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -678,1 +739,14 @@\n-    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->x0 = x0 + (int) roundf (instancer (varIdxBase, 0));\n+      out->y0 = y0 + (int) roundf (instancer (varIdxBase, 1));\n+      out->radius0 = radius0 + (unsigned) roundf (instancer (varIdxBase, 2));\n+      out->x1 = x1 + (int) roundf (instancer (varIdxBase, 3));\n+      out->y1 = y1 + (int) roundf (instancer (varIdxBase, 4));\n+      out->radius1 = radius1 + (unsigned) roundf (instancer (varIdxBase, 5));\n+    }\n+\n+    if (format == 7 && c->plan->all_axes_pinned)\n+        out->format = 6;\n+\n+    return_trace (out->colorLine.serialize_subset (c, colorLine, this, instancer));\n@@ -723,1 +797,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -729,1 +805,12 @@\n-    return_trace (out->colorLine.serialize_subset (c, colorLine, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->centerX = centerX + (int) roundf (instancer (varIdxBase, 0));\n+      out->centerY = centerY + (int) roundf (instancer (varIdxBase, 1));\n+      out->startAngle.set_float (startAngle.to_float (instancer (varIdxBase, 2)));\n+      out->endAngle.set_float (endAngle.to_float (instancer (varIdxBase, 3)));\n+    }\n+\n+    if (format == 9 && c->plan->all_axes_pinned)\n+        out->format = 8;\n+\n+    return_trace (out->colorLine.serialize_subset (c, colorLine, this, instancer));\n@@ -749,2 +836,2 @@\n-                              (startAngle.to_float (c->instancer (varIdxBase, 2)) + 1) * (float) M_PI,\n-                              (endAngle.to_float   (c->instancer (varIdxBase, 3)) + 1) * (float) M_PI);\n+                              (startAngle.to_float (c->instancer (varIdxBase, 2)) + 1) * HB_PI,\n+                              (endAngle.to_float   (c->instancer (varIdxBase, 3)) + 1) * HB_PI);\n@@ -769,1 +856,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -779,1 +867,1 @@\n-    return_trace (out->paint.serialize_subset (c, paint, this));\n+    return_trace (out->paint.serialize_subset (c, paint, this, instancer));\n@@ -810,1 +898,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer HB_UNUSED) const\n@@ -839,1 +928,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -844,2 +934,4 @@\n-    if (!out->transform.serialize_copy (c->serializer, transform, this)) return_trace (false);\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (!out->transform.serialize_subset (c, transform, this, instancer)) return_trace (false);\n+    if (format == 13 && c->plan->all_axes_pinned)\n+      out->format = 12;\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -874,1 +966,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -880,1 +974,10 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->dx = dx + (int) roundf (instancer (varIdxBase, 0));\n+      out->dy = dy + (int) roundf (instancer (varIdxBase, 1));\n+    }\n+\n+    if (format == 15 && c->plan->all_axes_pinned)\n+        out->format = 14;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -911,1 +1014,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -917,1 +1022,10 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->scaleX.set_float (scaleX.to_float (instancer (varIdxBase, 0)));\n+      out->scaleY.set_float (scaleY.to_float (instancer (varIdxBase, 1)));\n+    }\n+\n+    if (format == 17 && c->plan->all_axes_pinned)\n+        out->format = 16;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -948,1 +1062,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -954,1 +1070,12 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->scaleX.set_float (scaleX.to_float (instancer (varIdxBase, 0)));\n+      out->scaleY.set_float (scaleY.to_float (instancer (varIdxBase, 1)));\n+      out->centerX = centerX + (int) roundf (instancer (varIdxBase, 2));\n+      out->centerY = centerY + (int) roundf (instancer (varIdxBase, 3));\n+    }\n+\n+    if (format == 19 && c->plan->all_axes_pinned)\n+        out->format = 18;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -993,1 +1120,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -999,1 +1128,7 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+      out->scale.set_float (scale.to_float (instancer (varIdxBase, 0)));\n+\n+    if (format == 21 && c->plan->all_axes_pinned)\n+        out->format = 20;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -1028,1 +1163,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -1034,1 +1171,11 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->scale.set_float (scale.to_float (instancer (varIdxBase, 0)));\n+      out->centerX = centerX + (int) roundf (instancer (varIdxBase, 1));\n+      out->centerY = centerY + (int) roundf (instancer (varIdxBase, 2));\n+    }\n+\n+    if (format == 23 && c->plan->all_axes_pinned)\n+        out->format = 22;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -1071,1 +1218,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -1077,1 +1226,7 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+      out->angle.set_float (angle.to_float (instancer (varIdxBase, 0)));\n+\n+    if (format == 25 && c->plan->all_axes_pinned)\n+      out->format = 24;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -1106,1 +1261,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -1112,1 +1269,11 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->angle.set_float (angle.to_float (instancer (varIdxBase, 0)));\n+      out->centerX = centerX + (int) roundf (instancer (varIdxBase, 1));\n+      out->centerY = centerY + (int) roundf (instancer (varIdxBase, 2));\n+    }\n+\n+    if (format ==27 && c->plan->all_axes_pinned)\n+        out->format = 26;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -1149,1 +1316,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -1155,1 +1324,10 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->xSkewAngle.set_float (xSkewAngle.to_float (instancer (varIdxBase, 0)));\n+      out->ySkewAngle.set_float (ySkewAngle.to_float (instancer (varIdxBase, 1)));\n+    }\n+\n+    if (format == 29 && c->plan->all_axes_pinned)\n+        out->format = 28;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -1186,1 +1364,3 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n@@ -1192,1 +1372,12 @@\n-    return_trace (out->src.serialize_subset (c, src, this));\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->xSkewAngle.set_float (xSkewAngle.to_float (instancer (varIdxBase, 0)));\n+      out->ySkewAngle.set_float (ySkewAngle.to_float (instancer (varIdxBase, 1)));\n+      out->centerX = centerX + (int) roundf (instancer (varIdxBase, 2));\n+      out->centerY = centerY + (int) roundf (instancer (varIdxBase, 3));\n+    }\n+\n+    if (format == 31 && c->plan->all_axes_pinned)\n+        out->format = 30;\n+\n+    return_trace (out->src.serialize_subset (c, src, this, instancer));\n@@ -1231,1 +1422,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -1237,2 +1429,2 @@\n-    if (!out->src.serialize_subset (c, src, this)) return_trace (false);\n-    return_trace (out->backdrop.serialize_subset (c, backdrop, this));\n+    if (!out->src.serialize_subset (c, src, this, instancer)) return_trace (false);\n+    return_trace (out->backdrop.serialize_subset (c, backdrop, this, instancer));\n@@ -1286,0 +1478,22 @@\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer,\n+               uint32_t varIdxBase) const\n+  {\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    if (instancer && !c->plan->pinned_at_default && varIdxBase != VarIdx::NO_VARIATION)\n+    {\n+      out->xMin = xMin + (int) roundf (instancer (varIdxBase, 0));\n+      out->yMin = yMin + (int) roundf (instancer (varIdxBase, 1));\n+      out->xMax = xMax + (int) roundf (instancer (varIdxBase, 2));\n+      out->yMax = yMax + (int) roundf (instancer (varIdxBase, 3));\n+    }\n+\n+    if (format == 2 && c->plan->all_axes_pinned)\n+        out->format = 1;\n+\n+    return_trace (true);\n+  }\n+\n@@ -1313,1 +1527,2 @@\n-  ClipBox* copy (hb_serialize_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -1315,1 +1530,1 @@\n-    TRACE_SERIALIZE (this);\n+    TRACE_SUBSET (this);\n@@ -1317,3 +1532,3 @@\n-    case 1: return_trace (reinterpret_cast<ClipBox *> (c->embed (u.format1)));\n-    case 2: return_trace (reinterpret_cast<ClipBox *> (c->embed (u.format2)));\n-    default:return_trace (nullptr);\n+    case 1: return_trace (u.format1.subset (c, instancer, VarIdx::NO_VARIATION));\n+    case 2: return_trace (u.format2.subset (c, instancer));\n+    default:return_trace (c->default_return_value ());\n@@ -1370,1 +1585,3 @@\n-  ClipRecord* copy (hb_serialize_context_t *c, const void *base) const\n+  bool subset (hb_subset_context_t *c,\n+               const void *base,\n+               const VarStoreInstancer &instancer) const\n@@ -1372,5 +1589,5 @@\n-    TRACE_SERIALIZE (this);\n-    auto *out = c->embed (this);\n-    if (unlikely (!out)) return_trace (nullptr);\n-    if (!out->clipBox.serialize_copy (c, clipBox, base)) return_trace (nullptr);\n-    return_trace (out);\n+    TRACE_SUBSET (this);\n+    auto *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    return_trace (out->clipBox.serialize_subset (c, clipBox, base, instancer));\n@@ -1403,1 +1620,2 @@\n-  unsigned serialize_clip_records (hb_serialize_context_t *c,\n+  unsigned serialize_clip_records (hb_subset_context_t *c,\n+                                   const VarStoreInstancer &instancer,\n@@ -1435,1 +1653,1 @@\n-      if (!c->copy (record, this)) return_trace (0);\n+      if (!record.subset (c, this, instancer)) return_trace (0);\n@@ -1449,1 +1667,1 @@\n-      if (!c->copy (record, this)) return_trace (0);\n+      if (!record.subset (c, this, instancer)) return_trace (0);\n@@ -1455,1 +1673,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -1480,1 +1699,1 @@\n-    unsigned count = serialize_clip_records (c->serializer, new_gids, new_gid_offset_map);\n+    unsigned count = serialize_clip_records (c, instancer, new_gids, new_gid_offset_map);\n@@ -1614,1 +1833,2 @@\n-                  const void* src_base, hb_subset_context_t *c) const\n+                  const void* src_base, hb_subset_context_t *c,\n+                  const VarStoreInstancer &instancer) const\n@@ -1623,1 +1843,1 @@\n-    return_trace (out->paint.serialize_subset (c, paint, src_base));\n+    return_trace (out->paint.serialize_subset (c, paint, src_base, instancer));\n@@ -1642,1 +1862,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -1654,1 +1875,1 @@\n-      if (_.serialize (c->serializer, c->plan->glyph_map, this, c)) out->len++;\n+      if (_.serialize (c->serializer, c->plan->glyph_map, this, c, instancer)) out->len++;\n@@ -1673,1 +1894,2 @@\n-  bool subset (hb_subset_context_t *c) const\n+  bool subset (hb_subset_context_t *c,\n+               const VarStoreInstancer &instancer) const\n@@ -1684,1 +1906,1 @@\n-      if (unlikely (!o) || !o->serialize_subset (c, _.second, this))\n+      if (unlikely (!o) || !o->serialize_subset (c, _.second, this, instancer))\n@@ -1886,1 +2108,0 @@\n-\n@@ -1957,1 +2178,6 @@\n-    if (!colr_prime->baseGlyphList.serialize_subset (c, baseGlyphList, this))\n+\n+    VarStoreInstancer instancer (varStore ? &(this+varStore) : nullptr,\n+                                 varIdxMap ? &(this+varIdxMap) : nullptr,\n+                                 c->plan->normalized_coords.as_array ());\n+\n+    if (!colr_prime->baseGlyphList.serialize_subset (c, baseGlyphList, this, instancer))\n@@ -1967,2 +2193,5 @@\n-    colr_prime->layerList.serialize_subset (c, layerList, this);\n-    colr_prime->clipList.serialize_subset (c, clipList, this);\n+    colr_prime->layerList.serialize_subset (c, layerList, this, instancer);\n+    colr_prime->clipList.serialize_subset (c, clipList, this, instancer);\n+    if (!varStore || c->plan->all_axes_pinned)\n+      return_trace (true);\n+\n@@ -1987,0 +2216,1 @@\n+#ifndef HB_NO_PAINT\n@@ -1993,2 +2223,2 @@\n-    VarStoreInstancer instancer (this+varStore,\n-                                 this+varIdxMap,\n+    VarStoreInstancer instancer (&(this+varStore),\n+                                 &(this+varIdxMap),\n@@ -2025,0 +2255,1 @@\n+#endif\n@@ -2048,0 +2279,1 @@\n+#ifndef HB_NO_PAINT\n@@ -2051,2 +2283,2 @@\n-    VarStoreInstancer instancer (this+varStore,\n-                                 this+varIdxMap,\n+    VarStoreInstancer instancer (&(this+varStore),\n+                                 &(this+varIdxMap),\n@@ -2063,2 +2295,2 @@\n-        VarStoreInstancer instancer (this+varStore,\n-                                     this+varIdxMap,\n+        VarStoreInstancer instancer (&(this+varStore),\n+                                     &(this+varIdxMap),\n@@ -2134,0 +2366,1 @@\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Color\/COLR\/COLR.hh","additions":310,"deletions":77,"binary":false,"changes":387,"status":"modified"},{"patch":"@@ -76,0 +76,24 @@\n+  void collect_name_ids (const void *base,\n+                         unsigned palette_count,\n+                         unsigned color_count,\n+                         const hb_map_t *color_index_map,\n+                         hb_set_t *nameids_to_retain \/* OUT *\/) const\n+  {\n+    if (paletteLabelsZ)\n+    {\n+      + (base+paletteLabelsZ).as_array (palette_count)\n+      | hb_sink (nameids_to_retain)\n+      ;\n+    }\n+\n+    if (colorLabelsZ)\n+    {\n+      const hb_array_t<const NameID> colorLabels = (base+colorLabelsZ).as_array (color_count);\n+      for (unsigned i = 0; i < color_count; i++)\n+      {\n+        if (!color_index_map->has (i)) continue;\n+        nameids_to_retain->add (colorLabels[i]);\n+      }\n+    }\n+  }\n+\n@@ -98,1 +122,1 @@\n-      for (const auto _ : colorLabels)\n+      for (unsigned i = 0; i < color_count; i++)\n@@ -100,5 +124,2 @@\n-        const hb_codepoint_t *v;\n-        if (!color_index_map->has (_, &v)) continue;\n-        NameID new_color_idx;\n-        new_color_idx = *v;\n-        if (!c->copy<NameID> (new_color_idx))\n+        if (!color_index_map->has (i)) continue;\n+        if (!c->copy<NameID> (colorLabels[i]))\n@@ -192,0 +213,7 @@\n+  void collect_name_ids (const hb_map_t *color_index_map,\n+                         hb_set_t *nameids_to_retain \/* OUT *\/) const\n+  {\n+    if (version == 1)\n+      v1 ().collect_name_ids (this, numPalettes, numColors, color_index_map, nameids_to_retain);\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Color\/CPAL\/CPAL.hh","additions":34,"deletions":6,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-    j = (unsigned) c->last_base;\n+    unsigned idx = (unsigned) c->last_base;\n@@ -132,1 +132,1 @@\n-    \/\/if (!_hb_glyph_info_is_ligature (&buffer->info[j])) { return_trace (false); }\n+    \/\/if (!_hb_glyph_info_is_ligature (&buffer->info[idx])) { return_trace (false); }\n@@ -134,1 +134,1 @@\n-    unsigned int lig_index = (this+ligatureCoverage).get_coverage  (buffer->info[j].codepoint);\n+    unsigned int lig_index = (this+ligatureCoverage).get_coverage  (buffer->info[idx].codepoint);\n@@ -137,1 +137,1 @@\n-      buffer->unsafe_to_concat_from_outbuffer (skippy_iter.idx, buffer->idx + 1);\n+      buffer->unsafe_to_concat_from_outbuffer (idx, buffer->idx + 1);\n@@ -148,1 +148,1 @@\n-      buffer->unsafe_to_concat_from_outbuffer (skippy_iter.idx, buffer->idx + 1);\n+      buffer->unsafe_to_concat_from_outbuffer (idx, buffer->idx + 1);\n@@ -157,1 +157,1 @@\n-    unsigned int lig_id = _hb_glyph_info_get_lig_id (&buffer->info[j]);\n+    unsigned int lig_id = _hb_glyph_info_get_lig_id (&buffer->info[idx]);\n@@ -165,1 +165,1 @@\n-    return_trace ((this+markArray).apply (c, mark_index, comp_index, lig_attach, classCount, j));\n+    return_trace ((this+markArray).apply (c, mark_index, comp_index, lig_attach, classCount, idx));\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/MarkLigPosFormat1.hh","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-      for (hb_codepoint_t g = HB_SET_VALUE_INVALID; glyphs->next (&g);)\n+      for (hb_codepoint_t g : glyphs->iter())\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/PairPosFormat1.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,7 @@\n+                  \/* The coverage  table may use a range to represent a set\n+                   * of glyphs, which means a small number of bytes can\n+                   * generate a large glyph set. Manually modify the\n+                   * sanitizer max ops to take this into account.\n+                   *\n+                   * Note: This check *must* be right after coverage sanitize. *\/\n+                  c->check_ops ((this + coverage).get_population () >> 1) &&\n@@ -32,0 +39,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GPOS\/SinglePosFormat1.hh","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+  bool intersects_lig_glyph (const hb_set_t *glyphs) const\n+  { return glyphs->has(ligGlyph); }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/Ligature.hh","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,12 @@\n+  bool intersects_lig_glyph (const hb_set_t *glyphs) const\n+  {\n+    return\n+    + hb_iter (ligature)\n+    | hb_map (hb_add (this))\n+    | hb_map ([glyphs] (const Ligature<Types> &_) {\n+      return _.intersects_lig_glyph (glyphs) && _.intersects (glyphs);\n+    })\n+    | hb_any\n+    ;\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/LigatureSet.hh","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-      return _.intersects (&glyphset);\n+      return _.intersects_lig_glyph (&glyphset);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/LigatureSubstFormat1.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,9 @@\n-    return_trace (coverage.sanitize (c, this) && deltaGlyphID.sanitize (c));\n+    return_trace (c->check_struct (this) &&\n+                  coverage.sanitize (c, this) &&\n+                  \/* The coverage  table may use a range to represent a set\n+                   * of glyphs, which means a small number of bytes can\n+                   * generate a large glyph set. Manually modify the\n+                   * sanitizer max ops to take this into account.\n+                   *\n+                   * Note: This check *must* be right after coverage sanitize. *\/\n+                  c->check_ops ((this + coverage).get_population () >> 1));\n@@ -90,0 +98,28 @@\n+  unsigned\n+  get_glyph_alternates (hb_codepoint_t  glyph_id,\n+                        unsigned        start_offset,\n+                        unsigned       *alternate_count  \/* IN\/OUT.  May be NULL. *\/,\n+                        hb_codepoint_t *alternate_glyphs \/* OUT.     May be NULL. *\/) const\n+  {\n+    unsigned int index = (this+coverage).get_coverage (glyph_id);\n+    if (likely (index == NOT_COVERED))\n+    {\n+      if (alternate_count)\n+        *alternate_count = 0;\n+      return 0;\n+    }\n+\n+    if (alternate_count && *alternate_count)\n+    {\n+      hb_codepoint_t d = deltaGlyphID;\n+      hb_codepoint_t mask = get_mask ();\n+\n+      glyph_id = (glyph_id + d) & mask;\n+\n+      *alternate_glyphs = glyph_id;\n+      *alternate_count = 1;\n+    }\n+\n+    return 1;\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/SingleSubstFormat1.hh","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -78,0 +78,25 @@\n+  unsigned\n+  get_glyph_alternates (hb_codepoint_t  glyph_id,\n+                        unsigned        start_offset,\n+                        unsigned       *alternate_count  \/* IN\/OUT.  May be NULL. *\/,\n+                        hb_codepoint_t *alternate_glyphs \/* OUT.     May be NULL. *\/) const\n+  {\n+    unsigned int index = (this+coverage).get_coverage (glyph_id);\n+    if (likely (index == NOT_COVERED))\n+    {\n+      if (alternate_count)\n+        *alternate_count = 0;\n+      return 0;\n+    }\n+\n+    if (alternate_count && *alternate_count)\n+    {\n+      glyph_id = substitute[index];\n+\n+      *alternate_glyphs = glyph_id;\n+      *alternate_count = 1;\n+    }\n+\n+    return 1;\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/Layout\/GSUB\/SingleSubstFormat2.hh","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -90,1 +90,3 @@\n-  void transform_points (contour_point_vector_t &points) const\n+  void transform_points (contour_point_vector_t &points,\n+                         const float (&matrix)[4],\n+                         const contour_point_t &trans) const\n@@ -92,3 +94,1 @@\n-    float matrix[4];\n-    contour_point_t trans;\n-    if (get_transformation (matrix, trans))\n+    if (scaled_offsets ())\n@@ -96,10 +96,7 @@\n-      if (scaled_offsets ())\n-      {\n-        points.translate (trans);\n-        points.transform (matrix);\n-      }\n-      else\n-      {\n-        points.transform (matrix);\n-        points.translate (trans);\n-      }\n+      points.translate (trans);\n+      points.transform (matrix);\n+    }\n+    else\n+    {\n+      points.transform (matrix);\n+      points.translate (trans);\n@@ -109,2 +106,12 @@\n-  unsigned compile_with_deltas (const contour_point_t &p_delta,\n-                                char *out) const\n+  bool get_points (contour_point_vector_t &points) const\n+  {\n+    float matrix[4];\n+    contour_point_t trans;\n+    get_transformation (matrix, trans);\n+    if (unlikely (!points.resize (points.length + 1))) return false;\n+    points[points.length - 1] = trans;\n+    return true;\n+  }\n+\n+  unsigned compile_with_point (const contour_point_t &point,\n+                               char *out) const\n@@ -124,1 +131,1 @@\n-      \/\/ no overflow, copy and update value with deltas\n+      \/\/ no overflow, copy value\n@@ -127,1 +134,0 @@\n-      const HBINT16 *px = reinterpret_cast<const HBINT16 *> (p);\n@@ -129,2 +135,2 @@\n-      o[0] = px[0] + roundf (p_delta.x);\n-      o[1] = px[1] + roundf (p_delta.y);\n+      o[0] = roundf (point.x);\n+      o[1] = roundf (point.y);\n@@ -134,2 +140,2 @@\n-      int new_x = p[0] + roundf (p_delta.x);\n-      int new_y = p[1] + roundf (p_delta.y);\n+      int new_x = roundf (point.x);\n+      int new_y = roundf (point.y);\n@@ -146,1 +152,1 @@\n-        \/\/ int8 overflows after deltas applied\n+        \/\/ new point value has an int8 overflow\n@@ -174,0 +180,1 @@\n+  public:\n@@ -228,1 +235,0 @@\n-  public:\n@@ -249,0 +255,21 @@\n+#ifndef HB_NO_BEYOND_64K\n+  void lower_gid_24_to_16 ()\n+  {\n+    hb_codepoint_t gid = get_gid ();\n+    if (!(flags & GID_IS_24BIT) || gid > 0xFFFFu)\n+      return;\n+\n+    \/* Lower the flag and move the rest of the struct down. *\/\n+\n+    unsigned size = get_size ();\n+    char *end = (char *) this + size;\n+    char *p = &StructAfter<char> (flags);\n+    p += HBGlyphID24::static_size;\n+\n+    flags = flags & ~GID_IS_24BIT;\n+    set_gid (gid);\n+\n+    memmove (p - HBGlyphID24::static_size + HBGlyphID16::static_size, p, end - p);\n+  }\n+#endif\n+\n@@ -307,1 +334,1 @@\n-                                  const contour_point_vector_t &deltas,\n+                                  const contour_point_vector_t &points_with_deltas,\n@@ -322,1 +349,1 @@\n-    char *o = (char *) hb_calloc (source_len + source_len\/2, sizeof (char));\n+    char *o = (char *) hb_calloc (source_len * 2, sizeof (char));\n@@ -332,2 +359,5 @@\n-      \/* last 4 points in deltas are phantom points and should not be included *\/\n-      if (i >= deltas.length - 4) return false;\n+      \/* last 4 points in points_with_deltas are phantom points and should not be included *\/\n+      if (i >= points_with_deltas.length - 4) {\n+        free (o);\n+        return false;\n+      }\n@@ -343,1 +373,1 @@\n-        unsigned new_len = component.compile_with_deltas (deltas[i], p);\n+        unsigned new_len = component.compile_with_point (points_with_deltas[i], p);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/CompositeGlyph.hh","additions":59,"deletions":29,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -32,1 +32,8 @@\n-  enum glyph_type_t { EMPTY, SIMPLE, COMPOSITE, VAR_COMPOSITE };\n+  enum glyph_type_t {\n+    EMPTY,\n+    SIMPLE,\n+    COMPOSITE,\n+#ifndef HB_NO_VAR_COMPOSITES\n+    VAR_COMPOSITE,\n+#endif\n+  };\n@@ -42,0 +49,1 @@\n+#ifndef HB_NO_VAR_COMPOSITES\n@@ -44,0 +52,3 @@\n+#else\n+    return var_composite_iter_t ();\n+#endif\n@@ -49,0 +60,3 @@\n+#ifndef HB_NO_VAR_COMPOSITES\n+    case VAR_COMPOSITE: return VarCompositeGlyph (*header, bytes).trim_padding ();\n+#endif\n@@ -51,0 +65,1 @@\n+    case EMPTY:     return bytes;\n@@ -58,0 +73,3 @@\n+#ifndef HB_NO_VAR_COMPOSITES\n+    case VAR_COMPOSITE: return; \/\/ No hinting\n+#endif\n@@ -60,1 +78,1 @@\n-    default:        return;\n+    case EMPTY:     return;\n@@ -67,0 +85,3 @@\n+#ifndef HB_NO_VAR_COMPOSITES\n+    case VAR_COMPOSITE: return; \/\/ No overlaps flag\n+#endif\n@@ -69,1 +90,1 @@\n-    default:        return;\n+    case EMPTY:     return;\n@@ -76,0 +97,3 @@\n+#ifndef HB_NO_VAR_COMPOSITES\n+    case VAR_COMPOSITE: return; \/\/ No hinting\n+#endif\n@@ -78,1 +102,1 @@\n-    default:        return;\n+    case EMPTY:     return;\n@@ -184,1 +208,1 @@\n-    contour_point_vector_t all_points, deltas;\n+    contour_point_vector_t all_points, points_with_deltas;\n@@ -198,1 +222,1 @@\n-    if (!get_points (font, glyf, all_points, &deltas, head_maxp_info_p, composite_contours_p, false, false))\n+    if (!get_points (font, glyf, all_points, &points_with_deltas, head_maxp_info_p, composite_contours_p, false, false))\n@@ -212,2 +236,11 @@\n-    if (!plan->pinned_at_default) {\n-      switch (type) {\n+    if (!plan->pinned_at_default)\n+    {\n+      switch (type)\n+      {\n+#ifndef HB_NO_VAR_COMPOSITES\n+      case VAR_COMPOSITE:\n+        \/\/ TODO\n+        dest_end = hb_bytes_t ();\n+        break;\n+#endif\n+\n@@ -216,1 +249,1 @@\n-                                                                        deltas,\n+                                                                        points_with_deltas,\n@@ -226,1 +259,1 @@\n-      default:\n+      case EMPTY:\n@@ -250,1 +283,1 @@\n-                   contour_point_vector_t *deltas = nullptr, \/* OUT *\/\n+                   contour_point_vector_t *points_with_deltas = nullptr, \/* OUT *\/\n@@ -290,3 +323,2 @@\n-      \/* pseudo component points for each component in composite glyph *\/\n-      unsigned num_points = hb_len (CompositeGlyph (*header, bytes).iter ());\n-      if (unlikely (!points.resize (num_points))) return false;\n+      for (auto &item : get_composite_iterator ())\n+        if (unlikely (!item.get_points (points))) return false;\n@@ -302,1 +334,1 @@\n-    default:\n+    case EMPTY:\n@@ -330,1 +362,1 @@\n-      phantoms[PHANTOM_RIGHT].x = h_adv + h_delta;\n+      phantoms[PHANTOM_RIGHT].x = (int) h_adv + h_delta;\n@@ -335,6 +367,0 @@\n-    if (deltas != nullptr && depth == 0 && type == COMPOSITE)\n-    {\n-      if (unlikely (!deltas->resize (points.length))) return false;\n-      deltas->copy_vector (points);\n-    }\n-\n@@ -349,1 +375,1 @@\n-    if (deltas != nullptr && depth == 0 && type == COMPOSITE)\n+    if (points_with_deltas != nullptr && depth == 0 && type == COMPOSITE)\n@@ -351,5 +377,2 @@\n-      for (unsigned i = 0 ; i < points.length; i++)\n-      {\n-        deltas->arrayZ[i].x = points.arrayZ[i].x - deltas->arrayZ[i].x;\n-        deltas->arrayZ[i].y = points.arrayZ[i].y - deltas->arrayZ[i].y;\n-      }\n+      if (unlikely (!points_with_deltas->resize (points.length))) return false;\n+      points_with_deltas->copy_vector (points);\n@@ -376,1 +399,1 @@\n-                                                    deltas,\n+                                                    points_with_deltas,\n@@ -392,2 +415,3 @@\n-        \/* Apply component transformation & translation *\/\n-        item.transform_points (comp_points);\n+        float matrix[4];\n+        contour_point_t default_trans;\n+        item.get_transformation (matrix, default_trans);\n@@ -395,2 +419,2 @@\n-        \/* Apply translation from gvar *\/\n-        comp_points.translate (points[comp_index]);\n+        \/* Apply component transformation & translation (with deltas applied) *\/\n+        item.transform_points (comp_points, matrix, points[comp_index]);\n@@ -436,1 +460,2 @@\n-        hb_array_t<contour_point_t> record_points = points_left.sub_array (0, item.get_num_points ());\n+        unsigned item_num_points = item.get_num_points ();\n+        hb_array_t<contour_point_t> record_points = points_left.sub_array (0, item_num_points);\n@@ -451,1 +476,1 @@\n-                                                    deltas,\n+                                                    points_with_deltas,\n@@ -475,1 +500,1 @@\n-        points_left += item.get_num_points ();\n+        points_left += item_num_points;\n@@ -480,1 +505,1 @@\n-    default:\n+    case EMPTY:\n@@ -506,0 +531,2 @@\n+  glyph_type_t get_type () const { return type; }\n+  const GlyphHeader *get_header () const { return header; }\n@@ -521,0 +548,1 @@\n+#ifndef HB_NO_VAR_COMPOSITES\n@@ -522,0 +550,1 @@\n+#endif\n@@ -529,1 +558,1 @@\n-  unsigned type;\n+  glyph_type_t type;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/Glyph.hh","additions":67,"deletions":38,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -37,0 +37,5 @@\n+  bool has_instructions_length () const\n+  {\n+    return instruction_len_offset () + 2 <= bytes.length;\n+  }\n+\n@@ -97,0 +102,1 @@\n+    if (!has_instructions_length ()) return;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/SimpleGlyph.hh","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -21,0 +21,1 @@\n+  bool allocated;\n@@ -29,1 +30,6 @@\n-    dest_glyph = hb_bytes_t (&dest_glyph, dest_glyph.length + dest_end.copy (c).length);\n+    hb_bytes_t end_copy = dest_end.copy (c);\n+    if (!end_copy.arrayZ || !dest_glyph.arrayZ) {\n+      return false;\n+    }\n+\n+    dest_glyph = hb_bytes_t (&dest_glyph, dest_glyph.length + end_copy.length);\n@@ -43,1 +49,1 @@\n-    \/* update components gids *\/\n+    \/* update components gids. *\/\n@@ -50,0 +56,55 @@\n+#ifndef HB_NO_VAR_COMPOSITES\n+    for (auto &_ : Glyph (dest_glyph).get_var_composite_iterator ())\n+    {\n+      hb_codepoint_t new_gid;\n+      if (plan->new_gid_for_old_gid (_.get_gid(), &new_gid))\n+        const_cast<VarCompositeGlyphRecord &> (_).set_gid (new_gid);\n+    }\n+#endif\n+\n+#ifndef HB_NO_BEYOND_64K\n+    auto it = Glyph (dest_glyph).get_composite_iterator ();\n+    if (it)\n+    {\n+      \/* lower GID24 to GID16 in components if possible.\n+       *\n+       * TODO: VarComposite. Not as critical, since VarComposite supports\n+       * gid24 from the first version. *\/\n+      char *p = it ? (char *) &*it : nullptr;\n+      char *q = p;\n+      const char *end = dest_glyph.arrayZ + dest_glyph.length;\n+      while (it)\n+      {\n+        auto &rec = const_cast<CompositeGlyphRecord &> (*it);\n+        ++it;\n+\n+        q += rec.get_size ();\n+\n+        rec.lower_gid_24_to_16 ();\n+\n+        unsigned size = rec.get_size ();\n+\n+        memmove (p, &rec, size);\n+\n+        p += size;\n+      }\n+      memmove (p, q, end - q);\n+      p += end - q;\n+\n+      \/* We want to shorten the glyph, but we can't do that without\n+       * updating the length in the loca table, which is already\n+       * written out :-(.  So we just fill the rest of the glyph with\n+       * harmless instructions, since that's what they will be\n+       * interpreted as.\n+       *\n+       * Should move the lowering to _populate_subset_glyphs() to\n+       * fix this issue. *\/\n+\n+      hb_memset (p, 0x7A \/* TrueType instruction ROFF; harmless *\/, end - p);\n+      p += end - p;\n+      dest_glyph = hb_bytes_t (dest_glyph.arrayZ, p - (char *) dest_glyph.arrayZ);\n+\n+      \/\/ TODO: Padding; & trim serialized bytes.\n+      \/\/ TODO: Update length in loca. Ugh.\n+    }\n+#endif\n@@ -63,1 +124,4 @@\n-  { return source_glyph.compile_bytes_with_deltas (plan, font, glyf, dest_start, dest_end); }\n+  {\n+    allocated = source_glyph.compile_bytes_with_deltas (plan, font, glyf, dest_start, dest_end);\n+    return allocated;\n+  }\n@@ -67,2 +131,5 @@\n-    dest_start.fini ();\n-    dest_end.fini ();\n+    if (likely (allocated)) {\n+      allocated = false;\n+      dest_start.fini ();\n+      dest_end.fini ();\n+    }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/SubsetGlyph.hh","additions":72,"deletions":5,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-    GID_IS_24                   = 0x1000,\n+    GID_IS_24BIT                = 0x1000,\n@@ -46,1 +46,1 @@\n-    if (flags & GID_IS_24)              size += 1;\n+    if (flags & GID_IS_24BIT)           size += 1;\n@@ -68,1 +68,1 @@\n-    if (flags & GID_IS_24)\n+    if (flags & GID_IS_24BIT)\n@@ -74,0 +74,8 @@\n+  void set_gid (hb_codepoint_t gid)\n+  {\n+    if (flags & GID_IS_24BIT)\n+      StructAfter<HBGlyphID24> (numAxes) = gid;\n+    else\n+      StructAfter<HBGlyphID16> (numAxes) = gid;\n+  }\n+\n@@ -148,1 +156,1 @@\n-    rotation = rotation * float (M_PI);\n+    rotation = rotation * HB_PI;\n@@ -159,2 +167,2 @@\n-    skewX = skewX * float (M_PI);\n-    skewY = skewY * float (M_PI);\n+    skewX = skewX * HB_PI;\n+    skewY = skewY * HB_PI;\n@@ -177,1 +185,3 @@\n-    if (unlikely (!points.resize (points.length + get_num_points ()))) return false;\n+    unsigned num_points = get_num_points ();\n+\n+    if (unlikely (!points.resize (points.length + num_points))) return false;\n@@ -183,1 +193,1 @@\n-                                          (flags & GID_IS_24 ? 3 : 2) +\n+                                          (flags & GID_IS_24BIT ? 3 : 2) +\n@@ -186,1 +196,1 @@\n-    hb_array_t<contour_point_t> rec_points = points.as_array ().sub_array (points.length - get_num_points ());\n+    hb_array_t<contour_point_t> rec_points = points.as_array ().sub_array (points.length - num_points);\n@@ -311,2 +321,2 @@\n-    const HBUINT8  *p = (const HBUINT8 *)  (((HBUINT8 *) &numAxes) + numAxes.static_size + (flags & GID_IS_24 ? 3 : 2));\n-    const HBUINT16 *q = (const HBUINT16 *) (((HBUINT8 *) &numAxes) + numAxes.static_size + (flags & GID_IS_24 ? 3 : 2));\n+    const HBUINT8  *p = (const HBUINT8 *)  (((HBUINT8 *) &numAxes) + numAxes.static_size + (flags & GID_IS_24BIT ? 3 : 2));\n+    const HBUINT16 *q = (const HBUINT16 *) (((HBUINT8 *) &numAxes) + numAxes.static_size + (flags & GID_IS_24BIT ? 3 : 2));\n@@ -347,0 +357,7 @@\n+  const hb_bytes_t trim_padding () const\n+  {\n+    unsigned length = GlyphHeader::static_size;\n+    for (auto &comp : iter ())\n+      length += comp.get_size ();\n+    return bytes.sub_array (0, length);\n+  }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/VarCompositeGlyph.hh","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -34,0 +34,6 @@\n+  static bool has_valid_glyf_format(const hb_face_t* face)\n+  {\n+    const OT::head &head = *face->table.head;\n+    return head.indexToLocFormat <= 1 && head.glyphDataFormat <= 1;\n+  }\n+\n@@ -75,0 +81,7 @@\n+    if (!has_valid_glyf_format (c->plan->source)) {\n+      \/\/ glyf format is unknown don't attempt to subset it.\n+      DEBUG_MSG (SUBSET, nullptr,\n+                 \"unkown glyf format, dropping from subset.\");\n+      return_trace (false);\n+    }\n+\n@@ -88,0 +101,2 @@\n+    {\n+      hb_font_destroy (font);\n@@ -89,0 +104,1 @@\n+    }\n@@ -92,0 +108,2 @@\n+    {\n+      hb_font_destroy (font);\n@@ -93,0 +111,1 @@\n+    }\n@@ -115,1 +134,1 @@\n-      _free_compiled_subset_glyphs (glyphs, glyphs.length - 1);\n+      _free_compiled_subset_glyphs (glyphs);\n@@ -134,1 +153,1 @@\n-  void _free_compiled_subset_glyphs (hb_vector_t<glyf_impl::SubsetGlyph> &glyphs, unsigned index) const\n+  void _free_compiled_subset_glyphs (hb_vector_t<glyf_impl::SubsetGlyph> &glyphs) const\n@@ -136,1 +155,1 @@\n-    for (unsigned i = 0; i <= index && i < glyphs.length; i++)\n+    for (unsigned i = 0; i < glyphs.length; i++)\n@@ -165,1 +184,1 @@\n-    if (head.indexToLocFormat > 1 || head.glyphDataFormat > 0)\n+    if (!glyf::has_valid_glyf_format (face))\n@@ -225,0 +244,2 @@\n+  public:\n+\n@@ -288,1 +309,0 @@\n-  public:\n@@ -330,0 +350,9 @@\n+  bool get_leading_bearing_without_var_unscaled (hb_codepoint_t gid, bool is_vertical, int *lsb) const\n+  {\n+    if (unlikely (gid >= num_glyphs)) return false;\n+    if (is_vertical) return false; \/\/ TODO Humm, what to do here?\n+\n+    *lsb = glyph_for_gid (gid).get_header ()->xMin;\n+    return true;\n+  }\n+\n@@ -408,1 +437,0 @@\n-  unsigned idx = 0;\n@@ -436,2 +464,2 @@\n-        if (!plan->pinned_at_default && idx > 0)\n-          _free_compiled_subset_glyphs (glyphs, idx - 1);\n+        if (!plan->pinned_at_default)\n+          _free_compiled_subset_glyphs (glyphs);\n@@ -440,1 +468,0 @@\n-      idx++;\n@@ -454,0 +481,2 @@\n+  {\n+    hb_font_destroy (font);\n@@ -455,0 +484,1 @@\n+  }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/glyf.hh","additions":39,"deletions":9,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-  } first_oncurve, first_offcurve, last_offcurve, last_offcurve2;\n+  } first_oncurve, first_offcurve, first_offcurve2, last_offcurve, last_offcurve2;\n@@ -35,1 +35,1 @@\n-    first_oncurve = first_offcurve = last_offcurve = last_offcurve2 = optional_point_t ();\n+    first_oncurve = first_offcurve = first_offcurve2 = last_offcurve = last_offcurve2 = optional_point_t ();\n@@ -43,1 +43,1 @@\n-     * Cubic support added (incomplete). *\/\n+     * Cubic support added. *\/\n@@ -62,1 +62,6 @@\n-        if (first_offcurve)\n+        if (is_cubic && !first_offcurve2)\n+        {\n+          first_offcurve2 = first_offcurve;\n+          first_offcurve = p;\n+        }\n+        else if (first_offcurve)\n@@ -129,3 +134,10 @@\n-        optional_point_t mid = last_offcurve.lerp (first_offcurve, .5f);\n-        draw_session->quadratic_to (last_offcurve.x, last_offcurve.y,\n-                                   mid.x, mid.y);\n+        optional_point_t mid = last_offcurve.lerp (first_offcurve2 ?\n+                                                   first_offcurve2 :\n+                                                   first_offcurve, .5f);\n+        if (last_offcurve2)\n+          draw_session->cubic_to (last_offcurve2.x, last_offcurve2.y,\n+                                  last_offcurve.x, last_offcurve.y,\n+                                  mid.x, mid.y);\n+        else\n+          draw_session->quadratic_to (last_offcurve.x, last_offcurve.y,\n+                                     mid.x, mid.y);\n@@ -133,1 +145,0 @@\n-        \/* now check the rest *\/\n@@ -135,0 +146,1 @@\n+      \/* now check the rest *\/\n@@ -137,2 +149,9 @@\n-        draw_session->quadratic_to (first_offcurve.x, first_offcurve.y,\n-                                   first_oncurve.x, first_oncurve.y);\n+      {\n+        if (first_offcurve2)\n+          draw_session->cubic_to (first_offcurve2.x, first_offcurve2.y,\n+                                  first_offcurve.x, first_offcurve.y,\n+                                  first_oncurve.x, first_oncurve.y);\n+        else\n+          draw_session->quadratic_to (first_offcurve.x, first_offcurve.y,\n+                                     first_oncurve.x, first_oncurve.y);\n+      }\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/OT\/glyf\/path-builder.hh","additions":29,"deletions":10,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+  shopt -s nullglob\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/UPDATING.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -467,1 +467,2 @@\n-  bool sanitize (hb_sanitize_context_t *c, unsigned int count) const\n+  \/\/ This does seem like it's ever called.\n+  bool sanitize (hb_sanitize_context_t *c) const\n@@ -495,1 +496,2 @@\n-  bool sanitize (hb_sanitize_context_t *c, unsigned int count \/*XXX Unused?*\/) const\n+  \/\/ This does seem like it's ever called.\n+  bool sanitize (hb_sanitize_context_t *c) const\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat-layout-common.hh","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,1 +113,0 @@\n-    ((defined(__GNUC__) && __GNUC__ >= 5) || defined(__clang__)) && \\\n@@ -115,1 +114,3 @@\n-    (__BYTE_ORDER == __LITTLE_ENDIAN || __BYTE_ORDER == __BIG_ENDIAN)\n+    (__BYTE_ORDER == __BIG_ENDIAN || \\\n+     (__BYTE_ORDER == __LITTLE_ENDIAN && \\\n+      hb_has_builtin(__builtin_bswap16)))\n@@ -158,1 +159,0 @@\n-    ((defined(__GNUC__) && __GNUC__ >= 5) || defined(__clang__)) && \\\n@@ -160,1 +160,3 @@\n-    (__BYTE_ORDER == __LITTLE_ENDIAN || __BYTE_ORDER == __BIG_ENDIAN)\n+    (__BYTE_ORDER == __BIG_ENDIAN || \\\n+     (__BYTE_ORDER == __LITTLE_ENDIAN && \\\n+      hb_has_builtin(__builtin_bswap32)))\n@@ -601,1 +603,1 @@\n-#if (defined(__GNUC__) && (__GNUC__ >= 4)) || defined(__clang__)\n+#if hb_has_builtin(__builtin_popcount)\n@@ -604,0 +606,1 @@\n+#endif\n@@ -605,0 +608,1 @@\n+#if hb_has_builtin(__builtin_popcountl)\n@@ -607,0 +611,1 @@\n+#endif\n@@ -608,0 +613,1 @@\n+#if hb_has_builtin(__builtin_popcountll)\n@@ -644,1 +650,1 @@\n-#if (defined(__GNUC__) && (__GNUC__ >= 4)) || defined(__clang__)\n+#if hb_has_builtin(__builtin_clz)\n@@ -647,0 +653,1 @@\n+#endif\n@@ -648,0 +655,1 @@\n+#if hb_has_builtin(__builtin_clzl)\n@@ -650,0 +658,1 @@\n+#endif\n@@ -651,0 +660,1 @@\n+#if hb_has_builtin(__builtin_clzll)\n@@ -718,1 +728,1 @@\n-#if (defined(__GNUC__) && (__GNUC__ >= 4)) || defined(__clang__)\n+#if hb_has_builtin(__builtin_ctz)\n@@ -721,0 +731,1 @@\n+#endif\n@@ -722,0 +733,1 @@\n+#if hb_has_builtin(__builtin_ctzl)\n@@ -724,0 +736,1 @@\n+#endif\n@@ -725,0 +738,1 @@\n+#if hb_has_builtin(__builtin_ctzll)\n@@ -878,2 +892,1 @@\n-\/* avoid with xlc16 clang on AIX; it sets the gcc macros *\/\n-#if (defined(__GNUC__) && !defined(AIX) && (__GNUC__ >= 4)) || (defined(__clang__) && (__clang_major__ >= 8))\n+#if hb_has_builtin(__builtin_mul_overflow)\n@@ -1334,0 +1347,58 @@\n+\/* Adapted from kurbo implementation with extra parameters added,\n+ * and finding for a particular range instead of 0.\n+ *\n+ * For documentation and implementation see:\n+ *\n+ * [ITP method]: https:\/\/en.wikipedia.org\/wiki\/ITP_Method\n+ * [An Enhancement of the Bisection Method Average Performance Preserving Minmax Optimality]: https:\/\/dl.acm.org\/doi\/10.1145\/3423597\n+ * https:\/\/docs.rs\/kurbo\/0.8.1\/kurbo\/common\/fn.solve_itp.html\n+ * https:\/\/github.com\/linebender\/kurbo\/blob\/fd839c25ea0c98576c7ce5789305822675a89938\/src\/common.rs#L162-L248\n+ *\/\n+template <typename func_t>\n+double solve_itp (func_t f,\n+                  double a, double b,\n+                  double epsilon,\n+                  double min_y, double max_y,\n+                  double &ya, double &yb, double &y)\n+{\n+  unsigned n1_2 = (unsigned) (hb_max (ceil (log2 ((b - a) \/ epsilon)) - 1.0, 0.0));\n+  const unsigned n0 = 1; \/\/ Hardwired\n+  const double k1 = 0.2 \/ (b - a); \/\/ Hardwired.\n+  unsigned nmax = n0 + n1_2;\n+  double scaled_epsilon = epsilon * double (1llu << nmax);\n+  double _2_epsilon = 2.0 * epsilon;\n+  while (b - a > _2_epsilon)\n+  {\n+    double x1_2 = 0.5 * (a + b);\n+    double r = scaled_epsilon - 0.5 * (b - a);\n+    double xf = (yb * a - ya * b) \/ (yb - ya);\n+    double sigma = x1_2 - xf;\n+    double b_a = b - a;\n+    \/\/ This has k2 = 2 hardwired for efficiency.\n+    double b_a_k2 = b_a * b_a;\n+    double delta = k1 * b_a_k2;\n+    int sigma_sign = sigma >= 0 ? +1 : -1;\n+    double xt = delta <= fabs (x1_2 - xf) ? xf + delta * sigma_sign : x1_2;\n+    double xitp = fabs (xt - x1_2) <= r ? xt : x1_2 - r * sigma_sign;\n+    double yitp = f (xitp);\n+    if (yitp > max_y)\n+    {\n+      b = xitp;\n+      yb = yitp;\n+    }\n+    else if (yitp < min_y)\n+    {\n+      a = xitp;\n+      ya = yitp;\n+    }\n+    else\n+    {\n+      y = yitp;\n+      return xitp;\n+    }\n+    scaled_epsilon *= 0.5;\n+  }\n+  return 0.5 * (a + b);\n+}\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-algs.hh","additions":80,"deletions":9,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+\n@@ -89,0 +90,5 @@\n+\n+  public:\n+  auto keys () const HB_AUTO_RETURN (+ forw_map.keys())\n+  auto values () const HB_AUTO_RETURN (+ forw_map.values())\n+  auto iter () const HB_AUTO_RETURN (+ forw_map.iter())\n@@ -111,0 +117,3 @@\n+  hb_codepoint_t skip (unsigned count)\n+  { return next_value += count; }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-bimap.hh","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-        if (v || page) \/* The v check is to optimize out the page check if v is true. *\/\n+        if (g != INVALID && (v || page)) \/* The v check is to optimize out the page check if v is true. *\/\n@@ -241,1 +241,1 @@\n-        if (v || page) \/* The v check is to optimize out the page check if v is true. *\/\n+        if (g != INVALID && (v || page)) \/* The v check is to optimize out the page check if v is true. *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-bit-set.hh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n- *   @HB_MEMORY_READONLY_MAY_MAKE_WRITABLE, however, using that mode\n+ *   @HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE, however, using that mode\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-blob.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,5 @@\n+ *\n+ * The input buffer is a sequence of Unicode codepoints, with\n+ * associated attributes such as direction and script.  The output\n+ * buffer is a sequence of glyphs, with associated attributes such\n+ * as position and cluster.\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-buffer.cc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,1 +33,13 @@\n-\/* Implements a lockfree cache for int->int functions. *\/\n+\/* Implements a lockfree cache for int->int functions.\n+ *\n+ * The cache is a fixed-size array of 16-bit or 32-bit integers.\n+ * The key is split into two parts: the cache index and the rest.\n+ *\n+ * The cache index is used to index into the array.  The rest is used\n+ * to store the key and the value.\n+ *\n+ * The value is stored in the least significant bits of the integer.\n+ * The key is stored in the most significant bits of the integer.\n+ * The key is shifted by cache_bits to the left to make room for the\n+ * value.\n+ *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-cache.hh","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -635,0 +635,1 @@\n+    case HB_SCRIPT_TIFINAGH:\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-common.cc","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -139,0 +139,4 @@\n+#ifdef HB_NO_DRAW\n+#define HB_NO_OUTLINE\n+#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-config.hh","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -376,0 +376,4 @@\n+#ifndef HB_DEBUG_JUSTIFY\n+#define HB_DEBUG_JUSTIFY (HB_DEBUG+0)\n+#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-debug.hh","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,0 +111,10 @@\n+\/* https:\/\/github.com\/harfbuzz\/harfbuzz\/pull\/4207 *\/\n+\/**\n+ * HB_UNICODE_COMBINING_CLASS_CCC133:\n+ *\n+ * [Tibetan]\n+ *\n+ * Deprecated: 7.2.0\n+ **\/\n+#define HB_UNICODE_COMBINING_CLASS_CCC133 133\n+\n@@ -250,0 +260,1 @@\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-deprecated.h","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -50,0 +50,6 @@\n+ *\n+ * A font face can be created from a binary blob using hb_face_create().\n+ * The face index is used to select a face from a binary blob that contains\n+ * multiple faces.  For example, a binary blob that contains both a regular\n+ * and a bold face can be used to create two font faces, one for each face\n+ * index.\n@@ -200,1 +206,1 @@\n- * and DFont that can contain more than one face.  Face indices within\n+ * DFont that can contain more than one face.  Face indices within\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-face.cc","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    blob = reference_table_func (\/*XXX*\/const_cast<hb_face_t *> (this), tag, user_data);\n+    blob = reference_table_func (\/*Oh, well.*\/const_cast<hb_face_t *> (this), tag, user_data);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-face.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,5 @@\n+ *\n+ * The default font functions are implemented in terms of the\n+ * #hb_font_funcs_t methods of the parent font object.  This allows\n+ * client programs to override only the methods they need to, and\n+ * otherwise inherit the parent font's implementation, if any.\n@@ -1390,1 +1395,1 @@\n- * @glyph: : The glyph ID\n+ * @glyph: The glyph ID\n@@ -1412,1 +1417,1 @@\n- * @glyph: : The glyph ID\n+ * @glyph: The glyph ID\n@@ -2652,0 +2657,73 @@\n+\/**\n+ * hb_font_set_variation:\n+ * @font: #hb_font_t to work upon\n+ * @tag: The #hb_tag_t tag of the variation-axis name\n+ * @value: The value of the variation axis\n+ *\n+ * Change the value of one variation axis on the font.\n+ *\n+ * Note: This function is expensive to be called repeatedly.\n+ *   If you want to set multiple variation axes at the same time,\n+ *   use hb_font_set_variations() instead.\n+ *\n+ * Since: 7.1.0\n+ *\/\n+void\n+hb_font_set_variation (hb_font_t *font,\n+                       hb_tag_t tag,\n+                       float    value)\n+{\n+  if (hb_object_is_immutable (font))\n+    return;\n+\n+  font->serial_coords = ++font->serial;\n+\n+  \/\/ TODO Share some of this code with set_variations()\n+\n+  const OT::fvar &fvar = *font->face->table.fvar;\n+  auto axes = fvar.get_axes ();\n+  const unsigned coords_length = axes.length;\n+\n+  int *normalized = coords_length ? (int *) hb_calloc (coords_length, sizeof (int)) : nullptr;\n+  float *design_coords = coords_length ? (float *) hb_calloc (coords_length, sizeof (float)) : nullptr;\n+\n+  if (unlikely (coords_length && !(normalized && design_coords)))\n+  {\n+    hb_free (normalized);\n+    hb_free (design_coords);\n+    return;\n+  }\n+\n+  \/* Initialize design coords. *\/\n+  if (font->design_coords)\n+  {\n+    assert (coords_length == font->num_coords);\n+    for (unsigned int i = 0; i < coords_length; i++)\n+      design_coords[i] = font->design_coords[i];\n+  }\n+  else\n+  {\n+    for (unsigned int i = 0; i < coords_length; i++)\n+      design_coords[i] = axes[i].get_default ();\n+    if (font->instance_index != HB_FONT_NO_VAR_NAMED_INSTANCE)\n+    {\n+      unsigned count = coords_length;\n+      \/* This may fail if index is out-of-range;\n+       * That's why we initialize design_coords from fvar above\n+       * unconditionally. *\/\n+      hb_ot_var_named_instance_get_design_coords (font->face, font->instance_index,\n+                                                  &count, design_coords);\n+    }\n+  }\n+\n+  for (unsigned axis_index = 0; axis_index < coords_length; axis_index++)\n+    if (axes[axis_index].axisTag == tag)\n+      design_coords[axis_index] = value;\n+\n+  font->face->table.avar->map_coords (normalized, coords_length);\n+\n+  hb_ot_var_normalize_coords (font->face, coords_length, design_coords, normalized);\n+  _hb_font_adopt_var_coords (font, normalized, design_coords, coords_length);\n+\n+}\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-font.cc","additions":80,"deletions":2,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -1153,0 +1153,5 @@\n+HB_EXTERN void\n+hb_font_set_variation (hb_font_t *font,\n+                       hb_tag_t tag,\n+                       float    value);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-font.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-using hb_ft_advance_cache_t = hb_cache_t<16, 8, 8, false>;\n+using hb_ft_advance_cache_t = hb_cache_t<16, 24, 8, false>;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ft.cc","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -402,1 +402,1 @@\n-  map->keys (*keys);\n+  hb_copy (map->keys() , *keys);\n@@ -418,1 +418,1 @@\n-  map->values (*values);\n+  hb_copy (map->values() , *values);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-map.cc","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -320,10 +320,0 @@\n-  void keys (hb_set_t &keys_) const\n-  {\n-    hb_copy (keys() , keys_);\n-  }\n-\n-  void values (hb_set_t &values_) const\n-  {\n-    hb_copy (values() , values_);\n-  }\n-\n@@ -356,1 +346,2 @@\n-    + keys_ref ()\n+    + iter_items ()\n+    | hb_map (&item_t::key)\n@@ -366,1 +357,2 @@\n-    + values_ref ()\n+    + iter_items ()\n+    | hb_map (&item_t::value)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-map.hh","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -407,1 +407,1 @@\n-          if (k < (&last)[distance]) return -1;\n+          if (k < (&last)[distance]\/*first*\/) return -1;\n@@ -416,1 +416,1 @@\n-                                          2,\n+                                          sizeof (CustomRange),\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-cmap-table.hh","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+HB_OT_CORE_TABLE (OT, cvar)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-face-table-list.hh","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -416,1 +416,1 @@\n-#if !defined(HB_NO_COLOR)\n+#if !defined(HB_NO_COLOR) && !defined(HB_NO_PAINT)\n@@ -636,16 +636,0 @@\n-#ifndef HB_NO_VAR\n-bool\n-_glyf_get_leading_bearing_with_var_unscaled (hb_font_t *font, hb_codepoint_t glyph, bool is_vertical,\n-                                             int *lsb)\n-{\n-  return font->face->table.glyf->get_leading_bearing_with_var_unscaled (font, glyph, is_vertical, lsb);\n-}\n-\n-unsigned\n-_glyf_get_advance_with_var_unscaled (hb_font_t *font, hb_codepoint_t glyph, bool is_vertical)\n-{\n-  return font->face->table.glyf->get_advance_with_var_unscaled (font, glyph, is_vertical);\n-}\n-#endif\n-\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-font.cc","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  DEFINE_SIZE_ARRAY (2, widthsZ);\n+  DEFINE_SIZE_UNBOUNDED (2);\n@@ -90,8 +90,0 @@\n-  const DeviceRecord& operator [] (unsigned int i) const\n-  {\n-    \/* XXX Null(DeviceRecord) is NOT safe as it's num-glyphs lengthed.\n-     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1300 *\/\n-    if (unlikely (i >= numRecords)) return Null (DeviceRecord);\n-    return StructAtOffset<DeviceRecord> (&this->firstDeviceRecord, i * sizeDeviceRecord);\n-  }\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-hdmx-table.hh","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -66,1 +66,19 @@\n-    return_trace (serialize (c->serializer));\n+    head *out = c->serializer->embed (this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    if (c->plan->normalized_coords)\n+    {\n+      if (unlikely (!c->serializer->check_assign (out->xMin, c->plan->head_maxp_info.xMin,\n+                                                  HB_SERIALIZE_ERROR_INT_OVERFLOW)))\n+        return_trace (false);\n+      if (unlikely (!c->serializer->check_assign (out->xMax, c->plan->head_maxp_info.xMax,\n+                                                  HB_SERIALIZE_ERROR_INT_OVERFLOW)))\n+        return_trace (false);\n+      if (unlikely (!c->serializer->check_assign (out->yMin, c->plan->head_maxp_info.yMin,\n+                                                  HB_SERIALIZE_ERROR_INT_OVERFLOW)))\n+        return_trace (false);\n+      if (unlikely (!c->serializer->check_assign (out->yMax, c->plan->head_maxp_info.yMax,\n+                                                  HB_SERIALIZE_ERROR_INT_OVERFLOW)))\n+        return_trace (false);\n+    }\n+    return_trace (true);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-head-table.hh","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -53,0 +53,3 @@\n+HB_INTERNAL bool\n+_glyf_get_leading_bearing_without_var_unscaled (hb_face_t *face, hb_codepoint_t gid, bool is_vertical, int *lsb);\n+\n@@ -95,1 +98,1 @@\n-    table->numberOfLongMetrics = num_hmetrics;\n+    c->serializer->check_assign (table->numberOfLongMetrics, num_hmetrics, HB_SERIALIZE_ERROR_INT_OVERFLOW);\n@@ -168,1 +171,1 @@\n-      else\n+      else if (idx < 0x10000u)\n@@ -174,0 +177,7 @@\n+      else\n+      {\n+        \/\/ TODO: This does not do tail optimization.\n+        UFWORD *adv = c->allocate_size<UFWORD> (UFWORD::static_size);\n+        if (unlikely (!adv)) return;\n+        *adv = _.first;\n+      }\n@@ -192,1 +202,1 @@\n-      num_long_metrics = plan->num_output_glyphs ();\n+      num_long_metrics = hb_min (plan->num_output_glyphs (), 0xFFFFu);\n@@ -211,1 +221,2 @@\n-                  (void) _mtx.get_leading_bearing_without_var_unscaled (old_gid, &lsb);\n+                  if (!_mtx.get_leading_bearing_without_var_unscaled (old_gid, &lsb))\n+                    (void) _glyf_get_leading_bearing_without_var_unscaled (c->plan->source, old_gid, !T::is_horizontal, &lsb);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-hmtx-table.hh","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -532,0 +532,3 @@\n+  void collect_name_ids (hb_set_t *nameids_to_retain \/* OUT *\/) const\n+  { nameids_to_retain->add (subfamilyNameID); }\n+\n@@ -588,0 +591,3 @@\n+  void collect_name_ids (hb_set_t *nameids_to_retain \/* OUT *\/) const\n+  { nameids_to_retain->add (uiNameID); }\n+\n@@ -635,0 +641,14 @@\n+  void collect_name_ids (hb_set_t *nameids_to_retain \/* OUT *\/) const\n+  {\n+    if (featUILableNameID) nameids_to_retain->add (featUILableNameID);\n+    if (featUITooltipTextNameID) nameids_to_retain->add (featUITooltipTextNameID);\n+    if (sampleTextNameID) nameids_to_retain->add (sampleTextNameID);\n+\n+    if (!firstParamUILabelNameID || !numNamedParameters || numNamedParameters >= 0x7FFF)\n+      return;\n+\n+    unsigned last_name_id = (unsigned) firstParamUILabelNameID + (unsigned) numNamedParameters - 1;\n+    if (last_name_id >= 256 && last_name_id <= 32767)\n+      nameids_to_retain->add_range (firstParamUILabelNameID, last_name_id);\n+  }\n+\n@@ -697,0 +717,13 @@\n+  void collect_name_ids (hb_tag_t tag, hb_set_t *nameids_to_retain \/* OUT *\/) const\n+  {\n+#ifdef HB_NO_LAYOUT_FEATURE_PARAMS\n+    return;\n+#endif\n+    if (tag == HB_TAG ('s','i','z','e'))\n+      return (u.size.collect_name_ids (nameids_to_retain));\n+    if ((tag & 0xFFFF0000u) == HB_TAG ('s','s','\\0','\\0')) \/* ssXX *\/\n+      return (u.stylisticSet.collect_name_ids (nameids_to_retain));\n+    if ((tag & 0xFFFF0000u) == HB_TAG ('c','v','\\0','\\0')) \/* cvXX *\/\n+      return (u.characterVariants.collect_name_ids (nameids_to_retain));\n+  }\n+\n@@ -765,0 +798,6 @@\n+  void collect_name_ids (hb_tag_t tag, hb_set_t *nameids_to_retain \/* OUT *\/) const\n+  {\n+    if (featureParams)\n+      get_feature_params ().collect_name_ids (tag, nameids_to_retain);\n+  }\n+\n@@ -2236,1 +2275,5 @@\n-    int start = startCoord.to_int (), peak = peakCoord.to_int (), end = endCoord.to_int ();\n+    int peak = peakCoord.to_int ();\n+    if (peak == 0 || coord == peak)\n+      return 1.f;\n+\n+    int start = startCoord.to_int (), end = endCoord.to_int ();\n@@ -2240,1 +2283,1 @@\n-      return 1.;\n+      return 1.f;\n@@ -2242,4 +2285,1 @@\n-      return 1.;\n-\n-    if (peak == 0 || coord == peak)\n-      return 1.;\n+      return 1.f;\n@@ -2248,1 +2288,1 @@\n-      return 0.;\n+      return 0.f;\n@@ -2465,1 +2505,1 @@\n-        for (unsigned int i = 0; i < inner_map.get_next_value (); i++)\n+        for (unsigned old_gid : inner_map.keys())\n@@ -2467,2 +2507,1 @@\n-          unsigned int old = inner_map.backward (i);\n-          int32_t delta = src->get_item_delta_fast (old, r, src_delta_bytes, src_row_size);\n+          int32_t delta = src->get_item_delta_fast (old_gid, r, src_delta_bytes, src_row_size);\n@@ -2485,1 +2524,1 @@\n-      for (unsigned int i = 0; i < inner_map.get_next_value (); i++)\n+      for (unsigned old_gid : inner_map.keys())\n@@ -2487,2 +2526,1 @@\n-        unsigned int old = inner_map.backward (i);\n-        int32_t delta = src->get_item_delta_fast (old, r, src_delta_bytes, src_row_size);\n+        int32_t delta = src->get_item_delta_fast (old_gid, r, src_delta_bytes, src_row_size);\n@@ -2549,2 +2587,2 @@\n-      for (unsigned int i = 0; i < inner_map.get_next_value (); i++)\n-        if (get_item_delta_fast (inner_map.backward (i), r, delta_bytes, row_size) != 0)\n+      for (hb_codepoint_t old_gid : inner_map.keys())\n+        if (get_item_delta_fast (old_gid, r, delta_bytes, row_size) != 0)\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-common.hh","additions":53,"deletions":15,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -490,1 +490,2 @@\n-      matcher.set_per_syllable (c->per_syllable);\n+      \/* Per syllable matching is only for GSUB. *\/\n+      matcher.set_per_syllable (c->table_index == 0 && c->per_syllable);\n@@ -4464,0 +4465,12 @@\n+  void collect_name_ids (const hb_map_t *feature_index_map,\n+                         hb_set_t *nameids_to_retain \/* OUT *\/) const\n+  {\n+    unsigned count = get_feature_count ();\n+    for (unsigned i = 0 ; i < count; i++)\n+    {\n+      if (!feature_index_map->has (i)) continue;\n+      hb_tag_t tag = get_feature_tag (i);\n+      get_feature (i).collect_name_ids (tag, nameids_to_retain);\n+    }\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout-gsubgpos.hh","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+ * See the <ulink url=\"http:\/\/www.microsoft.com\/typography\/otspec\/\">OpenType\n+ * specification<\/ulink> for details.\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-layout.cc","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    maxp_prime->numGlyphs = c->plan->num_output_glyphs ();\n+    maxp_prime->numGlyphs = hb_min (c->plan->num_output_glyphs (), 0xFFFFu);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-maxp-table.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -184,2 +184,0 @@\n-#include \"hb-ot-name-language-static.hh\"\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-name.cc","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,0 +102,4 @@\n+    bool glyph_names = c->plan->flags & HB_SUBSET_FLAGS_GLYPH_NAMES;\n+    if (!serialize (c->serializer, glyph_names))\n+      return_trace (false);\n+\n@@ -113,4 +117,0 @@\n-    bool glyph_names = c->plan->flags & HB_SUBSET_FLAGS_GLYPH_NAMES;\n-    if (!serialize (c->serializer, glyph_names))\n-      return_trace (false);\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-post-table.hh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1070,1 +1070,2 @@\n-              info[base].indic_position() = POS_BASE_C;\n+              if (base < end)\n+                info[base].indic_position() = POS_BASE_C;\n@@ -1076,0 +1077,2 @@\n+        if (base == end)\n+          break;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shaper-indic.cc","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -539,0 +539,2 @@\n+\n+    nameids_to_retain->add (elidedFallbackNameID);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-stat-table.hh","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -225,2 +225,2 @@\n-  VarStoreInstancer (const VariationStore &varStore,\n-                     const DeltaSetIndexMap &varIdxMap,\n+  VarStoreInstancer (const VariationStore *varStore,\n+                     const DeltaSetIndexMap *varIdxMap,\n@@ -230,1 +230,1 @@\n-  operator bool () const { return bool (coords); }\n+  operator bool () const { return varStore && bool (coords); }\n@@ -232,0 +232,2 @@\n+  \/* according to the spec, if colr table has varStore but does not have\n+   * varIdxMap, then an implicit identity mapping is used *\/\n@@ -233,1 +235,1 @@\n-  { return varStore.get_delta (varIdxMap.map (VarIdx::add (varIdx, offset)), coords); }\n+  { return varStore->get_delta (varIdxMap ? varIdxMap->map (VarIdx::add (varIdx, offset)) : varIdx + offset, coords); }\n@@ -235,2 +237,2 @@\n-  const VariationStore &varStore;\n-  const DeltaSetIndexMap &varIdxMap;\n+  const VariationStore *varStore;\n+  const DeltaSetIndexMap *varIdxMap;\n@@ -240,0 +242,348 @@\n+\/* https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/otvarcommonformats#tuplevariationheader *\/\n+struct TupleVariationHeader\n+{\n+  unsigned get_size (unsigned axis_count) const\n+  { return min_size + get_all_tuples (axis_count).get_size (); }\n+\n+  unsigned get_data_size () const { return varDataSize; }\n+\n+  const TupleVariationHeader &get_next (unsigned axis_count) const\n+  { return StructAtOffset<TupleVariationHeader> (this, get_size (axis_count)); }\n+\n+  float calculate_scalar (hb_array_t<int> coords, unsigned int coord_count,\n+                          const hb_array_t<const F2DOT14> shared_tuples,\n+                          const hb_vector_t<int> *shared_tuple_active_idx = nullptr) const\n+  {\n+    const F2DOT14 *peak_tuple;\n+\n+    unsigned start_idx = 0;\n+    unsigned end_idx = coord_count;\n+\n+    if (has_peak ())\n+      peak_tuple = get_peak_tuple (coord_count).arrayZ;\n+    else\n+    {\n+      unsigned int index = get_index ();\n+      if (unlikely ((index + 1) * coord_count > shared_tuples.length))\n+        return 0.f;\n+      peak_tuple = shared_tuples.sub_array (coord_count * index, coord_count).arrayZ;\n+\n+      if (shared_tuple_active_idx)\n+      {\n+        assert (index < shared_tuple_active_idx->length);\n+        int v = (*shared_tuple_active_idx).arrayZ[index];\n+        if (v != -1)\n+        {\n+          start_idx = v;\n+          end_idx = start_idx + 1;\n+        }\n+      }\n+    }\n+\n+    const F2DOT14 *start_tuple = nullptr;\n+    const F2DOT14 *end_tuple = nullptr;\n+    bool has_interm = has_intermediate ();\n+    if (has_interm)\n+    {\n+      start_tuple = get_start_tuple (coord_count).arrayZ;\n+      end_tuple = get_end_tuple (coord_count).arrayZ;\n+    }\n+\n+    float scalar = 1.f;\n+    for (unsigned int i = start_idx; i < end_idx; i++)\n+    {\n+      int peak = peak_tuple[i].to_int ();\n+      if (!peak) continue;\n+\n+      int v = coords[i];\n+      if (v == peak) continue;\n+\n+      if (has_interm)\n+      {\n+        int start = start_tuple[i].to_int ();\n+        int end = end_tuple[i].to_int ();\n+        if (unlikely (start > peak || peak > end ||\n+                      (start < 0 && end > 0 && peak))) continue;\n+        if (v < start || v > end) return 0.f;\n+        if (v < peak)\n+        { if (peak != start) scalar *= (float) (v - start) \/ (peak - start); }\n+        else\n+        { if (peak != end) scalar *= (float) (end - v) \/ (end - peak); }\n+      }\n+      else if (!v || v < hb_min (0, peak) || v > hb_max (0, peak)) return 0.f;\n+      else\n+        scalar *= (float) v \/ peak;\n+    }\n+    return scalar;\n+  }\n+\n+  bool           has_peak () const { return tupleIndex & TuppleIndex::EmbeddedPeakTuple; }\n+  bool   has_intermediate () const { return tupleIndex & TuppleIndex::IntermediateRegion; }\n+  bool has_private_points () const { return tupleIndex & TuppleIndex::PrivatePointNumbers; }\n+  unsigned      get_index () const { return tupleIndex & TuppleIndex::TupleIndexMask; }\n+\n+  protected:\n+  struct TuppleIndex : HBUINT16\n+  {\n+    enum Flags {\n+      EmbeddedPeakTuple   = 0x8000u,\n+      IntermediateRegion  = 0x4000u,\n+      PrivatePointNumbers = 0x2000u,\n+      TupleIndexMask      = 0x0FFFu\n+    };\n+\n+    DEFINE_SIZE_STATIC (2);\n+  };\n+\n+  hb_array_t<const F2DOT14> get_all_tuples (unsigned axis_count) const\n+  { return StructAfter<UnsizedArrayOf<F2DOT14>> (tupleIndex).as_array ((has_peak () + has_intermediate () * 2) * axis_count); }\n+  hb_array_t<const F2DOT14> get_peak_tuple (unsigned axis_count) const\n+  { return get_all_tuples (axis_count).sub_array (0, axis_count); }\n+  hb_array_t<const F2DOT14> get_start_tuple (unsigned axis_count) const\n+  { return get_all_tuples (axis_count).sub_array (has_peak () * axis_count, axis_count); }\n+  hb_array_t<const F2DOT14> get_end_tuple (unsigned axis_count) const\n+  { return get_all_tuples (axis_count).sub_array (has_peak () * axis_count + axis_count, axis_count); }\n+\n+  HBUINT16      varDataSize;    \/* The size in bytes of the serialized\n+                                 * data for this tuple variation table. *\/\n+  TuppleIndex   tupleIndex;     \/* A packed field. The high 4 bits are flags (see below).\n+                                   The low 12 bits are an index into a shared tuple\n+                                   records array. *\/\n+  \/* UnsizedArrayOf<F2DOT14> peakTuple - optional *\/\n+                                \/* Peak tuple record for this tuple variation table — optional,\n+                                 * determined by flags in the tupleIndex value.\n+                                 *\n+                                 * Note that this must always be included in the 'cvar' table. *\/\n+  \/* UnsizedArrayOf<F2DOT14> intermediateStartTuple - optional *\/\n+                                \/* Intermediate start tuple record for this tuple variation table — optional,\n+                                   determined by flags in the tupleIndex value. *\/\n+  \/* UnsizedArrayOf<F2DOT14> intermediateEndTuple - optional *\/\n+                                \/* Intermediate end tuple record for this tuple variation table — optional,\n+                                 * determined by flags in the tupleIndex value. *\/\n+  public:\n+  DEFINE_SIZE_MIN (4);\n+};\n+\n+struct TupleVariationData\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    \/\/ here check on min_size only, TupleVariationHeader and var data will be\n+    \/\/ checked while accessing through iterator.\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  unsigned get_size (unsigned axis_count) const\n+  {\n+    unsigned total_size = min_size;\n+    unsigned count = tupleVarCount;\n+    const TupleVariationHeader *tuple_var_header = &(get_tuple_var_header());\n+    for (unsigned i = 0; i < count; i++)\n+    {\n+      total_size += tuple_var_header->get_size (axis_count) + tuple_var_header->get_data_size ();\n+      tuple_var_header = &tuple_var_header->get_next (axis_count);\n+    }\n+\n+    return total_size;\n+  }\n+\n+  const TupleVariationHeader &get_tuple_var_header (void) const\n+  { return StructAfter<TupleVariationHeader> (data); }\n+\n+  struct tuple_iterator_t\n+  {\n+    void init (hb_bytes_t var_data_bytes_, unsigned int axis_count_, const void *table_base_)\n+    {\n+      var_data_bytes = var_data_bytes_;\n+      var_data = var_data_bytes_.as<TupleVariationData> ();\n+      index = 0;\n+      axis_count = axis_count_;\n+      current_tuple = &var_data->get_tuple_var_header ();\n+      data_offset = 0;\n+      table_base = table_base_;\n+    }\n+\n+    bool get_shared_indices (hb_vector_t<unsigned int> &shared_indices \/* OUT *\/)\n+    {\n+      if (var_data->has_shared_point_numbers ())\n+      {\n+        const HBUINT8 *base = &(table_base+var_data->data);\n+        const HBUINT8 *p = base;\n+        if (!unpack_points (p, shared_indices, (const HBUINT8 *) (var_data_bytes.arrayZ + var_data_bytes.length))) return false;\n+        data_offset = p - base;\n+      }\n+      return true;\n+    }\n+\n+    bool is_valid () const\n+    {\n+      return (index < var_data->tupleVarCount.get_count ()) &&\n+             var_data_bytes.check_range (current_tuple, TupleVariationHeader::min_size) &&\n+             var_data_bytes.check_range (current_tuple, hb_max (current_tuple->get_data_size (),\n+                                                                current_tuple->get_size (axis_count)));\n+    }\n+\n+    bool move_to_next ()\n+    {\n+      data_offset += current_tuple->get_data_size ();\n+      current_tuple = &current_tuple->get_next (axis_count);\n+      index++;\n+      return is_valid ();\n+    }\n+\n+    const HBUINT8 *get_serialized_data () const\n+    { return &(table_base+var_data->data) + data_offset; }\n+\n+    private:\n+    const TupleVariationData *var_data;\n+    unsigned int index;\n+    unsigned int axis_count;\n+    unsigned int data_offset;\n+    const void *table_base;\n+\n+    public:\n+    hb_bytes_t var_data_bytes;\n+    const TupleVariationHeader *current_tuple;\n+  };\n+\n+  static bool get_tuple_iterator (hb_bytes_t var_data_bytes, unsigned axis_count,\n+                                  const void *table_base,\n+                                  hb_vector_t<unsigned int> &shared_indices \/* OUT *\/,\n+                                  tuple_iterator_t *iterator \/* OUT *\/)\n+  {\n+    iterator->init (var_data_bytes, axis_count, table_base);\n+    if (!iterator->get_shared_indices (shared_indices))\n+      return false;\n+    return iterator->is_valid ();\n+  }\n+\n+  bool has_shared_point_numbers () const { return tupleVarCount.has_shared_point_numbers (); }\n+\n+  static bool unpack_points (const HBUINT8 *&p \/* IN\/OUT *\/,\n+                             hb_vector_t<unsigned int> &points \/* OUT *\/,\n+                             const HBUINT8 *end)\n+  {\n+    enum packed_point_flag_t\n+    {\n+      POINTS_ARE_WORDS     = 0x80,\n+      POINT_RUN_COUNT_MASK = 0x7F\n+    };\n+\n+    if (unlikely (p + 1 > end)) return false;\n+\n+    unsigned count = *p++;\n+    if (count & POINTS_ARE_WORDS)\n+    {\n+      if (unlikely (p + 1 > end)) return false;\n+      count = ((count & POINT_RUN_COUNT_MASK) << 8) | *p++;\n+    }\n+    if (unlikely (!points.resize (count, false))) return false;\n+\n+    unsigned n = 0;\n+    unsigned i = 0;\n+    while (i < count)\n+    {\n+      if (unlikely (p + 1 > end)) return false;\n+      unsigned control = *p++;\n+      unsigned run_count = (control & POINT_RUN_COUNT_MASK) + 1;\n+      unsigned stop = i + run_count;\n+      if (unlikely (stop > count)) return false;\n+      if (control & POINTS_ARE_WORDS)\n+      {\n+        if (unlikely (p + run_count * HBUINT16::static_size > end)) return false;\n+        for (; i < stop; i++)\n+        {\n+          n += *(const HBUINT16 *)p;\n+          points.arrayZ[i] = n;\n+          p += HBUINT16::static_size;\n+        }\n+      }\n+      else\n+      {\n+        if (unlikely (p + run_count > end)) return false;\n+        for (; i < stop; i++)\n+        {\n+          n += *p++;\n+          points.arrayZ[i] = n;\n+        }\n+      }\n+    }\n+    return true;\n+  }\n+\n+  static bool unpack_deltas (const HBUINT8 *&p \/* IN\/OUT *\/,\n+                             hb_vector_t<int> &deltas \/* IN\/OUT *\/,\n+                             const HBUINT8 *end)\n+  {\n+    enum packed_delta_flag_t\n+    {\n+      DELTAS_ARE_ZERO      = 0x80,\n+      DELTAS_ARE_WORDS     = 0x40,\n+      DELTA_RUN_COUNT_MASK = 0x3F\n+    };\n+\n+    unsigned i = 0;\n+    unsigned count = deltas.length;\n+    while (i < count)\n+    {\n+      if (unlikely (p + 1 > end)) return false;\n+      unsigned control = *p++;\n+      unsigned run_count = (control & DELTA_RUN_COUNT_MASK) + 1;\n+      unsigned stop = i + run_count;\n+      if (unlikely (stop > count)) return false;\n+      if (control & DELTAS_ARE_ZERO)\n+      {\n+        for (; i < stop; i++)\n+          deltas.arrayZ[i] = 0;\n+      }\n+      else if (control & DELTAS_ARE_WORDS)\n+      {\n+        if (unlikely (p + run_count * HBUINT16::static_size > end)) return false;\n+        for (; i < stop; i++)\n+        {\n+          deltas.arrayZ[i] = * (const HBINT16 *) p;\n+          p += HBUINT16::static_size;\n+        }\n+      }\n+      else\n+      {\n+        if (unlikely (p + run_count > end)) return false;\n+        for (; i < stop; i++)\n+        {\n+          deltas.arrayZ[i] = * (const HBINT8 *) p++;\n+        }\n+      }\n+    }\n+    return true;\n+  }\n+\n+  bool has_data () const { return tupleVarCount; }\n+\n+  protected:\n+  struct TupleVarCount : HBUINT16\n+  {\n+    bool has_shared_point_numbers () const { return ((*this) & SharedPointNumbers); }\n+    unsigned int get_count () const { return (*this) & CountMask; }\n+\n+    protected:\n+    enum Flags\n+    {\n+      SharedPointNumbers= 0x8000u,\n+      CountMask         = 0x0FFFu\n+    };\n+    public:\n+    DEFINE_SIZE_STATIC (2);\n+  };\n+\n+  TupleVarCount tupleVarCount;  \/* A packed field. The high 4 bits are flags, and the\n+                                 * low 12 bits are the number of tuple variation tables\n+                                 * for this glyph. The number of tuple variation tables\n+                                 * can be any number between 1 and 4095. *\/\n+  Offset16To<HBUINT8>\n+                data;           \/* Offset from the start of the base table\n+                                 * to the serialized data. *\/\n+  \/* TupleVariationHeader tupleVariationHeaders[] *\/\/* Array of tuple variation headers. *\/\n+  public:\n+  DEFINE_SIZE_MIN (4);\n+};\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-common.hh","additions":356,"deletions":6,"binary":false,"changes":362,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright © 2023  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ *\/\n+\n+#ifndef HB_OT_VAR_CVAR_TABLE_HH\n+#define HB_OT_VAR_CVAR_TABLE_HH\n+\n+#include \"hb-ot-var-common.hh\"\n+\n+\n+namespace OT {\n+\/*\n+ * cvar -- control value table (CVT) Variations\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/cvar\n+ *\/\n+#define HB_OT_TAG_cvar HB_TAG('c','v','a','r')\n+\n+struct cvar\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_cvar;\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  version.sanitize (c) && likely (version.major == 1) &&\n+                  tupleVariationData.sanitize (c));\n+  }\n+\n+  const TupleVariationData* get_tuple_var_data (void) const\n+  { return &tupleVariationData; }\n+\n+  static bool calculate_cvt_deltas (unsigned axis_count,\n+                                    hb_array_t<int> coords,\n+                                    unsigned num_cvt_item,\n+                                    const TupleVariationData *tuple_var_data,\n+                                    const void *base,\n+                                    hb_vector_t<float>& cvt_deltas \/* OUT *\/)\n+  {\n+    if (!coords) return true;\n+    hb_vector_t<unsigned> shared_indices;\n+    TupleVariationData::tuple_iterator_t iterator;\n+    unsigned var_data_length = tuple_var_data->get_size (axis_count);\n+    hb_bytes_t var_data_bytes = hb_bytes_t (reinterpret_cast<const char*> (tuple_var_data), var_data_length);\n+    if (!TupleVariationData::get_tuple_iterator (var_data_bytes, axis_count, base,\n+                                                 shared_indices, &iterator))\n+      return true; \/* isn't applied at all *\/\n+\n+    hb_array_t<const F2DOT14> shared_tuples = hb_array<F2DOT14> ();\n+    hb_vector_t<unsigned> private_indices;\n+    hb_vector_t<int> unpacked_deltas;\n+\n+    do\n+    {\n+      float scalar = iterator.current_tuple->calculate_scalar (coords, axis_count, shared_tuples);\n+      if (scalar == 0.f) continue;\n+      const HBUINT8 *p = iterator.get_serialized_data ();\n+      unsigned int length = iterator.current_tuple->get_data_size ();\n+      if (unlikely (!iterator.var_data_bytes.check_range (p, length)))\n+        return false;\n+\n+      const HBUINT8 *end = p + length;\n+\n+      bool has_private_points = iterator.current_tuple->has_private_points ();\n+      if (has_private_points &&\n+          !TupleVariationData::unpack_points (p, private_indices, end))\n+        return false;\n+      const hb_vector_t<unsigned int> &indices = has_private_points ? private_indices : shared_indices;\n+\n+      bool apply_to_all = (indices.length == 0);\n+      unsigned num_deltas = apply_to_all ? num_cvt_item : indices.length;\n+      if (unlikely (!unpacked_deltas.resize (num_deltas, false))) return false;\n+      if (unlikely (!TupleVariationData::unpack_deltas (p, unpacked_deltas, end))) return false;\n+\n+      for (unsigned int i = 0; i < num_deltas; i++)\n+      {\n+        unsigned int idx = apply_to_all ? i : indices[i];\n+        if (unlikely (idx >= num_cvt_item)) continue;\n+        if (scalar != 1.0f) cvt_deltas[idx] += unpacked_deltas[i] * scalar ;\n+        else cvt_deltas[idx] += unpacked_deltas[i];\n+      }\n+    } while (iterator.move_to_next ());\n+\n+    return true;\n+  }\n+\n+  static bool add_cvt_and_apply_deltas (hb_subset_plan_t *plan,\n+                                        const TupleVariationData *tuple_var_data,\n+                                        const void *base)\n+  {\n+    const hb_tag_t cvt = HB_TAG('c','v','t',' ');\n+    hb_blob_t *cvt_blob = hb_face_reference_table (plan->source, cvt);\n+    hb_blob_t *cvt_prime_blob = hb_blob_copy_writable_or_fail (cvt_blob);\n+    hb_blob_destroy (cvt_blob);\n+\n+    if (unlikely (!cvt_prime_blob))\n+      return false;\n+\n+    unsigned cvt_blob_length = hb_blob_get_length (cvt_prime_blob);\n+    unsigned num_cvt_item = cvt_blob_length \/ FWORD::static_size;\n+\n+    hb_vector_t<float> cvt_deltas;\n+    if (unlikely (!cvt_deltas.resize (num_cvt_item)))\n+    {\n+      hb_blob_destroy (cvt_prime_blob);\n+      return false;\n+    }\n+    hb_memset (cvt_deltas.arrayZ, 0, cvt_deltas.get_size ());\n+\n+    if (!calculate_cvt_deltas (plan->normalized_coords.length, plan->normalized_coords.as_array (),\n+                               num_cvt_item, tuple_var_data, base, cvt_deltas))\n+    {\n+      hb_blob_destroy (cvt_prime_blob);\n+      return false;\n+    }\n+\n+    FWORD *cvt_prime = (FWORD *) hb_blob_get_data_writable (cvt_prime_blob, nullptr);\n+    for (unsigned i = 0; i < num_cvt_item; i++)\n+      cvt_prime[i] += (int) roundf (cvt_deltas[i]);\n+\n+    bool success = plan->add_table (cvt, cvt_prime_blob);\n+    hb_blob_destroy (cvt_prime_blob);\n+    return success;\n+  }\n+\n+  protected:\n+  FixedVersion<>version;                \/* Version of the CVT variation table\n+                                         * initially set to 0x00010000u *\/\n+  TupleVariationData tupleVariationData; \/* TupleVariationDate for cvar table *\/\n+  public:\n+  DEFINE_SIZE_MIN (8);\n+};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_VAR_CVAR_TABLE_HH *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-cvar-table.hh","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"hb-ot-var-common.hh\"\n@@ -93,305 +94,2 @@\n-\/* https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/otvarcommonformats#tuplevariationheader *\/\n-struct TupleVariationHeader\n-{\n-  unsigned get_size (unsigned axis_count) const\n-  { return min_size + get_all_tuples (axis_count).get_size (); }\n-\n-  unsigned get_data_size () const { return varDataSize; }\n-\n-  const TupleVariationHeader &get_next (unsigned axis_count) const\n-  { return StructAtOffset<TupleVariationHeader> (this, get_size (axis_count)); }\n-\n-  float calculate_scalar (hb_array_t<int> coords, unsigned int coord_count,\n-                          const hb_array_t<const F2DOT14> shared_tuples) const\n-  {\n-    hb_array_t<const F2DOT14> peak_tuple;\n-\n-    if (has_peak ())\n-      peak_tuple = get_peak_tuple (coord_count);\n-    else\n-    {\n-      unsigned int index = get_index ();\n-      if (unlikely (index * coord_count >= shared_tuples.length))\n-        return 0.f;\n-      peak_tuple = shared_tuples.sub_array (coord_count * index, coord_count);\n-    }\n-\n-    hb_array_t<const F2DOT14> start_tuple;\n-    hb_array_t<const F2DOT14> end_tuple;\n-    if (has_intermediate ())\n-    {\n-      start_tuple = get_start_tuple (coord_count);\n-      end_tuple = get_end_tuple (coord_count);\n-    }\n-\n-    float scalar = 1.f;\n-    for (unsigned int i = 0; i < coord_count; i++)\n-    {\n-      int v = coords[i];\n-      int peak = peak_tuple[i].to_int ();\n-      if (!peak || v == peak) continue;\n-\n-      if (has_intermediate ())\n-      {\n-        int start = start_tuple[i].to_int ();\n-        int end = end_tuple[i].to_int ();\n-        if (unlikely (start > peak || peak > end ||\n-                      (start < 0 && end > 0 && peak))) continue;\n-        if (v < start || v > end) return 0.f;\n-        if (v < peak)\n-        { if (peak != start) scalar *= (float) (v - start) \/ (peak - start); }\n-        else\n-        { if (peak != end) scalar *= (float) (end - v) \/ (end - peak); }\n-      }\n-      else if (!v || v < hb_min (0, peak) || v > hb_max (0, peak)) return 0.f;\n-      else\n-        scalar *= (float) v \/ peak;\n-    }\n-    return scalar;\n-  }\n-\n-  bool           has_peak () const { return tupleIndex & TuppleIndex::EmbeddedPeakTuple; }\n-  bool   has_intermediate () const { return tupleIndex & TuppleIndex::IntermediateRegion; }\n-  bool has_private_points () const { return tupleIndex & TuppleIndex::PrivatePointNumbers; }\n-  unsigned      get_index () const { return tupleIndex & TuppleIndex::TupleIndexMask; }\n-\n-  protected:\n-  struct TuppleIndex : HBUINT16\n-  {\n-    enum Flags {\n-      EmbeddedPeakTuple   = 0x8000u,\n-      IntermediateRegion  = 0x4000u,\n-      PrivatePointNumbers = 0x2000u,\n-      TupleIndexMask      = 0x0FFFu\n-    };\n-\n-    DEFINE_SIZE_STATIC (2);\n-  };\n-\n-  hb_array_t<const F2DOT14> get_all_tuples (unsigned axis_count) const\n-  { return StructAfter<UnsizedArrayOf<F2DOT14>> (tupleIndex).as_array ((has_peak () + has_intermediate () * 2) * axis_count); }\n-  hb_array_t<const F2DOT14> get_peak_tuple (unsigned axis_count) const\n-  { return get_all_tuples (axis_count).sub_array (0, axis_count); }\n-  hb_array_t<const F2DOT14> get_start_tuple (unsigned axis_count) const\n-  { return get_all_tuples (axis_count).sub_array (has_peak () * axis_count, axis_count); }\n-  hb_array_t<const F2DOT14> get_end_tuple (unsigned axis_count) const\n-  { return get_all_tuples (axis_count).sub_array (has_peak () * axis_count + axis_count, axis_count); }\n-\n-  HBUINT16      varDataSize;    \/* The size in bytes of the serialized\n-                                 * data for this tuple variation table. *\/\n-  TuppleIndex   tupleIndex;     \/* A packed field. The high 4 bits are flags (see below).\n-                                   The low 12 bits are an index into a shared tuple\n-                                   records array. *\/\n-  \/* UnsizedArrayOf<F2DOT14> peakTuple - optional *\/\n-                                \/* Peak tuple record for this tuple variation table — optional,\n-                                 * determined by flags in the tupleIndex value.\n-                                 *\n-                                 * Note that this must always be included in the 'cvar' table. *\/\n-  \/* UnsizedArrayOf<F2DOT14> intermediateStartTuple - optional *\/\n-                                \/* Intermediate start tuple record for this tuple variation table — optional,\n-                                   determined by flags in the tupleIndex value. *\/\n-  \/* UnsizedArrayOf<F2DOT14> intermediateEndTuple - optional *\/\n-                                \/* Intermediate end tuple record for this tuple variation table — optional,\n-                                 * determined by flags in the tupleIndex value. *\/\n-  public:\n-  DEFINE_SIZE_MIN (4);\n-};\n-\n-struct GlyphVariationData\n-{\n-  const TupleVariationHeader &get_tuple_var_header (void) const\n-  { return StructAfter<TupleVariationHeader> (data); }\n-\n-  struct tuple_iterator_t\n-  {\n-    void init (hb_bytes_t var_data_bytes_, unsigned int axis_count_)\n-    {\n-      var_data_bytes = var_data_bytes_;\n-      var_data = var_data_bytes_.as<GlyphVariationData> ();\n-      index = 0;\n-      axis_count = axis_count_;\n-      current_tuple = &var_data->get_tuple_var_header ();\n-      data_offset = 0;\n-    }\n-\n-    bool get_shared_indices (hb_vector_t<unsigned int> &shared_indices \/* OUT *\/)\n-    {\n-      if (var_data->has_shared_point_numbers ())\n-      {\n-        const HBUINT8 *base = &(var_data+var_data->data);\n-        const HBUINT8 *p = base;\n-        if (!unpack_points (p, shared_indices, (const HBUINT8 *) (var_data_bytes.arrayZ + var_data_bytes.length))) return false;\n-        data_offset = p - base;\n-      }\n-      return true;\n-    }\n-\n-    bool is_valid () const\n-    {\n-      return (index < var_data->tupleVarCount.get_count ()) &&\n-             var_data_bytes.check_range (current_tuple, TupleVariationHeader::min_size) &&\n-             var_data_bytes.check_range (current_tuple, hb_max (current_tuple->get_data_size (),\n-                                                                current_tuple->get_size (axis_count)));\n-    }\n-\n-    bool move_to_next ()\n-    {\n-      data_offset += current_tuple->get_data_size ();\n-      current_tuple = &current_tuple->get_next (axis_count);\n-      index++;\n-      return is_valid ();\n-    }\n-\n-    const HBUINT8 *get_serialized_data () const\n-    { return &(var_data+var_data->data) + data_offset; }\n-\n-    private:\n-    const GlyphVariationData *var_data;\n-    unsigned int index;\n-    unsigned int axis_count;\n-    unsigned int data_offset;\n-\n-    public:\n-    hb_bytes_t var_data_bytes;\n-    const TupleVariationHeader *current_tuple;\n-  };\n-\n-  static bool get_tuple_iterator (hb_bytes_t var_data_bytes, unsigned axis_count,\n-                                  hb_vector_t<unsigned int> &shared_indices \/* OUT *\/,\n-                                  tuple_iterator_t *iterator \/* OUT *\/)\n-  {\n-    iterator->init (var_data_bytes, axis_count);\n-    if (!iterator->get_shared_indices (shared_indices))\n-      return false;\n-    return iterator->is_valid ();\n-  }\n-\n-  bool has_shared_point_numbers () const { return tupleVarCount.has_shared_point_numbers (); }\n-\n-  static bool unpack_points (const HBUINT8 *&p \/* IN\/OUT *\/,\n-                             hb_vector_t<unsigned int> &points \/* OUT *\/,\n-                             const HBUINT8 *end)\n-  {\n-    enum packed_point_flag_t\n-    {\n-      POINTS_ARE_WORDS     = 0x80,\n-      POINT_RUN_COUNT_MASK = 0x7F\n-    };\n-\n-    if (unlikely (p + 1 > end)) return false;\n-\n-    unsigned count = *p++;\n-    if (count & POINTS_ARE_WORDS)\n-    {\n-      if (unlikely (p + 1 > end)) return false;\n-      count = ((count & POINT_RUN_COUNT_MASK) << 8) | *p++;\n-    }\n-    if (unlikely (!points.resize (count, false))) return false;\n-\n-    unsigned n = 0;\n-    unsigned i = 0;\n-    while (i < count)\n-    {\n-      if (unlikely (p + 1 > end)) return false;\n-      unsigned control = *p++;\n-      unsigned run_count = (control & POINT_RUN_COUNT_MASK) + 1;\n-      if (unlikely (i + run_count > count)) return false;\n-      unsigned j;\n-      if (control & POINTS_ARE_WORDS)\n-      {\n-        if (unlikely (p + run_count * HBUINT16::static_size > end)) return false;\n-        for (j = 0; j < run_count; j++, i++)\n-        {\n-          n += *(const HBUINT16 *)p;\n-          points.arrayZ[i] = n;\n-          p += HBUINT16::static_size;\n-        }\n-      }\n-      else\n-      {\n-        if (unlikely (p + run_count > end)) return false;\n-        for (j = 0; j < run_count; j++, i++)\n-        {\n-          n += *p++;\n-          points.arrayZ[i] = n;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-\n-  static bool unpack_deltas (const HBUINT8 *&p \/* IN\/OUT *\/,\n-                             hb_vector_t<int> &deltas \/* IN\/OUT *\/,\n-                             const HBUINT8 *end)\n-  {\n-    enum packed_delta_flag_t\n-    {\n-      DELTAS_ARE_ZERO      = 0x80,\n-      DELTAS_ARE_WORDS     = 0x40,\n-      DELTA_RUN_COUNT_MASK = 0x3F\n-    };\n-\n-    unsigned i = 0;\n-    unsigned count = deltas.length;\n-    while (i < count)\n-    {\n-      if (unlikely (p + 1 > end)) return false;\n-      unsigned control = *p++;\n-      unsigned run_count = (control & DELTA_RUN_COUNT_MASK) + 1;\n-      if (unlikely (i + run_count > count)) return false;\n-      unsigned j;\n-      if (control & DELTAS_ARE_ZERO)\n-      {\n-        for (j = 0; j < run_count; j++, i++)\n-          deltas.arrayZ[i] = 0;\n-      }\n-      else if (control & DELTAS_ARE_WORDS)\n-      {\n-        if (unlikely (p + run_count * HBUINT16::static_size > end)) return false;\n-        for (j = 0; j < run_count; j++, i++)\n-        {\n-          deltas.arrayZ[i] = * (const HBINT16 *) p;\n-          p += HBUINT16::static_size;\n-        }\n-      }\n-      else\n-      {\n-        if (unlikely (p + run_count > end)) return false;\n-        for (j = 0; j < run_count; j++, i++)\n-        {\n-          deltas.arrayZ[i] = * (const HBINT8 *) p++;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-\n-  bool has_data () const { return tupleVarCount; }\n-\n-  protected:\n-  struct TupleVarCount : HBUINT16\n-  {\n-    bool has_shared_point_numbers () const { return ((*this) & SharedPointNumbers); }\n-    unsigned int get_count () const { return (*this) & CountMask; }\n-\n-    protected:\n-    enum Flags\n-    {\n-      SharedPointNumbers= 0x8000u,\n-      CountMask         = 0x0FFFu\n-    };\n-    public:\n-    DEFINE_SIZE_STATIC (2);\n-  };\n-\n-  TupleVarCount tupleVarCount;  \/* A packed field. The high 4 bits are flags, and the\n-                                 * low 12 bits are the number of tuple variation tables\n-                                 * for this glyph. The number of tuple variation tables\n-                                 * can be any number between 1 and 4095. *\/\n-  Offset16To<HBUINT8>\n-                data;           \/* Offset from the start of the GlyphVariationData table\n-                                 * to the serialized data. *\/\n-  \/* TupleVariationHeader tupleVariationHeaders[] *\/\/* Array of tuple variation headers. *\/\n-  public:\n-  DEFINE_SIZE_MIN (4);\n-};\n+struct GlyphVariationData : TupleVariationData\n+{};\n@@ -409,2 +107,2 @@\n-                     c->check_array (get_long_offset_array (), glyphCount+1) :\n-                     c->check_array (get_short_offset_array (), glyphCount+1)));\n+                     c->check_array (get_long_offset_array (), c->get_num_glyphs () + 1) :\n+                     c->check_array (get_short_offset_array (), c->get_num_glyphs () + 1)));\n@@ -421,0 +119,2 @@\n+    unsigned glyph_count = version.to_int () ? c->plan->source->get_num_glyphs () : 0;\n+\n@@ -430,1 +130,1 @@\n-    out->glyphCount = num_glyphs;\n+    out->glyphCountX = hb_min (0xFFFFu, num_glyphs);\n@@ -439,1 +139,1 @@\n-      subset_data_size += get_glyph_var_data_bytes (c->source_blob, old_gid).length;\n+      subset_data_size += get_glyph_var_data_bytes (c->source_blob, glyph_count, old_gid).length;\n@@ -471,1 +171,3 @@\n-                                ? get_glyph_var_data_bytes (c->source_blob, old_gid)\n+                                ? get_glyph_var_data_bytes (c->source_blob,\n+                                                            glyph_count,\n+                                                            old_gid)\n@@ -493,1 +195,3 @@\n-  const hb_bytes_t get_glyph_var_data_bytes (hb_blob_t *blob, hb_codepoint_t glyph) const\n+  const hb_bytes_t get_glyph_var_data_bytes (hb_blob_t *blob,\n+                                             unsigned glyph_count,\n+                                             hb_codepoint_t glyph) const\n@@ -495,2 +199,2 @@\n-    unsigned start_offset = get_offset (glyph);\n-    unsigned end_offset = get_offset (glyph+1);\n+    unsigned start_offset = get_offset (glyph_count, glyph);\n+    unsigned end_offset = get_offset (glyph_count, glyph+1);\n@@ -505,1 +209,1 @@\n-  unsigned get_offset (unsigned i) const\n+  unsigned get_offset (unsigned glyph_count, unsigned i) const\n@@ -507,1 +211,1 @@\n-    if (unlikely (i > glyphCount)) return 0;\n+    if (unlikely (i > glyph_count)) return 0;\n@@ -519,1 +223,32 @@\n-    { table = hb_sanitize_context_t ().reference_table<gvar> (face); }\n+    {\n+      table = hb_sanitize_context_t ().reference_table<gvar> (face);\n+      \/* If sanitize failed, set glyphCount to 0. *\/\n+      glyphCount = table->version.to_int () ? face->get_num_glyphs () : 0;\n+\n+      \/* For shared tuples that only have one axis active, shared the index of\n+       * that axis as a cache. This will speed up caclulate_scalar() a lot\n+       * for fonts with lots of axes and many \"monovar\" tuples. *\/\n+      hb_array_t<const F2DOT14> shared_tuples = (table+table->sharedTuples).as_array (table->sharedTupleCount * table->axisCount);\n+      unsigned count = table->sharedTupleCount;\n+      if (unlikely (!shared_tuple_active_idx.resize (count, false))) return;\n+      unsigned axis_count = table->axisCount;\n+      for (unsigned i = 0; i < count; i++)\n+      {\n+        hb_array_t<const F2DOT14> tuple = shared_tuples.sub_array (axis_count * i, axis_count);\n+        int idx = -1;\n+        for (unsigned j = 0; j < axis_count; j++)\n+        {\n+          F2DOT14 peak = tuple.arrayZ[j];\n+          if (peak.to_int () != 0)\n+          {\n+            if (idx != -1)\n+            {\n+              idx = -1;\n+              break;\n+            }\n+            idx = j;\n+          }\n+        }\n+        shared_tuple_active_idx[i] = idx;\n+      }\n+    }\n@@ -557,1 +292,1 @@\n-      if (unlikely (glyph >= table->glyphCount)) return true;\n+      if (unlikely (glyph >= glyphCount)) return true;\n@@ -559,1 +294,1 @@\n-      hb_bytes_t var_data_bytes = table->get_glyph_var_data_bytes (table.get_blob (), glyph);\n+      hb_bytes_t var_data_bytes = table->get_glyph_var_data_bytes (table.get_blob (), glyphCount, glyph);\n@@ -564,0 +299,1 @@\n+                                                   var_data_bytes.arrayZ,\n@@ -568,3 +304,1 @@\n-      contour_point_vector_t orig_points_vec;\n-      orig_points_vec.extend (points);\n-      if (unlikely (orig_points_vec.in_error ())) return false;\n+      contour_point_vector_t orig_points_vec; \/\/ Populated lazily\n@@ -573,2 +307,2 @@\n-      contour_point_vector_t deltas_vec; \/* flag is used to indicate referenced point *\/\n-      if (unlikely (!deltas_vec.resize (points.length, false))) return false;\n+      \/* flag is used to indicate referenced point *\/\n+      contour_point_vector_t deltas_vec; \/\/ Populated lazily\n@@ -577,4 +311,1 @@\n-      hb_vector_t<unsigned> end_points;\n-      for (unsigned i = 0; i < points.length; ++i)\n-        if (points.arrayZ[i].is_end_point)\n-          end_points.push (i);\n+      hb_vector_t<unsigned> end_points; \/\/ Populated lazily\n@@ -588,0 +319,1 @@\n+      bool flush = false;\n@@ -590,1 +322,2 @@\n-        float scalar = iterator.current_tuple->calculate_scalar (coords, num_coords, shared_tuples);\n+        float scalar = iterator.current_tuple->calculate_scalar (coords, num_coords, shared_tuples,\n+                                                                 shared_tuple_active_idx.in_error () ? nullptr : &shared_tuple_active_idx);\n@@ -597,0 +330,6 @@\n+        if (!deltas)\n+        {\n+          if (unlikely (!deltas_vec.resize (points.length))) return false;\n+          deltas = deltas_vec.as_array ();\n+        }\n+\n@@ -612,1 +351,18 @@\n-        hb_memset (deltas.arrayZ, 0, deltas.get_size ());\n+        if (!apply_to_all)\n+        {\n+          if (!orig_points)\n+          {\n+            orig_points_vec.extend (points);\n+            if (unlikely (orig_points_vec.in_error ())) return false;\n+            orig_points = orig_points_vec.as_array ();\n+          }\n+\n+          if (flush)\n+          {\n+            for (unsigned int i = 0; i < points.length; i++)\n+              points.arrayZ[i].translate (deltas.arrayZ[i]);\n+            flush = false;\n+\n+          }\n+          hb_memset (deltas.arrayZ, 0, deltas.get_size ());\n+        }\n@@ -614,1 +370,0 @@\n-        unsigned ref_points = 0;\n@@ -618,2 +373,8 @@\n-            unsigned int pt_index = apply_to_all ? i : indices[i];\n-            if (unlikely (pt_index >= deltas.length)) continue;\n+            unsigned int pt_index;\n+            if (apply_to_all)\n+              pt_index = i;\n+            else\n+            {\n+              pt_index = indices[i];\n+              if (unlikely (pt_index >= deltas.length)) continue;\n+            }\n@@ -621,1 +382,0 @@\n-            ref_points += !delta.flag;\n@@ -629,2 +389,8 @@\n-            unsigned int pt_index = apply_to_all ? i : indices[i];\n-            if (unlikely (pt_index >= deltas.length)) continue;\n+            unsigned int pt_index;\n+            if (apply_to_all)\n+              pt_index = i;\n+            else\n+            {\n+              pt_index = indices[i];\n+              if (unlikely (pt_index >= deltas.length)) continue;\n+            }\n@@ -632,1 +398,0 @@\n-            ref_points += !delta.flag;\n@@ -639,1 +404,1 @@\n-        if (ref_points && ref_points < orig_points.length)\n+        if (!apply_to_all)\n@@ -641,2 +406,1 @@\n-          unsigned start_point = 0;\n-          for (unsigned c = 0; c < end_points.length; c++)\n+          if (!end_points)\n@@ -644,1 +408,5 @@\n-            unsigned end_point = end_points.arrayZ[c];\n+            for (unsigned i = 0; i < points.length; ++i)\n+              if (points.arrayZ[i].is_end_point)\n+                end_points.push (i);\n+            if (unlikely (end_points.in_error ())) return false;\n+          }\n@@ -646,0 +414,3 @@\n+          unsigned start_point = 0;\n+          for (unsigned end_point : end_points)\n+          {\n@@ -692,6 +463,2 @@\n-        \/* apply specified \/ inferred deltas to points *\/\n-        for (unsigned int i = 0; i < points.length; i++)\n-        {\n-          points.arrayZ[i].x += deltas.arrayZ[i].x;\n-          points.arrayZ[i].y += deltas.arrayZ[i].y;\n-        }\n+        flush = true;\n+\n@@ -700,0 +467,4 @@\n+      if (flush)\n+        for (unsigned int i = 0; i < points.length; i++)\n+          points.arrayZ[i].translate (deltas.arrayZ[i]);\n+\n@@ -707,0 +478,2 @@\n+    unsigned glyphCount;\n+    hb_vector_t<signed> shared_tuple_active_idx;\n@@ -722,1 +495,1 @@\n-  HBUINT16      glyphCount;     \/* The number of glyphs in this font. This must match the number of\n+  HBUINT16      glyphCountX;    \/* The number of glyphs in this font. This must match the number of\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-gvar-table.hh","additions":120,"deletions":347,"binary":false,"changes":467,"status":"modified"},{"patch":"@@ -188,6 +188,2 @@\n-      for (hb_codepoint_t gid = 0; gid < plan->num_output_glyphs (); gid++)\n-      {\n-        hb_codepoint_t old_gid;\n-        if (plan->old_gid_for_new_gid (gid, &old_gid))\n-          inner_sets[0]->add (old_gid);\n-      }\n+      for (hb_codepoint_t old_gid : plan->glyphset()->iter())\n+        inner_sets[0]->add (old_gid);\n@@ -205,0 +201,1 @@\n+      {\n@@ -209,0 +206,1 @@\n+      }\n@@ -268,0 +266,3 @@\n+  const VariationStore& get_var_store () const\n+  { return this+varStore; }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-var-hvar-table.hh","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -7,1 +7,0 @@\n- *\n@@ -88,1 +87,1 @@\n-float hb_outline_t::area () const\n+float hb_outline_t::control_area () const\n@@ -121,1 +120,1 @@\n-  bool orientation_negative = area () < 0;\n+  bool orientation_negative = control_area () < 0;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-outline.cc","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  HB_INTERNAL float area () const;\n+  HB_INTERNAL float control_area () const;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-outline.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -619,1 +619,1 @@\n-  HB_PAINT_COMPOSITE_MODE_HSL_LUMINOSITY,\n+  HB_PAINT_COMPOSITE_MODE_HSL_LUMINOSITY\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-paint.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -206,2 +206,2 @@\n-    float cc = cosf (a * (float) M_PI);\n-    float ss = sinf (a * (float) M_PI);\n+    float cc = cosf (a * HB_PI);\n+    float ss = sinf (a * HB_PI);\n@@ -219,2 +219,2 @@\n-    float x = tanf (-sx * (float) M_PI);\n-    float y = tanf (+sy * (float) M_PI);\n+    float x = tanf (-sx * HB_PI);\n+    float y = tanf (+sy * HB_PI);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-paint.hh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,10 @@\n-\/* Memory pool for persistent allocation of small objects. *\/\n+\/* Memory pool for persistent allocation of small objects.\n+ *\n+ * Some AI musings on this, not necessarily true:\n+ *\n+ * This is a very simple implementation, but it's good enough for our\n+ * purposes.  It's not thread-safe.  It's not very fast.  It's not\n+ * very memory efficient.  It's not very cache efficient.  It's not\n+ * very anything efficient.  But it's simple and it works.  And it's\n+ * good enough for our purposes.  If you need something more\n+ * sophisticated, use a real allocator.  Or use a real language. *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-pool.hh","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -38,0 +38,6 @@\n+ *\n+ * The priority queue is implemented as a binary heap, which is a complete\n+ * binary tree. The root of the tree is the minimum element. The heap\n+ * property is that the priority of a node is less than or equal to the\n+ * priority of its children. The heap is stored in an array, with the\n+ * children of node i stored at indices 2i + 1 and 2i + 2.\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-priority-queue.hh","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -231,0 +231,12 @@\n+\n+  bool check_ops(unsigned count)\n+  {\n+    \/* Avoid underflow *\/\n+    if (unlikely (this->max_ops < 0 || count >= (unsigned) this->max_ops))\n+    {\n+      this->max_ops = -1;\n+      return false;\n+    }\n+    return (this->max_ops -= (int) count) > 0;\n+  }\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-sanitize.hh","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -199,0 +199,246 @@\n+#ifdef HB_EXPERIMENTAL_API\n+\n+static float\n+buffer_advance (hb_buffer_t *buffer)\n+{\n+  float a = 0;\n+  auto *pos = buffer->pos;\n+  unsigned count = buffer->len;\n+  if (HB_DIRECTION_IS_HORIZONTAL (buffer->props.direction))\n+    for (unsigned i = 0; i < count; i++)\n+      a += pos[i].x_advance;\n+  else\n+    for (unsigned i = 0; i < count; i++)\n+      a += pos[i].y_advance;\n+  return a;\n+}\n+\n+static void\n+reset_buffer (hb_buffer_t *buffer,\n+              hb_array_t<const hb_glyph_info_t> text)\n+{\n+  assert (buffer->ensure (text.length));\n+  buffer->have_positions = false;\n+  buffer->len = text.length;\n+  memcpy (buffer->info, text.arrayZ, text.length * sizeof (buffer->info[0]));\n+  hb_buffer_set_content_type (buffer, HB_BUFFER_CONTENT_TYPE_UNICODE);\n+}\n+\n+\/**\n+ * hb_shape_justify:\n+ * @font: a mutable #hb_font_t to use for shaping\n+ * @buffer: an #hb_buffer_t to shape\n+ * @features: (array length=num_features) (nullable): an array of user\n+ *    specified #hb_feature_t or `NULL`\n+ * @num_features: the length of @features array\n+ * @shaper_list: (array zero-terminated=1) (nullable): a `NULL`-terminated\n+ *    array of shapers to use or `NULL`\n+ * @min_target_advance: Minimum advance width\/height to aim for.\n+ * @max_target_advance: Maximum advance width\/height to aim for.\n+ * @advance: (inout): Input\/output advance width\/height of the buffer.\n+ * @var_tag: (out): Variation-axis tag used for justification.\n+ * @var_value: (out): Variation-axis value used to reach target justification.\n+ *\n+ * See hb_shape_full() for basic details. If @shaper_list is not `NULL`, the specified\n+ * shapers will be used in the given order, otherwise the default shapers list\n+ * will be used.\n+ *\n+ * In addition, justify the shaping results such that the shaping results reach\n+ * the target advance width\/height, depending on the buffer direction.\n+ *\n+ * If the advance of the buffer shaped with hb_shape_full() is already known,\n+ * put that in *advance. Otherwise set *advance to zero.\n+ *\n+ * This API is currently experimental and will probably change in the future.\n+ *\n+ * Return value: false if all shapers failed, true otherwise\n+ *\n+ * XSince: EXPERIMENTAL\n+ **\/\n+hb_bool_t\n+hb_shape_justify (hb_font_t          *font,\n+                  hb_buffer_t        *buffer,\n+                  const hb_feature_t *features,\n+                  unsigned int        num_features,\n+                  const char * const *shaper_list,\n+                  float               min_target_advance,\n+                  float               max_target_advance,\n+                  float              *advance, \/* IN\/OUT *\/\n+                  hb_tag_t           *var_tag, \/* OUT *\/\n+                  float              *var_value \/* OUT *\/)\n+{\n+  \/\/ TODO Negative font scales?\n+\n+  \/* If default advance already matches target, nothing to do. Shape and return. *\/\n+  if (min_target_advance <= *advance && *advance <= max_target_advance)\n+  {\n+    *var_tag = HB_TAG_NONE;\n+    *var_value = 0.0f;\n+    return hb_shape_full (font, buffer,\n+                          features, num_features,\n+                          shaper_list);\n+  }\n+\n+  hb_face_t *face = font->face;\n+\n+  \/* Choose variation tag to use for justification. *\/\n+\n+  hb_tag_t tag = HB_TAG_NONE;\n+  hb_ot_var_axis_info_t axis_info;\n+\n+  hb_tag_t tags[] =\n+  {\n+    HB_TAG ('j','s','t','f'),\n+    HB_TAG ('w','d','t','h'),\n+  };\n+  for (unsigned i = 0; i < ARRAY_LENGTH (tags); i++)\n+    if (hb_ot_var_find_axis_info (face, tags[i], &axis_info))\n+    {\n+      tag = *var_tag = tags[i];\n+      break;\n+    }\n+\n+  \/* If no suitable variation axis found, can't justify.  Just shape and return. *\/\n+  if (!tag)\n+  {\n+    *var_tag = HB_TAG_NONE;\n+    *var_value = 0.0f;\n+    if (hb_shape_full (font, buffer,\n+                       features, num_features,\n+                       shaper_list))\n+    {\n+      *advance = buffer_advance (buffer);\n+      return true;\n+    }\n+    else\n+      return false;\n+  }\n+\n+  \/* Copy buffer text as we need it so we can shape multiple times. *\/\n+  unsigned text_len = buffer->len;\n+  auto *text_info = (hb_glyph_info_t *) hb_malloc (text_len * sizeof (buffer->info[0]));\n+  if (unlikely (text_len && !text_info))\n+    return false;\n+  hb_memcpy (text_info, buffer->info, text_len * sizeof (buffer->info[0]));\n+  auto text = hb_array<const hb_glyph_info_t> (text_info, text_len);\n+\n+  \/* If default advance was not provided to us, calculate it. *\/\n+  if (!*advance)\n+  {\n+    hb_font_set_variation (font, tag, axis_info.default_value);\n+    if (!hb_shape_full (font, buffer,\n+                        features, num_features,\n+                        shaper_list))\n+      return false;\n+    *advance = buffer_advance (buffer);\n+  }\n+\n+  \/* If default advance already matches target, nothing to do. Shape and return.\n+   * Do this again, in case advance was just calculated.\n+   *\/\n+  if (min_target_advance <= *advance && *advance <= max_target_advance)\n+  {\n+    *var_tag = HB_TAG_NONE;\n+    *var_value = 0.0f;\n+    return true;\n+  }\n+\n+  \/* Prepare for running the solver. *\/\n+  double a, b, ya, yb;\n+  if (*advance < min_target_advance)\n+  {\n+    \/* Need to expand. *\/\n+    ya = (double) *advance;\n+    a = (double) axis_info.default_value;\n+    b = (double) axis_info.max_value;\n+\n+    \/* Shape buffer for maximum expansion to use as other\n+     * starting point for the solver. *\/\n+    hb_font_set_variation (font, tag, (float) b);\n+    reset_buffer (buffer, text);\n+    if (!hb_shape_full (font, buffer,\n+                        features, num_features,\n+                        shaper_list))\n+      return false;\n+    yb = (double) buffer_advance (buffer);\n+    \/* If the maximum expansion is less than max target,\n+     * there's nothing to solve for. Just return it. *\/\n+    if (yb <= (double) max_target_advance)\n+    {\n+      *var_value = (float) b;\n+      *advance = (float) yb;\n+      return true;\n+    }\n+  }\n+  else\n+  {\n+    \/* Need to shrink. *\/\n+    yb = (double) *advance;\n+    a = (double) axis_info.min_value;\n+    b = (double) axis_info.default_value;\n+\n+    \/* Shape buffer for maximum shrinkate to use as other\n+     * starting point for the solver. *\/\n+    hb_font_set_variation (font, tag, (float) a);\n+    reset_buffer (buffer, text);\n+    if (!hb_shape_full (font, buffer,\n+                        features, num_features,\n+                        shaper_list))\n+      return false;\n+    ya = (double) buffer_advance (buffer);\n+    \/* If the maximum shrinkate is more than min target,\n+     * there's nothing to solve for. Just return it. *\/\n+    if (ya >= (double) min_target_advance)\n+    {\n+      *var_value = (float) a;\n+      *advance = (float) ya;\n+      return true;\n+    }\n+  }\n+\n+  \/* Run the solver to find a var axis value that hits\n+   * the desired width. *\/\n+\n+  double epsilon = (b - a) \/ (1<<14);\n+  bool failed = false;\n+\n+  auto f = [&] (double x)\n+  {\n+    hb_font_set_variation (font, tag, (float) x);\n+    reset_buffer (buffer, text);\n+    if (unlikely (!hb_shape_full (font, buffer,\n+                                  features, num_features,\n+                                  shaper_list)))\n+    {\n+      failed = true;\n+      return (double) min_target_advance;\n+    }\n+\n+    double w = (double) buffer_advance (buffer);\n+    DEBUG_MSG (JUSTIFY, nullptr, \"Trying '%c%c%c%c' axis parameter %f. Advance %g. Target: min %g max %g\",\n+               HB_UNTAG (tag), x, w,\n+               (double) min_target_advance, (double) max_target_advance);\n+    return w;\n+  };\n+\n+  double y = 0;\n+  double itp = solve_itp (f,\n+                          a, b,\n+                          epsilon,\n+                          (double) min_target_advance, (double) max_target_advance,\n+                          ya, yb, y);\n+\n+  hb_free (text_info);\n+\n+  if (failed)\n+    return false;\n+\n+  *var_value = (float) itp;\n+  *advance = (float) y;\n+\n+  return true;\n+}\n+\n+#endif\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-shape.cc","additions":246,"deletions":0,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -56,0 +56,12 @@\n+HB_EXTERN hb_bool_t\n+hb_shape_justify (hb_font_t          *font,\n+                  hb_buffer_t        *buffer,\n+                  const hb_feature_t *features,\n+                  unsigned int        num_features,\n+                  const char * const *shaper_list,\n+                  float               min_target_advance,\n+                  float               max_target_advance,\n+                  float              *advance, \/* IN\/OUT *\/\n+                  hb_tag_t           *var_tag, \/* OUT *\/\n+                  float              *var_value \/* OUT *\/);\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-shape.h","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-HB_SHAPER_IMPLEMENT (ot) \/* <--- This is our main OpenType shaper. *\/\n+HB_SHAPER_IMPLEMENT (ot) \/* <--- This is our main shaper. *\/\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-shaper-list.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"hb-ot-hmtx-table.hh\"\n@@ -42,0 +43,1 @@\n+#include \"hb-ot-name-language-static.hh\"\n@@ -111,0 +113,22 @@\n+#ifndef HB_NO_VAR\n+bool\n+_glyf_get_leading_bearing_with_var_unscaled (hb_font_t *font, hb_codepoint_t glyph, bool is_vertical,\n+                                             int *lsb)\n+{\n+  return font->face->table.glyf->get_leading_bearing_with_var_unscaled (font, glyph, is_vertical, lsb);\n+}\n+\n+unsigned\n+_glyf_get_advance_with_var_unscaled (hb_font_t *font, hb_codepoint_t glyph, bool is_vertical)\n+{\n+  return font->face->table.glyf->get_advance_with_var_unscaled (font, glyph, is_vertical);\n+}\n+#endif\n+\n+bool\n+_glyf_get_leading_bearing_without_var_unscaled (hb_face_t *face, hb_codepoint_t gid, bool is_vertical, int *lsb)\n+{\n+  return face->table.glyf->get_leading_bearing_without_var_unscaled (gid, is_vertical, lsb);\n+}\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-static.cc","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  return tanf (a * float (-M_PI \/ 180.));\n+  return tanf (a * -HB_PI \/ 180.f);\n@@ -55,1 +55,1 @@\n-  return atanf (r) * float (-180. \/ M_PI);\n+  return atanf (r) * -180.f \/ HB_PI;\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-style.cc","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-    HB_TAG ('c', 'v', 't', ' '),\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-input.cc","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"hb-ot-cff2-table.hh\"\n@@ -41,0 +42,1 @@\n+#include \"OT\/Color\/CPAL\/CPAL.hh\"\n@@ -296,1 +298,1 @@\n-  if (table_tag == HB_OT_TAG_GSUB)\n+  if (table_tag == HB_OT_TAG_GSUB && !(plan->flags & HB_SUBSET_FLAGS_NO_LAYOUT_CLOSURE))\n@@ -348,1 +350,4 @@\n-  vars.alloc (plan->user_axes_location.get_population ());\n+  if (!vars.alloc (plan->user_axes_location.get_population ())) {\n+    hb_font_destroy (font);\n+    return nullptr;\n+  }\n@@ -384,1 +389,7 @@\n-    font = _get_hb_font_with_variations (plan);\n+    if (unlikely (!plan->check_success (font = _get_hb_font_with_variations (plan)))) {\n+      hb_font_destroy (font);\n+      gdef.destroy ();\n+      gpos.destroy ();\n+      return;\n+    }\n+\n@@ -558,3 +569,6 @@\n-        hb_codepoint_t gid = (*unicode_glyphid_map)[cp];\n-        plan->codepoint_to_glyph->set (cp, gid);\n-        plan->unicode_to_new_gid_list.push (hb_pair (cp, gid));\n+        hb_codepoint_t *gid;\n+        if (!unicode_glyphid_map->has(cp, &gid))\n+          continue;\n+\n+        plan->codepoint_to_glyph->set (cp, *gid);\n+        plan->unicode_to_new_gid_list.push (hb_pair (cp, *gid));\n@@ -612,1 +626,1 @@\n-  for (auto item : glyf.glyph_for_gid (gid).get_composite_iterator ())\n+  for (auto &item : glyf.glyph_for_gid (gid).get_composite_iterator ())\n@@ -620,0 +634,12 @@\n+#ifndef HB_NO_VAR_COMPOSITES\n+  for (auto &item : glyf.glyph_for_gid (gid).get_var_composite_iterator ())\n+   {\n+    operation_count =\n+      _glyf_add_gid_and_children (glyf,\n+                                  item.get_gid (),\n+                                  gids_to_retain,\n+                                  operation_count,\n+                                  depth);\n+   }\n+#endif\n+\n@@ -623,0 +649,32 @@\n+static void\n+_nameid_closure (hb_subset_plan_t* plan,\n+                 hb_set_t* drop_tables)\n+{\n+#ifndef HB_NO_STYLE\n+  plan->source->table.STAT->collect_name_ids (&plan->user_axes_location, &plan->name_ids);\n+#endif\n+#ifndef HB_NO_VAR\n+  if (!plan->all_axes_pinned)\n+    plan->source->table.fvar->collect_name_ids (&plan->user_axes_location, &plan->name_ids);\n+#endif\n+#ifndef HB_NO_COLOR\n+  if (!drop_tables->has (HB_OT_TAG_CPAL))\n+    plan->source->table.CPAL->collect_name_ids (&plan->colr_palettes, &plan->name_ids);\n+#endif\n+\n+#ifndef HB_NO_SUBSET_LAYOUT\n+  if (!drop_tables->has (HB_OT_TAG_GPOS))\n+  {\n+    hb_blob_ptr_t<GPOS> gpos = plan->source_table<GPOS> ();\n+    gpos->collect_name_ids (&plan->gpos_features, &plan->name_ids);\n+    gpos.destroy ();\n+  }\n+  if (!drop_tables->has (HB_OT_TAG_GSUB))\n+  {\n+    hb_blob_ptr_t<GSUB> gsub = plan->source_table<GSUB> ();\n+    gsub->collect_name_ids (&plan->gsub_features, &plan->name_ids);\n+    gsub.destroy ();\n+  }\n+#endif\n+}\n+\n@@ -676,0 +734,1 @@\n+  _nameid_closure (plan, drop_tables);\n@@ -759,15 +818,0 @@\n-static void\n-_nameid_closure (hb_face_t *face,\n-                 hb_set_t  *nameids,\n-                 bool all_axes_pinned,\n-                 hb_hashmap_t<hb_tag_t, float> *user_axes_location)\n-{\n-#ifndef HB_NO_STYLE\n-  face->table.STAT->collect_name_ids (user_axes_location, nameids);\n-#endif\n-#ifndef HB_NO_VAR\n-  if (!all_axes_pinned)\n-    face->table.fvar->collect_name_ids (user_axes_location, nameids);\n-#endif\n-}\n-\n@@ -786,0 +830,1 @@\n+  unsigned avar_axis_count = 0;\n@@ -787,0 +832,1 @@\n+  {\n@@ -788,0 +834,2 @@\n+    avar_axis_count = face->table.avar->get_axis_count();\n+  }\n@@ -791,1 +839,0 @@\n-  unsigned int i = 0;\n@@ -806,1 +853,1 @@\n-      if (has_avar && old_axis_idx < face->table.avar->get_axis_count ())\n+      if (has_avar && old_axis_idx < avar_axis_count)\n@@ -814,1 +861,1 @@\n-      plan->normalized_coords[i] = normalized_v;\n+      plan->normalized_coords[old_axis_idx] = normalized_v;\n@@ -816,2 +863,0 @@\n-    if (has_avar)\n-      seg_maps = &StructAfter<OT::SegmentMaps> (*seg_maps);\n@@ -821,1 +866,2 @@\n-    i++;\n+    if (has_avar && old_axis_idx < avar_axis_count)\n+      seg_maps = &StructAfter<OT::SegmentMaps> (*seg_maps);\n@@ -825,0 +871,83 @@\n+\n+static void\n+_update_instance_metrics_map_from_cff2 (hb_subset_plan_t *plan)\n+{\n+  if (!plan->normalized_coords) return;\n+  OT::cff2::accelerator_t cff2 (plan->source);\n+  if (!cff2.is_valid ()) return;\n+\n+  hb_font_t *font = nullptr;\n+  if (unlikely (!plan->check_success (font = _get_hb_font_with_variations (plan))))\n+  {\n+    hb_font_destroy (font);\n+    return;\n+  }\n+\n+  hb_glyph_extents_t extents = {0x7FFF, -0x7FFF};\n+  OT::hmtx_accelerator_t _hmtx (plan->source);\n+  float *hvar_store_cache = nullptr;\n+  if (_hmtx.has_data () && _hmtx.var_table.get_length ())\n+    hvar_store_cache = _hmtx.var_table->get_var_store ().create_cache ();\n+\n+  OT::vmtx_accelerator_t _vmtx (plan->source);\n+  float *vvar_store_cache = nullptr;\n+  if (_vmtx.has_data () && _vmtx.var_table.get_length ())\n+    vvar_store_cache = _vmtx.var_table->get_var_store ().create_cache ();\n+\n+  for (auto p : *plan->glyph_map)\n+  {\n+    hb_codepoint_t old_gid = p.first;\n+    hb_codepoint_t new_gid = p.second;\n+    if (!cff2.get_extents (font, old_gid, &extents)) continue;\n+    bool has_bounds_info = true;\n+    if (extents.x_bearing == 0 && extents.width == 0 &&\n+        extents.height == 0 && extents.y_bearing == 0)\n+      has_bounds_info = false;\n+\n+    if (has_bounds_info)\n+    {\n+      plan->head_maxp_info.xMin = hb_min (plan->head_maxp_info.xMin, extents.x_bearing);\n+      plan->head_maxp_info.xMax = hb_max (plan->head_maxp_info.xMax, extents.x_bearing + extents.width);\n+      plan->head_maxp_info.yMax = hb_max (plan->head_maxp_info.yMax, extents.y_bearing);\n+      plan->head_maxp_info.yMin = hb_min (plan->head_maxp_info.yMin, extents.y_bearing + extents.height);\n+    }\n+\n+    if (_hmtx.has_data ())\n+    {\n+      int hori_aw = _hmtx.get_advance_without_var_unscaled (old_gid);\n+      if (_hmtx.var_table.get_length ())\n+        hori_aw += (int) roundf (_hmtx.var_table->get_advance_delta_unscaled (old_gid, font->coords, font->num_coords,\n+                                                                              hvar_store_cache));\n+      int lsb = extents.x_bearing;\n+      if (!has_bounds_info)\n+      {\n+        if (!_hmtx.get_leading_bearing_without_var_unscaled (old_gid, &lsb))\n+          continue;\n+      }\n+      plan->hmtx_map.set (new_gid, hb_pair ((unsigned) hori_aw, lsb));\n+      plan->bounds_width_map.set (new_gid, extents.width);\n+    }\n+\n+    if (_vmtx.has_data ())\n+    {\n+      int vert_aw = _vmtx.get_advance_without_var_unscaled (old_gid);\n+      if (_vmtx.var_table.get_length ())\n+        vert_aw += (int) roundf (_vmtx.var_table->get_advance_delta_unscaled (old_gid, font->coords, font->num_coords,\n+                                                                              vvar_store_cache));\n+\n+      int tsb = extents.y_bearing;\n+      if (!has_bounds_info)\n+      {\n+        if (!_vmtx.get_leading_bearing_without_var_unscaled (old_gid, &tsb))\n+          continue;\n+      }\n+      plan->vmtx_map.set (new_gid, hb_pair ((unsigned) vert_aw, tsb));\n+      plan->bounds_height_map.set (new_gid, extents.height);\n+    }\n+  }\n+  hb_font_destroy (font);\n+  if (hvar_store_cache)\n+    _hmtx.var_table->get_var_store ().destroy_cache (hvar_store_cache);\n+  if (vvar_store_cache)\n+    _vmtx.var_table->get_var_store ().destroy_cache (vvar_store_cache);\n+}\n@@ -887,0 +1016,2 @@\n+  if (unlikely (in_error ()))\n+    return;\n@@ -908,1 +1039,0 @@\n-  _nameid_closure (face, &name_ids, all_axes_pinned, &user_axes_location);\n@@ -912,0 +1042,4 @@\n+#ifndef HB_NO_VAR\n+  _update_instance_metrics_map_from_cff2 (this);\n+#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-plan.cc","additions":163,"deletions":29,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-    hb_lock_t (accelerator ? &accelerator->sanitized_table_cache_lock : nullptr);\n+    hb_lock_t lock (accelerator ? &accelerator->sanitized_table_cache_lock : nullptr);\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset-plan.hh","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-\n-#if !defined(AIX)\n@@ -49,2 +47,0 @@\n-#endif\n-\n@@ -57,0 +53,1 @@\n+#include \"hb-ot-var-cvar-table.hh\"\n@@ -485,0 +482,10 @@\n+  case HB_TAG ('c', 'v', 't', ' '):\n+#ifndef HB_NO_VAR\n+    if (_is_table_present (plan->source, HB_OT_TAG_cvar) &&\n+        plan->normalized_coords && !plan->pinned_at_default)\n+    {\n+      auto &cvar = *plan->source->table.cvar;\n+      return OT::cvar::add_cvt_and_apply_deltas (plan, cvar.get_tuple_var_data (), &cvar);\n+    }\n+#endif\n+    return _passthrough (plan, tag);\n@@ -633,5 +640,0 @@\n-\n-#ifndef HB_NO_VISIBILITY\n-\/* If NO_VISIBILITY, libharfbuzz has this. *\/\n-#include \"hb-ot-name-language-static.hh\"\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset.cc","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+ * @HB_SUBSET_FLAGS_NO_LAYOUT_CLOSURE: If set don't perform glyph closure on layout\n+ * substitution rules (GSUB). Since: 7.2.0.\n@@ -90,0 +92,1 @@\n+  HB_SUBSET_FLAGS_NO_LAYOUT_CLOSURE =        0x00000200u,\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n- * @HB_UNICODE_COMBINING_CLASS_CCC133: [Tibetan]\n+ * @HB_UNICODE_COMBINING_CLASS_CCC132: [Tibetan] Since: 7.2.0\n@@ -249,1 +249,1 @@\n-  HB_UNICODE_COMBINING_CLASS_CCC133     = 132,\n+  HB_UNICODE_COMBINING_CLASS_CCC132     = 132,\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-unicode.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-#define HB_VERSION_MINOR 0\n+#define HB_VERSION_MINOR 2\n@@ -56,1 +56,1 @@\n-#define HB_VERSION_MICRO 1\n+#define HB_VERSION_MICRO 0\n@@ -63,1 +63,1 @@\n-#define HB_VERSION_STRING \"7.0.1\"\n+#define HB_VERSION_STRING \"7.2.0\"\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-version.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -249,1 +249,9 @@\n-#if (defined(__GNUC__) || defined(__clang__)) && defined(__OPTIMIZE__)\n+\/\/ gcc 10 has __has_builtin but not earlier versions. Sanction any gcc >= 5\n+\/\/ clang defines it so no need.\n+#ifdef __has_builtin\n+#define hb_has_builtin __has_builtin\n+#else\n+#define hb_has_builtin(x) ((defined(__GNUC__) && __GNUC__ >= 5))\n+#endif\n+\n+#if defined(__OPTIMIZE__) && hb_has_builtin(__builtin_expect)\n@@ -504,0 +512,6 @@\n+\/* Pie time. *\/\n+\/\/ https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/4166\n+#define HB_PI 3.14159265358979f\n+#define HB_2_PI (2.f * HB_PI)\n+\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb.hh","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"}]}