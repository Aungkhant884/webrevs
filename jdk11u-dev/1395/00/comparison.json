{"files":[{"patch":"@@ -2164,2 +2164,1 @@\n-  bool will_link;\n-  ciKlass* klass = stream()->get_klass(will_link);\n+  ciKlass* klass = stream()->get_klass();\n@@ -2180,2 +2179,1 @@\n-  bool will_link;\n-  ciKlass* klass = stream()->get_klass(will_link);\n+  ciKlass* klass = stream()->get_klass();\n@@ -2206,2 +2204,1 @@\n-  bool will_link;\n-  ciKlass* klass = stream()->get_klass(will_link);\n+  ciKlass* klass = stream()->get_klass();\n@@ -2227,2 +2224,1 @@\n-  bool will_link;\n-  ciKlass* klass = stream()->get_klass(will_link);\n+  ciKlass* klass = stream()->get_klass();\n@@ -2262,2 +2258,1 @@\n-  bool will_link;\n-  ciKlass* klass = stream()->get_klass(will_link);\n+  ciKlass* klass = stream()->get_klass();\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1240,0 +1240,31 @@\n+static bool is_patching_needed(JavaThread* current, Runtime1::StubID stub_id) {\n+  if (stub_id == Runtime1::load_klass_patching_id ||\n+      stub_id == Runtime1::load_mirror_patching_id) {\n+    \/\/ last java frame on stack\n+    vframeStream vfst(current, true);\n+    assert(!vfst.at_end(), \"Java frame must exist\");\n+\n+    methodHandle caller_method(current, vfst.method());\n+    int bci = vfst.bci();\n+    Bytecodes::Code code = caller_method()->java_code_at(bci);\n+\n+    switch (code) {\n+      case Bytecodes::_new:\n+      case Bytecodes::_anewarray:\n+      case Bytecodes::_multianewarray:\n+      case Bytecodes::_instanceof:\n+      case Bytecodes::_checkcast: {\n+        Bytecode bc(caller_method(), caller_method->bcp_from(bci));\n+        constantTag tag = caller_method->constants()->tag_at(bc.get_index_u2(code));\n+        if (tag.is_unresolved_klass_in_error()) {\n+          return false; \/\/ throws resolution error\n+        }\n+        break;\n+      }\n+\n+      default: break;\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -1251,5 +1282,6 @@\n-  \/\/ It's possible the nmethod was invalidated in the last\n-  \/\/ safepoint, but if it's still alive then make it not_entrant.\n-  nmethod* nm = CodeCache::find_nmethod(caller_frame.pc());\n-  if (nm != NULL) {\n-    nm->make_not_entrant();\n+  if (is_patching_needed(current, stub_id)) {\n+    \/\/ Make sure the nmethod is invalidated, i.e. made not entrant.\n+    nmethod* nm = CodeCache::find_nmethod(caller_frame.pc());\n+    if (nm != NULL) {\n+      nm->make_not_entrant();\n+    }\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":37,"deletions":5,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"ci\/ciCallSite.hpp\"\n@@ -29,0 +28,2 @@\n+#include \"ci\/ciKlass.hpp\"\n+#include \"ci\/ciObjArrayKlass.hpp\"\n@@ -193,0 +194,19 @@\n+\/\/ ciBytecodeStream::get_klass\n+\/\/\n+\/\/ If this bytecode is a new, newarray, multianewarray, instanceof,\n+\/\/ or checkcast, get the referenced klass. Retuns an unloaded ciKlass\n+\/\/ if the referenced klass is not accessible.\n+ciKlass* ciBytecodeStream::get_klass() {\n+  bool will_link;\n+  ciKlass* klass = get_klass(will_link);\n+  if (!will_link && klass->is_loaded()) { \/\/ klass not accessible\n+    if (klass->is_array_klass()) {\n+      assert(!klass->is_type_array_klass(), \"\");\n+      klass = ciEnv::unloaded_ciobjarrayklass();\n+    } else {\n+      klass = ciEnv::unloaded_ciinstance_klass();\n+    }\n+  }\n+  return klass;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -236,0 +236,1 @@\n+  ciKlass* get_klass();\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    if (can_use_native_byte_order(bc, is_wide))\n+    if (can_use_native_byte_order(bc, is_wide)) {\n@@ -82,1 +82,3 @@\n-    else  return Bytes::get_Java_u2(p);\n+    } else {\n+      return Bytes::get_Java_u2(p);\n+    }\n","filename":"src\/hotspot\/share\/interpreter\/bytecode.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler\/c1;\n+\n+super public class KlassAccessCheck\n+  version 51:0\n+{\n+\n+  public static Method testNewInstance:\"()V\"\n+  stack 2 locals 0\n+  {\n+   new class compiler\/c1\/types\/PackagePrivateClass;\n+   return;\n+  }\n+\n+\n+  public static Method testNewArray:\"()[Ljava\/lang\/Object;\"\n+    stack 1 locals 0\n+  {\n+   iconst_1;\n+   anewarray class compiler\/c1\/types\/PackagePrivateClass;\n+   areturn;\n+  }\n+\n+  public static Method testMultiNewArray:\"()[[Ljava\/lang\/Object;\"\n+  stack 2 locals 1\n+  {\n+   iconst_1;\n+   iconst_1;\n+   multianewarray  class \"[[Lcompiler\/c1\/types\/PackagePrivateClass;\",  2;\n+   areturn;\n+  }\n+\n+  public static Method testCheckCast:\"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\"\n+  stack 1 locals 2\n+  {\n+   aload_0;\n+   checkcast class compiler\/c1\/types\/PackagePrivateClass;\n+   areturn;\n+  }\n+\n+  public static Method testCheckCastArr:\"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\"\n+  stack 1 locals 2\n+  {\n+   aload_0;\n+   checkcast class \"[Lcompiler\/c1\/types\/PackagePrivateClass;\";\n+   areturn;\n+  }\n+\n+  public static Method testInstanceOf:\"(Ljava\/lang\/Object;)Z\"\n+  stack 1 locals 2\n+  {\n+   aload_0;\n+   instanceof class compiler\/c1\/types\/PackagePrivateClass;\n+   ireturn;\n+  }\n+\n+  public static Method testInstanceOfArr:\"(Ljava\/lang\/Object;)Z\"\n+  stack 1 locals 2\n+  {\n+   aload_0;\n+   instanceof class \"[Lcompiler\/c1\/types\/PackagePrivateClass;\";\n+   ireturn;\n+  }\n+} \/\/ end Class KlassAccessCheck\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/KlassAccessCheck.jasm","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler\/c1\/types;\n+\n+super class PackagePrivateClass\n+ version 51:0\n+{}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/KlassAccessCheckPackagePrivate.jasm","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8293044\n+ * @requires vm.compiler1.enabled\n+ * @compile KlassAccessCheckPackagePrivate.jasm\n+ * @compile KlassAccessCheck.jasm\n+ * @run main\/othervm -Xbatch -XX:TieredStopAtLevel=1 compiler.c1.KlassAccessCheckTest\n+ *\/\n+\n+package compiler.c1;\n+\n+public class KlassAccessCheckTest {\n+    static void test(Runnable r) {\n+        for (int i = 0; i < 1000; ++i) {\n+            try {\n+                r.run();\n+                throw new AssertionError(\"No IllegalAccessError thrown\");\n+            } catch (IllegalAccessError e) {\n+                \/\/ Expected\n+            } catch (AssertionError e) {\n+                throw e; \/\/ rethrow\n+            } catch (Throwable e) {\n+                throw new AssertionError(\"Wrong exception thrown\", e);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        test(() -> KlassAccessCheck.testNewInstance());\n+        test(() -> KlassAccessCheck.testNewArray());\n+        test(() -> KlassAccessCheck.testMultiNewArray());\n+        test(() -> KlassAccessCheck.testCheckCast(42));\n+        test(() -> KlassAccessCheck.testCheckCastArr(new Integer[0]));\n+        test(() -> KlassAccessCheck.testInstanceOf(42));\n+        test(() -> KlassAccessCheck.testInstanceOfArr(new Integer[0]));\n+        System.out.println(\"TEST PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/KlassAccessCheckTest.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main gc.TestAllocateHeapAt\n+ * @run driver gc.TestAllocateHeapAt\n@@ -43,7 +43,0 @@\n-    ArrayList<String> vmOpts = new ArrayList<>();\n-\n-    String testVmOptsStr = System.getProperty(\"test.java.opts\");\n-    if (!testVmOptsStr.isEmpty()) {\n-      String[] testVmOpts = testVmOptsStr.split(\" \");\n-      Collections.addAll(vmOpts, testVmOpts);\n-    }\n@@ -51,14 +44,8 @@\n-    Collections.addAll(vmOpts, new String[] {\"-XX:AllocateHeapAt=\" + test_dir,\n-                                             \"-Xlog:gc+heap=info\",\n-                                             \"-Xmx32m\",\n-                                             \"-Xms32m\",\n-                                             \"-version\"});\n-\n-    System.out.print(\"Testing:\\n\" + JDKToolFinder.getJDKTool(\"java\"));\n-    for (int i = 0; i < vmOpts.size(); i += 1) {\n-      System.out.print(\" \" + vmOpts.get(i));\n-    }\n-    System.out.println();\n-\n-    ProcessBuilder pb =\n-      ProcessTools.createJavaProcessBuilder(vmOpts.toArray(new String[vmOpts.size()]));\n+    String[] flags = {\n+        \"-XX:AllocateHeapAt=\" + test_dir,\n+        \"-Xlog:gc+heap=info\",\n+        \"-Xmx32m\",\n+        \"-Xms32m\",\n+        \"-version\"};\n+\n+    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, flags);\n","filename":"test\/hotspot\/jtreg\/gc\/TestAllocateHeapAt.java","additions":9,"deletions":22,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main gc.TestAllocateHeapAtError\n+ * @run driver gc.TestAllocateHeapAtError\n@@ -36,1 +36,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -39,2 +38,0 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n@@ -45,7 +42,0 @@\n-    ArrayList<String> vmOpts = new ArrayList<>();\n-\n-    String testVmOptsStr = System.getProperty(\"test.java.opts\");\n-    if (!testVmOptsStr.isEmpty()) {\n-      String[] testVmOpts = testVmOptsStr.split(\" \");\n-      Collections.addAll(vmOpts, testVmOpts);\n-    }\n@@ -59,11 +49,6 @@\n-    Collections.addAll(vmOpts, new String[] {\"-XX:AllocateHeapAt=\" + f.getName(),\n-                                             \"-Xlog:gc+heap=info\",\n-                                             \"-Xmx32m\",\n-                                             \"-Xms32m\",\n-                                             \"-version\"});\n-\n-    System.out.print(\"Testing:\\n\" + JDKToolFinder.getJDKTool(\"java\"));\n-    for (int i = 0; i < vmOpts.size(); i += 1) {\n-      System.out.print(\" \" + vmOpts.get(i));\n-    }\n-    System.out.println();\n+    String[] flags = {\n+        \"-XX:AllocateHeapAt=\" + f.getName(),\n+        \"-Xlog:gc+heap=info\",\n+        \"-Xmx32m\",\n+        \"-Xms32m\",\n+        \"-version\"};\n@@ -71,2 +56,1 @@\n-    ProcessBuilder pb =\n-      ProcessTools.createJavaProcessBuilder(vmOpts.toArray(new String[vmOpts.size()]));\n+    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, flags);\n","filename":"test\/hotspot\/jtreg\/gc\/TestAllocateHeapAtError.java","additions":8,"deletions":24,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/timeout=360 gc.TestAllocateHeapAtMultiple\n+ * @run driver\/timeout=360 gc.TestAllocateHeapAtMultiple\n@@ -43,2 +43,1 @@\n-    ArrayList<String> vmOpts = new ArrayList<>();\n-    String[] testVmOpts = null;\n+    ArrayList<String> flags = new ArrayList<>();\n@@ -48,12 +47,7 @@\n-    String testVmOptsStr = System.getProperty(\"test.java.opts\");\n-    if (!testVmOptsStr.isEmpty()) {\n-      testVmOpts = testVmOptsStr.split(\" \");\n-    }\n-\n-    \/\/ Extra options for each of the sub-tests\n-    String[] extraOptsList = new String[] {\n-      \"-Xmx32m -Xms32m -XX:+UseCompressedOops\",     \/\/ 1. With compressedoops enabled.\n-      \"-Xmx32m -Xms32m -XX:-UseCompressedOops\",     \/\/ 2. With compressedoops disabled.\n-      \"-Xmx32m -Xms32m -XX:HeapBaseMinAddress=3g\",  \/\/ 3. With user specified HeapBaseMinAddress.\n-      \"-Xmx32m -Xms32m -XX:+UseLargePages\",         \/\/ 4. Set UseLargePages.\n-      \"-Xmx32m -Xms32m -XX:+UseNUMA\"                \/\/ 5. Set UseNUMA.\n+    \/\/ Extra flags for each of the sub-tests\n+    String[][] extraFlagsList = new String[][] {\n+      {\"-Xmx32m\", \"-Xms32m\", \"-XX:+UseCompressedOops\"},     \/\/ 1. With compressedoops enabled.\n+      {\"-Xmx32m\", \"-Xms32m\", \"-XX:-UseCompressedOops\"},     \/\/ 2. With compressedoops disabled.\n+      {\"-Xmx32m\", \"-Xms32m\", \"-XX:HeapBaseMinAddress=3g\"},  \/\/ 3. With user specified HeapBaseMinAddress.\n+      {\"-Xmx32m\", \"-Xms32m\", \"-XX:+UseLargePages\"},         \/\/ 4. Set UseLargePages.\n+      {\"-Xmx32m\", \"-Xms32m\", \"-XX:+UseNUMA\"}                \/\/ 5. Set UseNUMA.\n@@ -62,20 +56,8 @@\n-    for(String extraOpts : extraOptsList) {\n-      vmOpts.clear();\n-      if(testVmOpts != null) {\n-        Collections.addAll(vmOpts, testVmOpts);\n-      }\n-      \/\/ Add extra options specific to the sub-test.\n-      String[] extraOptsArray = extraOpts.split(\" \");\n-      if(extraOptsArray != null) {\n-        Collections.addAll(vmOpts, extraOptsArray);\n-      }\n-      \/\/ Add common options\n-      Collections.addAll(vmOpts, new String[] {\"-XX:AllocateHeapAt=\" + test_dir,\n-                                               \"-Xlog:gc+heap=info\",\n-                                               \"-version\"});\n-\n-      System.out.print(\"Testing:\\n\" + JDKToolFinder.getJDKTool(\"java\"));\n-      for (int i = 0; i < vmOpts.size(); i += 1) {\n-        System.out.print(\" \" + vmOpts.get(i));\n-      }\n-      System.out.println();\n+    for (String[] extraFlags : extraFlagsList) {\n+      flags.clear();\n+      \/\/ Add extra flags specific to the sub-test.\n+      Collections.addAll(flags, extraFlags);\n+      \/\/ Add common flags\n+      Collections.addAll(flags, new String[] {\"-XX:AllocateHeapAt=\" + test_dir,\n+                                              \"-Xlog:gc+heap=info\",\n+                                              \"-version\"});\n@@ -84,1 +66,1 @@\n-        ProcessTools.createJavaProcessBuilder(vmOpts.toArray(new String[vmOpts.size()]));\n+          ProcessTools.createJavaProcessBuilder(true, flags.toArray(String[]::new));\n","filename":"test\/hotspot\/jtreg\/gc\/TestAllocateHeapAtMultiple.java","additions":18,"deletions":36,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * @run main gc.TestVerifyDuringStartup\n+ * @run driver gc.TestVerifyDuringStartup\n@@ -36,1 +36,0 @@\n-import jdk.test.lib.JDKToolFinder;\n@@ -39,2 +38,0 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n@@ -44,21 +41,8 @@\n-    ArrayList<String> vmOpts = new ArrayList<>();\n-\n-    String testVmOptsStr = System.getProperty(\"test.java.opts\");\n-    if (!testVmOptsStr.isEmpty()) {\n-      String[] testVmOpts = testVmOptsStr.split(\" \");\n-      Collections.addAll(vmOpts, testVmOpts);\n-    }\n-    Collections.addAll(vmOpts, new String[] {\"-XX:-UseTLAB\",\n-                                             \"-XX:+UnlockDiagnosticVMOptions\",\n-                                             \"-XX:+VerifyDuringStartup\",\n-                                             \"-Xlog:gc+verify=debug\",\n-                                             \"-version\"});\n-\n-    System.out.print(\"Testing:\\n\" + JDKToolFinder.getJDKTool(\"java\"));\n-    for (int i = 0; i < vmOpts.size(); i += 1) {\n-      System.out.print(\" \" + vmOpts.get(i));\n-    }\n-    System.out.println();\n-\n-    ProcessBuilder pb =\n-      ProcessTools.createJavaProcessBuilder(vmOpts.toArray(new String[vmOpts.size()]));\n+    String[] flags = {\n+        \"-XX:-UseTLAB\",\n+        \"-XX:+UnlockDiagnosticVMOptions\",\n+        \"-XX:+VerifyDuringStartup\",\n+        \"-Xlog:gc+verify=debug\",\n+        \"-version\"};\n+\n+    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(true, flags);\n","filename":"test\/hotspot\/jtreg\/gc\/TestVerifyDuringStartup.java","additions":9,"deletions":25,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -155,1 +155,0 @@\n-   * @param useTestDotJavaDotOpts Use test.java.opts as part of the VM argument string\n@@ -158,1 +157,1 @@\n-  public static OutputAnalyzer runWhiteBoxTest(String[] vmargs, String classname, String[] arguments, boolean useTestDotJavaDotOpts) throws Exception {\n+  public static OutputAnalyzer runWhiteBoxTest(String[] vmargs, String classname, String[] arguments) throws Exception {\n@@ -167,10 +166,0 @@\n-    if (useTestDotJavaDotOpts) {\n-      \/\/ System.getProperty(\"test.java.opts\") is '' if no options is set,\n-      \/\/ we need to skip such a result\n-      String[] externalVMOpts = new String[0];\n-      if (System.getProperty(\"test.java.opts\") != null && System.getProperty(\"test.java.opts\").length() != 0) {\n-        externalVMOpts = System.getProperty(\"test.java.opts\").split(\" \");\n-      }\n-      finalargs.addAll(Arrays.asList(externalVMOpts));\n-    }\n-\n@@ -182,1 +171,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(finalargs.toArray(new String[0]));\n+    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(finalargs.toArray(String[]::new));\n@@ -190,1 +179,1 @@\n-    OutputAnalyzer output = runWhiteBoxTest(args, ErgoArgsPrinter.class.getName(), new String[] {}, false);\n+    OutputAnalyzer output = runWhiteBoxTest(args, ErgoArgsPrinter.class.getName(), new String[] {});\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestMaxHeapSizeTools.java","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n- *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n- * @run main\/othervm gc.arguments.TestUseCompressedOopsErgo -XX:+UseSerialGC\n+ *                                sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run driver gc.arguments.TestUseCompressedOopsErgo -XX:+UseSerialGC\n@@ -54,3 +54,3 @@\n- *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n- * @run main\/othervm gc.arguments.TestUseCompressedOopsErgo -XX:+UseParallelGC\n- * @run main\/othervm gc.arguments.TestUseCompressedOopsErgo -XX:+UseParallelGC -XX:-UseParallelOldGC\n+ *                                sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run driver gc.arguments.TestUseCompressedOopsErgo -XX:+UseParallelGC\n+ * @run driver gc.arguments.TestUseCompressedOopsErgo -XX:+UseParallelGC -XX:-UseParallelOldGC\n@@ -71,2 +71,2 @@\n- *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n- * @run main\/othervm gc.arguments.TestUseCompressedOopsErgo -XX:+UseG1GC\n+ *                                sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run driver gc.arguments.TestUseCompressedOopsErgo -XX:+UseG1GC\n@@ -87,2 +87,2 @@\n- *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n- * @run main\/othervm gc.arguments.TestUseCompressedOopsErgo -XX:+UseConcMarkSweepGC\n+ *                                sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run driver gc.arguments.TestUseCompressedOopsErgo -XX:+UseConcMarkSweepGC\n@@ -103,2 +103,2 @@\n- *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n- * @run main\/othervm gc.arguments.TestUseCompressedOopsErgo -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC\n+ *                                sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run driver gc.arguments.TestUseCompressedOopsErgo -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestUseCompressedOopsErgo.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    OutputAnalyzer output = runWhiteBoxTest(vmargs, DetermineMaxHeapForCompressedOops.class.getName(), new String[] {}, false);\n+    OutputAnalyzer output = runWhiteBoxTest(vmargs, DetermineMaxHeapForCompressedOops.class.getName(), new String[] {});\n@@ -81,1 +81,0 @@\n-   * @param useTestDotJavaDotOpts Use test.java.opts as part of the VM argument string\n@@ -84,1 +83,1 @@\n-  public static OutputAnalyzer runWhiteBoxTest(String[] vmargs, String classname, String[] arguments, boolean useTestDotJavaDotOpts) throws Exception {\n+  public static OutputAnalyzer runWhiteBoxTest(String[] vmargs, String classname, String[] arguments) throws Exception {\n@@ -93,10 +92,0 @@\n-    if (useTestDotJavaDotOpts) {\n-      \/\/ System.getProperty(\"test.java.opts\") is '' if no options is set,\n-      \/\/ we need to skip such a result\n-      String[] externalVMOpts = new String[0];\n-      if (System.getProperty(\"test.java.opts\") != null && System.getProperty(\"test.java.opts\").length() != 0) {\n-        externalVMOpts = System.getProperty(\"test.java.opts\").split(\" \");\n-      }\n-      finalargs.addAll(Arrays.asList(externalVMOpts));\n-    }\n-\n@@ -108,1 +97,1 @@\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(finalargs.toArray(new String[0]));\n+    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(finalargs.toArray(String[]::new));\n@@ -118,1 +107,1 @@\n-    return result.toArray(new String[0]);\n+    return result.toArray(String[]::new);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestUseCompressedOopsErgoTools.java","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n+ *                                sun.hotspot.WhiteBox$WhiteBoxPermission\n@@ -38,2 +38,2 @@\n- * @run main gc.g1.TestHumongousCodeCacheRoots\n-*\/\n+ * @run driver gc.g1.TestHumongousCodeCacheRoots\n+ *\/\n@@ -95,1 +95,0 @@\n-   * @param useTestDotJavaDotOpts Use test.java.opts as part of the VM argument string\n@@ -98,1 +97,1 @@\n-  public static OutputAnalyzer runWhiteBoxTest(String[] vmargs, String classname, String[] arguments, boolean useTestDotJavaDotOpts) throws Exception {\n+  public static OutputAnalyzer runWhiteBoxTest(String[] vmargs, String classname, String[] arguments) throws Exception {\n@@ -107,10 +106,0 @@\n-    if (useTestDotJavaDotOpts) {\n-      \/\/ System.getProperty(\"test.java.opts\") is '' if no options is set,\n-      \/\/ we need to skip such a result\n-      String[] externalVMOpts = new String[0];\n-      if (System.getProperty(\"test.java.opts\") != null && System.getProperty(\"test.java.opts\").length() != 0) {\n-        externalVMOpts = System.getProperty(\"test.java.opts\").split(\" \");\n-      }\n-      finalargs.addAll(Arrays.asList(externalVMOpts));\n-    }\n-\n@@ -122,1 +111,1 @@\n-    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(finalargs.toArray(new String[0]));\n+    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(finalargs.toArray(String[]::new));\n@@ -136,2 +125,1 @@\n-    runWhiteBoxTest(baseArguments, TestHumongousCodeCacheRootsHelper.class.getName(),\n-      new String[] {}, false);\n+    runWhiteBoxTest(baseArguments, TestHumongousCodeCacheRootsHelper.class.getName(), new String[] { });\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHumongousCodeCacheRoots.java","additions":6,"deletions":18,"binary":false,"changes":24,"status":"modified"}]}