{"files":[{"patch":"@@ -156,0 +156,1 @@\n+  NativeCall* call = NULL;\n@@ -158,1 +159,1 @@\n-      break;\n+      return;\n@@ -163,1 +164,1 @@\n-      NativeCall* call = nativeCall_at(_instructions->start() + pc_offset);\n+      call = nativeCall_at(_instructions->start() + pc_offset);\n@@ -173,1 +174,1 @@\n-      NativeCall* call = nativeCall_at(_instructions->start() + pc_offset);\n+      call = nativeCall_at(_instructions->start() + pc_offset);\n@@ -181,1 +182,1 @@\n-      NativeCall* call = nativeCall_at(_instructions->start() + pc_offset);\n+      call = nativeCall_at(_instructions->start() + pc_offset);\n@@ -188,2 +189,5 @@\n-      JVMCI_ERROR(\"invalid _next_call_type value\");\n-      break;\n+      JVMCI_ERROR(\"invalid _next_call_type value: %d\", _next_call_type);\n+      return;\n+  }\n+  if (!call->is_displacement_aligned()) {\n+    JVMCI_ERROR(\"unaligned displacement for call at offset %d\", pc_offset);\n","filename":"src\/hotspot\/cpu\/x86\/jvmciCodeInstaller_x86.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -244,0 +244,3 @@\n+bool NativeCall::is_displacement_aligned() {\n+  return (uintptr_t) displacement_address() % 4 == 0;\n+}\n@@ -267,2 +270,1 @@\n-  bool is_aligned = ((uintptr_t)displacement_address() + 0) \/ cache_line_size ==\n-                    ((uintptr_t)displacement_address() + 3) \/ cache_line_size;\n+  bool is_aligned = is_displacement_aligned();\n@@ -275,2 +277,2 @@\n-  } else if ((uintptr_t)instruction_address() \/ cache_line_size ==\n-             ((uintptr_t)instruction_address()+1) \/ cache_line_size) {\n+  } else if ((uintptr_t)instruction_address() \/ 4 ==\n+             ((uintptr_t)instruction_address()+1) \/ 4) {\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -166,2 +166,0 @@\n-  enum { cache_line_size = BytesPerWord };  \/\/ conservative estimate!\n-\n@@ -181,0 +179,2 @@\n+  \/\/ Returns whether the 4-byte displacement operand is 4-byte aligned.\n+  bool  is_displacement_aligned();\n@@ -183,1 +183,1 @@\n-  void  verify_alignment() { assert((intptr_t)addr_at(displacement_offset) % BytesPerInt == 0, \"must be aligned\"); }\n+  void  verify_alignment() { assert(is_displacement_aligned(), \"displacement of call is not aligned\"); }\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}