{"files":[{"patch":"@@ -315,0 +315,1 @@\n+          --disable-warnings-as-errors\n","filename":".github\/workflows\/submit.yml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3481,1 +3481,1 @@\n-    \/\/ Load markOop from object into displaced_header.\n+    \/\/ Load markWord from object into displaced_header.\n@@ -3496,1 +3496,1 @@\n-      __ tbnz(disp_hdr, exact_log2(markOop::monitor_value), object_has_monitor);\n+      __ tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n@@ -3499,2 +3499,2 @@\n-    \/\/ Set tmp to be (markOop of object | UNLOCK_VALUE).\n-    __ orr(tmp, disp_hdr, markOop::unlocked_value);\n+    \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n+    __ orr(tmp, disp_hdr, markWord::unlocked_value);\n@@ -3505,3 +3505,3 @@\n-    \/\/ Compare object markOop with an unlocked value (tmp) and if\n-    \/\/ equal exchange the stack address of our box with object markOop.\n-    \/\/ On failure disp_hdr contains the possibly locked markOop.\n+    \/\/ Compare object markWord with an unlocked value (tmp) and if\n+    \/\/ equal exchange the stack address of our box with object markWord.\n+    \/\/ On failure disp_hdr contains the possibly locked markWord.\n@@ -3521,1 +3521,1 @@\n-    \/\/ markOop of object (disp_hdr) with the stack pointer.\n+    \/\/ markWord of object (disp_hdr) with the stack pointer.\n@@ -3524,1 +3524,1 @@\n-    __ mov(tmp, (address) (~(os::vm_page_size()-1) | (uintptr_t)markOop::lock_mask_in_place));\n+    __ mov(tmp, (address) (~(os::vm_page_size()-1) | (uintptr_t)markWord::lock_mask_in_place));\n@@ -3539,1 +3539,1 @@\n-      __ add(tmp, disp_hdr, (ObjectMonitor::owner_offset_in_bytes()-markOop::monitor_value));\n+      __ add(tmp, disp_hdr, (ObjectMonitor::owner_offset_in_bytes()-markWord::monitor_value));\n@@ -3545,1 +3545,1 @@\n-      \/\/ markOop::monitor_value so use markOop::unused_mark which has the\n+      \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n@@ -3547,1 +3547,1 @@\n-      __ mov(tmp, (address)markOop::unused_mark().value());\n+      __ mov(tmp, (address)markWord::unused_mark().value());\n@@ -3587,1 +3587,1 @@\n-      __ tbnz(disp_hdr, exact_log2(markOop::monitor_value), object_has_monitor);\n+      __ tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n@@ -3591,1 +3591,1 @@\n-    \/\/ see the stack address of the basicLock in the markOop of the\n+    \/\/ see the stack address of the basicLock in the markWord of the\n@@ -3603,1 +3603,1 @@\n-      __ add(tmp, tmp, -markOop::monitor_value); \/\/ monitor\n+      __ add(tmp, tmp, -markWord::monitor_value); \/\/ monitor\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -85,1 +85,1 @@\n-  orr(hdr, hdr, markOop::unlocked_value);\n+  orr(hdr, hdr, markWord::unlocked_value);\n@@ -179,1 +179,1 @@\n-    mov(t1, (int32_t)(intptr_t)markOop::prototype().value());\n+    mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-  __ ands(zr, tmp, markOop::lock_mask_in_place);\n+  __ ands(zr, tmp, markWord::lock_mask_in_place);\n@@ -220,1 +220,1 @@\n-  __ orr(tmp, tmp, markOop::marked_value);\n+  __ orr(tmp, tmp, markWord::marked_value);\n@@ -619,1 +619,1 @@\n-  __ ands(zr, tmp1, markOop::lock_mask_in_place);\n+  __ ands(zr, tmp1, markWord::lock_mask_in_place);\n@@ -623,1 +623,1 @@\n-  __ orr(tmp1, tmp1, markOop::marked_value);\n+  __ orr(tmp1, tmp1, markWord::marked_value);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-  assert(markOop::age_shift == markOop::lock_bits + markOop::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n+  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n@@ -495,2 +495,2 @@\n-  andr(tmp_reg, swap_reg, markOop::biased_lock_mask_in_place);\n-  cmp(tmp_reg, markOop::biased_lock_pattern);\n+  andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);\n+  cmp(tmp_reg, markWord::biased_lock_pattern);\n@@ -503,1 +503,1 @@\n-  andr(tmp_reg, tmp_reg, ~((int) markOop::age_mask_in_place));\n+  andr(tmp_reg, tmp_reg, ~((int) markWord::age_mask_in_place));\n@@ -526,1 +526,1 @@\n-  andr(rscratch1, tmp_reg, markOop::biased_lock_mask_in_place);\n+  andr(rscratch1, tmp_reg, markWord::biased_lock_mask_in_place);\n@@ -538,1 +538,1 @@\n-  andr(rscratch1, tmp_reg, markOop::epoch_mask_in_place);\n+  andr(rscratch1, tmp_reg, markWord::epoch_mask_in_place);\n@@ -549,1 +549,1 @@\n-    mov(rscratch1, markOop::biased_lock_mask_in_place | markOop::age_mask_in_place | markOop::epoch_mask_in_place);\n+    mov(rscratch1, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n@@ -634,2 +634,2 @@\n-  andr(temp_reg, temp_reg, markOop::biased_lock_mask_in_place);\n-  cmp(temp_reg, markOop::biased_lock_pattern);\n+  andr(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);\n+  cmp(temp_reg, markWord::biased_lock_pattern);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3614,1 +3614,1 @@\n-      __ mov(rscratch1, (intptr_t)markOop::prototype().value());\n+      __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -104,1 +104,1 @@\n-    mov(tmp, (intptr_t)markOop::prototype());\n+    mov(tmp, (intptr_t)markWord::prototype());\n@@ -285,2 +285,2 @@\n-  assert(markOop::unlocked_value == 1, \"adjust this code\");\n-  tbnz(hdr, exact_log2(markOop::unlocked_value), fast_lock);\n+  assert(markWord::unlocked_value == 1, \"adjust this code\");\n+  tbnz(hdr, exact_log2(markWord::unlocked_value), fast_lock);\n@@ -315,1 +315,1 @@\n-  tst(hdr, markOop::unlocked_value);\n+  tst(hdr, markWord::unlocked_value);\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -998,2 +998,2 @@\n-    assert(markOop::unlocked_value == 1, \"adjust this code\");\n-    tbz(Rmark, exact_log2(markOop::unlocked_value), already_locked);\n+    assert(markWord::unlocked_value == 1, \"adjust this code\");\n+    tbz(Rmark, exact_log2(markWord::unlocked_value), already_locked);\n@@ -1012,1 +1012,1 @@\n-    tst(Rmark, markOop::unlocked_value);\n+    tst(Rmark, markWord::unlocked_value);\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1936,1 +1936,1 @@\n-  assert(markOop::age_shift == markOop::lock_bits + markOop::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n+  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n@@ -1958,2 +1958,2 @@\n-  andr(tmp_reg, swap_reg, (uintx)markOop::biased_lock_mask_in_place);\n-  cmp(tmp_reg, markOop::biased_lock_pattern);\n+  andr(tmp_reg, swap_reg, (uintx)markWord::biased_lock_mask_in_place);\n+  cmp(tmp_reg, markWord::biased_lock_pattern);\n@@ -1971,1 +1971,1 @@\n-  ands(tmp_reg, tmp_reg, ~((uintx) markOop::age_mask_in_place));\n+  ands(tmp_reg, tmp_reg, ~((uintx) markWord::age_mask_in_place));\n@@ -1973,1 +1973,1 @@\n-  bics(tmp_reg, tmp_reg, ((int) markOop::age_mask_in_place));\n+  bics(tmp_reg, tmp_reg, ((int) markWord::age_mask_in_place));\n@@ -1996,1 +1996,1 @@\n-  tst(tmp_reg, (uintx)markOop::biased_lock_mask_in_place);\n+  tst(tmp_reg, (uintx)markWord::biased_lock_mask_in_place);\n@@ -2008,1 +2008,1 @@\n-  tst(tmp_reg, (uintx)markOop::epoch_mask_in_place);\n+  tst(tmp_reg, (uintx)markWord::epoch_mask_in_place);\n@@ -2027,1 +2027,1 @@\n-  mov(tmp2, (markOop::biased_lock_mask_in_place | markOop::age_mask_in_place | markOop::epoch_mask_in_place));\n+  mov(tmp2, (markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place));\n@@ -2032,1 +2032,1 @@\n-  assert((markOop::biased_lock_mask_in_place | markOop::age_mask_in_place | markOop::epoch_mask_in_place) == 0x1ff, \"biased bitmasks changed\");\n+  assert((markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place) == 0x1ff, \"biased bitmasks changed\");\n@@ -2035,1 +2035,1 @@\n-  mov(swap_reg, AsmOperand(swap_reg, lsr, 23)); \/\/ markOop with thread bits cleared (for CAS)\n+  mov(swap_reg, AsmOperand(swap_reg, lsr, 23)); \/\/ markWord with thread bits cleared (for CAS)\n@@ -2065,1 +2065,1 @@\n-  mov(tmp2, (markOop::biased_lock_mask_in_place | markOop::age_mask_in_place | markOop::epoch_mask_in_place));\n+  mov(tmp2, (markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place));\n@@ -2100,1 +2100,1 @@\n-  mov(tmp2, (markOop::biased_lock_mask_in_place | markOop::age_mask_in_place | markOop::epoch_mask_in_place));\n+  mov(tmp2, (markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place));\n@@ -2131,2 +2131,2 @@\n-  andr(tmp_reg, tmp_reg, (uintx)markOop::biased_lock_mask_in_place);\n-  cmp(tmp_reg, markOop::biased_lock_pattern);\n+  andr(tmp_reg, tmp_reg, (uintx)markWord::biased_lock_mask_in_place);\n+  cmp(tmp_reg, markWord::biased_lock_pattern);\n@@ -3021,1 +3021,1 @@\n-  tst(Rmark, markOop::unlocked_value);\n+  tst(Rmark, markWord::unlocked_value);\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1231,2 +1231,2 @@\n-    assert(markOop::unlocked_value == 1, \"adjust this code\");\n-    __ tbz(Rtemp, exact_log2(markOop::unlocked_value), slow_case);\n+    assert(markWord::unlocked_value == 1, \"adjust this code\");\n+    __ tbz(Rtemp, exact_log2(markWord::unlocked_value), slow_case);\n@@ -1235,2 +1235,2 @@\n-      assert(is_power_of_2(markOop::biased_lock_bit_in_place), \"adjust this code\");\n-      __ tbnz(Rtemp, exact_log2(markOop::biased_lock_bit_in_place), slow_case);\n+      assert(is_power_of_2(markWord::biased_lock_bit_in_place), \"adjust this code\");\n+      __ tbnz(Rtemp, exact_log2(markWord::biased_lock_bit_in_place), slow_case);\n@@ -1240,1 +1240,1 @@\n-    __ ands(Rtemp, Rtemp, (uintx)markOop::hash_mask_in_place);\n+    __ ands(Rtemp, Rtemp, (uintx)markWord::hash_mask_in_place);\n@@ -1242,1 +1242,1 @@\n-    __ logical_shift_right(R0, Rtemp, markOop::hash_shift);\n+    __ logical_shift_right(R0, Rtemp, markWord::hash_shift);\n@@ -1245,2 +1245,2 @@\n-    __ bics(Rtemp, Rtemp, ~markOop::hash_mask_in_place);\n-    __ mov(R0, AsmOperand(Rtemp, lsr, markOop::hash_shift), ne);\n+    __ bics(Rtemp, Rtemp, ~markWord::hash_mask_in_place);\n+    __ mov(R0, AsmOperand(Rtemp, lsr, markWord::hash_shift), ne);\n@@ -1586,2 +1586,2 @@\n-    assert(markOop::unlocked_value == 1, \"adjust this code\");\n-    __ tbnz(mark, exact_log2(markOop::unlocked_value), fast_lock);\n+    assert(markWord::unlocked_value == 1, \"adjust this code\");\n+    __ tbnz(mark, exact_log2(markWord::unlocked_value), fast_lock);\n@@ -1613,1 +1613,1 @@\n-    __ tst(mark, markOop::unlocked_value);\n+    __ tst(mark, markWord::unlocked_value);\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -4610,1 +4610,1 @@\n-      __ mov_slow(Rtemp, (intptr_t)markOop::prototype());\n+      __ mov_slow(Rtemp, (intptr_t)markWord::prototype());\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -113,1 +113,1 @@\n-  ori(Rmark, Rmark, markOop::unlocked_value);\n+  ori(Rmark, Rmark, markWord::unlocked_value);\n@@ -118,1 +118,1 @@\n-  \/\/ Compare object markOop with Rmark and if equal exchange Rscratch with object markOop.\n+  \/\/ Compare object markWord with Rmark and if equal exchange Rscratch with object markWord.\n@@ -140,1 +140,1 @@\n-  load_const_optimized(R0, (~(os::vm_page_size()-1) | markOop::lock_mask_in_place));\n+  load_const_optimized(R0, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n@@ -174,1 +174,1 @@\n-  \/\/ the stack address of the basicLock in the markOop of the object.\n+  \/\/ the stack address of the basicLock in the markWord of the object.\n@@ -218,1 +218,1 @@\n-    load_const_optimized(t1, (intx)markOop::prototype());\n+    load_const_optimized(t1, (intx)markWord::prototype());\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -872,1 +872,1 @@\n-    \/\/ markOop displaced_header = obj->mark().set_unlocked();\n+    \/\/ markWord displaced_header = obj->mark().set_unlocked();\n@@ -894,1 +894,1 @@\n-    \/\/ markOop displaced_header = obj->mark().set_unlocked();\n+    \/\/ markWord displaced_header = obj->mark().set_unlocked();\n@@ -896,1 +896,1 @@\n-    \/\/ Load markOop from object into displaced_header.\n+    \/\/ Load markWord from object into displaced_header.\n@@ -903,2 +903,2 @@\n-    \/\/ Set displaced_header to be (markOop of object | UNLOCK_VALUE).\n-    ori(displaced_header, displaced_header, markOop::unlocked_value);\n+    \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n+    ori(displaced_header, displaced_header, markWord::unlocked_value);\n@@ -940,1 +940,1 @@\n-    \/\/ Check if owner is self by comparing the value in the markOop of object\n+    \/\/ Check if owner is self by comparing the value in the markWord of object\n@@ -945,1 +945,1 @@\n-    load_const_optimized(tmp, ~(os::vm_page_size()-1) | markOop::lock_mask_in_place);\n+    load_const_optimized(tmp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2092,1 +2092,1 @@\n-  assert(markOop::age_shift == markOop::lock_bits + markOop::biased_lock_bits,\n+  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits,\n@@ -2102,2 +2102,2 @@\n-  andi(temp_reg, mark_reg, markOop::biased_lock_mask_in_place);\n-  cmpwi(cr_reg, temp_reg, markOop::biased_lock_pattern);\n+  andi(temp_reg, mark_reg, markWord::biased_lock_mask_in_place);\n+  cmpwi(cr_reg, temp_reg, markWord::biased_lock_pattern);\n@@ -2108,1 +2108,1 @@\n-  load_const_optimized(temp2_reg, ~((int) markOop::age_mask_in_place));\n+  load_const_optimized(temp2_reg, ~((int) markWord::age_mask_in_place));\n@@ -2139,1 +2139,1 @@\n-  andi(temp2_reg, temp_reg, markOop::biased_lock_mask_in_place);\n+  andi(temp2_reg, temp_reg, markWord::biased_lock_mask_in_place);\n@@ -2153,1 +2153,1 @@\n-  int shift_amount = 64 - markOop::epoch_shift;\n+  int shift_amount = 64 - markWord::epoch_shift;\n@@ -2156,1 +2156,1 @@\n-  rldicl_(temp2_reg, temp_reg, shift_amount, 64 - markOop::epoch_bits);\n+  rldicl_(temp2_reg, temp_reg, shift_amount, 64 - markWord::epoch_bits);\n@@ -2166,3 +2166,3 @@\n-  andi(mark_reg, mark_reg, (markOop::biased_lock_mask_in_place |\n-                                markOop::age_mask_in_place |\n-                                markOop::epoch_mask_in_place));\n+  andi(mark_reg, mark_reg, (markWord::biased_lock_mask_in_place |\n+                                markWord::age_mask_in_place |\n+                                markWord::epoch_mask_in_place));\n@@ -2201,1 +2201,1 @@\n-  andi(temp2_reg, mark_reg, markOop::age_mask_in_place);\n+  andi(temp2_reg, mark_reg, markWord::age_mask_in_place);\n@@ -2238,1 +2238,1 @@\n-  andi(temp2_reg, mark_reg, markOop::age_mask_in_place);\n+  andi(temp2_reg, mark_reg, markWord::age_mask_in_place);\n@@ -2250,1 +2250,1 @@\n-  \/\/ reload markOop in mark_reg before continuing with lightweight locking\n+  \/\/ reload markWord in mark_reg before continuing with lightweight locking\n@@ -2278,1 +2278,1 @@\n-  andi(temp_reg, temp_reg, markOop::biased_lock_mask_in_place);\n+  andi(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);\n@@ -2280,1 +2280,1 @@\n-  cmpwi(cr_reg, temp_reg, markOop::biased_lock_pattern);\n+  cmpwi(cr_reg, temp_reg, markWord::biased_lock_pattern);\n@@ -2701,1 +2701,1 @@\n-  andi_(R0, mark_word, markOop::monitor_value);  \/\/ inflated vs stack-locked|neutral|biased\n+  andi_(R0, mark_word, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral|biased\n@@ -2720,2 +2720,2 @@\n-  andi(R0, mark_word, markOop::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-  cmpwi(flag, R0, markOop::unlocked_value);                \/\/ bits = 001 unlocked\n+  andi(R0, mark_word, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n+  cmpwi(flag, R0, markWord::unlocked_value);                \/\/ bits = 001 unlocked\n@@ -2758,1 +2758,1 @@\n-  int owner_offset = ObjectMonitor::owner_offset_in_bytes() - markOop::monitor_value;\n+  int owner_offset = ObjectMonitor::owner_offset_in_bytes() - markWord::monitor_value;\n@@ -2760,1 +2760,1 @@\n-  \/\/ Store non-null, using boxReg instead of (intptr_t)markOop::unused_mark().\n+  \/\/ Store non-null, using boxReg instead of (intptr_t)markWord::unused_mark().\n@@ -2805,1 +2805,1 @@\n-    andi_(R0, mark_word, markOop::monitor_value);\n+    andi_(R0, mark_word, markWord::monitor_value);\n@@ -2847,1 +2847,1 @@\n-  \/\/ Load markOop from object into displaced_header.\n+  \/\/ Load markWord from object into displaced_header.\n@@ -2872,1 +2872,1 @@\n-    andi_(temp, displaced_header, markOop::monitor_value);\n+    andi_(temp, displaced_header, markWord::monitor_value);\n@@ -2876,2 +2876,2 @@\n-  \/\/ Set displaced_header to be (markOop of object | UNLOCK_VALUE).\n-  ori(displaced_header, displaced_header, markOop::unlocked_value);\n+  \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n+  ori(displaced_header, displaced_header, markWord::unlocked_value);\n@@ -2885,1 +2885,1 @@\n-  \/\/ Compare object markOop with mark and if equal exchange scratch1 with object markOop.\n+  \/\/ Compare object markWord with mark and if equal exchange scratch1 with object markWord.\n@@ -2905,1 +2905,1 @@\n-  \/\/ Check if the owner is self by comparing the value in the markOop of object\n+  \/\/ Check if the owner is self by comparing the value in the markWord of object\n@@ -2908,1 +2908,1 @@\n-  load_const_optimized(temp, ~(os::vm_page_size()-1) | markOop::lock_mask_in_place);\n+  load_const_optimized(temp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);\n@@ -2933,1 +2933,1 @@\n-    addi(temp, displaced_header, ObjectMonitor::owner_offset_in_bytes()-markOop::monitor_value);\n+    addi(temp, displaced_header, ObjectMonitor::owner_offset_in_bytes()-markWord::monitor_value);\n@@ -2988,2 +2988,2 @@\n-    andi(R0, current_header, markOop::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-    cmpwi(flag, R0, markOop::unlocked_value);                     \/\/ bits = 001 unlocked\n+    andi(R0, current_header, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n+    cmpwi(flag, R0, markWord::unlocked_value);                     \/\/ bits = 001 unlocked\n@@ -3009,1 +3009,1 @@\n-    andi_(R0, current_header, markOop::monitor_value);\n+    andi_(R0, current_header, markWord::monitor_value);\n@@ -3014,1 +3014,1 @@\n-  \/\/ the stack address of the basicLock in the markOop of the object.\n+  \/\/ the stack address of the basicLock in the markWord of the object.\n@@ -3033,1 +3033,1 @@\n-    addi(current_header, current_header, -markOop::monitor_value); \/\/ monitor\n+    addi(current_header, current_header, -markWord::monitor_value); \/\/ monitor\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -3809,1 +3809,1 @@\n-      __ load_const_optimized(Rscratch, markOop::prototype(), R0);\n+      __ load_const_optimized(Rscratch, markWord::prototype(), R0);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -99,1 +99,1 @@\n-  z_oill(hdr, markOop::unlocked_value);\n+  z_oill(hdr, markWord::unlocked_value);\n@@ -118,1 +118,1 @@\n-  \/\/ 1) (hdr & markOop::lock_mask_in_place) == 0\n+  \/\/ 1) (hdr & markWord::lock_mask_in_place) == 0\n@@ -124,1 +124,1 @@\n-  \/\/ (hdr - Z_SP) & (~(page_size-1) | markOop::lock_mask_in_place)\n+  \/\/ (hdr - Z_SP) & (~(page_size-1) | markWord::lock_mask_in_place)\n@@ -130,1 +130,1 @@\n-  load_const_optimized(Z_R0_scratch, (~(os::vm_page_size()-1) | markOop::lock_mask_in_place));\n+  load_const_optimized(Z_R0_scratch, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n@@ -195,1 +195,1 @@\n-    load_const_optimized(t1, (intx)markOop::prototype());\n+    load_const_optimized(t1, (intx)markWord::prototype());\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  \/\/ hdr     : Used to hold locked markOop to be CASed into obj, contents destroyed.\n+  \/\/ hdr     : Used to hold locked markWord to be CASed into obj, contents destroyed.\n@@ -51,1 +51,1 @@\n-  \/\/ hdr     : Used to hold original markOop to be CASed back into obj, contents destroyed.\n+  \/\/ hdr     : Used to hold original markWord to be CASed back into obj, contents destroyed.\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -963,1 +963,1 @@\n-  \/\/ markOop displaced_header = obj->mark().set_unlocked();\n+  \/\/ markWord displaced_header = obj->mark().set_unlocked();\n@@ -982,1 +982,1 @@\n-  \/\/ markOop displaced_header = obj->mark().set_unlocked();\n+  \/\/ markWord displaced_header = obj->mark().set_unlocked();\n@@ -984,1 +984,1 @@\n-  \/\/ Load markOop from object into displaced_header.\n+  \/\/ Load markWord from object into displaced_header.\n@@ -991,2 +991,2 @@\n-  \/\/ Set displaced_header to be (markOop of object | UNLOCK_VALUE).\n-  z_oill(displaced_header, markOop::unlocked_value);\n+  \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n+  z_oill(displaced_header, markWord::unlocked_value);\n@@ -1016,1 +1016,1 @@\n-  \/\/ Check if owner is self by comparing the value in the markOop of object\n+  \/\/ Check if owner is self by comparing the value in the markWord of object\n@@ -1024,1 +1024,1 @@\n-  load_const_optimized(Z_R0, (~(os::vm_page_size()-1) | markOop::lock_mask_in_place));\n+  load_const_optimized(Z_R0, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3203,1 +3203,1 @@\n-  assert(markOop::age_shift == markOop::lock_bits + markOop::biased_lock_bits,\n+  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits,\n@@ -3206,2 +3206,2 @@\n-  z_nilf(temp_reg, markOop::biased_lock_mask_in_place);\n-  z_chi(temp_reg, markOop::biased_lock_pattern);\n+  z_nilf(temp_reg, markWord::biased_lock_mask_in_place);\n+  z_chi(temp_reg, markWord::biased_lock_pattern);\n@@ -3211,1 +3211,1 @@\n-  load_const_optimized(temp2_reg, ~((int) markOop::age_mask_in_place));\n+  load_const_optimized(temp2_reg, ~((int) markWord::age_mask_in_place));\n@@ -3237,1 +3237,1 @@\n-  z_tmll(temp_reg, markOop::biased_lock_mask_in_place);\n+  z_tmll(temp_reg, markWord::biased_lock_mask_in_place);\n@@ -3249,1 +3249,1 @@\n-  z_tmll(temp_reg, markOop::epoch_mask_in_place);\n+  z_tmll(temp_reg, markWord::epoch_mask_in_place);\n@@ -3259,2 +3259,2 @@\n-  z_nilf(mark_reg, markOop::biased_lock_mask_in_place | markOop::age_mask_in_place |\n-         markOop::epoch_mask_in_place);\n+  z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place |\n+         markWord::epoch_mask_in_place);\n@@ -3292,1 +3292,1 @@\n-  z_nilf(mark_reg, markOop::biased_lock_mask_in_place | markOop::age_mask_in_place | markOop::epoch_mask_in_place);\n+  z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n@@ -3353,1 +3353,1 @@\n-  z_nilf(temp_reg, markOop::biased_lock_mask_in_place);\n+  z_nilf(temp_reg, markWord::biased_lock_mask_in_place);\n@@ -3355,1 +3355,1 @@\n-  z_chi(temp_reg, markOop::biased_lock_pattern);\n+  z_chi(temp_reg, markWord::biased_lock_pattern);\n@@ -3368,1 +3368,1 @@\n-  \/\/ Load markOop from oop into mark.\n+  \/\/ Load markWord from oop into mark.\n@@ -3378,1 +3378,1 @@\n-    guarantee(Immediate::is_uimm16(markOop::monitor_value), \"must be half-word\");\n+    guarantee(Immediate::is_uimm16(markWord::monitor_value), \"must be half-word\");\n@@ -3380,1 +3380,1 @@\n-    z_nill(temp, markOop::monitor_value);\n+    z_nill(temp, markWord::monitor_value);\n@@ -3384,2 +3384,2 @@\n-  \/\/ Set mark to markOop | markOop::unlocked_value.\n-  z_oill(displacedHeader, markOop::unlocked_value);\n+  \/\/ Set mark to markWord | markWord::unlocked_value.\n+  z_oill(displacedHeader, markWord::unlocked_value);\n@@ -3393,1 +3393,1 @@\n-  \/\/ Compare object markOop with mark and if equal exchange scratch1 with object markOop.\n+  \/\/ Compare object markWord with mark and if equal exchange scratch1 with object markWord.\n@@ -3404,1 +3404,1 @@\n-  load_const_optimized(temp, (~(os::vm_page_size()-1) | markOop::lock_mask_in_place));\n+  load_const_optimized(temp, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n@@ -3415,1 +3415,1 @@\n-    Register monitor_tagged = displacedHeader; \/\/ Tagged with markOop::monitor_value.\n+    Register monitor_tagged = displacedHeader; \/\/ Tagged with markWord::monitor_value.\n@@ -3466,2 +3466,2 @@\n-    guarantee(Immediate::is_uimm16(markOop::monitor_value), \"must be half-word\");\n-    z_nill(currentHeader, markOop::monitor_value);\n+    guarantee(Immediate::is_uimm16(markWord::monitor_value), \"must be half-word\");\n+    z_nill(currentHeader, markWord::monitor_value);\n@@ -3472,1 +3472,1 @@\n-  \/\/ the stack address of the basicLock in the markOop of the object\n+  \/\/ the stack address of the basicLock in the markWord of the object\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3868,1 +3868,1 @@\n-                     (long)markOop::prototype());\n+                     (long)markWord::prototype());\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -100,1 +100,1 @@\n-  or3(Rmark, markOop::unlocked_value, Rmark);\n+  or3(Rmark, markWord::unlocked_value, Rmark);\n@@ -105,1 +105,1 @@\n-  \/\/ compare object markOop with Rmark and if equal exchange Rscratch with object markOop\n+  \/\/ compare object markWord with Rmark and if equal exchange Rscratch with object markWord\n@@ -147,1 +147,1 @@\n-  \/\/ the stack address of the basicLock in the markOop of the object\n+  \/\/ the stack address of the basicLock in the markWord of the object\n@@ -182,1 +182,1 @@\n-    set((intx)markOop::prototype(), t1);\n+    set((intx)markWord::prototype(), t1);\n","filename":"src\/hotspot\/cpu\/sparc\/c1_MacroAssembler_sparc.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/sparc\/frame_sparc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -1203,1 +1203,1 @@\n-    \/\/ load markOop from object into mark_reg\n+    \/\/ load markWord from object into mark_reg\n@@ -1214,2 +1214,2 @@\n-    \/\/ set mark reg to be (markOop of object | UNLOCK_VALUE)\n-    or3(mark_reg, markOop::unlocked_value, mark_reg);\n+    \/\/ set mark reg to be (markWord of object | UNLOCK_VALUE)\n+    or3(mark_reg, markWord::unlocked_value, mark_reg);\n@@ -1218,1 +1218,1 @@\n-    \/\/ compare and exchange object_addr, markOop | 1, stack address of basicLock\n+    \/\/ compare and exchange object_addr, markWord | 1, stack address of basicLock\n@@ -1227,1 +1227,1 @@\n-    \/\/ Check if owner is self by comparing the value in the markOop of object\n+    \/\/ Check if owner is self by comparing the value in the markWord of object\n@@ -1237,1 +1237,1 @@\n-    \/\/ FFFFF003\/FFFFFFFFFFFF003 is (markOop::lock_mask_in_place | -os::vm_page_size())\n+    \/\/ FFFFF003\/FFFFFFFFFFFF003 is (markWord::lock_mask_in_place | -os::vm_page_size())\n","filename":"src\/hotspot\/cpu\/sparc\/interp_masm_sparc.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2472,3 +2472,3 @@\n-  assert(markOop::age_shift == markOop::lock_bits + markOop::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n-  and3(mark_reg, markOop::biased_lock_mask_in_place, temp_reg);\n-  cmp_and_brx_short(temp_reg, markOop::biased_lock_pattern, Assembler::notEqual, Assembler::pn, cas_label);\n+  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n+  and3(mark_reg, markWord::biased_lock_mask_in_place, temp_reg);\n+  cmp_and_brx_short(temp_reg, markWord::biased_lock_pattern, Assembler::notEqual, Assembler::pn, cas_label);\n@@ -2480,1 +2480,1 @@\n-  andcc(temp_reg, ~((int) markOop::age_mask_in_place), temp_reg);\n+  andcc(temp_reg, ~((int) markWord::age_mask_in_place), temp_reg);\n@@ -2503,1 +2503,1 @@\n-  btst(markOop::biased_lock_mask_in_place, temp_reg);\n+  btst(markWord::biased_lock_mask_in_place, temp_reg);\n@@ -2515,1 +2515,1 @@\n-  delayed()->btst(markOop::epoch_mask_in_place, temp_reg);\n+  delayed()->btst(markWord::epoch_mask_in_place, temp_reg);\n@@ -2525,1 +2525,1 @@\n-                  markOop::biased_lock_mask_in_place | markOop::age_mask_in_place | markOop::epoch_mask_in_place,\n+                  markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place,\n@@ -2606,2 +2606,2 @@\n-  and3(temp_reg, markOop::biased_lock_mask_in_place, temp_reg);\n-  cmp(temp_reg, markOop::biased_lock_pattern);\n+  and3(temp_reg, markWord::biased_lock_mask_in_place, temp_reg);\n+  cmp(temp_reg, markWord::biased_lock_pattern);\n@@ -2623,1 +2623,1 @@\n-\/\/     Consider G2_thread, rsp, boxReg, or markOop::unused_mark()\n+\/\/     Consider G2_thread, rsp, boxReg, or markWord::unused_mark()\n@@ -2628,1 +2628,1 @@\n-\/\/     are responsible for setting box->dhw = NonZero (typically markOop::unused_mark()).\n+\/\/     are responsible for setting box->dhw = NonZero (typically markWord::unused_mark()).\n@@ -2670,2 +2670,2 @@\n-     \/\/ set Rmark to markOop | markOop::unlocked_value\n-     or3(Rmark, markOop::unlocked_value, Rmark);\n+     \/\/ set Rmark to markWord | markWord::unlocked_value\n+     or3(Rmark, markWord::unlocked_value, Rmark);\n@@ -2676,1 +2676,1 @@\n-     \/\/ compare object markOop with Rmark and if equal exchange Rscratch with object markOop\n+     \/\/ compare object markWord with Rmark and if equal exchange Rscratch with object markWord\n@@ -2720,1 +2720,1 @@\n-      or3(Rmark, markOop::unlocked_value, Rmark);\n+      or3(Rmark, markWord::unlocked_value, Rmark);\n@@ -2782,1 +2782,1 @@\n-      or3(Rmark, markOop::unlocked_value, Rmark);\n+      or3(Rmark, markWord::unlocked_value, Rmark);\n@@ -2836,1 +2836,1 @@\n-      \/\/    markOop::unused_mark(), G2_thread, RBox, RScratch, rsp, etc.\n+      \/\/    markWord::unused_mark(), G2_thread, RBox, RScratch, rsp, etc.\n@@ -2866,1 +2866,1 @@\n-     \/\/ the stack address of the basicLock in the markOop of the object\n+     \/\/ the stack address of the basicLock in the markWord of the object\n","filename":"src\/hotspot\/cpu\/sparc\/macroAssembler_sparc.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1836,1 +1836,1 @@\n-    \/\/ vm: see markOop.hpp.\n+    \/\/ vm: see markWord.hpp.\n@@ -1838,2 +1838,2 @@\n-    __ sethi(markOop::hash_mask, mask);\n-    __ btst(markOop::unlocked_value, header);\n+    __ sethi(markWord::hash_mask, mask);\n+    __ btst(markWord::unlocked_value, header);\n@@ -1844,1 +1844,1 @@\n-      __ btst(markOop::biased_lock_bit_in_place, header);\n+      __ btst(markWord::biased_lock_bit_in_place, header);\n@@ -1847,1 +1847,1 @@\n-    __ delayed()->or3(mask, markOop::hash_mask & 0x3ff, mask);\n+    __ delayed()->or3(mask, markWord::hash_mask & 0x3ff, mask);\n@@ -1850,1 +1850,1 @@\n-    __ srlx(header, markOop::hash_shift, hash);\n+    __ srlx(header, markWord::hash_shift, hash);\n","filename":"src\/hotspot\/cpu\/sparc\/sharedRuntime_sparc.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3521,1 +3521,1 @@\n-    __ set((intptr_t)markOop::prototype(), G4_scratch);\n+    __ set((intptr_t)markWord::prototype(), G4_scratch);\n","filename":"src\/hotspot\/cpu\/sparc\/templateTable_sparc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -62,1 +62,1 @@\n-  orptr(hdr, markOop::unlocked_value);\n+  orptr(hdr, markWord::unlocked_value);\n@@ -157,1 +157,1 @@\n-    movptr(Address(obj, oopDesc::mark_offset_in_bytes ()), (int32_t)(intptr_t)markOop::prototype().value());\n+    movptr(Address(obj, oopDesc::mark_offset_in_bytes ()), (int32_t)(intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -656,1 +656,1 @@\n-  __ testb(Address(tmp2, oopDesc::mark_offset_in_bytes()), markOop::marked_value);\n+  __ testb(Address(tmp2, oopDesc::mark_offset_in_bytes()), markWord::marked_value);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1121,1 +1121,1 @@\n-  assert(markOop::age_shift == markOop::lock_bits + markOop::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n+  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n@@ -1141,2 +1141,2 @@\n-  andptr(tmp_reg, markOop::biased_lock_mask_in_place);\n-  cmpptr(tmp_reg, markOop::biased_lock_pattern);\n+  andptr(tmp_reg, markWord::biased_lock_mask_in_place);\n+  cmpptr(tmp_reg, markWord::biased_lock_pattern);\n@@ -1168,1 +1168,1 @@\n-  andptr(header_reg, ~((int) markOop::age_mask_in_place));\n+  andptr(header_reg, ~((int) markWord::age_mask_in_place));\n@@ -1187,1 +1187,1 @@\n-  testptr(header_reg, markOop::biased_lock_mask_in_place);\n+  testptr(header_reg, markWord::biased_lock_mask_in_place);\n@@ -1199,1 +1199,1 @@\n-  testptr(header_reg, markOop::epoch_mask_in_place);\n+  testptr(header_reg, markWord::epoch_mask_in_place);\n@@ -1210,1 +1210,1 @@\n-         markOop::biased_lock_mask_in_place | markOop::age_mask_in_place | markOop::epoch_mask_in_place);\n+         markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n@@ -1310,2 +1310,2 @@\n-  andptr(temp_reg, markOop::biased_lock_mask_in_place);\n-  cmpptr(temp_reg, markOop::biased_lock_pattern);\n+  andptr(temp_reg, markWord::biased_lock_mask_in_place);\n+  cmpptr(temp_reg, markWord::biased_lock_pattern);\n@@ -1502,1 +1502,1 @@\n-  testptr(tmpReg, markOop::monitor_value);  \/\/ inflated vs stack-locked|neutral|biased\n+  testptr(tmpReg, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral|biased\n@@ -1517,2 +1517,2 @@\n-  andptr(tmpReg, markOop::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-  cmpptr(tmpReg, markOop::unlocked_value);            \/\/ bits = 001 unlocked\n+  andptr(tmpReg, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n+  cmpptr(tmpReg, markWord::unlocked_value);            \/\/ bits = 001 unlocked\n@@ -1544,1 +1544,1 @@\n-\/\/         tmpReg (ObjectMonitor address + markOop::monitor_value)\n+\/\/         tmpReg (ObjectMonitor address + markWord::monitor_value)\n@@ -1558,1 +1558,1 @@\n-  movptr(Address(boxReg, 0), (int32_t)intptr_t(markOop::unused_mark().value()));\n+  movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));\n@@ -1727,1 +1727,1 @@\n-      \/\/ set box->dhw = markOop::unused_mark()\n+      \/\/ set box->dhw = markWord::unused_mark()\n@@ -1729,1 +1729,1 @@\n-      movptr (Address(boxReg, 0), (int32_t)intptr_t(markOop::unused_mark().value()));\n+      movptr (Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));\n@@ -1771,1 +1771,1 @@\n-    testptr(tmpReg, markOop::monitor_value); \/\/ inflated vs stack-locked|neutral|biased\n+    testptr(tmpReg, markWord::monitor_value); \/\/ inflated vs stack-locked|neutral|biased\n@@ -1775,1 +1775,1 @@\n-    orptr (tmpReg, markOop::unlocked_value);\n+    orptr (tmpReg, markWord::unlocked_value);\n@@ -1801,1 +1801,1 @@\n-    \/\/ The object is inflated. tmpReg contains pointer to ObjectMonitor* + markOop::monitor_value\n+    \/\/ The object is inflated. tmpReg contains pointer to ObjectMonitor* + markWord::monitor_value\n@@ -1816,1 +1816,1 @@\n-    \/\/   set box->_displaced_header = markOop::unused_mark().  Any non-0 value suffices.\n+    \/\/   set box->_displaced_header = markWord::unused_mark().  Any non-0 value suffices.\n@@ -1881,1 +1881,1 @@\n-       movptr(Address(boxReg, 0), intptr_t(markOop::unused_mark().value()));  \/\/ results in ST-before-CAS penalty\n+       movptr(Address(boxReg, 0), intptr_t(markWord::unused_mark().value()));  \/\/ results in ST-before-CAS penalty\n@@ -1926,1 +1926,1 @@\n-    \/\/ Unconditionally set box->_displaced_header = markOop::unused_mark().\n+    \/\/ Unconditionally set box->_displaced_header = markWord::unused_mark().\n@@ -1928,1 +1928,1 @@\n-    movptr(Address(boxReg, 0), (int32_t)intptr_t(markOop::unused_mark().value()));\n+    movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));\n@@ -2001,6 +2001,6 @@\n-      movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));           \/\/ fetch markword\n-      andptr(tmpReg, markOop::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-      cmpptr(tmpReg, markOop::unlocked_value);            \/\/ bits = 001 unlocked\n-      jccb(Assembler::notEqual, L_regular_unlock);  \/\/ if !HLE RegularLock\n-      xend();                                       \/\/ otherwise end...\n-      jmp(DONE_LABEL);                              \/\/ ... and we're done\n+      movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); \/\/ fetch markword\n+      andptr(tmpReg, markWord::biased_lock_mask_in_place);              \/\/ look at 3 lock bits\n+      cmpptr(tmpReg, markWord::unlocked_value);                         \/\/ bits = 001 unlocked\n+      jccb(Assembler::notEqual, L_regular_unlock);                      \/\/ if !HLE RegularLock\n+      xend();                                                           \/\/ otherwise end...\n+      jmp(DONE_LABEL);                                                  \/\/ ... and we're done\n@@ -2011,4 +2011,4 @@\n-    cmpptr(Address(boxReg, 0), (int32_t)NULL_WORD); \/\/ Examine the displaced header\n-    jcc   (Assembler::zero, DONE_LABEL);            \/\/ 0 indicates recursive stack-lock\n-    movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));             \/\/ Examine the object's markword\n-    testptr(tmpReg, markOop::monitor_value);    \/\/ Inflated?\n+    cmpptr(Address(boxReg, 0), (int32_t)NULL_WORD);                   \/\/ Examine the displaced header\n+    jcc   (Assembler::zero, DONE_LABEL);                              \/\/ 0 indicates recursive stack-lock\n+    movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); \/\/ Examine the object's markword\n+    testptr(tmpReg, markWord::monitor_value);                         \/\/ Inflated?\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  __ testptr(result, markOop::unlocked_value);\n+  __ testptr(result, markWord::unlocked_value);\n@@ -67,1 +67,1 @@\n-    __ testptr(result, markOop::biased_lock_bit_in_place);\n+    __ testptr(result, markWord::biased_lock_bit_in_place);\n@@ -75,3 +75,3 @@\n-  \/\/ because it could be larger than 32 bits in a 64-bit vm. See markOop.hpp.\n-  __ shrptr(result, markOop::hash_shift);\n-  __ andptr(result, markOop::hash_mask);\n+  \/\/ because it could be larger than 32 bits in a 64-bit vm. See markWord.hpp.\n+  __ shrptr(result, markWord::hash_shift);\n+  __ andptr(result, markWord::hash_mask);\n@@ -79,1 +79,1 @@\n-  __ andptr(result, markOop::hash_mask_in_place);\n+  __ andptr(result, markWord::hash_mask_in_place);\n@@ -85,1 +85,1 @@\n-  __ shrptr(result, markOop::hash_shift);\n+  __ shrptr(result, markWord::hash_shift);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4106,1 +4106,1 @@\n-                (intptr_t)markOop::prototype().value()); \/\/ header\n+                (intptr_t)markWord::prototype().value()); \/\/ header\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-    markOop disp = lockee->mark().set_unlocked();\n+    markWord disp = lockee->mark().set_unlocked();\n@@ -280,1 +280,1 @@\n-    if (lockee->cas_set_mark((markOop)monitor, disp) != disp) {\n+    if (lockee->cas_set_mark((markWord)monitor, disp) != disp) {\n@@ -419,1 +419,1 @@\n-    markOop header = lock->displaced_header();\n+    markWord header = lock->displaced_header();\n@@ -424,1 +424,1 @@\n-      markOop old_header = markOop::encode(lock);\n+      markWord old_header = markWord::encode(lock);\n","filename":"src\/hotspot\/cpu\/zero\/cppInterpreter_zero.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-  AD.addInclude(AD._CPP_file, \"oops\/markOop.hpp\");\n+  AD.addInclude(AD._CPP_file, \"oops\/markWord.hpp\");\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -61,1 +61,1 @@\n-  return hc != markOop::no_hash ? hc : os::random();\n+  return hc != markWord::no_hash ? hc : os::random();\n","filename":"src\/hotspot\/share\/classfile\/altHashing.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2186,1 +2186,1 @@\n-        k->set_prototype_header(markOop::biased_locking_prototype());\n+        k->set_prototype_header(markWord::biased_locking_prototype());\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -753,1 +753,1 @@\n-  const size_t sz = heap_word_size(sizeof(SpoolBlock) + sizeof(markOop)\n+  const size_t sz = heap_word_size(sizeof(SpoolBlock) + sizeof(markWord)\n","filename":"src\/hotspot\/share\/gc\/cms\/compactibleFreeListSpace.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1014,1 +1014,1 @@\n-                                           oop old, markOop m,\n+                                           oop old, markWord m,\n@@ -7758,1 +7758,1 @@\n-  const markOop proto = markOop::prototype();\n+  const markWord proto = markWord::prototype();\n@@ -7858,1 +7858,1 @@\n-    cur->set_mark_raw(markOop::from_pointer(NULL));           \/\/ break off suffix\n+    cur->set_mark_raw(markWord::from_pointer(NULL));     \/\/ break off suffix\n@@ -7887,1 +7887,1 @@\n-          suffix_tail->set_mark_raw(markOop::from_pointer((void*)cur_overflow_list));\n+          suffix_tail->set_mark_raw(markWord::from_pointer((void*)cur_overflow_list));\n@@ -7889,1 +7889,1 @@\n-          suffix_tail->set_mark_raw(markOop::from_pointer(NULL));\n+          suffix_tail->set_mark_raw(markWord::from_pointer(NULL));\n@@ -7901,1 +7901,1 @@\n-  const markOop proto = markOop::prototype();\n+  const markWord proto = markWord::prototype();\n@@ -7924,1 +7924,1 @@\n-  p->set_mark_raw(markOop::from_pointer(_overflow_list));\n+  p->set_mark_raw(markWord::from_pointer(_overflow_list));\n@@ -7938,1 +7938,1 @@\n-      p->set_mark_raw(markOop::from_pointer((void*)cur_overflow_list));\n+      p->set_mark_raw(markWord::from_pointer((void*)cur_overflow_list));\n@@ -7940,1 +7940,1 @@\n-      p->set_mark_raw(markOop::from_pointer(NULL));\n+      p->set_mark_raw(markWord::from_pointer(NULL));\n@@ -7962,1 +7962,1 @@\n-void CMSCollector::preserve_mark_work(oop p, markOop m) {\n+void CMSCollector::preserve_mark_work(oop p, markWord m) {\n@@ -7972,1 +7972,1 @@\n-  markOop m = p->mark_raw();\n+  markWord m = p->mark_raw();\n@@ -7979,1 +7979,1 @@\n-  markOop m = p->mark_raw();\n+  markWord m = p->mark_raw();\n@@ -8020,1 +8020,1 @@\n-    assert(p->mark_raw() == markOop::prototype(),\n+    assert(p->mark_raw() == markWord::prototype(),\n@@ -8022,1 +8022,1 @@\n-    markOop m = _preserved_mark_stack.pop();\n+    markWord m = _preserved_mark_stack.pop();\n","filename":"src\/hotspot\/share\/gc\/cms\/concurrentMarkSweepGeneration.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -544,2 +544,2 @@\n-  Stack<oop, mtGC>     _preserved_oop_stack;\n-  Stack<markOop, mtGC> _preserved_mark_stack;\n+  Stack<oop, mtGC>      _preserved_oop_stack;\n+  Stack<markWord, mtGC> _preserved_mark_stack;\n@@ -752,1 +752,1 @@\n-  void preserve_mark_work(oop p, markOop m);\n+  void preserve_mark_work(oop p, markWord m);\n@@ -1144,1 +1144,1 @@\n-                          oop obj, markOop m, size_t word_sz);\n+                          oop obj, markWord m, size_t word_sz);\n","filename":"src\/hotspot\/share\/gc\/cms\/concurrentMarkSweepGeneration.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -59,1 +59,1 @@\n-  \/\/ For 64 bit compressed oops, the markOop encodes both the size and the\n+  \/\/ For 64 bit compressed oops, the markWord encodes both the size and the\n@@ -65,2 +65,2 @@\n-  markOop mark()     const volatile { return markOop((uintptr_t)_size); }\n-  void set_mark(markOop m)          { _size = (size_t)m.value(); }\n+  markWord mark()     const volatile { return markWord((uintptr_t)_size); }\n+  void set_mark(markWord m)          { _size = (size_t)m.value(); }\n@@ -107,1 +107,1 @@\n-    LP64_ONLY(if (UseCompressedOops) set_mark(markOop::set_size_and_free(sz)); else )\n+    LP64_ONLY(if (UseCompressedOops) set_mark(markWord::set_size_and_free(sz)); else )\n@@ -129,1 +129,1 @@\n-      set_mark(markOop::prototype());\n+      set_mark(markWord::prototype());\n","filename":"src\/hotspot\/share\/gc\/cms\/freeChunk.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1091,1 +1091,1 @@\n-                                             markOop m) {\n+                                             markWord m) {\n","filename":"src\/hotspot\/share\/gc\/cms\/parNewGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -389,1 +389,1 @@\n-                             oop obj, size_t obj_sz, markOop m);\n+                             oop obj, size_t obj_sz, markWord m);\n","filename":"src\/hotspot\/share\/gc\/cms\/parNewGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    markOop m = obj->mark_raw();\n+    markWord m = obj->mark_raw();\n@@ -113,1 +113,1 @@\n-      markOop m = obj->mark_raw();\n+      markWord m = obj->mark_raw();\n","filename":"src\/hotspot\/share\/gc\/cms\/parOopClosures.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"oops\/markOop.inline.hpp\"\n+#include \"oops\/markWord.inline.hpp\"\n@@ -65,1 +65,1 @@\n-markOop PromotionInfo::nextDisplacedHeader() {\n+markWord PromotionInfo::nextDisplacedHeader() {\n@@ -70,1 +70,1 @@\n-  markOop hdr = _spoolHead->displacedHdr[_firstIndex];\n+  markWord hdr = _spoolHead->displacedHdr[_firstIndex];\n@@ -96,1 +96,1 @@\n-  markOop mark = oop(trackOop)->mark_raw();\n+  markWord mark = oop(trackOop)->mark_raw();\n@@ -104,1 +104,1 @@\n-    \/\/ assert(mark == markOop::prototype(), \"consistency check\");\n+    \/\/ assert(mark == markWord::prototype(), \"consistency check\");\n@@ -126,1 +126,1 @@\n-void PromotionInfo::saveDisplacedHeader(markOop hdr) {\n+void PromotionInfo::saveDisplacedHeader(markWord hdr) {\n","filename":"src\/hotspot\/share\/gc\/cms\/promotionInfo.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  markOop*     displacedHdr;      \/\/ the displaced headers start here\n+  markWord*    displacedHdr;      \/\/ the displaced headers start here\n@@ -102,1 +102,1 @@\n-    return (size() * sizeof(HeapWord) - sizeof(*this)) \/ sizeof(markOop);\n+    return (size() * sizeof(HeapWord) - sizeof(*this)) \/ sizeof(markWord);\n@@ -108,1 +108,1 @@\n-    displacedHdr = (markOop*)&displacedHdr;\n+    displacedHdr = (markWord*)&displacedHdr;\n@@ -154,2 +154,2 @@\n-  markOop nextDisplacedHeader(); \/\/ get next header & forward spool pointer\n-  void    saveDisplacedHeader(markOop hdr);\n+  markWord nextDisplacedHeader(); \/\/ get next header & forward spool pointer\n+  void    saveDisplacedHeader(markWord hdr);\n","filename":"src\/hotspot\/share\/gc\/cms\/promotionInfo.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3141,1 +3141,1 @@\n-void G1CollectedHeap::preserve_mark_during_evac_failure(uint worker_id, oop obj, markOop m) {\n+void G1CollectedHeap::preserve_mark_during_evac_failure(uint worker_id, oop obj, markWord m) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -803,1 +803,1 @@\n-  void preserve_mark_during_evac_failure(uint worker_id, oop obj, markOop m);\n+  void preserve_mark_during_evac_failure(uint worker_id, oop obj, markWord m);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -291,1 +291,1 @@\n-  \/\/ word is set to markOop::marked_value - effectively removing\n+  \/\/ word is set to markWord::marked_value - effectively removing\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-      assert(object->mark_raw() == markOop::prototype_for_object(object) || \/\/ Correct mark\n+      assert(object->mark_raw() == markWord::prototype_for_object(object) || \/\/ Correct mark\n@@ -123,1 +123,1 @@\n-             p2i(object), object->mark_raw().value(), markOop::prototype_for_object(object).value());\n+             p2i(object), object->mark_raw().value(), markWord::prototype_for_object(object).value());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  markOop mark = obj->mark_raw();\n+  markWord mark = obj->mark_raw();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    assert(obj->mark_raw() == markOop::prototype_for_object(obj) || \/\/ Correct mark\n+    assert(obj->mark_raw() == markWord::prototype_for_object(obj) || \/\/ Correct mark\n@@ -83,1 +83,1 @@\n-           p2i(obj), obj->mark_raw().value(), markOop::prototype_for_object(obj).value());\n+           p2i(obj), obj->mark_raw().value(), markWord::prototype_for_object(obj).value());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -252,1 +252,1 @@\n-    markOop m = obj->mark_raw();\n+    markWord m = obj->mark_raw();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-InCSetState G1ParScanThreadState::next_state(InCSetState const state, markOop const m, uint& age) {\n+InCSetState G1ParScanThreadState::next_state(InCSetState const state, markWord const m, uint& age) {\n@@ -216,1 +216,1 @@\n-                                                 markOop const old_mark) {\n+                                                 markWord const old_mark) {\n@@ -274,1 +274,1 @@\n-      if (age < markOop::max_age) {\n+      if (age < markWord::max_age) {\n@@ -282,1 +282,1 @@\n-        markOop new_mark = old_mark.displaced_mark_helper().set_age(age);\n+        markWord new_mark = old_mark.displaced_mark_helper().set_age(age);\n@@ -356,1 +356,1 @@\n-oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markOop m) {\n+oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markWord m) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-  inline InCSetState next_state(InCSetState const state, markOop const m, uint& age);\n+  inline InCSetState next_state(InCSetState const state, markWord const m, uint& age);\n@@ -199,1 +199,1 @@\n-  oop copy_to_survivor_space(InCSetState const state, oop const obj, markOop const old_mark);\n+  oop copy_to_survivor_space(InCSetState const state, oop const obj, markWord const old_mark);\n@@ -210,1 +210,1 @@\n-  oop handle_evacuation_failure_par(oop obj, markOop m);\n+  oop handle_evacuation_failure_par(oop obj, markWord m);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    markOop m = obj->mark_raw();\n+    markWord m = obj->mark_raw();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-\/\/ pointers into markOops for use by adjust_pointers. If \"dest\" should overflow, we\n+\/\/ pointers into markWords for use by adjust_pointers. If \"dest\" should overflow, we\n","filename":"src\/hotspot\/share\/gc\/parallel\/psMarkSweepDecorator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  filler_oop->set_mark_raw(markOop::prototype());\n+  filler_oop->set_mark_raw(markWord::prototype());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionLAB.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -495,1 +495,1 @@\n-oop PSPromotionManager::oop_promotion_failed(oop obj, markOop obj_mark) {\n+oop PSPromotionManager::oop_promotion_failed(oop obj, markWord obj_mark) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-  oop oop_promotion_failed(oop obj, markOop obj_mark);\n+  oop oop_promotion_failed(oop obj, markWord obj_mark);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-  markOop test_mark = o->mark_raw();\n+  markWord test_mark = o->mark_raw();\n@@ -222,1 +222,1 @@\n-      \/\/ we're dealing with a markOop that cannot change, it is\n+      \/\/ we're dealing with a markWord that cannot change, it is\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-  assert(!NeverTenure || _tenuring_threshold == markOop::max_age + 1, \"Sanity\");\n+  assert(!NeverTenure || _tenuring_threshold == markWord::max_age + 1, \"Sanity\");\n@@ -731,2 +731,2 @@\n-    assert(MaxTenuringThreshold == 0 || MaxTenuringThreshold == markOop::max_age + 1,\n-           \"MaxTenuringThreshold should be 0 or markOop::max_age + 1, but is %d\", (int) MaxTenuringThreshold);\n+    assert(MaxTenuringThreshold == 0 || MaxTenuringThreshold == markWord::max_age + 1,\n+           \"MaxTenuringThreshold should be 0 or markWord::max_age + 1, but is %d\", (int) MaxTenuringThreshold);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -750,1 +750,1 @@\n-  \/\/ Mark sweep stores preserved markOops in to space, don't disturb!\n+  \/\/ Mark sweep stores preserved markWords in to space, don't disturb!\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-Stack<markOop, mtGC>          MarkSweep::_preserved_mark_stack;\n+Stack<markWord, mtGC>         MarkSweep::_preserved_mark_stack;\n@@ -154,1 +154,1 @@\n-\/\/ that it will go.  Note that the object that this markOop belongs to isn't\n+\/\/ that it will go.  Note that the object that this markWord belongs to isn't\n@@ -156,1 +156,1 @@\n-void MarkSweep::preserve_mark(oop obj, markOop mark) {\n+void MarkSweep::preserve_mark(oop obj, markWord mark) {\n@@ -206,1 +206,1 @@\n-    markOop mark  = _preserved_mark_stack.pop();\n+    markWord mark = _preserved_mark_stack.pop();\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -103,1 +103,1 @@\n-  static Stack<markOop, mtGC>                  _preserved_mark_stack;\n+  static Stack<markWord, mtGC>                 _preserved_mark_stack;\n@@ -140,1 +140,1 @@\n-  static void preserve_mark(oop p, markOop mark);\n+  static void preserve_mark(oop p, markWord mark);\n@@ -202,1 +202,1 @@\n-  markOop _mark;\n+  markWord _mark;\n@@ -205,1 +205,1 @@\n-  void init(oop obj, markOop mark) {\n+  void init(oop obj, markWord mark) {\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"oops\/markOop.inline.hpp\"\n+#include \"oops\/markWord.inline.hpp\"\n@@ -41,2 +41,2 @@\n-  markOop mark = obj->mark_raw();\n-  obj->set_mark_raw(markOop::prototype().set_marked());\n+  markWord mark = obj->mark_raw();\n+  obj->set_mark_raw(markWord::prototype().set_marked());\n@@ -84,2 +84,2 @@\n-    assert(new_obj != NULL ||                         \/\/ is forwarding ptr?\n-           obj->mark_raw() == markOop::prototype() || \/\/ not gc marked?\n+    assert(new_obj != NULL ||                          \/\/ is forwarding ptr?\n+           obj->mark_raw() == markWord::prototype() || \/\/ not gc marked?\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-    assert(MaxTenuringThreshold == 0 || MaxTenuringThreshold == markOop::max_age + 1,\n-           \"MaxTenuringThreshold should be 0 or markOop::max_age + 1, but is \" UINTX_FORMAT, MaxTenuringThreshold);\n+    assert(MaxTenuringThreshold == 0 || MaxTenuringThreshold == markWord::max_age + 1,\n+           \"MaxTenuringThreshold should be 0 or markWord::max_age + 1, but is \" UINTX_FORMAT, MaxTenuringThreshold);\n","filename":"src\/hotspot\/share\/gc\/shared\/ageTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -44,1 +44,1 @@\n-  enum { table_size = markOop::max_age + 1 };\n+  enum { table_size = markWord::max_age + 1 };\n","filename":"src\/hotspot\/share\/gc\/shared\/ageTable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -819,1 +819,1 @@\n-          range(0, markOop::max_age + 1)                                \\\n+          range(0, markWord::max_age + 1)                                   \\\n@@ -824,1 +824,1 @@\n-          range(0, markOop::max_age + 1)                                \\\n+          range(0, markWord::max_age + 1)                                   \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-                            oop obj, markOop m, size_t word_sz) {\n+                            oop obj, markWord m, size_t word_sz) {\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-  virtual oop par_promote(int thread_num, oop obj, markOop m, size_t word_sz);\n+  virtual oop par_promote(int thread_num, oop obj, markWord m, size_t word_sz);\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-    oopDesc::set_mark_raw(mem, markOop::prototype());\n+    oopDesc::set_mark_raw(mem, markWord::prototype());\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    const OopAndMarkOop elem = _stack.pop();\n+    const OopAndMarkWord elem = _stack.pop();\n@@ -42,1 +42,1 @@\n-  StackIterator<OopAndMarkOop, mtGC> iter(_stack);\n+  StackIterator<OopAndMarkWord, mtGC> iter(_stack);\n@@ -44,1 +44,1 @@\n-    OopAndMarkOop* elem = iter.next_addr();\n+    OopAndMarkWord* elem = iter.next_addr();\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  class OopAndMarkOop {\n+  class OopAndMarkWord {\n@@ -41,1 +41,1 @@\n-    markOop _m;\n+    markWord _m;\n@@ -44,1 +44,1 @@\n-    OopAndMarkOop(oop obj, markOop m) : _o(obj), _m(m) { }\n+    OopAndMarkWord(oop obj, markWord m) : _o(obj), _m(m) { }\n@@ -50,1 +50,1 @@\n-  typedef Stack<OopAndMarkOop, mtGC> OopAndMarkOopStack;\n+  typedef Stack<OopAndMarkWord, mtGC> OopAndMarkWordStack;\n@@ -52,1 +52,1 @@\n-  OopAndMarkOopStack _stack;\n+  OopAndMarkWordStack _stack;\n@@ -54,1 +54,1 @@\n-  inline bool should_preserve_mark(oop obj, markOop m) const;\n+  inline bool should_preserve_mark(oop obj, markWord m) const;\n@@ -58,2 +58,2 @@\n-  inline void push(oop obj, markOop m);\n-  inline void push_if_necessary(oop obj, markOop m);\n+  inline void push(oop obj, markWord m);\n+  inline void push_if_necessary(oop obj, markWord m);\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-inline bool PreservedMarks::should_preserve_mark(oop obj, markOop m) const {\n+inline bool PreservedMarks::should_preserve_mark(oop obj, markWord m) const {\n@@ -37,1 +37,1 @@\n-inline void PreservedMarks::push(oop obj, markOop m) {\n+inline void PreservedMarks::push(oop obj, markWord m) {\n@@ -39,1 +39,1 @@\n-  OopAndMarkOop elem(obj, m);\n+  OopAndMarkWord elem(obj, m);\n@@ -43,1 +43,1 @@\n-inline void PreservedMarks::push_if_necessary(oop obj, markOop m) {\n+inline void PreservedMarks::push_if_necessary(oop obj, markWord m) {\n@@ -75,1 +75,1 @@\n-    : _stack(OopAndMarkOopStack::default_segment_size(),\n+    : _stack(OopAndMarkWordStack::default_segment_size(),\n@@ -82,1 +82,1 @@\n-void PreservedMarks::OopAndMarkOop::set_mark() const {\n+void PreservedMarks::OopAndMarkWord::set_mark() const {\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -654,1 +654,1 @@\n-    t->set_mark_raw(markOop::prototype());\n+    t->set_mark_raw(markWord::prototype());\n@@ -661,1 +661,1 @@\n-    obj->set_mark_raw(markOop::prototype());\n+    obj->set_mark_raw(markWord::prototype());\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.inline.hpp\"\n+#include \"oops\/markWord.inline.hpp\"\n@@ -42,1 +42,1 @@\n-  markOop mark = obj->mark_raw();\n+  markWord mark = obj->mark_raw();\n@@ -57,1 +57,1 @@\n-  markOop mark = obj->mark_raw();\n+  markWord mark = obj->mark_raw();\n@@ -77,1 +77,1 @@\n-  markOop old_mark = obj->mark_raw();\n+  markWord old_mark = obj->mark_raw();\n@@ -82,2 +82,2 @@\n-  markOop new_mark = markOop::encode_pointer_as_mark(update);\n-  markOop prev_mark = obj->cas_set_mark_raw(new_mark, old_mark);\n+  markWord new_mark = markWord::encode_pointer_as_mark(update);\n+  markWord prev_mark = obj->cas_set_mark_raw(new_mark, old_mark);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    const markOop mark = java_string->mark();\n+    const markWord mark = java_string->mark();\n@@ -53,1 +53,1 @@\n-    if (mark == markOop::INFLATING() || mark.has_displaced_mark_helper()) {\n+    if (mark == markWord::INFLATING() || mark.has_displaced_mark_helper()) {\n@@ -58,1 +58,1 @@\n-    markOop new_mark = mark.incr_age();\n+    markWord new_mark = mark.incr_age();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahStringDedup.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -667,3 +667,3 @@\n-        uintptr_t epoch_mask_in_place = (uintptr_t)markOop::epoch_mask_in_place;\n-        markOop mark = rcvr->mark();\n-        intptr_t hash = (intptr_t) markOop::no_hash;\n+        uintptr_t epoch_mask_in_place = (uintptr_t)markWord::epoch_mask_in_place;\n+        markWord mark = rcvr->mark();\n+        intptr_t hash = (intptr_t) markWord::no_hash;\n@@ -676,2 +676,2 @@\n-            (((uintptr_t)rcvr->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) &\n-            ~((uintptr_t) markOop::age_mask_in_place);\n+            (((uintptr_t)rcvr->klass()->prototype_header().value() | thread_ident) ^ mark.value()) &\n+            ~((uintptr_t) markWord::age_mask_in_place);\n@@ -685,1 +685,1 @@\n-          } else if ((anticipated_bias_locking_value & markOop::biased_lock_mask_in_place) != 0) {\n+          } else if ((anticipated_bias_locking_value & markWord::biased_lock_mask_in_place) != 0) {\n@@ -687,3 +687,3 @@\n-            markOop header = rcvr->klass()->prototype_header();\n-            if (hash != markOop::no_hash) {\n-              header = header->copy_set_hash(hash);\n+            markWord header = rcvr->klass()->prototype_header();\n+            if (hash != markWord::no_hash) {\n+              header = header.copy_set_hash(hash);\n@@ -697,3 +697,3 @@\n-            markOop new_header = (markOop) ( (intptr_t) rcvr->klass()->prototype_header() | thread_ident);\n-            if (hash != markOop::no_hash) {\n-              new_header = new_header->copy_set_hash(hash);\n+            markWord new_header( (intptr_t) rcvr->klass()->prototype_header().value() | thread_ident);\n+            if (hash != markWord::no_hash) {\n+              new_header = new_header.copy_set_hash(hash);\n@@ -711,5 +711,5 @@\n-            markOop header = (markOop) ((uintptr_t) mark &\n-                                        ((uintptr_t)markOop::biased_lock_mask_in_place |\n-                                         (uintptr_t)markOop::age_mask_in_place | epoch_mask_in_place));\n-            if (hash != markOop::no_hash) {\n-              header = header->copy_set_hash(hash);\n+            markWord header(mark.value() &\n+                            ((uintptr_t)markWord::biased_lock_mask_in_place |\n+                             (uintptr_t)markWord::age_mask_in_place | epoch_mask_in_place));\n+            if (hash != markWord::no_hash) {\n+              header = header.copy_set_hash(hash);\n@@ -717,1 +717,1 @@\n-            markOop new_header = (markOop) ((uintptr_t) header | thread_ident);\n+            markWord new_header = (header.value() | thread_ident);\n@@ -719,1 +719,1 @@\n-            DEBUG_ONLY(mon->lock()->set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)\n+            DEBUG_ONLY(mon->lock()->set_displaced_header(markWord((uintptr_t) 0xdeaddead));)\n@@ -733,1 +733,1 @@\n-          markOop displaced = rcvr->mark().set_unlocked();\n+          markWord displaced = rcvr->mark().set_unlocked();\n@@ -736,1 +736,1 @@\n-          if (call_vm || rcvr->cas_set_mark((markOop)mon, displaced) != displaced) {\n+          if (call_vm || rcvr->cas_set_mark(markWord::from_pointer(mon), displaced) != displaced) {\n@@ -738,2 +738,2 @@\n-            if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {\n-              mon->lock()->set_displaced_header(NULL);\n+            if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+              mon->lock()->set_displaced_header(markWord::from_pointer(NULL));\n@@ -852,1 +852,1 @@\n-      uintptr_t epoch_mask_in_place = (uintptr_t)markOop::epoch_mask_in_place;\n+      uintptr_t epoch_mask_in_place = (uintptr_t)markWord::epoch_mask_in_place;\n@@ -854,2 +854,2 @@\n-      markOop mark = lockee->mark();\n-      intptr_t hash = (intptr_t) markOop::no_hash;\n+      markWord mark = lockee->mark();\n+      intptr_t hash = (intptr_t) markWord::no_hash;\n@@ -862,2 +862,2 @@\n-          (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) &\n-          ~((uintptr_t) markOop::age_mask_in_place);\n+          (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ mark.value()) &\n+          ~((uintptr_t) markWord::age_mask_in_place);\n@@ -871,1 +871,1 @@\n-        } else if ((anticipated_bias_locking_value & markOop::biased_lock_mask_in_place) != 0) {\n+        } else if ((anticipated_bias_locking_value & markWord::biased_lock_mask_in_place) != 0) {\n@@ -873,3 +873,3 @@\n-          markOop header = lockee->klass()->prototype_header();\n-          if (hash != markOop::no_hash) {\n-            header = header->copy_set_hash(hash);\n+          markWord header = lockee->klass()->prototype_header();\n+          if (hash != markWord::no_hash) {\n+            header = header.copy_set_hash(hash);\n@@ -884,3 +884,3 @@\n-          markOop new_header = (markOop) ( (intptr_t) lockee->klass()->prototype_header() | thread_ident);\n-          if (hash != markOop::no_hash) {\n-                new_header = new_header->copy_set_hash(hash);\n+          markWord new_header( (intptr_t) lockee->klass()->prototype_header().value() | thread_ident);\n+          if (hash != markWord::no_hash) {\n+                new_header = new_header.copy_set_hash(hash);\n@@ -898,4 +898,4 @@\n-          markOop header = (markOop) ((uintptr_t) mark & ((uintptr_t)markOop::biased_lock_mask_in_place |\n-                                                          (uintptr_t)markOop::age_mask_in_place | epoch_mask_in_place));\n-          if (hash != markOop::no_hash) {\n-            header = header->copy_set_hash(hash);\n+          markWord header(mark.value() & ((uintptr_t)markWord::biased_lock_mask_in_place |\n+                                          (uintptr_t)markWord::age_mask_in_place | epoch_mask_in_place));\n+          if (hash != markWord::no_hash) {\n+            header = header.copy_set_hash(hash);\n@@ -903,1 +903,1 @@\n-          markOop new_header = (markOop) ((uintptr_t) header | thread_ident);\n+          markWord new_header(header.value() | thread_ident);\n@@ -905,1 +905,1 @@\n-          DEBUG_ONLY(entry->lock()->set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)\n+          DEBUG_ONLY(entry->lock()->set_displaced_header(markWord((uintptr_t) 0xdeaddead));)\n@@ -919,1 +919,1 @@\n-        markOop displaced = lockee->mark().set_unlocked();\n+        markWord displaced = lockee->mark().set_unlocked();\n@@ -922,1 +922,1 @@\n-        if (call_vm || lockee->cas_set_mark((markOop)entry, displaced) != displaced) {\n+        if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n@@ -924,2 +924,2 @@\n-          if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {\n-            entry->lock()->set_displaced_header(NULL);\n+          if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+            entry->lock()->set_displaced_header(markWord::from_pointer(NULL));\n@@ -1792,1 +1792,1 @@\n-          uintptr_t epoch_mask_in_place = (uintptr_t)markOop::epoch_mask_in_place;\n+          uintptr_t epoch_mask_in_place = (uintptr_t)markWord::epoch_mask_in_place;\n@@ -1794,2 +1794,2 @@\n-          markOop mark = lockee->mark();\n-          intptr_t hash = (intptr_t) markOop::no_hash;\n+          markWord mark = lockee->mark();\n+          intptr_t hash = (intptr_t) markWord::no_hash;\n@@ -1802,2 +1802,2 @@\n-              (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) &\n-              ~((uintptr_t) markOop::age_mask_in_place);\n+              (((uintptr_t)lockee->klass()->prototype_header().value() | thread_ident) ^ mark.value()) &\n+              ~((uintptr_t) markWord::age_mask_in_place);\n@@ -1812,1 +1812,1 @@\n-            else if ((anticipated_bias_locking_value & markOop::biased_lock_mask_in_place) != 0) {\n+            else if ((anticipated_bias_locking_value & markWord::biased_lock_mask_in_place) != 0) {\n@@ -1814,3 +1814,3 @@\n-              markOop header = lockee->klass()->prototype_header();\n-              if (hash != markOop::no_hash) {\n-                header = header->copy_set_hash(hash);\n+              markWord header = lockee->klass()->prototype_header();\n+              if (hash != markWord::no_hash) {\n+                header = header.copy_set_hash(hash);\n@@ -1825,3 +1825,3 @@\n-              markOop new_header = (markOop) ( (intptr_t) lockee->klass()->prototype_header() | thread_ident);\n-              if (hash != markOop::no_hash) {\n-                new_header = new_header->copy_set_hash(hash);\n+              markWord new_header( (intptr_t) lockee->klass()->prototype_header().value() | thread_ident);\n+              if (hash != markWord::no_hash) {\n+                new_header = new_header.copy_set_hash(hash);\n@@ -1840,5 +1840,5 @@\n-              markOop header = (markOop) ((uintptr_t) mark & ((uintptr_t)markOop::biased_lock_mask_in_place |\n-                                                              (uintptr_t)markOop::age_mask_in_place |\n-                                                              epoch_mask_in_place));\n-              if (hash != markOop::no_hash) {\n-                header = header->copy_set_hash(hash);\n+              markWord header(mark.value() & ((uintptr_t)markWord::biased_lock_mask_in_place |\n+                                              (uintptr_t)markWord::age_mask_in_place |\n+                                              epoch_mask_in_place));\n+              if (hash != markWord::no_hash) {\n+                header = header.copy_set_hash(hash);\n@@ -1846,1 +1846,1 @@\n-              markOop new_header = (markOop) ((uintptr_t) header | thread_ident);\n+              markWord new_header(header.value() | thread_ident);\n@@ -1848,1 +1848,1 @@\n-              DEBUG_ONLY(entry->lock()->set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)\n+              DEBUG_ONLY(entry->lock()->set_displaced_header(markWord((uintptr_t) 0xdeaddead));)\n@@ -1862,1 +1862,1 @@\n-            markOop displaced = lockee->mark().set_unlocked();\n+            markWord displaced = lockee->mark().set_unlocked();\n@@ -1865,1 +1865,1 @@\n-            if (call_vm || lockee->cas_set_mark((markOop)entry, displaced) != displaced) {\n+            if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n@@ -1867,2 +1867,2 @@\n-              if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {\n-                entry->lock()->set_displaced_header(NULL);\n+              if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+                entry->lock()->set_displaced_header(markWord::from_pointer(NULL));\n@@ -1891,1 +1891,1 @@\n-            markOop header = lock->displaced_header();\n+            markWord header = lock->displaced_header();\n@@ -1896,2 +1896,2 @@\n-              if (header != NULL || call_vm) {\n-                markOop old_header = markOop::encode(lock);\n+              if (header.to_pointer() != NULL || call_vm) {\n+                markWord old_header = markWord::encode(lock);\n@@ -2183,1 +2183,1 @@\n-                result->set_mark(markOop::prototype());\n+                result->set_mark(markWord::prototype());\n@@ -3030,1 +3030,1 @@\n-          markOop header = lock->displaced_header();\n+          markWord header = lock->displaced_header();\n@@ -3035,2 +3035,2 @@\n-            if (header != NULL) {\n-              markOop old_header = markOop::encode(lock);\n+            if (header.to_pointer() != NULL) {\n+              markWord old_header = markWord::encode(lock);\n@@ -3105,1 +3105,1 @@\n-            markOop header = lock->displaced_header();\n+            markWord header = lock->displaced_header();\n@@ -3111,2 +3111,2 @@\n-              if (header != NULL) {\n-                markOop old_header = markOop::encode(lock);\n+              if (header.to_pointer() != NULL) {\n+                markWord old_header = markWord::encode(lock);\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeInterpreter.cpp","additions":78,"deletions":78,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-  sample_object->set_mark(markOop::from_pointer(leak_context_edge));\n+  sample_object->set_mark(markWord::from_pointer(leak_context_edge));\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeStore.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -39,1 +39,1 @@\n-  class ObjectSampleMarkOop : public ResourceObj {\n+  class ObjectSampleMarkWord : public ResourceObj {\n@@ -43,4 +43,4 @@\n-    markOop _mark_oop;\n-    ObjectSampleMarkOop(const oop obj,\n-                        const markOop mark_oop) : _obj(obj),\n-                                                  _mark_oop(mark_oop) {}\n+    markWord _mark_word;\n+    ObjectSampleMarkWord(const oop obj,\n+                         const markWord mark_oop) : _obj(obj),\n+                                                    _mark_word(mark_oop) {}\n@@ -48,1 +48,1 @@\n-    ObjectSampleMarkOop() : _obj(NULL), _mark_oop(markOop::zero()) {}\n+    ObjectSampleMarkWord() : _obj(NULL), _mark_word(markWord::zero()) {}\n@@ -51,1 +51,1 @@\n-  GrowableArray<ObjectSampleMarkOop>* _store;\n+  GrowableArray<ObjectSampleMarkWord>* _store;\n@@ -55,1 +55,1 @@\n-       _store(new GrowableArray<ObjectSampleMarkOop>(16)) {}\n+       _store(new GrowableArray<ObjectSampleMarkWord>(16)) {}\n@@ -58,1 +58,1 @@\n-    \/\/ restore the saved, original, markOop for sample objects\n+    \/\/ restore the saved, original, markWord for sample objects\n@@ -60,3 +60,3 @@\n-      ObjectSampleMarkOop sample_oop = _store->pop();\n-      sample_oop._obj->set_mark(sample_oop._mark_oop);\n-      assert(sample_oop._obj->mark() == sample_oop._mark_oop, \"invariant\");\n+      ObjectSampleMarkWord sample_oop = _store->pop();\n+      sample_oop._obj->set_mark(sample_oop._mark_word);\n+      assert(sample_oop._obj->mark() == sample_oop._mark_word, \"invariant\");\n@@ -68,2 +68,2 @@\n-    \/\/ save the original markOop\n-    _store->push(ObjectSampleMarkOop(obj, obj->mark()));\n+    \/\/ save the original markWord\n+    _store->push(ObjectSampleMarkWord(obj, obj->mark()));\n@@ -75,2 +75,2 @@\n-    assert(NULL == markOop::INFLATING().to_pointer(), \"invariant\");\n-    obj->set_mark(markOop::INFLATING());\n+    assert(NULL == markWord::INFLATING().to_pointer(), \"invariant\");\n+    obj->set_mark(markWord::INFLATING());\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/objectSampleMarker.hpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/eventEmitter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-MarkOopContext::MarkOopContext() : _obj(NULL), _mark_oop(markOop::zero()) {}\n+MarkWordContext::MarkWordContext() : _obj(NULL), _mark_word(markWord::zero()) {}\n@@ -32,2 +32,2 @@\n-MarkOopContext::MarkOopContext(const oop obj) : _obj(obj), _mark_oop(obj->mark()) {\n-  assert(_obj->mark() == _mark_oop, \"invariant\");\n+MarkWordContext::MarkWordContext(const oop obj) : _obj(obj), _mark_word(obj->mark()) {\n+  assert(_obj->mark() == _mark_word, \"invariant\");\n@@ -39,3 +39,3 @@\n-  assert(markOop::zero() == markOop::INFLATING(), \"invariant\");\n-  _obj->set_mark(markOop::INFLATING());\n-  assert(markOop::zero() == obj->mark(), \"invariant\");\n+  assert(markWord::zero() == markWord::INFLATING(), \"invariant\");\n+  _obj->set_mark(markWord::INFLATING());\n+  assert(markWord::zero() == obj->mark(), \"invariant\");\n@@ -44,1 +44,1 @@\n-MarkOopContext::~MarkOopContext() {\n+MarkWordContext::~MarkWordContext() {\n@@ -46,2 +46,2 @@\n-    _obj->set_mark(_mark_oop);\n-    assert(_obj->mark() == _mark_oop, \"invariant\");\n+    _obj->set_mark(_mark_word);\n+    assert(_obj->mark() == _mark_word, \"invariant\");\n@@ -51,2 +51,2 @@\n-MarkOopContext::MarkOopContext(const MarkOopContext& rhs) : _obj(NULL), _mark_oop(markOop::zero()) {\n-  swap(const_cast<MarkOopContext&>(rhs));\n+MarkWordContext::MarkWordContext(const MarkWordContext& rhs) : _obj(NULL), _mark_word(markWord::zero()) {\n+  swap(const_cast<MarkWordContext&>(rhs));\n@@ -55,1 +55,1 @@\n-void MarkOopContext::operator=(MarkOopContext rhs) {\n+void MarkWordContext::operator=(MarkWordContext rhs) {\n@@ -59,1 +59,1 @@\n-void MarkOopContext::swap(MarkOopContext& rhs) {\n+void MarkWordContext::swap(MarkWordContext& rhs) {\n@@ -61,1 +61,1 @@\n-  markOop temp_mark_oop = rhs._mark_oop;\n+  markWord temp_mark_word = rhs._mark_word;\n@@ -63,1 +63,1 @@\n-  rhs._mark_oop = _mark_oop;\n+  rhs._mark_word = _mark_word;\n@@ -65,1 +65,1 @@\n-  _mark_oop = temp_mark_oop;\n+  _mark_word = temp_mark_word;\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/saveRestore.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -81,1 +81,1 @@\n-class MarkOopContext {\n+class MarkWordContext {\n@@ -84,2 +84,2 @@\n-  markOop _mark_oop;\n-  void swap(MarkOopContext& rhs);\n+  markWord _mark_word;\n+  void swap(MarkWordContext& rhs);\n@@ -87,5 +87,5 @@\n-  MarkOopContext();\n-  MarkOopContext(const oop obj);\n-  MarkOopContext(const MarkOopContext& rhs);\n-  void operator=(MarkOopContext rhs);\n-  ~MarkOopContext();\n+  MarkWordContext();\n+  MarkWordContext(const oop obj);\n+  MarkWordContext(const MarkWordContext& rhs);\n+  void operator=(MarkWordContext rhs);\n+  ~MarkWordContext();\n@@ -94,1 +94,1 @@\n-typedef SaveRestore<oop, ContextStore<oop, MarkOopContext> > SaveRestoreMarkOops;\n+typedef SaveRestore<oop, ContextStore<oop, MarkWordContext> > SaveRestoreMarkWord;\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/saveRestore.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  volatile_nonstatic_field(BasicLock,          _displaced_header,                      markOop)                                      \\\n+  volatile_nonstatic_field(BasicLock,          _displaced_header,                      markWord)                                     \\\n@@ -203,1 +203,1 @@\n-  nonstatic_field(Klass,                       _prototype_header,                             markOop)                               \\\n+  nonstatic_field(Klass,                       _prototype_header,                             markWord)                              \\\n@@ -261,1 +261,1 @@\n-  volatile_nonstatic_field(oopDesc,            _mark,                                         markOop)                               \\\n+  volatile_nonstatic_field(oopDesc,            _mark,                                         markWord)                              \\\n@@ -570,1 +570,1 @@\n-  declare_constant(markOop::no_hash)                                  \\\n+  declare_constant(markWord::no_hash)                                     \\\n@@ -602,1 +602,1 @@\n-  declare_constant(markOop::hash_shift)                               \\\n+  declare_constant(markWord::hash_shift)                                  \\\n@@ -604,5 +604,5 @@\n-  declare_constant(markOop::biased_lock_mask_in_place)                \\\n-  declare_constant(markOop::age_mask_in_place)                        \\\n-  declare_constant(markOop::epoch_mask_in_place)                      \\\n-  declare_constant(markOop::hash_mask)                                \\\n-  declare_constant(markOop::hash_mask_in_place)                       \\\n+  declare_constant(markWord::biased_lock_mask_in_place)                   \\\n+  declare_constant(markWord::age_mask_in_place)                           \\\n+  declare_constant(markWord::epoch_mask_in_place)                         \\\n+  declare_constant(markWord::hash_mask)                                   \\\n+  declare_constant(markWord::hash_mask_in_place)                          \\\n@@ -610,2 +610,2 @@\n-  declare_constant(markOop::unlocked_value)                           \\\n-  declare_constant(markOop::biased_lock_pattern)                      \\\n+  declare_constant(markWord::unlocked_value)                              \\\n+  declare_constant(markWord::biased_lock_pattern)                         \\\n@@ -613,2 +613,2 @@\n-  declare_constant(markOop::no_hash_in_place)                         \\\n-  declare_constant(markOop::no_lock_in_place)                         \\\n+  declare_constant(markWord::no_hash_in_place)                            \\\n+  declare_constant(markWord::no_lock_in_place)                            \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1313,1 +1313,1 @@\n-  return markOop::lock_mask_in_place;\n+  return markWord::lock_mask_in_place;\n@@ -1318,1 +1318,1 @@\n-  intptr_t bits = (intptr_t)markOop::prototype().value();\n+  intptr_t bits = (intptr_t)markWord::prototype().value();\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -631,1 +631,1 @@\n-  assert(markOop::encode_pointer_as_mark(_base).decode_pointer() == _base,\n+  assert(markWord::encode_pointer_as_mark(_base).decode_pointer() == _base,\n@@ -633,1 +633,1 @@\n-  assert(markOop::encode_pointer_as_mark(&_base[size]).decode_pointer() == &_base[size],\n+  assert(markWord::encode_pointer_as_mark(&_base[size]).decode_pointer() == &_base[size],\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-\/\/  markOop\n+\/\/  markWord\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-                           _prototype_header(markOop::prototype()),\n+                           _prototype_header(markWord::prototype()),\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -163,1 +163,1 @@\n-  markOop  _prototype_header;   \/\/ Used when biased locking is both enabled and disabled for this type\n+  markWord  _prototype_header;   \/\/ Used when biased locking is both enabled and disabled for this type\n@@ -632,1 +632,1 @@\n-  \/\/ prototype markOop. If biased locking is enabled it may further be\n+  \/\/ prototype markWord. If biased locking is enabled it may further be\n@@ -634,1 +634,1 @@\n-  markOop prototype_header() const      { return _prototype_header; }\n+  markWord prototype_header() const      { return _prototype_header; }\n@@ -643,1 +643,1 @@\n-  inline void set_prototype_header(markOop header);\n+  inline void set_prototype_header(markWord header);\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -32,1 +32,1 @@\n-inline void Klass::set_prototype_header(markOop header) {\n+inline void Klass::set_prototype_header(markWord header) {\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,434 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_VM_OOPS_MARKOOP_HPP\n-#define SHARE_VM_OOPS_MARKOOP_HPP\n-\n-#include \"oops\/oop.hpp\"\n-\n-\/\/ The markOop describes the header of an object.\n-\/\/\n-\/\/ Note that the mark is not a real oop but just a word.\n-\/\/ It is placed in the oop hierarchy for historical reasons.\n-\/\/\n-\/\/ Bit-format of an object header (most significant first, big endian layout below):\n-\/\/\n-\/\/  32 bits:\n-\/\/  --------\n-\/\/             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)\n-\/\/             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)\n-\/\/             size:32 ------------------------------------------>| (CMS free block)\n-\/\/             PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS promoted object)\n-\/\/\n-\/\/  64 bits:\n-\/\/  --------\n-\/\/  unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)\n-\/\/  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)\n-\/\/  PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object)\n-\/\/  size:64 ----------------------------------------------------->| (CMS free block)\n-\/\/\n-\/\/  unused:25 hash:31 -->| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && normal object)\n-\/\/  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && biased object)\n-\/\/  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 ----->| (COOPs && CMS promoted object)\n-\/\/  unused:21 size:35 -->| cms_free:1 unused:7 ------------------>| (COOPs && CMS free block)\n-\/\/\n-\/\/  - hash contains the identity hash value: largest value is\n-\/\/    31 bits, see os::random().  Also, 64-bit vm's require\n-\/\/    a hash value no bigger than 32 bits because they will not\n-\/\/    properly generate a mask larger than that: see library_call.cpp\n-\/\/    and c1_CodePatterns_sparc.cpp.\n-\/\/\n-\/\/  - the biased lock pattern is used to bias a lock toward a given\n-\/\/    thread. When this pattern is set in the low three bits, the lock\n-\/\/    is either biased toward a given thread or \"anonymously\" biased,\n-\/\/    indicating that it is possible for it to be biased. When the\n-\/\/    lock is biased toward a given thread, locking and unlocking can\n-\/\/    be performed by that thread without using atomic operations.\n-\/\/    When a lock's bias is revoked, it reverts back to the normal\n-\/\/    locking scheme described below.\n-\/\/\n-\/\/    Note that we are overloading the meaning of the \"unlocked\" state\n-\/\/    of the header. Because we steal a bit from the age we can\n-\/\/    guarantee that the bias pattern will never be seen for a truly\n-\/\/    unlocked object.\n-\/\/\n-\/\/    Note also that the biased state contains the age bits normally\n-\/\/    contained in the object header. Large increases in scavenge\n-\/\/    times were seen when these bits were absent and an arbitrary age\n-\/\/    assigned to all biased objects, because they tended to consume a\n-\/\/    significant fraction of the eden semispaces and were not\n-\/\/    promoted promptly, causing an increase in the amount of copying\n-\/\/    performed. The runtime system aligns all JavaThread* pointers to\n-\/\/    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))\n-\/\/    to make room for the age bits & the epoch bits (used in support of\n-\/\/    biased locking), and for the CMS \"freeness\" bit in the 64bVM (+COOPs).\n-\/\/\n-\/\/    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread\n-\/\/    [0           | epoch | age | 1 | 01]       lock is anonymously biased\n-\/\/\n-\/\/  - the two lock bits are used to describe three states: locked\/unlocked and monitor.\n-\/\/\n-\/\/    [ptr             | 00]  locked             ptr points to real header on stack\n-\/\/    [header      | 0 | 01]  unlocked           regular object header\n-\/\/    [ptr             | 10]  monitor            inflated lock (header is wapped out)\n-\/\/    [ptr             | 11]  marked             used by markSweep to mark an object\n-\/\/                                               not valid at any other time\n-\/\/\n-\/\/    We assume that stack\/thread pointers have the lowest two bits cleared.\n-\n-class BasicLock;\n-class ObjectMonitor;\n-class JavaThread;\n-\n-class markOop {\n- private:\n-  uintptr_t _value;\n-\n- public:\n-  \/\/ Constants\n-  enum { age_bits                 = 4,\n-         lock_bits                = 2,\n-         biased_lock_bits         = 1,\n-         max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,\n-         hash_bits                = max_hash_bits > 31 ? 31 : max_hash_bits,\n-         cms_bits                 = LP64_ONLY(1) NOT_LP64(0),\n-         epoch_bits               = 2\n-  };\n-\n-  explicit markOop(uintptr_t value) : _value(value) {}\n-\n-  markOop() { \/* uninitialized *\/}\n-\n-  \/\/ It is critical for performance that this class be trivially\n-  \/\/ destructable, copyable, and assignable.\n-\n-  static markOop from_pointer(void* ptr) {\n-    return markOop((uintptr_t)ptr);\n-  }\n-  void* to_pointer() const {\n-    return (void*)_value;\n-  }\n-\n-  bool operator==(const markOop& other) const {\n-    return _value == other._value;\n-  }\n-  bool operator!=(const markOop& other) const {\n-    return !operator==(other);\n-  }\n-\n-  \/\/ Conversion\n-  uintptr_t value() const { return _value; }\n-\n-  \/\/ The biased locking code currently requires that the age bits be\n-  \/\/ contiguous to the lock bits.\n-  enum { lock_shift               = 0,\n-         biased_lock_shift        = lock_bits,\n-         age_shift                = lock_bits + biased_lock_bits,\n-         cms_shift                = age_shift + age_bits,\n-         hash_shift               = cms_shift + cms_bits,\n-         epoch_shift              = hash_shift\n-  };\n-\n-  enum { lock_mask                = right_n_bits(lock_bits),\n-         lock_mask_in_place       = lock_mask << lock_shift,\n-         biased_lock_mask         = right_n_bits(lock_bits + biased_lock_bits),\n-         biased_lock_mask_in_place= biased_lock_mask << lock_shift,\n-         biased_lock_bit_in_place = 1 << biased_lock_shift,\n-         age_mask                 = right_n_bits(age_bits),\n-         age_mask_in_place        = age_mask << age_shift,\n-         epoch_mask               = right_n_bits(epoch_bits),\n-         epoch_mask_in_place      = epoch_mask << epoch_shift,\n-         cms_mask                 = right_n_bits(cms_bits),\n-         cms_mask_in_place        = cms_mask << cms_shift\n-  };\n-\n-  const static uintptr_t hash_mask = right_n_bits(hash_bits);\n-  const static uintptr_t hash_mask_in_place = hash_mask << hash_shift;\n-\n-  \/\/ Alignment of JavaThread pointers encoded in object header required by biased locking\n-  enum { biased_lock_alignment    = 2 << (epoch_shift + epoch_bits)\n-  };\n-\n-  enum { locked_value             = 0,\n-         unlocked_value           = 1,\n-         monitor_value            = 2,\n-         marked_value             = 3,\n-         biased_lock_pattern      = 5\n-  };\n-\n-  enum { no_hash                  = 0 };  \/\/ no hash value assigned\n-\n-  enum { no_hash_in_place         = (address_word)no_hash << hash_shift,\n-         no_lock_in_place         = unlocked_value\n-  };\n-\n-  enum { max_age                  = age_mask };\n-\n-  enum { max_bias_epoch           = epoch_mask };\n-\n-  \/\/ Creates a markOop with all bits set to zero.\n-  static markOop zero() { return markOop(uintptr_t(0)); }\n-\n-  \/\/ Biased Locking accessors.\n-  \/\/ These must be checked by all code which calls into the\n-  \/\/ ObjectSynchronizer and other code. The biasing is not understood\n-  \/\/ by the lower-level CAS-based locking code, although the runtime\n-  \/\/ fixes up biased locks to be compatible with it when a bias is\n-  \/\/ revoked.\n-  bool has_bias_pattern() const {\n-    return (mask_bits(value(), biased_lock_mask_in_place) == biased_lock_pattern);\n-  }\n-  JavaThread* biased_locker() const {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    return (JavaThread*) ((intptr_t) (mask_bits(value(), ~(biased_lock_mask_in_place | age_mask_in_place | epoch_mask_in_place))));\n-  }\n-  \/\/ Indicates that the mark has the bias bit set but that it has not\n-  \/\/ yet been biased toward a particular thread\n-  bool is_biased_anonymously() const {\n-    return (has_bias_pattern() && (biased_locker() == NULL));\n-  }\n-  \/\/ Indicates epoch in which this bias was acquired. If the epoch\n-  \/\/ changes due to too many bias revocations occurring, the biases\n-  \/\/ from the previous epochs are all considered invalid.\n-  int bias_epoch() const {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    return (mask_bits(value(), epoch_mask_in_place) >> epoch_shift);\n-  }\n-  markOop set_bias_epoch(int epoch) {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    assert((epoch & (~epoch_mask)) == 0, \"epoch overflow\");\n-    return markOop(mask_bits(value(), ~epoch_mask_in_place) | (epoch << epoch_shift));\n-  }\n-  markOop incr_bias_epoch() {\n-    return set_bias_epoch((1 + bias_epoch()) & epoch_mask);\n-  }\n-  \/\/ Prototype mark for initialization\n-  static markOop biased_locking_prototype() {\n-    return markOop( biased_lock_pattern );\n-  }\n-\n-  \/\/ lock accessors (note that these assume lock_shift == 0)\n-  bool is_locked()   const {\n-    return (mask_bits(value(), lock_mask_in_place) != unlocked_value);\n-  }\n-  bool is_unlocked() const {\n-    return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value);\n-  }\n-  bool is_marked()   const {\n-    return (mask_bits(value(), lock_mask_in_place) == marked_value);\n-  }\n-  bool is_neutral()  const { return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value); }\n-\n-  \/\/ Special temporary state of the markOop while being inflated.\n-  \/\/ Code that looks at mark outside a lock need to take this into account.\n-  bool is_being_inflated() const { return (value() == 0); }\n-\n-  \/\/ Distinguished markOop value - used when inflating over\n-  \/\/ an existing stacklock.  0 indicates the markOop is \"BUSY\".\n-  \/\/ Lockword mutators that use a LD...CAS idiom should always\n-  \/\/ check for and avoid overwriting a 0 value installed by some\n-  \/\/ other thread.  (They should spin or block instead.  The 0 value\n-  \/\/ is transient and *should* be short-lived).\n-  static markOop INFLATING() { return zero(); }    \/\/ inflate-in-progress\n-\n-  \/\/ Should this header be preserved during GC?\n-  inline bool must_be_preserved(oop obj_containing_mark) const;\n-  inline bool must_be_preserved_with_bias(oop obj_containing_mark) const;\n-\n-  \/\/ Should this header (including its age bits) be preserved in the\n-  \/\/ case of a promotion failure during scavenge?\n-  \/\/ Note that we special case this situation. We want to avoid\n-  \/\/ calling BiasedLocking::preserve_marks()\/restore_marks() (which\n-  \/\/ decrease the number of mark words that need to be preserved\n-  \/\/ during GC) during each scavenge. During scavenges in which there\n-  \/\/ is no promotion failure, we actually don't need to call the above\n-  \/\/ routines at all, since we don't mutate and re-initialize the\n-  \/\/ marks of promoted objects using init_mark(). However, during\n-  \/\/ scavenges which result in promotion failure, we do re-initialize\n-  \/\/ the mark words of objects, meaning that we should have called\n-  \/\/ these mark word preservation routines. Currently there's no good\n-  \/\/ place in which to call them in any of the scavengers (although\n-  \/\/ guarded by appropriate locks we could make one), but the\n-  \/\/ observation is that promotion failures are quite rare and\n-  \/\/ reducing the number of mark words preserved during them isn't a\n-  \/\/ high priority.\n-  inline bool must_be_preserved_for_promotion_failure(oop obj_containing_mark) const;\n-  inline bool must_be_preserved_with_bias_for_promotion_failure(oop obj_containing_mark) const;\n-\n-  \/\/ Should this header be preserved during a scavenge where CMS is\n-  \/\/ the old generation?\n-  \/\/ (This is basically the same body as must_be_preserved_for_promotion_failure(),\n-  \/\/ but takes the Klass* as argument instead)\n-  inline bool must_be_preserved_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const;\n-  inline bool must_be_preserved_with_bias_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const;\n-\n-  \/\/ WARNING: The following routines are used EXCLUSIVELY by\n-  \/\/ synchronization functions. They are not really gc safe.\n-  \/\/ They must get updated if markOop layout get changed.\n-  markOop set_unlocked() const {\n-    return markOop(value() | unlocked_value);\n-  }\n-  bool has_locker() const {\n-    return ((value() & lock_mask_in_place) == locked_value);\n-  }\n-  BasicLock* locker() const {\n-    assert(has_locker(), \"check\");\n-    return (BasicLock*) value();\n-  }\n-  bool has_monitor() const {\n-    return ((value() & monitor_value) != 0);\n-  }\n-  ObjectMonitor* monitor() const {\n-    assert(has_monitor(), \"check\");\n-    \/\/ Use xor instead of &~ to provide one extra tag-bit check.\n-    return (ObjectMonitor*) (value() ^ monitor_value);\n-  }\n-  bool has_displaced_mark_helper() const {\n-    return ((value() & unlocked_value) == 0);\n-  }\n-  markOop displaced_mark_helper() const {\n-    assert(has_displaced_mark_helper(), \"check\");\n-    intptr_t ptr = (value() & ~monitor_value);\n-    return *(markOop*)ptr;\n-  }\n-  void set_displaced_mark_helper(markOop m) const {\n-    assert(has_displaced_mark_helper(), \"check\");\n-    intptr_t ptr = (value() & ~monitor_value);\n-    *(markOop*)ptr = m;\n-  }\n-  markOop copy_set_hash(intptr_t hash) const {\n-    intptr_t tmp = value() & (~hash_mask_in_place);\n-    tmp |= ((hash & hash_mask) << hash_shift);\n-    return markOop(tmp);\n-  }\n-  \/\/ it is only used to be stored into BasicLock as the\n-  \/\/ indicator that the lock is using heavyweight monitor\n-  static markOop unused_mark() {\n-    return markOop(marked_value);\n-  }\n-  \/\/ the following two functions create the markOop to be\n-  \/\/ stored into object header, it encodes monitor info\n-  static markOop encode(BasicLock* lock) {\n-    return from_pointer(lock);\n-  }\n-  static markOop encode(ObjectMonitor* monitor) {\n-    intptr_t tmp = (intptr_t) monitor;\n-    return (markOop) (tmp | monitor_value);\n-  }\n-  static markOop encode(JavaThread* thread, uint age, int bias_epoch) {\n-    intptr_t tmp = (intptr_t) thread;\n-    assert(UseBiasedLocking && ((tmp & (epoch_mask_in_place | age_mask_in_place | biased_lock_mask_in_place)) == 0), \"misaligned JavaThread pointer\");\n-    assert(age <= max_age, \"age too large\");\n-    assert(bias_epoch <= max_bias_epoch, \"bias epoch too large\");\n-    return (markOop) (tmp | (bias_epoch << epoch_shift) | (age << age_shift) | biased_lock_pattern);\n-  }\n-\n-  \/\/ used to encode pointers during GC\n-  markOop clear_lock_bits() { return markOop(value() & ~lock_mask_in_place); }\n-\n-  \/\/ age operations\n-  markOop set_marked()   { return markOop((value() & ~lock_mask_in_place) | marked_value); }\n-  markOop set_unmarked() { return markOop((value() & ~lock_mask_in_place) | unlocked_value); }\n-\n-  uint    age()               const { return mask_bits(value() >> age_shift, age_mask); }\n-  markOop set_age(uint v) const {\n-    assert((v & ~age_mask) == 0, \"shouldn't overflow age field\");\n-    return markOop((value() & ~age_mask_in_place) | (((uintptr_t)v & age_mask) << age_shift));\n-  }\n-  markOop incr_age()          const { return age() == max_age ? markOop(_value) : set_age(age() + 1); }\n-\n-  \/\/ hash operations\n-  intptr_t hash() const {\n-    return mask_bits(value() >> hash_shift, hash_mask);\n-  }\n-\n-  bool has_no_hash() const {\n-    return hash() == no_hash;\n-  }\n-\n-  \/\/ Prototype mark for initialization\n-  static markOop prototype() {\n-    return markOop( no_hash_in_place | no_lock_in_place );\n-  }\n-\n-  \/\/ Helper function for restoration of unmarked mark oops during GC\n-  static inline markOop prototype_for_object(oop obj);\n-\n-  \/\/ Debugging\n-  void print_on(outputStream* st) const;\n-\n-  \/\/ Prepare address of oop for placement into mark\n-  inline static markOop encode_pointer_as_mark(void* p) { return from_pointer(p).set_marked(); }\n-\n-  \/\/ Recover address of oop from encoded form used in mark\n-  inline void* decode_pointer() { if (UseBiasedLocking && has_bias_pattern()) return NULL; return (void*)clear_lock_bits().value(); }\n-\n-  \/\/ These markOops indicate cms free chunk blocks and not objects.\n-  \/\/ In 64 bit, the markOop is set to distinguish them from oops.\n-  \/\/ These are defined in 32 bit mode for vmStructs.\n-  const static uintptr_t cms_free_chunk_pattern  = 0x1;\n-\n-  \/\/ Constants for the size field.\n-  enum { size_shift                = cms_shift + cms_bits,\n-         size_bits                 = 35    \/\/ need for compressed oops 32G\n-       };\n-  \/\/ These values are too big for Win64\n-  const static uintptr_t size_mask = LP64_ONLY(right_n_bits(size_bits))\n-                                     NOT_LP64(0);\n-  const static uintptr_t size_mask_in_place =\n-                                     (address_word)size_mask << size_shift;\n-\n-#ifdef _LP64\n-  static markOop cms_free_prototype() {\n-    return markOop(((intptr_t)prototype().value() & ~cms_mask_in_place) |\n-                   ((cms_free_chunk_pattern & cms_mask) << cms_shift));\n-  }\n-  uintptr_t cms_encoding() const {\n-    return mask_bits(value() >> cms_shift, cms_mask);\n-  }\n-  bool is_cms_free_chunk() const {\n-    return is_neutral() &&\n-           (cms_encoding() & cms_free_chunk_pattern) == cms_free_chunk_pattern;\n-  }\n-\n-  size_t get_size() const       { return (size_t)(value() >> size_shift); }\n-  static markOop set_size_and_free(size_t size) {\n-    assert((size & ~size_mask) == 0, \"shouldn't overflow size field\");\n-    return markOop(((intptr_t)cms_free_prototype().value() & ~size_mask_in_place) |\n-                   (((intptr_t)size & size_mask) << size_shift));\n-  }\n-#endif \/\/ _LP64\n-};\n-\n-\/\/ Support atomic operations.\n-template<>\n-struct PrimitiveConversions::Translate<markOop> : public TrueType {\n-  typedef markOop Value;\n-  typedef uintptr_t Decayed;\n-\n-  static Decayed decay(const Value& x) { return x.value(); }\n-  static Value recover(Decayed x) { return Value(x); }\n-};\n-\n-#endif \/\/ SHARE_VM_OOPS_MARKOOP_HPP\n","filename":"src\/hotspot\/share\/oops\/markOop.hpp","additions":0,"deletions":434,"binary":false,"changes":434,"status":"deleted"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2006, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_VM_OOPS_MARKOOP_INLINE_HPP\n-#define SHARE_VM_OOPS_MARKOOP_INLINE_HPP\n-\n-#include \"oops\/klass.hpp\"\n-#include \"oops\/markOop.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/globals.hpp\"\n-\n-\/\/ Should this header be preserved during GC (when biased locking is enabled)?\n-inline bool markOop::must_be_preserved_with_bias(oop obj_containing_mark) const {\n-  assert(UseBiasedLocking, \"unexpected\");\n-  if (has_bias_pattern()) {\n-    \/\/ Will reset bias at end of collection\n-    \/\/ Mark words of biased and currently locked objects are preserved separately\n-    return false;\n-  }\n-  markOop prototype_header = prototype_for_object(obj_containing_mark);\n-  if (prototype_header.has_bias_pattern()) {\n-    \/\/ Individual instance which has its bias revoked; must return\n-    \/\/ true for correctness\n-    return true;\n-  }\n-  return (!is_unlocked() || !has_no_hash());\n-}\n-\n-\/\/ Should this header be preserved during GC?\n-inline bool markOop::must_be_preserved(oop obj_containing_mark) const {\n-  if (!UseBiasedLocking)\n-    return (!is_unlocked() || !has_no_hash());\n-  return must_be_preserved_with_bias(obj_containing_mark);\n-}\n-\n-\/\/ Should this header be preserved in the case of a promotion failure\n-\/\/ during scavenge (when biased locking is enabled)?\n-inline bool markOop::must_be_preserved_with_bias_for_promotion_failure(oop obj_containing_mark) const {\n-  assert(UseBiasedLocking, \"unexpected\");\n-  \/\/ We don't explicitly save off the mark words of biased and\n-  \/\/ currently-locked objects during scavenges, so if during a\n-  \/\/ promotion failure we encounter either a biased mark word or a\n-  \/\/ klass which still has a biasable prototype header, we have to\n-  \/\/ preserve the mark word. This results in oversaving, but promotion\n-  \/\/ failures are rare, and this avoids adding more complex logic to\n-  \/\/ the scavengers to call new variants of\n-  \/\/ BiasedLocking::preserve_marks() \/ restore_marks() in the middle\n-  \/\/ of a scavenge when a promotion failure has first been detected.\n-  if (has_bias_pattern() ||\n-      prototype_for_object(obj_containing_mark).has_bias_pattern()) {\n-    return true;\n-  }\n-  return (!is_unlocked() || !has_no_hash());\n-}\n-\n-\/\/ Should this header be preserved in the case of a promotion failure\n-\/\/ during scavenge?\n-inline bool markOop::must_be_preserved_for_promotion_failure(oop obj_containing_mark) const {\n-  if (!UseBiasedLocking)\n-    return (!is_unlocked() || !has_no_hash());\n-  return must_be_preserved_with_bias_for_promotion_failure(obj_containing_mark);\n-}\n-\n-\n-\/\/ Same as must_be_preserved_with_bias_for_promotion_failure() except that\n-\/\/ it takes a Klass* argument, instead of the object of which this is the mark word.\n-inline bool markOop::must_be_preserved_with_bias_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const {\n-  assert(UseBiasedLocking, \"unexpected\");\n-  \/\/ CMS scavenges preserve mark words in similar fashion to promotion failures; see above\n-  if (has_bias_pattern() ||\n-      klass_of_obj_containing_mark->prototype_header().has_bias_pattern()) {\n-    return true;\n-  }\n-  return (!is_unlocked() || !has_no_hash());\n-}\n-\n-\/\/ Same as must_be_preserved_for_promotion_failure() except that\n-\/\/ it takes a Klass* argument, instead of the object of which this is the mark word.\n-inline bool markOop::must_be_preserved_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const {\n-  if (!UseBiasedLocking)\n-    return (!is_unlocked() || !has_no_hash());\n-  return must_be_preserved_with_bias_for_cms_scavenge(klass_of_obj_containing_mark);\n-}\n-\n-inline markOop markOop::prototype_for_object(oop obj) {\n-#ifdef ASSERT\n-  markOop prototype_header = obj->klass()->prototype_header();\n-  assert(prototype_header == prototype() || prototype_header.has_bias_pattern(), \"corrupt prototype header\");\n-#endif\n-  return obj->klass()->prototype_header();\n-}\n-\n-#endif \/\/ SHARE_VM_OOPS_MARKOOP_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/markOop.inline.hpp","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -30,1 +30,1 @@\n-void markOop::print_on(outputStream* st) const {\n+void markWord::print_on(outputStream* st) const {\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/hotspot\/share\/oops\/markOop.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,433 @@\n+\/*\n+ * Copyright (c) 1997, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_OOPS_MARKWORD_HPP\n+#define SHARE_VM_OOPS_MARKWORD_HPP\n+\n+#include \"metaprogramming\/integralConstant.hpp\"\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+\/\/ The markWord describes the header of an object.\n+\/\/\n+\/\/ Bit-format of an object header (most significant first, big endian layout below):\n+\/\/\n+\/\/  32 bits:\n+\/\/  --------\n+\/\/             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)\n+\/\/             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)\n+\/\/             size:32 ------------------------------------------>| (CMS free block)\n+\/\/             PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS promoted object)\n+\/\/\n+\/\/  64 bits:\n+\/\/  --------\n+\/\/  unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)\n+\/\/  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)\n+\/\/  PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object)\n+\/\/  size:64 ----------------------------------------------------->| (CMS free block)\n+\/\/\n+\/\/  unused:25 hash:31 -->| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && normal object)\n+\/\/  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && biased object)\n+\/\/  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 ----->| (COOPs && CMS promoted object)\n+\/\/  unused:21 size:35 -->| cms_free:1 unused:7 ------------------>| (COOPs && CMS free block)\n+\/\/\n+\/\/  - hash contains the identity hash value: largest value is\n+\/\/    31 bits, see os::random().  Also, 64-bit vm's require\n+\/\/    a hash value no bigger than 32 bits because they will not\n+\/\/    properly generate a mask larger than that: see library_call.cpp\n+\/\/    and c1_CodePatterns_sparc.cpp.\n+\/\/\n+\/\/  - the biased lock pattern is used to bias a lock toward a given\n+\/\/    thread. When this pattern is set in the low three bits, the lock\n+\/\/    is either biased toward a given thread or \"anonymously\" biased,\n+\/\/    indicating that it is possible for it to be biased. When the\n+\/\/    lock is biased toward a given thread, locking and unlocking can\n+\/\/    be performed by that thread without using atomic operations.\n+\/\/    When a lock's bias is revoked, it reverts back to the normal\n+\/\/    locking scheme described below.\n+\/\/\n+\/\/    Note that we are overloading the meaning of the \"unlocked\" state\n+\/\/    of the header. Because we steal a bit from the age we can\n+\/\/    guarantee that the bias pattern will never be seen for a truly\n+\/\/    unlocked object.\n+\/\/\n+\/\/    Note also that the biased state contains the age bits normally\n+\/\/    contained in the object header. Large increases in scavenge\n+\/\/    times were seen when these bits were absent and an arbitrary age\n+\/\/    assigned to all biased objects, because they tended to consume a\n+\/\/    significant fraction of the eden semispaces and were not\n+\/\/    promoted promptly, causing an increase in the amount of copying\n+\/\/    performed. The runtime system aligns all JavaThread* pointers to\n+\/\/    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))\n+\/\/    to make room for the age bits & the epoch bits (used in support of\n+\/\/    biased locking), and for the CMS \"freeness\" bit in the 64bVM (+COOPs).\n+\/\/\n+\/\/    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread\n+\/\/    [0           | epoch | age | 1 | 01]       lock is anonymously biased\n+\/\/\n+\/\/  - the two lock bits are used to describe three states: locked\/unlocked and monitor.\n+\/\/\n+\/\/    [ptr             | 00]  locked             ptr points to real header on stack\n+\/\/    [header      | 0 | 01]  unlocked           regular object header\n+\/\/    [ptr             | 10]  monitor            inflated lock (header is wapped out)\n+\/\/    [ptr             | 11]  marked             used by markSweep to mark an object\n+\/\/                                               not valid at any other time\n+\/\/\n+\/\/    We assume that stack\/thread pointers have the lowest two bits cleared.\n+\n+class BasicLock;\n+class ObjectMonitor;\n+class JavaThread;\n+\n+class markWord {\n+ private:\n+  uintptr_t _value;\n+\n+ public:\n+  \/\/ Constants\n+  enum { age_bits                 = 4,\n+         lock_bits                = 2,\n+         biased_lock_bits         = 1,\n+         max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,\n+         hash_bits                = max_hash_bits > 31 ? 31 : max_hash_bits,\n+         cms_bits                 = LP64_ONLY(1) NOT_LP64(0),\n+         epoch_bits               = 2\n+  };\n+\n+  explicit markWord(uintptr_t value) : _value(value) {}\n+\n+  markWord() { \/* uninitialized *\/}\n+\n+  \/\/ It is critical for performance that this class be trivially\n+  \/\/ destructable, copyable, and assignable.\n+\n+  static markWord from_pointer(void* ptr) {\n+    return markWord((uintptr_t)ptr);\n+  }\n+  void* to_pointer() const {\n+    return (void*)_value;\n+  }\n+\n+  bool operator==(const markWord& other) const {\n+    return _value == other._value;\n+  }\n+  bool operator!=(const markWord& other) const {\n+    return !operator==(other);\n+  }\n+\n+  \/\/ Conversion\n+  uintptr_t value() const { return _value; }\n+\n+  \/\/ The biased locking code currently requires that the age bits be\n+  \/\/ contiguous to the lock bits.\n+  enum { lock_shift               = 0,\n+         biased_lock_shift        = lock_bits,\n+         age_shift                = lock_bits + biased_lock_bits,\n+         cms_shift                = age_shift + age_bits,\n+         hash_shift               = cms_shift + cms_bits,\n+         epoch_shift              = hash_shift\n+  };\n+\n+  enum { lock_mask                = right_n_bits(lock_bits),\n+         lock_mask_in_place       = lock_mask << lock_shift,\n+         biased_lock_mask         = right_n_bits(lock_bits + biased_lock_bits),\n+         biased_lock_mask_in_place= biased_lock_mask << lock_shift,\n+         biased_lock_bit_in_place = 1 << biased_lock_shift,\n+         age_mask                 = right_n_bits(age_bits),\n+         age_mask_in_place        = age_mask << age_shift,\n+         epoch_mask               = right_n_bits(epoch_bits),\n+         epoch_mask_in_place      = epoch_mask << epoch_shift,\n+         cms_mask                 = right_n_bits(cms_bits),\n+         cms_mask_in_place        = cms_mask << cms_shift\n+  };\n+\n+  const static uintptr_t hash_mask = right_n_bits(hash_bits);\n+  const static uintptr_t hash_mask_in_place = hash_mask << hash_shift;\n+\n+  \/\/ Alignment of JavaThread pointers encoded in object header required by biased locking\n+  enum { biased_lock_alignment    = 2 << (epoch_shift + epoch_bits)\n+  };\n+\n+  enum { locked_value             = 0,\n+         unlocked_value           = 1,\n+         monitor_value            = 2,\n+         marked_value             = 3,\n+         biased_lock_pattern      = 5\n+  };\n+\n+  enum { no_hash                  = 0 };  \/\/ no hash value assigned\n+\n+  enum { no_hash_in_place         = (address_word)no_hash << hash_shift,\n+         no_lock_in_place         = unlocked_value\n+  };\n+\n+  enum { max_age                  = age_mask };\n+\n+  enum { max_bias_epoch           = epoch_mask };\n+\n+  \/\/ Creates a markWord with all bits set to zero.\n+  static markWord zero() { return markWord(uintptr_t(0)); }\n+\n+  \/\/ Biased Locking accessors.\n+  \/\/ These must be checked by all code which calls into the\n+  \/\/ ObjectSynchronizer and other code. The biasing is not understood\n+  \/\/ by the lower-level CAS-based locking code, although the runtime\n+  \/\/ fixes up biased locks to be compatible with it when a bias is\n+  \/\/ revoked.\n+  bool has_bias_pattern() const {\n+    return (mask_bits(value(), biased_lock_mask_in_place) == biased_lock_pattern);\n+  }\n+  JavaThread* biased_locker() const {\n+    assert(has_bias_pattern(), \"should not call this otherwise\");\n+    return (JavaThread*) ((intptr_t) (mask_bits(value(), ~(biased_lock_mask_in_place | age_mask_in_place | epoch_mask_in_place))));\n+  }\n+  \/\/ Indicates that the mark has the bias bit set but that it has not\n+  \/\/ yet been biased toward a particular thread\n+  bool is_biased_anonymously() const {\n+    return (has_bias_pattern() && (biased_locker() == NULL));\n+  }\n+  \/\/ Indicates epoch in which this bias was acquired. If the epoch\n+  \/\/ changes due to too many bias revocations occurring, the biases\n+  \/\/ from the previous epochs are all considered invalid.\n+  int bias_epoch() const {\n+    assert(has_bias_pattern(), \"should not call this otherwise\");\n+    return (mask_bits(value(), epoch_mask_in_place) >> epoch_shift);\n+  }\n+  markWord set_bias_epoch(int epoch) {\n+    assert(has_bias_pattern(), \"should not call this otherwise\");\n+    assert((epoch & (~epoch_mask)) == 0, \"epoch overflow\");\n+    return markWord(mask_bits(value(), ~epoch_mask_in_place) | (epoch << epoch_shift));\n+  }\n+  markWord incr_bias_epoch() {\n+    return set_bias_epoch((1 + bias_epoch()) & epoch_mask);\n+  }\n+  \/\/ Prototype mark for initialization\n+  static markWord biased_locking_prototype() {\n+    return markWord( biased_lock_pattern );\n+  }\n+\n+  \/\/ lock accessors (note that these assume lock_shift == 0)\n+  bool is_locked()   const {\n+    return (mask_bits(value(), lock_mask_in_place) != unlocked_value);\n+  }\n+  bool is_unlocked() const {\n+    return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value);\n+  }\n+  bool is_marked()   const {\n+    return (mask_bits(value(), lock_mask_in_place) == marked_value);\n+  }\n+  bool is_neutral()  const { return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value); }\n+\n+  \/\/ Special temporary state of the markWord while being inflated.\n+  \/\/ Code that looks at mark outside a lock need to take this into account.\n+  bool is_being_inflated() const { return (value() == 0); }\n+\n+  \/\/ Distinguished markWord value - used when inflating over\n+  \/\/ an existing stacklock.  0 indicates the markWord is \"BUSY\".\n+  \/\/ Lockword mutators that use a LD...CAS idiom should always\n+  \/\/ check for and avoid overwriting a 0 value installed by some\n+  \/\/ other thread.  (They should spin or block instead.  The 0 value\n+  \/\/ is transient and *should* be short-lived).\n+  static markWord INFLATING() { return zero(); }    \/\/ inflate-in-progress\n+\n+  \/\/ Should this header be preserved during GC?\n+  inline bool must_be_preserved(oop obj_containing_mark) const;\n+  inline bool must_be_preserved_with_bias(oop obj_containing_mark) const;\n+\n+  \/\/ Should this header (including its age bits) be preserved in the\n+  \/\/ case of a promotion failure during scavenge?\n+  \/\/ Note that we special case this situation. We want to avoid\n+  \/\/ calling BiasedLocking::preserve_marks()\/restore_marks() (which\n+  \/\/ decrease the number of mark words that need to be preserved\n+  \/\/ during GC) during each scavenge. During scavenges in which there\n+  \/\/ is no promotion failure, we actually don't need to call the above\n+  \/\/ routines at all, since we don't mutate and re-initialize the\n+  \/\/ marks of promoted objects using init_mark(). However, during\n+  \/\/ scavenges which result in promotion failure, we do re-initialize\n+  \/\/ the mark words of objects, meaning that we should have called\n+  \/\/ these mark word preservation routines. Currently there's no good\n+  \/\/ place in which to call them in any of the scavengers (although\n+  \/\/ guarded by appropriate locks we could make one), but the\n+  \/\/ observation is that promotion failures are quite rare and\n+  \/\/ reducing the number of mark words preserved during them isn't a\n+  \/\/ high priority.\n+  inline bool must_be_preserved_for_promotion_failure(oop obj_containing_mark) const;\n+  inline bool must_be_preserved_with_bias_for_promotion_failure(oop obj_containing_mark) const;\n+\n+  \/\/ Should this header be preserved during a scavenge where CMS is\n+  \/\/ the old generation?\n+  \/\/ (This is basically the same body as must_be_preserved_for_promotion_failure(),\n+  \/\/ but takes the Klass* as argument instead)\n+  inline bool must_be_preserved_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const;\n+  inline bool must_be_preserved_with_bias_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const;\n+\n+  \/\/ WARNING: The following routines are used EXCLUSIVELY by\n+  \/\/ synchronization functions. They are not really gc safe.\n+  \/\/ They must get updated if markWord layout get changed.\n+  markWord set_unlocked() const {\n+    return markWord(value() | unlocked_value);\n+  }\n+  bool has_locker() const {\n+    return ((value() & lock_mask_in_place) == locked_value);\n+  }\n+  BasicLock* locker() const {\n+    assert(has_locker(), \"check\");\n+    return (BasicLock*) value();\n+  }\n+  bool has_monitor() const {\n+    return ((value() & monitor_value) != 0);\n+  }\n+  ObjectMonitor* monitor() const {\n+    assert(has_monitor(), \"check\");\n+    \/\/ Use xor instead of &~ to provide one extra tag-bit check.\n+    return (ObjectMonitor*) (value() ^ monitor_value);\n+  }\n+  bool has_displaced_mark_helper() const {\n+    return ((value() & unlocked_value) == 0);\n+  }\n+  markWord displaced_mark_helper() const {\n+    assert(has_displaced_mark_helper(), \"check\");\n+    intptr_t ptr = (value() & ~monitor_value);\n+    return *(markWord*)ptr;\n+  }\n+  void set_displaced_mark_helper(markWord m) const {\n+    assert(has_displaced_mark_helper(), \"check\");\n+    intptr_t ptr = (value() & ~monitor_value);\n+    *(markWord*)ptr = m;\n+  }\n+  markWord copy_set_hash(intptr_t hash) const {\n+    intptr_t tmp = value() & (~hash_mask_in_place);\n+    tmp |= ((hash & hash_mask) << hash_shift);\n+    return markWord(tmp);\n+  }\n+  \/\/ it is only used to be stored into BasicLock as the\n+  \/\/ indicator that the lock is using heavyweight monitor\n+  static markWord unused_mark() {\n+    return markWord(marked_value);\n+  }\n+  \/\/ the following two functions create the markWord to be\n+  \/\/ stored into object header, it encodes monitor info\n+  static markWord encode(BasicLock* lock) {\n+    return from_pointer(lock);\n+  }\n+  static markWord encode(ObjectMonitor* monitor) {\n+    intptr_t tmp = (intptr_t) monitor;\n+    return (markWord) (tmp | monitor_value);\n+  }\n+  static markWord encode(JavaThread* thread, uint age, int bias_epoch) {\n+    intptr_t tmp = (intptr_t) thread;\n+    assert(UseBiasedLocking && ((tmp & (epoch_mask_in_place | age_mask_in_place | biased_lock_mask_in_place)) == 0), \"misaligned JavaThread pointer\");\n+    assert(age <= max_age, \"age too large\");\n+    assert(bias_epoch <= max_bias_epoch, \"bias epoch too large\");\n+    return (markWord) (tmp | (bias_epoch << epoch_shift) | (age << age_shift) | biased_lock_pattern);\n+  }\n+\n+  \/\/ used to encode pointers during GC\n+  markWord clear_lock_bits() { return markWord(value() & ~lock_mask_in_place); }\n+\n+  \/\/ age operations\n+  markWord set_marked()   { return markWord((value() & ~lock_mask_in_place) | marked_value); }\n+  markWord set_unmarked() { return markWord((value() & ~lock_mask_in_place) | unlocked_value); }\n+\n+  uint    age()               const { return mask_bits(value() >> age_shift, age_mask); }\n+  markWord set_age(uint v) const {\n+    assert((v & ~age_mask) == 0, \"shouldn't overflow age field\");\n+    return markWord((value() & ~age_mask_in_place) | (((uintptr_t)v & age_mask) << age_shift));\n+  }\n+  markWord incr_age()          const { return age() == max_age ? markWord(_value) : set_age(age() + 1); }\n+\n+  \/\/ hash operations\n+  intptr_t hash() const {\n+    return mask_bits(value() >> hash_shift, hash_mask);\n+  }\n+\n+  bool has_no_hash() const {\n+    return hash() == no_hash;\n+  }\n+\n+  \/\/ Prototype mark for initialization\n+  static markWord prototype() {\n+    return markWord( no_hash_in_place | no_lock_in_place );\n+  }\n+\n+  \/\/ Helper function for restoration of unmarked mark oops during GC\n+  static inline markWord prototype_for_object(oop obj);\n+\n+  \/\/ Debugging\n+  void print_on(outputStream* st) const;\n+\n+  \/\/ Prepare address of oop for placement into mark\n+  inline static markWord encode_pointer_as_mark(void* p) { return from_pointer(p).set_marked(); }\n+\n+  \/\/ Recover address of oop from encoded form used in mark\n+  inline void* decode_pointer() { if (UseBiasedLocking && has_bias_pattern()) return NULL; return (void*)clear_lock_bits().value(); }\n+\n+  \/\/ These markWords indicate cms free chunk blocks and not objects.\n+  \/\/ In 64 bit, the markWord is set to distinguish them from oops.\n+  \/\/ These are defined in 32 bit mode for vmStructs.\n+  const static uintptr_t cms_free_chunk_pattern  = 0x1;\n+\n+  \/\/ Constants for the size field.\n+  enum { size_shift                = cms_shift + cms_bits,\n+         size_bits                 = 35    \/\/ need for compressed oops 32G\n+       };\n+  \/\/ These values are too big for Win64\n+  const static uintptr_t size_mask = LP64_ONLY(right_n_bits(size_bits))\n+                                     NOT_LP64(0);\n+  const static uintptr_t size_mask_in_place =\n+                                     (address_word)size_mask << size_shift;\n+\n+#ifdef _LP64\n+  static markWord cms_free_prototype() {\n+    return markWord(((intptr_t)prototype().value() & ~cms_mask_in_place) |\n+                   ((cms_free_chunk_pattern & cms_mask) << cms_shift));\n+  }\n+  uintptr_t cms_encoding() const {\n+    return mask_bits(value() >> cms_shift, cms_mask);\n+  }\n+  bool is_cms_free_chunk() const {\n+    return is_neutral() &&\n+           (cms_encoding() & cms_free_chunk_pattern) == cms_free_chunk_pattern;\n+  }\n+\n+  size_t get_size() const       { return (size_t)(value() >> size_shift); }\n+  static markWord set_size_and_free(size_t size) {\n+    assert((size & ~size_mask) == 0, \"shouldn't overflow size field\");\n+    return markWord(((intptr_t)cms_free_prototype().value() & ~size_mask_in_place) |\n+                   (((intptr_t)size & size_mask) << size_shift));\n+  }\n+#endif \/\/ _LP64\n+};\n+\n+\/\/ Support atomic operations.\n+template<>\n+struct PrimitiveConversions::Translate<markWord> : public TrueType {\n+  typedef markWord Value;\n+  typedef uintptr_t Decayed;\n+\n+  static Decayed decay(const Value& x) { return x.value(); }\n+  static Value recover(Decayed x) { return Value(x); }\n+};\n+\n+#endif \/\/ SHARE_VM_OOPS_MARKWORD_HPP\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":433,"deletions":0,"binary":false,"changes":433,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2006, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_OOPS_MARKWORD_INLINE_HPP\n+#define SHARE_VM_OOPS_MARKWORD_INLINE_HPP\n+\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+\/\/ Should this header be preserved during GC (when biased locking is enabled)?\n+inline bool markWord::must_be_preserved_with_bias(oop obj_containing_mark) const {\n+  assert(UseBiasedLocking, \"unexpected\");\n+  if (has_bias_pattern()) {\n+    \/\/ Will reset bias at end of collection\n+    \/\/ Mark words of biased and currently locked objects are preserved separately\n+    return false;\n+  }\n+  markWord prototype_header = prototype_for_object(obj_containing_mark);\n+  if (prototype_header.has_bias_pattern()) {\n+    \/\/ Individual instance which has its bias revoked; must return\n+    \/\/ true for correctness\n+    return true;\n+  }\n+  return (!is_unlocked() || !has_no_hash());\n+}\n+\n+\/\/ Should this header be preserved during GC?\n+inline bool markWord::must_be_preserved(oop obj_containing_mark) const {\n+  if (!UseBiasedLocking)\n+    return (!is_unlocked() || !has_no_hash());\n+  return must_be_preserved_with_bias(obj_containing_mark);\n+}\n+\n+\/\/ Should this header be preserved in the case of a promotion failure\n+\/\/ during scavenge (when biased locking is enabled)?\n+inline bool markWord::must_be_preserved_with_bias_for_promotion_failure(oop obj_containing_mark) const {\n+  assert(UseBiasedLocking, \"unexpected\");\n+  \/\/ We don't explicitly save off the mark words of biased and\n+  \/\/ currently-locked objects during scavenges, so if during a\n+  \/\/ promotion failure we encounter either a biased mark word or a\n+  \/\/ klass which still has a biasable prototype header, we have to\n+  \/\/ preserve the mark word. This results in oversaving, but promotion\n+  \/\/ failures are rare, and this avoids adding more complex logic to\n+  \/\/ the scavengers to call new variants of\n+  \/\/ BiasedLocking::preserve_marks() \/ restore_marks() in the middle\n+  \/\/ of a scavenge when a promotion failure has first been detected.\n+  if (has_bias_pattern() ||\n+      prototype_for_object(obj_containing_mark).has_bias_pattern()) {\n+    return true;\n+  }\n+  return (!is_unlocked() || !has_no_hash());\n+}\n+\n+\/\/ Should this header be preserved in the case of a promotion failure\n+\/\/ during scavenge?\n+inline bool markWord::must_be_preserved_for_promotion_failure(oop obj_containing_mark) const {\n+  if (!UseBiasedLocking)\n+    return (!is_unlocked() || !has_no_hash());\n+  return must_be_preserved_with_bias_for_promotion_failure(obj_containing_mark);\n+}\n+\n+\n+\/\/ Same as must_be_preserved_with_bias_for_promotion_failure() except that\n+\/\/ it takes a Klass* argument, instead of the object of which this is the mark word.\n+inline bool markWord::must_be_preserved_with_bias_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const {\n+  assert(UseBiasedLocking, \"unexpected\");\n+  \/\/ CMS scavenges preserve mark words in similar fashion to promotion failures; see above\n+  if (has_bias_pattern() ||\n+      klass_of_obj_containing_mark->prototype_header().has_bias_pattern()) {\n+    return true;\n+  }\n+  return (!is_unlocked() || !has_no_hash());\n+}\n+\n+\/\/ Same as must_be_preserved_for_promotion_failure() except that\n+\/\/ it takes a Klass* argument, instead of the object of which this is the mark word.\n+inline bool markWord::must_be_preserved_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const {\n+  if (!UseBiasedLocking)\n+    return (!is_unlocked() || !has_no_hash());\n+  return must_be_preserved_with_bias_for_cms_scavenge(klass_of_obj_containing_mark);\n+}\n+\n+inline markWord markWord::prototype_for_object(oop obj) {\n+#ifdef ASSERT\n+  markWord prototype_header = obj->klass()->prototype_header();\n+  assert(prototype_header == prototype() || prototype_header.has_bias_pattern(), \"corrupt prototype header\");\n+#endif\n+  return obj->klass()->prototype_header();\n+}\n+\n+#endif \/\/ SHARE_VM_OOPS_MARKWORD_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -2105,1 +2105,1 @@\n-\/\/ Something that can't be mistaken for an address or a markOop\n+\/\/ Something that can't be mistaken for an address or a markWord\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  friend class CSetMarkOopClosure;\n+  friend class CSetMarkWordClosure;\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,2 +126,2 @@\n-  \/\/ Header verification: the mark is typically non-NULL. If we're\n-  \/\/ at a safepoint, it must not be null.\n+  \/\/ Header verification: the mark is typically non-zero. If we're\n+  \/\/ at a safepoint, it must not be zero.\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -60,1 +60,1 @@\n-  volatile markOop _mark;\n+  volatile markWord _mark;\n@@ -67,3 +67,3 @@\n-  inline markOop  mark()          const;\n-  inline markOop  mark_raw()      const;\n-  inline markOop* mark_addr_raw() const;\n+  inline markWord  mark()          const;\n+  inline markWord  mark_raw()      const;\n+  inline markWord* mark_addr_raw() const;\n@@ -71,3 +71,3 @@\n-  inline void set_mark(volatile markOop m);\n-  inline void set_mark_raw(volatile markOop m);\n-  static inline void set_mark_raw(HeapWord* mem, markOop m);\n+  inline void set_mark(volatile markWord m);\n+  inline void set_mark_raw(volatile markWord m);\n+  static inline void set_mark_raw(HeapWord* mem, markWord m);\n@@ -75,3 +75,3 @@\n-  inline void release_set_mark(markOop m);\n-  inline markOop cas_set_mark(markOop new_mark, markOop old_mark);\n-  inline markOop cas_set_mark_raw(markOop new_mark, markOop old_mark, atomic_memory_order order = memory_order_conservative);\n+  inline void release_set_mark(markWord m);\n+  inline markWord cas_set_mark(markWord new_mark, markWord old_mark);\n+  inline markWord cas_set_mark_raw(markWord new_mark, markWord old_mark, atomic_memory_order order = memory_order_conservative);\n@@ -265,1 +265,1 @@\n-  inline bool cas_forward_to(oop p, markOop compare, atomic_memory_order order = memory_order_conservative);\n+  inline bool cas_forward_to(oop p, markWord compare, atomic_memory_order order = memory_order_conservative);\n@@ -320,3 +320,3 @@\n-  inline bool    has_displaced_mark_raw() const;\n-  inline markOop displaced_mark_raw() const;\n-  inline void    set_displaced_mark_raw(markOop m);\n+  inline bool     has_displaced_mark_raw() const;\n+  inline markWord displaced_mark_raw() const;\n+  inline void     set_displaced_mark_raw(markWord m);\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/markOop.inline.hpp\"\n+#include \"oops\/markWord.inline.hpp\"\n@@ -46,1 +46,1 @@\n-markOop  oopDesc::mark()      const {\n+markWord  oopDesc::mark() const {\n@@ -48,1 +48,1 @@\n-  return markOop(v);\n+  return markWord(v);\n@@ -51,1 +51,1 @@\n-markOop  oopDesc::mark_raw()  const {\n+markWord  oopDesc::mark_raw() const {\n@@ -55,2 +55,2 @@\n-markOop* oopDesc::mark_addr_raw() const {\n-  return (markOop*) &_mark;\n+markWord* oopDesc::mark_addr_raw() const {\n+  return (markWord*) &_mark;\n@@ -59,1 +59,1 @@\n-void oopDesc::set_mark(markOop m) {\n+void oopDesc::set_mark(markWord m) {\n@@ -63,1 +63,1 @@\n-void oopDesc::set_mark_raw(markOop m) {\n+void oopDesc::set_mark_raw(markWord m) {\n@@ -67,2 +67,2 @@\n-void oopDesc::set_mark_raw(HeapWord* mem, markOop m) {\n-  *(markOop*)(((char*)mem) + mark_offset_in_bytes()) = m;\n+void oopDesc::set_mark_raw(HeapWord* mem, markWord m) {\n+  *(markWord*)(((char*)mem) + mark_offset_in_bytes()) = m;\n@@ -71,1 +71,1 @@\n-void oopDesc::release_set_mark(markOop m) {\n+void oopDesc::release_set_mark(markWord m) {\n@@ -75,1 +75,1 @@\n-markOop oopDesc::cas_set_mark(markOop new_mark, markOop old_mark) {\n+markWord oopDesc::cas_set_mark(markWord new_mark, markWord old_mark) {\n@@ -77,1 +77,1 @@\n-  return markOop(v);\n+  return markWord(v);\n@@ -80,1 +80,1 @@\n-markOop oopDesc::cas_set_mark_raw(markOop new_mark, markOop old_mark, atomic_memory_order order) {\n+markWord oopDesc::cas_set_mark_raw(markWord new_mark, markWord old_mark, atomic_memory_order order) {\n@@ -85,1 +85,1 @@\n-  set_mark(markOop::prototype_for_object(this));\n+  set_mark(markWord::prototype_for_object(this));\n@@ -89,1 +89,1 @@\n-  set_mark_raw(markOop::prototype_for_object(this));\n+  set_mark_raw(markWord::prototype_for_object(this));\n@@ -359,1 +359,1 @@\n-  markOop m = markOop::encode_pointer_as_mark(p);\n+  markWord m = markWord::encode_pointer_as_mark(p);\n@@ -365,1 +365,1 @@\n-bool oopDesc::cas_forward_to(oop p, markOop compare, atomic_memory_order order) {\n+bool oopDesc::cas_forward_to(oop p, markWord compare, atomic_memory_order order) {\n@@ -370,1 +370,1 @@\n-  markOop m = markOop::encode_pointer_as_mark(p);\n+  markWord m = markWord::encode_pointer_as_mark(p);\n@@ -376,3 +376,3 @@\n-  markOop oldMark = mark_raw();\n-  markOop forwardPtrMark = markOop::encode_pointer_as_mark(p);\n-  markOop curMark;\n+  markWord oldMark = mark_raw();\n+  markWord forwardPtrMark = markWord::encode_pointer_as_mark(p);\n+  markWord curMark;\n@@ -381,1 +381,1 @@\n-  assert(sizeof(markOop) == sizeof(intptr_t), \"CAS below requires this.\");\n+  assert(sizeof(markWord) == sizeof(intptr_t), \"CAS below requires this.\");\n@@ -492,1 +492,1 @@\n-  markOop mrk = mark();\n+  markWord mrk = mark();\n@@ -506,1 +506,1 @@\n-markOop oopDesc::displaced_mark_raw() const {\n+markWord oopDesc::displaced_mark_raw() const {\n@@ -510,1 +510,1 @@\n-void oopDesc::set_displaced_mark_raw(markOop m) {\n+void oopDesc::set_displaced_mark_raw(markWord m) {\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-typedef class oopDesc*                            oop;\n+typedef class oopDesc*                      oop;\n@@ -48,1 +48,1 @@\n-typedef class   arrayOopDesc*                    arrayOop;\n+typedef class   arrayOopDesc*               arrayOop;\n@@ -50,1 +50,1 @@\n-typedef class     typeArrayOopDesc*            typeArrayOop;\n+typedef class     typeArrayOopDesc*           typeArrayOop;\n@@ -83,1 +83,0 @@\n-  \/\/ friend class markOop;\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3963,1 +3963,1 @@\n-  Node *lock_mask      = _gvn.MakeConX(markOop::biased_lock_mask_in_place);\n+  Node *lock_mask      = _gvn.MakeConX(markWord::biased_lock_mask_in_place);\n@@ -3965,1 +3965,1 @@\n-  Node *unlocked_val   = _gvn.MakeConX(markOop::unlocked_value);\n+  Node *unlocked_val   = _gvn.MakeConX(markWord::unlocked_value);\n@@ -3974,3 +3974,3 @@\n-  \/\/ vm: see markOop.hpp.\n-  Node *hash_mask      = _gvn.intcon(markOop::hash_mask);\n-  Node *hash_shift     = _gvn.intcon(markOop::hash_shift);\n+  \/\/ vm: see markWord.hpp.\n+  Node *hash_mask      = _gvn.intcon(markWord::hash_mask);\n+  Node *hash_shift     = _gvn.intcon(markWord::hash_shift);\n@@ -3985,1 +3985,1 @@\n-  Node *no_hash_val    = _gvn.intcon(markOop::no_hash);\n+  Node *no_hash_val    = _gvn.intcon(markWord::no_hash);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1776,1 +1776,1 @@\n-    mark_node = makecon(TypeRawPtr::make((address)markOop::prototype().value()));\n+    mark_node = makecon(TypeRawPtr::make((address)markWord::prototype().value()));\n@@ -2333,2 +2333,2 @@\n-                         markOop::biased_lock_mask_in_place,\n-                         markOop::biased_lock_pattern, true);\n+                         markWord::biased_lock_mask_in_place,\n+                         markWord::biased_lock_pattern, true);\n@@ -2363,1 +2363,1 @@\n-                                      (~markOop::age_mask_in_place), 0);\n+                                      (~markWord::age_mask_in_place), 0);\n@@ -2374,1 +2374,1 @@\n-                          markOop::biased_lock_mask_in_place, 0, true);\n+                          markWord::biased_lock_mask_in_place, 0, true);\n@@ -2396,1 +2396,1 @@\n-                                      markOop::epoch_mask_in_place, 0);\n+                                      markWord::epoch_mask_in_place, 0);\n@@ -2406,3 +2406,3 @@\n-    Node* cmask   = MakeConX(markOop::biased_lock_mask_in_place |\n-                             markOop::age_mask_in_place |\n-                             markOop::epoch_mask_in_place);\n+    Node* cmask   = MakeConX(markWord::biased_lock_mask_in_place |\n+                             markWord::age_mask_in_place |\n+                             markWord::epoch_mask_in_place);\n@@ -2523,2 +2523,2 @@\n-                         markOop::biased_lock_mask_in_place,\n-                         markOop::biased_lock_pattern);\n+                         markWord::biased_lock_mask_in_place,\n+                         markWord::biased_lock_pattern);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -146,2 +146,2 @@\n-# include \"oops\/markOop.hpp\"\n-# include \"oops\/markOop.inline.hpp\"\n+# include \"oops\/markWord.hpp\"\n+# include \"oops\/markWord.inline.hpp\"\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -966,1 +966,1 @@\n-      markOop mark = hobj()->mark();\n+      markWord mark = hobj()->mark();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1647,1 +1647,1 @@\n-      markOop mark = o->mark();\n+      markWord mark = o->mark();\n@@ -1660,1 +1660,1 @@\n-  static GrowableArray<markOop>* _saved_mark_stack;\n+  static GrowableArray<markWord>* _saved_mark_stack;\n@@ -1675,1 +1675,1 @@\n-GrowableArray<markOop>* ObjectMarker::_saved_mark_stack = NULL;\n+GrowableArray<markWord>* ObjectMarker::_saved_mark_stack = NULL;\n@@ -1686,1 +1686,1 @@\n-  _saved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<markOop>(4000, true);\n+  _saved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<markWord>(4000, true);\n@@ -1710,1 +1710,1 @@\n-    markOop mark = _saved_mark_stack->at(i);\n+    markWord mark = _saved_mark_stack->at(i);\n@@ -1729,1 +1729,1 @@\n-  markOop mark = o->mark();\n+  markWord mark = o->mark();\n@@ -1737,1 +1737,1 @@\n-  o->set_mark(markOop::prototype().set_marked());\n+  o->set_mark(markWord::prototype().set_marked());\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2882,1 +2882,1 @@\n-      if (FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, markOop::max_age + 1) != JVMFlag::SUCCESS) {\n+      if (FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, markWord::max_age + 1) != JVMFlag::SUCCESS) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,3 +31,3 @@\n-  markOop moop = displaced_header();\n-  if (moop.value() != 0)\n-    moop.print_on(st);\n+  markWord mark_word = displaced_header();\n+  if (mark_word.value() != 0)\n+    mark_word.print_on(st);\n","filename":"src\/hotspot\/share\/runtime\/basicLock.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -36,1 +36,1 @@\n-  volatile markOop _displaced_header;\n+  volatile markWord _displaced_header;\n@@ -38,1 +38,1 @@\n-  markOop displaced_header() const {\n+  markWord displaced_header() const {\n@@ -42,1 +42,1 @@\n-  void set_displaced_header(markOop header) {\n+  void set_displaced_header(markWord header) {\n","filename":"src\/hotspot\/share\/runtime\/basicLock.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -48,2 +48,2 @@\n-static GrowableArray<Handle>*  _preserved_oop_stack  = NULL;\n-static GrowableArray<markOop>* _preserved_mark_stack = NULL;\n+static GrowableArray<Handle>*   _preserved_oop_stack  = NULL;\n+static GrowableArray<markWord>* _preserved_mark_stack = NULL;\n@@ -52,1 +52,1 @@\n-  k->set_prototype_header(markOop::biased_locking_prototype());\n+  k->set_prototype_header(markWord::biased_locking_prototype());\n@@ -156,1 +156,1 @@\n-  markOop mark = obj->mark();\n+  markWord mark = obj->mark();\n@@ -164,1 +164,1 @@\n-                              p2i((void *)obj), (intptr_t) mark.value(),\n+                              p2i((void *)obj), mark.value(),\n@@ -172,2 +172,2 @@\n-  markOop   biased_prototype = markOop::biased_locking_prototype().set_age(age);\n-  markOop unbiased_prototype = markOop::prototype().set_age(age);\n+  markWord   biased_prototype = markWord::biased_locking_prototype().set_age(age);\n+  markWord unbiased_prototype = markWord::prototype().set_age(age);\n@@ -182,1 +182,1 @@\n-                            (intptr_t) mark.value(),\n+                            mark.value(),\n@@ -184,1 +184,1 @@\n-                            (intptr_t) obj->klass()->prototype_header().value(),\n+                            obj->klass()->prototype_header().value(),\n@@ -193,1 +193,1 @@\n-                             (intptr_t) mark.value(),\n+                             mark.value(),\n@@ -195,1 +195,1 @@\n-                             (intptr_t) obj->klass()->prototype_header().value(),\n+                             obj->klass()->prototype_header().value(),\n@@ -265,1 +265,1 @@\n-      markOop mark = markOop::encode((BasicLock*) NULL);\n+      markWord mark = markWord::encode((BasicLock*) NULL);\n@@ -281,1 +281,1 @@\n-    obj->release_set_mark(markOop::encode(highest_lock));\n+    obj->release_set_mark(markWord::encode(highest_lock));\n@@ -322,1 +322,1 @@\n-  markOop mark = o->mark();\n+  markWord mark = o->mark();\n@@ -384,1 +384,1 @@\n-                          (intptr_t) o->mark().value(),\n+                          o->mark().value(),\n@@ -420,1 +420,1 @@\n-            markOop mark = owner->mark();\n+            markWord mark = owner->mark();\n@@ -443,1 +443,1 @@\n-      klass->set_prototype_header(markOop::prototype());\n+      klass->set_prototype_header(markWord::prototype());\n@@ -452,1 +452,1 @@\n-          markOop mark = owner->mark();\n+          markWord mark = owner->mark();\n@@ -472,1 +472,1 @@\n-    markOop new_mark = markOop::encode(requesting_thread, o->mark().age(),\n+    markWord new_mark = markWord::encode(requesting_thread, o->mark().age(),\n@@ -525,1 +525,1 @@\n-      markOop mark = (*_obj)()->mark();\n+      markWord mark = (*_obj)()->mark();\n@@ -531,1 +531,1 @@\n-        markOop mark = (_objs->at(i))()->mark();\n+        markWord mark = (_objs->at(i))()->mark();\n@@ -631,1 +631,1 @@\n-  markOop mark = obj->mark();\n+  markWord mark = obj->mark();\n@@ -639,3 +639,3 @@\n-    markOop biased_value       = mark;\n-    markOop unbiased_prototype = markOop::prototype().set_age(mark.age());\n-    markOop res_mark = obj->cas_set_mark(unbiased_prototype, mark);\n+    markWord biased_value       = mark;\n+    markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n+    markWord res_mark = obj->cas_set_mark(unbiased_prototype, mark);\n@@ -647,1 +647,1 @@\n-    markOop prototype_header = k->prototype_header();\n+    markWord prototype_header = k->prototype_header();\n@@ -655,2 +655,2 @@\n-      markOop biased_value       = mark;\n-      markOop res_mark = obj->cas_set_mark(prototype_header, mark);\n+      markWord biased_value       = mark;\n+      markWord res_mark = obj->cas_set_mark(prototype_header, mark);\n@@ -669,3 +669,3 @@\n-        markOop biased_value       = mark;\n-        markOop rebiased_prototype = markOop::encode((JavaThread*) THREAD, mark.age(), prototype_header.bias_epoch());\n-        markOop res_mark = obj->cas_set_mark(rebiased_prototype, mark);\n+        markWord biased_value       = mark;\n+        markWord rebiased_prototype = markWord::encode((JavaThread*) THREAD, mark.age(), prototype_header.bias_epoch());\n+        markWord res_mark = obj->cas_set_mark(rebiased_prototype, mark);\n@@ -676,3 +676,3 @@\n-        markOop biased_value       = mark;\n-        markOop unbiased_prototype = markOop::prototype().set_age(mark.age());\n-        markOop res_mark = obj->cas_set_mark(unbiased_prototype, mark);\n+        markWord biased_value       = mark;\n+        markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n+        markWord res_mark = obj->cas_set_mark(unbiased_prototype, mark);\n@@ -691,1 +691,1 @@\n-    markOop prototype_header = k->prototype_header();\n+    markWord prototype_header = k->prototype_header();\n@@ -797,1 +797,1 @@\n-  _preserved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<markOop>(10, true);\n+  _preserved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<markWord>(10, true);\n@@ -816,1 +816,1 @@\n-              markOop mark = owner->mark();\n+              markWord mark = owner->mark();\n@@ -840,1 +840,1 @@\n-    markOop mark = _preserved_mark_stack->at(i);\n+    markWord mark = _preserved_mark_stack->at(i);\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.cpp","additions":39,"deletions":39,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-\/\/ unbiased markOop. The fast-path locking code checks to see whether\n+\/\/ unbiased markWord. The fast-path locking code checks to see whether\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1123,1 +1123,1 @@\n-        markOop mark = obj->mark();\n+        markWord mark = obj->mark();\n@@ -1131,1 +1131,1 @@\n-          markOop unbiased_prototype = markOop::prototype().set_age(mark.age());\n+          markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagRangeList.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2589,1 +2589,1 @@\n-          range(1, markOop::max_age)                                        \\\n+          range(1, markWord::max_age)                                       \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -305,1 +305,1 @@\n-    assert(((oop)(object()))->mark() == markOop::encode(this), \"invariant\");\n+    assert(((oop)(object()))->mark() == markWord::encode(this), \"invariant\");\n@@ -390,1 +390,1 @@\n-  assert(((oop)(object()))->mark() == markOop::encode(this), \"invariant\");\n+  assert(((oop)(object()))->mark() == markWord::encode(this), \"invariant\");\n@@ -624,1 +624,1 @@\n-  \/\/   guarantee (((oop)(object()))->mark() == markOop::encode(this), \"invariant\") ;\n+  \/\/   guarantee (((oop)(object()))->mark() == markWord::encode(this), \"invariant\") ;\n@@ -697,1 +697,1 @@\n-  assert(((oop)(object()))->mark() == markOop::encode(this), \"invariant\");\n+  assert(((oop)(object()))->mark() == markWord::encode(this), \"invariant\");\n@@ -772,1 +772,1 @@\n-  assert(((oop)(object()))->mark() == markOop::encode(this), \"invariant\");\n+  assert(((oop)(object()))->mark() == markWord::encode(this), \"invariant\");\n@@ -1623,1 +1623,1 @@\n-  assert(((oop)(object()))->mark() == markOop::encode(this), \"invariant\");\n+  assert(((oop)(object()))->mark() == markWord::encode(this), \"invariant\");\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -78,1 +78,1 @@\n-\/\/   from markOop is stored there. We do not want markOop.hpp to include\n+\/\/   from markWord is stored there. We do not want markWord.hpp to include\n@@ -144,1 +144,1 @@\n-  volatile markOop   _header;       \/\/ displaced object header word - mark\n+  volatile markWord   _header;       \/\/ displaced object header word - mark\n@@ -150,1 +150,1 @@\n-                        sizeof(volatile markOop) + sizeof(void * volatile) +\n+                        sizeof(volatile markWord) + sizeof(void * volatile) +\n@@ -222,1 +222,1 @@\n-  \/\/ ObjectMonitor references can be ORed with markOop::monitor_value\n+  \/\/ ObjectMonitor references can be ORed with markWord::monitor_value\n@@ -234,1 +234,1 @@\n-    ((ObjectMonitor::f ## _offset_in_bytes()) - markOop::monitor_value)\n+    ((ObjectMonitor::f ## _offset_in_bytes()) - markWord::monitor_value)\n@@ -236,3 +236,3 @@\n-  markOop   header() const;\n-  volatile markOop* header_addr();\n-  void      set_header(markOop hdr);\n+  markWord           header() const;\n+  volatile markWord* header_addr();\n+  void               set_header(markWord hdr);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-inline markOop ObjectMonitor::header() const {\n+inline markWord ObjectMonitor::header() const {\n@@ -41,1 +41,1 @@\n-inline volatile markOop* ObjectMonitor::header_addr() {\n+inline volatile markWord* ObjectMonitor::header_addr() {\n@@ -46,1 +46,1 @@\n-inline void ObjectMonitor::set_header(markOop hdr) {\n+inline void ObjectMonitor::set_header(markWord hdr) {\n@@ -70,1 +70,1 @@\n-  Atomic::store(markOop::zero(), &_header);\n+  Atomic::store(markWord::zero(), &_header);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -161,1 +161,1 @@\n-  const markOop mark = obj->mark();\n+  const markWord mark = obj->mark();\n@@ -211,1 +211,1 @@\n-  const markOop mark = obj->mark();\n+  const markWord mark = obj->mark();\n@@ -238,1 +238,1 @@\n-    lock->set_displaced_header(markOop::unused_mark());\n+    lock->set_displaced_header(markWord::unused_mark());\n@@ -283,1 +283,1 @@\n-  markOop mark = object->mark();\n+  markWord mark = object->mark();\n@@ -285,1 +285,1 @@\n-  assert(mark == markOop::INFLATING() ||\n+  assert(mark == markWord::INFLATING() ||\n@@ -288,1 +288,1 @@\n-  markOop dhw = lock->displaced_header();\n+  markWord dhw = lock->displaced_header();\n@@ -293,1 +293,1 @@\n-    if (mark != markOop::INFLATING()) {\n+    if (mark != markWord::INFLATING()) {\n@@ -318,1 +318,1 @@\n-  if (mark == markOop::from_pointer(lock)) {\n+  if (mark == markWord::from_pointer(lock)) {\n@@ -340,1 +340,1 @@\n-  markOop mark = obj->mark();\n+  markWord mark = obj->mark();\n@@ -347,1 +347,1 @@\n-    if (mark == obj()->cas_set_mark(markOop::from_pointer(lock), mark)) {\n+    if (mark == obj()->cas_set_mark(markWord::from_pointer(lock), mark)) {\n@@ -356,1 +356,1 @@\n-    lock->set_displaced_header(markOop::from_pointer(NULL));\n+    lock->set_displaced_header(markWord::from_pointer(NULL));\n@@ -364,1 +364,1 @@\n-  lock->set_displaced_header(markOop::unused_mark());\n+  lock->set_displaced_header(markWord::unused_mark());\n@@ -522,1 +522,1 @@\n-  markOop mark = obj->mark();\n+  markWord mark = obj->mark();\n@@ -538,1 +538,1 @@\n-  markOop mark = obj->mark();\n+  markWord mark = obj->mark();\n@@ -584,2 +584,2 @@\n-static markOop ReadStableMark(oop obj) {\n-  markOop mark = obj->mark();\n+static markWord ReadStableMark(oop obj) {\n+  markWord mark = obj->mark();\n@@ -592,1 +592,1 @@\n-    markOop mark = obj->mark();\n+    markWord mark = obj->mark();\n@@ -633,1 +633,1 @@\n-        while (obj->mark() == markOop::INFLATING()) {\n+        while (obj->mark() == markWord::INFLATING()) {\n@@ -703,1 +703,1 @@\n-  value &= markOop::hash_mask;\n+  value &= markWord::hash_mask;\n@@ -705,1 +705,1 @@\n-  assert(value != markOop::no_hash, \"invariant\");\n+  assert(value != markWord::no_hash, \"invariant\");\n@@ -742,1 +742,1 @@\n-  markOop temp, test;\n+  markWord temp, test;\n@@ -744,1 +744,1 @@\n-  markOop mark = ReadStableMark(obj);\n+  markWord mark = ReadStableMark(obj);\n@@ -776,2 +776,2 @@\n-    hash = temp.hash();              \/\/ by current thread, check if the displaced\n-    if (hash) {                       \/\/ header contains hash code\n+    hash = temp.hash();                  \/\/ by current thread, check if the displaced\n+    if (hash) {                          \/\/ header contains hash code\n@@ -801,2 +801,2 @@\n-    uintptr_t t = Atomic::cmpxchg(temp.value(), (volatile uintptr_t*)monitor->header_addr(), mark.value());\n-    test = markOop(t);\n+    uintptr_t v = Atomic::cmpxchg(temp.value(), (volatile uintptr_t*)monitor->header_addr(), mark.value());\n+    test = markWord(v);\n@@ -833,1 +833,1 @@\n-  markOop mark = ReadStableMark(obj);\n+  markWord mark = ReadStableMark(obj);\n@@ -872,1 +872,1 @@\n-  markOop mark = ReadStableMark(obj);\n+  markWord mark = ReadStableMark(obj);\n@@ -909,1 +909,1 @@\n-  markOop mark = ReadStableMark(obj);\n+  markWord mark = ReadStableMark(obj);\n@@ -1377,1 +1377,1 @@\n-  markOop mark = obj->mark();\n+  markWord mark = obj->mark();\n@@ -1400,1 +1400,1 @@\n-    const markOop mark = object->mark();\n+    const markWord mark = object->mark();\n@@ -1425,1 +1425,1 @@\n-    if (mark == markOop::INFLATING()) {\n+    if (mark == markWord::INFLATING()) {\n@@ -1460,1 +1460,1 @@\n-      markOop cmp = object->cas_set_mark(markOop::INFLATING(), mark);\n+      markWord cmp = object->cas_set_mark(markWord::INFLATING(), mark);\n@@ -1496,1 +1496,1 @@\n-      markOop dmw = mark.displaced_mark_helper();\n+      markWord dmw = mark.displaced_mark_helper();\n@@ -1513,2 +1513,2 @@\n-      guarantee(object->mark() == markOop::INFLATING(), \"invariant\");\n-      object->release_set_mark(markOop::encode(m));\n+      guarantee(object->mark() == markWord::INFLATING(), \"invariant\");\n+      object->release_set_mark(markWord::encode(m));\n@@ -1555,1 +1555,1 @@\n-    if (object->cas_set_mark(markOop::encode(m), mark) != mark) {\n+    if (object->cas_set_mark(markWord::encode(m), mark) != mark) {\n@@ -1626,1 +1626,1 @@\n-  guarantee(obj->mark() == markOop::encode(mid), \"invariant\");\n+  guarantee(obj->mark() == markWord::encode(mid), \"invariant\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":39,"deletions":39,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-    const int alignment = markOop::biased_lock_alignment;\n+    const int alignment = markWord::biased_lock_alignment;\n@@ -307,1 +307,1 @@\n-    assert((((uintptr_t) this) & (markOop::biased_lock_alignment - 1)) == 0, \"forced alignment of thread object failed\");\n+    assert((((uintptr_t) this) & (markWord::biased_lock_alignment - 1)) == 0, \"forced alignment of thread object failed\");\n@@ -309,1 +309,1 @@\n-           this == align_up(_real_malloc_address, (int)markOop::biased_lock_alignment),\n+           this == align_up(_real_malloc_address, (int)markWord::biased_lock_alignment),\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-        markOop mark = markOop::zero();\n+        markWord mark = markWord::zero();\n@@ -244,1 +244,1 @@\n-            mark = markOop::zero();\n+            mark = markWord::zero();\n@@ -263,1 +263,1 @@\n-            mark = markOop::zero();\n+            mark = markWord::zero();\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -206,1 +206,1 @@\n-  volatile_nonstatic_field(oopDesc,            _mark,                                         markOop)                               \\\n+  volatile_nonstatic_field(oopDesc,            _mark,                                         markWord)                              \\\n@@ -269,1 +269,1 @@\n-  nonstatic_field(Klass,                       _prototype_header,                             markOop)                               \\\n+  nonstatic_field(Klass,                       _prototype_header,                             markWord)                              \\\n@@ -927,1 +927,1 @@\n-  volatile_nonstatic_field(ObjectMonitor,      _header,                                       markOop)                               \\\n+  volatile_nonstatic_field(ObjectMonitor,      _header,                                       markWord)                              \\\n@@ -934,1 +934,1 @@\n-  volatile_nonstatic_field(BasicLock,          _displaced_header,                             markOop)                               \\\n+  volatile_nonstatic_field(BasicLock,          _displaced_header,                             markWord)                              \\\n@@ -1981,2 +1981,2 @@\n-   declare_integer_type(AccessFlags)  \/* FIXME: wrong type (not integer) *\/\\\n-   declare_integer_type(markOop)                                          \\\n+  declare_integer_type(AccessFlags)  \/* FIXME: wrong type (not integer) *\/\\\n+  declare_integer_type(markWord)                                          \\\n@@ -1984,1 +1984,1 @@\n-   declare_integer_type(BasicType)   \/* FIXME: wrong type (not integer) *\/\\\n+  declare_integer_type(BasicType)   \/* FIXME: wrong type (not integer) *\/ \\\n@@ -2637,1 +2637,1 @@\n-  \/* MarkOop constants *\/                                                 \\\n+  \/* MarkWord constants *\/                                                \\\n@@ -2644,39 +2644,39 @@\n-  declare_constant(markOop::age_bits)                                 \\\n-  declare_constant(markOop::lock_bits)                                \\\n-  declare_constant(markOop::biased_lock_bits)                         \\\n-  declare_constant(markOop::max_hash_bits)                            \\\n-  declare_constant(markOop::hash_bits)                                \\\n-                                                                          \\\n-  declare_constant(markOop::lock_shift)                               \\\n-  declare_constant(markOop::biased_lock_shift)                        \\\n-  declare_constant(markOop::age_shift)                                \\\n-  declare_constant(markOop::hash_shift)                               \\\n-                                                                          \\\n-  declare_constant(markOop::lock_mask)                                \\\n-  declare_constant(markOop::lock_mask_in_place)                       \\\n-  declare_constant(markOop::biased_lock_mask)                         \\\n-  declare_constant(markOop::biased_lock_mask_in_place)                \\\n-  declare_constant(markOop::biased_lock_bit_in_place)                 \\\n-  declare_constant(markOop::age_mask)                                 \\\n-  declare_constant(markOop::age_mask_in_place)                        \\\n-  declare_constant(markOop::epoch_mask)                               \\\n-  declare_constant(markOop::epoch_mask_in_place)                      \\\n-  declare_constant(markOop::hash_mask)                                \\\n-  declare_constant(markOop::hash_mask_in_place)                       \\\n-  declare_constant(markOop::biased_lock_alignment)                    \\\n-                                                                          \\\n-  declare_constant(markOop::locked_value)                             \\\n-  declare_constant(markOop::unlocked_value)                           \\\n-  declare_constant(markOop::monitor_value)                            \\\n-  declare_constant(markOop::marked_value)                             \\\n-  declare_constant(markOop::biased_lock_pattern)                      \\\n-                                                                          \\\n-  declare_constant(markOop::no_hash)                                  \\\n-  declare_constant(markOop::no_hash_in_place)                         \\\n-  declare_constant(markOop::no_lock_in_place)                         \\\n-  declare_constant(markOop::max_age)                                  \\\n-                                                                          \\\n-  \/* Constants in markOop used by CMS. *\/                                 \\\n-  declare_constant(markOop::cms_shift)                                \\\n-  declare_constant(markOop::cms_mask)                                 \\\n-  declare_constant(markOop::size_shift)                               \\\n+  declare_constant(markWord::age_bits)                                    \\\n+  declare_constant(markWord::lock_bits)                                   \\\n+  declare_constant(markWord::biased_lock_bits)                            \\\n+  declare_constant(markWord::max_hash_bits)                               \\\n+  declare_constant(markWord::hash_bits)                                   \\\n+                                                                          \\\n+  declare_constant(markWord::lock_shift)                                  \\\n+  declare_constant(markWord::biased_lock_shift)                           \\\n+  declare_constant(markWord::age_shift)                                   \\\n+  declare_constant(markWord::hash_shift)                                  \\\n+                                                                          \\\n+  declare_constant(markWord::lock_mask)                                   \\\n+  declare_constant(markWord::lock_mask_in_place)                          \\\n+  declare_constant(markWord::biased_lock_mask)                            \\\n+  declare_constant(markWord::biased_lock_mask_in_place)                   \\\n+  declare_constant(markWord::biased_lock_bit_in_place)                    \\\n+  declare_constant(markWord::age_mask)                                    \\\n+  declare_constant(markWord::age_mask_in_place)                           \\\n+  declare_constant(markWord::epoch_mask)                                  \\\n+  declare_constant(markWord::epoch_mask_in_place)                         \\\n+  declare_constant(markWord::hash_mask)                                   \\\n+  declare_constant(markWord::hash_mask_in_place)                          \\\n+  declare_constant(markWord::biased_lock_alignment)                       \\\n+                                                                          \\\n+  declare_constant(markWord::locked_value)                                \\\n+  declare_constant(markWord::unlocked_value)                              \\\n+  declare_constant(markWord::monitor_value)                               \\\n+  declare_constant(markWord::marked_value)                                \\\n+  declare_constant(markWord::biased_lock_pattern)                         \\\n+                                                                          \\\n+  declare_constant(markWord::no_hash)                                     \\\n+  declare_constant(markWord::no_hash_in_place)                            \\\n+  declare_constant(markWord::no_lock_in_place)                            \\\n+  declare_constant(markWord::max_age)                                     \\\n+                                                                          \\\n+  \/* Constants in markWord used by CMS. *\/                                \\\n+  declare_constant(markWord::cms_shift)                                   \\\n+  declare_constant(markWord::cms_mask)                                    \\\n+  declare_constant(markWord::size_shift)                                  \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":48,"deletions":48,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -658,8 +658,1 @@\n-        \/\/ HACK: turn markOop into a C integer type. This allows\n-        \/\/ proper handling of it in the Serviceability Agent. (FIXME\n-        \/\/ -- consider doing something different here)\n-        if (typeName.equals(\"markOop\")) {\n-          type = new BasicCIntegerType(this, typeName, true);\n-        } else {\n-          type.setIsOopType(true);\n-        }\n+        type.setIsOopType(true);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HotSpotTypeDataBase.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,6 +35,0 @@\n-\/** Mark is the analogue of the VM's markOop. In this system it does\n-    not subclass Oop but VMObject. For a mark on the stack, the mark's\n-    address will be an Address; for a mark in the header of an object,\n-    it will be an OopHandle. It is assumed in a couple of places in\n-    this code that the mark is the first word in an object. *\/\n-\n@@ -54,33 +48,33 @@\n-    ageBits             = db.lookupLongConstant(\"markOop::age_bits\").longValue();\n-    lockBits            = db.lookupLongConstant(\"markOop::lock_bits\").longValue();\n-    biasedLockBits      = db.lookupLongConstant(\"markOop::biased_lock_bits\").longValue();\n-    maxHashBits         = db.lookupLongConstant(\"markOop::max_hash_bits\").longValue();\n-    hashBits            = db.lookupLongConstant(\"markOop::hash_bits\").longValue();\n-    lockShift           = db.lookupLongConstant(\"markOop::lock_shift\").longValue();\n-    biasedLockShift     = db.lookupLongConstant(\"markOop::biased_lock_shift\").longValue();\n-    ageShift            = db.lookupLongConstant(\"markOop::age_shift\").longValue();\n-    hashShift           = db.lookupLongConstant(\"markOop::hash_shift\").longValue();\n-    lockMask            = db.lookupLongConstant(\"markOop::lock_mask\").longValue();\n-    lockMaskInPlace     = db.lookupLongConstant(\"markOop::lock_mask_in_place\").longValue();\n-    biasedLockMask      = db.lookupLongConstant(\"markOop::biased_lock_mask\").longValue();\n-    biasedLockMaskInPlace  = db.lookupLongConstant(\"markOop::biased_lock_mask_in_place\").longValue();\n-    biasedLockBitInPlace  = db.lookupLongConstant(\"markOop::biased_lock_bit_in_place\").longValue();\n-    ageMask             = db.lookupLongConstant(\"markOop::age_mask\").longValue();\n-    ageMaskInPlace      = db.lookupLongConstant(\"markOop::age_mask_in_place\").longValue();\n-    hashMask            = db.lookupLongConstant(\"markOop::hash_mask\").longValue();\n-    hashMaskInPlace     = db.lookupLongConstant(\"markOop::hash_mask_in_place\").longValue();\n-    biasedLockAlignment  = db.lookupLongConstant(\"markOop::biased_lock_alignment\").longValue();\n-    lockedValue         = db.lookupLongConstant(\"markOop::locked_value\").longValue();\n-    unlockedValue       = db.lookupLongConstant(\"markOop::unlocked_value\").longValue();\n-    monitorValue        = db.lookupLongConstant(\"markOop::monitor_value\").longValue();\n-    markedValue         = db.lookupLongConstant(\"markOop::marked_value\").longValue();\n-    biasedLockPattern = db.lookupLongConstant(\"markOop::biased_lock_pattern\").longValue();\n-    noHash              = db.lookupLongConstant(\"markOop::no_hash\").longValue();\n-    noHashInPlace       = db.lookupLongConstant(\"markOop::no_hash_in_place\").longValue();\n-    noLockInPlace       = db.lookupLongConstant(\"markOop::no_lock_in_place\").longValue();\n-    maxAge              = db.lookupLongConstant(\"markOop::max_age\").longValue();\n-\n-    \/* Constants in markOop used by CMS. *\/\n-    cmsShift            = db.lookupLongConstant(\"markOop::cms_shift\").longValue();\n-    cmsMask             = db.lookupLongConstant(\"markOop::cms_mask\").longValue();\n-    sizeShift           = db.lookupLongConstant(\"markOop::size_shift\").longValue();\n+    ageBits             = db.lookupLongConstant(\"markWord::age_bits\").longValue();\n+    lockBits            = db.lookupLongConstant(\"markWord::lock_bits\").longValue();\n+    biasedLockBits      = db.lookupLongConstant(\"markWord::biased_lock_bits\").longValue();\n+    maxHashBits         = db.lookupLongConstant(\"markWord::max_hash_bits\").longValue();\n+    hashBits            = db.lookupLongConstant(\"markWord::hash_bits\").longValue();\n+    lockShift           = db.lookupLongConstant(\"markWord::lock_shift\").longValue();\n+    biasedLockShift     = db.lookupLongConstant(\"markWord::biased_lock_shift\").longValue();\n+    ageShift            = db.lookupLongConstant(\"markWord::age_shift\").longValue();\n+    hashShift           = db.lookupLongConstant(\"markWord::hash_shift\").longValue();\n+    lockMask            = db.lookupLongConstant(\"markWord::lock_mask\").longValue();\n+    lockMaskInPlace     = db.lookupLongConstant(\"markWord::lock_mask_in_place\").longValue();\n+    biasedLockMask      = db.lookupLongConstant(\"markWord::biased_lock_mask\").longValue();\n+    biasedLockMaskInPlace  = db.lookupLongConstant(\"markWord::biased_lock_mask_in_place\").longValue();\n+    biasedLockBitInPlace  = db.lookupLongConstant(\"markWord::biased_lock_bit_in_place\").longValue();\n+    ageMask             = db.lookupLongConstant(\"markWord::age_mask\").longValue();\n+    ageMaskInPlace      = db.lookupLongConstant(\"markWord::age_mask_in_place\").longValue();\n+    hashMask            = db.lookupLongConstant(\"markWord::hash_mask\").longValue();\n+    hashMaskInPlace     = db.lookupLongConstant(\"markWord::hash_mask_in_place\").longValue();\n+    biasedLockAlignment  = db.lookupLongConstant(\"markWord::biased_lock_alignment\").longValue();\n+    lockedValue         = db.lookupLongConstant(\"markWord::locked_value\").longValue();\n+    unlockedValue       = db.lookupLongConstant(\"markWord::unlocked_value\").longValue();\n+    monitorValue        = db.lookupLongConstant(\"markWord::monitor_value\").longValue();\n+    markedValue         = db.lookupLongConstant(\"markWord::marked_value\").longValue();\n+    biasedLockPattern = db.lookupLongConstant(\"markWord::biased_lock_pattern\").longValue();\n+    noHash              = db.lookupLongConstant(\"markWord::no_hash\").longValue();\n+    noHashInPlace       = db.lookupLongConstant(\"markWord::no_hash_in_place\").longValue();\n+    noLockInPlace       = db.lookupLongConstant(\"markWord::no_lock_in_place\").longValue();\n+    maxAge              = db.lookupLongConstant(\"markWord::max_age\").longValue();\n+\n+    \/* Constants in markWord used by CMS. *\/\n+    cmsShift            = db.lookupLongConstant(\"markWord::cms_shift\").longValue();\n+    cmsMask             = db.lookupLongConstant(\"markWord::cms_mask\").longValue();\n+    sizeShift           = db.lookupLongConstant(\"markWord::size_shift\").longValue();\n@@ -128,1 +122,1 @@\n-  \/* Constants in markOop used by CMS. *\/\n+  \/* Constants in markWord used by CMS. *\/\n@@ -178,1 +172,1 @@\n-  \/\/ Special temporary state of the markOop while being inflated.\n+  \/\/ Special temporary state of the markWord while being inflated.\n@@ -191,1 +185,1 @@\n-  \/\/ They must get updated if markOop layout get changed.\n+  \/\/ They must get updated if markWord layout get changed.\n@@ -193,4 +187,0 @@\n-  \/\/ FIXME\n-  \/\/  markOop set_unlocked() const {\n-  \/\/    return markOop(value() | unlocked_value);\n-  \/\/  }\n@@ -227,32 +217,0 @@\n-  \/\/ FIXME\n-  \/\/  void set_displaced_mark_helper(markOop m) const {\n-  \/\/    assert(has_displaced_mark_helper(), \"check\");\n-  \/\/    intptr_t ptr = (value() & ~monitor_value);\n-  \/\/    *(markOop*)ptr = m;\n-  \/\/  }\n-  \/\/  markOop copy_set_hash(intptr_t hash) const {\n-  \/\/    intptr_t tmp = value() & (~hash_mask_in_place);\n-  \/\/    tmp |= ((hash & hash_mask) << hash_shift);\n-  \/\/    return (markOop)tmp;\n-  \/\/  }\n-  \/\/ it is only used to be stored into BasicLock as the\n-  \/\/ indicator that the lock is using heavyweight monitor\n-  \/\/  static markOop unused_mark() {\n-  \/\/    return (markOop) marked_value;\n-  \/\/  }\n-  \/\/  \/\/ the following two functions create the markOop to be\n-  \/\/  \/\/ stored into object header, it encodes monitor info\n-  \/\/  static markOop encode(BasicLock* lock) {\n-  \/\/    return (markOop) lock;\n-  \/\/  }\n-  \/\/  static markOop encode(ObjectMonitor* monitor) {\n-  \/\/    intptr_t tmp = (intptr_t) monitor;\n-  \/\/    return (markOop) (tmp | monitor_value);\n-  \/\/  }\n-  \/\/ used for alignment-based marking to reuse the busy state to encode pointers\n-  \/\/ (see markOop_alignment.hpp)\n-  \/\/  markOop clear_lock_bits() { return markOop(value() & ~lock_mask_in_place); }\n-  \/\/\n-  \/\/  \/\/ age operations\n-  \/\/  markOop set_marked()   { return markOop((value() & ~lock_mask_in_place) | marked_value); }\n-  \/\/\n@@ -260,5 +218,0 @@\n-  \/\/  markOop set_age(int v) const {\n-  \/\/    assert((v & ~age_mask) == 0, \"shouldn't overflow age field\");\n-  \/\/    return markOop((value() & ~age_mask_in_place) | (((intptr_t)v & age_mask) << age_shift));\n-  \/\/  }\n-  \/\/  markOop incr_age()          const { return age() == max_age ? markOop(this) : set_age(age() + 1); }\n@@ -275,6 +228,0 @@\n-  \/\/ FIXME\n-  \/\/ Prototype mark for initialization\n-  \/\/  static markOop prototype() {\n-  \/\/    return markOop( no_hash_in_place | no_lock_in_place );\n-  \/\/  }\n-\n@@ -297,8 +244,1 @@\n-  \/\/ FIXME\n-  \/\/  \/\/ Prepare address of oop for placement into mark\n-  \/\/  inline static markOop encode_pointer_as_mark(void* p) { return markOop(p)->set_marked(); }\n-  \/\/\n-  \/\/  \/\/ Recover address of oop from encoded form used in mark\n-  \/\/  inline void* decode_pointer() { return clear_lock_bits(); }\n-\n-  \/\/ Copy markOop methods for CMS here.\n+  \/\/ Copy markWord methods for CMS here.\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Mark.java","additions":37,"deletions":97,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-  \/\/  void      set_header(markOop hdr);\n+  \/\/  void      set_header(markWord hdr);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectMonitor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    final int prototypeMarkWordOffset = getFieldOffset(\"Klass::_prototype_header\", Integer.class, \"markOop\");\n+    final int prototypeMarkWordOffset = getFieldOffset(\"Klass::_prototype_header\", Integer.class, \"markWord\");\n@@ -137,2 +137,2 @@\n-    private final int markWordNoHashInPlace = getConstant(\"markOop::no_hash_in_place\", Integer.class);\n-    private final int markWordNoLockInPlace = getConstant(\"markOop::no_lock_in_place\", Integer.class);\n+    private final int markWordNoHashInPlace = getConstant(\"markWord::no_hash_in_place\", Integer.class);\n+    private final int markWordNoLockInPlace = getConstant(\"markWord::no_lock_in_place\", Integer.class);\n@@ -141,1 +141,1 @@\n-     * See {@code markOop::prototype()}.\n+     * See {@code markWord::prototype()}.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-    public final int markOffset = getFieldOffset(\"oopDesc::_mark\", Integer.class, \"markOop\");\n+    public final int markOffset = getFieldOffset(\"oopDesc::_mark\", Integer.class, \"markWord\");\n@@ -201,1 +201,1 @@\n-    public final int prototypeMarkWordOffset = getFieldOffset(\"Klass::_prototype_header\", Integer.class, \"markOop\");\n+    public final int prototypeMarkWordOffset = getFieldOffset(\"Klass::_prototype_header\", Integer.class, \"markWord\");\n@@ -402,1 +402,1 @@\n-    public final long markOopHashShift = getConstant(\"markOop::hash_shift\", Long.class);\n+    public final long markWordHashShift = getConstant(\"markWord::hash_shift\", Long.class);\n@@ -404,5 +404,5 @@\n-    public final int biasedLockMaskInPlace = getConstant(\"markOop::biased_lock_mask_in_place\", Integer.class);\n-    public final int ageMaskInPlace = getConstant(\"markOop::age_mask_in_place\", Integer.class);\n-    public final int epochMaskInPlace = getConstant(\"markOop::epoch_mask_in_place\", Integer.class);\n-    public final long markOopHashMask = getConstant(\"markOop::hash_mask\", Long.class);\n-    public final long markOopHashMaskInPlace = getConstant(\"markOop::hash_mask_in_place\", Long.class);\n+    public final int biasedLockMaskInPlace = getConstant(\"markWord::biased_lock_mask_in_place\", Integer.class);\n+    public final int ageMaskInPlace = getConstant(\"markWord::age_mask_in_place\", Integer.class);\n+    public final int epochMaskInPlace = getConstant(\"markWord::epoch_mask_in_place\", Integer.class);\n+    public final long markWordHashMask = getConstant(\"markWord::hash_mask\", Long.class);\n+    public final long markWordHashMaskInPlace = getConstant(\"markWord::hash_mask_in_place\", Long.class);\n@@ -410,3 +410,3 @@\n-    public final int unlockedMask = getConstant(\"markOop::unlocked_value\", Integer.class);\n-    public final int monitorMask = getConstant(\"markOop::monitor_value\", Integer.class, -1);\n-    public final int biasedLockPattern = getConstant(\"markOop::biased_lock_pattern\", Integer.class);\n+    public final int unlockedMask = getConstant(\"markWord::unlocked_value\", Integer.class);\n+    public final int monitorMask = getConstant(\"markWord::monitor_value\", Integer.class, -1);\n+    public final int biasedLockPattern = getConstant(\"markWord::biased_lock_pattern\", Integer.class);\n@@ -420,2 +420,2 @@\n-    public final int markWordNoHashInPlace = getConstant(\"markOop::no_hash_in_place\", Integer.class);\n-    public final int markWordNoLockInPlace = getConstant(\"markOop::no_lock_in_place\", Integer.class);\n+    public final int markWordNoHashInPlace = getConstant(\"markWord::no_hash_in_place\", Integer.class);\n+    public final int markWordNoLockInPlace = getConstant(\"markWord::no_lock_in_place\", Integer.class);\n@@ -424,1 +424,1 @@\n-     * See {@code markOop::prototype()}.\n+     * See {@code markWord::prototype()}.\n@@ -431,1 +431,1 @@\n-     * See {@code markOop::copy_set_hash()}.\n+     * See {@code markWord::copy_set_hash()}.\n@@ -434,2 +434,2 @@\n-        long tmp = arrayPrototypeMarkWord() & (~markOopHashMaskInPlace);\n-        tmp |= ((0x2 & markOopHashMask) << markOopHashShift);\n+        long tmp = arrayPrototypeMarkWord() & (~markWordHashMaskInPlace);\n+        tmp |= ((0x2 & markWordHashMask) << markWordHashShift);\n@@ -442,1 +442,1 @@\n-    public final int identityHashCodeShift = getConstant(\"markOop::hash_shift\", Integer.class);\n+    public final int identityHashCodeShift = getConstant(\"markWord::hash_shift\", Integer.class);\n@@ -447,1 +447,1 @@\n-    public final int uninitializedIdentityHashCodeValue = getConstant(\"markOop::no_hash\", Integer.class);\n+    public final int uninitializedIdentityHashCodeValue = getConstant(\"markWord::no_hash\", Integer.class);\n@@ -521,1 +521,1 @@\n-    public final int basicLockDisplacedHeaderOffset = getFieldOffset(\"BasicLock::_displaced_header\", Integer.class, \"markOop\");\n+    public final int basicLockDisplacedHeaderOffset = getFieldOffset(\"BasicLock::_displaced_header\", Integer.class, \"markWord\");\n","filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot\/src\/org\/graalvm\/compiler\/hotspot\/GraalHotSpotVMConfig.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n- * Comment below is reproduced from {@code markOop.hpp} for convenience:\n+ * Comment below is reproduced from {@code markWord.hpp} for convenience:\n","filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot\/src\/org\/graalvm\/compiler\/hotspot\/replacements\/MonitorSnippets.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/BasicLogEvent.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/CallSite.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/Compilation.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/Constants.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogCleanupReader.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogCompilation$MethodBCIPair.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogCompilation.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogEvent.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogParser$1.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogParser$2.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogParser$3.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogParser$Jvms.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogParser$LockElimination.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogParser.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/MakeNotEntrantEvent.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/Method.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/NMethod.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/Phase.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/UncommonTrap.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/UncommonTrapEvent.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/test-classes\/com\/sun\/hotspot\/tools\/compiler\/TestLogCompilation.class","binary":true,"status":"added"},{"patch":"@@ -45,2 +45,2 @@\n-  markOop mark() { return _oop.mark_raw(); }\n-  void set_mark(markOop m) { _oop.set_mark_raw(m); }\n+  markWord mark() { return _oop.mark_raw(); }\n+  void set_mark(markWord m) { _oop.set_mark_raw(m); }\n@@ -48,1 +48,1 @@\n-    markOop m = markOop::encode_pointer_as_mark(obj);\n+    markWord m = markWord::encode_pointer_as_mark(obj);\n@@ -52,2 +52,2 @@\n-  static markOop originalMark() { return markOop(markOop::lock_mask_in_place); }\n-  static markOop changedMark()  { return markOop(0x4711); }\n+  static markWord originalMark() { return markWord(markWord::lock_mask_in_place); }\n+  static markWord changedMark()  { return markWord(0x4711); }\n@@ -56,0 +56,2 @@\n+#define ASSERT_MARK_WORD_EQ(a, b) ASSERT_EQ((a).value(), (b).value())\n+\n@@ -68,4 +70,4 @@\n-  ASSERT_EQ(o1.mark(), FakeOop::originalMark());\n-  ASSERT_EQ(o2.mark(), FakeOop::originalMark());\n-  ASSERT_EQ(o3.mark(), FakeOop::originalMark());\n-  ASSERT_EQ(o4.mark(), FakeOop::originalMark());\n+  ASSERT_MARK_WORD_EQ(o1.mark(), FakeOop::originalMark());\n+  ASSERT_MARK_WORD_EQ(o2.mark(), FakeOop::originalMark());\n+  ASSERT_MARK_WORD_EQ(o3.mark(), FakeOop::originalMark());\n+  ASSERT_MARK_WORD_EQ(o4.mark(), FakeOop::originalMark());\n@@ -76,2 +78,2 @@\n-  ASSERT_EQ(o1.mark(), FakeOop::changedMark());\n-  ASSERT_EQ(o2.mark(), FakeOop::changedMark());\n+  ASSERT_MARK_WORD_EQ(o1.mark(), FakeOop::changedMark());\n+  ASSERT_MARK_WORD_EQ(o2.mark(), FakeOop::changedMark());\n@@ -95,2 +97,2 @@\n-  ASSERT_EQ(o3.mark(), FakeOop::changedMark());\n-  ASSERT_EQ(o4.mark(), FakeOop::changedMark());\n+  ASSERT_MARK_WORD_EQ(o3.mark(), FakeOop::changedMark());\n+  ASSERT_MARK_WORD_EQ(o4.mark(), FakeOop::changedMark());\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_preservedMarks.cpp","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-                    \"longConstant markOop::locked_value\");\n+                    \"longConstant markWord::locked_value\");\n@@ -68,2 +68,2 @@\n-            expStrMap.put(\"longConstant markOop::locked_value\", List.of(\n-                    \"longConstant markOop::locked_value\"));\n+            expStrMap.put(\"longConstant markWord::locked_value\", List.of(\n+                    \"longConstant markWord::locked_value\"));\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbAttach.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-                    \"longConstant markOop::locked_value\",\n-                    \"longConstant markOop::lock_bits\",\n+                    \"longConstant markWord::locked_value\",\n+                    \"longConstant markWord::lock_bits\",\n@@ -61,2 +61,2 @@\n-                    \"longConstant markOop::locked_value\",\n-                    \"longConstant markOop::lock_bits\",\n+                    \"longConstant markWord::locked_value\",\n+                    \"longConstant markWord::lock_bits\",\n@@ -64,5 +64,5 @@\n-                    \"markOop::epoch_mask_in_place\"));\n-            expStrMap.put(\"longConstant markOop::locked_value\", List.of(\n-                    \"longConstant markOop::locked_value\"));\n-            expStrMap.put(\"longConstant markOop::lock_bits\", List.of(\n-                    \"longConstant markOop::lock_bits\"));\n+                    \"markWord::epoch_mask_in_place\"));\n+            expStrMap.put(\"longConstant markWord::locked_value\", List.of(\n+                    \"longConstant markWord::locked_value\"));\n+            expStrMap.put(\"longConstant markWord::lock_bits\", List.of(\n+                    \"longConstant markWord::lock_bits\"));\n@@ -91,1 +91,1 @@\n-        \/\/ Expected values obtained from the hash_mask_in_place definition in markOop.hpp\n+        \/\/ Expected values obtained from the hash_mask_in_place definition in markWord.hpp\n@@ -96,3 +96,3 @@\n-        \/\/ longConstant markOop::biased_lock_bits 1\n-        \/\/ longConstant markOop::age_shift 3\n-        \/\/ longConstant markOop::hash_mask_in_place 549755813632\n+        \/\/ longConstant markWord::biased_lock_bits 1\n+        \/\/ longConstant markWord::age_shift 3\n+        \/\/ longConstant markWord::hash_mask_in_place 549755813632\n@@ -101,1 +101,1 @@\n-        checkLongValue(\"markOop::hash_mask_in_place\",\n+        checkLongValue(\"markWord::hash_mask_in_place\",\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbLongConstant.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"}]}