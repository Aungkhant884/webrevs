{"files":[{"patch":"@@ -234,0 +234,98 @@\n+  linux_x64_clang_build:\n+    name: Linux x64 clang\n+    runs-on: \"ubuntu-22.04\"\n+    needs: prerequisites\n+    if: needs.prerequisites.outputs.should_run != 'false' && (needs.prerequisites.outputs.platform_linux_x64 != 'false' || needs.prerequisites.outputs.platform_linux_additional == 'true')\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        flavor:\n+          - build release\n+          - build debug\n+        include:\n+          - flavor: build debug\n+            flags: --enable-debug\n+            artifact: -debug\n+\n+    env:\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Checkout the source\n+        uses: actions\/checkout@v3\n+        with:\n+          path: jdk\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          wget -O \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" \"${BOOT_JDK_URL}\"\n+          echo \"${BOOT_JDK_SHA256} ${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" | sha256sum -c >\/dev\/null -\n+          tar -xf \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" -C \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          mv \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"*\/* \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Restore jtreg artifact\n+        id: jtreg_restore\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        continue-on-error: true\n+\n+      - name: Restore jtreg artifact (retry)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        if: steps.jtreg_restore.outcome == 'failure'\n+\n+      - name: Fix jtreg permissions\n+        run: chmod -R a+rx ${HOME}\/jtreg\/\n+\n+      - name: Install dependencies\n+        run: |\n+          sudo apt-get update\n+          sudo apt-get install clang-14=1:14.0.0-1ubuntu1 libxrandr-dev libxtst-dev libcups2-dev libasound2-dev\n+\n+      - name: Configure\n+        run: >\n+          bash configure\n+          --with-conf-name=linux-x64-clang\n+          ${{ matrix.flags }}\n+          --with-version-opt=${GITHUB_ACTOR}-${GITHUB_SHA}\n+          --with-version-build=0\n+          --with-boot-jdk=${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\n+          --with-jtreg=${HOME}\/jtreg\n+          --with-default-make-target=\"product-bundles test-bundles\"\n+          --with-zlib=system\n+          --with-toolchain-type=clang\n+          --disable-warnings-as-errors\n+          --with-jvm-features=shenandoahgc\n+          --enable-jtreg-failure-handler\n+        working-directory: jdk\n+\n+      - name: Build\n+        run: make CONF_NAME=linux-x64-clang\n+        working-directory: jdk\n+\n+      - name: Persist test bundles\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          name: transient_jdk-linux-x64-clang${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: |\n+            jdk\/build\/linux-x64-clang\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64-clang_bin${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/linux-x64-clang\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64-clang_bin-tests${{ matrix.artifact }}.tar.gz\n+\n@@ -503,0 +601,269 @@\n+  linux_x64_clang_test:\n+    name: Linux x64\n+    runs-on: \"ubuntu-22.04\"\n+    needs:\n+      - prerequisites\n+      - linux_x64_clang_build\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        test:\n+          - jdk\/tier1 part 1\n+          - jdk\/tier1 part 2\n+          - jdk\/tier1 part 3\n+          - langtools\/tier1\n+          - hs\/tier1 common\n+          - hs\/tier1 compiler\n+          - hs\/tier1 gc\n+          - hs\/tier1 runtime\n+          - hs\/tier1 serviceability\n+        include:\n+          - test: jdk\/tier1 part 1\n+            suites: test\/jdk\/:tier1_part1\n+          - test: jdk\/tier1 part 2\n+            suites: test\/jdk\/:tier1_part2\n+          - test: jdk\/tier1 part 3\n+            suites: test\/jdk\/:tier1_part3\n+          - test: langtools\/tier1\n+            suites: test\/langtools\/:tier1\n+          - test: hs\/tier1 common\n+            suites: test\/hotspot\/jtreg\/:tier1_common\n+            artifact: -debug\n+          - test: hs\/tier1 compiler\n+            suites: test\/hotspot\/jtreg\/:tier1_compiler\n+            artifact: -debug\n+          - test: hs\/tier1 gc\n+            suites: test\/hotspot\/jtreg\/:tier1_gc\n+            artifact: -debug\n+          - test: hs\/tier1 runtime\n+            suites: test\/hotspot\/jtreg\/:tier1_runtime\n+            artifact: -debug\n+          - test: hs\/tier1 serviceability\n+            suites: test\/hotspot\/jtreg\/:tier1_serviceability\n+            artifact: -debug\n+\n+    env:\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Checkout the source\n+        uses: actions\/checkout@v3\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          wget -O \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" \"${BOOT_JDK_URL}\"\n+          echo \"${BOOT_JDK_SHA256} ${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" | sha256sum -c >\/dev\/null -\n+          tar -xf \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" -C \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          mv \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"*\/* \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Restore jtreg artifact\n+        id: jtreg_restore\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        continue-on-error: true\n+\n+      - name: Restore jtreg artifact (retry)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        if: steps.jtreg_restore.outcome == 'failure'\n+\n+      - name: Restore build artifacts\n+        id: build_restore\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jdk-linux-x64-clang${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jdk-linux-x64-clang${{ matrix.artifact }}\n+        continue-on-error: true\n+\n+      - name: Restore build artifacts (retry)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jdk-linux-x64-clang${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jdk-linux-x64-clang${{ matrix.artifact }}\n+        if: steps.build_restore.outcome == 'failure'\n+\n+      - name: Unpack jdk\n+        run: |\n+          mkdir -p \"${HOME}\/jdk-linux-x64-clang${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64-clang_bin${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-linux-x64-clang${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64-clang_bin${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x64-clang${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64-clang_bin${{ matrix.artifact }}\"\n+\n+      - name: Unpack tests\n+        run: |\n+          mkdir -p \"${HOME}\/jdk-linux-x64-clang${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64-clang_bin-tests${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-linux-x64-clang${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64-clang_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x64-clang${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64-clang_bin-tests${{ matrix.artifact }}\"\n+\n+      - name: Find root of jdk image dir\n+        run: |\n+          imageroot=`find ${HOME}\/jdk-linux-x64-clang${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64-clang_bin${{ matrix.artifact }} -name release -type f`\n+          echo \"imageroot=`dirname ${imageroot}`\" >> $GITHUB_ENV\n+\n+      - name: Run tests\n+        id: run_tests\n+        run: >\n+          JDK_IMAGE_DIR=${{ env.imageroot }}\n+          TEST_IMAGE_DIR=${HOME}\/jdk-linux-x64-clang${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64-clang_bin-tests${{ matrix.artifact }}\n+          BOOT_JDK=${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\n+          JT_HOME=${HOME}\/jtreg\n+          make run-test-prebuilt\n+          CONF_NAME=run-test-prebuilt\n+          LOG_CMDLINES=true\n+          JTREG_VERBOSE=fail,error,time\n+          TEST=\"${{ matrix.suites }}\"\n+          TEST_OPTS_JAVA_OPTIONS=\n+          JTREG_KEYWORDS=\"!headful\"\n+          JTREG=\"JAVA_OPTIONS=-XX:-CreateCoredumpOnCrash\"\n+\n+      - name: Generate test failure summary\n+        run: |\n+          #\n+          test_suite_name=$(cat build\/run-test-prebuilt\/test-support\/test-last-ids.txt)\n+          results_dir=build\/run-test-prebuilt\/test-results\/$test_suite_name\/text\n+\n+          failures=$(sed -e 's!\\(.*\\)\\.java!\\1!' -e '\/^#\/d' $results_dir\/newfailures.txt || true)\n+          errors=$(sed -e 's!\\(.*\\)\\.java!\\1!' -e '\/^#\/d' $results_dir\/other_errors.txt || true)\n+          failure_count=$(echo $failures | wc -w || true)\n+          error_count=$(echo $errors | wc -w || true)\n+\n+          if [[ \"$failures\" = \"\" && \"$errors\" = \"\" ]]; then\n+            # If we have nothing to report, exit this step now\n+            exit 0\n+          fi\n+\n+          echo \"::error:: Test run reported $failure_count test failure(s) and $error_count error(s). See summary for details.\"\n+\n+          echo \"### :boom: Test failures summary\" >> $GITHUB_STEP_SUMMARY\n+\n+          if [[ \"$failures\" != \"\" ]]; then\n+            echo \"\" >> $GITHUB_STEP_SUMMARY\n+            echo \"These tests reported failure:\" >> $GITHUB_STEP_SUMMARY\n+            for test in $failures; do\n+              anchor=\"$(echo \"$test\" | tr [A-Z\/] [a-z_])\"\n+              echo \"* [$test](#user-content-$anchor)\"\n+            done >> $GITHUB_STEP_SUMMARY\n+          fi\n+\n+          if [[ \"$errors\" != \"\" ]]; then\n+            echo \"\" >> $GITHUB_STEP_SUMMARY\n+            echo \"These tests reported errors:\"  >> $GITHUB_STEP_SUMMARY\n+            for test in $errors; do\n+              anchor=\"$(echo \"$test\" | tr [A-Z\/] [a-z_])\"\n+              echo \"* [$test](#user-content-$anchor)\"\n+            done >> $GITHUB_STEP_SUMMARY\n+          fi\n+\n+      - name: Collect failed test output\n+        run: |\n+          #\n+          # This is a separate step, since if the markdown from a step gets bigger than\n+          # 1024 kB it is skipped, but then the summary above is still generated\n+          test_suite_name=$(cat build\/run-test-prebuilt\/test-support\/test-last-ids.txt)\n+          results_dir=build\/run-test-prebuilt\/test-results\/$test_suite_name\/text\n+          report_dir=build\/run-test-prebuilt\/test-support\/$test_suite_name\n+\n+          failures=$(sed -e 's!\\(.*\\)\\.java!\\1!' -e '\/^#\/d' $results_dir\/newfailures.txt || true)\n+          errors=$(sed -e 's!\\(.*\\)\\.java!\\1!' -e '\/^#\/d' $results_dir\/other_errors.txt || true)\n+\n+          if [[ \"$failures\" = \"\" && \"$errors\" = \"\" ]]; then\n+            # If we have nothing to report, exit this step now\n+            exit 0\n+          fi\n+\n+          echo \"### Test output for failed tests\" >> $GITHUB_STEP_SUMMARY\n+          for test in $failures $errors; do\n+            anchor=\"$(echo \"$test\" | tr [A-Z\/] [a-z_])\"\n+            base_path=\"$(echo \"$test\" | tr '#' '_')\"\n+            report_file=\"$report_dir\/$base_path.jtr\"\n+            hs_err_files=\"$report_dir\/$base_path\/hs_err*.log\"\n+            echo \"####  <a id=\"$anchor\">$test\"\n+\n+            echo \"<details><summary>View test results<\/summary>\"\n+            echo \"\"\n+            echo '```'\n+            if [[ -f \"$report_file\" ]]; then\n+              cat \"$report_file\"\n+            else\n+              echo \"Error: Result file $report_file not found\"\n+            fi\n+            echo '```'\n+            echo \"<\/details>\"\n+            echo \"\"\n+\n+            if [[ \"$hs_err_files\" != \"\" ]]; then\n+              echo \"<details><summary>View HotSpot error log<\/summary>\"\n+              echo \"\"\n+              for hs_err in $hs_err_files; do\n+                echo '```'\n+                echo \"$hs_err:\"\n+                echo \"\"\n+                cat \"$hs_err\"\n+                echo '```'\n+              done\n+\n+              echo \"<\/details>\"\n+              echo \"\"\n+            fi\n+\n+          done >> $GITHUB_STEP_SUMMARY\n+\n+          echo \":arrow_right: To see the entire test log, click the job in the list to the left\"  >> $GITHUB_STEP_SUMMARY\n+\n+          # This will abort the entire job in GHA, which is what we want\n+          exit 1\n+\n+      - name: Create suitable test log artifact name\n+        if: always()\n+        run: echo \"logsuffix=`echo ${{ matrix.test }} | sed -e 's!\/!_!'g -e 's! !_!'g`\" >> $GITHUB_ENV\n+\n+      - name: Package test results\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-results\/\n+        run: >\n+          zip -r9\n+          \"$HOME\/linux-x64-clang${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\"\n+          .\n+        continue-on-error: true\n+\n+      - name: Package test support\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-support\/\n+        run: >\n+          zip -r9\n+          \"$HOME\/linux-x64-clang${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\"\n+          .\n+          -i *.jtr\n+          -i *\/hs_err*.log\n+          -i *\/replay*.log\n+        continue-on-error: true\n+\n+      - name: Persist test results\n+        if: always()\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          path: ~\/linux-x64-clang${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\n+        continue-on-error: true\n+\n+      - name: Persist test outputs\n+        if: always()\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          path: ~\/linux-x64-clang${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\n+        continue-on-error: true\n+\n@@ -1884,0 +2251,1 @@\n+      - linux_x64_clang_test\n","filename":".github\/workflows\/submit.yml","additions":368,"deletions":0,"binary":false,"changes":368,"status":"modified"},{"patch":"@@ -3481,1 +3481,1 @@\n-    \/\/ Load markOop from object into displaced_header.\n+    \/\/ Load markWord from object into displaced_header.\n@@ -3496,1 +3496,1 @@\n-      __ tbnz(disp_hdr, exact_log2(markOopDesc::monitor_value), object_has_monitor);\n+      __ tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n@@ -3499,2 +3499,2 @@\n-    \/\/ Set tmp to be (markOop of object | UNLOCK_VALUE).\n-    __ orr(tmp, disp_hdr, markOopDesc::unlocked_value);\n+    \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n+    __ orr(tmp, disp_hdr, markWord::unlocked_value);\n@@ -3505,3 +3505,3 @@\n-    \/\/ Compare object markOop with an unlocked value (tmp) and if\n-    \/\/ equal exchange the stack address of our box with object markOop.\n-    \/\/ On failure disp_hdr contains the possibly locked markOop.\n+    \/\/ Compare object markWord with an unlocked value (tmp) and if\n+    \/\/ equal exchange the stack address of our box with object markWord.\n+    \/\/ On failure disp_hdr contains the possibly locked markWord.\n@@ -3521,1 +3521,1 @@\n-    \/\/ markOop of object (disp_hdr) with the stack pointer.\n+    \/\/ markWord of object (disp_hdr) with the stack pointer.\n@@ -3524,1 +3524,1 @@\n-    __ mov(tmp, (address) (~(os::vm_page_size()-1) | (uintptr_t)markOopDesc::lock_mask_in_place));\n+    __ mov(tmp, (address) (~(os::vm_page_size()-1) | (uintptr_t)markWord::lock_mask_in_place));\n@@ -3539,1 +3539,1 @@\n-      __ add(tmp, disp_hdr, (ObjectMonitor::owner_offset_in_bytes()-markOopDesc::monitor_value));\n+      __ add(tmp, disp_hdr, (ObjectMonitor::owner_offset_in_bytes()-markWord::monitor_value));\n@@ -3545,1 +3545,1 @@\n-      \/\/ markOopDesc::monitor_value so use markOopDesc::unused_mark which has the\n+      \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n@@ -3547,1 +3547,1 @@\n-      __ mov(tmp, (address)markOopDesc::unused_mark());\n+      __ mov(tmp, (address)markWord::unused_mark().value());\n@@ -3587,1 +3587,1 @@\n-      __ tbnz(disp_hdr, exact_log2(markOopDesc::monitor_value), object_has_monitor);\n+      __ tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n@@ -3591,1 +3591,1 @@\n-    \/\/ see the stack address of the basicLock in the markOop of the\n+    \/\/ see the stack address of the basicLock in the markWord of the\n@@ -3603,1 +3603,1 @@\n-      __ add(tmp, tmp, -markOopDesc::monitor_value); \/\/ monitor\n+      __ add(tmp, tmp, -markWord::monitor_value); \/\/ monitor\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -85,1 +85,1 @@\n-  orr(hdr, hdr, markOopDesc::unlocked_value);\n+  orr(hdr, hdr, markWord::unlocked_value);\n@@ -179,1 +179,1 @@\n-    mov(t1, (int32_t)(intptr_t)markOopDesc::prototype());\n+    mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-  __ ands(zr, tmp, markOopDesc::lock_mask_in_place);\n+  __ ands(zr, tmp, markWord::lock_mask_in_place);\n@@ -220,1 +220,1 @@\n-  __ orr(tmp, tmp, markOopDesc::marked_value);\n+  __ orr(tmp, tmp, markWord::marked_value);\n@@ -619,1 +619,1 @@\n-  __ ands(zr, tmp1, markOopDesc::lock_mask_in_place);\n+  __ ands(zr, tmp1, markWord::lock_mask_in_place);\n@@ -623,1 +623,1 @@\n-  __ orr(tmp1, tmp1, markOopDesc::marked_value);\n+  __ orr(tmp1, tmp1, markWord::marked_value);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-  assert(markOopDesc::age_shift == markOopDesc::lock_bits + markOopDesc::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n+  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n@@ -495,2 +495,2 @@\n-  andr(tmp_reg, swap_reg, markOopDesc::biased_lock_mask_in_place);\n-  cmp(tmp_reg, markOopDesc::biased_lock_pattern);\n+  andr(tmp_reg, swap_reg, markWord::biased_lock_mask_in_place);\n+  cmp(tmp_reg, markWord::biased_lock_pattern);\n@@ -503,1 +503,1 @@\n-  andr(tmp_reg, tmp_reg, ~((int) markOopDesc::age_mask_in_place));\n+  andr(tmp_reg, tmp_reg, ~((int) markWord::age_mask_in_place));\n@@ -526,1 +526,1 @@\n-  andr(rscratch1, tmp_reg, markOopDesc::biased_lock_mask_in_place);\n+  andr(rscratch1, tmp_reg, markWord::biased_lock_mask_in_place);\n@@ -538,1 +538,1 @@\n-  andr(rscratch1, tmp_reg, markOopDesc::epoch_mask_in_place);\n+  andr(rscratch1, tmp_reg, markWord::epoch_mask_in_place);\n@@ -549,1 +549,1 @@\n-    mov(rscratch1, markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place | markOopDesc::epoch_mask_in_place);\n+    mov(rscratch1, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n@@ -634,2 +634,2 @@\n-  andr(temp_reg, temp_reg, markOopDesc::biased_lock_mask_in_place);\n-  cmp(temp_reg, markOopDesc::biased_lock_pattern);\n+  andr(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);\n+  cmp(temp_reg, markWord::biased_lock_pattern);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3614,1 +3614,1 @@\n-      __ mov(rscratch1, (intptr_t)markOopDesc::prototype());\n+      __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -104,1 +104,1 @@\n-    mov(tmp, (intptr_t)markOopDesc::prototype());\n+    mov(tmp, (intptr_t)markWord::prototype());\n@@ -285,2 +285,2 @@\n-  assert(markOopDesc::unlocked_value == 1, \"adjust this code\");\n-  tbnz(hdr, exact_log2(markOopDesc::unlocked_value), fast_lock);\n+  assert(markWord::unlocked_value == 1, \"adjust this code\");\n+  tbnz(hdr, exact_log2(markWord::unlocked_value), fast_lock);\n@@ -315,1 +315,1 @@\n-  tst(hdr, markOopDesc::unlocked_value);\n+  tst(hdr, markWord::unlocked_value);\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -998,2 +998,2 @@\n-    assert(markOopDesc::unlocked_value == 1, \"adjust this code\");\n-    tbz(Rmark, exact_log2(markOopDesc::unlocked_value), already_locked);\n+    assert(markWord::unlocked_value == 1, \"adjust this code\");\n+    tbz(Rmark, exact_log2(markWord::unlocked_value), already_locked);\n@@ -1012,1 +1012,1 @@\n-    tst(Rmark, markOopDesc::unlocked_value);\n+    tst(Rmark, markWord::unlocked_value);\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1936,1 +1936,1 @@\n-  assert(markOopDesc::age_shift == markOopDesc::lock_bits + markOopDesc::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n+  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n@@ -1958,2 +1958,2 @@\n-  andr(tmp_reg, swap_reg, (uintx)markOopDesc::biased_lock_mask_in_place);\n-  cmp(tmp_reg, markOopDesc::biased_lock_pattern);\n+  andr(tmp_reg, swap_reg, (uintx)markWord::biased_lock_mask_in_place);\n+  cmp(tmp_reg, markWord::biased_lock_pattern);\n@@ -1971,1 +1971,1 @@\n-  ands(tmp_reg, tmp_reg, ~((uintx) markOopDesc::age_mask_in_place));\n+  ands(tmp_reg, tmp_reg, ~((uintx) markWord::age_mask_in_place));\n@@ -1973,1 +1973,1 @@\n-  bics(tmp_reg, tmp_reg, ((int) markOopDesc::age_mask_in_place));\n+  bics(tmp_reg, tmp_reg, ((int) markWord::age_mask_in_place));\n@@ -1996,1 +1996,1 @@\n-  tst(tmp_reg, (uintx)markOopDesc::biased_lock_mask_in_place);\n+  tst(tmp_reg, (uintx)markWord::biased_lock_mask_in_place);\n@@ -2008,1 +2008,1 @@\n-  tst(tmp_reg, (uintx)markOopDesc::epoch_mask_in_place);\n+  tst(tmp_reg, (uintx)markWord::epoch_mask_in_place);\n@@ -2027,1 +2027,1 @@\n-  mov(tmp2, (markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place | markOopDesc::epoch_mask_in_place));\n+  mov(tmp2, (markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place));\n@@ -2032,1 +2032,1 @@\n-  assert((markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place | markOopDesc::epoch_mask_in_place) == 0x1ff, \"biased bitmasks changed\");\n+  assert((markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place) == 0x1ff, \"biased bitmasks changed\");\n@@ -2035,1 +2035,1 @@\n-  mov(swap_reg, AsmOperand(swap_reg, lsr, 23)); \/\/ markOop with thread bits cleared (for CAS)\n+  mov(swap_reg, AsmOperand(swap_reg, lsr, 23)); \/\/ markWord with thread bits cleared (for CAS)\n@@ -2065,1 +2065,1 @@\n-  mov(tmp2, (markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place | markOopDesc::epoch_mask_in_place));\n+  mov(tmp2, (markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place));\n@@ -2100,1 +2100,1 @@\n-  mov(tmp2, (markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place | markOopDesc::epoch_mask_in_place));\n+  mov(tmp2, (markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place));\n@@ -2131,2 +2131,2 @@\n-  andr(tmp_reg, tmp_reg, (uintx)markOopDesc::biased_lock_mask_in_place);\n-  cmp(tmp_reg, markOopDesc::biased_lock_pattern);\n+  andr(tmp_reg, tmp_reg, (uintx)markWord::biased_lock_mask_in_place);\n+  cmp(tmp_reg, markWord::biased_lock_pattern);\n@@ -3021,1 +3021,1 @@\n-  tst(Rmark, markOopDesc::unlocked_value);\n+  tst(Rmark, markWord::unlocked_value);\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1231,2 +1231,2 @@\n-    assert(markOopDesc::unlocked_value == 1, \"adjust this code\");\n-    __ tbz(Rtemp, exact_log2(markOopDesc::unlocked_value), slow_case);\n+    assert(markWord::unlocked_value == 1, \"adjust this code\");\n+    __ tbz(Rtemp, exact_log2(markWord::unlocked_value), slow_case);\n@@ -1235,2 +1235,2 @@\n-      assert(is_power_of_2(markOopDesc::biased_lock_bit_in_place), \"adjust this code\");\n-      __ tbnz(Rtemp, exact_log2(markOopDesc::biased_lock_bit_in_place), slow_case);\n+      assert(is_power_of_2(markWord::biased_lock_bit_in_place), \"adjust this code\");\n+      __ tbnz(Rtemp, exact_log2(markWord::biased_lock_bit_in_place), slow_case);\n@@ -1240,1 +1240,1 @@\n-    __ ands(Rtemp, Rtemp, (uintx)markOopDesc::hash_mask_in_place);\n+    __ ands(Rtemp, Rtemp, (uintx)markWord::hash_mask_in_place);\n@@ -1242,1 +1242,1 @@\n-    __ logical_shift_right(R0, Rtemp, markOopDesc::hash_shift);\n+    __ logical_shift_right(R0, Rtemp, markWord::hash_shift);\n@@ -1245,2 +1245,2 @@\n-    __ bics(Rtemp, Rtemp, ~markOopDesc::hash_mask_in_place);\n-    __ mov(R0, AsmOperand(Rtemp, lsr, markOopDesc::hash_shift), ne);\n+    __ bics(Rtemp, Rtemp, ~markWord::hash_mask_in_place);\n+    __ mov(R0, AsmOperand(Rtemp, lsr, markWord::hash_shift), ne);\n@@ -1586,2 +1586,2 @@\n-    assert(markOopDesc::unlocked_value == 1, \"adjust this code\");\n-    __ tbnz(mark, exact_log2(markOopDesc::unlocked_value), fast_lock);\n+    assert(markWord::unlocked_value == 1, \"adjust this code\");\n+    __ tbnz(mark, exact_log2(markWord::unlocked_value), fast_lock);\n@@ -1613,1 +1613,1 @@\n-    __ tst(mark, markOopDesc::unlocked_value);\n+    __ tst(mark, markWord::unlocked_value);\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -4610,1 +4610,1 @@\n-      __ mov_slow(Rtemp, (intptr_t)markOopDesc::prototype());\n+      __ mov_slow(Rtemp, (intptr_t)markWord::prototype());\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -113,1 +113,1 @@\n-  ori(Rmark, Rmark, markOopDesc::unlocked_value);\n+  ori(Rmark, Rmark, markWord::unlocked_value);\n@@ -118,1 +118,1 @@\n-  \/\/ Compare object markOop with Rmark and if equal exchange Rscratch with object markOop.\n+  \/\/ Compare object markWord with Rmark and if equal exchange Rscratch with object markWord.\n@@ -140,1 +140,1 @@\n-  load_const_optimized(R0, (~(os::vm_page_size()-1) | markOopDesc::lock_mask_in_place));\n+  load_const_optimized(R0, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n@@ -174,1 +174,1 @@\n-  \/\/ the stack address of the basicLock in the markOop of the object.\n+  \/\/ the stack address of the basicLock in the markWord of the object.\n@@ -218,1 +218,1 @@\n-    load_const_optimized(t1, (intx)markOopDesc::prototype());\n+    load_const_optimized(t1, (intx)markWord::prototype());\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -872,1 +872,1 @@\n-    \/\/ markOop displaced_header = obj->mark().set_unlocked();\n+    \/\/ markWord displaced_header = obj->mark().set_unlocked();\n@@ -894,1 +894,1 @@\n-    \/\/ markOop displaced_header = obj->mark().set_unlocked();\n+    \/\/ markWord displaced_header = obj->mark().set_unlocked();\n@@ -896,1 +896,1 @@\n-    \/\/ Load markOop from object into displaced_header.\n+    \/\/ Load markWord from object into displaced_header.\n@@ -903,2 +903,2 @@\n-    \/\/ Set displaced_header to be (markOop of object | UNLOCK_VALUE).\n-    ori(displaced_header, displaced_header, markOopDesc::unlocked_value);\n+    \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n+    ori(displaced_header, displaced_header, markWord::unlocked_value);\n@@ -940,1 +940,1 @@\n-    \/\/ Check if owner is self by comparing the value in the markOop of object\n+    \/\/ Check if owner is self by comparing the value in the markWord of object\n@@ -945,1 +945,1 @@\n-    load_const_optimized(tmp, ~(os::vm_page_size()-1) | markOopDesc::lock_mask_in_place);\n+    load_const_optimized(tmp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2092,1 +2092,1 @@\n-  assert(markOopDesc::age_shift == markOopDesc::lock_bits + markOopDesc::biased_lock_bits,\n+  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits,\n@@ -2102,2 +2102,2 @@\n-  andi(temp_reg, mark_reg, markOopDesc::biased_lock_mask_in_place);\n-  cmpwi(cr_reg, temp_reg, markOopDesc::biased_lock_pattern);\n+  andi(temp_reg, mark_reg, markWord::biased_lock_mask_in_place);\n+  cmpwi(cr_reg, temp_reg, markWord::biased_lock_pattern);\n@@ -2108,1 +2108,1 @@\n-  load_const_optimized(temp2_reg, ~((int) markOopDesc::age_mask_in_place));\n+  load_const_optimized(temp2_reg, ~((int) markWord::age_mask_in_place));\n@@ -2139,1 +2139,1 @@\n-  andi(temp2_reg, temp_reg, markOopDesc::biased_lock_mask_in_place);\n+  andi(temp2_reg, temp_reg, markWord::biased_lock_mask_in_place);\n@@ -2153,1 +2153,1 @@\n-  int shift_amount = 64 - markOopDesc::epoch_shift;\n+  int shift_amount = 64 - markWord::epoch_shift;\n@@ -2156,1 +2156,1 @@\n-  rldicl_(temp2_reg, temp_reg, shift_amount, 64 - markOopDesc::epoch_bits);\n+  rldicl_(temp2_reg, temp_reg, shift_amount, 64 - markWord::epoch_bits);\n@@ -2166,3 +2166,3 @@\n-  andi(mark_reg, mark_reg, (markOopDesc::biased_lock_mask_in_place |\n-                                markOopDesc::age_mask_in_place |\n-                                markOopDesc::epoch_mask_in_place));\n+  andi(mark_reg, mark_reg, (markWord::biased_lock_mask_in_place |\n+                                markWord::age_mask_in_place |\n+                                markWord::epoch_mask_in_place));\n@@ -2201,1 +2201,1 @@\n-  andi(temp2_reg, mark_reg, markOopDesc::age_mask_in_place);\n+  andi(temp2_reg, mark_reg, markWord::age_mask_in_place);\n@@ -2238,1 +2238,1 @@\n-  andi(temp2_reg, mark_reg, markOopDesc::age_mask_in_place);\n+  andi(temp2_reg, mark_reg, markWord::age_mask_in_place);\n@@ -2250,1 +2250,1 @@\n-  \/\/ reload markOop in mark_reg before continuing with lightweight locking\n+  \/\/ reload markWord in mark_reg before continuing with lightweight locking\n@@ -2278,1 +2278,1 @@\n-  andi(temp_reg, temp_reg, markOopDesc::biased_lock_mask_in_place);\n+  andi(temp_reg, temp_reg, markWord::biased_lock_mask_in_place);\n@@ -2280,1 +2280,1 @@\n-  cmpwi(cr_reg, temp_reg, markOopDesc::biased_lock_pattern);\n+  cmpwi(cr_reg, temp_reg, markWord::biased_lock_pattern);\n@@ -2701,1 +2701,1 @@\n-  andi_(R0, mark_word, markOopDesc::monitor_value);  \/\/ inflated vs stack-locked|neutral|biased\n+  andi_(R0, mark_word, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral|biased\n@@ -2720,2 +2720,2 @@\n-  andi(R0, mark_word, markOopDesc::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-  cmpwi(flag, R0, markOopDesc::unlocked_value);                \/\/ bits = 001 unlocked\n+  andi(R0, mark_word, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n+  cmpwi(flag, R0, markWord::unlocked_value);                \/\/ bits = 001 unlocked\n@@ -2758,1 +2758,1 @@\n-  int owner_offset = ObjectMonitor::owner_offset_in_bytes() - markOopDesc::monitor_value;\n+  int owner_offset = ObjectMonitor::owner_offset_in_bytes() - markWord::monitor_value;\n@@ -2760,1 +2760,1 @@\n-  \/\/ Store non-null, using boxReg instead of (intptr_t)markOopDesc::unused_mark().\n+  \/\/ Store non-null, using boxReg instead of (intptr_t)markWord::unused_mark().\n@@ -2805,1 +2805,1 @@\n-    andi_(R0, mark_word, markOopDesc::monitor_value);\n+    andi_(R0, mark_word, markWord::monitor_value);\n@@ -2847,1 +2847,1 @@\n-  \/\/ Load markOop from object into displaced_header.\n+  \/\/ Load markWord from object into displaced_header.\n@@ -2872,1 +2872,1 @@\n-    andi_(temp, displaced_header, markOopDesc::monitor_value);\n+    andi_(temp, displaced_header, markWord::monitor_value);\n@@ -2876,2 +2876,2 @@\n-  \/\/ Set displaced_header to be (markOop of object | UNLOCK_VALUE).\n-  ori(displaced_header, displaced_header, markOopDesc::unlocked_value);\n+  \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n+  ori(displaced_header, displaced_header, markWord::unlocked_value);\n@@ -2885,1 +2885,1 @@\n-  \/\/ Compare object markOop with mark and if equal exchange scratch1 with object markOop.\n+  \/\/ Compare object markWord with mark and if equal exchange scratch1 with object markWord.\n@@ -2905,1 +2905,1 @@\n-  \/\/ Check if the owner is self by comparing the value in the markOop of object\n+  \/\/ Check if the owner is self by comparing the value in the markWord of object\n@@ -2908,1 +2908,1 @@\n-  load_const_optimized(temp, ~(os::vm_page_size()-1) | markOopDesc::lock_mask_in_place);\n+  load_const_optimized(temp, ~(os::vm_page_size()-1) | markWord::lock_mask_in_place);\n@@ -2933,1 +2933,1 @@\n-    addi(temp, displaced_header, ObjectMonitor::owner_offset_in_bytes()-markOopDesc::monitor_value);\n+    addi(temp, displaced_header, ObjectMonitor::owner_offset_in_bytes()-markWord::monitor_value);\n@@ -2988,2 +2988,2 @@\n-    andi(R0, current_header, markOopDesc::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-    cmpwi(flag, R0, markOopDesc::unlocked_value);                     \/\/ bits = 001 unlocked\n+    andi(R0, current_header, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n+    cmpwi(flag, R0, markWord::unlocked_value);                     \/\/ bits = 001 unlocked\n@@ -3009,1 +3009,1 @@\n-    andi_(R0, current_header, markOopDesc::monitor_value);\n+    andi_(R0, current_header, markWord::monitor_value);\n@@ -3014,1 +3014,1 @@\n-  \/\/ the stack address of the basicLock in the markOop of the object.\n+  \/\/ the stack address of the basicLock in the markWord of the object.\n@@ -3033,1 +3033,1 @@\n-    addi(current_header, current_header, -markOopDesc::monitor_value); \/\/ monitor\n+    addi(current_header, current_header, -markWord::monitor_value); \/\/ monitor\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -3809,1 +3809,1 @@\n-      __ load_const_optimized(Rscratch, markOopDesc::prototype(), R0);\n+      __ load_const_optimized(Rscratch, markWord::prototype(), R0);\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -99,1 +99,1 @@\n-  z_oill(hdr, markOopDesc::unlocked_value);\n+  z_oill(hdr, markWord::unlocked_value);\n@@ -118,1 +118,1 @@\n-  \/\/ 1) (hdr & markOopDesc::lock_mask_in_place) == 0\n+  \/\/ 1) (hdr & markWord::lock_mask_in_place) == 0\n@@ -124,1 +124,1 @@\n-  \/\/ (hdr - Z_SP) & (~(page_size-1) | markOopDesc::lock_mask_in_place)\n+  \/\/ (hdr - Z_SP) & (~(page_size-1) | markWord::lock_mask_in_place)\n@@ -130,1 +130,1 @@\n-  load_const_optimized(Z_R0_scratch, (~(os::vm_page_size()-1) | markOopDesc::lock_mask_in_place));\n+  load_const_optimized(Z_R0_scratch, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n@@ -195,1 +195,1 @@\n-    load_const_optimized(t1, (intx)markOopDesc::prototype());\n+    load_const_optimized(t1, (intx)markWord::prototype());\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  \/\/ hdr     : Used to hold locked markOop to be CASed into obj, contents destroyed.\n+  \/\/ hdr     : Used to hold locked markWord to be CASed into obj, contents destroyed.\n@@ -51,1 +51,1 @@\n-  \/\/ hdr     : Used to hold original markOop to be CASed back into obj, contents destroyed.\n+  \/\/ hdr     : Used to hold original markWord to be CASed back into obj, contents destroyed.\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -963,1 +963,1 @@\n-  \/\/ markOop displaced_header = obj->mark().set_unlocked();\n+  \/\/ markWord displaced_header = obj->mark().set_unlocked();\n@@ -982,1 +982,1 @@\n-  \/\/ markOop displaced_header = obj->mark().set_unlocked();\n+  \/\/ markWord displaced_header = obj->mark().set_unlocked();\n@@ -984,1 +984,1 @@\n-  \/\/ Load markOop from object into displaced_header.\n+  \/\/ Load markWord from object into displaced_header.\n@@ -991,2 +991,2 @@\n-  \/\/ Set displaced_header to be (markOop of object | UNLOCK_VALUE).\n-  z_oill(displaced_header, markOopDesc::unlocked_value);\n+  \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n+  z_oill(displaced_header, markWord::unlocked_value);\n@@ -1016,1 +1016,1 @@\n-  \/\/ Check if owner is self by comparing the value in the markOop of object\n+  \/\/ Check if owner is self by comparing the value in the markWord of object\n@@ -1024,1 +1024,1 @@\n-  load_const_optimized(Z_R0, (~(os::vm_page_size()-1) | markOopDesc::lock_mask_in_place));\n+  load_const_optimized(Z_R0, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3203,1 +3203,1 @@\n-  assert(markOopDesc::age_shift == markOopDesc::lock_bits + markOopDesc::biased_lock_bits,\n+  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits,\n@@ -3206,2 +3206,2 @@\n-  z_nilf(temp_reg, markOopDesc::biased_lock_mask_in_place);\n-  z_chi(temp_reg, markOopDesc::biased_lock_pattern);\n+  z_nilf(temp_reg, markWord::biased_lock_mask_in_place);\n+  z_chi(temp_reg, markWord::biased_lock_pattern);\n@@ -3211,1 +3211,1 @@\n-  load_const_optimized(temp2_reg, ~((int) markOopDesc::age_mask_in_place));\n+  load_const_optimized(temp2_reg, ~((int) markWord::age_mask_in_place));\n@@ -3237,1 +3237,1 @@\n-  z_tmll(temp_reg, markOopDesc::biased_lock_mask_in_place);\n+  z_tmll(temp_reg, markWord::biased_lock_mask_in_place);\n@@ -3249,1 +3249,1 @@\n-  z_tmll(temp_reg, markOopDesc::epoch_mask_in_place);\n+  z_tmll(temp_reg, markWord::epoch_mask_in_place);\n@@ -3259,2 +3259,2 @@\n-  z_nilf(mark_reg, markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place |\n-         markOopDesc::epoch_mask_in_place);\n+  z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place |\n+         markWord::epoch_mask_in_place);\n@@ -3292,1 +3292,1 @@\n-  z_nilf(mark_reg, markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place | markOopDesc::epoch_mask_in_place);\n+  z_nilf(mark_reg, markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n@@ -3353,1 +3353,1 @@\n-  z_nilf(temp_reg, markOopDesc::biased_lock_mask_in_place);\n+  z_nilf(temp_reg, markWord::biased_lock_mask_in_place);\n@@ -3355,1 +3355,1 @@\n-  z_chi(temp_reg, markOopDesc::biased_lock_pattern);\n+  z_chi(temp_reg, markWord::biased_lock_pattern);\n@@ -3368,1 +3368,1 @@\n-  \/\/ Load markOop from oop into mark.\n+  \/\/ Load markWord from oop into mark.\n@@ -3378,1 +3378,1 @@\n-    guarantee(Immediate::is_uimm16(markOopDesc::monitor_value), \"must be half-word\");\n+    guarantee(Immediate::is_uimm16(markWord::monitor_value), \"must be half-word\");\n@@ -3380,1 +3380,1 @@\n-    z_nill(temp, markOopDesc::monitor_value);\n+    z_nill(temp, markWord::monitor_value);\n@@ -3384,2 +3384,2 @@\n-  \/\/ Set mark to markOop | markOopDesc::unlocked_value.\n-  z_oill(displacedHeader, markOopDesc::unlocked_value);\n+  \/\/ Set mark to markWord | markWord::unlocked_value.\n+  z_oill(displacedHeader, markWord::unlocked_value);\n@@ -3393,1 +3393,1 @@\n-  \/\/ Compare object markOop with mark and if equal exchange scratch1 with object markOop.\n+  \/\/ Compare object markWord with mark and if equal exchange scratch1 with object markWord.\n@@ -3404,1 +3404,1 @@\n-  load_const_optimized(temp, (~(os::vm_page_size()-1) | markOopDesc::lock_mask_in_place));\n+  load_const_optimized(temp, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n@@ -3415,1 +3415,1 @@\n-    Register monitor_tagged = displacedHeader; \/\/ Tagged with markOopDesc::monitor_value.\n+    Register monitor_tagged = displacedHeader; \/\/ Tagged with markWord::monitor_value.\n@@ -3466,2 +3466,2 @@\n-    guarantee(Immediate::is_uimm16(markOopDesc::monitor_value), \"must be half-word\");\n-    z_nill(currentHeader, markOopDesc::monitor_value);\n+    guarantee(Immediate::is_uimm16(markWord::monitor_value), \"must be half-word\");\n+    z_nill(currentHeader, markWord::monitor_value);\n@@ -3472,1 +3472,1 @@\n-  \/\/ the stack address of the basicLock in the markOop of the object\n+  \/\/ the stack address of the basicLock in the markWord of the object\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3868,1 +3868,1 @@\n-                     (long)markOopDesc::prototype());\n+                     (long)markWord::prototype());\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -100,1 +100,1 @@\n-  or3(Rmark, markOopDesc::unlocked_value, Rmark);\n+  or3(Rmark, markWord::unlocked_value, Rmark);\n@@ -105,1 +105,1 @@\n-  \/\/ compare object markOop with Rmark and if equal exchange Rscratch with object markOop\n+  \/\/ compare object markWord with Rmark and if equal exchange Rscratch with object markWord\n@@ -147,1 +147,1 @@\n-  \/\/ the stack address of the basicLock in the markOop of the object\n+  \/\/ the stack address of the basicLock in the markWord of the object\n@@ -182,1 +182,1 @@\n-    set((intx)markOopDesc::prototype(), t1);\n+    set((intx)markWord::prototype(), t1);\n","filename":"src\/hotspot\/cpu\/sparc\/c1_MacroAssembler_sparc.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/sparc\/frame_sparc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -1203,1 +1203,1 @@\n-    \/\/ load markOop from object into mark_reg\n+    \/\/ load markWord from object into mark_reg\n@@ -1214,2 +1214,2 @@\n-    \/\/ set mark reg to be (markOop of object | UNLOCK_VALUE)\n-    or3(mark_reg, markOopDesc::unlocked_value, mark_reg);\n+    \/\/ set mark reg to be (markWord of object | UNLOCK_VALUE)\n+    or3(mark_reg, markWord::unlocked_value, mark_reg);\n@@ -1218,1 +1218,1 @@\n-    \/\/ compare and exchange object_addr, markOop | 1, stack address of basicLock\n+    \/\/ compare and exchange object_addr, markWord | 1, stack address of basicLock\n@@ -1227,1 +1227,1 @@\n-    \/\/ Check if owner is self by comparing the value in the markOop of object\n+    \/\/ Check if owner is self by comparing the value in the markWord of object\n@@ -1237,1 +1237,1 @@\n-    \/\/ FFFFF003\/FFFFFFFFFFFF003 is (markOopDesc::lock_mask_in_place | -os::vm_page_size())\n+    \/\/ FFFFF003\/FFFFFFFFFFFF003 is (markWord::lock_mask_in_place | -os::vm_page_size())\n","filename":"src\/hotspot\/cpu\/sparc\/interp_masm_sparc.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2472,3 +2472,3 @@\n-  assert(markOopDesc::age_shift == markOopDesc::lock_bits + markOopDesc::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n-  and3(mark_reg, markOopDesc::biased_lock_mask_in_place, temp_reg);\n-  cmp_and_brx_short(temp_reg, markOopDesc::biased_lock_pattern, Assembler::notEqual, Assembler::pn, cas_label);\n+  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n+  and3(mark_reg, markWord::biased_lock_mask_in_place, temp_reg);\n+  cmp_and_brx_short(temp_reg, markWord::biased_lock_pattern, Assembler::notEqual, Assembler::pn, cas_label);\n@@ -2480,1 +2480,1 @@\n-  andcc(temp_reg, ~((int) markOopDesc::age_mask_in_place), temp_reg);\n+  andcc(temp_reg, ~((int) markWord::age_mask_in_place), temp_reg);\n@@ -2503,1 +2503,1 @@\n-  btst(markOopDesc::biased_lock_mask_in_place, temp_reg);\n+  btst(markWord::biased_lock_mask_in_place, temp_reg);\n@@ -2515,1 +2515,1 @@\n-  delayed()->btst(markOopDesc::epoch_mask_in_place, temp_reg);\n+  delayed()->btst(markWord::epoch_mask_in_place, temp_reg);\n@@ -2525,1 +2525,1 @@\n-                  markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place | markOopDesc::epoch_mask_in_place,\n+                  markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place,\n@@ -2606,2 +2606,2 @@\n-  and3(temp_reg, markOopDesc::biased_lock_mask_in_place, temp_reg);\n-  cmp(temp_reg, markOopDesc::biased_lock_pattern);\n+  and3(temp_reg, markWord::biased_lock_mask_in_place, temp_reg);\n+  cmp(temp_reg, markWord::biased_lock_pattern);\n@@ -2623,1 +2623,1 @@\n-\/\/     Consider G2_thread, rsp, boxReg, or markOopDesc::unused_mark()\n+\/\/     Consider G2_thread, rsp, boxReg, or markWord::unused_mark()\n@@ -2628,1 +2628,1 @@\n-\/\/     are responsible for setting box->dhw = NonZero (typically markOopDesc::unused_mark()).\n+\/\/     are responsible for setting box->dhw = NonZero (typically markWord::unused_mark()).\n@@ -2670,2 +2670,2 @@\n-     \/\/ set Rmark to markOop | markOopDesc::unlocked_value\n-     or3(Rmark, markOopDesc::unlocked_value, Rmark);\n+     \/\/ set Rmark to markWord | markWord::unlocked_value\n+     or3(Rmark, markWord::unlocked_value, Rmark);\n@@ -2676,1 +2676,1 @@\n-     \/\/ compare object markOop with Rmark and if equal exchange Rscratch with object markOop\n+     \/\/ compare object markWord with Rmark and if equal exchange Rscratch with object markWord\n@@ -2720,1 +2720,1 @@\n-      or3(Rmark, markOopDesc::unlocked_value, Rmark);\n+      or3(Rmark, markWord::unlocked_value, Rmark);\n@@ -2782,1 +2782,1 @@\n-      or3(Rmark, markOopDesc::unlocked_value, Rmark);\n+      or3(Rmark, markWord::unlocked_value, Rmark);\n@@ -2836,1 +2836,1 @@\n-      \/\/    markOopDesc::unused_mark(), G2_thread, RBox, RScratch, rsp, etc.\n+      \/\/    markWord::unused_mark(), G2_thread, RBox, RScratch, rsp, etc.\n@@ -2866,1 +2866,1 @@\n-     \/\/ the stack address of the basicLock in the markOop of the object\n+     \/\/ the stack address of the basicLock in the markWord of the object\n","filename":"src\/hotspot\/cpu\/sparc\/macroAssembler_sparc.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1836,1 +1836,1 @@\n-    \/\/ vm: see markOop.hpp.\n+    \/\/ vm: see markWord.hpp.\n@@ -1838,2 +1838,2 @@\n-    __ sethi(markOopDesc::hash_mask, mask);\n-    __ btst(markOopDesc::unlocked_value, header);\n+    __ sethi(markWord::hash_mask, mask);\n+    __ btst(markWord::unlocked_value, header);\n@@ -1844,1 +1844,1 @@\n-      __ btst(markOopDesc::biased_lock_bit_in_place, header);\n+      __ btst(markWord::biased_lock_bit_in_place, header);\n@@ -1847,1 +1847,1 @@\n-    __ delayed()->or3(mask, markOopDesc::hash_mask & 0x3ff, mask);\n+    __ delayed()->or3(mask, markWord::hash_mask & 0x3ff, mask);\n@@ -1850,1 +1850,1 @@\n-    __ srlx(header, markOopDesc::hash_shift, hash);\n+    __ srlx(header, markWord::hash_shift, hash);\n","filename":"src\/hotspot\/cpu\/sparc\/sharedRuntime_sparc.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3521,1 +3521,1 @@\n-    __ set((intptr_t)markOopDesc::prototype(), G4_scratch);\n+    __ set((intptr_t)markWord::prototype(), G4_scratch);\n","filename":"src\/hotspot\/cpu\/sparc\/templateTable_sparc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -62,1 +62,1 @@\n-  orptr(hdr, markOopDesc::unlocked_value);\n+  orptr(hdr, markWord::unlocked_value);\n@@ -157,1 +157,1 @@\n-    movptr(Address(obj, oopDesc::mark_offset_in_bytes ()), (int32_t)(intptr_t)markOopDesc::prototype());\n+    movptr(Address(obj, oopDesc::mark_offset_in_bytes ()), (int32_t)(intptr_t)markWord::prototype().value());\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -656,1 +656,1 @@\n-  __ testb(Address(tmp2, oopDesc::mark_offset_in_bytes()), markOopDesc::marked_value);\n+  __ testb(Address(tmp2, oopDesc::mark_offset_in_bytes()), markWord::marked_value);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1121,1 +1121,1 @@\n-  assert(markOopDesc::age_shift == markOopDesc::lock_bits + markOopDesc::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n+  assert(markWord::age_shift == markWord::lock_bits + markWord::biased_lock_bits, \"biased locking makes assumptions about bit layout\");\n@@ -1141,2 +1141,2 @@\n-  andptr(tmp_reg, markOopDesc::biased_lock_mask_in_place);\n-  cmpptr(tmp_reg, markOopDesc::biased_lock_pattern);\n+  andptr(tmp_reg, markWord::biased_lock_mask_in_place);\n+  cmpptr(tmp_reg, markWord::biased_lock_pattern);\n@@ -1168,1 +1168,1 @@\n-  andptr(header_reg, ~((int) markOopDesc::age_mask_in_place));\n+  andptr(header_reg, ~((int) markWord::age_mask_in_place));\n@@ -1187,1 +1187,1 @@\n-  testptr(header_reg, markOopDesc::biased_lock_mask_in_place);\n+  testptr(header_reg, markWord::biased_lock_mask_in_place);\n@@ -1199,1 +1199,1 @@\n-  testptr(header_reg, markOopDesc::epoch_mask_in_place);\n+  testptr(header_reg, markWord::epoch_mask_in_place);\n@@ -1210,1 +1210,1 @@\n-         markOopDesc::biased_lock_mask_in_place | markOopDesc::age_mask_in_place | markOopDesc::epoch_mask_in_place);\n+         markWord::biased_lock_mask_in_place | markWord::age_mask_in_place | markWord::epoch_mask_in_place);\n@@ -1310,2 +1310,2 @@\n-  andptr(temp_reg, markOopDesc::biased_lock_mask_in_place);\n-  cmpptr(temp_reg, markOopDesc::biased_lock_pattern);\n+  andptr(temp_reg, markWord::biased_lock_mask_in_place);\n+  cmpptr(temp_reg, markWord::biased_lock_pattern);\n@@ -1502,1 +1502,1 @@\n-  testptr(tmpReg, markOopDesc::monitor_value);  \/\/ inflated vs stack-locked|neutral|biased\n+  testptr(tmpReg, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral|biased\n@@ -1517,2 +1517,2 @@\n-  andptr(tmpReg, markOopDesc::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-  cmpptr(tmpReg, markOopDesc::unlocked_value);            \/\/ bits = 001 unlocked\n+  andptr(tmpReg, markWord::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n+  cmpptr(tmpReg, markWord::unlocked_value);            \/\/ bits = 001 unlocked\n@@ -1544,1 +1544,1 @@\n-\/\/         tmpReg (ObjectMonitor address + markOopDesc::monitor_value)\n+\/\/         tmpReg (ObjectMonitor address + markWord::monitor_value)\n@@ -1558,1 +1558,1 @@\n-  movptr(Address(boxReg, 0), (int32_t)intptr_t(markOopDesc::unused_mark()));\n+  movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));\n@@ -1727,1 +1727,1 @@\n-      \/\/ set box->dhw = markOopDesc::unused_mark()\n+      \/\/ set box->dhw = markWord::unused_mark()\n@@ -1729,1 +1729,1 @@\n-      movptr (Address(boxReg, 0), (int32_t)intptr_t(markOopDesc::unused_mark()));\n+      movptr (Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));\n@@ -1771,1 +1771,1 @@\n-    testptr(tmpReg, markOopDesc::monitor_value); \/\/ inflated vs stack-locked|neutral|biased\n+    testptr(tmpReg, markWord::monitor_value); \/\/ inflated vs stack-locked|neutral|biased\n@@ -1775,1 +1775,1 @@\n-    orptr (tmpReg, markOopDesc::unlocked_value);\n+    orptr (tmpReg, markWord::unlocked_value);\n@@ -1801,1 +1801,1 @@\n-    \/\/ The object is inflated. tmpReg contains pointer to ObjectMonitor* + markOopDesc::monitor_value\n+    \/\/ The object is inflated. tmpReg contains pointer to ObjectMonitor* + markWord::monitor_value\n@@ -1816,1 +1816,1 @@\n-    \/\/   set box->_displaced_header = markOopDesc::unused_mark().  Any non-0 value suffices.\n+    \/\/   set box->_displaced_header = markWord::unused_mark().  Any non-0 value suffices.\n@@ -1881,1 +1881,1 @@\n-       movptr(Address(boxReg, 0), intptr_t(markOopDesc::unused_mark()));  \/\/ results in ST-before-CAS penalty\n+       movptr(Address(boxReg, 0), intptr_t(markWord::unused_mark().value()));  \/\/ results in ST-before-CAS penalty\n@@ -1926,1 +1926,1 @@\n-    \/\/ Unconditionally set box->_displaced_header = markOopDesc::unused_mark().\n+    \/\/ Unconditionally set box->_displaced_header = markWord::unused_mark().\n@@ -1928,1 +1928,1 @@\n-    movptr(Address(boxReg, 0), (int32_t)intptr_t(markOopDesc::unused_mark()));\n+    movptr(Address(boxReg, 0), (int32_t)intptr_t(markWord::unused_mark().value()));\n@@ -2001,6 +2001,6 @@\n-      movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));           \/\/ fetch markword\n-      andptr(tmpReg, markOopDesc::biased_lock_mask_in_place); \/\/ look at 3 lock bits\n-      cmpptr(tmpReg, markOopDesc::unlocked_value);            \/\/ bits = 001 unlocked\n-      jccb(Assembler::notEqual, L_regular_unlock);  \/\/ if !HLE RegularLock\n-      xend();                                       \/\/ otherwise end...\n-      jmp(DONE_LABEL);                              \/\/ ... and we're done\n+      movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); \/\/ fetch markword\n+      andptr(tmpReg, markWord::biased_lock_mask_in_place);              \/\/ look at 3 lock bits\n+      cmpptr(tmpReg, markWord::unlocked_value);                         \/\/ bits = 001 unlocked\n+      jccb(Assembler::notEqual, L_regular_unlock);                      \/\/ if !HLE RegularLock\n+      xend();                                                           \/\/ otherwise end...\n+      jmp(DONE_LABEL);                                                  \/\/ ... and we're done\n@@ -2011,4 +2011,4 @@\n-    cmpptr(Address(boxReg, 0), (int32_t)NULL_WORD); \/\/ Examine the displaced header\n-    jcc   (Assembler::zero, DONE_LABEL);            \/\/ 0 indicates recursive stack-lock\n-    movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));             \/\/ Examine the object's markword\n-    testptr(tmpReg, markOopDesc::monitor_value);    \/\/ Inflated?\n+    cmpptr(Address(boxReg, 0), (int32_t)NULL_WORD);                   \/\/ Examine the displaced header\n+    jcc   (Assembler::zero, DONE_LABEL);                              \/\/ 0 indicates recursive stack-lock\n+    movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); \/\/ Examine the object's markword\n+    testptr(tmpReg, markWord::monitor_value);                         \/\/ Inflated?\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":33,"deletions":33,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  __ testptr(result, markOopDesc::unlocked_value);\n+  __ testptr(result, markWord::unlocked_value);\n@@ -67,1 +67,1 @@\n-    __ testptr(result, markOopDesc::biased_lock_bit_in_place);\n+    __ testptr(result, markWord::biased_lock_bit_in_place);\n@@ -75,3 +75,3 @@\n-  \/\/ because it could be larger than 32 bits in a 64-bit vm. See markOop.hpp.\n-  __ shrptr(result, markOopDesc::hash_shift);\n-  __ andptr(result, markOopDesc::hash_mask);\n+  \/\/ because it could be larger than 32 bits in a 64-bit vm. See markWord.hpp.\n+  __ shrptr(result, markWord::hash_shift);\n+  __ andptr(result, markWord::hash_mask);\n@@ -79,1 +79,1 @@\n-  __ andptr(result, markOopDesc::hash_mask_in_place);\n+  __ andptr(result, markWord::hash_mask_in_place);\n@@ -85,1 +85,1 @@\n-  __ shrptr(result, markOopDesc::hash_shift);\n+  __ shrptr(result, markWord::hash_shift);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4106,1 +4106,1 @@\n-                (intptr_t)markOopDesc::prototype()); \/\/ header\n+                (intptr_t)markWord::prototype().value()); \/\/ header\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -277,1 +277,1 @@\n-    markOop disp = lockee->mark()->set_unlocked();\n+    markWord disp = lockee->mark().set_unlocked();\n@@ -280,1 +280,1 @@\n-    if (lockee->cas_set_mark((markOop)monitor, disp) != disp) {\n+    if (lockee->cas_set_mark((markWord)monitor, disp) != disp) {\n@@ -419,1 +419,1 @@\n-    markOop header = lock->displaced_header();\n+    markWord header = lock->displaced_header();\n@@ -424,1 +424,1 @@\n-      markOop old_header = markOopDesc::encode(lock);\n+      markWord old_header = markWord::encode(lock);\n","filename":"src\/hotspot\/cpu\/zero\/cppInterpreter_zero.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-  AD.addInclude(AD._CPP_file, \"oops\/markOop.hpp\");\n+  AD.addInclude(AD._CPP_file, \"oops\/markWord.hpp\");\n","filename":"src\/hotspot\/share\/adlc\/main.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -60,2 +60,2 @@\n-  intptr_t hc = k->java_mirror()->mark()->hash();\n-  return hc != markOopDesc::no_hash ? hc : os::random();\n+  intptr_t hc = k->java_mirror()->mark().hash();\n+  return hc != markWord::no_hash ? hc : os::random();\n","filename":"src\/hotspot\/share\/classfile\/altHashing.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2186,1 +2186,1 @@\n-        k->set_prototype_header(markOopDesc::biased_locking_prototype());\n+        k->set_prototype_header(markWord::biased_locking_prototype());\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -753,1 +753,1 @@\n-  const size_t sz = heap_word_size(sizeof(SpoolBlock) + sizeof(markOop)\n+  const size_t sz = heap_word_size(sizeof(SpoolBlock) + sizeof(markWord)\n","filename":"src\/hotspot\/share\/gc\/cms\/compactibleFreeListSpace.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1014,1 +1014,1 @@\n-                                           oop old, markOop m,\n+                                           oop old, markWord m,\n@@ -7758,1 +7758,1 @@\n-  const markOop proto = markOopDesc::prototype();\n+  const markWord proto = markWord::prototype();\n@@ -7761,1 +7761,1 @@\n-    next = oop(cur->mark_raw());\n+    next = oop(cur->mark_raw().to_pointer());\n@@ -7845,2 +7845,2 @@\n-  for (; i > 1 && cur->mark_raw() != NULL; cur = oop(cur->mark_raw()), i--);\n-  if (cur->mark_raw() == NULL) {\n+  for (; i > 1 && cur->mark_raw().to_pointer() != NULL; cur = oop(cur->mark_raw().to_pointer()), i--);\n+  if (cur->mark_raw().to_pointer() == NULL) {\n@@ -7856,3 +7856,3 @@\n-    assert(cur->mark_raw() != BUSY, \"Error\");\n-    oop suffix_head = cur->mark_raw(); \/\/ suffix will be put back on global list\n-    cur->set_mark_raw(NULL);           \/\/ break off suffix\n+    assert(cur->mark_raw().to_pointer() != (void*)BUSY, \"Error\");\n+    oop suffix_head = oop(cur->mark_raw().to_pointer()); \/\/ suffix will be put back on global list\n+    cur->set_mark_raw(markWord::from_pointer(NULL));     \/\/ break off suffix\n@@ -7878,1 +7878,1 @@\n-      for (cur = suffix_head; cur->mark_raw() != NULL; cur = (oop)(cur->mark_raw()));\n+      for (cur = suffix_head; cur->mark_raw().to_pointer() != NULL; cur = (oop)(cur->mark_raw().to_pointer()));\n@@ -7880,1 +7880,1 @@\n-      assert(suffix_tail != NULL && suffix_tail->mark_raw() == NULL,\n+      assert(suffix_tail != NULL && suffix_tail->mark_raw().to_pointer() == NULL,\n@@ -7887,1 +7887,1 @@\n-          suffix_tail->set_mark_raw(markOop(cur_overflow_list));\n+          suffix_tail->set_mark_raw(markWord::from_pointer((void*)cur_overflow_list));\n@@ -7889,1 +7889,1 @@\n-          suffix_tail->set_mark_raw(NULL);\n+          suffix_tail->set_mark_raw(markWord::from_pointer(NULL));\n@@ -7901,1 +7901,1 @@\n-  const markOop proto = markOopDesc::prototype();\n+  const markWord proto = markWord::prototype();\n@@ -7905,1 +7905,1 @@\n-    next = oop(cur->mark_raw());\n+    next = oop(cur->mark_raw().to_pointer());\n@@ -7924,1 +7924,1 @@\n-  p->set_mark_raw((markOop)_overflow_list);\n+  p->set_mark_raw(markWord::from_pointer(_overflow_list));\n@@ -7938,1 +7938,1 @@\n-      p->set_mark_raw(markOop(cur_overflow_list));\n+      p->set_mark_raw(markWord::from_pointer((void*)cur_overflow_list));\n@@ -7940,1 +7940,1 @@\n-      p->set_mark_raw(NULL);\n+      p->set_mark_raw(markWord::from_pointer(NULL));\n@@ -7962,1 +7962,1 @@\n-void CMSCollector::preserve_mark_work(oop p, markOop m) {\n+void CMSCollector::preserve_mark_work(oop p, markWord m) {\n@@ -7972,2 +7972,2 @@\n-  markOop m = p->mark_raw();\n-  if (m->must_be_preserved(p)) {\n+  markWord m = p->mark_raw();\n+  if (m.must_be_preserved(p)) {\n@@ -7979,2 +7979,2 @@\n-  markOop m = p->mark_raw();\n-  if (m->must_be_preserved(p)) {\n+  markWord m = p->mark_raw();\n+  if (m.must_be_preserved(p)) {\n@@ -8020,1 +8020,1 @@\n-    assert(p->mark_raw() == markOopDesc::prototype(),\n+    assert(p->mark_raw() == markWord::prototype(),\n@@ -8022,1 +8022,1 @@\n-    markOop m = _preserved_mark_stack.pop();\n+    markWord m = _preserved_mark_stack.pop();\n","filename":"src\/hotspot\/share\/gc\/cms\/concurrentMarkSweepGeneration.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -544,2 +544,2 @@\n-  Stack<oop, mtGC>     _preserved_oop_stack;\n-  Stack<markOop, mtGC> _preserved_mark_stack;\n+  Stack<oop, mtGC>      _preserved_oop_stack;\n+  Stack<markWord, mtGC> _preserved_mark_stack;\n@@ -752,1 +752,1 @@\n-  void preserve_mark_work(oop p, markOop m);\n+  void preserve_mark_work(oop p, markWord m);\n@@ -1144,1 +1144,1 @@\n-                          oop obj, markOop m, size_t word_sz);\n+                          oop obj, markWord m, size_t word_sz);\n","filename":"src\/hotspot\/share\/gc\/cms\/concurrentMarkSweepGeneration.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -59,1 +59,1 @@\n-  \/\/ For 64 bit compressed oops, the markOop encodes both the size and the\n+  \/\/ For 64 bit compressed oops, the markWord encodes both the size and the\n@@ -65,2 +65,2 @@\n-  markOop mark()     const volatile { return (markOop)_size; }\n-  void set_mark(markOop m)          { _size = (size_t)m; }\n+  markWord mark()     const volatile { return markWord((uintptr_t)_size); }\n+  void set_mark(markWord m)          { _size = (size_t)m.value(); }\n@@ -82,1 +82,1 @@\n-    LP64_ONLY(if (UseCompressedOops) return mark()->is_cms_free_chunk(); else)\n+    LP64_ONLY(if (UseCompressedOops) return mark().is_cms_free_chunk(); else)\n@@ -103,1 +103,1 @@\n-    LP64_ONLY(if (UseCompressedOops) return mark()->get_size(); else )\n+    LP64_ONLY(if (UseCompressedOops) return mark().get_size(); else )\n@@ -107,1 +107,1 @@\n-    LP64_ONLY(if (UseCompressedOops) set_mark(markOopDesc::set_size_and_free(sz)); else )\n+    LP64_ONLY(if (UseCompressedOops) set_mark(markWord::set_size_and_free(sz)); else )\n@@ -129,1 +129,1 @@\n-      set_mark(markOopDesc::prototype());\n+      set_mark(markWord::prototype());\n","filename":"src\/hotspot\/share\/gc\/cms\/freeChunk.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1091,1 +1091,1 @@\n-                                             markOop m) {\n+                                             markWord m) {\n","filename":"src\/hotspot\/share\/gc\/cms\/parNewGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -389,1 +389,1 @@\n-                             oop obj, size_t obj_sz, markOop m);\n+                             oop obj, size_t obj_sz, markWord m);\n","filename":"src\/hotspot\/share\/gc\/cms\/parNewGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    markOop m = obj->mark_raw();\n+    markWord m = obj->mark_raw();\n@@ -50,1 +50,1 @@\n-    if (m->is_marked()) { \/\/ Contains forwarding pointer.\n+    if (m.is_marked()) { \/\/ Contains forwarding pointer.\n@@ -113,1 +113,1 @@\n-      markOop m = obj->mark_raw();\n+      markWord m = obj->mark_raw();\n@@ -115,1 +115,1 @@\n-      if (m->is_marked()) { \/\/ Contains forwarding pointer.\n+      if (m.is_marked()) { \/\/ Contains forwarding pointer.\n","filename":"src\/hotspot\/share\/gc\/cms\/parOopClosures.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"oops\/markOop.inline.hpp\"\n+#include \"oops\/markWord.inline.hpp\"\n@@ -65,1 +65,1 @@\n-markOop PromotionInfo::nextDisplacedHeader() {\n+markWord PromotionInfo::nextDisplacedHeader() {\n@@ -70,1 +70,1 @@\n-  markOop hdr = _spoolHead->displacedHdr[_firstIndex];\n+  markWord hdr = _spoolHead->displacedHdr[_firstIndex];\n@@ -96,1 +96,1 @@\n-  markOop mark = oop(trackOop)->mark_raw();\n+  markWord mark = oop(trackOop)->mark_raw();\n@@ -98,1 +98,1 @@\n-  if (mark->must_be_preserved_for_cms_scavenge(klassOfOop)) {\n+  if (mark.must_be_preserved_for_cms_scavenge(klassOfOop)) {\n@@ -104,1 +104,1 @@\n-    \/\/ assert(mark == markOopDesc::prototype(), \"consistency check\");\n+    \/\/ assert(mark == markWord::prototype(), \"consistency check\");\n@@ -126,1 +126,1 @@\n-void PromotionInfo::saveDisplacedHeader(markOop hdr) {\n+void PromotionInfo::saveDisplacedHeader(markWord hdr) {\n","filename":"src\/hotspot\/share\/gc\/cms\/promotionInfo.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  markOop*     displacedHdr;      \/\/ the displaced headers start here\n+  markWord*    displacedHdr;      \/\/ the displaced headers start here\n@@ -102,1 +102,1 @@\n-    return (size() * sizeof(HeapWord) - sizeof(*this)) \/ sizeof(markOop);\n+    return (size() * sizeof(HeapWord) - sizeof(*this)) \/ sizeof(markWord);\n@@ -108,1 +108,1 @@\n-    displacedHdr = (markOop*)&displacedHdr;\n+    displacedHdr = (markWord*)&displacedHdr;\n@@ -154,2 +154,2 @@\n-  markOop nextDisplacedHeader(); \/\/ get next header & forward spool pointer\n-  void    saveDisplacedHeader(markOop hdr);\n+  markWord nextDisplacedHeader(); \/\/ get next header & forward spool pointer\n+  void    saveDisplacedHeader(markWord hdr);\n","filename":"src\/hotspot\/share\/gc\/cms\/promotionInfo.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3141,1 +3141,1 @@\n-void G1CollectedHeap::preserve_mark_during_evac_failure(uint worker_id, oop obj, markOop m) {\n+void G1CollectedHeap::preserve_mark_during_evac_failure(uint worker_id, oop obj, markWord m) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -803,1 +803,1 @@\n-  void preserve_mark_during_evac_failure(uint worker_id, oop obj, markOop m);\n+  void preserve_mark_during_evac_failure(uint worker_id, oop obj, markWord m);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -291,1 +291,1 @@\n-  \/\/ word is set to markOop::marked_value - effectively removing\n+  \/\/ word is set to markWord::marked_value - effectively removing\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,2 +119,2 @@\n-      assert(object->mark_raw() == markOopDesc::prototype_for_object(object) || \/\/ Correct mark\n-             object->mark_raw()->must_be_preserved(object) || \/\/ Will be restored by PreservedMarksSet\n+      assert(object->mark_raw() == markWord::prototype_for_object(object) || \/\/ Correct mark\n+             object->mark_raw().must_be_preserved(object) || \/\/ Will be restored by PreservedMarksSet\n@@ -123,1 +123,1 @@\n-             p2i(object), p2i(object->mark_raw()), p2i(markOopDesc::prototype_for_object(object)));\n+             p2i(object), object->mark_raw().value(), markWord::prototype_for_object(object).value());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,2 +53,2 @@\n-  markOop mark = obj->mark_raw();\n-  if (mark->must_be_preserved(obj) &&\n+  markWord mark = obj->mark_raw();\n+  if (mark.must_be_preserved(obj) &&\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-    assert(obj->mark_raw() == markOopDesc::prototype_for_object(obj) || \/\/ Correct mark\n-           obj->mark_raw()->must_be_preserved(obj) || \/\/ Will be restored by PreservedMarksSet\n+    assert(obj->mark_raw() == markWord::prototype_for_object(obj) || \/\/ Correct mark\n+           obj->mark_raw().must_be_preserved(obj) || \/\/ Will be restored by PreservedMarksSet\n@@ -83,1 +83,1 @@\n-           p2i(obj), p2i(obj->mark_raw()), p2i(markOopDesc::prototype_for_object(obj)));\n+           p2i(obj), obj->mark_raw().value(), markWord::prototype_for_object(obj).value());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -252,3 +252,3 @@\n-    markOop m = obj->mark_raw();\n-    if (m->is_marked()) {\n-      forwardee = (oop) m->decode_pointer();\n+    markWord m = obj->mark_raw();\n+    if (m.is_marked()) {\n+      forwardee = (oop) m.decode_pointer();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-InCSetState G1ParScanThreadState::next_state(InCSetState const state, markOop const m, uint& age) {\n+InCSetState G1ParScanThreadState::next_state(InCSetState const state, markWord const m, uint& age) {\n@@ -191,2 +191,2 @@\n-    age = !m->has_displaced_mark_helper() ? m->age()\n-                                          : m->displaced_mark_helper()->age();\n+    age = !m.has_displaced_mark_helper() ? m.age()\n+                                          : m.displaced_mark_helper().age();\n@@ -216,1 +216,1 @@\n-                                                 markOop const old_mark) {\n+                                                 markWord const old_mark) {\n@@ -274,1 +274,1 @@\n-      if (age < markOopDesc::max_age) {\n+      if (age < markWord::max_age) {\n@@ -277,1 +277,1 @@\n-      if (old_mark->has_displaced_mark_helper()) {\n+      if (old_mark.has_displaced_mark_helper()) {\n@@ -282,2 +282,2 @@\n-        markOop new_mark = old_mark->displaced_mark_helper()->set_age(age);\n-        old_mark->set_displaced_mark_helper(new_mark);\n+        markWord new_mark = old_mark.displaced_mark_helper().set_age(age);\n+        old_mark.set_displaced_mark_helper(new_mark);\n@@ -285,1 +285,1 @@\n-        obj->set_mark_raw(old_mark->set_age(age));\n+        obj->set_mark_raw(old_mark.set_age(age));\n@@ -356,1 +356,1 @@\n-oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markOop m) {\n+oop G1ParScanThreadState::handle_evacuation_failure_par(oop old, markWord m) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-  inline InCSetState next_state(InCSetState const state, markOop const m, uint& age);\n+  inline InCSetState next_state(InCSetState const state, markWord const m, uint& age);\n@@ -199,1 +199,1 @@\n-  oop copy_to_survivor_space(InCSetState const state, oop const obj, markOop const old_mark);\n+  oop copy_to_survivor_space(InCSetState const state, oop const obj, markWord const old_mark);\n@@ -210,1 +210,1 @@\n-  oop handle_evacuation_failure_par(oop obj, markOop m);\n+  oop handle_evacuation_failure_par(oop obj, markWord m);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,3 +44,3 @@\n-    markOop m = obj->mark_raw();\n-    if (m->is_marked()) {\n-      obj = (oop) m->decode_pointer();\n+    markWord m = obj->mark_raw();\n+    if (m.is_marked()) {\n+      obj = (oop) m.decode_pointer();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-\/\/ pointers into markOops for use by adjust_pointers. If \"dest\" should overflow, we\n+\/\/ pointers into markWords for use by adjust_pointers. If \"dest\" should overflow, we\n@@ -116,2 +116,2 @@\n-    assert(oop(q)->mark_raw()->is_marked() || oop(q)->mark_raw()->is_unlocked() ||\n-           oop(q)->mark_raw()->has_bias_pattern(),\n+    assert(oop(q)->mark_raw().is_marked() || oop(q)->mark_raw().is_unlocked() ||\n+           oop(q)->mark_raw().has_bias_pattern(),\n@@ -262,1 +262,1 @@\n-    oop(q)->set_mark_raw(oop(q)->mark_raw()->set_marked());\n+    oop(q)->set_mark_raw(oop(q)->mark_raw().set_marked());\n@@ -353,1 +353,1 @@\n-      q = (HeapWord*) oop(_first_dead)->mark_raw()->decode_pointer();\n+      q = (HeapWord*) oop(_first_dead)->mark_raw().decode_pointer();\n@@ -364,1 +364,1 @@\n-      q = (HeapWord*) oop(q)->mark_raw()->decode_pointer();\n+      q = (HeapWord*) oop(q)->mark_raw().decode_pointer();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psMarkSweepDecorator.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  filler_oop->set_mark_raw(markOopDesc::prototype());\n+  filler_oop->set_mark_raw(markWord::prototype());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionLAB.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -495,1 +495,1 @@\n-oop PSPromotionManager::oop_promotion_failed(oop obj, markOop obj_mark) {\n+oop PSPromotionManager::oop_promotion_failed(oop obj, markWord obj_mark) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-  oop oop_promotion_failed(oop obj, markOop obj_mark);\n+  oop oop_promotion_failed(oop obj, markWord obj_mark);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-  markOop test_mark = o->mark_raw();\n+  markWord test_mark = o->mark_raw();\n@@ -122,1 +122,1 @@\n-  if (!test_mark->is_marked()) {\n+  if (!test_mark.is_marked()) {\n@@ -127,2 +127,2 @@\n-    uint age = (test_mark->has_displaced_mark_helper() \/* o->has_displaced_mark() *\/) ?\n-      test_mark->displaced_mark_helper()->age() : test_mark->age();\n+    uint age = (test_mark.has_displaced_mark_helper() \/* o->has_displaced_mark() *\/) ?\n+      test_mark.displaced_mark_helper().age() : test_mark.age();\n@@ -222,1 +222,1 @@\n-      \/\/ we're dealing with a markOop that cannot change, it is\n+      \/\/ we're dealing with a markWord that cannot change, it is\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -279,1 +279,1 @@\n-  assert(!NeverTenure || _tenuring_threshold == markOopDesc::max_age + 1, \"Sanity\");\n+  assert(!NeverTenure || _tenuring_threshold == markWord::max_age + 1, \"Sanity\");\n@@ -731,2 +731,2 @@\n-    assert(MaxTenuringThreshold == 0 || MaxTenuringThreshold == markOopDesc::max_age + 1,\n-           \"MaxTenuringThreshold should be 0 or markOopDesc::max_age + 1, but is %d\", (int) MaxTenuringThreshold);\n+    assert(MaxTenuringThreshold == 0 || MaxTenuringThreshold == markWord::max_age + 1,\n+           \"MaxTenuringThreshold should be 0 or markWord::max_age + 1, but is %d\", (int) MaxTenuringThreshold);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -750,1 +750,1 @@\n-  \/\/ Mark sweep stores preserved markOops in to space, don't disturb!\n+  \/\/ Mark sweep stores preserved markWords in to space, don't disturb!\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-Stack<markOop, mtGC>          MarkSweep::_preserved_mark_stack;\n+Stack<markWord, mtGC>         MarkSweep::_preserved_mark_stack;\n@@ -134,1 +134,1 @@\n-    if (!obj->mark_raw()->is_marked()) {\n+    if (!obj->mark_raw().is_marked()) {\n@@ -154,1 +154,1 @@\n-\/\/ that it will go.  Note that the object that this markOop belongs to isn't\n+\/\/ that it will go.  Note that the object that this markWord belongs to isn't\n@@ -156,1 +156,1 @@\n-void MarkSweep::preserve_mark(oop obj, markOop mark) {\n+void MarkSweep::preserve_mark(oop obj, markWord mark) {\n@@ -206,1 +206,1 @@\n-    markOop mark  = _preserved_mark_stack.pop();\n+    markWord mark = _preserved_mark_stack.pop();\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -103,1 +103,1 @@\n-  static Stack<markOop, mtGC>                  _preserved_mark_stack;\n+  static Stack<markWord, mtGC>                 _preserved_mark_stack;\n@@ -140,1 +140,1 @@\n-  static void preserve_mark(oop p, markOop mark);\n+  static void preserve_mark(oop p, markWord mark);\n@@ -202,1 +202,1 @@\n-  markOop _mark;\n+  markWord _mark;\n@@ -205,1 +205,1 @@\n-  void init(oop obj, markOop mark) {\n+  void init(oop obj, markWord mark) {\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"oops\/markOop.inline.hpp\"\n+#include \"oops\/markWord.inline.hpp\"\n@@ -41,2 +41,2 @@\n-  markOop mark = obj->mark_raw();\n-  obj->set_mark_raw(markOopDesc::prototype()->set_marked());\n+  markWord mark = obj->mark_raw();\n+  obj->set_mark_raw(markWord::prototype().set_marked());\n@@ -44,1 +44,1 @@\n-  if (mark->must_be_preserved(obj)) {\n+  if (mark.must_be_preserved(obj)) {\n@@ -53,1 +53,1 @@\n-    if (!obj->mark_raw()->is_marked()) {\n+    if (!obj->mark_raw().is_marked()) {\n@@ -82,1 +82,1 @@\n-    oop new_obj = oop(obj->mark_raw()->decode_pointer());\n+    oop new_obj = oop(obj->mark_raw().decode_pointer());\n@@ -84,3 +84,3 @@\n-    assert(new_obj != NULL ||                         \/\/ is forwarding ptr?\n-           obj->mark_raw() == markOopDesc::prototype() || \/\/ not gc marked?\n-           (UseBiasedLocking && obj->mark_raw()->has_bias_pattern()),\n+    assert(new_obj != NULL ||                          \/\/ is forwarding ptr?\n+           obj->mark_raw() == markWord::prototype() || \/\/ not gc marked?\n+           (UseBiasedLocking && obj->mark_raw().has_bias_pattern()),\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-    assert(MaxTenuringThreshold == 0 || MaxTenuringThreshold == markOopDesc::max_age + 1,\n-           \"MaxTenuringThreshold should be 0 or markOopDesc::max_age + 1, but is \" UINTX_FORMAT, MaxTenuringThreshold);\n+    assert(MaxTenuringThreshold == 0 || MaxTenuringThreshold == markWord::max_age + 1,\n+           \"MaxTenuringThreshold should be 0 or markWord::max_age + 1, but is \" UINTX_FORMAT, MaxTenuringThreshold);\n","filename":"src\/hotspot\/share\/gc\/shared\/ageTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -44,1 +44,1 @@\n-  enum { table_size = markOopDesc::max_age + 1 };\n+  enum { table_size = markWord::max_age + 1 };\n","filename":"src\/hotspot\/share\/gc\/shared\/ageTable.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -819,1 +819,1 @@\n-          range(0, markOopDesc::max_age + 1)                                \\\n+          range(0, markWord::max_age + 1)                                   \\\n@@ -824,1 +824,1 @@\n-          range(0, markOopDesc::max_age + 1)                                \\\n+          range(0, markWord::max_age + 1)                                   \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-                            oop obj, markOop m, size_t word_sz) {\n+                            oop obj, markWord m, size_t word_sz) {\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-  virtual oop par_promote(int thread_num, oop obj, markOop m, size_t word_sz);\n+  virtual oop par_promote(int thread_num, oop obj, markWord m, size_t word_sz);\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-    oopDesc::set_mark_raw(mem, markOopDesc::prototype());\n+    oopDesc::set_mark_raw(mem, markWord::prototype());\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-    const OopAndMarkOop elem = _stack.pop();\n+    const OopAndMarkWord elem = _stack.pop();\n@@ -42,1 +42,1 @@\n-  StackIterator<OopAndMarkOop, mtGC> iter(_stack);\n+  StackIterator<OopAndMarkWord, mtGC> iter(_stack);\n@@ -44,1 +44,1 @@\n-    OopAndMarkOop* elem = iter.next_addr();\n+    OopAndMarkWord* elem = iter.next_addr();\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  class OopAndMarkOop {\n+  class OopAndMarkWord {\n@@ -41,1 +41,1 @@\n-    markOop _m;\n+    markWord _m;\n@@ -44,1 +44,1 @@\n-    OopAndMarkOop(oop obj, markOop m) : _o(obj), _m(m) { }\n+    OopAndMarkWord(oop obj, markWord m) : _o(obj), _m(m) { }\n@@ -50,1 +50,1 @@\n-  typedef Stack<OopAndMarkOop, mtGC> OopAndMarkOopStack;\n+  typedef Stack<OopAndMarkWord, mtGC> OopAndMarkWordStack;\n@@ -52,1 +52,1 @@\n-  OopAndMarkOopStack _stack;\n+  OopAndMarkWordStack _stack;\n@@ -54,1 +54,1 @@\n-  inline bool should_preserve_mark(oop obj, markOop m) const;\n+  inline bool should_preserve_mark(oop obj, markWord m) const;\n@@ -58,2 +58,2 @@\n-  inline void push(oop obj, markOop m);\n-  inline void push_if_necessary(oop obj, markOop m);\n+  inline void push(oop obj, markWord m);\n+  inline void push_if_necessary(oop obj, markWord m);\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-inline bool PreservedMarks::should_preserve_mark(oop obj, markOop m) const {\n-  return m->must_be_preserved_for_promotion_failure(obj);\n+inline bool PreservedMarks::should_preserve_mark(oop obj, markWord m) const {\n+  return m.must_be_preserved_for_promotion_failure(obj);\n@@ -37,1 +37,1 @@\n-inline void PreservedMarks::push(oop obj, markOop m) {\n+inline void PreservedMarks::push(oop obj, markWord m) {\n@@ -39,1 +39,1 @@\n-  OopAndMarkOop elem(obj, m);\n+  OopAndMarkWord elem(obj, m);\n@@ -43,1 +43,1 @@\n-inline void PreservedMarks::push_if_necessary(oop obj, markOop m) {\n+inline void PreservedMarks::push_if_necessary(oop obj, markWord m) {\n@@ -75,1 +75,1 @@\n-    : _stack(OopAndMarkOopStack::default_segment_size(),\n+    : _stack(OopAndMarkWordStack::default_segment_size(),\n@@ -82,1 +82,1 @@\n-void PreservedMarks::OopAndMarkOop::set_mark() const {\n+void PreservedMarks::OopAndMarkWord::set_mark() const {\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.inline.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -654,1 +654,1 @@\n-    t->set_mark_raw(markOopDesc::prototype());\n+    t->set_mark_raw(markWord::prototype());\n@@ -661,1 +661,1 @@\n-    obj->set_mark_raw(markOopDesc::prototype());\n+    obj->set_mark_raw(markWord::prototype());\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-      obj->set_mark_raw(obj->mark_raw()->set_marked());\n+      obj->set_mark_raw(obj->mark_raw().set_marked());\n@@ -168,2 +168,2 @@\n-           oop(cur_obj)->mark_raw()->is_marked() || oop(cur_obj)->mark_raw()->is_unlocked() ||\n-           oop(cur_obj)->mark_raw()->has_bias_pattern(),\n+           oop(cur_obj)->mark_raw().is_marked() || oop(cur_obj)->mark_raw().is_unlocked() ||\n+           oop(cur_obj)->mark_raw().has_bias_pattern(),\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  obj->mark()->print_on(&mw_ss);\n+  obj->mark().print_on(&mw_ss);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.inline.hpp\"\n+#include \"oops\/markWord.inline.hpp\"\n@@ -42,3 +42,3 @@\n-  markOop mark = obj->mark_raw();\n-  if (mark->is_marked()) {\n-    HeapWord* fwdptr = (HeapWord*) mark->clear_lock_bits();\n+  markWord mark = obj->mark_raw();\n+  if (mark.is_marked()) {\n+    HeapWord* fwdptr = (HeapWord*) mark.clear_lock_bits().to_pointer();\n@@ -57,3 +57,3 @@\n-  markOop mark = obj->mark_raw();\n-  if (mark->is_marked()) {\n-    HeapWord* fwdptr = (HeapWord*)mark->clear_lock_bits();\n+  markWord mark = obj->mark_raw();\n+  if (mark.is_marked()) {\n+    HeapWord* fwdptr = (HeapWord*)mark.clear_lock_bits().to_pointer();\n@@ -73,1 +73,1 @@\n-  return obj->mark_raw()->is_marked();\n+  return obj->mark_raw().is_marked();\n@@ -77,3 +77,3 @@\n-  markOop old_mark = obj->mark_raw();\n-  if (old_mark->is_marked()) {\n-    return (oop) old_mark->clear_lock_bits();\n+  markWord old_mark = obj->mark_raw();\n+  if (old_mark.is_marked()) {\n+    return (oop) old_mark.clear_lock_bits().to_pointer();\n@@ -82,2 +82,2 @@\n-  markOop new_mark = markOopDesc::encode_pointer_as_mark(update);\n-  markOop prev_mark = obj->cas_set_mark_raw(new_mark, old_mark);\n+  markWord new_mark = markWord::encode_pointer_as_mark(update);\n+  markWord prev_mark = obj->cas_set_mark_raw(new_mark, old_mark);\n@@ -87,1 +87,1 @@\n-    return (oop) prev_mark->clear_lock_bits();\n+    return (oop) prev_mark.clear_lock_bits().to_pointer();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    const markOop mark = java_string->mark();\n+    const markWord mark = java_string->mark();\n@@ -53,1 +53,1 @@\n-    if (mark == markOopDesc::INFLATING() || mark->has_displaced_mark_helper()) {\n+    if (mark == markWord::INFLATING() || mark.has_displaced_mark_helper()) {\n@@ -58,1 +58,1 @@\n-    markOop new_mark = mark->incr_age();\n+    markWord new_mark = mark.incr_age();\n@@ -60,1 +60,1 @@\n-      if (mark->age() == StringDeduplicationAgeThreshold) {\n+      if (mark.age() == StringDeduplicationAgeThreshold) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahStringDedup.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -667,3 +667,3 @@\n-        uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;\n-        markOop mark = rcvr->mark();\n-        intptr_t hash = (intptr_t) markOopDesc::no_hash;\n+        uintptr_t epoch_mask_in_place = (uintptr_t)markWord::epoch_mask_in_place;\n+        markWord mark = rcvr->mark();\n+        intptr_t hash = (intptr_t) markWord::no_hash;\n@@ -671,1 +671,1 @@\n-        if (mark->has_bias_pattern()) {\n+        if (mark.has_bias_pattern()) {\n@@ -676,2 +676,2 @@\n-            (((uintptr_t)rcvr->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) &\n-            ~((uintptr_t) markOopDesc::age_mask_in_place);\n+            (((uintptr_t)rcvr->klass()->prototype_header().value() | thread_ident) ^ mark.value()) &\n+            ~((uintptr_t) markWord::age_mask_in_place);\n@@ -685,1 +685,1 @@\n-          } else if ((anticipated_bias_locking_value & markOopDesc::biased_lock_mask_in_place) != 0) {\n+          } else if ((anticipated_bias_locking_value & markWord::biased_lock_mask_in_place) != 0) {\n@@ -687,3 +687,3 @@\n-            markOop header = rcvr->klass()->prototype_header();\n-            if (hash != markOopDesc::no_hash) {\n-              header = header->copy_set_hash(hash);\n+            markWord header = rcvr->klass()->prototype_header();\n+            if (hash != markWord::no_hash) {\n+              header = header.copy_set_hash(hash);\n@@ -697,3 +697,3 @@\n-            markOop new_header = (markOop) ( (intptr_t) rcvr->klass()->prototype_header() | thread_ident);\n-            if (hash != markOopDesc::no_hash) {\n-              new_header = new_header->copy_set_hash(hash);\n+            markWord new_header( (intptr_t) rcvr->klass()->prototype_header().value() | thread_ident);\n+            if (hash != markWord::no_hash) {\n+              new_header = new_header.copy_set_hash(hash);\n@@ -711,5 +711,5 @@\n-            markOop header = (markOop) ((uintptr_t) mark &\n-                                        ((uintptr_t)markOopDesc::biased_lock_mask_in_place |\n-                                         (uintptr_t)markOopDesc::age_mask_in_place | epoch_mask_in_place));\n-            if (hash != markOopDesc::no_hash) {\n-              header = header->copy_set_hash(hash);\n+            markWord header(mark.value() &\n+                            ((uintptr_t)markWord::biased_lock_mask_in_place |\n+                             (uintptr_t)markWord::age_mask_in_place | epoch_mask_in_place));\n+            if (hash != markWord::no_hash) {\n+              header = header.copy_set_hash(hash);\n@@ -717,1 +717,1 @@\n-            markOop new_header = (markOop) ((uintptr_t) header | thread_ident);\n+            markWord new_header = (header.value() | thread_ident);\n@@ -719,1 +719,1 @@\n-            DEBUG_ONLY(mon->lock()->set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)\n+            DEBUG_ONLY(mon->lock()->set_displaced_header(markWord((uintptr_t) 0xdeaddead));)\n@@ -733,1 +733,1 @@\n-          markOop displaced = rcvr->mark()->set_unlocked();\n+          markWord displaced = rcvr->mark().set_unlocked();\n@@ -736,1 +736,1 @@\n-          if (call_vm || rcvr->cas_set_mark((markOop)mon, displaced) != displaced) {\n+          if (call_vm || rcvr->cas_set_mark(markWord::from_pointer(mon), displaced) != displaced) {\n@@ -738,2 +738,2 @@\n-            if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {\n-              mon->lock()->set_displaced_header(NULL);\n+            if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+              mon->lock()->set_displaced_header(markWord::from_pointer(NULL));\n@@ -852,1 +852,1 @@\n-      uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;\n+      uintptr_t epoch_mask_in_place = (uintptr_t)markWord::epoch_mask_in_place;\n@@ -854,2 +854,2 @@\n-      markOop mark = lockee->mark();\n-      intptr_t hash = (intptr_t) markOopDesc::no_hash;\n+      markWord mark = lockee->mark();\n+      intptr_t hash = (intptr_t) markWord::no_hash;\n@@ -857,1 +857,1 @@\n-      if (mark->has_bias_pattern()) {\n+      if (mark.has_bias_pattern()) {\n@@ -862,2 +862,2 @@\n-          (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) &\n-          ~((uintptr_t) markOopDesc::age_mask_in_place);\n+          (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ mark.value()) &\n+          ~((uintptr_t) markWord::age_mask_in_place);\n@@ -871,1 +871,1 @@\n-        } else if ((anticipated_bias_locking_value & markOopDesc::biased_lock_mask_in_place) != 0) {\n+        } else if ((anticipated_bias_locking_value & markWord::biased_lock_mask_in_place) != 0) {\n@@ -873,3 +873,3 @@\n-          markOop header = lockee->klass()->prototype_header();\n-          if (hash != markOopDesc::no_hash) {\n-            header = header->copy_set_hash(hash);\n+          markWord header = lockee->klass()->prototype_header();\n+          if (hash != markWord::no_hash) {\n+            header = header.copy_set_hash(hash);\n@@ -884,3 +884,3 @@\n-          markOop new_header = (markOop) ( (intptr_t) lockee->klass()->prototype_header() | thread_ident);\n-          if (hash != markOopDesc::no_hash) {\n-                new_header = new_header->copy_set_hash(hash);\n+          markWord new_header( (intptr_t) lockee->klass()->prototype_header().value() | thread_ident);\n+          if (hash != markWord::no_hash) {\n+                new_header = new_header.copy_set_hash(hash);\n@@ -898,4 +898,4 @@\n-          markOop header = (markOop) ((uintptr_t) mark & ((uintptr_t)markOopDesc::biased_lock_mask_in_place |\n-                                                          (uintptr_t)markOopDesc::age_mask_in_place | epoch_mask_in_place));\n-          if (hash != markOopDesc::no_hash) {\n-            header = header->copy_set_hash(hash);\n+          markWord header(mark.value() & ((uintptr_t)markWord::biased_lock_mask_in_place |\n+                                          (uintptr_t)markWord::age_mask_in_place | epoch_mask_in_place));\n+          if (hash != markWord::no_hash) {\n+            header = header.copy_set_hash(hash);\n@@ -903,1 +903,1 @@\n-          markOop new_header = (markOop) ((uintptr_t) header | thread_ident);\n+          markWord new_header(header.value() | thread_ident);\n@@ -905,1 +905,1 @@\n-          DEBUG_ONLY(entry->lock()->set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)\n+          DEBUG_ONLY(entry->lock()->set_displaced_header(markWord((uintptr_t) 0xdeaddead));)\n@@ -919,1 +919,1 @@\n-        markOop displaced = lockee->mark()->set_unlocked();\n+        markWord displaced = lockee->mark().set_unlocked();\n@@ -922,1 +922,1 @@\n-        if (call_vm || lockee->cas_set_mark((markOop)entry, displaced) != displaced) {\n+        if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n@@ -924,2 +924,2 @@\n-          if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {\n-            entry->lock()->set_displaced_header(NULL);\n+          if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+            entry->lock()->set_displaced_header(markWord::from_pointer(NULL));\n@@ -1792,1 +1792,1 @@\n-          uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;\n+          uintptr_t epoch_mask_in_place = (uintptr_t)markWord::epoch_mask_in_place;\n@@ -1794,2 +1794,2 @@\n-          markOop mark = lockee->mark();\n-          intptr_t hash = (intptr_t) markOopDesc::no_hash;\n+          markWord mark = lockee->mark();\n+          intptr_t hash = (intptr_t) markWord::no_hash;\n@@ -1797,1 +1797,1 @@\n-          if (mark->has_bias_pattern()) {\n+          if (mark.has_bias_pattern()) {\n@@ -1802,2 +1802,2 @@\n-              (((uintptr_t)lockee->klass()->prototype_header() | thread_ident) ^ (uintptr_t)mark) &\n-              ~((uintptr_t) markOopDesc::age_mask_in_place);\n+              (((uintptr_t)lockee->klass()->prototype_header().value() | thread_ident) ^ mark.value()) &\n+              ~((uintptr_t) markWord::age_mask_in_place);\n@@ -1812,1 +1812,1 @@\n-            else if ((anticipated_bias_locking_value & markOopDesc::biased_lock_mask_in_place) != 0) {\n+            else if ((anticipated_bias_locking_value & markWord::biased_lock_mask_in_place) != 0) {\n@@ -1814,3 +1814,3 @@\n-              markOop header = lockee->klass()->prototype_header();\n-              if (hash != markOopDesc::no_hash) {\n-                header = header->copy_set_hash(hash);\n+              markWord header = lockee->klass()->prototype_header();\n+              if (hash != markWord::no_hash) {\n+                header = header.copy_set_hash(hash);\n@@ -1825,3 +1825,3 @@\n-              markOop new_header = (markOop) ( (intptr_t) lockee->klass()->prototype_header() | thread_ident);\n-              if (hash != markOopDesc::no_hash) {\n-                new_header = new_header->copy_set_hash(hash);\n+              markWord new_header( (intptr_t) lockee->klass()->prototype_header().value() | thread_ident);\n+              if (hash != markWord::no_hash) {\n+                new_header = new_header.copy_set_hash(hash);\n@@ -1840,5 +1840,5 @@\n-              markOop header = (markOop) ((uintptr_t) mark & ((uintptr_t)markOopDesc::biased_lock_mask_in_place |\n-                                                              (uintptr_t)markOopDesc::age_mask_in_place |\n-                                                              epoch_mask_in_place));\n-              if (hash != markOopDesc::no_hash) {\n-                header = header->copy_set_hash(hash);\n+              markWord header(mark.value() & ((uintptr_t)markWord::biased_lock_mask_in_place |\n+                                              (uintptr_t)markWord::age_mask_in_place |\n+                                              epoch_mask_in_place));\n+              if (hash != markWord::no_hash) {\n+                header = header.copy_set_hash(hash);\n@@ -1846,1 +1846,1 @@\n-              markOop new_header = (markOop) ((uintptr_t) header | thread_ident);\n+              markWord new_header(header.value() | thread_ident);\n@@ -1848,1 +1848,1 @@\n-              DEBUG_ONLY(entry->lock()->set_displaced_header((markOop) (uintptr_t) 0xdeaddead);)\n+              DEBUG_ONLY(entry->lock()->set_displaced_header(markWord((uintptr_t) 0xdeaddead));)\n@@ -1862,1 +1862,1 @@\n-            markOop displaced = lockee->mark()->set_unlocked();\n+            markWord displaced = lockee->mark().set_unlocked();\n@@ -1865,1 +1865,1 @@\n-            if (call_vm || lockee->cas_set_mark((markOop)entry, displaced) != displaced) {\n+            if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n@@ -1867,2 +1867,2 @@\n-              if (!call_vm && THREAD->is_lock_owned((address) displaced->clear_lock_bits())) {\n-                entry->lock()->set_displaced_header(NULL);\n+              if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+                entry->lock()->set_displaced_header(markWord::from_pointer(NULL));\n@@ -1891,1 +1891,1 @@\n-            markOop header = lock->displaced_header();\n+            markWord header = lock->displaced_header();\n@@ -1893,1 +1893,1 @@\n-            if (!lockee->mark()->has_bias_pattern()) {\n+            if (!lockee->mark().has_bias_pattern()) {\n@@ -1896,2 +1896,2 @@\n-              if (header != NULL || call_vm) {\n-                markOop old_header = markOopDesc::encode(lock);\n+              if (header.to_pointer() != NULL || call_vm) {\n+                markWord old_header = markWord::encode(lock);\n@@ -2183,1 +2183,1 @@\n-                result->set_mark(markOopDesc::prototype());\n+                result->set_mark(markWord::prototype());\n@@ -3030,1 +3030,1 @@\n-          markOop header = lock->displaced_header();\n+          markWord header = lock->displaced_header();\n@@ -3033,1 +3033,1 @@\n-          if (!lockee->mark()->has_bias_pattern()) {\n+          if (!lockee->mark().has_bias_pattern()) {\n@@ -3035,2 +3035,2 @@\n-            if (header != NULL) {\n-              markOop old_header = markOopDesc::encode(lock);\n+            if (header.to_pointer() != NULL) {\n+              markWord old_header = markWord::encode(lock);\n@@ -3105,1 +3105,1 @@\n-            markOop header = lock->displaced_header();\n+            markWord header = lock->displaced_header();\n@@ -3108,1 +3108,1 @@\n-            if (!rcvr->mark()->has_bias_pattern()) {\n+            if (!rcvr->mark().has_bias_pattern()) {\n@@ -3111,2 +3111,2 @@\n-              if (header != NULL) {\n-                markOop old_header = markOopDesc::encode(lock);\n+              if (header.to_pointer() != NULL) {\n+                markWord old_header = markWord::encode(lock);\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeInterpreter.cpp","additions":84,"deletions":84,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -134,1 +134,1 @@\n-    if (NULL == pointee->mark()) {\n+    if (NULL == pointee->mark().to_pointer()) {\n@@ -151,1 +151,1 @@\n-  assert(NULL == pointee->mark(), \"invariant\");\n+  assert(NULL == pointee->mark().to_pointer(), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/bfsClosure.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  if (NULL == pointee->mark()) {\n+  if (NULL == pointee->mark().to_pointer()) {\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/dfsClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -240,2 +240,2 @@\n-  assert(NULL == sample_object->mark(), \"invariant\");\n-  sample_object->set_mark(markOop(leak_context_edge));\n+  assert(NULL == sample_object->mark().to_pointer(), \"invariant\");\n+  sample_object->set_mark(markWord::from_pointer(leak_context_edge));\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeStore.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  return (const Edge*)edge.pointee()->mark() == &edge;\n+  return (const Edge*)edge.pointee()->mark().to_pointer() == &edge;\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeUtils.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -39,1 +39,1 @@\n-  class ObjectSampleMarkOop : public ResourceObj {\n+  class ObjectSampleMarkWord : public ResourceObj {\n@@ -43,4 +43,4 @@\n-    markOop _mark_oop;\n-    ObjectSampleMarkOop(const oop obj,\n-                        const markOop mark_oop) : _obj(obj),\n-                                                  _mark_oop(mark_oop) {}\n+    markWord _mark_word;\n+    ObjectSampleMarkWord(const oop obj,\n+                         const markWord mark_oop) : _obj(obj),\n+                                                    _mark_word(mark_oop) {}\n@@ -48,1 +48,1 @@\n-    ObjectSampleMarkOop() : _obj(NULL), _mark_oop(NULL) {}\n+    ObjectSampleMarkWord() : _obj(NULL), _mark_word(markWord::zero()) {}\n@@ -51,1 +51,1 @@\n-  GrowableArray<ObjectSampleMarkOop>* _store;\n+  GrowableArray<ObjectSampleMarkWord>* _store;\n@@ -55,1 +55,1 @@\n-       _store(new GrowableArray<ObjectSampleMarkOop>(16)) {}\n+       _store(new GrowableArray<ObjectSampleMarkWord>(16)) {}\n@@ -58,1 +58,1 @@\n-    \/\/ restore the saved, original, markOop for sample objects\n+    \/\/ restore the saved, original, markWord for sample objects\n@@ -60,3 +60,3 @@\n-      ObjectSampleMarkOop sample_oop = _store->pop();\n-      sample_oop._obj->set_mark(sample_oop._mark_oop);\n-      assert(sample_oop._obj->mark() == sample_oop._mark_oop, \"invariant\");\n+      ObjectSampleMarkWord sample_oop = _store->pop();\n+      sample_oop._obj->set_mark(sample_oop._mark_word);\n+      assert(sample_oop._obj->mark() == sample_oop._mark_word, \"invariant\");\n@@ -68,2 +68,2 @@\n-    \/\/ save the original markOop\n-    _store->push(ObjectSampleMarkOop(obj, obj->mark()));\n+    \/\/ save the original markWord\n+    _store->push(ObjectSampleMarkWord(obj, obj->mark()));\n@@ -75,3 +75,3 @@\n-    assert(NULL == markOopDesc::INFLATING(), \"invariant\");\n-    obj->set_mark(markOopDesc::INFLATING());\n-    assert(NULL == obj->mark(), \"invariant\");\n+    assert(NULL == markWord::INFLATING().to_pointer(), \"invariant\");\n+    obj->set_mark(markWord::INFLATING());\n+    assert(NULL == obj->mark().to_pointer(), \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/objectSampleMarker.hpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -114,1 +114,1 @@\n-    edge = (const Edge*)(*object_addr)->mark();\n+    edge = (const Edge*)(*object_addr)->mark().to_pointer();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/eventEmitter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-MarkOopContext::MarkOopContext() : _obj(NULL), _mark_oop(NULL) {}\n+MarkWordContext::MarkWordContext() : _obj(NULL), _mark_word(markWord::zero()) {}\n@@ -32,2 +32,2 @@\n-MarkOopContext::MarkOopContext(const oop obj) : _obj(obj), _mark_oop(obj->mark()) {\n-  assert(_obj->mark() == _mark_oop, \"invariant\");\n+MarkWordContext::MarkWordContext(const oop obj) : _obj(obj), _mark_word(obj->mark()) {\n+  assert(_obj->mark() == _mark_word, \"invariant\");\n@@ -39,3 +39,3 @@\n-  assert(NULL == markOopDesc::INFLATING(), \"invariant\");\n-  _obj->set_mark(markOopDesc::INFLATING());\n-  assert(NULL == obj->mark(), \"invariant\");\n+  assert(markWord::zero() == markWord::INFLATING(), \"invariant\");\n+  _obj->set_mark(markWord::INFLATING());\n+  assert(markWord::zero() == obj->mark(), \"invariant\");\n@@ -44,1 +44,1 @@\n-MarkOopContext::~MarkOopContext() {\n+MarkWordContext::~MarkWordContext() {\n@@ -46,2 +46,2 @@\n-    _obj->set_mark(_mark_oop);\n-    assert(_obj->mark() == _mark_oop, \"invariant\");\n+    _obj->set_mark(_mark_word);\n+    assert(_obj->mark() == _mark_word, \"invariant\");\n@@ -51,2 +51,2 @@\n-MarkOopContext::MarkOopContext(const MarkOopContext& rhs) : _obj(NULL), _mark_oop(NULL) {\n-  swap(const_cast<MarkOopContext&>(rhs));\n+MarkWordContext::MarkWordContext(const MarkWordContext& rhs) : _obj(NULL), _mark_word(markWord::zero()) {\n+  swap(const_cast<MarkWordContext&>(rhs));\n@@ -55,1 +55,1 @@\n-void MarkOopContext::operator=(MarkOopContext rhs) {\n+void MarkWordContext::operator=(MarkWordContext rhs) {\n@@ -59,1 +59,1 @@\n-void MarkOopContext::swap(MarkOopContext& rhs) {\n+void MarkWordContext::swap(MarkWordContext& rhs) {\n@@ -61,1 +61,1 @@\n-  markOop temp_mark_oop = rhs._mark_oop;\n+  markWord temp_mark_word = rhs._mark_word;\n@@ -63,1 +63,1 @@\n-  rhs._mark_oop = _mark_oop;\n+  rhs._mark_word = _mark_word;\n@@ -65,1 +65,1 @@\n-  _mark_oop = temp_mark_oop;\n+  _mark_word = temp_mark_word;\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/saveRestore.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -81,1 +81,1 @@\n-class MarkOopContext {\n+class MarkWordContext {\n@@ -84,2 +84,2 @@\n-  markOop _mark_oop;\n-  void swap(MarkOopContext& rhs);\n+  markWord _mark_word;\n+  void swap(MarkWordContext& rhs);\n@@ -87,5 +87,5 @@\n-  MarkOopContext();\n-  MarkOopContext(const oop obj);\n-  MarkOopContext(const MarkOopContext& rhs);\n-  void operator=(MarkOopContext rhs);\n-  ~MarkOopContext();\n+  MarkWordContext();\n+  MarkWordContext(const oop obj);\n+  MarkWordContext(const MarkWordContext& rhs);\n+  void operator=(MarkWordContext rhs);\n+  ~MarkWordContext();\n@@ -94,1 +94,1 @@\n-typedef SaveRestore<oop, ContextStore<oop, MarkOopContext> > SaveRestoreMarkOops;\n+typedef SaveRestore<oop, ContextStore<oop, MarkWordContext> > SaveRestoreMarkWord;\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/saveRestore.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-  volatile_nonstatic_field(BasicLock,          _displaced_header,                      markOop)                                      \\\n+  volatile_nonstatic_field(BasicLock,          _displaced_header,                      markWord)                                     \\\n@@ -203,1 +203,1 @@\n-  nonstatic_field(Klass,                       _prototype_header,                             markOop)                               \\\n+  nonstatic_field(Klass,                       _prototype_header,                             markWord)                              \\\n@@ -261,1 +261,1 @@\n-  volatile_nonstatic_field(oopDesc,            _mark,                                         markOop)                               \\\n+  volatile_nonstatic_field(oopDesc,            _mark,                                         markWord)                              \\\n@@ -570,1 +570,1 @@\n-  declare_constant(markOopDesc::no_hash)                                  \\\n+  declare_constant(markWord::no_hash)                                     \\\n@@ -602,1 +602,1 @@\n-  declare_constant(markOopDesc::hash_shift)                               \\\n+  declare_constant(markWord::hash_shift)                                  \\\n@@ -604,5 +604,5 @@\n-  declare_constant(markOopDesc::biased_lock_mask_in_place)                \\\n-  declare_constant(markOopDesc::age_mask_in_place)                        \\\n-  declare_constant(markOopDesc::epoch_mask_in_place)                      \\\n-  declare_constant(markOopDesc::hash_mask)                                \\\n-  declare_constant(markOopDesc::hash_mask_in_place)                       \\\n+  declare_constant(markWord::biased_lock_mask_in_place)                   \\\n+  declare_constant(markWord::age_mask_in_place)                           \\\n+  declare_constant(markWord::epoch_mask_in_place)                         \\\n+  declare_constant(markWord::hash_mask)                                   \\\n+  declare_constant(markWord::hash_mask_in_place)                          \\\n@@ -610,2 +610,2 @@\n-  declare_constant(markOopDesc::unlocked_value)                           \\\n-  declare_constant(markOopDesc::biased_lock_pattern)                      \\\n+  declare_constant(markWord::unlocked_value)                              \\\n+  declare_constant(markWord::biased_lock_pattern)                         \\\n@@ -613,2 +613,2 @@\n-  declare_constant(markOopDesc::no_hash_in_place)                         \\\n-  declare_constant(markOopDesc::no_lock_in_place)                         \\\n+  declare_constant(markWord::no_hash_in_place)                            \\\n+  declare_constant(markWord::no_lock_in_place)                            \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1874,1 +1874,1 @@\n-  assert(!p->mark()->has_bias_pattern(),\n+  assert(!p->mark().has_bias_pattern(),\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1313,1 +1313,1 @@\n-  return markOopDesc::lock_mask_in_place;\n+  return markWord::lock_mask_in_place;\n@@ -1318,1 +1318,1 @@\n-  intptr_t bits = (intptr_t)markOopDesc::prototype();\n+  intptr_t bits = (intptr_t)markWord::prototype().value();\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -631,1 +631,1 @@\n-  assert(markOopDesc::encode_pointer_as_mark(_base)->decode_pointer() == _base,\n+  assert(markWord::encode_pointer_as_mark(_base).decode_pointer() == _base,\n@@ -633,1 +633,1 @@\n-  assert(markOopDesc::encode_pointer_as_mark(&_base[size])->decode_pointer() == &_base[size],\n+  assert(markWord::encode_pointer_as_mark(&_base[size]).decode_pointer() == &_base[size],\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-\/\/  markOop\n+\/\/  markWord\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-                           _prototype_header(markOopDesc::prototype()),\n+                           _prototype_header(markWord::prototype()),\n@@ -685,1 +685,1 @@\n-     obj->mark()->print_on(st);\n+     obj->mark().print_on(st);\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/markWord.hpp\"\n@@ -162,1 +163,1 @@\n-  markOop  _prototype_header;   \/\/ Used when biased locking is both enabled and disabled for this type\n+  markWord  _prototype_header;   \/\/ Used when biased locking is both enabled and disabled for this type\n@@ -631,1 +632,1 @@\n-  \/\/ prototype markOop. If biased locking is enabled it may further be\n+  \/\/ prototype markWord. If biased locking is enabled it may further be\n@@ -633,1 +634,1 @@\n-  markOop prototype_header() const      { return _prototype_header; }\n+  markWord prototype_header() const      { return _prototype_header; }\n@@ -642,1 +643,1 @@\n-  inline void set_prototype_header(markOop header);\n+  inline void set_prototype_header(markWord header);\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -32,2 +32,2 @@\n-inline void Klass::set_prototype_header(markOop header) {\n-  assert(!header->has_bias_pattern() || is_instance_klass(), \"biased locking currently only supported for Java instances\");\n+inline void Klass::set_prototype_header(markWord header) {\n+  assert(!header.has_bias_pattern() || is_instance_klass(), \"biased locking currently only supported for Java instances\");\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,398 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_VM_OOPS_MARKOOP_HPP\n-#define SHARE_VM_OOPS_MARKOOP_HPP\n-\n-#include \"oops\/oop.hpp\"\n-\n-\/\/ The markOop describes the header of an object.\n-\/\/\n-\/\/ Note that the mark is not a real oop but just a word.\n-\/\/ It is placed in the oop hierarchy for historical reasons.\n-\/\/\n-\/\/ Bit-format of an object header (most significant first, big endian layout below):\n-\/\/\n-\/\/  32 bits:\n-\/\/  --------\n-\/\/             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)\n-\/\/             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)\n-\/\/             size:32 ------------------------------------------>| (CMS free block)\n-\/\/             PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS promoted object)\n-\/\/\n-\/\/  64 bits:\n-\/\/  --------\n-\/\/  unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)\n-\/\/  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)\n-\/\/  PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object)\n-\/\/  size:64 ----------------------------------------------------->| (CMS free block)\n-\/\/\n-\/\/  unused:25 hash:31 -->| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && normal object)\n-\/\/  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && biased object)\n-\/\/  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 ----->| (COOPs && CMS promoted object)\n-\/\/  unused:21 size:35 -->| cms_free:1 unused:7 ------------------>| (COOPs && CMS free block)\n-\/\/\n-\/\/  - hash contains the identity hash value: largest value is\n-\/\/    31 bits, see os::random().  Also, 64-bit vm's require\n-\/\/    a hash value no bigger than 32 bits because they will not\n-\/\/    properly generate a mask larger than that: see library_call.cpp\n-\/\/    and c1_CodePatterns_sparc.cpp.\n-\/\/\n-\/\/  - the biased lock pattern is used to bias a lock toward a given\n-\/\/    thread. When this pattern is set in the low three bits, the lock\n-\/\/    is either biased toward a given thread or \"anonymously\" biased,\n-\/\/    indicating that it is possible for it to be biased. When the\n-\/\/    lock is biased toward a given thread, locking and unlocking can\n-\/\/    be performed by that thread without using atomic operations.\n-\/\/    When a lock's bias is revoked, it reverts back to the normal\n-\/\/    locking scheme described below.\n-\/\/\n-\/\/    Note that we are overloading the meaning of the \"unlocked\" state\n-\/\/    of the header. Because we steal a bit from the age we can\n-\/\/    guarantee that the bias pattern will never be seen for a truly\n-\/\/    unlocked object.\n-\/\/\n-\/\/    Note also that the biased state contains the age bits normally\n-\/\/    contained in the object header. Large increases in scavenge\n-\/\/    times were seen when these bits were absent and an arbitrary age\n-\/\/    assigned to all biased objects, because they tended to consume a\n-\/\/    significant fraction of the eden semispaces and were not\n-\/\/    promoted promptly, causing an increase in the amount of copying\n-\/\/    performed. The runtime system aligns all JavaThread* pointers to\n-\/\/    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))\n-\/\/    to make room for the age bits & the epoch bits (used in support of\n-\/\/    biased locking), and for the CMS \"freeness\" bit in the 64bVM (+COOPs).\n-\/\/\n-\/\/    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread\n-\/\/    [0           | epoch | age | 1 | 01]       lock is anonymously biased\n-\/\/\n-\/\/  - the two lock bits are used to describe three states: locked\/unlocked and monitor.\n-\/\/\n-\/\/    [ptr             | 00]  locked             ptr points to real header on stack\n-\/\/    [header      | 0 | 01]  unlocked           regular object header\n-\/\/    [ptr             | 10]  monitor            inflated lock (header is wapped out)\n-\/\/    [ptr             | 11]  marked             used by markSweep to mark an object\n-\/\/                                               not valid at any other time\n-\/\/\n-\/\/    We assume that stack\/thread pointers have the lowest two bits cleared.\n-\n-class BasicLock;\n-class ObjectMonitor;\n-class JavaThread;\n-\n-class markOopDesc: public oopDesc {\n- private:\n-  \/\/ Conversion\n-  uintptr_t value() const { return (uintptr_t) this; }\n-\n- public:\n-  \/\/ Constants\n-  enum { age_bits                 = 4,\n-         lock_bits                = 2,\n-         biased_lock_bits         = 1,\n-         max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,\n-         hash_bits                = max_hash_bits > 31 ? 31 : max_hash_bits,\n-         cms_bits                 = LP64_ONLY(1) NOT_LP64(0),\n-         epoch_bits               = 2\n-  };\n-\n-  \/\/ The biased locking code currently requires that the age bits be\n-  \/\/ contiguous to the lock bits.\n-  enum { lock_shift               = 0,\n-         biased_lock_shift        = lock_bits,\n-         age_shift                = lock_bits + biased_lock_bits,\n-         cms_shift                = age_shift + age_bits,\n-         hash_shift               = cms_shift + cms_bits,\n-         epoch_shift              = hash_shift\n-  };\n-\n-  enum { lock_mask                = right_n_bits(lock_bits),\n-         lock_mask_in_place       = lock_mask << lock_shift,\n-         biased_lock_mask         = right_n_bits(lock_bits + biased_lock_bits),\n-         biased_lock_mask_in_place= biased_lock_mask << lock_shift,\n-         biased_lock_bit_in_place = 1 << biased_lock_shift,\n-         age_mask                 = right_n_bits(age_bits),\n-         age_mask_in_place        = age_mask << age_shift,\n-         epoch_mask               = right_n_bits(epoch_bits),\n-         epoch_mask_in_place      = epoch_mask << epoch_shift,\n-         cms_mask                 = right_n_bits(cms_bits),\n-         cms_mask_in_place        = cms_mask << cms_shift\n-  };\n-\n-  const static uintptr_t hash_mask = right_n_bits(hash_bits);\n-  const static uintptr_t hash_mask_in_place = hash_mask << hash_shift;\n-\n-  \/\/ Alignment of JavaThread pointers encoded in object header required by biased locking\n-  enum { biased_lock_alignment    = 2 << (epoch_shift + epoch_bits)\n-  };\n-\n-  enum { locked_value             = 0,\n-         unlocked_value           = 1,\n-         monitor_value            = 2,\n-         marked_value             = 3,\n-         biased_lock_pattern      = 5\n-  };\n-\n-  enum { no_hash                  = 0 };  \/\/ no hash value assigned\n-\n-  enum { no_hash_in_place         = (address_word)no_hash << hash_shift,\n-         no_lock_in_place         = unlocked_value\n-  };\n-\n-  enum { max_age                  = age_mask };\n-\n-  enum { max_bias_epoch           = epoch_mask };\n-\n-  \/\/ Biased Locking accessors.\n-  \/\/ These must be checked by all code which calls into the\n-  \/\/ ObjectSynchronizer and other code. The biasing is not understood\n-  \/\/ by the lower-level CAS-based locking code, although the runtime\n-  \/\/ fixes up biased locks to be compatible with it when a bias is\n-  \/\/ revoked.\n-  bool has_bias_pattern() const {\n-    return (mask_bits(value(), biased_lock_mask_in_place) == biased_lock_pattern);\n-  }\n-  JavaThread* biased_locker() const {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    return (JavaThread*) ((intptr_t) (mask_bits(value(), ~(biased_lock_mask_in_place | age_mask_in_place | epoch_mask_in_place))));\n-  }\n-  \/\/ Indicates that the mark has the bias bit set but that it has not\n-  \/\/ yet been biased toward a particular thread\n-  bool is_biased_anonymously() const {\n-    return (has_bias_pattern() && (biased_locker() == NULL));\n-  }\n-  \/\/ Indicates epoch in which this bias was acquired. If the epoch\n-  \/\/ changes due to too many bias revocations occurring, the biases\n-  \/\/ from the previous epochs are all considered invalid.\n-  int bias_epoch() const {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    return (mask_bits(value(), epoch_mask_in_place) >> epoch_shift);\n-  }\n-  markOop set_bias_epoch(int epoch) {\n-    assert(has_bias_pattern(), \"should not call this otherwise\");\n-    assert((epoch & (~epoch_mask)) == 0, \"epoch overflow\");\n-    return markOop(mask_bits(value(), ~epoch_mask_in_place) | (epoch << epoch_shift));\n-  }\n-  markOop incr_bias_epoch() {\n-    return set_bias_epoch((1 + bias_epoch()) & epoch_mask);\n-  }\n-  \/\/ Prototype mark for initialization\n-  static markOop biased_locking_prototype() {\n-    return markOop( biased_lock_pattern );\n-  }\n-\n-  \/\/ lock accessors (note that these assume lock_shift == 0)\n-  bool is_locked()   const {\n-    return (mask_bits(value(), lock_mask_in_place) != unlocked_value);\n-  }\n-  bool is_unlocked() const {\n-    return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value);\n-  }\n-  bool is_marked()   const {\n-    return (mask_bits(value(), lock_mask_in_place) == marked_value);\n-  }\n-  bool is_neutral()  const { return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value); }\n-\n-  \/\/ Special temporary state of the markOop while being inflated.\n-  \/\/ Code that looks at mark outside a lock need to take this into account.\n-  bool is_being_inflated() const { return (value() == 0); }\n-\n-  \/\/ Distinguished markword value - used when inflating over\n-  \/\/ an existing stacklock.  0 indicates the markword is \"BUSY\".\n-  \/\/ Lockword mutators that use a LD...CAS idiom should always\n-  \/\/ check for and avoid overwriting a 0 value installed by some\n-  \/\/ other thread.  (They should spin or block instead.  The 0 value\n-  \/\/ is transient and *should* be short-lived).\n-  static markOop INFLATING() { return (markOop) 0; }    \/\/ inflate-in-progress\n-\n-  \/\/ Should this header be preserved during GC?\n-  inline bool must_be_preserved(oop obj_containing_mark) const;\n-  inline bool must_be_preserved_with_bias(oop obj_containing_mark) const;\n-\n-  \/\/ Should this header (including its age bits) be preserved in the\n-  \/\/ case of a promotion failure during scavenge?\n-  \/\/ Note that we special case this situation. We want to avoid\n-  \/\/ calling BiasedLocking::preserve_marks()\/restore_marks() (which\n-  \/\/ decrease the number of mark words that need to be preserved\n-  \/\/ during GC) during each scavenge. During scavenges in which there\n-  \/\/ is no promotion failure, we actually don't need to call the above\n-  \/\/ routines at all, since we don't mutate and re-initialize the\n-  \/\/ marks of promoted objects using init_mark(). However, during\n-  \/\/ scavenges which result in promotion failure, we do re-initialize\n-  \/\/ the mark words of objects, meaning that we should have called\n-  \/\/ these mark word preservation routines. Currently there's no good\n-  \/\/ place in which to call them in any of the scavengers (although\n-  \/\/ guarded by appropriate locks we could make one), but the\n-  \/\/ observation is that promotion failures are quite rare and\n-  \/\/ reducing the number of mark words preserved during them isn't a\n-  \/\/ high priority.\n-  inline bool must_be_preserved_for_promotion_failure(oop obj_containing_mark) const;\n-  inline bool must_be_preserved_with_bias_for_promotion_failure(oop obj_containing_mark) const;\n-\n-  \/\/ Should this header be preserved during a scavenge where CMS is\n-  \/\/ the old generation?\n-  \/\/ (This is basically the same body as must_be_preserved_for_promotion_failure(),\n-  \/\/ but takes the Klass* as argument instead)\n-  inline bool must_be_preserved_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const;\n-  inline bool must_be_preserved_with_bias_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const;\n-\n-  \/\/ WARNING: The following routines are used EXCLUSIVELY by\n-  \/\/ synchronization functions. They are not really gc safe.\n-  \/\/ They must get updated if markOop layout get changed.\n-  markOop set_unlocked() const {\n-    return markOop(value() | unlocked_value);\n-  }\n-  bool has_locker() const {\n-    return ((value() & lock_mask_in_place) == locked_value);\n-  }\n-  BasicLock* locker() const {\n-    assert(has_locker(), \"check\");\n-    return (BasicLock*) value();\n-  }\n-  bool has_monitor() const {\n-    return ((value() & monitor_value) != 0);\n-  }\n-  ObjectMonitor* monitor() const {\n-    assert(has_monitor(), \"check\");\n-    \/\/ Use xor instead of &~ to provide one extra tag-bit check.\n-    return (ObjectMonitor*) (value() ^ monitor_value);\n-  }\n-  bool has_displaced_mark_helper() const {\n-    return ((value() & unlocked_value) == 0);\n-  }\n-  markOop displaced_mark_helper() const {\n-    assert(has_displaced_mark_helper(), \"check\");\n-    intptr_t ptr = (value() & ~monitor_value);\n-    return *(markOop*)ptr;\n-  }\n-  void set_displaced_mark_helper(markOop m) const {\n-    assert(has_displaced_mark_helper(), \"check\");\n-    intptr_t ptr = (value() & ~monitor_value);\n-    *(markOop*)ptr = m;\n-  }\n-  markOop copy_set_hash(intptr_t hash) const {\n-    intptr_t tmp = value() & (~hash_mask_in_place);\n-    tmp |= ((hash & hash_mask) << hash_shift);\n-    return (markOop)tmp;\n-  }\n-  \/\/ it is only used to be stored into BasicLock as the\n-  \/\/ indicator that the lock is using heavyweight monitor\n-  static markOop unused_mark() {\n-    return (markOop) marked_value;\n-  }\n-  \/\/ the following two functions create the markOop to be\n-  \/\/ stored into object header, it encodes monitor info\n-  static markOop encode(BasicLock* lock) {\n-    return (markOop) lock;\n-  }\n-  static markOop encode(ObjectMonitor* monitor) {\n-    intptr_t tmp = (intptr_t) monitor;\n-    return (markOop) (tmp | monitor_value);\n-  }\n-  static markOop encode(JavaThread* thread, uint age, int bias_epoch) {\n-    intptr_t tmp = (intptr_t) thread;\n-    assert(UseBiasedLocking && ((tmp & (epoch_mask_in_place | age_mask_in_place | biased_lock_mask_in_place)) == 0), \"misaligned JavaThread pointer\");\n-    assert(age <= max_age, \"age too large\");\n-    assert(bias_epoch <= max_bias_epoch, \"bias epoch too large\");\n-    return (markOop) (tmp | (bias_epoch << epoch_shift) | (age << age_shift) | biased_lock_pattern);\n-  }\n-\n-  \/\/ used to encode pointers during GC\n-  markOop clear_lock_bits() { return markOop(value() & ~lock_mask_in_place); }\n-\n-  \/\/ age operations\n-  markOop set_marked()   { return markOop((value() & ~lock_mask_in_place) | marked_value); }\n-  markOop set_unmarked() { return markOop((value() & ~lock_mask_in_place) | unlocked_value); }\n-\n-  uint    age()               const { return mask_bits(value() >> age_shift, age_mask); }\n-  markOop set_age(uint v) const {\n-    assert((v & ~age_mask) == 0, \"shouldn't overflow age field\");\n-    return markOop((value() & ~age_mask_in_place) | (((uintptr_t)v & age_mask) << age_shift));\n-  }\n-  markOop incr_age()          const { return age() == max_age ? markOop(this) : set_age(age() + 1); }\n-\n-  \/\/ hash operations\n-  intptr_t hash() const {\n-    return mask_bits(value() >> hash_shift, hash_mask);\n-  }\n-\n-  bool has_no_hash() const {\n-    return hash() == no_hash;\n-  }\n-\n-  \/\/ Prototype mark for initialization\n-  static markOop prototype() {\n-    return markOop( no_hash_in_place | no_lock_in_place );\n-  }\n-\n-  \/\/ Helper function for restoration of unmarked mark oops during GC\n-  static inline markOop prototype_for_object(oop obj);\n-\n-  \/\/ Debugging\n-  void print_on(outputStream* st) const;\n-\n-  \/\/ Prepare address of oop for placement into mark\n-  inline static markOop encode_pointer_as_mark(void* p) { return markOop(p)->set_marked(); }\n-\n-  \/\/ Recover address of oop from encoded form used in mark\n-  inline void* decode_pointer() { if (UseBiasedLocking && has_bias_pattern()) return NULL; return clear_lock_bits(); }\n-\n-  \/\/ These markOops indicate cms free chunk blocks and not objects.\n-  \/\/ In 64 bit, the markOop is set to distinguish them from oops.\n-  \/\/ These are defined in 32 bit mode for vmStructs.\n-  const static uintptr_t cms_free_chunk_pattern  = 0x1;\n-\n-  \/\/ Constants for the size field.\n-  enum { size_shift                = cms_shift + cms_bits,\n-         size_bits                 = 35    \/\/ need for compressed oops 32G\n-       };\n-  \/\/ These values are too big for Win64\n-  const static uintptr_t size_mask = LP64_ONLY(right_n_bits(size_bits))\n-                                     NOT_LP64(0);\n-  const static uintptr_t size_mask_in_place =\n-                                     (address_word)size_mask << size_shift;\n-\n-#ifdef _LP64\n-  static markOop cms_free_prototype() {\n-    return markOop(((intptr_t)prototype() & ~cms_mask_in_place) |\n-                   ((cms_free_chunk_pattern & cms_mask) << cms_shift));\n-  }\n-  uintptr_t cms_encoding() const {\n-    return mask_bits(value() >> cms_shift, cms_mask);\n-  }\n-  bool is_cms_free_chunk() const {\n-    return is_neutral() &&\n-           (cms_encoding() & cms_free_chunk_pattern) == cms_free_chunk_pattern;\n-  }\n-\n-  size_t get_size() const       { return (size_t)(value() >> size_shift); }\n-  static markOop set_size_and_free(size_t size) {\n-    assert((size & ~size_mask) == 0, \"shouldn't overflow size field\");\n-    return markOop(((intptr_t)cms_free_prototype() & ~size_mask_in_place) |\n-                   (((intptr_t)size & size_mask) << size_shift));\n-  }\n-#endif \/\/ _LP64\n-};\n-\n-#endif \/\/ SHARE_VM_OOPS_MARKOOP_HPP\n","filename":"src\/hotspot\/share\/oops\/markOop.hpp","additions":0,"deletions":398,"binary":false,"changes":398,"status":"deleted"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2006, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_VM_OOPS_MARKOOP_INLINE_HPP\n-#define SHARE_VM_OOPS_MARKOOP_INLINE_HPP\n-\n-#include \"oops\/klass.hpp\"\n-#include \"oops\/markOop.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/globals.hpp\"\n-\n-\/\/ Should this header be preserved during GC (when biased locking is enabled)?\n-inline bool markOopDesc::must_be_preserved_with_bias(oop obj_containing_mark) const {\n-  assert(UseBiasedLocking, \"unexpected\");\n-  if (has_bias_pattern()) {\n-    \/\/ Will reset bias at end of collection\n-    \/\/ Mark words of biased and currently locked objects are preserved separately\n-    return false;\n-  }\n-  markOop prototype_header = prototype_for_object(obj_containing_mark);\n-  if (prototype_header->has_bias_pattern()) {\n-    \/\/ Individual instance which has its bias revoked; must return\n-    \/\/ true for correctness\n-    return true;\n-  }\n-  return (!is_unlocked() || !has_no_hash());\n-}\n-\n-\/\/ Should this header be preserved during GC?\n-inline bool markOopDesc::must_be_preserved(oop obj_containing_mark) const {\n-  if (!UseBiasedLocking)\n-    return (!is_unlocked() || !has_no_hash());\n-  return must_be_preserved_with_bias(obj_containing_mark);\n-}\n-\n-\/\/ Should this header be preserved in the case of a promotion failure\n-\/\/ during scavenge (when biased locking is enabled)?\n-inline bool markOopDesc::must_be_preserved_with_bias_for_promotion_failure(oop obj_containing_mark) const {\n-  assert(UseBiasedLocking, \"unexpected\");\n-  \/\/ We don't explicitly save off the mark words of biased and\n-  \/\/ currently-locked objects during scavenges, so if during a\n-  \/\/ promotion failure we encounter either a biased mark word or a\n-  \/\/ klass which still has a biasable prototype header, we have to\n-  \/\/ preserve the mark word. This results in oversaving, but promotion\n-  \/\/ failures are rare, and this avoids adding more complex logic to\n-  \/\/ the scavengers to call new variants of\n-  \/\/ BiasedLocking::preserve_marks() \/ restore_marks() in the middle\n-  \/\/ of a scavenge when a promotion failure has first been detected.\n-  if (has_bias_pattern() ||\n-      prototype_for_object(obj_containing_mark)->has_bias_pattern()) {\n-    return true;\n-  }\n-  return (!is_unlocked() || !has_no_hash());\n-}\n-\n-\/\/ Should this header be preserved in the case of a promotion failure\n-\/\/ during scavenge?\n-inline bool markOopDesc::must_be_preserved_for_promotion_failure(oop obj_containing_mark) const {\n-  if (!UseBiasedLocking)\n-    return (!is_unlocked() || !has_no_hash());\n-  return must_be_preserved_with_bias_for_promotion_failure(obj_containing_mark);\n-}\n-\n-\n-\/\/ Same as must_be_preserved_with_bias_for_promotion_failure() except that\n-\/\/ it takes a Klass* argument, instead of the object of which this is the mark word.\n-inline bool markOopDesc::must_be_preserved_with_bias_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const {\n-  assert(UseBiasedLocking, \"unexpected\");\n-  \/\/ CMS scavenges preserve mark words in similar fashion to promotion failures; see above\n-  if (has_bias_pattern() ||\n-      klass_of_obj_containing_mark->prototype_header()->has_bias_pattern()) {\n-    return true;\n-  }\n-  return (!is_unlocked() || !has_no_hash());\n-}\n-\n-\/\/ Same as must_be_preserved_for_promotion_failure() except that\n-\/\/ it takes a Klass* argument, instead of the object of which this is the mark word.\n-inline bool markOopDesc::must_be_preserved_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const {\n-  if (!UseBiasedLocking)\n-    return (!is_unlocked() || !has_no_hash());\n-  return must_be_preserved_with_bias_for_cms_scavenge(klass_of_obj_containing_mark);\n-}\n-\n-inline markOop markOopDesc::prototype_for_object(oop obj) {\n-#ifdef ASSERT\n-  markOop prototype_header = obj->klass()->prototype_header();\n-  assert(prototype_header == prototype() || prototype_header->has_bias_pattern(), \"corrupt prototype header\");\n-#endif\n-  return obj->klass()->prototype_header();\n-}\n-\n-#endif \/\/ SHARE_VM_OOPS_MARKOOP_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/markOop.inline.hpp","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -30,1 +30,1 @@\n-void markOopDesc::print_on(outputStream* st) const {\n+void markWord::print_on(outputStream* st) const {\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/hotspot\/share\/oops\/markOop.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,433 @@\n+\/*\n+ * Copyright (c) 1997, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_OOPS_MARKWORD_HPP\n+#define SHARE_VM_OOPS_MARKWORD_HPP\n+\n+#include \"metaprogramming\/integralConstant.hpp\"\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+\/\/ The markWord describes the header of an object.\n+\/\/\n+\/\/ Bit-format of an object header (most significant first, big endian layout below):\n+\/\/\n+\/\/  32 bits:\n+\/\/  --------\n+\/\/             hash:25 ------------>| age:4    biased_lock:1 lock:2 (normal object)\n+\/\/             JavaThread*:23 epoch:2 age:4    biased_lock:1 lock:2 (biased object)\n+\/\/             size:32 ------------------------------------------>| (CMS free block)\n+\/\/             PromotedObject*:29 ---------->| promo_bits:3 ----->| (CMS promoted object)\n+\/\/\n+\/\/  64 bits:\n+\/\/  --------\n+\/\/  unused:25 hash:31 -->| unused:1   age:4    biased_lock:1 lock:2 (normal object)\n+\/\/  JavaThread*:54 epoch:2 unused:1   age:4    biased_lock:1 lock:2 (biased object)\n+\/\/  PromotedObject*:61 --------------------->| promo_bits:3 ----->| (CMS promoted object)\n+\/\/  size:64 ----------------------------------------------------->| (CMS free block)\n+\/\/\n+\/\/  unused:25 hash:31 -->| cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && normal object)\n+\/\/  JavaThread*:54 epoch:2 cms_free:1 age:4    biased_lock:1 lock:2 (COOPs && biased object)\n+\/\/  narrowOop:32 unused:24 cms_free:1 unused:4 promo_bits:3 ----->| (COOPs && CMS promoted object)\n+\/\/  unused:21 size:35 -->| cms_free:1 unused:7 ------------------>| (COOPs && CMS free block)\n+\/\/\n+\/\/  - hash contains the identity hash value: largest value is\n+\/\/    31 bits, see os::random().  Also, 64-bit vm's require\n+\/\/    a hash value no bigger than 32 bits because they will not\n+\/\/    properly generate a mask larger than that: see library_call.cpp\n+\/\/    and c1_CodePatterns_sparc.cpp.\n+\/\/\n+\/\/  - the biased lock pattern is used to bias a lock toward a given\n+\/\/    thread. When this pattern is set in the low three bits, the lock\n+\/\/    is either biased toward a given thread or \"anonymously\" biased,\n+\/\/    indicating that it is possible for it to be biased. When the\n+\/\/    lock is biased toward a given thread, locking and unlocking can\n+\/\/    be performed by that thread without using atomic operations.\n+\/\/    When a lock's bias is revoked, it reverts back to the normal\n+\/\/    locking scheme described below.\n+\/\/\n+\/\/    Note that we are overloading the meaning of the \"unlocked\" state\n+\/\/    of the header. Because we steal a bit from the age we can\n+\/\/    guarantee that the bias pattern will never be seen for a truly\n+\/\/    unlocked object.\n+\/\/\n+\/\/    Note also that the biased state contains the age bits normally\n+\/\/    contained in the object header. Large increases in scavenge\n+\/\/    times were seen when these bits were absent and an arbitrary age\n+\/\/    assigned to all biased objects, because they tended to consume a\n+\/\/    significant fraction of the eden semispaces and were not\n+\/\/    promoted promptly, causing an increase in the amount of copying\n+\/\/    performed. The runtime system aligns all JavaThread* pointers to\n+\/\/    a very large value (currently 128 bytes (32bVM) or 256 bytes (64bVM))\n+\/\/    to make room for the age bits & the epoch bits (used in support of\n+\/\/    biased locking), and for the CMS \"freeness\" bit in the 64bVM (+COOPs).\n+\/\/\n+\/\/    [JavaThread* | epoch | age | 1 | 01]       lock is biased toward given thread\n+\/\/    [0           | epoch | age | 1 | 01]       lock is anonymously biased\n+\/\/\n+\/\/  - the two lock bits are used to describe three states: locked\/unlocked and monitor.\n+\/\/\n+\/\/    [ptr             | 00]  locked             ptr points to real header on stack\n+\/\/    [header      | 0 | 01]  unlocked           regular object header\n+\/\/    [ptr             | 10]  monitor            inflated lock (header is wapped out)\n+\/\/    [ptr             | 11]  marked             used by markSweep to mark an object\n+\/\/                                               not valid at any other time\n+\/\/\n+\/\/    We assume that stack\/thread pointers have the lowest two bits cleared.\n+\n+class BasicLock;\n+class ObjectMonitor;\n+class JavaThread;\n+\n+class markWord {\n+ private:\n+  uintptr_t _value;\n+\n+ public:\n+  \/\/ Constants\n+  enum { age_bits                 = 4,\n+         lock_bits                = 2,\n+         biased_lock_bits         = 1,\n+         max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,\n+         hash_bits                = max_hash_bits > 31 ? 31 : max_hash_bits,\n+         cms_bits                 = LP64_ONLY(1) NOT_LP64(0),\n+         epoch_bits               = 2\n+  };\n+\n+  explicit markWord(uintptr_t value) : _value(value) {}\n+\n+  markWord() { \/* uninitialized *\/}\n+\n+  \/\/ It is critical for performance that this class be trivially\n+  \/\/ destructable, copyable, and assignable.\n+\n+  static markWord from_pointer(void* ptr) {\n+    return markWord((uintptr_t)ptr);\n+  }\n+  void* to_pointer() const {\n+    return (void*)_value;\n+  }\n+\n+  bool operator==(const markWord& other) const {\n+    return _value == other._value;\n+  }\n+  bool operator!=(const markWord& other) const {\n+    return !operator==(other);\n+  }\n+\n+  \/\/ Conversion\n+  uintptr_t value() const { return _value; }\n+\n+  \/\/ The biased locking code currently requires that the age bits be\n+  \/\/ contiguous to the lock bits.\n+  enum { lock_shift               = 0,\n+         biased_lock_shift        = lock_bits,\n+         age_shift                = lock_bits + biased_lock_bits,\n+         cms_shift                = age_shift + age_bits,\n+         hash_shift               = cms_shift + cms_bits,\n+         epoch_shift              = hash_shift\n+  };\n+\n+  enum { lock_mask                = right_n_bits(lock_bits),\n+         lock_mask_in_place       = lock_mask << lock_shift,\n+         biased_lock_mask         = right_n_bits(lock_bits + biased_lock_bits),\n+         biased_lock_mask_in_place= biased_lock_mask << lock_shift,\n+         biased_lock_bit_in_place = 1 << biased_lock_shift,\n+         age_mask                 = right_n_bits(age_bits),\n+         age_mask_in_place        = age_mask << age_shift,\n+         epoch_mask               = right_n_bits(epoch_bits),\n+         epoch_mask_in_place      = epoch_mask << epoch_shift,\n+         cms_mask                 = right_n_bits(cms_bits),\n+         cms_mask_in_place        = cms_mask << cms_shift\n+  };\n+\n+  const static uintptr_t hash_mask = right_n_bits(hash_bits);\n+  const static uintptr_t hash_mask_in_place = hash_mask << hash_shift;\n+\n+  \/\/ Alignment of JavaThread pointers encoded in object header required by biased locking\n+  enum { biased_lock_alignment    = 2 << (epoch_shift + epoch_bits)\n+  };\n+\n+  enum { locked_value             = 0,\n+         unlocked_value           = 1,\n+         monitor_value            = 2,\n+         marked_value             = 3,\n+         biased_lock_pattern      = 5\n+  };\n+\n+  enum { no_hash                  = 0 };  \/\/ no hash value assigned\n+\n+  enum { no_hash_in_place         = (address_word)no_hash << hash_shift,\n+         no_lock_in_place         = unlocked_value\n+  };\n+\n+  enum { max_age                  = age_mask };\n+\n+  enum { max_bias_epoch           = epoch_mask };\n+\n+  \/\/ Creates a markWord with all bits set to zero.\n+  static markWord zero() { return markWord(uintptr_t(0)); }\n+\n+  \/\/ Biased Locking accessors.\n+  \/\/ These must be checked by all code which calls into the\n+  \/\/ ObjectSynchronizer and other code. The biasing is not understood\n+  \/\/ by the lower-level CAS-based locking code, although the runtime\n+  \/\/ fixes up biased locks to be compatible with it when a bias is\n+  \/\/ revoked.\n+  bool has_bias_pattern() const {\n+    return (mask_bits(value(), biased_lock_mask_in_place) == biased_lock_pattern);\n+  }\n+  JavaThread* biased_locker() const {\n+    assert(has_bias_pattern(), \"should not call this otherwise\");\n+    return (JavaThread*) ((intptr_t) (mask_bits(value(), ~(biased_lock_mask_in_place | age_mask_in_place | epoch_mask_in_place))));\n+  }\n+  \/\/ Indicates that the mark has the bias bit set but that it has not\n+  \/\/ yet been biased toward a particular thread\n+  bool is_biased_anonymously() const {\n+    return (has_bias_pattern() && (biased_locker() == NULL));\n+  }\n+  \/\/ Indicates epoch in which this bias was acquired. If the epoch\n+  \/\/ changes due to too many bias revocations occurring, the biases\n+  \/\/ from the previous epochs are all considered invalid.\n+  int bias_epoch() const {\n+    assert(has_bias_pattern(), \"should not call this otherwise\");\n+    return (mask_bits(value(), epoch_mask_in_place) >> epoch_shift);\n+  }\n+  markWord set_bias_epoch(int epoch) {\n+    assert(has_bias_pattern(), \"should not call this otherwise\");\n+    assert((epoch & (~epoch_mask)) == 0, \"epoch overflow\");\n+    return markWord(mask_bits(value(), ~epoch_mask_in_place) | (epoch << epoch_shift));\n+  }\n+  markWord incr_bias_epoch() {\n+    return set_bias_epoch((1 + bias_epoch()) & epoch_mask);\n+  }\n+  \/\/ Prototype mark for initialization\n+  static markWord biased_locking_prototype() {\n+    return markWord( biased_lock_pattern );\n+  }\n+\n+  \/\/ lock accessors (note that these assume lock_shift == 0)\n+  bool is_locked()   const {\n+    return (mask_bits(value(), lock_mask_in_place) != unlocked_value);\n+  }\n+  bool is_unlocked() const {\n+    return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value);\n+  }\n+  bool is_marked()   const {\n+    return (mask_bits(value(), lock_mask_in_place) == marked_value);\n+  }\n+  bool is_neutral()  const { return (mask_bits(value(), biased_lock_mask_in_place) == unlocked_value); }\n+\n+  \/\/ Special temporary state of the markWord while being inflated.\n+  \/\/ Code that looks at mark outside a lock need to take this into account.\n+  bool is_being_inflated() const { return (value() == 0); }\n+\n+  \/\/ Distinguished markWord value - used when inflating over\n+  \/\/ an existing stacklock.  0 indicates the markWord is \"BUSY\".\n+  \/\/ Lockword mutators that use a LD...CAS idiom should always\n+  \/\/ check for and avoid overwriting a 0 value installed by some\n+  \/\/ other thread.  (They should spin or block instead.  The 0 value\n+  \/\/ is transient and *should* be short-lived).\n+  static markWord INFLATING() { return zero(); }    \/\/ inflate-in-progress\n+\n+  \/\/ Should this header be preserved during GC?\n+  inline bool must_be_preserved(oop obj_containing_mark) const;\n+  inline bool must_be_preserved_with_bias(oop obj_containing_mark) const;\n+\n+  \/\/ Should this header (including its age bits) be preserved in the\n+  \/\/ case of a promotion failure during scavenge?\n+  \/\/ Note that we special case this situation. We want to avoid\n+  \/\/ calling BiasedLocking::preserve_marks()\/restore_marks() (which\n+  \/\/ decrease the number of mark words that need to be preserved\n+  \/\/ during GC) during each scavenge. During scavenges in which there\n+  \/\/ is no promotion failure, we actually don't need to call the above\n+  \/\/ routines at all, since we don't mutate and re-initialize the\n+  \/\/ marks of promoted objects using init_mark(). However, during\n+  \/\/ scavenges which result in promotion failure, we do re-initialize\n+  \/\/ the mark words of objects, meaning that we should have called\n+  \/\/ these mark word preservation routines. Currently there's no good\n+  \/\/ place in which to call them in any of the scavengers (although\n+  \/\/ guarded by appropriate locks we could make one), but the\n+  \/\/ observation is that promotion failures are quite rare and\n+  \/\/ reducing the number of mark words preserved during them isn't a\n+  \/\/ high priority.\n+  inline bool must_be_preserved_for_promotion_failure(oop obj_containing_mark) const;\n+  inline bool must_be_preserved_with_bias_for_promotion_failure(oop obj_containing_mark) const;\n+\n+  \/\/ Should this header be preserved during a scavenge where CMS is\n+  \/\/ the old generation?\n+  \/\/ (This is basically the same body as must_be_preserved_for_promotion_failure(),\n+  \/\/ but takes the Klass* as argument instead)\n+  inline bool must_be_preserved_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const;\n+  inline bool must_be_preserved_with_bias_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const;\n+\n+  \/\/ WARNING: The following routines are used EXCLUSIVELY by\n+  \/\/ synchronization functions. They are not really gc safe.\n+  \/\/ They must get updated if markWord layout get changed.\n+  markWord set_unlocked() const {\n+    return markWord(value() | unlocked_value);\n+  }\n+  bool has_locker() const {\n+    return ((value() & lock_mask_in_place) == locked_value);\n+  }\n+  BasicLock* locker() const {\n+    assert(has_locker(), \"check\");\n+    return (BasicLock*) value();\n+  }\n+  bool has_monitor() const {\n+    return ((value() & monitor_value) != 0);\n+  }\n+  ObjectMonitor* monitor() const {\n+    assert(has_monitor(), \"check\");\n+    \/\/ Use xor instead of &~ to provide one extra tag-bit check.\n+    return (ObjectMonitor*) (value() ^ monitor_value);\n+  }\n+  bool has_displaced_mark_helper() const {\n+    return ((value() & unlocked_value) == 0);\n+  }\n+  markWord displaced_mark_helper() const {\n+    assert(has_displaced_mark_helper(), \"check\");\n+    intptr_t ptr = (value() & ~monitor_value);\n+    return *(markWord*)ptr;\n+  }\n+  void set_displaced_mark_helper(markWord m) const {\n+    assert(has_displaced_mark_helper(), \"check\");\n+    intptr_t ptr = (value() & ~monitor_value);\n+    *(markWord*)ptr = m;\n+  }\n+  markWord copy_set_hash(intptr_t hash) const {\n+    intptr_t tmp = value() & (~hash_mask_in_place);\n+    tmp |= ((hash & hash_mask) << hash_shift);\n+    return markWord(tmp);\n+  }\n+  \/\/ it is only used to be stored into BasicLock as the\n+  \/\/ indicator that the lock is using heavyweight monitor\n+  static markWord unused_mark() {\n+    return markWord(marked_value);\n+  }\n+  \/\/ the following two functions create the markWord to be\n+  \/\/ stored into object header, it encodes monitor info\n+  static markWord encode(BasicLock* lock) {\n+    return from_pointer(lock);\n+  }\n+  static markWord encode(ObjectMonitor* monitor) {\n+    intptr_t tmp = (intptr_t) monitor;\n+    return (markWord) (tmp | monitor_value);\n+  }\n+  static markWord encode(JavaThread* thread, uint age, int bias_epoch) {\n+    intptr_t tmp = (intptr_t) thread;\n+    assert(UseBiasedLocking && ((tmp & (epoch_mask_in_place | age_mask_in_place | biased_lock_mask_in_place)) == 0), \"misaligned JavaThread pointer\");\n+    assert(age <= max_age, \"age too large\");\n+    assert(bias_epoch <= max_bias_epoch, \"bias epoch too large\");\n+    return (markWord) (tmp | (bias_epoch << epoch_shift) | (age << age_shift) | biased_lock_pattern);\n+  }\n+\n+  \/\/ used to encode pointers during GC\n+  markWord clear_lock_bits() { return markWord(value() & ~lock_mask_in_place); }\n+\n+  \/\/ age operations\n+  markWord set_marked()   { return markWord((value() & ~lock_mask_in_place) | marked_value); }\n+  markWord set_unmarked() { return markWord((value() & ~lock_mask_in_place) | unlocked_value); }\n+\n+  uint    age()               const { return mask_bits(value() >> age_shift, age_mask); }\n+  markWord set_age(uint v) const {\n+    assert((v & ~age_mask) == 0, \"shouldn't overflow age field\");\n+    return markWord((value() & ~age_mask_in_place) | (((uintptr_t)v & age_mask) << age_shift));\n+  }\n+  markWord incr_age()          const { return age() == max_age ? markWord(_value) : set_age(age() + 1); }\n+\n+  \/\/ hash operations\n+  intptr_t hash() const {\n+    return mask_bits(value() >> hash_shift, hash_mask);\n+  }\n+\n+  bool has_no_hash() const {\n+    return hash() == no_hash;\n+  }\n+\n+  \/\/ Prototype mark for initialization\n+  static markWord prototype() {\n+    return markWord( no_hash_in_place | no_lock_in_place );\n+  }\n+\n+  \/\/ Helper function for restoration of unmarked mark oops during GC\n+  static inline markWord prototype_for_object(oop obj);\n+\n+  \/\/ Debugging\n+  void print_on(outputStream* st) const;\n+\n+  \/\/ Prepare address of oop for placement into mark\n+  inline static markWord encode_pointer_as_mark(void* p) { return from_pointer(p).set_marked(); }\n+\n+  \/\/ Recover address of oop from encoded form used in mark\n+  inline void* decode_pointer() { if (UseBiasedLocking && has_bias_pattern()) return NULL; return (void*)clear_lock_bits().value(); }\n+\n+  \/\/ These markWords indicate cms free chunk blocks and not objects.\n+  \/\/ In 64 bit, the markWord is set to distinguish them from oops.\n+  \/\/ These are defined in 32 bit mode for vmStructs.\n+  const static uintptr_t cms_free_chunk_pattern  = 0x1;\n+\n+  \/\/ Constants for the size field.\n+  enum { size_shift                = cms_shift + cms_bits,\n+         size_bits                 = 35    \/\/ need for compressed oops 32G\n+       };\n+  \/\/ These values are too big for Win64\n+  const static uintptr_t size_mask = LP64_ONLY(right_n_bits(size_bits))\n+                                     NOT_LP64(0);\n+  const static uintptr_t size_mask_in_place =\n+                                     (address_word)size_mask << size_shift;\n+\n+#ifdef _LP64\n+  static markWord cms_free_prototype() {\n+    return markWord(((intptr_t)prototype().value() & ~cms_mask_in_place) |\n+                   ((cms_free_chunk_pattern & cms_mask) << cms_shift));\n+  }\n+  uintptr_t cms_encoding() const {\n+    return mask_bits(value() >> cms_shift, cms_mask);\n+  }\n+  bool is_cms_free_chunk() const {\n+    return is_neutral() &&\n+           (cms_encoding() & cms_free_chunk_pattern) == cms_free_chunk_pattern;\n+  }\n+\n+  size_t get_size() const       { return (size_t)(value() >> size_shift); }\n+  static markWord set_size_and_free(size_t size) {\n+    assert((size & ~size_mask) == 0, \"shouldn't overflow size field\");\n+    return markWord(((intptr_t)cms_free_prototype().value() & ~size_mask_in_place) |\n+                   (((intptr_t)size & size_mask) << size_shift));\n+  }\n+#endif \/\/ _LP64\n+};\n+\n+\/\/ Support atomic operations.\n+template<>\n+struct PrimitiveConversions::Translate<markWord> : public TrueType {\n+  typedef markWord Value;\n+  typedef uintptr_t Decayed;\n+\n+  static Decayed decay(const Value& x) { return x.value(); }\n+  static Value recover(Decayed x) { return Value(x); }\n+};\n+\n+#endif \/\/ SHARE_VM_OOPS_MARKWORD_HPP\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":433,"deletions":0,"binary":false,"changes":433,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2006, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_OOPS_MARKWORD_INLINE_HPP\n+#define SHARE_VM_OOPS_MARKWORD_INLINE_HPP\n+\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+\/\/ Should this header be preserved during GC (when biased locking is enabled)?\n+inline bool markWord::must_be_preserved_with_bias(oop obj_containing_mark) const {\n+  assert(UseBiasedLocking, \"unexpected\");\n+  if (has_bias_pattern()) {\n+    \/\/ Will reset bias at end of collection\n+    \/\/ Mark words of biased and currently locked objects are preserved separately\n+    return false;\n+  }\n+  markWord prototype_header = prototype_for_object(obj_containing_mark);\n+  if (prototype_header.has_bias_pattern()) {\n+    \/\/ Individual instance which has its bias revoked; must return\n+    \/\/ true for correctness\n+    return true;\n+  }\n+  return (!is_unlocked() || !has_no_hash());\n+}\n+\n+\/\/ Should this header be preserved during GC?\n+inline bool markWord::must_be_preserved(oop obj_containing_mark) const {\n+  if (!UseBiasedLocking)\n+    return (!is_unlocked() || !has_no_hash());\n+  return must_be_preserved_with_bias(obj_containing_mark);\n+}\n+\n+\/\/ Should this header be preserved in the case of a promotion failure\n+\/\/ during scavenge (when biased locking is enabled)?\n+inline bool markWord::must_be_preserved_with_bias_for_promotion_failure(oop obj_containing_mark) const {\n+  assert(UseBiasedLocking, \"unexpected\");\n+  \/\/ We don't explicitly save off the mark words of biased and\n+  \/\/ currently-locked objects during scavenges, so if during a\n+  \/\/ promotion failure we encounter either a biased mark word or a\n+  \/\/ klass which still has a biasable prototype header, we have to\n+  \/\/ preserve the mark word. This results in oversaving, but promotion\n+  \/\/ failures are rare, and this avoids adding more complex logic to\n+  \/\/ the scavengers to call new variants of\n+  \/\/ BiasedLocking::preserve_marks() \/ restore_marks() in the middle\n+  \/\/ of a scavenge when a promotion failure has first been detected.\n+  if (has_bias_pattern() ||\n+      prototype_for_object(obj_containing_mark).has_bias_pattern()) {\n+    return true;\n+  }\n+  return (!is_unlocked() || !has_no_hash());\n+}\n+\n+\/\/ Should this header be preserved in the case of a promotion failure\n+\/\/ during scavenge?\n+inline bool markWord::must_be_preserved_for_promotion_failure(oop obj_containing_mark) const {\n+  if (!UseBiasedLocking)\n+    return (!is_unlocked() || !has_no_hash());\n+  return must_be_preserved_with_bias_for_promotion_failure(obj_containing_mark);\n+}\n+\n+\n+\/\/ Same as must_be_preserved_with_bias_for_promotion_failure() except that\n+\/\/ it takes a Klass* argument, instead of the object of which this is the mark word.\n+inline bool markWord::must_be_preserved_with_bias_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const {\n+  assert(UseBiasedLocking, \"unexpected\");\n+  \/\/ CMS scavenges preserve mark words in similar fashion to promotion failures; see above\n+  if (has_bias_pattern() ||\n+      klass_of_obj_containing_mark->prototype_header().has_bias_pattern()) {\n+    return true;\n+  }\n+  return (!is_unlocked() || !has_no_hash());\n+}\n+\n+\/\/ Same as must_be_preserved_for_promotion_failure() except that\n+\/\/ it takes a Klass* argument, instead of the object of which this is the mark word.\n+inline bool markWord::must_be_preserved_for_cms_scavenge(Klass* klass_of_obj_containing_mark) const {\n+  if (!UseBiasedLocking)\n+    return (!is_unlocked() || !has_no_hash());\n+  return must_be_preserved_with_bias_for_cms_scavenge(klass_of_obj_containing_mark);\n+}\n+\n+inline markWord markWord::prototype_for_object(oop obj) {\n+#ifdef ASSERT\n+  markWord prototype_header = obj->klass()->prototype_header();\n+  assert(prototype_header == prototype() || prototype_header.has_bias_pattern(), \"corrupt prototype header\");\n+#endif\n+  return obj->klass()->prototype_header();\n+}\n+\n+#endif \/\/ SHARE_VM_OOPS_MARKWORD_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -2105,1 +2105,1 @@\n-\/\/ Something that can't be mistaken for an address or a markOop\n+\/\/ Something that can't be mistaken for an address or a markWord\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  friend class CSetMarkOopClosure;\n+  friend class CSetMarkWordClosure;\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,2 +126,2 @@\n-  \/\/ Header verification: the mark is typically non-NULL. If we're\n-  \/\/ at a safepoint, it must not be null.\n+  \/\/ Header verification: the mark is typically non-zero. If we're\n+  \/\/ at a safepoint, it must not be zero.\n@@ -133,1 +133,1 @@\n-  if (obj->mark_raw() != NULL) {\n+  if (obj->mark_raw().value() != 0) {\n@@ -148,1 +148,1 @@\n-  return mark()->is_unlocked();\n+  return mark().is_unlocked();\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/markWord.hpp\"\n@@ -59,1 +60,1 @@\n-  volatile markOop _mark;\n+  volatile markWord _mark;\n@@ -66,3 +67,3 @@\n-  inline markOop  mark()          const;\n-  inline markOop  mark_raw()      const;\n-  inline markOop* mark_addr_raw() const;\n+  inline markWord  mark()          const;\n+  inline markWord  mark_raw()      const;\n+  inline markWord* mark_addr_raw() const;\n@@ -70,3 +71,3 @@\n-  inline void set_mark(volatile markOop m);\n-  inline void set_mark_raw(volatile markOop m);\n-  static inline void set_mark_raw(HeapWord* mem, markOop m);\n+  inline void set_mark(volatile markWord m);\n+  inline void set_mark_raw(volatile markWord m);\n+  static inline void set_mark_raw(HeapWord* mem, markWord m);\n@@ -74,3 +75,3 @@\n-  inline void release_set_mark(markOop m);\n-  inline markOop cas_set_mark(markOop new_mark, markOop old_mark);\n-  inline markOop cas_set_mark_raw(markOop new_mark, markOop old_mark, atomic_memory_order order = memory_order_conservative);\n+  inline void release_set_mark(markWord m);\n+  inline markWord cas_set_mark(markWord new_mark, markWord old_mark);\n+  inline markWord cas_set_mark_raw(markWord new_mark, markWord old_mark, atomic_memory_order order = memory_order_conservative);\n@@ -264,1 +265,1 @@\n-  inline bool cas_forward_to(oop p, markOop compare, atomic_memory_order order = memory_order_conservative);\n+  inline bool cas_forward_to(oop p, markWord compare, atomic_memory_order order = memory_order_conservative);\n@@ -319,3 +320,3 @@\n-  inline bool    has_displaced_mark_raw() const;\n-  inline markOop displaced_mark_raw() const;\n-  inline void    set_displaced_mark_raw(markOop m);\n+  inline bool     has_displaced_mark_raw() const;\n+  inline markWord displaced_mark_raw() const;\n+  inline void     set_displaced_mark_raw(markWord m);\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/markOop.inline.hpp\"\n+#include \"oops\/markWord.inline.hpp\"\n@@ -46,2 +46,3 @@\n-markOop  oopDesc::mark()      const {\n-  return HeapAccess<MO_VOLATILE>::load_at(as_oop(), mark_offset_in_bytes());\n+markWord  oopDesc::mark() const {\n+  uintptr_t v = HeapAccess<MO_VOLATILE>::load_at(as_oop(), mark_offset_in_bytes());\n+  return markWord(v);\n@@ -50,2 +51,2 @@\n-markOop  oopDesc::mark_raw()  const {\n-  return _mark;\n+markWord  oopDesc::mark_raw() const {\n+  return Atomic::load(&_mark);;\n@@ -54,2 +55,2 @@\n-markOop* oopDesc::mark_addr_raw() const {\n-  return (markOop*) &_mark;\n+markWord* oopDesc::mark_addr_raw() const {\n+  return (markWord*) &_mark;\n@@ -58,2 +59,2 @@\n-void oopDesc::set_mark(volatile markOop m) {\n-  HeapAccess<MO_VOLATILE>::store_at(as_oop(), mark_offset_in_bytes(), m);\n+void oopDesc::set_mark(markWord m) {\n+  HeapAccess<MO_VOLATILE>::store_at(as_oop(), mark_offset_in_bytes(), m.value());\n@@ -62,2 +63,2 @@\n-void oopDesc::set_mark_raw(volatile markOop m) {\n-  _mark = m;\n+void oopDesc::set_mark_raw(markWord m) {\n+  Atomic::store(m, &_mark);\n@@ -66,2 +67,2 @@\n-void oopDesc::set_mark_raw(HeapWord* mem, markOop m) {\n-  *(markOop*)(((char*)mem) + mark_offset_in_bytes()) = m;\n+void oopDesc::set_mark_raw(HeapWord* mem, markWord m) {\n+  *(markWord*)(((char*)mem) + mark_offset_in_bytes()) = m;\n@@ -70,2 +71,2 @@\n-void oopDesc::release_set_mark(markOop m) {\n-  HeapAccess<MO_RELEASE>::store_at(as_oop(), mark_offset_in_bytes(), m);\n+void oopDesc::release_set_mark(markWord m) {\n+  HeapAccess<MO_RELEASE>::store_at(as_oop(), mark_offset_in_bytes(), m.value());\n@@ -74,2 +75,3 @@\n-markOop oopDesc::cas_set_mark(markOop new_mark, markOop old_mark) {\n-  return HeapAccess<>::atomic_cmpxchg_at(new_mark, as_oop(), mark_offset_in_bytes(), old_mark);\n+markWord oopDesc::cas_set_mark(markWord new_mark, markWord old_mark) {\n+  uintptr_t v = HeapAccess<>::atomic_cmpxchg_at(new_mark.value(), as_oop(), mark_offset_in_bytes(), old_mark.value());\n+  return markWord(v);\n@@ -78,1 +80,1 @@\n-markOop oopDesc::cas_set_mark_raw(markOop new_mark, markOop old_mark, atomic_memory_order order) {\n+markWord oopDesc::cas_set_mark_raw(markWord new_mark, markWord old_mark, atomic_memory_order order) {\n@@ -83,1 +85,1 @@\n-  set_mark(markOopDesc::prototype_for_object(this));\n+  set_mark(markWord::prototype_for_object(this));\n@@ -87,1 +89,1 @@\n-  set_mark_raw(markOopDesc::prototype_for_object(this));\n+  set_mark_raw(markWord::prototype_for_object(this));\n@@ -321,1 +323,1 @@\n-  return mark()->is_locked();\n+  return mark().is_locked();\n@@ -325,1 +327,1 @@\n-  return mark()->is_unlocked();\n+  return mark().is_unlocked();\n@@ -329,1 +331,1 @@\n-  return mark()->has_bias_pattern();\n+  return mark().has_bias_pattern();\n@@ -333,1 +335,1 @@\n-  return mark_raw()->has_bias_pattern();\n+  return mark_raw().has_bias_pattern();\n@@ -338,1 +340,1 @@\n-  return mark_raw()->is_marked();\n+  return mark_raw().is_marked();\n@@ -345,1 +347,1 @@\n-  return mark_raw()->is_marked();\n+  return mark_raw().is_marked();\n@@ -357,2 +359,2 @@\n-  markOop m = markOopDesc::encode_pointer_as_mark(p);\n-  assert(m->decode_pointer() == p, \"encoding must be reversable\");\n+  markWord m = markWord::encode_pointer_as_mark(p);\n+  assert(m.decode_pointer() == p, \"encoding must be reversable\");\n@@ -363,1 +365,1 @@\n-bool oopDesc::cas_forward_to(oop p, markOop compare, atomic_memory_order order) {\n+bool oopDesc::cas_forward_to(oop p, markWord compare, atomic_memory_order order) {\n@@ -368,2 +370,2 @@\n-  markOop m = markOopDesc::encode_pointer_as_mark(p);\n-  assert(m->decode_pointer() == p, \"encoding must be reversable\");\n+  markWord m = markWord::encode_pointer_as_mark(p);\n+  assert(m.decode_pointer() == p, \"encoding must be reversable\");\n@@ -374,3 +376,3 @@\n-  markOop oldMark = mark_raw();\n-  markOop forwardPtrMark = markOopDesc::encode_pointer_as_mark(p);\n-  markOop curMark;\n+  markWord oldMark = mark_raw();\n+  markWord forwardPtrMark = markWord::encode_pointer_as_mark(p);\n+  markWord curMark;\n@@ -378,2 +380,2 @@\n-  assert(forwardPtrMark->decode_pointer() == p, \"encoding must be reversable\");\n-  assert(sizeof(markOop) == sizeof(intptr_t), \"CAS below requires this.\");\n+  assert(forwardPtrMark.decode_pointer() == p, \"encoding must be reversable\");\n+  assert(sizeof(markWord) == sizeof(intptr_t), \"CAS below requires this.\");\n@@ -381,1 +383,1 @@\n-  while (!oldMark->is_marked()) {\n+  while (!oldMark.is_marked()) {\n@@ -399,1 +401,1 @@\n-  return (oop) mark_raw()->decode_pointer();\n+  return (oop) mark_raw().decode_pointer();\n@@ -406,2 +408,1 @@\n-  markOop m = OrderAccess::load_acquire(&_mark);\n-  return (oop) m->decode_pointer();\n+  return (oop) OrderAccess::load_acquire(&_mark).decode_pointer();\n@@ -414,1 +415,1 @@\n-    return displaced_mark_raw()->age();\n+    return displaced_mark_raw().age();\n@@ -416,1 +417,1 @@\n-    return mark_raw()->age();\n+    return mark_raw().age();\n@@ -423,1 +424,1 @@\n-    set_displaced_mark_raw(displaced_mark_raw()->incr_age());\n+    set_displaced_mark_raw(displaced_mark_raw().incr_age());\n@@ -425,1 +426,1 @@\n-    set_mark_raw(mark_raw()->incr_age());\n+    set_mark_raw(mark_raw().incr_age());\n@@ -491,5 +492,5 @@\n-  markOop mrk = mark();\n-  if (mrk->is_unlocked() && !mrk->has_no_hash()) {\n-    return mrk->hash();\n-  } else if (mrk->is_marked()) {\n-    return mrk->hash();\n+  markWord mrk = mark();\n+  if (mrk.is_unlocked() && !mrk.has_no_hash()) {\n+    return mrk.hash();\n+  } else if (mrk.is_marked()) {\n+    return mrk.hash();\n@@ -502,1 +503,1 @@\n-  return mark_raw()->has_displaced_mark_helper();\n+  return mark_raw().has_displaced_mark_helper();\n@@ -505,2 +506,2 @@\n-markOop oopDesc::displaced_mark_raw() const {\n-  return mark_raw()->displaced_mark_helper();\n+markWord oopDesc::displaced_mark_raw() const {\n+  return mark_raw().displaced_mark_helper();\n@@ -509,2 +510,2 @@\n-void oopDesc::set_displaced_mark_raw(markOop m) {\n-  mark_raw()->set_displaced_mark_helper(m);\n+void oopDesc::set_displaced_mark_raw(markWord m) {\n+  mark_raw().set_displaced_mark_helper(m);\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":55,"deletions":54,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-typedef class   markOopDesc*                markOop;\n@@ -47,1 +46,1 @@\n-typedef class oopDesc*                            oop;\n+typedef class oopDesc*                      oop;\n@@ -49,1 +48,1 @@\n-typedef class   arrayOopDesc*                    arrayOop;\n+typedef class   arrayOopDesc*               arrayOop;\n@@ -51,1 +50,1 @@\n-typedef class     typeArrayOopDesc*            typeArrayOop;\n+typedef class     typeArrayOopDesc*           typeArrayOop;\n@@ -84,1 +83,0 @@\n-  \/\/ friend class markOop;\n@@ -123,1 +121,0 @@\n-  operator markOop () const volatile  { return markOop(obj()); }\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3963,1 +3963,1 @@\n-  Node *lock_mask      = _gvn.MakeConX(markOopDesc::biased_lock_mask_in_place);\n+  Node *lock_mask      = _gvn.MakeConX(markWord::biased_lock_mask_in_place);\n@@ -3965,1 +3965,1 @@\n-  Node *unlocked_val   = _gvn.MakeConX(markOopDesc::unlocked_value);\n+  Node *unlocked_val   = _gvn.MakeConX(markWord::unlocked_value);\n@@ -3974,3 +3974,3 @@\n-  \/\/ vm: see markOop.hpp.\n-  Node *hash_mask      = _gvn.intcon(markOopDesc::hash_mask);\n-  Node *hash_shift     = _gvn.intcon(markOopDesc::hash_shift);\n+  \/\/ vm: see markWord.hpp.\n+  Node *hash_mask      = _gvn.intcon(markWord::hash_mask);\n+  Node *hash_shift     = _gvn.intcon(markWord::hash_shift);\n@@ -3985,1 +3985,1 @@\n-  Node *no_hash_val    = _gvn.intcon(markOopDesc::no_hash);\n+  Node *no_hash_val    = _gvn.intcon(markWord::no_hash);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1776,1 +1776,1 @@\n-    mark_node = makecon(TypeRawPtr::make((address)markOopDesc::prototype()));\n+    mark_node = makecon(TypeRawPtr::make((address)markWord::prototype().value()));\n@@ -2333,2 +2333,2 @@\n-                         markOopDesc::biased_lock_mask_in_place,\n-                         markOopDesc::biased_lock_pattern, true);\n+                         markWord::biased_lock_mask_in_place,\n+                         markWord::biased_lock_pattern, true);\n@@ -2363,1 +2363,1 @@\n-                                      (~markOopDesc::age_mask_in_place), 0);\n+                                      (~markWord::age_mask_in_place), 0);\n@@ -2374,1 +2374,1 @@\n-                          markOopDesc::biased_lock_mask_in_place, 0, true);\n+                          markWord::biased_lock_mask_in_place, 0, true);\n@@ -2396,1 +2396,1 @@\n-                                      markOopDesc::epoch_mask_in_place, 0);\n+                                      markWord::epoch_mask_in_place, 0);\n@@ -2406,3 +2406,3 @@\n-    Node* cmask   = MakeConX(markOopDesc::biased_lock_mask_in_place |\n-                             markOopDesc::age_mask_in_place |\n-                             markOopDesc::epoch_mask_in_place);\n+    Node* cmask   = MakeConX(markWord::biased_lock_mask_in_place |\n+                             markWord::age_mask_in_place |\n+                             markWord::epoch_mask_in_place);\n@@ -2523,2 +2523,2 @@\n-                         markOopDesc::biased_lock_mask_in_place,\n-                         markOopDesc::biased_lock_pattern);\n+                         markWord::biased_lock_mask_in_place,\n+                         markWord::biased_lock_pattern);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -146,2 +146,2 @@\n-# include \"oops\/markOop.hpp\"\n-# include \"oops\/markOop.inline.hpp\"\n+# include \"oops\/markWord.hpp\"\n+# include \"oops\/markWord.inline.hpp\"\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -966,1 +966,1 @@\n-      markOop mark = hobj()->mark();\n+      markWord mark = hobj()->mark();\n@@ -968,1 +968,1 @@\n-      if (!mark->has_monitor()) {\n+      if (!mark.has_monitor()) {\n@@ -971,2 +971,2 @@\n-        if (mark->has_locker()) {\n-          owner = (address)mark->locker(); \/\/ save the address of the Lock word\n+        if (mark.has_locker()) {\n+          owner = (address)mark.locker(); \/\/ save the address of the Lock word\n@@ -977,1 +977,1 @@\n-        mon = mark->monitor();\n+        mon = mark.monitor();\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1647,2 +1647,2 @@\n-      markOop mark = o->mark();\n-      if (mark->is_marked()) {\n+      markWord mark = o->mark();\n+      if (mark.is_marked()) {\n@@ -1660,1 +1660,1 @@\n-  static GrowableArray<markOop>* _saved_mark_stack;\n+  static GrowableArray<markWord>* _saved_mark_stack;\n@@ -1675,1 +1675,1 @@\n-GrowableArray<markOop>* ObjectMarker::_saved_mark_stack = NULL;\n+GrowableArray<markWord>* ObjectMarker::_saved_mark_stack = NULL;\n@@ -1686,1 +1686,1 @@\n-  _saved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<markOop>(4000, true);\n+  _saved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<markWord>(4000, true);\n@@ -1710,1 +1710,1 @@\n-    markOop mark = _saved_mark_stack->at(i);\n+    markWord mark = _saved_mark_stack->at(i);\n@@ -1726,1 +1726,1 @@\n-  assert(!o->mark()->is_marked(), \"should only mark an object once\");\n+  assert(!o->mark().is_marked(), \"should only mark an object once\");\n@@ -1729,1 +1729,1 @@\n-  markOop mark = o->mark();\n+  markWord mark = o->mark();\n@@ -1731,1 +1731,1 @@\n-  if (mark->must_be_preserved(o)) {\n+  if (mark.must_be_preserved(o)) {\n@@ -1737,1 +1737,1 @@\n-  o->set_mark(markOopDesc::prototype()->set_marked());\n+  o->set_mark(markWord::prototype().set_marked());\n@@ -1742,1 +1742,1 @@\n-  return o->mark()->is_marked();\n+  return o->mark().is_marked();\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1682,1 +1682,1 @@\n-  return (jboolean) obj_oop->mark()->has_monitor();\n+  return (jboolean) obj_oop->mark().has_monitor();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2882,1 +2882,1 @@\n-      if (FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, markOopDesc::max_age + 1) != JVMFlag::SUCCESS) {\n+      if (FLAG_SET_CMDLINE(uintx, MaxTenuringThreshold, markWord::max_age + 1) != JVMFlag::SUCCESS) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,3 +31,3 @@\n-  markOop moop = displaced_header();\n-  if (moop != NULL)\n-    moop->print_on(st);\n+  markWord mark_word = displaced_header();\n+  if (mark_word.value() != 0)\n+    mark_word.print_on(st);\n@@ -65,1 +65,1 @@\n-  if (displaced_header()->is_neutral()) {\n+  if (displaced_header().is_neutral()) {\n@@ -78,1 +78,1 @@\n-  intptr_t dh = (intptr_t) displaced_header();\n+  intptr_t dh = (intptr_t) displaced_header().value();\n","filename":"src\/hotspot\/share\/runtime\/basicLock.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -35,1 +36,1 @@\n-  volatile markOop _displaced_header;\n+  volatile markWord _displaced_header;\n@@ -37,2 +38,7 @@\n-  markOop      displaced_header() const               { return _displaced_header; }\n-  void         set_displaced_header(markOop header)   { _displaced_header = header; }\n+  markWord displaced_header() const {\n+    return Atomic::load(&_displaced_header);\n+  }\n+\n+  void set_displaced_header(markWord header) {\n+    Atomic::store(header, &_displaced_header);\n+  }\n","filename":"src\/hotspot\/share\/runtime\/basicLock.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -48,2 +48,2 @@\n-static GrowableArray<Handle>*  _preserved_oop_stack  = NULL;\n-static GrowableArray<markOop>* _preserved_mark_stack = NULL;\n+static GrowableArray<Handle>*   _preserved_oop_stack  = NULL;\n+static GrowableArray<markWord>* _preserved_mark_stack = NULL;\n@@ -52,1 +52,1 @@\n-  k->set_prototype_header(markOopDesc::biased_locking_prototype());\n+  k->set_prototype_header(markWord::biased_locking_prototype());\n@@ -153,1 +153,1 @@\n-\/\/ After the call, *biased_locker will be set to obj->mark()->biased_locker() if biased_locker != NULL,\n+\/\/ After the call, *biased_locker will be set to obj->mark().biased_locker() if biased_locker != NULL,\n@@ -156,2 +156,2 @@\n-  markOop mark = obj->mark();\n-  if (!mark->has_bias_pattern()) {\n+  markWord mark = obj->mark();\n+  if (!mark.has_bias_pattern()) {\n@@ -164,1 +164,1 @@\n-                              p2i((void *)obj), (intptr_t) mark,\n+                              p2i((void *)obj), mark.value(),\n@@ -171,3 +171,3 @@\n-  uint age = mark->age();\n-  markOop   biased_prototype = markOopDesc::biased_locking_prototype()->set_age(age);\n-  markOop unbiased_prototype = markOopDesc::prototype()->set_age(age);\n+  uint age = mark.age();\n+  markWord   biased_prototype = markWord::biased_locking_prototype().set_age(age);\n+  markWord unbiased_prototype = markWord::prototype().set_age(age);\n@@ -182,1 +182,1 @@\n-                            (intptr_t) mark,\n+                            mark.value(),\n@@ -184,1 +184,1 @@\n-                            (intptr_t) obj->klass()->prototype_header(),\n+                            obj->klass()->prototype_header().value(),\n@@ -193,1 +193,1 @@\n-                             (intptr_t) mark,\n+                             mark.value(),\n@@ -195,1 +195,1 @@\n-                             (intptr_t) obj->klass()->prototype_header(),\n+                             obj->klass()->prototype_header().value(),\n@@ -200,1 +200,1 @@\n-  JavaThread* biased_thread = mark->biased_locker();\n+  JavaThread* biased_thread = mark.biased_locker();\n@@ -265,1 +265,1 @@\n-      markOop mark = markOopDesc::encode((BasicLock*) NULL);\n+      markWord mark = markWord::encode((BasicLock*) NULL);\n@@ -281,2 +281,2 @@\n-    obj->release_set_mark(markOopDesc::encode(highest_lock));\n-    assert(!obj->mark()->has_bias_pattern(), \"illegal mark state: stack lock used bias bit\");\n+    obj->release_set_mark(markWord::encode(highest_lock));\n+    assert(!obj->mark().has_bias_pattern(), \"illegal mark state: stack lock used bias bit\");\n@@ -322,2 +322,2 @@\n-  markOop mark = o->mark();\n-  if (!mark->has_bias_pattern()) {\n+  markWord mark = o->mark();\n+  if (!mark.has_bias_pattern()) {\n@@ -384,1 +384,1 @@\n-                          (intptr_t) o->mark(),\n+                          o->mark().value(),\n@@ -408,4 +408,4 @@\n-      if (klass->prototype_header()->has_bias_pattern()) {\n-        int prev_epoch = klass->prototype_header()->bias_epoch();\n-        klass->set_prototype_header(klass->prototype_header()->incr_bias_epoch());\n-        int cur_epoch = klass->prototype_header()->bias_epoch();\n+      if (klass->prototype_header().has_bias_pattern()) {\n+        int prev_epoch = klass->prototype_header().bias_epoch();\n+        klass->set_prototype_header(klass->prototype_header().incr_bias_epoch());\n+        int cur_epoch = klass->prototype_header().bias_epoch();\n@@ -420,2 +420,2 @@\n-            markOop mark = owner->mark();\n-            if ((owner->klass() == k_o) && mark->has_bias_pattern()) {\n+            markWord mark = owner->mark();\n+            if ((owner->klass() == k_o) && mark.has_bias_pattern()) {\n@@ -423,2 +423,2 @@\n-              assert(mark->bias_epoch() == prev_epoch || mark->bias_epoch() == cur_epoch, \"error in bias epoch adjustment\");\n-              owner->set_mark(mark->set_bias_epoch(cur_epoch));\n+              assert(mark.bias_epoch() == prev_epoch || mark.bias_epoch() == cur_epoch, \"error in bias epoch adjustment\");\n+              owner->set_mark(mark.set_bias_epoch(cur_epoch));\n@@ -432,1 +432,1 @@\n-      revoke_bias(o, attempt_rebias_of_object && klass->prototype_header()->has_bias_pattern(), true, requesting_thread, NULL);\n+      revoke_bias(o, attempt_rebias_of_object && klass->prototype_header().has_bias_pattern(), true, requesting_thread, NULL);\n@@ -443,1 +443,1 @@\n-      klass->set_prototype_header(markOopDesc::prototype());\n+      klass->set_prototype_header(markWord::prototype());\n@@ -452,2 +452,2 @@\n-          markOop mark = owner->mark();\n-          if ((owner->klass() == k_o) && mark->has_bias_pattern()) {\n+          markWord mark = owner->mark();\n+          if ((owner->klass() == k_o) && mark.has_bias_pattern()) {\n@@ -470,4 +470,4 @@\n-      o->mark()->has_bias_pattern() &&\n-      klass->prototype_header()->has_bias_pattern()) {\n-    markOop new_mark = markOopDesc::encode(requesting_thread, o->mark()->age(),\n-                                           klass->prototype_header()->bias_epoch());\n+      o->mark().has_bias_pattern() &&\n+      klass->prototype_header().has_bias_pattern()) {\n+    markWord new_mark = markWord::encode(requesting_thread, o->mark().age(),\n+                                           klass->prototype_header().bias_epoch());\n@@ -479,2 +479,2 @@\n-  assert(!o->mark()->has_bias_pattern() ||\n-         (attempt_rebias_of_object && (o->mark()->biased_locker() == requesting_thread)),\n+  assert(!o->mark().has_bias_pattern() ||\n+         (attempt_rebias_of_object && (o->mark().biased_locker() == requesting_thread)),\n@@ -525,2 +525,2 @@\n-      markOop mark = (*_obj)()->mark();\n-      if (mark->has_bias_pattern()) {\n+      markWord mark = (*_obj)()->mark();\n+      if (mark.has_bias_pattern()) {\n@@ -531,2 +531,2 @@\n-        markOop mark = (_objs->at(i))()->mark();\n-        if (mark->has_bias_pattern()) {\n+        markWord mark = (_objs->at(i))()->mark();\n+        if (mark.has_bias_pattern()) {\n@@ -631,2 +631,2 @@\n-  markOop mark = obj->mark();\n-  if (mark->is_biased_anonymously() && !attempt_rebias) {\n+  markWord mark = obj->mark();\n+  if (mark.is_biased_anonymously() && !attempt_rebias) {\n@@ -639,3 +639,3 @@\n-    markOop biased_value       = mark;\n-    markOop unbiased_prototype = markOopDesc::prototype()->set_age(mark->age());\n-    markOop res_mark = obj->cas_set_mark(unbiased_prototype, mark);\n+    markWord biased_value       = mark;\n+    markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n+    markWord res_mark = obj->cas_set_mark(unbiased_prototype, mark);\n@@ -645,1 +645,1 @@\n-  } else if (mark->has_bias_pattern()) {\n+  } else if (mark.has_bias_pattern()) {\n@@ -647,2 +647,2 @@\n-    markOop prototype_header = k->prototype_header();\n-    if (!prototype_header->has_bias_pattern()) {\n+    markWord prototype_header = k->prototype_header();\n+    if (!prototype_header.has_bias_pattern()) {\n@@ -655,3 +655,3 @@\n-      markOop biased_value       = mark;\n-      markOop res_mark = obj->cas_set_mark(prototype_header, mark);\n-      assert(!obj->mark()->has_bias_pattern(), \"even if we raced, should still be revoked\");\n+      markWord biased_value       = mark;\n+      markWord res_mark = obj->cas_set_mark(prototype_header, mark);\n+      assert(!obj->mark().has_bias_pattern(), \"even if we raced, should still be revoked\");\n@@ -659,1 +659,1 @@\n-    } else if (prototype_header->bias_epoch() != mark->bias_epoch()) {\n+    } else if (prototype_header.bias_epoch() != mark.bias_epoch()) {\n@@ -669,3 +669,3 @@\n-        markOop biased_value       = mark;\n-        markOop rebiased_prototype = markOopDesc::encode((JavaThread*) THREAD, mark->age(), prototype_header->bias_epoch());\n-        markOop res_mark = obj->cas_set_mark(rebiased_prototype, mark);\n+        markWord biased_value       = mark;\n+        markWord rebiased_prototype = markWord::encode((JavaThread*) THREAD, mark.age(), prototype_header.bias_epoch());\n+        markWord res_mark = obj->cas_set_mark(rebiased_prototype, mark);\n@@ -676,3 +676,3 @@\n-        markOop biased_value       = mark;\n-        markOop unbiased_prototype = markOopDesc::prototype()->set_age(mark->age());\n-        markOop res_mark = obj->cas_set_mark(unbiased_prototype, mark);\n+        markWord biased_value       = mark;\n+        markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n+        markWord res_mark = obj->cas_set_mark(unbiased_prototype, mark);\n@@ -691,3 +691,3 @@\n-    markOop prototype_header = k->prototype_header();\n-    if (mark->biased_locker() == THREAD &&\n-        prototype_header->bias_epoch() == mark->bias_epoch()) {\n+    markWord prototype_header = k->prototype_header();\n+    if (mark.biased_locker() == THREAD &&\n+        prototype_header.bias_epoch() == mark.bias_epoch()) {\n@@ -797,1 +797,1 @@\n-  _preserved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<markOop>(10, true);\n+  _preserved_mark_stack = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<markWord>(10, true);\n@@ -816,2 +816,2 @@\n-              markOop mark = owner->mark();\n-              if (mark->has_bias_pattern()) {\n+              markWord mark = owner->mark();\n+              if (mark.has_bias_pattern()) {\n@@ -840,1 +840,1 @@\n-    markOop mark = _preserved_mark_stack->at(i);\n+    markWord mark = _preserved_mark_stack->at(i);\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.cpp","additions":69,"deletions":69,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-\/\/ unbiased markOop. The fast-path locking code checks to see whether\n+\/\/ unbiased markWord. The fast-path locking code checks to see whether\n","filename":"src\/hotspot\/share\/runtime\/biasedLocking.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1123,2 +1123,2 @@\n-        markOop mark = obj->mark();\n-        if (UseBiasedLocking && mark->has_bias_pattern()) {\n+        markWord mark = obj->mark();\n+        if (UseBiasedLocking && mark.has_bias_pattern()) {\n@@ -1128,2 +1128,2 @@\n-          assert(mark->is_biased_anonymously() ||\n-                 mark->biased_locker() == thread, \"should be locked to current thread\");\n+          assert(mark.is_biased_anonymously() ||\n+                 mark.biased_locker() == thread, \"should be locked to current thread\");\n@@ -1131,1 +1131,1 @@\n-          markOop unbiased_prototype = markOopDesc::prototype()->set_age(mark->age());\n+          markWord unbiased_prototype = markWord::prototype().set_age(mark.age());\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagRangeList.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2589,1 +2589,1 @@\n-          range(1, markOopDesc::max_age)                                    \\\n+          range(1, markWord::max_age)                                       \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -305,1 +305,1 @@\n-    assert(((oop)(object()))->mark() == markOopDesc::encode(this), \"invariant\");\n+    assert(((oop)(object()))->mark() == markWord::encode(this), \"invariant\");\n@@ -390,1 +390,1 @@\n-  assert(((oop)(object()))->mark() == markOopDesc::encode(this), \"invariant\");\n+  assert(((oop)(object()))->mark() == markWord::encode(this), \"invariant\");\n@@ -624,1 +624,1 @@\n-  \/\/   guarantee (((oop)(object()))->mark() == markOopDesc::encode(this), \"invariant\") ;\n+  \/\/   guarantee (((oop)(object()))->mark() == markWord::encode(this), \"invariant\") ;\n@@ -697,1 +697,1 @@\n-  assert(((oop)(object()))->mark() == markOopDesc::encode(this), \"invariant\");\n+  assert(((oop)(object()))->mark() == markWord::encode(this), \"invariant\");\n@@ -772,1 +772,1 @@\n-  assert(((oop)(object()))->mark() == markOopDesc::encode(this), \"invariant\");\n+  assert(((oop)(object()))->mark() == markWord::encode(this), \"invariant\");\n@@ -1623,1 +1623,1 @@\n-  assert(((oop)(object()))->mark() == markOopDesc::encode(this), \"invariant\");\n+  assert(((oop)(object()))->mark() == markWord::encode(this), \"invariant\");\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/markWord.hpp\"\n@@ -77,1 +78,1 @@\n-\/\/   from markOop is stored there. We do not want markOop.hpp to include\n+\/\/   from markWord is stored there. We do not want markWord.hpp to include\n@@ -143,1 +144,1 @@\n-  volatile markOop   _header;       \/\/ displaced object header word - mark\n+  volatile markWord   _header;       \/\/ displaced object header word - mark\n@@ -149,1 +150,1 @@\n-                        sizeof(volatile markOop) + sizeof(void * volatile) +\n+                        sizeof(volatile markWord) + sizeof(void * volatile) +\n@@ -221,1 +222,1 @@\n-  \/\/ ObjectMonitor references can be ORed with markOopDesc::monitor_value\n+  \/\/ ObjectMonitor references can be ORed with markWord::monitor_value\n@@ -233,1 +234,1 @@\n-    ((ObjectMonitor::f ## _offset_in_bytes()) - markOopDesc::monitor_value)\n+    ((ObjectMonitor::f ## _offset_in_bytes()) - markWord::monitor_value)\n@@ -235,3 +236,3 @@\n-  markOop   header() const;\n-  volatile markOop* header_addr();\n-  void      set_header(markOop hdr);\n+  markWord           header() const;\n+  volatile markWord* header_addr();\n+  void               set_header(markWord hdr);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"runtime\/atomic.hpp\"\n+\n@@ -35,2 +37,2 @@\n-inline markOop ObjectMonitor::header() const {\n-  return _header;\n+inline markWord ObjectMonitor::header() const {\n+  return Atomic::load(&_header);\n@@ -39,1 +41,1 @@\n-inline volatile markOop* ObjectMonitor::header_addr() {\n+inline volatile markWord* ObjectMonitor::header_addr() {\n@@ -44,2 +46,2 @@\n-inline void ObjectMonitor::set_header(markOop hdr) {\n-  _header = hdr;\n+inline void ObjectMonitor::set_header(markWord hdr) {\n+  Atomic::store(hdr, &_header);\n@@ -61,1 +63,1 @@\n-  assert(_header, \"Fatal logic error in ObjectMonitor header!\");\n+  assert(Atomic::load(&_header).value() != 0, \"Fatal logic error in ObjectMonitor header!\");\n@@ -68,1 +70,1 @@\n-  _header = NULL;\n+  Atomic::store(markWord::zero(), &_header);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3083,1 +3083,1 @@\n-      if (lock->displaced_header()->is_unlocked())\n+      if (lock->displaced_header().is_unlocked())\n@@ -3086,1 +3086,1 @@\n-      buf[i++] = (intptr_t)lock->displaced_header();\n+      buf[i++] = (intptr_t)lock->displaced_header().value();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -161,1 +161,1 @@\n-  const markOop mark = obj->mark();\n+  const markWord mark = obj->mark();\n@@ -163,1 +163,1 @@\n-  if (mark->has_locker() && self->is_lock_owned((address)mark->locker())) {\n+  if (mark.has_locker() && self->is_lock_owned((address)mark.locker())) {\n@@ -169,2 +169,2 @@\n-  if (mark->has_monitor()) {\n-    ObjectMonitor * const mon = mark->monitor();\n+  if (mark.has_monitor()) {\n+    ObjectMonitor * const mon = mark.monitor();\n@@ -211,1 +211,1 @@\n-  const markOop mark = obj->mark();\n+  const markWord mark = obj->mark();\n@@ -213,2 +213,2 @@\n-  if (mark->has_monitor()) {\n-    ObjectMonitor * const m = mark->monitor();\n+  if (mark.has_monitor()) {\n+    ObjectMonitor * const m = mark.monitor();\n@@ -238,1 +238,1 @@\n-    lock->set_displaced_header(markOopDesc::unused_mark());\n+    lock->set_displaced_header(markWord::unused_mark());\n@@ -276,1 +276,1 @@\n-    assert(!obj->mark()->has_bias_pattern(), \"biases should be revoked by now\");\n+    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -283,1 +283,1 @@\n-  markOop mark = object->mark();\n+  markWord mark = object->mark();\n@@ -285,2 +285,2 @@\n-  assert(mark == markOopDesc::INFLATING() ||\n-         !mark->has_bias_pattern(), \"should not see bias pattern here\");\n+  assert(mark == markWord::INFLATING() ||\n+         !mark.has_bias_pattern(), \"should not see bias pattern here\");\n@@ -288,2 +288,2 @@\n-  markOop dhw = lock->displaced_header();\n-  if (dhw == NULL) {\n+  markWord dhw = lock->displaced_header();\n+  if (dhw.value() == 0) {\n@@ -293,1 +293,1 @@\n-    if (mark != markOopDesc::INFLATING()) {\n+    if (mark != markWord::INFLATING()) {\n@@ -297,4 +297,4 @@\n-      assert(!mark->is_neutral(), \"invariant\");\n-      assert(!mark->has_locker() ||\n-             THREAD->is_lock_owned((address)mark->locker()), \"invariant\");\n-      if (mark->has_monitor()) {\n+      assert(!mark.is_neutral(), \"invariant\");\n+      assert(!mark.has_locker() ||\n+             THREAD->is_lock_owned((address)mark.locker()), \"invariant\");\n+      if (mark.has_monitor()) {\n@@ -309,1 +309,1 @@\n-        ObjectMonitor * m = mark->monitor();\n+        ObjectMonitor * m = mark.monitor();\n@@ -318,1 +318,1 @@\n-  if (mark == (markOop) lock) {\n+  if (mark == markWord::from_pointer(lock)) {\n@@ -321,1 +321,1 @@\n-    assert(dhw->is_neutral(), \"invariant\");\n+    assert(dhw.is_neutral(), \"invariant\");\n@@ -340,2 +340,2 @@\n-  markOop mark = obj->mark();\n-  assert(!mark->has_bias_pattern(), \"should not see bias pattern here\");\n+  markWord mark = obj->mark();\n+  assert(!mark.has_bias_pattern(), \"should not see bias pattern here\");\n@@ -343,1 +343,1 @@\n-  if (mark->is_neutral()) {\n+  if (mark.is_neutral()) {\n@@ -347,1 +347,1 @@\n-    if (mark == obj()->cas_set_mark((markOop) lock, mark)) {\n+    if (mark == obj()->cas_set_mark(markWord::from_pointer(lock), mark)) {\n@@ -352,5 +352,5 @@\n-  } else if (mark->has_locker() &&\n-             THREAD->is_lock_owned((address)mark->locker())) {\n-    assert(lock != mark->locker(), \"must not re-lock the same lock\");\n-    assert(lock != (BasicLock*)obj->mark(), \"don't relock with same BasicLock\");\n-    lock->set_displaced_header(NULL);\n+  } else if (mark.has_locker() &&\n+             THREAD->is_lock_owned((address)mark.locker())) {\n+    assert(lock != mark.locker(), \"must not re-lock the same lock\");\n+    assert(lock != (BasicLock*)obj->mark().value(), \"don't relock with same BasicLock\");\n+    lock->set_displaced_header(markWord::from_pointer(NULL));\n@@ -364,1 +364,1 @@\n-  lock->set_displaced_header(markOopDesc::unused_mark());\n+  lock->set_displaced_header(markWord::unused_mark());\n@@ -394,1 +394,1 @@\n-    assert(!obj->mark()->has_bias_pattern(), \"biases should be revoked by now\");\n+    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -409,1 +409,1 @@\n-    assert(!obj->mark()->has_bias_pattern(), \"biases should be revoked by now\");\n+    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -426,1 +426,1 @@\n-    assert(!obj->mark()->has_bias_pattern(), \"biases should be revoked by now\");\n+    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -441,1 +441,1 @@\n-  assert(!obj->mark()->has_bias_pattern(), \"biases should be revoked by now\");\n+  assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -482,1 +482,1 @@\n-    assert(!obj->mark()->has_bias_pattern(), \"biases should be revoked by now\");\n+    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -505,1 +505,1 @@\n-    assert(!obj->mark()->has_bias_pattern(), \"biases should be revoked by now\");\n+    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -519,1 +519,1 @@\n-    assert(!obj->mark()->has_bias_pattern(), \"biases should be revoked by now\");\n+    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -522,2 +522,2 @@\n-  markOop mark = obj->mark();\n-  if (mark->has_locker() && THREAD->is_lock_owned((address)mark->locker())) {\n+  markWord mark = obj->mark();\n+  if (mark.has_locker() && THREAD->is_lock_owned((address)mark.locker())) {\n@@ -535,1 +535,1 @@\n-    assert(!obj->mark()->has_bias_pattern(), \"biases should be revoked by now\");\n+    assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -538,2 +538,2 @@\n-  markOop mark = obj->mark();\n-  if (mark->has_locker() && THREAD->is_lock_owned((address)mark->locker())) {\n+  markWord mark = obj->mark();\n+  if (mark.has_locker() && THREAD->is_lock_owned((address)mark.locker())) {\n@@ -584,3 +584,3 @@\n-static markOop ReadStableMark(oop obj) {\n-  markOop mark = obj->mark();\n-  if (!mark->is_being_inflated()) {\n+static markWord ReadStableMark(oop obj) {\n+  markWord mark = obj->mark();\n+  if (!mark.is_being_inflated()) {\n@@ -592,2 +592,2 @@\n-    markOop mark = obj->mark();\n-    if (!mark->is_being_inflated()) {\n+    markWord mark = obj->mark();\n+    if (!mark.is_being_inflated()) {\n@@ -633,1 +633,1 @@\n-        while (obj->mark() == markOopDesc::INFLATING()) {\n+        while (obj->mark() == markWord::INFLATING()) {\n@@ -703,1 +703,1 @@\n-  value &= markOopDesc::hash_mask;\n+  value &= markWord::hash_mask;\n@@ -705,1 +705,1 @@\n-  assert(value != markOopDesc::no_hash, \"invariant\");\n+  assert(value != markWord::no_hash, \"invariant\");\n@@ -719,1 +719,1 @@\n-    if (obj->mark()->has_bias_pattern()) {\n+    if (obj->mark().has_bias_pattern()) {\n@@ -728,1 +728,1 @@\n-      assert(!obj->mark()->has_bias_pattern(), \"biases should be revoked by now\");\n+      assert(!obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -742,1 +742,1 @@\n-  markOop temp, test;\n+  markWord temp, test;\n@@ -744,1 +744,1 @@\n-  markOop mark = ReadStableMark(obj);\n+  markWord mark = ReadStableMark(obj);\n@@ -747,1 +747,1 @@\n-  assert(!mark->has_bias_pattern(), \"invariant\");\n+  assert(!mark.has_bias_pattern(), \"invariant\");\n@@ -749,2 +749,2 @@\n-  if (mark->is_neutral()) {\n-    hash = mark->hash();              \/\/ this is a normal header\n+  if (mark.is_neutral()) {\n+    hash = mark.hash();              \/\/ this is a normal header\n@@ -755,1 +755,1 @@\n-    temp = mark->copy_set_hash(hash); \/\/ merge the hash code into header\n+    temp = mark.copy_set_hash(hash); \/\/ merge the hash code into header\n@@ -764,2 +764,2 @@\n-  } else if (mark->has_monitor()) {\n-    monitor = mark->monitor();\n+  } else if (mark.has_monitor()) {\n+    monitor = mark.monitor();\n@@ -767,2 +767,2 @@\n-    assert(temp->is_neutral(), \"invariant\");\n-    hash = temp->hash();\n+    assert(temp.is_neutral(), \"invariant\");\n+    hash = temp.hash();\n@@ -773,5 +773,5 @@\n-  } else if (Self->is_lock_owned((address)mark->locker())) {\n-    temp = mark->displaced_mark_helper(); \/\/ this is a lightweight monitor owned\n-    assert(temp->is_neutral(), \"invariant\");\n-    hash = temp->hash();              \/\/ by current thread, check if the displaced\n-    if (hash) {                       \/\/ header contains hash code\n+  } else if (Self->is_lock_owned((address)mark.locker())) {\n+    temp = mark.displaced_mark_helper(); \/\/ this is a lightweight monitor owned\n+    assert(temp.is_neutral(), \"invariant\");\n+    hash = temp.hash();                  \/\/ by current thread, check if the displaced\n+    if (hash) {                          \/\/ header contains hash code\n@@ -795,2 +795,2 @@\n-  assert(mark->is_neutral(), \"invariant\");\n-  hash = mark->hash();\n+  assert(mark.is_neutral(), \"invariant\");\n+  hash = mark.hash();\n@@ -799,3 +799,4 @@\n-    temp = mark->copy_set_hash(hash); \/\/ merge hash code into header\n-    assert(temp->is_neutral(), \"invariant\");\n-    test = Atomic::cmpxchg(temp, monitor->header_addr(), mark);\n+    temp = mark.copy_set_hash(hash); \/\/ merge hash code into header\n+    assert(temp.is_neutral(), \"invariant\");\n+    uintptr_t v = Atomic::cmpxchg(temp.value(), (volatile uintptr_t*)monitor->header_addr(), mark.value());\n+    test = markWord(v);\n@@ -806,2 +807,2 @@\n-      hash = test->hash();\n-      assert(test->is_neutral(), \"invariant\");\n+      hash = test.hash();\n+      assert(test.is_neutral(), \"invariant\");\n@@ -826,1 +827,1 @@\n-    assert(!h_obj->mark()->has_bias_pattern(), \"biases should be revoked by now\");\n+    assert(!h_obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -832,1 +833,1 @@\n-  markOop mark = ReadStableMark(obj);\n+  markWord mark = ReadStableMark(obj);\n@@ -835,2 +836,2 @@\n-  if (mark->has_locker()) {\n-    return thread->is_lock_owned((address)mark->locker());\n+  if (mark.has_locker()) {\n+    return thread->is_lock_owned((address)mark.locker());\n@@ -839,2 +840,2 @@\n-  if (mark->has_monitor()) {\n-    ObjectMonitor* monitor = mark->monitor();\n+  if (mark.has_monitor()) {\n+    ObjectMonitor* monitor = mark.monitor();\n@@ -844,1 +845,1 @@\n-  assert(mark->is_neutral(), \"sanity check\");\n+  assert(mark.is_neutral(), \"sanity check\");\n@@ -862,1 +863,1 @@\n-  if (UseBiasedLocking && h_obj()->mark()->has_bias_pattern()) {\n+  if (UseBiasedLocking && h_obj()->mark().has_bias_pattern()) {\n@@ -865,1 +866,1 @@\n-    assert(!h_obj->mark()->has_bias_pattern(),\n+    assert(!h_obj->mark().has_bias_pattern(),\n@@ -871,1 +872,1 @@\n-  markOop mark = ReadStableMark(obj);\n+  markWord mark = ReadStableMark(obj);\n@@ -874,2 +875,2 @@\n-  if (mark->has_locker()) {\n-    return self->is_lock_owned((address)mark->locker()) ?\n+  if (mark.has_locker()) {\n+    return self->is_lock_owned((address)mark.locker()) ?\n@@ -882,2 +883,2 @@\n-  if (mark->has_monitor()) {\n-    void * owner = mark->monitor()->_owner;\n+  if (mark.has_monitor()) {\n+    void * owner = mark.monitor()->_owner;\n@@ -890,1 +891,1 @@\n-  assert(mark->is_neutral(), \"sanity check\");\n+  assert(mark.is_neutral(), \"sanity check\");\n@@ -902,1 +903,1 @@\n-    assert(!h_obj->mark()->has_bias_pattern(), \"biases should be revoked by now\");\n+    assert(!h_obj->mark().has_bias_pattern(), \"biases should be revoked by now\");\n@@ -908,1 +909,1 @@\n-  markOop mark = ReadStableMark(obj);\n+  markWord mark = ReadStableMark(obj);\n@@ -911,2 +912,2 @@\n-  if (mark->has_locker()) {\n-    owner = (address) mark->locker();\n+  if (mark.has_locker()) {\n+    owner = (address) mark.locker();\n@@ -916,2 +917,2 @@\n-  if (mark->has_monitor()) {\n-    ObjectMonitor* monitor = mark->monitor();\n+  if (mark.has_monitor()) {\n+    ObjectMonitor* monitor = mark.monitor();\n@@ -930,1 +931,1 @@\n-  \/\/ assert(mark->is_neutral(), \"sanity check\");\n+  \/\/ assert(mark.is_neutral(), \"sanity check\");\n@@ -1376,5 +1377,5 @@\n-  markOop mark = obj->mark();\n-  if (mark->has_monitor()) {\n-    assert(ObjectSynchronizer::verify_objmon_isinpool(mark->monitor()), \"monitor is invalid\");\n-    assert(mark->monitor()->header()->is_neutral(), \"monitor must record a good object header\");\n-    return mark->monitor();\n+  markWord mark = obj->mark();\n+  if (mark.has_monitor()) {\n+    assert(ObjectSynchronizer::verify_objmon_isinpool(mark.monitor()), \"monitor is invalid\");\n+    assert(mark.monitor()->header().is_neutral(), \"monitor must record a good object header\");\n+    return mark.monitor();\n@@ -1399,2 +1400,2 @@\n-    const markOop mark = object->mark();\n-    assert(!mark->has_bias_pattern(), \"invariant\");\n+    const markWord mark = object->mark();\n+    assert(!mark.has_bias_pattern(), \"invariant\");\n@@ -1410,3 +1411,3 @@\n-    if (mark->has_monitor()) {\n-      ObjectMonitor * inf = mark->monitor();\n-      assert(inf->header()->is_neutral(), \"invariant\");\n+    if (mark.has_monitor()) {\n+      ObjectMonitor * inf = mark.monitor();\n+      assert(inf->header().is_neutral(), \"invariant\");\n@@ -1424,1 +1425,1 @@\n-    if (mark == markOopDesc::INFLATING()) {\n+    if (mark == markWord::INFLATING()) {\n@@ -1449,1 +1450,1 @@\n-    if (mark->has_locker()) {\n+    if (mark.has_locker()) {\n@@ -1459,1 +1460,1 @@\n-      markOop cmp = object->cas_set_mark(markOopDesc::INFLATING(), mark);\n+      markWord cmp = object->cas_set_mark(markWord::INFLATING(), mark);\n@@ -1487,1 +1488,1 @@\n-      \/\/ Critically, while object->mark is 0 mark->displaced_mark_helper() is stable.\n+      \/\/ Critically, while object->mark is 0 mark.displaced_mark_helper() is stable.\n@@ -1495,2 +1496,2 @@\n-      markOop dmw = mark->displaced_mark_helper();\n-      assert(dmw->is_neutral(), \"invariant\");\n+      markWord dmw = mark.displaced_mark_helper();\n+      assert(dmw.is_neutral(), \"invariant\");\n@@ -1501,1 +1502,1 @@\n-      \/\/ Optimization: if the mark->locker stack address is associated\n+      \/\/ Optimization: if the mark.locker stack address is associated\n@@ -1506,1 +1507,1 @@\n-      m->set_owner(mark->locker());\n+      m->set_owner(mark.locker());\n@@ -1512,2 +1513,2 @@\n-      guarantee(object->mark() == markOopDesc::INFLATING(), \"invariant\");\n-      object->release_set_mark(markOopDesc::encode(m));\n+      guarantee(object->mark() == markWord::INFLATING(), \"invariant\");\n+      object->release_set_mark(markWord::encode(m));\n@@ -1523,1 +1524,1 @@\n-                                      p2i(object), p2i(object->mark()),\n+                                      p2i(object), object->mark().value(),\n@@ -1543,1 +1544,1 @@\n-    assert(mark->is_neutral(), \"invariant\");\n+    assert(mark.is_neutral(), \"invariant\");\n@@ -1554,1 +1555,1 @@\n-    if (object->cas_set_mark(markOopDesc::encode(m), mark) != mark) {\n+    if (object->cas_set_mark(markWord::encode(m), mark) != mark) {\n@@ -1574,1 +1575,1 @@\n-                                    p2i(object), p2i(object->mark()),\n+                                    p2i(object), object->mark().value(),\n@@ -1625,3 +1626,3 @@\n-  guarantee(obj->mark() == markOopDesc::encode(mid), \"invariant\");\n-  guarantee(mid == obj->mark()->monitor(), \"invariant\");\n-  guarantee(mid->header()->is_neutral(), \"invariant\");\n+  guarantee(obj->mark() == markWord::encode(mid), \"invariant\");\n+  guarantee(mid == obj->mark().monitor(), \"invariant\");\n+  guarantee(mid->header().is_neutral(), \"invariant\");\n@@ -1642,1 +1643,1 @@\n-                                    p2i(obj), p2i(obj->mark()),\n+                                    p2i(obj), obj->mark().value(),\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":128,"deletions":127,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-    const int alignment = markOopDesc::biased_lock_alignment;\n+    const int alignment = markWord::biased_lock_alignment;\n@@ -307,1 +307,1 @@\n-    assert((((uintptr_t) this) & (markOopDesc::biased_lock_alignment - 1)) == 0, \"forced alignment of thread object failed\");\n+    assert((((uintptr_t) this) & (markWord::biased_lock_alignment - 1)) == 0, \"forced alignment of thread object failed\");\n@@ -309,1 +309,1 @@\n-           this == align_up(_real_malloc_address, (int)markOopDesc::biased_lock_alignment),\n+           this == align_up(_real_malloc_address, (int)markWord::biased_lock_alignment),\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-        markOop mark = NULL;\n+        markWord mark = markWord::zero();\n@@ -234,1 +234,1 @@\n-          if (mark->has_monitor() &&\n+          if (mark.has_monitor() &&\n@@ -236,1 +236,1 @@\n-                mark->monitor() == thread()->current_pending_monitor() ||\n+                mark.monitor() == thread()->current_pending_monitor() ||\n@@ -238,1 +238,1 @@\n-                !mark->monitor()->is_entered(thread())\n+                !mark.monitor()->is_entered(thread())\n@@ -244,1 +244,1 @@\n-            mark = NULL;\n+            mark = markWord::zero();\n@@ -253,1 +253,1 @@\n-          if (mark->has_monitor() &&\n+          if (mark.has_monitor() &&\n@@ -255,1 +255,1 @@\n-                mark->monitor() == thread()->current_pending_monitor() ||\n+                mark.monitor() == thread()->current_pending_monitor() ||\n@@ -257,1 +257,1 @@\n-                !mark->monitor()->is_entered(thread())\n+                !mark.monitor()->is_entered(thread())\n@@ -263,1 +263,1 @@\n-            mark = NULL;\n+            mark = markWord::zero();\n@@ -267,1 +267,1 @@\n-        if (ObjectMonitor::Knob_Verbose && mark != NULL) {\n+        if (ObjectMonitor::Knob_Verbose && mark.to_pointer() != NULL) {\n@@ -269,1 +269,1 @@\n-          mark->print_on(st);\n+          mark.print_on(st);\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-#include \"oops\/markOop.hpp\"\n+#include \"oops\/markWord.hpp\"\n@@ -206,1 +206,1 @@\n-  volatile_nonstatic_field(oopDesc,            _mark,                                         markOop)                               \\\n+  volatile_nonstatic_field(oopDesc,            _mark,                                         markWord)                              \\\n@@ -269,1 +269,1 @@\n-  nonstatic_field(Klass,                       _prototype_header,                             markOop)                               \\\n+  nonstatic_field(Klass,                       _prototype_header,                             markWord)                              \\\n@@ -927,1 +927,1 @@\n-  volatile_nonstatic_field(ObjectMonitor,      _header,                                       markOop)                               \\\n+  volatile_nonstatic_field(ObjectMonitor,      _header,                                       markWord)                              \\\n@@ -934,1 +934,1 @@\n-  volatile_nonstatic_field(BasicLock,          _displaced_header,                             markOop)                               \\\n+  volatile_nonstatic_field(BasicLock,          _displaced_header,                             markWord)                              \\\n@@ -1288,1 +1288,0 @@\n-    declare_type(markOopDesc, oopDesc)                                    \\\n@@ -1328,1 +1327,0 @@\n-  declare_oop_type(markOop)                                               \\\n@@ -1983,1 +1981,2 @@\n-   declare_integer_type(AccessFlags)  \/* FIXME: wrong type (not integer) *\/\\\n+  declare_integer_type(AccessFlags)  \/* FIXME: wrong type (not integer) *\/\\\n+  declare_integer_type(markWord)                                          \\\n@@ -1985,1 +1984,1 @@\n-   declare_integer_type(BasicType)   \/* FIXME: wrong type (not integer) *\/\\\n+  declare_integer_type(BasicType)   \/* FIXME: wrong type (not integer) *\/ \\\n@@ -2638,1 +2637,1 @@\n-  \/* MarkOop constants *\/                                                 \\\n+  \/* MarkWord constants *\/                                                \\\n@@ -2645,39 +2644,39 @@\n-  declare_constant(markOopDesc::age_bits)                                 \\\n-  declare_constant(markOopDesc::lock_bits)                                \\\n-  declare_constant(markOopDesc::biased_lock_bits)                         \\\n-  declare_constant(markOopDesc::max_hash_bits)                            \\\n-  declare_constant(markOopDesc::hash_bits)                                \\\n-                                                                          \\\n-  declare_constant(markOopDesc::lock_shift)                               \\\n-  declare_constant(markOopDesc::biased_lock_shift)                        \\\n-  declare_constant(markOopDesc::age_shift)                                \\\n-  declare_constant(markOopDesc::hash_shift)                               \\\n-                                                                          \\\n-  declare_constant(markOopDesc::lock_mask)                                \\\n-  declare_constant(markOopDesc::lock_mask_in_place)                       \\\n-  declare_constant(markOopDesc::biased_lock_mask)                         \\\n-  declare_constant(markOopDesc::biased_lock_mask_in_place)                \\\n-  declare_constant(markOopDesc::biased_lock_bit_in_place)                 \\\n-  declare_constant(markOopDesc::age_mask)                                 \\\n-  declare_constant(markOopDesc::age_mask_in_place)                        \\\n-  declare_constant(markOopDesc::epoch_mask)                               \\\n-  declare_constant(markOopDesc::epoch_mask_in_place)                      \\\n-  declare_constant(markOopDesc::hash_mask)                                \\\n-  declare_constant(markOopDesc::hash_mask_in_place)                       \\\n-  declare_constant(markOopDesc::biased_lock_alignment)                    \\\n-                                                                          \\\n-  declare_constant(markOopDesc::locked_value)                             \\\n-  declare_constant(markOopDesc::unlocked_value)                           \\\n-  declare_constant(markOopDesc::monitor_value)                            \\\n-  declare_constant(markOopDesc::marked_value)                             \\\n-  declare_constant(markOopDesc::biased_lock_pattern)                      \\\n-                                                                          \\\n-  declare_constant(markOopDesc::no_hash)                                  \\\n-  declare_constant(markOopDesc::no_hash_in_place)                         \\\n-  declare_constant(markOopDesc::no_lock_in_place)                         \\\n-  declare_constant(markOopDesc::max_age)                                  \\\n-                                                                          \\\n-  \/* Constants in markOop used by CMS. *\/                                 \\\n-  declare_constant(markOopDesc::cms_shift)                                \\\n-  declare_constant(markOopDesc::cms_mask)                                 \\\n-  declare_constant(markOopDesc::size_shift)                               \\\n+  declare_constant(markWord::age_bits)                                    \\\n+  declare_constant(markWord::lock_bits)                                   \\\n+  declare_constant(markWord::biased_lock_bits)                            \\\n+  declare_constant(markWord::max_hash_bits)                               \\\n+  declare_constant(markWord::hash_bits)                                   \\\n+                                                                          \\\n+  declare_constant(markWord::lock_shift)                                  \\\n+  declare_constant(markWord::biased_lock_shift)                           \\\n+  declare_constant(markWord::age_shift)                                   \\\n+  declare_constant(markWord::hash_shift)                                  \\\n+                                                                          \\\n+  declare_constant(markWord::lock_mask)                                   \\\n+  declare_constant(markWord::lock_mask_in_place)                          \\\n+  declare_constant(markWord::biased_lock_mask)                            \\\n+  declare_constant(markWord::biased_lock_mask_in_place)                   \\\n+  declare_constant(markWord::biased_lock_bit_in_place)                    \\\n+  declare_constant(markWord::age_mask)                                    \\\n+  declare_constant(markWord::age_mask_in_place)                           \\\n+  declare_constant(markWord::epoch_mask)                                  \\\n+  declare_constant(markWord::epoch_mask_in_place)                         \\\n+  declare_constant(markWord::hash_mask)                                   \\\n+  declare_constant(markWord::hash_mask_in_place)                          \\\n+  declare_constant(markWord::biased_lock_alignment)                       \\\n+                                                                          \\\n+  declare_constant(markWord::locked_value)                                \\\n+  declare_constant(markWord::unlocked_value)                              \\\n+  declare_constant(markWord::monitor_value)                               \\\n+  declare_constant(markWord::marked_value)                                \\\n+  declare_constant(markWord::biased_lock_pattern)                         \\\n+                                                                          \\\n+  declare_constant(markWord::no_hash)                                     \\\n+  declare_constant(markWord::no_hash_in_place)                            \\\n+  declare_constant(markWord::no_lock_in_place)                            \\\n+  declare_constant(markWord::max_age)                                     \\\n+                                                                          \\\n+  \/* Constants in markWord used by CMS. *\/                                \\\n+  declare_constant(markWord::cms_shift)                                   \\\n+  declare_constant(markWord::cms_mask)                                    \\\n+  declare_constant(markWord::size_shift)                                  \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":48,"deletions":49,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -658,8 +658,1 @@\n-        \/\/ HACK: turn markOop into a C integer type. This allows\n-        \/\/ proper handling of it in the Serviceability Agent. (FIXME\n-        \/\/ -- consider doing something different here)\n-        if (typeName.equals(\"markOop\")) {\n-          type = new BasicCIntegerType(this, typeName, true);\n-        } else {\n-          type.setIsOopType(true);\n-        }\n+        type.setIsOopType(true);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HotSpotTypeDataBase.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,6 +35,0 @@\n-\/** Mark is the analogue of the VM's markOop. In this system it does\n-    not subclass Oop but VMObject. For a mark on the stack, the mark's\n-    address will be an Address; for a mark in the header of an object,\n-    it will be an OopHandle. It is assumed in a couple of places in\n-    this code that the mark is the first word in an object. *\/\n-\n@@ -54,33 +48,33 @@\n-    ageBits             = db.lookupLongConstant(\"markOopDesc::age_bits\").longValue();\n-    lockBits            = db.lookupLongConstant(\"markOopDesc::lock_bits\").longValue();\n-    biasedLockBits      = db.lookupLongConstant(\"markOopDesc::biased_lock_bits\").longValue();\n-    maxHashBits         = db.lookupLongConstant(\"markOopDesc::max_hash_bits\").longValue();\n-    hashBits            = db.lookupLongConstant(\"markOopDesc::hash_bits\").longValue();\n-    lockShift           = db.lookupLongConstant(\"markOopDesc::lock_shift\").longValue();\n-    biasedLockShift     = db.lookupLongConstant(\"markOopDesc::biased_lock_shift\").longValue();\n-    ageShift            = db.lookupLongConstant(\"markOopDesc::age_shift\").longValue();\n-    hashShift           = db.lookupLongConstant(\"markOopDesc::hash_shift\").longValue();\n-    lockMask            = db.lookupLongConstant(\"markOopDesc::lock_mask\").longValue();\n-    lockMaskInPlace     = db.lookupLongConstant(\"markOopDesc::lock_mask_in_place\").longValue();\n-    biasedLockMask      = db.lookupLongConstant(\"markOopDesc::biased_lock_mask\").longValue();\n-    biasedLockMaskInPlace  = db.lookupLongConstant(\"markOopDesc::biased_lock_mask_in_place\").longValue();\n-    biasedLockBitInPlace  = db.lookupLongConstant(\"markOopDesc::biased_lock_bit_in_place\").longValue();\n-    ageMask             = db.lookupLongConstant(\"markOopDesc::age_mask\").longValue();\n-    ageMaskInPlace      = db.lookupLongConstant(\"markOopDesc::age_mask_in_place\").longValue();\n-    hashMask            = db.lookupLongConstant(\"markOopDesc::hash_mask\").longValue();\n-    hashMaskInPlace     = db.lookupLongConstant(\"markOopDesc::hash_mask_in_place\").longValue();\n-    biasedLockAlignment  = db.lookupLongConstant(\"markOopDesc::biased_lock_alignment\").longValue();\n-    lockedValue         = db.lookupLongConstant(\"markOopDesc::locked_value\").longValue();\n-    unlockedValue       = db.lookupLongConstant(\"markOopDesc::unlocked_value\").longValue();\n-    monitorValue        = db.lookupLongConstant(\"markOopDesc::monitor_value\").longValue();\n-    markedValue         = db.lookupLongConstant(\"markOopDesc::marked_value\").longValue();\n-    biasedLockPattern = db.lookupLongConstant(\"markOopDesc::biased_lock_pattern\").longValue();\n-    noHash              = db.lookupLongConstant(\"markOopDesc::no_hash\").longValue();\n-    noHashInPlace       = db.lookupLongConstant(\"markOopDesc::no_hash_in_place\").longValue();\n-    noLockInPlace       = db.lookupLongConstant(\"markOopDesc::no_lock_in_place\").longValue();\n-    maxAge              = db.lookupLongConstant(\"markOopDesc::max_age\").longValue();\n-\n-    \/* Constants in markOop used by CMS. *\/\n-    cmsShift            = db.lookupLongConstant(\"markOopDesc::cms_shift\").longValue();\n-    cmsMask             = db.lookupLongConstant(\"markOopDesc::cms_mask\").longValue();\n-    sizeShift           = db.lookupLongConstant(\"markOopDesc::size_shift\").longValue();\n+    ageBits             = db.lookupLongConstant(\"markWord::age_bits\").longValue();\n+    lockBits            = db.lookupLongConstant(\"markWord::lock_bits\").longValue();\n+    biasedLockBits      = db.lookupLongConstant(\"markWord::biased_lock_bits\").longValue();\n+    maxHashBits         = db.lookupLongConstant(\"markWord::max_hash_bits\").longValue();\n+    hashBits            = db.lookupLongConstant(\"markWord::hash_bits\").longValue();\n+    lockShift           = db.lookupLongConstant(\"markWord::lock_shift\").longValue();\n+    biasedLockShift     = db.lookupLongConstant(\"markWord::biased_lock_shift\").longValue();\n+    ageShift            = db.lookupLongConstant(\"markWord::age_shift\").longValue();\n+    hashShift           = db.lookupLongConstant(\"markWord::hash_shift\").longValue();\n+    lockMask            = db.lookupLongConstant(\"markWord::lock_mask\").longValue();\n+    lockMaskInPlace     = db.lookupLongConstant(\"markWord::lock_mask_in_place\").longValue();\n+    biasedLockMask      = db.lookupLongConstant(\"markWord::biased_lock_mask\").longValue();\n+    biasedLockMaskInPlace  = db.lookupLongConstant(\"markWord::biased_lock_mask_in_place\").longValue();\n+    biasedLockBitInPlace  = db.lookupLongConstant(\"markWord::biased_lock_bit_in_place\").longValue();\n+    ageMask             = db.lookupLongConstant(\"markWord::age_mask\").longValue();\n+    ageMaskInPlace      = db.lookupLongConstant(\"markWord::age_mask_in_place\").longValue();\n+    hashMask            = db.lookupLongConstant(\"markWord::hash_mask\").longValue();\n+    hashMaskInPlace     = db.lookupLongConstant(\"markWord::hash_mask_in_place\").longValue();\n+    biasedLockAlignment  = db.lookupLongConstant(\"markWord::biased_lock_alignment\").longValue();\n+    lockedValue         = db.lookupLongConstant(\"markWord::locked_value\").longValue();\n+    unlockedValue       = db.lookupLongConstant(\"markWord::unlocked_value\").longValue();\n+    monitorValue        = db.lookupLongConstant(\"markWord::monitor_value\").longValue();\n+    markedValue         = db.lookupLongConstant(\"markWord::marked_value\").longValue();\n+    biasedLockPattern = db.lookupLongConstant(\"markWord::biased_lock_pattern\").longValue();\n+    noHash              = db.lookupLongConstant(\"markWord::no_hash\").longValue();\n+    noHashInPlace       = db.lookupLongConstant(\"markWord::no_hash_in_place\").longValue();\n+    noLockInPlace       = db.lookupLongConstant(\"markWord::no_lock_in_place\").longValue();\n+    maxAge              = db.lookupLongConstant(\"markWord::max_age\").longValue();\n+\n+    \/* Constants in markWord used by CMS. *\/\n+    cmsShift            = db.lookupLongConstant(\"markWord::cms_shift\").longValue();\n+    cmsMask             = db.lookupLongConstant(\"markWord::cms_mask\").longValue();\n+    sizeShift           = db.lookupLongConstant(\"markWord::size_shift\").longValue();\n@@ -128,1 +122,1 @@\n-  \/* Constants in markOop used by CMS. *\/\n+  \/* Constants in markWord used by CMS. *\/\n@@ -178,1 +172,1 @@\n-  \/\/ Special temporary state of the markOop while being inflated.\n+  \/\/ Special temporary state of the markWord while being inflated.\n@@ -191,1 +185,1 @@\n-  \/\/ They must get updated if markOop layout get changed.\n+  \/\/ They must get updated if markWord layout get changed.\n@@ -193,4 +187,0 @@\n-  \/\/ FIXME\n-  \/\/  markOop set_unlocked() const {\n-  \/\/    return markOop(value() | unlocked_value);\n-  \/\/  }\n@@ -227,32 +217,0 @@\n-  \/\/ FIXME\n-  \/\/  void set_displaced_mark_helper(markOop m) const {\n-  \/\/    assert(has_displaced_mark_helper(), \"check\");\n-  \/\/    intptr_t ptr = (value() & ~monitor_value);\n-  \/\/    *(markOop*)ptr = m;\n-  \/\/  }\n-  \/\/  markOop copy_set_hash(intptr_t hash) const {\n-  \/\/    intptr_t tmp = value() & (~hash_mask_in_place);\n-  \/\/    tmp |= ((hash & hash_mask) << hash_shift);\n-  \/\/    return (markOop)tmp;\n-  \/\/  }\n-  \/\/ it is only used to be stored into BasicLock as the\n-  \/\/ indicator that the lock is using heavyweight monitor\n-  \/\/  static markOop unused_mark() {\n-  \/\/    return (markOop) marked_value;\n-  \/\/  }\n-  \/\/  \/\/ the following two functions create the markOop to be\n-  \/\/  \/\/ stored into object header, it encodes monitor info\n-  \/\/  static markOop encode(BasicLock* lock) {\n-  \/\/    return (markOop) lock;\n-  \/\/  }\n-  \/\/  static markOop encode(ObjectMonitor* monitor) {\n-  \/\/    intptr_t tmp = (intptr_t) monitor;\n-  \/\/    return (markOop) (tmp | monitor_value);\n-  \/\/  }\n-  \/\/ used for alignment-based marking to reuse the busy state to encode pointers\n-  \/\/ (see markOop_alignment.hpp)\n-  \/\/  markOop clear_lock_bits() { return markOop(value() & ~lock_mask_in_place); }\n-  \/\/\n-  \/\/  \/\/ age operations\n-  \/\/  markOop set_marked()   { return markOop((value() & ~lock_mask_in_place) | marked_value); }\n-  \/\/\n@@ -260,5 +218,0 @@\n-  \/\/  markOop set_age(int v) const {\n-  \/\/    assert((v & ~age_mask) == 0, \"shouldn't overflow age field\");\n-  \/\/    return markOop((value() & ~age_mask_in_place) | (((intptr_t)v & age_mask) << age_shift));\n-  \/\/  }\n-  \/\/  markOop incr_age()          const { return age() == max_age ? markOop(this) : set_age(age() + 1); }\n@@ -275,6 +228,0 @@\n-  \/\/ FIXME\n-  \/\/ Prototype mark for initialization\n-  \/\/  static markOop prototype() {\n-  \/\/    return markOop( no_hash_in_place | no_lock_in_place );\n-  \/\/  }\n-\n@@ -297,8 +244,1 @@\n-  \/\/ FIXME\n-  \/\/  \/\/ Prepare address of oop for placement into mark\n-  \/\/  inline static markOop encode_pointer_as_mark(void* p) { return markOop(p)->set_marked(); }\n-  \/\/\n-  \/\/  \/\/ Recover address of oop from encoded form used in mark\n-  \/\/  inline void* decode_pointer() { return clear_lock_bits(); }\n-\n-  \/\/ Copy markOop methods for CMS here.\n+  \/\/ Copy markWord methods for CMS here.\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Mark.java","additions":37,"deletions":97,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-  \/\/  void      set_header(markOop hdr);\n+  \/\/  void      set_header(markWord hdr);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectMonitor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    final int prototypeMarkWordOffset = getFieldOffset(\"Klass::_prototype_header\", Integer.class, \"markOop\");\n+    final int prototypeMarkWordOffset = getFieldOffset(\"Klass::_prototype_header\", Integer.class, \"markWord\");\n@@ -137,2 +137,2 @@\n-    private final int markWordNoHashInPlace = getConstant(\"markOopDesc::no_hash_in_place\", Integer.class);\n-    private final int markWordNoLockInPlace = getConstant(\"markOopDesc::no_lock_in_place\", Integer.class);\n+    private final int markWordNoHashInPlace = getConstant(\"markWord::no_hash_in_place\", Integer.class);\n+    private final int markWordNoLockInPlace = getConstant(\"markWord::no_lock_in_place\", Integer.class);\n@@ -141,1 +141,1 @@\n-     * See {@code markOopDesc::prototype()}.\n+     * See {@code markWord::prototype()}.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-    public final int markOffset = getFieldOffset(\"oopDesc::_mark\", Integer.class, \"markOop\");\n+    public final int markOffset = getFieldOffset(\"oopDesc::_mark\", Integer.class, \"markWord\");\n@@ -201,1 +201,1 @@\n-    public final int prototypeMarkWordOffset = getFieldOffset(\"Klass::_prototype_header\", Integer.class, \"markOop\");\n+    public final int prototypeMarkWordOffset = getFieldOffset(\"Klass::_prototype_header\", Integer.class, \"markWord\");\n@@ -402,1 +402,1 @@\n-    public final long markOopDescHashShift = getConstant(\"markOopDesc::hash_shift\", Long.class);\n+    public final long markWordHashShift = getConstant(\"markWord::hash_shift\", Long.class);\n@@ -404,5 +404,5 @@\n-    public final int biasedLockMaskInPlace = getConstant(\"markOopDesc::biased_lock_mask_in_place\", Integer.class);\n-    public final int ageMaskInPlace = getConstant(\"markOopDesc::age_mask_in_place\", Integer.class);\n-    public final int epochMaskInPlace = getConstant(\"markOopDesc::epoch_mask_in_place\", Integer.class);\n-    public final long markOopDescHashMask = getConstant(\"markOopDesc::hash_mask\", Long.class);\n-    public final long markOopDescHashMaskInPlace = getConstant(\"markOopDesc::hash_mask_in_place\", Long.class);\n+    public final int biasedLockMaskInPlace = getConstant(\"markWord::biased_lock_mask_in_place\", Integer.class);\n+    public final int ageMaskInPlace = getConstant(\"markWord::age_mask_in_place\", Integer.class);\n+    public final int epochMaskInPlace = getConstant(\"markWord::epoch_mask_in_place\", Integer.class);\n+    public final long markWordHashMask = getConstant(\"markWord::hash_mask\", Long.class);\n+    public final long markWordHashMaskInPlace = getConstant(\"markWord::hash_mask_in_place\", Long.class);\n@@ -410,3 +410,3 @@\n-    public final int unlockedMask = getConstant(\"markOopDesc::unlocked_value\", Integer.class);\n-    public final int monitorMask = getConstant(\"markOopDesc::monitor_value\", Integer.class, -1);\n-    public final int biasedLockPattern = getConstant(\"markOopDesc::biased_lock_pattern\", Integer.class);\n+    public final int unlockedMask = getConstant(\"markWord::unlocked_value\", Integer.class);\n+    public final int monitorMask = getConstant(\"markWord::monitor_value\", Integer.class, -1);\n+    public final int biasedLockPattern = getConstant(\"markWord::biased_lock_pattern\", Integer.class);\n@@ -420,2 +420,2 @@\n-    public final int markWordNoHashInPlace = getConstant(\"markOopDesc::no_hash_in_place\", Integer.class);\n-    public final int markWordNoLockInPlace = getConstant(\"markOopDesc::no_lock_in_place\", Integer.class);\n+    public final int markWordNoHashInPlace = getConstant(\"markWord::no_hash_in_place\", Integer.class);\n+    public final int markWordNoLockInPlace = getConstant(\"markWord::no_lock_in_place\", Integer.class);\n@@ -424,1 +424,1 @@\n-     * See {@code markOopDesc::prototype()}.\n+     * See {@code markWord::prototype()}.\n@@ -431,1 +431,1 @@\n-     * See {@code markOopDesc::copy_set_hash()}.\n+     * See {@code markWord::copy_set_hash()}.\n@@ -434,2 +434,2 @@\n-        long tmp = arrayPrototypeMarkWord() & (~markOopDescHashMaskInPlace);\n-        tmp |= ((0x2 & markOopDescHashMask) << markOopDescHashShift);\n+        long tmp = arrayPrototypeMarkWord() & (~markWordHashMaskInPlace);\n+        tmp |= ((0x2 & markWordHashMask) << markWordHashShift);\n@@ -442,1 +442,1 @@\n-    public final int identityHashCodeShift = getConstant(\"markOopDesc::hash_shift\", Integer.class);\n+    public final int identityHashCodeShift = getConstant(\"markWord::hash_shift\", Integer.class);\n@@ -447,1 +447,1 @@\n-    public final int uninitializedIdentityHashCodeValue = getConstant(\"markOopDesc::no_hash\", Integer.class);\n+    public final int uninitializedIdentityHashCodeValue = getConstant(\"markWord::no_hash\", Integer.class);\n@@ -521,1 +521,1 @@\n-    public final int basicLockDisplacedHeaderOffset = getFieldOffset(\"BasicLock::_displaced_header\", Integer.class, \"markOop\");\n+    public final int basicLockDisplacedHeaderOffset = getFieldOffset(\"BasicLock::_displaced_header\", Integer.class, \"markWord\");\n","filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot\/src\/org\/graalvm\/compiler\/hotspot\/GraalHotSpotVMConfig.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n- * Comment below is reproduced from {@code markOop.hpp} for convenience:\n+ * Comment below is reproduced from {@code markWord.hpp} for convenience:\n","filename":"src\/jdk.internal.vm.compiler\/share\/classes\/org.graalvm.compiler.hotspot\/src\/org\/graalvm\/compiler\/hotspot\/replacements\/MonitorSnippets.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/BasicLogEvent.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/CallSite.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/Compilation.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/Constants.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogCleanupReader.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogCompilation$MethodBCIPair.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogCompilation.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogEvent.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogParser$1.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogParser$2.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogParser$3.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogParser$Jvms.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogParser$LockElimination.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/LogParser.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/MakeNotEntrantEvent.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/Method.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/NMethod.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/Phase.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/UncommonTrap.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/classes\/com\/sun\/hotspot\/tools\/compiler\/UncommonTrapEvent.class","binary":true,"status":"added"},{"filename":"src\/utils\/LogCompilation\/target\/test-classes\/com\/sun\/hotspot\/tools\/compiler\/TestLogCompilation.class","binary":true,"status":"added"},{"patch":"@@ -45,2 +45,2 @@\n-  markOop mark() { return _oop.mark_raw(); }\n-  void set_mark(markOop m) { _oop.set_mark_raw(m); }\n+  markWord mark() { return _oop.mark_raw(); }\n+  void set_mark(markWord m) { _oop.set_mark_raw(m); }\n@@ -48,1 +48,1 @@\n-    markOop m = markOopDesc::encode_pointer_as_mark(obj);\n+    markWord m = markWord::encode_pointer_as_mark(obj);\n@@ -52,2 +52,2 @@\n-  static markOop originalMark() { return markOop(markOopDesc::lock_mask_in_place); }\n-  static markOop changedMark()  { return markOop(0x4711); }\n+  static markWord originalMark() { return markWord(markWord::lock_mask_in_place); }\n+  static markWord changedMark()  { return markWord(0x4711); }\n@@ -56,0 +56,2 @@\n+#define ASSERT_MARK_WORD_EQ(a, b) ASSERT_EQ((a).value(), (b).value())\n+\n@@ -68,4 +70,4 @@\n-  ASSERT_EQ(o1.mark(), FakeOop::originalMark());\n-  ASSERT_EQ(o2.mark(), FakeOop::originalMark());\n-  ASSERT_EQ(o3.mark(), FakeOop::originalMark());\n-  ASSERT_EQ(o4.mark(), FakeOop::originalMark());\n+  ASSERT_MARK_WORD_EQ(o1.mark(), FakeOop::originalMark());\n+  ASSERT_MARK_WORD_EQ(o2.mark(), FakeOop::originalMark());\n+  ASSERT_MARK_WORD_EQ(o3.mark(), FakeOop::originalMark());\n+  ASSERT_MARK_WORD_EQ(o4.mark(), FakeOop::originalMark());\n@@ -76,2 +78,2 @@\n-  ASSERT_EQ(o1.mark(), FakeOop::changedMark());\n-  ASSERT_EQ(o2.mark(), FakeOop::changedMark());\n+  ASSERT_MARK_WORD_EQ(o1.mark(), FakeOop::changedMark());\n+  ASSERT_MARK_WORD_EQ(o2.mark(), FakeOop::changedMark());\n@@ -95,2 +97,2 @@\n-  ASSERT_EQ(o3.mark(), FakeOop::changedMark());\n-  ASSERT_EQ(o4.mark(), FakeOop::changedMark());\n+  ASSERT_MARK_WORD_EQ(o3.mark(), FakeOop::changedMark());\n+  ASSERT_MARK_WORD_EQ(o4.mark(), FakeOop::changedMark());\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_preservedMarks.cpp","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-                    \"longConstant markOopDesc::locked_value\");\n+                    \"longConstant markWord::locked_value\");\n@@ -68,2 +68,2 @@\n-            expStrMap.put(\"longConstant markOopDesc::locked_value\", List.of(\n-                    \"longConstant markOopDesc::locked_value\"));\n+            expStrMap.put(\"longConstant markWord::locked_value\", List.of(\n+                    \"longConstant markWord::locked_value\"));\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbAttach.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-                    \"longConstant markOopDesc::locked_value\",\n-                    \"longConstant markOopDesc::lock_bits\",\n+                    \"longConstant markWord::locked_value\",\n+                    \"longConstant markWord::lock_bits\",\n@@ -61,2 +61,2 @@\n-                    \"longConstant markOopDesc::locked_value\",\n-                    \"longConstant markOopDesc::lock_bits\",\n+                    \"longConstant markWord::locked_value\",\n+                    \"longConstant markWord::lock_bits\",\n@@ -64,5 +64,5 @@\n-                    \"markOopDesc::epoch_mask_in_place\"));\n-            expStrMap.put(\"longConstant markOopDesc::locked_value\", List.of(\n-                    \"longConstant markOopDesc::locked_value\"));\n-            expStrMap.put(\"longConstant markOopDesc::lock_bits\", List.of(\n-                    \"longConstant markOopDesc::lock_bits\"));\n+                    \"markWord::epoch_mask_in_place\"));\n+            expStrMap.put(\"longConstant markWord::locked_value\", List.of(\n+                    \"longConstant markWord::locked_value\"));\n+            expStrMap.put(\"longConstant markWord::lock_bits\", List.of(\n+                    \"longConstant markWord::lock_bits\"));\n@@ -91,1 +91,1 @@\n-        \/\/ Expected values obtained from the hash_mask_in_place definition in markOop.hpp\n+        \/\/ Expected values obtained from the hash_mask_in_place definition in markWord.hpp\n@@ -96,3 +96,3 @@\n-        \/\/ longConstant markOopDesc::biased_lock_bits 1\n-        \/\/ longConstant markOopDesc::age_shift 3\n-        \/\/ longConstant markOopDesc::hash_mask_in_place 549755813632\n+        \/\/ longConstant markWord::biased_lock_bits 1\n+        \/\/ longConstant markWord::age_shift 3\n+        \/\/ longConstant markWord::hash_mask_in_place 549755813632\n@@ -101,1 +101,1 @@\n-        checkLongValue(\"markOopDesc::hash_mask_in_place\",\n+        checkLongValue(\"markWord::hash_mask_in_place\",\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbLongConstant.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"}]}