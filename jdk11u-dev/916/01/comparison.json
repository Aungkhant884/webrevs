{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.io.InputStream;\n@@ -30,3 +31,3 @@\n-import java.nio.ByteBuffer;\n-import java.nio.channels.FileChannel;\n-import java.nio.file.Path;\n+import java.lang.module.ModuleReader;\n+import java.lang.module.ModuleReference;\n+import java.nio.charset.StandardCharsets;\n@@ -35,0 +36,1 @@\n+import java.util.Arrays;\n@@ -40,0 +42,2 @@\n+import java.util.TreeMap;\n+import java.util.function.Supplier;\n@@ -63,2 +67,2 @@\n-    public ModuleHashes(String algorithm, Map<String, byte[]> nameToHash) {\n-        this.algorithm = algorithm;\n+    ModuleHashes(String algorithm, Map<String, byte[]> nameToHash) {\n+        this.algorithm = Objects.requireNonNull(algorithm);\n@@ -98,2 +102,1 @@\n-     * Computes the hash for the given file with the given message digest\n-     * algorithm.\n+     * Computes a hash from the names and content of a module.\n@@ -101,0 +104,4 @@\n+     * @param reader the module reader to access the module content\n+     * @param algorithm the name of the message digest algorithm to use\n+     * @return the hash\n+     * @throws IllegalArgumentException if digest algorithm is not supported\n@@ -102,1 +109,0 @@\n-     * @throws RuntimeException if the algorithm is not available\n@@ -104,1 +110,2 @@\n-    public static byte[] computeHash(Path file, String algorithm) {\n+    private static byte[] computeHash(ModuleReader reader, String algorithm) {\n+        MessageDigest md;\n@@ -106,11 +113,15 @@\n-            MessageDigest md = MessageDigest.getInstance(algorithm);\n-\n-            \/\/ Ideally we would just mmap the file but this consumes too much\n-            \/\/ memory when jlink is running concurrently on very large jmods\n-            try (FileChannel fc = FileChannel.open(file)) {\n-                ByteBuffer bb = ByteBuffer.allocate(32*1024);\n-                while (fc.read(bb) > 0) {\n-                    bb.flip();\n-                    md.update(bb);\n-                    assert bb.remaining() == 0;\n-                    bb.clear();\n+            md = MessageDigest.getInstance(algorithm);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+        try {\n+            byte[] buf = new byte[32*1024];\n+            reader.list().sorted().forEach(rn -> {\n+                md.update(rn.getBytes(StandardCharsets.UTF_8));\n+                try (InputStream in = reader.open(rn).orElseThrow()) {\n+                    int n;\n+                    while ((n = in.read(buf)) > 0) {\n+                        md.update(buf, 0, n);\n+                    }\n+                } catch (IOException ioe) {\n+                    throw new UncheckedIOException(ioe);\n@@ -118,1 +129,6 @@\n-            }\n+            });\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+        return md.digest();\n+    }\n@@ -120,3 +136,12 @@\n-            return md.digest();\n-        } catch (NoSuchAlgorithmException e) {\n-            throw new RuntimeException(e);\n+    \/**\n+     * Computes a hash from the names and content of a module.\n+     *\n+     * @param supplier supplies the module reader to access the module content\n+     * @param algorithm the name of the message digest algorithm to use\n+     * @return the hash\n+     * @throws IllegalArgumentException if digest algorithm is not supported\n+     * @throws UncheckedIOException if an I\/O error occurs\n+     *\/\n+    static byte[] computeHash(Supplier<ModuleReader> supplier, String algorithm) {\n+        try (ModuleReader reader = supplier.get()) {\n+            return computeHash(reader, algorithm);\n@@ -129,4 +154,2 @@\n-     * Computes the hash for every entry in the given map, returning a\n-     * {@code ModuleHashes} to encapsulate the result. The map key is\n-     * the entry name, typically the module name. The map value is the file\n-     * path to the entry (module artifact).\n+     * Computes the hash from the names and content of a set of modules. Returns\n+     * a {@code ModuleHashes} to encapsulate the result.\n@@ -134,0 +157,2 @@\n+     * @param mrefs the set of modules\n+     * @param algorithm the name of the message digest algorithm to use\n@@ -135,0 +160,2 @@\n+     * @throws IllegalArgumentException if digest algorithm is not supported\n+     * @throws UncheckedIOException if an I\/O error occurs\n@@ -136,6 +163,9 @@\n-    public static ModuleHashes generate(Map<String, Path> map, String algorithm) {\n-        Map<String, byte[]> nameToHash = new HashMap<>();\n-        for (Map.Entry<String, Path> entry: map.entrySet()) {\n-            String name = entry.getKey();\n-            Path path = entry.getValue();\n-            nameToHash.put(name, computeHash(path, algorithm));\n+    static ModuleHashes generate(Set<ModuleReference> mrefs, String algorithm) {\n+        Map<String, byte[]> nameToHash = new TreeMap<>();\n+        for (ModuleReference mref : mrefs) {\n+            try (ModuleReader reader = mref.open()) {\n+                byte[] hash = computeHash(reader, algorithm);\n+                nameToHash.put(mref.descriptor().name(), hash);\n+            } catch (IOException ioe) {\n+                throw new UncheckedIOException(ioe);\n+            }\n@@ -146,0 +176,45 @@\n+    @Override\n+    public int hashCode() {\n+        int h = algorithm.hashCode();\n+        for (Map.Entry<String, byte[]> e : nameToHash.entrySet()) {\n+            h = h * 31 + e.getKey().hashCode();\n+            h = h * 31 + Arrays.hashCode(e.getValue());\n+        }\n+        return h;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (!(obj instanceof ModuleHashes))\n+            return false;\n+        ModuleHashes other = (ModuleHashes) obj;\n+        if (!algorithm.equals(other.algorithm)\n+                || nameToHash.size() != other.nameToHash.size())\n+            return false;\n+        for (Map.Entry<String, byte[]> e : nameToHash.entrySet()) {\n+            String name = e.getKey();\n+            byte[] hash = e.getValue();\n+            if (!Arrays.equals(hash, other.nameToHash.get(name)))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder(algorithm);\n+        sb.append(\" \");\n+        nameToHash.entrySet()\n+                .stream()\n+                .sorted(Map.Entry.comparingByKey())\n+                .forEach(e -> {\n+                    sb.append(e.getKey());\n+                    sb.append(\"=\");\n+                    byte[] ba = e.getValue();\n+                    for (byte b : ba) {\n+                        sb.append(String.format(\"%02x\", b & 0xff));\n+                    }\n+                });\n+        return sb.toString();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleHashes.java","additions":110,"deletions":35,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.module.ModuleReference;\n@@ -31,2 +32,0 @@\n-import java.net.URI;\n-import java.nio.file.Path;\n@@ -37,0 +36,1 @@\n+import java.util.TreeMap;\n@@ -41,1 +41,0 @@\n-import java.util.function.Function;\n@@ -101,1 +100,1 @@\n-        Map<String, ModuleHashes> hashes = new HashMap<>();\n+        Map<String, ModuleHashes> hashes = new TreeMap<>();\n@@ -116,3 +115,6 @@\n-                       Map<String, Path> moduleToPath = ns.stream()\n-                           .collect(toMap(Function.identity(), this::moduleToPath));\n-                       hashes.put(mn, ModuleHashes.generate(moduleToPath, \"SHA-256\"));\n+                       Set<ModuleReference> mrefs = ns.stream()\n+                               .map(name -> configuration.findModule(name)\n+                                                         .orElseThrow(InternalError::new))\n+                               .map(ResolvedModule::reference)\n+                               .collect(toSet());\n+                       hashes.put(mn, ModuleHashes.generate(mrefs, \"SHA-256\"));\n@@ -124,13 +126,0 @@\n-    private Path moduleToPath(String name) {\n-        ResolvedModule rm = configuration.findModule(name).orElseThrow(\n-            () -> new InternalError(\"Selected module \" + name + \" not on module path\"));\n-\n-        URI uri = rm.reference().location().get();\n-        Path path = Path.of(uri);\n-        String fn = path.getFileName().toString();\n-        if (!fn.endsWith(\".jar\") && !fn.endsWith(\".jmod\")) {\n-            throw new UnsupportedOperationException(path + \" is not a modular JAR or jmod file\");\n-        }\n-        return path;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleHashesBuilder.java","additions":10,"deletions":21,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,1 +170,3 @@\n-                    packages.forEach(pn -> mv.visitPackage(pn.replace('.', '\/')));\n+                    packages.stream()\n+                            .sorted()\n+                            .forEach(pn -> mv.visitPackage(pn.replace('.', '\/')));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleInfoExtender.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-        HashSupplier hasher = (a) -> ModuleHashes.computeHash(file, a);\n+        HashSupplier hasher = (a) -> ModuleHashes.computeHash(supplier, a);\n@@ -106,1 +106,1 @@\n-        HashSupplier hasher = (a) -> ModuleHashes.computeHash(file, a);\n+        HashSupplier hasher = (a) -> ModuleHashes.computeHash(supplier, a);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleReferences.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8160286\n+ * @bug 8160286 8243666\n@@ -57,0 +57,1 @@\n+import java.util.Map;\n@@ -87,0 +88,1 @@\n+\n@@ -286,0 +288,23 @@\n+    @Test\n+    public static void testReproducibibleHash() throws Exception {\n+        HashesTest ht = new HashesTest(Path.of(\"repro\"));\n+        ht.makeModule(\"m4\");\n+        ht.makeModule(\"m3\", \"m4\");\n+        ht.makeModule(\"m2\");\n+        ht.makeModule(\"m1\", \"m2\", \"m3\");\n+\n+        \/\/ create JMOD files and run jmod hash\n+        List.of(\"m1\", \"m2\", \"m3\", \"m4\").forEach(ht::makeJmod);\n+        Map<String, ModuleHashes> hashes1 = ht.runJmodHash();\n+\n+        \/\/ sleep a bit to be confident that the hashes aren't dependent on timestamps\n+        Thread.sleep(2000);\n+\n+        \/\/ (re)create JMOD files and run jmod hash\n+        List.of(\"m1\", \"m2\", \"m3\", \"m4\").forEach(ht::makeJmod);\n+        Map<String, ModuleHashes> hashes2 = ht.runJmodHash();\n+\n+        \/\/ hashes should be equal\n+        assertEquals(hashes1, hashes2);\n+    }\n+\n@@ -415,0 +440,19 @@\n+    \/**\n+     * Execute jmod hash on the modules in the lib directory. Returns a map of\n+     * the modules, with the module name as the key, for the modules that have\n+     * a ModuleHashes class file attribute.\n+     *\/\n+    private Map<String, ModuleHashes> runJmodHash() {\n+        runJmod(List.of(\"hash\",\n+                \"--module-path\", lib.toString(),\n+                \"--hash-modules\", \".*\"));\n+        HashesTest ht = this;\n+        return ModulePath.of(Runtime.version(), true, lib)\n+                .findAll()\n+                .stream()\n+                .map(ModuleReference::descriptor)\n+                .map(ModuleDescriptor::name)\n+                .filter(mn -> ht.hashes(mn) != null)\n+                .collect(Collectors.toMap(mn -> mn, ht::hashes));\n+    }\n+\n","filename":"test\/jdk\/tools\/jmod\/hashes\/HashesTest.java","additions":46,"deletions":2,"binary":false,"changes":48,"status":"modified"}]}