{"files":[{"patch":"@@ -65,1 +65,5 @@\n-    $1_LDFLAGS := $(LDFLAGS_JDKLIB) $(call SET_SHARED_LIBRARY_ORIGIN)\n+    ifeq ($(call isTargetOs, windows), false)\n+      $1_LDFLAGS := $(LDFLAGS_JDKLIB) $(call SET_SHARED_LIBRARY_ORIGIN) -pthread\n+    else\n+      $1_LDFLAGS := $(LDFLAGS_JDKLIB) $(call SET_SHARED_LIBRARY_ORIGIN)\n+    endif\n","filename":"make\/common\/TestFilesCompilation.gmk","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -534,4 +534,9 @@\n-            jlong newNanoTime = JVM_NanoTime(env, 0);\n-            nanoTimeout -= newNanoTime - prevNanoTime;\n-            if (nanoTimeout < NET_NSEC_PER_MSEC) {\n-                return 0;\n+            if (timeout > 0) {\n+                jlong newNanoTime = JVM_NanoTime(env, 0);\n+                nanoTimeout -= newNanoTime - prevNanoTime;\n+                if (nanoTimeout < NET_NSEC_PER_MSEC) {\n+                    return 0;\n+                }\n+                prevNanoTime = newNanoTime;\n+            } else {\n+                continue; \/\/ timeout is -1, so  loop again.\n@@ -539,1 +544,0 @@\n-            prevNanoTime = newNanoTime;\n","filename":"src\/java.base\/aix\/native\/libnet\/aix_close.c","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -440,4 +440,9 @@\n-            jlong newNanoTime = JVM_NanoTime(env, 0);\n-            nanoTimeout -= newNanoTime - prevNanoTime;\n-            if (nanoTimeout < NET_NSEC_PER_MSEC) {\n-                return 0;\n+            if (timeout > 0) {\n+                jlong newNanoTime = JVM_NanoTime(env, 0);\n+                nanoTimeout -= newNanoTime - prevNanoTime;\n+                if (nanoTimeout < NET_NSEC_PER_MSEC) {\n+                    return 0;\n+                }\n+                prevNanoTime = newNanoTime;\n+            } else {\n+                continue; \/\/ timeout is -1, so  loop again.\n@@ -445,1 +450,0 @@\n-            prevNanoTime = newNanoTime;\n","filename":"src\/java.base\/linux\/native\/libnet\/linux_close.c","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -475,6 +475,13 @@\n-            jlong newNanoTime = JVM_NanoTime(env, 0);\n-            nanoTimeout -= newNanoTime - prevNanoTime;\n-            if (nanoTimeout < NET_NSEC_PER_MSEC) {\n-                if (allocated != 0)\n-                    free(fdsp);\n-                return 0;\n+            if (timeout > 0) {\n+                jlong newNanoTime = JVM_NanoTime(env, 0);\n+                nanoTimeout -= newNanoTime - prevNanoTime;\n+                if (nanoTimeout < NET_NSEC_PER_MSEC) {\n+                    if (allocated != 0)\n+                        free(fdsp);\n+                    return 0;\n+                }\n+                prevNanoTime = newNanoTime;\n+                t.tv_sec = nanoTimeout \/ NET_NSEC_PER_SEC;\n+                t.tv_usec = (nanoTimeout % NET_NSEC_PER_SEC) \/ NET_NSEC_PER_USEC;\n+            } else {\n+                continue; \/\/ timeout is -1, so  loop again.\n@@ -482,4 +489,0 @@\n-            prevNanoTime = newNanoTime;\n-            t.tv_sec = nanoTimeout \/ NET_NSEC_PER_SEC;\n-            t.tv_usec = (nanoTimeout % NET_NSEC_PER_SEC) \/ NET_NSEC_PER_USEC;\n-\n","filename":"src\/java.base\/macosx\/native\/libnet\/bsd_close.c","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class NativeThread {\n+\n+    public static final int SIGPIPE;\n+\n+    static {\n+        SIGPIPE = getSIGPIPE();\n+    }\n+\n+    public static native long getID();\n+\n+    public static native int signal(long threadId, int sig);\n+\n+    private static native int getSIGPIPE();\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/NativeThread.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8237858\n+ * @summary PlainSocketImpl.socketAccept() handles EINTR incorrectly\n+ * @requires (os.family != \"windows\")\n+ * @compile NativeThread.java\n+ * @run main\/othervm\/native -Djdk.net.usePlainSocketImpl=true SocketAcceptInterruptTest 0\n+ * @run main\/othervm\/native -Djdk.net.usePlainSocketImpl=true SocketAcceptInterruptTest 5000\n+ * @run main\/othervm\/native SocketAcceptInterruptTest 0\n+ * @run main\/othervm\/native SocketAcceptInterruptTest 5000\n+ *\/\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.*;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+public class SocketAcceptInterruptTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        System.loadLibrary(\"NativeThread\");\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        ExecutorService executor = Executors.newFixedThreadPool(1);\n+\n+        try ( ServerSocket ss = new ServerSocket(0, 50, loopback);) {\n+            Server server = new Server(ss, Integer.parseInt(args[0]));\n+            Future<Result> future = executor.submit(server);\n+            long threadId = server.getID();\n+\n+            sendSignal(threadId, ss);\n+            sleep(100);\n+            \/\/ In failing case server socket will be closed, so we do need to check first\n+            if (!ss.isClosed()) {\n+                \/\/ After sending SIGPIPE, create client socket and connect to server\n+                try ( Socket s = new Socket(loopback, ss.getLocalPort());  InputStream in = s.getInputStream();) {\n+                    in.read(); \/\/ reading one byte is enought for test.\n+                }\n+            }\n+            Result result = future.get();\n+            if (result.status == Result.FAIL) {\n+                throw result.exception;\n+            }\n+        } finally {\n+            executor.shutdown();\n+        }\n+        System.out.println(\"OK!\");\n+    }\n+\n+    private static void sendSignal(long threadId, ServerSocket ss) {\n+        System.out.println(\"Sending SIGPIPE to ServerSocket thread.\");\n+        int count = 0;\n+        while (!ss.isClosed() && count++ < 20) {\n+            sleep(10);\n+            if (NativeThread.signal(threadId, NativeThread.SIGPIPE) != 0) {\n+                throw new RuntimeException(\"Failed to interrupt the server thread.\");\n+            }\n+        }\n+    }\n+\n+    private static void sleep(long time) {\n+        try {\n+            Thread.sleep(time);\n+        } catch (InterruptedException e) {\n+            \/\/ ignore the exception.\n+        }\n+    }\n+\n+    static class Server implements Callable<Result> {\n+\n+        private volatile long threadId;\n+        private final ServerSocket serverSocket;\n+        private final int timeout;\n+\n+        public Server(ServerSocket ss, int timeout) {\n+            serverSocket = ss;\n+            this.timeout = timeout;\n+        }\n+\n+        @Override\n+        public Result call() {\n+            try {\n+                threadId = NativeThread.getID();\n+                serverSocket.setSoTimeout(timeout);\n+                try ( Socket socket = serverSocket.accept();\n+                    OutputStream outputStream = socket.getOutputStream();) {\n+                    outputStream.write(\"Hello!\".getBytes());\n+                    return new Result(Result.SUCCESS, null);\n+                }\n+            } catch (IOException e) {\n+                close();\n+                return new Result(Result.FAIL, e);\n+            }\n+        }\n+\n+        long getID() {\n+            while (threadId == 0) {\n+                sleep(5);\n+            }\n+            return threadId;\n+        }\n+\n+        private void close() {\n+            if (!serverSocket.isClosed()) {\n+                try {\n+                    serverSocket.close();\n+                } catch (IOException ex) {\n+                    \/\/ ignore the exception\n+                }\n+            }\n+        }\n+    }\n+\n+    static class Result {\n+\n+        static final int SUCCESS = 0;\n+        static final int FAIL = 1;\n+        final int status;\n+        final Exception exception;\n+\n+        public Result(int status, Exception ex) {\n+            this.status = status;\n+            exception = ex;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/SocketAcceptInterruptTest.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8237858\n+ * @summary PlainSocketImpl.socketAccept() handles EINTR incorrectly\n+ * @requires (os.family != \"windows\")\n+ * @compile NativeThread.java\n+ * @run main\/othervm\/native -Djdk.net.usePlainSocketImpl=true SocketReadInterruptTest 2000 3000\n+ * @run main\/othervm\/native SocketReadInterruptTest 2000 3000\n+ * @run main\/othervm\/native -Djdk.net.usePlainSocketImpl=true SocketReadInterruptTest 2000 0\n+ * @run main\/othervm\/native SocketReadInterruptTest 2000 0\n+ *\/\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+\n+import java.net.*;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+public class SocketReadInterruptTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        System.loadLibrary(\"NativeThread\");\n+        ExecutorService executor = Executors.newFixedThreadPool(2);\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+\n+        try ( ServerSocket ss = new ServerSocket(0, 50, loopback);\n+            Socket s1 = new Socket(loopback, ss.getLocalPort());) {\n+            Server server = new Server(ss, Integer.parseInt(args[0]));\n+            Future<Result> f1 = executor.submit(server);\n+\n+            Client client = new Client(s1, Integer.parseInt(args[1]));\n+            Future<Result> f2 = executor.submit(client);\n+            long threadId = client.getID();\n+\n+            sleep(200);\n+            System.out.println(\"Sending SIGPIPE to client thread.\");\n+            if (NativeThread.signal(threadId, NativeThread.SIGPIPE) != 0) {\n+                throw new RuntimeException(\"Failed to interrupt the thread.\");\n+            }\n+\n+            Result r1 = f1.get();\n+            if (r1.status == Result.FAIL) {\n+                throw r1.exception;\n+            }\n+\n+            Result r2 = f2.get();\n+            if (r2.status == Result.FAIL) {\n+                throw r2.exception;\n+            }\n+            System.out.println(\"OK!\");\n+        } finally {\n+            executor.shutdown();\n+        }\n+    }\n+\n+    private static void sleep(long time) {\n+        try {\n+            Thread.sleep(time);\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        }\n+    }\n+\n+    static class Client implements Callable<Result> {\n+\n+        private volatile long threadId;\n+        private final Socket client;\n+        private final int timeout;\n+\n+        public Client(Socket s, int timeout) {\n+            client = s;\n+            this.timeout = timeout;\n+        }\n+\n+        @Override\n+        public Result call() {\n+            threadId = NativeThread.getID();\n+            byte[] arr = new byte[64];\n+            try ( InputStream in = client.getInputStream();) {\n+                client.setSoTimeout(timeout);\n+                in.read(arr);\n+                return new Result(Result.SUCCESS, null);\n+            } catch (IOException ex) {\n+                close();\n+                return new Result(Result.FAIL, ex);\n+            }\n+        }\n+\n+        long getID() {\n+            while (threadId == 0) {\n+                sleep(5);\n+            }\n+            return threadId;\n+        }\n+\n+        void close() {\n+            if (!client.isClosed()) {\n+                try {\n+                    client.close();\n+                } catch (IOException ex) {\n+                    \/\/ ignore the exception.\n+                }\n+            }\n+        }\n+    }\n+\n+    static class Server implements Callable<Result> {\n+\n+        private final ServerSocket serverSocket;\n+        private final int timeout;\n+\n+        public Server(ServerSocket ss, int timeout) {\n+            serverSocket = ss;\n+            this.timeout = timeout;\n+        }\n+\n+        @Override\n+        public Result call() {\n+            try {\n+                try ( Socket client = serverSocket.accept();  OutputStream outputStream = client.getOutputStream();) {\n+                    sleep(timeout);\n+                    outputStream.write(\"This is just a test string.\".getBytes());\n+                    return new Result(Result.SUCCESS, null);\n+                }\n+            } catch (IOException e) {\n+                close();\n+                return new Result(Result.FAIL, e);\n+            }\n+        }\n+\n+        public void close() {\n+            if (!serverSocket.isClosed()) {\n+                try {\n+                    serverSocket.close();\n+                } catch (IOException ex) {\n+                }\n+            }\n+        }\n+    }\n+\n+    static class Result {\n+\n+        static final int SUCCESS = 0;\n+        static final int FAIL = 1;\n+        final int status;\n+        final Exception exception;\n+\n+        public Result(int status, Exception ex) {\n+            this.status = status;\n+            exception = ex;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/SocketReadInterruptTest.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include<jni.h>\n+#include<signal.h>\n+#include<stdlib.h>\n+#if  defined(__linux__) || defined(_ALLBSD_SOURCE) || defined(_AIX)\n+#include <pthread.h>\n+#endif\n+\n+\/*\n+ * Class:     NativeThread\n+ * Method:    getID\n+ * Signature: ()J\n+ *\/\n+JNIEXPORT jlong JNICALL Java_NativeThread_getID(JNIEnv *env, jclass class)\n+{\n+    #if  defined(__linux__) || defined(_ALLBSD_SOURCE) || defined(_AIX)\n+        return (jlong)pthread_self();\n+    #else\n+        return 0;\n+    #endif\n+}\n+\n+\/*\n+ * Class:     NativeThread\n+ * Method:    signal\n+ * Signature: (JI)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_NativeThread_signal(JNIEnv *env, jclass class, jlong thread, jint sig)\n+{\n+    #if  defined(__linux__) || defined(_ALLBSD_SOURCE) || defined(_AIX)\n+        return pthread_kill((pthread_t)thread, sig);\n+    #else\n+        return 0;\n+    #endif\n+}\n+\n+\/*\n+ * Class:     NativeThread\n+ * Method:    getSIGPIPE\n+ * Signature: ()I\n+ *\/\n+JNIEXPORT jint JNICALL Java_NativeThread_getSIGPIPE(JNIEnv *env, jclass class)\n+{\n+    #if  defined(__linux__) || defined(_ALLBSD_SOURCE) || defined(_AIX)\n+        return SIGPIPE;\n+    #else\n+        return 0;\n+    #endif\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/libNativeThread.c","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"}]}