{"files":[{"patch":"@@ -56,0 +56,1 @@\n+        -e 's\/^\\#.*\/\/g' \\\n","filename":"make\/common\/FindTests.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -486,0 +486,4 @@\n+ClassFileStream* ClassPathImageEntry::open_stream(const char* name, TRAPS) {\n+  return open_stream_for_loader(name, ClassLoaderData::the_null_class_loader_data(), THREAD);\n+}\n+\n@@ -493,1 +497,1 @@\n-ClassFileStream* ClassPathImageEntry::open_stream(const char* name, TRAPS) {\n+ClassFileStream* ClassPathImageEntry::open_stream_for_loader(const char* name, ClassLoaderData* loader_data, TRAPS) {\n@@ -504,12 +508,0 @@\n-#if INCLUDE_CDS\n-        \/\/ CDS uses the boot class loader to load classes whose packages are in\n-        \/\/ modules defined for other class loaders.  So, for now, get their module\n-        \/\/ names from the \"modules\" jimage file.\n-        if (DumpSharedSpaces && location == 0) {\n-          const char* module_name = (*JImagePackageToModule)(_jimage, pkg_name);\n-          if (module_name != NULL) {\n-            location = (*JImageFindResource)(_jimage, module_name, get_jimage_version_string(), name, &size);\n-          }\n-        }\n-#endif\n-\n@@ -517,1 +509,1 @@\n-        PackageEntry* package_entry = ClassLoader::get_package_entry(name, ClassLoaderData::the_null_class_loader_data(), CHECK_NULL);\n+        PackageEntry* package_entry = ClassLoader::get_package_entry(name, loader_data, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+  \/\/ Open the stream for a specific class loader\n+  virtual ClassFileStream* open_stream_for_loader(const char* name, ClassLoaderData* loader_data, TRAPS) {\n+    return open_stream(name, THREAD);\n+  }\n@@ -143,1 +147,1 @@\n-\n+  ClassFileStream* open_stream_for_loader(const char* name, ClassLoaderData* loader_data, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-      cfs = FileMapInfo::open_stream_for_jvmti(ik, CHECK_NULL);\n+      cfs = FileMapInfo::open_stream_for_jvmti(ik, class_loader, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/classFileStream.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"classfile\/classLoaderData.inline.hpp\"\n@@ -1493,1 +1495,1 @@\n-ClassFileStream* FileMapInfo::open_stream_for_jvmti(InstanceKlass* ik, TRAPS) {\n+ClassFileStream* FileMapInfo::open_stream_for_jvmti(InstanceKlass* ik, Handle class_loader, TRAPS) {\n@@ -1505,1 +1507,6 @@\n-  return cpe->open_stream(file_name, THREAD);\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());\n+  ClassFileStream* cfs = cpe->open_stream_for_loader(file_name, loader_data, THREAD);\n+  assert(cfs != NULL, \"must be able to read the classfile data of shared classes for built-in loaders.\");\n+  log_debug(cds, jvmti)(\"classfile data for %s [%d: %s] = %d bytes\", class_name, path_index,\n+                        cfs->source(), cfs->length());\n+  return cfs;\n","filename":"src\/hotspot\/share\/memory\/filemap.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -303,1 +303,1 @@\n-  static ClassFileStream* open_stream_for_jvmti(InstanceKlass* ik, TRAPS);\n+  static ClassFileStream* open_stream_for_jvmti(InstanceKlass* ik, Handle class_loader, TRAPS);\n","filename":"src\/hotspot\/share\/memory\/filemap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -329,0 +329,15 @@\n+# This group should be executed with \"jtreg -Dtest.cds.run.with.jfr=true ...\"\n+# to test interaction between AppCDS and JFR. It also has the side effect of\n+# testing JVMTI ClassFileLoadHook.\n+#\n+# The excluded tests disallow the jdk.jfr module, which is required to\n+# run with JFR.\n+hotspot_appcds_with_jfr = \\\n+  runtime\/appcds\/ \\\n+ -runtime\/appcds\/cacheObject\/ArchivedModuleCompareTest.java \\\n+ -runtime\/appcds\/jigsaw\/classpathtests\/BootAppendTests.java \\\n+ -runtime\/appcds\/jigsaw\/classpathtests\/ClassPathTests.java \\\n+ -runtime\/appcds\/jigsaw\/classpathtests\/EmptyClassInBootClassPath.java \\\n+ -runtime\/appcds\/jigsaw\/JigsawOptionsCombo.java \\\n+ -runtime\/appcds\/jigsaw\/modulepath\/MainModuleOnly.java\n+\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -154,0 +154,9 @@\n+    \/\/ This allows you to run the AppCDS tests with JFR enabled at runtime (though not at\n+    \/\/ dump time, as that's uncommon for typical AppCDS users).\n+    \/\/\n+    \/\/ To run in this special mode, add the following to your jtreg command-line\n+    \/\/    -Dtest.cds.run.with.jfr=true\n+    \/\/\n+    \/\/ Some AppCDS tests are not compatible with this mode. See the group\n+    \/\/ hotspot_appcds_with_jfr in ..\/..\/TEST.ROOT for details.\n+    private static final boolean RUN_WITH_JFR = Boolean.getBoolean(\"test.cds.run.with.jfr\");\n@@ -175,0 +184,16 @@\n+        if (RUN_WITH_JFR) {\n+            boolean usesJFR = false;\n+            for (String s : cmd) {\n+                if (s.startsWith(\"-XX:StartFlightRecording=\") || s.startsWith(\"-XX:FlightRecorderOptions\")) {\n+                    System.out.println(\"JFR option might have been specified. Don't interfere: \" + s);\n+                    usesJFR = true;\n+                    break;\n+                }\n+            }\n+            if (!usesJFR) {\n+                System.out.println(\"JFR option not specified. Enabling JFR ...\");\n+                cmd.add(0, \"-XX:StartFlightRecording=dumponexit=true\");\n+                System.out.println(cmd);\n+            }\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/appcds\/TestCommon.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n@@ -46,0 +44,3 @@\n+        run();\n+    }\n+    public static void run(String... extra_runtime_args) throws Exception {\n@@ -65,5 +66,6 @@\n-                                 \/\/ command-line arguments ...\n-                                 use_whitebox_jar,\n-                                 \"-XX:+UnlockDiagnosticVMOptions\",\n-                                 \"-XX:+WhiteBoxAPI\",\n-                                 \"Hello\", customJarPath);\n+                                 TestCommon.concat(extra_runtime_args,\n+                                     \/\/ command-line arguments ...\n+                                     use_whitebox_jar,\n+                                     \"-XX:+UnlockDiagnosticVMOptions\",\n+                                     \"-XX:+WhiteBoxAPI\",\n+                                     \"Hello\", customJarPath));\n","filename":"test\/hotspot\/jtreg\/runtime\/appcds\/customLoader\/HelloCustom.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -96,0 +96,4 @@\n+        run();\n+    }\n+\n+    public static void run(String... extra_runtime_args) throws Exception {\n@@ -107,0 +111,1 @@\n+        prefix = TestCommon.concat(prefix, extra_runtime_args);\n","filename":"test\/hotspot\/jtreg\/runtime\/appcds\/jigsaw\/modulepath\/ModulePathAndCP.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-    public static void main(String args[]) {\n+    public static void main(String args[]) throws Exception {\n@@ -46,0 +46,6 @@\n+        test1(testCase);\n+        test2(testCase);\n+    }\n+\n+    \/\/ Test rewriting the classfile data using CFLH\n+    static void test1(TestCaseId testCase) {\n@@ -84,0 +90,14 @@\n+    \/\/ Test the loading of classfile data for non-boot shared classes from jrt:\/xxx.\n+    \/\/ See JDK-8221351.\n+    static void test2(TestCaseId testCase) throws Exception {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        Class c = Class.forName(\"java.sql.SQLException\"); \/\/ defined by platform class loader.\n+\n+        switch (testCase) {\n+        case SHARING_ON_CFLH_OFF:\n+        case SHARING_AUTO_CFLH_ON:\n+        case SHARING_ON_CFLH_ON:\n+            assertTrue(wb.isSharedClass(c), \"must be shared\");\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/appcds\/jvmti\/ClassFileLoadHook.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,3 +30,0 @@\n- * @modules java.base\/jdk.internal.misc\n- *          jdk.jartool\/sun.tools.jar\n- *          java.management\n@@ -49,1 +46,2 @@\n-        \"LoadMe\"\n+        \"LoadMe\",\n+        \"java\/sql\/SQLException\"\n","filename":"test\/hotspot\/jtreg\/runtime\/appcds\/jvmti\/ClassFileLoadHookTest.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"}]}