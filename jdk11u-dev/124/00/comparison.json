{"files":[{"patch":"@@ -510,0 +510,2 @@\n+  bool unrelated_load_in_store_null_block(Node* store, Node* load);\n+\n","filename":"src\/hotspot\/share\/opto\/block.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -543,0 +543,22 @@\n+\/\/ This function is used by insert_anti_dependences to find unrelated loads for stores in implicit null checks.\n+bool PhaseCFG::unrelated_load_in_store_null_block(Node* store, Node* load) {\n+  \/\/ We expect an anti-dependence edge from 'load' to 'store', except when\n+  \/\/ implicit_null_check() has hoisted 'store' above its early block to\n+  \/\/ perform an implicit null check, and 'load' is placed in the null\n+  \/\/ block. In this case it is safe to ignore the anti-dependence, as the\n+  \/\/ null block is only reached if 'store' tries to write to null object and\n+  \/\/ 'load' read from non-null object (there is preceding check for that)\n+  \/\/ These objects can't be the same.\n+  Block* store_block = get_block_for_node(store);\n+  Block* load_block = get_block_for_node(load);\n+  Node* end = store_block->end();\n+  if (end->is_MachNullCheck() && (end->in(1) == store) && store_block->dominates(load_block)) {\n+    Node* if_true = end->find_out_with(Op_IfTrue);\n+    assert(if_true != NULL, \"null check without null projection\");\n+    Node* null_block_region = if_true->find_out_with(Op_Region);\n+    assert(null_block_region != NULL, \"null check without null region\");\n+    return get_block_for_node(null_block_region) == load_block;\n+  }\n+  return false;\n+}\n+\n@@ -796,1 +818,1 @@\n-      if (LCA != early) {\n+      if (LCA != early && !unrelated_load_in_store_null_block(store, load)) {\n@@ -807,17 +829,1 @@\n-#ifdef ASSERT\n-        \/\/ We expect an anti-dependence edge from 'load' to 'store', except when\n-        \/\/ implicit_null_check() has hoisted 'store' above its early block to\n-        \/\/ perform an implicit null check, and 'load' is placed in the null\n-        \/\/ block. In this case it is safe to ignore the anti-dependence, as the\n-        \/\/ null block is only reached if 'store' tries to write to null.\n-        Block* store_null_block = NULL;\n-        Node* store_null_check = store->find_out_with(Op_MachNullCheck);\n-        if (store_null_check != NULL) {\n-          Node* if_true = store_null_check->find_out_with(Op_IfTrue);\n-          assert(if_true != NULL, \"null check without null projection\");\n-          Node* null_block_region = if_true->find_out_with(Op_Region);\n-          assert(null_block_region != NULL, \"null check without null region\");\n-          store_null_block = get_block_for_node(null_block_region);\n-        }\n-#endif\n-        assert(LCA == store_null_block || store->find_edge(load) != -1,\n+        assert(store->find_edge(load) != -1 || unrelated_load_in_store_null_block(store, load),\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @bug 8261730\n+ * @bug 8261730 8265132\n@@ -43,0 +43,1 @@\n+    private static MyInteger[] global = {new MyInteger()};\n@@ -44,1 +45,1 @@\n-    static void setFooToZero() {\n+    static void test1() {\n@@ -55,0 +56,6 @@\n+    static void test2(MyInteger a, MyInteger b) {\n+        global[0].val = a.val + b.val * 31;\n+        global[0].val = 0;\n+        return;\n+    }\n+\n@@ -57,1 +64,5 @@\n-            setFooToZero();\n+            test1();\n+        }\n+\n+        for (int i = 0; i < 10_000; i++) {\n+            test2(new MyInteger(), new MyInteger());\n@@ -59,0 +70,1 @@\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/uncommontrap\/TestNullCheckAntiDependence.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"}]}