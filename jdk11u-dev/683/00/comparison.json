{"files":[{"patch":"@@ -654,1 +654,1 @@\n-void AwtFrame::Reshape(int x, int y, int width, int height)\n+void AwtFrame::Reshape(int x, int y, int w, int h)\n@@ -658,0 +658,19 @@\n+        POINT pt = {x + w \/ 2, y + h \/ 2};\n+        Devices::InstanceAccess devices;\n+        HMONITOR monitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);\n+        int screen = AwtWin32GraphicsDevice::GetScreenFromHMONITOR(monitor);\n+        AwtWin32GraphicsDevice *device = devices->GetDevice(screen);\n+        \/\/ Try to set the correct size and jump to the correct location, even if\n+        \/\/ it is on the different monitor. Note that for the \"size\" we use the\n+        \/\/ current monitor, so the WM_DPICHANGED will adjust it for the \"target\"\n+        \/\/ monitor.\n+        MONITORINFO *miInfo = AwtWin32GraphicsDevice::GetMonitorInfo(screen);\n+        x = device == NULL ? x : device->ScaleUpAbsX(x);\n+        y = device == NULL ? y : device->ScaleUpAbsY(y);\n+        w = ScaleUpX(w);\n+        h = ScaleUpY(h);\n+        \/\/ SetWindowPlacement takes workspace coordinates, but if taskbar is at\n+        \/\/ top\/left of screen, workspace coords != screen coords, so offset by\n+        \/\/ workspace origin\n+        x = x - (miInfo->rcWork.left - miInfo->rcMonitor.left);\n+        y = y - (miInfo->rcWork.top - miInfo->rcMonitor.top);\n@@ -659,13 +678,1 @@\n-        POINT       ptMinPosition = {x,y};\n-        POINT       ptMaxPosition = {0,0};\n-        RECT        rcNormalPosition = {x,y,x+width,y+height};\n-        RECT        rcWorkspace;\n-        HWND        hWndDesktop = GetDesktopWindow();\n-        HWND        hWndSelf = GetHWnd();\n-\n-        \/\/ SetWindowPlacement takes workspace coordinates, but\n-        \/\/ if taskbar is at top of screen, workspace coords !=\n-        \/\/ screen coords, so offset by workspace origin\n-        VERIFY(::SystemParametersInfo(SPI_GETWORKAREA, 0, (PVOID)&rcWorkspace, 0));\n-        ::OffsetRect(&rcNormalPosition, -rcWorkspace.left, -rcWorkspace.top);\n-\n+        ::ZeroMemory(&wp, sizeof(WINDOWPLACEMENT));\n@@ -676,3 +683,3 @@\n-        wp.ptMinPosition = ptMinPosition;\n-        wp.ptMaxPosition = ptMaxPosition;\n-        wp.rcNormalPosition = rcNormalPosition;\n+        wp.ptMinPosition = {x, y};\n+        wp.ptMaxPosition = {0, 0};\n+        wp.rcNormalPosition = {x, y, x + w, y + h};\n@@ -686,1 +693,1 @@\n-        ::SetWindowPlacement(hWndSelf, &wp);\n+        ::SetWindowPlacement(GetHWnd(), &wp);\n@@ -703,1 +710,1 @@\n-    AwtWindow::Reshape(x, y, width, height);\n+    AwtWindow::Reshape(x, y, w, h);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Frame.cpp","additions":26,"deletions":19,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Frame;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Rectangle;\n+import java.awt.Toolkit;\n+\n+\/**\n+ * @test\n+ * @bug 8256373\n+ * @key headful\n+ * @summary setBounds() should work if the frame is minimized\n+ *\/\n+public final class RestoreToOppositeScreen {\n+\n+    public static void main(String[] args) throws Exception {\n+        Toolkit toolkit = Toolkit.getDefaultToolkit();\n+        if (!toolkit.isFrameStateSupported(Frame.ICONIFIED)) {\n+            return;\n+        }\n+\n+        var ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        GraphicsDevice[] gds = ge.getScreenDevices();\n+        for (GraphicsDevice gd1 : gds) {\n+            Rectangle screen1 = gd1.getDefaultConfiguration().getBounds();\n+            int x1 = (int) screen1.getCenterX();\n+            int y1 = (int) screen1.getCenterY();\n+            for (GraphicsDevice gd2 : gds) {\n+                Rectangle screen2 = gd2.getDefaultConfiguration().getBounds();\n+                \/\/ tweak the (x2, y2) point so even if the screen1 and screen2\n+                \/\/ are the same, we will use different bounds, otherwise\n+                \/\/ setBounds() will be ignored\n+                int x2 = (int) screen2.getCenterX() - 50;\n+                int y2 = (int) screen2.getCenterY() - 50;\n+                Frame frame = new Frame();\n+                try {\n+                    \/\/ show the frame on one monitor, and then move it to\n+                    \/\/ another while the frame minimized\n+                    frame.setBounds(x1, y1, 400, 400);\n+                    frame.setVisible(true);\n+                    Thread.sleep(2000);\n+                    frame.setExtendedState(Frame.ICONIFIED);\n+                    Thread.sleep(2000);\n+                    Rectangle before = new Rectangle(x2, y2, 380, 380);\n+                    frame.setBounds(before);\n+                    Thread.sleep(2000);\n+                    frame.setExtendedState(Frame.NORMAL);\n+                    Thread.sleep(2000);\n+                    Rectangle after = frame.getBounds();\n+                    checkSize(after.x, before.x, \"x\");\n+                    checkSize(after.y, before.y, \"y\");\n+                    checkSize(after.width, before.width, \"width\");\n+                    checkSize(after.height, before.height, \"height\");\n+                } finally {\n+                    frame.dispose();\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void checkSize(int actual, int expected, String prop) {\n+        if (Math.abs(actual - expected) > 10) { \/\/ let's allow size variation,\n+                                                \/\/ the bug is reproduced anyway\n+            System.err.println(\"Expected: \" + expected);\n+            System.err.println(\"Actual: \" + actual);\n+            throw new RuntimeException(prop + \" is wrong\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/RestoreToOppositeScreen\/RestoreToOppositeScreen.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}