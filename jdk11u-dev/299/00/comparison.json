{"files":[{"patch":"@@ -27,3 +27,2 @@\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n@@ -31,1 +30,1 @@\n-#include \"runtime\/stubCodeGenerator.hpp\"\n+#include \"runtime\/os.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -37,27 +37,0 @@\n-#include <sys\/auxv.h>\n-#include <asm\/hwcap.h>\n-\n-#ifndef HWCAP_AES\n-#define HWCAP_AES   (1<<3)\n-#endif\n-\n-#ifndef HWCAP_PMULL\n-#define HWCAP_PMULL (1<<4)\n-#endif\n-\n-#ifndef HWCAP_SHA1\n-#define HWCAP_SHA1  (1<<5)\n-#endif\n-\n-#ifndef HWCAP_SHA2\n-#define HWCAP_SHA2  (1<<6)\n-#endif\n-\n-#ifndef HWCAP_CRC32\n-#define HWCAP_CRC32 (1<<7)\n-#endif\n-\n-#ifndef HWCAP_ATOMICS\n-#define HWCAP_ATOMICS (1<<8)\n-#endif\n-\n@@ -70,24 +43,0 @@\n-VM_Version::PsrInfo VM_Version::_psr_info   = { 0, };\n-\n-static BufferBlob* stub_blob;\n-static const int stub_size = 550;\n-\n-extern \"C\" {\n-  typedef void (*getPsrInfo_stub_t)(void*);\n-}\n-static getPsrInfo_stub_t getPsrInfo_stub = NULL;\n-\n-\n-class VM_Version_StubGenerator: public StubCodeGenerator {\n- public:\n-\n-  VM_Version_StubGenerator(CodeBuffer *c) : StubCodeGenerator(c) {}\n-\n-  address generate_getPsrInfo() {\n-    StubCodeMark mark(this, \"VM_Version\", \"getPsrInfo_stub\");\n-#   define __ _masm->\n-    address start = __ pc();\n-\n-    \/\/ void getPsrInfo(VM_Version::PsrInfo* psr_info);\n-\n-    address entry = __ pc();\n@@ -95,1 +44,3 @@\n-    __ enter();\n+int VM_Version::_zva_length;\n+int VM_Version::_dcache_line_size;\n+int VM_Version::_icache_line_size;\n@@ -97,17 +48,1 @@\n-    __ get_dczid_el0(rscratch1);\n-    __ strw(rscratch1, Address(c_rarg0, in_bytes(VM_Version::dczid_el0_offset())));\n-\n-    __ get_ctr_el0(rscratch1);\n-    __ strw(rscratch1, Address(c_rarg0, in_bytes(VM_Version::ctr_el0_offset())));\n-\n-    __ leave();\n-    __ ret(lr);\n-\n-#   undef __\n-\n-    return start;\n-  }\n-};\n-\n-\n-void VM_Version::get_processor_features() {\n+void VM_Version::initialize() {\n@@ -120,1 +55,1 @@\n-  getPsrInfo_stub(&_psr_info);\n+  get_os_cpu_info();\n@@ -166,28 +101,0 @@\n-  uint64_t auxv = getauxval(AT_HWCAP);\n-\n-  char buf[512];\n-\n-  _features = auxv;\n-\n-  int cpu_lines = 0;\n-  if (FILE *f = fopen(\"\/proc\/cpuinfo\", \"r\")) {\n-    char buf[128], *p;\n-    while (fgets(buf, sizeof (buf), f) != NULL) {\n-      if ((p = strchr(buf, ':')) != NULL) {\n-        long v = strtol(p+1, NULL, 0);\n-        if (strncmp(buf, \"CPU implementer\", sizeof \"CPU implementer\" - 1) == 0) {\n-          _cpu = v;\n-          cpu_lines++;\n-        } else if (strncmp(buf, \"CPU variant\", sizeof \"CPU variant\" - 1) == 0) {\n-          _variant = v;\n-        } else if (strncmp(buf, \"CPU part\", sizeof \"CPU part\" - 1) == 0) {\n-          if (_model != v)  _model2 = _model;\n-          _model = v;\n-        } else if (strncmp(buf, \"CPU revision\", sizeof \"CPU revision\" - 1) == 0) {\n-          _revision = v;\n-        }\n-      }\n-    }\n-    fclose(f);\n-  }\n-\n@@ -259,1 +166,1 @@\n-  \/\/ If an olde style \/proc\/cpuinfo (cpu_lines == 1) then if _model is an A57 (0xd07)\n+  \/\/ If an olde style \/proc\/cpuinfo (cores == 1) then if _model is an A57 (0xd07)\n@@ -262,1 +169,1 @@\n-  if (_cpu == CPU_ARM && cpu_lines == 1 && _model == 0xd07) _features |= CPU_A53MAC;\n+  if (_cpu == CPU_ARM && os::processor_count() == 1 && _model == 0xd07) _features |= CPU_A53MAC;\n@@ -264,0 +171,1 @@\n+  char buf[512];\n@@ -266,6 +174,6 @@\n-  if (auxv & HWCAP_ASIMD) strcat(buf, \", simd\");\n-  if (auxv & HWCAP_CRC32) strcat(buf, \", crc\");\n-  if (auxv & HWCAP_AES)   strcat(buf, \", aes\");\n-  if (auxv & HWCAP_SHA1)  strcat(buf, \", sha1\");\n-  if (auxv & HWCAP_SHA2)  strcat(buf, \", sha256\");\n-  if (auxv & HWCAP_ATOMICS) strcat(buf, \", lse\");\n+  if (_features & CPU_ASIMD) strcat(buf, \", simd\");\n+  if (_features & CPU_CRC32) strcat(buf, \", crc\");\n+  if (_features & CPU_AES)   strcat(buf, \", aes\");\n+  if (_features & CPU_SHA1)  strcat(buf, \", sha1\");\n+  if (_features & CPU_SHA2)  strcat(buf, \", sha256\");\n+  if (_features & CPU_LSE)   strcat(buf, \", lse\");\n@@ -276,1 +184,1 @@\n-    UseCRC32 = (auxv & HWCAP_CRC32) != 0;\n+    UseCRC32 = (_features & CPU_CRC32) != 0;\n@@ -279,1 +187,1 @@\n-  if (UseCRC32 && (auxv & HWCAP_CRC32) == 0) {\n+  if (UseCRC32 && (_features & CPU_CRC32) == 0) {\n@@ -293,1 +201,1 @@\n-  if (auxv & HWCAP_ATOMICS) {\n+  if (_features & CPU_LSE) {\n@@ -303,1 +211,1 @@\n-  if (auxv & HWCAP_AES) {\n+  if (_features & CPU_AES) {\n@@ -331,1 +239,1 @@\n-  if (auxv & HWCAP_CRC32) {\n+  if (_features & CPU_CRC32) {\n@@ -344,1 +252,1 @@\n-  if (auxv & (HWCAP_SHA1 | HWCAP_SHA2)) {\n+  if (_features & (CPU_SHA1 | CPU_SHA2)) {\n@@ -353,1 +261,1 @@\n-  if (UseSHA && (auxv & HWCAP_SHA1)) {\n+  if (UseSHA && (_features & CPU_SHA1)) {\n@@ -362,1 +270,1 @@\n-  if (UseSHA && (auxv & HWCAP_SHA2)) {\n+  if (UseSHA && (_features & CPU_SHA2)) {\n@@ -380,1 +288,1 @@\n-  if (auxv & HWCAP_PMULL) {\n+  if (_features & CPU_PMULL) {\n@@ -442,16 +350,0 @@\n-}\n-\n-void VM_Version::initialize() {\n-  ResourceMark rm;\n-\n-  stub_blob = BufferBlob::create(\"getPsrInfo_stub\", stub_size);\n-  if (stub_blob == NULL) {\n-    vm_exit_during_initialization(\"Unable to allocate getPsrInfo_stub\");\n-  }\n-\n-  CodeBuffer c(stub_blob);\n-  VM_Version_StubGenerator g(&c);\n-  getPsrInfo_stub = CAST_TO_FN_PTR(getPsrInfo_stub_t,\n-                                   g.generate_getPsrInfo());\n-\n-  get_processor_features();\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":27,"deletions":135,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -44,6 +44,6 @@\n-  struct PsrInfo {\n-    uint32_t dczid_el0;\n-    uint32_t ctr_el0;\n-  };\n-  static PsrInfo _psr_info;\n-  static void get_processor_features();\n+  static int _zva_length;\n+  static int _dcache_line_size;\n+  static int _icache_line_size;\n+\n+  \/\/ Read additional info using OS-specific interfaces\n+  static void get_os_cpu_info();\n@@ -94,0 +94,1 @@\n+    \/\/ flags above must follow Linux HWCAP\n@@ -104,8 +105,2 @@\n-  static ByteSize dczid_el0_offset() { return byte_offset_of(PsrInfo, dczid_el0); }\n-  static ByteSize ctr_el0_offset()   { return byte_offset_of(PsrInfo, ctr_el0); }\n-  static bool is_zva_enabled() {\n-    \/\/ Check the DZP bit (bit 4) of dczid_el0 is zero\n-    \/\/ and block size (bit 0~3) is not zero.\n-    return ((_psr_info.dczid_el0 & 0x10) == 0 &&\n-            (_psr_info.dczid_el0 & 0xf) != 0);\n-  }\n+\n+  static bool is_zva_enabled() { return 0 <= _zva_length; }\n@@ -114,7 +109,1 @@\n-    return 4 << (_psr_info.dczid_el0 & 0xf);\n-  }\n-  static int icache_line_size() {\n-    return (1 << (_psr_info.ctr_el0 & 0x0f)) * 4;\n-  }\n-  static int dcache_line_size() {\n-    return (1 << ((_psr_info.ctr_el0 >> 16) & 0x0f)) * 4;\n+    return _zva_length;\n@@ -122,0 +111,3 @@\n+\n+  static int icache_line_size() { return _icache_line_size; }\n+  static int dcache_line_size() { return _dcache_line_size; }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":13,"deletions":21,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,0 +30,91 @@\n+#include <asm\/hwcap.h>\n+#include <sys\/auxv.h>\n+#include <sys\/prctl.h>\n+\n+#ifndef HWCAP_AES\n+#define HWCAP_AES   (1<<3)\n+#endif\n+\n+#ifndef HWCAP_PMULL\n+#define HWCAP_PMULL (1<<4)\n+#endif\n+\n+#ifndef HWCAP_SHA1\n+#define HWCAP_SHA1  (1<<5)\n+#endif\n+\n+#ifndef HWCAP_SHA2\n+#define HWCAP_SHA2  (1<<6)\n+#endif\n+\n+#ifndef HWCAP_CRC32\n+#define HWCAP_CRC32 (1<<7)\n+#endif\n+\n+#ifndef HWCAP_ATOMICS\n+#define HWCAP_ATOMICS (1<<8)\n+#endif\n+\n+void VM_Version::get_os_cpu_info() {\n+\n+  uint64_t auxv = getauxval(AT_HWCAP);\n+\n+  STATIC_ASSERT(CPU_FP      == HWCAP_FP);\n+  STATIC_ASSERT(CPU_ASIMD   == HWCAP_ASIMD);\n+  STATIC_ASSERT(CPU_EVTSTRM == HWCAP_EVTSTRM);\n+  STATIC_ASSERT(CPU_AES     == HWCAP_AES);\n+  STATIC_ASSERT(CPU_PMULL   == HWCAP_PMULL);\n+  STATIC_ASSERT(CPU_SHA1    == HWCAP_SHA1);\n+  STATIC_ASSERT(CPU_SHA2    == HWCAP_SHA2);\n+  STATIC_ASSERT(CPU_CRC32   == HWCAP_CRC32);\n+  STATIC_ASSERT(CPU_LSE     == HWCAP_ATOMICS);\n+  _features = auxv & (\n+      HWCAP_FP      |\n+      HWCAP_ASIMD   |\n+      HWCAP_EVTSTRM |\n+      HWCAP_AES     |\n+      HWCAP_PMULL   |\n+      HWCAP_SHA1    |\n+      HWCAP_SHA2    |\n+      HWCAP_CRC32   |\n+      HWCAP_ATOMICS);\n+\n+  uint64_t ctr_el0;\n+  uint64_t dczid_el0;\n+  __asm__ (\n+    \"mrs %0, CTR_EL0\\n\"\n+    \"mrs %1, DCZID_EL0\\n\"\n+    : \"=r\"(ctr_el0), \"=r\"(dczid_el0)\n+  );\n+\n+  _icache_line_size = (1 << (ctr_el0 & 0x0f)) * 4;\n+  _dcache_line_size = (1 << ((ctr_el0 >> 16) & 0x0f)) * 4;\n+\n+  if (!(dczid_el0 & 0x10)) {\n+    _zva_length = 4 << (dczid_el0 & 0xf);\n+  }\n+\n+  int cpu_lines = 0;\n+  if (FILE *f = fopen(\"\/proc\/cpuinfo\", \"r\")) {\n+    \/\/ need a large buffer as the flags line may include lots of text\n+    char buf[1024], *p;\n+    while (fgets(buf, sizeof (buf), f) != NULL) {\n+      if ((p = strchr(buf, ':')) != NULL) {\n+        long v = strtol(p+1, NULL, 0);\n+        if (strncmp(buf, \"CPU implementer\", sizeof \"CPU implementer\" - 1) == 0) {\n+          _cpu = v;\n+          cpu_lines++;\n+        } else if (strncmp(buf, \"CPU variant\", sizeof \"CPU variant\" - 1) == 0) {\n+          _variant = v;\n+        } else if (strncmp(buf, \"CPU part\", sizeof \"CPU part\" - 1) == 0) {\n+          if (_model != v)  _model2 = _model;\n+          _model = v;\n+        } else if (strncmp(buf, \"CPU revision\", sizeof \"CPU revision\" - 1) == 0) {\n+          _revision = v;\n+        }\n+      }\n+    }\n+    fclose(f);\n+  }\n+  guarantee(cpu_lines == os::processor_count(), \"core count should be consistent\");\n+}\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"modified"}]}