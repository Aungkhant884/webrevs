{"files":[{"patch":"@@ -204,0 +204,1 @@\n+        final Logger logger = server.getLogger();\n@@ -223,1 +224,0 @@\n-                Logger logger = server.getLogger();\n@@ -237,1 +237,0 @@\n-                final Logger logger = server.getLogger();\n@@ -269,0 +268,1 @@\n+        logger.log(Level.TRACE, \"Sent headers: noContentToSend=\" + noContentToSend);\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ExchangeImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -293,0 +293,1 @@\n+                    logger.log(Level.TRACE, \"Write Finished\");\n@@ -297,1 +298,0 @@\n-                    responseCompleted (c);\n@@ -301,0 +301,3 @@\n+                        if (c.getState() == State.REQUEST) {\n+                            requestCompleted(c);\n+                        }\n@@ -302,0 +305,1 @@\n+                    responseCompleted (c);\n@@ -515,0 +519,1 @@\n+            logger.log(Level.TRACE, \"exchange started\");\n@@ -704,0 +709,3 @@\n+            } catch (Throwable t) {\n+                logger.log(Level.TRACE, \"ServerImpl.Exchange (5)\", t);\n+                throw t;\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ServerImpl.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,230 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8266761\n+ * @summary HttpServer can fail with an assertion error when a handler doesn't fully\n+ *          read the request body and sends back a reply with no content, or when\n+ *          the client closes its outputstream while the server tries to drains\n+ *          its content.\n+ * @run testng\/othervm InputNotRead\n+ * @run testng\/othervm -Djava.net.preferIPv6Addresses=true InputNotRead\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+\n+import org.testng.annotations.Test;\n+\n+import static java.nio.charset.StandardCharsets.*;\n+\n+public class InputNotRead {\n+\n+    private static final int msgCode = 200;\n+    private static final String someContext = \"\/context\";\n+\n+    static class ServerThreadFactory implements ThreadFactory {\n+        static final AtomicLong tokens = new AtomicLong();\n+        @Override\n+        public Thread newThread(Runnable r) {\n+            var thread = new Thread(r, \"Server-\" + tokens.incrementAndGet());\n+            thread.setDaemon(true);\n+            return thread;\n+        }\n+    }\n+\n+    static {\n+        Logger.getLogger(\"\").setLevel(Level.ALL);\n+        Logger.getLogger(\"\").getHandlers()[0].setLevel(Level.ALL);\n+    }\n+\n+    @Test\n+    public void testSendResponse() throws Exception {\n+        System.out.println(\"testSendResponse()\");\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        HttpServer server = HttpServer.create(new InetSocketAddress(loopback, 0), 0);\n+        ExecutorService executor = Executors.newCachedThreadPool(new ServerThreadFactory());\n+        server.setExecutor(executor);\n+        try {\n+            server.createContext(someContext, new HttpHandler() {\n+                @Override\n+                public void handle(HttpExchange msg) throws IOException {\n+                    System.err.println(\"Handling request: \" + msg.getRequestURI());\n+                    byte[] reply = new byte[0];\n+                    try {\n+                        msg.getRequestBody().read();\n+                        try {\n+                            msg.sendResponseHeaders(msgCode, reply.length == 0 ? -1 : reply.length);\n+                        } catch(IOException ioe) {\n+                            ioe.printStackTrace();\n+                        }\n+                    } finally {\n+                        \/\/ don't close the exchange and don't close any stream\n+                        \/\/ to trigger the assertion.\n+                        System.err.println(\"Request handled: \" + msg.getRequestURI());\n+                    }\n+                }\n+            });\n+            server.start();\n+            System.out.println(\"Server started at port \"\n+                               + server.getAddress().getPort());\n+\n+            runRawSocketHttpClient(loopback, server.getAddress().getPort(), -1);\n+        } finally {\n+            System.out.println(\"shutting server down\");\n+            executor.shutdown();\n+            server.stop(0);\n+        }\n+        System.out.println(\"Server finished.\");\n+    }\n+\n+    @Test\n+    public void testCloseOutputStream() throws Exception {\n+        System.out.println(\"testCloseOutputStream()\");\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        HttpServer server = HttpServer.create(new InetSocketAddress(loopback, 0), 0);\n+        ExecutorService executor = Executors.newCachedThreadPool(new ServerThreadFactory());\n+        server.setExecutor(executor);\n+        try {\n+            server.createContext(someContext, new HttpHandler() {\n+                @Override\n+                public void handle(HttpExchange msg) throws IOException {\n+                    System.err.println(\"Handling request: \" + msg.getRequestURI());\n+                    byte[] reply = \"Here is my reply!\".getBytes(UTF_8);\n+                    try {\n+                        BufferedReader r = new BufferedReader(new InputStreamReader(msg.getRequestBody()));\n+                        r.read();\n+                        try {\n+                            msg.sendResponseHeaders(msgCode, reply.length == 0 ? -1 : reply.length);\n+                            msg.getResponseBody().write(reply);\n+                            msg.getResponseBody().close();\n+                            Thread.sleep(50);\n+                        } catch(IOException | InterruptedException ie) {\n+                            ie.printStackTrace();\n+                        }\n+                    } finally {\n+                        System.err.println(\"Request handled: \" + msg.getRequestURI());\n+                    }\n+                }\n+            });\n+            server.start();\n+            System.out.println(\"Server started at port \"\n+                    + server.getAddress().getPort());\n+\n+            runRawSocketHttpClient(loopback, server.getAddress().getPort(), 64 * 1024 + 16);\n+        } finally {\n+            System.out.println(\"shutting server down\");\n+            executor.shutdown();\n+            server.stop(0);\n+        }\n+        System.out.println(\"Server finished.\");\n+    }\n+\n+    static void runRawSocketHttpClient(InetAddress address, int port, int contentLength)\n+        throws Exception\n+    {\n+        Socket socket = null;\n+        PrintWriter writer = null;\n+        BufferedReader reader = null;\n+        final String CRLF = \"\\r\\n\";\n+        try {\n+            socket = new Socket(address, port);\n+            writer = new PrintWriter(new OutputStreamWriter(\n+                socket.getOutputStream()));\n+            System.out.println(\"Client connected by socket: \" + socket);\n+            String body = \"I will send all the data.\";\n+            if (contentLength <= 0)\n+                contentLength = body.getBytes(UTF_8).length;\n+\n+            writer.print(\"GET \" + someContext + \"\/ HTTP\/1.1\" + CRLF);\n+            writer.print(\"User-Agent: Java\/\"\n+                + System.getProperty(\"java.version\")\n+                + CRLF);\n+            writer.print(\"Host: \" + address.getHostName() + CRLF);\n+            writer.print(\"Accept: *\/*\" + CRLF);\n+            writer.print(\"Content-Length: \" + contentLength + CRLF);\n+            writer.print(\"Connection: keep-alive\" + CRLF);\n+            writer.print(CRLF); \/\/ Important, else the server will expect that\n+            \/\/ there's more into the request.\n+            writer.flush();\n+            System.out.println(\"Client wrote request to socket: \" + socket);\n+            writer.print(body);\n+            writer.flush();\n+\n+            reader = new BufferedReader(new InputStreamReader(\n+                socket.getInputStream()));\n+            System.out.println(\"Client start reading from server:\"  );\n+            String line = reader.readLine();\n+            for (; line != null; line = reader.readLine()) {\n+                if (line.isEmpty()) {\n+                    break;\n+                }\n+                System.out.println(\"\\\"\"  + line + \"\\\"\");\n+            }\n+            System.out.println(\"Client finished reading from server\"  );\n+        } finally {\n+            \/\/ give time to the server to try & drain its input stream\n+            Thread.sleep(500);\n+            \/\/ closes the client outputstream while the server is draining\n+            \/\/ it\n+            if (writer != null) {\n+                writer.close();\n+            }\n+            \/\/ give time to the server to trigger its assertion\n+            \/\/ error before closing the connection\n+            Thread.sleep(500);\n+            if (reader != null)\n+                try {\n+                    reader.close();\n+                } catch (IOException logOrIgnore) {\n+                    logOrIgnore.printStackTrace();\n+                }\n+            if (socket != null) {\n+                try {\n+                    socket.close();\n+                } catch (IOException logOrIgnore) {\n+                    logOrIgnore.printStackTrace();\n+                }\n+            }\n+        }\n+        System.out.println(\"Client finished.\" );\n+    }\n+\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/InputNotRead.java","additions":230,"deletions":0,"binary":false,"changes":230,"status":"added"}]}