{"files":[{"patch":"@@ -1,2 +1,31 @@\n-project=jdk10\n-bugids=dup\n+[general]\n+project=jdk-updates\n+jbs=JDK\n+version=11.0.13\n+\n+[checks]\n+error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace\n+\n+[repository]\n+tags=(?:jdk-(?:[1-9]([0-9]*)(?:\\.(?:0|[1-9][0-9]*)){0,4})(?:\\+(?:(?:[0-9]+))|(?:-ga)))|(?:jdk[4-9](?:u\\d{1,3})?-(?:(?:b\\d{2,3})|(?:ga)))|(?:hs\\d\\d(?:\\.\\d{1,2})?-b\\d\\d)\n+branches=\n+\n+[census]\n+version=0\n+domain=openjdk.org\n+\n+[checks \"whitespace\"]\n+files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java\n+\n+[checks \"merge\"]\n+message=Merge\n+\n+[checks \"reviewers\"]\n+reviewers=1\n+ignore=duke\n+\n+[checks \"committer\"]\n+role=committer\n+\n+[checks \"issues\"]\n+pattern=^([124-8][0-9]{6}): (\\S.*)$\n","filename":".jcheck\/conf","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-DEFAULT_VERSION_UPDATE=12\n+DEFAULT_VERSION_UPDATE=13\n@@ -36,1 +36,1 @@\n-DEFAULT_VERSION_DATE=2021-07-20\n+DEFAULT_VERSION_DATE=2021-10-19\n@@ -40,1 +40,1 @@\n-DEFAULT_PROMOTED_VERSION_PRE=ea\n+DEFAULT_PROMOTED_VERSION_PRE=\n","filename":"make\/autoconf\/version-numbers","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-        return new SingleByte.Decoder(this, b2c, $ASCIICOMPATIBLE$);\n+        return new SingleByte.Decoder(this, b2c, $ASCIICOMPATIBLE$, $LATIN1DECODABLE$);\n","filename":"make\/data\/charsetmapping\/SingleByte-X.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+        boolean isLatin1Decodable = true;\n@@ -72,0 +73,3 @@\n+            if (e.cp > 0xFF) {\n+                isLatin1Decodable = false;\n+            }\n@@ -181,0 +185,3 @@\n+            if (line.indexOf(\"$LATIN1DECODABLE$\") != -1) {\n+                line = line.replace(\"$LATIN1DECODABLE$\", isLatin1Decodable ? \"true\" : \"false\");\n+            }\n","filename":"make\/jdk\/src\/classes\/build\/tools\/charsetmapping\/SBCS.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-    LIBS_linux := -lthread_db $(LIBDL), \\\n+    LIBS_linux := $(LIBDL), \\\n","filename":"make\/lib\/Lib-jdk.hotspot.agent.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -204,2 +204,2 @@\n-  reg_def V8   ( SOC, SOC, Op_RegF,  8, v8->as_VMReg()          );\n-  reg_def V8_H ( SOC, SOC, Op_RegF,  8, v8->as_VMReg()->next()  );\n+  reg_def V8   ( SOC, SOE, Op_RegF,  8, v8->as_VMReg()          );\n+  reg_def V8_H ( SOC, SOE, Op_RegF,  8, v8->as_VMReg()->next()  );\n@@ -209,2 +209,2 @@\n-  reg_def V9   ( SOC, SOC, Op_RegF,  9, v9->as_VMReg()          );\n-  reg_def V9_H ( SOC, SOC, Op_RegF,  9, v9->as_VMReg()->next()  );\n+  reg_def V9   ( SOC, SOE, Op_RegF,  9, v9->as_VMReg()          );\n+  reg_def V9_H ( SOC, SOE, Op_RegF,  9, v9->as_VMReg()->next()  );\n@@ -214,2 +214,2 @@\n-  reg_def V10  ( SOC, SOC, Op_RegF, 10, v10->as_VMReg()         );\n-  reg_def V10_H( SOC, SOC, Op_RegF, 10, v10->as_VMReg()->next() );\n+  reg_def V10  ( SOC, SOE, Op_RegF, 10, v10->as_VMReg()         );\n+  reg_def V10_H( SOC, SOE, Op_RegF, 10, v10->as_VMReg()->next() );\n@@ -219,2 +219,2 @@\n-  reg_def V11  ( SOC, SOC, Op_RegF, 11, v11->as_VMReg()         );\n-  reg_def V11_H( SOC, SOC, Op_RegF, 11, v11->as_VMReg()->next() );\n+  reg_def V11  ( SOC, SOE, Op_RegF, 11, v11->as_VMReg()         );\n+  reg_def V11_H( SOC, SOE, Op_RegF, 11, v11->as_VMReg()->next() );\n@@ -224,2 +224,2 @@\n-  reg_def V12  ( SOC, SOC, Op_RegF, 12, v12->as_VMReg()         );\n-  reg_def V12_H( SOC, SOC, Op_RegF, 12, v12->as_VMReg()->next() );\n+  reg_def V12  ( SOC, SOE, Op_RegF, 12, v12->as_VMReg()         );\n+  reg_def V12_H( SOC, SOE, Op_RegF, 12, v12->as_VMReg()->next() );\n@@ -229,2 +229,2 @@\n-  reg_def V13  ( SOC, SOC, Op_RegF, 13, v13->as_VMReg()         );\n-  reg_def V13_H( SOC, SOC, Op_RegF, 13, v13->as_VMReg()->next() );\n+  reg_def V13  ( SOC, SOE, Op_RegF, 13, v13->as_VMReg()         );\n+  reg_def V13_H( SOC, SOE, Op_RegF, 13, v13->as_VMReg()->next() );\n@@ -234,2 +234,2 @@\n-  reg_def V14  ( SOC, SOC, Op_RegF, 14, v14->as_VMReg()         );\n-  reg_def V14_H( SOC, SOC, Op_RegF, 14, v14->as_VMReg()->next() );\n+  reg_def V14  ( SOC, SOE, Op_RegF, 14, v14->as_VMReg()         );\n+  reg_def V14_H( SOC, SOE, Op_RegF, 14, v14->as_VMReg()->next() );\n@@ -239,2 +239,2 @@\n-  reg_def V15  ( SOC, SOC, Op_RegF, 15, v15->as_VMReg()         );\n-  reg_def V15_H( SOC, SOC, Op_RegF, 15, v15->as_VMReg()->next() );\n+  reg_def V15  ( SOC, SOE, Op_RegF, 15, v15->as_VMReg()         );\n+  reg_def V15_H( SOC, SOE, Op_RegF, 15, v15->as_VMReg()->next() );\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -565,3 +565,1 @@\n-  __ mov(rscratch2, ShenandoahHeap::MARKING);\n-  __ tst(tmp, rscratch2);\n-  __ br(Assembler::EQ, done);\n+  __ tbz(tmp, ShenandoahHeap::MARKING_BITPOS, done);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-      fmovd(v10, tmp5);                            \/\/ init two24A value\n+      fmovd(v24, tmp5);                            \/\/ init two24A value\n@@ -377,1 +377,1 @@\n-        fmuld(v26, v26, v10);\n+        fmuld(v26, v26, v24);\n@@ -386,1 +386,1 @@\n-        fmuld(v3, v26, v10);\n+        fmuld(v3, v26, v24);\n@@ -842,1 +842,1 @@\n-          fmsubd(v28, v10, v29, v18);                      \/\/ v28 = z-two24A*fw\n+          fmsubd(v28, v24, v29, v18);                      \/\/ v28 = z-two24A*fw\n@@ -1003,1 +1003,1 @@\n-          fcmpd(v18, v10);                                   \/\/ v10 is stil two24A\n+          fcmpd(v18, v24);                                   \/\/ v24 is stil two24A\n@@ -1007,1 +1007,1 @@\n-          fmaddd(v2, v10, v1, v18);\n+          fmaddd(v2, v24, v1, v18);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64_trig.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1913,1 +1913,1 @@\n-    if (ProfileInterpreter) {\n+    if (ProfileInterpreter && !TieredCompilation) {\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2377,1 +2377,1 @@\n-    } else {\n+    } else { \/\/ not TieredCompilation\n@@ -2450,1 +2450,1 @@\n-    if (ProfileInterpreter) {\n+    if (ProfileInterpreter && !TieredCompilation) {\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2013,1 +2013,1 @@\n-    if (ProfileInterpreter) {\n+    if (ProfileInterpreter && !TieredCompilation) {\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2300,1 +2300,1 @@\n-    if (ProfileInterpreter) {\n+    if (ProfileInterpreter && !TieredCompilation) {\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3300,10 +3300,0 @@\n-#ifdef __APPLE__\n-  \/\/ XXXDARWIN\n-  \/\/ Work around the unaligned VM callbacks in hotspot's\n-  \/\/ sharedRuntime. The callbacks don't use SSE2 instructions, and work on\n-  \/\/ Linux, Solaris, and FreeBSD. On Mac OS X, dyld (rightly so) enforces\n-  \/\/ alignment when doing symbol lookup. To work around this, we force early\n-  \/\/ binding of all symbols now, thus binding when alignment is known-good.\n-  _dyld_bind_fully_image_containing_address((const void *) &os::init);\n-#endif\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-# include <pthread.h>\n@@ -504,10 +503,0 @@\n-\n-\/*\n-  NOTE: does not seem to work on bsd.\n-  if (info == NULL || info->si_code <= 0 || info->si_code == SI_NOINFO) {\n-    \/\/ can't decode this kind of signal\n-    info = NULL;\n-  } else {\n-    assert(sig == info->si_signo, \"bad siginfo\");\n-  }\n-*\/\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1044,5 +1044,1 @@\n-  NoSafepointVerifier no_safepoints; \/\/ we mustn't GC until we've installed the\n-                                     \/\/ ClassLoaderData in the graph since the CLD\n-                                     \/\/ contains oops in _handles that must be walked.\n-\n-  ClassLoaderData* cld = new ClassLoaderData(loader, is_anonymous);\n+  ClassLoaderData* cld;\n@@ -1051,6 +1047,4 @@\n-    \/\/ First, Atomically set it\n-    ClassLoaderData* old = java_lang_ClassLoader::cmpxchg_loader_data(cld, loader(), NULL);\n-    if (old != NULL) {\n-      delete cld;\n-      \/\/ Returns the data.\n-      return old;\n+    MutexLocker ml(ClassLoaderDataGraph_lock);\n+    cld = java_lang_ClassLoader::loader_data_raw(loader());\n+    if (cld != NULL) {\n+      return cld;\n@@ -1058,0 +1052,4 @@\n+    cld = new ClassLoaderData(loader, is_anonymous);\n+    java_lang_ClassLoader::release_set_loader_data(loader(), cld);\n+  } else {\n+    cld = new ClassLoaderData(loader, is_anonymous);\n@@ -1060,0 +1058,4 @@\n+  NoSafepointVerifier no_safepoints; \/\/ we mustn't GC until we've installed the\n+                                     \/\/ ClassLoaderData in the graph since the CLD\n+                                     \/\/ contains oops in _handles that must be walked.\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -422,0 +422,4 @@\n+  unsigned identity_hash() const {\n+    return (unsigned)((uintptr_t)this >> 3);\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-  return java_lang_ClassLoader::loader_data(loader);\n+  return java_lang_ClassLoader::loader_data_acquire(loader);\n@@ -62,1 +62,1 @@\n-  ClassLoaderData* loader_data= java_lang_ClassLoader::loader_data(loader());\n+  ClassLoaderData* loader_data= java_lang_ClassLoader::loader_data_acquire(loader());\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,1 +142,1 @@\n-  while (cl != NULL && java_lang_ClassLoader::loader_data(cl) == NULL) {\n+  while (cl != NULL && java_lang_ClassLoader::loader_data_acquire(cl) == NULL) {\n","filename":"src\/hotspot\/share\/classfile\/classLoaderStats.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -4023,1 +4023,1 @@\n-ClassLoaderData* java_lang_ClassLoader::loader_data(oop loader) {\n+ClassLoaderData* java_lang_ClassLoader::loader_data_acquire(oop loader) {\n@@ -4025,1 +4025,1 @@\n-  return HeapAccess<>::load_at(loader, _loader_data_offset);\n+  return HeapAccess<MO_ACQUIRE>::load_at(loader, _loader_data_offset);\n@@ -4028,1 +4028,1 @@\n-ClassLoaderData* java_lang_ClassLoader::cmpxchg_loader_data(ClassLoaderData* new_data, oop loader, ClassLoaderData* expected_data) {\n+ClassLoaderData* java_lang_ClassLoader::loader_data_raw(oop loader) {\n@@ -4030,1 +4030,7 @@\n-  return HeapAccess<>::atomic_cmpxchg_at(new_data, loader, _loader_data_offset, expected_data);\n+  return RawAccess<>::load_at(loader, _loader_data_offset);\n+}\n+\n+void java_lang_ClassLoader::release_set_loader_data(oop loader, ClassLoaderData* new_data) {\n+  assert(loader != NULL, \"loader must not be NULL\");\n+  assert(oopDesc::is_oop(loader), \"loader must be oop\");\n+  HeapAccess<MO_RELEASE>::store_at(loader, _loader_data_offset, new_data);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1323,2 +1323,3 @@\n-  static ClassLoaderData* loader_data(oop loader);\n-  static ClassLoaderData* cmpxchg_loader_data(ClassLoaderData* new_data, oop loader, ClassLoaderData* expected_data);\n+  static ClassLoaderData* loader_data_acquire(oop loader);\n+  static ClassLoaderData* loader_data_raw(oop loader);\n+  static void release_set_loader_data(oop loader, ClassLoaderData* new_data);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1569,1 +1569,1 @@\n-      assert(false, \"root method not found\");\n+      \/\/ Miranda.\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-          \"Use timed decays to shrik TLAB sizes. This conserves memory \"    \\\n+          \"Use timed decays to shrink TLAB sizes. This conserves memory \"   \\\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilon_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -186,1 +186,1 @@\n-  ClassLoaderData * const loader_data = java_lang_ClassLoader::loader_data(obj);\n+  ClassLoaderData * const loader_data = java_lang_ClassLoader::loader_data_acquire(obj);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -693,1 +693,1 @@\n-    assert(alias = Compile::AliasIdxRaw, \"following raw memory can't lead to a barrier\");\n+    assert(alias == Compile::AliasIdxRaw, \"following raw memory can't lead to a barrier\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,5 +53,7 @@\n-\n-  if (UseLargePages && (MaxHeapSize \/ os::large_page_size()) < ShenandoahHeapRegion::MIN_NUM_REGIONS) {\n-    warning(\"Large pages size (\" SIZE_FORMAT \"K) is too large to afford page-sized regions, disabling uncommit\",\n-            os::large_page_size() \/ K);\n-    FLAG_SET_DEFAULT(ShenandoahUncommit, false);\n+  if (UseLargePages) {\n+    size_t large_page_size = os::large_page_size();\n+    if ((align_up(MaxHeapSize, large_page_size) \/ large_page_size) < ShenandoahHeapRegion::MIN_NUM_REGIONS) {\n+      warning(\"Large pages size (\" SIZE_FORMAT \"K) is too large to afford page-sized regions, disabling uncommit\",\n+              os::large_page_size() \/ K);\n+      FLAG_SET_DEFAULT(ShenandoahUncommit, false);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-    size_t allocs_seen = Atomic::xchg<size_t>(0, &_allocs_seen);\n+    size_t allocs_seen = Atomic::xchg<size_t>(0, &_allocs_seen, memory_order_relaxed);\n@@ -630,1 +630,1 @@\n-  Atomic::add(words, &_allocs_seen);\n+  Atomic::add(words, &_allocs_seen, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -465,1 +465,1 @@\n-void ShenandoahHeapRegion::setup_sizes(size_t max_heap_size) {\n+size_t ShenandoahHeapRegion::setup_sizes(size_t max_heap_size) {\n@@ -540,4 +540,7 @@\n-  \/\/ Make sure region size is at least one large page, if enabled.\n-  \/\/ The heap sizes would be rounded by heap initialization code by\n-  \/\/ page size, so we need to round up the region size too, to cover\n-  \/\/ the heap exactly.\n+  \/\/ Make sure region size and heap size are page aligned.\n+  \/\/ If large pages are used, we ensure that region size is aligned to large page size if\n+  \/\/ heap size is large enough to accommodate minimal number of regions. Otherwise, we align\n+  \/\/ region size to regular page size.\n+\n+  \/\/ Figure out page size to use, and aligns up heap to page size\n+  int page_size = os::vm_page_size();\n@@ -545,1 +548,10 @@\n-    region_size = MAX2(region_size, os::large_page_size());\n+    size_t large_page_size = os::large_page_size();\n+    max_heap_size = align_up(max_heap_size, large_page_size);\n+    if ((max_heap_size \/ align_up(region_size, large_page_size)) >= MIN_NUM_REGIONS) {\n+      page_size = (int)large_page_size;\n+    } else {\n+      \/\/ Should have been checked during argument initialization\n+      assert(!ShenandoahUncommit, \"Uncommit requires region size aligns to large page size\");\n+    }\n+  } else {\n+    max_heap_size = align_up(max_heap_size, page_size);\n@@ -548,0 +560,2 @@\n+  \/\/ Align region size to page size\n+  region_size = align_up(region_size, page_size);\n@@ -617,0 +631,2 @@\n+\n+  return max_heap_size;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -253,1 +253,2 @@\n-  static void setup_sizes(size_t max_heap_size);\n+  \/\/ Return adjusted max heap size\n+  static size_t setup_sizes(size_t max_heap_size);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-  Atomic::xchg((intptr_t)initial, &_budget);\n+  Atomic::xchg((intptr_t)initial, &_budget, memory_order_relaxed);\n@@ -212,1 +212,1 @@\n-  } while (Atomic::cmpxchg(new_val, &_budget, cur) != cur);\n+  } while (Atomic::cmpxchg(new_val, &_budget, cur, memory_order_relaxed) != cur);\n@@ -219,1 +219,1 @@\n-  if (_epoch != epoch) {\n+  if (Atomic::load(&_epoch) != epoch) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  Atomic::add((intptr_t)words, &_progress);\n+  Atomic::add((intptr_t)words, &_progress, memory_order_relaxed);\n@@ -62,1 +62,1 @@\n-  intptr_t new_budget = Atomic::add(inc, &_budget);\n+  intptr_t new_budget = Atomic::add(inc, &_budget, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -471,1 +471,1 @@\n-      java_lang_ClassLoader::loader_data(cls->_class_loader) : (ClassLoaderData*)NULL;\n+      java_lang_ClassLoader::loader_data_acquire(cls->_class_loader) : (ClassLoaderData*)NULL;\n@@ -473,1 +473,1 @@\n-      java_lang_ClassLoader::loader_data(cls->_parent) : (ClassLoaderData*)NULL;\n+      java_lang_ClassLoader::loader_data_acquire(cls->_parent) : (ClassLoaderData*)NULL;\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -324,1 +324,0 @@\n-  static Monitor* _transition_block_lock;\n@@ -342,1 +341,1 @@\n-  static Monitor* transition_block() { return _transition_block_lock; }\n+  static Monitor* transition_block() { return JfrThreadSampler_lock; }\n@@ -346,2 +345,0 @@\n-Monitor* JfrThreadSampler::_transition_block_lock = new Monitor(Mutex::leaf, \"Trace block\", true, Monitor::_safepoint_check_never);\n-\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+const julong MAX_GLOBAL_BUFFER_SIZE = 2 * G;\n@@ -40,0 +41,1 @@\n+const julong MAX_THREAD_BUFFER_SIZE = 2 * G;\n@@ -308,0 +310,5 @@\n+    if (options->memory_size_configured) {\n+      options->buffer_count = div_total_by_per_unit(options->memory_size, options->global_buffer_size);\n+    } else {\n+      options->memory_size = multiply(options->global_buffer_size, options->buffer_count);\n+    }\n@@ -327,1 +334,2 @@\n-  assert(options->buffer_count > 0, \"invariant\");\n+  assert(options->buffer_count >= MIN_BUFFER_COUNT, \"invariant\");\n+  assert(options->global_buffer_size >= options->thread_buffer_size, \"invariant\");\n@@ -432,0 +440,4 @@\n+  if (options->buffer_count < MIN_BUFFER_COUNT ||\n+      options->global_buffer_size < options->thread_buffer_size) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrMemorySizer.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+extern const julong MAX_GLOBAL_BUFFER_SIZE;\n+extern const julong MAX_THREAD_BUFFER_SIZE;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrMemorySizer.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -394,2 +394,5 @@\n-template <typename Argument>\n-static void log_lower_than_min_value(Argument& memory_argument, julong min_value) {\n+static const char higher_than_msg[] = \"This value is higher than the maximum size limited \";\n+static const char lower_than_msg[] = \"This value is lower than the minimum size required \";\n+template <typename Argument, bool lower>\n+static void log_out_of_range_value(Argument& memory_argument, julong min_value) {\n+  const char* msg = lower ? lower_than_msg : higher_than_msg;\n@@ -399,1 +402,1 @@\n-      \"This value is lower than the minimum size required \" JULONG_FORMAT \"%c\",\n+      \"%s\" JULONG_FORMAT \"%c\", msg,\n@@ -405,1 +408,1 @@\n-    \"This value is lower than the minimum size required \" JULONG_FORMAT,\n+    \"%s\" JULONG_FORMAT, msg,\n@@ -409,0 +412,2 @@\n+static const char default_val_msg[] = \"Value default for option \";\n+static const char specified_val_msg[] = \"Value specified for option \";\n@@ -414,1 +419,2 @@\n-      \"Value specified for option \\\"%s\\\" is \" JULONG_FORMAT \"%c\",\n+      \"%s\\\"%s\\\" is \" JULONG_FORMAT \"%c\",\n+      memory_argument.is_set() ? specified_val_msg: default_val_msg,\n@@ -421,1 +427,2 @@\n-    \"Value specified for option \\\"%s\\\" is \" JULONG_FORMAT,\n+    \"%s\\\"%s\\\" is \" JULONG_FORMAT,\n+    memory_argument.is_set() ? specified_val_msg: default_val_msg,\n@@ -542,0 +549,4 @@\n+  } else if (options.thread_buffer_size_configured && options.memory_size_configured) {\n+    if (!ensure_first_gteq_second(_dcmd_memorysize, _dcmd_threadbuffersize)) {\n+      return false;\n+    }\n@@ -610,1 +621,1 @@\n-    log_lower_than_min_value(memory_argument, value);\n+    log_out_of_range_value<Argument, true>(memory_argument, value);\n@@ -641,0 +652,24 @@\n+template <typename Argument>\n+static bool ensure_lteq(Argument& memory_argument, const jlong value) {\n+  if ((jlong)memory_argument.value()._size > value) {\n+    log_set_value(memory_argument);\n+    log_out_of_range_value<Argument, false>(memory_argument, value);\n+    return false;\n+  }\n+  return true;\n+}\n+\n+static bool ensure_valid_maximum_sizes() {\n+  if (_dcmd_globalbuffersize.is_set()) {\n+    if (!ensure_lteq(_dcmd_globalbuffersize, MAX_GLOBAL_BUFFER_SIZE)) {\n+      return false;\n+    }\n+  }\n+  if (_dcmd_threadbuffersize.is_set()) {\n+    if (!ensure_lteq(_dcmd_threadbuffersize, MAX_THREAD_BUFFER_SIZE)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -648,1 +683,1 @@\n-  if (!ensure_valid_minimum_sizes()) {\n+  if (!ensure_valid_minimum_sizes() || !ensure_valid_maximum_sizes()) {\n@@ -657,0 +692,18 @@\n+    if (options.buffer_count < MIN_BUFFER_COUNT || options.global_buffer_size < options.thread_buffer_size) {\n+      log_set_value(_dcmd_memorysize);\n+      log_set_value(_dcmd_globalbuffersize);\n+      log_error(arguments) (\"%s \\\"%s\\\" is \" JLONG_FORMAT,\n+        _dcmd_numglobalbuffers.is_set() ? specified_val_msg: default_val_msg,\n+        _dcmd_numglobalbuffers.name(), _dcmd_numglobalbuffers.value());\n+      log_set_value(_dcmd_threadbuffersize);\n+      if (options.buffer_count < MIN_BUFFER_COUNT) {\n+        log_error(arguments) (\"numglobalbuffers \" JULONG_FORMAT \" is less than minimal value \" JULONG_FORMAT,\n+          options.buffer_count, MIN_BUFFER_COUNT);\n+        log_error(arguments) (\"Decrease globalbuffersize\/threadbuffersize or increase memorysize\");\n+      } else {\n+        log_error(arguments) (\"globalbuffersize \" JULONG_FORMAT \" is less than threadbuffersize\" JULONG_FORMAT,\n+          options.global_buffer_size, options.thread_buffer_size);\n+        log_error(arguments) (\"Decrease globalbuffersize or increase memorysize or adjust global\/threadbuffersize\");\n+      }\n+      return false;\n+    }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrOptionSet.cpp","additions":62,"deletions":9,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -373,0 +373,3 @@\n+  if (method->can_be_statically_bound()) {\n+    THROW_MSG_0(vmSymbols::java_lang_InternalError(), err_msg(\"Effectively static method %s.%s should be handled in Java code\", method->method_holder()->external_name(), method->external_name()));\n+  }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-    ClassLoaderData* cld = java_lang_ClassLoader::loader_data(obj);\n+    ClassLoaderData* cld = java_lang_ClassLoader::loader_data_acquire(obj);\n@@ -64,1 +64,1 @@\n-      ClassLoaderData* cld = java_lang_ClassLoader::loader_data(obj);\n+      ClassLoaderData* cld = java_lang_ClassLoader::loader_data_acquire(obj);\n","filename":"src\/hotspot\/share\/oops\/instanceClassLoaderKlass.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+      assert(!methods->at(i)->is_private(), \"private methods should not need a vtable entry\");\n@@ -285,1 +286,1 @@\n-\/\/ Private methods do not override and are not overridden.\n+\/\/ Private methods do not override, and are not overridden and are not in the vtable.\n@@ -395,2 +396,3 @@\n-  \/\/ Static and <init> methods are never in\n-  if (target_method()->is_static() || target_method()->name() ==  vmSymbols::object_initializer_name()) {\n+  \/\/ Private, static and <init> methods are never in\n+  if (target_method()->is_private() || target_method()->is_static() ||\n+      (target_method()->name()->fast_compare(vmSymbols::object_initializer_name()) == 0)) {\n@@ -416,4 +418,1 @@\n-    \/\/ Private interface methods have no itable index and are always invoked nonvirtually,\n-    \/\/ so they retain their nonvirtual_vtable_index value, and therefore can_be_statically_bound()\n-    \/\/ will return true.\n-    if ((!is_default || !target_method()->has_itable_index()) && !target_method()->is_private()) {\n+    if ((!is_default || !target_method()->has_itable_index())) {\n@@ -430,8 +429,0 @@\n-  \/\/ private methods in classes always have a new entry in the vtable\n-  \/\/ specification interpretation since classic has\n-  \/\/ private methods not overriding\n-  \/\/ JDK8 adds private methods in interfaces which require invokespecial\n-  if (target_method()->is_private()) {\n-    return allocate_new;\n-  }\n-\n@@ -560,0 +551,1 @@\n+  assert(!m->is_private(), \"private methods should not be in vtable\");\n@@ -611,0 +603,2 @@\n+      (target_method()->is_private()) ||\n+      \/\/ private methods don't need to be in vtable\n@@ -613,1 +607,1 @@\n-      (target_method()->name() ==  vmSymbols::object_initializer_name())\n+      (target_method()->name()->fast_compare(vmSymbols::object_initializer_name()) == 0)\n@@ -624,1 +618,1 @@\n-    assert(target_method()->is_default_method() || target_method()->is_private(),\n+    assert(target_method()->is_default_method(),\n@@ -634,6 +628,0 @@\n-  \/\/ private methods in classes always have a new entry in the vtable.\n-  \/\/ Specification interpretation since classic has private methods not overriding.\n-  if (target_method()->is_private()) {\n-    return true;\n-  }\n-\n@@ -666,2 +654,2 @@\n-    \/\/ pretend private methods are not in the super vtable\n-    \/\/ since we do override around them: e.g. a.m pub\/b.m private\/c.m pub,\n+    \/\/ ignore private methods found via lookup_method since they do not participate in overriding,\n+    \/\/ and since we do override around them: e.g. a.m pub\/b.m private\/c.m pub,\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":13,"deletions":25,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1221,2 +1221,8 @@\n-          assert(get_block_for_node(def) || def->is_Con(), \"must have block; constants for debug info ok\");\n-          \/\/ Verify that instructions in the block is in correct order.\n+          Block* def_block = get_block_for_node(def);\n+          assert(def_block || def->is_Con(), \"must have block; constants for debug info ok\");\n+          \/\/ Verify that all definitions dominate their uses (except for virtual\n+          \/\/ instructions merging multiple definitions).\n+          assert(n->is_Root() || n->is_Region() || n->is_Phi() || n->is_MachMerge() ||\n+                 def_block->dominates(block),\n+                 \"uses must be dominated by definitions\");\n+          \/\/ Verify that instructions in the block are in correct order.\n@@ -1226,1 +1232,1 @@\n-          if (get_block_for_node(def) == block && !(block->head()->is_Loop() && n->is_Phi()) &&\n+          if (def_block == block && !(block->head()->is_Loop() && n->is_Phi()) &&\n@@ -1242,0 +1248,8 @@\n+      if (n->is_Proj()) {\n+        assert(j >= 1, \"a projection cannot be the first instruction in a block\");\n+        Node* pred = block->get_node(j - 1);\n+        Node* parent = n->in(0);\n+        assert(parent != NULL, \"projections must have a parent\");\n+        assert(pred == parent || (pred->is_Proj() && pred->in(0) == parent),\n+               \"projections must follow their parents or other sibling projections\");\n+      }\n","filename":"src\/hotspot\/share\/opto\/block.cpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4319,1 +4319,2 @@\n-  if (superelem->is_array_klass())\n+  ciType* subelem = subk;\n+  if (superelem->is_array_klass()) {\n@@ -4321,0 +4322,4 @@\n+  }\n+  if (subelem->is_array_klass()) {\n+    subelem = subelem->as_array_klass()->base_element_type();\n+  }\n@@ -4327,0 +4332,1 @@\n+        !(subelem->is_klass() && subelem->as_klass()->is_interface()) &&\n@@ -4328,1 +4334,1 @@\n-      return SSC_always_false;\n+      return SSC_always_false;  \/\/ (2) true path dead; no dynamic test needed\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -416,1 +416,2 @@\n-  if (best->in(0) == not_null_block->head()) {\n+  Node* ctrl = best->in(0);\n+  if (get_block_for_node(ctrl) == not_null_block) {\n@@ -1393,1 +1394,1 @@\n-  for(uint i4 = 0; i4 < block->_num_succs; i4++ ) {\n+  for (uint i4 = 0; i4 < block->_num_succs; i4++) {\n@@ -1396,2 +1397,4 @@\n-    \/\/ Remove any newly created, but dead, nodes.\n-    for( uint j = new_cnt; j > 0; j-- ) {\n+    \/\/ Remove any newly created, but dead, nodes by traversing their schedule\n+    \/\/ backwards. Here, a dead node is a node whose only outputs (if any) are\n+    \/\/ unused projections.\n+    for (uint j = new_cnt; j > 0; j--) {\n@@ -1399,2 +1402,26 @@\n-      if (n->outcnt() == 0 &&\n-          (!n->is_Proj() || n->as_Proj()->in(0)->outcnt() == 1) ){\n+      \/\/ Individual projections are examined together with all siblings when\n+      \/\/ their parent is visited.\n+      if (n->is_Proj()) {\n+        continue;\n+      }\n+      bool dead = true;\n+      for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+        Node* out = n->fast_out(i);\n+        \/\/ n is live if it has a non-projection output or a used projection.\n+        if (!out->is_Proj() || out->outcnt() > 0) {\n+          dead = false;\n+          break;\n+        }\n+      }\n+      if (dead) {\n+        \/\/ n's only outputs (if any) are unused projections scheduled next to n\n+        \/\/ (see PhaseCFG::select()). Remove these projections backwards.\n+        for (uint k = j + n->outcnt(); k > j; k--) {\n+          Node* proj = sb->get_node(k);\n+          assert(proj->is_Proj() && proj->in(0) == n,\n+                 \"projection should correspond to dead node\");\n+          proj->disconnect_inputs(NULL, C);\n+          sb->remove_node(k);\n+          new_cnt--;\n+        }\n+        \/\/ Now remove the node itself.\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":33,"deletions":6,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -117,0 +117,2 @@\n+    \/\/ This assumes that the instruction is not used in the other exception\n+    \/\/ blocks. Global code motion is responsible for maintaining this invariant.\n","filename":"src\/hotspot\/share\/opto\/reg_split.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1152,0 +1152,5 @@\n+      \/\/ Special case for min_jint - it can't be negated.\n+      if (arg_val == min_jint) {\n+        return __ intcon(11);\n+      }\n+\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/classLoaderData.hpp\"\n@@ -81,1 +82,2 @@\n-  unsigned int hash = method->klass_name()->identity_hash();\n+  unsigned int hash = method->method_holder()->class_loader_data()->identity_hash();\n+  hash = (hash * 31) ^ method->klass_name()->identity_hash();\n","filename":"src\/hotspot\/share\/prims\/resolvedMethodTable.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1553,1 +1553,1 @@\n-      ? java_lang_ClassLoader::loader_data(class_loader_oop)\n+      ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)\n@@ -1564,1 +1564,1 @@\n-      ? java_lang_ClassLoader::loader_data(class_loader_oop)\n+      ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,1 @@\n-\n+Mutex*   NMethodSweeperStats_lock     = NULL;\n@@ -142,0 +142,1 @@\n+Monitor* JfrThreadSampler_lock        = NULL;\n@@ -150,0 +151,1 @@\n+Mutex*   ClassLoaderDataGraph_lock    = NULL;\n@@ -151,0 +153,3 @@\n+Monitor* ThreadsSMRDelete_lock       = NULL;\n+Mutex*   SharedDecoder_lock           = NULL;\n+Mutex*   DCmdFactory_lock             = NULL;\n@@ -238,0 +243,1 @@\n+  def(ClassLoaderDataGraph_lock    , PaddedMutex  , nonleaf,     true,  Monitor::_safepoint_check_always);\n@@ -244,1 +250,1 @@\n-  def(SharedDictionary_lock        , PaddedMutex,   leaf,        true,  Monitor::_safepoint_check_always);     \/\/ lookups done by VM thread\n+  def(SharedDictionary_lock        , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_always);     \/\/ lookups done by VM thread\n@@ -326,0 +332,1 @@\n+  def(JfrThreadSampler_lock        , PaddedMonitor, leaf,        true,  Monitor::_safepoint_check_never);\n@@ -334,0 +341,5 @@\n+\n+  def(NMethodSweeperStats_lock     , PaddedMutex  , special,     true,  Monitor::_safepoint_check_sometimes);\n+  def(ThreadsSMRDelete_lock        , PaddedMonitor, special,     false, Monitor::_safepoint_check_never);\n+  def(SharedDecoder_lock           , PaddedMutex  , native,      false, Monitor::_safepoint_check_never);\n+  def(DCmdFactory_lock             , PaddedMutex  , leaf,        true,  Monitor::_safepoint_check_never);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,0 +112,1 @@\n+extern Mutex*   NMethodSweeperStats_lock;        \/\/ a lock used to serialize access to sweeper statistics\n@@ -137,0 +138,3 @@\n+extern Monitor* ThreadsSMRDelete_lock;           \/\/ Used by ThreadsSMRSupport to take pressure off the Threads_lock\n+extern Mutex*   SharedDecoder_lock;              \/\/ serializes access to the decoder during normal (not error reporting) use\n+extern Mutex*   DCmdFactory_lock;                \/\/ serialize access to DCmdFactory information\n@@ -142,0 +146,1 @@\n+extern Monitor* JfrThreadSampler_lock;           \/\/ used to suspend\/resume JFR thread sampler\n@@ -149,1 +154,1 @@\n-\n+extern Mutex*   ClassLoaderDataGraph_lock;       \/\/ protects CLDG list, needed for concurrent unloading\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -163,2 +163,0 @@\n-Monitor* NMethodSweeper::_stat_lock = new Monitor(Mutex::special, \"Sweeper::Statistics\", true, Monitor::_safepoint_check_sometimes);\n-\n@@ -508,1 +506,1 @@\n-    MutexLockerEx mu(_stat_lock, Mutex::_no_safepoint_check_flag);\n+    MutexLockerEx mu(NMethodSweeperStats_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/runtime\/sweeper.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,2 +91,0 @@\n-  static Monitor*  _stat_lock;\n-\n","filename":"src\/hotspot\/share\/runtime\/sweeper.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,4 +41,0 @@\n-Monitor*              ThreadsSMRSupport::_delete_lock =\n-                          new Monitor(Monitor::special, \"Thread_SMR_delete_lock\",\n-                                      false \/* allow_vm_block *\/,\n-                                      Monitor::_safepoint_check_never);\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,2 @@\n-  static Monitor*              _delete_lock;\n+  static Monitor* delete_lock() { return ThreadsSMRDelete_lock; }\n+\n@@ -124,1 +125,0 @@\n-  static Monitor* delete_lock() { return _delete_lock; }\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -494,1 +494,0 @@\n-Mutex* DCmdFactory::_dcmdFactory_lock = new Mutex(Mutex::leaf, \"DCmdFactory\", true, Monitor::_safepoint_check_never);\n@@ -498,1 +497,1 @@\n-  MutexLockerEx ml(_dcmdFactory_lock, Mutex::_no_safepoint_check_flag);\n+  MutexLockerEx ml(DCmdFactory_lock, Mutex::_no_safepoint_check_flag);\n@@ -515,1 +514,1 @@\n-  MutexLockerEx ml(_dcmdFactory_lock, Mutex::_no_safepoint_check_flag);\n+  MutexLockerEx ml(DCmdFactory_lock, Mutex::_no_safepoint_check_flag);\n@@ -540,1 +539,1 @@\n-  MutexLockerEx ml(_dcmdFactory_lock, Mutex::_no_safepoint_check_flag);\n+  MutexLockerEx ml(DCmdFactory_lock, Mutex::_no_safepoint_check_flag);\n@@ -553,1 +552,1 @@\n-  MutexLockerEx ml(_dcmdFactory_lock, Mutex::_no_safepoint_check_flag);\n+  MutexLockerEx ml(DCmdFactory_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -347,1 +347,0 @@\n-  static Mutex*       _dcmdFactory_lock;\n","filename":"src\/hotspot\/share\/services\/diagnosticFramework.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,4 +44,0 @@\n-Mutex*            Decoder::_shared_decoder_lock = new Mutex(Mutex::native,\n-                                \"SharedDecoderLock\",\n-                                false,\n-                                Monitor::_safepoint_check_never);\n@@ -50,2 +46,1 @@\n-  assert(_shared_decoder_lock != NULL && _shared_decoder_lock->owned_by_self(),\n-    \"Require DecoderLock to enter\");\n+  assert(shared_decoder_lock()->owned_by_self(), \"Require DecoderLock to enter\");\n@@ -92,1 +87,2 @@\n-                NULL : Decoder::shared_decoder_lock(), true) {\n+                NULL : Decoder::shared_decoder_lock(),\n+                Mutex::_no_safepoint_check_flag) {\n@@ -99,2 +95,2 @@\n-  assert(_shared_decoder_lock != NULL, \"Just check\");\n-  return _shared_decoder_lock;\n+  assert(SharedDecoder_lock != NULL, \"Just check\");\n+  return SharedDecoder_lock;\n@@ -104,1 +100,0 @@\n-  assert(_shared_decoder_lock != NULL, \"Just check\");\n@@ -106,1 +101,2 @@\n-  MutexLockerEx locker(error_handling_thread ? NULL : _shared_decoder_lock, true);\n+  MutexLockerEx locker(error_handling_thread ? NULL : shared_decoder_lock(),\n+                       Mutex::_no_safepoint_check_flag);\n@@ -115,1 +111,0 @@\n-  assert(_shared_decoder_lock != NULL, \"Just check\");\n@@ -117,1 +112,2 @@\n-  MutexLockerEx locker(error_handling_thread ? NULL : _shared_decoder_lock, true);\n+  MutexLockerEx locker(error_handling_thread ? NULL : shared_decoder_lock(),\n+                       Mutex::_no_safepoint_check_flag);\n@@ -127,1 +123,0 @@\n-  assert(_shared_decoder_lock != NULL, \"Just check\");\n@@ -129,1 +124,2 @@\n-  MutexLockerEx locker(error_handling_thread ? NULL : _shared_decoder_lock, true);\n+  MutexLockerEx locker(error_handling_thread ? NULL : shared_decoder_lock(),\n+                       Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/utilities\/decoder.cpp","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -134,1 +134,0 @@\n-  static Mutex*               _shared_decoder_lock;\n","filename":"src\/hotspot\/share\/utilities\/decoder.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -221,2 +221,2 @@\n-inline int g_isfinite(jfloat  f)                 { return finite(f); }\n-inline int g_isfinite(jdouble f)                 { return finite(f); }\n+inline int g_isfinite(jfloat  f)                 { return isfinite(f); }\n+inline int g_isfinite(jdouble f)                 { return isfinite(f); }\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_gcc.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -194,0 +194,6 @@\n+            \/\/ fastpath for always Latin1 decodable single byte\n+            if (COMPACT_STRINGS && cd instanceof ArrayDecoder && ((ArrayDecoder)cd).isLatin1Decodable()) {\n+                byte[] dst = new byte[len];\n+                ((ArrayDecoder)cd).decodeToLatin1(ba, off, len, dst);\n+                return result.with(dst, LATIN1);\n+            }\n@@ -281,0 +287,7 @@\n+        \/\/ fastpath for always Latin1 decodable single byte\n+        if (COMPACT_STRINGS && cd instanceof ArrayDecoder && ((ArrayDecoder)cd).isLatin1Decodable()) {\n+            byte[] dst = new byte[len];\n+            ((ArrayDecoder)cd).decodeToLatin1(ba, off, len, dst);\n+            return new Result().with(dst, LATIN1);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,3 @@\n+ *\n+ * FastPath encoded byte[]-> \"String Latin1 coding\" byte[] decoder for use when\n+ * charset is always decodable to the internal String Latin1 coding byte[], ie. all mappings <=0xff\n@@ -39,0 +42,10 @@\n+\n+    \/\/ Is always decodable to internal String Latin1 coding, ie. all mappings <= 0xff\n+    default boolean isLatin1Decodable() {\n+        return false;\n+    }\n+\n+    \/\/ Decode to internal String Latin1 coding byte[] fastpath for when isLatin1Decodable == true\n+    default int decodeToLatin1(byte[] src, int sp, int len, byte[] dst) {\n+        return 0;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/ArrayDecoder.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+        private final boolean isLatin1Decodable;\n@@ -58,0 +59,1 @@\n+            this.isLatin1Decodable = false;\n@@ -64,0 +66,8 @@\n+            this.isLatin1Decodable = false;\n+        }\n+\n+        public Decoder(Charset cs, char[] b2c, boolean isASCIICompatible, boolean isLatin1Decodable) {\n+            super(cs, 1.0f, 1.0f);\n+            this.b2c = b2c;\n+            this.isASCIICompatible = isASCIICompatible;\n+            this.isLatin1Decodable = isLatin1Decodable;\n@@ -127,0 +137,12 @@\n+        @Override\n+        public int decodeToLatin1(byte[] src, int sp, int len, byte[] dst) {\n+            if (len > dst.length)\n+                len = dst.length;\n+\n+            int dp = 0;\n+            while (dp < len) {\n+                dst[dp++] = (byte)decode(src[sp++]);\n+            }\n+            return dp;\n+        }\n+\n@@ -146,0 +168,5 @@\n+\n+        @Override\n+        public boolean isLatin1Decodable() {\n+            return isLatin1Decodable;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/SingleByte.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -73,0 +73,3 @@\n+    TLS_CHACHA20_POLY1305_SHA256(\n+            0x1303, true, \"TLS_CHACHA20_POLY1305_SHA256\",\n+            ProtocolVersion.PROTOCOLS_OF_13, B_CC20_P1305, H_SHA256),\n@@ -94,0 +97,7 @@\n+    \/\/ Not suite B, but we want it to position the suite early in the list\n+    \/\/ of 1.2 suites.\n+    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256(\n+            0xCCA9, true, \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\", \"\",\n+            ProtocolVersion.PROTOCOLS_OF_12,\n+            K_ECDHE_ECDSA, B_CC20_P1305, M_NULL, H_SHA256),\n+\n@@ -99,0 +109,4 @@\n+    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256(\n+            0xCCA8, true, \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\", \"\",\n+            ProtocolVersion.PROTOCOLS_OF_12,\n+            K_ECDHE_RSA, B_CC20_P1305, M_NULL, H_SHA256),\n@@ -115,0 +129,4 @@\n+    TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256(\n+            0xCCAA, true, \"TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256\", \"\",\n+            ProtocolVersion.PROTOCOLS_OF_12,\n+            K_DHE_RSA, B_CC20_P1305, M_NULL, H_SHA256),\n@@ -487,2 +505,0 @@\n-    TLS_CHACHA20_POLY1305_SHA256(                    \/\/ TLS 1.3\n-            \"TLS_CHACHA20_POLY1305_SHA256\", 0x1303),\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CipherSuite.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -132,0 +132,5 @@\n+    \/**\n+     * JCE transformation string for ChaCha20-Poly1305\n+     *\/\n+    static final String CIPHER_CHACHA20_POLY1305 = \"ChaCha20-Poly1305\";\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/JsseJce.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -333,0 +333,26 @@\n+        })),\n+\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    B_CC20_P1305(CIPHER_CHACHA20_POLY1305, AEAD_CIPHER, 32, 32, 12,\n+            12, true, false,\n+        (Map.Entry<ReadCipherGenerator,\n+                ProtocolVersion[]>[])(new Map.Entry[] {\n+            new SimpleImmutableEntry<ReadCipherGenerator, ProtocolVersion[]>(\n+                new T12CC20P1305ReadCipherGenerator(),\n+                ProtocolVersion.PROTOCOLS_OF_12\n+            ),\n+            new SimpleImmutableEntry<ReadCipherGenerator, ProtocolVersion[]>(\n+                new T13CC20P1305ReadCipherGenerator(),\n+                ProtocolVersion.PROTOCOLS_OF_13\n+            )\n+        }),\n+        (Map.Entry<WriteCipherGenerator,\n+                ProtocolVersion[]>[])(new Map.Entry[] {\n+            new SimpleImmutableEntry<WriteCipherGenerator, ProtocolVersion[]>(\n+                new T12CC20P1305WriteCipherGenerator(),\n+                ProtocolVersion.PROTOCOLS_OF_12\n+            ),\n+            new SimpleImmutableEntry<WriteCipherGenerator, ProtocolVersion[]>(\n+                new T13CC20P1305WriteCipherGenerator(),\n+                ProtocolVersion.PROTOCOLS_OF_13\n+            )\n@@ -2101,0 +2127,543 @@\n+    private static final class T12CC20P1305ReadCipherGenerator\n+            implements ReadCipherGenerator {\n+\n+        @Override\n+        public SSLReadCipher createCipher(SSLCipher sslCipher,\n+                Authenticator authenticator, ProtocolVersion protocolVersion,\n+                String algorithm, Key key, AlgorithmParameterSpec params,\n+                SecureRandom random) throws GeneralSecurityException {\n+            return new CC20P1305ReadCipher(authenticator, protocolVersion,\n+                    sslCipher, algorithm, key, params, random);\n+        }\n+\n+        static final class CC20P1305ReadCipher extends SSLReadCipher {\n+            private final Cipher cipher;\n+            private final int tagSize;\n+            private final Key key;\n+            private final byte[] iv;\n+            private final SecureRandom random;\n+\n+            CC20P1305ReadCipher(Authenticator authenticator,\n+                    ProtocolVersion protocolVersion,\n+                    SSLCipher sslCipher, String algorithm,\n+                    Key key, AlgorithmParameterSpec params,\n+                    SecureRandom random) throws GeneralSecurityException {\n+                super(authenticator, protocolVersion);\n+                this.cipher = JsseJce.getCipher(algorithm);\n+                this.tagSize = sslCipher.tagSize;\n+                this.key = key;\n+                this.iv = ((IvParameterSpec)params).getIV();\n+                this.random = random;\n+\n+                \/\/ DON'T initialize the cipher for AEAD!\n+            }\n+\n+            @Override\n+            public Plaintext decrypt(byte contentType, ByteBuffer bb,\n+                    byte[] sequence) throws GeneralSecurityException {\n+                if (bb.remaining() <= tagSize) {\n+                    throw new BadPaddingException(\n+                        \"Insufficient buffer remaining for AEAD cipher \" +\n+                        \"fragment (\" + bb.remaining() + \"). Needs to be \" +\n+                        \"more than tag size (\" + tagSize + \")\");\n+                }\n+\n+                byte[] sn = sequence;\n+                if (sn == null) {\n+                    sn = authenticator.sequenceNumber();\n+                }\n+                byte[] nonce = new byte[iv.length];\n+                System.arraycopy(sn, 0, nonce, nonce.length - sn.length,\n+                        sn.length);\n+                for (int i = 0; i < nonce.length; i++) {\n+                    nonce[i] ^= iv[i];\n+                }\n+\n+                \/\/ initialize the AEAD cipher with the unique IV\n+                AlgorithmParameterSpec spec = new IvParameterSpec(nonce);\n+                try {\n+                    cipher.init(Cipher.DECRYPT_MODE, key, spec, random);\n+                } catch (InvalidKeyException |\n+                            InvalidAlgorithmParameterException ikae) {\n+                    \/\/ unlikely to happen\n+                    throw new RuntimeException(\n+                                \"invalid key or spec in AEAD mode\", ikae);\n+                }\n+\n+                \/\/ update the additional authentication data\n+                byte[] aad = authenticator.acquireAuthenticationBytes(\n+                        contentType, bb.remaining() - tagSize, sequence);\n+                cipher.updateAAD(aad);\n+\n+                \/\/ DON'T decrypt the nonce_explicit for AEAD mode. The buffer\n+                \/\/ position has moved out of the nonce_explicit range.\n+                int len = bb.remaining();\n+                int pos = bb.position();\n+                ByteBuffer dup = bb.duplicate();\n+                try {\n+                    len = cipher.doFinal(dup, bb);\n+                } catch (IllegalBlockSizeException ibse) {\n+                    \/\/ unlikely to happen\n+                    throw new RuntimeException(\n+                        \"Cipher error in AEAD mode \\\"\" + ibse.getMessage() +\n+                        \" \\\"in JCE provider \" + cipher.getProvider().getName());\n+                } catch (ShortBufferException sbe) {\n+                    \/\/ catch BouncyCastle buffering error\n+                    throw new RuntimeException(\"Cipher buffering error in \" +\n+                        \"JCE provider \" + cipher.getProvider().getName(), sbe);\n+                }\n+                \/\/ reset the limit to the end of the decrypted data\n+                bb.position(pos);\n+                bb.limit(pos + len);\n+\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                    SSLLogger.fine(\n+                            \"Plaintext after DECRYPTION\", bb.duplicate());\n+                }\n+\n+                return new Plaintext(contentType,\n+                        ProtocolVersion.NONE.major, ProtocolVersion.NONE.minor,\n+                        -1, -1L, bb.slice());\n+            }\n+\n+            @Override\n+            void dispose() {\n+                if (cipher != null) {\n+                    try {\n+                        cipher.doFinal();\n+                    } catch (Exception e) {\n+                        \/\/ swallow all types of exceptions.\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            int estimateFragmentSize(int packetSize, int headerSize) {\n+                return packetSize - headerSize - tagSize;\n+            }\n+        }\n+    }\n+\n+    private static final class T12CC20P1305WriteCipherGenerator\n+            implements WriteCipherGenerator {\n+        @Override\n+        public SSLWriteCipher createCipher(SSLCipher sslCipher,\n+                Authenticator authenticator, ProtocolVersion protocolVersion,\n+                String algorithm, Key key, AlgorithmParameterSpec params,\n+                SecureRandom random) throws GeneralSecurityException {\n+            return new CC20P1305WriteCipher(authenticator, protocolVersion,\n+                    sslCipher, algorithm, key, params, random);\n+        }\n+\n+        private static final class CC20P1305WriteCipher extends SSLWriteCipher {\n+            private final Cipher cipher;\n+            private final int tagSize;\n+            private final Key key;\n+            private final byte[] iv;\n+            private final SecureRandom random;\n+\n+            CC20P1305WriteCipher(Authenticator authenticator,\n+                    ProtocolVersion protocolVersion,\n+                    SSLCipher sslCipher, String algorithm,\n+                    Key key, AlgorithmParameterSpec params,\n+                    SecureRandom random) throws GeneralSecurityException {\n+                super(authenticator, protocolVersion);\n+                this.cipher = JsseJce.getCipher(algorithm);\n+                this.tagSize = sslCipher.tagSize;\n+                this.key = key;\n+                this.iv = ((IvParameterSpec)params).getIV();\n+                this.random = random;\n+\n+                keyLimitCountdown = cipherLimits.getOrDefault(\n+                        algorithm.toUpperCase() + \":\" + tag[0], 0L);\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    SSLLogger.fine(\"algorithm = \" + algorithm.toUpperCase() +\n+                            \":\" + tag[0] + \"\\ncountdown value = \" +\n+                            keyLimitCountdown);\n+                }\n+                if (keyLimitCountdown > 0) {\n+                    keyLimitEnabled = true;\n+                }\n+\n+                \/\/ DON'T initialize the cipher for AEAD!\n+            }\n+\n+            @Override\n+            public int encrypt(byte contentType,\n+                    ByteBuffer bb) {\n+                byte[] sn = authenticator.sequenceNumber();\n+                byte[] nonce = new byte[iv.length];\n+                System.arraycopy(sn, 0, nonce, nonce.length - sn.length,\n+                        sn.length);\n+                for (int i = 0; i < nonce.length; i++) {\n+                    nonce[i] ^= iv[i];\n+                }\n+\n+                \/\/ initialize the AEAD cipher for the unique IV\n+                AlgorithmParameterSpec spec = new IvParameterSpec(nonce);\n+                try {\n+                    cipher.init(Cipher.ENCRYPT_MODE, key, spec, random);\n+                } catch (InvalidKeyException |\n+                            InvalidAlgorithmParameterException ikae) {\n+                    \/\/ unlikely to happen\n+                    throw new RuntimeException(\n+                                \"invalid key or spec in AEAD mode\", ikae);\n+                }\n+\n+                \/\/ Update the additional authentication data, using the\n+                \/\/ implicit sequence number of the authenticator.\n+                byte[] aad = authenticator.acquireAuthenticationBytes(\n+                                        contentType, bb.remaining(), null);\n+                cipher.updateAAD(aad);\n+\n+                \/\/ DON'T encrypt the nonce for AEAD mode.\n+                int len = bb.remaining();\n+                int pos = bb.position();\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                    SSLLogger.fine(\n+                            \"Plaintext before ENCRYPTION\",\n+                            bb.duplicate());\n+                }\n+\n+                ByteBuffer dup = bb.duplicate();\n+                int outputSize = cipher.getOutputSize(dup.remaining());\n+                if (outputSize > bb.remaining()) {\n+                    \/\/ Need to expand the limit of the output buffer for\n+                    \/\/ the authentication tag.\n+                    \/\/\n+                    \/\/ DON'T worry about the buffer's capacity, we have\n+                    \/\/ reserved space for the authentication tag.\n+                    bb.limit(pos + outputSize);\n+                }\n+\n+                try {\n+                    len = cipher.doFinal(dup, bb);\n+                } catch (IllegalBlockSizeException |\n+                            BadPaddingException | ShortBufferException ibse) {\n+                    \/\/ unlikely to happen\n+                    throw new RuntimeException(\n+                            \"Cipher error in AEAD mode in JCE provider \" +\n+                            cipher.getProvider().getName(), ibse);\n+                }\n+\n+                if (len != outputSize) {\n+                    throw new RuntimeException(\n+                            \"Cipher buffering error in JCE provider \" +\n+                            cipher.getProvider().getName());\n+                }\n+\n+                return len;\n+            }\n+\n+            @Override\n+            void dispose() {\n+                if (cipher != null) {\n+                    try {\n+                        cipher.doFinal();\n+                    } catch (Exception e) {\n+                        \/\/ swallow all types of exceptions.\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            int getExplicitNonceSize() {\n+                return 0;\n+            }\n+\n+            @Override\n+            int calculateFragmentSize(int packetLimit, int headerSize) {\n+                return packetLimit - headerSize - tagSize;\n+            }\n+\n+            @Override\n+            int calculatePacketSize(int fragmentSize, int headerSize) {\n+                return fragmentSize + headerSize + tagSize;\n+            }\n+        }\n+    }\n+\n+    private static final class T13CC20P1305ReadCipherGenerator\n+            implements ReadCipherGenerator {\n+\n+        @Override\n+        public SSLReadCipher createCipher(SSLCipher sslCipher,\n+                Authenticator authenticator, ProtocolVersion protocolVersion,\n+                String algorithm, Key key, AlgorithmParameterSpec params,\n+                SecureRandom random) throws GeneralSecurityException {\n+            return new CC20P1305ReadCipher(authenticator, protocolVersion,\n+                    sslCipher, algorithm, key, params, random);\n+        }\n+\n+        static final class CC20P1305ReadCipher extends SSLReadCipher {\n+            private final Cipher cipher;\n+            private final int tagSize;\n+            private final Key key;\n+            private final byte[] iv;\n+            private final SecureRandom random;\n+\n+            CC20P1305ReadCipher(Authenticator authenticator,\n+                    ProtocolVersion protocolVersion,\n+                    SSLCipher sslCipher, String algorithm,\n+                    Key key, AlgorithmParameterSpec params,\n+                    SecureRandom random) throws GeneralSecurityException {\n+                super(authenticator, protocolVersion);\n+                this.cipher = JsseJce.getCipher(algorithm);\n+                this.tagSize = sslCipher.tagSize;\n+                this.key = key;\n+                this.iv = ((IvParameterSpec)params).getIV();\n+                this.random = random;\n+\n+                \/\/ DON'T initialize the cipher for AEAD!\n+            }\n+\n+            @Override\n+            public Plaintext decrypt(byte contentType, ByteBuffer bb,\n+                    byte[] sequence) throws GeneralSecurityException {\n+                \/\/ An implementation may receive an unencrypted record of type\n+                \/\/ change_cipher_spec consisting of the single byte value 0x01\n+                \/\/ at any time after the first ClientHello message has been\n+                \/\/ sent or received and before the peer's Finished message has\n+                \/\/ been received and MUST simply drop it without further\n+                \/\/ processing.\n+                if (contentType == ContentType.CHANGE_CIPHER_SPEC.id) {\n+                    return new Plaintext(contentType,\n+                        ProtocolVersion.NONE.major, ProtocolVersion.NONE.minor,\n+                        -1, -1L, bb.slice());\n+                }\n+\n+                if (bb.remaining() <= tagSize) {\n+                    throw new BadPaddingException(\n+                        \"Insufficient buffer remaining for AEAD cipher \" +\n+                        \"fragment (\" + bb.remaining() + \"). Needs to be \" +\n+                        \"more than tag size (\" + tagSize + \")\");\n+                }\n+\n+                byte[] sn = sequence;\n+                if (sn == null) {\n+                    sn = authenticator.sequenceNumber();\n+                }\n+                byte[] nonce = new byte[iv.length];\n+                System.arraycopy(sn, 0, nonce, nonce.length - sn.length,\n+                        sn.length);\n+                for (int i = 0; i < nonce.length; i++) {\n+                    nonce[i] ^= iv[i];\n+                }\n+\n+                \/\/ initialize the AEAD cipher with the unique IV\n+                AlgorithmParameterSpec spec = new IvParameterSpec(nonce);\n+                try {\n+                    cipher.init(Cipher.DECRYPT_MODE, key, spec, random);\n+                } catch (InvalidKeyException |\n+                            InvalidAlgorithmParameterException ikae) {\n+                    \/\/ unlikely to happen\n+                    throw new RuntimeException(\n+                                \"invalid key or spec in AEAD mode\", ikae);\n+                }\n+\n+                \/\/ Update the additional authentication data, using the\n+                \/\/ implicit sequence number of the authenticator.\n+                byte[] aad = authenticator.acquireAuthenticationBytes(\n+                                        contentType, bb.remaining(), sn);\n+                cipher.updateAAD(aad);\n+\n+                int len = bb.remaining();\n+                int pos = bb.position();\n+                ByteBuffer dup = bb.duplicate();\n+                try {\n+                    len = cipher.doFinal(dup, bb);\n+                } catch (IllegalBlockSizeException ibse) {\n+                    \/\/ unlikely to happen\n+                    throw new RuntimeException(\n+                        \"Cipher error in AEAD mode \\\"\" + ibse.getMessage() +\n+                        \" \\\"in JCE provider \" + cipher.getProvider().getName());\n+                } catch (ShortBufferException sbe) {\n+                    \/\/ catch BouncyCastle buffering error\n+                    throw new RuntimeException(\"Cipher buffering error in \" +\n+                        \"JCE provider \" + cipher.getProvider().getName(), sbe);\n+                }\n+                \/\/ reset the limit to the end of the decrypted data\n+                bb.position(pos);\n+                bb.limit(pos + len);\n+\n+                \/\/ remove inner plaintext padding\n+                int i = bb.limit() - 1;\n+                for (; i > 0 && bb.get(i) == 0; i--) {\n+                    \/\/ blank\n+                }\n+                if (i < (pos + 1)) {\n+                    throw new BadPaddingException(\n+                            \"Incorrect inner plaintext: no content type\");\n+                }\n+                contentType = bb.get(i);\n+                bb.limit(i);\n+\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                    SSLLogger.fine(\n+                            \"Plaintext after DECRYPTION\", bb.duplicate());\n+                }\n+\n+                return new Plaintext(contentType,\n+                        ProtocolVersion.NONE.major, ProtocolVersion.NONE.minor,\n+                        -1, -1L, bb.slice());\n+            }\n+\n+            @Override\n+            void dispose() {\n+                if (cipher != null) {\n+                    try {\n+                        cipher.doFinal();\n+                    } catch (Exception e) {\n+                        \/\/ swallow all types of exceptions.\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            int estimateFragmentSize(int packetSize, int headerSize) {\n+                return packetSize - headerSize - tagSize;\n+            }\n+        }\n+    }\n+\n+    private static final class T13CC20P1305WriteCipherGenerator\n+            implements WriteCipherGenerator {\n+        @Override\n+        public SSLWriteCipher createCipher(SSLCipher sslCipher,\n+                Authenticator authenticator, ProtocolVersion protocolVersion,\n+                String algorithm, Key key, AlgorithmParameterSpec params,\n+                SecureRandom random) throws GeneralSecurityException {\n+            return new CC20P1305WriteCipher(authenticator, protocolVersion,\n+                    sslCipher, algorithm, key, params, random);\n+        }\n+\n+        private static final class CC20P1305WriteCipher extends SSLWriteCipher {\n+            private final Cipher cipher;\n+            private final int tagSize;\n+            private final Key key;\n+            private final byte[] iv;\n+            private final SecureRandom random;\n+\n+            CC20P1305WriteCipher(Authenticator authenticator,\n+                    ProtocolVersion protocolVersion,\n+                    SSLCipher sslCipher, String algorithm,\n+                    Key key, AlgorithmParameterSpec params,\n+                    SecureRandom random) throws GeneralSecurityException {\n+                super(authenticator, protocolVersion);\n+                this.cipher = JsseJce.getCipher(algorithm);\n+                this.tagSize = sslCipher.tagSize;\n+                this.key = key;\n+                this.iv = ((IvParameterSpec)params).getIV();\n+                this.random = random;\n+\n+                keyLimitCountdown = cipherLimits.getOrDefault(\n+                        algorithm.toUpperCase() + \":\" + tag[0], 0L);\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    SSLLogger.fine(\"algorithm = \" + algorithm.toUpperCase() +\n+                            \":\" + tag[0] + \"\\ncountdown value = \" +\n+                            keyLimitCountdown);\n+                }\n+                if (keyLimitCountdown > 0) {\n+                    keyLimitEnabled = true;\n+                }\n+\n+                \/\/ DON'T initialize the cipher for AEAD!\n+            }\n+\n+            @Override\n+            public int encrypt(byte contentType,\n+                    ByteBuffer bb) {\n+                byte[] sn = authenticator.sequenceNumber();\n+                byte[] nonce = new byte[iv.length];\n+                System.arraycopy(sn, 0, nonce, nonce.length - sn.length,\n+                        sn.length);\n+                for (int i = 0; i < nonce.length; i++) {\n+                    nonce[i] ^= iv[i];\n+                }\n+\n+                \/\/ initialize the AEAD cipher for the unique IV\n+                AlgorithmParameterSpec spec = new IvParameterSpec(nonce);\n+                try {\n+                    cipher.init(Cipher.ENCRYPT_MODE, key, spec, random);\n+                } catch (InvalidKeyException |\n+                            InvalidAlgorithmParameterException ikae) {\n+                    \/\/ unlikely to happen\n+                    throw new RuntimeException(\n+                                \"invalid key or spec in AEAD mode\", ikae);\n+                }\n+\n+                \/\/ Update the additional authentication data, using the\n+                \/\/ implicit sequence number of the authenticator.\n+                int outputSize = cipher.getOutputSize(bb.remaining());\n+                byte[] aad = authenticator.acquireAuthenticationBytes(\n+                                        contentType, outputSize, sn);\n+                cipher.updateAAD(aad);\n+\n+                int len = bb.remaining();\n+                int pos = bb.position();\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                    SSLLogger.fine(\n+                            \"Plaintext before ENCRYPTION\",\n+                            bb.duplicate());\n+                }\n+\n+                ByteBuffer dup = bb.duplicate();\n+                if (outputSize > bb.remaining()) {\n+                    \/\/ Need to expand the limit of the output buffer for\n+                    \/\/ the authentication tag.\n+                    \/\/\n+                    \/\/ DON'T worry about the buffer's capacity, we have\n+                    \/\/ reserved space for the authentication tag.\n+                    bb.limit(pos + outputSize);\n+                }\n+\n+                try {\n+                    len = cipher.doFinal(dup, bb);\n+                } catch (IllegalBlockSizeException |\n+                            BadPaddingException | ShortBufferException ibse) {\n+                    \/\/ unlikely to happen\n+                    throw new RuntimeException(\n+                            \"Cipher error in AEAD mode in JCE provider \" +\n+                            cipher.getProvider().getName(), ibse);\n+                }\n+\n+                if (len != outputSize) {\n+                    throw new RuntimeException(\n+                            \"Cipher buffering error in JCE provider \" +\n+                            cipher.getProvider().getName());\n+                }\n+\n+                if (keyLimitEnabled) {\n+                    keyLimitCountdown -= len;\n+                }\n+                return len;\n+            }\n+\n+            @Override\n+            void dispose() {\n+                if (cipher != null) {\n+                    try {\n+                        cipher.doFinal();\n+                    } catch (Exception e) {\n+                        \/\/ swallow all types of exceptions.\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            int getExplicitNonceSize() {\n+                return 0;\n+            }\n+\n+            @Override\n+            int calculateFragmentSize(int packetLimit, int headerSize) {\n+                return packetLimit - headerSize - tagSize;\n+            }\n+\n+            @Override\n+            int calculatePacketSize(int fragmentSize, int headerSize) {\n+                return fragmentSize + headerSize + tagSize;\n+            }\n+        }\n+    }\n+\n@@ -2386,1 +2955,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLCipher.java","additions":569,"deletions":1,"binary":false,"changes":570,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-import java.util.Iterator;\n+import java.util.Objects;\n@@ -119,2 +119,1 @@\n-            for (Iterator<T> iter = sl.iterator(); iter.hasNext(); ) {\n-                T tool = iter.next();\n+            for (T tool : sl) {\n@@ -141,1 +140,1 @@\n-            return toolModuleName.equals(moduleName);\n+            return Objects.equals(toolModuleName, moduleName);\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/ToolProvider.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#import \"OSVersion.h\"\n@@ -59,4 +58,1 @@\n-    static int shouldUsePressAndHold = -1;\n-    if (shouldUsePressAndHold != -1) return shouldUsePressAndHold;\n-    shouldUsePressAndHold = !isSnowLeopardOrLower();\n-    return shouldUsePressAndHold;\n+    return YES;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTView.m","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Support for detecting Mac OS X versions\n-\n-double getOSXMajorVersion();\n-BOOL isSnowLeopardOrLower();\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/OSVersion.h","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Support for detecting Mac OS X Versions\n-\n-#include <math.h>\n-#include <stdlib.h>\n-#include <stdio.h>\n-#import <JavaRuntimeSupport\/JavaRuntimeSupport.h>\n-\n-\n-\/\/ returns 107 for Lion, 106 for SnowLeopard etc.\n-int getOSXMajorVersion() {\n-    char *ver = JRSCopyOSVersion();\n-    if (ver == NULL) {\n-        return 0;\n-    }\n-\n-    int len = strlen(ver);\n-    int v = 0;\n-\n-    \/\/ Third char must be a '.'\n-    if (len >= 3 && ver[2] == '.') {\n-        int i;\n-\n-        v = (ver[0] - '0') * 10 + (ver[1] - '0');\n-        for (i = 3; i < len && isdigit(ver[i]); ++i) {\n-            v = v * 10 + (ver[i] - '0');\n-        }\n-    }\n-\n-    free(ver);\n-\n-    return v;\n-}\n-\n-BOOL isSnowLeopardOrLower() {\n-    return (getOSXMajorVersion() < 107);\n-}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/OSVersion.m","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -258,3 +258,3 @@\n-static MIDIClientRef client = (MIDIClientRef) NULL;\n-static MIDIPortRef inPort = (MIDIPortRef) NULL;\n-static MIDIPortRef outPort = (MIDIPortRef) NULL;\n+static MIDIClientRef client = (MIDIClientRef) 0;\n+static MIDIPortRef inPort = (MIDIPortRef) 0;\n+static MIDIPortRef outPort = (MIDIPortRef) 0;\n@@ -466,1 +466,1 @@\n-    MIDIEndpointRef endpoint = (MIDIEndpointRef) NULL;\n+    MIDIEndpointRef endpoint = (MIDIEndpointRef) 0;\n","filename":"src\/java.desktop\/macosx\/native\/libjsound\/PLATFORM_API_MacOSX_MidiUtils.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## Mesa 3-D Graphics Library v19.2.1\n+## Mesa 3-D Graphics Library v21.0.3\n","filename":"src\/java.desktop\/share\/legal\/mesa3d.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,5 +59,0 @@\n-#if defined(USE_MGL_NAMESPACE)\n-#include \"gl_mangle.h\"\n-#endif\n-\n-\n@@ -2134,7 +2129,0 @@\n-\/**\n- ** NOTE!!!!!  If you add new functions to this file, or update\n- ** glext.h be sure to regenerate the gl_mangle.h file.  See comments\n- ** in that file for details.\n- **\/\n-\n-\n","filename":"src\/java.desktop\/share\/native\/common\/java2d\/opengl\/J2D_GL\/gl.h","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-#define GL_GLEXT_VERSION 20190611\n+#define GL_GLEXT_VERSION 20190911\n@@ -5030,0 +5030,16 @@\n+#ifndef GL_KHR_shader_subgroup\n+#define GL_KHR_shader_subgroup 1\n+#define GL_SUBGROUP_SIZE_KHR              0x9532\n+#define GL_SUBGROUP_SUPPORTED_STAGES_KHR  0x9533\n+#define GL_SUBGROUP_SUPPORTED_FEATURES_KHR 0x9534\n+#define GL_SUBGROUP_QUAD_ALL_STAGES_KHR   0x9535\n+#define GL_SUBGROUP_FEATURE_BASIC_BIT_KHR 0x00000001\n+#define GL_SUBGROUP_FEATURE_VOTE_BIT_KHR  0x00000002\n+#define GL_SUBGROUP_FEATURE_ARITHMETIC_BIT_KHR 0x00000004\n+#define GL_SUBGROUP_FEATURE_BALLOT_BIT_KHR 0x00000008\n+#define GL_SUBGROUP_FEATURE_SHUFFLE_BIT_KHR 0x00000010\n+#define GL_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT_KHR 0x00000020\n+#define GL_SUBGROUP_FEATURE_CLUSTERED_BIT_KHR 0x00000040\n+#define GL_SUBGROUP_FEATURE_QUAD_BIT_KHR  0x00000080\n+#endif \/* GL_KHR_shader_subgroup *\/\n+\n@@ -6503,0 +6519,4 @@\n+#ifndef GL_EXT_EGL_sync\n+#define GL_EXT_EGL_sync 1\n+#endif \/* GL_EXT_EGL_sync *\/\n+\n@@ -9297,0 +9317,11 @@\n+#ifndef GL_MESA_framebuffer_flip_y\n+#define GL_MESA_framebuffer_flip_y 1\n+#define GL_FRAMEBUFFER_FLIP_Y_MESA        0x8BBB\n+typedef void (APIENTRYP PFNGLFRAMEBUFFERPARAMETERIMESAPROC) (GLenum target, GLenum pname, GLint param);\n+typedef void (APIENTRYP PFNGLGETFRAMEBUFFERPARAMETERIVMESAPROC) (GLenum target, GLenum pname, GLint *params);\n+#ifdef GL_GLEXT_PROTOTYPES\n+GLAPI void APIENTRY glFramebufferParameteriMESA (GLenum target, GLenum pname, GLint param);\n+GLAPI void APIENTRY glGetFramebufferParameterivMESA (GLenum target, GLenum pname, GLint *params);\n+#endif\n+#endif \/* GL_MESA_framebuffer_flip_y *\/\n+\n@@ -9410,0 +9441,19 @@\n+#ifndef GL_NVX_gpu_multicast2\n+#define GL_NVX_gpu_multicast2 1\n+#define GL_UPLOAD_GPU_MASK_NVX            0x954A\n+typedef void (APIENTRYP PFNGLUPLOADGPUMASKNVXPROC) (GLbitfield mask);\n+typedef void (APIENTRYP PFNGLMULTICASTVIEWPORTARRAYVNVXPROC) (GLuint gpu, GLuint first, GLsizei count, const GLfloat *v);\n+typedef void (APIENTRYP PFNGLMULTICASTVIEWPORTPOSITIONWSCALENVXPROC) (GLuint gpu, GLuint index, GLfloat xcoeff, GLfloat ycoeff);\n+typedef void (APIENTRYP PFNGLMULTICASTSCISSORARRAYVNVXPROC) (GLuint gpu, GLuint first, GLsizei count, const GLint *v);\n+typedef GLuint (APIENTRYP PFNGLASYNCCOPYBUFFERSUBDATANVXPROC) (GLsizei waitSemaphoreCount, const GLuint *waitSemaphoreArray, const GLuint64 *fenceValueArray, GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray);\n+typedef GLuint (APIENTRYP PFNGLASYNCCOPYIMAGESUBDATANVXPROC) (GLsizei waitSemaphoreCount, const GLuint *waitSemaphoreArray, const GLuint64 *waitValueArray, GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray);\n+#ifdef GL_GLEXT_PROTOTYPES\n+GLAPI void APIENTRY glUploadGpuMaskNVX (GLbitfield mask);\n+GLAPI void APIENTRY glMulticastViewportArrayvNVX (GLuint gpu, GLuint first, GLsizei count, const GLfloat *v);\n+GLAPI void APIENTRY glMulticastViewportPositionWScaleNVX (GLuint gpu, GLuint index, GLfloat xcoeff, GLfloat ycoeff);\n+GLAPI void APIENTRY glMulticastScissorArrayvNVX (GLuint gpu, GLuint first, GLsizei count, const GLint *v);\n+GLAPI GLuint APIENTRY glAsyncCopyBufferSubDataNVX (GLsizei waitSemaphoreCount, const GLuint *waitSemaphoreArray, const GLuint64 *fenceValueArray, GLuint readGpu, GLbitfield writeGpuMask, GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray);\n+GLAPI GLuint APIENTRY glAsyncCopyImageSubDataNVX (GLsizei waitSemaphoreCount, const GLuint *waitSemaphoreArray, const GLuint64 *waitValueArray, GLuint srcGpu, GLbitfield dstGpuMask, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth, GLsizei signalSemaphoreCount, const GLuint *signalSemaphoreArray, const GLuint64 *signalValueArray);\n+#endif\n+#endif \/* GL_NVX_gpu_multicast2 *\/\n+\n@@ -9424,0 +9474,14 @@\n+#ifndef GL_NVX_progress_fence\n+#define GL_NVX_progress_fence 1\n+typedef GLuint (APIENTRYP PFNGLCREATEPROGRESSFENCENVXPROC) (void);\n+typedef void (APIENTRYP PFNGLSIGNALSEMAPHOREUI64NVXPROC) (GLuint signalGpu, GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray);\n+typedef void (APIENTRYP PFNGLWAITSEMAPHOREUI64NVXPROC) (GLuint waitGpu, GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray);\n+typedef void (APIENTRYP PFNGLCLIENTWAITSEMAPHOREUI64NVXPROC) (GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray);\n+#ifdef GL_GLEXT_PROTOTYPES\n+GLAPI GLuint APIENTRY glCreateProgressFenceNVX (void);\n+GLAPI void APIENTRY glSignalSemaphoreui64NVX (GLuint signalGpu, GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray);\n+GLAPI void APIENTRY glWaitSemaphoreui64NVX (GLuint waitGpu, GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray);\n+GLAPI void APIENTRY glClientWaitSemaphoreui64NVX (GLsizei fenceObjectCount, const GLuint *semaphoreArray, const GLuint64 *fenceValueArray);\n+#endif\n+#endif \/* GL_NVX_progress_fence *\/\n+\n@@ -10971,0 +11035,5 @@\n+#ifndef GL_NV_shader_subgroup_partitioned\n+#define GL_NV_shader_subgroup_partitioned 1\n+#define GL_SUBGROUP_FEATURE_PARTITIONED_BIT_NV 0x00000100\n+#endif \/* GL_NV_shader_subgroup_partitioned *\/\n+\n","filename":"src\/java.desktop\/share\/native\/common\/java2d\/opengl\/J2D_GL\/glext.h","additions":70,"deletions":1,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -66,5 +66,0 @@\n-#if defined(USE_MGL_NAMESPACE)\n-#include \"glx_mangle.h\"\n-#endif\n-\n-\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/opengl\/J2D_GL\/glx.h","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-#define GLX_GLXEXT_VERSION 20180525\n+#define GLX_GLXEXT_VERSION 20190911\n@@ -312,0 +312,8 @@\n+#ifndef GLX_EXT_context_priority\n+#define GLX_EXT_context_priority 1\n+#define GLX_CONTEXT_PRIORITY_LEVEL_EXT    0x3100\n+#define GLX_CONTEXT_PRIORITY_HIGH_EXT     0x3101\n+#define GLX_CONTEXT_PRIORITY_MEDIUM_EXT   0x3102\n+#define GLX_CONTEXT_PRIORITY_LOW_EXT      0x3103\n+#endif \/* GLX_EXT_context_priority *\/\n+\n@@ -508,1 +516,0 @@\n-#define GLX_RENDERER_ID_MESA              0x818E\n@@ -533,1 +540,1 @@\n-typedef Bool ( *PFNGLXSET3DFXMODEMESAPROC) (int mode);\n+typedef GLboolean ( *PFNGLXSET3DFXMODEMESAPROC) (GLint mode);\n@@ -535,1 +542,1 @@\n-Bool glXSet3DfxModeMESA (int mode);\n+GLboolean glXSet3DfxModeMESA (GLint mode);\n@@ -580,0 +587,9 @@\n+#ifndef GLX_NV_multigpu_context\n+#define GLX_NV_multigpu_context 1\n+#define GLX_CONTEXT_MULTIGPU_ATTRIB_NV    0x20AA\n+#define GLX_CONTEXT_MULTIGPU_ATTRIB_SINGLE_NV 0x20AB\n+#define GLX_CONTEXT_MULTIGPU_ATTRIB_AFR_NV 0x20AC\n+#define GLX_CONTEXT_MULTIGPU_ATTRIB_MULTICAST_NV 0x20AD\n+#define GLX_CONTEXT_MULTIGPU_ATTRIB_MULTI_DISPLAY_MULTICAST_NV 0x20AE\n+#endif \/* GLX_NV_multigpu_context *\/\n+\n@@ -685,2 +701,0 @@\n-\/* JDK modification *\/\n-#elif defined(__sun__)\n@@ -688,1 +702,1 @@\n-#elif defined(__digital__)\n+#elif defined(__sun__) || defined(__digital__)\n@@ -699,1 +713,0 @@\n-\n@@ -871,1 +884,1 @@\n-typedef int ( *PFNGLXQUERYGLXPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);\n+typedef void ( *PFNGLXQUERYGLXPBUFFERSGIXPROC) (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);\n@@ -877,1 +890,1 @@\n-int glXQueryGLXPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);\n+void glXQueryGLXPbufferSGIX (Display *dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int *value);\n@@ -985,1 +998,1 @@\n-typedef Status ( *PFNGLXGETTRANSPARENTINDEXSUNPROC) (Display *dpy, Window overlay, Window underlay, long *pTransparentIndex);\n+typedef Status ( *PFNGLXGETTRANSPARENTINDEXSUNPROC) (Display *dpy, Window overlay, Window underlay, unsigned long *pTransparentIndex);\n@@ -987,1 +1000,1 @@\n-Status glXGetTransparentIndexSUN (Display *dpy, Window overlay, Window underlay, long *pTransparentIndex);\n+Status glXGetTransparentIndexSUN (Display *dpy, Window overlay, Window underlay, unsigned long *pTransparentIndex);\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/opengl\/J2D_GL\/glxext.h","additions":25,"deletions":12,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1108,0 +1108,4 @@\n+        if (family.isEmpty()) {\n+            return false;\n+        }\n+\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WPrinterJob.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef __wglext_h_\n-#define __wglext_h_ 1\n+#ifndef __wgl_wglext_h_\n+#define __wgl_wglext_h_ 1\n@@ -38,1 +38,1 @@\n-** Copyright (c) 2013-2017 The Khronos Group Inc.\n+** Copyright (c) 2013-2018 The Khronos Group Inc.\n@@ -71,1 +71,1 @@\n-#define WGL_WGLEXT_VERSION 20170817\n+#define WGL_WGLEXT_VERSION 20190728\n@@ -350,1 +350,1 @@\n-typedef INT (WINAPI * PFNWGLGETGPUINFOAMDPROC) (UINT id, int property, GLenum dataType, UINT size, void *data);\n+typedef INT (WINAPI * PFNWGLGETGPUINFOAMDPROC) (UINT id, INT property, GLenum dataType, UINT size, void *data);\n@@ -360,1 +360,1 @@\n-INT WINAPI wglGetGPUInfoAMD (UINT id, int property, GLenum dataType, UINT size, void *data);\n+INT WINAPI wglGetGPUInfoAMD (UINT id, INT property, GLenum dataType, UINT size, void *data);\n@@ -376,0 +376,5 @@\n+#ifndef WGL_ATI_render_texture_rectangle\n+#define WGL_ATI_render_texture_rectangle 1\n+#define WGL_TEXTURE_RECTANGLE_ATI         0x21A5\n+#endif \/* WGL_ATI_render_texture_rectangle *\/\n+\n@@ -378,1 +383,1 @@\n-#define WGL_COLORSPACE_EXT                0x3087\n+#define WGL_COLORSPACE_EXT                0x309D\n@@ -742,0 +747,9 @@\n+#ifndef WGL_NV_multigpu_context\n+#define WGL_NV_multigpu_context 1\n+#define WGL_CONTEXT_MULTIGPU_ATTRIB_NV    0x20AA\n+#define WGL_CONTEXT_MULTIGPU_ATTRIB_SINGLE_NV 0x20AB\n+#define WGL_CONTEXT_MULTIGPU_ATTRIB_AFR_NV 0x20AC\n+#define WGL_CONTEXT_MULTIGPU_ATTRIB_MULTICAST_NV 0x20AD\n+#define WGL_CONTEXT_MULTIGPU_ATTRIB_MULTI_DISPLAY_MULTICAST_NV 0x20AE\n+#endif \/* WGL_NV_multigpu_context *\/\n+\n@@ -752,2 +766,2 @@\n-typedef int (WINAPI * PFNWGLENUMERATEVIDEODEVICESNVPROC) (HDC hDC, HVIDEOOUTPUTDEVICENV *phDeviceList);\n-typedef BOOL (WINAPI * PFNWGLBINDVIDEODEVICENVPROC) (HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList);\n+typedef int (WINAPI * PFNWGLENUMERATEVIDEODEVICESNVPROC) (HDC hDc, HVIDEOOUTPUTDEVICENV *phDeviceList);\n+typedef BOOL (WINAPI * PFNWGLBINDVIDEODEVICENVPROC) (HDC hDc, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList);\n@@ -756,2 +770,2 @@\n-int WINAPI wglEnumerateVideoDevicesNV (HDC hDC, HVIDEOOUTPUTDEVICENV *phDeviceList);\n-BOOL WINAPI wglBindVideoDeviceNV (HDC hDC, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList);\n+int WINAPI wglEnumerateVideoDevicesNV (HDC hDc, HVIDEOOUTPUTDEVICENV *phDeviceList);\n+BOOL WINAPI wglBindVideoDeviceNV (HDC hDc, unsigned int uVideoSlot, HVIDEOOUTPUTDEVICENV hVideoDevice, const int *piAttribList);\n@@ -862,1 +876,1 @@\n-typedef INT64 (WINAPI * PFNWGLSWAPLAYERBUFFERSMSCOMLPROC) (HDC hdc, int fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder);\n+typedef INT64 (WINAPI * PFNWGLSWAPLAYERBUFFERSMSCOMLPROC) (HDC hdc, INT fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder);\n@@ -869,1 +883,1 @@\n-INT64 WINAPI wglSwapLayerBuffersMscOML (HDC hdc, int fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder);\n+INT64 WINAPI wglSwapLayerBuffersMscOML (HDC hdc, INT fuPlanes, INT64 target_msc, INT64 divisor, INT64 remainder);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/opengl\/J2D_GL\/wglext.h","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -243,6 +243,1 @@\n-        if (status != UNAUTHORIZED && status != PROXY_UNAUTHORIZED) {\n-            \/\/ check if any authentication succeeded for first time\n-            if (exchange.serverauth != null && !exchange.serverauth.fromcache) {\n-                AuthInfo au = exchange.serverauth;\n-                cache.store(au.scheme, req.uri(), false, au.credentials);\n-            }\n+        if (status != PROXY_UNAUTHORIZED) {\n@@ -253,0 +248,1 @@\n+                    exchange.proxyauth = null;\n@@ -256,0 +252,6 @@\n+            if (status != UNAUTHORIZED) {\n+            \/\/ check if any authentication succeeded for first time\n+                if (exchange.serverauth != null && !exchange.serverauth.fromcache) {\n+                    AuthInfo au = exchange.serverauth;\n+                    cache.store(au.scheme, req.uri(), false, au.credentials);\n+                }\n@@ -257,0 +259,1 @@\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AuthenticationFilter.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,0 +145,1 @@\n+        assert c == null || c.isSecure() == secure;\n@@ -158,0 +159,4 @@\n+        assert (conn instanceof PlainHttpConnection) || conn.isSecure()\n+            : \"Attempting to return unsecure connection to SSL pool: \"\n+                + conn.getClass();\n+\n@@ -453,1 +458,1 @@\n-            assert c.isSecure();\n+            assert c.isSecure() : \"connection \" + c + \" is not secure!\";\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ConnectionPool.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,1 +266,1 @@\n-            return readBody(discarding(), true, executor);\n+            return readBody(discarding(), !request.isWebSocket(), executor);\n@@ -390,0 +390,8 @@\n+        if (debug.on()) {\n+            debug.log(\"readBody: return2Cache: \" + return2Cache);\n+            if (request.isWebSocket() && return2Cache && connection != null) {\n+                debug.log(\"websocket connection will be returned to cache: \"\n+                        + connection.getClass() + \"\/\" + connection );\n+            }\n+        }\n+        assert !return2Cache || !request.isWebSocket();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Response.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,0 +163,20 @@\n+    \/**\n+     * Closes the RawChannel that may have been used for WebSocket protocol.\n+     *\n+     * @apiNote This method should be called to close the connection\n+     * if an exception occurs during the websocket handshake, in cases where\n+     * {@link #rawChannel() rawChannel().close()} would have been called.\n+     * An unsuccessful handshake may prevent the creation of the RawChannel:\n+     * if a RawChannel has already been created, this method wil close it.\n+     * Otherwise, it will close the connection.\n+     *\n+     * @throws IOException if an I\/O exception occurs while closing\n+     *         the channel.\n+     *\/\n+    public synchronized void closeRawChannel() throws IOException {\n+        \/\/  close the rawChannel, if created, or the\n+        \/\/ connection, if not.\n+        if (rawchan != null) rawchan.close();\n+        else connection.close();\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpResponseImpl.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -366,0 +366,4 @@\n+                            if (currentreq.isWebSocket()) {\n+                                \/\/ need to close the connection and open a new one.\n+                                exch.exchImpl.connection().close();\n+                            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/MultiExchange.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-        dbgTag = \"[WebSocket] RawChannelTube(\" + tube.toString() +\")\";\n+        dbgTag = \"[WebSocket] RawChannelTube(\" + tube +\")\";\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/RawChannelTube.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * -Djava.net.HttpClient.log=\n+ * -Djdk.httpclient.HttpClient.log=\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Log.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -218,1 +218,1 @@\n-        Exception exception = null;\n+        Throwable exception = null;\n@@ -225,0 +225,5 @@\n+        } catch (Error e) {\n+            \/\/ We should attempt to close the connection and relay\n+            \/\/ the error through the completable future even in this\n+            \/\/ case.\n+            exception = e;\n@@ -230,1 +235,3 @@\n-            ((RawChannel.Provider) response).rawChannel().close();\n+            \/\/ calling this method will close the rawChannel, if created,\n+            \/\/ or the connection, if not.\n+            ((RawChannel.Provider) response).closeRawChannel();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/OpeningHandshake.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+        void closeRawChannel() throws IOException;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/RawChannel.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5028,0 +5028,4 @@\n+        protected void reportIllegalSignature(Type t) {\n+            throw new InvalidSignatureException(t);\n+        }\n+\n@@ -5062,1 +5066,1 @@\n-                        throw new InvalidSignatureException(type);\n+                        reportIllegalSignature(type);\n@@ -5107,1 +5111,1 @@\n-                        throw new InvalidSignatureException(type);\n+                        reportIllegalSignature(type);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import com.sun.tools.javac.code.Types.SignatureGenerator.InvalidSignatureException;\n+import com.sun.tools.javac.resources.CompilerProperties.Errors;\n+import com.sun.tools.javac.resources.CompilerProperties.Fragments;\n@@ -2033,1 +2036,1 @@\n-                    buf.append(typeSig(owner.type));\n+                    buf.append(typeSig(owner.type, true));\n@@ -2049,1 +2052,1 @@\n-                        buf.append(typeSig(fv.type));\n+                        buf.append(typeSig(fv.type, true));\n@@ -2438,3 +2441,13 @@\n-        L2MSignatureGenerator sg = new L2MSignatureGenerator();\n-        sg.assembleSig(type);\n-        return sg.toString();\n+        return typeSig(type, false);\n+    }\n+\n+    private String typeSig(Type type, boolean allowIllegalSignature) {\n+        try {\n+            L2MSignatureGenerator sg = new L2MSignatureGenerator(allowIllegalSignature);\n+            sg.assembleSig(type);\n+            return sg.toString();\n+        } catch (InvalidSignatureException ex) {\n+            Symbol c = attrEnv.enclClass.sym;\n+            log.error(Errors.CannotGenerateClass(c, Fragments.IllegalSignature(c, ex.type())));\n+            return \"<ERRONEOUS>\";\n+        }\n@@ -2444,3 +2457,9 @@\n-        L2MSignatureGenerator sg = new L2MSignatureGenerator();\n-        sg.assembleClassSig(type);\n-        return sg.toString();\n+        try {\n+            L2MSignatureGenerator sg = new L2MSignatureGenerator(false);\n+            sg.assembleClassSig(type);\n+            return sg.toString();\n+        } catch (InvalidSignatureException ex) {\n+            Symbol c = attrEnv.enclClass.sym;\n+            log.error(Errors.CannotGenerateClass(c, Fragments.IllegalSignature(c, ex.type())));\n+            return \"<ERRONEOUS>\";\n+        }\n@@ -2459,1 +2478,7 @@\n-        L2MSignatureGenerator() {\n+        \/**\n+         * Are signatures incompatible with JVM spec allowed?\n+         * Used by {@link LambdaTranslationContext#serializedLambdaDisambiguation()}.\n+         *\/\n+        boolean allowIllegalSignatures;\n+\n+        L2MSignatureGenerator(boolean allowIllegalSignatures) {\n@@ -2461,0 +2486,8 @@\n+            this.allowIllegalSignatures = allowIllegalSignatures;\n+        }\n+\n+        @Override\n+        protected void reportIllegalSignature(Type t) {\n+            if (!allowIllegalSignatures) {\n+                super.reportIllegalSignature(t);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":42,"deletions":9,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -246,9 +246,14 @@\n-        Set<String> platformAnnotations = new HashSet<>();\n-        platformAnnotations.add(\"java.lang.Deprecated\");\n-        platformAnnotations.add(\"java.lang.Override\");\n-        platformAnnotations.add(\"java.lang.SuppressWarnings\");\n-        platformAnnotations.add(\"java.lang.annotation.Documented\");\n-        platformAnnotations.add(\"java.lang.annotation.Inherited\");\n-        platformAnnotations.add(\"java.lang.annotation.Retention\");\n-        platformAnnotations.add(\"java.lang.annotation.Target\");\n-        return Collections.unmodifiableSet(platformAnnotations);\n+        final String module_prefix =\n+            Feature.MODULES.allowedInSource(source) ? \"java.base\/\" : \"\";\n+        return Set.of(module_prefix + \"java.lang.Deprecated\",\n+                      module_prefix + \"java.lang.FunctionalInterface\",\n+                      module_prefix + \"java.lang.Override\",\n+                      module_prefix + \"java.lang.SafeVarargs\",\n+                      module_prefix + \"java.lang.SuppressWarnings\",\n+\n+                      module_prefix + \"java.lang.annotation.Documented\",\n+                      module_prefix + \"java.lang.annotation.Inherited\",\n+                      module_prefix + \"java.lang.annotation.Native\",\n+                      module_prefix + \"java.lang.annotation.Repeatable\",\n+                      module_prefix + \"java.lang.annotation.Retention\",\n+                      module_prefix + \"java.lang.annotation.Target\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"proc_service.h\"\n@@ -244,1 +245,1 @@\n- * Signature: (IZ)V\n+ * Signature: (I)V\n@@ -246,2 +247,2 @@\n-JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_attach0__IZ\n-  (JNIEnv *env, jobject this_obj, jint jpid, jboolean is_in_container) {\n+JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_attach0__I\n+  (JNIEnv *env, jobject this_obj, jint jpid) {\n@@ -257,1 +258,1 @@\n-  if ((ph = Pgrab(jpid, err_buf, sizeof(err_buf), is_in_container)) == NULL) {\n+  if ((ph = Pgrab(jpid, err_buf, sizeof(err_buf))) == NULL) {\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/LinuxDebuggerLocal.c","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"proc_service.h\"\n@@ -33,0 +32,1 @@\n+#include <sys\/procfs.h>\n@@ -35,31 +35,0 @@\n-\/************************************************************************************\n-\n-0. This is very minimal subset of Solaris libproc just enough for current application.\n-Please note that the bulk of the functionality is from proc_service interface. This\n-adds Pgrab__ and some missing stuff. We hide the difference b\/w live process and core\n-file by this interface.\n-\n-1. pthread_id unique in both NPTL & LinuxThreads. We store this in\n-OSThread::_pthread_id in JVM code.\n-\n-2. All threads see the same pid when they call getpid() under NPTL.\n-Threads receive different pid under LinuxThreads. We used to save the result of\n-::getpid() call in OSThread::_thread_id. This way uniqueness of OSThread::_thread_id\n-was lost under NPTL. Now, we store the result of ::gettid() call in\n-OSThread::_thread_id. Because gettid returns actual pid of thread (lwp id), this is\n-unique again. We therefore use OSThread::_thread_id as unique identifier.\n-\n-3. There is a unique LWP id under both thread libraries. libthread_db  maps pthread_id\n-to its underlying lwp_id under both the thread libraries. thread_info.lwp_id stores\n-lwp_id of the thread. The lwp id is nothing but the actual pid of clone'd processes. But\n-unfortunately libthread_db does not work very well for core dumps. So, we get pthread_id\n-only for processes. For core dumps, we don't use libthread_db at all (like gdb).\n-\n-4. ptrace operates on this LWP id under both the thread libraries. When we say 'pid' for\n-ptrace call, we refer to lwp_id of the thread.\n-\n-5. for core file, we parse ELF files and read data from them. For processes we  use\n-combination of ptrace and \/proc calls.\n-\n-*************************************************************************************\/\n-\n@@ -90,1 +59,1 @@\n-Pgrab(pid_t pid, char* err_buf, size_t err_buf_len, bool is_in_container);\n+Pgrab(pid_t pid, char* err_buf, size_t err_buf_len);\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/libproc.h","additions":3,"deletions":34,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include <thread_db.h>\n+#include <sys\/procfs.h>\n@@ -31,0 +31,1 @@\n+#include \"proc_service.h\"\n@@ -119,7 +120,0 @@\n-\n-   \/\/ initialize the thread_db library\n-   if (td_init() != TD_OK) {\n-     print_debug(\"libthread_db's td_init failed\\n\");\n-     return false;\n-   }\n-\n@@ -259,1 +253,1 @@\n-thread_info* add_thread_info(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id) {\n+thread_info* add_thread_info(struct ps_prochandle* ph, lwpid_t lwp_id) {\n@@ -267,1 +261,0 @@\n-   newthr->pthread_id = pthread_id;\n@@ -298,58 +291,0 @@\n-\/\/ struct used for client data from thread_db callback\n-struct thread_db_client_data {\n-   struct ps_prochandle* ph;\n-   thread_info_callback callback;\n-};\n-\n-\/\/ callback function for libthread_db\n-static int thread_db_callback(const td_thrhandle_t *th_p, void *data) {\n-  struct thread_db_client_data* ptr = (struct thread_db_client_data*) data;\n-  td_thrinfo_t ti;\n-  td_err_e err;\n-\n-  memset(&ti, 0, sizeof(ti));\n-  err = td_thr_get_info(th_p, &ti);\n-  if (err != TD_OK) {\n-    print_debug(\"libthread_db : td_thr_get_info failed, can't get thread info\\n\");\n-    return err;\n-  }\n-\n-  print_debug(\"thread_db : pthread %d (lwp %d)\\n\", ti.ti_tid, ti.ti_lid);\n-\n-  if (ti.ti_state == TD_THR_UNKNOWN || ti.ti_state == TD_THR_ZOMBIE) {\n-    print_debug(\"Skipping pthread %d (lwp %d)\\n\", ti.ti_tid, ti.ti_lid);\n-    return TD_OK;\n-  }\n-\n-  if (ptr->callback(ptr->ph, ti.ti_tid, ti.ti_lid) != true)\n-    return TD_ERR;\n-\n-  return TD_OK;\n-}\n-\n-\/\/ read thread_info using libthread_db\n-bool read_thread_info(struct ps_prochandle* ph, thread_info_callback cb) {\n-  struct thread_db_client_data mydata;\n-  td_thragent_t* thread_agent = NULL;\n-  if (td_ta_new(ph, &thread_agent) != TD_OK) {\n-     print_debug(\"can't create libthread_db agent\\n\");\n-     return false;\n-  }\n-\n-  mydata.ph = ph;\n-  mydata.callback = cb;\n-\n-  \/\/ we use libthread_db iterator to iterate thru list of threads.\n-  if (td_ta_thr_iter(thread_agent, thread_db_callback, &mydata,\n-                 TD_THR_ANY_STATE, TD_THR_LOWEST_PRIORITY,\n-                 TD_SIGNO_MASK, TD_THR_ANY_USER_FLAGS) != TD_OK) {\n-     td_ta_delete(thread_agent);\n-     return false;\n-  }\n-\n-  \/\/ delete thread agent\n-  td_ta_delete(thread_agent);\n-  return true;\n-}\n-\n-\n@@ -487,6 +422,0 @@\n-\/\/ new libthread_db of NPTL seem to require this symbol\n-JNIEXPORT ps_err_e JNICALL\n-ps_get_thread_area() {\n-  print_debug(\"ps_get_thread_area not implemented\\n\");\n-  return PS_OK;\n-}\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/libproc_impl.c","additions":3,"deletions":74,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-   pthread_t                pthread_id; \/\/ not used cores, always -1\n@@ -112,5 +111,0 @@\n-typedef bool (*thread_info_callback)(struct ps_prochandle* ph, pthread_t pid, lwpid_t lwpid);\n-\n-\/\/ reads thread info using libthread_db and calls above callback for each thread\n-bool read_thread_info(struct ps_prochandle* ph, thread_info_callback cb);\n-\n@@ -128,1 +122,1 @@\n-thread_info* add_thread_info(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id);\n+thread_info* add_thread_info(struct ps_prochandle* ph, lwpid_t lwp_id);\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/libproc_impl.h","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include <thread_db.h>\n+#include <sys\/procfs.h>\n@@ -31,0 +31,1 @@\n+#include \"libproc.h\"\n@@ -32,3 +33,0 @@\n-\/\/ Linux does not have the proc service library, though it does provide the\n-\/\/ thread_db library which can be used to manipulate threads without having\n-\/\/ to know the details of NPTL\n@@ -82,4 +80,0 @@\n-\/\/ new libthread_db of NPTL seem to require this symbol\n-JNIEXPORT ps_err_e JNICALL\n-ps_get_thread_area();\n-\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/proc_service.h","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"proc_service.h\"\n@@ -514,2 +515,1 @@\n-   \/\/ we set pthread_t to -1 for core dump\n-   if((newthr = add_thread_info(ph, (pthread_t) -1,  prstat->pr_pid)) == NULL)\n+   if((newthr = add_thread_info(ph, prstat->pr_pid)) == NULL)\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/ps_core.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -342,5 +342,0 @@\n-\/\/ callback for read_thread_info\n-static bool add_new_thread(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id) {\n-  return add_thread_info(ph, pthread_id, lwp_id) != NULL;\n-}\n-\n@@ -446,1 +441,1 @@\n-Pgrab(pid_t pid, char* err_buf, size_t err_buf_len, bool is_in_container) {\n+Pgrab(pid_t pid, char* err_buf, size_t err_buf_len) {\n@@ -467,0 +462,1 @@\n+  add_thread_info(ph, ph->pid);\n@@ -476,22 +472,21 @@\n-  \/\/ read thread info\n-  if (is_in_container) {\n-    \/*\n-     * If the process is running in the container, SA scans all tasks in\n-     * \/proc\/<PID>\/task to read all threads info.\n-     *\/\n-    char taskpath[PATH_MAX];\n-    DIR *dirp;\n-    struct dirent *entry;\n-\n-    snprintf(taskpath, PATH_MAX, \"\/proc\/%d\/task\", ph->pid);\n-    dirp = opendir(taskpath);\n-    int lwp_id;\n-    while ((entry = readdir(dirp)) != NULL) {\n-      if (*entry->d_name == '.') {\n-        continue;\n-      }\n-      lwp_id = atoi(entry->d_name);\n-      if (lwp_id == ph->pid) {\n-        continue;\n-      }\n-      add_new_thread(ph, -1, lwp_id);\n+  \/*\n+   * Read thread info.\n+   * SA scans all tasks in \/proc\/<PID>\/task to read all threads info.\n+   *\/\n+  char taskpath[PATH_MAX];\n+  DIR *dirp;\n+  struct dirent *entry;\n+\n+  snprintf(taskpath, PATH_MAX, \"\/proc\/%d\/task\", ph->pid);\n+  dirp = opendir(taskpath);\n+  int lwp_id;\n+  while ((entry = readdir(dirp)) != NULL) {\n+    if (*entry->d_name == '.') {\n+      continue;\n+    }\n+    lwp_id = atoi(entry->d_name);\n+    if (lwp_id == ph->pid) {\n+      continue;\n+    }\n+    if (!process_doesnt_exist(lwp_id)) {\n+      add_thread_info(ph, lwp_id);\n@@ -499,3 +494,0 @@\n-    closedir(dirp);\n-  } else {\n-    read_thread_info(ph, add_new_thread);\n@@ -503,0 +495,1 @@\n+  closedir(dirp);\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/ps_proc.c","additions":25,"deletions":32,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-    private native void attach0(int pid, boolean isInContainer)\n+    private native void attach0(int pid)\n@@ -324,1 +324,0 @@\n-           boolean isInContainer;\n@@ -326,1 +325,1 @@\n-              debugger.attach0(pid, isInContainer);\n+              debugger.attach0(pid);\n@@ -335,1 +334,0 @@\n-        task.isInContainer = (processID != NSpid);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/LinuxDebuggerLocal.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-        return (isFinal() || isPrivate() || isStatic() || holder.isLeaf()) && isConcrete();\n+        return (isFinal() || isPrivate() || isStatic() || holder.isLeaf() || isConstructor()) && isConcrete();\n@@ -395,0 +395,2 @@\n+        assert !canBeStaticallyBound() : this;\n+\n@@ -406,0 +408,1 @@\n+        assert !receiver.isLinked() || isInVirtualMethodTable(receiver);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -605,0 +605,4 @@\n+        if (resolvedMethod.canBeStaticallyBound()) {\n+            \/\/ No assumptions are required.\n+            return new AssumptionResult<>(resolvedMethod);\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-                .setTimestamp(true, false)\n+                .setTimestamp(!configuration.notimestamp, false)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/IndexRedirectWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -408,0 +408,8 @@\n+        \/*\n+         * Ignore the module name which should not be shown in the output\n+         *\/\n+        @Override\n+        public String name() {\n+            return getName();\n+        }\n+\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/Analyzer.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -315,1 +315,1 @@\n-        if (source == target || !target.getModule().isNamed()) {\n+        if (source == target || !target.getModule().isNamed() || Analyzer.notFound(target)) {\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/jdeps\/JdepsWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -867,1 +867,1 @@\n-        error(messageFormat(key, args));\n+        error(\"%s\", messageFormat(key, args));\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/JShellTool.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2015 SAP SE. All rights reserved.\n+ * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020 SAP SE. All rights reserved.\n@@ -54,0 +54,7 @@\n+JNIEXPORT jlong JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostTotalCpuTicks0\n+(JNIEnv *env, jobject mbean)\n+{\n+    return -1;\n+}\n+\n@@ -60,0 +67,7 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostOnlineCpuCount0\n+(JNIEnv *env, jobject mbean)\n+{\n+    return -1;\n+}\n","filename":"src\/jdk.management\/aix\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#define NS_PER_SEC 1000000000\n@@ -367,0 +368,37 @@\n+\n+\/\/ Return the host cpu ticks since boot in nanoseconds\n+JNIEXPORT jlong JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostTotalCpuTicks0\n+(JNIEnv *env, jobject mbean)\n+{\n+    if (perfInit() == 0) {\n+        if (get_totalticks(-1, &counters.cpuTicks) < 0) {\n+            return -1;\n+        } else {\n+            long ticks_per_sec = sysconf(_SC_CLK_TCK);\n+            jlong result = (jlong)counters.cpuTicks.total;\n+            if (ticks_per_sec <= NS_PER_SEC) {\n+                long scale_factor = NS_PER_SEC\/ticks_per_sec;\n+                result = result * scale_factor;\n+            } else {\n+                long scale_factor = ticks_per_sec\/NS_PER_SEC;\n+                result = result \/ scale_factor;\n+            }\n+            return result;\n+        }\n+    } else {\n+        return -1;\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostOnlineCpuCount0\n+(JNIEnv *env, jobject mbean)\n+{\n+    int n = sysconf(_SC_NPROCESSORS_ONLN);\n+    if (n <= 0) {\n+        n = 1;\n+    }\n+    return n;\n+}\n+\n","filename":"src\/jdk.management\/linux\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,0 +170,7 @@\n+JNIEXPORT jlong JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostTotalCpuTicks0\n+(JNIEnv *env, jobject mbean)\n+{\n+    return -1;\n+}\n+\n@@ -176,0 +183,8 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostOnlineCpuCount0\n+(JNIEnv *env, jobject mbean)\n+{\n+    return -1;\n+}\n+\n","filename":"src\/jdk.management\/macosx\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+    private long usageTicks = 0; \/\/ used for cpu load calculation\n+    private long totalTicks = 0; \/\/ used for cpu load calculation\n@@ -136,0 +138,32 @@\n+    private double getUsageDividesTotal(long usageTicks, long totalTicks) {\n+        \/\/ If cpu quota or cpu shares are in effect calculate the cpu load\n+        \/\/ based on the following formula (similar to how\n+        \/\/ getCpuLoad0() is being calculated):\n+        \/\/\n+        \/\/   | usageTicks - usageTicks' |\n+        \/\/  ------------------------------\n+        \/\/   | totalTicks - totalTicks' |\n+        \/\/\n+        \/\/ where usageTicks' and totalTicks' are historical values\n+        \/\/ retrieved via an earlier call of this method.\n+        \/\/\n+        \/\/ Total ticks should be scaled to the container effective number\n+        \/\/ of cpus, if cpu shares are in effect.\n+        if (usageTicks < 0 || totalTicks <= 0) {\n+            return -1;\n+        }\n+        long distance = usageTicks - this.usageTicks;\n+        this.usageTicks = usageTicks;\n+        long totalDistance = totalTicks - this.totalTicks;\n+        this.totalTicks = totalTicks;\n+\n+        double systemLoad = 0.0;\n+        if (distance > 0 && totalDistance > 0) {\n+            systemLoad = ((double)distance) \/ totalDistance;\n+        }\n+        \/\/ Ensure the return value is in the range 0.0 -> 1.0\n+        systemLoad = Math.max(0.0, systemLoad);\n+        systemLoad = Math.min(1.0, systemLoad);\n+        return systemLoad;\n+    }\n+\n@@ -139,0 +173,2 @@\n+            long share = containerMetrics.getCpuShares();\n+            long usageNanos = containerMetrics.getCpuUsage();\n@@ -140,1 +176,0 @@\n-                long periodLength = containerMetrics.getCpuPeriod();\n@@ -142,10 +177,9 @@\n-                long usageNanos = containerMetrics.getCpuUsage();\n-                if (periodLength > 0 && numPeriods > 0 && usageNanos > 0) {\n-                    long elapsedNanos = TimeUnit.MICROSECONDS.toNanos(periodLength * numPeriods);\n-                    double systemLoad = (double) usageNanos \/ elapsedNanos;\n-                    \/\/ Ensure the return value is in the range 0.0 -> 1.0\n-                    systemLoad = Math.max(0.0, systemLoad);\n-                    systemLoad = Math.min(1.0, systemLoad);\n-                    return systemLoad;\n-                }\n-                return -1;\n+                long quotaNanos = TimeUnit.MICROSECONDS.toNanos(quota * numPeriods);\n+                return getUsageDividesTotal(usageNanos, quotaNanos);\n+            } else if (share > 0) {\n+                long hostTicks = getHostTotalCpuTicks0();\n+                int totalCPUs = getHostOnlineCpuCount0();\n+                int containerCPUs = getAvailableProcessors();\n+                \/\/ scale the total host load to the actual container cpus\n+                hostTicks = hostTicks * containerCPUs \/ totalCPUs;\n+                return getUsageDividesTotal(usageNanos, hostTicks);\n@@ -153,1 +187,1 @@\n-                \/\/ If CPU quotas are not active then find the average system load for\n+                \/\/ If CPU quotas and shares are not active then find the average system load for\n@@ -161,0 +195,4 @@\n+                    \/\/ in case the effectiveCPUSetCpus are not available, attempt to use just cpusets.cpus\n+                    if (cpuSet == null || cpuSet.length <= 0) {\n+                        cpuSet = containerMetrics.getCpuSetCpus();\n+                    }\n@@ -185,1 +223,1 @@\n-            return containerMetrics.getCpuSetCpus().length == getHostConfiguredCpuCount0();\n+            return containerMetrics.getCpuSetCpus().length == getHostOnlineCpuCount0();\n@@ -203,0 +241,3 @@\n+    private native int getHostOnlineCpuCount0();\n+    \/\/ CPU ticks since boot in nanoseconds\n+    private native long getHostTotalCpuTicks0();\n","filename":"src\/jdk.management\/unix\/classes\/com\/sun\/management\/internal\/OperatingSystemImpl.java","additions":54,"deletions":13,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+\/**\n+ * @test\n+ * @bug 8266480\n+ * @summary Check correct re-wiring of control edge when hoisting a memory\n+ *          operation for an implicit null check.\n+ * @run main\/othervm -Xbatch\n+ *                   compiler.c2.TestImplicitNullCheckDominance\n+ *\/\n+public class TestImplicitNullCheckDominance {\n+\n+    double dFld;\n+    int iFld;\n+\n+    static void test1(TestImplicitNullCheckDominance t, double d) {\n+        for (int i = 0; i < 100; i++) {\n+            t.dFld = d % 42;\n+            t.iFld = 43;\n+        }\n+    }\n+\n+    static void test2(TestImplicitNullCheckDominance t) {\n+        for (int i = 0; i < 10; i++) {\n+            for (int j = 0; j < 100; j++) {\n+               t.dFld %= 42;\n+               t.iFld = 43;\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestImplicitNullCheckDominance t = new TestImplicitNullCheckDominance();\n+        for (int i = 0; i < 50_000; ++i) {\n+            test1(t, i);\n+            test2(t);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestImplicitNullCheckDominance.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -67,0 +67,7 @@\n+            \/\/ start with allocating a small block\n+            long firstSegmentSizedAddress = 0;\n+            firstSegmentSizedAddress = allocate(0);\n+            if (firstSegmentSizedAddress == 0) {\n+                throw new RuntimeException(\"Test failed: Failed allocating first segment-sized blob\");\n+            }\n+\n@@ -72,2 +79,4 @@\n-            \/\/ Allocate segment-sized blocks in first code heap.\n-            long lastSegmentSizedAddress = 0; \/\/ Address of the last segment-sized blob allocated\n+            \/\/ Allocate segment-sized blocks in first code heap until it runs out\n+            \/\/ Remember the last one\n+            \/\/ Use the pre-allocated one as backup if the code cache is already completely full.\n+            long lastSegmentSizedAddress = firstSegmentSizedAddress;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/stress\/ReturnBlobToWrongHeapTest.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.exceptions;\n+\n+\/**\n+ * @test\n+ * @bug 8263227\n+ * @summary Tests that users of return values from exception-throwing method\n+ *          calls are not duplicated in the call's exception path. The second\n+ *          run with a variable seed is added for test robustness.\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -Xbatch -XX:+StressGCM -XX:StressSeed=0\n+ *                   -XX:+VerifyRegisterAllocator\n+ *                   -XX:CompileCommand=dontinline,java.lang.Integer::*\n+ *                   compiler.exceptions.TestSpilling\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions\n+ *                   -XX:+UnlockDiagnosticVMOptions\n+ *                   -Xbatch -XX:+StressGCM\n+ *                   -XX:+VerifyRegisterAllocator\n+ *                   -XX:CompileCommand=dontinline,java.lang.Integer::*\n+ *                   compiler.exceptions.TestSpilling\n+ *\/\n+\n+public class TestSpilling {\n+\n+    public static void test() {\n+        int a = Integer.valueOf(42).intValue();\n+        \/\/ After global code motion, the logic below should only be placed in\n+        \/\/ the fall-through path of java.lang.Integer::intValue(). Otherwise,\n+        \/\/ live range splitting might create uses without reaching definitions\n+        \/\/ if 'a' is spilled.\n+        int b = (((a & 0x0000F000)) + 1);\n+        int c = a \/ b + ((a % b > 0) ? 1 : 0);\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10_000; i++) {\n+            test();\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/TestSpilling.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -82,1 +82,1 @@\n-        result.add(new TestCase(true, SingleSubclass.class, \"privateMethod\"));\n+        result.add(new TestCase(InternalError.class, SingleSubclass.class, \"privateMethod\"));\n@@ -95,1 +95,1 @@\n-        result.add(new TestCase(false, SingleSubclass.class, \"staticMethod\"));\n+        result.add(new TestCase(InternalError.class, SingleSubclass.class, \"staticMethod\"));\n@@ -112,4 +112,15 @@\n-        HotSpotResolvedJavaMethod concreteMethod = CompilerToVMHelper\n-                .findUniqueConcreteMethod(resolvedType, testMethod);\n-        Asserts.assertEQ(concreteMethod, tcase.isPositive ? testMethod : null,\n-                \"Unexpected concrete method for \" + tcase.methodName);\n+        if (tcase.exception != null) {\n+            try {\n+                HotSpotResolvedJavaMethod concreteMethod = CompilerToVMHelper\n+                        .findUniqueConcreteMethod(resolvedType, testMethod);\n+\n+                Asserts.fail(\"Exception \" + tcase.exception.getName() + \" not thrown for \" + tcase.methodName);\n+            } catch (Throwable t) {\n+                Asserts.assertEQ(t.getClass(), tcase.exception, \"Wrong exception thrown for \" + tcase.methodName);\n+            }\n+        } else {\n+            HotSpotResolvedJavaMethod concreteMethod = CompilerToVMHelper\n+                    .findUniqueConcreteMethod(resolvedType, testMethod);\n+            Asserts.assertEQ(concreteMethod, tcase.isPositive ? testMethod : null,\n+                    \"Unexpected concrete method for \" + tcase.methodName);\n+        }\n@@ -123,0 +134,1 @@\n+        public final Class<?> exception;\n@@ -125,1 +137,1 @@\n-                        String methodName) {\n+                        String methodName, Class<?> exception) {\n@@ -130,0 +142,6 @@\n+            this.exception = exception;\n+        }\n+\n+        public TestCase(boolean isPositive, Class<?> clazz, Class<?> holder,\n+                        String methodName) {\n+            this(isPositive, clazz, holder, methodName, null);\n@@ -133,1 +151,5 @@\n-            this(isPositive, clazz, clazz, methodName);\n+            this(isPositive, clazz, clazz, methodName, null);\n+        }\n+\n+        public TestCase(Class<?> exception, Class<?> clazz, String methodName) {\n+            this(false, clazz, clazz, methodName, exception);\n@@ -138,2 +160,3 @@\n-            return String.format(\"CASE: receiver=%s, holder=%s, method=%s, isPositive=%s\",\n-                                 receiver.getName(), holder.getName(), methodName, isPositive);\n+            return String.format(\"CASE: receiver=%s, holder=%s, method=%s, isPositive=%s, exception=%s\",\n+                                 receiver.getName(), holder.getName(), methodName, isPositive,\n+                                 exception == null ? \"<none>\" : exception.getName());\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/FindUniqueConcreteMethodTest.java","additions":33,"deletions":10,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -217,1 +217,2 @@\n-        return (Modifier.isFinal(modifiers) || Modifier.isPrivate(modifiers) || Modifier.isStatic(modifiers) || Modifier.isFinal(method.getDeclaringClass().getModifiers())) &&\n+        boolean isConstructor = method instanceof Constructor;\n+        return (Modifier.isFinal(modifiers) || Modifier.isPrivate(modifiers) || Modifier.isStatic(modifiers) || Modifier.isFinal(method.getDeclaringClass().getModifiers()) || isConstructor) &&\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaMethod.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266615\n+ * @summary C2 incorrectly folds subtype checks involving an interface array.\n+ * @run main\/othervm -Xbatch\n+ *                   compiler.types.TestInterfaceArraySubtypeCheck\n+ *\/\n+\n+package compiler.types;\n+\n+public class TestInterfaceArraySubtypeCheck {\n+\n+    static interface MyInterface { }\n+\n+    static class MyClassA { }\n+\n+    static class MyClassB extends MyClassA implements MyInterface { }\n+\n+    static MyInterface[] getMyInterfaceArray() {\n+        return new MyClassB[0];\n+    }\n+\n+    static MyInterface getMyInterface() {\n+        return new MyClassB();\n+    }\n+\n+    static MyClassA[] test1() {\n+        return (MyClassA[])getMyInterfaceArray();\n+    }\n+\n+    static void test2() {\n+        if (!(getMyInterfaceArray() instanceof MyClassA[])) {\n+            throw new RuntimeException(\"test2 failed\");\n+        }\n+    }\n+\n+    static MyClassA test3() {\n+        return (MyClassA)getMyInterface();\n+    }\n+\n+    static void test4() {\n+        if (!(getMyInterface() instanceof MyClassA)) {\n+            throw new RuntimeException(\"test4 failed\");\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 50_000; ++i) {\n+            test1();\n+            test2();\n+            test3();\n+            test4();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestInterfaceArraySubtypeCheck.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @requires vm.gc.Shenandoah\n+ * @bug 8268127\n+ * @summary when heap is too small for regions to align to large page size, should fallback to regular page size\n+ *\n+ * @run main\/othervm -XX:+UseShenandoahGC -Xms17m -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC         -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -Xms17m         TestLargePagesWithSmallHeap\n+ *\n+ * @run main\/othervm -XX:+UseShenandoahGC -Xms17m -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC         -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -Xms17m         TestLargePagesWithSmallHeap\n+ *\/\n+\n+\/*\n+ * @test id=lp\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseLargePages -Xms17m -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseLargePages         -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseLargePages -Xms17m         TestLargePagesWithSmallHeap\n+ *\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseLargePages -Xms17m -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseLargePages         -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseLargePages -Xms17m         TestLargePagesWithSmallHeap\n+ *\/\n+\n+\/*\n+ * @test id=thp\n+ * @requires vm.gc.Shenandoah\n+ * @requires os.family == \"linux\"\n+ *\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseTransparentHugePages -Xms17m -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseTransparentHugePages         -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseTransparentHugePages -Xms17m         TestLargePagesWithSmallHeap\n+ *\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseTransparentHugePages -Xms17m -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseTransparentHugePages         -Xmx17m TestLargePagesWithSmallHeap\n+ * @run main\/othervm -XX:+UseShenandoahGC -XX:+UseTransparentHugePages -Xms17m         TestLargePagesWithSmallHeap\n+ *\/\n+\n+public class TestLargePagesWithSmallHeap {\n+    public static void main(String[] args) {\n+        \/\/ Everything is checked on initialization\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestLargePagesWithSmallHeap.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8251945\n+ * @summary Ensure no race on installing class loader data\n+ *\n+ * @run main\/othervm Test\n+ *\/\n+import jdk.jfr.Event;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.io.OutputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.Executors;\n+\n+public final class Test\n+{\n+    private static final int ITERATIONS = Integer.getInteger(\"iterations\", 10000);\n+    private volatile ClassLoader nextLoader;\n+\n+    public static void main(final String[] args) {\n+        new Test().crash();\n+    }\n+\n+    public void crash() {\n+        final byte[] runnableClass = loadBytecode(\"Test$TestRunnable\");\n+        final byte[] eventClass = loadBytecode(\"Test$TestRunnable$RunnableEvent\");\n+        final int numberOfThreads = Runtime.getRuntime().availableProcessors();\n+        if (numberOfThreads < 1) {\n+            throw new IllegalStateException(\"requies more than one thread\");\n+        }\n+        final ExecutorService threadPool = Executors.newFixedThreadPool(numberOfThreads);\n+        final CyclicBarrier cyclicBarrier = new CyclicBarrier(numberOfThreads, () -> this.nextLoader = new PredefinedClassLoader(runnableClass, eventClass));\n+        for (int i = 0; i < numberOfThreads; ++i) {\n+            threadPool.submit(new LoadingRunnable(cyclicBarrier));\n+        }\n+        threadPool.shutdown();\n+    }\n+\n+    Runnable loadTestRunnable(final ClassLoader classLoader) {\n+        try {\n+            return (Runnable)Class.forName(\"Test$TestRunnable\", true, classLoader).asSubclass(Runnable.class).getConstructor((Class<?>[])new Class[0]).newInstance(new Object[0]);\n+        }\n+        catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(\"could not load runnable\", e);\n+        }\n+    }\n+\n+    private static byte[] loadBytecode(final String className) {\n+        final String resource = toResourceName(className);\n+        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        try {\n+            final InputStream inputStream = Test.class.getClassLoader().getResourceAsStream(resource);\n+            try {\n+                inputStream.transferTo(buffer);\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            }\n+            catch (Throwable t) {\n+                if (inputStream != null) {\n+                    try {\n+                        inputStream.close();\n+                    }\n+                    catch (Throwable exception) {\n+                        t.addSuppressed(exception);\n+                    }\n+                }\n+                throw t;\n+            }\n+        }\n+        catch (IOException e) {\n+            throw new UncheckedIOException(className, e);\n+        }\n+        return buffer.toByteArray();\n+    }\n+\n+    private static String toResourceName(final String className) {\n+        return className.replace('.', '\/') + \".class\";\n+    }\n+\n+    final class LoadingRunnable implements Runnable\n+    {\n+        private final CyclicBarrier barrier;\n+\n+        LoadingRunnable(final CyclicBarrier barrier) {\n+            this.barrier = barrier;\n+        }\n+\n+        @Override\n+        public void run() {\n+            int itr = 0;\n+            try {\n+                while (itr++ < ITERATIONS) {\n+                    this.barrier.await();\n+                    final Runnable runnable = Test.this.loadTestRunnable(Test.this.nextLoader);\n+                    runnable.run();\n+                }\n+            }\n+            catch (InterruptedException | BrokenBarrierException ex) {\n+                final Exception e = ex;\n+            }\n+        }\n+    }\n+\n+    static final class PredefinedClassLoader extends ClassLoader\n+    {\n+        private final byte[] runnableClass;\n+        private final byte[] eventClass;\n+\n+        PredefinedClassLoader(final byte[] runnableClass, final byte[] eventClass) {\n+            super(null);\n+            this.runnableClass = runnableClass;\n+            this.eventClass = eventClass;\n+        }\n+\n+        @Override\n+        protected Class<?> loadClass(final String className, final boolean resolve) throws ClassNotFoundException {\n+            final Class<?> loadedClass = this.findLoadedClass(className);\n+            if (loadedClass != null) {\n+                if (resolve) {\n+                    this.resolveClass(loadedClass);\n+                }\n+                return loadedClass;\n+            }\n+            if (className.equals(\"Test$TestRunnable\")) {\n+                return this.loadClassFromByteArray(className, resolve, this.runnableClass);\n+            }\n+            if (className.equals(\"Test$TestRunnable$RunnableEvent\")) {\n+                return this.loadClassFromByteArray(className, resolve, this.eventClass);\n+            }\n+            return super.loadClass(className, resolve);\n+        }\n+\n+        private Class<?> loadClassFromByteArray(final String className, final boolean resolve, final byte[] byteCode) throws ClassNotFoundException {\n+            Class<?> clazz;\n+            try {\n+                synchronized (getClassLoadingLock(className)) {\n+                    clazz = this.defineClass(className, byteCode, 0, byteCode.length);\n+                }\n+            }\n+            catch (LinkageError e) {\n+                clazz = this.findLoadedClass(className);\n+            }\n+            if (resolve) {\n+                this.resolveClass(clazz);\n+            }\n+            return clazz;\n+        }\n+    }\n+\n+    public static final class TestRunnable implements Runnable\n+    {\n+        @Override\n+        public void run() {\n+            final RunnableEvent event = new RunnableEvent();\n+            event.setRunnableClassName(\"TestRunnable\");\n+            event.begin();\n+            event.end();\n+            event.commit();\n+        }\n+\n+        public static class RunnableEvent extends Event\n+        {\n+            private String runnableClassName;\n+\n+            String getRunnableClassName() {\n+                return this.runnableClassName;\n+            }\n+\n+            void setRunnableClassName(final String operationName) {\n+                this.runnableClassName = operationName;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/8251945\/Test.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -51,0 +51,8 @@\n+    private MethodHandle generateWithSameName() throws ReflectiveOperationException {\n+        byte[] buf = new byte[100];\n+        int size = writeClass(buf, \"MH$$\");\n+        \/\/ use different classloader instances to load the classes with the same name\n+        Class<?> cls = new ResolvedMethodTableHash().defineClass(null, buf, 0, size);\n+        return MethodHandles.publicLookup().findStatic(cls, \"m\", MethodType.methodType(void.class));\n+    }\n+\n@@ -85,1 +93,6 @@\n-            handles.add(generator.generate(\"MH$\" + i));\n+            \/\/ prevents metaspace oom\n+            if (i % 20 != 0) {\n+                handles.add(generator.generate(\"MH$\" + i));\n+            } else {\n+                handles.add(generator.generateWithSameName());\n+            }\n","filename":"test\/hotspot\/jtreg\/runtime\/MemberName\/ResolvedMethodTableHash.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -732,1 +732,0 @@\n-javax\/swing\/JComboBox\/8032878\/bug8032878.java 8196092 windows-all,macosx-all\n@@ -754,1 +753,0 @@\n-javax\/swing\/JComboBox\/8032878\/bug8032878.java 8196439 linux-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,289 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8265761\n+ * @requires (os.family == \"windows\")\n+ * @summary Font with missed font family name is not properly printed on Windows\n+ * @run main\/othervm\/manual PrintFontWithMissedFontFamilyTest\n+ *\/\n+\n+import javax.print.PrintServiceLookup;\n+import javax.swing.*;\n+import java.awt.*;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.geom.AffineTransform;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+public class PrintFontWithMissedFontFamilyTest {\n+\n+    private static final String DESCRIPTION =\n+            \" 1. Setup 'Microsoft Print to PDF' printer on Windows.\\n\" +\n+                    \" 2. Press Print button to print a text with a custom font to PDF.\\n\" +\n+                    \" 3. Choose 'Microsoft Print to PDF' on the print dialog and press OK.\\n\" +\n+                    \" 4. Open the PDF file.\\n\" +\n+                    \"    Three lines with text ABCDEF and the same custom font should be printed.\\n\" +\n+                    \" 5. Compare the text from the pdf with three strings drawn on the right pane.\\n\" +\n+                    \"    The pdf and the pane text should have the same font.\\n\" +\n+                    \" 6. If so, press PASS button, otherwise press FAIL button.\\n\";\n+\n+    private static final CountDownLatch testEndedSignal = new CountDownLatch(1);\n+    private static final int testTimeout = 300000;\n+    private static volatile String testFailureMsg;\n+    private static volatile boolean testPassed;\n+    private static volatile boolean testFinished;\n+    private static final float FONT_SIZE = 32.0f;\n+    private static final String TEXT = \"ABCDEF\";\n+    private static final String FONT_FILE = \"SampleFontMissedFontFamily.ttf\";\n+    private static Font customFont;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        SwingUtilities.invokeLater(() -> createAndShowTestDialog());\n+\n+        try {\n+            if (!testEndedSignal.await(testTimeout, TimeUnit.MILLISECONDS)) {\n+                throw new RuntimeException(String.format(\n+                        \"Test timeout '%d ms' elapsed.\", testTimeout));\n+            }\n+            if (!testPassed) {\n+                String failureMsg = testFailureMsg;\n+                if ((failureMsg != null) && (!failureMsg.trim().isEmpty())) {\n+                    throw new RuntimeException(failureMsg);\n+                } else {\n+                    throw new RuntimeException(\"Test failed.\");\n+                }\n+            }\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(ie);\n+        } finally {\n+            testFinished = true;\n+        }\n+    }\n+\n+    private static void pass() {\n+        testPassed = true;\n+        testEndedSignal.countDown();\n+    }\n+\n+    private static void fail(String failureMsg) {\n+        testFailureMsg = failureMsg;\n+        testPassed = false;\n+        testEndedSignal.countDown();\n+    }\n+\n+    private static String convertMillisToTimeStr(int millis) {\n+        if (millis < 0) {\n+            return \"00:00:00\";\n+        }\n+        int hours = millis \/ 3600000;\n+        int minutes = (millis - hours * 3600000) \/ 60000;\n+        int seconds = (millis - hours * 3600000 - minutes * 60000) \/ 1000;\n+        return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n+    }\n+\n+    private static void createAndShowTestDialog() {\n+\n+        final JDialog dialog = new JDialog();\n+        dialog.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n+        dialog.addWindowListener(new WindowAdapter() {\n+            @Override\n+            public void windowClosing(WindowEvent e) {\n+                dialog.dispose();\n+                fail(\"Main dialog was closed.\");\n+            }\n+        });\n+\n+        final JLabel testTimeoutLabel = new JLabel(String.format(\n+                \"Test timeout: %s\", convertMillisToTimeStr(testTimeout)));\n+        final long startTime = System.currentTimeMillis();\n+        final Timer timer = new Timer(0, null);\n+        timer.setDelay(1000);\n+        timer.addActionListener((e) -> {\n+            int leftTime = testTimeout - (int) (System.currentTimeMillis() - startTime);\n+            if ((leftTime < 0) || testFinished) {\n+                timer.stop();\n+                dialog.dispose();\n+            }\n+            testTimeoutLabel.setText(String.format(\n+                    \"Test timeout: %s\", convertMillisToTimeStr(leftTime)));\n+        });\n+        timer.start();\n+\n+        JTextArea textArea = new JTextArea(DESCRIPTION);\n+        textArea.setEditable(false);\n+\n+        final JButton testButton = new JButton(\"Print\");\n+        final JButton passButton = new JButton(\"PASS\");\n+        final JButton failButton = new JButton(\"FAIL\");\n+\n+        testButton.addActionListener((e) -> {\n+            testButton.setEnabled(false);\n+            new Thread(() -> {\n+                try {\n+                    doTest();\n+\n+                    SwingUtilities.invokeLater(() -> {\n+                        passButton.setEnabled(true);\n+                        failButton.setEnabled(true);\n+                    });\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                    dialog.dispose();\n+                    fail(\"Exception occurred in a thread executing the test.\");\n+                }\n+            }).start();\n+        });\n+        passButton.setEnabled(false);\n+        passButton.addActionListener((e) -> {\n+            dialog.dispose();\n+            pass();\n+        });\n+        failButton.setEnabled(false);\n+        failButton.addActionListener((e) -> {\n+            dialog.dispose();\n+            fail(\"TitledBorder label is cut off\");\n+        });\n+\n+        try {\n+            File dir = new File(System.getProperty(\"test.src\", \".\"));\n+            File customFontFile = new File(dir, FONT_FILE);\n+            customFont = Font.createFont(Font.TRUETYPE_FONT, customFontFile);\n+            customFont = customFont.deriveFont(FONT_SIZE);\n+        } catch(Exception e) {\n+            fail(\"Unable to load the custom font: \" + e);\n+        }\n+\n+        JPanel mainPanel = new JPanel(new BorderLayout());\n+        JPanel textPanel = new JPanel() {\n+            @Override\n+            public void paint(Graphics g) {\n+                super.paint(g);\n+                drawText((Graphics2D) g, customFont, TEXT);\n+            }\n+        };\n+\n+        textPanel.setPreferredSize(new Dimension(300, 300));\n+\n+        JPanel labelPanel = new JPanel(new FlowLayout());\n+        labelPanel.add(testTimeoutLabel);\n+        mainPanel.add(labelPanel, BorderLayout.NORTH);\n+        mainPanel.add(textPanel, BorderLayout.EAST);\n+        mainPanel.add(textArea, BorderLayout.CENTER);\n+        JPanel buttonPanel = new JPanel(new FlowLayout());\n+        buttonPanel.add(testButton);\n+        buttonPanel.add(passButton);\n+        buttonPanel.add(failButton);\n+        mainPanel.add(buttonPanel, BorderLayout.SOUTH);\n+        dialog.add(mainPanel);\n+\n+        dialog.pack();\n+        dialog.setVisible(true);\n+    }\n+\n+    private static void doTest() throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            try {\n+                new TestPrintable();\n+            } catch (PrinterException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+\n+    private static void drawText(Graphics2D g, Font font, String text) {\n+\n+        Font prevFont = g.getFont();\n+        g.setFont(font);\n+        FontRenderContext frc = new FontRenderContext(new AffineTransform(), false, true);\n+\n+        Rectangle clip = g.getClipBounds();\n+        int cx = (int) clip.getCenterX();\n+        int cy = (int) (0.5 * clip.getCenterY());\n+\n+        FontMetrics metrics = g.getFontMetrics();\n+        int w = metrics.stringWidth(text);\n+        int h = metrics.getHeight();\n+\n+        int x = cx - w \/ 2;\n+        int y = cy - h \/ 4;\n+\n+        g.drawString(text, x, y);\n+\n+        GlyphVector gv = font.createGlyphVector(frc, text);\n+        g.drawGlyphVector(gv, x, y + h);\n+\n+        gv = font.deriveFont(1.0f).createGlyphVector(frc, text);\n+        int fontSize = font.getSize();\n+\n+        AffineTransform scale = AffineTransform.getScaleInstance(fontSize, fontSize);\n+        for (int i = 0; i < gv.getNumGlyphs(); i++) {\n+            gv.setGlyphTransform(i, scale);\n+        }\n+\n+        g.drawGlyphVector(gv, x, y + 2 * h);\n+\n+        g.setFont(prevFont);\n+    }\n+\n+    private static class TestPrintable implements Printable {\n+\n+        TestPrintable() throws PrinterException {\n+            PrinterJob job = PrinterJob.getPrinterJob();\n+            job.setPrintService(PrintServiceLookup.lookupDefaultPrintService());\n+            job.setPrintable(this);\n+\n+            if (job.printDialog()) {\n+                job.print();\n+            } else {\n+                throw new RuntimeException(\"Printing was canceled!\");\n+            }\n+        }\n+\n+        void paint(Graphics2D g) {\n+            drawText(g, customFont, TEXT);\n+        }\n+\n+        @Override\n+        public int print(Graphics graphics, PageFormat pageFormat, int index) {\n+            if (index == 0) {\n+                paint((Graphics2D) graphics);\n+                return PAGE_EXISTS;\n+            } else {\n+                return NO_SUCH_PAGE;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/print\/MissedFontFamilyName\/PrintFontWithMissedFontFamilyTest.java","additions":289,"deletions":0,"binary":false,"changes":289,"status":"added"},{"filename":"test\/jdk\/java\/awt\/print\/MissedFontFamilyName\/SampleFontMissedFontFamily.ttf","binary":true,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8267773\n+ * @summary Test\n+ *\n+ * @compile IntegerMinValue.java\n+ * @run main\/othervm -Xverify:all -Xbatch IntegerMinValue\n+ *\n+ * @compile -XDstringConcat=inline IntegerMinValue.java\n+ * @run main\/othervm -Xverify:all -Xbatch IntegerMinValue\n+ *\n+ * @compile -XDstringConcat=indy IntegerMinValue.java\n+ * @run main\/othervm -Xverify:all -Xbatch IntegerMinValue\n+ *\n+ * @compile -XDstringConcat=indyWithConstants IntegerMinValue.java\n+ * @run main\/othervm -Xverify:all -Xbatch IntegerMinValue\n+*\/\n+\n+public class IntegerMinValue {\n+\n+    public void test() {\n+        int i = Integer.MIN_VALUE;\n+        String s = \"\" + i;\n+        if (!\"-2147483648\".equals(s)) {\n+           throw new IllegalStateException(\"Failed: \" + s);\n+        }\n+        System.out.println(s);\n+    }\n+\n+    public static void main(String[] strArr) {\n+        IntegerMinValue t = new IntegerMinValue();\n+        for (int i = 0; i < 100_000; i++ ) {\n+            t.test();\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/String\/concat\/IntegerMinValue.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -36,1 +36,0 @@\n-import java.util.Enumeration;\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetLoopbackMode.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4686717\n+ * @summary Test MulticastSocket.setLoopbackMode with IPv4 addresses\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.NetworkConfiguration\n+ *        jdk.test.lib.Platform\n+ *        SetLoopbackMode\n+ *        SetLoopbackModeIPv4\n+ * @run main\/othervm -Djava.net.preferIPv4Stack=true SetLoopbackModeIPv4\n+ *\/\n+\n+import jdk.test.lib.net.IPSupport;\n+\n+public class SetLoopbackModeIPv4 {\n+    public static void main(String[] args) throws Exception {\n+        IPSupport.throwSkippedExceptionIfNonOperational();\n+        SetLoopbackMode.main(args);\n+    }\n+}\n+\n+\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetLoopbackModeIPv4.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,610 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.net.ServerSocketFactory;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.ServerSocket;\n+import java.net.SocketAddress;\n+import java.net.SocketOption;\n+import java.net.StandardSocketOptions;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.channels.ClosedByInterruptException;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.CharacterCodingException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiFunction;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.String.format;\n+import static java.lang.System.err;\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Arrays.asList;\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * Dummy WebSocket Server, which supports TLS.\n+ * By default the dummy webserver uses a plain TCP connection,\n+ * but it can use a TLS connection if secure() is called before\n+ * open(). It will use the default SSL context.\n+ *\n+ * Performs simpler version of the WebSocket Opening Handshake over HTTP (i.e.\n+ * no proxying, cookies, etc.) Supports sequential connections, one at a time,\n+ * i.e. in order for a client to connect to the server the previous client must\n+ * disconnect first.\n+ *\n+ * Expected client request:\n+ *\n+ *     GET \/chat HTTP\/1.1\n+ *     Host: server.example.com\n+ *     Upgrade: websocket\n+ *     Connection: Upgrade\n+ *     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\n+ *     Origin: http:\/\/example.com\n+ *     Sec-WebSocket-Protocol: chat, superchat\n+ *     Sec-WebSocket-Version: 13\n+ *\n+ * This server response:\n+ *\n+ *     HTTP\/1.1 101 Switching Protocols\n+ *     Upgrade: websocket\n+ *     Connection: Upgrade\n+ *     Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n+ *     Sec-WebSocket-Protocol: chat\n+ *\/\n+public class DummySecureWebSocketServer implements Closeable {\n+\n+    \/**\n+     * Emulates some of the SocketChannel APIs over a Socket\n+     * instance.\n+     *\/\n+    public static class WebSocketChannel implements AutoCloseable {\n+        interface Reader {\n+            int read(ByteBuffer buf) throws IOException;\n+        }\n+        interface Writer {\n+            void write(ByteBuffer buf) throws IOException;\n+        }\n+        interface Config {\n+            <T> void setOption(SocketOption<T> option, T value) throws IOException;\n+        }\n+        interface Closer {\n+            void close() throws IOException;\n+        }\n+        final AutoCloseable channel;\n+        final Reader reader;\n+        final Writer writer;\n+        final Config config;\n+        final Closer closer;\n+        WebSocketChannel(AutoCloseable channel, Reader reader, Writer writer, Config config, Closer closer) {\n+            this.channel = channel;\n+            this.reader = reader;\n+            this.writer = writer;\n+            this.config = config;\n+            this.closer = closer;\n+        }\n+        public void close() throws IOException {\n+            closer.close();\n+        }\n+        public String toString() {\n+            return channel.toString();\n+        }\n+        public int read(ByteBuffer bb) throws IOException {\n+            return reader.read(bb);\n+        }\n+        public void write(ByteBuffer bb) throws IOException {\n+            writer.write(bb);\n+        }\n+        public <T> void setOption(SocketOption<T> option, T value) throws IOException {\n+            config.setOption(option, value);\n+        }\n+        public static WebSocketChannel of(Socket s) {\n+            Reader reader = (bb) -> DummySecureWebSocketServer.read(s.getInputStream(), bb);\n+            Writer writer = (bb) -> DummySecureWebSocketServer.write(s.getOutputStream(), bb);\n+            return new WebSocketChannel(s, reader, writer, s::setOption, s::close);\n+        }\n+    }\n+\n+    \/**\n+     * Emulates some of the ServerSocketChannel APIs over a ServerSocket\n+     * instance.\n+     *\/\n+    public static class WebServerSocketChannel implements AutoCloseable {\n+        interface Accepter {\n+            WebSocketChannel accept() throws IOException;\n+        }\n+        interface Binder {\n+            void bind(SocketAddress address) throws IOException;\n+        }\n+        interface Config {\n+            <T> void setOption(SocketOption<T> option, T value) throws IOException;\n+        }\n+        interface Closer {\n+            void close() throws IOException;\n+        }\n+        interface Addressable {\n+            SocketAddress getLocalAddress() throws IOException;\n+        }\n+        final AutoCloseable server;\n+        final Accepter accepter;\n+        final Binder binder;\n+        final Addressable address;\n+        final Config config;\n+        final Closer closer;\n+        WebServerSocketChannel(AutoCloseable server,\n+                               Accepter accepter,\n+                               Binder binder,\n+                               Addressable address,\n+                               Config config,\n+                               Closer closer) {\n+            this.server = server;\n+            this.accepter = accepter;\n+            this.binder = binder;\n+            this.address = address;\n+            this.config = config;\n+            this.closer = closer;\n+        }\n+        public void close() throws IOException {\n+            closer.close();\n+        }\n+        public String toString() {\n+            return server.toString();\n+        }\n+        public WebSocketChannel accept() throws IOException {\n+            return accepter.accept();\n+        }\n+        public void bind(SocketAddress address) throws IOException {\n+            binder.bind(address);\n+        }\n+        public <T> void setOption(SocketOption<T> option, T value) throws IOException {\n+            config.setOption(option, value);\n+        }\n+        public SocketAddress getLocalAddress()  throws IOException {\n+            return address.getLocalAddress();\n+        }\n+        public static WebServerSocketChannel of(ServerSocket ss) {\n+            Accepter a = () -> WebSocketChannel.of(ss.accept());\n+            return new WebServerSocketChannel(ss, a, ss::bind, ss::getLocalSocketAddress, ss::setOption, ss::close);\n+        }\n+    }\n+\n+    \/\/ Creates a secure WebServerSocketChannel\n+    static WebServerSocketChannel openWSS() throws IOException {\n+       return WebServerSocketChannel.of(SSLServerSocketFactory.getDefault().createServerSocket());\n+    }\n+\n+    \/\/ Creates a plain WebServerSocketChannel\n+    static WebServerSocketChannel openWS() throws IOException {\n+        return WebServerSocketChannel.of(ServerSocketFactory.getDefault().createServerSocket());\n+    }\n+\n+\n+    static int read(InputStream str, ByteBuffer buffer) throws IOException {\n+        int len = Math.min(buffer.remaining(), 1024);\n+        if (len <= 0) return 0;\n+        byte[] bytes = new byte[len];\n+        int res = 0;\n+        if (buffer.hasRemaining()) {\n+            len = Math.min(len, buffer.remaining());\n+            int n = str.read(bytes, 0, len);\n+            if (n > 0) {\n+                buffer.put(bytes, 0, n);\n+                res += n;\n+            } else if (res > 0) {\n+                return res;\n+            } else {\n+                return n;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    static void write(OutputStream str, ByteBuffer buffer) throws IOException {\n+        int len = Math.min(buffer.remaining(), 1024);\n+        if (len <= 0) return;\n+        byte[] bytes = new byte[len];\n+        int res = 0;\n+        int pos = buffer.position();\n+        while (buffer.hasRemaining()) {\n+            len = Math.min(len, buffer.remaining());\n+            buffer.get(bytes, 0, len);\n+            str.write(bytes, 0, len);\n+        }\n+    }\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private final Thread thread;\n+    private volatile WebServerSocketChannel ss;\n+    private volatile InetSocketAddress address;\n+    private volatile boolean secure;\n+    private ByteBuffer read = ByteBuffer.allocate(16384);\n+    private final CountDownLatch readReady = new CountDownLatch(1);\n+    private volatile boolean done;\n+\n+    private static class Credentials {\n+        private final String name;\n+        private final String password;\n+        private Credentials(String name, String password) {\n+            this.name = name;\n+            this.password = password;\n+        }\n+        public String name() { return name; }\n+        public String password() { return password; }\n+    }\n+\n+    public DummySecureWebSocketServer() {\n+        this(defaultMapping(), null, null);\n+    }\n+\n+    public DummySecureWebSocketServer(String username, String password) {\n+        this(defaultMapping(), username, password);\n+    }\n+\n+    public DummySecureWebSocketServer(BiFunction<List<String>,Credentials,List<String>> mapping,\n+                                String username,\n+                                String password) {\n+        requireNonNull(mapping);\n+        Credentials credentials = username != null ?\n+                new Credentials(username, password) : null;\n+\n+        thread = new Thread(() -> {\n+            try {\n+                while (!Thread.currentThread().isInterrupted() && !done) {\n+                    err.println(\"Accepting next connection at: \" + ss);\n+                    WebSocketChannel channel = ss.accept();\n+                    err.println(\"Accepted: \" + channel);\n+                    try {\n+                        channel.setOption(StandardSocketOptions.TCP_NODELAY, true);\n+                        while (!done) {\n+                            StringBuilder request = new StringBuilder();\n+                            if (!readRequest(channel, request)) {\n+                                throw new IOException(\"Bad request:[\" + request + \"]\");\n+                            }\n+                            List<String> strings = asList(request.toString().split(\"\\r\\n\"));\n+                            List<String> response = mapping.apply(strings, credentials);\n+                            writeResponse(channel, response);\n+\n+                            if (response.get(0).startsWith(\"HTTP\/1.1 401\")) {\n+                                err.println(\"Sent 401 Authentication response \" + channel);\n+                                continue;\n+                            } else {\n+                                serve(channel);\n+                                break;\n+                            }\n+                        }\n+                    } catch (IOException e) {\n+                        if (!done) {\n+                            err.println(\"Error in connection: \" + channel + \", \" + e);\n+                        }\n+                    } finally {\n+                        err.println(\"Closed: \" + channel);\n+                        close(channel);\n+                        readReady.countDown();\n+                    }\n+                }\n+            } catch (ClosedByInterruptException ignored) {\n+            } catch (Throwable e) {\n+                if (!done) {\n+                    e.printStackTrace(err);\n+                }\n+            } finally {\n+                done = true;\n+                close(ss);\n+                err.println(\"Stopped at: \" + getURI());\n+            }\n+        });\n+        thread.setName(\"DummySecureWebSocketServer\");\n+        thread.setDaemon(false);\n+    }\n+\n+    \/\/ must be called before open()\n+    public DummySecureWebSocketServer secure() {\n+        secure = true;\n+        return this;\n+    }\n+\n+    protected void read(WebSocketChannel ch) throws IOException {\n+        \/\/ Read until the thread is interrupted or an error occurred\n+        \/\/ or the input is shutdown\n+        ByteBuffer b = ByteBuffer.allocate(65536);\n+        while (ch.read(b) != -1) {\n+            b.flip();\n+            if (read.remaining() < b.remaining()) {\n+                int required = read.capacity() - read.remaining() + b.remaining();\n+                int log2required = 32 - Integer.numberOfLeadingZeros(required - 1);\n+                ByteBuffer newBuffer = ByteBuffer.allocate(1 << log2required);\n+                newBuffer.put(read.flip());\n+                read = newBuffer;\n+            }\n+            read.put(b);\n+            b.clear();\n+        }\n+    }\n+\n+    protected void write(WebSocketChannel ch) throws IOException { }\n+\n+    protected final void serve(WebSocketChannel channel)\n+            throws InterruptedException\n+    {\n+        Thread reader = new Thread(() -> {\n+            try {\n+                read(channel);\n+            } catch (IOException ignored) { }\n+        });\n+        Thread writer = new Thread(() -> {\n+            try {\n+                write(channel);\n+            } catch (IOException ignored) { }\n+        });\n+        reader.start();\n+        writer.start();\n+        try {\n+            while (!done) {\n+                try {\n+                    reader.join(500);\n+                } catch (InterruptedException x) {\n+                    if (done) {\n+                        close(channel);\n+                        break;\n+                    }\n+                }\n+            }\n+        } finally {\n+            reader.interrupt();\n+            try {\n+                while (!done) {\n+                    try {\n+                        writer.join(500);\n+                    } catch (InterruptedException x) {\n+                        if (done) break;\n+                    }\n+                }\n+            } finally {\n+                writer.interrupt();\n+            }\n+        }\n+    }\n+\n+    public ByteBuffer read() throws InterruptedException {\n+        readReady.await();\n+        return read.duplicate().asReadOnlyBuffer().flip();\n+    }\n+\n+    public void open() throws IOException {\n+        err.println(\"Starting\");\n+        if (!started.compareAndSet(false, true)) {\n+            throw new IllegalStateException(\"Already started\");\n+        }\n+        ss = secure ? openWSS() : openWS();\n+        try {\n+            ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            address = (InetSocketAddress) ss.getLocalAddress();\n+            thread.start();\n+        } catch (IOException e) {\n+            done = true;\n+            close(ss);\n+            throw e;\n+        }\n+        err.println(\"Started at: \" + getURI());\n+    }\n+\n+    @Override\n+    public void close() {\n+        err.println(\"Stopping: \" + getURI());\n+        done = true;\n+        thread.interrupt();\n+        close(ss);\n+    }\n+\n+    URI getURI() {\n+        if (!started.get()) {\n+            throw new IllegalStateException(\"Not yet started\");\n+        }\n+        if (!secure) {\n+            return URI.create(\"ws:\/\/localhost:\" + address.getPort());\n+        } else {\n+            return URI.create(\"wss:\/\/localhost:\" + address.getPort());\n+        }\n+    }\n+\n+    private boolean readRequest(WebSocketChannel channel, StringBuilder request)\n+            throws IOException\n+    {\n+        ByteBuffer buffer = ByteBuffer.allocate(512);\n+        while (channel.read(buffer) != -1) {\n+            \/\/ read the complete HTTP request headers, there should be no body\n+            CharBuffer decoded;\n+            buffer.flip();\n+            try {\n+                decoded = ISO_8859_1.newDecoder().decode(buffer);\n+            } catch (CharacterCodingException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            request.append(decoded);\n+            if (Pattern.compile(\"\\r\\n\\r\\n\").matcher(request).find())\n+                return true;\n+            buffer.clear();\n+        }\n+        return false;\n+    }\n+\n+    private void writeResponse(WebSocketChannel channel, List<String> response)\n+            throws IOException\n+    {\n+        String s = response.stream().collect(Collectors.joining(\"\\r\\n\"))\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuffer encoded;\n+        try {\n+            encoded = ISO_8859_1.newEncoder().encode(CharBuffer.wrap(s));\n+        } catch (CharacterCodingException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        while (encoded.hasRemaining()) {\n+            channel.write(encoded);\n+        }\n+    }\n+\n+    private static BiFunction<List<String>,Credentials,List<String>> defaultMapping() {\n+        return (request, credentials) -> {\n+            List<String> response = new LinkedList<>();\n+            Iterator<String> iterator = request.iterator();\n+            if (!iterator.hasNext()) {\n+                throw new IllegalStateException(\"The request is empty\");\n+            }\n+            String statusLine = iterator.next();\n+            if (!(statusLine.startsWith(\"GET \/\") && statusLine.endsWith(\" HTTP\/1.1\"))) {\n+                throw new IllegalStateException\n+                        (\"Unexpected status line: \" + request.get(0));\n+            }\n+            response.add(\"HTTP\/1.1 101 Switching Protocols\");\n+            Map<String, List<String>> requestHeaders = new HashMap<>();\n+            while (iterator.hasNext()) {\n+                String header = iterator.next();\n+                String[] split = header.split(\": \");\n+                if (split.length != 2) {\n+                    throw new IllegalStateException\n+                            (\"Unexpected header: \" + header\n+                                     + \", split=\" + Arrays.toString(split));\n+                }\n+                requestHeaders.computeIfAbsent(split[0], k -> new ArrayList<>()).add(split[1]);\n+\n+            }\n+            if (requestHeaders.containsKey(\"Sec-WebSocket-Protocol\")) {\n+                throw new IllegalStateException(\"Subprotocols are not expected\");\n+            }\n+            if (requestHeaders.containsKey(\"Sec-WebSocket-Extensions\")) {\n+                throw new IllegalStateException(\"Extensions are not expected\");\n+            }\n+            expectHeader(requestHeaders, \"Connection\", \"Upgrade\");\n+            response.add(\"Connection: Upgrade\");\n+            expectHeader(requestHeaders, \"Upgrade\", \"websocket\");\n+            response.add(\"Upgrade: websocket\");\n+            expectHeader(requestHeaders, \"Sec-WebSocket-Version\", \"13\");\n+            List<String> key = requestHeaders.get(\"Sec-WebSocket-Key\");\n+            if (key == null || key.isEmpty()) {\n+                throw new IllegalStateException(\"Sec-WebSocket-Key is missing\");\n+            }\n+            if (key.size() != 1) {\n+                throw new IllegalStateException(\"Sec-WebSocket-Key has too many values : \" + key);\n+            }\n+            MessageDigest sha1 = null;\n+            try {\n+                sha1 = MessageDigest.getInstance(\"SHA-1\");\n+            } catch (NoSuchAlgorithmException e) {\n+                throw new InternalError(e);\n+            }\n+            String x = key.get(0) + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n+            sha1.update(x.getBytes(ISO_8859_1));\n+            String v = Base64.getEncoder().encodeToString(sha1.digest());\n+            response.add(\"Sec-WebSocket-Accept: \" + v);\n+\n+            \/\/ check authorization credentials, if required by the server\n+            if (credentials != null && !authorized(credentials, requestHeaders)) {\n+                response.clear();\n+                response.add(\"HTTP\/1.1 401 Unauthorized\");\n+                response.add(\"Content-Length: 0\");\n+                response.add(\"WWW-Authenticate: Basic realm=\\\"dummy server realm\\\"\");\n+            }\n+\n+            return response;\n+        };\n+    }\n+\n+    \/\/ Checks credentials in the request against those allowable by the server.\n+    private static boolean authorized(Credentials credentials,\n+                                      Map<String,List<String>> requestHeaders) {\n+        List<String> authorization = requestHeaders.get(\"Authorization\");\n+        if (authorization == null)\n+            return false;\n+\n+        if (authorization.size() != 1) {\n+            throw new IllegalStateException(\"Authorization unexpected count:\" + authorization);\n+        }\n+        String header = authorization.get(0);\n+        if (!header.startsWith(\"Basic \"))\n+            throw new IllegalStateException(\"Authorization not Basic: \" + header);\n+\n+        header = header.substring(\"Basic \".length());\n+        String values = new String(Base64.getDecoder().decode(header), UTF_8);\n+        int sep = values.indexOf(':');\n+        if (sep < 1) {\n+            throw new IllegalStateException(\"Authorization not colon: \" +  values);\n+        }\n+        String name = values.substring(0, sep);\n+        String password = values.substring(sep + 1);\n+\n+        if (name.equals(credentials.name()) && password.equals(credentials.password()))\n+            return true;\n+\n+        return false;\n+    }\n+\n+    protected static String expectHeader(Map<String, List<String>> headers,\n+                                         String name,\n+                                         String value) {\n+        List<String> v = headers.get(name);\n+        if (v == null) {\n+            throw new IllegalStateException(\n+                    format(\"Expected '%s' header, not present in %s\",\n+                           name, headers));\n+        }\n+        if (!v.contains(value)) {\n+            throw new IllegalStateException(\n+                    format(\"Expected '%s: %s', actual: '%s: %s'\",\n+                           name, value, name, v)\n+            );\n+        }\n+        return value;\n+    }\n+\n+    private static void close(AutoCloseable... acs) {\n+        for (AutoCloseable ac : acs) {\n+            try {\n+                ac.close();\n+            } catch (Exception ignored) { }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/DummySecureWebSocketServer.java","additions":610,"deletions":0,"binary":false,"changes":610,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.testng.Assert.assertThrows;\n+\n+\/**\n+ * Helper class to create instances of DummySecureWebSocketServer which\n+ * can support both plain and secure connections.\n+ * The caller should invoke DummySecureWebSocketServer::secure before\n+ * DummySecureWebSocketServer::open in order to enable secure connection.\n+ * When secure, the DummySecureWebSocketServer currently only support using the\n+ * default SSLEngine through the default SSLSocketServerFacrtory.\n+ *\/\n+public class SecureSupport {\n+\n+    private SecureSupport() { }\n+\n+    public static DummySecureWebSocketServer serverWithCannedData(int... data) {\n+        return serverWithCannedDataAndAuthentication(null, null, data);\n+    }\n+\n+    public static DummySecureWebSocketServer serverWithCannedDataAndAuthentication(\n+            String username,\n+            String password,\n+            int... data)\n+    {\n+        byte[] copy = new byte[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            copy[i] = (byte) data[i];\n+        }\n+        return serverWithCannedDataAndAuthentication(username, password, copy);\n+    }\n+\n+    public static DummySecureWebSocketServer serverWithCannedData(byte... data) {\n+       return serverWithCannedDataAndAuthentication(null, null, data);\n+    }\n+\n+    public static DummySecureWebSocketServer serverWithCannedDataAndAuthentication(\n+            String username,\n+            String password,\n+            byte... data)\n+    {\n+        byte[] copy = Arrays.copyOf(data, data.length);\n+        return new DummySecureWebSocketServer(username, password) {\n+            @Override\n+            protected void write(WebSocketChannel ch) throws IOException {\n+                int off = 0; int n = 1; \/\/ 1 byte at a time\n+                while (off + n < copy.length + n) {\n+                    int len = Math.min(copy.length - off, n);\n+                    ByteBuffer bytes = ByteBuffer.wrap(copy, off, len);\n+                    off += len;\n+                    ch.write(bytes);\n+                }\n+                super.write(ch);\n+            }\n+        };\n+    }\n+\n+    \/*\n+     * This server does not read from the wire, allowing its client to fill up\n+     * their send buffer. Used to test scenarios with outstanding send\n+     * operations.\n+     *\/\n+    public static DummySecureWebSocketServer notReadingServer() {\n+        return new DummySecureWebSocketServer() {\n+            @Override\n+            protected void read(WebSocketChannel ch) throws IOException {\n+                try {\n+                    Thread.sleep(Long.MAX_VALUE);\n+                } catch (InterruptedException e) {\n+                    throw new IOException(e);\n+                }\n+            }\n+        };\n+    }\n+\n+    public static DummySecureWebSocketServer writingServer(int... data) {\n+        byte[] copy = new byte[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            copy[i] = (byte) data[i];\n+        }\n+        return new DummySecureWebSocketServer() {\n+\n+            @Override\n+            protected void read(WebSocketChannel ch) throws IOException {\n+                try {\n+                    Thread.sleep(Long.MAX_VALUE);\n+                } catch (InterruptedException e) {\n+                    throw new IOException(e);\n+                }\n+            }\n+\n+            @Override\n+            protected void write(WebSocketChannel ch) throws IOException {\n+                int off = 0; int n = 1; \/\/ 1 byte at a time\n+                while (off + n < copy.length + n) {\n+                    int len = Math.min(copy.length - off, n);\n+                    ByteBuffer bytes = ByteBuffer.wrap(copy, off, len);\n+                    off += len;\n+                    ch.write(bytes);\n+                }\n+                super.write(ch);\n+            }\n+        };\n+\n+    }\n+\n+    public static String stringWith2NBytes(int n) {\n+        \/\/ -- Russian Alphabet (33 characters, 2 bytes per char) --\n+        char[] abc = {\n+                0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0401, 0x0416,\n+                0x0417, 0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E,\n+                0x041F, 0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426,\n+                0x0427, 0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E,\n+                0x042F,\n+        };\n+        \/\/ repeat cyclically\n+        StringBuilder sb = new StringBuilder(n);\n+        for (int i = 0, j = 0; i < n; i++, j = (j + 1) % abc.length) {\n+            sb.append(abc[j]);\n+        }\n+        String s = sb.toString();\n+        assert s.length() == n && s.getBytes(StandardCharsets.UTF_8).length == 2 * n;\n+        return s;\n+    }\n+\n+    public static String malformedString() {\n+        return new String(new char[]{0xDC00, 0xD800});\n+    }\n+\n+    public static String incompleteString() {\n+        return new String(new char[]{0xD800});\n+    }\n+\n+    public static String stringWithNBytes(int n) {\n+        char[] chars = new char[n];\n+        Arrays.fill(chars, 'A');\n+        return new String(chars);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/SecureSupport.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8217429\n+ * @bug 8217429 8236859\n@@ -28,1 +28,3 @@\n- * @compile DummyWebSocketServer.java ..\/ProxyServer.java\n+ * @library \/lib\/testlibrary\n+ * @compile SecureSupport.java DummySecureWebSocketServer.java ..\/ProxyServer.java\n+ * @build jdk.testlibrary.SimpleSSLContext WebSocketProxyTest\n@@ -30,0 +32,3 @@\n+ *         -Djdk.internal.httpclient.debug=true\n+ *         -Djdk.internal.httpclient.websocket.debug=true\n+ *         -Djdk.httpclient.HttpClient.log=errors,requests,headers\n@@ -55,0 +60,2 @@\n+\n+import jdk.testlibrary.SimpleSSLContext;\n@@ -58,0 +65,3 @@\n+\n+import javax.net.ssl.SSLContext;\n+\n@@ -69,0 +79,8 @@\n+    static {\n+        try {\n+            SSLContext.setDefault(new SimpleSSLContext().get());\n+        } catch (IOException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n@@ -76,1 +94,1 @@\n-    static final Function<int[],DummyWebSocketServer> SERVER_WITH_CANNED_DATA =\n+    static final Function<int[],DummySecureWebSocketServer> SERVER_WITH_CANNED_DATA =\n@@ -78,2 +96,2 @@\n-            @Override public DummyWebSocketServer apply(int[] data) {\n-                return Support.serverWithCannedData(data); }\n+            @Override public DummySecureWebSocketServer apply(int[] data) {\n+                return SecureSupport.serverWithCannedData(data); }\n@@ -83,1 +101,8 @@\n-    static final Function<int[],DummyWebSocketServer> AUTH_SERVER_WITH_CANNED_DATA =\n+    static final Function<int[],DummySecureWebSocketServer> SSL_SERVER_WITH_CANNED_DATA =\n+            new Function<>() {\n+                @Override public DummySecureWebSocketServer apply(int[] data) {\n+                    return SecureSupport.serverWithCannedData(data).secure(); }\n+                @Override public String toString() { return \"SSL_SERVER_WITH_CANNED_DATA\"; }\n+            };\n+\n+    static final Function<int[],DummySecureWebSocketServer> AUTH_SERVER_WITH_CANNED_DATA =\n@@ -85,2 +110,2 @@\n-            @Override public DummyWebSocketServer apply(int[] data) {\n-                return Support.serverWithCannedDataAndAuthentication(USERNAME, PASSWORD, data); }\n+            @Override public DummySecureWebSocketServer apply(int[] data) {\n+                return SecureSupport.serverWithCannedDataAndAuthentication(USERNAME, PASSWORD, data); }\n@@ -90,0 +115,7 @@\n+    static final Function<int[],DummySecureWebSocketServer> AUTH_SSL_SVR_WITH_CANNED_DATA =\n+            new Function<>() {\n+                @Override public DummySecureWebSocketServer apply(int[] data) {\n+                    return SecureSupport.serverWithCannedDataAndAuthentication(USERNAME, PASSWORD, data).secure(); }\n+                @Override public String toString() { return \"AUTH_SSL_SVR_WITH_CANNED_DATA\"; }\n+            };\n+\n@@ -108,3 +140,8 @@\n-            { SERVER_WITH_CANNED_DATA,      TUNNELING_PROXY_SERVER      },\n-            { SERVER_WITH_CANNED_DATA,      AUTH_TUNNELING_PROXY_SERVER },\n-            { AUTH_SERVER_WITH_CANNED_DATA, TUNNELING_PROXY_SERVER      },\n+            { SERVER_WITH_CANNED_DATA,       TUNNELING_PROXY_SERVER      },\n+            { SERVER_WITH_CANNED_DATA,       AUTH_TUNNELING_PROXY_SERVER },\n+            { SSL_SERVER_WITH_CANNED_DATA,   TUNNELING_PROXY_SERVER      },\n+            { SSL_SERVER_WITH_CANNED_DATA,   AUTH_TUNNELING_PROXY_SERVER },\n+            { AUTH_SERVER_WITH_CANNED_DATA,  TUNNELING_PROXY_SERVER      },\n+            { AUTH_SSL_SVR_WITH_CANNED_DATA, TUNNELING_PROXY_SERVER      },\n+            { AUTH_SERVER_WITH_CANNED_DATA,  AUTH_TUNNELING_PROXY_SERVER },\n+            { AUTH_SSL_SVR_WITH_CANNED_DATA, AUTH_TUNNELING_PROXY_SERVER },\n@@ -116,1 +153,1 @@\n-            (Function<int[],DummyWebSocketServer> serverSupplier,\n+            (Function<int[],DummySecureWebSocketServer> serverSupplier,\n@@ -137,0 +174,2 @@\n+            System.out.println(\"Server: \" + server.getURI());\n+            System.out.println(\"Proxy: \" + proxyAddress);\n@@ -212,1 +251,1 @@\n-             var server = new DummyWebSocketServer()){\n+             var server = new DummySecureWebSocketServer()){\n@@ -233,1 +272,24 @@\n-             var server = new DummyWebSocketServer()) {\n+             var server = new DummySecureWebSocketServer()) {\n+            server.open();\n+            InetSocketAddress proxyAddress = new InetSocketAddress(\n+                    InetAddress.getLoopbackAddress(), proxyServer.getPort());\n+\n+            String hv = \"Basic \" + Base64.getEncoder().encodeToString(\n+                    (USERNAME + \":\" + PASSWORD).getBytes(UTF_8));\n+\n+            var webSocket = newBuilder()\n+                    .proxy(ProxySelector.of(proxyAddress)).build()\n+                    .newWebSocketBuilder()\n+                    .header(\"Proxy-Authorization\", hv)\n+                    .buildAsync(server.getURI(), new WebSocket.Listener() { })\n+                    .join();\n+        }\n+    }\n+\n+    \/*\n+     * Ensures authentication succeeds when an `Authorization` header is explicitly set.\n+     *\/\n+    @Test\n+    public void explicitAuthenticate2() throws IOException  {\n+        try (var proxyServer = AUTH_TUNNELING_PROXY_SERVER.get();\n+             var server = new DummySecureWebSocketServer(USERNAME, PASSWORD).secure()) {\n@@ -245,0 +307,1 @@\n+                    .header(\"Authorization\", hv)\n@@ -256,1 +319,1 @@\n-             var server = new DummyWebSocketServer(USERNAME, PASSWORD)) {\n+             var server = new DummySecureWebSocketServer(USERNAME, PASSWORD)) {\n@@ -284,1 +347,1 @@\n-             var server = new DummyWebSocketServer(USERNAME, PASSWORD)) {\n+             var server = new DummySecureWebSocketServer(USERNAME, PASSWORD)) {\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/WebSocketProxyTest.java","additions":80,"deletions":17,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-    private static long blockSize;\n@@ -53,1 +52,1 @@\n-    private static int testWrite(Path p) throws Exception {\n+    private static int testWrite(Path p, long blockSize) throws Exception {\n@@ -71,1 +70,1 @@\n-    private static int testRead(Path p) throws Exception {\n+    private static int testRead(Path p, long blockSize) throws Exception {\n@@ -112,1 +111,1 @@\n-        blockSize = Files.getFileStore(p).getBlockSize();\n+        long blockSize = Files.getFileStore(p).getBlockSize();\n@@ -122,1 +121,1 @@\n-            int size = testWrite(p);\n+            int size = testWrite(p, blockSize);\n@@ -127,1 +126,1 @@\n-            size = testRead(p);\n+            size = testRead(p, blockSize);\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/directio\/DirectIOTest.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main ParentLoggersTest\n+ * @run main\/othervm ParentLoggersTest\n","filename":"test\/jdk\/java\/util\/logging\/ParentLoggersTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,0 +121,2 @@\n+    TLS_CHACHA20_POLY1305_SHA256(\n+            0x1303, null, Protocol.TLSV1_3, Protocol.TLSV1_3),\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/CipherSuite.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,1 +185,2 @@\n-            \"TLS_AES_128_GCM_SHA256\"\n+            \"TLS_AES_128_GCM_SHA256\",\n+            \"TLS_CHACHA20_POLY1305_SHA256\"\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/SSLEngineTestCase.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+        \"TLS_CHACHA20_POLY1305_SHA256\",\n@@ -45,0 +46,1 @@\n+        \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\",\n@@ -46,0 +48,1 @@\n+        \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n@@ -50,0 +53,1 @@\n+        \"TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n@@ -121,0 +125,1 @@\n+        \"TLS_CHACHA20_POLY1305_SHA256\",\n@@ -123,0 +128,1 @@\n+        \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\",\n@@ -124,0 +130,1 @@\n+        \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n@@ -128,0 +135,1 @@\n+        \"TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n","filename":"test\/jdk\/javax\/net\/ssl\/sanity\/ciphersuites\/CheckCipherSuites.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+        \"TLS_CHACHA20_POLY1305_SHA256\",\n@@ -48,0 +49,1 @@\n+        \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\",\n@@ -49,0 +51,1 @@\n+        \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n@@ -53,0 +56,1 @@\n+        \"TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n","filename":"test\/jdk\/javax\/net\/ssl\/sanity\/ciphersuites\/CipherSuitesInOrder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n- * @library ..\/..\/regtesthelpers\n- * @build Util\n- * @author Alexey Ivanov\n@@ -89,0 +86,1 @@\n+        frame.setLocationRelativeTo(null);\n@@ -96,0 +94,2 @@\n+            robot.waitForIdle();\n+            robot.delay(1000);\n@@ -100,1 +100,1 @@\n-                frame.dispose();\n+                SwingUtilities.invokeAndWait(() -> frame.dispose());\n@@ -108,1 +108,2 @@\n-        Util.hitKeys(robot, KeyEvent.VK_TAB);\n+        robot.keyPress(KeyEvent.VK_TAB);\n+        robot.keyRelease(KeyEvent.VK_TAB);\n@@ -110,4 +111,11 @@\n-        Util.hitKeys(robot, KeyEvent.VK_1);\n-        Util.hitKeys(robot, KeyEvent.VK_2);\n-        Util.hitKeys(robot, KeyEvent.VK_3);\n-        Util.hitKeys(robot, KeyEvent.VK_ENTER);\n+        robot.keyPress(KeyEvent.VK_1);\n+        robot.keyRelease(KeyEvent.VK_1);\n+        robot.waitForIdle();\n+        robot.keyPress(KeyEvent.VK_2);\n+        robot.keyRelease(KeyEvent.VK_2);\n+        robot.waitForIdle();\n+        robot.keyPress(KeyEvent.VK_3);\n+        robot.keyRelease(KeyEvent.VK_3);\n+        robot.waitForIdle();\n+        robot.keyPress(KeyEvent.VK_ENTER);\n+        robot.keyRelease(KeyEvent.VK_ENTER);\n","filename":"test\/jdk\/javax\/swing\/JComboBox\/8032878\/bug8032878.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        if ((out.getExitValue() == 1 && out.getOutput().contains(\"Exception: java.lang.OutOfMemoryError\"))) {\n+        if ((out.getExitValue() == 1 && out.getOutput().contains(\"java.lang.OutOfMemoryError\"))) {\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/detailed\/ExecuteOOMApp.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import sun.hotspot.WhiteBox;\n@@ -42,1 +43,4 @@\n- * @run main jdk.jfr.startupargs.TestBadOptionValues\n+ * @build ClassFileInstaller\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI jdk.jfr.startupargs.TestBadOptionValues\n@@ -124,0 +128,25 @@\n+        \/\/ globalbuffersize exceeds limit\n+        test(FLIGHT_RECORDER_OPTIONS, \"This value is higher than the maximum size limit\",\n+            \"globalbuffersize=4G\");\n+\n+        \/\/ threadbuffersize exceeds limit\n+        test(FLIGHT_RECORDER_OPTIONS, \"This value is higher than the maximum size limit\",\n+            \"threadbuffersize=4G\");\n+\n+        \/\/ computed numglobalbuffers smaller than MIN_BUFFER_COUNT\n+        test(FLIGHT_RECORDER_OPTIONS, \"Decrease globalbuffersize\/threadbuffersize or increase memorysize\",\n+            \"memorysize=1m,globalbuffersize=1m\");\n+\n+        \/\/ memorysize smaller than threadbuffersize\n+        test(FLIGHT_RECORDER_OPTIONS, \"The value for option \\\"threadbuffersize\\\" should not be larger than the value specified for option \\\"memorysize\\\"\",\n+            \"memorysize=1m,threadbuffersize=2m\");\n+\n+        \/\/ computed globalbuffersize smaller than threadbuffersize\n+        \/\/ test is on when vm page isn't larger than 4K, avoiding both buffer sizes align to vm page size\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        long smallPageSize = wb.getVMPageSize();\n+        if (smallPageSize <= 4096) {\n+            test(FLIGHT_RECORDER_OPTIONS, \"Decrease globalbuffersize or increase memorysize or adjust global\/threadbuffersize\",\n+                \"memorysize=1m,numglobalbuffers=256\");\n+        }\n+\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestBadOptionValues.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -645,0 +645,5 @@\n+\n+        \/\/ threadbuffersize exceeds default memorysize\n+        tc = new TestCase(\"ThreadBufferSizeExceedMemorySize\", false);\n+        tc.setThreadBufferSizeTestParam(30, 'm');\n+        testCases.add(tc);\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestMemoryOptions.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8153716 8143955 8151754 8150382 8153920 8156910 8131024 8160089 8153897 8167128 8154513 8170015 8170368 8172102 8172103  8165405 8173073 8173848 8174041 8173916 8174028 8174262 8174797 8177079 8180508 8177466 8172154 8192979 8191842 8198573 8198801 8239536\n+ * @bug 8153716 8143955 8151754 8150382 8153920 8156910 8131024 8160089 8153897 8167128 8154513 8170015 8170368 8172102 8172103  8165405 8173073 8173848 8174041 8173916 8174028 8174262 8174797 8177079 8180508 8177466 8172154 8192979 8191842 8198573 8198801 8239536 8210959\n@@ -35,1 +35,1 @@\n-import java.util.Arrays;\n+\n@@ -37,0 +37,1 @@\n+import java.util.Arrays;\n@@ -115,0 +116,14 @@\n+    @Test\n+    public void testThrowWithPercent() {\n+        test(\n+                (a) -> assertCommandCheckOutput(a,\n+                        \"URI u = new URI(\\\"http\\\", null, \\\"h\\\", -1, \\\"a\\\" + (char)0x04, null, null);\", (s) ->\n+                                assertTrue(s.contains(\"URISyntaxException\") && !s.contains(\"JShellTool\"),\n+                                        \"Output: '\" + s + \"'\")),\n+                (a) -> assertCommandCheckOutput(a,\n+                        \"throw new Exception(\\\"%z\\\")\", (s) ->\n+                                assertTrue(s.contains(\"java.lang.Exception\") && !s.contains(\"UnknownFormatConversionException\"),\n+                                        \"Output: '\" + s + \"'\"))\n+        );\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/ToolSimpleTest.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8210495\n+ * @summary compiler crashes because of illegal signature in otherwise legal code\n+ * @compile T8210495.java\n+ *\/\n+\n+import java.awt.*;\n+import java.awt.event.ActionListener;\n+import java.util.List;\n+\n+class T8210495 {\n+    interface IFilter {\n+        Component getComponent();\n+    }\n+\n+    static class Filter implements IFilter {\n+        @Override\n+        public Component getComponent() {\n+            return null;\n+        }\n+\n+    }\n+\n+    public Component buildFilter(List<? extends Filter> l, Dialog dialog) {\n+        Panel c = new Panel();\n+        l.stream()\n+                .map(f -> {\n+                    Button btn = (Button)f.getComponent();\n+                    btn.addActionListener((java.io.Serializable & ActionListener)evt -> {\n+                        applyFilter(f);\n+                        dialog.setVisible(false);\n+                    });\n+                    return btn;\n+                })\n+                .forEach(c::add);\n+        return c;\n+    }\n+\n+    private void applyFilter(IFilter f) { }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/8210495\/T8210495.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8193214\n+ * @summary Verify annotations without processors warning not given for base module annotations.\n+ * @library \/tools\/javac\/lib\n+ * @modules java.compiler\n+ * @build JavacTestingAbstractProcessor TestAnnotationsWithoutProcessors\n+ * @compile\/ref=empty.out -XDrawDiagnostics -Xlint:processing -processor TestAnnotationsWithoutProcessors --release 8 TestAnnotationsWithoutProcessors.java\n+ * @compile\/ref=empty.out -XDrawDiagnostics -Xlint:processing -processor TestAnnotationsWithoutProcessors TestAnnotationsWithoutProcessors.java\n+ *\/\n+\n+import java.lang.annotation.*;\n+import java.util.*;\n+import javax.annotation.processing.*;\n+import javax.lang.model.element.*;\n+\n+\/**\n+ * Use various annotations in java.base.\n+ *\/\n+@SuppressWarnings(\"unchecked\")\n+public class TestAnnotationsWithoutProcessors extends JavacTestingAbstractProcessor {\n+    @Override\n+    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+        return false;\n+    }\n+\n+    @SafeVarargs\n+    @Deprecated\n+    public static void main(String... args) {\n+        return;\n+    }\n+\n+    @FunctionalInterface\n+    interface OneMethod {\n+        String method();\n+    }\n+\n+    @Native\n+    public double TAU = 2.0 * Math.PI;\n+\n+    @Documented\n+    @Inherited\n+    @Repeatable(TestAnnotationTypes.class)\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.TYPE)\n+    @interface TestAnnotationType {\n+    }\n+\n+    @Documented\n+    @Inherited\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @Target(ElementType.TYPE)\n+    @interface TestAnnotationTypes {\n+        TestAnnotationType[] value();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/warnings\/LintProcessing\/TestAnnotationsWithoutProcessors.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"","filename":"test\/langtools\/tools\/javac\/processing\/warnings\/LintProcessing\/empty.out","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/langtools\/test\/TEST.ROOT","status":"copied"},{"patch":"@@ -34,0 +34,1 @@\n+import java.io.IOException;\n@@ -36,0 +37,3 @@\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n@@ -37,0 +41,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -45,0 +51,1 @@\n+import static org.testng.Assert.assertFalse;\n@@ -118,0 +125,59 @@\n+    private static final List<String> REMOVED_APIS = List.of(\n+            \"com.sun.image.codec.jpeg.JPEGCodec\",\n+            \"sun.misc.Service\",\n+            \"sun.misc.SoftCache\",\n+            \"sun.reflect.Reflection\"\n+    );\n+    private static final String REMOVED_INTERNAL_API = \"JDK removed internal API\";\n+\n+\n+    @Test\n+    public void removedInternalJDKs() throws IOException  {\n+        \/\/ verify the JDK removed internal API\n+        JdepsRunner summary = JdepsRunner.run(\"-summary\", CLASSES_DIR.toString());\n+        Arrays.stream(summary.output()).map(l -> l.split(\" -> \"))\n+              .map(a -> a[1]).filter(n -> n.equals(REMOVED_INTERNAL_API))\n+              .findFirst().orElseThrow();\n+\n+        JdepsRunner jdeps = JdepsRunner.run(\"-verbose:class\", CLASSES_DIR.toString());\n+        String output = jdeps.stdout.toString();\n+        Map<String, String> result = findDeps(output);\n+        for (String cn : result.keySet()) {\n+            String name = result.get(cn);\n+            if (REMOVED_APIS.contains(cn)) {\n+                assertEquals(name, REMOVED_INTERNAL_API);\n+            } else if (cn.startsWith(\"sun.reflect\")){\n+                assertEquals(name, \"JDK internal API (jdk.unsupported)\");\n+            } else {\n+                assertEquals(name, \"java.base\");\n+            }\n+        }\n+        REMOVED_APIS.stream().map(result::containsKey).allMatch(b -> b);\n+    }\n+\n+    \/\/ Pattern used to parse lines\n+    private static final Pattern linePattern = Pattern.compile(\".*\\r?\\n\");\n+    private static final  Pattern pattern = Pattern.compile(\"\\\\s+ -> (\\\\S+) +(.*)\");\n+\n+    \/\/ Use the linePattern to break the given String into lines, applying\n+    \/\/ the pattern to each line to see if we have a match\n+    private static Map<String, String> findDeps(String out) {\n+        Map<String, String> result = new LinkedHashMap<>();\n+        Matcher lm = linePattern.matcher(out);  \/\/ Line matcher\n+        Matcher pm = null;                      \/\/ Pattern matcher\n+        int lines = 0;\n+        while (lm.find()) {\n+            lines++;\n+            CharSequence cs = lm.group();       \/\/ The current line\n+            if (pm == null)\n+                pm = pattern.matcher(cs);\n+            else\n+                pm.reset(cs);\n+            if (pm.find())\n+                result.put(pm.group(1), pm.group(2).trim());\n+            if (lm.end() == out.length())\n+                break;\n+        }\n+        return result;\n+    }\n+\n","filename":"test\/langtools\/tools\/jdeps\/jdkinternals\/RemovedJDKInternals.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+    private static final long serialVersionUID = 1347132660681446077L;\n+\n","filename":"test\/lib\/jtreg\/SkippedException.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}