{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n- *      -agentlib:SetNativeMethodPrefix001=\n+ *      -agentlib:SetNativeMethodPrefix001\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetNativeMethodPrefix\/SetNativeMethodPrefix001\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,0 @@\n-#define NSK_JVMTI_OPTION_VAL_SEP    '='\n@@ -194,12 +193,6 @@\n-int isOptSep(char c) {\n-    return isspace(c) || c == '~';\n-}\n-\n-\n-\/**\n- *\n- * The current option will not perform more than one\n- * single option which given, this is due to places explained\n- * in this question.\n- *\n- **\/\n+\/*\n+ * Tokenize a string based on a list of delimiters.\n+ *\/\n+static char* token(char **s, const char *delim) {\n+  char *p;\n+  char *start = *s;\n@@ -207,4 +200,16 @@\n- \/*\n-  * This whole play can be reduced with simple StringTokenizer (strtok).\n-  *\n-  *\/\n+  if (s == NULL || *s == NULL) {\n+    return NULL;\n+  }\n+\n+  p = strpbrk(*s, delim);\n+  if (p != NULL) {\n+    \/* Advance to next token. *\/\n+    *p = '\\0';\n+    *s = p + 1;\n+  } else {\n+    \/* End of tokens. *\/\n+    *s = NULL;\n+  }\n+\n+  return start;\n+}\n@@ -218,2 +223,0 @@\n-    size_t len;\n-    const char* opt;\n@@ -222,4 +225,4 @@\n-    context.options.string = NULL;\n-    context.options.count = 0;\n-    context.waittime = 2;\n-\n+    char *str = NULL;\n+    char *name = NULL;\n+    char *value = NULL;\n+    const char *delimiters = \" ,~\";\n@@ -227,1 +230,1 @@\n-        return NSK_TRUE;\n+        return success;\n@@ -229,2 +232,5 @@\n-    len = strlen(options);\n-    context.options.string = (char*)malloc(len + 2);\n+    \/*\n+     * Save a copy of the full options string for\n+     * ArgumentHandler.getAgentOptionsString().\n+     *\/\n+    context.options.string = strdup(options);\n@@ -232,29 +238,4 @@\n-    if (context.options.string == NULL) {\n-            nsk_complain(\"nsk_jvmti_parseOptions(): out of memory\\n\");\n-            return NSK_FALSE;\n-    }\n-    strncpy(context.options.string, options, len);\n-    context.options.string[len] = '\\0';\n-    context.options.string[len+1] = '\\0';\n-\n-    for (opt = context.options.string; ; ) {\n-        const char* opt_end;\n-        const char* val_sep;\n-        int opt_len=0;\n-        int val_len=0;\n-                int exit=1;\n-\n-        while (*opt != '\\0' && isOptSep(*opt)) opt++;\n-        if (*opt == '\\0') break;\n-\n-        val_sep = NULL;\n-        \/*\n-            This should break when the first option it encounters other wise\n-        *\/\n-        for (opt_end = opt, opt_len=0; !(*opt_end == '\\0' || isOptSep(*opt_end)); opt_end++,opt_len++) {\n-            if (*opt_end == NSK_JVMTI_OPTION_VAL_SEP) {\n-                val_sep = opt_end;\n-                exit=0;\n-                break;\n-            }\n-        }\n+    \/* Create a temporary copy of the options string to be tokenized. *\/\n+    str = strdup(options);\n+    while ((name = token(&str, delimiters)) != NULL) {\n+        value = strchr(name, '=');\n@@ -262,18 +243,2 @@\n-        if (exit == 1) break;\n-\n-        \/* now scan for the search  for the option value end.\n-\n-        *\/\n-        exit =1;\n-        opt_end++;\n-        val_sep++;\n-        \/**\n-         * I was expecting this jvmti_parseOptions(),\n-         * should be for multiple options as well.\n-         * If this break is not there then It will expects\n-         * to have. so a space should be sufficient as well.\n-         *\/\n-        for(val_len=0; !(*opt_end == '\\0' || isOptSep(*opt_end)); opt_end++,val_len++) {\n-            \/\/if (*opt_end == NSK_JVMTI_OPTION_START) {\n-            \/\/    break;\n-            \/\/}\n+        if (value != NULL) {\n+            *value++ = '\\0';\n@@ -281,2 +246,2 @@\n-\n-        if (!add_option(opt, opt_len, val_sep, val_len)) {\n+        if (!add_option(name, (int)strlen(name), value,\n+                        value ? (int)strlen(value) : 0)) {\n@@ -286,2 +251,0 @@\n-        opt_end++;\n-        opt = opt_end;\n@@ -289,1 +252,0 @@\n-\n@@ -293,1 +255,3 @@\n-\n+    if (str != NULL) {\n+      free(str);\n+    }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\/jvmti_tools.cpp","additions":44,"deletions":80,"binary":false,"changes":124,"status":"modified"}]}