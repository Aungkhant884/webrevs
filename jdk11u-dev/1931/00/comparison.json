{"files":[{"patch":"@@ -999,3 +999,4 @@\n-            super.stop();\n-            try {\n-                ss.close();\n+            try (var toClose = ss) {\n+                stop = true;\n+                System.out.println(\"Server \" + ss + \" stop requested\");\n+                super.stop();\n@@ -1051,0 +1052,3 @@\n+            if (b.length() == 0) {\n+                return \"\";\n+            }\n@@ -1060,4 +1064,6 @@\n-            try {\n-                while (true) {\n-                    System.out.println(\"Tunnel: Waiting for client at: \" + ss);\n-                    Socket previous = clientConnection;\n+            while (!stop) {\n+                System.out.println(\"Tunnel: Waiting for client at: \" + ss);\n+                final Socket previous = clientConnection;\n+                try {\n+                    clientConnection = ss.accept();\n+                } catch (IOException io) {\n@@ -1065,7 +1071,10 @@\n-                        clientConnection = ss.accept();\n-                    } catch (IOException io) {\n-                        if (DEBUG) io.printStackTrace(System.out);\n-                        break;\n-                    } finally {\n-                        \/\/ close the previous connection\n-                        if (previous != null) previous.close();\n+                        ss.close();\n+                    } catch (IOException ex) {\n+                        if (DEBUG) {\n+                            ex.printStackTrace(System.out);\n+                        }\n+                    }\n+                    \/\/ log the reason that caused the server to stop accepting connections\n+                    if (!stop) {\n+                        System.err.println(\"Server will stop accepting connections due to an exception:\");\n+                        io.printStackTrace();\n@@ -1073,20 +1082,13 @@\n-                    System.out.println(\"Tunnel: Client accepted\");\n-                    Socket targetConnection = null;\n-                    InputStream  ccis = clientConnection.getInputStream();\n-                    OutputStream ccos = clientConnection.getOutputStream();\n-                    Writer w = new OutputStreamWriter(\n-                                   clientConnection.getOutputStream(), \"UTF-8\");\n-                    PrintWriter pw = new PrintWriter(w);\n-                    System.out.println(\"Tunnel: Reading request line\");\n-                    String requestLine = readLine(ccis);\n-                    System.out.println(\"Tunnel: Request line: \" + requestLine);\n-                    if (requestLine.startsWith(\"CONNECT \")) {\n-                        \/\/ We should probably check that the next word following\n-                        \/\/ CONNECT is the host:port of our HTTPS serverImpl.\n-                        \/\/ Some improvement for a followup!\n-\n-                        \/\/ Read all headers until we find the empty line that\n-                        \/\/ signals the end of all headers.\n-                        while(!requestLine.equals(\"\")) {\n-                            System.out.println(\"Tunnel: Reading header: \"\n-                                               + (requestLine = readLine(ccis)));\n+                    break;\n+                } finally {\n+                    \/\/ close the previous connection\n+                    if (previous != null) {\n+                        try {\n+                            previous.close();\n+                        } catch (IOException e) {\n+                            \/\/ ignore\n+                            if (DEBUG) {\n+                                System.out.println(\"Ignoring exception that happened while closing \" +\n+                                        \"an older connection:\");\n+                                e.printStackTrace(System.out);\n+                            }\n@@ -1094,15 +1096,0 @@\n-\n-                        targetConnection = new Socket(\n-                                serverImpl.getAddress().getAddress(),\n-                                serverImpl.getAddress().getPort());\n-\n-                        \/\/ Then send the 200 OK response to the client\n-                        System.out.println(\"Tunnel: Sending \"\n-                                           + \"HTTP\/1.1 200 OK\\r\\n\\r\\n\");\n-                        pw.print(\"HTTP\/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\");\n-                        pw.flush();\n-                    } else {\n-                        \/\/ This should not happen. If it does let our serverImpl\n-                        \/\/ deal with it.\n-                        throw new IOException(\"Tunnel: Unexpected status line: \"\n-                                             + requestLine);\n@@ -1110,14 +1097,0 @@\n-\n-                    \/\/ Pipe the input stream of the client connection to the\n-                    \/\/ output stream of the target connection and conversely.\n-                    \/\/ Now the client and target will just talk to each other.\n-                    System.out.println(\"Tunnel: Starting tunnel pipes\");\n-                    Thread t1 = pipe(ccis, targetConnection.getOutputStream(), '+');\n-                    Thread t2 = pipe(targetConnection.getInputStream(), ccos, '-');\n-                    t1.start();\n-                    t2.start();\n-\n-                    \/\/ We have only 1 client... wait until it has finished before\n-                    \/\/ accepting a new connection request.\n-                    t1.join();\n-                    t2.join();\n@@ -1125,1 +1098,1 @@\n-            } catch (Throwable ex) {\n+                System.out.println(\"Tunnel: Client accepted\");\n@@ -1127,3 +1100,24 @@\n-                    ss.close();\n-                } catch (IOException ex1) {\n-                    ex.addSuppressed(ex1);\n+                    \/\/ We have only 1 client... process the current client\n+                    \/\/ request and wait until it has finished before\n+                    \/\/ accepting a new connection request.\n+                    processRequestAndWaitToComplete(clientConnection);\n+                } catch (IOException ioe) {\n+                    \/\/ close the client connection\n+                    try {\n+                        clientConnection.close();\n+                    } catch (IOException io) {\n+                        \/\/ ignore\n+                        if (DEBUG) {\n+                            System.out.println(\"Ignoring exception that happened during client\" +\n+                                    \" connection close:\");\n+                            io.printStackTrace(System.out);\n+                        }\n+                    } finally {\n+                        clientConnection = null;\n+                    }\n+                } catch (Throwable t) {\n+                    \/\/ don't close the client connection for non-IOExceptions, instead\n+                    \/\/ just log it and move on to accept next connection\n+                    if (!stop) {\n+                        t.printStackTrace();\n+                    }\n@@ -1131,1 +1125,0 @@\n-                ex.printStackTrace(System.err);\n@@ -1135,0 +1128,52 @@\n+        private void processRequestAndWaitToComplete(final Socket clientConnection)\n+                throws IOException, InterruptedException {\n+            final Socket targetConnection;\n+            InputStream  ccis = clientConnection.getInputStream();\n+            OutputStream ccos = clientConnection.getOutputStream();\n+            Writer w = new OutputStreamWriter(\n+                    clientConnection.getOutputStream(), \"UTF-8\");\n+            PrintWriter pw = new PrintWriter(w);\n+            System.out.println(\"Tunnel: Reading request line\");\n+            String requestLine = readLine(ccis);\n+            System.out.println(\"Tunnel: Request line: \" + requestLine);\n+            if (requestLine.startsWith(\"CONNECT \")) {\n+                \/\/ We should probably check that the next word following\n+                \/\/ CONNECT is the host:port of our HTTPS serverImpl.\n+                \/\/ Some improvement for a followup!\n+\n+                \/\/ Read all headers until we find the empty line that\n+                \/\/ signals the end of all headers.\n+                while(!requestLine.equals(\"\")) {\n+                    System.out.println(\"Tunnel: Reading header: \"\n+                            + (requestLine = readLine(ccis)));\n+                }\n+\n+                targetConnection = new Socket(\n+                        serverImpl.getAddress().getAddress(),\n+                        serverImpl.getAddress().getPort());\n+\n+                \/\/ Then send the 200 OK response to the client\n+                System.out.println(\"Tunnel: Sending \"\n+                        + \"HTTP\/1.1 200 OK\\r\\n\\r\\n\");\n+                pw.print(\"HTTP\/1.1 200 OK\\r\\nContent-Length: 0\\r\\n\\r\\n\");\n+                pw.flush();\n+            } else {\n+                \/\/ This should not happen. If it does then consider it a\n+                \/\/ client error and throw an IOException\n+                System.out.println(\"Tunnel: Throwing an IOException due to unexpected\" +\n+                        \" request line: \" + requestLine);\n+                throw new IOException(\"Client request error - Unexpected request line\");\n+            }\n+\n+            \/\/ Pipe the input stream of the client connection to the\n+            \/\/ output stream of the target connection and conversely.\n+            \/\/ Now the client and target will just talk to each other.\n+            System.out.println(\"Tunnel: Starting tunnel pipes\");\n+            Thread t1 = pipe(ccis, targetConnection.getOutputStream(), '+');\n+            Thread t2 = pipe(targetConnection.getInputStream(), ccos, '-');\n+            t1.start();\n+            t2.start();\n+            \/\/ wait for the request to complete\n+            t1.join();\n+            t2.join();\n+        }\n","filename":"test\/jdk\/java\/net\/HttpURLConnection\/SetAuthenticator\/HTTPTestServer.java","additions":113,"deletions":68,"binary":false,"changes":181,"status":"modified"}]}