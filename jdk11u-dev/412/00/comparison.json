{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,3 @@\n- * @bug 1234567\n- * @summary SSLEngine has not yet caused Solaris kernel to panic\n+ * @bug 8250839\n+ * @summary Improve test template SSLEngineTemplate with SSLContextTemplate\n+ * @build SSLContextTemplate\n@@ -33,0 +34,4 @@\n+import javax.net.ssl.*;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import java.nio.ByteBuffer;\n+\n@@ -47,20 +52,1 @@\n- * produced.  (For more information, please see the SSL\/TLS\n- * specifications.)  There may several steps for a successful handshake,\n- * so it's typical to see the following series of operations:\n- *\n- *      client          server          message\n- *      ======          ======          =======\n- *      wrap()          ...             ClientHello\n- *      ...             unwrap()        ClientHello\n- *      ...             wrap()          ServerHello\/Certificate\n- *      unwrap()        ...             ServerHello\/Certificate\n- *      wrap()          ...             ClientKeyExchange\n- *      wrap()          ...             ChangeCipherSpec\n- *      wrap()          ...             Finished\n- *      ...             unwrap()        ClientKeyExchange\n- *      ...             unwrap()        ChangeCipherSpec\n- *      ...             unwrap()        Finished\n- *      ...             wrap()          ChangeCipherSpec\n- *      ...             wrap()          Finished\n- *      unwrap()        ...             ChangeCipherSpec\n- *      unwrap()        ...             Finished\n+ * produced.\n@@ -68,23 +54,27 @@\n-import javax.net.ssl.*;\n-import javax.net.ssl.SSLEngineResult.*;\n-import java.io.*;\n-import java.security.*;\n-import java.nio.*;\n-\n-public class SSLEngineTemplate {\n-\n-    \/*\n-     * Enables logging of the SSLEngine operations.\n-     *\/\n-    private static final boolean logging = true;\n-\n-    \/*\n-     * Enables the JSSE system debugging system property:\n-     *\n-     *     -Djavax.net.debug=all\n-     *\n-     * This gives a lot of low-level information about operations underway,\n-     * including specific handshake messages, and might be best examined\n-     * after gaining some familiarity with this application.\n-     *\/\n-    private static final boolean debug = false;\n+public class SSLEngineTemplate implements SSLContextTemplate {\n+    private final SSLEngine clientEngine;     \/\/ client Engine\n+    private final ByteBuffer clientOut;       \/\/ write side of clientEngine\n+    private final ByteBuffer clientIn;        \/\/ read side of clientEngine\n+\n+    private final SSLEngine serverEngine;     \/\/ server Engine\n+    private final ByteBuffer serverOut;       \/\/ write side of serverEngine\n+    private final ByteBuffer serverIn;        \/\/ read side of serverEngine\n+\n+    \/\/ For data transport, this example uses local ByteBuffers.  This\n+    \/\/ isn't really useful, but the purpose of this example is to show\n+    \/\/ SSLEngine concepts, not how to do network transport.\n+    private final ByteBuffer cTOs;      \/\/ \"reliable\" transport client->server\n+    private final ByteBuffer sTOc;      \/\/ \"reliable\" transport server->client\n+\n+    private SSLEngineTemplate() throws Exception {\n+        serverEngine = configureServerEngine(\n+                createServerSSLContext().createSSLEngine());\n+\n+        clientEngine = configureClientEngine(\n+                createClientSSLContext().createSSLEngine());\n+\n+        \/\/ We'll assume the buffer sizes are the same\n+        \/\/ between client and server.\n+        SSLSession session = clientEngine.getSession();\n+        int appBufferMax = session.getApplicationBufferSize();\n+        int netBufferMax = session.getPacketBufferSize();\n@@ -92,1 +82,9 @@\n-    private final SSLContext sslc;\n+        \/\/ We'll make the input buffers a bit bigger than the max needed\n+        \/\/ size, so that unwrap()s following a successful data transfer\n+        \/\/ won't generate BUFFER_OVERFLOWS.\n+        \/\/\n+        \/\/ We'll use a mix of direct and indirect ByteBuffers for\n+        \/\/ tutorial purposes only.  In reality, only use direct\n+        \/\/ ByteBuffers when they give a clear performance enhancement.\n+        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n+        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n@@ -94,3 +92,2 @@\n-    private SSLEngine clientEngine;     \/\/ client Engine\n-    private ByteBuffer clientOut;       \/\/ write side of clientEngine\n-    private ByteBuffer clientIn;        \/\/ read side of clientEngine\n+        cTOs = ByteBuffer.allocateDirect(netBufferMax);\n+        sTOc = ByteBuffer.allocateDirect(netBufferMax);\n@@ -98,3 +95,3 @@\n-    private SSLEngine serverEngine;     \/\/ server Engine\n-    private ByteBuffer serverOut;       \/\/ write side of serverEngine\n-    private ByteBuffer serverIn;        \/\/ read side of serverEngine\n+        clientOut = ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n+        serverOut = ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n+    }\n@@ -102,7 +99,3 @@\n-    \/*\n-     * For data transport, this example uses local ByteBuffers.  This\n-     * isn't really useful, but the purpose of this example is to show\n-     * SSLEngine concepts, not how to do network transport.\n-     *\/\n-    private ByteBuffer cTOs;            \/\/ \"reliable\" transport client->server\n-    private ByteBuffer sTOc;            \/\/ \"reliable\" transport server->client\n+    \/\/\n+    \/\/ Protected methods could be used to customize the test case.\n+    \/\/\n@@ -111,1 +104,1 @@\n-     * The following is to set up the keystores.\n+     * Configure the client side engine.\n@@ -113,19 +106,2 @@\n-    private static final String pathToStores = \"..\/etc\";\n-    private static final String keyStoreFile = \"keystore\";\n-    private static final String trustStoreFile = \"truststore\";\n-    private static final char[] passphrase = \"passphrase\".toCharArray();\n-\n-    private static final String keyFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-    private static final String trustFilename =\n-            System.getProperty(\"test.src\", \".\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n-\n-    \/*\n-     * Main entry point for this test.\n-     *\/\n-    public static void main(String args[]) throws Exception {\n-        if (debug) {\n-            System.setProperty(\"javax.net.debug\", \"all\");\n-        }\n+    protected SSLEngine configureClientEngine(SSLEngine clientEngine) {\n+        clientEngine.setUseClientMode(true);\n@@ -133,2 +109,3 @@\n-        SSLEngineTemplate test = new SSLEngineTemplate();\n-        test.runTest();\n+        \/\/ Get\/set parameters if needed\n+        \/\/ SSLParameters paramsClient = clientEngine.getSSLParameters();\n+        \/\/ clientEngine.setSSLParameters(paramsClient);\n@@ -136,1 +113,1 @@\n-        System.out.println(\"Test Passed.\");\n+        return clientEngine;\n@@ -140,1 +117,1 @@\n-     * Create an initialized SSLContext to use for these tests.\n+     * Configure the server side engine.\n@@ -142,15 +119,3 @@\n-    public SSLEngineTemplate() throws Exception {\n-\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        KeyStore ts = KeyStore.getInstance(\"JKS\");\n-\n-        ks.load(new FileInputStream(keyFilename), passphrase);\n-        ts.load(new FileInputStream(trustFilename), passphrase);\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(ks, passphrase);\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(ts);\n-\n-        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n+    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setNeedClientAuth(true);\n@@ -158,1 +123,4 @@\n-        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+        \/\/ Get\/set parameters if needed\n+        \/\/\n+        \/\/ SSLParameters paramsServer = serverEngine.getSSLParameters();\n+        \/\/ serverEngine.setSSLParameters(paramsServer);\n@@ -160,1 +128,1 @@\n-        sslc = sslCtx;\n+        return serverEngine;\n@@ -163,19 +131,3 @@\n-    \/*\n-     * Run the test.\n-     *\n-     * Sit in a tight loop, both engines calling wrap\/unwrap regardless\n-     * of whether data is available or not.  We do this until both engines\n-     * report back they are closed.\n-     *\n-     * The main loop handles all of the I\/O phases of the SSLEngine's\n-     * lifetime:\n-     *\n-     *     initial handshaking\n-     *     application data transfer\n-     *     engine closing\n-     *\n-     * One could easily separate these phases into separate\n-     * sections of code.\n-     *\/\n-    private void runTest() throws Exception {\n-        boolean dataDone = false;\n+    public static void main(String[] args) throws Exception {\n+        new SSLEngineTemplate().runTest();\n+    }\n@@ -183,2 +135,3 @@\n-        createSSLEngines();\n-        createBuffers();\n+    \/\/\n+    \/\/ Private methods that used to build the common part of the test.\n+    \/\/\n@@ -186,1 +139,1 @@\n-        \/\/ results from client's last operation\n+    private void runTest() throws Exception {\n@@ -188,2 +141,0 @@\n-\n-        \/\/ results from server's last operation\n@@ -192,25 +143,3 @@\n-        \/*\n-         * Examining the SSLEngineResults could be much more involved,\n-         * and may alter the overall flow of the application.\n-         *\n-         * For example, if we received a BUFFER_OVERFLOW when trying\n-         * to write to the output pipe, we could reallocate a larger\n-         * pipe, but instead we wait for the peer to drain it.\n-         *\/\n-        Exception clientException = null;\n-        Exception serverException = null;\n-\n-        while (!isEngineClosed(clientEngine)\n-                || !isEngineClosed(serverEngine)) {\n-\n-            log(\"================\");\n-\n-            try {\n-                clientResult = clientEngine.wrap(clientOut, cTOs);\n-                log(\"client wrap: \", clientResult);\n-            } catch (Exception e) {\n-                clientException = e;\n-                System.out.println(\"Client wrap() threw: \" + e.getMessage());\n-            }\n-            logEngineStatus(clientEngine);\n-            runDelegatedTasks(clientEngine);\n+        boolean dataDone = false;\n+        while (isOpen(clientEngine) || isOpen(serverEngine)) {\n+            log(\"=================\");\n@@ -218,1 +147,5 @@\n-            log(\"----\");\n+            \/\/ client wrap\n+            log(\"---Client Wrap---\");\n+            clientResult = clientEngine.wrap(clientOut, cTOs);\n+            logEngineStatus(clientEngine, clientResult);\n+            runDelegatedTasks(clientEngine);\n@@ -220,8 +153,4 @@\n-            try {\n-                serverResult = serverEngine.wrap(serverOut, sTOc);\n-                log(\"server wrap: \", serverResult);\n-            } catch (Exception e) {\n-                serverException = e;\n-                System.out.println(\"Server wrap() threw: \" + e.getMessage());\n-            }\n-            logEngineStatus(serverEngine);\n+            \/\/ server wrap\n+            log(\"---Server Wrap---\");\n+            serverResult = serverEngine.wrap(serverOut, sTOc);\n+            logEngineStatus(serverEngine, serverResult);\n@@ -233,10 +162,4 @@\n-            log(\"--------\");\n-\n-            try {\n-                clientResult = clientEngine.unwrap(sTOc, clientIn);\n-                log(\"client unwrap: \", clientResult);\n-            } catch (Exception e) {\n-                clientException = e;\n-                System.out.println(\"Client unwrap() threw: \" + e.getMessage());\n-            }\n-            logEngineStatus(clientEngine);\n+            \/\/ client unwrap\n+            log(\"---Client Unwrap---\");\n+            clientResult = clientEngine.unwrap(sTOc, clientIn);\n+            logEngineStatus(clientEngine, clientResult);\n@@ -245,10 +168,4 @@\n-            log(\"----\");\n-\n-            try {\n-                serverResult = serverEngine.unwrap(cTOs, serverIn);\n-                log(\"server unwrap: \", serverResult);\n-            } catch (Exception e) {\n-                serverException = e;\n-                System.out.println(\"Server unwrap() threw: \" + e.getMessage());\n-            }\n-            logEngineStatus(serverEngine);\n+            \/\/ server unwrap\n+            log(\"---Server Unwrap---\");\n+            serverResult = serverEngine.unwrap(cTOs, serverIn);\n+            logEngineStatus(serverEngine, serverResult);\n@@ -260,6 +177,4 @@\n-            \/*\n-             * After we've transfered all application data between the client\n-             * and server, we close the clientEngine's outbound stream.\n-             * This generates a close_notify handshake message, which the\n-             * server engine receives and responds by closing itself.\n-             *\/\n+            \/\/ After we've transferred all application data between the client\n+            \/\/ and server, we close the clientEngine's outbound stream.\n+            \/\/ This generates a close_notify handshake message, which the\n+            \/\/ server engine receives and responds by closing itself.\n@@ -269,3 +184,1 @@\n-                \/*\n-                 * A sanity check to ensure we got what was sent.\n-                 *\/\n+                \/\/ A sanity check to ensure we got what was sent.\n@@ -287,0 +200,4 @@\n+    private static boolean isOpen(SSLEngine engine) {\n+        return (!engine.isOutboundDone() || !engine.isInboundDone());\n+    }\n+\n@@ -288,2 +205,2 @@\n-        log(\"\\tCurrent HS State  \" + engine.getHandshakeStatus().toString());\n-        log(\"\\tisInboundDone():  \" + engine.isInboundDone());\n+        log(\"\\tCurrent HS State: \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone() : \" + engine.isInboundDone());\n@@ -293,26 +210,8 @@\n-    \/*\n-     * Using the SSLContext created during object creation,\n-     * create\/configure the SSLEngines we'll use for this test.\n-     *\/\n-    private void createSSLEngines() throws Exception {\n-        \/*\n-         * Configure the serverEngine to act as a server in the SSL\/TLS\n-         * handshake.  Also, require SSL client authentication.\n-         *\/\n-        serverEngine = sslc.createSSLEngine();\n-        serverEngine.setUseClientMode(false);\n-        serverEngine.setNeedClientAuth(true);\n-\n-        \/\/ Get\/set parameters if needed\n-        SSLParameters paramsServer = serverEngine.getSSLParameters();\n-        serverEngine.setSSLParameters(paramsServer);\n-\n-        \/*\n-         * Similar to above, but using client mode instead.\n-         *\/\n-        clientEngine = sslc.createSSLEngine(\"client\", 80);\n-        clientEngine.setUseClientMode(true);\n-\n-        \/\/ Get\/set parameters if needed\n-        SSLParameters paramsClient = clientEngine.getSSLParameters();\n-        clientEngine.setSSLParameters(paramsClient);\n+    private static void logEngineStatus(\n+            SSLEngine engine, SSLEngineResult result) {\n+        log(\"\\tResult Status    : \" + result.getStatus());\n+        log(\"\\tResult HS Status : \" + result.getHandshakeStatus());\n+        log(\"\\tEngine HS Status : \" + engine.getHandshakeStatus());\n+        log(\"\\tisInboundDone()  : \" + engine.isInboundDone());\n+        log(\"\\tisOutboundDone() : \" + engine.isOutboundDone());\n+        log(\"\\tMore Result      : \" + result);\n@@ -321,30 +220,2 @@\n-    \/*\n-     * Create and size the buffers appropriately.\n-     *\/\n-    private void createBuffers() {\n-\n-        \/*\n-         * We'll assume the buffer sizes are the same\n-         * between client and server.\n-         *\/\n-        SSLSession session = clientEngine.getSession();\n-        int appBufferMax = session.getApplicationBufferSize();\n-        int netBufferMax = session.getPacketBufferSize();\n-\n-        \/*\n-         * We'll make the input buffers a bit bigger than the max needed\n-         * size, so that unwrap()s following a successful data transfer\n-         * won't generate BUFFER_OVERFLOWS.\n-         *\n-         * We'll use a mix of direct and indirect ByteBuffers for\n-         * tutorial purposes only.  In reality, only use direct\n-         * ByteBuffers when they give a clear performance enhancement.\n-         *\/\n-        clientIn = ByteBuffer.allocate(appBufferMax + 50);\n-        serverIn = ByteBuffer.allocate(appBufferMax + 50);\n-\n-        cTOs = ByteBuffer.allocateDirect(netBufferMax);\n-        sTOc = ByteBuffer.allocateDirect(netBufferMax);\n-\n-        clientOut = ByteBuffer.wrap(\"Hi Server, I'm Client\".getBytes());\n-        serverOut = ByteBuffer.wrap(\"Hello Client, I'm Server\".getBytes());\n+    private static void log(String message) {\n+        System.err.println(message);\n@@ -353,4 +224,2 @@\n-    \/*\n-     * If the result indicates that we have outstanding tasks to do,\n-     * go ahead and run them in this thread.\n-     *\/\n+    \/\/ If the result indicates that we have outstanding tasks to do,\n+    \/\/ go ahead and run them in this thread.\n@@ -358,1 +227,0 @@\n-\n@@ -368,1 +236,1 @@\n-                    \"handshake shouldn't need additional tasks\");\n+                        \"handshake shouldn't need additional tasks\");\n@@ -374,7 +242,1 @@\n-    private static boolean isEngineClosed(SSLEngine engine) {\n-        return (engine.isOutboundDone() && engine.isInboundDone());\n-    }\n-\n-    \/*\n-     * Simple check to make sure everything came across as expected.\n-     *\/\n+    \/\/ Simple check to make sure everything came across as expected.\n@@ -397,31 +259,0 @@\n-\n-    \/*\n-     * Logging code\n-     *\/\n-    private static boolean resultOnce = true;\n-\n-    private static void log(String str, SSLEngineResult result) {\n-        if (!logging) {\n-            return;\n-        }\n-        if (resultOnce) {\n-            resultOnce = false;\n-            System.out.println(\"The format of the SSLEngineResult is: \\n\" +\n-                    \"\\t\\\"getStatus() \/ getHandshakeStatus()\\\" +\\n\" +\n-                    \"\\t\\\"bytesConsumed() \/ bytesProduced()\\\"\\n\");\n-        }\n-        HandshakeStatus hsStatus = result.getHandshakeStatus();\n-        log(str +\n-                result.getStatus() + \"\/\" + hsStatus + \", \" +\n-                result.bytesConsumed() + \"\/\" + result.bytesProduced() +\n-                \" bytes\");\n-        if (hsStatus == HandshakeStatus.FINISHED) {\n-            log(\"\\t...ready for application data\");\n-        }\n-    }\n-\n-    private static void log(String str) {\n-        if (logging) {\n-            System.out.println(str);\n-        }\n-    }\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLEngineTemplate.java","additions":121,"deletions":290,"binary":false,"changes":411,"status":"modified"}]}