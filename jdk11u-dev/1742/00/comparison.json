{"files":[{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2020, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8134007 8035787\n+ * @summary folded string literals should have correct start and end positions\n+ *\/\n+\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.SourcePositions;\n+import com.sun.source.util.TreeScanner;\n+import com.sun.source.util.Trees;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.Arrays;\n+\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+public class StringFoldingPosTest {\n+    private final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+\n+    public static void main(String[] args) throws IOException {\n+        StringFoldingPosTest t = new StringFoldingPosTest();\n+        JavaFileObject source =\n+                t.makeSource(\n+                        \"C\", \"class C {String X=\\\"F\\\" + \\\"O\\\" + \\\"L\\\" + \\\"D\\\" + \\\"E\\\" + \\\"D\\\";}\");\n+        t.run(source, \"FOLDED\", 18, 51);\n+        source =\n+                t.makeSource(\n+                        \"C\",\n+                        \"class C {String X=(\\\"F\\\" + \\\"O\\\") + (\\\"L\\\" + \\\"D\\\") + (\\\"E\\\" + \\\"D\\\");}\");\n+        t.run(source, \"FO\", 19, 28);\n+        t.run(source, \"LD\", 33, 42);\n+        t.run(source, \"ED\", 47, 56);\n+    }\n+\n+    private static JavaFileObject makeSource(String name, String code) {\n+        return new SimpleJavaFileObject(\n+                URI.create(\n+                        \"file:\/\" + name.replace('.', '\/') + JavaFileObject.Kind.SOURCE.extension),\n+                JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+                return code;\n+            }\n+        };\n+    }\n+\n+    private void run(\n+            JavaFileObject source,\n+            String expectedLiteral,\n+            long expectedStartPos,\n+            long expectedEndPos)\n+            throws IOException {\n+        JavacTask ct =\n+                (JavacTask) compiler.getTask(null, null, null, null, null, Arrays.asList(source));\n+        SourcePositions positions = Trees.instance(ct).getSourcePositions();\n+        Iterable<? extends CompilationUnitTree> trees = ct.parse();\n+        boolean[] found = {false};\n+        for (CompilationUnitTree tree : trees) {\n+            new TreeScanner<Void, Void>() {\n+                @Override\n+                public Void visitLiteral(LiteralTree literal, Void v) {\n+                    if (literal.getKind() == Tree.Kind.STRING_LITERAL\n+                            && literal.getValue().equals(expectedLiteral)) {\n+                        long startPos = positions.getStartPosition(tree, literal);\n+                        long endPos = positions.getEndPosition(tree, literal);\n+                        if (startPos != expectedStartPos) {\n+                            throw new AssertionError(\n+                                    \"Expected start position \"\n+                                            + expectedStartPos\n+                                            + \", but was \"\n+                                            + startPos);\n+                        }\n+                        if (endPos != expectedEndPos) {\n+                            throw new AssertionError(\n+                                    \"Expected end position \"\n+                                            + expectedEndPos\n+                                            + \", but was \"\n+                                            + endPos);\n+                        }\n+                        found[0] = true;\n+                    }\n+                    return null;\n+                }\n+            }.scan(trees, null);\n+        }\n+        if (found[0]) {\n+            return;\n+        }\n+        throw new AssertionError(\"Expected string literal \" + expectedLiteral + \" not found\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/parser\/StringFoldingPosTest.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"}]}