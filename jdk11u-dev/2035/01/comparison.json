{"files":[{"patch":"@@ -838,0 +838,99 @@\n+\/\/ On Linux, glibc places static TLS blocks (for __thread variables) on\n+\/\/ the thread stack. This decreases the stack size actually available\n+\/\/ to threads.\n+\/\/\n+\/\/ For large static TLS sizes, this may cause threads to malfunction due\n+\/\/ to insufficient stack space. This is a well-known issue in glibc:\n+\/\/ http:\/\/sourceware.org\/bugzilla\/show_bug.cgi?id=11787.\n+\/\/\n+\/\/ As a workaround, we call a private but assumed-stable glibc function,\n+\/\/ __pthread_get_minstack() to obtain the minstack size and derive the\n+\/\/ static TLS size from it. We then increase the user requested stack\n+\/\/ size by this TLS size. The same function is used to determine whether\n+\/\/ adjustStackSizeForGuardPages() needs to be true.\n+\/\/\n+\/\/ Due to compatibility concerns, this size adjustment is opt-in and\n+\/\/ controlled via AdjustStackSizeForTLS.\n+typedef size_t (*GetMinStack)(const pthread_attr_t *attr);\n+\n+GetMinStack _get_minstack_func = NULL;  \/\/ Initialized via os::init_2()\n+\n+\/\/ Returns the size of the static TLS area glibc puts on thread stacks.\n+\/\/ The value is cached on first use, which occurs when the first thread\n+\/\/ is created during VM initialization.\n+static size_t get_static_tls_area_size(const pthread_attr_t *attr) {\n+  size_t tls_size = 0;\n+  if (_get_minstack_func != NULL) {\n+    \/\/ Obtain the pthread minstack size by calling __pthread_get_minstack.\n+    size_t minstack_size = _get_minstack_func(attr);\n+\n+    \/\/ Remove non-TLS area size included in minstack size returned\n+    \/\/ by __pthread_get_minstack() to get the static TLS size.\n+    \/\/ If adjustStackSizeForGuardPages() is true, minstack size includes\n+    \/\/ guard_size. Otherwise guard_size is automatically added\n+    \/\/ to the stack size by pthread_create and is no longer included\n+    \/\/ in minstack size. In both cases, the guard_size is taken into\n+    \/\/ account, so there is no need to adjust the result for that.\n+    \/\/\n+    \/\/ Although __pthread_get_minstack() is a private glibc function,\n+    \/\/ it is expected to have a stable behavior across future glibc\n+    \/\/ versions while glibc still allocates the static TLS blocks off\n+    \/\/ the stack. Following is glibc 2.28 __pthread_get_minstack():\n+    \/\/\n+    \/\/ size_t\n+    \/\/ __pthread_get_minstack (const pthread_attr_t *attr)\n+    \/\/ {\n+    \/\/   return GLRO(dl_pagesize) + __static_tls_size + PTHREAD_STACK_MIN;\n+    \/\/ }\n+    \/\/\n+    \/\/\n+    \/\/ The following 'minstack_size > os::vm_page_size() + PTHREAD_STACK_MIN'\n+    \/\/ if check is done for precaution.\n+    if (minstack_size > (size_t)os::vm_page_size() + PTHREAD_STACK_MIN) {\n+      tls_size = minstack_size - (size_t)os::vm_page_size() - PTHREAD_STACK_MIN;\n+    }\n+  }\n+\n+  log_info(os, thread)(\"Stack size adjustment for TLS is \" SIZE_FORMAT,\n+                       tls_size);\n+  return tls_size;\n+}\n+\n+\/\/ In glibc versions prior to 2.27 the guard size mechanism\n+\/\/ was not implemented properly. The POSIX standard requires adding\n+\/\/ the size of the guard pages to the stack size, instead glibc\n+\/\/ took the space out of 'stacksize'. Thus we need to adapt the requested\n+\/\/ stack_size by the size of the guard pages to mimic proper behaviour.\n+\/\/ The fix in glibc 2.27 has now been backported to numerous earlier\n+\/\/ glibc versions so we need to do a dynamic runtime check.\n+static bool _adjustStackSizeForGuardPages = true;\n+bool os::Linux::adjustStackSizeForGuardPages() {\n+  return _adjustStackSizeForGuardPages;\n+}\n+\n+#if defined(__GLIBC__)\n+\/\/ Dummy decl as substitute for cmdline parameter. TLS not in jdk11.\n+static const bool AdjustStackSizeForTLS = false;\n+static void init_adjust_stacksize_for_guard_pages() {\n+  assert(_get_minstack_func == NULL, \"initialization error\");\n+  _get_minstack_func =(GetMinStack)dlsym(RTLD_DEFAULT, \"__pthread_get_minstack\");\n+  log_info(os, thread)(\"Lookup of __pthread_get_minstack %s\",\n+                       _get_minstack_func == NULL ? \"failed\" : \"succeeded\");\n+\n+  if (_get_minstack_func != NULL) {\n+    pthread_attr_t attr;\n+    pthread_attr_init(&attr);\n+    size_t min_stack = _get_minstack_func(&attr);\n+    size_t guard = 16 * K; \/\/ Actual value doesn't matter as it is not examined\n+    pthread_attr_setguardsize(&attr, guard);\n+    size_t min_stack2 = _get_minstack_func(&attr);\n+    pthread_attr_destroy(&attr);\n+    \/\/ If the minimum stack size changed when we added the guard page space\n+    \/\/ then we need to perform the adjustment.\n+    _adjustStackSizeForGuardPages = (min_stack2 != min_stack);\n+    log_info(os)(\"Glibc stack size guard page adjustment is %sneeded\",\n+                 _adjustStackSizeForGuardPages ? \"\" : \"not \");\n+  }\n+}\n+#endif \/\/ GLIBC\n+\n@@ -863,7 +962,0 @@\n-  \/\/ In the Linux NPTL pthread implementation the guard size mechanism\n-  \/\/ is not implemented properly. The posix standard requires adding\n-  \/\/ the size of the guard pages to the stack size, instead Linux\n-  \/\/ takes the space out of 'stacksize'. Thus we adapt the requested\n-  \/\/ stack_size by the size of the guard pages to mimick proper\n-  \/\/ behaviour. However, be careful not to end up with a size\n-  \/\/ of zero due to overflow. Don't add the guard page in that case.\n@@ -871,2 +963,20 @@\n-  if (stack_size <= SIZE_MAX - guard_size) {\n-    stack_size += guard_size;\n+  \/\/ Configure glibc guard page. Must happen before calling\n+  \/\/ get_static_tls_area_size(), which uses the guard_size.\n+  pthread_attr_setguardsize(&attr, guard_size);\n+\n+  \/\/ Apply stack size adjustments if needed. However, be careful not to end up\n+  \/\/ with a size of zero due to overflow. Don't add the adjustment in that case.\n+  size_t stack_adjust_size = 0;\n+#if defined(__GLIBC__)\n+  if (AdjustStackSizeForTLS) {\n+    \/\/ Adjust the stack_size for on-stack TLS - see get_static_tls_area_size().\n+    stack_adjust_size += get_static_tls_area_size(&attr);\n+  } else\n+#endif\n+  if (os::Linux::adjustStackSizeForGuardPages()) {\n+    stack_adjust_size += guard_size;\n+  }\n+\n+  stack_adjust_size = align_up(stack_adjust_size, os::vm_page_size());\n+  if (stack_size <= SIZE_MAX - stack_adjust_size) {\n+    stack_size += stack_adjust_size;\n@@ -1008,2 +1118,4 @@\n-  log_info(os, thread)(\"Thread attached (tid: \" UINTX_FORMAT \", pthread id: \" UINTX_FORMAT \").\",\n-    os::current_thread_id(), (uintx) pthread_self());\n+  log_info(os, thread)(\"Thread attached (tid: \" UINTX_FORMAT \", pthread id: \" UINTX_FORMAT\n+                       \", stack: \" PTR_FORMAT \" - \" PTR_FORMAT \" (\" SIZE_FORMAT \"k) ).\",\n+                       os::current_thread_id(), (uintx) pthread_self(),\n+                       p2i(thread->stack_base()), p2i(thread->stack_end()), thread->stack_size() \/ K);\n@@ -1424,1 +1536,1 @@\n-  \/\/ If the fast Posix clocks are supported then the sys_clock_getres()\n+  \/\/ If the fast POSIX clocks are supported then the clock_getres()\n@@ -5521,0 +5633,5 @@\n+#ifdef __GLIBC__\n+  \/\/ Check if we need to adjust the stack size for glibc guard pages.\n+  init_adjust_stacksize_for_guard_pages();\n+#endif\n+\n@@ -6413,3 +6530,3 @@\n-\/\/ ** Due to NPTL implementation error, linux takes the glibc guard page out\n-\/\/    of the stack size given in pthread_attr. We work around this for\n-\/\/    threads created by the VM. (We adapt bottom to be P1 and size accordingly.)\n+\/\/ ** If adjustStackSizeForGuardPages() is true the guard pages have been taken\n+\/\/    out of the stack size given in pthread_attr. We work around this for\n+\/\/    threads created by the VM. We adjust bottom to be P1 and size accordingly.\n@@ -6442,8 +6559,9 @@\n-    \/\/ Work around NPTL stack guard error.\n-    size_t guard_size = 0;\n-    rslt = pthread_attr_getguardsize(&attr, &guard_size);\n-    if (rslt != 0) {\n-      fatal(\"pthread_attr_getguardsize failed with error = %d\", rslt);\n-    }\n-    *bottom += guard_size;\n-    *size   -= guard_size;\n+    if (os::Linux::adjustStackSizeForGuardPages()) {\n+       size_t guard_size = 0;\n+       rslt = pthread_attr_getguardsize(&attr, &guard_size);\n+       if (rslt != 0) {\n+         fatal(\"pthread_attr_getguardsize failed with error = %d\", rslt);\n+       }\n+       *bottom += guard_size;\n+       *size   -= guard_size;\n+     }\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":141,"deletions":23,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -201,0 +201,2 @@\n+  static bool adjustStackSizeForGuardPages(); \/\/ See comments in os_linux.cpp\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1432,2 +1432,2 @@\n-  \/\/ Work around linux NPTL implementation error, see also os::create_thread() in os_linux.cpp.\n-  LINUX_ONLY(stack_size -= guard_size);\n+  \/\/ Work around glibc stack guard issue, see os::create_thread() in os_linux.cpp.\n+  LINUX_ONLY(if (os::Linux::adjustStackSizeForGuardPages()) stack_size -= guard_size;)\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}