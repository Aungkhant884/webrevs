{"files":[{"patch":"@@ -1848,0 +1848,4 @@\n+    if (n->is_SafePoint()) {\n+      \/\/ Keep track of SafePoint nodes for PhaseCCP::transform()\n+      _safepoints.push(n);\n+    }\n@@ -1964,0 +1968,17 @@\n+\n+  \/\/ This CCP pass may prove that no exit test for a loop ever succeeds (i.e. the loop is infinite). In that case,\n+  \/\/ the logic below doesn't follow any path from Root to the loop body: there's at least one such path but it's proven\n+  \/\/ never taken (its type is TOP). As a consequence the node on the exit path that's input to Root (let's call it n) is\n+  \/\/ replaced by the top node and the inputs of that node n are not enqueued for further processing. If CCP only works\n+  \/\/ through the graph from Root, this causes the loop body to never be processed here even when it's not dead (that\n+  \/\/ is reachable from Root following its uses). To prevent that issue, transform() starts walking the graph from Root\n+  \/\/ and all safepoints.\n+  for (uint i = 0; i < _safepoints.size(); ++i) {\n+    Node* nn = _safepoints.at(i);\n+    Node* new_node = _nodes[nn->_idx];\n+    assert(new_node == NULL, \"\");\n+    new_node = transform_once(nn);\n+    _nodes.map(nn->_idx, new_node);\n+    trstack.push(new_node);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -585,0 +585,1 @@\n+  Unique_Node_List _safepoints;\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8290711\n+ * @summary assert(false) failed: infinite loop in PhaseIterGVN::optimize\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:-UseOnStackReplacement -XX:-TieredCompilation TestInfiniteIGVNAfterCCP\n+ *\/\n+\n+\n+import java.util.function.BooleanSupplier;\n+\n+public class TestInfiniteIGVNAfterCCP {\n+    private static int inc;\n+    private static volatile boolean barrier;\n+\n+    static class A {\n+        int field1;\n+        int field2;\n+    }\n+\n+    public static void main(String[] args) {\n+        A a = new A();\n+        for (int i = 0; i < 20_000; i++) {\n+            test(false, a, false);\n+            inc = 0;\n+            testHelper(true, () -> inc < 10, a, 4, true);\n+            inc = 0;\n+            testHelper(true, () -> inc < 10, a, 4, false);\n+            testHelper(false, () -> inc < 10, a, 42, false);\n+        }\n+    }\n+\n+    private static void test(boolean flag2, A a, boolean flag1) {\n+        int i = 2;\n+        for (; i < 4; i *= 2);\n+        testHelper(flag2, () -> true, a, i, flag1);\n+    }\n+\n+    private static void testHelper(boolean flag2, BooleanSupplier f, A a, int i, boolean flag1) {\n+        if (i == 4) {\n+            if (a == null) {\n+\n+            }\n+        } else {\n+            a = null;\n+        }\n+        if (flag2) {\n+            while (true) {\n+                synchronized (new Object()) {\n+\n+                }\n+                if (!f.getAsBoolean()) {\n+                    break;\n+                }\n+                if (flag1) {\n+                    if (a == null) {\n+\n+                    }\n+                }\n+                barrier = true;\n+                inc++;\n+                if (inc % 2 == 0) {\n+                    a.field1++;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ccp\/TestInfiniteIGVNAfterCCP.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}