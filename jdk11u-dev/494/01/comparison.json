{"files":[{"patch":"@@ -46,0 +46,3 @@\n+import static sun.java2d.SunGraphicsEnvironment.toDeviceSpace;\n+import static sun.java2d.SunGraphicsEnvironment.toDeviceSpaceAbs;\n+\n@@ -380,7 +383,3 @@\n-        AffineTransform tx = GraphicsEnvironment.\n-                getLocalGraphicsEnvironment().getDefaultScreenDevice().\n-                getDefaultConfiguration().getDefaultTransform();\n-        x = (int) (x * tx.getScaleX());\n-        y = (int) (y * tx.getScaleY());\n-        Color color = new Color(peer.getRGBPixel(x, y));\n-        return color;\n+        Point point = peer.useAbsoluteCoordinates() ? toDeviceSpaceAbs(x, y)\n+                                                    : toDeviceSpace(x, y);\n+        return new Color(peer.getRGBPixel(point.x, point.y));\n@@ -519,7 +518,8 @@\n-            int sX = (int) Math.floor(screenRect.x * uiScaleX);\n-            int sY = (int) Math.floor(screenRect.y * uiScaleY);\n-            int sWidth = (int) Math.ceil(screenRect.width * uiScaleX);\n-            int sHeight = (int) Math.ceil(screenRect.height * uiScaleY);\n-            int temppixels[];\n-            Rectangle scaledRect = new Rectangle(sX, sY, sWidth, sHeight);\n-            temppixels = peer.getRGBPixels(scaledRect);\n+            Rectangle scaledRect;\n+            if (peer.useAbsoluteCoordinates()) {\n+                scaledRect = toDeviceSpaceAbs(gc, screenRect.x,\n+                        screenRect.y, screenRect.width, screenRect.height);\n+            } else {\n+                scaledRect = toDeviceSpace(gc, screenRect.x,\n+                        screenRect.y, screenRect.width, screenRect.height);\n+            }\n@@ -528,1 +528,1 @@\n-            pixels = temppixels;\n+            pixels = peer.getRGBPixels(scaledRect);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Robot.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,10 @@\n+\n+    \/**\n+     * Determines if absolute coordinates should be used by this peer.\n+     *\n+     * @return {@code true} if absolute coordinates should be used,\n+     *         {@code false} otherwise\n+     *\/\n+    default boolean useAbsoluteCoordinates() {\n+        return false;\n+    }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/peer\/RobotPeer.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.awt.Dimension;\n@@ -404,2 +405,35 @@\n-     * Converts coordinates from the user's space to the device space using\n-     * appropriate device transformation.\n+     * Returns the bounds of the graphics configuration in device space.\n+     *\n+     * @param  config the graphics configuration which bounds are requested\n+     * @return the bounds of the area covered by this\n+     *         {@code GraphicsConfiguration} in device space (pixels)\n+     *\/\n+    public static Rectangle getGCDeviceBounds(GraphicsConfiguration config) {\n+        AffineTransform tx = config.getDefaultTransform();\n+        Rectangle bounds = config.getBounds();\n+        bounds.width *= tx.getScaleX();\n+        bounds.height *= tx.getScaleY();\n+        return bounds;\n+    }\n+\n+    \/**\n+     * Converts the size (w, h) from the device space to the user's space using\n+     * passed graphics configuration.\n+     *\n+     * @param  gc the graphics configuration to be used for transformation\n+     * @param  w the width in the device space\n+     * @param  h the height in the device space\n+     * @return the size in the user's space\n+     *\/\n+    public static Dimension toUserSpace(GraphicsConfiguration gc,\n+                                        int w, int h) {\n+        AffineTransform tx = gc.getDefaultTransform();\n+        return new Dimension(\n+                Region.clipRound(w \/ tx.getScaleX()),\n+                Region.clipRound(h \/ tx.getScaleY())\n+        );\n+    }\n+\n+    \/**\n+     * Converts absolute coordinates from the user's space to the device space\n+     * using appropriate device transformation.\n@@ -407,3 +441,3 @@\n-     * @param  x coordinate in the user space\n-     * @param  y coordinate in the user space\n-     * @return the point which uses device space(pixels)\n+     * @param  x absolute coordinate in the user's space\n+     * @param  y absolute coordinate in the user's space\n+     * @return the point which uses device space (pixels)\n@@ -411,1 +445,1 @@\n-    public static Point convertToDeviceSpace(double x, double y) {\n+    public static Point toDeviceSpaceAbs(int x, int y) {\n@@ -413,1 +447,1 @@\n-                        .getDefaultScreenDevice().getDefaultConfiguration();\n+                .getDefaultScreenDevice().getDefaultConfiguration();\n@@ -415,0 +449,2 @@\n+        return toDeviceSpaceAbs(gc, x, y, 0, 0).getLocation();\n+    }\n@@ -416,0 +452,27 @@\n+    \/**\n+     * Converts the rectangle from the user's space to the device space using\n+     * appropriate device transformation.\n+     *\n+     * @param  rect the rectangle in the user's space\n+     * @return the rectangle which uses device space (pixels)\n+     *\/\n+    public static Rectangle toDeviceSpaceAbs(Rectangle rect) {\n+        GraphicsConfiguration gc = getLocalGraphicsEnvironment()\n+                .getDefaultScreenDevice().getDefaultConfiguration();\n+        gc = getGraphicsConfigurationAtPoint(gc, rect.x, rect.y);\n+        return toDeviceSpaceAbs(gc, rect.x, rect.y, rect.width, rect.height);\n+    }\n+\n+    \/**\n+     * Converts absolute coordinates (x, y) and the size (w, h) from the user's\n+     * space to the device space using passed graphics configuration.\n+     *\n+     * @param  gc the graphics configuration to be used for transformation\n+     * @param  x absolute coordinate in the user's space\n+     * @param  y absolute coordinate in the user's space\n+     * @param  w the width in the user's space\n+     * @param  h the height in the user's space\n+     * @return the rectangle which uses device space (pixels)\n+     *\/\n+    public static Rectangle toDeviceSpaceAbs(GraphicsConfiguration gc,\n+                                             int x, int y, int w, int h) {\n@@ -417,3 +480,7 @@\n-        x = Region.clipRound(x * tx.getScaleX());\n-        y = Region.clipRound(y * tx.getScaleY());\n-        return new Point((int) x, (int) y);\n+        Rectangle screen = gc.getBounds();\n+        return new Rectangle(\n+                screen.x + Region.clipRound((x - screen.x) * tx.getScaleX()),\n+                screen.y + Region.clipRound((y - screen.y) * tx.getScaleY()),\n+                Region.clipRound(w * tx.getScaleX()),\n+                Region.clipRound(h * tx.getScaleY())\n+        );\n@@ -423,1 +490,1 @@\n-     * Converts bounds from the user's space to the device space using\n+     * Converts coordinates from the user's space to the device space using\n@@ -426,2 +493,3 @@\n-     * @param  bounds the rectangle in the user space\n-     * @return the rectangle which uses device space(pixels)\n+     * @param  x coordinate in the user's space\n+     * @param  y coordinate in the user's space\n+     * @return the point which uses device space (pixels)\n@@ -429,1 +497,1 @@\n-    public static Rectangle convertToDeviceSpace(Rectangle bounds) {\n+    public static Point toDeviceSpace(int x, int y) {\n@@ -432,2 +500,2 @@\n-        gc = getGraphicsConfigurationAtPoint(gc, bounds.x, bounds.y);\n-        return convertToDeviceSpace(gc, bounds);\n+        gc = getGraphicsConfigurationAtPoint(gc, x, y);\n+        return toDeviceSpace(gc, x, y, 0, 0).getLocation();\n@@ -437,2 +505,2 @@\n-     * Converts bounds from the user's space to the device space using\n-     * appropriate device transformation of the passed graphics configuration.\n+     * Converts coordinates (x, y) and the size (w, h) from the user's\n+     * space to the device space using passed graphics configuration.\n@@ -440,2 +508,6 @@\n-     * @param  bounds the rectangle in the user space\n-     * @return the rectangle which uses device space(pixels)\n+     * @param  gc the graphics configuration to be used for transformation\n+     * @param  x coordinate in the user's space\n+     * @param  y coordinate in the user's space\n+     * @param  w the width in the user's space\n+     * @param  h the height in the user's space\n+     * @return the rectangle which uses device space (pixels)\n@@ -443,2 +515,2 @@\n-    public static Rectangle convertToDeviceSpace(GraphicsConfiguration gc,\n-                                                 Rectangle bounds) {\n+    public static Rectangle toDeviceSpace(GraphicsConfiguration gc,\n+                                          int x, int y, int w, int h) {\n@@ -447,4 +519,4 @@\n-                Region.clipRound(bounds.x * tx.getScaleX()),\n-                Region.clipRound(bounds.y * tx.getScaleY()),\n-                Region.clipRound(bounds.width * tx.getScaleX()),\n-                Region.clipRound(bounds.height * tx.getScaleY())\n+                Region.clipRound(x * tx.getScaleX()),\n+                Region.clipRound(y * tx.getScaleY()),\n+                Region.clipRound(w * tx.getScaleX()),\n+                Region.clipRound(h * tx.getScaleY())\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/SunGraphicsEnvironment.java","additions":98,"deletions":26,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -466,1 +466,1 @@\n-                        dm.getWidth(), dm.getHeight());\n+                        screenBounds.width, screenBounds.height);\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/Win32GraphicsDevice.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -523,0 +523,1 @@\n+        var old = getGraphicsConfiguration().getDefaultTransform();\n@@ -524,0 +525,3 @@\n+        if (gc != null && !old.equals(gc.getDefaultTransform())) {\n+            syncBounds(); \/\/ the bounds of the peer depend on the DPI\n+        }\n@@ -532,0 +536,8 @@\n+    \/**\n+     * Make sure that the native peer's coordinates are in sync with the target.\n+     *\/\n+    void syncBounds() {\n+        Rectangle r = ((Component) target).getBounds();\n+        setBounds(r.x, r.y, r.width, r.height, SET_BOUNDS);\n+    }\n+\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WComponentPeer.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import static sun.java2d.SunGraphicsEnvironment.toUserSpace;\n+\n@@ -120,2 +122,2 @@\n-        return new Dimension(scaleDownX(getSysMinWidth()),\n-                             scaleDownY(getSysMinHeight()));\n+        return toUserSpace(getGraphicsConfiguration(),\n+                           getSysMinWidth(), getSysMinHeight());\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WDialogPeer.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,3 @@\n-import static sun.java2d.SunGraphicsEnvironment.convertToDeviceSpace;\n+import static sun.java2d.SunGraphicsEnvironment.getGCDeviceBounds;\n+import static sun.java2d.SunGraphicsEnvironment.toDeviceSpaceAbs;\n+import static sun.java2d.SunGraphicsEnvironment.toUserSpace;\n@@ -100,2 +102,1 @@\n-        bounds = convertToDeviceSpace(bounds);\n-\n+        bounds = toDeviceSpaceAbs(bounds);\n@@ -103,1 +104,1 @@\n-        Rectangle currentDevBounds = convertToDeviceSpace(gc, gc.getBounds());\n+        Rectangle currentDevBounds = getGCDeviceBounds(gc);\n@@ -151,0 +152,1 @@\n+        GraphicsConfiguration gc = getGraphicsConfiguration();\n@@ -153,2 +155,1 @@\n-            d.setSize(scaleDownX(getSysMinWidth()),\n-                      scaleDownY(getSysMinHeight()));\n+            d.setSize(toUserSpace(gc, getSysMinWidth(), getSysMinHeight()));\n@@ -156,2 +157,2 @@\n-        if (((Frame)target).getMenuBar() != null) {\n-            d.height += scaleDownY(getSysMenuHeight());\n+        if (((Frame) target).getMenuBar() != null) {\n+            d.height += toUserSpace(gc, 0, getSysMenuHeight()).height;\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WFramePeer.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import sun.java2d.SunGraphicsEnvironment;\n+import static sun.java2d.SunGraphicsEnvironment.toDeviceSpaceAbs;\n@@ -43,1 +43,1 @@\n-        Point point = SunGraphicsEnvironment.convertToDeviceSpace(x, y);\n+        Point point = toDeviceSpaceAbs(x, y);\n@@ -71,0 +71,5 @@\n+    @Override\n+    public boolean useAbsoluteCoordinates() {\n+        return true;\n+    }\n+\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WRobotPeer.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-import sun.java2d.SunGraphicsEnvironment;\n@@ -70,0 +69,2 @@\n+import static sun.java2d.SunGraphicsEnvironment.toUserSpace;\n+\n@@ -111,2 +112,0 @@\n-    private float scaleX;\n-    private float scaleY;\n@@ -225,2 +224,0 @@\n-        scaleX = gd.getDefaultScaleX();\n-        scaleY = gd.getDefaultScaleY();\n@@ -313,0 +310,6 @@\n+    @Override\n+    final void syncBounds() {\n+        \/\/ Windows will take care of the top-level window\/frame\/dialog, and\n+        \/\/ update the location\/size when DPI changes.\n+    }\n+\n@@ -441,3 +444,4 @@\n-            int w = Math.max(minimumSize.width, scaleDownX(getSysMinWidth()));\n-            int h = Math.max(minimumSize.height, scaleDownY(getSysMinHeight()));\n-            setMinSize(w, h);\n+            Dimension sysMin = toUserSpace(getGraphicsConfiguration(),\n+                                           getSysMinWidth(), getSysMinHeight());\n+            setMinSize(Math.max(minimumSize.width, sysMin.width),\n+                       Math.max(minimumSize.height, sysMin.height));\n@@ -601,15 +605,0 @@\n-\n-        checkDPIChange(oldDev, newDev);\n-    }\n-\n-    private void checkDPIChange(Win32GraphicsDevice oldDev,\n-                                Win32GraphicsDevice newDev) {\n-        float newScaleX = newDev.getDefaultScaleX();\n-        float newScaleY = newDev.getDefaultScaleY();\n-\n-        if (scaleX != newScaleX || scaleY != newScaleY) {\n-            windowDPIChange(oldDev.getScreen(), scaleX, scaleY,\n-                            newDev.getScreen(), newScaleX, newScaleY);\n-            scaleX = newScaleX;\n-            scaleY = newScaleY;\n-        }\n@@ -669,8 +658,0 @@\n-     \/\/ These are the peer bounds. They get updated at:\n-     \/\/    1. the WWindowPeer.setBounds() method.\n-     \/\/    2. the native code (on WM_SIZE\/WM_MOVE)\n-     private volatile int sysX = 0;\n-     private volatile int sysY = 0;\n-     private volatile int sysW = 0;\n-     private volatile int sysH = 0;\n-\n@@ -680,60 +661,0 @@\n-     @Override\n-     public void setBounds(int x, int y, int width, int height, int op) {\n-         sysX = x;\n-         sysY = y;\n-         sysW = width;\n-         sysH = height;\n-\n-         int cx = x + width \/ 2;\n-         int cy = y + height \/ 2;\n-         GraphicsConfiguration current = getGraphicsConfiguration();\n-         GraphicsConfiguration other = SunGraphicsEnvironment\n-                 .getGraphicsConfigurationAtPoint(current, cx, cy);\n-         if (!current.equals(other)) {\n-             AffineTransform tx = other.getDefaultTransform();\n-             double otherScaleX = tx.getScaleX();\n-             double otherScaleY = tx.getScaleY();\n-             initScales();\n-             if (scaleX != otherScaleX || scaleY != otherScaleY) {\n-                 x = (int) Math.floor(x * otherScaleX \/ scaleX);\n-                 y = (int) Math.floor(y * otherScaleY \/ scaleY);\n-             }\n-         }\n-\n-         super.setBounds(x, y, width, height, op);\n-     }\n-\n-    private void initScales() {\n-\n-        if (scaleX >= 1 && scaleY >= 1) {\n-            return;\n-        }\n-\n-        GraphicsConfiguration gc = getGraphicsConfiguration();\n-        if (gc instanceof Win32GraphicsConfig) {\n-            Win32GraphicsDevice gd = ((Win32GraphicsConfig) gc).getDevice();\n-            scaleX = gd.getDefaultScaleX();\n-            scaleY = gd.getDefaultScaleY();\n-        } else {\n-            AffineTransform tx = gc.getDefaultTransform();\n-            scaleX = (float) tx.getScaleX();\n-            scaleY = (float) tx.getScaleY();\n-        }\n-    }\n-\n-    final int scaleUpX(int x) {\n-        return Region.clipRound(x * scaleX);\n-    }\n-\n-    final int scaleUpY(int y) {\n-        return Region.clipRound(y * scaleY);\n-    }\n-\n-    final int scaleDownX(int x) {\n-        return Region.clipRound(x \/ scaleX);\n-    }\n-\n-    final int scaleDownY(int y) {\n-        return Region.clipRound(y \/ scaleY);\n-    }\n-\n@@ -908,3 +829,0 @@\n-    native void windowDPIChange(int prevScreen, float prevScaleX, float prevScaleY,\n-                                int newScreen, float newScaleX, float newScaleY);\n-\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WWindowPeer.java","additions":12,"deletions":94,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,2 +109,2 @@\n-    int x = (device == NULL) ? pt.x : device->ScaleDownX(pt.x);\n-    int y = (device == NULL) ? pt.y : device->ScaleDownY(pt.y);\n+    int x = (device == NULL) ? pt.x : device->ScaleDownAbsX(pt.x);\n+    int y = (device == NULL) ? pt.y : device->ScaleDownAbsY(pt.y);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/MouseInfo.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -606,1 +606,1 @@\n-    SetWindowPos(GetHWnd(), 0, x, y, w, h, SWP_NOZORDER | SWP_NOCOPYBITS | SWP_NOACTIVATE);\n+    Reshape(x, y, w, h);\n@@ -1090,0 +1090,1 @@\n+        WIN_MSG(WM_DPICHANGED)\n@@ -1508,1 +1509,1 @@\n-          \/\/ fix 4128317 : use GetClientRect for full 32-bit int precision and\n+          \/\/ fix 4128317 : use GetWindowRect for full 32-bit int precision and\n@@ -1510,1 +1511,1 @@\n-          ::GetClientRect( GetHWnd(), &r );\n+          ::GetWindowRect(GetHWnd(), &r);\n@@ -3891,2 +3892,2 @@\n-    int sx = ScaleUpX(x) - p.x;\n-    int sy = ScaleUpY(y) - p.y;\n+    int sx = ScaleUpAbsX(x) - p.x;\n+    int sy = ScaleUpAbsY(y) - p.y;\n@@ -4770,0 +4771,9 @@\n+int AwtComponent::GetScreenImOn() {\n+    HWND hWindow = GetAncestor(GetHWnd(), GA_ROOT);\n+    AwtComponent *comp = AwtComponent::GetComponent(hWindow);\n+    if (comp && comp->IsTopLevel()) {\n+        return comp->GetScreenImOn();\n+    }\n+    return AwtWin32GraphicsDevice::DeviceIndexForWindow(hWindow);\n+}\n+\n@@ -4771,1 +4781,1 @@\n-    int screen = AwtWin32GraphicsDevice::DeviceIndexForWindow(GetHWnd());\n+    int screen = GetScreenImOn();\n@@ -4777,0 +4787,7 @@\n+int AwtComponent::ScaleUpAbsX(int x) {\n+    int screen = GetScreenImOn();\n+    Devices::InstanceAccess devices;\n+    AwtWin32GraphicsDevice* device = devices->GetDevice(screen);\n+    return device == NULL ? x : device->ScaleUpAbsX(x);\n+}\n+\n@@ -4778,1 +4795,1 @@\n-    int screen = AwtWin32GraphicsDevice::DeviceIndexForWindow(GetHWnd());\n+    int screen = GetScreenImOn();\n@@ -4784,0 +4801,7 @@\n+int AwtComponent::ScaleUpAbsY(int y) {\n+    int screen = GetScreenImOn();\n+    Devices::InstanceAccess devices;\n+    AwtWin32GraphicsDevice* device = devices->GetDevice(screen);\n+    return device == NULL ? y : device->ScaleUpAbsY(y);\n+}\n+\n@@ -4785,1 +4809,1 @@\n-    int screen = AwtWin32GraphicsDevice::DeviceIndexForWindow(GetHWnd());\n+    int screen = GetScreenImOn();\n@@ -4791,0 +4815,7 @@\n+int AwtComponent::ScaleDownAbsX(int x) {\n+    int screen = GetScreenImOn();\n+    Devices::InstanceAccess devices;\n+    AwtWin32GraphicsDevice* device = devices->GetDevice(screen);\n+    return device == NULL ? x : device->ScaleDownAbsX(x);\n+}\n+\n@@ -4792,1 +4823,1 @@\n-    int screen = AwtWin32GraphicsDevice::DeviceIndexForWindow(GetHWnd());\n+    int screen = GetScreenImOn();\n@@ -4798,0 +4829,7 @@\n+int AwtComponent::ScaleDownAbsY(int y) {\n+    int screen = GetScreenImOn();\n+    Devices::InstanceAccess devices;\n+    AwtWin32GraphicsDevice* device = devices->GetDevice(screen);\n+    return device == NULL ? y : device->ScaleDownAbsY(y);\n+}\n+\n@@ -5093,1 +5131,1 @@\n-                                        ScaleDownX(xAbs), ScaleDownY(yAbs),\n+                                        ScaleDownAbsX(xAbs), ScaleDownAbsY(yAbs),\n@@ -5166,2 +5204,2 @@\n-                                             ScaleDownX(xAbs),\n-                                             ScaleDownY(yAbs),\n+                                             ScaleDownAbsX(xAbs),\n+                                             ScaleDownAbsY(yAbs),\n@@ -5677,2 +5715,2 @@\n-                                     p->ScaleDownX(rect.left),\n-                                     p->ScaleDownY(rect.top));\n+                                     p->ScaleDownAbsX(rect.left),\n+                                     p->ScaleDownAbsY(rect.top));\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Component.cpp","additions":52,"deletions":14,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -278,0 +278,1 @@\n+    virtual int GetScreenImOn();\n@@ -758,0 +759,1 @@\n+    int ScaleUpAbsX(int x);\n@@ -759,0 +761,1 @@\n+    int ScaleUpAbsY(int y);\n@@ -760,0 +763,1 @@\n+    int ScaleDownAbsX(int x);\n@@ -761,0 +765,1 @@\n+    int ScaleDownAbsY(int y);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Component.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -480,2 +480,2 @@\n-    int x = (device == NULL) ? p.x : device->ScaleDownX(p.x);\n-    int y = (device == NULL) ? p.y : device->ScaleDownY(p.y);\n+    int x = (device == NULL) ? p.x : device->ScaleDownAbsX(p.x);\n+    int y = (device == NULL) ? p.y : device->ScaleDownAbsY(p.y);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Cursor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1173,1 +1173,1 @@\n-static void ScaleDown(POINT &pt) {\n+static void ScaleDownAbs(POINT &pt) {\n@@ -1179,2 +1179,2 @@\n-        pt.x = device->ScaleDownX(pt.x);\n-        pt.y = device->ScaleDownY(pt.y);\n+        pt.x = device->ScaleDownAbsX(pt.x);\n+        pt.y = device->ScaleDownAbsY(pt.y);\n@@ -1189,1 +1189,1 @@\n-    ScaleDown(pt);\n+    ScaleDownAbs(pt);\n@@ -1202,1 +1202,1 @@\n-    ScaleDown(pt);\n+    ScaleDownAbs(pt);\n@@ -1215,1 +1215,1 @@\n-    ScaleDown(pt);\n+    ScaleDownAbs(pt);\n@@ -1228,1 +1228,1 @@\n-    ScaleDown(pt);\n+    ScaleDownAbs(pt);\n@@ -1241,1 +1241,1 @@\n-    ScaleDown(pt);\n+    ScaleDownAbs(pt);\n@@ -1254,1 +1254,1 @@\n-    ScaleDown(pt);\n+    ScaleDownAbs(pt);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_DnDDS.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -634,1 +634,1 @@\n-int ScaleDownX(int x, HWND hwnd) {\n+int ScaleDownAbsX(int x, HWND hwnd) {\n@@ -638,1 +638,1 @@\n-    return device == NULL ? x : device->ScaleDownX(x);\n+    return device == NULL ? x : device->ScaleDownAbsX(x);\n@@ -641,1 +641,1 @@\n-int ScaleDownY(int y, HWND hwnd) {\n+int ScaleDownAbsY(int y, HWND hwnd) {\n@@ -645,1 +645,1 @@\n-    return device == NULL ? y : device->ScaleDownY(y);\n+    return device == NULL ? y : device->ScaleDownAbsY(y);\n@@ -660,1 +660,2 @@\n-                       ScaleDownX(rect.left, hwnd), ScaleDownY(rect.top, hwnd));\n+                                     ScaleDownAbsX(rect.left, hwnd),\n+                                     ScaleDownAbsY(rect.top, hwnd));\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_FileDialog.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -331,1 +331,1 @@\n-                                  0, 0, 0, 0,\n+                                  x, y, width, height,\n@@ -337,5 +337,1 @@\n-                \/*\n-                 * Reshape here instead of during create, so that a\n-                 * WM_NCCALCSIZE is sent.\n-                 *\/\n-                frame->Reshape(x, y, width, height);\n+                frame->RecalcNonClient();\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Frame.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -291,2 +291,1 @@\n-    CreateHWnd(env, L\"\", style, exStyle,\n-               rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,\n+    CreateHWnd(env, L\"\", style, exStyle, 0, 0, 0, 0,\n@@ -298,0 +297,4 @@\n+\n+    SetWindowPos(GetHWnd(), 0,\n+            rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,\n+            SWP_NOZORDER | SWP_NOCOPYBITS | SWP_NOACTIVATE);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_List.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,3 +102,0 @@\n-\n-            int x = (device == NULL) ? rRW.left : device->ScaleDownX(rRW.left);\n-            int y = (device == NULL) ? rRW.top  : device->ScaleDownY(rRW.top);\n@@ -110,2 +107,1 @@\n-            bounds = env->NewObject(clazz, mid, x, y, w, h);\n-\n+            bounds = env->NewObject(clazz, mid, rRW.left, rRW.top, w, h);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Win32GraphicsConfig.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+    disableScaleAutoRefresh = FALSE;\n@@ -636,0 +637,6 @@\n+int AwtWin32GraphicsDevice::ScaleUpAbsX(int x)\n+{\n+    LONG screen = pMonitorInfo->rcMonitor.left;\n+    return screen + ClipRound((x - screen) * scaleX);\n+}\n+\n@@ -641,0 +648,6 @@\n+int AwtWin32GraphicsDevice::ScaleUpAbsY(int y)\n+{\n+    LONG screen = pMonitorInfo->rcMonitor.top;\n+    return screen + ClipRound((y - screen) * scaleY);\n+}\n+\n@@ -646,0 +659,6 @@\n+int AwtWin32GraphicsDevice::ScaleDownAbsX(int x)\n+{\n+    LONG screen = pMonitorInfo->rcMonitor.left;\n+    return screen + ClipRound((x - screen) \/ scaleX);\n+}\n+\n@@ -651,0 +670,6 @@\n+int AwtWin32GraphicsDevice::ScaleDownAbsY(int y)\n+{\n+    LONG screen = pMonitorInfo->rcMonitor.top;\n+    return screen + ClipRound((y - screen) \/ scaleY);\n+}\n+\n@@ -669,5 +694,7 @@\n-    float dpiX = -1.0f;\n-    float dpiY = -1.0f;\n-    GetScreenDpi(GetMonitor(), &dpiX, &dpiY);\n-    if (dpiX > 0 && dpiY > 0) {\n-        SetScale(dpiX \/ 96, dpiY \/ 96);\n+    if (!disableScaleAutoRefresh) {\n+        float dpiX = -1.0f;\n+        float dpiY = -1.0f;\n+        GetScreenDpi(GetMonitor(), &dpiX, &dpiY);\n+        if (dpiX > 0 && dpiY > 0) {\n+            SetScale(dpiX \/ 96, dpiY \/ 96);\n+        }\n@@ -697,0 +724,5 @@\n+void AwtWin32GraphicsDevice::DisableScaleAutoRefresh()\n+{\n+    disableScaleAutoRefresh = TRUE;\n+}\n+\n@@ -757,0 +789,15 @@\n+\/**\n+ * This function updates the scale factor for all monitors on the system.\n+ *\/\n+void AwtWin32GraphicsDevice::ResetAllDesktopScales()\n+{\n+    if (!Devices::GetInstance()){\n+        return;\n+    }\n+    Devices::InstanceAccess devices;\n+    int devicesNum = devices->GetNumDevices();\n+    for (int deviceIndex = 0; deviceIndex < devicesNum; deviceIndex++) {\n+        devices->GetDevice(deviceIndex)->InitDesktopScales();\n+    }\n+}\n+\n@@ -1396,0 +1443,1 @@\n+        device->DisableScaleAutoRefresh();\n@@ -1444,1 +1492,0 @@\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Win32GraphicsDevice.cpp","additions":53,"deletions":6,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+    void                    DisableScaleAutoRefresh();\n@@ -74,0 +75,1 @@\n+    int                     ScaleUpAbsX(int x);\n@@ -75,0 +77,1 @@\n+    int                     ScaleUpAbsY(int x);\n@@ -76,0 +79,1 @@\n+    int                     ScaleDownAbsX(int x);\n@@ -77,0 +81,1 @@\n+    int                     ScaleDownAbsY(int y);\n@@ -91,0 +96,1 @@\n+    static void             ResetAllDesktopScales();\n@@ -120,0 +126,1 @@\n+    BOOL                    disableScaleAutoRefresh;\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Win32GraphicsDevice.h","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -156,11 +156,0 @@\n-\/\/ struct for _WindowDPIChange() method\n-struct ScaleStruct {\n-    jobject window;\n-    jint prevScreen;\n-    jfloat prevScaleX;\n-    jfloat prevScaleY;\n-    jint screen;\n-    jfloat scaleX;\n-    jfloat scaleY;\n-};\n-\n@@ -182,4 +171,0 @@\n-jfieldID AwtWindow::sysXID;\n-jfieldID AwtWindow::sysYID;\n-jfieldID AwtWindow::sysWID;\n-jfieldID AwtWindow::sysHID;\n@@ -1131,0 +1116,5 @@\n+            jint x = env->GetIntField(target, AwtComponent::xID);\n+            jint y = env->GetIntField(target, AwtComponent::yID);\n+            jint width = env->GetIntField(target, AwtComponent::widthID);\n+            jint height = env->GetIntField(target, AwtComponent::heightID);\n+\n@@ -1133,1 +1123,1 @@\n-                               0, 0, 0, 0,\n+                               x, y, width, height,\n@@ -1139,6 +1129,0 @@\n-\n-            jint x = env->GetIntField(target, AwtComponent::xID);\n-            jint y = env->GetIntField(target, AwtComponent::yID);\n-            jint width = env->GetIntField(target, AwtComponent::widthID);\n-            jint height = env->GetIntField(target, AwtComponent::heightID);\n-\n@@ -1154,7 +1138,1 @@\n-\n-\n-            \/*\n-             * Reshape here instead of during create, so that a WM_NCCALCSIZE\n-             * is sent.\n-             *\/\n-            window->Reshape(x, y, width, height);\n+            window->RecalcNonClient();\n@@ -1218,0 +1196,42 @@\n+\/**\n+ * Override AwtComponent::Reshape() to handle absolute screen coordinates used\n+ * by the top-level windows.\n+ *\/\n+void AwtWindow::Reshape(int x, int y, int w, int h) {\n+    if (IsEmbeddedFrame()) {\n+        \/\/ Not the \"real\" top level window\n+        return AwtComponent::Reshape(x, y, w, h);\n+    }\n+    \/\/ Yes, use x,y in user's space to find the nearest monitor in device space.\n+    POINT pt = {x + w \/ 2, y + h \/ 2};\n+    Devices::InstanceAccess devices;\n+    HMONITOR monitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);\n+    int screen = AwtWin32GraphicsDevice::GetScreenFromHMONITOR(monitor);\n+    AwtWin32GraphicsDevice *device = devices->GetDevice(screen);\n+    \/\/ Try to set the correct size and jump to the correct location, even if it is\n+    \/\/ on the different monitor. Note that for the \"size\" we use the current\n+    \/\/ monitor, so the WM_DPICHANGED will adjust it for the \"target\" monitor.\n+    int scaleUpAbsX = device == NULL ? x : device->ScaleUpAbsX(x);\n+    int scaleUpAbsY = device == NULL ? y : device->ScaleUpAbsY(y);\n+    ReshapeNoScale(scaleUpAbsX, scaleUpAbsY, ScaleUpX(w), ScaleUpY(h));\n+    \/\/ The window manager may tweak the size for different reasons, so try\n+    \/\/ to make sure our window has the correct size in the user's space.\n+    \/\/ NOOP if the size was changed already or changing is in progress.\n+    RECT rc;\n+    ::GetWindowRect(GetHWnd(), &rc);\n+    ReshapeNoScale(rc.left, rc.top, ScaleUpX(w), ScaleUpY(h));\n+    \/\/ the window manager may ignore our \"SetWindowPos\" request, in this,\n+    \/\/ case the WmMove\/WmSize will not come and we need to manually resync\n+    \/\/ the \"java.awt.Window\" locations, because \"java.awt.Window\" already\n+    \/\/ uses location ignored by the window manager.\n+    ::GetWindowRect(GetHWnd(), &rc);\n+    if (x != ScaleDownAbsX(rc.left) || y != ScaleDownAbsY(rc.top)) {\n+        WmMove(rc.left, rc.top);\n+    }\n+    int userW = ScaleDownX(rc.right - rc.left);\n+    int userH = ScaleDownY(rc.bottom - rc.top);\n+    if (w != userW || h != userH) {\n+        WmSize(SIZENORMAL, rc.right - rc.left, rc.bottom - rc.top);\n+    }\n+}\n+\n@@ -1777,0 +1797,9 @@\n+void AwtWindow::WmDPIChanged(const LPARAM &lParam) {\n+    \/\/ need to update the scales now, otherwise the ReshapeNoScale() will\n+    \/\/ calculate the bounds wrongly\n+    AwtWin32GraphicsDevice::ResetAllDesktopScales();\n+    RECT *r = (RECT *) lParam;\n+    ReshapeNoScale(r->left, r->top, r->right - r->left, r->bottom - r->top);\n+    CheckIfOnNewScreen(true);\n+}\n+\n@@ -1792,8 +1821,2 @@\n-\n-    if (m_screenNum == -1) {\n-    \/\/ Set initial value\n-        m_screenNum = GetScreenImOn();\n-    }\n-    else {\n-        CheckIfOnNewScreen();\n-    }\n+    \/\/ Check for the new screen and update the java peer\n+    CheckIfOnNewScreen(false); \/\/ postpone if different DPI\n@@ -1806,2 +1829,1 @@\n-    jobject peer = GetPeer(env);\n-    jobject target = env->GetObjectField(peer, AwtObject::targetID);\n+    jobject target = GetTarget(env);\n@@ -1812,4 +1834,2 @@\n-    (env)->SetIntField(target, AwtComponent::xID, ScaleDownX(rect.left));\n-    (env)->SetIntField(target, AwtComponent::yID, ScaleDownY(rect.top));\n-    (env)->SetIntField(peer, AwtWindow::sysXID, ScaleDownX(rect.left));\n-    (env)->SetIntField(peer, AwtWindow::sysYID, ScaleDownY(rect.top));\n+    (env)->SetIntField(target, AwtComponent::xID, ScaleDownAbsX(rect.left));\n+    (env)->SetIntField(target, AwtComponent::yID, ScaleDownAbsY(rect.top));\n@@ -1860,0 +1880,9 @@\n+    \/\/ Below is a workaround, see CheckWindowDPIChange\n+    Devices::InstanceAccess devices;\n+    AwtWin32GraphicsDevice* device = devices->GetDevice(m_screenNum);\n+    if (device) {\n+        prevScaleRec.screen = m_screenNum;\n+        prevScaleRec.scaleX = device->GetScaleX();\n+        prevScaleRec.scaleY = device->GetScaleY();\n+    }\n+    \/\/ Above is a workaround\n@@ -1866,1 +1895,1 @@\n-    CheckWindowDPIChange();\n+    CheckWindowDPIChange(); \/\/ workaround\n@@ -1883,0 +1912,2 @@\n+    \/\/ Check for the new screen and update the java peer\n+    CheckIfOnNewScreen(false); \/\/ postpone if different DPI\n@@ -1890,9 +1921,2 @@\n-    int newWidth = w + m_insets.left + m_insets.right;\n-    int newHeight = h + m_insets.top + m_insets.bottom;\n-\n-    (env)->SetIntField(target, AwtComponent::widthID, ScaleDownX(newWidth));\n-    (env)->SetIntField(target, AwtComponent::heightID, ScaleDownY(newHeight));\n-\n-    jobject peer = GetPeer(env);\n-    (env)->SetIntField(peer, AwtWindow::sysWID, ScaleDownX(newWidth));\n-    (env)->SetIntField(peer, AwtWindow::sysHID, ScaleDownY(newHeight));\n+    (env)->SetIntField(target, AwtComponent::widthID, ScaleDownX(w));\n+    (env)->SetIntField(target, AwtComponent::heightID, ScaleDownY(h));\n@@ -1980,0 +2004,5 @@\n+        case WM_DPICHANGED: {\n+            WmDPIChanged(lParam);\n+            mr = mrConsume;\n+            break;\n+        }\n@@ -2123,1 +2152,2 @@\n-\/* Check to see if we've been moved onto another screen.\n+\/*\n+ * Check to see if we've been moved onto another screen.\n@@ -2126,2 +2156,1 @@\n-\n-void AwtWindow::CheckIfOnNewScreen() {\n+void AwtWindow::CheckIfOnNewScreen(BOOL force) {\n@@ -2131,0 +2160,14 @@\n+        \/\/ if moved from one monitor to another with different DPI, we should\n+        \/\/ update the m_screenNum only if the size was updated as well in the\n+        \/\/ WM_DPICHANGED.\n+        Devices::InstanceAccess devices;\n+        AwtWin32GraphicsDevice* oldDevice = devices->GetDevice(m_screenNum);\n+        AwtWin32GraphicsDevice* newDevice = devices->GetDevice(curScrn);\n+        if (!force && m_winSizeMove && oldDevice && newDevice) {\n+            if (oldDevice->GetScaleX() != newDevice->GetScaleX()\n+                    || oldDevice->GetScaleY() != newDevice->GetScaleY()) {\n+                \/\/ scales are different, wait for WM_DPICHANGED\n+                return;\n+            }\n+        }\n+\n@@ -2152,0 +2195,4 @@\n+\/\/ The shared code is not ready to the top-level window which crosses a few\n+\/\/ monitors with different DPI. Popup windows will start to use wrong screen,\n+\/\/ will be placed in the wrong place and will use the wrong size, see 8249164\n+\/\/ So we will \"JUMP TO\" the new screen.\n@@ -2153,43 +2200,1 @@\n-\n-    if (prevScaleRec.screen != -1 ) {\n-        float prevScaleX = prevScaleRec.scaleX;\n-        float prevScaleY = prevScaleRec.scaleY;\n-\n-        if (prevScaleX >= 1 && prevScaleY >= 1) {\n-            Devices::InstanceAccess devices;\n-            AwtWin32GraphicsDevice* device = devices->GetDevice(m_screenNum);\n-            if (device) {\n-                float scaleX = device->GetScaleX();\n-                float scaleY = device->GetScaleY();\n-                if (prevScaleX != scaleX || prevScaleY != scaleY) {\n-                    WindowDPIChange(prevScaleRec.screen, prevScaleX, prevScaleY,\n-                                    m_screenNum, scaleX, scaleY);\n-                }\n-            }\n-        }\n-        prevScaleRec.screen = -1;\n-    }\n-}\n-\n-void AwtWindow::WindowDPIChange(int prevScreen,\n-                                float prevScaleX, float prevScaleY,\n-                                int screen, float scaleX,\n-                                float scaleY)\n-{\n-    int x;\n-    int y;\n-    int w;\n-    int h;\n-    RECT rect;\n-\n-    if (prevScaleX == scaleX && prevScaleY == scaleY) {\n-        return;\n-    }\n-\n-    ::GetWindowRect(GetHWnd(), &rect);\n-    x = rect.left;\n-    y = rect.top;\n-    w = (rect.right - rect.left) * scaleX \/ prevScaleX;\n-    h = (rect.bottom - rect.top) * scaleY \/ prevScaleY;\n-\n-    if (prevScreen != screen) {\n+    if (prevScaleRec.screen != -1 && prevScaleRec.screen != m_screenNum) {\n@@ -2197,1 +2202,1 @@\n-        AwtWin32GraphicsDevice* device = devices->GetDevice(screen);\n+        AwtWin32GraphicsDevice *device = devices->GetDevice(m_screenNum);\n@@ -2199,7 +2204,16 @@\n-            RECT bounds;\n-            if (MonitorBounds(device->GetMonitor(), &bounds)) {\n-                x = x < bounds.left ? bounds.left : x;\n-                y = y < bounds.top ? bounds.top : y;\n-\n-                x = (x + w > bounds.right) ? bounds.right - w : x;\n-                y = (y + h > bounds.bottom) ? bounds.bottom - h : y;\n+            if (prevScaleRec.scaleX != device->GetScaleX()\n+                    || prevScaleRec.scaleY != device->GetScaleY()) {\n+                RECT rect;\n+                ::GetWindowRect(GetHWnd(), &rect);\n+                int x = rect.left;\n+                int y = rect.top;\n+                int w = rect.right - rect.left;\n+                int h = rect.bottom - rect.top;\n+                RECT bounds;\n+                if (MonitorBounds(device->GetMonitor(), &bounds)) {\n+                    x = x < bounds.left ? bounds.left : x;\n+                    y = y < bounds.top ? bounds.top : y;\n+                    x = (x + w > bounds.right) ? bounds.right - w : x;\n+                    y = (y + h > bounds.bottom) ? bounds.bottom - h : y;\n+                }\n+                ReshapeNoScale(x, y, w, h);\n@@ -2208,0 +2222,3 @@\n+        prevScaleRec.screen = -1;\n+        prevScaleRec.scaleX = -1.0f;\n+        prevScaleRec.scaleY = -1.0f;\n@@ -2209,2 +2226,0 @@\n-\n-    ReshapeNoScale(x, y, w, h);\n@@ -2585,2 +2600,0 @@\n-                    env->SetIntField(peer, AwtWindow::sysWID,\n-                        w);\n@@ -2592,2 +2605,0 @@\n-                    env->SetIntField(peer, AwtWindow::sysHID,\n-                        h);\n@@ -3260,33 +3271,0 @@\n-void AwtWindow::_WindowDPIChange(void* param)\n-{\n-    JNIEnv *env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);\n-\n-    ScaleStruct *ss = (ScaleStruct *)param;\n-    jobject self = ss->window;\n-    jint prevScreen = ss->prevScreen;\n-    jfloat prevScaleX = ss->prevScaleX;\n-    jfloat prevScaleY = ss->prevScaleY;\n-    jint screen = ss->screen;\n-    jfloat scaleX = ss->scaleX;\n-    jfloat scaleY = ss->scaleY;\n-\n-    PDATA pData;\n-    JNI_CHECK_PEER_GOTO(self, ret);\n-    AwtWindow *window = (AwtWindow *)pData;\n-\n-    if (window->m_winSizeMove) {\n-        if (window->prevScaleRec.screen == -1) {\n-            window->prevScaleRec.screen = prevScreen;\n-            window->prevScaleRec.scaleX = prevScaleX;\n-            window->prevScaleRec.scaleY = prevScaleY;\n-        }\n-    }\n-    else {\n-        window->WindowDPIChange(prevScreen, prevScaleX, prevScaleY,\n-                                screen, scaleX, scaleY);\n-    }\n-\n-ret:\n-    env->DeleteGlobalRef(self);\n-    delete ss;\n-}\n@@ -3350,5 +3328,0 @@\n-    CHECK_NULL(AwtWindow::sysXID = env->GetFieldID(cls, \"sysX\", \"I\"));\n-    CHECK_NULL(AwtWindow::sysYID = env->GetFieldID(cls, \"sysY\", \"I\"));\n-    CHECK_NULL(AwtWindow::sysWID = env->GetFieldID(cls, \"sysW\", \"I\"));\n-    CHECK_NULL(AwtWindow::sysHID = env->GetFieldID(cls, \"sysH\", \"I\"));\n-\n@@ -3994,27 +3967,0 @@\n-\/*\n-* Class:     sun_awt_windows_WWindowPeer\n-* Method:    windowDPIChange\n-* Signature: (IFFIFF)V\n-*\/\n-JNIEXPORT void JNICALL\n-Java_sun_awt_windows_WWindowPeer_windowDPIChange(JNIEnv *env, jobject self,\n-    jint prevScreen, jfloat prevScaleX, jfloat prevScaleY,\n-    jint screen, jfloat scaleX, jfloat scaleY)\n-{\n-    TRY;\n-\n-    ScaleStruct *ss = new ScaleStruct;\n-    ss->window = env->NewGlobalRef(self);\n-    ss->prevScreen = prevScreen;\n-    ss->prevScaleX = prevScaleX;\n-    ss->prevScaleY = prevScaleY;\n-    ss->screen = screen;\n-    ss->scaleX = scaleX;\n-    ss->scaleY = scaleY;\n-\n-    AwtToolkit::GetInstance().InvokeFunction(AwtWindow::_WindowDPIChange, ss);\n-    \/\/ global refs and ss are deleted in _WindowDPIChange\n-\n-    CATCH_BAD_ALLOC;\n-}\n-\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Window.cpp","additions":124,"deletions":178,"binary":false,"changes":302,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,6 +61,0 @@\n-    \/\/ The coordinates at the peer.\n-    static jfieldID sysXID;\n-    static jfieldID sysYID;\n-    static jfieldID sysWID;\n-    static jfieldID sysHID;\n-\n@@ -132,0 +126,1 @@\n+    virtual void Reshape(int x, int y, int w, int h);\n@@ -139,1 +134,1 @@\n-    virtual void CheckIfOnNewScreen();\n+    virtual void CheckIfOnNewScreen(BOOL force);\n@@ -251,1 +246,0 @@\n-    static void _WindowDPIChange(void* param);\n@@ -412,2 +406,1 @@\n-    void WindowDPIChange(int prevScreen, float prevScaleX, float prevScaleY,\n-                         int newScreen, float scaleX, float scaleY);\n+    void WmDPIChanged(const LPARAM &lParam);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Window.h","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,4 @@\n+#ifndef WM_DPICHANGED\n+#define WM_DPICHANGED                   0x02E0\n+#endif \/\/WM_DPICHANGED\n+\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awtmsg.h","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Canvas;\n+import java.awt.Checkbox;\n+import java.awt.Choice;\n+import java.awt.Component;\n+import java.awt.Frame;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Label;\n+import java.awt.List;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.ScrollPane;\n+import java.awt.Scrollbar;\n+import java.awt.TextArea;\n+import java.awt.TextField;\n+import java.awt.Window;\n+\n+\/**\n+ * @test\n+ * @key headful\n+ * @bug 8211999\n+ * @run main\/othervm SetComponentsBounds\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 SetComponentsBounds\n+ * @run main\/othervm -Dsun.java2d.uiScale=2.25 SetComponentsBounds\n+ *\/\n+public final class SetComponentsBounds {\n+\n+    private static final int X = 111;\n+    private static final int Y = 222;\n+    private static final int WIDTH = 321;\n+    private static final int HEIGHT = 123;\n+\n+    public static void main(String[] args) throws Exception {\n+        var ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        for (GraphicsDevice gd : ge.getScreenDevices()) {\n+            test(gd.getDefaultConfiguration(), true);\n+            test(gd.getDefaultConfiguration(), false);\n+        }\n+    }\n+\n+    private static void test(GraphicsConfiguration gc, boolean visible) throws Exception {\n+        Rectangle screen = gc.getBounds();\n+        Window frame = new Frame();\n+        try {\n+            frame.setLayout(null); \/\/ trigger use the minimum size of\n+                                   \/\/ the peer\n+            frame.setBounds(screen.x + 100, screen.y + 100, 500, 500);\n+            frame.add(new Button());\n+            frame.add(new Canvas());\n+            frame.add(new Checkbox());\n+            frame.add(new Choice());\n+            frame.add(new Label());\n+            frame.add(new List());\n+            frame.add(new Scrollbar());\n+            frame.add(new ScrollPane());\n+            frame.add(new TextArea());\n+            frame.add(new TextField());\n+            for (Component comp : frame.getComponents()) {\n+                comp.setBounds(X, Y, WIDTH, HEIGHT);\n+            }\n+            if (visible) {\n+                frame.setVisible(true);\n+            } else {\n+                frame.pack();\n+            }\n+            Robot robot = new Robot();\n+            robot.waitForIdle();\n+            checkGC(gc, frame);\n+            for (Component comp : frame.getComponents()) {\n+                Rectangle bounds = comp.getBounds();\n+                if (bounds.x != X || bounds.y != Y || bounds.width != WIDTH) {\n+                    System.err.println(\"Screen bounds:\" + screen);\n+                    System.err.println(\"Component:\" + comp);\n+                    throw new RuntimeException(\"Wrong bounds:\" + bounds);\n+                }\n+                if (bounds.height > HEIGHT) {\n+                    \/\/ different check for HEIGHT, it depends on the font\n+                    throw new RuntimeException(\"Wrong height:\" + bounds.height);\n+                }\n+                checkGC(gc, comp);\n+            }\n+        } finally {\n+            frame.dispose();\n+        }\n+    }\n+\n+    private static void checkGC(GraphicsConfiguration gc, Component comp) {\n+        GraphicsConfiguration compGC = comp.getGraphicsConfiguration();\n+        if (compGC != gc) {\n+            System.err.println(\"Expected GC:\" + gc);\n+            System.err.println(\"Actual GC:\" + compGC);\n+            throw new RuntimeException();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Component\/SetComponentsBounds\/SetComponentsBounds.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 6345003 8171363\n+ * @bug 6345003 8171363 8211999\n@@ -70,0 +70,1 @@\n+        frame.setLocationRelativeTo(null);\n@@ -91,0 +92,1 @@\n+        embedded_frame.setBounds(0, 0, 150, 150);\n","filename":"test\/jdk\/java\/awt\/EmbeddedFrame\/EmbeddedFrameGrabTest\/EmbeddedFrameGrabTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.awt.Dimension;\n@@ -33,1 +34,1 @@\n- * @bug 8176359 8231564\n+ * @bug 8176359 8231564 8211999\n@@ -61,2 +62,0 @@\n-                Rectangle maxTo = gd2.getDefaultConfiguration().getBounds();\n-                maxTo.grow(-maxTo.width \/ 2 + 120, -maxTo.height \/ 2 + 120);\n@@ -65,0 +64,2 @@\n+                    frame.setLayout(null); \/\/ trigger use the minimum size of\n+                                           \/\/ the peer\n@@ -66,0 +67,1 @@\n+\n@@ -70,0 +72,7 @@\n+                    Dimension minimumSize = frame.getMinimumSize();\n+                    minimumSize.width = Math.max(minimumSize.width, 120);\n+                    minimumSize.height = Math.max(minimumSize.height, 120);\n+                    Rectangle maxTo = gd2.getDefaultConfiguration().getBounds();\n+                    maxTo.grow(-maxTo.width \/ 2 + minimumSize.width,\n+                               -maxTo.height \/ 2 + minimumSize.height);\n+\n","filename":"test\/jdk\/java\/awt\/Frame\/MaximizedToOppositeScreen\/MaximizedToOppositeScreenSmall.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.DisplayMode;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Rectangle;\n+\n+\/**\n+ * @test\n+ * @bug 8211999\n+ * @key headful\n+ * @summary verifies the full-screen window bounds and graphics configuration\n+ *\/\n+public final class FullscreenWindowProps {\n+\n+    public static void main(String[] args) throws Exception {\n+        var ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        GraphicsDevice gd = ge.getDefaultScreenDevice();\n+\n+        if (!gd.isFullScreenSupported()) {\n+            return;\n+        }\n+\n+        Frame frame = new Frame() {\n+            @Override\n+            public void paint(Graphics g) {\n+                super.paint(g);\n+                g.setColor(Color.GREEN);\n+                g.fillRect(0, 0, getWidth(), getHeight());\n+            }\n+        };\n+        try {\n+            frame.setBackground(Color.MAGENTA);\n+            frame.setVisible(true);\n+            gd.setFullScreenWindow(frame);\n+            Thread.sleep(4000);\n+\n+            for (DisplayMode dm : gd.getDisplayModes()) {\n+                if (dm.getWidth() == 1024 && dm.getHeight() == 768) {\n+                    gd.setDisplayMode(dm);\n+                    Thread.sleep(4000);\n+                    break;\n+                }\n+            }\n+\n+            GraphicsConfiguration frameGC = frame.getGraphicsConfiguration();\n+            Rectangle frameBounds = frame.getBounds();\n+\n+            GraphicsConfiguration screenGC = gd.getDefaultConfiguration();\n+            Rectangle screenBounds = screenGC.getBounds();\n+\n+            if (frameGC != screenGC) {\n+                System.err.println(\"Expected: \" + screenGC);\n+                System.err.println(\"Actual: \" + frameGC);\n+                throw new RuntimeException();\n+            }\n+\n+            checkSize(frameBounds.x, screenBounds.x, \"x\");\n+            checkSize(frameBounds.y, screenBounds.y, \"Y\");\n+            checkSize(frameBounds.width, screenBounds.width, \"width\");\n+            checkSize(frameBounds.height, screenBounds.height, \"height\");\n+        } finally {\n+            gd.setFullScreenWindow(null);\n+            frame.dispose();\n+            Thread.sleep(10000);\n+        }\n+    }\n+\n+    private static void checkSize(int actual, int expected, String prop) {\n+        if (Math.abs(actual - expected) > 30) { \/\/ let's allow size variation,\n+                                                \/\/ the bug is reproduced anyway\n+            System.err.println(\"Expected: \" + expected);\n+            System.err.println(\"Actual: \" + actual);\n+            throw new RuntimeException(prop + \" is wrong\");\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/awt\/FullScreen\/FullscreenWindowProps\/FullscreenWindowProps.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.List;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+\n+\/**\n+ * @test\n+ * @bug 4909485 8211999\n+ * @key headful\n+ *\/\n+public final class ListMultipleSelectTest {\n+\n+    private static List aList;\n+    private static Panel panel;\n+    private static Point p;\n+    private static Robot robot;\n+    private static int[] selected;\n+\n+    public static void main(String[] args) throws Exception {\n+        Frame frame = new Frame();\n+        try {\n+            panel = new Panel();\n+            aList = new List();\n+            aList.add(\"Test item1\");\n+            aList.add(\"Test item2\");\n+            aList.add(\"Test item3\");\n+            aList.add(\"Test item4\");\n+\n+            frame.setLayout(new FlowLayout()); \/\/list should fill whole frame's space\n+            panel.add(aList);\n+            frame.setSize(200, 200);\n+            frame.setLocationRelativeTo(null);\n+            panel.setVisible(true);\n+            frame.add(panel);\n+            frame.setVisible(true);\n+            try {\n+                Thread.sleep(1000);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\" InterruptedException. Test failed. \");\n+            }\n+\n+            Dimension listSize = aList.getSize();\n+            p = aList.getLocationOnScreen();\n+            int stepY = listSize.height \/ aList.getItemCount();\n+\n+\/\/          System.out.println(\"itemCount = \"+aList.getItemCount());\n+\/\/          System.out.println(\"Size Of aList=\"+ listSize);\n+\/\/          System.out.println(\"stepY = \"+stepY);\n+\/\/          System.out.println(\"Point:\" +p);\n+            System.out.println(\"Multiple mode is ON\");\n+            aList.setMultipleMode(true);\n+\/\/=================================================\n+            robot = new Robot();\n+            robot.setAutoDelay(0);\n+            robot.setAutoWaitForIdle(false);\n+            robot.delay(10);\n+            robot.waitForIdle();\n+\n+\/\/=================================================\n+\n+            for (int i = 0; i < aList.getItemCount(); i++) {\n+                \/\/select all items in the List\n+                mousePress(p.x + listSize.width \/ 2, p.y + stepY \/ 2 + stepY * i);\n+            }\n+\n+            selected = aList.getSelectedIndexes();\n+            System.out.println(\"Multiple mode is ON\");\n+            aList.setMultipleMode(true);\n+            int[] newSelected = aList.getSelectedIndexes();\n+            if (!java.util.Arrays.equals(newSelected, selected)) {\n+                throw new RuntimeException(\" Incorrect item remains selected \" +\n+                        \"after setMultipleMode(true). \");\n+            }\n+\n+            aList.setMultipleMode(false);\n+            System.out.println(\"Multiple mode is OFF\");\n+            selected = aList.getSelectedIndexes();\n+            if (selected[0] != 3 || selected.length != 1) {\n+                throw new RuntimeException(\" Incorrect item remains selected \" +\n+                        \"after setMultipleMode(false) or it is more then one \" +\n+                        \"item remaining.Forward. \");\n+            }\n+\n+            System.out.println(\"Multiple mode is ON\");\n+            aList.setMultipleMode(true);\n+\n+            if (selected[0] != 3 || selected.length != 1) {\n+                throw new RuntimeException(\" Incorrect item remains selected \" +\n+                        \"after setMultipleMode(true) or it is more then one \" +\n+                        \"item remaining. \");\n+            }\n+\n+            deselectAll();\n+            for (int i = aList.getItemCount() - 1; i >= 0; i--) {\n+                mousePress(p.x + listSize.width \/ 2, p.y + stepY \/ 2 + stepY * i);\n+            }\n+\n+            System.out.println(\"Multiple mode is OFF\");\n+            aList.setMultipleMode(false);\n+\n+            selected = aList.getSelectedIndexes();\n+            if (selected[0] != 0 || selected.length != 1) {\n+                throw new RuntimeException(\" Incorrect item remains selected \" +\n+                        \"after setMultipleMode(false) or it is more then one \" +\n+                        \"item remaining.Backward. \");\n+            }\n+            System.out.println(\"Test succeeded.\");\n+        } finally {\n+            frame.dispose();\n+        }\n+    }\n+\n+    private static void mousePress(int x, int y) {\n+        robot.mouseMove(x, y);\n+        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+        robot.delay(1000);\n+    }\n+\n+    private static void deselectAll() {\n+        for (int i = 0; i < selected.length; i++) {\n+            aList.deselect(selected[i]);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/List\/ListMultipleSelectTest\/ListMultipleSelectTest.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n-  @bug 8017472\n+  @bug 8017472 8211999\n","filename":"test\/jdk\/java\/awt\/Multiscreen\/MouseEventTest\/MouseEventTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n@@ -41,1 +43,1 @@\n- * @bug 8215105\n+ * @bug 8215105 8211999\n@@ -51,4 +53,7 @@\n-        try {\n-            test();\n-        } finally {\n-            frame.dispose();\n+        var ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        for (GraphicsDevice gd : ge.getScreenDevices()) {\n+            try {\n+                test(gd.getDefaultConfiguration().getBounds());\n+            } finally {\n+                frame.dispose();\n+            }\n@@ -58,1 +63,1 @@\n-    private static void test() {\n+    private static void test(Rectangle screen) {\n@@ -60,1 +65,2 @@\n-        frame.setLocationRelativeTo(null);\n+        frame.setLocation((int)screen.getCenterX() - 200,\n+                          (int)screen.getCenterY() - 200);\n@@ -72,1 +78,2 @@\n-            checkPixels(color);\n+            checkPixels(color, true);\n+            checkPixels(color, false);\n@@ -76,1 +83,2 @@\n-    private static void checkPixels(final Color color) {\n+    private static void checkPixels(final Color color, boolean useRect) {\n+        System.out.println(\"color = \" + color + \", useRect = \" + useRect);\n@@ -81,1 +89,8 @@\n-            Color pixel = robot.getPixelColor(p.x, p.y);\n+            Color pixel;\n+            Rectangle rect = new Rectangle(p.x, p.y, 1, 1);\n+            if (useRect) {\n+                BufferedImage bi = robot.createScreenCapture(rect);\n+                pixel = new Color(bi.getRGB(0, 0));\n+            } else {\n+                pixel = robot.getPixelColor(rect.x, rect.y);\n+            }\n","filename":"test\/jdk\/java\/awt\/Robot\/CheckCommonColors\/CheckCommonColors.java","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @bug 8201364 8232433\n+ * @bug 8201364 8232433 8211999\n@@ -67,0 +67,1 @@\n+            test(robot, frame, bounds.x + bounds.width, bounds.y);\n@@ -68,0 +69,1 @@\n+            test(robot, frame, bounds.x, bounds.y + bounds.height);\n@@ -69,0 +71,1 @@\n+            test(robot, frame, bounds.x + bounds.width, bounds.y + bounds.height);\n","filename":"test\/jdk\/java\/awt\/Window\/LocationAtScreenCorner\/LocationAtScreenCorner.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.Window;\n+\n+\/**\n+ * @test\n+ * @key headful\n+ * @bug 8211999\n+ * @run main\/timeout=300 SlowMotion\n+ * @summary places the window on the screen outside of any insets, and waits to\n+ *          catch any strange window moving\n+ *\/\n+public final class SlowMotion {\n+\n+    \/\/ some additional space, if getScreenInsets() does not work, say on Linux\n+    private static final int SAFE = 100;\n+    private static final int HEIGHT = 350;\n+    private static final int WIDTH = 279;\n+    private static Robot robot;\n+\n+    public static void main(final String[] args) throws Exception {\n+        robot = new Robot();\n+        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        GraphicsDevice[] sds = ge.getScreenDevices();\n+\n+        for (GraphicsDevice sd : sds) {\n+            GraphicsConfiguration gc = sd.getDefaultConfiguration();\n+            Rectangle bounds = gc.getBounds();\n+            bounds.translate(SAFE, SAFE);\n+            Point point = new Point(bounds.x, bounds.y);\n+            Insets insets = Toolkit.getDefaultToolkit().getScreenInsets(gc);\n+            while (point.y < bounds.y + bounds.height - insets.bottom - HEIGHT - SAFE * 2) {\n+                while (point.x < bounds.x + bounds.width - insets.right - WIDTH - SAFE * 2) {\n+                    test(point, new Frame());\n+                    test(point, new Window(null));\n+                    test(point, new Dialog((Dialog) null));\n+                    point.translate(bounds.width \/ 6, 0);\n+                }\n+                point.setLocation(bounds.x, point.y + bounds.height \/ 5);\n+            }\n+        }\n+    }\n+\n+    private static void test(final Point loc, Window window) {\n+        try {\n+            window.setBounds(loc.x, loc.y, WIDTH, HEIGHT);\n+            window.setVisible(true);\n+            robot.delay(1000); \/\/ intentionally very slow, we try to catch\n+                               \/\/ very very last suspicion event\n+            Rectangle bounds = window.getBounds();\n+            if (loc.x != bounds.x || loc.y != bounds.y\n+                    || bounds.width != WIDTH || bounds.height != HEIGHT) {\n+                System.err.println(\"Component = \" + window);\n+                System.err.println(\"Actual bounds = \" + bounds);\n+                System.err.println(\"Expected location = \" + loc);\n+                System.err.println(\"Expected width = \" + WIDTH);\n+                System.err.println(\"Expected height = \" + HEIGHT);\n+                throw new RuntimeException();\n+            }\n+        } finally {\n+            window.dispose();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Window\/SlowMotion\/SlowMotion.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Window;\n+\n+\/**\n+ * @test\n+ * @key headful\n+ * @bug 8211999\n+ * @summary The test creates the packed\/unpacked top level components on the\n+ *          different screens and compares their bounds\n+ * @run main\/othervm WindowSizeDifferentScreens\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 WindowSizeDifferentScreens\n+ * @run main\/othervm -Dsun.java2d.uiScale=1.25 WindowSizeDifferentScreens\n+ *\/\n+public final class WindowSizeDifferentScreens {\n+\n+    public static void main(String[] args) throws Exception {\n+        test(\"window\");\n+        test(\"dialog\");\n+        test(\"frame\");\n+    }\n+\n+    private static void test(String top) throws Exception {\n+        var ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        Robot robot = new Robot();\n+        Window main = getTopLevel(top);\n+        try {\n+            main.setVisible(true);\n+            robot.waitForIdle();\n+            main.setSize(500, 500);\n+            robot.waitForIdle();\n+            for (GraphicsDevice gd : ge.getScreenDevices()) {\n+                Rectangle bounds = gd.getDefaultConfiguration().getBounds();\n+                Point point = bounds.getLocation();\n+                point.translate(100, 100);\n+                main.setLocation(point);\n+                main.setBackground(Color.RED);\n+                robot.waitForIdle();\n+\n+                Window packed = getTopLevel(top);\n+                Window unpacked = getTopLevel(top);\n+                try {\n+                    packed.pack();\n+                    robot.waitForIdle();\n+                    packed.setBackground(Color.GREEN);\n+                    unpacked.setBackground(Color.BLUE);\n+                    packed.setSize(500, 500);\n+                    unpacked.setSize(500, 500);\n+                    packed.setLocation(point);\n+                    unpacked.setLocation(point);\n+                    robot.waitForIdle();\n+                    packed.setVisible(true);\n+                    unpacked.setVisible(true);\n+                    robot.waitForIdle();\n+                    Rectangle mBounds = main.getBounds();\n+                    Rectangle pBounds = packed.getBounds();\n+                    Rectangle uBounds = unpacked.getBounds();\n+\n+                    if (!mBounds.equals(uBounds) ||\n+                            !mBounds.equals(pBounds)) {\n+                        System.err.println(\"Expected bounds: \" + mBounds);\n+                        System.err.println(\"Actual unpacked: \" + uBounds);\n+                        System.err.println(\"Actual packed: \" + pBounds);\n+                        throw new RuntimeException();\n+                    }\n+                } finally {\n+                    packed.dispose();\n+                    unpacked.dispose();\n+                }\n+            }\n+        } finally {\n+            main.dispose();\n+        }\n+    }\n+\n+    private static Window getTopLevel(String top) {\n+        switch (top) {\n+            case \"window\": return new Window(null);\n+\t    case \"dialog\": return new Dialog((Dialog) null);\n+\t    case \"frame\" : return new Frame();\n+\t    default: throw new IllegalArgumentException(\"Unexpected: \" + top);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Window\/WindowSizeDifferentScreens\/WindowSizeDifferentScreens.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -26,1 +26,0 @@\n-import java.awt.GraphicsConfiguration;\n@@ -30,0 +29,1 @@\n+import java.awt.Rectangle;\n@@ -50,1 +50,1 @@\n- * @bug 4955110 8238575\n+ * @bug 4955110 8238575 8211999\n@@ -60,0 +60,1 @@\n+    private static final int SIZE = 200;\n@@ -82,2 +83,2 @@\n-                    System.err.println(\"Expected in\" + frame.getBounds());\n-                    System.err.println(\"Actual\" + dsde.getLocation());\n+                    System.err.println(\"Expected in: \" + frame.getBounds());\n+                    System.err.println(\"Actual: \" + dsde.getLocation());\n@@ -133,2 +134,4 @@\n-        frame.setSize(200, 200);\n-        frame.setLocationRelativeTo(null);\n+        Rectangle screen = frame.getGraphicsConfiguration().getBounds();\n+        int x = (int) (screen.getCenterX() - SIZE \/ 2);\n+        int y = (int) (screen.getCenterY() - SIZE \/ 2);\n+        frame.setBounds(x, y, SIZE, SIZE);\n","filename":"test\/jdk\/java\/awt\/dnd\/Button2DragTest\/Button2DragTest.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n@@ -28,0 +30,1 @@\n+import java.awt.Rectangle;\n@@ -38,1 +41,1 @@\n- * @bug 8149849\n+ * @bug 8149849 8211999\n@@ -41,0 +44,1 @@\n+ * @run main\/othervm DNDTextToScaledArea\n@@ -45,0 +49,1 @@\n+    private static final int SIZE = 300;\n@@ -54,0 +59,7 @@\n+        var lge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        for (GraphicsDevice device : lge.getScreenDevices()) {\n+            test(device);\n+        }\n+    }\n+\n+    private static void test(GraphicsDevice device) throws Exception {\n@@ -55,1 +67,1 @@\n-        robot.setAutoDelay(50);\n+        robot.setAutoDelay(150);\n@@ -57,1 +69,1 @@\n-        SwingUtilities.invokeAndWait(DNDTextToScaledArea::createAndShowGUI);\n+        SwingUtilities.invokeAndWait(() -> createAndShowGUI(device));\n@@ -65,0 +77,5 @@\n+        \/\/ check the destination\n+        robot.mouseMove(dstPoint.x, dstPoint.y);\n+        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+        robot.waitForIdle();\n@@ -80,5 +97,6 @@\n-    private static void createAndShowGUI() {\n-\n-        frame = new JFrame();\n-        frame.setSize(300, 300);\n-        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+    private static void createAndShowGUI(GraphicsDevice device) {\n+        frame = new JFrame(device.getDefaultConfiguration());\n+        Rectangle screen = device.getDefaultConfiguration().getBounds();\n+        int x = (int) (screen.getCenterX() - SIZE \/ 2);\n+        int y = (int) (screen.getCenterY() - SIZE \/ 2);\n+        frame.setBounds(x, y, SIZE, SIZE);\n","filename":"test\/jdk\/javax\/swing\/JTextArea\/8149849\/DNDTextToScaledArea.java","additions":27,"deletions":9,"binary":false,"changes":36,"status":"modified"}]}