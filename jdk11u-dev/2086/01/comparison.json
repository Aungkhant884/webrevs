{"files":[{"patch":"@@ -85,1 +85,10 @@\n-             \"Use CPU_ALLOC code path in os::active_processor_count \")\n+             \"Use CPU_ALLOC code path in os::active_processor_count \")  \\\n+                                                                        \\\n+  diagnostic(bool, THPStackMitigation, true,                            \\\n+          \"If THPs are unconditionally enabled on the system (mode \"    \\\n+          \"\\\"always\\\"), the JVM will prevent THP from forming in \"      \\\n+          \"thread stacks. When disabled, the absence of this mitigation\"\\\n+          \"allows THPs to form in thread stacks.\")                      \\\n+                                                                        \\\n+  develop(bool, DelayThreadStartALot, false,                            \\\n+          \"Artificially delay thread starts randomly for testing.\")     \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"hugepages.hpp\"\n+\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+\/\/ Given a file that contains a single (integral) number, return that number in (*out) and true;\n+\/\/ in case of an error, return false.\n+static bool read_number_file(const char* file, size_t* out) {\n+  FILE* f = ::fopen(file, \"r\");\n+  bool rc = false;\n+  if (f != NULL) {\n+    uint64_t i = 0;\n+    if (::fscanf(f, SIZE_FORMAT, out) == 1) {\n+      rc = true;\n+    }\n+    ::fclose(f);\n+  }\n+  return rc;\n+}\n+\n+THPSupport::THPSupport() :\n+    _initialized(false), _mode(thp_never), _pagesize(SIZE_MAX) {}\n+\n+\n+THPMode THPSupport::mode() const {\n+  assert(_initialized, \"Not initialized\");\n+  return _mode;\n+}\n+\n+size_t THPSupport::pagesize() const {\n+  assert(_initialized, \"Not initialized\");\n+  return _pagesize;\n+}\n+\n+void THPSupport::scan_os() {\n+  \/\/ Scan \/sys\/kernel\/mm\/transparent_hugepage\/enabled\n+  \/\/ see mm\/huge_memory.c\n+  _mode = thp_never;\n+  const char* filename = \"\/sys\/kernel\/mm\/transparent_hugepage\/enabled\";\n+  FILE* f = ::fopen(filename, \"r\");\n+  if (f != NULL) {\n+    char buf[64];\n+    char* s = fgets(buf, sizeof(buf), f);\n+    assert(s == buf, \"Should have worked\");\n+    if (::strstr(buf, \"[madvise]\") != NULL) {\n+      _mode = thp_madvise;\n+    } else if (::strstr(buf, \"[always]\") != NULL) {\n+      _mode = thp_always;\n+    } else {\n+      assert(::strstr(buf, \"[never]\") != NULL, \"Weird content of %s: %s\", filename, buf);\n+    }\n+    fclose(f);\n+  }\n+\n+  \/\/ Scan large page size for THP from hpage_pmd_size\n+  _pagesize = 0;\n+  if (read_number_file(\"\/sys\/kernel\/mm\/transparent_hugepage\/hpage_pmd_size\", &_pagesize)) {\n+    assert(_pagesize > 0, \"Expected\");\n+  }\n+  _initialized = true;\n+\n+  LogTarget(Info, pagesize) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    print_on(&ls);\n+  }\n+}\n+\n+void THPSupport::print_on(outputStream* os) {\n+  if (_initialized) {\n+    os->print_cr(\"Transparent hugepage (THP) support:\");\n+    os->print_cr(\"  THP mode: %s\",\n+        (_mode == thp_always ? \"always\" : (_mode == thp_never ? \"never\" : \"madvise\")));\n+    os->print_cr(\"  THP pagesize: \" SIZE_FORMAT, _pagesize);\n+  } else {\n+    os->print_cr(\"  unknown.\");\n+  }\n+}\n+\n+THPSupport HugePages::_thp_support;\n+\n+void HugePages::initialize() {\n+  _thp_support.scan_os();\n+}\n+\n+void HugePages::print_on(outputStream* os) {\n+  _thp_support.print_on(os);\n+}\n","filename":"src\/hotspot\/os\/linux\/hugepages.cpp","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_HUGEPAGES_HPP\n+#define OS_LINUX_HUGEPAGES_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\" \/\/ for os::PageSizes\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+\n+enum THPMode { thp_always, thp_never, thp_madvise };\n+\n+\/\/ 2) for transparent hugepages\n+class THPSupport {\n+  bool _initialized;\n+\n+  \/\/ See \/sys\/kernel\/mm\/transparent_hugepages\/enabled\n+  THPMode _mode;\n+\n+  \/\/ Contains the THP page size\n+  size_t _pagesize;\n+\n+public:\n+\n+  THPSupport();\n+\n+  \/\/ Queries the OS, fills in object\n+  void scan_os();\n+\n+  THPMode mode() const;\n+  size_t pagesize() const;\n+  void print_on(outputStream* os);\n+};\n+\n+\/\/ Umbrella static interface\n+class HugePages : public AllStatic {\n+\n+  static THPSupport _thp_support;\n+\n+public:\n+\n+  static const THPSupport& thp_info() { return _thp_support; }\n+\n+  static THPMode thp_mode()                     { return _thp_support.mode(); }\n+  static bool supports_thp()                    { return thp_mode() == thp_madvise || thp_mode() == thp_always; }\n+  static size_t thp_pagesize()                  { return _thp_support.pagesize(); }\n+\n+  static void initialize();\n+  static void print_on(outputStream* os);\n+};\n+\n+#endif \/\/ OS_LINUX_HUGEPAGES_HPP\n","filename":"src\/hotspot\/os\/linux\/hugepages.hpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"hugepages.hpp\"\n@@ -825,0 +826,4 @@\n+  if (DelayThreadStartALot) {\n+    os::naked_short_sleep(100);\n+  }\n+\n@@ -984,0 +989,12 @@\n+  if (THPStackMitigation) {\n+    \/\/ In addition to the glibc guard page that prevents inter-thread-stack hugepage\n+    \/\/ coalescing (see comment in os::Linux::default_guard_size()), we also make\n+    \/\/ sure the stack size itself is not huge-page-size aligned; that makes it much\n+    \/\/ more likely for thread stack boundaries to be unaligned as well and hence\n+    \/\/ protects thread stacks from being targeted by khugepaged.\n+    if (HugePages::thp_pagesize() > 0 &&\n+        is_aligned(stack_size, HugePages::thp_pagesize())) {\n+      stack_size += os::vm_page_size();\n+    }\n+  }\n+\n@@ -3509,0 +3526,21 @@\n+\n+  if (THPStackMitigation) {\n+    \/\/ If THPs are unconditionally enabled, the following scenario can lead to huge RSS\n+    \/\/ - parent thread spawns, in quick succession, multiple child threads\n+    \/\/ - child threads are slow to start\n+    \/\/ - thread stacks of future child threads are adjacent and get merged into one large VMA\n+    \/\/   by the kernel, and subsequently transformed into huge pages by khugepaged\n+    \/\/ - child threads come up, place JVM guard pages, thus splinter the large VMA, splinter\n+    \/\/   the huge pages into many (still paged-in) small pages.\n+    \/\/ The result of that sequence are thread stacks that are fully paged-in even though the\n+    \/\/ threads did not even start yet.\n+    \/\/ We prevent that by letting the glibc allocate a guard page, which causes a VMA with different\n+    \/\/ permission bits to separate two ajacent thread stacks and therefore prevent merging stacks\n+    \/\/ into one VMA.\n+    \/\/\n+    \/\/ Yes, this means we have two guard sections - the glibc and the JVM one - per thread. But the\n+    \/\/ cost for that one extra protected page is dwarfed from a large win in performance and memory\n+    \/\/ that avoiding interference by khugepaged buys us.\n+    return os::vm_page_size();\n+  }\n+\n@@ -4162,0 +4200,19 @@\n+\n+  \/\/ Query OS information first.\n+  HugePages::initialize();\n+\n+  \/\/ If THPs are unconditionally enabled (THP mode \"always\"), khugepaged may attempt to\n+  \/\/ coalesce small pages in thread stacks to huge pages. That costs a lot of memory and\n+  \/\/ is usually unwanted for thread stacks. Therefore we attempt to prevent THP formation in\n+  \/\/ thread stacks unless the user explicitly allowed THP formation by manually disabling\n+  \/\/ -XX:-THPStackMitigation.\n+  if (HugePages::thp_mode() == thp_always) {\n+    if (THPStackMitigation) {\n+      log_info(pagesize)(\"JVM will attempt to prevent THPs in thread stacks.\");\n+    } else {\n+      log_info(pagesize)(\"JVM will *not* prevent THPs in thread stacks. This may cause high RSS.\");\n+    }\n+  } else {\n+    FLAG_SET_ERGO(bool, THPStackMitigation, false); \/\/ Mitigation not needed\n+  }\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-define_pd_global(intx, ThreadStackSize,          2048); \/\/ 0 => use system default\n-define_pd_global(intx, VMThreadStackSize,        2048);\n@@ -36,1 +34,11 @@\n-define_pd_global(intx, CompilerThreadStackSize,  2048);\n+\/\/ Set default stack sizes < 2MB so as to prevent stacks from getting\n+\/\/ large-page aligned and backed by THPs on systems where 2MB is the\n+\/\/ default huge page size. For non-JavaThreads, glibc may add an additional\n+\/\/ guard page to the total stack size, so to keep the default sizes same\n+\/\/ for all the following flags, we set them to 2 pages less than 2MB. On\n+\/\/ systems where 2MB is the default large page size, 4KB is most commonly\n+\/\/ the regular page size.\n+define_pd_global(intx, ThreadStackSize,          2040); \/\/ 0 => use system default\n+define_pd_global(intx, VMThreadStackSize,        2040);\n+\n+define_pd_global(intx, CompilerThreadStackSize,  2040);\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/globals_linux_aarch64.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.io.*;\n+import java.util.Set;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+class HugePageConfiguration {\n+\n+    Set<Long> _staticHugePageSizes;\n+    long _staticDefaultHugePageSize;\n+\n+    enum THPMode {always, never, madvise, unknown}\n+    THPMode _thpMode;\n+    long _thpPageSize;\n+\n+    public Set<Long> getStaticHugePageSizes() {\n+        return _staticHugePageSizes;\n+    }\n+\n+    public long getStaticDefaultHugePageSize() {\n+        return _staticDefaultHugePageSize;\n+    }\n+\n+    public THPMode getThpMode() {\n+        return _thpMode;\n+    }\n+\n+    public long getThpPageSize() {\n+        return _thpPageSize;\n+    }\n+\n+    public HugePageConfiguration(Set<Long> _staticHugePageSizes, long _staticDefaultHugePageSize, THPMode _thpMode, long _thpPageSize) {\n+        this._staticHugePageSizes = _staticHugePageSizes;\n+        this._staticDefaultHugePageSize = _staticDefaultHugePageSize;\n+        this._thpMode = _thpMode;\n+        this._thpPageSize = _thpPageSize;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"Configuration{\" +\n+                \"_staticHugePageSizes=\" + _staticHugePageSizes +\n+                \", _staticDefaultHugePageSize=\" + _staticDefaultHugePageSize +\n+                \", _thpMode=\" + _thpMode +\n+                \", _thpPageSize=\" + _thpPageSize +\n+                '}';\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        HugePageConfiguration that = (HugePageConfiguration) o;\n+        return _staticDefaultHugePageSize == that._staticDefaultHugePageSize && _thpPageSize == that._thpPageSize && Objects.equals(_staticHugePageSizes, that._staticHugePageSizes) && _thpMode == that._thpMode;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(_staticHugePageSizes, _staticDefaultHugePageSize, _thpMode, _thpPageSize);\n+    }\n+\n+    private static long readDefaultHugePageSizeFromOS() {\n+        Pattern pat = Pattern.compile(\"Hugepagesize: *(\\\\d+) +kB\");\n+        long result = 0;\n+        try (Scanner scanner = new Scanner(new File(\"\/proc\/meminfo\"))) {\n+            while (scanner.hasNextLine()) {\n+                Matcher mat = pat.matcher(scanner.nextLine());\n+                if (mat.matches()) {\n+                    scanner.close();\n+                    return Long.parseLong(mat.group(1)) * 1024;\n+                }\n+            }\n+        } catch (FileNotFoundException e) {\n+            System.out.println(\"Could not open \/proc\/meminfo\");\n+        }\n+        return 0;\n+    }\n+\n+    private static Set<Long> readSupportedHugePagesFromOS() {\n+        TreeSet<Long> pagesizes = new TreeSet<>();\n+        Pattern pat = Pattern.compile(\"hugepages-(\\\\d+)kB\");\n+        File[] subdirs = new File(\"\/sys\/kernel\/mm\/hugepages\").listFiles();\n+        if (subdirs != null) {\n+            for (File f : subdirs) {\n+                String name = f.getName();\n+                Matcher mat = pat.matcher(name);\n+                if (mat.matches()) {\n+                    long pagesize = Long.parseLong(mat.group(1)) * 1024;\n+                    pagesizes.add(pagesize);\n+                }\n+            }\n+        }\n+        return pagesizes;\n+    }\n+\n+    private static THPMode readTHPModeFromOS() {\n+        THPMode mode = THPMode.unknown;\n+        String file = \"\/sys\/kernel\/mm\/transparent_hugepage\/enabled\";\n+        try (FileReader fr = new FileReader(file);\n+             BufferedReader reader = new BufferedReader(fr)) {\n+            String s = reader.readLine();\n+            if (s.contains(\"[never]\")) {\n+                mode = THPMode.never;\n+            } else if (s.contains(\"[always]\")) {\n+                mode = THPMode.always;\n+            } else if (s.contains(\"[madvise]\")) {\n+                mode = THPMode.madvise;\n+            } else {\n+                throw new RuntimeException(\"Unexpected content of \" + file + \": \" + s);\n+            }\n+        } catch (IOException e) {\n+            System.out.println(\"Failed to read \" + file);\n+            mode = THPMode.unknown;\n+        }\n+        return mode;\n+    }\n+\n+    private static long readTHPPageSizeFromOS() {\n+        long pagesize = 0;\n+        String file = \"\/sys\/kernel\/mm\/transparent_hugepage\/hpage_pmd_size\";\n+        try (FileReader fr = new FileReader(file);\n+             BufferedReader reader = new BufferedReader(fr)) {\n+            String s = reader.readLine();\n+            pagesize = Long.parseLong(s);\n+        } catch (IOException | NumberFormatException e) { \/* ignored *\/ }\n+        return pagesize;\n+    }\n+\n+    \/\/ Fill object with info read from proc file system\n+    public static HugePageConfiguration readFromOS() {\n+        return new HugePageConfiguration(readSupportedHugePagesFromOS(),\n+                readDefaultHugePageSizeFromOS(),\n+                readTHPModeFromOS(),\n+                readTHPPageSizeFromOS());\n+    }\n+\n+    private static long parseSIUnit(String num, String unit) {\n+        long n = Long.parseLong(num);\n+        if (unit.equals(\"K\")) {\n+            return n * 1024;\n+        } else if (unit.equals(\"M\")) {\n+            return n * 1024 * 1024;\n+        } else if (unit.equals(\"G\")) {\n+            return n * 1024 * 1024 * 1024;\n+        }\n+        throw new RuntimeException(\"Invalid unit \" + unit);\n+    }\n+\n+    public static HugePageConfiguration readFromJVMLog(OutputAnalyzer output) {\n+        \/\/ Expects output from -Xlog:pagesize\n+        \/\/ Example:\n+        \/\/ [0.001s][info][pagesize] Static hugepage support:\n+        \/\/ [0.001s][info][pagesize]   hugepage size: 2M\n+        \/\/ [0.001s][info][pagesize]   hugepage size: 1G\n+        \/\/ [0.001s][info][pagesize]   default hugepage size: 2M\n+        \/\/ [0.001s][info][pagesize] Transparent hugepage (THP) support:\n+        \/\/ [0.001s][info][pagesize]   THP mode: madvise\n+        \/\/ [0.001s][info][pagesize]   THP pagesize: 2M\n+        TreeSet<Long> hugepages = new TreeSet<>();\n+        long defaultHugepageSize = 0;\n+        THPMode thpMode = THPMode.never;\n+        long thpPageSize = 0;\n+        Pattern patternHugepageSize = Pattern.compile(\".*\\\\[pagesize] *hugepage size: (\\\\d+)([KMG])\");\n+        Pattern patternDefaultHugepageSize = Pattern.compile(\".*\\\\[pagesize] *default hugepage size: (\\\\d+)([KMG]) *\");\n+        Pattern patternTHPPageSize = Pattern.compile(\".*\\\\[pagesize] *THP pagesize: (\\\\d+)([KMG])\");\n+        Pattern patternTHPMode = Pattern.compile(\".*\\\\[pagesize] *THP mode: (\\\\S+)\");\n+        List<String> lines = output.asLines();\n+        for (String s : lines) {\n+            Matcher mat = patternHugepageSize.matcher(s);\n+            if (mat.matches()) {\n+                hugepages.add(parseSIUnit(mat.group(1), mat.group(2)));\n+                continue;\n+            }\n+            if (defaultHugepageSize == 0) {\n+                mat = patternDefaultHugepageSize.matcher(s);\n+                if (mat.matches()) {\n+                    defaultHugepageSize = parseSIUnit(mat.group(1), mat.group(2));\n+                    continue;\n+                }\n+            }\n+            if (thpPageSize == 0) {\n+                mat = patternTHPPageSize.matcher(s);\n+                if (mat.matches()) {\n+                    thpPageSize = parseSIUnit(mat.group(1), mat.group(2));\n+                    continue;\n+                }\n+            }\n+            mat = patternTHPMode.matcher(s);\n+            if (mat.matches()) {\n+                thpMode = THPMode.valueOf(mat.group(1));\n+            }\n+        }\n+\n+        return new HugePageConfiguration(hugepages, defaultHugepageSize, thpMode, thpPageSize);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/HugePageConfiguration.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=ENABLED\n+ * @bug 8303215 8312182\n+ * @summary On THP=always systems, we prevent THPs from forming within thread stacks\n+ * @library \/test\/lib\n+ * @requires os.family == \"linux\"\n+ * @requires vm.debug\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver THPsInThreadStackPreventionTest PATCH-ENABLED\n+ *\/\n+\n+\/*\n+ * @test id=DISABLED\n+ * @bug 8303215 8312182\n+ * @summary On THP=always systems, we prevent THPs from forming within thread stacks (negative test)\n+ * @library \/test\/lib\n+ * @requires os.family == \"linux\"\n+ * @requires vm.debug\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/manual THPsInThreadStackPreventionTest  PATCH-DISABLED\n+ *\/\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jtreg.SkippedException;\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+\n+public class THPsInThreadStackPreventionTest {\n+\n+    \/\/ We test the mitigation for \"huge rss for THP=always\" introduced with JDK-8312182 and JDK-8302015:\n+    \/\/\n+    \/\/ We start a program that spawns a ton of threads with a stack size close to THP page size. The threads\n+    \/\/ are idle and should not build up a lot of stack. The threads are started with an artificial delay\n+    \/\/ between thread start and stack guardpage creation, which exacerbates the RSS bloat (for explanation\n+    \/\/ please see 8312182).\n+    \/\/\n+    \/\/ We then observe RSS of that program. We expect it to stay below a reasonable maximum. The unpatched\n+    \/\/ version should show an RSS of ~2 GB (paying for the fully paged in thread stacks). The fixed variant should\n+    \/\/ cost only ~200-400 MB.\n+\n+    static final int numThreads = 1000;\n+    static final long threadStackSizeMB = 2; \/\/ must be 2M\n+    static final long heapSizeMB = 64;\n+    static final long basicRSSOverheadMB = heapSizeMB + 150;\n+    \/\/ A successful completion of this test would show not more than X KB per thread stack.\n+    static final long acceptableRSSPerThreadStack = 128 * 1024;\n+    static final long acceptableRSSForAllThreadStacks = numThreads * acceptableRSSPerThreadStack;\n+    static final long acceptableRSSLimitMB = (acceptableRSSForAllThreadStacks \/ (1024 * 1024)) + basicRSSOverheadMB;\n+\n+    private static class TestMain {\n+\n+        static class Sleeper extends Thread {\n+            CyclicBarrier barrier;\n+            public Sleeper(CyclicBarrier barrier) {\n+                this.barrier = barrier;\n+            }\n+            @Override\n+            public void run() {\n+                try {\n+                    barrier.await(); \/\/ wait for all siblings\n+                    barrier.await(); \/\/ wait main thread to print status\n+                } catch (InterruptedException | BrokenBarrierException e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        }\n+\n+        public static void main(String[] args) throws BrokenBarrierException, InterruptedException {\n+\n+            \/\/ Fire up 1000 threads with 2M stack size each.\n+            Sleeper[] threads = new Sleeper[numThreads];\n+            CyclicBarrier barrier = new CyclicBarrier(numThreads + 1);\n+\n+            for (int i = 0; i < numThreads; i++) {\n+                threads[i] = new Sleeper(barrier);\n+                threads[i].start();\n+            }\n+\n+            \/\/ Wait for all threads to come up\n+            barrier.await();\n+\n+            \/\/ print status\n+            String file = \"\/proc\/self\/status\";\n+            try (FileReader fr = new FileReader(file);\n+                 BufferedReader reader = new BufferedReader(fr)) {\n+                String line;\n+                while ((line = reader.readLine()) != null) {\n+                    System.out.println(line);\n+                }\n+            } catch (IOException | NumberFormatException e) { \/* ignored *\/ }\n+\n+            \/\/ Signal threads to stop\n+            barrier.await();\n+\n+        }\n+    }\n+\n+    static class ProcSelfStatus {\n+\n+        public long rssMB;\n+        public long swapMB;\n+        public int numLifeThreads;\n+\n+        \/\/ Parse output from \/proc\/self\/status\n+        public static ProcSelfStatus parse(OutputAnalyzer o) {\n+            ProcSelfStatus status = new ProcSelfStatus();\n+            String s = o.firstMatch(\"Threads:\\\\s*(\\\\d+)\", 1);\n+            Objects.requireNonNull(s);\n+            status.numLifeThreads = Integer.parseInt(s);\n+            s = o.firstMatch(\"VmRSS:\\\\s*(\\\\d+) kB\", 1);\n+            Objects.requireNonNull(s);\n+            status.rssMB = Long.parseLong(s) \/ 1024;\n+            s = o.firstMatch(\"VmSwap:\\\\s*(\\\\d+) kB\", 1);\n+            Objects.requireNonNull(s);\n+            status.swapMB = Long.parseLong(s) \/ 1024;\n+            return status;\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        HugePageConfiguration config = HugePageConfiguration.readFromOS();\n+        \/\/ This issue is bound to THP=always\n+        if (config.getThpMode() != HugePageConfiguration.THPMode.always) {\n+            throw new SkippedException(\"Test only makes sense in THP \\\"always\\\" mode\");\n+        }\n+\n+        String[] defaultArgs = {\n+            \"-Xlog:pagesize\",\n+            \"-Xmx\" + heapSizeMB + \"m\", \"-Xms\" + heapSizeMB + \"m\", \"-XX:+AlwaysPreTouch\", \/\/ stabilize RSS\n+            \"-Xss\" + threadStackSizeMB + \"m\",\n+            \"-XX:-CreateCoredumpOnCrash\",\n+            \/\/ Limits the number of JVM-internal threads, which depends on the available cores of the\n+            \/\/ machine. RSS+Swap could exceed acceptableRSSLimitMB when JVM creates many internal threads.\n+            \"-XX:ActiveProcessorCount=2\",\n+            \/\/ This will delay the child threads before they create guard pages, thereby greatly increasing the\n+            \/\/ chance of large VMA formation + hugepage coalescation; see JDK-8312182\n+            \"-XX:+DelayThreadStartALot\"\n+        };\n+        ArrayList<String> finalargs = new ArrayList<>(Arrays.asList(defaultArgs));\n+\n+        switch (args[0]) {\n+            case \"PATCH-ENABLED\": {\n+                finalargs.add(TestMain.class.getName());\n+                ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(finalargs);\n+\n+                OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+                output.shouldHaveExitValue(0);\n+\n+                \/\/ this line indicates the mitigation is active:\n+                output.shouldContain(\"[pagesize] JVM will attempt to prevent THPs in thread stacks.\");\n+\n+                ProcSelfStatus status = ProcSelfStatus.parse(output);\n+                if (status.numLifeThreads < numThreads) {\n+                    throw new RuntimeException(\"Number of live threads lower than expected: \" + status.numLifeThreads + \", expected \" + numThreads);\n+                } else {\n+                    System.out.println(\"Found \" + status.numLifeThreads + \" to be alive. Ok.\");\n+                }\n+\n+                long rssPlusSwapMB = status.swapMB + status.rssMB;\n+\n+                if (rssPlusSwapMB > acceptableRSSLimitMB) {\n+                    throw new RuntimeException(\"RSS+Swap larger than expected: \" + rssPlusSwapMB + \"m, expected at most \" + acceptableRSSLimitMB + \"m\");\n+                } else {\n+                    if (rssPlusSwapMB < heapSizeMB) { \/\/ we pretouch the java heap, so we expect to see at least that:\n+                        throw new RuntimeException(\"RSS+Swap suspiciously low: \" + rssPlusSwapMB + \"m, expected at least \" + heapSizeMB + \"m\");\n+                    }\n+                    System.out.println(\"Okay: RSS+Swap=\" + rssPlusSwapMB + \", within acceptable limit of \" + acceptableRSSLimitMB);\n+                }\n+            }\n+            break;\n+\n+            case \"PATCH-DISABLED\": {\n+\n+                \/\/ Only execute manually! this will allocate ~2gb of memory!\n+\n+                \/\/ explicitly disable the no-THP-workaround:\n+                finalargs.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+                finalargs.add(\"-XX:-THPStackMitigation\");\n+\n+                finalargs.add(TestMain.class.getName());\n+                ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(finalargs);\n+                OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+                output.shouldHaveExitValue(0);\n+\n+                \/\/ We deliberately switched off mitigation, VM should tell us:\n+                output.shouldContain(\"[pagesize] JVM will *not* prevent THPs in thread stacks. This may cause high RSS.\");\n+\n+                \/\/ Parse output from self\/status\n+                ProcSelfStatus status = ProcSelfStatus.parse(output);\n+                if (status.numLifeThreads < numThreads) {\n+                    throw new RuntimeException(\"Number of live threads lower than expected (\" + status.numLifeThreads + \", expected \" + numThreads +\")\");\n+                } else {\n+                    System.out.println(\"Found \" + status.numLifeThreads + \" to be alive. Ok.\");\n+                }\n+\n+                long rssPlusSwapMB = status.swapMB + status.rssMB;\n+\n+                if (rssPlusSwapMB < acceptableRSSLimitMB) {\n+                    throw new RuntimeException(\"RSS+Swap lower than expected: \" + rssPlusSwapMB + \"m, expected more than \" + acceptableRSSLimitMB + \"m\");\n+                }\n+                break;\n+            }\n+\n+            default: throw new RuntimeException(\"Bad argument: \" + args[0]);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/THPsInThreadStackPreventionTest.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"}]}