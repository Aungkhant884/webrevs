{"files":[{"patch":"@@ -27,1 +27,0 @@\n-import java.io.InputStream;\n@@ -33,0 +32,1 @@\n+import java.net.URLEncoder;\n@@ -40,1 +40,1 @@\n-import java.util.Arrays;\n+import java.util.Base64;\n@@ -48,0 +48,1 @@\n+import sun.security.util.IOUtils;\n@@ -227,3 +228,3 @@\n-        InputStream in = null;\n-        OutputStream out = null;\n-        byte[] response = null;\n+        if (debug != null) {\n+            debug.println(\"connecting to OCSP service at: \" + responderURI);\n+        }\n@@ -231,0 +232,2 @@\n+        URL url;\n+        HttpURLConnection con = null;\n@@ -232,3 +235,25 @@\n-            URL url = responderURI.toURL();\n-            if (debug != null) {\n-                debug.println(\"connecting to OCSP service at: \" + url);\n+            String encodedGetReq = responderURI.toString() + \"\/\" +\n+                    URLEncoder.encode(Base64.getEncoder().encodeToString(bytes),\n+                            \"UTF-8\");\n+\n+            if (encodedGetReq.length() <= 255) {\n+                url = new URL(encodedGetReq);\n+                con = (HttpURLConnection)url.openConnection();\n+                con.setDoOutput(true);\n+                con.setDoInput(true);\n+                con.setRequestMethod(\"GET\");\n+            } else {\n+                url = responderURI.toURL();\n+                con = (HttpURLConnection)url.openConnection();\n+                con.setConnectTimeout(CONNECT_TIMEOUT);\n+                con.setReadTimeout(CONNECT_TIMEOUT);\n+                con.setDoOutput(true);\n+                con.setDoInput(true);\n+                con.setRequestMethod(\"POST\");\n+                con.setRequestProperty\n+                    (\"Content-type\", \"application\/ocsp-request\");\n+                con.setRequestProperty\n+                    (\"Content-length\", String.valueOf(bytes.length));\n+                OutputStream out = con.getOutputStream();\n+                out.write(bytes);\n+                out.flush();\n@@ -236,13 +261,0 @@\n-            HttpURLConnection con = (HttpURLConnection)url.openConnection();\n-            con.setConnectTimeout(CONNECT_TIMEOUT);\n-            con.setReadTimeout(CONNECT_TIMEOUT);\n-            con.setDoOutput(true);\n-            con.setDoInput(true);\n-            con.setRequestMethod(\"POST\");\n-            con.setRequestProperty\n-                (\"Content-type\", \"application\/ocsp-request\");\n-            con.setRequestProperty\n-                (\"Content-length\", String.valueOf(bytes.length));\n-            out = con.getOutputStream();\n-            out.write(bytes);\n-            out.flush();\n@@ -255,1 +267,1 @@\n-            in = con.getInputStream();\n+\n@@ -260,6 +272,0 @@\n-            response = new byte[contentLength > 2048 ? 2048 : contentLength];\n-            int total = 0;\n-            while (total < contentLength) {\n-                int count = in.read(response, total, response.length - total);\n-                if (count < 0)\n-                    break;\n@@ -267,6 +273,2 @@\n-                total += count;\n-                if (total >= response.length && total < contentLength) {\n-                    response = Arrays.copyOf(response, total * 2);\n-                }\n-            }\n-            response = Arrays.copyOf(response, total);\n+            return IOUtils.readExactlyNBytes(con.getInputStream(),\n+                    contentLength);\n@@ -274,13 +276,2 @@\n-            if (in != null) {\n-                try {\n-                    in.close();\n-                } catch (IOException ioe) {\n-                    throw ioe;\n-                }\n-            }\n-            if (out != null) {\n-                try {\n-                    out.close();\n-                } catch (IOException ioe) {\n-                    throw ioe;\n-                }\n+            if (con != null) {\n+                con.disconnect();\n@@ -289,1 +280,0 @@\n-        return response;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/OCSP.java","additions":38,"deletions":48,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -0,0 +1,264 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8179503\n+ * @summary Java should support GET OCSP calls\n+ * @library \/javax\/net\/ssl\/templates \/java\/security\/testlibrary\n+ * @build SimpleOCSPServer\n+ * @modules java.base\/sun.security.util\n+ *          java.base\/sun.security.provider.certpath\n+ *          java.base\/sun.security.x509\n+ * @run main\/othervm GetAndPostTests\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyFactory;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.SecureRandom;\n+import java.security.cert.CertPath;\n+import java.security.cert.CertPathValidator;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.Extension;\n+import java.security.cert.PKIXCertPathChecker;\n+import java.security.cert.PKIXParameters;\n+import java.security.cert.PKIXRevocationChecker;\n+import java.security.cert.TrustAnchor;\n+import java.security.cert.X509Certificate;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import sun.security.testlibrary.SimpleOCSPServer;\n+import sun.security.testlibrary.SimpleOCSPServer;\n+import sun.security.testlibrary.SimpleOCSPServer;\n+import sun.security.util.DerOutputStream;\n+import sun.security.util.DerValue;\n+import sun.security.util.ObjectIdentifier;\n+import sun.security.testlibrary.SimpleOCSPServer;\n+\n+public class GetAndPostTests {\n+    private static final String PASS = \"passphrase\";\n+    private static CertificateFactory certFac;\n+\n+    public static void main(String args[]) throws Exception {\n+        SimpleOCSPServer ocspResponder = null;\n+\n+        try {\n+            certFac = CertificateFactory.getInstance(\"X.509\");\n+\n+            \/\/ Read in the certificates and keys needed for this test and\n+            \/\/ create the keystore for the SimpleOCSPServer.  For the purposes\n+            \/\/ of this test, the CA certificate will also be the OCSP responder\n+            \/\/ signing certificate.\n+            SSLSocketTemplate.Cert certAuth =\n+                    SSLSocketTemplate.Cert.CA_ECDSA_SECP256R1;\n+            X509Certificate caCert = pem2Cert(certAuth.certStr);\n+            PrivateKey caKey = pem2Key(certAuth.privKeyStr, certAuth.keyAlgo);\n+            X509Certificate endEntCert =\n+                    pem2Cert(SSLSocketTemplate.Cert.EE_ECDSA_SECP256R1.certStr);\n+\n+            KeyStore.Builder keyStoreBuilder =\n+                    KeyStore.Builder.newInstance(\"PKCS12\", null,\n+                        new KeyStore.PasswordProtection(PASS.toCharArray()));\n+            KeyStore ocspStore = keyStoreBuilder.getKeyStore();\n+            Certificate[] ocspChain = {caCert};\n+            ocspStore.setKeyEntry(\"ocspsigner\", caKey, PASS.toCharArray(),\n+                    ocspChain);\n+\n+            \/\/ Create the certificate path we'll use for cert path validation.\n+            CertPath path = certFac.generateCertPath(List.of(endEntCert));\n+\n+            \/\/ Next, create and start the OCSP responder.  Obtain the socket\n+            \/\/ address so we can set that in the PKIXRevocationChecker since\n+            \/\/ these certificates do not have AIA extensions on them.\n+            ocspResponder = new SimpleOCSPServer(ocspStore, PASS,\n+                    \"ocspsigner\", null);\n+            ocspResponder.setSignatureAlgorithm(\"SHA256WithECDSA\");\n+            ocspResponder.enableLog(true);\n+            ocspResponder.setNextUpdateInterval(3600);\n+            ocspResponder.updateStatusDb(Map.of(\n+                    endEntCert.getSerialNumber(),\n+                    new SimpleOCSPServer.CertStatusInfo(\n+                            SimpleOCSPServer.CertStatus.CERT_STATUS_GOOD)));\n+            ocspResponder.start();\n+            \/\/ Wait 5 seconds for server ready\n+            for (int i = 0; (i < 100 && !ocspResponder.isServerReady()); i++) {\n+                Thread.sleep(50);\n+            }\n+            if (!ocspResponder.isServerReady()) {\n+                throw new RuntimeException(\"Server not ready yet\");\n+            }\n+\n+            int ocspPort = ocspResponder.getPort();\n+            URI ocspURI = new URI(\"http:\/\/localhost:\" + ocspPort);\n+            System.out.println(\"Configured CPV to connect to \" + ocspURI);\n+\n+            \/\/ Create the PKIXParameters needed for path validation and\n+            \/\/ configure any necessary OCSP parameters to control the OCSP\n+            \/\/ request size.\n+            Set<TrustAnchor> anchors = Set.of(new TrustAnchor(caCert, null));\n+\n+            CertPathValidator validator = CertPathValidator.getInstance(\"PKIX\");\n+            PKIXRevocationChecker revChkr =\n+                    (PKIXRevocationChecker)validator.getRevocationChecker();\n+            revChkr.setOcspResponder(ocspURI);\n+            revChkr.setOptions(Set.of(\n+                    PKIXRevocationChecker.Option.ONLY_END_ENTITY,\n+                    PKIXRevocationChecker.Option.NO_FALLBACK));\n+\n+            PKIXParameters params = new PKIXParameters(anchors);\n+            params.setRevocationEnabled(true);\n+            params.setDate(new Date(1590926400000L)); \/\/ 05\/31\/2020 @ 12:00:00Z\n+            params.addCertPathChecker(revChkr);\n+\n+            System.out.println(\"Test 1: Request < 255 bytes, HTTP GET\");\n+            validator.validate(path, params);\n+\n+            System.out.println(\"Test 2: Request > 255 bytes, HTTP POST\");\n+            \/\/ Modify the PKIXRevocationChecker to include a bogus non-critical\n+            \/\/ request extension that makes the request large enough to be\n+            \/\/ issued as an HTTP POST.\n+            List<PKIXCertPathChecker> chkrList = params.getCertPathCheckers();\n+            for (PKIXCertPathChecker chkr : chkrList) {\n+                if (chkr instanceof PKIXRevocationChecker) {\n+                    ((PKIXRevocationChecker)chkr).setOcspExtensions(\n+                            List.of(new BogusExtension(\"1.2.3.4.5.6.7.8.9\",\n+                                    false, 256)));\n+                }\n+            }\n+            params.setCertPathCheckers(chkrList);\n+            validator.validate(path, params);\n+\n+        } finally {\n+            if (ocspResponder != null) {\n+                ocspResponder.stop();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Create an X509Certificate object from its PEM encoding\n+     *\n+     * @param pemCert the base64 encoded certificate\n+     *\n+     * @return the corresponding X509Certificate object from the PEM encoding.\n+     *\n+     * @throws IOException if any InputStream or Base64 decoding failures occur.\n+     * @throws CertificateException if any certificate parsing errors occur.\n+     *\/\n+    private static X509Certificate pem2Cert(String pemCert)\n+            throws IOException, CertificateException {\n+        return (X509Certificate)certFac.generateCertificate(\n+                new ByteArrayInputStream(pemCert.getBytes()));\n+    }\n+\n+    \/**\n+     * Create a private key from its PEM-encoded PKCS#8 representation.\n+     *\n+     * @param pemKey the private key in PEM-encoded PKCS#8 unencrypted format\n+     * @param algorithm the private key algorithm\n+     *\n+     * @return the PrivateKey extracted from the PKCS#8 encoding.\n+     *\n+     * @throws GeneralSecurityException if any errors take place during\n+     * decoding or parsing.\n+     *\/\n+    private static PrivateKey pem2Key(String pemKey, String algorithm)\n+            throws GeneralSecurityException {\n+        byte[] p8Der = Base64.getMimeDecoder().decode(pemKey);\n+        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(p8Der, algorithm);\n+        KeyFactory kf = KeyFactory.getInstance(algorithm);\n+        return kf.generatePrivate(spec);\n+    }\n+\n+    \/**\n+     * The BogusOcspExtension is an extension with random data in the\n+     * extension value field.  It is used in this test to expand the size\n+     * of the OCSP request so it crosses the boundary that forces an HTTP\n+     * POST operation instead of a GET.\n+     *\/\n+    private static class BogusExtension implements Extension {\n+        private final ObjectIdentifier oid;\n+        private final boolean critical;\n+        private final byte[] data;\n+\n+        public BogusExtension(String oidStr, boolean isCrit, int size)\n+                throws IOException {\n+            \/\/ For this test we don't need anything larger than 10K\n+            if (size > 0 && size <= 10240) {\n+                data = new byte[size];\n+            } else {\n+                throw new IllegalArgumentException(\n+                        \"Size must be 0 < X <= 10240\");\n+            }\n+            oid = ObjectIdentifier.of(oidStr);\n+            SecureRandom sr = new SecureRandom();\n+            sr.nextBytes(data);\n+            critical = isCrit;\n+        }\n+\n+        @Override\n+        public String getId() {\n+            return oid.toString();\n+        }\n+\n+        @Override\n+        public boolean isCritical() {\n+            return critical;\n+        }\n+\n+        @Override\n+        public byte[] getValue() {\n+            return data.clone();\n+        }\n+\n+        @Override\n+        public void encode(OutputStream out) throws IOException {\n+            Objects.requireNonNull(out, \"Non-null OutputStream required\");\n+\n+            DerOutputStream dos1 = new DerOutputStream();\n+            DerOutputStream dos2 = new DerOutputStream();\n+\n+            dos1.putOID(oid);\n+            if (critical) {\n+                dos1.putBoolean(critical);\n+            }\n+            dos1.putOctetString(data);\n+\n+            dos2.write(DerValue.tag_Sequence, dos1);\n+            out.write(dos2.toByteArray());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/OCSP\/GetAndPostTests.java","additions":264,"deletions":0,"binary":false,"changes":264,"status":"added"},{"patch":"@@ -710,1 +710,0 @@\n-                log(\"Received incoming connection from \" + peerSockAddr);\n@@ -717,0 +716,2 @@\n+                        log(\"Received incoming HTTP \" + headerTokens[0] +\n+                                \" from \" + peerSockAddr);\n@@ -719,1 +720,1 @@\n-                                    ocspReq = parseHttpOcspPost(in);\n+                                ocspReq = parseHttpOcspPost(in);\n@@ -722,3 +723,2 @@\n-                                \/\/ req = parseHttpOcspGet(in);\n-                                \/\/ TODO implement the GET parsing\n-                                throw new IOException(\"GET method unsupported\");\n+                                ocspReq = parseHttpOcspGet(headerTokens);\n+                                break;\n@@ -847,0 +847,24 @@\n+         * Parse the incoming HTTP GET of an OCSP Request.\n+         *\n+         * @param headerTokens the individual String tokens from the first\n+         * line of the HTTP GET.\n+         *\n+         * @return the OCSP Request as a {@code LocalOcspRequest}\n+         *\n+         * @throws IOException if there are network related issues or problems\n+         * occur during parsing of the OCSP request.\n+         * @throws CertificateException if one or more of the certificates in\n+         * the OCSP request cannot be read\/parsed.\n+         *\/\n+        private LocalOcspRequest parseHttpOcspGet(String[] headerTokens)\n+                throws IOException, CertificateException {\n+            \/\/ We have already established headerTokens[0] to be \"GET\".\n+            \/\/ We should have the URL-encoded base64 representation of the\n+            \/\/ OCSP request in headerTokens[1].  We need to strip any leading\n+            \/\/ \"\/\" off before decoding.\n+            return new LocalOcspRequest(Base64.getMimeDecoder().decode(\n+                    URLDecoder.decode(headerTokens[1].replaceAll(\"\/\", \"\"),\n+                            \"UTF-8\")));\n+        }\n+\n+        \/**\n","filename":"test\/jdk\/java\/security\/testlibrary\/SimpleOCSPServer.java","additions":29,"deletions":5,"binary":false,"changes":34,"status":"modified"}]}