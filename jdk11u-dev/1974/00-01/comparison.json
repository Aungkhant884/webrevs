{"files":[{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl;\n+\n+import java.io.PrintStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ServiceLoader;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ForkJoinTask;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+public class Diag {\n+\n+    public static void main(String[] args) {\n+        diag(System.out);\n+    }\n+\n+    static void diag(PrintStream out) {\n+        out.println(\"System properties\");\n+        out.println(\"=================\");\n+        out.println(\"os.name =         \" + System.getProperty(\"os.name\"));\n+        out.println(\"OSTYPE =          \" + System.getenv(\"OSTYPE\"));\n+        out.println(\"MSYSTEM =         \" + System.getenv(\"MSYSTEM\"));\n+        out.println(\"PWD =             \" + System.getenv(\"PWD\"));\n+        out.println(\"ConEmuPID =       \" + System.getenv(\"ConEmuPID\"));\n+        out.println(\"WSL_DISTRO_NAME = \" + System.getenv(\"WSL_DISTRO_NAME\"));\n+        out.println(\"WSL_INTEROP =     \" + System.getenv(\"WSL_INTEROP\"));\n+        out.println();\n+\n+        out.println(\"OSUtils\");\n+        out.println(\"=================\");\n+        out.println(\"IS_WINDOWS = \" + OSUtils.IS_WINDOWS);\n+        out.println(\"IS_CYGWIN =  \" + OSUtils.IS_CYGWIN);\n+        out.println(\"IS_MSYSTEM = \" + OSUtils.IS_MSYSTEM);\n+        out.println(\"IS_WSL =     \" + OSUtils.IS_WSL);\n+        out.println(\"IS_WSL1 =    \" + OSUtils.IS_WSL1);\n+        out.println(\"IS_WSL2 =    \" + OSUtils.IS_WSL2);\n+        out.println(\"IS_CONEMU =  \" + OSUtils.IS_CONEMU);\n+        out.println(\"IS_OSX =     \" + OSUtils.IS_OSX);\n+        out.println();\n+\n+        out.println(\"JnaSupport\");\n+        out.println(\"=================\");\n+        try {\n+            TerminalProvider provider = TerminalProvider.load(\"jna\");\n+            testProvider(out, provider);\n+        } catch (Throwable t) {\n+            out.println(\"JNA support not available: \" + t);\n+        }\n+        out.println();\n+\n+        out.println(\"JansiSupport\");\n+        out.println(\"=================\");\n+        try {\n+            TerminalProvider provider = TerminalProvider.load(\"jansi\");\n+            testProvider(out, provider);\n+        } catch (Throwable t) {\n+            out.println(\"Jansi support not available: \" + t);\n+        }\n+        out.println();\n+\n+        \/\/ Exec\n+        out.println(\"Exec Support\");\n+        out.println(\"=================\");\n+        try {\n+            TerminalProvider provider = TerminalProvider.load(\"exec\");\n+            testProvider(out, provider);\n+        } catch (Throwable t) {\n+            out.println(\"Exec support not available: \" + t);\n+        }\n+    }\n+\n+    private static void testProvider(PrintStream out, TerminalProvider provider) {\n+        try {\n+            out.println(\"StdIn stream =    \" + provider.isSystemStream(TerminalProvider.Stream.Input));\n+            out.println(\"StdOut stream =   \" + provider.isSystemStream(TerminalProvider.Stream.Output));\n+            out.println(\"StdErr stream =   \" + provider.isSystemStream(TerminalProvider.Stream.Error));\n+        } catch (Throwable t2) {\n+            out.println(\"Unable to check stream: \" + t2);\n+        }\n+        try {\n+            out.println(\"StdIn stream name =     \" + provider.systemStreamName(TerminalProvider.Stream.Input));\n+            out.println(\"StdOut stream name =    \" + provider.systemStreamName(TerminalProvider.Stream.Output));\n+            out.println(\"StdErr stream name =    \" + provider.systemStreamName(TerminalProvider.Stream.Error));\n+        } catch (Throwable t2) {\n+            out.println(\"Unable to check stream names: \" + t2);\n+        }\n+        try (Terminal terminal = provider.sysTerminal(\"diag\", \"xterm\", false, StandardCharsets.UTF_8,\n+                false, Terminal.SignalHandler.SIG_DFL, false, TerminalProvider.Stream.Output, input -> input) ) {\n+            if (terminal != null) {\n+                Attributes attr = terminal.enterRawMode();\n+                try {\n+                    out.println(\"Terminal size: \" + terminal.getSize());\n+                    ForkJoinTask<Integer> t = new ForkJoinPool(1).submit(() -> terminal.reader().read(1) );\n+                    int r = t.get(1000, TimeUnit.MILLISECONDS);\n+                    StringBuilder sb = new StringBuilder();\n+                    sb.append(\"The terminal seems to work: \");\n+                    sb.append(\"terminal \").append(terminal.getClass().getName());\n+                    if (terminal instanceof AbstractPosixTerminal) {\n+                        sb.append(\" with pty \").append(((AbstractPosixTerminal) terminal).getPty().getClass().getName());\n+                    }\n+                    out.println(sb);\n+                } catch (Throwable t3) {\n+                    out.println(\"Unable to read from terminal: \" + t3);\n+                    t3.printStackTrace();\n+                } finally {\n+                    terminal.setAttributes(attr);\n+                }\n+            } else {\n+                out.println(\"Not supported by provider\");\n+            }\n+        } catch (Throwable t2) {\n+            out.println(\"Unable to open terminal: \" + t2);\n+            t2.printStackTrace();\n+        }\n+    }\n+\n+    static <S> S load(Class<S> clazz) {\n+        return ServiceLoader.load(clazz, clazz.getClassLoader()).iterator().next();\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/Diag.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2022, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.exec;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.nio.charset.Charset;\n+import java.util.function.Function;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.impl.ExecPty;\n+import jdk.internal.org.jline.terminal.impl.ExternalTerminal;\n+import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.utils.ExecHelper;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+public class ExecTerminalProvider implements TerminalProvider\n+{\n+\n+    public String name() {\n+        return \"exec\";\n+    }\n+\n+    public Pty current(Stream consoleStream) throws IOException {\n+        return ExecPty.current(consoleStream);\n+    }\n+\n+    @Override\n+    public Terminal sysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        if (OSUtils.IS_WINDOWS) {\n+            return winSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n+        } else {\n+            return posixSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n+        }\n+    }\n+\n+    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                    boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                    Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper ) throws IOException {\n+        if (OSUtils.IS_CYGWIN || OSUtils.IS_MSYSTEM) {\n+            Pty pty = current(consoleStream);\n+            return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Terminal posixSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                     boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                     Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        Pty pty = current(consoleStream);\n+        return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler, inputStreamWrapper);\n+    }\n+\n+    @Override\n+    public Terminal newTerminal(String name, String type, InputStream in, OutputStream out,\n+                                Charset encoding, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Attributes attributes, Size size) throws IOException\n+    {\n+        return new ExternalTerminal(name, type, in, out, encoding, signalHandler, paused, attributes, size);\n+    }\n+\n+    @Override\n+    public boolean isSystemStream(Stream stream) {\n+        try {\n+            return isWindowsSystemStream(stream) || isPosixSystemStream(stream);\n+        } catch (Throwable t) {\n+            return false;\n+        }\n+    }\n+\n+    public boolean isWindowsSystemStream(Stream stream) {\n+        return systemStreamName( stream ) != null;\n+    }\n+\n+    public boolean isPosixSystemStream(Stream stream) {\n+        try {\n+            Process p = new ProcessBuilder(OSUtils.TEST_COMMAND, \"-t\", Integer.toString(stream.ordinal()))\n+                    .inheritIO().start();\n+            return p.waitFor() == 0;\n+        } catch (Throwable t) {\n+            \/\/ ignore\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public String systemStreamName(Stream stream) {\n+        try {\n+            ProcessBuilder.Redirect input = stream == Stream.Input\n+                                ? ProcessBuilder.Redirect.INHERIT\n+                                : getRedirect(stream == Stream.Output ? FileDescriptor.out : FileDescriptor.err);\n+            Process p = new ProcessBuilder(OSUtils.TTY_COMMAND).redirectInput(input).start();\n+            String result = ExecHelper.waitAndCapture(p);\n+            if (p.exitValue() == 0) {\n+                return result.trim();\n+            }\n+        } catch (Throwable t) {\n+            \/\/ ignore\n+        }\n+        return null;\n+    }\n+\n+    private ProcessBuilder.Redirect getRedirect(FileDescriptor fd) throws ReflectiveOperationException {\n+        \/\/ This is not really allowed, but this is the only way to redirect the output or error stream\n+        \/\/ to the input.  This is definitely not something you'd usually want to do, but in the case of\n+        \/\/ the `tty` utility, it provides a way to get\n+        Class<?> rpi = Class.forName(\"java.lang.ProcessBuilder$RedirectPipeImpl\");\n+        Constructor<?> cns = rpi.getDeclaredConstructor();\n+        cns.setAccessible(true);\n+        ProcessBuilder.Redirect input = (ProcessBuilder.Redirect) cns.newInstance();\n+        Field f = rpi.getDeclaredField(\"fd\");\n+        f.setAccessible(true);\n+        f.set(input, fd);\n+        return input;\n+    }\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/exec\/ExecTerminalProvider.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2022, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.spi;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.util.Properties;\n+import java.util.ServiceLoader;\n+import java.util.function.Function;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.impl.exec.ExecTerminalProvider;\n+\n+public interface TerminalProvider\n+{\n+\n+    enum Stream {\n+        Input,\n+        Output,\n+        Error\n+    }\n+\n+    String name();\n+\n+    Terminal sysTerminal(String name, String type, boolean ansiPassThrough,\n+                         Charset encoding, boolean nativeSignals,\n+                         Terminal.SignalHandler signalHandler, boolean paused,\n+                         Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException;\n+\n+    Terminal newTerminal(String name, String type,\n+                         InputStream masterInput, OutputStream masterOutput,\n+                         Charset encoding, Terminal.SignalHandler signalHandler,\n+                         boolean paused, Attributes attributes, Size size) throws IOException;\n+\n+    boolean isSystemStream(Stream stream);\n+\n+    String systemStreamName(Stream stream);\n+\n+    static TerminalProvider load(String name) throws IOException {\n+        switch (name) {\n+            case \"exec\": return new ExecTerminalProvider();\n+            case \"jna\": {\n+                try {\n+                    return (TerminalProvider) Class.forName(\"jdk.internal.org.jline.terminal.impl.jna.JnaTerminalProvider\").getConstructor().newInstance();\n+                } catch (ReflectiveOperationException t) {\n+                    throw new IOException(t);\n+                }\n+            }\n+        }\n+        ClassLoader cl = Thread.currentThread().getContextClassLoader();\n+        if (cl == null) {\n+            cl = ClassLoader.getSystemClassLoader();\n+        }\n+        InputStream is = cl.getResourceAsStream( \"META-INF\/services\/org\/jline\/terminal\/provider\/\" + name);\n+        if (is != null) {\n+            Properties props = new Properties();\n+            try {\n+                props.load(is);\n+                String className = props.getProperty(\"class\");\n+                if (className == null) {\n+                    throw new IOException(\"No class defined in terminal provider file \" + name);\n+                }\n+                Class<?> clazz = cl.loadClass( className );\n+                return (TerminalProvider) clazz.getConstructor().newInstance();\n+            } catch ( Exception e ) {\n+                throw new IOException(\"Unable to load terminal provider \" + name, e);\n+            }\n+        } else {\n+            throw new IOException(\"Unable to find terminal provider \" + name);\n+        }\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/terminal\/spi\/TerminalProvider.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2002-2018, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.utils;\n+\n+\/**\n+ * Helper class ti use during I\/O operations with an eventual timeout.\n+ *\/\n+public class Timeout {\n+\n+    private final long timeout;\n+    private long cur = 0;\n+    private long end = Long.MAX_VALUE;\n+\n+    public Timeout(long timeout) {\n+        this.timeout = timeout;\n+    }\n+\n+    public boolean isInfinite() {\n+        return timeout <= 0;\n+    }\n+\n+    public boolean isFinite() {\n+        return timeout > 0;\n+    }\n+\n+    public boolean elapsed() {\n+        if (timeout > 0) {\n+            cur = System.currentTimeMillis();\n+            if (end == Long.MAX_VALUE) {\n+                end = cur + timeout;\n+            }\n+            return cur >= end;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public long timeout() {\n+        return timeout > 0 ? Math.max(1, end - cur) : timeout;\n+    }\n+\n+}\n","filename":"src\/jdk.internal.le\/share\/classes\/jdk\/internal\/org\/jline\/utils\/Timeout.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2002-2020, the original author or authors.\n+ *\n+ * This software is distributable under the BSD license. See the terms of the\n+ * BSD license in the documentation provided with this software.\n+ *\n+ * https:\/\/opensource.org\/licenses\/BSD-3-Clause\n+ *\/\n+package jdk.internal.org.jline.terminal.impl.jna;\n+\n+import jdk.internal.org.jline.terminal.Attributes;\n+import jdk.internal.org.jline.terminal.Size;\n+import jdk.internal.org.jline.terminal.Terminal;\n+import jdk.internal.org.jline.terminal.impl.PosixPtyTerminal;\n+import jdk.internal.org.jline.terminal.impl.PosixSysTerminal;\n+import jdk.internal.org.jline.terminal.impl.jna.win.JnaWinSysTerminal;\n+import jdk.internal.org.jline.terminal.spi.TerminalProvider;\n+import jdk.internal.org.jline.terminal.spi.Pty;\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.util.function.Function;\n+\n+public class JnaTerminalProvider implements TerminalProvider\n+{\n+    @Override\n+    public String name() {\n+        return \"jna\";\n+    }\n+\n+\/\/    public Pty current(TerminalProvider.Stream console) throws IOException {\n+\/\/        return JnaNativePty.current(console);\n+\/\/    }\n+\/\/\n+\/\/    public Pty open(Attributes attributes, Size size) throws IOException {\n+\/\/        return JnaNativePty.open(attributes, size);\n+\/\/    }\n+\n+    @Override\n+    public Terminal sysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Stream consoleStream, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        if (OSUtils.IS_WINDOWS) {\n+            return winSysTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, consoleStream, inputStreamWrapper );\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public Terminal winSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+                                   boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+                                   Stream console, Function<InputStream, InputStream> inputStreamWrapper) throws IOException {\n+        return JnaWinSysTerminal.createTerminal(name, type, ansiPassThrough, encoding, nativeSignals, signalHandler, paused, console, inputStreamWrapper);\n+    }\n+\n+\/\/    public Terminal posixSysTerminal(String name, String type, boolean ansiPassThrough, Charset encoding,\n+\/\/                                     boolean nativeSignals, Terminal.SignalHandler signalHandler, boolean paused,\n+\/\/                                     Stream consoleStream) throws IOException {\n+\/\/        Pty pty = current(consoleStream);\n+\/\/        return new PosixSysTerminal(name, type, pty, encoding, nativeSignals, signalHandler);\n+\/\/    }\n+\n+    @Override\n+    public Terminal newTerminal(String name, String type, InputStream in, OutputStream out,\n+                                Charset encoding, Terminal.SignalHandler signalHandler, boolean paused,\n+                                Attributes attributes, Size size) throws IOException\n+    {\n+\/\/        Pty pty = open(attributes, size);\n+\/\/        return new PosixPtyTerminal(name, type, pty, in, out, encoding, signalHandler, paused);\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean isSystemStream(Stream stream) {\n+        try {\n+            if (OSUtils.IS_WINDOWS) {\n+                return isWindowsSystemStream(stream);\n+            } else {\n+\/\/                return isPosixSystemStream(stream);\n+                return false;\n+            }\n+        } catch (Throwable t) {\n+            return false;\n+        }\n+    }\n+\n+    public boolean isWindowsSystemStream(Stream stream) {\n+        return JnaWinSysTerminal.isWindowsSystemStream(stream);\n+    }\n+\n+\/\/    public boolean isPosixSystemStream(Stream stream) {\n+\/\/        return JnaNativePty.isPosixSystemStream(stream);\n+\/\/    }\n+\n+    @Override\n+    public String systemStreamName(Stream stream) {\n+\/\/        if (OSUtils.IS_WINDOWS) {\n+            return null;\n+\/\/        } else {\n+\/\/            return JnaNativePty.posixSystemStreamName(stream);\n+\/\/        }\n+    }\n+}\n","filename":"src\/jdk.internal.le\/windows\/classes\/jdk\/internal\/org\/jline\/terminal\/impl\/jna\/JnaTerminalProvider.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8304498\n+ * @summary Verify the OSUtils class is initialized properly\n+ * @modules jdk.internal.le\/jdk.internal.org.jline.utils\n+ *\/\n+\n+import jdk.internal.org.jline.utils.OSUtils;\n+\n+public class OSUtilsTest {\n+    public static void main(String... args) throws Exception {\n+        new OSUtilsTest().run();\n+    }\n+\n+    void run() throws Exception {\n+        runTestTest();\n+    }\n+\n+    void runTestTest() throws Exception {\n+        if (OSUtils.IS_WINDOWS) {\n+            return ; \/\/skip on Windows\n+        }\n+\n+        Process p = new ProcessBuilder(OSUtils.TEST_COMMAND, \"-z\", \"\").inheritIO().start();\n+        if (p.waitFor() != 0) {\n+            throw new AssertionError(\"Unexpected result!\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jline\/OSUtilsTest.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"}]}