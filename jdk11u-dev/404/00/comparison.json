{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import sun.net.util.IPAddressUtil;\n@@ -131,0 +132,3 @@\n+        if (laddr.isLinkLocalAddress()) {\n+            laddr = IPAddressUtil.toScopedAddress(laddr);\n+        }\n@@ -142,1 +146,13 @@\n-    protected abstract void send(DatagramPacket p) throws IOException;\n+    protected void send(DatagramPacket p) throws IOException {\n+        InetAddress orig = p.getAddress();\n+        if (orig.isLinkLocalAddress()) {\n+            InetAddress scoped = IPAddressUtil.toScopedAddress(orig);\n+            if (orig != scoped) {\n+                p = new DatagramPacket(p.getData(), p.getOffset(),\n+                                       p.getLength(), scoped, p.getPort());\n+            }\n+        }\n+        send0(p);\n+    }\n+\n+    protected abstract void send0(DatagramPacket p) throws IOException;\n@@ -152,0 +168,3 @@\n+        if (address.isLinkLocalAddress()) {\n+            address = IPAddressUtil.toScopedAddress(address);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/net\/AbstractPlainDatagramSocketImpl.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import sun.net.util.IPAddressUtil;\n@@ -165,1 +166,1 @@\n-            this.port = port;\n+            \/\/ recording this.address as supplied by caller before calling connect\n@@ -167,0 +168,4 @@\n+            this.port = port;\n+            if (address.isLinkLocalAddress()) {\n+                address = IPAddressUtil.toScopedAddress(address);\n+            }\n@@ -189,1 +194,1 @@\n-        this.port = port;\n+        \/\/ recording this.address as supplied by caller before calling connect\n@@ -191,0 +196,4 @@\n+        this.port = port;\n+        if (address.isLinkLocalAddress()) {\n+            address = IPAddressUtil.toScopedAddress(address);\n+        }\n@@ -221,0 +230,3 @@\n+            \/\/ recording this.address as supplied by caller before calling connect\n+            InetAddress ia = addr.getAddress();\n+            this.address = ia;\n@@ -222,3 +234,4 @@\n-            this.address = addr.getAddress();\n-\n-            connectToAddress(this.address, port, timeout);\n+            if (ia.isLinkLocalAddress()) {\n+                ia = IPAddressUtil.toScopedAddress(ia);\n+            }\n+            connectToAddress(ia, port, timeout);\n@@ -436,0 +449,3 @@\n+        if (address.isLinkLocalAddress()) {\n+            address = IPAddressUtil.toScopedAddress(address);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/net\/AbstractPlainSocketImpl.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -179,5 +179,0 @@\n-    \/*\n-     * cached scope_id - for link-local address use only.\n-     *\/\n-    private transient int cached_scope_id;  \/\/ 0\n-\n","filename":"src\/java.base\/share\/classes\/java\/net\/Inet6Address.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,14 @@\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketException;\n+import java.security.AccessController;\n+import java.security.PrivilegedExceptionAction;\n+import java.security.PrivilegedActionException;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n@@ -471,0 +485,71 @@\n+    \/**\n+     * Mapping from unscoped local Inet(6)Address to the same address\n+     * including the correct scope-id, determined from NetworkInterface.\n+     *\/\n+    private final static ConcurrentHashMap<InetAddress,InetAddress>\n+        cache = new ConcurrentHashMap<>();\n+\n+    \/**\n+     * Returns a scoped version of the supplied local, link-local ipv6 address\n+     * if that scope-id can be determined from local NetworkInterfaces.\n+     * If the address already has a scope-id or if the address is not local, ipv6\n+     * or link local, then the original address is returned.\n+     *\n+     * @param addr\n+     * @exception SocketException if the given ipv6 link local address is found\n+     *            on more than one local interface\n+     * @return\n+     *\/\n+    public static InetAddress toScopedAddress(InetAddress address)\n+        throws SocketException {\n+\n+        if (address instanceof Inet6Address && address.isLinkLocalAddress()\n+            && ((Inet6Address) address).getScopeId() == 0) {\n+\n+            InetAddress cached = null;\n+            try {\n+                cached = cache.computeIfAbsent(address, k -> findScopedAddress(k));\n+            } catch (UncheckedIOException e) {\n+                throw (SocketException)e.getCause();\n+            }\n+            return cached != null ? cached : address;\n+        } else {\n+            return address;\n+        }\n+    }\n+\n+    \/**\n+     * Same as above for InetSocketAddress\n+     *\/\n+    public static InetSocketAddress toScopedAddress(InetSocketAddress address)\n+        throws SocketException {\n+        InetAddress addr;\n+        InetAddress orig = address.getAddress();\n+        if ((addr = toScopedAddress(orig)) == orig) {\n+            return address;\n+        } else {\n+            return new InetSocketAddress(addr, address.getPort());\n+        }\n+    }\n+\n+    private static InetAddress findScopedAddress(InetAddress address) {\n+        PrivilegedExceptionAction<List<InetAddress>> pa = () -> NetworkInterface.networkInterfaces()\n+                .flatMap(NetworkInterface::inetAddresses)\n+                .filter(a -> (a instanceof Inet6Address)\n+                        && address.equals(a)\n+                        && ((Inet6Address) a).getScopeId() != 0)\n+                .collect(Collectors.toList());\n+        List<InetAddress> result;\n+        try {\n+            result = AccessController.doPrivileged(pa);\n+            var sz = result.size();\n+            if (sz == 0)\n+                return null;\n+            if (sz > 1)\n+                throw new UncheckedIOException(new SocketException(\n+                    \"Duplicate link local addresses: must specify scope-id\"));\n+            return result.get(0);\n+        } catch (PrivilegedActionException pae) {\n+            return null;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/util\/IPAddressUtil.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import sun.net.util.IPAddressUtil;\n@@ -520,0 +521,1 @@\n+                    InetAddress ia = isa.getAddress();\n@@ -521,1 +523,0 @@\n-                        InetAddress ia = isa.getAddress();\n@@ -528,0 +529,2 @@\n+                    if (ia.isLinkLocalAddress())\n+                        isa = IPAddressUtil.toScopedAddress(isa);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import sun.net.util.IPAddressUtil;\n@@ -455,0 +456,3 @@\n+        if (addr.isLinkLocalAddress()) {\n+            addr = IPAddressUtil.toScopedAddress(addr);\n+        }\n@@ -474,0 +478,3 @@\n+        if (remote.isLinkLocalAddress()) {\n+            remote = IPAddressUtil.toScopedAddress(remote);\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Net.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-jfieldID ia6_cachedscopeidID;\n@@ -68,2 +67,0 @@\n-        ia6_cachedscopeidID = (*env)->GetFieldID(env, ia6_class, \"cached_scope_id\", \"I\");\n-        CHECK_NULL(ia6_cachedscopeidID);\n","filename":"src\/java.base\/share\/native\/libnet\/Inet6Address.c","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -110,1 +110,0 @@\n-extern jfieldID ia6_cachedscopeidID;\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-    protected native void send(DatagramPacket p) throws IOException;\n+    protected native void send0(DatagramPacket p) throws IOException;\n","filename":"src\/java.base\/unix\/classes\/java\/net\/PlainDatagramSocketImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -706,4 +706,0 @@\n-#if defined(__linux__)\n-    } else {\n-        sa.sa6.sin6_scope_id = getDefaultIPv6Interface(&sa.sa6.sin6_addr);\n-#endif\n","filename":"src\/java.base\/unix\/native\/libnet\/Inet6AddressImpl.c","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,4 +82,0 @@\n-extern void setDefaultScopeID(JNIEnv *env, struct sockaddr *him);\n-extern int getDefaultScopeID(JNIEnv *env);\n-\n-\n@@ -203,1 +199,0 @@\n-    setDefaultScopeID(env, &sa.sa);\n@@ -269,2 +264,0 @@\n-    setDefaultScopeID(env, &rmtaddr.sa);\n-\n@@ -337,1 +330,1 @@\n- * Method:    send\n+ * Method:    send0\n@@ -341,1 +334,1 @@\n-Java_java_net_PlainDatagramSocketImpl_send(JNIEnv *env, jobject this,\n+Java_java_net_PlainDatagramSocketImpl_send0(JNIEnv *env, jobject this,\n@@ -396,1 +389,0 @@\n-    setDefaultScopeID(env, &rmtaddr.sa);\n@@ -2146,20 +2138,0 @@\n-\n-#ifdef __linux__\n-            \/*\n-             * On 2.4.8+ if we join a group with the interface set to 0\n-             * then the kernel records the interface it decides. This causes\n-             * subsequent leave groups to fail as there is no match. Thus we\n-             * pick the interface if there is a matching route.\n-             *\/\n-            if (index == 0) {\n-                int rt_index = getDefaultIPv6Interface(&(mname6.ipv6mr_multiaddr));\n-                if (rt_index > 0) {\n-                    index = rt_index;\n-                }\n-            }\n-#endif\n-#ifdef MACOSX\n-            if (family == AF_INET6 && index == 0) {\n-                index = getDefaultScopeID(env);\n-            }\n-#endif\n","filename":"src\/java.base\/unix\/native\/libnet\/PlainDatagramSocketImpl.c","additions":2,"deletions":30,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-extern void setDefaultScopeID(JNIEnv *env, struct sockaddr *him);\n-\n@@ -267,1 +265,0 @@\n-    setDefaultScopeID(env, &sa.sa);\n@@ -515,1 +512,0 @@\n-    setDefaultScopeID(env, &sa.sa);\n","filename":"src\/java.base\/unix\/native\/libnet\/PlainSocketImpl.c","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -447,274 +447,1 @@\n-#if defined(__linux__)\n-\n-\/* following code creates a list of addresses from the kernel\n- * routing table that are routed via the loopback address.\n- * We check all destination addresses against this table\n- * and override the scope_id field to use the relevant value for \"lo\"\n- * in order to work-around the Linux bug that prevents packets destined\n- * for certain local addresses from being sent via a physical interface.\n- *\/\n-\n-struct loopback_route {\n-    struct in6_addr addr; \/* destination address *\/\n-    int plen; \/* prefix length *\/\n-};\n-\n-static struct loopback_route *loRoutes = 0;\n-static int nRoutes = 0; \/* number of routes *\/\n-static int loRoutes_size = 16; \/* initial size *\/\n-static int lo_scope_id = 0;\n-\n-static void initLoopbackRoutes();\n-\n-void printAddr (struct in6_addr *addr) {\n-    int i;\n-    for (i=0; i<16; i++) {\n-        printf (\"%02x\", addr->s6_addr[i]);\n-    }\n-    printf (\"\\n\");\n-}\n-\n-static jboolean needsLoopbackRoute (struct in6_addr* dest_addr) {\n-    int byte_count;\n-    int extra_bits, i;\n-    struct loopback_route *ptr;\n-\n-    if (loRoutes == 0) {\n-        initLoopbackRoutes();\n-    }\n-\n-    for (ptr = loRoutes, i=0; i<nRoutes; i++, ptr++) {\n-        struct in6_addr *target_addr=&ptr->addr;\n-        int dest_plen = ptr->plen;\n-        byte_count = dest_plen >> 3;\n-        extra_bits = dest_plen & 0x3;\n-\n-        if (byte_count > 0) {\n-            if (memcmp(target_addr, dest_addr, byte_count)) {\n-                continue;  \/* no match *\/\n-            }\n-        }\n-\n-        if (extra_bits > 0) {\n-            unsigned char c1 = ((unsigned char *)target_addr)[byte_count];\n-            unsigned char c2 = ((unsigned char *)&dest_addr)[byte_count];\n-            unsigned char mask = 0xff << (8 - extra_bits);\n-            if ((c1 & mask) != (c2 & mask)) {\n-                continue;\n-            }\n-        }\n-        return JNI_TRUE;\n-    }\n-    return JNI_FALSE;\n-}\n-\n-\n-static void initLoopbackRoutes() {\n-    FILE *f;\n-    char srcp[8][5];\n-    char hopp[8][5];\n-    int dest_plen, src_plen, use, refcnt, metric;\n-    unsigned long flags;\n-    char dest_str[40];\n-    struct in6_addr dest_addr;\n-    char device[16];\n-    struct loopback_route *loRoutesTemp;\n-\n-    if (loRoutes != 0) {\n-        free (loRoutes);\n-    }\n-    loRoutes = calloc (loRoutes_size, sizeof(struct loopback_route));\n-    if (loRoutes == 0) {\n-        return;\n-    }\n-    \/*\n-     * Scan \/proc\/net\/ipv6_route looking for a matching\n-     * route.\n-     *\/\n-    if ((f = fopen(\"\/proc\/net\/ipv6_route\", \"r\")) == NULL) {\n-        return ;\n-    }\n-    while (fscanf(f, \"%4s%4s%4s%4s%4s%4s%4s%4s %02x \"\n-                     \"%4s%4s%4s%4s%4s%4s%4s%4s %02x \"\n-                     \"%4s%4s%4s%4s%4s%4s%4s%4s \"\n-                     \"%08x %08x %08x %08lx %8s\",\n-                     dest_str, &dest_str[5], &dest_str[10], &dest_str[15],\n-                     &dest_str[20], &dest_str[25], &dest_str[30], &dest_str[35],\n-                     &dest_plen,\n-                     srcp[0], srcp[1], srcp[2], srcp[3],\n-                     srcp[4], srcp[5], srcp[6], srcp[7],\n-                     &src_plen,\n-                     hopp[0], hopp[1], hopp[2], hopp[3],\n-                     hopp[4], hopp[5], hopp[6], hopp[7],\n-                     &metric, &use, &refcnt, &flags, device) == 31) {\n-\n-        \/*\n-         * Some routes should be ignored\n-         *\/\n-        if ( (dest_plen < 0 || dest_plen > 128)  ||\n-             (src_plen != 0) ||\n-             (flags & (RTF_POLICY | RTF_FLOW)) ||\n-             ((flags & RTF_REJECT) && dest_plen == 0) ) {\n-            continue;\n-        }\n-\n-        \/*\n-         * Convert the destination address\n-         *\/\n-        dest_str[4] = ':';\n-        dest_str[9] = ':';\n-        dest_str[14] = ':';\n-        dest_str[19] = ':';\n-        dest_str[24] = ':';\n-        dest_str[29] = ':';\n-        dest_str[34] = ':';\n-        dest_str[39] = '\\0';\n-\n-        if (inet_pton(AF_INET6, dest_str, &dest_addr) < 0) {\n-            \/* not an Ipv6 address *\/\n-            continue;\n-        }\n-        if (strcmp(device, \"lo\") != 0) {\n-            \/* Not a loopback route *\/\n-            continue;\n-        } else {\n-            if (nRoutes == loRoutes_size) {\n-                loRoutesTemp = realloc (loRoutes, loRoutes_size *\n-                                        sizeof (struct loopback_route) * 2);\n-\n-                if (loRoutesTemp == 0) {\n-                    free(loRoutes);\n-                    loRoutes = NULL;\n-                    nRoutes = 0;\n-                    fclose (f);\n-                    return;\n-                }\n-                loRoutes=loRoutesTemp;\n-                loRoutes_size *= 2;\n-            }\n-            memcpy (&loRoutes[nRoutes].addr,&dest_addr,sizeof(struct in6_addr));\n-            loRoutes[nRoutes].plen = dest_plen;\n-            nRoutes ++;\n-        }\n-    }\n-\n-    fclose (f);\n-    {\n-        \/* now find the scope_id for \"lo\" *\/\n-\n-        char devname[21];\n-        char addr6p[8][5];\n-        int plen, scope, dad_status, if_idx;\n-\n-        if ((f = fopen(\"\/proc\/net\/if_inet6\", \"r\")) != NULL) {\n-            while (fscanf(f, \"%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\\n\",\n-                      addr6p[0], addr6p[1], addr6p[2], addr6p[3],\n-                      addr6p[4], addr6p[5], addr6p[6], addr6p[7],\n-                  &if_idx, &plen, &scope, &dad_status, devname) == 13) {\n-\n-                if (strcmp(devname, \"lo\") == 0) {\n-                    \/*\n-                     * Found - so just return the index\n-                     *\/\n-                    fclose(f);\n-                    lo_scope_id = if_idx;\n-                    return;\n-                }\n-            }\n-            fclose(f);\n-        }\n-    }\n-}\n-\n-\/*\n- * Following is used for binding to local addresses. Equivalent\n- * to code above, for bind().\n- *\/\n-\n-struct localinterface {\n-    int index;\n-    char localaddr [16];\n-};\n-\n-static struct localinterface *localifs = 0;\n-static int localifsSize = 0;    \/* size of array *\/\n-static int nifs = 0;            \/* number of entries used in array *\/\n-\n-\/* not thread safe: make sure called once from one thread *\/\n-\n-static void initLocalIfs () {\n-    FILE *f;\n-    unsigned char staddr [16];\n-    char ifname [33];\n-    struct localinterface *lif=0;\n-    int index, x1, x2, x3;\n-    unsigned int u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,ua,ub,uc,ud,ue,uf;\n-\n-    if ((f = fopen(\"\/proc\/net\/if_inet6\", \"r\")) == NULL) {\n-        return ;\n-    }\n-    while (fscanf (f, \"%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x%2x \"\n-                \"%d %x %x %x %32s\",&u0,&u1,&u2,&u3,&u4,&u5,&u6,&u7,\n-                &u8,&u9,&ua,&ub,&uc,&ud,&ue,&uf,\n-                &index, &x1, &x2, &x3, ifname) == 21) {\n-        staddr[0] = (unsigned char)u0;\n-        staddr[1] = (unsigned char)u1;\n-        staddr[2] = (unsigned char)u2;\n-        staddr[3] = (unsigned char)u3;\n-        staddr[4] = (unsigned char)u4;\n-        staddr[5] = (unsigned char)u5;\n-        staddr[6] = (unsigned char)u6;\n-        staddr[7] = (unsigned char)u7;\n-        staddr[8] = (unsigned char)u8;\n-        staddr[9] = (unsigned char)u9;\n-        staddr[10] = (unsigned char)ua;\n-        staddr[11] = (unsigned char)ub;\n-        staddr[12] = (unsigned char)uc;\n-        staddr[13] = (unsigned char)ud;\n-        staddr[14] = (unsigned char)ue;\n-        staddr[15] = (unsigned char)uf;\n-        nifs ++;\n-        if (nifs > localifsSize) {\n-            localifs = (struct localinterface *) realloc (\n-                        localifs, sizeof (struct localinterface)* (localifsSize+5));\n-            if (localifs == 0) {\n-                nifs = 0;\n-                fclose (f);\n-                return;\n-            }\n-            lif = localifs + localifsSize;\n-            localifsSize += 5;\n-        } else {\n-            lif ++;\n-        }\n-        memcpy (lif->localaddr, staddr, 16);\n-        lif->index = index;\n-    }\n-    fclose (f);\n-}\n-\n-\/* return the scope_id (interface index) of the\n- * interface corresponding to the given address\n- * returns 0 if no match found\n- *\/\n-\n-static int getLocalScopeID (char *addr) {\n-    struct localinterface *lif;\n-    int i;\n-    if (localifs == 0) {\n-        initLocalIfs();\n-    }\n-    for (i=0, lif=localifs; i<nifs; i++, lif++) {\n-        if (memcmp (addr, lif->localaddr, 16) == 0) {\n-            return lif->index;\n-        }\n-    }\n-    return 0;\n-}\n-\n-void platformInit () {\n-    initLoopbackRoutes();\n-    initLocalIfs();\n-}\n-\n-#elif defined(_AIX)\n+#if defined(_AIX)\n@@ -806,58 +533,0 @@\n-#ifdef __linux__\n-        \/*\n-         * On Linux if we are connecting to a link-local address\n-         * we need to specify the interface in the scope_id (2.4 kernel only)\n-         *\n-         * If the scope was cached then we use the cached value. If not cached but\n-         * specified in the Inet6Address we use that, but we first check if the\n-         * address needs to be routed via the loopback interface. In this case,\n-         * we override the specified value with that of the loopback interface.\n-         * If no cached value exists and no value was specified by user, then\n-         * we try to determine a value from the routing table. In all these\n-         * cases the used value is cached for further use.\n-         *\/\n-        if (IN6_IS_ADDR_LINKLOCAL(&sa->sa6.sin6_addr)) {\n-            unsigned int cached_scope_id = 0, scope_id = 0;\n-\n-            if (ia6_cachedscopeidID) {\n-                cached_scope_id = (int)(*env)->GetIntField(env, iaObj, ia6_cachedscopeidID);\n-                \/* if cached value exists then use it. Otherwise, check\n-                 * if scope is set in the address.\n-                 *\/\n-                if (!cached_scope_id) {\n-                    if (ia6_scopeidID) {\n-                        scope_id = getInet6Address_scopeid(env, iaObj);\n-                    }\n-                    if (scope_id != 0) {\n-                        \/* check user-specified value for loopback case\n-                         * that needs to be overridden\n-                         *\/\n-                        if (kernelIsV24() && needsLoopbackRoute(&sa->sa6.sin6_addr)) {\n-                            cached_scope_id = lo_scope_id;\n-                            (*env)->SetIntField(env, iaObj, ia6_cachedscopeidID, cached_scope_id);\n-                        }\n-                    } else {\n-                        \/*\n-                         * Otherwise consult the IPv6 routing tables to\n-                         * try determine the appropriate interface.\n-                         *\/\n-                        if (kernelIsV24()) {\n-                            cached_scope_id = getDefaultIPv6Interface(&sa->sa6.sin6_addr);\n-                        } else {\n-                            cached_scope_id = getLocalScopeID((char *)&(sa->sa6.sin6_addr));\n-                            if (cached_scope_id == 0) {\n-                                cached_scope_id = getDefaultIPv6Interface(&sa->sa6.sin6_addr);\n-                            }\n-                        }\n-                        (*env)->SetIntField(env, iaObj, ia6_cachedscopeidID, cached_scope_id);\n-                    }\n-                }\n-            }\n-\n-            \/*\n-             * If we have a scope_id use the extended form\n-             * of sockaddr_in6.\n-             *\/\n-            sa->sa6.sin6_scope_id = cached_scope_id == 0 ? scope_id : cached_scope_id;\n-        }\n-#else\n@@ -870,1 +539,0 @@\n-#endif\n@@ -1004,152 +672,0 @@\n-\/*\n- * Determine the default interface for an IPv6 address.\n- *\n- * 1. Scans \/proc\/net\/ipv6_route for a matching route\n- *    (eg: fe80::\/10 or a route for the specific address).\n- *    This will tell us the interface to use (eg: \"eth0\").\n- *\n- * 2. Lookup \/proc\/net\/if_inet6 to map the interface\n- *    name to an interface index.\n- *\n- * Returns :-\n- *      -1 if error\n- *       0 if no matching interface\n- *      >1 interface index to use for the link-local address.\n- *\/\n-#if defined(__linux__)\n-int getDefaultIPv6Interface(struct in6_addr *target_addr) {\n-    FILE *f;\n-    char srcp[8][5];\n-    char hopp[8][5];\n-    int dest_plen, src_plen, use, refcnt, metric;\n-    unsigned long flags;\n-    char dest_str[40];\n-    struct in6_addr dest_addr;\n-    char device[16];\n-    jboolean match = JNI_FALSE;\n-\n-    \/*\n-     * Scan \/proc\/net\/ipv6_route looking for a matching\n-     * route.\n-     *\/\n-    if ((f = fopen(\"\/proc\/net\/ipv6_route\", \"r\")) == NULL) {\n-        return -1;\n-    }\n-    while (fscanf(f, \"%4s%4s%4s%4s%4s%4s%4s%4s %02x \"\n-                     \"%4s%4s%4s%4s%4s%4s%4s%4s %02x \"\n-                     \"%4s%4s%4s%4s%4s%4s%4s%4s \"\n-                     \"%08x %08x %08x %08lx %8s\",\n-                     dest_str, &dest_str[5], &dest_str[10], &dest_str[15],\n-                     &dest_str[20], &dest_str[25], &dest_str[30], &dest_str[35],\n-                     &dest_plen,\n-                     srcp[0], srcp[1], srcp[2], srcp[3],\n-                     srcp[4], srcp[5], srcp[6], srcp[7],\n-                     &src_plen,\n-                     hopp[0], hopp[1], hopp[2], hopp[3],\n-                     hopp[4], hopp[5], hopp[6], hopp[7],\n-                     &metric, &use, &refcnt, &flags, device) == 31) {\n-\n-        \/*\n-         * Some routes should be ignored\n-         *\/\n-        if ( (dest_plen < 0 || dest_plen > 128)  ||\n-             (src_plen != 0) ||\n-             (flags & (RTF_POLICY | RTF_FLOW)) ||\n-             ((flags & RTF_REJECT) && dest_plen == 0) ) {\n-            continue;\n-        }\n-\n-        \/*\n-         * Convert the destination address\n-         *\/\n-        dest_str[4] = ':';\n-        dest_str[9] = ':';\n-        dest_str[14] = ':';\n-        dest_str[19] = ':';\n-        dest_str[24] = ':';\n-        dest_str[29] = ':';\n-        dest_str[34] = ':';\n-        dest_str[39] = '\\0';\n-\n-        if (inet_pton(AF_INET6, dest_str, &dest_addr) < 0) {\n-            \/* not an Ipv6 address *\/\n-            continue;\n-        } else {\n-            \/*\n-             * The prefix len (dest_plen) indicates the number of bits we\n-             * need to match on.\n-             *\n-             * dest_plen \/ 8    => number of bytes to match\n-             * dest_plen % 8    => number of additional bits to match\n-             *\n-             * eg: fe80::\/10 => match 1 byte + 2 additional bits in the\n-             *                  the next byte.\n-             *\/\n-            int byte_count = dest_plen >> 3;\n-            int extra_bits = dest_plen & 0x3;\n-\n-            if (byte_count > 0) {\n-                if (memcmp(target_addr, &dest_addr, byte_count)) {\n-                    continue;  \/* no match *\/\n-                }\n-            }\n-\n-            if (extra_bits > 0) {\n-                unsigned char c1 = ((unsigned char *)target_addr)[byte_count];\n-                unsigned char c2 = ((unsigned char *)&dest_addr)[byte_count];\n-                unsigned char mask = 0xff << (8 - extra_bits);\n-                if ((c1 & mask) != (c2 & mask)) {\n-                    continue;\n-                }\n-            }\n-\n-            \/*\n-             * We have a match\n-             *\/\n-            match = JNI_TRUE;\n-            break;\n-        }\n-    }\n-    fclose(f);\n-\n-    \/*\n-     * If there's a match then we lookup the interface\n-     * index.\n-     *\/\n-    if (match) {\n-        char devname[21];\n-        char addr6p[8][5];\n-        int plen, scope, dad_status, if_idx;\n-\n-        if ((f = fopen(\"\/proc\/net\/if_inet6\", \"r\")) != NULL) {\n-            while (fscanf(f, \"%4s%4s%4s%4s%4s%4s%4s%4s %08x %02x %02x %02x %20s\\n\",\n-                      addr6p[0], addr6p[1], addr6p[2], addr6p[3],\n-                      addr6p[4], addr6p[5], addr6p[6], addr6p[7],\n-                  &if_idx, &plen, &scope, &dad_status, devname) == 13) {\n-\n-                if (strcmp(devname, device) == 0) {\n-                    \/*\n-                     * Found - so just return the index\n-                     *\/\n-                    fclose(f);\n-                    return if_idx;\n-                }\n-            }\n-            fclose(f);\n-        } else {\n-            \/*\n-             * Couldn't open \/proc\/net\/if_inet6\n-             *\/\n-            return -1;\n-        }\n-    }\n-\n-    \/*\n-     * If we get here it means we didn't there wasn't any\n-     * route or we couldn't get the index of the interface.\n-     *\/\n-    return 0;\n-}\n-#endif\n-\n-\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.c","additions":1,"deletions":485,"binary":false,"changes":486,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n-int getDefaultIPv6Interface(struct in6_addr *target_addr);\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-    protected void send(DatagramPacket p) throws IOException {\n+    protected void send0(DatagramPacket p) throws IOException {\n","filename":"src\/java.base\/windows\/classes\/java\/net\/DualStackPlainDatagramSocketImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-    protected native void send(DatagramPacket p) throws IOException;\n+    protected native void send0(DatagramPacket p) throws IOException;\n","filename":"src\/java.base\/windows\/classes\/java\/net\/TwoStacksPlainDatagramSocketImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -418,1 +418,1 @@\n- * Method:    send\n+ * Method:    send0\n@@ -422,1 +422,1 @@\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_send\n+Java_java_net_TwoStacksPlainDatagramSocketImpl_send0\n","filename":"src\/java.base\/windows\/native\/libnet\/TwoStacksPlainDatagramSocketImpl.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -738,31 +738,0 @@\n-\/*\n- * Determine the default interface for an IPv6 address.\n- *\n- * Returns :-\n- *      0 if error\n- *      > 0 interface index to use\n- *\/\n-jint getDefaultIPv6Interface(JNIEnv *env, struct sockaddr_in6 *target_addr)\n-{\n-    int ret;\n-    DWORD b;\n-    struct sockaddr_in6 route;\n-    SOCKET fd = socket(AF_INET6, SOCK_STREAM, 0);\n-    if (fd == INVALID_SOCKET) {\n-        return 0;\n-    }\n-\n-    ret = WSAIoctl(fd, SIO_ROUTING_INTERFACE_QUERY,\n-                   (void *)target_addr, sizeof(struct sockaddr_in6),\n-                   (void *)&route, sizeof(struct sockaddr_in6),\n-                   &b, 0, 0);\n-    if (ret == SOCKET_ERROR) {\n-        \/\/ error\n-        closesocket(fd);\n-        return 0;\n-    } else {\n-        closesocket(fd);\n-        return route.sin6_scope_id;\n-    }\n-}\n-\n@@ -806,1 +775,1 @@\n-        unsigned int scopeid = 0, cached_scope_id = 0;\n+        unsigned int scopeid = 0;\n@@ -828,1 +797,0 @@\n-            cached_scope_id = (unsigned int)(*env)->GetIntField(env, iaObj, ia6_cachedscopeidID);\n@@ -833,8 +801,1 @@\n-        if ((family == java_net_InetAddress_IPv6) &&\n-            IN6_IS_ADDR_LINKLOCAL(&sa->sa6.sin6_addr) &&\n-            (!scopeid && !cached_scope_id))\n-        {\n-            cached_scope_id = getDefaultIPv6Interface(env, &sa->sa6);\n-            (*env)->SetIntField(env, iaObj, ia6_cachedscopeidID, cached_scope_id);\n-        }\n-        sa->sa6.sin6_scope_id = scopeid == 0 ? cached_scope_id : scopeid;\n+        sa->sa6.sin6_scope_id = scopeid;\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.c","additions":2,"deletions":41,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8216417\n+ * @summary cleanup of IPv6 scope-id handling\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.NetworkConfiguration\n+ * @run main\/othervm Scoping\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.DatagramChannel;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.util.Enumeration;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import jdk.test.lib.NetworkConfiguration;\n+\n+public class Scoping {\n+\n+    interface ThrowingConsumer<T> {\n+        public void accept(T t) throws Exception;\n+    }\n+\n+    static List<ThrowingConsumer<InetSocketAddress>> targets = List.of(\n+        \/* 0 *\/  (a) -> {Socket s = new Socket(); s.bind(a);s.close();},\n+        \/* 1 *\/  (a) -> {ServerSocket s = new ServerSocket(); s.bind(a);s.close();},\n+        \/* 2 *\/  (a) -> {DatagramSocket s = new DatagramSocket(null); s.bind(a); s.close();},\n+        \/* 3 *\/  (a) -> {MulticastSocket s = new MulticastSocket(null); s.bind(a); s.close();},\n+        \/* 4 *\/  (a) -> {SocketChannel s = SocketChannel.open(); s.bind(a);s.close();},\n+        \/* 5 *\/  (a) -> {ServerSocketChannel s = ServerSocketChannel.open(); s.bind(a);s.close();},\n+        \/* 6 *\/  (a) -> {DatagramChannel s = DatagramChannel.open(); s.bind(a); s.close();},\n+        \/* 7 *\/  (a) -> {SocketChannel s = SocketChannel.open(); s.socket().bind(a);s.close();},\n+        \/* 8 *\/  (a) -> {ServerSocketChannel s = ServerSocketChannel.open(); s.socket().bind(a);s.close();},\n+        \/* 9 *\/  (a) -> {DatagramChannel s = DatagramChannel.open(); s.socket().bind(a); s.close();},\n+        \/* 10 *\/ (a) -> {socketTest(a);},\n+        \/* 11 *\/ (a) -> {dgSocketTest(a, false);},\n+        \/* 12 *\/ (a) -> {dgSocketTest(a, true);},\n+        \/* 13 *\/ (a) -> {dgChannelTest(a, false);},\n+        \/* 14 *\/ (a) -> {dgChannelTest(a, true);}\n+    );\n+\n+    static List<Inet6Address> getLinkLocalAddrs() throws IOException {\n+        return NetworkConfiguration.probe()\n+                   .ip6Addresses()\n+                   .filter(Inet6Address::isLinkLocalAddress)\n+                   .collect(Collectors.toList());\n+    }\n+\n+    static void compare(InetSocketAddress a, InetSocketAddress b) {\n+        Inet6Address a1 = (Inet6Address)a.getAddress();\n+        Inet6Address b1 = (Inet6Address)b.getAddress();\n+        compare (a1, b1);\n+    }\n+\n+    static void compare(InetAddress a, InetAddress b) {\n+        Inet6Address a1 = (Inet6Address)a;\n+        Inet6Address b1 = (Inet6Address)b;\n+        if (!a1.equals(b1)) {\n+            System.out.printf(\"%s != %s\\n\", a1, b1);\n+            throw new RuntimeException(\"Addresses not the same\");\n+        }\n+\n+        if (!a1.getHostAddress().equals(b1.getHostAddress())) {\n+            System.out.printf(\"%s != %s\\n\", a1, b1);\n+            if (a1.getScopeId() != b1.getScopeId())\n+                throw new RuntimeException(\"Scope ids not the same\");\n+        }\n+    }\n+\n+    static void socketTest(InetSocketAddress a) throws Exception {\n+        System.out.printf(\"socketTest: address %s\\n\", a);\n+        try (ServerSocket server = new ServerSocket(0, 5, a.getAddress())) {\n+            InetAddress saddr = server.getInetAddress();\n+            int port = server.getLocalPort();\n+            Socket client = new Socket(saddr, port);\n+            compare(client.getInetAddress(), saddr);\n+            try {\n+                client.close();\n+            } catch (IOException e) {}\n+        }\n+    }\n+\n+    static void dgSocketTest(InetSocketAddress a, boolean connect) throws Exception {\n+        try (DatagramSocket s = new DatagramSocket(null)) {\n+            System.out.println(\"dgSocketTest: \" + a);\n+            s.bind(a);\n+            String t = \"Hello world\";\n+            DatagramPacket rx = new DatagramPacket(new byte[128], 128);\n+            int port = s.getLocalPort();\n+            InetSocketAddress dest = new InetSocketAddress(a.getAddress(), port);\n+            DatagramPacket tx = new DatagramPacket(t.getBytes(\"ISO8859_1\"), t.length(), dest);\n+            if (connect) {\n+                s.connect(dest);\n+                System.out.println(\"dgSocketTest: connect remote addr = \" + s.getRemoteSocketAddress());\n+                compare(a, (InetSocketAddress)s.getRemoteSocketAddress());\n+            }\n+            s.send(tx);\n+            s.receive(rx);\n+            String t1 = new String(rx.getData(), rx.getOffset(), rx.getLength(), \"ISO8859_1\");\n+            if (!t1.equals(t))\n+                throw new RuntimeException(\"Packets not equal\");\n+        }\n+    }\n+\n+    static void dgChannelTest(InetSocketAddress a, boolean connect) throws Exception {\n+        try (DatagramChannel s = DatagramChannel.open()) {\n+            System.out.println(\"dgChannelTest: \" + a);\n+            s.bind(a);\n+            String t = \"Hello world\";\n+            ByteBuffer rx = ByteBuffer.allocate(128);\n+            int port = ((InetSocketAddress)s.getLocalAddress()).getPort();\n+            InetSocketAddress dest = new InetSocketAddress(a.getAddress(), port);\n+            ByteBuffer tx = ByteBuffer.wrap(t.getBytes(\"ISO8859_1\"));\n+            if (connect) {\n+                s.connect(dest);\n+                System.out.println(\"dgChannelTest: connect remote addr = \" + s.getRemoteAddress());\n+                compare(a, (InetSocketAddress)s.getRemoteAddress());\n+            }\n+            s.send(tx, dest);\n+            s.receive(rx);\n+            rx.flip();\n+            String t1 = new String(rx.array(), 0, rx.limit(), \"ISO8859_1\");\n+            System.out.printf(\"rx : %s, data: %s\\n\", rx, t1);\n+            if (!t1.equals(t))\n+                throw new RuntimeException(\"Packets not equal\");\n+        }\n+    }\n+\n+    static Inet6Address stripScope(Inet6Address address) {\n+        byte[] bytes = address.getAddress();\n+        InetAddress result = null;\n+        try {\n+            result = InetAddress.getByAddress(bytes);\n+        } catch (UnknownHostException e) {\n+            assert false;\n+        }\n+        return (Inet6Address)result;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        for (Inet6Address address : getLinkLocalAddrs()) {\n+            Inet6Address stripped = stripScope(address);\n+            InetSocketAddress s1 = new InetSocketAddress(address, 0);\n+            InetSocketAddress s2 = new InetSocketAddress(stripped, 0);\n+            System.out.println(\"Trying: \" + address);\n+            int count = 0, success = 0;\n+            for (ThrowingConsumer<InetSocketAddress> target : targets) {\n+                try {\n+                    target.accept(s1);\n+                    System.out.println(\"target \" + count + \" OK\");\n+                    \/\/ if that succeeds try s2 (the actual test)\n+                    try {\n+                        target.accept(s2);\n+                        success++;\n+                    } catch (IOException ee) {\n+                        String msg = \"Failed: \" + s2.toString() + \"count: \" + Integer.toString(count);\n+                        throw new RuntimeException (msg);\n+                    }\n+                } catch (IOException e) {\n+                    System.out.println(e.getMessage());\n+                    \/\/ OK\n+                }\n+                count++;\n+            }\n+            System.out.println(\"Succeeded with \" + success + \" binds\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/Inet6Address\/Scoping.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+\n+\/*\n+ * @test\n+ * @bug 8215294\n+ * @requires os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.NetworkConfiguration\n+ *        PromiscuousIPv6\n+ * @run main\/othervm PromiscuousIPv6\n+ * @key randomness\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.Inet6Address;\n+import java.net.InetSocketAddress;\n+import java.net.MulticastSocket;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.net.StandardSocketOptions;\n+import java.util.List;\n+import java.util.Random;\n+import jdk.test.lib.NetworkConfiguration;\n+import jtreg.SkippedException;\n+import static java.lang.System.out;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.stream.Collectors.toList;\n+\n+\/*\n+ * This test was created as a clone of the Promiscuous test and adapted for\n+ * IPv6 node-local and link-local multicast addresses on Linux.\n+ *\/\n+public class PromiscuousIPv6 {\n+\n+    static final Random rand = new Random();\n+\n+    static final int TIMEOUT =  5 * 1000; \/\/ 5 secs\n+\n+    static int sendDatagram(NetworkInterface nif, InetAddress group, int port)\n+        throws IOException\n+    {\n+        try (MulticastSocket mc = new MulticastSocket()) {\n+            mc.setOption(StandardSocketOptions.IP_MULTICAST_IF, nif);\n+\n+            int id = rand.nextInt();\n+            byte[] msg = Integer.toString(id).getBytes(UTF_8);\n+            DatagramPacket p = new DatagramPacket(msg, msg.length);\n+            p.setAddress(group);\n+            p.setPort(port);\n+\n+            out.printf(\"Sending datagram to: %s\/%d\\n\", group, port);\n+            mc.send(p);\n+            return id;\n+        }\n+    }\n+\n+    static void receiveDatagram(DatagramSocket mc, boolean datagramExpected, int id)\n+        throws IOException\n+    {\n+        byte[] ba = new byte[100];\n+        DatagramPacket p = new DatagramPacket(ba, ba.length);\n+        try {\n+            mc.receive(p);\n+            int recvId = Integer.parseInt(\n+                    new String(p.getData(), 0, p.getLength(), UTF_8));\n+            if (datagramExpected) {\n+                if (recvId != id)\n+                    throw new RuntimeException(\"Unexpected id, got \" + recvId\n+                                                       + \", expected: \" + id);\n+                out.printf(\"Received message as expected, %s\\n\", p.getAddress());\n+            } else {\n+                throw new RuntimeException(\"Unexpected message received, \"\n+                                                   + p.getAddress());\n+            }\n+        } catch (SocketTimeoutException e) {\n+            if (datagramExpected)\n+                throw new RuntimeException(\"Expected message not received, \"\n+                                                   + e.getMessage());\n+            else\n+                out.printf(\"Message not received, as expected\\n\");\n+        }\n+    }\n+\n+    static void test(NetworkInterface nif, InetAddress group1, InetAddress group2)\n+        throws IOException\n+    {\n+        \/\/ Bind addresses should include the same network interface \/ scope, so\n+        \/\/ as to not reply on the default route when there are multiple interfaces\n+        InetAddress bindAddr1 = Inet6Address.getByAddress(null, group1.getAddress(), nif);\n+        InetAddress bindAddr2 = Inet6Address.getByAddress(null, group2.getAddress(), nif);\n+\n+        try (MulticastSocket mc1 = new MulticastSocket(new InetSocketAddress(bindAddr1, 0));\n+             MulticastSocket mc2 = new MulticastSocket(new InetSocketAddress(bindAddr2, mc1.getLocalPort()))) {\n+\n+            final int port = mc1.getLocalPort();\n+            out.printf(\"Using port: %d\\n\", port);\n+\n+            mc1.setSoTimeout(TIMEOUT);\n+            mc2.setSoTimeout(TIMEOUT);\n+\n+            mc1.joinGroup(new InetSocketAddress(group1, 0), nif);\n+            out.printf(\"mc1 joined the MC group: %s\\n\", group1);\n+            mc2.joinGroup(new InetSocketAddress(group2, 0), nif);\n+            out.printf(\"mc2 joined the MC group: %s\\n\", group2);\n+\n+            out.printf(\"Sending datagram to: %s\/%d\\n\", group1, port);\n+            int id = sendDatagram(nif, group1, port);\n+\n+            \/\/ the packet should be received by mc1 only\n+            receiveDatagram(mc1, true, id);\n+            receiveDatagram(mc2, false, 0);\n+\n+\n+            out.printf(\"Sending datagram to: %s\/%d\\n\", group2, port);\n+            id = sendDatagram(nif, group2, port);\n+\n+            \/\/ the packet should be received by mc2 only\n+            receiveDatagram(mc2, true, id);\n+            receiveDatagram(mc1, false, 0);\n+\n+            mc1.leaveGroup(new InetSocketAddress(group1, 0), nif);\n+            mc2.leaveGroup(new InetSocketAddress(group2, 0), nif);\n+        }\n+    }\n+\n+    public static void main(String args[]) throws IOException {\n+        String os = System.getProperty(\"os.name\");\n+\n+        if (!os.equals(\"Linux\")) {\n+            throw new SkippedException(\"This test should be run only on Linux\");\n+        } else {\n+            String osVersion = System.getProperty(\"os.version\");\n+            String prefix = \"3.10.0\";\n+            if (osVersion.startsWith(prefix)) {\n+                throw new SkippedException(\n+                        String.format(\"The behavior under test is known NOT to work on '%s' kernels\", prefix));\n+            }\n+        }\n+\n+        NetworkConfiguration.printSystemConfiguration(System.out);\n+        List<NetworkInterface> nifs = NetworkConfiguration.probe()\n+              .ip6MulticastInterfaces()\n+              .collect(toList());\n+\n+        if (nifs.size() == 0) {\n+            throw new SkippedException(\n+                 \"No IPv6 interfaces that support multicast found\");\n+        }\n+\n+        InetAddress interfaceLocal1 = InetAddress.getByName(\"ff11::3.4.5.6\");\n+        InetAddress interfaceLocal2 = InetAddress.getByName(\"ff11::5.6.7.8\");\n+\n+        InetAddress linkLocal1 = InetAddress.getByName(\"ff12::4.5.6.7\");\n+        InetAddress linkLocal2 = InetAddress.getByName(\"ff12::7.8.9.10\");\n+\n+        for (NetworkInterface nif : nifs) {\n+            test(nif, interfaceLocal1, interfaceLocal2);\n+            test(nif, linkLocal1, linkLocal2);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/PromiscuousIPv6.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -70,1 +70,0 @@\n-                .map(B6521014::removeScope)\n","filename":"test\/jdk\/java\/net\/ipv6tests\/B6521014.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+\n+\/*\n+ * @test\n+ * @bug 8215294\n+ * @requires os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.NetworkConfiguration\n+ *        PromiscuousIPv6\n+ * @run main PromiscuousIPv6\n+ * @key randomness\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.net.*;\n+import java.util.*;\n+import java.io.IOException;\n+import jdk.test.lib.NetworkConfiguration;\n+import jtreg.SkippedException;\n+import static java.net.StandardProtocolFamily.*;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.stream.Collectors.toList;\n+\n+\/*\n+ * This test was created as a copy of the Promiscuous test and adapted for\n+ * IPv6 node-local and link-local multicast addresses on Linux.\n+ *\/\n+public class PromiscuousIPv6 {\n+\n+    static final Random rand = new Random();\n+\n+    static final ProtocolFamily UNSPEC = () -> \"UNSPEC\";\n+\n+    \/**\n+     * Sends a datagram to the given multicast group\n+     *\/\n+    static int sendDatagram(NetworkInterface nif,\n+                            InetAddress group,\n+                            int port)\n+            throws IOException\n+    {\n+        ProtocolFamily family = (group instanceof Inet6Address) ? INET6 : INET;\n+        DatagramChannel dc = DatagramChannel.open(family)\n+                .setOption(StandardSocketOptions.IP_MULTICAST_IF, nif);\n+        int id = rand.nextInt();\n+        byte[] msg = Integer.toString(id).getBytes(UTF_8);\n+        ByteBuffer buf = ByteBuffer.wrap(msg);\n+        System.out.format(\"Send message -> group %s (id=0x%x)\\n\",\n+                          group.getHostAddress(), id);\n+        dc.send(buf, new InetSocketAddress(group, port));\n+        dc.close();\n+        return id;\n+    }\n+\n+    \/**\n+     * Waits (with timeout) for datagram. The {@code datagramExpected}\n+     * parameter indicates whether a datagram is expected, and if\n+     * {@code true} then {@code id} is the identifier in the payload.\n+     *\/\n+    static void receiveDatagram(DatagramChannel dc,\n+                                String name,\n+                                boolean datagramExpected,\n+                                int id)\n+        throws IOException\n+    {\n+        System.out.println(\"Checking if received by \" + name);\n+\n+        Selector sel = Selector.open();\n+        dc.configureBlocking(false);\n+        dc.register(sel, SelectionKey.OP_READ);\n+        ByteBuffer buf = ByteBuffer.allocateDirect(100);\n+\n+        try {\n+            for (;;) {\n+                System.out.println(\"Waiting to receive message\");\n+                sel.select(5*1000);\n+                SocketAddress sa = dc.receive(buf);\n+\n+                \/\/ no datagram received\n+                if (sa == null) {\n+                    if (datagramExpected) {\n+                        throw new RuntimeException(\"Expected message not received\");\n+                    }\n+                    System.out.println(\"No message received (correct)\");\n+                    return;\n+                }\n+\n+                \/\/ datagram received\n+\n+                InetAddress sender = ((InetSocketAddress)sa).getAddress();\n+                buf.flip();\n+                byte[] bytes = new byte[buf.remaining()];\n+                buf.get(bytes);\n+                String s = new String(bytes, \"UTF-8\");\n+                int receivedId = -1;\n+                try {\n+                    receivedId = Integer.parseInt(s);\n+                    System.out.format(\"Received message from %s (id=0x%x)\\n\",\n+                                      sender, receivedId);\n+                } catch (NumberFormatException x) {\n+                    System.out.format(\"Received message from %s (msg=%s)\\n\", sender, s);\n+                }\n+\n+                if (!datagramExpected) {\n+                    if (receivedId == id)\n+                        throw new RuntimeException(\"Message not expected\");\n+                    System.out.println(\"Message ignored (has wrong id)\");\n+                } else {\n+                    if (receivedId == id) {\n+                        System.out.println(\"Message expected\");\n+                        return;\n+                    }\n+                    System.out.println(\"Message ignored (wrong sender)\");\n+                }\n+\n+                sel.selectedKeys().clear();\n+                buf.rewind();\n+            }\n+        } finally {\n+            sel.close();\n+        }\n+    }\n+\n+    static void test(ProtocolFamily family,\n+                     NetworkInterface nif,\n+                     InetAddress group1,\n+                     InetAddress group2)\n+            throws IOException\n+    {\n+\n+        System.out.format(\"%nTest family=%s%n\", family.name());\n+\n+        \/\/ Bind addresses should include the same network interface \/ scope, so\n+        \/\/ as to not reply on the default route when there are multiple interfaces\n+        InetAddress bindAddr1 = Inet6Address.getByAddress(null, group1.getAddress(), nif);\n+        InetAddress bindAddr2 = Inet6Address.getByAddress(null, group2.getAddress(), nif);\n+\n+        DatagramChannel dc1 = (family == UNSPEC) ?\n+                DatagramChannel.open() : DatagramChannel.open(family);\n+        DatagramChannel dc2 = (family == UNSPEC) ?\n+                DatagramChannel.open() : DatagramChannel.open(family);\n+\n+        try {\n+            dc1.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n+            dc2.setOption(StandardSocketOptions.SO_REUSEADDR, true);\n+\n+            dc1.bind(new InetSocketAddress(bindAddr1, 0));\n+            int port = dc1.socket().getLocalPort();\n+            dc2.bind(new InetSocketAddress(bindAddr2, port));\n+\n+            System.out.format(\"dc1 joining [%s]:%d @ %s\\n\",\n+                              group1.getHostAddress(), port, nif.getName());\n+            System.out.format(\"dc2 joining [%s]:%d @ %s\\n\",\n+                              group2.getHostAddress(), port, nif.getName());\n+\n+            dc1.join(group1, nif);\n+            dc2.join(group2, nif);\n+\n+            int id = sendDatagram(nif, group1, port);\n+\n+            receiveDatagram(dc1, \"dc1\", true, id);\n+            receiveDatagram(dc2, \"dc2\", false, id);\n+\n+            id = sendDatagram(nif, group2, port);\n+\n+            receiveDatagram(dc1, \"dc1\", false, id);\n+            receiveDatagram(dc2, \"dc2\", true, id);\n+\n+        } finally {\n+            dc1.close();\n+            dc2.close();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws IOException {\n+\n+        String os = System.getProperty(\"os.name\");\n+\n+        if (!os.equals(\"Linux\")) {\n+            throw new SkippedException(\"This test should be run only on Linux\");\n+        } else {\n+            String osVersion = System.getProperty(\"os.version\");\n+            String prefix = \"3.10.0\";\n+            if (osVersion.startsWith(prefix)) {\n+                throw new SkippedException(\n+                        String.format(\"The behavior under test is known NOT to work on '%s' kernels\", prefix));\n+            }\n+        }\n+\n+        NetworkConfiguration.printSystemConfiguration(System.out);\n+        List<NetworkInterface> nifs = NetworkConfiguration.probe()\n+                .ip6MulticastInterfaces()\n+                .collect(toList());\n+\n+        if (nifs.size() == 0) {\n+            throw new SkippedException(\n+                    \"No IPv6 interfaces that support multicast found\");\n+        }\n+\n+        InetAddress interfaceLocal1 = InetAddress.getByName(\"ff11::2.3.4.5\");\n+        InetAddress interfaceLocal2 = InetAddress.getByName(\"ff11::6.7.8.9\");\n+\n+        InetAddress linkLocal1 = InetAddress.getByName(\"ff12::2.3.4.5\");\n+        InetAddress linkLocal2 = InetAddress.getByName(\"ff12::6.7.8.9\");\n+\n+        for (NetworkInterface nif : nifs) {\n+            test(INET6, nif, interfaceLocal1, interfaceLocal2);\n+            test(INET6, nif, linkLocal1, linkLocal2);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/PromiscuousIPv6.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"}]}