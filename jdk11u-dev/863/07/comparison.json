{"files":[{"patch":"@@ -15,0 +15,4 @@\n+concurrency:\n+  group: ${{ github.workflow }}-${{ github.ref }}\n+  cancel-in-progress: true\n+\n@@ -27,0 +31,1 @@\n+      platform_macos_aarch64: ${{ steps.check_platforms.outputs.platform_macos_aarch64 }}\n@@ -42,0 +47,1 @@\n+          echo \"::set-output name=platform_macos_aarch64::${{ contains(github.event.inputs.platforms, 'macos aarch64') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'macos aarch64'))) }}\"\n@@ -177,1 +183,1 @@\n-          sudo apt-get install gcc-9=9.3.0-17ubuntu1~20.04 g++-9=9.3.0-17ubuntu1~20.04 libxrandr-dev libxtst-dev libcups2-dev libasound2-dev\n+          sudo apt-get install gcc-9=9.4.0-1ubuntu1~20.04 g++-9=9.4.0-1ubuntu1~20.04 libxrandr-dev libxtst-dev libcups2-dev libasound2-dev\n@@ -499,1 +505,1 @@\n-          sudo apt-get install gcc-9=9.3.0-17ubuntu1~20.04 g++-9=9.3.0-17ubuntu1~20.04 libxrandr-dev libxtst-dev libcups2-dev libasound2-dev\n+          sudo apt-get install gcc-9=9.4.0-1ubuntu1~20.04 g++-9=9.4.0-1ubuntu1~20.04 libxrandr-dev libxtst-dev libcups2-dev libasound2-dev\n@@ -504,1 +510,1 @@\n-        run: sudo apt-get install gcc-9-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-flavor}}=9.3.0-17ubuntu1~20.04cross2 g++-9-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-flavor}}=9.3.0-17ubuntu1~20.04cross2\n+        run: sudo apt-get install gcc-9-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-flavor}}=9.4.0-1ubuntu1~20.04cross2 g++-9-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-flavor}}=9.4.0-1ubuntu1~20.04cross2\n@@ -1272,0 +1278,100 @@\n+  macos_aarch64_build:\n+    name: macOS aarch64\n+    runs-on: \"macos-10.15\"\n+    needs: prerequisites\n+    if: needs.prerequisites.outputs.should_run != 'false' && needs.prerequisites.outputs.platform_macos_aarch64 != 'false'\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        flavor:\n+          - build release\n+          - build debug\n+        include:\n+          - flavor: build release\n+          - flavor: build debug\n+            flags: --enable-debug\n+            artifact: -debug\n+\n+    env:\n+      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).MACOS_X64_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).MACOS_X64_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).MACOS_X64_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Checkout the source\n+        uses: actions\/checkout@v2\n+        with:\n+          path: jdk\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v2\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p ${HOME}\/bootjdk\/${BOOT_JDK_VERSION} || true\n+          wget -O \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" \"${BOOT_JDK_URL}\"\n+          echo \"${BOOT_JDK_SHA256}  ${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" | shasum -a 256 -c >\/dev\/null -\n+          tar -xf \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" -C \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          mv \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"*\/* \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Restore jtreg artifact\n+        id: jtreg_restore\n+        uses: actions\/download-artifact@v2\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        continue-on-error: true\n+\n+      - name: Restore jtreg artifact (retry)\n+        uses: actions\/download-artifact@v2\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        if: steps.jtreg_restore.outcome == 'failure'\n+\n+      - name: Fix jtreg permissions\n+        run: chmod -R a+rx ${HOME}\/jtreg\/\n+\n+      - name: Install dependencies\n+        run: brew install make\n+\n+      - name: Select Xcode version\n+        run: sudo xcode-select --switch \/Applications\/Xcode_12.4.app\/Contents\/Developer\n+\n+      - name: Configure\n+        run: >\n+          bash configure\n+          --with-conf-name=macos-aarch64\n+          --openjdk-target=aarch64-apple-darwin\n+          ${{ matrix.flags }}\n+          --with-version-opt=${GITHUB_ACTOR}-${GITHUB_SHA}\n+          --with-version-build=0\n+          --with-boot-jdk=${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/Contents\/Home\n+          --with-jtreg=${HOME}\/jtreg\n+          --with-default-make-target=\"product-bundles test-bundles\"\n+          --with-zlib=system\n+          --with-jvm-features=shenandoahgc\n+          --enable-jtreg-failure-handler\n+        working-directory: jdk\n+\n+      - name: Build\n+        run: make CONF_NAME=macos-aarch64\n+        working-directory: jdk\n+\n+      - name: Persist test bundles\n+        uses: actions\/upload-artifact@v2\n+        with:\n+          name: transient_jdk-macos-aarch64${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: |\n+            jdk\/build\/macos-aarch64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_osx-aarch64_bin${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/macos-aarch64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_osx-aarch64_bin-tests${{ matrix.artifact }}.tar.gz\n+\n+\n@@ -1470,0 +1576,1 @@\n+      - macos_aarch64_build\n","filename":".github\/workflows\/submit.yml","additions":110,"deletions":3,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-version=11.0.15\n+version=11.0.16\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-<li><a href=\"#creating-and-using-sysroots-with-qemu-deboostrap\">Creating And Using Sysroots With qemu-deboostrap<\/a><\/li>\n+<li><a href=\"#cross-compiling-with-debian-sysroots\">Cross compiling with Debian sysroots<\/a><\/li>\n@@ -682,1 +682,1 @@\n-<h3 id=\"creating-and-using-sysroots-with-qemu-deboostrap\">Creating And Using Sysroots With qemu-deboostrap<\/h3>\n+<h3 id=\"cross-compiling-with-debian-sysroots\">Cross compiling with Debian sysroots<\/h3>\n@@ -692,1 +692,1 @@\n-  --include=fakeroot,symlinks,build-essential,libx11-dev,libxext-dev,libxrender-dev,libxrandr-dev,libxtst-dev,libxt-dev,libcups2-dev,libfontconfig1-dev,libasound2-dev,libfreetype6-dev,libpng-dev \\\n+  --include=fakeroot,symlinks,build-essential,libx11-dev,libxext-dev,libxrender-dev,libxrandr-dev,libxtst-dev,libxt-dev,libcups2-dev,libfontconfig1-dev,libasound2-dev,libfreetype6-dev,libpng-dev,libffi-dev \\\n@@ -700,7 +700,3 @@\n-<pre><code>CC=aarch64-linux-gnu-gcc CXX=aarch64-linux-gnu-g++ sh .\/configure \\\n- --openjdk-target=aarch64-linux-gnu \\\n- --with-sysroot=~\/sysroot-arm64 \\\n- --with-toolchain-path=~\/sysroot-arm64 \\\n- --with-freetype-lib=~\/sysroot-arm64\/usr\/lib\/aarch64-linux-gnu\/ \\\n- --with-freetype-include=~\/sysroot-arm64\/usr\/include\/freetype2\/ \\\n- --x-libraries=~\/sysroot-arm64\/usr\/lib\/aarch64-linux-gnu\/\n+<pre><code>sh .\/configure \\\n+  --openjdk-target=aarch64-linux-gnu \\\n+  --with-sysroot=~\/sysroot-arm64\n@@ -711,0 +707,7 @@\n+<p>The build system should automatically detect the toolchain paths and dependencies, but sometimes it might require a little nudge with:<\/p>\n+<ul>\n+<li><p>Native compilers: override <code>CC<\/code> or <code>CXX<\/code> for <code>.\/configure<\/code><\/p><\/li>\n+<li><p>Freetype lib location: override <code>--with-freetype-lib<\/code>, for example <code>${sysroot}\/usr\/lib\/${target}\/<\/code><\/p><\/li>\n+<li><p>Freetype includes location: override <code>--with-freetype-include<\/code> for example <code>${sysroot}\/usr\/include\/freetype2\/<\/code><\/p><\/li>\n+<li><p>X11 libraries location: override <code>--x-libraries<\/code>, for example <code>${sysroot}\/usr\/lib\/${target}\/<\/code><\/p><\/li>\n+<\/ul>\n@@ -716,4 +719,4 @@\n-<th style=\"text-align: left;\"><code>CC<\/code><\/th>\n-<th style=\"text-align: left;\"><code>CXX<\/code><\/th>\n-<th><code>--arch=...<\/code><\/th>\n-<th><code>--openjdk-target=...<\/code><\/th>\n+<th style=\"text-align: left;\">Debian tree<\/th>\n+<th style=\"text-align: left;\">Debian arch<\/th>\n+<th style=\"text-align: left;\"><code>--openjdk-target=...<\/code><\/th>\n+<th><code>--with-jvm-variants=...<\/code><\/th>\n@@ -725,4 +728,4 @@\n-<td style=\"text-align: left;\">default<\/td>\n-<td style=\"text-align: left;\">default<\/td>\n-<td>i386<\/td>\n-<td>i386-linux-gnu<\/td>\n+<td style=\"text-align: left;\">buster<\/td>\n+<td style=\"text-align: left;\">i386<\/td>\n+<td style=\"text-align: left;\">i386-linux-gnu<\/td>\n+<td>(all)<\/td>\n@@ -731,0 +734,2 @@\n+<td style=\"text-align: left;\">arm<\/td>\n+<td style=\"text-align: left;\">buster<\/td>\n@@ -732,4 +737,2 @@\n-<td style=\"text-align: left;\">gcc-arm-linux-gnueabihf<\/td>\n-<td style=\"text-align: left;\">g++-arm-linux-gnueabihf<\/td>\n-<td>armhf<\/td>\n-<td>arm-linux-gnueabihf<\/td>\n+<td style=\"text-align: left;\">arm-linux-gnueabihf<\/td>\n+<td>(all)<\/td>\n@@ -739,4 +742,4 @@\n-<td style=\"text-align: left;\">gcc-aarch64-linux-gnu<\/td>\n-<td style=\"text-align: left;\">g++-aarch64-linux-gnu<\/td>\n-<td>arm64<\/td>\n-<td>aarch64-linux-gnu<\/td>\n+<td style=\"text-align: left;\">buster<\/td>\n+<td style=\"text-align: left;\">arm64<\/td>\n+<td style=\"text-align: left;\">aarch64-linux-gnu<\/td>\n+<td>(all)<\/td>\n@@ -745,0 +748,2 @@\n+<td style=\"text-align: left;\">ppc64le<\/td>\n+<td style=\"text-align: left;\">buster<\/td>\n@@ -746,4 +751,2 @@\n-<td style=\"text-align: left;\">gcc-powerpc64le-linux-gnu<\/td>\n-<td style=\"text-align: left;\">g++-powerpc64le-linux-gnu<\/td>\n-<td>ppc64el<\/td>\n-<td>powerpc64le-linux-gnu<\/td>\n+<td style=\"text-align: left;\">powerpc64le-linux-gnu<\/td>\n+<td>(all)<\/td>\n@@ -753,4 +756,60 @@\n-<td style=\"text-align: left;\">gcc-s390x-linux-gnu<\/td>\n-<td style=\"text-align: left;\">g++-s390x-linux-gnu<\/td>\n-<td>s390x<\/td>\n-<td>s390x-linux-gnu<\/td>\n+<td style=\"text-align: left;\">buster<\/td>\n+<td style=\"text-align: left;\">s390x<\/td>\n+<td style=\"text-align: left;\">s390x-linux-gnu<\/td>\n+<td>(all)<\/td>\n+<\/tr>\n+<tr class=\"even\">\n+<td style=\"text-align: left;\">mipsle<\/td>\n+<td style=\"text-align: left;\">buster<\/td>\n+<td style=\"text-align: left;\">mipsel<\/td>\n+<td style=\"text-align: left;\">mipsel-linux-gnu<\/td>\n+<td>zero<\/td>\n+<\/tr>\n+<tr class=\"odd\">\n+<td style=\"text-align: left;\">mips64le<\/td>\n+<td style=\"text-align: left;\">buster<\/td>\n+<td style=\"text-align: left;\">mips64el<\/td>\n+<td style=\"text-align: left;\">mips64el-linux-gnueabi64<\/td>\n+<td>zero<\/td>\n+<\/tr>\n+<tr class=\"even\">\n+<td style=\"text-align: left;\">armel<\/td>\n+<td style=\"text-align: left;\">buster<\/td>\n+<td style=\"text-align: left;\">arm<\/td>\n+<td style=\"text-align: left;\">arm-linux-gnueabi<\/td>\n+<td>zero<\/td>\n+<\/tr>\n+<tr class=\"odd\">\n+<td style=\"text-align: left;\">ppc<\/td>\n+<td style=\"text-align: left;\">sid<\/td>\n+<td style=\"text-align: left;\">powerpc<\/td>\n+<td style=\"text-align: left;\">powerpc-linux-gnu<\/td>\n+<td>zero<\/td>\n+<\/tr>\n+<tr class=\"even\">\n+<td style=\"text-align: left;\">ppc64be<\/td>\n+<td style=\"text-align: left;\">sid<\/td>\n+<td style=\"text-align: left;\">ppc64<\/td>\n+<td style=\"text-align: left;\">powerpc64-linux-gnu<\/td>\n+<td>(all)<\/td>\n+<\/tr>\n+<tr class=\"odd\">\n+<td style=\"text-align: left;\">m68k<\/td>\n+<td style=\"text-align: left;\">sid<\/td>\n+<td style=\"text-align: left;\">m68k<\/td>\n+<td style=\"text-align: left;\">m68k-linux-gnu<\/td>\n+<td>zero<\/td>\n+<\/tr>\n+<tr class=\"even\">\n+<td style=\"text-align: left;\">alpha<\/td>\n+<td style=\"text-align: left;\">sid<\/td>\n+<td style=\"text-align: left;\">alpha<\/td>\n+<td style=\"text-align: left;\">alpha-linux-gnu<\/td>\n+<td>zero<\/td>\n+<\/tr>\n+<tr class=\"odd\">\n+<td style=\"text-align: left;\">sh4<\/td>\n+<td style=\"text-align: left;\">sid<\/td>\n+<td style=\"text-align: left;\">sh4<\/td>\n+<td style=\"text-align: left;\">sh4-linux-gnu<\/td>\n+<td>zero<\/td>\n@@ -760,1 +819,0 @@\n-<p>Additional architectures might be supported by Debian\/Ubuntu Ports.<\/p>\n","filename":"doc\/building.html","additions":93,"deletions":35,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -1091,1 +1091,1 @@\n-### Creating And Using Sysroots With qemu-deboostrap\n+### Cross compiling with Debian sysroots\n@@ -1112,1 +1112,1 @@\n-      --include=fakeroot,symlinks,build-essential,libx11-dev,libxext-dev,libxrender-dev,libxrandr-dev,libxtst-dev,libxt-dev,libcups2-dev,libfontconfig1-dev,libasound2-dev,libfreetype6-dev,libpng-dev \\\n+      --include=fakeroot,symlinks,build-essential,libx11-dev,libxext-dev,libxrender-dev,libxrandr-dev,libxtst-dev,libxt-dev,libcups2-dev,libfontconfig1-dev,libasound2-dev,libfreetype6-dev,libpng-dev,libffi-dev \\\n@@ -1126,7 +1126,3 @@\n-    CC=aarch64-linux-gnu-gcc CXX=aarch64-linux-gnu-g++ sh .\/configure \\\n-     --openjdk-target=aarch64-linux-gnu \\\n-     --with-sysroot=~\/sysroot-arm64 \\\n-     --with-toolchain-path=~\/sysroot-arm64 \\\n-     --with-freetype-lib=~\/sysroot-arm64\/usr\/lib\/aarch64-linux-gnu\/ \\\n-     --with-freetype-include=~\/sysroot-arm64\/usr\/include\/freetype2\/ \\\n-     --x-libraries=~\/sysroot-arm64\/usr\/lib\/aarch64-linux-gnu\/\n+    sh .\/configure \\\n+      --openjdk-target=aarch64-linux-gnu \\\n+      --with-sysroot=~\/sysroot-arm64\n@@ -1140,1 +1136,6 @@\n-Architectures that are known to successfully cross-compile like this are:\n+The build system should automatically detect the toolchain paths and dependencies, but sometimes\n+it might require a little nudge with:\n+\n+  * Native compilers: override `CC` or `CXX` for `.\/configure`\n+\n+  * Freetype lib location: override `--with-freetype-lib`, for example `${sysroot}\/usr\/lib\/${target}\/`\n@@ -1142,7 +1143,5 @@\n-  Target        `CC`                      `CXX`                       `--arch=...` `--openjdk-target=...`\n-  ------------  ------------------------- --------------------------- ------------ ----------------------\n-  x86           default                   default                     i386         i386-linux-gnu\n-  armhf         gcc-arm-linux-gnueabihf   g++-arm-linux-gnueabihf     armhf        arm-linux-gnueabihf\n-  aarch64       gcc-aarch64-linux-gnu     g++-aarch64-linux-gnu       arm64        aarch64-linux-gnu\n-  ppc64el       gcc-powerpc64le-linux-gnu g++-powerpc64le-linux-gnu   ppc64el      powerpc64le-linux-gnu\n-  s390x         gcc-s390x-linux-gnu       g++-s390x-linux-gnu         s390x        s390x-linux-gnu\n+  * Freetype includes location: override `--with-freetype-include` for example `${sysroot}\/usr\/include\/freetype2\/`\n+\n+  * X11 libraries location: override `--x-libraries`, for example `${sysroot}\/usr\/lib\/${target}\/`\n+\n+Architectures that are known to successfully cross-compile like this are:\n@@ -1150,1 +1149,15 @@\n-Additional architectures might be supported by Debian\/Ubuntu Ports.\n+  Target        Debian tree  Debian arch   `--openjdk-target=...`   `--with-jvm-variants=...`\n+  ------------  ------------ ------------- ------------------------ --------------\n+  x86           buster       i386          i386-linux-gnu           (all)\n+  arm           buster       armhf         arm-linux-gnueabihf      (all)\n+  aarch64       buster       arm64         aarch64-linux-gnu        (all)\n+  ppc64le       buster       ppc64el       powerpc64le-linux-gnu    (all)\n+  s390x         buster       s390x         s390x-linux-gnu          (all)\n+  mipsle        buster       mipsel        mipsel-linux-gnu         zero\n+  mips64le      buster       mips64el      mips64el-linux-gnueabi64 zero\n+  armel         buster       arm           arm-linux-gnueabi        zero\n+  ppc           sid          powerpc       powerpc-linux-gnu        zero\n+  ppc64be       sid          ppc64         powerpc64-linux-gnu      (all)\n+  m68k          sid          m68k          m68k-linux-gnu           zero\n+  alpha         sid          alpha         alpha-linux-gnu          zero\n+  sh4           sid          sh4           sh4-linux-gnu            zero\n","filename":"doc\/building.md","additions":31,"deletions":18,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,1 +125,1 @@\n-      MACOSX_VERSION_MIN=10.9.0\n+      MACOSX_VERSION_MIN=10.12.0\n","filename":"make\/autoconf\/flags.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-DEFAULT_VERSION_UPDATE=15\n+DEFAULT_VERSION_UPDATE=16\n@@ -36,1 +36,1 @@\n-DEFAULT_VERSION_DATE=2022-04-19\n+DEFAULT_VERSION_DATE=2022-07-19\n","filename":"make\/autoconf\/version-numbers","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -418,1 +418,1 @@\n-                \"--with-macosx-version-max=10.9.0\"),\n+                \"--with-macosx-version-max=10.12.00\"),\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -545,0 +545,2 @@\n+  # Modern HarfBuzz requires c++11.\n+  HARFBUZZ_CXXFLAGS := -std=c++11\n@@ -627,1 +629,1 @@\n-    CXXFLAGS := $(CXXFLAGS_JDKLIB) $(LIBFONTMANAGER_CFLAGS), \\\n+    CXXFLAGS := $(CXXFLAGS_JDKLIB) $(LIBFONTMANAGER_CFLAGS) $(HARFBUZZ_CXXFLAGS), \\\n@@ -864,1 +866,1 @@\n-      DISABLED_WARNINGS_clang := incompatible-pointer-types, \\\n+      DISABLED_WARNINGS_clang := incompatible-pointer-types deprecated-declarations, \\\n","filename":"make\/lib\/Awt2dLibraries.gmk","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+  BUILD_JDK_JTREG_EXCLUDE += exeLibraryCache.c\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1495,1 +1495,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\"PRIX64, (uint64_t)imm64);\n+    snprintf(buffer, sizeof(buffer), \"0x%\" PRIX64, (uint64_t)imm64);\n@@ -1558,1 +1558,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\"PRIX64, imm64);\n+    snprintf(buffer, sizeof(buffer), \"0x%\" PRIX64, imm64);\n@@ -1671,1 +1671,1 @@\n-      snprintf(buffer, sizeof(buffer), \"0x%\"PRIX32, imm32);\n+      snprintf(buffer, sizeof(buffer), \"0x%\" PRIX32, imm32);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-             > (1ULL << log2_intptr(Universe::narrow_klass_range()))));\n+             > (1ULL << log2_intptr(checked_cast<uintptr_t>(Universe::narrow_klass_range())))));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6542,0 +6542,3 @@\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+         vector_len == AVX_256bit ? VM_Version::supports_avx2() :\n+         vector_len == AVX_512bit ? VM_Version::supports_evex() : 0, \"\");\n@@ -6550,0 +6553,3 @@\n+  assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :\n+         vector_len == AVX_256bit ? VM_Version::supports_avx2() :\n+         vector_len == AVX_512bit ? VM_Version::supports_evex() : 0, \"\");\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1343,2 +1343,8 @@\n-  void vpxor(XMMRegister dst, XMMRegister src) { Assembler::vpxor(dst, dst, src, true); }\n-  void vpxor(XMMRegister dst, Address src) { Assembler::vpxor(dst, dst, src, true); }\n+  void vpxor(XMMRegister dst, XMMRegister src) {\n+    assert(UseAVX >= 2, \"Should be at least AVX2\");\n+    Assembler::vpxor(dst, dst, src, AVX_256bit);\n+  }\n+  void vpxor(XMMRegister dst, Address src) {\n+    assert(UseAVX >= 2, \"Should be at least AVX2\");\n+    Assembler::vpxor(dst, dst, src, AVX_256bit);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -270,0 +270,2 @@\n+\n+ public:\n@@ -274,2 +276,0 @@\n- public:\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,3 @@\n-                                          Handle protection_domain, TRAPS) {\n+                                          Handle protection_domain,\n+                                          const ClassFileStream *cfs,\n+                                          TRAPS) {\n@@ -53,1 +55,0 @@\n-\n@@ -59,6 +60,5 @@\n-    JvmtiCachedClassFileData* archived_class_data = ik->get_archived_class_data();\n-    assert(archived_class_data != NULL, \"shared class has no archived class data\");\n-    unsigned char* ptr =\n-        VM_RedefineClasses::get_cached_class_file_bytes(archived_class_data);\n-    unsigned char* end_ptr =\n-        ptr + VM_RedefineClasses::get_cached_class_file_len(archived_class_data);\n+    if (cfs == NULL) {\n+      cfs = FileMapInfo::open_stream_for_jvmti(ik, CHECK_NULL);\n+    }\n+    unsigned char* ptr = (unsigned char*)cfs->buffer();\n+    unsigned char* end_ptr = ptr + cfs->length();\n@@ -78,16 +78,0 @@\n-      const char* pathname;\n-      if (path_index < 0) {\n-        \/\/ shared classes loaded by user defined class loader\n-        \/\/ do not have shared_classpath_index\n-        ModuleEntry* mod_entry = ik->module();\n-        if (mod_entry != NULL && (mod_entry->location() != NULL)) {\n-          ResourceMark rm;\n-          pathname = (const char*)(mod_entry->location()->as_C_string());\n-        } else {\n-          pathname = \"\";\n-        }\n-      } else {\n-        SharedClassPathEntry* ent =\n-          (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);\n-        pathname = ent == NULL ? NULL : ent->name();\n-      }\n@@ -96,1 +80,1 @@\n-                                                    pathname,\n+                                                    cfs->source(),\n@@ -243,18 +227,0 @@\n-#if INCLUDE_JVMTI\n-    assert(cached_class_file == NULL, \"Sanity\");\n-    \/\/ Archive the class stream data into the optional data section\n-    JvmtiCachedClassFileData *p;\n-    int len;\n-    const unsigned char *bytes;\n-    \/\/ event based tracing might set cached_class_file\n-    if ((bytes = result->get_cached_class_file_bytes()) != NULL) {\n-      len = result->get_cached_class_file_len();\n-    } else {\n-      len = stream->length();\n-      bytes = stream->buffer();\n-    }\n-    p = (JvmtiCachedClassFileData*)os::malloc(offset_of(JvmtiCachedClassFileData, data) + len, mtInternal);\n-    p->length = len;\n-    memcpy(p->data, bytes, len);\n-    result->set_archived_class_data(p);\n-#endif \/\/ INCLUDE_JVMTI\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.cpp","additions":10,"deletions":44,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -83,1 +83,3 @@\n-                                          Handle protection_domain, TRAPS);\n+                                          Handle protection_domain,\n+                                          const ClassFileStream *cfs,\n+                                          TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1174,1 +1174,1 @@\n-    return load_shared_class(ik, class_loader, protection_domain, THREAD);\n+    return load_shared_class(ik, class_loader, protection_domain, NULL, THREAD);\n@@ -1274,1 +1274,3 @@\n-                                                   Handle protection_domain, TRAPS) {\n+                                                   Handle protection_domain,\n+                                                   const ClassFileStream *cfs,\n+                                                   TRAPS) {\n@@ -1321,1 +1323,1 @@\n-        ik, class_name, class_loader, protection_domain, CHECK_NULL);\n+        ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -658,0 +658,1 @@\n+                                          const ClassFileStream *cfs,\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -544,1 +544,1 @@\n-      return load_shared_class(ik, class_loader, protection_domain, THREAD);\n+      return load_shared_class(ik, class_loader, protection_domain, NULL, THREAD);\n@@ -624,1 +624,2 @@\n-                                          protection_domain, THREAD);\n+                                          protection_domain, cfs,\n+                                          THREAD);\n@@ -631,0 +632,1 @@\n+                   const ClassFileStream *cfs,\n@@ -651,1 +653,2 @@\n-  InstanceKlass* shared_klass = load_shared_class(ik, class_loader, protection_domain, THREAD);\n+  InstanceKlass* shared_klass = load_shared_class(ik, class_loader, protection_domain,\n+                                                  cfs, THREAD);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -284,0 +284,1 @@\n+                                 const ClassFileStream* cfs,\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2041,0 +2041,3 @@\n+\n+            AutoNodeBudget node_budget(phase);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-JVM_LoadLibrary(const char *name);\n+JVM_LoadLibrary(const char *name, jboolean throwException);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -501,0 +502,10 @@\n+\n+#if INCLUDE_JVMTI\n+  if (_classpath_entries_for_jvmti != NULL) {\n+    os::free(_classpath_entries_for_jvmti);\n+  }\n+  size_t sz = sizeof(ClassPathEntry*) *  _shared_path_table_size;\n+  _classpath_entries_for_jvmti = (ClassPathEntry**)os::malloc(sz, mtClass);\n+  memset(_classpath_entries_for_jvmti, 0, sz);\n+#endif\n+\n@@ -1439,0 +1450,54 @@\n+\n+#if INCLUDE_JVMTI\n+ClassPathEntry** FileMapInfo::_classpath_entries_for_jvmti = NULL;\n+\n+ClassPathEntry* FileMapInfo::get_classpath_entry_for_jvmti(int i, TRAPS) {\n+  ClassPathEntry* ent = _classpath_entries_for_jvmti[i];\n+  if (ent == NULL) {\n+    if (i == 0) {\n+      ent = ClassLoader:: get_jrt_entry();\n+      assert(ent != NULL, \"must be\");\n+    } else {\n+      SharedClassPathEntry* scpe = shared_path(i);\n+      assert(scpe->is_jar(), \"must be\"); \/\/ other types of scpe will not produce archived classes\n+\n+      const char* path = scpe->name();\n+      struct stat st;\n+      if (os::stat(path, &st) != 0) {\n+        char *msg = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, strlen(path) + 128); ;\n+        jio_snprintf(msg, strlen(path) + 127, \"error in opening JAR file %s\", path);\n+        THROW_MSG_(vmSymbols::java_io_IOException(), msg, NULL);\n+      } else {\n+        ent = ClassLoader::create_class_path_entry(path, &st, \/*throw_exception=*\/true, false, CHECK_NULL);\n+      }\n+    }\n+\n+    MutexLocker mu(CDSClassFileStream_lock, THREAD);\n+    if (_classpath_entries_for_jvmti[i] == NULL) {\n+      _classpath_entries_for_jvmti[i] = ent;\n+    } else {\n+      \/\/ Another thread has beat me to creating this entry\n+      delete ent;\n+      ent = _classpath_entries_for_jvmti[i];\n+    }\n+  }\n+\n+  return ent;\n+}\n+\n+ClassFileStream* FileMapInfo::open_stream_for_jvmti(InstanceKlass* ik, TRAPS) {\n+  int path_index = ik->shared_classpath_index();\n+  assert(path_index >= 0, \"should be called for shared built-in classes only\");\n+  assert(path_index < (int)_shared_path_table_size, \"sanity\");\n+\n+  ClassPathEntry* cpe = get_classpath_entry_for_jvmti(path_index, CHECK_NULL);\n+  assert(cpe != NULL, \"must be\");\n+\n+  Symbol* name = ik->name();\n+  const char* const class_name = name->as_C_string();\n+  const char* const file_name = ClassLoader::file_name_for_class_name(class_name,\n+                                                                      name->utf8_length());\n+  return cpe->open_stream(file_name, THREAD);\n+}\n+\n+#endif\n","filename":"src\/hotspot\/share\/memory\/filemap.cpp","additions":66,"deletions":1,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -302,0 +302,4 @@\n+#if INCLUDE_JVMTI\n+  static ClassFileStream* open_stream_for_jvmti(InstanceKlass* ik, TRAPS);\n+#endif\n+\n@@ -348,0 +352,5 @@\n+\n+#if INCLUDE_JVMTI\n+  static ClassPathEntry** _classpath_entries_for_jvmti;\n+  static ClassPathEntry* get_classpath_entry_for_jvmti(int i, TRAPS);\n+#endif\n","filename":"src\/hotspot\/share\/memory\/filemap.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-DumpRegion _mc_region(\"mc\"), _ro_region(\"ro\"), _rw_region(\"rw\"), _md_region(\"md\"), _od_region(\"od\");\n+DumpRegion _mc_region(\"mc\"), _ro_region(\"ro\"), _rw_region(\"rw\"), _md_region(\"md\");\n@@ -566,19 +566,0 @@\n-#if INCLUDE_JVMTI\n-static void relocate_cached_class_file() {\n-  for (int i = 0; i < _global_klass_objects->length(); i++) {\n-    Klass* k = _global_klass_objects->at(i);\n-    if (k->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      JvmtiCachedClassFileData* p = ik->get_archived_class_data();\n-      if (p != NULL) {\n-        int size = offset_of(JvmtiCachedClassFileData, data) + p->length;\n-        JvmtiCachedClassFileData* q = (JvmtiCachedClassFileData*)_od_region.allocate(size);\n-        q->length = p->length;\n-        memcpy(q->data, p->data, p->length);\n-        ik->set_archived_class_data(q);\n-      }\n-    }\n-  }\n-}\n-#endif \/\/ INCLUDE_JVMTI\n-\n@@ -1442,5 +1423,1 @@\n-  _md_region.pack(&_od_region);\n-\n-  \/\/ Relocate the archived class file data into the od region\n-  JVMTI_ONLY(relocate_cached_class_file();)\n-  _od_region.pack();\n+  _md_region.pack();\n@@ -1448,1 +1425,1 @@\n-  \/\/ The 5 core spaces are allocated consecutively mc->rw->ro->md->od, so there total size\n+  \/\/ The 4 core spaces are allocated consecutively mc->rw->ro->md->od, so there total size\n@@ -1450,1 +1427,1 @@\n-  size_t core_spaces_size = _od_region.end() - _mc_region.base();\n+  size_t core_spaces_size = _md_region.end() - _mc_region.base();\n@@ -1491,1 +1468,0 @@\n-    write_region(mapinfo, MetaspaceShared::od, &_od_region, \/*read_only=*\/true, \/*allow_exec=*\/false);\n@@ -1530,1 +1506,0 @@\n-                                _od_region.reserved()  +\n@@ -1535,1 +1510,0 @@\n-                             _od_region.used()  +\n@@ -1544,1 +1518,0 @@\n-  _od_region.print(total_reserved);\n@@ -2084,1 +2057,0 @@\n-  char* od_base = NULL; char* od_top;\n@@ -2091,1 +2063,0 @@\n-      (od_base = mapinfo->map_region(od, &od_top)) != NULL &&\n@@ -2098,1 +2069,1 @@\n-    \/\/ We require that mc->rw->ro->md->od to be laid out consecutively, with no\n+    \/\/ We require that mc->rw->ro->md to be laid out consecutively, with no\n@@ -2102,2 +2073,2 @@\n-    assert(mc_base < ro_base && mc_base < rw_base && mc_base < md_base && mc_base < od_base, \"must be\");\n-    assert(od_top  > ro_top  && od_top  > rw_top  && od_top  > md_top  && od_top  > mc_top , \"must be\");\n+    assert(mc_base < ro_base && mc_base < rw_base && mc_base < md_base, \"must be\");\n+    assert(md_top  > ro_top  && md_top  > rw_top  && md_top  > mc_top , \"must be\");\n@@ -2107,1 +2078,0 @@\n-    assert(md_top == od_base, \"must be\");\n@@ -2109,1 +2079,1 @@\n-    MetaspaceObj::set_shared_metaspace_range((void*)mc_base, (void*)od_top);\n+    MetaspaceObj::set_shared_metaspace_range((void*)mc_base, (void*)md_top);\n@@ -2118,1 +2088,0 @@\n-    if (od_base != NULL) mapinfo->unmap_region(od);\n@@ -2218,1 +2187,0 @@\n-  _od_region.print_out_of_space_msg(name, needed_bytes);\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":8,"deletions":40,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -74,4 +74,1 @@\n-    \/\/ optional mapped spaces\n-    \/\/ Currently it only contains class file data.\n-    od = num_core_spaces,\n-    num_non_heap_spaces = od + 1,\n+    num_non_heap_spaces = 4,\n@@ -80,1 +77,1 @@\n-    first_string = od + 1, \/\/ index of first string region\n+    first_string = md + 1, \/\/ index of first string region\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2324,0 +2324,1 @@\n+  _cached_class_file = NULL;\n@@ -2475,1 +2476,1 @@\n-  if (_cached_class_file != NULL && !MetaspaceShared::is_in_shared_metaspace(_cached_class_file)) {\n+  if (_cached_class_file != NULL) {\n@@ -4007,6 +4008,1 @@\n-  if (MetaspaceShared::is_in_shared_metaspace(_cached_class_file)) {\n-    \/\/ Ignore the archived class stream data\n-    return NULL;\n-  } else {\n-    return _cached_class_file;\n-  }\n+  return _cached_class_file;\n@@ -4022,15 +4018,0 @@\n-\n-#if INCLUDE_CDS\n-JvmtiCachedClassFileData* InstanceKlass::get_archived_class_data() {\n-  if (DumpSharedSpaces) {\n-    return _cached_class_file;\n-  } else {\n-    assert(this->is_shared(), \"class should be shared\");\n-    if (MetaspaceShared::is_in_shared_metaspace(_cached_class_file)) {\n-      return _cached_class_file;\n-    } else {\n-      return NULL;\n-    }\n-  }\n-}\n-#endif\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":22,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -866,8 +866,0 @@\n-\n-#if INCLUDE_CDS\n-  void set_archived_class_data(JvmtiCachedClassFileData* data) {\n-    _cached_class_file = data;\n-  }\n-\n-  JvmtiCachedClassFileData * get_archived_class_data();\n-#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1089,1 +1089,1 @@\n-  } else if (_i2i_entry != NULL) {\n+  } else if (adapter() != NULL) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -289,0 +289,3 @@\n+\n+  if (!phase->may_require_nodes(10, 10)) return NULL;\n+\n@@ -340,1 +343,1 @@\n-    };\n+    }\n@@ -345,10 +348,21 @@\n-\/\/ Return TRUE or FALSE if the loop should be peeled or not.  Peel if we can\n-\/\/ make some loop-invariant test (usually a null-check) happen before the loop.\n-bool IdealLoopTree::policy_peeling(PhaseIdealLoop *phase) const {\n-  IdealLoopTree *loop = (IdealLoopTree*)this;\n-  Node *test = loop->tail();\n-  int body_size = loop->_body.size();\n-  \/\/ Peeling does loop cloning which can result in O(N^2) node construction\n-  if (body_size > 255 \/* Prevent overflow for large body_size *\/\n-      || (body_size * body_size + phase->C->live_nodes()) > phase->C->max_node_limit()) {\n-    return false;           \/\/ too large to safely clone\n+\/\/ Return TRUE if the loop should be peeled, otherwise return FALSE. Peeling\n+\/\/ is applicable if we can make a loop-invariant test (usually a null-check)\n+\/\/ execute before we enter the loop. When TRUE, the estimated node budget is\n+\/\/ also requested.\n+bool IdealLoopTree::policy_peeling(PhaseIdealLoop *phase) {\n+  uint estimate = estimate_peeling(phase);\n+\n+  return estimate == 0 ? false : phase->may_require_nodes(estimate);\n+}\n+\n+\/\/ Perform actual policy and size estimate for the loop peeling transform, and\n+\/\/ return the estimated loop size if peeling is applicable, otherwise return\n+\/\/ zero. No node budget is allocated.\n+uint IdealLoopTree::estimate_peeling(PhaseIdealLoop *phase) {\n+\n+  \/\/ If nodes are depleted, some transform has miscalculated its needs.\n+  assert(!phase->exceeding_node_budget(), \"sanity\");\n+\n+  \/\/ Peeling does loop cloning which can result in O(N^2) node construction.\n+  if (_body.size() > 255) {\n+    return 0;   \/\/ Suppress too large body size.\n@@ -356,0 +370,3 @@\n+  \/\/ Optimistic estimate that approximates loop body complexity via data and\n+  \/\/ control flow fan-out (instead of using the more pessimistic: BodySize^2).\n+  uint estimate = est_loop_clone_sz(2);\n@@ -357,1 +374,5 @@\n-  \/\/ check for vectorized loops, any peeling done was already applied\n+  if (phase->exceeding_node_budget(estimate)) {\n+    return 0;   \/\/ Too large to safely clone.\n+  }\n+\n+  \/\/ Check for vectorized loops, any peeling done was already applied.\n@@ -361,1 +382,1 @@\n-      return false;\n+      return 0;\n@@ -365,2 +386,4 @@\n-  while (test != _head) {       \/\/ Scan till run off top of loop\n-    if (test->is_If()) {        \/\/ Test?\n+  Node* test = tail();\n+\n+  while (test != _head) {   \/\/ Scan till run off top of loop\n+    if (test->is_If()) {    \/\/ Test?\n@@ -369,1 +392,1 @@\n-        return false;           \/\/ Found dead test on live IF?  No peeling!\n+        return 0;           \/\/ Found dead test on live IF?  No peeling!\n@@ -371,1 +394,1 @@\n-      \/\/ Standard IF only has one input value to check for loop invariance\n+      \/\/ Standard IF only has one input value to check for loop invariance.\n@@ -378,1 +401,1 @@\n-        return true;            \/\/ Found reason to peel!\n+        return estimate;    \/\/ Found reason to peel!\n@@ -381,2 +404,2 @@\n-    \/\/ Walk up dominators to loop _head looking for test which is\n-    \/\/ executed on every path thru loop.\n+    \/\/ Walk up dominators to loop _head looking for test which is executed on\n+    \/\/ every path through the loop.\n@@ -385,1 +408,1 @@\n-  return false;\n+  return 0;\n@@ -636,1 +659,0 @@\n-\n@@ -638,0 +660,1 @@\n+\n@@ -655,2 +678,0 @@\n-#define EMPTY_LOOP_SIZE 7 \/\/ number of nodes in an empty loop\n-\n@@ -658,4 +679,5 @@\n-\/\/ Calculate exact loop trip count and return true if loop can be maximally\n-\/\/ unrolled.\n-bool IdealLoopTree::policy_maximally_unroll(PhaseIdealLoop *phase) const {\n-  CountedLoopNode *cl = _head->as_CountedLoop();\n+\/\/ Calculate the exact  loop trip-count and return TRUE if loop can be fully,\n+\/\/ i.e. maximally, unrolled, otherwise return FALSE. When TRUE, the estimated\n+\/\/ node budget is also requested.\n+bool IdealLoopTree::policy_maximally_unroll(PhaseIdealLoop* phase) const {\n+  CountedLoopNode* cl = _head->as_CountedLoop();\n@@ -664,1 +686,1 @@\n-    return false; \/\/ Malformed counted loop\n+    return false;   \/\/ Malformed counted loop.\n@@ -667,2 +689,1 @@\n-    \/\/ Trip count is not exact.\n-    return false;\n+    return false;   \/\/ Trip count is not exact.\n@@ -674,1 +695,1 @@\n-  assert(trip_count < max_juint, \"exact trip_count should be less than max_uint.\");\n+  assert(trip_count < max_juint, \"exact trip_count should be less than max_juint.\");\n@@ -676,4 +697,4 @@\n-  \/\/ Real policy: if we maximally unroll, does it get too big?\n-  \/\/ Allow the unrolled mess to get larger than standard loop\n-  \/\/ size.  After all, it will no longer be a loop.\n-  uint body_size    = _body.size();\n+  \/\/ If nodes are depleted, some transform has miscalculated its needs.\n+  assert(!phase->exceeding_node_budget(), \"sanity\");\n+\n+  \/\/ Allow the unrolled body to get larger than the standard loop size limit.\n@@ -682,1 +703,1 @@\n-  if (trip_count > unroll_limit || body_size > unroll_limit) {\n+  if (trip_count > unroll_limit || _body.size() > unroll_limit) {\n@@ -686,5 +707,1 @@\n-  \/\/ Fully unroll a loop with few iterations regardless next\n-  \/\/ conditions since following loop optimizations will split\n-  \/\/ such loop anyway (pre-main-post).\n-  if (trip_count <= 3)\n-    return true;\n+  uint new_body_size = est_loop_unroll_sz(trip_count);\n@@ -692,5 +709,1 @@\n-  \/\/ Take into account that after unroll conjoined heads and tails will fold,\n-  \/\/ otherwise policy_unroll() may allow more unrolling than max unrolling.\n-  uint new_body_size = EMPTY_LOOP_SIZE + (body_size - EMPTY_LOOP_SIZE) * trip_count;\n-  uint tst_body_size = (new_body_size - EMPTY_LOOP_SIZE) \/ trip_count + EMPTY_LOOP_SIZE;\n-  if (body_size != tst_body_size) \/\/ Check for int overflow\n+  if (new_body_size == UINT_MAX) { \/\/ Check for bad estimate (overflow).\n@@ -698,3 +711,11 @@\n-  if (new_body_size > unroll_limit ||\n-      \/\/ Unrolling can result in a large amount of node construction\n-      new_body_size >= phase->C->max_node_limit() - phase->C->live_nodes()) {\n+  }\n+\n+  \/\/ Fully unroll a loop with few iterations, regardless of other conditions,\n+  \/\/ since the following (general) loop optimizations will split such loop in\n+  \/\/ any case (into pre-main-post).\n+  if (trip_count <= 3) {\n+    return phase->may_require_nodes(new_body_size);\n+  }\n+\n+  \/\/ Reject if unrolling will result in too much node construction.\n+  if (new_body_size > unroll_limit || phase->exceeding_node_budget(new_body_size)) {\n@@ -730,1 +751,1 @@\n-  return true; \/\/ Do maximally unroll\n+  return phase->may_require_nodes(new_body_size);\n@@ -735,2 +756,3 @@\n-\/\/ Return TRUE or FALSE if the loop should be unrolled or not.  Unroll if\n-\/\/ the loop is a CountedLoop and the body is small enough.\n+\/\/ Return TRUE or FALSE if the loop should be unrolled or not. Apply unroll if\n+\/\/ the loop is  a counted loop and  the loop body is small  enough. When TRUE,\n+\/\/ the estimated node budget is also requested.\n@@ -742,1 +764,1 @@\n-  if (!cl->is_valid_counted_loop())\n+  if (!cl->is_valid_counted_loop()) {\n@@ -744,0 +766,4 @@\n+  }\n+\n+  \/\/ If nodes are depleted, some transform has miscalculated its needs.\n+  assert(!phase->exceeding_node_budget(), \"sanity\");\n@@ -747,3 +773,4 @@\n-  if (cl->trip_count() <= (uint)(cl->is_normal_loop() ? 2 : 1)) return false;\n-\n-  _local_loop_unroll_limit = LoopUnrollLimit;\n+  if (cl->trip_count() <= (cl->is_normal_loop() ? 2u : 1u)) {\n+    return false;\n+  }\n+  _local_loop_unroll_limit  = LoopUnrollLimit;\n@@ -874,0 +901,3 @@\n+\n+  uint estimate = est_loop_clone_sz(2);\n+\n@@ -875,3 +905,4 @@\n-    if (slp_max_unroll_factor >= future_unroll_cnt) return true;\n-    \/\/ Normal case: loop too big\n-    return false;\n+    if (slp_max_unroll_factor >= future_unroll_cnt) {\n+      return phase->may_require_nodes(estimate);\n+    }\n+    return false; \/\/ Loop too big.\n@@ -882,2 +913,2 @@\n-    if ((cl->is_subword_loop() || xors_in_loop >= 4) && body_size < (uint)LoopUnrollLimit * 4) {\n-      return true;\n+    if ((cl->is_subword_loop() || xors_in_loop >= 4) && body_size < 4u * LoopUnrollLimit) {\n+      return phase->may_require_nodes(estimate);\n@@ -885,2 +916,1 @@\n-    \/\/ Normal case: loop too big\n-    return false;\n+    return false; \/\/ Loop too big.\n@@ -891,1 +921,2 @@\n-      tty->print_cr(\"policy_unroll passed vector loop(vlen=%d,factor = %d)\\n\", slp_max_unroll_factor, future_unroll_cnt);\n+      tty->print_cr(\"policy_unroll passed vector loop(vlen=%d, factor=%d)\\n\",\n+                    slp_max_unroll_factor, future_unroll_cnt);\n@@ -896,1 +927,1 @@\n-  return true;\n+  return phase->may_require_nodes(estimate);\n@@ -900,0 +931,4 @@\n+\n+  \/\/ If nodes are depleted, some transform has miscalculated its needs.\n+  assert(!phase->exceeding_node_budget(), \"sanity\");\n+\n@@ -938,2 +973,4 @@\n-\/\/ Return TRUE or FALSE if the loop should be range-check-eliminated.\n-\/\/ Actually we do iteration-splitting, a more powerful form of RCE.\n+\/\/ Return TRUE or FALSE if the loop should be range-check-eliminated or not.\n+\/\/ When TRUE, the estimated node budget is also requested.\n+\/\/\n+\/\/ We will actually perform iteration-splitting, a more powerful form of RCE.\n@@ -943,0 +980,3 @@\n+  \/\/ If nodes are depleted, some transform has miscalculated its needs.\n+  assert(!phase->exceeding_node_budget(), \"sanity\");\n+\n@@ -944,3 +984,3 @@\n-  \/\/ If we unrolled with no intention of doing RCE and we later\n-  \/\/ changed our minds, we got no pre-loop.  Either we need to\n-  \/\/ make a new pre-loop, or we gotta disallow RCE.\n+  \/\/ If we unrolled  with no intention of doing RCE and we  later changed our\n+  \/\/ minds, we got no pre-loop.  Either we need to make a new pre-loop, or we\n+  \/\/ have to disallow RCE.\n@@ -993,3 +1033,3 @@\n-      \/\/ Yeah!  Found a test like 'trip+off vs limit'\n-      \/\/ Test is an IfNode, has 2 projections.  If BOTH are in the loop\n-      \/\/ we need loop unswitching instead of iteration splitting.\n+      \/\/ Found a test like 'trip+off vs limit'. Test is an IfNode, has two (2)\n+      \/\/ projections. If BOTH are in the loop we need loop unswitching instead\n+      \/\/ of iteration splitting.\n@@ -997,1 +1037,3 @@\n-        return true;            \/\/ Found reason to split iterations\n+        \/\/ Found valid reason to split iterations (if there is room).\n+        \/\/ NOTE: Usually a gross overestimate.\n+        return phase->may_require_nodes(est_loop_clone_sz(2));\n@@ -1009,0 +1051,4 @@\n+\n+  \/\/ If nodes are depleted, some transform has miscalculated its needs.\n+  assert(!phase->exceeding_node_budget(), \"sanity\");\n+\n@@ -1587,0 +1633,4 @@\n+  if (!may_require_nodes(loop->est_loop_clone_sz(2))) {\n+    return;\n+  }\n+\n@@ -1917,1 +1967,2 @@\n-        stride_con < 0 && ((limit_type->_lo - stride_con) > limit_type->_lo), \"sanity\");\n+           stride_con < 0 && ((limit_type->_lo - stride_con) > limit_type->_lo),\n+           \"sanity\");\n@@ -1986,0 +2037,1 @@\n+\n@@ -2097,1 +2149,0 @@\n-\n@@ -3203,0 +3254,5 @@\n+  if (!_head->is_Loop()) {\n+    \/\/ Head could be a region with a NeverBranch that was added in beautify loops but the region was not\n+    \/\/ yet transformed into a LoopNode. Bail out and wait until beautify loops turns it into a Loop node.\n+    return false;\n+  }\n@@ -3214,1 +3270,0 @@\n-  bool should_peel = policy_peeling(phase); \/\/ Should we peel?\n@@ -3216,1 +3271,1 @@\n-  bool should_unswitch = policy_unswitching(phase);\n+  AutoNodeBudget node_budget(phase);\n@@ -3225,1 +3280,1 @@\n-    if (should_peel) {            \/\/ Should we peel?\n+    if (policy_peeling(phase)) {    \/\/ Should we peel?\n@@ -3227,2 +3282,2 @@\n-      phase->do_peeling(this,old_new);\n-    } else if (should_unswitch) {\n+      phase->do_peeling(this, old_new);\n+    } else if (policy_unswitching(phase)) {\n@@ -3247,1 +3302,1 @@\n-    if (should_unswitch) {\n+    if (policy_unswitching(phase)) {\n@@ -3251,2 +3306,1 @@\n-    bool should_maximally_unroll =  policy_maximally_unroll(phase);\n-    if (should_maximally_unroll) {\n+    if (policy_maximally_unroll(phase)) {\n@@ -3255,1 +3309,1 @@\n-      phase->do_maximally_unroll(this,old_new);\n+      phase->do_maximally_unroll(this, old_new);\n@@ -3260,6 +3314,2 @@\n-  \/\/ Skip next optimizations if running low on nodes. Note that\n-  \/\/ policy_unswitching and policy_maximally_unroll have this check.\n-  int nodes_left = phase->C->max_node_limit() - phase->C->live_nodes();\n-  if ((int)(2 * _body.size()) > nodes_left) {\n-    return true;\n-  }\n+  uint est_peeling = estimate_peeling(phase);\n+  bool should_peel = 0 < est_peeling;\n@@ -3280,0 +3330,3 @@\n+  bool should_rce    = policy_range_check(phase);\n+  \/\/ TODO: Remove align -- not used.\n+  bool should_align  = policy_align(phase);\n@@ -3281,7 +3334,3 @@\n-  bool should_rce = policy_range_check(phase);\n-\n-  bool should_align = policy_align(phase);\n-\n-  \/\/ If not RCE'ing (iteration splitting) or Aligning, then we do not\n-  \/\/ need a pre-loop.  We may still need to peel an initial iteration but\n-  \/\/ we will not be needing an unknown number of pre-iterations.\n+  \/\/ If not RCE'ing  (iteration splitting) or Aligning, then we  do not need a\n+  \/\/ pre-loop.  We may still need to peel an initial iteration but we will not\n+  \/\/ be needing an unknown number of pre-iterations.\n@@ -3289,2 +3338,2 @@\n-  \/\/ Basically, if may_rce_align reports FALSE first time through,\n-  \/\/ we will not be able to later do RCE or Aligning on this loop.\n+  \/\/ Basically, if may_rce_align reports FALSE first time through, we will not\n+  \/\/ be able to later do RCE or Aligning on this loop.\n@@ -3297,6 +3346,10 @@\n-    if (cl->is_normal_loop())  \/\/ Convert to 'pre\/main\/post' loops\n-      phase->insert_pre_post_loops(this,old_new, !may_rce_align);\n-\n-    \/\/ Adjust the pre- and main-loop limits to let the pre and post loops run\n-    \/\/ with full checks, but the main-loop with no checks.  Remove said\n-    \/\/ checks from the main body.\n+    if (cl->is_normal_loop()) { \/\/ Convert to 'pre\/main\/post' loops\n+      uint estimate = est_loop_clone_sz(3);\n+      if (!phase->may_require_nodes(estimate)) {\n+        return false;\n+      }\n+      phase->insert_pre_post_loops(this, old_new, !may_rce_align);\n+    }\n+    \/\/ Adjust the pre- and main-loop limits to let the pre and  post loops run\n+    \/\/ with full checks, but the main-loop with no checks.  Remove said checks\n+    \/\/ from the main body.\n@@ -3336,1 +3389,3 @@\n-      phase->do_peeling(this,old_new);\n+      if (phase->may_require_nodes(est_peeling)) {\n+        phase->do_peeling(this, old_new);\n+      }\n@@ -3366,3 +3421,6 @@\n-    } else if (policy_unswitching(phase)) {\n-      phase->do_unswitching(this, old_new);\n-      return false; \/\/ need to recalculate idom data\n+    } else {\n+      AutoNodeBudget node_budget(phase);\n+      if (policy_unswitching(phase)) {\n+        phase->do_unswitching(this, old_new);\n+        return false; \/\/ need to recalculate idom data\n+      }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":169,"deletions":111,"binary":false,"changes":280,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-  if( !LoopUnswitching ) {\n+  if (!LoopUnswitching) {\n@@ -65,0 +65,3 @@\n+  \/\/ If nodes are depleted, some transform has miscalculated its needs.\n+  assert(!phase->exceeding_node_budget(), \"sanity\");\n+\n@@ -70,4 +73,0 @@\n-  int nodes_left = phase->C->max_node_limit() - phase->C->live_nodes();\n-  if ((int)(2 * _body.size()) > nodes_left) {\n-    return false; \/\/ Too speculative if running low on nodes.\n-  }\n@@ -78,1 +77,6 @@\n-  return phase->find_unswitching_candidate(this) != NULL;\n+  if (phase->find_unswitching_candidate(this) == NULL) {\n+    return false;\n+  }\n+\n+  \/\/ Too speculative if running low on nodes.\n+  return phase->may_require_nodes(est_loop_clone_sz(2));\n@@ -115,1 +119,1 @@\n-void PhaseIdealLoop::do_unswitching (IdealLoopTree *loop, Node_List &old_new) {\n+void PhaseIdealLoop::do_unswitching(IdealLoopTree *loop, Node_List &old_new) {\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -2472,0 +2472,84 @@\n+\n+\/\/ The Estimated Loop Clone Size:\n+\/\/   CloneFactor * (~112% * BodySize + BC) + CC + FanOutTerm,\n+\/\/ where  BC and  CC are  totally ad-hoc\/magic  \"body\" and \"clone\" constants,\n+\/\/ respectively, used to ensure that the node usage estimates made are on the\n+\/\/ safe side, for the most part. The FanOutTerm is an attempt to estimate the\n+\/\/ possible additional\/excessive nodes generated due to data and control flow\n+\/\/ merging, for edges reaching outside the loop.\n+uint IdealLoopTree::est_loop_clone_sz(uint factor) const {\n+\n+  precond(0 < factor && factor < 16);\n+\n+  uint const bc = 13;\n+  uint const cc = 17;\n+  uint const sz = _body.size() + (_body.size() + 7) \/ 8;\n+  uint estimate = factor * (sz + bc) + cc;\n+\n+  assert((estimate - cc) \/ factor == sz + bc, \"overflow\");\n+\n+  return estimate + est_loop_flow_merge_sz();\n+}\n+\n+\/\/ The Estimated Loop (full-) Unroll Size:\n+\/\/   UnrollFactor * (~106% * BodySize) + CC + FanOutTerm,\n+\/\/ where CC is a (totally) ad-hoc\/magic \"clone\" constant, used to ensure that\n+\/\/ node usage estimates made are on the safe side, for the most part. This is\n+\/\/ a \"light\" version of the loop clone size calculation (above), based on the\n+\/\/ assumption that most of the loop-construct overhead will be unraveled when\n+\/\/ (fully) unrolled. Defined for unroll factors larger or equal to one (>=1),\n+\/\/ including an overflow check and returning UINT_MAX in case of an overflow.\n+uint IdealLoopTree::est_loop_unroll_sz(uint factor) const {\n+\n+  precond(factor > 0);\n+\n+  \/\/ Take into account that after unroll conjoined heads and tails will fold.\n+  uint const b0 = _body.size() - EMPTY_LOOP_SIZE;\n+  uint const cc = 7;\n+  uint const sz = b0 + (b0 + 15) \/ 16;\n+  uint estimate = factor * sz + cc;\n+\n+  if ((estimate - cc) \/ factor != sz) {\n+    return UINT_MAX;\n+  }\n+\n+  return estimate + est_loop_flow_merge_sz();\n+}\n+\n+\/\/ Estimate the growth effect (in nodes) of merging control and data flow when\n+\/\/ cloning a loop body, based on the amount of  control and data flow reaching\n+\/\/ outside of the (current) loop body.\n+uint IdealLoopTree::est_loop_flow_merge_sz() const {\n+\n+  uint ctrl_edge_out_cnt = 0;\n+  uint data_edge_out_cnt = 0;\n+\n+  for (uint i = 0; i < _body.size(); i++) {\n+    Node* node = _body.at(i);\n+    uint outcnt = node->outcnt();\n+\n+    for (uint k = 0; k < outcnt; k++) {\n+      Node* out = node->raw_out(k);\n+\n+      if (out->is_CFG()) {\n+        if (!is_member(_phase->get_loop(out))) {\n+          ctrl_edge_out_cnt++;\n+        }\n+      } else {\n+        Node* ctrl = _phase->get_ctrl(out);\n+        assert(ctrl->is_CFG(), \"must be\");\n+        if (!is_member(_phase->get_loop(ctrl))) {\n+          data_edge_out_cnt++;\n+        }\n+      }\n+    }\n+  }\n+  \/\/ Use data and control count (x2.0) in estimate iff both are > 0. This is\n+  \/\/ a rather pessimistic estimate for the most part, in particular for some\n+  \/\/ complex loops, but still not enough to capture all loops.\n+  if (ctrl_edge_out_cnt > 0 && data_edge_out_cnt > 0) {\n+    return 2 * (ctrl_edge_out_cnt + data_edge_out_cnt);\n+  }\n+  return 0;\n+}\n+\n@@ -2475,4 +2559,3 @@\n-void IdealLoopTree::dump_head( ) const {\n-  for (uint i=0; i<_nest; i++)\n-    tty->print(\"  \");\n-  tty->print(\"Loop: N%d\/N%d \",_head->_idx,_tail->_idx);\n+void IdealLoopTree::dump_head() const {\n+  tty->sp(2 * _nest);\n+  tty->print(\"Loop: N%d\/N%d \", _head->_idx, _tail->_idx);\n@@ -2546,1 +2629,1 @@\n-void IdealLoopTree::dump( ) const {\n+void IdealLoopTree::dump() const {\n@@ -2973,2 +3056,2 @@\n-  if(VerifyLoopOptimizations) verify();\n-  if(TraceLoopOpts && C->has_loops()) {\n+  if (VerifyLoopOptimizations) verify();\n+  if (TraceLoopOpts && C->has_loops()) {\n@@ -3012,4 +3095,6 @@\n-      if (is_counted && lpt->_head->as_CountedLoop()->is_unroll_only()) continue;\n-\n-      lpt->reassociate_invariants(this);\n-\n+      if (is_counted && lpt->_head->as_CountedLoop()->is_unroll_only()) {\n+        continue;\n+      } else {\n+        AutoNodeBudget node_budget(this);\n+        lpt->reassociate_invariants(this);\n+      }\n@@ -3020,0 +3105,1 @@\n+        AutoNodeBudget node_budget(this, AutoNodeBudget::NO_BUDGET_CHECK);\n@@ -4577,1 +4663,1 @@\n-void PhaseIdealLoop::dump( ) const {\n+void PhaseIdealLoop::dump() const {\n@@ -4584,1 +4670,1 @@\n-  rpo( C->root(), stack, visited, rpo_list );\n+  rpo(C->root(), stack, visited, rpo_list);\n@@ -4586,1 +4672,1 @@\n-  dump( _ltree_root, rpo_list.size(), rpo_list );\n+  dump(_ltree_root, rpo_list.size(), rpo_list);\n@@ -4589,1 +4675,1 @@\n-void PhaseIdealLoop::dump( IdealLoopTree *loop, uint idx, Node_List &rpo_list ) const {\n+void PhaseIdealLoop::dump(IdealLoopTree* loop, uint idx, Node_List &rpo_list) const {\n@@ -4593,3 +4679,3 @@\n-  for( uint j=idx; j > 0;  j-- ) {\n-    Node *n = rpo_list[j-1];\n-    if( !_nodes[n->_idx] )      \/\/ Skip dead nodes\n+  for (uint j = idx; j > 0; j--) {\n+    Node* n = rpo_list[j-1];\n+    if (!_nodes[n->_idx])      \/\/ Skip dead nodes\n@@ -4597,4 +4683,5 @@\n-    if( get_loop(n) != loop ) { \/\/ Wrong loop nest\n-      if( get_loop(n)->_head == n &&    \/\/ Found nested loop?\n-          get_loop(n)->_parent == loop )\n-        dump(get_loop(n),rpo_list.size(),rpo_list);     \/\/ Print it nested-ly\n+\n+    if (get_loop(n) != loop) { \/\/ Wrong loop nest\n+      if (get_loop(n)->_head == n &&    \/\/ Found nested loop?\n+          get_loop(n)->_parent == loop)\n+        dump(get_loop(n), rpo_list.size(), rpo_list);     \/\/ Print it nested-ly\n@@ -4605,2 +4692,1 @@\n-    for( uint x = 0; x < loop->_nest; x++ )\n-      tty->print(\"  \");\n+    tty->sp(2 * loop->_nest);\n@@ -4608,1 +4694,1 @@\n-    if( n == C->root() ) {\n+    if (n == C->root()) {\n@@ -4612,2 +4698,2 @@\n-      Node *computed_idom = n->in(0);\n-      if( n->is_Region() ) {\n+      Node* computed_idom = n->in(0);\n+      if (n->is_Region()) {\n@@ -4620,1 +4706,1 @@\n-      tty->print(\" ID:%d\",computed_idom->_idx);\n+      tty->print(\" ID:%d\", computed_idom->_idx);\n@@ -4622,1 +4708,1 @@\n-      if( cached_idom != computed_idom ) {\n+      if (cached_idom != computed_idom) {\n@@ -4628,1 +4714,1 @@\n-    for( uint k = 0; k < _nodes.Size(); k++ ) {\n+    for (uint k = 0; k < _nodes.Size(); k++) {\n@@ -4631,2 +4717,2 @@\n-        Node *m = C->root()->find(k);\n-        if( m && m->outcnt() > 0 ) {\n+        Node* m = C->root()->find(k);\n+        if (m && m->outcnt() > 0) {\n@@ -4637,3 +4723,1 @@\n-          for( uint j = 0; j < loop->_nest; j++ )\n-            tty->print(\"  \");\n-          tty->print(\" \");\n+          tty->sp(2 * loop->_nest + 1);\n@@ -4663,1 +4747,1 @@\n-void PhaseIdealLoop::rpo( Node *start, Node_Stack &stk, VectorSet &visited, Node_List &rpo_list ) const {\n+void PhaseIdealLoop::rpo(Node* start, Node_Stack &stk, VectorSet &visited, Node_List &rpo_list) const {\n@@ -4686,1 +4770,1 @@\n-\/\/------------------------------LoopTreeIterator-----------------------------------\n+\/\/------------------------------LoopTreeIterator-------------------------------\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":122,"deletions":38,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -373,7 +373,7 @@\n-inline CountedLoopEndNode *CountedLoopNode::loopexit_or_null() const {\n-  Node *bc = back_control();\n-  if( bc == NULL ) return NULL;\n-  Node *le = bc->in(0);\n-  if( le->Opcode() != Op_CountedLoopEnd )\n-    return NULL;\n-  return (CountedLoopEndNode*)le;\n+inline CountedLoopEndNode* CountedLoopNode::loopexit_or_null() const {\n+  Node* bctrl = back_control();\n+  if (bctrl == NULL) return NULL;\n+\n+  Node* lexit = bctrl->in(0);\n+  return (CountedLoopEndNode*)\n+      (lexit->Opcode() == Op_CountedLoopEnd ? lexit : NULL);\n@@ -381,1 +381,2 @@\n-inline CountedLoopEndNode *CountedLoopNode::loopexit() const {\n+\n+inline CountedLoopEndNode* CountedLoopNode::loopexit() const {\n@@ -386,7 +387,29 @@\n-inline Node *CountedLoopNode::init_trip() const { return loopexit_or_null() ? loopexit()->init_trip() : NULL; }\n-inline Node *CountedLoopNode::stride() const { return loopexit_or_null() ? loopexit()->stride() : NULL; }\n-inline int CountedLoopNode::stride_con() const { return loopexit_or_null() ? loopexit()->stride_con() : 0; }\n-inline bool CountedLoopNode::stride_is_con() const { return loopexit_or_null() && loopexit()->stride_is_con(); }\n-inline Node *CountedLoopNode::limit() const { return loopexit_or_null() ? loopexit()->limit() : NULL; }\n-inline Node *CountedLoopNode::incr() const { return loopexit_or_null() ? loopexit()->incr() : NULL; }\n-inline Node *CountedLoopNode::phi() const { return loopexit_or_null() ? loopexit()->phi() : NULL; }\n+\n+inline Node* CountedLoopNode::init_trip() const {\n+  CountedLoopEndNode* cle = loopexit_or_null();\n+  return cle != NULL ? cle->init_trip() : NULL;\n+}\n+inline Node* CountedLoopNode::stride() const {\n+  CountedLoopEndNode* cle = loopexit_or_null();\n+  return cle != NULL ? cle->stride() : NULL;\n+}\n+inline int CountedLoopNode::stride_con() const {\n+  CountedLoopEndNode* cle = loopexit_or_null();\n+  return cle != NULL ? cle->stride_con() : 0;\n+}\n+inline bool CountedLoopNode::stride_is_con() const {\n+  CountedLoopEndNode* cle = loopexit_or_null();\n+  return cle != NULL && cle->stride_is_con();\n+}\n+inline Node* CountedLoopNode::limit() const {\n+  CountedLoopEndNode* cle = loopexit_or_null();\n+  return cle != NULL ? cle->limit() : NULL;\n+}\n+inline Node* CountedLoopNode::incr() const {\n+  CountedLoopEndNode* cle = loopexit_or_null();\n+  return cle != NULL ? cle->incr() : NULL;\n+}\n+inline Node* CountedLoopNode::phi() const {\n+  CountedLoopEndNode* cle = loopexit_or_null();\n+  return cle != NULL ? cle->phi() : NULL;\n+}\n@@ -461,3 +484,3 @@\n-  \/\/ If tail is NULL then this loop has multiple backedges as part of the\n-  \/\/ same loop.  During cleanup I'll peel off the multiple backedges; merge\n-  \/\/ them at the loop bottom and flow 1 real backedge into the loop.\n+  \/\/ If a loop has multiple backedges, this is addressed during cleanup where\n+  \/\/ we peel off the multiple backedges,  merging all edges at the bottom and\n+  \/\/ ensuring that one proper backedge flow into the loop.\n@@ -493,1 +516,4 @@\n-  { }\n+  {\n+    precond(_head != NULL);\n+    precond(_tail != NULL);\n+  }\n@@ -569,4 +595,5 @@\n-  \/\/ Return TRUE or FALSE if the loop should be peeled or not.  Peel if we can\n-  \/\/ make some loop-invariant test (usually a null-check) happen before the\n-  \/\/ loop.\n-  bool policy_peeling( PhaseIdealLoop *phase ) const;\n+  \/\/ Return TRUE or FALSE if the loop should be peeled or not. Peel if we can\n+  \/\/ move some loop-invariant test (usually a null-check) before the loop.\n+  bool policy_peeling(PhaseIdealLoop *phase);\n+\n+  uint estimate_peeling(PhaseIdealLoop *phase);\n@@ -576,1 +603,1 @@\n-  bool policy_maximally_unroll( PhaseIdealLoop *phase ) const;\n+  bool policy_maximally_unroll(PhaseIdealLoop *phase) const;\n@@ -578,2 +605,2 @@\n-  \/\/ Return TRUE or FALSE if the loop should be unrolled or not.  Unroll if\n-  \/\/ the loop is a CountedLoop and the body is small enough.\n+  \/\/ Return TRUE or FALSE if the loop should be unrolled or not. Apply unroll\n+  \/\/ if the loop is a counted loop and the loop body is small enough.\n@@ -600,0 +627,5 @@\n+  \/\/ Estimate the number of nodes required when cloning a loop (body).\n+  uint est_loop_clone_sz(uint factor) const;\n+  \/\/ Estimate the number of nodes required when unrolling a loop (body).\n+  uint est_loop_unroll_sz(uint factor) const;\n+\n@@ -630,1 +662,1 @@\n-  void dump_head( ) const;      \/\/ Dump loop head only\n+  void dump_head() const;       \/\/ Dump loop head only\n@@ -635,0 +667,5 @@\n+ private:\n+  enum { EMPTY_LOOP_SIZE = 7 }; \/\/ Number of nodes in an empty loop.\n+\n+  \/\/ Estimate the number of nodes resulting from control and data flow merge.\n+  uint est_loop_flow_merge_sz() const;\n@@ -638,2 +675,2 @@\n-\/\/ Computes the mapping from Nodes to IdealLoopTrees.  Organizes IdealLoopTrees into a\n-\/\/ loop tree.  Drives the loop-based transformations on the ideal graph.\n+\/\/ Computes the mapping from Nodes to IdealLoopTrees. Organizes IdealLoopTrees\n+\/\/ into a loop tree. Drives the loop-based transformations on the ideal graph.\n@@ -644,0 +681,1 @@\n+  friend class AutoNodeBudget;\n@@ -649,1 +687,1 @@\n-  IdealLoopTree *_ltree_root;\n+  IdealLoopTree* _ltree_root;\n@@ -738,2 +776,1 @@\n-  \/\/ Helper function for directing control inputs away from CFG split\n-  \/\/ points.\n+  \/\/ Helper function for directing control inputs away from CFG split points.\n@@ -942,0 +979,1 @@\n+    _nodes_required(UINT_MAX),\n@@ -962,0 +1000,1 @@\n+    _nodes_required(UINT_MAX),\n@@ -972,0 +1011,1 @@\n+    _nodes_required(UINT_MAX),\n@@ -989,1 +1029,1 @@\n-  virtual Node *transform( Node *a_node ) { return 0; }\n+  virtual Node* transform(Node* n) { return 0; }\n@@ -991,1 +1031,1 @@\n-  bool is_counted_loop(Node* x, IdealLoopTree*& loop);\n+  bool is_counted_loop(Node* n, IdealLoopTree* &loop);\n@@ -1006,1 +1046,1 @@\n-  IdealLoopTree *ltree_root() const { return _ltree_root; }\n+  IdealLoopTree* ltree_root() const { return _ltree_root; }\n@@ -1277,1 +1317,1 @@\n-  \/\/ Conversion of fill\/copy patterns into intrisic versions\n+  \/\/ Conversion of fill\/copy patterns into intrinsic versions\n@@ -1321,0 +1361,66 @@\n+  \/\/ A simplistic node request tracking mechanism, where\n+  \/\/   = UINT_MAX   Request not valid or made final.\n+  \/\/   < UINT_MAX   Nodes currently requested (estimate).\n+  uint _nodes_required;\n+\n+  enum { REQUIRE_MIN = 70 };\n+\n+  uint nodes_required() const { return _nodes_required; }\n+\n+  \/\/ Given the _currently_  available number of nodes, check  whether there is\n+  \/\/ \"room\" for an additional request or not, considering the already required\n+  \/\/ number of  nodes.  Return TRUE if  the new request is  exceeding the node\n+  \/\/ budget limit, otherwise return FALSE.  Note that this interpretation will\n+  \/\/ act pessimistic on  additional requests when new nodes  have already been\n+  \/\/ generated since the 'begin'.  This behaviour fits with the intention that\n+  \/\/ node estimates\/requests should be made upfront.\n+  bool exceeding_node_budget(uint required = 0) {\n+    assert(C->live_nodes() < C->max_node_limit(), \"sanity\");\n+    uint available = C->max_node_limit() - C->live_nodes();\n+    return available < required + _nodes_required + REQUIRE_MIN;\n+  }\n+\n+  uint require_nodes(uint require, uint minreq = REQUIRE_MIN) {\n+    precond(require > 0);\n+    _nodes_required += MAX2(100u, require); \/\/ Keep requests at minimum 100.\n+    _nodes_required += MAX2(require, minreq);\n+    return _nodes_required;\n+  }\n+\n+  bool may_require_nodes(uint require, uint minreq = REQUIRE_MIN) {\n+    return !exceeding_node_budget(require) && require_nodes(require, minreq) > 0;\n+  }\n+\n+  uint require_nodes_begin() {\n+    assert(_nodes_required == UINT_MAX, \"Bad state (begin).\");\n+    _nodes_required = 0;\n+    return C->live_nodes();\n+  }\n+\n+  \/\/ When a node request is final,  optionally check that the requested number\n+  \/\/ of nodes was  reasonably correct with respect to the  number of new nodes\n+  \/\/ introduced since the last 'begin'. Always check that we have not exceeded\n+  \/\/ the maximum node limit.\n+  void require_nodes_final(uint live_at_begin, bool check_estimate) {\n+    assert(_nodes_required < UINT_MAX, \"Bad state (final).\");\n+\n+#ifdef ASSERT\n+    if (check_estimate) {\n+      \/\/ Check that the node budget request was not off by too much (x2).\n+      \/\/ Should this be the case we _surely_ need to improve the estimates\n+      \/\/ used in our budget calculations.\n+      if (C->live_nodes() - live_at_begin > 2 * _nodes_required) {\n+        log_info(compilation)(\"Bad node estimate: actual = %d >> request = %d\",\n+                              C->live_nodes() - live_at_begin, _nodes_required);\n+      }\n+    }\n+#endif\n+    \/\/ Assert that we have stayed within the node budget limit.\n+    assert(C->live_nodes() < C->max_node_limit(),\n+           \"Exceeding node budget limit: %d + %d > %d (request = %d)\",\n+           C->live_nodes() - live_at_begin, live_at_begin,\n+           C->max_node_limit(), _nodes_required);\n+\n+    _nodes_required = UINT_MAX;\n+  }\n+\n@@ -1330,1 +1436,1 @@\n-  void register_new_node( Node *n, Node *blk );\n+  void register_new_node(Node* n, Node* blk);\n@@ -1339,1 +1445,1 @@\n-  void dump(IdealLoopTree *loop, uint rpo_idx, Node_List &rpo_list) const;\n+  void dump(IdealLoopTree* loop, uint rpo_idx, Node_List &rpo_list) const;\n@@ -1341,2 +1447,2 @@\n-  void verify_compare(Node *n, const PhaseIdealLoop *loop_verify, VectorSet &visited) const;\n-  IdealLoopTree *get_loop_idx(Node* n) const {\n+  void verify_compare(Node* n, const PhaseIdealLoop* loop_verify, VectorSet &visited) const;\n+  IdealLoopTree* get_loop_idx(Node* n) const {\n@@ -1352,1 +1458,1 @@\n-  void rpo( Node *start, Node_Stack &stk, VectorSet &visited, Node_List &rpo_list ) const;\n+  void rpo(Node* start, Node_Stack &stk, VectorSet &visited, Node_List &rpo_list) const;\n@@ -1359,0 +1465,46 @@\n+\n+class AutoNodeBudget : public StackObj\n+{\n+public:\n+  enum budget_check_t { BUDGET_CHECK, NO_BUDGET_CHECK };\n+\n+  AutoNodeBudget(PhaseIdealLoop* phase, budget_check_t chk = BUDGET_CHECK)\n+    : _phase(phase),\n+      _check_at_final(chk == BUDGET_CHECK),\n+      _nodes_at_begin(0)\n+  {\n+    precond(_phase != NULL);\n+\n+    _nodes_at_begin = _phase->require_nodes_begin();\n+  }\n+\n+  ~AutoNodeBudget() {\n+#ifndef PRODUCT\n+    if (TraceLoopOpts) {\n+      uint request = _phase->nodes_required();\n+      uint delta   = _phase->C->live_nodes() - _nodes_at_begin;\n+\n+      if (request < delta) {\n+        tty->print_cr(\"Exceeding node budget: %d < %d\", request, delta);\n+      } else {\n+        uint const REQUIRE_MIN = PhaseIdealLoop::REQUIRE_MIN;\n+        \/\/ Identify the worst estimates as \"poor\" ones.\n+        if (request > REQUIRE_MIN && delta > 0) {\n+          if ((delta >  REQUIRE_MIN && request >  3 * delta) ||\n+              (delta <= REQUIRE_MIN && request > 10 * delta)) {\n+            tty->print_cr(\"Poor node estimate: %d >> %d\", request, delta);\n+          }\n+        }\n+      }\n+    }\n+#endif \/\/ PRODUCT\n+    _phase->require_nodes_final(_nodes_at_begin, _check_at_final);\n+  }\n+\n+private:\n+  PhaseIdealLoop* _phase;\n+  bool _check_at_final;\n+  uint _nodes_at_begin;\n+};\n+\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":193,"deletions":41,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -2718,1 +2718,1 @@\n-#if !defined(PRODUCT)\n+#ifndef PRODUCT\n@@ -2756,1 +2756,1 @@\n-#if !defined(PRODUCT)\n+#ifndef PRODUCT\n@@ -3085,3 +3085,3 @@\n-    return false;  }\n-\n-  LoopNode *head  = loop->_head->as_Loop();\n+    return false;\n+  }\n+  LoopNode *head = loop->_head->as_Loop();\n@@ -3094,1 +3094,1 @@\n-  for(uint ii = 0; ii < loop->_body.size(); ii++ ) {\n+  for (uint ii = 0; ii < loop->_body.size(); ii++) {\n@@ -3102,1 +3102,1 @@\n-#if !defined(PRODUCT)\n+#ifndef PRODUCT\n@@ -3121,2 +3121,2 @@\n-  while( iff != head ) {\n-    if( iff->is_If() ) {\n+  while (iff != head) {\n+    if (iff->is_If()) {\n@@ -3126,1 +3126,1 @@\n-      if( loop->is_member(get_loop(ctrl)) &&\n+      if (loop->is_member(get_loop(ctrl)) &&\n@@ -3140,0 +3140,1 @@\n+\n@@ -3158,1 +3159,1 @@\n-#if !defined(PRODUCT)\n+#ifndef PRODUCT\n@@ -3187,0 +3188,5 @@\n+  uint estimate = loop->est_loop_clone_sz(1);\n+  if (exceeding_node_budget(estimate)) {\n+    return false;\n+  }\n+\n@@ -3208,2 +3214,1 @@\n-  uint i;\n-  for(i = 0; i < loop->_body.size(); i++ ) {\n+  for (uint i = 0; i < loop->_body.size(); i++) {\n@@ -3224,1 +3229,1 @@\n-  scheduled_nodelist(loop, peel, peel_list );\n+  scheduled_nodelist(loop, peel, peel_list);\n@@ -3235,1 +3240,1 @@\n-#if !defined(PRODUCT)\n+#ifndef PRODUCT\n@@ -3244,1 +3249,1 @@\n-  for (i = 0; i < peel_list.size();) {\n+  for (uint i = 0; i < peel_list.size();) {\n@@ -3246,1 +3251,1 @@\n-#if !defined(PRODUCT)\n+#ifndef PRODUCT\n@@ -3250,4 +3255,2 @@\n-    if ( !n->is_CFG() ) {\n-\n-      if ( has_use_in_set(n, not_peel) ) {\n-\n+    if (!n->is_CFG()) {\n+      if (has_use_in_set(n, not_peel)) {\n@@ -3256,3 +3259,1 @@\n-\n-        if ( !has_use_internal_to_set(n, peel, loop) ) {\n-\n+        if (!has_use_internal_to_set(n, peel, loop)) {\n@@ -3262,1 +3263,1 @@\n-            cloned_for_outside_use += clone_for_use_outside_loop( loop, n, worklist );\n+            cloned_for_outside_use += clone_for_use_outside_loop(loop, n, worklist);\n@@ -3268,1 +3269,1 @@\n-#if !defined(PRODUCT)\n+#ifndef PRODUCT\n@@ -3278,1 +3279,1 @@\n-          clone_for_special_use_inside_loop( loop, n, not_peel, sink_list, worklist );\n+          clone_for_special_use_inside_loop(loop, n, not_peel, sink_list, worklist);\n@@ -3286,2 +3287,6 @@\n-  if (new_phi_cnt > old_phi_cnt + PartialPeelNewPhiDelta) {\n-#if !defined(PRODUCT)\n+  estimate += cloned_for_outside_use + new_phi_cnt;\n+  bool exceed_node_budget = !may_require_nodes(estimate);\n+  bool exceed_phi_limit = new_phi_cnt > old_phi_cnt + PartialPeelNewPhiDelta;\n+\n+  if (exceed_node_budget || exceed_phi_limit) {\n+#ifndef PRODUCT\n@@ -3334,1 +3339,1 @@\n-  assert(is_valid_clone_loop_form( loop, peel_list, orig_exit_idx, clone_exit_idx ), \"bad clone loop\");\n+  assert(is_valid_clone_loop_form(loop, peel_list, orig_exit_idx, clone_exit_idx), \"bad clone loop\");\n@@ -3342,1 +3347,1 @@\n-  for(i = 0; i < peel_list.size(); i++ ) {\n+  for (uint i = 0; i < peel_list.size(); i++) {\n@@ -3398,1 +3403,1 @@\n-  for(i = 0; i < loop->_body.size(); i++ ) {\n+  for (uint i = 0; i < loop->_body.size(); i++) {\n@@ -3445,1 +3450,1 @@\n-#if !defined(PRODUCT)\n+#ifndef PRODUCT\n@@ -3485,4 +3490,4 @@\n-  \/\/ Check for the special case of folks using the pre-incremented\n-  \/\/ trip-counter on the fall-out path (forces the pre-incremented\n-  \/\/ and post-incremented trip counter to be live at the same time).\n-  \/\/ Fix this by adjusting to use the post-increment trip counter.\n+  \/\/ Check for the special case when using the pre-incremented trip-counter on\n+  \/\/ the fall-out  path (forces the pre-incremented  and post-incremented trip\n+  \/\/ counter to be live  at the same time).  Fix this by  adjusting to use the\n+  \/\/ post-increment trip counter.\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":43,"deletions":38,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -3445,1 +3445,1 @@\n-JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name))\n+JVM_ENTRY_NO_ENV(void*, JVM_LoadLibrary(const char* name, jboolean throwException))\n@@ -3455,12 +3455,16 @@\n-    char msg[1024];\n-    jio_snprintf(msg, sizeof msg, \"%s: %s\", name, ebuf);\n-    \/\/ Since 'ebuf' may contain a string encoded using\n-    \/\/ platform encoding scheme, we need to pass\n-    \/\/ Exceptions::unsafe_to_utf8 to the new_exception method\n-    \/\/ as the last argument. See bug 6367357.\n-    Handle h_exception =\n-      Exceptions::new_exception(thread,\n-                                vmSymbols::java_lang_UnsatisfiedLinkError(),\n-                                msg, Exceptions::unsafe_to_utf8);\n-\n-    THROW_HANDLE_0(h_exception);\n+    if (throwException) {\n+      char msg[1024];\n+      jio_snprintf(msg, sizeof msg, \"%s: %s\", name, ebuf);\n+      \/\/ Since 'ebuf' may contain a string encoded using\n+      \/\/ platform encoding scheme, we need to pass\n+      \/\/ Exceptions::unsafe_to_utf8 to the new_exception method\n+      \/\/ as the last argument. See bug 6367357.\n+      Handle h_exception =\n+        Exceptions::new_exception(thread,\n+                                  vmSymbols::java_lang_UnsatisfiedLinkError(),\n+                                  msg, Exceptions::unsafe_to_utf8);\n+\n+      THROW_HANDLE_0(h_exception);\n+    } else {\n+      return load_result;\n+    }\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -144,0 +144,3 @@\n+#if INCLUDE_CDS && INCLUDE_JVMTI\n+Mutex*   CDSClassFileStream_lock      = NULL;\n+#endif\n@@ -346,0 +349,3 @@\n+#if INCLUDE_CDS && INCLUDE_JVMTI\n+  def(CDSClassFileStream_lock      , PaddedMutex  , max_nonleaf, false, Monitor::_safepoint_check_always);\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -141,0 +141,3 @@\n+#if INCLUDE_CDS && INCLUDE_JVMTI\n+extern Mutex*   CDSClassFileStream_lock;         \/\/ FileMapInfo::open_stream_for_jvmti\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4788,0 +4788,1 @@\n+        st->print(\"  \");\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-inline int g_isnan(float  f) { return isnanf(f); }\n+inline int g_isnan(float  f) { return isnan(f); }\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_gcc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1801,0 +1801,6 @@\n+#ifdef __APPLE__\n+  \/\/ 12 is unreliable on this platform, may just yield us a \"Trap\" message on stdout\n+  \/\/ Use 14 instead, which seems to work always\n+  if (how == 12) { how = 14; }\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ * Data structure to hold info from \/proc\/self\/cgroup\n+ *\n+ * man 7 cgroups\n+ *\n+ * @see CgroupSubsystemFactory\n+ *\/\n+class CgroupInfo {\n+\n+    private final String name;\n+    private final int hierarchyId;\n+    private final boolean enabled;\n+\n+    private CgroupInfo(String name, int hierarchyId, boolean enabled) {\n+        this.name = name;\n+        this.hierarchyId = hierarchyId;\n+        this.enabled = enabled;\n+    }\n+\n+    String getName() {\n+        return name;\n+    }\n+\n+    int getHierarchyId() {\n+        return hierarchyId;\n+    }\n+\n+    boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    static CgroupInfo fromCgroupsLine(String line) {\n+        String[] tokens = line.split(\"\\\\s+\");\n+        if (tokens.length != 4) {\n+            return null;\n+        }\n+        \/\/ discard 3'rd field, num_cgroups\n+        return new CgroupInfo(tokens[0] \/* name *\/,\n+                              Integer.parseInt(tokens[1]) \/* hierarchyId *\/,\n+                              (Integer.parseInt(tokens[3]) == 1) \/* enabled *\/);\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupInfo.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.util.Objects;\n+\n+public class CgroupMetrics implements Metrics {\n+\n+    private final CgroupSubsystem subsystem;\n+\n+    CgroupMetrics(CgroupSubsystem subsystem) {\n+        this.subsystem = Objects.requireNonNull(subsystem);\n+    }\n+\n+    @Override\n+    public String getProvider() {\n+        return subsystem.getProvider();\n+    }\n+\n+    @Override\n+    public long getCpuUsage() {\n+        return subsystem.getCpuUsage();\n+    }\n+\n+    @Override\n+    public long[] getPerCpuUsage() {\n+        return subsystem.getPerCpuUsage();\n+    }\n+\n+    @Override\n+    public long getCpuUserUsage() {\n+        return subsystem.getCpuUserUsage();\n+    }\n+\n+    @Override\n+    public long getCpuSystemUsage() {\n+        return subsystem.getCpuSystemUsage();\n+    }\n+\n+    @Override\n+    public long getCpuPeriod() {\n+        return subsystem.getCpuPeriod();\n+    }\n+\n+    @Override\n+    public long getCpuQuota() {\n+        return subsystem.getCpuQuota();\n+    }\n+\n+    @Override\n+    public long getCpuShares() {\n+        return subsystem.getCpuShares();\n+    }\n+\n+    @Override\n+    public long getCpuNumPeriods() {\n+        return subsystem.getCpuNumPeriods();\n+    }\n+\n+    @Override\n+    public long getCpuNumThrottled() {\n+        return subsystem.getCpuNumThrottled();\n+    }\n+\n+    @Override\n+    public long getCpuThrottledTime() {\n+        return subsystem.getCpuThrottledTime();\n+    }\n+\n+    @Override\n+    public long getEffectiveCpuCount() {\n+        return subsystem.getEffectiveCpuCount();\n+    }\n+\n+    @Override\n+    public int[] getCpuSetCpus() {\n+        return subsystem.getCpuSetCpus();\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetCpus() {\n+        return subsystem.getEffectiveCpuSetCpus();\n+    }\n+\n+    @Override\n+    public int[] getCpuSetMems() {\n+        return subsystem.getCpuSetMems();\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetMems() {\n+        return subsystem.getEffectiveCpuSetMems();\n+    }\n+\n+    public long getMemoryFailCount() {\n+        return subsystem.getMemoryFailCount();\n+    }\n+\n+    @Override\n+    public long getMemoryLimit() {\n+        return subsystem.getMemoryLimit();\n+    }\n+\n+    @Override\n+    public long getMemoryUsage() {\n+        return subsystem.getMemoryUsage();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryUsage() {\n+        return subsystem.getTcpMemoryUsage();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapLimit() {\n+        return subsystem.getMemoryAndSwapLimit();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapUsage() {\n+        return subsystem.getMemoryAndSwapUsage();\n+    }\n+\n+    @Override\n+    public long getMemorySoftLimit() {\n+        return subsystem.getMemorySoftLimit();\n+    }\n+\n+    @Override\n+    public long getBlkIOServiceCount() {\n+        return subsystem.getBlkIOServiceCount();\n+    }\n+\n+    @Override\n+    public long getBlkIOServiced() {\n+        return subsystem.getBlkIOServiced();\n+    }\n+\n+    public static Metrics getInstance() {\n+        if (!isUseContainerSupport()) {\n+            \/\/ Return null on -XX:-UseContainerSupport\n+            return null;\n+        }\n+        return CgroupSubsystemFactory.create();\n+    }\n+\n+    private static native boolean isUseContainerSupport();\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupMetrics.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ * Marker interface for cgroup-based metrics\n+ *\n+ *\/\n+public interface CgroupSubsystem extends Metrics {\n+\n+    \/**\n+     * Returned for metrics of type long if the underlying implementation\n+     * has determined that no limit is being imposed.\n+     *\/\n+    public static final long LONG_RETVAL_UNLIMITED = -1;\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystem.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,255 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.math.BigInteger;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Cgroup version agnostic controller logic\n+ *\n+ *\/\n+public interface CgroupSubsystemController {\n+\n+    public static final String EMPTY_STR = \"\";\n+\n+    public String path();\n+\n+    \/**\n+     * getStringValue\n+     *\n+     * Return the first line of the file \"param\" argument from the controller.\n+     *\n+     * TODO:  Consider using weak references for caching BufferedReader object.\n+     *\n+     * @param controller\n+     * @param param\n+     * @return Returns the contents of the file specified by param or null if\n+     *         an error occurs.\n+     *\/\n+    public static String getStringValue(CgroupSubsystemController controller, String param) {\n+        if (controller == null) return null;\n+\n+        try {\n+            return CgroupUtil.readStringValue(controller, param);\n+        }\n+        catch (IOException e) {\n+            return null;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Get an entry from file \"param\" within the \"controller\" directory path\n+     * which matches string \"match\". Applies \"conversion\" to the matching line.\n+     *\n+     * @param controller\n+     * @param param\n+     * @param match\n+     * @param conversion\n+     * @param defaultRetval\n+     * @return The long value as derived by applying \"conversion\" to the matching\n+     *         line or \"defaultRetval\" if there was an error or no match found.\n+     *\/\n+    public static long getLongValueMatchingLine(CgroupSubsystemController controller,\n+                                                     String param,\n+                                                     String match,\n+                                                     Function<String, Long> conversion,\n+                                                     long defaultRetval) {\n+        long retval = defaultRetval;\n+        if (controller == null) {\n+            return retval;\n+        }\n+        try {\n+            Path filePath = Paths.get(controller.path(), param);\n+            List<String> lines = CgroupUtil.readAllLinesPrivileged(filePath);\n+            for (String line : lines) {\n+                if (line.startsWith(match)) {\n+                    retval = conversion.apply(line);\n+                    break;\n+                }\n+            }\n+        } catch (IOException e) {\n+            \/\/ Ignore. Default is unlimited.\n+        }\n+        return retval;\n+    }\n+\n+    \/**\n+     * Get a long value from directory \"controller\" and file \"param\", by\n+     * applying \"conversion\" to the string value within the file.\n+     *\n+     * @param controller\n+     * @param param\n+     * @param conversion\n+     * @param defaultRetval\n+     * @return The converted long value or \"defaultRetval\" if there was an\n+     *         error.\n+     *\/\n+    public static long getLongValue(CgroupSubsystemController controller,\n+                                    String param,\n+                                    Function<String, Long> conversion,\n+                                    long defaultRetval) {\n+        String strval = getStringValue(controller, param);\n+        if (strval == null) return defaultRetval;\n+        return conversion.apply(strval);\n+    }\n+\n+    \/**\n+     * Get a double value from file \"param\" within \"controller\".\n+     *\n+     * @param controller\n+     * @param param\n+     * @param defaultRetval\n+     * @return The double value or \"defaultRetval\" if there was an error.\n+     *\/\n+    public static double getDoubleValue(CgroupSubsystemController controller, String param, double defaultRetval) {\n+        String strval = getStringValue(controller, param);\n+\n+        if (strval == null) return defaultRetval;\n+\n+        double retval = Double.parseDouble(strval);\n+\n+        return retval;\n+    }\n+\n+    \/**\n+     * getLongEntry\n+     *\n+     * Return the long value from the line containing the string \"entryname\"\n+     * within file \"param\" in the \"controller\".\n+     *\n+     * TODO:  Consider using weak references for caching BufferedReader object.\n+     *\n+     * @param controller\n+     * @param param\n+     * @param entryname\n+     * @return long value or \"defaultRetval\" if there was an error or no match\n+     *         was found.\n+     *\/\n+    public static long getLongEntry(CgroupSubsystemController controller, String param, String entryname, long defaultRetval) {\n+        if (controller == null) return defaultRetval;\n+\n+        try (Stream<String> lines = CgroupUtil.readFilePrivileged(Paths.get(controller.path(), param))) {\n+\n+            Optional<String> result = lines.map(line -> line.split(\" \"))\n+                                           .filter(line -> (line.length == 2 &&\n+                                                   line[0].equals(entryname)))\n+                                           .map(line -> line[1])\n+                                           .findFirst();\n+\n+            return result.isPresent() ? Long.parseLong(result.get()) : defaultRetval;\n+        } catch (UncheckedIOException e) {\n+            return defaultRetval;\n+        } catch (IOException e) {\n+            return defaultRetval;\n+        }\n+    }\n+\n+    \/**\n+     * stringRangeToIntArray\n+     *\n+     * Convert a string in the form of  1,3-4,6 to an array of\n+     * integers containing all the numbers in the range.\n+     *\n+     * @param range\n+     * @return int[] containing a sorted list of numbers as represented by\n+     *         the string range. Returns null if there was an error or the input\n+     *         was an empty string.\n+     *\/\n+    public static int[] stringRangeToIntArray(String range) {\n+        if (range == null || EMPTY_STR.equals(range)) return null;\n+\n+        ArrayList<Integer> results = new ArrayList<>();\n+        String strs[] = range.split(\",\");\n+        for (String str : strs) {\n+            if (str.contains(\"-\")) {\n+                String lohi[] = str.split(\"-\");\n+                \/\/ validate format\n+                if (lohi.length != 2) {\n+                    continue;\n+                }\n+                int lo = Integer.parseInt(lohi[0]);\n+                int hi = Integer.parseInt(lohi[1]);\n+                for (int i = lo; i <= hi; i++) {\n+                    results.add(i);\n+                }\n+            }\n+            else {\n+                results.add(Integer.parseInt(str));\n+            }\n+        }\n+\n+        \/\/ sort results\n+        results.sort(null);\n+\n+        \/\/ convert ArrayList to primitive int array\n+        int[] ints = new int[results.size()];\n+        int i = 0;\n+        for (Integer n : results) {\n+            ints[i++] = n;\n+        }\n+\n+        return ints;\n+    }\n+\n+    \/**\n+     * Convert a number from its string representation to a long.\n+     *\n+     * @param strval\n+     * @param overflowRetval\n+     * @param defaultRetval\n+     * @return The converted long value. \"overflowRetval\" is returned if the\n+     *         string representation exceeds the range of type long.\n+     *         \"defaultRetval\" is returned if another type of error occurred\n+     *         during conversion.\n+     *\/\n+    public static long convertStringToLong(String strval, long overflowRetval, long defaultRetval) {\n+        long retval = defaultRetval;\n+        if (strval == null) return retval;\n+\n+        try {\n+            retval = Long.parseLong(strval);\n+        } catch (NumberFormatException e) {\n+            \/\/ For some properties (e.g. memory.limit_in_bytes, cgroups v1) we may overflow\n+            \/\/ the range of signed long. In this case, return overflowRetval\n+            BigInteger b = new BigInteger(strval);\n+            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n+                return overflowRetval;\n+            }\n+        }\n+        return retval;\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemController.java","additions":255,"deletions":0,"binary":false,"changes":255,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.io.IOException;\n+import java.lang.System.Logger;\n+import java.lang.System.Logger.Level;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.internal.platform.cgroupv1.CgroupV1Subsystem;\n+import jdk.internal.platform.cgroupv2.CgroupV2Subsystem;\n+\n+class CgroupSubsystemFactory {\n+\n+    private static final String CPU_CTRL = \"cpu\";\n+    private static final String CPUACCT_CTRL = \"cpuacct\";\n+    private static final String CPUSET_CTRL = \"cpuset\";\n+    private static final String BLKIO_CTRL = \"blkio\";\n+    private static final String MEMORY_CTRL = \"memory\";\n+\n+    static CgroupMetrics create() {\n+        Map<String, CgroupInfo> infos = new HashMap<>();\n+        try {\n+            List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(\"\/proc\/cgroups\"));\n+            for (String line : lines) {\n+                if (line.startsWith(\"#\")) {\n+                    continue;\n+                }\n+                CgroupInfo info = CgroupInfo.fromCgroupsLine(line);\n+                switch (info.getName()) {\n+                case CPU_CTRL:      infos.put(CPU_CTRL, info); break;\n+                case CPUACCT_CTRL:  infos.put(CPUACCT_CTRL, info); break;\n+                case CPUSET_CTRL:   infos.put(CPUSET_CTRL, info); break;\n+                case MEMORY_CTRL:   infos.put(MEMORY_CTRL, info); break;\n+                case BLKIO_CTRL:    infos.put(BLKIO_CTRL, info); break;\n+                }\n+            }\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+        \/\/ For cgroups v1 all controllers need to have non-zero hierarchy id\n+        boolean isCgroupsV2 = true;\n+        boolean anyControllersEnabled = false;\n+        boolean anyCgroupsV2Controller = false;\n+        boolean anyCgroupsV1Controller = false;\n+        for (CgroupInfo info: infos.values()) {\n+            anyCgroupsV1Controller = anyCgroupsV1Controller || info.getHierarchyId() != 0;\n+            anyCgroupsV2Controller = anyCgroupsV2Controller || info.getHierarchyId() == 0;\n+            isCgroupsV2 = isCgroupsV2 && info.getHierarchyId() == 0;\n+            anyControllersEnabled = anyControllersEnabled || info.isEnabled();\n+        }\n+\n+        \/\/ If no controller is enabled, return no metrics.\n+        if (!anyControllersEnabled) {\n+            return null;\n+        }\n+        \/\/ Warn about mixed cgroups v1 and cgroups v2 controllers. The code is\n+        \/\/ not ready to deal with that on a per-controller basis. Return no metrics\n+        \/\/ in that case\n+        if (anyCgroupsV1Controller && anyCgroupsV2Controller) {\n+            Logger logger = System.getLogger(\"jdk.internal.platform\");\n+            logger.log(Level.DEBUG, \"Mixed cgroupv1 and cgroupv2 not supported. Metrics disabled.\");\n+            return null;\n+        }\n+\n+        if (isCgroupsV2) {\n+            CgroupSubsystem subsystem = CgroupV2Subsystem.getInstance();\n+            return subsystem != null ? new CgroupMetrics(subsystem) : null;\n+        } else {\n+            CgroupV1Subsystem subsystem = CgroupV1Subsystem.getInstance();\n+            return subsystem != null ? new CgroupV1MetricsImpl(subsystem) : null;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public final class CgroupUtil {\n+\n+    public static Stream<String> readFilePrivileged(Path path) throws IOException {\n+        try {\n+            PrivilegedExceptionAction<Stream<String>> pea = () -> Files.lines(path);\n+            return AccessController.doPrivileged(pea);\n+        } catch (PrivilegedActionException e) {\n+            unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n+        }\n+    }\n+\n+    static void unwrapIOExceptionAndRethrow(PrivilegedActionException pae) throws IOException {\n+        Throwable x = pae.getCause();\n+        if (x instanceof IOException)\n+            throw (IOException) x;\n+        if (x instanceof RuntimeException)\n+            throw (RuntimeException) x;\n+        if (x instanceof Error)\n+            throw (Error) x;\n+    }\n+\n+    static String readStringValue(CgroupSubsystemController controller, String param) throws IOException {\n+        PrivilegedExceptionAction<BufferedReader> pea = () ->\n+                Files.newBufferedReader(Paths.get(controller.path(), param));\n+        try (BufferedReader bufferedReader =\n+                     AccessController.doPrivileged(pea)) {\n+            String line = bufferedReader.readLine();\n+            return line;\n+        } catch (PrivilegedActionException e) {\n+            unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n+        }\n+    }\n+\n+    public static List<String> readAllLinesPrivileged(Path path) throws IOException {\n+        try {\n+            PrivilegedExceptionAction<List<String>> pea = () -> Files.readAllLines(path);\n+            return AccessController.doPrivileged(pea);\n+        } catch (PrivilegedActionException e) {\n+            unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n+        }\n+    }\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupUtil.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ *\n+ * Cgroup v1 extensions to the Metrics interface. Linux, only.\n+ *\n+ *\/\n+public interface CgroupV1Metrics extends Metrics {\n+\n+    \/**\n+     * Returns the largest amount of physical memory, in bytes, that\n+     * have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available. Returns -2 if this metric is not\n+     *         supported.\n+     *\n+     *\/\n+    public long getMemoryMaxUsage();\n+\n+    \/**\n+     * Returns the number of times that kernel memory requests in the\n+     * Isolation Group have exceeded the kernel memory limit.\n+     *\n+     * @return The number of exceeded requests or -1 if metric\n+     *         is not available.\n+     *\n+     *\/\n+    public long getKernelMemoryFailCount();\n+\n+    \/**\n+     * Returns the maximum amount of kernel physical memory, in bytes, that\n+     * can be allocated in the Isolation Group.\n+     *\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit set.\n+     *\n+     *\/\n+    public long getKernelMemoryLimit();\n+\n+    \/**\n+     * Returns the largest amount of kernel physical memory, in bytes, that\n+     * have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getKernelMemoryMaxUsage();\n+\n+    \/**\n+     * Returns the amount of kernel physical memory, in bytes, that\n+     * is currently allocated in the current Isolation Group.\n+     *\n+     * @return The amount of memory in bytes allocated or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getKernelMemoryUsage();\n+\n+    \/**\n+     * Returns the number of times that networking memory requests in the\n+     * Isolation Group have exceeded the kernel memory limit.\n+     *\n+     * @return The number of exceeded requests or -1 if the metric\n+     *         is not available.\n+     *\n+     *\/\n+    public long getTcpMemoryFailCount();\n+\n+    \/**\n+     * Returns the maximum amount of networking physical memory, in bytes,\n+     * that can be allocated in the Isolation Group.\n+     *\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit.\n+     *\n+     *\/\n+    public long getTcpMemoryLimit();\n+\n+    \/**\n+     * Returns the largest amount of networking physical memory, in bytes,\n+     * that have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getTcpMemoryMaxUsage();\n+\n+    \/**\n+     * Returns the number of times that user memory requests in the\n+     * Isolation Group have exceeded the memory + swap limit.\n+     *\n+     * @return The number of exceeded requests or -1 if the metric\n+     *         is not available.\n+     *\n+     *\/\n+    public long getMemoryAndSwapFailCount();\n+\n+    \/**\n+     * Returns the largest amount of physical memory and swap space,\n+     * in bytes, that have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getMemoryAndSwapMaxUsage();\n+\n+    \/**\n+     * Returns the state of the Operating System Out of Memory termination\n+     * policy.\n+     *\n+     * @return Returns true if operating system will terminate processes\n+     *         in the Isolation Group that exceed the amount of available\n+     *         memory, otherwise false. null will be returned if this\n+     *         capability is not available on the current operating system.\n+     *\n+     *\/\n+    public Boolean isMemoryOOMKillEnabled();\n+\n+    \/**\n+     * Returns the (attempts per second * 1000), if enabled, that the\n+     * operating system tries to satisfy a memory request for any\n+     * process in the current Isolation Group when no free memory is\n+     * readily available.  Use {@link #isCpuSetMemoryPressureEnabled()} to\n+     * determine if this support is enabled.\n+     *\n+     * @return Memory pressure or 0 if not enabled or -1 if metric is not\n+     *         available.\n+     *\n+     *\/\n+    public double getCpuSetMemoryPressure();\n+\n+    \/**\n+     * Returns the state of the memory pressure detection support.\n+     *\n+     * @return true if support is available and enabled. false otherwise.\n+     *\n+     *\/\n+    public Boolean isCpuSetMemoryPressureEnabled();\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupV1Metrics.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ * Cgroup v1 Metrics extensions\n+ *\n+ *\/\n+public class CgroupV1MetricsImpl extends CgroupMetrics implements CgroupV1Metrics {\n+\n+    private final CgroupV1Metrics metrics;\n+\n+    CgroupV1MetricsImpl(CgroupV1Metrics metrics) {\n+        super((CgroupSubsystem)metrics);\n+        this.metrics = metrics;\n+    }\n+\n+    @Override\n+    public long getMemoryMaxUsage() {\n+        return metrics.getMemoryMaxUsage();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryFailCount() {\n+        return metrics.getKernelMemoryFailCount();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryLimit() {\n+        return metrics.getKernelMemoryLimit();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryMaxUsage() {\n+        return metrics.getKernelMemoryMaxUsage();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryUsage() {\n+        return metrics.getKernelMemoryUsage();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryFailCount() {\n+        return metrics.getTcpMemoryFailCount();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryLimit() {\n+        return metrics.getTcpMemoryLimit();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryMaxUsage() {\n+        return metrics.getTcpMemoryMaxUsage();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapFailCount() {\n+        return metrics.getMemoryAndSwapFailCount();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapMaxUsage() {\n+        return metrics.getMemoryAndSwapMaxUsage();\n+    }\n+\n+    @Override\n+    public Boolean isMemoryOOMKillEnabled() {\n+        return metrics.isMemoryOOMKillEnabled();\n+    }\n+\n+    @Override\n+    public double getCpuSetMemoryPressure() {\n+        return metrics.getCpuSetMemoryPressure();\n+    }\n+\n+    @Override\n+    public Boolean isCpuSetMemoryPressureEnabled() {\n+        return metrics.isCpuSetMemoryPressureEnabled();\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupV1MetricsImpl.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv1;\n+\n+public class CgroupV1MemorySubSystemController extends CgroupV1SubsystemController {\n+\n+    private boolean hierarchical;\n+    private boolean swapenabled;\n+\n+    public CgroupV1MemorySubSystemController(String root, String mountPoint) {\n+        super(root, mountPoint);\n+    }\n+\n+    boolean isHierarchical() {\n+        return hierarchical;\n+    }\n+\n+    void setHierarchical(boolean hierarchical) {\n+        this.hierarchical = hierarchical;\n+    }\n+\n+    boolean isSwapEnabled() {\n+        return swapenabled;\n+    }\n+\n+    void setSwapEnabled(boolean swapenabled) {\n+        this.swapenabled = swapenabled;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1MemorySubSystemController.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,508 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv1;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+import jdk.internal.platform.CgroupUtil;\n+import jdk.internal.platform.CgroupV1Metrics;\n+\n+public class CgroupV1Subsystem implements CgroupSubsystem, CgroupV1Metrics {\n+    private CgroupV1MemorySubSystemController memory;\n+    private CgroupV1SubsystemController cpu;\n+    private CgroupV1SubsystemController cpuacct;\n+    private CgroupV1SubsystemController cpuset;\n+    private CgroupV1SubsystemController blkio;\n+    private boolean activeSubSystems;\n+\n+    private static final CgroupV1Subsystem INSTANCE = initSubSystem();\n+\n+    private static final String PROVIDER_NAME = \"cgroupv1\";\n+\n+    private CgroupV1Subsystem() {\n+        activeSubSystems = false;\n+    }\n+\n+    public static CgroupV1Subsystem getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    private static CgroupV1Subsystem initSubSystem() {\n+        CgroupV1Subsystem subsystem = new CgroupV1Subsystem();\n+\n+        \/**\n+         * Find the cgroup mount points for subsystems\n+         * by reading \/proc\/self\/mountinfo\n+         *\n+         * Example for docker MemorySubSystem subsystem:\n+         * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/MemorySubSystem ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,MemorySubSystem\n+         *\n+         * Example for host:\n+         * 34 28 0:29 \/ \/sys\/fs\/cgroup\/MemorySubSystem rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,MemorySubSystem\n+         *\/\n+        try (Stream<String> lines =\n+                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n+\n+            lines.filter(line -> line.contains(\" - cgroup \"))\n+                 .map(line -> line.split(\" \"))\n+                 .forEach(entry -> createSubSystemController(subsystem, entry));\n+\n+        } catch (UncheckedIOException e) {\n+            return null;\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+        \/**\n+         * Read \/proc\/self\/cgroup and map host mount point to\n+         * local one via \/proc\/self\/mountinfo content above\n+         *\n+         * Docker example:\n+         * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n+         *\n+         * Host example:\n+         * 5:memory:\/user.slice\n+         *\n+         * Construct a path to the process specific memory and cpuset\n+         * cgroup directory.\n+         *\n+         * For a container running under Docker from memory example above\n+         * the paths would be:\n+         *\n+         * \/sys\/fs\/cgroup\/memory\n+         *\n+         * For a Host from memory example above the path would be:\n+         *\n+         * \/sys\/fs\/cgroup\/memory\/user.slice\n+         *\n+         *\/\n+        try (Stream<String> lines =\n+                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/cgroup\"))) {\n+\n+            lines.map(line -> line.split(\":\"))\n+                 .filter(line -> (line.length >= 3))\n+                 .forEach(line -> setSubSystemControllerPath(subsystem, line));\n+\n+        } catch (UncheckedIOException e) {\n+            return null;\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+        \/\/ Return Metrics object if we found any subsystems.\n+        if (subsystem.activeSubSystems()) {\n+            return subsystem;\n+        }\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * createSubSystem objects and initialize mount points\n+     *\/\n+    private static void createSubSystemController(CgroupV1Subsystem subsystem, String[] mountentry) {\n+        if (mountentry.length < 5) return;\n+\n+        Path p = Paths.get(mountentry[4]);\n+        String[] subsystemNames = p.getFileName().toString().split(\",\");\n+\n+        for (String subsystemName: subsystemNames) {\n+            switch (subsystemName) {\n+                case \"memory\":\n+                    subsystem.setMemorySubSystem(new CgroupV1MemorySubSystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"cpuset\":\n+                    subsystem.setCpuSetController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"cpuacct\":\n+                    subsystem.setCpuAcctController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"cpu\":\n+                    subsystem.setCpuController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"blkio\":\n+                    subsystem.setBlkIOController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                default:\n+                    \/\/ Ignore subsystems that we don't support\n+                    break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * setSubSystemPath based on the contents of \/proc\/self\/cgroup\n+     *\/\n+    private static void setSubSystemControllerPath(CgroupV1Subsystem subsystem, String[] entry) {\n+        String controller = entry[1];\n+        String base = entry[2];\n+        if (controller != null && base != null) {\n+            for (String cName: controller.split(\",\")) {\n+                switch (cName) {\n+                    case \"memory\":\n+                        setPath(subsystem, subsystem.memoryController(), base);\n+                        break;\n+                    case \"cpuset\":\n+                        setPath(subsystem, subsystem.cpuSetController(), base);\n+                        break;\n+                    case \"cpuacct\":\n+                        setPath(subsystem, subsystem.cpuController(), base);\n+                        break;\n+                    case \"cpu\":\n+                        setPath(subsystem, subsystem.cpuAcctController(), base);\n+                        break;\n+                    case \"blkio\":\n+                        setPath(subsystem, subsystem.blkIOController(), base);\n+                        break;\n+                    \/\/ Ignore subsystems that we don't support\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void setPath(CgroupV1Subsystem subsystem, CgroupV1SubsystemController controller, String base) {\n+        if (controller != null) {\n+            controller.setPath(base);\n+            if (controller instanceof CgroupV1MemorySubSystemController) {\n+                CgroupV1MemorySubSystemController memorySubSystem = (CgroupV1MemorySubSystemController)controller;\n+                boolean isHierarchial = getHierarchical(memorySubSystem);\n+                memorySubSystem.setHierarchical(isHierarchial);\n+                boolean isSwapEnabled = getSwapEnabled(memorySubSystem);\n+                memorySubSystem.setSwapEnabled(isSwapEnabled);\n+            }\n+            subsystem.setActiveSubSystems();\n+        }\n+    }\n+\n+\n+    private static boolean getSwapEnabled(CgroupV1MemorySubSystemController controller) {\n+         long retval = getLongValue(controller, \"memory.memsw.limit_in_bytes\");\n+         return retval > 0;\n+     }\n+\n+\n+    private static boolean getHierarchical(CgroupV1MemorySubSystemController controller) {\n+        long hierarchical = getLongValue(controller, \"memory.use_hierarchy\");\n+        return hierarchical > 0;\n+    }\n+\n+    private void setActiveSubSystems() {\n+        activeSubSystems = true;\n+    }\n+\n+    private boolean activeSubSystems() {\n+        return activeSubSystems;\n+    }\n+\n+    private void setMemorySubSystem(CgroupV1MemorySubSystemController memory) {\n+        this.memory = memory;\n+    }\n+\n+    private void setCpuController(CgroupV1SubsystemController cpu) {\n+        this.cpu = cpu;\n+    }\n+\n+    private void setCpuAcctController(CgroupV1SubsystemController cpuacct) {\n+        this.cpuacct = cpuacct;\n+    }\n+\n+    private void setCpuSetController(CgroupV1SubsystemController cpuset) {\n+        this.cpuset = cpuset;\n+    }\n+\n+    private void setBlkIOController(CgroupV1SubsystemController blkio) {\n+        this.blkio = blkio;\n+    }\n+\n+    private CgroupV1SubsystemController memoryController() {\n+        return memory;\n+    }\n+\n+    private CgroupV1SubsystemController cpuController() {\n+        return cpu;\n+    }\n+\n+    private CgroupV1SubsystemController cpuAcctController() {\n+        return cpuacct;\n+    }\n+\n+    private CgroupV1SubsystemController cpuSetController() {\n+        return cpuset;\n+    }\n+\n+    private CgroupV1SubsystemController blkIOController() {\n+        return blkio;\n+    }\n+\n+    private static long getLongValue(CgroupSubsystemController controller,\n+                              String parm) {\n+        return CgroupSubsystemController.getLongValue(controller,\n+                                                      parm,\n+                                                      CgroupV1SubsystemController::convertStringToLong,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+    }\n+\n+    public String getProvider() {\n+        return PROVIDER_NAME;\n+    }\n+\n+    \/*****************************************************************\n+     * CPU Accounting Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getCpuUsage() {\n+        return getLongValue(cpuacct, \"cpuacct.usage\");\n+    }\n+\n+    public long[] getPerCpuUsage() {\n+        String usagelist = CgroupSubsystemController.getStringValue(cpuacct, \"cpuacct.usage_percpu\");\n+        if (usagelist == null) {\n+            return null;\n+        }\n+\n+        String list[] = usagelist.split(\" \");\n+        long percpu[] = new long[list.length];\n+        for (int i = 0; i < list.length; i++) {\n+            percpu[i] = Long.parseLong(list[i]);\n+        }\n+        return percpu;\n+    }\n+\n+    public long getCpuUserUsage() {\n+        return CgroupV1SubsystemController.getLongEntry(cpuacct, \"cpuacct.stat\", \"user\");\n+    }\n+\n+    public long getCpuSystemUsage() {\n+        return CgroupV1SubsystemController.getLongEntry(cpuacct, \"cpuacct.stat\", \"system\");\n+    }\n+\n+\n+    \/*****************************************************************\n+     * CPU Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getCpuPeriod() {\n+        return getLongValue(cpu, \"cpu.cfs_period_us\");\n+    }\n+\n+    public long getCpuQuota() {\n+        return getLongValue(cpu, \"cpu.cfs_quota_us\");\n+    }\n+\n+    public long getCpuShares() {\n+        long retval = getLongValue(cpu, \"cpu.shares\");\n+        if (retval == 0 || retval == 1024)\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        else\n+            return retval;\n+    }\n+\n+    public long getCpuNumPeriods() {\n+        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"nr_periods\");\n+    }\n+\n+    public long getCpuNumThrottled() {\n+        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"nr_throttled\");\n+    }\n+\n+    public long getCpuThrottledTime() {\n+        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"throttled_time\");\n+    }\n+\n+    public long getEffectiveCpuCount() {\n+        return Runtime.getRuntime().availableProcessors();\n+    }\n+\n+\n+    \/*****************************************************************\n+     * CPUSet Subsystem\n+     ****************************************************************\/\n+\n+    public int[] getCpuSetCpus() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.cpus\"));\n+    }\n+\n+    public int[] getEffectiveCpuSetCpus() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.effective_cpus\"));\n+    }\n+\n+    public int[] getCpuSetMems() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.mems\"));\n+    }\n+\n+    public int[] getEffectiveCpuSetMems() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.effective_mems\"));\n+    }\n+\n+    public double getCpuSetMemoryPressure() {\n+        return CgroupV1SubsystemController.getDoubleValue(cpuset, \"cpuset.memory_pressure\");\n+    }\n+\n+    public Boolean isCpuSetMemoryPressureEnabled() {\n+        long val = getLongValue(cpuset, \"cpuset.memory_pressure_enabled\");\n+        return (val == 1);\n+    }\n+\n+\n+    \/*****************************************************************\n+     * Memory Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getMemoryFailCount() {\n+        return getLongValue(memory, \"memory.failcnt\");\n+    }\n+\n+    public long getMemoryLimit() {\n+        long retval = getLongValue(memory, \"memory.limit_in_bytes\");\n+        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n+            if (memory.isHierarchical()) {\n+                \/\/ memory.limit_in_bytes returned unlimited, attempt\n+                \/\/ hierarchical memory limit\n+                String match = \"hierarchical_memory_limit\";\n+                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n+                                                            \"memory.stat\",\n+                                                            match);\n+            }\n+        }\n+        return CgroupV1SubsystemController.longValOrUnlimited(retval);\n+    }\n+\n+    public long getMemoryMaxUsage() {\n+        return getLongValue(memory, \"memory.max_usage_in_bytes\");\n+    }\n+\n+    public long getMemoryUsage() {\n+        return getLongValue(memory, \"memory.usage_in_bytes\");\n+    }\n+\n+    public long getKernelMemoryFailCount() {\n+        return getLongValue(memory, \"memory.kmem.failcnt\");\n+    }\n+\n+    public long getKernelMemoryLimit() {\n+        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(memory, \"memory.kmem.limit_in_bytes\"));\n+    }\n+\n+    public long getKernelMemoryMaxUsage() {\n+        return getLongValue(memory, \"memory.kmem.max_usage_in_bytes\");\n+    }\n+\n+    public long getKernelMemoryUsage() {\n+        return getLongValue(memory, \"memory.kmem.usage_in_bytes\");\n+    }\n+\n+    public long getTcpMemoryFailCount() {\n+        return getLongValue(memory, \"memory.kmem.tcp.failcnt\");\n+    }\n+\n+    public long getTcpMemoryLimit() {\n+        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(memory, \"memory.kmem.tcp.limit_in_bytes\"));\n+    }\n+\n+    public long getTcpMemoryMaxUsage() {\n+        return getLongValue(memory, \"memory.kmem.tcp.max_usage_in_bytes\");\n+    }\n+\n+    public long getTcpMemoryUsage() {\n+        return getLongValue(memory, \"memory.kmem.tcp.usage_in_bytes\");\n+    }\n+\n+    public long getMemoryAndSwapFailCount() {\n+        if (memory != null && !memory.isSwapEnabled()) {\n+            return getMemoryFailCount();\n+        }\n+        return getLongValue(memory, \"memory.memsw.failcnt\");\n+    }\n+\n+    public long getMemoryAndSwapLimit() {\n+        if (memory != null && !memory.isSwapEnabled()) {\n+            return getMemoryLimit();\n+        }\n+        long retval = getLongValue(memory, \"memory.memsw.limit_in_bytes\");\n+        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n+            if (memory.isHierarchical()) {\n+                \/\/ memory.memsw.limit_in_bytes returned unlimited, attempt\n+                \/\/ hierarchical memory limit\n+                String match = \"hierarchical_memsw_limit\";\n+                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n+                                                            \"memory.stat\",\n+                                                            match);\n+            }\n+        }\n+        return CgroupV1SubsystemController.longValOrUnlimited(retval);\n+    }\n+\n+    public long getMemoryAndSwapMaxUsage() {\n+        if (memory != null && !memory.isSwapEnabled()) {\n+            return getMemoryMaxUsage();\n+        }\n+        return getLongValue(memory, \"memory.memsw.max_usage_in_bytes\");\n+    }\n+\n+    public long getMemoryAndSwapUsage() {\n+        if (memory != null && !memory.isSwapEnabled()) {\n+            return getMemoryUsage();\n+        }\n+        return getLongValue(memory, \"memory.memsw.usage_in_bytes\");\n+    }\n+\n+    public Boolean isMemoryOOMKillEnabled() {\n+        long val = CgroupV1SubsystemController.getLongEntry(memory, \"memory.oom_control\", \"oom_kill_disable\");\n+        return (val == 0);\n+    }\n+\n+    public long getMemorySoftLimit() {\n+        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(memory, \"memory.soft_limit_in_bytes\"));\n+    }\n+\n+\n+    \/*****************************************************************\n+     * BlKIO Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getBlkIOServiceCount() {\n+        return CgroupV1SubsystemController.getLongEntry(blkio, \"blkio.throttle.io_service_bytes\", \"Total\");\n+    }\n+\n+    public long getBlkIOServiced() {\n+        return CgroupV1SubsystemController.getLongEntry(blkio, \"blkio.throttle.io_serviced\", \"Total\");\n+    }\n+\n+    private static native boolean isUseContainerSupport();\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":508,"deletions":0,"binary":false,"changes":508,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv1;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+\n+public class CgroupV1SubsystemController implements CgroupSubsystemController {\n+\n+    private static final double DOUBLE_RETVAL_UNLIMITED = CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+    \/\/ Values returned larger than this number are unlimited.\n+    static long UNLIMITED_MIN = 0x7FFFFFFFFF000000L;\n+    String root;\n+    String mountPoint;\n+    String path;\n+\n+    public CgroupV1SubsystemController(String root, String mountPoint) {\n+        this.root = root;\n+        this.mountPoint = mountPoint;\n+    }\n+\n+    public void setPath(String cgroupPath) {\n+        if (root != null && cgroupPath != null) {\n+            if (root.equals(\"\/\")) {\n+                if (!cgroupPath.equals(\"\/\")) {\n+                    path = mountPoint + cgroupPath;\n+                }\n+                else {\n+                    path = mountPoint;\n+                }\n+            }\n+            else {\n+                if (root.equals(cgroupPath)) {\n+                    path = mountPoint;\n+                }\n+                else {\n+                    if (cgroupPath.startsWith(root)) {\n+                        if (cgroupPath.length() > root.length()) {\n+                            String cgroupSubstr = cgroupPath.substring(root.length());\n+                            path = mountPoint + cgroupSubstr;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String path() {\n+        return path;\n+    }\n+\n+    public static long getLongEntry(CgroupSubsystemController controller, String param, String entryname) {\n+        return CgroupSubsystemController.getLongEntry(controller,\n+                                                      param,\n+                                                      entryname,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+\n+    public static double getDoubleValue(CgroupSubsystemController controller, String parm) {\n+        return CgroupSubsystemController.getDoubleValue(controller,\n+                                                        parm,\n+                                                        DOUBLE_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+\n+    public static long convertStringToLong(String strval) {\n+        return CgroupSubsystemController.convertStringToLong(strval,\n+                                                             Long.MAX_VALUE \/* overflow value *\/,\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+\n+    public static long longValOrUnlimited(long value) {\n+        return value > UNLIMITED_MIN ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : value;\n+    }\n+\n+    public static long getLongValueMatchingLine(CgroupSubsystemController controller,\n+                                                String param,\n+                                                String match) {\n+        return CgroupSubsystemController.getLongValueMatchingLine(controller,\n+                                                                  param,\n+                                                                  match,\n+                                                                  CgroupV1SubsystemController::convertHierachicalLimitLine,\n+                                                                  CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+    }\n+\n+    public static long convertHierachicalLimitLine(String line) {\n+        String[] tokens = line.split(\"\\\\s\");\n+        if (tokens.length == 2) {\n+            String strVal = tokens[1];\n+            return CgroupV1SubsystemController.convertStringToLong(strVal);\n+        }\n+        return CgroupV1SubsystemController.UNLIMITED_MIN + 1; \/\/ unlimited\n+    }\n+\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1SubsystemController.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -1,545 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.platform.cgroupv1;\n-\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.stream.Stream;\n-\n-import jdk.internal.platform.cgroupv1.SubSystem.MemorySubSystem;\n-\n-public class Metrics implements jdk.internal.platform.Metrics {\n-    private MemorySubSystem memory;\n-    private SubSystem cpu;\n-    private SubSystem cpuacct;\n-    private SubSystem cpuset;\n-    private SubSystem blkio;\n-    private boolean activeSubSystems;\n-\n-    \/\/ Values returned larger than this number are unlimited.\n-    static long unlimited_minimum = 0x7FFFFFFFFF000000L;\n-\n-    private static final Metrics INSTANCE = initContainerSubSystems();\n-\n-    private static final String PROVIDER_NAME = \"cgroupv1\";\n-\n-    private Metrics() {\n-        activeSubSystems = false;\n-    }\n-\n-    public static Metrics getInstance() {\n-        return INSTANCE;\n-    }\n-\n-    private static Metrics initContainerSubSystems() {\n-        if (!isUseContainerSupport()) {\n-            return null;\n-        }\n-        Metrics metrics = new Metrics();\n-\n-        \/**\n-         * Find the cgroup mount points for subsystems\n-         * by reading \/proc\/self\/mountinfo\n-         *\n-         * Example for docker MemorySubSystem subsystem:\n-         * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/MemorySubSystem ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,MemorySubSystem\n-         *\n-         * Example for host:\n-         * 34 28 0:29 \/ \/sys\/fs\/cgroup\/MemorySubSystem rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,MemorySubSystem\n-         *\/\n-        try (Stream<String> lines =\n-             readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n-\n-            lines.filter(line -> line.contains(\" - cgroup \"))\n-                 .map(line -> line.split(\" \"))\n-                 .forEach(entry -> createSubSystem(metrics, entry));\n-\n-        } catch (IOException e) {\n-            return null;\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        }\n-\n-        \/**\n-         * Read \/proc\/self\/cgroup and map host mount point to\n-         * local one via \/proc\/self\/mountinfo content above\n-         *\n-         * Docker example:\n-         * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n-         *\n-         * Host example:\n-         * 5:memory:\/user.slice\n-         *\n-         * Construct a path to the process specific memory and cpuset\n-         * cgroup directory.\n-         *\n-         * For a container running under Docker from memory example above\n-         * the paths would be:\n-         *\n-         * \/sys\/fs\/cgroup\/memory\n-         *\n-         * For a Host from memory example above the path would be:\n-         *\n-         * \/sys\/fs\/cgroup\/memory\/user.slice\n-         *\n-         *\/\n-        try (Stream<String> lines =\n-             readFilePrivileged(Paths.get(\"\/proc\/self\/cgroup\"))) {\n-\n-            \/\/ The limit value of 3 is because \/proc\/self\/cgroup contains three\n-            \/\/ colon-separated tokens per line. The last token, cgroup path, might\n-            \/\/ contain a ':'.\n-            lines.map(line -> line.split(\":\", 3))\n-                 .filter(line -> (line.length >= 3))\n-                 .forEach(line -> setSubSystemPath(metrics, line));\n-\n-        } catch (IOException e) {\n-            return null;\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        }\n-\n-        \/\/ Return Metrics object if we found any subsystems.\n-        if (metrics.activeSubSystems()) {\n-            return metrics;\n-        }\n-\n-        return null;\n-    }\n-\n-    static Stream<String> readFilePrivileged(Path path) throws IOException {\n-        try {\n-            PrivilegedExceptionAction<Stream<String>> pea = () -> Files.lines(path);\n-            return AccessController.doPrivileged(pea);\n-        } catch (PrivilegedActionException e) {\n-            unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    static void unwrapIOExceptionAndRethrow(PrivilegedActionException pae) throws IOException {\n-        Throwable x = pae.getCause();\n-        if (x instanceof IOException)\n-            throw (IOException) x;\n-        if (x instanceof RuntimeException)\n-            throw (RuntimeException) x;\n-        if (x instanceof Error)\n-            throw (Error) x;\n-    }\n-    \/**\n-     * createSubSystem objects and initialize mount points\n-     *\/\n-    private static void createSubSystem(Metrics metric, String[] mountentry) {\n-        if (mountentry.length < 5) return;\n-\n-        Path p = Paths.get(mountentry[4]);\n-        String[] subsystemNames = p.getFileName().toString().split(\",\");\n-\n-        for (String subsystemName: subsystemNames) {\n-            switch (subsystemName) {\n-                case \"memory\":\n-                    metric.setMemorySubSystem(new MemorySubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpuset\":\n-                    metric.setCpuSetSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpuacct\":\n-                    metric.setCpuAcctSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpu\":\n-                    metric.setCpuSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"blkio\":\n-                    metric.setBlkIOSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                default:\n-                    \/\/ Ignore subsystems that we don't support\n-                    break;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * setSubSystemPath based on the contents of \/proc\/self\/cgroup\n-     *\/\n-    private static void setSubSystemPath(Metrics metric, String[] entry) {\n-        String controller = entry[1];\n-        String base = entry[2];\n-        if (controller != null && base != null) {\n-            for (String cName: controller.split(\",\")) {\n-                switch (cName) {\n-                    case \"memory\":\n-                        setPath(metric, metric.MemorySubSystem(), base);\n-                        break;\n-                    case \"cpuset\":\n-                        setPath(metric, metric.CpuSetSubSystem(), base);\n-                        break;\n-                    case \"cpuacct\":\n-                        setPath(metric, metric.CpuAcctSubSystem(), base);\n-                        break;\n-                    case \"cpu\":\n-                        setPath(metric, metric.CpuSubSystem(), base);\n-                        break;\n-                    case \"blkio\":\n-                        setPath(metric, metric.BlkIOSubSystem(), base);\n-                        break;\n-                    \/\/ Ignore subsystems that we don't support\n-                    default:\n-                        break;\n-                }\n-            }\n-        }\n-    }\n-\n-    private static void setPath(Metrics metric, SubSystem subsystem, String base) {\n-        if (subsystem != null) {\n-            subsystem.setPath(base);\n-            if (subsystem instanceof MemorySubSystem) {\n-                MemorySubSystem memorySubSystem = (MemorySubSystem)subsystem;\n-                boolean isHierarchial = getHierarchical(memorySubSystem);\n-                memorySubSystem.setHierarchical(isHierarchial);\n-                boolean isSwapEnabled = getSwapEnabled(memorySubSystem);\n-                memorySubSystem.setSwapEnabled(isSwapEnabled);\n-            }\n-            metric.setActiveSubSystems();\n-        }\n-    }\n-\n-\n-    private static boolean getHierarchical(MemorySubSystem subsystem) {\n-        long hierarchical = SubSystem.getLongValue(subsystem, \"memory.use_hierarchy\");\n-        return hierarchical > 0;\n-    }\n-\n-    private static boolean getSwapEnabled(MemorySubSystem subsystem) {\n-        long retval = SubSystem.getLongValue(subsystem, \"memory.memsw.limit_in_bytes\");\n-        return retval > 0;\n-    }\n-\n-    private void setActiveSubSystems() {\n-        activeSubSystems = true;\n-    }\n-\n-    private boolean activeSubSystems() {\n-        return activeSubSystems;\n-    }\n-\n-    private void setMemorySubSystem(MemorySubSystem memory) {\n-        this.memory = memory;\n-    }\n-\n-    private void setCpuSubSystem(SubSystem cpu) {\n-        this.cpu = cpu;\n-    }\n-\n-    private void setCpuAcctSubSystem(SubSystem cpuacct) {\n-        this.cpuacct = cpuacct;\n-    }\n-\n-    private void setCpuSetSubSystem(SubSystem cpuset) {\n-        this.cpuset = cpuset;\n-    }\n-\n-    private void setBlkIOSubSystem(SubSystem blkio) {\n-        this.blkio = blkio;\n-    }\n-\n-    private SubSystem MemorySubSystem() {\n-        return memory;\n-    }\n-\n-    private SubSystem CpuSubSystem() {\n-        return cpu;\n-    }\n-\n-    private SubSystem CpuAcctSubSystem() {\n-        return cpuacct;\n-    }\n-\n-    private SubSystem CpuSetSubSystem() {\n-        return cpuset;\n-    }\n-\n-    private SubSystem BlkIOSubSystem() {\n-        return blkio;\n-    }\n-\n-    public String getProvider() {\n-        return PROVIDER_NAME;\n-    }\n-\n-    \/*****************************************************************\n-     * CPU Accounting Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getCpuUsage() {\n-        return SubSystem.getLongValue(cpuacct, \"cpuacct.usage\");\n-    }\n-\n-    public long[] getPerCpuUsage() {\n-        String usagelist = SubSystem.getStringValue(cpuacct, \"cpuacct.usage_percpu\");\n-        if (usagelist == null) {\n-            return new long[0];\n-        }\n-\n-        String list[] = usagelist.split(\" \");\n-        long percpu[] = new long[list.length];\n-        for (int i = 0; i < list.length; i++) {\n-            percpu[i] = Long.parseLong(list[i]);\n-        }\n-        return percpu;\n-    }\n-\n-    public long getCpuUserUsage() {\n-        return SubSystem.getLongEntry(cpuacct, \"cpuacct.stat\", \"user\");\n-    }\n-\n-    public long getCpuSystemUsage() {\n-        return SubSystem.getLongEntry(cpuacct, \"cpuacct.stat\", \"system\");\n-    }\n-\n-\n-    \/*****************************************************************\n-     * CPU Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getCpuPeriod() {\n-        return SubSystem.getLongValue(cpu, \"cpu.cfs_period_us\");\n-    }\n-\n-    public long getCpuQuota() {\n-        return SubSystem.getLongValue(cpu, \"cpu.cfs_quota_us\");\n-    }\n-\n-    public long getCpuShares() {\n-        long retval = SubSystem.getLongValue(cpu, \"cpu.shares\");\n-        if (retval == 0 || retval == 1024)\n-            return -1;\n-        else\n-            return retval;\n-    }\n-\n-    public long getCpuNumPeriods() {\n-        return SubSystem.getLongEntry(cpu, \"cpu.stat\", \"nr_periods\");\n-    }\n-\n-    public long getCpuNumThrottled() {\n-        return SubSystem.getLongEntry(cpu, \"cpu.stat\", \"nr_throttled\");\n-    }\n-\n-    public long getCpuThrottledTime() {\n-        return SubSystem.getLongEntry(cpu, \"cpu.stat\", \"throttled_time\");\n-    }\n-\n-    public long getEffectiveCpuCount() {\n-        return Runtime.getRuntime().availableProcessors();\n-    }\n-\n-\n-    \/*****************************************************************\n-     * CPUSet Subsystem\n-     ****************************************************************\/\n-\n-    public int[] getCpuSetCpus() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.cpus\"));\n-    }\n-\n-    public int[] getEffectiveCpuSetCpus() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.effective_cpus\"));\n-    }\n-\n-    public int[] getCpuSetMems() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.mems\"));\n-    }\n-\n-    public int[] getEffectiveCpuSetMems() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.effective_mems\"));\n-    }\n-\n-    public double getCpuSetMemoryPressure() {\n-        return SubSystem.getDoubleValue(cpuset, \"cpuset.memory_pressure\");\n-    }\n-\n-    public boolean isCpuSetMemoryPressureEnabled() {\n-        long val = SubSystem.getLongValue(cpuset, \"cpuset.memory_pressure_enabled\");\n-        return (val == 1);\n-    }\n-\n-\n-    \/*****************************************************************\n-     * Memory Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getMemoryFailCount() {\n-        return SubSystem.getLongValue(memory, \"memory.failcnt\");\n-    }\n-\n-    public long getMemoryLimit() {\n-        long retval = SubSystem.getLongValue(memory, \"memory.limit_in_bytes\");\n-        if (retval > unlimited_minimum) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memory_limit\";\n-                retval = SubSystem.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match,\n-                                                            Metrics::convertHierachicalLimitLine);\n-            }\n-        }\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public static long convertHierachicalLimitLine(String line) {\n-        String[] tokens = line.split(\"\\\\s\");\n-        if (tokens.length == 2) {\n-            String strVal = tokens[1];\n-            return SubSystem.convertStringToLong(strVal);\n-        }\n-        return unlimited_minimum + 1; \/\/ unlimited\n-    }\n-\n-    public long getMemoryMaxUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.max_usage_in_bytes\");\n-    }\n-\n-    public long getMemoryUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.usage_in_bytes\");\n-    }\n-\n-    public long getKernelMemoryFailCount() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.failcnt\");\n-    }\n-\n-    public long getKernelMemoryLimit() {\n-        long retval = SubSystem.getLongValue(memory, \"memory.kmem.limit_in_bytes\");\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public long getKernelMemoryMaxUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.max_usage_in_bytes\");\n-    }\n-\n-    public long getKernelMemoryUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.usage_in_bytes\");\n-    }\n-\n-    public long getTcpMemoryFailCount() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.tcp.failcnt\");\n-    }\n-\n-    public long getTcpMemoryLimit() {\n-        long retval =  SubSystem.getLongValue(memory, \"memory.kmem.tcp.limit_in_bytes\");\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public long getTcpMemoryMaxUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.tcp.max_usage_in_bytes\");\n-    }\n-\n-    public long getTcpMemoryUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.tcp.usage_in_bytes\");\n-    }\n-\n-    public long getMemoryAndSwapFailCount() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryFailCount();\n-        }\n-        return SubSystem.getLongValue(memory, \"memory.memsw.failcnt\");\n-    }\n-\n-    public long getMemoryAndSwapLimit() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryLimit();\n-        }\n-        long retval = SubSystem.getLongValue(memory, \"memory.memsw.limit_in_bytes\");\n-        if (retval > unlimited_minimum) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.memsw.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memsw_limit\";\n-                retval = SubSystem.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match,\n-                                                            Metrics::convertHierachicalLimitLine);\n-            }\n-        }\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public long getMemoryAndSwapMaxUsage() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryMaxUsage();\n-        }\n-        return SubSystem.getLongValue(memory, \"memory.memsw.max_usage_in_bytes\");\n-    }\n-\n-    public long getMemoryAndSwapUsage() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryUsage();\n-        }\n-        return SubSystem.getLongValue(memory, \"memory.memsw.usage_in_bytes\");\n-    }\n-\n-    public boolean isMemoryOOMKillEnabled() {\n-        long val = SubSystem.getLongEntry(memory, \"memory.oom_control\", \"oom_kill_disable\");\n-        return (val == 0);\n-    }\n-\n-    public long getMemorySoftLimit() {\n-        long retval = SubSystem.getLongValue(memory, \"memory.soft_limit_in_bytes\");\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-\n-    \/*****************************************************************\n-     * BlKIO Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getBlkIOServiceCount() {\n-        return SubSystem.getLongEntry(blkio, \"blkio.throttle.io_service_bytes\", \"Total\");\n-    }\n-\n-    public long getBlkIOServiced() {\n-        return SubSystem.getLongEntry(blkio, \"blkio.throttle.io_serviced\", \"Total\");\n-    }\n-\n-    private static native boolean isUseContainerSupport();\n-\n-}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/Metrics.java","additions":0,"deletions":545,"binary":false,"changes":545,"status":"deleted"},{"patch":"@@ -1,298 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.platform.cgroupv1;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.math.BigInteger;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n-\n-public class SubSystem {\n-    String root;\n-    String mountPoint;\n-    String path;\n-\n-    public SubSystem(String root, String mountPoint) {\n-        this.root = root;\n-        this.mountPoint = mountPoint;\n-    }\n-\n-    public void setPath(String cgroupPath) {\n-        if (root != null && cgroupPath != null) {\n-            if (root.equals(\"\/\")) {\n-                if (!cgroupPath.equals(\"\/\")) {\n-                    path = mountPoint + cgroupPath;\n-                }\n-                else {\n-                    path = mountPoint;\n-                }\n-            }\n-            else {\n-                if (root.equals(cgroupPath)) {\n-                    path = mountPoint;\n-                }\n-                else {\n-                    if (cgroupPath.startsWith(root)) {\n-                        if (cgroupPath.length() > root.length()) {\n-                            String cgroupSubstr = cgroupPath.substring(root.length());\n-                            path = mountPoint + cgroupSubstr;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    public String path() {\n-        return path;\n-    }\n-\n-    \/**\n-     * getSubSystemStringValue\n-     *\n-     * Return the first line of the file \"parm\" argument from the subsystem.\n-     *\n-     * TODO:  Consider using weak references for caching BufferedReader object.\n-     *\n-     * @param subsystem\n-     * @param parm\n-     * @return Returns the contents of the file specified by param.\n-     *\/\n-    public static String getStringValue(SubSystem subsystem, String parm) {\n-        if (subsystem == null) return null;\n-\n-        try {\n-            return subsystem.readStringValue(parm);\n-        } catch (IOException e) {\n-            return null;\n-        }\n-    }\n-\n-    private String readStringValue(String param) throws IOException {\n-        PrivilegedExceptionAction<BufferedReader> pea = () ->\n-                Files.newBufferedReader(Paths.get(path(), param));\n-        try (BufferedReader bufferedReader =\n-                     AccessController.doPrivileged(pea)) {\n-            String line = bufferedReader.readLine();\n-            return line;\n-        } catch (PrivilegedActionException e) {\n-            Metrics.unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    public static long getLongValueMatchingLine(SubSystem subsystem,\n-                                                     String param,\n-                                                     String match,\n-                                                     Function<String, Long> conversion) {\n-        long retval = Metrics.unlimited_minimum + 1; \/\/ default unlimited\n-        try {\n-            List<String> lines = subsystem.readMatchingLines(param);\n-            for (String line: lines) {\n-                if (line.startsWith(match)) {\n-                    retval = conversion.apply(line);\n-                    break;\n-                }\n-            }\n-        } catch (IOException e) {\n-            \/\/ Ignore. Default is unlimited.\n-        }\n-        return retval;\n-    }\n-\n-    private List<String> readMatchingLines(String param) throws IOException {\n-        try {\n-            PrivilegedExceptionAction<List<String>> pea = () ->\n-                    Files.readAllLines(Paths.get(path(), param));\n-            return AccessController.doPrivileged(pea);\n-        } catch (PrivilegedActionException e) {\n-            Metrics.unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    public static long getLongValue(SubSystem subsystem, String parm) {\n-        String strval = getStringValue(subsystem, parm);\n-        return convertStringToLong(strval);\n-    }\n-\n-    public static long convertStringToLong(String strval) {\n-        long retval = 0;\n-        if (strval == null) return 0L;\n-\n-        try {\n-            retval = Long.parseLong(strval);\n-        } catch (NumberFormatException e) {\n-            \/\/ For some properties (e.g. memory.limit_in_bytes) we may overflow the range of signed long.\n-            \/\/ In this case, return Long.MAX_VALUE\n-            BigInteger b = new BigInteger(strval);\n-            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n-                return Long.MAX_VALUE;\n-            }\n-        }\n-        return retval;\n-    }\n-\n-    public static double getDoubleValue(SubSystem subsystem, String parm) {\n-        String strval = getStringValue(subsystem, parm);\n-\n-        if (strval == null) return 0L;\n-\n-        double retval = Double.parseDouble(strval);\n-\n-        return retval;\n-    }\n-\n-    \/**\n-     * getSubSystemlongEntry\n-     *\n-     * Return the long value from the line containing the string \"entryname\"\n-     * within file \"parm\" in the \"subsystem\".\n-     *\n-     * TODO:  Consider using weak references for caching BufferedReader object.\n-     *\n-     * @param subsystem\n-     * @param parm\n-     * @param entryname\n-     * @return long value\n-     *\/\n-    public static long getLongEntry(SubSystem subsystem, String parm, String entryname) {\n-        String val = null;\n-\n-        if (subsystem == null) return 0L;\n-\n-        try (Stream<String> lines = Metrics.readFilePrivileged(Paths.get(subsystem.path(), parm))) {\n-\n-            Optional<String> result = lines.map(line -> line.split(\" \"))\n-                                           .filter(line -> (line.length == 2 &&\n-                                                   line[0].equals(entryname)))\n-                                           .map(line -> line[1])\n-                                           .findFirst();\n-\n-            return result.isPresent() ? Long.parseLong(result.get()) : 0L;\n-        } catch (IOException e) {\n-            return 0L;\n-        } catch (UncheckedIOException e) {\n-            return 0L;\n-        }\n-    }\n-\n-    public static int getIntValue(SubSystem subsystem, String parm) {\n-        String val = getStringValue(subsystem, parm);\n-\n-        if (val == null) return 0;\n-\n-        return Integer.parseInt(val);\n-    }\n-\n-    \/**\n-     * StringRangeToIntArray\n-     *\n-     * Convert a string in the form of  1,3-4,6 to an array of\n-     * integers containing all the numbers in the range.\n-     *\n-     * @param range\n-     * @return int[] containing a sorted list of processors or memory nodes\n-     *\/\n-    public static int[] StringRangeToIntArray(String range) {\n-        int[] ints = new int[0];\n-\n-        if (range == null) return ints;\n-\n-        ArrayList<Integer> results = new ArrayList<>();\n-        String strs[] = range.split(\",\");\n-        for (String str : strs) {\n-            if (str.contains(\"-\")) {\n-                String lohi[] = str.split(\"-\");\n-                \/\/ validate format\n-                if (lohi.length != 2) {\n-                    continue;\n-                }\n-                int lo = Integer.parseInt(lohi[0]);\n-                int hi = Integer.parseInt(lohi[1]);\n-                for (int i = lo; i <= hi; i++) {\n-                    results.add(i);\n-                }\n-            }\n-            else {\n-                results.add(Integer.parseInt(str));\n-            }\n-        }\n-\n-        \/\/ sort results\n-        results.sort(null);\n-\n-        \/\/ convert ArrayList to primitive int array\n-        ints = new int[results.size()];\n-        int i = 0;\n-        for (Integer n : results) {\n-            ints[i++] = n;\n-        }\n-\n-        return ints;\n-    }\n-\n-    public static class MemorySubSystem extends SubSystem {\n-\n-        private boolean hierarchical;\n-        private boolean swapenabled;\n-\n-        public MemorySubSystem(String root, String mountPoint) {\n-            super(root, mountPoint);\n-        }\n-\n-        boolean isHierarchical() {\n-            return hierarchical;\n-        }\n-\n-        void setHierarchical(boolean hierarchical) {\n-            this.hierarchical = hierarchical;\n-        }\n-\n-        boolean isSwapEnabled() {\n-            return swapenabled;\n-        }\n-\n-        void setSwapEnabled(boolean swapenabled) {\n-            this.swapenabled = swapenabled;\n-        }\n-\n-    }\n-}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/SubSystem.java","additions":0,"deletions":298,"binary":false,"changes":298,"status":"deleted"},{"patch":"@@ -0,0 +1,370 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv2;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+import jdk.internal.platform.CgroupUtil;\n+\n+public class CgroupV2Subsystem implements CgroupSubsystem {\n+\n+    private static final CgroupV2Subsystem INSTANCE = initSubsystem();\n+    private static final long[] LONG_ARRAY_NOT_SUPPORTED = null;\n+    private static final int[] INT_ARRAY_UNAVAILABLE = null;\n+    private final CgroupSubsystemController unified;\n+    private static final String PROVIDER_NAME = \"cgroupv2\";\n+    private static final int PER_CPU_SHARES = 1024;\n+    private static final String MAX_VAL = \"max\";\n+    private static final Object EMPTY_STR = \"\";\n+\n+    private CgroupV2Subsystem(CgroupSubsystemController unified) {\n+        this.unified = unified;\n+    }\n+\n+    private long getLongVal(String file) {\n+        return CgroupSubsystemController.getLongValue(unified,\n+                                                      file,\n+                                                      CgroupV2SubsystemController::convertStringToLong,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+    }\n+\n+    private static CgroupV2Subsystem initSubsystem() {\n+        \/\/ read mountinfo so as to determine root mount path\n+        String mountPath = null;\n+        try (Stream<String> lines =\n+                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n+\n+            String l = lines.filter(line -> line.contains(\" - cgroup2 \"))\n+                            .collect(Collectors.joining());\n+            String[] tokens = l.split(\" \");\n+            mountPath = tokens[4];\n+        } catch (UncheckedIOException e) {\n+            return null;\n+        } catch (IOException e) {\n+            return null;\n+        }\n+        String cgroupPath = null;\n+        try {\n+            List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(\"\/proc\/self\/cgroup\"));\n+            for (String line: lines) {\n+                String[] tokens = line.split(\":\");\n+                if (tokens.length != 3) {\n+                    return null; \/\/ something is not right.\n+                }\n+                if (!\"0\".equals(tokens[0])) {\n+                    \/\/ hierarchy must be zero for cgroups v2\n+                    return null;\n+                }\n+                cgroupPath = tokens[2];\n+                break;\n+            }\n+        } catch (UncheckedIOException e) {\n+            return null;\n+        } catch (IOException e) {\n+            return null;\n+        }\n+        CgroupSubsystemController unified = new CgroupV2SubsystemController(\n+                mountPath,\n+                cgroupPath);\n+        return new CgroupV2Subsystem(unified);\n+    }\n+\n+    public static CgroupSubsystem getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public String getProvider() {\n+        return PROVIDER_NAME;\n+    }\n+\n+    @Override\n+    public long getCpuUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"usage_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long[] getPerCpuUsage() {\n+        return LONG_ARRAY_NOT_SUPPORTED;\n+    }\n+\n+    @Override\n+    public long getCpuUserUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"user_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long getCpuSystemUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"system_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long getCpuPeriod() {\n+        return getFromCpuMax(1 \/* $PERIOD index *\/);\n+    }\n+\n+    @Override\n+    public long getCpuQuota() {\n+        return getFromCpuMax(0 \/* $MAX index *\/);\n+    }\n+\n+    private long getFromCpuMax(int tokenIdx) {\n+        String cpuMaxRaw = CgroupSubsystemController.getStringValue(unified, \"cpu.max\");\n+        if (cpuMaxRaw == null) {\n+            \/\/ likely file not found\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        \/\/ $MAX $PERIOD\n+        String[] tokens = cpuMaxRaw.split(\"\\\\s+\");\n+        if (tokens.length != 2) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        String quota = tokens[tokenIdx];\n+        return limitFromString(quota);\n+    }\n+\n+    private long limitFromString(String strVal) {\n+        if (strVal == null || MAX_VAL.equals(strVal)) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        return Long.parseLong(strVal);\n+    }\n+\n+    @Override\n+    public long getCpuShares() {\n+        long sharesRaw = getLongVal(\"cpu.weight\");\n+        if (sharesRaw == 100 || sharesRaw <= 0) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        int shares = (int)sharesRaw;\n+        \/\/ CPU shares (OCI) value needs to get translated into\n+        \/\/ a proper Cgroups v2 value. See:\n+        \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n+        \/\/\n+        \/\/ Use the inverse of (x == OCI value, y == cgroupsv2 value):\n+        \/\/ ((262142 * y - 1)\/9999) + 2 = x\n+        \/\/\n+        int x = 262142 * shares - 1;\n+        double frac = x\/9999.0;\n+        x = ((int)frac) + 2;\n+        if ( x <= PER_CPU_SHARES ) {\n+            return PER_CPU_SHARES; \/\/ mimic cgroups v1\n+        }\n+        int f = x\/PER_CPU_SHARES;\n+        int lower_multiple = f * PER_CPU_SHARES;\n+        int upper_multiple = (f + 1) * PER_CPU_SHARES;\n+        int distance_lower = Math.max(lower_multiple, x) - Math.min(lower_multiple, x);\n+        int distance_upper = Math.max(upper_multiple, x) - Math.min(upper_multiple, x);\n+        x = distance_lower <= distance_upper ? lower_multiple : upper_multiple;\n+        return x;\n+    }\n+\n+    @Override\n+    public long getCpuNumPeriods() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"nr_periods\");\n+    }\n+\n+    @Override\n+    public long getCpuNumThrottled() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"nr_throttled\");\n+    }\n+\n+    @Override\n+    public long getCpuThrottledTime() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"throttled_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long getEffectiveCpuCount() {\n+        return Runtime.getRuntime().availableProcessors();\n+    }\n+\n+    @Override\n+    public int[] getCpuSetCpus() {\n+        String cpuSetVal = CgroupSubsystemController.getStringValue(unified, \"cpuset.cpus\");\n+        return getCpuSet(cpuSetVal);\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetCpus() {\n+        String effCpuSetVal = CgroupSubsystemController.getStringValue(unified, \"cpuset.cpus.effective\");\n+        return getCpuSet(effCpuSetVal);\n+    }\n+\n+    @Override\n+    public int[] getCpuSetMems() {\n+        String cpuSetMems = CgroupSubsystemController.getStringValue(unified, \"cpuset.mems\");\n+        return getCpuSet(cpuSetMems);\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetMems() {\n+        String effCpuSetMems = CgroupSubsystemController.getStringValue(unified, \"cpuset.mems.effective\");\n+        return getCpuSet(effCpuSetMems);\n+    }\n+\n+    private int[] getCpuSet(String cpuSetVal) {\n+        if (cpuSetVal == null || EMPTY_STR.equals(cpuSetVal)) {\n+            return INT_ARRAY_UNAVAILABLE;\n+        }\n+        return CgroupSubsystemController.stringRangeToIntArray(cpuSetVal);\n+    }\n+\n+    @Override\n+    public long getMemoryFailCount() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"memory.events\", \"max\");\n+    }\n+\n+    @Override\n+    public long getMemoryLimit() {\n+        String strVal = CgroupSubsystemController.getStringValue(unified, \"memory.max\");\n+        return limitFromString(strVal);\n+    }\n+\n+    @Override\n+    public long getMemoryUsage() {\n+        return getLongVal(\"memory.current\");\n+    }\n+\n+    @Override\n+    public long getTcpMemoryUsage() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"memory.stat\", \"sock\");\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapLimit() {\n+        String strVal = CgroupSubsystemController.getStringValue(unified, \"memory.swap.max\");\n+        return limitFromString(strVal);\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapUsage() {\n+        return getLongVal(\"memory.swap.current\");\n+    }\n+\n+    @Override\n+    public long getMemorySoftLimit() {\n+        String softLimitStr = CgroupSubsystemController.getStringValue(unified, \"memory.high\");\n+        return limitFromString(softLimitStr);\n+    }\n+\n+    @Override\n+    public long getBlkIOServiceCount() {\n+        return sumTokensIOStat(CgroupV2Subsystem::lineToRandWIOs);\n+    }\n+\n+\n+    @Override\n+    public long getBlkIOServiced() {\n+        return sumTokensIOStat(CgroupV2Subsystem::lineToRBytesAndWBytesIO);\n+    }\n+\n+    private long sumTokensIOStat(Function<String, Long> mapFunc) {\n+        try {\n+            return CgroupUtil.readFilePrivileged(Paths.get(unified.path(), \"io.stat\"))\n+                                .map(mapFunc)\n+                                .collect(Collectors.summingLong(e -> e));\n+        } catch (UncheckedIOException e) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        } catch (IOException e) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+    }\n+\n+    private static String[] getRWIOMatchTokenNames() {\n+        return new String[] { \"rios\", \"wios\" };\n+    }\n+\n+    private static String[] getRWBytesIOMatchTokenNames() {\n+        return new String[] { \"rbytes\", \"wbytes\" };\n+    }\n+\n+    public static Long lineToRandWIOs(String line) {\n+        String[] matchNames = getRWIOMatchTokenNames();\n+        return ioStatLineToLong(line, matchNames);\n+    }\n+\n+    public static Long lineToRBytesAndWBytesIO(String line) {\n+        String[] matchNames = getRWBytesIOMatchTokenNames();\n+        return ioStatLineToLong(line, matchNames);\n+    }\n+\n+    private static Long ioStatLineToLong(String line, String[] matchNames) {\n+        if (line == null || EMPTY_STR.equals(line)) {\n+            return Long.valueOf(0);\n+        }\n+        String[] tokens = line.split(\"\\\\s+\");\n+        long retval = 0;\n+        for (String t: tokens) {\n+            String[] valKeys = t.split(\"=\");\n+            if (valKeys.length != 2) {\n+                \/\/ ignore device ids $MAJ:$MIN\n+                continue;\n+            }\n+            for (String match: matchNames) {\n+                if (match.equals(valKeys[0])) {\n+                    retval += longOrZero(valKeys[1]);\n+                }\n+            }\n+        }\n+        return Long.valueOf(retval);\n+    }\n+\n+    private static long longOrZero(String val) {\n+        long lVal = 0;\n+        try {\n+            lVal = Long.parseLong(val);\n+        } catch (NumberFormatException e) {\n+            \/\/ keep at 0\n+        }\n+        return lVal;\n+    }\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv2;\n+\n+import java.nio.file.Paths;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+\n+public class CgroupV2SubsystemController implements CgroupSubsystemController {\n+\n+    private final String path;\n+\n+    public CgroupV2SubsystemController(String mountPath, String cgroupPath) {\n+        this.path = Paths.get(mountPath, cgroupPath).toString();\n+    }\n+\n+    @Override\n+    public String path() {\n+        return path;\n+    }\n+\n+    public static long convertStringToLong(String strval) {\n+        return CgroupSubsystemController.convertStringToLong(strval,\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* overflow retval *\/,\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* default retval on error *\/);\n+    }\n+\n+    public static long getLongEntry(CgroupSubsystemController controller, String param, String entryname) {\n+        return CgroupSubsystemController.getLongEntry(controller,\n+                                                      param,\n+                                                      entryname,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+}\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2SubsystemController.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+\n+#include \"jdk_internal_platform_CgroupMetrics.h\"\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_platform_CgroupMetrics_isUseContainerSupport(JNIEnv *env, jclass ignored)\n+{\n+    return JVM_IsUseContainerSupport();\n+}\n","filename":"src\/java.base\/linux\/native\/libjava\/CgroupMetrics.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jvm.h\"\n-\n-#include \"jdk_internal_platform_cgroupv1_Metrics.h\"\n-\n-JNIEXPORT jboolean JNICALL\n-Java_jdk_internal_platform_cgroupv1_Metrics_isUseContainerSupport(JNIEnv *env, jclass ignored)\n-{\n-    return JVM_IsUseContainerSupport();\n-}\n","filename":"src\/java.base\/linux\/native\/libjava\/Metrics.c","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -63,1 +63,1 @@\n-static int sigWakeup = (__SIGRTMAX - 2);\n+#define WAKEUP_SIGNAL (SIGRTMAX - 2)\n@@ -155,1 +155,1 @@\n-    sigaction(sigWakeup, &sa, NULL);\n+    sigaction(WAKEUP_SIGNAL, &sa, NULL);\n@@ -158,1 +158,1 @@\n-    sigaddset(&sigset, sigWakeup);\n+    sigaddset(&sigset, WAKEUP_SIGNAL);\n@@ -308,1 +308,1 @@\n-            pthread_kill( curr->thr, sigWakeup );\n+            pthread_kill( curr->thr, WAKEUP_SIGNAL);\n","filename":"src\/java.base\/linux\/native\/libnet\/linux_close.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import sun.security.action.GetPropertyAction;\n@@ -31,0 +32,11 @@\n+    private static final boolean hasDynamicLoaderCache;\n+    static {\n+        String osVersion = GetPropertyAction.privilegedGetProperty(\"os.version\");\n+        \/\/ dynamic linker cache support on os.version >= 11.x\n+        int major = 11;\n+        int i = osVersion.indexOf('.');\n+        try {\n+            major = Integer.parseInt(i < 0 ? osVersion : osVersion.substring(0, i));\n+        } catch (NumberFormatException e) {}\n+        hasDynamicLoaderCache = major >= 11;\n+    }\n@@ -34,0 +46,14 @@\n+    \/**\n+     * Returns true if loading a native library only if\n+     * it's present on the file system.\n+     *\n+     * @implNote\n+     * On macOS 11.x or later which supports dynamic linker cache,\n+     * the dynamic library is not present on the filesystem.  The\n+     * library cannot determine if a dynamic library exists on a\n+     * given path or not and so this method returns false.\n+     *\/\n+    static boolean loadLibraryOnlyIfPresent() {\n+        return !hasDynamicLoaderCache;\n+    }\n+\n","filename":"src\/java.base\/macosx\/classes\/java\/lang\/ClassLoaderHelper.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2409,0 +2409,2 @@\n+        private static final boolean loadLibraryOnlyIfPresent = ClassLoaderHelper.loadLibraryOnlyIfPresent();\n+\n@@ -2423,1 +2425,2 @@\n-        native boolean load0(String name, boolean isBuiltin);\n+        native boolean load0(String name, boolean isBuiltin,\n+                             boolean throwExceptionIfFail);\n@@ -2442,1 +2445,1 @@\n-            if (!load0(name, isBuiltin)) return false;\n+            if (!load0(name, isBuiltin, loadLibraryOnlyIfPresent)) return false;\n@@ -2684,1 +2687,4 @@\n-                            return file.exists() ? file.getCanonicalPath() : null;\n+                            if (NativeLibrary.loadLibraryOnlyIfPresent && !file.exists()) {\n+                                return null;\n+                            }\n+                            return file.getCanonicalPath();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -526,1 +526,1 @@\n-    private static final ThreadLocal<StringCoding.Result>\n+    private static final ThreadLocal<SoftReference<Result>>\n@@ -528,2 +528,2 @@\n-            protected StringCoding.Result initialValue() {\n-                return new StringCoding.Result();\n+            protected SoftReference<Result> initialValue() {\n+                return new SoftReference<>(new Result());\n@@ -531,0 +531,9 @@\n+    private static Result resultCached() {\n+        SoftReference<Result> sr = resultCached.get();\n+        Result r;\n+        if (sr == null || (r = sr.get()) == null) {\n+            r = new Result();\n+            resultCached.set(new SoftReference<>(r));\n+        }\n+        return r;\n+    }\n@@ -535,1 +544,1 @@\n-        Result result = resultCached.get();\n+        Result result = resultCached();\n@@ -585,1 +594,1 @@\n-       Result result = resultCached.get();\n+       Result result = resultCached();\n@@ -723,1 +732,1 @@\n-            return resultCached.get().with(Arrays.copyOfRange(src, sp, sp + len),\n+            return resultCached().with(Arrays.copyOfRange(src, sp, sp + len),\n@@ -729,1 +738,1 @@\n-        Result ret = resultCached.get();\n+        Result ret = resultCached();\n@@ -1063,1 +1072,1 @@\n-        Result ret = resultCached.get().with(ca, 0, cb.position());\n+        Result ret = resultCached().with(ca, 0, cb.position());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,3 +59,1 @@\n-            \/\/ We currently only support cgroupv1\n-            Class<?> c = Class.forName(\"jdk.internal.platform.cgroupv1.Metrics\");\n-            @SuppressWarnings(\"unchecked\")\n+            Class<?> c = Class.forName(\"jdk.internal.platform.CgroupMetrics\");\n@@ -77,1 +75,1 @@\n-     * The provider for Linux is cgroupsv1.\n+     * The provider for Linux is cgroups (version 1 or 2).\n@@ -93,1 +91,2 @@\n-     * @return Time in nanoseconds or 0L if metric is not available.\n+     * @return Time in nanoseconds, -1 if unknown or\n+     *         -2 if the metric is not supported.\n@@ -109,1 +108,1 @@\n-     *         this metric is not available, a zero length array will be\n+     *         this metric is not supported or not available, null will be\n@@ -119,1 +118,2 @@\n-     * @return User time in nanoseconds or 0L if metric is not available.\n+     * @return User time in nanoseconds, -1 if the metric is not available or\n+     *         -2 if the metric is not supported.\n@@ -128,1 +128,2 @@\n-     * @return System time in nanoseconds or 0L if metric is not available.\n+     * @return System time in nanoseconds, -1 if the metric is not available or\n+     *         -2 if the metric is not supported.\n@@ -141,1 +142,2 @@\n-     * @return time in microseconds or 0L if metric is not available.\n+     * @return time in microseconds, -1 if the metric is not available or\n+     *         -2 if the metric is not supported.\n@@ -151,1 +153,2 @@\n-     * @return time in microseconds or -1 if the quota is unlimited.\n+     * @return time in microseconds, -1 if the quota is unlimited or\n+     *         -2 if not supported.\n@@ -170,1 +173,2 @@\n-     * @return shares value or -1 if no share set.\n+     * @return shares value, -1 if the metric is not available or\n+     *         -2 if cpu shares are not supported.\n@@ -177,2 +181,1 @@\n-     * a CPU quota has been setup for the Isolation Group; otherwise\n-     * returns 0.\n+     * a CPU quota has been setup for the Isolation Group\n@@ -180,1 +183,2 @@\n-     * @return count of elapsed periods or 0 if the quota is unlimited.\n+     * @return count of elapsed periods, -1 if the metric is not available\n+     *         or -2 if the metric is not supported.\n@@ -190,1 +194,2 @@\n-     * @return count of throttled periods or 0 if the quota is unlimited.\n+     * @return count of throttled periods, -1 if the metric is not available or\n+     *         -2 if it is not supported.\n@@ -200,1 +205,2 @@\n-     * @return Throttled time in nanoseconds or 0 if the quota is unlimited.\n+     * @return Throttled time in nanoseconds, -1 if the metric is not available\n+     *         or -2 if it is not supported.\n@@ -232,2 +238,2 @@\n-     * @return An array of available CPUs or a zero length array\n-     *         if the metric is not available.\n+     * @return An array of available CPUs. Returns null if the metric is not\n+     *         available or the metric is not supported.\n@@ -244,2 +250,2 @@\n-     * @return An array of available and online CPUs or a zero length\n-     *         array if the metric is not available.\n+     * @return An array of available and online CPUs. Returns null\n+     *         if the metric is not available or the metric is not supported.\n@@ -258,2 +264,2 @@\n-     * @return An array of available memory nodes or a zero length array\n-     *         if the metric is not available.\n+     * @return An array of available memory nodes or null\n+     *         if the metric is not available or is not supported.\n@@ -270,2 +276,2 @@\n-     * @return An array of available and online nodes or a zero length\n-     *         array if the metric is not available.\n+     * @return An array of available and online nodes or null\n+     *         if the metric is not available or is not supported.\n@@ -276,21 +282,0 @@\n-    \/**\n-     * Returns the (attempts per second * 1000), if enabled, that the\n-     * operating system tries to satisfy a memory request for any\n-     * process in the current Isolation Group when no free memory is\n-     * readily available.  Use {@link #isCpuSetMemoryPressureEnabled()} to\n-     * to determine if this support is enabled.\n-     *\n-     * @return Memory pressure or 0 if not enabled or metric is not\n-     *         available.\n-     *\n-     *\/\n-    public double getCpuSetMemoryPressure();\n-\n-    \/**\n-     * Returns the state of the memory pressure detection support.\n-     *\n-     * @return true if the support is available and enabled, otherwise false.\n-     *\n-     *\/\n-    public boolean isCpuSetMemoryPressureEnabled();\n-\n@@ -305,2 +290,3 @@\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n+     * @return The number of exceeded requests or -1 if the metric\n+     *         is not available. Returns -2 if the metric is not\n+     *         supported.\n@@ -315,2 +301,2 @@\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit or -2 if this metric is not supported.\n@@ -321,10 +307,0 @@\n-    \/**\n-     * Returns the largest amount of physical memory, in bytes, that\n-     * have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getMemoryMaxUsage();\n-\n@@ -335,2 +311,3 @@\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n+     * @return The amount of memory in bytes allocated or -1 if\n+     *         the metric is not available or -2 if the metric is not\n+     *         supported.\n@@ -341,70 +318,0 @@\n-    \/**\n-     * Returns the number of times that kernel memory requests in the\n-     * Isolation Group have exceeded the kernel memory limit.\n-     *\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryFailCount();\n-\n-    \/**\n-     * Returns the maximum amount of kernel physical memory, in bytes, that\n-     * can be allocated in the Isolation Group.\n-     *\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryLimit();\n-\n-    \/**\n-     * Returns the largest amount of kernel physical memory, in bytes, that\n-     * have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryMaxUsage();\n-\n-    \/**\n-     * Returns the amount of kernel physical memory, in bytes, that\n-     * is currently allocated in the current Isolation Group.\n-     *\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryUsage();\n-\n-    \/**\n-     * Returns the number of times that networking memory requests in the\n-     * Isolation Group have exceeded the kernel memory limit.\n-     *\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n-     *\n-     *\/\n-    public long getTcpMemoryFailCount();\n-\n-    \/**\n-     * Returns the maximum amount of networking physical memory, in bytes,\n-     * that can be allocated in the Isolation Group.\n-     *\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n-     *\n-     *\/\n-    public long getTcpMemoryLimit();\n-\n-    \/**\n-     * Returns the largest amount of networking physical memory, in bytes,\n-     * that have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getTcpMemoryMaxUsage();\n-\n@@ -415,2 +322,2 @@\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n+     * @return The amount of memory in bytes allocated or -1 if the metric\n+     *         is not available. Returns -2 if this metric is not supported.\n@@ -421,10 +328,0 @@\n-    \/**\n-     * Returns the number of times that user memory requests in the\n-     * Isolation Group have exceeded the memory + swap limit.\n-     *\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n-     *\n-     *\/\n-    public long getMemoryAndSwapFailCount();\n-\n@@ -435,2 +332,2 @@\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit set or -2 if this metric is not supported.\n@@ -441,10 +338,0 @@\n-    \/**\n-     * Returns the largest amount of physical memory and swap space,\n-     * in bytes, that have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getMemoryAndSwapMaxUsage();\n-\n@@ -455,2 +342,3 @@\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n+     * @return The amount of memory in bytes allocated or -1 if\n+     *         the metric is not available. Returns -2 if this metric is not\n+     *         supported.\n@@ -461,12 +349,0 @@\n-    \/**\n-     * Returns the state of the Operating System Out of Memory termination\n-     * policy.\n-     *\n-     * @return Returns true if operating system will terminate processes\n-     *         in the Isolation Group that exceed the amount of available\n-     *         memory, otherwise false.  Flase will be returned if this\n-     *         capability is not available on the current operating system.\n-     *\n-     *\/\n-    public boolean isMemoryOOMKillEnabled();\n-\n@@ -481,2 +357,2 @@\n-     *         conditions.  If this metric is not available, 0 will be\n-     *         returned.\n+     *         conditions.  If this metric is not available, -1 will be\n+     *         returned. Returns -2 if the metric is not supported.\n@@ -495,1 +371,2 @@\n-     * @return The count of requests or 0 if this metric is not available.\n+     * @return The count of requests or -1 if the metric is not available.\n+     *         Returns -2 if this metric is not supported.\n@@ -504,1 +381,2 @@\n-     * @return The number of bytes transferred or 0 if this metric is not available.\n+     * @return The number of bytes transferred or -1 if the metric is not\n+     *         available. Returns -2 if this metric is not supported.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/platform\/Metrics.java","additions":52,"deletions":174,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,0 @@\n-import java.lang.module.ModuleDescriptor.Requires;\n@@ -52,0 +51,1 @@\n+import java.lang.module.ModuleDescriptor.Requires;\n@@ -65,1 +65,0 @@\n-import java.text.Normalizer;\n@@ -67,0 +66,1 @@\n+import java.text.Normalizer;\n@@ -122,0 +122,1 @@\n+\n@@ -326,0 +327,2 @@\n+        final long longRetvalNotSupported = -2;\n+\n@@ -328,5 +331,3 @@\n-        ostream.println(INDENT + \"CPU Period: \" + c.getCpuPeriod() +\n-               (c.getCpuPeriod() == -1 ? \"\" : \"us\"));\n-        ostream.println(INDENT + \"CPU Quota: \" + c.getCpuQuota() +\n-               (c.getCpuQuota() == -1 ? \"\" : \"us\"));\n-        ostream.println(INDENT + \"CPU Shares: \" + c.getCpuShares());\n+        ostream.println(formatCpuVal(c.getCpuPeriod(), INDENT + \"CPU Period: \", longRetvalNotSupported));\n+        ostream.println(formatCpuVal(c.getCpuQuota(), INDENT + \"CPU Quota: \", longRetvalNotSupported));\n+        ostream.println(formatCpuVal(c.getCpuShares(), INDENT + \"CPU Shares: \", longRetvalNotSupported));\n@@ -335,2 +336,3 @@\n-        ostream.println(INDENT + \"List of Processors, \"\n-                + cpus.length + \" total: \");\n+        if (cpus != null) {\n+            ostream.println(INDENT + \"List of Processors, \"\n+                    + cpus.length + \" total: \");\n@@ -338,6 +340,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < cpus.length; i++) {\n-            ostream.print(cpus[i] + \" \");\n-        }\n-        if (cpus.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < cpus.length; i++) {\n+                ostream.print(cpus[i] + \" \");\n+            }\n+            if (cpus.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Processors: N\/A\");\n@@ -347,2 +352,3 @@\n-        ostream.println(INDENT + \"List of Effective Processors, \"\n-                + cpus.length + \" total: \");\n+        if (cpus != null) {\n+            ostream.println(INDENT + \"List of Effective Processors, \"\n+                    + cpus.length + \" total: \");\n@@ -350,6 +356,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < cpus.length; i++) {\n-            ostream.print(cpus[i] + \" \");\n-        }\n-        if (cpus.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < cpus.length; i++) {\n+                ostream.print(cpus[i] + \" \");\n+            }\n+            if (cpus.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Effective Processors: N\/A\");\n@@ -359,2 +368,3 @@\n-        ostream.println(INDENT + \"List of Memory Nodes, \"\n-                + mems.length + \" total: \");\n+        if (mems != null) {\n+            ostream.println(INDENT + \"List of Memory Nodes, \"\n+                    + mems.length + \" total: \");\n@@ -362,6 +372,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < mems.length; i++) {\n-            ostream.print(mems[i] + \" \");\n-        }\n-        if (mems.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < mems.length; i++) {\n+                ostream.print(mems[i] + \" \");\n+            }\n+            if (mems.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Memory Nodes: N\/A\");\n@@ -371,2 +384,3 @@\n-        ostream.println(INDENT + \"List of Available Memory Nodes, \"\n-                + mems.length + \" total: \");\n+        if (mems != null) {\n+            ostream.println(INDENT + \"List of Available Memory Nodes, \"\n+                    + mems.length + \" total: \");\n@@ -374,6 +388,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < mems.length; i++) {\n-            ostream.print(mems[i] + \" \");\n-        }\n-        if (mems.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < mems.length; i++) {\n+                ostream.print(mems[i] + \" \");\n+            }\n+            if (mems.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Available Memory Nodes: N\/A\");\n@@ -382,3 +399,0 @@\n-        ostream.println(INDENT + \"CPUSet Memory Pressure Enabled: \"\n-                + c.isCpuSetMemoryPressureEnabled());\n-\n@@ -386,2 +400,1 @@\n-        ostream.println(INDENT + \"Memory Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(formatLimitString(limit, INDENT + \"Memory Limit: \", longRetvalNotSupported));\n@@ -390,2 +403,1 @@\n-        ostream.println(INDENT + \"Memory Soft Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(formatLimitString(limit, INDENT + \"Memory Soft Limit: \", longRetvalNotSupported));\n@@ -394,6 +406,1 @@\n-        ostream.println(INDENT + \"Memory & Swap Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n-\n-        limit = c.getKernelMemoryLimit();\n-        ostream.println(INDENT + \"Kernel Memory Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(formatLimitString(limit, INDENT + \"Memory & Swap Limit: \", longRetvalNotSupported));\n@@ -401,3 +408,2 @@\n-        limit = c.getTcpMemoryLimit();\n-        ostream.println(INDENT + \"TCP Memory Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(\"\");\n+    }\n@@ -405,2 +411,9 @@\n-        ostream.println(INDENT + \"Out Of Memory Killer Enabled: \"\n-                + c.isMemoryOOMKillEnabled());\n+    private static String formatLimitString(long limit, String prefix, long unavailable) {\n+        if (limit >= 0) {\n+            return prefix + SizePrefix.scaleValue(limit);\n+        } else if (limit == unavailable) {\n+            return prefix + \"N\/A\";\n+        } else {\n+            return prefix + \"Unlimited\";\n+        }\n+    }\n@@ -408,1 +421,8 @@\n-        ostream.println(\"\");\n+    private static String formatCpuVal(long cpuVal, String prefix, long unavailable) {\n+        if (cpuVal >= 0) {\n+            return prefix + cpuVal + \"us\";\n+        } else if (cpuVal == unavailable) {\n+            return prefix + \"N\/A\";\n+        } else {\n+            return prefix + cpuVal;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":79,"deletions":59,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -339,1 +339,2 @@\n-  (JNIEnv *env, jobject this, jstring name, jboolean isBuiltin)\n+  (JNIEnv *env, jobject this, jstring name,\n+   jboolean isBuiltin, jboolean throwExceptionIfFail)\n@@ -353,1 +354,1 @@\n-    handle = isBuiltin ? procHandle : JVM_LoadLibrary(cname);\n+    handle = isBuiltin ? procHandle : JVM_LoadLibrary(cname, throwExceptionIfFail);\n","filename":"src\/java.base\/share\/native\/libjava\/ClassLoader.c","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -214,11 +214,0 @@\n-ImageFileReaderTable::~ImageFileReaderTable() {\n-    for (u4 i = 0; i < _count; i++) {\n-        ImageFileReader* image = _table[i];\n-\n-        if (image != NULL) {\n-            delete image;\n-        }\n-    }\n-    free(_table);\n-}\n-\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -374,1 +374,6 @@\n-    ~ImageFileReaderTable();\n+\/\/ ~ImageFileReaderTable()\n+\/\/ Bug 8166727\n+\/\/\n+\/\/ WARNING: Should never close jimage files.\n+\/\/          Threads may still be running during shutdown.\n+\/\/\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,8 @@\n+    \/**\n+     * Returns true if loading a native library only if\n+     * it's present on the file system.\n+     *\/\n+    static boolean loadLibraryOnlyIfPresent() {\n+        return true;\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ClassLoaderHelper.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#define ISNANF(f) isnanf(f)\n+#define ISNANF(f) isnan(f)\n","filename":"src\/java.base\/unix\/native\/libjava\/jdk_util_md.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  #define INTERRUPT_SIGNAL (__SIGRTMAX - 2)\n+  #define INTERRUPT_SIGNAL (SIGRTMAX - 2)\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/NativeThread.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,8 @@\n+    \/**\n+     * Returns true if loading a native library only if\n+     * it's present on the file system.\n+     *\/\n+    static boolean loadLibraryOnlyIfPresent() {\n+        return true;\n+    }\n+\n","filename":"src\/java.base\/windows\/classes\/java\/lang\/ClassLoaderHelper.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -622,1 +622,1 @@\n-                const AudioObjectPropertyAddress address = {kAudioObjectPropertyElementName, port->scope, ch};\n+                const AudioObjectPropertyAddress address = {kAudioObjectPropertyElementName, port->scope, (unsigned)ch};\n","filename":"src\/java.desktop\/macosx\/native\/libjsound\/PLATFORM_API_MacOSX_Ports.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1033,1 +1033,1 @@\n-        bis.mark(128);\n+        bis.mark(128); \/\/ 128 is the length of the ICC profile header\n@@ -1036,1 +1036,1 @@\n-        if (header[36] != 0x61 || header[37] != 0x63 ||\n+        if (header.length < 128 || header[36] != 0x61 || header[37] != 0x63 ||\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_Profile.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-#ifdef __linux__\n-#include <execinfo.h>\n-#endif\n@@ -790,20 +787,0 @@\n-#ifdef __linux__\n-void print_stack(void)\n-{\n-  void *array[10];\n-  size_t size;\n-  char **strings;\n-  size_t i;\n-\n-  size = backtrace (array, 10);\n-  strings = backtrace_symbols (array, size);\n-\n-  fprintf (stderr, \"Obtained %zd stack frames.\\n\", size);\n-\n-  for (i = 0; i < size; i++)\n-     fprintf (stderr, \"%s\\n\", strings[i]);\n-\n-  free (strings);\n-}\n-#endif\n-\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/xawt\/XToolkit.c","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -68,0 +68,7 @@\n+    public PooledConnection createPooledConnection(PoolCallback pcb, long timeout)\n+        throws NamingException {\n+        return new LdapClient(host, port, socketFactory,\n+                guardedIntegerCast(timeout),\n+                readTimeout, trace, pcb);\n+    }\n+\n@@ -71,0 +78,9 @@\n+\n+    private int guardedIntegerCast(long timeout) {\n+        if (timeout < Integer.MIN_VALUE) {\n+            return Integer.MIN_VALUE;\n+        } else if (timeout > Integer.MAX_VALUE) {\n+            return Integer.MAX_VALUE;\n+        }\n+        return (int) timeout;\n+    }\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/LdapClientFactory.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -71,0 +74,1 @@\n+    final private int initSize;\n@@ -74,0 +78,1 @@\n+    final private PooledConnectionFactory factory;\n@@ -78,0 +83,4 @@\n+    private boolean initialized = false;\n+    private final ReentrantLock lock;\n+    private final Condition connectionsAvailable;\n+\n@@ -90,3 +99,2 @@\n-    Connections(Object id, int initSize, int prefSize, int maxSize,\n-        PooledConnectionFactory factory) throws NamingException {\n-\n+    Connections(Object id, int initSize, int prefSize, int maxSize, PooledConnectionFactory factory,\n+            ReentrantLock lock) throws NamingException {\n@@ -94,0 +102,4 @@\n+        this.lock = lock;\n+        this.connectionsAvailable = lock.newCondition();\n+        this.factory = factory;\n+\n@@ -97,1 +109,1 @@\n-            initSize = Math.min(initSize, maxSize);\n+            this.initSize = Math.min(initSize, maxSize);\n@@ -100,0 +112,1 @@\n+            this.initSize = initSize;\n@@ -101,1 +114,2 @@\n-        conns = new ArrayList<>(maxSize > 0 ? maxSize : DEFAULT_SIZE);\n+        this.conns = new ArrayList<>(maxSize > 0 ? maxSize : DEFAULT_SIZE);\n+        this.initialized = initSize <= 0;\n@@ -105,1 +119,1 @@\n-        ref = new SoftReference<>(id);\n+        this.ref = new SoftReference<>(id);\n@@ -110,0 +124,1 @@\n+    }\n@@ -111,6 +126,7 @@\n-        \/\/ Create initial connections\n-        PooledConnection conn;\n-        for (int i = 0; i < initSize; i++) {\n-            conn = factory.createPooledConnection(this);\n-            td(\"Create \", conn ,factory);\n-            conns.add(new ConnectionDesc(conn)); \/\/ Add new idle conn to pool\n+    void waitForAvailableConnection() throws InterruptedNamingException {\n+        try {\n+            d(\"get(): waiting\");\n+            connectionsAvailable.await();\n+        } catch (InterruptedException e) {\n+            throw new InterruptedNamingException(\n+                    \"Interrupted while waiting for a connection\");\n@@ -120,38 +136,6 @@\n-    \/**\n-     * Retrieves a PooledConnection from this list of connections.\n-     * Use an existing one if one is idle, or create one if the list's\n-     * max size hasn't been reached. If max size has been reached, wait\n-     * for a PooledConnection to be returned, or one to be removed (thus\n-     * not reaching the max size any longer).\n-     *\n-     * @param timeout if > 0, msec to wait until connection is available\n-     * @param factory creates the PooledConnection if one needs to be created\n-     *\n-     * @return A non-null PooledConnection\n-     * @throws NamingException PooledConnection cannot be created, because this\n-     * thread was interrupted while it waited for an available connection,\n-     * or if it timed out while waiting, or the creation of a connection\n-     * resulted in an error.\n-     *\/\n-    synchronized PooledConnection get(long timeout,\n-        PooledConnectionFactory factory) throws NamingException {\n-        PooledConnection conn;\n-        long start = (timeout > 0 ? System.currentTimeMillis() : 0);\n-        long waittime = timeout;\n-\n-        d(\"get(): before\");\n-        while ((conn = getOrCreateConnection(factory)) == null) {\n-            if (timeout > 0 && waittime <= 0) {\n-                throw new CommunicationException(\n-                    \"Timeout exceeded while waiting for a connection: \" +\n-                    timeout + \"ms\");\n-            }\n-            try {\n-                d(\"get(): waiting\");\n-                if (waittime > 0) {\n-                    wait(waittime);  \/\/ Wait until one is released or removed\n-                } else {\n-                    wait();\n-                }\n-            } catch (InterruptedException e) {\n-                throw new InterruptedNamingException(\n+    void waitForAvailableConnection(long waitTime) throws InterruptedNamingException {\n+        try {\n+            d(\"get(): waiting\");\n+            connectionsAvailable.await(waitTime, TimeUnit.MILLISECONDS);\n+        } catch (InterruptedException e) {\n+            throw new InterruptedNamingException(\n@@ -159,6 +143,0 @@\n-            }\n-            \/\/ Check whether we timed out\n-            if (timeout > 0) {\n-                long now = System.currentTimeMillis();\n-                waittime = timeout - (now - start);\n-            }\n@@ -166,3 +144,0 @@\n-\n-        d(\"get(): after\");\n-        return conn;\n@@ -173,3 +148,0 @@\n-     * If none is available, create a new one if maxSize hasn't been reached.\n-     * If maxSize has been reached, return null.\n-     * Always called from a synchronized method.\n@@ -177,3 +149,8 @@\n-    private PooledConnection getOrCreateConnection(\n-        PooledConnectionFactory factory) throws NamingException {\n-\n+    PooledConnection getAvailableConnection(long timeout) throws NamingException {\n+        if (!initialized) {\n+            PooledConnection conn = createConnection(factory, timeout);\n+            if (conns.size() >= initSize) {\n+                this.initialized = true;\n+            }\n+            return conn;\n+        }\n@@ -181,1 +158,0 @@\n-        PooledConnection conn = null;\n@@ -187,2 +163,3 @@\n-            for (int i = 0; i < size; i++) {\n-                entry = conns.get(i);\n+            for (ConnectionDesc connectionDesc : conns) {\n+                PooledConnection conn;\n+                entry = connectionDesc;\n@@ -196,0 +173,2 @@\n+        return null;\n+    }\n@@ -197,3 +176,13 @@\n-        \/\/ Check if list size already at maxSize specified\n-        if (maxSize > 0 && size >= maxSize) {\n-            return null;   \/\/ List size is at limit; cannot create any more\n+    \/*\n+     * Creates a new Connection if maxSize hasn't been reached.\n+     * If maxSize has been reached, return null.\n+     * Caller must hold the ReentrantLock.\n+     *\/\n+    PooledConnection createConnection(PooledConnectionFactory factory, long timeout)\n+            throws NamingException {\n+        int size = conns.size(); \/\/ Current number of idle\/non-idle connections\n+        if (maxSize == 0 || size < maxSize) {\n+            PooledConnection conn = factory.createPooledConnection(this, timeout);\n+            td(\"Create and use \", conn, factory);\n+            conns.add(new ConnectionDesc(conn, true)); \/\/ Add new conn to pool\n+            return conn;\n@@ -202,5 +191,1 @@\n-        conn = factory.createPooledConnection(this);\n-        td(\"Create and use \", conn, factory);\n-        conns.add(new ConnectionDesc(conn, true)); \/\/ Add new conn to pool\n-\n-        return conn;\n+        return null;\n@@ -214,1 +199,1 @@\n-     *\n+     * <p>\n@@ -217,8 +202,5 @@\n-    public synchronized boolean releasePooledConnection(PooledConnection conn) {\n-        ConnectionDesc entry;\n-        int loc = conns.indexOf(entry=new ConnectionDesc(conn));\n-\n-        d(\"release(): \", conn);\n-\n-        if (loc >= 0) {\n-            \/\/ Found entry\n+    public boolean releasePooledConnection(PooledConnection conn) {\n+        lock.lock();\n+        try {\n+            ConnectionDesc entry;\n+            int loc = conns.indexOf(entry = new ConnectionDesc(conn));\n@@ -226,2 +208,1 @@\n-            if (closed || (prefSize > 0 && conns.size() > prefSize)) {\n-                \/\/ If list size exceeds prefSize, close connection\n+            d(\"release(): \", conn);\n@@ -229,2 +210,2 @@\n-                d(\"release(): closing \", conn);\n-                td(\"Close \", conn);\n+            if (loc >= 0) {\n+                \/\/ Found entry\n@@ -232,3 +213,2 @@\n-                \/\/ size must be >= 2 so don't worry about empty list\n-                conns.remove(entry);\n-                conn.closeConnection();\n+                if (closed || (prefSize > 0 && conns.size() > prefSize)) {\n+                    \/\/ If list size exceeds prefSize, close connection\n@@ -236,3 +216,2 @@\n-            } else {\n-                d(\"release(): release \", conn);\n-                td(\"Release \", conn);\n+                    d(\"release(): closing \", conn);\n+                    td(\"Close \", conn);\n@@ -240,4 +219,14 @@\n-                \/\/ Get ConnectionDesc from list to get correct state info\n-                entry = conns.get(loc);\n-                \/\/ Return connection to list, ready for reuse\n-                entry.release();\n+                    \/\/ size must be >= 2 so don't worry about empty list\n+                    conns.remove(entry);\n+                    conn.closeConnection();\n+                } else {\n+                    d(\"release(): release \", conn);\n+                    td(\"Release \", conn);\n+                    \/\/ Get ConnectionDesc from list to get correct state info\n+                    entry = conns.get(loc);\n+                    \/\/ Return connection to list, ready for reuse\n+                    entry.release();\n+                }\n+                connectionsAvailable.signalAll();\n+                d(\"release(): notify\");\n+                return true;\n@@ -245,5 +234,2 @@\n-            notifyAll();\n-            d(\"release(): notify\");\n-            return true;\n-        } else {\n-            return false;\n+        } finally {\n+            lock.unlock();\n@@ -251,0 +237,1 @@\n+        return false;\n@@ -260,1 +247,1 @@\n-     *\n+     * <p>\n@@ -263,3 +250,5 @@\n-    public synchronized boolean removePooledConnection(PooledConnection conn) {\n-        if (conns.remove(new ConnectionDesc(conn))) {\n-            d(\"remove(): \", conn);\n+    public boolean removePooledConnection(PooledConnection conn) {\n+        lock.lock();\n+        try {\n+            if (conns.remove(new ConnectionDesc(conn))) {\n+                d(\"remove(): \", conn);\n@@ -267,1 +256,1 @@\n-            notifyAll();\n+                connectionsAvailable.signalAll();\n@@ -269,2 +258,2 @@\n-            d(\"remove(): notify\");\n-            td(\"Remove \", conn);\n+                d(\"remove(): notify\");\n+                td(\"Remove \", conn);\n@@ -272,5 +261,5 @@\n-            if (conns.isEmpty()) {\n-                \/\/ Remove softref to make pool entry eligible for GC.\n-                \/\/ Once ref has been removed, it cannot be reinstated.\n-                ref = null;\n-            }\n+                if (conns.isEmpty()) {\n+                    \/\/ Remove softref to make pool entry eligible for GC.\n+                    \/\/ Once ref has been removed, it cannot be reinstated.\n+                    ref = null;\n+                }\n@@ -278,4 +267,6 @@\n-            return true;\n-        } else {\n-            d(\"remove(): not found \", conn);\n-            return false;\n+                return true;\n+            } else {\n+                d(\"remove(): not found \", conn);\n+            }\n+        } finally {\n+            lock.unlock();\n@@ -283,0 +274,1 @@\n+        return false;\n@@ -294,1 +286,2 @@\n-        synchronized(this) {\n+        lock.lock();\n+        try {\n@@ -296,0 +289,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -307,1 +302,2 @@\n-        synchronized (this) {\n+        lock.lock();\n+        try {\n@@ -313,0 +309,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -358,0 +356,23 @@\n+    boolean grabLock(long timeout) throws InterruptedNamingException {\n+        final long start = System.nanoTime();\n+        long current = start;\n+        long remaining = timeout;\n+        boolean locked = false;\n+        while (!locked && remaining > 0) {\n+            try {\n+                locked = lock.tryLock(remaining, TimeUnit.MILLISECONDS);\n+                remaining -= TimeUnit.NANOSECONDS.toMillis(current - start);\n+            } catch (InterruptedException ignore) {\n+                throw new InterruptedNamingException(\n+                        \"Interrupted while waiting for the connection pool lock\");\n+            }\n+            current = System.nanoTime();\n+            remaining -= TimeUnit.NANOSECONDS.toMillis(current - start);\n+        }\n+        return locked;\n+    }\n+\n+    void unlock() {\n+        lock.unlock();\n+    }\n+\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/pool\/Connections.java","additions":143,"deletions":122,"binary":false,"changes":265,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -38,0 +40,1 @@\n+import javax.naming.CommunicationException;\n@@ -120,0 +123,3 @@\n+        final long start = System.nanoTime();\n+        long remaining = timeout;\n+\n@@ -125,0 +131,1 @@\n+            remaining = checkRemaining(start, remaining);\n@@ -129,0 +136,25 @@\n+        Connections conns = getOrCreateConnections(factory, id);\n+        d(\"get(): size after: \", map.size());\n+        remaining = checkRemaining(start, remaining);\n+\n+        if (!conns.grabLock(remaining)) {\n+            throw new CommunicationException(\"Timed out waiting for lock\");\n+        }\n+\n+        try {\n+            remaining = checkRemaining(start, remaining);\n+            PooledConnection conn = null;\n+            while (remaining > 0 && conn == null) {\n+                conn = getOrCreatePooledConnection(factory, conns, start, remaining);\n+                \/\/ don't loop if the timeout has expired\n+                remaining = checkRemaining(start, timeout);\n+            }\n+            return conn;\n+        } finally {\n+            conns.unlock();\n+        }\n+    }\n+\n+    private Connections getOrCreateConnections(PooledConnectionFactory factory, Object id)\n+            throws NamingException {\n+\n@@ -131,16 +163,3 @@\n-            conns = getConnections(id);\n-            if (conns == null) {\n-                d(\"get(): creating new connections list for \", id);\n-\n-                \/\/ No connections for this id so create a new list\n-                conns = new Connections(id, initSize, prefSize, maxSize,\n-                    factory);\n-                ConnectionsRef connsRef = new ConnectionsRef(conns);\n-                map.put(id, connsRef);\n-\n-                \/\/ Create a weak reference to ConnectionsRef\n-                Reference<ConnectionsRef> weakRef =\n-                        new ConnectionsWeakRef(connsRef, queue);\n-\n-                \/\/ Keep the weak reference through the element of a linked list\n-                weakRefs.add(weakRef);\n+            ConnectionsRef ref = map.get(id);\n+            if (ref != null) {\n+                return ref.getConnections();\n@@ -148,1 +167,15 @@\n-            d(\"get(): size after: \", map.size());\n+\n+            d(\"get(): creating new connections list for \", id);\n+\n+            \/\/ No connections for this id so create a new list\n+            conns = new Connections(id, initSize, prefSize, maxSize,\n+                    factory, new ReentrantLock());\n+\n+            ConnectionsRef connsRef = new ConnectionsRef(conns);\n+            map.put(id, connsRef);\n+\n+            \/\/ Create a weak reference to ConnectionsRef\n+            Reference<ConnectionsRef> weakRef = new ConnectionsWeakRef(connsRef, queue);\n+\n+            \/\/ Keep the weak reference through the element of a linked list\n+            weakRefs.add(weakRef);\n@@ -150,0 +183,2 @@\n+        return conns;\n+    }\n@@ -151,1 +186,22 @@\n-        return conns.get(timeout, factory); \/\/ get one connection from list\n+    private PooledConnection getOrCreatePooledConnection(\n+            PooledConnectionFactory factory, Connections conns, long start, long timeout)\n+            throws NamingException {\n+        PooledConnection conn = conns.getAvailableConnection(timeout);\n+        if (conn != null) {\n+            return conn;\n+        }\n+        \/\/ no available cached connection\n+        \/\/ check if list size already at maxSize before creating a new one\n+        conn = conns.createConnection(factory, timeout);\n+        if (conn != null) {\n+            return conn;\n+        }\n+        \/\/ max number of connections already created,\n+        \/\/ try waiting around for one to become available\n+        if (timeout <= 0) {\n+            conns.waitForAvailableConnection();\n+        } else {\n+            long remaining = checkRemaining(start, timeout);\n+            conns.waitForAvailableConnection(remaining);\n+        }\n+        return null;\n@@ -154,3 +210,13 @@\n-    private Connections getConnections(Object id) {\n-        ConnectionsRef ref = map.get(id);\n-        return (ref != null) ? ref.getConnections() : null;\n+    \/\/ Check whether we timed out\n+    private long checkRemaining(long start, long timeout) throws CommunicationException {\n+        if (timeout > 0) {\n+            long current = System.nanoTime();\n+            long remaining = timeout - TimeUnit.NANOSECONDS.toMillis(current - start);\n+            if (remaining <= 0) {\n+                throw new CommunicationException(\n+                        \"Timeout exceeded while waiting for a connection: \" +\n+                                timeout + \"ms\");\n+            }\n+            return remaining;\n+        }\n+        return Long.MAX_VALUE;\n@@ -159,0 +225,1 @@\n+\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/pool\/Pool.java","additions":88,"deletions":21,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -47,0 +47,9 @@\n+\n+    \/**\n+     * Creates a pooled connection.\n+     * @param pcb callback responsible for removing and releasing the pooled\n+     * connection from the pool.\n+     * @param timeout the connection timeout\n+     *\/\n+    public abstract PooledConnection createPooledConnection(PoolCallback pcb, long timeout)\n+        throws NamingException;\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/pool\/PooledConnectionFactory.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -352,0 +352,3 @@\n+        if (resourceName == null) {\n+            throw new NullPointerException();\n+        }\n@@ -405,0 +408,3 @@\n+        if (resourceName == null) {\n+            throw new NullPointerException();\n+        }\n@@ -480,1 +486,1 @@\n-        if (ret.isEmpty() && resourceName != null && resourceName.charAt(0) != '\/') {\n+        if (ret.isEmpty() && resourceName.charAt(0) != '\/') {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/Init.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-            if (hmacLength != null && !\"\".equals(hmacLength)) {\n+            if (hmacLength != null && hmacLength.length() != 0) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/algorithms\/implementations\/IntegrityHmac.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-     * {@link #outputAttributes(Element, NameSpaceSymbTable, Map)},\n+     * {@link #outputAttributes(Element, NameSpaceSymbTable, Map, OutputStream)},\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/Canonicalizer20010315.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-        do {\n+        do {    \/\/NOPMD\n@@ -341,1 +341,1 @@\n-        do {\n+        do {    \/\/NOPMD\n@@ -563,1 +563,1 @@\n-        if (nsprefix != null && \"\".equals(nsprefix.getValue())) {\n+        if (nsprefix != null && nsprefix.getValue().length() == 0) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/CanonicalizerBase.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-     * {@link #outputAttributes(Element, NameSpaceSymbTable, Map)},\n+     * {@link #outputAttributes(Element, NameSpaceSymbTable, Map, OutputStream)},\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/CanonicalizerPhysical.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -351,1 +351,1 @@\n-            if (entries[i] != null && !\"\".equals(entries[i].uri)) {\n+            if (entries[i] != null && entries[i].uri.length() != 0) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/c14n\/implementations\/NameSpaceSymbTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,181 +0,0 @@\n-\/*\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n- *\/\n-\/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- *\/\n-package com.sun.org.apache.xml.internal.security.exceptions;\n-\n-import java.text.MessageFormat;\n-\n-import com.sun.org.apache.xml.internal.security.utils.Constants;\n-import com.sun.org.apache.xml.internal.security.utils.I18n;\n-\n-\/**\n- * The mother of all runtime Exceptions in this bundle. It allows exceptions to have\n- * their messages translated to the different locales.\n- *\n- * The {@code xmlsecurity_en.properties} file contains this line:\n- * <pre>\n- * xml.WrongElement = Can't create a {0} from a {1} element\n- * <\/pre>\n- *\n- * Usage in the Java source is:\n- * <pre>\n- * {\n- *    Object[] exArgs = { Constants._TAG_TRANSFORMS, \"BadElement\" };\n- *\n- *    throw new XMLSecurityException(\"xml.WrongElement\", exArgs);\n- * }\n- * <\/pre>\n- *\n- * Additionally, if another Exception has been caught, we can supply it, too\n- * <pre>\n- * try {\n- *    ...\n- * } catch (Exception oldEx) {\n- *    Object[] exArgs = { Constants._TAG_TRANSFORMS, \"BadElement\" };\n- *\n- *    throw new XMLSecurityException(\"xml.WrongElement\", exArgs, oldEx);\n- * }\n- * <\/pre>\n- *\n- *\n- *\/\n-public class XMLSecurityRuntimeException extends RuntimeException {\n-\n-    private static final long serialVersionUID = 1L;\n-\n-    \/** Field msgID *\/\n-    protected String msgID;\n-\n-    \/**\n-     * Constructor XMLSecurityRuntimeException\n-     *\n-     *\/\n-    public XMLSecurityRuntimeException() {\n-        super(\"Missing message string\");\n-\n-        this.msgID = null;\n-    }\n-\n-    \/**\n-     * Constructor XMLSecurityRuntimeException\n-     *\n-     * @param msgID\n-     *\/\n-    public XMLSecurityRuntimeException(String msgID) {\n-        super(I18n.getExceptionMessage(msgID));\n-\n-        this.msgID = msgID;\n-    }\n-\n-    \/**\n-     * Constructor XMLSecurityRuntimeException\n-     *\n-     * @param msgID\n-     * @param exArgs\n-     *\/\n-    public XMLSecurityRuntimeException(String msgID, Object[] exArgs) {\n-        super(MessageFormat.format(I18n.getExceptionMessage(msgID), exArgs));\n-\n-        this.msgID = msgID;\n-    }\n-\n-    \/**\n-     * Constructor XMLSecurityRuntimeException\n-     *\n-     * @param originalException\n-     *\/\n-    public XMLSecurityRuntimeException(Exception originalException) {\n-        super(\"Missing message ID to locate message string in resource bundle \\\"\"\n-              + Constants.exceptionMessagesResourceBundleBase\n-              + \"\\\". Original Exception was a \"\n-              + originalException.getClass().getName() + \" and message \"\n-              + originalException.getMessage(), originalException);\n-    }\n-\n-    \/**\n-     * Constructor XMLSecurityRuntimeException\n-     *\n-     * @param msgID\n-     * @param originalException\n-     *\/\n-    public XMLSecurityRuntimeException(String msgID, Exception originalException) {\n-        super(I18n.getExceptionMessage(msgID, originalException), originalException);\n-\n-        this.msgID = msgID;\n-    }\n-\n-    \/**\n-     * Constructor XMLSecurityRuntimeException\n-     *\n-     * @param msgID\n-     * @param exArgs\n-     * @param originalException\n-     *\/\n-    public XMLSecurityRuntimeException(String msgID, Object[] exArgs, Exception originalException) {\n-        super(MessageFormat.format(I18n.getExceptionMessage(msgID), exArgs), originalException);\n-\n-        this.msgID = msgID;\n-    }\n-\n-    \/**\n-     * Method getMsgID\n-     *\n-     * @return the messageId\n-     *\/\n-    public String getMsgID() {\n-        if (msgID == null) {\n-            return \"Missing message ID\";\n-        }\n-        return msgID;\n-    }\n-\n-    \/** {@inheritDoc} *\/\n-    public String toString() {\n-        String s = this.getClass().getName();\n-        String message = super.getLocalizedMessage();\n-\n-        if (message != null) {\n-            message = s + \": \" + message;\n-        } else {\n-            message = s;\n-        }\n-\n-        if (this.getCause() != null) {\n-            message = message + \"\\nOriginal Exception was \" + this.getCause().toString();\n-        }\n-\n-        return message;\n-    }\n-\n-    \/**\n-     * Method getOriginalException\n-     *\n-     * @return the original exception\n-     *\/\n-    public Exception getOriginalException() {\n-        if (this.getCause() instanceof Exception) {\n-            return (Exception)this.getCause();\n-        }\n-        return null;\n-    }\n-\n-}\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/exceptions\/XMLSecurityRuntimeException.java","additions":0,"deletions":181,"binary":false,"changes":181,"status":"deleted"},{"patch":"@@ -173,2 +173,2 @@\n-        KeyResolverSpi keyResolverSpi =\n-            (KeyResolverSpi) JavaUtils.newInstanceWithEmptyConstructor(ClassLoaderUtils.loadClass(className, KeyResolver.class));\n+        KeyResolverSpi keyResolverSpi = (KeyResolverSpi)\n+            JavaUtils.newInstanceWithEmptyConstructor(ClassLoaderUtils.loadClass(className, KeyResolver.class));\n@@ -196,2 +196,2 @@\n-            keyResolverSpi = (KeyResolverSpi) JavaUtils.newInstanceWithEmptyConstructor(\n-                    ClassLoaderUtils.loadClass(className, KeyResolver.class));\n+            keyResolverSpi = (KeyResolverSpi)\n+                JavaUtils.newInstanceWithEmptyConstructor(ClassLoaderUtils.loadClass(className, KeyResolver.class));\n@@ -256,2 +256,2 @@\n-            KeyResolverSpi keyResolverSpi = (KeyResolverSpi)JavaUtils\n-                    .newInstanceWithEmptyConstructor(ClassLoaderUtils.loadClass(className, KeyResolver.class));\n+            KeyResolverSpi keyResolverSpi = (KeyResolverSpi)\n+                JavaUtils.newInstanceWithEmptyConstructor(ClassLoaderUtils.loadClass(className, KeyResolver.class));\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/KeyResolver.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -165,0 +165,1 @@\n+        referent.setSecureValidation(secureValidation);\n@@ -184,1 +185,1 @@\n-        if (referent.containsKeyInfoReference()) {\n+        if (referent.containsKeyInfoReference() || referent.containsRetrievalMethod()) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/keys\/keyresolver\/implementations\/KeyInfoReferenceResolver.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -99,2 +99,0 @@\n-      <SignatureAlgorithm URI=\"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#ripemd160-rsa-MGF1\"\r\n-                          JAVACLASS=\"com.sun.org.apache.xml.internal.security.algorithms.implementations.SignatureBaseRSA$SignatureRSARIPEMD160MGF1\" \/>\r\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/resource\/config.xml","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+signature.Transform.XPathError = Error evaluating XPath expression\r\n@@ -199,1 +200,1 @@\n-stax.idgenerationdisablewithmultipleparts = Id generation must not be disabled when multiple parts need signing\n\\ No newline at end of file\n+stax.idgenerationdisablewithmultipleparts = Id generation must not be disabled when multiple parts need signing\r\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/resource\/xmlsecurity_en.properties","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityRuntimeException;\n@@ -144,1 +143,1 @@\n-     * method included the node and <I>all<\/I> his descendants in the output.\n+     * method included the node and <I>all<\/I> its descendants in the output.\n@@ -531,1 +530,1 @@\n-        try {\n+        try {   \/\/NOPMD\n@@ -542,1 +541,1 @@\n-    public void addNodeFilter(NodeFilter filter) {\n+    public void addNodeFilter(NodeFilter filter)  throws XMLParserException, IOException {\n@@ -544,7 +543,1 @@\n-            try {\n-                convertToNodes();\n-            } catch (Exception e) {\n-                throw new XMLSecurityRuntimeException(\n-                    \"signature.XMLSignatureInput.nodesetReference\", e\n-                );\n-            }\n+            convertToNodes();\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/signature\/XMLSignatureInput.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-        if (os == null) {\n+        if (os == null && (input.isOctetStream() || input.isElement() || input.isNodeSet())) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformC14N.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-            if (os == null) {\n+            if (os == null && (input.isOctetStream() || input.isElement() || input.isNodeSet())) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformC14NExclusive.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.io.IOException;\n@@ -27,0 +28,1 @@\n+import com.sun.org.apache.xml.internal.security.parser.XMLParserException;\n@@ -74,1 +76,5 @@\n-        input.addNodeFilter(new EnvelopedNodeFilter(signatureElement));\n+        try {\n+            input.addNodeFilter(new EnvelopedNodeFilter(signatureElement));\n+        } catch (XMLParserException | IOException ex) {\n+            throw new TransformationException(ex);\n+        }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformEnvelopedSignature.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.io.IOException;\n@@ -29,1 +30,1 @@\n-import com.sun.org.apache.xml.internal.security.exceptions.XMLSecurityRuntimeException;\n+import com.sun.org.apache.xml.internal.security.parser.XMLParserException;\n@@ -54,0 +55,3 @@\n+    private static final com.sun.org.slf4j.internal.Logger LOG =\n+            com.sun.org.slf4j.internal.LoggerFactory.getLogger(TransformXPath.class);\n+\n@@ -105,1 +109,1 @@\n-        } catch (DOMException ex) {\n+        } catch (XMLParserException | IOException | DOMException ex) {\n@@ -147,5 +151,2 @@\n-                Object[] eArgs = {currentNode};\n-                throw new XMLSecurityRuntimeException(\"signature.Transform.node\", eArgs, e);\n-            } catch (Exception e) {\n-                Object[] eArgs = {currentNode, currentNode.getNodeType()};\n-                throw new XMLSecurityRuntimeException(\"signature.Transform.nodeAndType\",eArgs, e);\n+                LOG.debug(\"Error evaluating XPath expression\", e);\n+                return 0;\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/transforms\/implementations\/TransformXPath.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+@SuppressWarnings(\"PMD\")\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/Base64.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-        if (namespaceURI == null) {\n+        if (namespaceURI == null && context != null) {\n@@ -132,1 +132,1 @@\n-        } else if (namespaceURI.equals(XML_NS_URI)) {\n+        } else if (XML_NS_URI.equals(namespaceURI)) {\n@@ -134,1 +134,1 @@\n-        } else if (namespaceURI.equals(XMLNS_ATTRIBUTE_NS_URI)) {\n+        } else if (XMLNS_ATTRIBUTE_NS_URI.equals(namespaceURI)) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/DOMNamespaceContext.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -193,3 +193,3 @@\n-            StringReader sr = new StringReader(value.substring(1, value.length() - 1));\n-            int i = 0;\n-            char c;\n+            try (StringReader sr = new StringReader(value.substring(1, value.length() - 1))) {\n+                int i = 0;\n+                char c;\n@@ -197,2 +197,2 @@\n-            while ((i = sr.read()) > -1) {\n-                c = (char) i;\n+                while ((i = sr.read()) > -1) {\n+                    c = (char) i;\n@@ -200,5 +200,5 @@\n-                \/\/the following char is defined at 4.Relationship with RFC1779 and LDAPv2 inrfc2253\n-                if (c == ',' || c == '=' || c == '+' || c == '<'\n-                    || c == '>' || c == '#' || c == ';') {\n-                    sb.append('\\\\');\n-                }\n+                    \/\/the following char is defined at 4.Relationship with RFC1779 and LDAPv2 inrfc2253\n+                    if (c == ',' || c == '=' || c == '+' || c == '<'\n+                            || c == '>' || c == '#' || c == ';') {\n+                        sb.append('\\\\');\n+                    }\n@@ -206,1 +206,2 @@\n-                sb.append(c);\n+                    sb.append(c);\n+                }\n@@ -266,1 +267,0 @@\n-        StringReader sr = new StringReader(string);\n@@ -270,15 +270,3 @@\n-        while ((i = sr.read()) > -1) {\n-            c = (char) i;\n-\n-            if (c == '\\\\') {\n-                sb.append(c);\n-\n-                char c1 = (char) sr.read();\n-                char c2 = (char) sr.read();\n-\n-                \/\/65 (A) 97 (a)\n-                if ((c1 >= 48 && c1 <= 57 || c1 >= 65 && c1 <= 70 || c1 >= 97 && c1 <= 102)\n-                    && (c2 >= 48 && c2 <= 57\n-                        || c2 >= 65 && c2 <= 70\n-                        || c2 >= 97 && c2 <= 102)) {\n-                    char ch = (char) Byte.parseByte(\"\" + c1 + c2, 16);\n+        try (StringReader sr = new StringReader(string)) {\n+            while ((i = sr.read()) > -1) {\n+                c = (char) i;\n@@ -286,1 +274,22 @@\n-                    sb.append(ch);\n+                if (c == '\\\\') {\n+                    sb.append(c);\n+\n+                    char c1 = (char) sr.read();\n+                    char c2 = (char) sr.read();\n+\n+                    \/\/65 (A) 97 (a)\n+                    if ((c1 >= 48 && c1 <= 57 || c1 >= 65 && c1 <= 70 || c1 >= 97 && c1 <= 102)\n+                            && (c2 >= 48 && c2 <= 57\n+                            || c2 >= 65 && c2 <= 70\n+                            || c2 >= 97 && c2 <= 102)) {\n+                        try {\n+                            char ch = (char) Byte.parseByte(\"\" + c1 + c2, 16);\n+\n+                            sb.append(ch);\n+                        } catch (NumberFormatException ex) {\n+                            throw new IOException(ex);\n+                        }\n+                    } else {\n+                        sb.append(c1);\n+                        sb.append(c2);\n+                    }\n@@ -288,2 +297,1 @@\n-                    sb.append(c1);\n-                    sb.append(c2);\n+                    sb.append(c);\n@@ -291,2 +299,0 @@\n-            } else {\n-                sb.append(c);\n@@ -308,1 +314,0 @@\n-        StringReader sr = new StringReader(string);\n@@ -311,6 +316,8 @@\n-        while ((i = sr.read()) > -1) {\n-            if (i < 32) {\n-                sb.append('\\\\');\n-                sb.append(Integer.toHexString(i));\n-            } else {\n-                sb.append((char) i);\n+        try (StringReader sr = new StringReader(string)) {\n+            while ((i = sr.read()) > -1) {\n+                if (i < 32) {\n+                    sb.append('\\\\');\n+                    sb.append(Integer.toHexString(i));\n+                } else {\n+                    sb.append((char) i);\n+                }\n@@ -332,1 +339,0 @@\n-        StringReader sr = new StringReader(string);\n@@ -336,2 +342,3 @@\n-        while ((i = sr.read()) > -1) {\n-            c = (char) i;\n+        try (StringReader sr = new StringReader(string)) {\n+            while ((i = sr.read()) > -1) {\n+                c = (char) i;\n@@ -339,2 +346,2 @@\n-            if (c == '\\\\') {\n-                char c1 = (char) sr.read();\n+                if (c == '\\\\') {\n+                    char c1 = (char) sr.read();\n@@ -342,2 +349,2 @@\n-                if (c1 == ' ') {\n-                    sb.append('\\\\');\n+                    if (c1 == ' ') {\n+                        sb.append('\\\\');\n@@ -345,1 +352,1 @@\n-                    String s = \"20\";\n+                        String s = \"20\";\n@@ -347,1 +354,5 @@\n-                    sb.append(s);\n+                        sb.append(s);\n+                    } else {\n+                        sb.append('\\\\');\n+                        sb.append(c1);\n+                    }\n@@ -349,2 +360,1 @@\n-                    sb.append('\\\\');\n-                    sb.append(c1);\n+                    sb.append(c);\n@@ -352,2 +362,0 @@\n-            } else {\n-                sb.append(c);\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/RFC2253Parser.java","additions":60,"deletions":52,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -584,1 +584,1 @@\n-        do {\n+        do {    \/\/NOPMD\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/XMLUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,2 +125,2 @@\n-            ResourceResolverSpi resourceResolverSpi = (ResourceResolverSpi)JavaUtils\n-                    .newInstanceWithEmptyConstructor(ClassLoaderUtils.loadClass(className, ResourceResolver.class));\n+            ResourceResolverSpi resourceResolverSpi = (ResourceResolverSpi)\n+                JavaUtils.newInstanceWithEmptyConstructor(ClassLoaderUtils.loadClass(className, ResourceResolver.class));\n@@ -162,9 +162,0 @@\n-                \/\/ Check to see whether the Resolver is allowed\n-                if (context.secureValidation\n-                    && (resolver instanceof ResolverLocalFilesystem\n-                        || resolver instanceof ResolverDirectHTTP)) {\n-                    Object[] exArgs = { resolver.getClass().getName() };\n-                    throw new ResourceResolverException(\n-                        \"signature.Reference.ForbiddenResolver\", exArgs, context.uriToResolve, context.baseUri\n-                    );\n-                }\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/resolver\/ResourceResolver.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/resolver\/ResourceResolverContext.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -222,1 +222,2 @@\n-            context.baseUri != null && context.baseUri.startsWith(\"http:\")) {\n+            context.uriToResolve.startsWith(\"https:\") ||\n+            context.baseUri != null && (context.baseUri.startsWith(\"http:\") || context.baseUri.startsWith(\"https:\"))) {\n@@ -234,1 +235,1 @@\n-        if (baseURI == null || \"\".equals(baseURI)) {\n+        if (baseURI == null || baseURI.length() == 0) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/resolver\/implementations\/ResolverDirectHTTP.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-    private static final int FILE_URI_LENGTH = \"file:\/\".length();\n-\n@@ -56,3 +54,1 @@\n-            String fileName =\n-                ResolverLocalFilesystem.translateUriToFilename(uriNew.toString());\n-            InputStream inputStream = Files.newInputStream(Paths.get(fileName));\n+            InputStream inputStream = Files.newInputStream(Paths.get(uriNew));  \/\/NOPMD\n@@ -70,35 +66,0 @@\n-    \/**\n-     * Method translateUriToFilename\n-     *\n-     * @param uri\n-     * @return the string of the filename\n-     *\/\n-    private static String translateUriToFilename(String uri) {\n-\n-        String subStr = uri.substring(FILE_URI_LENGTH);\n-\n-        if (subStr.indexOf(\"%20\") > -1) {\n-            int offset = 0;\n-            int index = 0;\n-            StringBuilder temp = new StringBuilder(subStr.length());\n-            do {\n-                index = subStr.indexOf(\"%20\",offset);\n-                if (index == -1) {\n-                    temp.append(subStr.substring(offset));\n-                } else {\n-                    temp.append(subStr.substring(offset, index));\n-                    temp.append(' ');\n-                    offset = index + 3;\n-                }\n-            } while(index != -1);\n-            subStr = temp.toString();\n-        }\n-\n-        if (subStr.charAt(1) == ':') {\n-            \/\/ we're running M$ Windows, so this works fine\n-            return subStr;\n-        }\n-        \/\/ we're running some UNIX, so we have to prepend a slash\n-        return \"\/\" + subStr;\n-    }\n-\n@@ -114,1 +75,1 @@\n-            context.uriToResolve.startsWith(\"http:\")) {\n+            context.uriToResolve.startsWith(\"http:\") || context.uriToResolve.startsWith(\"https:\")) {\n@@ -136,1 +97,1 @@\n-        if (baseURI == null || \"\".equals(baseURI)) {\n+        if (baseURI == null || baseURI.length() == 0) {\n","filename":"src\/java.xml.crypto\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/resolver\/implementations\/ResolverLocalFilesystem.java","additions":3,"deletions":42,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -242,3 +242,0 @@\n-            if (!in.isNodeSet() && !in.isElement()) {\n-                return null;\n-            }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/ApacheCanonicalizer.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -128,1 +128,5 @@\n-        outputLength = Integer.parseInt(paramsElem.getFirstChild().getNodeValue());\n+        try {\n+            outputLength = Integer.parseInt(paramsElem.getFirstChild().getNodeValue());\n+        } catch (NumberFormatException ex) {\n+            throw new MarshalException(\"Invalid output length supplied: \" + paramsElem.getFirstChild().getNodeValue());\n+        }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMHMACSignatureMethod.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -449,1 +449,1 @@\n-        try (OutputStream os = new UnsyncBufferedOutputStream(dos)) {\n+        try (OutputStream os = new UnsyncBufferedOutputStream(dos)) { \/\/NOPMD\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMReference.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-        if (parent.getLocalName().equals(\"Transforms\")) {\n+        if (\"Transforms\".equals(parent.getLocalName())) {\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMTransform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-            ResourceResolverContext resContext = new ResourceResolverContext(uriAttr, baseURI, false);\n+            ResourceResolverContext resContext = new ResourceResolverContext(uriAttr, baseURI, secVal);\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMURIDereferencer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,8 +46,7 @@\n-    \/\/ all restrictions are initialized to be unconstrained\n-    private static Set<URI> disallowedAlgs = new HashSet<>();\n-    private static int maxTrans = Integer.MAX_VALUE;\n-    private static int maxRefs = Integer.MAX_VALUE;\n-    private static Set<String> disallowedRefUriSchemes = new HashSet<>();\n-    private static Map<String, Integer> minKeyMap = new HashMap<>();\n-    private static boolean noDuplicateIds = false;\n-    private static boolean noRMLoops = false;\n+    private static Set<URI> disallowedAlgs;\n+    private static int maxTrans;\n+    private static int maxRefs;\n+    private static Set<String> disallowedRefUriSchemes;\n+    private static Map<String, Integer> minKeyMap;\n+    private static boolean noDuplicateIds;\n+    private static boolean noRMLoops;\n@@ -67,0 +66,10 @@\n+        \/\/ First initialized to be unconstrained and then parse the\n+        \/\/ security property \"jdk.xml.dsig.secureValidationPolicy\"\n+        disallowedAlgs = new HashSet<>();\n+        maxTrans = Integer.MAX_VALUE;\n+        maxRefs = Integer.MAX_VALUE;\n+        disallowedRefUriSchemes = new HashSet<>();\n+        minKeyMap = new HashMap<>();\n+        noDuplicateIds = false;\n+        noRMLoops = false;\n+\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/Policy.java","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-        Boolean value = (Boolean)xc.getProperty(name);\n+        Boolean value = (Boolean) xc.getProperty(name);\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/Utils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-        \/\/ Apache Santuario XML Security for Java, version 2.2.1\n+        \/\/ Apache Santuario XML Security for Java, version 2.3.0\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/XMLDSigRI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## Apache Santuario v2.2.1\n+## Apache Santuario v2.3.0\n","filename":"src\/java.xml.crypto\/share\/legal\/santuario.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -308,0 +308,32 @@\n+\n+    public void setProperty(String name, String value) {\n+        \/\/ property name cannot be null\n+        if (name == null) {\n+            String fmsg = XSLMessages.createXPATHMessage(\n+                    XPATHErrorResources.ER_PROPERTY_NAME_NULL,\n+                    new Object[] {CLASS_NAME,  value} );\n+            throw new NullPointerException(fmsg);\n+         }\n+\n+        \/\/ property name not recognized\n+        String fmsg = XSLMessages.createXPATHMessage(\n+                XPATHErrorResources.ER_PROPERTY_UNKNOWN,\n+                new Object[] {name, CLASS_NAME, value} );\n+        throw new IllegalArgumentException(fmsg);\n+    }\n+\n+    public String getProperty(String name) {\n+        \/\/ property name cannot be null\n+        if (name == null) {\n+            String fmsg = XSLMessages.createXPATHMessage(\n+                    XPATHErrorResources.ER_GETTING_NULL_PROPERTY,\n+                    new Object[] {CLASS_NAME} );\n+            throw new NullPointerException(fmsg);\n+        }\n+\n+        \/\/ unknown property\n+        String fmsg = XSLMessages.createXPATHMessage(\n+                XPATHErrorResources.ER_GETTING_UNKNOWN_PROPERTY,\n+                new Object[] {name, CLASS_NAME} );\n+        throw new IllegalArgumentException(fmsg);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/jaxp\/XPathFactoryImpl.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @LastModified: May 2019\n+ * @LastModified: Nov 2021\n@@ -325,0 +325,4 @@\n+  public static final String ER_PROPERTY_NAME_NULL = \"ER_PROPERTY_NAME_NULL\";\n+  public static final String ER_PROPERTY_UNKNOWN = \"ER_PROPERTY_UNKNOWN\";\n+  public static final String ER_GETTING_NULL_PROPERTY = \"ER_GETTING_NULL_PROPERTY\";\n+  public static final String ER_GETTING_UNKNOWN_PROPERTY = \"ER_GETTING_UNKNOWN_PROPERTY\";\n@@ -839,0 +843,20 @@\n+  \/** Field ER_PROPERTY_NAME_NULL                       *\/\n+\n+  { ER_PROPERTY_NAME_NULL,\n+       \"Trying to set a property with a null name: {0}#setProperty( null, {1})\"},\n+\n+  \/** Field ER_PROPERTY_UNKNOWN                       *\/\n+\n+  { ER_PROPERTY_UNKNOWN,\n+       \"Trying to set the unknown property \\\"{0}\\\":{1}#setProperty({0},{2})\"},\n+\n+  \/** Field ER_GETTING_NULL_PROPERTY                       *\/\n+\n+  { ER_GETTING_NULL_PROPERTY,\n+       \"Trying to get a property with a null name: {0}#getProperty(null)\"},\n+\n+  \/** Field ER_GETTING_NULL_PROPERTY                       *\/\n+\n+  { ER_GETTING_UNKNOWN_PROPERTY,\n+       \"Trying to get the unknown property \\\"{0}\\\":{1}#getProperty({0})\"},\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xpath\/internal\/res\/XPATHErrorResources.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * AES with GCM mode.\n+ * AES cipher in GCM mode and CHACHA20-POLY1305 cipher.\n@@ -48,6 +48,4 @@\n- * its own padding impl. In addition, NSS CKM_AES_GCM only supports single-part\n- * encryption\/decryption, thus the current impl uses PKCS#11 C_Encrypt\/C_Decrypt\n- * calls and buffers data until doFinal is called.\n- *\n- * Note that PKCS#11 standard currently only supports GCM and CCM AEAD modes.\n- * There are no provisions for other AEAD modes yet.\n+ * its own padding impl. In addition, some vendors such as NSS may not support\n+ * multi-part encryption\/decryption for AEAD cipher algorithms, thus the\n+ * current impl uses PKCS#11 C_Encrypt\/C_Decrypt calls and buffers data until\n+ * doFinal is called.\n@@ -59,2 +57,4 @@\n-    \/\/ mode constant for GCM mode\n-    private static final int MODE_GCM = 10;\n+    \/\/ supported AEAD algorithms\/transformations\n+    private enum Transformation {\n+        AES_GCM(\"AES\", \"GCM\", \"NOPADDING\", 16, 16),\n+        CHACHA20_POLY1305(\"CHACHA20\", \"NONE\", \"NOPADDING\", 12, 16);\n@@ -62,3 +62,5 @@\n-    \/\/ default constants for GCM\n-    private static final int GCM_DEFAULT_TAG_LEN = 16;\n-    private static final int GCM_DEFAULT_IV_LEN = 16;\n+        final String keyAlgo;\n+        final String mode;\n+        final String padding;\n+        final int defIvLen; \/\/ in bytes\n+        final int defTagLen; \/\/ in bytes\n@@ -66,1 +68,9 @@\n-    private static final String ALGO = \"AES\";\n+        Transformation(String keyAlgo, String mode, String padding,\n+                int defIvLen, int defTagLen) {\n+            this.keyAlgo = keyAlgo;\n+            this.mode = mode;\n+            this.padding = padding;\n+            this.defIvLen = defIvLen;\n+            this.defTagLen = defTagLen;\n+        }\n+    }\n@@ -74,2 +84,2 @@\n-    \/\/ mode, one of MODE_* above\n-    private final int blockMode;\n+    \/\/ type of this AEAD cipher, one of Transformation enum above\n+    private final Transformation type;\n@@ -77,1 +87,1 @@\n-    \/\/ acceptable key size, -1 if more than 1 key sizes are accepted\n+    \/\/ acceptable key size in bytes, -1 if more than 1 key sizes are accepted\n@@ -114,11 +124,38 @@\n-        if (algoParts.length != 3) {\n-            throw new ProviderException(\"Unsupported Transformation format: \" +\n-                    algorithm);\n-        }\n-        if (!algoParts[0].startsWith(\"AES\")) {\n-            throw new ProviderException(\"Only support AES for AEAD cipher mode\");\n-        }\n-        int index = algoParts[0].indexOf('_');\n-        if (index != -1) {\n-            \/\/ should be well-formed since we specify what we support\n-            fixedKeySize = Integer.parseInt(algoParts[0].substring(index+1)) >> 3;\n+        if (algoParts[0].startsWith(\"AES\")) {\n+            \/\/ for AES_GCM, need 3 parts\n+            if (algoParts.length != 3) {\n+                throw new AssertionError(\"Invalid Transformation format: \" +\n+                        algorithm);\n+            }\n+            int index = algoParts[0].indexOf('_');\n+            if (index != -1) {\n+                \/\/ should be well-formed since we specify what we support\n+                fixedKeySize = Integer.parseInt(algoParts[0].substring(index+1)) >> 3;\n+            } else {\n+                fixedKeySize = -1;\n+            }\n+            this.type = Transformation.AES_GCM;\n+            engineSetMode(algoParts[1]);\n+            try {\n+                engineSetPadding(algoParts[2]);\n+            } catch (NoSuchPaddingException e) {\n+                throw new NoSuchAlgorithmException();\n+            }\n+        } else if (algoParts[0].equals(\"ChaCha20-Poly1305\")) {\n+            fixedKeySize = 32;\n+            this.type = Transformation.CHACHA20_POLY1305;\n+            if (algoParts.length > 3) {\n+                throw new AssertionError(\n+                        \"Invalid Transformation format: \" + algorithm);\n+            } else {\n+                if (algoParts.length > 1) {\n+                    engineSetMode(algoParts[1]);\n+                }\n+                try {\n+                    if (algoParts.length > 2) {\n+                        engineSetPadding(algoParts[2]);\n+                    }\n+                } catch (NoSuchPaddingException e) {\n+                    throw new NoSuchAlgorithmException();\n+                }\n+            }\n@@ -126,5 +163,1 @@\n-            fixedKeySize = -1;\n-        }\n-        this.blockMode = parseMode(algoParts[1]);\n-        if (!algoParts[2].equals(\"NoPadding\")) {\n-            throw new ProviderException(\"Only NoPadding is supported for AEAD cipher mode\");\n+            throw new AssertionError(\"Unsupported transformation \" + algorithm);\n@@ -134,0 +167,1 @@\n+    @Override\n@@ -135,11 +169,1 @@\n-        \/\/ Disallow change of mode for now since currently it's explicitly\n-        \/\/ defined in transformation strings\n-        throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n-    }\n-\n-    private int parseMode(String mode) throws NoSuchAlgorithmException {\n-        mode = mode.toUpperCase(Locale.ENGLISH);\n-        int result;\n-        if (mode.equals(\"GCM\")) {\n-            result = MODE_GCM;\n-        } else {\n+        if (!mode.toUpperCase(Locale.ENGLISH).equals(type.mode)) {\n@@ -148,1 +172,0 @@\n-        return result;\n@@ -152,0 +175,1 @@\n+    @Override\n@@ -154,3 +178,3 @@\n-        \/\/ Disallow change of padding for now since currently it's explicitly\n-        \/\/ defined in transformation strings\n-        throw new NoSuchPaddingException(\"Unsupported padding \" + padding);\n+        if (!padding.toUpperCase(Locale.ENGLISH).equals(type.padding)) {\n+            throw new NoSuchPaddingException(\"Unsupported padding \" + padding);\n+        }\n@@ -160,0 +184,1 @@\n+    @Override\n@@ -161,1 +186,5 @@\n-        return 16; \/\/ constant; only AES is supported\n+        switch (type) {\n+            case AES_GCM: return 16;\n+            case CHACHA20_POLY1305: return 0;\n+            default: throw new AssertionError(\"Unsupported type \" + type);\n+        }\n@@ -165,0 +194,1 @@\n+    @Override\n@@ -170,0 +200,1 @@\n+    @Override\n@@ -176,17 +207,11 @@\n-        if (encrypt && iv == null && tagLen == -1) {\n-            switch (blockMode) {\n-                case MODE_GCM:\n-                    iv = new byte[GCM_DEFAULT_IV_LEN];\n-                    tagLen = GCM_DEFAULT_TAG_LEN;\n-                    break;\n-                default:\n-                    throw new ProviderException(\"Unsupported mode\");\n-            }\n-            random.nextBytes(iv);\n-        }\n-        try {\n-            AlgorithmParameterSpec spec;\n-            String apAlgo;\n-            switch (blockMode) {\n-                case MODE_GCM:\n-                    apAlgo = \"GCM\";\n+        String apAlgo;\n+        AlgorithmParameterSpec spec = null;\n+        switch (type) {\n+            case AES_GCM:\n+                apAlgo = \"GCM\";\n+                if (encrypt && iv == null && tagLen == -1) {\n+                    iv = new byte[type.defIvLen];\n+                    tagLen = type.defTagLen;\n+                    random.nextBytes(iv);\n+                }\n+                if (iv != null) {\n@@ -194,3 +219,25 @@\n-                    break;\n-                default:\n-                    throw new ProviderException(\"Unsupported mode\");\n+                }\n+            break;\n+            case CHACHA20_POLY1305:\n+                if (encrypt && iv == null) {\n+                    iv = new byte[type.defIvLen];\n+                    random.nextBytes(iv);\n+                }\n+                apAlgo = \"ChaCha20-Poly1305\";\n+                if (iv != null) {\n+                    spec = new IvParameterSpec(iv);\n+                }\n+            break;\n+            default:\n+                throw new AssertionError(\"Unsupported type \" + type);\n+        }\n+        if (spec != null) {\n+            try {\n+                AlgorithmParameters params =\n+                    AlgorithmParameters.getInstance(apAlgo);\n+                params.init(spec);\n+                return params;\n+            } catch (GeneralSecurityException e) {\n+                \/\/ NoSuchAlgorithmException, NoSuchProviderException\n+                \/\/ InvalidParameterSpecException\n+                throw new ProviderException(\"Could not encode parameters\", e);\n@@ -198,8 +245,0 @@\n-            AlgorithmParameters params =\n-                AlgorithmParameters.getInstance(apAlgo);\n-            params.init(spec);\n-            return params;\n-        } catch (GeneralSecurityException e) {\n-            \/\/ NoSuchAlgorithmException, NoSuchProviderException\n-            \/\/ InvalidParameterSpecException\n-            throw new ProviderException(\"Could not encode parameters\", e);\n@@ -207,0 +246,1 @@\n+        return null;\n@@ -234,6 +274,19 @@\n-        if (params != null) {\n-            switch (blockMode) {\n-            case MODE_GCM:\n-                if (!(params instanceof GCMParameterSpec)) {\n-                    throw new InvalidAlgorithmParameterException\n-                        (\"Only GCMParameterSpec is supported\");\n+        switch (type) {\n+            case AES_GCM:\n+                if (params != null) {\n+                    if (!(params instanceof GCMParameterSpec)) {\n+                        throw new InvalidAlgorithmParameterException\n+                                (\"Only GCMParameterSpec is supported\");\n+                    }\n+                    ivValue = ((GCMParameterSpec) params).getIV();\n+                    tagLen = ((GCMParameterSpec) params).getTLen() >> 3;\n+                }\n+            break;\n+            case CHACHA20_POLY1305:\n+                if (params != null) {\n+                    if (!(params instanceof IvParameterSpec)) {\n+                        throw new InvalidAlgorithmParameterException\n+                                (\"Only IvParameterSpec is supported\");\n+                    }\n+                    ivValue = ((IvParameterSpec) params).getIV();\n+                    tagLen = type.defTagLen;\n@@ -241,2 +294,0 @@\n-                ivValue = ((GCMParameterSpec) params).getIV();\n-                tagLen = ((GCMParameterSpec) params).getTLen() >> 3;\n@@ -245,3 +296,2 @@\n-                throw new ProviderException(\"Unsupported mode\");\n-            }\n-        }\n+                throw new AssertionError(\"Unsupported type \" + type);\n+        };\n@@ -263,2 +313,2 @@\n-                switch (blockMode) {\n-                    case MODE_GCM:\n+                switch (type) {\n+                    case AES_GCM:\n@@ -268,0 +318,4 @@\n+                    case CHACHA20_POLY1305:\n+                        paramSpec =\n+                            params.getParameterSpec(IvParameterSpec.class);\n+                        break;\n@@ -269,1 +323,1 @@\n-                        throw new ProviderException(\"Unsupported mode\");\n+                        throw new AssertionError(\"Unsupported type \" + type);\n@@ -288,1 +342,2 @@\n-        P11Key newKey = P11SecretKeyFactory.convertKey(token, key, ALGO);\n+        P11Key newKey = P11SecretKeyFactory.convertKey(token, key,\n+                type.keyAlgo);\n@@ -295,2 +350,2 @@\n-                    throw new InvalidAlgorithmParameterException\n-                        (\"Cannot reuse iv for GCM encryption\");\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Cannot reuse the same key and iv pair\");\n@@ -312,0 +367,1 @@\n+\n@@ -314,3 +370,8 @@\n-            switch (blockMode) {\n-                case MODE_GCM:\n-                    iv = new byte[GCM_DEFAULT_IV_LEN];\n+            switch (type) {\n+                case AES_GCM:\n+                    iv = new byte[type.defIvLen];\n+                    this.random.nextBytes(iv);\n+                    tagLen = type.defTagLen;\n+                    break;\n+                case CHACHA20_POLY1305:\n+                    iv = new byte[type.defIvLen];\n@@ -318,1 +379,1 @@\n-                    tagLen = GCM_DEFAULT_TAG_LEN;\n+                    tagLen = type.defTagLen;\n@@ -321,1 +382,1 @@\n-                    throw new ProviderException(\"Unsupported mode\");\n+                    throw new AssertionError(\"Unsupported type \" + type);\n@@ -385,1 +446,1 @@\n-                (\"Must use either different key or iv for GCM encryption\");\n+                (\"Must use either different key or iv\");\n@@ -395,2 +456,2 @@\n-            switch (blockMode) {\n-                case MODE_GCM:\n+            switch (type) {\n+                case AES_GCM:\n@@ -400,0 +461,4 @@\n+                case CHACHA20_POLY1305:\n+                    mechWithParams = new CK_MECHANISM(mechanism,\n+                        new CK_SALSA20_CHACHA20_POLY1305_PARAMS(iv, aad));\n+                    break;\n@@ -401,1 +466,1 @@\n-                    throw new ProviderException(\"Unsupported mode: \" + blockMode);\n+                    throw new AssertionError(\"Unsupported type: \" + type);\n@@ -434,2 +499,5 @@\n-            \/\/ PKCS11Exception: CKR_BUFFER_TOO_SMALL\n-            \/\/result -= tagLen;\n+            \/\/ In earlier NSS versions, AES_GCM would report\n+            \/\/ CKR_BUFFER_TOO_SMALL error if minus tagLen\n+            if (type == Transformation.CHACHA20_POLY1305) {\n+                result -= tagLen;\n+            }\n@@ -437,1 +505,1 @@\n-        return result;\n+        return (result > 0? result : 0);\n@@ -495,1 +563,1 @@\n-                (\"Must use either different key or iv for GCM encryption\");\n+                (\"Must use either different key or iv for encryption\");\n@@ -598,0 +666,1 @@\n+\n@@ -715,0 +784,1 @@\n+            inBuffer.position(inBuffer.limit());\n@@ -751,2 +821,2 @@\n-            throw (BadPaddingException)\n-                    (new BadPaddingException(e.toString()).initCause(e));\n+            throw (AEADBadTagException)\n+                    (new AEADBadTagException(e.toString()).initCause(e));\n@@ -775,1 +845,1 @@\n-                (token, key, ALGO).length();\n+                (token, key, type.keyAlgo).length();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":179,"deletions":109,"binary":false,"changes":288,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,0 +197,4 @@\n+        case (int)CKM_CHACHA20_KEY_GEN:\n+            keySize = 256;\n+            keyType = CKK_CHACHA20;\n+            break;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyGenerator.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+        addKeyType(\"ChaCha20\", CKK_CHACHA20);\n@@ -240,0 +241,4 @@\n+                case (int)CKK_CHACHA20:\n+                    keyLength = P11KeyGenerator.checkKeySize(\n+                        CKM_CHACHA20_KEY_GEN, n, token);\n+                    break;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11SecretKeyFactory.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+import com.sun.crypto.provider.ChaCha20Poly1305Parameters;\n+\n@@ -603,0 +605,2 @@\n+        d(KG,  \"ChaCha20\",      P11KeyGenerator,\n+                m(CKM_CHACHA20_KEY_GEN));\n@@ -629,0 +633,5 @@\n+        d(AGP, \"ChaCha20-Poly1305\",\n+                \"com.sun.crypto.provider.ChaCha20Poly1305Parameters\",\n+                s(\"1.2.840.113549.1.9.16.3.18\", \"OID.1.2.840.113549.1.9.16.3.18\"),\n+                m(CKM_CHACHA20_POLY1305));\n+\n@@ -645,0 +654,2 @@\n+        d(SKF, \"ChaCha20\",      P11SecretKeyFactory,\n+                m(CKM_CHACHA20_POLY1305));\n@@ -712,0 +723,4 @@\n+        d(CIP, \"ChaCha20-Poly1305\",             P11AEADCipher,\n+                s(\"1.2.840.113549.1.9.16.3.18\", \"OID.1.2.840.113549.1.9.16.3.18\"),\n+                m(CKM_CHACHA20_POLY1305));\n+\n@@ -1168,1 +1183,2 @@\n-                } else if (algorithm.endsWith(\"GCM\/NoPadding\")) {\n+                } else if (algorithm.endsWith(\"GCM\/NoPadding\") ||\n+                           algorithm.startsWith(\"ChaCha20-Poly1305\")) {\n@@ -1221,0 +1237,2 @@\n+                } else if (algorithm == \"ChaCha20-Poly1305\") {\n+                    return new ChaCha20Poly1305Parameters(); \/\/ from SunJCE\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,0 +158,5 @@\n+    public CK_MECHANISM(long mechanism,\n+            CK_SALSA20_CHACHA20_POLY1305_PARAMS params) {\n+        init(mechanism, params);\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_MECHANISM.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs11.wrapper;\n+\n+\/**\n+ * This class represents the necessary parameters required by the\n+ * CKM_CHACHA20_POLY1305 and CKM_SALSA20_POLY1305 mechanisms as defined in\n+ * CK_SALSA20_CHACHA20_POLY1305_PARAMS structure.<p>\n+ * <B>PKCS#11 structure:<\/B>\n+ * <PRE>\n+ * typedef struct CK_SALSA20_CHACHA20_POLY1305_PARAMS {\n+ *   CK_BYTE_PTR  pNonce;\n+ *   CK_ULONG     ulNonceLen;\n+ *   CK_BYTE_PTR  pAAD;\n+ *   CK_ULONG     ulAADLen;\n+ * } CK_SALSA20_CHACHA20_POLY1305_PARAMS;\n+ * <\/PRE>\n+ *\n+ * @since   17\n+ *\/\n+public class CK_SALSA20_CHACHA20_POLY1305_PARAMS {\n+\n+    private final byte[] nonce;\n+    private final byte[] aad;\n+\n+    public CK_SALSA20_CHACHA20_POLY1305_PARAMS(byte[] nonce, byte[] aad) {\n+        this.nonce = nonce;\n+        this.aad = aad;\n+    }\n+\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"Nonce: \");\n+        if (nonce == null) {\n+            sb.append(\"null\");\n+        } else {\n+            sb.append(\"0x\");\n+            for (byte b: nonce) {\n+                sb.append(String.format(\"%02x\", b));\n+            }\n+        }\n+        sb.append(Constants.NEWLINE);\n+        sb.append(Constants.INDENT);\n+        sb.append(\"AAD: \");\n+        if (aad == null) {\n+            sb.append(\"null\");\n+        } else {\n+            sb.append(\"0x\");\n+            for (byte b: aad) {\n+                sb.append(String.format(\"%02x\", b));\n+            }\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_SALSA20_CHACHA20_POLY1305_PARAMS.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1162,0 +1162,67 @@\n+\/*\n+ * converts the Java CK_SALSA20_CHACHA20_POLY1305_PARAMS object to a\n+ * CK_SALSA20_CHACHA20_POLY1305_PARAMS pointer\n+ *\n+ * @param env - used to call JNI functions to get the Java classes and objects\n+ * @param jParam - the Java CK_SALSA20_CHACHA20_POLY1305_PARAMS object to\n+ *         convert\n+ * @param pLength - length of the allocated memory of the returned pointer\n+ * @return pointer to the new CK_SALSA20_CHACHA20_POLY1305_PARAMS structure\n+ *\/\n+CK_SALSA20_CHACHA20_POLY1305_PARAMS_PTR\n+jSalsaChaChaPolyParamsToCKSalsaChaChaPolyParamPtr(\n+        JNIEnv *env, jobject jParam, CK_ULONG *pLength)\n+{\n+    CK_SALSA20_CHACHA20_POLY1305_PARAMS_PTR ckParamPtr;\n+    jclass jParamsClass;\n+    jfieldID fieldID;\n+    jobject jNonce, jAad;\n+\n+    if (pLength != NULL) {\n+        *pLength = 0;\n+    }\n+\n+    \/\/ retrieve java values\n+    jParamsClass = (*env)->FindClass(env,\n+            CLASS_SALSA20_CHACHA20_POLY1305_PARAMS);\n+    if (jParamsClass == NULL) { return NULL; }\n+    if (!(*env)->IsInstanceOf(env, jParam, jParamsClass)) {\n+        return NULL;\n+    }\n+    fieldID = (*env)->GetFieldID(env, jParamsClass, \"nonce\", \"[B\");\n+    if (fieldID == NULL) { return NULL; }\n+    jNonce = (*env)->GetObjectField(env, jParam, fieldID);\n+    fieldID = (*env)->GetFieldID(env, jParamsClass, \"aad\", \"[B\");\n+    if (fieldID == NULL) { return NULL; }\n+    jAad = (*env)->GetObjectField(env, jParam, fieldID);\n+    \/\/ allocate memory for CK_SALSA20_CHACHA20_POLY1305_PARAMS pointer\n+    ckParamPtr = calloc(1, sizeof(CK_SALSA20_CHACHA20_POLY1305_PARAMS));\n+    if (ckParamPtr == NULL) {\n+        throwOutOfMemoryError(env, 0);\n+        return NULL;\n+    }\n+\n+    \/\/ populate using java values\n+    jByteArrayToCKByteArray(env, jNonce, &(ckParamPtr->pNonce),\n+            &(ckParamPtr->ulNonceLen));\n+    if ((*env)->ExceptionCheck(env)) {\n+        goto cleanup;\n+    }\n+\n+    jByteArrayToCKByteArray(env, jAad, &(ckParamPtr->pAAD),\n+            &(ckParamPtr->ulAADLen));\n+    if ((*env)->ExceptionCheck(env)) {\n+        goto cleanup;\n+    }\n+\n+    if (pLength != NULL) {\n+        *pLength = sizeof(CK_SALSA20_CHACHA20_POLY1305_PARAMS);\n+    }\n+    return ckParamPtr;\n+cleanup:\n+    free(ckParamPtr->pNonce);\n+    free(ckParamPtr->pAAD);\n+    free(ckParamPtr);\n+    return NULL;\n+}\n+\n@@ -1440,0 +1507,5 @@\n+       case CKM_CHACHA20_POLY1305:\n+            ckpParamPtr =\n+                    jSalsaChaChaPolyParamsToCKSalsaChaChaPolyParamPtr(env,\n+                    jParam, ckpLength);\n+            break;\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_convert.c","additions":73,"deletions":1,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -326,0 +326,5 @@\n+                 case CKM_CHACHA20_POLY1305:\n+                     TRACE0(\"[ CK_SALSA20_CHACHA20_POLY1305_PARAMS ]\\n\");\n+                     free(((CK_SALSA20_CHACHA20_POLY1305_PARAMS*)tmp)->pNonce);\n+                     free(((CK_SALSA20_CHACHA20_POLY1305_PARAMS*)tmp)->pAAD);\n+                     break;\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_util.c","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -259,0 +259,2 @@\n+#define CLASS_SALSA20_CHACHA20_POLY1305_PARAMS \\\n+        \"sun\/security\/pkcs11\/wrapper\/CK_SALSA20_CHACHA20_POLY1305_PARAMS\"\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/pkcs11wrapper.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,0 @@\n-    debugMonitorEnter(classTrackLock);\n@@ -86,3 +85,1 @@\n-        \/\/ Class tracking not initialized, nobody's interested.\n-        debugMonitorExit(classTrackLock);\n-        return NULL;\n+      return NULL;\n@@ -90,0 +87,11 @@\n+\n+    \/* Allocate new bag outside classTrackLock lock to avoid deadlock.\n+     *\n+     * Note: jvmtiAllocate\/jvmtiDeallocate() may be blocked by ongoing safepoints.\n+     * It is dangerous to call them (via bagCreateBag\/bagDestroyBag()) while holding monitor(s),\n+     * because jvmti may post events, e.g. JVMTI_EVENT_OBJECT_FREE at safepoints and event processing\n+     * code may acquire the same monitor(s), e.g. classTrackLock in cbTrackingObjectFree(),\n+     * which can lead to deadlock.\n+     *\/\n+    struct bag* new_bag = bagCreateBag(sizeof(char*), 10);\n+    debugMonitorEnter(classTrackLock);\n@@ -91,1 +99,1 @@\n-    deletedSignatures = bagCreateBag(sizeof(char*), 10);\n+    deletedSignatures = new_bag;\n@@ -197,0 +205,3 @@\n+    \/\/ Allocate bag outside classTrackLock lock to avoid deadlock.\n+    \/\/ See comments in classTrack_processUnloads() for details.\n+    struct bag* new_bag = bagCreateBag(sizeof(char*), 1000);\n@@ -198,1 +209,1 @@\n-    deletedSignatures = bagCreateBag(sizeof(char*), 1000);\n+    deletedSignatures = new_bag;\n@@ -217,0 +228,3 @@\n+    struct bag* to_delete = deletedSignatures;\n+    deletedSignatures = NULL;\n+    debugMonitorExit(classTrackLock);\n@@ -218,4 +232,5 @@\n-    if (deletedSignatures != NULL) {\n-        bagEnumerateOver(deletedSignatures, cleanDeleted, NULL);\n-        bagDestroyBag(deletedSignatures);\n-        deletedSignatures = NULL;\n+    \/\/ Deallocate bag outside classTrackLock to avoid deadlock.\n+    \/\/ See comments in classTrack_processUnloads() for details.\n+    if (to_delete != NULL) {\n+      bagEnumerateOver(to_delete, cleanDeleted, NULL);\n+      bagDestroyBag(to_delete);\n@@ -223,2 +238,0 @@\n-\n-    debugMonitorExit(classTrackLock);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/classTrack.c","additions":26,"deletions":13,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -284,0 +284,1 @@\n+    JDI_ASSERT_MSG(request->methodSignature == NULL, \"Request methodSignature not null\");\n@@ -825,0 +826,4 @@\n+    JDI_ASSERT_MSG(request->methodSignature != NULL, \"methodSignature is NULL\");\n+    jvmtiDeallocate(request->methodSignature);\n+    request->methodSignature = NULL;\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/invoker.c","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-        if (containerMetrics != null) {\n+        if (containerMetrics != null && containerMetrics.getCpuSetCpus() != null) {\n","filename":"src\/jdk.management\/unix\/classes\/com\/sun\/management\/internal\/OperatingSystemImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8059550\n+ * @bug 8059550 8279356\n@@ -37,2 +37,2 @@\n- *                   -XX:-SegmentedCodeCache\n- *                   compiler.codecache.OverflowCodeCacheTest\n+ *                   -XX:-SegmentedCodeCache -Xmixed\n+ *                   compiler.codecache.OverflowCodeCacheTest CompilationDisabled\n@@ -41,1 +41,4 @@\n- *                   -XX:+SegmentedCodeCache\n+ *                   -XX:+SegmentedCodeCache -Xmixed\n+ *                   compiler.codecache.OverflowCodeCacheTest CompilationDisabled\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:-SegmentedCodeCache -Xmixed\n@@ -53,0 +56,1 @@\n+import java.lang.reflect.Method;\n@@ -56,0 +60,5 @@\n+class Helper {\n+    \/\/ Uncommon signature to prevent sharing and force creation of a new adapter\n+    public void method(float a, float b, float c, Object o) { }\n+}\n+\n@@ -58,0 +67,1 @@\n+    private static boolean COMPILATION_DISABLED = false;\n@@ -60,0 +70,1 @@\n+        COMPILATION_DISABLED = args.length > 0;\n@@ -78,0 +89,2 @@\n+        \/\/ Lock compilation to be able to better control code cache space\n+        WHITE_BOX.lockCompilation();\n@@ -92,1 +105,1 @@\n-               possibly have no free cache for futher work *\/\n+               possibly have no free cache for further work *\/\n@@ -94,0 +107,4 @@\n+\n+            \/\/ Use smallest allocation size to make sure all of the available space\n+            \/\/ is filled up. Don't free these below to put some pressure on the sweeper.\n+            while ((addr = WHITE_BOX.allocateCodeBlob(1, type.id)) != 0) { }\n@@ -95,0 +112,8 @@\n+            try {\n+                \/\/ Trigger creation of a new adapter for Helper::method\n+                \/\/ which will fail because we are out of code cache space.\n+                Helper helper = new Helper();\n+            } catch (VirtualMachineError e) {\n+                \/\/ Expected\n+            }\n+            \/\/ Free code cache space\n@@ -98,0 +123,18 @@\n+\n+            \/\/ Convert some nmethods to zombie and then free them to re-enable compilation\n+            WHITE_BOX.unlockCompilation();\n+            WHITE_BOX.forceNMethodSweep();\n+            WHITE_BOX.forceNMethodSweep();\n+\n+            \/\/ Trigger compilation of Helper::method which will hit an assert because\n+            \/\/ adapter creation failed above due to a lack of code cache space.\n+            Helper helper = new Helper();\n+            for (int i = 0; i < 100_000; i++) {\n+                helper.method(0, 0, 0, null);\n+            }\n+        }\n+        \/\/ Only check this if compilation is disabled, otherwise the sweeper might have\n+        \/\/ freed enough nmethods to allow for re-enabling compilation.\n+        if (COMPILATION_DISABLED) {\n+            Asserts.assertNotEquals(compilationActivityMode, 1 \/* run_compilation*\/,\n+                    \"Compilation must be disabled when CodeCache(CodeHeap) overflows\");\n@@ -99,2 +142,0 @@\n-        Asserts.assertNotEquals(compilationActivityMode, 1 \/* run_compilation*\/,\n-                \"Compilation must be disabled when CodeCache(CodeHeap) overflows\");\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/OverflowCodeCacheTest.java","additions":49,"deletions":8,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @modules java.base\/jdk.internal.misc\n@@ -41,3 +40,0 @@\n-        \/\/ try some sanity checks first\n-        doTest();\n-\n@@ -48,1 +44,1 @@\n-                    Launcher.class.getName());\n+                 Launcher.class.getName());\n","filename":"test\/hotspot\/jtreg\/compiler\/inlining\/InlineAccessors.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8231565\n+ * @summary Node estimate for loop rotate is not correct\/sufficient:\n+ *          assert(delta <= 2 * required) failed: Bad node estimate ...\n+ *\n+ * @requires !vm.graal.enabled\n+ *\n+ * @run main\/othervm -XX:PartialPeelNewPhiDelta=5 LoopRotateBadNodeBudget\n+ * @run main\/othervm -Xbatch -XX:PartialPeelNewPhiDelta=5 LoopRotateBadNodeBudget\n+ *\n+ * @run main\/othervm LoopRotateBadNodeBudget\n+ * @run main\/othervm -Xbatch LoopRotateBadNodeBudget\n+ *\n+ * NOTE: Test-case seldom manifesting the problem on fast machines.\n+ *\/\n+\n+public class LoopRotateBadNodeBudget {\n+\n+    int h;\n+    float j(int a, int b) {\n+        double d = 0.19881;\n+        int c, e[] = new int[9];\n+        c = 1;\n+        while (++c < 12)\n+            switch ((c % 7 * 5) + 122) {\n+                case 156:\n+                case 46128:\n+                case 135:\n+                case 148:\n+                case 127:\n+                    break;\n+                default:\n+            }\n+        while ((d += 2) < 62)\n+            ;\n+        long k = l(e);\n+        return k;\n+    }\n+    long l(int[] a) {\n+        long m = 0;\n+        for (int i = 0; i < a.length; i++)\n+            m = a[i];\n+        return m;\n+    }\n+    void f(String[] g) {\n+        int i = 2;\n+        for (; i < 20000; ++i)\n+            j(3, h);\n+    }\n+    public static void main(String[] o) {\n+        try {\n+            LoopRotateBadNodeBudget n = new LoopRotateBadNodeBudget();\n+            n.f(o);\n+        } catch (Exception ex) {\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/LoopRotateBadNodeBudget.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8229499\n+ * @summary Node estimate for loop unrolling is not correct\/sufficient:\n+ *          assert(delta <= 2 * required) failed: Bad node estimate ...\n+ *\n+ * @requires !vm.graal.enabled\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation\n+ *                   LoopUnrollBadNodeBudget\n+ *\n+ *\/\n+\n+public class LoopUnrollBadNodeBudget {\n+\n+    int a;\n+    long b;\n+    int c;\n+    int d(long e, short f, int g) {\n+        int h, j = 2, k, l[][] = new int[a][];\n+        for (h = 8; h < 58; ++h)\n+            for (k = 1; 7 > k; ++k)\n+                switch (h % 9 * 5 + 43) {\n+                    case 70:\n+                    case 65:\n+                    case 86:\n+                    case 81:\n+                    case 62:\n+                    case 69:\n+                    case 74:\n+                        g = j;\n+                }\n+        long m = u(l);\n+        return (int)m;\n+    }\n+    void n(int p, int o) { d(b, (short)0, p); }\n+    void r(String[] q) {\n+        int i = 4;\n+        n(i, c);\n+    }\n+    long u(int[][] a) {\n+        long sum = 0;\n+        return sum;\n+    }\n+    public static void main(String[] t) {\n+        try {\n+            LoopUnrollBadNodeBudget s = new LoopUnrollBadNodeBudget();\n+            for (int i = 5000; i > 0; i--)\n+                s.r(t);\n+        } catch (Exception ex) {\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/LoopUnrollBadNodeBudget.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8223502\n+ * @summary Node estimate for loop unswitching is not correct:\n+ *          assert(delta <= 2 * required) failed: Bad node estimate\n+ *\n+ * @requires !vm.graal.enabled\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation\n+ *      -XX:-UseOnStackReplacement -XX:CompileOnly=LoopUnswitchingBadNodeBudget::test\n+ *      -XX:CompileCommand=dontinline,LoopUnswitchingBadNodeBudget::helper\n+ *      -XX:+UnlockExperimentalVMOptions -XX:-UseSwitchProfiling LoopUnswitchingBadNodeBudget\n+ *\n+ *\/\n+\n+public class LoopUnswitchingBadNodeBudget {\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            for (int j = 0; j < 100; j++) {\n+                test(j, true, 0, 0, 0);\n+                test(j, false, 0, 0, 0);\n+            }\n+        }\n+    }\n+\n+    private static int test(int j, boolean flag, int k, int l, int m) {\n+        int res = 0;\n+        for (int i = 0; i < 24; i++) {\n+            if (flag) {\n+                k = k \/ 2;\n+                l = l * 2;\n+                m = m + 2;\n+            }\n+            switch (j) {\n+                case  0: break;\n+                case  1: return helper(j, k, l, m);\n+                case  2: return helper(j, k, l, m);\n+                case  3: return helper(j, k, l, m);\n+                case  4: return helper(j, k, l, m);\n+                case  5: return helper(j, k, l, m);\n+                case  6: return helper(j, k, l, m);\n+                case  7: return helper(j, k, l, m);\n+                case  8: return helper(j, k, l, m);\n+                case  9: return helper(j, k, l, m);\n+                case 10: return helper(j, k, l, m);\n+                case 11: return helper(j, k, l, m);\n+                case 12: return helper(j, k, l, m);\n+                case 13: return helper(j, k, l, m);\n+                case 14: return helper(j, k, l, m);\n+                case 15: return helper(j, k, l, m);\n+                case 16: return helper(j, k, l, m);\n+                case 17: return helper(j, k, l, m);\n+                case 18: return helper(j, k, l, m);\n+                case 19: return helper(j, k, l, m);\n+                case 20: return helper(j, k, l, m);\n+                case 21: return helper(j, k, l, m);\n+                case 22: return helper(j, k, l, m);\n+                case 23: return helper(j, k, l, m);\n+                case 24: return helper(j, k, l, m);\n+                case 25: return helper(j, k, l, m);\n+                case 26: return helper(j, k, l, m);\n+                case 27: return helper(j, k, l, m);\n+                case 28: return helper(j, k, l, m);\n+                case 29: return helper(j, k, l, m);\n+                case 30: return helper(j, k, l, m);\n+                case 31: return helper(j, k, l, m);\n+                case 32: return helper(j, k, l, m);\n+                case 33: return helper(j, k, l, m);\n+                case 34: return helper(j, k, l, m);\n+                case 35: return helper(j, k, l, m);\n+                case 36: return helper(j, k, l, m);\n+                case 37: return helper(j, k, l, m);\n+                case 38: return helper(j, k, l, m);\n+                case 39: return helper(j, k, l, m);\n+                case 40: return helper(j, k, l, m);\n+                case 41: return helper(j, k, l, m);\n+                case 42: return helper(j, k, l, m);\n+                case 43: return helper(j, k, l, m);\n+                case 44: return helper(j, k, l, m);\n+                case 45: return helper(j, k, l, m);\n+                case 46: return helper(j, k, l, m);\n+                case 47: return helper(j, k, l, m);\n+                case 48: return helper(j, k, l, m);\n+                case 49: return helper(j, k, l, m);\n+                case 50: return helper(j, k, l, m);\n+                case 51: return helper(j, k, l, m);\n+                case 52: return helper(j, k, l, m);\n+                case 53: return helper(j, k, l, m);\n+                case 54: return helper(j, k, l, m);\n+                case 55: return helper(j, k, l, m);\n+                case 56: return helper(j, k, l, m);\n+                case 57: return helper(j, k, l, m);\n+                case 58: return helper(j, k, l, m);\n+                case 59: return helper(j, k, l, m);\n+                case 60: return helper(j, k, l, m);\n+                case 61: return helper(j, k, l, m);\n+                case 62: return helper(j, k, l, m);\n+                case 63: return helper(j, k, l, m);\n+                case 64: return helper(j, k, l, m);\n+                case 65: return helper(j, k, l, m);\n+                case 66: return helper(j, k, l, m);\n+                case 67: return helper(j, k, l, m);\n+                case 68: return helper(j, k, l, m);\n+                case 69: return helper(j, k, l, m);\n+                case 70: return helper(j, k, l, m);\n+                case 71: return helper(j, k, l, m);\n+                case 72: return helper(j, k, l, m);\n+                case 73: return helper(j, k, l, m);\n+                case 74: return helper(j, k, l, m);\n+                case 75: return helper(j, k, l, m);\n+                case 76: return helper(j, k, l, m);\n+                case 77: return helper(j, k, l, m);\n+                case 78: return helper(j, k, l, m);\n+                case 79: return helper(j, k, l, m);\n+                case 80: return helper(j, k, l, m);\n+                case 81: return helper(j, k, l, m);\n+                case 82: return helper(j, k, l, m);\n+                case 83: return helper(j, k, l, m);\n+                case 84: return helper(j, k, l, m);\n+                case 85: return helper(j, k, l, m);\n+                case 86: return helper(j, k, l, m);\n+                case 87: return helper(j, k, l, m);\n+                case 88: return helper(j, k, l, m);\n+                case 89: return helper(j, k, l, m);\n+                case 90: return helper(j, k, l, m);\n+                case 91: return helper(j, k, l, m);\n+                case 92: return helper(j, k, l, m);\n+                case 93: return helper(j, k, l, m);\n+                case 94: return helper(j, k, l, m);\n+                case 95: return helper(j, k, l, m);\n+                case 96: return helper(j, k, l, m);\n+                case 97: return helper(j, k, l, m);\n+                case 98: return helper(j, k, l, m);\n+                case 99: return helper(j, k, l, m);\n+            }\n+            res += helper(j, k, l, m);\n+        }\n+        return res;\n+    }\n+\n+    private static int helper(int j, int k, int l, int m) {\n+        return j + k;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/LoopUnswitchingBadNodeBudget.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.compiler2.enabled\n+ * @bug 8279837\n+ * @summary Tests infinite loop with region head in iteration split.\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.loopopts.TestIterationSplitWithRegionHead::test\n+ *      -XX:CompileCommand=dontinline,compiler.loopopts.TestIterationSplitWithRegionHead::*\n+ *      compiler.loopopts.TestIterationSplitWithRegionHead\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestIterationSplitWithRegionHead {\n+\n+    static boolean flagFalse = false;\n+\n+    public static void main(String[] args) {\n+        test();\n+    }\n+\n+    public static void test() {\n+        \/\/ 1) The loop tree is built. We find that nested loop N2 is an infinite loop and add a NeverBranch\n+        \/\/ to the inner loop to make it reachable. But the current loop tree does not have N2, yet. The\n+        \/\/ resulting loop tree is:\n+        \/\/\n+        \/\/   Loop: N0\/N0  has_call has_sfpt\n+        \/\/     Loop: N77\/N121  has_call \/\/ N1 outer\n+        \/\/       Loop: N77\/N111  has_call sfpts={ 111 97 } \/\/ N1 inner\n+        \/\/\n+        \/\/ 2) beautify_loops() finds that the outer loop head of N1 is shared and thus adds a new region\n+        \/\/ in merge_many_backedges(). As a result, the loop tree is built again. This time, the NeverBranch\n+        \/\/ in the inner loop of N2 allows that a loop tree can be built for it:\n+        \/\/\n+        \/\/   Loop: N0\/N0  has_call has_sfpt\n+        \/\/     Loop: N216\/N213  limit_check profile_predicated predicated has_call sfpts={ 111 97 } \/\/ N1 shared loop head\n+        \/\/     Loop: N196\/N201  sfpts={ 201 } \/\/ N2 inner loop now discovered with the new NeverBranch\n+        \/\/\n+        \/\/ However, a LoopNode is only added by beautify_loops() which won't be called until the next iteration of loop opts.\n+        \/\/ This means that we have a Region node (N196) as head in the loop tree which cannot be handled by iteration_split_impl()\n+        \/\/ resulting in an assertion failure.\n+\n+        \/\/ Nested loop N1\n+        while (flagFalse) {\n+            while (dontInlineFalse()) {\n+            }\n+        }\n+        dontInlineFalse();\n+\n+        \/\/ Nested loop N2\n+        while (flagFalse) {\n+            while (true) ;  \/\/ Detected as infinite inner loop by C2 -> NeverBranch added\n+        }\n+    }\n+\n+    public static boolean dontInlineFalse() {\n+        return false;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestIterationSplitWithRegionHead.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -28,3 +28,0 @@\n- * COMMENTS\n- *     Macos_aarch64 (unlike macos_intel) doesn't let the java to create\n- *     core file with ErrorHandlerTest=12. so need to ignore this test there.\n@@ -33,1 +30,1 @@\n- * @requires vm.debug & !(os.arch == \"aarch64\" & os.family == \"mac\")\n+ * @requires vm.debug\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/TestOnError.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,2 +105,2 @@\n-        if (checked.size() != 5) {\n-          throw new RuntimeException(\"Must have 5 consecutive, fully utilized regions\");\n+        if (checked.size() != 4) {\n+          throw new RuntimeException(\"Must have 4 consecutive, fully utilized regions\");\n","filename":"test\/hotspot\/jtreg\/runtime\/SharedArchiveFile\/SpaceUtilizationCheck.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n- * @run main ThreadPriorities\n+ * @comment Use othervm mode so that we don't capture unrelated threads created by other tests\n+ * @run main\/othervm ThreadPriorities\n@@ -78,1 +79,1 @@\n-        String[] output = new OutputAnalyzer(pb.start()).getOutput().split(\"\\\\n+\");\n+        String[] output = new OutputAnalyzer(pb.start()).getOutput().split(\"\\\\R\");\n@@ -96,2 +97,14 @@\n-        assertEquals(matches, NUMBER_OF_JAVA_PRIORITIES);\n-        assertTrue(failed.isEmpty(), failed.size() + \":\" + failed);\n+        boolean success = false;\n+        try {\n+            assertEquals(matches, NUMBER_OF_JAVA_PRIORITIES);\n+            assertTrue(failed.isEmpty(), failed.size() + \":\" + failed);\n+            success = true;\n+        }\n+        finally {\n+            if (!success) {\n+                System.out.println(\"Failure detected - dumping jstack output:\");\n+                for (String line : output) {\n+                    System.out.println(line);\n+                }\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/ThreadPriorities.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -54,7 +54,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_anonclassloader_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -54,7 +54,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_anonclassloader_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -54,7 +54,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_anonclassloader_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -54,7 +54,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_anonclassloader_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level1_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level1_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level1_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level1_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level1_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level1_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level2_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level2_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level2_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level2_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level2_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level2_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level3_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level3_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level3_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level3_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level3_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level3_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level4_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level4_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level4_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level4_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level4_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_compilation_level4_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_humongous_class_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_humongous_class_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_humongous_class_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_humongous_class_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_humongous_class_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_humongous_class_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_jni_classloading_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_jni_classloading_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_jni_classloading_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_jni_classloading_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_jni_classloading_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_jni_classloading_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_global_ref_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_global_ref_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_global_ref_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_global_ref_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_global_ref_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_global_ref_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_local_ref_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_local_ref_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_local_ref_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_local_ref_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_local_ref_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_jni_local_ref_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,7 +58,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,7 +58,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,7 +58,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,7 +58,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,7 +58,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,7 +58,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_rootClass_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_stackLocal_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_stackLocal_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_stackLocal_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_stackLocal_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_stackLocal_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_stackLocal_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_staticField_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_staticField_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_staticField_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_staticField_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_staticField_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_staticField_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_strongRef_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_strongRef_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_strongRef_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_strongRef_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_strongRef_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_strongRef_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_threadItself_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_threadItself_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_threadItself_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_threadItself_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_threadItself_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_keepRef_threadItself_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_phantom_ref_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_phantom_ref_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_phantom_ref_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_phantom_ref_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_phantom_ref_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_phantom_ref_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_prot_domains_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_prot_domains_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_prot_domains_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_prot_domains_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_prot_domains_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_prot_domains_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_redefinition_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_reflection_classloading_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_reflection_classloading_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_reflection_classloading_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_reflection_classloading_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_reflection_classloading_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_reflection_classloading_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_weak_ref_inMemoryCompilation_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_weak_ref_inMemoryCompilation_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_weak_ref_inMemoryCompilation_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_weak_ref_keep_cl\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_weak_ref_keep_class\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,7 +53,0 @@\n- *      -Xbootclasspath\/a:.\n- *      -XX:+UnlockDiagnosticVMOptions\n- *      -XX:+WhiteBoxAPI\n- *      -XX:+UseG1GC\n- *      -XX:+ExplicitGCInvokesConcurrent\n- *      -Xlog:gc:gc.log\n- *      -XX:-UseGCOverheadLimit\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/gc\/g1\/unloading\/tests\/unloading_weak_ref_keep_obj\/TestDescription.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -140,4 +140,4 @@\n-            if (e.getMessage().trim().toLowerCase().contains(\"metadata\")) {\n-                System.out.println(\"Got OOME in metaspace in PerformChecksHelper.callMethods(Class clazz). \" +\n-                                \"This happened because reflection generates a too many accessors. \" +\n-                                \"There is nothing we can do with it, so we are just suppressing.\");\n+            if (e.getMessage().trim().toLowerCase().contains(\"metaspace\")) {\n+                \/\/ avoid string concatenation, which may create more classes.\n+                System.out.println(\"Got OOME in metaspace in PerformChecksHelper.callMethods(Class clazz). \");\n+                System.out.println(\"This is possible with -triggerUnloadingByFillingMetaspace\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/common\/PerformChecksHelper.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-import nsk.share.test.timeoutwatchdog.TimeoutHandler;\n-import nsk.share.test.timeoutwatchdog.TimeoutWatchdog;\n@@ -50,1 +48,1 @@\n-abstract public class StressHierarchyBaseClass extends TestBase implements TimeoutHandler {\n+abstract public class StressHierarchyBaseClass extends TestBase {\n@@ -104,1 +102,0 @@\n-            TimeoutWatchdog.watch(stresser, this);\n@@ -131,6 +128,0 @@\n-    @Override\n-    public void handleTimeout() {\n-        System.out.println(\"Shutting down vm because of time expired.\");\n-        System.exit(95);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/common\/StressHierarchyBaseClass.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- *      -XX:MaxMetaspaceSize=450m\n+ *      -XX:MaxMetaspaceSize=250m\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/metaspace\/stressHierarchy\/stressHierarchy012\/TestDescription.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- *      -XX:MaxMetaspaceSize=8m\n+ *      -XX:MaxMetaspaceSize=9m\n@@ -48,1 +48,1 @@\n- *      .\/bin\/classes\n+ *      ..\/..\/classes\/0\/vmTestbase\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ResourceExhausted\/resexhausted003\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -122,2 +122,0 @@\n-                } catch (IOException e) {\n-                        throw new TestBug(e);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/classload\/GeneratingClassLoader.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package nsk.share.test.timeoutwatchdog;\n-\n-\/**\n- * TimeoutHandler - interface to define reaction on timeout.\n- * @see TimeoutWatchdoc\n- *\/\n-public interface TimeoutHandler {\n-\n-        \/**\n-         * Invoked when watchdog detects timeout. Subclasses must implement this method to define how timeout should be handled.\n-         *\/\n-        void handleTimeout();\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/test\/timeoutwatchdog\/TimeoutHandler.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package nsk.share.test.timeoutwatchdog;\n-\n-import nsk.share.test.ExecutionController;\n-\n-\/**\n- * This class watches for ExecutionControler and notifies TimeoutHander in case of timeout.\n- *\/\n-public class TimeoutWatchdog implements Runnable {\n-\n-        private ExecutionController executionController;\n-\n-        private TimeoutHandler handler;\n-\n-        private static long CHECK_PERIOD = 1000; \/\/ In milliseconds\n-\n-        private TimeoutWatchdog(ExecutionController executionController, TimeoutHandler handler) {\n-                this.executionController = executionController;\n-                this.handler = handler;\n-        }\n-\n-        \/**\n-         * Start watching for timeout.\n-         * This method runs a new daemon thread that checks periodically if the observable test is still running.\n-         * If timeout is detected <code>handler.handleTimeout()<\/code> will be called. If the test finishes normally the daemon\n-         * thread will silently die.\n-         * @param executionController - executionController used to monitor time left\n-         * @param handler - handler on which handleTimeout() will be called\n-         *\/\n-        public static void watch(ExecutionController executionController, TimeoutHandler handler) {\n-                Thread thread = new Thread(new TimeoutWatchdog(executionController, handler));\n-                thread.setName(\"TimeoutWatchdog_thread\");\n-                thread.setDaemon(true);\n-                thread.start();\n-        }\n-\n-        @Override\n-        public void run() {\n-                try {\n-                        while (true) {\n-                                Thread.sleep(CHECK_PERIOD);\n-                                if (!executionController.continueExecution()) {\n-                                        System.out.println(\"Time expired. TimeoutWatchdog is calling TimeoutHandler.handleTimeout.\");\n-                                        handler.handleTimeout();\n-                                }\n-                        }\n-                } catch (InterruptedException e) {\n-                        throw new RuntimeException(\"Somebody dared to interrupt TimeoutWatchdog thread.\");\n-                }\n-        }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/test\/timeoutwatchdog\/TimeoutWatchdog.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.gc;\n-\n-import java.lang.management.ManagementFactory;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Random;\n-\n-import nsk.share.TestFailure;\n-import nsk.share.test.ExecutionController;\n-\n-public class TriggerUnloadingByFillingHeap implements TriggerUnloadingHelper {\n-\n-    public void triggerUnloading(ExecutionController stresser) {\n-        List<String> jvmArgs = ManagementFactory.getRuntimeMXBean().getInputArguments();\n-        if (jvmArgs.contains(\"-XX:+ExplicitGCInvokesConcurrent\")) {\n-                throw new TestFailure(\"Test bug! Found -XX:+ExplicitGCInvokesConcurrent in jvm args. TriggerUnloadingByFillingHeap.triggerUnloading will not work!.\");\n-        }\n-\n-        System.out.println(\"collections invoked: \" + provokeGC(stresser));\n-        System.out.println(\"collections invoked: \" + provokeGC(stresser));\n-        System.out.println(\"collections invoked: \" + provokeGC(stresser));\n-    }\n-\n-    private static long getGCCounter() {\n-        return ManagementFactory.getGarbageCollectorMXBeans().get(1).getCollectionCount();\n-    }\n-\n-    private static Random random = new Random();\n-\n-    public static byte[] garbage; \/\/make it reference public to avoid compiler optimizations\n-\n-    private static long provokeGC(ExecutionController stresser) {\n-        long initCounter = getGCCounter();\n-        ArrayList<byte[]> list = new ArrayList<byte[]>();\n-        while (getGCCounter() == initCounter && stresser.continueExecution()) {\n-            list.add(new byte[1024]);\n-\n-            garbage = new byte[1024];\n-            if (random.nextInt(10) % 10 < 3 && !list.isEmpty()) {\n-                list.remove(0);\n-            }\n-            System.gc();\n-        }\n-        return getGCCounter() - initCounter;\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/gc\/TriggerUnloadingByFillingHeap.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -25,5 +25,1 @@\n-import java.util.ArrayList;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-\n+import nsk.share.test.ExecutionController;\n@@ -32,1 +28,0 @@\n-import nsk.share.test.ExecutionController;\n@@ -37,29 +32,12 @@\n-    private static final int NUMBER_OF_THREADS = 30;\n-\n-    private static class FillMetaspace {\n-        private volatile boolean gotOOME = false;\n-        private ExecutionController stresser;\n-        private GeneratedClassProducer generatedClassProducer = new GeneratedClassProducer(\"metaspace.stressHierarchy.common.HumongousClass\");\n-\n-        public FillMetaspace(ExecutionController stresser) { this.stresser = stresser; }\n-\n-        private class FillMetaspaceTask implements Callable<Object> {\n-            @Override\n-            public Object call() throws Exception {\n-                while (stresser.continueExecution() && ! gotOOME) {\n-                    try {\n-                        generatedClassProducer.create(-100500); \/\/argument is not used.\n-                    } catch (OutOfMemoryError oome) {\n-                        if (!isInMetaspace(oome)) {\n-                            throw new GotWrongOOMEException(\"Got OOME in heap while gaining OOME in metaspace. Test result can't be valid.\");\n-                        }\n-                        gotOOME = true;\n-                    }\n-                }\n-                return null;\n-            }\n-        }\n-    }\n-\n-    private static boolean isInMetaspace(OutOfMemoryError error) {\n-        return error.getMessage().trim().toLowerCase().contains(\"metadata\");\n+    private volatile boolean gotOOME = false;\n+    private ExecutionController stresser;\n+    private final ThreadLocal<GeneratedClassProducer> generatedClassProducer =\n+        new ThreadLocal<GeneratedClassProducer>() {\n+          @Override\n+          protected GeneratedClassProducer initialValue() {\n+            return new GeneratedClassProducer(\"metaspace.stressHierarchy.common.HumongousClass\");\n+          }\n+        };\n+\n+    private static boolean isInMetaspace(Throwable error) {\n+        return (error.getMessage().trim().toLowerCase().contains(\"metaspace\"));\n@@ -70,7 +48,1 @@\n-        try {\n-            FillMetaspace fillMetaspace = new FillMetaspace(stresser);\n-            ArrayList<Callable<Object>> tasks = new ArrayList<Callable<Object>>(NUMBER_OF_THREADS);\n-            for (int i = 0; i < NUMBER_OF_THREADS; i++) {\n-                tasks.add(fillMetaspace.new FillMetaspaceTask());\n-            }\n-            ExecutorService executorService = Executors.newCachedThreadPool();\n+        while (stresser.continueExecution() && !gotOOME) {\n@@ -78,8 +50,6 @@\n-                executorService.invokeAll(tasks);\n-            } catch (InterruptedException e) {\n-                System.out.println(\"Process of gaining OOME in metaspace was interrupted.\");\n-                e.printStackTrace();\n-            }\n-        } catch (OutOfMemoryError e) {\n-            if (!isInMetaspace(e)) {\n-                throw new GotWrongOOMEException(\"Got OOME in heap while gaining OOME in metaspace. Test result can't be valid.\");\n+                generatedClassProducer.get().create(-100500); \/\/argument is not used.\n+            } catch (Throwable oome) {\n+                if (!isInMetaspace(oome)) {\n+                    throw new GotWrongOOMEException(\"Got OOME in heap while triggering OOME in metaspace. Test result can't be valid.\");\n+                }\n+                gotOOME = true;\n@@ -87,1 +57,0 @@\n-            return;\n@@ -90,1 +59,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/gc\/TriggerUnloadingByFillingMetaspace.java","additions":20,"deletions":52,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.vmstresser;\n-\n-public class CompileAndDeoptimize implements Runnable {\n-\n-    public static int v = 0;\n-\n-    private abstract static class A {\n-        public abstract void incv();\n-    }\n-\n-    private static class B extends A {\n-        public void incv() {\n-            v++;\n-        }\n-    }\n-\n-    public static class C extends A {\n-        public void incv() {\n-            v += (new int[1][1][1][1][1][1][1][1]).length;\n-        }\n-    }\n-\n-    private volatile boolean done = false;\n-    public volatile A a = new B();\n-\n-    private void incv() {\n-        a.incv();\n-    }\n-\n-    private void inc() {\n-        while ( ! done ) {\n-            incv();\n-        }\n-        \/\/while ( ! done ) {\n-        \/\/      incv();\n-        \/\/}\n-        \/\/while ( ! done ) {\n-        \/\/      incv();\n-        \/\/}\n-    }\n-\n-    public void run() {\n-        try {\n-            Thread t = new Thread(new Runnable() { @Override public void run() { inc(); } });\n-            t.start();\n-            Thread.sleep(100);\n-            a = (A) CompileAndDeoptimize.class.getClassLoader().loadClass(B.class.getName().replaceAll(\"B$\", \"C\")).getConstructors()[0].newInstance(new Object[0]);\n-            \/\/Thread.sleep(1000);\n-            \/\/done = true;\n-            \/\/t.join();\n-\n-        } catch ( Throwable t ) {\n-            t.printStackTrace();\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/vmstresser\/CompileAndDeoptimize.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -1,260 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package vm.share.vmstresser;\n-\n-import java.util.*;\n-import java.util.concurrent.locks.*;\n-\n-import nsk.share.*;\n-import nsk.share.classload.*;\n-import nsk.share.test.*;\n-\n-\/**\n- * Stresser that load classes until OOME, then unload some of them and continue loading.\n- *\/\n-public class MetaspaceStresser extends Thread {\n-\n-    \/**\n-     * Capacity of class containers.\n-     * This amount of classes will be unloaded on reset call.\n-     *\/\n-    public static final int DEFAULT_BUCKET_SIZE = 4000;\n-\n-    public static final int DEFAULT_PAUSE_TIME = 0;\n-\n-    \/*\n-     * Loaded classes stored in ClassContainer instances.\n-     * Such instances organized in array-based stack as it is\n-     * one of the simplest way to minimize possibility\n-     * to get OOME and guarntee that after replacing\n-     * reference to class container by null there will be\n-     * no cached refereces and container will be reclaimed by\n-     * GC and classes will become unloadable.\n-     *\/\n-    \/\/ Maximum available amount of arrays with class containers.\n-    private static final int CONTAINERS_ARRAY_LENGTH = 1000;\n-    \/\/ Maximum length array with class containers.\n-    private static final int CONTAINER_ARRAYS_COUNT = 100;\n-\n-    private ClassContainersStack containersStack = new ClassContainersStack(CONTAINER_ARRAYS_COUNT * CONTAINERS_ARRAY_LENGTH,\n-            CONTAINERS_ARRAY_LENGTH);\n-    private ClassContainer newContainer = null;\n-\n-    private ExecutionController controller = null;\n-    private int bucketSize = DEFAULT_BUCKET_SIZE;\n-    private int pauseTime = DEFAULT_PAUSE_TIME;\n-\n-    private ReentrantLock lock = new ReentrantLock();\n-\n-    \/**\n-     * Construct MetaspaceStrresser with default bucket size\n-     * and pause time.\n-     * @param c controller to control execution time.\n-     *\/\n-    public MetaspaceStresser(ExecutionController c) {\n-        controller = c;\n-    }\n-\n-    \/**\n-     * Construct MetaspaceStrresser with custom bucket size\n-     * and pause time.\n-     * @param c controller to control execution time.\n-     * @param bucketSize classes to be unloaded on reset.\n-     * @param pauseTime pause after reset.\n-     *\/\n-    public MetaspaceStresser(ExecutionController c, int bucketSize, int pauseTime) {\n-        this(c);\n-        this.bucketSize = bucketSize;\n-        this.pauseTime = pauseTime;\n-    }\n-\n-    \/**\n-     *  Fill Metaspace with classes.\n-     *  Classes will be loaded until OOME, then some of them will be unloaded.\n-     *\/\n-    public synchronized void prepare() {\n-        while (controller.continueExecution()) {\n-            try {\n-                fillContainerStack();\n-            } catch (OutOfMemoryError oome) {\n-                unloadLastClassBucket();\n-                return;\n-            } catch (ClassNotFoundException cnfe) {\n-                throw new TestBug(\"Unexpected exception in stresser.\", cnfe);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Load new class to container, fill containerStack.\n-     * Classes will be loaded until OOME\n-     * @throws ClassNotFoundException\n-     *\/\n-    private void fillContainerStack() throws ClassNotFoundException {\n-        newContainer = new ClassContainer();\n-        while (newContainer.size() < bucketSize && controller.continueExecution()) {\n-            newContainer.loadClass();\n-        }\n-        containersStack.push(newContainer);\n-        newContainer = null;\n-    }\n-\n-    \/**\n-     * Run stresser.\n-     * Stresser will load classes until OOME, then bucketSize classes\n-     * will be unloaded and stresser will wait pauseTime millisiconds\n-     * before continuing class loading.\n-     *\/\n-    public void run() {\n-        try {\n-            while (controller.continueExecution()) {\n-                try {\n-                    fillContainerStack();\n-                } catch (OutOfMemoryError oome) {\n-                    unloadLastClassBucket();\n-                    try {\n-                        Thread.sleep(pauseTime);\n-                    } catch (InterruptedException ie) {\n-                    }\n-                }\n-            }\n-        } catch (Throwable e) {\n-            throw new TestBug(\"Unexpected exception in stresser.\", e);\n-        } finally {\n-            containersStack.free();\n-        }\n-    }\n-\n-    \/**\n-     * Unload most recently loaded bucket of classes.\n-     *\/\n-    public void unloadLastClassBucket() {\n-        while (controller.continueExecution()) {\n-            try {\n-                containersStack.pop();\n-                System.gc();\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                oome.printStackTrace();\n-                continue;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Array-based stack for ClassContainer's.\n-     *\/\n-    private class ClassContainersStack {\n-\n-        private int arrayLength = 0;\n-        private int arraysCount = 0;\n-        private int arrayIndex = 0;\n-        private int elemIndex = 0;\n-\n-        private ClassContainer data[][];\n-\n-        \/**\n-         * Create ClassContainersStack that will be able\n-         * to store size classes in arrays of segmentSize length.\n-         *\/\n-        public ClassContainersStack(int size, int segementSize) {\n-            arrayLength = segementSize;\n-            arraysCount = size \/ arrayLength;\n-            data = new ClassContainer[arraysCount][];\n-            data[0] = new ClassContainer[arrayLength];\n-        }\n-\n-        \/**\n-         * Push ClassContainer c into stack.\n-         *\/\n-        public synchronized void push(ClassContainer c) {\n-            data[arrayIndex][elemIndex] = c;\n-            elemIndex++;\n-            if (elemIndex == arrayLength) {\n-                if (arrayIndex == arraysCount) {\n-                    throw new TestBug(\"ClassContainersStack ran out of available slots\");\n-                }\n-                data[arrayIndex + 1] = new ClassContainer[arrayLength];\n-                arrayIndex++;\n-                elemIndex = 0;\n-            }\n-        }\n-\n-        \/**\n-         * Remove reference to top ClassContainer.\n-         *\/\n-        public synchronized void pop() {\n-            data[arrayIndex][elemIndex] = null;\n-            if (elemIndex > 0) {\n-                elemIndex--;\n-            } else if (arrayIndex > 0) {\n-                data[arrayIndex] = null;\n-                arrayIndex--;\n-                elemIndex = arrayLength - 1;\n-            }\n-        }\n-\n-        \/**\n-         * Remove all stored ClassContainers.\n-         *\/\n-        public synchronized void free() {\n-            data = null;\n-            System.gc();\n-            data = new ClassContainer[arraysCount][];\n-            data[0] = new ClassContainer[arrayLength];\n-            arrayIndex = 0;\n-            elemIndex = 0;\n-        }\n-\n-    }\n-\n-    \/\/\/ Variable used to create uniqe name for generated classes.\n-    private static long lastClass = 0;\n-\n-    \/**\n-     * Class container consists of classes and their ClassLoader, so\n-     * if there will be no references to container and classes inside it then\n-     * it could be easely collected by GC.\n-     *\/\n-    private class ClassContainer {\n-\n-        private List<Class> classes = new LinkedList<Class>();\n-        private GeneratingClassLoader loader = new GeneratingClassLoader();\n-        private String prefix = loader.getPrefix();\n-        private int length = loader.getNameLength();\n-\n-        public void loadClass() throws ClassNotFoundException {\n-            String newName = prefix + \"c\" + lastClass;\n-            lastClass++;\n-            while (newName.length() < length) {\n-                newName = newName + \"c\";\n-            }\n-            classes.add(loader.loadClass(newName));\n-        }\n-\n-        public int size() {\n-            return classes.size();\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/share\/vmstresser\/MetaspaceStresser.java","additions":0,"deletions":260,"binary":false,"changes":260,"status":"deleted"},{"patch":"@@ -466,1 +466,0 @@\n-java\/awt\/MenuBar\/8007006\/bug8007006.java 8202886 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import jdk.test.lib.OSVersion;\n@@ -379,4 +380,1 @@\n-        return Platform.isSolaris()\n-                && Platform.getOsVersionMajor() <= 5\n-                && Platform.getOsVersionMinor() <= 11\n-                && Utils.distro().compareTo(\"11.3\") < 0;\n+        return Platform.isSolaris() && OSVersion.current().compareTo(new OSVersion(11, 3)) < 0;\n","filename":"test\/jdk\/com\/oracle\/security\/ucrypto\/TestAES.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @library \/lib\/testlibrary\n+ * @library \/test\/lib\n@@ -30,3 +30,1 @@\n- * @modules java.management\n- *          jdk.jdi\n- * @build jdk.testlibrary.* VMConnection ExclusiveBind HelloWorld\n+ * @build ExclusiveBind HelloWorld\n@@ -35,5 +33,0 @@\n-import java.net.ServerSocket;\n-import com.sun.jdi.Bootstrap;\n-import com.sun.jdi.VirtualMachine;\n-import com.sun.jdi.connect.Connector;\n-import com.sun.jdi.connect.AttachingConnector;\n@@ -41,8 +34,2 @@\n-import java.util.ArrayList;\n-import java.util.Map;\n-import java.util.List;\n-import java.util.Iterator;\n-import java.util.concurrent.TimeUnit;\n-\n-import jdk.testlibrary.ProcessTools;\n-import jdk.testlibrary.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+import lib.jdb.Debuggee;\n@@ -52,43 +39,3 @@\n-     * Find a connector by name\n-     *\/\n-    private static Connector findConnector(String name) {\n-        List connectors = Bootstrap.virtualMachineManager().allConnectors();\n-        Iterator iter = connectors.iterator();\n-        while (iter.hasNext()) {\n-            Connector connector = (Connector)iter.next();\n-            if (connector.name().equals(name)) {\n-                return connector;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    \/*\n-     * Launch (in server mode) a debuggee with the given address and\n-     * suspend mode.\n-     *\/\n-    private static ProcessBuilder prepareLauncher(String address, boolean suspend, String class_name) throws Exception {\n-        List<String> args = new ArrayList<>();\n-        for(String dbgOption : VMConnection.getDebuggeeVMOptions().split(\" \")) {\n-            if (!dbgOption.trim().isEmpty()) {\n-                args.add(dbgOption);\n-            }\n-        }\n-        String lib = \"-agentlib:jdwp=transport=dt_socket,server=y,suspend=\";\n-        if (suspend) {\n-            lib += \"y\";\n-        } else {\n-            lib += \"n\";\n-        }\n-        lib += \",address=\" + address;\n-\n-        args.add(lib);\n-        args.add(class_name);\n-\n-        return ProcessTools.createJavaProcessBuilder(args.toArray(new String[args.size()]));\n-    }\n-\n-    \/*\n-     * - pick a TCP port\n-     * - Launch a debuggee in server=y,suspend=y,address=${port}\n-     * - Launch a second debuggee in server=y,suspend=n with the same port\n+     * - Launch a debuggee with server=y,suspend=y\n+     * - Parse listening port\n+     * - Launch a second debuggee in server=y,suspend=n with the parsed port\n@@ -99,7 +46,0 @@\n-        \/\/ find a free port\n-        ServerSocket ss = new ServerSocket(0);\n-        int port = ss.getLocalPort();\n-        ss.close();\n-\n-        String address = String.valueOf(port);\n-\n@@ -107,12 +47,6 @@\n-        ProcessBuilder process1 = prepareLauncher(address, true, \"HelloWorld\");\n-        \/\/ start the debuggee and wait for the \"ready\" message\n-        Process p = ProcessTools.startProcess(\n-                \"process1\",\n-                process1,\n-                line -> line.equals(\"Listening for transport dt_socket at address: \" + address),\n-                Utils.adjustTimeout(5000),\n-                TimeUnit.MILLISECONDS\n-        );\n-\n-        \/\/ launch a second debuggee with the same address\n-        ProcessBuilder process2 = prepareLauncher(address, false, \"HelloWorld\");\n+        try (Debuggee process1 = Debuggee.launcher(\"HelloWorld\").launch(\"process1\")) {\n+            \/\/ launch a second debuggee with the same address\n+            ProcessBuilder process2 = Debuggee.launcher(\"HelloWorld\")\n+                    .setSuspended(false)\n+                    .setAddress(process1.getAddress())\n+                    .prepare();\n@@ -120,2 +54,2 @@\n-        \/\/ get exit status from second debuggee\n-        int exitCode = ProcessTools.startProcess(\"process2\", process2).waitFor();\n+            \/\/ get exit status from second debuggee\n+            int exitCode = ProcessTools.startProcess(\"process2\", process2).waitFor();\n@@ -123,14 +57,6 @@\n-        \/\/ clean-up - attach to first debuggee and resume it\n-        AttachingConnector conn = (AttachingConnector)findConnector(\"com.sun.jdi.SocketAttach\");\n-        Map conn_args = conn.defaultArguments();\n-        Connector.IntegerArgument port_arg =\n-            (Connector.IntegerArgument)conn_args.get(\"port\");\n-        port_arg.setValue(port);\n-        VirtualMachine vm = conn.attach(conn_args);\n-        vm.resume();\n-\n-        \/\/ if the second debuggee ran to completion then we've got a problem\n-        if (exitCode == 0) {\n-            throw new RuntimeException(\"Test failed - second debuggee didn't fail to bind\");\n-        } else {\n-            System.out.println(\"Test passed - second debuggee correctly failed to bind\");\n+            \/\/ if the second debuggee ran to completion then we've got a problem\n+            if (exitCode == 0) {\n+                throw new RuntimeException(\"Test failed - second debuggee didn't fail to bind\");\n+            } else {\n+                System.out.println(\"Test passed - second debuggee correctly failed to bind\");\n+            }\n","filename":"test\/jdk\/com\/sun\/jdi\/ExclusiveBind.java","additions":21,"deletions":95,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -538,3 +538,4 @@\n-                        if (name.startsWith(\"java.\") &&\n-                                       !name.startsWith(\"sun.\") &&\n-                                       !name.startsWith(\"com.\")) {\n+                        if (name.startsWith(\"java.\")\n+                            || name.startsWith(\"sun.\")\n+                            || name.startsWith(\"com.\")\n+                            || name.startsWith(\"jdk.\")) {\n","filename":"test\/jdk\/com\/sun\/jdi\/TestScaffold.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package lib.jdb;\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * Helper class to run java debuggee and parse agent listening transport\/address.\n+ * Usage:\n+ *   1)\n+ *      Debugee debugee = Debuggee.launcher(\"MyClass\").setTransport(\"dt_shmem\").launch();\n+ *      try {\n+ *          String transport = debuggee.getTransport();\n+ *          String addr = debuggee.getAddress();\n+ *      } finally {\n+ *          debuggee.shutdown();\n+ *      }\n+ *   2) (using try-with-resource)\n+ *      try (Debugee debugee = Debuggee.launcher(\"MyClass\").launch()) {\n+ *          String transport = debuggee.getTransport();\n+ *          String addr = debuggee.getAddress();\n+ *      }\n+ *   3)\n+ *      ProcessBuilder pb = Debuggee.launcher(\"MyClass\").setSuspended(false).prepare();\n+ *      ProcessTools.executeProcess(pb);\n+ *\/\n+public class Debuggee implements Closeable {\n+\n+    public static Launcher launcher(String mainClass) {\n+        return new Launcher(mainClass);\n+    }\n+\n+    public static class Launcher {\n+        private final String mainClass;\n+        private final List<String> options = new LinkedList<>();\n+        private String transport = \"dt_socket\";\n+        private String address = null;\n+        private boolean suspended = true;\n+        private boolean addTestVmAndJavaOptions = true;\n+\n+        private Launcher(String mainClass) {\n+            this.mainClass = mainClass;\n+        }\n+        public Launcher addOption(String option) {\n+            options.add(option);\n+            return this;\n+        }\n+        public Launcher addOptions(List<String> options) {\n+            this.options.addAll(options);\n+            return this;\n+        }\n+        \/\/ default is \"dt_socket\"\n+        public Launcher setTransport(String value) {\n+            transport = value;\n+            return this;\n+        }\n+        \/\/ default is \"null\" (auto-generate)\n+        public Launcher setAddress(String value) {\n+            address = value;\n+            return this;\n+        }\n+        \/\/ default is \"true\"\n+        public Launcher setSuspended(boolean value) {\n+            suspended = value;\n+            return this;\n+        }\n+        \/\/ default is \"true\"\n+        public Launcher addTestVmAndJavaOptions(boolean value) {\n+            addTestVmAndJavaOptions = value;\n+            return this;\n+        }\n+\n+        public ProcessBuilder prepare() {\n+            List<String> debuggeeArgs = new LinkedList<>();\n+            debuggeeArgs.add(\"-agentlib:jdwp=transport=\" + transport\n+                    + (address == null ? \"\" : \",address=\" + address)\n+                    + \",server=y,suspend=\" + (suspended ? \"y\" : \"n\"));\n+            debuggeeArgs.addAll(options);\n+            debuggeeArgs.add(mainClass);\n+            return ProcessTools.createJavaProcessBuilder(addTestVmAndJavaOptions,\n+                    debuggeeArgs.toArray(new String[0]));\n+        }\n+\n+        public Debuggee launch(String name) {\n+            return new Debuggee(prepare(), name);\n+        }\n+        public Debuggee launch() {\n+            return launch(\"debuggee\");\n+        }\n+    }\n+\n+    \/\/ starts the process, waits for \"Listening for transport\" output and detects transport\/address\n+    private Debuggee(ProcessBuilder pb, String name) {\n+        \/\/ debuggeeListen[0] - transport, debuggeeListen[1] - address\n+        String[] debuggeeListen = new String[2];\n+        Pattern listenRegexp = Pattern.compile(\"Listening for transport \\\\b(.+)\\\\b at address: \\\\b(.+)\\\\b\");\n+        try {\n+            p = ProcessTools.startProcess(name, pb,\n+                    s -> output.add(s),  \/\/ output consumer\n+                    s -> {  \/\/ warm-up predicate\n+                        Matcher m = listenRegexp.matcher(s);\n+                        if (!m.matches()) {\n+                            return false;\n+                        }\n+                        debuggeeListen[0] = m.group(1);\n+                        debuggeeListen[1] = m.group(2);\n+                        return true;\n+                    },\n+                    30, TimeUnit.SECONDS);\n+            transport = debuggeeListen[0];\n+            address = debuggeeListen[1];\n+        } catch (IOException | InterruptedException | TimeoutException ex) {\n+            throw new RuntimeException(\"failed to launch debuggee\", ex);\n+        }\n+    }\n+\n+    private final Process p;\n+    private final List<String> output = new LinkedList<>();\n+    private final String transport;\n+    private final String address;\n+\n+    public void shutdown() {\n+        try {\n+            close();\n+        } catch (IOException ex) {\n+            \/\/ ignore\n+        }\n+    }\n+\n+    \/\/ waits until the process shutdown or crash\n+    public boolean waitFor(long timeout, TimeUnit unit) {\n+        try {\n+            return p.waitFor(Utils.adjustTimeout(timeout), unit);\n+        } catch (InterruptedException e) {\n+            return false;\n+        }\n+    }\n+\n+    \/\/ returns the whole debuggee output as a string\n+    public String getOutput() {\n+        return output.stream().collect(Collectors.joining(Utils.NEW_LINE));\n+    }\n+\n+    String getTransport() {\n+        return transport;\n+    }\n+\n+    public String getAddress() {\n+        return address;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (p.isAlive()) {\n+            p.destroy();\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/lib\/jdb\/Debuggee.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.test.lib.Utils;\n@@ -28,1 +27,0 @@\n-import jdk.test.lib.process.ProcessTools;\n@@ -37,3 +35,0 @@\n-import java.util.concurrent.TimeoutException;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -79,2 +74,1 @@\n-    protected Process debuggee;\n-    private final List<String> debuggeeOutput = new LinkedList<>();\n+    protected Debuggee debuggee;\n@@ -90,1 +84,1 @@\n-        return debuggeeOutput.stream().collect(Collectors.joining(lineSeparator));\n+        return debuggee == null ? \"\" : debuggee.getOutput();\n@@ -109,1 +103,1 @@\n-            java -agentlib:jdwp=transport=dt_socket,address=0,server=n,suspend=y <debuggeeClass>\n+            java -agentlib:jdwp=transport=dt_socket,server=n,suspend=y <debuggeeClass>\n@@ -115,26 +109,3 @@\n-        List<String> debuggeeArgs = new LinkedList<>();\n-        \/\/ specify address=0 to automatically select free port\n-        debuggeeArgs.add(\"-agentlib:jdwp=transport=dt_socket,address=0,server=y,suspend=y\");\n-        debuggeeArgs.addAll(launchOptions.debuggeeOptions);\n-        debuggeeArgs.add(launchOptions.debuggeeClass);\n-        ProcessBuilder pbDebuggee = ProcessTools.createJavaProcessBuilder(true, debuggeeArgs.toArray(new String[0]));\n-\n-        \/\/ debuggeeListen[0] - transport, debuggeeListen[1] - address\n-        String[] debuggeeListen = new String[2];\n-        Pattern listenRegexp = Pattern.compile(\"Listening for transport \\\\b(.+)\\\\b at address: \\\\b(\\\\d+)\\\\b\");\n-        try {\n-            debuggee = ProcessTools.startProcess(\"debuggee\", pbDebuggee,\n-                    s -> debuggeeOutput.add(s),  \/\/ output consumer\n-                    s -> {  \/\/ warm-up predicate\n-                        Matcher m = listenRegexp.matcher(s);\n-                        if (!m.matches()) {\n-                            return false;\n-                        }\n-                        debuggeeListen[0] = m.group(1);\n-                        debuggeeListen[1] = m.group(2);\n-                        return true;\n-                    },\n-                    30, TimeUnit.SECONDS);\n-        } catch (IOException | InterruptedException | TimeoutException ex) {\n-            throw new RuntimeException(\"failed to launch debuggee\", ex);\n-        }\n+        debuggee = Debuggee.launcher(launchOptions.debuggeeClass)\n+                .addOptions(launchOptions.debuggeeOptions)\n+                .launch();\n@@ -144,1 +115,1 @@\n-            jdb = new Jdb(\"-connect\", \"com.sun.jdi.SocketAttach:port=\" + debuggeeListen[1]);\n+            jdb = new Jdb(\"-connect\", \"com.sun.jdi.SocketAttach:port=\" + debuggee.getAddress());\n@@ -147,1 +118,1 @@\n-            debuggee.destroy();\n+            debuggee.shutdown();\n@@ -161,9 +132,3 @@\n-        if (debuggee != null && debuggee.isAlive()) {\n-            try {\n-                debuggee.waitFor(Utils.adjustTimeout(10), TimeUnit.SECONDS);\n-            } catch (InterruptedException e) {\n-                \/\/ ignore\n-            } finally {\n-                if (debuggee.isAlive()) {\n-                    debuggee.destroy();\n-                }\n+        if (debuggee != null) {\n+            if (!debuggee.waitFor(10, TimeUnit.SECONDS)) {\n+                debuggee.shutdown();\n","filename":"test\/jdk\/com\/sun\/jdi\/lib\/jdb\/JdbTest.java","additions":11,"deletions":46,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8277795\n+ * @summary Multi-threaded client timeout tests for ldap pool\n+ * @library \/test\/lib\n+ *          lib\/\n+ * @run testng\/othervm LdapPoolTimeoutTest\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import javax.naming.Context;\n+import javax.naming.NamingException;\n+import javax.naming.directory.InitialDirContext;\n+import java.util.ArrayList;\n+import java.util.Hashtable;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.test.lib.Utils.adjustTimeout;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.expectThrows;\n+\n+public class LdapPoolTimeoutTest {\n+    \/*\n+     * Practical representation of an infinite timeout.\n+     *\/\n+    private static final long INFINITY_MILLIS = adjustTimeout(20_000);\n+    \/*\n+     * The acceptable variation in timeout measurements.\n+     *\/\n+    private static final long TOLERANCE       = adjustTimeout( 3_500);\n+\n+    private static final long CONNECT_MILLIS  = adjustTimeout( 3_000);\n+    private static final long READ_MILLIS     = adjustTimeout(10_000);\n+\n+    static {\n+        \/\/ a series of checks to make sure this timeouts configuration is\n+        \/\/ consistent and the timeouts do not overlap\n+\n+        assert (TOLERANCE >= 0);\n+        \/\/ context creation\n+        assert (2 * CONNECT_MILLIS + TOLERANCE < READ_MILLIS);\n+        \/\/ context creation immediately followed by search\n+        assert (2 * CONNECT_MILLIS + READ_MILLIS + TOLERANCE < INFINITY_MILLIS);\n+    }\n+\n+    @Test\n+    public void test() throws Exception {\n+        List<Future<?>> futures = new ArrayList<>();\n+        ExecutorService executorService = Executors.newCachedThreadPool();\n+\n+        Hashtable<Object, Object> env = new Hashtable<>();\n+        env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n+        env.put(\"com.sun.jndi.ldap.read.timeout\", String.valueOf(READ_MILLIS));\n+        env.put(\"com.sun.jndi.ldap.connect.timeout\", String.valueOf(CONNECT_MILLIS));\n+        env.put(\"com.sun.jndi.ldap.connect.pool\", \"true\");\n+        env.put(Context.PROVIDER_URL, \"ldap:\/\/example.com:1234\");\n+\n+        try {\n+            futures.add(executorService.submit(() -> { attemptConnect(env); return null; }));\n+            futures.add(executorService.submit(() -> { attemptConnect(env); return null; }));\n+            futures.add(executorService.submit(() -> { attemptConnect(env); return null; }));\n+            futures.add(executorService.submit(() -> { attemptConnect(env); return null; }));\n+            futures.add(executorService.submit(() -> { attemptConnect(env); return null; }));\n+            futures.add(executorService.submit(() -> { attemptConnect(env); return null; }));\n+            futures.add(executorService.submit(() -> { attemptConnect(env); return null; }));\n+            futures.add(executorService.submit(() -> { attemptConnect(env); return null; }));\n+        } finally {\n+            executorService.shutdown();\n+        }\n+        int failedCount = 0;\n+        for (var f : futures) {\n+            try {\n+                f.get();\n+            } catch (ExecutionException e) {\n+                failedCount++;\n+                e.getCause().printStackTrace(System.out);\n+            }\n+        }\n+        if (failedCount > 0)\n+            throw new RuntimeException(failedCount + \" (sub)tests failed\");\n+    }\n+\n+    private static void attemptConnect(Hashtable<Object, Object> env) throws Exception {\n+        try {\n+            LdapTimeoutTest.assertCompletion(CONNECT_MILLIS - 1000,\n+                   2 * CONNECT_MILLIS + TOLERANCE,\n+                   () -> new InitialDirContext(env));\n+        } catch (RuntimeException e) {\n+            String msg = e.getCause() == null ? e.getMessage() : e.getCause().getMessage();\n+            System.err.println(\"MSG RTE: \" + msg);\n+            \/\/ assertCompletion may wrap a CommunicationException in an RTE\n+            assertTrue(msg != null && msg.contains(\"Network is unreachable\"));\n+        } catch (NamingException ex) {\n+            String msg = ex.getCause() == null ? ex.getMessage() : ex.getCause().getMessage();\n+            System.err.println(\"MSG: \" + msg);\n+            assertTrue(msg != null &&\n+                    (msg.contains(\"Network is unreachable\")\n+                        || msg.contains(\"Timed out waiting for lock\")\n+                        || msg.contains(\"connect timed out\")\n+                        || msg.contains(\"Connect timed out\")\n+                        || msg.contains(\"Timeout exceeded while waiting for a connection\")));\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+}\n+\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/LdapPoolTimeoutTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+ * @library \/test\/lib\n@@ -58,1 +59,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -113,3 +114,1 @@\n-        OSInfo.OSType os = OSInfo.getOSType();\n-\n-        switch (os) {\n+        if (Platform.isLinux()) {\n@@ -120,10 +119,7 @@\n-\n-            case LINUX: {\n-                String swapSizeStr = ProcessTools.executeCommand(\"free\", \"-b\")\n-                                        .firstMatch(\"Swap:\\\\s+([0-9]+)\\\\s+.*\", 1);\n-                return Long.parseLong(swapSizeStr);\n-            }\n-            case SOLARIS: {\n-                \/\/ swapfile             dev   swaplo blocks   free\n-                \/\/ \/dev\/dsk\/c0t0d0s1   136,1      16 1638608 1600528\n-                OutputAnalyzer out= ProcessTools.executeCommand(\n+            String swapSizeStr = ProcessTools.executeCommand(\"free\", \"-b\")\n+                                             .firstMatch(\"Swap:\\\\s+([0-9]+)\\\\s+.*\", 1);\n+            return Long.parseLong(swapSizeStr);\n+        } else if (Platform.isSolaris()) {\n+            \/\/ swapfile             dev   swaplo blocks   free\n+            \/\/ \/dev\/dsk\/c0t0d0s1   136,1      16 1638608 1600528\n+            OutputAnalyzer out= ProcessTools.executeCommand(\n@@ -132,1 +128,1 @@\n-                );\n+            );\n@@ -134,1 +130,1 @@\n-                long swapSize = 0;\n+            long swapSize = 0;\n@@ -136,2 +132,2 @@\n-                for (String line : out.asLines()) {\n-                    if (line.contains(\"swapfile\")) continue;\n+            for (String line : out.asLines()) {\n+                if (line.contains(\"swapfile\")) continue;\n@@ -139,4 +135,3 @@\n-                    String[] vals = line.split(\"\\\\s+\");\n-                    if (vals.length == 5) {\n-                        swapSize += Long.parseLong(vals[3]) * 512; \/\/ size is reported in 512b blocks\n-                    }\n+                String[] vals = line.split(\"\\\\s+\");\n+                if (vals.length == 5) {\n+                    swapSize += Long.parseLong(vals[3]) * 512; \/\/ size is reported in 512b blocks\n@@ -144,2 +139,0 @@\n-\n-                return swapSize;\n@@ -147,3 +140,5 @@\n-            case MACOSX: {\n-                \/\/ total = 8192.00M used = 7471.11M free = 720.89M (encrypted)\n-                String swapSizeStr = ProcessTools.executeCommand(\n+\n+            return swapSize;\n+        } else if (Platform.isOSX()) {\n+            \/\/ total = 8192.00M used = 7471.11M free = 720.89M (encrypted)\n+            String swapSizeStr = ProcessTools.executeCommand(\n@@ -153,9 +148,4 @@\n-                ).firstMatch(\"total\\\\s+=\\\\s+([0-9]+(\\\\.[0-9]+)?[Mm]?).*\", 1);\n-                if (swapSizeStr.toLowerCase().endsWith(\"m\")) {\n-                    swapSizeStr = swapSizeStr.substring(0, swapSizeStr.length() - 1);\n-                    return (long)(Double.parseDouble(swapSizeStr) * 1024 * 1024); \/\/ size in MB\n-                }\n-                return (long)(Double.parseDouble(swapSizeStr) * 1024 * 1024);\n-            }\n-            default: {\n-                System.err.println(\"Unsupported operating system: \" + os);\n+            ).firstMatch(\"total\\\\s+=\\\\s+([0-9]+(\\\\.[0-9]+)?[Mm]?).*\", 1);\n+            if (swapSizeStr.toLowerCase().endsWith(\"m\")) {\n+                swapSizeStr = swapSizeStr.substring(0, swapSizeStr.length() - 1);\n+                return (long)(Double.parseDouble(swapSizeStr) * 1024 * 1024); \/\/ size in MB\n@@ -163,0 +153,3 @@\n+            return (long)(Double.parseDouble(swapSizeStr) * 1024 * 1024);\n+        } else {\n+            System.err.println(\"Unsupported operating system: \" + Platform.getOsName());\n","filename":"test\/jdk\/com\/sun\/management\/OperatingSystemMXBean\/TestTotalSwap.java","additions":30,"deletions":37,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import jdk.test.lib.thread.ProcessThread;\n@@ -32,1 +33,0 @@\n-import jdk.testlibrary.ProcessThread;\n@@ -48,0 +48,1 @@\n+ * @library \/test\/lib\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/BasicTests.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.test.lib.thread.ProcessThread;\n@@ -29,1 +30,0 @@\n-import jdk.testlibrary.ProcessThread;\n@@ -38,0 +38,1 @@\n+ * @library \/test\/lib\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/PermissionTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+ * @library \/test\/lib\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/ProviderTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.test.lib.thread.ProcessThread;\n@@ -31,1 +32,0 @@\n-import jdk.testlibrary.ProcessThread;\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/RunnerUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-import jdk.testlibrary.ProcessThread;\n+import jdk.test.lib.thread.ProcessThread;\n@@ -44,0 +44,1 @@\n+ * @library \/test\/lib\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/StartManagementAgent.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import jdk.test.lib.thread.ProcessThread;\n@@ -34,1 +35,0 @@\n-import jdk.testlibrary.ProcessThread;\n@@ -42,0 +42,1 @@\n+ * @library \/test\/lib\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/TempDirTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-  @library ..\/..\/..\/..\/lib\/testlibrary\n+  @library \/test\/lib\n@@ -34,1 +34,1 @@\n-  @build jdk.testlibrary.OSInfo\n+  @build jdk.test.lib.Platform\n@@ -38,0 +38,1 @@\n+import jdk.test.lib.Platform;\n@@ -39,1 +40,0 @@\n-import jdk.testlibrary.OSInfo;\n@@ -54,1 +54,1 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.WINDOWS) {\n+        if (!Platform.isWindows()) {\n","filename":"test\/jdk\/java\/awt\/Choice\/ItemStateChangeTest\/ItemStateChangeTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/awt\/Choice\/PopupPosTest\/PopupPosTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n-  @library ..\/..\/..\/..\/lib\/testlibrary\n-  @build jdk.testlibrary.OSInfo\n+  @library \/test\/lib\n+  @build jdk.test.lib.Platform\n@@ -37,1 +37,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -49,1 +49,1 @@\n-        if(OSInfo.getOSType().equals(OSInfo.OSType.MACOSX)) {\n+        if (Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/Choice\/ResizeAutoClosesChoice\/ResizeAutoClosesChoice.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,2 @@\n-import jdk.testlibrary.OSInfo;\n+\n+import jdk.test.lib.Platform;\n@@ -44,1 +45,1 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n+ * @library \/test\/lib\n@@ -46,1 +47,1 @@\n- * @build jdk.testlibrary.OSInfo\n+ * @build jdk.test.lib.Platform\n@@ -61,1 +62,1 @@\n-        if (OSInfo.getOSType().equals(OSInfo.OSType.MACOSX)) {\n+        if (Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/Cursor\/MultiResolutionCursorTest\/MultiResolutionCursorTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n+ * @library \/test\/lib\n@@ -32,1 +32,1 @@\n- * @build jdk.testlibrary.OSInfo\n+ * @build jdk.test.lib.Platform\n@@ -35,1 +35,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -40,0 +40,1 @@\n+import java.security.PrivilegedAction;\n@@ -47,1 +48,1 @@\n-        if (AccessController.doPrivileged(OSInfo.getOSTypeAction()) != OSInfo.OSType.WINDOWS) {\n+        if (!AccessController.doPrivileged((PrivilegedAction<Boolean>) Platform::isWindows)) {\n","filename":"test\/jdk\/java\/awt\/Desktop\/8064934\/bug8064934.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-   @library \/lib\/testlibrary\n-   @build jdk.testlibrary.OSInfo\n+   @library \/test\/lib\n+   @build jdk.test.lib.OSVersion jdk.test.lib.Platform\n@@ -34,1 +34,2 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.OSVersion;\n@@ -42,2 +43,2 @@\n-        if (OSInfo.getOSType() == OSInfo.OSType.WINDOWS &&\n-                OSInfo.getWindowsVersion().compareTo(OSInfo.WINDOWS_VISTA) > 0 ) {\n+        if (Platform.isWindows() &&\n+                OSVersion.current().compareTo(OSVersion.WINDOWS_VISTA) > 0 ) {\n","filename":"test\/jdk\/java\/awt\/FileDialog\/8003399\/bug8003399.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n-   @library \/lib\/testlibrary\n-   @build jdk.testlibrary.OSInfo\n+   @library \/test\/lib\n+   @build jdk.test.lib.OSVersion jdk.test.lib.Platform\n@@ -36,1 +36,2 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.OSVersion;\n@@ -46,2 +47,2 @@\n-        if (OSInfo.getOSType() == OSInfo.OSType.WINDOWS &&\n-                OSInfo.getWindowsVersion().compareTo(OSInfo.WINDOWS_VISTA) > 0 ) {\n+        if (Platform.isWindows() &&\n+                OSVersion.current().compareTo(OSVersion.WINDOWS_VISTA) > 0 ) {\n","filename":"test\/jdk\/java\/awt\/FileDialog\/8017487\/bug8017487.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-  @library ..\/..\/..\/..\/lib\/testlibrary\n+  @library \/test\/lib\n@@ -33,1 +33,1 @@\n-  @build jdk.testlibrary.OSInfo\n+  @build jdk.test.lib.Platform\n","filename":"test\/jdk\/java\/awt\/FileDialog\/FileDialogForDirectories\/FileDialogForDirectories.html","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -42,1 +42,1 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.MACOSX) {\n+        if (!Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/FileDialog\/FileDialogForDirectories\/FileDialogForDirectories.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-  @library ..\/..\/..\/..\/lib\/testlibrary\n+  @library \/test\/lib\n@@ -33,1 +33,1 @@\n-  @build jdk.testlibrary.OSInfo\n+  @build jdk.test.lib.Platform\n","filename":"test\/jdk\/java\/awt\/FileDialog\/FileDialogForPackages\/FileDialogForPackages.html","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -44,1 +44,1 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.MACOSX) {\n+        if (!Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/FileDialog\/FileDialogForPackages\/FileDialogForPackages.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -50,2 +50,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -152,1 +152,1 @@\n-        if (!OSInfo.getOSType().equals(OSInfo.OSType.MACOSX)) {\n+        if (!Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/Focus\/MouseClickRequestFocusRaceTest\/MouseClickRequestFocusRaceTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -35,1 +35,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -44,1 +44,1 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.MACOSX) {\n+        if (!Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/Frame\/MaximizedByPlatform\/MaximizedByPlatform.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,5 +27,5 @@\n-  @bug       6346690\n-  @summary   Tests that key_typed is consumed after mnemonic key_pressed is handled for a menu item.\n-  @library   ..\/..\/..\/..\/lib\/testlibrary\n-  @build jdk.testlibrary.OSInfo\n-  @run       main ConsumeNextMnemonicKeyTypedTest\n+  @bug        6346690\n+  @summary    Tests that key_typed is consumed after mnemonic key_pressed is handled for a menu item.\n+  @library    \/test\/lib\n+  @build      jdk.test.lib.Platform\n+  @run        main ConsumeNextMnemonicKeyTypedTest\n@@ -34,0 +34,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -113,1 +115,1 @@\n-        if (jdk.testlibrary.OSInfo.getOSType() == jdk.testlibrary.OSInfo.OSType.MACOSX) {\n+        if (Platform.isOSX()) {\n@@ -121,1 +123,1 @@\n-        if (jdk.testlibrary.OSInfo.getOSType() == jdk.testlibrary.OSInfo.OSType.MACOSX) {\n+        if (Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/KeyboardFocusmanager\/ConsumeNextMnemonicKeyTypedTest\/ConsumeNextMnemonicKeyTypedTest.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-  @library ..\/..\/..\/..\/..\/lib\/testlibrary\n+  @library \/test\/lib\n@@ -33,0 +33,1 @@\n+  @build jdk.test.lib.Platform\n@@ -47,0 +48,1 @@\n+import jdk.test.lib.Platform;\n@@ -48,1 +50,0 @@\n-import jdk.testlibrary.OSInfo;\n@@ -118,1 +119,1 @@\n-        boolean isMacOSX = (OSInfo.getOSType() == OSInfo.OSType.MACOSX);\n+        boolean isMacOSX = Platform.isOSX();\n","filename":"test\/jdk\/java\/awt\/KeyboardFocusmanager\/TypeAhead\/SubMenuShowTest\/SubMenuShowTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n-  @library ..\/..\/..\/..\/lib\/testlibrary\n-  @build jdk.testlibrary.OSInfo\n+  @library \/test\/lib\n+  @build jdk.test.lib.Platform\n@@ -34,0 +34,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -78,1 +80,1 @@\n-        if (jdk.testlibrary.OSInfo.getOSType() == jdk.testlibrary.OSInfo.OSType.MACOSX) {\n+        if (Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/List\/FirstItemRemoveTest\/FirstItemRemoveTest.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n-  @library ..\/..\/..\/..\/lib\/testlibrary\n-  @build jdk.testlibrary.OSInfo\n+  @library \/test\/lib\n+  @build jdk.test.lib.Platform\n@@ -45,1 +45,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -275,1 +275,1 @@\n-        if (OSInfo.getOSType() == OSInfo.OSType.WINDOWS) {\n+        if (Platform.isWindows()) {\n@@ -277,1 +277,1 @@\n-        }else if(OSInfo.getOSType() == OSInfo.OSType.MACOSX) {\n+        } else if (Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/List\/KeyEventsTest\/KeyEventsTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-  @library ..\/..\/..\/..\/lib\/testlibrary\n+  @library \/test\/lib\n@@ -33,1 +33,1 @@\n-  @build jdk.testlibrary.OSInfo\n+  @build jdk.test.lib.Platform\n@@ -41,1 +41,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -49,2 +49,1 @@\n-        if (!(OSInfo.getOSType().equals(OSInfo.OSType.LINUX)\n-                || OSInfo.getOSType().equals(OSInfo.OSType.SOLARIS))) {\n+        if (!(Platform.isLinux() || Platform.isSolaris())) {\n","filename":"test\/jdk\/java\/awt\/Menu\/OpensWithNoGrab\/OpensWithNoGrab.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires (os.family == \"mac\")\n@@ -29,3 +30,2 @@\n- * @author Leonid Romanov\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build ExtendedRobot jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -38,1 +38,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -43,0 +43,1 @@\n+    private static volatile boolean isActionPerformed;\n@@ -45,1 +46,1 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.MACOSX) {\n+        if (!Platform.isOSX()) {\n@@ -52,2 +53,2 @@\n-        ExtendedRobot robot = new ExtendedRobot();\n-        robot.setAutoDelay(50);\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(300);\n@@ -56,2 +57,1 @@\n-        robot.waitForIdle(1500);\n-\n+        robot.waitForIdle();\n@@ -59,22 +59,0 @@\n-\n-        robot.waitForIdle(1500);\n-\n-\n-        \/\/ open \"Apple\" menu (the leftmost one)\n-        robot.keyPress(KeyEvent.VK_META);\n-        robot.keyPress(KeyEvent.VK_SHIFT);\n-        robot.keyPress(KeyEvent.VK_SLASH);\n-        robot.keyRelease(KeyEvent.VK_SLASH);\n-        robot.keyRelease(KeyEvent.VK_SHIFT);\n-        robot.keyRelease(KeyEvent.VK_META);\n-\n-        \/\/ Select our menu\n-        robot.keyPress(KeyEvent.VK_LEFT);\n-        robot.keyRelease(KeyEvent.VK_LEFT);\n-\n-        \/\/ Select menu item\n-        robot.keyPress(KeyEvent.VK_DOWN);\n-        robot.keyRelease(KeyEvent.VK_DOWN);\n-        robot.keyPress(KeyEvent.VK_ENTER);\n-        robot.keyRelease(KeyEvent.VK_ENTER);\n-\n@@ -83,4 +61,1 @@\n-        MenuBar mbar = frame1.getMenuBar();\n-        Menu menu = mbar.getMenu(0);\n-        CheckboxMenuItem item = (CheckboxMenuItem)menu.getItem(0);\n-        boolean isChecked = item.getState();\n+        performMenuItemTest(robot);\n@@ -89,3 +64,2 @@\n-\n-        if (isChecked) {\n-            throw new Exception(\"Test failed: menu item remained checked\");\n+        if (!isActionPerformed) {\n+            throw new Exception(\"Test failed: menu item action was not performed\");\n@@ -109,4 +83,10 @@\n-        MenuBar mbar = new MenuBar();\n-        Menu menu = new Menu(\"Menu\");\n-        MenuItem item = new CheckboxMenuItem(\"Checked\", true);\n-\n+        \/\/ A very long name makes it more likely that the robot will hit the\n+        \/\/ menu\n+        Menu menu = new Menu(\"TestTestTestTestTestTestTestTestTestTest\");\n+        MenuItem item = new MenuItem(\"TestTestTestTestTestTestTestTestTestTest\");\n+        item.addActionListener(new ActionListener() {\n+            @Override\n+            public void actionPerformed(ActionEvent ev) {\n+                isActionPerformed = true;\n+            }\n+        });\n@@ -114,1 +94,4 @@\n-        mbar.add(menu);\n+        MenuBar mb = new MenuBar();\n+        mb.add(menu);\n+        return mb;\n+    }\n@@ -116,1 +99,18 @@\n-        return mbar;\n+    private static void performMenuItemTest(Robot robot) {\n+        \/\/ Find the menu on the screen menu bar\n+        \/\/ The location depends upon the application name which is the name\n+        \/\/ of the first menu.\n+        \/\/ Unfortunately, the application name can vary based on how the\n+        \/\/ application is run.\n+        \/\/ The work around is to make the menu and the menu item names very\n+        \/\/ long.\n+        int menuBarX = 250;\n+        int menuBarY = 11;\n+        int menuItemX = menuBarX;\n+        int menuItemY = 34;\n+        robot.mouseMove(menuBarX, menuBarY);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseMove(menuItemX, menuItemY);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.waitForIdle();\n+        waitForAction();\n@@ -119,0 +119,11 @@\n+    private static void waitForAction() {\n+        try {\n+            for (int i = 0; i < 10; i++) {\n+                if (isActionPerformed) {\n+                    return;\n+                }\n+                Thread.sleep(100);\n+            }\n+        } catch (InterruptedException ex) {\n+        }\n+    }\n","filename":"test\/jdk\/java\/awt\/MenuBar\/8007006\/bug8007006.java","additions":56,"deletions":45,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -44,2 +44,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -71,1 +71,1 @@\n-        if (OSInfo.getOSType() == OSInfo.OSType.MACOSX) {\n+        if (Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/MenuBar\/MenuBarSetFont\/MenuBarSetFont.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n-  @library ..\/..\/..\/..\/lib\/testlibrary\n-  @build jdk.testlibrary.OSInfo\n+  @library \/test\/lib\n+  @build jdk.test.lib.Platform\n@@ -35,1 +35,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -69,1 +69,1 @@\n-    private final static String SHIFT_MODIFIER = OSInfo.getOSType().equals(OSInfo.OSType.MACOSX) ?\n+    private final static String SHIFT_MODIFIER = Platform.isOSX() ?\n@@ -72,1 +72,1 @@\n-    private final static String ALT_MODIFIER = OSInfo.getOSType().equals(OSInfo.OSType.MACOSX) ?\n+    private final static String ALT_MODIFIER = Platform.isOSX() ?\n@@ -76,1 +76,1 @@\n-    private final static String CTRL_MODIFIER = OSInfo.getOSType().equals(OSInfo.OSType.MACOSX) ?\n+    private final static String CTRL_MODIFIER = Platform.isOSX() ?\n","filename":"test\/jdk\/java\/awt\/Mouse\/MouseModifiersUnitTest\/MouseModifiersUnitTest_Extra.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n-  @library ..\/..\/..\/..\/lib\/testlibrary\n-  @build jdk.testlibrary.OSInfo\n+  @library \/test\/lib\n+  @build jdk.test.lib.Platform\n@@ -43,1 +43,2 @@\n-import jdk.testlibrary.OSInfo;\n+\n+import jdk.test.lib.Platform;\n@@ -49,2 +50,1 @@\n-        OSInfo.OSType type = OSInfo.getOSType();\n-        if (type != OSInfo.OSType.LINUX && type != OSInfo.OSType.SOLARIS) {\n+        if (!Platform.isLinux() && !Platform.isSolaris()) {\n","filename":"test\/jdk\/java\/awt\/Multiscreen\/MultiScreenInsetsTest\/MultiScreenInsetsTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n-import jdk.testlibrary.OSInfo;\n+\n+import jdk.test.lib.Platform;\n@@ -35,2 +36,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -48,1 +49,1 @@\n-            int wheelSign = OSInfo.getOSType().equals(OSInfo.OSType.MACOSX) ? -1 : 1;\n+            int wheelSign = Platform.isOSX() ? -1 : 1;\n","filename":"test\/jdk\/java\/awt\/Robot\/RobotWheelTest\/RobotWheelTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n-  @library ..\/..\/..\/..\/lib\/testlibrary\n-  @build jdk.testlibrary.OSInfo\n+  @library \/test\/lib\n+  @build jdk.test.lib.Platform\n@@ -38,1 +38,0 @@\n-import jdk.testlibrary.OSInfo;\n@@ -40,0 +39,1 @@\n+import jdk.test.lib.Platform;\n@@ -137,1 +137,1 @@\n-        if (OSInfo.getOSType() == OSInfo.OSType.MACOSX) {\n+        if (Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/TextArea\/ScrollbarIntersectionTest\/ScrollbarIntersectionTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -34,0 +34,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -38,1 +40,1 @@\n-        if (jdk.testlibrary.OSInfo.getOSType() != jdk.testlibrary.OSInfo.OSType.MACOSX) {\n+        if (!Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/Toolkit\/ToolkitPropertyTest\/bug7129133.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n-   @library ..\/..\/..\/..\/lib\/testlibrary\n-   @build jdk.testlibrary.OSInfo\n+   @library \/test\/lib\n+   @build jdk.test.lib.Platform\n@@ -35,1 +35,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -44,1 +44,1 @@\n-        if (OSInfo.getOSType() == OSInfo.OSType.WINDOWS) {\n+        if (Platform.isWindows()) {\n","filename":"test\/jdk\/java\/awt\/TrayIcon\/8072769\/bug8072769.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-  @library ..\/..\/..\/..\/lib\/testlibrary\n+  @library \/test\/lib\n@@ -33,1 +33,1 @@\n-  @build jdk.testlibrary.OSInfo\n+  @build jdk.test.lib.Platform\n","filename":"test\/jdk\/java\/awt\/TrayIcon\/DblClickActionEventTest\/DblClickActionEventTest.html","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -53,1 +53,1 @@\n-            if (OSInfo.getOSType().equals(OSInfo.OSType.MACOSX)) {\n+            if (Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/TrayIcon\/DblClickActionEventTest\/DblClickActionEventTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-  @library ..\/..\/..\/..\/lib\/testlibrary\n+  @library \/test\/lib\n@@ -34,1 +34,1 @@\n-  @build jdk.testlibrary.OSInfo\n+  @build jdk.test.lib.Platform\n","filename":"test\/jdk\/java\/awt\/TrayIcon\/DisposeInActionEventTest\/DisposeInActionEventTest.html","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -62,1 +62,1 @@\n-            if (OSInfo.getOSType().equals(OSInfo.OSType.MACOSX)) {\n+            if (Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/TrayIcon\/DisposeInActionEventTest\/DisposeInActionEventTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.color.ICC_Profile;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+\n+\/**\n+ * @test\n+ * @bug 8261107\n+ * @summary Short and broken streams should be reported as unsupported\n+ *\/\n+public final class GetInstanceBrokenStream {\n+\n+    public static void main(String[] args) throws IOException {\n+        \/\/ Empty header\n+        testHeader(new byte[]{});\n+        \/\/ Short header\n+        testHeader(new byte[]{-12, 3, 45});\n+        \/\/ Broken header\n+        testHeader(new byte[]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\n+                15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n+                31, 32, 33, 34, 35, 0x61, 0x63, 0x73, 0x70});\n+    }\n+\n+    private static void testHeader(byte[] data) throws IOException {\n+        ByteArrayInputStream bais = new ByteArrayInputStream(data);\n+        try {\n+            ICC_Profile.getInstance(bais);\n+        } catch (IllegalArgumentException e) {\n+            \/\/ expected\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/GetInstanceBrokenStream.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n+ * @library \/test\/lib\n@@ -34,1 +34,1 @@\n- * @build jdk.testlibrary.OSInfo\n+ * @build jdk.test.lib.Platform\n@@ -38,0 +38,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -50,1 +52,1 @@\n-        if (jdk.testlibrary.OSInfo.getOSType() != jdk.testlibrary.OSInfo.OSType.WINDOWS) {\n+        if (!Platform.isWindows()) {\n","filename":"test\/jdk\/java\/awt\/datatransfer\/HTMLDataFlavors\/HTMLDataFlavorTest.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import jdk.test.lib.Platform;\n@@ -33,1 +34,0 @@\n-import jdk.testlibrary.OSInfo;\n@@ -44,1 +44,1 @@\n-    @library ..\/..\/..\/..\/lib\/testlibrary\n+    @library \/test\/lib\n@@ -47,1 +47,1 @@\n-    @build jdk.testlibrary.OSInfo\n+    @build jdk.test.lib.Platform\n@@ -53,2 +53,1 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.MACOSX\n-                && OSInfo.getOSType() != OSInfo.OSType.WINDOWS) {\n+        if (!Platform.isOSX() && !Platform.isWindows()) {\n","filename":"test\/jdk\/java\/awt\/datatransfer\/MissedHtmlAndRtfBug\/MissedHtmlAndRtfBug.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n+ * @library \/test\/lib\n@@ -32,1 +32,1 @@\n- * @build jdk.testlibrary.OSInfo ProcessResults ProcessCommunicator\n+ * @build jdk.test.lib.Platform ProcessResults ProcessCommunicator\n@@ -37,0 +37,1 @@\n+import jdk.test.lib.Platform;\n@@ -39,1 +40,0 @@\n-import jdk.testlibrary.OSInfo;\n@@ -191,2 +191,1 @@\n-        if (OSInfo.OSType.WINDOWS.equals(OSInfo.getOSType()) &&\n-            !ln.contains(\"METAFILEPICT\"))\n+        if (Platform.isWindows() &&  !ln.contains(\"METAFILEPICT\"))\n","filename":"test\/jdk\/java\/awt\/dnd\/ImageTransferTest\/ImageTransferTest.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @library ..\/..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -38,1 +38,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -50,1 +50,1 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.MACOSX) {\n+        if (!Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/event\/KeyEvent\/8020209\/bug8020209.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @library ..\/..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -40,1 +40,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -48,1 +48,1 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.MACOSX) {\n+        if (!Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/event\/KeyEvent\/DeadKey\/DeadKeyMacOSXInputText.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @library ..\/..\/..\/..\/..\/lib\/testlibrary\n- * @build  jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build  jdk.test.lib.Platform\n@@ -39,1 +39,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -47,1 +47,1 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.MACOSX) {\n+        if (!Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/event\/KeyEvent\/DeadKey\/deadKeyMacOSX.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-  @library ..\/..\/..\/..\/..\/lib\/testlibrary\n+  @library \/test\/lib\n@@ -33,1 +33,1 @@\n-  @build jdk.testlibrary.OSInfo\n+  @build jdk.test.lib.Platform\n@@ -38,1 +38,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -57,1 +57,1 @@\n-        if (OSInfo.getOSType() == OSInfo.OSType.WINDOWS) {\n+        if (Platform.isWindows()) {\n","filename":"test\/jdk\/java\/awt\/event\/KeyEvent\/SwallowKeyEvents\/SwallowKeyEvents.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n-import jdk.testlibrary.OSInfo;\n+\n+import jdk.test.lib.Platform;\n@@ -35,2 +36,2 @@\n- * @library \/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -44,1 +45,1 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.MACOSX) {\n+        if (!Platform.isOSX()) {\n","filename":"test\/jdk\/java\/awt\/image\/MultiResolutionImage\/NSImageToMultiResolutionImageTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n-  @library \/lib\/testlibrary\n-  @build jdk.testlibrary.OSInfo\n+  @library \/test\/lib\n+  @build jdk.test.lib.Platform\n@@ -41,1 +41,0 @@\n-import jdk.testlibrary.OSInfo;\n@@ -43,0 +42,1 @@\n+import jdk.test.lib.Platform;\n@@ -53,3 +53,1 @@\n-        OSInfo.OSType os = OSInfo.getOSType();\n-        return (os.equals(OSInfo.OSType.WINDOWS) ||\n-            os.equals(OSInfo.OSType.MACOSX));\n+        return Platform.isWindows() || Platform.isOSX();\n","filename":"test\/jdk\/java\/awt\/image\/multiresolution\/MultiDisplayTest\/MultiDisplayTest.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8275703\n+ * @library \/test\/lib\n+ * @requires os.family == \"mac\"\n+ * @run main\/native\/othervm -Djava.library.path=\/usr\/lib LibraryFromCache blas\n+ * @run main\/native\/othervm -Djava.library.path=\/usr\/lib LibraryFromCache BLAS\n+ * @summary Test System::loadLibrary to be able to load a library even\n+ *          if it's not present on the filesystem on macOS which supports\n+ *          dynamic library cache\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public class LibraryFromCache {\n+    public static void main(String[] args) throws IOException {\n+        String libname = args[0];\n+        if (!systemHasLibrary(libname)) {\n+            System.out.println(\"Test skipped. Library \" + libname + \" not found\");\n+            return;\n+        }\n+\n+        System.loadLibrary(libname);\n+    }\n+\n+    \/*\n+     * Returns true if dlopen successfully loads the specified library\n+     *\/\n+    private static boolean systemHasLibrary(String libname) throws IOException {\n+        Path launcher = Paths.get(System.getProperty(\"test.nativepath\"), \"LibraryCache\");\n+        ProcessBuilder pb = new ProcessBuilder(launcher.toString(), \"lib\" + libname + \".dylib\");\n+        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(pb.start());\n+        System.out.println(outputAnalyzer.getOutput());\n+        return outputAnalyzer.getExitValue() == 0;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/loadLibrary\/exeLibraryCache\/LibraryFromCache.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <dlfcn.h>\n+\n+int main(int argc, char** argv)\n+{\n+    void *handle;\n+\n+    if (argc != 2) {\n+        fprintf(stderr, \"Usage: %s <lib_filename_or_full_path>\\n\", argv[0]);\n+        return EXIT_FAILURE;\n+    }\n+\n+    printf(\"Attempting to load library '%s'...\\n\", argv[1]);\n+\n+    handle = dlopen(argv[1], RTLD_LAZY);\n+\n+    if (handle == NULL) {\n+       fprintf(stderr, \"Unable to load library!\\n\");\n+       return EXIT_FAILURE;\n+    }\n+\n+    printf(\"Library successfully loaded!\\n\");\n+\n+    return dlclose(handle);\n+}\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/loadLibrary\/exeLibraryCache\/exeLibraryCache.c","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,2 @@\n-import java.net.InetAddress;\n+import java.io.PrintStream;\n+import java.io.UncheckedIOException;\n@@ -29,1 +30,0 @@\n-import java.util.Enumeration;\n@@ -31,0 +31,1 @@\n+import java.util.stream.Collectors;\n@@ -32,0 +33,1 @@\n+import jdk.test.lib.NetworkConfiguration;\n@@ -37,1 +39,3 @@\n- *\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.NetworkConfiguration\n+ * @run main\/othervm UniqueMacAddressesTest\n@@ -41,0 +45,12 @@\n+    static PrintStream log = System.err;\n+\n+    \/\/ A record pair (NetworkInterface::name,  NetworkInterface::hardwareAddress)\n+    class NetIfPair {\n+        String interfaceName;\n+        byte[] address;\n+        public NetIfPair(String name, byte[] adr) {\n+            interfaceName = name;\n+            address = adr;\n+        }\n+    }\n+\n@@ -43,1 +59,1 @@\n-        System.out.println(\"UniqueMacAddressesTest: OK\");\n+        log.println(\"UniqueMacAddressesTest: OK\");\n@@ -47,1 +63,1 @@\n-        System.out.println(\"UniqueMacAddressesTest: start \");\n+        log.println(\"UniqueMacAddressesTest: start\");\n@@ -51,10 +67,4 @@\n-        Enumeration<NetworkInterface> networkInterfaces;\n-        boolean areMacAddressesUnique = false;\n-        List<NetworkInterface> networkInterfaceList = new ArrayList<NetworkInterface>();\n-            networkInterfaces = NetworkInterface.getNetworkInterfaces();\n-\n-        \/\/ build a list of NetworkInterface objects to test MAC address\n-        \/\/ uniqueness\n-        createNetworkInterfaceList(networkInterfaces, networkInterfaceList);\n-        areMacAddressesUnique = checkMacAddressesAreUnique(networkInterfaceList);\n-        if (!areMacAddressesUnique) {\n+        \/\/ build a list of NetworkInterface name address pairs\n+        \/\/ to test MAC address uniqueness\n+        List<NetIfPair> netIfList = createNetworkInterfaceList(NetworkConfiguration.probe());\n+        if (!macAddressesAreUnique(netIfList))\n@@ -62,1 +72,0 @@\n-        }\n@@ -65,12 +74,6 @@\n-    private boolean checkMacAddressesAreUnique (\n-            List<NetworkInterface> networkInterfaces) throws Exception {\n-        boolean uniqueMacAddresses = true;\n-        for (NetworkInterface networkInterface : networkInterfaces) {\n-            for (NetworkInterface comparisonNetIf : networkInterfaces) {\n-                System.out.println(\"Comparing netif \"\n-                        + networkInterface.getName() + \" and netif \"\n-                        + comparisonNetIf.getName());\n-                if (testMacAddressesEqual(networkInterface, comparisonNetIf)) {\n-                    uniqueMacAddresses = false;\n-                    break;\n-                }\n+    private boolean macAddressesAreUnique(List<NetIfPair> netIfPairs) {\n+        for (NetIfPair netIfPair : netIfPairs) {\n+            for (NetIfPair compNetIfPair : netIfPairs) {\n+                if (!netIfPair.interfaceName.equals(compNetIfPair.interfaceName) &&\n+                        testMacAddressesEqual(netIfPair, compNetIfPair))\n+                    return false;\n@@ -78,2 +81,0 @@\n-            if (uniqueMacAddresses != true)\n-                break;\n@@ -81,1 +82,1 @@\n-        return uniqueMacAddresses;\n+        return true;\n@@ -84,17 +85,5 @@\n-    private boolean testMacAddressesEqual(NetworkInterface netIf1,\n-            NetworkInterface netIf2) throws Exception {\n-\n-        byte[] rawMacAddress1 = null;\n-        byte[] rawMacAddress2 = null;\n-        boolean macAddressesEqual = false;\n-        if (!netIf1.getName().equals(netIf2.getName())) {\n-            System.out.println(\"compare hardware addresses \"\n-                +  createMacAddressString(netIf1) + \" and \" + createMacAddressString(netIf2));\n-            rawMacAddress1 = netIf1.getHardwareAddress();\n-            rawMacAddress2 = netIf2.getHardwareAddress();\n-            macAddressesEqual = Arrays.equals(rawMacAddress1, rawMacAddress2);\n-        } else {\n-            \/\/ same interface\n-            macAddressesEqual = false;\n-        }\n-        return macAddressesEqual;\n+    private boolean testMacAddressesEqual(NetIfPair if1, NetIfPair if2) {\n+        log.println(\"Compare hardware addresses of \" + if1.interfaceName + \" (\"\n+                +  createMacAddressString(if1.address) + \")\" + \" and \" + if2.interfaceName\n+                + \" (\" + createMacAddressString(if2.address) + \")\");\n+        return (Arrays.equals(if1.address, if2.address));\n@@ -103,2 +92,1 @@\n-    private String createMacAddressString (NetworkInterface netIf) throws Exception {\n-        byte[] macAddr = netIf.getHardwareAddress();\n+    private String createMacAddressString(byte[] macAddr) {\n@@ -115,15 +103,5 @@\n-    private void createNetworkInterfaceList(Enumeration<NetworkInterface> nis,\n-            List<NetworkInterface> networkInterfaceList) throws Exception {\n-        byte[] macAddr = null;\n-        NetworkInterface netIf = null;\n-        while (nis.hasMoreElements()) {\n-            netIf = (NetworkInterface) nis.nextElement();\n-            if (netIf.isUp()) {\n-                macAddr = netIf.getHardwareAddress();\n-                if (macAddr != null) {\n-                    System.out.println(\"Adding NetworkInterface \"\n-                            + netIf.getName() + \" with mac address \"\n-                            + createMacAddressString(netIf));\n-                    networkInterfaceList.add(netIf);\n-                }\n-            }\n+    private byte[] getNetworkInterfaceHardwareAddress(NetworkInterface inf) {\n+        try {\n+            return inf.getHardwareAddress();\n+        } catch (SocketException se) {\n+            throw new UncheckedIOException(se);\n@@ -132,0 +110,7 @@\n+\n+    private List<NetIfPair> createNetworkInterfaceList(NetworkConfiguration netConf) {\n+        return netConf.interfaces()\n+                .map(netIf -> new NetIfPair(netIf.getName(), getNetworkInterfaceHardwareAddress(netIf)))\n+                .collect(Collectors.filtering(netIfPair -> netIfPair.address != null,\n+                        Collectors.toCollection(ArrayList::new)));\n+    }\n","filename":"test\/jdk\/java\/net\/NetworkInterface\/UniqueMacAddressesTest.java","additions":51,"deletions":66,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n+ * @library \/test\/lib\n@@ -35,1 +35,1 @@\n- * @build jdk.testlibrary.OSInfo\n+ * @build jdk.test.lib.OSVersion jdk.test.lib.Platform\n@@ -40,1 +40,2 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.OSVersion;\n@@ -53,2 +54,2 @@\n-            if (OSInfo.getOSType() == OSInfo.OSType.WINDOWS\n-                && OSInfo.getWindowsVersion() == OSInfo.WINDOWS_XP) {\n+        if (Platform.isWindows()\n+                && OSVersion.current().equals(OSVersion.WINDOWS_XP)) {\n","filename":"test\/jdk\/javax\/swing\/JButton\/4796987\/bug4796987.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n+ * @library \/test\/lib\n@@ -30,1 +30,1 @@\n- * @build jdk.testlibrary.OSInfo\n+ * @build jdk.test.lib.Platform\n@@ -38,1 +38,2 @@\n-import jdk.testlibrary.OSInfo;\n+\n+import jdk.test.lib.Platform;\n@@ -47,1 +48,1 @@\n-            if (OSInfo.getOSType() == OSInfo.OSType.MACOSX) {\n+            if (Platform.isOSX()) {\n","filename":"test\/jdk\/javax\/swing\/JCheckBox\/4449413\/bug4449413.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,2 @@\n-import jdk.testlibrary.OSInfo;\n+\n+import jdk.test.lib.Platform;\n@@ -36,2 +37,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -47,1 +48,1 @@\n-        if(!OSInfo.OSType.MACOSX.equals(OSInfo.getOSType())){\n+        if (!Platform.isOSX()) {\n","filename":"test\/jdk\/javax\/swing\/JCheckBox\/8032667\/bug8032667_image_diff.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,1 @@\n-   @author Vladislav Karnaukhov\n-   @library ..\/..\/..\/..\/lib\/testlibrary\n+   @library \/test\/lib\n@@ -33,1 +32,1 @@\n-   @build jdk.testlibrary.OSInfo\n+   @build jdk.test.lib.Platform\n@@ -38,1 +37,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -232,1 +231,1 @@\n-        if (OSInfo.getOSType() == OSInfo.OSType.WINDOWS) {\n+        if (Platform.isWindows()) {\n","filename":"test\/jdk\/javax\/swing\/JComboBox\/4199622\/bug4199622.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- Copyright (c) 2013, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- @library ..\/..\/..\/..\/lib\/testlibrary\n- @build jdk.testlibrary.OSInfo\n+ @library \/test\/lib\n+ @build jdk.test.lib.Platform\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/4150029\/bug4150029.html","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -38,1 +40,1 @@\n-        if (jdk.testlibrary.OSInfo.getOSType() == jdk.testlibrary.OSInfo.OSType.MACOSX) {\n+        if (Platform.isOSX()) {\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/4150029\/bug4150029.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build Util jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build Util jdk.test.lib.Platform\n@@ -39,1 +39,2 @@\n-import jdk.testlibrary.OSInfo;\n+\n+import jdk.test.lib.Platform;\n@@ -61,1 +62,1 @@\n-        if (OSInfo.OSType.MACOSX.equals(OSInfo.getOSType())) {\n+        if (Platform.isOSX()) {\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/4524490\/bug4524490.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-   @library ..\/..\/..\/..\/lib\/testlibrary\n+   @library \/test\/lib\n@@ -30,1 +30,1 @@\n-   @build jdk.testlibrary.OSInfo\n+   @build jdk.test.lib.Platform\n@@ -34,1 +34,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -49,1 +49,1 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.WINDOWS) {\n+        if (!Platform.isWindows()) {\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/6840086\/bug6840086.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,2 +30,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -48,1 +48,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -62,1 +62,1 @@\n-            if (OSInfo.getOSType() == OSInfo.OSType.WINDOWS) {\n+            if (Platform.isWindows()) {\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/8041694\/bug8041694.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n+ * @library \/test\/lib\n@@ -32,1 +32,1 @@\n- * @build jdk.testlibrary.OSInfo\n+ * @build jdk.test.lib.Platform\n@@ -37,2 +37,1 @@\n-import jdk.testlibrary.OSInfo;\n-import jdk.testlibrary.OSInfo.OSType;\n+import jdk.test.lib.Platform;\n@@ -48,2 +47,1 @@\n-        OSType type = OSInfo.getOSType();\n-        if (type != OSType.WINDOWS) {\n+        if (!Platform.isWindows()) {\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/8046391\/bug8046391.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -42,1 +42,1 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n+ * @library \/test\/lib\n@@ -44,1 +44,1 @@\n- * @build jdk.testlibrary.OSInfo\n+ * @build jdk.test.lib.Platform\n@@ -122,1 +122,1 @@\n-        if (!OSInfo.getOSType().equals(OSInfo.OSType.WINDOWS)) {\n+        if (!Platform.isWindows()) {\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/8062561\/bug8062561.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -50,1 +50,2 @@\n-import jdk.testlibrary.OSInfo;\n+\n+import jdk.test.lib.Platform;\n@@ -63,1 +64,1 @@\n-        if (OSInfo.getOSType() == OSInfo.OSType.WINDOWS) {\n+        if (Platform.isWindows()) {\n","filename":"test\/jdk\/javax\/swing\/JFrame\/8016356\/bug8016356.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,2 @@\n-import jdk.testlibrary.OSInfo;\n+\n+import jdk.test.lib.Platform;\n@@ -37,0 +38,1 @@\n+ * @requires (os.family == \"mac\")\n@@ -38,3 +40,3 @@\n- * @author Sergey Bylokhov\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build ExtendedRobot jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ *          \/test\/jdk\/lib\/testlibrary\/\n+ * @build ExtendedRobot jdk.test.lib.Platform\n@@ -55,1 +57,1 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.MACOSX) {\n+        if (!Platform.isOSX()) {\n","filename":"test\/jdk\/javax\/swing\/JFrame\/NSTexturedJFrame\/NSTexturedJFrame.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,2 @@\n-   @library ..\/..\/..\/..\/lib\/testlibrary\n-   @build jdk.testlibrary.OSInfo\n+   @library \/test\/lib\n+   @build jdk.test.lib.Platform\n@@ -37,1 +37,0 @@\n-import jdk.testlibrary.OSInfo;\n@@ -39,0 +38,1 @@\n+import jdk.test.lib.Platform;\n@@ -43,1 +43,1 @@\n-        if (OSInfo.getOSType() == OSInfo.OSType.MACOSX) {\n+        if (Platform.isOSX()) {\n","filename":"test\/jdk\/javax\/swing\/JInternalFrame\/4251301\/bug4251301.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build Util jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build Util jdk.test.lib.Platform\n@@ -42,1 +42,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -82,1 +82,1 @@\n-            if (OSInfo.getOSType() == OSInfo.OSType.MACOSX) {\n+            if (Platform.isOSX()) {\n","filename":"test\/jdk\/javax\/swing\/JLabel\/6596966\/bug6596966.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -38,1 +38,2 @@\n-import jdk.testlibrary.OSInfo;\n+\n+import jdk.test.lib.Platform;\n@@ -70,1 +71,1 @@\n-            if (OSInfo.getOSType() == OSInfo.OSType.MACOSX) {\n+            if (Platform.isOSX()) {\n@@ -77,1 +78,1 @@\n-            if (OSInfo.getOSType() == OSInfo.OSType.MACOSX) {\n+            if (Platform.isOSX()) {\n","filename":"test\/jdk\/javax\/swing\/JMenu\/6470128\/bug6470128.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -36,1 +36,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -59,1 +59,1 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.MACOSX) {\n+        if (!Platform.isOSX()) {\n","filename":"test\/jdk\/javax\/swing\/JMenuItem\/ActionListenerCalledTwice\/ActionListenerCalledTwiceTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -34,0 +34,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -44,1 +46,1 @@\n-        if (jdk.testlibrary.OSInfo.getOSType() != jdk.testlibrary.OSInfo.OSType.MACOSX) {\n+        if (!Platform.isOSX()) {\n","filename":"test\/jdk\/javax\/swing\/JMenuItem\/ShortcutNotDiplayed\/ShortcutNotDisplayedTest.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,2 @@\n-import jdk.testlibrary.OSInfo;\n+\n+import jdk.test.lib.Platform;\n@@ -37,2 +38,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -51,1 +52,1 @@\n-        if (OSInfo.getOSType().equals(OSInfo.OSType.MACOSX)) {\n+        if (Platform.isOSX()) {\n","filename":"test\/jdk\/javax\/swing\/JOptionPane\/8024926\/bug8024926.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n+ * @library \/test\/lib\n@@ -33,1 +33,1 @@\n- * @build jdk.testlibrary.OSInfo\n+ * @build jdk.test.lib.Platform\n@@ -37,1 +37,2 @@\n-import jdk.testlibrary.OSInfo;\n+\n+import jdk.test.lib.Platform;\n@@ -77,1 +78,1 @@\n-            if (OSInfo.getOSType() == OSInfo.OSType.MACOSX) {\n+            if (Platform.isOSX()) {\n","filename":"test\/jdk\/javax\/swing\/JPopupMenu\/6827786\/bug6827786.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires (os.family == \"mac\")\n@@ -29,3 +30,3 @@\n- * @author Petr Pchelko\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build ExtendedRobot jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ *          \/test\/jdk\/lib\/testlibrary\/\n+ * @build ExtendedRobot jdk.test.lib.Platform\n@@ -40,1 +41,2 @@\n-import jdk.testlibrary.OSInfo;\n+\n+import jdk.test.lib.Platform;\n@@ -71,1 +73,1 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.MACOSX) {\n+        if (!Platform.isOSX()) {\n","filename":"test\/jdk\/javax\/swing\/JPopupMenu\/7154841\/bug7154841.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-   @library ..\/..\/..\/..\/lib\/testlibrary\n+   @library \/test\/lib\n@@ -29,1 +29,1 @@\n-   @build Util jdk.testlibrary.OSInfo\n+   @build Util jdk.test.lib.Platform\n@@ -37,1 +37,2 @@\n-import jdk.testlibrary.OSInfo;\n+\n+import jdk.test.lib.Platform;\n@@ -45,1 +46,1 @@\n-            if (OSInfo.getOSType() == OSInfo.OSType.MACOSX) {\n+            if (Platform.isOSX()) {\n","filename":"test\/jdk\/javax\/swing\/JScrollBar\/bug4202954\/bug4202954.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -42,2 +42,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -55,1 +55,1 @@\n-        delta = OSInfo.getOSType().equals(OSInfo.OSType.MACOSX) ? -30 : 30;\n+        delta = Platform.isOSX() ? -30 : 30;\n","filename":"test\/jdk\/javax\/swing\/JScrollPane\/HorizontalMouseWheelOnShiftPressed\/HorizontalMouseWheelOnShiftPressed.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.OSVersion jdk.test.lib.Platform\n@@ -34,1 +34,2 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.OSVersion;\n@@ -41,2 +42,2 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.WINDOWS ||\n-                OSInfo.getWindowsVersion() != OSInfo.WINDOWS_VISTA) {\n+        if (!Platform.isWindows() ||\n+                !OSVersion.current().equals(OSVersion.WINDOWS_VISTA)) {\n","filename":"test\/jdk\/javax\/swing\/JSlider\/6579827\/bug6579827.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n+ * @library \/test\/lib\n@@ -32,1 +32,1 @@\n- * @build Util jdk.testlibrary.OSInfo\n+ * @build Util jdk.test.lib.Platform\n@@ -43,1 +43,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -106,1 +106,1 @@\n-            if (OSInfo.getOSType() == OSInfo.OSType.MACOSX) {\n+            if (Platform.isOSX()) {\n","filename":"test\/jdk\/javax\/swing\/JTabbedPane\/4624207\/bug4624207.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -40,1 +40,2 @@\n-import jdk.testlibrary.OSInfo;\n+\n+import jdk.test.lib.Platform;\n@@ -47,1 +48,1 @@\n-        if(OSInfo.getOSType() != OSInfo.OSType.WINDOWS){\n+        if (!Platform.isWindows()) {\n","filename":"test\/jdk\/javax\/swing\/JTabbedPane\/6416920\/bug6416920.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n- * @library ..\/..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -36,1 +36,1 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n@@ -62,1 +62,1 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.WINDOWS) {\n+        if (!Platform.isWindows()) {\n","filename":"test\/jdk\/javax\/swing\/JTextArea\/6940863\/bug6940863.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n- * @library ..\/..\/..\/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -37,2 +37,2 @@\n-import jdk.testlibrary.OSInfo;\n-import jdk.testlibrary.OSInfo.OSType;\n+\n+import jdk.test.lib.Platform;\n@@ -43,1 +43,0 @@\n-        OSType os = OSInfo.getOSType();\n@@ -45,0 +44,5 @@\n+        if (Platform.isWindows()) {\n+            \/\/ Make sure we don't have GTK.\n+            if (hasLAF(\"gtk\", lafInfo)) {\n+                throw new RuntimeException(\"On windows, but GTK is present\");\n+            }\n@@ -46,31 +50,4 @@\n-        switch (os) {\n-            case WINDOWS:\n-\n-                \/\/ Make sure we don't have GTK.\n-                if (hasLAF(\"gtk\", lafInfo)) {\n-                    throw new RuntimeException(\"On windows, but GTK is present\");\n-                }\n-\n-                \/\/ Make sure we don't have Aqua.\n-                if (hasLAF(\"mac\", lafInfo)) {\n-                    throw new RuntimeException(\"On windows, but Aqua is present\");\n-                }\n-\n-                \/\/ Make sure we have Windows.\n-                if (!hasLAF(\"windows\", lafInfo)) {\n-                    throw new RuntimeException(\"On windows and don't have Windows\");\n-                }\n-\n-                break;\n-\n-            case MACOSX:\n-\n-                \/\/ Make sure we don't have GTK.\n-                if (hasLAF(\"gtk\", lafInfo)) {\n-                    throw new RuntimeException(\"On mac, but GTK is present\");\n-                }\n-\n-                \/\/ Make sure we don't have Windows.\n-                if (hasLAF(\"windows\", lafInfo)) {\n-                    throw new RuntimeException(\"On mac, but Windows is present\");\n-                }\n+            \/\/ Make sure we don't have Aqua.\n+            if (hasLAF(\"mac\", lafInfo)) {\n+                throw new RuntimeException(\"On windows, but Aqua is present\");\n+            }\n@@ -78,4 +55,9 @@\n-                \/\/ Make sure we have Aqua.\n-                if (!hasLAF(\"mac\", lafInfo)) {\n-                    throw new RuntimeException(\"On mac and don't have Aqua\");\n-                }\n+            \/\/ Make sure we have Windows.\n+            if (!hasLAF(\"windows\", lafInfo)) {\n+                throw new RuntimeException(\"On windows and don't have Windows\");\n+            }\n+        } else if (Platform.isOSX()) {\n+            \/\/ Make sure we don't have GTK.\n+            if (hasLAF(\"gtk\", lafInfo)) {\n+                throw new RuntimeException(\"On mac, but GTK is present\");\n+            }\n@@ -83,1 +65,4 @@\n-                break;\n+            \/\/ Make sure we don't have Windows.\n+            if (hasLAF(\"windows\", lafInfo)) {\n+                throw new RuntimeException(\"On mac, but Windows is present\");\n+            }\n@@ -85,2 +70,6 @@\n-            default:\n-                \/\/ Not windows and mac\n+            \/\/ Make sure we have Aqua.\n+            if (!hasLAF(\"mac\", lafInfo)) {\n+                throw new RuntimeException(\"On mac and don't have Aqua\");\n+            }\n+        } else {\n+            \/\/ Not windows and mac\n@@ -88,4 +77,4 @@\n-                \/\/ Make sure we don't have Windows.\n-                if (hasLAF(\"windows\", lafInfo)) {\n-                    throw new RuntimeException(\"Not on windows and have Windows\");\n-                }\n+            \/\/ Make sure we don't have Windows.\n+            if (hasLAF(\"windows\", lafInfo)) {\n+                throw new RuntimeException(\"Not on windows and have Windows\");\n+            }\n@@ -93,4 +82,4 @@\n-                \/\/ Make sure we don't have Aqua.\n-                if (hasLAF(\"mac\", lafInfo)) {\n-                    throw new RuntimeException(\"Not on mac and have Aqua\");\n-                }\n+            \/\/ Make sure we don't have Aqua.\n+            if (hasLAF(\"mac\", lafInfo)) {\n+                throw new RuntimeException(\"Not on mac and have Aqua\");\n+            }\n@@ -98,5 +87,5 @@\n-                \/\/ Make sure we have GTK.\n-                if (!hasLAF(\"gtk\", lafInfo)) {\n-                    throw new RuntimeException(\n-                            \"Not on Windows and Mac and don't have GTK!\");\n-                }\n+            \/\/ Make sure we have GTK.\n+            if (!hasLAF(\"gtk\", lafInfo)) {\n+                throw new RuntimeException(\n+                        \"Not on Windows and Mac and don't have GTK!\");\n+            }\n@@ -104,1 +93,0 @@\n-\n","filename":"test\/jdk\/javax\/swing\/UITest\/UITest.java","additions":46,"deletions":58,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,2 @@\n- * @library \/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -57,1 +57,2 @@\n-import jdk.testlibrary.OSInfo;\n+\n+import jdk.test.lib.Platform;\n@@ -64,1 +65,1 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.MACOSX) {\n+        if (!Platform.isOSX()) {\n","filename":"test\/jdk\/javax\/swing\/plaf\/aqua\/CustomComboBoxFocusTest.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n- * @library \/lib\/testlibrary\n- * @build jdk.testlibrary.OSInfo\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform\n@@ -41,1 +41,2 @@\n-import jdk.testlibrary.OSInfo;\n+\n+import jdk.test.lib.Platform;\n@@ -50,1 +51,1 @@\n-        if (OSInfo.getOSType() != OSInfo.OSType.WINDOWS) {\n+        if (!Platform.isWindows()) {\n","filename":"test\/jdk\/javax\/swing\/plaf\/basic\/BasicLabelUI\/bug7172652.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -46,8 +46,1 @@\n-        metricsTester.setup();\n-        metricsTester.testCpuAccounting();\n-        metricsTester.testCpuSchedulingMetrics();\n-        metricsTester.testCpuSets();\n-        metricsTester.testMemorySubsystem();\n-        metricsTester.testBlkIO();\n-        metricsTester.testCpuConsumption();\n-        metricsTester.testMemoryUsage();\n+        metricsTester.testAll(metrics);\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupMetrics.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import jdk.internal.platform.CgroupSubsystemController;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.util.FileUtils;\n+\n+\/*\n+ * @test\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.platform\n+ * @library \/test\/lib\n+ * @run junit\/othervm TestCgroupSubsystemController\n+ *\/\n+\n+\/**\n+ *\n+ * Basic unit test for CgroupSubsystemController\n+ *\n+ *\/\n+public class TestCgroupSubsystemController {\n+\n+    private static final double DELTA = 0.01;\n+    private Path existingDirectory;\n+    private Path existingFile;\n+    private String existingFileName = \"test-controller-file\";\n+    private String existingFileContents = \"foobar\";\n+    private String doubleValueContents = \"1.5\";\n+    private String longValueContents = \"3000000000\";\n+    private String longValueMatchingLineContents = \"testme\\n\" +\n+                                                   \"itemfoo 25\";\n+    private String longEntryContents = \"s 1\\n\" +\n+                                       \"t 2\";\n+    private String longEntryName = \"longEntry\";\n+    private String longEntryMatchingLineName = \"longMatchingLine\";\n+    private String doubleValueName = \"doubleValue\";\n+    private String longValueName = \"longValue\";\n+    private CgroupSubsystemController mockController;\n+\n+    @Before\n+    public void setup() {\n+        try {\n+            existingDirectory = Utils.createTempDirectory(TestCgroupSubsystemController.class.getSimpleName());\n+            existingFile = Paths.get(existingDirectory.toString(), existingFileName);\n+            Files.writeString(existingFile, existingFileContents, StandardCharsets.UTF_8);\n+            Path longFile = Paths.get(existingDirectory.toString(), longValueName);\n+            Files.writeString(longFile, longValueContents);\n+            Path doubleFile = Paths.get(existingDirectory.toString(), doubleValueName);\n+            Files.writeString(doubleFile, doubleValueContents);\n+            Path longEntryFile = Paths.get(existingDirectory.toString(), longEntryName);\n+            Files.writeString(longEntryFile, longEntryContents);\n+            Path longMatchingLine = Paths.get(existingDirectory.toString(), longEntryMatchingLineName);\n+            Files.writeString(longMatchingLine, longValueMatchingLineContents);\n+            mockController = new MockCgroupSubsystemController(existingDirectory.toString());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @After\n+    public void teardown() {\n+        try {\n+            FileUtils.deleteFileTreeWithRetry(existingDirectory);\n+        } catch (IOException e) {\n+            System.err.println(\"Teardown failed. \" + e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void getStringValueNullController() {\n+        String val = CgroupSubsystemController.getStringValue(null, \"ignore\");\n+        assertNull(val);\n+    }\n+\n+    @Test\n+    public void getStringValueIOException() throws IOException {\n+        String val = CgroupSubsystemController.getStringValue(mockController, \"don-t-exist.txt\");\n+        assertNull(val);\n+    }\n+\n+    @Test\n+    public void getStringValueSuccess() {\n+        String actual = CgroupSubsystemController.getStringValue(mockController, existingFileName);\n+        assertEquals(existingFileContents, actual);\n+    }\n+\n+    @Test\n+    public void convertStringToLong() {\n+        String strVal = \"1230\";\n+        long longVal = Long.parseLong(strVal);\n+        long actual = CgroupSubsystemController.convertStringToLong(strVal, -1L, 0);\n+        assertEquals(longVal, actual);\n+\n+        String overflowVal = \"9223372036854775808\"; \/\/ Long.MAX_VALUE + 1\n+        long overflowDefault = -1;\n+        actual = CgroupSubsystemController.convertStringToLong(overflowVal, overflowDefault, 0);\n+        assertEquals(overflowDefault, actual);\n+        overflowDefault = Long.MAX_VALUE;\n+        actual = CgroupSubsystemController.convertStringToLong(overflowVal, overflowDefault, 0);\n+        assertEquals(overflowDefault, actual);\n+    }\n+\n+    @Test\n+    public void convertStringRangeToIntArray() {\n+        assertNull(CgroupSubsystemController.stringRangeToIntArray(null));\n+        assertNull(CgroupSubsystemController.stringRangeToIntArray(\"\"));\n+        String strRange = \"2,4,6\";\n+        int[] actual = CgroupSubsystemController.stringRangeToIntArray(strRange);\n+        int[] expected = new int[] { 2, 4, 6 };\n+        assertTrue(Arrays.equals(expected, actual));\n+        strRange = \"6,1-3\";\n+        actual = CgroupSubsystemController.stringRangeToIntArray(strRange);\n+        expected = new int[] { 1, 2, 3, 6 };\n+        assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    @Test\n+    public void getDoubleValue() {\n+        double defaultValue = -3;\n+        double actual = CgroupSubsystemController.getDoubleValue(null, null, defaultValue);\n+        assertEquals(defaultValue, actual, DELTA);\n+        double expected = Double.parseDouble(doubleValueContents);\n+        actual = CgroupSubsystemController.getDoubleValue(mockController, doubleValueName, defaultValue);\n+        assertEquals(expected, actual, DELTA);\n+        actual = CgroupSubsystemController.getDoubleValue(mockController, \"don't-exist\", defaultValue);\n+        assertEquals(defaultValue, actual, DELTA);\n+    }\n+\n+    @Test\n+    public void getLongValue() {\n+        long defaultValue = -4;\n+        long actual = CgroupSubsystemController.getLongValue(null, null, Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongValue(mockController, \"dont-exist\", Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        long expected = Long.parseLong(longValueContents);\n+        actual = CgroupSubsystemController.getLongValue(mockController, longValueName, Long::parseLong, defaultValue);\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void getLongEntry() {\n+        long defaultValue = -5;\n+        long actual = CgroupSubsystemController.getLongEntry(null, null, \"no-matter\", defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongEntry(mockController, \"dont-exist\", \"foo-bar\", defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongEntry(mockController, longEntryName, \"t\", defaultValue);\n+        assertEquals(2, actual);\n+    }\n+\n+    @Test\n+    public void getLongMatchingLine() {\n+        long defaultValue = -6;\n+        long actual = CgroupSubsystemController.getLongValueMatchingLine(null, null, \"no-matter\", Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongValueMatchingLine(mockController, \"dont-exist\", \"no-matter\", Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongValueMatchingLine(mockController, longEntryMatchingLineName, \"item\", TestCgroupSubsystemController::convertLong, defaultValue);\n+        assertEquals(25, actual);\n+    }\n+\n+    public static long convertLong(String line) {\n+        return Long.parseLong(line.split(\"\\\\s+\")[1]);\n+    }\n+\n+    static class MockCgroupSubsystemController implements CgroupSubsystemController {\n+\n+        private final String path;\n+\n+        public MockCgroupSubsystemController(String path) {\n+            this.path = path;\n+        }\n+\n+        @Override\n+        public String path() {\n+            return path;\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemController.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -146,0 +146,5 @@\n+        if (\"cgroupv2\".equals(metrics.getProvider()) && shares < 1024) {\n+            \/\/ Adjust input shares for < 1024 cpu shares as the\n+            \/\/ impl. rounds up to the next multiple of 1024\n+            shares = 1024;\n+        }\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/MetricsCpuTester.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -26,0 +27,1 @@\n+import jdk.internal.platform.CgroupV1Metrics;\n@@ -78,0 +80,1 @@\n+            boolean atLeastOneAllocationWorked = false;\n@@ -81,0 +84,1 @@\n+                    atLeastOneAllocationWorked = true;\n@@ -90,0 +94,6 @@\n+            if (!atLeastOneAllocationWorked) {\n+                System.out.println(\"Allocation failed immediately. Ignoring test!\");\n+                return;\n+            }\n+            \/\/ Be sure bytes allocations don't get optimized out\n+            System.out.println(\"DEBUG: Bytes allocation length 1: \" + bytes[0].length);\n@@ -113,9 +123,16 @@\n-        long limit = getMemoryValue(value);\n-        long kmemlimit = Metrics.systemMetrics().getKernelMemoryLimit();\n-        \/\/ Note that the kernel memory limit might get ignored by OCI runtimes\n-        \/\/ This feature is deprecated. Only perform the check if we get an actual\n-        \/\/ limit back.\n-        if (kmemlimit != UNLIMITED && limit != kmemlimit) {\n-            throw new RuntimeException(\"Kernel Memory limit not equal, expected : [\"\n-                    + limit + \"]\" + \", got : [\"\n-                    + kmemlimit + \"]\");\n+        Metrics m = Metrics.systemMetrics();\n+        if (m instanceof CgroupV1Metrics) {\n+            CgroupV1Metrics mCgroupV1 = (CgroupV1Metrics)m;\n+            System.out.println(\"TEST PASSED!!!\");\n+            long limit = getMemoryValue(value);\n+            long kmemlimit = mCgroupV1.getKernelMemoryLimit();\n+            \/\/ Note that the kernel memory limit might get ignored by OCI runtimes\n+            \/\/ This feature is deprecated. Only perform the check if we get an actual\n+            \/\/ limit back.\n+            if (kmemlimit != UNLIMITED && limit != kmemlimit) {\n+                throw new RuntimeException(\"Kernel Memory limit not equal, expected : [\"\n+                            + limit + \"]\" + \", got : [\"\n+                            + kmemlimit + \"]\");\n+            }\n+        } else {\n+            throw new RuntimeException(\"oomKillFlag test not supported for cgroups v2\");\n@@ -123,1 +140,0 @@\n-        System.out.println(\"TEST PASSED!!!\");\n@@ -157,2 +173,11 @@\n-        if (!(oomKillFlag ^ Metrics.systemMetrics().isMemoryOOMKillEnabled())) {\n-            throw new RuntimeException(\"oomKillFlag error\");\n+        Metrics m = Metrics.systemMetrics();\n+        if (m instanceof CgroupV1Metrics) {\n+            CgroupV1Metrics mCgroupV1 = (CgroupV1Metrics)m;\n+            Boolean expected = Boolean.valueOf(oomKillFlag);\n+            Boolean actual = mCgroupV1.isMemoryOOMKillEnabled();\n+            if (!(expected.equals(actual))) {\n+                throw new RuntimeException(\"oomKillFlag error\");\n+            }\n+            System.out.println(\"TEST PASSED!!!\");\n+        } else {\n+            throw new RuntimeException(\"oomKillFlag test not supported for cgroups v2\");\n@@ -160,1 +185,0 @@\n-        System.out.println(\"TEST PASSED!!!\");\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/MetricsMemoryTester.java","additions":38,"deletions":14,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-            if (cpuSetMems.length > 1) {\n+            if (cpuSetMems != null && cpuSetMems.length > 1) {\n@@ -84,1 +84,1 @@\n-            } else if (cpuSetMems.length == 1) {\n+            } else if (cpuSetMems != null && cpuSetMems.length == 1) {\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerCpuMetrics.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.internal.platform.Metrics;\n@@ -28,0 +29,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -60,4 +62,15 @@\n-            testKernelMemoryLimit(\"100m\");\n-            testKernelMemoryLimit(\"1g\");\n-\n-            testOomKillFlag(\"100m\", false);\n+            Metrics m = Metrics.systemMetrics();\n+            \/\/ kernel memory, '--kernel-memory' switch, and OOM killer,\n+            \/\/ '--oom-kill-disable' switch, tests not supported by cgroupv2\n+            \/\/ runtimes\n+            if (m != null) {\n+                if (\"cgroupv1\".equals(m.getProvider())) {\n+                    testKernelMemoryLimit(\"100m\");\n+                    testKernelMemoryLimit(\"1g\");\n+\n+                    testOomKillFlag(\"100m\", false);\n+                } else {\n+                    System.out.println(\"kernel memory tests and OOM Kill flag tests not \" +\n+                                       \"possible with cgroupv2.\");\n+                }\n+            }\n@@ -71,1 +84,3 @@\n-            DockerTestUtils.removeDockerImage(imageName);\n+            if (!DockerTestUtils.RETAIN_IMAGE_AFTER_TEST) {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n@@ -137,1 +152,2 @@\n-        DockerTestUtils.dockerRunJava(opts).shouldHaveExitValue(0).shouldContain(\"TEST PASSED!!!\");\n+        OutputAnalyzer oa = DockerTestUtils.dockerRunJava(opts);\n+        oa.shouldHaveExitValue(0).shouldContain(\"TEST PASSED!!!\");\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerMemoryMetrics.java","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jdk.test.lib.Utils;\n@@ -90,1 +91,1 @@\n-        return File.createTempFile(\"EvilTransformer\", null, new File(\".\")).getAbsoluteFile();\n+        return Utils.createTempFile(\"EvilTransformer\", null).toFile();\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/EvilInstrument.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.test.lib.Utils;\n@@ -58,2 +59,1 @@\n-        File tmp = File.createTempFile(\"TestDisabledEvents\", \".tmp\", new File(\".\"));\n-        tmp.deleteOnExit();\n+        File tmp = Utils.createTempFile(\"TestDisabledEvents\", \".tmp\").toFile();\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestDisabledEvents.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.test.lib.Utils;\n@@ -51,2 +52,1 @@\n-        File tmp = File.createTempFile(\"TestFileChannelEvents\", \".tmp\", new File(\".\"));\n-        tmp.deleteOnExit();\n+        File tmp = Utils.createTempFile(\"TestFileChannelEvents\", \".tmp\").toFile();\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestFileChannelEvents.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jdk.test.lib.Utils;\n@@ -53,2 +54,1 @@\n-        File tmp = File.createTempFile(\"TestFileReadOnly\", \".tmp\", new File(\".\"));\n-        tmp.deleteOnExit();\n+        File tmp = Utils.createTempFile(\"TestFileReadOnly\", \".tmp\").toFile();\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestFileReadOnly.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.test.lib.Utils;\n@@ -51,2 +52,1 @@\n-        File tmp = File.createTempFile(\"TestFileStreamEvents\", \".tmp\", new File(\".\"));\n-        tmp.deleteOnExit();\n+        File tmp = Utils.createTempFile(\"TestFileStreamEvents\", \".tmp\").toFile();\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestFileStreamEvents.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.test.lib.Utils;\n@@ -50,2 +51,1 @@\n-        File tmp = File.createTempFile(\"TestRandomAccessFileEvents\", \".tmp\", new File(\".\"));\n-        tmp.deleteOnExit();\n+        File tmp = Utils.createTempFile(\"TestRandomAccessFileEvents\", \".tmp\").toFile();\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestRandomAccessFileEvents.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.test.lib.Utils;\n@@ -65,2 +66,2 @@\n-        File tmp = File.createTempFile(\"TestRandomAccessFileThread\", \".tmp\", new File(\".\"));\n-        tmp.deleteOnExit();\n+        File tmp = Utils.createTempFile(\"TestRandomAccessFileThread\", \".tmp\").toFile();\n+\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestRandomAccessFileThread.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.test.lib.Utils;\n@@ -65,1 +66,1 @@\n-        String dumpPath = Files.createTempDirectory(\"dump-path\").toAbsolutePath().toString();\n+        String dumpPath = Utils.createTempDirectory(\"dump-path-\").toAbsolutePath().toString();\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdConfigure.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,1 @@\n+import jdk.test.lib.Utils;\n@@ -139,1 +140,1 @@\n-        File f = File.createTempFile(\"stream_\" + streamId + \"_\", \".jfr\", new File(\".\"));\n+        File f = Utils.createTempFile(\"stream_\" + streamId + \"_\", \".jfr\").toFile();\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/JmxHelper.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import jdk.test.lib.Utils;\n@@ -120,1 +121,1 @@\n-        File file = File.createTempFile(\"test\", \".jfr\");\n+        File file = Utils.createTempFile(\"test\", \".jfr\").toFile();\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestJavaEvent.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,2 @@\n- * @library \/lib\/testlibrary\n- * @build jdk.testlibrary.*\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.OSVersion jdk.test.lib.Platform\n@@ -35,1 +35,0 @@\n-import jdk.net.ExtendedSocketOptions;\n@@ -38,1 +37,2 @@\n-import jdk.testlibrary.OSInfo;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.OSVersion;\n@@ -56,1 +56,0 @@\n-    private static final double solarisVersionToCheck = 11.2;\n@@ -193,3 +192,4 @@\n-        if (OSInfo.getOSType().equals(OSInfo.OSType.SOLARIS)) {\n-            double solarisVersion = OSInfo.getSolarisVersion();\n-            if (solarisVersion >= solarisVersionToCheck) {\n+        if (Platform.isSolaris()) {\n+            OSVersion solarisVersion = OSVersion.current();\n+            OSVersion solarisVersionToCheck = new OSVersion(11, 2);\n+            if (solarisVersion.compareTo(solarisVersionToCheck) >= 0) {\n","filename":"test\/jdk\/jdk\/net\/Sockets\/Test.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,4 +1,2 @@\n-grant {\n-    permission java.util.PropertyPermission \"os.name\", \"read\";\n-    permission java.io.FilePermission \"<<ALL FILES>>\", \"execute\";\n-    permission java.util.PropertyPermission \"line.separator\", \"read\";\n+grant codeBase \"file:${test.classes}\/..\/..\/..\/..\/test\/lib\/-\" {\n+    permission java.util.PropertyPermission \"*\", \"read\";\n@@ -6,2 +4,6 @@\n-    permission java.net.SocketPermission \"127.0.0.1\", \"connect,accept\" ;\n-    permission java.net.SocketPermission \"localhost\", \"listen\" ;\n+    permission java.io.FilePermission \"<<ALL FILES>>\", \"execute\";\n+};\n+\n+grant codeBase \"file:${test.classes}\/*\" {\n+    permission java.net.SocketPermission \"127.0.0.1\", \"connect,accept\";\n+    permission java.net.SocketPermission \"localhost\", \"listen\";\n","filename":"test\/jdk\/jdk\/net\/Sockets\/policy.fail","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,4 +1,2 @@\n-grant {\n-    permission java.util.PropertyPermission \"os.name\", \"read\";\n-    permission java.io.FilePermission \"<<ALL FILES>>\", \"execute\";\n-    permission java.util.PropertyPermission \"line.separator\", \"read\";\n+grant codeBase \"file:${test.classes}\/..\/..\/..\/..\/test\/lib\/-\" {\n+    permission java.util.PropertyPermission \"*\", \"read\";\n@@ -6,2 +4,6 @@\n-    permission java.net.SocketPermission \"127.0.0.1\", \"connect,accept\" ;\n-    permission java.net.SocketPermission \"localhost\", \"listen\" ;\n+    permission java.io.FilePermission \"<<ALL FILES>>\", \"execute\";\n+};\n+\n+grant codeBase \"file:${test.classes}\/*\" {\n+    permission java.net.SocketPermission \"127.0.0.1\", \"connect,accept\";\n+    permission java.net.SocketPermission \"localhost\", \"listen\";\n","filename":"test\/jdk\/jdk\/net\/Sockets\/policy.success","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,217 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.testlibrary;\n-\n-import java.security.PrivilegedAction;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.io.BufferedReader;\n-import java.io.FileReader;\n-import java.io.InputStreamReader;\n-\n-import static jdk.testlibrary.OSInfo.OSType.*;\n-\n-\/**\n- * @author Pavel Porvatov\n- * copied to testlibrary by yan\n- *\/\n-public class OSInfo {\n-    public static enum OSType {\n-        WINDOWS,\n-        LINUX,\n-        SOLARIS,\n-        MACOSX,\n-        UNKNOWN\n-    }\n-\n-    \/*\n-       The map windowsVersionMap must contain all windows version constants except WINDOWS_UNKNOWN,\n-       and so the method getWindowsVersion() will return the constant for known OS.\n-       It allows compare objects by \"==\" instead of \"equals\".\n-     *\/\n-    public static final WindowsVersion WINDOWS_UNKNOWN = new WindowsVersion(-1, -1);\n-    public static final WindowsVersion WINDOWS_95 = new WindowsVersion(4, 0);\n-    public static final WindowsVersion WINDOWS_98 = new WindowsVersion(4, 10);\n-    public static final WindowsVersion WINDOWS_ME = new WindowsVersion(4, 90);\n-    public static final WindowsVersion WINDOWS_2000 = new WindowsVersion(5, 0);\n-    public static final WindowsVersion WINDOWS_XP = new WindowsVersion(5, 1);\n-    public static final WindowsVersion WINDOWS_2003 = new WindowsVersion(5, 2);\n-    public static final WindowsVersion WINDOWS_VISTA = new WindowsVersion(6, 0);\n-\n-    private static final String OS_NAME = \"os.name\";\n-    private static final String OS_VERSION = \"os.version\";\n-\n-    private final static Map<String, WindowsVersion> windowsVersionMap = new HashMap<String, OSInfo.WindowsVersion>();\n-\n-    static {\n-        windowsVersionMap.put(WINDOWS_95.toString(), WINDOWS_95);\n-        windowsVersionMap.put(WINDOWS_98.toString(), WINDOWS_98);\n-        windowsVersionMap.put(WINDOWS_ME.toString(), WINDOWS_ME);\n-        windowsVersionMap.put(WINDOWS_2000.toString(), WINDOWS_2000);\n-        windowsVersionMap.put(WINDOWS_XP.toString(), WINDOWS_XP);\n-        windowsVersionMap.put(WINDOWS_2003.toString(), WINDOWS_2003);\n-        windowsVersionMap.put(WINDOWS_VISTA.toString(), WINDOWS_VISTA);\n-    }\n-\n-    private static final PrivilegedAction<OSType> osTypeAction = new PrivilegedAction<OSType>() {\n-        public OSType run() {\n-            return getOSType();\n-        }\n-    };\n-\n-    private OSInfo() {\n-        \/\/ Don't allow to create instances\n-    }\n-\n-    \/**\n-     * Returns type of operating system.\n-     *\/\n-    public static OSType getOSType() throws SecurityException {\n-        String osName = System.getProperty(OS_NAME);\n-\n-        if (osName != null) {\n-            if (osName.contains(\"Windows\")) {\n-                return WINDOWS;\n-            }\n-\n-            if (osName.contains(\"Linux\")) {\n-                return LINUX;\n-            }\n-\n-            if (osName.contains(\"Solaris\") || osName.contains(\"SunOS\")) {\n-                return SOLARIS;\n-            }\n-\n-            if (osName.contains(\"OS X\")) {\n-                return MACOSX;\n-            }\n-\n-            \/\/ determine another OS here\n-        }\n-\n-        return UNKNOWN;\n-    }\n-\n-    public static PrivilegedAction<OSType> getOSTypeAction() {\n-        return osTypeAction;\n-    }\n-\n-    public static WindowsVersion getWindowsVersion() throws SecurityException {\n-        String osVersion = System.getProperty(OS_VERSION);\n-\n-        if (osVersion == null) {\n-            return WINDOWS_UNKNOWN;\n-        }\n-\n-        synchronized (windowsVersionMap) {\n-            WindowsVersion result = windowsVersionMap.get(osVersion);\n-\n-            if (result == null) {\n-                \/\/ Try parse version and put object into windowsVersionMap\n-                String[] arr = osVersion.split(\"\\\\.\");\n-\n-                if (arr.length == 2) {\n-                    try {\n-                        result = new WindowsVersion(Integer.parseInt(arr[0]), Integer.parseInt(arr[1]));\n-                    } catch (NumberFormatException e) {\n-                        return WINDOWS_UNKNOWN;\n-                    }\n-                } else {\n-                    return WINDOWS_UNKNOWN;\n-                }\n-\n-                windowsVersionMap.put(osVersion, result);\n-            }\n-\n-            return result;\n-        }\n-    }\n-\n-    public static double getSolarisVersion() {\n-        try {\n-            OutputAnalyzer output = ProcessTools.executeProcess(\"uname\", \"-v\");\n-            System.out.println(\"'uname -v' finished with code \"\n-                    + output.getExitValue());\n-            String version = output.getOutput().replaceAll(\"(\\\\d+\\\\.\\\\d+)\\\\..*\", \"$1\");\n-            return Double.parseDouble(version);\n-        } catch (Exception e) {\n-            System.out.println(\"First attempt failed with: \" + e.getMessage());\n-        }\n-\n-        \/\/Try to get Solaris version from \/etc\/release\n-        try (BufferedReader in =\n-                     new BufferedReader(new FileReader(\"\/etc\/release\"))) {\n-            String line = in.readLine().trim().split(\" \")[2];\n-            return Double.parseDouble(line);\n-        } catch (Exception e) {\n-            System.out.println(\"Second attempt failed with: \" + e.getMessage());\n-        }\n-\n-        throw new RuntimeException(\"Unable to get Solaris version\");\n-    }\n-\n-    public static class WindowsVersion implements Comparable<WindowsVersion> {\n-        private final int major;\n-\n-        private final int minor;\n-\n-        private WindowsVersion(int major, int minor) {\n-            this.major = major;\n-            this.minor = minor;\n-        }\n-\n-        public int getMajor() {\n-            return major;\n-        }\n-\n-        public int getMinor() {\n-            return minor;\n-        }\n-\n-        public int compareTo(WindowsVersion o) {\n-            int result = major - o.getMajor();\n-\n-            if (result == 0) {\n-                result = minor - o.getMinor();\n-            }\n-\n-            return result;\n-        }\n-\n-        public boolean equals(Object obj) {\n-            return obj instanceof WindowsVersion && compareTo((WindowsVersion) obj) == 0;\n-        }\n-\n-        public int hashCode() {\n-            return 31 * major + minor;\n-        }\n-\n-        public String toString() {\n-            return major + \".\" + minor;\n-        }\n-    }\n-}\n-\n","filename":"test\/jdk\/lib\/testlibrary\/jdk\/testlibrary\/OSInfo.java","additions":0,"deletions":217,"binary":false,"changes":217,"status":"deleted"},{"patch":"@@ -1,204 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.testlibrary;\n-\n-import java.util.concurrent.TimeoutException;\n-\n-\/**\n- * Thread which catches exceptions thrown during the execution\n- * and stores them for later analysis.\n- *\n- * <pre>\n- * {@code\n- * TestThread thread = new TestThread(new XRun() {\n- *      public void run() {\n- *      \/\/ do something\n- *      }\n- * });\n- * thread.start();\n- * \/\/ do something\n- * Throwable uncaught = thread.getUncaught();\n- * }\n- * <\/pre>\n- *\/\n-public class TestThread extends Thread {\n-\n-    private final Runnable runnable;\n-    private volatile Throwable uncaught;\n-\n-    \/**\n-     * Returns {@link Runnable} the thread has been created with.\n-     *\n-     * @return The object whose {@code run} method is called\n-     *\/\n-    public Runnable getRunnable() {\n-        return runnable;\n-    }\n-\n-    \/**\n-     * Creates a new {@code TestThread} object.\n-     *\n-     * @param target The object whose {@code run} method is called\n-     * @param name The thread name\n-     *\/\n-    public TestThread(Runnable target, String name) {\n-        super(target, name);\n-        this.runnable = target;\n-    }\n-\n-    \/**\n-     * Creates a new {@code TestThread} object.\n-     *\n-     * @param target The object whose {@code run} method is called\n-     *\/\n-    public TestThread(Runnable target) {\n-        super(target);\n-        this.runnable = target;\n-    }\n-\n-    \/**\n-     * Creates a new {@code TestThread} object.\n-     *\n-     * @param group The thread group\n-     * @param target The object whose {@code run} method is called\n-     * @param name The thread name\n-     * @param stackSize Stack size\n-     *\/\n-    public TestThread(ThreadGroup group, Runnable target, String name,\n-            long stackSize) {\n-        super(group, target, name, stackSize);\n-        this.runnable = target;\n-    }\n-\n-    \/**\n-     * Creates a new {@code TestThread} object.\n-     *\n-     * @param group The thread group\n-     * @param target The object whose {@code run} method is called\n-     * @param name The thread name\n-     *\/\n-    public TestThread(ThreadGroup group, Runnable target, String name) {\n-        super(group, target, name);\n-        this.runnable = target;\n-    }\n-\n-    \/**\n-     * Creates a new {@code TestThread} object.\n-     *\n-     * @param group The thread group\n-     * @param target The object whose {@code run} method is called\n-     *\/\n-    public TestThread(ThreadGroup group, Runnable target) {\n-        super(group, target);\n-        this.runnable = target;\n-    }\n-\n-    \/**\n-     * The thread executor.\n-     *\/\n-    @Override\n-    public void run() {\n-        try {\n-            super.run();\n-        } catch (Throwable t) {\n-            uncaught = t;\n-        }\n-    }\n-\n-    \/**\n-     * Returns exception caught during the execution.\n-     *\n-     * @return {@link Throwable}\n-     *\/\n-    public Throwable getUncaught() {\n-        return uncaught;\n-    }\n-\n-    \/**\n-     * Waits for {@link TestThread} to die\n-     * and throws exception caught during the execution.\n-     *\n-     * @throws InterruptedException\n-     * @throws Throwable\n-     *\/\n-    public void joinAndThrow() throws InterruptedException, Throwable {\n-        join();\n-        if (uncaught != null) {\n-            throw uncaught;\n-        }\n-    }\n-\n-    \/**\n-     * Waits during {@code timeout} for {@link TestThread} to die\n-     * and throws exception caught during the execution.\n-     *\n-     * @param timeout The time to wait in milliseconds\n-     * @throws InterruptedException\n-     * @throws Throwable\n-     *\/\n-    public void joinAndThrow(long timeout) throws InterruptedException,\n-            Throwable {\n-        join(timeout);\n-        if (isAlive()) {\n-            throw new TimeoutException();\n-        }\n-        if (uncaught != null) {\n-            throw uncaught;\n-        }\n-    }\n-\n-    \/**\n-     * Waits for {@link TestThread} to die\n-     * and returns exception caught during the execution.\n-     *\n-     * @return Exception caught during the execution\n-     * @throws InterruptedException\n-     *\/\n-    public Throwable joinAndReturn() throws InterruptedException {\n-        join();\n-        if (uncaught != null) {\n-            return uncaught;\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * Waits during {@code timeout} for {@link TestThread} to die\n-     * and returns exception caught during the execution.\n-     *\n-     * @param timeout The time to wait in milliseconds\n-     * @return Exception caught during the execution\n-     * @throws InterruptedException\n-     *\/\n-    public Throwable joinAndReturn(long timeout) throws InterruptedException {\n-        join(timeout);\n-        if (isAlive()) {\n-            return new TimeoutException();\n-        }\n-        if (uncaught != null) {\n-            return uncaught;\n-        }\n-        return null;\n-    }\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/jdk\/testlibrary\/TestThread.java","additions":0,"deletions":204,"binary":false,"changes":204,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.testlibrary;\n-\n-\/**\n- * This type serves no other purpose than to simply allow automatically running\n- * something in a thread, and have all exceptions propagated to\n- * RuntimeExceptions, which are thrown up to thread, which in turn should\n- * probably be a {@link TestThread} to they are stored.\n- *\/\n-public abstract class XRun implements Runnable {\n-\n-    \/**\n-     * Invokes {@code xrun()} and throws all exceptions caught in it\n-     * up to the thread.\n-     *\/\n-    public final void run() {\n-        try {\n-            xrun();\n-        } catch (Error e) {\n-            throw e;\n-        } catch (RuntimeException e) {\n-            throw e;\n-        } catch (Throwable e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    \/**\n-     * Override this method to implement what to run in the thread.\n-     *\n-     * @throws Throwable\n-     *\/\n-    protected abstract void xrun() throws Throwable;\n-}\n","filename":"test\/jdk\/lib\/testlibrary\/jdk\/testlibrary\/XRun.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.testlibrary.ProcessThread;\n+import jdk.test.lib.thread.ProcessThread;\n@@ -52,0 +52,1 @@\n+ * @library \/test\/lib\n","filename":"test\/jdk\/sun\/management\/jmxremote\/bootstrap\/JMXInterfaceBindingTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,323 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255410\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @run main\/othervm TestChaChaPoly\n+ * @summary test for PKCS#11 ChaCha20-Poly1305 Cipher.\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.GeneralSecurityException;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Arrays;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.NoSuchPaddingException;\n+\n+import jdk.test.lib.Utils;\n+\n+public class TestChaChaPoly extends PKCS11Test {\n+\n+    private static final byte[] NONCE\n+            = HexToBytes(\"012345670123456701234567\");\n+    private static final SecretKeySpec KEY = new SecretKeySpec(\n+            HexToBytes(\"0123456701234567012345670123456701234567012345670123456701234567\"),\n+            \"ChaCha20\");\n+    private static final ChaCha20ParameterSpec CHACHA20_PARAM_SPEC\n+            = new ChaCha20ParameterSpec(NONCE, 0);\n+    private static final IvParameterSpec IV_PARAM_SPEC\n+            = new IvParameterSpec(NONCE);\n+    private static final String ALGO = \"ChaCha20-Poly1305\";\n+    private static final SecureRandom RAND = new SecureRandom();\n+    private static Provider p;\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        System.out.println(\"Testing \" + p.getName());\n+        try {\n+            Cipher.getInstance(ALGO, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            System.out.println(\"Skip; no support for \" + ALGO);\n+            return;\n+        }\n+        this.p = p;\n+        testTransformations();\n+        testInit();\n+        testAEAD();\n+        testGetBlockSize();\n+        testGetIV();\n+        testInterop(\"SunJCE\");\n+    }\n+\n+    private static void testTransformations() throws Exception {\n+        System.out.println(\"== transformations ==\");\n+\n+        checkTransformation(p, ALGO, true);\n+        checkTransformation(p, ALGO + \"\/None\/NoPadding\", true);\n+        checkTransformation(p, ALGO + \"\/ECB\/NoPadding\", false);\n+        checkTransformation(p, ALGO + \"\/None\/PKCS5Padding\", false);\n+    }\n+\n+    private static void checkTransformation(Provider p, String t,\n+            boolean expected) throws Exception {\n+        try {\n+            Cipher.getInstance(t, p);\n+            if (!expected) {\n+                throw new RuntimeException( \"Should reject transformation: \" +\n+                        t);\n+            } else {\n+                System.out.println(\"Accepted transformation: \" + t);\n+            }\n+        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n+            if (!expected) {\n+                System.out.println(\"Rejected transformation: \" + t);\n+            } else {\n+                throw new RuntimeException(\"Should accept transformation: \" +\n+                        t, e);\n+            }\n+        }\n+    }\n+\n+    private static void testInit() throws Exception {\n+        testInitOnCrypt(Cipher.ENCRYPT_MODE);\n+        testInitOnCrypt(Cipher.DECRYPT_MODE);\n+    }\n+\n+    private static void testInitOnCrypt(int opMode) throws Exception {\n+        System.out.println(\"== init (\" + getOpModeName(opMode) + \") ==\");\n+\n+        \/\/ Need to acquire new Cipher object as ChaCha20-Poly1305 cipher\n+        \/\/ disallow reusing the same key and iv pair\n+        Cipher.getInstance(ALGO, p).init(opMode, KEY, IV_PARAM_SPEC);\n+        Cipher c = Cipher.getInstance(ALGO, p);\n+        c.init(opMode, KEY, IV_PARAM_SPEC, RAND);\n+        AlgorithmParameters params = c.getParameters();\n+        Cipher.getInstance(ALGO, p).init(opMode, KEY, params, RAND);\n+\n+        try {\n+            \/\/ try with invalid param\n+            Cipher.getInstance(ALGO, p).init(opMode, KEY, CHACHA20_PARAM_SPEC);\n+            throw new RuntimeException(\"Should reject non-IvparameterSpec\");\n+        } catch (InvalidAlgorithmParameterException e) {\n+            System.out.println(\"Expected IAPE - \" + e);\n+        }\n+    }\n+\n+    private static void testAEAD() throws Exception {\n+        byte[] expectedPt = HexToBytes(\"01234567\");\n+        byte[] ct = testUpdateAAD(Cipher.ENCRYPT_MODE, expectedPt);\n+        byte[] pt = testUpdateAAD(Cipher.DECRYPT_MODE, ct);\n+        if (pt != null && !Arrays.equals(pt, expectedPt)) {\n+            System.out.println(\"ciphertext: \" + Arrays.toString(ct));\n+            System.out.println(\"plaintext: \" + Arrays.toString(pt));\n+            throw new RuntimeException(\"AEAD failed\");\n+        }\n+    }\n+\n+    private static byte[] testUpdateAAD(int opMode, byte[] input)\n+            throws Exception {\n+        String opModeName = getOpModeName(opMode);\n+        System.out.println(\"== updateAAD (\" + opModeName + \") ==\");\n+\n+        byte[] aad = HexToBytes(\"0000\");\n+        ByteBuffer aadBuf = ByteBuffer.wrap(aad);\n+\n+        Cipher ccp = Cipher.getInstance(ALGO, p);\n+        try {\n+            ccp.updateAAD(aadBuf);\n+            throw new RuntimeException(\n+                    \"Should throw ISE for setting AAD on uninit'ed Cipher\");\n+        } catch (IllegalStateException e) {\n+            System.out.println(\"Expected ISE - \" + e);\n+        }\n+\n+        ccp.init(opMode, KEY, IV_PARAM_SPEC);\n+        ccp.update(input);\n+        try {\n+            ccp.updateAAD(aad);\n+            throw new RuntimeException(\n+                    \"Should throw ISE for setting AAD after update\");\n+        } catch (IllegalStateException e) {\n+            System.out.println(\"Expected ISE - \" + e);\n+        }\n+\n+        ccp.init(opMode, KEY, IV_PARAM_SPEC);\n+        ccp.updateAAD(aadBuf);\n+        return ccp.doFinal(input);\n+    }\n+\n+    private static void testGetBlockSize() throws Exception {\n+        testGetBlockSize(Cipher.ENCRYPT_MODE);\n+        testGetBlockSize(Cipher.DECRYPT_MODE);\n+    }\n+\n+    private static void testGetBlockSize(int opMode) throws Exception {\n+        System.out.println(\"== getBlockSize (\" + getOpModeName(opMode) + \") ==\");\n+        Cipher c = Cipher.getInstance(ALGO, p);\n+        if (c.getBlockSize() != 0) {\n+            throw new RuntimeException(\"Block size must be 0\");\n+        }\n+    }\n+\n+    private static void testGetIV() throws Exception {\n+        testGetIV(Cipher.ENCRYPT_MODE);\n+        testGetIV(Cipher.DECRYPT_MODE);\n+    }\n+\n+    private static void testGetIV(int opMode) throws Exception {\n+        System.out.println(\"== getIv (\" + getOpModeName(opMode) + \") ==\");\n+\n+        try {\n+            Cipher.getInstance(ALGO, p).getIV();\n+            Cipher.getInstance(ALGO, p).getParameters();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Should not throw ex\", e);\n+        }\n+        \/\/ first init w\/ key only\n+        AlgorithmParameters params = null;\n+        for (int i = 0; i < 6; i++) {\n+            System.out.println(\"IV test# \" + i);\n+            Cipher c = Cipher.getInstance(ALGO, p);\n+            byte[] expectedIV = NONCE;\n+            try {\n+                switch (i) {\n+                case 0: {\n+                    c.init(opMode, KEY);\n+                    expectedIV = null; \/\/ randomly-generated\n+                    break;\n+                }\n+                case 1: {\n+                    c.init(opMode, KEY, RAND);\n+                    expectedIV = null; \/\/ randomly-generated\n+                    break;\n+                }\n+                case 2: {\n+                    c.init(opMode, KEY, IV_PARAM_SPEC);\n+                    params = c.getParameters();\n+                    if (params == null) {\n+                        throw new RuntimeException(\"Params should not be null\");\n+                    }\n+                    break;\n+                }\n+                case 3: c.init(opMode, KEY, IV_PARAM_SPEC, RAND); break;\n+                case 4: c.init(opMode, KEY, params); break;\n+                case 5: c.init(opMode, KEY, params, RAND); break;\n+                }\n+                checkIV(c, expectedIV);\n+                System.out.println(\"=> Passed\");\n+            } catch (GeneralSecurityException e) {\n+                if (opMode == Cipher.DECRYPT_MODE && i < 2) {\n+                    System.out.println(\"=> Passed: Expected Ex thrown\");\n+                } else {\n+                    throw new RuntimeException(\"Should not throw ex\", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void checkIV(Cipher c, byte[] expectedIv) {\n+        \/\/ the specified cipher has been initialized; the returned IV and\n+        \/\/ AlgorithmParameters object should be non-null\n+        byte[] iv = c.getIV();\n+        AlgorithmParameters params = c.getParameters();\n+        \/\/ fail if either is null\n+        if (iv == null || params == null) {\n+            throw new RuntimeException(\"getIV()\/getParameters() should \" +\n+                    \"not return null\");\n+        }\n+\n+        \/\/ check iv matches if not null\n+        if (expectedIv != null && !Arrays.equals(expectedIv, iv)) {\n+            throw new RuntimeException(\"IV should match expected value\");\n+        }\n+\n+        try {\n+            byte[] iv2 = params.getParameterSpec(IvParameterSpec.class).getIV();\n+            if (!Arrays.equals(iv, iv2)) {\n+                throw new RuntimeException(\"IV values should be consistent\");\n+            }\n+        } catch (InvalidParameterSpecException ipe) {\n+            \/\/ should never happen\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    private static void testInterop(String interopProv) throws Exception {\n+        testInterop(Cipher.getInstance(ALGO, p),\n+                Cipher.getInstance(ALGO, interopProv));\n+        testInterop(Cipher.getInstance(ALGO, interopProv),\n+                Cipher.getInstance(ALGO, p));\n+    }\n+\n+    private static void testInterop(Cipher encCipher, Cipher decCipher)\n+            throws Exception {\n+        System.out.println(\"Interop: \" + encCipher.getProvider().getName() +\n+                \" -> \" + encCipher.getProvider().getName());\n+        byte[] pt = HexToBytes(\"012345678901234567890123456789\");\n+        encCipher.init(Cipher.ENCRYPT_MODE, KEY);\n+        byte[] ct = encCipher.doFinal(pt);\n+        decCipher.init(Cipher.DECRYPT_MODE, KEY, encCipher.getParameters());\n+        byte[] pt2 = decCipher.doFinal(ct);\n+        if (!Arrays.equals(pt, pt2)) {\n+            System.out.println(\"HexDump\/pt: \" + toHexString(pt));\n+            System.out.println(\"HexDump\/pt2: \" + toHexString(pt2));\n+            throw new RuntimeException(\"Recovered data should match\");\n+        }\n+        System.out.println(\"=> Passed\");\n+    }\n+\n+    private static String getOpModeName(int opMode) {\n+        switch (opMode) {\n+        case Cipher.ENCRYPT_MODE:\n+            return \"ENCRYPT\";\n+\n+        case Cipher.DECRYPT_MODE:\n+            return \"DECRYPT\";\n+\n+        case Cipher.WRAP_MODE:\n+            return \"WRAP\";\n+\n+        case Cipher.UNWRAP_MODE:\n+            return \"UNWRAP\";\n+\n+        default:\n+            return \"\";\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestChaChaPoly(), args);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPoly.java","additions":323,"deletions":0,"binary":false,"changes":323,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8255410\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @build jdk.test.lib.Convert\n+ * @run main\/othervm TestChaChaPolyKAT\n+ * @summary ChaCha20-Poly1305 Cipher Implementation (KAT)\n+ *\/\n+\n+import java.util.*;\n+import java.security.GeneralSecurityException;\n+import java.security.Provider;\n+import java.security.NoSuchAlgorithmException;\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.AEADBadTagException;\n+import java.nio.ByteBuffer;\n+import jdk.test.lib.Convert;\n+\n+public class TestChaChaPolyKAT extends PKCS11Test {\n+\n+    public static class TestData {\n+        public TestData(String name, String keyStr, String nonceStr, int ctr,\n+                int dir, String inputStr, String aadStr, String outStr) {\n+            testName = Objects.requireNonNull(name);\n+            key = HexToBytes(Objects.requireNonNull(keyStr));\n+            nonce = HexToBytes(Objects.requireNonNull(nonceStr));\n+            if ((counter = ctr) < 0) {\n+                throw new IllegalArgumentException(\n+                        \"counter must be 0 or greater\");\n+            }\n+            direction = dir;\n+            if ((direction != Cipher.ENCRYPT_MODE) &&\n+                    (direction != Cipher.DECRYPT_MODE)) {\n+                throw new IllegalArgumentException(\n+                        \"Direction must be ENCRYPT_MODE or DECRYPT_MODE\");\n+            }\n+            input = HexToBytes(Objects.requireNonNull(inputStr));\n+            aad = (aadStr != null) ? HexToBytes(aadStr) : null;\n+            expOutput = HexToBytes(Objects.requireNonNull(outStr));\n+        }\n+\n+        public final String testName;\n+        public final byte[] key;\n+        public final byte[] nonce;\n+        public final int counter;\n+        public final int direction;\n+        public final byte[] input;\n+        public final byte[] aad;\n+        public final byte[] expOutput;\n+    }\n+\n+    private static final String ALGO = \"ChaCha20-Poly1305\";\n+\n+    public static final List<TestData> aeadTestList =\n+            new LinkedList<TestData>() {{\n+        add(new TestData(\"RFC 7539 Sample AEAD Test Vector\",\n+            \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\",\n+            \"070000004041424344454647\",\n+            1, Cipher.ENCRYPT_MODE,\n+            \"4c616469657320616e642047656e746c656d656e206f662074686520636c6173\" +\n+            \"73206f66202739393a204966204920636f756c64206f6666657220796f75206f\" +\n+            \"6e6c79206f6e652074697020666f7220746865206675747572652c2073756e73\" +\n+            \"637265656e20776f756c642062652069742e\",\n+            \"50515253c0c1c2c3c4c5c6c7\",\n+            \"d31a8d34648e60db7b86afbc53ef7ec2a4aded51296e08fea9e2b5a736ee62d6\" +\n+            \"3dbea45e8ca9671282fafb69da92728b1a71de0a9e060b2905d6a5b67ecd3b36\" +\n+            \"92ddbd7f2d778b8c9803aee328091b58fab324e4fad675945585808b4831d7bc\" +\n+            \"3ff4def08e4b7a9de576d26586cec64b61161ae10b594f09e26a7e902ecbd060\" +\n+            \"0691\"));\n+        add(new TestData(\"RFC 7539 A.5 Sample Decryption\",\n+            \"1c9240a5eb55d38af333888604f6b5f0473917c1402b80099dca5cbc207075c0\",\n+            \"000000000102030405060708\",\n+            1, Cipher.DECRYPT_MODE,\n+            \"64a0861575861af460f062c79be643bd5e805cfd345cf389f108670ac76c8cb2\" +\n+            \"4c6cfc18755d43eea09ee94e382d26b0bdb7b73c321b0100d4f03b7f355894cf\" +\n+            \"332f830e710b97ce98c8a84abd0b948114ad176e008d33bd60f982b1ff37c855\" +\n+            \"9797a06ef4f0ef61c186324e2b3506383606907b6a7c02b0f9f6157b53c867e4\" +\n+            \"b9166c767b804d46a59b5216cde7a4e99040c5a40433225ee282a1b0a06c523e\" +\n+            \"af4534d7f83fa1155b0047718cbc546a0d072b04b3564eea1b422273f548271a\" +\n+            \"0bb2316053fa76991955ebd63159434ecebb4e466dae5a1073a6727627097a10\" +\n+            \"49e617d91d361094fa68f0ff77987130305beaba2eda04df997b714d6c6f2c29\" +\n+            \"a6ad5cb4022b02709beead9d67890cbb22392336fea1851f38\",\n+            \"f33388860000000000004e91\",\n+            \"496e7465726e65742d4472616674732061726520647261667420646f63756d65\" +\n+            \"6e74732076616c696420666f722061206d6178696d756d206f6620736978206d\" +\n+            \"6f6e74687320616e64206d617920626520757064617465642c207265706c6163\" +\n+            \"65642c206f72206f62736f6c65746564206279206f7468657220646f63756d65\" +\n+            \"6e747320617420616e792074696d652e20497420697320696e617070726f7072\" +\n+            \"6961746520746f2075736520496e7465726e65742d4472616674732061732072\" +\n+            \"65666572656e6365206d6174657269616c206f7220746f206369746520746865\" +\n+            \"6d206f74686572207468616e206173202fe2809c776f726b20696e2070726f67\" +\n+            \"726573732e2fe2809d\"));\n+    }};\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        System.out.println(\"Testing \" + p.getName());\n+\n+        try {\n+            Cipher.getInstance(ALGO, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            System.out.println(\"Skip; no support for \" + ALGO);\n+            return;\n+        }\n+\n+        int testsPassed = 0;\n+        int testNumber = 0;\n+\n+        System.out.println(\"----- AEAD Tests -----\");\n+        for (TestData test : aeadTestList) {\n+            System.out.println(\"*** Test \" + ++testNumber + \": \" +\n+                    test.testName);\n+            if (runAEADTest(p, test)) {\n+                testsPassed++;\n+            }\n+        }\n+        System.out.println();\n+\n+        System.out.println(\"Total tests: \" + testNumber +\n+                \", Passed: \" + testsPassed + \", Failed: \" +\n+                (testNumber - testsPassed));\n+        if (testsPassed != testNumber) {\n+            throw new RuntimeException(\"One or more tests failed.  \" +\n+                    \"Check output for details\");\n+        }\n+    }\n+\n+    private static boolean runAEADTest(Provider p, TestData testData)\n+            throws GeneralSecurityException {\n+        boolean result = false;\n+\n+        Cipher mambo = Cipher.getInstance(ALGO, p);\n+        SecretKeySpec mamboKey = new SecretKeySpec(testData.key, \"ChaCha20\");\n+        IvParameterSpec mamboSpec = new IvParameterSpec(testData.nonce);\n+\n+        mambo.init(testData.direction, mamboKey, mamboSpec);\n+\n+        byte[] out = new byte[mambo.getOutputSize(testData.input.length)];\n+        int outOff = 0;\n+        try {\n+            mambo.updateAAD(testData.aad);\n+            outOff += mambo.update(testData.input, 0, testData.input.length,\n+                    out, outOff);\n+            outOff += mambo.doFinal(out, outOff);\n+        } catch (AEADBadTagException abte) {\n+            \/\/ If we get a bad tag or derive a tag mismatch, log it\n+            \/\/ and register it as a failure\n+            System.out.println(\"FAIL: \" + abte);\n+            return false;\n+        }\n+\n+        if (!Arrays.equals(out, 0, outOff, testData.expOutput, 0, outOff)) {\n+            System.out.println(\"ERROR - Output Mismatch!\");\n+            System.out.println(\"Expected:\\n\" +\n+                    dumpHexBytes(testData.expOutput, 16, \"\\n\", \" \"));\n+            System.out.println(\"Actual:\\n\" +\n+                    dumpHexBytes(out, 16, \"\\n\", \" \"));\n+            System.out.println();\n+        } else {\n+            result = true;\n+        }\n+\n+        return result;\n+    }\n+\n+    \/**\n+     * Dump the hex bytes of a buffer into string form.\n+     *\n+     * @param data The array of bytes to dump to stdout.\n+     * @param itemsPerLine The number of bytes to display per line\n+     *      if the {@code lineDelim} character is blank then all bytes\n+     *      will be printed on a single line.\n+     * @param lineDelim The delimiter between lines\n+     * @param itemDelim The delimiter between bytes\n+     *\n+     * @return The hexdump of the byte array\n+     *\/\n+    private static String dumpHexBytes(byte[] data, int itemsPerLine,\n+            String lineDelim, String itemDelim) {\n+        return dumpHexBytes(ByteBuffer.wrap(data), itemsPerLine, lineDelim,\n+                itemDelim);\n+    }\n+\n+    private static String dumpHexBytes(ByteBuffer data, int itemsPerLine,\n+            String lineDelim, String itemDelim) {\n+        StringBuilder sb = new StringBuilder();\n+        if (data != null) {\n+            data.mark();\n+            int i = 0;\n+            while (data.remaining() > 0) {\n+                if (i % itemsPerLine == 0 && i != 0) {\n+                    sb.append(lineDelim);\n+                }\n+                sb.append(String.format(\"%02X\", data.get())).append(itemDelim);\n+                i++;\n+            }\n+            data.reset();\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestChaChaPolyKAT(), args);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyKAT.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,267 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8255410\n+ * @library \/test\/lib ..\n+ * @run main\/othervm TestChaChaPolyNoReuse\n+ * @summary Test PKCS#11 ChaCha20-Poly1305 Cipher Implementation\n+ * (key\/nonce reuse check)\n+ *\/\n+\n+import java.util.*;\n+import javax.crypto.Cipher;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.Provider;\n+import java.security.NoSuchAlgorithmException;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.AEADBadTagException;\n+import javax.crypto.SecretKey;\n+import java.security.InvalidKeyException;\n+import java.security.InvalidAlgorithmParameterException;\n+\n+public class TestChaChaPolyNoReuse extends PKCS11Test {\n+\n+    private static final String KEY_ALGO = \"ChaCha20\";\n+    private static final String CIPHER_ALGO = \"ChaCha20-Poly1305\";\n+\n+    \/**\n+     * Basic TestMethod interface definition\n+     *\/\n+    public interface TestMethod {\n+        \/**\n+         * Runs the actual test case\n+         *\n+         * @param provider the provider to provide the requested Cipher obj.\n+         *\n+         * @return true if the test passes, false otherwise.\n+         *\/\n+        boolean run(Provider p);\n+    }\n+\n+    public static class TestData {\n+        public TestData(String name, String keyStr, String nonceStr, int ctr,\n+                int dir, String inputStr, String aadStr, String outStr) {\n+            testName = Objects.requireNonNull(name);\n+            key = HexToBytes(keyStr);\n+            nonce = HexToBytes(nonceStr);\n+            if ((counter = ctr) < 0) {\n+                throw new IllegalArgumentException(\n+                        \"counter must be 0 or greater\");\n+            }\n+            direction = dir;\n+            if (direction != Cipher.ENCRYPT_MODE) {\n+                throw new IllegalArgumentException(\n+                        \"Direction must be ENCRYPT_MODE\");\n+            }\n+            input = HexToBytes(inputStr);\n+            aad = (aadStr != null) ? HexToBytes(aadStr) : null;\n+            expOutput = HexToBytes(outStr);\n+        }\n+\n+        public final String testName;\n+        public final byte[] key;\n+        public final byte[] nonce;\n+        public final int counter;\n+        public final int direction;\n+        public final byte[] input;\n+        public final byte[] aad;\n+        public final byte[] expOutput;\n+    }\n+\n+    public static final List<TestData> aeadTestList =\n+            new LinkedList<TestData>() {{\n+        add(new TestData(\"RFC 7539 Sample AEAD Test Vector\",\n+            \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\",\n+            \"070000004041424344454647\",\n+            1, Cipher.ENCRYPT_MODE,\n+            \"4c616469657320616e642047656e746c656d656e206f662074686520636c6173\" +\n+            \"73206f66202739393a204966204920636f756c64206f6666657220796f75206f\" +\n+            \"6e6c79206f6e652074697020666f7220746865206675747572652c2073756e73\" +\n+            \"637265656e20776f756c642062652069742e\",\n+            \"50515253c0c1c2c3c4c5c6c7\",\n+            \"d31a8d34648e60db7b86afbc53ef7ec2a4aded51296e08fea9e2b5a736ee62d6\" +\n+            \"3dbea45e8ca9671282fafb69da92728b1a71de0a9e060b2905d6a5b67ecd3b36\" +\n+            \"92ddbd7f2d778b8c9803aee328091b58fab324e4fad675945585808b4831d7bc\" +\n+            \"3ff4def08e4b7a9de576d26586cec64b61161ae10b594f09e26a7e902ecbd060\" +\n+            \"0691\"));\n+    }};\n+\n+    \/**\n+     * Make sure we do not use this Cipher object without initializing it\n+     * at all\n+     *\/\n+    public static final TestMethod noInitTest = new TestMethod() {\n+        @Override\n+        public boolean run(Provider p) {\n+            System.out.println(\"----- No Init Test -----\");\n+            try {\n+                Cipher cipher = Cipher.getInstance(CIPHER_ALGO, p);\n+                TestData testData = aeadTestList.get(0);\n+\n+                \/\/ Attempting to use the cipher without initializing it\n+                \/\/ should throw an IllegalStateException\n+                try {\n+                    cipher.updateAAD(testData.aad);\n+                    throw new RuntimeException(\n+                            \"Expected IllegalStateException not thrown\");\n+                } catch (IllegalStateException ise) {\n+                    \/\/ Do nothing, this is what we expected to happen\n+                }\n+            } catch (Exception exc) {\n+                System.out.println(\"Unexpected exception: \" + exc);\n+                exc.printStackTrace();\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+    };\n+\n+    \/**\n+     * Attempt to run two full encryption operations without an init in\n+     * between.\n+     *\/\n+    public static final TestMethod encTwiceNoInit = new TestMethod() {\n+        @Override\n+        public boolean run(Provider p) {\n+            System.out.println(\"----- Encrypt 2nd time without init -----\");\n+            try {\n+                AlgorithmParameterSpec spec;\n+                Cipher cipher = Cipher.getInstance(CIPHER_ALGO, p);\n+                TestData testData = aeadTestList.get(0);\n+                spec = new IvParameterSpec(testData.nonce);\n+                SecretKey key = new SecretKeySpec(testData.key, KEY_ALGO);\n+\n+                \/\/ Initialize and encrypt\n+                cipher.init(testData.direction, key, spec);\n+                cipher.updateAAD(testData.aad);\n+                cipher.doFinal(testData.input);\n+                System.out.println(\"First encryption complete\");\n+\n+                \/\/ Now attempt to encrypt again without changing the key\/IV\n+                \/\/ This should fail.\n+                try {\n+                    cipher.updateAAD(testData.aad);\n+                } catch (IllegalStateException ise) {\n+                    \/\/ Do nothing, this is what we expected to happen\n+                }\n+                try {\n+                    cipher.doFinal(testData.input);\n+                    throw new RuntimeException(\n+                            \"Expected IllegalStateException not thrown\");\n+                } catch (IllegalStateException ise) {\n+                    \/\/ Do nothing, this is what we expected to happen\n+                }\n+            } catch (Exception exc) {\n+                System.out.println(\"Unexpected exception: \" + exc);\n+                exc.printStackTrace();\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+    };\n+\n+    \/**\n+     * Encrypt once successfully, then attempt to init with the same\n+     * key and nonce.\n+     *\/\n+    public static final TestMethod encTwiceInitSameParams = new TestMethod() {\n+        @Override\n+        public boolean run(Provider p) {\n+            System.out.println(\"----- Encrypt, then init with same params \" +\n+                     \"-----\");\n+            try {\n+                AlgorithmParameterSpec spec;\n+                Cipher cipher = Cipher.getInstance(CIPHER_ALGO, p);\n+                TestData testData = aeadTestList.get(0);\n+                spec = new IvParameterSpec(testData.nonce);\n+                SecretKey key = new SecretKeySpec(testData.key, KEY_ALGO);\n+\n+                \/\/ Initialize then encrypt\n+                cipher.init(testData.direction, key, spec);\n+                cipher.updateAAD(testData.aad);\n+                cipher.doFinal(testData.input);\n+                System.out.println(\"First encryption complete\");\n+\n+                \/\/ Initializing after the completed encryption with\n+                \/\/ the same key and nonce should fail.\n+                try {\n+                    cipher.init(testData.direction, key, spec);\n+                    throw new RuntimeException(\n+                            \"Expected IKE or IAPE not thrown\");\n+                } catch (InvalidKeyException |\n+                        InvalidAlgorithmParameterException e) {\n+                    \/\/ Do nothing, this is what we expected to happen\n+                }\n+            } catch (Exception exc) {\n+                System.out.println(\"Unexpected exception: \" + exc);\n+                exc.printStackTrace();\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+    };\n+\n+    public static final List<TestMethod> testMethodList =\n+            Arrays.asList(noInitTest, encTwiceNoInit, encTwiceInitSameParams);\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        System.out.println(\"Testing \" + p.getName());\n+        try {\n+            Cipher.getInstance(CIPHER_ALGO, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            System.out.println(\"Skip; no support for \" + CIPHER_ALGO);\n+            return;\n+        }\n+\n+        int testsPassed = 0;\n+        int testNumber = 0;\n+\n+        for (TestMethod tm : testMethodList) {\n+            testNumber++;\n+            boolean result = tm.run(p);\n+            System.out.println(\"Result: \" + (result ? \"PASS\" : \"FAIL\"));\n+            if (result) {\n+                testsPassed++;\n+            }\n+        }\n+\n+        System.out.println(\"Total Tests: \" + testNumber +\n+                \", Tests passed: \" + testsPassed);\n+        if (testsPassed < testNumber) {\n+            throw new RuntimeException(\n+                    \"Not all tests passed.  See output for failure info\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestChaChaPolyNoReuse(), args);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyNoReuse.java","additions":267,"deletions":0,"binary":false,"changes":267,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8255410\n+ * @summary Check ChaCha20-Poly1305 cipher output size\n+ * @library \/test\/lib ..\n+ * @build jdk.test.lib.Convert\n+ * @run main TestChaChaPolyOutputSize\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.security.GeneralSecurityException;\n+import java.security.Key;\n+import java.security.SecureRandom;\n+import java.security.Provider;\n+import java.security.NoSuchAlgorithmException;\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+public class TestChaChaPolyOutputSize extends PKCS11Test {\n+\n+    private static final SecureRandom SR = new SecureRandom();\n+\n+    private static final SecretKeySpec KEY = new SecretKeySpec(new byte[32],\n+            \"ChaCha20\");\n+\n+    private static final String ALGO = \"ChaCha20-Poly1305\";\n+\n+    public static void main(String args[]) throws Exception {\n+        main(new TestChaChaPolyOutputSize(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws GeneralSecurityException {\n+        System.out.println(\"Testing \" + p.getName());\n+        try {\n+            Cipher.getInstance(ALGO, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            System.out.println(\"Skip; no support for \" + ALGO);\n+            return;\n+        }\n+        testGetOutSize(p);\n+        testMultiPartAEADDec(p);\n+    }\n+\n+    private static void testGetOutSize(Provider p)\n+            throws GeneralSecurityException {\n+\n+        Cipher ccp = Cipher.getInstance(ALGO, p);\n+        ccp.init(Cipher.ENCRYPT_MODE, KEY,\n+                new IvParameterSpec(getRandBuf(12)));\n+\n+        \/\/ Encryption lengths are calculated as the input length plus the tag\n+        \/\/ length (16).\n+        testOutLen(ccp, 0, 16);\n+        testOutLen(ccp, 5, 21);\n+        testOutLen(ccp, 5120, 5136);\n+        \/\/ perform an update, then test with a final block\n+        byte[] input = new byte[5120];\n+        SR.nextBytes(input);\n+        byte[] updateOut = ccp.update(input);\n+        testOutLen(ccp, 1024, 1040 +\n+                (5120 - (updateOut == null? 0 : updateOut.length)));\n+\n+        \/\/ Decryption lengths are handled differently for AEAD mode.  The length\n+        \/\/ should be zero for anything up to and including the first 16 bytes\n+        \/\/ (since that's the tag).  Anything above that should be the input\n+        \/\/ length plus any unprocessed input (via update calls), minus the\n+        \/\/ 16 byte tag.\n+        ccp.init(Cipher.DECRYPT_MODE, KEY, new IvParameterSpec(getRandBuf(12)));\n+        testOutLen(ccp, 0, 0);\n+        testOutLen(ccp, 5, 0);\n+        testOutLen(ccp, 16, 0);\n+        testOutLen(ccp, 5120, 5104);\n+        \/\/ Perform an update, then test with the length of a final chunk\n+        \/\/ of data.\n+        updateOut = ccp.update(input);\n+        testOutLen(ccp, 1024, 6128 - (updateOut == null? 0 : updateOut.length));\n+    }\n+\n+    private static void testMultiPartAEADDec(Provider p)\n+            throws GeneralSecurityException {\n+        IvParameterSpec ivps = new IvParameterSpec(getRandBuf(12));\n+\n+        \/\/ Encrypt some data so we can test decryption.\n+        byte[] pText = getRandBuf(2048);\n+        ByteBuffer pTextBase = ByteBuffer.wrap(pText);\n+\n+        Cipher enc = Cipher.getInstance(ALGO, p);\n+        enc.init(Cipher.ENCRYPT_MODE, KEY, ivps);\n+        ByteBuffer ctBuf = ByteBuffer.allocateDirect(\n+                enc.getOutputSize(pText.length));\n+        enc.doFinal(pTextBase, ctBuf);\n+\n+        \/\/ Create a new direct plain text ByteBuffer which will catch the\n+        \/\/ decrypted data.\n+        ByteBuffer ptBuf = ByteBuffer.allocateDirect(pText.length);\n+\n+        \/\/ Set the cipher text buffer limit to roughly half the data so we can\n+        \/\/ do an update\/final sequence.\n+        ctBuf.position(0).limit(1024);\n+\n+        Cipher dec = Cipher.getInstance(ALGO, p);\n+        dec.init(Cipher.DECRYPT_MODE, KEY, ivps);\n+        dec.update(ctBuf, ptBuf);\n+        System.out.println(\"CTBuf: \" + ctBuf);\n+        System.out.println(\"PTBuf: \" + ptBuf);\n+        ctBuf.limit(ctBuf.capacity());\n+        dec.doFinal(ctBuf, ptBuf);\n+\n+        \/\/ NOTE: do not use flip() which will set limit based on current\n+        \/\/ position. ptBuf curr pos = 2048 vs pTextBase pos = 0\n+        ptBuf.flip();\n+        pTextBase.flip();\n+        System.out.println(\"PT Base:\" + pTextBase);\n+        System.out.println(\"PT Actual:\" + ptBuf);\n+\n+        if (pTextBase.compareTo(ptBuf) != 0) {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Plaintext mismatch: Original: \").\n+                    append(pTextBase.toString()).append(\"\\nActual :\").\n+                    append(ptBuf);\n+            throw new RuntimeException(sb.toString());\n+        }\n+    }\n+\n+    private static void testOutLen(Cipher c, int inLen, int expOut) {\n+        int actualOut = c.getOutputSize(inLen);\n+        if (actualOut != expOut) {\n+            throw new RuntimeException(\"Cipher \" + c + \", in: \" + inLen +\n+                    \", expOut: \" + expOut + \", actual: \" + actualOut);\n+        }\n+    }\n+\n+    private static byte[] getRandBuf(int len) {\n+        byte[] buf = new byte[len];\n+        SR.nextBytes(buf);\n+        return buf;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyOutputSize.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -42,12 +42,0 @@\n-    \/\/ Utility methods\n-    private static byte[] HexToBytes(String hexVal) {\n-        if (hexVal == null) return new byte[0];\n-        byte[] result = new byte[hexVal.length()\/2];\n-        for (int i = 0; i < result.length; i++) {\n-            \/\/ 2 characters at a time\n-            String byteVal = hexVal.substring(2*i, 2*i +2);\n-            result[i] = Integer.valueOf(byteVal, 16).byteValue();\n-        }\n-        return result;\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestKATForGCM.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255410\n+ * @modules jdk.crypto.cryptoki\n+ * @summary Check ChaCha20 key generator.\n+ * @library \/test\/lib ..\n+ * @run main\/othervm TestChaCha20\n+ *\/\n+import java.security.Provider;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidParameterException;\n+import java.security.NoSuchAlgorithmException;\n+\n+import javax.crypto.KeyGenerator;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+\n+public class TestChaCha20 extends PKCS11Test {\n+\n+    private static final String ALGO = \"ChaCha20\";\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestChaCha20(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        System.out.println(\"Testing \" + p.getName());\n+        KeyGenerator kg;\n+        try {\n+            kg = KeyGenerator.getInstance(ALGO, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            System.out.println(\"Skip; no support for \" + ALGO);\n+            return;\n+        }\n+\n+        try {\n+            kg.init(new ChaCha20ParameterSpec(new byte[12], 0));\n+            throw new RuntimeException(\n+                    \"ChaCha20 key generation should not need any paramSpec\");\n+        } catch (InvalidAlgorithmParameterException e) {\n+            System.out.println(\"Expected IAPE: \" + e.getMessage());\n+        }\n+\n+        for (int keySize : new int[] { 32, 64, 128, 256, 512, 1024 }) {\n+            try {\n+                kg.init(keySize);\n+                if (keySize != 256) {\n+                    throw new RuntimeException(keySize + \" is invalid keysize\");\n+                }\n+            } catch (InvalidParameterException e) {\n+                if (keySize == 256) {\n+                    throw new RuntimeException(\"IPE thrown for valid keySize\");\n+                } else {\n+                    System.out.println(\"Expected IPE thrown for \" + keySize);\n+                }\n+            }\n+        }\n+\n+        \/\/kg.init(256);\n+        SecretKey key = kg.generateKey();\n+        byte[] keyValue = key.getEncoded();\n+        System.out.println(\"Key: \" + toHexString(keyValue));\n+        if (keyValue.length != 32) {\n+            throw new RuntimeException(\"The size of generated key must be 256\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyGenerator\/TestChaCha20.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -114,0 +114,34 @@\n+    \/\/ Utility methods\n+    \/\/ Used to backport HexFormat from 17.\n+    protected static byte[] HexToBytes(String hexVal) {\n+        if (hexVal == null) return new byte[0];\n+        byte[] result = new byte[hexVal.length()\/2];\n+        for (int i = 0; i < result.length; i++) {\n+            \/\/ 2 characters at a time\n+            String byteVal = hexVal.substring(2*i, 2*i +2);\n+            result[i] = Integer.valueOf(byteVal, 16).byteValue();\n+        }\n+        return result;\n+    }\n+    private static void byte2hex(byte b, StringBuffer buf) {\n+        char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',\n+                            '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n+        int high = ((b & 0xf0) >> 4);\n+        int low = (b & 0x0f);\n+        buf.append(hexChars[high]);\n+        buf.append(hexChars[low]);\n+    }\n+    protected static String toHexString(byte[] block) {\n+        StringBuffer buf = new StringBuffer();\n+\n+        int len = block.length;\n+\n+        for (int i = 0; i < len; i++) {\n+             byte2hex(block[i], buf);\n+             if (i < len-1) {\n+                 buf.append(\":\");\n+             }\n+        }\n+        return buf.toString();\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255410\n+ * @summary test the general SecretKeyFactory functionality\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @run main\/othervm TestGeneral\n+ *\/\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.util.Arrays;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+public class TestGeneral extends PKCS11Test {\n+\n+    private enum TestResult {\n+        PASS,\n+        FAIL,\n+        TBD \/\/ unused for now\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestGeneral(), args);\n+    }\n+\n+    private void test(String algorithm, SecretKey key, Provider p,\n+            TestResult expected) throws RuntimeException {\n+        System.out.println(\"Testing \" + algorithm + \" SKF from \" + p.getName());\n+        SecretKeyFactory skf;\n+        try {\n+            skf = SecretKeyFactory.getInstance(algorithm, p);\n+        } catch (NoSuchAlgorithmException e) {\n+            System.out.println(\"Not supported, skipping: \" + e);\n+            return;\n+        }\n+        try {\n+            SecretKey key2 = skf.translateKey(key);\n+            if (expected == TestResult.FAIL) {\n+                throw new RuntimeException(\"translateKey() should FAIL\");\n+            }\n+            System.out.println(\"=> translated key\");\n+            if (!key2.getAlgorithm().equalsIgnoreCase(algorithm)) {\n+                throw new RuntimeException(\"translated key algorithm mismatch\");\n+            }\n+            System.out.println(\"=> checked key algorithm\");\n+\n+            \/\/ proceed to check encodings if format match\n+            if (key2.getFormat().equalsIgnoreCase(key.getFormat())) {\n+                if (key2.getEncoded() != null &&\n+                        !Arrays.equals(key.getEncoded(), key2.getEncoded())) {\n+                    throw new RuntimeException(\n+                            \"translated key encoding mismatch\");\n+                }\n+                System.out.println(\"=> checked key format and encoding\");\n+            }\n+        } catch (Exception e) {\n+            if (expected == TestResult.PASS) {\n+                e.printStackTrace();\n+                throw new RuntimeException(\"translateKey() should pass\", e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+\n+        byte[] rawBytes = new byte[32];\n+        new SecureRandom().nextBytes(rawBytes);\n+\n+        SecretKey aes_128Key = new SecretKeySpec(rawBytes, 0, 16, \"AES\");\n+        SecretKey aes_256Key = new SecretKeySpec(rawBytes, 0, 32, \"AES\");\n+        SecretKey bf_128Key = new SecretKeySpec(rawBytes, 0, 16, \"Blowfish\");\n+        SecretKey cc20Key = new SecretKeySpec(rawBytes, 0, 32, \"ChaCha20\");\n+\n+        \/\/ fixed key length\n+        test(\"AES\", aes_128Key, p, TestResult.PASS);\n+        test(\"AES\", aes_256Key, p, TestResult.PASS);\n+        test(\"AES\", cc20Key, p, TestResult.FAIL);\n+\n+        test(\"ChaCha20\", aes_128Key, p, TestResult.FAIL);\n+        test(\"ChaCha20\", aes_256Key, p, TestResult.FAIL);\n+        test(\"ChaCha20\", cc20Key, p, TestResult.PASS);\n+\n+        \/\/ variable key length\n+        \/\/ Different PKCS11 impls may have different ranges\n+        \/\/ of supported key sizes for variable-key-length\n+        \/\/ algorithms.\n+        test(\"Blowfish\", aes_128Key, p, TestResult.FAIL);\n+        test(\"Blowfish\", cc20Key, p, TestResult.FAIL);\n+        test(\"Blowfish\", bf_128Key, p, TestResult.PASS);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/SecretKeyFactory\/TestGeneral.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -110,29 +110,0 @@\n-    \/*\n-     * Converts a byte to hex digit and writes to the supplied buffer\n-     *\/\n-    private void byte2hex(byte b, StringBuffer buf) {\n-        char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',\n-                            '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n-        int high = ((b & 0xf0) >> 4);\n-        int low = (b & 0x0f);\n-        buf.append(hexChars[high]);\n-        buf.append(hexChars[low]);\n-    }\n-\n-    \/*\n-     * Converts a byte array to hex string\n-     *\/\n-    private String toHexString(byte[] block) {\n-        StringBuffer buf = new StringBuffer();\n-\n-        int len = block.length;\n-\n-        for (int i = 0; i < len; i++) {\n-             byte2hex(block[i], buf);\n-             if (i < len-1) {\n-                 buf.append(\":\");\n-             }\n-        }\n-        return buf.toString();\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/TestLeadingZeroesP11.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-package jdk.testlibrary;\n-\n@@ -28,0 +26,4 @@\n+import jdk.testlibrary.OutputAnalyzer;\n+import jdk.testlibrary.ProcessTools;\n+import jdk.testlibrary.JDKToolLauncher;\n+\n","filename":"test\/jdk\/sun\/tools\/jcmd\/JcmdBase.java","additions":5,"deletions":3,"binary":false,"changes":8,"previous_filename":"test\/jdk\/lib\/testlibrary\/jdk\/testlibrary\/JcmdBase.java","status":"renamed"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.testlibrary.JcmdBase;\n","filename":"test\/jdk\/sun\/tools\/jcmd\/TestJcmdDefaults.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import jdk.testlibrary.JcmdBase;\n","filename":"test\/jdk\/sun\/tools\/jcmd\/TestJcmdSanity.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.thread.ProcessThread;\n@@ -33,2 +35,0 @@\n-import jdk.testlibrary.OutputAnalyzer;\n-import jdk.testlibrary.ProcessThread;\n","filename":"test\/jdk\/sun\/tools\/jstatd\/JstatdTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @library \/test\/lib\n","filename":"test\/jdk\/sun\/tools\/jstatd\/TestJstatdDefaults.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @library \/test\/lib\n","filename":"test\/jdk\/sun\/tools\/jstatd\/TestJstatdExternalRegistry.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @library \/test\/lib\n","filename":"test\/jdk\/sun\/tools\/jstatd\/TestJstatdPort.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @library \/test\/lib\n","filename":"test\/jdk\/sun\/tools\/jstatd\/TestJstatdPortAndServer.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+ * @library \/test\/lib\n","filename":"test\/jdk\/sun\/tools\/jstatd\/TestJstatdServer.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+ * @library \/test\/lib\n","filename":"test\/jdk\/sun\/tools\/jstatd\/TestJstatdUsage.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7029048\n+ * @bug 7029048 8217340\n@@ -29,0 +29,1 @@\n+ * @library \/test\/lib\n@@ -43,3 +44,0 @@\n-    static int passes = 0;\n-    static int errors = 0;\n-\n@@ -64,2 +62,0 @@\n-    private static final Map<String, String> env = new HashMap<>();\n-\n@@ -76,2 +72,4 @@\n-    static void run(Map<String, String> env,\n-            int nLLPComponents, String caseID) {\n+    static boolean run(int nLLPComponents, File variantDir, String caseID) {\n+\n+        Map<String, String> env = new HashMap<>();\n+        env.put(LD_LIBRARY_PATH, variantDir.getAbsolutePath());\n@@ -87,1 +85,9 @@\n-        analyze(tr, nLLPComponents, caseID);\n+        int len = getLLPComponents(tr);\n+        if (len == nLLPComponents) {\n+            System.out.printf(\"Test7029048 OK %s%n\", caseID);\n+            return true;\n+        } else {\n+            System.out.printf(\"Test7029048 FAIL %s: expected %d but got %d%n\",\n+                    caseID, nLLPComponents, len);\n+            return false;\n+        }\n@@ -90,1 +96,1 @@\n-    static void analyze(TestResult tr, int nLLPComponents, String caseID) {\n+    static int getLLPComponents(TestResult tr) {\n@@ -99,11 +105,3 @@\n-        int len = (envValue.equals(\"null\")\n-                   ? 0 : envValue.split(File.pathSeparator).length);\n-        if (len == nLLPComponents) {\n-            System.out.println(caseID + \": OK\");\n-            passes++;\n-        } else {\n-            System.out.println(\"FAIL: test7029048, \" + caseID);\n-            System.out.println(\" expected \" + nLLPComponents\n-                               + \" but got \" + len);\n-            System.out.println(envValue);\n-            errors++;\n+\n+        if (envValue.equals(\"null\")) {\n+            return 0;\n@@ -111,0 +109,2 @@\n+\n+        return envValue.split(File.pathSeparator).length;\n@@ -132,1 +132,1 @@\n-    static void test7029048() throws IOException {\n+    static boolean runTest() throws IOException {\n@@ -134,0 +134,1 @@\n+        boolean pass = true;\n@@ -158,2 +159,1 @@\n-                        System.out.println(\"Skipping test case \\\"\" + desc +\n-                                           \"\\\" because the Aix launcher adds the paths in any case.\");\n+                        printSkipMessage(desc);\n@@ -169,2 +169,1 @@\n-                        System.out.println(\"Skipping test case \\\"\" + desc +\n-                                           \"\\\" because the Aix launcher adds the paths in any case.\");\n+                        printSkipMessage(desc);\n@@ -178,0 +177,3 @@\n+            \/\/ Add one to account for our setting\n+            int nLLPComponents = v.value + 1;\n+\n@@ -181,5 +183,1 @@\n-            env.clear();\n-            env.put(LD_LIBRARY_PATH, dstServerDir.getAbsolutePath());\n-            run(env,\n-                v.value + 1,            \/\/ Add one to account for our setting\n-                \"Case 1: \" + desc);\n+            boolean pass1 = run(nLLPComponents, dstServerDir, \"Case 1: \" + desc);\n@@ -190,18 +188,3 @@\n-            env.clear();\n-            env.put(LD_LIBRARY_PATH, dstClientDir.getAbsolutePath());\n-            run(env,\n-                v.value + 1,            \/\/ Add one to account for our setting\n-                \"Case 2: \" + desc);\n-\n-            if (isSolaris) {\n-                \/*\n-                 * Case 3: set the appropriate LLP_XX flag,\n-                 * java64 LLP_64 is relevant, LLP_32 is ignored\n-                 *\/\n-                env.clear();\n-                env.put(LD_LIBRARY_PATH_64, dstServerDir.getAbsolutePath());\n-                run(env,\n-                    v.value,            \/\/ Do not add one, since we didn't set\n-                                        \/\/ LD_LIBRARY_PATH here\n-                    \"Case 3: \" + desc);\n-            }\n+            boolean pass2 = run(nLLPComponents, dstClientDir, \"Case 2: \" + desc);\n+\n+            pass &= pass1 && pass2;\n@@ -209,1 +192,6 @@\n-        return;\n+        return pass;\n+    }\n+\n+    private static void printSkipMessage(String description) {\n+        System.out.printf(\"Skipping test case '%s' because the Aix launcher\" +\n+                          \" adds the paths in any case.%n\", description);\n@@ -224,13 +212,2 @@\n-        \/\/ run the tests\n-        test7029048();\n-        if (errors > 0) {\n-            throw new Exception(\"Test7029048: FAIL: with \"\n-                    + errors + \" errors and passes \" + passes);\n-        } else if (isSolaris && passes < 9) {\n-            throw new Exception(\"Test7029048: FAIL: \" +\n-                    \"all tests did not run, expected \" + 9 + \" got \" + passes);\n-        } else if (isLinux && passes < 6) {\n-             throw new Exception(\"Test7029048: FAIL: \" +\n-                    \"all tests did not run, expected \" + 6 + \" got \" + passes);\n-        } else {\n-            System.out.println(\"Test7029048: PASS \" + passes);\n+        if (!runTest()) {\n+            throw new Exception(\"Test7029048 fails\");\n@@ -239,1 +216,0 @@\n-\n","filename":"test\/jdk\/tools\/launcher\/Test7029048.java","additions":40,"deletions":64,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib;\n+\n+import java.util.Arrays;\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+\n+public final class OSVersion implements Comparable<OSVersion> {\n+    public static final OSVersion WINDOWS_95 = new OSVersion(4, 0);\n+    public static final OSVersion WINDOWS_98 = new OSVersion(4, 10);\n+    public static final OSVersion WINDOWS_ME = new OSVersion(4, 90);\n+    public static final OSVersion WINDOWS_2000 = new OSVersion(5, 0);\n+    public static final OSVersion WINDOWS_XP = new OSVersion(5, 1);\n+    public static final OSVersion WINDOWS_2003 = new OSVersion(5, 2);\n+    public static final OSVersion WINDOWS_VISTA = new OSVersion(6, 0);\n+\n+    private final int[] versionTokens;\n+\n+    public static OSVersion current() {\n+        if (Platform.isSolaris()) {\n+            return new OSVersion(getSolarisVersion());\n+        }\n+        return new OSVersion(Platform.getOsVersion());\n+    }\n+\n+    public OSVersion(int major, int minor) {\n+        versionTokens = new int[] {major, minor};\n+    }\n+\n+    public OSVersion(String version) {\n+        Pattern onlyDigits = Pattern.compile(\"^\\\\d+$\");\n+        this.versionTokens = Arrays.stream(version.split(\"-\")[0].split(\"\\\\.\"))\n+                                   .filter(onlyDigits.asPredicate())\n+                                   .mapToInt(Integer::parseInt)\n+                                   .toArray();\n+    }\n+\n+    private static String getSolarisVersion() {\n+        try {\n+            return Utils.distro();\n+        } catch (Throwable e) {\n+            System.out.println(\"First attempt failed with: \" + e.getMessage());\n+        }\n+\n+        \/\/ Try to get Solaris version from \/etc\/release\n+        try (BufferedReader in = new BufferedReader(AccessController.doPrivileged(\n+                (PrivilegedExceptionAction<FileReader>) () -> new FileReader(\"\/etc\/release\")))) {\n+            return in.readLine().trim().split(\" \")[2];\n+        } catch (PrivilegedActionException e) {\n+            System.out.println(\"Second attempt failed with: \" + e.getException().getMessage());\n+        } catch (Exception e) {\n+            System.out.println(\"Second attempt failed with: \" + e.getMessage());\n+        }\n+\n+        throw new RuntimeException(\"Unable to get Solaris version\");\n+    }\n+\n+    @Override\n+    public int compareTo(OSVersion o) {\n+        return Arrays.compare(this.versionTokens, o.versionTokens);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Arrays.hashCode(versionTokens);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        OSVersion osVersion = (OSVersion) o;\n+        return Arrays.equals(versionTokens, osVersion.versionTokens);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Arrays.stream(versionTokens)\n+                     .mapToObj(String::valueOf)\n+                     .collect(Collectors.joining(\".\"));\n+    }\n+}\n+\n","filename":"test\/lib\/jdk\/test\/lib\/OSVersion.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -29,3 +29,0 @@\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Objects;\n@@ -33,1 +30,4 @@\n-import java.util.stream.Collectors;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n@@ -36,4 +36,3 @@\n-    public  static final String vmName      = System.getProperty(\"java.vm.name\");\n-    public  static final String vmInfo      = System.getProperty(\"java.vm.info\");\n-    private static final String osVersion   = System.getProperty(\"os.version\");\n-    private static       String[] osVersionTokens;\n+    public  static final String vmName      = privilegedGetProperty(\"java.vm.name\");\n+    public  static final String vmInfo      = privilegedGetProperty(\"java.vm.info\");\n+    private static final String osVersion   = privilegedGetProperty(\"os.version\");\n@@ -42,7 +41,12 @@\n-    private static final String osName      = System.getProperty(\"os.name\");\n-    private static final String dataModel   = System.getProperty(\"sun.arch.data.model\");\n-    private static final String vmVersion   = System.getProperty(\"java.vm.version\");\n-    private static final String jdkDebug    = System.getProperty(\"jdk.debug\");\n-    private static final String osArch      = System.getProperty(\"os.arch\");\n-    private static final String userName    = System.getProperty(\"user.name\");\n-    private static final String compiler    = System.getProperty(\"sun.management.compiler\");\n+    private static final String osName      = privilegedGetProperty(\"os.name\");\n+    private static final String dataModel   = privilegedGetProperty(\"sun.arch.data.model\");\n+    private static final String vmVersion   = privilegedGetProperty(\"java.vm.version\");\n+    private static final String jdkDebug    = privilegedGetProperty(\"jdk.debug\");\n+    private static final String osArch      = privilegedGetProperty(\"os.arch\");\n+    private static final String userName    = privilegedGetProperty(\"user.name\");\n+    private static final String compiler    = privilegedGetProperty(\"sun.management.compiler\");\n+\n+    private static String privilegedGetProperty(String key) {\n+        return AccessController.doPrivileged((\n+                PrivilegedAction<String>) () -> System.getProperty(key));\n+    }\n@@ -132,1 +136,1 @@\n-        osVersionTokens = osVersion.split(\"\\\\.\");\n+        String[] osVersionTokens = osVersion.split(\"\\\\.\");\n@@ -163,39 +167,0 @@\n-    \/**\n-     * Compares the platform version with the supplied version. The\n-     * version must be of the form a[.b[.c[.d...]]] where a, b, c, d, ...\n-     * are decimal integers.\n-     *\n-     * @throws NullPointerException if the parameter is null\n-     * @throws NumberFormatException if there is an error parsing either\n-     *         version as split into component strings\n-     * @return -1, 0, or 1 according to whether the platform version is\n-     *         less than, equal to, or greater than the supplied version\n-     *\/\n-    public static int compareOsVersion(String version) {\n-        if (osVersionTokens == null) init_version();\n-\n-        Objects.requireNonNull(version);\n-\n-        List<Integer> s1 = Arrays\n-            .stream(osVersionTokens)\n-            .map(Integer::valueOf)\n-            .collect(Collectors.toList());\n-        List<Integer> s2 = Arrays\n-            .stream(version.split(\"\\\\.\"))\n-            .map(Integer::valueOf)\n-            .collect(Collectors.toList());\n-\n-        int count = Math.max(s1.size(), s2.size());\n-        for (int i = 0; i < count; i++) {\n-            int i1 = i < s1.size() ? s1.get(i) : 0;\n-            int i2 = i < s2.size() ? s2.get(i) : 0;\n-            if (i1 > i2) {\n-                return 1;\n-            } else if (i2 > i1) {\n-                return -1;\n-            }\n-        }\n-\n-        return 0;\n-    }\n-\n@@ -300,1 +265,2 @@\n-            try (RandomAccessFile file = new RandomAccessFile(deny_ptrace, \"r\")) {\n+            try (RandomAccessFile file = AccessController.doPrivileged(\n+                    (PrivilegedExceptionAction<RandomAccessFile>) () -> new RandomAccessFile(deny_ptrace, \"r\"))) {\n@@ -304,0 +270,4 @@\n+            } catch (PrivilegedActionException e) {\n+                @SuppressWarnings(\"unchecked\")\n+                IOException t = (IOException) e.getException();\n+                throw t;\n@@ -314,1 +284,2 @@\n-            try (RandomAccessFile file = new RandomAccessFile(ptrace_scope, \"r\")) {\n+            try (RandomAccessFile file = AccessController.doPrivileged(\n+                    (PrivilegedExceptionAction<RandomAccessFile>) () -> new RandomAccessFile(ptrace_scope, \"r\"))) {\n@@ -323,0 +294,4 @@\n+            } catch (PrivilegedActionException e) {\n+                @SuppressWarnings(\"unchecked\")\n+                IOException t = (IOException) e.getException();\n+                throw t;\n","filename":"test\/lib\/jdk\/test\/lib\/Platform.java","additions":32,"deletions":57,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -765,0 +765,20 @@\n+\n+    \/**\n+     * Creates an empty directory in \"user.dir\" or \".\"\n+     * <p>\n+     * This method is meant as a replacement for {@code Files#createTempDirectory(String, String, FileAttribute...)}\n+     * that doesn't leave files behind in \/tmp directory of the test machine\n+     * <p>\n+     * If the property \"user.dir\" is not set, \".\" will be used.\n+     *\n+     * @param prefix\n+     * @param attrs\n+     * @return the path to the newly created directory\n+     * @throws IOException\n+     *\n+     * @see {@link Files#createTempDirectory(String, String, FileAttribute...)}\n+     *\/\n+    public static Path createTempDirectory(String prefix, FileAttribute<?>... attrs) throws IOException {\n+        Path dir = Paths.get(System.getProperty(\"user.dir\", \".\"));\n+        return Files.createTempDirectory(dir, prefix);\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/Utils.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+\n@@ -57,2 +58,1 @@\n-        try {\n-            Stream<String> stream = Files.lines(Paths.get(path));\n+        try (Stream<String> stream = Files.lines(Paths.get(path))) {\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/CPUSetsReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.cgroup;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+interface CgroupMetricsTester {\n+\n+    public static final double ERROR_MARGIN = 0.1;\n+    public static final String EMPTY_STR = \"\";\n+\n+    public void testMemorySubsystem();\n+    public void testCpuAccounting();\n+    public void testCpuSchedulingMetrics();\n+    public void testCpuSets();\n+    public void testCpuConsumption() throws IOException, InterruptedException;\n+    public void testMemoryUsage() throws Exception;\n+    public void testMisc();\n+\n+    public static long convertStringToLong(String strval, long overflowRetval) {\n+        long retval = 0;\n+        if (strval == null) return 0L;\n+\n+        try {\n+            retval = Long.parseLong(strval);\n+        } catch (NumberFormatException e) {\n+            \/\/ For some properties (e.g. memory.limit_in_bytes) we may overflow the range of signed long.\n+            \/\/ In this case, return Long.MAX_VALUE\n+            BigInteger b = new BigInteger(strval);\n+            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n+                return overflowRetval;\n+            }\n+        }\n+        return retval;\n+    }\n+\n+    public static boolean compareWithErrorMargin(long oldVal, long newVal) {\n+        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n+    }\n+\n+    public static boolean compareWithErrorMargin(double oldVal, double newVal) {\n+        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n+    }\n+\n+    public static void fail(String controller, String metric, long oldVal, long testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void fail(String controller, String metric, String oldVal, String testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void fail(String controller, String metric, double oldVal, double testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void fail(String controller, String metric, boolean oldVal, boolean testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void warn(String controller, String metric, long oldVal, long testVal) {\n+        System.err.println(\"Warning - \" + controller + \":\" + metric\n+                + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static Integer[] convertCpuSetsToArray(String cpusstr) {\n+        if (cpusstr == null || EMPTY_STR.equals(cpusstr)) {\n+            return new Integer[0];\n+        }\n+        \/\/ Parse range string in the format 1,2-6,7\n+        Integer[] cpuSets = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n+            if (a.contains(\"-\")) {\n+                String[] range = a.split(\"-\");\n+                return IntStream.rangeClosed(Integer.parseInt(range[0]),\n+                        Integer.parseInt(range[1])).boxed();\n+            } else {\n+                return Stream.of(Integer.parseInt(a));\n+            }\n+        }).toArray(Integer[]::new);\n+        return cpuSets;\n+    }\n+\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/CgroupMetricsTester.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc.\n@@ -24,0 +24,1 @@\n+\n@@ -26,17 +27,2 @@\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.math.BigInteger;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Scanner;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-import java.util.stream.LongStream;\n-import java.util.stream.Stream;\n+import java.util.Objects;\n+\n@@ -45,0 +31,4 @@\n+\/**\n+ * Cgroup version agnostic metrics tester\n+ *\n+ *\/\n@@ -47,293 +37,2 @@\n-    private static final double ERROR_MARGIN = 0.1;\n-    private static long unlimited_minimum = 0x7FFFFFFFFF000000L;\n-    long startSysVal;\n-    long startUserVal;\n-    long startUsage;\n-    long startPerCpu[];\n-\n-    enum SubSystem {\n-        MEMORY(\"memory\"),\n-        CPUSET(\"cpuset\"),\n-        CPU(\"cpu\"),\n-        CPUACCT(\"cpuacct\"),\n-        BLKIO(\"blkio\");\n-\n-        private String value;\n-\n-        SubSystem(String value) {\n-            this.value = value;\n-        }\n-\n-        public String value() {\n-            return value;\n-        }\n-    }\n-\n-    private static final Set<String> allowedSubSystems =\n-            Stream.of(SubSystem.values()).map(SubSystem::value).collect(Collectors.toSet());\n-\n-    private static final Map<String, String[]> subSystemPaths = new HashMap<>();\n-\n-    private static void setPath(String[] line) {\n-        String cgroupPath = line[2];\n-        String[] subSystems = line[1].split(\",\");\n-\n-        for (String subSystem : subSystems) {\n-            if (allowedSubSystems.contains(subSystem)) {\n-                String[] paths = subSystemPaths.get(subSystem);\n-                String finalPath = \"\";\n-                String root = paths[0];\n-                String mountPoint = paths[1];\n-                if (root != null && cgroupPath != null) {\n-                    if (root.equals(\"\/\")) {\n-                        if (!cgroupPath.equals(\"\/\")) {\n-                            finalPath = mountPoint + cgroupPath;\n-                        } else {\n-                            finalPath = mountPoint;\n-                        }\n-                    } else {\n-                        if (root.equals(cgroupPath)) {\n-                            finalPath = mountPoint;\n-                        } else {\n-                            if (cgroupPath.startsWith(root)) {\n-                                if (cgroupPath.length() > root.length()) {\n-                                    String cgroupSubstr = cgroupPath.substring(root.length());\n-                                    finalPath = mountPoint + cgroupSubstr;\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                subSystemPaths.put(subSystem, new String[]{finalPath, mountPoint});\n-            }\n-        }\n-    }\n-\n-    private static void createSubsystems(String[] line) {\n-        if (line.length < 5) return;\n-        Path p = Paths.get(line[4]);\n-        String subsystemName = p.getFileName().toString();\n-        if (subsystemName != null) {\n-            for (String subSystem : subsystemName.split(\",\")) {\n-                if (allowedSubSystems.contains(subSystem)) {\n-                    subSystemPaths.put(subSystem, new String[]{line[3], line[4]});\n-                }\n-            }\n-        }\n-    }\n-\n-    public void setup() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        \/\/ Initialize CPU usage metrics before we do any testing.\n-        startSysVal = metrics.getCpuSystemUsage();\n-        startUserVal = metrics.getCpuUserUsage();\n-        startUsage = metrics.getCpuUsage();\n-        startPerCpu = metrics.getPerCpuUsage();\n-\n-        try {\n-            Stream<String> lines = Files.lines(Paths.get(\"\/proc\/self\/mountinfo\"));\n-            lines.filter(line -> line.contains(\" - cgroup cgroup \"))\n-                    .map(line -> line.split(\" \"))\n-                    .forEach(MetricsTester::createSubsystems);\n-            lines.close();\n-\n-            lines = Files.lines(Paths.get(\"\/proc\/self\/cgroup\"));\n-            lines.map(line -> line.split(\":\"))\n-                    .filter(line -> (line.length >= 3))\n-                    .forEach(MetricsTester::setPath);\n-            lines.close();\n-        } catch (IOException e) {\n-        }\n-    }\n-\n-    private static String getFileContents(SubSystem subSystem, String fileName) {\n-        String fname = subSystemPaths.get(subSystem.value())[0] + File.separator + fileName;\n-        try {\n-            return new Scanner(new File(fname)).useDelimiter(\"\\\\Z\").next();\n-        } catch (FileNotFoundException e) {\n-            System.err.println(\"Unable to open : \" + fname);\n-            return \"\";\n-        }\n-    }\n-\n-    private static long getLongValueFromFile(SubSystem subSystem, String fileName) {\n-        String data = getFileContents(subSystem, fileName);\n-        return data.isEmpty() ? 0L : convertStringToLong(data);\n-    }\n-\n-    private static long convertStringToLong(String strval) {\n-        long retval = 0;\n-        if (strval == null) return 0L;\n-\n-        try {\n-            retval = Long.parseLong(strval);\n-        } catch (NumberFormatException e) {\n-            \/\/ For some properties (e.g. memory.limit_in_bytes) we may overflow the range of signed long.\n-            \/\/ In this case, return Long.MAX_VALUE\n-            BigInteger b = new BigInteger(strval);\n-            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n-                return Long.MAX_VALUE;\n-            }\n-        }\n-        return retval;\n-    }\n-\n-    private static long getLongValueFromFile(SubSystem subSystem, String metric, String subMetric) {\n-        String stats = getFileContents(subSystem, metric);\n-        String[] tokens = stats.split(\"[\\\\r\\\\n]+\");\n-        for (int i = 0; i < tokens.length; i++) {\n-            if (tokens[i].startsWith(subMetric)) {\n-                String strval = tokens[i].split(\"\\\\s+\")[1];\n-                return convertStringToLong(strval);\n-            }\n-        }\n-        return 0L;\n-    }\n-\n-    private static double getDoubleValueFromFile(SubSystem subSystem, String fileName) {\n-        String data = getFileContents(subSystem, fileName);\n-        return data.isEmpty() ? 0.0 : Double.parseDouble(data);\n-    }\n-\n-    private boolean compareWithErrorMargin(long oldVal, long newVal) {\n-        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n-    }\n-\n-    private boolean compareWithErrorMargin(double oldVal, double newVal) {\n-        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n-    }\n-\n-    private static void fail(SubSystem system, String metric, long oldVal, long testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void fail(SubSystem system, String metric, String oldVal, String testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void fail(SubSystem system, String metric, double oldVal, double testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void fail(SubSystem system, String metric, boolean oldVal, boolean testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void warn(SubSystem system, String metric, long oldVal, long testVal) {\n-        System.err.println(\"Warning - \" + system.value + \":\" + metric\n-                + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    public void testMemorySubsystem() {\n-        Metrics metrics = Metrics.systemMetrics();\n-\n-        \/\/ User Memory\n-        long oldVal = metrics.getMemoryFailCount();\n-        long newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.failcnt\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.failcnt\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getMemoryLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getMemoryMaxUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.max_usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.max_usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getMemoryUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        \/\/ Kernel memory\n-        oldVal = metrics.getKernelMemoryFailCount();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.failcnt\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.failcnt\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getKernelMemoryLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getKernelMemoryMaxUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.max_usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.max_usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getKernelMemoryUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        \/\/TCP Memory\n-        oldVal = metrics.getTcpMemoryFailCount();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.failcnt\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.failcnt\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getTcpMemoryLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getTcpMemoryMaxUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getTcpMemoryUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        \/\/  Memory and Swap\n-        \/\/ Skip swap tests if no swap is configured.\n-        if (metrics.getMemoryAndSwapLimit() > metrics.getMemoryLimit()) {\n-            oldVal = metrics.getMemoryAndSwapFailCount();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.failcnt\");\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.failcnt\", oldVal, newVal);\n-            }\n-\n-            oldVal = metrics.getMemoryAndSwapLimit();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.limit_in_bytes\");\n-            newVal = newVal > unlimited_minimum ? -1L : newVal;\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.limit_in_bytes\", oldVal, newVal);\n-            }\n-\n-            oldVal = metrics.getMemoryAndSwapMaxUsage();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.max_usage_in_bytes\");\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.max_usage_in_bytes\", oldVal, newVal);\n-            }\n-\n-            oldVal = metrics.getMemoryAndSwapUsage();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.usage_in_bytes\");\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.usage_in_bytes\", oldVal, newVal);\n-            }\n-        }\n+    private static final String CGROUP_V1 = \"cgroupv1\";\n+    private static final String CGROUP_V2 = \"cgroupv2\";\n@@ -341,14 +40,12 @@\n-        oldVal = metrics.getMemorySoftLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.soft_limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.soft_limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        boolean oomKillEnabled = metrics.isMemoryOOMKillEnabled();\n-        boolean newOomKillEnabled = getLongValueFromFile(SubSystem.MEMORY,\n-                \"memory.oom_control\", \"oom_kill_disable\") == 0L ? true : false;\n-        if (oomKillEnabled != newOomKillEnabled) {\n-            throw new RuntimeException(\"Test failed for - \" + SubSystem.MEMORY.value + \":\"\n-                    + \"memory.oom_control:oom_kill_disable\" + \", expected [\"\n-                    + oomKillEnabled + \"], got [\" + newOomKillEnabled + \"]\");\n+    private static CgroupMetricsTester createInstance(Metrics m) {\n+        Objects.requireNonNull(m);\n+        if (CGROUP_V1.equals(m.getProvider())) {\n+            MetricsTesterCgroupV1 t = new MetricsTesterCgroupV1();\n+            t.setup();\n+            return t;\n+        } else if (CGROUP_V2.equals(m.getProvider())) {\n+            return new MetricsTesterCgroupV2();\n+        } else {\n+            System.err.println(\"WARNING: Metrics provider, '\" + m.getProvider()\n+                                                              + \"' is unknown!\");\n+            return null;\n@@ -358,253 +55,9 @@\n-    public void testCpuAccounting() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        long oldVal = metrics.getCpuUsage();\n-        long newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpuacct.usage\");\n-\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            warn(SubSystem.CPUACCT, \"cpuacct.usage\", oldVal, newVal);\n-        }\n-\n-        Long[] newVals = Stream.of(getFileContents(SubSystem.CPUACCT, \"cpuacct.usage_percpu\")\n-                .split(\"\\\\s+\"))\n-                .map(Long::parseLong)\n-                .toArray(Long[]::new);\n-        Long[] oldVals = LongStream.of(metrics.getPerCpuUsage()).boxed().toArray(Long[]::new);\n-        for (int i = 0; i < oldVals.length; i++) {\n-            if (!compareWithErrorMargin(oldVals[i], newVals[i])) {\n-                warn(SubSystem.CPUACCT, \"cpuacct.usage_percpu\", oldVals[i], newVals[i]);\n-            }\n-        }\n-\n-        oldVal = metrics.getCpuUserUsage();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpuacct.stat\", \"user\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            warn(SubSystem.CPUACCT, \"cpuacct.usage - user\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuSystemUsage();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpuacct.stat\", \"system\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            warn(SubSystem.CPUACCT, \"cpuacct.usage - system\", oldVal, newVal);\n-        }\n-    }\n-\n-    public void testCpuSchedulingMetrics() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        long oldVal = metrics.getCpuPeriod();\n-        long newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.cfs_period_us\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.cfs_period_us\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuQuota();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.cfs_quota_us\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.cfs_quota_us\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuShares();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.shares\");\n-        if (newVal == 0 || newVal == 1024) newVal = -1;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.shares\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuNumPeriods();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.stat\", \"nr_periods\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.stat - nr_periods\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuNumThrottled();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.stat\", \"nr_throttled\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.stat - nr_throttled\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuThrottledTime();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.stat\", \"throttled_time\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.stat - throttled_time\", oldVal, newVal);\n-        }\n-    }\n-\n-    public void testCpuSets() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        Integer[] oldVal = Arrays.stream(metrics.getCpuSetCpus()).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n-\n-        String cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.cpus\");\n-        \/\/ Parse range string in the format 1,2-6,7\n-        Integer[] newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-            if (a.contains(\"-\")) {\n-                String[] range = a.split(\"-\");\n-                return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                        Integer.parseInt(range[1])).boxed();\n-            } else {\n-                return Stream.of(Integer.parseInt(a));\n-            }\n-        }).toArray(Integer[]::new);\n-        Arrays.sort(newVal);\n-        if (Arrays.compare(oldVal, newVal) != 0) {\n-            fail(SubSystem.CPUSET, \"cpuset.cpus\", Arrays.toString(oldVal),\n-                Arrays.toString(newVal));\n-        }\n-\n-        int [] cpuSets = metrics.getEffectiveCpuSetCpus();\n-\n-        \/\/ Skip this test if this metric is supported on this platform\n-        if (cpuSets.length != 0) {\n-            oldVal = Arrays.stream(cpuSets).boxed().toArray(Integer[]::new);\n-            Arrays.sort(oldVal);\n-            cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.effective_cpus\");\n-            newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-                if (a.contains(\"-\")) {\n-                    String[] range = a.split(\"-\");\n-                    return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                            Integer.parseInt(range[1])).boxed();\n-                } else {\n-                    return Stream.of(Integer.parseInt(a));\n-                }\n-            }).toArray(Integer[]::new);\n-            Arrays.sort(newVal);\n-            if (Arrays.compare(oldVal, newVal) != 0) {\n-                fail(SubSystem.CPUSET, \"cpuset.effective_cpus\", Arrays.toString(oldVal),\n-                        Arrays.toString(newVal));\n-            }\n-        }\n-\n-        oldVal = Arrays.stream(metrics.getCpuSetMems()).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n-        cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.mems\");\n-        newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-            if (a.contains(\"-\")) {\n-                String[] range = a.split(\"-\");\n-                return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                        Integer.parseInt(range[1])).boxed();\n-            } else {\n-                return Stream.of(Integer.parseInt(a));\n-            }\n-        }).toArray(Integer[]::new);\n-        Arrays.sort(newVal);\n-        if (Arrays.compare(oldVal, newVal) != 0) {\n-            fail(SubSystem.CPUSET, \"cpuset.mems\", Arrays.toString(oldVal),\n-                    Arrays.toString(newVal));\n-        }\n-\n-        int [] cpuSetMems = metrics.getEffectiveCpuSetMems();\n-\n-        \/\/ Skip this test if this metric is supported on this platform\n-        if (cpuSetMems.length != 0) {\n-            oldVal = Arrays.stream(cpuSetMems).boxed().toArray(Integer[]::new);\n-            Arrays.sort(oldVal);\n-            cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.effective_mems\");\n-            newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-                if (a.contains(\"-\")) {\n-                    String[] range = a.split(\"-\");\n-                    return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                            Integer.parseInt(range[1])).boxed();\n-                } else {\n-                    return Stream.of(Integer.parseInt(a));\n-                }\n-            }).toArray(Integer[]::new);\n-            Arrays.sort(newVal);\n-            if (Arrays.compare(oldVal, newVal) != 0) {\n-                fail(SubSystem.CPUSET, \"cpuset.effective_mems\", Arrays.toString(oldVal),\n-                        Arrays.toString(newVal));\n-            }\n-        }\n-\n-        double oldValue = metrics.getCpuSetMemoryPressure();\n-        double newValue = getDoubleValueFromFile(SubSystem.CPUSET, \"cpuset.memory_pressure\");\n-        if (!compareWithErrorMargin(oldValue, newValue)) {\n-            fail(SubSystem.CPUSET, \"cpuset.memory_pressure\", oldValue, newValue);\n-        }\n-\n-        boolean oldV = metrics.isCpuSetMemoryPressureEnabled();\n-        boolean newV = getLongValueFromFile(SubSystem.CPUSET,\n-                \"cpuset.memory_pressure_enabled\") == 1 ? true : false;\n-        if (oldV != newV) {\n-            fail(SubSystem.CPUSET, \"cpuset.memory_pressure_enabled\", oldV, newV);\n-        }\n-    }\n-\n-    public void testBlkIO() {\n-        Metrics metrics = Metrics.systemMetrics();\n-            long oldVal = metrics.getBlkIOServiceCount();\n-        long newVal = getLongValueFromFile(SubSystem.BLKIO,\n-                \"blkio.throttle.io_service_bytes\", \"Total\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.BLKIO, \"blkio.throttle.io_service_bytes - Total\",\n-                    oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getBlkIOServiced();\n-        newVal = getLongValueFromFile(SubSystem.BLKIO, \"blkio.throttle.io_serviced\", \"Total\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.BLKIO, \"blkio.throttle.io_serviced - Total\", oldVal, newVal);\n-        }\n-    }\n-\n-    public void testCpuConsumption() throws IOException, InterruptedException {\n-        Metrics metrics = Metrics.systemMetrics();\n-        \/\/ make system call\n-        long newSysVal = metrics.getCpuSystemUsage();\n-        long newUserVal = metrics.getCpuUserUsage();\n-        long newUsage = metrics.getCpuUsage();\n-        long[] newPerCpu = metrics.getPerCpuUsage();\n-\n-        \/\/ system\/user CPU usage counters may be slowly increasing.\n-        \/\/ allow for equal values for a pass\n-        if (newSysVal < startSysVal) {\n-            fail(SubSystem.CPU, \"getCpuSystemUsage\", newSysVal, startSysVal);\n-        }\n-\n-        \/\/ system\/user CPU usage counters may be slowly increasing.\n-        \/\/ allow for equal values for a pass\n-        if (newUserVal < startUserVal) {\n-            fail(SubSystem.CPU, \"getCpuUserUsage\", newUserVal, startUserVal);\n-        }\n-\n-        if (newUsage <= startUsage) {\n-            fail(SubSystem.CPU, \"getCpuUsage\", newUsage, startUsage);\n-        }\n-\n-        boolean success = false;\n-        for (int i = 0; i < startPerCpu.length; i++) {\n-            if (newPerCpu[i] > startPerCpu[i]) {\n-                success = true;\n-                break;\n-            }\n-        }\n-\n-        if(!success) fail(SubSystem.CPU, \"getPerCpuUsage\", Arrays.toString(newPerCpu),\n-                Arrays.toString(startPerCpu));\n-    }\n-\n-    public void testMemoryUsage() throws Exception {\n-        Metrics metrics = Metrics.systemMetrics();\n-        long memoryMaxUsage = metrics.getMemoryMaxUsage();\n-        long memoryUsage = metrics.getMemoryUsage();\n-        long newMemoryMaxUsage = 0, newMemoryUsage = 0;\n-\n-        \/\/ allocate memory in a loop and check more than once for new values\n-        \/\/ otherwise we might see seldom the effect of decreasing new memory values\n-        \/\/ e.g. because the system could free up memory\n-        byte[][] bytes = new byte[32][];\n-        for (int i = 0; i < 32; i++) {\n-            bytes[i] = new byte[8*1024*1024];\n-            newMemoryUsage = metrics.getMemoryUsage();\n-            if (newMemoryUsage > memoryUsage) {\n-                break;\n-            }\n-        }\n-        newMemoryMaxUsage = metrics.getMemoryMaxUsage();\n-\n-        if (newMemoryMaxUsage < memoryMaxUsage) {\n-            fail(SubSystem.MEMORY, \"getMemoryMaxUsage\", memoryMaxUsage,\n-                    newMemoryMaxUsage);\n-        }\n-\n-        if (newMemoryUsage < memoryUsage) {\n-            fail(SubSystem.MEMORY, \"getMemoryUsage\", memoryUsage, newMemoryUsage);\n-        }\n+    public void testAll(Metrics m) throws Exception {\n+        CgroupMetricsTester tester =  createInstance(m);\n+        tester.testCpuAccounting();\n+        tester.testCpuConsumption();\n+        tester.testCpuSchedulingMetrics();\n+        tester.testCpuSets();\n+        tester.testMemorySubsystem();\n+        tester.testMemoryUsage();\n+        tester.testMisc();\n@@ -614,0 +67,1 @@\n+        Metrics m = Metrics.systemMetrics();\n@@ -615,2 +69,1 @@\n-        Metrics metrics = Metrics.systemMetrics();\n-        if (metrics == null) {\n+        if (m == null) {\n@@ -622,8 +75,1 @@\n-        metricsTester.setup();\n-        metricsTester.testCpuAccounting();\n-        metricsTester.testCpuSchedulingMetrics();\n-        metricsTester.testCpuSets();\n-        metricsTester.testMemorySubsystem();\n-        metricsTester.testBlkIO();\n-        metricsTester.testCpuConsumption();\n-        metricsTester.testMemoryUsage();\n+        metricsTester.testAll(m);\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTester.java","additions":34,"deletions":588,"binary":false,"changes":622,"status":"modified"},{"patch":"@@ -0,0 +1,572 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.cgroup;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.platform.Metrics;\n+import jdk.internal.platform.CgroupV1Metrics;\n+\n+public class MetricsTesterCgroupV1 implements CgroupMetricsTester {\n+\n+    private static long unlimited_minimum = 0x7FFFFFFFFF000000L;\n+    long startSysVal;\n+    long startUserVal;\n+    long startUsage;\n+    long startPerCpu[];\n+\n+    enum Controller {\n+        MEMORY(\"memory\"),\n+        CPUSET(\"cpuset\"),\n+        CPU(\"cpu\"),\n+        CPUACCT(\"cpuacct\"),\n+        BLKIO(\"blkio\");\n+\n+        private String value;\n+\n+        Controller(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+    }\n+\n+    private static final Set<String> allowedSubSystems =\n+            Stream.of(Controller.values()).map(Controller::value).collect(Collectors.toSet());\n+\n+    private static final Map<String, String[]> subSystemPaths = new HashMap<>();\n+\n+    private static void setPath(String[] line) {\n+        String cgroupPath = line[2];\n+        String[] subSystems = line[1].split(\",\");\n+\n+        for (String subSystem : subSystems) {\n+            if (allowedSubSystems.contains(subSystem)) {\n+                String[] paths = subSystemPaths.get(subSystem);\n+                String finalPath = \"\";\n+                String root = paths[0];\n+                String mountPoint = paths[1];\n+                if (root != null && cgroupPath != null) {\n+                    if (root.equals(\"\/\")) {\n+                        if (!cgroupPath.equals(\"\/\")) {\n+                            finalPath = mountPoint + cgroupPath;\n+                        } else {\n+                            finalPath = mountPoint;\n+                        }\n+                    } else {\n+                        if (root.equals(cgroupPath)) {\n+                            finalPath = mountPoint;\n+                        } else {\n+                            if (cgroupPath.startsWith(root)) {\n+                                if (cgroupPath.length() > root.length()) {\n+                                    String cgroupSubstr = cgroupPath.substring(root.length());\n+                                    finalPath = mountPoint + cgroupSubstr;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                subSystemPaths.put(subSystem, new String[]{finalPath, mountPoint});\n+            }\n+        }\n+    }\n+\n+    private static void createSubsystems(String[] line) {\n+        if (line.length < 5) return;\n+        Path p = Paths.get(line[4]);\n+        String subsystemName = p.getFileName().toString();\n+        if (subsystemName != null) {\n+            for (String subSystem : subsystemName.split(\",\")) {\n+                if (allowedSubSystems.contains(subSystem)) {\n+                    subSystemPaths.put(subSystem, new String[]{line[3], line[4]});\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setup() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        \/\/ Initialize CPU usage metrics before we do any testing.\n+        startSysVal = metrics.getCpuSystemUsage();\n+        startUserVal = metrics.getCpuUserUsage();\n+        startUsage = metrics.getCpuUsage();\n+        startPerCpu = metrics.getPerCpuUsage();\n+        if (startPerCpu == null) {\n+            startPerCpu = new long[0];\n+        }\n+\n+        try {\n+            Stream<String> lines = Files.lines(Paths.get(\"\/proc\/self\/mountinfo\"));\n+            lines.filter(line -> line.contains(\" - cgroup cgroup \"))\n+                    .map(line -> line.split(\" \"))\n+                    .forEach(MetricsTesterCgroupV1::createSubsystems);\n+            lines.close();\n+\n+            lines = Files.lines(Paths.get(\"\/proc\/self\/cgroup\"));\n+            lines.map(line -> line.split(\":\"))\n+                    .filter(line -> (line.length >= 3))\n+                    .forEach(MetricsTesterCgroupV1::setPath);\n+            lines.close();\n+        } catch (IOException e) {\n+        }\n+    }\n+\n+    private static String getFileContents(Controller subSystem, String fileName) {\n+        String fname = subSystemPaths.get(subSystem.value())[0] + File.separator + fileName;\n+        try {\n+            return new Scanner(new File(fname)).useDelimiter(\"\\\\Z\").next();\n+        } catch (FileNotFoundException e) {\n+            System.err.println(\"Unable to open : \" + fname);\n+            return null;\n+        }\n+    }\n+\n+    private static long getLongValueFromFile(Controller subSystem, String fileName) {\n+        String data = getFileContents(subSystem, fileName);\n+        return (data == null || data.isEmpty()) ? 0L : convertStringToLong(data);\n+    }\n+\n+    private static long convertStringToLong(String strval) {\n+        return CgroupMetricsTester.convertStringToLong(strval, Long.MAX_VALUE);\n+    }\n+\n+    private static long getLongValueFromFile(Controller subSystem, String metric, String subMetric) {\n+        String stats = getFileContents(subSystem, metric);\n+        String[] tokens = stats.split(\"[\\\\r\\\\n]+\");\n+        for (int i = 0; i < tokens.length; i++) {\n+            if (tokens[i].startsWith(subMetric)) {\n+                String strval = tokens[i].split(\"\\\\s+\")[1];\n+                return convertStringToLong(strval);\n+            }\n+        }\n+        return 0L;\n+    }\n+\n+    private static double getDoubleValueFromFile(Controller subSystem, String fileName) {\n+        String data = getFileContents(subSystem, fileName);\n+        return data.isEmpty() ? 0.0 : Double.parseDouble(data);\n+    }\n+\n+    private static void fail(Controller system, String metric, long oldVal, long testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void fail(Controller system, String metric, String oldVal, String testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void fail(Controller system, String metric, double oldVal, double testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void fail(Controller system, String metric, boolean oldVal, boolean testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void warn(Controller system, String metric, long oldVal, long testVal) {\n+        CgroupMetricsTester.warn(system.value, metric, oldVal, testVal);\n+    }\n+\n+    public void testMemorySubsystem() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+\n+        \/\/ User Memory\n+        long oldVal = metrics.getMemoryFailCount();\n+        long newVal = getLongValueFromFile(Controller.MEMORY, \"memory.failcnt\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.failcnt\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryMaxUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.max_usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.max_usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        \/\/ Kernel memory\n+        oldVal = metrics.getKernelMemoryFailCount();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.failcnt\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.failcnt\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getKernelMemoryLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getKernelMemoryMaxUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.max_usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.max_usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getKernelMemoryUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        \/\/TCP Memory\n+        oldVal = metrics.getTcpMemoryFailCount();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.failcnt\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.failcnt\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryMaxUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        \/\/  Memory and Swap\n+        \/\/ Skip swap tests if no swap is configured.\n+        if (metrics.getMemoryAndSwapLimit() > metrics.getMemoryLimit()) {\n+            oldVal = metrics.getMemoryAndSwapFailCount();\n+            newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.failcnt\");\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(Controller.MEMORY, \"memory.memsw.failcnt\", oldVal, newVal);\n+            }\n+\n+            oldVal = metrics.getMemoryAndSwapLimit();\n+            newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.limit_in_bytes\");\n+            newVal = newVal > unlimited_minimum ? -1L : newVal;\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(Controller.MEMORY, \"memory.memsw.limit_in_bytes\", oldVal, newVal);\n+            }\n+\n+            oldVal = metrics.getMemoryAndSwapMaxUsage();\n+            newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.max_usage_in_bytes\");\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(Controller.MEMORY, \"memory.memsw.max_usage_in_bytes\", oldVal, newVal);\n+            }\n+\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(Controller.MEMORY, \"memory.memsw.usage_in_bytes\", oldVal, newVal);\n+                oldVal = metrics.getMemoryAndSwapUsage();\n+                newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.usage_in_bytes\");\n+                if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                    fail(Controller.MEMORY, \"memory.memsw.usage_in_bytes\", oldVal, newVal);\n+                }\n+            }\n+        }\n+\n+        oldVal = metrics.getMemorySoftLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.soft_limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? -1L : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.soft_limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        boolean oomKillEnabled = metrics.isMemoryOOMKillEnabled();\n+        boolean newOomKillEnabled = getLongValueFromFile(Controller.MEMORY,\n+                \"memory.oom_control\", \"oom_kill_disable\") == 0L ? true : false;\n+        if (oomKillEnabled != newOomKillEnabled) {\n+            throw new RuntimeException(\"Test failed for - \" + Controller.MEMORY.value + \":\"\n+                    + \"memory.oom_control:oom_kill_disable\" + \", expected [\"\n+                    + oomKillEnabled + \"], got [\" + newOomKillEnabled + \"]\");\n+        }\n+    }\n+\n+    public void testCpuAccounting() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuUsage();\n+        long newVal = getLongValueFromFile(Controller.CPUACCT, \"cpuacct.usage\");\n+\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(Controller.CPUACCT, \"cpuacct.usage\", oldVal, newVal);\n+        }\n+\n+        String newValsStr = getFileContents(Controller.CPUACCT, \"cpuacct.usage_percpu\");\n+        Long[] newVals = new Long[0];\n+        if (newValsStr != null) {\n+            newVals = Stream.of(newValsStr\n+                .split(\"\\\\s+\"))\n+                .map(Long::parseLong)\n+                .toArray(Long[]::new);\n+        }\n+        long[] oldValsPrim = metrics.getPerCpuUsage();\n+        Long[] oldVals = LongStream.of(oldValsPrim == null ? new long[0] : oldValsPrim)\n+                                    .boxed().toArray(Long[]::new);\n+        for (int i = 0; i < oldVals.length; i++) {\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVals[i], newVals[i])) {\n+                warn(Controller.CPUACCT, \"cpuacct.usage_percpu\", oldVals[i], newVals[i]);\n+            }\n+        }\n+\n+        oldVal = metrics.getCpuUserUsage();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpuacct.stat\", \"user\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(Controller.CPUACCT, \"cpuacct.usage - user\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuSystemUsage();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpuacct.stat\", \"system\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(Controller.CPUACCT, \"cpuacct.usage - system\", oldVal, newVal);\n+        }\n+    }\n+\n+    public void testCpuSchedulingMetrics() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuPeriod();\n+        long newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.cfs_period_us\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.cfs_period_us\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuQuota();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.cfs_quota_us\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.cfs_quota_us\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuShares();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.shares\");\n+        if (newVal == 0 || newVal == 1024) newVal = -1;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.shares\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumPeriods();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.stat\", \"nr_periods\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.stat - nr_periods\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumThrottled();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.stat\", \"nr_throttled\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.stat - nr_throttled\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuThrottledTime();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.stat\", \"throttled_time\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.stat - throttled_time\", oldVal, newVal);\n+        }\n+    }\n+\n+    public void testCpuSets() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        Integer[] oldVal = Arrays.stream(metrics.getCpuSetCpus()).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+\n+        String cpusstr = getFileContents(Controller.CPUSET, \"cpuset.cpus\");\n+        \/\/ Parse range string in the format 1,2-6,7\n+        Integer[] newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(Controller.CPUSET, \"cpuset.cpus\", Arrays.toString(oldVal),\n+                Arrays.toString(newVal));\n+        }\n+\n+        int [] cpuSets = metrics.getEffectiveCpuSetCpus();\n+\n+        \/\/ Skip this test if this metric is not supported on this platform\n+        if (cpuSets.length != 0) {\n+            oldVal = Arrays.stream(cpuSets).boxed().toArray(Integer[]::new);\n+            Arrays.sort(oldVal);\n+            cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_cpus\");\n+            newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+            Arrays.sort(newVal);\n+            if (Arrays.compare(oldVal, newVal) != 0) {\n+                fail(Controller.CPUSET, \"cpuset.effective_cpus\", Arrays.toString(oldVal),\n+                        Arrays.toString(newVal));\n+            }\n+        }\n+\n+        oldVal = Arrays.stream(metrics.getCpuSetMems()).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+        cpusstr = getFileContents(Controller.CPUSET, \"cpuset.mems\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(Controller.CPUSET, \"cpuset.mems\", Arrays.toString(oldVal),\n+                    Arrays.toString(newVal));\n+        }\n+\n+        int [] cpuSetMems = metrics.getEffectiveCpuSetMems();\n+\n+        \/\/ Skip this test if this metric is not supported on this platform\n+        if (cpuSetMems.length != 0) {\n+            oldVal = Arrays.stream(cpuSetMems).boxed().toArray(Integer[]::new);\n+            Arrays.sort(oldVal);\n+            cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_mems\");\n+            newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+            Arrays.sort(newVal);\n+            if (Arrays.compare(oldVal, newVal) != 0) {\n+                fail(Controller.CPUSET, \"cpuset.effective_mems\", Arrays.toString(oldVal),\n+                        Arrays.toString(newVal));\n+            }\n+        }\n+\n+        double oldValue = metrics.getCpuSetMemoryPressure();\n+        double newValue = getDoubleValueFromFile(Controller.CPUSET, \"cpuset.memory_pressure\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldValue, newValue)) {\n+            fail(Controller.CPUSET, \"cpuset.memory_pressure\", oldValue, newValue);\n+        }\n+\n+        boolean oldV = metrics.isCpuSetMemoryPressureEnabled();\n+        boolean newV = getLongValueFromFile(Controller.CPUSET,\n+                \"cpuset.memory_pressure_enabled\") == 1 ? true : false;\n+        if (oldV != newV) {\n+            fail(Controller.CPUSET, \"cpuset.memory_pressure_enabled\", oldV, newV);\n+        }\n+    }\n+\n+    private void testBlkIO() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+            long oldVal = metrics.getBlkIOServiceCount();\n+        long newVal = getLongValueFromFile(Controller.BLKIO,\n+                \"blkio.throttle.io_service_bytes\", \"Total\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.BLKIO, \"blkio.throttle.io_service_bytes - Total\",\n+                    oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getBlkIOServiced();\n+        newVal = getLongValueFromFile(Controller.BLKIO, \"blkio.throttle.io_serviced\", \"Total\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.BLKIO, \"blkio.throttle.io_serviced - Total\", oldVal, newVal);\n+        }\n+    }\n+\n+    public void testCpuConsumption() throws IOException, InterruptedException {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        \/\/ make system call\n+        long newSysVal = metrics.getCpuSystemUsage();\n+        long newUserVal = metrics.getCpuUserUsage();\n+        long newUsage = metrics.getCpuUsage();\n+        long[] newPerCpu = metrics.getPerCpuUsage();\n+        if (newPerCpu == null) {\n+            newPerCpu = new long[0];\n+        }\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newSysVal < startSysVal) {\n+            fail(Controller.CPU, \"getCpuSystemUsage\", newSysVal, startSysVal);\n+        }\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newUserVal < startUserVal) {\n+            fail(Controller.CPU, \"getCpuUserUsage\", newUserVal, startUserVal);\n+        }\n+\n+        if (newUsage <= startUsage) {\n+            fail(Controller.CPU, \"getCpuUsage\", newUsage, startUsage);\n+        }\n+\n+        boolean success = false;\n+        for (int i = 0; i < startPerCpu.length; i++) {\n+            if (newPerCpu[i] > startPerCpu[i]) {\n+                success = true;\n+                break;\n+            }\n+        }\n+\n+        if(!success) fail(Controller.CPU, \"getPerCpuUsage\", Arrays.toString(newPerCpu),\n+                Arrays.toString(startPerCpu));\n+    }\n+\n+    public void testMemoryUsage() throws Exception {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        long memoryMaxUsage = metrics.getMemoryMaxUsage();\n+        long memoryUsage = metrics.getMemoryUsage();\n+        long newMemoryMaxUsage = 0, newMemoryUsage = 0;\n+\n+        \/\/ allocate memory in a loop and check more than once for new values\n+        \/\/ otherwise we might see seldom the effect of decreasing new memory values\n+        \/\/ e.g. because the system could free up memory\n+        byte[][] bytes = new byte[32][];\n+        for (int i = 0; i < 32; i++) {\n+            bytes[i] = new byte[8*1024*1024];\n+            newMemoryUsage = metrics.getMemoryUsage();\n+            if (newMemoryUsage > memoryUsage) {\n+                break;\n+            }\n+        }\n+        newMemoryMaxUsage = metrics.getMemoryMaxUsage();\n+\n+        if (newMemoryMaxUsage < memoryMaxUsage) {\n+            fail(Controller.MEMORY, \"getMemoryMaxUsage\", memoryMaxUsage,\n+                    newMemoryMaxUsage);\n+        }\n+\n+        if (newMemoryUsage < memoryUsage) {\n+            fail(Controller.MEMORY, \"getMemoryUsage\", memoryUsage, newMemoryUsage);\n+        }\n+    }\n+\n+    @Override\n+    public void testMisc() {\n+        testBlkIO();\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV1.java","additions":572,"deletions":0,"binary":false,"changes":572,"status":"added"},{"patch":"@@ -0,0 +1,468 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.cgroup;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.Metrics;\n+\n+public class MetricsTesterCgroupV2 implements CgroupMetricsTester {\n+\n+    private static final long UNLIMITED = -1;\n+    private static final UnifiedController UNIFIED = new UnifiedController();\n+    private static final String MAX = \"max\";\n+    private static final int PER_CPU_SHARES = 1024;\n+\n+    private final long startSysVal;\n+    private final long startUserVal;\n+    private final long startUsage;\n+\n+    static class UnifiedController {\n+\n+        private static final String NAME = \"unified\";\n+        private final String path;\n+\n+        UnifiedController() {\n+            path = constructPath();\n+        }\n+\n+        String getPath() {\n+            return path;\n+        }\n+\n+        private static String constructPath() {\n+            String mountPath;\n+            String cgroupPath;\n+            try {\n+                List<String> fifthTokens = Files.lines(Paths.get(\"\/proc\/self\/mountinfo\"))\n+                        .filter( l -> l.contains(\"- cgroup2\"))\n+                        .map(UnifiedController::splitAndMountPath)\n+                        .collect(Collectors.toList());\n+                if (fifthTokens.size() != 1) {\n+                    throw new AssertionError(\"Expected only one cgroup2 line\");\n+                }\n+                mountPath = fifthTokens.get(0);\n+\n+                List<String> cgroupPaths = Files.lines(Paths.get(\"\/proc\/self\/cgroup\"))\n+                        .filter( l -> l.startsWith(\"0:\"))\n+                        .map(UnifiedController::splitAndCgroupPath)\n+                        .collect(Collectors.toList());\n+                if (cgroupPaths.size() != 1) {\n+                    throw new AssertionError(\"Expected only one unified controller line\");\n+                }\n+                cgroupPath = cgroupPaths.get(0);\n+                return Paths.get(mountPath, cgroupPath).toString();\n+            } catch (IOException e) {\n+                return null;\n+            }\n+        }\n+\n+        public static String splitAndMountPath(String input) {\n+            String[] tokens = input.split(\"\\\\s+\");\n+            return tokens[4]; \/\/ fifth entry is the mount path\n+        }\n+\n+        public static String splitAndCgroupPath(String input) {\n+            String[] tokens = input.split(\":\");\n+            return tokens[2];\n+        }\n+    }\n+\n+    private long getLongLimitValueFromFile(String file) {\n+        String strVal = getStringVal(file);\n+        if (MAX.equals(strVal)) {\n+            return UNLIMITED;\n+        }\n+        return convertStringToLong(strVal);\n+    }\n+\n+    public MetricsTesterCgroupV2() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        \/\/ Initialize CPU usage metrics before we do any testing.\n+        startSysVal = metrics.getCpuSystemUsage();\n+        startUserVal = metrics.getCpuUserUsage();\n+        startUsage = metrics.getCpuUsage();\n+    }\n+\n+    private long getLongValueFromFile(String file) {\n+        return convertStringToLong(getStringVal(file));\n+    }\n+\n+    private long getLongValueEntryFromFile(String file, String metric) {\n+        Path filePath = Paths.get(UNIFIED.getPath(), file);\n+        try {\n+            String strVal = Files.lines(filePath).filter(l -> l.startsWith(metric)).collect(Collectors.joining());\n+            String[] keyValues = strVal.split(\"\\\\s+\");\n+            String value = keyValues[1];\n+            return convertStringToLong(value);\n+        } catch (IOException e) {\n+            return 0;\n+        }\n+    }\n+\n+    private String getStringVal(String file) {\n+        Path filePath = Paths.get(UNIFIED.getPath(), file);\n+        try {\n+            return Files.lines(filePath).collect(Collectors.joining());\n+        } catch (IOException e) {\n+            return null;\n+        }\n+    }\n+\n+    private void fail(String metric, long oldVal, long newVal) {\n+        CgroupMetricsTester.fail(UnifiedController.NAME, metric, oldVal, newVal);\n+    }\n+\n+    private void fail(String metric, String oldVal, String newVal) {\n+        CgroupMetricsTester.fail(UnifiedController.NAME, metric, oldVal, newVal);\n+    }\n+\n+    private void warn(String metric, long oldVal, long newVal) {\n+        CgroupMetricsTester.warn(UnifiedController.NAME, metric, oldVal, newVal);\n+    }\n+\n+    private long getCpuShares(String file) {\n+        long rawVal = getLongValueFromFile(file);\n+        if (rawVal == 0 || rawVal == 100) {\n+            return UNLIMITED;\n+        }\n+        int shares = (int)rawVal;\n+        \/\/ CPU shares (OCI) value needs to get translated into\n+        \/\/ a proper Cgroups v2 value. See:\n+        \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n+        \/\/\n+        \/\/ Use the inverse of (x == OCI value, y == cgroupsv2 value):\n+        \/\/ ((262142 * y - 1)\/9999) + 2 = x\n+        \/\/\n+        int x = 262142 * shares - 1;\n+        double frac = x\/9999.0;\n+        x = ((int)frac) + 2;\n+        if ( x <= PER_CPU_SHARES ) {\n+            return PER_CPU_SHARES; \/\/ mimic cgroups v1\n+        }\n+        int f = x\/PER_CPU_SHARES;\n+        int lower_multiple = f * PER_CPU_SHARES;\n+        int upper_multiple = (f + 1) * PER_CPU_SHARES;\n+        int distance_lower = Math.max(lower_multiple, x) - Math.min(lower_multiple, x);\n+        int distance_upper = Math.max(upper_multiple, x) - Math.min(upper_multiple, x);\n+        x = distance_lower <= distance_upper ? lower_multiple : upper_multiple;\n+        return x;\n+    }\n+\n+    private long getCpuMaxValueFromFile(String file) {\n+        return getCpuValueFromFile(file, 0 \/* $MAX index *\/);\n+    }\n+\n+    private long getCpuPeriodValueFromFile(String file) {\n+        return getCpuValueFromFile(file, 1 \/* $PERIOD index *\/);\n+    }\n+\n+    private long getCpuValueFromFile(String file, int index) {\n+        String maxPeriod = getStringVal(file);\n+        if (maxPeriod == null) {\n+            return UNLIMITED;\n+        }\n+        String[] tokens = maxPeriod.split(\"\\\\s+\");\n+        String val = tokens[index];\n+        if (MAX.equals(val)) {\n+            return UNLIMITED;\n+        }\n+        return convertStringToLong(val);\n+    }\n+\n+    private long convertStringToLong(String val) {\n+        return CgroupMetricsTester.convertStringToLong(val, UNLIMITED);\n+    }\n+\n+    @Override\n+    public void testMemorySubsystem() {\n+        Metrics metrics = Metrics.systemMetrics();\n+\n+        \/\/ User Memory\n+        long oldVal = metrics.getMemoryFailCount();\n+        long newVal = getLongValueEntryFromFile(\"memory.events\", \"max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.events[max]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryLimit();\n+        newVal = getLongLimitValueFromFile(\"memory.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.max\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryUsage();\n+        newVal = getLongValueFromFile(\"memory.current\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.current\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryUsage();\n+        newVal = getLongValueEntryFromFile(\"memory.stat\", \"sock\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.stat[sock]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryAndSwapLimit();\n+        newVal = getLongLimitValueFromFile(\"memory.swap.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.swap.max\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryAndSwapUsage();\n+        newVal = getLongValueFromFile(\"memory.swap.current\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.swap.current\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemorySoftLimit();\n+        newVal = getLongLimitValueFromFile(\"memory.high\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.high\", oldVal, newVal);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void testCpuAccounting() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuUsage();\n+        long newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"usage_usec\"));\n+\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(\"cpu.stat[usage_usec]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuUserUsage();\n+        newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"user_usec\"));\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(\"cpu.stat[user_usec]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuSystemUsage();\n+        newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"system_usec\"));\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(\"cpu.stat[system_usec]\", oldVal, newVal);\n+        }\n+    }\n+\n+    @Override\n+    public void testCpuSchedulingMetrics() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuPeriod();\n+        long newVal = getCpuPeriodValueFromFile(\"cpu.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.max[$PERIOD]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuQuota();\n+        newVal = getCpuMaxValueFromFile(\"cpu.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.max[$MAX]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuShares();\n+        newVal = getCpuShares(\"cpu.weight\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.weight\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumPeriods();\n+        newVal = getLongValueEntryFromFile(\"cpu.stat\", \"nr_periods\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.stat[nr_periods]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumThrottled();\n+        newVal = getLongValueEntryFromFile(\"cpu.stat\", \"nr_throttled\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.stat[nr_throttled]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuThrottledTime();\n+        newVal = TimeUnit.MICROSECONDS.toNanos(getLongValueEntryFromFile(\"cpu.stat\", \"throttled_usec\"));\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.stat[throttled_usec]\", oldVal, newVal);\n+        }\n+    }\n+\n+    @Override\n+    public void testCpuSets() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        int[] cpus = mapNullToEmpty(metrics.getCpuSetCpus());\n+        Integer[] oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+\n+        String cpusstr = getStringVal(\"cpuset.cpus\");\n+        \/\/ Parse range string in the format 1,2-6,7\n+        Integer[] newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(\"cpuset.cpus\", Arrays.toString(oldVal),\n+                                Arrays.toString(newVal));\n+        }\n+\n+        cpus = mapNullToEmpty(metrics.getEffectiveCpuSetCpus());\n+        oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+        cpusstr = getStringVal(\"cpuset.cpus.effective\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(\"cpuset.cpus.effective\", Arrays.toString(oldVal),\n+                                          Arrays.toString(newVal));\n+        }\n+\n+        cpus = mapNullToEmpty(metrics.getCpuSetMems());\n+        oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+        cpusstr = getStringVal(\"cpuset.mems\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(\"cpuset.mems\", Arrays.toString(oldVal),\n+                                Arrays.toString(newVal));\n+        }\n+\n+        cpus = mapNullToEmpty(metrics.getEffectiveCpuSetMems());\n+        oldVal = Arrays.stream(cpus).boxed().toArray(Integer[]::new);\n+        Arrays.sort(oldVal);\n+        cpusstr = getStringVal(\"cpuset.mems.effective\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        Arrays.sort(newVal);\n+        if (Arrays.compare(oldVal, newVal) != 0) {\n+            fail(\"cpuset.mems.effective\", Arrays.toString(oldVal),\n+                                          Arrays.toString(newVal));\n+        }\n+    }\n+\n+    private int[] mapNullToEmpty(int[] cpus) {\n+        if (cpus == null) {\n+            \/\/ Not available. For sake of testing continue with an\n+            \/\/ empty array.\n+            cpus = new int[0];\n+        }\n+        return cpus;\n+    }\n+\n+    @Override\n+    public void testCpuConsumption() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        \/\/ make system call\n+        long newSysVal = metrics.getCpuSystemUsage();\n+        long newUserVal = metrics.getCpuUserUsage();\n+        long newUsage = metrics.getCpuUsage();\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newSysVal < startSysVal) {\n+            fail(\"getCpuSystemUsage\", newSysVal, startSysVal);\n+        }\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newUserVal < startUserVal) {\n+            fail(\"getCpuUserUsage\", newUserVal, startUserVal);\n+        }\n+\n+        if (newUsage <= startUsage) {\n+            fail(\"getCpuUsage\", newUsage, startUsage);\n+        }\n+    }\n+\n+    @Override\n+    public void testMemoryUsage() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long memoryUsage = metrics.getMemoryUsage();\n+        long newMemoryUsage = 0;\n+\n+        \/\/ allocate memory in a loop and check more than once for new values\n+        \/\/ otherwise we might occasionally see the effect of decreasing new memory\n+        \/\/ values. For example because the system could free up memory\n+        byte[][] bytes = new byte[32][];\n+        for (int i = 0; i < 32; i++) {\n+            bytes[i] = new byte[8*1024*1024];\n+            newMemoryUsage = metrics.getMemoryUsage();\n+            if (newMemoryUsage > memoryUsage) {\n+                break;\n+            }\n+        }\n+\n+        if (newMemoryUsage < memoryUsage) {\n+            fail(\"getMemoryUsage\", memoryUsage, newMemoryUsage);\n+        }\n+    }\n+\n+    @Override\n+    public void testMisc() {\n+        testIOStat();\n+    }\n+\n+    private void testIOStat() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long oldVal = metrics.getBlkIOServiceCount();\n+        long newVal = getIoStatAccumulate(new String[] { \"rios\", \"wios\" });\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"io.stat->rios\/wios: \", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getBlkIOServiced();\n+        newVal = getIoStatAccumulate(new String[] { \"rbytes\", \"wbytes\" });\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"io.stat->rbytes\/wbytes: \", oldVal, newVal);\n+        }\n+    }\n+\n+    private long getIoStatAccumulate(String[] matchNames) {\n+        try {\n+            return Files.lines(Paths.get(UNIFIED.getPath(), \"io.stat\"))\n+                    .map(line -> {\n+                        long accumulator = 0;\n+                        String[] tokens = line.split(\"\\\\s+\");\n+                        for (String t: tokens) {\n+                            String[] keyVal = t.split(\"=\");\n+                            if (keyVal.length != 2) {\n+                                continue;\n+                            }\n+                            for (String match: matchNames) {\n+                                if (match.equals(keyVal[0])) {\n+                                    accumulator += Long.parseLong(keyVal[1]);\n+                                }\n+                            }\n+                        }\n+                        return accumulator;\n+                    }).collect(Collectors.summingLong(e -> e));\n+        } catch (IOException e) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV2.java","additions":468,"deletions":0,"binary":false,"changes":468,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,3 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n@@ -72,1 +75,1 @@\n-        return getOutput(processBuilder.start());\n+        return getOutput(privilegedStart(processBuilder));\n@@ -204,1 +207,1 @@\n-        Process p = processBuilder.start();\n+        Process p = privilegedStart(processBuilder);\n@@ -396,1 +399,1 @@\n-            p = pb.start();\n+            p = privilegedStart(pb);\n@@ -501,0 +504,11 @@\n+    private static Process privilegedStart(ProcessBuilder pb) throws IOException {\n+        try {\n+            return AccessController.doPrivileged(\n+                (PrivilegedExceptionAction<Process>) () -> pb.start());\n+        } catch (PrivilegedActionException e) {\n+            @SuppressWarnings(\"unchecked\")\n+            IOException t = (IOException) e.getException();\n+            throw t;\n+        }\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/process\/ProcessTools.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,4 @@\n-package jdk.testlibrary;\n+package jdk.test.lib.thread;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n","filename":"test\/lib\/jdk\/test\/lib\/thread\/ProcessThread.java","additions":5,"deletions":2,"binary":false,"changes":7,"previous_filename":"test\/jdk\/lib\/testlibrary\/jdk\/testlibrary\/ProcessThread.java","status":"renamed"}]}