{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1089,1 +1089,1 @@\n-  } else if (_i2i_entry != NULL) {\n+  } else if (adapter() != NULL) {\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -214,11 +214,0 @@\n-ImageFileReaderTable::~ImageFileReaderTable() {\n-    for (u4 i = 0; i < _count; i++) {\n-        ImageFileReader* image = _table[i];\n-\n-        if (image != NULL) {\n-            delete image;\n-        }\n-    }\n-    free(_table);\n-}\n-\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -374,1 +374,6 @@\n-    ~ImageFileReaderTable();\n+\/\/ ~ImageFileReaderTable()\n+\/\/ Bug 8166727\n+\/\/\n+\/\/ WARNING: Should never close jimage files.\n+\/\/          Threads may still be running during shutdown.\n+\/\/\n","filename":"src\/java.base\/share\/native\/libjimage\/imageFile.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8059550\n+ * @bug 8059550 8279356\n@@ -37,2 +37,2 @@\n- *                   -XX:-SegmentedCodeCache\n- *                   compiler.codecache.OverflowCodeCacheTest\n+ *                   -XX:-SegmentedCodeCache -Xmixed\n+ *                   compiler.codecache.OverflowCodeCacheTest CompilationDisabled\n@@ -41,1 +41,4 @@\n- *                   -XX:+SegmentedCodeCache\n+ *                   -XX:+SegmentedCodeCache -Xmixed\n+ *                   compiler.codecache.OverflowCodeCacheTest CompilationDisabled\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:-SegmentedCodeCache -Xmixed\n@@ -53,0 +56,1 @@\n+import java.lang.reflect.Method;\n@@ -56,0 +60,5 @@\n+class Helper {\n+    \/\/ Uncommon signature to prevent sharing and force creation of a new adapter\n+    public void method(float a, float b, float c, Object o) { }\n+}\n+\n@@ -58,0 +67,1 @@\n+    private static boolean COMPILATION_DISABLED = false;\n@@ -60,0 +70,1 @@\n+        COMPILATION_DISABLED = args.length > 0;\n@@ -78,0 +89,2 @@\n+        \/\/ Lock compilation to be able to better control code cache space\n+        WHITE_BOX.lockCompilation();\n@@ -92,1 +105,1 @@\n-               possibly have no free cache for futher work *\/\n+               possibly have no free cache for further work *\/\n@@ -94,0 +107,4 @@\n+\n+            \/\/ Use smallest allocation size to make sure all of the available space\n+            \/\/ is filled up. Don't free these below to put some pressure on the sweeper.\n+            while ((addr = WHITE_BOX.allocateCodeBlob(1, type.id)) != 0) { }\n@@ -95,0 +112,8 @@\n+            try {\n+                \/\/ Trigger creation of a new adapter for Helper::method\n+                \/\/ which will fail because we are out of code cache space.\n+                Helper helper = new Helper();\n+            } catch (VirtualMachineError e) {\n+                \/\/ Expected\n+            }\n+            \/\/ Free code cache space\n@@ -98,0 +123,18 @@\n+\n+            \/\/ Convert some nmethods to zombie and then free them to re-enable compilation\n+            WHITE_BOX.unlockCompilation();\n+            WHITE_BOX.forceNMethodSweep();\n+            WHITE_BOX.forceNMethodSweep();\n+\n+            \/\/ Trigger compilation of Helper::method which will hit an assert because\n+            \/\/ adapter creation failed above due to a lack of code cache space.\n+            Helper helper = new Helper();\n+            for (int i = 0; i < 100_000; i++) {\n+                helper.method(0, 0, 0, null);\n+            }\n+        }\n+        \/\/ Only check this if compilation is disabled, otherwise the sweeper might have\n+        \/\/ freed enough nmethods to allow for re-enabling compilation.\n+        if (COMPILATION_DISABLED) {\n+            Asserts.assertNotEquals(compilationActivityMode, 1 \/* run_compilation*\/,\n+                    \"Compilation must be disabled when CodeCache(CodeHeap) overflows\");\n@@ -99,2 +142,0 @@\n-        Asserts.assertNotEquals(compilationActivityMode, 1 \/* run_compilation*\/,\n-                \"Compilation must be disabled when CodeCache(CodeHeap) overflows\");\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/OverflowCodeCacheTest.java","additions":49,"deletions":8,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n- * @run main ThreadPriorities\n+ * @comment Use othervm mode so that we don't capture unrelated threads created by other tests\n+ * @run main\/othervm ThreadPriorities\n@@ -78,1 +79,1 @@\n-        String[] output = new OutputAnalyzer(pb.start()).getOutput().split(\"\\\\n+\");\n+        String[] output = new OutputAnalyzer(pb.start()).getOutput().split(\"\\\\R\");\n@@ -96,2 +97,14 @@\n-        assertEquals(matches, NUMBER_OF_JAVA_PRIORITIES);\n-        assertTrue(failed.isEmpty(), failed.size() + \":\" + failed);\n+        boolean success = false;\n+        try {\n+            assertEquals(matches, NUMBER_OF_JAVA_PRIORITIES);\n+            assertTrue(failed.isEmpty(), failed.size() + \":\" + failed);\n+            success = true;\n+        }\n+        finally {\n+            if (!success) {\n+                System.out.println(\"Failure detected - dumping jstack output:\");\n+                for (String line : output) {\n+                    System.out.println(line);\n+                }\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/ThreadPriorities.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- *      -XX:MaxMetaspaceSize=8m\n+ *      -XX:MaxMetaspaceSize=9m\n@@ -48,1 +48,1 @@\n- *      .\/bin\/classes\n+ *      ..\/..\/classes\/0\/vmTestbase\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/ResourceExhausted\/resexhausted003\/TestDescription.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jdk.test.lib.Utils;\n@@ -90,1 +91,1 @@\n-        return File.createTempFile(\"EvilTransformer\", null, new File(\".\")).getAbsoluteFile();\n+        return Utils.createTempFile(\"EvilTransformer\", null).toFile();\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/EvilInstrument.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.test.lib.Utils;\n@@ -58,2 +59,1 @@\n-        File tmp = File.createTempFile(\"TestDisabledEvents\", \".tmp\", new File(\".\"));\n-        tmp.deleteOnExit();\n+        File tmp = Utils.createTempFile(\"TestDisabledEvents\", \".tmp\").toFile();\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestDisabledEvents.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.test.lib.Utils;\n@@ -51,2 +52,1 @@\n-        File tmp = File.createTempFile(\"TestFileChannelEvents\", \".tmp\", new File(\".\"));\n-        tmp.deleteOnExit();\n+        File tmp = Utils.createTempFile(\"TestFileChannelEvents\", \".tmp\").toFile();\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestFileChannelEvents.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jdk.test.lib.Utils;\n@@ -53,2 +54,1 @@\n-        File tmp = File.createTempFile(\"TestFileReadOnly\", \".tmp\", new File(\".\"));\n-        tmp.deleteOnExit();\n+        File tmp = Utils.createTempFile(\"TestFileReadOnly\", \".tmp\").toFile();\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestFileReadOnly.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.test.lib.Utils;\n@@ -51,2 +52,1 @@\n-        File tmp = File.createTempFile(\"TestFileStreamEvents\", \".tmp\", new File(\".\"));\n-        tmp.deleteOnExit();\n+        File tmp = Utils.createTempFile(\"TestFileStreamEvents\", \".tmp\").toFile();\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestFileStreamEvents.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.test.lib.Utils;\n@@ -50,2 +51,1 @@\n-        File tmp = File.createTempFile(\"TestRandomAccessFileEvents\", \".tmp\", new File(\".\"));\n-        tmp.deleteOnExit();\n+        File tmp = Utils.createTempFile(\"TestRandomAccessFileEvents\", \".tmp\").toFile();\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestRandomAccessFileEvents.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.test.lib.Utils;\n@@ -65,2 +66,2 @@\n-        File tmp = File.createTempFile(\"TestRandomAccessFileThread\", \".tmp\", new File(\".\"));\n-        tmp.deleteOnExit();\n+        File tmp = Utils.createTempFile(\"TestRandomAccessFileThread\", \".tmp\").toFile();\n+\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestRandomAccessFileThread.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.test.lib.Utils;\n@@ -65,1 +66,1 @@\n-        String dumpPath = Files.createTempDirectory(\"dump-path\").toAbsolutePath().toString();\n+        String dumpPath = Utils.createTempDirectory(\"dump-path-\").toAbsolutePath().toString();\n","filename":"test\/jdk\/jdk\/jfr\/jcmd\/TestJcmdConfigure.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,1 @@\n+import jdk.test.lib.Utils;\n@@ -139,1 +140,1 @@\n-        File f = File.createTempFile(\"stream_\" + streamId + \"_\", \".jfr\", new File(\".\"));\n+        File f = Utils.createTempFile(\"stream_\" + streamId + \"_\", \".jfr\").toFile();\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/JmxHelper.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import jdk.test.lib.Utils;\n@@ -120,1 +121,1 @@\n-        File file = File.createTempFile(\"test\", \".jfr\");\n+        File file = Utils.createTempFile(\"test\", \".jfr\").toFile();\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestJavaEvent.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,3 +44,0 @@\n-    static int passes = 0;\n-    static int errors = 0;\n-\n@@ -65,2 +62,0 @@\n-    private static final Map<String, String> env = new HashMap<>();\n-\n@@ -77,2 +72,4 @@\n-    static void run(Map<String, String> env,\n-            int nLLPComponents, String caseID) {\n+    static boolean run(int nLLPComponents, File variantDir, String caseID) {\n+\n+        Map<String, String> env = new HashMap<>();\n+        env.put(LD_LIBRARY_PATH, variantDir.getAbsolutePath());\n@@ -88,1 +85,9 @@\n-        analyze(tr, nLLPComponents, caseID);\n+        int len = getLLPComponents(tr);\n+        if (len == nLLPComponents) {\n+            System.out.printf(\"Test7029048 OK %s%n\", caseID);\n+            return true;\n+        } else {\n+            System.out.printf(\"Test7029048 FAIL %s: expected %d but got %d%n\",\n+                    caseID, nLLPComponents, len);\n+            return false;\n+        }\n@@ -91,1 +96,1 @@\n-    static void analyze(TestResult tr, int nLLPComponents, String caseID) {\n+    static int getLLPComponents(TestResult tr) {\n@@ -100,11 +105,3 @@\n-        int len = (envValue.equals(\"null\")\n-                   ? 0 : envValue.split(File.pathSeparator).length);\n-        if (len == nLLPComponents) {\n-            System.out.println(caseID + \": OK\");\n-            passes++;\n-        } else {\n-            System.out.println(\"FAIL: test7029048, \" + caseID);\n-            System.out.println(\" expected \" + nLLPComponents\n-                               + \" but got \" + len);\n-            System.out.println(envValue);\n-            errors++;\n+\n+        if (envValue.equals(\"null\")) {\n+            return 0;\n@@ -112,0 +109,2 @@\n+\n+        return envValue.split(File.pathSeparator).length;\n@@ -133,1 +132,1 @@\n-    static void test7029048() throws IOException {\n+    static boolean runTest() throws IOException {\n@@ -135,0 +134,1 @@\n+        boolean pass = true;\n@@ -159,2 +159,1 @@\n-                        System.out.println(\"Skipping test case \\\"\" + desc +\n-                                           \"\\\" because the Aix launcher adds the paths in any case.\");\n+                        printSkipMessage(desc);\n@@ -170,2 +169,1 @@\n-                        System.out.println(\"Skipping test case \\\"\" + desc +\n-                                           \"\\\" because the Aix launcher adds the paths in any case.\");\n+                        printSkipMessage(desc);\n@@ -179,0 +177,3 @@\n+            \/\/ Add one to account for our setting\n+            int nLLPComponents = v.value + 1;\n+\n@@ -182,5 +183,1 @@\n-            env.clear();\n-            env.put(LD_LIBRARY_PATH, dstServerDir.getAbsolutePath());\n-            run(env,\n-                v.value + 1,            \/\/ Add one to account for our setting\n-                \"Case 1: \" + desc);\n+            boolean pass1 = run(nLLPComponents, dstServerDir, \"Case 1: \" + desc);\n@@ -191,18 +188,3 @@\n-            env.clear();\n-            env.put(LD_LIBRARY_PATH, dstClientDir.getAbsolutePath());\n-            run(env,\n-                v.value + 1,            \/\/ Add one to account for our setting\n-                \"Case 2: \" + desc);\n-\n-            if (isSolaris) {\n-                \/*\n-                 * Case 3: set the appropriate LLP_XX flag,\n-                 * java64 LLP_64 is relevant, LLP_32 is ignored\n-                 *\/\n-                env.clear();\n-                env.put(LD_LIBRARY_PATH_64, dstServerDir.getAbsolutePath());\n-                run(env,\n-                    v.value,            \/\/ Do not add one, since we didn't set\n-                                        \/\/ LD_LIBRARY_PATH here\n-                    \"Case 3: \" + desc);\n-            }\n+            boolean pass2 = run(nLLPComponents, dstClientDir, \"Case 2: \" + desc);\n+\n+            pass &= pass1 && pass2;\n@@ -210,1 +192,6 @@\n-        return;\n+        return pass;\n+    }\n+\n+    private static void printSkipMessage(String description) {\n+        System.out.printf(\"Skipping test case '%s' because the Aix launcher\" +\n+                          \" adds the paths in any case.%n\", description);\n@@ -225,13 +212,2 @@\n-        \/\/ run the tests\n-        test7029048();\n-        if (errors > 0) {\n-            throw new Exception(\"Test7029048: FAIL: with \"\n-                    + errors + \" errors and passes \" + passes);\n-        } else if (isSolaris && passes < 9) {\n-            throw new Exception(\"Test7029048: FAIL: \" +\n-                    \"all tests did not run, expected \" + 9 + \" got \" + passes);\n-        } else if (isLinux && passes < 6) {\n-             throw new Exception(\"Test7029048: FAIL: \" +\n-                    \"all tests did not run, expected \" + 6 + \" got \" + passes);\n-        } else {\n-            System.out.println(\"Test7029048: PASS \" + passes);\n+        if (!runTest()) {\n+            throw new Exception(\"Test7029048 fails\");\n@@ -240,1 +216,0 @@\n-\n","filename":"test\/jdk\/tools\/launcher\/Test7029048.java","additions":38,"deletions":63,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -769,1 +769,1 @@\n-     * This method is meant as a replacement for {@link Files#createTempDirectory(Path, String, FileAttribute...)}\n+     * This method is meant as a replacement for {@code Files#createTempDirectory(String, String, FileAttribute...)}\n@@ -774,2 +774,2 @@\n-     * @param prefix the prefix string to be used in generating the directory's name; may be null\n-     * @param attrs an optional list of file attributes to set atomically when creating the directory\n+     * @param prefix\n+     * @param attrs\n@@ -777,1 +777,1 @@\n-     * @throws IOException if an I\/O error occurs or dir does not exist\n+     * @throws IOException\n@@ -779,1 +779,1 @@\n-     * @see Files#createTempDirectory(Path, String, FileAttribute...)\n+     * @see {@link Files#createTempDirectory(String, String, FileAttribute...)}\n@@ -783,1 +783,1 @@\n-        return Files.createTempDirectory(dir, prefix, attrs);\n+        return Files.createTempDirectory(dir, prefix);\n","filename":"test\/lib\/jdk\/test\/lib\/Utils.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}