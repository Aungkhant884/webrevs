{"files":[{"filename":"src\/java.base\/share\/classes\/java\/security\/.Security.java.rej.swp","binary":true,"status":"deleted"},{"patch":"@@ -1,1104 +0,0 @@\n-\/*\n- * Copyright (c) 1996, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.security;\n-\n-import java.util.*;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.io.*;\n-import java.net.URL;\n-\n-import jdk.internal.event.EventHelper;\n-import jdk.internal.event.SecurityPropertyModificationEvent;\n-import jdk.internal.misc.SharedSecrets;\n-import jdk.internal.util.StaticProperty;\n-import sun.security.util.Debug;\n-import sun.security.util.PropertyExpander;\n-\n-import sun.security.jca.*;\n-\n-\/**\n- * <p>This class centralizes all security properties and common security\n- * methods. One of its primary uses is to manage providers.\n- *\n- * <p>The default values of security properties are read from an\n- * implementation-specific location, which is typically the properties file\n- * {@code conf\/security\/java.security} in the Java installation directory.\n- *\n- * @author Benjamin Renaud\n- * @since 1.1\n- *\/\n-\n-public final class Security {\n-\n-    \/* Are we debugging? -- for developers *\/\n-    private static final Debug sdebug =\n-                        Debug.getInstance(\"properties\");\n-\n-    \/* The java.security properties *\/\n-    private static Properties props;\n-\n-    \/\/ An element in the cache\n-    private static class ProviderProperty {\n-        String className;\n-        Provider provider;\n-    }\n-\n-    static {\n-        \/\/ doPrivileged here because there are multiple\n-        \/\/ things in initialize that might require privs.\n-        \/\/ (the FileInputStream call and the File.exists call,\n-        \/\/ the securityPropFile call, etc)\n-        AccessController.doPrivileged(new PrivilegedAction<>() {\n-            public Void run() {\n-                initialize();\n-                return null;\n-            }\n-        });\n-    }\n-\n-    private static void initialize() {\n-        props = new Properties();\n-        boolean loadedProps = false;\n-        boolean overrideAll = false;\n-\n-        \/\/ first load the system properties file\n-        \/\/ to determine the value of security.overridePropertiesFile\n-        File propFile = securityPropFile(\"java.security\");\n-        if (propFile.exists()) {\n-            InputStream is = null;\n-            try {\n-                FileInputStream fis = new FileInputStream(propFile);\n-                is = new BufferedInputStream(fis);\n-                props.load(is);\n-                loadedProps = true;\n-\n-                if (sdebug != null) {\n-                    sdebug.println(\"reading security properties file: \" +\n-                                propFile);\n-                }\n-            } catch (IOException e) {\n-                if (sdebug != null) {\n-                    sdebug.println(\"unable to load security properties from \" +\n-                                propFile);\n-                    e.printStackTrace();\n-                }\n-            } finally {\n-                if (is != null) {\n-                    try {\n-                        is.close();\n-                    } catch (IOException ioe) {\n-                        if (sdebug != null) {\n-                            sdebug.println(\"unable to close input stream\");\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        if (\"true\".equalsIgnoreCase(props.getProperty\n-                (\"security.overridePropertiesFile\"))) {\n-\n-            String extraPropFile = System.getProperty\n-                                        (\"java.security.properties\");\n-            if (extraPropFile != null && extraPropFile.startsWith(\"=\")) {\n-                overrideAll = true;\n-                extraPropFile = extraPropFile.substring(1);\n-            }\n-\n-            if (overrideAll) {\n-                props = new Properties();\n-                if (sdebug != null) {\n-                    sdebug.println\n-                        (\"overriding other security properties files!\");\n-                }\n-            }\n-\n-            \/\/ now load the user-specified file so its values\n-            \/\/ will win if they conflict with the earlier values\n-            if (extraPropFile != null) {\n-                BufferedInputStream bis = null;\n-                try {\n-                    URL propURL;\n-\n-                    extraPropFile = PropertyExpander.expand(extraPropFile);\n-                    propFile = new File(extraPropFile);\n-                    if (propFile.exists()) {\n-                        propURL = new URL\n-                                (\"file:\" + propFile.getCanonicalPath());\n-                    } else {\n-                        propURL = new URL(extraPropFile);\n-                    }\n-                    bis = new BufferedInputStream(propURL.openStream());\n-                    props.load(bis);\n-                    loadedProps = true;\n-\n-                    if (sdebug != null) {\n-                        sdebug.println(\"reading security properties file: \" +\n-                                        propURL);\n-                        if (overrideAll) {\n-                            sdebug.println\n-                                (\"overriding other security properties files!\");\n-                        }\n-                    }\n-                } catch (Exception e) {\n-                    if (sdebug != null) {\n-                        sdebug.println\n-                                (\"unable to load security properties from \" +\n-                                extraPropFile);\n-                        e.printStackTrace();\n-                    }\n-                } finally {\n-                    if (bis != null) {\n-                        try {\n-                            bis.close();\n-                        } catch (IOException ioe) {\n-                            if (sdebug != null) {\n-                                sdebug.println(\"unable to close input stream\");\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        if (!loadedProps) {\n-            initializeStatic();\n-            if (sdebug != null) {\n-                sdebug.println(\"unable to load security properties \" +\n-                        \"-- using defaults\");\n-            }\n-        }\n-\n-    }\n-\n-    \/*\n-     * Initialize to default values, if <java.home>\/lib\/java.security\n-     * is not found.\n-     *\/\n-    private static void initializeStatic() {\n-        props.put(\"security.provider.1\", \"sun.security.provider.Sun\");\n-        props.put(\"security.provider.2\", \"sun.security.rsa.SunRsaSign\");\n-        props.put(\"security.provider.3\", \"com.sun.net.ssl.internal.ssl.Provider\");\n-        props.put(\"security.provider.4\", \"com.sun.crypto.provider.SunJCE\");\n-        props.put(\"security.provider.5\", \"sun.security.jgss.SunProvider\");\n-        props.put(\"security.provider.6\", \"com.sun.security.sasl.Provider\");\n-    }\n-\n-    \/**\n-     * Don't let anyone instantiate this.\n-     *\/\n-    private Security() {\n-    }\n-\n-    private static File securityPropFile(String filename) {\n-        \/\/ maybe check for a system property which will specify where to\n-        \/\/ look. Someday.\n-        String sep = File.separator;\n-        return new File(StaticProperty.javaHome() + sep + \"conf\" + sep +\n-                        \"security\" + sep + filename);\n-    }\n-\n-    \/**\n-     * Looks up providers, and returns the property (and its associated\n-     * provider) mapping the key, if any.\n-     * The order in which the providers are looked up is the\n-     * provider-preference order, as specificed in the security\n-     * properties file.\n-     *\/\n-    private static ProviderProperty getProviderProperty(String key) {\n-        ProviderProperty entry = null;\n-\n-        List<Provider> providers = Providers.getProviderList().providers();\n-        for (int i = 0; i < providers.size(); i++) {\n-\n-            String matchKey = null;\n-            Provider prov = providers.get(i);\n-            String prop = prov.getProperty(key);\n-\n-            if (prop == null) {\n-                \/\/ Is there a match if we do a case-insensitive property name\n-                \/\/ comparison? Let's try ...\n-                for (Enumeration<Object> e = prov.keys();\n-                                e.hasMoreElements() && prop == null; ) {\n-                    matchKey = (String)e.nextElement();\n-                    if (key.equalsIgnoreCase(matchKey)) {\n-                        prop = prov.getProperty(matchKey);\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            if (prop != null) {\n-                ProviderProperty newEntry = new ProviderProperty();\n-                newEntry.className = prop;\n-                newEntry.provider = prov;\n-                return newEntry;\n-            }\n-        }\n-\n-        return entry;\n-    }\n-\n-    \/**\n-     * Returns the property (if any) mapping the key for the given provider.\n-     *\/\n-    private static String getProviderProperty(String key, Provider provider) {\n-        String prop = provider.getProperty(key);\n-        if (prop == null) {\n-            \/\/ Is there a match if we do a case-insensitive property name\n-            \/\/ comparison? Let's try ...\n-            for (Enumeration<Object> e = provider.keys();\n-                                e.hasMoreElements() && prop == null; ) {\n-                String matchKey = (String)e.nextElement();\n-                if (key.equalsIgnoreCase(matchKey)) {\n-                    prop = provider.getProperty(matchKey);\n-                    break;\n-                }\n-            }\n-        }\n-        return prop;\n-    }\n-\n-    \/**\n-     * Gets a specified property for an algorithm. The algorithm name\n-     * should be a standard name. See the <a href=\n-     * \"{@docRoot}\/..\/specs\/security\/standard-names.html\">\n-     * Java Security Standard Algorithm Names Specification<\/a>\n-     * for information about standard algorithm names.\n-     *\n-     * One possible use is by specialized algorithm parsers, which may map\n-     * classes to algorithms which they understand (much like Key parsers\n-     * do).\n-     *\n-     * @param algName the algorithm name.\n-     *\n-     * @param propName the name of the property to get.\n-     *\n-     * @return the value of the specified property.\n-     *\n-     * @deprecated This method used to return the value of a proprietary\n-     * property in the master file of the \"SUN\" Cryptographic Service\n-     * Provider in order to determine how to parse algorithm-specific\n-     * parameters. Use the new provider-based and algorithm-independent\n-     * {@code AlgorithmParameters} and {@code KeyFactory} engine\n-     * classes (introduced in the J2SE version 1.2 platform) instead.\n-     *\/\n-    @Deprecated\n-    public static String getAlgorithmProperty(String algName,\n-                                              String propName) {\n-        ProviderProperty entry = getProviderProperty(\"Alg.\" + propName\n-                                                     + \".\" + algName);\n-        if (entry != null) {\n-            return entry.className;\n-        } else {\n-            return null;\n-        }\n-    }\n-\n-    \/**\n-     * Adds a new provider, at a specified position. The position is\n-     * the preference order in which providers are searched for\n-     * requested algorithms.  The position is 1-based, that is,\n-     * 1 is most preferred, followed by 2, and so on.\n-     *\n-     * <p>If the given provider is installed at the requested position,\n-     * the provider that used to be at that position, and all providers\n-     * with a position greater than {@code position}, are shifted up\n-     * one position (towards the end of the list of installed providers).\n-     *\n-     * <p>A provider cannot be added if it is already installed.\n-     *\n-     * <p>If there is a security manager, the\n-     * {@link java.lang.SecurityManager#checkSecurityAccess} method is called\n-     * with the {@code \"insertProvider\"} permission target name to see if\n-     * it's ok to add a new provider. If this permission check is denied,\n-     * {@code checkSecurityAccess} is called again with the\n-     * {@code \"insertProvider.\"+provider.getName()} permission target name. If\n-     * both checks are denied, a {@code SecurityException} is thrown.\n-     *\n-     * @param provider the provider to be added.\n-     *\n-     * @param position the preference position that the caller would\n-     * like for this provider.\n-     *\n-     * @return the actual preference position in which the provider was\n-     * added, or -1 if the provider was not added because it is\n-     * already installed.\n-     *\n-     * @throws  NullPointerException if provider is null\n-     * @throws  SecurityException\n-     *          if a security manager exists and its {@link\n-     *          java.lang.SecurityManager#checkSecurityAccess} method\n-     *          denies access to add a new provider\n-     *\n-     * @see #getProvider\n-     * @see #removeProvider\n-     * @see java.security.SecurityPermission\n-     *\/\n-    public static synchronized int insertProviderAt(Provider provider,\n-            int position) {\n-        String providerName = provider.getName();\n-        checkInsertProvider(providerName);\n-        ProviderList list = Providers.getFullProviderList();\n-        ProviderList newList = ProviderList.insertAt(list, provider, position - 1);\n-        if (list == newList) {\n-            return -1;\n-        }\n-        Providers.setProviderList(newList);\n-        return newList.getIndex(providerName) + 1;\n-    }\n-\n-    \/**\n-     * Adds a provider to the next position available.\n-     *\n-     * <p>If there is a security manager, the\n-     * {@link java.lang.SecurityManager#checkSecurityAccess} method is called\n-     * with the {@code \"insertProvider\"} permission target name to see if\n-     * it's ok to add a new provider. If this permission check is denied,\n-     * {@code checkSecurityAccess} is called again with the\n-     * {@code \"insertProvider.\"+provider.getName()} permission target name. If\n-     * both checks are denied, a {@code SecurityException} is thrown.\n-     *\n-     * @param provider the provider to be added.\n-     *\n-     * @return the preference position in which the provider was\n-     * added, or -1 if the provider was not added because it is\n-     * already installed.\n-     *\n-     * @throws  NullPointerException if provider is null\n-     * @throws  SecurityException\n-     *          if a security manager exists and its {@link\n-     *          java.lang.SecurityManager#checkSecurityAccess} method\n-     *          denies access to add a new provider\n-     *\n-     * @see #getProvider\n-     * @see #removeProvider\n-     * @see java.security.SecurityPermission\n-     *\/\n-    public static int addProvider(Provider provider) {\n-        \/*\n-         * We can't assign a position here because the statically\n-         * registered providers may not have been installed yet.\n-         * insertProviderAt() will fix that value after it has\n-         * loaded the static providers.\n-         *\/\n-        return insertProviderAt(provider, 0);\n-    }\n-\n-    \/**\n-     * Removes the provider with the specified name.\n-     *\n-     * <p>When the specified provider is removed, all providers located\n-     * at a position greater than where the specified provider was are shifted\n-     * down one position (towards the head of the list of installed\n-     * providers).\n-     *\n-     * <p>This method returns silently if the provider is not installed or\n-     * if name is null.\n-     *\n-     * <p>First, if there is a security manager, its\n-     * {@code checkSecurityAccess}\n-     * method is called with the string {@code \"removeProvider.\"+name}\n-     * to see if it's ok to remove the provider.\n-     * If the default implementation of {@code checkSecurityAccess}\n-     * is used (i.e., that method is not overriden), then this will result in\n-     * a call to the security manager's {@code checkPermission} method\n-     * with a {@code SecurityPermission(\"removeProvider.\"+name)}\n-     * permission.\n-     *\n-     * @param name the name of the provider to remove.\n-     *\n-     * @throws  SecurityException\n-     *          if a security manager exists and its {@link\n-     *          java.lang.SecurityManager#checkSecurityAccess} method\n-     *          denies\n-     *          access to remove the provider\n-     *\n-     * @see #getProvider\n-     * @see #addProvider\n-     *\/\n-    public static synchronized void removeProvider(String name) {\n-        check(\"removeProvider.\" + name);\n-        ProviderList list = Providers.getFullProviderList();\n-        ProviderList newList = ProviderList.remove(list, name);\n-        Providers.setProviderList(newList);\n-    }\n-\n-    \/**\n-     * Returns an array containing all the installed providers. The order of\n-     * the providers in the array is their preference order.\n-     *\n-     * @return an array of all the installed providers.\n-     *\/\n-    public static Provider[] getProviders() {\n-        return Providers.getFullProviderList().toArray();\n-    }\n-\n-    \/**\n-     * Returns the provider installed with the specified name, if\n-     * any. Returns null if no provider with the specified name is\n-     * installed or if name is null.\n-     *\n-     * @param name the name of the provider to get.\n-     *\n-     * @return the provider of the specified name.\n-     *\n-     * @see #removeProvider\n-     * @see #addProvider\n-     *\/\n-    public static Provider getProvider(String name) {\n-        return Providers.getProviderList().getProvider(name);\n-    }\n-\n-    \/**\n-     * Returns an array containing all installed providers that satisfy the\n-     * specified selection criterion, or null if no such providers have been\n-     * installed. The returned providers are ordered\n-     * according to their\n-     * {@linkplain #insertProviderAt(java.security.Provider, int) preference order}.\n-     *\n-     * <p> A cryptographic service is always associated with a particular\n-     * algorithm or type. For example, a digital signature service is\n-     * always associated with a particular algorithm (e.g., DSA),\n-     * and a CertificateFactory service is always associated with\n-     * a particular certificate type (e.g., X.509).\n-     *\n-     * <p>The selection criterion must be specified in one of the following two\n-     * formats:\n-     * <ul>\n-     * <li> <i>{@literal <crypto_service>.<algorithm_or_type>}<\/i>\n-     * <p> The cryptographic service name must not contain any dots.\n-     * <p> A\n-     * provider satisfies the specified selection criterion iff the provider\n-     * implements the\n-     * specified algorithm or type for the specified cryptographic service.\n-     * <p> For example, \"CertificateFactory.X.509\"\n-     * would be satisfied by any provider that supplied\n-     * a CertificateFactory implementation for X.509 certificates.\n-     * <li> <i>{@literal <crypto_service>.<algorithm_or_type>\n-     * <attribute_name>:<attribute_value>}<\/i>\n-     * <p> The cryptographic service name must not contain any dots. There\n-     * must be one or more space characters between the\n-     * <i>{@literal <algorithm_or_type>}<\/i> and the\n-     * <i>{@literal <attribute_name>}<\/i>.\n-     *  <p> A provider satisfies this selection criterion iff the\n-     * provider implements the specified algorithm or type for the specified\n-     * cryptographic service and its implementation meets the\n-     * constraint expressed by the specified attribute name\/value pair.\n-     * <p> For example, \"Signature.SHA1withDSA KeySize:1024\" would be\n-     * satisfied by any provider that implemented\n-     * the SHA1withDSA signature algorithm with a keysize of 1024 (or larger).\n-     *\n-     * <\/ul>\n-     *\n-     * <p> See the <a href=\n-     * \"{@docRoot}\/..\/specs\/security\/standard-names.html\">\n-     * Java Security Standard Algorithm Names Specification<\/a>\n-     * for information about standard cryptographic service names, standard\n-     * algorithm names and standard attribute names.\n-     *\n-     * @param filter the criterion for selecting\n-     * providers. The filter is case-insensitive.\n-     *\n-     * @return all the installed providers that satisfy the selection\n-     * criterion, or null if no such providers have been installed.\n-     *\n-     * @throws InvalidParameterException\n-     *         if the filter is not in the required format\n-     * @throws NullPointerException if filter is null\n-     *\n-     * @see #getProviders(java.util.Map)\n-     * @since 1.3\n-     *\/\n-    public static Provider[] getProviders(String filter) {\n-        String key = null;\n-        String value = null;\n-        int index = filter.indexOf(':');\n-\n-        if (index == -1) {\n-            key = filter;\n-            value = \"\";\n-        } else {\n-            key = filter.substring(0, index);\n-            value = filter.substring(index + 1);\n-        }\n-\n-        Hashtable<String, String> hashtableFilter = new Hashtable<>(1);\n-        hashtableFilter.put(key, value);\n-\n-        return (getProviders(hashtableFilter));\n-    }\n-\n-    \/**\n-     * Returns an array containing all installed providers that satisfy the\n-     * specified selection criteria, or null if no such providers have been\n-     * installed. The returned providers are ordered\n-     * according to their\n-     * {@linkplain #insertProviderAt(java.security.Provider, int)\n-     * preference order}.\n-     *\n-     * <p>The selection criteria are represented by a map.\n-     * Each map entry represents a selection criterion.\n-     * A provider is selected iff it satisfies all selection\n-     * criteria. The key for any entry in such a map must be in one of the\n-     * following two formats:\n-     * <ul>\n-     * <li> <i>{@literal <crypto_service>.<algorithm_or_type>}<\/i>\n-     * <p> The cryptographic service name must not contain any dots.\n-     * <p> The value associated with the key must be an empty string.\n-     * <p> A provider\n-     * satisfies this selection criterion iff the provider implements the\n-     * specified algorithm or type for the specified cryptographic service.\n-     * <li>  <i>{@literal <crypto_service>}.\n-     * {@literal <algorithm_or_type> <attribute_name>}<\/i>\n-     * <p> The cryptographic service name must not contain any dots. There\n-     * must be one or more space characters between the\n-     * <i>{@literal <algorithm_or_type>}<\/i>\n-     * and the <i>{@literal <attribute_name>}<\/i>.\n-     * <p> The value associated with the key must be a non-empty string.\n-     * A provider satisfies this selection criterion iff the\n-     * provider implements the specified algorithm or type for the specified\n-     * cryptographic service and its implementation meets the\n-     * constraint expressed by the specified attribute name\/value pair.\n-     * <\/ul>\n-     *\n-     * <p> See the <a href=\n-     * \"{@docRoot}\/..\/specs\/security\/standard-names.html\">\n-     * Java Security Standard Algorithm Names Specification<\/a>\n-     * for information about standard cryptographic service names, standard\n-     * algorithm names and standard attribute names.\n-     *\n-     * @param filter the criteria for selecting\n-     * providers. The filter is case-insensitive.\n-     *\n-     * @return all the installed providers that satisfy the selection\n-     * criteria, or null if no such providers have been installed.\n-     *\n-     * @throws InvalidParameterException\n-     *         if the filter is not in the required format\n-     * @throws NullPointerException if filter is null\n-     *\n-     * @see #getProviders(java.lang.String)\n-     * @since 1.3\n-     *\/\n-    public static Provider[] getProviders(Map<String,String> filter) {\n-        \/\/ Get all installed providers first.\n-        \/\/ Then only return those providers who satisfy the selection criteria.\n-        Provider[] allProviders = Security.getProviders();\n-        Set<String> keySet = filter.keySet();\n-        LinkedHashSet<Provider> candidates = new LinkedHashSet<>(5);\n-\n-        \/\/ Returns all installed providers\n-        \/\/ if the selection criteria is null.\n-        if ((keySet == null) || (allProviders == null)) {\n-            return allProviders;\n-        }\n-\n-        boolean firstSearch = true;\n-\n-        \/\/ For each selection criterion, remove providers\n-        \/\/ which don't satisfy the criterion from the candidate set.\n-        for (Iterator<String> ite = keySet.iterator(); ite.hasNext(); ) {\n-            String key = ite.next();\n-            String value = filter.get(key);\n-\n-            LinkedHashSet<Provider> newCandidates = getAllQualifyingCandidates(key, value,\n-                                                               allProviders);\n-            if (firstSearch) {\n-                candidates = newCandidates;\n-                firstSearch = false;\n-            }\n-\n-            if ((newCandidates != null) && !newCandidates.isEmpty()) {\n-                \/\/ For each provider in the candidates set, if it\n-                \/\/ isn't in the newCandidate set, we should remove\n-                \/\/ it from the candidate set.\n-                for (Iterator<Provider> cansIte = candidates.iterator();\n-                     cansIte.hasNext(); ) {\n-                    Provider prov = cansIte.next();\n-                    if (!newCandidates.contains(prov)) {\n-                        cansIte.remove();\n-                    }\n-                }\n-            } else {\n-                candidates = null;\n-                break;\n-            }\n-        }\n-\n-        if (candidates == null || candidates.isEmpty())\n-            return null;\n-\n-        Object[] candidatesArray = candidates.toArray();\n-        Provider[] result = new Provider[candidatesArray.length];\n-\n-        for (int i = 0; i < result.length; i++) {\n-            result[i] = (Provider)candidatesArray[i];\n-        }\n-\n-        return result;\n-    }\n-\n-    \/\/ Map containing cached Spi Class objects of the specified type\n-    private static final Map<String, Class<?>> spiMap =\n-            new ConcurrentHashMap<>();\n-\n-    \/**\n-     * Return the Class object for the given engine type\n-     * (e.g. \"MessageDigest\"). Works for Spis in the java.security package\n-     * only.\n-     *\/\n-    private static Class<?> getSpiClass(String type) {\n-        Class<?> clazz = spiMap.get(type);\n-        if (clazz != null) {\n-            return clazz;\n-        }\n-        try {\n-            clazz = Class.forName(\"java.security.\" + type + \"Spi\");\n-            spiMap.put(type, clazz);\n-            return clazz;\n-        } catch (ClassNotFoundException e) {\n-            throw new AssertionError(\"Spi class not found\", e);\n-        }\n-    }\n-\n-    \/*\n-     * Returns an array of objects: the first object in the array is\n-     * an instance of an implementation of the requested algorithm\n-     * and type, and the second object in the array identifies the provider\n-     * of that implementation.\n-     * The {@code provider} argument can be null, in which case all\n-     * configured providers will be searched in order of preference.\n-     *\/\n-    static Object[] getImpl(String algorithm, String type, String provider)\n-            throws NoSuchAlgorithmException, NoSuchProviderException {\n-        if (provider == null) {\n-            return GetInstance.getInstance\n-                (type, getSpiClass(type), algorithm).toArray();\n-        } else {\n-            return GetInstance.getInstance\n-                (type, getSpiClass(type), algorithm, provider).toArray();\n-        }\n-    }\n-\n-    static Object[] getImpl(String algorithm, String type, String provider,\n-            Object params) throws NoSuchAlgorithmException,\n-            NoSuchProviderException, InvalidAlgorithmParameterException {\n-        if (provider == null) {\n-            return GetInstance.getInstance\n-                (type, getSpiClass(type), algorithm, params).toArray();\n-        } else {\n-            return GetInstance.getInstance\n-                (type, getSpiClass(type), algorithm, params, provider).toArray();\n-        }\n-    }\n-\n-    \/*\n-     * Returns an array of objects: the first object in the array is\n-     * an instance of an implementation of the requested algorithm\n-     * and type, and the second object in the array identifies the provider\n-     * of that implementation.\n-     * The {@code provider} argument cannot be null.\n-     *\/\n-    static Object[] getImpl(String algorithm, String type, Provider provider)\n-            throws NoSuchAlgorithmException {\n-        return GetInstance.getInstance\n-            (type, getSpiClass(type), algorithm, provider).toArray();\n-    }\n-\n-    static Object[] getImpl(String algorithm, String type, Provider provider,\n-            Object params) throws NoSuchAlgorithmException,\n-            InvalidAlgorithmParameterException {\n-        return GetInstance.getInstance\n-            (type, getSpiClass(type), algorithm, params, provider).toArray();\n-    }\n-\n-    \/**\n-     * Gets a security property value.\n-     *\n-     * <p>First, if there is a security manager, its\n-     * {@code checkPermission}  method is called with a\n-     * {@code java.security.SecurityPermission(\"getProperty.\"+key)}\n-     * permission to see if it's ok to retrieve the specified\n-     * security property value..\n-     *\n-     * @param key the key of the property being retrieved.\n-     *\n-     * @return the value of the security property corresponding to key.\n-     *\n-     * @throws  SecurityException\n-     *          if a security manager exists and its {@link\n-     *          java.lang.SecurityManager#checkPermission} method\n-     *          denies\n-     *          access to retrieve the specified security property value\n-     * @throws  NullPointerException is key is null\n-     *\n-     * @see #setProperty\n-     * @see java.security.SecurityPermission\n-     *\/\n-    public static String getProperty(String key) {\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(new SecurityPermission(\"getProperty.\"+\n-                                                      key));\n-        }\n-        String name = props.getProperty(key);\n-        if (name != null)\n-            name = name.trim(); \/\/ could be a class name with trailing ws\n-        return name;\n-    }\n-\n-    \/**\n-     * Sets a security property value.\n-     *\n-     * <p>First, if there is a security manager, its\n-     * {@code checkPermission} method is called with a\n-     * {@code java.security.SecurityPermission(\"setProperty.\"+key)}\n-     * permission to see if it's ok to set the specified\n-     * security property value.\n-     *\n-     * @param key the name of the property to be set.\n-     *\n-     * @param datum the value of the property to be set.\n-     *\n-     * @throws  SecurityException\n-     *          if a security manager exists and its {@link\n-     *          java.lang.SecurityManager#checkPermission} method\n-     *          denies access to set the specified security property value\n-     * @throws  NullPointerException if key or datum is null\n-     *\n-     * @see #getProperty\n-     * @see java.security.SecurityPermission\n-     *\/\n-    public static void setProperty(String key, String datum) {\n-        check(\"setProperty.\" + key);\n-        props.put(key, datum);\n-        invalidateSMCache(key);  \/* See below. *\/\n-\n-        SecurityPropertyModificationEvent spe = new SecurityPropertyModificationEvent();\n-        \/\/ following is a no-op if event is disabled\n-        spe.key = key;\n-        spe.value = datum;\n-        spe.commit();\n-\n-        if (EventHelper.isLoggingSecurity()) {\n-            EventHelper.logSecurityPropertyEvent(key, datum);\n-        }\n-    }\n-\n-    \/*\n-     * Implementation detail:  If the property we just set in\n-     * setProperty() was either \"package.access\" or\n-     * \"package.definition\", we need to signal to the SecurityManager\n-     * class that the value has just changed, and that it should\n-     * invalidate it's local cache values.\n-     *\/\n-    private static void invalidateSMCache(String key) {\n-\n-        final boolean pa = key.equals(\"package.access\");\n-        final boolean pd = key.equals(\"package.definition\");\n-\n-        if (pa || pd) {\n-            SharedSecrets.getJavaLangAccess().invalidatePackageAccessCache();\n-        }\n-    }\n-\n-    private static void check(String directive) {\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkSecurityAccess(directive);\n-        }\n-    }\n-\n-    private static void checkInsertProvider(String name) {\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            try {\n-                security.checkSecurityAccess(\"insertProvider\");\n-            } catch (SecurityException se1) {\n-                try {\n-                    security.checkSecurityAccess(\"insertProvider.\" + name);\n-                } catch (SecurityException se2) {\n-                    \/\/ throw first exception, but add second to suppressed\n-                    se1.addSuppressed(se2);\n-                    throw se1;\n-                }\n-            }\n-        }\n-    }\n-\n-    \/*\n-    * Returns all providers who satisfy the specified\n-    * criterion.\n-    *\/\n-    private static LinkedHashSet<Provider> getAllQualifyingCandidates(\n-                                                String filterKey,\n-                                                String filterValue,\n-                                                Provider[] allProviders) {\n-        String[] filterComponents = getFilterComponents(filterKey,\n-                                                        filterValue);\n-\n-        \/\/ The first component is the service name.\n-        \/\/ The second is the algorithm name.\n-        \/\/ If the third isn't null, that is the attrinute name.\n-        String serviceName = filterComponents[0];\n-        String algName = filterComponents[1];\n-        String attrName = filterComponents[2];\n-\n-        return getProvidersNotUsingCache(serviceName, algName, attrName,\n-                                         filterValue, allProviders);\n-    }\n-\n-    private static LinkedHashSet<Provider> getProvidersNotUsingCache(\n-                                                String serviceName,\n-                                                String algName,\n-                                                String attrName,\n-                                                String filterValue,\n-                                                Provider[] allProviders) {\n-        LinkedHashSet<Provider> candidates = new LinkedHashSet<>(5);\n-        for (int i = 0; i < allProviders.length; i++) {\n-            if (isCriterionSatisfied(allProviders[i], serviceName,\n-                                     algName,\n-                                     attrName, filterValue)) {\n-                candidates.add(allProviders[i]);\n-            }\n-        }\n-        return candidates;\n-    }\n-\n-    \/*\n-     * Returns true if the given provider satisfies\n-     * the selection criterion key:value.\n-     *\/\n-    private static boolean isCriterionSatisfied(Provider prov,\n-                                                String serviceName,\n-                                                String algName,\n-                                                String attrName,\n-                                                String filterValue) {\n-        String key = serviceName + '.' + algName;\n-\n-        if (attrName != null) {\n-            key += ' ' + attrName;\n-        }\n-        \/\/ Check whether the provider has a property\n-        \/\/ whose key is the same as the given key.\n-        String propValue = getProviderProperty(key, prov);\n-\n-        if (propValue == null) {\n-            \/\/ Check whether we have an alias instead\n-            \/\/ of a standard name in the key.\n-            String standardName = getProviderProperty(\"Alg.Alias.\" +\n-                                                      serviceName + \".\" +\n-                                                      algName,\n-                                                      prov);\n-            if (standardName != null) {\n-                key = serviceName + \".\" + standardName;\n-\n-                if (attrName != null) {\n-                    key += ' ' + attrName;\n-                }\n-\n-                propValue = getProviderProperty(key, prov);\n-            }\n-\n-            if (propValue == null) {\n-                \/\/ The provider doesn't have the given\n-                \/\/ key in its property list.\n-                return false;\n-            }\n-        }\n-\n-        \/\/ If the key is in the format of:\n-        \/\/ <crypto_service>.<algorithm_or_type>,\n-        \/\/ there is no need to check the value.\n-\n-        if (attrName == null) {\n-            return true;\n-        }\n-\n-        \/\/ If we get here, the key must be in the\n-        \/\/ format of <crypto_service>.<algorithm_or_provider> <attribute_name>.\n-        if (isStandardAttr(attrName)) {\n-            return isConstraintSatisfied(attrName, filterValue, propValue);\n-        } else {\n-            return filterValue.equalsIgnoreCase(propValue);\n-        }\n-    }\n-\n-    \/*\n-     * Returns true if the attribute is a standard attribute;\n-     * otherwise, returns false.\n-     *\/\n-    private static boolean isStandardAttr(String attribute) {\n-        \/\/ For now, we just have two standard attributes:\n-        \/\/ KeySize and ImplementedIn.\n-        if (attribute.equalsIgnoreCase(\"KeySize\"))\n-            return true;\n-\n-        if (attribute.equalsIgnoreCase(\"ImplementedIn\"))\n-            return true;\n-\n-        return false;\n-    }\n-\n-    \/*\n-     * Returns true if the requested attribute value is supported;\n-     * otherwise, returns false.\n-     *\/\n-    private static boolean isConstraintSatisfied(String attribute,\n-                                                 String value,\n-                                                 String prop) {\n-        \/\/ For KeySize, prop is the max key size the\n-        \/\/ provider supports for a specific <crypto_service>.<algorithm>.\n-        if (attribute.equalsIgnoreCase(\"KeySize\")) {\n-            int requestedSize = Integer.parseInt(value);\n-            int maxSize = Integer.parseInt(prop);\n-            if (requestedSize <= maxSize) {\n-                return true;\n-            } else {\n-                return false;\n-            }\n-        }\n-\n-        \/\/ For Type, prop is the type of the implementation\n-        \/\/ for a specific <crypto service>.<algorithm>.\n-        if (attribute.equalsIgnoreCase(\"ImplementedIn\")) {\n-            return value.equalsIgnoreCase(prop);\n-        }\n-\n-        return false;\n-    }\n-\n-    static String[] getFilterComponents(String filterKey, String filterValue) {\n-        int algIndex = filterKey.indexOf('.');\n-\n-        if (algIndex < 0) {\n-            \/\/ There must be a dot in the filter, and the dot\n-            \/\/ shouldn't be at the beginning of this string.\n-            throw new InvalidParameterException(\"Invalid filter\");\n-        }\n-\n-        String serviceName = filterKey.substring(0, algIndex);\n-        String algName = null;\n-        String attrName = null;\n-\n-        if (filterValue.isEmpty()) {\n-            \/\/ The filterValue is an empty string. So the filterKey\n-            \/\/ should be in the format of <crypto_service>.<algorithm_or_type>.\n-            algName = filterKey.substring(algIndex + 1).trim();\n-            if (algName.isEmpty()) {\n-                \/\/ There must be a algorithm or type name.\n-                throw new InvalidParameterException(\"Invalid filter\");\n-            }\n-        } else {\n-            \/\/ The filterValue is a non-empty string. So the filterKey must be\n-            \/\/ in the format of\n-            \/\/ <crypto_service>.<algorithm_or_type> <attribute_name>\n-            int attrIndex = filterKey.indexOf(' ');\n-\n-            if (attrIndex == -1) {\n-                \/\/ There is no attribute name in the filter.\n-                throw new InvalidParameterException(\"Invalid filter\");\n-            } else {\n-                attrName = filterKey.substring(attrIndex + 1).trim();\n-                if (attrName.isEmpty()) {\n-                    \/\/ There is no attribute name in the filter.\n-                    throw new InvalidParameterException(\"Invalid filter\");\n-                }\n-            }\n-\n-            \/\/ There must be an algorithm name in the filter.\n-            if ((attrIndex < algIndex) ||\n-                (algIndex == attrIndex - 1)) {\n-                throw new InvalidParameterException(\"Invalid filter\");\n-            } else {\n-                algName = filterKey.substring(algIndex + 1, attrIndex);\n-            }\n-        }\n-\n-        String[] result = new String[3];\n-        result[0] = serviceName;\n-        result[1] = algName;\n-        result[2] = attrName;\n-\n-        return result;\n-    }\n-\n-    \/**\n-     * Returns a Set of Strings containing the names of all available\n-     * algorithms or types for the specified Java cryptographic service\n-     * (e.g., Signature, MessageDigest, Cipher, Mac, KeyStore). Returns\n-     * an empty Set if there is no provider that supports the\n-     * specified service or if serviceName is null. For a complete list\n-     * of Java cryptographic services, please see the\n-     * {@extLink security_guide_jca\n-     * Java Cryptography Architecture (JCA) Reference Guide}.\n-     * Note: the returned set is immutable.\n-     *\n-     * @param serviceName the name of the Java cryptographic\n-     * service (e.g., Signature, MessageDigest, Cipher, Mac, KeyStore).\n-     * Note: this parameter is case-insensitive.\n-     *\n-     * @return a Set of Strings containing the names of all available\n-     * algorithms or types for the specified Java cryptographic service\n-     * or an empty set if no provider supports the specified service.\n-     *\n-     * @since 1.4\n-     **\/\n-    public static Set<String> getAlgorithms(String serviceName) {\n-\n-        if ((serviceName == null) || (serviceName.isEmpty()) ||\n-            (serviceName.endsWith(\".\"))) {\n-            return Collections.emptySet();\n-        }\n-\n-        HashSet<String> result = new HashSet<>();\n-        Provider[] providers = Security.getProviders();\n-\n-        for (int i = 0; i < providers.length; i++) {\n-            \/\/ Check the keys for each provider.\n-            for (Enumeration<Object> e = providers[i].keys();\n-                                                e.hasMoreElements(); ) {\n-                String currentKey =\n-                        ((String)e.nextElement()).toUpperCase(Locale.ENGLISH);\n-                if (currentKey.startsWith(\n-                        serviceName.toUpperCase(Locale.ENGLISH))) {\n-                    \/\/ We should skip the currentKey if it contains a\n-                    \/\/ whitespace. The reason is: such an entry in the\n-                    \/\/ provider property contains attributes for the\n-                    \/\/ implementation of an algorithm. We are only interested\n-                    \/\/ in entries which lead to the implementation\n-                    \/\/ classes.\n-                    if (currentKey.indexOf(' ') < 0) {\n-                        result.add(currentKey.substring(\n-                                                serviceName.length() + 1));\n-                    }\n-                }\n-            }\n-        }\n-        return Collections.unmodifiableSet(result);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/security\/Security.java.orig","additions":0,"deletions":1104,"binary":false,"changes":1104,"status":"deleted"}]}