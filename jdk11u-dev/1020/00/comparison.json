{"files":[{"patch":"@@ -29,1 +29,2 @@\n- * Data structure to hold info from \/proc\/self\/cgroup\n+ * Data structure to hold info from \/proc\/self\/cgroup,\n+ * \/proc\/cgroups and \/proc\/self\/mountinfo\n@@ -35,1 +36,1 @@\n-class CgroupInfo {\n+public class CgroupInfo {\n@@ -40,0 +41,3 @@\n+    private String mountPoint;\n+    private String mountRoot;\n+    private String cgroupPath;\n@@ -47,1 +51,1 @@\n-    String getName() {\n+    public String getName() {\n@@ -51,1 +55,1 @@\n-    int getHierarchyId() {\n+    public int getHierarchyId() {\n@@ -55,1 +59,1 @@\n-    boolean isEnabled() {\n+    public boolean isEnabled() {\n@@ -59,0 +63,46 @@\n+    public String getMountPoint() {\n+        return mountPoint;\n+    }\n+\n+    public void setMountPoint(String mountPoint) {\n+        this.mountPoint = mountPoint;\n+    }\n+\n+    public String getMountRoot() {\n+        return mountRoot;\n+    }\n+\n+    public void setMountRoot(String mountRoot) {\n+        this.mountRoot = mountRoot;\n+    }\n+\n+    public String getCgroupPath() {\n+        return cgroupPath;\n+    }\n+\n+    public void setCgroupPath(String cgroupPath) {\n+        this.cgroupPath = cgroupPath;\n+    }\n+\n+    \/*\n+     * Creates a CgroupInfo instance from a line in \/proc\/cgroups.\n+     * Comment token (hash) is handled by the caller.\n+     *\n+     * Example (annotated):\n+     *\n+     * #subsys_name     hierarchy       num_cgroups     enabled\n+     * cpuset           10              1               1         (a)\n+     * cpu              7               8               1         (b)\n+     * [...]\n+     *\n+     * Line (a) would yield:\n+     *   info = new CgroupInfo(\"cpuset\", 10, true);\n+     *   return info;\n+     * Line (b) results in:\n+     *   info = new CgroupInfo(\"cpu\", 7, true);\n+     *   return info;\n+     *\n+     *\n+     * See CgroupSubsystemFactory.determineType()\n+     *\n+     *\/\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupInfo.java","additions":55,"deletions":5,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.io.UncheckedIOException;\n@@ -31,0 +32,1 @@\n+import java.nio.file.Path;\n@@ -32,0 +34,1 @@\n+import java.util.Collections;\n@@ -36,0 +39,1 @@\n+import java.util.function.Consumer;\n@@ -71,1 +75,1 @@\n-        \"[^\\\\s]+\\\\s+([^\\\\s]+)\\\\s+\" +           \/\/ (4), (5)     - group 1: mount point\n+        \"([^\\\\s]+)\\\\s+([^\\\\s]+)\\\\s+\" +         \/\/ (4), (5)     - group 1, 2: root, mount point\n@@ -73,1 +77,1 @@\n-        \"([^\\\\s]+)\\\\s+\" +                      \/\/ (9)          - group 2: filesystem type\n+        \"([^\\\\s]+)\\\\s+\" +                      \/\/ (9)          - group 3: filesystem type\n@@ -79,1 +83,1 @@\n-            optResult = determineType(\"\/proc\/self\/mountinfo\", \"\/proc\/cgroups\");\n+            optResult = determineType(\"\/proc\/self\/mountinfo\", \"\/proc\/cgroups\", \"\/proc\/self\/cgroup\");\n@@ -82,0 +86,2 @@\n+        } catch (UncheckedIOException e) {\n+            return null;\n@@ -103,0 +109,1 @@\n+        Map<String, CgroupInfo> infos = result.getInfos();\n@@ -104,1 +111,3 @@\n-            CgroupSubsystem subsystem = CgroupV2Subsystem.getInstance();\n+            \/\/ For unified it doesn't matter which controller we pick.\n+            CgroupInfo anyController = infos.get(MEMORY_CTRL);\n+            CgroupSubsystem subsystem = CgroupV2Subsystem.getInstance(anyController);\n@@ -107,1 +116,1 @@\n-            CgroupV1Subsystem subsystem = CgroupV1Subsystem.getInstance();\n+            CgroupV1Subsystem subsystem = CgroupV1Subsystem.getInstance(infos);\n@@ -112,2 +121,19 @@\n-    public static Optional<CgroupTypeResult> determineType(String mountInfo, String cgroups) throws IOException {\n-        Map<String, CgroupInfo> infos = new HashMap<>();\n+    \/*\n+     * Determine the type of the cgroup system (v1 - legacy or hybrid - or, v2 - unified)\n+     * based on three files:\n+     *\n+     *  (1) mountInfo  (i.e. \/proc\/self\/mountinfo)\n+     *  (2) cgroups    (i.e. \/proc\/cgroups)\n+     *  (3) selfCgroup (i.e. \/proc\/self\/cgroup)\n+     *\n+     * File 'cgroups' is inspected for the hierarchy ID of the mounted cgroup pseudo\n+     * filesystem. The hierarchy ID, in turn, helps us distinguish cgroups v2 and\n+     * cgroup v1. For a system with zero hierarchy ID, but with >= 1 relevant cgroup\n+     * controllers mounted in 'mountInfo' we can infer it's cgroups v2. Anything else\n+     * will be cgroup v1 (hybrid or legacy). File 'selfCgroup' is being used for\n+     * figuring out the mount path of the controller in the cgroup hierarchy.\n+     *\/\n+    public static Optional<CgroupTypeResult> determineType(String mountInfo,\n+                                                           String cgroups,\n+                                                           String selfCgroup) throws IOException {\n+        final Map<String, CgroupInfo> infos = new HashMap<>();\n@@ -144,2 +170,2 @@\n-        \/\/ If there are no mounted, relevant cgroup controllers in mountinfo and only\n-        \/\/ 0 hierarchy IDs in \/proc\/cgroups have been seen, we are on a cgroups v1 system.\n+        \/\/ If there are no mounted, relevant cgroup controllers in 'mountinfo' and only\n+        \/\/ 0 hierarchy IDs in file 'cgroups' have been seen, we are on a cgroups v1 system.\n@@ -149,4 +175,21 @@\n-        try (Stream<String> mntInfo = CgroupUtil.readFilePrivileged(Paths.get(mountInfo))) {\n-            boolean anyCgroupMounted = mntInfo.anyMatch(CgroupSubsystemFactory::isRelevantControllerMount);\n-            if (!anyCgroupMounted && isCgroupsV2) {\n-                return Optional.empty();\n+        lines = CgroupUtil.readAllLinesPrivileged(Paths.get(mountInfo));\n+        boolean anyCgroupMounted = false;\n+        for (String line: lines) {\n+            boolean cgroupsControllerFound = amendCgroupInfos(line, infos, isCgroupsV2);\n+            anyCgroupMounted = anyCgroupMounted || cgroupsControllerFound;\n+        }\n+        if (!anyCgroupMounted) {\n+            return Optional.empty();\n+        }\n+\n+        \/\/ Map a cgroup version specific 'action' to a line in 'selfCgroup' (i.e.\n+        \/\/ \/proc\/self\/cgroups) , split on the ':' token, so as to set the appropriate\n+        \/\/ path to the cgroup controller in cgroup data structures 'infos'.\n+        \/\/ See:\n+        \/\/   setCgroupV1Path() for the action run for cgroups v1 systems\n+        \/\/   setCgroupV2Path() for the action run for cgroups v2 systems\n+        try (Stream<String> selfCgroupLines =\n+             CgroupUtil.readFilePrivileged(Paths.get(selfCgroup))) {\n+            Consumer<String[]> action = (tokens -> setCgroupV1Path(infos, tokens));\n+            if (isCgroupsV2) {\n+                action = (tokens -> setCgroupV2Path(infos, tokens));\n@@ -154,0 +197,4 @@\n+            \/\/ The limit value of 3 is because \/proc\/self\/cgroup contains three\n+            \/\/ colon-separated tokens per line. The last token, cgroup path, might\n+            \/\/ contain a ':'.\n+            selfCgroupLines.map(line -> line.split(\":\", 3)).forEach(action);\n@@ -155,1 +202,6 @@\n-        CgroupTypeResult result = new CgroupTypeResult(isCgroupsV2, anyControllersEnabled, anyCgroupsV2Controller, anyCgroupsV1Controller);\n+\n+        CgroupTypeResult result = new CgroupTypeResult(isCgroupsV2,\n+                                                       anyControllersEnabled,\n+                                                       anyCgroupsV2Controller,\n+                                                       anyCgroupsV1Controller,\n+                                                       Collections.unmodifiableMap(infos));\n@@ -159,23 +211,141 @@\n-    private static boolean isRelevantControllerMount(String line) {\n-         Matcher lineMatcher = MOUNTINFO_PATTERN.matcher(line.trim());\n-         if (lineMatcher.matches()) {\n-             String mountPoint = lineMatcher.group(1);\n-             String fsType = lineMatcher.group(2);\n-             if (fsType.equals(\"cgroup\")) {\n-                 String filename = Paths.get(mountPoint).getFileName().toString();\n-                 for (String fn: filename.split(\",\")) {\n-                     switch (fn) {\n-                         case MEMORY_CTRL: \/\/ fall through\n-                         case CPU_CTRL:\n-                         case CPUSET_CTRL:\n-                         case CPUACCT_CTRL:\n-                         case BLKIO_CTRL:\n-                             return true;\n-                         default: break; \/\/ ignore not recognized controllers\n-                     }\n-                 }\n-             } else if (fsType.equals(\"cgroup2\")) {\n-                 return true;\n-             }\n-         }\n-         return false;\n+    \/*\n+     * Sets the path to the cgroup controller for cgroups v2 based on a line\n+     * in \/proc\/self\/cgroup file (represented as the 'tokens' array).\n+     *\n+     * Example:\n+     *\n+     * 0::\/\n+     *\n+     * => tokens = [ \"0\", \"\", \"\/\" ]\n+     *\/\n+    private static void setCgroupV2Path(Map<String, CgroupInfo> infos,\n+                                        String[] tokens) {\n+        int hierarchyId = Integer.parseInt(tokens[0]);\n+        String cgroupPath = tokens[2];\n+        for (CgroupInfo info: infos.values()) {\n+            assert hierarchyId == info.getHierarchyId() && hierarchyId == 0;\n+            info.setCgroupPath(cgroupPath);\n+        }\n+    }\n+\n+    \/*\n+     * Sets the path to the cgroup controller for cgroups v1 based on a line\n+     * in \/proc\/self\/cgroup file (represented as the 'tokens' array).\n+     *\n+     * Note that multiple controllers might be joined at a single path.\n+     *\n+     * Example:\n+     *\n+     * 7:cpu,cpuacct:\/system.slice\/docker-74ad896fb40bbefe0f181069e4417505fffa19052098f27edf7133f31423bc0b.scope\n+     *\n+     * => tokens = [ \"7\", \"cpu,cpuacct\", \"\/system.slice\/docker-74ad896fb40bbefe0f181069e4417505fffa19052098f27edf7133f31423bc0b.scope\" ]\n+     *\/\n+    private static void setCgroupV1Path(Map<String, CgroupInfo> infos,\n+                                        String[] tokens) {\n+        String controllerName = tokens[1];\n+        String cgroupPath = tokens[2];\n+        if (controllerName != null && cgroupPath != null) {\n+            for (String cName: controllerName.split(\",\")) {\n+                switch (cName) {\n+                    case MEMORY_CTRL: \/\/ fall through\n+                    case CPUSET_CTRL:\n+                    case CPUACCT_CTRL:\n+                    case CPU_CTRL:\n+                    case BLKIO_CTRL:\n+                        CgroupInfo info = infos.get(cName);\n+                        info.setCgroupPath(cgroupPath);\n+                        break;\n+                    \/\/ Ignore not recognized controllers\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Amends cgroup infos with mount path and mount root. The passed in\n+     * 'mntInfoLine' represents a single line in, for example,\n+     * \/proc\/self\/mountinfo. Each line is matched with MOUNTINFO_PATTERN\n+     * (see above), so as to extract the relevant tokens from the line.\n+     *\n+     * Host example cgroups v1:\n+     *\n+     * 44 30 0:41 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,seclabel,devices\n+     *\n+     * Container example cgroups v1:\n+     *\n+     * 1901 1894 0:37 \/system.slice\/docker-2291eeb92093f9d761aaf971782b575e9be56bd5930d4b5759b51017df3c1387.scope \/sys\/fs\/cgroup\/cpu,cpuacct ro,nosuid,nodev,noexec,relatime master:12 - cgroup cgroup rw,seclabel,cpu,cpuacct\n+     *\n+     * Container example cgroups v2:\n+     *\n+     * 1043 1034 0:27 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec,relatime - cgroup2 cgroup2 rw,seclabel,nsdelegate\n+     *\n+     *\n+     * @return {@code true} iff a relevant controller has been found at the\n+     * given line\n+     *\/\n+    private static boolean amendCgroupInfos(String mntInfoLine,\n+                                            Map<String, CgroupInfo> infos,\n+                                            boolean isCgroupsV2) {\n+        Matcher lineMatcher = MOUNTINFO_PATTERN.matcher(mntInfoLine.trim());\n+        boolean cgroupv1ControllerFound = false;\n+        boolean cgroupv2ControllerFound = false;\n+        if (lineMatcher.matches()) {\n+            String mountRoot = lineMatcher.group(1);\n+            String mountPath = lineMatcher.group(2);\n+            String fsType = lineMatcher.group(3);\n+            if (fsType.equals(\"cgroup\")) {\n+                Path p = Paths.get(mountPath);\n+                String[] controllerNames = p.getFileName().toString().split(\",\");\n+                for (String controllerName: controllerNames) {\n+                    switch (controllerName) {\n+                        case MEMORY_CTRL: \/\/ fall-through\n+                        case CPU_CTRL:\n+                        case CPUACCT_CTRL:\n+                        case BLKIO_CTRL: {\n+                            CgroupInfo info = infos.get(controllerName);\n+                            assert info.getMountPoint() == null;\n+                            assert info.getMountRoot() == null;\n+                            info.setMountPoint(mountPath);\n+                            info.setMountRoot(mountRoot);\n+                            cgroupv1ControllerFound = true;\n+                            break;\n+                        }\n+                        case CPUSET_CTRL: {\n+                            CgroupInfo info = infos.get(controllerName);\n+                            if (info.getMountPoint() != null) {\n+                                \/\/ On some systems duplicate cpuset controllers get mounted in addition to\n+                                \/\/ the main cgroup controllers most likely under \/sys\/fs\/cgroup. In that\n+                                \/\/ case pick the one under \/sys\/fs\/cgroup and discard others.\n+                                if (!info.getMountPoint().startsWith(\"\/sys\/fs\/cgroup\")) {\n+                                    info.setMountPoint(mountPath);\n+                                    info.setMountRoot(mountRoot);\n+                                }\n+                            } else {\n+                                info.setMountPoint(mountPath);\n+                                info.setMountRoot(mountRoot);\n+                            }\n+                            cgroupv1ControllerFound = true;\n+                            break;\n+                        }\n+                        default:\n+                            \/\/ Ignore controllers which we don't recognize\n+                            break;\n+                    }\n+                }\n+            } else if (fsType.equals(\"cgroup2\")) {\n+                if (isCgroupsV2) { \/\/ will be false for hybrid\n+                    \/\/ All controllers have the same mount point and root mount\n+                    \/\/ for unified hierarchy.\n+                    for (CgroupInfo info: infos.values()) {\n+                        assert info.getMountPoint() == null;\n+                        assert info.getMountRoot() == null;\n+                        info.setMountPoint(mountPath);\n+                        info.setMountRoot(mountRoot);\n+                    }\n+                }\n+                cgroupv2ControllerFound = true;\n+            }\n+        }\n+        return cgroupv1ControllerFound || cgroupv2ControllerFound;\n@@ -189,0 +359,1 @@\n+        private final Map<String, CgroupInfo> infos;\n@@ -193,1 +364,2 @@\n-                                 boolean anyCgroupV1Controllers) {\n+                                 boolean anyCgroupV1Controllers,\n+                                 Map<String, CgroupInfo> infos) {\n@@ -198,0 +370,1 @@\n+            this.infos = infos;\n@@ -215,0 +388,4 @@\n+\n+        public Map<String, CgroupInfo> getInfos() {\n+            return infos;\n+        }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":215,"deletions":38,"binary":false,"changes":253,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.stream.Stream;\n+import java.util.Map;\n@@ -34,0 +30,1 @@\n+import jdk.internal.platform.CgroupInfo;\n@@ -36,1 +33,0 @@\n-import jdk.internal.platform.CgroupUtil;\n@@ -45,1 +41,0 @@\n-    private boolean activeSubSystems;\n@@ -47,1 +42,1 @@\n-    private static final CgroupV1Subsystem INSTANCE = initSubSystem();\n+    private static volatile CgroupV1Subsystem INSTANCE;\n@@ -51,3 +46,1 @@\n-    private CgroupV1Subsystem() {\n-        activeSubSystems = false;\n-    }\n+    private CgroupV1Subsystem() {}\n@@ -55,1 +48,19 @@\n-    public static CgroupV1Subsystem getInstance() {\n+    \/**\n+     * Get a singleton instance of CgroupV1Subsystem. Initially, it creates a new\n+     * object by retrieving the pre-parsed information from cgroup interface\n+     * files from the provided 'infos' map.\n+     *\n+     * See CgroupSubsystemFactory.determineType() where the actual parsing of\n+     * cgroup interface files happens.\n+     *\n+     * @return A singleton CgroupV1Subsystem instance, never null\n+     *\/\n+    public static CgroupV1Subsystem getInstance(Map<String, CgroupInfo> infos) {\n+        if (INSTANCE == null) {\n+            CgroupV1Subsystem tmpSubsystem = initSubSystem(infos);\n+            synchronized (CgroupV1Subsystem.class) {\n+                if (INSTANCE == null) {\n+                    INSTANCE = tmpSubsystem;\n+                }\n+            }\n+        }\n@@ -59,1 +70,1 @@\n-    private static CgroupV1Subsystem initSubSystem() {\n+    private static CgroupV1Subsystem initSubSystem(Map<String, CgroupInfo> infos) {\n@@ -62,9 +73,4 @@\n-        \/**\n-         * Find the cgroup mount points for subsystems\n-         * by reading \/proc\/self\/mountinfo\n-         *\n-         * Example for docker MemorySubSystem subsystem:\n-         * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/MemorySubSystem ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,MemorySubSystem\n-         *\n-         * Example for host:\n-         * 34 28 0:29 \/ \/sys\/fs\/cgroup\/MemorySubSystem rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,MemorySubSystem\n+        boolean anyActiveControllers = false;\n+        \/*\n+         * Find the cgroup mount points for subsystem controllers\n+         * by looking up relevant data in the infos map\n@@ -72,50 +78,54 @@\n-        try (Stream<String> lines =\n-                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n-\n-            lines.filter(line -> line.contains(\" - cgroup \"))\n-                 .map(line -> line.split(\" \"))\n-                 .forEach(entry -> createSubSystemController(subsystem, entry));\n-\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        } catch (IOException e) {\n-            return null;\n-        }\n-\n-        \/**\n-         * Read \/proc\/self\/cgroup and map host mount point to\n-         * local one via \/proc\/self\/mountinfo content above\n-         *\n-         * Docker example:\n-         * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n-         *\n-         * Host example:\n-         * 5:memory:\/user.slice\n-         *\n-         * Construct a path to the process specific memory and cpuset\n-         * cgroup directory.\n-         *\n-         * For a container running under Docker from memory example above\n-         * the paths would be:\n-         *\n-         * \/sys\/fs\/cgroup\/memory\n-         *\n-         * For a Host from memory example above the path would be:\n-         *\n-         * \/sys\/fs\/cgroup\/memory\/user.slice\n-         *\n-         *\/\n-        try (Stream<String> lines =\n-            CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/cgroup\"))) {\n-\n-            \/\/ The limit value of 3 is because \/proc\/self\/cgroup contains three\n-            \/\/ colon-separated tokens per line. The last token, cgroup path, might\n-            \/\/ contain a ':'.\n-            lines.map(line -> line.split(\":\", 3))\n-                 .filter(line -> (line.length >= 3))\n-                 .forEach(line -> setSubSystemControllerPath(subsystem, line));\n-\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        } catch (IOException e) {\n-            return null;\n+        for (CgroupInfo info: infos.values()) {\n+            switch (info.getName()) {\n+            case \"memory\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1MemorySubSystemController controller = new CgroupV1MemorySubSystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    boolean isHierarchial = getHierarchical(controller);\n+                    controller.setHierarchical(isHierarchial);\n+                    boolean isSwapEnabled = getSwapEnabled(controller);\n+                    controller.setSwapEnabled(isSwapEnabled);\n+                    subsystem.setMemorySubSystem(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            case \"cpuset\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setCpuSetController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            case \"cpuacct\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setCpuAcctController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            case \"cpu\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setCpuController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            case \"blkio\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setBlkIOController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            default:\n+                throw new AssertionError(\"Unrecognized controller in infos: \" + info.getName());\n+            }\n@@ -125,1 +135,1 @@\n-        if (subsystem.activeSubSystems()) {\n+        if (anyActiveControllers) {\n@@ -132,80 +142,0 @@\n-    \/**\n-     * createSubSystem objects and initialize mount points\n-     *\/\n-    private static void createSubSystemController(CgroupV1Subsystem subsystem, String[] mountentry) {\n-        if (mountentry.length < 5) return;\n-\n-        Path p = Paths.get(mountentry[4]);\n-        String[] subsystemNames = p.getFileName().toString().split(\",\");\n-\n-        for (String subsystemName: subsystemNames) {\n-            switch (subsystemName) {\n-                case \"memory\":\n-                    subsystem.setMemorySubSystem(new CgroupV1MemorySubSystemController(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpuset\":\n-                    subsystem.setCpuSetController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpuacct\":\n-                    subsystem.setCpuAcctController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpu\":\n-                    subsystem.setCpuController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"blkio\":\n-                    subsystem.setBlkIOController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n-                    break;\n-                default:\n-                    \/\/ Ignore subsystems that we don't support\n-                    break;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * setSubSystemPath based on the contents of \/proc\/self\/cgroup\n-     *\/\n-    private static void setSubSystemControllerPath(CgroupV1Subsystem subsystem, String[] entry) {\n-        String controller = entry[1];\n-        String base = entry[2];\n-        if (controller != null && base != null) {\n-            for (String cName: controller.split(\",\")) {\n-                switch (cName) {\n-                    case \"memory\":\n-                        setPath(subsystem, subsystem.memoryController(), base);\n-                        break;\n-                    case \"cpuset\":\n-                        setPath(subsystem, subsystem.cpuSetController(), base);\n-                        break;\n-                    case \"cpuacct\":\n-                        setPath(subsystem, subsystem.cpuController(), base);\n-                        break;\n-                    case \"cpu\":\n-                        setPath(subsystem, subsystem.cpuAcctController(), base);\n-                        break;\n-                    case \"blkio\":\n-                        setPath(subsystem, subsystem.blkIOController(), base);\n-                        break;\n-                    \/\/ Ignore subsystems that we don't support\n-                    default:\n-                        break;\n-                }\n-            }\n-        }\n-    }\n-\n-    private static void setPath(CgroupV1Subsystem subsystem, CgroupV1SubsystemController controller, String base) {\n-        if (controller != null) {\n-            controller.setPath(base);\n-            if (controller instanceof CgroupV1MemorySubSystemController) {\n-                CgroupV1MemorySubSystemController memorySubSystem = (CgroupV1MemorySubSystemController)controller;\n-                boolean isHierarchial = getHierarchical(memorySubSystem);\n-                memorySubSystem.setHierarchical(isHierarchial);\n-                boolean isSwapEnabled = getSwapEnabled(memorySubSystem);\n-                memorySubSystem.setSwapEnabled(isSwapEnabled);\n-            }\n-            subsystem.setActiveSubSystems();\n-        }\n-    }\n-\n-\n@@ -223,8 +153,0 @@\n-    private void setActiveSubSystems() {\n-        activeSubSystems = true;\n-    }\n-\n-    private boolean activeSubSystems() {\n-        return activeSubSystems;\n-    }\n-\n@@ -251,20 +173,0 @@\n-    private CgroupV1SubsystemController memoryController() {\n-        return memory;\n-    }\n-\n-    private CgroupV1SubsystemController cpuController() {\n-        return cpu;\n-    }\n-\n-    private CgroupV1SubsystemController cpuAcctController() {\n-        return cpuacct;\n-    }\n-\n-    private CgroupV1SubsystemController cpuSetController() {\n-        return cpuset;\n-    }\n-\n-    private CgroupV1SubsystemController blkIOController() {\n-        return blkio;\n-    }\n-\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":83,"deletions":181,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.List;\n@@ -35,1 +34,0 @@\n-import java.util.stream.Stream;\n@@ -37,0 +35,1 @@\n+import jdk.internal.platform.CgroupInfo;\n@@ -43,1 +42,1 @@\n-    private static final CgroupV2Subsystem INSTANCE = initSubsystem();\n+    private static volatile CgroupV2Subsystem INSTANCE;\n@@ -63,26 +62,20 @@\n-    private static CgroupV2Subsystem initSubsystem() {\n-        \/\/ read mountinfo so as to determine root mount path\n-        String mountPath = null;\n-        try (Stream<String> lines =\n-                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n-\n-            String l = lines.filter(line -> line.contains(\" - cgroup2 \"))\n-                            .collect(Collectors.joining());\n-            String[] tokens = l.split(\" \");\n-            mountPath = tokens[4];\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        } catch (IOException e) {\n-            return null;\n-        }\n-        String cgroupPath = null;\n-        try {\n-            List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(\"\/proc\/self\/cgroup\"));\n-            for (String line: lines) {\n-                String[] tokens = line.split(\":\");\n-                if (tokens.length != 3) {\n-                    return null; \/\/ something is not right.\n-                }\n-                if (!\"0\".equals(tokens[0])) {\n-                    \/\/ hierarchy must be zero for cgroups v2\n-                    return null;\n+    \/**\n+     * Get the singleton instance of a cgroups v2 subsystem. On initialization,\n+     * a new object from the given cgroup information 'anyController' is being\n+     * created. Note that the cgroup information has been parsed from cgroup\n+     * interface files ahead of time.\n+     *\n+     * See CgroupSubsystemFactory.determineType() for the cgroup interface\n+     * files parsing logic.\n+     *\n+     * @return A singleton CgroupSubsystem instance, never null.\n+     *\/\n+    public static CgroupSubsystem getInstance(CgroupInfo anyController) {\n+        if (INSTANCE == null) {\n+            CgroupSubsystemController unified = new CgroupV2SubsystemController(\n+                    anyController.getMountPoint(),\n+                    anyController.getCgroupPath());\n+            CgroupV2Subsystem tmpCgroupSystem = new CgroupV2Subsystem(unified);\n+            synchronized (CgroupV2Subsystem.class) {\n+                if (INSTANCE == null) {\n+                    INSTANCE = tmpCgroupSystem;\n@@ -90,2 +83,0 @@\n-                cgroupPath = tokens[2];\n-                break;\n@@ -93,4 +84,0 @@\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        } catch (IOException e) {\n-            return null;\n@@ -98,7 +85,0 @@\n-        CgroupSubsystemController unified = new CgroupV2SubsystemController(\n-                mountPath,\n-                cgroupPath);\n-        return new CgroupV2Subsystem(unified);\n-    }\n-\n-    public static CgroupSubsystem getInstance() {\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":22,"deletions":42,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+import static org.junit.Assert.assertEquals;\n@@ -37,0 +38,1 @@\n+import jdk.internal.platform.CgroupInfo;\n@@ -64,0 +66,3 @@\n+    private Path cgroupv1SelfCgroup;\n+    private Path cgroupv2SelfCgroup;\n+    private Path cgroupv1SelfCgroupJoinCtrl;\n@@ -80,0 +85,11 @@\n+    private String selfCgroupNonZeroJoinControllers =\n+            \"9:cpuset:\/\\n\" +\n+            \"8:perf_event:\/\\n\" +\n+            \"7:rdma:\/\\n\" +\n+            \"6:freezer:\/\\n\" +\n+            \"5:blkio:\/user.slice\\n\" +\n+            \"4:pids:\/user.slice\/user-1000.slice\/session-3.scope\\n\" +\n+            \"3:devices:\/user.slice\\n\" +\n+            \"2:cpu,cpuacct,memory,net_cls,net_prio,hugetlb:\/user.slice\/user-1000.slice\/session-3.scope\\n\" +\n+            \"1:name=systemd:\/user.slice\/user-1000.slice\/session-3.scope\\n\" +\n+            \"0::\/user.slice\/user-1000.slice\/session-3.scope\\n\";\n@@ -139,0 +155,13 @@\n+    private String cgroupv1SelfCgroupContent = \"11:memory:\/user.slice\/user-1000.slice\/user@1000.service\\n\" +\n+            \"10:hugetlb:\/\\n\" +\n+            \"9:cpuset:\/\\n\" +\n+            \"8:pids:\/user.slice\/user-1000.slice\/user@1000.service\\n\" +\n+            \"7:freezer:\/\\n\" +\n+            \"6:blkio:\/\\n\" +\n+            \"5:net_cls,net_prio:\/\\n\" +\n+            \"4:devices:\/user.slice\\n\" +\n+            \"3:perf_event:\/\\n\" +\n+            \"2:cpu,cpuacct:\/\\n\" +\n+            \"1:name=systemd:\/user.slice\/user-1000.slice\/user@1000.service\/apps.slice\/apps-org.gnome.Terminal.slice\/vte-spawn-3c00b338-5b65-439f-8e97-135e183d135d.scope\\n\" +\n+            \"0::\/user.slice\/user-1000.slice\/user@1000.service\/apps.slice\/apps-org.gnome.Terminal.slice\/vte-spawn-3c00b338-5b65-439f-8e97-135e183d135d.scope\\n\";\n+    private String cgroupv2SelfCgroupContent = \"0::\/user.slice\/user-1000.slice\/session-2.scope\";\n@@ -174,0 +203,9 @@\n+\n+            cgroupv1SelfCgroup = Paths.get(existingDirectory.toString(), \"self_cgroup_cgv1\");\n+            Files.writeString(cgroupv1SelfCgroup, cgroupv1SelfCgroupContent);\n+\n+            cgroupv2SelfCgroup = Paths.get(existingDirectory.toString(), \"self_cgroup_cgv2\");\n+            Files.writeString(cgroupv2SelfCgroup, cgroupv2SelfCgroupContent);\n+\n+            cgroupv1SelfCgroupJoinCtrl = Paths.get(existingDirectory.toString(), \"self_cgroup_cgv1_join_controllers\");\n+            Files.writeString(cgroupv1SelfCgroupJoinCtrl, selfCgroupNonZeroJoinControllers);\n@@ -192,1 +230,2 @@\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv1SelfCgroupJoinCtrl.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -197,0 +236,2 @@\n+        CgroupInfo memoryInfo = res.getInfos().get(\"memory\");\n+        assertEquals(\"\/user.slice\/user-1000.slice\/session-3.scope\", memoryInfo.getCgroupPath());\n@@ -203,1 +244,2 @@\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv1SelfCgroup.toString(); \/\/ Content doesn't matter\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -217,1 +259,2 @@\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv1SelfCgroup.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -222,0 +265,3 @@\n+        CgroupInfo cpuSetInfo = res.getInfos().get(\"cpuset\");\n+        assertEquals(\"\/sys\/fs\/cgroup\/cpuset\", cpuSetInfo.getMountPoint());\n+        assertEquals(\"\/\", cpuSetInfo.getMountRoot());\n@@ -228,1 +274,2 @@\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv1SelfCgroup.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -233,0 +280,4 @@\n+        CgroupInfo memoryInfo = res.getInfos().get(\"memory\");\n+        assertEquals(\"\/user.slice\/user-1000.slice\/user@1000.service\", memoryInfo.getCgroupPath());\n+        assertEquals(\"\/\", memoryInfo.getMountRoot());\n+        assertEquals(\"\/sys\/fs\/cgroup\/memory\", memoryInfo.getMountPoint());\n@@ -239,1 +290,2 @@\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv1SelfCgroup.toString(); \/\/ Content doesn't matter\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -248,1 +300,2 @@\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv2SelfCgroup.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -254,0 +307,7 @@\n+        CgroupInfo memoryInfo = res.getInfos().get(\"memory\");\n+        assertEquals(\"\/user.slice\/user-1000.slice\/session-2.scope\", memoryInfo.getCgroupPath());\n+        CgroupInfo cpuInfo = res.getInfos().get(\"cpu\");\n+        assertEquals(memoryInfo.getCgroupPath(), cpuInfo.getCgroupPath());\n+        assertEquals(memoryInfo.getMountPoint(), cpuInfo.getMountPoint());\n+        assertEquals(memoryInfo.getMountRoot(), cpuInfo.getMountRoot());\n+        assertEquals(\"\/sys\/fs\/cgroup\", cpuInfo.getMountPoint());\n@@ -259,0 +319,1 @@\n+        String selfCgroup = cgroupv1SelfCgroup.toString(); \/\/ any existing file\n@@ -261,1 +322,1 @@\n-        CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -268,1 +329,10 @@\n-        CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv2SelfCgroup.toString(); \/\/ any existing file\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+    }\n+\n+    @Test(expected = IOException.class)\n+    public void selfCgroupsFileNotFound() throws IOException {\n+        String cgroups = cgroupv1CgInfoZeroHierarchy.toString(); \/\/ any existing file\n+        String mountInfo = cgroupv2MntInfoZeroHierarchy.toString(); \/\/ any existing file\n+        String selfCgroup = Paths.get(existingDirectory.toString(), \"not-existing-self-cgroups\").toString();\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemFactory.java","additions":78,"deletions":8,"binary":false,"changes":86,"status":"modified"}]}