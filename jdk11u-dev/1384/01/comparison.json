{"files":[{"patch":"@@ -2164,2 +2164,1 @@\n-  bool will_link;\n-  ciKlass* klass = stream()->get_klass(will_link);\n+  ciKlass* klass = stream()->get_klass();\n@@ -2180,2 +2179,1 @@\n-  bool will_link;\n-  ciKlass* klass = stream()->get_klass(will_link);\n+  ciKlass* klass = stream()->get_klass();\n@@ -2206,2 +2204,1 @@\n-  bool will_link;\n-  ciKlass* klass = stream()->get_klass(will_link);\n+  ciKlass* klass = stream()->get_klass();\n@@ -2227,2 +2224,1 @@\n-  bool will_link;\n-  ciKlass* klass = stream()->get_klass(will_link);\n+  ciKlass* klass = stream()->get_klass();\n@@ -2262,2 +2258,1 @@\n-  bool will_link;\n-  ciKlass* klass = stream()->get_klass(will_link);\n+  ciKlass* klass = stream()->get_klass();\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1240,0 +1240,31 @@\n+static bool is_patching_needed(JavaThread* current, Runtime1::StubID stub_id) {\n+  if (stub_id == Runtime1::load_klass_patching_id ||\n+      stub_id == Runtime1::load_mirror_patching_id) {\n+    \/\/ last java frame on stack\n+    vframeStream vfst(current, true);\n+    assert(!vfst.at_end(), \"Java frame must exist\");\n+\n+    methodHandle caller_method(current, vfst.method());\n+    int bci = vfst.bci();\n+    Bytecodes::Code code = caller_method()->java_code_at(bci);\n+\n+    switch (code) {\n+      case Bytecodes::_new:\n+      case Bytecodes::_anewarray:\n+      case Bytecodes::_multianewarray:\n+      case Bytecodes::_instanceof:\n+      case Bytecodes::_checkcast: {\n+        Bytecode bc(caller_method(), caller_method->bcp_from(bci));\n+        constantTag tag = caller_method->constants()->tag_at(bc.get_index_u2(code));\n+        if (tag.is_unresolved_klass_in_error()) {\n+          return false; \/\/ throws resolution error\n+        }\n+        break;\n+      }\n+\n+      default: break;\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -1251,5 +1282,6 @@\n-  \/\/ It's possible the nmethod was invalidated in the last\n-  \/\/ safepoint, but if it's still alive then make it not_entrant.\n-  nmethod* nm = CodeCache::find_nmethod(caller_frame.pc());\n-  if (nm != NULL) {\n-    nm->make_not_entrant();\n+  if (is_patching_needed(thread, stub_id)) {\n+    \/\/ Make sure the nmethod is invalidated, i.e. made not entrant.\n+    nmethod* nm = CodeCache::find_nmethod(caller_frame.pc());\n+    if (nm != NULL) {\n+      nm->make_not_entrant();\n+    }\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":37,"deletions":5,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"ci\/ciCallSite.hpp\"\n@@ -29,0 +28,2 @@\n+#include \"ci\/ciKlass.hpp\"\n+#include \"ci\/ciObjArrayKlass.hpp\"\n@@ -193,0 +194,19 @@\n+\/\/ ciBytecodeStream::get_klass\n+\/\/\n+\/\/ If this bytecode is a new, newarray, multianewarray, instanceof,\n+\/\/ or checkcast, get the referenced klass. Retuns an unloaded ciKlass\n+\/\/ if the referenced klass is not accessible.\n+ciKlass* ciBytecodeStream::get_klass() {\n+  bool will_link;\n+  ciKlass* klass = get_klass(will_link);\n+  if (!will_link && klass->is_loaded()) { \/\/ klass not accessible\n+    if (klass->is_array_klass()) {\n+      assert(!klass->is_type_array_klass(), \"\");\n+      klass = ciEnv::unloaded_ciobjarrayklass();\n+    } else {\n+      klass = ciEnv::unloaded_ciinstance_klass();\n+    }\n+  }\n+  return klass;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -236,0 +236,1 @@\n+  ciKlass* get_klass();\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    if (can_use_native_byte_order(bc, is_wide))\n+    if (can_use_native_byte_order(bc, is_wide)) {\n@@ -82,1 +82,3 @@\n-    else  return Bytes::get_Java_u2(p);\n+    } else {\n+      return Bytes::get_Java_u2(p);\n+    }\n","filename":"src\/hotspot\/share\/interpreter\/bytecode.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler\/c1;\n+\n+super public class KlassAccessCheck\n+  version 51:0\n+{\n+\n+  public static Method testNewInstance:\"()V\"\n+  stack 2 locals 0\n+  {\n+   new class compiler\/c1\/types\/PackagePrivateClass;\n+   return;\n+  }\n+\n+\n+  public static Method testNewArray:\"()[Ljava\/lang\/Object;\"\n+    stack 1 locals 0\n+  {\n+   iconst_1;\n+   anewarray class compiler\/c1\/types\/PackagePrivateClass;\n+   areturn;\n+  }\n+\n+  public static Method testMultiNewArray:\"()[[Ljava\/lang\/Object;\"\n+  stack 2 locals 1\n+  {\n+   iconst_1;\n+   iconst_1;\n+   multianewarray  class \"[[Lcompiler\/c1\/types\/PackagePrivateClass;\",  2;\n+   areturn;\n+  }\n+\n+  public static Method testCheckCast:\"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\"\n+  stack 1 locals 2\n+  {\n+   aload_0;\n+   checkcast class compiler\/c1\/types\/PackagePrivateClass;\n+   areturn;\n+  }\n+\n+  public static Method testCheckCastArr:\"(Ljava\/lang\/Object;)Ljava\/lang\/Object;\"\n+  stack 1 locals 2\n+  {\n+   aload_0;\n+   checkcast class \"[Lcompiler\/c1\/types\/PackagePrivateClass;\";\n+   areturn;\n+  }\n+\n+  public static Method testInstanceOf:\"(Ljava\/lang\/Object;)Z\"\n+  stack 1 locals 2\n+  {\n+   aload_0;\n+   instanceof class compiler\/c1\/types\/PackagePrivateClass;\n+   ireturn;\n+  }\n+\n+  public static Method testInstanceOfArr:\"(Ljava\/lang\/Object;)Z\"\n+  stack 1 locals 2\n+  {\n+   aload_0;\n+   instanceof class \"[Lcompiler\/c1\/types\/PackagePrivateClass;\";\n+   ireturn;\n+  }\n+} \/\/ end Class KlassAccessCheck\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/KlassAccessCheck.jasm","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler\/c1\/types;\n+\n+super class PackagePrivateClass\n+ version 51:0\n+{}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/KlassAccessCheckPackagePrivate.jasm","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8293044\n+ * @requires vm.compiler1.enabled\n+ * @compile KlassAccessCheckPackagePrivate.jasm\n+ * @compile KlassAccessCheck.jasm\n+ * @run main\/othervm -Xbatch -XX:TieredStopAtLevel=1 compiler.c1.KlassAccessCheckTest\n+ *\/\n+\n+package compiler.c1;\n+\n+public class KlassAccessCheckTest {\n+    static void test(Runnable r) {\n+        for (int i = 0; i < 1000; ++i) {\n+            try {\n+                r.run();\n+                throw new AssertionError(\"No IllegalAccessError thrown\");\n+            } catch (IllegalAccessError e) {\n+                \/\/ Expected\n+            } catch (AssertionError e) {\n+                throw e; \/\/ rethrow\n+            } catch (Throwable e) {\n+                throw new AssertionError(\"Wrong exception thrown\", e);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        test(() -> KlassAccessCheck.testNewInstance());\n+        test(() -> KlassAccessCheck.testNewArray());\n+        test(() -> KlassAccessCheck.testMultiNewArray());\n+        test(() -> KlassAccessCheck.testCheckCast(42));\n+        test(() -> KlassAccessCheck.testCheckCastArr(new Integer[0]));\n+        test(() -> KlassAccessCheck.testInstanceOf(42));\n+        test(() -> KlassAccessCheck.testInstanceOfArr(new Integer[0]));\n+        System.out.println(\"TEST PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/KlassAccessCheckTest.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"}]}