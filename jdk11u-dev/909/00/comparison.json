{"files":[{"patch":"@@ -24,1 +24,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,3 @@\n-                id = id.substring(i1+1, i2);\n+                if (i1 >= 0 && i2 >= 0) {\n+                    id = id.substring(i1 + 1, i2);\n+                }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMURIDereferencer.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,3 @@\n-            id = id.substring(i1+1, i2);\n+            if (i1 >= 0 && i2 >= 0) {\n+                id = id.substring(i1 + 1, i2);\n+            }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/Utils.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.security.XMLUtils;\n+\n+import javax.xml.crypto.URIReferenceException;\n+import javax.xml.crypto.dsig.XMLSignatureException;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.spec.ECGenParameterSpec;\n+\n+\/**\n+ * @test\n+ * @bug 8278186\n+ * @summary reject malformed xpointer(id('a')) gracefully\n+ * @library \/test\/lib\n+ * @modules java.xml.crypto\n+ *\/\n+public class BadXPointer {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"EC\");\n+        kpg.initialize(new ECGenParameterSpec(\"secp256r1\"));\n+        KeyPair kp = kpg.generateKeyPair();\n+\n+        var signer = XMLUtils.signer(kp.getPrivate(), kp.getPublic());\n+        var doc = XMLUtils.string2doc(\"<root\/>\");\n+\n+        \/\/ No enclosing ' for id\n+        Utils.runAndCheckException(\n+                () -> signer.signEnveloping(doc, \"a\", \"#xpointer(id('a))\"),\n+                ex -> Asserts.assertTrue(ex instanceof XMLSignatureException\n+                        && ex.getCause() instanceof URIReferenceException\n+                        && ex.getMessage().contains(\"Could not find a resolver\"),\n+                    ex.toString()));\n+    }\n+}\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/BadXPointer.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,578 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.security;\n+\n+import jdk.test.lib.Asserts;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.InputSource;\n+\n+import javax.xml.crypto.*;\n+import javax.xml.crypto.dom.DOMStructure;\n+import javax.xml.crypto.dsig.*;\n+import javax.xml.crypto.dsig.dom.DOMSignContext;\n+import javax.xml.crypto.dsig.dom.DOMValidateContext;\n+import javax.xml.crypto.dsig.keyinfo.*;\n+import javax.xml.crypto.dsig.spec.*;\n+import javax.xml.namespace.NamespaceContext;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathFactory;\n+import java.io.File;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.*;\n+import java.security.cert.X509Certificate;\n+import java.security.interfaces.RSAKey;\n+import java.security.spec.PSSParameterSpec;\n+import java.util.*;\n+\n+\/\/ A collection of test utility methods for parsing, validating and\n+\/\/ generating XML Signatures.\n+public class XMLUtils {\n+\n+    private static final XMLSignatureFactory FAC =\n+            XMLSignatureFactory.getInstance(\"DOM\");\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/ MAIN as TEST \/\/\/\/\/\/\/\/\/\/\/\/\n+    public static void main(String[] args) throws Exception {\n+        var x = \"<a><b>c<\/b>x<\/a>\";\n+        var p = Files.write(Path.of(\"x.xml\"), List.of(x));\n+        var b = Path.of(\"\").toUri().toString();\n+        var d = string2doc(x);\n+        \/\/ keytool -keystore ks -keyalg ec -storepass changeit -genkeypair -alias a -dname CN=a\n+        var pass = \"changeit\".toCharArray();\n+        var ks = KeyStore.getInstance(new File(\"ks\"), pass);\n+        var c = (X509Certificate) ks.getCertificate(\"a\");\n+        var pr = (PrivateKey) ks.getKey(\"a\", pass);\n+        var pu = c.getPublicKey();\n+        var s0 = signer(pr); \/\/ No KeyInfo\n+        var s1 = signer(pr, pu); \/\/ KeyInfo is PublicKey\n+        var s2 = signer(pr, c); \/\/ KeyInfo is X509Data\n+        var s3 = signer(ks, \"a\", pass); \/\/ KeyInfo is KeyName\n+        var v1 = validator(); \/\/ knows nothing\n+        var v2 = validator(ks); \/\/ knows KeyName\n+        Asserts.assertTrue(v1.validate(s0.sign(d), pu)); \/\/ need PublicKey\n+        Asserts.assertTrue(v1.validate(s1.sign(d))); \/\/ can read KeyInfo\n+        Asserts.assertTrue(v1.validate(s2.sign(d))); \/\/ can read KeyInfo\n+        Asserts.assertTrue(v2.validate(s3.sign(d))); \/\/ can read KeyInfo\n+        Asserts.assertTrue(v2.secureValidation(false).validate(s3.sign(p.toUri()))); \/\/ can read KeyInfo\n+        Asserts.assertTrue(v2.secureValidation(false).baseURI(b).validate(\n+                s3.sign(p.toAbsolutePath().getParent().toUri(), p.getFileName().toUri()))); \/\/ can read KeyInfo\n+        Asserts.assertTrue(v1.validate(s1.sign(\"text\"))); \/\/ plain text\n+        Asserts.assertTrue(v1.validate(s1.sign(\"binary\".getBytes()))); \/\/ raw data\n+        Asserts.assertTrue(v1.validate(s1.signEnveloping(d, \"x\", \"#x\")));\n+        Asserts.assertTrue(v1.validate(s1.signEnveloping(d, \"x\", \"#xpointer(id('x'))\")));\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/ CONVERT \/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    \/\/ Converts a Document object to string\n+    public static String doc2string(Document doc) throws Exception {\n+        TransformerFactory tf = TransformerFactory.newInstance();\n+        Transformer transformer = tf.newTransformer();\n+        transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"no\");\n+        \/\/ Indentation would invalidate the signature\n+        \/\/ transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+        StringWriter writer = new StringWriter();\n+        transformer.transform(new DOMSource(doc), new StreamResult(writer));\n+        return writer.getBuffer().toString();\n+    }\n+\n+    \/\/ Parses a string into a Document object\n+    public static Document string2doc(String input) throws Exception {\n+        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+        factory.setNamespaceAware(true);\n+        return factory.newDocumentBuilder().\n+                parse(new InputSource(new StringReader(input)));\n+    }\n+\n+    \/\/ Clones a document\n+    public static Document clone(Document d) throws Exception {\n+        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder db = dbf.newDocumentBuilder();\n+        Document copiedDocument = db.newDocument();\n+        Node copiedRoot = copiedDocument.importNode(d.getDocumentElement(), true);\n+        copiedDocument.appendChild(copiedRoot);\n+        return copiedDocument;\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/ QUERY AND EDIT \/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    \/\/ An XPath object that recognizes ds and pss names\n+    public static final XPath XPATH;\n+\n+    static {\n+        XPATH = XPathFactory.newInstance().newXPath();\n+        XPATH.setNamespaceContext(new NamespaceContext() {\n+            @Override\n+            public String getNamespaceURI(String prefix) {\n+                if (prefix.equals(\"ds\")) {\n+                    return \"http:\/\/www.w3.org\/2000\/09\/xmldsig#\";\n+                } else if (prefix.equals(\"pss\")) {\n+                    return \"http:\/\/www.w3.org\/2007\/05\/xmldsig-more#\";\n+                } else {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n+\n+            @Override\n+            public String getPrefix(String namespaceURI) {\n+                return null;\n+            }\n+\n+            @Override\n+            public Iterator<String> getPrefixes(String namespaceURI) {\n+                return null;\n+            }\n+        });\n+    }\n+\n+    \/\/ Returns an Element inside a Document\n+    public static Element sub(Document d, String path) throws Exception {\n+        return (Element) XMLUtils.XPATH.evaluate(path, d, XPathConstants.NODE);\n+    }\n+\n+    \/\/ Returns a new document with an attribute modified\n+    public static Document withAttribute(Document d, String path, String attr, String value) throws Exception {\n+        d = clone(d);\n+        sub(d, path).setAttribute(attr, value);\n+        return d;\n+    }\n+\n+    \/\/ Returns a new document with a text modified\n+    public static Document withText(Document d, String path, String value) throws Exception {\n+        d = clone(d);\n+        sub(d, path).setTextContent(value);\n+        return d;\n+    }\n+\n+    \/\/ Returns a new document without a child element\n+    public static Document withoutNode(Document d, String... paths) throws Exception {\n+        d = clone(d);\n+        for (String path : paths) {\n+            Element e = sub(d, path);\n+            e.getParentNode().removeChild(e);\n+        }\n+        return d;\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/ SIGN \/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    \/\/ Creates a signer from a private key and a certificate\n+    public static Signer signer(PrivateKey privateKey, X509Certificate cert)\n+            throws Exception {\n+        return signer(privateKey).cert(cert);\n+    }\n+\n+    \/\/ Creates a signer from a private key and a public key\n+    public static Signer signer(PrivateKey privateKey, PublicKey publicKey)\n+            throws Exception {\n+        return signer(privateKey).publicKey(publicKey);\n+    }\n+\n+    \/\/ Creates a signer from a private key entry in a keystore. The KeyInfo\n+    \/\/ inside the signature will only contain a KeyName to alias\n+    public static Signer signer(KeyStore ks, String alias, char[] password)\n+            throws Exception {\n+        return signer((PrivateKey) ks.getKey(alias, password))\n+                .keyName(alias);\n+    }\n+\n+    \/\/ Creates a signer from a private key. There will be no KeyInfo inside\n+    \/\/ the signature and must be validated with a given public key.\n+    public static Signer signer(PrivateKey privateKey)\n+            throws Exception {\n+        return new Signer(privateKey);\n+    }\n+\n+    public static class Signer {\n+\n+        PrivateKey privateKey;  \/\/ signer key, never null\n+        X509Certificate cert;   \/\/ certificate, optional\n+        PublicKey publicKey;    \/\/ public key, optional\n+        String keyName;         \/\/ alias, optional\n+\n+        SignatureMethod sm;     \/\/ default determined by privateKey\n+        DigestMethod dm;        \/\/ default SHA-256\n+        CanonicalizationMethod cm;  \/\/ default EXCLUSIVE\n+        Transform tr;           \/\/ default ENVELOPED\n+\n+        public Signer(PrivateKey privateKey) throws Exception {\n+            this.privateKey = privateKey;\n+            dm(DigestMethod.SHA256);\n+            tr(Transform.ENVELOPED);\n+            cm(CanonicalizationMethod.EXCLUSIVE);\n+            String alg = privateKey.getAlgorithm();\n+            if (alg.equals(\"RSASSA-PSS\")) {\n+                PSSParameterSpec pspec\n+                        = (PSSParameterSpec) ((RSAKey) privateKey).getParams();\n+                \/*\n+                if (pspec != null) {\n+                    sm(SignatureMethod.RSA_PSS, new RSAPSSParameterSpec(pspec));\n+                } else {\n+                    sm(SignatureMethod.RSA_PSS);\n+                }\n+                *\/\n+                throw new Exception(\"Code not expected to be used in tests for 11. Backport 8241306.\");\n+            } else {\n+                if (alg.equals(\"RSA\")) {\n+                    sm(SignatureMethod.RSA_SHA256);\n+                } else if (alg.equals(\"DSA\")) {\n+                    sm(SignatureMethod.DSA_SHA256);\n+                } else if (alg.equals(\"EC\")) {\n+                    sm(SignatureMethod.ECDSA_SHA256);\n+                } else {\n+                    throw new InvalidKeyException();\n+                }\n+            }\n+        }\n+\n+        \/\/ Change KeyInfo source\n+\n+        public Signer cert(X509Certificate cert) {\n+            this.cert = cert;\n+            return this;\n+        }\n+\n+        public Signer publicKey(PublicKey key) {\n+            this.publicKey = key;\n+            return this;\n+        }\n+\n+        public Signer keyName(String n) {\n+            keyName = n;\n+            return this;\n+        }\n+\n+        \/\/ Change various methods\n+\n+        public Signer tr(String transform) throws Exception {\n+            TransformParameterSpec params = null;\n+            switch (transform) {\n+                case Transform.XPATH:\n+                    params = new XPathFilterParameterSpec(\"\/\/.\");\n+                    break;\n+                case Transform.XPATH2:\n+                    params = new XPathFilter2ParameterSpec(\n+                            Collections.singletonList(new XPathType(\"\/\/.\",\n+                                    XPathType.Filter.INTERSECT)));\n+                    break;\n+            }\n+            tr = FAC.newTransform(transform, params);\n+            return this;\n+        }\n+\n+        public Signer sm(String method) throws Exception {\n+            sm = FAC.newSignatureMethod(method, null);\n+            return this;\n+        }\n+\n+        public Signer dm(String method) throws Exception {\n+            dm = FAC.newDigestMethod(method, null);\n+            return this;\n+        }\n+\n+        public Signer cm(String method) throws Exception {\n+            cm = FAC.newCanonicalizationMethod(method, (C14NMethodParameterSpec) null);\n+            return this;\n+        }\n+\n+        public Signer sm(String method, SignatureMethodParameterSpec spec)\n+                throws Exception {\n+            sm = FAC.newSignatureMethod(method, spec);\n+            return this;\n+        }\n+\n+        public Signer dm(String method, DigestMethodParameterSpec spec)\n+                throws Exception {\n+            dm = FAC.newDigestMethod(method, spec);\n+            return this;\n+        }\n+\n+        \/\/ Signs different sources\n+\n+        \/\/ Signs an XML file in detached mode\n+        public Document sign(URI uri) throws Exception {\n+            Document newDocument = DocumentBuilderFactory.newInstance()\n+                    .newDocumentBuilder().newDocument();\n+            FAC.newXMLSignature(buildSignedInfo(uri.toString()), buildKeyInfo()).sign(\n+                    new DOMSignContext(privateKey, newDocument));\n+            return newDocument;\n+        }\n+\n+        \/\/ Signs an XML file in a relative reference in detached mode\n+        public Document sign(URI base, URI ref) throws Exception {\n+            Document newDocument = DocumentBuilderFactory.newInstance()\n+                    .newDocumentBuilder().newDocument();\n+            DOMSignContext ctxt = new DOMSignContext(privateKey, newDocument);\n+            ctxt.setBaseURI(base.toString());\n+            FAC.newXMLSignature(buildSignedInfo(ref.toString()), buildKeyInfo()).sign(ctxt);\n+            return newDocument;\n+        }\n+\n+        \/\/ Signs a document in enveloped mode\n+        public Document sign(Document document) throws Exception {\n+            DOMResult result = new DOMResult();\n+            TransformerFactory.newInstance().newTransformer()\n+                    .transform(new DOMSource(document), result);\n+            Document newDocument = (Document) result.getNode();\n+            FAC.newXMLSignature(buildSignedInfo(\"\"), buildKeyInfo()).sign(\n+                    new DOMSignContext(privateKey, newDocument.getDocumentElement()));\n+            return newDocument;\n+        }\n+\n+        \/\/ Signs a document in enveloping mode\n+        public Document signEnveloping(Document document, String id, String ref) throws Exception {\n+            Document newDocument = DocumentBuilderFactory.newInstance()\n+                    .newDocumentBuilder().newDocument();\n+            FAC.newXMLSignature(\n+                    buildSignedInfo(FAC.newReference(ref, dm)),\n+                    buildKeyInfo(),\n+                    List.of(FAC.newXMLObject(List.of(new DOMStructure(document.getDocumentElement())),\n+                            id, null, null)),\n+                    null,\n+                    null)\n+                    .sign(new DOMSignContext(privateKey, newDocument));\n+            return newDocument;\n+        }\n+\n+        \/\/ Signs a raw byte array\n+        public Document sign(byte[] data) throws Exception {\n+            Document newDocument = DocumentBuilderFactory.newInstance()\n+                    .newDocumentBuilder().newDocument();\n+            FAC.newXMLSignature(\n+                    buildSignedInfo(FAC.newReference(\"#object\", dm, List.of\n+                            (FAC.newTransform(Transform.BASE64,\n+                                    (TransformParameterSpec) null)), null, null)),\n+                    buildKeyInfo(),\n+                    List.of(FAC.newXMLObject(List.of(new DOMStructure(\n+                            newDocument.createTextNode(Base64.getEncoder().encodeToString(data)))),\n+                            \"object\", null, null)),\n+                    null,\n+                    null)\n+                    .sign(new DOMSignContext(privateKey, newDocument));\n+            return newDocument;\n+        }\n+\n+        \/\/ Signs a plain string\n+        public Document sign(String str) throws Exception {\n+            Document newDocument = DocumentBuilderFactory.newInstance()\n+                    .newDocumentBuilder().newDocument();\n+            FAC.newXMLSignature(\n+                    buildSignedInfo(FAC.newReference(\"#object\", dm)),\n+                    buildKeyInfo(),\n+                    List.of(FAC.newXMLObject(List.of(new DOMStructure(newDocument.createTextNode(str))),\n+                            \"object\", null, null)),\n+                    null,\n+                    null)\n+                    .sign(new DOMSignContext(privateKey, newDocument));\n+            return newDocument;\n+        }\n+\n+        \/\/ Builds a SignedInfo for a string reference\n+        private SignedInfo buildSignedInfo(String ref) {\n+            return FAC.newSignedInfo(\n+                    cm,\n+                    sm,\n+                    List.of(FAC.newReference(\n+                            ref,\n+                            dm,\n+                            List.of(tr),\n+                            null, null)));\n+        }\n+\n+        \/\/ Builds a SignedInfo for a Reference\n+        private SignedInfo buildSignedInfo(Reference ref) {\n+            return FAC.newSignedInfo(\n+                    cm,\n+                    sm,\n+                    List.of(ref));\n+        }\n+\n+        \/\/ Builds a KeyInfo from different sources\n+        private KeyInfo buildKeyInfo() throws Exception {\n+            KeyInfoFactory keyInfoFactory = FAC.getKeyInfoFactory();\n+            if (cert != null) {\n+                return keyInfoFactory.newKeyInfo(List.of(\n+                        keyInfoFactory.newX509Data(List.of(cert))));\n+            } else if (publicKey != null) {\n+                return keyInfoFactory.newKeyInfo(List.of(\n+                        keyInfoFactory.newKeyValue(publicKey)));\n+            } else if (keyName != null) {\n+                return keyInfoFactory.newKeyInfo(List.of(\n+                        keyInfoFactory.newKeyName(keyName)));\n+            } else {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/ VALIDATE \/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    \/\/ Create a Validator, ks will be used if there is a KeyName\n+    public static Validator validator(KeyStore ks)\n+            throws Exception {\n+        return new Validator(ks);\n+    }\n+\n+    \/\/ Create a Validator, key will either be inside KeyInfo or\n+    \/\/ a key will be provided when validate() is called\n+    public static Validator validator()\n+            throws Exception {\n+        return new Validator(null);\n+    }\n+\n+    public static class Validator {\n+\n+        private Boolean secureValidation = null;\n+        private String baseURI = null;\n+        private final KeyStore ks;\n+\n+        public Validator(KeyStore ks) {\n+            this.ks = ks;\n+        }\n+\n+        public Validator secureValidation(boolean v) {\n+            this.secureValidation = v;\n+            return this;\n+        }\n+\n+        public Validator baseURI(String base) {\n+            this.baseURI = base;\n+            return this;\n+        }\n+\n+        public boolean validate(Document document) throws Exception {\n+            return validate(document, null);\n+        }\n+\n+        \/\/ If key is not null, any key from the signature will be ignored\n+        public boolean validate(Document document, PublicKey key)\n+                throws Exception {\n+            NodeList nodeList = document.getElementsByTagNameNS(XMLSignature.XMLNS, \"Signature\");\n+            if (nodeList.getLength() == 1) {\n+                Node signatureNode = nodeList.item(0);\n+                if (signatureNode != null) {\n+                    KeySelector ks = key == null ? new MyKeySelector(this.ks) : new KeySelector() {\n+                        @Override\n+                        public KeySelectorResult select(KeyInfo ki, Purpose p,\n+                                AlgorithmMethod m, XMLCryptoContext c) {\n+                            return () -> key;\n+                        }\n+                    };\n+                    DOMValidateContext valContext\n+                            = new DOMValidateContext(ks, signatureNode);\n+                    if (baseURI != null) {\n+                        valContext.setBaseURI(baseURI);\n+                    }\n+                    if (secureValidation != null) {\n+                        valContext.setProperty(\"org.jcp.xml.dsig.secureValidation\",\n+                                secureValidation);\n+                        valContext.setProperty(\"org.apache.jcp.xml.dsig.secureValidation\",\n+                                secureValidation);\n+                    }\n+                    return XMLSignatureFactory.getInstance(\"DOM\")\n+                            .unmarshalXMLSignature(valContext).validate(valContext);\n+                }\n+            }\n+            return false;\n+        }\n+\n+        \/\/ Find public key from KeyInfo, ks will be used if it's KeyName\n+        private static class MyKeySelector extends KeySelector {\n+            private final KeyStore ks;\n+\n+            public MyKeySelector(KeyStore ks) {\n+                this.ks = ks;\n+            }\n+\n+            public KeySelectorResult select(KeyInfo keyInfo,\n+                                            KeySelector.Purpose purpose,\n+                                            AlgorithmMethod method,\n+                                            XMLCryptoContext context)\n+                    throws KeySelectorException {\n+                Objects.requireNonNull(keyInfo, \"Null KeyInfo object!\");\n+\n+                for (XMLStructure xmlStructure : keyInfo.getContent()) {\n+                    PublicKey pk;\n+                    if (xmlStructure instanceof KeyValue) {\n+                        KeyValue kv = (KeyValue) xmlStructure;\n+                        try {\n+                            pk = kv.getPublicKey();\n+                        } catch (KeyException ke) {\n+                            throw new KeySelectorException(ke);\n+                        }\n+                        return () -> pk;\n+                    } else if (xmlStructure instanceof X509Data) {\n+                        X509Data x509 = (X509Data)xmlStructure;\n+                        for (Object data : x509.getContent()) {\n+                            if (data instanceof X509Certificate) {\n+                                pk = ((X509Certificate) data).getPublicKey();\n+                                return () -> pk;\n+                            }\n+                        }\n+                    } else if (xmlStructure instanceof KeyName) {\n+                        KeyName kn = (KeyName)xmlStructure;\n+                        try {\n+                            pk = ks.getCertificate(kn.getName()).getPublicKey();\n+                        } catch (KeyStoreException e) {\n+                            throw new KeySelectorException(e);\n+                        }\n+                        return () -> pk;\n+                    }\n+                }\n+                throw new KeySelectorException(\"No KeyValue element found!\");\n+            }\n+        }\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/\/\/ MISC \/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    \/**\n+     * Adds a new rule to \"jdk.xml.dsig.secureValidationPolicy\"\n+     *\/\n+    public static void addPolicy(String rule) {\n+        String value = Security.getProperty(\"jdk.xml.dsig.secureValidationPolicy\");\n+        value = rule + \",\" + value;\n+        Security.setProperty(\"jdk.xml.dsig.secureValidationPolicy\", value);\n+    }\n+\n+    private XMLUtils() {\n+        assert false : \"No one instantiates me\";\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/security\/XMLUtils.java","additions":578,"deletions":0,"binary":false,"changes":578,"status":"added"}]}