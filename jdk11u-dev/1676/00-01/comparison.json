{"files":[{"patch":"@@ -1,218 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.cms;\n-\n-\/* @test TestJStatCMS\n- * @bug 8300742\n- * @comment Graal does not support CMS\n- * @requires vm.gc.ConcMarkSweep & !vm.graal.enabled\n- * @library \/test\/lib \/\n- * @summary Tests that jstat GCCT(sun.gc.collector.2.time) equals the sum of InitMark and Remark times in gc log.\n- * @modules java.base\/jdk.internal.misc\n- *          jdk.internal.jvmstat\/sun.jvmstat.monitor\n- * @run main\/othervm\/timeout=300 gc.cms.TestJStatCMS\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.Platform;\n-import gc.testlibrary.PerfCounter;\n-import gc.testlibrary.PerfCounters;\n-import java.lang.management.*;\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.Random;\n-\n-public class TestJStatCMS {\n-    final static int tolerance = 3; \/\/ percentae of the tolerance for the differeance between gc log and jstat\n-\n-    public static void main(String[] args) throws Exception {\n-        if (args.length != 0) {\n-            int MX = Integer.parseInt(args[0]); \/\/ pass -Xmx\n-            test(MX);\n-            return;\n-        }\n-\n-        \/* Run an application which cause lots of CMSGC, and print the gc log and jstat log *\/\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-             \"-Xms64m\",\n-             \"-Xmx64m\",\n-             \"-XX:+UsePerfData\",\n-             \"-XX:+UseConcMarkSweepGC\",\n-             \"-Xlog:gc\",\n-             \"gc.cms.TestJStatCMS\",\n-             \"64\"    \/\/ MaxHeapSize\n-             );\n-\n-        \/* Analize that jstat CGCT equals GC log. *\/\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-\n-        \/\/ Parse CMGC Inital Mark and Remark logs from the -Xlog:gc log.\n-        \/\/  [0.281s][info][gc] GC(2) Pause Initial Mark 33M->33M(61M) 1.562ms\n-        \/\/  [0.695s][info][gc] GC(2) Pause Remark 44M->44M(62M) 1.712ms\n-        String regexInitMark = \"Pause Initial Mark .+\\\\) [0-9]+\\\\.[0-9]+ms\";\n-        String regexReMark = \"Pause Remark .+\\\\) [0-9]+\\\\.[0-9]+ms\";\n-        Pattern patternInitMark = Pattern.compile(regexInitMark);\n-        Pattern patternReMark = Pattern.compile(regexReMark);\n-\n-        \/\/ Parse jstat CGC and CGCT which are printed at test().\n-        \/\/  jstatCGC=6109\n-        \/\/  jstatCGCT=7555.883219794695ms\n-        String regexJstatCGC = \"jstatCGC=[0-9]+\";\n-        String regexJstatCGCT = \"jstatCGCT=[0-9]+\\\\.[0-9]+ms\";\n-        Pattern patternJstatCGC = Pattern.compile(regexJstatCGC);\n-        Pattern patternJstatCGCT = Pattern.compile(regexJstatCGCT);\n-\n-        \/\/ Parse invocations and times\n-        String regexInvocations =  \"[0-9]+\";\n-        String regexTimeMS =  \"[0-9]+\\\\.[0-9]+\";\n-        Pattern patternInvocations = Pattern.compile(regexInvocations);\n-        Pattern patternTimeMS = Pattern.compile(regexTimeMS);\n-\n-        double cmsGGlogPauseTime = 0.0d;\n-        long cmsGGlogPauseInvocations = 0L;\n-        double jstatCGCT = 0.0d;\n-        long jstatCGC = 0L;\n-\n-        \/* Read std output by line. *\/\n-        Iterator<String> lines = output.asLines().iterator();\n-        while (lines.hasNext()) {\n-            String line = lines.next();\n-            \/\/ gc:log\n-            Matcher m1 = patternInitMark.matcher(line);\n-            Matcher m2 = patternReMark.matcher(line);\n-            String pauseLog = null;\n-            if (m1.find()) {\n-                pauseLog = m1.group();\n-            }\n-            else if (m2.find()) {\n-                 pauseLog = m2.group();\n-            }\n-            if (pauseLog != null) {\n-                Matcher m = patternTimeMS.matcher(pauseLog);\n-                if (m.find()) {\n-                    String timeLog = m.group();\n-                    ++cmsGGlogPauseInvocations;\n-                    cmsGGlogPauseTime += Double.parseDouble(timeLog);\n-                }\n-            }\n-\n-            \/\/ jstat\n-            Matcher m3 = patternJstatCGC.matcher(line);\n-            Matcher m4 = patternJstatCGCT.matcher(line);\n-            if (m3.find()) {\n-                String jstatCGCLog = m3.group();\n-                if (jstatCGCLog != null) {\n-                    Matcher m = patternInvocations.matcher(jstatCGCLog);\n-                    if (m.find()) {\n-                        String invocations = m.group();\n-                        jstatCGC = Long.parseLong(invocations);\n-                    }\n-                }\n-            }\n-            if (m4.find()) {\n-                String jstatCGCTLog = m4.group();\n-                if (jstatCGCTLog != null) {\n-                    Matcher m = patternTimeMS.matcher(jstatCGCTLog);\n-                    if (m.find()) {\n-                        String time = m.group();\n-                        jstatCGCT = Double.parseDouble(time);\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/* Check that GC log and jstat are equal *\/\n-        \/\/ gc:log\n-        System.out.println(\"cmsGGlogPauseInvocations=\" + cmsGGlogPauseInvocations);\n-        System.out.println(\"cmsGGlogPauseTime=\" + cmsGGlogPauseTime + \"ms\");\n-        \/\/ jstat\n-        System.out.println(\"jstat CGT=\" + jstatCGC);\n-        System.out.println(\"jstat CGCT=\" + jstatCGCT + \"ms\");\n-\n-        double ratio = jstatCGCT \/ cmsGGlogPauseTime;\n-        System.out.println(\"jstat\/loggc=\" + ratio);\n-        if (cmsGGlogPauseInvocations != jstatCGC) {\n-           throw new RuntimeException(\"jstat CGC \" + jstatCGC + \" is not equal to GC log \" + cmsGGlogPauseInvocations);\n-        }\n-        if ( Math.abs(1.0d-ratio) > (tolerance\/100.0d) ) {\n-           throw new RuntimeException(\"jstat CGCT \" + jstatCGCT + \" is not equal GC log \" + cmsGGlogPauseTime + \", the difference(\" + ratio + \") is larger than \" + tolerance + \"%.\");\n-        }\n-    }\n-\n-    private static void test(int MX) throws Exception {\n-        \/\/ Causes lots of CMSGC\n-        CMSGCALot.consumeHeap(MX);\n-         \/\/ System.gc();\n-\n-        \/\/ Get CMSGC puase time and invocations from PerfData which equals jstat CGCT, and print them to std output.\n-        long CGCT = PerfCounters.findByName(\"sun.gc.collector.2.time\").longValue();\n-        long CGC = PerfCounters.findByName(\"sun.gc.collector.2.invocations\").longValue();\n-        long frequency = PerfCounters.findByName(\"sun.os.hrt.frequency\").longValue();\n-        System.out.println(\"frequency:\" + frequency);\n-        System.out.println(\"jstatCGCT=\" + ((double)CGCT \/ (double)frequency) * 1000 + \"ms\");\n-        System.out.println(\"jstatCGC=\" + CGC);\n-    }\n-}\n-\n-class CMSGCALot\n-{\n-    private static ArrayList arrayList;\n-    private static TmpClass[] tmp = new TmpClass[1024];\n-\n-    static void consumeHeap(int MX) throws Exception {\n-\n-        Random rand = new Random();\n-        arrayList = new ArrayList();\n-\n-        int notFreed = (int)(MX * 0.65);\n-        \/\/ Use 0.65% of -Xmx which is not freed\n-        for (int i = 0 ; i < (1024 * notFreed) ; i++) { \/\/ Allocate 1K * 1024 * (MX*0.65) bytes\n-            byte[] b = new byte[1024];                  \/\/ For instance, if MX=64mx,\n-            arrayList.add(b);                           \/\/ consume 1K * 1024 * (64*0.65) = 41.6MB\n-        }\n-\n-        \/\/ Use 0.35% of -Xmx which is freed\n-        for (int i = 0 ; i < 1000 ; i++) { \/\/ new 1000 * 100000 * 1KB = 100GB which is freed by GC\n-            Thread.sleep(10);\n-            for (int j = 0 ; j < 100000 ; j++) {\n-                tmp[rand.nextInt(1024)] = new TmpClass(1);  \/\/ The alive objects are at most 1KB * 1024 bytes\n-            }                                               \/\/ and the other objects are freed by GC.\n-        }\n-    }\n-\n-    static class TmpClass\n-    {\n-        ArrayList arrayList;\n-        TmpClass(int n) {\n-            arrayList = new ArrayList();\n-            for (int i = 0 ; i < n ; ++i) {\n-                byte[] b = new byte[1024];    \/\/ new 1KB\n-                arrayList.add(b);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/cms\/TestJStatCMS.java","additions":0,"deletions":218,"binary":false,"changes":218,"status":"deleted"}]}